/* rexx procedure */
        ver = "1.25"
        /* --------------------------------------------------------- *
         *                                                           *
         * Name:      XML2COB                                        *
         *                                                           *
         * Function:  Convert a XML file to a COBOL copybook.        *
         *                                                           *
         * Syntax:    XML2COB   XML xml-ds     (or DD:xml-ddname)    *
         *                      COB cob-ds     (or DD:cob-ddname)    *
         *                      PREFIX  prefix (see below)           *
         *                      ROUND          (see below)           *
         *                      LEVEL01        (see below)           *
         *                      VERBOSE        (display messages)    *
         *                      BROWSE         (will browse report)  *
         *                                                           *
         *  (MVS)     if no parameters and under ISPF then the ISPF  *
         *            dialog will be invoked.                        *
         *                                                           *
         *            Where:                                         *
         *                                                           *
         * ------------------- Mandatory --------------------------- *
         *                                                           *
         *  (MVS)     xml_ds    is a sequential dataset or member of *
         *                      a partitioned dataset                *
         *                                                           *
         *  (MVS)               or dd:ddname                         *
         *                                                           *
         *  (WIN/UNIX)          or a file                            *
         *                                                           *
         *                                                           *
         *  (MVS)     cob_ds    is a sequential dataset or member of *
         *                      a partitioned dataset                *
         *                                                           *
         *  (MVS)               or dd:ddname                         *
         *                                                           *
         *  (WIN/UNIX)          or a file                            *
         *                                                           *
         * ------------------- Optional ---------------------------- *
         *                                                           *
         *            prefix    a leading string to be removed from  *
         *                      the XML element                      *
         *                                                           *
         *                                                           *
         *            round     to round length of COBOL items to    *
         *                      the next 5 or 0. I.e., if length     *
         *                      equals 16, then it will become 20.   *
         *                                                           *
         *                                                           *
         *            level01   If specified, COBOL copybook level   *
         *                      will start at 1. Otherwise, it will  *
         *                      start, by default, at level 02.      *
         *                                                           *
         *                                                           *
         *            browse    (will browse report) only used       *
         *                      under ISPF for use by the ISPF       *
         *                      interface                            *
         *                                                           *
         *                                                           *
         *            verbose   all messages will be displayed.      *
         *                                                           *
         *                                                           *
         * Functions:                                                *
         *                                                           *
         *  additem   additem(element, content) where                *
         *            element   is the XML element name to added to  *
         *                      the COBOL item list.                 *
         *            content   is the XML content used to extract   *
         *                      the meta-data (length, type, sign,   *
         *                      ...) of the COBOL item.              *
         *                                                           *
         *  dropitem  dropitem(item_nbr) where                       *
         *            item_nbr  is the item number to be removed     *
         *                      from the COBOL item list.            *
         *                                                           *
         *                                                           *
         * --------------------------------------------------------- *
         *                                                           *
         * Author(s): Lionel B. Dyck                                 *
         *            Kaiser Permanente Information Technology       *
         *            Walnut Creek, CA 94598                         *
         *            (925) 926-5332                                 *
         *            Internet: lionel.b.dyck@kp.org                 *
         *                                                           *
         *            Pierre Delaunoy                                *
         *            Belgium                                        *
         *            Mail: sunuraxi@users.sourceforge.net           *
         *                                                           *
         * Web:       http://sourceforge.net/projects/txt2xml-rexx/  *
         *                                                           *
         * Doc:       See the documentation directory or dataset     *
         *                                                           *
         *---------------------------------------------------------- */

         parse arg option
         i = time("R")        /* set start ot time */

        /* --------------------------------------------------------- *
         * Global variables                                          *
         * --------------------------------------------------------- */
         msgid = "XML2COB:"   /* Default message identifier */
         r = 0                /* Used for reporting */
         browse = 0           /* Used for reporting */
         confirm = 0          /* Used for reporting */
         rpt.1 = ""           /* Used for reporting */
         exit_rc = 0          /* return code on exit  */
         rexx_os = ""         /* Operating system running rexx*/
         ret = 0              /* flag to return instead of exit
                                 at end of PGM */
         level.0 = 0          /* level of COBOL item */
         name.1 = ""          /* name of COBOL item */
         type.1 = ""          /* type of COBOL item */
         length.1 = 0         /* length of COBOL item */
         start_pos.1 = 0      /* starting position of COBOL item */
         sign.1 = ""          /* sign flag of COBOL item */
         occurs.1 = 0         /* occcurence of COBOL item */
         nb_items = 0         /* number of COBOL items */
         prefix = ""          /* prefix of an XML element name */
         round = ""           /* to round item length to the next 5 or 0 */
         level01 = ""         /* to start COBOL copybook at level 01 */
         cob_lines = 0        /* number of COBOL copybook lines */
         cob. = ""            /* Generated COBOL copybook */
         cobol_length = 0     /* Total length of the COBOL record in bytes  */
         current_level = 0    /* COBOL current level */
         level_increment = 0  /* COBOL level increment */
         nb_first_child = 0   /* number of XML first child element */
         total_items = 0      /* total number of COBOL items */
                              /* COBOL reserved words according to IBM's
                                 "Enterprise COBOL for z/OS V3R3
                                 Language Reference "(IGY3LR20) */
         reserved_words = ,
           "AFTER ALIGNED ALL ALLOCATE ALPHABET ALPHABETIC",
           "ALPHABETIC-LOWER ALPHABETIC-UPPER ALPHANUMERIC",
           "ALPHANUMERIC-EDITED ALSO ALTER",
           "ALTERNATE AND ANY ANYCASE APPLY ARE",
           "AREA AREAS AS ASCENDING ASSIGN AT",
           "AUTHOR B-AND B-NOT B-OR B-XOR BASED",
           "BASIS BEFORE BEGINNING BINARY BINARY-CHAR BINARY-DOUBLE",
           "BINARY-LONG BINARY-SHORT BIT BLANK BLOCK BOOLEAN",
           "BOTTOM BY CALL CANCEL CBL CD",
           "CF CH CHARACTER CHARACTERS CLASS CLASS-ID",
           "CLOCK-UNITS CLOSE COBOL CODE CODE-SET COL",
           "COLLATING COLS COLUMN COLUMNS COM-REG COMMA",
           "COMMON COMMUNICATION COMP COMP-1 COMP-2 COMP-3",
           "COMP-4 COMP-5 COMPUTATIONAL COMPUTATIONAL-1",
           "COMPUTATIONAL-2 COMPUTATIONAL-3",
           "COMPUTATIONAL-4 COMPUTATIONAL-5 COMPUTE CONDITION",
           "CONFIGURATION CONSTANT",
           "CONTAINS CONTENT CONTINUE CONTROL CONTROLS CONVERTING",
           "COPY CORR CORRESPONDING COUNT CRT CURRENCY",
           "CURSOR DATA DATA-POINTER DATE DATE-COMPILED DATE-WRITTEN",
           "DAY DAY-OF-WEEK DBCS DE DEBUG-CONTENTS DEBUG-ITEM",
           "DEBUG-LINE DEBUG-NAME DEBUG-SUB-1 DEBUG-SUB-2 DEBUG-SUB-3",
           "DEBUGGING",
           "DECIMAL-POINT DECLARATIVES DEFAULT DELETE DELIMITED DELIMITER",
           "DEPENDING DESCENDING DESTINATION DETAIL DISABLE DISPLAY",
           "DISPLAY-1 DIVIDE DIVISION DOWN DUPLICATES DYNAMIC",
           "EC EGCS EGI EJECT ELSE EMI",
           "ENABLE END END-ACCEPT END-ADD END-CALL END-COMPUTE",
           "END-DELETE END-DISPLAY END-DIVIDE END-EVALUATE END-EXEC END-IF",
           "END-INVOKE END-MULTIPLY END-OF-PAGE END-PERFORM END-READ",
           "END-RECEIVE",
           "END-RETURN END-REWRITE END-SEARCH END-START END-STRING",
           "END-SUBTRACT",
           "END-UNSTRING END-WRITE END-XML ENDING ENTER ENTRY",
           "ENVIRONMENT EO EOP EQUAL ERROR ESI",
           "EVALUATE EVERY EXCEPTION EXCEPTION-OBJECT EXEC EXECUTE",
           "EXIT EXTEND EXTERNAL FACTORY FALSE FD",
           "FILE FILE-CONTROL FILLER FINAL FIRST FLOAT-EXTENDED",
           "FLOAT-LONG FLOAT-SHORT FOOTING FOR FORMAT FREE",
           "FROM FUNCTION FUNCTION-ID FUNCTION-POINTER GENERATE GET",
           "GIVING GLOBAL GO GOBACK GREATER GROUP",
           "GROUP-USAGE HEADING HIGH-VALUE HIGH-VALUES I-O I-O-CONTROL",
           "ID IDENTIFICATION IF IN INDEX INDEXED",
           "INDICATE INHERITS INITIAL INITIALIZE INITIATE INPUT",
           "INPUT-OUTPUT INSERT INSPECT INSTALLATION INTERFACE INTERFACE-ID",
           "INTO INVALID INVOKE IS JNIENVPTR JUST",
           "JUSTIFIED KANJI KEY LABEL LAST LEADING",
           "LEFT LENGTH LESS LIMIT LIMITS LINAGE",
           "LINAGE-COUNTER LINE LINE-COUNTER LINES LINKAGE LOCAL-STORAGE",
           "LOCALE LOCK LOW-VALUE LOW-VALUES MEMORY MERGE",
           "MESSAGE METHOD METHOD-ID MINUS MODE MODULES",
           "MORE-LABELS MOVE MULTIPLE MULTIPLY NATIONAL NATIONAL-EDITED",
           "NATIVE NEGATIVE NESTED NEXT NO NOT",
           "NULL NULLS NUMBER NUMERIC NUMERIC-EDITED OBJECT",
           "OBJECT-COMPUTER OBJECT-REFERENCE OCCURS OF OFF OMITTED",
           "ON OPEN OPTIONAL OPTIONS OR ORDER",
           "ORGANIZATION OTHER OUTPUT OVERFLOW OVERRIDE PACKED-DECIMAL",
           "PADDING PAGE PAGE-COUNTER PASSWORD PERFORM PF",
           "PH PIC PICTURE PLUS POINTER POSITION",
           "POSITIVE PRESENT PRINTING PROCEDURE PROCEDURE-POINTER PROCEDURES",
           "PROCEED PROCESSING PROGRAM PROGRAM-ID PROGRAM-POINTER PROPERTY",
           "PROTOTYPE PURGE QUEUE QUOTE QUOTES RAISE",
           "RAISING RANDOM RD READ READY RECEIVE",
           "RECORD RECORDING RECORDS RECURSIVE REDEFINES REEL",
           "REFERENCE REFERENCES RELATIVE RELEASE RELOAD REMAINDER",
           "REMOVAL RENAMES REPLACE REPLACING REPORT REPORTING",
           "REPORTS REPOSITORY RERUN RESERVE RESET RESUME",
           "RETRY RETURN RETURN-CODE RETURNING REVERSED REWIND",
           "REWRITE RF RH RIGHT ROUNDED RUN",
           "SAME SCREEN SD SEARCH SECTION SECURITY",
           "SEGMENT SEGMENT-LIMIT SELECT SELF SEND SENTENCE",
           "SEPARATE SEQUENCE SEQUENTIAL SERVICE SET SHARING",
           "SHIFT-IN SHIFT-OUT SIGN SIZE SKIP1 SKIP2",
           "SKIP3 SORT SORT-CONTROL SORT-CORE-SIZE SORT-FILE-SIZE SORT-MERGE",
           "SORT-MESSAGE SORT-MODE-SIZE SORT-RETURN SOURCE SOURCE-COMPUTER",
           "SOURCES",
           "SPACE SPACES SPECIAL-NAMES SQL STANDARD STANDARD-1",
           "STANDARD-2 START STATUS STOP STRING SUB-QUEUE-1",
           "SUB-QUEUE-2 SUB-QUEUE-3 SUBTRACT SUM SUPER SUPPRESS",
           "SYMBOLIC SYNC SYNCHRONIZED SYSTEM-DEFAULT TABLE TALLY",
           "TALLYING TAPE TERMINAL TERMINATE TEST TEXT",
           "THAN THEN THROUGH THRU TIME TIMES",
           "TITLE TO TOP TRACE TRAILING TRUE",
           "TYPE TYPEDEF UNIT UNIVERSAL UNLOCK UNSTRING",
           "UNTIL UP UPON USAGE USE USER-DEFAULT",
           "USING VAL-STATUS VALID VALIDATE VALIDATE-STATUS VALUE",
           "VALUES VARYING WHEN WHEN-COMPILED WITH WORDS",
           "WORKING-STORAGE WRITE WRITE-ONLY XML XML-CODE XML-EVENT",
           "XML-NTEXT XML-TEXT ZERO ZEROES ZEROS"

         globals = "msgid r browse confirm rpt. exit_rc rexx_os ret"
         globals = globals "level. name. type. length. sign. start_POS."
         globals = globals "nb_items prefix current_level occurs."
         globals = globals "level_increment nb_first_child total_items"
         globals = globals "first_child reserved_words cob_lines cob."
         globals = globals "round level01 cobol_length"

        /* --------------------------------------------------------- *
         * Test if concatenation and OR operators works              *
         * --------------------------------------------------------- */
        /* first test concatenation operator */
         if "1" || "2" <> "12" then do
            say "==>Error: the Rexx concatenation operator doesn't work."
            say " "
            say "You may request help on the user forum at :"
            say " "
            say ,
                "http://sourceforge.net/forum/forum.php?forum_id=391891"
            say " "
            exit_rc = 12
            exit exit_rc
         end /* end if "1" || "2" <> "12" */

        /* Second test OR operator */
         if ("1" <> "1" | "2" <> "2") > 0 then do
            say "==>Error: the Rexx OR operator doesn't work." ,
            say " "
            say "You may request help on the user forum at :"
            say " "
            say ,
               "http://sourceforge.net/forum/forum.php?forum_id=391891"
            say " "
            exit_rc = 12
            exit exit_rc
         end /* end if ("1" <> "1" | "2" <> "2") > 0 */

        /* --------------------------------------------------------- *
         * Get REXX Operating System and type.                       *
         * --------------------------------------------------------- */
        /* get rexx interpreter name */
         parse version rexx_interpreter . .
         rexx_interpreter = translate(rexx_interpreter)
         if left(rexx_interpreter, 5) == "REXX-" then do
            parse var rexx_interpreter "REXX-" rexx_interpreter "_" .
         end /* end if left(rexx_interpreter, 5)  */

        /* get rexx operating system */
         parse source rexx_os .
         rexx_os = translate(word(rexx_os,1))

        /* Check OS and REXX interpreter */
         select
            when rexx_os = "TSO" then nop
            when substr(rexx_interpreter,1,6) = "REGINA" then nop
            otherwise do
               say "==>Error :" ,
                   "Unsupported Rexx interpreter" rexx_interpreter ,
                   "or unsupported operating system :" rexx_os
               say " "
               exit_rc = 12
               exit exit_rc
            end /* end otherwise do  */
         end /* end select */

        /* --------------------------------------------------------- *
         * If no option provided and ISPF is active then call the    *
         * ISPF interface.                                           *
         * --------------------------------------------------------- */
         if length(option) <= 0 then do
            if rexx_os = "TSO" then do
               if sysvar('sysispf') = "ACTIVE" then do
                  ret = 1
                  cc = ""
                  do forever
                     cmd = ""
                     Address ISPExec "Display Panel(XML2COB)"
                     if rc > 4 then exit rc
                     option = cmd
                     i = time("R")
                     drop r rpt. nb_items total_items name. length. ,
                          type. start_pos. occurs. sign. cob. ,
                          cob_lines cobol_length nb_first_child ,
                          profile round level01 verbose
                     nb_items = 0
                     total_items = 0
                     name.0 = ""
                     length.0 = 0
                     type.0 = ""
                     start_pos.0 = 0
                     occurs.0 = 0
                     sign.0 = ""
                     cob.0 = ""
                     cob_lines = 0
                     cobol_length = 0
                     nb_first_child = 0
                     profile = ""
                     round = ""
                     level01 = ""
                     verbose = ""
                     r = 0
                     rpt.1 = ""
                     call do_it cmd
                  end /* end do forever */
               end /* end if sysvar('sysispf') = "ACTIVE"  */
               else call exit_no_options
            end /* end if rexx_os = "TSO"  */
            else call exit_no_options
         end /* end if length(option) <= 0  */

         Do_It:
        /* --------------------------------------------------------- *
         * Parse the input parameters.                               *
         * --------------------------------------------------------- */
         option = " " || option
         uopt = translate(option)
         i = pos(" XML ",uopt)
         if i > 0 then option = overlay(" XML ",option,i,5)
         i = pos(" COB ",uopt)
         if i > 0 then option = overlay(" COB ",option,i,5)
         i = pos(" PREFIX ",uopt)
         if i > 0 then option = overlay(" PREFIX ",option,i,8)
         i = pos(" ROUND ",uopt)
         if i > 0 then option = overlay(" ROUND ",option,i,7)
         i = pos(" LEVEL01 ",uopt)
         if i > 0 then option = overlay(" LEVEL01 ",option,i,9)
         i = pos(" BROWSE ",uopt)
         if i > 0 then option = overlay(" BROWSE ",option,i,8)
         i = pos(" VERBOSE ",uopt)
         if i > 0 then option = overlay(" VERBOSE ",option,i,9)
         parse var option . " COB " cobol ,
                          " XML " xml ,
                          " PREFIX " prefix . 1
         cobol= strip(cobol)
         i = pos("PREFIX",translate(xml))
         if i > 0 then xml = overlay("      ",xml,i,50)
         i = pos("ROUND",translate(xml))
         if i > 0 then xml = overlay("     ",xml,i,50)
         i = pos("LEVEL01",translate(xml))
         if i > 0 then xml = overlay("     ",xml,i,50)
         i = pos("BROWSE",translate(xml))
         if i > 0 then xml = overlay("      ",xml,i,6)
         i = pos("VERBOSE",translate(xml))
         if i > 0 then xml = overlay("       ",xml,i,7)
         xml = strip(xml)
         prefix = translate(strip(prefix))
         prefix = translate(prefix,"-","_")

        /* --------------------------------------------------------- *
         * Test for round & level01                                  *
         * --------------------------------------------------------- */
         if wordpos("ROUND",uopt) > 1 then round = "Y"
         else round = "N"
         if wordpos("LEVEL01",uopt) > 1 then level01 = "Y"
         else level01 = "N"

        /* --------------------------------------------------------- *
         * Test for verbose                                          *
         * --------------------------------------------------------- */
         if wordpos("VERBOSE",uopt) > 1 then do
            confirm = 1
         end /* end if wordpos("VERBOSE",uopt) > 1 */
         else confirm = 0

        /* --------------------------------------------------------- *
         * Test for Browse                                           *
         * --------------------------------------------------------- */
         if rexx_os = "TSO" then do
            if sysvar('sysispf') <> "ACTIVE" then browse = 0
            else if wordpos("BROWSE",uopt) > 1 then browse = 1
                 else browse = 0
         end /* end if rexx_os = "TSO"  */
         else browse = 0

        /* --------------------------------------------------------- *
         * Setup the default variables                               *
         * --------------------------------------------------------- */
         parse value "" with null cobdd xmldd

         if confirm >= 1 then do
             call domsg "XML to COBOL Copybook Conversion Utility." ,
             " Version:" ver
            call domsg " "
         end /* end if confirm >= 1 */

        /* --------------------------------------------------------- *
         * Test that the cobol file doesn't already exist            *
         *      or that the cobol dd is allocated                    *
         *      or that the file can be opened                       *
         * --------------------------------------------------------- */
         select
            when rexx_os <> "TSO" then do
               if stream(cobol, "C", "OPEN WRITE") <> "READY:" then do
                  call domsg "==>Error :" ,
                             "the COBOL file" cobol "can not be opened."
                  exit_rc = 12
                  signal done
               end /* end if stream(cobol, "C", "OPEN WRITE") <> "READY:" */
            end /* end when rexx_os <> "TSO" */
            when translate(left(cobol,3)) = "DD:" then do
               parse value cobol with "DD:" cobdd
               x = listdsi(cobdd "file")
               if x > 0 then do
                  call domsg "==>Error :" ,
                             "the COBOL ddname" cobdd "can not be found."
                  exit_rc = 12
                  signal done
               end /* end if x > 0  */
            end /* end when translate(left(cobol,3)) = "DD:" */
            when "OK" = sysdsn(cobol) then do
               call domsg "==>Error :" ,
                          "The COBOL file currently exists." ,
                          "Please specify a file name to be created."
               exit_rc = 12
               signal done
            end /* end when "OK"  sysdsn(cobol) */
            otherwise
         end /* end select */

        /* --------------------------------------------------------- *
         * Test that the XML file already exist                      *
         *      or that the XML dd is allocated                      *
         *      or that the file can be opened                       *
         * --------------------------------------------------------- */
         select
           when rexx_os <> "TSO" then do
               rc = stream(xml, "C", "OPEN READ")
               if rc  <> "READY:" then do
                  call domsg "==>Error :" ,
                             "the XML file" xml "can not be opened."
                  exit_rc = 12
                  signal done
               end /* end if rc  <> "READY:" */
            end /* end when rexx_os <> "TSO" */
            when xml = null then do
               call domsg "==>Error : the XML file was not specified."
               exit_rc = 12
               signal done
            end /* end when xml = null */
            when translate(left(xml,3)) = "DD:" then do
               parse value xml with "DD:" xmldd
               x = listdsi(xmldd "file")
               if x > 0 then do
                  call domsg "==>Error : " ,
                             "the XML ddname" xmldd "can not be found."
                  exit_rc = 12
                  signal done
               end /* end if x > 0 */
            end /* end when translate(left(xml,3)) = "DD:" */
            when "OK" <> sysdsn(xml) then do
               call domsg "==>Error : the XML file" xml
               call domsg sysdsn(xml)
               exit_rc = 12
               signal done
            end /* end when "OK" <> sysdsn(xml) */
            otherwise
         end /* end select */

        /* --------------------------------------------------------- *
         * Alloc the XML file if needed                              *
         * --------------------------------------------------------- */
         if rexx_os = "TSO" then do
            if xmldd = null then do
               "Alloc f("xml2dd") shr ds("xml") reuse"
            end /* end if xmldd = null */
         end /* end if rexx_os = "TSO" */

        /* --------------------------------------------------------- *
         * Create the COBOL copybook                                 *
         * --------------------------------------------------------- */
          call do_cob

        /* --------------------------------------------------------- *
         * Now Report What We Did                                    *
         * --------------------------------------------------------- */
         if confirm >= 1 then do
            call domsg    " "
            if xmldd = null then
               call domsg "XML File:          " xml
            else
               call domsg "XML DD:            " xmldd
            if cobdd = null then
               call domsg "Cobol File:        " cobol
            else
               call domsg "Cobol DD:          " cobdd
            call domsg    "Prefix:            " prefix
            call domsg    "Round:             " round
            call domsg    "Level01:           " level01
            call domsg    " "
            call domsg    "XML first child:   " nb_first_child ,
                          "processed in" substr(time("E"),1,6) "seconds"
            call domsg    " "
            header.1 = "+-"
            header.1 = insert("-",header.1,length(header.1),5,"-")
            header.1 = insert("-+-",header.1,length(header.1),3)
            header.1 = insert("-",header.1,length(header.1),30,"-")
            header.1 = insert("-+-",header.1,length(header.1),3)
            header.1 = insert("-",header.1,length(header.1),5,"-")
            header.1 = insert("-+-",header.1,length(header.1),3)
            header.1 = insert("-",header.1,length(header.1),6,"-")
            header.1 = insert("-+-",header.1,length(header.1),3)
            header.1 = insert("-",header.1,length(header.1),4,"-")
            header.1 = insert("-+-",header.1,length(header.1),3)
            header.1 = insert("-",header.1,length(header.1),5,"-")
            header.1 = insert("-+-",header.1,length(header.1),3)
            header.1 = insert("-",header.1,length(header.1),6,"-")
            header.1 = insert("-+",header.1,length(header.1),2)
            header.2 = "] "
            header.2 = insert("Level",header.2,length(header.2),5)
            header.2 = insert(" ] ",header.2,length(header.2),3)
            header.2 = insert("Name",header.2,length(header.2),30)
            header.2 = insert(" ] ",header.2,length(header.2),3)
            header.2 = insert("Type",header.2,length(header.2),5)
            header.2 = insert(" ] ",header.2,length(header.2),3)
            header.2 = insert("Occurs",header.2,length(header.2),6)
            header.2 = insert(" ] ",header.2,length(header.2),3)
            header.2 = insert("Sign",header.2,length(header.2),4)
            header.2 = insert(" ] ",header.2,length(header.2),3)
            header.2 = insert("Start",header.2,length(header.2),5)
            header.2 = insert(" ] ",header.2,length(header.2),3)
            header.2 = insert("Length",header.2,length(header.2),6)
            header.2 = insert(" ]",header.2,length(header.2),2)
            if total_items > 0 then do
               call domsg    copies("=",80)
               call domsg    " "
               call domsg    center("COBOL copybook created :",80)
               call domsg    " "
               call domsg    header.1
               call domsg    header.2
               call domsg    header.1
               do i = 1 to total_items
                  if level.i = 0 then iterate
                  line = "] "
                  line = insert(level.i,line,length(line),5)
                  line = insert(" ] ",line,length(line),3)
                  if length(copies(" ",level.i-1) || name.i) <= 30 then ,
                     line = insert(copies(" ",level.i-1) || ,
                                   name.i,line,length(line),30)
                  else line = insert(copies(" ",level.i-1) || ,
                       substr(name.i,1,22) || "...",line,length(line),30)
                  line = insert(" ] ",line,length(line),3)
                  line = insert(type.i,line,length(line),5)
                  line = insert(" ] ",line,length(line),3)
                  line = insert(occurs.i,line,length(line),6)
                  line = insert(" ] ",line,length(line),3)
                  line = insert(sign.i,line,length(line),4)
                  line = insert(" ] ",line,length(line),3)
                  line = insert(start_pos.i,line,length(line),5)
                  line = insert(" ] ",line,length(line),3)
                  line = insert(length.i,line,length(line),6)
                  line = insert(" ]",line,length(line),2)
                  call domsg line
               end /* end do i = 1 to nb_items */
               call domsg    header.1
               call domsg    " "
               call domsg    "Total COBOL record length :" cobol_length
               call domsg    " "
            end /* end if nb_items > 0 */
         end /* end if confirm >= 1 then do */

        /* --------------------------------------------------------- *
         * Done so report out and leave                              *
         * --------------------------------------------------------- */
         Done:
         if browse >= 1 & rexx_os = "TSO" then do
            call msg "off"
            if sysvar("syspref") = null then hlq  = sysvar("sysuid")"."
            else hlq = null
            browse_dsn = hlq"XML2COB.report"
            "Alloc f("dd") ds("browse_dsn") new spa(1,1) tr",
            "recfm(v b) lrecl(255) blksize(0)"
            "Execio * diskw" dd "(Finis stem rpt."
            Address ISPExec "Browse Dataset("browse_dsn")"
            "Free f("dd")"
            "Delete" browse_dsn
         end /* end if browse >= 1 & rexx_os = "TSO" */

        /* free xml file */
         if rexx_os = "TSO" then do
            if xmldd = null then "Free f("xml2dd")"
         end /* end if rexx_os = "TSO" */

         if ret = 1 then return
         exit exit_rc

          Do_COB:
        /* --------------------------------------------------------- *
         * Allocate the cobol file                                     *
         * Space of cobol file = space of the XML file % 3             *
         * Lrecl is set to the computed cobol length of the copybook *
         * --------------------------------------------------------- */
         if rexx_os = "TSO" then do
            if cobdd = null then do
               if pos("(",cobol) <= 0 then do
                  "Alloc f("cob2dd") new ds("cobol") reuse tracks"    ,
                  "recfm(f b) lrecl(80) spa(1,1) blksize(8000) release"
               end /* end if pos("(",cobol) <= 0 */
               else do
                  if "MEMBER NOT FOUND" = sysdsn(cobol) then do
                     "Alloc f("cob2dd") shr ds("cobol") reuse"
                  end /* end if "MEMBER NOT FOUND" = sysdsn(cobol) */
                  else do
                     "Alloc f("cob2dd") new ds("cobol") reuse tracks" ,
                     "recfm(f b) lrecl(80) dir(20)" ,
                     "spa(1,1) blksize(8000) release"
                  end /* end else do */
               end /* end else do */
            end /* end if cobdd = null */
         end /* end if rexx_os = "TSO" */

        /* initialize variables */
         file_eof = 0
         nb_first_child = 0   /* number of XML first child element */
         cobol_length = 0     /* computed length of the cobol copybook */
         current_level = 0    /* COBOL current level */
         level_increment = 2  /* COBOL level increment */
         nb_items = 0         /* number of COBOL items in copybook */
         root = ""            /* name of the XML root element */
         first_child  = ""    /* name of the XML first child element */
         element = ""         /* one XML element */
         attribute = ""       /* one XML attribute */
         attributes = ""      /* all XML attributes of an XML element */
         content = ""         /* content of one XML element */
         call reset_XML_flags
         do while file_eof = 0

        /* read one record from XML file */
            rc = 0
            select
               when rexx_os <> "TSO" then do
                  if lines(xml) > 0 then xml.1 = linein(xml, ,1)
                  else rc = 1
               end /* end when rexx_os <> "TSO" */
               when xmldd = null then "Execio 1 diskr" xml2dd "(stem xml."
               when xmldd <> null then "Execio 1 diskr" xmldd "(stem xml."
               otherwise
            end /* end select */

        /* if end of file then write copybook and exit */
            if rc > 0 then do
               file_eof = 1
               rc=clean_copybook()
               select
                  when rexx_os <> "TSO" then ,
                     rc = stream(xml, "C", "CLOSE")
                  when xmldd = null then do
                     "Execio 0 diskr" xml2dd "(FINIS"
                     "Free f("xml2dd")"
                  end /* end when xmldd = null */
                  when xmldd <> null then ,
                     "Execio 0 diskr" xmldd "(FINIS"
                  otherwise
               end /* end select */
               select
                  when rexx_os <> "TSO" then do
                     do i = 1 to cob_lines
                        if i <= 1 then rc = lineout(cobol,cob.i,1)
                        else rc = lineout(cobol,cob.i)
                     end /* end do i = 1 to cob_lines */
                     rc = stream(cobol, "C", "CLOSE")
                  end /* end when rexx_os <> "TSO" */
                  when cobdd = null then do
                     "Execio " cob_lines " diskw" cob2dd "(stem cob. FINIS"
                     "Free f("cob2dd")"
                  end /* end when cobdd = null */
                  when cobdd <> null then ,
                     "Execio " cob_lines " diskw" cobdd "(stem cob. FINIS"
                  otherwise
               end /* end select */
            end /* end if rc > 0 */
            else do

        /* ------------------------------------------------------ *
         * skip blank lines                                       *
         * ------------------------------------------------------ */
               xml.1 = strip(xml.1)
               if length(xml.1) <= 0 then iterate

        /* ------------------------------------------------------ *
         * skip XML declaration and comments. Search for XML root *
         * , XML first child and XML elements, attributes and     *
         * content.                                               *
         * ------------------------------------------------------ */
               do i = 1 to length(xml.1)
                  select

        /* ------------------------------------------------------ *
         * start of XML declaration <?                            *
         * ------------------------------------------------------ */
                     when XML_declaration <= 0 ,
                          & substr(xml.1,i,2) = "<?" then do
                          XML_declaration = 1
                          i = i + 1
                     end /* end when XML_declaration <= 0 , */

        /* end of XML declaration ?> */
                     when XML_declaration > 0 then do
                          i = pos("?>",xml.1,i)
                          if i <= 0 then leave
                          else do
                             i = i + 1
                             call reset_XML_flags
                          end /* end else do */
                     end /* end when XML_declaration > 0 */

        /* ------------------------------------------------------ *
         * start of XML entity <|ENTITY                           *
         * ------------------------------------------------------ */
                     when XML_entity <= 0 ,
                          & substr(xml.1,i,8) = "<|ENTITY" then do
                          call domsg "==>Error :" ,
                               "in the XML file, entity declaration" ,
                               "is not supported."
                          exit_rc = 12
                          signal done
                     end /* end when XML_entity <= 0 ,*/

        /* end of XML entity */
                     when XML_entity > 0 then do
                          i = pos(">",xml.1,i)
                          if i <= 0 then leave
                          else do
                             i = i + 1
                             call reset_XML_flags
                          end /* end else do */
                     end /* end when XML_entity > 0 */

        /* ------------------------------------------------------ *
         * start of XML DOCTYPE <|DOCTYPE                         *
         * ------------------------------------------------------ */
                     when XML_DOCTYPE <= 0 & ,
                          substr(xml.1,i,9) = "<|DOCTYPE" then do
                          XML_DOCTYPE = 1
                          if pos("¢",xml.1,i) > 0 then XML_DOCTYPE = 2
                          i = i + 8
                     end /* end when XML_DOCTYPE <= 0 & , */

        /* end of XML DOCTYPE without DTD declaration > */
                     when XML_DOCTYPE = 1 then do
                          i = pos(">",xml.1,i)
                          if i <= 0 then leave
                          else call reset_XML_flags
                     end /* end when XML_DOCTYPE = 1 */

        /* end of XML DOCTYPE with inline DTD declaration > */
                     when XML_DOCTYPE >= 2 then do
                          i = pos("!>",xml.1,i)
                          if i <= 0 then leave
                          else do
                             i = i + 1
                             call reset_XML_flags
                          end /* end else do */
                     end /* end when XML_DOCTYPE >= 2 */

        /* ------------------------------------------------------ *
         * start of XML comment <|--                              *
         * ------------------------------------------------------ */
                     when XML_comment <= 0 & substr(xml.1,i,4) = "<|--" ,
                          then do
                          XML_comment = 1
                          i = i + 3
                     end /* end when XML_comment <= 0 & substr(xml.1,i,4) */

        /* end of XML comment --> */
                     when XML_comment > 0 then do
                          i = pos("-->",xml.1,i)
                          if i <= 0 then leave
                          else do
                             i = i + 2
                             call reset_XML_flags
                          end /* end else do */
                     end /* end when XML_comment > 0 */

        /* ------------------------------------------------------ *
         * start of XML root element                              *
         * ------------------------------------------------------ */
                     when root = "" & XML_root <= 0 ,
                          & substr(xml.1,i,1) = "<" then do
                          XML_root = 1
                      end /* end when root = "" & XML_root <= 0 , */

        /* end of XML root element */
                     when XML_root > 0 then do

        /* XML root element end on this line ? */
                          if pos(">",xml.1,i) > 0 then do
                             k = pos(">",xml.1,i)
                             l = k - i
                             root = strip(root substr(xml.1,i,l))
                             if words(root) >  1 then do
                                call domsg ,
                                "==>Warning : " ,
                                "XML attributes of root element" ,
                                word(root,1) "are ignored."
                                exit_rc = 04
                             end /* end if words(root) >  1 */
                             root = strip(word(root,1))
                             i = pos(">",xml.1,i)
                             call reset_XML_flags
                          end /* end if pos(">",xml.1,i) > 0 */

        /* else concatenate XML root element */
                          else do
                             root = root substr(xml.1,i)
                             leave
                          end /* end else do */
                     end /* end when XML_root > 0 */

        /* ------------------------------------------------------ *
         * start of XML first_child element                       *
         * ------------------------------------------------------ */
                     when first_child = "" & XML_first_child <= 0 ,
                          & substr(xml.1,i,1) = "<" & root <> "" then do
                          XML_first_child = 1
                          attributes = ""
                      end /* end when first_child = "" & XML_first_child */

        /* end of XML first_child element */
                     when XML_first_child > 0 then do

        /* XML first_child element end on this line ? */
                          if pos(">",xml.1,i) > 0 then do
                             k = pos(">",xml.1,i)
                             l = k - i
                             first_child = strip(first_child substr(xml.1,i,l))
                             parse var first_child first_child attributes
                             element = first_child
                             nb_first_child = 1
                             nb_items = 1
                             current_level = 0
                             if level01 = "Y" then ,
                                current_level = 1 - level_increment
                             rc = add_item(first_child,"")
                             call do_XML_attribute
                             i = pos(">",xml.1,i)
                             call reset_XML_flags
                             XML_content = 1
                          end /* end if pos(">",xml.1,i) > 0 */

        /* else concatenate XML first_child element */
                          else do
                             first_child = first_child substr(xml.1,i)
                             leave
                          end /* end else do */
                     end /* end when XML_first_child > 0 */

        /* ------------------------------------------------------ *
         * start of XML element                                   *
         * ------------------------------------------------------ */
                     when XML_element <= 0 & substr(xml.1,i,1) = "<" & ,
                          substr(xml.1,i,2) <> "</" ,
                          & substr(xml.1,i,9) <> "<|¢CDATA¢" then do
                          call reset_XML_flags
                          XML_element = 1
                          element = ""
                          attributes = ""
                     end /* end when XML_element <= 0 & substr(xml.1,i,1) */

        /* end of XML element */
                     when XML_element > 0 then do

        /* XML element end on this line ? */
                          if pos(">",xml.1,i) > 0 then do
                             k = pos(">",xml.1,i)
                             l = k - i
                             element = strip(element substr(xml.1,i,l))
                             parse var element element attributes
                             rc = add_item(element,"")
                             call do_XML_attribute

        /* XML empty element ? */
                             if substr(xml.1,k-1,2) = "/>" then do
                                current_level = current_level - ,
                                                level_increment
                                i = k
                                call reset_XML_flags
                                iterate
                             end /* end if substr(xml.1,k-1,2) = "/>" */

                             i = pos(">",xml.1,i)
                             call reset_XML_flags
                             XML_content = 1
                             content = ""
                          end /* end if pos(">",xml.1,i) > 0 */

        /* else concatenate XML element */
                          else do
                             element = element substr(xml.1,i)
                             leave
                          end /* end else do */
                     end /* end when XML_element > 0 */

        /* ------------------------------------------------------ *
         * find the content of a XML element                      *
         * ------------------------------------------------------ */
                     when XML_content > 0 then do
                          k = pos("</",xml.1,i)

        /* no closing tag on line ? continue on next line */
                          if k <= 0 then do
                             content = content substr(xml.1,i)
                             leave
                          end /* end if k <= 0 */
                          else do
                             l = k - i
                             content = strip(content substr(xml.1,i,l))
                          end /* end else do */
                          call check_XML_content
                          rc = add_item(element,content)
                          i = pos("</",xml.1,i) - 1
                          drop content element
                          call reset_XML_flags
                          current_level = current_level - ,
                                          level_increment
                     end /* end when XML_content > 0 */

        /* ------------------------------------------------------ *
         * Start of child closing tag </                          *
         * ------------------------------------------------------ */
                     when XML_end_child <= 0 & ,
                          substr(xml.1,i,2) = "</" then do
                          XML_end_child = 1
                          element = ""
                          i = i + 1
                     end /* end when XML_end_child <= 0 & , */

        /* end of XML child closing tag > */
                     when XML_end_child > 0 then do
                          if pos(">",xml.1,i) > 0 then do
                             k = pos(">",xml.1,i)
                             l = k - i
                             element = element substr(xml.1,i,l)
                             element = strip(word(element,1))

        /* Restart the analysis if we have reached the first child
           closing tag */
                             if element = first_child then do
                                nb_first_child = nb_first_child + 1
                                nb_items = 1
                                current_level = 0
                                if level01 = "Y" then ,
                                   current_level = 1 - level_increment
                             end /* end if element = first_child */
                             else do
                                current_level = current_level - ,
                                                level_increment
                             end
                             i = pos(">",xml.1,i)
                             call reset_XML_flags
                          end /* end if pos(">",xml.1,i) > 0 */

        /* else concatenate XML child closing tag */
                          else do
                             element = element substr(xml.1,i)
                             leave
                          end /* end else do */
                     end /* end when XML_end_child > 0 */

        /* ------------------------------------------------------ *
         * In case of ...                                         *
         * ------------------------------------------------------ */
                     otherwise do
                          call domsg "==>Error :" ,
                               "unable to convert the following chars :" ,
                               substr(xml.1,i,20)
                          exit_rc = 12
                          signal done
                     end /* end otherwise do */
                  end /* end select */
               end /* end do i = 1 to length(xml.1) */
            end /* end else do */
         end /* end do while file_eof = 0 */

        /* free COBOL file */
      /* if rexx_os = "TSO" then do
            if cobdd = null then "Free f("cob2dd")"
         end */ /* end if rexx_os = "TSO" */

         return

         DoMsg:
        /* --------------------------------------------------------- *
         * Issue Messages                                            *
         * --------------------------------------------------------- */
           parse arg msg
           if confirm <= 0 then return
           if browse <= 0 then say msgid msg
           else do
              r = r + 1
              rpt.r = msg
           end /* end else do */
           return

         reset_XML_flags:
        /* --------------------------------------------------------- *
         * Reset XML flags                                           *
         * --------------------------------------------------------- */

           XML_declaration = 0
           XML_DOCTYPE = 0
           XML_comment = 0
           XML_root = 0
           XML_first_child = 0
           XML_element = 0
           XML_attribute = 0
           XML_end_child = 0
           XML_content = 0
           XML_entity = 0

           return

         do_XML_attribute:
        /* --------------------------------------------------------- *
         * Converting attribute value to text                        *
         * --------------------------------------------------------- */
           if length(attributes) > 0 then do
              XML_attribute = 1
              start_pos = 0
              end_pos = 0
              temp1 = strip(attributes)
              if right(temp1,1) = "/" then ,
                 temp1 = left(temp1,length(temp1)-1)
              temp1 = temp1 || " "

         /* Search attributes and content*/
              do b = 1 to length(temp1)
                 if substr(temp1,b,1) <> " " ,
                    & start_pos <= 0 then start_pos = b
                 if substr(temp1,b,2) = '" ' | ,
                    substr(temp1,b,2) = "' " then do
                    end_pos = b + 1
                    temp2 = substr(temp1,start_pos,end_pos-start_pos)
                    if substr(temp2,length(temp2),1) = "/" then ,
                       temp2 = substr(temp2,1,length(temp2)-1)
                    if pos("=",temp2) <= 0 then do
                       call domsg ,
                          "==>Error: equal sign not found in attribute :" ,
                          temp2
                       exit_rc = 12
                       signal done
                    end /* end if pos("=",temp2) <= 0 */
                    attribute = substr(temp2,1,pos("=",temp2)-1)

         /* Skip XML specials attributes */
                    if translate(substr(attribute,1,3)) = "XML" then do
                       start_pos = 0
                       end_pos = 0
                       iterate
                    end /* end if translate(substr(attribute,1,3)) = "XML" */
                    content = substr(temp2,pos("=",temp2)+2)
                    content = substr(content,1,length(content)-1)
                    call check_XML_content
                    rc = add_item(attribute,content)
                    current_level = current_level - level_increment
                    start_pos = 0
                    end_pos = 0
                 end /* end if substr(temp1,b,2) = '" ' | , */
              end /* end do b = 1 to length(temp1) */
              XML_attribute = 0
           end /* end if words(element) > 1 */
           drop b content attribute temp1 temp2 start_pos end_pos

           return

         check_XML_content:
        /* --------------------------------------------------------- *
         * Check XML content before transfering it to the output     *
         * record.                                                   *
         * --------------------------------------------------------- */
        /* scan content for CDATA */
           if pos("<|¢CDATA¢",content) > 0 then do
              k = pos("<|¢CDATA¢",content)
              k = k + length("<|¢CDATA¢")
              l = pos("!!>",content)
              content = substr(content,k,l-k)
           end /* end if pos("<|¢CDATA¢",content) > 0  */

        /* scan content for escaping characters */
           else
           if (pos("&amp;",content) > 0 | ,
              pos("&lt;",content) > 0 | ,
              pos("&gt;",content) > 0 | ,
              pos("&apos;",content) > 0 | ,
              pos("&quot;",content) > 0 | ,
              pos("&#",content) > 0)  then
              do k = 1 to length(content)
                 k = pos("&",content,k)
                 l = pos(";",content,k)
                 temp = translate(substr(content,k+1,l-k-1))
                 select
                    when temp = "AMP" then symbole = "&"
                    when temp = "LT" then symbole = "<"
                    when temp = "GT" then symbole = ">"
                    when temp = "QUOT" then symbole = '"'
                    when temp = "APOS" then symbole = "'"
                    when substr(temp,1,1) = "#" then do
                       temp1 = substr(temp,2)
                       if left(temp1,1) = "X" then ,
                          symbole = x2c(substr(temp1,2))
                       else symbole = d2c(temp1)
                       call domsg ,
                          "==>Warning : character reference:" temp ,
                          "encountered in escaped characters."
                       exit_rc = 04
                       drop temp1
                    end /* end when substr(temp,1,1) = "#" */
                    otherwise do
                       call domsg ,
                         "==>Error: unknown escaping character" ,
                          "&" || symbole || ";" ,
                          "encounterd."
                       exit_rc = 12
                       signal done
                    end /* end otherwise do */
                 end /* end select */
                 if k > 1 then temp1 = substr(content,1,k-1)
                 else temp1 = ""
                 temp2 = substr(content,k+length(temp)+2)
                 content = temp1 || symbole || temp2
                 drop temp1 temp2 temp symbole
                 if pos("&",content,k) <= 0 | ,
                    pos(";",content,k) <= 0 then leave
           end /* end if (pos("&amp;",content) > 0 | */

           return

         add_item: procedure expose(globals)
        /* --------------------------------------------------------- *
         * Add COBOL item in array                                   *
         *                                                           *
         * Parameter(s) : element (required)                         *
         *                content (optional)                         *
         *                                                           *
         * --------------------------------------------------------- */
           parse arg element, content
           old_msgid = msgid
           msgid = msgid || "add_item():"

        /* Check that element parameter is filled */
           if length(element) <= 0 then do
              call domsg "==>Error :" ,
                         "Element parameter must be filled"
              call domsg "Parameter values when the error occured:"
              call domsg "element       :" element
              call domsg "content       :" content
              exit_rc = 12
              signal done
           end /* end if length(element) <= 0 */

        /* Check element type */
           if datatype(element) <> "CHAR" then do
              call domsg "==>Error :" ,
                         "Element (" element ") name is not valid"
              call domsg "Parameter values when the error occured:"
              call domsg "element       :" element
              call domsg "content       :" content
              exit_rc = 12
              signal done
           end /* end if datatype(element) <> "CHAR"*/

           if nb_items <= 0 then nb_items = 1
           item = translate(strip(element))
           item = translate(item,"-","_")
           if left(item,length(prefix)) = prefix then ,
              item = substr(item,length(prefix)+1)

        /* Check that item name is not a reserved word */
           if wordpos(item, reserved_words) > 0 then do
              call domsg "==>Warning :" ,
                         "Item (" item ") name is a COBOL reserved word"
              call domsg "Parameter values when the error occured:"
              call domsg "element       :" element
              call domsg "content       :" content
              exit_rc = 04
           end /* end if wordpos(item, reserved_words) > 0  */

        /* Check that COBOL level is never greater than 50 */
           current_level = current_level + level_increment
           if current_level > 50 then do
              call domsg "==>Error :" ,
                         "COBOL level (" current_level item ,
                         ") is greater than 50. Aborting"
              call domsg "Parameter values when the error occured:"
              call domsg "element       :" element
              call domsg "content       :" content
              exit_rc = 12
              signal done
           end /* end if current_level >= 50 */

        /*===========================================================
           First round : first "XML first child", then insert
           meta-data of all XML elements found
          ===========================================================*/
           if nb_first_child <= 1 then do

        /* add FILLER item if no content. If content is detected later
           a COBOL item will then be added with the name of the XML
           element at a lower level. By this way, if attributes are
           present, they will appear before the content of the XML
           element and if the element has no content, it will never
           appear in the COBOL copybook */
              level.nb_items = current_level
              type.nb_items = ""
              length.nb_items = 0
              sign.nb_items = "N"

              if length(content) <= 0 then ,
                 name.nb_items = "FILLER-" || item
              else do
                 name.nb_items = item
                 temp = translate(content,".",",")
                 if datatype(temp)= "NUM" then do
                    type.nb_items = "NUM"
                    select
                       when left(content,1) = "+" then sign.nb_items = "LS"
                       when left(content,1) = "-" then sign.nb_items = "LS"
                       when right(content,1) = "+" then sign.nb_items = "TS"
                       when right(content,1) = "-" then sign.nb_items = "TS"
                       otherwise sign.nb_items = "N"
                    end /* end select */
                 end /* end if datatype(temp)= "NUM" */
                 else type.nb_items = "CHAR"
                 length.nb_items = length(content)

        /* round length if needed */
                 if round ="Y" & length.nb_items > 0 then do
                    j = length.nb_items
                    if j >= 10 then j = right(j,length(j)-1)
                    select
                       when j <= 5    then j = 5
                       when j <= 10   then j = 10
                       when j <= 15   then j = 15
                       when j <= 20   then j = 20
                       when j <= 25   then j = 25
                       when j <= 30   then j = 30
                       when j <= 35   then j = 35
                       when j <= 40   then j = 40
                       when j <= 45   then j = 45
                       when j <= 50   then j = 50
                       when j <= 55   then j = 55
                       when j <= 60   then j = 60
                       when j <= 65   then j = 65
                       when j <= 70   then j = 70
                       when j <= 75   then j = 75
                       when j <= 80   then j = 80
                       when j <= 85   then j = 85
                       when j <= 90   then j = 90
                       when j <= 95   then j = 95
                       when j <= 100  then j = 100
                       when j <= 125  then j = 125
                       when j <= 150  then j = 150
                       when j <= 200  then j = 200
                       when j <= 250  then j = 250
                       when j <= 300  then j = 300
                       when j <= 350  then j = 350
                       when j <= 400  then j = 400
                       when j <= 450  then j = 450
                       when j <= 500  then j = 500
                       when j <= 600  then j = 600
                       when j <= 700  then j = 700
                       when j <= 800  then j = 800
                       when j <= 900  then j = 900
                       when j <= 1000 then j = 1000
                       otherwise nop
                   end /* end select */
                   if length.nb_items < 10 then length.nb_items = j
                   else length.nb_items =left(length.nb_items,1) || j
                 end /* end if round ="Y"  */
              end /* end else do */
              m = nb_items + 1
              total_items = nb_items
              nb_items = nb_items + 1
           end /* end if nb_first_child <= 1 */

        /*===========================================================
           Second round : other "first child" in XML file, then insert
           meta-data of all new XML elements found ...
          ===========================================================*/
           else do
              if length(content) <= 0 then item = "FILLER-" || item
              if level.nb_items <> current_level | ,
                 name.nb_items <> item | ,
                 nb_items > total_items then do
                 do j = total_items + 1 to nb_items + 1 by -1
                    k = j - 1
                    name.j = name.k
                    level.j = level.k
                    type.j = type.k
                    length.j = length.k
                    sign.j = sign.k
                 end /* end do j = total_items + 1 to nb_items by -1 */
                 name.nb_items = ""
                 level.nb_items = 0
                 type.nb_items = ""
                 length.nb_items = 0
                 sign.nb_items = "N"
                 total_items = nb_items + 1
              end /* end if level.nb_items <> current_level |  */

        /*===========================================================
          ... and/or update meta-data
         ===========================================================*/
              name.nb_items = item
              level.nb_items = current_level
              if length(content) > 0 then do
                 temp = translate(content,".",",")
                 if datatype(temp)= "CHAR" & type.nb_items = "NUM" then ,
                    type.nb_items = "CHAR"
                 if type.nb_items = "NUM" then do
                    select
                       when sign.nb_items = "LS" then nop
                       when sign.nb_items = "TS" then nop
                       when left(content,1) = "+" then sign.nb_items = "LS"
                       when left(content,1) = "-" then sign.nb_items = "LS"
                       when right(content,1) = "+" then sign.nb_items = "TS"
                       when right(content,1) = "-" then sign.nb_items = "TS"
                       otherwise sign.nb_items = "N"
                    end /* end select */
                 end /* end if type.nb_items = "NUM" */
              end /* end if length(content) > 0  */
              if length(content) > length.nb_items then ,
                 length.nb_items = length(content)

        /* round length if needed */
                 if round ="Y" & length.nb_items > 0 then do
                    j = length.nb_items
                    if j >= 10 then j = right(j,length(j)-1)
                    select
                       when j <= 5    then j = 5
                       when j <= 10   then j = 10
                       when j <= 15   then j = 15
                       when j <= 20   then j = 20
                       when j <= 25   then j = 25
                       when j <= 30   then j = 30
                       when j <= 35   then j = 35
                       when j <= 40   then j = 40
                       when j <= 45   then j = 45
                       when j <= 50   then j = 50
                       when j <= 55   then j = 55
                       when j <= 60   then j = 60
                       when j <= 65   then j = 65
                       when j <= 70   then j = 70
                       when j <= 75   then j = 75
                       when j <= 80   then j = 80
                       when j <= 85   then j = 85
                       when j <= 90   then j = 90
                       when j <= 95   then j = 95
                       when j <= 100  then j = 100
                       when j <= 125  then j = 125
                       when j <= 150  then j = 150
                       when j <= 200  then j = 200
                       when j <= 250  then j = 250
                       when j <= 300  then j = 300
                       when j <= 350  then j = 350
                       when j <= 400  then j = 400
                       when j <= 450  then j = 450
                       when j <= 500  then j = 500
                       when j <= 600  then j = 600
                       when j <= 700  then j = 700
                       when j <= 800  then j = 800
                       when j <= 900  then j = 900
                       when j <= 1000 then j = 1000
                       otherwise nop
                   end /* end select */
                   if length.nb_items < 10 then length.nb_items = j
                   else length.nb_items =left(length.nb_items,1) || j
                 end /* end if round ="Y"  */
              m = nb_items + 1
              nb_items = nb_items + 1
           end /* end else do */

           msgid = old_msgid
           return 0

         drop_item: procedure expose(globals)
        /* --------------------------------------------------------- *
         * Remove COBOL item in array                                *
         *                                                           *
         * Parameter(s) : item_nbr       (required, item number)     *
         *                                                           *
         * --------------------------------------------------------- */
           parse arg item_nbr
           old_msgid = msgid
           msgid = msgid || "drop_item():"

        /* Check that item_nbr parameter is filled */
           if length(item_nbr) <= 0 then do
              call domsg "==>Error :" ,
                         "Item_nbr parameter must be filled"
              call domsg "Parameter value when the error occured:"
              call domsg "item_nbr       :" item_nbr
              exit_rc = 12
              signal done
           end /* end if length(item_nbr) <= 0 */

        /* Check item_nbr type */
           if datatype(item_nbr) <> "NUM" then do
              call domsg "==>Error :" ,
                         "Item number (" item_nbr ") is not numeric. Aborting"
              call domsg "Parameter value when the error occured:"
              call domsg "item_nbr       :" item_nbr
              exit_rc = 12
              signal done
           end /* end if datatype(item_nbr) <> "CHAR"*/

        /* Check item_nbr is not greater than total_items */
           if item_nbr > total_items then do
              call domsg "==>Error :" ,
                         "Item number (" item_nbr ") is greater than ",
                         "the total number of items (" total_items ")"
              call domsg "Parameter value when the error occured:"
              call domsg "item_nbr       :" item_nbr
              exit_rc = 12
              signal done
           end /* end if item_nbr > total_items */

        /* Check item_nbr is not lower than 1 */
           if item_nbr < 1 then do
              call domsg "==>Error :" ,
                         "Item number (" item_nbr ") is lower than 1"
              call domsg "Parameter value when the error occured:"
              call domsg "item_nbr       :" item_nbr
              exit_rc = 12
              signal done
           end /* end if item_nbr > total_items */

           do i = item_nbr to total_items - 1
              j = i + 1
              name.i = name.j
              level.i = level.j
              type.i = type.j
              length.i = length.j
              sign.i = sign.j
              occurs.i = occurs.j
           end /* end do i = item_nbr to total_items - 1 */
           drop name.total_items
           drop level.total_items
           drop type.total_items
           drop length.total_items
           drop sign.total_items
           drop occurs.total_items
           total_items = total_items - 1

           msgid = old_msgid
           return 0

         clean_copybook: procedure expose(globals)
        /* --------------------------------------------------------- *
         * Clean the COBOL copybook generated                        *
         *                                                           *
         * --------------------------------------------------------- */
           old_msgid = msgid
           msgid = msgid || "clean_copybook():"

        /* Step 1 : suppressing unnecessary "FILLER-" levels */
           do i = 1 to total_items - 2
              j = i + 1
              k = i + 2
              if level.i >= level.k & ,
                 substr(name.i,8) = name.j & ,
                 left(name.i,7) = "FILLER-" & ,
                 left(name.k,7) = "FILLER-" then do
                 level.j = level.i
                 rc = drop_item(i)
              end /* end if level.i = level.k & , */
           end /* end do i = 1 to total_items - 2 */
           i = total_items - 1
           j = total_items
           if left(name.i,7) = "FILLER-" & ,
              left(name.j,7) <> "FILLER-" then do
              level.j = level.i
              rc = drop_item(i)
           end /* end if left(name.i,7) = "FILLER-" */

        /* Step 2 : Handling elementary occurs */
           do i = 1 to total_items
              occurs.i =  1
              do j = i + 1 to total_items
                 if level.i = level.j & ,
                    name.i = name.j & ,
                    length.i = length.j & ,
                    type.i = type.j then do
                       occurs.i = occurs.i + 1
                       if length.j > length.i then length.i = length.j
                       rc = drop_item(j)
                       j = j - 1
                       if j <= 0 then j = 1
                 end /* end if level.i = level.j & , */
                 else leave
              end /* end do j = i + 1 to total_items */
           end /* end do i = 1 to total_items */

        /* Step 3: Handling group occurs */
           do i = 1 to total_items
              if occurs.i > 1 then iterate
              occurs.i = 1
              interval = 0
              temp = level.i || name.i

        /* Find next occurence of group item */
              do j = i + 1 to total_items

        /* leave when an item is not part of the group */
                 if level.i = level.j & name.i <> name.j then leave
                 if level.i > level.j then leave

        /* a new occurence of a group item is found | */
                 if level.i = level.j & ,
                    name.i = name.j & ,
                    length.i = length.j & ,
                    type.i = type.j then do
                    if interval <= 0 then interval = j - i
                    occurs.i = occurs.i + 1
                 end /* end if level.i = level.j & , */
                 else
                    if interval <= 0 then temp = temp level.j || name.j
              end /* end do j = i to total_items */

        /* A group occurence has been found ? Suppress all
           others occurrences */
              if interval > 0 then do
                 k = i
                 do j = i + interval to total_items

        /* leave when an item is not part of the group */
                    if level.i = level.j & name.i <> name.j then leave
                    if level.i > level.j then leave

        /* Set length to the maximum length of each occurence of the
           item in the group */
                    if length.j > length.k & ,
                       level.j = level.k & ,
                       name.j = name.k then length.k = length.j

        /* restart analysis from the start of the group if the end
           of the group is reached */
                    k = k + 1
                    if level.k = level.i & name.k = name.i then k = i

        /* suppress multiple occurence of the group item  */
                    if wordpos(level.j || name.j, temp) > 0 then do
                       rc = drop_item(j)
                       j = j - 1
                       if j <= 0 then j = 1
                    end /* end if wordpos(level.j || name.j, temp) > 0 */
                    else temp = temp level.j || name.j
                 end /* end do j = i + interval to total_items */
                 i = j - 1
              end /* end if interval > 0 */
           end /* end do i = 1 to total_items */

        /* Step 4: Suppressing "FILLER-" prefix in item name */
           do i = 1 to total_items
              if left(name.i,7) = "FILLER-" then name.i = substr(name.i,8)
           end /* end do i = 1 to total_items */

        /* Step 5: Computing starting positions of COBOL items */
           start_pos.1 = 1
           do i = 1 to total_items

       /* Multiple occurences of a group item */
              if occurs.i > 1 & length.i <= 0 then do
                 group_length = 0
                 do k = i + 1 to total_items
                    if level.k <= level.i then leave
                    j = k - 1
                    group_length = group_length + length.k
                    start_pos.k = start_pos.j + length.j
                 end /* end do while level.k > level.i */
                 start_pos.k = start_pos.i + group_length * occurs.i
                 i = k - 1
              end /* end if occurs.i > 1 & length.i <= 0 */

       /* Multiple occurences of an elementary item */
              else if occurs.i > 1 & length.i > 0 then do
                 j = i + 1
                 start_pos.j = start_pos.i + length.i * occurs.i
              end /* end if occurs.i > 1 & length.i > 0 */

       /* Single occurence of an elementary item */
              else do
                 j = i + 1
                 start_pos.j = start_pos.i + length.i
              end /* end if occurs.i > 1 & length.i > 0 */
           end /* end do i = 1 to total_items */
           k = total_items + 1
           cobol_length = start_pos.k - 1

        /* Step 6: building COBOL copybook records */
           cob_lines = 1

        /* Header */
           cob.cob_lines = copies(" ",6) || "*"  || copies("-",63)
           cob_lines = cob_lines + 1
           cob.cob_lines = copies(" ",6) || "* "
           cob_lines = cob_lines + 1
           cob.cob_lines = copies(" ",6) || "* " ,
                           "Created by XML2COB on" date("N") "at" time("N")
           cob_lines = cob_lines + 1
           cob.cob_lines = copies(" ",6) || "* "
           cob_lines = cob_lines + 1
           cob.cob_lines = copies(" ",6) || "* " ,
                           "More info on :" ,
                           "http://sourceforge.net/projects/txt2xml-rexx/"
           cob_lines = cob_lines + 1
           cob.cob_lines = copies(" ",6) || "* "
           cob_lines = cob_lines + 1
           cob.cob_lines = copies(" ",6) || ,
                           "*  Total COBOL record length : " || ,
                           cobol_length
           cob_lines = cob_lines + 1
           cob.cob_lines = copies(" ",6) || "* "
           cob_lines = cob_lines + 1
           cob.cob_lines = copies(" ",6) || "*"  || copies("-",63)
           cob_lines = cob_lines + 1
           cob.cob_lines = ""
           cob_lines = cob_lines + 1
           do i = 1 to total_items

        /* Level and name  */
              if level.i = 0 & name.i = "" then iterate
              if level.i <= 9 then level.i = "0" || level.i
              j = (level.i - level_increment) % level_increment
              if j <= 0  then j = 0
              if level01 = "Y" & i > 1 then j = j + 1
              cob.cob_lines = copies(" ",10) || ,
                              copies("   ",j) || ,
                              level.i || ,
                              " " || ,
                              name.i
              cob_lines = cob_lines + 1

        /* Picture */
              if length.i > 0 then do
                 picture = "9"
                 if type.i <> "NUM" then picture = "X"
                 j = cob_lines - 1
                 if length(cob.j) < 50 then do
                     cob.j = cob.j || copies(" ",50-length(cob.j))
                     cob.j = cob.j || ,
                             "PICTURE " || ,
                              picture || ,
                              "(" || ,
                              length.i || ,
                              ")"
                 end /* end if length(cob.j) <= 50 */
                 else do
                    cob.cob_lines = copies(" ",50) || ,
                                    "PICTURE " || ,
                                    picture || ,
                                    "(" || ,
                                    length.i || ,
                                    ")"
                    cob_lines = cob_lines + 1
                 end /* end else do */
              end /* end if length.i > 0 */

        /* sign */
              if sign.i <> "N" then do
                 signe = "SIGN IS LEADING SEPARATE"
                 if sign.i = "TS" then signe = "SIGN IS TRAILING SEPARATE"
                 j = cob_lines - 1
                 if length(cob.j) < 50 then do
                     cob.j = cob.j || copies(" ",50-length(cob.j))
                     cob.j = cob.j || "   " || signe
                 end /* end if length(cob.j) <= 50 */
                 else do
                    cob.cob_lines = copies(" ",50) || "   " || signe
                    cob_lines = cob_lines + 1
                 end /* end else do */
              end /* end if sign.i <> "N" */

        /* occurs */
              if occurs.i > 1 then do
                 j = cob_lines - 1
                 if length(cob.j) < 50 then do
                     cob.j = cob.j || copies(" ",50-length(cob.j))
                     cob.j = cob.j || ,
                             "   " || ,
                             "OCCURS " || ,
                             occurs.i || ,
                             " TIMES"
                 end /* end if length(cob.j) <= 50 */
                 else do
                    cob.cob_lines = copies(" ",50) || ,
                                    "   " || ,
                                    "OCCURS " || ,
                                    occurs.i || ,
                                    " TIMES"
                    cob_lines = cob_lines + 1
                 end /* end else do */
              end /* end if occurs.i > 1 */

        /* Final period */
              j = cob_lines - 1
              cob.j = cob.j || "."
           end /* end do i = 1 to total_items */
           cob.cob_lines = " "

           msgid = old_msgid
           return 0

         exit_no_options:
        /* --------------------------------------------------------- *
         * Exit with error messages when no options are specified    *
         * --------------------------------------------------------- */
           say "==>Error: XML2COB requires a minimum of XML and" ,
               "COB keywords and values."
           say " "
           say "XML2COB is a REXX script that converts XML files"
           say "into COBOL copybook."
           say " "
           say "XML2COB Syntax:"
           say " "
           say "XML2COB XML xml-ds"
           say "        COB cob-ds"
           say "        PREFIX prefix"
           say "        ROUND"
           say "        LEVEL01"
           say "        VERBOSE"
           say "        BROWSE"
           say " "

        /* --------------------------------------------------------- *
         * Trying to start Java gui front end                        *
         * --------------------------------------------------------- */
           if rexx_os <> "TSO" then do
              say "Trying to start JAVA GUI front-end ..."
              "java -jar xml2cob.jar"
           end /* end if rexx_os <> "TSO" */
           exit_rc = 12
           exit exit_rc

