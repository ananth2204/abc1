{"INMR01": {"INMLRECL": 80, "INMFNODE": "NODENAME", "INMFUID": "CTIS003", "INMTNODE": "LPPROD", "INMTUID": "SUNURAX", "INMFTIME": "20050228121908000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 587860, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 27920, "INMRECFM": "FB", "INMDIR": 6, "INMDSNAM": "CTIS003.TXT2XML.EXEC", "INMMEMBR": "CTIS003.TXT2XML.EXEC", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 587860, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 587860, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CTIS003.TXT2XML.EXEC": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 27920, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 32, "DS1SMSFG": 160, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3339, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "050059", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\xc0\\x00\\x00\\x01'", "DS1LSTAR": "b'\\x00$\\t'", "DS1TRBAL": "b'\\x0eX'"}, "COPYR2": {"deb": "b'\\x02\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03@\\x00\\x04\\xbb\\x00\\xa8'", "extents": ["b'\\x02\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03@\\x00\\x04\\xbb\\x00\\xa8'", "b'P\\xfc(\\xe0\\x00\\x00\\x01\\xef\\x00\\x00\\x01\\xf0\\x00\\x0e\\x00\\x1e'", "b'P\\xfc(\\xe0\\x00\\x00\\x05\\xa7\\x00\\x00\\x05\\xa7\\x00\\x0e\\x00\\x0f'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"TXT2XML": {"ttr": 7169, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00C\\x01\\x05\\x05\\x9f\\x01\\x05\\x05\\x9f\\x12)\\x0e\\xfa\\x0e\\xfb\\x00\\x00\\xc3\\xe3\\xc9\\xe2\\xf0\\xf0\\xf3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2005-02-28T00:00:00", "modifydate": "2005-02-28T12:29:43", "lines": 3834, "newlines": 3835, "modlines": 0, "user": "CTIS003"}, "text": "       /* rexx procedure */\n        ver = \"1.25\"\n        /* --------------------------------------------------------- *\n         *                                                           *\n         * Name:      TXT2XML                                        *\n         *                                                           *\n         * Function:  Convert a text file to and from a XML one      *\n         *            using a COBOL copybook as reference            *\n         *                                                           *\n         * Syntax:    TXT2XML   TXT txt-ds     (or DD:txt-ddname)    *\n         *                      COB cob-ds     (or DD:cob-ddname)    *\n         *                      XML xml-ds     (or DD:xml-ddname)    *\n         *                      FORMAT format  (value: X or T)       *\n         *                      PREFIX  prefix (see below)           *\n         *                      DTD dtd-ds     (or DD:dtd-ddname)    *\n         *                      VERBOSE        (display messages)    *\n         *                      BROWSE         (will browse report)  *\n         *                                                           *\n         *  (MVS)     if no parameters and under ISPF then the ISPF  *\n         *            dialog will be invoked.                        *\n         *                                                           *\n         *            Where:                                         *\n         *                                                           *\n         * ------------------- Mandatory --------------------------- *\n         *                                                           *\n         *  (MVS)     txt_ds    is a sequential dataset or member of *\n         *                      a partitioned dataset                *\n         *                                                           *\n         *  (MVS)               or dd:ddname                         *\n         *                                                           *\n         *  (WIN/UNIX)          or a file                            *\n         *                                                           *\n         *                                                           *\n         *  (MVS)     cob_ds    is a sequential dataset or member of *\n         *                      a partitioned dataset                *\n         *                                                           *\n         *  (MVS)               or dd:ddname                         *\n         *                                                           *\n         *  (WIN/UNIX)          or a file                            *\n         *                                                           *\n         *                                                           *\n         *  (MVS)     xml_ds    is a sequential dataset or member of *\n         *                      a partitioned dataset                *\n         *                                                           *\n         *  (MVS)               or dd:ddname                         *\n         *                                                           *\n         *  (WIN/UNIX)          or a file                            *\n         *                                                           *\n         *                                                           *\n         *            format    is the format of output data : X for *\n         *                      XML or T for TXT                     *\n         *                                                           *\n         * ------------------- Optional ---------------------------- *\n         *                                                           *\n         *  (MVS)     dtd_ds    is a sequential dataset or member of *\n         *                      a partitioned dataset                *\n         *                                                           *\n         *  (MVS)               or dd:ddname                         *\n         *                                                           *\n         *  (WIN/UNIX)          or a file                            *\n         *                                                           *\n         *                      or \"INTERNAL\" for the DTD included   *\n         *                      in the XML file.                     *\n         *                                                           *\n         *                                                           *\n         *            prefix    a leading string to be removed from  *\n         *                      the COBOL item name or XML element   *\n         *                                                           *\n         *                                                           *\n         *            noconfirm all messages will be suppressed.     *\n         *                      Deprecated, see \"verbose\"            *\n         *                                                           *\n         *                                                           *\n         *  (MVS)     browse    (will browse report) only used       *\n         *                      under ISPF for use by the ISPF       *\n         *                      interface                            *\n         *                                                           *\n         *                                                           *\n         *            verbose   all message will be displayed.       *\n         *                                                           *\n         * --------------------------------------------------------- *\n         *                                                           *\n         * Author(s): Lionel B. Dyck                                 *\n         *            Kaiser Permanente Information Technology       *\n         *            Walnut Creek, CA 94598                         *\n         *            (925) 926-5332                                 *\n         *            Internet: lionel.b.dyck@kp.org                 *\n         *                                                           *\n         *            Pierre Delaunoy                                *\n         *            Belgium                                        *\n         *            Mail: sunuraxi@users.sourceforge.net           *\n         *                                                           *\n         * Web:       http://sourceforge.net/projects/txt2xml-rexx/  *\n         *                                                           *\n         * Doc:       See the documentation directory or dataset     *\n         *                                                           *\n         * Functions:                                                *\n         *                                                           *\n         *  txt2bin   txt2bin(text,length,signed) where              *\n         *            - text is the text to convert.                 *\n         *            - length is the length in bytes of binary      *\n         *              data. May only be 2, 4 or 8.                 *\n         *            - signed is a flag to tell that the binary     *\n         *              item is signed. May only be \"Y\" or \"N\".      *\n         *                                                           *\n         *  txt2pack  txt2pack(text,length,signed) where             *\n         *            - text is the text to convert.                 *\n         *            - length is the length in bytes of binary      *\n         *              data.                                        *\n         *            - signed is a flag to tell that the binary     *\n         *              item is signed. May only be \"Y\" or \"N\".      *\n         *                                                           *\n         *  txt2num   txt2num(text,length,signed,sign_pos) where     *\n         *            - text is the text to convert.                 *\n         *            - length is the length in bytes of binary      *\n         *              data.                                        *\n         *            - signed is a flag to tell that the binary     *\n         *              item is signed. May only be \"Y\" or \"N\".      *\n         *            - sign_pos is a flag to tell where the sign is *\n         *              located. May only be \"L\", \"T\", \"LS\", \"TS\".   *\n         *                                                           *\n         *  bin2txt   bin2txt(bin,length,signed) where               *\n         *            - bin is the binary data to convert.           *\n         *            - length is the length in bytes of binary      *\n         *              data. May only be 2, 4 or 8.                 *\n         *            - signed is a flag to tell that the binary     *\n         *              item is signed. May only be \"Y\" or \"N\".      *\n         *                                                           *\n         *  pack2txt  pack2txt(pack) where                           *\n         *            - pack is the packed data to convert.          *\n         *                                                           *\n         *  num2txt   num2txt(num,signed,sign_pos) where             *\n         *            - num is the numeric data to convert.          *\n         *            - signed is a flag to tell that the binary     *\n         *              item is signed. May only be \"Y\" or \"N\".      *\n         *            - sign_pos is a flag to tell where the sign is *\n         *              located. May only be \"L\", \"T\", \"LS\", \"TS\".   *\n         *                                                           *\n         *---------------------------------------------------------- */\n\n         parse arg option\n         i = time(\"R\")        /* set start ot time */\n         f = \"X\"              /* default format for ISPF panel */\n\n        /* --------------------------------------------------------- *\n         * Global variables                                          *\n         * --------------------------------------------------------- */\n         msgid = \"TXT2XML:\"   /* Default message identifier */\n         r = 0                /* Used for reporting */\n         browse = 0           /* Used for reporting */\n         confirm = 0          /* Used for reporting */\n         rpt.1 = \"\"           /* Used for reporting */\n         exit_rc = 0          /* return code on exit  */\n         rexx_os = \"\"         /* Operating system running rexx*/\n         ret = 0              /* flag to return instead of exit */\n                              /* at end of PGM */\n         globals = \"rexx_os exit_rc r rpt. browse confirm msgid ret\"\n\n        /* --------------------------------------------------------- *\n         * Test if concatenation and OR operators works              *\n         * --------------------------------------------------------- */\n        /* first test concatenation operator */\n         if \"1\" || \"2\" <> \"12\" then do\n            say \"==>Error: the Rexx concatenation operator doesn't work.\"\n            say \" \"\n            say \"You may request help on the user forum at :\"\n            say \" \"\n            say ,\n                \"http://sourceforge.net/forum/forum.php?forum_id=391891\"\n            say \" \"\n            exit_rc = 12\n            exit exit_rc\n         end /* end if \"1\" || \"2\" <> \"12\" */\n\n        /* Second test OR operator */\n         if (\"1\" <> \"1\" | \"2\" <> \"2\") > 0 then do\n            say \"==>Error: the Rexx OR operator doesn't work.\" ,\n            say \" \"\n            say \"You may request help on the user forum at :\"\n            say \" \"\n            say ,\n               \"http://sourceforge.net/forum/forum.php?forum_id=391891\"\n            say \" \"\n            exit_rc = 12\n            exit exit_rc\n         end /* end if (\"1\" <> \"1\" | \"2\" <> \"2\") > 0 */\n\n        /* --------------------------------------------------------- *\n         * Get REXX Operating System and type.                       *\n         * --------------------------------------------------------- */\n        /* get rexx interpreter name */\n         parse version rexx_interpreter . .\n         rexx_interpreter = translate(rexx_interpreter)\n         if left(rexx_interpreter, 5) == \"REXX-\" then do\n            parse var rexx_interpreter \"REXX-\" rexx_interpreter \"_\" .\n         end /* end if left(rexx_interpreter, 5)  */\n\n        /* get rexx operating system */\n         parse source rexx_os .\n         rexx_os = translate(word(rexx_os,1))\n\n        /* Check OS and REXX interpreter */\n         select\n            when rexx_os = \"TSO\" then nop\n            when substr(rexx_interpreter,1,6) = \"REGINA\" then nop\n            otherwise do\n               say \"==>Error :\" ,\n                   \"Unsupported Rexx interpreter\" rexx_interpreter ,\n                   \"or unsupported operating system :\" rexx_os\n               say \" \"\n               exit_rc = 12\n               exit exit_rc\n            end /* end otherwise do  */\n         end /* end select */\n\n        /* First viewable characters in code page */\n         select\n            when rexx_os= \"TSO\" THEN first_char = \"40\"x\n            when rexx_os= \"UNIX\" THEN first_char = \"20\"x\n            when rexx_os= \"WIN32\" THEN first_char = \"20\"x\n            otherwise,\n         end /* end select */\n\n        /* --------------------------------------------------------- *\n         * If no option provided and ISPF is active then call the    *\n         * ISPF interface.                                           *\n         * --------------------------------------------------------- */\n         if length(option) <= 0 then do\n            if rexx_os = \"TSO\" then do\n               if sysvar('sysispf') = \"ACTIVE\" then do\n                  ret = 1\n                  cc = \"\"\n                  do forever\n                     cmd = \"\"\n                     Address ISPExec \"Display Panel(TXT2XML)\"\n                     if rc > 4 then exit rc\n                     option = cmd\n                     i = time(\"R\")\n                     drop r rpt.\n                     r = 0\n                     rpt.1 = \"\"\n                     call do_it cmd\n                  end /* end do forever */\n               end /* end if sysvar('sysispf') = \"ACTIVE\"  */\n               else call exit_no_options\n            end /* end if rexx_os = \"TSO\"  */\n            else call exit_no_options\n         end /* end if length(option) <= 0  */\n\n         Do_It:\n        /* --------------------------------------------------------- *\n         * Parse the input parameters.                               *\n         * --------------------------------------------------------- */\n         option = \" \" || option\n         uopt = translate(option)\n         i = pos(\" TXT \",uopt)\n         if i > 0 then option = overlay(\" TXT \",option,i,5)\n         i = pos(\" COB \",uopt)\n         if i > 0 then option = overlay(\" COB \",option,i,5)\n         i = pos(\" XML \",uopt)\n         if i > 0 then option = overlay(\" XML \",option,i,5)\n         i = pos(\" FORMAT \",uopt)\n         if i > 0 then option = overlay(\" FORMAT \",option,i,8)\n         i = pos(\" DTD \",uopt)\n         if i > 0 then option = overlay(\" DTD \",option,i,5)\n         i = pos(\" PREFIX \",uopt)\n         if i > 0 then option = overlay(\" PREFIX \",option,i,8)\n         i = pos(\" BROWSE \",uopt)\n         if i > 0 then option = overlay(\" BROWSE \",option,i,8)\n         i = pos(\" NOCONFIRM \",uopt)\n         if i > 0 then option = overlay(\" NOCONFIRM \",option,i,11)\n         i = pos(\" VERBOSE \",uopt)\n         if i > 0 then option = overlay(\" VERBOSE \",option,i,9)\n         parse var option . \" TXT \" txt ,\n                          \" COB \" cobol ,\n                          \" XML \" xml ,\n                          \" FORMAT \" output . 1 ,\n                          \" DTD \" dtd 1,\n                          \" PREFIX \" prefix . 1\n         txt = strip(txt)\n         cobol= strip(cobol)\n         xml = strip(xml)\n         i = pos(\"PREFIX\",translate(dtd))\n         if i > 0 then dtd = overlay(\"      \",dtd,i,50)\n         i = pos(\"BROWSE\",translate(dtd))\n         if i > 0 then dtd = overlay(\"      \",dtd,i,6)\n         i = pos(\"NOCONFIRM\",translate(dtd))\n         if i > 0 then dtd = overlay(\"         \",dtd,i,9)\n         i = pos(\"VERBOSE\",translate(dtd))\n         if i > 0 then dtd = overlay(\"       \",dtd,i,7)\n         dtd = strip(dtd)\n         output = translate(strip(output))\n         prefix = translate(strip(prefix))\n         prefix = translate(prefix,\"-\",\"_\")\n\n        /* --------------------------------------------------------- *\n         * Test for noconfirm & verbose                              *\n         * --------------------------------------------------------- */\n         if wordpos(\"NOCONFIRM\",uopt) > 1 then do\n            call domsg \"==>Warning :\" ,\n                       \"NOCONFIRM is deprecated. Use VERBOSE instead.\"\n            exit_rc = 4\n            confirm = 0\n         end /* end if wordpos(\"NOCONFIRM\",uopt) > 1 */\n         else confirm = 1\n         if wordpos(\"VERBOSE\",uopt) > 1 then do\n            confirm = 1\n         end /* end if wordpos(\"VERBOSE\",uopt) > 1 */\n         else confirm = 0\n\n        /* --------------------------------------------------------- *\n         * Test for Browse                                           *\n         * --------------------------------------------------------- */\n         if rexx_os = \"TSO\" then do\n            if sysvar('sysispf') <> \"ACTIVE\" then browse = 0\n            else if wordpos(\"BROWSE\",uopt) > 1 then browse = 1\n                 else browse = 0\n         end /* end if rexx_os = \"TSO\"  */\n         else browse = 0\n\n        /* --------------------------------------------------------- *\n         * Setup the default variables                               *\n         * --------------------------------------------------------- */\n         parse value \"\" with null txtdd cobdd xmldd dtddd top\n\n         if confirm >= 1 then do\n            call domsg \"Text from & to XML Conversion Utility. Version:\" ver\n            call domsg \" \"\n         end /* end if confirm >= 1 */\n\n        /* --------------------------------------------------------- *\n         * Test for the value of the output parameter                *\n         * --------------------------------------------------------- */\n         if output = null then do\n            call domsg \"==>Error :\" ,\n                       \"The format parameter must be specified.\"\n            exit_rc = 12\n            signal done\n         end /* end if output = null */\n         else do\n            output = substr(output,1,1)\n            if output <> \"X\" & output <> \"T\" then do\n               call domsg \"==>Error :\" ,\n                          \"The value of the format parameter\" ,\n                          \"must be X or T.\"\n               exit_rc = 12\n               signal done\n            end /* end if output <> \"X\" & output <> \"T\"  */\n         end /* end else do  */\n\n        /* --------------------------------------------------------- *\n         * Test that the cobol file already exists                   *\n         *      or that the cobol dd is allocated                    *\n         *      or that the file can be opened                       *\n         * --------------------------------------------------------- */\n         select\n            when rexx_os <> \"TSO\" then do\n               if stream(cobol, 'C', 'OPEN READ') <> 'READY:' then do\n                  call domsg \"==>Error :\" ,\n                             \"the cobol file\" cobol \"can not be opened.\"\n                  exit_rc = 12\n                  signal done\n               end /* end if stream(cobol, 'C', 'OPEN READ') <> 'READY:' */\n            end /* end when rexx_os <> \"TSO\" */\n            when translate(left(cobol,3)) = \"DD:\" then do\n               parse value cobol with \"DD:\" cobdd\n               x = listdsi(cobdd \"file\")\n               if x > 0 then do\n                  call domsg \"==>Error :\" ,\n                             \"the cobol ddname\" cobdd \"can not be found.\"\n                  exit_rc = 12\n                  signal done\n               end /* end if x > 0  */\n            end /* end when translate(left(cobol,3)) = \"DD:\" */\n            when \"OK\" <> sysdsn(cobol) then do\n               call domsg \"==>Error : the cobol dataset\" cobol\n               call domsg sysdsn(cobol)\n               exit_rc = 12\n               signal done\n            end /* end when \"OK\" <> sysdsn(cobol) */\n            otherwise\n         end /* end select */\n\n        /* --------------------------------------------------------- *\n         * Test that the txt file already exists                     *\n         *      or that the txt dd is allocated                      *\n         *      or that the file can be opened                       *\n         * --------------------------------------------------------- */\n         select\n            when rexx_os <> \"TSO\" then do\n               if output = \"X\" then rc = stream(txt, 'C', 'OPEN READ')\n               else rc = stream(txt, 'C', 'OPEN WRITE')\n               if rc  <> 'READY:' then do\n                  call domsg \"==>Error :\" ,\n                             \"the txt file\" txt \"can not be opened.\"\n                  exit_rc = 12\n                  signal done\n               end /* end if rc  <> 'READY:'  */\n            end /* end when rexx_os <> \"TSO\" */\n            when txt = null then do\n               call domsg \"==>Error :\" ,\n                          \"The txt file was not specified.\"\n               exit_rc = 12\n               signal done\n            end /* end when txt = null */\n            when translate(left(txt,3)) = \"DD:\" then do\n               parse value txt with \"DD:\" txtdd\n               x = listdsi(txtdd \"file\")\n               if x > 0 then do\n                  call domsg \"==>Error :\" ,\n                             \"The txt ddname\" txtdd \"can not be found.\"\n                  exit_rc = 12\n                  signal done\n               end /* end if x > 0 */\n            end /* end when translate(left(txt,3)) = \"DD:\" */\n            when \"OK\" <> sysdsn(txt) & output = \"X\" then do\n               call domsg \"==>Error : the txt file\" txt\n               call domsg sysdsn(txt)\n               exit_rc = 12\n               signal done\n            end /* end when \"OK\" <> sysdsn(txt) & output = \"X\" */\n            when \"OK\" = sysdsn(txt) & output = \"T\" then do\n               call domsg \"==>Error :\" ,\n                          \"The txt file currently exists.\" ,\n                          \"Please specify a file name to be created.\"\n               exit_rc = 12\n               signal done\n            end /* end when \"OK\" = sysdsn(txt) & output = \"T\"  */\n            otherwise\n         end /* end select */\n\n        /* --------------------------------------------------------- *\n         * Test for a specified XML file                             *\n         *      or that the XML dd is allocated                      *\n         *      or that the file can be opened                       *\n         * --------------------------------------------------------- */\n         select\n           when rexx_os <> \"TSO\" then do\n               if output = \"X\" then rc = stream(xml, 'C', 'OPEN WRITE')\n               else rc = stream(xml, 'C', 'OPEN READ')\n               if rc  <> 'READY:' then do\n                  call domsg \"==>Error :\" ,\n                             \"the XML file\" xml \"can not be opened.\"\n                  exit_rc = 12\n                  signal done\n               end /* end if rc  <> 'READY:' */\n            end /* end when rexx_os <> \"TSO\" */\n            when xml = null then do\n               call domsg \"==>Error : the xml file was not specified.\"\n               exit_rc = 12\n               signal done\n            end /* end when xml = null */\n            when translate(left(xml,3)) = \"DD:\" then do\n               parse value xml with \"DD:\" xmldd\n               x = listdsi(xmldd \"file\")\n               if x > 0 then do\n                  call domsg \"==>Error : \" ,\n                             \"the xml ddname\" xmldd \"can not be found.\"\n                  exit_rc = 12\n                  signal done\n               end /* end if x > 0 */\n            end /* end when translate(left(xml,3)) = \"DD:\" */\n            when \"OK\" <> sysdsn(xml) & output = \"T\" then do\n               call domsg \"==>Error : the xml file\" xml\n               call domsg sysdsn(xml)\n               exit_rc = 12\n               signal done\n            end /* end when \"OK\" <> sysdsn(xml) & output = \"T\" */\n            when \"OK\" = sysdsn(xml) & output = \"X\" then do\n               call domsg \"==>Error :\" ,\n                          \"The xml file currently exists.\"\n               call domsg \"Please specify a file name to be created.\"\n               exit_rc = 12\n               signal done\n            end /* end when \"OK\" = sysdsn(xml) & output = \"X\" */\n            otherwise\n         end /* end select */\n\n        /* --------------------------------------------------------- *\n         * Test that the dtd parameter is only present during txt    *\n         *           to XML conversion                               *\n         *      or that the dtd file already exists                  *\n         *      or that the dtd dd is allocated                      *\n         *      or that the file can be opened                       *\n         * --------------------------------------------------------- */\n          if output = \"X\" then do\n             select\n               when length(dtd) <= 0 then nop\n               when translate(dtd) = \"INTERNAL\" then dtd = \"INTERNAL\"\n               when rexx_os <> \"TSO\" then do\n                  rc = stream(dtd, 'C', 'OPEN WRITE')\n                  if rc  <> 'READY:' then do\n                     call domsg \"==>Error :\" ,\n                                \"the dtd file\" dtd \"can not be opened.\"\n                     exit_rc = 12\n                     signal done\n                  end /* end if rc  <> 'READY:'  */\n               end /* end when rexx_os <> \"TSO\" */\n               when translate(left(dtd,3)) = \"DD:\" then do\n                  parse value dtd with \"DD:\" dtddd\n                  x = listdsi(dtddd \"file\")\n                  if x > 0 then do\n                     call domsg \"==>Error :\" ,\n                                \"The dtd ddname\" dtddd \"can not be found.\"\n                     exit_rc = 12\n                     signal done\n                  end /* end if x > 0 */\n               end /* end when translate(left(dtd,3)) = \"DD:\" */\n               when \"OK\" = sysdsn(dtd) then do\n                  call domsg \"==>Error :\" ,\n                             \"The dtd file currently exists.\"\n                  call domsg \"Please specify a file name to be created.\"\n                  exit_rc = 12\n                  signal done\n               end /* end when \"OK\" = sysdsn(dtd) */\n               otherwise\n            end /* end select */\n         end /* end if output = \"X\" */\n         else if length(dtd) > 0 then do\n            call domsg \"==>Error :\" ,\n                       \"The DTD parameter may only be specified\" ,\n                       \"for a text to XML conversion.\"\n            exit_rc = 12\n            signal done\n         end /* end else if length(dtd) > 0 */\n\n        /* --------------------------------------------------------- *\n         * Alloc the txt, DTD and XML files if needed                *\n         * --------------------------------------------------------- */\n         if rexx_os = \"TSO\" then do\n            if txtdd = null & output = \"X\" then do\n               \"Alloc f(\"textdd\") shr ds(\"txt\") reuse\"\n            end /* end if txtdd = null & output = \"X\" */\n            if xmldd = null & output = \"T\" then do\n               \"Alloc f(\"xml2dd\") shr ds(\"xml\") reuse\"\n            end /* end if xmldd = null & output = \"T\" */\n         end /* end if rexx_os = \"TSO\" */\n\n        /* --------------------------------------------------------- *\n         * Read the COBOL file into cob.                             *\n         * --------------------------------------------------------- */\n         select\n            when rexx_os <> \"TSO\" then do\n               i = 0\n               do while lines(cobol) > 0\n                  i = i + 1\n                  cob.i = linein(cobol, , 1)\n               end /* end do while lines(cobol) > 0 */\n               cob.0 = i\n               rc = stream(cobol, 'C', 'CLOSE')\n            end /* end when rexx_os <> \"TSO\" */\n            when cobdd = null then do\n               \"Alloc f(\"dd\") shr ds(\"cobol\") reuse\"\n               \"Execio * diskr\" dd \"(finis stem cob.\"\n               \"Free f(\"dd\")\"\n            end /* end when cobdd = null */\n            when cobdd <> null then \"Execio * diskr\" cobdd \"(finis stem cob.\"\n            otherwise\n         end /* end select */\n\n        /* --------------------------------------------------------- *\n         * \"Clean\" the COBOL file                                    *\n         * --------------------------------------------------------- */\n         j = 0\n         nb_line = 0\n         do i = 1 to cob.0\n\n        /* skip comment lines */\n            if substr(cob.i,7,1) = \"*\" then iterate\n            if substr(cob.i,7,1) = \"/\" then iterate\n\n        /* skip blank lines */\n            if length(strip(substr(cob.i,8,65))) <= 0 then iterate\n            j = j + 1\n\n        /* Take only the interesting part of the line without line\n           numbers */\n            copybook.j = substr(cob.i,7,66)\n\n        /* test to see if line is continuated on next line */\n            k = i + 1\n            do forever\n               if k > cob.0 then leave\n\n        /* leave the loop if new level is found */\n               if datatype(word(substr(cob.k,8,65),1)) = \"NUM\" then leave\n\n        /* if next line is not a comment, concatenate previous line\n           with current line */\n               if substr(cob.k,7,1) <> \"*\" & ,\n                  substr(cob.k,7,1) <> \"/\" then do\n                  copybook.j = strip(copybook.j,\"t\") ,\n                               strip(substr(cob.k,8,65))\n                  i = i + 1\n               end /* end if substr(cob.k,7,1) <> \"*\" & */\n               k = k + 1\n            end /* end do forever */\n            copybook.j = translate(copybook.j)\n\n        /* replace PICTURE clause with PIC clause */\n            if wordpos(\"PICTURE\",copybook.j) > 0 then do\n               copybook.j = ,\n               overlay(\"     PIC \",copybook.j,pos(\" PICTURE \",copybook.j))\n            end /* end if wordpos(\"PICTURE\",copybook.j) > 0 */\n\n        /* ignore IS in PICTURE clause */\n            if word(copybook.j,wordpos(\"PIC\",copybook.j)+1) = \"IS\" then do\n               copybook.j = overlay(\"    \",copybook.j,pos(\" IS \",copybook.j))\n            end /* end if word(copybook.j,wordpos(\"PIC\",copybook.j)+1) ... */\n\n        /* ignore IS in VALUE clause */\n            if word(copybook.j,wordpos(\"VALUE\",copybook.j)+1) ,\n               = \"IS\" then do\n               copybook.j = overlay(\"    \",copybook.j,pos(\" IS \",copybook.j))\n            end /* end if word(copybook.j,wordpos(\"VALUE\",copybook.j)+1) , */\n\n        /* ignore IS in USAGE clause */\n            if word(copybook.j,wordpos(\"USAGE\",copybook.j)+1) = \"IS\" then do\n               copybook.j = overlay(\"    \",copybook.j,pos(\" IS \",copybook.j))\n            end /* end if word(copybook.j,wordpos(\"USAGE\",copybook.j)+1) , */\n\n        /* ignore USAGE clause */\n            if wordpos(\"USAGE\",copybook.j) > 0 then do\n               copybook.j = ,\n                  overlay(\"       \",copybook.j,pos(\" USAGE \",copybook.j))\n            end /* end if wordpos(\"USAGE\",copybook.j) > 0 */\n\n        /* ignore IS in SIGN clause */\n            if word(copybook.j,wordpos(\"SIGN\",copybook.j)+1) = \"IS\" then do\n               copybook.j = overlay(\"    \",copybook.j, ,\n               pos(\" IS \",copybook.j))\n            end /* end if word(copybook.j,wordpos(\"SIGN\",copybook.j)+1) , */\n\n        /* ignore SIGN clause */\n            if wordpos(\"SIGN\",copybook.j) > 0 then do\n               copybook.j = overlay(\"      \",copybook.j, ,\n                                    pos(\" SIGN \",copybook.j))\n            end /* end if wordpos(\"SIGN\",copybook.j) > 0 */\n\n        /* ignore NATIVE clause */\n            if wordpos(\"NATIVE\",copybook.j) > 0 then do\n               copybook.j = overlay(\"        \",copybook.j, ,\n                                    pos(\" NATIVE \",copybook.j))\n            end /* end if wordpos(\"NATIVE\",copybook.j) > 0 */\n\n        /* ignore DISPLAY clause */\n            if wordpos(\"DISPLAY\",copybook.j) > 0 then do\n               copybook.j = overlay(\"         \",copybook.j, ,\n                                    pos(\" DISPLAY \",copybook.j))\n            end /* end if wordpos(\"DISPLAY\",copybook.j) > 0 */\n\n        /* suppress final dot */\n            copybook.j = strip(copybook.j,\"t\")\n            if substr(copybook.j,length(copybook.j),1) = \".\" then do\n               copybook.j = overlay(\" \",copybook.j,length(copybook.j))\n            end /* end if substr(copybook.j,length(copybook.j),1) = \".\" */\n\n        /* replace 9(4) with 9999 in PIC clause */\n            if pos(\"(\",copybook.j) > 0 then do\n               temp = word(copybook.j,wordpos(\"PIC\",copybook.j)+1)\n               clause = temp\n               do k = 2 to length(temp)\n\n        /* find \"(\" and \")\" */\n                  if substr(temp,k,1) = \"(\" then start_pos=k\n                  if substr(temp,k,1) = \")\" then do\n                     end_pos = k\n\n        /* find symbol and length */\n                     lengt = substr(temp,start_pos+1,end_pos-start_pos-1)\n                     symbole = substr(temp,start_pos-1,1)\n                     temp = substr(temp,1,start_pos-1) || ,\n                            copies(symbole,lengt-1) || ,\n                            substr(temp,end_pos+1)\n                  end /* end if substr(temp,k,1) = \")\" */\n               end /* end do k = 2 to length(temp) */\n\n        /* replace old picture symbol with new */\n               copybook.j = substr(copybook.j,1,pos(clause,copybook.j)-1) || ,\n                 temp || ,\n                 substr(copybook.j,pos(clause,copybook.j)+length(clause))\n            end /* end if pos(\"(\",copybook.j) > 0 */\n         end /* end do i = 1 to cob.0 */\n         nb_line = j\n         drop cob. symbole temp lengt clause end_pos\n\n        /* --------------------------------------------------------- *\n         * Analyze the cobol copy book                               *\n         * --------------------------------------------------------- */\n         cobol_length = 0       /* total computed COBOL length of copybook */\n         nb_items = 0           /* number of COBOL items */\n         occurs_group_level = 0 /* level of an array group item */\n         signed_group_level = 0 /* level of an signed group item */\n         start_pos.1 = 1\n         do i = 1 to nb_line\n\n        /* stop if REDEFINES clause is found */\n            if wordpos(\"REDEFINES\", copybook.i) > 0 then do\n               call domsg \"==>Error :\" ,\n                          \"in the COBOL copybook,\" ,\n                          \"REDEFINES clause is not supported.\"\n               exit_rc = 12\n               signal done\n            end /* end if wordpos(\"REDEFINES\", copybook.i) > 0 */\n\n        /* stop if POINTER clause is found */\n            if wordpos(\"POINTER\", copybook.i) > 0 then do\n               call domsg \"==>Error :\" ,\n                          \"in the COBOL copybook,\" ,\n                          \"POINTER clause is not supported.\"\n               exit_rc = 12\n               signal done\n            end /* end if wordpos(\"POINTER\", copybook.i) > 0 */\n\n        /* stop if PROCEDURE-POINTER clause is found */\n            if wordpos(\"PROCEDURE-POINTER\", copybook.i) > 0 then do\n               call domsg \"==>Error :\" ,\n                          \"in the COBOL copybook,\" ,\n                          \"PROCEDURE-POINTER clause is not supported.\"\n               exit_rc = 12\n               signal done\n            end /* end if wordpos(\"PROCEDURE-POINTER\", copybook.i) > 0 */\n\n        /* stop if FUNCTION-POINTER clause is found */\n            if wordpos(\"FUNCTION-POINTER\", copybook.i) > 0 then do\n               call domsg \"==>Error :\" ,\n                          \"in the COBOL copybook,\" ,\n                          \"FUNCTION-POINTER clause is not supported.\"\n               exit_rc = 12\n               signal done\n            end /* end if wordpos(\"FUNCTION-POINTER\", copybook.i) > 0 */\n\n        /* stop if OBJECT REFERENCE clause is found */\n             if wordpos(\"REFERENCE\", copybook.i) = ,\n                wordpos(\"OBJECT\",copybook.i) + 1  then do\n                call domsg \"==>Error :\" ,\n                           \"in the COBOL copybook,\" ,\n                           \"OBJECT REFERENCE clause is not supported.\"\n                exit_rc = 12\n                signal done\n            end /* end if wordpos(\" REFERENCE\", copybook.i) =  */\n\n        /* stop if one of COMP-1, COMP-2, COMP-5 clauses is found */\n            if wordpos(\"COMPUTATIONAL-1\", copybook.i) > 0  | ,\n               wordpos(\"COMP-1\", (copybook.i)) > 0 | ,\n               wordpos(\"COMPUTATIONAL-2\", copybook.i) > 0  | ,\n               wordpos(\"COMP-2\", copybook.i) > 0 | ,\n               wordpos(\"COMPUTATIONAL-5\", copybook.i) > 0  | ,\n               wordpos(\"COMP-5\", copybook.i) > 0 then do\n               call domsg \"==>Error :\" ,\n                          \"in the COBOL copybook,\" ,\n                          \"COMP-1, COMP-2, COMP-5\",\n                          \"clauses are not supported.\"\n               exit_rc = 12\n               signal done\n            end /* end if wordpos(\"COMPUTATIONAL-1\", copybook.i) > 0  | , */\n\n        /* stop if INDEX clause is found */\n            if wordpos(\"INDEX\", copybook.i) > 0 then do\n               call domsg \"==>Error :\" ,\n                          \"in the COBOL copybook,\" ,\n                          \"INDEX clause is not supported.\"\n               exit_rc = 12\n               signal done\n            end /* end if wordpos(\"INDEX\", copybook.i) > 0 */\n\n        /* stop if DISPLAY-1 clause is found */\n            if wordpos(\"DISPLAY-1\", copybook.i) > 0 then do\n               call domsg \"==>Error :\" ,\n                          \"in the COBOL copybook,\" ,\n                          \"DISPLAY-1 clause is not supported.\"\n               exit_rc = 12\n               signal done\n            end /* end if wordpos(\"DISPLAY-1\", copybook.i) > 0 */\n\n        /* stop if NATIONAL clause is found */\n            if wordpos(\"NATIONAL\", copybook.i) > 0 then do\n               call domsg \"==>Error :\" ,\n                          \"in the COBOL copybook,\" ,\n                          \"NATIONAL clause is not supported\".\n               exit_rc = 12\n               signal done\n            end /* end if wordpos(\"NATIONAL\", copybook.i) > 0 */\n\n        /* stop if SYNC clause is found */\n             if wordpos(\"SYNC\", copybook.i) > 0 | ,\n                wordpos(\"SYNCHRONIZED\", copybook.i) > 0 then do\n               call domsg \"==>Error :\" ,\n                          \"in the COBOL copybook,\" ,\n                          \"SYNCHRONYZED clause is not supported\".\n               exit_rc = 12\n               signal done\n            end /* end if wordpos(\"SYNC\", copybook.i) > 0 */\n\n        /* stop if DEPENDING clause is found */\n            if wordpos(\"DEPENDING\", copybook.i) > 0 then do\n               call domsg \"==>Error :\" ,\n                          \"in the COBOL copybook,\" ,\n                          \"DEPENDING clause is not supported\".\n               exit_rc = 12\n               signal done\n            end /* end if wordpos(\"DEPENDING\", copybook.i) > 0 */\n\n        /* stop if level is not numeric */\n            if datatype(word(copybook.i,1)) <> \"NUM\" then do\n               call domsg \"==>Error :\" ,\n                          \"in the COBOL copybook,\" ,\n                          \"level\" word(copybook.1,1) \" is not numeric.\"\n               exit_rc = 12\n               signal done\n            end /* end if datatype(word(copybook.i,1)) <> \"NUM\" */\n\n        /* ignore level 77 or 88 or 66 items */\n            if word(copybook.i,1) = \"66\" | ,\n               word(copybook.i,1) = \"77\" | ,\n               word(copybook.i,1) = \"88\" then do\n               call domsg \"==>Warning :\" ,\n                          \"in the COBOL copybook,\" ,\n                          \"level 66, 77, 88 items are ignored.\"\n               exit_rc = 4\n               iterate\n            end /* end if word(copybook.i,1) = \"66\" | , */\n\n        /* stop if level is greater than 50 */\n            if word(copybook.i,1) > \"49\" then do\n               call domsg \"==>Error :\" ,\n                          \"in the COBOL copybook,\" ,\n                          \"level (\" level ,\n                          \") greater than 49 are not allowed\" ,\n                          \"in COBOL.\"\n               exit_rc = 12\n               signal done\n            end /* end if word(copybook.i,1) > \"49\" */\n\n        /* if an OCCURS clause was detected for a group item and if we have\n           reached the end of the group item then ... */\n            if occurs_group_level > 0 & ,\n               word(copybook.i,1) <= occurs_group_level then do\n\n        /* go backward to the start of the group ... */\n               do j = nb_items to 1 by -1\n                  if level.j <= occurs_group_level then leave\n               end /* end do j = nb_items to 1 by -1 */\n               l = nb_items\n\n        /* and repeat it according to the OCCURS clause */\n               do occurs.j - 1\n                  do k = j to l\n                     nb_items = nb_items + 1\n                     m = nb_items + 1\n                     name.nb_items = name.k\n                     type.nb_items = type.k\n                     occurs.nb_items = occurs.j\n                     default.nb_items = default.k\n                     length.nb_items = length.k\n                     signed.nb_items = signed.k\n                     sign_pos.nb_items = sign_pos.k\n                     level.nb_items = level.k\n                     start_pos.m = start_pos.nb_items + length.nb_items\n                     cobol_length = cobol_length + length.nb_items\n                  end /* end do k = j to l */\n               end /* end do occurs.j - 1 */\n               occurs_group_level = 0\n            end /* end if occurs_group_level > 0 & , */\n\n        /* count number of items */\n            nb_items = nb_items + 1\n\n        /* find name and level of item */\n            level.nb_items = word(copybook.i,1)\n            name.nb_items = word(copybook.i,2)\n\n        /* find sign characteristics of item */\n            signed.nb_items = \"\"\n            sign_pos.nb_items = \"\"\n            if wordpos(\"PIC\",copybook.i) > 0 then do\n               temp = word(copybook.i,wordpos(\"PIC\",copybook.i) + 1)\n               if left(temp,1) = \"S\" then do\n                  signed.nb_items = \"Y\"\n                  if signed_group_item = \"Y\" then ,\n                     sign_pos.nb_items = sign_pos_group_item\n                  if wordpos(\"SEPARATE\",copybook.i) > 0 then do\n                     if wordpos(\"LEADING\",copybook.i) > 0 then ,\n                        sign_pos.nb_items = \"LS\"\n                     else sign_pos.nb_items = \"TS\"\n                  end /* end if wordpos(\"SEPARATE\",copybook.i) > 0 */\n                  else do\n                     if wordpos(\"LEADING\",copybook.i) > 0 then ,\n                        sign_pos.nb_items = \"L\"\n                     else if sign_pos.nb_items = \"\" then ,\n                        sign_pos.nb_items = \"T\"\n                  end /* end else do */\n               end /* end if left(temp,1) = \"S\" */\n               else signed.nb_items = \"N\"\n            end /* end if wordpos(\"PIC\",copybook.i) > 0 */\n\n        /* check if sign applies to a group of items */\n            else do\n               if wordpos(\"LEADING\",copybook.i) > 0 | ,\n                  wordpos(\"TRAILING\",copybook.i) > 0 then do\n                  signed_group_item = \"Y\"\n                  signed_group_level = level.i\n                  if wordpos(\"SEPARATE\",copybook.i) > 0 then do\n                     if wordpos(\"LEADING\",copybook.i) > 0 then ,\n                        sign_pos_group_item = \"LS\"\n                     else sign_pos_group_item = \"TS\"\n                  end /* end if wordpos(\"SEPARATE\",copybook.i) > 0 */\n                  else do\n                     if wordpos(\"LEADING\",copybook.i) > 0 then ,\n                        sign_pos_group_item = \"L\"\n                     else sign_pos_group_item = \"T\"\n                  end /* end else do */\n                  signed.nb_items = \"Y\"\n                  sign_pos.nb_items = sign_pos_group_item\n               end /* end if wordpos(\"LEADING\",copybook.i) > 0 | ,  */\n               else if level.i <= signed_group_level then do\n                  signed_group_level = 0\n                  drop signed_group_item sign_pos_group_item\n               end /* end else if level.i <= signed_group_level */\n            end /* end else do */\n            drop temp\n\n        /* find length of item */\n            if wordpos(\"PIC\",copybook.i) > 0 then do\n               temp = word(copybook.i,wordpos(\"PIC\",copybook.i) + 1)\n               if left(temp,1) = \"S\" then temp = substr(temp,2)\n               length.nb_items = length(temp)\n               if pos(\"V\",temp) > 0 then length.nb_items = length.nb_items - 1\n               if wordpos(\"SEPARATE\",copybook.i) > 0 |,\n                  sign_pos.nb_items = \"LS\" | ,\n                  sign_pos.nb_items = \"TS\" then ,\n                  length.nb_items = length.nb_items + 1\n               else if wordpos(\"COMP-3\",copybook.i) > 0 | ,\n                       wordpos(\"COMPUTATIONAL-3\",copybook.i) > 0 | ,\n                       wordpos(\"PACKED-DECIMAL\",copybook.i) > 0 then do\n                       if length(temp) = 2 * (length(temp) % 2) then ,\n                          length.nb_items  = (length.nb_items + 2) / 2\n                       else length.nb_items  = (length.nb_items + 1) / 2\n               end /* end else if wordpos(\"COMP-3\",copybook.i) > 0 | , */\n               else if wordpos(\"COMP-4\",copybook.i) > 0 | ,\n                       wordpos(\"COMPUTATIONAL-4\",copybook.i) > 0 | ,\n                       wordpos(\"COMPUTATIONAL\",copybook.i) > 0 | ,\n                       wordpos(\"COMP\",copybook.i) > 0 | ,\n                       wordpos(\"BINARY\",copybook.i) > 0 then do\n                       select\n                          when length(temp) <= 4 then length.nb_items = 2\n                          when length(temp) <= 9 then length.nb_items = 4\n                          when length(temp) <= 18 then length.nb_items = 8\n                          otherwise do\n                             call domsg \"==>Error :\" ,\n                                  \"in the COBOL copybook, a binary item\",\n                                   name.nb_items ,\n                                  \"has a PICTURE length greater than 18.\"\n                             exit_rc = 12\n                             signal done\n                          end /* end otherwise do */\n                       end /* end select */\n               end /* end else if wordpos(\"COMP-4\",copybook.i) > 0 | , */\n            end /* end if wordpos(\"PIC\",copybook.i) > 0 */\n            else length.nb_items = 0\n            drop temp\n\n        /* find type of item */\n            if wordpos(\"PIC\",copybook.i) > 0 then do\n               j = word(copybook.i,wordpos(\"PIC\",copybook.i)+1)\n               select\n                  when wordpos(\"COMP-3\",copybook.i) > 0 then ,\n                     type.nb_items = \"PACK\"\n                  when wordpos(\"COMPUTATIONAL-3\",copybook.i) > 0 then ,\n                     type.nb_items = \"PACK\"\n                  when wordpos(\"PACKED-DECIMAL\",copybook.i) > 0 then ,\n                     type.nb_items = \"PACK\"\n                  when wordpos(\"COMP-4\",copybook.i) > 0 then ,\n                     type.nb_items = \"BIN\"\n                  when wordpos(\"COMPUTATIONAL-4\",copybook.i) > 0 then ,\n                     type.nb_items = \"BIN\"\n                  when wordpos(\"COMP\",copybook.i) > 0 then ,\n                     type.nb_items = \"BIN\"\n                  when wordpos(\"COMPUTATIONAL\",copybook.i) > 0 then ,\n                     type.nb_items = \"BIN\"\n                  when wordpos(\"BINARY\",copybook.i) > 0 then ,\n                     type.nb_items = \"BIN\"\n                  when pos(\"P\",j) > 0 then do\n                     call domsg \"==>Error :\" ,\n                                \"in the COBOL copybook,\" ,\n                                \"the scaling postion character P\" ,\n                                \"is not supported.\"\n                     exit_rc = 12\n                     signal done\n                  end /* end when pos(\"P\",j) > 0 */\n                  when pos(\"9\",j)>0 & pos(\"X\",j) = 0 then type.nb_items = \"NUM\"\n                  when pos(\"0\",j)>0 & pos(\"X\",j) = 0 then type.nb_items = \"NUM\"\n                  when pos(\"Z\",j)>0 & pos(\"X\",j) = 0 then type.nb_items = \"NUM\"\n                  when pos(\"G\",j) > 0 then do\n                     call domsg \"==>Error :\" ,\n                                \"in the COBOL copybook,\" ,\n                                \"DBCS symbols are not supported.\"\n                     exit_rc = 12\n                     signal done\n                  end /* end when pos(\"G\",j) > 0 */\n                  when pos(\"N\",j) > 0 then do\n                     call domsg \"==>Error :\" ,\n                                \"in the COBOL copybook,\" ,\n                                \"DBCS or national symbols are not supported.\"\n                     exit_rc = 12\n                     signal done\n                  end /* end when pos(\"N\",j) > 0 */\n                  otherwise type.nb_items = \"CHAR\"\n               end /* end select */\n            end /* end if wordpos(\"PIC\",copybook.i) > 0 */\n            else type.nb_items = \"GROUP\"\n            if type.nb_items = \"PACK\" | ,\n               type.nb_items = \"BIN\" | ,\n               signed.nb_items = \"\" then ,\n               sign_pos.nb_items = \"\"\n            if type.nb_items = \"CHAR\" then do\n               signed.nb_items = \"\"\n               sign_pos.nb_items = \"\"\n            end /* end if type.nb_items = \"CHAR\" */\n\n        /* find VALUE clause and save the default value */\n            if wordpos(\"VALUE\",copybook.i) > 0 then do\n               start_pos = 0\n               end_pos = 0\n               quote = 0\n               apost = 0\n               k = pos(\" VALUE \",copybook.i) + length(\" VALUE \")\n\n        /* Alphanumeric value */\n               do l = k to length(copybook.i)\n                  if substr(copybook.i,l,1) = '\"' | ,\n                     substr(copybook.i,l,1) = \"'\" then do\n                     if start_pos = 0 then do\n                        start_pos = l + 1\n                        if substr(copybook.i,l,1) = \"'\" then apost = 1\n                        else quote = 1\n                     end /* end if start_pos = 0 */\n                     else if substr(copybook.i,l,2) <> '\"\"' & ,\n                             substr(copybook.i,l,2) <> \"''\" ,\n                             then end_pos = l - 1\n                  end /* end if substr(copybook.i,l,1) = '\"' | , */\n\n        /* Numeric value */\n                  else if substr(copybook.i,l,1) <> \" \" then do\n                     if quote = 0 & apost = 0 then do\n                        if start_pos = 0 then start_pos = l\n                        else if substr(copybook.i,l,1) = \" \" then end_pos = l\n                     end /* end if quote = 0 & apost = 0 */\n                  end /* end if substr(copybook.i,l,1) <> \" \" */\n               end /* end do l = k to length(copybook.i) */\n               if end_pos = 0 then end_pos = length(copybook.i)\n               j = substr(copybook.i,start_pos,end_pos-start_pos+1)\n\n        /* Literal value */\n               select\n                  when j = \"LOW-VALUES\" | j = \"LOW-VALUE\" then ,\n                     default.nb_items = copies(\"00\"x,length.nb_items)\n                  when j = \"HIGH-VALUES\" | j = \"HIGH-VALUE\" then ,\n                     default.nb_items = copies(\"FF\"x,length.nb_items)\n                  when j = \"ZEROES\" | j = \"ZERO\" | j = \"ZEROS\" then do\n                     select\n                        when type.nb_items = \"BIN\" then default.nb_items = ,\n                           txt2bin(0,length.nb_items,\"N\")\n                        when type.nb_items = \"PACK\" then default.nb_items = ,\n                           txt2pack(0,length.nb_items,\"N\")\n                        when type.nb_items = \"NUM\" then default.nb_items = ,\n                           txt2num(0,length.nb_items,\"N\",\"\")\n                        otherwise ,\n                           default.nb_items = copies(\"0\",length.nb_items)\n                     end /* end select */\n                  end /* end when j = \"ZEROES\" | j = \"ZERO\" | j = \"ZEROS\" */\n                  when j = \"SPACES\" | j = \"SPACE\" then ,\n                     default.nb_items = copies(\" \",length.nb_items)\n                  when j = \"NULL\" then do\n                     call domsg \"==>Error :\" ,\n                                \"in the COBOL copybook,\" ,\n                                \"NULL clause is not supported. \"\n                     exit_rc = 12\n                     signal done\n                  end /* end when j = \"NULL\" */\n                  when j = \"QUOTE\" | j = \"QUOTES\" then do\n                     call domsg \"==>Error :\" ,\n                                \"in the COBOL copybook,\" ,\n                                \"QUOTE clause is not supported. \"\n                     exit_rc = 12\n                     signal done\n                  end /* end when j = \"QUOTE\" | j = \"QUOTES\" */\n                  when word(j,1) = \"ALL\" then do\n                     k = \"\"\n                     parse var j \"ALL\" k\n                     k = strip(k)\n                     if substr(k,1,1) = \"'\" | substr(k,1,1) = '\"' then ,\n                        k = substr(k,2)\n                     default.nb_items = copies(k,length.nb_items)\n                  end /* end when j = \"ALL\" */\n                  otherwise do\n                     temp = substr(copybook.i,start_pos,end_pos-start_pos+1)\n                     select\n                        when type.nb_items = \"BIN\" then default.nb_items = ,\n                           txt2bin(temp,length.nb_items,signed.nb_items)\n                        when type.nb_items = \"PACK\" then default.nb_items = ,\n                           txt2pack(temp,length.nb_items,signed.nb_items)\n                        when type.nb_items = \"NUM\" then default.nb_items = ,\n                           txt2num(temp,length.nb_items,signed.nb_items, ,\n                                   sign_pos.nb_items)\n                        otherwise default.nb_items = temp\n                     end /* end select */\n                     drop temp\n                  end /* end otherwise do */\n               end /* end select */\n\n        /* Suppress double quote or double apost */\n               if (quote > 0 | apost > 0) then do\n                  if (pos('\"\"',default.nb_items) > 0 | ,\n                     pos(\"''\",default.nb_items) > 0 ) then do\n                     temp = \"\"\n                     do j = 1 to length(default.nb_items)\n                        if substr(default.nb_items,j,2) = \"''\" & ,\n                           apost > 0 then do\n                           temp = temp || \"'\"\n                           j = j + 1\n                        end /* end if substr(default.nb_items,j,2) = \"''\" & */\n                        else if substr(default.nb_items,j,2) = '\"\"' &,\n                             quote > 0 then do\n                                temp = temp || '\"'\n                                j = j + 1\n                             end /* end if substr(default.nb_items,j,2)='\"\"'*/\n                             else temp = temp || substr(default.nb_items,j,1)\n                     end /* end if (pos('\"\"',default.nb_items) > 0 | , */\n                     default.nb_items = temp\n                     drop temp\n                  end /* end if (pos('\"\"',default.nb_items) > 0 | , */\n               end /* end if (quote > 0 | apost > 0) */\n            end /* end if wordpos(\"VALUE\",copybook.i) > 0 */\n\n         /* No default values : initialize with zeroes and spaces */\n            else do\n               select\n                  when type.nb_items = \"BIN\" then default.nb_items = ,\n                     txt2bin(0,length.nb_items,\"N\")\n                  when type.nb_items = \"PACK\" then default.nb_items = ,\n                     txt2pack(0,length.nb_items,\"N\")\n                  when type.nb_items = \"NUM\" then default.nb_items = ,\n                     txt2num(0,length.nb_items,\"N\",\"\")\n                  otherwise default.nb_items = copies(\" \",length.nb_items)\n               end /* end select */\n            end /* end else do */\n            drop apost quote temp start_pos end_pos\n\n        /* find OCCURS clause */\n            if wordpos(\"OCCURS\",copybook.i) > 0 then occurs.nb_items = ,\n               word(copybook.i,wordpos(\"OCCURS\",copybook.i) + 1)\n            else occurs.nb_items = 1\n\n        /* compute starting position of next item */\n            k = nb_items + 1\n            start_pos.k = start_pos.nb_items + length.nb_items\n\n        /* handle OCCURS clause ...  */\n            if occurs.nb_items > 1 then do\n\n        /* ... for elementary items ... */\n               if length.nb_items > 0 then do\n                  cobol_length = cobol_length + length.nb_items\n                  j = nb_items\n                  do occurs.j - 1\n                     nb_items = nb_items + 1\n                     k = nb_items + 1\n                     name.nb_items = name.j\n                     type.nb_items = type.j\n                     occurs.nb_items = occurs.j\n                     signed.nb_items = signed.j\n                     sign_pos.nb_items = sign_pos.j\n                     default.nb_items = default.j\n                     length.nb_items = length.j\n                     level.nb_items = level.j\n                     start_pos.k = start_pos.nb_items + length.nb_items\n                     cobol_length = cobol_length + length.nb_items\n                  end /* end do occurs.j - 1 */\n               end /* end if length.nb_items > 0 */\n\n        /* ... and for group items. */\n               else do\n                  if occurs_group_level <= 0 then do\n                     occurs_group_level = level.nb_items\n                  end /* end if occurs_group_level <= 0 */\n               end /* end else do */\n            end /* end if occurs.nb_items > 1 */\n\n        /* compute total length of file */\n            else cobol_length = cobol_length + length.nb_items\n\n         end /* end do i = 1 to nb_line */\n\n        /* if an OCCURS clause was detected for a group item and if we have\n           reached the end of the copybook then ... */\n         if occurs_group_level > 0 & i >= nb_line then do\n\n        /* go backward to the start of the group ... */\n            do j = nb_items to 1 by -1\n               if level.j <= occurs_group_level then leave\n            end /* end do j = nb_items to 1 by -1 */\n            l = nb_items\n\n        /* and repeat it according to the OCCURS clause */\n            do occurs.j - 1\n               do k = j to l\n                  nb_items = nb_items + 1\n                  m = nb_items + 1\n                  name.nb_items = name.k\n                  type.nb_items = type.k\n                  occurs.nb_items = occurs.j\n                  default.nb_items = default.k\n                  signed.nb_items = signed.k\n                  sign_pos.nb_items = sign_pos.k\n                  length.nb_items = length.k\n                  level.nb_items = level.k\n                  start_pos.m = start_pos.nb_items + length.nb_items\n                  cobol_length = cobol_length + length.nb_items\n               end /* end do k = j to l */\n            end /* end do occurs.j - 1 */\n            occurs_group_level = 0\n         end /* end if occurs_group_level > 0 & i >= nb_line */\n\n         /* --------------------------------------------------------- *\n         * If computed length equals zero, exit                      *\n         * --------------------------------------------------------- */\n         if cobol_length = 0 then do\n            call domsg \"==>Error :\" ,\n                       \"in the COBOL copybook,\" ,\n                       \"The total length of the COBOL items is zero\"\n            exit_rc = 12\n            signal done\n         end /* end if cobol_length = 0 */\n\n        /* --------------------------------------------------------- *\n         * Renumber the COBOL level so that identation of XML        *\n         * elements will smoother and independent of copybook        *\n         * absolute level                                            *\n         * --------------------------------------------------------- */\n        /* firstly copy the level array and bubble sort it */\n         do i = 1 to nb_items\n            l.i = level.i\n         end /* end do i = 1 to nb_items */\n         j = nb_items\n         do forever\n            inversion = 0\n            do i = 1 to j - 1\n               k = i + 1\n               if l.i > l.k then do\n                  a = l.k\n                  l.k = l.i\n                  l.i = a\n                  inversion = 1\n               end /* end if l.i > l.k then do */\n            end /* end do i = 1 to j - 1 */\n            j = j - 1\n            if inversion <= 0 then leave\n         end /* end do forever */\n\n        /* Secondly, suppress non-unique levels */\n         k = 1\n         m.k = l.1\n         do i = 1 to nb_items - 1\n            j = i + 1\n            if l.j > l.i then do\n               k = k + 1\n               m.k = l.j\n            end /* end if l.j > l.i */\n         end /* end do i = 1 to nb_items - 1 */\n\n        /* thirdly, renumber levels */\n         do i = 1 to nb_items\n            do j = 1 to k\n               if level.i = m.j then do\n                  level.i = j\n                  leave\n               end /* end if level.i = m.j */\n            end /* end do j = 1 to k */\n         end /* end do i = 1 to nb_items */\n         drop l. m. inversion a\n\n        /* --------------------------------------------------------- *\n         * Now call the do_XML or the do_txt Conversion Routine      *\n         * according to the value of the output parameter            *\n         * --------------------------------------------------------- */\n         if output = \"X\" then call do_XML\n         else call do_TXT\n\n        /* --------------------------------------------------------- *\n         * Now Report What We Did                                    *\n         * --------------------------------------------------------- */\n         if confirm >= 1 then do\n            call domsg    \" \"\n            if txtdd = null then\n               call domsg \"Txt File:          \" txt\n            else\n               call domsg \"Txt DD:            \" txtdd\n            if cobdd = null then\n               call domsg \"Cobol File:        \" cobol\n            else\n               call domsg \"Cobol DD:          \" cobdd\n            if xmldd = null then\n               call domsg \"XML File:          \" xml\n            else\n               call domsg \"XML DD:            \" xmldd\n            if output = \"X\" then ,\n               call domsg \"Output data format: XML\"\n            else ,\n               call domsg \"Output data format: TXT\"\n            call domsg    \"Prefix:            \" prefix\n            if dtddd = null then\n               call domsg \"DTD File:          \" dtd\n            else\n               call domsg \"DTD DD:            \" dtddd\n            call domsg    \" \"\n            call domsg    \"Text records:      \" nb_txt_rec ,\n                          \"processed in\" substr(time(\"E\"),1,6) \"seconds\"\n            call domsg    \" \"\n            header.1 = \"+-\"\n            header.1 = insert(\"-\",header.1,length(header.1),5,\"-\")\n            header.1 = insert(\"-+-\",header.1,length(header.1),3)\n            header.1 = insert(\"-\",header.1,length(header.1),30,\"-\")\n            header.1 = insert(\"-+-\",header.1,length(header.1),3)\n            header.1 = insert(\"-\",header.1,length(header.1),5,\"-\")\n            header.1 = insert(\"-+-\",header.1,length(header.1),3)\n            header.1 = insert(\"-\",header.1,length(header.1),4,\"-\")\n            header.1 = insert(\"-]-\",header.1,length(header.1),3)\n            header.1 = insert(\"-\",header.1,length(header.1),5,\"-\")\n            header.1 = insert(\"-+-\",header.1,length(header.1),3)\n            header.1 = insert(\"-\",header.1,length(header.1),6,\"-\")\n            header.1 = insert(\"-+-\",header.1,length(header.1),3)\n            header.1 = insert(\"-\",header.1,length(header.1),13,\"-\")\n            header.1 = insert(\"-+\",header.1,length(header.1),2)\n            header.2 = \"] \"\n            header.2 = insert(\"Level\",header.2,length(header.2),5)\n            header.2 = insert(\" ] \",header.2,length(header.2),3)\n            header.2 = insert(\"Name\",header.2,length(header.2),30)\n            header.2 = insert(\" ] \",header.2,length(header.2),3)\n            header.2 = insert(\"Type\",header.2,length(header.2),5)\n            header.2 = insert(\" ] \",header.2,length(header.2),3)\n            header.2 = insert(\"Sign\",header.2,length(header.2),4)\n            header.2 = insert(\" ] \",header.2,length(header.2),3)\n            header.2 = insert(\"Start\",header.2,length(header.2),5)\n            header.2 = insert(\" ] \",header.2,length(header.2),3)\n            header.2 = insert(\"Length\",header.2,length(header.2),6)\n            header.2 = insert(\" ] \",header.2,length(header.2),3)\n            header.2 = insert(\"Default value\",header.2,length(header.2),13)\n            header.2 = insert(\" ]\",header.2,length(header.2),2)\n            if nb_items > 0 then do\n               call domsg    copies(\"=\",80)\n               call domsg    \" \"\n               call domsg    center(\"COBOL copybook analysis\",80)\n               call domsg    \" \"\n               call domsg    header.1\n               call domsg    header.2\n               call domsg    header.1\n               do i = 1 to nb_items\n                  line = \"] \"\n                  line = insert(level.i,line,length(line),5)\n                  line = insert(\" ] \",line,length(line),3)\n                  if length(copies(\" \",level.i-1) || name.i) <= 30 then ,\n                     line = insert(copies(\" \",level.i-1) || ,\n                                   name.i,line,length(line),30)\n                  else line = insert(copies(\" \",level.i-1) || ,\n                       substr(name.i,1,22) || \"...\",line,length(line),30)\n                  line = insert(\" ] \",line,length(line),3)\n                  line = insert(type.i,line,length(line),5)\n                  line = insert(\" ] \",line,length(line),3)\n                  if sign_pos.i <> \"\" then ,\n                     line = insert(sign_pos.i,line,length(line),4)\n                  else line = insert(signed.i,line,length(line),4)\n                  line = insert(\" ] \",line,length(line),3)\n                  line = insert(start_pos.i,line,length(line),5)\n                  line = insert(\" ] \",line,length(line),3)\n                  line = insert(length.i,line,length(line),6)\n                  line = insert(\" ] \",line,length(line),3)\n                  select\n                     when type.i = \"BIN\" then ,\n                        line = insert(bin2txt(default.i,length.i,signed.i), ,\n                                      line,length(line),13)\n                     when type.i = \"PACK\" then ,\n                        line = insert(pack2txt(default.i), ,\n                                      line,length(line),13)\n                     when type.i = \"NUM\" then ,\n                        line = insert(num2txt(default.i,signed.i,sign_pos.i), ,\n                                      line,length(line),13)\n                     when type.i = \"CHAR\" & ,\n                        default.i = copies(\"00\"x,length.i) then ,\n                        line = insert(\"LOW-VALUES\",line,length(line),13)\n                     when type.i = \"CHAR\" & ,\n                        default.i = copies(\"FF\"x,length.i) then ,\n                        line = insert(\"HIGH-VALUES\",line,length(line),13)\n                     when type.i = \"CHAR\" & ,\n                        default.i = copies(\" \",length.i) then ,\n                        line = insert(\"SPACES\",line,length(line),13)\n                     otherwise line = insert(default.i,line,length(line),13)\n                  end /* end select */\n                  line = insert(\" ]\",line,length(line),2)\n                  call domsg line\n               end /* end do i = 1 to nb_items */\n               call domsg    header.1\n               call domsg    \" \"\n               call domsg    \"Total computed COBOL length :\" cobol_length\n               call domsg    \" \"\n            end /* end if nb_items > 0 */\n         end /* end if confirm >= 1 then do */\n\n        /* --------------------------------------------------------- *\n         * Done so report out and leave                              *\n         * --------------------------------------------------------- */\n         Done:\n         if browse = 1 & rexx_os = \"TSO\" then do\n            call msg 'off'\n            if sysvar(\"syspref\") = null then hlq  = sysvar(\"sysuid\")\".\"\n            else hlq = null\n            browse_dsn = hlq\"TXT2XML.report\"\n            \"Alloc f(\"dd\") ds(\"browse_dsn\") new spa(1,1) tr\",\n            \"recfm(v b) lrecl(255) blksize(0)\"\n            \"Execio * diskw\" dd \"(Finis stem rpt.\"\n            Address ISPExec \"Browse Dataset(\"browse_dsn\")\"\n            \"Free f(\"dd\")\"\n            \"Delete\" browse_dsn\n         end /* end if browse = 1 & rexx_os = \"TSO\" */\n\n        /* free txt file */\n         if rexx_os = \"TSO\" then do\n            if txtdd = null & output = \"X\" then \"Free f(\"textdd\")\"\n            if xmldd = null & output = \"T\" then \"Free f(\"xml2dd\")\"\n         end /* end if rexx_os = \"TSO\" */\n\n         if ret = 1 then return\n         exit exit_rc\n\n          Do_TXT:\n        /* --------------------------------------------------------- *\n         * Allocate the txt file                                     *\n         * Space of txt file = space of the XML file % 3             *\n         * Lrecl is set to the computed cobol length of the copybook *\n         * --------------------------------------------------------- */\n         if rexx_os = \"TSO\" then do\n            if txtdd = null then do\n               rc = listdsi(xml)\n               space = SYSPRIMARY%3+1\",\"SYSSECONDS%3+1\n               if pos(\"(\",txt) <= 0 then do\n                  if SYSUNITS <> \"BLOCK\" then ,\n                     \"Alloc f(\"textdd\") new ds(\"txt\") reuse\" SYSUNITS ,\n                     \"recfm(f b) lrecl(\"cobol_length\")\" ,\n                     \"spa(\"space\") blksize(\"cobol_length\") release\"\n                  else ,\n                     \"Alloc f(\"textdd\") new ds(\"txt\") reuse\" ,\n                     \"recfm(f b) lrecl(\"cobol_length\")\" ,\n                     \"block(\"cobol_length*10\")\",\n                     \"spa(\"space\") blksize(\"cobol_length\") release\"\n               end /* end if pos(\"(\",txt) <= 0 */\n               else do\n                  if \"MEMBER NOT FOUND\" = sysdsn(txt) then do\n                     \"Alloc f(\"textdd\") shr ds(\"txt\") reuse\"\n                  end /* end if \"MEMBER NOT FOUND\" = sysdsn(txt) */\n                  else do\n                     if SYSUNITS <> \"BLOCK\" then ,\n                        \"Alloc f(\"textdd\") new ds(\"txt\") reuse\" SYSUNITS ,\n                        \"recfm(f b) lrecl(\"cobol_length\") dir(27)\" ,\n                         \"spa(\"space\") blksize(\"cobol_length\") release\"\n                     else ,\n                        \"Alloc f(\"textdd\") new ds(\"txt\") reuse\" ,\n                        \"recfm(f b) lrecl(\"cobol_length\") dir(27)\" ,\n                        \"block(\"cobol_length*10\")\",\n                        \"spa(\"space\") blksize(\"cobol_length\") release\"\n                  end /* end else do */\n               end /* end else do */\n            end /* end if txtdd = null */\n         end /* end if rexx_os = \"TSO\" */\n\n        /* initialize array of boolean that shows if XML element or attribute\n           has already beeing match with COBOL items */\n         do i = 1 to nb_items\n            cobol_item_found.i = 0\n         end /* end do i = 1 to nb_items */\n         file_eof = 0\n         nb_txt_rec = 0       /* number of txt record read or writte */\n         root = \"\"            /* name of the XML root element */\n         first_child  = \"\"    /* name of the XML first child element */\n         element = \"\"         /* one XML element */\n         attribute = \"\"       /* one XML attribute */\n         attributes = \"\"      /* all XML attributes of an XML element */\n         content = \"\"         /* content of one XML element */\n         text_pos = 1         /* current position in text ouput record */\n         element_pos = 0      /* XML element position in COBOL copybook */\n         record.1 = \"\"        /* output record */\n         do a = 1 to nb_items\n            record.1 = record.1 || default.a\n         end /* end do a = 1 to nb_items */\n         call reset_XML_flags\n         do while file_eof = 0\n\n        /* read one record from XML file */\n            rc = 0\n            select\n               when rexx_os <> \"TSO\" then do\n                  if lines(xml) > 0 then xml.1 = linein(xml, ,1)\n                  else rc = 1\n               end /* end when rexx_os <> \"TSO\" */\n               when xmldd = null then \"Execio 1 diskr\" xml2dd \"(stem xml.\"\n               when xmldd <> null then \"Execio 1 diskr\" xmldd \"(stem xml.\"\n               otherwise\n            end /* end select */\n\n        /* if end of file then exit */\n            if rc > 0 then do\n               file_eof = 1\n               select\n                  when rexx_os <> \"TSO\" then ,\n                     rc = stream(xml, 'C', 'CLOSE')\n                  when xmldd = null then do\n                     \"Execio 0 diskr\" xml2dd \"(FINIS\"\n                     \"Free f(\"xml2dd\")\"\n                  end /* end when xmldd = null */\n                  when xmldd <> null then ,\n                     \"Execio 0 diskr\" xmldd \"(FINIS\"\n                  otherwise\n               end /* end select */\n               select\n                  when rexx_os <> \"TSO\" then ,\n                     rc = stream(txt, 'C', 'CLOSE')\n                  when txtdd = null then do\n                     \"Execio 0 diskw\" textdd \"(FINIS\"\n                     \"Free f(\"textdd\")\"\n                  end /* end when txtdd = null */\n                  when txtdd <> null then \"Execio 0 diskw\" txtdd \"(FINIS\"\n                  otherwise\n               end /* end select */\n            end /* end if rc > 0 */\n            else do\n\n        /* ------------------------------------------------------ *\n         * skip blank lines                                       *\n         * ------------------------------------------------------ */\n               xml.1 = strip(xml.1)\n               if length(xml.1) <= 0 then iterate\n\n        /* ------------------------------------------------------ *\n         * skip XML declaration and comments. Search for XML root *\n         * , XML first child and XML elements, attributes and     *\n         * content.                                               *\n         * ------------------------------------------------------ */\n               do i = 1 to length(xml.1)\n                  select\n\n        /* ------------------------------------------------------ *\n         * start of XML declaration <?                            *\n         * ------------------------------------------------------ */\n                     when XML_declaration <= 0 ,\n                          & substr(xml.1,i,2) = \"<?\" then do\n                          XML_declaration = 1\n                          i = i + 1\n                     end /* end when XML_declaration <= 0 , */\n\n        /* end of XML declaration ?> */\n                     when XML_declaration > 0 then do\n                          i = pos(\"?>\",xml.1,i)\n                          if i <= 0 then leave\n                          else do\n                             i = i + 1\n                             call reset_XML_flags\n                          end /* end else do */\n                     end /* end when XML_declaration > 0 */\n\n        /* ------------------------------------------------------ *\n         * start of XML entity <|ENTITY                           *\n         * ------------------------------------------------------ */\n                     when XML_entity <= 0 ,\n                          & substr(xml.1,i,8) = \"<|ENTITY\" then do\n                          call domsg \"==>Error :\" ,\n                               \"in the XML file, entity declaration\" ,\n                               \"is not supported.\"\n                          exit_rc = 12\n                          signal done\n                     end /* end when XML_entity <= 0 ,*/\n\n        /* end of XML entity */\n                     when XML_entity > 0 then do\n                          i = pos(\">\",xml.1,i)\n                          if i <= 0 then leave\n                          else do\n                             i = i + 1\n                             call reset_XML_flags\n                          end /* end else do */\n                     end /* end when XML_entity > 0 */\n\n        /* ------------------------------------------------------ *\n         * start of XML DOCTYPE <|DOCTYPE                         *\n         * ------------------------------------------------------ */\n                     when XML_DOCTYPE <= 0 & ,\n                          substr(xml.1,i,9) = \"<|DOCTYPE\" then do\n                          XML_DOCTYPE = 1\n                          if pos(\"\u00a2\",xml.1,i) > 0 then XML_DOCTYPE = 2\n                          i = i + 8\n                     end /* end when XML_DOCTYPE <= 0 & , */\n\n        /* end of XML DOCTYPE without DTD declaration > */\n                     when XML_DOCTYPE = 1 then do\n                          i = pos(\">\",xml.1,i)\n                          if i <= 0 then leave\n                          else call reset_XML_flags\n                     end /* end when XML_DOCTYPE = 1 */\n\n        /* end of XML DOCTYPE with inline DTD declaration > */\n                     when XML_DOCTYPE >= 2 then do\n                          i = pos(\"!>\",xml.1,i)\n                          if i <= 0 then leave\n                          else do\n                             i = i + 1\n                             call reset_XML_flags\n                          end /* end else do */\n                     end /* end when XML_DOCTYPE >= 2 */\n\n        /* ------------------------------------------------------ *\n         * start of XML comment <|--                              *\n         * ------------------------------------------------------ */\n                     when XML_comment <= 0 & substr(xml.1,i,4) = \"<|--\" ,\n                          then do\n                          XML_comment = 1\n                          i = i + 3\n                     end /* end when XML_comment <= 0 & substr(xml.1,i,4) */\n\n        /* end of XML comment --> */\n                     when XML_comment > 0 then do\n                          i = pos(\"-->\",xml.1,i)\n                          if i <= 0 then leave\n                          else do\n                             i = i + 2\n                             call reset_XML_flags\n                          end /* end else do */\n                     end /* end when XML_comment > 0 */\n\n        /* ------------------------------------------------------ *\n         * start of XML root element                              *\n         * ------------------------------------------------------ */\n                     when root = \"\" & XML_root <= 0 ,\n                          & substr(xml.1,i,1) = \"<\" then do\n                          XML_root = 1\n                      end /* end when root = \"\" & XML_root <= 0 , */\n\n        /* end of XML root element */\n                     when XML_root > 0 then do\n\n        /* XML root element end on this line ? */\n                          if pos(\">\",xml.1,i) > 0 then do\n                             k = pos(\">\",xml.1,i)\n                             l = k - i\n                             root = strip(root substr(xml.1,i,l))\n                             if words(root) >  1 then do\n                                call domsg ,\n                                \"==>Warning : \" ,\n                                \"XML attributes of root element\" ,\n                                word(root,1) \"are ignored.\"\n                                exit_rc = 04\n                             end /* end if words(root) >  1 */\n                             root = strip(word(root,1))\n                             i = pos(\">\",xml.1,i)\n                             call reset_XML_flags\n                          end /* end if pos(\">\",xml.1,i) > 0 */\n\n        /* else concatenate XML root element */\n                          else do\n                             root = root substr(xml.1,i)\n                             leave\n                          end /* end else do */\n                     end /* end when XML_root > 0 */\n\n        /* ------------------------------------------------------ *\n         * start of XML first_child element                       *\n         * ------------------------------------------------------ */\n                     when first_child = \"\" & XML_first_child <= 0 ,\n                          & substr(xml.1,i,1) = \"<\" & root <> \"\" then do\n                          XML_first_child = 1\n                          attributes = \"\"\n                          element_pos = 0\n                      end /* end when first_child = \"\" & XML_first_child */\n\n        /* end of XML first_child element */\n                     when XML_first_child > 0 then do\n\n        /* XML first_child element end on this line ? */\n                          if pos(\">\",xml.1,i) > 0 then do\n                             k = pos(\">\",xml.1,i)\n                             l = k - i\n                             first_child = strip(first_child substr(xml.1,i,l))\n                             parse var first_child first_child attributes\n                             element = first_child\n                             call find_XML_equivalent\n                             element_pos = x\n                             call do_XML_attribute\n                             i = pos(\">\",xml.1,i)\n                             call reset_XML_flags\n                             XML_content = 1\n                          end /* end if pos(\">\",xml.1,i) > 0 */\n\n        /* else concatenate XML first_child element */\n                          else do\n                             first_child = first_child substr(xml.1,i)\n                             leave\n                          end /* end else do */\n                     end /* end when XML_first_child > 0 */\n\n        /* ------------------------------------------------------ *\n         * start of XML element                                   *\n         * ------------------------------------------------------ */\n                     when XML_element <= 0 & substr(xml.1,i,1) = \"<\" & ,\n                          substr(xml.1,i,2) <> \"</\" ,\n                          & substr(xml.1,i,9) <> \"<|\u00a2CDATA\u00a2\" then do\n                          call reset_XML_flags\n                          XML_element = 1\n                          element = \"\"\n                          attributes = \"\"\n                          element_pos = 0\n                     end /* end when XML_element <= 0 & substr(xml.1,i,1) */\n\n        /* end of XML element */\n                     when XML_element > 0 then do\n\n        /* XML element end on this line ? */\n                          if pos(\">\",xml.1,i) > 0 then do\n                             k = pos(\">\",xml.1,i)\n                             l = k - i\n                             element = strip(element substr(xml.1,i,l))\n                             parse var element element attributes\n\n        /* if first child XML element then create and initialize,\n           according to the COBOL copybook, the TXT record */\n                             if element = first_child then do\n                                drop record.\n                                record.1 = \"\"\n                                do a = 1 to nb_items\n                                   record.1 = record.1 || default.a\n                                end /* end do a = 1 to nb_items */\n                             end /* end if element = first_child */\n                             drop temp\n                             call find_XML_equivalent\n                             element_pos = x\n                             call do_XML_attribute\n\n        /* XML empty element ? */\n                             if substr(xml.1,k-1,2) = \"/>\" then do\n                                i = k\n                                call reset_XML_flags\n                                iterate\n                             end /* end if substr(xml.1,k-1,2) = \"/>\" */\n\n                             i = pos(\">\",xml.1,i)\n                             call reset_XML_flags\n                             XML_content = 1\n                             content = \"\"\n                          end /* end if pos(\">\",xml.1,i) > 0 */\n\n        /* else concatenate XML element */\n                          else do\n                             element = element substr(xml.1,i)\n                             leave\n                          end /* end else do */\n                     end /* end when XML_element > 0 */\n\n        /* ------------------------------------------------------ *\n         * find the content of a XML element                      *\n         * ------------------------------------------------------ */\n                     when XML_content > 0 then do\n                          k = pos(\"</\",xml.1,i)\n\n        /* no closing tag on line ? continue on next line */\n                          if k <= 0 then do\n                             content = content substr(xml.1,i)\n                             leave\n                          end /* end if k <= 0 */\n                          else do\n                             l = k - i\n                             content = strip(content substr(xml.1,i,l))\n                          end /* end else do */\n                          call check_XML_content\n                          i = pos(\"</\",xml.1,i) - 1\n                          drop content element\n                          call reset_XML_flags\n                     end /* end when XML_content > 0 */\n\n        /* ------------------------------------------------------ *\n         * Start of child closing tag </                          *\n         * ------------------------------------------------------ */\n                     when XML_end_child <= 0 & ,\n                          substr(xml.1,i,2) = \"</\" then do\n                          XML_end_child = 1\n                          element = \"\"\n                          i = i + 1\n                     end /* end when XML_end_child <= 0 & , */\n\n        /* end of XML child closing tag > */\n                     when XML_end_child > 0 then do\n                          if pos(\">\",xml.1,i) > 0 then do\n                             k = pos(\">\",xml.1,i)\n                             l = k - i\n                             element = element substr(xml.1,i,l)\n                             element = strip(word(element,1))\n\n        /* Write record if we have reached the first child closing tag */\n                             if element = first_child then do\n                                rc = 0\n                                select\n                                   when rexx_os <> \"TSO\" then do\n                                      if nb_txt_rec <= 0 then ,\n                                         rc = lineout(txt,record.1,1)\n                                      else rc = lineout(txt,record.1)\n                                      if rc <> 0 then do\n                                         call domsg \"==>Error :\" ,\n                                                    \"Unable to write to file\",\n                                          txt \"RC :\" rc\n                                         exit_rc = 12\n                                         signal done\n                                      end /* end if rc <> 0 */\n                                   end /* end when rexx_os <> \"TSO\" */\n                                   when txtdd = null then ,\n                                      \"Execio 1 diskw\" textdd \"(stem record.\"\n                                   when txtdd <> null then ,\n                                      \"Execio 1 diskw\" txtdd \"(stem record.\"\n                                   otherwise\n                                end /* end select */\n                                drop record.\n                                text_pos = 1\n                                nb_txt_rec = nb_txt_rec + 1\n                                if nb_txt_rec // 1000 = 0 then ,\n                                   call domsg nb_txt_rec ,\n                                   \"text records processed in\" ,\n                                 substr(time(\"E\"),1,6) \"seconds.\"\n\n        /* check that we have filled all COBOL items except group items */\n                                do x = 1 to nb_items\n                                   if cobol_item_found.x <= 0 & ,\n                                      name.x <> \"FILLER\" & ,\n                                      length.x > 0 then do\n                                      call domsg ,\n                                         \"==>Warning : in text record number\" ,\n                                         nb_txt_rec \", COBOL item\" ,\n                                         name.x ,\n                                         \"starting at\" start_pos.x\n                                      call domsg ,\n                                         \"is filled with default values\" ,\n                                         \"because the corresponding XML\" ,\n                                         \"equivalent was not found\"\n                                      exit_rc = 4\n                                   end /* end if cobol_item_found.x <= 0 & */\n                                   cobol_item_found.x = 0\n                                end /* end do x = 1 to nb_items */\n                             end /* end if element = first_child */\n                             i = pos(\">\",xml.1,i)\n                             call reset_XML_flags\n                          end /* end if pos(\">\",xml.1,i) > 0 */\n\n        /* else concatenate XML child closing tag */\n                          else do\n                             element = element substr(xml.1,i)\n                             leave\n                          end /* end else do */\n                     end /* end when XML_end_child > 0 */\n\n        /* ------------------------------------------------------ *\n         * In case of ...                                         *\n         * ------------------------------------------------------ */\n                     otherwise do\n                          call domsg \"==>Error :\" ,\n                               \"unable to convert the following chars :\" ,\n                               substr(xml.1,i,20)\n                          exit_rc = 12\n                          signal done\n                     end /* end otherwise do */\n                  end /* end select */\n               end /* end do i = 1 to length(xml.1) */\n            end /* end else do */\n         end /* end do while file_eof = 0 */\n\n        /* free txt file */\n         if rexx_os = \"TSO\" then do\n            if txtdd = null then \"Free f(\"textdd\")\"\n         end /* end if rexx_os = \"TSO\" */\n\n         return\n\n         Do_XML:\n        /* ------------------------------------------------------- *\n         * Allocate the XML                                        *\n         * Space of XML file = 5 times space of the txt file       *\n         * because XML can generate very big files                 *\n         * Lrecl is set to 4096 because, XML record length should  *\n         * never reach such a length.                              *\n         * ------------------------------------------------------- */\n         if xmldd = null & rexx_os = \"TSO\" then do\n            rc = listdsi(txt)\n            space = SYSPRIMARY*5\",\"SYSSECONDS*5\n            if pos(\"(\",xml) <= 0 then do\n               if SYSUNITS <> \"BLOCK\" then ,\n                  \"Alloc f(\"xml2dd\") new ds(\"xml\") reuse \" SYSUNITS ,\n                  \"recfm(v b) lrecl(4096)\" ,\n                  \"blksize(0) spa(\"space\") release\"\n               else ,\n                  \"Alloc f(\"xml2dd\") new ds(\"xml\") reuse \" ,\n                  \"recfm(v b) lrecl(4096)\" ,\n                  \"block(4096)\",\n                  \"blksize(0) spa(\"space\") release\"\n            end /* end if pos(\"(\",xml) <= 0 */\n            else do\n               if \"MEMBER NOT FOUND\" = sysdsn(xml) then do\n                  \"Alloc f(\"xml2dd\") shr ds(\"xml\") reuse\"\n               end /* end if \"MEMBER NOT FOUND\" = sysdsn(xml) */\n               else do\n                  if SYSUNITS <> \"BLOCK\" then ,\n                     \"Alloc f(\"xml2dd\") new ds(\"xml\") reuse \" SYSUNITS ,\n                     \"recfm(v b) lrecl(4096)\" ,\n                     \"dir(27)\" ,\n                     \"blksize(0) spa(\"space\") release\"\n                  else ,\n                     \"Alloc f(\"xml2dd\") new ds(\"xml\") reuse \" ,\n                     \"recfm(v b) lrecl(4096)\" ,\n                     \"dir(27)\" ,\n                     \"blksize(0) spa(\"space\") release\"\n               end /* end else do */\n            end /* end else do */\n         end /* end if xmldd = null & rexx_os = \"TSO\" */\n\n        /* ------------------------------------------------------- *\n         * Allocate the DTD file if necessary                      *\n         * ------------------------------------------------------- */\n         if dtd <> \"INTERNAL\" & dtd <> \"\" & ,\n            dtddd = null & rexx_os = \"TSO\" then do\n            if pos(\"(\",dtd) <= 0 then do\n               \"Alloc f(\"dtd2dd\") new ds(\"dtd\") reuse tracks\" ,\n               \"recfm(f b) lrecl(80)\" ,\n               \"blksize(0) spa(10,10) release\"\n            end /* end if pos(\"(\",dtd) <= 0 */\n            else do\n               if \"MEMBER NOT FOUND\" = sysdsn(dtd) then do\n                  \"Alloc f(\"dtd2dd\") shr ds(\"dtd\") reuse\"\n               end /* end if \"MEMBER NOT FOUND\" = sysdsn(dtd) */\n               else do\n                  \"Alloc f(\"dtd2dd\") new ds(\"dtd\") reuse tracks\",\n                  \"recfm(f b) lrecl(80)\" ,\n                  \"dir(27)\" ,\n                  \"blksize(0) spa(10,10) release\"\n               end /* end else do */\n            end /* end else do */\n         end /* end if dtd <> \"INTERNAL\" & dtd <> \" \" , */\n\n        /* Create XML declaration */\n         i = 1\n         root = \"DATA\"\n         if dtd = \"INTERNAL\" then record.i = ,\n         '<?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"yes\" ?>'\n         else record.i = ,\n         '<?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"no\" ?>'\n         i = i + 1\n         record.i = \"<|-- \"\n         i = i + 1\n         record.i = \"\"\n         i = i + 1\n         record.i = center(\"Created by TXT2XML on\" date(\"N\") \"at\" ,\n                    time(\"N\"), 70)\n         i = i + 1\n         record.i = \"\"\n         i = i + 1\n         record.i = center(\"More info on :\" ,\n                    \"http://sourceforge.net/projects/txt2xml-rexx/\", 70)\n         i = i + 1\n         record.i = \"\"\n         i = i + 1\n         record.i = \"-->\"\n         i = i + 1\n         record.i = \"\"\n\n        /* ------------------------------------------------------- *\n         * create DTD                                              *\n         * ------------------------------------------------------- */\n         if dtd <> \"\" then do\n\n        /* internal or external DTD header with DOCTYPE tag */\n            i = i + 1\n            if dtd = \"INTERNAL\" then record.i = \"<|DOCTYPE\" root \"\u00a2\"\n            else record.i = \"<|DOCTYPE\" root 'SYSTEM \"'|| dtd || '\">'\n            i = i + 1\n            l = 1\n            do j = 1 to nb_items\n                if name.j = \"FILLER\" then iterate\n\n        /* create root element DTD */\n               if j < = 1 then do\n                  dtd.l = '<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>'\n                  l = l + 1\n                  element = name.1\n                  if length(prefix) > 0 then do\n                     if left(element,length(prefix)) = prefix then ,\n                        element = substr(element,length(prefix)+1)\n                  end /* end if length(prefix) > 0 */\n                  dtd.l = \"   <|ELEMENT\" root \"(\" || element || \", \"\n\n        /* find sub-elemenents of the element */\n                  do k = 2 to nb_items\n                     if name.k = \"FILLER\" then iterate\n                     element = name.k\n                     if length(prefix) > 0 then do\n                        if left(element,length(prefix)) = prefix then ,\n                           element = substr(element,length(prefix)+1)\n                     end /* end if length(prefix) > 0 */\n                     if level.k = level.1 then do\n                        if length(dtd.l) + length(element) > 75 then do\n                           dtd.l = translate(dtd.l)\n                           dtd.l = translate(dtd.l,\"_\",\"-\")\n                           if dtd = \"INTERNAL\" then do\n                              record.i = dtd.l\n                              i = i + 1\n                           end /* end if dtd = \"INTERNAL\" */\n                           l = l + 1\n                           dtd.l = copies(\" \",3)\n                        end /* end if length(dtd.l) + length(element) > 75 */\n\n        /* Skip multiple occurences of a sub-element */\n                        if occurs.k > 1 then do\n                           dtd.l = dtd.l || element || \"+, \"\n                           n = occurs.k\n                           do m = k + 1 to nb_items\n                              if level.m = level.k & ,\n                                 name.m = name.k then n = n - 1\n                              if n <= 1 then do\n                                 k = m\n                                 leave\n                              end /* end if n <= 1 */\n                           end /* end do m = k + 1 to nb_items */\n                        end /* end if occurs.k > 1 */\n                        else dtd.l = dtd.l || element || \", \"\n                     end /* end if level.k = level.1 */\n                  end /* end do k = 2 to nb_items */\n\n        /* Close tag */\n                  dtd.l = left(dtd.l,length(dtd.l)-2) || \")>\"\n                  dtd.l = translate(dtd.l)\n                  dtd.l = translate(dtd.l,\"_\",\"-\")\n                  if dtd = \"INTERNAL\" then do\n                     record.i = dtd.l\n                     i = i + 1\n                  end /* end if dtd = \"INTERNAL\" */\n               end /* end if j < = 1 */\n\n        /* create complex element DTD */\n               if type.j = \"GROUP\" then do\n                  l = l + 1\n                  element = name.j\n                  if length(prefix) > 0 then do\n                     if left(element,length(prefix)) = prefix then ,\n                        element = substr(element,length(prefix)+1)\n                  end /* end if length(prefix) > 0 */\n                  dtd.l = \"   <|ELEMENT\" element \"(\"\n                  m = j + 1\n\n        /* find sub-elemenents of the element */\n                  do k = m to nb_items\n                     if name.k = \"FILLER\" then iterate\n                     if level.k = level.m then do\n                        element = name.k\n                        if length(prefix) > 0 then do\n                           if left(element,length(prefix)) = prefix then ,\n                              element = substr(element,length(prefix)+1)\n                        end /* end if length(prefix) > 0 */\n                        if length(dtd.l) + length(element) > 75 then do\n                           dtd.l = translate(dtd.l)\n                           dtd.l = translate(dtd.l,\"_\",\"-\")\n                           if dtd = \"INTERNAL\" then do\n                              record.i = dtd.l\n                              i = i + 1\n                           end /* end if dtd = \"INTERNAL\" */\n                           l = l + 1\n                           dtd.l = copies(\" \",6)\n                        end /* end if length(dtd.l) + length(element) > 75 */\n\n        /* Skip multiple occurences of a sub-element */\n                        if occurs.k > 1 then do\n                           dtd.l = dtd.l || element || \"+, \"\n                           o = occurs.k\n                           do n = k + 1 to nb_items\n                              if level.n = level.k & ,\n                                 name.n = name.k then o = o - 1\n                              if o <= 1 then do\n                                 k = n\n                                 leave\n                              end /* end if o <= 1 */\n                           end /* end do n = k + 1 to nb_items */\n                        end /* end if occurs.k > 1 */\n                        else dtd.l = dtd.l || element || \", \"\n                     end /* end if level.k = level.m */\n                     else if level.k < level.m then leave\n                  end /* end do k = m to nb_items */\n\n        /* Close tag */\n                  dtd.l = left(dtd.l,length(dtd.l)-2) || \")>\"\n                  dtd.l = translate(dtd.l)\n                  dtd.l = translate(dtd.l,\"_\",\"-\")\n                  if dtd = \"INTERNAL\" then do\n                     record.i = dtd.l\n/*                      i = i + 1 */\n                  end /* end if dtd = \"INTERNAL\" */\n\n        /* Skip multiple occurences of the element */\n                  if occurs.j > 1 then do\n                     m = occurs.j\n                     do k = j + 1 to nb_items\n                        if level.k = level.j & ,\n                           name.k = name.j then m = m - 1\n                        if m <= 1 then do\n                           j = k\n                           leave\n                        end /* end if m <= 1 */\n                     end /* end do k = j + 1 to nb_items */\n                  end /* end if occurs.j > 1 */\n               end /* end if type.j = \"GROUP\" */\n\n        /* create elementary element DTD */\n               else do\n                  l = l + 1\n                  element = name.j\n                  if length(prefix) > 0 then do\n                     if left(element,length(prefix)) = prefix then ,\n                        element = substr(element,length(prefix)+1)\n                  end /* end if length(prefix) > 0 */\n                  dtd.l = \"   <|ELEMENT\" element \"(#PCDATA)>\"\n\n        /* Skip multiple occurences of an element */\n                  if occurs.j > 1 then do\n                     n = occurs.j\n                     do m = j + 1 to nb_items\n                        if level.m = level.j & ,\n                           name.m = name.j then n = n - 1\n                        if n <= 1 then do\n                           j = m\n                           leave\n                        end /* end if n <= 1 */\n                     end /* end do m = j + 1 to nb_items */\n                  end /* end if occurs.j > 1 */\n               end /* end else do  */\n               dtd.l = translate(dtd.l)\n               dtd.l = translate(dtd.l,\"_\",\"-\")\n               if dtd = \"INTERNAL\" then do\n                  record.i = dtd.l\n                  i = i + 1\n               end /* end if dtd = \"INTERNAL\" */\n            end /* end do j = 1 to nb_items */\n\n        /* Close tag */\n            if dtd  = \"INTERNAL\" then do\n               record.i = \"!>\"\n               i = i + 1\n            end  /* end if dtd = \"INTERNAL\" */\n\n        /* write DTD records */\n            else do\n               select\n                  when rexx_os <> \"TSO\" then do j = 1 to l\n                     do j = 1 to l\n                        if j <= 1 then rc = lineout(dtd,dtd.j,1)\n                        else rc = lineout(dtd,dtd.j)\n                        if rc <> 0 then do\n                           call domsg \"==>Error :\" ,\n                                      \"Unable to write to file\",\n                                      dtd \"RC :\" rc\n                           exit_rc = 12\n                           signal done\n                        end /* end if rc <> 0 */\n                     end /* end do j = 1 to l */\n                  end /* end when rexx_os <> \"TSO\" */\n                  when dtddd = null then ,\n                    \"Execio \" l \" diskw\" dtd2dd \"(stem dtd.\"\n                  when dtddd <> null then ,\n                    \"Execio \" l \" diskw\" dtddd \"(stem dtd.\"\n                  otherwise\n               end /* end select */\n               drop dtd.\n            end /* end else do */\n         end /* end if dtd <> \"\" */\n         drop dtd. j k l m n o\n\n         record.i = \"\"\n         i = i + 1\n         record.i = \"<\" || root || \">\"\n         file_eof = 0\n         nb_txt_rec = 0 /* number of text records read or written */\n         do while file_eof <= 0\n\n        /* read one record from txt file */\n            rc = 0\n            select\n               when rexx_os <> \"TSO\" then do\n                  if lines(txt) > 0 then txt.1 = linein(txt, ,1)\n                  else rc = 1\n               end /* end when rexx_os <> \"TSO\"  */\n               when txtdd = null then \"Execio 1 diskr\" textdd \"(stem txt.\"\n               when txtdd <> null then \"Execio 1 diskr\" txtdd \"(stem txt.\"\n               otherwise\n            end /* end select */\n\n        /* if end of file then exit */\n            if rc > 0 then file_eof = 1\n            else do\n               nb_txt_rec = nb_txt_rec + 1\n               if nb_txt_rec // 1000 = 0 then do\n                  call domsg nb_txt_rec \"records processed in\",\n                             substr(time(\"E\"),1,6) \"seconds.\"\n               end /* end if nb_txt_rec // 1000 = 0 */\n\n         /* ----------------------------------------------------- *\n         * If computed length not equal in file length, exit      *\n         * ------------------------------------------------------ */\n               if nb_txt_rec <= 1 & cobol_length <> length(txt.1) then do\n                  call domsg \"==>Error :\" ,\n                             \"the total length of the COBOL items (\" || ,\n                             cobol_length || \")\"\n                  call domsg \"doesn't match the txt file length (\" || ,\n                             length(txt.1) || \").\"\n                  exit_rc = 12\n                  signal done\n               end /* end if nb_txt_rec <= 1 & cobol_length <> length(txt.1) */\n\n        /* write XML declaration in XML file */\n               if nb_txt_rec <= 1 then do\n                  rc = 0\n                  select\n                     when rexx_os <> \"TSO\" then do j = 1 to i\n                        if j <= 1 then rc = lineout(xml,record.j,1)\n                        else rc = lineout(xml,record.j)\n                        if rc <> 0 then do\n                           call domsg \"==>Error :\" ,\n                                      \"Unable to write to file\",\n                                      xml \"RC :\" rc\n                           exit_rc = 12\n                           signal done\n                        end /* end if rc <> 0 */\n                     end /* end when rexx_os <> \"TSO\" */\n                     when xmldd = null then ,\n                        \"Execio \" i \" diskw\" xml2dd \"(stem record.\"\n                     when xmldd <> null then ,\n                       \"Execio \" i \" diskw\" xmldd \"(stem record.\"\n                     otherwise\n                  end /* end select */\n                  drop record.\n               end /* end if nb_txt_rec <= 1 */\n\n        /* ----------------------------------------------------- *\n         * generate XML elements                                 *\n         * ----------------------------------------------------- */\n               do j = 1 to nb_items\n\n        /* Skip fillers */\n                  if name.j <> \"FILLER\" then do\n                     element = name.j\n                     if length(prefix) > 0 then do\n                        if left(element,length(prefix)) = prefix then ,\n                           element = substr(element,length(prefix)+1)\n                     end /* end if length(prefix) > 0 */\n\n        /* indent XML according to the level */\n                     record.1 = copies(\" \",level.j * 2) || ,\n                                \"<\" || translate(element,\"_\",\"-\") ||\">\"\n\n        /* if item is not a COBOL group item then show content and close\n           element */\n                     if length.j > 0 then do\n                        content = substr(txt.1,start_pos.j,length.j)\n                        select\n                           when type.j = \"BIN\" then content = ,\n                              bin2txt(content,length.j,signed.j)\n                           when type.j = \"PACK\" then content = ,\n                              pack2txt(content)\n                           when type.j = \"NUM\" then content = ,\n                              num2txt(content,signed.j,sign_pos.j)\n                           otherwise nop\n                        end /* end select */\n\n        /* Escape special characters in content */\n                        if type.j = \"CHAR\" then do\n                           k = 0\n                           do forever\n                              k = k + 1\n                              if k > length(content) then leave\n                              temp = substr(content,k,1)\n                              select\n                                 when temp = \"&\" then symbole = \"&amp;\"\n                                 when temp = \"<\" then symbole = \"&lt;\"\n                                 when temp = \">\" then symbole = \"&gt;\"\n                                 when temp = '\"' then symbole = \"&quot;\"\n                                 when temp = \"'\" then symbole = \"&apos;\"\n                                 when c2d(temp) < c2d(first_char) then ,\n                                    symbole = \"&#\" || c2d(temp) || \";\"\n                                 when temp = \"FF\"x then symbole = \"&#255;\"\n                                 otherwise iterate\n                              end /* end select */\n                              if k > 1 then temp1 = substr(content,1,k-1)\n                              else temp1 = \"\"\n                              temp2 = substr(content,k+1)\n                              content = temp1 || symbole || temp2\n                              drop temp1 temp2 temp symbole\n                           end /* end do forever */\n\n        /* preserve space in content */\n                           if content = copies(\" \",length(content)) then ,\n                              content = \"<|\u00a2CDATA\u00a2\" || content ||\"!!>\"\n                        end /* end if type.j = \"CHAR\" */\n                        record.1 = record.1 || content\n                        record.1 = record.1 || \"</\" || ,\n                                   translate(element,\"_\",\"-\") ||\">\"\n                     end /* end if length.j > 0 */\n\n        /* write one record in XML file */\n                     rc = 0\n                     select\n                        when rexx_os <> \"TSO\" then do\n                           rc = lineout(xml,record.1)\n                           if rc <> 0 then do\n                              call domsg \"==>Error :\" ,\n                                         \"Unable to write to file\",\n                                         xml \"RC :\" rc\n                              exit_rc = 12\n                              signal done\n                           end /* end if rc <> 0 */\n                        end /* end when rexx_os <> \"TSO\" */\n                        when xmldd = null then ,\n                           \"Execio 1 diskw\" xml2dd \"(stem record.\"\n                        when xmldd <> null then ,\n                           \"Execio 1 diskw\" xmldd \"(stem record.\"\n                        otherwise\n                     end /* end select */\n                     drop record.\n                  end /* end if name.j <> \"FILLER\" */\n\n        /* To close elements at end of record, add dummy level 0 */\n                  l = j + 1\n                  if l > nb_items then level.l = 0\n\n        /* if item is a COBOL group item then close previous opened\n               elements */\n                  if level.j > level.l then do\n                     close_level = level.j\n\n        /* explore previous level to add close element if needed */\n                     do k = j - 1 to 1 by -1\n                        if length.k <= 0 then do\n\n        /* if this level was already close, skip it */\n                           if level.k >= close_level then iterate\n\n        /* write one record in XML file */\n                           element = name.k\n                           if length(prefix) > 0 then do\n                              if left(element,length(prefix)) = prefix then ,\n                                 element = substr(element,length(prefix)+1)\n                           end /* end if length(prefix) >  */\n                           record.1 = copies(\" \",level.k * 2) || ,\n                                      \"</\" || translate(element,\"_\",\"-\") ||\">\"\n                           rc = 0\n                           select\n                              when rexx_os <> \"TSO\" then do\n                                 rc = lineout(xml,record.1)\n                                 if rc <> 0 then do\n                                    call domsg \"==>Error :\" ,\n                                               \"Unable to write to file\",\n                                               xml \"RC :\" rc\n                                    exit_rc = 12\n                                    signal done\n                                 end /* end if rc <> 0 */\n                              end /* end when rexx_os <> \"TSO\" */\n                              when xmldd = null then ,\n                                 \"Execio 1 diskw\" xml2dd \"(stem record.\"\n                              when xmldd <> null then ,\n                                 \"Execio 1 diskw\" xmldd \"(stem record.\"\n                              otherwise\n                           end /* end select */\n                           drop record.\n\n        /* leave the loop only if the previous level was closed or\n               if final level (level = 0 ) */\n                           if level.k <= level.l & level.l <> 0 then leave\n\n        /* else save current close level */\n                           close_level = level.k\n                        end /* end if length.k <= 0 */\n                     end /* end do k = j - 1 to 1 by -1 */\n                  end /* end if level.j > level.l then do */\n               end /* end do j = 1 to nb_items */\n            end /* end else do */\n         end /* end do while file_eof = 0 */\n\n        /* write one record in XML file and close it */\n         record.1 = \"</\" || root || \">\"\n         rc = 0\n         select\n            when rexx_os <> \"TSO\" then do\n               rc = lineout(xml,record.1)\n               if rc <> 0 then do\n                  call domsg \"==>Error :\" ,\n                             \"Unable to write to file\",\n                             xml \"RC :\" rc\n                  exit_rc = 12\n                  signal done\n               end /* end if rc <> 0 */\n               rc = stream(xml, 'C', 'CLOSE')\n            end /* end when rexx_os <> \"TSO\" */\n            when xmldd = null then do\n               \"Execio 1 diskw\" xml2dd \"(FINIS stem record.\"\n               \"Free f(\"xml2dd\")\"\n            end /* end when xmldd = null */\n            when xmldd <> null then ,\n               \"Execio 1 diskw\" xmldd \"(FINIS stem record.\"\n            otherwise\n         end /* end select */\n         if dtd <> \"\" & dtd <> \"INTERNAL\" then do\n            select\n               when rexx_os <> \"TSO\" then do\n                  rc = stream(dtd, 'C', 'CLOSE')\n               end /* end when rexx_os <> \"TSO\" */\n               when dtddd = null then do\n                  \"Execio 0 diskw\" dtd2dd \"(FINIS stem record.\"\n                  \"Free f(\"dtd2dd\")\"\n               end /* end when dtddd = null */\n               when dtddd <> null then ,\n                  \"Execio 0 diskw\" dtddd \"(FINIS stem record.\"\n               otherwise\n            end /* end select */\n         end /* end if dtd <> \"\" & dtd \"INTERNAL\" */\n         select\n            when rexx_os <> \"TSO\" then rc = stream(txt, 'C', 'CLOSE')\n            when txtdd = null then do\n               \"Execio 0 diskr\" textdd \"(FINIS\"\n               \"Free f(\"textdd\")\"\n            end /* end when rexx_os <> \"TSO\" */\n            when txtdd <> null then \"Execio 0 diskr\" txtdd \"(FINIS\"\n            otherwise\n         end /* end select */\n         drop record.\n\n         return\n\n         DoMsg:\n        /* --------------------------------------------------------- *\n         * Issue Messages                                            *\n         * --------------------------------------------------------- */\n           parse arg msg\n           if confirm <= 0 then return\n           if browse <= 0 then say msgid msg\n           else do\n              r = r + 1\n              rpt.r = msg\n           end /* end else do */\n           return\n\n           find_XML_equivalent:\n        /* --------------------------------------------------------- *\n         * XML element or XML attribute in COBOL copybook ?          *\n         * --------------------------------------------------------- */\n           equivalent = \"\"\n           if XML_attribute > 0 then equivalent = attribute\n           else if XML_element > 0 | ,\n                   XML_content > 0 | ,\n                   XML_first_child > 0 then equivalent = element\n           else return\n           found = 0\n           equivalent = translate(equivalent)\n           equivalent = translate(equivalent,\"-\",\"_\")\n           if length(prefix) > 0 then do\n              if left(equivalent,length(prefix)) = prefix then ,\n                 equivalent = substr(equivalent,length(prefix)+1)\n           end /* end if length(prefix) > 0*/\n           do x = 1 to nb_items\n              if cobol_item_found.x > 0 then iterate\n\n        /* Skip fillers and find next COBOL Item */\n              if name.x = \"FILLER\" then do\n                 text_pos = start_pos.x + length.x\n                 cobol_item_found.x = 1\n                 iterate\n              end /* end if name.x = \"FILLER\" */\n              if name.x = equivalent | ,\n                 name.x = prefix || equivalent then do\n                 if start_pos.x >= text_pos then do\n                    found = 1\n                    cobol_item_found.x = 1\n                    text_pos = start_pos.x + length.x\n                    leave\n                 end /* end if start_pos.x >= text_pos */\n              end /* end if name.x = equivalent then do */\n           end /* end do x = 1 to nb_items */\n\n        /* if XML attribute is not found in COBOL copybook, then warning */\n           if found <= 0 then do\n              x = 0\n              if XML_attribute > 0 then do\n                 call domsg \"==>Warning :\" ,\n                            \"XML attribute\" equivalent ,\n                            \"not found in COBOL copybook\"\n                 call domsg \"or occurs too many times\" ,\n                      \"according to the COBOL copybook\"\n                 exit_rc = 4\n              end /* end if XML_attribute > 0 */\n\n        /* if XML element is not found in COBOL copybook, then exit */\n              else do\n                 call domsg \"==>Error :\" ,\n                            \"XML element\" equivalent ,\n                            \"not found in COBOL copybook\"\n                 call domsg \"or occurs too many times\" ,\n                            \"according to the COBOL copybook\"\n                 exit_rc = 12\n                 signal done\n              end /* end else do */\n           end /* end if found <= 0 */\n\n           drop equivalent found\n           return\n\n         reset_XML_flags:\n        /* --------------------------------------------------------- *\n         * Reset XML flags                                           *\n         * --------------------------------------------------------- */\n\n           XML_declaration = 0\n           XML_DOCTYPE = 0\n           XML_comment = 0\n           XML_root = 0\n           XML_first_child = 0\n           XML_element = 0\n           XML_attribute = 0\n           XML_end_child = 0\n           XML_content = 0\n           XML_entity = 0\n\n           return\n\n         do_XML_attribute:\n        /* --------------------------------------------------------- *\n         * Converting attribute value to text                        *\n         * --------------------------------------------------------- */\n           if length(attributes) > 0 then do\n              XML_attribute = 1\n              start_pos = 0\n              end_pos = 0\n              temp1 = strip(attributes)\n              if right(temp1,1) = \"/\" then ,\n                 temp1 = left(temp1,length(temp1)-1)\n              temp1 = temp1 || \" \"\n\n         /* Search attributes and content*/\n              do b = 1 to length(temp1)\n                 if substr(temp1,b,1) <> \" \" ,\n                    & start_pos <= 0 then start_pos = b\n                 if substr(temp1,b,2) = '\" ' | ,\n                    substr(temp1,b,2) = \"' \" then do\n                    end_pos = b + 1\n                    temp2 = substr(temp1,start_pos,end_pos-start_pos)\n                    if substr(temp2,length(temp2),1) = \"/\" then ,\n                       temp2 = substr(temp2,1,length(temp2)-1)\n                    if pos(\"=\",temp2) <= 0 then do\n                       call domsg ,\n                          \"==>Error: equal sign not found in attribute :\" ,\n                          temp2\n                       exit_rc = 12\n                       signal done\n                    end /* end if pos(\"=\",temp2) <= 0 */\n                    attribute = substr(temp2,1,pos(\"=\",temp2)-1)\n\n         /* Skip XML specials attributes */\n                    if translate(substr(attribute,1,3)) = \"XML\" then do\n                       start_pos = 0\n                       end_pos = 0\n                       iterate\n                    end /* end if translate(substr(attribute,1,3)) = \"XML\" */\n                    content = substr(temp2,pos(\"=\",temp2)+2)\n                    content = substr(content,1,length(content)-1)\n                    start_pos = 0\n                    end_pos = 0\n                    call find_XML_equivalent\n                    call check_XML_content\n                 end /* end if substr(temp1,b,2) = '\" ' | , */\n              end /* end do b = 1 to length(temp1) */\n              XML_attribute = 0\n           end /* end if words(element) > 1 */\n           drop b content attribute temp1 temp2 start_pos end_pos\n\n           return\n\n         check_XML_content:\n        /* --------------------------------------------------------- *\n         * Check XML content before transfering it to the output     *\n         * record.                                                   *\n         * --------------------------------------------------------- */\n           if XML_content > 0 then x = element_pos\n           if x <= 0 then return\n           select\n              when type.x = \"BIN\" then content = ,\n                 txt2bin(content,length.x,signed.x)\n              when type.x = \"PACK\" then content = ,\n                 txt2pack(content,length.x,signed.x)\n              when type.x = \"NUM\" then content = ,\n                 txt2num(content,length.x,signed.x,sign_pos.x)\n              otherwise nop\n           end /* end select */\n\n        /* scan content for CDATA */\n           if pos(\"<|\u00a2CDATA\u00a2\",content) > 0 & type.x = \"CHAR\" then do\n              k = pos(\"<|\u00a2CDATA\u00a2\",content)\n              k = k + length(\"<|\u00a2CDATA\u00a2\")\n              l = pos(\"!!>\",content)\n              content = substr(content,k,l-k)\n           end /* end if pos(\"<|\u00a2CDATA\u00a2\",content) > 0 & type.x = \"CHAR\" */\n\n        /* scan content for escaping characters */\n           else\n           if (pos(\"&amp;\",content) > 0 | ,\n              pos(\"&lt;\",content) > 0 | ,\n              pos(\"&gt;\",content) > 0 | ,\n              pos(\"&apos;\",content) > 0 | ,\n              pos(\"&quot;\",content) > 0 | ,\n              pos(\"&#\",content) > 0) & type.x = \"CHAR\"  then\n              do k = 1 to length(content)\n                 k = pos(\"&\",content,k)\n                 l = pos(\";\",content,k)\n                 temp = translate(substr(content,k+1,l-k-1))\n                 select\n                    when temp = \"AMP\" then symbole = \"&\"\n                    when temp = \"LT\" then symbole = \"<\"\n                    when temp = \"GT\" then symbole = \">\"\n                    when temp = \"QUOT\" then symbole = '\"'\n                    when temp = \"APOS\" then symbole = \"'\"\n                    when substr(temp,1,1) = \"#\" then do\n                       temp1 = substr(temp,2)\n                       if left(temp1,1) = \"X\" then ,\n                          symbole = x2c(substr(temp1,2))\n                       else symbole = d2c(temp1)\n                       call domsg ,\n                          \"==>Warning : character reference:\" temp ,\n                          \"encountered in escaped characters.\"\n                       exit_rc = 04\n                       drop temp1\n                    end /* end when substr(temp,1,1) = \"#\" */\n                    otherwise do\n                       call domsg ,\n                         \"==>Error: unknown escaping character\" ,\n                          \"&\" || symbole || \";\" ,\n                          \"encounterd.\"\n                       exit_rc = 12\n                       signal done\n                    end /* end otherwise do */\n                 end /* end select */\n                 if k > 1 then temp1 = substr(content,1,k-1)\n                 else temp1 = \"\"\n                 temp2 = substr(content,k+length(temp)+2)\n                 content = temp1 || symbole || temp2\n                 drop temp1 temp2 temp symbole\n                 if pos(\"&\",content,k) <= 0 | ,\n                    pos(\";\",content,k) <= 0 then leave\n           end /* end if (pos(\"&amp;\",content) > 0 | */\n\n        /* check length of content against length of item in COBOL\n           copybook */\n           if length(content) > length.x then do\n              call domsg \"==>Error :\" ,\n                   \"the length of content\" content \"in XML element\" ,\n                   element\n              call domsg ,\n                   \"is greater than the length of the\" ,\n                   \"COBOL item\" name.x \":\" length.x\n              exit_rc = 12\n              signal done\n           end /* end if length(content) > length.x */\n           record.1 = overlay(content,record.1,start_pos.x,length.x)\n\n           return\n\n         exit_no_options:\n        /* --------------------------------------------------------- *\n         * Exit with error messages when no options are specified    *\n         * --------------------------------------------------------- */\n           say \"==>Error: TXT2XML requires a minimum of TXT,\" ,\n               \"COB, XML and FORMAT keywords and values.\"\n           say \" \"\n           say \"TXT2XML is a REXX script that converts TXT files\"\n           say \"from and to XML files using a COBOL copybook\"\n           say \"as reference. \"\n           say \" \"\n           say \"TXT2XML Syntax:\"\n           say \" \"\n           say \"TXT2XML TXT txt-ds\"\n           say \"        COB cob-ds\"\n           say \"        XML xml-ds\"\n           say \"        FORMAT X or T\"\n           say \"        DTD dtd-ds\"\n           say \"        PREFIX prefix\"\n           say \"        VERBOSE\"\n           say \"        BROWSE\"\n           say \" \"\n\n        /* --------------------------------------------------------- *\n         * Trying to start Java gui front end                        *\n         * --------------------------------------------------------- */\n           if rexx_os <> \"TSO\" then do\n              say \"Trying to start JAVA GUI front-end ...\"\n              \"java -jar txt2xml.jar\"\n           end /* end if rexx_os <> \"TSO\" */\n           exit_rc = 12\n           exit exit_rc\n\n         txt2bin: procedure expose(globals)\n        /* --------------------------------------------------------- *\n         * Convert text to binary                                    *\n         *                                                           *\n         * Parameter(s) : txt (mandatory)                            *\n         *                length (mandatory) (>0, in bytes)          *\n         *                signed (mandatory) (Y/N)                   *\n         *                                                           *\n         * --------------------------------------------------------- */\n           parse arg txt, lengt, signed\n           bin = \"\"\n           txt = strip(word(txt,1))\n           lengt = strip(word(lengt,1))\n           signed = translate(left(strip(signed),1))\n           if left(txt,1) <> \"+\" & left(txt,1) <> \"-\" then txt = \"+\" || txt\n           signe = substr(txt,1,1)\n           txt = substr(txt,2)\n           old_msgid = msgid\n           msgid = msgid || \"txt2bin():\"\n\n        /* Check data type, sign and length */\n           if datatype(translate(txt,\".00\",\",$E\")) <> \"NUM\" then do\n              call domsg \"==>Error :\" ,\n                         \"During text to numeric conversion, text (\" txt ,\n                         \") is not numeric.\"\n              call domsg \"Parameter values when the error occured:\"\n              call domsg \"txt           :\" txt\n              call domsg \"length        :\" lengt\n              call domsg \"signed        :\" signed\n              exit_rc = 12\n              signal done\n           end /* end if datatype(translate(txt,\".00\",\",$E\")) <> \"NUM\" */\n           if signe <> \"+\" & signe <> \"-\" then do\n              call domsg \"==>Error :\" ,\n                         \"During text to binary conversion, sign (\" signe ,\n                         \") is not a valid sign.\"\n              call domsg \"Parameter values when the error occured:\"\n              call domsg \"txt           :\" txt\n              call domsg \"length        :\" lengt\n              call domsg \"signed        :\" signed\n              exit_rc = 12\n              signal done\n           end /* end if signe <> \"+\" & signe <> \"-\" */\n           if length(txt) > 18 then do\n              call domsg \"==>Error :\" ,\n                         \"During text to binary conversion, text (\" txt ,\n                         \") with length (\" ,\n                         length(txt) ,\n                         \") is longer than 18 bytes.\"\n              call domsg \"Parameter values when the error occured:\"\n              call domsg \"txt           :\" txt\n              call domsg \"length        :\" lengt\n              call domsg \"signed        :\" signed\n              exit_rc = 12\n              signal done\n           end /* end if length(txt) > 18 */\n           if (lengt <> 8 & lengt <> 4 & lengt <> 2) | ,\n              datatype(lengt) <> \"NUM\" then do\n              call domsg \"==>Error :\" ,\n                         \"During text to binary conversion,\"  ,\n                         \"invalid length (\" lengt ,\n                         \") for COBOL binary item.\"\n              call domsg \"Parameter values when the error occured:\"\n              call domsg \"txt           :\" txt\n              call domsg \"length        :\" lengt\n              call domsg \"signed        :\" signed\n              exit_rc = 12\n              signal done\n           end /* end if (lengt <> 8 & lengt <> 4 & lengt <> 2) | , */\n           if (lengt = 2 & length(txt) > 4 ) | ,\n              (lengt = 4 & length(txt) > 9 ) | ,\n              (lengt = 8 & length(txt) > 18 ) then do\n              call domsg \"==>Error :\" ,\n                         \"During text to binary conversion,\"  ,\n                         \"unable to convert text \" txt ,\n                         \"of length (\" length(txt) ,\n                         \") into a COBOL binary item of length\" lengt \".\"\n              call domsg \"Parameter values when the error occured:\"\n              call domsg \"txt           :\" txt\n              call domsg \"length        :\" lengt\n              call domsg \"signed        :\" signed\n              exit_rc = 12\n              signal done\n           end /* end if (lengt = 2 & length(txt) > 4 ) | , */\n           if signed = \"N\" & signe = \"-\" then do\n              call domsg \"==>Error :\" ,\n                         \"During text to binary conversion, unable\" ,\n                         \"to convert signed data\" signe || txt\n                         \"into unsigned binary item.\"\n              call domsg \"Parameter values when the error occured:\"\n              call domsg \"txt           :\" txt\n              call domsg \"length        :\" lengt\n              call domsg \"signed        :\" signed\n              exit_rc = 12\n              signal done\n           end /* end if signed = \"N\" & signe = \"-\" */\n\n         /* If data is signed and negative, perform 2 complement */\n           if signed = \"Y\" & signe = \"-\" then do\n              i = 2 ** (lengt * 8)\n              txt = i - txt\n           end /* end if signed = \"Y\" & signe = \"-\" */\n\n         /* Do the conversion according to the Operating System */\n           select\n              when rexx_os = \"TSO\" then do /* big endian */\n                 bin = d2c(txt,lengt)\n              end /* end when rexx_os = \"TSO\" */\n              when rexx_os = \"UNIX\" then do /* little endian */\n                 bin = reverse(d2c(txt,lengt))\n              end /* end when rexx_os = \"UNIX\" */\n              when rexx_os = \"WIN32\" then do /* little endian */\n                 bin = reverse(d2c(txt,lengt))\n              end /* end when rexx_os = \"WIN32\" */\n              otherwise do\n                 call Domsg \"==>Error :\" ,\n                            \"During text to binary conversion,\" ,\n                            \"unsupported operating system :\" rexx_os\n                 exit_rc = 12\n                 signal done\n              end /* end otherwise do  */\n           end /* end select */\n           msgid = old_msgid\n\n           return bin\n\n         txt2pack: procedure expose(globals)\n        /* --------------------------------------------------------- *\n         * convert text data to packed decimal                       *\n         *                                                           *\n         * Parameter(s) : txt (mandatory)                            *\n         *                length (mandatory) (>0, in bytes)          *\n         *                signed (mandatory) (Y/N)                   *\n         *                                                           *\n         * --------------------------------------------------------- */\n           parse arg txt, lengt, signed\n           packed = \"\"\n           txt = strip(word(txt,1))\n           signed = translate(left(strip(signed),1))\n           lengt = strip(word(lengt,1))\n           if left(txt,1) <> \"+\" & left(txt,1) <> \"-\" then txt = \"+\" || txt\n           signe = substr(txt,1,1)\n           txt = substr(txt,2)\n           old_msgid = msgid\n           msgid = msgid || \"txt2pack():\"\n\n        /* Check data type, sign and length */\n           if datatype(translate(txt,\".00\",\",$E\")) <> \"NUM\" then do\n              call domsg \"==>Error :\" ,\n                         \"During text to numeric conversion, text (\" txt ,\n                         \") is not numeric.\"\n              call domsg \"Parameter values when the error occured:\"\n              call domsg \"txt           :\" txt\n              call domsg \"length        :\" lengt\n              call domsg \"signed        :\" signed\n              exit_rc = 12\n              signal done\n           end /* end if datatype(translate(txt,\".00\",\",$E\")) <> \"NUM\" */\n           if signe <> \"+\" & signe <> \"-\" then do\n              call domsg \"==>Error :\" ,\n                         \"During text to packed conversion, sign (\" signe ,\n                         \") is not a valid sign.\"\n              call domsg \"Parameter values when the error occured:\"\n              call domsg \"txt           :\" txt\n              call domsg \"length        :\" lengt\n              call domsg \"signed        :\" signed\n              exit_rc = 12\n              signal done\n           end /* end if signe <> \"+\" & signe <> \"-\" */\n           if lengt < 1  | datatype(lengt) <> \"NUM\" then do\n              call domsg \"==>Error :\" ,\n                         \"During text to packed conversion,\" ,\n                         \"invalid length (\" lengt ,\n                         \") for COBOL packed item.\"\n              call domsg \"Parameter values when the error occured:\"\n              call domsg \"txt           :\" txt\n              call domsg \"length        :\" lengt\n              call domsg \"signed        :\" signed\n              exit_rc = 12\n              signal done\n           end /* end if lengt < 1  | datatype(lengt) <> \"NUM\" */\n           if signed = \"N\" & signe = \"-\" then do\n              call domsg \"==>Error :\" ,\n                         \"During text to packed conversion, unable\" ,\n                         \"to convert signed data\" signe || txt\n                         \"into unsigned packed item.\"\n              call domsg \"Parameter values when the error occured:\"\n              call domsg \"txt           :\" txt\n              call domsg \"length        :\" lengt\n              call domsg \"signed        :\" signed\n              exit_rc = 12\n              signal done\n           end /* end if signed = \"N\" & signe = \"-\" */\n\n         /* if text length is odd, then add a zero so that with the sign,\n            the total length will still be odd */\n           if length(txt) = 2 * (length(txt) % 2) then txt = \"0\" || txt\n\n         /* do the conversion */\n           select\n              when signed = \"N\" then txt = txt || \"F\"\n              when signe = \"+\" then txt = txt || \"C\"\n              when signe = \"-\" then txt = txt || \"D\"\n              otherwise do\n                 call domsg \"==>Error :\" ,\n                            \"During text to packed conversion, sign (\" signe ,\n                            \") is not a valid sign.\"\n                 call domsg \"Parameter values when the error occured:\"\n                 call domsg \"txt           :\" txt\n                 call domsg \"length        :\" lengt\n                 call domsg \"signed        :\" signed\n                 exit_rc = 12\n                 signal done\n              end /* end otherwise do  */\n           end /* end select */\n\n         /* set packed data to requested length */\n           if length(txt) / 2 <= lengt then do\n              i = lengt - (length(txt) / 2)\n              if i > 0 then txt = copies(\"00\",i) || txt\n           end /* end if length(txt) / 2 <= lengt */\n           else do\n              call domsg \"==>Error :\" ,\n                         \"During txt to packed conversion,\"  ,\n                         \"unable to convert text\" txt ,\n                         \"of length (\" length(txt) ,\n                         \") into a COBOL packed item of length\" lengt \".\"\n              call domsg \"Parameter values when the error occured:\"\n              call domsg \"txt           :\" txt\n              call domsg \"length        :\" lengt\n              call domsg \"signed        :\" signed\n              exit_rc = 12\n              signal done\n           end /* end else do */\n           packed = x2c(txt)\n           msgid = old_msgid\n\n           return packed\n\n         txt2num: procedure expose(globals)\n        /* --------------------------------------------------------- *\n         * convert text data to numeric data                         *\n         *                                                           *\n         * Parameter(s) : txt (mandatory)                            *\n         *                length (mandatory) (>0, in bytes)          *\n         *                signed (mandatory) (Y/N)                   *\n         *                sign_pos (mandatory) (L/T/LS/TS)           *\n         *                                                           *\n         * --------------------------------------------------------- */\n           parse arg txt, lengt, signed, sign_pos\n           num = \"\"\n           txt = strip(word(txt,1))\n           lengt = strip(word(lengt,1))\n           signed = translate(left(strip(signed),1))\n           sign_pos = translate(left(strip(sign_pos),2))\n           if left(txt,1) <> \"+\" & left(txt,1) <> \"-\" then txt = \"+\" || txt\n           signe = substr(txt,1,1)\n           txt = substr(txt,2)\n           old_msgid = msgid\n           msgid = msgid || \"txt2num():\"\n\n        /* Check data type, sign and sign position */\n           if datatype(translate(txt,\".00\",\",$E\")) <> \"NUM\" then do\n              call domsg \"==>Error :\" ,\n                         \"During text to numeric conversion, text (\" txt ,\n                         \") is not numeric.\"\n              call domsg \"Parameter values when the error occured:\"\n              call domsg \"txt           :\" txt\n              call domsg \"length        :\" lengt\n              call domsg \"signed        :\" signed\n              exit_rc = 12\n              signal done\n           end /* end if datatype(translate(txt,\".00\",\",$E\")) <> \"NUM\" */\n           if signe <> \"+\" & signe <> \"-\" then do\n              call domsg \"==>Error :\" ,\n                         \"During text to numeric conversion, sign (\" signe ,\n                         \") is not a valid sign.\"\n              call domsg \"Parameter values when the error occured:\"\n              call domsg \"txt           :\" txt\n              call domsg \"length        :\" lengt\n              call domsg \"signed        :\" signed\n              call domsg \"sign_pos      :\" sign_pos\n              exit_rc = 12\n              signal done\n           end /* end if signe <> \"+\" & signe <> \"-\" */\n           if sign_pos <> \"L\" & ,\n              sign_pos <> \"T\" & ,\n              sign_pos <> \"LS\" & ,\n              sign_pos <> \"TS\" & signed = \"Y\" then do\n              call domsg \"==>Error :\" ,\n                         \"During text to numeric conversion, sign position (\" ,\n                         sign_pos\n                         \") is not valid.\"\n              call domsg \"Parameter values when the error occured:\"\n              call domsg \"txt           :\" txt\n              call domsg \"length        :\" lengt\n              call domsg \"signed        :\" signed\n              call domsg \"sign_pos      :\" sign_pos\n              exit_rc = 12\n              signal done\n           end /* end if sign_pos <> \"L\" &, */\n           if lengt < 1  | datatype(lengt) <> \"NUM\"  then do\n              call domsg \"==>Error :\" ,\n                         \"During text to num conversion,\" ,\n                         \"invalid length (\" lengt ,\n                         \") for COBOL numeric item.\"\n              call domsg \"Parameter values when the error occured:\"\n              call domsg \"txt           :\" txt\n              call domsg \"length        :\" lengt\n              call domsg \"signed        :\" signed\n              call domsg \"sign_pos      :\" sign_pos\n              exit_rc = 12\n              signal done\n           end /* end if lengt < 1  | datatype(lengt) <> \"NUM\" */\n           if signed = \"N\" & signe = \"-\" then do\n              call domsg \"==>Error :\" ,\n                         \"During text to numeric conversion, unable\" ,\n                         \"to convert signed data\" signe || txt ,\n                         \"into unsigned numeric item.\"\n              call domsg \"Parameter values when the error occured:\"\n              call domsg \"txt           :\" txt\n              call domsg \"length        :\" lengt\n              call domsg \"signed        :\" signed\n              call domsg \"sign_pos      :\" sign_pos\n              exit_rc = 12\n              signal done\n           end /* end if signed = \"N\" & signe = \"-\" */\n\n        /* Do the conversion according the OS */\n           positive = \"C\"\n           negative = \"D\"\n           select\n              when rexx_os = \"TSO\" then do\n                 separator = \"F\"\n                 sep_positive = \"4E\"\n                 sep_negative = \"60\"\n              end /* end when rexx_os = \"TSO\" */\n              when rexx_os = \"UNIX\" then do\n                 separator = \"3\"\n                 sep_positive = \"2B\"\n                 sep_negative = \"2D\"\n              end /* end when rexx_os = \"UNIX\" */\n              when rexx_os = \"WIN32\" then do\n                 separator = \"3\"\n                 sep_positive = \"2B\"\n                 sep_negative = \"2D\"\n              end /* end when rexx_os = \"WIN32\"*/\n              otherwise do\n                 call domsg \"==>Error :\" ,\n                            \"During text to numeric conversion,\" ,\n                            \"unsupported operating system :\" rexx_os\n                   exit_rc = 12\n                 signal done\n              end /* end otherwise do  */\n           end /* end select */\n\n         /* set numeric data to requested length */\n           i = 0\n           if (sign_pos = \"LS\" | sign_pos = \"TS\") then ,\n              i = lengt - length(txt) - 1\n           else i = lengt - length(txt)\n           if i > 0 then txt = copies(\"0\",i) || txt\n           else if i < 0 then do\n              call domsg \"==>Error :\" ,\n                         \"During txt to numeric conversion,\"  ,\n                         \"unable to convert text\" txt ,\n                         \"of length (\" length(txt) ,\n                         \") into a COBOL numeric item of length\" lengt \".\"\n              call domsg \"Parameter values when the error occured:\"\n              call domsg \"txt           :\" txt\n              call domsg \"length        :\" lengt\n              call domsg \"signed        :\" signed\n              call domsg \"sign_pos      :\" sign_pos\n              exit_rc = 12\n              signal done\n           end /* end else do */\n\n           select\n       /* Unsigned data */\n              when signed = \"N\" then do\n                 do i = 1 to length(txt)\n                    if datatype(substr(txt,i,1)) <> \"NUM\" then ,\n                       temp = temp || c2x(substr(txt,i,1))\n                    else num = num || separator || substr(txt,i,1)\n                 end /* end do i = 1 to length(txt)*/\n              end /* end when signed = \"N\" */\n\n       /* Trailing sign */\n              when sign_pos = \"T\" then do\n                 do i = 1 to length(txt) - 1\n                    if datatype(substr(txt,i,1)) <> \"NUM\" then ,\n                       temp = temp || c2x(substr(txt,i,1))\n                    else num = num || separator || substr(txt,i,1)\n                 end /* end do i = 1 to length(txt) - 1 */\n                 if signe = \"+\" then num = num || positive || right(txt,1)\n                 else num = num  || negative || right(txt,1)\n              end /* end when sign_pos = \"T\" */\n\n       /* Leading sign */\n              when sign_pos = \"L\" then do\n                 if signe = \"+\" then num = num  || positive || left(txt,1)\n                 else num = num  || negative || left(txt,1)\n                 do i = 2 to length(txt)\n                    if datatype(substr(txt,i,1)) <> \"NUM\" then ,\n                       temp = temp || c2x(substr(txt,i,1))\n                    else num = num || separator || substr(txt,i,1)\n                 end /* end do i = 2 to length(txt) */\n              end /* end when sign_pos = \"L\" */\n\n       /* Trailing sign separate */\n              when sign_pos = \"TS\" then do\n                 do i = 1 to length(txt)\n                    if datatype(substr(txt,i,1)) <> \"NUM\" then ,\n                       temp = temp || c2x(substr(txt,i,1))\n                    else num = num || separator || substr(txt,i,1)\n                 end /* end do i = 1 to length(txt) */\n                 if signe = \"+\" then num = num || sep_positive\n                 else num = num || sep_negative\n              end /* end when sign_pos = \"TS\" */\n\n       /* Leading sign separate */\n              when sign_pos = \"LS\" then do\n                 if signe = \"+\" then num = num || sep_positive\n                 else num = num || sep_negative\n                 do i = 1 to length(txt)\n                    if datatype(substr(txt,i,1)) <> \"NUM\" then ,\n                       temp = temp || c2x(substr(txt,i,1))\n                    else num = num || separator || substr(txt,i,1)\n                 end /* end do i = 1 to length(txt) */\n              end /* end when sign_pos = \"LS\" */\n              otherwise do\n                 call domsg \"==>Error :\" ,\n                            \"During text to numeric conversion,\" ,\n                            \"sign position (\" ,\n                            sign_pos\n                            \") is not valid.\"\n                 call domsg \"Parameter values when the error occured:\"\n                 call domsg \"txt           :\" txt\n                 call domsg \"length        :\" lengt\n                 call domsg \"signed        :\" signed\n                 call domsg \"sign_pos      :\" sign_pos\n                 exit_rc = 12\n                 signal done\n              end /* end otherwise do */\n           end /* end select */\n\n        /* Change MVS style signed characters to the Tiny-COBOL style */\n           if rexx_os = \"UNIX\" | rexx_os = \"WIN32\"  then do\n              if sign_pos = \"T\" then do\n                 select\n        /* - 0 */\n                    when right(num,2) = \"D0\" then ,\n                       num = overlay(\"7D\",num,length(num)-1,2)\n        /* - 1 */\n                    when right(num,2) = \"D1\" then ,\n                       num = overlay(\"4A\",num,length(num)-1,2)\n        /* - 2 */\n                    when right(num,2) = \"D2\" then ,\n                       num = overlay(\"4B\",num,length(num)-1,2)\n        /* - 3 */\n                    when right(num,2) = \"D3\" then ,\n                       num = overlay(\"4C\",num,length(num)-1,2)\n        /* - 4 */\n                    when right(num,2) = \"D4\" then ,\n                       num = overlay(\"4D\",num,length(num)-1,2)\n        /* - 5 */\n                    when right(num,2) = \"D5\" then ,\n                       num = overlay(\"4E\",num,length(num)-1,2)\n        /* - 6 */\n                    when right(num,2) = \"D6\" then ,\n                       num = overlay(\"4F\",num,length(num)-1,2)\n        /* - 7 */\n                    when right(num,2) = \"D5\" then ,\n                       num = overlay(\"50\",num,length(num)-1,2)\n        /* - 8 */\n                    when right(num,2) = \"D8\" then ,\n                       num = overlay(\"51\",num,length(num)-1,2)\n        /* - 9 */\n                    when right(num,2) = \"D9\" then ,\n                       num = overlay(\"52\",num,length(num)-1,2)\n        /* + 0 */\n                    when right(num,2) = \"C0\" then ,\n                       num = overlay(\"7B\",num,length(num)-1,2)\n        /* + 1 */\n                    when right(num,2) = \"C1\" then ,\n                       num = overlay(\"41\",num,length(num)-1,2)\n        /* + 2 */\n                    when right(num,2) = \"C2\" then ,\n                       num = overlay(\"42\",num,length(num)-1,2)\n        /* + 3 */\n                    when right(num,2) = \"C3\" then ,\n                       num = overlay(\"43\",num,length(num)-1,2)\n        /* + 4 */\n                    when right(num,2) = \"C4\" then ,\n                       num = overlay(\"44\",num,length(num)-1,2)\n        /* + 5 */\n                    when right(num,2) = \"C5\" then ,\n                       num = overlay(\"45\",num,length(num)-1,2)\n        /* + 6 */\n                    when right(num,2) = \"C6\" then ,\n                       num = overlay(\"46\",num,length(num)-1,2)\n        /* + 7 */\n                    when right(num,2) = \"C7\" then ,\n                       num = overlay(\"47\",num,length(num)-1,2)\n        /* + 8 */\n                    when right(num,2) = \"C8\" then ,\n                       num = overlay(\"48\",num,length(num)-1,2)\n        /* + 9 */\n                    when right(num,2) = \"C9\" then ,\n                        num = overlay(\"49\",num,length(num)-1,2)\n                    otherwise do\n                       call domsg \"==>Error :\" ,\n                                  \"During text to numeric conversion, unable\" ,\n                                  \"to convert signed data\" ,\n                                  right(num,2)\n                       call domsg \"Parameter values when the error occured:\"\n                       call domsg \"txt           :\" txt\n                       call domsg \"length        :\" lengt\n                       call domsg \"signed        :\" signed\n                       call domsg \"sign_pos      :\" sign_pos\n                       exit_rc = 12\n                       signal done\n                    end /* end otherwise do */\n                 end /* end select */\n              end /* end if sign_pos = \"T\" then do */\n              else if sign_pos = \"L\" then do\n                 select\n        /* - 0 */\n                    when left(num,2) = \"D0\" then ,\n                       num = overlay(\"7D\",num,1,2)\n        /* - 1 */\n                    when left(num,2) = \"D1\" then ,\n                       num = overlay(\"4A\",num,1,2)\n        /* - 2 */\n                    when left(num,2) = \"D2\" then ,\n                       num = overlay(\"4B\",num,1,2)\n        /* - 3 */\n                    when left(num,2) = \"D3\" then ,\n                       num = overlay(\"4C\",num,1,2)\n        /* - 4 */\n                    when left(num,2) = \"D4\" then ,\n                       num = overlay(\"4D\",num,1,2)\n        /* - 5 */\n                    when left(num,2) = \"D5\" then ,\n                       num = overlay(\"4E\",num,1,2)\n        /* - 6 */\n                    when left(num,2) = \"D6\" then ,\n                       num = overlay(\"4F\",num,1,2)\n        /* - 7 */\n                    when left(num,2) = \"D5\" then ,\n                       num = overlay(\"50\",num,1,2)\n        /* - 8 */\n                    when left(num,2) = \"D8\" then ,\n                       num = overlay(\"51\",num,1,2)\n        /* - 9 */\n                    when left(num,2) = \"D9\" then ,\n                       num = overlay(\"52\",num,1,2)\n        /* + 0 */\n                    when left(num,2) = \"C0\" then ,\n                       num = overlay(\"7B\",num,1,2)\n        /* + 1 */\n                    when left(num,2) = \"C1\" then ,\n                       num = overlay(\"41\",num,1,2)\n        /* + 2 */\n                    when left(num,2) = \"C2\" then ,\n                       num = overlay(\"42\",num,1,2)\n        /* + 3 */\n                    when left(num,2) = \"C3\" then ,\n                       num = overlay(\"43\",num,1,2)\n        /* + 4 */\n                    when left(num,2) = \"C4\" then ,\n                       num = overlay(\"44\",num,1,2)\n        /* + 5 */\n                    when left(num,2) = \"C5\" then ,\n                       num = overlay(\"45\",num,1,2)\n        /* + 6 */\n                    when left(num,2) = \"C6\" then ,\n                       num = overlay(\"46\",num,1,2)\n        /* + 7 */\n                    when left(num,2) = \"C7\" then ,\n                       num = overlay(\"47\",num,1,2)\n        /* + 8 */\n                    when left(num,2) = \"C8\" then ,\n                       num = overlay(\"48\",num,1,2)\n        /* + 9 */\n                    when left(num,2) = \"C9\" then ,\n                        num = overlay(\"49\",num,1,2)\n                    otherwise do\n                       call domsg \"==>Error :\" ,\n                                  \"During text to numeric conversion, unable\" ,\n                                  \"to convert signed data\" ,\n                                  left(num,2)\n                       call domsg \"Parameter values when the error occured:\"\n                       call domsg \"txt           :\" txt\n                       call domsg \"length        :\" lengt\n                       call domsg \"signed        :\" signed\n                       call domsg \"sign_pos      :\" sign_pos\n                       exit_rc = 12\n                       signal done\n                    end /* end otherwise do */\n                 end /* end select */\n              end /* end else if sign_pos = \"L\" */\n           end /* end if rexx_os = \"UNIX\" | rexx_os = \"WIN32\" */\n\n\n           msgid = old_msgid\n           return x2c(num)\n\n         bin2txt: procedure expose(globals)\n        /* --------------------------------------------------------- *\n         * convert binary to text                                    *\n         *                                                           *\n         * Parameter(s) : bin (mandatory)                            *\n         *                length (mandatory) (>0, in bytes)          *\n         *                signed (mandatory) (Y/N)                   *\n         *                                                           *\n         * --------------------------------------------------------- */\n           parse arg bin, lengt, signed\n           txt = \"\"\n           lengt = strip(word(lengt,1))\n           signed = translate(left(strip(signed),1))\n           old_msgid = msgid\n           msgid = msgid || \"bin2txt():\"\n\n        /* Check data type and length */\n           if signed <> \"N\" & signed <> \"Y\" then do\n              call domsg \"==>Error :\" ,\n                         \"During binary to text conversion, signed (\" signed ,\n                         \") parameter value is not valid.\"\n              call domsg \"Parameter values when the error occured:\"\n              call domsg \"bin           :\" c2x(bin)\n              call domsg \"length        :\" lengt\n              call domsg \"signed        :\" signed\n              exit_rc = 12\n              signal done\n           end /* end if signed <> \"N\" & signed <> \"Y\" */\n           if length(bin) > 8 then do\n              call domsg \"==>Error :\" ,\n                         \"During binary to text conversion, length (\" ,\n                         length(bin) ,\n                         \") of binary string is longer than 8 bytes.\"\n              call domsg \"Parameter values when the error occured:\"\n              call domsg \"bin           :\" c2x(bin)\n              call domsg \"length        :\" lengt\n              call domsg \"signed        :\" signed\n              exit_rc = 12\n              signal done\n           end /* end if length(txt) > 8 */\n           if (lengt <> 8 & lengt <> 4 & lengt <> 2) | ,\n              datatype(lengt) <> \"NUM\" then do\n              call domsg \"==>Error :\" ,\n                         \"During binary to txt conversion,\"  ,\n                         \"invalid length (\" lengt ,\n                         \") for COBOL binary item.\"\n              call domsg \"Parameter values when the error occured:\"\n              call domsg \"bin           :\" c2x(bin)\n              call domsg \"length        :\" lengt\n              call domsg \"signed        :\" signed\n              exit_rc = 12\n              signal done\n           end /* end if (lengt <> 8 & lengt <> 4 & lengt <> 2) | ,*/\n           if lengt <> length(bin) then do\n              call domsg \"==>Error :\" ,\n                         \"During binary to txt conversion,\"  ,\n                         \"unable to convert a COBOL binary item of\",\n                         \"length\" lengt \"to a text of length (\" length(txt) \")\"\n              call domsg \"Parameter values when the error occured:\"\n              call domsg \"bin           :\" c2x(bin)\n              call domsg \"length        :\" lengt\n              call domsg \"signed        :\" signed\n              exit_rc = 12\n              signal done\n           end /* end if lengt <> length(bin) */\n\n         /* Do the conversion according to the Operating System */\n           select\n              when rexx_os = \"TSO\" then do\n                 txt = strip(c2d(bin),\"L\",\"0\")\n              end /* end when rexx_os = \"TSO\" */\n              when rexx_os = \"UNIX\" then do\n                 txt = strip(c2d(reverse(bin)),\"L\",\"0\")\n              end /* end when rexx_os = \"UNIX\" */\n              when rexx_os = \"WIN32\" then do\n                 txt = strip(c2d(reverse(bin)),\"L\",\"0\")\n              end /* end when rexx_os = \"WIN32\" */\n              otherwise do\n                  call Domsg \"==>Error :\" ,\n                             \"During binary to text conversion,\" ,\n                             \"unsupported operating system :\" rexx_os\n                 exit_rc = 12\n                 signal done\n              end /* end otherwise do  */\n           end /* end select */\n           if length(txt) = 0 then txt = \"0\"\n\n         /* If data is signed and negative, perform 2 complement */\n           if signed = \"Y\" then do\n              i = 2 ** ((lengt * 8) - 1)\n              if txt >= i then do\n                 txt = 2 * i - txt\n                 txt = \"-\" || txt\n              end /* end if txt >= i */\n              else txt = \"+\" || txt\n           end /* end if signed = \"Y\" */\n           if length(txt) = 0 then txt = \"0\"\n\n           msgid = old_msgid\n           return txt\n\n         pack2txt: procedure expose(globals)\n        /* --------------------------------------------------------- *\n         * convert packed decimal data to text                       *\n         *                                                           *\n         * Parameter(s) : packed (mandatory)                         *\n         *                                                           *\n         * --------------------------------------------------------- */\n           parse arg packed\n           txt = c2x(packed)\n           old_msgid = msgid\n           msgid = msgid || \"pack2txt():\"\n\n           /* Check data sign and length */\n           signe = right(txt,1)\n           if signe <> \"A\" & ,\n              signe <> \"B\" & ,\n              signe <> \"C\" & ,\n              signe <> \"D\" & ,\n              signe <> \"E\" & ,\n              signe <> \"F\" then do\n              call domsg \"==>Error :\" ,\n                         \"During packed to text conversion, sign (\" signe ,\n                         \") is not a valid packed-decimal sign.\"\n              call domsg \"Parameter values when the error occured:\"\n              call domsg \"packed        :\" c2x(packed)\n              call domsg \"length        :\" lengt\n              call domsg \"signed        :\" signed\n              exit_rc = 12\n              signal done\n           end /* end if signe <> \"A\" & , */\n           if datatype(substr(txt,1,length(txt)-1)) <> \"NUM\" then do\n              call domsg \"==>Error :\" ,\n                         \"During packed to text conversion, packed (\" ,\n                         txt ,\n                         \") is not a valid packed-decimal.\"\n              call domsg \"Parameter values when the error occured:\"\n              call domsg \"packed        :\" c2x(packed)\n              call domsg \"length        :\" lengt\n              call domsg \"signed        :\" signed\n              exit_rc = 12\n              signal done\n           end /* end if datatype(substr(txt,1,length(txt)-1)) <> \"NUM\" */\n           txt = strip(substr(txt,1,length(txt)-1),\"L\",\"0\")\n           if length(txt) = 0 then txt = \"0\"\n           select\n              when signe = \"F\" then nop\n              when signe = \"C\" then txt = \"+\" || txt\n              when signe = \"A\" then txt = \"+\" || txt\n              when signe = \"E\" then txt = \"+\" || txt\n              when signe = \"D\" then txt = \"-\" || txt\n              when signe = \"B\" then txt = \"-\" || txt\n              otherwise do\n                 call domsg \"==>Error :\" ,\n                            \"During packed to text conversion, sign (\" ,\n                            signe ,\n                            \") is not a valid packed-decimal sign.\"\n                 call domsg \"Parameter values when the error occured:\"\n                 call domsg \"packed        :\" c2x(packed)\n                 call domsg \"length        :\" lengt\n                 call domsg \"signed        :\" signed\n                 exit_rc = 12\n                 signal done\n              end /* end otherwise do */\n           end /* end select */\n           if length(txt) = 0 then txt = \"0\"\n\n           msgid = old_msgid\n           return txt\n\n         num2txt: procedure expose(globals)\n        /* --------------------------------------------------------- *\n         * convert numeric data to text                              *\n         *                                                           *\n         * Parameter(s) : num (mandatory)                            *\n         *                signed (mandatory) (Y/N)                   *\n         *                sign_pos (mandatory) (L/T/LS/TS)           *\n         *                                                           *\n         * --------------------------------------------------------- */\n           parse arg num, signed, sign_pos\n           txt = c2x(num)\n           signed = translate(left(strip(signed),1))\n           sign_pos = translate(left(strip(sign_pos),2))\n           old_msgid = msgid\n           msgid = msgid || \"num2txt():\"\n\n        /* Check data type, sign and sign position */\n           if signed <> \"Y\" & signed <> \"N\" then do\n              call domsg \"==>Error :\" ,\n                         \"During numeric to text conversion, signed (\" signed ,\n                         \") parameter value is not a valid.\"\n              call domsg \"Parameter values when the error occured:\"\n              call domsg \"num           :\" num\n              call domsg \"signed        :\" signed\n              call domsg \"sign_pos      :\" sign_pos\n              exit_rc = 12\n              signal done\n           end /* end if signed <> \"Y\" & signed <> \"N\" */\n           if sign_pos <> \"L\" & ,\n              sign_pos <> \"T\" & ,\n              sign_pos <> \"LS\" & ,\n              sign_pos <> \"TS\" & signe = \"Y\" then do\n              call domsg \"==>Error :\" ,\n                         \"During numeric to text conversion, sign position (\" ,\n                         sign_pos\n                         \") is not valid.\"\n              call domsg \"Parameter values when the error occured:\"\n              call domsg \"num           :\" num\n              call domsg \"signed        :\" signed\n              call domsg \"sign_pos      :\" sign_pos\n              exit_rc = 12\n              signal done\n           end /* end if sign_pos <> \"L\" &, */\n\n\n        /* Change Tiny-COBOL signed characters to the MVS style  */\n           if rexx_os = \"UNIX\" | rexx_os = \"WIN32\"  then do\n              if sign_pos = \"T\" then do\n                 select\n        /* - 0 */\n                    when right(txt,2) = \"7D\" then ,\n                       txt = overlay(\"D0\",txt,length(txt)-1,2)\n        /* - 1 */\n                    when right(txt,2) = \"4A\" then ,\n                       txt = overlay(\"D1\",txt,length(txt)-1,2)\n        /* - 2 */\n                    when right(txt,2) = \"4B\" then ,\n                       txt = overlay(\"D2\",txt,length(txt)-1,2)\n        /* - 3 */\n                    when right(txt,2) = \"4C\" then ,\n                       txt = overlay(\"D3\",txt,length(txt)-1,2)\n        /* - 4 */\n                    when right(txt,2) = \"4D\" then ,\n                       txt = overlay(\"D4\",txt,length(txt)-1,2)\n        /* - 5 */\n                    when right(txt,2) = \"4E\" then ,\n                       txt = overlay(\"D5\",txt,length(txt)-1,2)\n        /* - 6 */\n                    when right(txt,2) = \"4F\" then ,\n                       txt = overlay(\"D6\",txt,length(txt)-1,2)\n        /* - 7 */\n                    when right(txt,2) = \"5D\" then ,\n                       txt = overlay(\"D7\",txt,length(txt)-1,2)\n        /* - 8 */\n                    when right(txt,2) = \"51\" then ,\n                       txt = overlay(\"D8\",txt,length(txt)-1,2)\n        /* - 9 */\n                    when right(txt,2) = \"52\" then ,\n                       txt = overlay(\"D9\",txt,length(txt)-1,2)\n        /* + 0 */\n                    when right(txt,2) = \"7B\" then ,\n                       txt = overlay(\"C0\",txt,length(txt)-1,2)\n        /* + 1 */\n                    when right(txt,2) = \"41\" then ,\n                       txt = overlay(\"C1\",txt,length(txt)-1,2)\n        /* + 2 */\n                    when right(txt,2) = \"42\" then ,\n                       txt = overlay(\"C2\",txt,length(txt)-1,2)\n        /* + 3 */\n                    when right(txt,2) = \"43\" then ,\n                       txt = overlay(\"C3\",txt,length(txt)-1,2)\n        /* + 4 */\n                    when right(txt,2) = \"44\" then ,\n                       txt = overlay(\"C4\",txt,length(txt)-1,2)\n        /* + 5 */\n                    when right(txt,2) = \"45\" then ,\n                       txt = overlay(\"C5\",txt,length(txt)-1,2)\n        /* + 6 */\n                    when right(txt,2) = \"46\" then ,\n                       txt = overlay(\"C6\",txt,length(txt)-1,2)\n        /* + 7 */\n                    when right(txt,2) = \"47\" then ,\n                       txt = overlay(\"C7\",txt,length(txt)-1,2)\n        /* + 8 */\n                    when right(txt,2) = \"48\" then ,\n                       txt = overlay(\"C8\",txt,length(txt)-1,2)\n        /* + 9 */\n                    when right(txt,2) = \"49\" then ,\n                        txt = overlay(\"C9\",txt,length(txt)-1,2)\n                    otherwise do\n                       call domsg \"==>Error :\" ,\n                                  \"During text to numeric conversion, unable\" ,\n                                  \"to convert signed data\" ,\n                                  right(txt,2)\n                       call domsg \"Parameter values when the error occured:\"\n                       call domsg \"num           :\" num\n                       call domsg \"signed        :\" signed\n                       call domsg \"sign_pos      :\" sign_pos\n                       exit_rc = 12\n                       signal done\n                    end /* end otherwise do */\n                 end /* end select */\n              end /* end if sign_pos = \"T\" then do */\n              else if sign_pos = \"L\" then do\n                 select\n        /* - 0 */\n                    when left(txt,2) = \"7D\" then ,\n                       txt = overlay(\"D0\",txt,1,2)\n        /* - 1 */\n                    when left(txt,2) = \"4A\" then ,\n                       txt = overlay(\"D1\",txt,1,2)\n        /* - 2 */\n                    when left(txt,2) = \"4B\" then ,\n                       txt = overlay(\"D2\",txt,1,2)\n        /* - 3 */\n                    when left(txt,2) = \"4C\" then ,\n                       txt = overlay(\"D3\",txt,1,2)\n        /* - 4 */\n                    when left(txt,2) = \"4D\" then ,\n                       txt = overlay(\"D4\",txt,1,2)\n        /* - 5 */\n                    when left(txt,2) = \"4E\" then ,\n                       txt = overlay(\"D5\",txt,1,2)\n        /* - 6 */\n                    when left(txt,2) = \"4F\" then ,\n                       txt = overlay(\"D6\",txt,1,2)\n        /* - 7 */\n                    when left(txt,2) = \"5D\" then ,\n                       txt = overlay(\"D7\",txt,1,2)\n        /* - 8 */\n                    when left(txt,2) = \"51\" then ,\n                       txt = overlay(\"D8\",txt,1,2)\n        /* - 9 */\n                    when left(txt,2) = \"52\" then ,\n                       txt = overlay(\"D9\",txt,1,2)\n        /* + 0 */\n                    when left(txt,2) = \"7B\" then ,\n                       txt = overlay(\"C0\",txt,1,2)\n        /* + 1 */\n                    when left(txt,2) = \"41\" then ,\n                       txt = overlay(\"C1\",txt,1,2)\n        /* + 2 */\n                    when left(txt,2) = \"42\" then ,\n                       txt = overlay(\"C2\",txt,1,2)\n        /* + 3 */\n                    when left(txt,2) = \"43\" then ,\n                       txt = overlay(\"C3\",txt,1,2)\n        /* + 4 */\n                    when left(txt,2) = \"44\" then ,\n                       txt = overlay(\"C4\",txt,1,2)\n        /* + 5 */\n                    when left(txt,2) = \"45\" then ,\n                       txt = overlay(\"C5\",txt,1,2)\n        /* + 6 */\n                    when left(txt,2) = \"46\" then ,\n                       txt = overlay(\"C6\",txt,1,2)\n        /* + 7 */\n                    when left(txt,2) = \"47\" then ,\n                       txt = overlay(\"C7\",txt,1,2)\n        /* + 8 */\n                    when left(txt,2) = \"48\" then ,\n                       txt = overlay(\"C8\",txt,1,2)\n        /* + 9 */\n                    when left(txt,2) = \"49\" then ,\n                        txt = overlay(\"C9\",txt,1,2)\n                    otherwise do\n                       call domsg \"==>Error :\" ,\n                                  \"During numeric to text conversion, unable\" ,\n                                  \"to convert signed data\" ,\n                                  left(txt,2)\n                       call domsg \"Parameter values when the error occured:\"\n                       call domsg \"num           :\" num\n                       call domsg \"signed        :\" signed\n                       call domsg \"sign_pos      :\" sign_pos\n                       exit_rc = 12\n                       signal done\n                    end /* end otherwise do */\n                 end /* end select */\n              end /* end else if sign_pos = \"L\" */\n           end /* end if rexx_os = \"UNIX\" | rexx_os = \"WIN32\" */\n\n        /* Do the conversion according the OS */\n           positive = \"C\"\n           negative = \"D\"\n           select\n              when rexx_os = \"TSO\" then do\n                 separator = \"F\"\n                 sep_positive = \"4E\"\n                 sep_negative = \"60\"\n              end /* end when rexx_os = \"TSO\" */\n              when rexx_os = \"UNIX\" then do\n                 separator = \"3\"\n                 sep_positive = \"2B\"\n                 sep_negative = \"2D\"\n              end /* end when rexx_os = \"UNIX\" */\n              when rexx_os = \"WIN32\" then do\n                 separator = \"3\"\n                 sep_positive = \"2B\"\n                 sep_negative = \"2D\"\n              end /* end when rexx_os = \"WIN32\"*/\n              otherwise do\n                 call domsg \"==>Error :\" ,\n                            \"During numeric to text conversion,\" ,\n                            \"unsupported operating system :\" rexx_os\n                 exit_rc = 12\n                 signal done\n              end /* end otherwise do  */\n           end /* end select */\n\n           temp = \"\"\n           select\n        /* --------------------------------------------------------- *\n         * Unsigned data.                                            *\n         * --------------------------------------------------------- */\n              when signed = \"N\" then do\n                 do i = 2 to length(txt) by 2\n                    if substr(txt,i-1,1) <> separator & ,\n                       substr(txt,i-1,1) <> positive & ,\n                       substr(txt,i-1,1) <> negative then ,\n                       temp = temp || x2c(substr(txt,i-1,2))\n                    else temp = temp || substr(txt,i,1)\n                 end /* end do i = 2 to length(txt) by 2 */\n                 txt = strip(temp,\"L\",\"0\")\n              end /* end when signed = \"N\" */\n\n        /* --------------------------------------------------------- *\n         * Signed data.                                              *\n         * --------------------------------------------------------- */\n              when signed = \"Y\" then do\n                 select\n       /* Trailing sign */\n                    when sign_pos = \"T\" then do\n                       do i = 2 to length(txt) by 2\n                          if substr(txt,i-1,1) <> separator & ,\n                             substr(txt,i-1,1) <> positive & ,\n                             substr(txt,i-1,1) <> negative then ,\n                             temp = temp || x2c(substr(txt,i-1,2))\n                          else temp = temp || substr(txt,i,1)\n                       end /* end do i = 2 to length(txt) by 2 */\n                       temp = strip(temp,\"L\",\"0\")\n                       if left(right(txt,2),1) = positive then ,\n                          temp = \"+\" || temp\n                       else if left(right(txt,2),1) = negative then ,\n                               temp = \"-\" || temp\n                       txt = temp\n                    end /* end when sign_pos = \"T\" */\n\n       /* Leading sign */\n                    when sign_pos = \"L\" then do\n                       do i = 2 to length(txt) by 2\n                          if substr(txt,i-1,1) <> separator & ,\n                             substr(txt,i-1,1) <> positive & ,\n                             substr(txt,i-1,1) <> negative then ,\n                             temp = temp || x2c(substr(txt,i-1,2))\n                          else temp = temp || substr(txt,i,1)\n                       end /* end do i = 2 to length(txt) by 2 */\n                       temp = strip(temp,\"L\",\"0\")\n                       if left(txt,1) = positive then temp = \"+\" || temp\n                       else if left(txt,1) = negative then temp = \"-\" || temp\n                       txt = temp\n                    end /* end when sign_pos = \"L\" */\n\n       /* Trailing sign separate */\n                    when sign_pos = \"TS\" then do\n                       do i = 2 to (length(txt) - 2) by 2\n                          if substr(txt,i-1,1) <> separator & ,\n                             substr(txt,i-1,1) <> positive & ,\n                             substr(txt,i-1,1) <> negative then ,\n                             temp = temp || x2c(substr(txt,i-1,2))\n                          else temp = temp || substr(txt,i,1)\n                       end /* end do i = 2 to (length(txt) - 2) by 2 */\n                       temp = strip(temp,\"L\",\"0\")\n                       if right(txt,2) = sep_positive then temp = \"+\" || temp\n                       else if right(txt,2) = sep_negative then ,\n                               temp = \"-\" || temp\n                       txt = temp\n                    end /* end when sign_pos = \"TS\" */\n\n       /* Leading sign separate */\n                    when sign_pos = \"LS\" then do\n                       do i = 4 to length(txt) by 2\n                          if substr(txt,i-1,1) <> separator & ,\n                             substr(txt,i-1,1) <> positive & ,\n                             substr(txt,i-1,1) <> negative then ,\n                             temp = temp || x2c(substr(txt,i-1,2))\n                          else temp = temp || substr(txt,i,1)\n                       end /* end do i = 2 to (length(txt) - 2) by 2 */\n                       temp = strip(temp,\"L\",\"0\")\n                       if left(txt,2) = sep_positive then temp = \"+\" || temp\n                       else if left(txt,2) = sep_negative then ,\n                               temp = \"-\" || temp\n                       txt = temp\n                    end /* end when sign_pos = \"LS\" */\n                    otherwise do\n                       call domsg \"==>Error :\" ,\n                                  \"During text to numeric conversion,\" ,\n                                  \"sign position (\" ,\n                                  sign_pos\n                                  \") is not valid.\"\n                       call domsg \"Parameter values when the error occured:\"\n                       call domsg \"num           :\" num\n                       call domsg \"signed        :\" signed\n                       call domsg \"sign_pos      :\" sign_pos\n                       exit_rc = 12\n                       signal done\n                    end /* end otherwise do */\n                 end /* end select */\n              end /* end when signed = \"Y\" */\n              otherwise do\n                 call domsg \"==>Error :\" ,\n                            \"During numeric to text conversion,\" ,\n                            \"signed (\" signed ,\n                            \") parameter value is not a valid.\"\n                 call domsg \"Parameter values when the error occured:\"\n                 call domsg \"num           :\" num\n                 call domsg \"signed        :\" signed\n                 call domsg \"sign_pos      :\" sign_pos\n                 exit_rc = 12\n                 signal done\n              end /* end otherwise do */\n           end /* end select */\n           drop temp\n           if length(txt) = 0 then txt = \"0\"\n\n           msgid = old_msgid\n           return txt\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XML2COB": {"ttr": 8705, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00A\\x01\\x05\\x05\\x9f\\x01\\x05\\x05\\x9f\\x12(\\x06\\xd9\\x06\\xd9\\x00\\x00\\xc3\\xe3\\xc9\\xe2\\xf0\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-02-28T00:00:00", "modifydate": "2005-02-28T12:28:41", "lines": 1753, "newlines": 1753, "modlines": 0, "user": "CTIS003"}, "text": "/* rexx procedure */\n        ver = \"1.25\"\n        /* --------------------------------------------------------- *\n         *                                                           *\n         * Name:      XML2COB                                        *\n         *                                                           *\n         * Function:  Convert a XML file to a COBOL copybook.        *\n         *                                                           *\n         * Syntax:    XML2COB   XML xml-ds     (or DD:xml-ddname)    *\n         *                      COB cob-ds     (or DD:cob-ddname)    *\n         *                      PREFIX  prefix (see below)           *\n         *                      ROUND          (see below)           *\n         *                      LEVEL01        (see below)           *\n         *                      VERBOSE        (display messages)    *\n         *                      BROWSE         (will browse report)  *\n         *                                                           *\n         *  (MVS)     if no parameters and under ISPF then the ISPF  *\n         *            dialog will be invoked.                        *\n         *                                                           *\n         *            Where:                                         *\n         *                                                           *\n         * ------------------- Mandatory --------------------------- *\n         *                                                           *\n         *  (MVS)     xml_ds    is a sequential dataset or member of *\n         *                      a partitioned dataset                *\n         *                                                           *\n         *  (MVS)               or dd:ddname                         *\n         *                                                           *\n         *  (WIN/UNIX)          or a file                            *\n         *                                                           *\n         *                                                           *\n         *  (MVS)     cob_ds    is a sequential dataset or member of *\n         *                      a partitioned dataset                *\n         *                                                           *\n         *  (MVS)               or dd:ddname                         *\n         *                                                           *\n         *  (WIN/UNIX)          or a file                            *\n         *                                                           *\n         * ------------------- Optional ---------------------------- *\n         *                                                           *\n         *            prefix    a leading string to be removed from  *\n         *                      the XML element                      *\n         *                                                           *\n         *                                                           *\n         *            round     to round length of COBOL items to    *\n         *                      the next 5 or 0. I.e., if length     *\n         *                      equals 16, then it will become 20.   *\n         *                                                           *\n         *                                                           *\n         *            level01   If specified, COBOL copybook level   *\n         *                      will start at 1. Otherwise, it will  *\n         *                      start, by default, at level 02.      *\n         *                                                           *\n         *                                                           *\n         *            browse    (will browse report) only used       *\n         *                      under ISPF for use by the ISPF       *\n         *                      interface                            *\n         *                                                           *\n         *                                                           *\n         *            verbose   all messages will be displayed.      *\n         *                                                           *\n         *                                                           *\n         * Functions:                                                *\n         *                                                           *\n         *  additem   additem(element, content) where                *\n         *            element   is the XML element name to added to  *\n         *                      the COBOL item list.                 *\n         *            content   is the XML content used to extract   *\n         *                      the meta-data (length, type, sign,   *\n         *                      ...) of the COBOL item.              *\n         *                                                           *\n         *  dropitem  dropitem(item_nbr) where                       *\n         *            item_nbr  is the item number to be removed     *\n         *                      from the COBOL item list.            *\n         *                                                           *\n         *                                                           *\n         * --------------------------------------------------------- *\n         *                                                           *\n         * Author(s): Lionel B. Dyck                                 *\n         *            Kaiser Permanente Information Technology       *\n         *            Walnut Creek, CA 94598                         *\n         *            (925) 926-5332                                 *\n         *            Internet: lionel.b.dyck@kp.org                 *\n         *                                                           *\n         *            Pierre Delaunoy                                *\n         *            Belgium                                        *\n         *            Mail: sunuraxi@users.sourceforge.net           *\n         *                                                           *\n         * Web:       http://sourceforge.net/projects/txt2xml-rexx/  *\n         *                                                           *\n         * Doc:       See the documentation directory or dataset     *\n         *                                                           *\n         *---------------------------------------------------------- */\n\n         parse arg option\n         i = time(\"R\")        /* set start ot time */\n\n        /* --------------------------------------------------------- *\n         * Global variables                                          *\n         * --------------------------------------------------------- */\n         msgid = \"XML2COB:\"   /* Default message identifier */\n         r = 0                /* Used for reporting */\n         browse = 0           /* Used for reporting */\n         confirm = 0          /* Used for reporting */\n         rpt.1 = \"\"           /* Used for reporting */\n         exit_rc = 0          /* return code on exit  */\n         rexx_os = \"\"         /* Operating system running rexx*/\n         ret = 0              /* flag to return instead of exit\n                                 at end of PGM */\n         level.0 = 0          /* level of COBOL item */\n         name.1 = \"\"          /* name of COBOL item */\n         type.1 = \"\"          /* type of COBOL item */\n         length.1 = 0         /* length of COBOL item */\n         start_pos.1 = 0      /* starting position of COBOL item */\n         sign.1 = \"\"          /* sign flag of COBOL item */\n         occurs.1 = 0         /* occcurence of COBOL item */\n         nb_items = 0         /* number of COBOL items */\n         prefix = \"\"          /* prefix of an XML element name */\n         round = \"\"           /* to round item length to the next 5 or 0 */\n         level01 = \"\"         /* to start COBOL copybook at level 01 */\n         cob_lines = 0        /* number of COBOL copybook lines */\n         cob. = \"\"            /* Generated COBOL copybook */\n         cobol_length = 0     /* Total length of the COBOL record in bytes  */\n         current_level = 0    /* COBOL current level */\n         level_increment = 0  /* COBOL level increment */\n         nb_first_child = 0   /* number of XML first child element */\n         total_items = 0      /* total number of COBOL items */\n                              /* COBOL reserved words according to IBM's\n                                 \"Enterprise COBOL for z/OS V3R3\n                                 Language Reference \"(IGY3LR20) */\n         reserved_words = ,\n           \"AFTER ALIGNED ALL ALLOCATE ALPHABET ALPHABETIC\",\n           \"ALPHABETIC-LOWER ALPHABETIC-UPPER ALPHANUMERIC\",\n           \"ALPHANUMERIC-EDITED ALSO ALTER\",\n           \"ALTERNATE AND ANY ANYCASE APPLY ARE\",\n           \"AREA AREAS AS ASCENDING ASSIGN AT\",\n           \"AUTHOR B-AND B-NOT B-OR B-XOR BASED\",\n           \"BASIS BEFORE BEGINNING BINARY BINARY-CHAR BINARY-DOUBLE\",\n           \"BINARY-LONG BINARY-SHORT BIT BLANK BLOCK BOOLEAN\",\n           \"BOTTOM BY CALL CANCEL CBL CD\",\n           \"CF CH CHARACTER CHARACTERS CLASS CLASS-ID\",\n           \"CLOCK-UNITS CLOSE COBOL CODE CODE-SET COL\",\n           \"COLLATING COLS COLUMN COLUMNS COM-REG COMMA\",\n           \"COMMON COMMUNICATION COMP COMP-1 COMP-2 COMP-3\",\n           \"COMP-4 COMP-5 COMPUTATIONAL COMPUTATIONAL-1\",\n           \"COMPUTATIONAL-2 COMPUTATIONAL-3\",\n           \"COMPUTATIONAL-4 COMPUTATIONAL-5 COMPUTE CONDITION\",\n           \"CONFIGURATION CONSTANT\",\n           \"CONTAINS CONTENT CONTINUE CONTROL CONTROLS CONVERTING\",\n           \"COPY CORR CORRESPONDING COUNT CRT CURRENCY\",\n           \"CURSOR DATA DATA-POINTER DATE DATE-COMPILED DATE-WRITTEN\",\n           \"DAY DAY-OF-WEEK DBCS DE DEBUG-CONTENTS DEBUG-ITEM\",\n           \"DEBUG-LINE DEBUG-NAME DEBUG-SUB-1 DEBUG-SUB-2 DEBUG-SUB-3\",\n           \"DEBUGGING\",\n           \"DECIMAL-POINT DECLARATIVES DEFAULT DELETE DELIMITED DELIMITER\",\n           \"DEPENDING DESCENDING DESTINATION DETAIL DISABLE DISPLAY\",\n           \"DISPLAY-1 DIVIDE DIVISION DOWN DUPLICATES DYNAMIC\",\n           \"EC EGCS EGI EJECT ELSE EMI\",\n           \"ENABLE END END-ACCEPT END-ADD END-CALL END-COMPUTE\",\n           \"END-DELETE END-DISPLAY END-DIVIDE END-EVALUATE END-EXEC END-IF\",\n           \"END-INVOKE END-MULTIPLY END-OF-PAGE END-PERFORM END-READ\",\n           \"END-RECEIVE\",\n           \"END-RETURN END-REWRITE END-SEARCH END-START END-STRING\",\n           \"END-SUBTRACT\",\n           \"END-UNSTRING END-WRITE END-XML ENDING ENTER ENTRY\",\n           \"ENVIRONMENT EO EOP EQUAL ERROR ESI\",\n           \"EVALUATE EVERY EXCEPTION EXCEPTION-OBJECT EXEC EXECUTE\",\n           \"EXIT EXTEND EXTERNAL FACTORY FALSE FD\",\n           \"FILE FILE-CONTROL FILLER FINAL FIRST FLOAT-EXTENDED\",\n           \"FLOAT-LONG FLOAT-SHORT FOOTING FOR FORMAT FREE\",\n           \"FROM FUNCTION FUNCTION-ID FUNCTION-POINTER GENERATE GET\",\n           \"GIVING GLOBAL GO GOBACK GREATER GROUP\",\n           \"GROUP-USAGE HEADING HIGH-VALUE HIGH-VALUES I-O I-O-CONTROL\",\n           \"ID IDENTIFICATION IF IN INDEX INDEXED\",\n           \"INDICATE INHERITS INITIAL INITIALIZE INITIATE INPUT\",\n           \"INPUT-OUTPUT INSERT INSPECT INSTALLATION INTERFACE INTERFACE-ID\",\n           \"INTO INVALID INVOKE IS JNIENVPTR JUST\",\n           \"JUSTIFIED KANJI KEY LABEL LAST LEADING\",\n           \"LEFT LENGTH LESS LIMIT LIMITS LINAGE\",\n           \"LINAGE-COUNTER LINE LINE-COUNTER LINES LINKAGE LOCAL-STORAGE\",\n           \"LOCALE LOCK LOW-VALUE LOW-VALUES MEMORY MERGE\",\n           \"MESSAGE METHOD METHOD-ID MINUS MODE MODULES\",\n           \"MORE-LABELS MOVE MULTIPLE MULTIPLY NATIONAL NATIONAL-EDITED\",\n           \"NATIVE NEGATIVE NESTED NEXT NO NOT\",\n           \"NULL NULLS NUMBER NUMERIC NUMERIC-EDITED OBJECT\",\n           \"OBJECT-COMPUTER OBJECT-REFERENCE OCCURS OF OFF OMITTED\",\n           \"ON OPEN OPTIONAL OPTIONS OR ORDER\",\n           \"ORGANIZATION OTHER OUTPUT OVERFLOW OVERRIDE PACKED-DECIMAL\",\n           \"PADDING PAGE PAGE-COUNTER PASSWORD PERFORM PF\",\n           \"PH PIC PICTURE PLUS POINTER POSITION\",\n           \"POSITIVE PRESENT PRINTING PROCEDURE PROCEDURE-POINTER PROCEDURES\",\n           \"PROCEED PROCESSING PROGRAM PROGRAM-ID PROGRAM-POINTER PROPERTY\",\n           \"PROTOTYPE PURGE QUEUE QUOTE QUOTES RAISE\",\n           \"RAISING RANDOM RD READ READY RECEIVE\",\n           \"RECORD RECORDING RECORDS RECURSIVE REDEFINES REEL\",\n           \"REFERENCE REFERENCES RELATIVE RELEASE RELOAD REMAINDER\",\n           \"REMOVAL RENAMES REPLACE REPLACING REPORT REPORTING\",\n           \"REPORTS REPOSITORY RERUN RESERVE RESET RESUME\",\n           \"RETRY RETURN RETURN-CODE RETURNING REVERSED REWIND\",\n           \"REWRITE RF RH RIGHT ROUNDED RUN\",\n           \"SAME SCREEN SD SEARCH SECTION SECURITY\",\n           \"SEGMENT SEGMENT-LIMIT SELECT SELF SEND SENTENCE\",\n           \"SEPARATE SEQUENCE SEQUENTIAL SERVICE SET SHARING\",\n           \"SHIFT-IN SHIFT-OUT SIGN SIZE SKIP1 SKIP2\",\n           \"SKIP3 SORT SORT-CONTROL SORT-CORE-SIZE SORT-FILE-SIZE SORT-MERGE\",\n           \"SORT-MESSAGE SORT-MODE-SIZE SORT-RETURN SOURCE SOURCE-COMPUTER\",\n           \"SOURCES\",\n           \"SPACE SPACES SPECIAL-NAMES SQL STANDARD STANDARD-1\",\n           \"STANDARD-2 START STATUS STOP STRING SUB-QUEUE-1\",\n           \"SUB-QUEUE-2 SUB-QUEUE-3 SUBTRACT SUM SUPER SUPPRESS\",\n           \"SYMBOLIC SYNC SYNCHRONIZED SYSTEM-DEFAULT TABLE TALLY\",\n           \"TALLYING TAPE TERMINAL TERMINATE TEST TEXT\",\n           \"THAN THEN THROUGH THRU TIME TIMES\",\n           \"TITLE TO TOP TRACE TRAILING TRUE\",\n           \"TYPE TYPEDEF UNIT UNIVERSAL UNLOCK UNSTRING\",\n           \"UNTIL UP UPON USAGE USE USER-DEFAULT\",\n           \"USING VAL-STATUS VALID VALIDATE VALIDATE-STATUS VALUE\",\n           \"VALUES VARYING WHEN WHEN-COMPILED WITH WORDS\",\n           \"WORKING-STORAGE WRITE WRITE-ONLY XML XML-CODE XML-EVENT\",\n           \"XML-NTEXT XML-TEXT ZERO ZEROES ZEROS\"\n\n         globals = \"msgid r browse confirm rpt. exit_rc rexx_os ret\"\n         globals = globals \"level. name. type. length. sign. start_POS.\"\n         globals = globals \"nb_items prefix current_level occurs.\"\n         globals = globals \"level_increment nb_first_child total_items\"\n         globals = globals \"first_child reserved_words cob_lines cob.\"\n         globals = globals \"round level01 cobol_length\"\n\n        /* --------------------------------------------------------- *\n         * Test if concatenation and OR operators works              *\n         * --------------------------------------------------------- */\n        /* first test concatenation operator */\n         if \"1\" || \"2\" <> \"12\" then do\n            say \"==>Error: the Rexx concatenation operator doesn't work.\"\n            say \" \"\n            say \"You may request help on the user forum at :\"\n            say \" \"\n            say ,\n                \"http://sourceforge.net/forum/forum.php?forum_id=391891\"\n            say \" \"\n            exit_rc = 12\n            exit exit_rc\n         end /* end if \"1\" || \"2\" <> \"12\" */\n\n        /* Second test OR operator */\n         if (\"1\" <> \"1\" | \"2\" <> \"2\") > 0 then do\n            say \"==>Error: the Rexx OR operator doesn't work.\" ,\n            say \" \"\n            say \"You may request help on the user forum at :\"\n            say \" \"\n            say ,\n               \"http://sourceforge.net/forum/forum.php?forum_id=391891\"\n            say \" \"\n            exit_rc = 12\n            exit exit_rc\n         end /* end if (\"1\" <> \"1\" | \"2\" <> \"2\") > 0 */\n\n        /* --------------------------------------------------------- *\n         * Get REXX Operating System and type.                       *\n         * --------------------------------------------------------- */\n        /* get rexx interpreter name */\n         parse version rexx_interpreter . .\n         rexx_interpreter = translate(rexx_interpreter)\n         if left(rexx_interpreter, 5) == \"REXX-\" then do\n            parse var rexx_interpreter \"REXX-\" rexx_interpreter \"_\" .\n         end /* end if left(rexx_interpreter, 5)  */\n\n        /* get rexx operating system */\n         parse source rexx_os .\n         rexx_os = translate(word(rexx_os,1))\n\n        /* Check OS and REXX interpreter */\n         select\n            when rexx_os = \"TSO\" then nop\n            when substr(rexx_interpreter,1,6) = \"REGINA\" then nop\n            otherwise do\n               say \"==>Error :\" ,\n                   \"Unsupported Rexx interpreter\" rexx_interpreter ,\n                   \"or unsupported operating system :\" rexx_os\n               say \" \"\n               exit_rc = 12\n               exit exit_rc\n            end /* end otherwise do  */\n         end /* end select */\n\n        /* --------------------------------------------------------- *\n         * If no option provided and ISPF is active then call the    *\n         * ISPF interface.                                           *\n         * --------------------------------------------------------- */\n         if length(option) <= 0 then do\n            if rexx_os = \"TSO\" then do\n               if sysvar('sysispf') = \"ACTIVE\" then do\n                  ret = 1\n                  cc = \"\"\n                  do forever\n                     cmd = \"\"\n                     Address ISPExec \"Display Panel(XML2COB)\"\n                     if rc > 4 then exit rc\n                     option = cmd\n                     i = time(\"R\")\n                     drop r rpt. nb_items total_items name. length. ,\n                          type. start_pos. occurs. sign. cob. ,\n                          cob_lines cobol_length nb_first_child ,\n                          profile round level01 verbose\n                     nb_items = 0\n                     total_items = 0\n                     name.0 = \"\"\n                     length.0 = 0\n                     type.0 = \"\"\n                     start_pos.0 = 0\n                     occurs.0 = 0\n                     sign.0 = \"\"\n                     cob.0 = \"\"\n                     cob_lines = 0\n                     cobol_length = 0\n                     nb_first_child = 0\n                     profile = \"\"\n                     round = \"\"\n                     level01 = \"\"\n                     verbose = \"\"\n                     r = 0\n                     rpt.1 = \"\"\n                     call do_it cmd\n                  end /* end do forever */\n               end /* end if sysvar('sysispf') = \"ACTIVE\"  */\n               else call exit_no_options\n            end /* end if rexx_os = \"TSO\"  */\n            else call exit_no_options\n         end /* end if length(option) <= 0  */\n\n         Do_It:\n        /* --------------------------------------------------------- *\n         * Parse the input parameters.                               *\n         * --------------------------------------------------------- */\n         option = \" \" || option\n         uopt = translate(option)\n         i = pos(\" XML \",uopt)\n         if i > 0 then option = overlay(\" XML \",option,i,5)\n         i = pos(\" COB \",uopt)\n         if i > 0 then option = overlay(\" COB \",option,i,5)\n         i = pos(\" PREFIX \",uopt)\n         if i > 0 then option = overlay(\" PREFIX \",option,i,8)\n         i = pos(\" ROUND \",uopt)\n         if i > 0 then option = overlay(\" ROUND \",option,i,7)\n         i = pos(\" LEVEL01 \",uopt)\n         if i > 0 then option = overlay(\" LEVEL01 \",option,i,9)\n         i = pos(\" BROWSE \",uopt)\n         if i > 0 then option = overlay(\" BROWSE \",option,i,8)\n         i = pos(\" VERBOSE \",uopt)\n         if i > 0 then option = overlay(\" VERBOSE \",option,i,9)\n         parse var option . \" COB \" cobol ,\n                          \" XML \" xml ,\n                          \" PREFIX \" prefix . 1\n         cobol= strip(cobol)\n         i = pos(\"PREFIX\",translate(xml))\n         if i > 0 then xml = overlay(\"      \",xml,i,50)\n         i = pos(\"ROUND\",translate(xml))\n         if i > 0 then xml = overlay(\"     \",xml,i,50)\n         i = pos(\"LEVEL01\",translate(xml))\n         if i > 0 then xml = overlay(\"     \",xml,i,50)\n         i = pos(\"BROWSE\",translate(xml))\n         if i > 0 then xml = overlay(\"      \",xml,i,6)\n         i = pos(\"VERBOSE\",translate(xml))\n         if i > 0 then xml = overlay(\"       \",xml,i,7)\n         xml = strip(xml)\n         prefix = translate(strip(prefix))\n         prefix = translate(prefix,\"-\",\"_\")\n\n        /* --------------------------------------------------------- *\n         * Test for round & level01                                  *\n         * --------------------------------------------------------- */\n         if wordpos(\"ROUND\",uopt) > 1 then round = \"Y\"\n         else round = \"N\"\n         if wordpos(\"LEVEL01\",uopt) > 1 then level01 = \"Y\"\n         else level01 = \"N\"\n\n        /* --------------------------------------------------------- *\n         * Test for verbose                                          *\n         * --------------------------------------------------------- */\n         if wordpos(\"VERBOSE\",uopt) > 1 then do\n            confirm = 1\n         end /* end if wordpos(\"VERBOSE\",uopt) > 1 */\n         else confirm = 0\n\n        /* --------------------------------------------------------- *\n         * Test for Browse                                           *\n         * --------------------------------------------------------- */\n         if rexx_os = \"TSO\" then do\n            if sysvar('sysispf') <> \"ACTIVE\" then browse = 0\n            else if wordpos(\"BROWSE\",uopt) > 1 then browse = 1\n                 else browse = 0\n         end /* end if rexx_os = \"TSO\"  */\n         else browse = 0\n\n        /* --------------------------------------------------------- *\n         * Setup the default variables                               *\n         * --------------------------------------------------------- */\n         parse value \"\" with null cobdd xmldd\n\n         if confirm >= 1 then do\n             call domsg \"XML to COBOL Copybook Conversion Utility.\" ,\n             \" Version:\" ver\n            call domsg \" \"\n         end /* end if confirm >= 1 */\n\n        /* --------------------------------------------------------- *\n         * Test that the cobol file doesn't already exist            *\n         *      or that the cobol dd is allocated                    *\n         *      or that the file can be opened                       *\n         * --------------------------------------------------------- */\n         select\n            when rexx_os <> \"TSO\" then do\n               if stream(cobol, \"C\", \"OPEN WRITE\") <> \"READY:\" then do\n                  call domsg \"==>Error :\" ,\n                             \"the COBOL file\" cobol \"can not be opened.\"\n                  exit_rc = 12\n                  signal done\n               end /* end if stream(cobol, \"C\", \"OPEN WRITE\") <> \"READY:\" */\n            end /* end when rexx_os <> \"TSO\" */\n            when translate(left(cobol,3)) = \"DD:\" then do\n               parse value cobol with \"DD:\" cobdd\n               x = listdsi(cobdd \"file\")\n               if x > 0 then do\n                  call domsg \"==>Error :\" ,\n                             \"the COBOL ddname\" cobdd \"can not be found.\"\n                  exit_rc = 12\n                  signal done\n               end /* end if x > 0  */\n            end /* end when translate(left(cobol,3)) = \"DD:\" */\n            when \"OK\" = sysdsn(cobol) then do\n               call domsg \"==>Error :\" ,\n                          \"The COBOL file currently exists.\" ,\n                          \"Please specify a file name to be created.\"\n               exit_rc = 12\n               signal done\n            end /* end when \"OK\"  sysdsn(cobol) */\n            otherwise\n         end /* end select */\n\n        /* --------------------------------------------------------- *\n         * Test that the XML file already exist                      *\n         *      or that the XML dd is allocated                      *\n         *      or that the file can be opened                       *\n         * --------------------------------------------------------- */\n         select\n           when rexx_os <> \"TSO\" then do\n               rc = stream(xml, \"C\", \"OPEN READ\")\n               if rc  <> \"READY:\" then do\n                  call domsg \"==>Error :\" ,\n                             \"the XML file\" xml \"can not be opened.\"\n                  exit_rc = 12\n                  signal done\n               end /* end if rc  <> \"READY:\" */\n            end /* end when rexx_os <> \"TSO\" */\n            when xml = null then do\n               call domsg \"==>Error : the XML file was not specified.\"\n               exit_rc = 12\n               signal done\n            end /* end when xml = null */\n            when translate(left(xml,3)) = \"DD:\" then do\n               parse value xml with \"DD:\" xmldd\n               x = listdsi(xmldd \"file\")\n               if x > 0 then do\n                  call domsg \"==>Error : \" ,\n                             \"the XML ddname\" xmldd \"can not be found.\"\n                  exit_rc = 12\n                  signal done\n               end /* end if x > 0 */\n            end /* end when translate(left(xml,3)) = \"DD:\" */\n            when \"OK\" <> sysdsn(xml) then do\n               call domsg \"==>Error : the XML file\" xml\n               call domsg sysdsn(xml)\n               exit_rc = 12\n               signal done\n            end /* end when \"OK\" <> sysdsn(xml) */\n            otherwise\n         end /* end select */\n\n        /* --------------------------------------------------------- *\n         * Alloc the XML file if needed                              *\n         * --------------------------------------------------------- */\n         if rexx_os = \"TSO\" then do\n            if xmldd = null then do\n               \"Alloc f(\"xml2dd\") shr ds(\"xml\") reuse\"\n            end /* end if xmldd = null */\n         end /* end if rexx_os = \"TSO\" */\n\n        /* --------------------------------------------------------- *\n         * Create the COBOL copybook                                 *\n         * --------------------------------------------------------- */\n          call do_cob\n\n        /* --------------------------------------------------------- *\n         * Now Report What We Did                                    *\n         * --------------------------------------------------------- */\n         if confirm >= 1 then do\n            call domsg    \" \"\n            if xmldd = null then\n               call domsg \"XML File:          \" xml\n            else\n               call domsg \"XML DD:            \" xmldd\n            if cobdd = null then\n               call domsg \"Cobol File:        \" cobol\n            else\n               call domsg \"Cobol DD:          \" cobdd\n            call domsg    \"Prefix:            \" prefix\n            call domsg    \"Round:             \" round\n            call domsg    \"Level01:           \" level01\n            call domsg    \" \"\n            call domsg    \"XML first child:   \" nb_first_child ,\n                          \"processed in\" substr(time(\"E\"),1,6) \"seconds\"\n            call domsg    \" \"\n            header.1 = \"+-\"\n            header.1 = insert(\"-\",header.1,length(header.1),5,\"-\")\n            header.1 = insert(\"-+-\",header.1,length(header.1),3)\n            header.1 = insert(\"-\",header.1,length(header.1),30,\"-\")\n            header.1 = insert(\"-+-\",header.1,length(header.1),3)\n            header.1 = insert(\"-\",header.1,length(header.1),5,\"-\")\n            header.1 = insert(\"-+-\",header.1,length(header.1),3)\n            header.1 = insert(\"-\",header.1,length(header.1),6,\"-\")\n            header.1 = insert(\"-+-\",header.1,length(header.1),3)\n            header.1 = insert(\"-\",header.1,length(header.1),4,\"-\")\n            header.1 = insert(\"-+-\",header.1,length(header.1),3)\n            header.1 = insert(\"-\",header.1,length(header.1),5,\"-\")\n            header.1 = insert(\"-+-\",header.1,length(header.1),3)\n            header.1 = insert(\"-\",header.1,length(header.1),6,\"-\")\n            header.1 = insert(\"-+\",header.1,length(header.1),2)\n            header.2 = \"] \"\n            header.2 = insert(\"Level\",header.2,length(header.2),5)\n            header.2 = insert(\" ] \",header.2,length(header.2),3)\n            header.2 = insert(\"Name\",header.2,length(header.2),30)\n            header.2 = insert(\" ] \",header.2,length(header.2),3)\n            header.2 = insert(\"Type\",header.2,length(header.2),5)\n            header.2 = insert(\" ] \",header.2,length(header.2),3)\n            header.2 = insert(\"Occurs\",header.2,length(header.2),6)\n            header.2 = insert(\" ] \",header.2,length(header.2),3)\n            header.2 = insert(\"Sign\",header.2,length(header.2),4)\n            header.2 = insert(\" ] \",header.2,length(header.2),3)\n            header.2 = insert(\"Start\",header.2,length(header.2),5)\n            header.2 = insert(\" ] \",header.2,length(header.2),3)\n            header.2 = insert(\"Length\",header.2,length(header.2),6)\n            header.2 = insert(\" ]\",header.2,length(header.2),2)\n            if total_items > 0 then do\n               call domsg    copies(\"=\",80)\n               call domsg    \" \"\n               call domsg    center(\"COBOL copybook created :\",80)\n               call domsg    \" \"\n               call domsg    header.1\n               call domsg    header.2\n               call domsg    header.1\n               do i = 1 to total_items\n                  if level.i = 0 then iterate\n                  line = \"] \"\n                  line = insert(level.i,line,length(line),5)\n                  line = insert(\" ] \",line,length(line),3)\n                  if length(copies(\" \",level.i-1) || name.i) <= 30 then ,\n                     line = insert(copies(\" \",level.i-1) || ,\n                                   name.i,line,length(line),30)\n                  else line = insert(copies(\" \",level.i-1) || ,\n                       substr(name.i,1,22) || \"...\",line,length(line),30)\n                  line = insert(\" ] \",line,length(line),3)\n                  line = insert(type.i,line,length(line),5)\n                  line = insert(\" ] \",line,length(line),3)\n                  line = insert(occurs.i,line,length(line),6)\n                  line = insert(\" ] \",line,length(line),3)\n                  line = insert(sign.i,line,length(line),4)\n                  line = insert(\" ] \",line,length(line),3)\n                  line = insert(start_pos.i,line,length(line),5)\n                  line = insert(\" ] \",line,length(line),3)\n                  line = insert(length.i,line,length(line),6)\n                  line = insert(\" ]\",line,length(line),2)\n                  call domsg line\n               end /* end do i = 1 to nb_items */\n               call domsg    header.1\n               call domsg    \" \"\n               call domsg    \"Total COBOL record length :\" cobol_length\n               call domsg    \" \"\n            end /* end if nb_items > 0 */\n         end /* end if confirm >= 1 then do */\n\n        /* --------------------------------------------------------- *\n         * Done so report out and leave                              *\n         * --------------------------------------------------------- */\n         Done:\n         if browse >= 1 & rexx_os = \"TSO\" then do\n            call msg \"off\"\n            if sysvar(\"syspref\") = null then hlq  = sysvar(\"sysuid\")\".\"\n            else hlq = null\n            browse_dsn = hlq\"XML2COB.report\"\n            \"Alloc f(\"dd\") ds(\"browse_dsn\") new spa(1,1) tr\",\n            \"recfm(v b) lrecl(255) blksize(0)\"\n            \"Execio * diskw\" dd \"(Finis stem rpt.\"\n            Address ISPExec \"Browse Dataset(\"browse_dsn\")\"\n            \"Free f(\"dd\")\"\n            \"Delete\" browse_dsn\n         end /* end if browse >= 1 & rexx_os = \"TSO\" */\n\n        /* free xml file */\n         if rexx_os = \"TSO\" then do\n            if xmldd = null then \"Free f(\"xml2dd\")\"\n         end /* end if rexx_os = \"TSO\" */\n\n         if ret = 1 then return\n         exit exit_rc\n\n          Do_COB:\n        /* --------------------------------------------------------- *\n         * Allocate the cobol file                                     *\n         * Space of cobol file = space of the XML file % 3             *\n         * Lrecl is set to the computed cobol length of the copybook *\n         * --------------------------------------------------------- */\n         if rexx_os = \"TSO\" then do\n            if cobdd = null then do\n               if pos(\"(\",cobol) <= 0 then do\n                  \"Alloc f(\"cob2dd\") new ds(\"cobol\") reuse tracks\"    ,\n                  \"recfm(f b) lrecl(80) spa(1,1) blksize(8000) release\"\n               end /* end if pos(\"(\",cobol) <= 0 */\n               else do\n                  if \"MEMBER NOT FOUND\" = sysdsn(cobol) then do\n                     \"Alloc f(\"cob2dd\") shr ds(\"cobol\") reuse\"\n                  end /* end if \"MEMBER NOT FOUND\" = sysdsn(cobol) */\n                  else do\n                     \"Alloc f(\"cob2dd\") new ds(\"cobol\") reuse tracks\" ,\n                     \"recfm(f b) lrecl(80) dir(20)\" ,\n                     \"spa(1,1) blksize(8000) release\"\n                  end /* end else do */\n               end /* end else do */\n            end /* end if cobdd = null */\n         end /* end if rexx_os = \"TSO\" */\n\n        /* initialize variables */\n         file_eof = 0\n         nb_first_child = 0   /* number of XML first child element */\n         cobol_length = 0     /* computed length of the cobol copybook */\n         current_level = 0    /* COBOL current level */\n         level_increment = 2  /* COBOL level increment */\n         nb_items = 0         /* number of COBOL items in copybook */\n         root = \"\"            /* name of the XML root element */\n         first_child  = \"\"    /* name of the XML first child element */\n         element = \"\"         /* one XML element */\n         attribute = \"\"       /* one XML attribute */\n         attributes = \"\"      /* all XML attributes of an XML element */\n         content = \"\"         /* content of one XML element */\n         call reset_XML_flags\n         do while file_eof = 0\n\n        /* read one record from XML file */\n            rc = 0\n            select\n               when rexx_os <> \"TSO\" then do\n                  if lines(xml) > 0 then xml.1 = linein(xml, ,1)\n                  else rc = 1\n               end /* end when rexx_os <> \"TSO\" */\n               when xmldd = null then \"Execio 1 diskr\" xml2dd \"(stem xml.\"\n               when xmldd <> null then \"Execio 1 diskr\" xmldd \"(stem xml.\"\n               otherwise\n            end /* end select */\n\n        /* if end of file then write copybook and exit */\n            if rc > 0 then do\n               file_eof = 1\n               rc=clean_copybook()\n               select\n                  when rexx_os <> \"TSO\" then ,\n                     rc = stream(xml, \"C\", \"CLOSE\")\n                  when xmldd = null then do\n                     \"Execio 0 diskr\" xml2dd \"(FINIS\"\n                     \"Free f(\"xml2dd\")\"\n                  end /* end when xmldd = null */\n                  when xmldd <> null then ,\n                     \"Execio 0 diskr\" xmldd \"(FINIS\"\n                  otherwise\n               end /* end select */\n               select\n                  when rexx_os <> \"TSO\" then do\n                     do i = 1 to cob_lines\n                        if i <= 1 then rc = lineout(cobol,cob.i,1)\n                        else rc = lineout(cobol,cob.i)\n                     end /* end do i = 1 to cob_lines */\n                     rc = stream(cobol, \"C\", \"CLOSE\")\n                  end /* end when rexx_os <> \"TSO\" */\n                  when cobdd = null then do\n                     \"Execio \" cob_lines \" diskw\" cob2dd \"(stem cob. FINIS\"\n                     \"Free f(\"cob2dd\")\"\n                  end /* end when cobdd = null */\n                  when cobdd <> null then ,\n                     \"Execio \" cob_lines \" diskw\" cobdd \"(stem cob. FINIS\"\n                  otherwise\n               end /* end select */\n            end /* end if rc > 0 */\n            else do\n\n        /* ------------------------------------------------------ *\n         * skip blank lines                                       *\n         * ------------------------------------------------------ */\n               xml.1 = strip(xml.1)\n               if length(xml.1) <= 0 then iterate\n\n        /* ------------------------------------------------------ *\n         * skip XML declaration and comments. Search for XML root *\n         * , XML first child and XML elements, attributes and     *\n         * content.                                               *\n         * ------------------------------------------------------ */\n               do i = 1 to length(xml.1)\n                  select\n\n        /* ------------------------------------------------------ *\n         * start of XML declaration <?                            *\n         * ------------------------------------------------------ */\n                     when XML_declaration <= 0 ,\n                          & substr(xml.1,i,2) = \"<?\" then do\n                          XML_declaration = 1\n                          i = i + 1\n                     end /* end when XML_declaration <= 0 , */\n\n        /* end of XML declaration ?> */\n                     when XML_declaration > 0 then do\n                          i = pos(\"?>\",xml.1,i)\n                          if i <= 0 then leave\n                          else do\n                             i = i + 1\n                             call reset_XML_flags\n                          end /* end else do */\n                     end /* end when XML_declaration > 0 */\n\n        /* ------------------------------------------------------ *\n         * start of XML entity <|ENTITY                           *\n         * ------------------------------------------------------ */\n                     when XML_entity <= 0 ,\n                          & substr(xml.1,i,8) = \"<|ENTITY\" then do\n                          call domsg \"==>Error :\" ,\n                               \"in the XML file, entity declaration\" ,\n                               \"is not supported.\"\n                          exit_rc = 12\n                          signal done\n                     end /* end when XML_entity <= 0 ,*/\n\n        /* end of XML entity */\n                     when XML_entity > 0 then do\n                          i = pos(\">\",xml.1,i)\n                          if i <= 0 then leave\n                          else do\n                             i = i + 1\n                             call reset_XML_flags\n                          end /* end else do */\n                     end /* end when XML_entity > 0 */\n\n        /* ------------------------------------------------------ *\n         * start of XML DOCTYPE <|DOCTYPE                         *\n         * ------------------------------------------------------ */\n                     when XML_DOCTYPE <= 0 & ,\n                          substr(xml.1,i,9) = \"<|DOCTYPE\" then do\n                          XML_DOCTYPE = 1\n                          if pos(\"\u00a2\",xml.1,i) > 0 then XML_DOCTYPE = 2\n                          i = i + 8\n                     end /* end when XML_DOCTYPE <= 0 & , */\n\n        /* end of XML DOCTYPE without DTD declaration > */\n                     when XML_DOCTYPE = 1 then do\n                          i = pos(\">\",xml.1,i)\n                          if i <= 0 then leave\n                          else call reset_XML_flags\n                     end /* end when XML_DOCTYPE = 1 */\n\n        /* end of XML DOCTYPE with inline DTD declaration > */\n                     when XML_DOCTYPE >= 2 then do\n                          i = pos(\"!>\",xml.1,i)\n                          if i <= 0 then leave\n                          else do\n                             i = i + 1\n                             call reset_XML_flags\n                          end /* end else do */\n                     end /* end when XML_DOCTYPE >= 2 */\n\n        /* ------------------------------------------------------ *\n         * start of XML comment <|--                              *\n         * ------------------------------------------------------ */\n                     when XML_comment <= 0 & substr(xml.1,i,4) = \"<|--\" ,\n                          then do\n                          XML_comment = 1\n                          i = i + 3\n                     end /* end when XML_comment <= 0 & substr(xml.1,i,4) */\n\n        /* end of XML comment --> */\n                     when XML_comment > 0 then do\n                          i = pos(\"-->\",xml.1,i)\n                          if i <= 0 then leave\n                          else do\n                             i = i + 2\n                             call reset_XML_flags\n                          end /* end else do */\n                     end /* end when XML_comment > 0 */\n\n        /* ------------------------------------------------------ *\n         * start of XML root element                              *\n         * ------------------------------------------------------ */\n                     when root = \"\" & XML_root <= 0 ,\n                          & substr(xml.1,i,1) = \"<\" then do\n                          XML_root = 1\n                      end /* end when root = \"\" & XML_root <= 0 , */\n\n        /* end of XML root element */\n                     when XML_root > 0 then do\n\n        /* XML root element end on this line ? */\n                          if pos(\">\",xml.1,i) > 0 then do\n                             k = pos(\">\",xml.1,i)\n                             l = k - i\n                             root = strip(root substr(xml.1,i,l))\n                             if words(root) >  1 then do\n                                call domsg ,\n                                \"==>Warning : \" ,\n                                \"XML attributes of root element\" ,\n                                word(root,1) \"are ignored.\"\n                                exit_rc = 04\n                             end /* end if words(root) >  1 */\n                             root = strip(word(root,1))\n                             i = pos(\">\",xml.1,i)\n                             call reset_XML_flags\n                          end /* end if pos(\">\",xml.1,i) > 0 */\n\n        /* else concatenate XML root element */\n                          else do\n                             root = root substr(xml.1,i)\n                             leave\n                          end /* end else do */\n                     end /* end when XML_root > 0 */\n\n        /* ------------------------------------------------------ *\n         * start of XML first_child element                       *\n         * ------------------------------------------------------ */\n                     when first_child = \"\" & XML_first_child <= 0 ,\n                          & substr(xml.1,i,1) = \"<\" & root <> \"\" then do\n                          XML_first_child = 1\n                          attributes = \"\"\n                      end /* end when first_child = \"\" & XML_first_child */\n\n        /* end of XML first_child element */\n                     when XML_first_child > 0 then do\n\n        /* XML first_child element end on this line ? */\n                          if pos(\">\",xml.1,i) > 0 then do\n                             k = pos(\">\",xml.1,i)\n                             l = k - i\n                             first_child = strip(first_child substr(xml.1,i,l))\n                             parse var first_child first_child attributes\n                             element = first_child\n                             nb_first_child = 1\n                             nb_items = 1\n                             current_level = 0\n                             if level01 = \"Y\" then ,\n                                current_level = 1 - level_increment\n                             rc = add_item(first_child,\"\")\n                             call do_XML_attribute\n                             i = pos(\">\",xml.1,i)\n                             call reset_XML_flags\n                             XML_content = 1\n                          end /* end if pos(\">\",xml.1,i) > 0 */\n\n        /* else concatenate XML first_child element */\n                          else do\n                             first_child = first_child substr(xml.1,i)\n                             leave\n                          end /* end else do */\n                     end /* end when XML_first_child > 0 */\n\n        /* ------------------------------------------------------ *\n         * start of XML element                                   *\n         * ------------------------------------------------------ */\n                     when XML_element <= 0 & substr(xml.1,i,1) = \"<\" & ,\n                          substr(xml.1,i,2) <> \"</\" ,\n                          & substr(xml.1,i,9) <> \"<|\u00a2CDATA\u00a2\" then do\n                          call reset_XML_flags\n                          XML_element = 1\n                          element = \"\"\n                          attributes = \"\"\n                     end /* end when XML_element <= 0 & substr(xml.1,i,1) */\n\n        /* end of XML element */\n                     when XML_element > 0 then do\n\n        /* XML element end on this line ? */\n                          if pos(\">\",xml.1,i) > 0 then do\n                             k = pos(\">\",xml.1,i)\n                             l = k - i\n                             element = strip(element substr(xml.1,i,l))\n                             parse var element element attributes\n                             rc = add_item(element,\"\")\n                             call do_XML_attribute\n\n        /* XML empty element ? */\n                             if substr(xml.1,k-1,2) = \"/>\" then do\n                                current_level = current_level - ,\n                                                level_increment\n                                i = k\n                                call reset_XML_flags\n                                iterate\n                             end /* end if substr(xml.1,k-1,2) = \"/>\" */\n\n                             i = pos(\">\",xml.1,i)\n                             call reset_XML_flags\n                             XML_content = 1\n                             content = \"\"\n                          end /* end if pos(\">\",xml.1,i) > 0 */\n\n        /* else concatenate XML element */\n                          else do\n                             element = element substr(xml.1,i)\n                             leave\n                          end /* end else do */\n                     end /* end when XML_element > 0 */\n\n        /* ------------------------------------------------------ *\n         * find the content of a XML element                      *\n         * ------------------------------------------------------ */\n                     when XML_content > 0 then do\n                          k = pos(\"</\",xml.1,i)\n\n        /* no closing tag on line ? continue on next line */\n                          if k <= 0 then do\n                             content = content substr(xml.1,i)\n                             leave\n                          end /* end if k <= 0 */\n                          else do\n                             l = k - i\n                             content = strip(content substr(xml.1,i,l))\n                          end /* end else do */\n                          call check_XML_content\n                          rc = add_item(element,content)\n                          i = pos(\"</\",xml.1,i) - 1\n                          drop content element\n                          call reset_XML_flags\n                          current_level = current_level - ,\n                                          level_increment\n                     end /* end when XML_content > 0 */\n\n        /* ------------------------------------------------------ *\n         * Start of child closing tag </                          *\n         * ------------------------------------------------------ */\n                     when XML_end_child <= 0 & ,\n                          substr(xml.1,i,2) = \"</\" then do\n                          XML_end_child = 1\n                          element = \"\"\n                          i = i + 1\n                     end /* end when XML_end_child <= 0 & , */\n\n        /* end of XML child closing tag > */\n                     when XML_end_child > 0 then do\n                          if pos(\">\",xml.1,i) > 0 then do\n                             k = pos(\">\",xml.1,i)\n                             l = k - i\n                             element = element substr(xml.1,i,l)\n                             element = strip(word(element,1))\n\n        /* Restart the analysis if we have reached the first child\n           closing tag */\n                             if element = first_child then do\n                                nb_first_child = nb_first_child + 1\n                                nb_items = 1\n                                current_level = 0\n                                if level01 = \"Y\" then ,\n                                   current_level = 1 - level_increment\n                             end /* end if element = first_child */\n                             else do\n                                current_level = current_level - ,\n                                                level_increment\n                             end\n                             i = pos(\">\",xml.1,i)\n                             call reset_XML_flags\n                          end /* end if pos(\">\",xml.1,i) > 0 */\n\n        /* else concatenate XML child closing tag */\n                          else do\n                             element = element substr(xml.1,i)\n                             leave\n                          end /* end else do */\n                     end /* end when XML_end_child > 0 */\n\n        /* ------------------------------------------------------ *\n         * In case of ...                                         *\n         * ------------------------------------------------------ */\n                     otherwise do\n                          call domsg \"==>Error :\" ,\n                               \"unable to convert the following chars :\" ,\n                               substr(xml.1,i,20)\n                          exit_rc = 12\n                          signal done\n                     end /* end otherwise do */\n                  end /* end select */\n               end /* end do i = 1 to length(xml.1) */\n            end /* end else do */\n         end /* end do while file_eof = 0 */\n\n        /* free COBOL file */\n      /* if rexx_os = \"TSO\" then do\n            if cobdd = null then \"Free f(\"cob2dd\")\"\n         end */ /* end if rexx_os = \"TSO\" */\n\n         return\n\n         DoMsg:\n        /* --------------------------------------------------------- *\n         * Issue Messages                                            *\n         * --------------------------------------------------------- */\n           parse arg msg\n           if confirm <= 0 then return\n           if browse <= 0 then say msgid msg\n           else do\n              r = r + 1\n              rpt.r = msg\n           end /* end else do */\n           return\n\n         reset_XML_flags:\n        /* --------------------------------------------------------- *\n         * Reset XML flags                                           *\n         * --------------------------------------------------------- */\n\n           XML_declaration = 0\n           XML_DOCTYPE = 0\n           XML_comment = 0\n           XML_root = 0\n           XML_first_child = 0\n           XML_element = 0\n           XML_attribute = 0\n           XML_end_child = 0\n           XML_content = 0\n           XML_entity = 0\n\n           return\n\n         do_XML_attribute:\n        /* --------------------------------------------------------- *\n         * Converting attribute value to text                        *\n         * --------------------------------------------------------- */\n           if length(attributes) > 0 then do\n              XML_attribute = 1\n              start_pos = 0\n              end_pos = 0\n              temp1 = strip(attributes)\n              if right(temp1,1) = \"/\" then ,\n                 temp1 = left(temp1,length(temp1)-1)\n              temp1 = temp1 || \" \"\n\n         /* Search attributes and content*/\n              do b = 1 to length(temp1)\n                 if substr(temp1,b,1) <> \" \" ,\n                    & start_pos <= 0 then start_pos = b\n                 if substr(temp1,b,2) = '\" ' | ,\n                    substr(temp1,b,2) = \"' \" then do\n                    end_pos = b + 1\n                    temp2 = substr(temp1,start_pos,end_pos-start_pos)\n                    if substr(temp2,length(temp2),1) = \"/\" then ,\n                       temp2 = substr(temp2,1,length(temp2)-1)\n                    if pos(\"=\",temp2) <= 0 then do\n                       call domsg ,\n                          \"==>Error: equal sign not found in attribute :\" ,\n                          temp2\n                       exit_rc = 12\n                       signal done\n                    end /* end if pos(\"=\",temp2) <= 0 */\n                    attribute = substr(temp2,1,pos(\"=\",temp2)-1)\n\n         /* Skip XML specials attributes */\n                    if translate(substr(attribute,1,3)) = \"XML\" then do\n                       start_pos = 0\n                       end_pos = 0\n                       iterate\n                    end /* end if translate(substr(attribute,1,3)) = \"XML\" */\n                    content = substr(temp2,pos(\"=\",temp2)+2)\n                    content = substr(content,1,length(content)-1)\n                    call check_XML_content\n                    rc = add_item(attribute,content)\n                    current_level = current_level - level_increment\n                    start_pos = 0\n                    end_pos = 0\n                 end /* end if substr(temp1,b,2) = '\" ' | , */\n              end /* end do b = 1 to length(temp1) */\n              XML_attribute = 0\n           end /* end if words(element) > 1 */\n           drop b content attribute temp1 temp2 start_pos end_pos\n\n           return\n\n         check_XML_content:\n        /* --------------------------------------------------------- *\n         * Check XML content before transfering it to the output     *\n         * record.                                                   *\n         * --------------------------------------------------------- */\n        /* scan content for CDATA */\n           if pos(\"<|\u00a2CDATA\u00a2\",content) > 0 then do\n              k = pos(\"<|\u00a2CDATA\u00a2\",content)\n              k = k + length(\"<|\u00a2CDATA\u00a2\")\n              l = pos(\"!!>\",content)\n              content = substr(content,k,l-k)\n           end /* end if pos(\"<|\u00a2CDATA\u00a2\",content) > 0  */\n\n        /* scan content for escaping characters */\n           else\n           if (pos(\"&amp;\",content) > 0 | ,\n              pos(\"&lt;\",content) > 0 | ,\n              pos(\"&gt;\",content) > 0 | ,\n              pos(\"&apos;\",content) > 0 | ,\n              pos(\"&quot;\",content) > 0 | ,\n              pos(\"&#\",content) > 0)  then\n              do k = 1 to length(content)\n                 k = pos(\"&\",content,k)\n                 l = pos(\";\",content,k)\n                 temp = translate(substr(content,k+1,l-k-1))\n                 select\n                    when temp = \"AMP\" then symbole = \"&\"\n                    when temp = \"LT\" then symbole = \"<\"\n                    when temp = \"GT\" then symbole = \">\"\n                    when temp = \"QUOT\" then symbole = '\"'\n                    when temp = \"APOS\" then symbole = \"'\"\n                    when substr(temp,1,1) = \"#\" then do\n                       temp1 = substr(temp,2)\n                       if left(temp1,1) = \"X\" then ,\n                          symbole = x2c(substr(temp1,2))\n                       else symbole = d2c(temp1)\n                       call domsg ,\n                          \"==>Warning : character reference:\" temp ,\n                          \"encountered in escaped characters.\"\n                       exit_rc = 04\n                       drop temp1\n                    end /* end when substr(temp,1,1) = \"#\" */\n                    otherwise do\n                       call domsg ,\n                         \"==>Error: unknown escaping character\" ,\n                          \"&\" || symbole || \";\" ,\n                          \"encounterd.\"\n                       exit_rc = 12\n                       signal done\n                    end /* end otherwise do */\n                 end /* end select */\n                 if k > 1 then temp1 = substr(content,1,k-1)\n                 else temp1 = \"\"\n                 temp2 = substr(content,k+length(temp)+2)\n                 content = temp1 || symbole || temp2\n                 drop temp1 temp2 temp symbole\n                 if pos(\"&\",content,k) <= 0 | ,\n                    pos(\";\",content,k) <= 0 then leave\n           end /* end if (pos(\"&amp;\",content) > 0 | */\n\n           return\n\n         add_item: procedure expose(globals)\n        /* --------------------------------------------------------- *\n         * Add COBOL item in array                                   *\n         *                                                           *\n         * Parameter(s) : element (required)                         *\n         *                content (optional)                         *\n         *                                                           *\n         * --------------------------------------------------------- */\n           parse arg element, content\n           old_msgid = msgid\n           msgid = msgid || \"add_item():\"\n\n        /* Check that element parameter is filled */\n           if length(element) <= 0 then do\n              call domsg \"==>Error :\" ,\n                         \"Element parameter must be filled\"\n              call domsg \"Parameter values when the error occured:\"\n              call domsg \"element       :\" element\n              call domsg \"content       :\" content\n              exit_rc = 12\n              signal done\n           end /* end if length(element) <= 0 */\n\n        /* Check element type */\n           if datatype(element) <> \"CHAR\" then do\n              call domsg \"==>Error :\" ,\n                         \"Element (\" element \") name is not valid\"\n              call domsg \"Parameter values when the error occured:\"\n              call domsg \"element       :\" element\n              call domsg \"content       :\" content\n              exit_rc = 12\n              signal done\n           end /* end if datatype(element) <> \"CHAR\"*/\n\n           if nb_items <= 0 then nb_items = 1\n           item = translate(strip(element))\n           item = translate(item,\"-\",\"_\")\n           if left(item,length(prefix)) = prefix then ,\n              item = substr(item,length(prefix)+1)\n\n        /* Check that item name is not a reserved word */\n           if wordpos(item, reserved_words) > 0 then do\n              call domsg \"==>Warning :\" ,\n                         \"Item (\" item \") name is a COBOL reserved word\"\n              call domsg \"Parameter values when the error occured:\"\n              call domsg \"element       :\" element\n              call domsg \"content       :\" content\n              exit_rc = 04\n           end /* end if wordpos(item, reserved_words) > 0  */\n\n        /* Check that COBOL level is never greater than 50 */\n           current_level = current_level + level_increment\n           if current_level > 50 then do\n              call domsg \"==>Error :\" ,\n                         \"COBOL level (\" current_level item ,\n                         \") is greater than 50. Aborting\"\n              call domsg \"Parameter values when the error occured:\"\n              call domsg \"element       :\" element\n              call domsg \"content       :\" content\n              exit_rc = 12\n              signal done\n           end /* end if current_level >= 50 */\n\n        /*===========================================================\n           First round : first \"XML first child\", then insert\n           meta-data of all XML elements found\n          ===========================================================*/\n           if nb_first_child <= 1 then do\n\n        /* add FILLER item if no content. If content is detected later\n           a COBOL item will then be added with the name of the XML\n           element at a lower level. By this way, if attributes are\n           present, they will appear before the content of the XML\n           element and if the element has no content, it will never\n           appear in the COBOL copybook */\n              level.nb_items = current_level\n              type.nb_items = \"\"\n              length.nb_items = 0\n              sign.nb_items = \"N\"\n\n              if length(content) <= 0 then ,\n                 name.nb_items = \"FILLER-\" || item\n              else do\n                 name.nb_items = item\n                 temp = translate(content,\".\",\",\")\n                 if datatype(temp)= \"NUM\" then do\n                    type.nb_items = \"NUM\"\n                    select\n                       when left(content,1) = \"+\" then sign.nb_items = \"LS\"\n                       when left(content,1) = \"-\" then sign.nb_items = \"LS\"\n                       when right(content,1) = \"+\" then sign.nb_items = \"TS\"\n                       when right(content,1) = \"-\" then sign.nb_items = \"TS\"\n                       otherwise sign.nb_items = \"N\"\n                    end /* end select */\n                 end /* end if datatype(temp)= \"NUM\" */\n                 else type.nb_items = \"CHAR\"\n                 length.nb_items = length(content)\n\n        /* round length if needed */\n                 if round =\"Y\" & length.nb_items > 0 then do\n                    j = length.nb_items\n                    if j >= 10 then j = right(j,length(j)-1)\n                    select\n                       when j <= 5    then j = 5\n                       when j <= 10   then j = 10\n                       when j <= 15   then j = 15\n                       when j <= 20   then j = 20\n                       when j <= 25   then j = 25\n                       when j <= 30   then j = 30\n                       when j <= 35   then j = 35\n                       when j <= 40   then j = 40\n                       when j <= 45   then j = 45\n                       when j <= 50   then j = 50\n                       when j <= 55   then j = 55\n                       when j <= 60   then j = 60\n                       when j <= 65   then j = 65\n                       when j <= 70   then j = 70\n                       when j <= 75   then j = 75\n                       when j <= 80   then j = 80\n                       when j <= 85   then j = 85\n                       when j <= 90   then j = 90\n                       when j <= 95   then j = 95\n                       when j <= 100  then j = 100\n                       when j <= 125  then j = 125\n                       when j <= 150  then j = 150\n                       when j <= 200  then j = 200\n                       when j <= 250  then j = 250\n                       when j <= 300  then j = 300\n                       when j <= 350  then j = 350\n                       when j <= 400  then j = 400\n                       when j <= 450  then j = 450\n                       when j <= 500  then j = 500\n                       when j <= 600  then j = 600\n                       when j <= 700  then j = 700\n                       when j <= 800  then j = 800\n                       when j <= 900  then j = 900\n                       when j <= 1000 then j = 1000\n                       otherwise nop\n                   end /* end select */\n                   if length.nb_items < 10 then length.nb_items = j\n                   else length.nb_items =left(length.nb_items,1) || j\n                 end /* end if round =\"Y\"  */\n              end /* end else do */\n              m = nb_items + 1\n              total_items = nb_items\n              nb_items = nb_items + 1\n           end /* end if nb_first_child <= 1 */\n\n        /*===========================================================\n           Second round : other \"first child\" in XML file, then insert\n           meta-data of all new XML elements found ...\n          ===========================================================*/\n           else do\n              if length(content) <= 0 then item = \"FILLER-\" || item\n              if level.nb_items <> current_level | ,\n                 name.nb_items <> item | ,\n                 nb_items > total_items then do\n                 do j = total_items + 1 to nb_items + 1 by -1\n                    k = j - 1\n                    name.j = name.k\n                    level.j = level.k\n                    type.j = type.k\n                    length.j = length.k\n                    sign.j = sign.k\n                 end /* end do j = total_items + 1 to nb_items by -1 */\n                 name.nb_items = \"\"\n                 level.nb_items = 0\n                 type.nb_items = \"\"\n                 length.nb_items = 0\n                 sign.nb_items = \"N\"\n                 total_items = nb_items + 1\n              end /* end if level.nb_items <> current_level |  */\n\n        /*===========================================================\n          ... and/or update meta-data\n         ===========================================================*/\n              name.nb_items = item\n              level.nb_items = current_level\n              if length(content) > 0 then do\n                 temp = translate(content,\".\",\",\")\n                 if datatype(temp)= \"CHAR\" & type.nb_items = \"NUM\" then ,\n                    type.nb_items = \"CHAR\"\n                 if type.nb_items = \"NUM\" then do\n                    select\n                       when sign.nb_items = \"LS\" then nop\n                       when sign.nb_items = \"TS\" then nop\n                       when left(content,1) = \"+\" then sign.nb_items = \"LS\"\n                       when left(content,1) = \"-\" then sign.nb_items = \"LS\"\n                       when right(content,1) = \"+\" then sign.nb_items = \"TS\"\n                       when right(content,1) = \"-\" then sign.nb_items = \"TS\"\n                       otherwise sign.nb_items = \"N\"\n                    end /* end select */\n                 end /* end if type.nb_items = \"NUM\" */\n              end /* end if length(content) > 0  */\n              if length(content) > length.nb_items then ,\n                 length.nb_items = length(content)\n\n        /* round length if needed */\n                 if round =\"Y\" & length.nb_items > 0 then do\n                    j = length.nb_items\n                    if j >= 10 then j = right(j,length(j)-1)\n                    select\n                       when j <= 5    then j = 5\n                       when j <= 10   then j = 10\n                       when j <= 15   then j = 15\n                       when j <= 20   then j = 20\n                       when j <= 25   then j = 25\n                       when j <= 30   then j = 30\n                       when j <= 35   then j = 35\n                       when j <= 40   then j = 40\n                       when j <= 45   then j = 45\n                       when j <= 50   then j = 50\n                       when j <= 55   then j = 55\n                       when j <= 60   then j = 60\n                       when j <= 65   then j = 65\n                       when j <= 70   then j = 70\n                       when j <= 75   then j = 75\n                       when j <= 80   then j = 80\n                       when j <= 85   then j = 85\n                       when j <= 90   then j = 90\n                       when j <= 95   then j = 95\n                       when j <= 100  then j = 100\n                       when j <= 125  then j = 125\n                       when j <= 150  then j = 150\n                       when j <= 200  then j = 200\n                       when j <= 250  then j = 250\n                       when j <= 300  then j = 300\n                       when j <= 350  then j = 350\n                       when j <= 400  then j = 400\n                       when j <= 450  then j = 450\n                       when j <= 500  then j = 500\n                       when j <= 600  then j = 600\n                       when j <= 700  then j = 700\n                       when j <= 800  then j = 800\n                       when j <= 900  then j = 900\n                       when j <= 1000 then j = 1000\n                       otherwise nop\n                   end /* end select */\n                   if length.nb_items < 10 then length.nb_items = j\n                   else length.nb_items =left(length.nb_items,1) || j\n                 end /* end if round =\"Y\"  */\n              m = nb_items + 1\n              nb_items = nb_items + 1\n           end /* end else do */\n\n           msgid = old_msgid\n           return 0\n\n         drop_item: procedure expose(globals)\n        /* --------------------------------------------------------- *\n         * Remove COBOL item in array                                *\n         *                                                           *\n         * Parameter(s) : item_nbr       (required, item number)     *\n         *                                                           *\n         * --------------------------------------------------------- */\n           parse arg item_nbr\n           old_msgid = msgid\n           msgid = msgid || \"drop_item():\"\n\n        /* Check that item_nbr parameter is filled */\n           if length(item_nbr) <= 0 then do\n              call domsg \"==>Error :\" ,\n                         \"Item_nbr parameter must be filled\"\n              call domsg \"Parameter value when the error occured:\"\n              call domsg \"item_nbr       :\" item_nbr\n              exit_rc = 12\n              signal done\n           end /* end if length(item_nbr) <= 0 */\n\n        /* Check item_nbr type */\n           if datatype(item_nbr) <> \"NUM\" then do\n              call domsg \"==>Error :\" ,\n                         \"Item number (\" item_nbr \") is not numeric. Aborting\"\n              call domsg \"Parameter value when the error occured:\"\n              call domsg \"item_nbr       :\" item_nbr\n              exit_rc = 12\n              signal done\n           end /* end if datatype(item_nbr) <> \"CHAR\"*/\n\n        /* Check item_nbr is not greater than total_items */\n           if item_nbr > total_items then do\n              call domsg \"==>Error :\" ,\n                         \"Item number (\" item_nbr \") is greater than \",\n                         \"the total number of items (\" total_items \")\"\n              call domsg \"Parameter value when the error occured:\"\n              call domsg \"item_nbr       :\" item_nbr\n              exit_rc = 12\n              signal done\n           end /* end if item_nbr > total_items */\n\n        /* Check item_nbr is not lower than 1 */\n           if item_nbr < 1 then do\n              call domsg \"==>Error :\" ,\n                         \"Item number (\" item_nbr \") is lower than 1\"\n              call domsg \"Parameter value when the error occured:\"\n              call domsg \"item_nbr       :\" item_nbr\n              exit_rc = 12\n              signal done\n           end /* end if item_nbr > total_items */\n\n           do i = item_nbr to total_items - 1\n              j = i + 1\n              name.i = name.j\n              level.i = level.j\n              type.i = type.j\n              length.i = length.j\n              sign.i = sign.j\n              occurs.i = occurs.j\n           end /* end do i = item_nbr to total_items - 1 */\n           drop name.total_items\n           drop level.total_items\n           drop type.total_items\n           drop length.total_items\n           drop sign.total_items\n           drop occurs.total_items\n           total_items = total_items - 1\n\n           msgid = old_msgid\n           return 0\n\n         clean_copybook: procedure expose(globals)\n        /* --------------------------------------------------------- *\n         * Clean the COBOL copybook generated                        *\n         *                                                           *\n         * --------------------------------------------------------- */\n           old_msgid = msgid\n           msgid = msgid || \"clean_copybook():\"\n\n        /* Step 1 : suppressing unnecessary \"FILLER-\" levels */\n           do i = 1 to total_items - 2\n              j = i + 1\n              k = i + 2\n              if level.i >= level.k & ,\n                 substr(name.i,8) = name.j & ,\n                 left(name.i,7) = \"FILLER-\" & ,\n                 left(name.k,7) = \"FILLER-\" then do\n                 level.j = level.i\n                 rc = drop_item(i)\n              end /* end if level.i = level.k & , */\n           end /* end do i = 1 to total_items - 2 */\n           i = total_items - 1\n           j = total_items\n           if left(name.i,7) = \"FILLER-\" & ,\n              left(name.j,7) <> \"FILLER-\" then do\n              level.j = level.i\n              rc = drop_item(i)\n           end /* end if left(name.i,7) = \"FILLER-\" */\n\n        /* Step 2 : Handling elementary occurs */\n           do i = 1 to total_items\n              occurs.i =  1\n              do j = i + 1 to total_items\n                 if level.i = level.j & ,\n                    name.i = name.j & ,\n                    length.i = length.j & ,\n                    type.i = type.j then do\n                       occurs.i = occurs.i + 1\n                       if length.j > length.i then length.i = length.j\n                       rc = drop_item(j)\n                       j = j - 1\n                       if j <= 0 then j = 1\n                 end /* end if level.i = level.j & , */\n                 else leave\n              end /* end do j = i + 1 to total_items */\n           end /* end do i = 1 to total_items */\n\n        /* Step 3: Handling group occurs */\n           do i = 1 to total_items\n              if occurs.i > 1 then iterate\n              occurs.i = 1\n              interval = 0\n              temp = level.i || name.i\n\n        /* Find next occurence of group item */\n              do j = i + 1 to total_items\n\n        /* leave when an item is not part of the group */\n                 if level.i = level.j & name.i <> name.j then leave\n                 if level.i > level.j then leave\n\n        /* a new occurence of a group item is found | */\n                 if level.i = level.j & ,\n                    name.i = name.j & ,\n                    length.i = length.j & ,\n                    type.i = type.j then do\n                    if interval <= 0 then interval = j - i\n                    occurs.i = occurs.i + 1\n                 end /* end if level.i = level.j & , */\n                 else\n                    if interval <= 0 then temp = temp level.j || name.j\n              end /* end do j = i to total_items */\n\n        /* A group occurence has been found ? Suppress all\n           others occurrences */\n              if interval > 0 then do\n                 k = i\n                 do j = i + interval to total_items\n\n        /* leave when an item is not part of the group */\n                    if level.i = level.j & name.i <> name.j then leave\n                    if level.i > level.j then leave\n\n        /* Set length to the maximum length of each occurence of the\n           item in the group */\n                    if length.j > length.k & ,\n                       level.j = level.k & ,\n                       name.j = name.k then length.k = length.j\n\n        /* restart analysis from the start of the group if the end\n           of the group is reached */\n                    k = k + 1\n                    if level.k = level.i & name.k = name.i then k = i\n\n        /* suppress multiple occurence of the group item  */\n                    if wordpos(level.j || name.j, temp) > 0 then do\n                       rc = drop_item(j)\n                       j = j - 1\n                       if j <= 0 then j = 1\n                    end /* end if wordpos(level.j || name.j, temp) > 0 */\n                    else temp = temp level.j || name.j\n                 end /* end do j = i + interval to total_items */\n                 i = j - 1\n              end /* end if interval > 0 */\n           end /* end do i = 1 to total_items */\n\n        /* Step 4: Suppressing \"FILLER-\" prefix in item name */\n           do i = 1 to total_items\n              if left(name.i,7) = \"FILLER-\" then name.i = substr(name.i,8)\n           end /* end do i = 1 to total_items */\n\n        /* Step 5: Computing starting positions of COBOL items */\n           start_pos.1 = 1\n           do i = 1 to total_items\n\n       /* Multiple occurences of a group item */\n              if occurs.i > 1 & length.i <= 0 then do\n                 group_length = 0\n                 do k = i + 1 to total_items\n                    if level.k <= level.i then leave\n                    j = k - 1\n                    group_length = group_length + length.k\n                    start_pos.k = start_pos.j + length.j\n                 end /* end do while level.k > level.i */\n                 start_pos.k = start_pos.i + group_length * occurs.i\n                 i = k - 1\n              end /* end if occurs.i > 1 & length.i <= 0 */\n\n       /* Multiple occurences of an elementary item */\n              else if occurs.i > 1 & length.i > 0 then do\n                 j = i + 1\n                 start_pos.j = start_pos.i + length.i * occurs.i\n              end /* end if occurs.i > 1 & length.i > 0 */\n\n       /* Single occurence of an elementary item */\n              else do\n                 j = i + 1\n                 start_pos.j = start_pos.i + length.i\n              end /* end if occurs.i > 1 & length.i > 0 */\n           end /* end do i = 1 to total_items */\n           k = total_items + 1\n           cobol_length = start_pos.k - 1\n\n        /* Step 6: building COBOL copybook records */\n           cob_lines = 1\n\n        /* Header */\n           cob.cob_lines = copies(\" \",6) || \"*\"  || copies(\"-\",63)\n           cob_lines = cob_lines + 1\n           cob.cob_lines = copies(\" \",6) || \"* \"\n           cob_lines = cob_lines + 1\n           cob.cob_lines = copies(\" \",6) || \"* \" ,\n                           \"Created by XML2COB on\" date(\"N\") \"at\" time(\"N\")\n           cob_lines = cob_lines + 1\n           cob.cob_lines = copies(\" \",6) || \"* \"\n           cob_lines = cob_lines + 1\n           cob.cob_lines = copies(\" \",6) || \"* \" ,\n                           \"More info on :\" ,\n                           \"http://sourceforge.net/projects/txt2xml-rexx/\"\n           cob_lines = cob_lines + 1\n           cob.cob_lines = copies(\" \",6) || \"* \"\n           cob_lines = cob_lines + 1\n           cob.cob_lines = copies(\" \",6) || ,\n                           \"*  Total COBOL record length : \" || ,\n                           cobol_length\n           cob_lines = cob_lines + 1\n           cob.cob_lines = copies(\" \",6) || \"* \"\n           cob_lines = cob_lines + 1\n           cob.cob_lines = copies(\" \",6) || \"*\"  || copies(\"-\",63)\n           cob_lines = cob_lines + 1\n           cob.cob_lines = \"\"\n           cob_lines = cob_lines + 1\n           do i = 1 to total_items\n\n        /* Level and name  */\n              if level.i = 0 & name.i = \"\" then iterate\n              if level.i <= 9 then level.i = \"0\" || level.i\n              j = (level.i - level_increment) % level_increment\n              if j <= 0  then j = 0\n              if level01 = \"Y\" & i > 1 then j = j + 1\n              cob.cob_lines = copies(\" \",10) || ,\n                              copies(\"   \",j) || ,\n                              level.i || ,\n                              \" \" || ,\n                              name.i\n              cob_lines = cob_lines + 1\n\n        /* Picture */\n              if length.i > 0 then do\n                 picture = \"9\"\n                 if type.i <> \"NUM\" then picture = \"X\"\n                 j = cob_lines - 1\n                 if length(cob.j) < 50 then do\n                     cob.j = cob.j || copies(\" \",50-length(cob.j))\n                     cob.j = cob.j || ,\n                             \"PICTURE \" || ,\n                              picture || ,\n                              \"(\" || ,\n                              length.i || ,\n                              \")\"\n                 end /* end if length(cob.j) <= 50 */\n                 else do\n                    cob.cob_lines = copies(\" \",50) || ,\n                                    \"PICTURE \" || ,\n                                    picture || ,\n                                    \"(\" || ,\n                                    length.i || ,\n                                    \")\"\n                    cob_lines = cob_lines + 1\n                 end /* end else do */\n              end /* end if length.i > 0 */\n\n        /* sign */\n              if sign.i <> \"N\" then do\n                 signe = \"SIGN IS LEADING SEPARATE\"\n                 if sign.i = \"TS\" then signe = \"SIGN IS TRAILING SEPARATE\"\n                 j = cob_lines - 1\n                 if length(cob.j) < 50 then do\n                     cob.j = cob.j || copies(\" \",50-length(cob.j))\n                     cob.j = cob.j || \"   \" || signe\n                 end /* end if length(cob.j) <= 50 */\n                 else do\n                    cob.cob_lines = copies(\" \",50) || \"   \" || signe\n                    cob_lines = cob_lines + 1\n                 end /* end else do */\n              end /* end if sign.i <> \"N\" */\n\n        /* occurs */\n              if occurs.i > 1 then do\n                 j = cob_lines - 1\n                 if length(cob.j) < 50 then do\n                     cob.j = cob.j || copies(\" \",50-length(cob.j))\n                     cob.j = cob.j || ,\n                             \"   \" || ,\n                             \"OCCURS \" || ,\n                             occurs.i || ,\n                             \" TIMES\"\n                 end /* end if length(cob.j) <= 50 */\n                 else do\n                    cob.cob_lines = copies(\" \",50) || ,\n                                    \"   \" || ,\n                                    \"OCCURS \" || ,\n                                    occurs.i || ,\n                                    \" TIMES\"\n                    cob_lines = cob_lines + 1\n                 end /* end else do */\n              end /* end if occurs.i > 1 */\n\n        /* Final period */\n              j = cob_lines - 1\n              cob.j = cob.j || \".\"\n           end /* end do i = 1 to total_items */\n           cob.cob_lines = \" \"\n\n           msgid = old_msgid\n           return 0\n\n         exit_no_options:\n        /* --------------------------------------------------------- *\n         * Exit with error messages when no options are specified    *\n         * --------------------------------------------------------- */\n           say \"==>Error: XML2COB requires a minimum of XML and\" ,\n               \"COB keywords and values.\"\n           say \" \"\n           say \"XML2COB is a REXX script that converts XML files\"\n           say \"into COBOL copybook.\"\n           say \" \"\n           say \"XML2COB Syntax:\"\n           say \" \"\n           say \"XML2COB XML xml-ds\"\n           say \"        COB cob-ds\"\n           say \"        PREFIX prefix\"\n           say \"        ROUND\"\n           say \"        LEVEL01\"\n           say \"        VERBOSE\"\n           say \"        BROWSE\"\n           say \" \"\n\n        /* --------------------------------------------------------- *\n         * Trying to start Java gui front end                        *\n         * --------------------------------------------------------- */\n           if rexx_os <> \"TSO\" then do\n              say \"Trying to start JAVA GUI front-end ...\"\n              \"java -jar xml2cob.jar\"\n           end /* end if rexx_os <> \"TSO\" */\n           exit_rc = 12\n           exit exit_rc\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT685/CBT.V500.FILE685.PDS/EXEC.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT685/CBT.V500.FILE685.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}