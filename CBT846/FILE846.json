{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012933000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 529074, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 10, "INMDSNAM": "CBT.V500.FILE846.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 529074, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 529074, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE846.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\t\\x0f'", "DS1TRBAL": "b'Ev'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x05\\xd2\\x00\\x0e\\x05\\xd3\\x00\\x08\\x00\\n'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00\\x06\\x01 4o\\x01 4o\\x15%\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf5\\xf0\\xf0@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "2020-12-11T00:00:00", "modifydate": "2020-12-11T15:25:06", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-500"}, "text": "REGULAR CBT TAPE - VERSION 500    FILE:  846\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT500.FILE846\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 29 MEMBERS COUNTED; CUMULATIVE SIZE IS 4,349 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   12/11/20    15:25:06    UTC-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$CLIP01": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x03\\x00\\x18\\x01 \\x04\\x0f\\x01 \\x04\\x1f\\x15$\\x00+\\x00'\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@\"", "ispf": {"version": "01.03", "flags": 0, "createdate": "2020-02-09T00:00:00", "modifydate": "2020-02-10T15:24:18", "lines": 43, "newlines": 39, "modlines": 0, "user": "SBGOLOB"}, "text": "    Purpose of being able to CLIP (change the volser of) a disk pack\n                          while it is ONLINE\n\n\n    IBM allows you to use the ICKDSF program to change the volume\n    serial of a disk pack while it is offline.  But they don't give\n    you a program to change the volume serial of a pack when it is\n    online.  There may be several reasons for that.\n\n    IBM has to worry about more situations than we have to worry\n    about.\n\n    If you change the volser of a pack while it is online, the new\n    volser does not take effect right away.  You first have to take\n    it offline, and then you have to bring it online again.  Then,\n    the new volser will be in effect.\n\n    But here is at least one situation in which it is helpful to be\n    able to change the volser of a pack while it is online.\n\n1.  A particular pack went bad, and the operators restored that volser\n    from a backup onto a volser that was \"higher\" in collating sequence\n    of UCB addresses than the original pack, which was still online.\n\n    The pack that was online could not be forced offline for a number\n    of production-related reasons.  An IPL, to put the new pack\n    online, would not take effect properly, because the volser of the\n    bad pack was lower.  (Maybe now, it would be OK, with the later\n    operating system improvements.  At IPL you now have a better\n    choice, of which pack, of duplicate volsers, that you want to\n    keep online.\n\n    The surest solution would be to rename the bad pack so it would not\n    be in effect after the IPL, and the restored pack would be the one\n    that you'd get online with no ambiguity.\n\n2.  You could use Fullscreen ZAP from CBT File 300 for this, but this\n    is a programmatic solution that takes the guesswork out of the\n    process.  And it can be set up to be done by an operator.  Very\n    often, the systems programmers set up a procedure for the operators\n    that doesn't require much effort on their part, provided there is\n    a program which drives the procedure.  ONLCLIP is such a program.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE01": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00C\\x01\\x11\\x06\\x8f\\x01\\x11\\x06\\x8f\\x10\\x19\\x00/\\x00/\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2011-03-09T00:00:00", "modifydate": "2011-03-09T10:19:43", "lines": 47, "newlines": 47, "modlines": 0, "user": "SBGOLOB"}, "text": "A few notes about using the TRK0**** set of programs.\n\nTRK0SAVE will back up the IPL text (if it exists) on a disk volume.\nDCB attributes of the backup dataset are:\n\n  RECFM=U,LRECL=0,BLKSIZE=32760\n\nEach backed up Track 0 record will contain count, key, and data\nfields.  See their description in the notes below.\n\nA snippet of the beginning of the records for a pack containing\nIPL text follows:  This is from a TRK0SAVE backup.\n\n-----------*--------------------------------------------------------\n000001         IPL1    \u00d8  !  \u00a2q-  -  \u00a2q\n       00000001CDDF000080050049600600490000\n       0000140897310800001A60A8000080A80000\n-----------*--------------------------------------------------------\n000002        \u00b0IPL2  \u00a2\u00bd      \u00a2\u00b4      \u00a2\u00b5           \u00ed\n       00000009CDDF004B4000304B4000004A00000000202500000000000000000\n       00002400973270A8000610AE000580A00000600000F500000000004000000\n-----------*--------------------------------------------------------\n000003        \u00ca    \u00d8       00         \u00d8\n       00000017000080034444FF440000000800000000000000000000000000000\n       000040A208000062000000000000003000000000000000000000000000000\n-----------*--------------------------------------------------------\n\nNote that record 3 is not backed up.  See where the * is, to note\nthe record number of the backed up record in hex.  This is in the\n\"count\" field.\n\nDescription of backed up record format.....\n\n    The format written by these program does NOT\n  match what ICKDSF write IPLTEXT ABSFORMAT expects.\n\n  ABSFORMAT wants three or more undefined records.\n  The first must be 24 ( X'18' ) bytes.\n  The second must be 144 ( X'90' ) bytes.\n  The others are written after the volume label as is.\n\n  These programs include count and key fields so:\n  The first must be 36 bytes ( C+K+D 8+4+24 ).\n  The second must be 156 bytes ( C+K+D 8+4+144 ).\n  Others are eight bytes larger than data for the\n  count field.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE02": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\"\\x01 \\x13/\\x01 \\x13/\\t9\\x00=\\x00=\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-05-11T00:00:00", "modifydate": "2020-05-11T09:39:22", "lines": 61, "newlines": 61, "modlines": 0, "user": "SBGOLOB"}, "text": "Recent change to the ONLCLIP program.\n\nThe most recent change to the ONLCLIP program was a cosmetic\nchange, to put a comment at the beginning of the program, as\nan eyecatcher, letting the installer know what kind of RACF\nprotection the program has.\n\nIn order to run the program with RACF protection, there needs\nto be defined a FACILITY class profile, called TBCXTUL.  And\nthe program needs READ access to this profile.  The error\nmessage in the program does not tell you the kind of RACF\nprotection which the program ONLCLIP has.  So we put an eye-\ncatcher at the beginning of the program, so that if you Browse\nthe load module, you can figure out the type of RACF protection\nthat is needed.\n\nThe following is a LISTMOD dump of the ONLCLIP module, to show\nthe eyecatcher:   (LISTMOD - TSO command - is on CBT File 994.)\n\nLoaded Program Name:  ONLCLIP\n-----------------------------------------------------------------\nModule has been LOADED. CDE Address: 009880D0\nLength of loaded module Hex:  000013A8    Decimal:        5032\nLength after entry address :  000013A8    Decimal:        5032\nDisplacement of entry point:  00000000    Decimal:           0\n-----------------------------------------------------------------\n\n 00  ONLCLIP.05/11/20.02.56   }  00  -Needs FACILITY class profi   00000000\n4FF11DDDCDCD4FF6FF6FF4FF4FF09ED04FF546D888A4CCCCDCEE4898AA499988\n700C66533397B05111120B02B5600C0C70080055542061393938033122079669\n0---+---+---+---1---+---+---+---2---+---+---+---3---+---+---+---\n\nle TBCXTUL, READ access- { -&{} &}{       H     &   ( {@  Ou       00000040\n984ECCEEED64DCCC48888AA64CF65CD05DC01D1C47C0477051C741C783DA0100\n3503237343B095140133522010B0000800048C8F1080108000F0D00C0F64A370\n0---+---+---+---1---+---+---+---2---+---+---+---3---+---+---+---\n\n\nIn case the installer wants to bypass RACF protection completely,\nthere is a NOP instruction (currently at +200, but you have to\ncheck the current source for the exact location), which can be\nchanged to a B (unconditional branch) instruction, and this will\ncompletely bypass the RACROUTE instructions in the program.\nSo the 4700 at that location has to be changed to 47F0, and this\nwill bypass the RACF protection entirely.\n\nLISTMOD dump of ONLCLIP at +200.\n\n  D   B                                                            00000200\n40C041C700000000060000400000000004B40000000000070000000004000000\n7040502000000000084003000000000000C40000000000000000000000000000\n0---+---+---+---1---+---+---+---2---+---+---+---3---+---+---+---\n\nYou change the 4700 at +200 to 47F0.\n\nAMASPZAP control cards:\n\n NAME ONLCLIP  ONLCLIP\n VER  0200 4700\n REP  0200 47F0\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE846": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00R\\x01 4o\\x01 4o\\x15$\\x00@\\x00@\\x00\\x00\\xc3\\xc2\\xe3`\\xf5\\xf0\\xf0@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "2020-12-11T00:00:00", "modifydate": "2020-12-11T15:24:52", "lines": 64, "newlines": 64, "modlines": 0, "user": "CBT-500"}, "text": "//***FILE 846 is from somitcw and contains programs to do EXCP for  *   FILE 846\n//*           DASD.  Programs beginning with TRK0*** deal with      *   FILE 846\n//*           saving and restoring IPL text on a disk volume.       *   FILE 846\n//*                                                                 *   FILE 846\n//*           So you can move IPL text from one volume              *   FILE 846\n//*           to another.  (Nice technique to have.)                *   FILE 846\n//*                                                                 *   FILE 846\n//*           Program EOFDISK will clear disk tracks in the         *   FILE 846\n//*           extents of a sequential dataset.                      *   FILE 846\n//*                                                                 *   FILE 846\n//*       Addition of program ONLCLIP \"Online CLIP\" to change       *   FILE 846\n//*           the volser of a disk pack while it is online.         *   FILE 846\n//*           Needs READ access to RACF FACILITY class profile      *   FILE 846\n//*           TBCXTUL (CBT backwards, X, TUL for tools).            *   FILE 846\n//*       New program ONLCLEAR which blanks out the user area       *   FILE 846\n//*           which is the last 64 bytes (the identification        *   FILE 846\n//*           part) of Track 0, Record 3.                           *   FILE 846\n//*           Needs READ access to RACF FACILITY class profile      *   FILE 846\n//*           TBCXTUL (CBT backwards, X, TUL for tools).            *   FILE 846\n//*                                                                 *   FILE 846\n//*       Description of TRK0SAVE, TRK0UPD.                         *   FILE 846\n//*                                                                 *   FILE 846\n//*           TRK0SAVE will copy Records 1, 2, 4, and the           *   FILE 846\n//*           rest of the records on Track 0 (Record 3 is the       *   FILE 846\n//*           volume id, so it isn't copied) to an external data    *   FILE 846\n//*           set.  TRK0UPD will take this output and reload Track  *   FILE 846\n//*           0 of a target volume with this unloaded IPL text.     *   FILE 846\n//*                                                                 *   FILE 846\n//*           For completeness, Sam Golob followed somitcw's lead   *   FILE 846\n//*           and wrote a program to REMOVE IPL text, called        *   FILE 846\n//*           TRK0INIT.  This program will erase the IPL text       *   FILE 846\n//*           from a disk pack.  IT MUST BE USED WITH EXTREME       *   FILE 846\n//*           CAUTION !!!  See warning below, how to avoid          *   FILE 846\n//*           problems.                                             *   FILE 846\n//*                                                                 *   FILE 846\n//*       below    - - - - - W A R N I N G - - - - -                *   FILE 846\n//*                                                                 *   FILE 846\n//*     >>>>  If you are erasing the IPL text off a disk pack,      *   FILE 846\n//*     >>>>  you should please make sure that you back it up       *   FILE 846\n//*     >>>>  first, using TRK0SAVE.  Then you can restore it       *   FILE 846\n//*     >>>>  later with TRK0UPD.                                   *   FILE 846\n//*                                                                 *   FILE 846\n//*       above    - - - - - W A R N I N G - - - - -                *   FILE 846\n//*                                                                 *   FILE 846\n//*           Sam Golob has added a program to this collection      *   FILE 846\n//*           called TR02ABS, along with JCL to run it.  This       *   FILE 846\n//*           program CONVERTS IPLTEXT that is in TRK0SAVE          *   FILE 846\n//*           format to IPLTEXT in ICKDSF ABSFORMAT, so that it     *   FILE 846\n//*           can be loaded using ICKDSF, without needing to        *   FILE 846\n//*           use the TRK0UPD program from this file.               *   FILE 846\n//*                                                                 *   FILE 846\n//*           Added source code for the AWSTAPIN program, which     *   FILE 846\n//*           I plagiarized to create the TR02ABS program. Since    *   FILE 846\n//*           AWSTAPIN is nowhere on the CBT Tape, I put it here    *   FILE 846\n//*           for safekeeping.  I think it was once on the          *   FILE 846\n//*           Hercules-390 Yahoogroups files, but those get         *   FILE 846\n//*           purged quite often, when the capacity is exceeded.    *   FILE 846\n//*           The author of AWSTAPIN turned out to be David         *   FILE 846\n//*           Cartwright.  And I rang him up, to thank him.         *   FILE 846\n//*                                                                 *   FILE 846\n//*           email:  somitcw@yahoo.com                             *   FILE 846\n//*                                                                 *   FILE 846\n//*           email:  sbgolob@cbttape.org                           *   FILE 846\n//*                                                                 *   FILE 846\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "AWSTAPIN": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x005\\x01\\x01\\x03?\\x01\\x01\\x03?\\x14\"\\x00R\\x00R\\x00\\x00\\xd4\\xd4\\xe2\\xd4\\xc1\\xd2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-02-02T00:00:00", "modifydate": "2001-02-02T14:22:35", "lines": 82, "newlines": 82, "modlines": 0, "user": "MMSMAK"}, "text": "TAPECONV TITLE 'Convert file to AWSTAPE format'\n*---------------------------------------------------------------------*\n* Function:                                                           *\n*        This program converts a tape file to AWSTAPE format.         *\n*        It reads undefined length blocks of data from SYSUT1 and     *\n*        writes each block, prefixed by a 6-byte header, to SYSUT2.   *\n*---------------------------------------------------------------------*\nTAPECONV CSECT\n         LR    R12,R15                  Load base register\n         USING TAPECONV,R12             Establish addressability\n         OPEN  (SYSUT1,INPUT)           Open input DCB\n         TM    SYSUT1+48,X'10'          Is DCB open?\n         BZ    EXIT020                  No, exit with RC=20\n         OPEN  (SYSUT2,OUTPUT)          Open output DCB\n         TM    SYSUT2+48,X'10'          Is DCB open?\n         BZ    EXIT020                  No, exit with RC=20\nGENLOOP  EQU   *\n         GET   SYSUT1                   Get input block\n         LR    R2,R1                    R2=>input block\n         LH    R4,SYSUT1+82             R4=actual block length\n         MVC   HDRPRVLN,HDRCURLN        Copy previous block length\n         STCM  R4,B'0001',HDRCURLN      Store low-order length byte\n         STCM  R4,B'0010',HDRCURLN+1    Store high-order length byte\n         MVI   HDRFLAG1,HDRF1BOR+HDRF1EOR  Set complete record flags\n         MVC   SYSUT2+82(2),=H'6'       Set header length in DCB\n         PUT   SYSUT2,HEADER            Write block header to SYSUT2\n         STH   R4,SYSUT2+82             Set block length in DCB\n         PUT   SYSUT2,(R2)              Write data block to SYSUT2\n         B     GENLOOP                  Go back for next record\nGENEOF   DS    0H\n         MVC   HDRPRVLN,HDRCURLN        Copy previous block length\n         XC    HDRCURLN,HDRCURLN        Clear current block length\n         MVI   HDRFLAG1,HDRF1TMK        Set tape mark flag\n         MVC   SYSUT2+82(2),=H'6'       Set header length in DCB\n         PUT   SYSUT2,HEADER            Write block header to SYSUT2\n         CLOSE (SYSUT1,,SYSUT2)         Close DCBs\n         SR    R15,R15                  Zeroize return code\n         SVC   3                        Exit with RC=0\nEXIT020  DS    0H\n         LA    R15,20                   DD statement missing\n         SVC   3                        Exit with RC=20\n         DROP  R12                      Drop base register\n*\n* AWSTAPE block header\n*\nHEADER   DS    0CL6                     Block header\nHDRCURLN DC    XL2'0000'                Current block length\nHDRPRVLN DC    XL2'0000'                Previous block length\nHDRFLAG1 DC    X'00'                    Flags byte 1...\nHDRF1BOR EQU   X'80'                    ...beginning of record\nHDRF1TMK EQU   X'40'                    ...tape mark\nHDRF1EOR EQU   X'20'                    ...end of record\nHDRFLAG2 DC    X'00'                    Flags byte 2\n*\n* Data Control Blocks\n*\n         PRINT NOGEN\nSYSUT1   DCB   DSORG=PS,MACRF=GL,DDNAME=SYSUT1,EODAD=GENEOF,           X\n               RECFM=U,LRECL=0,BLKSIZE=32760\nSYSUT2   DCB   DSORG=PS,MACRF=PM,DDNAME=SYSUT2,                        X\n               RECFM=U,LRECL=0,BLKSIZE=32760\n         LTORG\n*\n* Register equates\n*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "EOFDISK": {"ttr": 529, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x11\\x04/\\x01\\x11\\x04/\\x01\\x12\\x01\\xfd\\x01\\xfd\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2011-02-11T00:00:00", "modifydate": "2011-02-11T01:12:00", "lines": 509, "newlines": 509, "modlines": 0, "user": "SOMITCW"}, "text": "//HERC01E JOB (XXXXXXXX,XXXX,1439,9999,9999),EOFDISK-HERC01,\n//             COND=(0,NE),\n//             MSGCLASS=C,CLASS=A,NOTIFY=HERC01\n//ASMFCL  EXEC PROC=ASMFCL,PARM.LKED='AC=1'  AC=1 needed for PARM=NULL\n//SYSLIB   DD\n//         DD  DISP=SHR,DSN=SYS1.AMODGEN for MVS 3.8j\n//*        DD  DISP=SHR,DSN=SYS1.MODGEN OS/390 and zOS may want instead\nPASS     TITLE 'EOFDISK - - - Program to clear disk tracks'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n* Change log:\n*\n* 2011-01-01 - PARM=NULL without EMPTY changed to not null the\n*  somitcw   - track after the last data record.  There should\n*  be an end-of-file record on that track.\n*\n* 2010-12-26 - PARM=NULL added to erase all records on tracks.\n*  somitcw   - No EOF record will be written if PARM=NULL specified.\n* No PARM will write EOF record tracks after end-of-file.\n* PARM=NULL will erase tracks after end-of-file.\n* PARM=EMPTY will write EOF records on all tracks in the data set.\n* PARM=(EMPTY,NULL) will erase all tracks in the data set.\n* PARM=NULL requires APF authorization to update the DEB to allow\n* re-writing record zero to clear the remainder of the track.\n*\n* 2007-05-24 - PARM=EMPTY requirement added to empty data sets.\n* Greg Price - The default is to only empty tracks after end-of-file.\n*\n*    This program writes End-Of-File records on disk tracks by\n* writing record one as an end-of-file record or\n* erases all data on a track by writing record zero.\n*\n*    This program handles multiple extents.\n*\n*    This program should handle any type of disk.\n*\n*    This program is slow because it writes one track at at time.\n*    This program should write a cylinder at a time, but I was lazy.\n*\n*    This program works on data sets so does not right\n* for pds members.\n*\n*    QSAM and BSAM put an end-of-file record on the track\n* after the last data if there is a track after the last data.\n* When using PARM=NULL without EMPTY, this program will not\n* null that track because the end-of-file record is needed.\n*\n*    If using for Hercules CCKD disk volumes to shrink the\n* the size of the disk image file:\n*\n* 1. Use the default of EOF for old CCKD disk image files.\n*    By old, I mean created from before 2004 like MVS Tur(n)key #3.\n* 2. Use PARM=NULL or PARM=(NULL,EMPTY) for newer CCKD disk volumes.\n* 3. After running, you may need to wait minutes, hours, days, weeks,\n* months, or years for the CCKD garbage collector to shrink the disk\n* image file.\n* For immediate shrinking, use Hercules console command: sfc cccu\n* Yes, I know that the disk image file is not a shadow file, but\n* sfc will work on it anyway.\n*\n* Sample JCLs:\n*\n* //HERC01E  JOB (XXXXXXXX,XXXX,1439,9999,9999),EOFDISKJ-HERC01,\n* //             MSGCLASS=C,\n* //             CLASS=A,NOTIFY=HERC01\n* //*\n* //* This will erase the largest 25 free\n* //*   space extents on a disk volume.\n* //* If less than 21 extents on the disk volume, the JOB will\n* //*   get a JCL error after all extents are cleared.\n* //*\n* //EOFDISK1 EXEC PGM=EOFDISK,PARM=NULL\n* //OUTPUT  DD  UNIT=SYSDA,VOL=SER=PUB001,\n* // SPACE=(TRK,1,,ALX),DISP=(,PASS)\n* //EOFDISK2 EXEC PGM=EOFDISK,PARM=NULL\n* //OUTPUT  DD  UNIT=SYSDA,VOL=SER=PUB001,\n* // SPACE=(TRK,1,,ALX),DISP=(,PASS)\n* //EOFDISK3 EXEC PGM=EOFDISK,PARM=NULL\n* //OUTPUT  DD  UNIT=SYSDA,VOL=SER=PUB001,\n* // SPACE=(TRK,1,,ALX),DISP=(,PASS)\n* //EOFDISK4 EXEC PGM=EOFDISK,PARM=NULL\n* //OUTPUT  DD  UNIT=SYSDA,VOL=SER=PUB001,\n* // SPACE=(TRK,1,,ALX),DISP=(,PASS)\n* //EOFDISK5 EXEC PGM=EOFDISK,PARM=NULL\n* //OUTPUT  DD  UNIT=SYSDA,VOL=SER=PUB001,\n* // SPACE=(TRK,1,,ALX),DISP=(,PASS)\n*\n* //HERC01E  JOB (XXXXXXXX,XXXX,1439,9999,9999),EOFDSET-HERC01,\n* //             MSGCLASS=C,\n* //             CLASS=A,NOTIFY=HERC01\n* //*\n* //* This will erase the unused tracks of a PDS or\n* //*   sequential data set while preserving data.\n* //*\n* //EOFDISK  EXEC PGM=EOFDISK,PARM=NULL\n* //OUTPUT   DD  DISP=OLD,DSN=A.REAL.DATA.SET\n* //*\n*\n* //HERC01E  JOB (XXXXXXXX,XXXX,1439,9999,9999),EMPTYSEQ-HERC01,\n* //             MSGCLASS=C,\n* //             CLASS=A,NOTIFY=HERC01\n* //*\n* //* This will empty and erase a sequential data set.\n* //* ( Note that a PDS processed this way will be unusable. )\n* //*\n* //EOFDISK  EXEC PGM=EOFDISK,PARM=(NULL,EMPTY)\n* //OUTPUT   DD  DISP=OLD,DSN=A.SEQ.DATA.SET\n* //\n*\n* Blame: somitcw @ yahoo.com\n*\n* Empty Blame: Greg. Price\n*              at\n*              optushome. com. au\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n         MACRO\n         REGS  ,\n         LCLA  &NUMBER\n.LOOP    ANOP\nR&NUMBER EQU   &NUMBER            Register equate for register &NUMBER\n&NUMBER  SETA  &NUMBER+1\n         AIF   (16 GT &NUMBER).LOOP\n         MEND\n*\n         PRINT ON,GEN,DATA        Always print everything\nEOFDISK  CSECT ,\n         USING *,R15              Set temporary base register\n         SAVE  (14,12),,EOFDISK.&SYSDATE..&SYSTIME  Save Reg.s\n         LA    R12,SAVEAREA       Load address of new save area\n         ST    R12,8(,R13)        Connect old and new save areas\n         ST    R13,4(,R12)        Connect old and new save areas\n         LR    R13,R12            Connect old and new save areas\n         DROP  R15                Drop the temporary base register\n         LR    R12,R15            Load the program's base register\n         USING EOFDISK,R12        Give the assembler the new base\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      Process program parameter if specified\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n         L     R1,0(,R1)          Point to the program parameter\n         CLC   H0,0(R1)           Any parameter?\n         BE    PARMOK             No, that's fine\n         CLC   H4,0(R1)           Possible PARM=NULL length\n         BE    PARM4              Yes, go set flag for PARM=NULL\n         CLC   H5,0(R1)           Possible PARM=EMPTY length\n         BE    PARM5              Yes, go set flag for PARM=EMPTY\n         CLC   H10,0(R1)          Possible PARM='EMPTY,NULL' length\n         BE    PARM10             Yes, go set flag for PARM=EMPTY\n         BNE   PARMBAD            No, non-valid PARM length\nPARM4    DS    0H\n         CLC   2(4,R1),PARMNUEM   Expected PARM=NULL\n         BNE   PARMBAD            No, go give error message and bomb\n         OI    FLAG,NULL          Flag NULL request\n         B     PARMNULL           Go update CCW string for PARM=NULL\nPARM5    DS    0H\n         CLC   2(5,R1),PARMEMNU   Expected PARM=EMPTY\n         BNE   PARMBAD            No, go give error message and bomb\n         OI    FLAG,EMPTY         Flag EMPTY request\n         B     PARMOK             Go to main part of program\nPARM10   DS    0H\n         CLC   2(10,R1),PARMEMNU  See if PARM=(EMPTY,NULL)\n         BE    PARMBOTH           Yes, go set flag for both\n         CLC   2(10,R1),PARMNUEM  See if PARM=(NULL,EMPTY)\n         BNE   PARMBAD            No, go give error message and bomb\n*        B     PARMBOTH           Yes, go set flag for both\nPARMBOTH DS    0H\n         OI    FLAG,EMPTY+NULL    Set flag for both NULL and EMPTY\nPARMNULL DS    0H\n         MVC   CCW(8),CCWSHA      Update the CCW string for PARM=NULL\n         MVC   CCW+16(8),CCWWR0   Update the CCW string for PARM=NULL\nPARMOK   DS    0H                 Parameter processing complete\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      Locate the TIOT entry for the OUTPUT file\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n         L     R4,540             Point to the current TCB ?PSATOLD?\n         L     R4,12(,R4)         Point to the TIOT ?TCBTIO?\n         LA    R4,24(,R4)         Point to first TIOT entry\n         SLR   R5,R5              Prepare for insert\nTIOTLOOP DS    0H\n         CLI   0(R4),0            Reached end of TIOT?\n         BE    NODD               Yes, required file not allocated\n         CLC   4(8,R4),DCB+DCBDDNAM-IHADCB\n         BE    GOTTIOTE           Found the right TIOT entry\n         IC    R5,0(,R4)          Get TIOT entry length\n         AR    R4,R5              Point to the next TIOT entry\n         B     TIOTLOOP           Go check it out\nGOTTIOTE DS    0H\n         ICM   R5,7,17(R4)        Point to the UCB\n         BZ    NOTDASD            No UCB means can't be DASD\n         CLI   18(R5),X'20'       DASD?\n         BNE   NOTDASD            No, not much more to do here\n         MVC   VOLSER,28(R5)      Yes, copy the Volume Serial Number\n*        CLI   VOLSER,C' '        VIO?\n*        BNH   NOTDASD            Yes, don't bother\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      Determine the data set name of the OUTPUT file\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n         RDJFCB SAMDCB            Copy the JFCB to working storage\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      Obtain the VTOC entry\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n         OBTAIN OBTAIN            Fetch the VTOC entry\n         LTR   R15,R15            Success?\n         BNZ   OBTAINER           No, OBTAIN failed, go abend with msg.\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      Prevent destruction of formatted SYSCTLG\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n         CLC   =CL8'SYSCTLG ',JFCBDSNM  See if DSN=SYSCTLG\n         BNE   NOTCVOL            No, then not an active OS catalog\n         CLC   =X'0000FF',DS1LSTAR  See if VTOC says CVOL is formated\n         BE    ISCVOL             Is a formated CVOL, go abend with msg\nNOTCVOL  DS    0H\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      Determine the number of used tracks\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n         SLR   R10,R10            Clear a work register\n         ICM   R10,7,DS1LSTAR     Ascertain last addressable record\n         BZ    GOTTRKS            Empty data set\n         SRL   R10,8              Shift out R to convert TTR to TT\n         LA    R10,2(,R10)        Relative to track number + EOF track\nGOTTRKS  DS    0H\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      Empty the data set if requested by parameter\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n         TM    FLAG,EMPTY         EMPTY requested?\n         BNO   EMPTYOK            No, preserve any data if PS or PO\n         LTR   R10,R10            Empty according to VTOC?\n         BZ    EMPTYOK            Yes, no need for extra I/O\n         OPEN  (SAMDCB,OUTPUT)    No, so overwrite data...\n         CLOSE SAMDCB             ... with EOF mark\n         LA    R10,1              Preserve track with EOF record\nEMPTYOK  DS    0H                 EMPTY processing complete\n         ST    R10,KEEPTRKS       Save number of tracks to preserve\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      Perform main processing\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n         OPEN  (DCB,OUTPUT)       Open the file to be cleared\n         L     R10,DCB+DCBDVTBL-IHADCB  Load Dev.Char.Table Address\n         MVC   TRACKS,2(R10)      Save number of tracks on a cylinder\n         L     R10,DCB+DCBDEBAD-IHADCB  Load DEB address\n         SLR   R9,R9              Clear extent counter\n         IC    R9,16(,R10)        Load the number of extents\n         LA    R7,0               Set initial extent number\nNEXTEXTN DS    0H\n         LTR   R9,R9              See if no more extents\n         BZ    ENDOFJOB           If not, go return to caller\n         BCTR  R9,0               Subtract one from extent number\n*  Calculate the Extent\n         LR    R10,R7             Load the extent number\n         SLL   R10,4              Multiply by 16 for displacement\n         LA    R10,32(,R10)       Add DEB header length to displacement\n         A     R10,DCB+DCBDEBAD-IHADCB  Add the base DEB address\n         TM    FLAG,NULL          See if record zero must be written\n         BNO   SAVEEXT            No, go save the extent CCHH\n         MODESET KEY=ZERO         Must update DEB\n         OI    0(R10),X'C0'       Change extent to allow Write Record 0\n         MODESET KEY=NZERO        Switch back to normal key\nSAVEEXT  DS    0H                 *\n         MVC   CCHH,6(R10)        Set seek for beginning of extent\n         STC   R7,SEEK            Set extent number\n         LA    R7,1(,R7)          Bump extent number\nKEEPCHK  DS    0H\n         ICM   R1,15,KEEPTRKS     Get track count still to skip\n         BZ    WRITE              Do not skip any more tracks\n         BCTR  R1,0               Decrement track-to-keep count\n         ST    R1,KEEPTRKS        Save updated count\n         B     TRKDONE            Do not clear this track\nWRITE    DS    0H\n         MVC   COUNTEOF(4),CCHH   Set COUNT CCHH incase PARM isn't NULL\n         MVC   COUNTNUL(4),CCHH   Set COUNT CCHH incase PARM=NULL\n         XC    ECB,ECB            Ensure that the ECB is clear\n         EXCP  IOB                Write record, EOF or new record zero\n         WAIT  ECB=ECB            Wait for the write to complete\n         CLI   ECB,X'7F'          See if a good write\n         BNE   IOERROR            If not good, go abend\nTRKDONE  DS    0H\n* Last track is cleared, next track number is needed\n         CLC   CCHH,10(R10)       See if at end of an extent\n         BNL   NEXTEXTN           If at end, go find next extent\n         ICM   R8,3,HH            Load current track number\n         LA    R8,1(,R8)          Bump to the next track\n         CLM   R8,3,TRACKS        See if past last track on a cylinder\n         BNL   NEWCYL             If past cyl. end, go to next cylinder\n         STCM  R8,3,HH            Store the new track number\n         B     KEEPCHK            Go to write the next record\n*\nNEWCYL   DS    0H\n         ICM   R8,3,CC            Load the current cylinder number\n         LA    R8,1(,R8)          Bump to the next cylinder\n         STCM  R8,3,CC            Save the new cylinder number\n         XC    HH,HH              Clear the track number\n         B     KEEPCHK            Go to write the next record\n*\nENDOFJOB DS    0H\n         CLOSE DCB                Close the file\n         SLR   R15,R15            Success\nRETURN   DS    0H\n         L     R13,4(,R13)        Restore the caller's save area addr.\n         RETURN (14,12),RC=(15)   Return to caller\n         EJECT ,\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      Error messages and abend routines\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\nPARMBAD  DS    0H\n         WTO  'EOFDISK - PARM other than EMPTY or NULL specified',     +\n               ROUTCDE=11\n         BAL   R11,ABENDING       Issue \"program abending WTO\"\n         ABEND 1111               Abend with a U1111, no DUMP, no STEP\n*\nNODD     DS    0H\n         WTO   'EOFDISK - Required //OUTPUT DD is missing',ROUTCDE=11\n         BAL   R11,ABENDING       Issue \"program abending WTO\"\n         ABEND 1112               Abend with a U1112, no DUMP, no STEP\n*\nNOTDASD  DS    0H\n         WTO   'EOFDISK - OUTPUT DD points to a non-DASD',ROUTCDE=11\n         BAL   R11,ABENDING       Issue \"program abending WTO\"\n         ABEND 1113               Abend with a U1113, no DUMP, no STEP\n*\nOBTAINER DS    0H                 OBTAIN error\n         STC   R15,OBTAINRC       Store OBTAIN's return code\n         UNPK  WTO20RC(3),OBTAINRC(2)  Convert return code to display\n         TR    WTO20RC,HEX-C'0'   Show OBTAIN return code (in hex)\n         MVI   WTO20RC+2,C' '     Clear byte after return code\n         MVC   WTO20VOL,VOLSER    Show Volume Serial Number\n         WTO   MF=(E,WTO20)       Issue message\n         WTO   'EOFDISK - Does data set exist on disk?',ROUTCDE=11\n         BAL   R11,ABENDING       Issue \"program abending WTO\"\n         ABEND 1114               Abend with a U1114, no DUMP, no STEP\n*\nISCVOL   DS    0H\n         WTO   'EOFDISK - Will not clear a formated SYSCTLG',          +\n               ROUTCDE=(2,9,11)\n         BAL   R11,ABENDING       Issue \"program abending WTO\"\n         ABEND 1115               Abend with a U1115, no DUMP, no STEP\n*\nIOERROR  DS    0H\n         WTO   'EOFDISK - I/O error, Program abending',ROUTCDE=11\n         BAL   R11,ABENDING       Issue \"program abending WTO\"\n         ABEND 1116,DUMP          Abend with a U1116, DUMP, no STEP\n*\nABENDING DS    0H\n         WTO   'EOFDISK - Program abending',ROUTCDE=11\n         BR    11                 Return to error routine\n         EJECT ,\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      DCB's, IOB'S, ECB, and CCW's\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n         PRINT ON,GEN,DATA        Always print everything\nSAMDCB   DCB   DDNAME=OUTPUT,DSORG=PS,MACRF=(WP),EXLST=EXITLIST\nDCB      DCB   DDNAME=OUTPUT,     DD name                              X\n               DSORG=PS,          Data Set Organization                X\n               MACRF=E            MACRO Reference is EXCP\nDCBLEN   EQU   *-DCB              Length of DCB\n         PRINT ON,GEN,DATA        Always print everything\nIOB      DS    0D                 Input/output Block\n         DC    XL4'40000000'      Command chaining used\n         DC    A(ECB)             Address of the ECB\nCSW      DC    D'0'               Channel Status Word\n         DC    A(CCW)             Address of the channel command string\n         DC    A(DCB)             Address of the Data Control Block\n         DC    A(0)               IOB Restart\n         DC    XL4'0'             Flags and Counters\nSEEK     DC    D'0'               Seek address\nSEARCH   EQU   SEEK+3,5           Cylinder, Head, and Record to search\nCCHH     EQU   SEEK+3,4           Cylinder and Head to seek to\nCC       EQU   SEEK+3,2           Cylinder to seek\nHH       EQU   SEEK+5,2           Track to seek to\nR        EQU   SEEK+7,1           Record to search for\nCCW      CCW   X'31',SEARCH,X'40',5 Search for record before one writen\n         CCW   8,*-8,0,0          TIC back until search complete\n         CCW   X'1D',COUNTEOF,0,8 Write the EOF record\n*\nCCWSHA   CCW   X'39',COUNTNUL,X'40',4  Search Home Address equal\nCCWWR0   CCW   X'15',COUNTNUL,0,16  Write record zero\n         EJECT ,\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      Workarea and Constants\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\nSAVEAREA DC    18F'0'             Register save area\nHEX      DC    CL16'0123456789ABCDEF'\nEXITLIST DC    XL1'87',AL3(JFCB)  End of list and RDJFCB exit list\nECB      DC    F'0'               Event Control Block\nCOUNTEOF DC    XL8'0000000001000000'  Count area CCHHRKLL\n*                  CCCCHHHHRRKKLLLL   Cyl,Head,record#,Key-len,data-len\nCOUNTNUL DC    XL16'00000000000000080000000000000000'  New record zero\n*                   CCCCHHHHRRKKLLLLDDDDDDDDDDDDDDDD   New record zero\nTRACKS   DC    H'0'               Number of tracks on a cylinder\nVOLSER   DC    CL6' '             Volume Serial Number\nH0       DC    H'0'               PARM length for no PARM\nH4       DC    H'4'               PARM length for PARM=NULL\nH5       DC    H'5'               PARM length for PARM=EMPTY\nH10      DC    H'10'              PARM length for PARM='EMPTY,NULL'\nPARMEMNU DC    CL10'EMPTY,NULL'   Compare for PARM=EMPTY or EMPTY,NULL\nPARMNUEM DC    CL10'NULL,EMPTY'   Compare for PARM=NULL  or NULL,EMPTY\nFLAG     DC    X'00'              Flag byte\nEMPTY    EQU   X'80'              PARM=EMPTY specified\nNULL     EQU   X'40'              PARM=NULL  specified\nOBTAINRC DS    XL1                OBTAIN's return code for error\nKEEPTRKS DC    A(*-*)             Number of tracks to not overwrite\nF1DSCB   DC    CL140'DSCB AREA'   44 byte data set name, 96 bytes DSCB1\nJFCB     DC    CL176'JFCB AREA'   JOB File Control Block area\nOBTAIN   CAMLST SEARCH,JFCBDSNM,VOLSER,F1DSCB\nWTO20    WTO   'EOFDISK - VTOC OBTAIN failure RC=xx VOL=SER=volser',   +\n               ROUTCDE=11,MF=L    WTO list format for OBTAIN error\nWTO20RC  EQU   WTO20+37,2,C'C'    Will be the return code from OBTAIN\nWTO20VOL EQU   WTO20+48,6,C'C'    Will be the output data set volser\n*\n         EJECT ,\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      DSECTs\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n         LTORG ,                  Ensure literals are before the DSECTs\n*\n         DC    0D'0'              End of CSECT\n*\n         PRINT ON,GEN,DATA        Always print everything\n*\n         ORG   F1DSCB-44          Overlay Format 1 DSCB area in CSECT\n         IECSDSL1 (1)             DSECT for Format-1 DSCB (VTOC entry)\n         ORG   ,                  Reset the location counter to normal\n*\n         ORG   JFCB               Overlay JFCB area in CSECT\n         IEFJFCBN LIST=YES        DSECT for Job File Control Block\n         ORG   ,                  Reset the location counter to normal\n*\n         DCBD  DSORG=PS,DEVD=DA   DSECT for the Data Control Block\n*\n         IEZDEB LIST=YES          Data Extent Block\n*\n* Bit definitions for File Mask\n*\n* C0 Write control bits...\n* 00 ...inhibit write HA/R0\n* 40 ...inhibit all writes\n* 80 ...write update only\n* C0 ...allow all writes\n* 20 Reserved bits - must be 0\n* 18 Seek control bits...\n* 00 ...allow all seek/recalib\n* 08 ...allow seek cyl/head\n* 10 ...allow seek head only\n* 18 ...inhibit seek and MT\n* 06 Access auth bits...\n* 00 ...normal authorization\n* 02 ...device support auth\n* 04 ...diagnostic auth\n* 06 ...device support with no correction or retry\n*\n*\n         EJECT ,\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      Register Equates\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n         REGS  ,                  User Register equate MACRO\n         END   ,                  The end of the program\n//LKED.SYSLMOD DD DISP=SHR,DSN=SYS2.LINKLIB\n NAME EOFDISK     (R)\n//*\n//CHECKCC EXEC PGM=IEFBR14\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ONLCLEA$": {"ttr": 775, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00A\\x01\\x11\\x04O\\x01 4O\"I\\x00\\x1d\\x00\\x1c\\x00\\x00\\xc1\\xe2\\xd4\\xd1\\xc3\\xd3@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2011-02-13T00:00:00", "modifydate": "2020-12-09T22:49:41", "lines": 29, "newlines": 28, "modlines": 0, "user": "ASMJCL"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(ONLCLEAR)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,4),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n ENTRY   ONLCLEAR\n SETCODE AC(1)\n SETSSI  CB500846\n NAME    ONLCLEAR(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ONLCLEA#": {"ttr": 777, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00!\\x01 4o\\x01 4o\\x15$\\x00D\\x00:\\x00\\x00\\xc8\\xc5\\xd3\\xd7@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2020-12-11T00:00:00", "modifydate": "2020-12-11T15:24:21", "lines": 68, "newlines": 58, "modlines": 0, "user": "HELP"}, "text": "\n  FUNCTION OF THIS PROGRAM:   ONLCLEAR\n\n     For JCL to run ONLCLEAR, please see member ONLCLEA@.\n     You can make a PROC out of this JCL, and clear all the\n     VOL1 user areas on many (or all) the packs on your\n     system (in a jiffy) - if you want to do that.\n\n     As coded, to protect usage of this program, you need\n     READ access to RACF FACILITY class TBCXTUL.  Same\n     authority is needed for program ONLCLIP, which is also\n     part of this file.\n\n     THIS PROGRAM WAS DERIVED FROM THE ONLCLIP PROGRAM, BUT\n     INSTEAD OF CHANGING THE DASD VOLSER, IT CLEARS THE USER\n     IDENTIFICATION AREA OF THE DASD VOL1 RECORD TO BLANKS.\n\n     PARMS IN THE JCL ARE IGNORED (unlike the ONLCLIP program).\n\n     The user area of the VOL1 record for the disk pack is\n     cleared out to all blanks.  (Track 0, Record 3. This is\n     the last 64 bytes of Record 0, Track 3.)\n\n     The DISKUPD DD name determines the volser to be changed.\n\n     According to IBM nowadays (12/2020), the last 64 bytes of\n     the Track 0, Record 3, VOL1 DASD id record, should be all\n     blanks (X'40' EBCDIC).  This is what the ONLCLEAR program\n     sets them to.\n\n     These bytes are often used to identify the owner of the\n     disk pack, or the creator of the disk pack.  In previous\n     times, there may have been other uses for this data area.\n\n  Examples of this data area from old disks and new disks.\n\n  Example 1.  Disk pack created by a P/390.\n\n00000  >E5D6 D3F1  E5D6 D3F1   D4E5 E2D9  C5E2 4004   |VOL1VOL1MVSRES .|\n00010   5400 0001  0000 0000   0040 4040  4040 4040   |.........       |\n00020   4040 4040  4040 4040   4040 4040  4000 0000   |             ...|\n00030   0000 C3D7  F3F7 F040   0000 0000  0000 0000   |..CP370 ........|\n00040   4040 4040  4040 4040   4040 4040  4040 4040   |                |\n00050   4040 4040                                     |                |\n\n\n  Example 2.  Disk pack which was old.  I don't understand\n              the significance of the data.\n\n00000  >E5D6 D3F1  E5D6 D3F1   E6D6 D9D2  C5F4 4000   |VOL1VOL1WORKE4 .|\n00010   0000 0101  0000 0004   0000 0BB8  0000 0BB8   |................|\n00020   0008 3D60  0000 0017   0000 0040  0000 0040   |...-....... ... |\n00030   0402 2316  1504 0100   0000 0000  0000 0001   |................|\n00040   4040 4040  4040 401F   0000 0000  0000 0000   |       .........|\n00050   0000 0000                                     |....            |\n\n\n  Example 3.  This is a \"normal\" volume.  Most DASD nowadays\n              have a volume id record that looks like this.\n\n00000  >E5D6 D3F1  E5D6 D3F1   E6D6 D9D2  C5F1 4000   |VOL1VOL1WORKE1 .|\n00010   0000 0101  4040 4040   4040 4040  4040 4040   |....            |\n00020   4040 4040  4040 4040   4040 4040  4040 4040   |                |\n00030   4040 4040  4040 4040   4040 4040  4040 4040   |                |\n00040   4040 4040  4040 4040   4040 4040  4040 4040   |                |\n00050   4040 4040                                     |                |\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ONLCLEA@": {"ttr": 779, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x10\\x008\\x01\\x11\\x04/\\x01 4O\"H\\x00\\r\\x00\\x15\\x00\\x00\\xd9\\xe4\\xd5\\xd1\\xc3\\xd3@@@@'", "ispf": {"version": "01.16", "flags": 0, "createdate": "2011-02-11T00:00:00", "modifydate": "2020-12-09T22:48:38", "lines": 13, "newlines": 21, "modlines": 0, "user": "RUNJCL"}, "text": "//SBGOLOBS JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//* This program changes the user area of the VOL1 record\n//*  and clears it out to all blanks.  (Track 0, Record 3)\n//*  (This is the last 64 bytes of Record 0, Track 3.)\n//*\n//TRK0SAV1 EXEC PGM=ONLCLEAR\n//STEPLIB  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSPRINT DD  SYSOUT=*\n//SYSUDUMP DD  SYSOUT=*\n//DISKUPD  DD  UNIT=SYSALLDA,SPACE=(TRK,1),VOL=SER=TESCLR\n//*\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ONLCLEAR": {"ttr": 781, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01R\\x00T\\x01\\x11\\x04/\\x01 4O\"9\\x02\\xf7\\x00\\xe3\\x00\\x00\\xe2\\xd6\\xe4\\xd9\\xc3\\xc5@@@@'", "ispf": {"version": "01.82", "flags": 0, "createdate": "2011-02-11T00:00:00", "modifydate": "2020-12-09T22:39:54", "lines": 759, "newlines": 227, "modlines": 0, "user": "SOURCE"}, "text": "ONLCLEAR TITLE 'ONLCLEAR - Clear the user area of the VOL1 DASD record'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n* * * *   CLEAR THE DASD VOLUME IDENTIFICATION AREA TO BLANKS   * * * *\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*   FUNCTION OF THIS PROGRAM:\n*\n*      THIS PROGRAM WAS DERIVED FROM THE ONLCLIP PROGRAM, BUT\n*      INSTEAD OF CHANGING THE DASD VOLSER, IT CLEARS THE USER\n*      IDENTIFICATION AREA OF THE DASD VOL1 RECORD TO BLANKS.\n*\n*      PARMS IN THE JCL ARE IGNORED (unlike the ONLCLIP program).\n*\n*      The user area of the VOL1 record for the disk pack is\n*      cleared out to all blanks.  (Track 0, Record 3. This is\n*      the last 64 bytes of Record 0, Track 3.)\n*\n*      The DISKUPD DD name determines the volser to be changed.\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n* Sample JCL:\n*\n* //*\n* //* Purpose of this program is to blank out the user identification\n* //* part of the DASD VOL1 record of a disk pack.  Track 0 Record 3.\n* //*\n* //useridX  JOB (etc.)\n* //ONLCLEAR EXEC PGM=ONLCLEAR\n* //STEPLIB  DD  DISP=SHR,DSN=your.steplib\n* //SYSPRINT DD  SYSOUT=*\n* //SYSUDUMP DD  SYSOUT=*\n* //DISKUPD  DD  UNIT=SYSALLDA,SPACE=(TRK,1),VOL=SER=TEST02\n* //*\n*\n* Blame: Sam Golob.  NOT somitcw@yahoo.com.\n*        Got help from Rick Fochtman.\n*        Cobbled this code from TRK0INIT.  Only change the volser\n*          of the pack, and do not disturb any IPL text that is\n*          already there.\n*\n*  Maximum Size Permitted for\n*  the IPL Program Record\n*  Maximum Bytes\n* Volume Type for IPL Program\n* 2311      3,110\n* 2314      6,514\n* 2319      6,514\n* 3340      7,286\n* 3344      7,286\n* 3330-1   12,117\n* 3330-11  12,117\n* 2305-1   12,180\n* 2305-2   13,616\n* 3350     17,902\n* 3375     33,984\n* 3380     44,948\n* 9345     49,938\n* 3390     53,450\n*\n*\n* Notes from Sam Golob follow: (Logic is for ONLCLIP, but\n* the PARM field is ignored.  All you need is the VOLSER from\n* the //DISKUPD DD name.)\n*\n* Input for this program is a new volume serial which is in the\n*  PARM field.  After changing the volume serial of the pack, to\n*  \"make it offiical\", you have to take the pack offline and\n*  bring it online again.  In the old days, you also had to do a\n*  MOUNT command, but that was eliminated around the middle of\n*  the OS/390 time, I think.\n*\n* Requires READ access to the FACILITY class profile TBCXTUL.\n*  (CBT spelled backwards, X, TUL for tool.)\n*\n* Program Logic for ONLCLEAR. (Really most of this is for ONLCLIP)\n*\n*  Stage 0.  OPEN SYSPRINT.\n*            Print the header, and get the value of the new volser\n*              from the JCL PARM field.  Save it in the program.\n*\n*  Stage 0A. RACF protection to use the program. Tests READ access\n*              to the FACILITY class, profile TBCXTUL.\n*\n*  Stage 1.  GETMAIN a 65535 byte buffer.\n*            OPEN DISKUPD DCB for INPUT.\n*            Copy entire track 0 into buffer, including count, key,\n*              and data of each record.\n*            CLOSE DISKUPD DCB.\n*\n*  Stage 2.  Now we will see what to do with this data.\n*            Records 1 and 2 are not disturbed.  The CCW opcode is a\n*              no-op.\n*\n*  Stage 3.  Bump in the buffer to the count field of Record 3.\n*            Copy the previous volser to a saved location, and save\n*              the contents of the VTOC location field as well.\n*            Save all of the rest of the Record 3 data into the\n*              program except the volser.\n*            Copy the buffer's Record 3 into the program, overlaying\n*              the VOL1 storage area.  You now have the contents of\n*              the volume's Record 3, copied into the program.  (This\n*              process has been kludged, but it works, because we then\n*              forcibly overlay the unchanged part of Record 3 with\n*              all the previous unchanged data, besides the volser\n*              field.)  The volser field is then overlaid with the\n*              saved PARM data, after having been uppercased.\n*\n*            Modification for ONLCLEAR:  Overlay the \"new volser\"\n*              field with the UCB volser, and then clear out the\n*              last 64 bytes of Record 3 to blanks.\n*\n*  Stage 4.  OPEN DISKUPD DCB for UPDAT.\n*            Copy the previous volser from its saved location to the\n*              report.  Copy the new volser from its save area to the\n*              report.  Do not change the rest of Record 3, and write\n*              the record back in place.  X'85' is the \"update in\n*              place\" opcode, which doesn't destroy the subsequent\n*              records in the rest of Track 0.  So only the volume\n*              serial of the pack is changed, and not the rest of\n*              Record 3.  Any IPL text which is subsequent to Record\n*              3, is also not disturbed.\n*\n*            Modification for ONLCLEAR:  Record 3 is written back in\n*              place with unchanged volser and VTOC location, but the\n*              last 64 bytes of Record 3 are blanked.\n*\n*            CLOSE DISKUPD DCB.\n*\n*  Stage 5.  FREEMAIN the 65535 byte buffer.\n*            CLOSE SYSPRINT.\n*            End the program.\n*\n*            No PARM is necessary in ONLCLEAR.  If a PARM is coded,\n*              then it is ignored.  Only the UCB volser is used.\n*            If no READ access to FACILITY class, profile TBCXTUL,\n*              then get out with an appropriate error message.\n*\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*\n*  Changes for ONLCLIP:\n*\n*            Version 1.1 - 02/09/2020 - Initial release.\n*\n*            Version 1.2 - 02/10/2020 - Time and Date of Execution\n*\n*            Version 1.3 - 02/16/2020 - UCB messages - unit address\n*                                        and volume serial\n*\n*            Version 1.4 - 02/16/2020 - WTO messages including unit\n*                                        address and volume serial\n*\n*            Version 1.5 - 02/23/2020 - RACF protection. Needs FACILITY\n*                                        CLASS profile TBCXTUL and\n*                                        READ access, to work.\n*\n*  Changes for ONLCLEAR:\n*\n*            Version 1.5 - 12/09/2020 - PARM field ignored. This\n*                                       program does not change the\n*                                       DASD volser, but instead, it\n*                                       blanks out the VOL1 user\n*                                       area, after the VTOC location\n*                                       in the VOL1 DASD record.\n*                                       (Track 0, Record 3 of DASD)\n*                                       (Last 64 bytes of the record.)\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE\n         MACRO\n         REGS  ,\n         LCLA  &COUNT\n.LOOP    ANOP\nR&COUNT  EQU   &COUNT             Register equate for register &COUNT\n&COUNT   SETA  &COUNT+1\n         AIF   (16 GT &COUNT).LOOP\n         MEND\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         MACRO\n&NAME    HEX   &TO,&LEN,&FROM\n&NAME    DS    0H\n         ST    R9,SAV9HEX\n         STM   R15,R1,HEXSAVE\n         LA    R1,&FROM\n         LA    R0,&LEN\n         LA    R15,&TO\n         BAL   R9,HEX\n         L     R9,SAV9HEX\n         LM    R15,R1,HEXSAVE\n         MEND\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE\n         PRINT ON,GEN,DATA\nONLCLEAR CSECT ,\nONLCLEAR RMODE 24\nONLCLEAR AMODE 31\n         USING *,R15              Set temporary base register\n         SAVE  (14,12),,ONLCLEAR.&SYSDATE..&SYSTIME Save Reg.s\n         B     BEGIN\n         DC    CL2' -'\n         DC    CL50'Needs FACILITY class profile TBCXTUL, READ access-'\nBEGIN    DS    0H\n         LA    R12,SAVEAREA       Load address of new save area\n         ST    R12,8(,R13)        Connect old and new save areas\n         ST    R13,4(,R12)        Connect old and new save areas\n         LR    R13,R12            Connect old and new save areas\n         DROP  R15                Drop the temporary base register\n         LR    R12,R15            Load the program's base register\n         USING ONLCLEAR,R12,R7    Give the assembler the new bases\n         LA    R7,2048(,R12)\n         LA    R7,2048(,R7)\n         ST    R1,SAVER1A         Save PARM pointer\n         OPEN  (DCBUPD,INPUT)     Open DCB to read original Track 0\n         GETMAIN R,LV=65536       Get Input/Output buffer\n         LR    R11,R1             Save I/O buffer address\n         STCM  R11,B'0111',CCWREAD+1  Store I/O buffer address in CCW\n*\n* ----- >                         At this point we read the PARM\n*                                 field to obtain the new volser.\nINITCON  DS    0H\n         MVI   FLAG0,X'00'\n         MVI   CLERREST-1,X'40'\n         MVC   CLERREST,CLERREST-1\n         MVI   BLANKS-1,X'40'\n         MVC   BLANKS,BLANKS-1\nTESTPARM DS    0H\n         OPEN  (SYSPRINT,OUTPUT)\n***********************************************************************\n*                    GET SYSTEM DATE AND TIME                         *\n***********************************************************************\n         STM   R14,R2,SAVE1402\n         TIME  DEC,DATETIME,LINKAGE=SYSTEM,DATETYPE=MMDDYYYY\n         OI    DATE+4,X'0F'\n         UNPK  DATED,DATE\n         OI    TIME+3,X'0F'\n         UNPK  TIMED,TIME\n*                          FILL HEADER AREA WITH INFO TO REUSE\n         MVC   HEADERD+9(2),DATED\n         MVI   HEADERD+9+2,C'/'\n         MVC   HEADERD+9+3(2),DATED+2\n         MVI   HEADERD+9+5,C'/'\n         MVC   HEADERD+9+6(4),DATED+4\n         MVC   HEADERD+25+7(2),TIMED\n         MVI   HEADERD+25+9,C':'\n         MVC   HEADERD+25+10(2),TIMED+2\n         MVI   HEADERD+25+12,C':'\n         MVC   HEADERD+25+13(2),TIMED+4\n         LM    R14,R2,SAVE1402\n*\n*             PRINT PROGRAM TITLE\n*\n         MVI   OUTLINE-1,X'40'\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+1(36),HEADER\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+1(36),HEADERU\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+1(34),HEADERT\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+1(34),HEADERX\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+1(46),HEADERD\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n***********************************************************************\n*                                                                     *\n*  CHECK THE AUTHORITY OF THE USER TO SAF CLASS \"FACILITY' FOR        *\n*  ENTITY \"TBCXTUL\".  NOTE THAT FASTAUTH IS USED.  TO AVOID THE       *\n*  SITUATION WHERE SPECIAL ATTRIBUTES OF THE USER MAY ALLOW THE       *\n*  ACCESS WITH LOGGING, A CHECK IS MADE FOR A NON-ZERO REASON         *\n*  CODE.  THIS CONDITION WILL BE CONSIDERED A FAILURE.                *\n*                                                                     *\n***********************************************************************\n         NOP   TESTEND\nTEST0    RACROUTE REQUEST=LIST,WORKA=RACWORK,CLASS=FACILITY,           X\n               ENVIR=CREATE,                                           X\n               GLOBAL=YES,                                             X\n               RELEASE=2.2,                                            X\n               MF=S\n***********************************************************************\n*        TEST TBCXTUL  IN THE FACILITY CLASS                          *\n***********************************************************************\nTEST1    MVC   RESOURCE,=CL44'TBCXTUL  '\n         RACROUTE REQUEST=FASTAUTH,WORKA=RACWORK,WKAREA=FRACWORK,      X\n               ENTITY=RESOURCE,CLASS=FACILITY,ATTR=READ,               X\n               MF=(E,RACROUTE)\n         LTR   R15,R15             TEST THE RETURN CODE\n         BNZ   TESTBAD             NOT ZERO, NOT AUTHORIZED\n         CLC   RACROUTE+4(4),=F'0' TEST THE REASON CODE\n         BNE   TESTBAD             ZERO, FULLY AUTHORIZED\n         B     TESTOK\n***********************************************************************\nTESTBAD  DS    0H\nTESTFAIL MVC   RESOURCE,=CL44' '\n         OI    FLAG0,X'02'\n***********************************************************************\n*        CLEANUP AFTER RACROUTE                                       *\n***********************************************************************\nTESTOK   RACROUTE REQUEST=LIST,WORKA=RACWORK,CLASS=FACILITY,           X\n               ENVIR=DELETE,                                           X\n               RELEASE=2.2,                                            X\n               MF=S\n         TM    FLAG0,X'02'\n         BO    NOTAUTHR\nTESTEND  DS    0H\n         EJECT\n***********************************************************************\n*\n*             GET THE NEW VOLSER FROM THE PARM FIELD\n*\n***********************************************************************\n         L     R1,SAVER1A          RESTORE PARM POINTER\n         LTR   R1,R1               ANY PARM POINTER?\n         BZ    PARM                DOES NOT MATTER\n         L     R3,0(,R1)           POINT TO BUFFER\n         LTR   R3,R3               ANY?\n         BZ    PARM                B IF NOT.\n         LH    R4,0(,R3)           LOAD LENGTH.\n         LTR   R4,R4               ANY?\n         BZ    PARM                DOES NOT MATTER\n         LA    R3,2(,R3)           POINT TO PARM.\nPARM     OC    0(6,R3),=CL6' '          UPPERCASE.\n         MVC   SAVENVOL(6),0(R3)        Save for plugging in.\n*\n*             DO ALL THE DEB WORK AND GET THE UCB\n* ----- >\n*\n* DEBDVMOD DS    B         DEVICE MODIFIER - FILE MASK\n* DEBUCBA  DS    AL3       ADDRESS OF UCB ASSOCIATED WITH THIS DATA\n* *                        EXTENT\n* DEBBINUM DS    CL2       BIN NUMBER\n* DEBSTRCC DS    CL2       CYLINDER ADDRESS FOR THE START OF AN EXTENT.\n* DEBSTRHH DS    CL2       TRACK ADDRESS FOR THE START OF AN EXTENT.\n* DEBENDCC DS    CL2       CYLINDER ADDRESS FOR THE END OF AN EXTENT.\n*\n* DEBENDHH DS    CL2       TRACK ADDRESS FOR THE END OF AN EXTENT.\n* DEBNMTRK DS    CL2       NUMBER OF TRACKS ALLOCATED TO A GIVEN EXTENT\n*\n         L     R10,DCBUPD+DCBDEBAD-IHADCB   Load DEB address\n         LR    R5,R10                       Addr of DEBBASIC\n         LA    R10,DEBBASND-DEBBASIC(,R10)  Find DEBDASD section\n         USING DEBDASD,R10            Give the assembler the DEB base\n         MVC   SAVEDEB(12),DEBBINUM   Save extent to restore later\n*\n* --- >     At this point we find the UCB information - below\n*\n         MVC   UCBADDR(4),0(R10)      UCB Address is 0 off DEBBASIC\n         TM    15(R5),X'02'           Is DEB31UCB ON--all 4 bits used?\n         BO    NOZERO                 Yes, the UCB is above the line\n         MVI   UCBADDR+0,X'00'        No, the UCB is the last 24 bits\nNOZERO   DS    0H\n         L     R5,UCBADDR             Get the actual UCB address\n         MVC   UCBUNIT(2),4(R5)       Get the unit address in UCB\n         MVC   UCBVOLS(6),28(R5)      Get the volser in the UCB\n*\n* --- >     At this point we find the UCB information - above\n*\n         MODESET KEY=ZERO             Go to key zero to update DEB\n         XC    DEBBINUM(12),DEBBINUM  Set extent to CYL 0 and TRK 0\n         MVI   DEBNMTRK+1,1           Set extent size as one track\n         MODESET KEY=NZERO            Go back to problem progrem key\nREAD     DS    0H                 Read entire Track 0 into the buffer\n         XC    ECBIN,ECBIN        Insure that the ECB is clear\n         EXCP  IOBIN              Read track zero\n         WAIT  ECB=ECBIN          Wait for the read to complete\n         CLI   ECBIN,X'7F'        See if a good read\n         BNE   IOERROR            If not good, go abend\n         SLR   R8,R8              Clear a work register\n         L     R9,F65535          Load max. size that could have read\n         ICM   R8,B'0011',CSWIN+6  Load the residual byte count\n         SR    R9,R8              Find size of track read\n         AR    R9,R11             Find byte after track read\n         MVI   0(R9),X'FF'        Mark byte after end as the end\n         MODESET KEY=ZERO         Go to key zero to update DEB\n         MVC   DEBBINUM(12),SAVEDEB  Restore DEB extent information\n         MODESET KEY=NZERO           Go back to problem program key\n         CLOSE DCBUPD             We are done with the reading in\n         DROP  R10                Don't need DEB address anymore\n* ----------------------------------------------------------------- *\n*  Print the unit address and the volser taken from the UCB.\n* ----------------------------------------------------------------- *\n         MVI   OUTLINE-1,X'40'\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+2(11),=C'UCB Unit:  '\n         HEX   OUTLINE+14,2,UCBUNIT\n         MVC   OUTLINE+22(11),=C'UCB Volser:'\n         MVC   OUTLINE+35(6),UCBVOLS\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n* ----------------------------------------------------------------- *\n*  Now, you've got the Track 0 image in the buffer.\n*  We copy Record 3 into the proper area, and then ignore records 1\n*   and 2.  We update record 3 in place, with modified information,\n*   only in the VOL1 user id area, blanks in the last 64 bytes.\n* ----------------------------------------------------------------- *\n         LR    R9,R11              Load the input track address\n         LA    R9,IPLLEN(,R9)      Point to Record 3\n         CLI   4(R9),3             Check to see if it is Record 3\n         BNE   ERROR1              Not Record 3, error message & quit\n*\n         MVC   VOL1(VOL1L),4(R9)   Overlay VOL1 area with real VOL1\n         MVC   SAVEOVOL(6),16(R9)  Save old VOLSER before change\n* ----------------------------------------------------------------- *\n*     In this program the new volser equals the old volser.         *\n* ----------------------------------------------------------------- *\n         MVC   SAVENVOL(6),SAVEOVOL   Do not change the volser ever.\n* ---------------------------------------------------------------- *\n         MVC   SAVEVTOC(4),24(R9)  Save the VTOC location\n         MVC   SAVEREST(92),0(R9)  Save almost entire Record 3\n*\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE+2(38),=C'This program has succesfully cleared  '\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+2(38),=C'  the user area of the VOL1 record    '\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+2(38),=C'  of this pack:  Track 0, Record 3.   '\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+2(38),=C'The VOLSER and the VTOC position on   '\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+2(38),=C'  this pack, have not been changed.   '\n         PUT   SYSPRINT,OUTLINE\n         B     OUTPARM\nOPMSG2   WTO   'ONLC002 No parm was coded in the JCL--Nothing Changed',+\n               ROUTCDE=11\n         CLOSE SYSPRINT\n         OI    FLAG0,X'01'         Show Return Code of 4\n         B     GOFREE1             Get out of the program.\nNOTAUTHR DS    0H                  If no PARM coded, then leave.\n         MVI   OUTLINE-1,X'40'\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+1(37),=C' You have not been authorized by RACF'\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+1(21),=C' Nothing was changed.'\n         PUT   SYSPRINT,OUTLINE\nOPMSG3   WTO   'ONLC003 Not authorized by RACF--Nothing Changed',      +\n               ROUTCDE=11\n         CLOSE SYSPRINT\n         OI    FLAG0,X'01'         Show Return Code of 4\n         B     GOFREE1             Get out of the program.\nOUTPARM  DS    0H\n         CLOSE SYSPRINT\n* ----------------------------------------------------------------- *\n*   Now, we have to put out the new Track 0 information only for    *\n*    Record 3.  Make sure we keep the VTOC location and the rest    *\n*    of the record as before.                                       *\n* ----------------------------------------------------------------- *\n         OPEN  (DCBUPD,UPDAT)         Now OPEN DCB to update Track 0\n         L     R10,DCBUPD+DCBDEBAD-IHADCB   Load DEB address\n         LA    R10,DEBBASND-DEBBASIC(,R10)  Find DEBDASD section\n         USING DEBDASD,R10            Give the assembler the DEB base\n         MVC   SAVEDEB(12),DEBBINUM   Save extent to restore later\n         MODESET KEY=ZERO             Go to key zero to update DEB\n         XC    DEBBINUM(12),DEBBINUM  Set extent to CYL 0 and TRK 0\n         MVI   DEBNMTRK+1,1           Set extent size as one track\n         MODESET KEY=NZERO            Go back to problem program key\n*\nOREC1    DS    0H                 Write IPL1\n         LA    R1,IPL1            Point to IPL1 record\n         LA    R2,IPL1L           Load its length\n         STH   R2,CCWUPDO+6       Store key and data length in CCW\n         MVI   RO,0               Copy record number to seek\n         STCM  R1,7,CCWUPDO+1     Store I/O buffer address in CCW\n         MVI   CCWUPDO,X'03'      No-op CCW opcode\n         MVC   IOERROR1+X'25'(2),=C'01'  (Diagnostic)\n         BAL   R6,EXCP            Write out the record\n*\nOREC2    DS    0H                 Write IPL2\n         LA    R1,IPL2            Point to IPL2 record\n         LA    R2,IPL2L           Load its length\n         STH   R2,CCWUPDO+6       Store key and data length in CCW\n         MVI   RO,1               Copy record number to seek\n         STCM  R1,7,CCWUPDO+1     Store I/O buffer address in CCW\n         MVI   CCWUPDO,X'03'      No-op CCW opcode\n         MVC   IOERROR1+X'25'(2),=C'02'  (Diagnostic)\n         BAL   R6,EXCP            Write out the record\n*\nOVOL1    DS    0H                 Write Record 3\n         LA    R1,VOL1            Point to VOL1 record\n         LA    R2,VOL1L           Load its length\n         STH   R2,CCWUPDO+6       Store key and data length in CCW\n         MVI   RO,2               Copy record number to seek\n         STCM  R1,7,CCWUPDO+1     Store I/O buffer address in CCW\n         MVI   CCWUPDO,X'03'      No-op CCW opcode\n         MVC   IOERROR1+X'25'(2),=C'03'  (Diagnostic)\n         BAL   R6,EXCP            Write out the record\n*\n*        B     ENDOFPGM\nOVOLS    DS    0H                 Erase record 4 to clear track\n         LA    R1,VOLS            Point to DUMMY record\n         LA    R2,VOLSL           Load its length\n         MVC   VOLSLIT(4),=C'VOL1'\n*   plug in new volser here\n         MVC   VOLSVOL(6),SAVENVOL   New volser\n         MVC   VOLSVTOC(4),SAVEVTOC  Old VTOC location\n*        MVC   VOLSREST(64),SAVEREST+28  Rest of Record 3\n         MVC   VOLSREST(64),CLERREST     BLANK REST OF RECORD 3\n         STH   R2,CCWUPDO+6       Store key and data length in CCW\n         MVI   RO,3               Copy record number to seek\n         STCM  R1,7,CCWUPDO+1     Store I/O buffer address in CCW\n         MVI   CCWUPDO,X'85'      Update in place CCW opcode\n         MVC   IOERROR1+X'25'(2),=C'04'  (Diagnostic)\n         BAL   R6,EXCP            Overlay the entire Record 3\n*\nWTO001   DS    0H                 Write to Operator and JES logs\n         MVC   WTO0VOL(6),UCBVOLS     Put new pack id into message\nOPMSG0   WTO   'ONLCLR0 The DASD (UCB) volume serial is: xxxxxx.',     +\n               ROUTCDE=11\n         HEX   WTOUNIT,2,UCBUNIT      Put unit address into message\n         MVC   WTO1VOL(6),UCBVOLS     Put UCB volser into message\nOPMSG1   WTO   'ONLCLR1 VOL1 user area on Unit: uuuu  Volser: xxxxxx cl+\n               eared to blanks.',ROUTCDE=11\nWTO0VOL  EQU   OPMSG0+49,6            Proper location\nWTOUNIT  EQU   OPMSG1+40,4              in\nWTO1VOL  EQU   OPMSG1+54,6                messages\nENDOFPGM DS    0H                 Done. Clean up and get out.\n         MODESET KEY=ZERO            Go to key zero to update DEB\n         MVC   DEBBINUM(12),SAVEDEB  Restore DEB extent information\n         MODESET KEY=NZERO           Go back to problem program key\n         DROP  R10                Don't need DEB address anymore\n         CLOSE DCBUPD             Close the DCB\nGOFREE1  DS    0H\n         FREEMAIN R,LV=65536,A=(R11)  Free the GETMAINed buffer\n         L     R13,4(,R13)        Restore the caller's save area addr.\n         TM    FLAG0,X'01'        Return code 4 ?\n         BZ    RET0               No.\nRET4     DS    0H\n         LM    14,12,12(13)       Return to caller\n         LA    R15,4              Return code 4.\n         BR    14\nRET0     DS    0H\n         LM    14,12,12(13)       Return to caller\n         LA    R15,0              Return code 0.\n         BR    14\n*\nIOERROR  DS    0H\n         WTO   'Input/Output error, Program abending',ROUTCDE=11\n         ABEND 1234,DUMP          Abend with a dump\n         EJECT\nIOERROR1 DS    0H\n         WTO   'Input/Output error, Code = xx ',ROUTCDE=11\n         ABEND 1235,DUMP          Abend with a dump\n         EJECT\nERROR1   DS    0H\n         WTO   'Volume id not copied, Program abending',ROUTCDE=11\n         ABEND 1248,DUMP          Abend with a dump\n         EJECT\n*\nEXCP     DS    0H                 Routine to write a record.\n         ST    R6,SAVER6A         Save BAL register.\n         XC    ECBOUT,ECBOUT      Insure that the ECB is clear\n         EXCP  IOBOUT             Update or add record to track zero\n         WAIT  ECB=ECBOUT         Wait for the update to complete\n*        CLI   ECBOUT,X'7F'\n         TM    ECBOUT,X'40'       See if a good count-key-data write\n*        BNE   IOERROR1           You don't need to test full X'7F'\n         BZ    IOERROR1           If not good, go abend\n         L     R6,SAVER6A         Restore BAL register.\n         BR    R6\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nHEX      DS    0H                HEX Display Routine\n         MVC   1(1,R15),0(R1)        Move byte\n         UNPK  0(3,R15),1(2,R15)     Unpack\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)           Increment output pointer\n         LA    R1,1(,R1)             Increment input pointer\n         BCT   R0,HEX                Decrement length, then loop\n         MVI   0(R15),C' '           Blank the trailing byte\n         BR    R9                    Return to caller\nHEXTAB   DC    C'0123456789ABCDEF'   Translate table\nHEXSAVE  DS    3F\nSAV9HEX  DS    F\n         SPACE\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      DCB's, IOB'S, ECB, and CCW's\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE\nDCBUPD   DCB   DDNAME=DISKUPD,    DD name                              X\n               MACRF=E,           MACRO Reference is EXCP              X\n               DSORG=PS           Data Set Organization\n* DCBLEN   EQU   *-DCBOUT           Length of DCB\nSYSPRINT DCB   MACRF=PM,DDNAME=SYSPRINT,DSORG=PS,RECFM=FBA,LRECL=133\n*  ---  IOB for Input from Track 0\nIOBIN    DS    0D                 Input/output Block\n         DC    XL4'40000000'      Command chaining used\n         DC    A(ECBIN)           Address of the ECB\nCSWIN    DC    D'0'               Channel Status Word\n         DC    A(CCWIN)           Address of the channel command string\n         DC    A(DCBUPD)          Address of the Data Control Block\n         DC    A(0)               IOB Restart\n         DC    XL4'0'             Flags and Counters\nSEEKI    DC    D'0'               Seek address\nSEARCHI  EQU   SEEKI+3,5          Cylinder, Head, and Record to search\nCCHHI    EQU   SEEKI+3,4          Cylinder and Head to seek to\nCCI      EQU   SEEKI+3,2          Cylinder to seek\nHHI      EQU   SEEKI+5,2          Track to seek to\nRI       EQU   SEEKI+7,1          Record to search for\nCCWIN    CCW   X'31',SEARCHI,X'40',5 Search for record zero\n         CCW   8,*-8,0,0          TIC back until search complete\nCCWREAD  CCW   X'5E',*-*,X'20',65535  Read track zero with SLI\n*  ---  IOB for Output to Track 0\nIOBOUT   DS    0D                 Input/output Block for Output\n         DC    XL4'40000000'      Command chaining used\n         DC    A(ECBOUT)          Address of the ECB\nCSWOUT   DC    D'0'               Channel Status Word\n         DC    A(CCWOUT)          Address of the channel command string\n         DC    A(DCBUPD)          Address of the Data Control Block\n         DC    A(0)               IOB Restart\n         DC    XL4'0'             Flags and Counters\nSEEKO    DC    D'0'               Seek address\nSEARCHO  EQU   SEEKO+3,5          Cylinder, Head, and Record to search\nCCHHO    EQU   SEEKO+3,4          Cylinder and Head to seek to\nCCO      EQU   SEEKO+3,2          Cylinder to seek\nHHO      EQU   SEEKO+5,2          Track to seek to\nRO       EQU   SEEKO+7,1          Record to search for\nCCWOUT   CCW   X'31',SEARCHO,X'40',5 Srch for record before one written\n         CCW   8,*-8,0,0          TIC back until search complete\nCCWUPDO  CCW   X'1D',*-*,0,*-*    Update key-data,write count-key-data\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      Workarea and Constants\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nSAVEAREA DC    18F'0'             Register save area\nECBIN    DC    F'0'               Event Control Block\nECBOUT   DC    F'0'               Event Control Block\nSAVEDEB  DS    XL12               Area to save extent after OPEN\nSAVER6A  DC    F'0'               BAL register save area\nSAVEOVOL DC    CL6' '             Old volser\nSAVENVOL DC    CL6' '             New volser\nSAVEVTOC DC    XL4'00'            Preserve VTOC location on disk\nSAVEREST DC    CL92' '            Rest of Record 3, after VTOC loc.\nH8       DC    H'8'               Constant for subtraction\nFLAG0    DC    X'00'              X'01' means Return Code of 4\n*                                 X'02' means NOT RACF AUTHORIZED\nF65535   DC    F'65535'           Buffer size\nUCBUNIT  DC    H'0'               Unit address from the UCB\nUCBVOLS  DC    CL6' '             Volser from UCB\nUCBADDR  DC    F'0'               UCB Address from DEB\nMESSAG01 DS    0F                      AREA FOR PRINTING\nMESS01L  DC    Y(L'MESSAGC1)           MESSAGE LENGTH\nMESSAGC1 DC    CL(69)'ONLC001 Volume Serial for Unit: xxxxxx changed fr+\n               om xxxxxx to yyyyyy.'\n* ------ >>   below     Init track images\nIPL1     DS    0XL36              Canned IPL1 record\nIPL1R    DC    X'0000000001'               5\nIPL1KL   DC    X'040018'                   3\nIPL1K    DC    C'IPL1'                     4   =  12\n         DC    X'000A00000000000F'         8\n         DC    X'0300000000000001'         8\n         DC    X'0000000000000000'         8   =  24 + 12  =  36\nIPL1L    EQU   *-IPL1             IPL1 record length incl count\n* -----\nIPL2     DS    0XL156             Canned IPL2 record\nIPL2R    DC    X'0000000002'               5\nIPL2KL   DC    X'040090'                   3\nIPL2K    DC    C'IPL2'                     4   =  12\n         DC    X'07003AB840000006'         8\n         DC    X'31003ABE40000005'         8\n         DC    X'08003AA000000000'         8\n         DC    X'0600000020000000'         8\n         DC    X'0000000000000000'         8   =  40 + 12  =  52\n         DC    X'000004'                   3   +  52  =  55\n         DC    XL101'00'                   101 +  55  = 156\nIPL2L    EQU   *-IPL2             IPL2 record length incl count\n* -----\nIPLLEN   EQU   *-IPL1             Length of both IPL records\n* -----\n* -----                           VOLS is more used, to replace Rec 3\nVOL1     DS    0XL96              VOLUME ID record - will be overlaid\nVOL1R    DC    X'0000000003'                  5\nVOL1KL   DC    X'040050'                      3\nVOL1K    DC    C'VOL1'                        4   =  12\n         DC    C'VOL1'                        4\nVOL1SER  DC    CL6' '                         6\n         DC    C' '                           1\n         DC    XL5'0000000101' (LOC OF VTOC)  5   =  16 + 12 = 28\n         DC    CL68' '\nVOL1L    EQU   *-VOL1             VOL1 record length incl count\n* ------ >>   above     Init track images\nVOLS     DS    0XL92              Record overlay area for Record 3\nVOLSLIT  DC    C'VOL1'            Second \"VOL1\" in record\nVOLSVOL  DC    CL6' '             New VOLSER here.\nVOLSFIL1 DC    X'4000'            Filler - necessary\nVOLSVTOC DC    XL4'00'            VTOC location to preserve\nVOLSREST DC    CL64' '            Rest of Record 3\nVOLSL    EQU   *-VOLS\n* -----\n         DC    CL1' '\nOUTLINE  DC    CL133' '           Output line for SYSPRINT\n* -----\nSAVE1402 DS    6F                 ONE MORE FOR SAFETY\nHEADER   DC    CL35'  ONLCLEAR - Version 1.5 - &SYSDATE'\nHEADERU  DC    CL35'  -------- - ------- --- - --------'\nHEADERT  DC    CL35'           \"ONLINE CLEAR\"          '\nHEADERX  DC    CL35'      Time and Date of Execution:  '\nHEADERD  DC    CL46' Date:                  Time:           '\n* ----------------------------------------------------------------- *\n*          Work area for time and date display routine              *\n* ----------------------------------------------------------------- *\nTIMED    DS    CL7\nDATED    DS    CL9\nDATETIME DS    4F\n         ORG   DATETIME\nTIME     DS    CL4\n         DS    CL4\nDATE     DS    CL5\n         DS    CL3\n         EJECT\n***********************************************************************\nSAVER1A  DS    F\nFACILITY DC    CL8'FACILITY'       RACROUTE CLASS NAME\nRESOURCE DC    CL44' '             RACROUTE RESOURCE NAME\nRACROUTE RACROUTE REQUEST=FASTAUTH,MF=L RACROUTE LIST FORM\nRACWORK  DS    CL512               RACROUTE WORK AREA 1\nFRACWORK DS    16F                 RACROUTE WORK AREA 2\n         DS    X\nCLERREST DC    CL64' '             Rest of Record 3\n         DS    X\nBLANKS   DC    CL64' '             Rest of Record 3\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      DSECTs\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n         LTORG ,                  Insure literals are before the DSECTs\n*\n         PRINT GEN\n         DCBD  DSORG=PS,DEVD=DA   DSECT for the Data Control Block\n         IEZDEB LIST=YES          DSECT for the Data Extent Block\n         PRINT NOGEN\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      Register Equates\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE\n         REGS  ,                  User Register equate MACRO\n         END   ,                  The end of the program\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ONLCLI@@": {"ttr": 1035, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00&\\x01 \\x05O\\x01 \\x05O\\x15V\\x00\\x03\\x00\\x03\\x00\\x00\\xd9\\xc5\\xc1\\xc4\\xd4\\xc5Z@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-02-23T00:00:00", "modifydate": "2020-02-23T15:56:26", "lines": 3, "newlines": 3, "modlines": 0, "user": "README!"}, "text": "\nNote:   ONLCLIP needs READ access to the RACF FACILITY class TBCXTUL.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ONLCLIJ1": {"ttr": 1282, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00E\\x01\\x11\\x04/\\x01 \\x04\\x1f\\x15\\x17\\x00\\x0c\\x00\\x15\\x00\\x00\\xd9\\xe4\\xd5\\xd1\\xc3\\xd3@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2011-02-11T00:00:00", "modifydate": "2020-02-10T15:17:45", "lines": 12, "newlines": 21, "modlines": 0, "user": "RUNJCL"}, "text": "//SBGOLOBS JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//* Purpose of this program is to change the VOLSER of a volume,\n//*  while it is online.  The PARM field contains the new volume id.\n//*\n//TRK0SAV1 EXEC PGM=ONLCLIP,PARM='test13'\n//STEPLIB  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSPRINT DD  SYSOUT=*\n//SYSUDUMP DD  SYSOUT=*\n//DISKUPD  DD  UNIT=SYSALLDA,SPACE=(TRK,1),VOL=SER=TEST06\n//*\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ONLCLIJ2": {"ttr": 1284, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x01\\x11\\x04/\\x01 \\x13/\\x03\\x00\\x00\\x10\\x00\\x15\\x00\\x00\\xd9\\xe4\\xd5\\xd1\\xc3\\xd3@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2011-02-11T00:00:00", "modifydate": "2020-05-11T03:00:00", "lines": 16, "newlines": 21, "modlines": 0, "user": "RUNJCL"}, "text": "//SBGOLOBS JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//* Purpose of this program is to change the VOLSER of a volume,\n//*  while it is online.  The PARM field contains the new volume id.\n//*\n//* If two disks are online with identical UCB volsers and identical\n//*  volume labels, then specify the specific unit address in the JCL,\n//*  as per the DISKUPD DD name below.\n//*\n//TRK0SAV1 EXEC PGM=ONLCLIP,PARM='work82'       <= New Volume ID\n//STEPLIB  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSPRINT DD  SYSOUT=*\n//SYSUDUMP DD  SYSOUT=*\n//DISKUPD  DD  UNIT=128,SPACE=(TRK,1),VOL=SER=WORK80  <= Device Address\n//*\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ONLCLIP": {"ttr": 1286, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01<\\x00\\x11\\x01\\x11\\x04/\\x01 \\x13/\\x01\\x07\\x02\\xda\\x00\\xe3\\x00\\x00\\xe2\\xd6\\xe4\\xd9\\xc3\\xc5@@@@'", "ispf": {"version": "01.60", "flags": 0, "createdate": "2011-02-11T00:00:00", "modifydate": "2020-05-11T01:07:11", "lines": 730, "newlines": 227, "modlines": 0, "user": "SOURCE"}, "text": "ONLCLIP  TITLE  'ONLCLIP - Program to change the VOLSER of a disk pack'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n* * * *    CHANGE THE VOLSER OF A DISK PACK WHEN IT IS ONLINE   * * * *\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*     This program changes the volume serial of a disk pack, without\n* affecting any IPL text that is there as well.  The disk pack has to\n* be online.\n*\n*     This program requires RACF authority:  READ access to FACILITY\n* class, profile TBCXTUL.\n*\n* Sample JCL:\n* //*\n* //* Purpose of this program is to change the VOLSER of a volume,\n* //*  while it is online.  The PARM field contains the new volume id.\n* //*\n* //useridX  JOB (etc.)\n* //ONLCLIP  EXEC PGM=ONLCLIP,PARM='test03'    (program uppercases it)\n* //STEPLIB  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n* //SYSPRINT DD  SYSOUT=*\n* //SYSUDUMP DD  SYSOUT=*\n* //DISKUPD  DD  UNIT=SYSALLDA,SPACE=(TRK,1),VOL=SER=TEST02\n* //*\n*\n* Blame: Sam Golob.  NOT somitcw@yahoo.com.\n*        Got help from Rick Fochtman.\n*        Cobbled this code from TRK0INIT.  Only change the volser\n*          of the pack, and do not disturb any IPL text that is\n*          already there.\n*\n*  Maximum Size Permitted for\n*  the IPL Program Record\n*  Maximum Bytes\n* Volume Type for IPL Program\n* 2311      3,110\n* 2314      6,514\n* 2319      6,514\n* 3340      7,286\n* 3344      7,286\n* 3330-1   12,117\n* 3330-11  12,117\n* 2305-1   12,180\n* 2305-2   13,616\n* 3350     17,902\n* 3375     33,984\n* 3380     44,948\n* 9345     49,938\n* 3390     53,450\n*\n*\n* Notes from Sam Golob follow:\n*\n* Input for this program is a new volume serial which is in the\n*  PARM field.  After changing the volume serial of the pack, to\n*  \"make it offiical\", you have to take the pack offline and\n*  bring it online again.  In the old days, you also had to do a\n*  MOUNT command, but that was eliminated around the middle of\n*  the OS/390 time, I think.\n*\n* Requires READ access to the FACILITY class profile TBCXTUL.\n*  (CBT spelled backwards, X, TUL for tool.)\n*\n* Program Logic for ONLCLIP.\n*\n*  Stage 0.  OPEN SYSPRINT.\n*            Print the header, and get the value of the new volser\n*              from the JCL PARM field.  Save it in the program.\n*\n*  Stage 0A. RACF protection to use the program. Tests READ access\n*              to the FACILITY class, profile TBCXTUL.\n*\n*  Stage 1.  GETMAIN a 65535 byte buffer.\n*            OPEN DISKUPD DCB for INPUT.\n*            Copy entire track 0 into buffer, including count, key,\n*              and data of each record.\n*            CLOSE DISKUPD DCB.\n*\n*  Stage 2.  Now we will see what to do with this data.\n*            Records 1 and 2 are not disturbed.  The CCW opcode is a\n*              no-op.\n*\n*  Stage 3.  Bump in the buffer to the count field of Record 3.\n*            Copy the previous volser to a saved location, and save\n*              the contents of the VTOC location field as well.\n*            Save all of the rest of the Record 3 data into the\n*              program except the volser.\n*            Copy the buffer's Record 3 into the program, overlaying\n*              the VOL1 storage area.  You now have the contents of\n*              the volume's Record 3, copied into the program.  (This\n*              process has been kludged, but it works, because we then\n*              forcibly overlay the unchanged part of Record 3 with\n*              all the previous unchanged data, besides the volser\n*              field.)  The volser field is then overlaid with the\n*              saved PARM data, after having been uppercased.\n*\n*  Stage 4.  OPEN DISKUPD DCB for UPDAT.\n*            Copy the previous volser from its saved location to the\n*              report.  Copy the new volser from its save area to the\n*              report.  Do not change the rest of Record 3, and write\n*              the record back in place.  X'85' is the \"update in\n*              place\" opcode, which doesn't destroy the subsequent\n*              records in the rest of Track 0.  So only the volume\n*              serial of the pack is changed, and not the rest of\n*              Record 3.  Any IPL text which is subsequent to Record\n*              3, is also not disturbed.\n*            CLOSE DISKUPD DCB.\n*\n*  Stage 5.  FREEMAIN the 65535 byte buffer.\n*            CLOSE SYSPRINT.\n*            End the program.\n*\n*            If no PARM was coded, get out with an informative message.\n*            If no READ access to FACILITY class, profile TBCXTUL,\n*              then get out with an appropriate error message.\n*\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*\n*  Return Code 4 comes when no parms have been coded in the JCL.\n*\n*  Changes:  Version 1.1 - 02/09/2020 - Initial release.\n*\n*            Version 1.2 - 02/10/2020 - Time and Date of Execution\n*\n*            Version 1.3 - 02/16/2020 - UCB messages - unit address\n*                                        and volume serial\n*\n*            Version 1.4 - 02/16/2020 - WTO messages including unit\n*                                        address and volume serial\n*\n*            Version 1.5 - 02/23/2020 - RACF protection. Needs FACILITY\n*                                        CLASS profile TBCXTUL and\n*                                        READ access, to work.\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE\n         MACRO\n         REGS  ,\n         LCLA  &COUNT\n.LOOP    ANOP\nR&COUNT  EQU   &COUNT             Register equate for register &COUNT\n&COUNT   SETA  &COUNT+1\n         AIF   (16 GT &COUNT).LOOP\n         MEND\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         MACRO\n&NAME    HEX   &TO,&LEN,&FROM\n&NAME    DS    0H\n         ST    R9,SAV9HEX\n         STM   R15,R1,HEXSAVE\n         LA    R1,&FROM\n         LA    R0,&LEN\n         LA    R15,&TO\n         BAL   R9,HEX\n         L     R9,SAV9HEX\n         LM    R15,R1,HEXSAVE\n         MEND\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE\n         PRINT ON,GEN,DATA\nONLCLIP  CSECT ,\nONLCLIP  RMODE 24\nONLCLIP  AMODE 31\n         USING *,R15              Set temporary base register\n         SAVE  (14,12),,ONLCLIP.&SYSDATE..&SYSTIME Save Reg.s\n         B     BEGIN\n         DC    CL2' -'\n         DC    CL50'Needs FACILITY class profile TBCXTUL, READ access-'\nBEGIN    DS    0H\n         LA    R12,SAVEAREA       Load address of new save area\n         ST    R12,8(,R13)        Connect old and new save areas\n         ST    R13,4(,R12)        Connect old and new save areas\n         LR    R13,R12            Connect old and new save areas\n         DROP  R15                Drop the temporary base register\n         LR    R12,R15            Load the program's base register\n         USING ONLCLIP,R12,R7     Give the assembler the new bases\n         LA    R7,2048(,R12)\n         LA    R7,2048(,R7)\n         ST    R1,SAVER1A         Save PARM pointer\n         OPEN  (DCBUPD,INPUT)     Open DCB to read original Track 0\n         GETMAIN R,LV=65536       Get Input/Output buffer\n         LR    R11,R1             Save I/O buffer address\n         STCM  R11,B'0111',CCWREAD+1  Store I/O buffer address in CCW\n*\n* ----- >                         At this point we read the PARM\n*                                 field to obtain the new volser.\nINITCON  DS    0H\n         MVI   FLAG0,X'00'\nTESTPARM DS    0H\n         OPEN  (SYSPRINT,OUTPUT)\n***********************************************************************\n*                    GET SYSTEM DATE AND TIME                         *\n***********************************************************************\n         STM   R14,R2,SAVE1402\n         TIME  DEC,DATETIME,LINKAGE=SYSTEM,DATETYPE=MMDDYYYY\n         OI    DATE+4,X'0F'\n         UNPK  DATED,DATE\n         OI    TIME+3,X'0F'\n         UNPK  TIMED,TIME\n*                          FILL HEADER AREA WITH INFO TO REUSE\n         MVC   HEADERD+9(2),DATED\n         MVI   HEADERD+9+2,C'/'\n         MVC   HEADERD+9+3(2),DATED+2\n         MVI   HEADERD+9+5,C'/'\n         MVC   HEADERD+9+6(4),DATED+4\n         MVC   HEADERD+25+7(2),TIMED\n         MVI   HEADERD+25+9,C':'\n         MVC   HEADERD+25+10(2),TIMED+2\n         MVI   HEADERD+25+12,C':'\n         MVC   HEADERD+25+13(2),TIMED+4\n         LM    R14,R2,SAVE1402\n*\n*             PRINT PROGRAM TITLE\n*\n         MVI   OUTLINE-1,X'40'\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+1(34),HEADER\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+1(34),HEADERU\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+1(34),HEADERT\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+1(34),HEADERX\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+1(46),HEADERD\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n***********************************************************************\n*                                                                     *\n*  CHECK THE AUTHORITY OF THE USER TO SAF CLASS \"FACILITY' FOR        *\n*  ENTITY \"TBCXTUL\".  NOTE THAT FASTAUTH IS USED.  TO AVOID THE       *\n*  SITUATION WHERE SPECIAL ATTRIBUTES OF THE USER MAY ALLOW THE       *\n*  ACCESS WITH LOGGING, A CHECK IS MADE FOR A NON-ZERO REASON         *\n*  CODE.  THIS CONDITION WILL BE CONSIDERED A FAILURE.                *\n*                                                                     *\n***********************************************************************\n         NOP   TESTEND\nTEST0    RACROUTE REQUEST=LIST,WORKA=RACWORK,CLASS=FACILITY,           X\n               ENVIR=CREATE,                                           X\n               GLOBAL=YES,                                             X\n               RELEASE=2.2,                                            X\n               MF=S\n***********************************************************************\n*        TEST TBCXTUL  IN THE FACILITY CLASS                          *\n***********************************************************************\nTEST1    MVC   RESOURCE,=CL44'TBCXTUL  '\n         RACROUTE REQUEST=FASTAUTH,WORKA=RACWORK,WKAREA=FRACWORK,      X\n               ENTITY=RESOURCE,CLASS=FACILITY,ATTR=READ,               X\n               MF=(E,RACROUTE)\n         LTR   R15,R15             TEST THE RETURN CODE\n         BNZ   TESTBAD             NOT ZERO, NOT AUTHORIZED\n         CLC   RACROUTE+4(4),=F'0' TEST THE REASON CODE\n         BNE   TESTBAD             ZERO, FULLY AUTHORIZED\n         B     TESTOK\n***********************************************************************\nTESTBAD  DS    0H\nTESTFAIL MVC   RESOURCE,=CL44' '\n         OI    FLAG0,X'02'\n***********************************************************************\n***********************************************************************\n*        CLEANUP AFTER RACROUTE                                       *\n***********************************************************************\nTESTOK   RACROUTE REQUEST=LIST,WORKA=RACWORK,CLASS=FACILITY,           X\n               ENVIR=DELETE,                                           X\n               RELEASE=2.2,                                            X\n               MF=S\n         TM    FLAG0,X'02'\n         BO    NOTAUTHR\nTESTEND  DS    0H\n         EJECT\n***********************************************************************\n*\n*             GET THE NEW VOLSER FROM THE PARM FIELD\n*\n***********************************************************************\n         L     R1,SAVER1A          RESTORE PARM POINTER\n         LTR   R1,R1               ANY PARM POINTER?\n         BZ    NOPARMS             B IF NOT.\n         L     R3,0(,R1)           POINT TO BUFFER\n         LTR   R3,R3               ANY?\n         BZ    NOPARMS             B IF NOT.\n         LH    R4,0(R3)            LOAD LENGTH.\n         LTR   R4,R4               ANY?\n         BZ    NOPARMS             B IF NOT.\n         LA    R3,2(,R3)           POINT TO PARM.\nPARM     OC    0(6,R3),=CL6' '          UPPERCASE.\n         MVC   SAVENVOL(6),0(R3)        Save for plugging in.\n*\n*             DO ALL THE DEB WORK AND GET THE UCB\n* ----- >\n*\n* DEBDVMOD DS    B         DEVICE MODIFIER - FILE MASK\n* DEBUCBA  DS    AL3       ADDRESS OF UCB ASSOCIATED WITH THIS DATA\n* *                        EXTENT\n* DEBBINUM DS    CL2       BIN NUMBER\n* DEBSTRCC DS    CL2       CYLINDER ADDRESS FOR THE START OF AN EXTENT.\n* DEBSTRHH DS    CL2       TRACK ADDRESS FOR THE START OF AN EXTENT.\n* DEBENDCC DS    CL2       CYLINDER ADDRESS FOR THE END OF AN EXTENT.\n*\n* DEBENDHH DS    CL2       TRACK ADDRESS FOR THE END OF AN EXTENT.\n* DEBNMTRK DS    CL2       NUMBER OF TRACKS ALLOCATED TO A GIVEN EXTENT\n*\n         L     R10,DCBUPD+DCBDEBAD-IHADCB   Load DEB address\n         LR    R5,R10                       Addr of DEBBASIC\n         LA    R10,DEBBASND-DEBBASIC(,R10)  Find DEBDASD section\n         USING DEBDASD,R10            Give the assembler the DEB base\n         MVC   SAVEDEB(12),DEBBINUM   Save extent to restore later\n*\n* --- >     At this point we find the UCB information - below\n*\n         MVC   UCBADDR(4),0(R10)      UCB Address is 0 off DEBBASIC\n         TM    15(R5),X'02'           Is DEB31UCB ON--all 4 bits used?\n         BO    NOZERO                 Yes, the UCB is above the line\n         MVI   UCBADDR+0,X'00'        No, the UCB is the last 24 bits\nNOZERO   DS    0H\n         L     R5,UCBADDR             Get the actual UCB address\n         MVC   UCBUNIT(2),4(R5)       Get the unit address in UCB\n         MVC   UCBVOLS(6),28(R5)      Get the volser in the UCB\n*\n* --- >     At this point we find the UCB information - above\n*\n         MODESET KEY=ZERO             Go to key zero to update DEB\n         XC    DEBBINUM(12),DEBBINUM  Set extent to CYL 0 and TRK 0\n         MVI   DEBNMTRK+1,1           Set extent size as one track\n         MODESET KEY=NZERO            Go back to problem progrem key\nREAD     DS    0H                 Read entire Track 0 into the buffer\n         XC    ECBIN,ECBIN        Insure that the ECB is clear\n         EXCP  IOBIN              Read track zero\n         WAIT  ECB=ECBIN          Wait for the read to complete\n         CLI   ECBIN,X'7F'        See if a good read\n         BNE   IOERROR            If not good, go abend\n         SLR   R8,R8              Clear a work register\n         L     R9,F65535          Load max. size that could have read\n         ICM   R8,B'0011',CSWIN+6  Load the residual byte count\n         SR    R9,R8              Find size of track read\n         AR    R9,R11             Find byte after track read\n         MVI   0(R9),X'FF'        Mark byte after end as the end\n         MODESET KEY=ZERO         Go to key zero to update DEB\n         MVC   DEBBINUM(12),SAVEDEB  Restore DEB extent information\n         MODESET KEY=NZERO           Go back to problem program key\n         CLOSE DCBUPD             We are done with the reading in\n         DROP  R10                Don't need DEB address anymore\n* ----------------------------------------------------------------- *\n*  Print the unit address and the volser taken from the UCB.\n* ----------------------------------------------------------------- *\n         MVI   OUTLINE-1,X'40'\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+2(11),=C'UCB Unit:  '\n         HEX   OUTLINE+14,2,UCBUNIT\n         MVC   OUTLINE+22(11),=C'UCB Volser:'\n         MVC   OUTLINE+35(6),UCBVOLS\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n* ----------------------------------------------------------------- *\n*  Now, you've got the Track 0 image in the buffer.\n*  We copy Record 3 into the proper area, and then ignore records 1\n*   and 2.  We update record 3 in place, with modified information,\n*   only in the VOLSER field.\n* ----------------------------------------------------------------- *\n         LR    R9,R11              Load the input track address\n         LA    R9,IPLLEN(,R9)      Point to Record 3\n         CLI   4(R9),3             Check to see if it is Record 3\n         BNE   ERROR1              Not Record 3, error message & quit\n*\n         MVC   VOL1(VOL1L),4(R9)   Overlay VOL1 area with real VOL1\n         MVC   SAVEOVOL(6),16(R9)  Save old VOLSER before change\n         MVC   SAVEVTOC(4),24(R9)  Save the VTOC location\n         MVC   SAVEREST(92),0(R9)  Save almost entire Record 3\n*\n         MVI   OUTLINE-1,X'40'\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+2(17),=C'Old VOLSER was:  '\n         MVC   OUTLINE+19(6),SAVEOVOL   Plug in old volser\n         PUT   SYSPRINT,OUTLINE\n         MVI   OUTLINE-1,X'40'\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+2(17),=C'New VOLSER is :  '\n         MVC   OUTLINE+19(6),SAVENVOL   Plug in new volser from PARM\n         PUT   SYSPRINT,OUTLINE\n         MVI   OUTLINE-1,X'40'\n         MVC   OUTLINE,OUTLINE-1\n*        PUT   SYSPRINT,SAVEREST        Diagnostic\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE+2(38),=C'To make the change permanent, you have'\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+2(38),=C' to VARY the pack OFFLINE and then    '\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+2(38),=C' VARY the pack ONLINE again.          '\n         PUT   SYSPRINT,OUTLINE\n         B     OUTPARM\nNOPARMS  DS    0H                  If no PARM coded, then leave.\n         MVI   OUTLINE-1,X'40'\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+1(35),=C' No parm has been coded in the JCL.'\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+1(21),=C' Nothing was changed.'\n         PUT   SYSPRINT,OUTLINE\nOPMSG2   WTO   'ONLC002 No parm was coded in the JCL--Nothing Changed',+\n               ROUTCDE=11\n         CLOSE SYSPRINT\n         OI    FLAG0,X'01'         Show Return Code of 4\n         B     GOFREE1             Get out of the program.\nNOTAUTHR DS    0H                  If no PARM coded, then leave.\n         MVI   OUTLINE-1,X'40'\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+1(37),=C' You have not been authorized by RACF'\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+1(21),=C' Nothing was changed.'\n         PUT   SYSPRINT,OUTLINE\nOPMSG3   WTO   'ONLC003 Not authorized by RACF--Nothing Changed',      +\n               ROUTCDE=11\n         CLOSE SYSPRINT\n         OI    FLAG0,X'01'         Show Return Code of 4\n         B     GOFREE1             Get out of the program.\nOUTPARM  DS    0H\n         CLOSE SYSPRINT\n* ----------------------------------------------------------------- *\n*   Now, we have to put out the new Track 0 information only for    *\n*    Record 3.  Make sure we keep the VTOC location and the rest    *\n*    of the record as before.                                       *\n* ----------------------------------------------------------------- *\n         OPEN  (DCBUPD,UPDAT)         Now OPEN DCB to update Track 0\n         L     R10,DCBUPD+DCBDEBAD-IHADCB   Load DEB address\n         LA    R10,DEBBASND-DEBBASIC(,R10)  Find DEBDASD section\n         USING DEBDASD,R10            Give the assembler the DEB base\n         MVC   SAVEDEB(12),DEBBINUM   Save extent to restore later\n         MODESET KEY=ZERO             Go to key zero to update DEB\n         XC    DEBBINUM(12),DEBBINUM  Set extent to CYL 0 and TRK 0\n         MVI   DEBNMTRK+1,1           Set extent size as one track\n         MODESET KEY=NZERO            Go back to problem program key\n*\nOREC1    DS    0H                 Write IPL1\n         LA    R1,IPL1            Point to IPL1 record\n         LA    R2,IPL1L           Load its length\n         STH   R2,CCWUPDO+6       Store key and data length in CCW\n         MVI   RO,0               Copy record number to seek\n         STCM  R1,7,CCWUPDO+1     Store I/O buffer address in CCW\n         MVI   CCWUPDO,X'03'      No-op CCW opcode\n         MVC   IOERROR1+X'25'(2),=C'01'  (Diagnostic)\n         BAL   R6,EXCP            Write out the record\n*\nOREC2    DS    0H                 Write IPL2\n         LA    R1,IPL2            Point to IPL2 record\n         LA    R2,IPL2L           Load its length\n         STH   R2,CCWUPDO+6       Store key and data length in CCW\n         MVI   RO,1               Copy record number to seek\n         STCM  R1,7,CCWUPDO+1     Store I/O buffer address in CCW\n         MVI   CCWUPDO,X'03'      No-op CCW opcode\n         MVC   IOERROR1+X'25'(2),=C'02'  (Diagnostic)\n         BAL   R6,EXCP            Write out the record\n*\nOVOL1    DS    0H                 Write Record 3\n         LA    R1,VOL1            Point to VOL1 record\n         LA    R2,VOL1L           Load its length\n         STH   R2,CCWUPDO+6       Store key and data length in CCW\n         MVI   RO,2               Copy record number to seek\n         STCM  R1,7,CCWUPDO+1     Store I/O buffer address in CCW\n         MVI   CCWUPDO,X'03'      No-op CCW opcode\n         MVC   IOERROR1+X'25'(2),=C'03'  (Diagnostic)\n         BAL   R6,EXCP            Write out the record\n*\n*        B     ENDOFPGM\nOVOLS    DS    0H                 Erase record 4 to clear track\n         LA    R1,VOLS            Point to DUMMY record\n         LA    R2,VOLSL           Load its length\n         MVC   VOLSLIT(4),=C'VOL1'\n*   plug in new volser here\n         MVC   VOLSVOL(6),SAVENVOL   New volser\n         MVC   VOLSVTOC(4),SAVEVTOC  Old VTOC location\n         MVC   VOLSREST(64),SAVEREST+28  Rest of Record 3\n         STH   R2,CCWUPDO+6       Store key and data length in CCW\n         MVI   RO,3               Copy record number to seek\n         STCM  R1,7,CCWUPDO+1     Store I/O buffer address in CCW\n         MVI   CCWUPDO,X'85'      Update in place CCW opcode\n         MVC   IOERROR1+X'25'(2),=C'04'  (Diagnostic)\n         BAL   R6,EXCP            Overlay the entire Record 3\n*\nWTO001   DS    0H                 Write to Operator and JES logs\n         HEX   WTOUNIT,2,UCBUNIT      Put unit address into message\n         MVC   WTOOVOL(6),SAVEOVOL    Put old pack id into message\n         MVC   WTONVOL(6),SAVENVOL    Put new pack id into message\n         MVC   WTO0ORIG(6),UCBVOLS    Put UCB volser into message\nOPMSG0   WTO   'ONLC000 Original (UCB) volume serial is: xxxxxx.',     +\n               ROUTCDE=11\nOPMSG1   WTO   'ONLC001 Volume Serial for Unit: uuuu changed from xxxxx+\n               x to yyyyyy.',ROUTCDE=11\nWTO0ORIG EQU   OPMSG0+49,6\nWTOUNIT  EQU   OPMSG1+40,4            Proper location\nWTOOVOL  EQU   OPMSG1+58,6              in\nWTONVOL  EQU   OPMSG1+68,6                mesage\nENDOFPGM DS    0H                 Done. Clean up and get out.\n         MODESET KEY=ZERO            Go to key zero to update DEB\n         MVC   DEBBINUM(12),SAVEDEB  Restore DEB extent information\n         MODESET KEY=NZERO           Go back to problem program key\n         DROP  R10                Don't need DEB address anymore\n         CLOSE DCBUPD             Close the DCB\nGOFREE1  DS    0H\n         FREEMAIN R,LV=65536,A=(R11)  Free the GETMAINed buffer\n         L     R13,4(,R13)        Restore the caller's save area addr.\n         TM    FLAG0,X'01'        Return code 4 ?\n         BZ    RET0               No.\nRET4     DS    0H\n         LM    14,12,12(13)       Return to caller\n         LA    R15,4              Return code 4.\n         BR    14\nRET0     DS    0H\n         LM    14,12,12(13)       Return to caller\n         LA    R15,0              Return code 0.\n         BR    14\n*\nIOERROR  DS    0H\n         WTO   'Input/Output error, Program abending',ROUTCDE=11\n         ABEND 1234,DUMP          Abend with a dump\n         EJECT\nIOERROR1 DS    0H\n         WTO   'Input/Output error, Code = xx ',ROUTCDE=11\n         ABEND 1235,DUMP          Abend with a dump\n         EJECT\nERROR1   DS    0H\n         WTO   'Volume id not copied, Program abending',ROUTCDE=11\n         ABEND 1248,DUMP          Abend with a dump\n         EJECT\n*\nEXCP     DS    0H                 Routine to write a record.\n         ST    R6,SAVER6A         Save BAL register.\n         XC    ECBOUT,ECBOUT      Insure that the ECB is clear\n         EXCP  IOBOUT             Update or add record to track zero\n         WAIT  ECB=ECBOUT         Wait for the update to complete\n*        CLI   ECBOUT,X'7F'\n         TM    ECBOUT,X'40'       See if a good count-key-data write\n*        BNE   IOERROR1           You don't need to test full X'7F'\n         BZ    IOERROR1           If not good, go abend\n         L     R6,SAVER6A         Restore BAL register.\n         BR    R6\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nHEX      DS    0H                HEX Display Routine\n         MVC   1(1,R15),0(R1)        Move byte\n         UNPK  0(3,R15),1(2,R15)     Unpack\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)           Increment output pointer\n         LA    R1,1(,R1)             Increment input pointer\n         BCT   R0,HEX                Decrement length, then loop\n         MVI   0(R15),C' '           Blank the trailing byte\n         BR    R9                    Return to caller\nHEXTAB   DC    C'0123456789ABCDEF'   Translate table\nHEXSAVE  DS    3F\nSAV9HEX  DS    F\n         SPACE\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      DCB's, IOB'S, ECB, and CCW's\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE\nDCBUPD   DCB   DDNAME=DISKUPD,    DD name                              X\n               MACRF=E,           MACRO Reference is EXCP              X\n               DSORG=PS           Data Set Organization\n* DCBLEN   EQU   *-DCBOUT           Length of DCB\nSYSPRINT DCB   MACRF=PM,DDNAME=SYSPRINT,DSORG=PS,RECFM=FBA,LRECL=133\n*  ---  IOB for Input from Track 0\nIOBIN    DS    0D                 Input/output Block\n         DC    XL4'40000000'      Command chaining used\n         DC    A(ECBIN)           Address of the ECB\nCSWIN    DC    D'0'               Channel Status Word\n         DC    A(CCWIN)           Address of the channel command string\n         DC    A(DCBUPD)          Address of the Data Control Block\n         DC    A(0)               IOB Restart\n         DC    XL4'0'             Flags and Counters\nSEEKI    DC    D'0'               Seek address\nSEARCHI  EQU   SEEKI+3,5          Cylinder, Head, and Record to search\nCCHHI    EQU   SEEKI+3,4          Cylinder and Head to seek to\nCCI      EQU   SEEKI+3,2          Cylinder to seek\nHHI      EQU   SEEKI+5,2          Track to seek to\nRI       EQU   SEEKI+7,1          Record to search for\nCCWIN    CCW   X'31',SEARCHI,X'40',5 Search for record zero\n         CCW   8,*-8,0,0          TIC back until search complete\nCCWREAD  CCW   X'5E',*-*,X'20',65535  Read track zero with SLI\n*  ---  IOB for Output to Track 0\nIOBOUT   DS    0D                 Input/output Block for Output\n         DC    XL4'40000000'      Command chaining used\n         DC    A(ECBOUT)          Address of the ECB\nCSWOUT   DC    D'0'               Channel Status Word\n         DC    A(CCWOUT)          Address of the channel command string\n         DC    A(DCBUPD)          Address of the Data Control Block\n         DC    A(0)               IOB Restart\n         DC    XL4'0'             Flags and Counters\nSEEKO    DC    D'0'               Seek address\nSEARCHO  EQU   SEEKO+3,5          Cylinder, Head, and Record to search\nCCHHO    EQU   SEEKO+3,4          Cylinder and Head to seek to\nCCO      EQU   SEEKO+3,2          Cylinder to seek\nHHO      EQU   SEEKO+5,2          Track to seek to\nRO       EQU   SEEKO+7,1          Record to search for\nCCWOUT   CCW   X'31',SEARCHO,X'40',5 Srch for record before one written\n         CCW   8,*-8,0,0          TIC back until search complete\nCCWUPDO  CCW   X'1D',*-*,0,*-*    Update key-data,write count-key-data\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      Workarea and Constants\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nSAVEAREA DC    18F'0'             Register save area\nECBIN    DC    F'0'               Event Control Block\nECBOUT   DC    F'0'               Event Control Block\nSAVEDEB  DS    XL12               Area to save extent after OPEN\nSAVER6A  DC    F'0'               BAL register save area\nSAVEOVOL DC    CL6' '             Old volser\nSAVENVOL DC    CL6' '             New volser\nSAVEVTOC DC    XL4'00'            Preserve VTOC location on disk\nSAVEREST DC    CL92' '            Rest of Record 3, after VTOC loc.\nH8       DC    H'8'               Constant for subtraction\nFLAG0    DC    X'00'              X'01' means Return Code of 4\n*                                 X'02' means NOT RACF AUTHORIZED\nF65535   DC    F'65535'           Buffer size\nUCBUNIT  DC    H'0'               Unit address from the UCB\nUCBVOLS  DC    CL6' '             Volser from UCB\nUCBADDR  DC    F'0'               UCB Address from DEB\nMESSAG01 DS    0F                      AREA FOR PRINTING\nMESS01L  DC    Y(L'MESSAGC1)           MESSAGE LENGTH\nMESSAGC1 DC    CL(69)'ONLC001 Volume Serial for Unit: xxxxxx changed fr+\n               om xxxxxx to yyyyyy.'\n* ------ >>   below     Init track images\nIPL1     DS    0XL36              Canned IPL1 record\nIPL1R    DC    X'0000000001'               5\nIPL1KL   DC    X'040018'                   3\nIPL1K    DC    C'IPL1'                     4   =  12\n         DC    X'000A00000000000F'         8\n         DC    X'0300000000000001'         8\n         DC    X'0000000000000000'         8   =  24 + 12  =  36\nIPL1L    EQU   *-IPL1             IPL1 record length incl count\n* -----\nIPL2     DS    0XL156             Canned IPL2 record\nIPL2R    DC    X'0000000002'               5\nIPL2KL   DC    X'040090'                   3\nIPL2K    DC    C'IPL2'                     4   =  12\n         DC    X'07003AB840000006'         8\n         DC    X'31003ABE40000005'         8\n         DC    X'08003AA000000000'         8\n         DC    X'0600000020000000'         8\n         DC    X'0000000000000000'         8   =  40 + 12  =  52\n         DC    X'000004'                   3   +  52  =  55\n         DC    XL101'00'                   101 +  55  = 156\nIPL2L    EQU   *-IPL2             IPL2 record length incl count\n* -----\nIPLLEN   EQU   *-IPL1             Length of both IPL records\n* -----\n* -----                           VOLS is more used, to replace Rec 3\nVOL1     DS    0XL96              VOLUME ID record - will be overlaid\nVOL1R    DC    X'0000000003'                  5\nVOL1KL   DC    X'040050'                      3\nVOL1K    DC    C'VOL1'                        4   =  12\n         DC    C'VOL1'                        4\nVOL1SER  DC    CL6' '                         6\n         DC    C' '                           1\n         DC    XL5'0000000101' (LOC OF VTOC)  5   =  16 + 12 = 28\n         DC    CL68' '\nVOL1L    EQU   *-VOL1             VOL1 record length incl count\n* ------ >>   above     Init track images\nVOLS     DS    0XL92              Record overlay area for Record 3\nVOLSLIT  DC    C'VOL1'            Second \"VOL1\" in record\nVOLSVOL  DC    CL6' '             New VOLSER here.\nVOLSFIL1 DC    X'4000'            Filler - necessary\nVOLSVTOC DC    XL4'00'            VTOC location to preserve\nVOLSREST DC    CL64' '            Rest of Record 3\nVOLSL    EQU   *-VOLS\n* -----\n         DC    CL1' '\nOUTLINE  DC    CL133' '           Output line for SYSPRINT\n* -----\nSAVE1402 DS    6F                 ONE MORE FOR SAFETY\nHEADER   DC    CL34'  ONLCLIP - Version 1.5 - &SYSDATE'\nHEADERU  DC    CL34'  ------- - ------- --- - --------'\nHEADERT  DC    CL34'           \"ONLINE CLIP\"          '\nHEADERX  DC    CL34'     Time and Date of Execution:  '\nHEADERD  DC    CL46' Date:                  Time:           '\n* ----------------------------------------------------------------- *\n*          Work area for time and date display routine              *\n* ----------------------------------------------------------------- *\nTIMED    DS    CL7\nDATED    DS    CL9\nDATETIME DS    4F\n         ORG   DATETIME\nTIME     DS    CL4\n         DS    CL4\nDATE     DS    CL5\n         DS    CL3\n         EJECT\n***********************************************************************\nSAVER1A  DS    F\nFACILITY DC    CL8'FACILITY'       RACROUTE CLASS NAME\nRESOURCE DC    CL44' '             RACROUTE RESOURCE NAME\nRACROUTE RACROUTE REQUEST=FASTAUTH,MF=L RACROUTE LIST FORM\nRACWORK  DS    CL512               RACROUTE WORK AREA 1\nFRACWORK DS    16F                 RACROUTE WORK AREA 2\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      DSECTs\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n         LTORG ,                  Insure literals are before the DSECTs\n*\n         PRINT GEN\n         DCBD  DSORG=PS,DEVD=DA   DSECT for the Data Control Block\n         IEZDEB LIST=YES          DSECT for the Data Extent Block\n         PRINT NOGEN\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      Register Equates\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE\n         REGS  ,                  User Register equate MACRO\n         END   ,                  The end of the program\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ONLCLIP$": {"ttr": 1541, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x12\\x01\\x11\\x04O\\x01 \\x04\\x1f\\x14V\\x00\\x1c\\x00\\x1c\\x00\\x00\\xc1\\xe2\\xd4\\xd1\\xc3\\xd3@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2011-02-13T00:00:00", "modifydate": "2020-02-10T14:56:12", "lines": 28, "newlines": 28, "modlines": 0, "user": "ASMJCL"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,FLAG(5))\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(ONLCLIP)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,4),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n SETCODE AC(1)\n SETSSI  CB499846\n NAME    ONLCLIP(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ONLCLI00": {"ttr": 1543, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x019\\x00\\x14\\x01\\x11\\x04/\\x01 \\x13/\\t\\x15\\x02\\xd6\\x00\\xe3\\x00\\x00\\xd6\\xd3\\xc4\\xe5\\xc5\\xd9\\xe2@@@'", "ispf": {"version": "01.57", "flags": 0, "createdate": "2011-02-11T00:00:00", "modifydate": "2020-05-11T09:15:14", "lines": 726, "newlines": 227, "modlines": 0, "user": "OLDVERS"}, "text": "ONLCLIP  TITLE  'ONLCLIP - Program to change the VOLSER of a disk pack'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n* * * *    CHANGE THE VOLSER OF A DISK PACK WHEN IT IS ONLINE   * * * *\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*     This program changes the volume serial of a disk pack, without\n* affecting any IPL text that is there as well.  The disk pack has to\n* be online.\n*\n*     This program requires RACF authority:  READ access to FACILITY\n* class, profile TBCXTUL.\n*\n* Sample JCL:\n* //*\n* //* Purpose of this program is to change the VOLSER of a volume,\n* //*  while it is online.  The PARM field contains the new volume id.\n* //*\n* //useridX  JOB (etc.)\n* //ONLCLIP  EXEC PGM=ONLCLIP,PARM='test03'    (program uppercases it)\n* //STEPLIB  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n* //SYSPRINT DD  SYSOUT=*\n* //SYSUDUMP DD  SYSOUT=*\n* //DISKUPD  DD  UNIT=SYSALLDA,SPACE=(TRK,1),VOL=SER=TEST02\n* //*\n*\n* Blame: Sam Golob.  NOT somitcw@yahoo.com.\n*        Got help from Rick Fochtman.\n*        Cobbled this code from TRK0INIT.  Only change the volser\n*          of the pack, and do not disturb any IPL text that is\n*          already there.\n*\n*  Maximum Size Permitted for\n*  the IPL Program Record\n*  Maximum Bytes\n* Volume Type for IPL Program\n* 2311      3,110\n* 2314      6,514\n* 2319      6,514\n* 3340      7,286\n* 3344      7,286\n* 3330-1   12,117\n* 3330-11  12,117\n* 2305-1   12,180\n* 2305-2   13,616\n* 3350     17,902\n* 3375     33,984\n* 3380     44,948\n* 9345     49,938\n* 3390     53,450\n*\n*\n* Notes from Sam Golob follow:\n*\n* Input for this program is a new volume serial which is in the\n*  PARM field.  After changing the volume serial of the pack, to\n*  \"make it offiical\", you have to take the pack offline and\n*  bring it online again.  In the old days, you also had to do a\n*  MOUNT command, but that was eliminated around the middle of\n*  the OS/390 time, I think.\n*\n* Requires READ access to the FACILITY class profile TBCXTUL.\n*  (CBT spelled backwards, X, TUL for tool.)\n*\n* Program Logic for ONLCLIP.\n*\n*  Stage 0.  OPEN SYSPRINT.\n*            Print the header, and get the value of the new volser\n*              from the JCL PARM field.  Save it in the program.\n*\n*  Stage 0A. RACF protection to use the program. Tests READ access\n*              to the FACILITY class, profile TBCXTUL.\n*\n*  Stage 1.  GETMAIN a 65535 byte buffer.\n*            OPEN DISKUPD DCB for INPUT.\n*            Copy entire track 0 into buffer, including count, key,\n*              and data of each record.\n*            CLOSE DISKUPD DCB.\n*\n*  Stage 2.  Now we will see what to do with this data.\n*            Records 1 and 2 are not disturbed.  The CCW opcode is a\n*              no-op.\n*\n*  Stage 3.  Bump in the buffer to the count field of Record 3.\n*            Copy the previous volser to a saved location, and save\n*              the contents of the VTOC location field as well.\n*            Save all of the rest of the Record 3 data into the\n*              program except the volser.\n*            Copy the buffer's Record 3 into the program, overlaying\n*              the VOL1 storage area.  You now have the contents of\n*              the volume's Record 3, copied into the program.  (This\n*              process has been kludged, but it works, because we then\n*              forcibly overlay the unchanged part of Record 3 with\n*              all the previous unchanged data, besides the volser\n*              field.)  The volser field is then overlaid with the\n*              saved PARM data, after having been uppercased.\n*\n*  Stage 4.  OPEN DISKUPD DCB for UPDAT.\n*            Copy the previous volser from its saved location to the\n*              report.  Copy the new volser from its save area to the\n*              report.  Do not change the rest of Record 3, and write\n*              the record back in place.  X'85' is the \"update in\n*              place\" opcode, which doesn't destroy the subsequent\n*              records in the rest of Track 0.  So only the volume\n*              serial of the pack is changed, and not the rest of\n*              Record 3.  Any IPL text which is subsequent to Record\n*              3, is also not disturbed.\n*            CLOSE DISKUPD DCB.\n*\n*  Stage 5.  FREEMAIN the 65535 byte buffer.\n*            CLOSE SYSPRINT.\n*            End the program.\n*\n*            If no PARM was coded, get out with an informative message.\n*            If no READ access to FACILITY class, profile TBCXTUL,\n*              then get out with an appropriate error message.\n*\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*\n*  Return Code 4 comes when no parms have been coded in the JCL.\n*\n*  Changes:  Version 1.1 - 02/09/2020 - Initial release.\n*\n*            Version 1.2 - 02/10/2020 - Time and Date of Execution\n*\n*            Version 1.3 - 02/16/2020 - UCB messages - unit address\n*                                        and volume serial\n*\n*            Version 1.4 - 02/16/2020 - WTO messages including unit\n*                                        address and volume serial\n*\n*            Version 1.5 - 02/23/2020 - RACF protection. Needs FACILITY\n*                                        CLASS profile TBCXTUL and\n*                                        READ access, to work.\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE\n         MACRO\n         REGS  ,\n         LCLA  &COUNT\n.LOOP    ANOP\nR&COUNT  EQU   &COUNT             Register equate for register &COUNT\n&COUNT   SETA  &COUNT+1\n         AIF   (16 GT &COUNT).LOOP\n         MEND\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         MACRO\n&NAME    HEX   &TO,&LEN,&FROM\n&NAME    DS    0H\n         ST    R9,SAV9HEX\n         STM   R15,R1,HEXSAVE\n         LA    R1,&FROM\n         LA    R0,&LEN\n         LA    R15,&TO\n         BAL   R9,HEX\n         L     R9,SAV9HEX\n         LM    R15,R1,HEXSAVE\n         MEND\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE\n         PRINT ON,GEN,DATA\nONLCLIP  CSECT ,\nONLCLIP  RMODE 24\nONLCLIP  AMODE 31\n         USING *,R15              Set temporary base register\n         SAVE  (14,12),,ONLCLIP.&SYSDATE..&SYSTIME Save Reg.s\n         LA    R12,SAVEAREA       Load address of new save area\n         ST    R12,8(,R13)        Connect old and new save areas\n         ST    R13,4(,R12)        Connect old and new save areas\n         LR    R13,R12            Connect old and new save areas\n         DROP  R15                Drop the temporary base register\n         LR    R12,R15            Load the program's base register\n         USING ONLCLIP,R12,R7     Give the assembler the new bases\n         LA    R7,2048(,R12)\n         LA    R7,2048(,R7)\n         ST    R1,SAVER1A         Save PARM pointer\n         OPEN  (DCBUPD,INPUT)     Open DCB to read original Track 0\n         GETMAIN R,LV=65536       Get Input/Output buffer\n         LR    R11,R1             Save I/O buffer address\n         STCM  R11,B'0111',CCWREAD+1  Store I/O buffer address in CCW\n*\n* ----- >                         At this point we read the PARM\n*                                 field to obtain the new volser.\nINITCON  DS    0H\n         MVI   FLAG0,X'00'\nTESTPARM DS    0H\n         OPEN  (SYSPRINT,OUTPUT)\n***********************************************************************\n*                    GET SYSTEM DATE AND TIME                         *\n***********************************************************************\n         STM   R14,R2,SAVE1402\n         TIME  DEC,DATETIME,LINKAGE=SYSTEM,DATETYPE=MMDDYYYY\n         OI    DATE+4,X'0F'\n         UNPK  DATED,DATE\n         OI    TIME+3,X'0F'\n         UNPK  TIMED,TIME\n*                          FILL HEADER AREA WITH INFO TO REUSE\n         MVC   HEADERD+9(2),DATED\n         MVI   HEADERD+9+2,C'/'\n         MVC   HEADERD+9+3(2),DATED+2\n         MVI   HEADERD+9+5,C'/'\n         MVC   HEADERD+9+6(4),DATED+4\n         MVC   HEADERD+25+7(2),TIMED\n         MVI   HEADERD+25+9,C':'\n         MVC   HEADERD+25+10(2),TIMED+2\n         MVI   HEADERD+25+12,C':'\n         MVC   HEADERD+25+13(2),TIMED+4\n         LM    R14,R2,SAVE1402\n*\n*             PRINT PROGRAM TITLE\n*\n         MVI   OUTLINE-1,X'40'\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+1(34),HEADER\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+1(34),HEADERU\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+1(34),HEADERT\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+1(34),HEADERX\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+1(46),HEADERD\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n***********************************************************************\n*                                                                     *\n*  CHECK THE AUTHORITY OF THE USER TO SAF CLASS \"FACILITY' FOR        *\n*  ENTITY \"TBCXTUL\".  NOTE THAT FASTAUTH IS USED.  TO AVOID THE       *\n*  SITUATION WHERE SPECIAL ATTRIBUTES OF THE USER MAY ALLOW THE       *\n*  ACCESS WITH LOGGING, A CHECK IS MADE FOR A NON-ZERO REASON         *\n*  CODE.  THIS CONDITION WILL BE CONSIDERED A FAILURE.                *\n*                                                                     *\n***********************************************************************\n         NOP   TESTEND\nTEST0    RACROUTE REQUEST=LIST,WORKA=RACWORK,CLASS=FACILITY,           X\n               ENVIR=CREATE,                                           X\n               GLOBAL=YES,                                             X\n               RELEASE=2.2,                                            X\n               MF=S\n***********************************************************************\n*        TEST TBCXTUL  IN THE FACILITY CLASS                          *\n***********************************************************************\nTEST1    MVC   RESOURCE,=CL44'TBCXTUL  '\n         RACROUTE REQUEST=FASTAUTH,WORKA=RACWORK,WKAREA=FRACWORK,      X\n               ENTITY=RESOURCE,CLASS=FACILITY,ATTR=READ,               X\n               MF=(E,RACROUTE)\n         LTR   R15,R15             TEST THE RETURN CODE\n         BNZ   TESTBAD             NOT ZERO, NOT AUTHORIZED\n         CLC   RACROUTE+4(4),=F'0' TEST THE REASON CODE\n         BNE   TESTBAD             ZERO, FULLY AUTHORIZED\n         B     TESTOK\n***********************************************************************\nTESTBAD  DS    0H\nTESTFAIL MVC   RESOURCE,=CL44' '\n         OI    FLAG0,X'02'\n***********************************************************************\n***********************************************************************\n*        CLEANUP AFTER RACROUTE                                       *\n***********************************************************************\nTESTOK   RACROUTE REQUEST=LIST,WORKA=RACWORK,CLASS=FACILITY,           X\n               ENVIR=DELETE,                                           X\n               RELEASE=2.2,                                            X\n               MF=S\n         TM    FLAG0,X'02'\n         BO    NOTAUTHR\nTESTEND  DS    0H\n         EJECT\n***********************************************************************\n*\n*             GET THE NEW VOLSER FROM THE PARM FIELD\n*\n***********************************************************************\n         L     R1,SAVER1A          RESTORE PARM POINTER\n         LTR   R1,R1               ANY PARM POINTER?\n         BZ    NOPARMS             B IF NOT.\n         L     R3,0(,R1)           POINT TO BUFFER\n         LTR   R3,R3               ANY?\n         BZ    NOPARMS             B IF NOT.\n         LH    R4,0(R3)            LOAD LENGTH.\n         LTR   R4,R4               ANY?\n         BZ    NOPARMS             B IF NOT.\n         LA    R3,2(,R3)           POINT TO PARM.\nPARM     OC    0(6,R3),=CL6' '          UPPERCASE.\n         MVC   SAVENVOL(6),0(R3)        Save for plugging in.\n*\n*             DO ALL THE DEB WORK AND GET THE UCB\n* ----- >\n*\n* DEBDVMOD DS    B         DEVICE MODIFIER - FILE MASK\n* DEBUCBA  DS    AL3       ADDRESS OF UCB ASSOCIATED WITH THIS DATA\n* *                        EXTENT\n* DEBBINUM DS    CL2       BIN NUMBER\n* DEBSTRCC DS    CL2       CYLINDER ADDRESS FOR THE START OF AN EXTENT.\n* DEBSTRHH DS    CL2       TRACK ADDRESS FOR THE START OF AN EXTENT.\n* DEBENDCC DS    CL2       CYLINDER ADDRESS FOR THE END OF AN EXTENT.\n*\n* DEBENDHH DS    CL2       TRACK ADDRESS FOR THE END OF AN EXTENT.\n* DEBNMTRK DS    CL2       NUMBER OF TRACKS ALLOCATED TO A GIVEN EXTENT\n*\n         L     R10,DCBUPD+DCBDEBAD-IHADCB   Load DEB address\n         LR    R5,R10                       Addr of DEBBASIC\n         LA    R10,DEBBASND-DEBBASIC(,R10)  Find DEBDASD section\n         USING DEBDASD,R10            Give the assembler the DEB base\n         MVC   SAVEDEB(12),DEBBINUM   Save extent to restore later\n*\n* --- >     At this point we find the UCB information - below\n*\n         MVC   UCBADDR(4),0(R10)      UCB Address is 0 off DEBBASIC\n         TM    15(R5),X'02'           Is DEB31UCB ON--all 4 bits used?\n         BO    NOZERO                 Yes, the UCB is above the line\n         MVI   UCBADDR+0,X'00'        No, the UCB is the last 24 bits\nNOZERO   DS    0H\n         L     R5,UCBADDR             Get the actual UCB address\n         MVC   UCBUNIT(2),4(R5)       Get the unit address in UCB\n         MVC   UCBVOLS(6),28(R5)      Get the volser in the UCB\n*\n* --- >     At this point we find the UCB information - above\n*\n         MODESET KEY=ZERO             Go to key zero to update DEB\n         XC    DEBBINUM(12),DEBBINUM  Set extent to CYL 0 and TRK 0\n         MVI   DEBNMTRK+1,1           Set extent size as one track\n         MODESET KEY=NZERO            Go back to problem progrem key\nREAD     DS    0H                 Read entire Track 0 into the buffer\n         XC    ECBIN,ECBIN        Insure that the ECB is clear\n         EXCP  IOBIN              Read track zero\n         WAIT  ECB=ECBIN          Wait for the read to complete\n         CLI   ECBIN,X'7F'        See if a good read\n         BNE   IOERROR            If not good, go abend\n         SLR   R8,R8              Clear a work register\n         L     R9,F65535          Load max. size that could have read\n         ICM   R8,B'0011',CSWIN+6  Load the residual byte count\n         SR    R9,R8              Find size of track read\n         AR    R9,R11             Find byte after track read\n         MVI   0(R9),X'FF'        Mark byte after end as the end\n         MODESET KEY=ZERO         Go to key zero to update DEB\n         MVC   DEBBINUM(12),SAVEDEB  Restore DEB extent information\n         MODESET KEY=NZERO           Go back to problem program key\n         CLOSE DCBUPD             We are done with the reading in\n         DROP  R10                Don't need DEB address anymore\n* ----------------------------------------------------------------- *\n*  Print the unit address and the volser taken from the UCB.\n* ----------------------------------------------------------------- *\n         MVI   OUTLINE-1,X'40'\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+2(11),=C'UCB Unit:  '\n         HEX   OUTLINE+14,2,UCBUNIT\n         MVC   OUTLINE+22(11),=C'UCB Volser:'\n         MVC   OUTLINE+35(6),UCBVOLS\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n* ----------------------------------------------------------------- *\n*  Now, you've got the Track 0 image in the buffer.\n*  We copy Record 3 into the proper area, and then ignore records 1\n*   and 2.  We update record 3 in place, with modified information,\n*   only in the VOLSER field.\n* ----------------------------------------------------------------- *\n         LR    R9,R11              Load the input track address\n         LA    R9,IPLLEN(,R9)      Point to Record 3\n         CLI   4(R9),3             Check to see if it is Record 3\n         BNE   ERROR1              Not Record 3, error message & quit\n*\n         MVC   VOL1(VOL1L),4(R9)   Overlay VOL1 area with real VOL1\n         MVC   SAVEOVOL(6),16(R9)  Save old VOLSER before change\n         MVC   SAVEVTOC(4),24(R9)  Save the VTOC location\n         MVC   SAVEREST(92),0(R9)  Save almost entire Record 3\n*\n         MVI   OUTLINE-1,X'40'\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+2(17),=C'Old VOLSER was:  '\n         MVC   OUTLINE+19(6),SAVEOVOL   Plug in old volser\n         PUT   SYSPRINT,OUTLINE\n         MVI   OUTLINE-1,X'40'\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+2(17),=C'New VOLSER is :  '\n         MVC   OUTLINE+19(6),SAVENVOL   Plug in new volser from PARM\n         PUT   SYSPRINT,OUTLINE\n         MVI   OUTLINE-1,X'40'\n         MVC   OUTLINE,OUTLINE-1\n*        PUT   SYSPRINT,SAVEREST        Diagnostic\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE+2(38),=C'To make the change permanent, you have'\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+2(38),=C' to VARY the pack OFFLINE and then    '\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+2(38),=C' VARY the pack ONLINE again.          '\n         PUT   SYSPRINT,OUTLINE\n         B     OUTPARM\nNOPARMS  DS    0H                  If no PARM coded, then leave.\n         MVI   OUTLINE-1,X'40'\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+1(35),=C' No parm has been coded in the JCL.'\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+1(21),=C' Nothing was changed.'\n         PUT   SYSPRINT,OUTLINE\nOPMSG2   WTO   'ONLC002 No parm was coded in the JCL--Nothing Changed',+\n               ROUTCDE=11\n         CLOSE SYSPRINT\n         OI    FLAG0,X'01'         Show Return Code of 4\n         B     GOFREE1             Get out of the program.\nNOTAUTHR DS    0H                  If no PARM coded, then leave.\n         MVI   OUTLINE-1,X'40'\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+1(37),=C' You have not been authorized by RACF'\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+1(21),=C' Nothing was changed.'\n         PUT   SYSPRINT,OUTLINE\nOPMSG3   WTO   'ONLC003 Not authorized by RACF--Nothing Changed',      +\n               ROUTCDE=11\n         CLOSE SYSPRINT\n         OI    FLAG0,X'01'         Show Return Code of 4\n         B     GOFREE1             Get out of the program.\nOUTPARM  DS    0H\n         CLOSE SYSPRINT\n* ----------------------------------------------------------------- *\n*   Now, we have to put out the new Track 0 information only for    *\n*    Record 3.  Make sure we keep the VTOC location and the rest    *\n*    of the record as before.                                       *\n* ----------------------------------------------------------------- *\n         OPEN  (DCBUPD,UPDAT)         Now OPEN DCB to update Track 0\n         L     R10,DCBUPD+DCBDEBAD-IHADCB   Load DEB address\n         LA    R10,DEBBASND-DEBBASIC(,R10)  Find DEBDASD section\n         USING DEBDASD,R10            Give the assembler the DEB base\n         MVC   SAVEDEB(12),DEBBINUM   Save extent to restore later\n         MODESET KEY=ZERO             Go to key zero to update DEB\n         XC    DEBBINUM(12),DEBBINUM  Set extent to CYL 0 and TRK 0\n         MVI   DEBNMTRK+1,1           Set extent size as one track\n         MODESET KEY=NZERO            Go back to problem program key\n*\nOREC1    DS    0H                 Write IPL1\n         LA    R1,IPL1            Point to IPL1 record\n         LA    R2,IPL1L           Load its length\n         STH   R2,CCWUPDO+6       Store key and data length in CCW\n         MVI   RO,0               Copy record number to seek\n         STCM  R1,7,CCWUPDO+1     Store I/O buffer address in CCW\n         MVI   CCWUPDO,X'03'      No-op CCW opcode\n         MVC   IOERROR1+X'25'(2),=C'01'  (Diagnostic)\n         BAL   R6,EXCP            Write out the record\n*\nOREC2    DS    0H                 Write IPL2\n         LA    R1,IPL2            Point to IPL2 record\n         LA    R2,IPL2L           Load its length\n         STH   R2,CCWUPDO+6       Store key and data length in CCW\n         MVI   RO,1               Copy record number to seek\n         STCM  R1,7,CCWUPDO+1     Store I/O buffer address in CCW\n         MVI   CCWUPDO,X'03'      No-op CCW opcode\n         MVC   IOERROR1+X'25'(2),=C'02'  (Diagnostic)\n         BAL   R6,EXCP            Write out the record\n*\nOVOL1    DS    0H                 Write Record 3\n         LA    R1,VOL1            Point to VOL1 record\n         LA    R2,VOL1L           Load its length\n         STH   R2,CCWUPDO+6       Store key and data length in CCW\n         MVI   RO,2               Copy record number to seek\n         STCM  R1,7,CCWUPDO+1     Store I/O buffer address in CCW\n         MVI   CCWUPDO,X'03'      No-op CCW opcode\n         MVC   IOERROR1+X'25'(2),=C'03'  (Diagnostic)\n         BAL   R6,EXCP            Write out the record\n*\n*        B     ENDOFPGM\nOVOLS    DS    0H                 Erase record 4 to clear track\n         LA    R1,VOLS            Point to DUMMY record\n         LA    R2,VOLSL           Load its length\n         MVC   VOLSLIT(4),=C'VOL1'\n*   plug in new volser here\n         MVC   VOLSVOL(6),SAVENVOL   New volser\n         MVC   VOLSVTOC(4),SAVEVTOC  Old VTOC location\n         MVC   VOLSREST(64),SAVEREST+28  Rest of Record 3\n         STH   R2,CCWUPDO+6       Store key and data length in CCW\n         MVI   RO,3               Copy record number to seek\n         STCM  R1,7,CCWUPDO+1     Store I/O buffer address in CCW\n         MVI   CCWUPDO,X'85'      Update in place CCW opcode\n         MVC   IOERROR1+X'25'(2),=C'04'  (Diagnostic)\n         BAL   R6,EXCP            Overlay the entire Record 3\n*\nWTO001   DS    0H                 Write to Operator and JES logs\n         HEX   WTOUNIT,2,UCBUNIT      Put unit address into message\n         MVC   WTOOVOL(6),SAVEOVOL    Put old pack id into message\n         MVC   WTONVOL(6),SAVENVOL    Put new pack id into message\n         MVC   WTO0ORIG(6),UCBVOLS    Put UCB volser into message\nOPMSG0   WTO   'ONLC000 Original (UCB) volume serial is: xxxxxx.',     +\n               ROUTCDE=11\nOPMSG1   WTO   'ONLC001 Volume Serial for Unit: uuuu changed from xxxxx+\n               x to yyyyyy.',ROUTCDE=11\nWTO0ORIG EQU   OPMSG0+49,6\nWTOUNIT  EQU   OPMSG1+40,4            Proper location\nWTOOVOL  EQU   OPMSG1+58,6              in\nWTONVOL  EQU   OPMSG1+68,6                mesage\nENDOFPGM DS    0H                 Done. Clean up and get out.\n         MODESET KEY=ZERO            Go to key zero to update DEB\n         MVC   DEBBINUM(12),SAVEDEB  Restore DEB extent information\n         MODESET KEY=NZERO           Go back to problem program key\n         DROP  R10                Don't need DEB address anymore\n         CLOSE DCBUPD             Close the DCB\nGOFREE1  DS    0H\n         FREEMAIN R,LV=65536,A=(R11)  Free the GETMAINed buffer\n         L     R13,4(,R13)        Restore the caller's save area addr.\n         TM    FLAG0,X'01'        Return code 4 ?\n         BZ    RET0               No.\nRET4     DS    0H\n         LM    14,12,12(13)       Return to caller\n         LA    R15,4              Return code 4.\n         BR    14\nRET0     DS    0H\n         LM    14,12,12(13)       Return to caller\n         LA    R15,0              Return code 0.\n         BR    14\n*\nIOERROR  DS    0H\n         WTO   'Input/Output error, Program abending',ROUTCDE=11\n         ABEND 1234,DUMP          Abend with a dump\n         EJECT\nIOERROR1 DS    0H\n         WTO   'Input/Output error, Code = xx ',ROUTCDE=11\n         ABEND 1235,DUMP          Abend with a dump\n         EJECT\nERROR1   DS    0H\n         WTO   'Volume id not copied, Program abending',ROUTCDE=11\n         ABEND 1248,DUMP          Abend with a dump\n         EJECT\n*\nEXCP     DS    0H                 Routine to write a record.\n         ST    R6,SAVER6A         Save BAL register.\n         XC    ECBOUT,ECBOUT      Insure that the ECB is clear\n         EXCP  IOBOUT             Update or add record to track zero\n         WAIT  ECB=ECBOUT         Wait for the update to complete\n*        CLI   ECBOUT,X'7F'\n         TM    ECBOUT,X'40'       See if a good count-key-data write\n*        BNE   IOERROR1           You don't need to test full X'7F'\n         BZ    IOERROR1           If not good, go abend\n         L     R6,SAVER6A         Restore BAL register.\n         BR    R6\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nHEX      DS    0H                HEX Display Routine\n         MVC   1(1,R15),0(R1)        Move byte\n         UNPK  0(3,R15),1(2,R15)     Unpack\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)           Increment output pointer\n         LA    R1,1(,R1)             Increment input pointer\n         BCT   R0,HEX                Decrement length, then loop\n         MVI   0(R15),C' '           Blank the trailing byte\n         BR    R9                    Return to caller\nHEXTAB   DC    C'0123456789ABCDEF'   Translate table\nHEXSAVE  DS    3F\nSAV9HEX  DS    F\n         SPACE\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      DCB's, IOB'S, ECB, and CCW's\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE\nDCBUPD   DCB   DDNAME=DISKUPD,    DD name                              X\n               MACRF=E,           MACRO Reference is EXCP              X\n               DSORG=PS           Data Set Organization\n* DCBLEN   EQU   *-DCBOUT           Length of DCB\nSYSPRINT DCB   MACRF=PM,DDNAME=SYSPRINT,DSORG=PS,RECFM=FBA,LRECL=133\n*  ---  IOB for Input from Track 0\nIOBIN    DS    0D                 Input/output Block\n         DC    XL4'40000000'      Command chaining used\n         DC    A(ECBIN)           Address of the ECB\nCSWIN    DC    D'0'               Channel Status Word\n         DC    A(CCWIN)           Address of the channel command string\n         DC    A(DCBUPD)          Address of the Data Control Block\n         DC    A(0)               IOB Restart\n         DC    XL4'0'             Flags and Counters\nSEEKI    DC    D'0'               Seek address\nSEARCHI  EQU   SEEKI+3,5          Cylinder, Head, and Record to search\nCCHHI    EQU   SEEKI+3,4          Cylinder and Head to seek to\nCCI      EQU   SEEKI+3,2          Cylinder to seek\nHHI      EQU   SEEKI+5,2          Track to seek to\nRI       EQU   SEEKI+7,1          Record to search for\nCCWIN    CCW   X'31',SEARCHI,X'40',5 Search for record zero\n         CCW   8,*-8,0,0          TIC back until search complete\nCCWREAD  CCW   X'5E',*-*,X'20',65535  Read track zero with SLI\n*  ---  IOB for Output to Track 0\nIOBOUT   DS    0D                 Input/output Block for Output\n         DC    XL4'40000000'      Command chaining used\n         DC    A(ECBOUT)          Address of the ECB\nCSWOUT   DC    D'0'               Channel Status Word\n         DC    A(CCWOUT)          Address of the channel command string\n         DC    A(DCBUPD)          Address of the Data Control Block\n         DC    A(0)               IOB Restart\n         DC    XL4'0'             Flags and Counters\nSEEKO    DC    D'0'               Seek address\nSEARCHO  EQU   SEEKO+3,5          Cylinder, Head, and Record to search\nCCHHO    EQU   SEEKO+3,4          Cylinder and Head to seek to\nCCO      EQU   SEEKO+3,2          Cylinder to seek\nHHO      EQU   SEEKO+5,2          Track to seek to\nRO       EQU   SEEKO+7,1          Record to search for\nCCWOUT   CCW   X'31',SEARCHO,X'40',5 Srch for record before one written\n         CCW   8,*-8,0,0          TIC back until search complete\nCCWUPDO  CCW   X'1D',*-*,0,*-*    Update key-data,write count-key-data\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      Workarea and Constants\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nSAVEAREA DC    18F'0'             Register save area\nECBIN    DC    F'0'               Event Control Block\nECBOUT   DC    F'0'               Event Control Block\nSAVEDEB  DS    XL12               Area to save extent after OPEN\nSAVER6A  DC    F'0'               BAL register save area\nSAVEOVOL DC    CL6' '             Old volser\nSAVENVOL DC    CL6' '             New volser\nSAVEVTOC DC    XL4'00'            Preserve VTOC location on disk\nSAVEREST DC    CL92' '            Rest of Record 3, after VTOC loc.\nH8       DC    H'8'               Constant for subtraction\nFLAG0    DC    X'00'              X'01' means Return Code of 4\n*                                 X'02' means NOT RACF AUTHORIZED\nF65535   DC    F'65535'           Buffer size\nUCBUNIT  DC    H'0'               Unit address from the UCB\nUCBVOLS  DC    CL6' '             Volser from UCB\nUCBADDR  DC    F'0'               UCB Address from DEB\nMESSAG01 DS    0F                      AREA FOR PRINTING\nMESS01L  DC    Y(L'MESSAGC1)           MESSAGE LENGTH\nMESSAGC1 DC    CL(69)'ONLC001 Volume Serial for Unit: xxxxxx changed fr+\n               om xxxxxx to yyyyyy.'\n* ------ >>   below     Init track images\nIPL1     DS    0XL36              Canned IPL1 record\nIPL1R    DC    X'0000000001'               5\nIPL1KL   DC    X'040018'                   3\nIPL1K    DC    C'IPL1'                     4   =  12\n         DC    X'000A00000000000F'         8\n         DC    X'0300000000000001'         8\n         DC    X'0000000000000000'         8   =  24 + 12  =  36\nIPL1L    EQU   *-IPL1             IPL1 record length incl count\n* -----\nIPL2     DS    0XL156             Canned IPL2 record\nIPL2R    DC    X'0000000002'               5\nIPL2KL   DC    X'040090'                   3\nIPL2K    DC    C'IPL2'                     4   =  12\n         DC    X'07003AB840000006'         8\n         DC    X'31003ABE40000005'         8\n         DC    X'08003AA000000000'         8\n         DC    X'0600000020000000'         8\n         DC    X'0000000000000000'         8   =  40 + 12  =  52\n         DC    X'000004'                   3   +  52  =  55\n         DC    XL101'00'                   101 +  55  = 156\nIPL2L    EQU   *-IPL2             IPL2 record length incl count\n* -----\nIPLLEN   EQU   *-IPL1             Length of both IPL records\n* -----\n* -----                           VOLS is more used, to replace Rec 3\nVOL1     DS    0XL96              VOLUME ID record - will be overlaid\nVOL1R    DC    X'0000000003'                  5\nVOL1KL   DC    X'040050'                      3\nVOL1K    DC    C'VOL1'                        4   =  12\n         DC    C'VOL1'                        4\nVOL1SER  DC    CL6' '                         6\n         DC    C' '                           1\n         DC    XL5'0000000101' (LOC OF VTOC)  5   =  16 + 12 = 28\n         DC    CL68' '\nVOL1L    EQU   *-VOL1             VOL1 record length incl count\n* ------ >>   above     Init track images\nVOLS     DS    0XL92              Record overlay area for Record 3\nVOLSLIT  DC    C'VOL1'            Second \"VOL1\" in record\nVOLSVOL  DC    CL6' '             New VOLSER here.\nVOLSFIL1 DC    X'4000'            Filler - necessary\nVOLSVTOC DC    XL4'00'            VTOC location to preserve\nVOLSREST DC    CL64' '            Rest of Record 3\nVOLSL    EQU   *-VOLS\n* -----\n         DC    CL1' '\nOUTLINE  DC    CL133' '           Output line for SYSPRINT\n* -----\nSAVE1402 DS    6F                 ONE MORE FOR SAFETY\nHEADER   DC    CL34'  ONLCLIP - Version 1.5 - &SYSDATE'\nHEADERU  DC    CL34'  ------- - ------- --- - --------'\nHEADERT  DC    CL34'           \"ONLINE CLIP\"          '\nHEADERX  DC    CL34'     Time and Date of Execution:  '\nHEADERD  DC    CL46' Date:                  Time:           '\n* ----------------------------------------------------------------- *\n*          Work area for time and date display routine              *\n* ----------------------------------------------------------------- *\nTIMED    DS    CL7\nDATED    DS    CL9\nDATETIME DS    4F\n         ORG   DATETIME\nTIME     DS    CL4\n         DS    CL4\nDATE     DS    CL5\n         DS    CL3\n         EJECT\n***********************************************************************\nSAVER1A  DS    F\nFACILITY DC    CL8'FACILITY'       RACROUTE CLASS NAME\nRESOURCE DC    CL44' '             RACROUTE RESOURCE NAME\nRACROUTE RACROUTE REQUEST=FASTAUTH,MF=L RACROUTE LIST FORM\nRACWORK  DS    CL512               RACROUTE WORK AREA 1\nFRACWORK DS    16F                 RACROUTE WORK AREA 2\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      DSECTs\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n         LTORG ,                  Insure literals are before the DSECTs\n*\n         PRINT GEN\n         DCBD  DSORG=PS,DEVD=DA   DSECT for the Data Control Block\n         IEZDEB LIST=YES          DSECT for the Data Extent Block\n         PRINT NOGEN\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      Register Equates\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE\n         REGS  ,                  User Register equate MACRO\n         END   ,                  The end of the program\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TRK0INI$": {"ttr": 1800, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00V\\x01\\x11\\x04O\\x01\\x11\\x06o\\x155\\x00\\x1c\\x00\\x1c\\x00\\x00\\xc1\\xe2\\xd4\\xd1\\xc3\\xd3@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2011-02-13T00:00:00", "modifydate": "2011-03-07T15:35:56", "lines": 28, "newlines": 28, "modlines": 0, "user": "ASMJCL"}, "text": "//IBMUSERU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,FLAG(5))\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSIN    DD DISP=SHR,DSN=IBMUSER.B.ASM(TRK0INIT)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,4),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n SETCODE AC(1)\n SETSSI  CB482846\n NAME    TRK0INIT(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TRK0INIJ": {"ttr": 1802, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x17\\x01\\x11\\x04/\\x01\\x11\\x06\\x8f\\x01P\\x00\\x11\\x00\\x15\\x00\\x00\\xd9\\xe4\\xd5\\xd1\\xc3\\xd3@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2011-02-11T00:00:00", "modifydate": "2011-03-09T01:50:17", "lines": 17, "newlines": 21, "modlines": 0, "user": "RUNJCL"}, "text": "//IBMUSERS JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//* Purpose of this program is to remove IPL text from a volume,\n//*  and restore the volume to its original ICKDSF initted state,\n//*  in Track 0.\n//*   -------------------------------------------------\n//*    IF YOU ARE ERASING THE IPL TEXT OFF A DISK PACK,\n//*    YOU SHOULD PLEASE MAKE SURE THAT YOU BACK IT UP\n//*    FIRST, USING TRK0SAVE.  THEN YOU CAN RESTORE IT\n//*    LATER WITH TRK0UPD.\n//*   -------------------------------------------------\n//TRK0SAV1 EXEC PGM=TRK0INIT\n//STEPLIB  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSUDUMP DD  SYSOUT=*\n//DISKUPD  DD  UNIT=SYSALLDA,SPACE=(TRK,1),VOL=SER=TEST01\n//*\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TRK0INIT": {"ttr": 1804, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01 \\x00'\\x01\\x11\\x04/\\x01 \\x00/\\x13G\\x01w\\x00\\xe3\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@\"", "ispf": {"version": "01.32", "flags": 0, "createdate": "2011-02-11T00:00:00", "modifydate": "2020-01-02T13:47:27", "lines": 375, "newlines": 227, "modlines": 0, "user": "SBGOLOB"}, "text": "TRK0INIT TITLE 'TRK0INIT - Program to remove IPL text from track 0'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*     This program removes IPL text from a volume, if it previously\n* existed there.  Record 3 of the volume, which points to the VTOC\n* location and which contains the Volume ID, remains unchanged.\n*\n* Sample JCL:\n*\n* //useridX  JOB (etc.)\n* //TRK0SAV1 EXEC PGM=TRK0INIT     (Remove IPL Text from a pack)\n* //STEPLIB  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n* //SYSUDUMP DD  SYSOUT=*\n* //DISKUPD  DD  UNIT=SYSALLDA,SPACE=(TRK,1),VOL=SER=TEST01\n* //*\n*\n* Blame: Sam Golob.  NOT somitcw@yahoo.com.\n*        Got help from Rick Fochtman.\n*        Original idea came from somitcw@yahoo.com and his other\n*          programs, TRK0SAVE and TRK0UPD.  Copied some code\n*          from there, but not exactly the same, here.\n*\n* Format of initted IPL records on a pack was\n* extracted from DSF Users Guide R17, Table 56.\n*\n*  Maximum Size Permitted for\n*  the IPL Program Record\n*  Maximum Bytes\n* Volume Type for IPL Program\n* 2311      3,110\n* 2314      6,514\n* 2319      6,514\n* 3340      7,286\n* 3344      7,286\n* 3330-1   12,117\n* 3330-11  12,117\n* 2305-1   12,180\n* 2305-2   13,616\n* 3350     17,902\n* 3375     33,984\n* 3380     44,948\n* 9345     49,938\n* 3390     53,450\n*\n*   The format used by this program does NOT match\n* what ICKDSF write IPLTEXT ABSFORMAT expects.\n*\n* ABSFORMAT wants three or more undefined records.\n* The first must be 24 ( X'18' ) bytes.\n* The second must be 144 ( X'90' ) bytes.\n* The others are written after the volume label as is.\n*\n* This program includes count and key fields so:\n* The first must be 36 bytes ( C+K+D 8+4+24 ).\n* The second must be 156 bytes ( C+K+D 8+4+144 ).\n* Others are eight bytes larger than data for the\n* count field.\n*\n* Notes from Sam Golob follow:\n*\n* Input for this program is hardcoded in this program, except for\n*  record 3, which is copied from record 3 on the existing pack,\n*  and then rewritten back to its place.\n*\n* Program Logic for TRK0INIT.\n*\n*  Stage 0.  Records 1 and 2 for an initted pack are hardcoded as\n*              constants in this program.  A model Record 3 is coded\n*              here too, but it will get overlaid with the real\n*              Record 3 (the volume id that points to the VTOC).\n*              Finally, a dummy Record 4 is hardcoded in this program,\n*              and instead of it getting written, an erase opcode is\n*              inserted in the CCW (X'11' instead of X'1D'), and the\n*              fourth record is erased, erasing all the other records\n*              on Track 0.\n*  Stage 1.  GETMAIN a 65535 byte buffer.\n*            OPEN DISKUPD DCB for INPUT.\n*            Copy entire track 0 into buffer, including count, key,\n*              and data of each record.\n*            CLOSE DISKUPD DCB.\n*  Stage 2.  Bump in the buffer to the count field of Record 3.  Copy\n*              the buffer's Record 3 into the program, overlaying the\n*              VOL1 storage area.  You now have the contents of\n*              the volume's Record 3, copied into the program.\n*  Stage 3.  OPEN DISKUPD DCB for UPDAT.\n*            Write Count-Key-Data (opcode X'1D') for Record 1,\n*              Record 2, Record 3, Erase opcode X'11' for Record 4.\n*            CLOSE DISKUPD DCB.\n*            FREEMAIN the 65535 byte buffer.\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE\n         MACRO\n         REGS  ,\n         LCLA  &COUNT\n.LOOP    ANOP\nR&COUNT  EQU   &COUNT             Register equate for register &COUNT\n&COUNT   SETA  &COUNT+1\n         AIF   (16 GT &COUNT).LOOP\n         MEND\n         SPACE\n         PRINT ON,GEN,DATA\nTRK0INIT CSECT ,\n         USING *,R15              Set temporary base register\n         SAVE  (14,12),,TRK0INIT.&SYSDATE..&SYSTIME Save Reg.s\n         LA    R12,SAVEAREA       Load address of new save area\n         ST    R12,8(,R13)        Connect old and new save areas\n         ST    R13,4(,R12)        Connect old and new save areas\n         LR    R13,R12            Connect old and new save areas\n         DROP  R15                Drop the temporary base register\n         LR    R12,R15            Load the program's base register\n         USING TRK0INIT,R12       Give the assembler the new base\n         OPEN  (DCBUPD,INPUT)     Open DCB to read original Track 0\n         GETMAIN R,LV=65536       Get Input/Output buffer\n         LR    R11,R1             Save I/O buffer address\n         STCM  R11,B'0111',CCWREAD+1  Store I/O buffer address in CCW\n*\n* DEBDVMOD DS    B         DEVICE MODIFIER - FILE MASK\n* DEBUCBA  DS    AL3       ADDRESS OF UCB ASSOCIATED WITH THIS DATA\n* *                        EXTENT\n* DEBBINUM DS    CL2       BIN NUMBER\n* DEBSTRCC DS    CL2       CYLINDER ADDRESS FOR THE START OF AN EXTENT.\n* DEBSTRHH DS    CL2       TRACK ADDRESS FOR THE START OF AN EXTENT.\n* DEBENDCC DS    CL2       CYLINDER ADDRESS FOR THE END OF AN EXTENT.\n*\n* DEBENDHH DS    CL2       TRACK ADDRESS FOR THE END OF AN EXTENT.\n* DEBNMTRK DS    CL2       NUMBER OF TRACKS ALLOCATED TO A GIVEN EXTENT\n*\n         L     R10,DCBUPD+DCBDEBAD-IHADCB   Load DEB address\n         LA    R10,DEBBASND-DEBBASIC(,R10)  Find DEBDASD section\n         USING DEBDASD,R10            Give the assembler the DEB base\n         MVC   SAVEDEB(12),DEBBINUM   Save extent to restore later\n         MODESET KEY=ZERO             Go to key zero to update DEB\n         XC    DEBBINUM(12),DEBBINUM  Set extent to CYL 0 and TRK 0\n         MVI   DEBNMTRK+1,1           Set extent size as one track\n         MODESET KEY=NZERO            Go back to problem progrem key\nREAD     DS    0H                 Read entire Track 0 into the buffer\n         XC    ECBIN,ECBIN        Insure that the ECB is clear\n         EXCP  IOBIN              Read track zero\n         WAIT  ECB=ECBIN          Wait for the read to complete\n         CLI   ECBIN,X'7F'        See if a good read\n         BNE   IOERROR            If not good, go abend\n         SLR   R8,R8              Clear a work register\n         L     R9,F65535          Load max. size that could have read\n         ICM   R8,B'0011',CSWIN+6  Load the residual byte count\n         SR    R9,R8              Find size of track read\n         AR    R9,R11             Find byte after track read\n         MVI   0(R9),X'FF'        Mark byte after end as the end\n         MODESET KEY=ZERO         Go to key zero to update DEB\n         MVC   DEBBINUM(12),SAVEDEB  Restore DEB extent information\n         MODESET KEY=NZERO           Go back to problem program key\n         CLOSE DCBUPD             We are done with the reading in\n         DROP  R10                Don't need DEB address anymore\n* ----------------------------------------------------------------- *\n*  Now, you've got the Track 0 image in the buffer.\n*  We copy Record 3 into the proper area, and then write out records\n*   1, 2, 3, and the dummy record 4, with count-key-data.\n* ----------------------------------------------------------------- *\n         LR    R9,R11             Load the input track address\n         LA    R9,IPLLEN(,R9)     Point to Record 3\n         CLI   4(R9),3            Check to see if it is Record 3\n         BNE   ERROR1             Not Record 3, error message & quit\n         MVC   VOL1(VOL1L),0(R9)  Overlay VOL1 area with real VOL1\n* ----------------------------------------------------------------- *\n*  Now, we have to put out the new Track 0 information and Dummy\n*   out Record 4.\n* ----------------------------------------------------------------- *\n         OPEN  (DCBUPD,UPDAT)         Now OPEN DCB to update Track 0\n         L     R10,DCBUPD+DCBDEBAD-IHADCB   Load DEB address\n         LA    R10,DEBBASND-DEBBASIC(,R10)  Find DEBDASD section\n         USING DEBDASD,R10            Give the assembler the DEB base\n         MVC   SAVEDEB(12),DEBBINUM   Save extent to restore later\n         MODESET KEY=ZERO             Go to key zero to update DEB\n         XC    DEBBINUM(12),DEBBINUM  Set extent to CYL 0 and TRK 0\n         MVI   DEBNMTRK+1,1           Set extent size as one track\n         MODESET KEY=NZERO            Go back to problem progrem key\n*\nOREC1    DS    0H                 Write IPL1\n         LA    R1,IPL1            Point to IPL1 record\n         LA    R2,IPL1L           Load its length\n         STH   R2,CCWUPDO+6       Store key and data length in CCW\n         MVI   RO,0               Copy record number to seek\n         STCM  R1,7,CCWUPDO+1     Store I/O buffer address in CCW\n         MVI   CCWUPDO,X'1D'      Write count key data\n         MVC   IOERROR1+X'25'(2),=C'01'  (Diagnostic)\n         BAL   R6,EXCP            Write out the record\n*\nOREC2    DS    0H                 Write IPL2\n         LA    R1,IPL2            Point to IPL2 record\n         LA    R2,IPL2L           Load its length\n         STH   R2,CCWUPDO+6       Store key and data length in CCW\n         MVI   RO,1               Copy record number to seek\n         STCM  R1,7,CCWUPDO+1     Store I/O buffer address in CCW\n         MVI   CCWUPDO,X'1D'      Write count key data\n         MVC   IOERROR1+X'25'(2),=C'02'  (Diagnostic)\n         BAL   R6,EXCP            Write out the record\n*\nOVOL1    DS    0H                 Write Record 3\n         LA    R1,VOL1            Point to VOL1 record\n         LA    R2,VOL1L           Load its length\n         STH   R2,CCWUPDO+6       Store key and data length in CCW\n         MVI   RO,2               Copy record number to seek\n         STCM  R1,7,CCWUPDO+1     Store I/O buffer address in CCW\n         MVI   CCWUPDO,X'1D'      Write count key data\n         MVC   IOERROR1+X'25'(2),=C'03'  (Diagnostic)\n         BAL   R6,EXCP            Write out the record\n*\nODUMY    DS    0H                 Erase record 4 to clear track\n         LA    R1,DUMY            Point to DUMMY record\n         LA    R2,DUMYL           Load its length\n         STH   R2,CCWUPDO+6       Store key and data length in CCW\n         MVI   RO,3               Copy record number to seek\n         STCM  R1,7,CCWUPDO+1     Store I/O buffer address in CCW\n         MVI   CCWUPDO,X'11'      Insert \"erase\" opcode into CCW\n         MVC   IOERROR1+X'25'(2),=C'04'  (Diagnostic)\n         BAL   R6,EXCP            Erase the record\n*\nENDOFPGM DS    0H                 Done. Clean up and get out.\n         MODESET KEY=ZERO            Go to key zero to update DEB\n         MVC   DEBBINUM(12),SAVEDEB  Restore DEB extent information\n         MODESET KEY=NZERO           Go back to problem program key\n         DROP  R10                Don't need DEB address anymore\n         CLOSE DCBUPD             Close the DCB\n         FREEMAIN R,LV=65536,A=(R11)  Free the GETMAINed buffer\n         L     R13,4(,R13)        Restore the caller's save area addr.\n         RETURN (14,12),RC=0      Return to caller\n*\nIOERROR  DS    0H\n         WTO   'Input/Output error, Program abending',ROUTCDE=11\n         ABEND 1234,DUMP          Abend with a dump\n         EJECT\nIOERROR1 DS    0H\n         WTO   'Input/Output error, Code = xx ',ROUTCDE=11\n         ABEND 1235,DUMP          Abend with a dump\n         EJECT\nERROR1   DS    0H\n         WTO   'Volume id not copied, Program abending',ROUTCDE=11\n         ABEND 1248,DUMP          Abend with a dump\n         EJECT\n*\nEXCP     DS    0H                 Routine to write a record.\n         ST    R6,SAVER6A         Save BAL register.\n         XC    ECBOUT,ECBOUT      Insure that the ECB is clear\n         EXCP  IOBOUT             Update or add record to track zero\n         WAIT  ECB=ECBOUT         Wait for the update to complete\n*        CLI   ECBOUT,X'7F'\n         TM    ECBOUT,X'40'       See if a good count-key-data write\n*        BNE   IOERROR1           You don't need to test full X'7F'\n         BZ    IOERROR1           If not good, go abend\n         L     R6,SAVER6A         Restore BAL register.\n         BR    R6\n*\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      DCB's, IOB'S, ECB, and CCW's\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE\nDCBUPD   DCB   DDNAME=DISKUPD,    DD name                              X\n               MACRF=E,           MACRO Reference is EXCP              X\n               DSORG=PS           Data Set Organization\n* DCBLEN   EQU   *-DCBOUT           Length of DCB\n*  ---  IOB for Input from Track 0\nIOBIN    DS    0D                 Input/output Block\n         DC    XL4'40000000'      Command chaining used\n         DC    A(ECBIN)           Address of the ECB\nCSWIN    DC    D'0'               Channel Status Word\n         DC    A(CCWIN)           Address of the channel command string\n         DC    A(DCBUPD)          Address of the Data Control Block\n         DC    A(0)               IOB Restart\n         DC    XL4'0'             Flags and Counters\nSEEKI    DC    D'0'               Seek address\nSEARCHI  EQU   SEEKI+3,5          Cylinder, Head, and Record to search\nCCHHI    EQU   SEEKI+3,4          Cylinder and Head to seek to\nCCI      EQU   SEEKI+3,2          Cylinder to seek\nHHI      EQU   SEEKI+5,2          Track to seek to\nRI       EQU   SEEKI+7,1          Record to search for\nCCWIN    CCW   X'31',SEARCHI,X'40',5 Search for record zero\n         CCW   8,*-8,0,0          TIC back until search complete\nCCWREAD  CCW   X'5E',*-*,X'20',65535  Read track zero with SLI\n*  ---  IOB for Output to Track 0\nIOBOUT   DS    0D                 Input/output Block for Output\n         DC    XL4'40000000'      Command chaining used\n         DC    A(ECBOUT)          Address of the ECB\nCSWOUT   DC    D'0'               Channel Status Word\n         DC    A(CCWOUT)          Address of the channel command string\n         DC    A(DCBUPD)          Address of the Data Control Block\n         DC    A(0)               IOB Restart\n         DC    XL4'0'             Flags and Counters\nSEEKO    DC    D'0'               Seek address\nSEARCHO  EQU   SEEKO+3,5          Cylinder, Head, and Record to search\nCCHHO    EQU   SEEKO+3,4          Cylinder and Head to seek to\nCCO      EQU   SEEKO+3,2          Cylinder to seek\nHHO      EQU   SEEKO+5,2          Track to seek to\nRO       EQU   SEEKO+7,1          Record to search for\nCCWOUT   CCW   X'31',SEARCHO,X'40',5 Srch for record before one written\n         CCW   8,*-8,0,0          TIC back until search complete\nCCWUPDO  CCW   X'1D',*-*,0,*-*    Update key-data,write count-key-data\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      Workarea and Constants\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nSAVEAREA DC    18F'0'             Register save area\nECBIN    DC    F'0'               Event Control Block\nECBOUT   DC    F'0'               Event Control Block\nSAVEDEB  DS    XL12               Area to save extent after OPEN\nSAVER6A  DC    F'0'\nH8       DC    H'8'               Constant for subtraction\nF65535   DC    F'65535'           Buffer size\n* ------ >>   below     Init track images\nIPL1     DS    0XL36              Canned IPL1 record\nIPL1R    DC    X'0000000001'               5\nIPL1KL   DC    X'040018'                   3\nIPL1K    DC    C'IPL1'                     4   =  12\n         DC    X'000A00000000000F'         8\n         DC    X'0300000000000001'         8\n         DC    X'0000000000000000'         8   =  24 + 12  =  36\nIPL1L    EQU   *-IPL1             IPL1 record length incl count\n* -----\nIPL2     DS    0XL156             Canned IPL2 record\nIPL2R    DC    X'0000000002'               5\nIPL2KL   DC    X'040090'                   3\nIPL2K    DC    C'IPL2'                     4   =  12\n         DC    X'07003AB840000006'         8\n         DC    X'31003ABE40000005'         8\n         DC    X'08003AA000000000'         8\n         DC    X'0600000020000000'         8\n         DC    X'0000000000000000'         8   =  40 + 12  =  52\n         DC    X'000004'                   3   +  52  =  55\n         DC    XL101'00'                   101 +  55  = 156\nIPL2L    EQU   *-IPL2             IPL2 record length incl count\n* -----\nIPLLEN   EQU   *-IPL1             Length of both IPL records\n* -----\nVOL1     DS    0XL96              VOLUME ID record - will be overlaid\nVOL1R    DC    X'0000000003'                  5\nVOL1KL   DC    X'040050'                      3\nVOL1K    DC    C'VOL1'                        4   =  12\n         DC    C'VOL1'                        4\nVOL1SER  DC    CL6' '                         6\n         DC    C' '                           1\n         DC    XL5'0000000101' (LOC OF VTOC)  5   =  16 + 12 = 28\n         DC    CL68' '\nVOL1L    EQU   *-VOL1             VOL1 record length incl count\n* ------ >>   above     Init track images\nDUMY     DS    0XL9               Dummy record to blank rest of track\nDUMYR    DC    X'0000000004'                  5\nDUMYKL   DC    X'000001'                      3\nDUMYZ    DC    X'00'                          1\nDUMYL    EQU   *-DUMY\n* -----\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      DSECTs\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n         LTORG ,                  Insure literals are before the DSECTs\n*\n         PRINT GEN\n         DCBD  DSORG=PS,DEVD=DA   DSECT for the Data Control Block\n         IEZDEB LIST=YES          DSECT for the Data Extent Block\n         PRINT NOGEN\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      Register Equates\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE\n         REGS  ,                  User Register equate MACRO\n         END   ,                  The end of the program\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TRK0SAV$": {"ttr": 2054, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00T\\x01\\x11\\x04O\\x01\\x11\\x04O\\x01%\\x00\\x1c\\x00\\x1c\\x00\\x00\\xc1\\xe2\\xd4\\xd1\\xc3\\xd3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2011-02-13T00:00:00", "modifydate": "2011-02-13T01:25:54", "lines": 28, "newlines": 28, "modlines": 0, "user": "ASMJCL"}, "text": "//IBMUSERU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,FLAG(5))\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSIN    DD DISP=SHR,DSN=IBMUSER.B.ASM(TRK0SAVE)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,4),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n SETCODE AC(1)\n SETSSI  CB481846\n NAME    TRK0SAVE(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TRK0SAVE": {"ttr": 2056, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x11\\x04/\\x01\\x11\\x04/\\x01\\x12\\x00\\xe8\\x00\\xe8\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2011-02-11T00:00:00", "modifydate": "2011-02-11T01:12:00", "lines": 232, "newlines": 232, "modlines": 0, "user": "SOMITCW"}, "text": "//HERC01T  JOB (XXXXXXXX,XXXX,1439,9999,9999),TRK0SAVE-HERC01,\n//             MSGCLASS=C,CLASS=A,NOTIFY=HERC01,COND=(0,NE)\n//ASMFCL  EXEC PROC=ASMFCL\n//SYSLIB   DD\n//         DD  DISP=SHR,DSN=SYS1.AMODGEN\nPASS     TITLE 'TRK0SAVE - - - Program to copy a disk volume track 0'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*     This program copies records 1, 2, and 4 through the\n* end of a disk volume track 0 to a sequential data set.\n* Record 3 is the volume label and is not copied.\n* Each block in the output data set will have the 8 byte\n* disk count field in the front of the data or key and data.\n*\n*     Use program TRK0UPD to copy back to a disk track 0.\n*\n* Sample JCL:\n*\n* //HERC01T  JOB (xxxxxxxx,xxxx,1439,9999,9999),TRK0SAVJ-HERC01,\n* //             MSGCLASS=x,CLASS=x,NOTIFY=HERC01\n* //TRK0SAVE EXEC PGM=TRK0SAVE\n* //SYSUDUMP DD  SYSOUT=*\n* //DISKIN   DD  UNIT=SYSDA,SPACE=(TRK,1),VOL=SER=MVSRES\n* //OUTPUT   DD  DISP=(,CATLG,DELETE),DSN=HERC01.IPLTEXT.MVS38J,\n* //             SPACE=(TRK,1),VOL=REF=SYS1.PARMLIB\n*\n* Blame: somitcw@yahoo.com\n*\n* Additional information:\n*\n* Extracted information from Table 26\n* of the DSF Users Guide r16\n* Maximum Size Permitted for\n* the IPL Program Record\n* Maximum Bytes\n* Volume Type for IPL Program\n* 2311      3,110\n* 2314      6,514\n* 2319      6,514\n* 3340      7,286\n* 3344      7,286\n* 3330-1   12,117\n* 3330-11  12,117\n* 2305-1   12,180\n* 2305-2   13,616\n* 3350     17,902\n* 3375     33,984\n* 3380     44,948\n* 9345     49,938\n* 3390     53,450\n*\n*   The format written by this program does NOT\n* match what ICKDSF write IPLTEXT ABSFORMAT expects.\n*\n* ABSFORMAT wants three or more undefined records.\n* The first must be 24 ( X'18' ) bytes.\n* The second must be 144 ( X'90' ) bytes.\n* The others are written after the volume label as is.\n*\n* This program includes count and key fields so:\n* The first must be 36 bytes ( C+K+D 8+4+24 ).\n* The second must be 156 bytes ( C+K+D 8+4+144 ).\n* Others are eight bytes larger than data for the\n* count field.\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE\n         MACRO\n         REGS  ,\n         LCLA  &COUNT\n.LOOP    ANOP\nR&COUNT  EQU   &COUNT             Register equate for register &COUNT\n&COUNT   SETA  &COUNT+1\n         AIF   (16 GT &COUNT).LOOP\n         MEND\n         SPACE\n         PRINT ON,GEN,DATA\nTRK0SAVE  CSECT ,\n         USING *,R15              Set temporary base register\n         SAVE  (14,12),,TRK0SAVE.&SYSDATE..&SYSTIME  Save Reg.s\n         LA    R12,SAVEAREA       Load address of new save area\n         ST    R12,8(,R13)        Connect old and new save areas\n         ST    R13,4(,R12)        Connect old and new save areas\n         LR    R13,R12            Connect old and new save areas\n         DROP  R15                Drop the temporary base register\n         LR    R12,R15            Load the program's base register\n         USING TRK0SAVE,R12       Give the assembler the new base\n         OPEN  (DCBIN,INPUT)      Open the disk to be read\n         GETMAIN R,LV=65536       Get Input/Output buffer\n         LR    R11,R1             Save I/O buffer address\n         STCM  R11,B'0111',CCWREAD+1  Store I/O buffer address in CCW\n*\n* DEBDVMOD DS    B         DEVICE MODIFIER - FILE MASK\n* DEBUCBA  DS    AL3       ADDRESS OF UCB ASSOCIATED WITH THIS DATA\n* *                        EXTENT\n* DEBBINUM DS    CL2       BIN NUMBER\n* DEBSTRCC DS    CL2       CYLINDER ADDRESS FOR THE START OF AN EXTENT.\n* DEBSTRHH DS    CL2       TRACK ADDRESS FOR THE START OF AN EXTENT.\n* DEBENDCC DS    CL2       CYLINDER ADDRESS FOR THE END OF AN EXTENT.\n*\n* DEBENDHH DS    CL2       TRACK ADDRESS FOR THE END OF AN EXTENT.\n* DEBNMTRK DS    CL2       NUMBER OF TRACKS ALLOCATED TO A GIVEN EXTENT\n*\n         L     R10,DCBIN+DCBDEBAD-IHADCB  Load DEB address\n         LA    R10,DEBBASND-DEBBASIC(,R10)  Find DEBDASD section\n         USING DEBDASD,R10        Give the assembler the DEB base\n         MVC   SAVEDEB(12),DEBBINUM Save extent to restore later\n         MODESET KEY=ZERO         Go to key zero to update DEB\n         XC    DEBBINUM(12),DEBBINUM  Set extent to CYL 0 and TRK 0\n         MVI   DEBNMTRK+1,1       Set extent size as one track\n         MODESET KEY=NZERO        Go back to problem progrem key\nREAD     DS    0H\n         XC    ECB,ECB            Insure that the ECB is clear\n         EXCP  IOB                Read track zero\n         WAIT  ECB=ECB            Wait for the read to complete\n         CLI   ECB,X'7F'          See if a good read\n         BNE   IOERROR            If not good, go abend\n         MODESET KEY=ZERO         Go to key zero to update DEB\n         MVC   DEBBINUM(12),SAVEDEB  Restore DEB extent information\n         MODESET KEY=NZERO        Go back to problem program key\n         DROP  R10                Don't need DEB address anymore\n         SLR   R8,R8              Clear a work register\n         L     R9,F65535          Load max. size that could have read\n         ICM   R8,B'0011',CSW+6   Load the residual byte count\n         SR    R9,R8              Find size of track read\n         AR    R9,R11             Find byte after track read\n         MVI   0(R9),X'FF'        Mark byte after end as the end\n*\n* Track zero was read, now write all records except record 3\n* Record 3 is the volume label and not needed or wanted\n*\n         OPEN  (DCBOUT,OUTPUT)    Open the output file\n         LR    R9,R11             Load the input track address\nPUT      DS    0H\n         CLI   0(R9),X'FF'        See if end of track\n         BE    ENDOFPGM           Is end of track, go exit the program\n         SLR   R7,R7              Clear a second work register\n         SLR   R8,R8              Clear a work register\n* R9 starts with count CCHHRKLL Cyl, Head(Trk), Rec, Key-len, Data-len\n* R9 displacements are 01234567\n         IC    R7,5(,R9)          Load key length\n         ICM   R8,B'0011',6(R9)   Load data length\n         LA    R8,8(R7,R8)        Find length of Count-Key-Data\n         CLI   4(R9),X'03'        See if record 3 ( Volume label )\n         BE    NOPUT              Is rec.3, do not PUT\n         STH   R8,DCBOUT+DCBLRECL-IHADCB  Store length to PUT\n         PUT   DCBOUT,(R9)        Write a block\nNOPUT    DS    0H\n         LA    R9,0(R8,R9)        Find next block to write\n         B     PUT                Go to see if another block to PUT\n*\nENDOFPGM DS    0H\n         CLOSE DCBOUT             Close output file before input file\n         CLOSE DCBIN              Close input file, ignore if abend\n         FREEMAIN R,LV=65536,A=(R11)  Free Input/Output buffer\n         L     R13,4(,R13)        Restore the caller's save area addr.\n         RETURN (14,12),RC=0      Return to caller\n*\nIOERROR  DS    0H\n         WTO   'Input/Output error, Program abending',ROUTCDE=11\n         ABEND 1234,DUMP          Abend with a dump\n         EJECT\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      DCB's, IOB'S, ECB, and CCW's\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE\nDCBOUT   DCB   DDNAME=OUTPUT,     DD name                              X\n               MACRF=PM,          MACRO Reference is PUT,MOVE          X\n               DSORG=PS,          Data Set Organization                X\n               RECFM=U,           Record format is undefined           X\n               LRECL=0,           Logical record length nonexsistant   X\n               BLKSIZE=32760      Block size is maximum\n         SPACE\nDCBIN    DCB   DDNAME=DISKIN,     DD name                              X\n               MACRF=E,           MACRO Reference is EXCP              X\n               DSORG=PS           Data Set Organization\n* DCBLEN   EQU   *-DCBIN            Length of DCB\nIOB      DS    0D                 Input/output Block\n         DC    XL4'40000000'      Command chaining used\n         DC    A(ECB)             Address of the ECB\nCSW      DC    D'0'               Channel Status Word\n         DC    A(CCW)             Address of the channel command string\n         DC    A(DCBIN)           Address of the Data Control Block\n         DC    A(0)               IOB Restart\n         DC    XL4'0'             Flags and Counters\nSEEK     DC    D'0'               Seek address\nSEARCH   EQU   SEEK+3,5           Cylinder, Head, and Record to search\nCCHH     EQU   SEEK+3,4           Cylinder and Head to seek to\nCC       EQU   SEEK+3,2           Cylinder to seek\nHH       EQU   SEEK+5,2           Track to seek to\nR        EQU   SEEK+7,1           Record to search for\nCCW      CCW   X'31',SEARCH,X'40',5 Search for record zero\n         CCW   8,*-8,0,0          TIC back until search complete\nCCWREAD  CCW   X'5E',*-*,X'20',65535  Read track zero with SLI\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      Workarea and Constants\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nSAVEAREA DC    18F'0'             Register save area\nCOUNT    DC    XL8'0000000000000000'  Count area CCHHRKLL find rec.zero\nECB      DC    F'0'               Event Control Block\nSAVEDEB  DS    XL12               Area to save extent after OPEN\nF65535   DC    F'65535'           Size of buffer to read track zero\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      DSECTs\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n         LTORG ,                  Insure literals are before the DSECTs\n*\n         PRINT GEN\n         DCBD  DSORG=PS,DEVD=DA   DSECT for the Data Control Block\n         IEZDEB LIST=YES          DSECT for the Data Extent Block\n         PRINT NOGEN\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      Register Equates\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE\n         REGS  ,                  User Register equate MACRO\n         END   ,                  The end of the program\n//LKED.SYSLMOD DD DISP=SHR,DSN=SYS2.LINKLIB\n SETCODE AC(1)\n NAME TRK0SAVE(R)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TRK0SAVJ": {"ttr": 2061, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x11\\x04/\\x01\\x11\\x04/\\x01\\x12\\x00\\x15\\x00\\x15\\x00\\x00\\xd9\\xe4\\xd5\\xd1\\xc3\\xd3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2011-02-11T00:00:00", "modifydate": "2011-02-11T01:12:00", "lines": 21, "newlines": 21, "modlines": 0, "user": "RUNJCL"}, "text": "//HERC01T  JOB (XXXXXXXX,XXXX,1439,9999,9999),TRK0SAVJ-HERC01,\n//             MSGCLASS=C,CLASS=A,NOTIFY=HERC01,COND=(0,NE)\n//*\n//* If you change output to go to SYS1. or SYS2. data sets, then\n//* reply the master catalog password on the console. Twice.\n//*\n//TRK0SAV1 EXEC PGM=TRK0SAVE\n//SYSUDUMP DD  SYSOUT=*\n//DISKIN   DD  UNIT=SYSDA,SPACE=(TRK,1),VOL=SER=MVSRES\n//OUTPUT   DD  DISP=(,CATLG,DELETE),DSN=HERC01.IPLTEXT.MVS38J,\n//             SPACE=(TRK,2,RLSE),VOL=REF=SYS1.PARMLIB\n//*\n//TRK0SAV2 EXEC PGM=TRK0SAVE\n//SYSUDUMP DD  SYSOUT=*\n//DISKIN   DD  DISP=SHR,DSN=SYS1.SAMPLE.DATA.SET,\n//             UNIT=SYSDA,VOL=SER=MVSCAT\n//OUTPUT   DD  DISP=(,CATLG,DELETE),DSN=HERC01.IPLTEXT.ZZSA,\n//             SPACE=(TRK,2,RLSE),VOL=REF=SYS1.PARMLIB\n//*\n//CHECKCC EXEC PGM=IEFBR14\n//\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TRK0UPD": {"ttr": 2063, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x11\\x04/\\x01\\x11\\x04/\\x01\\x12\\x00\\xe3\\x00\\xe3\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2011-02-11T00:00:00", "modifydate": "2011-02-11T01:12:00", "lines": 227, "newlines": 227, "modlines": 0, "user": "SOMITCW"}, "text": "//HERC01T  JOB (XXXXXXXX,XXXX,1439,9999,9999),TRK0UPD-SOMITCW,\n//             MSGCLASS=C,CLASS=A,\n//             NOTIFY=HERC01,COND=(0,NE)\n//ASMFCL  EXEC PROC=ASMFCL\n//SYSLIB   DD\n//         DD  DISP=SHR,DSN=SYS1.AMODGEN\nPASS     TITLE 'TRK0UPD - - - Program to re-write a disk track 0'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*     This reads an input file with disk volume track zero\n* records 1, 2, and 4 through the end of the track and\n* updates records 1 and 2 on disk and writes new records 4\n* through end of a disk volume track 0.\n* Using program TRK0SAVE followed by this program is a\n* way to copy IPLTEXT and Boot-strap information from one\n* disk to another.\n*\n* Sample JCL:\n*\n* //HERC01T  JOB (xxxxxxxx,xxxx,1439,9999,9999),TRK0UPDJ-HERC01,\n* //             MSGCLASS=x,CLASS=x,NOTIFY=HERC01\n* //TRK0UPD EXEC PGM=TRK0UPD\n* //SYSUDUMP DD  SYSOUT=*\n* //DISKIN   DD  DISP=SHR,DSN=HERC01.IPLTEXT.MVS38J\n* //DISKUPD  DD  UNIT=SYSDA,SPACE=(TRK,1),VOL=SER=RES38J\n*\n* Blame: somitcw@yahoo.com\n*\n* Extracted from DSF Users Guide r16\n* Table 26.\n*\n*  Maximum Size Permitted for\n*  the IPL Program Record\n*  Maximum Bytes\n* Volume Type for IPL Program\n* 2311      3,110\n* 2314      6,514\n* 2319      6,514\n* 3340      7,286\n* 3344      7,286\n* 3330-1   12,117\n* 3330-11  12,117\n* 2305-1   12,180\n* 2305-2   13,616\n* 3350     17,902\n* 3375     33,984\n* 3380     44,948\n* 9345     49,938\n* 3390     53,450\n*\n*   The format read by this program does NOT match\n* what ICKDSF write IPLTEXT ABSFORMAT expects.\n*\n* ABSFORMAT wants three or more undefined records.\n* The first must be 24 ( X'18' ) bytes.\n* The second must be 144 ( X'90' ) bytes.\n* The others are written after the volume label as is.\n*\n* This program includes count and key fields so:\n* The first must be 36 bytes ( C+K+D 8+4+24 ).\n* The second must be 156 bytes ( C+K+D 8+4+144 ).\n* Others are eight bytes larger than data for the\n* count field.\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE\n         MACRO\n         REGS  ,\n         LCLA  &COUNT\n.LOOP    ANOP\nR&COUNT  EQU   &COUNT             Register equate for register &COUNT\n&COUNT   SETA  &COUNT+1\n         AIF   (16 GT &COUNT).LOOP\n         MEND\n         SPACE\n         PRINT ON,GEN,DATA\nTRK0UPD  CSECT ,\n         USING *,R15              Set temporary base register\n         SAVE  (14,12),,TRK0UPD.&SYSDATE..&SYSTIME  Save Reg.s\n         LA    R12,SAVEAREA       Load address of new save area\n         ST    R12,8(,R13)        Connect old and new save areas\n         ST    R13,4(,R12)        Connect old and new save areas\n         LR    R13,R12            Connect old and new save areas\n         DROP  R15                Drop the temporary base register\n         LR    R12,R15            Load the program's base register\n         USING TRK0UPD,R12        Give the assembler the new base\n         OPEN  (DCBOUT,UPDAT)     Open output disk volume\n*\n* DEBDVMOD DS    B         DEVICE MODIFIER - FILE MASK\n* DEBUCBA  DS    AL3       ADDRESS OF UCB ASSOCIATED WITH THIS DATA\n* *                        EXTENT\n* DEBBINUM DS    CL2       BIN NUMBER\n* DEBSTRCC DS    CL2       CYLINDER ADDRESS FOR THE START OF AN EXTENT.\n* DEBSTRHH DS    CL2       TRACK ADDRESS FOR THE START OF AN EXTENT.\n* DEBENDCC DS    CL2       CYLINDER ADDRESS FOR THE END OF AN EXTENT.\n*\n* DEBENDHH DS    CL2       TRACK ADDRESS FOR THE END OF AN EXTENT.\n* DEBNMTRK DS    CL2       NUMBER OF TRACKS ALLOCATED TO A GIVEN EXTENT\n*\n         L     R10,DCBOUT+DCBDEBAD-IHADCB  Load DEB address\n         LA    R10,DEBBASND-DEBBASIC(,R10)  Find DEBDASD section\n         USING DEBDASD,R10        Give the assembler the DEB base\n         MVC   SAVEDEB(12),DEBBINUM Save extent to restore later\n         MODESET KEY=ZERO         Go to key zero to update DEB\n         XC    DEBBINUM(12),DEBBINUM  Set extent to CYL 0 and TRK 0\n         MVI   DEBNMTRK+1,1       Set extent size as one track\n         MODESET KEY=NZERO        Go back to problem progrem key\n         OPEN  (DCBIN,INPUT)      Open input data set\nGET      DS    0H\n         GET   DCBIN              Get a disk block\n         L     R2,DCBIN+DCBLRECL-IHADCB-2  Load length of block read\n         LA    R2,0(,R2)          Make certain that it's not negative\n* If record number less than 3, set command code x'0D'\n* If record number greater than 3,set command code X'1D' and\n* back up seek/search record number by one.\n         CLI   4(R1),3            See if after record 3 input block\n         BH    FORMAT             Record 4 through 255, format write\n         SH    R2,H8              Subtract count length for update\n         STH   R2,CCWUPD+6        Store key and data length in CCW\n         MVC   R,4(R1)            Copy record number to seek\n         LA    R1,8(,R1)          Point to key and data part of input\n         ST    R1,CCWUPD          Store I/O buffer address in CCW\n         MVI   CCWUPD,X'0D'       Update key and data in place write\n         B     EXCP               Go update a disk record\nFORMAT   DS    0H\n         STH   R2,CCWUPD+6        Store count-key-data length in CCW\n         IC    R2,4(,R1)          Load the record number to write\n         BCTR  R2,R0              Decrement record by one\n         STC   R2,R               Store rec.no.to search for for write\n         ST    R1,CCWUPD          Store I/O buffer address in CCW\n         MVI   CCWUPD,X'1D'       Format write full count, key, data\n*\nEXCP     DS    0H\n         XC    ECB,ECB            Insure that the ECB is clear\n         EXCP  IOB                Update or add record to track zero\n         WAIT  ECB=ECB            Wait for the update to complete\n         CLI   ECB,X'7F'          See if a good update or format write\n         BNE   IOERROR            If not good, go abend\n         B     GET                Go back to get another record\n*\nENDOFPGM DS    0H\n         MODESET KEY=ZERO         Go to key zero to update DEB\n         MVC   DEBBINUM(12),SAVEDEB  Restore DEB extent information\n         MODESET KEY=NZERO        Go back to problem program key\n         DROP  R10                Don't need DEB address anymore\n         CLOSE DCBOUT             Close output file, ignore if abend\n         CLOSE DCBIN              Close input file\n         L     R13,4(,R13)        Restore the caller's save area addr.\n         RETURN (14,12),RC=0      Return to caller\n*\nIOERROR  DS    0H\n         WTO   'Input/Output error, Program abending',ROUTCDE=11\n         ABEND 1234,DUMP          Abend with a dump\n         EJECT\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      DCB's, IOB'S, ECB, and CCW's\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE\nDCBIN    DCB   DDNAME=DISKIN,     DD name                              X\n               DSORG=PS,          Data Set Organization                X\n               EODAD=ENDOFPGM,    End-of-data-address = end-of-program X\n               MACRF=GL           MACRO Reference is PUT,MOVE        X\n*              RECFM=U,           Record format is undefined         X\n*              LRECL=0,           Logical record length nonexsistant X\n*              BLKSIZE=32760      Block size is maximum\n         SPACE\nDCBOUT   DCB   DDNAME=DISKUPD,    DD name                              X\n               MACRF=E,           MACRO Reference is EXCP              X\n               DSORG=PS           Data Set Organization\n* DCBLEN   EQU   *-DCBOUT           Length of DCB\nIOB      DS    0D                 Input/output Block\n         DC    XL4'40000000'      Command chaining used\n         DC    A(ECB)             Address of the ECB\nCSW      DC    D'0'               Channel Status Word\n         DC    A(CCW)             Address of the channel command string\n         DC    A(DCBOUT)          Address of the Data Control Block\n         DC    A(0)               IOB Restart\n         DC    XL4'0'             Flags and Counters\nSEEK     DC    D'0'               Seek address\nSEARCH   EQU   SEEK+3,5           Cylinder, Head, and Record to search\nCCHH     EQU   SEEK+3,4           Cylinder and Head to seek to\nCC       EQU   SEEK+3,2           Cylinder to seek\nHH       EQU   SEEK+5,2           Track to seek to\nR        EQU   SEEK+7,1           Record to search for\nCCW      CCW   X'31',SEARCH,X'40',5 Search for record before one writen\n         CCW   8,*-8,0,0          TIC back until search complete\nCCWUPD   CCW   *-*,*-*,0,*-*      Update key-data,write count-key-data\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      Workarea and Constants\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nSAVEAREA DC    18F'0'             Register save area\nECB      DC    F'0'               Event Control Block\nSAVEDEB  DS    XL12               Area to save extent after OPEN\nH8       DC    H'8'               Constant for subtraction\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      DSECTs\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n         LTORG ,                  Insure literals are before the DSECTs\n*\n         PRINT GEN\n         DCBD  DSORG=PS,DEVD=DA   DSECT for the Data Control Block\n         IEZDEB LIST=YES          DSECT for the Data Extent Block\n         PRINT NOGEN\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      Register Equates\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE\n         REGS  ,                  User Register equate MACRO\n         END   ,                  The end of the program\n//LKED.SYSLMOD DD DISP=SHR,DSN=SYS2.LINKLIB\n SETCODE AC(1)\n NAME TRK0UPD(R)\n//*\n//CHECKCC EXEC PGM=IEFBR14\n//\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TRK0UPD$": {"ttr": 2309, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00)\\x01\\x11\\x04O\\x01\\x11\\x04O\\x01&\\x00\\x1c\\x00\\x1c\\x00\\x00\\xc1\\xe2\\xd4\\xd1\\xc3\\xd3@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2011-02-13T00:00:00", "modifydate": "2011-02-13T01:26:29", "lines": 28, "newlines": 28, "modlines": 0, "user": "ASMJCL"}, "text": "//IBMUSERU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,FLAG(5))\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSIN    DD DISP=SHR,DSN=IBMUSER.B.ASM(TRK0UPD)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,4),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n SETCODE AC(1)\n SETSSI  CB481846\n NAME    TRK0UPD(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TRK0UPDJ": {"ttr": 2311, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x11\\x04/\\x01\\x11\\x04/\\x01\\x12\\x00\\x0f\\x00\\x0f\\x00\\x00\\xd9\\xe4\\xd5\\xd1\\xc3\\xd3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2011-02-11T00:00:00", "modifydate": "2011-02-11T01:12:00", "lines": 15, "newlines": 15, "modlines": 0, "user": "RUNJCL"}, "text": "//HERC01T  JOB (XXXXXXXX,XXXX,1439,9999,9999),TRK0UPDJ-HERC01,\n//             MSGCLASS=C,CLASS=A,NOTIFY=HERC01,COND=(0,NE)\n//*\n//TRK0UPD EXEC PGM=TRK0UPD\n//SYSUDUMP DD  SYSOUT=*\n//DISKIN   DD  DISP=SHR,DSN=HERC01.IPLTEXT.RES38J\n//DISKUPD  DD  UNIT=SYSDA,SPACE=(TRK,1),VOL=SER=RES38J\n//*\n//TRK0UPD EXEC PGM=TRK0UPD\n//SYSUDUMP DD  SYSOUT=*\n//DISKIN   DD  DISP=SHR,DSN=HERC01.IPLTEXT.ZZSA\n//DISKUPD  DD  UNIT=SYSDA,SPACE=(TRK,1),VOL=SER=CAT38J\n//*\n//CHECKCC EXEC PGM=IEFBR14\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TR02ABS": {"ttr": 2313, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00\\x16\\x01\\x01\\x03?\\x01 \\x00/\\x11#\\x00\\x80\\x00R\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "2001-02-02T00:00:00", "modifydate": "2020-01-02T11:23:16", "lines": 128, "newlines": 82, "modlines": 0, "user": "SBGOLOB"}, "text": "TR02ABS  TITLE 'Convert TRK0SAVE IPL Text format to ICKDSF ABSFORMAT'\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Author  :   Sam Golob (most of this was plagiarized from the       *\n*                         AWSTAPIN program, from David Cartwright.    *\n*                         Thanks, Dave !! )                           *\n*                                                                     *\n*  Date    :   May 14, 2014                                           *\n*                                                                     *\n*  Version :   1.0                                                    *\n*                                                                     *\n*  Changes :                                                          *\n*                                                                     *\n*  Function:                                                          *\n*                                                                     *\n*    RECFM=U  input  to  RECFM=U  output.                             *\n*                                                                     *\n*    This program converts an IPL text file in somitcw's.             *\n*    TRK0SAVE format into ICKDSF's ABSFORMAT format............       *\n*    Eight-byte CKD records are dropped off each block.........       *\n*    But before that was done, if there is a key length and           *\n*     a key, it is also dropped.                                      *\n*                                                                     *\n*    The idea is, that if you only have TRK0SAVE ipltext records,     *\n*     you can still convert them and load them with ICKDSF.           *\n*                                                                     *\n*    ABSFORMAT wants three or more undefined records.                 *\n*    The first must be 24 ( X'18' ) bytes.  Decimal 24.               *\n*    The second must be 144 ( X'90' ) bytes.  Decimal 144.            *\n*    The others are written after the volume label as is,             *\n*     starting with record 4.                                         *\n*    But ABSFORMAT does not include the count or key fields           *\n*     for each record.  And record 3 (the volume id record)           *\n*     is not included, for good reason.  You don't want to            *\n*     affect the VOLSER of the volume, or the location of             *\n*     the VTOC on the volume.                                         *\n*                                                                     *\n*    The TRK0SAVE program includes count and key fields so:           *\n*    The first must be 36 bytes ( C+K+D 8+4+24 ).                     *\n*    The second must be 156 bytes ( C+K+D 8+4+144 ).                  *\n*    Others are eight bytes larger than data for the                  *\n*    count field.  To convert to ABS format, the count                *\n*    and key fields in each record must be dropped off.               *\n*                                                                     *\n*    The count field (always eight bytes) contains the length         *\n*     of the key in +5 off the beginning of the count field.          *\n*    A halfword +6 off the count field contains the length            *\n*     of the actual data in the record.                               *\n*                                                                     *\n*---------------------------------------------------------------------*\nTR02ABS  CSECT\nTR02ABS  RMODE 24\nTR02ABS  AMODE 24\n*---------------------------------------------------------------------*\n*    Initialization of the program.                                   *\n*---------------------------------------------------------------------*\n         LR    R12,R15               Load base register\n         USING TR02ABS,R12           Establish addressability\n         OPEN  (SYSUT1,INPUT)        Open input DCB\n         TM    SYSUT1+48,X'10'       Is DCB open?\n         BZ    EXIT020               No, exit with RC=20\n         OPEN  (SYSUT2,OUTPUT)       Open output DCB\n         TM    SYSUT2+48,X'10'       Is DCB open?\n         BZ    EXIT020               No, exit with RC=20\n*---------------------------------------------------------------------*\n*    Grab each undefined record, to remove the count and key fields.  *\n*---------------------------------------------------------------------*\nGENLOOP  DS    0H\n         GET   SYSUT1                Get input block (this is QSAM GL)\n         LR    R2,R1                 R2=>input block (save address)\n*---------------------------------------------------------------------*\n*                                                                     *\n* R2 starts with count CCHHRKLL Cyl, Head(Trk), Rec, Key-len, Data-len*\n* R2 displacements are 01234567                                       *\n*                                                                     *\n*     so that X'5' off the beginning is the one-byte KEY field        *\n*     and X'6' for two bytes is the data length field.                *\n*                                                                     *\n*---------------------------------------------------------------------*\n         XR    R5,R5                 Clear\n         XR    R6,R6                       work\n         XR    R7,R7                            registers\n         IC    R5,5(,R2)             Load Key Length\n         ICM   R6,B'0011',6(R2)      Load Data length\n         LA    R7,8(R5,R6)           Total length of Count-Key-Data\n*                                     (not needed for this program)\n*\n         STH   R6,SYSUT2+82          Set data block length in DCB\n         LA    R2,8(R5,R2)           Bump past CK to reach data only\n         PUT   SYSUT2,(R2)           Write only data length to SYSUT2\n         B     GENLOOP               Go back for next record\nGENEOF   DS    0H\n         CLOSE (SYSUT1,,SYSUT2)      Close DCBs\n         SR    R15,R15               Zeroize return code\n         SVC   3                     Exit with RC=0\nEXIT020  DS    0H\n         LA    R15,20                DD statement missing\n         SVC   3                     Exit with RC=20\n         DROP  R12                   Drop base register\n*\n* Data Control Blocks\n*\n         PRINT GEN\nSYSUT1   DCB   DSORG=PS,MACRF=GL,DDNAME=SYSUT1,EODAD=GENEOF,           X\n               RECFM=U,LRECL=0,BLKSIZE=32760\nSYSUT2   DCB   DSORG=PS,MACRF=PM,DDNAME=SYSUT2,                        X\n               RECFM=U,LRECL=0,BLKSIZE=32760\n         LTORG\n*\n* Register equates\n*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TR02ABS$": {"ttr": 2316, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00F\\x01\\x11\\x04O\\x01\\x14\\x13O\\x11S\\x00\\x1c\\x00\\x1c\\x00\\x00\\xc1\\xe2\\xd4\\xd1\\xc3\\xd3@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2011-02-13T00:00:00", "modifydate": "2014-05-14T11:53:46", "lines": 28, "newlines": 28, "modlines": 0, "user": "ASMJCL"}, "text": "//IBMUSERU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,FLAG(5))\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSIN    DD DISP=SHR,DSN=IBMUSER.CBT488.FILE846(TR02ABS)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,4),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n SETCODE AC(0)\n SETSSI  CB488846\n NAME    TR02ABS(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TR02ABSJ": {"ttr": 2318, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00W\\x01\\x14\\x13?\\x01\\x14\\x13O\\x10\\x13\\x00\\x14\\x00\\x07\\x00\\x00\\xd9\\xe4\\xd5\\xd1\\xc3\\xd3@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2014-05-13T00:00:00", "modifydate": "2014-05-14T10:13:57", "lines": 20, "newlines": 7, "modlines": 0, "user": "RUNJCL"}, "text": "//IBMUSERC JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//* ----------------------------------------------------------- *\n//*  Convert one pds member in TRK0SAVE format into ICKDSF      *\n//*  ABS format.  The IPL text file can also be sequential      *\n//*  (and it usually is sequential).  Required DCB attributes:  *\n//*         DCB=(RECFM=U,LRECL=0,BLKSIZE=32760)                 *\n//* ----------------------------------------------------------- *\n//*\n//CONVERT EXEC PGM=TR02ABS\n//STEPLIB  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSUT1   DD  DISP=SHR,DSN=IBMUSER.TEST.IPL.PDS(ZZSATEXT)\n//SYSUT2   DD  DISP=SHR,DSN=IBMUSER.TEST.ABS.PDS(ZZSATEXT)\n//\n//*\n//*         DISP UNIT OPT RECFM LRECL BLKSIZE\n//*         SHR  3390 C   U         0   32760\n//*\n//*\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT846/FILE846.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT846", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}