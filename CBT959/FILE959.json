{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220013604000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 176358, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 8, "INMDSNAM": "CBT.V500.FILE959.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 176358, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 176358, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE959.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x04\\x06'", "DS1TRBAL": "b'\\x90\\xe6'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xc0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xc0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\t\\xf3\\x00\\n\\t\\xf3\\x00\\x0e\\x00\\x05'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04c\\x00\\x05\\x01 \\x11/\\x01 \\x11/\\x15E\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf9@@@'", "ispf": {"version": "04.99", "flags": 0, "createdate": "2020-04-21T00:00:00", "modifydate": "2020-04-21T15:45:05", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-499"}, "text": "REGULAR CBT TAPE - VERSION 499    FILE:  959\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT499.FILE959\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 12 MEMBERS COUNTED; CUMULATIVE SIZE IS 1,300 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   04/21/20    15:45:05    UTC-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$ULUNOTE": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00V\\x01\\x124o\\x01 \\x10O\\x16)\\x01\\xad\\x00\\xca\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "2012-12-11T00:00:00", "modifydate": "2020-04-13T16:29:56", "lines": 429, "newlines": 202, "modlines": 0, "user": "SBGOLOB"}, "text": "Notes on the ULUT accessing method to scan UCB's.\n\nIntroduction.\n\nGilbert Saint-flour discovered this IBM internal technique for doing\nnon-authorized scans of REAL UCB's.  IBM keeps a real UCB Lookup Table\n(called the ULUT), in above-the-line storage.  The format of this\ntable is not guaranteed.  IBM can change the format at will, but they\nhave established \"types\" (or formats) of ULUT table.  Currently, as\nof this writing, there are two ULUT types, type X'01' and type X'02'.\nPlus, there is now an added type X'03', with the ULUT table being\nmoved to 64-bit storage.\n\nIf you want to check the format of the ULUT, you first look for which\n\"type\" it is, and then you know what to do.  You do not have to check\nthe system level.  Knowing the ULUT TYPE is enough.\n\nHowever, you must also check if the ULUT is in 64-bit storage\n(addressable via doubleword address) or in 31-bit storage (addressable\nby fullword address).  The way to do that is to look in the IOVT\n(I/O Vector Table).\n\nThe IOVT is addressable from the CVT.\n\n    CVT + X'7C'    points to the IXAVL.\n    IXAVL + X'D0'  points to the IOVT.\n\nThe IOVT is an OCO control block.  But we know enough about it, to\ndo what we need.  The IOVT contains two possible addresses to the ULUT.\n\n    IOVT + X'8'    is a fullword address.  If it is non-zero, then\n                   it points to a 31-bit ULUT and you don't have to\n                   do any more work to find the ULUT.  31-bit ULUT's\n                   are either Type X'01' or Type X'02'.\n\n    IOVT + X'1B8'  contains a doubleword pointer.  If the fullword\n                   pointer at IOVT + X'8' is zeroes, then this\n                   doubleword pointer will be populated, and it will\n                   point to the ULUT in 64-bit storage.  Such a ULUT\n                   will be Type X'03' or higher.\n\nThe ULUT Type 1 has extended at least as far back as ESA 5.2.2 which\nis pre-Y2K.  The ULUT Type 2 has extended at least as far forward as\nz/OS 2.1, without PTF UA90741 installed.  The 64-bit ULUT coding was\noriginally intended to be deployed in z/OS 2.2, but it was retrofitted\nto z/OS 2.1 and z/OS 1.13 with PTFs, as follows.\n\n    z/OS 2.1   -  PTF UA90741\n    z/OS 1.13  -  PTF UA90740, for HBB7780\n    z/OS 1.13  -  PTF UA90742, for JBB778H, on top of UA90740\n\nSTRUCTURE OF THE ULUT:\n\nThe ULUT consists of two parts.  First is a bunch of fields containing\ngeneral quantities, such as the total number of entries in the table,\nand the number of entries in each device category, such as DASD, TAPE,\nand so forth.  After that, there is the device table itself, describing\nall the devices.  We will refer to the device table itself as the table\nof entries, or the ULUT table entries.\n\nFor both ULUT types, the format of the 12-byte ULUT table entries\nappears to be the same.\n\n   ULUT table entries are 12 bytes in length. No change in format.\n\n     The first halfword is the unit number in hex.\n     The second halfword consists of flags.\n     The third halfword is a sequence counter number in the table.\n     The fourth halfword is probably unused for now.\n     The next fullword contains the real UCB address of the unit.\n\n     Example:\n\n          0A80 4000 010D 0000 00F511D0\n\n          unit flag coun-     real UCB\n          addr      ter       address\n\nIn order to read the ULUT table entries, you look at the first\nhalfword of the table entry which is the hex device address, and the\nlast fullword of the ULUT table entry, which points to the real UCB.\n\nThe UCB itself, contains, or points to, related areas that tell you\njust about anything you need to know about that particular device.\nSo the main guts of each ULUT table entry is the hex device number,\nand the address of the real UCB which defines that device.\n\nThe general ULUT control block itself, is accessed by the following\ninstructions, which have to execute in 31-bit mode (AMODE 31).\nWe have condensed this sequence of instructions into a relatively\neasy-to-use macro, called ULUINIT.  We will explain more about\nour ULUINIT macro later.  For now, here are the instructions that\nare used to get the address of the entire ULUT table, and to\nafterwards point to the address of the first 12-byte ULUT table entry.\n\nThe following coding applies to 31-bit ULUT's only.  To see the\nproper coding for 64-bit ULUT's see the code in the ULUINIT macro.\nIt is as follows:\n\nYou first check if IOVT+8 (fullword) is zero, and then you look at\nIOVT+X'1B8' which is a doubleword, to point to the 64-bit ULUT.\nRemember that 64-bit addresses have to be referred to with 64-bit\ninstructions, in 64-bit addressing mode (say, after a SAM64).\nAnd the high-order bit in a 31-bit address has to be zeroed first,\nbefore entering 64-bit addressing mode.\n\nGETULUT  DS    0H                     Get the ULUT (UCB lookup table)\n         L     R3,16                  CVT\n         L     R3,X'7C'(,R3)          CVTIXAVL - IOCOM\n         L     R3,X'D0'(,R3)          IOVT\n         L     R4,8(,R3)              UCB Lookup Table (ULUT)\n         LR    R3,R4                  Point both regs to ULUT\n         CLC   =C'ULUT',0(R3)         Eyecatcher there?\n         BNE   EXIT                   Nope. It ain't it. Out.\n* ------------------------------------------------------------------ *\n         CLI   4(R3),X'01'            Before z/OS 1.7 ? (ULUT Type 1?)\n         BE    ULUTTYP1               Go to beginning of table entries.\n         CLI   4(R3),X'02'            After z/OS 1.7 ?  (ULUT Type 2?)\n         BE    ULUTTYP2               Go to beginning of table entries.\n* ----------------------------------- Insert test for future types here\n         B     EXIT                   Neither?  Get out.\n* ------------------------------------------------------------------ *\n*     Get actual table entries - location varies by ULUT type....    *\n*                                                                    *\n*     (This seems to be why IBM doesn't document this interface.     *\n*      The format of the ULUT changed at z/OS level 1.7.  So IBM     *\n*      wants to keep the user's interface standard.  But we don't    *\n*      want to lose the convenience of getting a UCB scan of REAL    *\n*      UCBs, in REAL TIME, without having to be APF-authorized.)     *\n*                                                                    *\n*     Actually, this program has been tested to work from ESA 5.2.2  *\n*      through z/OS 1.13.  So it is really quite stable, so far.     *\n* ------------------------------------------------------------------ *\nULUTTYP1 L     R3,X'0C'(,R3)   ULUT Type 1, Addr of first table entry.\n         L     R4,X'10'(,R4)   Total number of ULUT entries\n         ST    R4,TOTCOUNT     Store this number away\n         B     LOOPSET\nULUTTYP2 L     R3,X'14'(,R3)   ULUT Type 2, Addr of first table entry.\n         L     R4,X'18'(,R4)   Total number of ULUT entries\n         ST    R4,TOTCOUNT     Store this number away\n*        B     LOOPSET\nLOOPSET  DS    0H              Set up loop thru all UCB's.\n\n\nI invented the ULUDSECT control block for the purpose of simplifying\nthe process of reading through all the devices defined in the UCB\nLookup Table.  Instead of looking at the UCB itself and extracting\nany fields we want to look at, our ULUSCAN macro pre-extracts commonly\nused fields from the UCB and related control blocks, in one process,\nputting all this information into the ULUDSECT control block.  Then,\nmost subsequent inquiries from the UCB actually go to ULUDSECT fields,\nwhich were obtained from the UCB by the ULUSCAN macro's action.  To\nput it another way, we might say that the ULUSCAN macro \"pre-digests\"\nthe UCB information, before we make our inquiries.\n\nThe ULUINIT macro requires a 88-byte workarea, which contains the\ncontrol block described by the ULUDSECT macro.  The fields of the\nULUDSECT control block are actually filled by two macros:  ULUINIT\ninitially, and then ULUSCAN later.  The ULUINIT macro is executed\nonce, to establish the ULUDSECT control block and to fill in its fields\nrelating to the whole ULUT control block itself.  The ULUSCAN macro\nthen reads each individual 12-byte ULUT table entry corresponding to\neach individual device, \"pre-digesting\" its UCB fields and placing\nthem into the ULUDSECT control block.\n\nThe ULUSCAN macro is therefore executed repeatedly, one time for each\ndevice defined in that system.\n\nThe contents of the ULUDSECT control block follows below (old format).\nFor the new format, see the new macro in this pds.\n\nTo be clearer, the ULUINIT macro establishes the ULUDSECT control block\nand fills in those fields NOT having to do with each UCB, but with the\nULUT control block in general.  The ULUSCAN macro then fills in all\nULUDSECT fields which have to do with each ULUT table entry (that is,\neach particular UCB).\n\nYou can see that everything necessary to describe a device (i.e. a\nUCB) can be obtained from the contents of ONE ULUDSECT entry.  To\nscan all the UCB's on a system, you run the ULUSCAN macro to step\nthrough the ULUT table entries, one at a time, pre-digesting each\none's UCB information and putting it into the ULUDSECT control block.\n\nAPF-authorization is not necessary to do this, but the scan must be\ndone in 31-bit mode.  Here is what the ULUDSECT control block looks\nlike.\n\nULUDSECT DSECT\n         DS    0D            Align to doubleword for GETMAIN\nULUDULUT DS    F             Address of ULUT in this system\nULUDCURR DS    F             Current ULUT table entry address\nULUDNEXT DS    F             Next ULUT table entry address\nULUDTOTC DS    F             Total count of ULUT entries\nULUDRUNC DS    F             Running descending count of ULUT entries\n*                             (initialized to ULUDTOTC at beginning)\nULUDDEVA DS    H             Device address of current table entry\nULUDCNTR DS    H             Counter in ULUT of current table entry\n*                             This is one higher than the table entry\n*                             count, and is incremented by one with\n*                             each successive table entry.  The count\n*                             field for the very last table entry,\n*                             is X'0000', marking the end of the table.\nULUDUCBA DS    F             UCB address of current table entry\nULUDCEXT DS    F             Address of this UCB's common extension\nULUDDEVT DS    F             UCB device type (4 bytes)\nULUDONLF DS    X             UCB + 3 (device online has X'80' set)\nULUDTYPE DS    X             ULUT TYPE for this table\nULUDRSV1 DS    2X            RESERVED\nULUDSVR0 DS    F             Save area for R0 in macro invocation\nULUDSVR1 DS    F             Save area for R1 in macro invocation\nULUDSVUR DS    F             Save USING register for workarea\nULUDSVW1 DS    F             Save first work register\nULUDSVW2 DS    F             Save second work register\nULUDSVBR DS    F             Save BCT register\n         DS    0D\nULUDLENG EQU   *-ULUDSECT\n\n\nNow I have to show you how to use our ULUT access macros, ULUINIT\nand ULUSCAN.  A complete coding example is included in this pds.\nThis is the TSO command called ULUDIAG.  The TSO command ULUDIAG\nwill display all relevant ULUDSECT fields for each defined UCB (ULUT\ntable entry).  Here is an example of ULUDIAG output:  The output was\nproduced by the coding example below it, with the print lines being\ndone by means of the PUTENTRY subroutine.\n\n             ULUDIAG - V1.0 - PRINT ULUDSECT FIELDS\n             -------   ----   ----- -------- ------\n             ***       DEV ADDRESS: 000C        ***\nULUDULUT 02281F90  ULUDCURR 02282114  ULUDNEXT 02282120  ULUDDEVA 000C\nULUDUCBA 00F46140  ULUDCEXT 00F46118  ULUDDEVT 10000801  ULUDCNTR 0002\nULUDTOTC 00000183  ULUDRUNC 00000183  ULUDONLF 80        ULUDTYPE 02\n             ***       DEV ADDRESS: 000E        ***\nULUDULUT 02281F90  ULUDCURR 02282120  ULUDNEXT 0228212C  ULUDDEVA 000E\nULUDUCBA 00F46180  ULUDCEXT 00F46158  ULUDDEVT 10000808  ULUDCNTR 0003\nULUDTOTC 00000183  ULUDRUNC 00000182  ULUDONLF 80        ULUDTYPE 02\n             ***       DEV ADDRESS: 000F        ***\nULUDULUT 02281F90  ULUDCURR 0228212C  ULUDNEXT 02282138  ULUDDEVA 000F\nULUDUCBA 00F461C0  ULUDCEXT 00F46198  ULUDDEVT 10000808  ULUDCNTR 0000\nULUDTOTC 00000183  ULUDRUNC 00000181  ULUDONLF 00        ULUDTYPE 02\n             ***       DEV ADDRESS: 0120        ***\nULUDULUT 02281F90  ULUDCURR 02282138  ULUDNEXT 02282144  ULUDDEVA 0120\nULUDUCBA 00F46248  ULUDCEXT 00F46220  ULUDDEVT 3030200E  ULUDCNTR 0005\nULUDTOTC 00000183  ULUDRUNC 00000180  ULUDONLF 04        ULUDTYPE 02\n             ***       DEV ADDRESS: 0121        ***\nULUDULUT 02281F90  ULUDCURR 02282144  ULUDNEXT 02282150  ULUDDEVA 0121\nULUDUCBA 00F462E0  ULUDCEXT 00F462B8  ULUDDEVT 3030200E  ULUDCNTR 0006\nULUDTOTC 00000183  ULUDRUNC 0000017F  ULUDONLF 04        ULUDTYPE 02\n                  *** *** *** *** *** *** ***\n                  *** *** *** *** *** *** ***\n             ***       DEV ADDRESS: 0A80        ***\nULUDULUT 02281F90  ULUDCURR 02282D98  ULUDNEXT 02282DA4  ULUDDEVA 0A80\nULUDUCBA 00F501D0  ULUDCEXT 00F501A8  ULUDDEVT 3030200F  ULUDCNTR 010D\nULUDTOTC 00000183  ULUDRUNC 00000078  ULUDONLF 8E        ULUDTYPE 02\n             ***       DEV ADDRESS: 0A81        ***\nULUDULUT 02281F90  ULUDCURR 02282DA4  ULUDNEXT 02282DB0  ULUDDEVA 0A81\nULUDUCBA 00F50268  ULUDCEXT 00F50240  ULUDDEVT 3030200F  ULUDCNTR 010E\nULUDTOTC 00000183  ULUDRUNC 00000077  ULUDONLF 8C        ULUDTYPE 02\n             ***       DEV ADDRESS: 0A82        ***\nULUDULUT 02281F90  ULUDCURR 02282DB0  ULUDNEXT 02282DBC  ULUDDEVA 0A82\nULUDUCBA 00F50300  ULUDCEXT 00F502D8  ULUDDEVT 3030200F  ULUDCNTR 010F\nULUDTOTC 00000183  ULUDRUNC 00000076  ULUDONLF 8C        ULUDTYPE 02\n             ***       DEV ADDRESS: 0A83        ***\nULUDULUT 02281F90  ULUDCURR 02282DBC  ULUDNEXT 02282DC8  ULUDDEVA 0A83\nULUDUCBA 00F50398  ULUDCEXT 00F50370  ULUDDEVT 3030200F  ULUDCNTR 0110\nULUDTOTC 00000183  ULUDRUNC 00000075  ULUDONLF 84        ULUDTYPE 02\n             ***       DEV ADDRESS: 0A84        ***\nULUDULUT 02281F90  ULUDCURR 02282DC8  ULUDNEXT 02282DD4  ULUDDEVA 0A84\nULUDUCBA 00F50430  ULUDCEXT 00F50408  ULUDDEVT 3030200F  ULUDCNTR 0111\nULUDTOTC 00000183  ULUDRUNC 00000074  ULUDONLF 8C        ULUDTYPE 02\n                  *** *** *** *** *** *** ***\n\n\nNew format for ULUDIAG:  -------  (for 64-bit ULUT and earlier too)\n\n\n             ULUDIAG - V1.3 - PRINT ULUDSECT FIELDS\n             -------   ----   ----- -------- ------\n             ***       DEV ADDRESS: 000C        ***\nULUDULUT 000001FF_FFF00000  ULUDCURR 000001FF_FFF00210   ULUDDEVA 000C\nULUDNEXT 000001FF_FFF0021C            ULUDSLV6 E0        ULUDONLF 80\nULUDUCBA 00F47140  ULUDCEXT 00F47118  ULUDDEVT 10000801  ULUDCNTR 0002\nULUDTOTC 00000183  ULUDRUNC 00000183  ULUDONLF 80        ULUDTYPE 03\n             ***       DEV ADDRESS: 000E        ***\nULUDULUT 000001FF_FFF00000  ULUDCURR 000001FF_FFF0021C   ULUDDEVA 000E\nULUDNEXT 000001FF_FFF00228            ULUDSLV6 E0        ULUDONLF 80\nULUDUCBA 00F47180  ULUDCEXT 00F47158  ULUDDEVT 10000808  ULUDCNTR 0003\nULUDTOTC 00000183  ULUDRUNC 00000182  ULUDONLF 80        ULUDTYPE 03\n             ***       DEV ADDRESS: 000F        ***\nULUDULUT 000001FF_FFF00000  ULUDCURR 000001FF_FFF00228   ULUDDEVA 000F\nULUDNEXT 000001FF_FFF00234            ULUDSLV6 E0        ULUDONLF 00\nULUDUCBA 00F471C0  ULUDCEXT 00F47198  ULUDDEVT 10000808  ULUDCNTR 0000\nULUDTOTC 00000183  ULUDRUNC 00000181  ULUDONLF 00        ULUDTYPE 03\n             ***       DEV ADDRESS: 0120        ***\nULUDULUT 000001FF_FFF00000  ULUDCURR 000001FF_FFF00234   ULUDDEVA 0120\nULUDNEXT 000001FF_FFF00240            ULUDSLV6 E0        ULUDONLF 04\nULUDUCBA 00F47248  ULUDCEXT 00F47220  ULUDDEVT 3030200E  ULUDCNTR 0005\nULUDTOTC 00000183  ULUDRUNC 00000180  ULUDONLF 04        ULUDTYPE 03\n             ***       DEV ADDRESS: 0121        ***\nULUDULUT 000001FF_FFF00000  ULUDCURR 000001FF_FFF00240   ULUDDEVA 0121\nULUDNEXT 000001FF_FFF0024C            ULUDSLV6 E0        ULUDONLF 04\nULUDUCBA 00F472E0  ULUDCEXT 00F472B8  ULUDDEVT 3030200E  ULUDCNTR 0006\nULUDTOTC 00000183  ULUDRUNC 0000017F  ULUDONLF 04        ULUDTYPE 03\n             ***    ***    ***    ***    ***    ***\n             ***    ***    ***    ***    ***    ***\n             ***       DEV ADDRESS: 0A80        ***\nULUDULUT 000001FF_FFF00000  ULUDCURR 000001FF_FFF00E94   ULUDDEVA 0A80\nULUDNEXT 000001FF_FFF00EA0            ULUDSLV6 E0        ULUDONLF 8E\nULUDUCBA 00F511D0  ULUDCEXT 00F511A8  ULUDDEVT 3030200F  ULUDCNTR 010D\nULUDTOTC 00000183  ULUDRUNC 00000078  ULUDONLF 8E        ULUDTYPE 03\n             ***       DEV ADDRESS: 0A81        ***\nULUDULUT 000001FF_FFF00000  ULUDCURR 000001FF_FFF00EA0   ULUDDEVA 0A81\nULUDNEXT 000001FF_FFF00EAC            ULUDSLV6 E0        ULUDONLF 8C\nULUDUCBA 00F51268  ULUDCEXT 00F51240  ULUDDEVT 3030200F  ULUDCNTR 010E\nULUDTOTC 00000183  ULUDRUNC 00000077  ULUDONLF 8C        ULUDTYPE 03\n             ***       DEV ADDRESS: 0A82        ***\nULUDULUT 000001FF_FFF00000  ULUDCURR 000001FF_FFF00EAC   ULUDDEVA 0A82\nULUDNEXT 000001FF_FFF00EB8            ULUDSLV6 E0        ULUDONLF 8C\nULUDUCBA 00F51300  ULUDCEXT 00F512D8  ULUDDEVT 3030200F  ULUDCNTR 010F\nULUDTOTC 00000183  ULUDRUNC 00000076  ULUDONLF 8C        ULUDTYPE 03\n             ***       DEV ADDRESS: 0A83        ***\nULUDULUT 000001FF_FFF00000  ULUDCURR 000001FF_FFF00EB8   ULUDDEVA 0A83\nULUDNEXT 000001FF_FFF00EC4            ULUDSLV6 E0        ULUDONLF 8C\nULUDUCBA 00F51398  ULUDCEXT 00F51370  ULUDDEVT 3030200F  ULUDCNTR 0110\nULUDTOTC 00000183  ULUDRUNC 00000075  ULUDONLF 8C        ULUDTYPE 03\n             ***       DEV ADDRESS: 0A84        ***\nULUDULUT 000001FF_FFF00000  ULUDCURR 000001FF_FFF00EC4   ULUDDEVA 0A84\nULUDNEXT 000001FF_FFF00ED0            ULUDSLV6 E0        ULUDONLF 8C\nULUDUCBA 00F51430  ULUDCEXT 00F51408  ULUDDEVT 3030200F  ULUDCNTR 0111\nULUDTOTC 00000183  ULUDRUNC 00000074  ULUDONLF 8C        ULUDTYPE 03\n             ***    ***    ***    ***    ***    ***\n\n\nNext is the piece of code which produced the above report.  This\nshows how useful the ULUINIT and ULUSCAN macros are, and how they\nsimplify the coding in this program.  (Almost exactly the same as\nwith the old version of the ULUDIAG program.  The difference is in\nthe LLGTR instruction and the specific coding of the PUTENTRY routine.\n\nPlease notice how simple this coding is.\n\n* ------------------------------------------------------------------- *\n* --  INITIALIZE ULUDSECT CONTROL BLOCK                            -- *\n* ------------------------------------------------------------------- *\n         LLGTR R10,R10                Clear bit 32 from base register\n         ULUINIT WRKAREA=WORKU,UREG=R8,EXIT=EXIT,WR1=R3,WR2=R4,BREG=R6\n*\nLOOPUCB  DS    0H\n* ------------------------------------------------------------------- *\n* --  SCAN EACH UCB, REPRESENTED BY A ULUDSECT CONTROL BLOCK       -- *\n* ------------------------------------------------------------------- *\n         ULUSCAN WR1=R3,UCBR=R5,BREG=R6\n         BAL   R7,PUTENTRY            Print contents of control block\n         MVC   ULUDCURR,ULUDNEXT      Make next entry current\n         BCT   R6,LOOPUCB             Get stuff for next table entry.\n         B     EXIT0                  End of table. Fall thru.\n\nMECHANISM OF OPERATION:\n\nThe ULUDSECT control block contains (or has access to) all the\ninformation that you'll need about one particular device.  The\nfields of the ULUDSECT control block are filled by:\n\n1.  The ULUINIT macro, which creates the ULUDSECT control block\n    and fills those of its fields common to the entire ULUT\n    control block.\n\n2.  The ULUSCAN macro, which fills in all fields in the ULUDSECT\n    having to do with ONE UCB, pointed to by ONE ULUT table entry.\n\nAfter you invoke the ULUINIT macro once, you then invoke the ULUSCAN\nmacro repeatedly.  Each invocation of the ULUSCAN macro gives you\ninformation about ONE device, represented by ONE UCB, pointed to\nby ONE 12-byte ULUT table entry.\n\nThe above code works by doing a complete search of ALL defined\ndevices.  It \"marches\" completely through the entire ULUT table,\nfrom beginning to end.  Each invocation of the ULUSCAN macro gives\ninformation from ONE ULUT table entry, which points to ONE UCB,\nthat represents ONE device.\n\nEach time the ULUSCAN macro is invoked, it fills the fields of the\nULUDSECT control block with a lot of information extracted from, or\nderived from, that UCB.  You can picture this situation by saying that\nthe ULUSCAN macro \"pre-digests\" information from each UCB, putting\nthe \"digested\" information into the ULUDSECT control block.\n\nTo step through the ULUT (UCB Lookup Table), from one entry to the\nnext, just move the ULUDNEXT field (pointing to the NEXT ULUT table\nentry) into the ULUDCURR field (meaning the current ULUT table entry)\nand reinvoke the ULUSCAN macro, to refill all the ULUDSECT fields for\nthe next UCB.  Then your program will go process the new UCB's\ninformation.  Do this until you've reached the end of the ULUT table.\n\nWhere is the end of the table?  It is found by COUNTING.\n\nThe total number of entries in the ULUT table, extracted from a field\nin the ULUT control block, is loaded into the BREG register by the\nULUINIT macro.  This register can be used later as a BCT register to\ncount through all the table entries, that exact number of times.  The\nULUSCAN macro does not automatically do a partial search, as yet,\nlike IBM's UCBSCAN macro can do.  (UCBSCAN does all the selections\nunder the covers, but in reality, it also does a complete search of\nall UCB's, much of the time).\n\nSelection of devices, for example, only those which are online, is\ndone while that device's ULUT table entry is being processed by the\nULUSCAN macro.  The ULUSCAN macro loads that device's UCB information\ninto the fields of the ULUDSECT control block, and the selection is\nusually done by looking somewhere in the ULUDSECT control block, and\nby making a selection decision from one of its fields.\n\nFor example, to see if a device is online, the ULUDONLF field, which\nthe ULUSCAN macro extracts from that device's UCB+3, is examined for\nthe X'80' bit.  If that bit is on, then the device is online.  If\nnot, then the device is offline.  All other selection criteria are\ndone, using fields created from that unit's UCB, and which have\nalready been loaded into the ULUDSECT control block by the ULUSCAN\nmacro.  Then, when you've finished with that particular UCB, you loop\nback to the next ULUT table entry and invoke the ULUSCAN macro again,\nto get information from the next UCB.  ULUSCAN refills the ULUDSECT\ncontrol block with new information from the next device's UCB (the\nnext ULUT table entry).  Then you look at that one.  And so on, until\nyou've searched through the entire ULUT table, and you've seen all\nthe defined devices.\n\nThe advantage of doing all of this, is that you can do a complete\nscan of all the real UCB's, without having to be APF-authorized.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE959": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04c\\x00Y\\x01 \\x11/\\x01 \\x11/\\x15D\\x00(\\x00(\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf9@@@'", "ispf": {"version": "04.99", "flags": 0, "createdate": "2020-04-21T00:00:00", "modifydate": "2020-04-21T15:44:59", "lines": 40, "newlines": 40, "modlines": 0, "user": "CBT-499"}, "text": "//***FILE 959 is from Richard W. Pinion and contains a program      *   FILE 959\n//*           to release excess space from a list of datasets (by   *   FILE 959\n//*           name), without affecting the last-access date.        *   FILE 959\n//*           This program uses the PARTREL macro from SYS1.MACLIB. *   FILE 959\n//*                                                                 *   FILE 959\n//*           email:  RPINION@firsthorizon.com                      *   FILE 959\n//*                                                                 *   FILE 959\n//*           The UCB lookup in this program uses the ULUT          *   FILE 959\n//*           (UCB Lookup Table) method, from CBT File 873, that    *   FILE 959\n//*           was pioneered by Gilbert Saint-flour.  Please see     *   FILE 959\n//*           member $ULUNOTE for some background on this subject,  *   FILE 959\n//*           which is not documented by IBM.  The easy-to-use      *   FILE 959\n//*           UCB Lookup Table macros were written by Sam Golob.    *   FILE 959\n//*                                                                 *   FILE 959\n//*       PARTREL  - RELEASES EXCESS SPACE FROM DATASETS, EITHER    *   FILE 959\n//*                  CATALOGED, OR UNCATALOGED (WITH VOLSER).       *   FILE 959\n//*                                                                 *   FILE 959\n//*       Further documentation:                                    *   FILE 959\n//*                                                                 *   FILE 959\n//*       The PARTREL program takes input in the //INDD DD name     *   FILE 959\n//*       with the dataset name starting in column1, and optionally *   FILE 959\n//*       the volser of the dataset, which is necessary if the      *   FILE 959\n//*       dataset is uncataloged, starting (for 6 characters)       *   FILE 959\n//*       in column 45.                                             *   FILE 959\n//*                                                                 *   FILE 959\n//*       Model JCL for the //INDD DD card is as follows:           *   FILE 959\n//*       Please  make sure that the \"ruler\" comment card does not  *   FILE 959\n//*       immediately follow the //INDD DD card, or a //SYSIN DD *  *   FILE 959\n//*       card will be generated, nullifying the //INDD DD * card.  *   FILE 959\n//*                                                                 *   FILE 959\n//*       //PARTR01  EXEC PGM=PARTREL                               *   FILE 959\n//*       //STEPLIB   DD  DSN=SYS1.W$$.LINKLIB,DISP=SHR             *   FILE 959\n//*       //SYSPRINT  DD  SYSOUT=*                                  *   FILE 959\n//*       //*-+----1----+----2----+----3----+----4----volser        *   FILE 959\n//*       //INDD      DD  *                                         *   FILE 959\n//*       IBMUSER.TEST.PARTREL.PDS2                   VPWRKD        *   FILE 959\n//*       IBMUSER.TEST.PARTREL.PDS                                  *   FILE 959\n//*       /*                                                        *   FILE 959\n//*       //                                                        *   FILE 959\n//*                                                                 *   FILE 959\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IOSDIOVT": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x004\\x01\\x146/\\x01\\x15\\x02\\x7f\\x120\\x00>\\x00>\\x00>\\xe2\\xc8\\xd6\\xe6\\xf7\\xf2\\xf2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2014-12-28T00:00:00", "modifydate": "2015-01-27T12:30:34", "lines": 62, "newlines": 62, "modlines": 62, "user": "SHOW722"}, "text": "         MACRO\n         IOSDIOVT\nIOVT     DSECT                         IOS Vector Table          ESA41\n         DS    C'IOVT'\n         DS    H'476'                  Length of IOVT            RS1106\n         DS    XL2\nIOVTUL31 DS    V(ULUT)                 UCB LOOK-UP TABLE\n         DS    3F\nIOVTCDA  DS    V(CDA)                  Config Data Area\n         DS    1F                      ???\n         DS    A                       IASC ??\n         DS    A                       IOS PIN QUEUE HEADERS\n         DS    A                       IOS PIN QUEUE ELEMENTS\n         DS    1F                      ???\n         DS    A                       TQE\n         DS    6F                      ???\n         DS    A                       CSC\n         DS    1F                      ???\n         DS    A                       IOS 31 BIT DST ENTRIES\n         DS    A                       IOS 24 BIT DST ENTRIES\n         DS    1F                      ???\n         DS    A                       IOS UCB SERVICES PC RTN\n         DS    A                       IODE\n         DS    3F                      ???\n         DS    A                       IOS HASH\n         DS    A                       IOS UCB HASH COLISIONS\n         DS    1F                      ???\n         DS    A                       DDT\n         DS    A                       DDT\n         DS    A                       DDT\n         DS    4F                      ???\n         DS    A                       CAPT\n         DS    2F                      ???\n         DS    A                       DDT\n         DS    A                       DDT\n         DS    1F                      ???\n         DS    A                       DDT\n         DS    A                       IOS CAPTURE UCB SERVICE\n         DS    A                       TRCB\n         DS    2F                      ???\n         DS    1F                      ???\n         DS    A                       MGFQ\n         DS    A                       CMVT\n         DS    A                       CPCT\n         DS    1F                      ???\n         DS    1F                      ???\n         DS    A                       IXSD\n         DS    CL8'SYSIOS01'\n         DS    6F                      ???\n         DS    A                       QDIO\n         DS    1F                      ???\n         DS    A                       SAUT\n         DS    4F                      ???\n         DS    A                       IOS PURGE WORK AREAS\nIOVTFLG1 DS    X                       IOVT-Flag\nIOVTMIDAW EQU   X'08'                  MIDAW ON?\n         DS    XL3                     ???\n         DS    A                       CCAP\n         ORG   IOVT+440                0x1B8                     JH1214\nIOVTULUT DS    D                       UCB V3 look-up table      JH1214\n         ORG   ,                                                 JH1214\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IOSDULUT": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x12\\x19\\x0f\\x01\\x12\\x19\\x0f\\x133\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe2\\xc8\\xd6\\xe6\\xf7\\xf2\\xf1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2012-07-08T00:00:00", "modifydate": "2012-07-08T13:33:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "SHOW721"}, "text": "         MACRO\n         IOSDULUT\nULUT     DSECT                         UCB Look-up Table         ESA41\n         DS    C'ULUT'\nULUTVERS DS    X                       version 1 or 2            RS0405\n         DS    AL1(245)                Subpool\n         DS    XL2,F                   UNUSED,DASB\nULUT1ST  DS    A(ULUENTRY)             FIRST LOOK-UP ENTRY\nULUTUCBC DS    F'561'                  Total number of LOOK-UP Entries\nULUTTAPE DS    F'064'                  number of TAPE LOOK-UP Entries\nULUTCOMM DS    F'032'                  number of COMM LOOK-UP Entries\nULUTDASD DS    F'256'                  number of DASD LOOK-UP Entries\nULUTDISP DS    F'128'                  number of DISP LOOK-UP Entries\nULUTUREC DS    F'032'                  number of UREC LOOK-UP Entries\nULUTCHAR DS    F'008'                  number of CHAR LOOK-UP Entries\nULUTCTCA DS    F'016'                  number of CTCA LOOK-UP Entries\n         ORG   ULUT+132\nULUENTRY DSECT                         UCB LOOK-UP ENTRY\nULUEDEVN DS    X'000D'                 DEVICE NUMBER\nULUEFLGS DS    X'4000'                 Flags\nULUEDYN   EQU  X'40'                   Dynamic UCB\nULUESEQN DS    XL2                     ?\n         DS    XL2                     ?\nULUEUCBP DS    V(UCBOB)                UCB ADDRESS\nULUELEN  EQU   *-ULUENTRY\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IOSDULU2": {"ttr": 771, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x12\\x19\\x0f\\x01\\x12\\x19\\x0f\\x133\\x00\\x1b\\x00\\x1b\\x00\\x00\\xe2\\xc8\\xd6\\xe6\\xf7\\xf2\\xf1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2012-07-08T00:00:00", "modifydate": "2012-07-08T13:33:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "SHOW721"}, "text": "         MACRO\n         IOSDULU2\nULU2     DSECT                         UCB Look-up Table\n         DS    C'ULUT'\nULU2VERS DS    X                       version 1 or 2\n         DS    AL1(245)                Subpool\n         DS    XL2,F                   UNUSED,DASB\n         DS    F,F\nULU21ST  DS    A(UL2ENTRY)             FIRST LOOK-UP ENTRY\nULU2UCBC DS    F'561'                  Total number of LOOK-UP Entries\nULU2TAPE DS    F'064'                  number of TAPE LOOK-UP Entries\nULU2COMM DS    F'032'                  number of COMM LOOK-UP Entries\nULU2DASD DS    F'256'                  number of DASD LOOK-UP Entries\nULU2DISP DS    F'128'                  number of DISP LOOK-UP Entries\nULU2UREC DS    F'032'                  number of UREC LOOK-UP Entries\nULU2CHAR DS    F'008'                  number of CHAR LOOK-UP Entries\nULU2CTCA DS    F'016'                  number of CTCA LOOK-UP Entries\n         ORG   ULU2+264\nUL2ENTRY DSECT                         UCB LOOK-UP ENTRY\nUL2EDEVN DS    X'000D'                 DEVICE NUMBER\nUL2EFLGS DS    X'4000'                 Flags\nUL2EDYN   EQU  X'40'                   Dynamic UCB\nUL2ESEQN DS    XL2                     ?\n         DS    XL2                     ?\nUL2EUCBP DS    V(UCBOB)                UCB ADDRESS\nUL2ELEN  EQU   *-UL2ENTRY\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IOSDULU3": {"ttr": 773, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x146/\\x01\\x146/\\x08T\\x00\\x1e\\x00\\x1e\\x00\\x00\\xe2\\xc8\\xd6\\xe6\\xf7\\xf2\\xf2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-12-28T00:00:00", "modifydate": "2014-12-28T08:54:00", "lines": 30, "newlines": 30, "modlines": 0, "user": "SHOW722"}, "text": "         MACRO\n         IOSDULU3\nULU3     DSECT                         UCB Look-up Table\n         DS    C'ULUT'\nULU3VERS DS    X                       version 3                 JH1214\n         DS    AL1                     Subpool\n         DS    XL2                     <filler>\n         DS    F                       <filler>\n         DS    F                       <filler>\nULU31ST  DS    D                       FIRST LOOK-UP ENTRY (V3)\n         DS    XL2                     <filler>\n         DS    XL2                     <filler>\nULU3UCBC DS    F                       Total number of LOOK-UP Entries\nULU3TAPE DS    F'064'                  number of TAPE LOOK-UP Entries\nULU3COMM DS    F'032'                  number of COMM LOOK-UP Entries\nULU3DASD DS    F'256'                  number of DASD LOOK-UP Entries\nULU3DISP DS    F'128'                  number of DISP LOOK-UP Entries\nULU3UREC DS    F'032'                  number of UREC LOOK-UP Entries\nULU3CHAR DS    F'008'                  number of CHAR LOOK-UP Entries\nULU3CTCA DS    F'016'                  number of CTCA LOOK-UP Entries\n         ORG   ULU3+264\nUL3ENTRY DSECT                         UCB LOOK-UP ENTRY\nUL3EDEVN DS    X'000D'                 DEVICE NUMBER\nUL3EFLGS DS    X'4000'                 Flags\nUL3EDYN   EQU  X'40'                   Dynamic UCB\nUL3ESEQN DS    XL2                     ?\n         DS    XL2                     ?\nUL3EUCBP DS    V(UCBOB)                UCB ADDRESS\nUL3ELEN  EQU   *-UL3ENTRY\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PARTREL": {"ttr": 775, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x16\\x00\"\\x01\\x17%\\x8f\\x01 \\x11/\\x15D\\x00\\xd9\\x00\\xbe\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.22", "flags": 0, "createdate": "2017-09-15T00:00:00", "modifydate": "2020-04-21T15:44:22", "lines": 217, "newlines": 190, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBM JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*                                                                   *\n//*********************************************************************\n//*                                                                   *\n//* WARNING, THIS PROGRAM IS DISTRUBTED FROM WWW.CBTTAPE.ORG.         *\n//* THEREFORE, IT IS SHAREWARE, WITH NO FORMAL SUPPORT AND NO         *\n//* WARRANTIES.  THE ULUINIT, ULUSCAN, AND ULUDSECT ARE MAINTAINED    *\n//* BY MEMBERS OF THE CBTTAPE GROUP.  THESE MACROS ALLOW ACCESS TO    *\n//* THE REAL UCB'S, WHICH PARTREL NEEDS.  HOWEVER, IBM DOES NOT       *\n//* SUPPORT THESE INTERFACES, AND THESE INTERFACES ARE SUBJECT TO     *\n//* CHANGE WITHOUT NOTICE.!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!     *\n//*                                                                   *\n//*********************************************************************\n//*                                                                   *\n//ASM1    EXEC PGM=ASMA90\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR\n//         DD  DSN=SYS1.MODGEN,DISP=SHR\n//         DD  DSN=SBGOLOB.CBT499.FILE959,DISP=SHR\n//SYSUT1   DD  DSN=&&SYSUT1,UNIT=SYSDA,SPACE=(CYL,(9,1))\n//SYSPRINT DD  SYSOUT=*\n//SYSPUNCH DD  DUMMY\n//SYSLIN   DD  DSN=&&TEMP,DISP=(,PASS,DELETE),UNIT=SYSDA,\n//             SPACE=(TRK,(15,15),RLSE),LRECL=80,RECFM=FB,\n//             BLKSIZE=0\n//SYSIN    DD  *\nPARTREL  CSECT\nPARTREL  AMODE 31\nPARTREL  RMODE 24\n*********************************************************************\n* PROGRAM TO RELEASE EXCESS SPACE FROM PS AND PO DATASETS.          *\n* PASS FULLY QUALIFIED DSN OF DATASET TO BE RELEASED IN PARM.       *\n* USES PARTREL MACRO. DOESN'T OPEN/CLOSE DATASET, THEREFORE         *\n* WON'T MESS UP LAST ACCESSED DATE.                                 *\n*********************************************************************\n* THIS PROGRAM HAS TO BE LINKEDITED WITH SETCODE AC(1).             *\n*********************************************************************\n* FIXED TO IGNORE THE RETURN CODE FROM PARTREL, AND SET TO 0.   SBG *\n*********************************************************************\n*********************************************************************\n* THE UCB LOOKUP SUPPORT MACROS ARE ULUINIT, ULUSCAN, AND ULUDSECT  *\n* THEY RESIDE IN SYS9.ZOS22.RIMLIB.                                 *\n*********************************************************************\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nPROLOG   STM   14,R12,12(R13)\n         BALR  R12,0\nPSTART   DS    0H\n         USING PSTART,R12\n         ST    R13,MYSAVE+4       SAVE CALLER'S REGISTER 13\n         LA    R2,MYSAVE          GET MY SAVE AREA ADDRESS\n         ST    R2,8(R13)          CHAIN SAVE AREA TO CALLER'S\n         LR    R13,R2             SET UP TO USE LOCAL SAVE AREA\nINITCON  DS    0H\n         MVC   SAVERC,=F'0'       INITIALIZE RETURN CODE TO 0\nGOFORTH  DS    0H\n         OPEN  (INDD,(INPUT),SYSPRINT,(OUTPUT))\n         LTR   R15,R15            IF OPEN SUCCESSFUL\n         BZ    TITLPRNT           YES, KEEP GOING\n         WTO   'OPEN FAILED'      ALERT THAT OPEN FAILED\n         B     FIN                TERMINATE\nTITLPRNT DS    0H\n         MVI   OUTREC1-1,X'40'    CLEAR OUTPUT AREA\n         MVC   OUTREC1,OUTREC1-1\n         MVC   OUTREC1+12(L'TITLE1),TITLE1\n         PUT   SYSPRINT,OUTREC1\n         MVI   OUTREC1-1,X'40'    CLEAR OUTPUT AREA\n         MVC   OUTREC1,OUTREC1-1\n         MVC   OUTREC1+12(L'TITLED),TITLED\n         PUT   SYSPRINT,OUTREC1\nPROCESS  DS    0H\n         LLGTR R12,R12            SET UP BASE REGISTER FOR 64 BIT\n         ULUINIT WRKAREA=WORKU,UREG=R8,EXIT=FIN,WR1=R3,WR2=R4,BREG=R6\n         GET   INDD,INREC         GET LIST OF DSN'S TO RELEASE\n         MVC   DSN,INDSN          MOVE DATA SET NAME\n         MVC   VOLSER,INVOLSER    MOVE DATA SET NAME\n         CLI   VOLSER,C' '        IF INPUT VOLSER NOT BLANK\n         BNE   NOLOCATE           THEN BYPASS LOCATE\n         XR    R15,R15            CLEAR R15                           *\n         LOCATE LOCLIST           FIND OUT WHAT VOLUME THE DSN IS ON  *\n         LTR   R15,R15            LOCATED SUCCESSFULLY?               *\n         BNZ   PROCESS            NO, SO NEXT ONE                     *\n         MVC   VOLSER,LOCAREA+6   GET OUR VOLSER                      *\nNOLOCATE EQU   *\n         MVC   VOL(6),VOLSER      MOVE FOR REPORT\n         CLC   VOLSER,LASTVOL     IF SAME VOLSER\n         BE    RELESIT            YES, NO NEED TO DO UCB LOOKUP\n* ------------------------------------------------------------------- *\n* --  INITIALIZE ULUDSECT CONTROL BLOCK                            -- *\n* ------------------------------------------------------------------- *\n         XR    R15,R15            CLEAR R15\n         BAL   R10,UCBSCAN        FIND THE UCB FOR THE VOLUME\n         LTR   R15,R15            GOOD SCAN?\n         BNZ   PROCESS            NO.\n         XR    R15,R15            CLEAR R15\nRELESIT  EQU   *\n         PARTREL DSN=DSN,MODE=PGM,UCB=(R5),TIOT=ENQ,ERASE=NO,          X\n               MF=(E,PRELLST)\n         LTR   R15,R15            IF PARTREL OK\n         BNZ   RELSENOK           NO, WRITE NOT OK MESSAGE\n         MVC   SAVERC,=F'0'       OUR OWN RETURN CODE 0\n         MVI   OUTREC1-1,X'40'    CLEAR OUTPUT AREA\n         MVC   OUTREC1,OUTREC1-1\n         MVC   OUTREC1,OUTFIL21   YES, WRITE OK MESSAGE\n         PUT   SYSPRINT,OUTREC1   WRITE OUT MESSAGE\n         MVI   OUTREC1-1,X'40'    CLEAR OUTPUT AREA\n         MVC   OUTREC1,OUTREC1-1\n         MVC   OUTREC1+4(6),DSNEQU\n         MVC   OUTREC1+10(44),DSN ....................\n         MVC   OUTREC1+56(6),VOLEQU\n         MVC   OUTREC1+62(6),VOL\n         PUT   SYSPRINT,OUTREC1   WRITE OUT MESSAGE\n         B     NEXTDSN            BRANCH TO GET NEXT RECORD\nRELSENOK EQU   *\n         MVC   SAVERC,=F'4'       OUR OWN RETURN CODE 4\n         MVI   OUTREC1-1,X'40'    CLEAR OUTPUT AREA\n         MVC   OUTREC1,OUTREC1-1\n         MVC   OUTREC1,OUTFIL31   WRITE NOT OK MESSAGE\n         PUT   SYSPRINT,OUTREC1   WRITE OUT MESSAGE\n         MVI   OUTREC1-1,X'40'    CLEAR OUTPUT AREA\n         MVC   OUTREC1,OUTREC1-1\n         MVC   OUTREC1+4(6),DSNEQU\n         MVC   OUTREC1+10(44),DSN\n         MVC   OUTREC1+56(6),VOLEQU\n         MVC   OUTREC1+62(6),VOL\n         PUT   SYSPRINT,OUTREC1   WRITE OUT MESSAGE\nNEXTDSN  EQU   *\n         MVC   LASTVOL,VOLSER     KEEP LAST VOLSER USED FOR COMPARE\n*        PUT   SYSPRINT,OUTREC1   WRITE OUT MESSAGE\n         B     PROCESS            GET ANOTHER RECORD\nFIN      EQU   *\n         CLOSE INDD               CLOSE INDD\n         CLOSE SYSPRINT           CLOSE SYSPRINT\n         L     R13,MYSAVE+4       RESTORE CALLER'S REGISTER 13\n         L     R15,SAVERC         LOAD RETURN CODE WE MADE        SBG\n         ST    R15,16(,R13)       SHOVE IT INTO CORRECT SLOT      SBG\n         LM    R14,R12,12(R13)    RESTORE CALLER'S REGISTERS\n         BR    R14                RETURN TO CALLER\n         SPACE 5\nUCBSCAN  DS    0H\n* ------------------------------------------------------------------- *\n* --  SCAN EACH UCB, REPRESENTED BY A ULUDSECT CONTROL BLOCK       -- *\n* ------------------------------------------------------------------- *\n         ULUSCAN WR1=R3,UCBR=R5,BREG=R6\n         USING UCBOB,R5           ADDRESSABILITY TO UCB.\n         MVC   ULUDCURR,ULUDNEXT  MAKE NEXT ENTRY CURRENT\n         TM    UCBTBYT3,UCB3DACC  IS THIS UCB FOR DASD?\n         BNO   UCBSCAN            NO. LOOK FOR THE NEXT ONE.\n         TM    UCBSTAT,UCBONLI    IS THIS UCB ONLINE?\n         BNO   UCBSCAN            NO. LOOK FOR THE NEXT ONE.\n         CLC   UCBVOLI,VOLSER     IS THIS OUR VOLUME'S UCB?\n         BNE   UCBSCAN            NO. LOOK FOR THE NEXT ONE.\nFOUNDIT  DS    0H\n         XR    R15,R15            CLEAR R15, WE FOUND UCB\n         BR    R10                RETURN TO CALLER\n         EJECT\nMYSAVE   DS  18F\nWORKU    DS  CL88\n         DC  C'#############'\nINREC    DS  0CL80\nINDSN    DS  CL44\nINVOLSER DS  CL6\nINFIL1   DS  CL30\nTITLE1   DC  C' PARTIAL SPACE RELEASE PROGRAM - VERSION 1.2 '\nTITLED   DC  C' ------- ----- ------- -------   ------- --- '\nDSNEQU   DC  C'DSN = '\nVOLEQU   DC  C'VOL = '\n         DS  C' '\nOUTREC1  DS  CL133\nOUTREC2  DS  0CL133\nOUTFIL21 DC  C' FREE SPACE RELEASED FOR DATA SET '\nOUTFIL2L EQU *-OUTFIL21\nOUTDSN2  DS  CL44\nOUTFIL22 DS  CL55\nOUTREC3  DS  0CL133\nOUTFIL31 DC  C' FREE SPACE RELEASE FAILED FOR DATA SET '\nOUTFIL3L EQU *-OUTFIL31+1\nOUTDSN3  DS  CL44\nOUTFIL32 DS  CL48\n         DC  C'%%%%%%%%%%%%%'\nLASTVOL  DC  CL6' '\nVOLSER   DC  CL6' '\nLOCLIST  CAMLST NAME,DSN,,LOCAREA  LOCATE\nDSN      DC  CL44' '\nVOL      DC  CL6' '\nSAVERC   DS  F\nLOCAREA  DS  0D\n         DS  265C\nINDD     DCB DDNAME=INDD,MACRF=GM,DSORG=PS,EODAD=FIN\nSYSPRINT DCB DDNAME=SYSPRINT,MACRF=PM,LRECL=133,DSORG=PS\nPRELLST  PARTREL DSN=DSN,MODE=PGM,MF=L\nPRELPL   PARTREL MF=D\n         IEFUCBOB LIST=YES\n         END\n//*\n//LKED1   EXEC PGM=IEWL,\n//  PARM='LIST,XREF,AMODE=31,RMODE=24,AC(1)'\n//SYSLIN   DD DSN=&&TEMP,DISP=(OLD,DELETE)\n//         DD *\n SETSSI CB499959\n NAME PARTREL(R)\n//SYSLMOD  DD DSN=SYS1.W$$.LINKLIB,DISP=SHR\n//SYSPRINT DD  SYSOUT=*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PARTRET1": {"ttr": 780, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x000\\x01\\x17$O\\x01 \\x10O\\x16$\\x00\\x10\\x00\\x05\\x00\\x00\\xd9\\xe4\\xd5\\xd1\\xc3\\xd3@@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "2017-09-01T00:00:00", "modifydate": "2020-04-13T16:24:30", "lines": 16, "newlines": 5, "modlines": 0, "user": "RUNJCL"}, "text": "//SBGOLOBP JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//* ---------------------------------------------------- *//\n//*   EXECUTION OF THE PARTREL PROGRAM AGAINST A LIST    *//\n//*                  OF DATASET NAMES                    *//\n//* ---------------------------------------------------- *//\n//STEP010  EXEC PGM=PARTREL\n//STEPLIB   DD  DSN=SYS1.W$$.LINKLIB,DISP=SHR\n//SYSPRINT  DD  SYSOUT=*\n//SYSUDUMP  DD  SYSOUT=*\n//*-+----1----+----2----+----3----+----4----VOLSER   (RULER)\n//INDD      DD  *\nSBGOLOB.TEST.PARTREL.PDS                    VPWRKD\nSBGOLOB.TEST.PARTREL2.PDS\nSBGOLOB.TEST.PARTREL.PDS2\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ULUDSECT": {"ttr": 782, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x00\\x00B\\x01\\x124_\\x01\\x15\\x02o\\x18\\x18\\x00\\xe2\\x00D\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "02.00", "flags": 0, "createdate": "2012-12-10T00:00:00", "modifydate": "2015-01-26T18:18:42", "lines": 226, "newlines": 68, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n         ULUDSECT &NAM=ULUDSECT\n&NAM     DSECT\n* ------------------------------------------------------------------- *\n*    ULUDSECT - PASS INFORMATION FROM A ULUT TABLE ENTRY              *\n*                                                                     *\n*    Author   - Sam Golob                                             *\n*                                                                     *\n*    Version  - 2.0.0                                                 *\n*                                                                     *\n*    Current Length - 88 bytes                                        *\n*                                                                     *\n*    Description:                                                     *\n*                                                                     *\n*        The idea of this DSECT is to provide an area to pass         *\n*        information from a UCB Lookup Table entry (ULUE) to a        *\n*        calling program, one entry at a time.                        *\n*                                                                     *\n*        The information requested from each ULUT entry, is what      *\n*        you would probably require during a typical UCB scan.        *\n*                                                                     *\n*        There are also a few register save areas in here.            *\n*                                                                     *\n*        The reason for this arrangement, is to be able to            *\n*        substitute the ULUT lookup for a UCBSCAN macro execution     *\n*        in an Assembler program.  UCBSCAN returns information        *\n*        about one UCB at a time, and we want to be able to do        *\n*        the same thing, using the ULUT method instead.               *\n*                                                                     *\n*        The difference between this method and the UCBSCAN method    *\n*        is that information about REAL UCB's can be returned this    *\n*        way, without the caller having to be APF-authorized.         *\n*                                                                     *\n*        If you are just looking at the UCB and not trying to         *\n*        change anything in it, it seems that this method is          *\n*        quite harmless to use.                                       *\n*                                                                     *\n*    Attribution:                                                     *\n*                                                                     *\n*        This is an undocumented interface that was unearthed for     *\n*        the general public by Gilbert Saint-flour, and we are        *\n*        publicizing this discovery to perpetuate his memory.         *\n*                                                                     *\n*    System Dependencies:                                             *\n*                                                                     *\n*        The user of this interface must be aware that if IBM         *\n*        changes the layout of the ULUT by creating a new \"ULUT       *\n*        type\", then the programming interface must be adjusted       *\n*        for the new ULUT type. (At present writing, there are        *\n*        three ULUT types.  Type 3, starting with PTF UA90741, is     *\n*        located in 64-bit storage.  It is pointed to by a new        *\n*        location in the IOVT, a doubleword at +1B8 (decimal 440)     *\n*        off the beginning of the IOVT.  The previous ULUT types,     *\n*        Type 1 and Type 2, were pointed to by a fullword address     *\n*        at location +8 off the IOVT.                                 *\n*                                                                     *\n*        If IOVT+X'8' (for a fullword) is zero, then IOVT+X'1B8'      *\n*        (for a doubleword) points to the real ULUT (Type 3 or        *\n*        higher).  This depends on PTF level (for z/OS 1.13           *\n*        of z/OS 2.1) or on system level (for z/OS 2.2 and more).     *\n*                                                                     *\n*    ULUT Types:                                                      *\n*                                                                     *\n*        The ULUT interface to UCB scanning is not a documented       *\n*        IBM interface.  Therefore IBM (of course) reserves the       *\n*        right to change it at its own discretion.  It has changed    *\n*        twice, since ESA 5.  This was at the z/OS 1.7 level.         *\n*                                                                     *\n*        A new change, to ULUT Type 2, was made at the z/OS 1.7       *\n*        level.  ULUT Type 3, starting at the z/OS 2.2 level, has     *\n*        been moved to 64-bit storage and is pointed to by a          *\n*        doubleword address at +1B8 off the IOVT.  It must be         *\n*        addressed in 64-bit mode (SAM64).                            *\n*                                                                     *\n*        It is up to the user to keep track of any changes to the     *\n*        ULUT.  Access to the ULUT is provided by the following       *\n*        set of instructions (to be executed in 31-bit mode):         *\n*                                                                     *\n*          L     R3,16                  CVT                           *\n*          L     R3,X'7C'(,R3)          CVTIXAVL - IOCOM              *\n*          L     R3,X'D0'(,R3)          IOVT                          *\n*          L     R4,8(,R3)              UCB Lookup Table (ULUT)       *\n*          LR    R3,R4                  Point both regs to ULUT       *\n*          CLC   =C'ULUT',0(R3)         Eyecatcher there?             *\n*          BNE   EXIT                   Nope. It ain't it. Out.       *\n*                                                                     *\n*        This set of instructions is only valid through ULUT          *\n*        Type 2 (before PTF UA90741).  To include ULUT Type 3         *\n*        as well, you will need the following code:                   *\n*                                                                     *\n*   GETULUT  DS    0H                                                 *\n*            L     R2,16                     CVT                      *\n*            USING CVTMAP,R2                                          *\n*            MVC   OSLVLSW6,CVTOSLV6         Copy off CVTOSLV6 byte   *\n*            DROP  R2                                                 *\n*            L     R3,X'7C'(,R2)             CVTIXAVL                 *\n*            L     R3,X'D0'(,R3)             IOVT                     *\n*            L     R4,8(,R3)                 Check IOVTUL31           *\n*            LTR   R4,R4                     Zero?                    *\n*            BZ    GETULUN2                  Yes. Type 2 or 1.        *\n*            OI    OSLVLSW6,X'40'            No. Indicate 64-bit ULUT *\n*            LLGTR R3,R3                     Clear 33 hi-order bits   *\n*            LLGTR R4,R4                      of                      *\n*            LLGTR R9,R9                       registers              *\n*            LLGTR R10,R10                      for running in        *\n*            LLGTR R12,R12                       64-bit mode.         *\n*            LG    R4,X'1B8'(,R3)            Get dwd addr of ULUT.    *\n*            SAM64                           Go to 64-bit mode        *\n*            LGR   R3,R4                     Copy register.           *\n*            B     GETULUN3                  Skip old 31-bit stuff.   *\n*   GETULUN2 DS    0H                                                 *\n*            L     R4,8(,R3)                 Old ULUT addr off IOVT   *\n*            LR    R3,R4                     Copy register.           *\n*   GETULUN3 DS    0H                                                 *\n*            TM    OSLVLSW6,X'40'            64-bit ULUT?             *\n*            BZ    GETULUN4                  No. Skip 64-bit instrs.  *\n*            LLGTR Rx,Rx            Rx, Ry are base registers, etc.   *\n*            LLGTR Ry,Ry            Rx, Ry are base registers, etc.   *\n*   GETULUN4 DS    0H                                                 *\n*            CLC   =C'ULUT',0(R3)            Eyecatcher present?      *\n*            BNE   EXIT                      No. Get out.             *\n*                                                                     *\n*        A binary number at ULUT+4 indicates the ULUT type.           *\n*        There have currently been three ULUT types, Type X'01'       *\n*        and Type X'02', as well as the new Type X'03' which resides  *\n*        in 64-bit storage.  The pointers to the beginning of the     *\n*        actual table entries, and the addresses of other pointers    *\n*        differ in their location according to ULUT type.  Thus       *\n*        any program looking at the ULUT must first refer to the      *\n*        \"ULUT type\" field, and then get all the other information    *\n*        accordingly.                                                 *\n*                                                                     *\n*        The description of the ULUT table entries themselves,        *\n*        seems to be identical for all ULUT types thus far.           *\n*        For ULUT table entries, the entries are 12 bytes long.       *\n*        The first halfword is the hexadecimal four digit device      *\n*        address.  The last 4 bytes, at entry+8, is the UCB address.  *\n*        Each ULUT table entry also contains a halfword counter,      *\n*        at entry+4, starting with X'0002', and which appears to be   *\n*        incremented by 1, with each successive table entry.          *\n*                                                                     *\n*        However, whenever there is a switch of device type in the    *\n*        ULUT table, the counter field is zero for the last entry     *\n*        representing each given device type.                         *\n*                                                                     *\n*        The way we find the end of the table, is to get the total    *\n*        number of table entries from a field in the ULUT control     *\n*        block, get to the first entry, and count through all the     *\n*        entries until we get to the last one.                        *\n*                                                                     *\n*    Requirements:                                                    *\n*                                                                     *\n*        A calling program will refer to the ULUDSECT data area       *\n*        multiple times.  The number of times will usually reflect    *\n*        the total number of UCB's defined in the ULUT table.  The    *\n*        calling program must GETMAIN storage for this work area,     *\n*        and initialize it to zeros at the beginning.  It must NOT    *\n*        be initialized while the scan is running, because this       *\n*        DSECT is keeping track of which ULUT table entry (i.e.       *\n*        which UCB) the program is currently looking at.              *\n*                                                                     *\n*    Notes:                                                           *\n*                                                                     *\n*        While the calling program has a given ULUT table entry,      *\n*        and its associated UCB, in its sights, it is expected        *\n*        that all the required information be extracted from that     *\n*        UCB and passed to the work area described by this DSECT.     *\n*                                                                     *\n*    Residence:                                                       *\n*                                                                     *\n*        The storage pointed to by this DSECT can reside below        *\n*        the 16M line (in 24-bit storage), but the calling program    *\n*        must execute in 31-bit mode, because the real UCB info       *\n*        may reside above the 16M line, and the ULUT itself is        *\n*        usually located above the 16M line.                          *\n*                                                                     *\n*    Return Codes:                                                    *\n*                                                                     *\n*        Each referral to this DSECT should return a code of 0,       *\n*        except when the table has been exhausted, at which time      *\n*        the return code should be 4.  This is to copy the action     *\n*        of the UCBSCAN macro, so it is easier to insert a            *\n*        routine using this DSECT, into an existing program.          *\n*                                                                     *\n*    Date:  December 10, 2012                                         *\n*                                                                     *\n*    Revision:    2.0.0                                               *\n*                                                                     *\n*    Change History:                                                  *\n*                                                                     *\n*      2.0.0 - 2015/01/26 - Change for doubleword addressing in       *\n*                           the ULUT.  Older ULUT types use the       *\n*                           first word of the doubleword save areas.  *\n*                                                                     *\n* ------------------------------------------------------------------- *\n         DS    0D            Align to doubleword for GETMAIN\nULUDULUT DS    D             Address of ULUT in this system\nULUDCURR DS    D             Current ULUT table entry address\nULUDNEXT DS    D             Next ULUT table entry address\nULUDTOTC DS    F             Total count of ULUT entries\nULUDRUNC DS    F             Realtime descending count of ULUT entries\n*                             (initialized to ULUDTOTC at beginning)\nULUDDEVA DS    H             Device address of current table entry\nULUDCNTR DS    H             Counter in ULUT of current table entry\n*                             This is one higher than the table entry\n*                             count, and is incremented by one with\n*                             each successive table entry.  However,\n*                             this field is sometimes zero when there\n*                             is going to be a switch of device types.\nULUDUCBA DS    F             UCB address of current table entry\nULUDCEXT DS    F             Address of this UCB's common extension\nULUDDEVT DS    F             UCB device type (4 bytes)\nULUDONLF DS    X             UCB + 3 (device online has X'80' set)\nULUDTYPE DS    X             ULUT TYPE for this table\nULUDSLV6 DS    X             Copy of CVTOSLV6 flag byte in the CVT.\n*                             X'40' is used as a switch to show 64-bit.\nULUDRSV1 DS    X             RESERVED\nULUDSVR0 DS    F             Save area for R0 - fullword\nULUDSVR1 DS    F             Save area for R1 - fullword\nULUDSVUR DS    F             Save USING register for workarea\nULUDSVW1 DS    D             Save first work register  - doubleword\nULUDSVW2 DS    D             Save second work register - doubleword\nULUDSVBR DS    F             Save BCT register - fullword\n         DS    0D            Align for GETMAIN\nULUDLENG EQU   *-ULUDSECT\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ULUINIT": {"ttr": 1025, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x00\\x00T\\x01\\x15\\x02o\\x01\\x15\\x02o\"7\\x00\\x86\\x00~\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "02.00", "flags": 0, "createdate": "2015-01-26T00:00:00", "modifydate": "2015-01-26T22:37:54", "lines": 134, "newlines": 126, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n         ULUINIT &WRKAREA=,&UREG=,&EXIT=,&BREG=,&WR1=,&WR2=\n* ------------------------------------------------------------------ *\n*   ULUINIT - Access the ULUT (UCB Lookup Table) and initialize      *\n*             the ULUDSECT control block with some of the ULUT       *\n*             information.                                           *\n* ------------------------------------------------------------------ *\n*                                                                    *\n*   Important:  If you are running with ULUT Type=3 or higher,       *\n*   ---------   this macro invokes the SAM64 instruction.            *\n*                                                                    *\n*       Therefore, YOU MUST CLEAR bit 33 X'00000000_80000000'        *\n*       from the BASE REGISTERS before invoking this macro.          *\n*                                                                    *\n*       Example:  If the base register is R10, then code:            *\n*                                                                    *\n*          LLGTR    R10,R10                                          *\n*          ULUINIT  etc, etc.                                        *\n*                                                                    *\n*       Otherwise you may get a S0C4, reason code 3B.                *\n*                                                                    *\n* ------------------------------------------------------------------ *\n*    The ULUINIT macro must be invoked in AMODE 31.                  *\n*    The ULUINIT macro initializes the ULUDSECT control block.       *\n*    The user must supply a 88 bit workarea for ULUINIT to use.      *\n*    The ULUDSECT work area may reside in 24 bit storage.            *\n* ------------------------------------------------------------------ *\n*        Registers indicated by WRn will be saved and restored.      *\n* ------------------------------------------------------------------ *\n*                                                                    *\n*    Parameter descriptions:                                         *\n*                                                                    *\n*        WRKAREA - a 88 byte work area to contain the data           *\n*                  described by the ULUDSECT control block           *\n*        UREG    - the USING register for accessiblity to the        *\n*                  ULUDSECT control block in the work area           *\n*        EXIT    - a location to escape the ULUT access if           *\n*                  there is an error                                 *\n*        BREG    - BCT register initially containing ULUITOTC        *\n*                  to count table entries as you pass through        *\n*                  them.  May not have to be decremented by BCT.     *\n*                  But it should be decremented for each ULUT        *\n*                  entry that was passed through.                    *\n*        WR1     - work register - saved and restored  31- or 64-bit *\n*        WR2     - work register - saved and restored  31- or 64-bit *\n*                                                                    *\n* ------------------------------------------------------------------ *\n*                                                                    *\n*        Enter and leave this macro in 31-bit mode, always.          *\n*        -----     -----               -----------                   *\n* ------------------------------------------------------------------ *\n         LA    &UREG,&WRKAREA         Point to work area\n         USING ULUDSECT,&UREG\n*                                     Get ULUT and initialize.\n         ST    &UREG,ULUDSVUR         Save USING register in cntl blk.\n         STG   &WR1,ULUDSVW1          Save off entire two bytes.\n         STG   &WR2,ULUDSVW2          Save off entire two bytes.\n         ST    &BREG,ULUDSVBR         Save count register in cntl blk.\n         LLGTR &WR1,&WR1              Make sure hi order not corrupted\n         LLGTR &WR2,&WR2\n         L     &WR1,16                CVT\n         MVC   ULUDSLV6(1),X'4F6'(&WR1)  Move entire CVTOSLV6 to DSECT\n*                                        Will use as a switch, later.\n         LLGTR &WR1,&WR1              Make sure hi order not corrupted\n         LLGTR &WR2,&WR2\n*                                     ****  GET THE ULUT NOW  ****\n         L     &WR1,X'7C'(,&WR1)      CVTIXAVL\n         L     &WR1,X'D0'(,&WR1)      IOVT\n*                                     Check if IOVTUL31 is zero or not.\n*                                     If zero, then IOVTULUT is nonzero\n         L     &WR2,X'8'(,&WR1)       Load IOVTUL31 fullword.\n         LTR   &WR2,&WR2              Is it zero?\n         BNZ   ULUNTYP3               No. We have Type 1 or 2.\n*                                     Yes. Handle 64-bit ULUT\n         OI    ULUDSLV6,X'40'         Indicate 64-bit ULUT table.\n         LG    &WR2,X'1B8'(,&WR1)     Load dwd ULUT address in 2nd reg\n         LGR   &WR1,&WR2              Copy dwd address to first reg\n* ------------------------------------------------------------------ *\n         SAM64                        Deal with ULUT in 64-bit mode\n         CLC   =C'ULUT',0(&WR1)       Is ULUT eyecatcher there?\n         BNE   &EXIT                  No eyecatcher, not ULUT, exit.\n         STG   &WR1,ULUDULUT          Save ULUT address in DSECT\n         CLI   4(&WR1),X'03'          Is the Type = X'03' ?\n         BE    ULUITYP3               Yes. Deal with Type 3.\n         SAM31                        31-bit in anticipation of exit\n         B     &EXIT                  No. exit.\nULUITYP3 DS    0H                     Handle Type 3\n         MVI   ULUDTYPE,X'03'         Indicate ULUT Type 3.\n         SAM64                        Has to be 64-bit mode\n         LG    &WR1,X'10'(,&WR1)      Type 3, addr of first table entry\n         STG   &WR1,ULUDCURR          Store 64-bit entry in cntl block\n         L     &WR2,X'1C'(,&WR2)      Count of all entries - fullword\n         LLGTR &WR2,&WR2              Clear hi order of WR2.\n         SAM31                        Nothing later needs SAM64\n         ST    &WR2,ULUDTOTC          Store in control block\n         ST    &WR2,ULUDRUNC          Initialize running descent count\n         B     ULUILSET               Do search processing.\nULUNTYP3 DS    0H\n         L     &WR2,8(,&WR1)          UCB LOOKUP TABLE (ULUT)\n         LR    &WR1,&WR2              Point both registers to it.\n         CLC   =C'ULUT',0(&WR1)       Eyecatcher there?\n         BNE   &EXIT                  Nope. Not pointing to table.\n         ST    &WR1,ULUDULUT          Start filling control block.\n         CLI   4(&WR1),X'01'          Type 1?\n         BE    ULUITYP1               Yes. Handle as type 1.\n         CLI   4(&WR1),X'02'          Type 2?\n         BE    ULUITYP2               Yes. Handle as type 2.\n         B     &EXIT                  No. If new type, test for it here\nULUITYP1 DS    0H                     Handle Type 1\n         MVI   ULUDTYPE,X'01'         Move type to control block.\n         L     &WR1,X'0C'(,&WR1)      TYPE 1, addr of first entry\n         ST    &WR1,ULUDCURR          Store entry addr in control block\n         L     &WR2,X'10'(,&WR2)      Count of all entries.\n         ST    &WR2,ULUDTOTC          Put number into control block.\n         ST    &WR2,ULUDRUNC          Initialize running descend count\n         B     ULUILSET               Do search processing.\n*\nULUITYP2 DS    0H                     Handle Type 2\n         MVI   ULUDTYPE,X'02'         Move type to control block.\n         L     &WR1,X'14'(,&WR1)      TYPE 2, addr of first entry\n         ST    &WR1,ULUDCURR          Store entry addr in control block\n         L     &WR2,X'18'(,&WR2)      Count of all entries.\n         ST    &WR2,ULUDTOTC          Put number into control block.\n         ST    &WR2,ULUDRUNC          Initialize running descend count\n         B     ULUILSET               Do search processing.\n*\nULUILSET DS    0H                     Must exit in 31-bit mode.\n         L     &BREG,ULUDTOTC         Load number of loops in register\n         LG    &WR1,ULUDSVW1          Restore work register contents\n         LG    &WR2,ULUDSVW2\n*\n         ULUDSECT\n&SYSECT  CSECT ,                      Resume user's CSECT\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ULUSCAN": {"ttr": 1028, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x00\\x00V\\x01\\x124o\\x01\\x15\\x02o\"Q\\x00Q\\x00\\x14\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "02.00", "flags": 0, "createdate": "2012-12-11T00:00:00", "modifydate": "2015-01-26T22:51:56", "lines": 81, "newlines": 20, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n         ULUSCAN &WR1=,&UCBR=,&BREG=\n* ------------------------------------------------------------------ *\n*   ULUSCAN - Access one ULUT (UCB Lookup Table) entry and fill      *\n*             in all the rest of the fields of the ULUDSECT control  *\n*             block, which depend on the current particular ULUT     *\n*             table entry.                                           *\n* ------------------------------------------------------------------ *\n*    The ULUSCAN macro must be invoked in AMODE 31.                  *\n*    The user must supply a 88 bit workarea which contains the       *\n*      data described by the ULUDSECT macro.                         *\n*    The ULUDSECT work area may reside in 24 bit storage.            *\n* ------------------------------------------------------------------ *\n*        Registers indicated by WRn will be saved and restored.      *\n* ------------------------------------------------------------------ *\n*                                                                    *\n*    Parameter descriptions:                                         *\n*                                                                    *\n*        UCBR    - the register pointing to the current UCB          *\n*                  pointed to by this ULUT entry                     *\n*        BREG    - BCT register initially containing ULUDTOTC        *\n*                  to count table entries as you pass through        *\n*                  them.  Later contains descending count,           *\n*                  ULUDRUNC.                                         *\n*        WR1     - work register - saved and restored                *\n*                                                                    *\n* ------------------------------------------------------------------ *\n         TM    ULUDSLV6,X'40'         Is this a 64-bit ULUT?\n         BZ    SKIPTY3                No. Deal as 31-bit.\n         STG   &WR1,ULUDSVW1          Save work reg previous contents\n*                                     64-bit housekeeping\n         LLGTR &WR1,&WR1              Clear 64-bit hi order for safety\n         LLGTR &UCBR,&UCBR            Clear 64-bit hi order for safety\n         LLGTR &BREG,&BREG            Clear 64-bit hi order for safety\n         LG    &WR1,ULUDCURR          Look at current ULUT entry\n         B     SKIPTY2\n*                                     31-bit processing\nSKIPTY3  DS    0H\n         ST    &WR1,ULUDSVW1          Save work reg previous contents\n         L     &WR1,ULUDCURR          Look at current ULUT entry\n*\nSKIPTY2  DS    0H                     Both modes come here.\n         ST    &BREG,ULUDRUNC         Save descending count.\n         TM    ULUDSLV6,X'40'         64-bit ULUT?\n         BZ    SKIPTY3A               No. Stay in 31-bit mode.\n         SAM64\nSKIPTY3A DS    0H                     Both modes come here.\n         MVC   ULUDDEVA(2),0(&WR1)    Get hex device address in entry\n         MVC   ULUDCNTR(2),4(&WR1)    Get counter of this ULUT entry\n         L     &UCBR,8(,&WR1)         Get address of current UCB\n         ST    &UCBR,ULUDUCBA         Save address in control block\n         MVC   ULUDONLF(1),3(&UCBR)   Save byte to show if online\n         MVC   ULUDDEVT(4),X'10'(&UCBR) Copy device type to ctrl block\n*                                   Get address of UCB common extension\n         TM    ULUDSLV6,X'40'         64-bit mode?\n         BZ    SKIPTY3B               No. No need to SAM31.\n         SAM31\nSKIPTY3B DS    0H\n         ST    R1,ULUDSVR1            Save R1 in control block\n         L     R1,ULUDUCBA            Load real UCB address\n         ST    R0,ULUDSVR0            Save register 0\n         IOSCMXR\n         ST    R1,ULUDCEXT            Result of macro, UCB common ext.\n         L     R0,ULUDSVR0            Restore register 0\n         L     R1,ULUDSVR1            Restore register 1\n         TM    ULUDSLV6,X'40'         Running z/OS 2.2 or higher?\n         BZ    SKIPTY3C               No. Don't switch modes.\n         SAM64                        ULUT address is 64-bit\nSKIPTY3C DS    0H\n         LA    &WR1,X'C'(,&WR1)       Go to next ULUT entry\n         TM    ULUDSLV6,X'40'         Are we running a 64-bit ULUT?\n         BZ    SKIPTY3D               No. Handle fullword processing.\n         STG   &WR1,ULUDNEXT          Doubleword processing.\n         LG    &WR1,ULUDSVW1\n         SAM31                        Switch to 31-bit before exit.\n         B     SKIPEXIT\nSKIPTY3D DS    0H                     Fullword processing 31-bit ULUT.\n         ST    &WR1,ULUDNEXT          And save it in control block\n         L     &WR1,ULUDSVW1          Restore prev work reg contents\nSKIPEXIT DS    0H\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT959/FILE959.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT959", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}