{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012524000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 411502, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE646.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 411502, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 411502, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE646.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x07\\x0e'", "DS1TRBAL": "b'\\x0c|'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x04\\x97\\x00\\x03\\x04\\x97\\x00\\n\\x00\\x08'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04V\\x00%\\x01\\x13\\x00\\x1f\\x01\\x13\\x00\\x1f\\x02 \\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf6@@@'", "ispf": {"version": "04.86", "flags": 0, "createdate": "2013-01-01T00:00:00", "modifydate": "2013-01-01T02:20:25", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-486"}, "text": "REGULAR CBT TAPE - VERSION 486    FILE:  646\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT486.FILE646\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 9 MEMBERS COUNTED; CUMULATIVE SIZE IS 3,594 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   01/01/13    02:20:24    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$INTRO": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x10\\x01\\x03$\\x0f\\x01\\x13\\x00\\x1f\\x02\\x14\\x00\"\\x00.\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2003-08-28T00:00:00", "modifydate": "2013-01-01T02:14:10", "lines": 34, "newlines": 46, "modlines": 0, "user": "SBGOLOB"}, "text": "            Convert CLIST to REXX via Automation\n\n\nThis is a CLIST conversion tool which is run as an edit macro.\n\nInstallation requires copying two REXX execs, CLS2REXX and TSOPROC,\nto a SYSPROC or SYSEXEC library that is accessible to your TSO\nsession.\n\nTo run the product, go into ISPF EDIT and edit your CLIST to be\nconverted.  Be sure to make a backup copy of it first.  Then, on\nthe command line, type CLS2REXX and press enter.  The CLS2REXX exec,\nwhich uses the TSOPROC exec to interpret PROC statements, will\nperform the conversion, line by line, with the REXX version as\n\"real\" lines, and the old CLIST version as \"NOTE\" lines in between.\nIn order to complete the operation, you do a SAVE on the command\nline, and the REXX lines will become the permanent ones.\n\nI've tried this program--it's not perfect, but it gives you a start.\nOnce you've gotten an approximate REXX that has been converted from\nyour CLIST, you can try to run it, and it shouldn't be too hard to\nfix manually.\n\nIn this file, I've included a CLIST named DOCFIL which I converted\nto a REXX, named DOCFILX.  Both of these are used in preparing a\nfile to be put on the CBT Tape.  The CLIST and its equivalent REXX\nare used to fix the columns 73-80 of sections of FILE 001 (the\ndocumentation) of the CBT Tape.  If you will notice, columns 73-80\ncontain either the expression \"DOC FILE\" or the file number, for\nexample:  \"FILE 646\".  To see the result just look at member @FILE646\nof this pds, which was treated by this process, and look at columns\n73-80 in this member.  You can find the DOCFILE assembler program\non CBT File 006.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE1": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01\\x03#o\\x01\\x03#o\\x10!\\x00\\x17\\x00\\x17\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-08-24T00:00:00", "modifydate": "2003-08-24T10:21:59", "lines": 23, "newlines": 23, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject: Re: convert CLIST to REXX\nDate: Mon, 17 Dec 2001 12:30:46 +0100\nFrom: \"Gray, Alastair\" <Gray.Alistair@PMINTL.CH>\nReply-To: TSO REXX Discussion List <TSO-REXX@VM.MARIST.EDU>\n\nHi,\n\nHere is a copy of the CLS2REXX code, I have also included TSOPROC\nwhich may be required for the REXX code created.\n\nThe zip contains ASCII versions of both members, together with\nbinaries of XMITted versions.\n\nGood luck and all best wishes for Christmas and the New Year.\n\nAlastair Gray\n\n ---------------------------------------------------------------------\n                   Name: cls2rexx.zip\n   cls2rexx.zip    Type: WinZip File\n                         (application/x-unknown-content-type-WinZip)\n               Encoding: base64\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE2": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00 \\x01\\x03#o\\x01\\x03#o\\x10\"\\x01\\x1b\\x01\\x1b\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-08-24T00:00:00", "modifydate": "2003-08-24T10:22:20", "lines": 283, "newlines": 283, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject: TSO-REXX Digest - 20 Aug 2003 to 22 Aug 2003 (#2003-166)\nDate: Sat, 23 Aug 2003 00:03:28 -0400\nFrom: Automatic digest processor <LISTSERV@VM.MARIST.EDU>\nReply-To: TSO REXX Discussion List <TSO-REXX@VM.MARIST.EDU>\nTo: Recipients of TSO-REXX digests <TSO-REXX@VM.MARIST.EDU>\n\nSubject: TSO-REXX Digest - 20 Aug 2003 to 22 Aug 2003 (#2003-166)\nDate: Sat, 23 Aug 2003 00:03:28 -0400\nFrom: Automatic digest processor <LISTSERV@VM.MARIST.EDU>\nReply-To: TSO REXX Discussion List <TSO-REXX@VM.MARIST.EDU>\nTo: Recipients of TSO-REXX digests <TSO-REXX@VM.MARIST.EDU>\n\nThere are 33 messages totalling 3112 lines in this issue.\n\nTopics of the day:\n\n  1. How to check if a label exists or not? (7)\n  2. Convert CLIST to REXX via automation? (19)\n  3. Clist to REXX (7)\n\n--------------------------------------------------------------------\n\n\nSubject: Convert CLIST to REXX via automation?\nDate: Fri, 22 Aug 2003 06:45:44 -0700\nFrom: Lionel Dyck <Lionel.B.Dyck@KP.ORG>\n\nIs there any tool available to convert TSO Clists to REXX?  Even\na 80-90% conversion would be a good start?\n\nI have an applications group where the last clist programmer\nretired and everyone else knows rexx and they want/need to update\ntheir tools.\n\nthx\n\nLionel B. Dyck, Systems Software Lead\nKaiser Permanente Information Technology\n\n--------------------------------------------------------------------\n\nSubject: Re: Convert CLIST to REXX via automation?\nDate: Fri, 22 Aug 2003 09:37:15 -0500\nFrom: Tina Hilton <Tina.Hilton@ARVATOSYSTEMS.COM>\n\nI have one called CLS2REXX that I got from somewhere.  The\ncomments say it was written by Chuck Tribolet.  Let me know if\nyou want me to send it to you.\n\nTina\n\n--------------------------------------------------------------------\n\nSubject: Re: Convert CLIST to REXX via automation?\nDate: Fri, 22 Aug 2003 10:41:28 -0400\nFrom: \"Richards.Bob\" <Bob.Richards@SUNTRUST.COM>\n\nI already sent Chuck's version to him.\n\nBob\n\n--------------------------------------------------------------------\n\nSubject: Re: Convert CLIST to REXX via automation?\nDate: Fri, 22 Aug 2003 07:53:09 -0700\nFrom: Lionel Dyck <Lionel.B.Dyck@KP.ORG>\n\nThanks for the offer - bob richards sent me a copy.\n\nlooks like a good start\n\n--------------------------------------------------------------------\n\nSubject: Re: Convert CLIST to REXX via automation?\nDate: Fri, 22 Aug 2003 10:22:30 -0500\nFrom: Ronald Wells <RWells@AGFINANCE.COM>\n\nI would be interesting in seeing converter(clist to rexx)>> why\nreinvent a wheel......\n\n----------------------------------------------------------------------\n\nSubject: Re: Convert CLIST to REXX via automation?\nDate: Fri, 22 Aug 2003 11:25:31 -0400\nFrom: Ted MacNeil <ted.macneil@CA.IBM.COM>\n\nIs it possible to post it for others?\n\nTed.MacNEIL@Ca.IBM.COM\n\nThis mind left intentionally blank\n\n----------------------------------------------------------------------\n\nSubject: Re: Convert CLIST to REXX via automation?\nDate: Fri, 22 Aug 2003 11:26:13 -0400\nFrom: \"Ryerse, Robin\" <robin.ryerse@EDS.COM>\n\nLionel: I see other listers have provided you with Chuck\nTriobolet's converter.  I have another courtesy of IBM circa\n1989.   Are you interested?\n\n--------------------------------------------------------------------\n\nSubject: Re: Convert CLIST to REXX via automation?\nDate: Fri, 22 Aug 2003 08:37:46 -0700\nFrom: \"Mosley, George\" <George.Mosley@ICBC.COM>\n\nRobin,\n\nI certainly would, for comparison purposes at least.\n\n--------------------------------------------------------------------\n\nSubject: Re: Convert CLIST to REXX via automation?\nDate: Fri, 22 Aug 2003 11:34:58 -0400\nFrom: \"Ryerse, Robin\" <robin.ryerse@EDS.COM>\n\nThe one I have (from IBM) is close to 4000 lines of code.  I will\nattach it to an email of all listers who request it by end of\ntoday; I am off next week.\n\n--------------------------------------------------------------------\n\nSubject: Re: Convert CLIST to REXX via automation?\nDate: Fri, 22 Aug 2003 08:43:34 -0700\nFrom: \"Valone, Toren W.\" <TValone@DMV.CA.GOV>\n\nJust a quick thought here. I got the CLIST2Rexx conversion tool,\nstarted debugging and getting to work for my shop, then stopped.\nI found that it was easier to go thru the original Clist written,\nand analyze what it was doing, drop allot of dead code,\nunderstand the business rules behind it, identify common\nprocesses (created common called Rexx routines) and then\nrewrote!!\n\n--------------------------------------------------------------------\n\nSubject: Re: Convert CLIST to REXX via automation?\nDate: Fri, 22 Aug 2003 11:45:18 -0400\nFrom: \"Richards.Bob\" <Bob.Richards@SUNTRUST.COM>\n\nWhere at?\n\nIn the meantime, I'll send it to you privately.\n\nBob\n\n--------------------------------------------------------------------\n\nSubject: Re: Convert CLIST to REXX via automation?\nDate: Fri, 22 Aug 2003 11:51:28 -0400\nFrom: Ted MacNeil <ted.macneil@CA.IBM.COM>\n\nI am interested, PLEASE!\n\nTed.MacNEIL@Ca.IBM.COM\n\n----------------------------------------------------------------------\n\nSubject: Re: Convert CLIST to REXX via automation?\nDate: Fri, 22 Aug 2003 11:52:21 -0400\nFrom: \"MacMullen, Mark\" <Mark.MacMullen@MBNA.COM>\n\nPlease include me on the list of those to receive the Clist to\nREXX program.\n\nThank you,\nMark MacMullen\n\n----------------------------------------------------------------------\n\nSubject: Re: Convert CLIST to REXX via automation?\nDate: Fri, 22 Aug 2003 11:53:48 -0400\nFrom: \"Ryerse, Robin\" <robin.ryerse@EDS.COM>\n\nThat was my experience too. In particular, I have a personal\navertion to GOTO / Signal\n\n----------------------------------------------------------------------\n\nSubject: Clist to REXX\nDate: Fri, 22 Aug 2003 08:39:35 -0700\nFrom: Lionel Dyck <Lionel.B.Dyck@KP.ORG>\n\nI have talked to the author of the clist to rexx edit macro and\nhe will have to get his managers ok to publically share it - that\nok should come next week and once I get it I will forward it to\nSam Golob for posting on the CBT 'virtual' Tape site.\n\nbtw. the edit macro was written by Chuck over 10 years ago to\nsolve a problem that he had and now he is no longer involved with\nmainframes (part of ibm research)\n\n--------------------------------------------------------------------\n\nSubject: Re: Convert CLIST to REXX via automation?\nDate: Fri, 22 Aug 2003 11:59:46 -0400\nFrom: \"Chambers, David W.\" <David.Chambers@NSCORP.COM>\n\nThere is a version of CLS2REXX already posted to the list in a\nzip file. You should be able to retrieve it by sending either:\n\nGETPOST TSO-REXX 7786\nor\nGETPOST TSO-REXX 7789\n\nto LISTSERV@VM.MARIST.EDU.\n\nAssuming your e-mail system doesn't remove attachments.\n\nDavid Chambers\n\n--------------------------------------------------------------------\n\nSubject: Re: Convert CLIST to REXX via automation?\nDate: Fri, 22 Aug 2003 08:43:28 -0700\nFrom: Lionel Dyck <Lionel.B.Dyck@KP.ORG>\n\nRobin - I would be interested as it might do more or less (worth\ncomparing).  Do you know if it can be shared on the cbttape?\n\n--------------------------------------------------------------------\n\nSubject: Re: Clist to REXX\nDate: Fri, 22 Aug 2003 12:53:52 -0400\nFrom: \"Richards.Bob\" <Bob.Richards@SUNTRUST.COM>\n\nTed is right. There seems to be a missing procedure or exec. I\nhonestly did not look that far into the code to notice this. I\njust ran it. Does anyone who also has this code know where it is?\n\nBy the way, it is called on an OTHERWISE statement and I never\nsaw an error running it.\n\nBob\n\n--------------------------------------------------------------------\n\nFrom:   Ted MacNeil [mailto:ted.macneil@CA.IBM.COM]\nSent:   Friday, August 22, 2003 12:19 PM\nTo:     TSO-REXX@VM.MARIST.EDU\nSubject:        Re: Clist to REXX\n\nWhere does one find TSOPROC to be able to use this?\n\nTed.MacNEIL@Ca.IBM.COM\n\n---------------------------------------------------------------------\n\nSubject: Re: Clist to REXX\nDate: Fri, 22 Aug 2003 12:53:52 -0400\nFrom: \"Richards.Bob\" <Bob.Richards@SUNTRUST.COM>\n\nTed is right. There seems to be a missing procedure or exec. I\nhonestly did not look that far into the code to notice this. I\njust ran it. Does anyone who also has this code know where it is?\n\nBy the way, it is called on an OTHERWISE statement and I never\nsaw an error running it.\n\nBob\n\n---------------------------------------------------------------------\n\nSubject: Re: Clist to REXX\nDate: Fri, 22 Aug 2003 12:58:34 -0400\nFrom: \"Chambers, David W.\" <David.Chambers@NSCORP.COM>\n\nThe zip file posted previously also contains the TSOPROC code.\n\nDavid Chambers\n\n---------------------------------------------------------------------\n\nSubject: Re: Clist to REXX\nDate: Fri, 22 Aug 2003 13:27:00 -0400\nFrom: \"Richards.Bob\" <Bob.Richards@SUNTRUST.COM>\n\nThanks David. I have it now.\n\nBob\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE646": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04V\\x00\\x19\\x01\\x13\\x00\\x1f\\x01\\x13\\x00\\x1f\\x02 \\x00\\x14\\x00\\x14\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf6@@@'", "ispf": {"version": "04.86", "flags": 0, "createdate": "2013-01-01T00:00:00", "modifydate": "2013-01-01T02:20:19", "lines": 20, "newlines": 20, "modlines": 0, "user": "CBT-486"}, "text": "//***FILE 646 is an automation tool from IBM, to convert a CLIST    *   FILE 646\n//*           to a REXX exec.  This code has been released to a     *   FILE 646\n//*           public LISTSERV, so I assume it is in the public      *   FILE 646\n//*           domain already.  I am including, as members $$NOTE1   *   FILE 646\n//*           and $$NOTE2, the pieces of LISTSERV transcripts,      *   FILE 646\n//*           with their respective dates, as an indication that    *   FILE 646\n//*           it is probably OK to distribute this code.  Also      *   FILE 646\n//*           see member $$INTRO for hints how to install and       *   FILE 646\n//*           run this tool.                                        *   FILE 646\n//*                                                                 *   FILE 646\n//*           I've included a \"before\" and \"after\" example of a     *   FILE 646\n//*           CLIST which was converted to a REXX.  The conversion  *   FILE 646\n//*           was not completely automatic, but with a few minor    *   FILE 646\n//*           adjustments, is was made to work OK.  The CLIST       *   FILE 646\n//*           member is called DOCFIL, and the converted REXX is    *   FILE 646\n//*           called DOCFILX.                                       *   FILE 646\n//*                                                                 *   FILE 646\n//*           email:  sbgolob@cbttape.org     or                    *   FILE 646\n//*                   sbgolob@attglobal.net                         *   FILE 646\n//*                                                                 *   FILE 646\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CLS2REXX": {"ttr": 530, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00E\\x00\\x94)\\x9f\\x01\\x03$\\x0f\\t\\x00\\nj\\nf\\x00\\x00\\xd7\\xe4\\xc2\\xd3\\xc9\\xc3@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1994-10-26T00:00:00", "modifydate": "2003-08-28T09:00:45", "lines": 2666, "newlines": 2662, "modlines": 0, "user": "PUBLIC"}, "text": "/* REXX ***************************************************************/\n/***                                                                  */\n/*** Needs:                                                           */\n/***   Make sure it will still run on CMS                             */\n/***   Generate correct initialization code for PDF edit macros       */\n/***   Remove any TRIBLET-specific stuff                              */\n/***   IF A = THEN NOP does not translate correctly.                  */\n/***   TC09.2                                                         */\n/***   IF A=B THEN ELSE should generate a NOP ELSE clause. (TC09.3)   */\n/***   Message IDs                                                    */\n/***   Use MSG for CONTROL LIST/NOLIST                                */\n/***   Update help text                                               */\n/***                                                                  */\n/***                                                                  */\n/***                                                                  */\n/***                                                                  */\n/*** Fixed Problems:                                                  */\n/***   SET X = TOM, &NRSTR(&MIDDLE), AND HARRY                        */\n/***     translates to:                                               */\n/***       x = \"TOM,\" middle, \"AND HARRY\"                             */\n/***   Optimized parsing when only postional parms, or no parms       */\n/***     at all.                                                      */\n/***   Correct use of Clist continuation.                             */\n/***   ISPEXEC TBCLOSE TABLE LIBRARY(&LIBNAME) translates to          */\n/***     Address ISPEXEC \"TBCLOSE TABLE LIBRARY(\"libname)             */\n/***     Note the incorrect handling of the close paren, but then     */\n/***     we also have to handle close parens in arithmetic            */\n/***     expressions.                                                 */\n/***   ALLOC FILE(FOO) DA(*) REUSE                                    */\n/***     translates to                                                */\n/***   \"ALLOC FILE(FOO) DA(\"*) \"REUSE\"                                */\n/***   Support for SYSTWOBYTE function                                */\n/***   SET FOO = (no right side) is a valid CLIST stmt.  See TC06.    */\n/***   SAA REXX conformance                                           */\n/***   GOODREXX                                                       */\n/***   Some comments get closed with star slash star. (could not      */\n/***     reproduce)                                                   */\n/***   Support for SYSCLENGTH function                                */\n/***   Support for SYSCSUBSTR function                                */\n/***   Support for converting FB 80 execs                             */\n/***   This exec can now be put in an FB 80 exec file                 */\n/***                                                                  */\n/*** 'Post Chuck' changes :                                           */\n/***   14/12/2001 - CHG0001                                           */\n/***   Correct 'Call Putudndent' to 'Call Put_indent'                 */\n/***   thomas.cothmann@ppi.de                                         */\n/***                                                                  */\n/***                                                                  */\n/*** CLS2REXX - An ISPF/PDF edit macro to assist with conversion of   */\n/***           CLISTs to REXX.  See help text below for details.      */\n/***                                                                  */\n/*** This macro will run under both TSO and CMS.                      */\n/***                                                                  */\n/*** Author: Chuck Tribolet, TRIBLET at STLMVS1                       */\n/***                                                                  */\n/**********************************************************************/\nSignal On NoValue\nParse source opsys . cmd_name .\nIf opsys = \"TSO\"\n  Then\n    Do\n    ADDRESS ISREDIT\n    ISREDIT = \"\"\n    End\n  Else\n    ISREDIT = \"ISREDIT\"\nISREDIT \"MACRO (PARM)\"\nparm = strip(translate(parm))\nIf parm = \"?\"\n  Then\n    Do\n    Call Help\n    Exit 0\n    End\ntest_mode = 0\nSelect\n  When parm = \"TEST\"\n    Then\n      test_mode = 1\n  When parm = \"TRACE\"\n    Then\n      test_mode = 2\n  When parm = \"\"\n    Then\n      Nop\n  Otherwise\n      Do\n      zedsmsg = \"Invalid parm\"\n      zedlmsg = '\"'parm'\" is an invalid parameter.'\n      ADDRESS  ISPEXEC \"SETMSG MSG(ISRZ001)\"\n      Exit 8\n      End\n  End\nif test_mode \u00ac= 0\n  then\n    Say 'Test_mode =' Test_mode\nIf opsys = \"TSO\" & userid() = \"TRIBLET\"\n  Then\n    Do\n    ISREDIT \"(DSNAME) = DATASET\"\n    If dsname = \"TRIBLET.CLS2REXX.TESTCASE.CLIST\",\n      |dsname = \"TRIBLET.CLS2REXX.TESTCASE.CLISTFB\"\n      Then\n        Do\n        ISREDIT \"DEFINE CLS2FILE CMD MACRO\"\n        ISREDIT \"DEFINE SAVE DISABLED\"\n        ISREDIT \"DEFINE END ALIAS CLS2FILE\"\n        End\n    End\nISREDIT \"(FIRSTLIN) = LINE 1\"\nIf left(word(firstlin,1),2) = \"/*\",\n  & pos(\"REXX\",firstlin) \u00ac= 0\n  Then\n    Do\n    zedsmsg = \"Already REXXified\"\n    zedlmsg = \"The current file is already a REXX exec.\"\n    ADDRESS  ISPEXEC \"SETMSG MSG(ISRZ001)\"\n    Exit 4\n    End\nISREDIT \"(NUMLINES) = LINENUM .ZLAST\"\nISREDIT \"(LRECL) = LRECL\"\nISREDIT \"(RECFM) = RECFM\"\nIf recfm = \"F\",\n  & lrecl = 80,\n  Then\n    lrecl = lrecl - 8\ntoken_offset = 0\ncurr_token = \"\"\nnext_token = \"\"\ncurr_char  = \"\"\nnext_char  = \"\"\ncurr_stmt = \"\"\nnew_exp   = \"\"\nlabel_list = \"\"\nverb = \"\"\noutput_line.1 = \"\"\noutput_line_type.1 = \"\"\noutput_recd = \"\"\npdf_edit_macro_found = 0\ncontrol_stmt_used = 0\ncontrol_list_stmt_used = 0\nfirst_proc_stmt_found = 0\ninput_line_number = 0\noutput_line_number = 0\n\nmust_define.sysdval = 0\nmust_define.sysprompt = 0\nmust_define.syssymlist = 0\nmust_define.sysconlist = 0\nmust_define.syslist = 0\nmust_define.sysasis = 0\nmust_define.sysmsg = 0\nmust_define.sysflush = 0\nmust_define.eval = 0\nmust_define.syslc = 0\nmust_define.substrc = 0\nmust_define.sysnsub = 0\nmust_define.sysouttrap = 0\nmust_define.sysoutline = 0\nindent = 0\nCall Get_Stmt\nDo while input_line_number <= numlines\n  Call Parse_Stmt\n  End\nindent = 0\nCall Put_Stmt \"Exit 0\"\nIf control_list_stmt_used\n  Then\n    Do\n    Call Put_Stmt \" \"\n    Call Put_Stmt \"check_control_options:\"\n    Call Put_Stmt \"Select\"\n    Call Put_Stmt \"  When syssymlist = 'ON' & sysconlist= 'OFF'\"\n    Call Put_Stmt \"    Then\"\n    Call Put_Stmt \"      control_options_value = 'a'\"\n    Call Put_Stmt \"  When sysconlist = 'ON'\"\n    Call Put_Stmt \"    Then\"\n    Call Put_Stmt \"      control_options_value = 'r'\"\n    Call Put_Stmt \"  When syslist = 'ON'\"\n    Call Put_Stmt \"    Then\"\n    Call Put_Stmt \"      control_options_value = 'c'\"\n    Call Put_Stmt \"  Otherwise\"\n    Call Put_Stmt \"      control_options_value = 'o'\"\n    Call Put_Stmt \"  End\"\n    Call Put_Stmt \"  Return 0\"\n    End\nISREDIT \"CAPS OFF\"\nISREDIT \"NUMBER OFF\"\nISREDIT \"DELETE .ZFIRST .ZLAST\"\nISREDIT 'LINE_AFTER 0 = \"/* REXX */\"'\nIf opsys = 'TSO'\n  Then\n    Address TSO \"NEWSTACK\"\n  Else\n    Address CMS \"MAKEBUF\"\nalready_queued = queued()\nQueue \"/* \"cmd_name\"ed by\" userid() \"on\" date() \"at\" time() \" */\"\nQueue \"Signal On NoValue\"\nQueue \"Parse source opsys . exec_name .\"\nIf pdf_edit_macro_found\n  Then\n    Do\n    Queue \"If opsys = 'TSO'\"\n    Queue \"  Then\"\n    Queue \"    Do\"\n    Queue \"    Address ISREDIT\"\n    Queue \"    ISREDIT = ''\"\n    Queue \"    End\"\n    Queue \"  Else\"\n    Queue \"    ISREDIT = 'ISREDIT'\"\n    End\nIf must_define.sysdval\n  Then\n    Queue \"sysdval = ''\"\nIf must_define.sysprompt\n  Then\n    Queue \"sysprompt = 'OFF'\"\nIf must_define.syssymlist,\n  | control_list_stmt_used\n  Then\n    Queue \"syssymlist = 'OFF'\"\nIf must_define.sysconlist,\n  | control_list_stmt_used\n  Then\n    Queue \"sysconlist = 'OFF'\"\nIf must_define.syslist,\n  | control_list_stmt_used\n  Then\n    Queue \"syslist = 'OFF'\"\nIf must_define.sysasis\n  Then\n    Queue \"sysasis = 'OFF'\"\nIf must_define.sysmsg\n  Then\n    Queue \"sysmsg = 'ON'\"\nIf must_define.sysflush\n  Then\n    Queue \"sysflush = 'ON'\"\nIf control_stmt_used\n  Then\n    Queue \"control_options_value = 'o'\"\nQueue \" \"\nQueue \" \"\nCall Append_Stack\nIf opsys = 'TSO'\n  Then\n    Address TSO \"DELSTACK\"\n  Else\n    Address CMS \"DROPBUF\"\nDo i = 1 to output_line_number\n  thisline = strip(output_line.i,\"t\")\n  If length(thisline) = 0\n    Then\n      ThisLine = \" \"\n  ISREDIT \"(LAST) = LINENUM .ZLAST\"\n  If test_mode >= 1\n    Then\n      Say \"LineBefor\" last output_line_type.i '\"'ThisLine'\"'\n  ISREDIT \"LINE_BEFORE .ZLAST =\" output_line_type.i \"(THISLINE)\"\n  End\nIf opsys = 'TSO'\n  Then\n    Address TSO \"NEWSTACK\"\n  Else\n    Address CMS \"MAKEBUF\"\nalready_queued = queued()\nIf must_define.eval\n  Then\n    Do\n    Queue \" \"\n    Queue \"eval: Procedure\"\n    Queue \"  Return arg(1)\"\n    End\nIf must_define.syslc\n  Then\n    Do\n    Queue \" \"\n    Queue \"syslc: Procedure\"\n    Queue \"  Return translate(arg(1),,\"\n    Queue \"       'abcdefghijklmnopqrstuvwxyz',,\"\n    Queue \"       'ABCDEFGHIJKLMNOPQRSTUVWXYZ')\"\n    End\nIf must_define.substrc\n  Then\n    Do\n    Queue \" \"\n    Queue \"substrc: Procedure\"\n    Queue \" If arg(3) = ''\"\n    Queue \"   Then\"\n    Queue \"     Do\"\n    Queue \"     s = Arg(1)\"\n    Queue \"     l = 1\"\n    Queue \"     v = arg(2)\"\n    Queue \"     End\"\n    Queue \"   Else\"\n    Queue \"     Do\"\n    Queue \"     s = arg(1)\"\n    Queue \"     l = arg(2)-arg(1)+1\"\n    Queue \"     v = arg(3)\"\n    Queue \"     End\"\n    Queue \"  Return substr(v,s,l)\"\n    End\nIf must_define.sysnsub\n  Then\n    Do\n    Queue \" \"\n    Queue \"sysnsub: Procedure\"\n    Queue \" return arg(1)\"\n    End\nIf must_define.sysouttrap\n  Then\n    Do\n    Queue \" \"\n    Queue \"sysouttrap: /*Procedure*/\"\n    Queue \"  Interpret 'sysouttrap_Result = 'OutTrap()'MAX'\"\n    Queue \"  Return sysouttrap_Result\"\n    End\nIf must_define.sysoutline\n  Then\n    Do\n    Queue \" \"\n    Queue \"sysoutline: /*Procedure*/\"\n    Queue \"  sysouttrap_Index = arg(1)\"\n    Queue \"  Interpret 'sysouttrap_Result = 'OutTrap()sysouttrap_Index\"\n    Queue \"  Return sysouttrap_Result\"\n    End\nQueue \" \"\nCall Append_Stack\nIf opsys = 'TSO'\n  Then\n    Address TSO \"DELSTACK\"\n  Else\n    Address CMS \"DROPBUF\"\nISREDIT \"LEFT MAX\"\nISREDIT \"UP MAX\"\nExit 0\n/*1*/\n/**********************************************************************/\n/*** Parse_Stmt:                                                    ***/\n/***   Subroutine to parse a single CLIST statement, and translate  ***/\n/***   it to REXX.                                                  ***/\n/***                                                                ***/\n/***   Parameters:                                                  ***/\n/***     None.                                                      ***/\n/***                                                                ***/\n/**********************************************************************/\n\nParse_Stmt: Procedure expose curr_token,\n                             curr_token_type,\n                             next_token,\n                             next_token_type,\n                             token_offset,\n                             first_token,\n                             curr_stmt,\n                             curr_char,\n                             next_char,\n                             test_mode,\n                             expr_depth,\n                             numlines,\n                             input_line_number,\n                             cmd_name,\n                             output_recd,\n                             output_line_type.,\n                             output_line.,\n                             output_line_number,\n                             quote_mode,\n                             must_define.,\n                             new_exp,\n                             verb,\n                             lrecl,\n                             label_list,\n                             pdf_edit_macro_found,\n                             control_stmt_used,\n                             control_list_stmt_used,\n                             first_proc_stmt_found,\n                             indent,\n                             isredit\n  expr_depth = 0\n  If input_line_number > numlines\n    Then\n      Leave\n  If test_mode >= 2\n    Then\n      Say 'Parse_Stmt' verb\n  Select\n\n    When verb = \"PROC\"\n      Then\n        Do\n        If first_proc_stmt_found\n          Then\n            Do\n            indent = indent + 2\n            Call Put_Stmt \"Procedure\"\n            End\n        tsoproc_parms = \"PROC\"\n        Do while curr_token_type \u00ac= \"<eos>\"\n          Call Get_Token\n          Select\n            When curr_token_type = \"<comment>\"\n              Then\n                Call Put_Stmt curr_token\n            When curr_token_type = \"<eos>\"\n              Then\n                Nop\n            Otherwise\n                tsoproc_parms = tsoproc_parms||curr_token\n            End\n          End\n        Select\n          When words(tsoproc_parms) <= 2\n            Then\n              Nop\n          When datatype(word(tsoproc_parms,2)) \u00ac= \"NUM\"\n            Then\n              Do\n              Call Put_Msg \"Warning:\" verb \"at input line\",\n                   input_line_number \"has non-numeric count.\"\n              End\n          When word(tsoproc_parms,2) = words(tsoproc_parms)-2\n            Then\n              Do\n              Call Put_Stmt \"Parse upper arg argument_list\"\n              Call Put_Stmt \"If words(argument_list) >\",\n                            word(tsoproc_parms,2)\n              Call Put_Stmt \"  Then\"\n              Call Put_Stmt \"    Do\"\n              Call Put_Stmt \"    Say 'Extraneous parm value\",\n                                   \"\"\"'subword(argument_list,\",\n                                   word(tsoproc_parms,2)+1\")'\"\"\",\n                                   \"ignored.'\"\n              Call Put_Stmt \"    End\"\n              Call Put_Stmt \"If words(argument_list) <\",\n                            word(tsoproc_parms,2)\n              Call Put_Stmt \"  Then\"\n              Call Put_Stmt \"    Do\"\n              Call Put_Stmt \"    Say 'Positional Parms'\",\n                                   \"subword('\"tsoproc_parms\"',\",\n                                   \"words(argument_list)+3) 'omitted.'\"\n              Call Put_Stmt \"    Exit\"\n              Call Put_Stmt \"    End\"\n              Call Put_Stmt \"Parse Var argument_list\",\n                            subword(tsoproc_parms,3) \".\"\n              End\n          Otherwise\n              Do\n              Call Put_Stmt \"Parse upper arg argument_list\"\n              Call Put_Stmt \"Call TSOPROC argument_list,,\n                            '\"tsoproc_parms\"'\"\n              Call Put_Stmt \"Interpret Result\"\n              Call Put_Stmt \"If RC \u00ac= 0\"\n              Call Put_Stmt \"  Then\"\n              Call Put_Stmt \"    Do\"\n              Call Put_Stmt \"    Say tsoproc_msg\"\n              Call Put_Stmt \"    Exit RC\"\n              Call Put_Stmt \"    End\"\n              End\n          End\n        Call Get_Stmt\n        If first_proc_stmt_found\n          Then\n            Do\n            Do while verb \u00ac= \"END\",\n              & input_line_number <= numlines\n              Call Parse_Stmt\n              End\n            Call Put_indent                 /* CHG-0001 */\n            Call Put_Token \"Return\"\n            Call Get_Token\n            Call Parse_Expression\n            Call Put_Line\n            Call Get_Stmt\n            indent = indent - 2\n            End\n        first_proc_stmt_found = 1\n        End\n\n    When verb = \"ATTN\"\n      Then\n        Do\n        Call Put_Msg \"Warning:\" verb \"at input line\",\n             input_line_number \"not translateable by\" cmd_name\".\"\n        Call Put_Token \"/*!\"\n        Call Put_Indent\n        Call Put_Token verb||\" \"\n        Call Get_Token\n        Call Parse_Expression\n        Call Put_Token \"*/\"\n        Call Put_Line\n        Call Get_Stmt\n        End\n\n    When verb = \"CLOSFILE\"\n      Then\n        Do\n        Call Get_Token\n        Call Get_Token\n        Call Put_Indent\n        Call Put_Token 'Address TSO \"EXECIO * DISKR '\n        If curr_token_type = \"<variable>\"\n          Then\n            Call Put_Token '\"'substr(curr_token,2)'\"'\n          Else\n            Call Put_Token curr_token\n        Call Put_Token ' (FINIS\"'\n        Call Put_Line\n        Call Get_Token\n        Call Get_Stmt\n        End\n\n    When verb = \"CONTROL\"\n      Then\n        Do\n        control_stmt_used = 1\n        Call Get_NonBlank_Token\n        list_option_set = 0\n        Call Put_Stmt \"Do\"\n        Do while curr_token_type \u00ac= \"<eos>\"\n          Select\n            When curr_token = \"LIST\"\n              Then\n                Do\n                Call Put_Stmt \"Syslist = 'ON'\"\n                list_option_set = 1\n                End\n            When curr_token = \"NOLIST\"\n              Then\n                Do\n                Call Put_Stmt \"Syslist = 'OFF'\"\n                list_option_set = 1\n                End\n            When curr_token = \"CONLIST\"\n              Then\n                Do\n                Call Put_Stmt \"sysconlist = 'ON'\"\n                list_option_set = 1\n                End\n            When curr_token = \"NOCONLIST\"\n              Then\n                Do\n                Call Put_Stmt \"sysconlist = 'OFF'\"\n                list_option_set = 1\n                End\n            When curr_token = \"SYMLIST\"\n              Then\n                Do\n                Call Put_Stmt \"syssymlist = 'ON'\"\n                list_option_set = 1\n                End\n            When curr_token = \"NOSYMLIST\"\n              Then\n                Do\n                Call Put_Stmt \"syssymlist = 'OFF'\"\n                list_option_set = 1\n                End\n            When curr_token = \"PROMPT\"\n              Then\n                Do\n                Call Put_Stmt \"Call Prompt 'ON'\"\n                Call Put_Stmt \"sysprompt = 'ON'\"\n                must_define.sysprompt = 1\n                End\n            When curr_token = \"NOPROMPT\"\n              Then\n                Do\n                Call Put_Stmt \"Call Prompt 'OFF'\"\n                Call Put_Stmt \"sysprompt = 'OFF'\"\n                must_define.sysprompt = 1\n                End\n            When curr_token = \"MSG\"\n              Then\n                Do\n                Call Put_Stmt \"Call OutTrap 'OFF'\"\n                Call Put_Stmt \"sysmsg = 'ON'\"\n                must_define.sysmsg = 1\n                End\n            When curr_token = \"NOMSG\"\n              Then\n                Do\n                Call Put_Stmt \"Call OutTrap 'outtrap.'\"\n                Call Put_Stmt \"sysmsg = 'OFF'\"\n                must_define.sysmsg = 1\n                End\n            When curr_token = \"FLUSH\"\n              Then\n                Do\n                Call Put_Msg \"Warning: CONTROL\" curr_token,\n                    \"at input line\" input_line_number,\n                    \"not translateable by\" cmd_name\".\"\n                Call Put_Stmt \"sysflush = 'ON' /*!*/\"\n                must_define.sysflush = 1\n                End\n            When curr_token = \"NOFLUSH\"\n              Then\n                Do\n                Call Put_Msg \"Warning: CONTROL\" curr_token,\n                     \"at input line\" input_line_number,\n                     \"not translateable by\" cmd_name\".\"\n                Call Put_Stmt \"sysflush = 'OFF' /*!*/\"\n                must_define.sysflush = 1\n                End\n            When curr_token = \"CAPS\"\n              Then\n                Do\n                Call Put_Msg \"Warning: CONTROL\" curr_token,\n                     \"at input line\" input_line_number,\n                     \"not translateable by\" cmd_name\".\"\n                Call Put_Stmt \"sysasis = 'OFF' /*!*/\"\n                must_define.sysasis = 1\n                End\n            When curr_token = \"NOCAPS\"\n              Then\n                Do\n                Call Put_Stmt \"sysasis = 'ON'\"\n                must_define.sysasis = 1\n                End\n            When curr_token = \"ASIS\"\n              Then\n                Do\n                Call Put_Stmt \"sysasis = 'ON'\"\n                must_define.sysasis = 1\n                End\n            When curr_token = \"MAIN\"\n              Then\n                Do\n                Call Put_Msg \"Warning: CONTROL\" curr_token,\n                    \"at input line\" input_line_number,\n                    \"not translateable by\" cmd_name\".\"\n                Call Put_Stmt \"/*!CONTROL MAIN*/\"\n                End\n            When curr_token = \"END\"\n              Then\n                Do\n                Call Put_Msg \"Warning: CONTROL\" curr_token,\n                    \"at input line\" input_line_number,\n                    \"not translateable by\" cmd_name\".\"\n                Call Put_Stmt \"/*!CONTROL END*/\"\n                End\n            Otherwise\n                Call Put_Msg \"Warning: CONTROL\" curr_token,\n                             \"at input line\",\n                     input_line_number \"not recognized by\" cmd_name\".\"\n            End\n          Call Get_NonBlank_Token\n          End\n        If list_option_set\n          Then\n            Do\n            control_list_stmt_used = 1\n            Call Put_Stmt \"Call check_control_options\"\n            Call Put_Stmt \"trace value control_options_value\"\n            End\n        Call Put_Stmt \"End\"\n        Call Get_Stmt\n        End\n\n    When verb = \"DATA\"\n      Then\n        Do\n        Call Get_NonBlank_Token\n        save_token = curr_token\n        Call Put_Stmt \"Do \"\n        Call Get_Stmt\n        Do while verb \u00ac= \"ENDDATA\",\n          & input_line_number <= numlines\n          Call Put_Indent\n          If save_token = \"PROMPT\"\n            Then\n              Call Put_Token \"Queue '\"verb\" \"\n            Else\n              Call Put_Token \"Address TSO \"\n          Call Get_Token\n          Call Parse_Expression \"q\"\n          Call Put_Line\n          Call Get_Stmt\n          End\n        Call Put_Indent\n        Call Put_Token \"End \"\n        Call Get_Token\n        Call Parse_Expression\n        Call Put_Line\n        Call Get_Stmt\n        End\n\n    When verb = \"DO\"\n      Then\n        Do\n        Call Put_Indent\n        Call Put_Token \"Do\"\n        Call Get_Token\n        Do while curr_token_type = \"<comment>\",\n          | curr_token_type = \"<blanks>\"\n          Call Put_Token curr_token\n          Call Get_Token\n          End\n        If next_token_type = \"<eos>\"\n          Then\n            Do\n            Call Get_Token\n            Call Parse_Expression\n            Call Put_Line\n            Call Get_Stmt\n            Do while verb \u00ac= \"END\",\n              & input_line_number <= numlines\n              Call Parse_Stmt\n              End\n            Call Put_Indent\n            Call Put_Token \"End \"\n            Call Get_Token\n            Call Parse_Expression\n            Call Put_Line\n            Call Get_Stmt\n            End\n          Else\n            Do\n            If  curr_token \u00ac= \"WHILE\",\n              & curr_token \u00ac= \"UNTIL\",\n              Then\n                Do\n                Call Put_Indent\n                If left(curr_token,1) = \"&\"\n                  Then\n                    curr_token = substr(curr_token,2)\n                Call Put_Token curr_token\" \"\n                Call Get_Token\n                Call Parse_Expression \"\",\"Do_i\"\n                If curr_token = \"TO\"\n                  Then\n                    Do\n                    Call Put_Token \"to \"\n                    Call Get_Token\n                    Call Parse_Expression \"\",\"Do_to\"\n                    End\n                If curr_token = \"BY\"\n                  Then\n                    Do\n                    Call Put_Token \"by \"\n                    Call Get_Token\n                    Call Parse_Expression \"\",\"Do_by\"\n                    End\n                End\n            Do 2\n              If  curr_token = \"WHILE\",\n                | curr_token = \"UNTIL\",\n                Then\n                  Do\n                  If curr_token = \"WHILE\"\n                    Then\n                      Call Put_Token \"while \"\n                    Else\n                      Call Put_Token \"until \"\n                  Call Get_Token\n                  Call Parse_Expression \"\",\"Do_while\"\n                  End\n              End\n            Call Put_Line\n            indent = indent + 2\n            Call Get_Stmt\n            Do while verb \u00ac= \"END\",\n              & input_line_number <= numlines\n              Call Parse_Stmt\n              End\n            Call Put_Indent\n            Call Put_Token \"End \"\n            Call Get_Token\n            Call Parse_Expression\n            Call Put_Line\n            Call Get_Stmt\n            indent = indent - 2\n            End\n        End\n\n    When verb = \"END\"\n      Then\n        Do\n        if test_mode >= 2\n          then\n            say 'Verb=END'\n        Call Put_Indent\n        Call Put_Token \"Exit \"\n        Call Get_Token\n        Call Parse_Expression\n        Call Put_Line\n        Call Get_Stmt\n        End\n\n    When verb = \"ERROR\"\n      Then\n        Do\n        Call Put_Msg \"Warning:\" verb \"at input line\",\n             input_line_number \"not translateable by\" cmd_name\".\"\n        Call Put_Token \"/*!\"\n        Call Put_Indent\n        Call Put_Token verb||\" \"\n        Call Get_Token\n        Call Parse_Expression\n        Call Put_Token \"*/\"\n        Call Put_Line\n        Call Get_Stmt\n        End\n\n    When verb = \"EXIT\"\n      Then\n        Do\n        Call Put_Indent\n        Call Put_Token \"Exit \"\n        Call Get_NonBlank_Token\n        If curr_token = \"CODE\"\n          Then\n            Do\n            Call Get_Token\n            Call Parse_Expression\n            End\n        Call Put_Line\n        Call Get_Stmt\n        End\n\n    When verb = \"GETFILE\"\n      Then\n        Do\n        Call Get_Token\n        Call Get_Token\n        Call Put_Indent\n        Call Put_Token 'Address TSO \"EXECIO * DISKR '\n        If curr_token_type = \"<variable>\"\n          Then\n            Call Put_Token '\"'substr(curr_token,2)'\"'\n          Else\n            Call Put_Token curr_token\n        Call Put_Token ' (CASE M\"'\n        Call Put_Line\n        Call Put_Indent\n        If curr_token_type = \"<variable>\"\n          Then\n            Do\n            Call Put_Token 'Interpret \"Parse pull\" '\n            Call Put_Token substr(curr_token,2)\n            End\n          Else\n            Do\n            Call Put_Token \"Parse pull \"\n            Call Put_Token curr_token\n            End\n        Call Put_Line\n        Call Get_Token\n        Call Get_Stmt\n        End\n\n    When verb = \"GLOBAL\"\n      Then\n        Do\n        Call Put_Msg \"Warning:\" verb \"at input line\",\n             input_line_number \"not translateable by\" cmd_name\".\"\n        Call Put_Token \"/*!\"\n        Call Put_Indent\n        Call Put_Token verb||\" \"\n        Call Get_Token\n        Call Parse_Expression\n        Call Put_Token \"*/\"\n        Call Put_Line\n        Call Get_Stmt\n        End\n\n    When verb = \"NGLOBAL\"\n      Then\n        Do\n        Call Put_Msg \"Warning:\" verb \"at input line\",\n             input_line_number \"not translateable by\" cmd_name\".\"\n        Call Put_Token \"/*!\"\n        Call Put_Indent\n        Call Put_Token verb||\" \"\n        Call Get_Token\n        Call Parse_Expression\n        Call Put_Token \"*/\"\n        Call Put_Line\n        Call Get_Stmt\n        End\n\n    When verb = \"GOTO\"\n      Then\n        Do\n        Call Put_Msg \"Warning:\" verb \"at input line\",\n             input_line_number \"translated to SIGNAL.\"\n        Call Put_Token \"/*!*/\"\n        Call Put_Indent\n        Call Put_Token \"SIGNAL \"\n        Call Get_Token\n        Do while curr_token_type \u00ac= \"<eos>\"\n          If curr_token_type = \"<keyword>\",\n            & find(label_list,curr_token) \u00ac= 0,\n            Then\n              Call Put_Msg \"Warning: label\" curr_token,\n                           \"is already defined.  SIGNAL will fail.\"\n          Call Put_Token curr_token\n          Call Get_Token\n          End\n        Call Put_Line\n        Call Get_Stmt\n        End\n\n    When verb = \"IF\"\n      Then\n        Do\n        Call Put_Indent\n        Call Put_Token \"If \"\n        Call Get_Token\n        Call Parse_Expression \"\",\"If\"\n        Call Put_Line\n        indent = indent + 2\n        Call Put_Stmt \"Then \"\n        indent = indent + 2\n        Call Get_NonBlank_Token\n        verb = translate(curr_token)\n        Call Parse_Stmt\n        indent = indent - 2\n        If verb = \"ELSE\"\n          Then\n            Do\n            Call Put_Stmt \"Else \"\n            indent = indent + 2\n            Call Get_NonBlank_Token\n            verb = translate(curr_token)\n            Call Parse_Stmt\n            indent = indent - 2\n            End\n        indent = indent - 2\n        End\n\n    When verb = \"ISPEXEC\"\n      Then\n        Do\n        Call Put_Indent\n        Call Put_Token \"Address ISPEXEC \"\n        Call Get_Token\n        Call Parse_Expression \"q\"\n        Call Put_Line\n        Call Get_Stmt\n        End\n\n    When verb = \"ISREDIT\"\n      Then\n        Do\n        pdf_edit_macro_found = 1\n        Call Put_Indent\n        Call Put_Token \"ISREDIT \"\n        Call Get_Token\n        Call Parse_Expression \"q\"\n        Call Put_Line\n        Call Get_Stmt\n        End\n\n    When verb = \"LISTDSI\"\n      Then\n        Do\n        Call Put_Indent\n        Call Put_Token \"Call ListDSI \"\n        Call Get_Token\n        Call Parse_Expression \"q\"\n        Call Put_Line\n        Call Get_Stmt\n        End\n\n    When verb = \"OPENFILE\"\n      Then\n        Do\n        Call Put_Indent\n        Call Put_Token \"Nop\"\n        Call Put_Line\n        Call Get_Stmt\n        End\n\n    When verb = \"PUTFILE\"\n      Then\n        Do\n        Call Get_Token\n        Call Get_Token\n        Call Put_Indent\n        If curr_token_type = \"<variable>\"\n          Then\n            Do\n            Call Put_Token 'Interpret \"queue\" '\n            Call Put_Token substr(curr_token,2)\n            End\n          Else\n            Do\n            Call Put_Token \"queue \"\n            Call Put_Token curr_token\n            End\n        Call Put_Line\n        Call Put_Indent\n        Call Put_Token 'Address TSO \"EXECIO * DISKW '\n        If curr_token_type = \"<variable>\"\n          Then\n            Call Put_Token '\"'substr(curr_token,2)'\"'\n          Else\n            Call Put_Token curr_token\n        Call Put_Token ' (CASE M\"'\n        Call Put_Line\n        Call Get_Token\n        Call Get_Stmt\n        End\n\n    When verb = \"READ\"\n      Then\n        Do\n        parse_string = \"\"\n        Do while next_token_type \u00ac= \"<eos>\"\n          Call Get_NonBlank_Token\n          If curr_token = \",\"\n            Then\n              parse_string = parse_string \".\"\n            Else\n              parse_string = parse_string curr_token\n          End\n        If parse_string \u00ac= \"\"\n          Then\n            Do\n            Call Put_Stmt \"Parse upper pull sysdval_temp\"\n            Call Put_Stmt \"Parse var sysdval_temp\"parse_string \".\"\n            End\n          Else\n            Call Put_Stmt \"Parse upper pull sysdval\"\n        must_define.sysdval = 1\n        Call Get_Stmt\n        End\n\n    When verb = \"READDVAL\"\n      Then\n        Do\n        parse_string = \"\"\n        Do while next_token_type \u00ac= \"<eos>\"\n          Call Get_NonBlank_Token\n          If curr_token = \",\"\n            Then\n              parse_string = parse_string \".\"\n            Else\n              parse_string = parse_string curr_token\n          End\n        If parse_string \u00ac= \"\"\n          Then\n            Do\n            Call Put_Stmt \"Parse var sysdval\"parse_string \".\"\n            End\n        must_define.sysdval = 1\n        Call Get_Stmt\n        End\n\n    When verb = \"RETURN\"\n      Then\n        Do\n        Call Put_Indent\n        Call Put_Token \"Return \"\n        Call Get_NonBlank_Token\n        If curr_token = \"CODE\"\n          Then\n            Do\n            Call Get_Token\n            Call Parse_Expression\n            End\n        Call Put_Line\n        Call Get_Stmt\n        End\n\n    When verb = \"SELECT\"\n      Then\n        Do\n        Call Put_Indent\n        Call Put_Token \"Select \"\n        Call Get_Token\n        Do while curr_token_type = \"<comment>\",\n          | curr_token_type = \"<blanks>\"\n          Call Put_Token curr_token\n          Call Get_Token\n          End\n        Call Get_Token\n        Call Parse_Expression\n        Call Put_Line\n        indent = indent + 2\n        Call Get_Stmt\n        Do while verb \u00ac= \"END\",\n          & input_line_number <= numlines\n          Call Parse_Stmt\n          End\n        Call Put_Indent\n        Call Put_Token \"End \"\n        Call Get_Token\n        Call Parse_Expression\n        Call Put_Line\n        Call Get_Stmt\n        indent = indent - 2\n        End\n\n    When verb = \"SET\"\n      Then\n        Do\n        Call Get_NonBlank_Token\n        If left(curr_token,1) = \"&\"\n          Then\n            curr_token = substr(curr_token,2)\n        Call Put_Indent\n        curr_token = translate(curr_token,,\n                               \"abcdefghijklmnopqrstuvwxyz\",,\n                               \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n        Call Put_Token curr_token||\" \"\n        Call Get_NonBlank_Token\n        Call Put_Token curr_token||\" \"\n        If next_token_type = \"<eos>\"\n          Then\n            Do\n            Call Get_NonBlank_Token\n            Call Put_Token '\"\"'\n            End\n          Else\n            Do\n            Call Get_Token\n            Call Parse_Expression\n            End\n        Call Put_Line\n        Call Get_Stmt\n        End\n\n    When verb = \"SYSCALL\"\n      Then\n        Do\n        Call Get_NonBlank_Token\n        Call Put_Indent\n        curr_token = translate(curr_token,,\n                               \"abcdefghijklmnopqrstuvwxyz\",,\n                               \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n        Call Put_Token \"Call\" curr_token||\" \"\n        Call Get_Token\n        Call Parse_Expression\n        Call Put_Line\n        Call Get_Stmt\n        End\n\n    When verb = \"SYSREF\"\n      Then\n        Do\n        Call Put_Msg \"Warning:\" verb \"at input line\",\n             input_line_number \"not translateable by\" cmd_name\".\"\n        Call Put_Token \"/*!\"\n        Call Put_Indent\n        Call Put_Token verb||\" \"\n        Call Get_Token\n        Call Parse_Expression\n        Call Put_Token \"*/\"\n        Call Put_Line\n        Call Get_Stmt\n        End\n\n    When verb = \"TERMIN\"\n      Then\n        Do\n        parse_string = \"\"\n        Do while next_token_type \u00ac= \"<eos>\"\n          Call Get_NonBlank_Token\n          If curr_token = \",\"\n            Then\n              parse_string = parse_string \".\"\n            Else\n              parse_string = parse_string curr_token\n          End\n        Call Put_Stmt \"Parse upper pull sysdval\"\n        Call Put_Stmt \"Parse var sysdval sysdlm sysdval\"\n        Call Put_Stmt 'If sysdlm = \"\"'\n        Call Put_Stmt \"  Then\"\n        Call Put_Stmt '     sysdlm = \",\"'\n        Call Put_Stmt 'sysdlm = find(\"'parse_string'\",sysdlm)'\n        Call Get_Stmt\n        must_define.sysdval = 1\n        End\n\n    When verb = \"WHEN\"\n      Then\n        Do\n        Call Put_Indent\n        Call Put_Token \"When \"\n        Call Get_Token\n        Call Parse_Expression \"\",\"When\"\n        Call Put_Line\n        indent = indent + 2\n        Call Put_Stmt \"Then \"\n        indent = indent + 2\n        Call Get_NonBlank_Token\n        verb = translate(curr_token)\n        Call Parse_Stmt\n        indent = indent - 2\n        indent = indent - 2\n        End\n\n    When verb = \"WRITE\" | verb = \"WRITENR\"\n      Then\n        Do\n        Call Put_Indent\n        Call Put_Token \"Say \"\n        Call Get_Token\n        Call Parse_Expression\n        Call Put_Line\n        Call Get_Stmt\n        End\n\n    When curr_token_type = \"<comment>\"\n      Then\n        Do\n        Call Put_Stmt curr_token\n        Call Get_NonBlank_Token\n        verb = translate(curr_token)\n        Call Parse_Stmt\n        End\n\n    When curr_token_type = \"<eos>\"\n      Then\n        Do\n        Call Get_Stmt\n        End\n\n    When verb = \"\"\n      Then\n        Do\n        Call Get_Stmt\n        End\n\n    Otherwise\n        Call Put_Indent\n        Call Put_Token \"Address TSO \"\n        Call Parse_Expression\n        Call Put_Line\n        Call Get_Stmt\n    End\n  Return 0\n/*1*/\n/**********************************************************************/\n/*** Parse_Expression:                                              ***/\n/***   Subroutine to parse a single CLIST expression, and translate ***/\n/***   it to REXX.                                                  ***/\n/***                                                                ***/\n/***   Parameters:                                                  ***/\n/***     1. \"q\" = the expression is a character expression, and     ***/\n/***              its REXX equivalent should be in quotes.          ***/\n/***        \"nq\" = the expression is not a character expression.    ***/\n/***              This is the default.                              ***/\n/***                                                                ***/\n/***     2. \"\"  = the expression is the right side of an assignment ***/\n/***              statement.                                        ***/\n/***        \"If\" = the epression is part of an If statement and     ***/\n/***               may be terminated by a THEN clause.              ***/\n/***        \"Do_i\" = the expression is the starting point of a      ***/\n/***               repetetive DO (DO I = <expr> TO 5) and may       ***/\n/***               be terminated by a TO clause.                    ***/\n/***        \"Do_to\" = the expression is the ending point of a       ***/\n/***               repetetive DO (DO I = 1 TO <expr>) and may       ***/\n/***               be terminated by a BY, WHILE, or UNTIL clause.   ***/\n/***        \"Do_by\" = the expression is the increment of a          ***/\n/***               repetetive DO (DO I = 1 TO 9 BY <expr>) and may  ***/\n/***               be terminated by a WHILE or UNTIL clause.        ***/\n/***        \"Do_while\" = the expression is the terminator (WHILE    ***/\n/***               or UNTIL clause) of a repetetive DO.             ***/\n/***        \"When\" = the expression is part of a When statement.    ***/\n/***        \"parm\" = the expression is a function paramater and     ***/\n/***               may be terminated by a comma or right            ***/\n/***               parenthesis.  If this parameter is specified,    ***/\n/***               a third parameter, the name of the function,     ***/\n/***               is also specified.                               ***/\n/***                                                                ***/\n/**********************************************************************/\nParse_Expression: Procedure expose curr_token,\n                             curr_token_type,\n                             next_token,\n                             next_token_type,\n                             token_offset,\n                             first_token,\n                             curr_stmt,\n                             curr_char,\n                             next_char,\n                             test_mode,\n                             expr_depth,\n                             numlines,\n                             input_line_number,\n                             cmd_name,\n                             output_recd,\n                             output_line_type.,\n                             output_line.,\n                             output_line_number,\n                             quote_mode,\n                             must_define.,\n                             new_exp,\n                             verb,\n                             lrecl,\n                             label_list,\n                             pdf_edit_macro_found,\n                             control_stmt_used,\n                             control_list_stmt_used,\n                             first_proc_stmt_found,\n                             indent,\n                             isredit\n  expr_depth = expr_depth + 1\n  If test_mode >= 2\n    Then\n      Do\n      Say\n      Say \"Parse_Exp\" copies(\"--\",expr_depth) arg(1)\",\" arg(2)\",\",\n           arg(3)\",\" curr_token_type\", \"curr_token\n      End\n  quote_mode = \"nq\"\n  If arg(1) = \"q\"\n    Then\n      numeric_expression = 0\n    Else\n      numeric_expression = 1\n  If_mode = 0\n  Do_i_mode = 0\n  Do_to_mode = 0\n  Do_by_mode = 0\n  Do_while_mode = 0\n  When_mode = 0\n  parm_mode = 0\n  assignment_mode = 0\n  Select\n    When arg(2) = \"If\"\n      Then\n        If_mode = 1\n    When arg(2) = \"Do_i\"\n      Then\n        Do_i_mode = 1\n    When arg(2) = \"Do_to\"\n      Then\n        Do_to_mode = 1\n    When arg(2) = \"Do_by\"\n      Then\n        Do_by_mode = 1\n    When arg(2) = \"Do_while\"\n      Then\n        Do_while_mode = 1\n    When arg(2) = \"When\"\n      Then\n        When_mode = 1\n    When arg(2) = \"parm\"\n      Then\n        parm_mode = 1\n    Otherwise\n        assignment_mode = 1\n    End\n  paren_depth = 0\n  If \u00acparm_mode\n    Then\n      new_exp = \"\"\n  token_num = 0\n  Do while \u00ac((curr_token_type = \"<eos>\"),\n    | (next_token_type = \"<eos>\" & token_num \u00ac= 0))\n    If token_num \u00ac= 0\n      Then\n        Call Get_Token\n    token_num = token_num + 1\n    If \u00acparm_mode\n      Then\n        Do while token_num = 1 & curr_token_type = \"<blanks>\"\n          If test_mode >= 2\n            Then\n              Say \"Skip_Term\" copies(\"--\",expr_depth),\n                  format(token_num,6),\n                  left(curr_token_type,16) curr_token\n          Call Get_Token\n          End\n    If test_mode >= 2\n      Then\n        Say \"Get_Term \" copies(\"--\",expr_depth) format(token_num,6),\n            left(curr_token_type,16) curr_token\n    Select\n      When curr_token_type = \"<comment>\"\n        Then\n          Do\n          Call End_Quote_Mode\n          new_exp = new_exp||curr_token\n          End\n      When curr_token_type = \"<integer>\",\n        |  curr_token_type = \"<number>\",\n        Then\n          Do\n          Call Check_Concat_Needed\n          new_exp = new_exp||curr_token\n          End\n      When curr_token_type = \"<variable>\"\n        Then\n          Do\n          Call Check_Concat_Needed\n          curr_token = substr(curr_token,2)\n          Call End_Quote_Mode\n          Select\n            When curr_token = \"sysdate\"\n              Then\n                curr_token = 'date(\"u\")'\n            When curr_token = \"syssdate\"\n              Then\n                curr_token = 'date(\"o\")'\n            When curr_token = \"sysjdate\"\n              Then\n                curr_token = 'left(date(\"o\"),2)\".\"date(\"d\")'\n            When curr_token = \"systime\"\n              Then\n                curr_token = \"time()\"\n            When curr_token = \"sysstime\"\n              Then\n                curr_token = \"left(time(),5)\"\n            When curr_token = \"syslterm\"\n              Then\n                curr_token = \"SysVar('SysLTerm')\"\n            When curr_token = \"syswterm\"\n              Then\n                curr_token = \"SysVar('SysWTerm')\"\n            When curr_token = \"sysuid\"\n              Then\n                curr_token = \"userid()\"\n            When curr_token = \"syspref\"\n              Then\n                curr_token = \"SysVar('SysPref')\"\n            When curr_token = \"sysproc\"\n              Then\n                curr_token = \"SysVar('SysProc')\"\n            When curr_token = \"syscpu\"\n              Then\n                curr_token = \"SysVar('SysCPU')\"\n            When curr_token = \"syssrv\"\n              Then\n                curr_token = \"SysVar('SysSrv')\"\n            When curr_token = \"sysispf\"\n              Then\n                curr_token = \"SysVar('SysISPF')\"\n            When curr_token = \"sysracf\"\n              Then\n                curr_token = \"SysVar('SysRACF')\"\n            When curr_token = \"syslracf\"\n              Then\n                curr_token = \"SysVar('SysLRACF')\"\n            When curr_token = \"syshsm\"\n              Then\n                curr_token = \"SysVar('SysHSM')\"\n            When curr_token = \"systsoe\"\n              Then\n                curr_token = \"SysVar('SysTSOE')\"\n            When curr_token = \"sysenv\"\n              Then\n                curr_token = \"SysVar('SysEnv')\"\n            When curr_token = \"sysscan\"\n              Then\n                curr_token = \"1\"\n            When curr_token = \"sysicmd\"\n              Then\n                curr_token = \"SysVar('SysICmd')\"\n            When curr_token = \"syspcmd\"\n              Then\n                curr_token = \"SysVar('SysPCmd')\"\n            When curr_token = \"sysscmd\"\n              Then\n                curr_token = \"SysVar('SysSCmd')\"\n            When curr_token = \"sysnest\"\n              Then\n                curr_token = \"SysVar('SysNest')\"\n            When curr_token = \"sysprompt\"\n              Then\n                Do\n                curr_token = curr_token\n                must_define.sysprompt = 1\n                End\n            When curr_token = \"syssymlist\"\n              Then\n                Do\n                curr_token = curr_token\n                must_define.syssymlist = 1\n                End\n            When curr_token = \"sysconlist\"\n              Then\n                Do\n                curr_token = curr_token\n                must_define.sysconlist = 1\n                End\n            When curr_token = \"syslist\"\n              Then\n                Do\n                curr_token = curr_token\n                must_define.syslist = 1\n                End\n            When curr_token = \"sysasis\"\n              Then\n                Do\n                curr_token = curr_token\n                must_define.sysasis = 1\n                End\n            When curr_token = \"sysmsg\"\n              Then\n                Do\n                curr_token = curr_token\n                must_define.sysmsg = 1\n                End\n            When curr_token = \"sysflush\"\n              Then\n                Do\n                curr_token = curr_token\n                must_define.sysflush = 1\n                End\n            When curr_token = \"sysdlm\"\n              Then\n                curr_token = curr_token\n            When curr_token = \"sysdval\"\n              Then\n                Do\n                curr_token = curr_token\n                must_define.sysdval = 1\n                End\n            When curr_token = \"sysouttrap\"\n              Then\n                Do\n                curr_token = \"sysouttrap()\"\n                must_define.sysouttrap = 1\n                End\n            When left(curr_token,10) = \"sysoutline\"\n              Then\n                Do\n                curr_token = \"sysoutline()\"\n                must_define.sysoutline = 1\n                End\n            When curr_token = \"lastcc\"\n              Then\n                curr_token = \"rc\"\n            When curr_token = \"maxcc\"\n              Then\n                Do\n                Call Put_Msg \"Warning: &\"curr_token \"at input line\",\n                     input_line_number \"not translateable by\",\n                     cmd_name\".\"\n                curr_token = \"/*!*/\"curr_token\n                End\n            When curr_token = \"sysabncd\"\n              Then\n                curr_token = curr_token\n            When curr_token = \"sysabnrc\"\n              Then\n                curr_token = curr_token\n            When curr_token = \"syscmdrc\"\n              Then\n                curr_token = curr_token\n            /* begin parseing functions */\n            When curr_token = \"datatype\"\n              Then\n                Call Parse_Function\n            When curr_token = \"eval\"\n              Then\n                Do\n                Call Parse_Function\n                must_define.eval = 1\n                End\n            When curr_token = \"length\"\n              Then\n                Call Parse_Function\n            When curr_token = \"nrstr\"\n              Then\n                Do\n                Call Put_Msg \"Warning: &\"curr_token \"at input line\",\n                     input_line_number \"not translateable by\",\n                     cmd_name\".\"\n                Call Parse_NOP_Function\n                End\n            When curr_token = \"str\"\n              Then\n                Call Parse_NOP_Function\n            When curr_token = \"substr\"\n              Then\n                Do\n                curr_token = \"substrc\"\n                Call Parse_Function\n                must_define.substrc = 1\n                End\n            When curr_token = \"syscaps\"\n              Then\n                Do\n                curr_token = \"translate\"\n                Call Parse_Function\n                End\n            When curr_token = \"syslc\"\n              Then\n                Do\n                Call Parse_Function\n                must_define.syslc = 1\n                End\n            When curr_token = \"sysdsn\"\n              Then\n                Call Parse_Function\n            When curr_token = \"sysindex\"\n              Then\n                Do\n                curr_token = \"pos\"\n                Call Parse_Function\n                End\n            When curr_token = \"sysnsub\"\n              Then\n                Do\n                Call Put_Msg \"Warning: &\"curr_token \"at input line\",\n                     input_line_number \"not translateable by\",\n                     cmd_name\".\"\n                Call Parse_Function\n                must_define.sysnsub = 1\n                End\n            When curr_token = \"sysonebyte\"\n              Then\n                Do\n                curr_token = \"dbtosbcs\"\n                Call Parse_Function\n                End\n            When curr_token = \"systwobyte\"\n              Then\n                Do\n                curr_token = \"dbtodbcs\"\n                Call Parse_Function\n                End\n            When curr_token = \"sysclength\"\n              Then\n                Do\n                curr_token = \"length\"\n                Call Parse_Function\n                End\n            When curr_token = \"syscsubstr\"\n              Then\n                Do\n                curr_token = \"substrc\"\n                Call Parse_Function\n                must_define.substrc = 1\n                End\n            Otherwise\n                curr_token = curr_token\n            End\n          new_exp = new_exp||curr_token\n          End\n      When curr_token_type = \"<keyword>\"\n        Then\n          Do\n          Select\n            When (If_mode | Do_while_mode),\n              & (curr_token = \"OR\",\n               | curr_token = \"AND\",\n               | curr_token = \"EQ\",\n               | curr_token = \"NE\",\n               | curr_token = \"LT\",\n               | curr_token = \"GT\",\n               | curr_token = \"LE\",\n               | curr_token = \"GE\",\n               | curr_token = \"NG\",\n               | curr_token = \"NL\"),\n              Then\n                Do\n                Call End_Quote_Mode\n                Select\n                  When curr_token = \"OR\",\n                    Then\n                      curr_token = \"|\"\n                  When curr_token = \"AND\",\n                    Then\n                      curr_token = \"&\"\n                  When curr_token = \"EQ\",\n                    Then\n                      curr_token = \"=\"\n                  When curr_token = \"NE\",\n                    Then\n                      curr_token = \"\u00ac=\"\n                  When curr_token = \"LT\",\n                    Then\n                      curr_token = \"<\"\n                  When curr_token = \"GT\",\n                    Then\n                      curr_token = \">\"\n                  When curr_token = \"LE\",\n                    Then\n                      curr_token = \"<=\"\n                  When curr_token = \"GE\",\n                    Then\n                      curr_token = \">=\"\n                  When curr_token = \"NG\",\n                    Then\n                      curr_token = \"<=\"\n                  When curr_token = \"NL\",\n                    Then\n                      curr_token = \">=\"\n                  Otherwise\n                      Nop\n                  End\n                End\n            When If_mode & curr_token = \"THEN\"\n              Then\n                Leave\n            When Do_i_mode & curr_token = \"TO\"\n              Then\n                Leave\n            When Do_to_mode & find(\"BY WHILE UNTIL\",curr_token) \u00ac= 0\n              Then\n                Leave\n            When Do_by_mode & find(\"WHILE UNTIL\",curr_token) \u00ac= 0\n              Then\n                Leave\n            When Do_while_mode & find(\"WHILE UNTIL\",curr_token) \u00ac= 0\n              Then\n                Leave\n            Otherwise\n                Call Start_Quote_Mode\n                numeric_expression = 0\n            End\n          new_exp = new_exp||curr_token\n          End\n      When curr_token_type = \"<blanks>\"\n        Then\n          Do\n          If parm_mode\n            Then\n              Do\n              Call Start_Quote_Mode\n              numeric_expression = 0\n              End\n          new_exp = new_exp||curr_token\n          End\n      When curr_token = \":\",\n        & parm_mode,\n        & paren_depth = 0,\n        & arg(3) = \"substrc\",\n        Then\n          Do\n          Call end_quote_mode\n          curr_token = \",\"\n          curr_token_type = \"<special_char>\"\n          Leave\n          End\n      When curr_token = \",\",\n        & parm_mode,\n        & paren_depth = 0,\n        Then\n          Do\n          Call end_quote_mode\n          Leave\n          End\n      When curr_token = \")\",\n        & parm_mode,\n    /*  & paren_depth <= 0, */\n        Then\n          Do\n          Call end_quote_mode\n          Leave\n          End\n      Otherwise\n        Select\n          When curr_token = \"(\"\n            Then\n              Do\n              If parm_mode | When_mode\n                Then\n                  paren_depth = paren_depth+1\n              If \u00acnumeric_expression\n                Then\n                  Call Start_Quote_Mode\n              End\n          When curr_token = \")\"\n            Then\n              Do\n              If parm_mode\n                Then\n                  paren_depth = paren_depth-1\n              If \u00acnumeric_expression\n                Then\n                  Call Start_Quote_Mode\n              If When_mode\n                Then\n                  Do\n                  new_exp = new_exp||curr_token\n                  paren_depth = paren_depth-1\n                  If paren_depth <= 0\n                    Then\n                      Leave\n                  End\n              End\n          When curr_token_type = \"<operator>\"\n            Then\n              Do\n              Select\n                When curr_token = \"/\" & numeric_expression\n                  Then\n                    curr_token = \"%\"\n                When Do_while_mode,\n                  |If_mode,\n                  |(assignment_mode,\n                    & (find(\"= < > <= >= \u00ac=\",curr_token) = 0)),\n                  & numeric_expression\n                  Then\n                    Call End_Quote_Mode\n                When \u00acnumeric_expression\n                  Then\n                    Call Start_Quote_mode\n                Otherwise\n                    Nop\n                End\n              End\n          When curr_token_type = \"<special_char>\"\n            Then\n              Do\n              Call Start_Quote_Mode\n              numeric_expression = 0\n              If curr_token = '\"',\n                Then\n                  curr_token = curr_token||curr_token\n              End\n          Otherwise\n              Do\n              Call Put_Msg \"Error:   \"curr_token_type,\n                           \"at input line\" input_line_number,\n                           \"not expected.\"\n              Call Start_Quote_Mode\n              numeric_expression = 0\n              End\n          End\n        new_exp = new_exp||curr_token\n      End\n    End\n  Call End_Quote_Mode\n  If \u00acparm_mode\n    Then\n      Call Put_Token new_exp\n  If test_mode >= 2\n    Then\n      Do\n      Say \"End_Exp  \" copies(\"--\",expr_depth) arg(1)\",\" arg(2)\",\" arg(3)\n      Say\n      End\n  expr_depth = expr_depth - 1\n  Return 0\n\n/*1*/\n/**********************************************************************/\n/*** Parse_Function:                                                ***/\n/***   Subroutine to parse a single CLIST function, and translate   ***/\n/***   it to REXX.                                                  ***/\n/***                                                                ***/\n/***   Parameters:                                                  ***/\n/***     None.                                                      ***/\n/***                                                                ***/\n/**********************************************************************/\nParse_Function: Procedure expose curr_token,\n                             curr_token_type,\n                             next_token,\n                             next_token_type,\n                             token_offset,\n                             first_token,\n                             curr_stmt,\n                             curr_char,\n                             next_char,\n                             test_mode,\n                             expr_depth,\n                             numlines,\n                             input_line_number,\n                             cmd_name,\n                             output_recd,\n                             output_line_type.,\n                             output_line.,\n                             output_line_number,\n                             quote_mode,\n                             must_define.,\n                             new_exp,\n                             verb,\n                             lrecl,\n                             label_list,\n                             pdf_edit_macro_found,\n                             control_stmt_used,\n                             control_list_stmt_used,\n                             first_proc_stmt_found,\n                             indent,\n                             isredit\n  function_name = curr_token\n  new_exp = new_exp||curr_token\n  Call Get_Token\n  new_exp = new_exp||curr_token\n  Do forever\n    Call Get_Token\n    Call Parse_Expression \"\",\"parm\",function_name\n    new_exp = new_exp||curr_token\n    If curr_token = \")\"\n      Then\n        Do\n        curr_token = \"\"\n        curr_token_type = \"<blanks>\"\n        Leave\n        End\n    End\n  Return 0\n\n/*1*/\n/**********************************************************************/\n/*** Parse_NOP_Function:                                            ***/\n/***   Subroutine to parse a CLIST functions that don't Do anything ***/\n/***   in the REXX world (like &STR), and ignore it.                ***/\n/***                                                                ***/\n/***   Parameters:                                                  ***/\n/***     None.                                                      ***/\n/***                                                                ***/\n/**********************************************************************/\nParse_NOP_Function: Procedure expose curr_token,\n                             curr_token_type,\n                             next_token,\n                             next_token_type,\n                             token_offset,\n                             first_token,\n                             curr_stmt,\n                             curr_char,\n                             next_char,\n                             test_mode,\n                             expr_depth,\n                             numlines,\n                             input_line_number,\n                             cmd_name,\n                             output_recd,\n                             output_line_type.,\n                             output_line.,\n                             output_line_number,\n                             quote_mode,\n                             must_define.,\n                             new_exp,\n                             verb,\n                             lrecl,\n                             label_list,\n                             pdf_edit_macro_found,\n                             control_stmt_used,\n                             control_list_stmt_used,\n                             first_proc_stmt_found,\n                             indent,\n                             isredit\n  function_name = curr_token\n  Call Get_Token\n  If curr_char \u00ac= \")\"\n    Then\n      Do\n      Call Get_Token\n      Call Parse_Expression \"q\",\"parm\",function_name\n      End\n    Else\n      Do\n      Call Get_Token\n      Call Start_Quote_Mode\n      End\n  curr_token = \"\"\n  curr_token_type = \"<blanks>\"\n  Return 0\n\n\n/*1*/\n/**********************************************************************/\n/*** Get_Char:                                                      ***/\n/***   Subroutine to get one character from the input stream.       ***/\n/***                                                                ***/\n/***   Parameters:                                                  ***/\n/***     None.                                                      ***/\n/***                                                                ***/\n/**********************************************************************/\nGet_Char:\n  token_offset = token_offset + 1\n  If token_offset > length(curr_stmt)\n    Then\n      curr_char = \";\"\n    Else\n      curr_char = substr(curr_stmt,token_offset,1)\n  Return 0\n\n\n/*1*/\n/**********************************************************************/\n/*** Get_NonBlank_Token:                                            ***/\n/***   Subroutine to get one non-blank token from the input stream. ***/\n/***                                                                ***/\n/***   Parameters:                                                  ***/\n/***     None.                                                      ***/\n/***                                                                ***/\n/**********************************************************************/\nGet_NonBlank_Token:\n  Call Get_Token\n  Do while curr_token_type = \"<blanks>\"\n    Call Get_Token\n    End\n  Return 0\n\n\n/*1*/\n/**********************************************************************/\n/*** Get_Token:                                                     ***/\n/***   Subroutine to get one token from the input stream.           ***/\n/***   The token may be blank.                                      ***/\n/***                                                                ***/\n/***   Parameters:                                                  ***/\n/***     None.                                                      ***/\n/***                                                                ***/\n/**********************************************************************/\nGet_Token:\n  If token_offset = 0\n    Then\n      Do\n      Call Get_Char\n      End\n  If token_offset > length(curr_stmt)\n    Then\n      Do\n      curr_token_type = \"<eos>\"\n      next_token_type = \"<eos>\"\n      curr_token = \";\"\n      next_token = \";\"\n      Return 0\n      End\n  curr_token = \"\"\n  curr_token_type = \"<?>\"\n  Select\n    When (\"0\" <= curr_char & curr_char <= \"9\"),\n      Then\n        Do\n        curr_token_type = \"<integer>\"\n        Do while (\"0\" <= curr_char & curr_char <= \"9\")\n          curr_token = curr_token||curr_char\n          Call Get_Char\n          End\n        If curr_char = \".\"\n          Then\n            Do\n            curr_token_type = \"<number>\"\n            curr_token = curr_token||curr_char\n            Call Get_Char\n            Do while (\"0\" <= curr_char & curr_char <= \"9\")\n              curr_token = curr_token||curr_char\n              Call Get_Char\n              End\n            End\n        End\n    When (\"A\" <= curr_char & curr_char <= \"I\"),\n      |  (\"J\" <= curr_char & curr_char <= \"R\"),\n      |  (\"S\" <= curr_char & curr_char <= \"Z\"),\n      |  (\"a\" <= curr_char & curr_char <= \"i\"),\n      |  (\"j\" <= curr_char & curr_char <= \"r\"),\n      |  (\"s\" <= curr_char & curr_char <= \"z\"),\n      |  curr_char = \"%\",\n      |  curr_char = \"$\",\n      |  curr_char = \"#\",\n      Then\n        Do\n        curr_token_type = \"<keyword>\"\n        Do while (\"A\" <= curr_char & curr_char <= \"I\"),\n               | (\"J\" <= curr_char & curr_char <= \"R\"),\n               | (\"S\" <= curr_char & curr_char <= \"Z\"),\n               | (\"a\" <= curr_char & curr_char <= \"i\"),\n               | (\"j\" <= curr_char & curr_char <= \"r\"),\n               | (\"s\" <= curr_char & curr_char <= \"z\"),\n               | (\"0\" <= curr_char & curr_char <= \"9\"),\n               | curr_char = \"_\",\n               | curr_char = \"%\",\n               | curr_char = \"$\",\n               | curr_char = \"#\"\n          curr_token = curr_token||curr_char\n          Call Get_Char\n          End\n        If curr_char = \":\" & first_token\n          Then\n            Do\n            curr_token_type = \"<label>\"\n            curr_token = curr_token||curr_char\n            Call Get_Char\n            End\n        End\n    When curr_char = \"&\"\n      Then\n        Do\n        curr_token_type = \"<variable>\"\n        curr_token = curr_token||curr_char\n        Call Get_Char\n        If curr_char = \"&\"\n          Then\n            Do\n            curr_token_type = \"<operator>\"\n            Call Get_Char\n            End\n          Else\n            Do\n            Do while (\"A\" <= curr_char & curr_char <= \"I\"),\n                   | (\"J\" <= curr_char & curr_char <= \"R\"),\n                   | (\"S\" <= curr_char & curr_char <= \"Z\"),\n                   | (\"a\" <= curr_char & curr_char <= \"i\"),\n                   | (\"j\" <= curr_char & curr_char <= \"r\"),\n                   | (\"s\" <= curr_char & curr_char <= \"z\"),\n                   | (\"0\" <= curr_char & curr_char <= \"9\"),\n                   | curr_char = \"_\",\n                   | curr_char = \"%\",\n                   | curr_char = \"$\",\n                   | curr_char = \"#\"\n              curr_token = curr_token||curr_char\n              Call Get_Char\n              End\n            If curr_char = \".\"\n              Then\n                Call Get_Char\n            curr_token = translate(curr_token,,\n                                   \"abcdefghijklmnopqrstuvwxyz\",,\n                                   \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n            End\n        End\n    When curr_char = \" \"\n      Then\n        Do\n        curr_token_type = \"<blanks>\"\n        Do while (curr_char = \" \")\n          curr_token = curr_token||curr_char\n          Call Get_Char\n          End\n        End\n    When curr_char = \"'\"\n      Then\n        Do\n        curr_token_type = \"<special_char>\"\n        curr_token = curr_token||curr_char\n        Call Get_Char\n        End\n    When curr_char = \"/\"\n      Then\n        Do\n        curr_token_type = \"<operator>\"\n        curr_token = curr_token||curr_char\n        Call Get_Char\n        If curr_char = \"*\"\n          Then\n            Do\n            curr_token_type = \"<comment>\"\n            curr_token = curr_token||curr_char\n            Call Get_Char\n            Do forever\n              curr_token = curr_token||curr_char\n              If curr_char \u00ac= \"*\"\n                Then\n                  Call Get_Char\n                Else\n                  Do\n                  Call Get_Char\n                  If curr_char = \"/\"\n                    Then\n                      Do\n                      curr_token = curr_token||curr_char\n                      Call Get_Char\n                      Leave\n                      End\n                  End\n              If token_offset > length(curr_stmt)\n                Then\n                  Do\n                  curr_token = curr_token||\"*/\"\n                  Leave\n                  End\n              End\n            End\n        End\n    When pos(curr_char,\"\u00ac<>=&+-/*()\") \u00ac= 0\n      Then\n        Do\n        curr_token_type = \"<operator>\"\n        curr_token = curr_token||curr_char\n        save_char = curr_char\n        Call Get_Char\n        double_operators = \"\u00ac<>&/*\u00ac\u00ac\"\n        double_oprsmates = \"===&/*<>\"\n        If pos(save_char,double_operators) \u00ac= 0\n          Then\n            Do i = 1 to length(double_operators)\n              If  substr(double_operators,i,1) = save_char,\n                & substr(double_oprsmates,i,1) = curr_char,\n                Then\n                  Do\n                  curr_token = curr_token||curr_char\n                  Select\n                    When curr_token = \"\u00ac>\"\n                      Then\n                        curr_token = \"<=\"\n                    When curr_token = \"\u00ac<\"\n                      Then\n                        curr_token = \">=\"\n                    When curr_token = \"&&\"\n                      Then\n                        curr_token = \"&\"\n                    Otherwise\n                        nop\n                    End\n                  Call Get_Char\n                  Leave i\n                  End\n              End\n        If pos(save_char,\"()\") = 0\n          Then\n            If       \u00ac(datatype(curr_char,\"a\"),\n              | pos(curr_char,\"() &\") \u00ac= 0,\n              | token_offset > length(curr_stmt))\n              Then\n                curr_token_type = \"<special_char>\"\n        End\n    Otherwise\n        Do\n        curr_token_type = \"<special_char>\"\n        curr_token = curr_token||curr_char\n        save_char = curr_char\n        Call Get_Char\n        End\n    End\n  If token_offset > length(curr_stmt)\n    Then\n      Do\n      next_token_type = \"<eos>\"\n      next_token = \";\"\n      End\n    Else\n      Do\n      next_token_type = \"<?>\"\n      next_token = \"?????\"\n      End\n\n  If test_mode >= 2 & 0\n    Then\n      Say \"Get_Token      \" left(curr_token_type,16) curr_token\n  Return 0\n\n\n/*1*/\n/**********************************************************************/\n/*** Get_Stmt:                                                      ***/\n/***   Subroutine to get one statement from the input stream,       ***/\n/***   including handling continuation.                             ***/\n/***                                                                ***/\n/***   Parameters:                                                  ***/\n/***     None.                                                      ***/\n/***                                                                ***/\n/**********************************************************************/\nGet_Stmt:\n  curr_stmt = \"\"\n  k = 0\n  strip_next_line = 0\n  Do forever\n    input_line_number = input_line_number + 1\n    k = k + 1\n    If input_line_number > numlines\n      Then\n        Leave\n    ISREDIT \"(THISLINE) = LINE\" input_line_number\n    If test_mode >= 1\n      Then\n        Do\n        If test_mode >= 2\n          Then\n            Say copies(\"-\",78)\n        Say \"Get_Stmt \" format(input_line_number,6) strip(thisline,\"t\")\n        End\n    Call Put_Line \"NOTELINE\",thisline\n    If strip_next_line\n      Then\n        thisline = strip(thisline)\n      Else\n        thisline = strip(thisline,\"t\")\n    strip_next_line = 0\n    Select\n      When right(thisline,1) = \"+\"\n        Then\n          Do\n          curr_stmt = curr_stmt||substr(thisline,1,length(thisline)-1)\n          strip_next_line = 1\n          End\n      When right(thisline,1) = \"-\"\n        Then\n          curr_stmt = curr_stmt||substr(thisline,1,length(thisline)-1)\n      Otherwise\n          Do\n          curr_stmt = curr_stmt||thisline\n          Leave\n          End\n      End\n    End\n  first_token = 1\n  token_offset = 0\n  Call Get_NonBlank_Token\n  If curr_token_type = \"<label>\"\n    Then\n      Do\n      label_list = label_list substr(curr_token,1,length(curr_token)-1)\n      Call Put_Token curr_token\n      Call Put_Line\n      first_token = 0\n      Call Get_NonBlank_Token\n      End\n  first_token = 0\n  verb = translate(curr_token)\n  Return 0\n\n\n/*1*/\n/**********************************************************************/\n/*** Put_Indent:                                                    ***/\n/***   Subroutine to put out leading blanks on the current output   ***/\n/***   record, so that it indents nicely.                           ***/\n/***                                                                ***/\n/***   Parameters:                                                  ***/\n/***     None.                                                      ***/\n/***                                                                ***/\n/**********************************************************************/\nPut_Indent:\n  output_recd = output_recd||copies(\" \",,\n                                max(0,indent-length(output_recd)))\n  Return 0\n\n\n/*1*/\n/**********************************************************************/\n/*** Put_Token:                                                     ***/\n/***   Subroutine to put out a token or tokens to the current       ***/\n/***   output record.                                               ***/\n/***                                                                ***/\n/***   Parameters:                                                  ***/\n/***     1. The token(s) to add to the current output record.       ***/\n/***                                                                ***/\n/**********************************************************************/\nPut_Token:\n  output_recd = output_recd||arg(1)\n  Return 0\n\n\n/*1*/\n/**********************************************************************/\n/*** Put_Line:                                                      ***/\n/***   Subroutine to output a record to the output stream.          ***/\n/***                                                                ***/\n/***   Parameters:                                                  ***/\n/***     1. The type of output line.  Values are \"\", \"DATALINE\",    ***/\n/***        \"NOTELINE\", and \"MSGLINE\".  This parameter will be      ***/\n/***        used on an PDF edit LINE_BEFORE command.                ***/\n/***     2. The line itself.                                        ***/\n/***                                                                ***/\n/**********************************************************************/\nPut_Line:\n  If test_mode >= 2\n    Then\n      Say \"Put_Line \" format(output_line_number,6) arg(1),\n           strip(arg(2),\"t\")\n  If arg(1) \u00ac= \"\"\n    Then\n      Do\n      output_line_number = output_line_number + 1\n      output_line.output_line_number = arg(2)\n      output_line_type.output_line_number = arg(1)\n      End\n    Else\n      Do\n      If test_mode >= 2\n        Then\n          Say \"Put_Line \" format(output_line_number,6) \"**REXX**\",\n               strip(output_recd,\"t\")\n      If length(output_recd) <= lrecl\n        Then\n          Do\n          output_line_number = output_line_number + 1\n          output_line.output_line_number = output_recd\n          output_line_type.output_line_number = \"\"\n          output_recd = \"\"\n          End\n        Else\n          Do\n          const_map = \"\"\n          cc = 1\n          output_mode = \"NORMAL\"\n          Do while cc <= length(output_recd)\n            Select\n              When output_mode = \"NORMAL\"\n                Then\n                  Do\n                  Select\n                    When substr(output_recd,cc,1) = \"\"\"\"\n                      Then\n                        Do\n                        output_mode = \"QSTRING2\"\n                        const_map = const_map\"1\"\n                        cc = cc + 1\n                        End\n                    When substr(output_recd,cc,1) = \"'\"\n                      Then\n                        Do\n                        output_mode = \"QSTRING1\"\n                        const_map = const_map\"1\"\n                        cc = cc + 1\n                        End\n                    Otherwise\n                        Do\n                        const_map = const_map\" \"\n                        cc = cc + 1\n                        End\n                    End\n                  End\n              When output_mode = \"QSTRING1\"\n                Then\n                  Do\n                  Select\n                    When substr(output_recd,cc,1) = \"'\",\n                      &  substr(output_recd,cc+1,1) = \"'\"\n                      Then\n                        Do\n                        const_map = const_map\"SS\"\n                        cc = cc + 2\n                        End\n                    When substr(output_recd,cc,1) = \"'\",\n                      Then\n                        Do\n                        output_mode = \"NORMAL\"\n                        const_map = const_map\"2\"\n                        cc = cc + 1\n                        End\n                    Otherwise\n                        Do\n                        const_map = const_map\"S\"\n                        cc = cc + 1\n                        End\n                    End\n                End\n              When output_mode = \"QSTRING2\"\n                Then\n                  Do\n                  Select\n                    When substr(output_recd,cc,1) = '\"',\n                      &  substr(output_recd,cc+1,1) = '\"'\n                      Then\n                        Do\n                        const_map = const_map\"SS\"\n                        cc = cc + 2\n                        End\n                    When substr(output_recd,cc,1) = '\"',\n                      Then\n                        Do\n                        output_mode = \"NORMAL\"\n                        const_map = const_map\"2\"\n                        cc = cc + 1\n                        End\n                    Otherwise\n                        Do\n                        const_map = const_map\"S\"\n                        cc = cc + 1\n                        End\n                    End\n                  End\n              End\n            End\n          Do while length(output_recd) > 0\n            If length(output_recd) > lrecl\n              Then\n                Do\n                If substr(const_map,lrecl) = \" \"\n                  Then\n                    Do\n                    output_line_number = output_line_number + 1\n                    output_line.output_line_number,\n                          = substr(output_recd,1,71)\",\"\n                    output_line_type.output_line_number = \"\"\n                    output_recd = substr(output_recd,72)\n                    End\n                  Else\n                    Do\n                    output_line_number = output_line_number + 1\n                    output_line.output_line_number,\n                          = substr(output_recd,1,72)\n                    output_line_type.output_line_number = \"\"\n                    output_recd = substr(output_recd,73)\n                    End\n                End\n              Else\n                Do\n                output_line_number = output_line_number + 1\n                output_line.output_line_number = output_recd\n                output_line_type.output_line_number = \"\"\n                output_recd = \"\"\n                End\n            End\n          End\n      End\n  Return 0\n\n\n/*1*/\n/**********************************************************************/\n/*** Put_Stmt:                                                      ***/\n/***   Subroutine to put an entire statement to the output stream.  ***/\n/***                                                                ***/\n/***   Parameters:                                                  ***/\n/***     1. The statement to be output.                             ***/\n/***                                                                ***/\n/**********************************************************************/\nPut_Stmt:\n  Call Put_Indent\n  Call Put_Token arg(1)\n  Call Put_Line\n  Return 0\n\n\n/*1*/\n/**********************************************************************/\n/*** Put_Msg:                                                       ***/\n/***   Subroutine to put a message to the output stream.            ***/\n/***                                                                ***/\n/***   Parameters:                                                  ***/\n/***     1. The message to be output.                               ***/\n/***                                                                ***/\n/**********************************************************************/\nPut_Msg:\n  Say arg(1)\n  Call Put_Line \"MSGLINE\",arg(1)\n  Return 0\n\n\n/*1*/\n/**********************************************************************/\n/*** Check_Concat_Needed:                                           ***/\n/***   Subroutine to check to see If REXX needs a concat operator   ***/\n/***   where the CLIST did not.                                     ***/\n/***                                                                ***/\n/***   Parameters:                                                  ***/\n/***     None.                                                      ***/\n/***                                                                ***/\n/**********************************************************************/\nCheck_Concat_Needed:\n  If datatype(right(new_exp,1),\"a\")\n    Then\n      new_exp = new_exp||\"||\"\n  Return 0\n\n\n/*1*/\n/**********************************************************************/\n/*** Start_Quote_Mode:                                              ***/\n/***   Subroutine to start a REXX quoted string if we have not      ***/\n/***   already started one.                                         ***/\n/***                                                                ***/\n/***   Parameters:                                                  ***/\n/***     None.                                                      ***/\n/***                                                                ***/\n/**********************************************************************/\nStart_Quote_Mode:\n  If quote_mode \u00ac= \"q\"\n    Then\n      Do\n      new_exp = new_exp'\"'\n      quote_mode = \"q\"\n      End\n  Return\n\n\n/*1*/\n/**********************************************************************/\n/*** End_Quote_Mode:                                                ***/\n/***   Subroutine to terminate a REXX quoted string.                ***/\n/***                                                                ***/\n/***   Parameters:                                                  ***/\n/***     None.                                                      ***/\n/***                                                                ***/\n/**********************************************************************/\nEnd_Quote_Mode:\n  If quote_mode \u00ac= \"nq\"\n    Then\n      Do\n      blank_count = 0\n      Do while length(new_exp) > 0,\n        & right(new_exp,1) = \" \"\n        blank_count = blank_count + 1\n        new_exp = substr(new_exp,1,length(new_exp)-1)\n        End\n      If right(new_exp,1) = '\"',\n        & right(new_exp,2) \u00ac= '\"\"',\n        Then\n          new_exp = new_exp||copies(\" \",blank_count)'\"'\n        Else\n          new_exp = new_exp'\"'copies(\" \",blank_count)\n      quote_mode = \"nq\"\n      End\n  Return\n\n/*1*/\n/**********************************************************************/\n/*** Help:                                                          ***/\n/***   Subroutine to display help text.                             ***/\n/***                                                                ***/\n/***   Parameters:                                                  ***/\n/***     None.                                                      ***/\n/***                                                                ***/\n/**********************************************************************/\nHelp:\n  Say cmd_name \"ISREDIT\"\n  Say \"\"\n  Say \"An ISPF/PDF edit macro to assist with conversion of\"\n  Say \"CLISTs to REXX.  It does not do everything, but is designed\"\n  Say \"to do 90% of the work.  It won't handle, but I hope to\"\n  Say \"add support for in the future:\"\n  Say \"\"\n  Say \"  - abutal (&A&B is translated to ab)\"\n  Say \"\"\n  Say \"You will still have to do some manual touch-up, but I\"\n  Say \"think conversion is now feasable.  You should also\"\n  Say \"review your code to identify those areas where you\"\n  Say \"used several lines of code to implement something REXX\"\n  Say \"provides as a function.\"\n  Say \"\"\n  Say \"It won't handle, and I'm not sure how to do the following\"\n  Say \"I wouldn't mind suggestions on how to do these:\"\n  Say \"\"\n  Say \"  - CONTROL END/CAPS/FLUSH/NOFLUSH/MAIN\"\n  Say \"  - ATTN\"\n  Say \"  - ERROR\"\n  Say \"  - GLOBAL\"\n  Say \"  - IF &FOO = THEN +  (nothing on the right of the =)\"\n  Say \"  - Some of the builtin functions and control variables:\"\n  Say \"      &sysscan (always returns 1, setting has no effect)\"\n  Say \"      &maxcc\"\n  Say \"      &sysabncd\"\n  Say \"      &sysabnrc\"\n  Say \"      &syscmdrc\"\n  Say \"\"\n  Say \"It DOES handle CONTROL PROMPT/LIST/CONLIST/SYMLIST/MSG\"\n  Say \"and their inverses.  It will also handle CONTROL\"\n  Say \"ASIS/NOCAPS by ignoring it.  It will not hand CONTROL\"\n  Say \"CAPS.\"\n  Say \"\"\n  Say \"GOTO's are translated to SIGNALS, which won't work if\"\n  Say \"the label preceeds the SIGNAL.  You will probably\"\n  Say \"want to manually translate them to LEAVE/ITERATE/SELECT\"\n  Say \"or whatever it was you had in mind.\"\n  Say \"\"\n  Say \"REXX statements which are longer than the lrecl are\"\n  Say \"hacked into pieces rather ruthlessly and without warning.\"\n  Say \"\"\n  Say \"Untranslateable commands are commented out and prefixed\"\n  Say \"with an !\"\n  Say \"\"\n  Say \"Untranslateable functions and control variables are left\"\n  Say \"alone and prefixed with /*!\"\n  Say \"\"\n  Say \"\"\n  Say \"Syntax:\"\n  Say \"\"\n  Say \"  \"cmd_name\n  Say \"\"\n  Say \"\"\n  Say \"This macro will run under both TSO and CMS.\"\n  Say \"                                                                \"\n  Say \"Author:        Chuck Tribolet, TRIBLET at STLMVS1               \"\n  Return 0\n\n/*1*/\n/**********************************************************************/\n/*** Append_Stack:                                                  ***/\n/***   Subroutine to copy the REXX stack to the PDF editor's        ***/\n/***   working copy of the file.                                    ***/\n/***                                                                ***/\n/***   Parameters:                                                  ***/\n/***     None.                                                      ***/\n/***                                                                ***/\n/**********************************************************************/\nAppend_Stack: Procedure Expose ISREDIT already_queued,\n                             test_mode\n  Do while Queued() > already_queued\n    Parse Pull Line\n    If test_mode >= 1\n      Then\n        Say \"LineAfter\" strip(line,\"t\")\n    ISREDIT 'LINE_AFTER .ZLAST = \"'line'\"'\n    End\n  Return 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DOCFIL": {"ttr": 1795, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01-\\x00%\\x01\\x02(\\x1f\\x01\\x125\\x1f\\x19$\\x00\\x1e\\x00\\x06\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.45", "flags": 0, "createdate": "2002-10-08T00:00:00", "modifydate": "2012-12-16T19:24:25", "lines": 30, "newlines": 6, "modlines": 0, "user": "SBGOLOB"}, "text": "PROC 1 FNUM PREF(SBGOLOB) OUTPUT(X) NUMB(486) CBT(CBT) FLE(@FILE) -\n       DSNM(CBTDOC.PDS)\n/* ------------------------------------------------------------- */\n/* CLIST TO FIX COLUMNS 73-80 IN THE CBT DOCUMENTATION, FOR A    */\n/* SPECIFIC FILE NUMBER.  DATASET IN WHICH THE MEMBER IS FIXED,  */\n/* IS THE STAGING DATASET FOR THAT CBT TAPE FILE.                */\n/* ------------------------------------------------------------- */\n     SET &FILVER = &STR(CBT&NUMB)\n     SET &FILNAM = &STR(&FILVER..FILE&FNUM)\n     SET &DATAST = &STR('&PREF..&FILNAM')\n     SET &VER    = &SUBSTR(1:1,&NUMB)\n     SET &MODIF  = &SUBSTR(2:3,&NUMB)\n     WRITE ISPF STATS:  VERSION    IS &VER\n     WRITE ISPF STATS:  MODIF LVL  IS &MODIF\n     ALLOC F(INPUT)  SH REUSE DA('&DATAST(&FLE&FNUM)')\n     ALLOC F(OUTPUT) SH REUSE DA('&DATAST(&OUTPUT)')\n     WRITE FIXING COLUMNS 73-80 FOR CBTDOC IN MEMBER &FLE&FNUM\n     WRITE DATASET BEING FIXED:  &DATAST\n     WRITE OUTPUT MEMBER NAME :  &OUTPUT\n     CALL 'SBGOLOB.LOAD(DOCFILE)'\n     WRITE PDS86 BEING CALLED TO RENAME OUTPUT MEMBER\n     PDS86 '&DATAST' XISPM\n     ATTRIB &OUTPUT ADDSTATS ID(&CBT-&NUMB) VER(&VER) MOD(&MODIF)\n     RENAME &OUTPUT &FLE&FNUM SWAP\n     DELETE &OUTPUT\n     END\n     WRITE MEMBER &FLE&FNUM SUCCESSFULLY RENAMED\n     FREE FI(INPUT OUTPUT)\n     WRITE INPUT AND OUTPUT FILES FREED\n     WRITE DOCFIL EXECUTION COMPLETED WITH RETURN CODE &LASTCC\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DOCFILX": {"ttr": 1797, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x012\\x005\\x01\\x02(\\x1f\\x01\\x125\\x1f\\x19$\\x00E\\x00\\x06\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.50", "flags": 0, "createdate": "2002-10-08T00:00:00", "modifydate": "2012-12-16T19:24:35", "lines": 69, "newlines": 6, "modlines": 0, "user": "SBGOLOB"}, "text": "/* REXX */\n/* CLS2REXXed by SBGOLOB on 28 Aug 2003 at 08:34:35  */\n/* This REXX requires the CLS2REXX and TSOPROC REXXes on File 646.  */\n/* This REXX was converted from the DOCFIL CLIST, with adjustments. */\nSignal On NoValue\nParse source opsys . exec_name .\n\nParse upper arg argument_list\nCall TSOPROC argument_list,,\n  'PROC 1 FNUM PREF(SBGOLOB) OUTPU(X) NUMB(486) CBT(CBT) FLE(@FILE)\n         DSNM(CBTDOC.PDS)'\nInterpret Result\nIf RC \u00ac= 0\n  Then\n    Do\n    Say tsoproc_msg\n    Exit RC\n    End\n/* ------------------------------------------------------------- */\n/* CLIST TO FIX COLUMNS 73-80 IN THE CBT DOCUMENTATION, FOR A    */\n/* SPECIFIC FILE NUMBER.  DATASET IN WHICH THE MEMBER IS FIXED,  */\n/* IS THE STAGING DATASET FOR THAT CBT TAPE FILE.                */\n/* ------------------------------------------------------------- */\nfilver = \"CBT\"numb\nfilnam = filver\".FILE\"fnum\ndatast = pref\".\"filnam\nvers = substrc(1,1,numb)\nmodif = substrc(2,3,numb)\nSay \"ISPF STATS:  VERSION    IS\" vers\nSay \"ISPF STATS:  MODIF LVL  IS\" modif\nAddress TSO \"ALLOC F(INPUT)  SH REUSE DA('\"datast\"(\"fle||fnum\")')\"\nAddress TSO \"ALLOC F(OUTPUT) SH REUSE DA('\"datast\"(\"outpu\")')\"\nSay \"FIXING COLUMNS 73-80 FOR CBTDOC IN MEMBER\" fle||fnum\nSay \"DATASET BEING FIXED:\"  datast\nSay \"OUTPUT MEMBER NAME :\"  outpu\nAddress TSO \"CALL 'SBGOLOB.LOAD(DOCFILE)'\"\nSay \"PDS86 BEING CALLED TO RENAME OUTPUT MEMBER\"\n line01 = ' AT 'outpu' AD  ID(CBT-'numb') VER('vers') MOD('modif') '\n   QUEUE line01\n line02 = ' RENAME 'outpu' 'fle||fnum'  SWAP '\n   QUEUE line02\n line03 = ' DELETE 'outpu' '\n   QUEUE line03\n line04 = ' END '\n   QUEUE line04\nAddress TSO \"PDS86 '\"datast\"' XISPM\"\nSay \"Current Return Code \" rc\nSay \"MEMBER\" fle||fnum \"SUCCESSFULLY RENAMED\"\nAddress TSO \"FREE FI(INPUT OUTPUT)\"\nSay \"INPUT AND OUTPUT FILES FREED\"\nSay \"DOCFIL EXECUTION COMPLETED WITH RETURN CODE\" rc\nExit 0\n\nsubstrc: Procedure\n If arg(3) = ''\n   Then\n     Do\n     s = Arg(1)\n     l = 1\n     v = arg(2)\n     End\n   Else\n     Do\n     s = arg(1)\n     l = arg(2)-arg(1)+1\n     v = arg(3)\n     End\n  Return substr(v,s,l)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSOPROC": {"ttr": 1799, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x05\\x01\\x03#o\\x01\\x03$\\x0f\\t\\x01\\x01\\xc9\\x01\\xc9\\x00\\x00\\xd7\\xe4\\xc2\\xd3\\xc9\\xc3@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2003-08-24T00:00:00", "modifydate": "2003-08-28T09:01:05", "lines": 457, "newlines": 457, "modlines": 0, "user": "PUBLIC"}, "text": "/*REXX***********************************************************/\n/* TSOPROC - V1.1                                               */\n/*                                                              */\n/*                                                              */\n/* TSOPROC     Subroutine to Parse the TSO command operands     */\n/*             based on a TSO CLISTlike PROC statement          */\n/*                                                              */\n/*      This routine does not attempt to exactly emulate the    */\n/*      TSO CLIST parsing.  However, it provides an easy way for*/\n/*      the EXEC writer to use TSO syntax for the command entry.*/\n/*                                                              */\n/*      Called as external subroutine                           */\n/*                                                              */\n/*                                                              */\n/*      CALL TSOPROC String,Proc_stmt,key                       */\n/*       String     - Command input to be parsed.   (required)  */\n/*       Proc_stmt  - String containing a list of   (required)  */\n/*                    positional paremeter and keywords         */\n/*                    in the form of a CLIST PROC statement.    */\n/*                    Keywords must be uppercase.               */\n/*                                                              */\n/*       Key        - Specific key to be processed. (optional)  */\n/*                                                              */\n/*    If the key is not included then all of the positional     */\n/*    parameters and keywords from the \"PROC\" statement are     */\n/*    processed.                                                */\n/*                                                              */\n/*    Returns: RESULT                                           */\n/*      String containing REXX statements to set the            */\n/*      variables corresponding to the PROC parameters.         */\n/*      Normally processed with the REXX INTERPRET instruction. */\n/*      If user enters:                                         */\n/*        execname 'user1.a.list'                               */\n/*      Then                                                    */\n/*        CALL TSOPROC cmdinput,\"PROC 1 DSN SYSOUT(A)\"          */\n/*        INTERPRET result                                      */\n/*      Would set:                                              */\n/*        dsn = \"'USER1.A.LIST'\";                               */\n/*        sysout = \"A\"                                          */\n/*                                                              */\n/*    Variables set by the INTERPRET in addition to keywords    */\n/*      rc = Return code                                        */\n/*      tsoproc_msg =Error message when rc > 0                  */\n/*      tsoproc_left= Unprocessed command input                 */\n/*                                                              */\n/* Example:                                                     */\n/*                                                              */\n/*     CLIST - PROC 1 P1 KEY1(60) LIST                          */\n/*                                                              */\n/* Typical calling sequence                                     */\n/*                                                              */\n/*     parse upper arg cmd_area                                 */\n/*     proc_stmt = 'PROC 1 P1 KEY1(60) LIST  '                  */\n/*     call   TSOPROC cmd_area,proc_stmt                        */\n/*     interpret result                                         */\n/*     if rc > 0 then                                           */\n/*       do                                                     */\n/*         say tsoproc_msg                                      */\n/*         exit rc                                              */\n/*       end                                                    */\n/*     if list = 'LIST' then                                    */\n/*       etc                                                    */\n/*                                                              */\n/*                                                              */\n/* RC= 0  -  Processed successfully                             */\n/*     4  -  Error - Key requires a value                       */\n/*     8  -  Error - Value not allowed on KEYWORD               */\n/*    12  -  Error - key( ) contains invalid data               */\n/*    16  -  Error - No terminator for quoted string            */\n/*           key('string') requires the ending \"') \"            */\n/*    20  -  Invalid calling sequence to TSOPROC                */\n/*    24  -  Unrecognized parameters entered by user            */\n/*                                                              */\n/*    If a specific key is passed as the 3rd parameter to       */\n/*    TSOPROC, then error code 24 is not returned but the       */\n/*    unprocessed input is in tsoproc_left.                     */\n/*                                                              */\n/*    For ... KEYWORD ...   returns    keyword = 'KEYWORD'      */\n/*    For ... KEY(value)        -      key = 'value'            */\n/*    For ... KEY('value')      -      key = \"'value'\"          */\n/*    For ... KEY()             -      key = ''                 */\n/*    For ...                   -      key = 'default'          */\n/*                                                              */\n/* Additional notes:                                            */\n/*     If the user enters duplicate keywords then the           */\n/*     last value is returned.                                  */\n/*                                                              */\n/*     No prompt is done for missing or invalid values          */\n/*     The calling EXEC can, however, do prompting when         */\n/*     rc is nonzero.                                           */\n/*                                                              */\n/*     Quoted strings do not require double quotes as in TSO    */\n/*     CLISTS.  This is a feature not a bug!                    */\n/*                                                              */\n/*     If proc_stmt  = 'PROC 0 KEY1 KEY2()' then                */\n/*       Key1 does not allow a value, and key2 requires a value.*/\n/*                                                              */\n/*     Positional parameters are not required.  EXEC may        */\n/*     may check for null and prompt if desired.                */\n/*                                                              */\n/*     Comma or blanks are valid delimitors for keywords        */\n/*     when entered by user.  PROC statement must use blanks.   */\n/*--------------------------------------------------------------*/\n/* Written Nov 1985, by John Thomas   (Almaden Research Center) */\n/*                      JTHOMAS at ALMVSA                       */\n/*V1.1 - 12/01/85 -Fix to accept comma as delimitor             */\n/*--------------------------------------------------------------*/\nTSOPROC:\n\n  TRACE Off                        /* Do not trace subroutine   */\n  rc = 0                           /* return code               */\n  tsoproc_msg = ''                 /* error message area        */\n  tsoproc_left = ''                /* remainder of  area        */\n  tsoproc_cmd = ''                 /* REXX cmd to return to caller */\n  arg_cnt = ARG()                  /* number of arguments passed */\n  /*--------------------------------------------------*/\n  /* verify valid number of parameters                */\n  /*--------------------------------------------------*/\n  if arg_cnt < 2 | arg_cnt > 3 then /* 2 or 3 arguments required */\n    signal bad_input\n  /*--------------------------------------------------*/\n  /* verify valid PROC statement                      */\n  /*--------------------------------------------------*/\n  procstmt = arg(2)\n  parse value procstmt with proc proc# operands\n  if proc \u00ac= \"PROC\" | ,\n     datatype(proc#) \u00ac= 'NUM' then\n    do\n      tsoproc_msg = 'TSOPROC - Invalid PROC statement'\n      rc = 20\n      signal tsoproc_exit\n    end\n\n  work_area = arg(1)\" \"            /* User input - add trailing blank*/\n\n  /*--------------------------------------------------*/\n  /* process a specific key if specified              */\n  /*--------------------------------------------------*/\n  if arg_cnt = 3 then              /*  if specific key passed*/\n    do\n      key = arg(3)\n      parse value procstmt with proc proc# key_list\n      keyvalue = KEYPARSE(work_area,key_list,key)\n      if key_rc = 0 then\n          tsoproc_cmd = tsoproc_cmd || key \"=\" quoted(keyvalue) \";\"\n      else\n        do\n          tsoproc_cmd = tsoproc_cmd || key \"= '';\"\n          rc = key_rc\n          tsoproc_msg = key_msg\n        end\n    end\n\n  else      /* No specific key specified - Do them all */\n\n    do\n      /*--------------------------------------------------*/\n      /* process the positional operands                  */\n      /*--------------------------------------------------*/\n      if proc# > 0 then /* if one or more positional parameters */\n        do i = 1 to proc#\n          parse value operands with pos operands\n          pvalue = parsepos()\n          tsoproc_cmd = tsoproc_cmd || pos \"=\" quoted(pvalue) \";\"\n        end\n\n      /*--------------------------------------------------*/\n      /* process the keyword operands                     */\n      /*--------------------------------------------------*/\n      key_list = operands /* save key word portion of PROC statement */\n      key_area = work_area /* save key word portion of user input  */\n      do while operands \u00ac= ''\n        operands = strip(operands,\"L\")\n        parse value operands with key1 keyrest1\n        parse value key1\" \" with key2 \"(\" value \") \" .\n        key = key2\n        operands = keyrest1\n        keyvalue = KEYPARSE(key_area,key_list,key)\n        if key_rc = 0 then\n            tsoproc_cmd = tsoproc_cmd || key \"=\" quoted(keyvalue) \";\"\n        else\n          do\n            rc = key_rc\n            tsoproc_msg = key_msg\n            signal tsoproc_exit\n          end\n      end\n    end\n\n  tsoproc_left = key_area /*left over operands */\n\n  if arg_cnt = 2 & ,   /* if processing complete PROC statement */\n    key_area \u00ac= '' then   /*and unprocessed user input */\n    do\n      rc = 24\n      tsoproc_msg = 'Invalid input parameter -' key_area\n      signal tsoproc_exit\n    end\ntsoproc_exit:\n  tsoproc_cmd = tsoproc_cmd || 'rc =' rc ';'\n  tsoproc_cmd = tsoproc_cmd || 'TSOPROC_MSG = ' quoted(tsoproc_msg) ';'\n  tsoproc_cmd = tsoproc_cmd || 'tsoproc_left = ' quoted(tsoproc_left) ';'\n  return tsoproc_cmd\n/* END OF PROCESSING */\n\n\nbad_input:\n  parse source opsys envir rest\n  if envir \u00ac= 'SUBROUTINE' then\n    do\n      say \"TSOPROC can only be called as an REXX EXEC subroutine.\"\n      say \"Refer to TSOPROC EXEC prolog for calling sequence.   \"\n      exit 20\n    end\n  else\n    do\n      say 'Invalid call to TSOPROC,  At least 2 arguments are required'\n      tsoproc_msg = 'TSOPROC - Invalid call'\n      rc = 20\n      signal tsoproc_exit\n    end\n/*--------------------------------------------------------------*/\n/*        S U B R O U T I N E S                                 */\n/*--------------------------------------------------------------*/\n\n/*--------------------------------------------------------------*/\n/*Obtain the next positional parameter from the users cmd input */\n/*input:  work_area - command input area                        */\n/*returns: value of next positional parameter                   */\n/*                                                              */\n/*Modifies: work_area - the returned value is removed from it   */\n/*--------------------------------------------------------------*/\nparsepos:\n    trace off\n    work_area = strip(work_area,'L') /*remove leading blanks */\n    delim = left(work_area,1)    /* check for ' or ( */\n    if delim = \"'\" then          /* quoted string    */\n      do\n        parse value work_area with posvalue \"' \" work_area\n        posvalue = posvalue\"'\"    /*add back the ending quote*/\n      end;\n    else\n      if delim = \"(\" then        /* parenthasised string */\n        do\n          parse value work_area with posvalue \") \" work_area\n          posvalue = posvalue\")\"    /*add back the ending paren*/\n        end;\n      else\n        parse value work_area with posvalue work_area\n  return posvalue\n\n/*--------------------------------------------------------------*/\n/*quoted - build a valid string statement                       */\n/*  Place ' or \" around the string.                             */\n/*  If necessary, double the ' and place ' around the string    */\n/*--------------------------------------------------------------*/\nquoted:\n  trace off\n  p1 = arg(1)\n  if index(p1,\"'\") = 0 then        /* if no ' within string */\n    p1 = \"'\"p1\"'\"                /* then use ' as delimitor */\n  else\n    if index(p1,'\"') = 0 then      /* if no \" within string */\n      p1 = '\"'p1'\"'              /* then use \" as delimitor */\n    else\n      do\n        do i = 1 while(i < length(p1))  /*double up the 's */\n          i = index(p1,\"'\",i)\n          p1 = insert(\"'\",p1,i)\n          i = i + 2\n        end\n        p1 = \"'\"p1\"'\"       /* use ' as delimitor */\n      end\n  return p1\n/*--------------------------------------------------------------*/\n/*                                                              */\n/* KEYPARSE    Subroutine to Parse for a keyword in the argument*/\n/*                                                              */\n/*     KEYPARSE(String,ListofKeys,key)                          */\n/*       String - String to be parsed               (required)  */\n/*       ListOfKeys - String containing a list of   (required)  */\n/*                    blank-delimited keywords with             */\n/*                    defaults. Keywords must be uppercase.     */\n/*       Key    - Key to searched for               (required)  */\n/*                                                              */\n/*                                                              */\n/*    Returns:                                                  */\n/*      String containing key's value (or default if not found) */\n/*    Exposed variables:                                        */\n/*      key_rc    -  Return code                                */\n/*      key_value -  Keyword's value                            */\n/*      key_area  -  Input string with keyword deleted          */\n/*      key_msg   -  Error message when key_rc > 0              */\n/*                                                              */\n/*                                                              */\n/*    key_rc                                                    */\n/*     0  -  Processed successfully                             */\n/*     4  -  Error - Key requires a value                       */\n/*     8  -  Error - Value not allowed on KEYWORD               */\n/*    12  -  Error - key( ) contains invalid data               */\n/*    16  -  Error - No terminator for quoted string            */\n/*           key('string') requires the ending \"') \"            */\n/*                                                              */\n/*    If key_area is used in each call to keyparse for          */\n/*    all of the valid keys, then key_area should end up null.  */\n/*    key_area \u00ac= '' indicates unrecognized keywords.           */\n/*                                                              */\n/****************************************************************/\nkeyparse: procedure   expose key_rc key_area key_value key_msg\n\n  TRACE off                        /* Do not trace subroutine        */\n  wkarea = strip(arg(1))||\" \"      /* input string with 1 extra blank*/\n  key_area = ''                    /* parsed area minus found keys */\n  key_rc = 0                       /* return code              */\n  key_msg = ''                     /* error message area       */\n  key_list = arg(2)\n  key = arg(3)                     /* full keyword */\n  call get_defaults                /* sets min_abbrev, value_required*/\n                                   /* and default key_value          */\n/* debug\n  say key min_abbrev value_required key_value\n  trace r\n   debug */\n  do i = 1 by 1 while ( STRIP(wkarea) \u00ac= '' )\n    if i > 255 then                  /* apparently in an endless loop*/\n      exit 999\n    /*----------------------------------------*/\n    /* Process a simple keyword               */\n    /*----------------------------------------*/\n    if POS(\",\",wkarea) > 0 ,                       /*comma present */\n     & POS(\",\",wkarea) < POS(\" \",wkarea) then      /*as next delimitor*/\n      dlm = \",\"\n    else\n      dlm = \" \"\n    if  POS(\"(\",wkarea) = 0 ,\n     |  POS(dlm,wkarea) < POS(\"(\",wkarea)  then /*simple keyword */\n      do\n        parse var wkarea word (dlm) wkarea\n        if ( ABBREV(word,LEFT(key,min_abbrev)) ),\n         & ( ABBREV(key,word,min_abbrev) ) then\n          do\n            if value_required = 'NO' then /*if no value expected   */\n              key_value = key              /*-> returns KEYWORD */\n            else                   /*This keyword requires a value */\n              do\n                key_rc = 4\n                key_msg = 'TSOPROC - Key' key 'requires a value'\n              end\n          end\n        else\n          key_area =key_area||word||\" \" /* save the unknown key*/\n        wkarea = STRIP(wkarea,'L')    /*strip leading blanks */\n      end\n    else\n      /*----------------------------------------*/\n      /* Process a keyword with (value)         */\n      /*----------------------------------------*/\n      if ( POS(\"('\",wkarea) = 0 ),\n       | ( POS(\"(\",wkarea) < POS(\"('\",wkarea) ) then /*unquoted string*/\n        do\n          if POS(\"),\",wkarea) > 0 ,                 /*comma present */\n           & POS(\"),\",wkarea) < POS(\") \",wkarea||\") \") then\n            dlm = \"),\"\n          else\n            dlm = \") \"\n          len = INDEX(wkarea,dlm) +1\n          if len = 1 then            /*no trailing right paren*/\n            len = length(wkarea)\n          parse var wkarea word \"(\" value (dlm) rest\n          if ( ABBREV(word,LEFT(key,min_abbrev)) ),\n           & ( ABBREV(key,word,min_abbrev) ) then\n            do\n              key_value = value               /*-> returns key(value) */\n              if value_required = 'NO' then /*if no value expected   */\n                do\n                  key_rc = 8\n                  key_msg = 'TSOPROC - Value not allowed on keyword',\n                            key\n                end\n              /* verify that no imbedded blanks or quotes          */\n              if ( index(value,\" \") > 0 ) ,\n               | ( index(value,\"'\") > 0 ) then\n                do\n                  key_rc = 12\n                  key_msg = 'TSOPROC - Key' key 'contains invalid value'\n                end\n            end\n          else\n            key_area = key_area||LEFT(wkarea,len)\n          wkarea = DELSTR(wkarea,1,len)\n          wkarea = STRIP(wkarea,'L')    /*strip leading blanks */\n        end\n      else              /*quoted string processing */\n        /*----------------------------------------*/\n        /* Process a keyword with ('value')       */\n        /*----------------------------------------*/\n        do\n          if POS(\"'),\",wkarea) > 0 ,                 /*comma present */\n           & POS(\"'),\",wkarea) < POS(\"') \",wkarea||\"') \") then\n            dlm = \"'),\"\n          else\n            dlm = \"') \"\n          len = INDEX(wkarea,dlm) +2\n          parse value wkarea with word \"('\" value (dlm) rest\n          if ( ABBREV(word,LEFT(key,min_abbrev)) ),\n           & ( ABBREV(key,word,min_abbrev) ) then\n            do\n              key_value = \"'\"value\"'\"       /*return with quotes added*/\n              if value_required = 'NO' then /*if no value expected   */\n                do\n                  key_rc = 8\n                  key_msg = 'TSOPROC - Value not allowed on keyword',\n                            key\n                end\n            end\n          else\n            key_area = key_area||LEFT(wkarea,len)||\" \"\n          wkarea = DELSTR(wkarea,1,len)\n          wkarea = STRIP(wkarea,'L')    /*strip leading blanks */\n          if len = 2 then            /*no ending ')           */\n            do\n              key_rc = 16\n              key_msg = 'TSOPROC - Operands contain quoted string'||,\n                        ' with no ending delimitor'\n            end\n        end\n  end\n  key_area = STRIP(key_area)         /*remove leading/trailing blanks*/\n  return key_value\n\n/*--------------------------------------------------------------*/\n/* Determine minimum abbreviation for key based on list of keys */\n/* and obtain any default values                                */\n/*--------------------------------------------------------------*/\nget_defaults:\n  min_abbrev = 1\n  key_value = ''\n  value_required = 'NO'\n  operands = key_list\n  do while operands \u00ac= ''\n    operands = strip(operands,\"L\")\n    parse value operands with key1 keyrest1\n    parse value key1\" \" with key2 \"(\" value \") \" .\n    if key = key2 then             /* this is our keyword */\n      if key2 = key1 then          /* if there was no () */\n        value_required = 'NO'     /* indicate KEYWORD with no value*/\n      else\n        do\n          value_required = 'YES'     /* Not a KEYWORD. ie. KEY(value) */\n          key_value = value\n        end\n    else\n      min_abbrev = max(min_abbrev,compare(key,key2) )\n    operands = keyrest1\n  end\n  min_abbrev = min(length(key),min_abbrev)\n  return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT646/FILE646.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT646", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}