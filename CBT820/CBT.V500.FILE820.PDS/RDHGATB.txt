***********************************************************************
* Copyright (c) 2009 - Richard D. Harper, All Rights Reserved         *
***********************************************************************
*                                                                     *
*   This file is part of Richard Harper's Private Development         *
* Platform (PDP).                                                     *
*                                                                     *
*   Richard Harper's PDP is free software: you can redistribute       *
* it and/or modify it under the terms of the GNU General Public       *
* License as published by the Free Software Foundation, either        *
* version 3 of the License, or (at your option) any later version.    *
*                                                                     *
*   Richard Harper's PDP is distributed in the hope that it will      *
* be useful, but WITHOUT ANY WARRANTY; without even the implied       *
* warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.    *
* See the GNU General Public License for more details.                *
*                                                                     *
*   You should have received a copy of the GNU General Public         *
* License along with Richard harper's PDP.  If not, see               *
* <http://www.gnu.org/licenses/>.                                     *
*                                                                     *
***********************************************************************
*
***********************************************************************
*                                                                     *
** RDHGATB - Support Module for the #GETATB and #FREATB Macros        *
*                                                                     *
*    This program is entered via the execution of a #GETATB/#FREATB   *
*  to perform GETMAIN and FREEMAIN services for Above-The-Bar         *
*  storage in increments of less than a megabyte.  It allows the      *
*  user programs to obtain and release storage above-the-bar in       *
*  quadword increments, making better use of the storage available.   *
*    Storage is obtained in the key of the caller and anchored off    *
*  a task related RME (Resource Manager Exit).                        *
*                                                                     *
*                                                                     *
*  Abend Codes - S0A7   Reason Codes Below                            *
*  =======================================                            *
*  08 - Max Storage Requests exceeded (22,000+)                       *
*  0C - Attempt to obtain more tha one meg or storage                 *
*  10 - Attempt to freemain storage not allocated                     *
*  14 - Freemain request not equal to length of getmain               *
*                                                                     *
*                                                                     *
*    This is a simple implementation of getmain and freemain services *
*  for above-the-bar storage and it does have some limitations.  It   *
*  can only handle about 22,000 getmains, it's task related meaning   *
*  that each task gets a new set of storage areas, so that's 22,000   *
*  getmains per task.  It doesn't support subpools, though it does    *
*  support keyed storage.  And it does not support fetch or store     *
*  protected storage.                                                 *
*    It returns storage on a 32-byte boundry, so whatever length is   *
*  specified on the request will be rounded up to a 32-byte voundry.  *
*  And you cannot freemain a portion of the storage that was          *
*  previously acquired.  The freemain must match the Length of the    *
*  getmain.                                                           *
*    So, while the functionality of this service could be increased   *
*  it's good enough for now as it allows the developer to develop     *
*  fully functional 64(ANY) programs and systems. It allows the       *
*  developer to rise above 31-Bit.                                    *
*                                                                     *
*                                                                     *
*                                                                     *
*  Date     FIX-ID Programmer Description                             *
*  ======== ====== ========== ======================================= *
*  00/00/00  M001  R. Harper  Module Developed                        *
*                                                                     *
*                                                                     *
***********************************************************************
*
*---------------------------------------------------------------------*
* Define MVS System Data Areas                                        *
*---------------------------------------------------------------------*
*
         PRINT OFF
         IHAPSA  ,                     PSA  Deect
         CVT   DSECT=YES               CVT  Dsect
         IHASCVT ,                     SCVT Dsect
*
         IHAASCB ,                     ASCB Dsect
         IHAASXB ,                     ASXB Dsect
         IHAASSB ,                     ASSB Dsect
         IHASDWA ,                     ASSB Dsect
*
         IKJTCB  ,                     TCB  Dsect
         IHASTCB ,                     STCB Dsect
         IHARB   ,                     PRB  Dsect
         PRINT ON,NOGEN
*
*---------------------------------------------------------------------*
* Define Internal RDHGATB Data Areas                                  *
*---------------------------------------------------------------------*
*
         PRINT GEN
         RMEDSECT ,                    Define RMEDSECT Area
         LSEDSECT ,                    Define Linkage Stack Area
*
** Virtual Above-The-Bar Storage Management DSECT Areas
*
*
*  VABDSECT - Virtual ATB Primary Anchor, Exists Below the Line and
*             is pointed to by an RME
*  VAADSECT - Virtual ATB Primary Anchor Page, exists above teh bar
*             and is pointed to by VABANCOR.
*  VAKDSECT - Virtual ATB Anchor for a Given Key, space is defined
*             within VAA at VAASTKEY, 16 copies are defined, one
*             for each possible key.
*
*  VASDSECT - Storage Entry, defines characteristics of allocated
*             or free storage pages.
*
*--------------------------------------------------------------------*
* VABDSECT - Define below the line Anchor Block pointed to by RME
*--------------------------------------------------------------------*
*
VABDSECT DSECT ,
VABEYECT DS    CL8                     EyeCatcher 'VABDSECT'
VABTCBAD DS    A                       TCB Address
VABLENTH DS    F                       Length of This Area
*
         DS    0D
VABRESMP DS    D                       Parm Passed to Resource Manager
VABRESMT DS    F                       Token From RESMGR Delete
VABRESM  DS    XL(MDLRESML)            Reserve Space for RESMGR
*
VABPAGCT DS    D                       Count of ATB Pages (1)
VABANCOR DS    AD                      1st ATB Page on Chain
VABANTOK DS    AD                      User Token for IARV64
*
         DS    0D                      End on Doubleword
VABLNGTH EQU   *-VABDSECT              Length of Area
*
*--------------------------------------------------------------------*
* VAADSECT - Primary Above the Bar Anchor Page
*--------------------------------------------------------------------*
*
VAADSECT DSECT ,                   -*- ATB Task Anchor Dsect
VAAEYECT DS    CL8                     EyeCatcher 'VAADSECT'
VAATCBAD DS    A                       TCB Address
VAAPAGCT DS    F                       Count of Pages in This Extent
VAANEXTA DS    AD                      Next VAADSECT Extent
*
VAASTABL DS    AD                      Beg of Storage Entry Table
VAASTCHN DS    AD                      Chain of Free Table Entries
         DS   3D                       (Reserved)
*
         DS    0D                      On Doubleword Boundry
VAASTKEY DS    16XL(VAKLNGTH)          One Entry Per Possible Key
*
         DS    0D
VAALNGTH EQU   *-VAADSECT              Length of Area
VAAMAXNT EQU   (1024*1024-VAALNGTH)/VASLNGTH   Max Entries Per Page
*
*--------------------------------------------------------------------*
* VAKDSECT - Define Pointers to Alloc/Free storage by Key
*--------------------------------------------------------------------*
*
*   There are 16 VAKDSECT entries defined one for each possible key.
* these areas are defined within VAADSECT at label VAASTKEY.
*
*   This table contains three chains of of VASDSECT entries that
* define areas of allocated or free storage within ATB pages we
* have acquired on behalf of the caller.
*
* VAKSTPAG - Will point at a VAS that have the address of a page
*            of ATB Storage we have acquired to fill a request. We
*            monitor this so we can free the storage at task term.
*
* VAKSTFRE - Points to a chain of VAS entries that represent areas
*            of storage within an ATB page that is free and available
*            for allocation.
*
* VAKSTALO - Points to a chain of VAS Entries that represent areas
*            of storage within an ATB page that is currently allocated.
*
*
VAKDSECT DSECT ,                   -*- ATB Per Key Storage Entry
VAKEYECT DS    CL3                     VAK Eye Catcher
VAKSTKEY DS    X                       Storage Key For This Entry
         DS    F
VAKSTPAG DS    AD                      Chain of Gotten Page   Entries
VAKSTFRE DS    AD                      Chain of Free  Storage Entries
VAKSTALO DS    AD                      Chain of Alloc Storage Entries
*
         DS    0D                      End on Doubleword
VAKLNGTH EQU   *-VAKDSECT              Length of Area - 32 -Bytes
*
*--------------------------------------------------------------------*
* VASDSECT - Define a Storage Entry for a Page, Allocated or Free Area
*--------------------------------------------------------------------*
*
VASDSECT DSECT ,                   -*- Storage Entry - Aloc/Free
VASEYECT DS    CL3                     VAS Eye Catcher
VASSTKEY DS    X                       Storage Key For This Entry
VAS1FLAG DS    B                       Flag Byte
VAS1NUSE EQU   X'80'                   This Storage Entry is In Use
VAS1SPAG EQU   X'40'                   Entry for Gotten Pages Chain
VAS1SFRE EQU   X'20'                   Entry for Free Space Chain
VAS1SALO EQU   X'10'                   Entry for Aloc Space Chain
         DS    BL3
VASCHAIN DS    AD                      Pointer to Next Entry Aloc/Free
VASSTPTR DS    AD                      Pointer to Storage Area
VASSTSIZ DS    A                       Size of Storage Area
VASPSWAD DS    A                       Return PSW From #GETATB
         DS    0D                      End on Doubleword
VASLNGTH EQU   *-VASDSECT              Length of Area - 32-Bytes
*
***********************************************************************
* RDHGATBT - Test Program for RDHGATB                                 *
***********************************************************************
*
         USING PSA,R0                  Establish Addressability
*
*
***********************************************************************
* RDHGATB - Program Main Entry Point                                  *
***********************************************************************
*
         USING PSA,R0                  Establish Addressability
         USING VABDSECT,R9             VABDSECT Addressability
         USING VAADSECT,R8             VAADSECT Addressability
         USING VAKDSECT,R7             VAKDSECT Addressability
         USING VASDSECT,R6             VASDSECT Addressability
*
RDHGATB  PGMNTRY TYPE=MAIN,            Establish Main Entry Point      *
               AMODE=64,               Runs AMODE(64)                  *
               RMODE=ANY,              Runs RMODE(ANY)                 *
               CBAS=(R12),             Define Constant Base Register   *
               ABAS=(R11),             Define ATB Base Register        *
               ESTAE=NO,               No ESTAE Support Needed         *
               TRACE=NO,               No Traces As Distributed        *
               IMP=BASR,               Traces are BASR Implementation  *
               PRINT=GEN,                                              *
               MSG='Entering RDHGATB #GETATB/#FREATB Support Module.'
*
** Save Input Parameters in DSA
*
         STG   R0,DSAWORKD             Get Macro Operands
         MVC   DSAOPFLG(2),DSAWORKD+2  Get Options and Key
         AHI   R0,31                   Round to 32 Byte Boundry
         SRL   R0,5                    (Same)
         SLL   R0,5                    (Same)
         STY   R0,DSAGLNTH             Save Length of Area to Get/Free
         STG   R1,DSAGADDR             Save Address if Freemain
*
** Program MainLine
*
         GOSUB INIT                    Do Init Processing
         GOSUB MAIN                    Do Main Processing
         GOSUB TERM                    Do Term Processing
*
** Return to Caller
*
EXIT     DS    0H
         PGMEXIT RC=(*,DSA$RC),        Return to Caller                *
               R1=(*,DSARAREA)         Return Address
*
*=====================================================================*
** MAIN - Main Processing Routine                                     *
*=====================================================================*
*
MAIN     SUBNTRY ,
         XGR   R7,R7                   Zero Work Register
         IC    R7,DSAGKEY              Get Key of Storage
         SRL   R7,4                    Put in Low Nibble
         MH    R7,=Y(VAKLNGTH)         Times Entry Length
         LA    R7,VAASTKEY(R7)         Point at Proper VAK Entry
*
         IF (TM,DSAOPFLG,DSAOPFRE,Z)   If Getmain Request?
            GOSUB GETMAIN              ..Get Some Storage
         ELSE ,                        Else
            GOSUB FREMAIN              ..Free The Storage
         ENDIF ,
*
** Return to Caller
*
         SUBEXIT ,
*
*=====================================================================*
** INIT - Do Initialization Processing                                *
*=====================================================================*
*
INIT     SUBNTRY ,
         ENQ (CONMAJOR,CONMINOR,E,8,STEP) Get Exclusive Control
*
         GOSUB LOCVAB                  Locate VABDSECT for Task
         LGR R9,R1                     Get Address of VABDSECT
         IF (LTR,R9,R9,Z)              If Not There Yet?
            GOSUB OPEN                 ..Build it on First Call
         ENDIF
         LG  R8,VABANCOR               Get Address of VAADSECT
*
** If We're Under an SVRB Get Key of Caller From SVRB
*
         LLGT  R2,PSATOLD              Get our TCB Address
         USING TCB,R2                  And Addressability
         LLGT  R2,TCBRBP               Get PRB/SVRB Address
         USING RBBASIC,R2              And Addressability
         IF (TM,RBSTAB1,RBFTSVRB,O)    If We're Under an SVRB?
            MVC DSAPSW1,RBOPSW         Save PSW in DSA
            MVC DSAPSW2,RBOPSW         (Same)
            MVC DSAGKEY,DSAPSW1+1      Get Key of Caller
            NI  DSAGKEY,X'F0'          And Unused Bits
         ELSE ,
*
** Get Key of Caller From Linkage Stack
*
            STCTG CR15,CR15,DSAWORKD   Get Linkage Stack Address
            LG R15,DSAWORKD            (Same)
            SH R15,=Y(LSENLNTH)
            USING LSEN,R15             Get Temp Addressability
            MVC DSAPSW1,LSENPSW1       Save PSW in DSA
            MVC DSAPSW2,LSENPSW2       (Same)
            MVC DSAGKEY,DSAPSW1+1      Get Key of Caller
            NI  DSAGKEY,X'F0'          And Unused Bits
         ENDIF ,
*
** If Caller Specified Key= Use the Key He Requested
*
         IF (TM,DSAOPFLG,DSAOPKEY,O)   Did Caller Speecify KEY=?
            MVC DSAGKEY,DSAOKEY        ..Give Him What he Wants
         ENDIF ,
** Return to Caller
*
INIT999  DS    0H
         SUBEXIT ,
         DROP  R15                     Drop Temp Addressability
*
*=====================================================================*
** TERM - Do Termination Processing                                   *
*=====================================================================*
*
TERM     SUBNTRY ,
         DEQ (CONMAJOR,CONMINOR,8,STEP) Free Exclusive Control
*
** Return to Caller
*
TERM999  DS    0H
         SUBEXIT ,
*
*=====================================================================*
** GETMAIN - Obtain Storage Area for Caller                           *
*=====================================================================*
*
GETMAIN  SUBNTRY DATA=('VAKDSECT Area',0(R7),VAKLNGTH)
         IF (CLC,DSAGLNTH,GT,=A(1024*1024))  If More tha a meg?
            IF (TM,DSAOPFLG,DSAOPRC,O) Conditional Getmain?
               MVC DSA$RC,=F'8'        ..Set Bad Return Code
               B GETM999               ..Exit
            ELSE ,
               B ABEND00C                    ..Abend the Task
            ENDIF ,
         ENDIF
*
         IF (OC,VAKSTPAG,VAKSTPAG,Z)   If First Request This Key
            GOSUB GETPAGE              ..Get a Page for This Key
         ENDIF ,
*
         GOSUB GETFREE                 Locate Available Free Space
         GOSUB ASSIGN                  Assign Storage to Caller
*
** Return to Caller
*
GETM999  DS    0H
         SUBEXIT ,
*
*=====================================================================*
** FREEMAIN - Free Storage Area for Caller                            *
*=====================================================================*
*
FREMAIN  SUBNTRY DATA=('VAKDSECT Area',0(R7),VAKLNGTH)
*
         GOSUB SHOFREE
         GOSUB LOCALOC                 Locate Allocated Stor VAS Entry
         GOSUB FREESTR                 Freemain The Storage
*
** Return to Caller
*
         SUBEXIT ,
*
*=====================================================================*
*                                                                     *
** OPEN - Build Initial Data Areas for Managing ATB Storage           *
*                                                                     *
*    This routine obtains storage below the line for the VABDSECT     *
*  area, and the first page of ATB Storage above the bar.  This
*  first page is contains the VAADSECT area followed by as many       *
*  VASDSECT areas that will fit in that page, about 22,000.  This     *
*  first page is used to manage allocated and free storage above      *
*  the bar.  Another page will later be obtained for a VAKDSECT       *
*  of the key requested by that caller and storage in that second     *
*  page will be assigned and returned to the caller.                  *
*    Doing it this way keeps my control block that I need to have     *
*  to manage these requests seperate from the storage that I then     *
*  assign to the user seperate and less likely that they will         *
*  overlay my control blocks.  It should be in fetch protected and    *
*  in a supervisor key.  Maybe I'll do that later.  For now it's      *
*  non-fetch protected and in key zero storage.                       *
*    It also establishes a Resource Manager Exit so we can locate the
*  area on subsequent calls, and free the storage at
*  Task termination.                                                  *
*                                                                     *
*=====================================================================*
*
OPEN     SUBNTRY ,
*
** Obtain Storage for VABDSECT Area Below-The-Line
*
         STORAGE OBTAIN,               Obtain Storage for VAB          *
               LENGTH=4096,            (Same)                          *
               LOC=(24,31),BNDRY=PAGE  (Same) - Below The Line
*
         LR  R9,R1                     Get Address of VABDSECT
         MVCY VABEYECT,=C'VABDSECT'    Place Eye Catcher
         MVC VABTCBAD,PSATOLD          Save TCB Address
         MVC VABLENTH,=A(4096)         Save Length for Freemain
         #TRACE MSG='VABDSECT Address in R1',REGS=(R1)
*
** Obtain Storage for VAADSECT Area Above-The-Bar
*
         MVC  VABANTOK+4(4),PSATOLD    Set DSA Address as User Token
         OI   VABANTOK+3,X'FF'         Non-Zero for SUPR Pgms
         MVCY VABPAGCT,=AD(1)          Save Page Count for Freemain
         LA   R2,VABPAGCT              Set Number of Segments (Meg)
         IARV64 REQUEST=GETSTOR,       Get Some ATB Storage            *
               SEGMENTS=(R2),          ..Number of Segments            *
               FPROT=NO,               ..Not Fetch Protected           *
               KEY=DSAGKEY,            ..Storage Key of Page           *
               ORIGIN=VABANCOR,        ..Return Address Here           *
               USERTKN=VABANTOK,       ..Indicate User Token           *
               MF=(E,DSAV64)           ..Address of List Form
         LG R8,VABANCOR                Get Address of Anchor Page VAA
*
         MVCY  VAAEYECT,=C'VAADSECT'   Set Eye Catcher
         MVC   VAATCBAD,PSATOLD        Save TCB Address
         MVC   VAAPAGCT,VABPAGCT+4     Save Page Count
         LA    R15,VAALNGTH(,R8)       Get Start of Storage Entries
         STG   R15,VAASTABL            Save in VAADSECT
         STG   R15,VAASTCHN            Chain of Available Entries
*
** Populate the VAK Entries in the VAA
*
         LA  R7,VAASTKEY               Get Key Table Address
         USING VAKDSECT,R7             Temp Addressability
         LA  R2,16                     Process 16 Table Entries
         XGR R1,R1                     Initial Key Value
         DO FROM=(R2)                  Loop Through table
            MVC VAKEYECT,=C'VAK'       Set Eye Catcher
            LR  R0,R1                  Put in Proper Format
            SLL R0,4                   (Same)
            STC R0,VAKSTKEY            Set Key This Entry
            LA  R1,1(,R1)              Bump to Next Key
            LA  R7,VAKLNGTH(,R7)       Bump to Next Table Entry
         ENDDO ,                       -> Loop
*
** Populate the VAS Entries and Build Initial Chain
*
         LG    R6,VAASTABL             Save in VAADSECT
         L     R14,=A(VAAMAXNT)        Get Count of Entries Per Page
         DO FROM=(R14)                 Build Initial Free Chain
            MVC VASEYECT,=C'VAS'       Set Eye Catcher
            LA  R1,VASLNGTH(,R6)       Point at Next Entry
            STG R1,VASCHAIN            Set as Next Entry-Chain Forward
            LGR R6,R1                  Point at Next Entry
         ENDDO ,                       -> Loop
*
         SHY R6,=Y(VASLNGTH)           Back Up to Last Entry
         XC  VASCHAIN,VASCHAIN         Zero Chain Ptr in Last Entry
*
** Establish a Resourge Manager Exit for This Task if Not Present
*
         L     R2,=A(RDHVABEX)             Identify The EP for LINK
         IDENTIFY EP=RDHVABEX,ENTRY=(R2)   (Same)
*
         MVC   VABRESMP(4),=C'VABP'    Set Identifier in Param
         ST    R9,VABRESMP+4           Addr of VABDSECT for This Task
         MVC   VABRESM,MDLRESM         Set List Form in Storage
*
         SAM31                         Downgrade to 31-Bit
         LG    R3,=VD(RDHVABEX)
         RESMGR ADD,TYPE=TASK,         Establish RESMGR Exit This Task *
               ASID=CURRENT,              ..And This Address Space     *
               ROUTINE=(BRANCH,(R3)),     ..RSM Routine Under an RB    *
               PARAM=VABRESMP,            ..Parameter Input            *
               TOKEN=VABRESMT,            ..Token for DELETE           *
               MF=(E,VABRESM)             ..Point to List Form
*
         IF (LTR,R15,R15,NZ)           Established Properly?
            #SUICIDE MSG='RDHT0001: RESMGR Macro Failed.'
         ENDIF ,
         SAM64                         Reset Proper Amode
*
** Show Your Work
*
         #TRACE DATA=('VABDSECT Data Area',0(R9),VABLNGTH)
         #TRACE DATA=('VAADSECT Data Area',0(R8),VAALNGTH)
         #TRACE DATA=('VASDSECT Beg Areas',VAALNGTH(R8),64)
*
         LGR R2,R8                     Get End Address of Page
         AG  R2,=AD(1024*1024-64)      (Same)
         #TRACE REGS=(R2,R8,R9)
         #TRACE DATA=('VASDSECT End Areas',0(R2),64)
*
** Return to Caller
*
OPEN999  DS    0H
         SUBEXIT ,
*
*=====================================================================*
*                                                                     *
** LOCVAB - Locate the VABDSECT AREA for the Current Task             *
*                                                                     *
*   This routine will loop through the RME DSECTS for the current     *
* TCB looking for the Entry for RDHVABEX.  If found it will return    *
* the address of VABDSECT in R1.  If not found R1 will be zero on     *
* exit.                                                               *
*                                                                     *
*=====================================================================*
*
         USING TCB,R14                 TCB  Addressability
         USING STCB,R15                STCB Addressability
         USING RMEDSECT,R1             RME  Addressability
*
LOCVAB   SUBNTRY ,
         LY R14,PSATOLD                Address of our TCB
         LY R15,TCBSTCB                Address of STCB
         LY R1,STCBRMEF                Get RESMGR Queue
*
         DO WHILE=(LTR,R1,R1,NZ)       Loop RME Chain
            CLCY RMEPARAM,=C'VABP',SAVE=YES 20-Bit Complient
            IF (EQ)                    If This is Our Exit...
               DOEXIT ,                     ..And Exit
            ENDIF
            LY R1,RMEFWDPT             Get Next RME on Chain
         ENDDO ,                       -> Loop
*
         IF (LTR,R1,R1,NZ)             If We Found Our Anchor
            LY R1,RMEPARAM+4           ..Get Address of VABDSECT
         ENDIF ,                       Else, Return Zero
*
** Return to Caller
*
         SUBEXIT MSG='VABDSECT Address Returned in R1.',REGS=(R1)
*
         DROP  R14,R15,R1              Drop Temp Addressability
*
*=====================================================================*
** GETPAGE - Get a Page for a VAK of a Specific Key                   *
*=====================================================================*
*
GETPAGE  SUBNTRY
         MVC  DSAANTOK+4(4),PSATOLD    Set TCB Address as User Token
         OI   DSAANTOK+3,X'FF'         Non-Zero for SUPR Pgms
         MVCY DSAPAGCT,=AD(1)          Obtain 1 Page at a Time
         LA   R2,DSAPAGCT              Set Number of Segments (Meg)
         IARV64 REQUEST=GETSTOR,       Get Some ATB Storage            *
               SEGMENTS=(R2),          ..Number of Segments            *
               FPROT=NO,               ..Not Fetch Protected           *
               ORIGIN=DSAANCOR,        ..Return Address Here           *
               KEY=VAKSTKEY,           ..Specify Storage Key           *
               USERTKN=DSAANTOK,       ..Indicate User Token           *
               MF=(E,DSAV64)           ..Address of List Form
*
** Get a VAS Entry to a Page for VAK
*
         GOSUB GETFVAS                 Get as Available VAS
         LGR R6,R1                     And Addressability
*
** Fill in VAS Dsect for a Gotten ATB Page
*
         XC VASDSECT(VASLNGTH),VASDSECT Start Fresh
         MVCY VASEYECT,=C'VAS'          Set Sys Catcher
         MVCY VASSTKEY,VAKSTKEY         Set Storage Key
         OI  VAS1FLAG,VAS1SPAG          Indicate Gotten Page Chain
         MVC VASCHAIN,VAKSTPAG          Insert This One First
         STG R6,VAKSTPAG                (Same)
         MVC VASSTPTR,DSAANCOR          Set New Page Address
         MVC VASSTSIZ,=A(1024*1024)     Size is One Meg
*
** Get a VAS Entry For Free Storage Area
*
         GOSUB GETFVAS                 Get as Available VAS
         LGR R6,R1                     And Addressability
*
** Fill in VAS Dsect for a Free Storage Entry
*
         XC VASDSECT(VASLNGTH),VASDSECT Start Fresh
         MVC VASEYECT,=C'VAS'           Set Sys Catcher
         MVC VASSTKEY,VAKSTKEY          Set Storage Key
         OI  VAS1FLAG,VAS1SFRE          Indicate Gotten Page Chain
         MVC VASCHAIN,VAKSTFRE          Insert This One First
         STG R6,VAKSTFRE                (Same)
         MVC VASSTPTR,DSAANCOR          Set New Page Address
         MVC VASSTSIZ,=A(1024*1024)     Size is One Meg
*
** Return to Caller
*
         SUBEXIT ,
*
*=====================================================================*
** GETFREE - Get VAS Free Space Entry That Will Satisfy The Request   *
*=====================================================================*
*
S        USING VASDSECT,R5             Previous VAS Area
*
GETFREE  SUBNTRY
         LA R5,VAKSTFRE-(VASCHAIN-VASDSECT) Set 1st Forward Pointer
         LG R6,VAKSTFRE                Get 1st Free Space Entry
         DO WHILE=(LTR,R6,R6,NZ)       Loop Through Free Stor Chain
            DOEXIT (CLC,DSAGLNTH,LE,VASSTSIZ) Exit if We Fit...
            LGR R5,R6                  Save Previous Entry
            LG  R6,VASCHAIN            Get Next Entry on Chain
         ENDDO ,
*
         IF (LTR,R6,R6,Z)              If No Free Space Large Enough
            GOSUB GETPAGE              ..Get Another Page
            LG  R6,VAKSTFRE            ..And Return This Entry
            MVC VAKSTFRE,VASCHAIN      ..And Pop it Off Chain
         ELSE ,
            MVC S.VASCHAIN,VASCHAIN    Pop This One Off Chain
         ENDIF ,                       By Chaining Next VAS to Prev
         XC  VASCHAIN,VASCHAIN         And Note We're Unchained
*
         #TRACE DATA=('Found Free Space VAS',0(R6),VASLNGTH),          *
               MSG=('VAKSTFRE: ',VAKSTFRE)
*
** Return to Caller
*
         SUBEXIT ,
         DROP  S                       Drop Temp Addressability
*
*=====================================================================*
** ASSIGN - Assign This Storage to Caller
*=====================================================================*
*
* R6 -> VAS Free Space Entry That Has Been Popped off the Free Chain
*
S        USING VASDSECT,R5             Allocated Space Entry
*
ASSIGN   SUBNTRY
         GOSUB GETFVAS                 Get an Available VAS
         LGR R5,R1                     And Addressability
         #TRACE DATA=('VAKDSECT On Entry',0(R7),VAKLNGTH)
         #TRACE DATA=('Free Space VAS On Entry',0(R6),VASLNGTH)
*
** Fill in VAS Dsect for an Allocated Storage Entry
*
         XC  S.VASDSECT(VASLNGTH),S.VASDSECT  Start Fresh
         MVC S.VASEYECT,=C'VAS'        Set Sys Catcher
         MVC S.VASSTKEY,VAKSTKEY       Set Storage Key
         OI  S.VAS1FLAG,VAS1SALO       Indicate Gotten Page Chain
         LG  R14,VASSTPTR              Get Free Storage Pointer
         STG R14,S.VASSTPTR            Set Allocated Addr in S.VAS
         MVC S.VASSTSIZ,DSAGLNTH       Size User Requests
         MVC S.VASPSWAD,DSAPSW2+4      Save Callers Address
         MVC DSARAREA,S.VASSTPTR       Pass Address to Caller
*
         MVC S.VASCHAIN,VAKSTALO       Add Entry to Allocated Chain
         STG R5,VAKSTALO               (Same)
*
** Update the Free Space VAS and Put it Back on the Free Space Chain
*
         LG  R14,VASSTPTR              Get Free Storage Pointer
         A   R14,DSAGLNTH              Add Length of Area to Get
         STG R14,VASSTPTR              Set New Free Space Address
         LLGT R15,VASSTSIZ             Get Free Area Size
         S   R15,DSAGLNTH              Sub Length of Area to Get
         ST  R15,VASSTSIZ              Set New Free Space Length
*
         IF (LTR,R15,R15,NZ)           If Free Space Not Exhausted?
            MVC VASCHAIN,VAKSTFRE      ..Put VAS Back on Free Chain
            STG R6,VAKSTFRE            ..(Same)
         ELSE ,                        Else
            XC  VASDSECT(VASLNGTH),VASDSECT Re-Initialize VAS
            MVC VASEYECT,=C'VAS'            (Same)
            MVC VASCHAIN,VAASTCHN      And Put it on Free VAS Chain
            STG R6,VAASTCHN            (Same)
         ENDIF
*
         #TRACE DATA=('VAKDSECT Area',0(R7),VAKLNGTH)
         #TRACE DATA=('New Free Space VAS',0(R6),VASLNGTH)
         #TRACE DATA=('New Alloc Space VAS',0(R5),VASLNGTH)
*
** Return to Caller
*
         SUBEXIT ,
         DROP  S                       Drop Temp Addressability
*
*=====================================================================*
** GETFVAS - Get a Free VAS Entry From the Free Chain - Pop Off Chain *
*=====================================================================*
*
*  On Exit R1 -> Free VAS Entry to Use
*
S        USING VASDSECT,R1             VAS Temp Addressability
*
GETFVAS  SUBNTRY ,
         LG   R1,VAASTCHN              Get Chain of Available VAS
         IF (LTR,R1,R1,Z)              If None Left?
            B ABEND008                 ..Force an Abend
         ENDIF ,
*
         LG R1,VAASTCHN                Get First Free VAS Entry
         DO UNTIL=(CSG,R1,R2,Z,VAASTCHN) Catch it if you Can
            LG R2,S.VASCHAIN           Get Forward Pointer
         ENDDO ,                       -> Try Again - Spin loop
*
** Return to Caller
*
         SUBEXIT ,
         DROP  S                       Drop Temp Addresability
*
*=====================================================================*
** LOCALOC - Locate Callers Allocated Storage VAS for Freemain        *
*=====================================================================*
*
*    This routine will runn the allocated storage chain of VASDSECTs
*  and locate teh entry created when the storage was getmained.  It
*  will then pop it off the chain and return the address in R6.
*    In the unlikely event that we do not find a allocate storage
*  VAS that matches the address passed in by the caller, we will
*  terminate the task with a U0167 abend RS=16.
*
S        USING VASDSECT,R5             Allocated Space Entry
*
LOCALOC  SUBNTRY
         LA R5,VAKSTALO-(VASCHAIN-VASDSECT)   Set 1st Forward Pointer
         LG R6,VAKSTALO                       Get Alloc Storage Head
         DO WHILE=(LTR,R6,R6,NZ)              Run The Chain
            DOEXIT (CLC,DSAGADDR,EQ,VASSTPTR) -> Exit When Found
            LGR R5,R6                         Save Previous Entry
            LG  R6,VASCHAIN                   Get Next Entry on Chain
         ENDDO ,                              -> Loop
*
         IF (LTR,R6,R6,Z)              If We Didn't Find It
            B ABEND010                 ..Abend The Bad Boy
         ELSE ,
            IF (CLC,DSAGLNTH,NE,VASSTSIZ)  If Not Same Size?
               B ABEND014                  ..Abend the Caller U167/20
            ENDIF
            MVC S.VASCHAIN,VASCHAIN    Pop This One Off Chain
         ENDIF ,                       By Chaining Next VAS to Prev
         XC  VASCHAIN,VASCHAIN         And Note We're Unchained
*
** Return to Caller
*
         SUBEXIT DATA=('Found ALOC Space VAS',0(R6),VASLNGTH),         *
               MSG=('VAKSTALO: ',VAKSTALO)
         DROP S                        Drop Temmp Addressability
*
*=====================================================================*
** FREESTR - Freemain the Storage Requested By Caller                 *
*=====================================================================*
*
* R6 -> VAS Allocated Space Entry That Has Been Popped off the Chain
*
*   At this point the storage has actually already been freed in
* that the allocated storage has been located and the associated
* VAS has been popped off the allocated storage chain.  What we
* need to do now is to locate any free space entry on the free
* space chain, if there is one, and merge them together so we
* don't get too fragmented.
*
S        USING VASDSECT,R5             Previous Free Space VAS
A        USING VASDSECT,R4             Allocated Space Entry
*
FREESTR  SUBNTRY DATA=('Allocated Space VAS Input',0(R6),VASLNGTH)
         MVI DSAMERGE,C'N'             Set Indicator Negative
         LGR R4,R6                     Save Allocated Space VAS
*
** Attempt to Merge Allocated Space VAS with a Free Space VAS
*
         LG  R2,A.VASSTPTR             Get The Ending Address
         AGF R2,A.VASSTSIZ             (Same)
*
         LA R5,VAKSTFRE-(VASCHAIN-VASDSECT) Set 1st Forward Pointer
         LG R6,VAKSTFRE                Get 1st Free Space Entry
         DO WHILE=(LTR,R6,R6,NZ)       Loop Through Free Stor Chain
            IF (CG,R2,EQ,VASSTPTR)     If AloEnd=FreBeg?
               #TRACE DATA=('Merging Before Free VAS',0(R6),VASLNGTH)
               MVC VASSTPTR,A.VASSTPTR ..Free Space Entry Has New Beg
               LLGT R14,VASSTSIZ       ..And Grew a Little Bigger
               A    R14,A.VASSTSIZ     ..(Same)
               ST   R14,VASSTSIZ       ..Save Result
               MVI  DSAMERGE,C'Y'      ..Indicate Merge
               LGR R5,R6               Position Between Prev & Next
               LG  R6,VASCHAIN         To See if They Can Now Merge
               #TRACE DATA=('Free VAS After Merge',0(R6),VASLNGTH)
            ENDIF ,
*
            LG  R3,VASSTPTR            Get The Ending Addr of Free VAS
            AGF R3,VASSTSIZ            (Same)
            IF (CG,R3,EQ,A.VASSTPTR)   If FreBeg=AloEnd?
               #TRACE DATA=('Merging After Free VAS',0(R6),VASLNGTH)
               LGF R14,VASSTSIZ        ..Get Previous Free VAS Size
               A   R14,A.VASSTSIZ      ..And Add Size of Aloc VAS
               ST  R14,VASSTSIZ        ..Save Result
               MVI DSAMERGE,C'Y'       ..Indicate Merge
               LGR R5,R6               Position Between Prev & Next
               LG  R6,VASCHAIN         To See if They Can Now Merge
               #TRACE DATA=('Free VAS After Merge',0(R5),VASLNGTH)
               #TRACE DATA=('Next VAS After Merge',0(R6),VASLNGTH)
            ENDIF ,
*
            DOEXIT (CLI,DSAMERGE,EQ,C'Y')   -> Exit if Done
            LGR R5,R6                  Save Previous Entry
            IF (LTR,R6,R6,NZ)          If More Than 1 Entry?
               LG R6,VASCHAIN          Get Next Entry on Chain
            ENDIF ,
         ENDDO ,
*
** Dispose of the Allocated Space VAS If We Merged
*
         IF (CLI,DSAMERGE,EQ,C'Y')     If we Merged With a Free VAS
            MVC A.VASEYECT,=C'VAS'     Set Eye Catcher
            MVC A.VASCHAIN,VAASTCHN    Add Entry to Free VAS Chain
            STG R4,VAASTCHN            (Same)
*
*                                  -*- Check for Double Mergings
            LG  R2,S.VASSTPTR          Get The Ending Address For Prev
            AGF R2,S.VASSTSIZ          (Same)
            #TRACE MSG='We Did Merge',REGS=(R2,R6)
            GOSUB SHOFREE
            IF (LTR,R6,R6,NZ),AND,     If PrevEnd=NextBeg?             *
               (CG,R2,EQ,VASSTPTR)
               #TRACE DATA=(('Double Merge Prev',0(R5),VASLNGTH),      *
               ('Double Merge Next',0(R6),VASLNGTH))
               LGF R14,S.VASSTSIZ      ..Get Prev VAS Size
               A   R14,VASSTSIZ        ..And Add Size of Next VAS
               ST  R14,S.VASSTSIZ      ..Save Result
               MVC S.VASCHAIN,VASCHAIN ..Chain Prev to Next Next
               #TRACE DATA=('After Double Merge',0(R5),VASLNGTH)
*
               XC  VASDSECT(VASLNGTH),VASDSECT Indicate Free
               MVC VASEYECT,=C'VAS'    Set Eye Catcher
               MVC VASCHAIN,VAASTCHN   Add Entry to Free VAS Chain
               STG R6,VAASTCHN         (Same)
               LGR R6,R5               Make Merged one Current
            ENDIF ,
         ENDIF ,
*
** Check For Empty Page - Can it Be Freed?
*
         IF (CLC,VASSTSIZ,EQ,=A(1024*1024)) Is This Page Empty?
            GOSUB FREPAGE                   ..Yes -> Free The Storage
         ENDIF ,
*
** Dispose of the Allocated Space VAS When We Didn't Merge
*        Allocated VAS is Now a Free VAS - Insert in Free Chain
*
         IF (CLI,DSAMERGE,EQ,C'N')     If We Didn't Merge?
            #TRACE MSG='We Did Not Merge'
            GOSUB SHOFREE
*
            XGR R5,R5                  Set Zero Prev
            LG  R6,VAKSTFRE            Get 1st Free Space Entry
            #TRACE MSG=('VASSTPTR: ',VASSTPTR),REGS=(R4,R6)
            IF (CLC,A.VASSTPTR,LT,VASSTPTR), If We're First?           *
               AND,(LTR,R6,R6,NZ)            ..And Not None
               MVC A.VASCHAIN,VAKSTFRE       ..Make It So
               STG R4,VAKSTFRE               ..(Same)
*
               #TRACE DATA=('1st On Chain',0(R4),VASLNGTH),REGS=(R4,R6)
               #TRACE DATA=('Nxt On Chain',0(R6),VASLNGTH)
            ELSE ,
             IF (LTR,R6,R6,NZ)
               IF (OC,VASCHAIN,VASCHAIN,Z) If Only 1 Entry on Chain?
                  STG R4,VASCHAIN             ..Point Last One At Us
                  MVC A.VASCHAIN,=AD(0)       ..We're Last
*
                  #TRACE DATA=('1 Lst On Chain',0(R6),VASLNGTH)
                  #TRACE DATA=('1 Alo On Chain',0(R4),VASLNGTH)
               ELSE ,
*                                  -*- Insert in The Middle
                  LGR R5,R6            Bump to Next Entry - Beginning
                  LG R6,VASCHAIN       (Same)
                  GOSUB INSERT         Insert AloVas Onto Free Chain
               ENDIF ,
             ELSE ,
                  STG R4,VAKSTFRE             ..We Are First On Chain
                  MVC A.VASCHAIN,=AD(0)       ..No Next
                  #TRACE DATA=('Only On Chain',0(R4),VASLNGTH)
             ENDIF ,
            ENDIF ,
         ENDIF ,
*
*temp    GOSUB SHOALOC
*temp    GOSUB SHOFREE
*
** Return to Caller
*
         SUBEXIT ,
*
*=====================================================================*
** INSERT - Insert Allocated VAS on Free Chain After Freemain         *
*=====================================================================*
*
INSERT   SUBNTRY REGS=(R4,R5,R6)
         LG R14,A.VASSTPTR             Get Addr End of AloVas
         A  R14,A.VASSTSIZ             (Same)
*
         DO WHILE=(LTR,R6,R6,NZ)       Loop Through Free Stor Chain
*
** Insert After Lesser Address Entry And Before Greater
*
            LG R15,S.VASSTPTR          Get End of Previous VAS
            A  R15,S.VASSTSIZ          S(ame)
*           *
            #TRACE REGS=(R15,R15)
            IF (CG,R15,LT,A.VASSTPTR),AND,  If Prev End LT Our Addr?   *e
               (CG,R14,LT,VASSTPTR)         ..And Our End LT Nxt Addr?
               MVC A.VASCHAIN,S.VASCHAIN    ..Insert Us Here
               STG R4,S.VASCHAIN            ..(Same)
*
               #TRACE DATA=('Prv On Chain',0(R5),VASLNGTH)
               #TRACE DATA=('Alo On Chain',0(R4),VASLNGTH)
               #TRACE DATA=('Nxt On Chain',0(R6),VASLNGTH)
               DOEXIT ,
            ENDIF ,
*
** Check If Inserting After Last Free Space Entry
*
            IF (OC,VASCHAIN,VASCHAIN,Z) If We're Last?
               STG R4,VASCHAIN                ..Point Last One At Us
               MVC A.VASCHAIN,=AD(0)          ..We're Last
*
               #TRACE DATA=('2 Lst On Chain',0(R6),VASLNGTH)
               #TRACE DATA=('2 Alo On Chain',0(R4),VASLNGTH)
               DOEXIT ,                       -> Done
            ENDIF ,
*
            LGR R5,R6                  Save Previous Entry
            LG  R6,VASCHAIN            Get Next Entry on Chain
         ENDDO ,
*
** Return to Caller
*
         SUBEXIT ,
         DROP A,S                      Drop Temmp Addressability
*
*=====================================================================*
** FREPAGE - Freemain Emptied the ATB Page - Free The Page            *
*=====================================================================*
*
FREPAGE  SUBNTRY
*
** Return to Caller
*
         SUBEXIT ,
*
*=====================================================================*
** SHOALOC - Show Allocated Chain for VAK                             *
*=====================================================================*
*
SHOALOC  SUBNTRY
         LG   R14,VAKSTALO             Get Head of Chain
         DO WHILE=(LTR,R14,R14,NZ)
            #TRACE DATA=('Alocated Storage Chain',0(R14),VASLNGTH),    *
               NOHEAD=YES
            LG R14,VASCHAIN-VASDSECT(,R14)
         ENDDO
*
** Return to Caller
*
         SUBEXIT ,
*
*=====================================================================*
** SHOFREE - Show Free Chain for VAK                                  *
*=====================================================================*
*
SHOFREE  SUBNTRY
         LG R14,VAKSTFRE               Get Head of Chain
         IF (LTR,R14,R14,NZ)
            LA R15,5
            DO FROM=(R15)
               #TRACE DATA=('Free Storage Chain',0(R14),VASLNGTH),     *
               NOHEAD=YES
               LG R14,VASCHAIN-VASDSECT(,R14)
            DOEXIT (LTR,R14,R14,Z)
            ENDDO
         ENDIF
*
** Return to Caller
*
         SUBEXIT ,
*
*=====================================================================*
** SUBR - Model Subroutine for Replication                            *
*=====================================================================*
*
SUBR     SUBNTRY
*
** Return to Caller
*
         SUBEXIT ,
*
***********************************************************************
** ABENDS Supported by this program.                                  *
***********************************************************************
*
ABEND008 DS    0H
         #WTO MSGID=RDH9001A,ROUTCDE=(11),                             *
               'Max ATB Getmains have been exceeded.  '
         ABEND 167,REASON=8         ...Terminate for Now
*
ABEND00C DS    0H
         #WTO MSGID=RDH9002A,ROUTCDE=(11),                             *
               'Attempt to obtain more than 1 meg of ATB storage.'
         ABEND 167,REASON=12        ...Terminate for Now
*
ABEND010 DS    0H
         #WTO MSGID=RDH9003A,ROUTCDE=(11),                             *
               'Attempt to freemain ATB storage not allocated.'
         ABEND 167,REASON=16        ...Terminate for Now
*
ABEND014 DS    0H
         #WTO MSGID=RDH9004A,ROUTCDE=(11),                             *
               'Freemain request not equal in length to getmain.'
         ABEND 167,REASON=16        ...Terminate for Now
*
***********************************************************************
* Define Literials and Constants                                      *
***********************************************************************
*
         CONBEG ,
*
** Equates
*
HEXFF    EQU   X'FF'                   Common Equates
HEX00    EQU   X'00'                   (Same)
*
** Constants
*
CONMAJOR DC    CL8'SYSATB'             Serialization Enqueue
CONMINOR DC    CL8'STORAGE'            (Same)
*
MDLRESM  RESMGR ADD,TYPE=ADDRSPC,      Define Model for RESMGR         *
               ROUTINE=(LINK,*-*),     (Same)                          *
               PARAM=*-*,              (Same)                          *
               TOKEN=*-*,MF=L          (Same)
MDLRESML EQU   *-MDLRESM               (Same)
*
HEXTAB   DC    C'0123456789ABCDEF'     Hex Conversion Table
*
         CONEND ,
*
***********************************************************************
* Define Dynamic Storage Area                                         *
***********************************************************************
*
         DSABEG ,                      Define DSA Prefix
*
DSAMERGE DS    C                       Merge indicator Y/N
DSAAB$RS DS    X                       ABEND Reason Code
*
DSAOPFLG DS    B                       Option Flags Bits 24-31 of R0
DSAOPFRE EQU   X'04'                   ..Call is for Freemain
DSAOPRC  EQU   X'02'                   ..Conditional Getmain Request
DSAOPKEY EQU   X'01'                   ..Key Specified on Macro
DSAOKEY  DS    X                       Key if Specified on Macro
*
DSAGADDR DS    AD                      Address of Area to Free
DSAGLNTH DS    A                       Length of Storage to Obtain
DSAGKEY  DS    X                       Storage Key to Obtain
*
DSARAREA DS    AD                      Address of Area Returned
*
DSAPSW1  DS    D                       Z/PSW
DSAPSW2  DS    D                       Z/PSW
*
DSAANTOK DS    D
DSAPAGCT DS    D
DSAANCOR DS    D
*
         DSAEND ,                      Define DSA Suffex
*
***********************************************************************
* Define Above-The-Bar Storage Area                                   *
***********************************************************************
*
         ATBBEG ,                      Define ATB Prefix
*
*
         ATBEND ,                      Define ATB Suffex
*
***********************************************************************
*                                                                     *
** RDHRESEX - Resource Manager Exit Routine                           *
*                                                                     *
*    This routine was needed to perform cleanup at End-Of-Task.  It's *
*  probably not really necessary, because the Above-The-Bar storage   *
*  that we acquire is task related and I expect the operating system  *
*  will happily do the cleanup for us.  However, if I choose to       *
*  support common storage above-the-bar it may be required.  Anyway,  *
*  it's here if I need it later.                                      *
*                                                                     *
***********************************************************************
*
         USING PSA,R0                  Establish Addressability
         USING VABDSECT,R9             VABDSCET Addressability
         USING VAADSECT,R8             VAADSCET Addressability
*
RDHVABEX PGMNTRY TYPE=MAIN,                                            *
               CBAS=(R12),             Define Constant Base            *
               ABAS=(R11),             Define ATB Base                 *
               AMODE=31,               Define Addressing Mode          *
               RMODE=ANY,              Define Residency Mode           *
               TRACE=NO,               Define Residency Mode           *
               ESTAE=YES               Define ESTAE Support
*
         MVC   DSARETRY,=A(RDHVABND)   If Error Just Exit
         L     R9,4(,R1)               Get Address of 8-Byte Param
         L     R9,4(,R9)               Get Address of VABDSECT
         MODESET MODE=SUP,KEY=ZERO
*
** RESMGR Exit Mainline
*
         GOSUB CLOS                    Close Up Shop and Free Storage
*
** Return to Caller
*
RDHVABND DS    0H
         PGMEXIT RC=8,                 Return to Caller                *
               RS=1                    ..Terminate RESMGR Exit
*
*=====================================================================*
** CLOS - Close Processing for ATB Storage For This Task              *
*=====================================================================*
*
CLOS     SUBNTRY ,
         RESMGR DELETE,TYPE=TASK,      Delete RESMGR Exit This Task    *
               ASID=CURRENT,           ..And This Address Space        *
               TOKEN=VABRESMT,         ..Token for DELETE              *
               MF=(E,VABRESM)          ..Point to List Form
*
** Free Storage For VAADSECT Area
*
         IARV64 REQUEST=DETACH,        Get Some ATB Storage            *
               MEMOBJSTART=VABANCOR,   ..Address of Storage to Free    *
               USERTKN=VABANTOK,       ..Indicate User Token This Pgm  *
               MF=(E,DSAV64)           ..Address of List Form
*
** Free Storage for TRCDSECT
*
         L     R0,VABLENTH             Length of VABDSECT Area
         STORAGE RELEASE,              Free Storage for VABDSECT       *
               ADDR=(R9),              (Same)                          *
               LENGTH=(0)              (Same)
*
** Return to Caller
*
CLOS999  DS    0H
         SUBEXIT ,
*
***********************************************************************
** Define Constant Area                                               *
***********************************************************************
*
         CONBEG ,
*
*
         CONEND ,
*
***********************************************************************
* Define Dynamic Storage Area                                         *
***********************************************************************
*
         DSABEG ,
*
         DSAEND ,
*
***********************************************************************
* Define Above-The-Bar Storage Area                                   *
***********************************************************************
*
         ATBBEG ,                      Define ATB Prefix
*
*
         ATBEND ,                      Define ATB Suffex
         END   ,
