***********************************************************************
* Copyright (c) 2009 - Richard D. Harper, All Rights Reserved         *
***********************************************************************
*                                                                     *
*   This file is part of Richard Harper's Private Development         *
* Platform (PDP).                                                     *
*                                                                     *
*   Richard Harper's PDP is free software: you can redistribute       *
* it and/or modify it under the terms of the GNU General Public       *
* License as published by the Free Software Foundation, either        *
* version 3 of the License, or (at your option) any later version.    *
*                                                                     *
*   Richard Harper's PDP is distributed in the hope that it will      *
* be useful, but WITHOUT ANY WARRANTY; without even the implied       *
* warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.    *
* See the GNU General Public License for more details.                *
*                                                                     *
*   You should have received a copy of the GNU General Public         *
* License along with Richard harper's PDP.  If not, see               *
* <http://www.gnu.org/licenses/>.                                     *
*                                                                     *
***********************************************************************
*
***********************************************************************
*                                                                     *
** RDHMSGS - Driver Program for #MSG/#WTO/#WTOR Macros                *
*                                                                     *
*    This program is entered via a BASR R14,R15 to process a message  *
*  described by MSGDSECT and write the output to a SYSOUT dataset,    *
*  which defaults to MSGPRINT or the console.                         *
*    The MSGDSECT data area is generated by the macros #MSG, #WTO or  *
*  #WTOR.  For details of the parameters available on these macros    *
*  please read the prolog within the macro.                           *
*                                                                     *
*  On Entry:                                                          *
*     R1  - Points to a MSGDSECT Data Area Built by #MSG/#WTO/#WTOR   *
*     R14 - Contains the Return Address                               *
*     R15 - Contains the Entry Point of this Program                  *
*                                                                     *
*                                                                     *
*  Date     FIX-ID Programmer Description                             *
*  ======== ====== ========== ======================================= *
*  02/25/09  M001  R. Harper  Module Developed                        *
*                                                                     *
*                                                                     *
***********************************************************************
*
*---------------------------------------------------------------------*
* Define MVS System Data Areas                                        *
*---------------------------------------------------------------------*
*
         PRINT NOGEN
*
         IHAPSA ,                      Define PSA Control Block
         CVT   DSECT=YES               CVT  Dsect
         IHASCVT ,                     SCVT Dsect
         IKJTCB ,                      Define TCB Control Block
         IHASTCB ,                     Define STCB Control Block
         DCBD   DSORG=PS               Define DCB Control Block
         IEZDEB LIST=YES               Define DEB Control Block
         IHACDE ,                      Define CDE Control Block
         IHASDWA ,                     Define CDE Control Block
         IEFTIOT1 ,                    Define TIOT Control Block
         IHAXTLST ,                    Define XTLST Control Block
JFCB     DSECT    ,                    Define JFCB Control Block
         IEFJFCBN ,                    (Same)
         IHAEXLST ,                    Define EXLST Data Area
*
*---------------------------------------------------------------------*
*                                                                     *
** RMEDSECT - DSECT Area for chain of Task Related RESMGR Exits       *
*                                                                     *
*    This DSECT is pointed to by STCBRMEF and is an Undocumented      *
*  IBM Data Area.  I found What I Needed.                             *
*                                                                     *
*---------------------------------------------------------------------*
*                                                                     *
RMEDSECT DSECT ,                       RME DSECT AREA
RMEID    DS    CL4'RME'                RME Identifier
         DS    F                       ..Unknown
RMEBCKPT DS    A                       ..Prev RME on Chain or Zero
RMEFWDPT DS    A                       ..Next RME on Chain or Zero
         DS    F                       ..Unknown
RMERESID DS    CL8                     ..Name of RESMGR Exit
         DS    2F                      ..Unknown
RMEPARAM DS    2CL4                    ..Parameter Passed to Exit
         DS    F                       ..Unknown
RMELNGTH EQU   *-RMEDSECT              Length of DSECT Area
         PRINT GEN
*
*---------------------------------------------------------------------*
* Define Our Own Internal Dsect Areas                                 *
*---------------------------------------------------------------------*
*
         LSEDSECT ,                    Define Linkage Stack DSECT
         MSGDSECT ,                    Define Message DSECT
*
MMGDSECT DSECT                         Dsect for #MSG Anchor
MMGEYECT DS    CL8'MMGDSECT'           Define Eye Catcher
MMGTCBAD DS    CL8                     TCB Address
MMGDDNAM DS    CL8                     DDNAME of SYSOUT Dataset
*
MMGPFLAG DS    B                       Processing Flag
MMGPDDSO EQU   X'80'                   ..MSGPRINT is SYSOUT
MMGPDDPS EQU   X'40'                   ..MSGPRINT is PS
MMGPDDPO EQU   X'20'                   ..MSGPRINT is PO
*
         DS    0D
MMGDCB   DS    XL(MDLDCBL)             Reserve Space for DCB
MMGDCBID DS    CL4                     DCB Identifier
*
         DS   0D                       End on Doubleword
MMGLNGTH EQU   *-MMGDSECT              Length of DSECT Area
*
***********************************************************************
* RDHMSGS - Program Main Entry Point                                  *
***********************************************************************
*
         USING PSA,R0                  Define PCA Addressability
         USING MSGDSECT,R10            Define MSG Addressability
*
RDHMSGS  PGMNTRY BASE=(R12,R11),       Define Program Entry Code       *
               AMODE=31,               Define Addressing Mode          *
               RMODE=ANY,PRINT=GEN,    Define Residency Mode           *
               TYPE=MAIN,              Define As Main Program for DSA  *
               ESTAE=YES,              Define ESTAE Recovery Support   *
               TRACE=NO ,IMP=BASR
*
         LR    R10,R1                  Point at MSGDSECT Area
         IF (TM,MSGFLAG1,MSG1CLOS,O)   If CLOSE Requested?
            GOSUB CLOSE                ...Do CLOSE Processing
         ELSE ,                        Else
            IF (TM,MSGFLAG1,MSG1MSG,O) If #MSG Macro?
               GOSUB PMSG              ...Process a #MSG Macro
            ELSE ,                     Else
               IF (TM,MSGFLAG1,MSG1WTO,O) If #WTO Macro?
                  GOSUB PWTO           ...Process a #WTO Macro
               ELSE ,
                  GOSUB PWTR           ...Process a #WTOR Macro
               ENDIF ,
            ENDIF ,
         ENDIF ,
*
** Return to Caller
*
MSGRETRY DS    0H
         PGMEXIT RC=0                  Define Program Exit Code
*
*---------------------------------------------------------------------*
* PMSG - Process a #MSG Construct                                     *
*---------------------------------------------------------------------*
*
** #MSG requires a SYSOUT dataset, which means we have to open and
*       close that dataset.  This means we need an anchor to place
*       the DCB for the dataset and a task related Resource Manager
*       Exit routine to close that dataset at task termination.
*
PMSG     SUBNTRY ,
         BAS R14,LDCB                  Find MMGDSECT if its There
         #TRACE REGS=(R9),MSG='MMGDSECT=R9'
         USING MMGDSECT,R9             #MSG Persistant Data Area
         IF (LTR,R9,R9,Z)              If Not Already Open
            GOSUB OPEN                 ...Open The SYSOUT Dataset
         ENDIF ,
         #TRACE REGS=(R9),MSG='MMGDSECT=R9'
*
         GOSUB BUILD                   Build Message to Write in DSA
*
         LA R2,MMGDCB                  Get Address of DCB
         PUT (R2),DSAPLINE             Write Message to SYSOUT
*
** Return to Caller
*
PMSG999  DS    0H
         SUBEXIT ,
*
*---------------------------------------------------------------------*
* PWTO - Process a #WTO Construct                                     *
*---------------------------------------------------------------------*
*
PWTO     SUBNTRY ,
         GOSUB BUILD                   Build Message to Write in DSA
*
** Print WTO to Console
*
         LA R2,DSAPLINE+L'DSAPLINE-1   Point at Last Char
         DO WHILE=(CLI,0(R2),EQ,C' ')  Loop to Last Char
            AHI R2,-1                  Decrement
         ENDDO
         LA R2,1(,R2)                  Point Past Last Byte
*
         LA    R3,DSAPLINE             Get Length of Message
         SR    R2,R3                   (Same)
         LA    R2,4(,R2)               Add Prefix Length
         STH   R2,DSAWLEN              Save Messave Length
         MVC   DSAWRCDE,MSGWRCDE       Set Route Codes
*
** Set Return Address
*
         IF (CLC,MSGWRADR,NE,=Y(0))    If Return Area Specified?
            XR  R14,R14                Zero Work Register
            XR  R15,R15                (Same)
            ICM R14,B'0011',MSGWRADR   Get SCON Address of Data
            SRDL R14,12                Seperate B and DDD
            SRL R15,20                 (Same)
            SLL R14,3                  Base Times 8
            LG  R14,DSAREGS(R14)       Lift The Proper Base Reg
            ALR R14,R15                Add Base and Displacement
            ST  R14,DSARADDR           Set Reply Address
         ENDIF ,
*
** Write WTOR to Console
*
         #TRACE DATA=('WTO Print Line',DSAWLINE,132)
*
         L  R14,DSARADDR               Set Reply Address
         IF (CLC,MSGWRADR,NE,=Y(0))    If Return Area Specified?
            MVC 0(128,R14),DSAPLINE    Return Data to Callers Area
         ELSE ,
            LA R1,DSAWLINE             Point at WTO Line Built
            SVC 35                     Issue WTO
         ENDIF ,
*
** Return to Caller
*
PWTO999  DS    0H
         SUBEXIT ,
*
*---------------------------------------------------------------------*
* PWTR _ Process a #WTOR Construct                                    *
*---------------------------------------------------------------------*
*
PWTR     SUBNTRY ,
         GOSUB BUILD                   Build Message to Write in DSA
*
** Write WTOR to Console
*
         LA R2,DSAPLINE+L'DSAPLINE-1   Point at Last Char
         DO WHILE=(CLI,0(R2),EQ,C' ')  Loop to Last Char
            AHI R2,-1                  Decrement
         ENDDO
         LA R2,1(,R2)                  Point Past Last Byte
*
         LA    R3,DSAPLINE             Get Length of Message
         SR    R2,R3                   (Same)
         LA    R2,4(,R2)               Add Prefix Length
         STH   R2,DSAWLEN              Save Messave Length
         MVC   DSAWLEN(1),MSGWRLEN+1   Set Reply Length
*
** Set ECB Address
*
         XR  R14,R14                   Zero Work Register
         XR  R15,R15                   (Same)
         ICM R14,B'0011',MSGWRECB      Get SCON Address of Data
         SRDL R14,12                   Seperate B and DDD
         SRL R15,20                    (Same)
         SLL R14,3                     Base Times 8
         LG  R14,DSAREGS(R14)          Lift The Proper Base Reg
         ALR R14,R15                   Add Base and Displacement
         ST  R14,DSARECBA              Set ECB Address
*
** Set Reply Address
*
         XR  R14,R14                   Zero Work Register
         XR  R15,R15                   (Same)
         ICM R14,B'0011',MSGWRADR      Get SCON Address of Data
         SRDL R14,12                   Seperate B and DDD
         SRL R15,20                    (Same)
         SLL R14,3                     Base Times 8
         LG  R14,DSAREGS(R14)          Lift The Proper Base Reg
         ALR R14,R15                   Add Base and Displacement
         ST  R14,DSARADDR              Set Reply Address
         OI  DSARADDR,DSARWTOR         Indicate WTOR
*
 #TRACE DATA=('WTOR Print Line',DSARLINE,140)
*
** Write WTOR to Console
*
         LA R1,DSARLINE                Point at WTO Line Built
         SVC 35                        Issue WTO
*
** Return to Caller
*
PWTR999  DS    0H
         SUBEXIT ,
*
*---------------------------------------------------------------------*
*                                                                     *
** OPEN - Do Open Processing for #MSG Macro                           *
*                                                                     *
*    Since the #MSG Macro requires a persistent storage area for      *
*  the DCB it is necessary to open that DCB on the initial call and   *
*  provide a place to locate that persistent storage area on each     *
*  subsequent call.                                                   *
*    Since we want to remain able to operate in Key 8, we cannot use  *
*  a Resource manager Exit here.  Under most circumstances that is    *
*  not a problem because the operating System will write the final    *
*  buffers, close the datasets and free our storage for us.           *
*    However, there may be some situations where we want to close     *
*  these datasets.  So, close processing can be invokes by issueing   *
*  #MSG CLOSE macro.                                                  *
*                                                                     *
*---------------------------------------------------------------------*
*
OPEN     SUBNTRY ,
*
** Get Storage for MMGDSECT Persistant Storage or DSA for This TCB
*
         STORAGE OBTAIN,               Obtain Storage for MMG          *
               LENGTH=4096,            (Same)                          *
               LOC=(24,31),BNDRY=PAGE  (Same) - Below The Line
*
         LR    R9,R1                   Get Address of MMGDSECT
         MVC   MMGEYECT,=C'MMGDSECT'   Place Eye Catcher
         MVC   MMGDDNAM,MSGDDNAM       Set DD Name in DSECT Area
         MVC   MMGTCBAD,PSATOLD        Save TCB Address
*
** Read in JFCB for DDNAME
*
         LA R1,DSAJFCB                 Build Exit List
         ST R1,DSAEXLST                (Same)
         OI DSAEXLST,EXLLASTE+EXLRJFCB (Same)
*
         LA R1,MMGDCB                  Build RDJFCB MF=L
         USING IHADCB,R1               And Temp Addressability
         MVC MMGDCB,MDLDCB             Move DCB to Common
         MVC DCBDDNAM,MSGDDNAM   '     Set DDNAME in DCB
         LA R14,DSAEXLST               Put EXLST Address in DCB
         ST R14,DCBEXLST               (Same)
*
         OI DSARJFCL,X'80'             Set Option Byte
         RDJFCB (MMGDCB),              Load JFCB for Dataset           *
               MF=(E,DSARJFCL)         (Same)
         IF (LTR,R15,R15,NZ)           If RDJFCB Failed
            EX 0,*                      ..Terminate
            DC C'RDHT0001 RDJFCB for MSGPRINT has Failed.',0H
         ENDIF
*
** Extract Data From JFCB
*
         LA R2,DSAJFCB                 Load JSCB Address
         USING JFCB,R2                 Setup Addressability
         IF (TM,JFCBTSDM,JFCSDS,O)     If This is a SYSOUT Dataset
            OI MMGPFLAG,MMGPDDSO       ...Indicate SYSOUT
         ELSE ,
            IF (TM,JFCBIND1,JFCPDS,O)  If This is a PDS
               OI MMGPFLAG,MMGPDDPO    ...Indicate PDS
            ELSE ,                     Else
               OI MMGPFLAG,MMGPDDPS    ...Indicate PS
            ENDIF
         ENDIF
         DROP R2
*
** Open Message Sysout DCB - Default(MSGPRINT)
*
         LA  R1,MMGDCB                 Get DCB Address
         USING IHADCB,R1               And Temp Addressability
         MVC MMGDCB,MDLDCB             Move DCB to Common
         MVC MMGDCBID,=C'RDHM'         Set DCB Identifier
         MVC DCBDDNAM,MSGDDNAM         Set DDNAME in DCB
         MVC DSAOPL,MDLOPL             Move Open Parm to Common
         OPEN  (MMGDCB,(OUTPUT)),      Open Sysout Dataset             *
               MF=(E,DSAOPL)            (Same)
*
         LA R1,MMGDCB                  Get DCB Address
         IF (TM,DCBOFLGS,DCBOFOPN,Z)   If Open Failed...
            #SUICIDE MSG='RDHM0001 Open failure for message Dataset.'
         ENDIF
*
         #TRACE DATA=('MMGDSECT Area Obtained',0(R9),MMGLNGTH)
*
** Return to Caller
*
OPEN999  DS    0H
         SUBEXIT ,
         DROP R1                       Drop Temp Addressability
*
*---------------------------------------------------------------------*
*                                                                     *
** CLOSE - Close All Open SYSOUT Datasets and Free Storage            *
*                                                                     *
*---------------------------------------------------------------------*
*
CLOSE    SUBNTRY ,
         DO UNTIL=(LTR,R9,R9,Z)        Find All Open Datasets
            GOSUB LDCB                 Get Next SYSOUT Dataset
            IF (LTR,R9,R9,NZ)          If We Found one?
               GOSUB CMMG              Do Cleanup Processing
            ENDIF ,
         ENDDO ,
*
** Return to Caller
*
CLOSE99  DS    0H
         SUBEXIT ,
*
*---------------------------------------------------------------------*
*                                                                     *
** CMMG - Close the SYSOUT Dataset and do cleanup for this task       *
*                                                                     *
*    Close processing is done within the RESMGR exit to close         *
*  the trace output dataset and freemain the storage for MMGDSECT.    *
*                                                                     *
*---------------------------------------------------------------------*
*
CMMG     SUBNTRY ,
*
** Close Open Dataset For This Task
*
         MVC DSACLL,MDLCLL             Move Close Parm to Common
         CLOSE (MMGDCB),               Close Sysout Dataset            *
               MF=(E,DSACLL)            (Same)
*
** Free Storage for MMGDSECT
*
         STORAGE RELEASE,              Free Storage for MMGDSECT       *
               ADDR=(R9),              (Same)                          *
               LENGTH=4096             (Same)
*
** Return to Caller
*
CMMG999  DS    0H
         SUBEXIT ,
*
*---------------------------------------------------------------------*
*                                                                     *
** BUILD - Build the Message Text in DSAPLINE                         *
*                                                                     *
*---------------------------------------------------------------------*
*
BUILD    SUBNTRY ,
*
** Get Callers Registers From Stack
*
         PUSH  USING                         Save Current USING Status
         EREGG R0,R7                         Get First Half
         STMG  R0,R7,DSAREGS                 (Same)
         STMG  R9,R13,DSASAVE5               Save Base Registers
         DROP  ,                             Drop All Bases
*
         LR    R2,R13                        Setup Temp Addressability
         USING RDHMSGS_DSA,R2                (Same)
         EREGG R8,R15                        Get Second Half
         STMG  R8,R15,DSAREGS+64             (Same)
         LMG   R9,R13,DSASAVE5               Restore Bases
         DROP  R2                            Drop temp Addressability
         POP   USING                         Load Previous USING Status
*
** Go Build The Message in MMGDSECT
*
         GOSUB MSGS                     Process the Message
*
** Return to Caller
*
BUILD999 DS    0H
         SUBEXIT ,
*
*---------------------------------------------------------------------*
*                                                                     *
** MSGS - Build The Message Requested by This Trap                    *
*                                                                     *
*    This routine will format the message data, which consists as a   *
*  sublist intermixed with both text data and variable data.  The     *
*  variable data will be converted to printable form based upon the   *
*  T' type for that variable.  Some examples are:                     *
*                                                                     *
*         'This is a message'                                         *
*         ('The ',COLOR,',HARE,' is ',HEIGHT,' ft. tall.'             *
*         ('Show savearea at: ',DSASAVEA)                             *
*                                                                     *
*  COLOR  DC C'BLUE'                                                  *
*  HEIGHT DC H'5'                                                     *
*                                                                     *
*    The primary input for this routine is the MSGDSECT area.         *
*                                                                     *
*                                                                     *
*---------------------------------------------------------------------*
*
MSGS     SUBNTRY ,
         MVI DSAMSGWK,C' '             Space Fill Work Area
         MVC DSAMSGWK+1(L'DSAMSGWK-1),DSAMSGWK
         MVI DSAPLINE,C' '             Space Fill Print Line
         MVC DSAPLINE+1(L'DSAPLINE-1),DSAPLINE
*
         LA  R2,DSAMSGWK               Init Current Output Position
         MVI DSAMSGWK,C' '             Space Fill Area
         MVC 1(L'DSAMSGWK-1,R2),0(R2)  (Same)
         LA  R3,MSGMSG                 Point at Pre-formated Message
         XR  R4,R4                     Zero Work Register
         ICM R4,B'0011',MSGMLNTH       Get Length of Message
         LA  R3,2(,R3)                 Point Past Length at Message
         AHI R4,-2
*
** Process MSGID= Value if Present
*
         IF (TM,MSGFLAG1,MSG1MID,Z)    If MSDID is Present?
            MVC DSAMSGWK(8),MSGID      Set Message ID in Output Area
            LA  R2,9(,R2)              Point Past Message ID
         ENDIF ,
*
** Loop Through Message and Build Text
*
         DO FROM=(R4)                  Loop For Count in Message
            IF (CLI,0(R3),EQ,MSGEVVAR) Do We Have A Variable?
               IF (CH,R4,LE,=H'0')     If VAR is Last Thing?
                  DOEXIT ,
               ENDIF ,
               BAS R14,FVAR            Format Variable for Printing
            ELSE ,                 -*- Move Message Text
               MVC 0(1,R2),0(R3)       Move a Byte
               LA  R2,1(,R2)           Bump Output Pointer
               LA  R3,1(,R3)           Bump Input Pointer
            ENDIF ,
            LA R14,DSAMSGWK+L'DSAMSGWK-1 Get End of Buffer
            IF (CR,R14,NH,R2),OR,      Have We Move to End?            *
               (LTR,R4,R4,Z)           (Same)
               DOEXIT ,                Yes -> Quit
            ENDIF ,
         ENDDO ,                       -> Loop (BCT)
*
         IF (TM,MSGFLAG1,MSG1SQEZ,NZ)     Sqeeze Buffer?
            SQUEEZE BEG=DSAMSGWK,         Remove Double Blanks         *
               END=DSAMSGWK+L'DSAMSGWK-1,MF=E
         ENDIF ,
*
         MVC   DSAPLINE,DSAMSGWK       Move to Print Area
*
** Return to Caller
*
MSGS999  DS    0H
         SUBEXIT ,
*
*---------------------------------------------------------------------*
*                                                                     *
** FVAR - Format a MSG= Variable for Printing                         *
*                                                                     *
*    This routine takes in the address of the current variable        *
*  defination from the input MSG= data and formats that data          *
*  according to the data type.  This formated data is passed back     *
*  to the caller in the current position within DSAMSGWK, with the    *
*  current positions of from and to data bumped appropriately and     *
*  the current length drecemented.                                    *
*                                                                     *
*    Inputs:                                                          *
*            R2 = Output Pointer, Current Position in DSAMSGWK        *
*            R3 = Input  Pointer, Current Position in MSGMSG          *
*                 This will also be the pointer to the MSGEVAR entry  *
*                 to process.                                         *
*            R4 = Residual length of total MSG= data.                 *
*                                                                     *
*---------------------------------------------------------------------*
*
         USING MSGEVAR,R3              Establish Temp Addressability
*
FVAR     SUBNTRY ,
         XR  R14,R14                   Zero Work Register
         XR  R15,R15                   (Same)
         ICM R14,B'0011',MSGESCON      Get SCON Address of Data
         SRDL R14,12                   Seperate B and DDD
         SRL R15,20                    (Same)
         SLL R14,3                     Base Times 8
*
         LG  R14,DSAREGS(R14)          Lift The Proper Base Reg
         ALR R14,R15                   Add Base and Displacement
         XR  R15,R15                   Zero Work Register
         IC  R15,MSGEDLEN              Get Length of Data
*
         MVC  DSARETRY,=A(FVARRTY)     Set Retry Routine
         IF (CLI,MSGETYP,EQ,C'C')  -*- For Character Data
            BCTR R15,0                 Decrement for Assembler
            MVC 0(*-*,R2),0(R14)       Move Data to Print Line
            EX  R15,*-6                (Same)
            LA  R2,1(R15,R2)           Point Past Data
            LA  R3,MSGESLEN(,R3)       Point Past Var Entry
            SH  R4,=Y(MSGESLEN-1)      Decrement Count
         ENDIF ,
*
         IF (CLI,MSGETYP,EQ,C'Z')  -*- For Zoned Decimal
            BCTR R15,0                 Decrement for Assembler
            MVC 0(*-*,R2),0(R14)       Move Data to Print Line
            EX R15,*-6                 (Same)
            LA R2,0(R15,R2)            Point Past Data
            OI 0(R2),X'F0'             Set Sign in Last Byte
            LA R2,1(,R2)               Point to next Blank
            LA R3,MSGESLEN(,R3)        Point Past Var Entry
            SH R4,=Y(MSGESLEN-1)       Decrement Count
         ENDIF ,
*
         IF (CLI,MSGETYP,EQ,C'F')  -*- For Fullword Data
            ICM R15,B'1111',0(R14)     Get Data to Print
            CVD R15,MMGWORKD           Get Data in Decimal
            MVC DSAWORKC,CONECON       Set ED Constant
            ED  DSAWORKC,MMGWORKD      Get Character Numbers
            MVC 0(L'CONECON,R2),DSAWORKC
            LA  R2,L'CONECON(,R2)      Bump Output Pointer
            LA  R3,MSGESLEN(,R3)       Point Past Var Entry
            SH  R4,=Y(MSGESLEN-1)      Decrement Count
         ENDIF ,
*
         IF (CLI,MSGETYP,EQ,C'H')  -*- For Fullword Data
               XR  R15,R15             Zero Work Register
               ICM R15,B'0011',0(R14)  Get Data to Print
               CVD R15,MMGWORKD        Get Data in Decimal
               MVC DSAWORKC,CONECON    Set ED Constant
               ED  DSAWORKC,MMGWORKD   Get Character Numbers
               MVC 0(L'CONECON,R2),DSAWORKC
               LA  R2,L'CONECON(,R2)   Bump Output Pointer
               LA  R3,MSGESLEN(,R3)    Point Past Var Entry
               SH  R4,=Y(MSGESLEN-1)   Decrement Count
         ENDIF ,
*
         IF (CLI,MSGETYP,EQ,C'P')  -*- For Packed Decimal
            BCTR R15,0                 Decrement for Assembler
            O  R15,=A(X'70')           Set Length of To Field
            EX R15,FVARZAP             Zap Data into MMGWORKD
            MVC DSAWORKC,CONECON       Set ED Constant
            ED  DSAWORKC,MMGWORKD      Get Character Numbers
            MVC 0(L'CONECON,R2),DSAWORKC
            LA  R2,L'CONECON(,R2)      Bump Output Pointer
            LA  R3,MSGESLEN(,R3)       Point Past Var Entry
            SH  R4,=Y(MSGESLEN-1)      Decrement Count
         ENDIF ,
*
         IF (CLI,MSGETYP,EQ,C'X')  -*- For Hexidecimal
            N   R15,=A(X'0F')          Allow Max 16-Bytes
            LR  R5,R15                 Get Output Length
            SLL R5,1                   (Same)
            MVC DSAWORKX,=32C' '       Space Fill Result
            LA R1,DSAWORKX             Get Output Location
            XC MMGWORKD,MMGWORKD       Zero Fill Work Area
            DO FROM=(R15)              Loop All Digits to Translate
               UNPK MMGWORKD(3),0(2,R14)    Unpack a Byte
               TR  MMGWORKD(2),HEXTABL-240  In Char Format
               MVC 0(2,R1),MMGWORKD         Put Output
               LA  R14,1(,R14)              Bump Input Ptr
               LA  R1,2(,R1)                Bump Output Ptr
            ENDDO ,
            MVC 0(L'DSAWORKX,R2),DSAWORKX
            LA R2,0(R5,R2)             Bump Output Pointer
            LA R3,MSGESLEN(,R3)        Point Past Var Entry
            SH R4,=Y(MSGESLEN-1)       Decrement Count
         ENDIF ,
FVARRTY  DS    0H
         XC    DSARETRY,DSARETRY       Set for no Retry
*
FVAR999  DS    0H
         SUBEXIT ,
*
FVARZAP  ZAP   MMGWORKD(*-*),0(R14)    Executed Instruction
*
*---------------------------------------------------------------------*
*                                                                     *
** LDCB - Locate Our Open DCB by running the DEB Chain off the TCB    *
*                                                                     *
*   This routine will loop through the DEB chain off the current TCB  *
* looking for an open DCB that belong to this Tracing Facility.  If   *
* found it will locate the address of the TRC Persistant Data Area,   *
* within which the DCB resides, and return that address in R9.        *
*                                                                     *
** Note: This routine is no longer executed.  It is left here for     *
*        reference purposes only.  It has been replaced with LTRC     *
*        which provides a better means of locating the TRCDSECT area  *
*        for the current task.                                        *
*                                                                     *
*---------------------------------------------------------------------*
*
         USING DEBBASIC,R1             ..And Addressability
         USING IHADCB,R2               Get DCB Addressability
         USING TCB,R14                 ..And Addressability
*
LDCB     SUBNTRY ,
         XR R9,R9                      Zero Innitial Pointer
         XR R1,R1                      Zero Work Register
         XR R2,R2                      (Same)
         L  R14,PSATOLD                Load Our TCB Address
*
         IF (ICM,R1,7,TCBDEB+1,NZ)     Get Address of 1st DEB?
            DO WHILE=(LTR,R1,R1,NZ)    Loop Thru DEB Chain
               ICM R2,B'0111',DEBECBB  Load DCB Address
*
               LA R3,MMGDCBID-MMGDCB(,R2)   Get Addr of Idetifier
            #TRACE REGS=(R1,R2,R3),DATA=('DCB Addr',0(R2),128)
               IF (CLC,=C'RDHM',EQ,0(R3))   Is This Our DCB?
            #TRACE 'FOUND DCB'
                  LR R9,R2                  Get Address of MMGDSECT
                  SH R9,=Y(MMGDCB-MMGDSECT) Get MMGDSECT Address
                  IF (TM,MSGFLAG1,MSG1CLOS,Z)   If Not CLOSE Request?
                     IF (CLC,MSGDDNAM,EQ,MMGDDNAM) If For This DD?
                        DOEXIT ,              ..And Exit
                     ELSE ,
                        XR R9,R9              ..Still Not Found
                     ENDIF
                  ENDIF
               ENDIF
*
               ICM R1,B'0111',DEBDEBB  Get Next DEB on Chain
            ENDDO
         ENDIF
 #TRACE REGS=(R9)
*
** Exit LDCB
*
LDCB999  DS    0H
         SUBEXIT ,
         DROP  R1,R2                   Drop Temp Addressability
*
***********************************************************************
*  Literials and Constants
***********************************************************************
*
         CONBEG ,                      Define literal Pool
*
HEXTABL  DC    C'0123456789ABCDEF'     Hex Translate Table
*
MDLRDJSC RDJFCB (*-*),MF=L             Define model for RDJFCB
MDLRDJSL EQU  *-MDLRDJSC               (Same)
*
MDLOPL   OPEN  (*-*,(OUTPUT)),MF=L     Define Model for OPEN
MDLOPLL  EQU   *-MDLOPL                (Same)
*
MDLCLL   CLOSE (*-*),MF=L
MDLCLLL  EQU   *-MDLCLL
*
MDLDCB   DCB   DDNAME=MSGPRINT,        Define Trace DCB                *
               LRECL=128,BLKSIZE=1280, (Same)                          *
               RECFM=FB,DSORG=PS,      (Same)                          *
               MACRF=PM,EXLST=*-*      (Same)
MDLDCBL  EQU   *-MDLDCB                (Same)
*
MDLRESM  RESMGR ADD,TYPE=ADDRSPC,      Define Model for RESMGR         *
               ROUTINE=(LINK,*-*),     (Same)                          *
               PARAM=*-*,              (Same)                          *
               TOKEN=*-*,MF=L          (Same)
MDLRESML EQU   *-MDLRESM               (Same)
*
CONECON  DC    X'402020206B2020206B2020206B2020206B202120'
*                    12345678901234567890123456789012345678901234567890
*              23456789012345678901234567890123456789012345678901234567
*              90123456789012345678
CONTITLE DC    CL128'00/00/00         SYS00000 - Label Level Tracing - *
               TCB: 00000000'
CONABEND DC    CL128'    ***> An abend occured while attempting to acce*
               ss this data.'
CONHEAD1 DC    CL128'    Address Offset'
CONHEAD2 DC    0CL128
         DC    CL4' ',72C'=',CL52' '
*
         DS    0D
TRTABL   DS    256C'.'                 Translate Table
         ORG   TRTABL+C'A'
         DC    C'ABCDEFGHI'
         ORG   TRTABL+C'J'
         DC    C'JKLMNOPQR'
         ORG   TRTABL+C'S'
         DC    C'STUVWXYZ'
         ORG   TRTABL+C'a'
         DC    C'abcdefghi'
         ORG   TRTABL+C'j'
         DC    C'jklnmopqr'
         ORG   TRTABL+C's'
         DC    C'stuvwxyz'
         ORG   TRTABL+C'0'
         DC    C'0123456789'
         ORG   TRTABL+C'@'
         DC    C'@'
         ORG   TRTABL+C'#'
         DC    C'#'
         ORG   TRTABL+C'$'
         DC    C'$'
         ORG   TRTABL+C','
         DC    C','
         ORG   ,
*
         CONEND ,
*
***********************************************************************
* Define Dynamic Storage Area - DSA
***********************************************************************
*
         DSABEG ,                 <*** Begin Dynamic Storage Area
*
         DS    0D
DSARESM  DS    XL(MDLRESML)            Reserve Space for RESMGR
*
DSASAVE5 DS    5D                      Save Base Registers
*
DSAESTAE DS    F            <Keep    > Address of Recovery RTN or Zero
DSAEACNT DS    F            <Together> Count of Abends
*
DSARJFCL DS    F                       Reserve Space for RDJFCB MF=L
DSAEXLST DS    F                       Space for DCB EXLST
DSAJFCB  DS    0D,CL176                Reserve Space for JFCB
*
         DS    0D
DSAOPL   DS    XL(MDLOPLL)             Reserve Space for OPEN Parm
         DS    0D
DSACLL   DS    XL(MDLCLLL)             Reserve Space for CLOSE Parm
*
DSAREGS  DS    16D                     Callers Registers R0-R15
*
DSARLINE DS    0D                      WTOR Print Area
DSARADDR DS    A                       Reply Address
DSARWTOR EQU   X'80'                   High Bit Means WTOR
DSARECBA DS    A                       ECB Address
DSAWLINE DS    0D                      WTO Print Area
DSAWLEN  DS    H                       Length of WTO
DSAWRCDE DS    2B                      Route Codes
DSAPLINE DS    CL128                   Print Line
DSAPNT   DS    0CL80
DSAMSGWK DS    CL255                   MSG= Work Area
*
MMGWORKD DS    D                       General Purpose Workarea
DSAWORKC DS    XL20                    (Same)
DSAWORKX DS    XL32                    (Same)
*
         SQUEEZE MF=L                  Get Data Areas for SQUEEZE
*
         DSAEND ,                 <*** End Dynamic Storage Area
         DROP ,                        Drop Everything
         END ,
