***********************************************************************
* Copyright (c) 2006 - Richard D. Harper, All Rights Reserved         *
***********************************************************************
*                                                                     *
*   This file is part of Richard Harper's Private Development         *
* Platform (PDP).                                                     *
*                                                                     *
*   Richard Harper's PDP is free software: you can redistribute       *
* it and/or modify it under the terms of the GNU General Public       *
* License as published by the Free Software Foundation, either        *
* version 3 of the License, or (at your option) any later version.    *
*                                                                     *
*   Richard Harper's PDP is distributed in the hope that it will      *
* be useful, but WITHOUT ANY WARRANTY; without even the implied       *
* warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.    *
* See the GNU General Public License for more details.                *
*                                                                     *
*   You should have received a copy of the GNU General Public         *
* License along with Richard harper's PDP.  If not, see               *
* <http://www.gnu.org/licenses/>.                                     *
*                                                                     *
***********************************************************************
*
***********************************************************************
*                                                                     *
** RDHTRACE - Program Tracing Facility for the #TRACE Macro           *
*                                                                     *
*    This program is the BASR implementation of the tracing facility. *
*  It is entered via a BASR R14,R15 generated by the #TRACE macro in  *
*  the callers code.  There are many potential operands in the #TRACE *
*  macro, and you can look at the Porlog there for a description of   *
*  all.  I'm just going to describe here the main four that will      *
*  most often be used.                                                *
*                                                                     *
*                                                                     *
*     &TYPE = PGME  - Call Generated on Program Entry                 *
*             PGMX  - Call Generated on Program Exit                  *
*             SUBE  - Call Generated on Subroutine Entry              *
*             SUBX  - Call Generated on Subroutine Exit               *
*             TRAP  - Indicate a Trace Point Trap                     *
*                                                                     *
*     &REGS = A sublist of register values that indicate the          *
*             registers to be printed when this trap point is         *
*             executed.  They may be specifies as the values          *
*             0 through 15, or R0 through R15.                        *
*             (e.g. REGS=(0,3,5,R12,R14,R15) or REGS=ALL or           *
*             REGS=NONE)                                              *
*                                                                     *
*      &MSG = Specifies a message to be printed allowinf for          *
*             embedded variables in a sublisted string.  Variable     *
*             data will be printed according to the type of           *
*             variable.  Types C and Z are printes in character       *
*             format.  Types F, H and P are printed in decimal        *
*             format.  Everything else is printed in hex format.      *
*               MSG='This is a message'                               *
*               MSG=('The ',COLOR,' HARE ' is ',HEIGHT,' ft. tall.'   *
*               MSG=('Show savearea at: ',DSASAVEA)                   *
*                                                                     *
*     &DATA = Specifies an area in storage that is to be displayed    *
*             in hex dump format. An optional title may be specified  *
*             to identify the area being displayed.  The areas to be  *
*             displayed must be specified as a sublist within a       *
*             sublist.                                                *
*               DATA=('My DSA Area',0(R13),DSALNGTH)                  *
*               DATA=(('Previous SA in Chain',0(R6),SALNGTH),         *
*                     ('Next SA in Chain,',0(R5),(R2))                *
*                                                                     *
*  Restrictions:                                                      *
*       For BASR Implementation, this program must be entered in      *
*     Supervisor State.                                               *
*       For TRAP2 Implementation, no SVCs can be executed while       *
*     processing a Trace Trap Point, as we may be in cross memory     *
*     mode, or SRB mode.                                              *
*                                                                     *
*                                                                     *
*  On Entry:                                                          *
*     R1  - Points to a fullword address of TRPDSECT which contains   *
*           additional specific information about the trace point.    *
*     R14 - Contains the Return Address                               *
*     R15 - Contains the Entry Point of this Program                  *
*                                                                     *
*                                                                     *
*  Date     FIX-ID Programmer Description                             *
*  ======== ====== ========== ======================================= *
*  02/02/06  M001  R. Harper  Module Developed                        *
*  10/04/07  M002  R. Harper  Added Support for EX Tracepoints        *
*                                                                     *
*                                                                     *
***********************************************************************
*
*---------------------------------------------------------------------*
* Define MVS System Data Areas                                        *
*---------------------------------------------------------------------*
*
         PRINT NOGEN
         COPY  PGMGBLAS
*
         IHAPSA ,                      Define PSA Control Block
         IKJTCB ,                      Define TCB Control Block
         IHASTCB ,                     Define STCB Control Block
         DCBD   DSORG=PS               Define DCB Control Block
         IEZDEB LIST=YES               Define DEB Control Block
         IHACDE ,                      Define CDE Control Block
         IHASCB ,                      Define SCB Control Block
         IHASDWA ,                     Define CDE Control Block
SDWLEN   EQU   SDWAEND-SDWA            Get Me The Length
         IEFTIOT1 ,                    Define TIOT Control Block
         IHAXTLST ,                    Define XTLST Control Block
JFCB     DSECT    ,                    Define JFCB Control Block
         IEFJFCBN ,                    (Same)
         IHAEXLST ,                    Define EXLST Data Area
         CVT   DSECT=YES
         IHASCVT ,
*
*---------------------------------------------------------------------*
* Define Internal RDHTRACE Data Areas                                 *
*---------------------------------------------------------------------*
*
         PRINT GEN
         RMEDSECT ,                    Define RMEDSECT Area
         LSEDSECT ,                    Define Linkage Stack Entry
         TRCDSECT ,                    Define TRCDSECT Data Area
         TRPDSECT ,                    Define Trap Data Areas
         TRGDSECT ,                    Define Trap Glue Data Area
*
***********************************************************************
* RDHTRACE - Program Main Entry Point                                 *
***********************************************************************
*
         USING PSA,R0                  Define PCA Addressability
         USING TRGDSECT,R10            Trap Glue Data Area - Status
         USING LSEN,TRGLSEN            Linkage Stack Entry
         USING TRPDSECT,R9             Trap Trace Point Data
         USING TRCDSECT,R8             TRC Persistant Data Area
*
*
RDHTRACE PGMNTRY TYPE=MAIN,            Define Program Entry Code       *
               CBAS=(R12,R11),         Define Constant Base            *
               AMODE=31,               Define Addressing Mode          *
               RMODE=ANY,              Define Residency Mode           *
               ESTAE=YES,              Define ESTAE Support            *
               OPSYN20=NO,             Do No Redefine RS/RX            *
               TRACE=NO,PRINT=GEN      Traces Not Available Here
*
C        USING TRCDNTRY,TRCCNTRY       Current TRCDAREA Entry
P        USING TRCDNTRY,TRCPNTRY       Previous TRCDAREA Entry
*
         L     R10,0(,R1)              Get TRGDSECT Address
         LA    R10,0(,R10)             Clear high Bit
*
         MODESET EXTKEY=ZERO,          Assure we are in Key Zero       *
               SAVEKEY=DSASVKEY,                                       *
               WORKREG=3
*
         IFNTIOT DDNAME=TRCPRINT       If TRCPRINT is Present
            L  R9,TRGTRPAD             Get R1 at Trace Point
            L  R9,0(,R9)               Get TRPDSECT Address
*
            JAS R14,LTRC               Find TRCDSECT if its There
            IF (LTR,R8,R8,Z)              And Not Already Open
               JAS R14,OPEN               ...Open a SYSOUT Dataset
            ENDIF ,
            ST R9,TRCTRPAD             Save TRPDSECT Address
*
            JAS R14,TRACE              Process the TRACE Request
         ENDIF
*
** Return to Caller
*
TRCEXIT  DS    0H
         MODESET KEYADDR=DSASVKEY,     Restore Callers Key             *
               WORKREG=3
         PGMEXIT RC=0                  Define Program Exit Code
*
*---------------------------------------------------------------------*
*                                                                     *
** OPEN - Do Open Processing for Program Tracing Facility             *
*                                                                     *
*    Since this version of the tracing facility is self-contained     *
*  meaning that the #TRACE macro is the only macro in the present     *
*  system, it is necessary to provide a means to perform our          *
*  initialization processing, through this macro and give over        *
*  unto the user of the system the responsibillity for determining    *
*  where this initialization code should go.                          *
*                                                                     *
*---------------------------------------------------------------------*
*
OPEN     SUBNTRY ,
*
** Get Storage for TRCDSECT Persistant Storage or DSA for This TCB
*
         STORAGE OBTAIN,               Obtain Storage for TRC          *
               LENGTH=4096,            (Same)                          *
               LOC=(24,31),BNDRY=PAGE  (Same) - Below The Line
*
         LR  R8,R1                     Get Address of TRCDSECT
         MVC TRCEYECT,=C'TRCDSECT'     Place Eye Catcher
         MVC TRCTCBAD,PSATOLD          Save TCB Address
         UNPK TRCWKCL9,TRCTCBAD(5)     In Hexadecimal
         TR  TRCWKCL9(8),HEXTABL-240   (Same)
         MVC TRCTCBAC,TRCWKCL9         Save In Character Format
*
         STORAGE OBTAIN,               Obtain Storage for TRCDAREA     *
               SP=240,                 (Same)                          *
               LENGTH=TRCDSIZE,        (Same)                          *
               LOC=31                  (Same)
         ST    R1,TRCDADDR             (Same)
         USING TRCDAREA,R1             And Addressability
         MVC   TRCDEYE,=C'TRCDAREA'    Set Eye Catcher
         MVC   TRCDLEN,=A(TRCDSIZE)    Save Size in Header
         DROP  R1                      Drop Temp Addressability
*
** Establish a Resourge Manager Exit for This Task if Not Present
*
         L     R2,=A(RDHRESEX)             Identify The EP for LINK
         IDENTIFY EP=RDHRESEX,ENTRY=(R2)   (Same)
*
         MVC   TRCRESMP(4),=C'RDHT'    Set Identifier in Param
         MVC   TRCRESM,MDLRESM         Set List Form in Storage
         ST    R8,TRCRESMP+4           Addr of TRCDSECT for This Task
*
         L     R3,=V(RDHRESEX)
         RESMGR ADD,TYPE=TASK,         Establish RESMGR Exit This Task *
               ASID=CURRENT,              ..And This Address Space     *
               ROUTINE=(BRANCH,(R3)),           Routine Under an RB    *
               PARAM=TRCRESMP,            ..Parameter Input            *
               TOKEN=TRCRESMT,            ..Token for DELETE           *
               MF=(E,TRCRESM)             ..Point to List Form
*
         IF (LTR,R15,R15,NZ)           Established Properly?
            #SUICIDE MSG='RDHT0001: RESMGR Macro Failed.'
         ENDIF ,

*
** Read in JFCB for TRCPRINT
*
         LA R1,TRCJFCB                 Build Exit List
         ST R1,TRCEXLST                (Same)
         OI TRCEXLST,EXLLASTE+EXLRJFCB (Same)
*
         LA R1,TRCDCB                  Build RDJFCB MF=L
         USING IHADCB,R1               And Temp Addressability
         MVC TRCDCB,MDLDCB             Move DCB to Common
         MVC DCBDDNAM,=C'TRCPRINT'     Set DDNAME in DCB
         LA R14,TRCEXLST               Put EXLST Address in DCB
         ST R14,DCBEXLST               (Same)
*
         OI TRCRJFCL,X'80'             Set Option Byte
         RDJFCB (TRCDCB),              Load JFCB for Dataset           *
               MF=(E,TRCRJFCL)         (Same)
         IF (LTR,R15,R15,NZ)           If RDJFCB Failed
            #SUICIDE MSG'RDHT0001: RDJFCB for TRCPRINT has Failed.'
         ENDIF
*
** Extract Data From JFCB
*
         LA R2,TRCJFCB                 Load JSCB Address
         USING JFCB,R2                 Setup Addressability
         IF (TM,JFCBTSDM,JFCSDS,O)     If This is a SYSOUT Dataset
            OI TRCPFLAG,TRCPDDSO       ...Indicate SYSOUT
         ELSE ,
            IF (TM,JFCBIND1,JFCPDS,O)  If This is a PDS
               OI TRCPFLAG,TRCPDDPO    ...Indicate PDS
            ELSE ,                     Else
               OI TRCPFLAG,TRCPDDPS    ...Indicate PS
            ENDIF
         ENDIF
         DROP R2
*
** Allocate a Sysout Dataset for This TCB if Necessary
*
         L R1,PSATOLD                  Get our TCB Address
         USING TCB,R1                  And Temp Addressability
         MVC TRCDDNAM,=C'TRCPRINT'     Assume Writing to TRCPRINT
*
         IF (TM,TRCPFLAG,TRCPDDSO,O)   If We're Using SYSOUT
            IF (C,R1,NE,TCBJSTCB)         If We Are NOT Job Step TCB?
               MVC TRCDDNAM,=8C' '        ..Space Fill Receiving Field
               #DD ALLOC,                 ..Allocate a Sysout Dataset  *
               SYSOUT=A,                  ....Default Sysout Class     *
               FREE=CLOSE,                ....Deallocate at Close      *
               RTDDN=TRCDDNAM             ....Save DDNAME for Open
            ENDIF
         ENDIF
*
** Open Trace Sysout DCB
*
         LA  R1,TRCDCB                 Get DCB Address
         USING IHADCB,R1               And Temp Addressability
         MVC TRCDCB,MDLDCB             Move DCB to Common
         MVC DCBDDNAM,TRCDDNAM         Set DDNAME in DCB
         MVC TRCOPL,MDLOPL             Move Open Parm to Common
         OPEN  (TRCDCB,(OUTPUT)),      Open Sysout Dataset             *
               MF=(E,TRCOPL)            (Same)
*
         LA R1,TRCDCB                  Get DCB Address
         IF (TM,DCBOFLGS,DCBOFOPN,Z)   If Open Failed...
            #SUICIDE MSG='Open failure for Trace Sysout Dataset.'
         ENDIF
*
         MVC   TRCDCBID,=C'TRAC'       Indicate Our DCB            @RDH
         DROP R1                       Drop Temp Addressability
*
** Obtain Storage for Buffer if Requested
*
         L  R14,TRPTRPAD               Get Address of Open Segment
O        USING TRPDSECT,R14            ..And Addressability
         IF (TM,O.TRPOFLG1,TRPOBUFF,O) If Buffering requested
            LH  R2,O.TRPOBMAX          Get Line Count
            MH  R2,=Y(L'TRCPLINE)      Length of a Print Line
            AH  R2,=Y(4096)            Round to Page Boundry
            SRL R2,12                  (Same)
            SLL R2,12                  (Same)
            STORAGE OBTAIN,            Obtain Storage for Buffer       *
               LENGTH=(R2),            (Same)                          *
               LOC=31,BNDRY=PAGE       (Same)
            ST R1,TRCBUFAD             Save Address
            ST R2,TRCBUFLN             Save Length
            ST R1,TRCBUFCR             Current Position
            AR R2,R1                   Point Past End
            ST R2,TRCBUFND             Save End Pointer
            OI TRCBFLAG,TRCBBFON       Indicate Buffering in Effect
            OI TRCBFLAG,TRCBBATB       In Above-The-Line Storage
         ENDIF
*
** Print Title Line
*
         XC   TRCWKC16,TRCWKC16        Assure Workarea is Zero
         TIME DEC,TRCWKC16,LINKAGE=SYSTEM,DATETYPE=MMDDYYYY,           *
               MF=(E,TRCTMFL)
         L    R0,TRCWKC16
         L    R1,TRCWKC16+8
*
         ST   R1,TRCWORKF
         UNPK TRCWKCL9,TRCWORKF(5)     Get Date in Character
         MVC TRCCDATE,=C'00/00/00' `   Set Template
         OC  TRCWKCL9(8),=8C'0'        (Same)
         MVC TRCCDATE(2),TRCWKCL9      Build Character Form
         MVC TRCCDATE+3(2),TRCWKCL9+2  (Same)
         MVC TRCCDATE+6(2),TRCWKCL9+6  (Same)
*
         SRL R0,8                       Get Only HHMMSS
         ST  R0,TRCWORKF                (Same)
         UNPK TRCWORKD(7),TRCWORKF+1(4) (Same)
         OC  TRCWORKD,=8C'0'            (Same)
         MVC TRCCTIME,=C'00:00:00'      Set Template
         MVC TRCCTIME(2),TRCWORKD       Build Character Form
         MVC TRCCTIME+3(2),TRCWORKD+2   (Same)
         MVC TRCCTIME+6(2),TRCWORKD+4   (Same)
*
         MVC TRCPLINE,CONTITLE         Set Title in Print Area
         MVC TRCPLINE(8),TRCCDATE      Set Date in Title
         MVC TRCPLINE+17(8),TRCDDNAM   Set DDNAME in Title
         MVC TRCPLINE+55(8),TRCTCBAC   Set TCB Address in Title
         MVC TRCPLINE+72(8),TRCCTIME   Set Time in Title
         GOSUB PRNT                    Write Title Line
         MVC TRCPLINE,=CL128' '        Print Vertical Seperator
         GOSUB PRNT                    Print the Line
*
** Establish Recovery Processing for Printing Abend Diagnostics
*
         L     R14,PSATOLD             Get Current TCB Address
         USING TCB,R14                 And Addressability
         XR    R15,R15                 Get Current SCB Address
         ICM   R15,B'0111',TCBSTABB    (Same)
         USING SCB,R15                 And Addressability
*
         DO UNTIL=(LTR,R15,R15,Z)      Loop Through SCB's
            L R14,SCBXPTR                   ..Get SCBX Address
            USING SCBX,R14                  ..And Addressability
            IF (CLC,SCBXALET,EQ,=A(X'101')) And Ours From TYPE=MAIN?
               XC SCBXALET,SCBXALET         ..AR Mode Callers
               MVC SCBXPARM,=A(X'101')      ..(Same)
            ENDIF
            IF (CLC,SCBXPARM,EQ,=A(X'101')) And Ours From TYPE=MAIN?
               L  R1,=A(RDHABEND)           ..Get Address of ESTAE Rtn
               ST R1,SCBEXIT                ..Save it in SCB
               ST R8,SCBXPARM               ..Pass Address of TRCDSECT
               OI SCBFLGS2,SCBSUPER         ..Exit Runs in Supr State
               OI SCBFLGS2,SCBKEY0          ..Exit Runs in Key 0
               NI SCBPARMA,255-SCBAM64      ..31-Bit Estae
               MVI SCBPKEY,0                ..---->Yes REALLY
            ENDIF ,
            L R15,SCBCHAIN                  Get Next SCB on Chain
         ENDDO ,
*
** Return to Caller
*
OPEN999  DS    0H
         SUBEXIT ,
         DROP  O,R14,R15               Drop Temp Addressabilty
*
*---------------------------------------------------------------------*
*                                                                     *
** TRACE - Process a Trace Point Trap Request                         *
*                                                                     *
*    The function of this routine is to break out all the various     *
*  types of trace points that I have envisioned for this system in    *
*  the future. Not all of this is implemented at present, but it      *
*  does provide a basic structure for future enhancements.            *
*                                                                     *
*---------------------------------------------------------------------*
*
TRACE    SUBNTRY ,
         LA  R14,TRCINDNT               Get Current Indention Level
         LH  R15,TRCINCUR               Get Current Table Entry #
         SLL R15,1                      (Same)
         LA  R14,0(R14,R15)             Point at Current Entry
         MVC TRCINLVL,0(R14)            Get Current Indention
         MVI TRCINLVL,X'00'             Zero Overflow - If Present
*
** Build TRCDAREA - Savearea and Linkage Stack Chain
*
         CALL  RDHDSAVE,                Build TRCDAREA For This Call   *
               ((R8)),                  Passing TRCDSECT Address       *
               MF=(E,DSAPLIST)          (Same)
*
** Get Caller's Registers
*
         L     R1,TRCDADDR              Get TRCDAREA Address
         USING TRCDAREA,R1              And Temp Addressability
         L     R14,TRCDCNT              Get Last TRCDAREA Entry-Current
         SH    R14,=Y(1)                (Same)
         MH    R14,=Y(TRCDLNTH)         (Sama)
         LA    R14,TRCPLTH(R14,R1)      (Same)
         MVC   TRCCNTRY,0(R14)          (Same)
         L     R15,TRCDCNT              Get Prev TRCDSECT Entry-Caller
         SH    R15,=Y(2)                (Same)
         MH    R15,=Y(TRCDLNTH)         (Same)
         LA    R15,TRCPLTH(R15,R1)      (Same)
         MVC   TRCPNTRY,0(R15)          (Same)
         DROP  R1                       Drop Temp Addressability
*
** Set ARMODE Flags
*
         IF (TM,LSENPSW1+2,X'40',O)        If We Were in ARMODE?
            OI TRGFLAG1,TRG1ARMD           ..Indicate ARMODE
         ENDIF
*
         NI TRGFLAG1,255-(TRG1AM64+TRG1AM31+TRG1AM24) Reset
         IF (TM,LSENPSW1+3,X'01',O)        If We Were in AMODE=64?
            OI TRGFLAG1,TRG1AM64           ..Indicate AMODE=64
         ELSE ,
            IF (TM,LSENPSW1+4,X'80',O)     If We Were in AMODE=31?
               OI TRGFLAG1,TRG1AM31        ..Indicate AMODE=31
            ELSE ,
               OI TRGFLAG1,TRG1AM24        ..Indicate AMODE=24
            ENDIF
         ENDIF
*
** Process by Type of Trap
*
         MVC TRCNAME,TRPNAME              Set Default Trap Name
         IF (TM,TRPFLAG1,TRPFPGME,O)      If Program Entry?
            BAS R14,PGME
         ELSEIF (TM,TRPFLAG1,TRPFPGMX,O)  If Program Exit?
            BAS R14,PGMX
         ELSEIF (TM,TRPFLAG1,TRPFSUBE,O)  If Subroutine Entry?
            BAS R14,SUBE
         ELSEIF (TM,TRPFLAG1,TRPFSUBX,O)  If Subroutine Exit?
            BAS R14,SUBX
         ELSEIF (TM,TRPFLAG1,TRPFTRAP,O)  If Generic Trap?
            BAS R14,TRAP
         ELSE ,
            MVC TRCRC,=F'16'              No  -> Set Bad RC
            MVC TRCRS,=F'4'               Set bad RS
         ENDIF ALL
*
** Return to Caller
*
TRACE999 DS    0H
         SUBEXIT ,
*
*---------------------------------------------------------------------*
*                                                                     *
** PGME - Process a Program Entry Trace Point Request                 *
*                                                                     *
*                                                                     *
*---------------------------------------------------------------------*
*
PGME     SUBNTRY ,
         ICM R2,B'1111',TRPTRPAD             Get Addr of Open Segment
         MVC TRCNAME,TRPCSECT-TRPDSECT(R2)   Use CSECT Name
         MVC TRCHEADT,=C'P) PGME:'           Set Trap Type
*
         GOSUB PLSE                    Get Previous LSEN Entry
*
         MVI TRCPLINE,C' '             Space Fill Print Line
         MVC TRCPLINE+1(L'TRCPLINE-1),TRCPLINE
         GOSUB PRNT                    Print the Line
*
         IF (TM,TRPFLAG2,TRPFNOHD,Z)   Are Trap Headings Requested?
            BAS R14,HEAD               Yes -> Show Heading Line
            BAS R14,SPSW                      And PSW Status
         ENDIF
*
         IF (TM,TRPFLAG2,TRPFMSGS,O)   Was MSG= Specified?
            BAS R14,MSGS               Yes ->
         ENDIF
         IF (TM,TRPFLAG2,TRPFREGS,O)   Was REGS= Specified?
            BAS R14,REGS               Yes ->
         ENDIF
         IF (TM,TRPFLAG2,TRPFDATA,O)   Was DATA= Specified?
            BAS R14,DATA               Yes ->
         ENDIF
*
PGME999  DS    0H
         SUBEXIT ,
*
*---------------------------------------------------------------------*
*                                                                     *
** PLSE - Get Previous LSEN Dsect Entry                               *
*                                                                     *
*---------------------------------------------------------------------*
*
PLSE     SUBNTRY ,
         LG    R3,TRGCR15              Load Control Register 15
         SH    R3,=Y(LSENLNTH)         Back up to BAKR Entry
         SH    R3,=Y(LSEDLNTH)         ..Back up to Descripter
         USING LSED,R3                 & Addressability
*
         MVC DSALSTPP,LSEDTYPE         Get Entry Type
         NI  DSALSTPP,X'7F'            Strip High Bit
         IF (CLI,DSALSTPP,EQ,LSEDTHDR) If Header Entry..
            SH R3,=Y(LSHDLNTH)         ..Back up to Entry
            USING LSHD,R3              Obtain Addressability
            L  R3,LSHDPREV             Get Previous Entry Ptr
            SH R3,=Y(LSEDLNTH)         ..Back up to Descripter
         ENDIF ,
*
         SH R3,=Y(LSENLNTH)            Back up to Entry We Want
*
         LR    R0,R3                   Get Linkage Stack Address
         LA    R1,L'TRGLSEN            Length for MVCL
         LA    R14,TRGLSEN             Set To Address
         LR    R15,R1                  Set To Length
         MVCL  R14,R0                  Move Linkage Stack Entry
         MVC   DSAEPSW1,LSENMODA *TEMP Save PSW Status On Entry
*
PLSE999  DS    0H
         SUBEXIT ,
         DROP  R3                      Drop Temp Addressability
*
*---------------------------------------------------------------------*
*                                                                     *
** PGMX - Process a Program Exit Trace Point Request                  *
*                                                                     *
*                                                                     *
*---------------------------------------------------------------------*
*
PGMX     SUBNTRY ,
         MVI TRCPLINE,C' '             Space Fill Print Line
         MVC TRCPLINE+1(L'TRCPLINE-1),TRCPLINE
         GOSUB PRNT                    Print the Line
*
         ICM R2,B'1111',TRPTRPAD           Get Addr of Open Segment
         MVC TRCNAME,TRPCSECT-TRPDSECT(R2) Use CSECT Name
         MVC TRCHEADT,=C'P) PGMX:'         Set Trap Type
*
         IF (TM,TRPFLAG2,TRPFNOHD,Z)       Are Trap Headings Requested?
            BAS R14,HEAD                   Yes -> Print Headings
            MVC DSAEPSW1,LSENMODA  *TEMP   Save PSW Status On Exit
            BAS R14,SPSW                   And PSW Status
         ENDIF
*
         IF (TM,TRPFLAG2,TRPFMSGS,O)   Was MSG= Specified?
            BAS R14,MSGS               Yes ->
         ENDIF
*
         IF (TM,TRPFLAG2,TRPFREGS,O)   Was REGS= Specified?
            BAS R14,REGS               Yes ->
         ENDIF
*
         IF (TM,TRPFLAG2,TRPFDATA,O)   Was DATA= Specified?
            BAS R14,DATA               Yes ->
         ENDIF
*
PGMX999  DS    0H
         SUBEXIT ,
*
*---------------------------------------------------------------------*
*                                                                     *
** SUBE - Process a Subroutine Entry Trace Point Request              *
*                                                                     *
*                                                                     *
*---------------------------------------------------------------------*
*
SUBE     SUBNTRY ,                  -*- Increment Indention Level
         LA  R14,TRCINDNT               Get Current Indention Level
         LH  R15,TRCINCUR               Get Current Table Entry #
         SLL R15,1                      (Same)
         LA  R14,0(R14,R15)             Point at Current Entry
         IF (CLI,0(R14),EQ,X'00'),AND,  If not in Overflow             *
               (CLI,1(R14),LT,30)
            LH R1,0(R14)                Get Current Indention Level
            LA R1,3(,R1)                Increment Indention
            STH R1,0(R14)               (Same)
         ELSE ,
            XR R1,R1                    Zero Work Register
            IC R1,0(R14)                Get Overflow Count
            LA R1,1(,R1)                Increment Count
            STC R1,0(,R14)              (Same)
         ENDIF  ,
         MVC TRCINLVL,0(R14)            Get Current Indention
         MVI TRCINLVL,X'00'             Zero Overflow - If Present

*
** Build Name for Trace Point
*
         MVC TRCWKCL9,=CL9' '          Space Fill Area
         MVC TRCWKCL9(8),TRCNAME       Get Trace Point Name
         LA R1,TRCWKCL9                Get Address of Name
         DO WHILE=(CLI,0(R1),NE,C' ')  Locate First Space
            LA R1,1(,R1)               (Same)
         ENDDO ,
         BCTR R1,0                     Point at Last Character C'E'
         MVI  0(R1),C' '               ..And Wipe it Out
         MVC TRCNAME,TRCWKCL9          Set Subr Name
         MVC TRCHEADT,=C'S) SUBE:'     Set Trap Type
*
** Process Trap Parameters
*
         IF (TM,TRPFLAG2,TRPFNOHD,Z)   Are Trap Headings Requested?
            BAS R14,HEAD               Yes ->
         ENDIF
         IF (TM,TRPFLAG2,TRPFMSGS,O)   Was MSG= Specified?
            BAS R14,MSGS               Yes ->
         ENDIF
         IF (TM,TRPFLAG2,TRPFREGS,O)   Was REGS= Specified?
            BAS R14,REGS               Yes ->
         ENDIF
         IF (TM,TRPFLAG2,TRPFDATA,O)   Was DATA= Specified?
            BAS R14,DATA               Yes ->
         ENDIF
*
** Return to Caller
*
         SUBEXIT ,
*
*---------------------------------------------------------------------*
*                                                                     *
** SUBX - Process a Subroutine Exit Trace Point Request               *
*                                                                     *
*                                                                     *
*---------------------------------------------------------------------*
*
SUBX     SUBNTRY ,                 -*- Build Trap Name
         MVC TRCWKCL9,=CL9' '          Space Fill Area
         MVC TRCWKCL9(8),TRCNAME       Get Trace Point Name
         LA R1,TRCWKCL9                Get Address of Name
         DO WHILE=(CLI,0(R1),NE,C' ')  Locate First Space
            LA R1,1(,R1)               (Same)
         ENDDO ,
         BCTR R1,0                     Point at Last Character C'E'
         MVI  0(R1),C' '               ..And Wipe it Out
         MVC  TRCNAME,TRCWKCL9         Set Subr name
*
** Process Trap Parameters
*
         MVC TRCHEADT,=C'S) SUBX:'     Set Trap Type
         IF (TM,TRPFLAG2,TRPFNOHD,Z)   Are Trap Headings Requested?
            BAS R14,HEAD               Yes ->
         ENDIF
         IF (TM,TRPFLAG2,TRPFMSGS,O)   Was MSG= Specified?
            BAS R14,MSGS               Yes ->
         ENDIF
         IF (TM,TRPFLAG2,TRPFREGS,O)   Was REGS= Specified?
            BAS R14,REGS               Yes ->
         ENDIF
         IF (TM,TRPFLAG2,TRPFDATA,O)   Was DATA= Specified?
            BAS R14,DATA               Yes ->
         ENDIF
*
** Decrement Indention Level
*
         LA  R14,TRCINDNT               Get Current Indention Level
         LH  R15,TRCINCUR               Get Current Table Entry #
         SLL R15,1                      (Same)
         LA  R14,0(R14,R15)             Point at Current Entry
         IF (CLI,0(R14),EQ,X'00')       If not in Overflow
            LH  R1,0(R14)               Get Current Indention Level
            AHI R1,-3                   Decrement Indention
            STH R1,0(R14)               (Same)
         ELSE ,
            XR  R1,R1                   Zero Work Register
            ICM R1,B'0011',0(R14)       Get Overflow Count
            AHI R1,-256                 Subtract One Overflow Level
            STCM R1,B'0011',0(R14)      (Same)
         ENDIF  ,
*
** Return to Caller
*
         SUBEXIT ,
*
*---------------------------------------------------------------------*
*                                                                     *
** TRAP - Process a Generic Trace Point Request                       *
*                                                                     *
*    This routine is the generic trap processor. It's function is to  *
*  generate the data for all macro parameters that are common to all  *
*  traps.  Specifically, MSG=, REGS= and DATA=.                       *
*                                                                     *
*---------------------------------------------------------------------*
*
TRAP     SUBNTRY ,
         LH  R1,TRCINLVL               Get Indention Level
         LA  R1,3(,R1)                 Increment indention for TRAP
         STH R1,TRCINLVL               Set Indention Level
*
         MVC TRCHEADT,=C'T) Trap:'     Set Trap Type
         IF (TM,TRPFLAG2,TRPFNOHD,Z)   Are Trap Headings Requested?
            BAS R14,HEAD               Yes ->
         ENDIF
*
         IF (TM,TRPFLAG2,TRPFMSGS,O)   Was MSG= Specified?
            BAS R14,MSGS               Yes ->
         ENDIF
*
         IF (TM,TRPFLAG2,TRPFREGS,O)   Was REGS= Specified?
            BAS R14,REGS               Yes ->
         ENDIF
*
         IF (TM,TRPFLAG2,TRPFDATA,O)   Was DATA= Specified?
            BAS R14,DATA               Yes ->
         ENDIF
*
         LH  R1,TRCINLVL               Get Indention Level
         LA  R1,3(,R1)                 Decrement Indention After
         STH R1,TRCINLVL               Set Indention Level
*
TRAP999  DS    0H
         SUBEXIT ,
*
*---------------------------------------------------------------------*
*                                                                     *
** HEAD - Process Process Trap Heading with Identifier                *
*                                                                     *
*    This routine will produce the trace point heading line as        *
*  indicated below.  If NOHEAD=YES was specified on the #TRACE        *
*  macro, this routine will not be called.                            *
*                                                                     *
*    T) Trap: TRAPNAME At: LMOD.CSECT+DDDD
*    P) Entr: PGRMNAME At: LMOD.CSECT+DDDD, Fr: LMOD.CSECT+DDDD
*    P) Exit: PRGMNAME At: LMOD.CSECT+DDDD, Fr: LMOD.CSECT+DDDD
*    S) Entr: SUBRNAME At: LMOD.CSECT+DDDD, Fr: LMOD.CSECT+DDDD
*    S) Exit: SUBRNAME At: LMOD.CSECT+DDDD, Fr: LMOD.CSECT+DDDD
*
*---------------------------------------------------------------------*
*
O        USING TRPDSECT,R14            Temp Addressability
*
HEAD     SUBNTRY ,
         MVI TRCPLINE,C' '             Space Fill Print Line
         MVC TRCPLINE+1(L'TRCPLINE-1),TRCPLINE
*
** Do Initial Part With At:
*
         LH  R1,TRCINLVL               Get Indention Level
         LA  R1,TRCPLINE(R1)           Get Address of Print Line
         MVC 1(8,R1),TRCHEADT          Set Trap Type
         LA  R1,10(,R1)                Bump Pointer to Blank
         MVC 0(8,R1),TRCNAME           Set Trap Name
         BAS R14,FBLNK                 Find Next Blank
         MVC 1(3,R1),=C'At:'           Set Next Literal
         LA  R1,5(,R1)                 Bump Pointer
*
         IF (CLI,C.TRCDLMOD,NE,C' ')   If Found LMOD
            MVC 0(8,R1),C.TRCDLMOD     Set LMOD Name
            BAS R14,FBLNK              Find Next Blank
            MVI 0(R1),C'.'             Set Seperator
         ELSE
            SH R1,=Y(1)                Compensate
         ENDIF
*
         ICM   R7,B'1111',TRPTRPAD     Get Address of Open Segment
         MVC   1(8,R1),TRPCSECT-TRPDSECT(R7)
         LA    R1,1(,R1)               Point at First Character
         BAS   R14,FBLNK               Find Next Blank
         MVI   0(R1),C'+'              Set Seperator
*
         IF (TM,TRPFLAG1,TRPFPGME,O)    If Program Entry?
            MVC 1(4,R1),=C'0000'           Move to Print Line
         ELSE ,
            UNPK TRCWORKD+0(5),TRPOFFST(3) Get Offset in Hex
            TR TRCWORKD+0(5),HEXTABL-240   (Same)
            MVC 1(4,R1),TRCWORKD           Move to Print Line
         ENDIF ,
*
         IF (TM,TRPFLAG1,TRPFTRAP,O)   If Generic Trap Trace point?
            GOSUB PRNT                 Print the Line
            B HEAD999                  -> Done
         ENDIF ,
*
** Process PGME Entries
*
         XC  DSAPADDR,DSAPADDR         Zero Output Fields
         XC  DSAPOFST,DSAPOFST         (Same)
         MVC DSAPCNAM,=CL8' '          (Same)
*
         IF (TM,TRPFLAG1,TRPFPGME,O)   If PGM Entry?
            BAS R14,FBLNK              Find Next Blank
            MVC 0(5,R1),=C', Fr:'      Set Next Literal
            LA R1,6(,R1)               Bump Pointer
            MVC DSAPLNAM,C.TRCDRTLM    Set Lmod
            MVC DSAPCNAM,C.TRCDRTCS    Set Csect
            MVC DSAPOFST,C.TRCDROFS    Set Offset
         ENDIF ,
*
** Process PGMX Entries
*
         IF (TM,TRPFLAG1,TRPFPGMX,O)   If PGM Entry?
            BAS R14,FBLNK              Find Next Blank
            MVC 0(5,R1),=C', To:'      Set Next Literal
            LA R1,6(,R1)               Bump Pointer
            MVC DSAPLNAM,C.TRCDRTLM    Set Lmod
            MVC DSAPCNAM,C.TRCDRTCS    Set Csect
            MVC DSAPOFST,C.TRCDROFS    Set Offset
         ENDIF ,
*
** Process SUBE Entries
*
         IF (TM,TRPFLAG1,TRPFSUBE,O)   If SUB Entry?
            BAS R14,FBLNK              Find Next Blank
            MVC 0(5,R1),=C', Fr:'      Set Next Literal
            LA R1,6(,R1)               Bump Pointer
*
            MVC DSAPLNAM,C.TRCDLMOD    Set Current Lmod
            MVC DSAPCNAM,C.TRCDCSCT    Set Current Csect
            L  R14,LSENGR14+4          Get Return Point
            LA R14,0(,R14)
            S  R14,C.TRCDCSEP          Minus Entry Point
            ST R14,DSAPOFST            Set Offset
         ENDIF ,
*
** Process SUBX Entries
*
         IF (TM,TRPFLAG1,TRPFSUBX,O)   If SUB Entry?
            BAS R14,FBLNK              Find Next Blank
            MVC 0(5,R1),=C', To:'      Set Next Literal
            LA R1,6(,R1)               Bump Pointer
*
            MVC DSAPLNAM,C.TRCDLMOD    Set Current Lmod
            MVC DSAPCNAM,C.TRCDCSCT    Set Current Csect
            L  R14,LSENGR14+4          Get Return Point
            LA R14,0(,R14)
            S  R14,C.TRCDCSEP          Minus Entry Point
            ST R14,DSAPOFST            Set Offset
         ENDIF ,
*
** Finish Up Line
*
         IF (CLI,DSAPLNAM,NE,C' ')      If Found Callers LMOD
            MVC 0(8,R1),DSAPLNAM        Set LMOD Name
            BAS R14,FBLNK               Find Next Blank
            IF (CLC,=C'Zos',NE,DSAPLNAM)   If Not Initiator?
               MVI 0(R1),C'.'              ..Set Seperator
            ENDIF
         ELSE
            SH R1,=Y(1)                Compensate
            MVI 0(R1),C' '             (Same)
         ENDIF
*
         IF  (CLC,=C'Zos',NE,DSAPLNAM) If Not From Zos?
            IF (CLI,DSAPCNAM,NE,C' ')  If we Have Csect Name?
              MVC 1(8,R1),DSAPCNAM        Add CSECT Name
              LA R1,1(,R1)             Point at First Character
              BAS R14,FBLNK            Find Next Blank
              MVI 0(R1),C'+'           Set Seperator
            ENDIF ,
*
            UNPK TRCWORKD+0(5),DSAPOFST+2(3)   Get Offset in Hex
            TR TRCWORKD+0(5),HEXTABL-240       (Same)
            MVC 1(4,R1),TRCWORKD               Move to Print Line
         ENDIF ,
*
         GOSUB PRNT                    Print the Line
*
** Return to Caller
*
HEAD999  DS    0H
         SUBEXIT ,                     Return to Caller
         DROP  O                       Drop Temp Bases
*
** FBLNK - Find the Next Blank
*
FBLNK    DS    0H                  -*- Tiny Little Subroutine
         CLI   0(R1),C' '              Found a Blank
         BER   R14                     -> Goback
         LA    R1,1(,R1)               Bump by a Character
         B     FBLNK                   -> And Try Again
*
*
*---------------------------------------------------------------------*
*                                                                     *
** SPSW - Show PSW Status at Program Entry                            *
*                                                                     *
*---------------------------------------------------------------------*
*
SPSW     SUBNTRY ,
         MVI TRCPLINE,C' '             Space Fill Print Line
         MVC TRCPLINE+1(L'TRCPLINE-1),TRCPLINE
*
         LH  R2,TRCINLVL               Get Indention Level
         LA  R2,TRCPLINE+10(R2)        Get Address of Print Line
*
*                                  -*- Set State Value
         MVC 0(6,R2),=C'State('        Set State Header
         LA  R2,6(,R2)                 (Same)
         IF  (TM,DSAEPSW1+1,X'01',O)   If Problem State?
             MVC 0(9,R2),=C'Problem),' ...Indicate Problem State
             LA  R2,10(,R2)            ...Bump Pointer
         ELSE ,                        Else
             MVC 0(12,R2),=C'Supervisor),' ...Indicate Supervisor State
             LA  R2,13(,R2)                ...Bump Pointer
         ENDIF ,
*
         XR  R14,R14               -*- Set Key Value
         IC  R14,DSAEPSW1+1            Get PSW Key
         SRL R14,4                     (Same)
         IF  (C,R14,LT,=F'10')         If Single Digit Key?
           O   R14,=A(X'000000F0')     (Same)
           MVC 0(4,R2),=C'Key('        Set Key Header
           LA  R2,4(,R2)               (Same)
           STC R14,0(,R2)              Set Key
           MVC 1(2,R2),=C'),'          (Same)
           LA  R2,4(,R2)               (Same)
         ELSE  ,
           S   R14,=F'10'              Get Double Digit Key
           O   R14,=A(X'000000F0')     (Same)
           MVC 0(5,R2),=C'Key(1'       Set Key Header
           LA  R2,5(,R2)               (Same)
           STC R14,0(,R2)              Set Key
           MVC 1(2,R2),=C'),'          (Same)
           LA  R2,5(,R2)               (Same)
         ENDIF ,
*
         MVC 0(5,R2),=C'Mode('      -*- Set Mode Header
         LA  R2,5(,R2)                  (Same)
         IF (TM,DSAEPSW1+2,X'80',Z)     If Primary or Access?
            IF (TM,DSAEPSW1+2,X'40',Z)     If Primary Mode?
               MVC 0(9,R2),=C'Primary),'   ...Indicate Primary Mode
               LA  R2,10(,R2)              ...Bump Pointer
            ELSE ,                         Else
               MVC 0(8,R2),=C'Access),'    ...Indicate Access Mode
               LA  R2,9(,R2)               ...Bump Pointer
            ENDIF ,
         ELSE ,                         If Home or Secondary?
            IF (TM,DSAEPSW1+2,X'40',Z)     If Secondary Mode?
               MVC 0(9,R2),=C'Secondary),' ...Indicate Primary Mode
               LA  R2,10(,R2)              ...Bump Pointer
            ELSE ,                         Else
               MVC 0(6,R2),=C'Home),'      ...Indicate Home Mode
               LA  R2,7(,R2)               ...Bump Pointer
            ENDIF ,
         ENDIF ,
*
         MVC 0(6,R2),=C'Amode('     -*- Set Amode Header
         LA  R2,6(,R2)                  (Same)
         IF  (TM,DSAEPSW1+3,X'01',O)    If Amode(64)?
             MVC 0(3,R2),=C'64)'        ...Indicate Amode(64)
         ELSE ,                         Else
            IF (TM,DSAEPSW1+4,X'80',O)  If Amode(31)?
                MVC 0(3,R2),=C'31)'     ...Indicate Amode(31)
            ELSE ,
                MVC 0(3,R2),=C'24)'     ...Indicate Amode(24)
            ENDIF ,
         ENDIF ,
*
         GOSUB PRNT                     Print Line
*
SPSW999  DS    0H
         SUBEXIT ,
*
*---------------------------------------------------------------------*
*                                                                     *
** FCDE - Locate CDE and Extent List for Address                      *
*                                                                     *
*    This routine is given an storage address and attempts to find    *
*  the load module that is loaded at that address.  It runs the CDE   *
*  chain to the extent list and and checks the address against the    *
*  storage extent.                                                    *
*                                                                     *
*  On Input:  R1      -> Address to Locate                            *
*  On Output: TRCLMOD -> CDNAME of LMOD or Blanks                     *
*                                                                     *
*---------------------------------------------------------------------*
*
         USING TCB,R14                 Get TCB Addressability
         USING CDENTRY,R15             Get CDE Addressability
         USING XTLST,R2                Get XTLST Addressability
*
FCDE     SUBNTRY ,
         MVC TRCLMOD,=CL8' '           Space Fill Receiving Field
*
         L  R14,PSATOLD                Load Our TCB Address
         L  R14,TCBJSTCB               CDE's Are Anchored Off JSTCB
         IF (ICM,R15,15,TCBJPQ,NZ)     Get First CDE on Chain
            DO INF                     Do Forever...
               L  R2,CDXLMJP           Get Extent Pointer
               XR R14,R14              Zero Work Register
               ICM R14,7,XTLMSBLN      Get Length of Extent
               AL  R14,XTLMSBAD        Plus Address for End Pointer
*
               IF (C,R1,GE,XTLMSBAD)   If Greater Than Beginning
                  IF (CR,R1,LT,R14)    And Less Than End
                     MVC TRCLMOD,CDNAME   Save CDNAME
                     DOEXIT ,             -> Done
                  ENDIF
               ENDIF
*
               L  R15,CDCHAIN          Get next CDE Entry
               IF (LTR,R15,R15,Z)      End of Chain?
                  DOEXIT ,             Yes -> Done
               ENDIF
            ENDDO
         ENDIF
*
FCDE999  DS    0H
         SUBEXIT ,
         DROP  R14,R15,R2              Drop Temp Bases
*
*---------------------------------------------------------------------*
*                                                                     *
** REGS - Print Registers Requested by This Trap                      *
*                                                                     *
*    This routine print the values of the callers registers at the    *
*  point the trap was taken.  Any combination of registers may be     *
*  specified on the #TRACE macro and will be printed as shown below.  *
*                                                                     *
*    R08 - 008F0760  R09 - 008FF6F8  R10 - 00000000  R11 - 00008470   *
*    R12 - 80007470  R13 - 00008000  R14 - 800075DA  R15 - 000076F0   *
*                                                                     *
*    R00 - FD000008  R01 - 800075E6  R14 - 800075F2  R15 - 000076F0   *
*                                                                     *
*---------------------------------------------------------------------*
*
REGS     SUBNTRY ,
         XGR R0,R0                     Zero Work Registers
         XGR R1,R1                     (Same)
         ZAP TRCREG#,=P'0'             1st Register to Print
         ICM R1,B'1100',TRPPREGS       Get Registers to Print
         LH  R2,TRCINLVL               Get Indention Level
         LA  R2,TRCPLINE+4(R2)         Output - Print Line Position
         LA  R14,LSENARGS              Input  - Access  Register Values
         LA  R15,LSENGRGS              Input  - General Register Values
*
         DO FROM=(R3,8)                Loop Max Eight Lines
            MVI TRCPLINE,C' '          Space Fill Print Line
            MVC TRCPLINE+1(L'TRCPLINE-1),TRCPLINE
*
            DO FROM=(R4,2)            -*- Loop Max Two Regs
               DO INF                 -*- Inner Loop
                  SLDL R0,1               Get Register to Print
                  IF (LTR,R0,R0,NZ)       Print This Register?
                     XR R0,R0                   Zero For Next Time
                     UNPK TRCWORKD(3),TRCREG#   Get Register Number
                     OC   TRCWORKD(3),=C'000'   (Same)
                     MVI  0(R2),C'R'            Register Indicater
                     MVC  1(2,R2),TRCWORKD+1    Register Number
                     MVI  4(R2),C'-'            Seperater
*
                     UNPK TRCWKCL9,0(5,R14)       Get Access Reg
                     TR   TRCWKCL9(8),HEXTABL-240 (Same)
                     MVC  6(8,R2),TRCWKCL9        Register Value
                     MVI  14(R2),C'/'             Set Seperator
*
                     UNPK TRCWKCL9,0(5,R15)       Get High Word
                     TR   TRCWKCL9(8),HEXTABL-240 (Same)
                     MVC  15(8,R2),TRCWKCL9       Register Value
                     MVI  23(R2),C'_'             Set Seperator
*
                     UNPK TRCWKCL9,4(5,R15)       Get Low Word
                     TR   TRCWKCL9(8),HEXTABL-240 (Same)
                     MVC  24(8,R2),TRCWKCL9       Register Value
*
                     LA R2,35(,R2)     Bump Line Position
                     AP TRCREG#,=P'1'  Bump Register Number
                     LA R14,4(,R14)    Point at Next Access  Register
                     LA R15,8(,R15)    Point at Next General Register
                     DOEXIT ,
                  ELSE
                     AP TRCREG#,=P'1'  Bump Register Number
                     LA R14,4(,R14)    Point at Next Access  Register
                     LA R15,8(,R15)    Point at Next General Register
                  ENDIF
               ENDDO
               IF (LTR,R1,R1,Z)        If At End?
                  DOEXIT ,             -> Exit
               ENDIF
            ENDDO
*
            STM R14,R1,TRCSAVE4        Save Registers Over PUT
            GOSUB PRNT                 Print the Line
            LM  R14,R1,TRCSAVE4        Load Registers After PUT
            LH  R2,TRCINLVL            Get Indention Level
            LA  R2,TRCPLINE+4(R2)      Reset Print Line Position
            IF (LTR,R1,R1,Z)           If At End?
               DOEXIT ,                -> Exit
            ENDIF
         ENDDO
*
         MVI TRCPLINE,C' '             Space Fill Print Line
         MVC TRCPLINE+1(L'TRCPLINE-1),TRCPLINE
         GOSUB PRNT                    Print the Line
*
REGS999  DS    0H
         SUBEXIT ,
*
*---------------------------------------------------------------------*
*                                                                     *
** MSGS - Print The Message Requested by This Trap                    *
*                                                                     *
*    This routine will format the MSG= data, which consists as a      *
*  sublist intermixed with both text data and variable data.  The     *
*  variable data will be converted to printable form based upon the   *
*  T' type for that variable.  Some examples are:                     *
*                                                                     *
*     MSG='This is a message'                                         *
*     MSG=('The ',COLOR,' HARE ' is ',HEIGHT,' ft. tall.'             *
*     MSG=('Show savearea at: ',DSASAVEA)                             *
*                                                                     *
*  COLOR  DC C'BLUE'                                                  *
*  HEIGHT DC H'5'                                                     *
*                                                                     *
*    The primary input for this routine is the TRPDSECT area.         *
*                                                                     *
*                                                                     *
*---------------------------------------------------------------------*
*
MSGS     SUBNTRY ,
         MVI TRCPLINE,C' '             Space Fill Print Line
         MVC TRCPLINE+1(L'TRCPLINE-1),TRCPLINE
*
         LA  R2,TRCMSGWK               Init Current Output Position
         MVI TRCMSGWK,C' '             Space Fill Area
         MVC 1(L'TRCMSGWK-1,R2),0(R2)  (Same)
         LA  R3,TRPMSG                 Point at Pre-formated Message
         XR  R4,R4                     Zero Work Register
         ICM R4,B'0011',TRPMLNTH       Get Length of Message
         LA  R3,2(,R3)                 Point Past Length at Message
         AHI R4,-2
*
** Loop Through Message and Build Text
*
         DO FROM=(R4)                  Loop For Count in Message
            IF (CLI,0(R3),EQ,TRPEVVAR) Do We Have A Variable?
               IF (CH,R4,LE,=H'0')     If VAR is Last Thing?
                  DOEXIT ,
               ENDIF ,
               BAS R14,FVAR            Format Variable for Printing
            ELSE ,                 -*- Move Message Text
               IF (CLI,0(R3),EQ,TRPEVFIL) Is This a Filler Byte?
                  LA R2,1(,R2)            ..Ignore This Byte
                  LA R3,1(,R3)            ..(Same)
               ELSE ,                     Else
                  MVC 0(1,R2),0(R3)       ..Move a Byte
                  LA R2,1(,R2)            ..Bump Output Pointer
                  LA R3,1(,R3)            ..Bump Input Pointer
               ENDIF ,
            ENDIF ,
            LA R14,TRCMSGWK+L'TRCMSGWK-1 Get End of Buffer
            IF (CR,R14,NH,R2),OR,      Have We Move to End?            *
               (LTR,R4,R4,Z)           (Same)
               DOEXIT ,                Yes -> Quit
            ENDIF ,
         ENDDO ,                       -> Loop (BCT)
*
** Print Formated Message
*
         IF (TM,TRPFLAG2,TRPFSQEZ,NZ)     Sqeeze Buffer?
            LARL R3,RDHTRACE              We Need Temp Addressabliity
            USING RDHTRACE,R3             (Same)
            SQUEEZE BEG=TRCMSGWK,         Remove Double Blanks         *
               END=TRCMSGWK+L'TRCMSGWK-1,MF=E
            DROP R3                       Drop Temp Addressability
         ENDIF ,
         LH  R15,TRCINLVL              Get Index Level
         LA  R15,TRCPLINE(R15)         Index to Area
         MVC 4(124,R15),TRCMSGWK       Indent Message Text
         GOSUB PRNT                    Print the Line
*
MSGS999  DS    0H
         SUBEXIT ,
*
*---------------------------------------------------------------------*
*                                                                     *
** FVAR - Format a MSG= Variable for Printing                         *
*                                                                     *
*    This routine takes in the address of the current variable        *
*  defination from the input MSG= data and formats that data          *
*  according to the data type.  This formated data is passed back     *
*  to the caller in the current position within TRCMSGWK, with the    *
*  current positions of from and to data bumped appropriately and     *
*  the current length drecemented.                                    *
*                                                                     *
*    Inputs:                                                          *
*            R2 = Output Pointer, Current Position in TRCMSGWK        *
*            R3 = Input  Pointer, Current Position in TRPMSG          *
*                 This will also be the pointer to the TRPEVAR entry  *
*                 to process.                                         *
*            R4 = Residual length of total MSG= data.                 *
*                                                                     *
*---------------------------------------------------------------------*
*
         USING TRPEVAR,R3              Establish Temp Addressability
*
FVAR     SUBNTRY ,
         XGR  R14,R14                  Zero Work Register
         XGR  R15,R15                  (Same)
         ICM  R14,B'0011',TRPESCON     Get SCON Address of Data
         SRDL R14,12                   Seperate B and DDD
*
         SRL R15,16                    Get DH+DL Displacement Fr SL3
         ICM R15,B'0100',TRPESCDH      (Same)
         SRL R15,4                     (Same)
*
         SLL  R14,2                    Base Register Times*4
         L    R1,LSENARGS(R14)         Load Access Aegister
         ST   R1,DSAWORKF              Save in Work Area
         LAM  R14,R14,DSAWORKF         Load Access Aegister
         SLL  R14,1                    Base Register Times*8
         LG   R14,LSENGRGS(R14)        Get Base Address
*
** Set ARMODE and AMODE for Proper Access to Data
*
         IF (TM,LSENPSW1+2,X'40',O)    If We Were in ARMODE?
            SAC 512                    ..Sac In - To Get Data
         ENDIF
*                                      In The Beginning We're 31-Bit
         IF (TM,TRGFLAG1,TRG1AM64,O)     If AMODE=64?
            SAM64 ,                         Put us in 64-Bit Mode
         ELSE ,
            IF (TM,TRGFLAG1,TRG1AM24,O)  If AMODE=24?
               N R14,=A(X'00FFFFFF')        And Strip High Byte
            ENDIF ,
         ENDIF ,
*
** Process Variable By Data Type
*
         ALGR R14,R15                  Add Base and Displacement
         XGR  R15,R15                  Zero Work Register
         IC   R15,TRPEDLEN             Get Length of Data
*
         MVC  DSARETRY,=A(FVARRTY)     Set Retry Routine
         IF (CLI,TRPETYP,EQ,C'C')  -*- For Character Data
            BCTR R15,0                 Decrement for Assembler
            EX  R15,CONMVC1            Move data to Print Line
            LA  R2,1(R15,R2)           Point Past Data
            LA  R3,TRPESLEN(,R3)       Point Past Var Entry
            SH  R4,=Y(TRPESLEN-1)      Decrement Count
         ENDIF ,
*
         IF (CLI,TRPETYP,EQ,C'Z')  -*- For Zoned Decimal
            BCTR R15,0                 Decrement for Assembler
            EX R15,CONMVC1             Move Data to Print Line
            LA R2,0(R15,R2)            Point Past Data
            OI 0(R2),X'F0'             Set Sign in Last Byte
            LA R2,1(,R2)               Point to next Blank
            LA R3,TRPESLEN(,R3)        Point Past Var Entry
            SH R4,=Y(TRPESLEN-1)       Decrement Count
         ENDIF ,
*
         IF (CLI,TRPETYP,EQ,C'F')  -*- For Fullword Data
            ICM R15,B'1111',0(R14)     Get Data to Print
            CVD R15,TRCWORKD           Get Data in Decimal
            MVC TRCWORKC,TRCECON       Set ED Constant
            ED  TRCWORKC,TRCWORKD      Get Character Numbers
            MVC 0(L'TRCECON,R2),TRCWORKC
            LA  R2,L'TRCECON(,R2)      Bump Output Pointer
            LA  R3,TRPESLEN(,R3)       Point Past Var Entry
            SH  R4,=Y(TRPESLEN-1)      Decrement Count
         ENDIF ,
*
         IF (CLI,TRPETYP,EQ,C'H')  -*- For Fullword Data
               XR  R15,R15             Zero Work Register
               ICM R15,B'0011',0(R14)  Get Data to Print
               CVD R15,TRCWORKD        Get Data in Decimal
               MVC TRCWORKC,TRCECON    Set ED Constant
               ED  TRCWORKC,TRCWORKD   Get Character Numbers
               MVC 0(L'TRCECON,R2),TRCWORKC
               LA  R2,L'TRCECON(,R2)   Bump Output Pointer
               LA  R3,TRPESLEN(,R3)    Point Past Var Entry
               SH  R4,=Y(TRPESLEN-1)   Decrement Count
         ENDIF ,
*
         IF (CLI,TRPETYP,EQ,C'P')  -*- For Packed Decimal
            BCTR R15,0                 Decrement for Assembler
            O  R15,=A(X'70')           Set Length of To Field
            EX R15,FVARZAP             Zap Data into TRCWORKD
            MVC TRCWORKC,TRCECON       Set ED Constant
            ED  TRCWORKC,TRCWORKD      Get Character Numbers
            MVC 0(L'TRCECON,R2),TRCWORKC
            LA  R2,L'TRCECON(,R2)      Bump Output Pointer
            LA  R3,TRPESLEN(,R3)       Point Past Var Entry
            SH  R4,=Y(TRPESLEN-1)      Decrement Count
         ENDIF ,
*
         IF (CLI,TRPETYP,EQ,C'X')  -*- For Hexidecimal
            N   R15,=A(X'0F')          Allow Max 16-Bytes
            LR  R5,R15                 Get Output Length +1
            SLL R5,1                   (Same)
            LA  R5,1(,R5)              (Same)
            MVC TRCWORKX,=32C' '       Space Fill Result
            LA R1,TRCWORKX             Get Output Location
            XC TRCWORKD,TRCWORKD       Zero Fill Work Area
            DO FROM=(R15)              Loop All Digits to Translate
               UNPK TRCWORKD(3),0(2,R14)    Unpack a Byte
               TR  TRCWORKD(2),HEXTABL-240  In Char Format
               MVC 0(2,R1),TRCWORKD         Put Output
               LA  R14,1(,R14)              Bump Input Ptr
               LA  R1,2(,R1)                Bump Output Ptr
            ENDDO ,
            MVC 0(L'TRCWORKX,R2),TRCWORKX
            LA R2,0(R5,R2)             Bump Output Pointer
            LA R3,TRPESLEN(,R3)        Point Past Var Entry
            SH R4,=Y(TRPESLEN-1)       Decrement Count
         ENDIF ,
*
FVARRTY  DS    0H
         SAM31 ,                       We Run in 31-Bit Amode
         IF (TM,LSENPSW1+2,X'40',O)    If We Were in ARMODE?
            SAC 000                    ..Sac Out - Back to Primary
         ENDIF
         LAM   R14,R14,=A(0)           Reset to Primary
         XC DSARETRY,DSARETRY          Set for no Retry
*
FVAR999  DS    0H
         SUBEXIT ,
*
*
*---------------------------------------------------------------------*
*                                                                     *
** DATA - Print The Data Areas Requested by This Trap                 *
*                                                                     *
*    This routine will print the data areas specified on the DATA=    *
*  parameter.  There may be multiple areas and each may have a title  *
*  to be printed priot to the title.  The data is formated in 16-byte *
*  hex dump format, so that it may easily be viewed on an 80-byte     *
*  wide screen.                                                       *
*                                                                     *
*---------------------------------------------------------------------*
*
         USING TRPDDATA,R4             Set Temp Addressability
*
DATA     SUBNTRY ,
         LA  R4,TRPMSG                 Point at Pre-formated Message
         XR  R3,R3                     Zero Work Register
         IF  (TM,TRPFLAG2,TRPFMSGS,O)  If MSG= Was Specified...
            ICM R3,B'0011',TRPMLNTH    Get Length of Message
         ENDIF ,
         LA  R4,0(R4,R3)               Point at Data Segment
*
         XR R5,R5                      Zero Work Register
         LH R5,TRPDCNT                 Count of DATA= Entries
         DO FROM=(R5)                  Loop For Each Entry
            MVC TRCPLINE,=CL256' '     Print Vertical Seperator
            GOSUB PRNT                 Print the Line
*
            MVC TRCPLINE,CONHEAD1      Set Heading Constant
            XGR R1,R1                  Zero Work Register
            IC  R1,TRPDTLEN            Get Length of Title
            IF  (LTR,R1,R1,NZ)         If We have a Heading?
               BCTR R1,0                  Decrement for Assembler
               EX R1,CONMVC2              Move in Heading
            ENDIF ,
            MVC TRCMSGWK,=CL256' '     Space Fill Area
            LH  R15,TRCINLVL           Get Index Level
            LA  R15,TRCMSGWK(R15)      Index to Area
            MVC 0(128,R15),TRCPLINE    Indent Message Text
            MVC TRCPLINE,TRCMSGWK      (Same)
            GOSUB PRNT                 Print the Line
*
            MVC TRCPLINE,CONHEAD2      Set heading Constant
            MVC TRCMSGWK,=CL256' '     Space Fill Area
            LH  R15,TRCINLVL           Get Index Level
            LA  R15,TRCMSGWK(R15)      Index to Area
            MVC 0(128,R15),TRCPLINE    Indent Message Text
            MVC TRCPLINE,TRCMSGWK      (Same)
            GOSUB PRNT                 Print the Line
*
            XGR R2,R2                  Zero Work Register
            XGR R3,R3                  (Same)
            ICM R2,B'0011',TRPDADRL    Get SCON Address of Data
            SRDL R2,12                 Get Displacement in R3
            SLL R2,2                   Base Register Times*4 in R2
            SRL R3,16                  Get DH+DL Displacement Fr SL3
            ICM R3,B'0100',TRPDADRH    (Same)
            SRL R3,4                   (Same)
            L   R1,LSENARGS(R2)        Load Access Register
            ST  R1,DSAWORKF            (Same)
            LAM AR2,AR2,DSAWORKF       (Same)
            SLL R2,1                   Base Register Times*8
            LG  R2,LSENGRGS(R2)        Get Base Address
            IF (TM,TRGFLAG1,TRG1AM31,O) If Caller in 31-Bit?
               LA R2,0(,R2)                Strip High Bit
            ENDIF ,
*                                   -*- Get Address of Data to Print
            AGR R2,R3                   Get Base Plus Dispamcement
            IF (TM,TRPDFLAG,TRPDFRDR,NZ)   If Redirection in Effect?
               IF (TM,TRPDFLAG,TRPDF64R,O) If 64-Bit Redirection?
                  LG R2,0(,R2)                Load Redirected Address
               ENDIF ,
               IF (TM,TRPDFLAG,TRPDF31R,O) If 31-Bit Redirection?
                  LGR R1,R2                   Move to Work Register
                  XGR R2,R2                   Xero high Word
                  L   R2,0(,R1)               Load Redirected Address
                  LA  R2,0(,R2)               Zero High Bit
               ENDIF ,
               IF (TM,TRPDFLAG,TRPDF24R,O) If 24-Bit Redirection?
                  LGR R1,R2                   Move to Work Register
                  XGR R2,R2                   Xero high Word
                  ICM R2,B'0111',1(R1)        Load Redirected Address
               ENDIF ,
            ENDIF ,
*                                   -*- Get Length of Data to Print
            XGR R3,R3                   Zero Work Register
            ICM R3,B'0011',TRPDATLN     Get Length of Data
            IF (TM,TRPDFLAG,TRPDFREG,O) If Length in Register?
               SLL R3,3                    Reg # Time*8
               LG  R3,LSENGRGS(R3)         Load Actual Length From GPR
            ENDIF ,
*
            BAS R14,PDAT               Print Data
*
            XGR R14,R14                Zero Work Register
            IC  R14,TRPDTLEN           Length of Title
            LA  R4,TRPDSLEN(R14,R4)    Point at Next Entry - If Any
         ENDDO ,
*
         MVC TRCPLINE,=CL128' '        Print Vertical Seperator
         GOSUB PRNT                    Print the Line
*
DATA999  DS    0H
         LAM   R2,R2,=A(0)             Reset to Primary
         SUBEXIT ,
         DROP  R3                      Drop Tempm Addressability
*
*---------------------------------------------------------------------*
*                                                                     *
** PDAT - Print Data for DATA= Parameter                              *
*                                                                     *
*    This routine prints the storage area requested on the DATA=      *
*  parameter in a hex dump format with 16-bytes per line.  The        *
*  format is the following:                                           *
*                                                                     *
*     Address  Offs Data in Hex                          Data in Char *
*     =============================================================== *
*  D) 00010340 0010 00000000 11111111 00000000 11111111  *abcd..wxyz* *
*  D) 00010350 0020 00000000 11111111 00000000 11111111  *abcd..wxyz* *
*  D) 00010360 0020 00000000 11111111 00000000 11111111  *abcd..wxyz* *
*                                                                     *
*  Inputs:  R2 - Address of Data to Print                             *
*           R3 - Length  of Data to Print                             *
*                                                                     *
*---------------------------------------------------------------------*
*
PDAT     SUBNTRY ,
         XR R6,R6                          Zero Work Register
         LR R1,R2                          Get Address of End of Area
         AR R1,R3                          (Same)
         ST R1,TRCENDAT                    (Same)
         XC TRCEACMP,TRCEACMP              Indicate No Abends
         XC TRCEACNT,TRCEACNT              (Same)
*
         DO INF
            MVI TRCPLINE,C' '              Space Fill Print Line
            MVC TRCPLINE+1(L'TRCPLINE-1),TRCPLINE
*
*                                      -*- Export Address
            STG  R2,TRCWORKD               Get Address of Area
            UNPK TRCWKCL9,TRCWORKD(5)      In Hexadecimal
            TR   TRCWKCL9(8),HEXTABL-240   (Same)
            MVC  TRCPLINE+4(8),TRCWKCL9    Move to Print Line
            MVI  TRCPLINE+12,C'_'          Set Seperator
*
            UNPK TRCWKCL9,TRCWORKD+4(5)    In Hexadecimal
            TR   TRCWKCL9(8),HEXTABL-240   (Same)
            MVC  TRCPLINE+13(8),TRCWKCL9   Move to Print Line
*
*                                      -*- Export Offset
            ST   R6,TRCWORKF               Get Address of Area
            UNPK TRCWKCL9,TRCWORKF(5)      In Hexadecimal
            TR   TRCWKCL9(8),HEXTABL-240   (Same)
            MVC  TRCPLINE+22(4),TRCWKCL9+4 Move to Print Line
*
** Get a Line of Data to Print
*
            XC TRCWKC16,TRCWKC16       Get Data to Print
            LA R14,TRCWKC16            Output Pointer
            LA R15,TRCPLINE+28         Output Pointer
*
            DO FROM=(R7,4)             Loop 4 Times Max
               XC  TRCWORKF,TRCWORKF       Begin With Zeros
*
               MVC DSARETRY,=A(PDATR) *tempSet Retry Routine
               IF (TM,LSENPSW1+2,X'40',O)  If We Were in ARMODE?
                  SAC 512                  ..Sac In - To Get Data
               ENDIF
               IF (TM,TRGFLAG1,TRG1AM64,O) If AMODE=64?
                  SAM64 ,                     Put us in 64-Bit Mode
               ELSE ,
                  IF (TM,TRGFLAG1,TRG1AM24,O) If AMODE=24?
                     N R14,=A(X'00FFFFFF')    And Strip High Byte
                  ENDIF ,
               ENDIF ,
*
               IF (TM,TRPDFLAG,TRPDFRAD,O) If A Real Storage Address?
                  LURA R1,R2               ..Move From Real Address
                  ST   R1,0(R14)           ..(Same)
               ELSE ,                      Else
                  MVC 0(1,R14),0(R2)       ..Move From Virtual Address
                  MVC 1(1,R14),1(R2)       ..(Same)
                  MVC 2(1,R14),2(R2)       ..(Same)
                  MVC 3(1,R14),3(R2)       ..(Same)
               ENDIF ,
*
               XC DSARETRY,DSARETRY        Set for no Retry
               SAM31 ,                     We Run in 31-Bit Amode
               IF (TM,LSENPSW1+2,X'40',O)  If We Were in ARMODE?
                  SAC 000                  ..Sac Out - Back to Primary
               ENDIF
*
               MVC TRCWORKF,0(R14)         (Same)
               UNPK TRCWKCL9,TRCWORKF(5)   In Hexadecimal
               TR  TRCWKCL9(8),HEXTABL-240 (Same)
               MVC 0(8,R15),TRCWKCL9       Move to Print Line

               IF (CLC,TRCEACMP,NE,=3X'0') If We've Abended
                  DOEXIT ,                 -> We're Done
               ENDIF
*
               LA  R2,4(,R2)           Bump Input Pointer
               IF (C,R2,GE,TRCENDAT)   If Past End
                  DOEXIT ,             -> Done
               ENDIF ,
               LA  R14,4(,R14)         Bump Output Pointer
               LA  R15,9(,R15)         Bump Output Pointer
            ENDDO ,
*
            MVI TRCPLINE+65,C'*'       Set Seperator
            TR  TRCWKC16,TRTABL        Make Data Printable
            MVC TRCPLINE+66(16),TRCWKC16   Move Data to PLINE
            MVI TRCPLINE+82,C'*'       Set Seperator
            MVC TRCMSGWK,=CL256' '     Space Fill Area
            LH  R15,TRCINLVL           Get Index Level
            LA  R15,TRCMSGWK(R15)      Index to Area
            MVC 0(128,R15),TRCPLINE    Indent Message Text
            MVC TRCPLINE,TRCMSGWK      (Same)
            GOSUB PRNT                 Print the Line
*
            IF (CLC,TRCEACMP,NE,=3X'0')  If We've Abended
               GOSUB PRNT                Print the Line
               DOEXIT ,                  -> We're Done
            ENDIF
            AH R6,=Y(16)               Bump Offset
            SH R3,=Y(16)               Decr Length
            IF (CH,R3,LE,=H'0')        If At End of Data?
               DOEXIT ,                Yes -> Done
            ENDIF ,
         ENDDO ,
         B  PDAT999                    -> Done
*
** Here on Bad Data
*
PDATR    DS 0H                         Retry Address
         XC DSARETRY,DSARETRY          ..Set for no Retry
         SAM31 ,                       ..We Run in 31-Bit Amode
         SAC 000                       ..Back to Primary
*
         LA  R15,TRCPLINE+28           Output Pointer
         MVC 0(36,R15),=CL36'(Bad Address Encountered)'
         LH  R15,TRCINLVL              Get Index Level
         LA  R15,TRCMSGWK(R15)         Index to Area
         MVC 0(128,R15),TRCPLINE       Indent Message Text
         MVC TRCPLINE,TRCMSGWK         (Same)
         GOSUB PRNT                    Print the Line
*
** Return to Caller
*
PDAT999  DS    0H
         SUBEXIT ,
*
*---------------------------------------------------------------------*
*                                                                     *
** PRNT - Write a Line of Output                                      *
*                                                                     *
*    This routine is called to write a line of output.  That output   *
*  line may be written to the sysout dataset for the task, or to the  *
*  print buffer if BUFFER=YES was specified on the OPEN request.      *
*                                                                     *
*---------------------------------------------------------------------*
*
PRNT     SUBNTRY ,
         IF (TM,TRCBFLAG,TRCBBFON,Z)    If Not Buffering?
            PUT TRCDCB,TRCPLINE         Yes -> Print Line
         ELSE
            L   R1,TRCBUFCR               Get Current Position
            MVC 0(L'TRCPLINE,R1),TRCPLINE Move Line to Buffer
            LA  R1,L'TRCPLINE(,R1)        Point at Next Slot
            IF (C,R1,LT,TRCBUFND)       Past End of Buffer
               ST R1,TRCBUFCR           Set Next Slot Pointer
            ELSE
               MVC TRCBUFCR,TRCBUFAD    Set First Slot as Next
            ENDIF
         ENDIF
*
PRNT999  DS    0H
         SUBEXIT ,
*
*---------------------------------------------------------------------*
*                                                                     *
** LTRC - Locate the TRCDSECT AREA for the Current Task if it Exists  *
*                                                                     *
*   This routine will loop through the RME DSECTS for the current     *
* TCB looking for the Entry for RDHRESEX.  If found it will return    *
* the address of TRCDSECT in R8.  If not found R8 will be zero on     *
* exit.                                                               *
*                                                                     *
*---------------------------------------------------------------------*
*
         USING TCB,R14                 TCB  Addressability
         USING STCB,R15                STCB Addressability
         USING RMEDSECT,R1             RME  Addressability
*
LTRC     SUBNTRY ,
         XR    R8,R8                   Assume Not Found
*
         L     R14,PSATOLD             Address of our TCB
         L     R15,TCBSTCB             Address of STCB
         L     R1,STCBRMEF             Get RESMGR Queue
*
         DO WHILE=(LTR,R1,R1,NZ)       Loop RME Chain
            IF (CLC,RMEPARAM,EQ,=C'RDHT')   If This is Our Exit...
               L  R8,RMEPARAM+4             ..Get Address of TRCDSECT
               DOEXIT ,                     ..And Exit
            ENDIF
            L  R1,RMEFWDPT             Get Next RME on Chain
         ENDDO ,                       -> Loop
*
** Exit LDCB
*
LTRC999  DS    0H
         SUBEXIT ,
         DROP  R14,R15,R1              Drop Temp Addressability
*
*---------------------------------------------------------------------*
*                                                                     *
** LDCB - Locate Our Open DCB by running the DEB Chain off the TCB    *
*                                                                     *
*   This routine will loop through the DEB chain off the current TCB  *
* looking for an open DCB that belong to this Tracing Facility.  If   *
* found it will locate the address of the TRC Persistant Data Area,   *
* within which the DCB resides, and return that address in R8.        *
*                                                                     *
** Note: This routine is no longer executed.  It is left here for     *
*        reference purposes only.  It has been replaced with LTRC     *
*        which provides a better means of locating the TRCDSECT area  *
*        for the current task.                                        *
*                                                                     *
*---------------------------------------------------------------------*
*
         USING DEBBASIC,R1             ..And Addressability
         USING IHADCB,R2               Get DCB Addressability
         USING TCB,R14                 ..And Addressability
*
LDCB     SUBNTRY ,
         XR R8,R8                      Zero Innitial Pointer
         XR R1,R1                      Zero Work Register
         XR R2,R2                      (Same)
         L  R14,PSATOLD                Load Our TCB Address
*
         IF (ICM,R1,7,TCBDEB+1,NZ)     Get Address of 1st DEB?
            DO WHILE=(LTR,R1,R1,NZ)    Loop Thru DEB Chain
               ICM R2,B'0111',DEBECBB  Load DCB Address
*
               LA R3,TRCDCBID-TRCDCB(,R2)   Get Addr of Idetifier @RDH
               IF (CLC,=C'TRAC',EQ,0(R3))   Is This Our DCB?      @RDH
                  LR R8,R2                  Get Address of TRCDSECT
                  SH R8,=Y(TRCDCB-TRCDSECT) Get TRCDSECT Address
                  DOEXIT ,                  -> Done
               ENDIF
*
               ICM R1,B'0111',DEBDEBB  Get Next DEB on Chain
            ENDDO
         ENDIF
*
** Exit LDCB
*
LDCB999  DS    0H
         SUBEXIT ,
         DROP  R1,R2                   Drop Temp Addressability
*
***********************************************************************
*  Literials and Constants
***********************************************************************
*
         CONBEG ,                      Define literal Pool
*
*
CONMVC1  MVC 0(*-*,R2),0(R14)          Move Data to Print Line
CONMVC2  MVC TRCPLINE+28(*-*),TRPDTITL Move Title
FVARZAP  ZAP TRCWORKD(*-*),0(*-*,R14)  Executed Instruction
*
MDLRDJSC RDJFCB (*-*),MF=L             Define model for RDJFCB
MDLRDJSL EQU  *-MDLRDJSC               (Same)
*
MDLOPL   OPEN  (*-*,(OUTPUT)),MF=L     Define Model for OPEN
MDLOPLL  EQU   *-MDLOPL                (Same)
*
MDLDCB   DCB   DDNAME=TRCPRINT,        Define Trace DCB                *
               LRECL=128,BLKSIZE=1280, (Same)                          *
               RECFM=FB,DSORG=PS,      (Same)                          *
               MACRF=PM,EXLST=*-*      (Same)
MDLDCBL  EQU   *-MDLDCB                (Same)
*
MDLRESM  RESMGR ADD,TYPE=ADDRSPC,      Define Model for RESMGR         *
               ROUTINE=(LINK,*-*),     (Same)                          *
               PARAM=*-*,              (Same)                          *
               TOKEN=*-*,MF=L          (Same)
MDLRESML EQU   *-MDLRESM               (Same)
*
TRCECON  DC    X'402020206B2020206B2020206B2020206B202120'
*                    12345678901234567890123456789012345678901234567890
*              23456789012345678901234567890123456789012345678901234567
*              90123456789012345678
CONTITLE DC    CL128'00/00/00         SYS00000 - Label Level Tracing - *
               TCB: 00000000'
CONABEND DC    CL128'    ***> An abend occured while attempting to acce*
               ss this data.'
CONHEAD1 DC    CL128'    64-Bit Address    Ofst '
CONHEAD2 DC    0CL128
         DC    CL4' ',79C'=',CL43' '
*
         DS    0D
TRTABL   DS    256C'.'                 Translate Table
         ORG   TRTABL+C'A'
         DC    C'ABCDEFGHI'
         ORG   TRTABL+C'J'
         DC    C'JKLMNOPQR'
         ORG   TRTABL+C'S'
         DC    C'STUVWXYZ'
         ORG   TRTABL+C'a'
         DC    C'abcdefghi'
         ORG   TRTABL+C'j'
         DC    C'jklmnopqr'
         ORG   TRTABL+C's'
         DC    C'stuvwxyz'
         ORG   TRTABL+C'0'
         DC    C'0123456789'
         ORG   TRTABL+C'@'
         DC    C'@'
         ORG   TRTABL+C'#'
         DC    C'#'
         ORG   TRTABL+C'$'
         DC    C'$'
         ORG   TRTABL+C','
         DC    C','
         ORG   TRTABL+C'/'
         DC    C'/'
         ORG   TRTABL+C'-'
         DC    C'-'
         ORG   TRTABL+C':'
         DC    C':'
         ORG   ,
*
HEXTABL  DC    C'0123456789ABCDEF'     Hex Translate Table
*
 print gen
         CONEND ,
 print nogen
*
***********************************************************************
* Define Dynamic Storage Area - DSA
***********************************************************************
*
         DSABEG ,                 <*** Begin Dynamic Storage Area
*
DSATRGAD DS    A                       Addr of TRGDSECT Area
DSASVKEY DS    X                       Key of Calling Program
DSALSTPP DS    B                       Linkage Stack Type
*
DSASAVR1 DS    A                       Register Save Area
DSAPADDR DS    A                       Address of Fr: Point
DSAPOFST DS    A                       Offset  of Fr: Point
DSAPLNAM DS    CL8                     Load Module Name
DSAPCNAM DS    CL8                     CSECT Name
DSAPEP   DS    A                       Entry Point Address
DSAEPSW1 DS    CL8                     PGME PSW On Entryss
*
         DSAEND ,                 <*** End Dynamic Storage Area
         DROP ,                        Drop Everything
*
***********************************************************************
*                                                                     *
** RDHDSAVE - Build TRCDAREA Dsect for Savearea Chain/Stack Entries   *
*                                                                     *
*    This program is called by RDHTRACE and RDHADIAG to obtain a      *
*  table of all saveareas or linkage stack entries in the chain.      *
*  The results of this call are placed into TRCDAREA pointed to by    *
*  TRCDADDR in TRCDSECT.                                              *
*                                                                     *
*  On Entry: R1 -> TRCDSECT                                           *
*                                                                     *
*                                                                     *
***********************************************************************
*
         USING PSA,R0                Setup PSA      Addressability
*
RDHDSAVE PGMNTRY TYPE=MAIN,          Establish Main Entry Point        *
               BASE=(R12,R11),       (Same)                            *
               ESTAE=YES,            (Same)                            *
               TRACE=NO,PRINT=GEN
*
         L     R10,0(,R1)            Get TRCDSECT Address
         ST    R10,DSATADDR          Save Address in DSA
*
         GOSUB DBLD                  Do Main Processing
*
** Return to Caller
*
         PGMEXIT RC=0                Return to Caller
*
*=====================================================================*
** DBLD - Build TRCDAREA Area From Savearea Chain - TCBFSA            *
*=====================================================================*
*
* R10 - Current Linkage Stack Entry
* R9  - Current Savearea Address
* R8  - Current Position in TRCDAREA Table
* R7  - Current Count of Entries Processed
* R6  - Previous Linkage Stack Entry
*
         USING LSED,R10                Current LSED Entry
         USING LSEN,LSED+LSEDLNTH      Current LSEN Addressabliity
         USING TRCDAREA,R8             And Addressability
*
DBLD     SUBNTRY ,
         L     R8,DSATADDR               Get TRCDSECT Address
         L     R8,TRCDADDR-TRCDSECT(,R8) Get TRCDAREA Address
         XR    R7,R7                     Start With Zero Count
*
         LA    R14,TRCDNTRY              Get Address of 1st Entry
         L     R15,=A(TRCDSIZE-TRCPLTH) Get Length to Clear
         XR    R0,R0                     Zero Work Registers
         XR    R1,R1                     (Same)
         MVCL  R14,R0                    Clear Storage - Start Fresh
         XC    TRCDCNT,TRCDCNT           (Same)
*
         L  R14,PSATOLD                Get Current TCB Addreee
         USING TCB,R14                 And Addressability
         L  R15,TCBSTCB                Get STCB Address
         USING STCB,R15                And Addressability
*
         L  R9,TCBFSA                  Get First Savearea
         L  R10,STCBESTK               Get Linkate Stack Address
*
         MVC TRCDLMOD,=CL8'Zos'        Initialize First Entry
         MVC TRCDEPAD,12(R9)           Save Return Address
         MVC TRCDCSCT,=CL8'Zos'        (Same)
         MVC TRCDCSEP,12(R9)           Save Return Address
         MVC TRCDRTLM,=CL8'Zos'        (Same)
         MVC TRCDRTCS,=CL8'Zos'        (Same)
         MVC TRCDRTAD,12(R9)           Save Return Address
         NI  TRCDRTAD,X'7F'            Strip High Bit
         NI  TRCDRTAD+3,X'FE'          Strip Low Bit For 64-Bit
         ST  R9,TRCDR13                Save R13 Address
         LA  R7,1(,R7)                 First Savearea Always There
         LA  R8,TRCDLNTH(,R8)          Bump to Next TRCDAREA Area
         L   R9,8(,R9)                 Get First Pgm Savearea
*
** Loop Through All Saveareas from TCBFSA
*
         DO UNTIL=(LTR,R9,R9,Z)        Loop to End of Chain?
            IF (CLC,=C'F1SA',EQ,4(R9)) If Regs on Linkage Stack?
               GOSUB DLNS              Get TRCDAREA Data from LSEN
               LR R6,R10               Save Prev LSEN Entry
               AH R10,LSEDNES          Bump to next Stack Entry
               L  R9,8(,R9)            Bump to Next Savearea
            ELSE ,
               GOSUB DSAV              Get TRCDAREA Data From Savearea
               L  R9,8(,R9)            Bump to Next Savearea
            ENDIF ,
*
*
            LA R8,TRCDLNTH(,R8)          Bump to Next TRCDAREA Area
            LA R7,1(,R7)                 Increment Count
         DOEXIT (CH,R7,GE,=Y(TRCDMAXC))  Exit if Maxed Out
         ENDDO ,
*
** Show Table Built in Traces
*
         L     R8,DSATADDR               Get TRCDSECT Address
         L     R8,TRCDADDR-TRCDSECT(,R8) Get TRCDAREA Address
         ST    R7,TRCDCNT                Save Count
*
DBLD999  DS    0H
         SUBEXIT ,
         DROP  R14,R15                 Drop temp Addressability
*
*=====================================================================*
** DLNS - Get Data From Linkage Stack Entry                           *
*=====================================================================*
*
DLNS     SUBNTRY ,
         XC    TRCDNTRY(TRCDLNTH),TRCDNTRY Initialize Entry
*
         MVC TRCDCSEP,LSENGR15+4       Get EP Address
         NI  TRCDCSEP,X'7F'            Strip High Bit
         MVC TRCDRTAD,LSENGR14+4       Get Return Address
         NI  TRCDRTAD,X'7F'            Strpi High Bit
         NI  TRCDRTAD+3,X'FE'          Strip Low Bit For 64-Bit
         MVC TRCDCSCT,=CL8'UNKNOWN'    Initialize Csect Name
         ST  R10,TRCDLSEN              Save Linkage Stack Entry Addr
*
         MVC DSARETRY,=A(DLNSRTR1)     Establish Recovery
         L   R1,TRCDCSEP               Get Csect Entry Point
         IF (CLI,0(R1),EQ,X'47'),OR,   If Standard Branch Around EYE   *
               (CLI,0(R1),EQ,X'A7')    (Same)
            MVC TRCDCSCT,5(R1)         Get Csect Name
            MVC TRCDPGID,=32C' '       Space Fill Receiving Field
            XR  R14,R14                Zero Work Register
            IC  R14,4(,R1)             Get Length Of Program ID
            BCTR R14,0                 Decrement for Assembler
            IF (CH,R14,GT,=Y(L'TRCDPGID-1)) If Greater than Max?
               LH R14,=Y(L'TRCDPGID-1)      ..Use Max
            ENDIF
            EX  R14,CONMVC3            Move Program ID Data
         ELSE  ,
DLNSRTR1    DS  0H                     Recover Here on Abend
            MVC TRCDCSEP,=A(0)         Set TRCCSEP to ZERO
         ENDIF ,
         MVC DSARETRY,=A(0)            Terminate Recovery
*
         GOSUB DCDS                    Get LMOD Name & EP Address
         MVC TRCDLMOD,DSACLMOD         Set LMOD Name
         MVC TRCDEPAD,DSACEPAD         Set LMOD EP Address
*
         L  R1,TRCDRTAD                Load return Address
         IF (CLC,=X'0A03',EQ,0(R1))    If Initiator Return?
            MVC TRCDRTLM,=CL8'Zos'     ...Indicate Return to Zos
            MVC TRCDROFS,=F'0'         ...(Same)
         ELSE ,
            L  R1,TRCDCSEP             Get Csect Offset Into LMOD
            S  R1,TRCDEPAD             (Same)
            ST R1,TRCDCOFS             (Same)
         ENDIF
*
** Do Return Addresses
*
         L  R2,LSENGR13+4              Get Callers R13
         L  R2,8(,R2)                  Get F1SA Savearea Address
         ST R2,TRCDR13                 Save Address in TRCDAREA
*
         L  R1,TRCDRTAD                Get Csect Entry Point
         IF (CLC,=X'0A03',EQ,0(R1))    If Initiator Return?
            MVC TRCDRTLM,=CL8'Zos'     ...Indicate Return to Zos
            MVC TRCDRTCS,=CL8' '       ...(Same)
            MVC TRCDROFS,=F'0'         ...(Same)
         ELSE ,
            L  R1,TRCDRTAD               Get Return Address
            GOSUB DCDS                   Get LMOD Name & EP Address
            MVC TRCDRTLM,DSACLMOD        Set Return LMOD Name
*
            L R14,TRCDR13                Savearea Address
            IF (CLC,=C'F1SA',EQ,4(R14))  If Callers Caller in F1SA?
               L R15,LSENGR15-LSEN+8+4(R6)
            ELSE ,                       Else
               L R15,4(,R14)             ...Get His EP From Savearea
               L R15,16(,R15)            ...(Same)
            ENDIF ,

            MVC DSARETRY,=A(DLNSRTR2)    Establish Recovery
            IF (CLI,0(R15),EQ,X'47'),OR, If Standard Branch Around EYE *
               (CLI,0(R15),EQ,X'A7')     (Same)
               MVC TRCDRTCS,5(R15)       Get Csect Name
               L  R14,TRCDRTAD           Get Offset Into LMOD
               SR R14,R15                (Same)
               ST R14,TRCDROFS           (Same)
            ELSE  ,
DLNSRTR2       DS  0H                    Recover Here on Abend
               MVC TRCDROFS,=A(0)        Set TRCDROFS to Zero
            ENDIF ,
            MVC DSARETRY,=A(0)           Terminate Recovery
         ENDIF
*
** Return to Caller
*
DLNS999  DS    0H
         SUBEXIT ,
*
*=====================================================================*
** DSAV - Get Data From Standard O/S Savearea                         *
*=====================================================================*
*
D        USING DSA,R14                 Callers DSA  Addressability
*
DSAV     SUBNTRY ,
         XC    TRCDNTRY(TRCDLNTH),TRCDNTRY Initialize Entry
*
** Get Csect information
*
         L   R14,4(,R9)                Get Previous Savearea
         ST  R9,TRCDR13                Set R13 Value Callers Savearea
         MVC TRCDCSEP,D.DSASVR15       Get EP Address
         NI  TRCDCSEP,X'7F'            Strpi High Bit
         MVC TRCDRTAD,D.DSASVR14       Get Return Address
         NI  TRCDRTAD,X'7F'            Strpi High Bit
         NI  TRCDRTAD+3,X'FE'          Strip Low Bit For 64-Bit
         MVC TRCDCSCT,=CL8'UNKNOWN'    Initialize Csect Name
         L   R1,TRCDCSEP               Get Csect Entry Point
         IF (CLI,0(R1),EQ,X'47'),OR,   If Standard Branch Around EYE   *
               (CLI,0(R1),EQ,X'A7')    (Same)
            MVC TRCDCSCT,5(R1)         Get Csect Name
            MVC TRCDPGID,=32C' '       Space Fill Receiving Field
            XR  R14,R14                Zero Work Register
            IC  R14,4(,R1)             Get Length Of Program ID
            BCTR R14,0                 Decrement for Assembler
            IF (CH,R14,GT,=Y(L'TRCDPGID-1)) If Greater than Max?
               LH R14,=Y(L'TRCDPGID-1)      ..Use Max
            ENDIF
            MVC TRCDPGID(*-*),5(R1)    Get Program ID Area
            EX  R14,*-6                Move Program ID Data
         ENDIF ,
*
         L   R1,TRCDCSEP               Get Csect Entry Point
         GOSUB DCDS                    Get LMOD Name & EP Address
         MVC TRCDLMOD,DSACLMOD         Set LMOD Name
         MVC TRCDEPAD,DSACEPAD         Set LMOD EP Address
         L  R1,TRCDCSEP                Get Csect Offset Into LMOD
         S  R1,DSACEPAD                (Same)
         ST R1,TRCDCOFS                (Same)
*
** Do Return Addresses
*
         L   R1,TRCDRTAD               Get Csect Entry Point
         IF (CLC,=X'0A03',EQ,0(R1))    If Initiator Return?
            MVC TRCDRTLM,=CL8'Zos'     ...Indicate Return to Zos
            MVC TRCDRTCS,=CL8' '       ...(Same)
            MVC TRCDROFS,=F'0'         ...(Same)
         ELSE ,
            L  R1,TRCDRTAD               Get Return Address
            GOSUB DCDS                   Get LMOD Name & EP Address
            MVC TRCDRTLM,DSACLMOD        Set Return LMOD Name
*
            L R14,4(,R9)                 Get Previous Savearea
            L R14,TRCDR13                Savearea Address
            IF (CLC,=C'F1SA',EQ,4(R14))  If Callers Caller in F1SA?
               L R15,LSENGR15-LSEN+8+4(R6)
            ELSE ,                       Else
               L R15,4(,R14)             ...Get His EP From Savearea
               L R15,16(,R15)            ...(Same)
            ENDIF ,

            IF (CLI,0(R15),EQ,X'47'),OR, If Standard Branch Around EYE *
               (CLI,0(R15),EQ,X'A7')     (Same)
               MVC TRCDRTCS,5(R15)       Get Csect Name
               L R14,TRCDRTAD            Get Offset Into LMOD
               SR R14,R15                (Same)
               ST R14,TRCDROFS           (Same)
            ENDIF ,
         ENDIF
*
** Return to Caller
*
DSAV999  DS    0H
         SUBEXIT ,
         DROP  D                       Drop Temp Addressability
*
*---------------------------------------------------------------------*
*                                                                     *
** DCDS - Locate CDE and Extent List for Address                      *
*                                                                     *
*    This routine is given an storage address and attempts to find    *
*  the load module that is loaded at that address.  It runs the CDE   *
*  chain to the extent list and and checks the address against the    *
*  storage extent.                                                    *
*                                                                     *
*  On Input:  R1       -> Address to Locate                           *
*  On Output: DSACLMOD -> CDNAME of LMOD or Blanks                    *
*  On Output: DSACEPAD -> Entry Point Address of LMOD or Zero         *
*                                                                     *
*---------------------------------------------------------------------*
*
         USING TCB,R14                 Get TCB Addressability
         USING CDENTRY,R15             Get CDE Addressability
         USING XTLST,R2                Get XTLST Addressability
*
DCDS     SUBNTRY ,
         MVC DSACLMOD,=CL8' '          Space Fill Receiving Field
         MVC DSACEPAD,=F'0'            (Same)
*
         L  R14,PSATOLD                Load Our TCB Address
         L  R14,TCBJSTCB               CDE's Are Anchored Off JSTCB
         IF (ICM,R15,15,TCBJPQ,NZ)     Get First CDE on Chain
            DO INF                     Do Forever...
               L  R2,CDXLMJP           Get Extent Pointer
               XR R14,R14              Zero Work Register
               ICM R14,7,XTLMSBLN      Get Length of Extent
               AL  R14,XTLMSBAD        Plus Address for End Pointer
*
               IF (C,R1,GE,XTLMSBAD)   If Greater Than Beginning
                  IF (CR,R1,LT,R14)    And Less Than End
                     MVC DSACLMOD,CDNAME   Save CDNAME
                     MVC DSACEPAD,CDENTPT  Save EP Address
                     NI  DSACEPAD,X'7F'    Strip High Bit
                     DOEXIT ,              -> Done
                  ENDIF
               ENDIF
*
               L  R15,CDCHAIN          Get next CDE Entry
               IF (LTR,R15,R15,Z)      End of Chain?
                  DOEXIT ,             Yes -> Done
               ENDIF
            ENDDO
         ENDIF
*
DCDS999  DS    0H
         SUBEXIT ,
         DROP  R14,R15,R2              Drop Temp Bases
*
***********************************************************************
* Define Literials and Constants                                      *
***********************************************************************
*
         CONBEG ,
*
CONMVC3  MVC TRCDPGID(*-*),5(R1)    Get Program ID Area
*
         CONEND ,
*
***********************************************************************
* Define Dynamic Storage Area                                         *
***********************************************************************
*
         DSABEG ,                      Define DSA Prefix
*
DSALSTYP DS    X                       Linkage Stack Type PC/BAKR
DSATADDR DS    A                       Address of TRCDSECT
DSACLMOD DS    CL8                     DCDE - CLMOD Name
DSACEPAD DS    A                       DCDE - EP Address
*
         DSAEND ,                      Define DSA Suffix
         DROP ,                        Drop Everything
*
***********************************************************************
*                                                                     *
*  RDHABEND - Print ABEND Diagnostics - Covers 1st TYPE=MAIN Program  *
*                                                                     *
*            This routine gets control in the event of an abend       *
*          situation in the initiating program.  The ESTAE is         *
*          initiated for the first TYPE=MAIN program to be executed   *
*          for the current task when the TRCDSECT is built.  Any      *
*          subsequent TYPE=MAIN program will be covered by the        *
*          initial ESTAE.                                             *
*            The purpose of this recovery routine is to print         *
*          diagnostics for the ABEND to TRCPRINT to assist the user   *
*          to diagnose the problem in their code.                     *
*            There is no attempt to recover from the error.           *
*            On Entry SDWAPARM will contain the address of the        *
*          TRCDSECT for the current task which is needed to get to    *
*          the TRCPRINT DCB or the in-storage buffer address if       *
*          buffering is in effect.                                    *
*            There is no need to clean up at this point because the   *
*          Resource Manager will perform those duties shortly after   *
*          the completion of this function.                           *
*                                                                     *
*          Input Parameters:                                          *
*            R0 - Code, 12 If no SDWA                                 *
*            R1 - Address of SDWA                                     *
*           R13 - Savearea Address                                    *
*           R14 - Return Address                                      *
*           R15 - Entry Point Address                                 *
*                                                                     *
*          OUTPUT:                                                    *
*           R15 - RETURN CODE, 0-Continue W/Termination               *
*                                                                     *
*                                                                     *
***********************************************************************
*
RDHABEND CSECT ,                        Define Control Section
RDHABEND AMODE 31
RDHABEND RMODE ANY
         CHI   R0,12                    Is SDWA Available?
         BZR   R14                      No -> Percolate
*
** Have SDWA Continue Processing
*
         STMG  R14,R12,16(R13)          Save Registers
         LGR   R12,R15                  Load Base Register
         SRL   R12,1                    Zero Low Bit For 64Bit ESTAEX
         SLL   R12,1                    (Same)
         USING RDHABEND,R12             (Same)
*
         LGR   R9,R1                    Get SDWA Address
         USING SDWA,R9                  And Addressability
         LGR   R10,R2                   Get TRCDSECT Address
         USING TRCDSECT,R10             And Addressability
*
         SAM31 ,                        We Run in 31
         LA    R11,TRCABSAV             Get Our Savearea Address
         ST    R13,4(,R11)              Store His in Ours
         ST    R11,8(,R13)              Store Ours in His
         LR    R13,R11                  Setup Our Standard Savearea
*
** Call RDHADIAG to Print Abend Diagnostics
*
         CALL  RDHDSAVE,                Build TRCDAREA For This Call   *
               ((R10)),                 Passing TRCDSECT Address       *
               MF=(E,TRCPLIST)          (Same)
*
         CALL  RDHADIAG,                Call Diagnostic Program        *
               ((R10)),VL,              Pass SDWA Address              *
               MF=(E,TRCPLIST)
         L     R13,4(,R13)              Restore Savearea on Entry
         LR    R1,R9                    Restore SDWA Address
*
** Return to Caller - Percolate
*
TRCATERM DS    0H                   -*- Continue With Termination
         SETRP RC=0                     Return to Supervisor
         LMG   R14,R12,16(R13)          Restore Registers
         XGR   R15,R15                  Percolate
         BR    R14                      -> Return
*
         LTORG ,
*
         ORG RDHABEND+(*-RDHABEND+255)/256*256 Round to 256-Byte Bndry
         DS  0H
         DROP ,
*
***********************************************************************
** RTM2WA - RTM 2nd level Workatea - No DSECT Available - Fake it     *
***********************************************************************
*
RTM2WA   DSECT ,
RTM2PREV EQU   RTM2WA+X'162',4,C'A'  Address of Previous RTM2WA
RTM2SDW1 EQU   RTM2WA+X'354',4,C'A'  Address of Related SDWA
RTM2ANCH EQU   RTM2WA+X'3E4',4,C'A'  Address of Original RTM2WA
*
***********************************************************************
*                                                                     *
** RDHADIAG - Print Diagnostics for Abending Program                  *
*                                                                     *
*    This program is called from RDHABEND to print diagnostics for    *
*  the abending program to TRCPRINT.                                  *
*                                                                     *
*                                                                     *
***********************************************************************
*
         USING PSA,R0                  PSA  Addressability
         USING TRCDSECT,R10            TRC  Main Data Area
         USING RTM2WA,R9               RTM2WA  Addressability
         USING SDWA,R8                 SDWA Addressability
*
RDHADIAG PGMNTRY TYPE=MAIN,TRACE=NO,   Establish Program Linkage       *
               ESTAE=YES,              ESTAE Recovery Support          *
               BASE=(R12,R11,R7)
*
C        USING TRCDNTRY,TRCCNTRY       Current TRCDAREA Entry
P        USING TRCDNTRY,TRCPNTRY       Previous TRCDAREA Entry
*
         L     R10,0(,R1)              Get Address of TRCDSECT
*
         GOSUB DINIT                   Do Initialization
         GOSUB DPROC                   Go Print Diagnostics
         GOSUB DTERM                   Do Termination
*
  MVC DSARETRY,=A(TRCAD999) *temp
  DC H'0'
*
** Return From Here to Percolate
*
TRCAD999 DS    0H
         PGMEXIT RC=0
*
*=====================================================================*
** DINIT - Do Initialization Processing                               *
*=====================================================================*
*
DINIT    SUBNTRY ,
*
** Get Caller's Registers
*
         L     R1,TRCDADDR              Get TRCDAREA Address
         USING TRCDAREA,R1              And Temp Addressability
         L     R14,TRCDCNT              Get Last TRCDAREA Entry-Current
         SH    R14,=Y(1)                (Same)
         MH    R14,=Y(TRCDLNTH)         (Sama)
         LA    R14,TRCPLTH(R14,R1)      (Same)
         MVC   TRCCNTRY,0(R14)          (Same)
         L     R15,TRCDCNT              Get Prev TRCDSECT Entry-Caller
         SH    R15,=Y(2)                (Same)
         MH    R15,=Y(TRCDLNTH)         (Same)
         LA    R15,TRCPLTH(R15,R1)      (Same)
         MVC   TRCPNTRY,0(R15)          (Same)
         DROP  R1                       Drop Temp Addressability
*
** Return to Caller
*
DINIT99  DS    0H
         SUBEXIT ,
*
*=====================================================================*
** DTERM - Do Termination Processing                                  *
*=====================================================================*
*
DTERM    SUBNTRY ,
*
** Return to Caller
*
DTERM99  DS    0H
         SUBEXIT ,
*
*=====================================================================*
** DPROC - Do Main Processing                                         *
*=====================================================================*
*
DPROC    SUBNTRY ,
         L     R14,PSATOLD             Get Address of TCB
         USING TCB,R14                 (Same)
         L     R9,TCBRTWA              Get RTM2WA Address
*
         DO WHILE=(LTR,R9,R9,NZ)       Loop All RTM2WA Areas
            L  R8,RTM2SDW1             Get SDWA Address This RTM2WA
*
            GOSUB DSDWA                Move SDWA Stuff to DSA
            GOSUB DRTM2                Process an RTM2WA Workarea
*
            ICM R9,B'1111',RTM2PREV    Get Prev RTM2WA Address
         ENDDO ,
*
** Return To Caller
*
DPROC99  DS    0H
         SUBEXIT ,
         DROP  R14                     Drop Temp Bases
*
*=====================================================================*
** DSDWA - Move Stuff From SDWA Fields to DSA - Save The Bases        *
*=====================================================================*
*
         USING SDWAPTRS,R1             SDWAPTRS Addressability
         USING SDWARC1,R14             SDWARC1 Addressability
         USING SDWARC4,R15             SDWARC4 Addressability
*
DSDWA    SUBNTRY ,
         L     R1,SDWAXPAD             Get Address of SDWAPTRS
         L     R14,SDWASRVP            Get Access Regs
         L     R15,SDWAXEME            Get 64-Bit Regs
*
         IF (LTR,R15,R15,NZ)           Have 64-Bit Regs?
            MVC DSAGR64,SDWAG64        Grab 64-Bit Regs
         ELSE ,
            XC  DSAGR64,DSAGR64        Zero High Words
            MVC DSAGR0+4(4),SDWAGR00   Grab 31-Bit Registers
            MVC DSAGR1+4(4),SDWAGR01   (Same)
            MVC DSAGR2+4(4),SDWAGR02   (Same)
            MVC DSAGR3+4(4),SDWAGR03   (Same)
            MVC DSAGR4+4(4),SDWAGR04   (Same)
            MVC DSAGR5+4(4),SDWAGR05   (Same)
            MVC DSAGR6+4(4),SDWAGR06   (Same)
            MVC DSAGR7+4(4),SDWAGR07   (Same)
            MVC DSAGR8+4(4),SDWAGR08   (Same)
            MVC DSAGR9+4(4),SDWAGR09   (Same)
            MVC DSAGR10+4(4),SDWAGR10  (Same)
            MVC DSAGR11+4(4),SDWAGR11  (Same)
            MVC DSAGR12+4(4),SDWAGR12  (Same)
            MVC DSAGR13+4(4),SDWAGR13  (Same)
            MVC DSAGR14+4(4),SDWAGR14  (Same)
            MVC DSAGR15+4(4),SDWAGR15  (Same)
         ENDIF ,
*
         MVC  DSAACRS,SDWAARER         Grab Access Registers
         MVC  DSACREGS,SDWACRER        Grab Control Registers
         MVC  DSARSC,SDWACRC           Extract Reason Code
*
         IF (LTR,R15,R15,NZ)           If We have 64-Bit Extension?
            MVC DSAPSW,SDWAPSW16       Move PSW to DSA
         ELSE
            XC  DSAPSW,DSAPSW          Reformat EC PSW
            MVC DSAPSW(4),SDWAEC1      (Same)
            MVC DSAPSW+12(4),SDWAEC1+4 (Same)
            IF  (TM,DSAPSW+12,X'80',O) (Same)
                OI DSAPSW+4,X'80'      (Same)
                NI DSAPSW+12,X'7F'     (Same)
            ENDIF ,
         ENDIF
*
** Return To Caller
*
DSDWA99  DS    0H
         SUBEXIT ,
         DROP  R1,R14,R15              Drop Temp Addressability
*
*=====================================================================*
** DRTM2 - Processing for the Current RTM2WA Work Area                *
*=====================================================================*
*
DRTM2    SUBNTRY ,
*
** Print Program Abended Header
*
         #WTO ' ',PLINE=TRCPLINE       Print a Few Spaces
         GOSUB PPRNT                   (Same)
         GOSUB PPRNT                   (Same)
         GOSUB PPRNT                   (Same)
*
         #WTO (CL80AST),SQUEEZE=NO,PLINE=TRCPLINE
         GOSUB PPRNT
         #WTO (CL80TTL),SQUEEZE=NO,PLINE=TRCPLINE
         GOSUB PPRNT
         #WTO (CL80AST),SQUEEZE=NO,PLINE=TRCPLINE
         GOSUB PPRNT
*
         ST   R9,DSAWXL4A              Save RTM2WA Addr for Print
         #WTO '*',PLINE=TRCPLINE
         GOSUB PPRNT
         #WTO ('** Diagnostics for RTM2WA at: ',DSAWXL4A),             *
               PLINE=TRCPLINE
         GOSUB PPRNT
         #WTO '*',PLINE=TRCPLINE
         GOSUB PPRNT
         #WTO ' ',PLINE=TRCPLINE
         GOSUB PPRNT
*
** Print Abend Diagnostics
*
         GOSUB DPSW                    Display PSW at Abend
         GOSUB DGREG                   Display Registers at Abend
         GOSUB DCREG                   Display Control Regs At Abend
         GOSUB DCHN                    Print Savearea Chain
*
         GOSUB DSDWA                   Restore Abend PSW & Regs
*
** Return to Caller
*
DRTM299  DS    0H
         SUBEXIT ,
*
*=====================================================================*
** DPSW - Display PSW At Entry to Abend                               *
*=====================================================================*
*
DPSW     SUBNTRY ,
         MVC DSAWORKF,SDWACMPC         Get Completion Code
         IF (NC,DSAWORKF(2),=X'FFF0',Z)    If User Abend?
            XR  R14,R14                    ..Zero Work Register
            ICM R14,B'0111',SDWACMPC       ..Get User Abend Code
            N   R14,=A(X'00000FFF')        ..(Same)
            CVD R14,DSAWORKD               ..User Code in Decimal
            OI  DSAWORKD+7,X'0F'           ..(Same)
            UNPK DSAWORKD(5),DSAWORKD+5(3) ..(Same)
            MVI DSACMP,C'U'                ..(Same)
            MVC DSACMP+1(4),DSAWORKD+1     ..(Same)
         ELSE ,                            Else
            UNPK DSAWORKD(5),SDWACMPC(3)   ..Extract System Code
            MVI DSACMP,C'S'                ..(Same)
            MVC DSACMP+1(3),DSAWORKD       ..(Same)
            TR  DSACMP+1(3),HEXTABA-240    ..(Same)
         ENDIF ,
*
         XR   R2,R2                    Zero Work Register
         IC   R2,SDWAILC1              Get ILC
         N    R2,=A(X'06')             (Same)
         STC  R2,DSAILC                In Character
         OI   DSAILC,C'0'              (Same)
*
         #WTO ('  ABEND CODE: ',DSACMP,'   REASON CODE:  ',DSARSC,     *
               '   ILC: ',DSAILC),SQUEEZE=NO,PLINE=TRCPLINE
         GOSUB PPRNT
*
         #WTO ('         PSW: ',DSAPSW1,' ',DSAPSW2,                   *
               '   ',DSAPSW3,' ',DSAPSW4),SQUEEZE=NO,PLINE=TRCPLINE
         GOSUB PPRNT
*
** Print DATA at PSW line
*
         L    R14,DSAPSW+12            Get PSW Address
         SR   R14,R2                   Get Prev instruction
         SRL  R14,2                    To Fullword Boundry
         SLL  R14,2                    (Same)
         ST   R14,DSADAPAD             Save Address of Data At PSW
*
         MVC  DSARETRY,=A(DPSW010)     Could Abend Here
         L    R14,DSADAPAD             Get Data At PSW
         MVC  DSADAPSW,0(R14)          (Same)
DPSW010  DS   0H
         XC   DSARETRY,DSARETRY        Release Retry
         #WTO ('  DATA @ PSW:          ',DSADAPAD,' -',                *
               ' ',DSADAPS1,' ',DSADAPS2,                              *
               ' ',DSADAPS3,' ',DSADAPS4),                             *
               SQUEEZE=NO,PLINE=TRCPLINE
         GOSUB PPRNT
*
** Display PSW Status
*
         #WTO ' ',PLINE=TRCPLINE
         GOSUB PPRNT
*
         MVI TRCPLINE,C' '             Space Fill Print Line
         MVC TRCPLINE+1(L'TRCPLINE-1),TRCPLINE
*
         LA  R2,TRCPLINE+2         -*- Set State Value
         MVC 0(6,R2),=C'State('        Set State Header
         LA  R2,6(,R2)                 (Same)
         IF  (TM,DSAPSW1+1,X'01',O)    If Problem State?
             MVC 0(9,R2),=C'Problem),' ...Indicate Problem State
             LA  R2,10(,R2)            ...Bump Pointer
         ELSE ,                        Else
             MVC 0(12,R2),=C'Supervisor),' ...Indicate Supervisor State
             LA  R2,13(,R2)                ...Bump Pointer
         ENDIF ,
*
         XR  R14,R14               -*- Set Key Value
         IC  R14,DSAPSW1+1             Get PSW Key
         SRL R14,4                     (Same)
         IF  (C,R14,LT,=F'10')         If Single Digit Key?
           O   R14,=A(X'000000F0')     (Same)
           MVC 0(4,R2),=C'Key('        Set Key Header
           LA  R2,4(,R2)               (Same)
           STC R14,0(,R2)              Set Key
           MVC 1(2,R2),=C'),'          (Same)
           LA  R2,4(,R2)               (Same)
         ELSE  ,
           S   R14,=F'10'              Get Double Digit Key
           O   R14,=A(X'000000F0')     (Same)
           MVC 0(5,R2),=C'Key(1'       Set Key Header
           LA  R2,5(,R2)               (Same)
           STC R14,0(,R2)              Set Key
           MVC 1(2,R2),=C'),'          (Same)
           LA  R2,5(,R2)               (Same)
         ENDIF ,
*
         MVC 0(5,R2),=C'Mode('      -*- Set Mode Header
         LA  R2,5(,R2)                  (Same)
         IF (TM,DSAPSW1+2,X'80',Z)      If Primary or Access?
            IF (TM,DSAPSW1+2,X'40',Z)      If Primary Mode?
               MVC 0(9,R2),=C'Primary),'   ...Indicate Primary Mode
               LA  R2,10(,R2)              ...Bump Pointer
            ELSE ,                         Else
               MVC 0(8,R2),=C'Access),'    ...Indicate Access Mode
               LA  R2,9(,R2)               ...Bump Pointer
            ENDIF ,
         ELSE ,                         If Home or Secondary?
            IF (TM,DSAPSW1+2,X'40',Z)      If Secondary Mode?
               MVC 0(9,R2),=C'Secondary),' ...Indicate Primary Mode
               LA  R2,10(,R2)              ...Bump Pointer
            ELSE ,                         Else
               MVC 0(6,R2),=C'Home),'      ...Indicate Home Mode
               LA  R2,7(,R2)               ...Bump Pointer
            ENDIF ,
         ENDIF ,
*
         MVC 0(6,R2),=C'Amode('     -*- Set Amode Header
         LA  R2,6(,R2)                  (Same)
         IF  (TM,DSAPSW1+3,X'01',O)     If Amode(64)?
             MVC 0(3,R2),=C'64)'        ...Indicate Amode(64)
         ELSE ,                         Else
            IF (TM,DSAPSW1+4,X'80',O)   If Amode(31)?
                MVC 0(3,R2),=C'31)'     ...Indicate Amode(31)
            ELSE ,
                MVC 0(3,R2),=C'24)'     ...Indicate Amode(24)
            ENDIF ,
         ENDIF ,
*
         GOSUB PPRNT
*
         #WTO ' ',PLINE=TRCPLINE
         GOSUB PPRNT
*
** Display Active Load Module Line
*
         L     R1,DSAPSW+12            Get PSW Address
         GOSUB DCDE                    Get Data to Print
         IF (CLI,DSADLMOD,NE,C' ')     If We Found it?
            #WTO ('  Active Load Module: ',DSADLMOD,', EP: ',          *
               DSADEPAD,', Offset: ',DSADOFS1),                        *
               SQUEEZE=NO,PLINE=TRCPLINE
            GOSUB PPRNT
         ELSE ,
            #WTO '  No Active Load Module.',                           *
               SQUEEZE=NO,PLINE=TRCPLINE
            GOSUB PPRNT
         ENDIF ,
*
** Display Active Csect Line
*
         IF (CLI,DSADCSCT,NE,C' ')     If We Found it?
            #WTO ('       Current Csect: ',DSADCSCT,', EP: ',          *
               DSADCSEP,', Offset: ',DSADCOF1),                        *
               SQUEEZE=NO,PLINE=TRCPLINE
            GOSUB PPRNT
         ENDIF ,
*
** Return to Caller
*
DPSW999  DS    0H
         SUBEXIT ,
*
*=====================================================================*
** DGREG - Display General Registers                                  *
*=====================================================================*
*
DGREG    SUBNTRY ,
         #WTO ' ',PLINE=TRCPLINE
         GOSUB PPRNT
         #WTO '    AR/GR Registers at Entry to Abend',SQUEEZE=NO,      *
               PLINE=TRCPLINE
         GOSUB PPRNT
         #WTO '    ---------------------------------',SQUEEZE=NO,      *
               PLINE=TRCPLINE
         GOSUB PPRNT
*
         LA R4,DSAACRS                 Access Registers to Print
         LA R5,DSAGR64                 General Registers 64-Bit
         LA R2,8                       Print Eight lines
         XR R3,R3                      Curr Register Number
*
         DO FROM=(R2)                  Loop Through Lines to Print
            MVC  DSAPAR,0(R4)          1st Access Reg This Line
            MVC  DSAPGH,0(R5)          1st High GPR   This Line
            MVC  DSAPGL,4(R5)          1st Low GPR    This Line
            MVC  DSAQAR,4(R4)          2nd Access Reg This Line
            MVC  DSAQGH,8(R5)          2nd High GPR   This Line
            MVC  DSAQGL,12(R5)         2nd Low GPR    This Line
*
            STC  R3,DSACL1A            Get 1st Register Number
            LA   R3,1(,R3)             (Same)
            OI   DSACL1A,X'F0'         (Same)
            TR   DSACL1A,HEXTABA-240   (Same)
            STC  R3,DSACL1B            Get 2nd Register Number
            OI   DSACL1B,X'F0'         (Same)
            TR   DSACL1B,HEXTABA-240   (Same)
            LA   R3,1(,R3)             (Same)
*
            #WTO ('    ',DSACL1A,': ',DSAPAR,'/',DSAPGH,'_',DSAPGL,    *
               '    ',DSACL1B,': ',DSAQAR,'/',DSAQGH,'_',DSAQGL),      *
               SQUEEZE=NO,PLINE=TRCPLINE
            GOSUB PPRNT
*
            LA R4,8(,R4)               Next Access Register
            LA R5,16(,R5)              Next General Register
         ENDDO ,                       -> Loop
*
** Return to Caller
*
DGREG999 DS    0H
         SUBEXIT ,
*
*=====================================================================*
** DCREG - Show Control Registers at Abend                            *
*=====================================================================*
*
DCREG    SUBNTRY ,
         #WTO ' ',PLINE=TRCPLINE
         GOSUB PPRNT
         #WTO '    Control Registers at Entry to Abend',SQUEEZE=NO,    *
               PLINE=TRCPLINE
         GOSUB PPRNT
         #WTO '    -----------------------------------',SQUEEZE=NO,    *
               PLINE=TRCPLINE
         GOSUB PPRNT
*
         #WTO ('    CR0-3:   ',DSACR0,'  ',DSACR1,'  ',                *
               '  ',DSACR2,'  ',DSACR3),SQUEEZE=NO,PLINE=TRCPLINE
         GOSUB PPRNT
         #WTO ('    CR4-7:   ',DSACR4,'  ',DSACR5,'  ',                *
               '  ',DSACR6,'  ',DSACR6),SQUEEZE=NO,PLINE=TRCPLINE
         GOSUB PPRNT
         #WTO ('    CR8-11:  ',DSACR8,'  ',DSACR9,'  ',                *
               '  ',DSACR10,'  ',DSACR11),SQUEEZE=NO,PLINE=TRCPLINE
         GOSUB PPRNT
         #WTO ('    CR12-15: ',DSACR12,'  ',DSACR13,'  ',              *
               '  ',DSACR14,'  ',DSACR15),SQUEEZE=NO,PLINE=TRCPLINE
         GOSUB PPRNT
*
** Return to Caller
*
DCREG999 DS    0H
         SUBEXIT ,
*
*=====================================================================*
** DCHN - Show Save Area Chain in Reverse Order                       *
*=====================================================================*
*
         USING TRCDAREA,R4
         USING LSED,R3
*
DCHN     SUBNTRY ,
         #WTO ' ',PLINE=TRCPLINE
         GOSUB PPRNT
         GOSUB PPRNT
         #WTO '    Save Area Chain in Reverse Order',                  *
               SQUEEZE=NO,PLINE=TRCPLINE
         GOSUB PPRNT
         #WTO '    --------------------------------',                  *
               SQUEEZE=NO,PLINE=TRCPLINE
         GOSUB PPRNT
*
         L  R4,TRCDADDR                Get Address of TRCDAREA
         L  R5,TRCDCNT                 Get Count of Entries
         LR R14,R5                     Point at Last Entry
         SH R14,=Y(1)                  (Same)
         MH R14,=Y(TRCDLNTH)           (Same)
         LA R4,0(R4,R14)               Point at Last Entry
         DO FROM=(R5)                  Loop Through Entry in Table
            IF (CLC,TRCDLSEN,NE,=A(0))    If Linkage Stack Entry
               L R3,TRCDLSEN              Get Linkage Stack Address
               IF (TM,LSEDTYPE,LSEDTPCE,O)  If PC Entry?
                  NI DSAFLAG,X'FF'-DSABAKR  ..Remove BAKR Flag
                  OI DSAFLAG,DSAPC          ..Indicate PC Entry
               ELSE ,                       Else
                  NI DSAFLAG,X'FF'-DSAPC    ..Remove PC Flag
                  OI DSAFLAG,DSABAKR        ..Indicate BAKR Entry
               ENDIF ,
*
               LA R3,8(,R3)               ..Point At LSEN Entry
               GOSUB DLNKE                ..Print Entry
            ELSE ,                        Else
               L R3,TRCDR13               ..Get R13 Value
               GOSUB DSAVE                ..Print O/S Savearea
            ENDIF
*
            L R3,TRCDR13               Get Current R13 Savearea
D           USING DSA,R3               Temp Addressability
            IF (CLC,0(3,R3),EQ,=C'DSA')      If This is Our DSA?
               GOSUB DDSAE                   ..Print Whole DSA
               IF (TM,D.DSAFLAG1,DSAATBUS,O) If Using ATB Storage?
                  GOSUB DATBE                ..Print Whole ATB
               ENDIF
            ENDIF ,
*
            SH R4,=Y(TRCDLNTH)            Get Previous Entry
         ENDDO ,                       -> Loop
*
** Return to Caller
*
DCHN999  DS    0H
         SUBEXIT ,
         DROP  D                       Drop temp Addressability
*
*=====================================================================*
** DLNKE - Print a Linkage Stack Entry
*=====================================================================*
*
         USING LSEN,R3                Linkage Stack Addressability
*
DLNKE    SUBNTRY ,
         STM   R3,R6,DSASAVE4         Save Callers Registers
*
         ST    R3,DSAWXL4A            Save LESN Address

         IF (TM,DSAFLAG,DSABAKR,O)    If BAKR Entry?
            #WTO ' ',PLINE=TRCPLINE
            GOSUB PPRNT
            #WTO ('      LS BAKR Entry At: ',DSAWXL4A,                 *
               ', For: ',TRCDCSCT),                                    *
               SQUEEZE=NO,PLINE=TRCPLINE
            GOSUB PPRNT
            #WTO  '      -----------------------------------------',   *
               SQUEEZE=NO,PLINE=TRCPLINE
            GOSUB PPRNT
         ELSE ,
            #WTO ' ',PLINE=TRCPLINE
            GOSUB PPRNT
            #WTO ('      LS PC Entry At: ',DSAWXL4A,                   *
               ', For: ',TRCDCSCT),                                    *
               SQUEEZE=NO,PLINE=TRCPLINE
            GOSUB PPRNT
            #WTO  '      ---------------------------------------',     *
               SQUEEZE=NO,PLINE=TRCPLINE
            GOSUB PPRNT
         ENDIF ,
*
         MVC DSAGR64,LSENGRGS          Get GR Registers
         MVC DSAACRS,LSENARGS          Get Access Registers
*
** Print PSW and Other Stuff
*
         MVC  DSAPSW(8),LSENPSW1       Move PSW to DSA
         MVC  DSAPSW+8(8),LSENPSW2     (Same)
         #WTO ('      PSW:  ',DSAPSW1,' ',DSAPSW2,                     *
               '   ',DSAPSW3,' ',DSAPSW4),                             *
               SQUEEZE=NO,PLINE=TRCPLINE
         GOSUB PPRNT
         #WTO ('      MSTK: ',LSENMOD1,' ',LSENMOD2,                   *
               '   F1SA: ',TRCDR13),                                   *
               SQUEEZE=NO,PLINE=TRCPLINE
         GOSUB PPRNT
         #WTO ('      PASN: ',LSENPASN,'   SASN: ',LSENSASN,           *
               '   PKM:  ',LSENPKM,' EAX: ',LSENEAX),                  *
               SQUEEZE=NO,PLINE=TRCPLINE
         GOSUB PPRNT
         #WTO ' ',PLINE=TRCPLINE
         GOSUB PPRNT
*
** Print AR/GR Registers For Stack Entry
*
         LA R4,DSAACRS                  Access Registers
         LA R5,DSAGR64                  General Registers, 64-Bit
         LA R2,8                        Print Eight Lines
         XR R3,R3                       Current register Number
*
         DO FROM=(R2)
            MVC  DSAPAR,0(R4)          1st Access Reg This Line
            MVC  DSAPGH,0(R5)          1st High GPR   This Line
            MVC  DSAPGL,4(R5)          1st Low GPR    This Line
            MVC  DSAQAR,4(R4)          2nd Access Reg This Line
            MVC  DSAQGH,8(R5)          2nd High GPR   This Line
            MVC  DSAQGL,12(R5)         2nd Low GPR    This Line
*
            STC  R3,DSACL1A            Get 1st Register Number
            LA   R3,1(,R3)             (Same)
            OI   DSACL1A,X'F0'         (Same)
            TR   DSACL1A,HEXTABA-240   (Same)
            STC  R3,DSACL1B            Get 2nd Register Number
            OI   DSACL1B,X'F0'         (Same)
            TR   DSACL1B,HEXTABA-240   (Same)
            LA   R3,1(,R3)             (Same)
*
            #WTO ('         ',DSACL1A,': ',                            *
               DSAPAR,'/',DSAPGH,'_',DSAPGL,                           *
               '    ',DSACL1B,': ',                                    *
               DSAQAR,'/',DSAQGH,'_',DSAQGL),                          *
               SQUEEZE=NO,PLINE=TRCPLINE
            GOSUB PPRNT
*
            LA R4,8(,R4)               Next Access Register
            LA R5,16(,R5)              Next General Register
         ENDDO ,
*
** Return to Caller
*
DLNKE999 DS    0H
         LM    R3,R6,DSASAVE4          Save Callers Registers
         SUBEXIT ,
         DROP R3
*
*=====================================================================*
** DSAVE - Print Zos Savearea to TRCPRINT                             *
*=====================================================================*
*
* R3 -> R13 Savearea Address to Print
*
DSAVE    SUBNTRY ,
         STM  R3,R6,DSASAVE4           Save Callers Registers
         ST   R3,DSAWXL4A              Savearea Address to Print
*
** Print Savearea Header
*
         #WTO ' ',PLINE=TRCPLINE
         GOSUB PPRNT
         #WTO ('      Zos Standard Savearea At: ',DSAWXL4A,            *
               ', For: ',TRCDCSCT),                                    *
               SQUEEZE=NO,PLINE=TRCPLINE
         GOSUB PPRNT
         #WTO ('      -----------------------------------------',      *
               '--------'),                                            *
               SQUEEZE=NO,PLINE=TRCPLINE
         GOSUB PPRNT
*
** Print Register Savearea
*
         LA  R4,4                      Divided by 16
         LR  R5,R3                     Address of Area to Print
         DO FROM=(R4)                  Loop Through DSA Area
            ST  R5,DSAWKADR            Save Address of This Data
            MVC DSAWCL16,0(R5)         Get Character Data
            TR  DSAWCL16,TRTABLE       In Printable Format
            MVC DSAWXL4A,0(R5)         Get Hex Data Word 1
            MVC DSAWXL4B,4(R5)         Get Hex Data Word 2
            MVC DSAWXL4C,8(R5)         Get Hex Data Word 3
            MVC DSAWXL4D,12(R5)        Get Hex Data Word 4
*
            #WTO ('      ',DSAWKADR,'  ',                              *
               DSAWXL4A,' ',DSAWXL4B,' ',                              *
               DSAWXL4C,' ',DSAWXL4D,'  ',                             *
               '*',DSAWCL16,'*'),                                      *
               SQUEEZE=NO,PLINE=TRCPLINE
            GOSUB PPRNT
*
            LA  R5,16(,R5)             Bump Input Pointer
         ENDDO ,
*
         ST  R5,DSAWKADR               Save Address of This Data
         MVC DSAWCL16,=16C' '          Space out Field
         MVC DSAWCL16(8),0(R5)         Get Character Data
         TR  DSAWCL16,TRTABLE          In Printable Format
         MVC DSAWXL4A,0(R5)            Get Hex Data Word 1
         MVC DSAWXL4B,4(R5)            Get Hex Data Word 2
*
         #WTO ('      ',DSAWKADR,'  ',                                 *
               DSAWXL4A,' ',DSAWXL4B,' ',                              *
               '                   ',                                  *
               '*',DSAWCL16,'*'),                                      *
               SQUEEZE=NO,PLINE=TRCPLINE
         GOSUB PPRNT
         #WTO ' ',PLINE=TRCPLINE
         GOSUB PPRNT
*
** Return to Caller
*
DSAVE999 DS    0H
         LM    R3,R6,DSASAVE4          Save Callers Registers
         SUBEXIT ,
*
*=====================================================================*
** DDSAE  - Display a DSA Entry Off R13                               *
*=====================================================================*
*
* R3 -> R13 Savearea Address to Print
*
DDSAE    SUBNTRY ,
         ST   R3,DSAWXL4A              Savearea Address to Print
         STM  R3,R6,DSASAVE4           Save Callers Registers
*
         MVC  DSADCNAM,TRCDCSCT        Save CSECT Name
*
** Print DSA Header
*
         #WTO ' ',PLINE=TRCPLINE
         GOSUB PPRNT
         #WTO ('         Dymamic Storage At: ',DSAWXL4A,               *
               ', For: ',DSADCNAM),                                    *
               SQUEEZE=NO,PLINE=TRCPLINE
         GOSUB PPRNT
         #WTO  '         ------------------------------------------',  *
               SQUEEZE=NO,PLINE=TRCPLINE
         GOSUB PPRNT
*
** Print DSA Prefix
*
D        USING DSA,R3                  Temp Addressability
         #WTO '         DSA Prefix',                                   *
               SQUEEZE=NO,PLINE=TRCPLINE
         GOSUB PPRNT
*
         LA  R4,DSAPFXLN/16            Get Length of DSA Prefix
         LR  R5,R3                     Address of Area to Print
         DO FROM=(R4)                  Loop Through DSA Area
            ST  R5,DSAWKADR            Save Address of This Data
            MVC DSAWCL16,0(R5)         Get Character Data
            TR  DSAWCL16,TRTABLE       In Printable Format
            MVC DSAWXL4A,0(R5)         Get Hex Data Word 1
            MVC DSAWXL4B,4(R5)         Get Hex Data Word 2
            MVC DSAWXL4C,8(R5)         Get Hex Data Word 3
            MVC DSAWXL4D,12(R5)        Get Hex Data Word 4
*
            #WTO ('         ',DSAWKADR,'  ',                           *
               DSAWXL4A,' ',DSAWXL4B,' ',                              *
               DSAWXL4C,' ',DSAWXL4D,'  ',                             *
               '*',DSAWCL16,'*'),                                      *
               SQUEEZE=NO,PLINE=TRCPLINE
            GOSUB PPRNT
*
            LA  R5,16(,R5)             Bump Input Pointer
         ENDDO ,
*
** Print User Program DSA Area
*
         #WTO ' ',                                                     *
               SQUEEZE=NO,PLINE=TRCPLINE
         GOSUB PPRNT
*
         L   R4,D.DSALNGTH             Get Length of DSA
         SH  R4,=Y(DSAPFXLN+16)        Minus Prefix + Suffix
         IF (LTR,R4,R4,NZ)             If We Have Data to Print
            #WTO '         Program DSA Storage',                       *
               SQUEEZE=NO,PLINE=TRCPLINE
            GOSUB PPRNT
            SRL R4,4                   Divided by 16
            LR R5,R3                   Address of Area to Print
            AH R5,=Y(DSAPFXLN)         Plus Prefix
            DO FROM=(R4)               Loop Through DSA Area
               ST R5,DSAWKADR          Save Address of This Data
               MVC DSAWCL16,0(R5)      Get Character Data
               TR DSAWCL16,TRTABLE     In Printable Format
               MVC DSAWXL4A,0(R5)      Get Hex Data Word 1
               MVC DSAWXL4B,4(R5)      Get Hex Data Word 2
               MVC DSAWXL4C,8(R5)      Get Hex Data Word 3
               MVC DSAWXL4D,12(R5)     Get Hex Data Word 4
*
               #WTO ('         ',DSAWKADR,'  ',                        *
               DSAWXL4A,' ',DSAWXL4B,' ',                              *
               DSAWXL4C,' ',DSAWXL4D,'  ',                             *
               '*',DSAWCL16,'*'),                                      *
               SQUEEZE=NO,PLINE=TRCPLINE
               GOSUB PPRNT
*
               LA R5,16(,R5)           Bump Input Pointer
            ENDDO ,
         ELSE ,
            #WTO '         Program Has No DSA Data',                   *
               SQUEEZE=NO,PLINE=TRCPLINE
            GOSUB PPRNT
         ENDIF ,
*
** Print DSA Suffix
*
         #WTO ' ',                                                     *
               SQUEEZE=NO,PLINE=TRCPLINE
         GOSUB PPRNT
         #WTO '         DSA Suffix',                                   *
               SQUEEZE=NO,PLINE=TRCPLINE
         GOSUB PPRNT
*
         LR  R5,R3                     Address of Area to Print
         A   R5,D.DSALNGTH             Point After DSA
         SH  R5,=Y(16)                 Length of Suffix
         ST  R5,DSAWKADR               Save Address of This Data
         MVC DSAWCL16,0(R5)            Get Character Data
         TR  DSAWCL16,TRTABLE          In Printable Format
         MVC DSAWXL4A,0(R5)            Get Hex Data Word 1
         MVC DSAWXL4B,4(R5)            Get Hex Data Word 2
         MVC DSAWXL4C,8(R5)            Get Hex Data Word 3
         MVC DSAWXL4D,12(R5)           Get Hex Data Word 4
*
         #WTO ('         ',DSAWKADR,'  ',                              *
               DSAWXL4A,' ',DSAWXL4B,' ',                              *
               DSAWXL4C,' ',DSAWXL4D,'  ',                             *
               '*',DSAWCL16,'*'),                                      *
               SQUEEZE=NO,PLINE=TRCPLINE
         GOSUB PPRNT
         #WTO ' ',                                                     *
               SQUEEZE=NO,PLINE=TRCPLINE
         GOSUB PPRNT
*
** Return to Caller
*
DDSAE999 DS    0H
         LM    R3,R6,DSASAVE4          Save Callers Registers
         SUBEXIT ,
         DROP  D                       Drop Temp Addressability
*
*=====================================================================*
** DATBE  - Display a ATB Entry Off DAS in R13                        *
*=====================================================================*
*
* R3 -> R13 DSA Savearea Address to Print
*
D        USING DSA,R3                  Temp Addressability
A        USING ATB,R6                  Temp Addressability
*
DATBE    SUBNTRY ,
         STM  R3,R6,DSASAVE4           Save Callers Registers
*
         MVC  DSAWXL4A,D.DSAATBAD      Get ATB Address for Print
         MVC  DSAWXL4B,D.DSAATBAD+4    (Same)
*
         MVC  DSADCNAM,TRCDCSCT        Save CSECT Name
*
** Print DSA Header
*
         #WTO ' ',PLINE=TRCPLINE
         GOSUB PPRNT
         #WTO ('         Above-The-Bar Storage At: ',DSAWXL4A,         *
               '_',DSAWXL4B,', For: ',DSADCNAM),                       *
               SQUEEZE=NO,PLINE=TRCPLINE
         GOSUB PPRNT
         #WTO  ('         -------------------------------------------',*
               '---------------'),SQUEEZE=NO,PLINE=TRCPLINE
         GOSUB PPRNT
*
** Print ATB Prefix
*
         #WTO '         ATB Prefix',                                   *
               SQUEEZE=NO,PLINE=TRCPLINE
         GOSUB PPRNT
*
         LG  R6,D.DSAATBAD             Get ATB Address
         LA  R4,ATBPFXLN/16            Get Length of DSA Prefix
         LGR R5,R6                     Address of Area to Print
*
         DO FROM=(R4)                  Loop Through DSA Area
            SAM64 ,                    Must be in 64-Bit mode
            STG R5,DSAWKADR            Save Address of This Data
            MVC DSAWCL16,0(R5)         Get Character Data
            TR  DSAWCL16,TRTABLE       In Printable Format
            MVC DSAWXL4A,0(R5)         Get Hex Data Word 1
            MVC DSAWXL4B,4(R5)         Get Hex Data Word 2
            MVC DSAWXL4C,8(R5)         Get Hex Data Word 3
            MVC DSAWXL4D,12(R5)        Get Hex Data Word 4
*
            SAM31 ,                    Back to 31-Bit Amode For #WTO
            #WTO ('         ',DSAWKADR,'_',DSAWKAD2,'  ',              *
               DSAWXL4A,' ',DSAWXL4B,' ',                              *
               DSAWXL4C,' ',DSAWXL4D,'  ',                             *
               '*',DSAWCL16,'*'),                                      *
               SQUEEZE=NO,PLINE=TRCPLINE
            GOSUB PPRNT
            SAM64 ,                    Must be in 64-Bit mode
*
            LA  R5,16(,R5)             Bump Input Pointer
         ENDDO ,
*
** Print User Program ATB Area
*
         SAM31 ,                       Back to 31-Bit Amode For #WTO
         #WTO ' ',                                                     *
               SQUEEZE=NO,PLINE=TRCPLINE
         GOSUB PPRNT
         SAM64 ,                       Must be in 64-Bit mode
*
         LG  R4,D.DSAATBSZ             Get Length of DSA
         SH  R4,=Y(ATBPFXLN+16)        Minus Prefix + Suffix
         IF (LTR,R4,R4,NZ)             If We Have Data to Print
            SAM31 ,                    Back to 31-Bit Amode For #WTO
            #WTO '         Program ATB Storage',                       *
               SQUEEZE=NO,PLINE=TRCPLINE
            GOSUB PPRNT
            SAM64 ,                    Must be in 64-Bit mode
*
            SRL R4,4                   Divided by 16
            LGR R5,R6                  Address of Area to Print
            AH R5,=Y(ATBPFXLN)         Plus Prefix
            DO FROM=(R4)               Loop Through DSA Area
               STG R5,DSAWKADR         Save Address of This Data
               MVC DSAWCL16,0(R5)      Get Character Data
               TR  DSAWCL16,TRTABLE    In Printable Format
               MVC DSAWXL4A,0(R5)      Get Hex Data Word 1
               MVC DSAWXL4B,4(R5)      Get Hex Data Word 2
               MVC DSAWXL4C,8(R5)      Get Hex Data Word 3
               MVC DSAWXL4D,12(R5)     Get Hex Data Word 4
*
               SAM31 ,                 Back to 31-Bit Amode For #WTO
               #WTO ('         ',DSAWKADR,'_',DSAWKAD2,'  ',           *
               DSAWXL4A,' ',DSAWXL4B,' ',                              *
               DSAWXL4C,' ',DSAWXL4D,'  ',                             *
               '*',DSAWCL16,'*'),                                      *
               SQUEEZE=NO,PLINE=TRCPLINE
               GOSUB PPRNT
               SAM64 ,                 Must be in 64-Bit mode
*
               LA R5,16(,R5)           Bump Input Pointer
            ENDDO ,
         ELSE ,
            SAM31 ,                    Back to 31-Bit Amode For #WTO
            #WTO '         Program Has No ATB Data',                   *
               SQUEEZE=NO,PLINE=TRCPLINE
            GOSUB PPRNT
            SAM64 ,                    Must be in 64-Bit mode
         ENDIF
*
** Print DSA Suffix
*
         SAM31 ,                       Back to 31-Bit Amode For #WTO
         #WTO ' ',                                                     *
               SQUEEZE=NO,PLINE=TRCPLINE
         GOSUB PPRNT
         #WTO '         ATB Suffix',                                   *
               SQUEEZE=NO,PLINE=TRCPLINE
         GOSUB PPRNT
         SAM64 ,                       Must be in 64-Bit mode
*
         LGR R5,R6                     Address of Area to Print
         AG  R5,D.DSAATBSZ             Point After DSA
         AGHI R5,-16                   Length of Suffix
         STG R5,DSAWKADR               Save Address of This Data
         MVC DSAWCL16,0(R5)            Get Character Data
         TR  DSAWCL16,TRTABLE          In Printable Format
         MVC DSAWXL4A,0(R5)            Get Hex Data Word 1
         MVC DSAWXL4B,4(R5)            Get Hex Data Word 2
         MVC DSAWXL4C,8(R5)            Get Hex Data Word 3
         MVC DSAWXL4D,12(R5)           Get Hex Data Word 4
*
         SAM31 ,                       Back to 31-Bit Amode For #WTO
         #WTO ('         ',DSAWKADR,'_',DSAWKAD2,'  ',                 *
               DSAWXL4A,' ',DSAWXL4B,' ',                              *
               DSAWXL4C,' ',DSAWXL4D,'  ',                             *
               '*',DSAWCL16,'*'),                                      *
               SQUEEZE=NO,PLINE=TRCPLINE
         GOSUB PPRNT
         #WTO ' ',                                                     *
               SQUEEZE=NO,PLINE=TRCPLINE
         GOSUB PPRNT
*
** Return to Caller
*
DATBE999 DS    0H
         SAM31 ,                       Back to 31-Bit Amode
         LM    R3,R6,DSASAVE4          Save Callers Registers
         SUBEXIT ,
         DROP  D,A                     Drop Temp Addressability
*
*
*=====================================================================*
*                                                                     *
** DCDE - Locate CDE and Extent List for Address                      *
*                                                                     *
*    This routine is given an storage address and attempts to find    *
*  the load module that is loaded at that address.  It runs the CDE   *
*  chain to the extent list and and checks the address against the    *
*  storage extent.                                                    *
*                                                                     *
*  On Input:  R1       -> Address to Locate                           *
*  On Output: DSADLMOD -> CDNAME of LMOD or Blanks                    *
*                                                                     *
*=====================================================================*
*
         USING TCB,R14                 Get TCB Addressability
         USING CDENTRY,R15             Get CDE Addressability
         USING XTLST,R2                Get XTLST Addressability
*
DCDE     SUBNTRY ,
         MVC DSADLMOD,=CL8' '          Space Fill Receiving Field
         MVC DSADEPAD,=F'0'            (Same)
         MVC DSADOFST,=F'0'            (Same)
         MVC DSADCSCT,=CL8' '          Space Fill Receiving Field
         MVC DSADCSEP,=F'0'            (Same)
*
         L  R14,PSATOLD                Load Our TCB Address
         L  R14,TCBJSTCB               CDE's Are Anchored Off JSTCB
         IF (ICM,R15,15,TCBJPQ,NZ)     Get First CDE on Chain
            DO INF                     Do Forever...
               L  R2,CDXLMJP           Get Extent Pointer
               XR R14,R14              Zero Work Register
               ICM R14,7,XTLMSBLN      Get Length of Extent
               AL  R14,XTLMSBAD        Plus Address for End Pointer
*
               IF (C,R1,GE,XTLMSBAD)      If Greater Than Beginning
                  IF (CR,R1,LT,R14)       And Less Than End
                     MVC DSADLMOD,CDNAME     Save CDNAME
                     MVC DSADEPAD,CDENTPT    Save EP Address
                     NI DSADEPAD,X'7F'       Strip High Bit
                     NI DSADEPAD+3,X'FE'     Strip Low Bit When 64-Bit
                     L  R2,DSAPSW+12         Get Offset Value
                     S  R2,DSADEPAD          (Same)
                     ST R2,DSADOFST          (Same)
*
                     MVC DSADCSCT,C.TRCDCSCT Get Current Csect Name
                     MVC DSADCSEP,C.TRCDCSEP Get Current Csect EP
                     L  R2,DSAPSW+12         Get Offset Value
                     S  R2,DSADCSEP          (Same)
                     ST R2,DSADCOFS          (Same)
                     DOEXIT ,             -> Done
                  ENDIF
               ENDIF
*
               L  R15,CDCHAIN          Get next CDE Entry
               IF (LTR,R15,R15,Z)      End of Chain?
                  DOEXIT ,             Yes -> Done
               ENDIF
            ENDDO
         ENDIF
*
DCDE999  DS    0H
         SUBEXIT ,
         DROP  R14,R15,R2              Drop Temp Bases
*
*=====================================================================*
** SUBR - Model Subroutine for Replication                            *
*=====================================================================*
*
SUBR     SUBNTRY ,
*
*
SUBR999  DS    0H
         SUBEXIT ,
*
*---------------------------------------------------------------------*
*                                                                     *
** PPRNT - Write a Line of Output                                     *
*                                                                     *
*    This routine is called to write a line of output.  That output   *
*  line may be written to the sysout dataset for the task, or to the  *
*  print buffer if BUFFER=YES was specified on the OPEN request.      *
*                                                                     *
*---------------------------------------------------------------------*
*
PPRNT    SUBNTRY ,
         IF (TM,TRCBFLAG,TRCBBFON,Z)    If Not Buffering?
            PUT TRCDCB,TRCPLINE         Yes -> Print Line
         ELSE
            L   R1,TRCBUFCR               Get Current Position
            MVC 0(L'TRCPLINE,R1),TRCPLINE Move Line to Buffer
            LA  R1,L'TRCPLINE(,R1)        Point at Next Slot
            IF (C,R1,LT,TRCBUFND)       Past End of Buffer
               ST R1,TRCBUFCR           Set Next Slot Pointer
            ELSE
               MVC TRCBUFCR,TRCBUFAD    Set First Slot as Next
            ENDIF
         ENDIF
*
PPRNT999 DS    0H
         SUBEXIT ,
*
*---------------------------------------------------------------------*
** Define Constants and Literials                                     *
*---------------------------------------------------------------------*
*
** Define Literals and Constants
*
         CONBEG ,
         DS    0D
TRTABLE  DS    256C'.'                 Translate Table
         ORG   TRTABLE+C'A'
         DC    C'ABCDEFGHI'
         ORG   TRTABLE+C'J'
         DC    C'JKLMNOPQR'
         ORG   TRTABLE+C'S'
         DC    C'STUVWXYZ'
         ORG   TRTABLE+C'a'
         DC    C'abcdefghi'
         ORG   TRTABLE+C'j'
         DC    C'jklnmopqr'
         ORG   TRTABLE+C's'
         DC    C'stuvwxyz'
         ORG   TRTABLE+C'0'
         DC    C'0123456789'
         ORG   TRTABLE+C'@'
         DC    C'@'
         ORG   TRTABLE+C'#'
         DC    C'#'
         ORG   TRTABLE+C'$'
         DC    C'$'
         ORG   TRTABLE+C','
         DC    C','
         ORG   ,
*
HEXTABA  DC    CL16'0123456789ABCDEF'
*
CL80AST  DC    0CL80,80C'*'
CL80TTL  DC    CL80'*                           -> Program Abended <-'
         ORG   *-1
         DC    C'*'
*
CONEST   ESTAEX MF=L
CONESTL  EQU   *-CONEST
*
         CONEND ,
*
*---------------------------------------------------------------------*
** Define Dynamic Storage Area                                        *
*---------------------------------------------------------------------*
*
         DSABEG ,
*
DSASAVE4 DS    4A                      Register Save Area - PLNK
*
DSACMP   DS    CL5                     Current Completion Code
DSARSC   DS    A                       Current Reason Code
DSAILC   DS    CL1                     Current Instruction Length Code
*
DSACL1A  DS    CL1                     1st Register Number
DSACL1B  DS    CL1                     2nd Register Number
DSAPAR   DS    A                       1st Access  Reg Print Area
DSAPGH   DS    A                       1st General Reg High Word
DSAPGL   DS    A                       1st General Reg Low  Word
DSAQAR   DS    A                       2nd Access  Reg Print Area
DSAQGH   DS    A                       2nd General Reg High Word
DSAQGL   DS    A                       2nd General Reg Low  Word
*
DSADLMOD DS    CL8                     Current LMOD  Name
DSADEPAD DS    A                       Current LMOD EP Address
DSADOFST DS    A                       Current LMOD Offset to PSW Ad
DSADOFS1 EQU   DSADOFST+1,3,C'X'       (Same)
*
DSADCSCT DS    CL8                     Current Csect Name
DSADCSEP DS    A                       Current Csect EP
DSADCOFS DS    A                       Current Csect OFfset
DSADCOF1 EQU   DSADCOFS+1,3,C'X'       (Same)
*
DSADCNAM DS    CL8                     Current CSECT Name
*
         DS    0D                <===* Keep Together
DSAWKADR DS    XL4                   * Address of Data to Print
DSAWKAD2 DS    XL4               <===* (Same)
*
DSAWXL4A DS    XL4                     4-Byte Work Areas for Print
DSAWXL4B DS    XL4                     (Same)
DSAWXL4C DS    XL4                     (Same)
DSAWXL4D DS    XL4                     (Same)
DSAWCL16 DS    CL16                    16-Byte Work Area
*
DSALSTP  DS    B                       Linkage Stack Type
DSAFLAG  DS    B                       General Flag Byte
DSAPC    EQU   X'80'                   ..LSEN is PC Entry
DSABAKR  EQU   X'40'                   ..LSEN is BAKR Entry
*
         DS    0D
DSAPSW   DS    0XL16                   PSW to Print
DSAPSW1  DS    A                       (Same)
DSAPSW2  DS    A                       (Same)
DSAPSW3  DS    A                       (Same)
DSAPSW4  DS    A                       (Same)
*
DSADAPAD DS    A                       Address of Data At PSW
DSADAPSW DS    0XL16                   Data At PSW
DSADAPS1 DS    XL4                     (Same)
DSADAPS2 DS    XL4                     (Same)
DSADAPS3 DS    XL4                     (Same)
DSADAPS4 DS    XL4                     (Same)
*
*
** Current Register Values for Printing
*
         DS    0D
DSAACRS  DS    XL64                  Access Registers
*
         DS    0D
DSAGR64  DS    0XL128                64-Bit Registers
DSAGR0   DS    D                     (Same)
DSAGR1   DS    D                     (Same)
DSAGR2   DS    D                     (Same)
DSAGR3   DS    D                     (Same)
DSAGR4   DS    D                     (Same)
DSAGR5   DS    D                     (Same)
DSAGR6   DS    D                     (Same)
DSAGR7   DS    D                     (Same)
DSAGR8   DS    D                     (Same)
DSAGR9   DS    D                     (Same)
DSAGR10  DS    D                     (Same)
DSAGR11  DS    D                     (Same)
DSAGR12  DS    D                     (Same)
DSAGR13  DS    D                     (Same)
DSAGR14  DS    D                     (Same)
DSAGR15  DS    D                     (Same)
*
         DS    0D
DSACREGS DS    0XL64                 Control Registers at Abend
DSACR0   DS    A                     (Same)
DSACR1   DS    A                     (Same)
DSACR2   DS    A                     (Same)
DSACR3   DS    A                     (Same)
DSACR4   DS    A                     (Same)
DSACR5   DS    A                     (Same)
DSACR6   DS    A                     (Same)
DSACR7   DS    A                     (Same)
DSACR8   DS    A                     (Same)
DSACR9   DS    A                     (Same)
DSACR10  DS    A                     (Same)
DSACR11  DS    A                     (Same)
DSACR12  DS    A                     (Same)
DSACR13  DS    A                     (Same)
DSACR14  DS    A                     (Same)
DSACR15  DS    A                     (Same)
*
         DS    0D
DSAPNTRY DS    XL(TRCDLNTH)            Previous Save Area Entry
         DS    0D
DSACNTRY DS    XL(TRCDLNTH)            Current  Save Area Entry
*
         DSAEND ,
         DROP   ,                    Drop Everything
*
***********************************************************************
*                                                                     *
** RDHRESEX - Resource Manager Exit Routine                           *
*                                                                     *
*    This routine was required to support buffering of sysout data    *
*  for this trace facility.  The data is buffered in a round robin    *
*  in storage table and printed at end of task.                       *
*                                                                     *
***********************************************************************
*
         USING PSA,R0                  Establish Addressability
         USING TRCDSECT,R9             TRCDSCET Addressability
         USING SDWA,R7                 SDWA Addressability
*
RDHRESEX PGMNTRY TYPE=MAIN,                                            *
               BASE=(R12,R11),                                         *
               AMODE=31,               Define Addressing Mode          *
               RMODE=ANY,              Define Residency Mode           *
               ESTAE=YES,              Define ESTAE Support            *
               TRACE=NO
*
         L     R9,4(,R1)               Get Address of 8-Byte Param
         L     R9,4(,R9)               Get Address of TRCDSECT
         MODESET MODE=SUP,KEY=ZERO
*
** RESMGR Exit Mainline
*
         MVC   DSARETRY,=A(RDHRETRY)   Set Retry Address
         GOSUB CLOS                    Close SYSOUT & Free Storage
*
** Retry Here on Error
*
RDHRETRY DS    0H
*
** Return to Caller
*
RDHRESND DS    0H
         PGMEXIT RC=8,                 Return to Caller                *
               RS=1                    ..Terminate RESMGR Exit
*
*=====================================================================*
** CLOS - Close the SYSOUT Dataset and do cleanup for this task       *
*=====================================================================*
*
CLOS     SUBNTRY ,
         RESMGR DELETE,TYPE=TASK,      Delete RESMGR Exit This Task    *
               ASID=CURRENT,           ..And This Address Space        *
               TOKEN=TRCRESMT,         ..Token for DELETE              *
               MF=(E,TRCRESM)          ..Point to List Form
*
         IF (CLC,=F'0',NE,TRCBUFAD)    If Buffering Was Requested
            BAS R14,PBFR               Write Out Buffered Data
            L  R1,TRCBUFAD             Save Address
            L  R0,TRCBUFLN             Save Length
            STORAGE RELEASE,           Release Storage for Buffer      *
               LENGTH=(0),             (Same)                          *
               ADDR=(1)                (Same)
         ENDIF
*
** Close Open Dataset For This Task
*
         MVC TRCCLL,MDLCLL             Move Close Parm to Common
         CLOSE (TRCDCB),               Close Sysout Dataset            *
               MF=(E,TRCCLL)            (Same)
*
** Free Storage For TRCDAREA
*
         L     R1,TRCDADDR             Get Address of Area to Free
         STORAGE RELEASE,ADDR=(1),     Free Storage for TRCDAREA       *
               SP=240,                 (Same)                          *
               LENGTH=TRCDSIZE         (Same)
*
** Free Storage for TRCDSECT
*
         STORAGE RELEASE,              Free Storage for TRCDSECT       *
               ADDR=(R9),              (Same)                          *
               LENGTH=4096             (Same)
*
** Return to Caller
*
CLOS999  DS    0H
         SUBEXIT ,
*
*=====================================================================*
** PBFR - Print the Buffered Output to SYSOUT                         *
*=====================================================================*
*
PBFR     SUBNTRY ,
         L  R2,TRCBUFCR                 Get Current Position
         IF (CLI,0(R2),NE,X'00')        If We've Filled Buffer?
            DO WHILE=(C,R2,LT,TRCBUFND) Loop Through Buffer to End
               IF (CLI,0(R2),EQ,X'00')  If at End?
                  DOEXIT ,              -> Done
               ENDIF ,
               MVC TRCPLINE,0(R2)      Move Data to DSA
               LA R2,L'TRCPLINE(,R2)   Bump Pointer
               PUT TRCDCB,TRCPLINE     Print Line to SYSOUT
            ENDDO ,                    -> Loop
         ENDIF ,
*
         L  R2,TRCBUFAD                Start From Beginning
         DO WHILE=(C,R2,LT,TRCBUFCR)   Loop Through to End Pointer
            IF (CLI,0(R2),EQ,X'00')    If at End?
               DOEXIT ,                -> Done
            ENDIF ,
            MVC TRCPLINE,0(R2)         Move Data to DSA
            LA  R2,L'TRCPLINE(,R2)     Bump Pointer
            PUT TRCDCB,TRCPLINE        Print Line to SYSOUT
         ENDDO ,                       -> Loop
*
PBFR999  DS    0H
         SUBEXIT ,
*
***********************************************************************
** Define Constant Area & Dynamic Storage Area
***********************************************************************
*
** Define Literials and Constants
*
         CONBEG ,
MDLCLL   CLOSE (*-*),MF=L
MDLCLLL  EQU   *-MDLCLL
         CONEND ,
*
** Define Dynamic Storage
*
         DSABEG ,
*
         DSAEND ,
         DROP ,
         END ,
