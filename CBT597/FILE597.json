{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012430000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 235144, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 8, "INMDSNAM": "CBT.V500.FILE597.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 235144, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 235144, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE597.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x04\\x13'", "DS1TRBAL": "b'\\rj'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xb0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xb0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x04b\\x00\\x03\\x04b\\x00\\x07\\x00\\x05'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04b\\x003\\x01\\x19)?\\x01\\x19)?\\x16V\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf8@@@'", "ispf": {"version": "04.98", "flags": 0, "createdate": "2019-10-20T00:00:00", "modifydate": "2019-10-20T16:56:33", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-498"}, "text": "REGULAR CBT TAPE - VERSION 498    FILE:  597\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT498.FILE597\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 13 MEMBERS COUNTED; CUMULATIVE SIZE IS 1,620 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   10/20/19    16:56:33    UTC-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$INDEX": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x15\\x01\\x02)\\x0f\\x01\\x02)\\x0f\\x12 \\x00\\x0b\\x00\\x07\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2002-10-17T00:00:00", "modifydate": "2002-10-17T12:20:15", "lines": 11, "newlines": 7, "modlines": 0, "user": "IBMUSER"}, "text": "$$INDEX   You're reading it now.\n$R$EADME  You should read this next.\n$MPFCMDS  Installs MPFCMDS-exit into an apf authorised, lnklsted lib.\n          This program written by Paul Naidoo (an excellent South-\n          African world travelling 390-specialist).\n$MPFPROC  Contains proc to be installed into a proclib library.\n          Rename it into MPFCMDS.\n$COMMAND  Installs program COMMAND into an apf authorised, lnklsted lib.\n          This program copied from FILE088 (Brian Westerman).\nmsgno     sample message handling members.  these should be used as\n          templates when building your own command library.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$NOTE0": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00F\\x01\\x02)\\x1f\\x01\\x02)\\x1f\\x00 \\x00\\x18\\x00\\x18\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-10-18T00:00:00", "modifydate": "2002-10-18T00:20:46", "lines": 24, "newlines": 24, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject: File345 MPFXTALL\nDate: Mon, 14 Oct 2002 14:27:13 +0200\nFrom: \"Westheim, Hans\" <Hans.Westheim@essent.nl>\nTo: \"'sbgolob@aol.com'\" <sbgolob@aol.com>\n\nHello Mr Golob,\n\nI visit the CBT-site a lot. I did find a lot of helpful freeware\nwhich saved us a lot of money. So thank You for that.\n\nAt the moment I am also using the MPF-exit MPFXTALL from CBT345.\nI was very pleased about it's simpleness. But now I encounter\nA37-008 abends on this exit. Do you know whether there is a newer\nversion available or maybe an elegant replacement  for this exit?\n(I am running OS390 2.10 at the moment.)\n\nGreetings,\n\nHans Westheim, Netherlands\nEssent/ICT/Services/S390-engineer\n+31 (0)73-8557928 (kantoor)\n+31 (0)6-29503136 (mobiel)\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE1": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x000\\x01\\x02)\\x1f\\x01\\x02)\\x1f\\x00!\\x00K\\x00K\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-10-18T00:00:00", "modifydate": "2002-10-18T00:21:30", "lines": 75, "newlines": 75, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject: Fwd: File345 MPFXTALL\nDate: Fri, 18 Oct 2002 00:17:52 EDT\nFrom: SBGOLOB@aol.com\nTo: sbgolob@cbttape.org\n\nIn a message dated 10/15/2002 10:54:32 AM Eastern Daylight Time,\nHans.Westheim@essent.nl writes:\n\n    ---------------------------------------------------------------------\n\nSubject: RE: File345 MPFXTALL\nDate: Tue, 15 Oct 2002 16:53:55 +0200\nFrom: \"Westheim, Hans\" <Hans.Westheim@essent.nl>\nTo: \"'SBGOLOB@aol.com'\" <SBGOLOB@aol.com>\n\nHi Sam,\n\nNice to know that you are still working on my problem.  We solved\nit using a even more elegant way (my personal opinion).\n\nWe combined two things:\nFirst a collegea (with assembler skills) did write an very simple\nnew MPF-exit named MPFCMDS. This exit just issue's a command \"S\nMPFCMDS,MBR=<msgid>\".  (Even I am able to maintain this exit with\nmy limited Assembler skills!)\n\nI also created a proc called \"MPFCMDS\":\n\n//MPFCMDS  PROC MEMBER=DUMMY\n//MPFCMDS  EXEC PGM=COMMAND\n//IEFRDER  DD DSN=MVS.MEGA.MPFCMDS(&MEMBER.),DISP=SHR\n\nThe PDS contains just like before the commands to issue when a\nparticular message occurs.\n\nI did use the program COMMAND  (found at cbt) because it has the\nextra features like \"DELAY\", \"IFSTARTED\" ... The proc could also\nbe any other command executing program.\n\nIf you are interested I could send the sources to you!\n\nGreetings,\n\nHans\n\nPS. I noticed you ended your mail with \"Met vriendelijke groeten\"???\nDo You write/speak dutcht??\n\n     -----Oorspronkelijk bericht-----\n     Van: SBGOLOB@aol.com [mailto:SBGOLOB@aol.com]\n     Verzonden: dinsdag 15 oktober 2002 16:28\n     Aan: Hans.Westheim@essent.nl\n     CC: sbgolob@cbttape.org\n     Onderwerp: Re: File345 MPFXTALL\n\n     Hi Hans,\n\n        My \"error message list\" says that an A37-008 means that the\n     Data Extent Block does not point to the DCB.\n\n        This means that a field in the DEB (the one that is supposed to\n     point to the DCB) is missing.  Please look at whatever output you\n     can get, to determine what ddname this is for.  The we can look\n     into the code that opens the ddname (maybe) and see if there is\n     some problem with the open.  The MPF exit code does open the file\n     which contains the list of commands to be dealt with.  If that is\n     the dataset that we're dealing with, then we can possibly fix the\n     program.\n\n        Please try and gather this evidence, if you can.\n\n        All the best.....\n\n     Met vriendelijke groeten,\n     Sam Golob\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE2": {"ttr": 525, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x16\\x01\\x02)\\x0f\\x01\\x02)\\x0f#Y\\x00\\x18\\x00\\x18\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-10-17T00:00:00", "modifydate": "2002-10-17T23:59:16", "lines": 24, "newlines": 24, "modlines": 0, "user": "SBGOLOB"}, "text": "Subj: RE: File345 MPFXTALL\nDate: 10/17/2002 6:51:28 AM Eastern Daylight Time\nFrom:    Hans.Westheim@essent.nl (Westheim, Hans)\nTo:    SBGOLOB@aol.com ('SBGOLOB@aol.com')\n\nFile: cbtnew (119680 bytes) DL Time (TCP/IP): < 1 minute\n\n\n\nHi Sam,\n\nAttached find the sources / documentation in XMIT format. I\nenjoyed having contact with you.\n\nKeep up the good work.\n\nAll the best,\n\nHans Westheim\nEssent/ICT/Services/SAP Applicatiebeheer\n+31 (0)73-8557928 (kantoor)\n+31 (0)6-29503136 (mobiel)\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$README": {"ttr": 527, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x05\\x01\\x02)\\x0f\\x01\\x02)\\x0f\\x12&\\x00/\\x00\\x1e\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2002-10-17T00:00:00", "modifydate": "2002-10-17T12:26:05", "lines": 47, "newlines": 30, "modlines": 0, "user": "IBMUSER"}, "text": "==================================\nINTRODUCTION TO MPFCMDS PROCESSING\n==================================\n\nThis file is from Hans Westheim of Essent Energy Netherlands.\n\n   email: hans.westheim@essent.nl\n\nThe file created at 17 oct 2002\nCurrent Operating Systems at Essent OS/390 2.10\n\nMPFCMDS is an alternative for MPFXTALL at file 345. MPFXTALL (on my\nconfiguration abends A37-08). MPFCMDS is also a better alternative\nbecause it is more of a building block principle. By using this\nbuilding block principle it is easier to maintain and enhance.\nMPFCMDS makes use of all the fancy things off \"COMMAND (FILE 088)\".\nBy using COMMAND it can also issue reply's. (This was one of the\nlimitations of MPFXTALL.)\n\nMPFCMDS is a very simple tool which can be invoked through MPFLST\nmembers of your PARMLIB(s) in order to respond automatically to the\nappearance of any message on the operator's console.\n\n\nOPERATION\n\nFor any message to be automated, it must appear in an\nMPFLSTxx member with an entry such as the following:\n\nIST123I,USEREXIT(MPFCMDS)\n\nWhen message IST123I occurs, standard MVS MPF processing will invoke the\nMPFCMDS exit. MPFCMDS extracts the message id from the first 8 bytes\nof the message text and then executes the procedure MPFCMDS with the\nparameter MEMBER=IST123I. This procedure executes COMMAND (found at CBT\nfile 088) and uses as input the member IST123I from YOUR.CMDS.PDS.\nHaving found this member, COMMAND reads each line and, if it is not a\ncomment (an asterisk in column 1), issues the command as supplied.\n\nLIMITATIONS\n\nMessage numbers are restricted to a maximum of 8 bytes (length of a PDS\nmember name).  No code has been implemented to handle longer messages.\nThe commands than can be used in the input member is limited by the\nprogram \"COMMAND\". For details, have a look at member $COMMAND.\nThis program could also be substituted with an other command-processor.\n(Just update procedure MPFCMDS for this).\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$COMMAND": {"ttr": 529, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00B\\x01\\x02)\\x0f\\x01\\x19)?\\x16U\\x04\\xe6\\x04\\xe3\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2002-10-17T00:00:00", "modifydate": "2019-10-20T16:55:42", "lines": 1254, "newlines": 1251, "modlines": 0, "user": "IBMUSER"}, "text": "//COMMAND   JOB NOTIFY=&SYSUID.\n//*------------------------------------------------------------------*\n//* BEFORE SUBMITTING\n//* CHANGE \"YOUR.LINKLIB\" ---> YOUR LINKLIB\n//*------------------------------------------------------------------*\n//ASM      EXEC PGM=ASMA90,\n//             PARM='OBJECT,NOTEST,NOALIGN'\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR\n//         DD  DSN=SYS1.MODGEN,DISP=SHR\n//*        DD  DSN=SYS1.AMODGEN,DISP=SHR\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(CYL,(10,5))\n//SYSIN    DD  *\nCOMMAND  TITLE 'PROGRAM TO ISSUE O/S COMMANDS FROM A DATASET'\n***********************************************************************\n*  CHANGED TO GET RID OF DOUBLE MESSAGE IN SYSLOG                     *\n*  CHANGED TO GET RID OF DOUBLE MESSAGE IN SYSLOG                     *\n*  CHANGED TO GET RID OF DOUBLE MESSAGE IN SYSLOG                     *\n*  FIND HWE FOR CHANGES                                               *\n*                          C O M M A N D                              *\n*                                                                     *\n*        THIS PROGRAM WILL USE THE SVC 34 INTERFACE TO ISSUE O/S OR   *\n*        JES2 COMMANDS.                                               *\n*                                                                     *\n*        CALLERS OF THIS PROGRAM REQUIRE SPECIAL ACCESS               *\n*        AUTHORITY AS FOLLOWS:                                        *\n*                                                                     *\n*           THE USER MUST BE AUTHORIZED THROUGH A SPECIAL             *\n*           SECURITY CALL TO SAF FOR RESOURCE CLASS \"FACILITY\"        *\n*           AND ENTITY NAME \"COMMAND\".                                *\n*                                                                     *\n*                                                                     *\n*        WHAT MAKES THIS PROGRAM DIFFERENT FROM MOST PROGRAMS         *\n*        WHAT ISSUE COMMANDS ARE FOUR SPECIAL COMMANDS:               *\n*                                                                     *\n*        1)  DELAY=NNN - THIS COMMAND MAKES THE PROGRAM DELAY         *\n*            NNN SECONDS PRIOR TO ISSUING THE NEXT COMMAND IN         *\n*            THE LIST.                                                *\n*                                                                     *\n*        2)  REPLY JOBNAME MESSAGEID REPLYTEXT - THIS GIVES           *\n*            THE ABILITY TO REPLY TO OUTSTANDING REPLIES FOR          *\n*            SPECIFIED JOBS WITHOUT HAVING TO KNOW THE REPLY          *\n*            ID.                                                      *\n*                                                                     *\n*        3)  STARTED JOBNAME - THIS GIVES THE ABILITY TO WAIT         *\n*            FOR A SPECIFIC BATCH JOB OR STARTED TASK TO START        *\n*            OR TO INSURE THAT IT IS EXECUTING AT THE PRESENT         *\n*            TIME.                                                    *\n*                                                                     *\n*        4)  STOPPED JOBNAME - THIS GIVES THE ABILITY TO WAIT         *\n*            FOR A SPECIFIC BATCH JOB OR STARTED TASK TO END          *\n*            OR TO INSURE THAT IT IS NOT EXECUTING AT THE             *\n*            PRESENT TIME.                                            *\n*                                                                     *\n*        5)  IFSTARTED JOBNAME - THIS GIVES THE ABILITY TO  *      @BHW\n*            EXECUTE COMMANDS WHICH FOLLOW THIS COMMAND     *      @BHW\n*            ONLY IF THE SPECIFIED JOBNAME IS ACTIVE.  THE  *      @BHW\n*            ENDIF COMMAND ENDS THE IF NEST OF COMMANDS     *      @BHW\n*                                                           *      @BHW\n*        6)  IFSTOPPED JOBNAME - THIS GIVES THE ABILITY TO  *      @BHW\n*            EXECUTE COMMANDS WHICH FOLLOW THIS COMMAND     *      @BHW\n*            ONLY IF THE SPECIFIED JOBNAME IS NOT ACTIVE.   *      @BHW\n*            THE ENDIF COMMAND ENDS THE IF NEST OF COMMANDS *      @BHW\n*                                                           *      @BHW\n*        7)  ENDIF - THIS ENDS THE IF NESTED COMMANDS THAT  *      @BHW\n*            WERE STARTED BY EITHER THE IFSTARTED OR THE    *      @BHW\n*            IFSTOPPED COMMAND.  ONLY ONE IF NEST IS        *      @BHW\n*            SUPPORTED AT THIS TIME. BUT MULTI LEVEL NESTING*      @BHW\n*            IS PLANNED FOR IN THE CODE.                    *      @BHW\n*                                                           *      @BHW\n*        8)  WTO=TEXT  - ALLOWS YOU TO ISSUE WTOS OF        *      @BHW\n*            ANYTHING YOU WANT TO SAY, UP TO 72 CHARACTERS  *      @BHW\n*            THE FORMAT IS WTO=TEXT YOU WANT TO SAY         *      @BHW\n*                                                           *      @BHW\n*        9)  STOPCODE=NNNN -  ALLOWS YOU TO END PROCESSING  *      @BHW\n*            AND OPTIONALLY SET A CONDITION CODE OF UP TO   *      @BHW\n*            4 NUMERIC DIGITS                               *      @BHW\n*            THE FORMAT IS STOPCODE OR STOPCODE=NNNN WHERE  *      @BHW\n*            NNNN IS FROM 1 TO 4 DIGITS, IF YOU SPECIFY MORE*      @BHW\n*            THAN 4 DIGITS, THE NUMBERS AFTER THE 4TH WILL  *      @BHW\n*            BE IGNORED                                     *      @BHW\n*                                                           *      @BHW\n*        THE COMMANDS CAN COME FROM TWO INPUT SOURCES.  THE FIRST     *\n*        IS THE PARM VALUE ON THE EXECUTE CARD FOR THE STEP.  THE     *\n*        OTHER IS FROM THE INPUT DATA SET IEFRDER.  IF THE SOURCE     *\n*        IS THE PARM FIELD, MULTIPLE COMMANDS CAN BE ENTERED BY       *\n*        SEPARATING EACH COMMAND WITH A \";\".  IF THE SOURCE IS THE    *\n*        INPUT DATA SET, EACH RECORD WILL CONTAIN A SINGLE COMMAND    *\n*        STARTING IN COLUMN 1 THROUGH COLUMN 72 OF EACH RECORD.       *\n*        IF BOTH THE PARM AND INPUT DATASET ARE USED, THE COMMANDS    *\n*        IN THE PARM ARE EXECUTED FIRST.                              *\n*                                                                     *\n*        ONLY THE FIRST 72 CHARACTERS OF EACH COMMAND WILL BE USED    *\n*        WHEN ACTUALLY ISSUING THE COMMAND.                           *\n*                                                                     *\n*        COMMENTS CAN BE ENTERED WITH THE COMMANDS BY STARTING        *\n*        THE COMMAND WITH A '*'.  THIS CAUSES THE COMMAND TO BE       *\n*        BYPASSED.                                                    *\n*                                                                     *\n*        IF THE COMMAND IS \"DELAY=NNN\", THE PROGRAM WILL ENTER A      *\n*        WAIT FOR THE NUMBER OF SECONDS SPECIFIED BY \"NNN\".  IF       *\n*        MORE THAN A THREE DIGIT DELAY TIME IS SPECIFIED, ONLY        *\n*        THE FIRST THREE DIGITS WILL BE USED.                         *\n*                                                                     *\n*        IF THE COMMAND IS \"REPLY JOBNAME MESSAGEID REPLYTEXT\"        *\n*        THE PROGRAM WILL SEARCH FOR OUTSTANDING REPLIES FOR          *\n*        THE SPECIFIED JOBNAME AND CONTAINING THE OPTIONAL            *\n*        MESSAGE TEXT.                                                *\n*                                                                     *\n*        THE FULL JOBNAME MUST BE SPECIFIED.  THE USE IF THE          *\n*        MESSAGEID FIELD IS OPTIONAL.  IF MULTIPLE REPLIES MAY        *\n*        BE OUTSTANDING FOR THE JOB, THIS PARAMETER CAN BE USED       *\n*        TO SPECIFY A MESSAGEID OR CHARACER STRING CONTAINED IN       *\n*        THE MESSAGE.  IF NO MESSAGEID IS TO BE SPECIFIED, A          *\n*        '*' MUST BE SPECIFIED.  SINGLE QUOTES MAY BE USED IF         *\n*        THE STRING CONTAINS IMBEDDED BLANKS.                         *\n*                                                                     *\n*        THE REPLY TEXT MUST BE SPECIFIED.  SINGLE QUOTES MAY         *\n*        BE USED IF THE STRING CONTAINS IMBEDDED BLANKS.              *\n*                                                                     *\n*        IF THE COMMAND IS \"STOPPED JOBNAME\" THE PROGRAM WILL         *\n*        SEARCH ALL ACTIVE JOBS AND TASKS TO INSURE THAT THE          *\n*        SPECIFIED JOB OR TASK NAME IS NOT EXECUTING.  IF IT          *\n*        IS EXECUTING, A NON-ROLLABLE MESSAGE WILL BE SEND TO         *\n*        THE CONSOLE STATING THAT THE PROGRAM IS WAITING FOR          *\n*        THAT JOB TO STOP.  WHEN THE JOB OR TASK STOPS, THE           *\n*        MESSAGE WILL BE DELETED AND PROCESSING WILL CONTINUE.        *\n*                                                                     *\n*        IF THE COMMAND IS \"STARTED JOBNAME\" THE PROGRAM WILL         *\n*        SEARCH ALL ACTIVE JOBS AND TASKS TO INSURE THAT THE          *\n*        SPECIFIED JOB OR TASK NAME IS EXECUTING.  IF IT IS NOT       *\n*        EXECUTING, A NON-ROLLABLE MESSAGE WILL BE SEND TO THE        *\n*        CONSOLE STATING THAT THE PROGRAM IS WAITING FOR THAT         *\n*        JOB TO START.  WHEN THE JOB OR TASK STARTS, THE              *\n*        MESSAGE WILL BE DELETED AND PROCESSING WILL CONTINUE.        *\n*                                                                     *\n*                                                                     *\n*        BECAUSE THIS PROGRAM ISSUES THE MODESET MACRO AND USES       *\n*        CROSS MEMORY SERVICES, IT MUST BE APF AUTHORIZED TO DO       *\n*        SO.                                                          *\n*                                                                     *\n*        ESA VERSION 4 ALLOWS A REPLYID TO BE UP TO 4 CHARACTERS      *\n*        LONG.  THIS PROGRAM DOES NOT SUPPORT THIS.  IF THAT          *\n*        SUPPORT IS REQUIRED, THE REPLYID CAN BE EXTRACTED FROM       *\n*        THE BINARY REPLY ID IN FIELD WQERPYIB USING THE              *\n*        VERSION OF THE IHAWQE MACRO AND THE LENGTH OF THE            *\n*        REPLY IN THE COMMAND BUFFER CAN BE CHANGED.  SOME            *\n*        OTHER CHANGES WOULD LIKELY BE NEEDED FOR SYSPLEX AS          *\n*        WELL.   THIS CHANGE WAS NOT MADE TO KEEP COMPATIBILITY       *\n*        WITH ESA VERSION 3.                                          *\n*                                                                     *\n*                                                                     *\n*        WRITTEN BY:                                                  *\n*                   JOHN V. HOOPER                                    *\n*                   FOOD LION, INC.                                   *\n*                   2110 EXECUTIVE DRIVE                              *\n*                   SALISBURY, N.C.  28145-1330                       *\n*                                                                     *\n*        MODIFIED BY:                                                 *\n*                   BRIAN WESTERMAN                                   *\n*                   SYZYGY INCORPORATED                               *\n*                   1381 KILDAIRE FARM ROAD                           *\n*                   SUITE 326                                         *\n*                   CARY, N.C.  27511-5525                            *\n*                   (800) 767-2244                                    *\n*                   (800) 366-4082 -- FAX                             *\n*                   BRIANW45@AOL.COM --  EMAIL                        *\n*                   BRIAN_WESTERMAN@JUNO.COM -- EMAIL                 *\n*                                                                     *\n*                                                                     *\n*                           DISCLAIMER                                *\n*                                                                     *\n*      THE AUTHORS INCLUDING FOOD LION, ITS OFFICERS,                 *\n*      DIRECTORS, AND EMPLOYEES MAKE NO REPRESENTATION OR             *\n*      WARRANTY OF ANY KIND WHATSOEVER, INCLUDING, BUT NOT            *\n*      LIMITED TO, REPRESENTATIONS OR WARRANTIES, EXPRESS OR          *\n*      IMPLIED, OR MERCHANTABILITY, FITNESS FOR USE OR PURPOSE,       *\n*      ACCURACY OR COMPLETENESS OF PROCESSES, PROCEDURES,             *\n*      DESIGNS, DEFINITIONS, INSTRUCTIONS, INFORMATION, OR            *\n*      FUNCTIONING OF ANY PROGRAMS, DOCUMENTS, OR RELATED             *\n*      MATERIALS; THE AUTHORS FURTHER EXPRESSLY DISCLAIM ANY          *\n*      KNOWLEDGE OF PURPOSE FOR WHICH THESE PROGRAMS,                 *\n*      DOCUMENTS, OR RELATED MATERIAL MAY BE UTILIZED OR THEIR        *\n*      APPLICABILITY FOR SUCH USE, NOR SHALL THE FACT OF MAKING       *\n*      THEM AVAILABLE CONSTITUTE ANY SUCH REPRESENTATION,             *\n*      WARRANTY, OR KNOWLEDGE; NOR DO THE AUTHORS ASSUME ANY          *\n*      LIABILITY, RESPONSIBILITY, OR OBLIGATION ARISING FROM          *\n*      THE USE OR MALFUNCTIONING OF OF THESE COMPUTER PROGRAMS,       *\n*      DOCUMENTATION, OR RELATED MATERIALS.                           *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*                        SAMPLE JCL                                   *\n*                                                                     *\n*       //JOBNAME ...                                                 *\n*       //COMMAND  EXEC PGM=COMMAND,REGION=4M                         *\n*       //IEFRDER  DD  *                                              *\n*       D R,R                                                         *\n*       DELAY=10                                                      *\n*       STARTED CICS                                                  *\n*       DELAY=10                                                      *\n*       REPLY TESTJOB 'WAITING FOR' 'STOP'                            *\n*       DELAY 10                                                      *\n*       REPLY TESTJOB * YES                                           *\n*       DELAY 10                                                      *\n*       D R,R                                                         *\n*                                                                     *\n*       IN THE ABOVE EXAMPLE, THE DELAY COMMAND IS USED TO            *\n*       PAUSE THE PROGRAM FOR 10 SECONDS BETWEEN COMMANDS TO          *\n*       ALLOW TIME FOR THE PREVIOUS COMMAND TO BE EXECUTED.           *\n*                                                                     *\n*       THE STARTED COMMAND WILL INSURE THAT THE JOB OR TASK          *\n*       CICS IS EXECUTING.                                            *\n*                                                                     *\n*       THE FIRST REPLY COMMAND WILL REPLY 'STOP' TO THE FIRST        *\n*       OUTSTANDING REPLY FOR JOB TESTJOB WHICH CONTAINS              *\n*       THE CHARACTERS 'WAITING FOR'.                                 *\n*                                                                     *\n*       THE SECOND REPLY COMMAND WILL REPLY 'YES' TO THE              *\n*       FIRST OUTSTANDING REPLY FOR JOB TESTJOB NO                    *\n*       MATTER WHAT REPLY MESSAGE IS OUTSTANDING.                     *\n*                                                                     *\n***********************************************************************\n         EJECT\n***********************************************************************\n*                                                                     *\n*            M A C R O S   U S E D   I N   C O M M A N D              *\n*                                                                     *\n*        01)  ABEND        SYS1.MACLIB                                *\n*        02)  AXSET        SYS1.MACLIB                                *\n*        03)  CALL         SYS1.MACLIB                                *\n*        04)  CLOSE        SYS1.MACLIB                                *\n*        05)  CVT          SYS1.MODGEN                                *\n*        06)  DCB          SYS1.MACLIB                                *\n*        07)  DOM          SYS1.MACLIB                                *\n*        08)  EXTRACT      SYS1.MACLIB                                *\n*        09)  FREEMAIN     SYS1.MACLIB                                *\n*        10)  GET          SYS1.MACLIB                                *\n*        11)  GEMAIN       SYS1.MACLIB                                *\n*        12)  IEECUCM      SYS1.MODGEN                                *\n*        13)  IEFTIOT1     SYS1.MACLIB                                *\n*        14)  IHAASCB      SYS1.MODGEN                                *\n*        15)  IHAASVT      SYS1.MODGEN                                *\n*        16)  IHAORE       SYS1.MODGEN                                *\n*        17)  IHAPSA       SYS1.MACLIB                                *\n*        18)  IHAWQE       SYS1.MODGEN                                *\n*        19)  MGCR         SYS1.MODGEN                                *\n*        20)  MODESET      SYS1.MACLIB                                *\n*        21)  OPEN         SYS1.MACLIB                                *\n*        22)  RETURN       SYS1.MACLIB                                *\n*        23)  SAVE         SYS1.MACLIB                                *\n*        24)  SETLOCK      SYS1.MACLIB                                *\n*        25)  STIMER       SYS1.MACLIB                                *\n*        26)  WTO          SYS1.MACLIB                                *\n*                                                                     *\n*                                                                     *\n*               L I N K A G E    E D I T O R    I N F O               *\n*                                                                     *\n*        SIZE:       3K                                               *\n*        ATTRIBUTES: AUTHORIZED NORENT NOREUS NOREFR                  *\n*                    AMODE24    RMODE24                               *\n*                                                                     *\n***********************************************************************\n         EJECT\n*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         EJECT\n***********************************************************************\n*                                                                     *\n*        START OF PROGRAM                                             *\n*                                                                     *\n***********************************************************************\nCOMMAND  CSECT\nCOMMAND  AMODE 24\nCOMMAND  RMODE 24\n         SAVE  (14,12)             SAVE REGISTERS\n         LR    R12,R15             SET BASE REGISTER\n         USING COMMAND,R12         SET ADDRESSABILITY\n         LA    R15,SAVEAREA        LOAD ADDRESS OF NEW SAVE\n         ST    R15,8(R13)          STORE NEW SAVE ADDR IN OLD\n         ST    R13,4(R15)          STORE OLD SAVE ADDR IN NEW\n         LR    R13,R15             SET NEW SAVE ADDRESS\n         LR    R2,R1               SAVE INPUT PARM ADDRESS\n         EJECT\n***********************************************************************\n*                                                                     *\n*  CHECK THE AUTHORITY OF THE USER TO SAF CLASS \"FACILITY' FOR        *\n*  ENTITY \"COMMAND\".  NOTE THAT FASTAUTH IS USED.  TO AVOID THE       *\n*  SITUATION WHERE SPECIAL ATTRIBUTES OF THE USER MAY ALLOW THE       *\n*  ACCESS WITH LOGGING, A CHECK IS MADE FOR A NON-ZERO REASON         *\n*  CODE.  THIS CONDITION WILL BE CONSIDERED A FAILURE.                *\n*                                                                     *\n***********************************************************************\n         B     EXTRACT             ALLOW ALL AT THIS TIME\nAUTHTST  RACROUTE REQUEST=FASTAUTH,WORKA=RACWORK,WKAREA=FRACWORK,      X\n               ENTITY=RESOURCE,CLASS=FACILITY,ATTR=READ,               X\n               MF=(E,RACROUTE)\n         CH    R15,=H'4'           TEST THE RETURN CODE\n         BE    EXTRACT             NO DECISION POSSIBLE, OK\n         BH    NOTAUTH             GREATER THAN 4, NOT AUTHORIZED\n         CLC   RACROUTE+4(4),=F'0' TEST THE REASON CODE\n         BE    EXTRACT             ZERO, AUTHORIZED\nNOTAUTH  WTO   'CMD913E UNAUTHORIZED USE OF THE COMMAND PROGRAM - JOB AX\n               BORTED',ROUTCDE=(2,11)\n         ABEND X'913',,,SYSTEM,REASON=0  ABEND THE JOB\n***********************************************************************\n*                                                                     *\n*        EXTRACT MY JOB NAME FOR THE WTO MESSAGES                     *\n*                                                                     *\n***********************************************************************\nEXTRACT  EXTRACT TIOTADDR,'S',FIELDS=TIOT EXTRACT THE ADDR OF THE TIOT\n         L     R3,TIOTADDR         LOAD ADDRESS OF THE TIOT\n         USING TIOT,R3             SET ADDRESSABILITY TO THE TIOT\n         MVC   MYNAME,TIOCNJOB     SAVE THE JOBNAME\n         DROP  R3                  DROP ADDRESSABILITY TO THE TIOT\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*        GET STORAGE FOR AN OUTSTANDING REPLY TABLE                   *\n*                                                                     *\n***********************************************************************\n         GETMAIN R,LV=13801        GET STORAGE FOR TABLE\n         ST    R1,GETADDR          SAVE TABLE ADDRESS\n         EJECT\n***********************************************************************\n*                                                                     *\n*        SEE IF A PARM HAS BEEN ENTERED.  IF SO, PROCESS EACH         *\n*        COMMAND WITHIN THE PARM.                                     *\n*                                                                     *\n***********************************************************************\nCKPARM   LR    R1,R2               RESTORE INPUT PARM ADDRESS\n         LTR   R1,R1               SEE IF INPUT PARM\n         BZ    OPEN                NONE, GO OPEN FILE\n         L     R9,0(R1)            LOAD PARM ADDRESS\n         LTR   R9,R9               TEST PARM ADDRESS\n         BZ    OPEN                ZERO, NO PARM, GO OPEN FILE\n         LH    R8,0(R9)            LOAD PARM LENGTH\n         LTR   R8,R8               TEST PARM LENGTH\n         BZ    OPEN                ZERO, NO PARM, GO OPEN FILE\n         LA    R9,2(R9)            POINT TO ACTUAL PARM\nCKPARM1  LR    R1,R9               SAVE START ADDRESS OF PARM\n         SLR   R15,R15             SET LENGTH OF COMMAND\nCKPARM2  CLI   0(R1),C';'          SEE IF END OF COMMAND\n         BE    CKPARM3             YES, BRANCH\n         LA    R15,1(R15)          ADD 1 TO LENGTH\n         LA    R1,1(R1)            INCREMENT TO NEXT CHAR OF PARM\n         BCT   R8,CKPARM2          LOOP FOR NEXT CHAR OF PARM\nCKPARM3  LTR   R15,R15             TEST FOR ZERO LENGTH\n         BZ    CKPARM5             ZERO, NULL COMMAND, BRANCH\n         CH    R15,=H'72'          SEE IF EXCEEDS MAX LENGTH\n         BNH   CKPARM4             NO, BRANCH\n         LA    R15,72              SET TO MAX LENGTH\nCKPARM4  MVI   COMDATA+4,C' '      BLANK THE ENTIRE\n         MVC   COMDATA+4+1(79),COMDATA+4  COMMAND AREA\n         BCTR  R15,0               MAKE MACHINE LENGTH\n         EX    R15,PARMCMD         MOVE PARM COMMAND TO BUFFER\n         LR    R9,R1               SET NEW START OF CMD POINTER\n         BAL   R10,DOCMD           GO ISSUE THE COMMAND\nCKPARM5  CLI   0(R9),C';'          IS THERE ANOTHER COMMAND\n         BNE   OPEN                NO, GET OUT\n         LA    R9,1(R9)            INCREMENT PAST SEMICOLON\n         BCTR  R8,0                REDUCE REMAINING PARM LENGTH BY 1\n         LTR   R8,R8               TEST REMAINING PARM LENGTH\n         BZ    OPEN                ZERO, FINISHED\n         B     CKPARM1             GO PROCESS THIS COMMAND\nPARMCMD  MVC   COMDATA+4(0),0(R9)  **** EXECUTE ONLY ****\n         EJECT\n***********************************************************************\n*                                                                     *\n*        OPEN THE IEFRDER DATA SET (IF SPECIFIED).                    *\n*                                                                     *\n***********************************************************************\nOPEN     SLR   R15,R15        CLEAR REGISTER FOR ICM\n         L     R14,16         POINT TO CVT\n         L     R14,0(,R14)    POINT TO TCB POINTERS\n         L     R14,4(,R14)    POINT TO CURRENT TCB\n         L     R14,12(,R14)   POINT TO TIOT\n         LA    R14,24(,R14)   POINT TO TIOT DD ENTRIES\nOPEN1    ICM   R15,1,0(R14)   LOAD ENTRY LENGTH\n         BZ    RETURN         END OF TIOT, END OF PROCESSING\n         CLC   4(8,R14),=CL8'IEFRDER' SEE IF DD STATEMENT SPECIFIED\n         BE    OPEN2          YES, GET OUT\n         LA    R14,0(R15,R14) INCREMENT TO NEXT ENTRY\n         B     OPEN1          LOOP\n***********************************************************************\n*                                                                     *\n*        READ INPUT FILE.  PASS THE FIRST 72 CHARACTERS OF EACH       *\n*        RECORD TO O/S AS A COMMAND.                                  *\n*                                                                     *\n***********************************************************************\nOPEN2    OPEN  (IEFRDER,(INPUT))   OPEN INPUT FILE\nREAD     GET   IEFRDER             READ INPUT FILE\n         MVI   COMDATA+4,C' '      BLANK THE ENTIRE\n         MVC   COMDATA+4+1(79),COMDATA+4  COMMAND AREA\n         MVC   COMDATA+4(72),0(R1) MOVE IN JES OR O/S COMMAND\n         BAL   R10,DOCMD           GO ISSUE THE COMMAND\n         B     READ\n         EJECT\n***********************************************************************\n*                                                                     *\n*        END OF THE PROGRAM                                           *\n*                                                                     *\n***********************************************************************\nEOF      CLOSE (IEFRDER)           CLOSE INPUT FILE\nRETURN   L     R1,GETADDR          LOAD ADDRESS OF GETMAINED TABLE\n         FREEMAIN R,LV=13801,A=(1) FREE STORAGE USED BY THE TABLE\n         L     R13,4(,R13)         LOAD ADDRESS OF OLD SAVE AREA\n         SLR   R15,R15             CLEAR R15                      @BHW\n         L     R15,RETCODE         LOAD RETURN CODE FROM SAVE AREA@BHW\n         RETURN (14,12),T,RC=(15)  RETURN TO O/S                  @BHW\n         EJECT\n***********************************************************************\n*                                                                     *\n*        EITHER ISSUE THE COMMAND WHICH HAS BEEN STORED AT            *\n*        COMDATA+4 OR IF IT IS A DELAY COMMAND, WAIT THE SPECIFIED    *\n*        INTERVAL OF TIME BEFORE CONTINUING WITH OTHER COMMANDS.      *\n*                                                                     *\n*        INPUT:  COMMAND AT COMDATA+4                                 *\n*                R10 - RETURN ADDRESS                                 *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n***********************************************************************\n*        SEE IF THE COMMAND IS A DELAY COMMAND TO THE PROGRAM TO      *\n*        WAIT A SPECIFIED INTERVAL OF TIME BEFORE CONTINUING WITH     *\n*        OTHER INPUT COMMANDS.                                        *\n***********************************************************************\nDOCMD    CLI   COMDATA+4,C'*'      SEE IF A COMMENT STATEMENT\n         BER   R10                 YES, BYPASS THIS COMMAND\n         CLC   COMDATA+4(5),=CL5'ENDIF' SEE IF A ENDIF COMMAND  @BHW\n         BE    DOCMD9              YES, PROCESS ENDIF           @BHW\n         CLC   IFACTIVE,=F'1'      ARE WE IN INVALID IF TEST?   @BHW\n         BER   R10                 YES, THEN BYPASS THIS COMMAND@BHW\n         CLC   COMDATA+4(4),=CL4'WTO=' SEE IF A WTO COMMAND @BHW\n         BNE   DOCMD1              NO, GO SEE IF REPLY COMMAND @BHW\n         MVC   COMDATA+4(4),=CL4'    ' CLEAR THE WTO=\n         WTO   MF=(E,COMDATA)       ECHO THE TEXT ON THE CONSOLE@BHW\n         BR    R10                 GO GET NEXT RECORD             @BHW\nDOCMD1   CLC   COMDATA+4(6),=CL6'DELAY=' SEE IF A DELAY COMMAND\n         BNE   DOCMD2              NO, GO SEE IF REPLY COMMAND\nDOCMD1W  WTO   MF=(E,COMDATA)      ECHO THE COMMAND ON THE CONSOLE\n         LA    R2,COMDATA+10       POINT TO START OF \"DELAY=\" VALUE\n         LA    R3,8                SET MAXIMUM LENGTH OF DELAY VALUE\n         SLR   R4,R4               SET LENGTH COUNTER\nDOCMD1A  CLI   0(R2),C' '          END OF DELAY VALUE\n         BE    DOCMD1B             YES, BRANCH\n         LA    R4,1(,R4)           ADD 1 TO LENGTH COUNTER\n         CLI   0(R2),C'0'          SEE IF LT 0\n         BL    DOCMD1C             YES, NOT NUMERIC\n         CLI   0(R2),C'9'          SEE IF GT 9\n         BH    DOCMD1C             YES, NOT NUMERIC\n         LA    R2,1(,R2)           INCREMENT TO NEXT INPUT CHARACTER\n         BCT   R3,DOCMD1A          LOOP UP TO 8 TIMES\n         CLI   0(R2),C' '          END OF DELAY VALUE\n         BNE   DOCMD1C             NO, TOO LONG\nDOCMD1B  LTR   R4,R4               TEST LENGTH\n         BZ    DOCMD1C             ZERO, BLANK\n         BCTR  R4,0                MAKE MACHINE LENGTH\n         EX    R4,PACKTIME         PACK THE DELAY VALUE\n         CVB   R5,DOUBLE           CONVERT DELAY TO BINARY\n         LTR   R5,R5               CHECK VALUE\n         BZ    DOCMD1C             ZERO, INVALID\n         CH    R5,=H'999'          SEE IF EXCEEDS MAXIMUM VALUE\n         BH    DOCMD1C             YES, ERROR\n         MH    R5,=H'100'          MULTIPLY BY 100\n         ST    R5,WAITIME          SAVE WAIT TIME IN HUNDRETHS OF A SEC\n         STIMER WAIT,BINTVL=WAITIME WAIT THE SPECIFIED TIME\n         B     DOCMD6              GO GET ANOTHER COMMAND\nDOCMD1C  WTO   'CMD001E ILLEGAL VALUE SPECIFIED ON THE DELAY CONTROL STX\n               ATEMENT - JOB ABORTED',ROUTCDE=(2,11)\n         ABEND 0001,DUMP           ABEND THE STEP\n         EJECT\n***********************************************************************\n*                                                                     *\n*        PROCESS A REPLY COMMAND                                      *\n*                                                                     *\n***********************************************************************\nDOCMD2   CLC   COMDATA+4(6),=CL6'REPLY ' SEE IF A REPLY COMMAND\n         BNE   DOCMD3              NO, GO SEE IF WAIT COMMAND\n***********************************************************************\n*                                                                     *\n*        PARSE THE REPLY COMMAND                                      *\n*                                                                     *\n***********************************************************************\n         MVC   REPLYWK(72),COMDATA+4   SAVE REPLY COMMAND\n         LA    R1,REPLYWK+5        POINT TO START OF REPLY DATA\n         LA    R14,72-5            LOAD LENGTH OF REPLY DATA\n         MVI   DELIM,C' '          SET DELIMETER TO BLANK\n         LA    R2,PARMS            POINT TO PARM TABLE\n         SLR   R15,R15             SET PARM COUNT TO ZERO\nDOCMD2A  CLC   0(1,R1),DELIM       SEE IF START OF PARM\n         BNE   DOCMD2B             NO, BRANCH\n         LA    R1,1(,R1)           INCREMENT TO NEXT CHAR OF PARMS\n         BCT   R14,DOCMD2A         LOOP\n         B     DOCMD2F             END OF PARM, BRANCH\nDOCMD2B  CH    R15,=H'3'           SEE IF ALREADY FOUND MAX PARMS\n         BNL   DOCMD2F             YES, IGNORE ANY OTHERS\n         LA    R15,1(,R15)         ADD 1 TO PARM COUNTER\n         CLI   0(R1),C''''         SEE IF QUOTED STRING\n         BNE   DOCMD2C             NO, BRANCH\n         MVC   DELIM,0(R1)         SET DELIMETER\n         LA    R1,1(,R1)           INCREMENT PAST DELIMETER\n         BCTR  R14,0               DECREMENT REMAINING CHARACTER COUNT\n         LTR   R14,R14             TEST REMAINING CHARACTER COUNT\n         BNP   DOCMD2F             DONE, GET OUT\nDOCMD2C  ST    R1,0(R2)            SAVE START ADDRESS OF PARM\nDOCMD2D  CLC   0(1,R1),DELIM       SEE IF END OF PARM\n         BE    DOCMD2E             YES, BRANCH\n         LA    R1,1(,R1)           INCREMENT TO NEXT CHAR OF PARMS\n         BCT   R14,DOCMD2D         LOOP\nDOCMD2E  S     R1,0(R2)            SUBTRACT START ADDR FROM ENDING\n         ST    R1,4(R2)            SAVE PARM LENGTH\n         A     R1,0(R2)            RESTORE END ADDRESS\n         LA    R1,1(,R1)           INCREMENT PAST DELIMETER\n         BCTR  R14,0               DECREMENT REMAINING CHARACTER COUNT\n         LTR   R14,R14             TEST REMAINING CHARACTER COUNT\n         BNP   DOCMD2F             DONE, GET OUT\n         MVI   DELIM,C' '          SET DEFAULT DELIMETER\n         LA    R2,8(,R2)           INCREMENT TO NEXT PARM POINTER\n         B     DOCMD2A             GO PROCESS NEXT PARM\nDOCMD2F  CH    R15,=H'3'           SEE IF THREE PARMS\n         BE    DOCMD2G             YES, BRANCH\n         MVC   COMDATA+4+72(8),=CL8' ERROR01' SET ERROR FLAG\n         B     DOCMD2P             GO ECHO THE COMMAND\nDOCMD2G  CLC   JOBNL,=F'0'         TEST LENGTH OF THE JOBNAME\n         BNZ   DOCMD2H             NOT ZERO, BRANCH\n         MVC   COMDATA+4+72(8),=CL8' ERROR02' SET ERROR FLAG\n         B     DOCMD2P             GO ECHO THE COMMAND\nDOCMD2H  CLC   JOBNL,=F'8'         TEST LENGTH OF THE JOBNAME\n         BNH   DOCMD2I             NOT GREATER THAN 8, BRANCH\n         MVC   COMDATA+4+72(8),=CL8' ERROR03' SET ERROR FLAG\n         B     DOCMD2P             GO ECHO THE COMMAND\n***********************************************************************\n*                                                                     *\n*        GO GET A LIST OF OUTSTANDING REPLIES                         *\n*                                                                     *\n***********************************************************************\nDOCMD2I  L     R1,GETADDR          LOAD ADDRESS OF REPLY TABLE\n         CALL  REPLY               CALL THE SUBROUTINE\n***********************************************************************\n*                                                                     *\n*        FIND AN OUTSTANDING REPLY FOR THE SPECIFIED JOBNAME          *\n*                                                                     *\n***********************************************************************\nDOCMD2J  MVC   JOBNAME,=CL8' '     BLANK THE JOBNAME\n         L     R14,JOBN            LOAD ADDRESS OF JOBNAME\n         L     R15,JOBNL           LOAD LENGTH OF JOBNAME\n         BCTR  R15,0               MAKE MACHINE LENGTH\n         EX    R15,SETNAME         SET THE FULL JOB NAME\n         L     R3,GETADDR          LOAD ADDRESS OF REPLY TABLE\n         USING MSGENT,R3           SET ADDRESSABILITY TO REPLY TABLE\nDOCMD2K  CLI   0(R3),X'FF'         END OF TABLE, BRANCH\n         BNE   DOCMD2L             NO, BRANCH\n         MVC   COMDATA+4+72(8),=CL8' ERROR04' SET ERROR FLAG\n         B     DOCMD2P             GO ECHO THE COMMAND\nDOCMD2L  CLC   JNAME,JOBNAME       SEE IF MATCH ON JOB NAME\n         BE    DOCMD2N             YES, BRANCH\nDOCMD2M  LA    R3,L'MSGENT(,R3)    INCREMENT TO NEXT REPLY TABLE ENTRY\n         B     DOCMD2K             LOOP\n***********************************************************************\n*                                                                     *\n*        SEE IF THIS REPLY CONTAINS THE SPECIFIED TEXT (IF ANY)       *\n*                                                                     *\n***********************************************************************\nDOCMD2N  LA    R14,MSG             POINT TO MESSAGE TEST\n         LA    R15,128             LOAD MESSAGE LENGTH\n         S     R15,MATCHL          CALCULATE LOOP COUNTER\n         L     R1,MATCHL           LOAD LENGTH OF MATCH TEXT\n         BCTR  R1,0                MAKE MACHINE LENGTH\n         L     R2,MATCH            LOAD ADDRESS OF MATCH TEXT\n         CLC   MATCHL,=F'0'        SEE IF LENGTH OF TEXT = 0\n         BE    DOCMD2P             YES, USE THIS OUTSTANDING REPLY\n         CLC   MATCHL,=F'1'        SEE IF LENGTH OF TEXT = 1\n         BH    DOCMD2O             NO, BRANCH\n         CLI   0(R2),C'*'          SEE IF NULL MATCH TEXT\n         BE    DOCMD2P             YES, USE THIS OUTSTANDING REPLY\nDOCMD2O  EX    R1,COMPTEXT         SEE IF MATCH MESSAGE TEXT\n         BE    DOCMD2P             YES, BRANCH\n         LA    R14,1(,R14)         POINT TO NEXT CHARACTER OF TEXT\n         BCT   R15,DOCMD2O         LOOP\n         B     DOCMD2M             NO MATCH FOR TEXT, FIND ANOTHER MSG\nDOCMD2P  WTO   MF=(E,COMDATA)      ECHO THE COMMAND ON THE CONSOLE\n         CLC   COMDATA+4+72(8),=CL8' ' SEE IF ERROR HAS OCCURRED\n         BNE   DOCMD6              YES, DROP THIS REPLY COMMAND\n         MVI   COMDATA+4,C' '      BLANK THE ENTIRE\n         MVC   COMDATA+4+1(79),COMDATA+4  COMMAND AREA\n         MVI   COMDATA+4,C'R'      SET REPLY CHARACTER\n         MVC   COMDATA+4+2(2),RID  SET REPLY ID\n         MVI   COMDATA+4+4,C','    SET THE END OF THE REPLY ID\n         L     R1,REPLYTX          LOAD ADDRESS OF THE REPLY TEXT\n         ICM   R15,B'1111',REPLYTXL LOAD LENGTH OF REPLY TEXT\n         BZ    DOCMD5              ZERO, GO ISSUE THE NULL REPLY\n         MVI   COMDATA+4+5,C''''   SET START QUOTE FOR REPLY\n         BCTR  R15,0               MAKE MACHINE LENGTH\n         EX    R15,SETREPLY        SET THE REPLY TEXT\n         LA    R15,COMDATA+4+6+1(R15) POINT PAST REPLY\n         MVI   0(R15),C''''        SET ENDING QUOTE FOR REPLY\n         WTO   MF=(E,COMDATA)      ECHO THE COMMAND ON THE CONSOLE\n         B     DOCMD5              GO ISSUE THE REPLY\nCOMPTEXT CLC   0(0,R14),0(R2)      **** EXECUTE ONLY ****\nSETREPLY MVC   COMDATA+4+6(0),0(R1) *** EXECUTE ONLY ****\n         DROP  R3                  DROP ADDRESSABILITY TO REPLY TABLE\n         EJECT\n***********************************************************************\n*                                                                     *\n*        PROCESS A STOPPED COMMAND                                    *\n*                                                                     *\n***********************************************************************\nDOCMD3   CLC   COMDATA+4(8),=CL8'STOPPED' SEE IF A STOPPED COMMAND\n         BNE   DOCMD4              NO, GO SEE IF STARTED COMMAND\n         WTO   MF=(E,COMDATA)      ECHO THE COMMAND ON THE CONSOLE\n***********************************************************************\n*                                                                     *\n*        PARSE THE STOPPED COMMAND                                    *\n*                                                                     *\n***********************************************************************\n         MVC   REPLYWK(72),COMDATA+4   SAVE STOPPED COMMAND\n         LA    R1,REPLYWK+8        POINT TO START OF STOPPED DATA\n         LA    R15,72-8            LOAD LENGTH OF STOPPED DATA\n         SLR   R14,R14             SET LENGTH OF JOBNAME TO ZERO\nDOCMD3A  CLC   0(1,R1),C' '        SEE IF START OF JOBNAME\n         BNE   DOCMD3B             NO, BRANCH\n         LA    R1,1(,R1)           INCREMENT TO NEXT CHAR OF PARMS\n         BCT   R15,DOCMD3A         LOOP\n         B     DOCMD3Z             END OF PARM, NO JOBNAME, BYPASS\nDOCMD3B  LR    R14,R1              SAVE START ADDRESS OF JOBNAME\nDOCMD3C  CLC   0(1,R1),C' '        SEE IF END OF JOBNAME\n         BE    DOCMD3D             YES, BRANCH\n         LA    R1,1(,R1)           INCREMENT TO NEXT CHAR OF JOBNAME\n         BCT   R15,DOCMD3C         LOOP\nDOCMD3D  SR    R1,R14              SUBTRACT START ADDR FROM ENDING\n         CH    R1,=H'8'            TEST LENGTH OF THE JOBNAME\n         BNH   DOCMD3E             NOT GREATER THAN 8, BRANCH\n         LA    R1,8                SET LENGTH TO 8\nDOCMD3E  MVC   JOBNAME,=CL8' '     BLANK THE JOBNAME\n         BCTR  R1,0                MAKE MACHINE LENGTH\n         EX    R1,SETNAME          SET THE FULL JOB NAME\n***********************************************************************\n*                                                                     *\n*        SEE IF THE REQUESTED JOB/TASK IS RUNNING                     *\n*                                                                     *\n***********************************************************************\nDOCMD3F  LA    R1,JOBNAME          POINT TO JOBNAME\n         BAL   R14,JOBSRCH         GO SEE IF JOB IS EXECUTING\n         LTR   R15,R15             TEST THE RETURN CODE\n         BNZ   DOCMD3Z             NOT ZER0, NOT EXECUTING, EXIT\n***********************************************************************\n*                                                                     *\n*        ISSUE THE WTO MESSAGE IF NOT ALREADY ISSUED                  *\n*                                                                     *\n***********************************************************************\n         CLC   WTOMSGID,=XL8'00'   SEE IF MESSAGE ALREADY ISSUED\n         BNE   DOCMD3G             YES, GO WAIT A BIT\n         MVC   WAITMSG1+4+08(8),MYNAME  MOVE MY JOBNAME TO MESSAGE\n         MVC   WAITMSG1+4+29(8),JOBNAME MOVE JOBNAME TO MESSAGE\n         WTO   MF=(E,WAITMSG1)     ISSUED THE WTO MESSAGE\n         ST    R1,WTOMSGID         SAVE THE WTO MESSAGE ID FOR DOM\n***********************************************************************\n*                                                                     *\n*        WAIT 15 SECONDS AND TRY AGAIN                                *\n*                                                                     *\n***********************************************************************\nDOCMD3G  STIMER WAIT,BINTVL=SEC15  WAIT 15 SECONDS\n         B     DOCMD3F             GO SEE IF JOB HAS COMPLETED YET\n***********************************************************************\n*                                                                     *\n*        DELETE THE WTO MESSAGE IF IT HAS BEEN ISSUED                 *\n*        AND EXIT                                                     *\n*                                                                     *\n***********************************************************************\nDOCMD3Z  ICM   R1,B'1111',WTOMSGID LOAD WTO MESSAGE ID\n         BZ    DOCMD6              ZERO, NO MESSAGE, GET OUT\n         DOM   MSG=(1)             DELETE OPERATOR MESSAGE\n         XC    WTOMSGID,WTOMSGID   CLEAR THE WTO MESSAGE ID\n         B     DOCMD6              GO GET ANOTHER COMMAND\n         SPACE 3\nWAITMSG1 WTO   'CMD002I ........ WAITING FOR ........ TO COMPLETE',    X\n               ROUTCDE=(2,11),DESC=2,MF=L\n         EJECT\n***********************************************************************\n*                                                                     *\n*        PROCESS A STARTED COMMAND                                    *\n*                                                                     *\n***********************************************************************\nDOCMD4   CLC   COMDATA+4(8),=CL8'STARTED' SEE IF A STARTED COMMAND\n         BNE   DOCMD7              NO, SEE IF IFSTARTED COMMAND    @BHW\n         WTO   MF=(E,COMDATA)      ECHO THE COMMAND ON THE CONSOLE\n***********************************************************************\n*                                                                     *\n*        PARSE THE STARTED COMMAND                                    *\n*                                                                     *\n***********************************************************************\n         MVC   REPLYWK(72),COMDATA+4   SAVE STARTED COMMAND\n         LA    R1,REPLYWK+8        POINT TO START OF STARTED DATA\n         LA    R15,72-8            LOAD LENGTH OF STARTED DATA\n         SLR   R14,R14             SET LENGTH OF JOBNAME TO ZERO\nDOCMD4A  CLC   0(1,R1),C' '        SEE IF START OF JOBNAME\n         BNE   DOCMD4B             NO, BRANCH\n         LA    R1,1(,R1)           INCREMENT TO NEXT CHAR OF PARMS\n         BCT   R15,DOCMD4A         LOOP\n         B     DOCMD4Z             END OF PARM, NO JOBNAME, BYPASS\nDOCMD4B  LR    R14,R1              SAVE START ADDRESS OF JOBNAME\nDOCMD4C  CLC   0(1,R1),C' '        SEE IF END OF JOBNAME\n         BE    DOCMD4D             YES, BRANCH\n         LA    R1,1(,R1)           INCREMENT TO NEXT CHAR OF JOBNAME\n         BCT   R15,DOCMD4C         LOOP\nDOCMD4D  SR    R1,R14              SUBTRACT START ADDR FROM ENDING\n         CH    R1,=H'8'            TEST LENGTH OF THE JOBNAME\n         BNH   DOCMD4E             NOT GREATER THAN 8, BRANCH\n         LA    R1,8                SET LENGTH TO 8\nDOCMD4E  MVC   JOBNAME,=CL8' '     BLANK THE JOBNAME\n         BCTR  R1,0                MAKE MACHINE LENGTH\n         EX    R1,SETNAME          SET THE FULL JOB NAME\n***********************************************************************\n*                                                                     *\n*        SEE IF THE REQUESTED JOB/TASK IS RUNNING                     *\n*                                                                     *\n***********************************************************************\nDOCMD4F  LA    R1,JOBNAME          POINT TO JOBNAME\n         BAL   R14,JOBSRCH         GO SEE IF JOB IS EXECUTING\n         LTR   R15,R15             TEST THE RETURN CODE\n         BZ    DOCMD4Z             ZER0, EXECUTING, EXIT\n***********************************************************************\n*                                                                     *\n*        ISSUE THE WTO MESSAGE IF NOT ALREADY ISSUED                  *\n*                                                                     *\n***********************************************************************\n         CLC   WTOMSGID,=XL8'00'   SEE IF MESSAGE ALREADY ISSUED\n         BNE   DOCMD4G             YES, GO WAIT A BIT\n         MVC   WAITMSG2+4+08(8),MYNAME  MOVE MY JOBNAME TO MESSAGE\n         MVC   WAITMSG2+4+29(8),JOBNAME MOVE JOBNAME TO MESSAGE\n         WTO   MF=(E,WAITMSG2)     ISSUED THE WTO MESSAGE\n         ST    R1,WTOMSGID         SAVE THE WTO MESSAGE ID FOR DOM\n***********************************************************************\n*                                                                     *\n*        WAIT 15 SECONDS AND TRY AGAIN                                *\n*                                                                     *\n***********************************************************************\nDOCMD4G  STIMER WAIT,BINTVL=SEC15  WAIT 15 SECONDS\n         B     DOCMD4F             GO SEE IF JOB HAS COMPLETED YET\n***********************************************************************\n*                                                                     *\n*        DELETE THE WTO MESSAGE IF IT HAS BEEN ISSUED                 *\n*        AND EXIT                                                     *\n*                                                                     *\n***********************************************************************\nDOCMD4Z  ICM   R1,B'1111',WTOMSGID LOAD WTO MESSAGE ID\n         BZ    DOCMD6              ZERO, NO MESSAGE, GET OUT\n         DOM   MSG=(1)             DELETE OPERATOR MESSAGE\n         XC    WTOMSGID,WTOMSGID   CLEAR THE WTO MESSAGE ID\n         B     DOCMD6              GO GET ANOTHER COMMAND\n         SPACE 3\nWAITMSG2 WTO   'CMD003I ........ WAITING FOR ........ TO START',       X\n               ROUTCDE=(2,11),DESC=2,MF=L\n         EJECT\n***********************************************************************\n*                                                                     *\n*        ISSUE THE COMMAND                                            *\n*                                                                     *\n***********************************************************************\nDOCMD5   SLR   R0,R0               CLEAR REG ZERO\n         MODESET KEY=ZERO          GET INTO KEY ZERO\n         MGCR  COMDATA             ISSUE THE COMMAND\n* HWE    WTO   MF=(E,COMDATA)      ECHO THE COMMAND ON THE CONSOLE\n         MODESET KEY=NZERO         GET OUT OF KEY ZERO\nDOCMD6   BR    R10                 GO GET ANOTHER COMMAND\n         EJECT\n****************************************************************  @BHW\n*                                                              *  @BHW\n*        PROCESS A IFSTARTED COMMAND                           *  @BHW\n*                                                              *  @BHW\n****************************************************************  @BHW\nDOCMD7   CLC   COMDATA+4(10),=CL10'IFSTARTED'  IFSTARTED COMMAND  @BHW\n         BNE   DOCMD8              NO, SEE IF IFSTOPPED COMMAND   @BHW\n         WTO   MF=(E,COMDATA)      ECHO THE COMMAND ON THE CONSOLE@BHW\n****************************************************************  @BHW\n*                                                              *  @BHW\n*        PARSE THE STARTED COMMAND                             *  @BHW\n*                                                              *  @BHW\n****************************************************************  @BHW\n         MVC   REPLYWK(72),COMDATA+4   SAVE STARTED COMMAND       @BHW\n         LA    R1,REPLYWK+10       POINT TO START OF STARTED DATA @BHW\n         LA    R15,72-10           LOAD LENGTH OF STARTED DATA    @BHW\n         SLR   R14,R14             SET LENGTH OF JOBNAME TO ZERO  @BHW\nDOCMD7A  CLC   0(1,R1),C' '        SEE IF START OF JOBNAME        @BHW\n         BNE   DOCMD7B             NO, BRANCH                     @BHW\n         LA    R1,1(,R1)           INCREMENT TO NEXT CHAR OF PARMS@BHW\n         BCT   R15,DOCMD7A         LOOP                           @BHW\n         B     DOCMD7Z             END OF PARM, NO JOBNAME, BYPASS@BHW\nDOCMD7B  LR    R14,R1              SAVE START ADDRESS OF JOBNAME  @BHW\nDOCMD7C  CLC   0(1,R1),C' '        SEE IF END OF JOBNAME          @BHW\n         BE    DOCMD7D             YES, BRANCH                    @BHW\n         LA    R1,1(,R1)           INCREMENT TO NEXT CHAR JOBNAME @BHW\n         BCT   R15,DOCMD7C         LOOP                           @BHW\nDOCMD7D  SR    R1,R14              SUBTRACT START ADDR FROM ENDING@BHW\n         CH    R1,=H'8'            TEST LENGTH OF THE JOBNAME     @BHW\n         BNH   DOCMD7E             NOT GREATER THAN 8, BRANCH     @BHW\n         LA    R1,8                SET LENGTH TO 8                @BHW\nDOCMD7E  MVC   JOBNAME,=CL8' '     BLANK THE JOBNAME              @BHW\n         BCTR  R1,0                MAKE MACHINE LENGTH            @BHW\n         EX    R1,SETNAME          SET THE FULL JOB NAME          @BHW\n***************************************************************** @BHW\n*                                                               * @BHW\n*        SEE IF THE REQUESTED JOB/TASK IS RUNNING               * @BHW\n*                                                               * @BHW\n***************************************************************** @BHW\nDOCMD7F  LA    R1,JOBNAME          POINT TO JOBNAME               @BHW\n         BAL   R14,JOBSRCH         GO SEE IF JOB IS EXECUTING     @BHW\n         LTR   R15,R15             TEST THE RETURN CODE           @BHW\n         BZ    DOCMD7Z             ZER0, EXECUTING, EXIT          @BHW\n***************************************************************** @BHW\n*                                                               * @BHW\n*        SET THE IFACTIVE FLAG TO 1=INVALID (JOB NOT ACTIVE)    * @BHW\n*                                                               * @BHW\n***************************************************************** @BHW\n         MVC   IFACTIVE,=F'1'      SET FLAG TO INVALID            @BHW\nDOCMD7Z  B     DOCMD6              GO GET ANOTHER COMMAND         @BHW\n         EJECT\n****************************************************************  @BHW\n*                                                              *  @BHW\n*        PROCESS A IFSTOPPED COMMAND                           *  @BHW\n*                                                              *  @BHW\n****************************************************************  @BHW\nDOCMD8   CLC   COMDATA+4(10),=CL10'IFSTOPPED'  IFSTARTED COMMAND  @BHW\n         BNE   DOCMD9              NO, SEE IF IFSTOPPED COMMAND   @BHW\n         WTO   MF=(E,COMDATA)      ECHO THE COMMAND ON THE CONSOLE@BHW\n****************************************************************  @BHW\n*                                                              *  @BHW\n*        PARSE THE IFSTOPPED COMMAND                           *  @BHW\n*                                                              *  @BHW\n****************************************************************  @BHW\n         MVC   REPLYWK(72),COMDATA+4   SAVE STARTED COMMAND       @BHW\n         LA    R1,REPLYWK+10       POINT TO START OF STARTED DATA @BHW\n         LA    R15,72-10           LOAD LENGTH OF STARTED DATA    @BHW\n         SLR   R14,R14             SET LENGTH OF JOBNAME TO ZERO  @BHW\nDOCMD8A  CLC   0(1,R1),C' '        SEE IF START OF JOBNAME        @BHW\n         BNE   DOCMD8B             NO, BRANCH                     @BHW\n         LA    R1,1(,R1)           INCREMENT TO NEXT CHAR OF PARMS@BHW\n         BCT   R15,DOCMD8A         LOOP                           @BHW\n         B     DOCMD8Z             END OF PARM, NO JOBNAME, BYPASS@BHW\nDOCMD8B  LR    R14,R1              SAVE START ADDRESS OF JOBNAME  @BHW\nDOCMD8C  CLC   0(1,R1),C' '        SEE IF END OF JOBNAME          @BHW\n         BE    DOCMD8D             YES, BRANCH                    @BHW\n         LA    R1,1(,R1)           INCREMENT TO NEXT CHAR JOBNAME @BHW\n         BCT   R15,DOCMD8C         LOOP                           @BHW\nDOCMD8D  SR    R1,R14              SUBTRACT START ADDR FROM ENDING@BHW\n         CH    R1,=H'8'            TEST LENGTH OF THE JOBNAME     @BHW\n         BNH   DOCMD8E             NOT GREATER THAN 8, BRANCH     @BHW\n         LA    R1,8                SET LENGTH TO 8                @BHW\nDOCMD8E  MVC   JOBNAME,=CL8' '     BLANK THE JOBNAME              @BHW\n         BCTR  R1,0                MAKE MACHINE LENGTH            @BHW\n         EX    R1,SETNAME          SET THE FULL JOB NAME          @BHW\n***************************************************************** @BHW\n*                                                               * @BHW\n*        SEE IF THE REQUESTED JOB/TASK IS RUNNING               * @BHW\n*                                                               * @BHW\n***************************************************************** @BHW\nDOCMD8F  LA    R1,JOBNAME          POINT TO JOBNAME               @BHW\n         BAL   R14,JOBSRCH         GO SEE IF JOB IS EXECUTING     @BHW\n         LTR   R15,R15             TEST THE RETURN CODE           @BHW\n         BNZ   DOCMD8Z             NOT ZERO, NOT EXECUTING, EXIT  @BHW\n***************************************************************** @BHW\n*                                                               * @BHW\n*        SET THE IFACTIVE FLAG TO 1=INVALID (JOB NOT ACTIVE)    * @BHW\n*                                                               * @BHW\n***************************************************************** @BHW\n         MVC   IFACTIVE,=F'1'      SET FLAG TO INVALID            @BHW\nDOCMD8Z  B     DOCMD6              GO GET ANOTHER COMMAND         @BHW\n         EJECT                                                    @BHW\n****************************************************************  @BHW\n*                                                              *  @BHW\n*        PROCESS A ENDIF     COMMAND                           *  @BHW\n*                                                              *  @BHW\n****************************************************************  @BHW\nDOCMD9   CLC   COMDATA+4(5),=CL5'ENDIF' SEE IF ENDIF COMMAND      @BHW\n         BNE   DOCMD10             NO, SEE IF STOPCODECOMMAND     @BHW\n         XC    IFACTIVE,IFACTIVE   CLEAR VALID/INVALID IF FLAG    @BHW\n         BR    R10                 GO GET NEXT RECORD             @BHW\n****************************************************************  @BHW\n*                                                              *  @BHW\n*        PROCESS A STOPCODE  COMMAND                           *  @BHW\n*                                                              *  @BHW\n****************************************************************  @BHW\nDOCMD10  CLC   COMDATA+4(8),=CL8'STOPCODE'  IF ENDIF COMMAND      @BHW\n         BNE   DOCMD5              NO, JUST ISSUE THE COMMAND     @BHW\n         CLI   COMDATA+12,C'='     SPECIAL RC TO BE SET?          @BHW\n         BE    DOCMD10A            YES, GO SET IT                 @BHW\n         B     DOCMD10Y            DONE, NO = SPECIFIED           @BHW\nDOCMD10A SLR   R9,R9               CLEAR R9                       @BHW\n         LA    R11,COMDATA+13      POINT BACK TO START OF RC      @BHW\n         LA    R7,4                                               @BHW\nDOCMD10E CLI   0(R11),C' '         BLANK?                         @BHW\n         BE    DOCMD10G            YES, DONE                      @BHW\n         TM    0(R11),X'F0'        NUMERIC?                       @BHW\n         BO    DOCMD10F            YES, CONTINUE                  @BHW\n         WTO   MF=(E,DOCMD10X)     ISSUE ERROR MESSAGE            @BHW\n         B     DOCMD10Y            DONE, INVALID LENGTH, USE ZERO @BHW\nDOCMD10X WTO   'CMD010I RETURN CODE SPECIFIED NOT NUMERIC',       @BHW X\n               ROUTCDE=(2,11),DESC=2,MF=L                         @BHW\nDOCMD10F SLR   R2,R2              R2=0                            @BHW\n         TRT   0(1,R11),TABLE     GET VALUE                       @BHW\n         MH    R9,=H'10'          R9=R9*10                        @BHW\n         AR    R9,R2              R9=R9+R2                        @BHW\n         LA    R11,1(R11)         R11=R11+1                       @BHW\n         BCT   R7,DOCMD10E        R7=R7-1 >0 -> LOOP FOR NEXT DIG @BHW\nDOCMD10G LR    R15,R9             MOVE RC TO REG15                @BHW\n         B     DOCMD10Z                                           @BHW\nDOCMD10Y SLR   R15,R15             CLEAR R15, INV OR NO INPUT     @BHW\nDOCMD10Z ST    R15,RETCODE         SAVE RETURN CODE FOR EXIT      @BHW\n         B     RETURN              IMMEDIATE END                  @BHW\n         SPACE 1\nPACKTIME PACK  DOUBLE,COMDATA+10(0) *** EXECUTE ONLY ****\nSETNAME  MVC   JOBNAME(0),0(R14)   **** EXECUTE ONLY ****\n         EJECT\n***********************************************************************\n*                                                                     *\n*                          J O B S R C H                              *\n*                                                                     *\n*        SEARCH THE ADDRESS SPACES IN THE SYSTEM TO SEE IF THE        *\n*        JOBNAME OR TASK NAME POINTED TO BY REGISTER 1 UPON           *\n*        ENTRY TO THIS ROUTINE IS EXECUTING.  THE RETURN CODE         *\n*        WILL BE SET AS FOLLOWS:                                      *\n*                                                                     *\n*        R15 = 0  - THE REQUESTED JOB IS EXECUTING                    *\n*        R15 = 4  - THE REQUESTED JOB IS NOT EXECUTING                *\n*                                                                     *\n*        RETURN IS MADE TO THE ADDRESS IN REGISTER 14 UPON ENTRY.     *\n*                                                                     *\n***********************************************************************\nJOBSRCH  STM   R0,R15,SAVESRCH     SAVE REGISTERS\nJOBSRCH1 L     R5,16               LOAD ADDR OF CVT\n         USING CVT,R5              SET ADDRESSABILITY TO CVT\n         L     R5,CVTASVT          POINT TO ADDRESS SPACE VECTOR TABLE.\n         DROP  R5                  DROP ADDRESSABILITY TO CVT\n         USING ASVT,R5             SET ADDRESSABILITY TO ASVT\n         L     R14,ASVTMAXU        LOAD MAX. NUMBER OF ADDRESS SPACES.\n         LA    R5,ASVTENTY         LOAD ADDRESS OF FIRST ASCB POINTER\n         DROP  R5                  DROP ADDRESSABILITY TO ASVT\nJOBSRCH2 ICM   R6,B'1111',0(R5)    POINT TO ASCB\n         BNP   JOBSRCH5            ZERO OR NEGATIVE, BYPASS THIS ONE\n         USING ASCB,R6             SET ADDRESSABILITY TO ASCB\n         ICM   R15,B'1111',ASCBJBNI LOAD ADDRESS OF JOB NAME\n         BZ    JOBSRCH3            ZERO, NOT A BATCH JOB\n         MVC   SRCHNAME,0(R15)     SAVE JOB NAME\n         B     JOBSRCH4            GO SEE IF REQUESTED JOB/TASK NAME\nJOBSRCH3 ICM   R15,B'1111',ASCBJBNS LOAD ADDRESS OF TASK NAME\n         MVC   SRCHNAME,0(R15)     SAVE TASK NAME\nJOBSRCH4 CLC   SRCHNAME,0(R1)      SEE IF REQUESTED JOB/TASK NAME\n         BE    JOBSRCH6            YES, GET OUT\nJOBSRCH5 LA    R5,4(R5)            POINT TO NEXT ASCB POINTER.\n         BCT   R14,JOBSRCH2        LOOP THROUGH ASCBS\n         LA    R15,4               NOT FOUND, SET RETURN CODE TO 4\n         B     JOBSRCH7            GO RETURN TO CALLER\nJOBSRCH6 LA    R15,0               FOUND, SET RETURN CODE TO 0\nJOBSRCH7 LM    R0,R14,SAVESRCH     RESTORE REGISTERS\n         BR    R14                 RETURN TO CALLER\n         DROP  R6                  DROP ADDRESSABILITY TO ASCB\n         EJECT\n***********************************************************************\n*                                                                     *\n*        CONSTANTS AND WORK AREAS.                                    *\n*                                                                     *\n***********************************************************************\n         SPACE 3\nTABLE    DC    256X'00'\n         ORG   TABLE+X'F0'\n         DC    X'00010203040506070809'\n         ORG\n         LTORG\n         SPACE 3\nSAVEAREA DS    18F                 REGISTER SAVE AREA\nSAVESRCH DS    16F                 SAVE AREA FOR JOBSRCH ROUTINE\nSEC15    DC    A(15*100)           15 SECOND BINARY WAIT INTERVAL\nTIOTADDR DS    F                   EXTRACT ANSWER AREA\nGETADDR  DS    F                   ADDRESS OF OUTSTANDING REPLY TABLE\nREPLYWK  DC    CL80' '             REPLY COMMAND WORK AREA\nPARMS    DS    0F                  REPLY PARM PARSE LIST\nJOBN     DS    F                   ADDRESS OF JOB NAME\nJOBNL    DS    F                   LENGTH OF JOB NAME\nMATCH    DS    F                   ADDRESS OF REPLY TEXT TO MATCH\nMATCHL   DS    F                   LENGTH OF REPLY TEXT TO MATCH\nREPLYTX  DS    F                   ADDRESS OF ACTUAL REPLY TEXT\nREPLYTXL DS    F                   LENGTH OF ACTUAL REPLY TEXT\nWTOMSGID DC    F'0'                WTO MESSAGE ID FOR DOM PROCESSING\nRETCODE  DC    F'0'                RETURN CODE HOLD AREA\nDELIM    DC    C' '                TEXT SCAN DELIMETER\nIFACTIVE DC    F'0'            VALID IF FLAG 0=VALID 1=INVALID  @BHW\nMYNAME   DS    CL8                 NAME OF THIS JOB OR TASK\nJOBNAME  DS    CL8                 JOBNAME FOR REPLY SEARCH\nSRCHNAME DS    CL8                 JOB/TASK NAME FROM ASCB\nCOMDATA  DS    0F\n         DC    X'00'\n         DC    AL1(84)\n         DC    X'0000'\n         DC    C'123456789 123456789 123456789 123456789 123456789 1234X\n               56789 123456789 12        '\nDOUBLE   DS    D                   DOUBLE WORK WORK AREA\nWAITIME  DS    F                   DELAY TIME IN 1/100 SECONDS\nFACILITY DC    CL8'FACILITY'       RACROUTE CLASS NAME\nRESOURCE DC    CL44'COMMAND'       RACROUTE RESOURCE NAME\nRACROUTE RACROUTE REQUEST=FASTAUTH,MF=L RACROUTE LIST FORM\nRACWORK  DS    CL512               RACROUTE WORK AREA 1\nFRACWORK DS    16F                 RACROUTE WORK AREA 2\n         PRINT NOGEN\nIEFRDER  DCB   DDNAME=IEFRDER,DSORG=PS,MACRF=GL,EODAD=EOF\n         EJECT\n***********************************************************************\n*                                                                     *\n*                           R E P L Y                                 *\n*                                                                     *\n*        RETURN A LIST OF THE OUTSTANDING REPLIES IN A TABLE          *\n*        POINTED TO BY REGISTER 1 ON ENTRY.  THERE IS ROOM FOR        *\n*        100 OUTSTANDING REPLIES IN THE TABLE.  AN ENTRY WHICH        *\n*        STARTS WITH X'FF' WILL FLAG THE END OF THE REPLIES.          *\n*                                                                     *\n*        BECAUSE SOME OF THE STORAGE AREAS ARE ABOVE THE 16           *\n*        MEG LINE, THE ROUTINE WILL SWITCH TO AMODE31 IN THE          *\n*        BEGINNING AND SWITCH BACK TO AMODE 24 WHEN FINISHED.         *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*        REGISTERS ON ENTRY                                           *\n*           R1  - ADDRESS OF THE REPLY TABLE                          *\n*           R13 - ADDRESS OF A SAVE AREA                              *\n*           R15 - ENTRY POINT ADDRESS                                 *\n*                                                                     *\n*        REGISTERS ON ENTRY                                           *\n*           SAME AS ON ENTRY                                          *\n*                                                                     *\n***********************************************************************\nREPLY    CSECT\n         SAVE  (14,12)             SAVE REGISTERS\n         LR    R12,R15             INITIALIZE FIRST BASE REGISTER\n         USING REPLY,R12           SET PROGRAM ADDRESSABILITY\n         LR    R15,R13             SAVE CALLING'S SAVE AREA ADDR\n         LA    R13,REPSAVE         LOAD ADDR OF NEW SAVE AREA\n         ST    R13,8(R15)          STORE NEW SAVE ADDR IN OLD\n         ST    R15,4(R13)          STORE OLD SAVE ADDR IN NEW\n         LA    R15,*+10            SET BRANCH ADDRESS\n         O     R15,=X'80000000'    SET AMODE31 BIT ON\n         BASSM R14,R15             GO TO AMODE 31\n***********************************************************************\n*                                                                     *\n*        FLAG END OF REPLY TABLE                                      *\n*                                                                     *\n***********************************************************************\n         MVI   0(R1),X'FF'         SET END OF TABLE INDICATOR\n         ST    R1,TBLADDR          SAVE REPLY TABLE ADDRESS\n***********************************************************************\n*                                                                     *\n*        DETERMINE THE ASID NUMBER OF THE CONSOLE ADDRESS SPACE       *\n*                                                                     *\n***********************************************************************\nREPLY01  L     R4,16               R4 = ADDR OF CVT\n         USING CVT,R4              SET ADDRESSABILITY TO CVT\n         L     R5,CVTASVT          POINT TO ADDRESS SPACE VECTOR TABLE.\n         USING ASVT,R5             SET ADDRESSABILITY TO ASVT\n         L     R4,ASVTMAXU         LOAD MAX. NUMBER OF ADDRESS SPACES.\n         LA    R2,1                SET ADDRESS SPACE NUMBER TO ONE\n         LA    R5,ASVTENTY         LOAD ADDRESS OF FIRST ASCB POINTER\nREPLY02  ICM   R6,B'1111',0(R5)    POINT TO ASCB\n         BNP   REPLY03             ZERO OR NEGATIVE, BYPASS THIS ONE\n         USING ASCB,R6             SET ADDRESSABILITY TO ASCB\n         ICM   R15,B'1111',ASCBJBNS LOAD ADDRESS OF JOBNAME FIELD.\n         BZ    REPLY03             ZERO, BYPASS THIS ONE\n         CLC   0(8,R15),=C'CONSOLE ' IS THIS THE CONSOLE ADDRESS SPACE?\n         BE    REPLY04             YES, EXIT FROM LOOP.\nREPLY03  LA    R2,1(R2)            ADD 1 TO THE ASID\n         LA    R5,4(R5)            POINT TO NEXT ASCB POINTER.\n         BCT   R4,REPLY02          LOOP\n         B     REPLY13             ERROR, GET OUT\nREPLY04  ST    R2,CONSASID         SAVE ASID OF CONSOLE ADDRESS SPACE.\n         DROP  R4                  DROP ADDRESSABILITY TO CVT\n         DROP  R5                  DROP ADDRESSABILITY TO ASVT\n         DROP  R6                  DROP ADDRESSABILITY TO ASCB\n         EJECT\n***********************************************************************\n*                                                                     *\n*        SET UP CROSS MEMORY SERVICES                                 *\n*                                                                     *\n***********************************************************************\nREPLY05  L     R10,TBLADDR         GET START OF REPLY TABLE\n         USING MSGDSECT,R10        SET ADDRESSABILITY TO REPLY ENTRY\n         SLR   R7,R7               SET MESSAGE COUNT TO ZERO\n         MODESET MODE=SUP,KEY=ZERO AUTHORIZE OURSELVES\n         ESAR  R9                  GET SECONDARY ASID\n         ST    R9,SASID            AND SAVE IT\n         AXSET AX=ONE              SET AX TO ALLOW SSAR\n         L     R9,CONSASID         GET 'CONSOLE' ASID\n         SSAR  R9                  SET 'CONSOLE' AS SECONDARY ASID\n***********************************************************************\n*                                                                     *\n*        GET THE CMS LOCK SO THAT THE OUTSTANDING REPLY               *\n*        ELEMENT (ORE) CHAIN WILL NOT BE ALTERED DURING               *\n*        OUR PROCESSING.                                              *\n*                                                                     *\n***********************************************************************\nREPLY06  AL    R13,=F'12'          CHANGE R13 FOR SETLOCK\n         SETLOCK OBTAIN,TYPE=LOCAL,MODE=UNCOND,REGS=SAVE\n         SETLOCK OBTAIN,TYPE=CMS,MODE=UNCOND,REGS=SAVE\n         SL    R13,=F'12'          PUT R13 BACK TO NORMAL\n***********************************************************************\n*                                                                     *\n*          GET THE ADDRESS OF THE FIRST OUTSTANDING REPLY             *\n*          ELEMENT (ORE)                                              *\n*                                                                     *\n***********************************************************************\nREPLY07  L     R4,16               R4 = ADDR OF CVT\n         USING CVT,R4              SET ADDRESSABILITY TO CVT\n         L     R4,CVTCUCB          R4 = ADDR OF 'CUCB' (UCM BASE)\n         DROP  R4                  DROP ADDRESSABILITY TO CVT\n         USING UCM,R4              SET ADDRESSABILITY TO UCM BASE\n         L     R2,UCMRPYQ          LOAD ADDRESS OF FIRST ORE\n         LTR   R2,R2               TEST ORE ADDRESS\n         BZ    REPLY12             ZERO, NO OUTSTANDING REPLIES\n         DROP  R4                  DROP ADDRESSABILITY TO UCM BASE\n         USING OREF,R2             SET ADDRESSABILITY TO ORE\n***********************************************************************\n*                                                                     *\n*          COPY THE WTO QUEUE ELEMENT (WQE) FROM THE CONSOLE          *\n*          ADDRESS SPACE FOR THE CURRENT ORE                          *\n*                                                                     *\n***********************************************************************\nREPLY08  L     R8,ORERWQE          R8 = ADDR OF WQE\n         LA    R4,WQECOPY          R4 = ADDR OF COPY OF WQE\n         LA    R5,WQESIZE          R5 = SET LENGTH OF WQE\n         SLR   R15,R15             SET 'FROM' KEY TO ZERO\nREPLY09  MVCP  0(R5,R4),0(R8),R15  MOVE UP TO 256 BYTES\n         BZ    REPLY10             CC=0 - DONE\n         LA    R4,256(,R4)         INCREMENT 'TO' ADDRESS\n         LA    R8,256(,R8)         INCREMENT 'FROM' ADDRESS\n         SH    R5,=H'256'          SUBTRACT LENGTH OF LAST MOVE\n         B     REPLY09             GO GET REST OF AREA\nREPLY10  LA    R4,WQECOPY          RESTORE ADDRESS OF COPY OF WQE\n         USING WQE,R4              SET ADDRESSABILITY TO WQE\n***********************************************************************\n*                                                                     *\n*          SAVE THE REPLY JOBNAME, MSGID, AND ACTUAL MESSAGE          *\n*          FROM THE WQE                                               *\n*                                                                     *\n***********************************************************************\nREPLY11  MVI   MSGENT,C' '         BLANK THE ENTIRE\n         MVC   MSGENT+1(L'MSGENT-1),MSGENT   MESSAGE AREA\n         MVC   JNAME,WQEOJBNM      SAVE JOB NAME\n         MVC   RID,WQERPYID        SAVE REPLY ID\n         MVC   MSG,WQETXT          SAVE MESSAGE TEXT\n         LA    R10,L'MSGENT(,R10)  INCREMENT TO NEXT MESSAGE AREA\n         MVI   0(R10),X'FF'        SET END OF TABLE INDICATOR\n         LA    R7,1(,R7)           ADD 1 TO MESSAGE COUNT\n         CH    R7,=H'100'          SEE IF REACHED MAXIMUM\n         BNL   REPLY12             YES, GET OUT\n         L     R2,ORELKP           LOAD ADDRESS OF NEXT ORE\n         LTR   R2,R2               SEE IF ANY MORE ORE'S\n         BNZ   REPLY08             YES, LOOP\n         DROP  R2                  DROP ADDRESSABILITY TO ORE\n         DROP  R4                  DROP ADDRESSABILITY TO WQE\n         DROP  R10                 DROP ADDRESSABILITY TO REPLY TABLE\n***********************************************************************\n*                                                                     *\n*        FREE THE CMS LOCK SO THAT NORMAL CONSOLE MESSAGE             *\n*        PROCESSING CAN CONTINUE                                      *\n*                                                                     *\n***********************************************************************\nREPLY12  AL    R13,=F'12'          CHANGE R13 FOR SETLOCK\n         SETLOCK RELEASE,TYPE=CMS,REGS=SAVE\n         SETLOCK RELEASE,TYPE=LOCAL,REGS=SAVE\n         SL    R13,=F'12'          PUT R13 BACK TO NORMAL\n***********************************************************************\n*                                                                     *\n*        GET OUT OF CROSS MEMORY MODE                                 *\n*                                                                     *\n***********************************************************************\n         L     R9,SASID            RESTORE PREVIOUS SECONDARY ASID\n         SSAR  R9                  SHOULD BE SAME AS PRIMARY\n         AXSET AX=ZERO             SET AUTHORIZATION INDEX BACK TO ZERO\n         MODESET MODE=PROB,KEY=NZERO UNAUTHORIZE OURSELVES\n***********************************************************************\n*                                                                     *\n*        RETURN TO THE CALLER                                         *\n*                                                                     *\n***********************************************************************\n         SPACE 3\nREPLY13  LA    R15,*+6             SET BRANCH ADDRESS\n         BASSM R14,R15             GO TO AMODE 24\n         L     R13,4(R13)          RESTORE ORIG SAVE AREA ADDRESS\n         RETURN (14,12)            RETURN TO CALLER\n         EJECT\n***********************************************************************\n*                                                                     *\n*                         C O N S T A N T S                           *\n*                                                                     *\n***********************************************************************\n         LTORG\nREPSAVE  DS    18F                 PROGRAM SAVE AREA\nCONSASID DC    F'0'                ASID OF CONSOLE ADDRESS SPACE\nTBLADDR  DS    F                   ADDRESS OF REPLY TABLE\nSASID    DS    F                   SAVE PREVIOUS SECONDARY ASID\nONE      DC    H'1'                TO SET AX 1\nZERO     DC    H'0'                TO SET AX 0\n         DS    0F\nWQECOPY  DS    CL512               LOCAL COPY OF WQE\n         EJECT\nMSGDSECT DSECT\nMSGENT   DS    0CL138\nJNAME    DS    CL8\nRID      DS    CL2\nMSG      DS    CL128\n         EJECT\n         CVT   DSECT=YES\n         EJECT\n         IEECUCM DSECT=YES,FORMAT=NEW,LIST=YES\n         EJECT\n         IHAASVT DSECT=YES\n         EJECT\n         IHAASCB DSECT=YES\n         EJECT\n         IHAORE DSECT=YES\n         EJECT\n         IHAWQE DSECT=YES,FORMAT=OLD\n         EJECT\n         IHAPSA DSECT=YES,LIST=YES\n         EJECT\nTIOT     DSECT\n         IEFTIOT1\n         END\n//SYSLIN   DD  DSN=&&LOADME,DISP=(,PASS),UNIT=SYSDA,\n//             SPACE=(TRK,(30,10),RLSE)\n//SYSPRINT DD  SYSOUT=*\n//LKED     EXEC PGM=HEWL,PARM='AC=1',\n//             COND=(8,LT,ASM)\n//SYSLMOD  DD  DSN=YOUR.LINKLIB,DISP=SHR\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(CYL,(3,2)),DSN=&SYSUT1\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  DSN=&&LOADME,DISP=(OLD,DELETE)\n//         DD *\n ENTRY COMMAND\n NAME COMMAND(R)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$MPFCMDS": {"ttr": 1031, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\"\\x01\\x02)\\x0f\\x01\\x02)\\x0f\\x12\\x19\\x00\\x89\\x00\\x16\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2002-10-17T00:00:00", "modifydate": "2002-10-17T12:19:22", "lines": 137, "newlines": 22, "modlines": 0, "user": "IBMUSER"}, "text": "//MPFCMDS   JOB NOTIFY=&SYSUID.\n//*------------------------------------------------------------------*\n//* BEFORE SUBMITTING\n//* CHANGE \"YOUR.LINKLIB\" ---> YOUR LINKLIB\n//*------------------------------------------------------------------*\n//ASM      EXEC PGM=ASMA90,\n//             PARM='OBJECT,NOTEST,RENT,NOALIGN'\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR\n//         DD  DSN=SYS1.MODGEN,DISP=SHR\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(CYL,(10,5))\n//SYSIN    DD  *\nMPFCMDS  TITLE 'MPF EXIT TO ISSUE START COMMAND BASED ON MESSAGE ID.'\n*\nMPFCMDS  CSECT\nMPFCMDS  AMODE 31\nMPFCMDS  RMODE 24\n         BAKR   R14,0               INITIALISATION\n         LR    R12,R15\n         USING MPFCMDS,R12\n         L     R10,0(R1)           POINT TO CTXT PARAMETER BLOCK\n         USING CTXT,R10            ESTABLISH ADDRESSABILITY\n         L     R9,CTXTTXPJ         POINT TO MESSAGE ATTRIBUTES\n         USING CTXTATTR,R9         ESTABLISH ADDRESSABILITY\n         LA    R0,WORKSIZE\n*\n*  INITIALISE WORKAREA\n*\n         GETMAIN RU,LV=(R0),LOC=BELOW     GET SOME WORKING STORAGE\n         LR    R2,R1               POINT TO REENTRANT WORK AREA\n         LA    R3,PSETSIZE         STORE LENGTH OF PRESET CONSTANTS\n         LR    R5,R3               COPY TO R4 FOR MVCL\n         LA    R4,PSETAREA         POINT TO PRESET DATA AREA\n         MVCL  R2,R4               PRIME WORK AREA WITH PRESET DATA\n         LR    R5,R1               SAVE ADDRESS OF GETMAINED STORAGE\n         USING WORKAREA,R5         ESTABLISH ADDRESSABILITY\n         EJECT\n*\n*  DETERMINE CASE TO PROCESS\n*\nMPFXT100 EQU   *\n         LA    R2,CTXTTMSG         CALCULATE LENGTH OF MSGID\n         LA    R3,CTXTTMSG+8\nMPFXT105 CLI   0(R2),C' '          MESSAGE ID IS DELIMITED BY BLANK\n         BE    MPFXT110\n         CR    R2,R3\n         BE    MPFXT110            REACHED THE MAX LENGTH\n         LA    R2,1(,R2)\n         B     MPFXT105\nMPFXT110 LA    R3,CTXTTMSG         @ START OF MSGID\n         SR    R2,R3               R2=L'(MSGID)-1\n         BCTR  R2,0                DECREMENT FOR EXECUTED MOVE\n         EX    R2,MVMBR            MOVE MEMBER NAME TO DYNALLOC TU\n*\n*  COMMAND ISSUE ROUTINE\n*\n         XR    R0,R0               CLEAR FOR MGCR/SVC 34\n         MGCR  CMDHDR              POINT TO COMMAND\n*\n*     END OF COMMANDS - TIDY UP AND GO HOME\n*\nQUIT     CNOP  0,4\n         LA    R2,WORKAREA\n         LA    R1,WORKSIZE\n         FREEMAIN R,LV=(R1),A=(R2)\n         EJECT\n*\n*     END OF PROCESSING.\n*\n         PR\nMVMBR    MVC  CMDSMBR(0),CTXTTMSG  MOVE MESSAGE ID TO MEMBER NAME\n         EJECT\n*\n*        CONSTANT DATA.\n*\n         SPACE 2\n         LTORG\n         EJECT\n*\n*     VARIABLE DATA. NOTE THAT THIS DATA IS COPIED TO A WORK AREA\n*     AND UPDATED THERE.\n*\n         SPACE 2\nPSETAREA DS    0D                  PRESET MGCR WORK AREA\nSSCMD    DC    AL2(SCMDLN)\n         DC    XL2'00'\n         DC    CL17'S MPFCMDS,MEMBER='\n*                   12345678901234567\n         DC    CL8'        '\n         DC    C'  /* ISSUED BY MPFCMDS */ '\nSCMDLN   EQU   *-SSCMD\nPSETSIZE EQU   *-PSETAREA          SIZE OF THE VARIABLE WORK AREA\n         EJECT\n*\n*     MAP PARAMETER LIST TO MPFCMDS.\n*\n         EJECT\nWORKAREA DSECT                     PRESET WORK AREA\n         DS    0D                  PRESET WORK AREA\nCMDHDR   DC    XL2'20'\n         DC    XL2'00'\nCMDTEXT  DC    CL17' '\nCMDSMBR  DC    CL8'        '                  COMMAND FILE MEMBER\n         DC    C'  /* ISSUED BY MPFCMDS */ '\nWORKSIZE EQU   *-WORKAREA          SIZE OF THE VARIABLE WORK AREA\n         IEZVX100\n*\n*     REGISTER EQUATES\n*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n//SYSLIN   DD  DSN=&&LOADME,DISP=(,PASS),UNIT=SYSDA,\n//             SPACE=(TRK,(30,10),RLSE)\n//SYSPRINT DD  SYSOUT=*\n//LKED     EXEC PGM=HEWL,PARM='RENT,REUS,XREF',\n//             COND=(8,LT,ASM)\n//SYSLMOD  DD  DSN=YOUR.LINKLIB,DISP=SHR\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(CYL,(3,2)),DSN=&SYSUT1\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  DSN=&&LOADME,DISP=(OLD,DELETE)\n//         DD *\n ENTRY MPFCMDS\n NAME MPFCMDS(R)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$MPFPROC": {"ttr": 1034, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x16\\x01\\x02)\\x0f\\x01\\x02)\\x0f\\x12\\x14\\x00\\n\\x00\\x03\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2002-10-17T00:00:00", "modifydate": "2002-10-17T12:14:16", "lines": 10, "newlines": 3, "modlines": 0, "user": "IBMUSER"}, "text": "//MPFCMDS  PROC MEMBER=DUMMY\n//*------------------------------------------------------------------*\n//* PROC TO BE PLACED IN AN PROCLIB LIBRARY\n//* CHANGE \"YOUR.CMDS.PDS\" ---> YOUR CMDS LIBRARY\n//* ALLOCATE THIS PDS FIXED LRECL 80\n//* THE PURPOSE OF THIS PDS IS TO CONTAIN THE MEMBERS WITH THE\n//* COMMANDS TO HANDLE MESSAGES\n//*------------------------------------------------------------------*\n//MPFCMDS  EXEC PGM=COMMAND\n//IEFRDER  DD DSN=YOUR.CMDS.PDS(&MEMBER.),DISP=SHR\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE597": {"ttr": 1036, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04b\\x00&\\x01\\x19)?\\x01\\x19)?\\x16V\\x00\\x14\\x00\\x14\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf8@@@'", "ispf": {"version": "04.98", "flags": 0, "createdate": "2019-10-20T00:00:00", "modifydate": "2019-10-20T16:56:26", "lines": 20, "newlines": 20, "modlines": 0, "user": "CBT-498"}, "text": "//***FILE 597 is from Hans Westheim and contains an MPF program     *   FILE 597\n//*           to reply to messages.  Hans had been using the        *   FILE 597\n//*           general MPF exit on File 345, and when he went to     *   FILE 597\n//*           OS/390 2.10, he had a problem of A37-008 abends,      *   FILE 597\n//*           which he overcame with this new solution.             *   FILE 597\n//*                                                                 *   FILE 597\n//*           This is an MPF exit which issues a START command,     *   FILE 597\n//*           based on the message id.                              *   FILE 597\n//*                                                                 *   FILE 597\n//*           email:  Hans.Westheim@essent.nl                       *   FILE 597\n//*                                                                 *   FILE 597\n//*           Hans Westheim, Netherlands                            *   FILE 597\n//*           Essent/ICT/Services/S390-engineer                     *   FILE 597\n//*           +31 (0)73-8557928 (phone)                             *   FILE 597\n//*           +31 (0)6-29503136 (mobile)                            *   FILE 597\n//*                                                                 *   FILE 597\n//*           The new MPF exit was written by:                      *   FILE 597\n//*                                                                 *   FILE 597\n//*           Paul Naidoo <paulcn@xs4all.nl>                        *   FILE 597\n//*                                                                 *   FILE 597\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IEE043I": {"ttr": 1038, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00!\\x00\\x95\\x19\\x8f\\x01\\x02'\\x7f\\x15#\\x00\\x02\\x00\\x02\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "1995-07-17T00:00:00", "modifydate": "2002-10-04T15:23:21", "lines": 2, "newlines": 2, "modlines": 0, "user": "IBMUSER"}, "text": "* Issued after a syslog has been written in response to a \"W L\"\nS LOGWTR.LOGWTR,,,L\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IEF176I": {"ttr": 1040, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00C\\x00\\x95\\x19\\x8f\\x01\\x02'\\x7f\\x15#\\x00\\x02\\x00\\x02\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "1995-07-17T00:00:00", "modifydate": "2002-10-04T15:23:43", "lines": 2, "newlines": 2, "modlines": 0, "user": "IBMUSER"}, "text": "* Issued when LOGWTR has finished copying a SYSLOG to BACKUP.SYSLOG\nP LOGWTR\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IFB080E": {"ttr": 1042, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00U\\x01\\x02%\\x9f\\x01\\x02%\\x9f\\x13V\\x00\\x02\\x00\\x02\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-09-16T00:00:00", "modifydate": "2002-09-16T13:56:55", "lines": 2, "newlines": 2, "modlines": 0, "user": "IBMUSER"}, "text": "* logrec near full\ns erep\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT597/FILE597.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT597", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}