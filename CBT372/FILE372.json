{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011851000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 117572, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 6, "INMDSNAM": "CBT.V500.FILE372.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 117572, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 117572, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE372.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x03\\x07'", "DS1TRBAL": "b'\\x85\\xe0'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x02\\xb1\\x00\\x07\\x02\\xb1\\x00\\n\\x00\\x04'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"@FILE372": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x99\\x08?\\x00\\x990O\\x11\"\\x00\\x11\\x00\\x02\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1999-03-24T00:00:00", "modifydate": "1999-10-31T11:22:00", "lines": 17, "newlines": 2, "modlines": 0, "user": "SBGOLOB"}, "text": "//***FILE 372 is from Ken MacKenzie of NatWest bank in England,     *   FILE 372\n//*           and contains a dynamic allocation program that is     *   FILE 372\n//*           faster than the ALLOC program which comes with        *   FILE 372\n//*           TSO.  It's also a bit different, so you should        *   FILE 372\n//*           look to see if it's good for your purposes.           *   FILE 372\n//*                                                                 *   FILE 372\n//*           1.  DYNALLOC - The main (only) routine.               *   FILE 372\n//*           2.  ASMTSTMP - A macro which is used to               *   FILE 372\n//*                          insert a date/time stamp               *   FILE 372\n//*                          into the load module.                  *   FILE 372\n//*                                                                 *   FILE 372\n//*           Contact information:                                  *   FILE 372\n//*           Home Email: ken.mackenzie@tesco.net                   *   FILE 372\n//*                     : ken.mackenzie@talk21.com                  *   FILE 372\n//*           Work Email: ken.mackenzie@natwest.com                 *   FILE 372\n//*           Work Phone: +44 (0) 20 7709 6365    (UK)              *   FILE 372\n//*                                                                 *   FILE 372\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ASMTSTMP": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99#\\x9f\\x00\\x99#\\x9f\\x13&\\x00\\x13\\x00\\x13\\x00\\x00\\xe8\\xf0\\xf0\\xf1\\xd2\\xd4\\xf6@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-08-27T00:00:00", "modifydate": "1999-08-27T13:26:00", "lines": 19, "newlines": 19, "modlines": 0, "user": "Y001KM6"}, "text": "         MACRO\n.*   **************************************************\n.*   *  ASMTSTMP MACRO - Ken & Andy - August 1999     *\n.*   *                                                *\n.*   *  Creates a Timestamp in an assembler program   *\n.*   *                                                *\n.*   **************************************************\n         ASMTSTMP\n         DC    C'ASMTSTMP:'            Eyecatcher\n         DC    C'&SYSIN_DSN'           Dataset name\n         DC    C'('\n         DC    CL8'&SYSIN_MEMBER'      Program id\n         DC    C')'\n         DC    C'-'\n         DC    C'&SYSDATE'             Compile Date\n         DC    C'-'\n         DC    C'&SYSTIME'             Compile Time\n         EJECT\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DYNALLOC": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99#\\x9f\\x00\\x99#\\x9f\\x13#\\x02\\xd1\\x02\\xd1\\x00\\x00\\xe8\\xf0\\xf0\\xf1\\xd2\\xd4\\xf6@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-08-27T00:00:00", "modifydate": "1999-08-27T13:23:00", "lines": 721, "newlines": 721, "modlines": 0, "user": "Y001KM6"}, "text": "DYNALLOC TITLE 'Do dynamic allocation - faster than TSO'\n*   +---------------------------------------------+\n*   |  DYNALLOC - Ken MacKenzie - August 1999     |\n*   +---------------------------------------------+\n*   |  Limited support can be obtained by         |\n*   |  contacting the author at:                  |\n*   |    ken.mackenzie@tesco.net                  |\n*   |         - or -                              |\n*   |    ken.mackenzie@talk21.com                 |\n*   +---------------------------------------------+\n*   |  This routine, which is designed to be      |\n*   |  called as a REXX function, allocates a     |\n*   |  list of datasets to a ddname.  All         |\n*   |  datasets are fully-qualified, assumed to   |\n*   |  exist already and are allocated as         |\n*   |  \"DISP=SHR\".                                |\n*   +---------------------------------------------+\n*   |                                             |\n*   | +-----------------------------------------+ |\n*   | |  IT IS *NOT* A RE-WRITE OF THE TSO      | |\n*   | |  ALLOC COMMAND.                         | |\n*   | +-----------------------------------------+ |\n*   |                                             |\n*   +---------------------------------------------+\n*   |  Sample call:                               |\n*   |    ddname = 'MYDD'                          |\n*   |    dslist = 'A.FILE B.FILE C.FILE D.FILE'   |\n*   |    x = 'DYNALLOC'(dsname, dslist)           |\n*   +---------------------------------------------+\n*   |  Return information:                        |\n*   |    This function returns the return-code    |\n*   |    from the SVC99 call                      |\n*   |         - or -                              |\n*   |    -1 if no ddname is supplied              |\n*   |    -2 if no dataset list is supplied        |\n*   |    -3 if there are more than 2 parameters   |\n*   +---------------------------------------------+\n*   |  Additional variables set:                  |\n*   |    S99INFO & S99REASON are set to the       |\n*   |    appropriate values as described in the   |\n*   |    \"Authorized Assembler Services Guide\"    |\n*   |    manual.                                  |\n*   |                                             |\n*   |    S99MSG1 & S99MSG2 are set to the first   |\n*   |    and second level messages in the event   |\n*   |    of a non-zero return code from SVC99     |\n*   +---------------------------------------------+\n         SPACE 1\nDYNALLOC CSECT\nDYNALLOC AMODE 31\nDYNALLOC RMODE ANY\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         USING *,R12\n         SPACE 3\n         SAVE  (14,12),,*\n         LR    R12,R15\n         LR    15,13                    * CHAIN\n         LA    13,SAVEAREA              * THE\n         ST    13,8(15)                 * SAVE\n         ST    15,4(13)                 * AREAS.\n         B     A000                     * BRANCH AROUND\n*\n         ASMTSTMP\n*\nSAVEAREA DC    18A(0)                   * SAVE AREA.\n*\n         EJECT\nA000     DS    0H\n         MVI   DYNFLAG,C'N'            Show that we've done nothing\n         USING EFPL,R1                 Address EFPL\n         L     R11,EFPLEVAL            Get address of...\n         L     R11,0(,R11)             ...and address REXX's EVALBLOCK\n         ST    R11,$EVALBLOCK          (Save it)\n         USING EVALBLOCK,R11           Register 11 is EVALBLOCK base\n         MVC   EVALBLOCK_EVLEN,=X'80000000'\n         LR    R10,R0                  Get address of environment block\n         USING ENVBLOCK,R10            Register 10 is ENVBLOCK base\n         L     R9,ENVBLOCK_WORKBLOK_EXT Get address of workblock\n*                                                          extension\n         L     R9,ENVBLOCK_IRXEXTE     Get address of vector block\n         USING IRXEXTE,R9              Register 9 is IRXEXTE base\n         MVC   $IRXEXCOM,IRXEXCOM      Get variable routine address\n         L     R8,EFPLARG              Address REXX's Parsed Argument\n*                                                     List\n         USING ARGTABLE_ENTRY,R8\n         ST    R8,$EFPLARG             (Save Arglist Address)\n         CLC   ARGTABLE_ARGSTRING_PTR,ARGTABLE_END Any DDNAME parm?\n         BNE   A001                    Yes ... good --->\n         XR    R15,R15\n         BCTR  R15,0                   No ... exit with...\n         B     A999                    ...return code -1\nA001     EQU   *\n         L     R7,ARGTABLE_ARGSTRING_PTR\n         ST    R7,$DDPARM              Save Address of DDname\n         L     R7,ARGTABLE_ARGSTRING_LENGTH\n         ST    R7,#DDLEN               Save Length of DDname\n         LA    R8,ARGTABLE_NEXT        Address next argument\n         CLC   ARGTABLE_ARGSTRING_PTR,ARGTABLE_END Any DSNAME parameter\n         BNE   A002                    Yes ... good --->\n         XR    R15,R15\n         BCTR  R15,0                   No ... exit with...\n         BCTR  R15,0                   ...wait for it...\n         B     A999                    ...return code -2\nA002     EQU   *\n         L     R7,ARGTABLE_ARGSTRING_PTR\n         ST    R7,$DSNPARM             Store DSNs Address\n         L     R7,ARGTABLE_ARGSTRING_LENGTH\n         ST    R7,#DSNLEN              Store DSNs Length\n         LA    R8,ARGTABLE_NEXT        Address next argument\n         CLC   ARGTABLE_ARGSTRING_PTR,ARGTABLE_END Any more parameters?\n         BE    A003                    No ... good --->\n         XR    R15,R15\n         BCTR  R15,0                   No ... exit with...\n         BCTR  R15,0                   ...wait for it...\n         BCTR  R15,0                   ...wait for it...\n         B     A999                    ...return code -3\nA003     EQU   *\n         BAS   R14,GETDSNS             Were there any dsns?\n         ICM   R15,B'1111',#DSNS\n         BNZ   A004                    Yes ... carry on\n         BCTR  R15,0                        exit...\n         BCTR  R15,0                               with...\n         B     A999                    ...return code -2\nA004     EQU   *\n         L     R6,#DSNS                Get number of DSNs\n         MH    R6,=H'6'                Mult no. of dsn * 6\n         A     R6,#DSNLEN              Add on the dsn lengths\n         LA    R6,4(,R6)               Add on a bit for END marker\n         ST    R6,@DSNLIST             Store length of DSN list\n         STORAGE OBTAIN,LENGTH=(R6),LOC=ANY\n         ST    R1,$DSNLIST             Store Address of DSN list\n         L     R6,#DSNS                Get number of DSNs\n         MH    R6,=H'14'               Mult no. of dsn * 14\n         AH    R6,=H'6'                Add on a bit\n         A     R6,#DDLEN               Add on the DD length\n         ST    R6,@DDLIST              Store length of DD list\n         STORAGE OBTAIN,LENGTH=(R6),LOC=ANY\n         ST    R1,$DDLIST              Store address of DD list\n         L     R8,$EFPLARG             Re-address REXX parameters\n         L     R2,$DDLIST              Re-address DD list\n         USING TU_DDLIST,R2\n         MVC   TU_DD_T,=AL2(DALDDNAM)  Set type to \"DD\"\n         MVC   TU_DDLIST_T,=AL2(DALDDNAM) (Set to type to \"DD\")\n         L     R6,#DSNS                Get no. of DSNs\n         STH   R6,TU_DDLIST_#          Store in no. of DDs\n         L     R7,ARGTABLE_ARGSTRING_PTR * Address DD name\n         L     R6,ARGTABLE_ARGSTRING_LENGTH * Get DD length\n         STH   R6,TU_DD_L              Save DD length in Text Unit\n         BCTR  R6,0                    Less 1 for \"EX\"\n         EX    R6,MOVEDD               Move DD name\n         B     A005                    Go for the DSNs\nMOVEDD   MVC   TU_DD_$(0),0(R7)        Move DDNAME (\"EX\"ed instr.)\nA005     EQU   *\n         L     R3,$DSNLIST             Re-address (SVC99) DSN list\n         L     R8,$DSNADDR             Re-address DSN List\nA006     EQU   *\n         CLC   ARGTABLE_ARGSTRING_PTR,ARGTABLE_END End of arguments?\n         BE    A007                    No more entries --->\n         USING TU_DSN,R3\n         MVC   TU_DSN_T,=AL2(DALDSNAM) Set TU type to DSNAME\n         MVC   TU_DSN_#,=H'1'          Set number to 1\n         L     R7,ARGTABLE_ARGSTRING_PTR * Get DSN address\n         L     R6,ARGTABLE_ARGSTRING_LENGTH * Get DSN length\n         STH   R6,TU_DSN_L             Store length in Text Unit\n         BCTR  R6,0                    -1 for \"EX\"\n         EX    R6,MOVEDSN              Move the DSN\n         LA    R3,7(R6,R3)             Address next (SVC99) DSN\n         LA    R8,ARGTABLE_NEXT        Address next DSN\n         B     A006                    Go back round\nMOVEDSN  MVC   TU_DSN_$(0),0(R7)       Move DSNAME (\"EX\"ed instr.)\nA007     EQU   *\n         MVC   TU_DSN_T(4),=X'FFFF'    Indicate end of list\n         L     R3,$DSNLIST             * Address DSN list\n         BAS   R14,DDFREE              Go free the DD\nA008     EQU   *\n*   *************************************************\n*   *  We're going to allocate the DSNs one by one  *\n*   *  The first one is allocated to the supplied   *\n*   *  DD name and the subsequent ones are          *\n*   *  allocated to a system-supplied DD name       *\n*   *************************************************\n         CLC   TU_DSN_T(4),=X'FFFF'    * End of table?\n         BE    A009                    * Yes ... get out\n         BAS   R14,DSNALLOC            * Allocate requested DD\n         LTR   R15,R15                 * Did it work OK?\n         BNZ   A999                    * No ... better go\n         LH    R4,TU_DD_L              Get DD length\n         STH   R4,TU_DDLIST_L          Save in DD list\n         BCTR  R4,0                    -1 for EX\n         EX    R4,MOVEDD1              Move this DD to list\n         LA    R2,3(R4,R2)             Address next DD list entry\n         LH    R4,TU_DSN_L             Get DSN length\n         BCTR  R4,0\n         LA    R3,7(R4,R3)             Address next DSN\n         MVC   TU_DD_T,=AL2(DALRTDDN)  Set DD Text unit\n         MVC   TU_DD_L,=H'8'           To request a DD name\n         B     A008                    Loop round\nMOVEDD1  MVC   TU_DDLIST_$(0),TU_DD_$  Move DD name (\"EX\"ed instr.)\nA009     DS    0H\n         L     R2,$DDLIST              Re-address DD list\n         CLC   TU_DDLIST_#,=H'1'       Is there only one DSN?\n         BE    A999                    Yes ... let's leave\n         BAS   R14,CONCAT              Else ... concatenate them\nA999     EQU   *\n         L     R11,$EVALBLOCK          Re-address REXX eval block\n         MVC   RCSIGN,=H'0'            Assume \"positive\"\n         CVD   R15,PACKDUBL            * Get return code\n         UNPK  ZONEDEC,PACKDUBL        * Into zoned decimal\n         LA    R8,ZONEDEC-1            * Address intermediate field\n         LA    R3,RC                   * Address return code\n         LA    R4,16                   * Set up maximum output length\nA999A1   EQU   *\n         LTR   R4,R4                   * Are we on the last character?\n         BZ    A999A2                  * We'd better move a single char\n         BCTR  R4,0                    * Prepare for potential 'EX'\n         LA    R8,1(,R8)               * Point to current character\n         TM    0(R8),X'0F'             * Is it a zero?\n         BZ    A999A1                  * Yes ... get the next one\nA999A2   EQU   *\n         TM    ZONEDEC+L'ZONEDEC-1,X'30' * Is it negative?\n         BNM   A999A3                  * No ... ignore sign\n         MVC   RCSIGN,=H'1'\n         MVI   0(R3),C'-'              * Move the sign in\n         LA    R3,1(,R3)               * Point to next output char.\nA999A3   EQU   *\n         OI    ZONEDEC+L'ZONEDEC-1,X'F0' Switch the sign off\n         EX    R4,EXEC5                * Move the answer out\n         EX    R4,EXEC6                * Move the answer out\n         LA    R4,1(,R4)               * Re-adjust to \"real\" length\n         AH    R4,RCSIGN               * Add on sign adjustment\n         ST    R4,EVALBLOCK_EVLEN\n         LA    R9,RC_SHVBLOCK          * Address RC variable block\n         USING SHVBLOCK,R9             * R9 is SHVBLOCK base\n         XR    R2,R2\n         CLI   DYNFLAG,C'Y'            * Has DYNALLOC been done?\n         BNE   A999A                   * No ... this is last block\n         LA    R2,S99ERROR_SHVBLOCK    * Yes ... get next SHVBLOCK addr\nA999A    EQU   *\n         ST    R2,SHVNEXT              * Chain to next SHVBLOCK\n         LA    R2,=C'RC'               * Address RC variable name\n         ST    R2,SHVNAMA              * Store address in SHVBLOCK\n         LA    R2,2                    * Length of RC variable name\n         ST    R2,SHVNAML              * Store length in SHVBLOCK\n         ST    R4,SHVVALL              * Store length of RC value\n         LA    R2,RC                   * Address RC variable value\n         ST    R2,SHVVALA              * Store address in SHVBLOCK\n         MVI   SHVCODE,SHVSTORE\n         LA    R4,S99_AREA             * Re-address SVC99 Request block\n         USING S99RBP,R4\n         LA    R5,S99RBPTR+4           * Point four bytes beyond start\n         USING S99RB,R5                * Est addressability to RB DSECT\n*\n*   *  If the dynamic allocation was performed, then there\n*   *  are potentially 2 codes available.  These are S99ERROR\n*   *  and S99INFO.  They are both held in binary coded decimal\n*   *  (unsigned packed decimal) format          |         |\n*                                                |         |\n         UNPK  SVC99_ERROR(5),S99ERROR(3)        |         |\n         NC    SVC99_ERROR(4),=4X'0F'            |         |\n         TR    SVC99_ERROR,=C'0123456789ABCDEF'  |         |\n         UNPK  SVC99_INFO(5),S99INFO(3)          |         |\n         NC    SVC99_INFO(4),=4X'0F'             |         |\n         TR    SVC99_INFO,=C'0123456789ABCDEF'   V         V\n*\n         LA    R9,S99ERROR_SHVBLOCK    * Address S99ERROR SHVBLOCK\n         LA    R2,S99INFO_SHVBLOCK     * Chain forward to...\n         ST    R2,SHVNEXT              * ...S99INFO SHVBLOCK\n         LA    R2,=C'S99ERROR'         Set S99ERROR variable name\n         ST    R2,SHVNAMA              Store in Name address\n         LA    R2,8                    Set name length\n         ST    R2,SHVNAML              Store in name length\n         LA    R2,4                    Set value length\n         ST    R2,SHVVALL              Save in value length\n         LA    R2,SVC99_ERROR          Address Value\n         ST    R2,SHVVALA              Store value\n         MVI   SHVCODE,SHVSTORE        Indicate \"Store\"\n*\n         LA    R9,S99INFO_SHVBLOCK     Address S99INFO SHVBLOCK\n         LA    R2,S99MSG1_SHVBLOCK     Indicate...\n         ST    R2,SHVNEXT              ...no more SHVBLOCKs\n         LA    R2,=C'S99INFO'          Set S99ERROR variable name\n         ST    R2,SHVNAMA              Store in Name address\n         LA    R2,7                    Set name length\n         ST    R2,SHVNAML              Store in name length\n         LA    R2,4                    Set value length\n         ST    R2,SHVVALL              Save in value length\n         LA    R2,SVC99_INFO           Address Value\n         ST    R2,SHVVALA              Store value\n         MVI   SHVCODE,SHVSTORE        Indicate \"Store\"\n*\n         LA    R9,S99MSG1_SHVBLOCK     Address S99INFO SHVBLOCK\n         LA    R2,S99MSG2_SHVBLOCK     Indicate...\n         ST    R2,SHVNEXT              ...no more SHVBLOCKs\n         LA    R2,=C'S99MSG1'          Set S99ERROR variable name\n         ST    R2,SHVNAMA              Store in Name address\n         LA    R2,7                    Set name length\n         ST    R2,SHVNAML              Store in name length\n         LH    R2,DFBUFL1              Set value length\n         S     R2,=F'4'\n         ST    R2,SHVVALL              Save in value length\n         LA    R2,DFBUFL1+4            Address Value\n         ST    R2,SHVVALA              Store value\n         MVI   SHVCODE,SHVSTORE        Indicate \"Store\"\n*\n         LA    R9,S99MSG2_SHVBLOCK     Address S99INFO SHVBLOCK\n         XR    R2,R2                   Indicate...\n         ST    R2,SHVNEXT              ...no more SHVBLOCKs\n         LA    R2,=C'S99MSG2'          Set S99ERROR variable name\n         ST    R2,SHVNAMA              Store in Name address\n         LA    R2,7                    Set name length\n         ST    R2,SHVNAML              Store in name length\n         LH    R2,DFBUFL2              Set value length\n         S     R2,=F'4'\n         ST    R2,SHVVALL              Save in value length\n         LA    R2,DFBUFL2+4            Address Value\n         ST    R2,SHVVALA              Store value\n         MVI   SHVCODE,SHVSTORE        Indicate \"Store\"\n*\nA999B    EQU   *\n         L     R15,$IRXEXCOM           Call REXX variable routine\n         CALL  (15),(@IRXEXCOM,0,0,RC_SHVBLOCK),VL\nA999Z    EQU   *\n         ICM   R2,B'1111',$DDLIST      Is there a DD list\n         BZ    A999Z1                  No ... ignore\n         L     R3,@DDLIST              Else ... free it\n         STORAGE RELEASE,LENGTH=(R3),ADDR=(R2)\nA999Z1   EQU   *\n         ICM   R2,B'1111',$DSNLIST     Is there a DSN list\n         BZ    A999Z2                  No ... ignore\n         L     R3,@DSNLIST             Else ... free it\n         STORAGE RELEASE,LENGTH=(R3),ADDR=(R2)\nA999Z2   EQU   *\n         ICM   R2,B'1111',$DSNADDR     Is there a DSN address list\n         BZ    A999Z3                  No ... ignore\n         L     R3,@DSNADDR             Else ... free it\n         STORAGE RELEASE,LENGTH=(R3),ADDR=(R2)\nA999Z3   EQU   *\n         L     R13,4(,R13)             * Re-address HSA\n         RETURN (14,12),T,RC=0         * All done\n*\nGETDSNS  DS    0H\n*   ****************************************************\n*   *  This routine separates the DSNs parameter into  *\n*   *  separate DSN parameters.  The result is a       *\n*   *  list of address/length pairs (like REXX uses)   *\n*   *  terminated by HIGH-VALUES                       *\n*   ****************************************************\n         ST    R14,GETSAVE             Save return address\n         L     R7,$DSNPARM             Address the DSN parm\n         L     R6,#DSNLEN              Get the DSN length\n         LA    R6,0(R7,R6)             Address end of parameter\n         BCTR  R6,0\nGET003   EQU   *\n         CLI   0(R7),C' '              Is the first character a space\n         BNE   GET005                  No ... carry on\n         LA    R7,1(,R7)               Else ... increment address\n         B     GET003                  And go round again\nGET005   EQU   *\n         ST    R7,$DSNPARM             Set \"new\" address of DSN\n         CLI   0(R6),C' '              Is last character a space?\n         BNE   GET007                  No ... carry on\n         BCTR  R6,0                    Else ... decrement address\n         B     GET005                  And go round again\nGET007   EQU   *\n         LA    R6,1(,R6)               Set \"new\" end address\n         XR    R3,R3\nGET010   DS    0H\n         TRT   0(44,R7),TABLE_SPACE    Find next space\n         BZ    GET020                  Branch if there wasn't one\n         CR    R1,R6                   \"Belt and Braces\" ...\n         BNL   GET020                  ... not found\n         LR    R7,R1                   Address the Space\n         TRT   0(44,R7),TABLE_CHAR     Find next valid DSN char\n         BZ    GET020                  Branch if there isn't one\n         CR    R1,R6                   \"Belt and Braces\" ...\n         BNL   GET020                  ... not found\n         LR    R7,R1                   Address start of DSN\n         LA    R3,1(,R3)               Increment count of DSNs\n         B     GET010                  Go for more\nGET020   DS    0H\n         LA    R3,1(,R3)               Increment count of DSNs\n         ST    R3,#DSNS                Stash it away\n         LA    R3,1(,R3)               Increment for STORAGE request\n         MH    R3,=H'8'                Mult. by 8\n         ST    R3,@DSNADDR             Save required length\n         STORAGE OBTAIN,LENGTH=(R3),LOC=ANY\n         ST    R1,$DSNADDR             Save \"gotten\" address\n         LR    R8,R1\n         L     R7,$DSNPARM             Re-address DSN parm\nGET030   EQU   *\n         ST    R7,ARGTABLE_ARGSTRING_PTR * Save address in list\n         TRT   0(44,R7),TABLE_SPACE    Find next space\n         BZ    GET040                  Branch if there isn't one\n         CR    R1,R6                   \"Belt and Braces\" ...\n         BNL   GET040                  ... not found\n         SR    R1,R7                   Calculate the length\n         ST    R1,ARGTABLE_ARGSTRING_LENGTH * Stash it away\n         LA    R7,0(R1,R7)             Address the space\n         TRT   0(44,R7),TABLE_CHAR     Find next valid DSN char\n         BZ    GET040                  Branch if there isn't one\n         CR    R1,R6                   \"Belt and Braces\" ...\n         BNL   GET040                  ... not found\n         LR    R7,R1                   Address next entry\n         LA    R8,ARGTABLE_NEXT        Address next table entry\n         B     GET030                  Go back round\nGET040   DS    0H\n         SR    R6,R7                   Set length of last one\n         ST    R6,ARGTABLE_ARGSTRING_LENGTH * Store it\n         LA    R8,ARGTABLE_NEXT        Address next entry\n         MVC   ARGTABLE_ARGSTRING_PTR,=X'FFFFFFFF' * set to\n         MVC   ARGTABLE_ARGSTRING_LENGTH,=X'FFFFFFFF' * HIGH-VALUES\nGETDSNS_EXIT DS  0H\n         L     R14,GETSAVE             Get return address...\n         BR    R14                     ...and return\nGETSAVE  DC    A(0)\n*\nDSNALLOC DS    0H\n*   **********************************\n*   *  Allocate individual datasets  *\n*   **********************************\n         USING TU_DSN,R3\n         ST    R14,DSNRSAVE            Save the return address\n         LA    R4,S99_AREA             Address our SVC 99 area\n         MVI   DYNFLAG,C'Y'            Show that we attempted DYNALLOC\n         USING S99RBP,R4               * Address SVC 99 Request Block\n         LA    R5,S99RBPTR+4           * Point four bytes beyond start\n         USING S99RB,R5                * Est addressability to RB DSECT\n         ST    R5,S99RBPTR             * Make RBPTR point to Req Block\n         OI    S99RBPTR,S99RBPND       * On high-order bit in RBPTR\n         XC    S99RB(RBLEN),S99RB      * Zero out Req Block entirely\n         MVI   S99RBLN,RBLEN           * Put RB length into LEN field\n         MVI   S99VERB,S99VRBAL        * Set verb to ALLOCATE\n         LA    R6,S99RB+RBLEN          * Point past RB to TUP list\n         USING S99TUPL,R6              * Address Text Unit Pointers\n         ST    R6,S99TXTPP             * Store TUP address in RB\n*\n         LA    R7,TU_DSN               * Address DSN parameter\n         ST    R7,S99TUPTR             * ... and store in TUP list\n*\n         LA    R6,S99TUPL+4            * Get add of next TUP list entry\n         LA    R7,TU_DISP              * Address DISP parameter\n         ST    R7,S99TUPTR             * ... and store in TUP list\n*\n         LA    R6,S99TUPL+4            * Get add of next TUP list entry\n         LA    R7,TU_STAT              * Address STAT parameter\n         ST    R7,S99TUPTR             * ... and store in TUP list\n*\n         LA    R6,S99TUPL+4            * Get add of next TUP list entry\n         LA    R7,TU_DD                * Address DD parameter\n         ST    R7,S99TUPTR             * ... and store in TUP list\n*\n         LA    R6,S99TUPL+4            * Get add of next TUP list entry\n         LA    R7,TU_PERMD             * Address DD parameter\n         ST    R7,S99TUPTR             * ... and store in TUP list\n*\n         LA    R6,S99TUPL+4            * Get add of next TUP list entry\n         LA    R7,TU_NONCONV           * Address DD parameter\n         ST    R7,S99TUPTR             * ... and store in TUP list\n*\n         OI    S99TUPTR,S99TUPLN       * flag last parameter\n*\n         LR    R1,R4\n         DYNALLOC ,                    Do the \"business\"\n         LTR   R15,R15\n         BZ    DSNALLOC_EXIT           If it worked, we get out->\n         LA    R4,4(,R4)               Address the SVC99 RB\n         ST    R4,DFS99RBP             Set address for DAIRFAIL\n         ST    R15,SVC99RC             Set SVC99 retcode\n         LA    R14,SVC99RC             Get address of it\n         ST    R14,DFRCP               Set address for DAIRFAIL\n         LA    R14,DAIRSWIT            Get address of DAIR switches\n         ST    R14,DFIDP               Set address for DAIRFAIL\n         LA    R14,ZEROES              Get address of word of zeroes\n         ST    R14,DFJEFF02            Set IKJEFF02 addr Not Known\n         LA    R14,DFBUFS              Get address for messages\n         ST    R14,DFBUFP              Set address for DAIRFAIL\n         LA    R1,DFPARMS              Address DAIRFAIL parameter\n         LINK  EP=IKJEFF18             Call DAIRFAIL\n         L     R15,SVC99RC             Retrieve SVC 99 retcode\nDSNALLOC_EXIT DS 0H\n         L     R14,DSNRSAVE            Get return address\n         BR    R14                     And return\nDDFREE   DS    0H\n*   *************************************************\n*   *  This routine frees up the requested DD name  *\n*   *  giving us the same flexibility as the REUSE  *\n*   *  parameter in the TSO ALLOC command           *\n*   *************************************************\n         USING TU_DSN,R3               Address Text Unit\n         ST    R14,DSNRSAVE            Save the return address\n         LA    R4,S99_AREA             Address the SVC99 area\n         MVI   DYNFLAG,C'Y'            Show that we've tried DYNALLOC\n         USING S99RBP,R4               * Address SVC 99 Request Block\n         LA    R5,S99RBPTR+4           * Point four bytes beyond start\n         USING S99RB,R5                * Est addressability to RB DSECT\n         ST    R5,S99RBPTR             * Make RBPTR point to Req Block\n         OI    S99RBPTR,S99RBPND       * On high-order bit in RBPTR\n         XC    S99RB(RBLEN),S99RB      * Zero out Req Block entirely\n         MVI   S99RBLN,RBLEN           * Put RB length into LEN field\n         MVI   S99VERB,S99VRBUN        * Set verb to UNALLOCATE\n         LA    R6,S99RB+RBLEN          * Point past RB to TUP list\n         USING S99TUPL,R6              * Address Text Unit Pointers\n         ST    R6,S99TXTPP             * Store TUP address in RB\n*\n         LA    R7,TU_DD                * Address DD parameter\n         ST    R7,S99TUPTR             * ... and store in TUP list\n*\n         LA    R6,S99TUPL+4            * Get add of next TUP list entry\n         LA    R7,TU_DUN               * Address DUN parameter\n         ST    R7,S99TUPTR             * ... and store in TUP list\n*\n         OI    S99TUPTR,S99TUPLN       * flag last parameter\n*\n         LR    R1,R4\n         DYNALLOC                      Do the \"business\"\n         LTR   R15,R15\n         BZ    DDFREE_EXIT\n         LA    R4,4(,R4)               Address the SVC99 RB\n         ST    R4,DFS99RBP             Set address for DAIRFAIL\n         ST    R15,SVC99RC             Set SVC99 retcode\n         LA    R14,SVC99RC             Get address of it\n         ST    R14,DFRCP               Set address for DAIRFAIL\n         LA    R14,DAIRSWIT_F          Get address of DAIR switches\n         ST    R14,DFIDP               Set address for DAIRFAIL\n         LA    R14,ZEROES              Get address of word of zeroes\n         ST    R14,DFJEFF02            Set IKJEFF02 addr Not Known\n         LA    R14,DFBUFS              Get address for messages\n         ST    R14,DFBUFP              Set address for DAIRFAIL\n         LA    R1,DFPARMS              Address DAIRFAIL parameter\n         LINK  EP=IKJEFF18             Call DAIRFAIL\n         L     R15,SVC99RC             Retrieve SVC 99 retcode\nDDFREE_EXIT DS 0H\n         L     R14,DSNRSAVE            Get return address\n         BR    R14                     Go back\nCONCAT   DS    0H\n*   *********************************************\n*   *  This routine performs the concatenation  *\n*   *  this is done by addressing the list of   *\n*   *  DDnames and requesting concatenation     *\n*   *********************************************\n         ST    R14,DSNRSAVE            Save return address\n         LA    R4,S99_AREA             Address SVC99 area\n         MVI   DYNFLAG,C'Y'            Show we've done DYNALLOC\n         USING S99RBP,R4               * Address SVC 99 Request Block\n         LA    R5,S99RBPTR+4           * Point four bytes beyond start\n         USING S99RB,R5                * Est addressability to RB DSECT\n         ST    R5,S99RBPTR             * Make RBPTR point to Req Block\n         OI    S99RBPTR,S99RBPND       * On high-order bit in RBPTR\n         XC    S99RB(RBLEN),S99RB      * Zero out Req Block entirely\n         MVI   S99RBLN,RBLEN           * Put RB length into LEN field\n         MVI   S99VERB,S99VRBCC        * Set verb to CONCATENATE\n         LA    R6,S99RB+RBLEN          * Point past RB to TUP list\n         USING S99TUPL,R6              * Address Text Unit Pointers\n         ST    R6,S99TXTPP             * Store TUP address in RB\n*\n         LA    R7,TU_DDLIST            * Get address of DD list\n         ST    R7,S99TUPTR             * ... and store in TUP list\n*\n         LA    R6,S99TUPL+4            * Get add of next TUP list entry\n         LA    R7,TU_PERM              * Get address of PERM flag\n         ST    R7,S99TUPTR             * ... and store in TUP list\n         OI    S99TUPTR,S99TUPLN       * Indicate last Text Unit\n         LR    R1,R4\n         DYNALLOC\n         LTR   R15,R15\n         BZ    CONCAT_EXIT\n         LA    R4,4(,R4)               Address the SVC99 RB\n         ST    R4,DFS99RBP             Set address for DAIRFAIL\n         ST    R15,SVC99RC             Set SVC99 retcode\n         LA    R14,SVC99RC             Get address of it\n         ST    R14,DFRCP               Set address for DAIRFAIL\n         LA    R14,DAIRSWIT            Get address of DAIR switches\n         ST    R14,DFIDP               Set address for DAIRFAIL\n         LA    R14,ZEROES              Get address of word of zeroes\n         ST    R14,DFJEFF02            Set IKJEFF02 addr Not Known\n         LA    R14,DFBUFS              Get address for messages\n         ST    R14,DFBUFP              Set address for DAIRFAIL\n         LA    R1,DFPARMS              Address DAIRFAIL parameter\n         LINK  EP=IKJEFF18             Call DAIRFAIL\n         L     R15,SVC99RC             Retrieve SVC 99 retcode\nCONCAT_EXIT DS 0H\n         L     R14,DSNRSAVE            Get return address\n         BR    R14                     Go back\nDSNRSAVE DS    F\n         DS    0D\nEXEC5    MVC   0(0,R3),0(R8)           Move return code to REXX RC\nEXEC6    MVC   EVALBLOCK_EVDATA(0),0(R8)\n@IRXEXCOM DC   C'IRXEXCOM'\n#DDLEN   DC    A(0)\n#DSNLEN  DC    A(0)\n#DSNS    DC    A(0)\n$DDPARM  DC    A(0)\n$DSNPARM DC    A(0)\n$DSNADDR DC    A(0)\n$DSNLIST DC    A(0)\n$DDLIST  DC    A(0)\n$IRXEXCOM DC   A(0)\n$EFPLARG  DC   A(0)\n$EVALBLOCK DC  A(0)\n@DSNADDR DC    A(0)\n@DSNLIST DC    A(0)\n@DDLIST  DC    A(0)\nPACKDUBL DS    D\nZONEDEC  DS    CL16\nRC_SHVBLOCK DS CL(SHVBLEN)\nS99ERROR_SHVBLOCK DS CL(SHVBLEN)\nS99INFO_SHVBLOCK DS CL(SHVBLEN)\nS99MSG1_SHVBLOCK DS CL(SHVBLEN)\nS99MSG2_SHVBLOCK DS CL(SHVBLEN)\nRC       DS    CL5\nZEROES   DC    A(0)                @ IKJEFF02 (NOT KNOWN)\nDAIRSWIT DC    AL1(DFBUFSW)        RETURN THE MESSAGE\n         DC    AL1(DFSVC99)        ERROR DETECTED IN SVC 99\nDAIRSWIT_F DC  AL1(DFBUFSW)        RETURN THE MESSAGE\n         DC    AL1(DFFREE)        ERROR DETECTED IN \"FREE\"\nSVC99_ERROR DS    CL5\nSVC99_INFO  DS    CL5\nSVC99RC  DS F\nDYNFLAG  DS    CL1' '\nRCSIGN   DS    H\nRBLEN    EQU   (S99RBEND-S99RB)\n         DS    0D\nS99_AREA DC    XL100'FF'\n*\n*\nTU_DUN   DC    AL2(DUNUNALC)\n         DC    X'0000'\n*\nTU_PERMD DC    AL2(DALPERMA)\n         DC    X'0000'\n*\nTU_NONCONV DC    AL2(DALCNVRT)\n         DC    X'0000'\n*\nTU_DD    DS    0A\nTU_DD_T  DC    AL2(0)   <-will be DALDDNAM or DALRTDDN\nTU_DD_#  DC    X'0001'\nTU_DD_L  DC    X'0000'\nTU_DD_$  DC    CL8'        '\n*\nTU_PERM  DC    AL2(DCCPERMC)\n         DC    X'0000'\n*\nTU_DUNUNALC DC    AL2(DUNUNALC)\n         DC    X'0000'\n*\nTU_STAT  DC    AL2(DALSTATS)           Data Set status\n         DC    X'0001'                 .\n         DC    X'0001'                 .\nSTATUS   DC    X'08'                   DISP=KEEP\n*\nTU_DISP  DC    AL2(DALNDISP)           Data Set Disposition\n         DC    X'0001'                 .\n         DC    X'0001'                 .\n         DC    X'08'                   DISP=KEEP\n*\nTABLE_CHAR   DC XL256'00'              *****************************\n         ORG TABLE_CHAR+C'A'           * Table of valid characters *\n         DC  C'ABCDEFGHI'              * which can be at the start *\n         ORG TABLE_CHAR+C'J'           * of a dataset name         *\n         DC  C'JKLMNOPQR'              *****************************\n         ORG TABLE_CHAR+C'S'\n         DC  C'STUVWXYZ'\n         ORG TABLE_CHAR+C'#'\n         DC  C'#'\n         ORG TABLE_CHAR+C'@'\n         DC  C'@'\n         ORG TABLE_CHAR+C'$'\n         DC  C'$'\n         ORG TABLE_CHAR+X'7D'\n         DC  X'7D'\n         ORG TABLE_CHAR+L'TABLE_CHAR\nTABLE_SPACE  DC XL256'00'              ********************\n         ORG TABLE_SPACE+C' '          * Table containing *\n         DC  C' '                      * space and comma  *\n         ORG TABLE_SPACE+C','          * (used as dataset *\n         DC  C','                      * name delimiters  *\n         ORG TABLE_SPACE+L'TABLE_SPACE ********************\n         LTORG\n*\nTU_DSN   DSECT\nTU_DSN_T DC    AL2(DALDSNAM)           Data Set Name\nTU_DSN_# DC    X'0001'\nTU_DSN_L DC    X'002C'\nTU_DSN_$ DS    CL44\n*\nTU_DDLIST DSECT\nTU_DDLIST_T DC AL2(DALDDNAM)           DD Name\nTU_DDLIST_# DC X'0001'\nTU_DDLIST_L DC X'0008'\nTU_DDLIST_$ DS CL8\nTU_DDLIST_@ EQU *-TU_DDLIST_L\n*\n         IEFZB4D0 ,\n         IEFZB4D2 ,\n         IRXEVALB ,                    REXX's evaluation block\n         IRXENVB  ,                    REXX's environment block\n         IRXEXTE  ,                    REXX's vector block\n         IRXSHVB  ,                    REXX's shared variable block\n         IRXEFPL  ,                    REXX's external function\n*                                             parameter list\nDYNALLOC CSECT\n         IRXARGTB DECLARE=YES          REXX's parsed argument list\nDYNALLOC CSECT\n         IKJEFFDF DFDSECT=NO,DFDSEC2=NO DAIRFAIL areas\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "README": {"ttr": 774, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x99#\\x9f\\x00\\x99#\\x9f\\x138\\x00\\n\\x00\\x05\\x00\\x00\\xe8\\xf0\\xf0\\xf1\\xd2\\xd4\\xf6@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1999-08-27T00:00:00", "modifydate": "1999-08-27T13:38:00", "lines": 10, "newlines": 5, "modlines": 0, "user": "Y001KM6"}, "text": "The other two members in this dataset are:\n    1.  DYNALLOC - The main (only) routine.\n    2.  ASMTSTMP - A macro which is used to\n                   insert a date/time stamp\n                   into the load module.\n    Contact information:\n    Home Email: ken.mackenzie@tesco.net\n              : ken.mackenzie@talk21.com\n    Work Email: ken.mackenzie@natwest.com\n    Work Phone: +44 (0) 20 7709 6365\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT372/FILE372.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT372", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}