{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220013550000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 646646, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 16, "INMDSNAM": "CBT.V500.FILE950.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 646646, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 646646, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE950.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x0c\\x04'", "DS1TRBAL": "b'\\xc2,'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xc0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xc0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\t\\xe1\\x00\\x04\\t\\xe2\\x00\\x01\\x00\\r'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04c\\x00\\x00\\x01 \\x01O\\x01 \\x01O\\x144\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf9@@@'", "ispf": {"version": "04.99", "flags": 0, "createdate": "2020-01-14T00:00:00", "modifydate": "2020-01-14T14:34:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-499"}, "text": "REGULAR CBT TAPE - VERSION 499    FILE:  950\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT499.FILE950\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    27920   PO\n\n   PDS117I 63 MEMBERS COUNTED; CUMULATIVE SIZE IS 5,436 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   01/14/20    14:33:59    UTC-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FILE950": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04c\\x00R\\x01 \\x01O\\x01 \\x01O\\x143\\x00v\\x00v\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf9@@@'", "ispf": {"version": "04.99", "flags": 0, "createdate": "2020-01-14T00:00:00", "modifydate": "2020-01-14T14:33:52", "lines": 118, "newlines": 118, "modlines": 0, "user": "CBT-499"}, "text": "//***FILE 950 is from Norbert Haas and contains many useful tools,  *   FILE 950\n//*           mostly written in REXX.                               *   FILE 950\n//*                                                                 *   FILE 950\n//*           Most of these tools have REXX'es and panels.          *   FILE 950\n//*                                                                 *   FILE 950\n//*           There are many more tools here than we describe       *   FILE 950\n//*           below.                                                *   FILE 950\n//*                                                                 *   FILE 950\n//*           Some of these products are commented in German.       *   FILE 950\n//*           We tried to translate most of them into English.      *   FILE 950\n//*                                                                 *   FILE 950\n//*           email:    nh@noadatex.de                              *   FILE 950\n//*           website:  www.noadatex.de                             *   FILE 950\n//*                                                                 *   FILE 950\n//*           email:    sbgolob@cbttape.org                         *   FILE 950\n//*                                                                 *   FILE 950\n//*       Partial Description:                                      *   FILE 950\n//*                                                                 *   FILE 950\n//*       AUTOMAT  - A quick method of setting up multiple split    *   FILE 950\n//*                  sessions in ISPF, as soon as you get into      *   FILE 950\n//*                  ISPF.  (Note: IBM's =XALL command gets rid     *   FILE 950\n//*                  of them quickly when you want to close them    *   FILE 950\n//*                  down.)                                         *   FILE 950\n//*                                                                 *   FILE 950\n//*       BACKUP   - Make a quick backup of a dataset from an       *   FILE 950\n//*                  ISPF 3.4 list (DSLIST).                        *   FILE 950\n//*                                                                 *   FILE 950\n//*       CHALL    - Change a string to another string, globally    *   FILE 950\n//*                  in a pds.                                      *   FILE 950\n//*                                                                 *   FILE 950\n//*       CUAATTR  - Summary of color and other attribute codes in  *   FILE 950\n//*                  ISPF panels.                                   *   FILE 950\n//*                                                                 *   FILE 950\n//*       FSCREEN  - Find characters on the screen.                 *   FILE 950\n//*                                                                 *   FILE 950\n//*       INTER    - Small REXX test interpreter                    *   FILE 950\n//*                                                                 *   FILE 950\n//*       KONKAT   - A REXX function to concatenate two strings     *   FILE 950\n//*                  inside a REXX.                                 *   FILE 950\n//*                                                                 *   FILE 950\n//*       NOT      - A REXX function like \"NOT\"                     *   FILE 950\n//*                                                                 *   FILE 950\n//*       ODER     - A REXX function to \"OR\"                        *   FILE 950\n//*                                                                 *   FILE 950\n//*       RULER    - Edit macro to put a ruler into the edit        *   FILE 950\n//*                                                                 *   FILE 950\n//*       SAVE     - Double a dataset (earlier version of BACKUP)   *   FILE 950\n//*                                                                 *   FILE 950\n//*       WHOHOLDS - A REXX function to tell you if a dataset       *   FILE 950\n//*                  is in use.                                     *   FILE 950\n//*                                                                 *   FILE 950\n//*       XMAN     - An easy TSO TRANSMIT (XMIT) interface in       *   FILE 950\n//*                  ISPF.                                          *   FILE 950\n//*                                                                 *   FILE 950\n//*       ALL MEMBERS OF THIS DATASET:                              *   FILE 950\n//*                                                                 *   FILE 950\n//*       NAME       VER.MOD   LAST MODIFIED     SIZE   ID          *   FILE 950\n//*       $$$#DATE    04.93   2017/01/06 00:22     12 CBT-493       *   FILE 950\n//*       @FILE950    04.93   2017/01/06 00:22    116 CBT-493       *   FILE 950\n//*       ADDUP       01.01   2017/01/05 09:23    104 NORBERT       *   FILE 950\n//*       AREA        01.01   2017/01/05 09:23     37 NORBERT       *   FILE 950\n//*       AUTOMAT     01.40   2017/01/05 09:23    290 NORBERT       *   FILE 950\n//*       BACKUP      01.04   2017/01/05 09:23    339 NORBERT       *   FILE 950\n//*       BACKUPH0    01.01   2016/12/19 12:37     37 NORBERT       *   FILE 950\n//*       BACKUPH1    01.00   2017/01/02 10:07     17 NORBERT       *   FILE 950\n//*       BACKUPH2    01.00   2016/12/19 12:35     19 NORBERT       *   FILE 950\n//*       BACKUPH3    01.02   2017/01/05 09:10     32 NORBERT       *   FILE 950\n//*       BACKUPH4    01.00   2017/01/02 10:07     20 NORBERT       *   FILE 950\n//*       BACKUPH5    01.00   2017/01/02 10:07     20 NORBERT       *   FILE 950\n//*       BACKUPH6    01.00   2016/12/19 12:37     19 NORBERT       *   FILE 950\n//*       BACKUPH7    01.00   2017/01/02 10:07     19 NORBERT       *   FILE 950\n//*       BACKUPP     01.04   2010/04/16 07:29     94 NORBERT       *   FILE 950\n//*       BIG         01.01   2017/01/05 09:23    177 NORBERT       *   FILE 950\n//*       BODY        01.01   2017/01/05 09:23     37 NORBERT       *   FILE 950\n//*       BOX         01.01   2017/01/05 09:23    244 NORBERT       *   FILE 950\n//*       CATCH       01.02   2017/01/05 09:23     39 NORBERT       *   FILE 950\n//*       CFIND       01.01   2017/01/05 09:23     92 NORBERT       *   FILE 950\n//*       CHALL       01.04   2017/01/05 09:23    133 NORBERT       *   FILE 950\n//*       CHALLM      01.00   2016/10/07 00:31     36 NORBERT       *   FILE 950\n//*       CHALLP      01.13   2017/01/05 09:10     67 NORBERT       *   FILE 950\n//*       COLA        01.01   2017/01/05 09:23     94 NORBERT       *   FILE 950\n//*       CUAATTR     01.04   2017/01/05 09:23    101 NORBERT       *   FILE 950\n//*       CUTMEM      01.01   2017/01/05 09:23     26 NORBERT       *   FILE 950\n//*       C2B         01.01   2017/01/05 09:23     23 NORBERT       *   FILE 950\n//*       DATE        01.08   2017/01/05 09:23     56 NORBERT       *   FILE 950\n//*       DISPMSG     01.02   2017/01/05 23:48     21 NORBERT       *   FILE 950\n//*       DSINFO      01.01   2017/01/05 09:23    221 NORBERT       *   FILE 950\n//*       D2B         01.02   2017/01/05 09:23     31 NORBERT       *   FILE 950\n//*       ET          01.01   2017/01/05 09:23    111 NORBERT       *   FILE 950\n//*       ET2         01.01   2017/01/05 09:23     81 NORBERT       *   FILE 950\n//*       FF          01.02   2017/01/05 09:23     39 NORBERT       *   FILE 950\n//*       FLAGCHGS    01.03   2017/01/05 09:23    158 NORBERT       *   FILE 950\n//*       FSCREEN     01.00   2016/10/07 00:31     57 NORBERT       *   FILE 950\n//*       INCL        01.01   2017/01/05 09:23     23 NORBERT       *   FILE 950\n//*       INTER       01.02   2017/01/05 09:23     43 NORBERT       *   FILE 950\n//*       KILL        01.01   2017/01/05 09:23    115 NORBERT       *   FILE 950\n//*       KONKAT      01.02   2017/01/05 09:23     21 NORBERT       *   FILE 950\n//*       LASTWORD    01.01   2017/01/05 09:23     15 NORBERT       *   FILE 950\n//*       LCL         01.01   2017/01/05 09:23     50 NORBERT       *   FILE 950\n//*       LCLP        01.01   2017/01/05 09:10     76 NORBERT       *   FILE 950\n//*       LINFO       01.01   2017/01/05 09:23    170 NORBERT       *   FILE 950\n//*       MCANCEL     01.01   2017/01/05 09:23     15 NORBERT       *   FILE 950\n//*       MIRACLE     01.00   2017/01/05 09:23      4 NORBERT       *   FILE 950\n//*       NOT         01.01   2017/01/05 09:23     23 NORBERT       *   FILE 950\n//*       ODER        01.02   2017/01/05 09:23     27 NORBERT       *   FILE 950\n//*       ONLY        01.01   2017/01/05 09:23     25 NORBERT       *   FILE 950\n//*       PACKCHG     01.14   2017/01/05 09:23    334 NORBERT       *   FILE 950\n//*       PACKCHG1    01.19   2017/01/05 09:23    227 NORBERT       *   FILE 950\n//*       PACKCHG2    01.13   2017/01/05 09:23     57 NORBERT       *   FILE 950\n//*       PACKCHG3    01.12   2017/01/05 09:23     62 NORBERT       *   FILE 950\n//*       SAVE        01.03   2017/01/05 09:23    226 NORBERT       *   FILE 950\n//*       SAVEP       01.00   2016/10/07 00:31     43 NORBERT       *   FILE 950\n//*       SETLAB      01.01   2017/01/05 09:23     96 NORBERT       *   FILE 950\n//*       WHOHOLDS    01.03   2017/01/05 09:23     36 NORBERT       *   FILE 950\n//*       XDOUBLE     01.03   2017/01/05 09:23    162 NORBERT       *   FILE 950\n//*       XMAN        01.04   2017/01/05 09:23    168 NORBERT       *   FILE 950\n//*       XMANP       01.02   2017/01/05 09:23     50 NORBERT       *   FILE 950\n//*                                                                 *   FILE 950\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ADDUP": {"ttr": 521, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x18\\x01\\x17\\x00_\\x01\\x17\\x00_\\t#\\x00h\\x00h\\x00\\x00\\xd5\\xd6\\xd9\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2017-01-05T00:00:00", "modifydate": "2017-01-05T09:23:18", "lines": 104, "newlines": 104, "modlines": 0, "user": "NORBERT"}, "text": "/* REXX ***************************************************************/\n/* -------------------------------------------------------------------*/\n/* Name:       ADDUP                                                  */\n/* Function:   Summarizes the content of special columns within the   */\n/*             editor (incl sign >+< or >-< and decimal sign >.<)     */\n/* Type:       REXX-macro                                             */\n/* Author:     Norbert Haas, noaDatex.de                              */\n/* Input:      Content of the editor                                  */\n/* Output:     Long message                                           */\n/* Syntax:     ADDUP first_col last_col                               */\n/* Parameter:  first_col = First column                               */\n/*             last_col  = Last column                                */\n/* Remark:     Counts only on NX lines|                               */\n/* Example:    ADDUP 10 14                                            */\n/*                                                                    */\n/* Version Author   Date       Why                                    */\n/* ------- -------- ---------- -------------------------------------- */\n/* V01.01  N.Haas   27.06.2012 Also Blanks (counted as zero) are      */\n/*                             allowed now.                           */\n/* V01.00  N.Haas   18.07.2007 Creation                               */\n/**********************************************************************/\n\"ISREDIT MACRO (parm) NOPROCESS\"\n\n/* Init */\nTRUE = 1\nFALSE = 0\n\n/* Plausi */\nIF WORDS(parm) /= 2 THEN DO\n   CALL Set_Message 'Macro ADDUP needs exactly two parameter. Syntax:',\n                    'ADDUP from_col to_col.', TRUE\n   EXIT 1\nEND\nPARSE VAR parm from to\nIF DATATYPE(from) /= 'NUM' | DATATYPE(to) /= 'NUM' THEN DO\n   CALL Set_Message 'Both parameters have to be numeric.',TRUE\n   EXIT 1\nEND\n\"ISREDIT (lrecl) = LRECL\"\nIF from < 1 | to > lrecl THEN DO\n   CALL Set_Message 'Both parameters have to be between 1',\n                    'and' lrecl+0'.', TRUE\n   EXIT 1\nEND\n\n/* More Init */\nlen     = to - from + 1\nsum     = 0\ncounter = 0\nNUMERIC DIGITS 30\nzedlmsg = \"BUSY ...\"\nCALL Show_Message\n\n/* Loop over all NX lines */\n\"ISREDIT (last) = LINENUM .ZL\"\nDO i = 1 TO last\n   \"ISREDIT (status) = XSTATUS (i)\"\n   IF status = 'X' THEN NOP\n   ELSE DO\n      \"ISREDIT (content) = LINE (i)\"\n      value = SUBSTR(content, from, len)\n      value = TRANSLATE(value, '0', ' ')       /* new, Blanks allowed */\n      IF DATATYPE(value) /= 'NUM' THEN DO\n         CALL Set_Message 'At least in line' i+0 'there is a non',\n                          'numeric value in column' from 'to' to'.',,\n                          TRUE\n         EXIT 1\n      END\n      ELSE DO\n         counter = counter + 1\n         sum = sum + value\n         IF counter // 2500 = 0 THEN DO\n            zedlmsg = zedlmsg || '.'\n            CALL Show_Message\n         END\n      END\n   END\nEND\n\n/* Message */\nCALL Set_Message 'I counted' counter 'lines between line 1 and line',\n                 last+0'. The sum of' sum 'has been computed.', FALSE\n\nEXIT\n\nSet_Message: PROCEDURE EXPOSE TRUE FALSE\n   PARSE ARG lmsg, beep\n\n   zedsmsg = ''\n   zedlmsg = lmsg\n\n\n   IF beep THEN\n      \"ISPEXEC SETMSG MSG(ISRZ001)\"\n   ELSE\n      \"ISPEXEC SETMSG MSG(ISRZ000)\"\nRETURN\n\nShow_Message: PROCEDURE EXPOSE zedlmsg\n   zedsmsg = \"\"\n   \"ISPEXEC CONTROL DISPLAY LOCK\"\n   \"ISPEXEC DISPLAY MSG(ISRZ000)\"\n   IF LENGTH(zedlmsg) > 60 THEN zedlmsg = \"BUSY ...\"\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "AREA": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x18\\x01\\x17\\x00_\\x01\\x17\\x00_\\t#\\x00%\\x00%\\x00\\x00\\xd5\\xd6\\xd9\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2017-01-05T00:00:00", "modifydate": "2017-01-05T09:23:18", "lines": 37, "newlines": 37, "modlines": 0, "user": "NORBERT"}, "text": "/* REXX ------------------------------------------------------------- */\n/* Macro:         AREA                                                */\n/* Syntax:        AREA                                                */\n/* Parameter:     none                                                */\n/* Function:      counts the number of lines in the )AREA section of  */\n/*                a ISPF-Panel.                                       */\n/* Author:        Norbert Haas, noaDatex.de                           */\n/* Remark:        See macro BODY.                                     */\n/* ------------------------------------------------------------------ */\n\"ISREDIT MACRO\"\n\n\"ISREDIT FIND FIRST ')AREA' 1\"\nIF rc = 0 THEN DO\n   \"ISREDIT (z1) = LINENUM .ZCSR\"\n   \"ISREDIT FIND NEXT ')' 1\"\n   IF rc = 0 THEN DO\n      \"ISREDIT (z2) = LINENUM .ZCSR\"\n      anz = z2 - z1 - 1\n      \"ISREDIT (panel) = MEMBER\"\n      zedsmsg = 'AREA' anz 'lines'\n      zedlmsg = 'Panel' panel 'has' anz 'line in the AREA-Section.'\n      \"ISPEXEC SETMSG MSG(isrz000)\"\n      \"ISREDIT FIND FIRST ')AREA' 1\"\n   END\n   ELSE DO\n      zedsmsg = 'Error (END missing)'\n      zedlmsg = 'No )END-Section found in this panel.'\n      \"ISPEXEC SETMSG MSG(isrz001)\"\n   END\nEND\nELSE DO\n   zedsmsg = 'Error (AREA missing)'\n   zedlmsg = 'No )AREA-Section found in this panel.'\n   \"ISPEXEC SETMSG MSG(isrz001)\"\nEND\n\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "AUTOMAT": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01*\\x00\\x18\\x01\\x17\\x00_\\x01 \\x01O\\x13\\t\\x01&\\x01\"\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.42", "flags": 0, "createdate": "2017-01-05T00:00:00", "modifydate": "2020-01-14T13:09:18", "lines": 294, "newlines": 290, "modlines": 0, "user": "SBGOLOB"}, "text": "/* REXX OK ************************************************************/\n/* -------------------------------------------------------------------*/\n/* Name:     AUTOMAT                                                  */\n/* Syntax:   \u00ddTSO\u00a8 AUTOMAT \u00ddB|E|V|R\u00a8                                  */\n/* Parms:    B = Browse Profile member                                */\n/*           E = Edit        \"    \"                                   */\n/*           V = View        \"    \"                                   */\n/*           R = Review      \"    \"                                   */\n/* Purpose:  Automatically Opening Several Split Screens              */\n/* Type:     REXX-Exec                                                */\n/* Author:   Norbert Haas, noaDatex.de                                */\n/* Date:     10.04.1999                                               */\n/*                                                                    */\n/* Change:   Assume that your ISPF PROFILE dataset is called          */\n/*           userid.ISPF.ISPPROF  and not  userid.TSOPROF        SBG  */\n/*           (See member AUTOMAT1 for original exec.)                 */\n/*                                                                    */\n/* Description:                                                       */\n/* ------------                                                       */\n/* The purpose of this exec is to automatically open multiple ISPF    */\n/* split screens, under the control of a profile dataset, which       */\n/* determines how many and what screens are open, and in what order.  */\n/*                                                                    */\n/* The profile member, whose member name is AUTOMAT, is created in    */\n/* the ISPF profile library, and the applications to be called, are   */\n/* listed there.  This member is created during the first call,       */\n/* brought into the editor and can then be changed by the user.       */\n/* The AUTOMAT profile is newly created only during the first call.   */\n/*                                                                    */\n/* The ISPF profile name should be changed in this exec, to your own  */\n/* ISPF profile name, or name pattern.  See line 112.                 */\n/*                                                                    */\n/* Applications listed in the AUTOMAT profile are each called up in   */\n/* a separate split screen, but executing AUTOMAT itself, needs       */\n/* an initial ISPF screen, because AUTOMAT won't run unless ISPF is   */\n/* already up.  The first application started by AUTOMAT then comes   */\n/* up in the second ISPF screen, the second application in the 3rd    */\n/* screen, and so forth.                                              */\n/*                                                                    */\n/* If AUTOMAT is called with parameters B(rowse), V(iew) or E(dit),   */\n/* then the AUTOMAT profile member in the ISPF profile library (as    */\n/* hard-coded in this exec) is Browsed, Viewed, or Edited, so you     */\n/* can see, or change, how you want AUTOMAT to operate.               */\n/*                                                                    */\n/* I have added an option to call AUTOMAT with a parameter \"R\" for    */\n/* the REVIEW TSO command.  REVIEW (found on CBT Tape Files 134       */\n/* (source) and 135 (load modules)) can browse or edit datasets in    */\n/* TSO READY mode, or it can use ISPF if it is available.  REVIEW     */\n/* has an editing option, if you \"UPDATE\" the dataset being reviewed. */\n/* So you can use REVIEW to fix the profile dataset when ISPF is      */\n/* not up yet.  REVIEW is a very convenient recovery tool. (SBG)      */\n/*                                                                    */\n/* Remark:                                                            */\n/* ------                                                             */\n/* It might be useful to put the following command into the ISPF      */\n/* Command Table as specified below.  In this way, you can avoid      */\n/* having to press TSO before entering the command, AUTOMAT.          */\n/* You can check the results of executing AUTOMAT using the SWAP      */\n/* LIST ISPF command.                                                 */\n/*                                                                    */\n/*    Variable   Value                                                */\n/*    ---------- -------                                              */\n/*    ZCTVERB    AUTOMAT                                              */\n/*    ZCTTRUNC   4                                                    */\n/*    ZCTACT     SELECT CMD(%AUTOMAT &ZPARM) SUSPEND SCRNAME(AUTOMAT) */\n/*    ZCTDESC    Call the split-screen automation                     */\n/*                                                                    */\n/* If the automation is to be started from the Primary Option Menu as */\n/* a menu item, this can be done as follows (in the example, 'T' is   */\n/* the corresponding menu character):                                 */\n/*                                                                    */\n/* Part of the PROC section of the Primary Option Menu panel:         */\n/*                                                                    */\n/*    &ZSEL = TRANS ( TRUNC (&ZCMD,'.')                               */\n/*      0,'PGM(ISPISM) SCRNAME(SETTINGS)'                             */\n/*      1,'PGM(ISRBRO) PARM(ISRBRO01) SCRNAME(VIEW)'                  */\n/*      2,'PGM(ISREDIT) PARM(P,ISREDM01) SCRNAME(EDIT)'               */\n/*      3,'PANEL(ISRUTIL) SCRNAME(UTIL)'                              */\n/*      ...  (more lines)                                             */\n/*      T,'CMD(automat)'                                              */\n/*      X,EXIT                                                        */\n/*     ' ',' '                                                        */\n/*       *,'?' )                                                      */\n/*                                                                    */\n/* Adjustments                                                        */\n/* -----------                                                        */\n/* It is necessary to adjust the maximum number of split screens on   */\n/* line 110 and the DSN of the profile library on line 111.           */\n/*                                                                    */\n/* -------------------------------------------------------------------*/\n/* Version   Author      Date        Modification                     */\n/* --------- ----------- ----------- -------------------------------- */\n/* V01.02    N.Haas      19.12.2016  Translated into English          */\n/*                                   (powered by Google Translator)   */\n/*           S.Golob     26.12.2016  English fixed better.            */\n/*                                   Add support for REVIEW command   */\n/* V01.01    N.Haas      31.05.1999  Added SPLIT-Screen test          */\n/* V01.00    N.Haas      10.04.1999  Creation                         */\n/* ********************************************************************/\n/*                                                                    */\n/* Initialization --------------------------------------------------- */\n/* --------------                                                     */\n\n/* Get parameter (empty, B, V, or E, or R)  ------------------------- */\nPARSE UPPER ARG parm\nparm = LEFT(parm,1)\n\n\"ISPEXEC CONTROL ERRORS RETURN\"\nTRUE = 1                                                      /* True */\nFALSE = 0                                                    /* False */\nuserid = USERID()\ncmd_counter = 0\ncmd_lines. = ''\n\nmax_split = 8                 /* not greater than 8 */    /*  adjust  */\nautomat_dsn_mem = \"'\"userid\".ISPF.ISPPROF(AUTOMAT)'\"      /*  adjust  */\n\nautomat_exists = SYSDSN(automat_dsn_mem)\n\n/* Does the AUTOMAT member exist in the ISPF profile library ? ------ */\nIF automat_exists /= 'OK' THEN DO\n   /* Create it, but if not.....   ---------------------------------- */\n   CALL Init_Default_Automat\n\n   /* Message ------------------------------------------------------- */\n   CALL Display_Message \"\",,\n       \"A sample profile member has been created. Please adapt\",\n       \"this member to your needs now. After customizing the member\",\n       \"and exiting the Edit, you can then restart AUTOMAT.\",,\n      \"ISRZ000\"\n\n   /* if you set a parm of \"E\", then you will call the Editor  ------ */\n   parm = 'E'\nEND\n\n/* Will a parameter be entered? ------------------------------------- */\nIF parm /= \"\" THEN DO        /* With Parameter ==> Browse, View, Edit */\n   SELECT\n      WHEN parm = \"B\" THEN DO                               /* BROWSE */\n         \"ISPEXEC BROWSE DATASET(\"automat_dsn_mem\")\"\n      END\n\n      WHEN parm = \"V\" THEN DO                                 /* VIEW */\n         \"ISPEXEC VIEW DATASET(\"automat_dsn_mem\")\"\n      END\n\n      WHEN parm = \"E\" THEN DO                                 /* EDIT */\n         \"ISPEXEC EDIT DATASET(\"automat_dsn_mem\")\"\n      END\n\n      WHEN parm = \"R\" THEN DO                               /* REVIEW */\n         \"REVIEW \"automat_dsn_mem\" \"\n      /*  The REVIEW TSO command is on the CBT Tape File 134.   */\n      /*  The REVIEW load modules are on the CBT Tape File 135. */\n      /*  REVIEW operates with or without ISPF, so you can use  */\n      /*  REVIEW's UPDATE parameter to edit the profile without */\n      /*  needing ISPF to be up.  AUTOMAT R works without ISPF. */\n      /*        CBT Tape address is:  www.cbttape.org           */\n      END\n\n      OTHERWISE DO\n         CALL Display_Message \"\",,\n             \"Bad Parameter -\",\n             \"AUTOMAT must start with parameter B(rowse), V(iew) or\",\n             \"E(dit), or R(eview), or without a parameter.\",,\n            \"ISRZ001\"\n      END\n   END\n   /* Cancel -------------------------------------------------------- */\n   SIGNAL Ende\nEND\nELSE DO            /* Wihout a parameter, AUTOMAT creates the splits. */\n   /* Are two SPLIT-Screens already active?-------------------------- */\n   \"ISPEXEC CONTROL SPLIT DISABLE\"\n   split_rc = rc\n   IF split_rc /= 0 THEN DO\n      CALL Display_Message \"\",,\n          \"Message - Split screens are already opened.\",\n          \"You cannot call AUTOMAT now if more than\",\n          \"one ISPF screen is open.\",,\n         \"ISRZ001\"\n       SIGNAL Ende\n   END\n   ELSE \"ISPEXEC CONTROL SPLIT ENABLE\"\nEND\n\n/* The member exists => Read and process all lines of it. ----------- */\n\"ALLOC FI(dd) DA(\"automat_dsn_mem\") SHR REUSE\"\n\"EXECIO * DISKR dd (FINIS STEM line.)\"\n\"FREE FI(dd)\"\n\n/* Put all the commands together. ----------------------------------- */\nDO i = 1 TO line.0\n   temp_pos = INDEX(line.i,'/*')                    /* Comment line ? */\n\n   IF temp_pos > 0 THEN DO                 /* Is the line a comment ? */\n      IF temp_pos = 1 THEN DO      /* Yes the whole line is a comment */\n         temp_cmd = ''\n      END\n      ELSE DO                  /* No. Just chop the comment at the end */\n         temp_cmd = STRIP(LEFT(line.i,temp_pos - 1))\n      END\n   END\n   ELSE DO                                       /* No comment there. */\n      temp_cmd = STRIP(line.i)\n   END\n\n   IF temp_cmd /= '' THEN DO               /* Then save that command. */\n      cmd_counter = cmd_counter + 1\n      cmd_lines.cmd_counter = temp_cmd\n   END\nEND\n\n/* More than max_splits - 1 ? --------------------------------------- */\nIF cmd_counter > max_split - 1 THEN DO\n      CALL Display_Message \"\",,\n         \"Too many commands specified in profile.\",\n         \"A maximum of\" max_split \"screens is possible.\",\n         \"AUTOMAT requires one initial ISPF screen\",\n         \"before starting up.\",\n         \"So please reduce the number of commands\",\n         \"in the profile, to a maximum of\",\n          max_split - 1\".\",,\n         \"ISRZ001\"\n\n   /* Call Edit to edit the profile dataset) ------------------------ */\n   \"ISPEXEC EDIT DATASET(\"automat_dsn_mem\")\"\n\n   /* Cancel -------------------------------------------------------- */\n   SIGNAL Ende\nEND\n\n/* Call the commands now  ------------------------------------------- */\nDO i = 1 TO cmd_counter\n   /* Get each command ... ------------------------------------------ */\n   tempcmd = cmd_lines.i\n\n   /* ... and process  ---------------------------------------------- */\n   CALL Aktivate_Command\nEND\n\n/* The first (current) screen will get the screen name TMP ------- */\ntempcmd = \"SCRNAME TMP PERM\"\n\"ISPEXEC DISPLAY COMMAND(tempcmd)\"\n\n/* Afterwards display a SWAP LIST ----------------------------------- */\ntempcmd = \"SWAP LIST\"\n\"ISPEXEC DISPLAY COMMAND(tempcmd)\"\n\n/* Ende ------------------------------------------------------------- */\nEnde:\nEXIT\n\n/* ================================================================== */\n/* ========================  Subroutines  =========================== */\n/* ================================================================== */\n\nAktivate_Command:\n   /* Add SWAP at the end and process ------------------------------- */\n   tempcmd = tempcmd\";SWAP\"\n   \"ISPEXEC SELECT PGM(ISPSTRT) PARM(\"tempcmd\")\"\nReturn\n\nInit_Default_Automat:\n   line.0 = 17\n\n   line.1 = \"/* --------------------------------------------------- */\"\n   line.2 = \"/* AUTOMAT PROFILE - Applications to be started...     */\"\n   line.3 = \"/* --------------------------------------------------- */\"\n   line.4 = \"/* Please note that AUTOMAT itself requires one ISPF   */\"\n   line.5 = \"/* screen to be opened first. This means that the next */\"\n   line.6 = \"/* application which will be opened by AUTOMAT, will   */\"\n   line.7 = \"/* start next.  That is, the first screen specified    */\"\n   line.8 = \"/* below will be the second split screen, and the next */\"\n   line.9 = \"/* one after that will be the 3rd split screen, etc.   */\"\n   line.10= \"/*                                                     */\"\n   line.11= \"/* Sample entries:                                     */\"\n   line.12= \"/* --------------------------------------------------- */\"\n   line.13= \"1; SCRNAME BRS                            /* 1.View    */\"\n   line.14= \"2; SCRNAME EDT                            /* 2.Editor  */\"\n   line.15= \"3.4                                       /* 3.DSLIST  */\"\n   line.16= \"TSO UPSEDIT N#C015.X1480.SRC; SCRNAME SRC /* 4.TSO-CMD */\"\n   line.17= \"SDSF; PREFIX <your userid>; OWNER *       /* 5.SDSF    */\"\n\n   \"ALLOC FI(dd) DA(\"automat_dsn_mem\") SHR REUSE\"\n   \"EXECIO\" line.0 \"DISKW dd (FINIS STEM line.)\"\n   \"FREE FI(dd)\"\nRETURN\n\nDisplay_Message:\n   PARSE ARG zedsmsg, zedlmsg, msgtype\n\n   \"ISPEXEC SETMSG MSG(\"msgtype\")\"\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "AUTOMAT@": {"ttr": 771, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00H\\x01\\x19\\x19?\\x01\\x19\\x19?\\x10\\x06\\x00\\x13\\x00\\x13\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-07-12T00:00:00", "modifydate": "2019-07-12T10:06:48", "lines": 19, "newlines": 19, "modlines": 0, "user": "SBGOLOB"}, "text": "/* --------------------------------------------------- */\n/* AUTOMAT PROFILE - Applications to be started...     */\n/* --------------------------------------------------- */\n/* Please note that AUTOMAT itself requires one ISPF   */\n/* screen to be opened first. This means that the next */\n/* application which will be opened by AUTOMAT, will   */\n/* start next.  That is, the first screen specified    */\n/* below will be the second split screen, and the next */\n/* one after that will be the 3rd split screen, etc.   */\n/*                                                     */\n/* Sample entries:                                     */\n/* --------------------------------------------------- */\nTSO                                        /* 1.TSO-CMD */\nTSO                                        /* 2.TSO-CMD */\nTSO                                        /* 3.TSO-CMD */\nTSO                                        /* 4.TSO-CMD */\nTSO                                        /* 5.TSO-CMD */\nTSO                                        /* 6.TSO-CMD */\nSDSF; PREFIX SBGOLOB*; OWNER *;SCRNAME SDSF /*7.SDSF    */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "AUTOMAT1": {"ttr": 773, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01(\\x00\\x18\\x01\\x17\\x00_\\x01\\x17\\x00_\\t#\\x01\"\\x01\"\\x00\\x00\\xd5\\xd6\\xd9\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.40", "flags": 0, "createdate": "2017-01-05T00:00:00", "modifydate": "2017-01-05T09:23:18", "lines": 290, "newlines": 290, "modlines": 0, "user": "NORBERT"}, "text": "/* REXX OK ************************************************************/\n/* -------------------------------------------------------------------*/\n/* Name:     AUTOMAT                                                  */\n/* Syntax:   \u00ddTSO\u00a8 AUTOMAT \u00ddB|E|V|R\u00a8                                  */\n/* Parms:    B = Browse Profile member                                */\n/*           E = Edit        \"    \"                                   */\n/*           V = View        \"    \"                                   */\n/*           R = Review      \"    \"                                   */\n/* Purpose:  Automatically Opening Several Split Screens              */\n/* Type:     REXX-Exec                                                */\n/* Author:   Norbert Haas, noaDatex.de                                */\n/* Date:     10.04.1999                                               */\n/*                                                                    */\n/* Description:                                                       */\n/* ------------                                                       */\n/* The purpose of this exec is to automatically open multiple ISPF    */\n/* split screens, under the control of a profile dataset, which       */\n/* determines how many and what screens are open, and in what order.  */\n/*                                                                    */\n/* The profile member, whose member name is AUTOMAT, is created in    */\n/* the ISPF profile library, and the applications to be called, are   */\n/* listed there.  This member is created during the first call,       */\n/* brought into the editor and can then be changed by the user.       */\n/* The AUTOMAT profile is newly created only during the first call.   */\n/*                                                                    */\n/* The ISPF profile name should be changed in this exec, to your own  */\n/* ISPF profile name, or name pattern.  See line 112.                 */\n/*                                                                    */\n/* Applications listed in the AUTOMAT profile are each called up in   */\n/* a separate split screen, but executing AUTOMAT itself, needs       */\n/* an initial ISPF screen, because AUTOMAT won't run unless ISPF is   */\n/* already up.  The first application started by AUTOMAT then comes   */\n/* up in the second ISPF screen, the second application in the 3rd    */\n/* screen, and so forth.                                              */\n/*                                                                    */\n/* If AUTOMAT is called with parameters B(rowse), V(iew) or E(dit),   */\n/* then the AUTOMAT profile member in the ISPF profile library (as    */\n/* hard-coded in this exec) is Browsed, Viewed, or Edited, so you     */\n/* can see, or change, how you want AUTOMAT to operate.               */\n/*                                                                    */\n/* I have added an option to call AUTOMAT with a parameter \"R\" for    */\n/* the REVIEW TSO command.  REVIEW (found on CBT Tape Files 134       */\n/* (source) and 135 (load modules)) can browse or edit datasets in    */\n/* TSO READY mode, or it can use ISPF if it is available.  REVIEW     */\n/* has an editing option, if you \"UPDATE\" the dataset being reviewed. */\n/* So you can use REVIEW to fix the profile dataset when ISPF is      */\n/* not up yet.  REVIEW is a very convenient recovery tool. (SBG)      */\n/*                                                                    */\n/* Remark:                                                            */\n/* ------                                                             */\n/* It might be useful to put the following command into the ISPF      */\n/* Command Table as specified below.  In this way, you can avoid      */\n/* having to press TSO before entering the command, AUTOMAT.          */\n/* You can check the results of executing AUTOMAT using the SWAP      */\n/* LIST ISPF command.                                                 */\n/*                                                                    */\n/*    Variable   Value                                                */\n/*    ---------- -------                                              */\n/*    ZCTVERB    AUTOMAT                                              */\n/*    ZCTTRUNC   4                                                    */\n/*    ZCTACT     SELECT CMD(%AUTOMAT &ZPARM) SUSPEND SCRNAME(AUTOMAT) */\n/*    ZCTDESC    Call the split-screen automation                     */\n/*                                                                    */\n/* If the automation is to be started from the Primary Option Menu as */\n/* a menu item, this can be done as follows (in the example, 'T' is   */\n/* the corresponding menu character):                                 */\n/*                                                                    */\n/* Part of the PROC section of the Primary Option Menu panel:         */\n/*                                                                    */\n/*    &ZSEL = TRANS ( TRUNC (&ZCMD,'.')                               */\n/*      0,'PGM(ISPISM) SCRNAME(SETTINGS)'                             */\n/*      1,'PGM(ISRBRO) PARM(ISRBRO01) SCRNAME(VIEW)'                  */\n/*      2,'PGM(ISREDIT) PARM(P,ISREDM01) SCRNAME(EDIT)'               */\n/*      3,'PANEL(ISRUTIL) SCRNAME(UTIL)'                              */\n/*      ...  (more lines)                                             */\n/*      T,'CMD(automat)'                                              */\n/*      X,EXIT                                                        */\n/*     ' ',' '                                                        */\n/*       *,'?' )                                                      */\n/*                                                                    */\n/* Adjustments                                                        */\n/* -----------                                                        */\n/* It is necessary to adjust the maximum number of split screens on   */\n/* line 110 and the DSN of the profile library on line 111.           */\n/*                                                                    */\n/* -------------------------------------------------------------------*/\n/* Version   Author      Date        Modification                     */\n/* --------- ----------- ----------- -------------------------------- */\n/* V01.02    N.Haas      19.12.2016  Translated into English          */\n/*                                   (powered by Google Translator)   */\n/*           S.Golob     26.12.2016  English fixed better.            */\n/*                                   Add support for REVIEW command   */\n/* V01.01    N.Haas      31.05.1999  Added SPLIT-Screen test          */\n/* V01.00    N.Haas      10.04.1999  Creation                         */\n/* ********************************************************************/\n/*                                                                    */\n/* Initialization --------------------------------------------------- */\n/* --------------                                                     */\n\n/* Get parameter (empty, B, V, or E, or R)  ------------------------- */\nPARSE UPPER ARG parm\nparm = LEFT(parm,1)\n\n\"ISPEXEC CONTROL ERRORS RETURN\"\nTRUE = 1                                                      /* True */\nFALSE = 0                                                    /* False */\nuserid = USERID()\ncmd_counter = 0\ncmd_lines. = ''\n\nmax_split = 8                 /* not greater than 8 */    /*  adjust  */\nautomat_dsn_mem = \"'\"userid\".TSOPROF(AUTOMAT)'\"           /*  adjust  */\n\nautomat_exists = SYSDSN(automat_dsn_mem)\n\n/* Does the AUTOMAT member exist in the ISPF profile library ? ------ */\nIF automat_exists /= 'OK' THEN DO\n   /* Create it, but if not.....   ---------------------------------- */\n   CALL Init_Default_Automat\n\n   /* Message ------------------------------------------------------- */\n   CALL Display_Message \"\",,\n       \"A sample profile member has been created. Please adapt\",\n       \"this member to your needs now. After customizing the member\",\n       \"and exiting the Edit, you can then restart AUTOMAT.\",,\n      \"ISRZ000\"\n\n   /* if you set a parm of \"E\", then you will call the Editor  ------ */\n   parm = 'E'\nEND\n\n/* Will a parameter be entered? ------------------------------------- */\nIF parm /= \"\" THEN DO        /* With Parameter ==> Browse, View, Edit */\n   SELECT\n      WHEN parm = \"B\" THEN DO                               /* BROWSE */\n         \"ISPEXEC BROWSE DATASET(\"automat_dsn_mem\")\"\n      END\n\n      WHEN parm = \"V\" THEN DO                                 /* VIEW */\n         \"ISPEXEC VIEW DATASET(\"automat_dsn_mem\")\"\n      END\n\n      WHEN parm = \"E\" THEN DO                                 /* EDIT */\n         \"ISPEXEC EDIT DATASET(\"automat_dsn_mem\")\"\n      END\n\n      WHEN parm = \"R\" THEN DO                               /* REVIEW */\n         \"REVIEW \"automat_dsn_mem\" \"\n      /*  The REVIEW TSO command is on the CBT Tape File 134.   */\n      /*  The REVIEW load modules are on the CBT Tape File 135. */\n      /*  REVIEW operates with or without ISPF, so you can use  */\n      /*  REVIEW's UPDATE parameter to edit the profile without */\n      /*  needing ISPF to be up.  AUTOMAT R works without ISPF. */\n      /*        CBT Tape address is:  www.cbttape.org           */\n      END\n\n      OTHERWISE DO\n         CALL Display_Message \"\",,\n             \"Bad Parameter -\",\n             \"AUTOMAT must start with parameter B(rowse), V(iew) or\",\n             \"E(dit), or R(eview), or without a parameter.\",,\n            \"ISRZ001\"\n      END\n   END\n   /* Cancel -------------------------------------------------------- */\n   SIGNAL Ende\nEND\nELSE DO            /* Wihout a parameter, AUTOMAT creates the splits. */\n   /* Are two SPLIT-Screens already active?-------------------------- */\n   \"ISPEXEC CONTROL SPLIT DISABLE\"\n   split_rc = rc\n   IF split_rc /= 0 THEN DO\n      CALL Display_Message \"\",,\n          \"Message - Split screens are already opened.\",\n          \"You cannot call AUTOMAT now if more than\",\n          \"one ISPF screen is open.\",,\n         \"ISRZ001\"\n       SIGNAL Ende\n   END\n   ELSE \"ISPEXEC CONTROL SPLIT ENABLE\"\nEND\n\n/* The member exists => Read and process all lines of it. ----------- */\n\"ALLOC FI(dd) DA(\"automat_dsn_mem\") SHR REUSE\"\n\"EXECIO * DISKR dd (FINIS STEM line.)\"\n\"FREE FI(dd)\"\n\n/* Put all the commands together. ----------------------------------- */\nDO i = 1 TO line.0\n   temp_pos = INDEX(line.i,'/*')                    /* Comment line ? */\n\n   IF temp_pos > 0 THEN DO                 /* Is the line a comment ? */\n      IF temp_pos = 1 THEN DO      /* Yes the whole line is a comment */\n         temp_cmd = ''\n      END\n      ELSE DO                  /* No. Just chop the comment at the end */\n         temp_cmd = STRIP(LEFT(line.i,temp_pos - 1))\n      END\n   END\n   ELSE DO                                       /* No comment there. */\n      temp_cmd = STRIP(line.i)\n   END\n\n   IF temp_cmd /= '' THEN DO               /* Then save that command. */\n      cmd_counter = cmd_counter + 1\n      cmd_lines.cmd_counter = temp_cmd\n   END\nEND\n\n/* More than max_splits - 1 ? --------------------------------------- */\nIF cmd_counter > max_split - 1 THEN DO\n      CALL Display_Message \"\",,\n         \"Too many commands specified in profile.\",\n         \"A maximum of\" max_split \"screens is possible.\",\n         \"AUTOMAT requires one initial ISPF screen\",\n         \"before starting up.\",\n         \"So please reduce the number of commands\",\n         \"in the profile, to a maximum of\",\n          max_split - 1\".\",,\n         \"ISRZ001\"\n\n   /* Call Edit to edit the profile dataset) ------------------------ */\n   \"ISPEXEC EDIT DATASET(\"automat_dsn_mem\")\"\n\n   /* Cancel -------------------------------------------------------- */\n   SIGNAL Ende\nEND\n\n/* Call the commands now  ------------------------------------------- */\nDO i = 1 TO cmd_counter\n   /* Get each command ... ------------------------------------------ */\n   tempcmd = cmd_lines.i\n\n   /* ... and process  ---------------------------------------------- */\n   CALL Aktivate_Command\nEND\n\n/* The first (current) screen will get the screen name TMP ------- */\ntempcmd = \"SCRNAME TMP PERM\"\n\"ISPEXEC DISPLAY COMMAND(tempcmd)\"\n\n/* Afterwards display a SWAP LIST ----------------------------------- */\ntempcmd = \"SWAP LIST\"\n\"ISPEXEC DISPLAY COMMAND(tempcmd)\"\n\n/* Ende ------------------------------------------------------------- */\nEnde:\nEXIT\n\n/* ================================================================== */\n/* ========================  Subroutines  =========================== */\n/* ================================================================== */\n\nAktivate_Command:\n   /* Add SWAP at the end and process ------------------------------- */\n   tempcmd = tempcmd\";SWAP\"\n   \"ISPEXEC SELECT PGM(ISPSTRT) PARM(\"tempcmd\")\"\nReturn\n\nInit_Default_Automat:\n   line.0 = 17\n\n   line.1 = \"/* --------------------------------------------------- */\"\n   line.2 = \"/* AUTOMAT PROFILE - Applications to be started...     */\"\n   line.3 = \"/* --------------------------------------------------- */\"\n   line.4 = \"/* Please note that AUTOMAT itself requires one ISPF   */\"\n   line.5 = \"/* screen to be opened first. This means that the next */\"\n   line.6 = \"/* application which will be opened by AUTOMAT, will   */\"\n   line.7 = \"/* start next.  That is, the first screen specified    */\"\n   line.8 = \"/* below will be the second split screen, and the next */\"\n   line.9 = \"/* one after that will be the 3rd split screen, etc.   */\"\n   line.10= \"/*                                                     */\"\n   line.11= \"/* Sample entries:                                     */\"\n   line.12= \"/* --------------------------------------------------- */\"\n   line.13= \"1; SCRNAME BRS                            /* 1.View    */\"\n   line.14= \"2; SCRNAME EDT                            /* 2.Editor  */\"\n   line.15= \"3.4                                       /* 3.DSLIST  */\"\n   line.16= \"TSO UPSEDIT N#C015.X1480.SRC; SCRNAME SRC /* 4.TSO-CMD */\"\n   line.17= \"SDSF; PREFIX <your userid>; OWNER *       /* 5.SDSF    */\"\n\n   \"ALLOC FI(dd) DA(\"automat_dsn_mem\") SHR REUSE\"\n   \"EXECIO\" line.0 \"DISKW dd (FINIS STEM line.)\"\n   \"FREE FI(dd)\"\nRETURN\n\nDisplay_Message:\n   PARSE ARG zedsmsg, zedlmsg, msgtype\n\n   \"ISPEXEC SETMSG MSG(\"msgtype\")\"\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BACKUP": {"ttr": 779, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x18\\x01\\x17\\x00_\\x01\\x17\\x00_\\t#\\x01S\\x01S\\x00\\x00\\xd5\\xd6\\xd9\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2017-01-05T00:00:00", "modifydate": "2017-01-05T09:23:18", "lines": 339, "newlines": 339, "modlines": 0, "user": "NORBERT"}, "text": "/* REXX ***************************************************************/\n/* -------------------------------------------------------------------*/\n/* Name:       BACKUP                                                 *//*HELP*/\n/* Short       Backup of a dataset                                    *//*HELP*/\n/* Type:       REXX-Exec                                              *//*HELP*/\n/* Author:     Norbert Haas, noaDatex.de                              *//*HELP*/\n/* Function:   Creates a backup copy of a dataset (PS/PO)             *//*HELP*/\n/* Input:      dataset                                                *//*HELP*/\n/* Output:     dataset.BACKUP                                         *//*HELP*/\n/* Syntax:     Used in 3.4                                            *//*HELP*/\n/*                                                                    */\n/* Version Author        Date       Why                               */\n/* ------- ------------- ---------- --------------------------------- */\n/* V02.03  N.Haas        15.04.2010 vonmem1 = / ==> Memberlistselect. */\n/* V02.02  N.Haas        14.04.2010 vonmem2/3 and bismem2/3           */\n/* V02.01  N.Haas        20.07.2009 small changes                     */\n/* V02.00  N.Haas        11.07.2005 English version and new option 3  */\n/* V01.00  N.Haas           03/2000 Creation                          */\n/**********************************************************************/\n\n/* Init --------------------------------------------------------------*/\nTRUE = 1\nFALSE = 0\n\nPARSE UPPER ARG dsn_alt\n\n/* CALL OK ? ---------------------------------------------------------*/\nIF dsn_alt = '' THEN DO\n   rc = DispMsg('Wrong Call',,\n                'This tool must be called from 3.4.',,\n                TRUE)\n   EXIT\nEND\n\n/* DSN with or without quotes? ---------------------------------------*/\ndsn_alt  = STRIP(dsn_alt,,\"'\")\ndsn_neu  = LEFT(dsn_alt || '.BACKUP',44)\ncursor   = 'ndsn'\ndummy    = LISTDSI(\"'\"dsn_alt\"'\")\nsyslrecl = syslrecl + 0\ninfo     = '('sysdsorg', 'syslrecl')'\ndatopt   = '1'\n\n/* Display Panel -----------------------------------------------------*/\n\"ISPEXEC ADDPOP\"\nadsn = dsn_alt\n\nDisplay:\nndsn = dsn_neu\n\"ISPEXEC DISPLAY PANEL(BACKUPP)\"\nIF rc = 8 THEN DO\n   rc = DispMsg('Canceled by user',,\n                'The BACKUP command has been canceled by the user.',,\n                FALSE)\n   EXIT\nEND\ndsn_neu = ndsn\n\n/* Option plus other input OK ? --------------------------------------*/\nIF datopt = 1 | datopt = 4 THEN DO\n   IF vonzeil1 /= '' | vonzeil2 /= '' | vonzeil3 /= '' |,\n      biszeil1 /= '' | biszeil2 /= '' | biszeil3 /= '' |,\n      vonmem1  /= '' | vonmem2  /= '' | vonmem3  /= '' |,\n      bismem1  /= '' | bismem2  /= '' | bismem3  /= ''     THEN DO\n      rc = DispMsg('Wrong input',,\n                   'If option' datopt 'was used, any other input must',\n                   'be left empty.',,\n                   TRUE)\n      cursor = 'datopt'\n      SIGNAL Display\n   END\nEND\n\nIF datopt = 2 THEN DO\n   IF vonzeil1 = \"\" | biszeil1 = \"\" THEN DO\n      rc = DispMsg('Wrong input',,\n                   'If option 2 is used, \"from line\"',\n                   'and \"to line\" must be entered.',,\n                   TRUE)\n      cursor = 'vonzeil1'\n      SIGNAL Display\n   END\nEND\n\nIF datopt = 3 THEN DO\n   IF vonmem = \"\" | bismem = \"\" THEN DO\n      rc = DispMsg('Wrong input',,\n                   'If option 3 is used, \"from member\"',\n                   'and \"to member\" must be entered.',,\n                   TRUE)\n      cursor = 'vonmem'\n      SIGNAL Display\n   END\nEND\n\n/* New dsn alredy exists? --------------------------------------------*/\nIF SYSDSN(\"'\"dsn_neu\"'\") = 'OK' THEN DO\n   rc = DispMsg('DSN new already exists',,\n                'The new dataset' dsn_neu 'does already exist.',,\n                TRUE)\n   SIGNAL Display\nEND\n\n/* Remove Panel ------------------------------------------------------*/\n\"ISPEXEC REMPOP\"\ndsn_alt = \"'\"dsn_alt\"'\"\ndsn_neu = \"'\"dsn_neu\"'\"\n\n/* Alloc new dataset -------------------------------------------------*/\n/*<\"ALLOC NEW DATASET(\"dsn_neu\") LIKE(\"dsn_alt\") MGMTCLAS(TESTSTD)\",  */\n/*         \"STORCLAS(STANDARD)\"                                       */\n\"ALLOC NEW DATASET(\"dsn_neu\") LIKE(\"dsn_alt\")\"\nalloc_rc = rc\nIF alloc_rc > 0 THEN DO\n   SAY 'ALLOC, RC =' rc\nEND\n\n/* Copy --------------------------------------------------------------*/\nIF datopt = 1 THEN DO                           /* Alloc and copy all */\n   IF sysdsorg = 'PO' THEN DO\n      member = ''\n      \"ISPEXEC LMINIT DATAID(dataid1) DATASET(\"dsn_alt\") ENQ(SHR)\"\n      \"ISPEXEC LMINIT DATAID(dataid2) DATASET(\"dsn_neu\") ENQ(SHRW)\"\n\n      \"ISPEXEC LMOPEN DATAID(\"dataid1\") OPTION(INPUT)\"\n\n      \"ISPEXEC LMMLIST DATAID(\"dataid1\") OPTION(LIST) MEMBER(member)\"\n\n      DO WHILE rc = 0\n         \"ISPEXEC LMCOPY FROMID(\"dataid1\") FROMMEM(\"member\")\",\n                        \"TODATAID(\"dataid2\") TOMEM(\"member\")\",\n                        \"REPLACE\"\n         lmcopy_rc = rc\n         IF lmcopy_rc > 0 THEN DO\n            SAY 'LMCOPY, RC =' rc\n         END\n         \"ISPEXEC LMMLIST DATAID(\"dataid1\") OPTION(LIST) MEMBER(member)\"\n      END\n\n      \"ISPEXEC LMCLOSE DATAID(\"dataid1\")\"\n\n      \"ISPEXEC LMFREE DATAID(\"dataid2\")\"\n      \"ISPEXEC LMFREE DATAID(\"dataid1\")\"\n   END\n   ELSE DO\n      IF sysdsorg = 'PS' THEN DO\n         \"ALLOC DD(SYSUT1)   DSN(\"dsn_alt\") SHR REUSE\"\n         \"ALLOC DD(SYSUT2)   DSN(\"dsn_neu\") OLD REUSE\"\n         \"ALLOC DD(SYSIN)    DUMMY REUSE\"\n         \"ALLOC DD(SYSPRINT) DUMMY REUSE\"\n\n         \"ISPEXEC SELECT PGM(IEBGENER)\"\n         iebgener_rc = rc\n         IF iebgener_rc > 0 THEN DO\n            SAY 'IEBGENER, RC =' rc\n         END\n\n         \"FREE DD(SYSPRINT)\"\n         \"FREE DD(SYSIN)\"\n         \"FREE DD(SYSUT2)\"\n         \"FREE DD(SYSUT1)\"\n      END\n      ELSE DO\n         rc = DispMsg('Wrong DSORG',,\n                 'DSORG of dataset' dsn_alt 'is neither PO nor PS',\n                 'BACKUP provides only PS and PO datasets.',,\n                      TRUE)\n         CALL Delete_Again dsn_neu\n         EXIT\n      END\n   END\nEND\n\nIF datopt = 3 THEN DO                        /* Alloc and copy member */\n   IF sysdsorg = 'PO' THEN DO\n      IF vonmem1 = \"/\" THEN DO\n         msg = '*COPIED*'\n         zedsmsg = ''\n         zedlmsg = 'Please select (S) member to be copied.'\n         \"ISPEXEC SETMSG MSG(ISRZ000)\"\n\n         \"ISPEXEC LMINIT DATAID(dataid1) DATASET(\"dsn_alt\") ENQ(SHR)\"\n         \"ISPEXEC LMINIT DATAID(dataid2) DATASET(\"dsn_neu\") ENQ(SHRW)\"\n\n         \"ISPEXEC LMOPEN DATAID(\"dataid1\") OPTION(INPUT)\"\n\n         \"ISPEXEC LMMDISP DATAID(\"dataid1\") OPTION(DISPLAY)\"\n\n         DO WHILE rc = 0\n            \"ISPEXEC LMCOPY FROMID(\"dataid1\") FROMMEM(\"zlmember\")\",\n                           \"TODATAID(\"dataid2\") TOMEM(\"zlmember\")\",\n                           \"REPLACE\"\n            lmcopy_rc = rc\n            IF lmcopy_rc > 0 THEN DO\n               SAY 'LMCOPY, RC =' rc\n            END\n\n            \"ISPEXEC LMMDISP DATAID(\"dataid1\") OPTION(PUT)\",\n                                              \"MEMBER(\"zlmember\")\",\n                                              \"ZLUDATA(\"msg\")\"\n            \"ISPEXEC CONTROL NONDISPL ENTER\"\n            \"ISPEXEC LMMDISP DATAID(\"dataid1\") OPTION(DISPLAY)\"\n         END\n\n         \"ISPEXEC LMCLOSE DATAID(\"dataid1\")\"\n\n         \"ISPEXEC LMFREE DATAID(\"dataid2\")\"\n         \"ISPEXEC LMFREE DATAID(\"dataid1\")\"\n      END\n      ELSE DO\n         member = ''\n         \"ISPEXEC LMINIT DATAID(dataid1) DATASET(\"dsn_alt\") ENQ(SHR)\"\n         \"ISPEXEC LMINIT DATAID(dataid2) DATASET(\"dsn_neu\") ENQ(SHRW)\"\n\n         \"ISPEXEC LMOPEN DATAID(\"dataid1\") OPTION(INPUT)\"\n\n         \"ISPEXEC LMMLIST DATAID(\"dataid1\") OPTION(LIST) MEMBER(member)\"\n\n         DO WHILE rc = 0\n            IF (member >= vonmem1 & member <= bismem1) |,\n               (member >= vonmem2 & member <= bismem2) |,\n               (member >= vonmem3 & member <= bismem3) THEN DO\n               \"ISPEXEC LMCOPY FROMID(\"dataid1\") FROMMEM(\"member\")\",\n                              \"TODATAID(\"dataid2\") TOMEM(\"member\")\",\n                              \"REPLACE\"\n               lmcopy_rc = rc\n               IF lmcopy_rc > 0 THEN DO\n                  SAY 'LMCOPY, RC =' rc\n               END\n            END\n            \"ISPEXEC LMMLIST DATAID(\"dataid1\") OPTION(LIST) MEMBER(member)\"\n         END\n\n         \"ISPEXEC LMCLOSE DATAID(\"dataid1\")\"\n\n         \"ISPEXEC LMFREE DATAID(\"dataid2\")\"\n         \"ISPEXEC LMFREE DATAID(\"dataid1\")\"\n      END\n   END\n   ELSE DO\n      rc = DispMsg('Wrong DSORG',,\n                  'With option 3 the DSORG must be PO.',,\n                   TRUE)\n      CALL Delete_Again dsn_neu\n      EXIT\n   END\nEND\n\nIF datopt = 2 THEN DO                         /* Alloc and copy lines */\n   IF sysdsorg = 'PS' THEN DO\n      /* 1 */\n      anzahl_zeilen = biszeil1 - vonzeil1 + 1\n      \"ALLOC DD(di) DSN(\"dsn_alt\") SHR REUSE\"\n      \"EXECIO\" anzahl_zeilen \"DISKR di\" vonzeil1 \"(FINIS STEM line.)\"\n      execio_rc = rc\n      \"FREE DD(di)\"\n      IF execio_rc /= 0 THEN DO\n         rc = DispMsg('To less memory',,\n                      'The virtual memory is to low to read the',\n                      'selected number of lines.',,\n                      TRUE)\n         CALL Delete_Again dsn_neu\n         EXIT\n      END\n      \"ALLOC DD(do) DSN(\"dsn_neu\") SHR REUSE\"\n      \"EXECIO\" anzahl_zeilen \"DISKW do (FINIS STEM line.)\"\n      \"FREE DD(do)\"\n      /* 2 */\n      IF vonzeil2 /= \"\" & biszeil2 /= \"\" THEN DO\n         anzahl_zeilen = biszeil2 - vonzeil2 + 1\n         \"ALLOC DD(di) DSN(\"dsn_alt\") SHR REUSE\"\n         \"EXECIO\" anzahl_zeilen \"DISKR di\" vonzeil2 \"(FINIS STEM line.)\"\n         execio_rc = rc\n         \"FREE DD(di)\"\n         IF execio_rc /= 0 THEN DO\n            rc = DispMsg('To less memory',,\n                         'The virtual memory is to low to read the',\n                         'selected number of lines.',,\n                         TRUE)\n            CALL Delete_Again dsn_neu\n            EXIT\n         END\n         \"ALLOC DD(do) DSN(\"dsn_neu\") MOD REUSE\"\n         \"EXECIO\" anzahl_zeilen \"DISKW do (FINIS STEM line.)\"\n         \"FREE DD(do)\"\n      END\n      /* 3 */\n      IF vonzeil3 /= \"\" & biszeil3 /= \"\" THEN DO\n         anzahl_zeilen = biszeil3 - vonzeil3 + 1\n         \"ALLOC DD(di) DSN(\"dsn_alt\") SHR REUSE\"\n         \"EXECIO\" anzahl_zeilen \"DISKR di\" vonzeil3 \"(FINIS STEM line.)\"\n         execio_rc = rc\n         \"FREE DD(di)\"\n         IF execio_rc /= 0 THEN DO\n            rc = DispMsg('To less memory',,\n                         'The virtual memory is to low to read the',\n                         'selected number of lines.',,\n                         TRUE)\n            CALL Delete_Again dsn_neu\n            EXIT\n         END\n         \"ALLOC DD(do) DSN(\"dsn_neu\") MOD REUSE\"\n         \"EXECIO\" anzahl_zeilen \"DISKW do (FINIS STEM line.)\"\n         \"FREE DD(do)\"\n      END\n   END\n   ELSE DO\n      rc = DispMsg('Wrong DSORG',,\n                  'With option 2 the DSORG must be PS.',,\n                   TRUE)\n      CALL Delete_Again dsn_neu\n      EXIT\n   END\nEND\n\n/* ... and bye bye ---------------------------------------------------*/\n\"FREE DATASET(\"dsn_neu\")\"\nEXIT\n\n/* ================================================================== */\n\nDelete_Again: PROCEDURE\n   PARSE ARG dsn_del\n   dummy = MSG('OFF')\n   \"DELETE\" dsn_del\n   dummy = MSG('ON')\nRETURN\n\nDispMsg: PROCEDURE\n   PARSE ARG zedsmsg, zedlmsg, beep\n\n   /* Beep ? */\n   IF beep THEN\n      msg = 'ISRZ001'\n   ELSE\n      msg = 'ISRZ000'\n\n   \"ISPEXEC SETMSG MSG(\"msg\")\"\nRETURN 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BACKUPH0": {"ttr": 1028, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00Q\\x01\\x165O\\x01\\x165O\\x127\\x00%\\x00$\\x00\\x00\\xd5\\xd6\\xd9\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2016-12-19T00:00:00", "modifydate": "2016-12-19T12:37:51", "lines": 37, "newlines": 36, "modlines": 0, "user": "NORBERT"}, "text": ")PANEL KEYLIST(ISRSNAB,ISR)\n)ATTR DEFAULT(%+_)\n   % TYPE(ET)                                      /* Emphasized Text */\n   + TYPE(NT)                                          /* Normal Text */\n   _ TYPE(NEF)                                  /* Normal Entry Field */\n   ] AREA(SCRL) EXTEND(ON)                              /* Scrollarea */\n)BODY WINDOW(50,15)\n]SAREA39                                         ]\n)AREA SAREA39\n+                                                +\n+The%BACKUP+procedure copies a dataset under your+\n+control (backup copy).                          +\n+                                                +\n+The source dataset will not be changed| The name+\n+of the target dataset will be%'xxx.BACKUP'.     +\n+                                                +\n+You have four options to copy (with all these   +\n+options the target dataset will be allocated):  +\n+                                                +\n%1+Copy the whole content. This option copies all+\n+lines of a PS dataset or all member of a PO     +\n+dataset into the target dataset.                +\n+                                                +\n%2+Copy only selected lines of a PS dataset into +\n+the target dataset.                             +\n+                                                +\n%3+Copy only selected member of a PO dataset into+\n+the target dataset. Enter%/+to see member list  +\n+panel.                                          +\n+                                                +\n%3+Allocate the dataset only, no copy.           +\n+                                                +\n+                                                +\n+                                                +\n)INIT\n &ZWINTTL = ' Help '\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "BACKUPH1": {"ttr": 1030, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00X\\x01\\x17\\x00/\\x01\\x17\\x00/\\x10\\x07\\x00\\x11\\x00\\x11\\x00\\x00\\xd5\\xd6\\xd9\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2017-01-02T00:00:00", "modifydate": "2017-01-02T10:07:58", "lines": 17, "newlines": 17, "modlines": 0, "user": "NORBERT"}, "text": ")PANEL KEYLIST(ISRSNAB,ISR)\n)ATTR DEFAULT(%+_)\n   % TYPE(ET)                                      /* Emphasized Text */\n   + TYPE(NT)                                          /* Normal Text */\n   _ TYPE(NEF)                                  /* Normal Entry Field */\n   ] AREA(SCRL) EXTEND(ON)                              /* Scrollarea */\n)BODY WINDOW(50,7)\n]SAREA39                                         ]\n)AREA SAREA39\n+                                                +\n%DSN (old)+is the source dataset you want to copy+\n+into the target dataset.                        +\n+                                                +\n+                                                +\n)INIT\n &ZWINTTL = ' Help '\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "BACKUPH2": {"ttr": 1032, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x007\\x01\\x165O\\x01\\x165O\\x125\\x00\\x13\\x00\\x13\\x00\\x00\\xd5\\xd6\\xd9\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-12-19T00:00:00", "modifydate": "2016-12-19T12:35:37", "lines": 19, "newlines": 19, "modlines": 0, "user": "NORBERT"}, "text": ")PANEL KEYLIST(ISRSNAB,ISR)\n)ATTR DEFAULT(%+_)\n   % TYPE(ET)                                      /* Emphasized Text */\n   + TYPE(NT)                                          /* Normal Text */\n   _ TYPE(NEF)                                  /* Normal Entry Field */\n   ] AREA(SCRL) EXTEND(ON)                              /* Scrollarea */\n)BODY WINDOW(50,9)\n]SAREA39                                         ]\n)AREA SAREA39\n+                                                +\n%DSN (new)+is the target dataset you want to copy+\n+into. The name of the target dataset will be    +\n+'xxx.BACKUP'.                                   +\n+                                                +\n+                                                +\n+                                                +\n)INIT\n &ZWINTTL = ' Help '\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "BACKUPH3": {"ttr": 1034, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00A\\x01\\x17\\x00_\\x01\\x17\\x00_\\t\\x10\\x00 \\x00 \\x00\\x00\\xd5\\xd6\\xd9\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2017-01-05T00:00:00", "modifydate": "2017-01-05T09:10:41", "lines": 32, "newlines": 32, "modlines": 0, "user": "NORBERT"}, "text": ")PANEL KEYLIST(ISRSNAB,ISR)\n)ATTR DEFAULT(%+_)\n   % TYPE(ET)                                      /* Emphasized Text */\n   + TYPE(NT)                                          /* Normal Text */\n   _ TYPE(NEF)                                  /* Normal Entry Field */\n   ] AREA(SCRL) EXTEND(ON)                              /* Scrollarea */\n)BODY WINDOW(50,15)\n]SAREA39                                         ]\n)AREA SAREA39\n+                                                +\n+Please select%option+1 to 4.                    +\n+                                                +\n+With all these options the target dataset will  +\n+be allocated:                                   +\n+                                                +\n%1+Copy the whole content. This option copies all+\n+lines of a PS dataset or all member of a PO     +\n+dataset into the target dataset.                +\n+                                                +\n%2+Copy only selected lines of a PS dataset into +\n+the target dataset.                             +\n+                                                +\n%3+Copy only selected member of a PO dataset into+\n+the target dataset. Enter%/+to see member list  +\n+panel.                                          +\n+                                                +\n%4+Allocate the dataset only, no copy.           +\n+                                                +\n+                                                +\n)INIT\n &ZWINTTL = ' Help '\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "BACKUPH4": {"ttr": 1036, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00X\\x01\\x17\\x00/\\x01\\x17\\x00/\\x10\\x07\\x00\\x14\\x00\\x14\\x00\\x00\\xd5\\xd6\\xd9\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2017-01-02T00:00:00", "modifydate": "2017-01-02T10:07:58", "lines": 20, "newlines": 20, "modlines": 0, "user": "NORBERT"}, "text": ")PANEL KEYLIST(ISRSNAB,ISR)\n)ATTR DEFAULT(%+_)\n   % TYPE(ET)                                      /* Emphasized Text */\n   + TYPE(NT)                                          /* Normal Text */\n   _ TYPE(NEF)                                  /* Normal Entry Field */\n   ] AREA(SCRL) EXTEND(ON)                              /* Scrollarea */\n)BODY WINDOW(50,10)\n]SAREA39                                         ]\n)AREA SAREA39\n+                                                +\n%From line+is the first line of those lines that +\n+shall be copied. Only numbers must be entered.  +\n+You may select a maximum of three groups of     +\n+lines. Only available with option 2.            +\n+                                                +\n+                                                +\n+                                                +\n)INIT\n &ZWINTTL = ' Help '\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "BACKUPH5": {"ttr": 1038, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00X\\x01\\x17\\x00/\\x01\\x17\\x00/\\x10\\x07\\x00\\x14\\x00\\x14\\x00\\x00\\xd5\\xd6\\xd9\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2017-01-02T00:00:00", "modifydate": "2017-01-02T10:07:58", "lines": 20, "newlines": 20, "modlines": 0, "user": "NORBERT"}, "text": ")PANEL KEYLIST(ISRSNAB,ISR)\n)ATTR DEFAULT(%+_)\n   % TYPE(ET)                                      /* Emphasized Text */\n   + TYPE(NT)                                          /* Normal Text */\n   _ TYPE(NEF)                                  /* Normal Entry Field */\n   ] AREA(SCRL) EXTEND(ON)                              /* Scrollarea */\n)BODY WINDOW(50,10)\n]SAREA39                                         ]\n)AREA SAREA39\n+                                                +\n%To line+is the last line of those lines that    +\n+shall be copied. Only numbers must be entered.  +\n+You may select a maximum of three groups of     +\n+lines. Only available with option 2.            +\n+                                                +\n+                                                +\n+                                                +\n)INIT\n &ZWINTTL = ' Help '\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "BACKUPH6": {"ttr": 1040, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x13\\x01\\x165O\\x01\\x165O\\x127\\x00\\x13\\x00\\x13\\x00\\x00\\xd5\\xd6\\xd9\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-12-19T00:00:00", "modifydate": "2016-12-19T12:37:13", "lines": 19, "newlines": 19, "modlines": 0, "user": "NORBERT"}, "text": ")PANEL KEYLIST(ISRSNAB,ISR)\n)ATTR DEFAULT(%+_)\n   % TYPE(ET)                                      /* Emphasized Text */\n   + TYPE(NT)                                          /* Normal Text */\n   _ TYPE(NEF)                                  /* Normal Entry Field */\n   ] AREA(SCRL) EXTEND(ON)                              /* Scrollarea */\n)BODY WINDOW(50,9)\n]SAREA39                                         ]\n)AREA SAREA39\n+                                                +\n%From member+is the first member name of all the +\n+members that shall be copied. Only available    +\n+with option 3. Enter%/+to see member list panel.+\n+                                                +\n+                                                +\n+                                                +\n)INIT\n &ZWINTTL = ' Help '\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "BACKUPH7": {"ttr": 1042, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00X\\x01\\x17\\x00/\\x01\\x17\\x00/\\x10\\x07\\x00\\x13\\x00\\x13\\x00\\x00\\xd5\\xd6\\xd9\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2017-01-02T00:00:00", "modifydate": "2017-01-02T10:07:58", "lines": 19, "newlines": 19, "modlines": 0, "user": "NORBERT"}, "text": ")PANEL KEYLIST(ISRSNAB,ISR)\n)ATTR DEFAULT(%+_)\n   % TYPE(ET)                                      /* Emphasized Text */\n   + TYPE(NT)                                          /* Normal Text */\n   _ TYPE(NEF)                                  /* Normal Entry Field */\n   ] AREA(SCRL) EXTEND(ON)                              /* Scrollarea */\n)BODY WINDOW(50,9)\n]SAREA39                                         ]\n)AREA SAREA39\n+                                                +\n%To member+is the last member name of all the    +\n+members that shall be copied. Only available    +\n+with option 3.                                  +\n+                                                +\n+                                                +\n+                                                +\n)INIT\n &ZWINTTL = ' Help '\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "BACKUPP": {"ttr": 1044, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00$\\x01\\x10\\x10O\\x01\\x10\\x10o\\x07)\\x00^\\x00Y\\x00\\x00\\xd5\\xd6\\xd9\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2010-04-14T00:00:00", "modifydate": "2010-04-16T07:29:24", "lines": 94, "newlines": 89, "modlines": 0, "user": "NORBERT"}, "text": ")PANEL KEYLIST(ISRSNAB,ISR)\n)ATTR DEFAULT(%+_)\n   % TYPE(ET)                                      /* Emphasized Text */\n   + TYPE(NT)                                          /* Normal Text */\n   _ TYPE(NEF) CAPS(ON)                         /* Normal Entry Field */\n   ! TYPE(VOI)                         /* Variable Output Information */\n   \u00d6 TYPE(OUTPUT) COLOR(RED) CAPS(OFF) JUST(ASIS)     /* Warning Text */\n   \u00e4 TYPE(TEXT) COLOR(RED)\n   \u00dd TYPE(TEXT) COLOR(YELLOW)\n   $ TYPE(FP)                                         /* Field Prompt */\n   < TYPE(CEF) PADC(USER)\n   \u00a2 TYPE(SAC)\n   \u00fc TYPE(TEXT) SKIP(ON)\n   ] AREA(SCRL) EXTEND(ON)                              /* Scrollarea */\n)BODY WINDOW(76,22)\n+\n$Command ===>_ZCMD                                            +\n]SCROLLI                                                                   ]\n)AREA SCROLLI\n$DSN (old) . . .:!adsn                                        +!info\n+\n$DSN (new) . . . _ndsn                                        +\n+                 ----:----1----:----2----:----3----:----4----\n+\n$Option  . . . <Z+\u00a21. Create and copy the whole content+\n+                 \u00a22. Create and copy the following lines:\u00e4(*)+\n+      $from line . ._vonzeil1+         $to line . ._biszeil1+\n+  $and from line . ._vonzeil2+         $to line . ._biszeil2+\n+  $and from line . ._vonzeil3+         $to line . ._biszeil3+\n+                 \u00a23. Create and copy the following members:\u00dd(*)+\n+      $from member ._vonmem1 +%(/=Sel)+$to member ._bismem1 +\n+  $and from member ._vonmem2 +         $to member ._bismem2 +\n+  $and from member ._vonmem3 +         $to member ._bismem3 +\n+                 \u00a24. Create only+\n+\n+                \u00e4(*)%Only available with PS-Datasets+\n+                \u00dd(*)%Only available with PO-Datasets+\n+\n+\n+\n)INIT\n  .ZVARS   = '(datopt)'\n  .cursor  = &cursor\n  .help    = 'BACKUPH0'\n  &zwinttl = 'BACKUP'\n)PROC\n  VER(&datopt,NB)\n  VER(&datopt,LIST,1,2,3,4)\n  IF(&vonzeil1 NE &Z)\n     VER(&vonzeil1,NUM)\n     IF(&biszeil1 EQ &Z) &biszeil1=&vonzeil1\n     IF(&vonzeil1 GT &biszeil1)\n        &temp = &vonzeil1\n        &vonzeil1 = &biszeil1\n        &biszeil1 = &temp\n  IF(&vonzeil2 NE &Z)\n     VER(&vonzeil2,NUM)\n     IF(&biszeil2 EQ &Z) &biszeil2=&vonzeil2\n     IF(&vonzeil2 GT &biszeil2)\n        &temp = &vonzeil2\n        &vonzeil2 = &biszeil2\n        &biszeil2 = &temp\n  IF(&vonzeil3 NE &Z)\n     VER(&vonzeil3,NUM)\n     IF(&biszeil3 EQ &Z) &biszeil3=&vonzeil3\n     IF(&vonzeil3 GT &biszeil3)\n        &temp = &vonzeil3\n        &vonzeil3 = &biszeil3\n        &biszeil3 = &temp\n  IF(&vonmem1 NE /)\n     IF(&vonmem1 NE &Z)\n        IF(&bismem1 EQ &Z) &bismem1=&vonmem1\n     IF(&vonmem2 NE &Z)\n        IF(&bismem2 EQ &Z) &bismem2=&vonmem2\n     IF(&vonmem3 NE &Z)\n        IF(&bismem3 EQ &Z) &bismem3=&vonmem3\n  &zwinttl = ''\n)HELP\n   FIELD (adsn)     PANEL (BACKUPH1)\n   FIELD (ndsn)     PANEL (BACKUPH2)\n   FIELD (datopt)   PANEL (BACKUPH3)\n   FIELD (vonzeil1) PANEL (BACKUPH4)\n   FIELD (vonzeil2) PANEL (BACKUPH4)\n   FIELD (vonzeil3) PANEL (BACKUPH4)\n   FIELD (biszeil1) PANEL (BACKUPH5)\n   FIELD (biszeil2) PANEL (BACKUPH5)\n   FIELD (biszeil3) PANEL (BACKUPH5)\n   FIELD (vonmem1)  PANEL (BACKUPH6)\n   FIELD (bismem1)  PANEL (BACKUPH7)\n   FIELD (vonmem2)  PANEL (BACKUPH6)\n   FIELD (bismem2)  PANEL (BACKUPH7)\n   FIELD (vonmem3)  PANEL (BACKUPH6)\n   FIELD (bismem3)  PANEL (BACKUPH7)\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "BIG": {"ttr": 1047, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x18\\x01\\x17\\x00_\\x01\\x17\\x00_\\t#\\x00\\xb1\\x00\\xb1\\x00\\x00\\xd5\\xd6\\xd9\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2017-01-05T00:00:00", "modifydate": "2017-01-05T09:23:18", "lines": 177, "newlines": 177, "modlines": 0, "user": "NORBERT"}, "text": "/* REXX ***************************************************************/\n/* -------------------------------------------------------------------*/\n/* Name:       BIG                                                    */\n/* Short:      Creates Capital Letters (7 lines)                      */\n/* Type:       REXX-Macro                                             */\n/* Author:     Norbert Haas, noaDatex.de                              */\n/* Syntax:     BIG text (primnary command)                            */\n/*             a/b (line command)                                     */\n/* Requires:   Function KONKAT                                        */\n/* Parameter:  text = String (max 10 chars, without Blanks)           */\n/* Chars:      A B C D E F G H I J K L M N O P Q R S T U V W X Y Z    */\n/*             0 1 2 3 4 5 6 7 8 9                                    */\n/*             ! $ % & / ( ) = + * - . : # , ; _ ?                    */\n/* Example:    BIG 'upro'                                             */\n/*             BIG here                                               */\n/*                                                                    */\n/* EEEEEEE X     X  AAAAA  M     M PPPPPP  L       EEEEEEE            */\n/* E        X   X  A     A MM   MM P     P L       E                  */\n/* E         X X   A     A M M M M P     P L       E                  */\n/* EEEEEE     X    A     A M  M  M PPPPPP  L       EEEEEE             */\n/* E         X X   AAAAAAA M     M P       L       E                  */\n/* E        X   X  A     A M     M P       L       E                  */\n/* EEEEEEE X     X A     A M     M P       LLLLLLL EEEEEEE            */\n/*                                                                    */\n/* Remarks:    none                                                   */\n/*                                                                    */\n/* Version   Autor         Datum     Anlass                           */\n/* --------- ------------- --------- -------------------------------- */\n/* V01.02    N.Haas        28.05.03  remarks in english               */\n/* V01.01    N.Haas        06.02.03  | ersetzt durch KONKAT()         */\n/* V01.00    N.Haas        15.06.92  Erstellung                       */\n/**********************************************************************/\n\"ISREDIT MACRO (parm) NOPROCESS\"\n\"ISPEXEC CONTROL ERRORS RETURN\"\n\n/* translate parm to caps ------------------------------------------- */\nparm = TRANSLATE(parm)\n\n/* parameter exists? ------------------------------------------------ */\nIF parm = '' THEN DO\n   zedsmsg = 'PARAMETER MISSING'\n   zedlmsg = 'MACRO BIG NEEDS AT LEAST ONE CHARACTER TO WORK WITH.'\n   \"ISPEXEC SETMSG MSG(ISRZ001)\"\n   EXIT -8\nEND\n\n/* parameter ok ? --------------------------------------------------- */\nparm = STRIP(parm,,\"'\")\nmaxlen = 10\nlen = LENGTH(parm)\nIF len > maxlen THEN DO\n   zedsmsg = 'PARAMETER TO LONG'\n   zedlmsg = 'PARAMETER IS NOT ALLOWED TO BE LONGER THAN 10 CHARS.'\n   \"ISPEXEC SETMSG MSG(ISRZ001)\"\n   EXIT -8\nEND\n\n/* linecommand A or B exists? --------------------------------------- */\n\"ISREDIT PROCESS DEST\"\nIF rc > 0 THEN DO\n   zedsmsg = 'BIG PENDING'\n   zedlmsg = 'AN \"A\" or \"B\" LINE COMMAND HAS NOT BEEN',\n             'SPECIFIED.'\n   \"ISPEXEC SETMSG MSG(ISRZ001)\"\n   EXIT -8\nEND\n\n/* destination ..................------------------------------------ */\n\"ISREDIT (line) = LINENUM .ZDEST\"\n\n/* init chars ------------------------------------------------------- */\nCALL Define\n\n/* distribute ------------------------------------------------------- */\nDO i = 1 TO len\n   found = 0\n   DO j = 1 to a.0 WHILE (found = 0)\n      IF SUBSTR(a.j,1,1) = SUBSTR(parm,i,1) THEN DO\n         DO k = 1 to 7\n/*          b.k = b.k || SUBSTR(a.j,3+(k-1)*7,7) || ' '               */\n            b.k = KONKAT(b.k, SUBSTR(a.j,3+(k-1)*7,7), ' ')\n         END\n         found = 1\n      END\n   END\n   IF found = 0 THEN DO\n      zedsmsg = 'PARAMETER WRONG'\n      zedlmsg = 'AT LEAST ONE CHARACTER IS WRONG.'\n      \"ISPEXEC SETMSG MSG(ISRZ001)\"\n      EXIT -8\n   END\nEND\n\n/* write chars ------------------------------------------------------ */\ncntr = 0\nDO i = 1 to 7\n   zeile = b.i\n   \"ISREDIT LINE_AFTER\" line \"= (zeile)\"\n   cntr = cntr + 1\n   line = line + 1\nEND\n\n/* message ---------------------------------------------------------- */\nzedsmsg = \"BIG FINISHED\"\nzedlmsg = \"CHARS '\"parm\"' ADDED INTO DATA.\"\n\"ISPEXEC SETMSG MSG(ISRZ000)\"\n\nEXIT 0\n\n/* ================================================================== */\n\n/* init chars ------------------------------------------------------- */\nDefine:\n   a.0 =54\n   a.1 ='A! AAAAA A     AA     AA     AAAAAAAAA     AA     A'\n   a.2 ='B!BBBBBB B     BB     BBBBBBB B     BB     BBBBBBB '\n   a.3 ='C! CCCCC C     CC      C      C      C     C CCCCC '\n   a.4 ='D!DDDDDD D     DD     DD     DD     DD     DDDDDDD '\n   a.5 ='E!EEEEEEEE      E      EEEEEE E      E      EEEEEEE'\n   a.6 ='F!FFFFFFFF      F      FFFFFF F      F      F      '\n   a.7 ='G! GGGGG G     GG      GGGGGGGG     GG     G GGGGG '\n   a.8 ='H!H     HH     HH     HHHHHHHHH     HH     HH     H'\n   a.9 ='I! IIIII    I      I      I      I      I    IIIII '\n   a.10='J!JJJJJJ      J      J      J      J      J  JJJJ  '\n   a.11='K!K    K K   K  K  K   KKK    K  K   K   K  K    K '\n   a.12='L!L      L      L      L      L      L      LLLLLLL'\n   a.13='M!M     MMM   MMM M M MM  M  MM     MM     MM     M'\n   a.14='N!N     NNN    NN N   NN  N  NN   N NN    NNN     N'\n   a.15='O! OOOOO O     OO     OO     OO     OO     O OOOOO '\n   a.16='P!PPPPPP P     PP     PPPPPPP P      P      P      '\n   a.17='Q! QQQQQ Q     QQ     QQ     QQ   Q QQ    QQ QQQQQQ'\n   a.18='R!RRRRRR R     RR     RRRRRRR R   R  R    R R     R'\n   a.19='S! SSSSS S     SS       SSSSS       SS     S SSSSS '\n   a.20='T!TTTTTTT   T      T      T      T      T      T   '\n   a.21='U!U     UU     UU     UU     UU     UU     U UUUUU '\n   a.22='V!V     VV     VV     VV     V V   V   V V     V   '\n   a.23='W!W     WW     WW     WW  W  WW W W WWW   WWW     W'\n   a.24='X!X     X X   X   X X     X     X X   X   X X     X'\n   a.25='Y!Y     YY     Y Y   Y   Y Y     Y      Y      Y   '\n   a.26='Z!ZZZZZZZ     Z     Z     Z     Z     Z     ZZZZZZZ'\n   a.27='0! 00000 0    000   0 00  0  00 0   000    0 00000 '\n   a.28='1!   1     11    1 1      1      1      1    11111 '\n   a.29='2! 22222 2     2      2     2    2    2     2222222'\n   a.30='3! 33333 3     3      3  3333       33     3 33333 '\n   a.31='4!    4     44    4 4   4  4  4444444    4      4  '\n   a.32='5!55555555      5      555555       5      5 55555 '\n   a.33='6!  66666 6     6      66666666     66     6 66666 '\n   a.34='7!7777777     7     7     7      7      7      7   '\n   a.35='8! 88888 8     88     8 88888 8     88     8 88888 '\n   a.36='9! 99999 9     99     9 999999      9      9 99999 '\n   a.37='!!   !!     !!     !!     !!            !!     !!  '\n   a.38='$!   $    $$$$$ $  $    $$$$$    $  $ $$$$$    $   '\n   a.39='%!%%    %%%   %     %     %     %     %   %%%    %%'\n   a.40='&!  &&&&  &    & &   &    &&    & & & &   &   &&  &'\n   a.41='/!      /     /     /     /     /     /     /      '\n   a.42='(!     (    (     (      (      (       (        ( '\n   a.43=')! )        )       )      )      )     )    )     '\n   a.44='=!              =======       =======              '\n   a.45='+!          +      +    +++++    +      +          '\n   a.46='*!       *  *  * * * *   ***   * * * *  *  *       '\n   a.47='-!                      -----                      '\n   a.48='.!                               ..     ..         '\n   a.49=':!          ::     ::            ::     ::         '\n   a.50='#!         # #   #####   # #   #####   # #         '\n   a.51=',!                               ,,     ,,    ,,   '\n   a.52=';!                        ;;            ;;    ;;   '\n   a.53='_!                                          _______'\n   a.54='?! ????? ?     ?     ?    ?      ?             ?   '\n\n   b.1 = ''\n   b.2 = ''\n   b.3 = ''\n   b.4 = ''\n   b.5 = ''\n   b.6 = ''\n   b.7 = ''\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BODY": {"ttr": 1284, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x18\\x01\\x17\\x00_\\x01\\x17\\x00_\\t#\\x00%\\x00%\\x00\\x00\\xd5\\xd6\\xd9\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2017-01-05T00:00:00", "modifydate": "2017-01-05T09:23:18", "lines": 37, "newlines": 37, "modlines": 0, "user": "NORBERT"}, "text": "/* REXX ------------------------------------------------------------- */\n/* Macro:         BODY                                                */\n/* Syntax:        BODY                                                */\n/* Parameter:     none                                                */\n/* Function:      counts the number of lines in the )BODY section of  */\n/*                an ISPF-Panel.                                      */\n/* Author:        Norbert Haas, noaDatex.de                           */\n/* Remark:        See macro AREA.                                     */\n/* ------------------------------------------------------------------ */\n\"ISREDIT MACRO\"\n\n\"ISREDIT FIND FIRST ')BODY' 1\"\nIF rc = 0 THEN DO\n   \"ISREDIT (z1) = LINENUM .ZCSR\"\n   \"ISREDIT FIND NEXT ')' 1\"\n   IF rc = 0 THEN DO\n      \"ISREDIT (z2) = LINENUM .ZCSR\"\n      anz = z2 - z1 - 1\n      \"ISREDIT (panel) = MEMBER\"\n      zedsmsg = 'BODY' anz 'lines'\n      zedlmsg = 'Panel' panel 'has' anz 'line in the BODY-Section.'\n      \"ISPEXEC SETMSG MSG(isrz000)\"\n      \"ISREDIT FIND FIRST ')BODY' 1\"\n   END\n   ELSE DO\n      zedsmsg = 'Error (END missing)'\n      zedlmsg = 'No )END-Section found in this panel.'\n      \"ISPEXEC SETMSG MSG(isrz001)\"\n   END\nEND\nELSE DO\n   zedsmsg = 'Error (BODY missing)'\n   zedlmsg = 'No )BODY-Section found in this panel.'\n   \"ISPEXEC SETMSG MSG(isrz001)\"\nEND\n\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BOX": {"ttr": 1286, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x18\\x01\\x17\\x00_\\x01\\x17\\x00_\\t#\\x00\\xf4\\x00\\xf4\\x00\\x00\\xd5\\xd6\\xd9\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2017-01-05T00:00:00", "modifydate": "2017-01-05T09:23:18", "lines": 244, "newlines": 244, "modlines": 0, "user": "NORBERT"}, "text": "/* REXX ***************************************************************/\n/* -------------------------------------------------------------------*/\n/* Name:       BOX                                                    */\n/* Short       Draws a comment-box around lines (COBOL,PLI,REXX,JCL)  */\n/* Type:       REXX Macro                                             */\n/* Author:     Norbert Haas, noaDatex.de                              */\n/* Syntax:     BOX .label1 .label2 <char> <language>                  */\n/* Parameter:  .label 1/2 = ISPF-Edit-Label                           */\n/*             char = fillin char (optional, Default = '*') for the   */\n/*                       edge above and belowe                        */\n/*             language = COBol (default)                             */\n/*                        PLI oder PL1                                */\n/*                        JCL oder CNTL                               */\n/*                        REXx                                        */\n/*                                                                    */\n/* Examples:   BOX .a .b                                              */\n/*             BOX .x .x (just one line)                              */\n/*             BOX .from .to - C                                      */\n/*             BOX .U .V REXX                                         */\n/*                                                                    */\n/* Version   Author        Date      Why                              */\n/* --------- ------------- --------- -------------------------------- */\n/* V01.05    N.Haas        28.05.03  remarks in english               */\n/* V01.04    N.Haas        06.02.03  | => KONKAT(), ODER()            */\n/* V01.03    N.Haas        29.11.94  PLI und REX eingefuehrt          */\n/* V01.02    N.Haas        21.10.93  Nur bis Spalte 71, nicht 72      */\n/* V01.01    N.Haas        04.10.93  User_State eingefuehrt           */\n/* V01.00    N.Haas        12.10.92  Erstellung                       */\n/**********************************************************************/\n\"ISREDIT MACRO (parm)\"\n\"ISPEXEC CONTROL ERRORS RETURN\"\n\n/* save cursor ------------------------------------------------------ */\n\"ISREDIT (csrrow,csrcol) = CURSOR\"\n\n/* User_State ------------------------------------------------------- */\n\"ISREDIT (usrst)  = USER_STATE\"\n\n/* divide parm and notice number of words --------------------------- */\nparm = TRANSLATE(parm)\nPARSE VALUE parm WITH p.1 p.2 p.3 p.4 .\nanz_worte = WORDS(PARM)\n\n/* examine parms ---------------------------------------------------- */\nIF ODER(anz_worte < 2, anz_worte > 4) THEN DO\n   zedsmsg = 'PARAMETER INVALID'\n   zedlmsg = 'MACRO BOX NEEDS TWO LABEL PLUS TWO OPTIONAL PARM.'\n   SIGNAL mistake\nEND\n\n/* distribute parms ------------------------------------------------- */\nanz_lab = 0\nanz_char = 0\nanz_lang = 0\n\nDO i = 1 TO anz_worte\n   SELECT\n      /* is parm a libe (label) ? ----------------------------------- */\n      WHEN (p.i /= '')  &,\n           (SUBSTR(p.i,1,1) = '.')  &,\n           (DATATYPE(SUBSTR(p.i,2),'M')) THEN DO\n         anz_lab = anz_lab + 1                /* number of line-parms */\n         IF anz_lab = 1 THEN\n            n.2 = p.i                     /* move parm to 2. new-parm */\n         ELSE\n            n.3 = p.i                     /* move parm to 3. new-parm */\n         p.i = ''                                      /* delete parm */\n      END\n      /* is parm a language ? --------------------------------------- */\n      WHEN (p.i /= '')  &,\n           (ODER(LEFT(p.i,3) = 'COB',,\n                 LEFT(p.i,3) = 'PLI', LEFT(p.i,3) = 'PL1',,\n                 LEFT(p.i,3) = 'JCL', LEFT(p.i,4) = 'CNTL',,\n                 LEFT(p.i,3) = 'REX')) THEN DO\n         anz_lang = anz_lang + 1          /* number of language parms */\n         IF anz_lang = 1 THEN\n            n.4 = LEFT(p.i,3)             /* move parm to 4. new-parm */\n         p.i = ''                                      /* delete parm */\n      END\n      /* parm is char ----------------------------------------------- */\n      OTHERWISE DO\n         anz_char = anz_char + 1              /* number of char-parms */\n         n.1 = p.i                        /* move parm to 1. new-parm */\n         p.i = ''                                      /* delete parm */\n      END\n   END\nEND\n\n/* examine number of labels ----------------------------------------- */\nSELECT\n   WHEN anz_lab = 0 THEN DO\n      zedsmsg = 'LABEL ERROR'\n      zedlmsg = 'MACRO BOX NEEDS TWO ISPF-LABEL TO WORK WITH.'\n      SIGNAL mistake\n   END\n   WHEN anz_lab = 2 THEN DO\n      /* examine label ---------------------------------------------- */\n      \"ISREDIT (von) = LINENUM \" n.2\n      IF rc > 0 THEN DO\n         zedsmsg = 'INVALID LABEL'\n         zedlmsg = 'INVALID LABEL SPECIFIED. LABEL' n.2 'NOT FOUND.'\n         SIGNAL mistake\n      END\n      \"ISREDIT (bis) = LINENUM \" n.3\n      IF rc > 0 THEN DO\n         zedsmsg = 'INVALID LABEL'\n         zedlmsg = 'INVALID LABEL SPECIFIED. LABEL' n.3 'NOT FOUND.'\n         SIGNAL mistake\n      END\n   END\n   OTHERWISE DO\n      zedsmsg = 'PROBABLE LABEL ERROR'\n      zedlmsg = 'LABEL RECOGNIZED AS INVALID. ALLWAYS USE A',\n                'COMBINATION OF TWO LABELS.'\n      SIGNAL mistake\n   END\nEND\n\n/* examine number of chars ------------------------------------------ */\nSELECT\n   WHEN anz_char = 0 THEN DO\n      n.1 = '*'\n   END\n   WHEN anz_char = 1 THEN DO\n      SELECT\n         WHEN LENGTH(n.1) = 1 THEN NOP                /* parm was >*< */\n         WHEN LENGTH(n.1) = 3 THEN DO               /* parm was >'*'< */\n            n.1 = SUBSTR(n.1,2,1)\n         END\n         OTHERWISE DO\n            zedsmsg = 'INVALID PARAMATERS'\n            zedlmsg = 'CHARACTER INVALID. PUT STRING IN QUOTES'\n            SIGNAL mistake\n         END\n      END\n   END\n   OTHERWISE DO\n      zedsmsg = 'INVALID PARAMATERS'\n      zedlmsg = 'MACRO BOX DOES NOT SUPPORT MORE THAN ONE CHARACTER.'\n      SIGNAL mistake\n   END\nEND\n\n/* examine number of languages -------------------------------------- */\nSELECT\n   WHEN anz_lang = 0 THEN DO\n      n.4 = 'COB'                                          /* Default */\n   END\n   WHEN anz_lang = 1 THEN NOP\n   OTHERWISE DO\n      zedsmsg = 'INVALID PARAMATERS'\n      zedlmsg = 'MACRO BOX DOES NOT SUPPORT MORE THAN ONE LANGUAGE',\n                'PARMAMETER.'\n      SIGNAL mistake\n   END\nEND\n\n/* swap from / to --------------------------------------------------- */\nIF von > bis THEN DO\n   temp = von\n   von = bis\n   bis = temp\nEND\n\n/* loop ------------------------------------------------------------- */\ncol = 1\nDO row = von TO bis\n   \"ISREDIT CURSOR = \" row col\n   SELECT\n      WHEN (n.4 = 'COB') THEN DO\n         \"ISREDIT CHANGE .ZCSR .ZCSR  7 p'=' '*'\"\n         \"ISREDIT CHANGE .ZCSR .ZCSR 71 p'=' '*'\"\n      END\n      WHEN (LEFT(n.4,2) = 'PL') THEN DO\n         \"ISREDIT CHANGE .ZCSR .ZCSR  '/*' '  '\"\n         \"ISREDIT CHANGE .ZCSR .ZCSR  '*/' '  '\"\n         \"ISREDIT CURSOR = \" row col\n         \"ISREDIT CHANGE .ZCSR .ZCSR  2 p'==' '/*'\"\n         \"ISREDIT CHANGE .ZCSR .ZCSR 71 p'==' '*/'\"\n      END\n      WHEN ODER(n.4 = 'JCL' , n.4 = 'CNT') THEN DO\n         \"ISREDIT CHANGE .ZCSR .ZCSR  1 p'===' '//*'\"\n      END\n      WHEN (n.4 = 'REX') THEN DO\n         \"ISREDIT CHANGE .ZCSR .ZCSR  1 p'==' '/*'\"\n         \"ISREDIT CHANGE .ZCSR .ZCSR 71 p'==' '*/'\"\n      END\n      OTHERWISE NOP\n   END\nEND\n\n/* above / belowe --------------------------------------------------- */\nSELECT\n   WHEN (n.4 = 'COB') THEN DO\n      box_line = '      *'\n      do i = 8 to 70\n         box_line = KONKAT(box_line, n.1)\n      end\n      box_line = KONKAT(box_line, '*         ')\n   END\n   WHEN (LEFT(n.4,2) = 'PL') THEN DO\n      box_line = ' /*'\n      do i = 4 to 70\n         box_line = KONKAT(box_line, n.1)\n      end\n      box_line = KONKAT(box_line, '*/        ')\n   END\n   WHEN ODER(n.4 = 'JCL', n.4 = 'CNT') THEN DO\n      box_line = '//*'\n      do i = 4 to 71\n         box_line = KONKAT(box_line, n.1)\n      end\n      box_line = KONKAT(box_line, '         ')\n   END\n   WHEN (n.4 = 'REX') THEN DO\n      box_line = '/* '\n      do i = 4 to 69\n         box_line = KONKAT(box_line, n.1)\n      end\n      box_line = KONKAT(box_line, ' */        ')\n   END\n   OTHERWISE NOP\nEND\n\"ISREDIT LINE_AFTER\" bis \"= '\"box_line\"'\"\n\"ISREDIT LINE_BEFORE\" von \"= '\"box_line\"'\"\n\n/* Reset ------------------------------------------------------------ */\n\"ISREDIT RESET CHG\"\n\n/* reset User_State ------------------------------------------------- */\n\"ISREDIT USER_STATE = (usrst)\"\n\n/* reset cursor ----------------------------------------------------- */\n\"ISREDIT CURSOR = \" csrrow csrcol\n\n/* finish ----------------------------------------------------------- */\nEXIT 1\n\n/* ================================================================== */\n\nMISTAKE:\n   /* Fehlerbehandlung ---------------------------------------------- */\n   \"ISPEXEC SETMSG MSG(ISRZ001)\"\nEXIT -8\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CATCH": {"ttr": 1291, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x02\\x00\\x18\\x01\\x17\\x00_\\x01\\x17\\x00_\\t#\\x00'\\x00'\\x00\\x00\\xd5\\xd6\\xd9\\xc2\\xc5\\xd9\\xe3@@@\"", "ispf": {"version": "01.02", "flags": 0, "createdate": "2017-01-05T00:00:00", "modifydate": "2017-01-05T09:23:18", "lines": 39, "newlines": 39, "modlines": 0, "user": "NORBERT"}, "text": "/* REXX ------------------------------------------------------------- */\n/* Name:         CATCH                                                */\n/* Type:         Exec                                                 */\n/* Author:       Norbert Haas, noaDatex.de                            */\n/* Date:         21.08.2009                                           */\n/* Syntax:       TSO CATCH tso_command                                */\n/* Parameter:    tso_command                                          */\n/* Description:  Catches the output of a tso_command                  */\n/* Example:      TSO CATCH HELP PERMIT                                */\n/*                                                                    */\n/* Vers.  Datum      Author    Reason                                 */\n/* ------ ---------- --------- -------------------------------------- */\n/* V01.02 03.01.2017 N.Haas    English version                        */\n/* V01.01 21.08.2009 N.Haas    Erstellung                             */\n/* ------------------------------------------------------------------ */\nPARSE UPPER ARG parm\n\nTRUE = 1\nFALSE = 0\n\ndsn = \"'\"USERID()\".CATCH'\"\nIF SYSDSN(dsn) = 'OK' THEN DO\n   dmy = MSG('OFF')\n   \"DELETE\" dsn\n   DMY = MSG('ON')\nEND\n\"ALLOC DD(dd) DSN(\"dsn\") DSORG(PS) RECFM(F,B)\",\n                        \"SPACE(5,75) TRACKS\",\n                        \"LRECL(132) BLKSIZE(0)\"\ndmy = OUTTRAP('lines.')\nparm\ndmy = OUTTRAP('OFF')\n\n\"EXECIO\" lines.0 \"DISKW DD (FINIS STEM lines.\"\n\"FREE DD(dd)\"\n\n\"ISPEXEC BROWSE DATASET(\"dsn\")\"\n\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CFIND": {"ttr": 1293, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x18\\x01\\x17\\x00_\\x01\\x17\\x00_\\t#\\x00\\\\\\x00\\\\\\x00\\x00\\xd5\\xd6\\xd9\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2017-01-05T00:00:00", "modifydate": "2017-01-05T09:23:18", "lines": 92, "newlines": 92, "modlines": 0, "user": "NORBERT"}, "text": "/* REXX ***************************************************************/\n/* -------------------------------------------------------------------*/\n/* Name:       CFIND (Cursor FIND)                                    */\n/* Short:      Find string under the cursor                           */\n/* Type:       REXX-macro                                             */\n/* Author:     Norbert Haas, noaDatex.de                              */\n/* Function:   finds chars powered by cursorposition                  */\n/* Syntax:     CFIND (should be on a PF-Key)                          */\n/* Parameter:  none                                                   */\n/* Remarks:    - The string is limited by blanks (left and right)     */\n/*             - Implizite parms are NEXT and CHAR.                   */\n/*             - Used once, you can use RFIND (F5) afterwords.        */\n/*                                                                    */\n/* Version   Author        Date      Why                              */\n/* --------- ------------- --------- -------------------------------- */\n/* V01.03    N.Haas        28.05.03  remarks in english               */\n/* V01.02    N.Haas        14.05.03  Rechts Punkt abschneiden (Cobol) */\n/* V01.01    N.Haas        21.06.95  Verbesserung (Messages)          */\n/* V01.00    N.Haas        22.12.92  Erstellung                       */\n/**********************************************************************/\n\"ISREDIT MACRO (parm)\"\n\"ISPEXEC CONTROL ERRORS RETURN\"\n\n/* translate parm to caps ------------------------------------------- */\nparm = TRANSLATE(parm)\n\n/* examine parm ----------------------------------------------------- */\nIF parm /= '' THEN DO\n   zedsmsg = \"PARAMETER ERROR\"\n   zedlmsg = \"MACRO CFIND DOES NOT WORK WITH ANY PARAMETERS.\"\n   \"ISPEXEC SETMSG MSG(ISRZ001)\"\n   EXIT -8\nEND\n\n/* read char under the cursor --------------------------------------- */\n\"ISREDIT (zeile) = LINE .ZCSR\"\n\"ISREDIT (row,col) = CURSOR\"\ncol_save = col\ntst = SUBSTR(zeile,col,1)\nIF tst = '' THEN EXIT 0\nDO WHILE (tst /= '')\n   col = col - 1\n   IF col > 0 THEN\n      tst = SUBSTR(zeile,col,1)\n   ELSE\n      tst = ''\nEND\ncol = col + 1\ntst = SUBSTR(zeile,col,1)\nchr = ''\nDO WHILE (tst /= '')\n  chr = chr || tst\n  col = col + 1\n  tst = SUBSTR(zeile,col,1)\nEND\n\n/* examine char (no & allowed) -------------------------------------- */\nIF LEFT(chr,1) = '&' THEN DO\n   zedsmsg = 'CFIND not possible'\n   zedlmsg = 'Ths string under the cursor ('chr')',\n             'contains at least one ampersand (&)'\n   \"ISPEXEC SETMSG MSG(isrz001)\"\n   \"ISREDIT CURSOR =\" row col_save\n   SIGNAL Ente\nEND\n\n/* strip right dot (.) ---------------------------------------------- */\nchr = STRIP(chr,'T','.')\n\n/* find char -------------------------------------------------------- */\n\"ISREDIT FIND '\"chr\"'\"\nfind_rc = rc\n\nIF find_rc = 4 THEN DO\n   zedsmsg = '*Bottom of data reached*'\n   zedlmsg = 'CHARS 'chr' - NOT FOUND.',\n             'PRESS RFIND KEY TO CONTINUE FROM TOP.'\n   \"ISPEXEC SETMSG MSG(isrz001)\"\n   \"ISREDIT CURSOR =\" row col_save\nEND\n\nIF find_rc > 4 THEN DO\n   zedsmsg = 'CFIND not possible'\n   zedlmsg = 'The string under the cursor ('chr')',\n             \"contains one of the following chars ('), (,)\",\n             'or (&).'\n   \"ISPEXEC SETMSG MSG(isrz001)\"\n   \"ISREDIT CURSOR =\" row col_save\nEND\n\nEnte:\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CHALL": {"ttr": 1537, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x18\\x01\\x17\\x00_\\x01\\x17\\x00_\\t#\\x00\\x85\\x00\\x85\\x00\\x00\\xd5\\xd6\\xd9\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2017-01-05T00:00:00", "modifydate": "2017-01-05T09:23:18", "lines": 133, "newlines": 133, "modlines": 0, "user": "NORBERT"}, "text": "/* REXX ***************************************************************/\n/* -------------------------------------------------------------------*/\n/* Name:       CHALL                                                  *//*HELP*/\n/* Short       CHange ALL, Change All strings in some/all Members of  *//*HELP*/\n/*             a PDS.                                                 */\n/* Type:       REXX-Exec                                              *//*HELP*/\n/* Author:     Norbert Haas, noaDatex.de                              *//*HELP*/\n/* Syntax:     TSO %CHALL                                             *//*HELP*/\n/* Parameter:  none                                                   *//*HELP*/\n/*                                                                    */\n/* Version   Autor         Datum     Anlass                           */\n/* --------- ------------- --------- -------------------------------- */\n/* V01.01    N.Haas        20.06.03  englich version                  */\n/* V01.00    N.Haas        03.05.02  Erstellung                       */\n/**********************************************************************/\n\n/* Init */\nzedsmsg  = ''                                            /* Short MSG */\n\nxFF      = 'FF'x                                    /* Hex FF ( 255 ) */\nBlank    = '40'x                                    /* Hex 40 ( 064 ) */\n\nfstring  = \"\"                                          /* Find-String */\ncstring  = \"\"                                        /* Change-String */\n\ncontext  = \"\"\nposition = 1\nfrom     = 1\nto       = 999999\n\ncursor   = 'dsn'                                            /* Cursor */\ncsrpos   = 1                                            /* Cursorpos. */\n\ndsn      = \"'\"USERID()\"....'\"\npat      = '*'                                         /* Alle Member */\n\nc_mem    = 0                                    /* Counter for Member */\nc_change = 0                                /* Counter for anderungen */\n\n/* Display panel before loop */\n\"ISPEXEC ADDPOP\"\n\"ISPEXEC DISPLAY PANEL(challp)\"\nDO WHILE rc = 0\n   /* Re-Init */\n   c_mem    = 0                                 /* Counter for member */\n   c_change = 0                                /* Counter for changes */\n\n   /* Read panel (Options) */\n   IF context = '/' THEN DO\n      grkl = 'YES'\n   END\n   ELSE DO\n      grkl = 'NO'\n   END\n\n   SELECT\n      WHEN position = 1 THEN pos = 'CHARS'\n      WHEN position = 2 THEN pos = 'PREFIX'\n      WHEN position = 3 THEN pos = 'SUFFIX'\n      WHEN position = 4 THEN pos = 'WORD'\n      OTHERWISE NOP\n   END\n\n   /* Does DSN exist ? */\n   sysdsn = SYSDSN(dsn)\n   IF sysdsn /= 'OK' THEN DO\n      zedlmsg = 'Dataset' dsn 'not found. ('sysdsn')'\n      msg = 'ISRZ001'\n      cursor = 'dsn'\n      csrpos = 1\n   END\n   ELSE DO\n      /* LM-Job and plausi PO Dataset */\n      \"ISPEXEC LMINIT DATAID(id) DATASET(\"dsn\") ENQ(SHR) ORG(dsorg)\"\n      IF dsorg /= 'PO' THEN DO\n         zedlmsg = 'Dataset' dsn 'is not PO.'\n         cursor = 'dsn'\n         csrpos = 1\n         msg = 'ISRZ001'\n      END\n      ELSE DO\n         /* LM-Job, create list aof all relevant members */\n         \"ISPEXEC LMOPEN DATAID(\"id\") OPTION(INPUT)\"\n         mem = \"\"\n         \"ISPEXEC LMMLIST DATAID(\"id\") OPTION(LIST)\",\n                         \"MEMBER(mem) PATTERN(\"pat\")\"\n\n         /* Loop against all members of the list */\n         DO WHILE rc = 0\n            c_mem = c_mem + 1\n            dsn_mem = STRIP(dsn,\"T\",\"'\")\"(\"STRIP(mem)\")'\"\n\n            /* >'< aorund find- and changestring */\n            fstring = TRANSLATE(\"'\"STRIP(fstring,\"B\",\"'\")\"'\",xFF,Blank)\n            cstring = TRANSLATE(\"'\"STRIP(cstring,\"B\",\"'\")\"'\",xFF,Blank)\n\n            PUSH fstring cstring grkl pos from to\n\n            /* Display */\n            \"ISPEXEC CONTROL DISPLAY LOCK\"\n            zedlmsg = dsn_mem\n            \"ISPEXEC DISPLAY MSG(ISRZ000)\"\n\n            /* Call Editor with Initialmacro */\n            \"ISPEXEC EDIT DATASET(\"dsn_mem\") MACRO(CHALLM)\"\n            IF rc = 0 THEN c_change = c_change + 1\n            mem = \"\"\n\n            /* Get next member from the list */\n            \"ISPEXEC LMMLIST DATAID(\"id\") OPTION(LIST)\",\n                            \"MEMBER(mem) PATTERN(\"pat\")\"\n         END\n\n         /* LM-Job */\n         \"ISPEXEC LMCLOSE DATAID(\"id\")\"\n\n         /* Info-Msg */\n         zedlmsg = 'In DSN ' dsn c_mem 'members have been processed.',\n                   'In' c_change 'Members changes have been made.'\n         cursor = 'fstring'\n         csrpos = 1\n         msg = 'ISRZ000'\n      END\n      /* LM-Job */\n      \"ISPEXEC LMFREE DATAID(\"id\")\"\n   END\n   /* Display Panel once again with MSG */\n   \"ISPEXEC SETMSG MSG(\"msg\")\"\n   \"ISPEXEC DISPLAY PANEL(challp)\"\nEND\n\n\"ISPEXEC REMPOP\"\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CHALLM": {"ttr": 1540, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x15\\x01\\x16(\\x1f\\x01\\x16(\\x1f\\x001\\x00$\\x00$\\x00\\x00\\xd5\\xd6\\xd9\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-10-07T00:00:00", "modifydate": "2016-10-07T00:31:15", "lines": 36, "newlines": 36, "modlines": 0, "user": "NORBERT"}, "text": "/* REXX See CHALL */\n\n\"ISREDIT MACRO\"\n\nPULL fstring cstring grkl pos from to\n\nxFF     = 'FF'x                                     /* Hex FF ( 255 ) */\nBlank   = '40'x                                     /* Hex 40 ( 064 ) */\n\nfstring = TRANSLATE(fstring,Blank,xFF)\ncstring = TRANSLATE(cstring,Blank,xFF)\n\n\"ISREDIT (width) = DATA_WIDTH\"\nto = MIN(to,width)\n\nIF from > to THEN DO\n   dummy = to\n   to    = from\n   from  = dummy\nEND\n\nIF grkl = 'YES' then\n   grkl = 'C'\nELSE\n   grkl = ''\n\n\"ISREDIT CHANGE ALL\" grkl||fstring cstring pos from to\n\nIF rc = 0 THEN DO\n   \"ISREDIT (treffer) = CHANGE_COUNTS\"\nEND\nELSE DO\n   treffer = 0\nEND\n\n\"ISREDIT END\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CHALLP": {"ttr": 1542, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x00A\\x01\\x17\\x00_\\x01\\x17\\x00_\\t\\x10\\x00C\\x00C\\x00\\x00\\xd5\\xd6\\xd9\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "2017-01-05T00:00:00", "modifydate": "2017-01-05T09:10:41", "lines": 67, "newlines": 67, "modlines": 0, "user": "NORBERT"}, "text": ")PANEL KEYLIST(ISRSNAB,ISR)\n\n/* Panel **************************************************************/\n/* Name   CHALLP                                                      */\n/* Short  CHange ALL agains all/some member of a PDS                  */\n/* Type   PANEL                                                       */\n/* Author Norbert Haas                                                */\n/* Date   03.05.2002                                                  */\n/* VER    V01.00                                                      */\n/* ********************************************************************/\n\n)ATTR DEFAULT(%+_)\n  % TYPE(ET)                                       /* Emphasized Text */\n  } TYPE(CH)\n  { TYPE(FP)                                          /* Field Prompt */\n  q TYPE(RP)\n  _ TYPE(NEF) CAPS(ON)                          /* Normal Entry Field */\n  | TYPE(NEF) JUST(RIGHT)\n  + TYPE(NT)                                           /* Normal Text */\n  \\ TYPE(PIN)                                    /* Panel Instruction */\n  ~ AREA(SCRL) EXTEND(ON)                               /* Scrollarea */\n)BODY EXPAND(``) WINDOW(60,22)\n+\n+COMMAND ===>_ZCMD\n~SCROLLI                                                   ~\n)AREA SCROLLI\n\\You are going to change a string into another string in all\n\\or some members of a PDS.\n+\n\\You have to enter the name of the PDS and the member (* for\n\\all members), the find- and change-string and some options.\n+\n+\n}Datasetinformation+\n+ {Dataset   . . ._dsn                                     +\n+ {Member  . . . ._pat     +          q(\"*\" for all Member)+\n+\n+\n}Strings:+\n+ {Findstring  . ._fstring                                 +\n+ {Changestring  ._cstring                                 +\n+\n+\n}Options:+\n+ _Z+                                     qwith UCase/LCase+\n+ _Z+                   q1=Chars, 2=Prefix, 3=Suffix,4=Word+\n+ |from  |to    +                         qfrom / to colums+\n+\n+\n+\n+\n)INIT\n   .ZVARS = 'context,position'\n   &ZWINTTL = ' Change All Tool '\n   .CURSOR = &CURSOR\n   .CSRPOS = &CSRPOS\n)PROC\n   &ZWINTTL = ''\n   VER (&dsn,NB)\n   VER (&pat,NB)\n   VER (&fstring,NB)\n   VER (&cstring,NB)\n   IF (&context NE &Z) &context = '/'\n   VER (&position,NB,LIST,1,2,3,4)\n   VER (&from,NB,RANGE,1,999999)\n   VER (&to,NB,RANGE,1,999999)\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COLA": {"ttr": 1544, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x18\\x01\\x17\\x00_\\x01\\x17\\x00_\\t#\\x00^\\x00^\\x00\\x00\\xd5\\xd6\\xd9\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2017-01-05T00:00:00", "modifydate": "2017-01-05T09:23:18", "lines": 94, "newlines": 94, "modlines": 0, "user": "NORBERT"}, "text": "/* REXX ***************************************************************/\n/* -------------------------------------------------------------------*/\n/* Name:       COLA                                                   */\n/* Short       Set CObol LAbel                                        */\n/* Type:       REXX-Macro (my first one!)                             */\n/* Author:     Norbert Haas, noaDatex.de                              */\n/* Function:   Puts in some labels on special lines in Cobolsource    */\n/* Syntax:     COLA \u00ddlabel\u00a8                                           */\n/* Parameter:  label = one of the inserted labels                     */\n/* Remark:     The following labels will be set, dependig of the      */\n/*             existance of the corrosponding lines:                  */\n/*             .E = ENVIRONMENT DIVISION.                             */\n/*             .C = CONFIGURATION SECTION.                            */\n/*             .I = INPUT-OUTPUT SECTION.                             */\n/*             .D = DATA DIVISION.                                    */\n/*             .F = FILE SECTION.                                     */\n/*             .W = WORKING-STORAGE SECTION.                          */\n/*             .L = LINKAGE SECTION.                                  */\n/*             .P = PROCEDURE DIVISION.                               */\n/* Exampel:    COLA .P                                                */\n/*             Sets the labels and locates on .P                      */\n/*                                                                    */\n/* Version Author        Date       Why                               */\n/* ------- ------------- ---------- --------------------------------- */\n/* V02.01  N.Haas        30.05.2003 english version                   */\n/* V02.00  N.Haas        xx.02.1999 REXX-Version                      */\n/* V01.00  N.Haas        xx.07.1990 Creation    (Clist)               */\n/**********************************************************************/\n\"ISREDIT MACRO (loc)\"\n\n/* Init */\ncount = 0\nlist = ''\n\nFLAG01: \"ISREDIT FIND 'ENVIRONMENT DIVISION' FIRST\"\nIF rc = 4 THEN SIGNAL FLAG02\n\"ISREDIT LABEL .ZCSR = .E 0\"\ncount = count + 1\nlist = list '.E'\n\nFLAG02: \"ISREDIT FIND 'CONFIGURATION SECTION' FIRST\"\nIF rc = 4 THEN SIGNAL FLAG03\n\"ISREDIT LABEL .ZCSR = .C 0\"\ncount = count + 1\nlist = list '.C'\n\nFLAG03: \"ISREDIT FIND 'INPUT-OUTPUT SECTION' FIRST\"\nIF rc = 4 THEN SIGNAL FLAG04\n\"ISREDIT LABEL .ZCSR = .I 0\"\ncount = count + 1\nlist = list '.I'\n\nFLAG04: \"ISREDIT FIND 'DATA DIVISION' FIRST\"\nIF rc = 4 THEN SIGNAL FLAG05\n\"ISREDIT LABEL .ZCSR = .D 0\"\ncount = count + 1\nlist = list '.D'\n\nFLAG05: \"ISREDIT FIND 'FILE SECTION' FIRST\"\nIF rc = 4 THEN SIGNAL FLAG06\n\"ISREDIT LABEL .ZCSR = .F 0\"\ncount = count + 1\nlist = list '.F'\n\nFLAG06: \"ISREDIT FIND 'WORKING-STORAGE SECTION' FIRST\"\nIF rc = 4 THEN SIGNAL FLAG07\n\"ISREDIT LABEL .ZCSR = .W 0\"\ncount = count + 1\nlist = list '.W'\n\nFLAG07: \"ISREDIT FIND 'LINKAGE SECTION' FIRST\"\nIF rc = 4 THEN SIGNAL FLAG08\n\"ISREDIT LABEL .ZCSR = .L 0\"\ncount = count + 1\nlist = list '.L'\n\nFLAG08: \"ISREDIT FIND 'PROCEDURE DIVISION' FIRST\"\nIF rc = 4 THEN SIGNAL FLAG09\n\"ISREDIT LABEL .ZCSR = .P 0\"\ncount = count + 1\nlist = list '.P'\n\n/* Well done ? Set message ------------------------------------------ */\nFLAG09: \"ISREDIT LOCATE .ZFIRST\"\nIF count > 0 THEN DO\n  zedsmsg = count \"LABELS\"\n  ZEDLMSg = \"FOLLOWING LABELS HAVE BEEN SET:\" list\n  \"ISPEXEC SETMSG MSG(ISRZ000)\"\nEND\n\n/* locate ----------------------------------------------------------- */\nIF loc /= '' THEN \"ISREDIT LOCATE\" loc\n\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CUAATTR": {"ttr": 1547, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x18\\x01\\x17\\x00_\\x01\\x17\\x00_\\t#\\x00e\\x00e\\x00\\x00\\xd5\\xd6\\xd9\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2017-01-05T00:00:00", "modifydate": "2017-01-05T09:23:18", "lines": 101, "newlines": 101, "modlines": 0, "user": "NORBERT"}, "text": "/* REXX     Overview of the storage of the CUAATTR in the ISPSPROF\n\n            N.Haas, 11.12.2001, noaDatex.de\n\nzcuaattr = '600100720220620504120400520622400100720504400700' !! ,\n           '504400400100700100720720700100500620220100520520'\n\n            The meaning of the triplets are: (i.e. 6 0 0):\n            6 = Yellow, 0 = Low, 0 = None\n\n            The sequence of triplets can be found in the following list.\n            The Active Window Frame is not stored here, the Point-And-\n            Shoot fields occupy triplets 31 and 32. The colors,\n            intensity and highlighting can be found at the end of the\n            table.\n\n     +---------------------------------------------------------------+\n   No| Panel Element                  Color    Intensity  Highlight  |\n     |                                                               |\n    1| AB Selected Choice . . . . . . YELLOW   LOW        NONE       |\n    2| AB Separator Line  . . . . . . BLUE     LOW        NONE       |\n    3| AB Unselected Choice . . . . . WHITE    HIGH       NONE       |\n    4| Action Message Text  . . . . . RED      HIGH       NONE       |\n   --| Active Window Frame  . . . . . BLUE     HIGH                  |\n    5| Caution Text . . . . . . . . . YELLOW   HIGH       NONE       |\n    6| Choice Entry Field . . . . . . TURQ     LOW        USCORE     |\n    7| Column Heading . . . . . . . . BLUE     HIGH       NONE       |\n    8| Descriptive Text . . . . . . . GREEN    LOW        NONE       |\n    9| Emphasized Text  . . . . . . . TURQ     HIGH       NONE       |\n   10| Error Emphasis . . . . . . . . YELLOW   HIGH       REVERSE    |\n   11| Field Prompt . . . . . . . . . GREEN    LOW        NONE       |\n   12| Function Keys  . . . . . . . . BLUE     LOW        NONE       |\n   13| Informational Message Text . . WHITE    HIGH       NONE       |\n   14| List Entry Field . . . . . . . TURQ     LOW        USCORE     |\n   15| List Item Description  . . . . GREEN    LOW        NONE       |\n   16| List Items . . . . . . . . . . WHITE    LOW        NONE       |\n   17| Normal Entry Field . . . . . . TURQ     LOW        USCORE     |\n   18| Normal Text  . . . . . . . . . GREEN    LOW        NONE       |\n   19| Panel Instruction  . . . . . . GREEN    LOW        NONE       |\n   20| Panel Title  . . . . . . . . . BLUE     LOW        NONE       |\n31/32| Point-and-Shoot  . . . . . . . TURQ     HIGH       NONE       |\n   21| PD Available Choices . . . . . WHITE    LOW        NONE       |\n   22| PD Unavailable Choices . . . . BLUE     LOW        NONE       |\n   23| Reference Phrase . . . . . . . WHITE    HIGH       NONE       |\n   24| Scroll Information . . . . . . WHITE    HIGH       NONE       |\n   25| Sel. Available Choices . . . . WHITE    LOW        NONE       |\n   26| Sel. Unavailable Choices . . . BLUE     LOW        NONE       |\n   27| Variable Output Info.  . . . . TURQ     LOW        NONE       |\n   28| Warning Message Text . . . . . YELLOW   HIGH       NONE       |\n   29| Warning Text . . . . . . . . . RED      HIGH       NONE       |\n   30| Work Area Separator Line . . . BLUE     LOW        NONE       |\n     +---------------------------------------------------------------+\n\n     Color:          Intensity:       Highlight:\n         1  Blue         0  Low           0  None\n         2  Red          1  ---           1  Blink\n         3  Pink         2  High          2  Reverse\n         4  Green                         3  ---\n         5  Turq                          4  Uscore\n         6  Yellow\n         7  White                                                     */\n\n\"ISPEXEC TBSTATS ispsprof STATUS1 (st1) STATUS2 (st2)\"\n\"ISPEXEC TBTOP ispsprof\"\n\"ISPEXEC TBSKIP ispsprof\"\n\"ISPEXEC TBGET ispsprof\"\n\nSAY zcuaattr\n\ncolor.   = '-nn------'\ncolor.1  = 'Blue     '\ncolor.2  = 'Red      '\ncolor.3  = 'Pink     '\ncolor.4  = 'Green    '\ncolor.5  = 'Turquoise'\ncolor.6  = 'Yellow   '\ncolor.7  = 'White    '\n\nintens.  = '-nn------'\nintens.0 = 'LOW      '\nintens.1 = '??????   '\nintens.2 = 'HIGH     '\n\nhigh.    = '-nn------'\nhigh.0   = 'NONE     '\nhigh.1   = 'BLINK    '\nhigh.2   = 'REVERSE  '\nhigh.3   = '??????   '\nhigh.4   = 'USCOREE  '\n\nDO i = 1 TO LENGTH(zcuaattr) BY 3\n   i0 = i + 0\n   i1 = i + 1\n   i2 = i + 2\n   c0 = SUBSTR(zcuaattr,i0,1)\n   c1 = SUBSTR(zcuaattr,i1,1)\n   c2 = SUBSTR(zcuaattr,i2,1)\n   SAY FORMAT(i,2) '-' c0 c1 c2 '-' color.c0 intens.c1 high.c2\nEND\n\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CUTMEM": {"ttr": 1550, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x18\\x01\\x17\\x00_\\x01\\x17\\x00_\\t#\\x00\\x1a\\x00\\x1a\\x00\\x00\\xd5\\xd6\\xd9\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2017-01-05T00:00:00", "modifydate": "2017-01-05T09:23:18", "lines": 26, "newlines": 26, "modlines": 0, "user": "NORBERT"}, "text": "/* REXX ------------------------------------------------------------- */\n/* Name:         CUTMEM                                               */\n/* Type:         Macro                                                */\n/* Author:       Norbert Haas, noaDatex.de                            */\n/* Date:         02.09.2009                                           */\n/* Syntax:       CUTMEM                                               */\n/* Parameter:    none                                                 */\n/* Description:  CUT with current member name                         */\n/* Beispiel:     CUTMEM                                               */\n/*                                                                    */\n/* Vers.  Datum      Autor     Grund                                  */\n/* ------ ---------- --------- -------------------------------------- */\n/* V01.02 03.01.2017 N.Haas    English version                        */\n/* V01.01 02.09.2009 N.Haas    Erstellung                             */\n/* ------------------------------------------------------------------ */\n\"ISREDIT MACRO NOPROCESS\"\n\n\"ISREDIT (zedtkey1) = MEMBER\"\nIF zedtkey1 = \"\" THEN zedtkey1 = \"DEFAULT\"\n\"ISREDIT CUT\" zedtkey1\n\"ISREDIT (zfixdkey) = LINENUM .ZLAST\"\nzfixdkey = zfixdkey + 0\n\n\"ISPEXEC SETMSG MSG(ISRP131)\"\n\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "C2B": {"ttr": 1552, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x18\\x01\\x17\\x00_\\x01\\x17\\x00_\\t#\\x00\\x17\\x00\\x17\\x00\\x00\\xd5\\xd6\\xd9\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2017-01-05T00:00:00", "modifydate": "2017-01-05T09:23:18", "lines": 23, "newlines": 23, "modlines": 0, "user": "NORBERT"}, "text": "/* REXX ------------------------------------------------------------- */\n/* Name:         C2B                                                  */\n/* Type:         Function                                             */\n/* Author:       Norbert Haas, noaDatex.de                            */\n/* Date:         03.05.2013                                           */\n/* Syntax:       C2B(char)                                            */\n/* Parameter:    char                                                 */\n/* Beschreibung: Character to Binary                                  */\n/* Example:      SAY C2B('N')                                         */\n/*                                                                    */\n/* Vers.  Date       Author    Reason                                 */\n/* ------ ---------- --------- -------------------------------------- */\n/* V01.02 03.01.2017 N.Haas    Englich Version                        */\n/* V01.01 03.05.2013 N.Haas    Erstellung                             */\n/* ------------------------------------------------------------------ */\nPARSE ARG char\nIF LENGTH(char) /= 1 THEN DO\n   zedsmsg = 'Wrong length'\n   zedlmsg = 'Function C2B expects just one char.'\n   \"ISPEXEC SETMSG MSG(ISRZ001)\"\n   EXIT 8\nEND\nEXIT D2B(C2D(char))\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DATE": {"ttr": 1554, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00\\x18\\x01\\x17\\x00_\\x01\\x17\\x00_\\t#\\x008\\x008\\x00\\x00\\xd5\\xd6\\xd9\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "2017-01-05T00:00:00", "modifydate": "2017-01-05T09:23:18", "lines": 56, "newlines": 56, "modlines": 0, "user": "NORBERT"}, "text": "DATE: PROCEDURE\n   /* --------------------------------------------------------------- */\n   /* Function:  DATE (must be imported into any other REXX-Exec, so  */\n   /*            that it becomes an internal function!)               */\n   /* Syntax:    x = DATE(format \u00dd,length\u00a8)                           */\n   /* Parameter: format = 'G' (German) or 'DSN' or any other format   */\n   /*            of the builtin function DATE                         */\n   /*          - If G, then length = 8 or 10                          */\n   /*            ==>   8 = dd.mm.yy   (8 is default)                  */\n   /*            ==>  10 = dd.mm.yyyy                                 */\n   /*          - IF DSN, length is obsolete                           */\n   /*            ==>     = #jjmmtt                                    */\n   /* Examples:  SAY DATE()                                           */\n   /*            SAY DATE('S')                                        */\n   /*            SAY DATE('U')                                        */\n   /*            SAY DATE('G')                                        */\n   /*            SAY DATE('G', 8)                                     */\n   /*            SAY DATE('G',10)                                     */\n   /*            SAY USERID() || \".ABC.\" || DATE('DSN')               */\n   /* Return:    4 Jan 2017                                           */\n   /*            20170104                                             */\n   /*            01/04/17                                             */\n   /*            04.01.17                                             */\n   /*            04.01.17                                             */\n   /*            04.01.2017                                           */\n   /*            NHAAS.ABC.#170104                                    */\n   /*                                                                 */\n   /* Vers.  Datum      Autor     Grund                               */\n   /* ------ ---------- --------- ----------------------------------- */\n   /* V01.02 03.01.2017 N.Haas    English Version                     */\n   /* V01.01 29.02.2015 N.Haas    Creation, noaDatex.de               */\n   /* --------------------------------------------------------------- */\n   PARSE UPPER ARG a, l\n\n   SELECT\n      WHEN a = 'G' THEN DO\n         tmp = \"DATE\"('E')                              /* tt/mm/jj   */\n         tmp = TRANSLATE(tmp,'.','/')                   /* tt.mm.jj   */\n         IF l = '' | l = 8 THEN NOP\n         ELSE DO\n            IF l = 10 THEN DO                           /* 03.01.2017 */\n               tmp = LEFT(tmp,6) || RIGHT(\"DATE\"(),4)\n            END\n            ELSE SAY \"ERROR bei Aufruf DATE('G',len)\"\n         END\n      END\n      WHEN a = 'DSN' THEN DO\n         tmp = \"DATE\"('S')                              /* jjjjmmtt   */\n         tmp = \"#\" || SUBSTR(tmp, 3)                    /* jjmmtt     */\n      END\n      OTHERWISE DO\n         IF a = \"\" THEN tmp = \"DATE\"()\n                   ELSE tmp = \"DATE\"(a)\n      END\n   END\nRETURN tmp\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DISPMSG": {"ttr": 1793, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x003\\x01\\x16\"O\\x01\\x17\\x00_#H\\x00\\x15\\x00\\x17\\x00\\x00\\xd5\\xd6\\xd9\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2016-08-11T00:00:00", "modifydate": "2017-01-05T23:48:33", "lines": 21, "newlines": 23, "modlines": 0, "user": "NORBERT"}, "text": "/* REXX N.Haas, 11/99 ----------------------------------------------- */\n/*                                                                    */\n/* -------------------------------------------------------------------*/\n/* Display a message                                                  */\n/* Call:   rc = DISPMSG(shortmsg, longmsg, TRUE|FALSE)                */\n/* Parms:  shortmsg = Shortmessage, max 26 Character                  */\n/*         longmsg = Longmessage                                      */\n/*         TRUE(1)|FALSE(0) = mit / ohne Beep                         */\n/* -------------------------------------------------------------------*/\n\n/* Accept parameters */\nPARSE ARG zedsmsg, zedlmsg, beep\n\n/* Beep ? */\nIF beep THEN\n   msg = 'ISRZ001'\nELSE\n   msg = 'ISRZ000'\n\n\"ISPEXEC SETMSG MSG(\"msg\")\"\nRETURN 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DSINFO": {"ttr": 1795, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x18\\x01\\x17\\x00_\\x01\\x17\\x00_\\t#\\x00\\xdd\\x00\\xdd\\x00\\x00\\xd5\\xd6\\xd9\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2017-01-05T00:00:00", "modifydate": "2017-01-05T09:23:18", "lines": 221, "newlines": 221, "modlines": 0, "user": "NORBERT"}, "text": "/* REXX ------------------------------------------------------------- */\n/* Name:         DSINFO                                               */\n/* Type:         Macro                                                */\n/* Author:       Norbert Haas, noaDatex.de                            */\n/* Datum:        15.06.2009                                           */\n/* Syntax:       DSINFO                                               */\n/* Parameter:    nn                                                   */\n/* Description:  Returns system information                           */\n/* Beispiel:     DSINFO                                               */\n/*                                                                    */\n/* Vers.  Datum      Autor     Grund                                  */\n/* ------ ---------- --------- -------------------------------------- */\n/* V01.02 02.01.2017 N.Haas    english version                        */\n/* V01.01 15.06.2009 N.Haas    Erstellung                             */\n/* ------------------------------------------------------------------ */\n\n\"ISREDIT MACRO\"\n\n\"ISREDIT (dsn) = DATASET\"\n\"ISREDIT (mem) = MEMBER\"\n\nIF mem = \"\" THEN\n   SAY dsn\nELSE DO\n   SAY dsn\"(\"STRIP(mem)\")\"\n   PARSE VAR dsn    dsn \"(\".\nEND\n\nSAY \"=================================================================\"\ndsn = \"'\"dsn\"'\"\n\nTRUE = 1\nFALSE =0\nfinished = FALSE\n\n/* 1. LISTDSI */\ndummy = LISTDSI(dsn) 'DIRECTORY'\n\n/* 2. LMDLIST */\nlevel = STRIP(dsn,,\"'\")\n\"ISPEXEC LMDINIT LISTID(listid) LEVEL(\"level\")\"\n\"ISPEXEC LMDLIST LISTID(\"listid\") DATASET(dataset) STATS(YES)\"\nDO WHILE (rc = 0) & (finished = FALSE)\n   \"ISPEXEC LMDLIST LISTID(\"listid\") DATASET(dataset) STATS(YES)\"\n   IF level = dataset THEN finished = TRUE\nEND\n\"ISPEXEC LMDFREE LISTID(\"listid\")\"\n\n/* Ausgabe */\nSAY\nSAY \"ZVARS:\"\nSAY \"-----------------------------------------------------------------\"\nSAY F10(ZDLVOL )   \"Volume serial.                         \"\nSAY F10(ZDLDEV )   \"Device type.                           \"\nSAY F10(ZDLDSORG)  \"Data set organization.                 \"\nSAY F10(ZDLRECFM)  \"Record format.                         \"\nSAY F10(ZDLLRECL)  \"Logical record length.                 \"\nSAY F10(ZDLBLKSZ)  \"Block size.                            \"\nSAY F10(ZDLSIZE )  \"Data set size in tracks.               \"\nSAY F10(ZDLUSED )  \"Percentage of used tracks or pages     \"\nSAY F10()          \"(PDSE).                                \"\nSAY F10(ZDLEXT )   \"Number of extents used.                \"\nSAY F10(ZDLCDATE)  \"Creation date.                         \"\nSAY F10(ZDLEDATE)  \"Expiration date.                       \"\nSAY F10(ZDLRDATE)  \"Date last referenced.                  \"\nSAY F10(ZDLMIGR )  \"Whether the data set is migrated       \"\nSAY F10()          \"('YES' or 'NO') based on the value     \"\nSAY F10()          \"of the Volume_of_migrated_data_sets    \"\nSAY F10()          \"keyword in ISPF configuration table.   \"\nSAY F10()          \"If the volume name of the data set     \"\nSAY F10()          \"matches the value of                   \"\nSAY F10()          \"Volume_of_migrated_data_sets,          \"\nSAY F10()          \"ZDLMIGR is set to 'YES', otherwise     \"\nSAY F10()          \"it is set to 'NO'.                     \"\nSAY F10(ZDLDSNTP)  \"Dsname type ('PDS', 'LIBRARY', or      \"\nSAY F10()          \"' ').                                  \"\nSAY F10(ZDLSPACU)  \"Space units.                           \"\nSAY\nSAY \"SYSVARS:\"\nSAY \"-----------------------------------------------------------------\"\nSAY F10(SYSDSNAME)  \"Data set name                                      \"\nSAY F10(SYSVOLUME)  \"Volume serial ID                                   \"\nSAY F10(SYSUNIT)    \"Generic device type on which volume resides, for   \"\nSAY F10()          \"example 3390.                                      \"\nSAY F10(SYSDSORG)   \"Data set organization:                             \"\nSAY F10()          \"                                                   \"\nSAY F10()          \"PS   - Physical sequential                         \"\nSAY F10()          \"PSU  - Physical sequential unmovable               \"\nSAY F10()          \"DA   - Direct organization                         \"\nSAY F10()          \"DAU  - Direct organization unmovable               \"\nSAY F10()          \"IS   - Indexed sequential                          \"\nSAY F10()          \"ISU  - Indexed sequential unmovable                \"\nSAY F10()          \"PO   - Partitioned organization                    \"\nSAY F10()          \"POU  - Partitioned organization unmovable          \"\nSAY F10()          \"VS   - VSAM                                        \"\nSAY F10()          \"???  - Unknown                                     \"\nSAY F10(SYSRECFM)   \"Record format; one to six character combination of \"\nSAY F10()          \"the following:                                     \"\nSAY F10()          \"                                                   \"\nSAY F10()          \"U    - Records of undefined length                 \"\nSAY F10()          \"F    - Records of fixed length                     \"\nSAY F10()          \"V    - Records of variable length                  \"\nSAY F10()          \"T    - Records written with the track overflow     \"\nSAY F10()          \"     feature of the device (3375, 3380, and 3390 d \"\nSAY F10()          \"     not support track overflow)                   \"\nSAY F10()          \"B    - Records blocked                             \"\nSAY F10()          \"S    - Records written as standard or spanned      \"\nSAY F10()          \"     variable-length blocks                        \"\nSAY F10()          \"A    - Records contain ASCII control characters    \"\nSAY F10()          \"M    - Records contain machine code control        \"\nSAY F10()          \"     characters                                    \"\nSAY F10()          \"?????? - Unknown                                   \"\nSAY F10(SYSLRECL)   \"Logical record length                              \"\nSAY F10(SYSBLKSIZE) \"Block size                                         \"\nSAY F10(SYSKEYLEN)  \"Key length                                         \"\nSAY F10(SYSALLOC)   \"Allocation, in space units                         \"\nSAY F10(SYSUSED)    \"Allocation used, in space units. For a partitioned \"\nSAY F10()          \"data set extended (PDSE), 'N/A' will be returned;  \"\nSAY F10()          \"see the description of the variable SYSUSEDPAGES f \"\nSAY F10()          \"used space of a PDSE.                              \"\nSAY F10(SYSUSEDPAGES) \"The used space of a partitioned data set extended\"\nSAY F10()          \"(PDSE) in 4K pages.                                \"\nSAY F10(SYSPRIMARY) \"Primary allocation in space units                  \"\nSAY F10(SYSSECONDS) \"Secondary allocation in space units                \"\nSAY F10(SYSUNITS)   \"Space units:                                       \"\nSAY F10()          \"                                                   \"\nSAY F10()          \"CYLINDER  - Space units in cylinders               \"\nSAY F10()          \"TRACK     - Space units in tracks                  \"\nSAY F10()          \"BLOCK     - Space units in blocks                  \"\nSAY F10()          \"????????  - Space units are unknown                \"\nSAY F10(SYSEXTENTS) \"Number of extents allocated                        \"\nSAY F10(SYSCREATE)  \"Creation date                                      \"\nSAY F10()          \"                                                   \"\nSAY F10()          \"Year/day format, for example: 1990/102             \"\nSAY F10(SYSREFDATE) \"Last referenced date                               \"\nSAY F10()          \"                                                   \"\nSAY F10()          \"Year/day format, for example: 1990/107             \"\nSAY F10()          \"                                                   \"\nSAY F10()          \"(Specifying DIRECTORY causes the date to be update \"\nSAY F10(SYSEXDATE)  \"Expiration date                                    \"\nSAY F10()          \"                                                   \"\nSAY F10()          \"Year/day format, for example: 1990/365             \"\nSAY F10(SYSPASSWORD) \"Password indication:                              \"\nSAY F10()          \"                                                   \"\nSAY F10()          \"NONE      - No password protection                 \"\nSAY F10()          \"READ      - Password required to read              \"\nSAY F10()          \"WRITE     - Password required to write             \"\nSAY F10(SYSRACFA)   \"RACF indication:                                   \"\nSAY F10()          \"                                                   \"\nSAY F10()          \"NONE      - No RACF protection                     \"\nSAY F10()          \"GENERIC   - Generic profile covers this data set   \"\nSAY F10()          \"DISCRETE  - Discrete profile covers this data set  \"\nSAY F10(SYSUPDATED) \"Change indicator:                                  \"\nSAY F10()          \"                                                   \"\nSAY F10()          \"YES       - Data set has been updated              \"\nSAY F10()          \"NO        - Data set has not been updated          \"\nSAY F10(SYSTRKSCYL) \"Tracks per cylinder for the unit identified in the \"\nSAY F10()          \"SYSUNIT variable                                   \"\nSAY F10(SYSBLKSTRK) \"Blocks (whose size is given in variable SYSBLKSIZE \"\nSAY F10()          \"per track for the unit identified in the SYSUNIT   \"\nSAY F10()          \"variable. For a PDSE, the value 'N/A' is returned  \"\nSAY F10()          \"because a block of size SYSBLKSIZE can 'span' a    \"\nSAY F10()          \"track in a PDSE. The value contained in SYSUSEDPAG \"\nSAY F10()          \"is a more meaningful measurement of space usage fo \"\nSAY F10()          \"a PDSE.                                            \"\nSAY F10(SYSADIRBLK) \"For a partitioned data set (PDS) the number of     \"\nSAY F10()          \"directory blocks allocated will be returned. For a \"\nSAY F10()          \"partitioned data set extended (PDSE), 'NO_LIM' wil \"\nSAY F10()          \"be returned because there is no static allocation  \"\nSAY F10()          \"for its directory. A value is returned only if     \"\nSAY F10()          \"DIRECTORY is specified on the LISTDSI statement.   \"\nSAY F10(SYSUDIRBLK) \"For a partitioned data set (PDS) the number of     \"\nSAY F10()          \"directory blocks used will be returned. For a      \"\nSAY F10()          \"partitioned data set extended (PDSE), 'N/A' will b \"\nSAY F10()          \"returned because it is not a static value. A value \"\nSAY F10()          \"is returned only if DIRECTORY is specified on the  \"\nSAY F10()          \"LISTDSI statement.                                 \"\nSAY F10(SYSMEMBERS) \"Number of members - returned only for partitioned  \"\nSAY F10()          \"data sets when DIRECTORY is specified              \"\nSAY F10(SYSREASON) \"LISTDSI reason code                                \"\nSAY F10(SYSMSGLVL1) \"First-level message if an error occurred           \"\nSAY F10(SYSMSGLVL2) \"Second-level message if an error occurred          \"\nSAY F10(SYSDSSMS)   \"Contains information about the type of a data set, \"\nSAY F10()          \"provided by DFSMS/MVS.                             \"\nSAY F10()          \"                                                   \"\nSAY F10()          \"                                                   \"\nSAY F10()          \"If the SMS DSNTYPE information could not be        \"\nSAY F10()          \"retrieved, the SYSDSSMS variable contains:         \"\nSAY F10()          \"                                                   \"\nSAY F10()          \"SEQ       for a sequential data set                \"\nSAY F10()          \"PDS       for a partitioned data set               \"\nSAY F10()          \"PDSE      for a partitioned data set extended.     \"\nSAY F10()          \"                                                   \"\nSAY F10()          \"If the data set is a PDSE and the SMS DSNTYPE      \"\nSAY F10()          \"information could be retrieved, the SYSDSSMS       \"\nSAY F10()          \"variable contains:                                 \"\nSAY F10()          \"                                                   \"\nSAY F10()          \"LIBRARY             for an empty PDSE              \"\nSAY F10()          \"PROGRAM_LIBRARY     for a partitioned data set     \"\nSAY F10()          \"                    extended program library       \"\nSAY F10()          \"DATA_LIBRARY        for a partitioned data set     \"\nSAY F10()          \"                    extended data library.         \"\nSAY F10(SYSDATACLASS) \"The SMS data class name - returned only if SMSINFO\"\nSAY F10()          \"is specified on the LISTDSI statement and the data \"\nSAY F10()          \"set is managed by SMS.                             \"\nSAY F10(SYSSTORCLASS) \"The SMS storage class name - returned only if    \"\nSAY F10()          \"SMSINFO is specified on the LISTDSI statement and  \"\nSAY F10()          \"the data set is managed by SMS.                    \"\nSAY F10(SYSMGMTCLASS) \"The SMS management class name - returned only if \"\nSAY F10()          \"SMSINFO is specified on the LISTDSI statement and  \"\nSAY F10()          \"the data set is managed by SMS.                    \"\nSAY \"Note: These variables, introduced with TSO/E 2.5, require either  \"\nSAY \"      MVS/DFP 3.2 (or later) or DFSMS/MVS 1.1 (or later) to be act\"\nSAY \"      on your system. For data sets not managed by SMS these \"\nSAY \"      variables return a null string. \"\n\nEXIT\n\nF10: PROCEDURE\n   PARSE ARG x\nRETURN LEFT(STRIP(x),10)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "D2B": {"ttr": 1800, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x18\\x01\\x17\\x00_\\x01\\x17\\x00_\\t#\\x00\\x1f\\x00\\x1f\\x00\\x00\\xd5\\xd6\\xd9\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2017-01-05T00:00:00", "modifydate": "2017-01-05T09:23:18", "lines": 31, "newlines": 31, "modlines": 0, "user": "NORBERT"}, "text": "/* REXX ------------------------------------------------------------- */\n/* Name:         D2B                                                  */\n/* Type:         Exec                                                 */\n/* Author:       Norbert Haas, noaDatex.de                            */\n/* Date:         03.05.2013                                           */\n/* Syntax:       D2B(decimal)                                         */\n/* Parameter:    decimal = Decimal number                             */\n/* Description:  Decimal to Binary                                    */\n/* Beispiel:     SAY D2B(164)                                         */\n/*                                                                    */\n/* Vers.  Datum      Autor     Grund                                  */\n/* ------ ---------- --------- -------------------------------------- */\n/* V01.02 03.01.2017 N.Haas    English Version                        */\n/* V01.01 03.05.2013 N.Haas    Erstellung                             */\n/* ------------------------------------------------------------------ */\nPARSE ARG dez\nTRUE = 1\nFALSE = 0\nIF DATATYPE(dez,'W') = FALSE THEN DO\n   zedsmsg = 'Wrong input'\n   zedlmsg = 'Function D2B expects only a whole number'\n   \"ISPEXEC SETMSG MSG(ISRZ001)\"\n   EXIT 8\nEND\nbin = ''\nDO UNTIL dez = 0\n   b = dez // 2\n   bin = b || bin\n   dez = TRUNC(dez / 2)\nEND\nEXIT bin\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ET": {"ttr": 1802, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x18\\x01\\x17\\x00_\\x01\\x17\\x00_\\t#\\x00o\\x00o\\x00\\x00\\xd5\\xd6\\xd9\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2017-01-05T00:00:00", "modifydate": "2017-01-05T09:23:18", "lines": 111, "newlines": 111, "modlines": 0, "user": "NORBERT"}, "text": "/* REXX ***************************************************************/\n/* -------------------------------------------------------------------*/\n/* Name:       ET (EditThis)                                          */\n/* Short       When changes made, using VIEW, type ET, and you will   */\n/*             see all the changes in the editor.                     */\n/* Type:       REXX-Macro                                             */\n/* Author:     Norbert Haas, noaDatex.de & Meik Naujeck               */\n/* Syntax:     ET \u00dd-\u00a8                                                 */\n/* Parameter:  - = Cancel the changes, just open the editor           */\n/* Remark:     Needs macros ET2,                                      */\n/*                          MCANCEL and                               */\n/*                          Function WHOHELDS()                       */\n/*                                                                    */\n/* Version Author        Date       Why                               */\n/* ------- ------------- ---------- --------------------------------- */\n/* V02.00  Haas          30.05.2003 english version and CUT (no VCUT) */\n/* V01.00  Haas&Naujeck  29.04.1998 Creation                          */\n/**********************************************************************/\n\"ISPEXEC CONTROL ERRORS RETURN\"\n\n/* Some not executed linecommands ?---------------------------------- */\n\"ISREDIT MACRO (parm) NOPROCESS\"\nIF rc /= 0 THEN DO\n   zedsmsg = 'ET not possible'\n   zedlmsg = 'Some linecommands have not yet been finished.',\n             'Please type RESET and try again.'\n   \"ISPEXEC SETMSG MSG(isrz001)\"\n   EXIT\nEND\n\n/* Init ------------------------------------------------------------- */\n\"ISREDIT (dsn) = DATASET\"\n\"ISREDIT (mem) = MEMBER\"\nIF mem = '' THEN\n   dsn_mem = \"'\" || dsn || \"'\"\nELSE\n   dsn_mem = \"'\" || dsn || \"(\" || mem || \")'\"\n\n/* Edit possible (Editmode or Viewmode) ? --------------------------- */\n\"ISPEXEC EDIT DATASET(\"dsn_mem\") MACRO(MCANCEL)\"\nIF RC = 14 THEN DO\n   zedsmsg = \"ET not possible\"\n   zedlmsg = \"Macro ET can't open\" dsn_mem\", because it is used\",\n             'by' WHOHELDS(dsn_mem)\".\"\n   \"ISPEXEC SETMSG MSG(ISRZ001)\"\n   EXIT -8\nEND\n\n/* Are there changes ? ---------------------------------------------- */\n\"ISREDIT (etchg) = DATA_CHANGED\"\n\n/* with changes ? --------------------------------------------------- */\nIF parm = '-' THEN\n   etwc = 'NO'\nELSE DO\n   etwc = 'YES'\n   IF etchg = 'YES' THEN \"ISREDIT CUT et$copy .ZF .ZL\"\nEND\n\n/* notice cursorposition, lines and columns ------------------------- */\n\"ISREDIT (lrecl) = LRECL\"\n\"ISREDIT (etrow,etcol) = CURSOR\";        IF etcol > lrecl THEN etcol = 1\n\"ISREDIT (etdl1,etdl2) = DISPLAY_LINES\"; IF rc    > 0     THEN etdl1 = 1\n\"ISREDIT (etdc1,etdc2) = DISPLAY_COLS\"\n\n/* notice all labels ------------------------------------------------ */\netlabels = ''\n\"ISREDIT LOCATE FIRST LABEL\"\nDO WHILE RC = 0\n   \"ISREDIT (top,bot) = DISPLAY_LINES\"\n   \"ISREDIT (label) = LABEL\" top\n   \"ISREDIT CURSOR =\" top 1\n   etlabels = etlabels STRIP(label) top + 0\n   \"ISREDIT RESET LABEL\" .ZCSR .ZCSR\n   \"ISREDIT LOCATE FIRST LABEL\"\nEND\n\n/* notice all excludet lines ---------------------------------------- */\netexcl = ''\n\"ISREDIT LOCATE FIRST EXCLUDED\"\nDO WHILE RC = 0\n   \"ISREDIT (top,bot) = DISPLAY_LINES\"\n   \"ISREDIT CURSOR =\" top 1\n   etexcl = etexcl top + 0\n   \"ISREDIT RESET EXCLUDED\" .ZCSR .ZCSR\n   \"ISREDIT LOCATE FIRST EXCLUDED\"\nEND\n\n/* put vars into sharedpool ----------------------------------------- */\n\"ISPEXEC VPUT (etrow,etcol,etdl1,etdc1,etwc,etchg,etlabels\",\n              \"etexcl) SHARED\"\n\n/* call edit with macro et2 ----------------------------------------- */\ntemp = 'SCRNAME EDITTHIS'\n\"ISPEXEC DISPLAY COMMAND(temp)\"\n\"ISPEXEC EDIT DATASET(\"dsn_mem\") MACRO(ET2)\"\nedit_rc = rc\nIF edit_rc = 14 THEN DO\n   zedsmsg = 'ET not possible'\n   zedlmsg = 'Dataset' dsn_mem 'in use by' WHOHELDS(dsn_mem)'.'\n   \"ISPEXEC SETMSG MSG(isrz001)\"\n   EXIT\nEND\n\n/* last message (after edit) ---------------------------------------- */\nzedsmsg = ''\nzedlmsg = 'The ET-Macro finished successful.'\n\"ISPEXEC SETMSG MSG(isrz000)\"\n\"ISREDIT CANCEL\"\n\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ET2": {"ttr": 1805, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x18\\x01\\x17\\x00_\\x01\\x17\\x00_\\t#\\x00Q\\x00Q\\x00\\x00\\xd5\\xd6\\xd9\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2017-01-05T00:00:00", "modifydate": "2017-01-05T09:23:18", "lines": 81, "newlines": 81, "modlines": 0, "user": "NORBERT"}, "text": "/* REXX ***************************************************************/\n/* -------------------------------------------------------------------*/\n/* Name:       ET2 (EditThis, part 2)                                 *//*HELP*/\n/* Short       Will be called from ET                                 *//*HELP*/\n/* Type:       REXX-Macro                                             *//*HELP*/\n/* Author:     Norbert Haas, noaDatex.de & Meik Naujeck               *//*HELP*/\n/* Syntax:     ET2                                                    *//*HELP*/\n/* Parameter:  none                                                   *//*HELP*/\n/* Remark:     Must bee called from ET, don't use it as a macro       *//*HELP*/\n/*                                                                    */\n/* Version Author        Date       Why                               */\n/* ------- ------------- ---------- --------------------------------- */\n/* V02.00  Haas          30.05.2003 english version and PASTE         */\n/*                                  (not VPASTE)                      */\n/* V01.00  Haas&Naujeck  29.04.1998 Creation                          */\n/**********************************************************************/\n\"ISREDIT MACRO\"\n\n/* edit and view not allowed ---------------------------------------- */\n\"ISREDIT DEFINE EDIT DISABLED\"\n\"ISREDIT DEFINE VIEW DISABLED\"\n\n/* load vars from shared pool --------------------------------------- */\n\"ISPEXEC VGET (etrow,etcol,etdl1,etdc1,etwc,etchg,etlabels\",\n              \"etexcl) SHARED\"\n\n/* init ------------------------------------------------------------- */\nzedsmsg = ''\nIF etwc = 'YES' & etchg = 'YES' THEN DO\n   \"ISREDIT RESET\"\n   \"ISREDIT DEL ALL NX\"\n   \"ISREDIT PASTE et$copy\"\n   zedlmsg = 'Changes (from View) have been copied to the Editor.',\n             'Continue editing or use command CANCEL to abort.'\nEND\nELSE DO\n   zedlmsg = 'Changes (from View) have not been copied to the Editor',\n             '(ET - or no changes had been made in the View).',\n             'Continue editing or use command CANCEL to abort.'\nEND\nzedlmsg = 'You are now using the Editor!' zedlmsg\n\n/* set labels ------------------------------------------------------- */\nIF etlabels /= '' THEN DO\n   zedlmsg = zedlmsg 'Some labels ('\n   DO i = 1 TO WORDS(etlabels) BY 2\n      label = WORD(etlabels,i)\n      line  = WORD(etlabels,i + 1)\n      \"ISREDIT LABEL\" line \"=\" label 0\n      zedlmsg = zedlmsg label\n   END\n   zedlmsg = zedlmsg ') have been set.'\nEND\n\n/* exclude lines ---------------------------------------------------- */\nIF etexcl /= '' THEN DO\n   DO i = 1 TO WORDS(etexcl)\n      line  = WORD(etexcl,i)\n      \"ISREDIT XSTATUS\" line  \"= X\"\n   END\n   zedlmsg = zedlmsg 'Some lines have been excluded.'\nEND\n\n/* locate at cursorposition ----------------------------------------- */\n\"ISREDIT LABEL\" etdl1 \"= .tmp\"\nIF etdl1 = 1 THEN\n   \"ISREDIT LOCATE 0\"\nELSE\n   \"ISREDIT LOCATE .tmp\"\n\n/* set cursor ------------------------------------------------------- */\nIF etrow = 1 & etcol = 0 THEN\n   et2_rc = 1\nELSE\n   et2_rc = 0\n\"ISREDIT CURSOR =\" etrow etcol\n\n/* message ---------------------------------------------------------- */\n\"ISPEXEC SETMSG MSG(isrz000)\"\n\nEXIT et2_rc\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FF": {"ttr": 1808, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x02\\x00\\x18\\x01\\x17\\x00_\\x01\\x17\\x00_\\t#\\x00'\\x00'\\x00\\x00\\xd5\\xd6\\xd9\\xc2\\xc5\\xd9\\xe3@@@\"", "ispf": {"version": "01.02", "flags": 0, "createdate": "2017-01-05T00:00:00", "modifydate": "2017-01-05T09:23:18", "lines": 39, "newlines": 39, "modlines": 0, "user": "NORBERT"}, "text": "/* REXX ------------------------------------------------------------- */\n/* Name:         FF                                                   */\n/* Type:         Macro                                                */\n/* Author:       Norbert Haas, noaDatex.de                            */\n/* Date:         22.06.2009                                           */\n/* Syntax:       FF parm                                              */\n/* Parameter:    parm = Parameter as in original FIND command         */\n/*                      except: NEXT, PREV, FIRST, LAST, ALL          */\n/* Description:  Find First                                           */\n/* Example:      FF move                                              */\n/* Hint:         Used once, you can use F5 (Repeat Find)              */\n/*                                                                    */\n/* Vers.  Datum      Autor     Grund                                  */\n/* ------ ---------- --------- -------------------------------------- */\n/* V01.03 03.02.2017 N.Haas    Englich Version and zinstr1            */\n/* V01.02 21.04.2011 N.Haas    Parameter eingepackt in Blanks         */\n/* V01.01 22.06.2009 N.Haas    Erstellung                             */\n/* ------------------------------------------------------------------ */\n\"ISREDIT MACRO (zinstr1) NOPROCESS\"\n\nnot_allowed = 'NEXT PREV FIRST LAST ALL'\n\nDO i = 1 TO WORDS(not_allowed)\n   w = \" \" || WORD(not_allowed, i) || \" \"\n   IF POS(w, TRANSLATE(\" \" || zinstr1 || \" \")) > 0 THEN DO\n      zedsmsg = \"Parm not allowed\"\n      zedlmsg = \"The parameter\" STRIP(w) \"is not allowd while\",\n                \"using FF Macro.\"\n      \"ISPEXEC SETMSG MSG(isrz001)\"\n      EXIT -1\n   END\nEND\n\n\"ISREDIT FIND FIRST\" zinstr1\nIF rc >= 4 THEN DO\n   \"ISPEXEC SETMSG MSG(ISRE164)\"\nEND\n\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FLAGCHGS": {"ttr": 2049, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x18\\x01\\x17\\x00_\\x01\\x17\\x00_\\t#\\x00\\x9e\\x00\\x9e\\x00\\x00\\xd5\\xd6\\xd9\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2017-01-05T00:00:00", "modifydate": "2017-01-05T09:23:18", "lines": 158, "newlines": 158, "modlines": 0, "user": "NORBERT"}, "text": "/* REXX ------------------------------------------------------------- */\n/* Name:         FLAGCHGS                                             */\n/* Type:         Macro                                                */\n/* Author:       Norbert Haas, noaDatex.de                            */\n/* Date:         08.02.2011                                           */\n/* Syntax:       FLAGCHGS \u00dd-/+\u00a8 \u00ddX/NX\u00a8                                */\n/*   also:       FLAGCHGS \u00ddSHOW/DO\u00a8 \u00ddX/NX\u00a8                            */\n/* Parameter:    - / SHOW = Show all then changes (default)           */\n/*               + / DO   = Mark all the changes                      */\n/* Description:  Show / mark all the changes in cobol programms in    */\n/*               column 1 - 6.                                        */\n/*                                                                    */\n/* Vers.  Datum      Autor     Grund                                  */\n/* ------ ---------- --------- -------------------------------------- */\n/* V01.08 03.01.2017 N.Haas    English version                        */\n/* V01.07 06.06.2012 N.Haas    LOCATE verbessert                      */\n/* V01.06 12.04.2012 N.Haas    LOCATE verbessert                      */\n/* V01.05 03.01.2012 N.Haas    LOCATE verbessert                      */\n/* V01.04 09.11.2011 N.Haas    X/NX eingef\u00fchrt                        */\n/* V01.03 01.06.2011 N.Haas    RES LAB raus                           */\n/* V01.02 25.02.2011 N.Haas    Parm Default = '-'                     */\n/* V01.01 08.02.2011 N.Haas    Erstellung                             */\n/* ------------------------------------------------------------------ */\n\"ISREDIT MACRO (parm) NOPROCESS\"\n\"ISREDIT (fl,ll) = DISPLAY_LINES\"\n\n/* Inits */\nTRUE  = 1\nFALSE = 0\nnot_x = FALSE\nloc   = FALSE\nset   = FALSE\n\n/* Parameter */\nparm = TRANSLATE(parm)\n\nIF parm = '' THEN DO\n   set   = FALSE\n   not_x = FALSE\nEND\nELSE DO\n   p = 0\n   DO i = 1 TO WORDS(parm)\n      SELECT\n         WHEN WORD(parm,i) = '+' | ,\n              WORD(parm,i) = 'DO' THEN DO\n            p = p + 1\n            set = TRUE\n         END\n\n         WHEN WORD(parm,i) = '-' | ,\n              WORD(parm,i) = 'SHOW' THEN DO\n            p = p + 1\n            set = FALSE\n         END\n\n         WHEN WORD(parm,i) = 'X' THEN DO\n            p = p + 1\n            not_x = FALSE\n            loc   = FALSE\n         END\n\n         WHEN WORD(parm,i) = 'NX' THEN DO\n            p = p + 1\n            not_x = TRUE\n            loc   = FALSE\n         END\n\n         WHEN WORD(parm,i) = 'L'  |,\n              WORD(parm,i) = 'GO' THEN DO\n            p = p + 1\n            not_x = TRUE\n            loc   = TRUE\n         END\n\n         OTHERWISE DO\n            zedsmsg = 'Wrong parm'\n            zedlmsg = 'Macro FLAGCHGS allows the following parms:',\n                      '\"+\", \"-\" equal to \"DO\", \"SHOW\" and \"X\" or \"NX\".'\n            \"ISPEXEC SETMSG MSG(ISRZ001)\"\n            EXIT -1\n         END\n      END\n   END\nEND\n\nIF p > 2 THEN DO\n   zedsmsg = 'Wrong number of parms'\n   zedlmsg = 'Macro FLAGCHGS allows only two parms, which can be:',\n             '\"+\", \"-\" equal to \"DO\", \"SHOW\" and \"X\" or \"NX\"',\n             'or \"L\" (also \"GO\").'\n   \"ISPEXEC SETMSG MSG(ISRZ001)\"\n   EXIT -1\nEND\n\n/* Date */\nPARSE VALUE DATE('E') WITH t '/' m '/' j\ncf = \"CHG==>\"\n\n/* All lines */\nfirst = 1\n\"ISREDIT (last) = LINENUM .ZL\"\n\"ISREDIT RES X\"\n\n/* More inits */\nchanges = FALSE\n\"ISREDIT (df,dl) = DISPLAY_LINES\"\n\n/* Collect information */\nDO i = first TO last\n   \"ISREDIT (info) = LINE_STATUS (i)\"\n   IF SUBSTR(info,1,1) = 0 |,                    /* Not original line */\n      SUBSTR(info,8,1) = 1 THEN DO               /* Line was changed  */\n      \"ISREDIT XSTATUS (i) = X\"\n      changes = TRUE\n   END\nEND\n\"ISREDIT HIDE X\"\n\n/* Message */\nIF changes THEN DO\n   \"ISREDIT FLIP\"\n   IF set THEN DO\n      \"ISREDIT (a,b) = NUMBER\"\n      \"ISREDIT NUMBER OFF\"\n      \"ISREDIT C ALL p'======' 1 '\"cf\"' .ZF .ZL NX\"\n      \"ISREDIT NUMBER\" a b\n      \"ISREDIT RES C\"\n      \"ISREDIT RES X\"\n      CALL DispMsg '',,\n                   \"All changed lines have been flagged with '\"cf\"'.\",,\n                   FALSE\n      \"ISREDIT FIND FIRST '\"cf\"' 1\"\n      IF not_x THEN \"ISREDIT RES X\"\n      \"ISREDIT LOCATE\" df\n      IF df + 0 = 1 THEN \"ISREDIT UP 1\"\n      EXIT 0\n   END\n   ELSE DO\n      CALL DispMsg '',,\n                   \"The current visible lines have been changed and\",\n                   \"can be flagged with '\"cf\"' using 'FLAGCHGS +'.\",,\n                   FALSE\n      \"ISREDIT LOCATE 0\"\n      EXIT 1\n   END\n   \"ISREDIT LOCATE\" fl\nEND\nELSE DO\n  \"ISREDIT RES X\"\n   CALL DispMsg '',,\n                'There are no changes'.,,\n                FALSE\nEND\n\nIF loc THEN \"ISREDIT LOCATE\" fl\n\nEXIT 1\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FSCREEN": {"ttr": 2053, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00P\\x01\\x16(\\x1f\\x01\\x16(\\x1f\\x001\\x009\\x009\\x00\\x00\\xd5\\xd6\\xd9\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-10-07T00:00:00", "modifydate": "2016-10-07T00:31:50", "lines": 57, "newlines": 57, "modlines": 0, "user": "NORBERT"}, "text": "/* REXX ------------------------------------------------------------- */\n/* Name:       FSCREEN                                                */\n/* Short:      Find chars an the screen                               */\n/* Type:       REXX-Exec                                              */\n/* Author:     Norbert Haas                                           */\n/* Syntax:     TSO %FSCREEN string                                    */\n/* Requiers:   Function NOT()                                         */\n/* Remark:     Contains two undocumented ISPF-Vars                    */\n/* 1) zscreeni = The whole content of the screen, beginning from the  */\n/*               upper left corner to the lower right corner.         */\n/* 2) zscreenc = The cursor position as number between 0 and max,     */\n/*               where max is lines * columns - 1.                    */\n/*    zscreenw = Screen width (i.E. 80, 132 depending on logmode)     */\n/*                                                                    */\n/* Version Author        Date       Why                               */\n/* ------- ------------- ---------- --------------------------------- */\n/* V01.00  N.Haas        06.06.2003 Creation                          */\n/* ------------------------------------------------------------------ */\n\n/* Fetch string */\nPARSE ARG string\n\n/* Init */\nzedsmsg = ''\nzedlmsg = ''\nTRUE    = 1\nFALSE   = 0\nfound   = FALSE\n\n/* Fetch screen, cursorposition and screenwidth */\n\"ISPEXEC VGET (zscreeni,zscreenc,zscreenw)\"\n\n/* Find the first string */\np = POS(string, zscreeni)\nIF p > 0 THEN DO\n   DO WHILE p > 0\n      IF p + LENGTH(string) - 1 = zscreenc THEN NOP\n      ELSE DO\n         row = TRUNC(p / zscreenw)\n         col = p - (row * zscreenw)\n         IF zedlmsg = '' THEN DO\n            zedlmsg = 'String found in (row,col):'\n            found = TRUE\n         END\n         zedlmsg = zedlmsg '('row + 1','col')'\n      END\n      /* Find the next string */\n      p = POS(string, zscreeni, p + 1)\n   END\nEND\nIF NOT(found) THEN DO\n   zedlmsg = 'String not found.'\nEND\n\n\"ISPEXEC SETMSG MSG(isrz000)\"\n\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INCL": {"ttr": 2055, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x18\\x01\\x17\\x00_\\x01\\x17\\x00_\\t#\\x00\\x17\\x00\\x17\\x00\\x00\\xd5\\xd6\\xd9\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2017-01-05T00:00:00", "modifydate": "2017-01-05T09:23:18", "lines": 23, "newlines": 23, "modlines": 0, "user": "NORBERT"}, "text": "/* REXX ***************************************************************/\n/* -------------------------------------------------------------------*/\n/* Name:       INCL                                                   */\n/* Short:      Include (Opposite of EXCLUDE)                          */\n/* Typ:        REXX-Macro                                             */\n/* Author:     Norbert Haas, noaDatex.de                              */\n/* Function:   Excludes all line, that do not contain <parm>          */\n/* Syntax:     INCL parm \u00ddoptional parms\u00a8                             */\n/* Parameter:  parm = string to find                                  */\n/*             optional parm = parms used with findcommand            */\n/* Example:    INCL dd word                                           */\n/*                                                                    */\n/* Version   Autor         Datum     Anlass                           */\n/* --------- ------------- --------- -------------------------------- */\n/* V01.01    N.Haas        30.05.03  english version                  */\n/* V01.00    N.Haas        22.12.92  Erstellung                       */\n/**********************************************************************/\n\"ISREDIT MACRO (parm)\"\n\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT FIND ALL\" parm\n\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INTER": {"ttr": 2057, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x18\\x01\\x17\\x00_\\x01\\x17\\x00_\\t#\\x00+\\x00+\\x00\\x00\\xd5\\xd6\\xd9\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2017-01-05T00:00:00", "modifydate": "2017-01-05T09:23:18", "lines": 43, "newlines": 43, "modlines": 0, "user": "NORBERT"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "KILL": {"ttr": 2059, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x18\\x01\\x17\\x00_\\x01\\x17\\x00_\\t#\\x00s\\x00s\\x00\\x00\\xd5\\xd6\\xd9\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2017-01-05T00:00:00", "modifydate": "2017-01-05T09:23:18", "lines": 115, "newlines": 115, "modlines": 0, "user": "NORBERT"}, "text": "/* REXX ***************************************************************/\n/* -------------------------------------------------------------------*/\n/* Function:   Deletes (!!!) the member beeining edited. Can be used  */\n/*             only in members of PDS, not in seq. datasets.          */\n/* Syntax:     KILL \u00ddmember\u00a8                                          */\n/* Parameter:  member = Membername of an other member of ths same PDS */\n/* Author:     Norbert Haas, noaDatex.de                              */\n/* Beispiele:  KILL                                                   */\n/*             KILL x4lodi                                            */\n/*                                                                    */\n/* Version  Autor         Datum     Anlass                            */\n/* -------- ------------- --------- --------------------------------- */\n/* V02.01   N.Haas        11.06.03  english version                   */\n/* V02.00   N.Haas        15.11.00  mit Parameter member              */\n/* V01.03   N.Haas        14.06.96  DSN wird angezeigt                */\n/* V01.02   N.Haas        21.12.95  NOENQ eingebaut bei LMMDEL        */\n/* V01.01   N.Haas        09.12.92  Fehler behoben, LMCLOSE/FREE nach */\n/*                                  RC bei LMDEL notwendig            */\n/* V01.00   N.Haas        30.06.92  Erstellung (Ursprung John Paryman)*/\n/**********************************************************************/\n\"ISREDIT MACRO (parm)\"\n\n\"ISPEXEC CONTROL ERRORS RETURN\"\n\n/* translate parms to upper case */\nparm = TRANSLATE(parm)\n\n/* parameter ? */\nIF WORDS(parm) > 1 THEN DO\n   zedsmsg = 'WRONG PARAMETER'\n   zedlmsg = 'MACRO KILL DOES NOT SUPPORT MORE THAN ONE PARAMETER.'\n   \"ISPEXEC SETMSG MSG(ISRZ001)\"\n   EXIT -8\nEND\n\n/* dsn and membername */\n\"ISREDIT (dsn) = DATASET\"\nIF parm = '' THEN DO\n   \"ISREDIT (mem) = MEMBER\"\n   dsnmem = \"'\"dsn\"(\"mem\")'\"\nEND\nELSE DO\n   mem = parm\n   dsnmem = \"'\"dsn\"(\"mem\")'\"\n   tmp = SYSDSN(dsnmem)\n   IF tmp /= 'OK' THEN DO\n      zedsmsg = ''\n      zedlmsg = tmp\n      \"ISPEXEC SETMSG MSG(ISRZ001)\"\n      EXIT -8\n   END\n   ELSE DO\n      tmp = OUTTRAP('dummy.')\n      \"DELETE\" dsnmem\n      lmrc = rc\n      tmp = OUTTRAP('OFF')\n      zedsmsg = 'MEMBER' mem 'KILLED'\n      zedlmsg = 'MEMBER' mem 'HAS BEEN REMOVED FROM DATASET' dsn'.'\n      SIGNAL Ente\n   END\nEND\n\n/* Dataset sequential ? */\ntmp = \"'\" || dsn || \"'\"\ndmy = LISTDSI(tmp)\nIF SUBSTR(sysdsorg,1,2) /= 'PO' THEN DO\n   zedsmsg = 'DATASET NOT PARTITIONED'\n   zedlmsg = 'MACRO KILL CAN ONLY BE USED ON PARTITIONED DATASET.'\n   \"ISPEXEC SETMSG MSG(ISRZ001)\"\n   EXIT -8\nEND\n\n/* LMINIT-Routine --------------------------------------------------- */\n\"ISPEXEC LMINIT DATAID(dsid) DATASET('\"dsn\"') ENQ(SHRW)\"\nIF rc /= 0 THEN DO\n   zedsmsg = 'LMINIT FAILED WITH RC' rc\n   zedlmsg = 'MACRO KILL HAS GOT AN RC OF' rc 'USING LMINIT.'\n   \"ISPEXEC SETMSG MSG(ISRZ001)\"\n   EXIT -8\nEND\n\n/* LMOPEN-Routine --------------------------------------------------- */\n\"ISPEXEC LMOPEN DATAID(\"dsid\") OPTION(OUTPUT)\"\nIF rc /= 0 THEN DO\n   zedsmsg = 'LMOPEN FAILED WITH RC' rc\n   zedlmsg = 'MACRO KILL HAS GOT AN RC OF' rc 'USING LMOPEN.'\n   \"ISPEXEC SETMSG MSG(ISRZ001)\"\n   EXIT -8\nEND\n\n/* LMMDEL-Routine --------------------------------------------------- */\n\"ISPEXEC LMMDEL DATAID(\"dsid\") MEMBER(\" mem \") NOENQ\"\nlmrc = rc\nIF lmrc /= 0 THEN DO\n   zedsmsg = 'MEMBER' mem 'CANCELED'\n   zedlmsg = 'MEMBER' mem 'HAD NEVER NEVER NEVER BEEN SAVED.'\nEND\nELSE DO\n   zedsmsg = 'MEMBER' mem 'KILLED'\n   zedlmsg = 'MEMBER' mem 'HAS BEEN REMOVED FROM DATASET' tmp'.'\nEND\n\n/* LMCLOSE / LMFREE Routine if OK */\n\"ISPEXEC LMCLOSE DATAID(\"dsid\")\"\n\"ISPEXEC LMFREE DATAID(\"dsid\")\"\n\n/* CANCEL it */\n\"ISREDIT CANCEL\"\n\n/* Positive Message */\nEnte:\n\"ISPEXEC SETMSG MSG(ISRZ000)\"\n\n/* this is it */\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "KONKAT": {"ttr": 2062, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x18\\x01\\x17\\x00_\\x01\\x17\\x00_\\t#\\x00\\x15\\x00\\x15\\x00\\x00\\xd5\\xd6\\xd9\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2017-01-05T00:00:00", "modifydate": "2017-01-05T09:23:18", "lines": 21, "newlines": 21, "modlines": 0, "user": "NORBERT"}, "text": "/* REXX ------------------------------------------------------------- */\n/* Name:       KONKAT                                                 */\n/* Short:      Conkatination of strings or vars                       */\n/*             same as: string1 !! string2                            */\n/*         or  same as: string1 || string2                            */\n/* Type:       REXX-Funktion                                          */\n/* Author:     Norbert Haas, noaDatex.de                              */\n/* Input:      2 .. n Strings (constant or var)                       */\n/* Output:     Concatination of input                                 */\n/* Advantage:  Chars >!< od >|< are not needed (different machines)   */\n/*                                                                    */\n/* Version Author        Date       Why                               */\n/* ------- ------------- ---------- --------------------------------- */\n/* V01.01  N.Haas        28.05.2003 remarks in english                */\n/* V01.00  N.Haas        05.02.2003 Erstellung                        */\n/* ------------------------------------------------------------------ */\nstring = ''\nDO i = 1 TO ARG()\n   string = string''ARG(i)\nEND\nEXIT string\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LASTWORD": {"ttr": 2064, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x18\\x01\\x17\\x00_\\x01\\x17\\x00_\\t#\\x00\\x0f\\x00\\x0f\\x00\\x00\\xd5\\xd6\\xd9\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2017-01-05T00:00:00", "modifydate": "2017-01-05T09:23:18", "lines": 15, "newlines": 15, "modlines": 0, "user": "NORBERT"}, "text": "/* REXX ------------------------------------------------------------- */\n/* Name:         LASTWORD                                             */\n/* Type:         Function                                             */\n/* Author:       Norbert Haas, noaDatex.de                            */\n/* Date:         09.07.2013                                           */\n/* Syntax:       x = LASTWORD(string)                                 */\n/* Parameter:    string                                               */\n/* Description:  Returns lastword of a sentence                       */\n/*                                                                    */\n/* Vers.  Datum      Autor     Grund                                  */\n/* ------ ---------- --------- -------------------------------------- */\n/* V01.01 09.07.2013 N.Haas    Erstellung                             */\n/* ------------------------------------------------------------------ */\nPARSE ARG string\nEXIT WORD(string,WORDS(string))\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LCL": {"ttr": 2066, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x18\\x01\\x17\\x00_\\x01\\x17\\x00_\\t#\\x002\\x002\\x00\\x00\\xd5\\xd6\\xd9\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2017-01-05T00:00:00", "modifydate": "2017-01-05T09:23:18", "lines": 50, "newlines": 50, "modlines": 0, "user": "NORBERT"}, "text": "/* REXX ***************************************************************/\n/*%COPYRIGHT (C) Norbert Haas, U.N.P. - Software GmbH                 */\n/* -------------------------------------------------------------------*/\n/* Name:       LCL Long CommandLine                                   */\n/* Short:      gives you a long command line                          */\n/* Type:       REXX-Macro                                             */\n/* Author:     Norbert Haas, noaDatex.de                              */\n/* Syntax:     LCL                                                    */\n/* Parameter:  none                                                   */\n/*                                                                    */\n/* Version Autor         Datum      Anlass                            */\n/* ------- ------------- ---------- --------------------------------- */\n/* V02.03  N.Haas        02.01.2017 englich version                   */\n/* V02.02  N.Haas        11.01.2008 Zweite Eingabezeile               */\n/* V02.01  N.Haas        24.02.2003 Panel ganz nach unten             */\n/* V02.00  N.Haas        10.09.2002 zuz}glich 10 \"alte\" Zeilen        */\n/* V01.00  N.Haas        04.07.2002 Erstellung                        */\n/**********************************************************************/\n\"ISREDIT MACRO\"\n\"ISPEXEC VGET (lcl01, lcl02, lcl03, lcl04, lcl05) PROFILE\"\n\"ISPEXEC VGET (lcl06, lcl07, lcl08, lcl09, lcl10) PROFILE\"\n\"ISPEXEC VGET (zscreend,zscreenw)\"\n\n\"ISPEXEC ADDPOP ROW(\"zscreend-24\") COLUMN(0)\"\nShow_Panel:\n\"ISPEXEC DISPLAY PANEL(LCLP)\"\n\nIF rc = 0 THEN DO\n   IF cursor = 'RETRIEVE' THEN SIGNAL Show_Panel\n\n   IF cmd2 /= \"\" THEN DO\n      cmd = cmd || cmd2\n      cmd2 = \"\"\n   END\n\n   IF TRANSLATE(LEFT(cmd,1)) = \"F\" &,\n      LEFT(WORD(cmd, 2),1) /= \"'\" &,\n      LEFT(WORD(cmd, 2),1) /= '\"' THEN cmd = \"F '\"SUBSTR(cmd, 3)\"'\"\n\n   \"ISREDIT\" cmd\n   DO i = 10 TO 2 BY -1\n      ii = TRANSLATE(FORMAT(i,  2),'0',' ')\n      jj = TRANSLATE(FORMAT(i-1,2),'0',' ')\n      INTERPRET \"lcl\"ii\" = lcl\"jj\n   END\n   lcl01 = cmd\n   \"ISPEXEC VPUT (lcl01, lcl02, lcl03, lcl04, lcl05) PROFILE\"\n   \"ISPEXEC VPUT (lcl06, lcl07, lcl08, lcl09, lcl10) PROFILE\"\nEND\n\"ISPEXEC REMPOP\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LCLP": {"ttr": 2068, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00A\\x01\\x17\\x00_\\x01\\x17\\x00_\\t\\x10\\x00L\\x00L\\x00\\x00\\xd5\\xd6\\xd9\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2017-01-05T00:00:00", "modifydate": "2017-01-05T09:10:41", "lines": 76, "newlines": 76, "modlines": 0, "user": "NORBERT"}, "text": ")PANEL KEYLIST(ISRSNAB,ISR)\n)ATTR DEFAULT(%+_)\n  % TYPE(ET)                                       /* Emphasized Text */\n  \u00e4 TYPE(FP)                                          /* Field Prompt */\n  _ TYPE(NEF) CAPS(OFF)                         /* Normal Entry Field */\n  \u00a6 TYPE(INPUT) CAPS(OFF) COLOR(TURQ)           /* Normal Entry Field */\n  + TYPE(NT)                                           /* Normal Text */\n  \u00d6 TYPE(PIN)                                    /* Panel Instruction */\n  ! TYPE(TEXT) SKIP(ON)\n  @ AREA(SCRL) EXTEND(ON)                               /* Scrollarea */\n)BODY EXPAND(``) WINDOW(77,20)\n+\n+COMMAND ===>_ZCMD                                                          +\n+\n\u00d6Enter your editor command into the following two lines. The command will be\n\u00d6done after pressing Enter.\n+\n_cmd                                                                        !\n_cmd2                                                                       +\n+\n+ Place cursor on choice and press enter to retrieve command\n@SCROLLI                                                                    @\n)AREA SCROLLI\n+=>\u00a6lcl01                                                                   +\n+=>\u00a6lcl02                                                                   +\n+=>\u00a6lcl03                                                                   +\n+=>\u00a6lcl04                                                                   +\n+=>\u00a6lcl05                                                                   +\n+=>\u00a6lcl06                                                                   +\n+=>\u00a6lcl07                                                                   +\n+=>\u00a6lcl08                                                                   +\n+=>\u00a6lcl09                                                                   +\n+=>\u00a6lcl10                                                                   +\n+\n+\n+\n+\n)INIT\n   &ZWINTTL = ' Long Command Line '\n   .CURSOR = 'cmd'\n)PROC\n   &ZWINTTL = ''\n   &cursor = ''\n\n   IF (.CURSOR = lcl01)\n     &cmd = &lcl01\n     &cursor = 'RETRIEVE'\n   IF (.CURSOR = lcl02)\n     &cmd = &lcl02\n     &cursor = 'RETRIEVE'\n   IF (.CURSOR = lcl03)\n     &cmd = &lcl03\n     &cursor = 'RETRIEVE'\n   IF (.CURSOR = lcl04)\n     &cmd = &lcl04\n     &cursor = 'RETRIEVE'\n   IF (.CURSOR = lcl05)\n     &cmd = &lcl05\n     &cursor = 'RETRIEVE'\n   IF (.CURSOR = lcl06)\n     &cmd = &lcl06\n     &cursor = 'RETRIEVE'\n   IF (.CURSOR = lcl07)\n     &cmd = &lcl07\n     &cursor = 'RETRIEVE'\n   IF (.CURSOR = lcl08)\n     &cmd = &lcl08\n     &cursor = 'RETRIEVE'\n   IF (.CURSOR = lcl09)\n     &cmd = &lcl09\n     &cursor = 'RETRIEVE'\n   IF (.CURSOR = lcl10)\n     &cmd = &lcl10\n     &cursor = 'RETRIEVE'\n   VER (&cmd,NB)\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LINFO": {"ttr": 2307, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x18\\x01\\x17\\x00_\\x01\\x17\\x00_\\t#\\x00\\xaa\\x00\\xaa\\x00\\x00\\xd5\\xd6\\xd9\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2017-01-05T00:00:00", "modifydate": "2017-01-05T09:23:18", "lines": 170, "newlines": 170, "modlines": 0, "user": "NORBERT"}, "text": "/* REXX ------------------------------------------------------------- */\n/* Macro:         LINFO (Line INFO)                                   */\n/* Syntax (1):    LINFO zn                                            */\n/*        (2)     LINFO zn1 zn2 | LINFO ALL                           */\n/* Paramater:     zn, zn1, zn2 = linenumber / Label                   */\n/* Function (1):  shows status information about one line             */\n/*          (2):  shows status information about some lines           */\n/* Author:        Norbert Haas, noaDatex.de                           */\n/* Examples:      - LINFO 12                                          */\n/*                - LINFO .X                                          */\n/*                - LINFO .zf .zl                                     */\n/*                - LINFO ALL                                         */\n/*                                                                    */\n/* Version Autor         Datum      Anlass                            */\n/* ------- ------------- ---------- --------------------------------- */\n/* V02.01  N.Haas        30.05.2003 english version                   */\n/* V02.00  N.Haas        19.11.2002 auch zwei Zeilen, Bereich         */\n/* V01.00  N.Haas        15.11.2002 Erstellung                        */\n/* ------------------------------------------------------------------ */\n\n/* receive linenumer(s) */\n\"ISREDIT MACRO (fromline,toline,dummy) NOPROCESS\"\n\n/* dummy must not exist */\nIF dummy /= \"\" THEN DO\n   zedsmsg = 'PARAMETER WRONG'\n   zedlmsg = 'MACRO LINFO DOES NOT NEED MORE THAN TWO PARMS.'\n   \"ISPEXEC SETMSG MSG(ISRZ001)\"\n   EXIT 12\nEND\n\n/* ALL ? */\nIF TRANSLATE(fromline) = 'ALL' THEN DO\n   fromline = '.ZF'\n   toline = '.ZL'\nEND\n\n/* fromline must exist an be numeric or existing label */\nIF fromline = \"\" THEN DO\n   zedsmsg = 'PARAMETER MISSING'\n   zedlmsg = 'MACRO LINFO NEEDS TWO LINENUMBERS/LABELS TO',\n             'WORK WITH.'\n   \"ISPEXEC SETMSG MSG(ISRZ001)\"\n   EXIT 12\nEND\nlfromline = TRANSLATE(fromline)\n\n/* linenumer ist number or label ? */\nIF DATATYPE(fromline) = 'NUM' THEN DO                     /* number ? */\n   \"ISREDIT (last) = LINENUM .ZL\"\n   IF fromline > last THEN fromline = last\n   IF fromline < 1 THEN fromline = 1\nEND\nELSE DO                                                    /* label ? */\n   \"ISREDIT (fromline) = LINENUM (fromline)\"\n   IF fromline = 0 THEN DO\n      zedsmsg = 'LABEL NOT FOUND'\n      zedlmsg = 'THE LABEL YOU ENTERED ('lfromline') DOES',\n                'NOT EXIST.'\n      \"ISPEXEC SETMSG MSG(ISRZ001)\"\n      EXIT 12\n   END\nEND\n\n/* secound parm ? */\nIF toline /= \"\" THEN DO\n   ltoline = TRANSLATE(toline)\n   IF DATATYPE(toline) = 'NUM' THEN DO                    /* number ? */\n      \"ISREDIT (last) = LINENUM .ZL\"\n      IF toline > last THEN toline = last\n      IF toline < 1 THEN toline = 1\n   END\n   ELSE DO                                                 /* label ? */\n      \"ISREDIT (toline) = LINENUM (toline)\"\n      IF toline = 0 THEN DO\n         zedsmsg = 'LABEL NOT FOUND'\n         zedlmsg = 'THE LABEL YOU ENTERED ('ltoline') DOES',\n                   'NOT EXIST.'\n         \"ISPEXEC SETMSG MSG(ISRZ001)\"\n         EXIT 12\n      END\n   END\n\n   /* swap from and to ? */\n   IF fromline > toline THEN DO\n      tmp = fromline\n      fromline = toline\n      toline = tmp\n   END\nEND\n\n/* text to 14 from 32 byte */\ntext.   = ''\ntext.1  = 'Line is an original record'\ntext.2  = 'Line was created by the Move line command'\ntext.3  = 'Line was created by the Copy or Repeat line command'\ntext.4  = 'Line was created by the MOVE primary or macro',\n          'command'\ntext.5  = 'Line was created by the COPY primary or macro',\n          'command'\ntext.6  = 'Line was created by the TE line command'\ntext.7  = 'Line was created by the Insert line command'\ntext.8  = 'Line was changed'\ntext.9  = 'Data on the line was typed over'\ntext.10 = 'Data was changed by the CHANGE primary command or',\n          'the Overlay line command'\ntext.11 = 'Data was changed by the Column Shift line command',\n          'used the (, ((, ), or )) command'\ntext.12 = 'Data was changed by the Data Shift line command',\n          'used the <, <<, >, or >> command'\ntext.13 = 'Data was changed by the TE, TF, or TS line command'\ntext.14 = 'The line was renumbered'\n\n/* more inits */\nTRUE    = 1\nFALSE   = 0\nchanges = FALSE\nj       = 1\nmsg.    = ''\nIF toline /= \"\" THEN msg.j     = 'Following lines have been hanged',\n                                 '(Range 'fromline+0'-'toline+0'):'\nnochang = 'No lines have been changed.'\nlineal  = COPIES('-',72)\n\nIF toline /= \"\" THEN DO                                      /* range */\n   /* collect information over the range ... */\n   DO i = fromline TO toline\n      \"ISREDIT (info) = LINE_STATUS (i)\"\n      IF SUBSTR(info,8,1) = 1 THEN DO\n         msg.j = msg.j   i\n         changes = TRUE\n      END\n      IF LENGTH(msg.j) > = 68 THEN j = j + 1\n   END\n\n   /* ... and display as ==MSG> lines */\n   \"ISREDIT (first,dummy) = DISPLAY_LINES\"\n   \"ISREDIT RES SPECIAL\"\n   \"ISREDIT LINE_AFTER (first) = MSGLINE (lineal)\"\n   IF changes THEN DO\n      DO i = j TO 1 BY -1\n          zeile = msg.i\n          \"ISREDIT LINE_AFTER (first) = MSGLINE (zeile)\"\n      END\n   END\n   ELSE DO\n      \"ISREDIT LINE_AFTER (first) = MSGLINE (nochang)\"\n   END\n\n   \"ISREDIT LINE_AFTER (first) = MSGLINE (lineal)\"\nEND\nELSE DO                                              /* just one line */\n   /* collect information over one line */\n   \"ISREDIT (info) = LINE_STATUS (fromline)\"\n\n   /* collect longmessage ... */\n   zedlmsg = 'Line' fromline+0':'\n   DO i = 1 TO 14\n      bit = SUBSTR(info,i,1)                           /* bit = 1 / 0 */\n      IF bit THEN DO\n         zedlmsg = zedlmsg text.i\".\"\n      END\n   END\n\n   /* ... and show it */\n   zedsmsg = ''\n   \"ISPEXEC SETMSG MSG(ISRZ000)\"\nEND\n\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MCANCEL": {"ttr": 2311, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x18\\x01\\x17\\x00_\\x01\\x17\\x00_\\t#\\x00\\x0f\\x00\\x0f\\x00\\x00\\xd5\\xd6\\xd9\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2017-01-05T00:00:00", "modifydate": "2017-01-05T09:23:18", "lines": 15, "newlines": 15, "modlines": 0, "user": "NORBERT"}, "text": "/* REXX ***************************************************************/\n/* -------------------------------------------------------------------*/\n/* Name:       MCANCEL                                                */\n/* Short:      Does nothing                                           */\n/* Type:       REXX-Macro                                             */\n/* Author:     Norbert Haas, noaDatex.de                              */\n/* Function:   None                                                   */\n/*                                                                    */\n/* Version Author        Date       Why                               */\n/* ------- ------------- ---------- --------------------------------- */\n/* V01.00  N.Haas        30.05.2003 Erstellung                        */\n/**********************************************************************/\n\"ISREDIT MACRO\"\n\"ISREDIT CANCEL\"\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MIRACLE": {"ttr": 2313, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x18\\x01\\x17\\x00_\\x01\\x17\\x00_\\t#\\x00\\x04\\x00\\x04\\x00\\x00\\xd5\\xd6\\xd9\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2017-01-05T00:00:00", "modifydate": "2017-01-05T09:23:18", "lines": 4, "newlines": 4, "modlines": 0, "user": "NORBERT"}, "text": "/* REXX */ ADDRESS ISREDIT; \"MACRO NOPROCESS\"; \"(THEN) = LINENUM .ZF\"\n\"(ELSE) = LINENUM .ZL\"; DO IF = THEN TO ELSE; \"(WORD) = LINE (IF)\"\nPARSE.IF = REVERSE(WORD); END; EXIT = 0; DO IF = ELSE TO THEN BY -1\nEXIT = EXIT + 1; SUBSTR = PARSE.IF; \"LINE\" EXIT \"= (SUBSTR)\"; END; EXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "NOT": {"ttr": 2315, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x18\\x01\\x17\\x00_\\x01\\x17\\x00_\\t#\\x00\\x17\\x00\\x17\\x00\\x00\\xd5\\xd6\\xd9\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2017-01-05T00:00:00", "modifydate": "2017-01-05T09:23:18", "lines": 23, "newlines": 23, "modlines": 0, "user": "NORBERT"}, "text": "/* REXX ------------------------------------------------------------- */\n/* Name:       NOT                                                    */\n/* Short:      Negates the argument                                   */\n/*             Same as: \u00ac arg                                         */\n/* Type:       REXX-Function                                          */\n/* Author:     Norbert Haas, noaDatex.de                              */\n/* Input:      1/0                                                    */\n/* Output:     0/1                                                    */\n/* Advantage:  No special characters are needed.                      */\n/*                                                                    */\n/* Version Author        Date       Why                               */\n/* ------- ------------- ---------- --------------------------------- */\n/* V01.00  N.Haas        06.06.2003 Creationng                        */\n/* ------------------------------------------------------------------ */\nPARSE ARG parm\n\nIF parm = 1 THEN EXIT 0\nELSE\n   IF parm = 0 THEN EXIT 1\n   ELSE DO\n      SAY 'Wrong parameter, not 1 or 0, but' parm\n      EXIT 0\n   END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ODER": {"ttr": 2317, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x18\\x01\\x17\\x00_\\x01\\x17\\x00_\\t#\\x00\\x1b\\x00\\x1b\\x00\\x00\\xd5\\xd6\\xd9\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2017-01-05T00:00:00", "modifydate": "2017-01-05T09:23:18", "lines": 27, "newlines": 27, "modlines": 0, "user": "NORBERT"}, "text": "/* REXX ------------------------------------------------------------- */\n/* Name:       ODER                                                   */\n/* Function:   OR                                                     */\n/*             same as: a = b ! c = d                                 */\n/*         or  same as: a = b | c = d                                 */\n/* Type:       REXX-Funktion                                          */\n/* Author:     Norbert Haas, noaDatex.de                              */\n/* Input:      2 .. n comparisons                                     */\n/* Output:     0 / 1 (False / True)                                   */\n/* Example:    IF ODER(a = 1, b = 2) THEN ...                         */\n/* Advantage:  Chars >!< od >|< are not needed (different machines)   */\n/*                                                                    */\n/* Version Author        Date       Why                               */\n/* ------- ------------- ---------- --------------------------------- */\n/* V01.01  N.Haas        28.05.2003 remarks in english                */\n/* V01.00  N.Haas        05.02.2003 Erstellung                        */\n/* ------------------------------------------------------------------ */\nbool = 0\nDO i = 1 TO ARG()\n   bool = bool + ARG(i)\nEND\n\nIF bool > 0 THEN\n   rc = 1\nELSE\n   rc = 0\nEXIT rc\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ONLY": {"ttr": 2319, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x18\\x01\\x17\\x00_\\x01\\x17\\x00_\\t#\\x00\\x19\\x00\\x19\\x00\\x00\\xd5\\xd6\\xd9\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2017-01-05T00:00:00", "modifydate": "2017-01-05T09:23:18", "lines": 25, "newlines": 25, "modlines": 0, "user": "NORBERT"}, "text": "/* REXX ***************************************************************/\n/* -------------------------------------------------------------------*/\n/* Name:       ONLY                                                   */\n/* Short:      ONLY (See INCL)                                        */\n/* Typ:        REXX-Macro                                             */\n/* Author:     Norbert Haas, noaDatex.de                              */\n/* Function:   Excludes all line, that do not contain <parm> and      */\n/*             hides all excludet lines                               */\n/* Syntax:     ONLY parm \u00ddoptional parms\u00a8                             */\n/* Parameter:  parm = string to find                                  */\n/*             optional parm = parms used with findcommand            */\n/* Example:    ONLY dd word                                           */\n/*                                                                    */\n/* Version   Autor         Datum     Anlass                           */\n/* --------- ------------- --------- -------------------------------- */\n/* V01.01    N.Haas        30.05.03  english version                  */\n/* V01.00    N.Haas        22.12.92  Erstellung                       */\n/**********************************************************************/\n\"ISREDIT MACRO (parm)\"\n\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT FIND ALL\" parm\n\"ISREDIT HIDE X\"\n\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PACKCHG": {"ttr": 2321, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0e\\x00\\x18\\x01\\x17\\x00_\\x01\\x17\\x00_\\t#\\x01N\\x01N\\x00\\x00\\xd5\\xd6\\xd9\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.14", "flags": 0, "createdate": "2017-01-05T00:00:00", "modifydate": "2017-01-05T09:23:18", "lines": 334, "newlines": 334, "modlines": 0, "user": "NORBERT"}, "text": "/* REXX ------------------------------------------------------------- */\n/* Name:         PACKCHG                                              */\n/* Type:         Exec                                                 */\n/* Author:       Norbert Haas, noaDatex.de                            */\n/* Datum:        24.08.2016                                           */\n/* Syntax:       TSO PACKCHG                                          */\n/* Parameter:    none                                                 */\n/* Description:  Changes in (all) members of a PDS (dsn = ...) the    */\n/*               string f$ by c$ (WORD). Uses PACMCHGM for that       */\n/* Remark:       See lines with $$$ and change if neccessary          */\n/*                                                                    */\n/* Vers.  Datum      Autor     Grund                                  */\n/* ------ ---------- --------- -------------------------------------- */\n/* V03.02 20.12.2016 N.Haas    Translated into English                */\n/* V03.01 21.11.2016 N.Haas    Weitere Eingabefelder abarbeiten       */\n/* V02.01 02.09.2016 N.Haas    Jetzt auch mit Spaltenangabe und \u00a7\u00a7\u00a7   */\n/* V01.01 24.08.2016 N.Haas    Erstellung (Kopie und Erweiterung des  */\n/*                             RUDELCHG vom 22.01.2015)               */\n/* ------------------------------------------------------------------ */\nSIGNAL ON NOVALUE\nSIGNAL ON SYNTAX\n\nTRUE     = 1\nFALSE    = 0\nxc1      = '7D'x /* ' Single quote */\nxc2      = '59'x /* \u00df Tilde        */\nxc3      = 'EC'x /* \u00d6 Back slash   */\ncollect. = \"\"                       /* Collection of the member names */\nj.       = \"\"                     /* Lines for the job beeing created */\nu        = 0                                      /* Counter therefor */\nzedsmsg  = \"\"                                         /* Shortmessage */\njid60    = 'VTTRFCHG'                                   /* Job ID $$$ */\nacc      = 'LVAL0000'                              /* Job Account $$$ */\nmcl      = 'T'                                        /* MSGCLASS $$$ */\ncl       = 'A'                                           /* CLASS $$$ */\nPARSE SOURCE . . . . me_dsn .             /* Name of the current REXX */\nIF me_dsn = \"?\" THEN\n   me_dsn = \"NHAAS.PRIVATE.EXEC\"                  /* REXX Dataset $$$ */\n\n/* Show Panel and Plausibility check -------------------------------- */\ncursor = \"dsn60\"\n\"ISPEXEC ADDPOP\"\nDO UNTIL plausi_ok\n   plausi_ok = TRUE\n\n   /* Show Panel ---------------------------------------------------- */\n   \"ISPEXEC DISPLAY PANEL(PACKCHGP)\"\n   IF rc > 0 THEN DO\n      \"ISPEXEC REMPOP\"\n      EXIT\n   END\n\n   /* Check DSN ----------------------------------------------------- */\n   dsn60 = FullQual(dsn60)\n   IF SYSDSN(dsn60) /= \"OK\" THEN DO\n      zedlmsg = \"Dataset does nor exist or is not available.\"\n      \"ISPEXEC SETMSG MSG(ISRZ001)\"\n      plausi_ok = FALSE\n      cursor = \"dsn60\"\n   END\n\n   /* Prefix without '*' -------------------------------------------- */\n   px60 = STRIP(px60,,\"*\")\n\n   /* Check strings ('\u00df\u00d6) ------------------------------------------- */\n   CALL Plausi_strings\n\n   /* Action? ------------------------------------------------------- */\n   IF aktS = \"\" THEN aktS = \"/\"\nEND\n\"ISPEXEC REMPOP\"\n\n/* Create job ------------------------------------------------------- */\nc  = Collect_Member(dsn60, px60)                /* Collect all member */\n\nIF aktE = \"/\" THEN\n   action = \"Find and change\"\nELSE\n   action = \"Find\"\n\nu=u+1;j.u = \"//\"jid60\" JOB (\"acc\"),'PACKCHG',MSGCLASS=\"mcl\",CLASS=\"cl\",\"\nu=u+1;j.u = \"//      NOTIFY=&SYSUID,TIME=1440\"\nu=u+1;j.u = \"//*----------------------------------------------------\"\nu=u+1;j.u = \"//PACKCHG EXEC PGM=IKJEFT01,DYNAMNBR=30\"\nu=u+1;j.u = \"//SYSEXEC DD DSN=\"me_dsn\",DISP=SHR\"\nu=u+1;j.u = \"//SYSPROC DD DSN=\"me_dsn\",DISP=SHR\"\nu=u+1;j.u = \"//ISPTLIB DD DSN=ISP.SISPTENU,DISP=SHR\"           /* $$$ */\nu=u+1;j.u = \"//ISPTABL DD DUMMY\"\nu=u+1;j.u = \"//ISPMLIB DD DSN=ISP.SISPMENU,DISP=SHR\"           /* $$$ */\nu=u+1;j.u = \"//ISPPLIB DD DSN=ISP.SISPPENU,DISP=SHR\"           /* $$$ */\nu=u+1;j.u = \"//ISPSLIB DD DSN=ISP.SISPSENU,DISP=SHR\"           /* $$$ */\nu=u+1;j.u = \"//ISPPROF DD SPACE=(TRK,(9,1,4)),\"\nu=u+1;j.u = \"//      DCB=(LRECL=80,BLKSIZE=3120,RECFM=FB)\"\nu=u+1;j.u = \"//SYSTSPRT DD SYSOUT=*\"\nu=u+1;j.u = \"//DSN60   DD *\"\nu=u+1;j.u = dsn60\nu=u+1;j.u = \"/*\"\nu=u+1;j.u = \"//MEMBER  DD *\"\nDO i = 1 TO c\n   u=u+1;j.u = collection.i\nEND\nu=u+1;j.u = \"/*\"\nu=u+1;j.u = \"//PREFIX  DD *\"\nu=u+1;j.u = px60\nu=u+1;j.u = \"/*\"\nu=u+1;j.u = \"//STRINGS DD *\"\nu=u+1;j.u = fstr60\nu=u+1;j.u = cstr60\nu=u+1;j.u = fstr61\nu=u+1;j.u = cstr61\nu=u+1;j.u = fstr62\nu=u+1;j.u = cstr62\nu=u+1;j.u = fstr63\nu=u+1;j.u = cstr63\nu=u+1;j.u = fstr64\nu=u+1;j.u = cstr64\nu=u+1;j.u = \"//COLUMN  DD *\"\nu=u+1;j.u = splt60\nu=u+1;j.u = splt61\nu=u+1;j.u = splt62\nu=u+1;j.u = splt63\nu=u+1;j.u = splt64\nu=u+1;j.u = \"/*\"\nu=u+1;j.u = \"//ACTION  DD *\"\nu=u+1;j.u = action\nu=u+1;j.u = \"/*\"\nu=u+1;j.u = \"//SYSTSIN DD *\"\nu=u+1;j.u = \" ISPSTART CMD(%PACKCHG1)\"\nu=u+1;j.u = \"/*\"\nu=u+1;j.u = \"//\"\n\n/* Create, save and submit job DSN ---------------------------------- */\njob_dsn = \"'\"USERID()\".PACKCHG'\"\n\"ISPEXEC LMERASE DATASET(\"job_dsn\")\"\n\n\"ALLOC DD(jobdd) DSN(\"job_dsn\") NEW REUSE\",\n   \"DSORG(PS) RECFM(F,B)\",\n   \"SPACE(5,5) TRACKS\",\n   \"LRECL(80) BLKSIZE(0)\"\n\"EXECIO\" u \"DISKW jobdd (FINIS STEM j.)\"\n\"FREE DD(jobdd)\"\n\n\"SUBMIT\" job_dsn\n\nEXIT\n\n/* ================================================================== */\n\nPlausi_strings:\n   IF POS(xc1, fstr60) > 0 |,\n      POS(xc2, fstr60) > 0 |,\n      POS(xc3, fstr60) > 0  THEN DO\n      zedlmsg = \"The find string contains at least one of the\",\n                \"following characters, which ist not allowd:\",\n                xc1 xc2 xc3\".\"\n      \"ISPEXEC SETMSG MSG(ISRZ001)\"\n      plausi_ok = FALSE\n      cursor = \"fstr60\"\n      RETURN\n   END\n   IF POS(xc1, cstr60) > 0 |,\n      POS(xc2, cstr60) > 0 |,\n      POS(xc3, cstr60) > 0  THEN DO\n      zedlmsg = \"The change string contains at least one of the\",\n                \"following characters, which ist not allowd:\"\n                xc1 xc2 xc3\".\"\n      \"ISPEXEC SETMSG MSG(ISRZ001)\"\n      plausi_ok = FALSE\n      cursor = \"cstr60\"\n      RETURN\n   END\n\n   IF POS(xc1, fstr61) > 0 |,\n      POS(xc2, fstr61) > 0 |,\n      POS(xc3, fstr61) > 0  THEN DO\n      zedlmsg = \"The find string contains at least one of the\",\n                \"following characters, which ist not allowd:\",\n                xc1 xc2 xc3\".\"\n      \"ISPEXEC SETMSG MSG(ISRZ001)\"\n      plausi_ok = FALSE\n      cursor = \"fstr61\"\n      RETURN\n   END\n   IF POS(xc1, cstr61) > 0 |,\n      POS(xc2, cstr61) > 0 |,\n      POS(xc3, cstr61) > 0  THEN DO\n      zedlmsg = \"The change string contains at least one of the\",\n                \"following characters, which ist not allowd:\"\n                xc1 xc2 xc3\".\"\n      \"ISPEXEC SETMSG MSG(ISRZ001)\"\n      plausi_ok = FALSE\n      cursor = \"cstr61\"\n      RETURN\n   END\n\n   IF POS(xc1, fstr62) > 0 |,\n      POS(xc2, fstr62) > 0 |,\n      POS(xc3, fstr62) > 0  THEN DO\n      zedlmsg = \"The find string contains at least one of the\",\n                \"following characters, which ist not allowd:\",\n                xc1 xc2 xc3\".\"\n      \"ISPEXEC SETMSG MSG(ISRZ001)\"\n      plausi_ok = FALSE\n      cursor = \"fstr62\"\n      RETURN\n   END\n   IF POS(xc1, cstr62) > 0 |,\n      POS(xc2, cstr62) > 0 |,\n      POS(xc3, cstr62) > 0  THEN DO\n      zedlmsg = \"The change string contains at least one of the\",\n                \"following characters, which ist not allowd:\"\n                xc1 xc2 xc3\".\"\n      \"ISPEXEC SETMSG MSG(ISRZ001)\"\n      plausi_ok = FALSE\n      cursor = \"cstr62\"\n      RETURN\n   END\n\n   IF POS(xc1, fstr63) > 0 |,\n      POS(xc2, fstr63) > 0 |,\n      POS(xc3, fstr63) > 0  THEN DO\n      zedlmsg = \"The find string contains at least one of the\",\n                \"following characters, which ist not allowd:\",\n                xc1 xc2 xc3\".\"\n      \"ISPEXEC SETMSG MSG(ISRZ001)\"\n      plausi_ok = FALSE\n      cursor = \"fstr63\"\n      RETURN\n   END\n   IF POS(xc1, cstr63) > 0 |,\n      POS(xc2, cstr63) > 0 |,\n      POS(xc3, cstr63) > 0  THEN DO\n      zedlmsg = \"The change string contains at least one of the\",\n                \"following characters, which ist not allowd:\"\n                xc1 xc2 xc3\".\"\n      \"ISPEXEC SETMSG MSG(ISRZ001)\"\n      plausi_ok = FALSE\n      cursor = \"cstr63\"\n      RETURN\n   END\n\n   IF POS(xc1, fstr64) > 0 |,\n      POS(xc2, fstr64) > 0 |,\n      POS(xc3, fstr64) > 0  THEN DO\n      zedlmsg = \"The find string contains at least one of the\",\n                \"following characters, which ist not allowd:\",\n                xc1 xc2 xc3\".\"\n      \"ISPEXEC SETMSG MSG(ISRZ001)\"\n      plausi_ok = FALSE\n      cursor = \"fstr64\"\n      RETURN\n   END\n   IF POS(xc1, cstr64) > 0 |,\n      POS(xc2, cstr64) > 0 |,\n      POS(xc3, cstr64) > 0  THEN DO\n      zedlmsg = \"The change string contains at least one of the\",\n                \"following characters, which ist not allowd:\"\n                xc1 xc2 xc3\".\"\n      \"ISPEXEC SETMSG MSG(ISRZ001)\"\n      plausi_ok = FALSE\n      cursor = \"cstr64\"\n      RETURN\n   END\nRETURN\n\nCollect_Member: PROCEDURE EXPOSE mem. collection. c\n   PARSE UPPER ARG dsn, prefix\n\n   /* Fully qualified? */\n   dsn = \"'\" || STRIP(dsn,,\"'\") || \"'\"\n\n   /* Now collect */\n   dmy = OUTTRAP('line.')\n   \"LISTDS \"dsn\" STA HIS MEM\"\n   dmy = OUTTRAP('OFF')\n\n   /* Skip some lines, save the others */\n   z1 = 0\n   DO i = 1 TO line.0\n      IF z1 > 0 THEN DO\n         tmp_mem = STRIP(line.i)\n         IF prefix = \"\" | prefix = LEFT(tmp_mem, LENGTH(prefix)) THEN DO\n            mem.z1 = tmp_mem\n            z1 = z1 + 1\n         END\n      END\n\n      /* Behind this line, you'll find the member names */\n      IF z1 = 0 & POS('--MEMBERS--', line.i) > 0 THEN z1 = 1\n   END\n\n   /* Counter minus one */\n   z1 = z1 - 1\n   mem.0 = z1\n\n   /* Drop memory */\n   DROP line.\n\n   /* without words */\n   c = 0\n   temp = \"\"\n   l = 70\n   DO i = 1 TO mem.0\n      IF LENGTH(temp) + LENGTH(mem.i) > l THEN DO\n         c = c + 1\n         collection.c = STRIP(temp)\n         temp = mem.i\n      END\n      ELSE DO\n         temp = temp mem.i\n      END\n   END\n\n   IF temp /= \"\" THEN DO\n      c = c + 1\n      collection.c = STRIP(temp)\n   END\nRETURN c\n\nFullQual: PROCEDURE EXPOSE TRUE FALSE\n   PARSE ARG dsn\n\n   dsn = STRIP(dsn,,\"'\")\nRETURN \"'\"dsn\"'\"\n\n\nNOVALUE:\nSYNTAX:\n   SAY \"PACKCHG   \"\n   SAY \"Zeile    =\" SIGL\n   SAY \"Source   =\" strip(\"SOURCELINE\"(sigl), \"L\")\n   SAY \"Error    =\" ERRORTEXT(rc)\n   SAY \"Variable =\" condition(\"D\")\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PACKCHG1": {"ttr": 2563, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x13\\x00\\x18\\x01\\x17\\x00_\\x01\\x17\\x00_\\t#\\x00\\xe3\\x00\\xe3\\x00\\x00\\xd5\\xd6\\xd9\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.19", "flags": 0, "createdate": "2017-01-05T00:00:00", "modifydate": "2017-01-05T09:23:18", "lines": 227, "newlines": 227, "modlines": 0, "user": "NORBERT"}, "text": "/* REXX ------------------------------------------------------------- */\n/* Name:         PACKCHG1                                             */\n/* Type:         Exec (only possible in batch mode)                   */\n/* Author:       Norbert Haas, noaDatex.de                            */\n/* Date:         24.08.2016                                           */\n/* Syntax:       will be called by PACKCHG                            */\n/* Parameter:    none                                                 */\n/* Description:  Changes in (all) members of a PDS (dsn = ...) the    */\n/*               string f$ by c$ (WORD). Uses PACKCHG2 for that       */\n/* Remark:       See lines with $$$ and change if neccessary          */\n/*                                                                    */\n/* Vers.  Datum      Autor     Grund                                  */\n/* ------ ---------- --------- -------------------------------------- */\n/* V03.03 21.12.2016 N.Haas    Translated into english                */\n/* V03.02 21.11.2016 N.Haas    Weitere Eingabefelder abarbeiten       */\n/* V03.01 17.11.2016 N.Haas    Jetzt mit C1, C2 und c3                */\n/* V02.01 02.09.2016 N.Haas    Jetzt auch mit Spaltenangabe           */\n/* V01.01 24.08.2016 N.Haas    Erstellung (Kopie und Erweiterung des  */\n/*                             RUDELCHG vom 22.01.2015)               */\n/* ------------------------------------------------------------------ */\nSIGNAL ON NOVALUE\nSIGNAL ON SYNTAX\n\nTRUE    = 1\nFALSE   = 0\npzeile. = \"\"\np       = 0\nc1      = 0                 /* Counter for number of member with hits */\nc2      = 0                 /* Counter for number of hits             */\nc3      = 0                 /* Counter for number of error            */\n\n/* Log -------------------------------------------------------------- */\nSAY \"Starting PACKCHG-Batch\"\nSAY DATE('G', 10) \"/\" TIME()\n\n/* Read all data ---------------------------------------------------- */\n\"EXECIO 1 DISKR DSN60   (FINIS STEM dsn60.)\"\n\"EXECIO 1 DISKR PREFIX  (FINIS STEM px60.)\"\n\"EXECIO * DISKR MEMBER  (FINIS STEM collect.)\"\n\"EXECIO 10 DISKR STRINGS (FINIS STEM string.)\"\n\"EXECIO 5 DISKR COLUMN  (FINIS STEM spalte.)\"\n\"EXECIO 1 DISKR ACTION  (FINIS STEM aktion.)\"\n\n/* Log -------------------------------------------------------------- */\nSAY \"Dataset          =\" dsn60.1\nSAY \"Prefix           =\" px60.1\nSAY \"Number of member =\" Anzahl_Member()\nSAY \"1. find string   =\" string.1; string.1 = STRIP(string.1)\nSAY \"   change string =\" string.2; string.2 = STRIP(string.2)\nSAY \"   on column     =\" spalte.1; spalte.1 = STRIP(spalte.1)\nIF string.3 /= \"\" THEN DO\n   SAY \"2. find string   =\" string.3; string.3 = STRIP(string.3)\n   SAY \"   change string =\" string.4; string.4 = STRIP(string.4)\n   SAY \"   on column     =\" spalte.2; spalte.2 = STRIP(spalte.2)\nEND\nIF string.5 /= \"\" THEN DO\n   SAY \"3. find string   =\" string.5; string.5 = STRIP(string.5)\n   SAY \"   change string =\" string.6; string.6 = STRIP(string.6)\n   SAY \"   on column     =\" spalte.3; spalte.3 = STRIP(spalte.3)\nEND\nIF string.7 /= \"\" THEN DO\n   SAY \"4. find string   =\" string.7; string.7 = STRIP(string.7)\n   SAY \"   change string =\" string.8; string.8 = STRIP(string.8)\n   SAY \"   on column     =\" spalte.4; spalte.4 = STRIP(spalte.4)\nEND\nIF string.9 /= \"\" THEN DO\n   SAY \"5. find string   =\" string.9; string.9 = STRIP(string.9)\n   SAY \"   change string =\" string.10; string.10 = STRIP(string.10)\n   SAY \"   on column     =\" spalte.5; spalte.5 = STRIP(spalte.5)\nEND\nSAY \"Action           =\" aktion.1\nSAY COPIES('-', 70)\n\n/* Call sub programms ----------------------------------------------- */\nIF UCASE(aktion.1) = \"FIND AND CHANGE\" THEN\n   CALL Find_and_change\nELSE\n   CALL Find\n\n/* End of log ------------------------------------------------------- */\nSAY COPIES('-', 70)\nSAY \"Number of member with hits:\" FORMAT(c1,6)\nSAY \"Total number of hits:      \" FORMAT(c2,6)\nIF UCASE(aktion.1) = \"FIND AND CHANGE\" THEN DO\n   SAY \"Total number of errors:    \" FORMAT(c3,6)\nEND\nSAY DATE('G', 10) \"/\" TIME()\nSAY \"End of PACKCHG\"\n\nEXIT\n\n/* ================================================================== */\n\nJoin: PROCEDURE\n   PARSE ARG dsn, mem\n\n   DO i = 1 TO 3\n      dsn = STRIP(dsn,,\"'\")\n      dsn = STRIP(dsn)\n   END\n   mem = STRIP(mem)\nRETURN \"'\"dsn\"(\"mem\")'\"\n\nFullQual: PROCEDURE EXPOSE TRUE FALSE\n   PARSE ARG dsn\n\n   dsn = STRIP(dsn,,\"'\")\nRETURN \"'\"dsn\"'\"\n\nDATE: PROCEDURE\n   PARSE UPPER ARG a, l\n\n   SELECT\n      WHEN a = 'G' THEN DO\n         tmp = \"DATE\"('E')                              /* dd/mm/yy   */\n         tmp = TRANSLATE(tmp,'.','/')                   /* dd.mm.yy   */\n         IF l = '' | l = 8 THEN NOP\n         ELSE DO\n            IF l = 10 THEN DO                           /* dd.mm.yyyy */\n               tmp = LEFT(tmp,6) || RIGHT(\"DATE\"(),4)\n            END\n            ELSE SAY \"ERROR bei Aufruf DATE('G',len)\"\n         END\n      END\n      WHEN a = 'DSN' THEN DO\n         tmp = \"DATE\"('S')                              /* yyyymmdd   */\n         tmp = SUBSTR(tmp, 3)                           /* yymmdd     */\n      END\n      OTHERWISE DO\n         tmp = \"DATE\"(a)\n      END\n   END\nRETURN tmp\n\nFind:\n   CALL Collect_Parms\n\n   DO i = 1 TO collect.0\n      temp = collect.i\n      DO j = 1 TO WORDS(temp)\n         member = WORD(temp, j)\n         dsn_mem = Join(dsn60.1, member)\n         parmx60 = parm\n         \"ISPEXEC VPUT parmx60\"\n         \"ISPEXEC VIEW DATASET(\"dsn_mem\") MACRO(PACKCHG2)\"\n         \"ISPEXEC VGET (treffer, fehler)\"\n         SAY \"Member (hits) =\" LEFT(member, 8),\n             \"(\"FORMAT(treffer, 5)\")\"\n         IF treffer > 0 THEN c1 = c1 + 1\n         c2 = c2 + treffer\n      END\n   END\nRETURN\n\nFind_and_change:\n   CALL Collect_Parms\n\n   DO i = 1 TO collect.0\n      temp = collect.i\n      DO j = 1 TO WORDS(temp)\n         member = WORD(temp, j)\n         dsn_mem = Join(dsn60.1, member)\n         parmx60 = parm\n         \"ISPEXEC VPUT parmx60\"\n         \"ISPEXEC EDIT DATASET(\"dsn_mem\") MACRO(PACKCHG3)\"\n         \"ISPEXEC VGET (treffer, fehler)\"\n         SAY  \"Member (hits/error ) =\" LEFT(member, 8),\n              \"(\"FORMAT(treffer, 5)\"/\"FORMAT(fehler, 5)\")\"\n         IF treffer > 0 THEN c1 = c1 + 1\n         c2 = c2 + treffer\n         c3 = c3 + fehler\n      END\n   END\nRETURN\n\nCollect_Parms:\n   xc1 = 'CA'x /* \u00ad Bullet point */\n   xc2 = '59'x /* \u00df Tilde        */\n   xc3 = 'EC'x /* \u00d6 Back slash   */\n   parm = TRANSLATE(string.1 || xc1 || string.2 || xc1 ||,\n                    spalte.1, xc2, \" \")\n\n   IF string.2 /= \"\" THEN DO\n      parm = parm || xc3 ||,\n             TRANSLATE(string.3 || xc1 || string.4 || xc1 || ,\n                       spalte.2, xc2, \" \")\n   END\n   IF string.3 /= \"\" THEN DO\n      parm = parm || xc3 ||,\n             TRANSLATE(string.5 || xc1 || string.6 || xc1 || ,\n                       spalte.3, xc2, \" \")\n   END\n   IF string.4 /= \"\" THEN DO\n      parm = parm || xc3 ||,\n             TRANSLATE(string.7 || xc1 || string.8 || xc1 || ,\n                       spalte.4, xc2, \" \")\n   END\n   IF string.5 /= \"\" THEN DO\n      parm = parm || xc3 ||,\n             TRANSLATE(string.9 || xc1 || string.10 || xc1 || ,\n                       spalte.5, xc2, \" \")\n   END\n\n   parm = parm || xc3\nRETURN\n\nUCASE: PROCEDURE\n   PARSE ARG parm\n   uc = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\u00a2\\!\"\n   lc = \"abcdefghijklmnopqrstuvwxyz{\u00a6}\"\nRETURN TRANSLATE(parm,uc,lc)\n\nAnzahl_Member: PROCEDURE EXPOSE collect.\n   c = 0\n   DO i = 1 TO collect.0\n      c = c + WORDS(collect.i)\n   END\nRETURN c\n\nNOVALUE:\nSYNTAX:\n   SAY \"PACKCHG1  \"\n   SAY \"Zeile    =\" SIGL\n   SAY \"Source   =\" strip(\"SOURCELINE\"(sigl), \"L\")\n   SAY \"Error    =\" ERRORTEXT(rc)\n   SAY \"Variable =\" condition(\"D\")\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PACKCHG2": {"ttr": 2568, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x00\\x18\\x01\\x17\\x00_\\x01\\x17\\x00_\\t#\\x009\\x009\\x00\\x00\\xd5\\xd6\\xd9\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "2017-01-05T00:00:00", "modifydate": "2017-01-05T09:23:18", "lines": 57, "newlines": 57, "modlines": 0, "user": "NORBERT"}, "text": "/* REXX ------------------------------------------------------------- */\n/* Name:         PACKCHG2                                             */\n/* Type:         Macro                                                */\n/* Author:       Norbert Haas, noaDatex.de                            */\n/* Date:         24.08.2016                                           */\n/* Syntax:       will be called by PACKCHG1                           */\n/* Parameter:    Concatination from find and change parameter         */\n/*                                                                    */\n/* Vers.  Date       Author    Reason                                 */\n/* ------ ---------- --------- -------------------------------------- */\n/* V03.03 21.12.2016 N.Haas    Translated into englich                */\n/* V03.02 21.11.2016 N.Haas    Weitere Eingabefelder abarbeiten       */\n/* V03.01 17.11.2016 N.Haas    Sonderbehandlung bei ###               */\n/* V02.01 02.09.2016 N.Haas    Jetzt auch mit Spaltenangabe und \u00a7\u00a7\u00a7   */\n/* V01.01 24.08.2016 N.Haas    Erstellung                             */\n/* ------------------------------------------------------------------ */\n\"ISREDIT MACRO\"\n\"ISPEXEC VGET parmx60\"\nc = 0\nv1 = 0\nxc1 = 'CA'x /* \u00ad Bullet point */\nxc2 = '59'x /* \u00df Tilde        */\nxc3 = 'EC'x /* \u00d6 Back slash   */\np = POS(xc3, parm)\nparm = TRANSLATE(parmx60, \" \", xc2)\nDO WHILE p > 0\n   c = c + 1\n   temp = LEFT(parm, p - 1)\n   parm = SUBSTR(parm, p + 1)\n   PARSE VAR temp     fp.c \"\u00ad\" cp.c \"\u00ad\" spalte.c\n   /* Character 'CA'x here \"x\" and  \"x\" between the double quotes */\n   p = POS(xc3, parm)\nEND\n\nDO i = 1 TO c\n   IF fp.1 = \"########\" & cp.i = \"\u00a7\u00a7\u00a7\u00a7\u00a7\u00a7\u00a7\u00a7\" THEN DO\n      \"ISREDIT NUMBER OFF\"\n      \"ISREDIT FIND ALL P'########' 73\"\n   END\n   ELSE DO\n      fp.i = TRANSLATE(fp.i, \" \" ,\"\u00a7\")\n\n      IF spalte.i /= \"\" THEN\n         \"ISREDIT FIND ALL '\"fp.i\"'\" spalte.i\n      ELSE\n         \"ISREDIT FIND ALL '\"fp.i\"'\"\n   END\n   \"ISREDIT (vt, dmy) = FIND_COUNTS\"\n   v1 = v1 + vt\nEND\n\ntreffer = v1\n\n\"ISPEXEC VPUT (treffer)\"\n\"ISREDIT CANCEL\"\n\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PACKCHG3": {"ttr": 2570, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00\\x18\\x01\\x17\\x00_\\x01\\x17\\x00_\\t#\\x00>\\x00>\\x00\\x00\\xd5\\xd6\\xd9\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "2017-01-05T00:00:00", "modifydate": "2017-01-05T09:23:18", "lines": 62, "newlines": 62, "modlines": 0, "user": "NORBERT"}, "text": "/* REXX ------------------------------------------------------------- */\n/* Name:         PACKCHG3                                             */\n/* Type:         Macro                                                */\n/* Author:       Norbert Haas, noaDatex.de                            */\n/* Date:         24.08.2016                                           */\n/* Syntax:       will be called by PACKCHG1                           */\n/* Parameter:    Concatination from find and change parameter         */\n/*                                                                    */\n/* Vers.  Date       Author    Reason                                 */\n/* ------ ---------- --------- -------------------------------------- */\n/* V03.03 21.12.2016 N.Haas    Translated into englich                */\n/* V03.02 21.11.2016 N.Haas    Weitere Eingabefelder abarbeiten       */\n/* V03.01 17.11.2016 N.Haas    Sonderbehandlung bei ###               */\n/* V02.01 02.09.2016 N.Haas    Jetzt auch mit Spaltenangabe und \u00a7\u00a7\u00a7   */\n/* V01.01 24.08.2016 N.Haas    Erstellung                             */\n/* ------------------------------------------------------------------ */\n\"ISREDIT MACRO\"\n\"ISPEXEC VGET parmx60\"\nc = 0\nv1 = 0\nv2 = 0\nxc1 = 'CA'x /* \u00ad Bullet point */\nxc2 = '59'x /* \u00df Tilde        */\nxc3 = 'EC'x /* \u00d6 Back slash   */\np = POS(xc3, parm)\nparm = TRANSLATE(parmx60, \" \", xc2)\nDO WHILE p > 0\n   c = c + 1\n   temp = LEFT(parm, p - 1)\n   parm = SUBSTR(parm, p + 1)\n   PARSE VAR temp     fp.c \"\u00ad\" cp.c \"\u00ad\" spalte.c\n   /* Character 'CA'x here \"x\" and  \"x\" between the double quotes */\n   p = POS(xc3, parm)\nEND\n\nDO i = 1 TO c\n   IF fp.1 = \"########\" & cp.i = \"\u00a7\u00a7\u00a7\u00a7\u00a7\u00a7\u00a7\u00a7\" THEN DO\n      \"ISREDIT NUMBER OFF\"\n      \"ISREDIT CHANGE ALL P'########' '        ' 73\"\n   END\n   ELSE DO\n      fp.i = TRANSLATE(fp.i, \" \" ,\"\u00a7\")\n      cp.i = TRANSLATE(cp.i, \" \" ,\"\u00a7\")\n\n      IF spalte.i /= \"\" THEN\n         \"ISREDIT CHANGE ALL '\"fp.i\"' '\"cp.i\"'\" spalte.i\n      ELSE\n         \"ISREDIT CHANGE ALL '\"fp.i\"' '\"cp.i\"'\"\n   END\n   \"ISREDIT (vt, ve) = CHANGE_COUNTS\"\n   v1 = v1 + vt\n   v2 = v2 + ve\nEND\n\ntreffer = v1\nfehler  = v2\n\n\"ISPEXEC VPUT (treffer, fehler)\"\nIF treffer > 0 THEN \"ISREDIT SAVE\"\n\"ISREDIT CANCEL\"\n\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RULER": {"ttr": 2572, "alias": false, "halfwords": 40, "notes": 0, "parms": "b'\\x01\\x00 \\x03\\x01\\x18\\x00O\\x01\\x18\\x00O\\x167\\x00\"\\x00\"\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@\\x00\\x00\\x00\"\\x00\\x00\\x00\"\\x00\\x00\\x00\\x00'", "ispf": {"version": "01.00", "flags": 32, "createdate": "2018-01-04T00:00:00", "modifydate": "2018-01-04T16:37:03", "lines": 34, "newlines": 34, "modlines": 0, "user": "SBGOLOB"}, "text": "/* REXX ------------------------------------------------------------- */\n/* Name:         RULER                                                */\n/* Type:         Macro                                                */\n/* Author:       Norbert Haas                                         */\n/* Date:         21.12.2017                                           */\n/* Syntax:       Linecommand RULER and cursor within data             */\n/* Parameter:    none                                                 */\n/* Description:  Shows a ruler from the cursor position               */\n/* Example:      X <== Cursor is here when RULER starts               */\n/*               ----+----1----+----2----+----3----+----4----+----5...*/\n/* Comment:      Works perfect, if command RULER is on a PF-key       */\n/*                                                                    */\n/* Vers.  Date       Author    Reason                                 */\n/* ------ ---------- --------- -------------------------------------- */\n/* V02.01 21.12.2017 N.Haas    New Version (engl.)                    */\n/* V01.01 29.02.2007 N.Haas    Creation (@ Ford)                      */\n/* ------------------------------------------------------------------ */\n\"ISREDIT MACRO (parm) NOPROCESS\"\n\"ISREDIT (dw) = DATA_WIDTH\"\n\"ISREDIT (dmy, col) = CURSOR\"\nif col = 0 then col = 1        /* added by LBD */\nruler = COPIES(' ', col-1)\ncnt = 0\nrl = dw - col\nDO i = col TO col + rl\n   cnt = cnt + 1\n   SELECT\n      WHEN cnt // 10 = 0 THEN ruler = ruler || RIGHT(cnt / 10, 1)\n      WHEN cnt //  5 = 0 THEN ruler = ruler || '+'\n      OTHERWISE               ruler = ruler || '-'\n   END\nEND\n\"ISREDIT LINE_AFTER .ZCSR = INFOLINE (ruler)\"\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SAVE": {"ttr": 2574, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x18\\x01\\x17\\x00_\\x01\\x17\\x00_\\t#\\x00\\xe2\\x00\\xe2\\x00\\x00\\xd5\\xd6\\xd9\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2017-01-05T00:00:00", "modifydate": "2017-01-05T09:23:18", "lines": 226, "newlines": 226, "modlines": 0, "user": "NORBERT"}, "text": "/* REXX ***************************************************************/\n/* -------------------------------------------------------------------*/\n/* Name:       SAVE                                                   */\n/* Short       Double a dataset (PO / PS)                             */\n/* Type:       REXX-Exec                                              */\n/* Author:     Norbert Haas, noaDatex.de                              */\n/* Syntax:     SAVE (used in 3.4 in front of a DSN)                   */\n/* Parameter:  none                                                   */\n/* Remark:     Based on an idea of Dirk Melzig                        */\n/*                                                                    */\n/* Version Author        Date       Why                               */\n/* ------- ------------- ---------- --------------------------------- */\n/* V05.01  N.Haas        18.06.2003 english version                   */\n/* V05.00  N.Haas        xx.01.2003 ...                               */\n/* V04.00  N.Haas        xx.08.2001 ...                               */\n/* V03.00  N.Haas        xx.05.2000 ...                               */\n/* V02.00  N.Haas        xx.03.2000 ...                               */\n/* V01.00  N.Haas        xx.11.1999 Creation                          */\n/**********************************************************************/\n/* Init --------------------------------------------------------------*/\nTRUE = 1\nFALSE = 0\n\nPARSE UPPER ARG dsn_alt\n\n/* Parm OK ? ---------------------------------------------------------*/\nIF dsn_alt = '' THEN DO\n   rc = DispMsg('Wrong use',,\n                'This tool must be used in the dataset list from',\n                'PDF 3.4 or a DSN must be given as a parameter.',,\n                TRUE)\n   EXIT\nEND\n\n/* Dataset name with or without >'< ? --------------------------------*/\ndsn_alt = STRIP(dsn_alt,\"B\",\"'\")\ndsn_neu = dsn_alt || '.SAVE'\n\n\"ISPEXEC ADDPOP\"\nadsn = dsn_alt\n\nDisplay:\nndsn = dsn_neu\n\"ISPEXEC DISPLAY PANEL(SAVEP)\"\nIF rc = 8 THEN DO\n   rc = DispMsg('Canceled by user',,\n                'This action has been canceled by the user.',,\n                FALSE)\n   EXIT\nEND\ndsn_neu = ndsn\n\nIF LENGTH(dsn_neu) > 44 THEN DO\n   rc = DispMsg('Error (length)',,\n                'The new DSN will be too long (> 44 Char). Please',\n                'take a different name for the dataset' dsn_neu'.',,\n                TRUE)\n   SIGNAL Display\nEND\n\n\"ISPEXEC REMPOP\"\ndsn_alt = \"'\"dsn_alt\"'\"\ndsn_neu = \"'\"dsn_neu\"'\"\n\n/* New DSN exists ? --------------------------------------------------*/\nIF SYSDSN(dsn_neu) = 'OK' THEN DO\n   rc = DispMsg('Error (already existing)',,\n                'The new DSN' dsn_neu 'already exists.',,\n                TRUE)\n   EXIT\nEND\n\n/* Create new dsn ----------------------------------------------------*/\n\"ALLOC NEW DATASET(\"dsn_neu\") LIKE(\"dsn_alt\")\"\nalloc_rc = rc\nIF alloc_rc > 0 THEN DO\n   SAY 'ALLOC, RC =' rc\nEND\n\n/* Copy (PO / PS) ----------------------------------------------------*/\ndummy = LISTDSI(dsn_alt)\nIF datopt = 1 THEN DO /* Create and copy */\n   IF sysdsorg = 'PO' THEN DO\n      member = ''\n      \"ISPEXEC LMINIT DATAID(dataid1) DATASET(\"dsn_alt\") ENQ(SHR)\"\n      \"ISPEXEC LMINIT DATAID(dataid2) DATASET(\"dsn_neu\") ENQ(SHRW)\"\n\n      \"ISPEXEC LMOPEN DATAID(\"dataid1\") OPTION(INPUT)\"\n\n      \"ISPEXEC LMMLIST DATAID(\"dataid1\") OPTION(LIST) MEMBER(member)\"\n\n      DO WHILE rc = 0\n         \"ISPEXEC LMCOPY FROMID(\"dataid1\") FROMMEM(\"member\")\",\n                        \"TODATAID(\"dataid2\") TOMEM(\"member\")\",\n                        \"REPLACE\"\n         lmcopy_rc = rc\n         IF lmcopy_rc > 0 THEN DO\n            SAY 'LMCOPY, RC =' rc\n         END\n         \"ISPEXEC LMMLIST DATAID(\"dataid1\") OPTION(LIST) MEMBER(member)\"\n      END\n\n      \"ISPEXEC LMCLOSE DATAID(\"dataid1\")\"\n\n      \"ISPEXEC LMFREE DATAID(\"dataid2\")\"\n      \"ISPEXEC LMFREE DATAID(\"dataid1\")\"\n   END\n   ELSE DO\n      IF sysdsorg = 'PS' THEN DO\n         \"ALLOC DD(SYSUT1)   DSN(\"dsn_alt\") SHR REUSE\"\n         \"ALLOC DD(SYSUT2)   DSN(\"dsn_neu\") OLD REUSE\"\n         \"ALLOC DD(SYSIN)    DUMMY REUSE\"\n         \"ALLOC DD(SYSPRINT) DUMMY REUSE\"\n\n         \"ISPEXEC SELECT PGM(IEBGENER)\"\n         iebgener_rc = rc\n         IF iebgener_rc > 0 THEN DO\n            SAY 'IEBGENER, RC =' rc\n         END\n\n         \"FREE DD(SYSPRINT)\"\n         \"FREE DD(SYSIN)\"\n         \"FREE DD(SYSUT2)\"\n         \"FREE DD(SYSUT1)\"\n      END\n      ELSE DO\n         rc = DispMsg('Wrong DSORG',,\n                 'The DSORG of DSN' dsn_alt 'is not PO or PS.',\n                 'SAVE only supports PO and PS datasets.',,\n                      TRUE)\n         CALL Delete_Again dsn_neu\n         EXIT\n      END\n   END\nEND\nELSE DO\n   IF datopt = 2 THEN DO /* Create and copy lines */\n      IF vonzeil1 = \"\" | biszeil1 = \"\" THEN DO\n         rc = DispMsg('Wrong Input',,\n                      'If option 2 selected, \"from line\"',\n                      'and \"to line\" must be filled out.',,\n                      TRUE)\n         CALL Delete_Again dsn_neu\n         EXIT\n      END\n      ELSE DO\n         IF sysdsorg = 'PS' THEN DO\n            /* 1 */\n            anzahl_zeilen = biszeil1 - vonzeil1 + 1\n            \"ALLOC DD(di) DSN(\"dsn_alt\") SHR REUSE\"\n            \"EXECIO\" anzahl_zeilen \"DISKR di\" vonzeil1 \"(FINIS STEM line.)\"\n            execio_rc = rc\n            \"FREE DD(di)\"\n            IF execio_rc /= 0 THEN DO\n               rc = DispMsg('To less memory',,\n                            'Unsufficioned memory to read the selected',\n                            'lines.',,\n                            TRUE)\n               CALL Delete_Again dsn_neu\n               EXIT\n            END\n            \"ALLOC DD(do) DSN(\"dsn_neu\") SHR REUSE\"\n            \"EXECIO\" anzahl_zeilen \"DISKW do (FINIS STEM line.)\"\n            \"FREE DD(do)\"\n            /* 2 */\n            IF vonzeil2 /= \"\" & biszeil2 /= \"\" THEN DO\n               anzahl_zeilen = biszeil2 - vonzeil2 + 1\n               \"ALLOC DD(di) DSN(\"dsn_alt\") SHR REUSE\"\n               \"EXECIO\" anzahl_zeilen \"DISKR di\" vonzeil2 \"(FINIS STEM line.)\"\n               execio_rc = rc\n               \"FREE DD(di)\"\n               IF execio_rc /= 0 THEN DO\n                  rc = DispMsg('To less memory',,\n                               'Unsufficioned memory to read the selected',\n                               'lines.',,\n                               TRUE)\n                  CALL Delete_Again dsn_neu\n                  EXIT\n               END\n               \"ALLOC DD(do) DSN(\"dsn_neu\") MOD REUSE\"\n               \"EXECIO\" anzahl_zeilen \"DISKW do (FINIS STEM line.)\"\n               \"FREE DD(do)\"\n            END\n            /* 3 */\n            IF vonzeil3 /= \"\" & biszeil3 /= \"\" THEN DO\n               anzahl_zeilen = biszeil3 - vonzeil3 + 1\n               \"ALLOC DD(di) DSN(\"dsn_alt\") SHR REUSE\"\n               \"EXECIO\" anzahl_zeilen \"DISKR di\" vonzeil3 \"(FINIS STEM line.)\"\n               execio_rc = rc\n               \"FREE DD(di)\"\n               IF execio_rc /= 0 THEN DO\n                  rc = DispMsg('To less memory',,\n                               'Unsufficioned memory to read the selected',\n                               'lines.',,\n                               TRUE)\n                  CALL Delete_Again dsn_neu\n                  EXIT\n               END\n               \"ALLOC DD(do) DSN(\"dsn_neu\") MOD REUSE\"\n               \"EXECIO\" anzahl_zeilen \"DISKW do (FINIS STEM line.)\"\n               \"FREE DD(do)\"\n            END\n         END\n         ELSE DO\n            rc = DispMsg('Wrong DSORG',,\n                        'If option 2 selected, the DSORG must be PS.',,\n                         TRUE)\n            CALL Delete_Again dsn_neu\n            EXIT\n         END\n      END\n   END\nEND\n\n/* ... uns Tschuess --------------------------------------------------*/\n\"FREE DATASET(\"dsn_neu\")\"\nEXIT\n\n/* ================================================================== */\n\nDelete_Again: PROCEDURE\n   PARSE ARG dsn_del\n   dummy = MSG('OFF')\n   \"DELETE\" dsn_del\n   dummy = MSG('ON')\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SAVEP": {"ttr": 2820, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00P\\x01\\x16(\\x1f\\x01\\x16(\\x1f\\x001\\x00+\\x00+\\x00\\x00\\xd5\\xd6\\xd9\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-10-07T00:00:00", "modifydate": "2016-10-07T00:31:50", "lines": 43, "newlines": 43, "modlines": 0, "user": "NORBERT"}, "text": ")PANEL KEYLIST(ISRSNAB,ISR)\n)ATTR DEFAULT(%+_)\n   % TYPE(ET)                                      /* Emphasized Text */\n   + TYPE(NT)                                          /* Normal Text */\n   _ TYPE(NEF) CAPS(ON)                         /* Normal Entry Field */\n   / TYPE(VOI)                         /* Variable Output Information */\n   \\ TYPE(OUTPUT) COLOR(RED) CAPS(OFF) JUST(ASIS)     /* Warning Text */\n   { TYPE(WT)                                         /* Warning Text */\n   $ TYPE(FP)                                         /* Field Prompt */\n   < TYPE(CEF) PADC(USER)\n   | TYPE(SAC)\n   } TYPE(TEXT) SKIP(ON)\n)BODY WINDOW(63,20)\n+\n$Command ===>_ZCMD                                            +\n+\n+\n$DSN (old) . . .:/adsn                                        +\n+\n$DSN (new) . . . _ndsn                                        +\n+                 ----:----1----:----2----:----3----:----4----\n+\n+\n+\n$Option  . . . . <Z+|1. Create and copy content+\n+                   |2. Create and copy the follwoing lines:{*+\n+        $from line . ._vonzeil1$to line . ._biszeil1+\n+    $and from line . ._vonzeil2$to line . ._biszeil2+\n+    $and from line . ._vonzeil3$to line . ._biszeil3+\n+                   |3. Create only+\n+\n+                   {*+%Only available with PS-Datasets+\n+\n)INIT\n  .ZVARS   = 'datopt'\n  .cursor  = 'ndsn'\n  &zwinttl = 'SAVE'\n  &datopt  = '1'\n)PROC\n  VER(&datopt,NB)\n  VER(&datopt,LIST,1,2,3)\n  &zwinttl = ''\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SETLAB": {"ttr": 2822, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x18\\x01\\x17\\x00_\\x01\\x17\\x00_\\t#\\x00`\\x00`\\x00\\x00\\xd5\\xd6\\xd9\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2017-01-05T00:00:00", "modifydate": "2017-01-05T09:23:18", "lines": 96, "newlines": 96, "modlines": 0, "user": "NORBERT"}, "text": "/* REXX ***************************************************************/\n/* -------------------------------------------------------------------*/\n/* Name:       SETLAB                                                 */\n/* Short       Set Label on lines with <string>                       */\n/* Type:       REXX-Macro                                             */\n/* Author:     Norbert Haas, noaDatex.de                              */\n/* Syntax:     SETLAB string                                          */\n/* Parameter:  string = find string (required)                        */\n/* Example:    SETLAB isredit                                         */\n/*                                                                    */\n/* Version Author        Date       Why                               */\n/* ------- ------------- ---------- --------------------------------- */\n/* V01.01  N.Haas        15.07.2004 English version                   */\n/* V01.00  N.Haas        22.12.2001 Erstellung                        */\n/**********************************************************************/\n\n/* Parameter */\n\"ISREDIT MACRO (string) NOPROCESS\"\n\"ISPEXEC CONTROL ERRORS RETURN\"\n\n/* Parameter OK? */\nIF WORDS(string) /= 1 THEN DO\n   zedsmsg = 'Paramater required'\n   zedlmsg = 'Macro SETLAB needs one parameter (string).'\n   \"ISPEXEC SETMSG MSG(isrz001)\"\n   EXIT\nEND\n\n/* Init */\nPARSE VALUE '1' WITH 1 mc1  1 mc2  1 mc3  1 mc4\n\nletters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nDO i = 1 TO LENGTH(letters)\n   INTERPRET 'l.'i '= SUBSTR(letters,i,1)'\nEND\n\nc = 0; max = 26 ** 4\nletter = 'A'\n\n/* Main loop */\n\"ISREDIT FIND FIRST\" string\nfind_rc = rc\nDO WHILE (find_rc = 0) & (c < max)\n   c = c + 1\n   label = MakeLabel(mc4, mc3, mc2, mc1)                /* .AAAAA ... */\n   \"ISREDIT LABEL .zcsr =\" label \"0\"\n   IF c = 1 THEN label1 = label\n   \"ISREDIT FIND NEXT\" string\n   find_rc = rc\n   mc1 = mc1 + 1\n   IF mc1 > 26 THEN DO\n      mc1 = 1\n      mc2 = mc2 + 1\n      IF mc2 > 26 THEN DO\n         mc2 = 1\n         mc3 = mc3 + 1\n         IF mc3 > 25 THEN DO\n            mc3 = 1\n            mc4 = mc4 + 1\n            IF mc4 > 26 then DO\n               EXIT\n            END\n         END\n      END\n   END\nEND\n\n/* End message */\nIF c > 0 THEN DO\n   zedsmsg = c 'label set'\n   zedlmsg = c 'label have been set. From .'letter'AAAA to' label'.'\n   \"ISPEXEC SETMSG MSG(isrz000)\"\n   \"ISREDIT LOCATE\" label1\n   IF rc > 0 THEN DO\n      \"ISREDIT LOCATE FIRST LABEL\"\n   END\nEND\nELSE DO\n   zedsmsg = 'Not found'\n   zedlmsg = 'String' string 'not found.'\n   \"ISPEXEC SETMSG MSG(isrz001)\"\nEND\n\nEXIT\n\n\n\nMakeLabel:\n   PARSE ARG p.4, p.3, p.2, p.1\n\n   label = \".\" || letter\n   DO i = 4 TO 1 BY - 1\n      j = p.i\n      label = label || l.j\n   END\nRETURN label\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WHOHOLDS": {"ttr": 2825, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x18\\x01\\x17\\x00_\\x01\\x17\\x00_\\t#\\x00$\\x00$\\x00\\x00\\xd5\\xd6\\xd9\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2017-01-05T00:00:00", "modifydate": "2017-01-05T09:23:18", "lines": 36, "newlines": 36, "modlines": 0, "user": "NORBERT"}, "text": "/* REXX ***************************************************************/\n/* -------------------------------------------------------------------*/\n/* Name:       WHOHOLDS                                               */\n/* Short       Who holds a dataset (i.E. by Edit)                     */\n/* Type:       REXX-Function                                          */\n/* Author:     Norbert Haas, noaDatex.de                              */\n/* Input:      DSN                                                    */\n/* Output:     User-Id                                                */\n/* Syntax:     x = WHOHOLDS(dsn)                                      */\n/* Parameter:  dsn = Dataset                                          */\n/* Remark:     Needs Macro MCANCEL                                    */\n/*                                                                    */\n/* Version Author        Date       Why                               */\n/* ------- ------------- ---------- --------------------------------- */\n/* V01.00  N.Haas        06.01.2003 Creation                          */\n/**********************************************************************/\n\n/* Get dsn */\nPARSE UPPER ARG dsn\n\n/* full qualified ? */\nIF LEFT(dsn,1) /= \"'\" THEN dsn = \"'\"dsn\nIF RIGHT(dsn,1) /= \"'\" THEN dsn = dsn\"'\"\n\n/* Try to open with edit (maybe it doesn't work) */\n\"ISPEXEC EDIT DATASET(\"dsn\") MACRO(MCANCEL)\"\nIF rc = 14 THEN DO\n   /* This systemvar contains the userid, that helds the dataset */\n   \"ISPEXEC VGET zenqlist PROFILE\"\n\n   /* Fisrt char is x'02', delete it */\n   uid = SUBSTR(zenqlist,2)\nEND\nELSE uid = '*NONE*'\n\nEXIT uid\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XDOUBLE": {"ttr": 2827, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x18\\x01\\x17\\x00_\\x01\\x17\\x00_\\t#\\x00\\xa2\\x00\\xa2\\x00\\x00\\xd5\\xd6\\xd9\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2017-01-05T00:00:00", "modifydate": "2017-01-05T09:23:18", "lines": 162, "newlines": 162, "modlines": 0, "user": "NORBERT"}, "text": "/* REXX ------------------------------------------------------------- */\n/* Name:         XDOUBLE                                              */\n/* Type:         Macro                                                */\n/* Author:       Norbert Haas, noaDatex.de                            */\n/* Date:         in 2002                                              */\n/* Syntax:       XDOUBLE left_col right_col                           */\n/*     or:       XDOUBLE left_col +length                             */\n/*     or:       XDOUBLE ALL                                          */\n/* Parameter:    left / right_col = Colums                            */\n/*               ALL uses the whole length (lrecl)                    */\n/* Description:  Excludes double lines                                */\n/* Attention:    Data will be sorted!                                 */\n/* Example:      XDOUBLE 10 12                                        */\n/*    also:      XDOUBLE 12 +3                                        */\n/*               Excludes all line, that have identical data in       */\n/*               columns 10 to 12.                                    */\n/*                                                                    */\n/* Vers.  Date       Author    Reason                                 */\n/* ------ ---------- --------- -------------------------------------- */\n/* V05.03 03.01.2017 N.Haas    English version                        */\n/* V05.02 06.01.2015 N.Haas    PARM-Fehler beseitigt, L\u00e4nge ermittelt */\n/* V05.01 20.12.2013 N.Haas    Jetzt wird mit HEX gesucht!            */\n/* V04.02 15.08.2013 N.Haas    Fehler raus                            */\n/* V04.01 30.07.2013 N.Haas    Komplett neue Version - cleverer!      */\n/*                             Blitzschnelle Version !!!              */\n/* V03.01 24.05.2013 N.Haas    Version mit Labeln                     */\n/* V02.01 21.05.2013 N.Haas    Fetter Fehler raus. Es wurden die      */\n/*                             beiden Zeichenketten                   */\n/*                             100000000000000001 und                 */\n/*                             100000000000000002 verglichen. Dabei   */\n/*                             wird Gleichheit festgestellt, wenn mit */\n/*                             IF string = string_alt verglichen wird.*/\n/*                             IF string == string_alt stellt kor-    */\n/*                             rekterweise Ungleichheit fest.         */\n/* V01.03 11.05.2011 N.Haas    Parm = *  durch ALL ersetzt            */\n/* V01.02 14.01.2011 N.Haas    Parm = *                               */\n/* V01.01       2002 N.Haas    Erstellung (FORD)                      */\n/* ------------------------------------------------------------------ */\n\"ISREDIT MACRO (parm) NOPROCESS\"\nUPPER parm\n\nSIGNAL ON NOVALUE NAME Exception\nSIGNAL ON SYNTAX  NAME Exception\n\nzedsmsg = ''\n\n/* Plausis */\nIF parm = 'ALL' THEN DO\n   p1 = 1\n   \"ISREDIT (p2) = LRECL\"\nEND\nELSE DO\n   IF WORDS(parm) /= 2 THEN DO\n      zedlmsg = 'Wrong parameter -',\n                'Please enter ALL, two cols (c1 c2) or one',\n                'column and then length (c +l).'\n      \"ISPEXEC SETMSG MSG(isrz001)\"\n      EXIT -1\n   END\n   PARSE VAR parm  p1 p2\nEND\n\n/* Compute */\nIF LEFT(p2,1) = \"+\" THEN DO\n   l = p2\n   p2 = p1 + l - 1\nEND\nELSE DO\n   l = p2 - p1 + 1\nEND\n\n/* Hex mode is possible, therefor max. length = 128 */\nIF l > 128 THEN DO\n   zedlmsg = 'Wrong length -',\n             'maximum is 128 char.'\n   \"ISPEXEC SETMSG MSG(isrz001)\"\n   EXIT -1\nEND\n\n/* Init for Label */\nPARSE VALUE '1' WITH 1 mc1  1 mc2  1 mc3  1 mc4\n\nletters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nDO i = 1 TO LENGTH(letters)\n   INTERPRET 'l.'i '= SUBSTR(letters,i,1)'\nEND\n\nc = 0; max = 26 ** 4; cntr = 0\nTRUE = 1; FALSE = 0; finished = FALSE\nletter = 'A'                                          /* First letter */\n\n/* This is the master piece | */\n\"ISREDIT (lastline) = LINENUM .ZL\"\n\"ISREDIT RESET\"\n\"ISREDIT BNDS\"\n\"ISREDIT RESET LABEL\"\n\"ISREDIT SORT\" p1 p2 \"a\"\n\"ISREDIT FIND FIRST P'\"COPIES('=',l)\"'\" p1\nDO WHILE rc = 0 & finished = FALSE\n   \"ISREDIT (line) = LINE .ZCSR\"\n   string = SUBSTR(line, p1, l)\n   xstring = C2X(string)\n   label = MakeLabel(mc4, mc3, mc2, mc1)\n   \"ISREDIT LABEL .ZCSR =\" label \"0\"\n   \"ISREDIT (linenum) = LINENUM .ZCSR\"\n   linenum = linenum + 1\n   IF linenum > lastline THEN finished = TRUE\n   ELSE DO\n      \"ISREDIT LABEL\" linenum \"= .DMY 0\"\n      \"ISREDIT X ALL x'\"xstring\"'\" p1 \".DMY .ZL\"\n      \"ISREDIT (tmp1,tmp2) = EXCLUDE_COUNTS\"\n      cntr = cntr + tmp1\n      \"ISREDIT FIND FIRST P'\"COPIES('=',l)\"'\" p1 \".DMY .ZL NX\" /* Nxt */\n   END\nEND\n\n/* Big fat message */\nzedlmsg = LEFT('The excludet lines are double.',\n          'To delete enter \"DEL ALL X\". There where',\n          cntr 'double lines.',156),\n          'Enter \"RES;TOP;&L NEXT LABEL\" to find the hits',\n          'step by step.'\n\"ISPEXEC SETMSG MSG(isrz000)\"\n\nEXIT\n\n\n\nMakeLabel:\n   PARSE ARG p.4, p.3, p.2, p.1\n\n   label = \".\" || letter\n   DO ii = 4 TO 1 BY - 1\n      jj = p.ii\n      label = label || l.jj\n   END\n   mc1 = mc1 + 1\n   IF mc1 > 26 THEN DO\n      mc1 = 1\n      mc2 = mc2 + 1\n      IF mc2 > 26 THEN DO\n         mc2 = 1\n         mc3 = mc3 + 1\n         IF mc3 > 25 THEN DO\n            mc3 = 1\n            mc4 = mc4 + 1\n            IF mc4 > 26 then DO\n               EXIT\n            END\n         END\n      END\n   END\nRETURN label\n\n\n\nException:\n   SAY rc\n   SAY ERRORTEXT(rc)\n   SAY sigl\n   SAY SOURCELINE(sigl)\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XMAN": {"ttr": 2831, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x18\\x01\\x17\\x00_\\x01\\x17\\x00_\\t#\\x00\\xa8\\x00\\xa8\\x00\\x00\\xd5\\xd6\\xd9\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2017-01-05T00:00:00", "modifydate": "2017-01-05T09:23:18", "lines": 168, "newlines": 168, "modlines": 0, "user": "NORBERT"}, "text": "/* REXX ------------------------------------------------------------- */\n/* Name:         XMAN - XMIT Manager                                  */\n/* Type:         Exec                                                 */\n/* Author:       Norbert Haas - noaDatex.de                           */\n/* Date:         30.12.2016                                           */\n/* Syntax:       TSO XMAN                                             */\n/* Parameter:    Input DS (optional)                                  */\n/* Description:  XMIT command with dialog                             */\n/* Example:      TSO XMAN                                             */\n/*                                                                    */\n/* Vers.  Date       Author    Reason                                 */\n/* ------ ---------- --------- -------------------------------------- */\n/* V01.01 30.12.2016 N.Haas    Creation                               */\n/* ------------------------------------------------------------------ */\nPARSE UPPER ARG inpdsn                                    /* Input DS */\n\nSIGNAL ON NOVALUE\nSIGNAL ON SYNTAX\n\n/* Init ------------------------------------------------------------- */\nTRUE = 1\nFALSE = 0\nok = TRUE\ncursor = \"inpdsn\"\ncmd = \"SE 'Canceled by user ...' U(\"USERID()\")\"\n\n/* Show panel ------------------------------------------------------- */\n\"ISPEXEC ADDPOP\"\n\"ISPEXEC DISPLAY PANEL(XMANP)\"\nDO WHILE rc = 0\n   \"ISPEXEC REMPOP\"\n   ok = TRUE\n\n   /* Plausi input DS ----------------------------------------------- */\n   inpdsn = FQ(inpdsn)\n   IF SYSDSN(inpdsn) /= \"OK\" THEN DO\n      dmy = DispMsg(\"\",,\n                    \"Input dataset (\"inpdsn\") does not exist.\",,\n                    TRUE)\n      ok  = FALSE\n   END\n\n   dmy = LISTDSI(inpdsn)\n   IF sysdsorg /= 'PO' THEN DO\n      rc = DispMsg(\"Wrong DSORG\",,\n                   \"DS\" inpdsn \"must be partitioned.\",,\n                   TRUE)\n      ok  = FALSE\n   END\n\n   /* Member -------------------------------------------------------- */\n   IF ok THEN DO\n      all = FALSE\n      member.0 = 0\n      SELECT\n         WHEN inpmem1 = \"*\" THEN all = TRUE\n         WHEN inpmem1 = \"/\" THEN member.0 = Select_Members()\n         OTHERWISE NOP\n      END\n   END\n\n   /* Plausi output DS ---------------------------------------------- */\n   IF ok THEN DO\n      outdsn = FQ(outdsn)\n      IF SYSDSN(outdsn) = \"OK\" THEN DO\n         dmy = DispMsg(\"\",,\n                       \"Output dataset (\"outdsn\") already exists.\",,\n                       TRUE)\n         ok = FALSE\n         cursor = \"outdsn\"\n      END\n   END\n\n   /* Built XMIT command -------------------------------------------- */\n   IF ok THEN DO\n      cmd = \"XMIT \"nodeid\".\"userid \" DSN(\"inpdsn\")\"\n\n      IF all THEN NOP\n      ELSE DO\n         cmd = cmd \"MEMBERS(\"\n\n         IF member.0 > 0 THEN DO\n            DO i = 1 TO member.0\n               cmd = cmd || STRIP(member.i) || \",\"\n            END\n         END\n         ELSE DO\n            cmd = cmd || STRIP(inpmem1)\n            IF inpmem2 /= \"\" THEN cmd = cmd || \",\" || STRIP(inpmem2)\n            IF inpmem3 /= \"\" THEN cmd = cmd || \",\" || STRIP(inpmem3)\n            IF inpmem4 /= \"\" THEN cmd = cmd || \",\" || STRIP(inpmem4)\n            IF inpmem5 /= \"\" THEN cmd = cmd || \",\" || STRIP(inpmem5)\n         END\n\n         cmd = cmd || \")\"\n      END\n\n      cmd = cmd \"OUTDSN(\"outdsn\")\"\n   END\n\n   /* End of loop --------------------------------------------------- */\n   IF ok THEN rc = 1\n   ELSE DO\n      \"ISPEXEC ADDPOP\"\n      \"ISPEXEC DISPLAY PANEL(XMANP)\"\n   END\nEND\n\n/* XMIT now --------------------------------------------------------- */\nIF ok THEN cmd\n\nEXIT\n\n/* ERROR coding ----------------------------------------------------- */\nNOVALUE:\nSYNTAX:\n   SAY \"XMAN      \"\n   SAY \"Line     =\" sigl\n   SAY \"Source   =\" STRIP(\"SOURCELINE\"(sigl), \"L\")\n   SAY \"Error    =\" ERRORTEXT(rc)\n   SAY \"Variable =\" CONDITION(\"D\")\nEXIT\n\n/* Full Qualified --------------------------------------------------- */\nFQ: PROCEDURE\n   PARSE UPPER ARG dsn\n\n   dsn = STRIP(dsn,,\"'\")\nRETURN \"'\"dsn\"'\"\n\n/* Display Message -------------------------------------------------- */\nDispMsg: PROCEDURE\n   PARSE ARG zedsmsg, zedlmsg, beep\n\n   /* Beep ? */\n   IF beep THEN\n      msg = 'ISRZ001'\n   ELSE\n      msg = 'ISRZ000'\n\n   \"ISPEXEC SETMSG MSG(\"msg\")\"\nRETURN 0\n\n/* Dialog dieplay members ------------------------------------------- */\nSelect_Members: PROCEDURE EXPOSE member. inpdsn TRUE FALSE\n   msg = '*SEL*'\n   dmy = DispMsg(\"\",,\n                 \"Please select (S) member to be copied.\",,\n                 FALSE)\n\n   \"ISPEXEC LMINIT DATAID(dataid1) DATASET(\"inpdsn\") ENQ(SHR)\"\n   \"ISPEXEC LMOPEN DATAID(\"dataid1\") OPTION(INPUT)\"\n   \"ISPEXEC LMMDISP DATAID(\"dataid1\") OPTION(DISPLAY)\"\n\n   c = 0\n   DO WHILE rc = 0\n      c = c + 1\n      member.c = zlmember\n      \"ISPEXEC LMMDISP DATAID(\"dataid1\") OPTION(PUT)\",\n                                        \"MEMBER(\"zlmember\")\",\n                                        \"ZLUDATA(\"msg\")\"\n      \"ISPEXEC CONTROL NONDISPL ENTER\"\n      \"ISPEXEC LMMDISP DATAID(\"dataid1\") OPTION(DISPLAY)\"\n   END\n\n   \"ISPEXEC LMCLOSE DATAID(\"dataid1\")\"\n   \"ISPEXEC LMFREE DATAID(\"dataid1\")\"\nRETURN c\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XMANP": {"ttr": 3075, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x18\\x01\\x17\\x00_\\x01\\x17\\x00_\\t#\\x002\\x002\\x00\\x00\\xd5\\xd6\\xd9\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2017-01-05T00:00:00", "modifydate": "2017-01-05T09:23:18", "lines": 50, "newlines": 50, "modlines": 0, "user": "NORBERT"}, "text": ")PANEL KEYLIST(ISRSNAB,ISR)\n/* Panel **************************************************************/\n/* -------------------------------------------------------------------*/\n/* Name      XMAPN                                                    */\n/* Text      XMIT Manager                                             */\n/* Typ       PANEL                                                    */\n/*                                                                    */\n/* Version   Author        Date       Reason                          */\n/* --------- ------------- ---------- ------------------------------- */\n/* V01.01    N.Haas        30.12.2016 Creation                        */\n/**********************************************************************/\n)ATTR DEFAULT(%+_)\n   % TYPE(ET)                                      /* Emphasized Text */\n   + TYPE(NT)                                          /* Normal Text */\n   _ TYPE(NEF) CAPS(ON)                         /* Normal Entry Field */\n   $ TYPE(FP)                                         /* Field Prompt */\n   ~ TYPE(DT)                                     /* Descriptive Text */\n   ] AREA(SCRL) EXTEND(ON)                              /* Scrollarea */\n)BODY WINDOW(70,17)\n+\n$Command ===>_ZCMD                                                   +\n]SCROLLI                                                             ]\n)AREA SCROLLI\n$Input dataset . ._inpdsn                                            +\n+\n$Node ID/User ID ._nodeid  _userid  +                                +\n+\n$Input member  . ._inpmem1 %*~for all member,%/~for selection list+\n+                 _inpmem2 +\n+                 _inpmem3 +\n+                 _inpmem4 +\n+                 _inpmem5 +\n+\n$Output dataset  ._outdsn                                            +\n+\n+\n+\n)INIT\n  .CURSOR  = &cursor\n  &zwinttl = 'XMIT Manager'\n  &nodeid = &Z\n  &userid = &ZUSER\n  &outdsn = '''&ZUSER..xxx.xxx.XMIT'''\n)PROC\n  VER (&inpdsn,NB)\n  VER (&nodeid,NB)\n  VER (&inpmem1,NB)\n  VER (&outdsn,NB)\n  &zwinttl = ''\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT950/FILE950.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT950", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}