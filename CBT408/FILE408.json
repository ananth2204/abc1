{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011941000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 2704156, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 11, "INMDSNAM": "CBT.V500.FILE408.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 2704156, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 2704156, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE408.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00*\\r'", "DS1TRBAL": "b'&\\xc8'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x02\\xee\\x00\\x02\\x02\\xf0\\x00\\x0e\\x00+'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04]\\x00\\x19\\x01\\x165o\\x01\\x165o\\x15\\x05\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf3@@@'", "ispf": {"version": "04.93", "flags": 0, "createdate": "2016-12-21T00:00:00", "modifydate": "2016-12-21T15:05:19", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-493"}, "text": "REGULAR CBT TAPE - VERSION 493    FILE:  408\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT493.FILE408\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 33 MEMBERS COUNTED; CUMULATIVE SIZE IS 25,057 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   12/21/16    15:05:19    UTC-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#ALD": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x850/\\x00\\x850/\\x12\\x00\\x003\\x003\\x00\\x00\\xd6\\xd3\\xc4\\xd4\\xc1\\xc3\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-10-29T00:00:00", "modifydate": "1985-10-29T12:00:00", "lines": 51, "newlines": 51, "modlines": 0, "user": "OLDMACS"}, "text": "         MACRO\n&N       #ALD  &R,&A\n.*\n.*\n.*\n.* LAST CHANGE DATE - OCTOBER 18, 1983\n.*                  - MAILING ADDRESS CHANGE\n.*\n.* LAST CHANGE DATE - APRIL 21, 1981\n.*                  - MACRO NAME CHANGED F4OM $ALD TO #ALD\n.*\n.* LAST CHANGE DATE - FEBRUARY 2, 1977\n.*                  - MAILING ADDRESS CHANGE.\n.*\n.* LAST CHANGE DATE - FEBRUARY 3, 1976\n.*\n.* THIS MACRO WAS WRITTEN BY DAVID B. COLE. ANY QUESTIONS CONCERNING IT\n.* MAY BE ADDRESSED TO:\n.*       RR#2 BOX 712\n.*       AFTON, VA. 22920\n.*\n.*\n.*\n.*   THIS MACRO SIMULATES A HYPOTHETICAL \"ADD LOGICAL DOUBLE\" MACHINE\n.* INSTRUCTION. ITS FUNCTION IS SIMILAR TO THE \"AL\" MACHINE INSTRUCTION\n.* EXCEPT THAT IT OPERATES ON 64-BIT NUMBERS. WARNING, THE RESULTING\n.* CONDITION CODE IS NOT AN ANALOGOUS EXTENSION FROM THE \"AL\"\n.* INSTRUCTION.\n.*\n.* INNER MACROS USED - #TEST\n.*\n.*\n.*\n         GBLA  &#TESERR\n         GBLC  &#TESRET(20)\n         LCLA  &A1\n         LCLC  &RODD\n&RODD    SETC  '&R+1'\n         #TEST REGS=&R\n         AIF   (&#TESERR NE 0).REGUNKN\n&A1      SETA  &#TESRET(1)+1\n         AIF   (&A1 LE 15).GOTA1\n&A1      SETA  0\n.GOTA1   #TEST PFIX=\n&RODD    SETC  '&#TESRET(1)&A1'\n.REGUNKN ANOP\n&N       AL    &RODD,4+&A LOW-ORDER SUM; HI-ORDER AFFECTED?\n         BC    12,ALD&SYSNDX NO, SKIP\n         AL    &R,=F'1' YES, ADJUST HI-ORDER\nALD&SYSNDX AL  &R,&A GET HI-ORDER SUM\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "#ALDR": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x850/\\x00\\x850/\\x12\\x00\\x00<\\x00<\\x00\\x00\\xd6\\xd3\\xc4\\xd4\\xc1\\xc3\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-10-29T00:00:00", "modifydate": "1985-10-29T12:00:00", "lines": 60, "newlines": 60, "modlines": 0, "user": "OLDMACS"}, "text": "         MACRO\n&N       #ALDR &R1,&R2\n.*\n.*\n.*\n.* LAST CHANGE DATE - OCTOBER 18, 1983\n.*                  - MAILING ADDRESS CHANGE\n.*\n.* LAST CHANGE DATE - APRIL 21, 1981\n.*                  - MACRO NAME CHANGED FROM $ALDR TO #ALDR\n.*\n.* LAST CHANGE DATE - FEBRUARY 2, 1977\n.*                  - MAILING ADDRESS CHANGE\n.*\n.* LAST CHANGE DATE - FEBRUARY 3, 1976\n.*\n.* THIS MACRO WAS WRITTEN BY DAVID B. COLE. ANY QUESTIONS CONCERNING IT\n.* MAY BE ADDRESSED TO:\n.*       RR#2 BOX 712\n.*       AFTON, VA. 22920\n.*\n.*\n.*\n.*   THIS MACRO SIMULATES A HYPOTHETICAL \"ADD LOGICAL DOUBLE REGISTER\"\n.* MACHINE INSTRUCTION. ITS FUNCTION IS SIMILAR TO THE \"ALR\" MACHINE\n.* INSTRUCTION EXCEPT THAT IT OPERATES ON 64-BIT NUMBERS. WARNING,\n.* THE RESULTING CONDITION CODE IS NOT AN ANALOGOUS EXTENSION FROM THE\n.* \"ALR\" INSTRUCTION.\n.*\n.* INNER MACROS USED - #TEST\n.*\n.*\n.*\n         GBLA  &#TESERR\n         GBLC  &#TESRET(20)\n         LCLA  &A1\n         LCLC  &R1ODD,&R2ODD\n&R1ODD   SETC  '&R1+1'\n         #TEST REGS=&R1\n         AIF   (&#TESERR NE 0).R1UNKN\n&A1      SETA  &#TESRET(1)+1\n         AIF   (&A1 LE 15).GOTA1A\n&A1      SETA  0\n.GOTA1A  #TEST PFIX=\n&R1ODD   SETC  '&#TESRET(1)&A1'\n.R1UNKN  ANOP\n&R2ODD   SETC  '&R2+1'\n         #TEST REGS=&R2\n         AIF   (&#TESERR NE 0).R2UNKN\n&A1      SETA  &#TESRET(1)+1\n         AIF   (&A1 LE 15).GOTA1B\n&A1      SETA  0\n.GOTA1B  #TEST PFIX=\n&R2ODD   SETC  '&#TESRET(1)&A1'\n.R2UNKN  ANOP\n&N       ALR   &R1ODD,&R2ODD LOW-ORDER SUM; HI-ORDER AFFECTED?\n         BC    3,ALDR&SYSNDX NO, SKIP\n         BCTR  &R1,0 YES, ADJUST HI-ORDER\nALDR&SYSNDX ALR &R1,&R2 GET HI-ORDER SUM\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "#DCBD": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x850/\\x00\\x850/\\x12\\x00\\x08\\xd6\\x08\\xd6\\x00\\x00\\xd6\\xd3\\xc4\\xd4\\xc1\\xc3\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-10-29T00:00:00", "modifydate": "1985-10-29T12:00:00", "lines": 2262, "newlines": 2262, "modlines": 0, "user": "OLDMACS"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "#DIAG": {"ttr": 1291, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x850/\\x00\\x850/\\x12\\x00\\x00)\\x00)\\x00\\x00\\xd6\\xd3\\xc4\\xd4\\xc1\\xc3\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-10-29T00:00:00", "modifydate": "1985-10-29T12:00:00", "lines": 41, "newlines": 41, "modlines": 0, "user": "OLDMACS"}, "text": "         MACRO\n&N       #DIAG &R1,&R3,&D2\n.*\n.*\n.*\n.* LAST CHANGE DATE - OCTOBER 18, 1983\n.*                  - MAILING ADDRESS CHANGE\n.*\n.* LAST CHANGE DATE - APRIL 21, 1981\n.*                  - MACRO NAME CHANGED FROM $DIAG TO #DIAG.\n.*\n.* LAST CHANGE DATE - FEBRUARY 2, 1977\n.*                  - MAILING ADDRESS CHANGE.\n.*\n.* LAST CHANGE DATE - FEBRUARY 3, 1976\n.*\n.* THIS MACRO WAS WRITTEN BY DAVID B. COLE. ANY QUESTIONS CONCERNING IT\n.* MAY BE ADDRESSED TO:\n.*       RR#2 BOX 712\n.*       AFTON, VA. 22920\n.*\n.*\n.*\n.*   THIS MACRO GENERATES A DIAGNOSE MACHINE INSTRUCTION (OPCODE IS\n.* X'83'). IF THE THIRD POSITIONAL OPERAND IS PRESENT, THEN AN RS-TYPE\n.* INSTRUCTION FORMAT IS USED. IF THE THIRD POSITIONAL OPERAND IS\n.* OMITTED, THEN AN RX-TYPE INSTRUCTION FORMAT IS USED.\n.*\n.*\n.*\n.* INNER MACROS USED - NONE\n.*\n         AIF   (K'&D2 EQ 0).RX\n&N       LM    &R1,&R3,&D2 GENERATE AN RS-TYPE INSTRUCTION\n         AGO   .OPCODE\n.RX      ANOP\n&N       L     &R1,&R3 GENERATE AN RX-TYPE INSTRUCTION\n.OPCODE  ORG   *-4 LOCATE BACK TO CHANGE THE OPCODE\n         DC    X'83' GENERATE THE DIAGNOSE OPCODE\n         ORG   *+3 RELOCATE FORWARD\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#DIE": {"ttr": 1538, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x850/\\x00\\x850/\\x12\\x00\\x00\\xa0\\x00\\xa0\\x00\\x00\\xd6\\xd3\\xc4\\xd4\\xc1\\xc3\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-10-29T00:00:00", "modifydate": "1985-10-29T12:00:00", "lines": 160, "newlines": 160, "modlines": 0, "user": "OLDMACS"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "#DROP": {"ttr": 1542, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x850/\\x00\\x850/\\x12\\x00\\x00(\\x00(\\x00\\x00\\xd6\\xd3\\xc4\\xd4\\xc1\\xc3\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-10-29T00:00:00", "modifydate": "1985-10-29T12:00:00", "lines": 40, "newlines": 40, "modlines": 0, "user": "OLDMACS"}, "text": "         MACRO\n         #DROP  &D\n.*\n.*\n.*\n.* LAST CHANGE DATE - OCTOBER 18, 1983\n.*                  - MAILING ADDRESS CHANGE\n.*\n.* LAST CHANGE DATE - APRIL 21, 1981\n.*                  - MACRO NAME CHANGED FROM $DROP TO #DROP.\n.*\n.* LAST CHANGE DATE - FEBRUARY 2, 1977\n.*                  - MAILING ADDRESS CHANGE\n.*\n.* LAST CHANGE DATE - AUGUST 24, 1976\n.*\n.* THIS MACRO WAS WRITTEN BY DAVID B. COLE. ANY QUESTIONS CONCERNING\n.* IT MAY BE ADDRESSED TO:\n.*       RR#2 BOX 712\n.*       AFTON, VA. 22920\n.*\n.*\n.*\n.*   THIS MACRO GENERATES A DROP INSTRUCTION THAT RELEASES ALL BASES\n.* DECLARED BY A PRIOR #ENTER MACRO EXPANSION.\n.*\n.*\n.*\n.* INNER MACROS USED - NONE\n.*\n         GBLC  &#BS(14)\n         LCLA  &W1\n         AIF   ('&#BS(14)' EQ '').END\n&W1      SETA  14\n.LP2     AIF   (&W1 EQ 1).END\n&W1      SETA  &W1-1\n         AIF   ('&#BS(&W1)' EQ '').LP2\n         DROP  &#BS(&W1)\n         AGO   .LP2\n.END     MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#DSA": {"ttr": 1544, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x850/\\x00\\x850/\\x12\\x00\\x009\\x009\\x00\\x00\\xd6\\xd3\\xc4\\xd4\\xc1\\xc3\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-10-29T00:00:00", "modifydate": "1985-10-29T12:00:00", "lines": 57, "newlines": 57, "modlines": 0, "user": "OLDMACS"}, "text": "         MACRO\n&NME     #DSA  &D\n.*\n.*\n.*\n.* LAST CHANGE DATE - OCTOBER 18, 1983\n.*                  - MAILING ADDRESS CHANGE\n.*\n.* LAST CHANGE DATE - APRIL 21, 1981\n.*                  - MACRO NAME CHANGED FROM $DSA TO #DSA.\n.*\n.* LAST CHANGE DATE - FEBRUARY 2, 1977\n.*                  - MAILING ADDRESS CHANGE\n.*\n.* LAST CHANGE DATE - JANUARY 27, 1976\n.*\n.* THIS MACRO WAS WRITTEN BY DAVID B. COLE.  ANY QUESTIONS CONCERNING\n.* IT MAY BE ADDRESSED TO:\n.*       RR#2 BOX 712\n.*       AFTON, VA. 22920\n.*\n.*\n.*\n.*   THIS MACRO GENERATES A DSECT FOR A STANDARD REGISTER SAVE AREA.\n.* FREQUENTLY, A REENTRANT PROGRAM NEEDS TO GETMAIN A \"DATA STORAGE\n.* AREA\" AND USE THE BEGINNING OF IT AS A REGISTER SAVE AREA. IN THIS\n.* SITUATION, THIS MACRO CAN BE USED TO MAP THE BEGINNING OF THE DSA.\n.* THE REMAINDER OF THE DSA, OF COURSE, WOULD HAVE TO BE MAPPED\n.* MANUALLY.\n.*\n.*   IF THE NAME FIELD ON THE MACRO CALLING STATEMENT IS OMITTED, THEN\n.* THE GENERATED DSECT IS NAMED \"DSA\" AND ALL GENERATED FIELD NAMES ARE\n.* PREFIXED WITH \"DSA\". IF THE NAME FIELD IS USED, THEN IT INSTEAD OF\n.* \"DSA\" IS USED IN THE ABOVE MANNER.\n.*\n.*   INNER MACROS USED - NONE\n.*\n.*\n.*\n         LCLA  &A1\n         LCLC  &N\n&N       SETC  'DSA'\n         AIF   (K'&NME EQ 0).GOTNME\n&N       SETC  '&NME'\n.GOTNME  ANOP\n&N       DSECT  ,                  STANDARD REGISTER SAVE AREA\n&N.WD1   DS    A -                 WORD-1 (USED BY PL/1)\n&N.HSA   DS    A -                 HIGHER SAVE AREA POINTER\n&N.LSA   DS    A -                 LOWER SAVE AREA POINTER\n&N.R14   DS    A -                 REGISTER SAVE AREA (RETURN ADDRESS)\n&N.R15   DS    A -                 REGISTER SAVE AREA (ENTRY POINT)\n&A1      SETA  0-1\n.LP      AIF   (&A1 EQ 12).END\n&A1      SETA  &A1+1\n&N.R&A1  DS    A -                 REGISTER SAVE AREA\n         AGO   .LP\n.END     MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "#DSORG": {"ttr": 1546, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x850/\\x00\\x850/\\x12\\x00\\x00<\\x00<\\x00\\x00\\xd6\\xd3\\xc4\\xd4\\xc1\\xc3\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-10-29T00:00:00", "modifydate": "1985-10-29T12:00:00", "lines": 60, "newlines": 60, "modlines": 0, "user": "OLDMACS"}, "text": "         MACRO\n&N       #DSORG &D\n.*\n.*\n.*\n.* LAST CHANGE DATE - APRIL 21, 1981\n.*                  - MACRO NAME CHANGED FROM $DSORG TO #DSORG.\n.*\n.* LAST CHANGE DATE - FEBRUARY 2, 1977\n.*                  - MAILING ADDRESS CHANGE.\n.*\n.* LAST CHANGE DATE - APRIL 1, 1975\n.*\n.* THIS MACRO WAS WRITTEN BY DAVID B. COLE. ANY QUESTIONS CONCERNING\n.* IT MAY BE ADDRESSED TO:\n.*       809 WHITNEY AVE.\n.*       NEW HAVEN, CT. 06511\n.*\n.*\n.*\n.*   THIS MACRO WAS WRITTEN TO BE AN INNER MACRO FOR THE #DCBD MACRO.\n.* ITS SOLE PURPOSE IS TO GENERATE DSORG FIELD AND BIT NAMES FOR THE\n.* #DCBD MACRO.\n.*\n.*\n.*\n.* INNER MACROS USED - NONE\n.*\n         GBLB  &#DCBDSG\n         GBLB  &#DCBSW(150)\n         LCLC  &P\n&P       SETC  'DCB'\n         AIF   ('&N' EQ '').GOTPFIX\n&P       SETC  '&N'\n.GOTPFIX ANOP\n&P.DSORG DS    0BL2 -         DATA SET ORGANIZATION BEING USED\n&P.DSRG1 DS    BL1 -          FIRST BYTE OF DCBDSORG\n         AIF   (&#DCBDSG).SKP1\nDCBDSGIS EQU   BIT0 -         IS - INDEXED SEQUENTIAL ORGANIZATION\nDCBDSGPS EQU   BIT1 -         PS - SHYSICAL SEQUENTIAL ORGANIZATION\nDCBDSGDA EQU   BIT2 -         DA - DIRECT ORGANIZATION\nDCBDSGCX EQU   BIT3 -         CX - BTAM OR QTAM LINE GROUP\nDCBDSGCQ EQU   BIT4 -         CQ - QTAM DIRECT ACCESS MESSAGE QUEUE\nDCBDSGMQ EQU   BIT5 -         MQ - QTAM PROBLEM PROGRAM MESSAGE QUEUE\nDCBDSGPO EQU   BIT6 -         PO - PARTITIONED ORGANIZATION\nDCBDSGU  EQU   BIT7 -         U  - UNMOVABLE, THE DATA CONTAINS\n*                                  LOCATION DEPENDENT INFORMATION\n.SKP1    ANOP  ,\n&P.DSRG2 DS    BL1 -          SECOND BYTE OF DCBDSORG\n         AIF   (&#DCBDSG).SKP2\nDCBDSGGS EQU   BIT0 -         GS - GRAPHICS ORGANIZATION\nDCBDSGTX EQU   BIT1 -         TX - TCAM LINE GROUP\nDCBDSGTQ EQU   BIT2 -         TQ - TCAM MESSAGE QUEUE\nDCBACBM  EQU   BIT4 -         ACCESS METHOD CONTROL BLOCK   ICBI DCB-1\n         AIF   (&#DCBSW(44)).SKP2\n&#DCBSW(44) SETB (1)\nDCBDSGTR EQU   BIT5 -         TR - TCAM 3705                    S22024\n.SKP2    ANOP\n&#DCBDSG SETB  (1)\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#ENTER": {"ttr": 1548, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x850/\\x00\\x850/\\x12\\x00\\x03H\\x03H\\x00\\x00\\xd6\\xd3\\xc4\\xd4\\xc1\\xc3\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-10-29T00:00:00", "modifydate": "1985-10-29T12:00:00", "lines": 840, "newlines": 840, "modlines": 0, "user": "OLDMACS"}, "text": "         MACRO\n&N       #ENTER &NME,&ESDTYPE=DEFAULT,&BASES=1,&SAVTYPE=LOCAL,&PFIX=\n.*\n.*\n.*                                                            08/85 DBC\n.* LAST CHANGE DATE - AUGUST 12, 1985                         08/85 DBC\n.*                  - THIS MACRO NO LONGER ASSUMES THAT A     08/85 DBC\n.*                    SATISFIED UNCONDITIONAL GETMAIN         08/85 DBC\n.*                    REQUEST SETS R15 TO ZERO. ONE CUSTOMER  08/85 DBC\n.*                    ACTUALLY HAD A MODIFIED GETMAIN SVC     08/85 DBC\n.*                    ROUTINE THAT INSURED THAT R15 WAS       08/85 DBC\n.*                    UNCHANGED BY GETMAIN. THIS LED TO       08/85 DBC\n.*                    DISASTEROUS RESULTS WHEN HE ATTEMPTED   08/85 DBC\n.*                    TO USE THIS MACRO IN THAT               08/85 DBC\n.*                    ENVIRONMENT. NOW, CHANGING MY MACRO     08/85 DBC\n.*                    WAS A LOT SIMPLER THAN CHANGING HIS     08/85 DBC\n.*                    ENVIRONMENT, AND THERE WAS A LOT OF     08/85 DBC\n.*                    MONEY AT STAKE, SO ...                  08/85 DBC\n.*                                                            08/84 DBC\n.* LAST CHANGE DATE - AUGUST 8, 1984                          08/84 DBC\n.*                  - WHEN BASES=* IS SPECIFIED, #ENTER NOW   08/84 DBC\n.*                    DERIVES THE DESIRED BASE ADDRESS BY     08/84 DBC\n.*                    SUBTRACTING AN OFFSET FROM THE          08/84 DBC\n.*                    CURRENT ENTRY ADDRESS. PREVIOUSLY, IT   08/84 DBC\n.*                    WAS JUST LOADING AN ADCON FOR THE       08/84 DBC\n.*                    DESIRED BASE ADDRESS. THIS CAUSED       08/84 DBC\n.*                    PROBLEMS IF THE #ENTER MACRO WAS        08/84 DBC\n.*                    LOCATED WITHIN DYNAMICALLY RELOCATED    08/84 DBC\n.*                    CODE.                                   08/84 DBC\n.*                  - SIMILARLY, WHEN SAVTYPE=(REMOTE,NME%)   08/84 DBC\n.*                    IS SPECIFIED, THE DESIRED SAVE AREA     08/84 DBC\n.*                    IS LOCATED BY ADDING AN OFFSET (WHICH   08/84 DBC\n.*                    MAY BE NEGATIVE) TO THE CURRENT ENTRY   08/84 DBC\n.*                    ADDRESS.                                08/84 DBC\n.*                                                            06/84 DBC\n.* LAST CHANGE DATE - JUNE 11, 1984                           06/84 DBC\n.*                  - ADDED \"SAVTYPE=NONE\" SUPPORT.           06/84 DBC\n.*                  - WHEN A REMOTE SAVE AREA WAS USED,       06/84 DBC\n.*                    #ENTER USE TO GENERATE A \"USING\"        06/84 DBC\n.*                    STATEMENT DECLARING R13 AS A BASE FOR   06/84 DBC\n.*                    THAT SAVE AREA. THAT \"USING\" STATEMENT  06/84 DBC\n.*                    IS NO LONGER GENERATED.                 06/84 DBC\n.*\n.* LAST CHANGE DATE - OCTOBER 18, 1983\n.*                  - MAILING ADDRESS CHANGE\n.*\n.* LAST CHANGE DATE - APRIL 27, 1983\n.*                  - MAILING ADDRESS CHANGE.\n.*                  - USE OF IBM'S \"SAVE\" MACRO HAS BEEN\n.*                    REPLACED BY LOCAL CODE.\n.*                  - THE ASSEMBLY DATE AND TIME ARE NOW\n.*                    INCLUDED IN THE MODULE IDENTIFIER\n.*                    TEXT.\n.*\n.* LAST CHANGE DATE - APRIL 21, 1981\n.*                  - MACRO NAME CHANGED FROM $ENTER TO #ENTER.\n.*\n.* LAST CHANGE DATE - APRIL 15, 1981\n.*                  - ADDED ENTRY LINKAGE FOR A PLI ENVIRONMENT.\n.*                  - ADDED \"#REGS GEN=NO\" SUPPORT.\n.*\n.* LAST CHANGE DATE - JULY 18, 1980\n.*                  - BUG FIXED: THE PRECEEDING MODIFICATION INTRODUCED\n.*                    AN ERROR WHICH UNDER CERTAIN CIRCUMSTANCES\n.*                    GENERATED ASSEMBLY ERRORS.\n.*\n.* LAST CHANGE DATE - JULY 10, 1980\n.*                  - FOR GETMAINED REENTRANT SAVE AREAS, CODE HAS BEEN\n.*                    ADDED TO CLEAR THE ENTIRE GETMAINED AREA TO ZEROS\n.*                    BEFORE SETING THE CHAIN FIELD.\n.*                  - INDIRECT ADDRESSING TO A REMOTE SAVE AREA IS NOW\n.*                    SIGNALLED BY A TRAILING PERCENT SIGN RATHER THAN\n.*                    A LEADING PERCENT SIGN.\n.*\n.* LAST CHANGE DATE - OCTOBER 3, 1979\n.*                  - CODE HAS BEEN ALTERED SO THAT ADDRESSABILITY TO\n.*                    A REMOTE SAVE AREA DOES NOT HAVE TO BE BASED ON\n.*                    R15 (I.E., ON THE ENTRY ADDRESS).\n.*\n.* LAST CHANGE DATE - OCTOBER 3, 1978\n.*                  - THE GETMAIN FOR THE RENTRANT SAVE AREA HAS BEEN\n.*                    CHANGED SO THAT MORE THAN 4K BYTES CAN BE GOTTEN.\n.*\n.* LAST CHANGE DATE - FEBRUARY 28, 1978\n.*                  - BUG FIXED IN REMOTE SAVE AREA HANDLING\n.*\n.* LAST CHANGE DATE - JANUARY 29, 1978\n.*                  - IN MOST CASES IT IS LOGICALLY INCONSISTANT TO\n.*                    CODE 'BASES=*' WHEN ONE OF THE OLD BASES IS R13.\n.*                    THIS PROBLEM IS NOW RECOGNIZED AND FLAGGED.\n.*\n.*                  - A REMOTE SAVE AREA'S NAME CAN NOW BE GIVEN EITHER\n.*                    WITH OR WITHOUT A PRECEEDING PERCENT (%) SIGN TO\n.*                    INDICATE WHETHER THE NAMED ADDRESS MUST BE\n.*                    REACHED BY INDIRECT ADDRESSING.\n.*\n.* LAST CHANGE DATE - NOVEMBER 4, 1977\n.*                  - SUPPORT IS ADDED FOR DEFINING A LOCAL SAVE AREA\n.*                    WHOSE LENGTH IS OTHER THAN 72 BYTES.\n.*\n.* LAST CHANGE DATE - JANUARY 13, 1977\n.*                  - THE MF= AND SVID= OPERANDS ARE REPLACED BY THE\n.*                    SAVTYPE= OPERAND.\n.*                  - SUPPORT FOR THE HANDLING OF A REMOTELY ASSEMBLED\n.*                    SAVE AREA.\n.*                  - MAILING ADDRESS CHANGE.\n.*\n.* LAST CHANGE DATE - SEPTEMBER 14, 1976\n.*                  - IMPLEMENT SUPPORT FOR \"BASES=*\" WHICH IMPLIES\n.*                    THAT BOTH THE BASE ADDRESS AND BASE REGISTERS\n.*                    DEFINED BY THE PHYSICALLY PREVIOUS USE OF THE\n.*                    #ENTER MACRO ARE TO BE REUSED.\n.*\n.* LAST CHANGE DATE - AUGUST 23, 1976\n.*\n.* THIS MACRO WAS WRITTEN BY DAVID B. COLE.  ANY QUESTIONS CONCERNING\n.* IT MAY BE ADDRESSED TO:\n.*       RR#2 BOX 712\n.*       AFTON, VA. 22920\n.*\n.*\n.*\n.*   THIS MACRO GENERATES OS STANDARD ENTRY LINKAGE. IT WAS WRITTEN TO\n.* PROVIDE A SIMPLE, FLEXIBLE, AND COMPLETE METHOD OF GENERATING SUCH\n.* LINKAGE. IN ADDITION, FOR ALMOST ALL OPERAND COMBINATIONS, #ENTER\n.* WILL GENERATE THE ABSOLUTE MINIMUM AMOUNT OF CODE NECESSARY.\n.*\n.*   THE #ENTER MACRO WILL GENERATE THE FOLLOWING:\n.*     - A CSECT OR ENTRY CARD (IF DESIRED)\n.*     - A MODULE IDENTIFIER WHICH WILL INCLUDE THE ASSEMBLY\n.*       DATE AND TIME.\n.*     - CODE TO SAVE ALL REGISTERS IN THE HIGHER SAVE AREA\n.*     - CODE TO LOAD R13 WITH A POINTER TO A LOWER SAVE AREA\n.*     - CODE TO CROSS LINK THE LOWER SAVE AREA WITH THE HIGHER SAVE\n.*       AREA\n.*     - CODE TO LOAD ANY SET OF BASE REGISTERS\n.*     - A USING STATEMENT DECLARING THE SET OF BASE REGISTERS\n.*     - EITHER THE LOWER SAVE AREA ITSELF OR CODE TO GETMAIN A\n.*       REENTRANT SAVE AREA OF 72 OR MORE BYTES OR CODE TO LOAD THE\n.*       ADDRESS OF AN ASSEMBLED SAVE AREA THAT IS REMOTE FROM THE\n.*       MACRO EXPANSION.\n.*     - FOR A GETMAINED REENTRANT SAVE AREA, CODE TO CLEAR THE AREA TO\n.*       ZEROS.\n.*\n.* &N\n.*       THIS IS THE ONLY FIELD REQUIRED FOR THE MACRO CALL. IT MUST\n.*       SPECIFY THE DESIRED CONTROL SECTION OR ENTRY NAME.\n.*\n.* &NME\n.*       USE THIS FIELD TO SPECIFY OPTIONAL TEXT TO BE\n.*       INCLUDED INTO THE MODULE IDENTIFIER. ENCLOSING\n.*       QUOTES ARE OPTIONAL.\n.*\n.* &ESDTYPE=\n.*       THIS OPERAND CONTROLS THE TYPE OF EXTERNAL SYMBOL (IF ANY) TO\n.*       BE GENERATED USING &N. VALID VALUES FOR THIS OPERAND IMPLY THE\n.*       FOLLOWING:\n.*              -OMITTED-    ==> ESDTYPE=ENTRY IF SAVTYPE=PLI\n.*              -OMITTED-    ==> ESDTYPE=CSECT OTHERWISE\n.*             ESDTYPE=CSECT ==>\n.*                     &N       CSECT\n.*             ESDTYPE=START ==>\n.*                     &N       START\n.*             ESDTYPE=ENTRY ==>\n.*                              ENTRY &N\n.*                     &N       DS    0H\n.*             ESDTYPE=     <==>\n.*             ESDTYPE=NONE  ==>\n.*                     &N       DS    0H\n.*\n.* &BASES=\n.*       USE THIS OPERAND TO SPECIFY EITHER HOW MANY OR EXACTLY WHICH\n.*       BASE REGISTERS TO DECLARE AND LOAD. VALID VALUES FOR THIS\n.*       OPERAND ARE:\n.*             BASES= -A SINGLE SELF DEFINING NUMERIC-\n.*                   THIS REQUESTS THAT A SPECIFIC NUMBER OF BASES BE\n.*                   LOADED AND DECLARED. THE MACRO IS ALLOWED TO\n.*                   DETERMINE FOR ITSELF PRECISELY WHICH REGISERS TO\n.*                   DECLARE AS FOLLOWS. FOR SAVTYPE=LOCAL (SEE BELOW)\n.*                   THE FIRST BASE REGISTER WILL BE R13; OTHERWISE\n.*                   (I.E. FOR SAVTYPE=RENT OR SAVTYPE=REMOTE), THE\n.*                   FIRST BASE REGISTER WILL BE R12. IN EITHER CASE,\n.*                   ADDITIONAL BASES WILL BE SUCCESSIVELY LOWER\n.*                   NUMBERED REGISTERS. EXAMPLES:\n.*                   BASES=3,SAVTYPE=RENT  ==> R12, R11, AND R10.\n.*                   BASES=2,SAVTYPE=LOCAL ==> R13, AND R12.\n.*             BASES= -A SUBLIST OF ONE OR MORE REGISTER NAMES-\n.*                   THE LISTED REGISTERS ARE LOADED AND DECLARED AS\n.*                   BASES. THE LEFTMOST LISTED REGISTER IS LOADED WITH\n.*                   THE LOWEST ADDRESS. EXAMPLE:\n.*                   BASES=(R5,6,4) ==> R5, R6, AND R4 IN THAT ORDER.\n.*             BASES=*\n.*                   THE BASE ADDRESS AND BASE REGISTERS DEFINED BY THE\n.*                   PHYSICALLY PREVIOUS #ENTER MACRO ARE REUSED.\n.*          THE BASES= OPERAND MAY BE NULLIFIED BY SPECIFYING EITHER:\n.*             BASES=\n.*             BASES=0\n.*       IN THIS CASE, NO BASE REGISTERS ARE LOADED OR DECLARED.\n.*          IF THE BASES= OPERAND IS OMITTED, THEN A DEFAULT OF BASES=1\n.*       WILL BE USED.\n.*\n.* &SAVTYPE=\n.*       THIS OPERAND IDENTIFIES THE TYPE OR LOCATION OF THE SAVE AREA\n.*       TO BE GENERATED OR USED. VALID VALUES ARE:\n.*             -OMITTED-\n.*             SAVTYPE=\n.*             SAVTYPE=LOCAL\n.*             SAVTYPE=(,-SAVE AREA NAME-)\n.*             SAVTYPE=(LOCAL,-SAVE AREA NAME-)\n.*             SAVTYPE=(LOCAL,,-SAVE AREA LENGTH-)\n.*             SAVTYPE=(LOCAL,-SAVE AREA NAME-,-SAVE AREA LENGTH-)\n.*                     A STANDARD SAVE AREA IS GENERATED IN THE\n.*                     THE MACRO EXPANSION AND ITS ADDRESS IS LOADED\n.*                     INTO R13. NOTE, DEPENDING UPON THE BASES=\n.*                     OPERAND (SEE ABOVE) R13 MAY ALSO BE DECLARED AS\n.*                     A PROGRAM BASE.\n.*                        IF A -SAVE AREA NAME- IS GIVEN, THEN IT IS\n.*                     USED TO LABEL THE SAVE AREA; OTHERWISE, AN\n.*                     INTERNAL NAME IS GENERATED.\n.*                              IF -SAVE AREA LENGTH- IS GIVEN, THEN IT\n.*                              IS USED TO SET THE LENGTH OF THE SAVE\n.*                              AREA; OTHERWISE, THE DEFAULT LENGTH OF\n.*                              72 BYTES IS USED.\n.*             SAVTYPE=(REMOTE,-SAVE AREA ADDRESS-)\n.*                     THE ADDRESS OF THE REMOTE SAVE AREA IS\n.*                     LOADED INTO R13. NOTE, IN THIS CASE -SAVE AREA\n.*                     ADDRESS- IS A REQUIRED SUB-OPERAND. IT MAY BE\n.*                     EITHER AN ADDRESS LABEL OR A PARENTHESIZED\n.*                     REGISTER NAME OR AN ADDRESS LABEL FOLLOWED BY A\n.*                     PERCENT (%) SIGN. IF THE NAME IS JUST AN ADDRESS\n.*                     LABEL, THEN A 'LA' INSTRUCTION IS USED TO LOAD\n.*                     THE SAVE AREA'S ADDRESS. IF A PERCENT SIGN\n.*                     FOLLOWS THE NAME, THEN AN ADDRESS CONSTANT IS\n.*                     GENERATED AND A 'L' INSTRUCTION IS USED. IF A\n.*                     REGISTER NAME IS GIVEN, THEN A 'LR' INSTRUCTION\n.*                     IS USED UNLESS THE MACRO CAN DETERMINE THAT THE\n.*                     NAMED REGISTER IS ACTUALLY R13 IN WHICH CASE IT\n.*                     IS ASSUMED THAT THE LOWER SAVE AREA IS ALREADY\n.*                     PRESENT AND INITIALIZED, SO THE SAVING OF\n.*                     REGISTERS AND THE CROSS-CHAINING OF THE SAVE\n.*                     AREAS IS BYPASSED.\n.*             SAVTYPE=RENT\n.*             SAVTYPE=(RENT,(-LENGTH-,-SUBPOOL-),-ERROR ADDRESS-)\n.*             SAVTYPE=(RENT,(-LENGTH-,-SUBPOOL-),RETURN)\n.*                     THE MACRO EXPANSION IS TO BE REENTRANT. THE SAVE\n.*                     AREA IS TO BE GETMAINED. THE SUB-OPERANDS HAVE\n.*                     THE FOLLOWING AFFECT:\n.*                     -LENGTH- IS OPTIONAL. IF OMITTED, THEN A VALUE\n.*                              OF 72 IS USED. IF GIVEN, THEN IT\n.*                              INDICATES THE SIZE OF THE SAVE AREA TO\n.*                              BE GOTTEN. WARNING, THE VALUE OF\n.*                              -LENGTH- SHOULD NEVER BE LESS THAN 72.\n.*                     -SUBPOOL- IS OPTIONAL. IF OMITTED, THEN A VALUE\n.*                               OF 0 IS IMPLIED. IF GIVEN, THEN IT\n.*                               SPECIFIES THE SUBPOOL OUT OF WHICH THE\n.*                               SAVE AREA IS TO BE GOTTEN.\n.*                     -ERROR ADDRESS- IS OPTIONAL. IF OMITTED, THEN\n.*                                     THE SAVE AREA GETMAIN REQUEST IS\n.*                                     UNCONDITIONAL. IF GIVEN, THEN\n.*                                     THE GETMAIN IS CONDITIONAL, AND\n.*                                     IF IT FAILS, THEN CONTROL IS\n.*                                     PASSED TO THE INDICATED ADDRESS.\n.*                                     NOTE, -ERROR ADDRESS- MAY BE\n.*                                     EITHER A STATEMENT LABEL OR A\n.*                                     PARENTHESIZED REGISTER NAME.\n.*                                     WARNING, -ERROR ADDRESS- MAY BE\n.*                                     USED ONLY IN A MVS ENVIRONMENT.\n.*                                     IT IS NOT SUPPORTED UNDER MVT.\n.*                     RETURN IS A SPECIAL FORM OF -ERROR ADDRESS-\n.*                            WHICH, IF GIVEN, CAUSES CONTROL TO BE\n.*                            RETURNED IMMEDIATELY TO THE CALLER IN THE\n.*                            EVENT OF A GETMAIN FAILURE. ALL REGISTERS\n.*                            ARE RESTORED EXCEPT R15 WHICH CONTAINS\n.*                            THE RETURN CODE FROM GETMAIN.\n.*             SAVTYPE=PLI\n.*             SAVTYPE=NONE                                   06/84 DBC\n.*                     NO LOCAL LEVEL SAVEAREA IS DEFINED OR  06/84 DBC\n.*                     USED.                                  06/84 DBC\n.*             SAVTYPE=(PLI,-LENGTH-)\n.*                     THE MACRO IS TO EXPAND INTO THE FORMAT OF A PLI\n.*                     PROLOG. THE EXPANSION IS REENTRANT. THE SAVE\n.*                     AREA WILL BE A PLI DSA. IT WILL PROBABLY BE\n.*                     OBTAINED FROM PLI'S ISA. IF -LENGTH- IS GIVEN,\n.*                     THEN IT SPECIFIES THE DESIRED LENGTH OF THE DSA\n.*                     THAT THIS EXPANSION OBTAINS. WARNING, THE VALUE\n.*                     OF -LENGTH- MUST NEVER BE LESS THAN 88.\n.*\n.* &PFIX=\n.*       THE #ENTER MACRO ATTEMPTS TO USE REGISTER EQUATES IN ITS\n.*       EXPANSION WHEN REFERING TO REGISTERS. THIS IS SO THAT THE USE\n.*       OF THE REGISTERS IS INDICATED IN THE ASSEMBLER'S CROSS\n.*       REFERENCE LISTING. THE PFIX= OPERAND CAN BE USED TO CONTROL\n.*       THE SET OF EQUATES USED. FOR EXAMPLE, IF \"PFIX=GPR\" IS GIVEN,\n.*       THEN \"GPR1\" IS USED WHENEVER THE EXPANSION REFERS FO REGISTER\n.*       1.\n.*          IF THE PFIX= OPERAND IS OMITTED, THEN THE SET OF REGISTER\n.*       EQUATES DEFINED BY THE NEXT PRIOR #REGS MACRO IS USED. IF\n.*       THERE ARE NO PRIOR #REGS MACROS, THEN SELF-DEFINING NUMERICS\n.*       ARE USED.\n.*\n.* MISCELLANIOUS CONSIDERATIONS\n.*     - SINCE THE #ENTER MACRO EXPANSION USUALLY INCLUDES A CSECT\n.*       CARD, THE MACRO CALL SHOULD BE PLACED AT THE PHYSICAL\n.*       BEGINNING OF A CONTROL SECTION.\n.*     - FOR LOCAL SAVE AREAS IT IS BOTH POSSIBLE AND REASONABLE FOR\n.*       R13 TO SERVE AS BOTH THE SAVE AREA POINTER AND A PROGRAM BASE.\n.*       THERE ARE, HOWEVER, CERTAIN PRECAUTIONS THAT HAVE TO BE TAKEN\n.*       FOR VARIOUS SYSTEM EXIT ROUTINES IF THEY ARE INCLUDED IN THE\n.*       PROGRAM. HERE ARE SOME EXAMPLES:\n.*           - IOS APPENDAGE ROUTINES: NO BASE REGISTER FOR THE MAIN\n.*             PROGRAM, INCLUDING R13, IS AVAILABLE FROM WITHIN AN IOS\n.*             APPENDAGE.\n.*           - DCB OPEN EXITS: R13 REMAINS A VALID BASE REGISTER.\n.*           - EOD ROUTINES: R13 REMAINS A VALID BASE REGISTER.\n.*           - SYNAD EXITS: R13 REMAINS A VALID BASE REGISTER UNTIL A\n.*             SYNADAF MACRO IS ISSUED. AFTER A SUBSEQUENT SYNADRLS\n.*             MACRO, R13 IS AGAIN A VALID PROGRAM BASE.\n.*\n.*\n.*\n.* INNER MACROS USED - #USING, #TEST, SAVE, GETMAIN\n.*\n         GBLA  &#TESERR\n         GBLB  &#ENTRNT,&#ENTPLI,&#ENTNUN                     06/84 DBC\n         GBLC  &#TESRET(20),&#ENTSIZ,&#ENTSP,&#BS(14)\n         LCLA  &A1,&A2,&C1,&C2,&C3,&C4,&B(13),&RMTREGA\n         LCLB  &REDUN(13),&OLDBASE,&REMOTE(5),&ALIGND,&LOCAL,&LENGTH\n         LCLC  &LID,&@,&#,&N1,&N2,&W2,&W3,&R,&RMTREGC,&SAVLEN,&RMTNAME\n         LCLC  &SPOOL,&TB,&ESDT,&C                            06/84 DBC\n&#       SETC  '&SYSNDX'\n&#ENTRNT SETB  (0)\n&#ENTPLI SETB  (0)\n&#ENTNUN SETB  (0)\n&C1      SETA  11\n.*                                                            06/84 DBC\n         AIF   ('&SAVTYPE' NE 'NONE').TYPNNON                 06/84 DBC\n&#ENTNUN SETB  (1)                                            06/84 DBC\n         AGO   .PFXTST                                        06/84 DBC\n.TYPNNON ANOP                                                 06/84 DBC\n.*                                                            06/84 DBC\n         AIF   ('&SAVTYPE(1)' NE 'RENT').TYPNRNT\n&#ENTRNT SETB  (1)\n&#ENTSIZ SETC  '72'\n&#ENTSP  SETC  ''\n         #TEST DCODE=&SAVTYPE(2)\n&A1      SETA  &#TESRET(1)\n         AIF   (&A1 EQ 0).PFXTST\n         AIF   ('&#TESRET(2)' EQ '').DFLTLEN\n&#ENTSIZ SETC  '&#TESRET(2)'\n.DFLTLEN AIF   (&A1 EQ 1).PFXTST\n&#ENTSP  SETC  '&#TESRET(3)'\n         AGO   .PFXTST\n.TYPNRNT ANOP\n.*\n         AIF   ('&SAVTYPE(1)' NE 'REMOTE').TYPNRMT\n&REMOTE(1) SETB (1)\n         AIF   ('&SAVTYPE(2)' NE '').GOTRMT2\n         MNOTE 12,'ERROR - SAVTYPE(2) (REMOTE AREA''S NAME) OMITTED.'\n.GOTRMT2 AIF   ('&SAVTYPE(2)'(1,1) EQ '(').TYPLCL2\n&REMOTE(2) SETB (1)\n&RMTNAME SETC  '&SAVTYPE(2)'\n         AIF   ('&SAVTYPE(2)'(K'&SAVTYPE(2),1) NE '%').PFXTST\n&REMOTE(5) SETB (1)\n&RMTNAME SETC  '&SAVTYPE(2)'(1,K'&SAVTYPE(2)-1)\n         AGO   .PFXTST\n.TYPLCL2 #TEST DCODE=&SAVTYPE(2)\n&RMTREGC SETC  '&#TESRET(2)'\n         #TEST REGS=&RMTREGC\n         AIF   (&#TESERR NE 0).PFXTST\n&RMTREGA SETA  &#TESRET(1)\n         AIF   (&RMTREGA NE 13).PFXTST\n&REMOTE(3) SETB (1)\n         AGO   .PFXTST\n.TYPNRMT ANOP\n.*\n         AIF   ('&SAVTYPE(1)' NE 'PLI').TYPNPLI\n&#ENTPLI SETB  (1)\n&C1      SETA  10\n         AGO   .PFXTST\n.TYPNPLI ANOP\n.*\n         AIF   ('&SAVTYPE(1)' EQ '' OR '&SAVTYPE(1)' EQ 'LOCAL').TYPLCL\n         MNOTE 4,'SAVTYPE(1)=&SAVTYPE(1) IS INVALID.'\n         MNOTE 4,'SAVTYPE(1)=LOCAL ASSUMED.'\n.TYPLCL  ANOP\n&LOCAL   SETB  (1)\n&C1      SETA  12\n&LID     SETC  'E&#.SVA'\n         AIF   ('&SAVTYPE(2)' EQ '').GOTSLID\n&LID     SETC  '&SAVTYPE(2)'\n.GOTSLID ANOP\n&SAVLEN  SETC  '72'\n         AIF   ('&SAVTYPE(3)' EQ '').PFXTST\n&SAVLEN  SETC  '&SAVTYPE(3)'\n.*\n.PFXTST  ANOP\n&@       SETC  '&PFIX'\n         AIF   (K'&PFIX NE 0).GOTPFIX\n         #TEST PFIX=\n&@       SETC  '&#TESRET(1)'\n         AGO   .DONPFIX\n.GOTPFIX #REGS &PFIX,GEN=NO\n.DONPFIX ANOP\n.*                                                            06/84 DBC\n&A1      SETA  0\n         AIF   ('&BASES' NE '*').BSCLR\n.BSOLD   AIF   (&A1 EQ 13).BASEND\n&A1      SETA  &A1+1\n         AIF   ('&#BS(&A1)' EQ '').BSOLD\n         #TEST REGS=&#BS(&A1)\n&B(&A1)  SETA  16\n         AIF   (&#TESERR NE 0).BSOLD\n&B(&A1)  SETA  &#TESRET(1)\n         AIF   (&B(&A1) NE 13).BSOLD\n         AIF   (&A1 NE 13 OR '&#BS(14)' NE '&RMTNAME' OR &#ENTRNT OR &#*\n               ENTPLI).BSERROR\n&REMOTE(4) SETB (1)\n         AGO   .BSOLD\n.BSERROR ANOP\n         MNOTE 4,'THE OLD BASE REGISTER &B(&A1) CANNOT ALSO FUNCTION'\n         MNOTE 4,'AS A SAVE AREA POINTER IN THIS CONTEXT.'\n         MNOTE 4,'THE CODE GENERATED BELOW WILL NOT FUNCTION CORRECTLY.*\n               '\n         AGO   .BSOLD\n.BSCLR   AIF   (&A1 EQ 14).BSCLRD\n&A1      SETA  &A1+1\n&#BS(&A1) SETC ''\n         AGO   .BSCLR\n.BSCLRD  AIF   (K'&BASES EQ 0).BASEND\n         AIF   ('&BASES' NE '&BASES(1)').TSTNBSE\n         #TEST NUM=&BASES\n         AIF   (&#TESERR EQ 0).BSEOKX\n         MNOTE 4,'\"BASES=&BASES\" IS INVALID.'\n         MNOTE 4,'\"BASES=1\" ASSUMED.'\n&C3      SETA  1\n         AGO   .BSESET\n.BSEOKX  ANOP\n&C3      SETA  &BASES\n         AIF   (&C3 LE &C1).BSESET\n         MNOTE 4,'\"BASES=&BASES\" IS OUTSIDE THE RANGE OF 0...&C1..'\n         MNOTE 4,'THE CODE GENERATED BELOW WILL NOT FUNCTION CORRECTLY.*\n               '\n.BSESET  ANOP\n&C1      SETA  &C1+1\n&C3      SETA  &C1-&C3\n&C4      SETA  13\n.BOK     AIF   (&C1 LE &C3).BASEND\n&#BS(&C4) SETC '&@&C1'\n&B(&C4)  SETA  &C1\n&C1      SETA  &C1-1\n&C4      SETA  &C4-1\n         AGO   .BOK\n.TSTNBSE ANOP\n&C3      SETA  N'&BASES\n         AIF   (&C3 LE &C1).NBSOK\n         MNOTE 4,'\"BASES=&BASES\" SPECIFIES TOO MAY REGISTERS.'\n         MNOTE 4,'ONLY THE FIRST &C1 REGISTERS WILL BE USED.'\n&C3      SETA  &C1\n.NBSOK   ANOP\n&C1      SETA  &C1+1\n&C4      SETA  13\n&C2      SETA  0\n.GETBSE  AIF   (&C2 GE &C3).BASEND\n&C2      SETA  &C2+1\n         AIF   ('&BASES(&C2)' EQ '').IGNR\n         #TEST REGS=&BASES(&C2)\n&B(&C4)  SETA  16\n         AIF   (&#TESERR EQ 16).REGUNK\n         AIF   (&#TESRET(1) GE 2 AND &#TESRET(1) LE &C1).BSEOK2\n         MNOTE 4,'\"BASES(&C2)=&BASES(&C2)\" IS OUTSIDE THE RANGE OF 2...*\n               &C1..'\n         MNOTE 4,'THE CODE GENERATED BELOW WILL NOT FUNCTION CORRECTLY.*\n               '\n         AGO   .BSEOK2\n.IGNR    AIF   (&C3 GE N'&BASES).GETBSE\n&C3      SETA  &C3+1\n         AGO   .GETBSE\n.BSEOK2  AIF   (NOT &REDUN(&#TESRET(1))).BSEOK3\n         MNOTE 4,'\"BASES(&C2)=&BASES(&C2) IS REDUNDANT.'\n         MNOTE 4,'THE CODE GENERATED BELOW WILL NOT FUNCTION CORRECTLY.*\n               '\n.BSEOK3  ANOP\n&REDUN(&#TESRET(1)) SETB (1)\n&B(&C4)  SETA &#TESRET(1)\n.REGUNK  ANOP\n&C1      SETA  12\n&#BS(&C4) SETC '&BASES(&C2)'\n&C4      SETA  &C4-1\n         AGO   .GETBSE\n.BASEND  ANOP\n.*\n&R       SETC  '&@.1'\n&C3      SETA  0\n.WRLP    AIF   (&C3 GE 13).GOTWRG\n&C3      SETA  &C3+1\n         AIF   ('&#BS(&C3)' EQ '').WRLP\n         AIF   (&B(&C3) EQ 13).GOTWRG\n&R       SETC  '&#BS(&C3)'\n.GOTWRG  ANOP\n.*\n&ESDT    SETC  '&ESDTYPE(1)'\n         AIF   (&#ENTPLI).PLIGEN\n.*\n         AIF   ('&ESDT' NE 'DEFAULT').GOTESD\n&ESDT    SETC  'CSECT'\n.GOTESD  ANOP\n&N2      SETC  '&N'\n         AIF   ('&ESDT' EQ 'NONE' OR '&ESDT' EQ '' OR '&ESDT' EQ 'ENTRY*\n               ').NCSCETC\n         AIF   ('&ESDT' NE 'CSECT').ESDNCSC\n&N       CSECT ,                   START CONTROL SECTION\n         AGO   .ESDDONE\n.ESDNCSC AIF   ('&ESDT' NE 'START').ESDNSTA\n&N       START ,                   START CONTOL SECTION\n         AGO   .ESDDONE\n.ESDNSTA ANOP\n&W2      SETC  '&ESDT'\n&N       &W2   0H'0'               START\n.ESDDONE ANOP\n&N2      SETC  ''\n.*\n.NCSCETC AIF   ('&ESDT' NE 'ENTRY').NENTRY\n         ENTRY &N                  MAKE NAME EXTERNALLY AVAILABLE\n.NENTRY  ANOP\n.*\n         AIF   (K'&NME EQ 0 AND '&ESDT' NE 'CSECT' AND '&ESDT' NE 'STAR*\n               T').NMODID\n&N2      B     E&#.ZID-&N.(,&@.15) SKIP AROUND THE MODULE ID\n&N2      SETC  'E&#.ZID'\n         DC    AL1(&N2-E&#.MID)    LENGTH OF TEXT\nE&#.MID  DC    C'&N '              ENTRY NAME\n&W2      SETC  '&SYSDATE       '(1,8).' '\n         DC    C'&W2'              ASSEMBLY DATE\n&W2      SETC  '&SYSTIME    '(1,5)\n         AIF   (K'&NME EQ 0).NMEZ1\n&W2      SETC  '&W2 - '\n.NMEZ1   DC    C'&W2'              ASSEMBLY TIME\n         AIF   (K'&NME EQ 0).NMEZ2\n         AIF   ('&NME'(1,1) EQ '''').QNME\n         DC    C'&NME'\n         AGO   .NMEZ2\n.QNME    DC    C&NME\n.NMEZ2   ANOP\n.NMODID  ANOP\n.*\n         AIF   (&REMOTE(3)).RNTRNT1\n&W2      SETC  '&@.14,&@.12,12(&@.13)'\n&N2      STM   &W2                 SAVE CALLER'S REGISTERS\n&N2      SETC  ''\n.*\n         AIF   (&#ENTRNT OR &#ENTNUN).RNTRNT1                 06/84 DBC\n         LR    &R,&@.13            POINT TO HIGHER SA\n         AIF   (&REMOTE(1)).LRMTSV1\n&C       SETC  '&@.13,&LID-&N.(,&@.15)'                       06/84 DBC\n         LA    &C                  POINT TO LOWER SA\n         AGO   .LRMTSV2\n.LRMTSV1 AIF   (&REMOTE(2)).LRMTSV3\n         #TEST REGS=&R\n         AIF   (&RMTREGA NE &#TESRET(1)).LRMTSV4\n&A1      SETA  20+&RMTREGA*4-&RMTREGA/13*44\n         L     &@.13,&A1.(,&@.13)  POINT TO LOWER SA\n         AGO   .LRMTSV2\n.LRMTSV4 LR    &@.13,&RMTREGC      POINT TO LOWER SA\n         AGO   .LRMTSV2\n.LRMTSV3 AIF   (&REMOTE(5)).LRMTSV5\n         PUSH  USING               SAVE USING ENVIRONMENT\n         USING &N,&@.15            DECLARE TEMP BASE\n         LA    &@.13,&RMTNAME      POINT TO LOWER SA\n         POP   USING               RESTORE USING ENVIRONMENT\n         AGO   .LRMTSV2                                       06/84 DBC\n.LRMTSV5 ANOP                                                 06/84 DBC\n         LR    &@.13,&@.15         POINT TO LOWER SA          08/84 DBC\n&C       SETC  '&@.13,E&#.SAP-&N.(,&@.15)'                    06/84 DBC\n         AH    &C                                             08/84 DBC\n.LRMTSV2 ST    &@.13,8(,&R)        FORWARD CHAIN THE SAVE AREAS\n         ST    &R,4(,&@.13)        BACK CHAIN THE SAVE AREAS\n         AIF   ('&R' NE '&@.1').RNTRNT1\n         L     &@.1,24(,&@.1)      RESTORE REGISTER 1\n.RNTRNT1 AIF   ('&#BS(13)' EQ '').SKIPUSE\n&C1      SETA  13\n         AIF   ('&BASES' NE '*').BSEADR\n         AIF   (&REMOTE(4)).EQUATE\n&OLDBASE SETB  (1)\n&N2      LR    &#BS(13),&@.15      LOAD 1ST BASE REGISTER     08/84 DBC\n&N2      SETC  ''                                             08/84 DBC\n&C       SETC  '&#BS(13),E&#.BSE-&N.(,&@.15)'                 06/84 DBC\n         SH    &C                                             08/84 DBC\n         AGO   .EQUATE\n.BSEADR  ANOP\n&C2      SETA  15\n&#BS(14) SETC  '&N'\n         AIF   (&#ENTRNT OR &REMOTE(1) OR &#ENTNUN).FLDTST    06/84 DBC\n&C2      SETA  13\n&#BS(14) SETC  '&LID'\n.FLDTST  AIF   (&B(13) EQ &C2).EQUATE\n&N2      LR    &#BS(13),&@&C2      LOAD FIRST BASE REGISTER\n&N2      SETC  ''\n.EQUATE  ANOP\n&W2      SETC  '&#BS(&C1)'\n         AIF   (&C1 EQ 2).ENDLA\n&C1      SETA  &C1-1\n         AIF   ('&#BS(&C1)' EQ '').ENDLA\n&N2      LA    &#BS(&C1),X'FFF'(,&W2) LOAD NEXT BASE\n&N2      SETC  ''\n         AGO   .EQUATE\n.ENDLA   #USING\n.SKIPUSE AIF   (NOT &#ENTRNT).DATACHK\n&W2      SETC  ''\n&TB      SETC  ''\n         AIF   ('&#BS(13)' NE '').GETM2\n&N2      LR    &@.14,&@.15         LOAD TEMPORARY BASE\n&N2      SETC  ''\n         PUSH  USING               SAVE BASES\n         DROP  ,                   CLEAR BASES\n         USING &N,&@.14            DECLARE TEMPORARY BASE\n&TB      SETC  '-&N.(,&@.14)'\n.GETM2   ANOP\n&N2      L     &@.0,E&#.LEN        LOAD LENGTH (MAYBE SUBPOOL TOO)\n&N2      SETC  ''\n         AIF   ('&#ENTSP' EQ '' OR '&SAVTYPE(3)' EQ '').GETM4\n&SPOOL   SETC  ''\n         MNOTE '         GETMAIN RC,LV=(0),SP=&#ENTSP'\n         GETMAIN RC,LV=(0),SP=&#ENTSP\n         AGO   .GETM5\n.GETM4   ANOP\n&SPOOL   SETC  '&#ENTSP'\n&W3      SETC  'R'\n         AIF   ('&SAVTYPE(3)' EQ '').GETM4A\n&W3      SETC  'RC'\n.GETM4A  MNOTE '         GETMAIN &W3,LV=(0)'\n         GETMAIN &W3,LV=(0)\n.GETM5   AIF   ('&#BS(13)' NE '').GETM5A\n         POP   USING               RESTURE BASES\n.GETM5A  AIF   ('&SAVTYPE(3)' EQ '').GETM7\n         LTR   &@.15,&@.15         GETMAIN OK?\n         AIF   ('&SAVTYPE(3)' EQ 'RETURN').GETM8\n         AIF   ('&SAVTYPE(3)'(1,1) EQ '(').GETM6\n         BNZ   &SAVTYPE(3)         NO, TAKE ERROR EXIT\n         AGO   .GETM7\n.GETM6   #TEST DCODE=&SAVTYPE(3)\n         BCR   7,&#TESRET(2)       NO, TAKE ERROR EXIT\n         AGO   .GETM7\n.GETM8   ANOP\n&W2      SETC  'E&#.GO'\n         BZ    &W2&TB              YES, PROCEED\n         L     &@.14,12(,&@.13)    NO, RESTORE REGISTER\n         LM    &@.0,&@.12,20(&@.13) RESTORE REGISTERS\n         MVI   12(&@.13),X'FF'     SET RETURNED SIGNEL\n         BR    &@.14               RETURN TO CALLER\n.GETM7   ANOP\n&W2      LR    &@.0,&@.1           POINT TO AREA TO CLEAR\n         L     &@.1,E&#.LEN&TB     GET LENGTH TO CLEAR\n         LR    &@.14,&@.0          SAVE AREA POINTER\n         SLR   &@.15,&@.15         CLEAR SRC LEN AND PAD CHAR 08/85 DBC\n         MVCL  &@.0,&@.14          CLEAR THE AREA (R15 SET BY GETMAIN)\n         ST    &@.14,8(,&@.13)     FORWARD CHAIN THE SAVE AREAS\n         ST    &@.13,4(,&@.14)     BACK CHAIN THE SAVE AREAS\n         LM    &@.13,&@.1,8(&@.13) RESTORE REGS AND POINT TO LOWER SA\n.DATACHK AIF   (NOT &OLDBASE AND NOT &#ENTRNT AND NOT &REMOTE(5) AND NO*\n               T &LOCAL).ENDCHK\n         AIF   ('&#BS(13)' EQ '').NOUSING\n&N2      B     E&#.END             SKIP AROUND DATA AREA\n&N2      SETC  ''\n         AGO   .DFNDATA\n.NOUSING ANOP\n&N2      B     E&#.END-&N.(,&@.15) SKIP AROUND DATA AREA\n&N2      SETC  ''\n.DFNDATA ANOP                                                 08/84 DBC\n.*                                                            08/84 DBC\n         AIF   (NOT &OLDBASE).NOLDBSE                         08/84 DBC\nE&#.BSE  DC    Y(&N-&#BS(14))       OLD BASE ADDRESS          08/84 DBC\n.NOLDBSE ANOP                                                 08/84 DBC\n.*                                                            08/84 DBC\n         AIF   (NOT &#ENTRNT).NLENGTH                         08/84 DBC\n         AIF   ('&SPOOL' EQ '').NSUBPOO\n         AIF   (&ALIGND).ALIGND1\n         DS    0F                  ALIGNMENT\n&ALIGND  SETB  (1)\n.ALIGND1 ANOP\nE&#.LEN  DC    AL1(&SPOOL),AL3(&#ENTSIZ) SAVE AREA SUBPOOL AND LENGTH\n         AGO   .NLENGTH\n.NSUBPOO ANOP\nE&#.LEN  DC    A(&#ENTSIZ)         SAVE AREA LENGTH\n&ALIGND  SETB  (1)\n.NLENGTH AIF   (&#ENTRNT OR &#ENTNUN).NSVAREA                 06/84 DBC\n         AIF   (&REMOTE(1)).RMTSVPT\n         AIF   (&ALIGND).ALIGND2\n         DS    0F                  ALIGNMENT\n&ALIGND  SETB  (1)\n.ALIGND2 ANOP\n&LID     DC    (&SAVLEN)X'00'      LOCAL SAVE AREA\n         AGO   .NSVAREA\n.RMTSVPT ANOP                                                 08/84 DBC\n.*                                                            08/84 DBC\n         AIF   (NOT &REMOTE(5)).NSVAREA                       08/84 DBC\nE&#.SAP  DC    Y(&RMTNAME-&N)       PTR TO REMOTE SA          08/84 DBC\n.NSVAREA ANOP                                                 08/84 DBC\n.*                                                            08/84 DBC\n         AGO   .END                                           08/84 DBC\n.*\n.PLIGEN  AIF   ('&ESDT' EQ 'DEFAULT').PESDSET\n         AIF   (K'&N GT 0 OR '&ESDT' NE 'ENTRY').PESDOK1\n         MNOTE 4,'\"ESDTYPE=&ESDTYPE\" IS INVALID WHEN THE NAME FIELD IS'\n         MNOTE 4,'OMITTED FROM THE MACRO CALL.'\n         MNOTE 4,'\"ESDTYPE=NONE\" WILL BE USED INSTEAD.'\n&ESDT    SETC  'NONE'\n.PESDOK1 ANOP\n         AIF   ('&ESDT' EQ 'ENTRY' OR '&ESDT' EQ 'NONE' OR '&ESDT' EQ '*\n               ').PESDOK\n         MNOTE 4,'\"ESDTYPE=&ESDTYPE\" IS INVALID WHEN \"SAVTYPE=PLI\".'\n.PESDSET ANOP\n&ESDT    SETC  'ENTRY'\n         AIF   (K'&N GT 0).PESDOK2\n&ESDT    SETC  'NONE'\n.PESDOK2 AIF   ('&ESDTYPE' EQ 'DEFAULT').PESDOK\n         MNOTE 4,'\"ESDTYPE=&ESDT\" WILL BE USED INSTEAD.'\n.PESDOK  ANOP\n         AIF   ('&ESDT' NE 'ENTRY').PNOTENT\n         ENTRY &N                  MAKE NAME EXTERNALLY AVAILABLE\n.PNOTENT ANOP\n.*\n&N2      SETC  '&N'\n&A1      SETA  K'&N\n         AIF   (K'&NME EQ 0).GOTN2\n&N2      SETC  '&NME'\n&A1      SETA  K'&NME\n.GOTN2   ANOP\n&N2      SETC  ' '(1,1-(&A1-&A1/2*2)).'&N2'\n         DS    0H                  ALIGNMENT\n         DC    C'&N2'              ENTRY NAME\n         DC    AL1(&A1)            LENGTH OF NAME\n.*\n&N1      SETC  '&N'\n         AIF   (K'&N GT 0).PGOTN1\n&N1      SETC  'E&#.ENT'\n.PGOTN1  ANOP\n         USING &N1,&@.15           DCL LOCAL BASE\n&N1      STM   &@.14,&@.12,12(&@.13) SAVE CALLER'S REGISTERS\n.*\n         #TEST DCODE=&SAVTYPE(2)\n&A1      SETA  &#TESRET(1)\n&A2      SETA  120\n         AIF   (&A1 EQ 0).DSALLA\n         AIF   ('&#TESRET(2)' NE '&SAVTYPE(2)').DSALREG\n         #TEST NUM=&#TESRET(2)\n         AIF   (&#TESERR NE 0).DSALL\n&A2      SETA  &#TESRET(2)\n         AIF   (&A2 GE 4096-7).DSALL\n         AIF   (&A2 GE 120-7).DSALLA\n         MNOTE 4,'\"SAVTYPE(2)=&SAVTYPE(2)\" IS TOO SHORT A LENGTH.'\n         MNOTE 4,'THE CODE GENERATED BELOW WILL NOT FUNCTION CORRECTLY.*\n               '\n.DSALLA  ANOP\n         LA    &@.0,(&A2+7)/8*8    GET DESIRED DSA LENGTH\n         AGO   .GOTDSAL\n.DSALREG #TEST REGS=&#TESRET(2)\n         AIF   (&#TESERR NE 0).DSALLR\n         AIF   (&#TESRET(1) EQ 0).GOTLLR\n.DSALLR  LR    &@.0,&#TESRET(2)    GET DESIRED DSA LENGTH\n.GOTLLR  LA    &@.14,7             ROUND UP -\n         AR    &@.0,&@.14           TO -\n         OR    &@.0,&@.14            DOUBLE WORD -\n         XR    &@.0,&@.14             LENGTH\n         AGO   .GOTDSAL\n.DSALL   ANOP\n&LENGTH  SETB  (1)\n         L     &@.0,E&#.LEN        GET DESIRED DSA LENGTH\n.GOTDSAL ANOP\n.*\n         L     &@.1,76(,&@.13)     GET NXT AVAILABLE BLOCK POINTER\n         ALR   &@.0,&@.1           --> PAST DESIRED AREA\n         CL    &@.0,12(,&@.12)     WOULD THE ISA OVERFLOW?\n         BNH   E&#.GOT             NO, PROCEED\n         L     &@.15,116(,&@.12)   YES, --> SPECIAL HANDLER\n         DROP  &@.15               RELEASE CLOBBERED BASE\n         BALR  &@.14,&@.15         GO OBTAIN DESIRED DSA FROM ELSEWHERE\nE&#.GOT  LR    &@.14,&@.1          SAVE PTR TO NEW DSA\n         LR    &@.15,&@.0          SAVE HI-BYTE OF NAB POINTER REG\n         SRL   &@.15,24            ISSOLATE IT\n         SLL   &@.15,24            RESTORE ITS POSITION. SET MVCL\n*                                  SOURCE LENGTH TO ZERO\n         SR    &@.0,&@.1           GET LENGTH OF NEW DSA\n         LR    &@.1,&@.0           COPY FOR MVCL SINK LENGTH\n         LR    &@.0,&@.14          GET MVCL SINK POINTER\n         MVCL  &@.0,&@.14          CLEAR THE NEW DSA\n         OR    &@.0,&@.15          RESTORE HI-BYTE TO NAB POINTER REG\n         LR    &@.1,&@.0           COPY NEXT AVAILABLE BLOCK POINTER\n         L     &@.15,72(,&@.13)    GET LIBRARY WORKSPACE POINTER\n         STM   &@.15,&@.1,72(&@.14) STORE INTO OUR NEW DSA\n         ST    &@.5,88(,&@.14)     STORE PASSED PARAMETERS POINTER\n         ST    &@.13,4(,&@.14)     BACK CHAIN THE DSA\n         L     &@.1,24(,&@.13)     RESTORE PLIST POINTER\n         LR    &@.13,&@.14         --> NEW DSA (R14 PURIFIED BY MVCL)\n         MVI   0(&@.13),X'80'      SET FOR -\n         MVI   1(&@.13),X'00'       PLI -\n         MVI   86(&@.13),X'91'       ERROR -\n         MVI   87(&@.13),X'C0'        HANDLING\n.*\n&N2      SETC  ''\n         AIF   ('&#BS(13)' EQ '').PSKPUSE\n&C1      SETA  13\n         AIF   ('&BASES' NE '*').PBSEADR\n&OLDBASE SETB  (1)\n         BALR  &#BS(13),0          LOAD TEMP LOCAL BASE\n         L     &#BS(13),E&#.BSE-*(,&#BS(13)) LOAD 1ST PROGRAM BASE\n         AGO   .PEQUATE\n.PBSEADR ANOP\n&N2      SETC  'E&#.BSE'\n&#BS(14) SETC  '&N2'\n         BALR  &#BS(13),0          LOAD 1ST PROGRAM BASE\n.PEQUATE ANOP\n&W2      SETC  '&#BS(&C1)'\n&C1      SETA  &C1-1\n         AIF   (&C1 EQ 1 OR '&#BS(&C1)' EQ '').PENDLA\n&N2      LA    &#BS(&C1),X'FFF'(,&W2) LOAD NEXT PROGRAM BASE\n&N2      SETC  ''\n         AGO   .PEQUATE\n.PENDLA  #USING ,\n.PSKPUSE ANOP\n.*\n         AIF   (NOT &LENGTH AND NOT &OLDBASE).ENDCHK\n         AIF   ('&#BS(13)' NE '').PGOTBAS\n&N2      BALR  &@.15,0             LOAD TEMP BASE\n&N2      SETC  ''\n         B     E&#.END-*(,&@.15)   SKIP DATA AREA\n         AGO   .PDFNDAT\n.PGOTBAS ANOP\n&N2      B     E&#.END             SKIP DATA AREA\n&N2      SETC  ''\n.PDFNDAT AIF   (NOT &LENGTH).PNOLEN\nE&#.LEN  DC    A((&SAVTYPE(2)+7)/8*8) DESIRED DSA LENGTH\n.PNOLEN  AIF   (NOT &OLDBASE).PNOOBAS\nE&#.BSE  DC    A(&#BS(14))         OLD BASE ADDRESS\n.PNOOBAS ANOP\n.*\n.END     ANOP\nE&#.END  DS    0H\n.ENDCHK  AIF   ('&N2' EQ '').MEND\n&N2      DS    0H\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "#EXIT": {"ttr": 2049, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x850/\\x00\\x850/\\x12\\x00\\x01\\x82\\x01\\x82\\x00\\x00\\xd6\\xd3\\xc4\\xd4\\xc1\\xc3\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-10-29T00:00:00", "modifydate": "1985-10-29T12:00:00", "lines": 386, "newlines": 386, "modlines": 0, "user": "OLDMACS"}, "text": "         MACRO\n&NME     #EXIT &R,&PFIX=,&RC=,&MODE=LEAVE                     DBC 04/85\n.*\n.*\n.*                                                            DBC 04/85\n.* LAST CHANGE DATE - APRIL 29, 1985                          DBC 04/85\n.*                  - ADDED SUPPORT FOR THE \"MODE=\" OPERAND.  DBC 04/85\n.*                                                            DBC 10/84\n.* LAST CHANGE DATE - OCTOBER 1, 1984                         DBC 10/84\n.*                  - DELETED CODE THAT SET A X'FF' \"RETURN   DBC 10/84\n.*                    INDICATOR\" IN THE HI-BYTE OF DSAR14.    DBC 10/84\n.*                    IT WAS NOT APPROPRIATE FOR MVS/XA.      DBC 10/84\n.*                                                            DBC 06/84\n.* LAST CHANGE DATE - JUNE 11, 1984                           DBC 06/84\n.*                  - ADDED SUPPORT FOR \"SAVTYPE=NONE\" ON THE DBC 06/84\n.*                    #ENTER MACRO.                           DBC 06/84\n.*                  - FOR REENTRANT EXIT LINKAGE, CHANGED     DBC 06/84\n.*                    THE FREEMAIN SO THAT IT WOULD NO        DBC 06/84\n.*                    LONGER GENERATE AN INLINE PLIST.        DBC 06/84\n.*\n.* LAST CHANGE DATE - OCTOBER 18, 1983\n.*                  - MAILING ADDRESS CHANGE\n.*\n.* LAST CHANGE DATE - APRIL 21, 1981\n.*                  - CHANGE THE MACRO NAME FROM $EXIT TO #EXIT\n.*\n.* LAST CHANGE DATE - APRIL 15, 1981\n.*                  - ADDED EXIT LINKAGE FOR A PLI ENVIRONMENT.\n.*                  - \"#REGS GEN=NO\" SUPPORT ADDED.\n.*\n.* LAST CHANGE DATE - OCTOBER 3, 1978\n.*                  - FOR REENTRANT SAVE AREAS, THE FREEMAIN HAS BEEN\n.*                    CHANGED SO THAT MORE THAN 4K CAN BE FREED.\n.*\n.* LAST CHANGE DATE - FEBRUARY 2, 1977\n.*                  - MAILING ADDRESS CHANGE.\n.*\n.* LAST CHANGE DATE - FEBRUARY 10, 1976\n.*\n.* THIS MACRO WAS WRITTEN BY DAVID B. COLE.  ANY QUESTIONS CONCERNING\n.* IT MAY BE ADDRESSED TO:\n.*       RR#2 BOX 712\n.*       AFTON, VA. 22920\n.*\n.*\n.*\n.*   THIS MACRO GENERATES EITHER OS STANDARD OR PLI STANDARD EXIT\n.* LINKAGE. IT WAS WRITTEN TO PROVIDE A SIMPLE, FLEXIBLE, AND COMPLETE\n.* METHOD FOR GENERATING SUCH LINKAGE. IN ADDITION, FOR ALL POSSIBLE\n.* OPERAND COMBINATIONS, #EXIT WILL GENERATE THE ABSOLUTE MINIMUM\n.* AMOUNT OF CODE NECESSARY.\n.*\n.*   THE #EXIT MACRO WILL GENERATE THE FOLLOWING:\n.* - CODE TO LOAD REGISTER 13 WITH A POINTER TO THE HIGHER OS SAVE AREA\n.*   OR PLI DATA STORAGE AREA\n.* - CODE TO RELEASE (VIA FREEMAIN) THE LOWER SAVE AREA IF THE\n.*   PRECEEDING #ENTER MACRO CALL GENERATED A REENTRANT EXPANSION\n.* - CODE TO RESTORE ANY PARTICULAR SET OF REGISTERS\n.* - CODE TO LOAD REGISTER 15 WITH A RETURN CODE THAT IS EITHER AN\n.*   ABSOLUTE VALUE OR A VALUE PRELOADED INTO ANY REGISTER\n.* - CODE TO RETURN TO THE CALLING PROGRAM VIA REGISTER 14\n.*\n.*   THE NAME FIELD\n.* USE THIS FIELD TO ASSIGN A STATEMENT LABEL TO THE FIRST MACHINE\n.* INSTRUCTION OF THE EXPANSION. IF THE NAME FIELD IS OMITTED, THEN NO\n.* STATEMENT LABEL IS ASSIGNED.\n.*\n.*   THE FIRST POSITIONAL OPERAND\n.* THIS OPERAND MUST CONSIST OF A SUB-LIST OF ANY NUMBER OF ENTRIES.\n.* EACH ENTRY MAY BE EITHER A SINGLE REGISTER NAME OR A PARENTHESIZED\n.* PAIR (SEPERATED BY A COMMA) OF REGISTER NAMES - E.G.\n.* \" (1,11,(7,9),5) \". EACH SINGLE REGISTER NAME SPECIFIES A PARTICULAR\n.* REGISTER TO BE RESTORED FROM THE HIGHER SAVE AREA. EACH\n.* PARENTHESIZED PAIR OF REGISTER NAMES SPECIFIES A RANGE OF REGISTERS\n.* TO BE RESTORED. THUS, THE ABOVE EXAMPLE WOULD CAUSE REGISTERS 1, 5,\n.* 7, 8, 9, AND 11 TO BE RESTORED.\n.*   SOME NOTES AND WARNINGS:\n.* - A REQUEST TO RESTORE REGISTER 13 IS MEANINGLESS AND IS IGNORED.\n.* - IF REGISTER 14 IS TO BE LOADED WITH THE RETURN ADDRESS FOUND IN\n.*   THE HIGHER SAVE AREA, THEN YOU MUST SPECIFICALLY REQUEST THAT IT\n.*   (REGISTER 14) BE RESTORED; OTHERWISE, WHATEVER VALUE IS FOUND IN\n.*   REGISTER 14 PRIOR TO THE MACRO CALL WILL BE USED FOR THE RETURN\n.*   ADDRESS.\n.* - TO RESTORE ALL REGISTERS FROM 14 THROUGH 12, YOU MUST CODE\n.*   \" ((14,12)) \". CODING \" (14,12) \" WILL CAUSE ONLY REGISTERS 14 AND\n.*   12 TO BE RESTORED.\n.* - THE NUMERIC VALUES OF ALL REGISTER NAMES USED IN THIS OPERAND MUST\n.*   BE DETERMINABLE AT MACRO PASS TIME. THUS, EACH REGISTER NAME USED\n.*   MUST BE EITHER A SELF-DEFINING NUMERIC OR A NAME DEFINED VIA THE\n.*   #REGS MACRO.\n.* - IF ONLY A SINGLE REGISTER IS TO BE RESTORED, THEN IT NEED NOT BE\n.*   ENCLOSED IN PARENTHESES.\n.* - IF THE FIRST POSITIONAL OPERAND IS OMITTED, THEN NO REGISTERS ARE\n.*   RESTORED.\n.*\n.*   THE RC= OPERAND\n.* THIS OPERAND MUST CONSIST OF A SINGLE VALUE EITHER WITHIN OR NOT\n.* WITHIN PARENTHESES. IF ENCLOSED WITHIN PARENTHESES, THEN THE VALUE\n.* IS TREATED AS THE NAME OF A REGISTER CONTAINING A RETURN CODE. IF\n.* NOT ENCLOSED WITHIN PARENTHESES, THEN THE VALUE IS TREATED AS BEING\n.* THE RETURN CODE ITSELF.\n.*   IF THE RC= OPERAND SPECIFIES A REGISTER NAME, THEN:\n.* - THE VALUE OF THAT NAME NEED NOT BE DETERMINABLE AT MACRO PASS\n.*   TIME;\n.* - THE REGISTER NAME MAY IDENTIFY ANY REGISTER WHATSOEVER REGUARDLESS\n.*   OF WHICH REGISTERS ARE TO BE RESTORED SINCE IN CASES OF POTENTIAL\n.*   CONFLICT, THE RETURN CODE IS COPIED INTO REGISTER 15 PRIOR TO\n.*   REGISTER RESTORATION;\n.* - IT IS ILLOGICAL FOR THE RC= OPERAND TO SPECIFY REGISTER 13.\n.* NOTE THAT IF THE RC= OPERAND IS SPECIFIED BUT THE FIRST POSITIONAL\n.* OPERAND INDICATES THAT REGISTER 15 IS ALSO TO BE RESTORED, THEN\n.* REGISTER 15 IS NOT RESTORED. INSTEAD, IT IS LOADED WITH THE RETURN\n.* CODE VALUE.\n.*   IF THE RC= OPERAND IS OMITTED, THEN NO CODE IS GENERATED TO LOAD\n.* REGISTER 15 WITH A RETURN CODE.\n.*                                                            DBC 04/85\n.*   THE MODE= OPERAND                                        DBC 04/85\n.* THIS FOR MVS/XA. IT CONTROLS WHETHER OR NOT THE #EXIT      DBC 04/85\n.* MACRO IS TO GENERATE CODE TO RESTORE THE CALLER'S          DBC 04/85\n.* ADDRESSING MODE. THE DEFAULT IS NOT TO DO SO.              DBC 04/85\n.*                                                            DBC 04/85\n.* - MODE=LEAVE                                               DBC 04/85\n.*   THIS IS THE DEFAULT. NO EXPLICIT ATTEMPT IS MADE TO      DBC 04/85\n.*   RESTORE THE CALLER'S ADDRESSING MODE.                    DBC 04/85\n.*                                                            DBC 04/85\n.* - MODE=RESTORE                                             DBC 04/85\n.*   THE #EXIT MACRO ATTEMPTS TO RESTORE THE CALLER'S         DBC 04/85\n.*   ADDRESSING MODE BASED ON THE HI-ORDER BIT OF THE         DBC 04/85\n.*   CALLER'S R14.                                            DBC 04/85\n.*\n.*   THE PFIX= OPERAND\n.* THE #EXIT MACRO ATTEMPTS TO USE REGISTER EQUATES IN ITS EXPANSION\n.* WHEN REFERING TO REGISTERS. THIS IS SO THAT THE USE OF THE REGISTERS\n.* WILL BE INDICATED IN THE CROSS REFERENCE LISTING. THE PFIX= OPERAND\n.* CAN BE USED TO CONTROL THE SET OF EQUATES USED. FOR EXAMPLE, IF\n.* \"PFIX=GPR\" IS SPECIFIED, THEN \"GPR1\" WILL BE USED WHENEVER THE\n.* EXPANSION REFERS TO REGISTER 1.\n.*   IF THE PFIX= OPERAND IS OMITTED, THEN THE SET OF EQUATES DEFINED\n.* BY THE FIRST PRIOR #REGS MACRO WILL BE USED. IF THERE IS NO PRIOR\n.* #REGS MACRO, THEN NO EQUATES WILL BE USED.\n.*\n.*   CONSIDERATIONS\n.* THE #EXIT MACRO WILL GENERATE AN EXPANSION THAT WILL ACCURATELY\n.* RESTORE ALL DESIRED REGISTERS AND SET THE RETURN CODE REGUARDLESS OF\n.* WHETHER OR NOT A FREEMAIN SVC IS ISSUED TO RELEASE THE LOWER SAVE\n.* AREA AND REGUARDLESS OF THE RELATIONSHIP BETWEEN THE RC= OPERAND AND\n.* THE SET OF REGISTERS RESTORED.\n.*\n.*\n.*\n.* INNER MACROS USED - #REGS #TEST AND FREEMAIN\n.*\n         GBLA  &#TESERR\n         GBLB  &#ENTRNT,&#ENTPLI,&#ENTNUN                     DBC 06/84\n         GBLC  &#TESRET(20),&#ENTSIZ,&#ENTSP\n         LCLA  &C1,&R1,&R2,&W1,&W2,&ERRCODE\n         LCLB  &RCLA,&RCST,&RSW(16)\n         LCLC  &LNME,&@,&RG(16),&REGNME,&RG2SAVE,&RG4SAVE,&RG5SAVE\n         LCLC  &C,&#                                          DBC 06/84\n&#       SETC  '&SYSNDX'                                      DBC 06/84\n&LNME    SETC  '&NME'\n.*\n&@       SETC  '&PFIX'\n         AIF   (K'&PFIX NE 0).GOTPFIX\n         #TEST PFIX=\n&@       SETC  '&#TESRET(1)'\n         AGO   .DONPFIX\n.GOTPFIX #REGS &PFIX,GEN=NO\n.DONPFIX ANOP\n.*\n&C1      SETA  0                                              DBC 06/84\n.RLP     AIF   (&C1 GE N'&R).RFIN\n&C1      SETA  &C1+1\n         #TEST DCODE=&R(&C1)\n         AIF   (&#TESERR NE 0).END\n&W1      SETA  &#TESRET(1)\n         AIF   (&W1 EQ 0).RLP\n&REGNME  SETC  '&#TESRET(2)'\n         #TEST REGS=&REGNME\n&ERRCODE SETA  1\n         AIF   (&#TESERR NE 0).REGERR\n.REGOK1  ANOP\n&R1      SETA  &#TESRET(1)\n&R2      SETA  &R1+3-&R1/14*16\n&RG(&R2) SETC  '&REGNME'\n&RSW(&R1+1) SETB (1)\n         AIF   (&W1 EQ 1).RLP\n         AIF   (&W1 EQ 2).TWOND\n         MNOTE 4,'\"&R(&C1)\" CONTAINS EXCESS INFORMATION.'\n.TWOND   ANOP\n&REGNME  SETC  '&#TESRET(3)'\n         #TEST REGS=&REGNME\n&ERRCODE SETA  2\n         AIF   (&#TESERR NE 0).REGERR\n.REGOK2  ANOP\n&W2      SETA  &#TESRET(1)\n&RSW(&W2+1) SETB (1)\n.ENTLP   AIF   (&R1 EQ &#TESRET(1)).ENTEND\n&R1      SETA  &R1+1\n&R2      SETA  &R2+1\n         AIF   (&R1 LE 15).R1OK\n&R1      SETA  0\n.R1OK    AIF   (&R2 LE 16).R2OK\n&R2      SETA  1\n.R2OK    ANOP\n&RG(&R2) SETC  '&@&R1'\n         AGO   .ENTLP\n.ENTEND  ANOP\n&RG(&R2) SETC  '&REGNME'\n         AGO   .RLP\n.REGERR  AIF   (&#TESRET(1) GE 0 OR &#TESRET(1) LT 0).REGVALU\n         MNOTE 0,'THE ABOVE ERROR IS NOT DUE TO A BUG IN THE MACRO.'\n         MNOTE 8,'THE VALUE OF \"&REGNME\" IS NOT DETERMINABLE.'\n         MEXIT\n.REGVALU AIF   (&#TESRET(1) GE 0 AND &#TESRET(1) LE 15).REGOK\n         MNOTE 8,'THE VALUE OF \"&REGNME\" IS OUTSIDE THE RANGE OF 0 ... *\n               15'\n         MEXIT\n.REGOK   AIF   (&ERRCODE EQ 1).REGOK1\n         AGO   .REGOK2\n.RFIN    AIF   (NOT &#ENTPLI).RGOK\n         AIF   (NOT &RSW(1)).RG0OK\n         MNOTE 4,'&RG(3) NEEDED BY THE EXIT LINKAGE - NOT RESTORED.'\n.RG0OK   AIF   (NOT &RSW(2)).RG1OK\n         MNOTE 4,'&RG(4) NEEDED BY THE EXIT LINKAGE - NOT RESTORED.'\n.RG1OK   ANOP\n&RG(3)   SETC  ''\n&RG(4)   SETC  ''\n.RGOK    ANOP\n.*\n&RG(16)  SETC  ''\n.*\n         AIF   (K'&RC EQ 0).NORC\n&RG2SAVE SETC  '&RG(2)'\n&RG(2)   SETC  ''\n         AIF   ('&RG2SAVE' NE '').RG2SOK\n&RG2SAVE SETC  '&@.15'\n.RG2SOK  ANOP\n.*\n         AIF   (NOT &RSW(16)).NOPRBLM\n         MNOTE 4,'&RG2SAVE SET TO THE RETURN CODE - NOT RESTORED.'\n.NOPRBLM ANOP\n.*\n         AIF   ('&RC' EQ '&RC(1)').RCNTRG\n         #TEST REGS=&RC(1)\n         AIF   (&#TESERR NE 0).LOADRC\n         AIF   ('&#TESRET(1)' NE '13').RCOK\n         MNOTE 4,'\"RC=&RC\" IS ILLOGICAL.'\n.RCOK    AIF   ('&#TESRET(1)' EQ '15').NORC\n.LOADRC  AIF   ('&RG(1)' EQ '' OR '&RG(3)' EQ '' OR &#ENTPLI).RCLR\n&RCST    SETB  (1)\n         AGO   .NORC\n.RCLR    ANOP\n&LNME    LR    &@.15,&RC(1)        LOAD THE RETURN CODE\n&LNME    SETC  ''\n         AGO   .NORC\n.RCNTRG  ANOP\n&RCLA    SETB  (1)\n         AIF   ('&RG(3)' EQ '' OR '&RG(1)' EQ '').NORC\n&RG(2)   SETC  '&RG2SAVE'\n.NORC    ANOP\n.*\n         AIF   (NOT &#ENTPLI).NOTPLI2\n&LNME    LR    &@.0,&@.13          COPY OUR DSA POINTER\n&LNME    SETC  ''\n.NOTPLI2 ANOP\n.*\n         AIF   (NOT &#ENTRNT OR '&RG(4)' EQ '').NOLRR1\n&LNME    LR    &@.1,&@.13          GET SAVE AREA ADDRESS FOR FREEMAIN\n&LNME    SETC  ''\n.NOLRR1  ANOP\n.*\n         AIF   (&#ENTNUN).NOLSA                               DBC 06/84\n&LNME    L     &@.13,4(,&@.13)     POINT TO THE HIGHER SAVE AREA\n&LNME    SETC  ''                                             DBC 06/84\n.NOLSA   ANOP                                                 DBC 06/84\n         AIF   (NOT &RCST).NORCST\n&LNME    ST    &RC(1),16(,&@.13)   STORE THE RC FOR LATER     DBC 06/84\n&LNME    SETC  ''                                             DBC 06/84\n&RG(2)   SETC  '&RG2SAVE'\n.NORCST  ANOP\n.*\n         AIF   (NOT &#ENTRNT).NTRENT\n         AIF   (NOT &RCLA).RG2OK\n&RG(2)   SETC  'X'\n         AIF   ('&RG(1)&RG(3)' NE '').RG2OK\n&RG(2)   SETC  ''\n.RG2OK   ANOP\n&RG4SAVE SETC  '&RG(4)'\n&RG5SAVE SETC  '&RG(5)'\n&RG(5)   SETC  'X'\n&C1      SETA  0\n.STMLP   AIF   (&C1 GE 4).STMEND\n&C1      SETA  &C1+1\n         AIF   ('&RG(&C1)' NE '').STMLP\n&R1      SETA  &C1+13-(&C1+13)/16*16\n&R2      SETA  &R1-1\n&W1      SETA  &C1*4+8\n.STMLP2  ANOP\n&R2      SETA  &R2+1\n         AIF   (&R2 LE 15).STMR2OK\n&R2      SETA  0\n.STMR2OK ANOP\n&RG(&C1) SETC  '&@&R2'\n&C1      SETA  &C1+1\n         AIF   ('&RG(&C1)' EQ '').STMLP2\n         AIF   (&R1 EQ &R2).ST\n&C       SETC  '&@&R1,&@&R2,&W1.(&@.13)'                      DBC 06/84\n&LNME    STM   &C                  SAVE AGAINST FREEMAIN      DBC 06/84\n&LNME    SETC  ''                                             DBC 06/84\n         AGO   .STMLP\n.ST      ANOP                                                 DBC 06/84\n&LNME    ST    &@&R1,&W1.(,&@.13)  SAVE AGAINST FREEMAIN      DBC 06/84\n&LNME    SETC  ''                                             DBC 06/84\n         AGO   .STMLP\n.STMEND  ANOP\n&RG(5)   SETC  '&RG5SAVE'\n.GTR1M   AIF   ('&RG4SAVE' NE '').NOGTR1\n&LNME    L     &@.1,8(,&@.13)      GET RSA PTR FOR FREEMAIN   DBC 06/84\n&LNME    SETC  ''                                             DBC 06/84\n.NOGTR1  ANOP                                                 DBC 06/84\n&LNME    L     &@.0,E&#.LEN        GET RSA LEN (AND SUBPOOL)  DBC 06/84\n&LNME    SETC  ''                                             DBC 06/84\n         MNOTE '         FREEMAIN R,A=(1),LV=(0)'             DBC 06/84\n         FREEMAIN R,A=(1),LV=(0)                              DBC 06/84\n.NTRENT  ANOP\n.*\n&C1      SETA  0\n.LMLP    AIF   (&C1 GE 16).SETRCM\n&C1      SETA  &C1+1\n         AIF   ('&RG(&C1)' EQ '').LMLP\n&R1      SETA  &C1\n&W1      SETA  &C1*4+8\n.LMLP2   ANOP\n&C1      SETA  &C1+1\n         AIF   ('&RG(&C1)' NE '').LMLP2\n         AIF   (&R1 EQ &C1-1).L\n&C       SETC  '&RG(&R1),&RG(&C1-1),&W1.(&@.13)'              DBC 06/84\n&LNME    LM    &C                  RESTORE REGISTERS          DBC 06/84\n&LNME    SETC  ''                                             DBC 06/84\n         AGO   .LMLP\n.L       ANOP                                                 DBC 06/84\n&C       SETC  '&RG(&R1),&W1.(,&@.13)'                        DBC 06/84\n&LNME    L     &C                  RESTORE THE REGISTER       DBC 06/84\n&LNME    SETC  ''                                             DBC 06/84\n         AGO   .LMLP\n.SETRCM  ANOP\n.*\n         AIF   (NOT &RCLA).RETURN\n         AIF   ('&RC' EQ '0').SR\n&LNME    LA    &@.15,&RC           GET THE RETURN CODE        DBC 06/84\n&LNME    SETC  ''                                             DBC 06/84\n         AGO   .RETURN\n.SR      ANOP                                                 DBC 06/84\n&LNME    SLR   &@.15,&@.15         ZERO THE RETURN CODE       DBC 06/84\n&LNME    SETC  ''                                             DBC 06/84\n.RETURN  ANOP\n.*\n         AIF   (NOT &#ENTPLI).NOTPLI3\n&LNME    BALR  &@.1,&@.14          RETURN TO CALLER           DBC 06/84\n         MEXIT\n.NOTPLI3 ANOP\n.*\n         AIF   ('&MODE '(1,1) EQ 'R').RETBSM                  DBC 04/85\n         AIF   ('&MODE '(1,1) EQ 'L').RETBR                   DBC 04/85\n         MNOTE 8,'\"MODE=&MODE\" NOT RECOGNIZED.'               DBC 04/85\n         MNOTE *,'\"MODE=RESTORE\" OR \"MODE=LEAVE\" WAS EXPECTED.' C 04/85\n.*                                                            DBC 04/85\n.RETBR   ANOP                                                 DBC 04/85\n&LNME    BR    &@.14               RETURN                     DBC 10/84\n&LNME    SETC  ''                                             DBC 04/85\n         AGO   .MODEZ                                         DBC 04/85\n.RETBSM  ANOP                                                 DBC 04/85\n&LNME    BSM   0,&@.14             RESTORE AMODE AND RETURN   DBC 04/85\n&LNME    SETC  ''                                             DBC 04/85\n.MODEZ   ANOP                                                 DBC 04/85\n.*                                                            DBC 06/84\n         AIF   (NOT &#ENTRNT).END                             DBC 06/84\n         AIF   ('&#ENTSP' EQ '').NOSPOOL                      DBC 06/84\n         DS    0F                  ALIGN                      DBC 06/84\n&C       SETC  'AL1(&#ENTSP),AL3(&#ENTSIZ)'                   DBC 06/84\nE&#.LEN  DC    &C                  RSA SUBPOOL AND LENGTH     DBC 06/84\n         MEXIT                                                DBC 06/84\n.NOSPOOL ANOP\nE&#.LEN  DC    A(&#ENTSIZ)         RSA LENGTH                 DBC 06/84\n.END     MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "#PARMS": {"ttr": 2056, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x850/\\x00\\x850/\\x12\\x00\\x01\\x1f\\x01\\x1f\\x00\\x00\\xd6\\xd3\\xc4\\xd4\\xc1\\xc3\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-10-29T00:00:00", "modifydate": "1985-10-29T12:00:00", "lines": 287, "newlines": 287, "modlines": 0, "user": "OLDMACS"}, "text": "         MACRO\n&NME     #PARMS &P1,&P2,&P3,&P4,&P5,&P6,&P7,&P8,&P9,&P10,              *\n               &P11,&P12,&P13,&P14,&P15,&P16,&P17,&P18,&P19,&P20,      *\n               &P21,&P22,&P23,&P24,&P25,&P26,&P27,&P28,&P29,&P30,      *\n               &P31,&P32,&P33,&P34,&P35,&P36,&P37,&P38,&P39,&P40,      *\n               &SVID=,&WKID=,&SUBAD=,&PFIX=\n.*\n.*\n.*\n.* LAST CHANGE DATE - OCTOBER 18, 1983\n.*                  - MAILING ADDRESS CHANGE\n.*\n.* LAST CHANGE DATE - APRIL 21, 1981\n.*                  - MACRO NAME CHANGED FROM $PARMS TO #PARMS.\n.*\n.* LAST CHANGE DATE - FEBRUARY 2, 1977\n.*                  - CHARACTERS NOT WITHIN APOSTROPHIES ARE NOW\n.*                    UPCASED.\n.*                  - FIXED BUG: THE ERROR RETURN FROM THE PARM\n.*                    SUBROUTINE GENERATED BY THE MACRO WAS NEVER\n.*                    TAKEN.\n.*                  - MAILING ADDRESS CHANGE.\n.*\n.* LAST CHANGE DATE - JUNE 17, 1975\n.*\n.* THIS MACRO WAS WRITTEN BY DAVID B. COLE. ANY QUESTIONS CONCERNING IT\n.* MAY BE ADDRESSED TO:\n.*       RR#2 BOX 712\n.*       AFTON, VA. 22920\n.*\n.*\n.*\n.*   THIS MACRO WAS WRITTEN TO GENERATE A GENERALIZED PARM FIELD SCAN\n.* OUT SUBROUTINE. IT DOES THE FOLLOWING:\n.* - IT DETERMINES THE EXISTANCE OF A PARM FIELD.\n.* - IT INTERFACES WITH A MESSAGE PRINTING SUBROUTINE TO PRINT\n.*   APPROPIATE MESSAGES INCLUDING AN ECHO OF THE PARM FIELD AS WELL AS\n.*   ANY ERROR MESSAGES THAT MIGHT BE APPROPIATE.\n.* - IT SCANS FOR AND ISSOLATES EACH ENTRY IN THE PARM FIELD,\n.*   IDENTIFIES IT AGAINST A LIST OF GIVEN KEYWORDS, AND THEN BRANCHES\n.*   TO A GIVEN SPECIALIZED HANDLER ROUTINE.\n.* - IF BY THE END OF THE SCAN OUT ANY ERRORS HAVE BEEN DETECTED, THE\n.*   ROUTINE WILL MAKE AN ERROR RETURN TO ITS CALLER.\n.*\n.*\n.*\n.* THE MACRO CALL USES THE FOLLOWING ARGUEMENTS:\n.*\n.* THE NAME FIELD (OPTIONAL) -\n.*   THIS SPECIFIES BOTH THE NAME OF THE GENERATED SUBROUTINE AND THE\n.* PREFIX TO USE FOR ALL GENERATED STATEMENT LABELS. IT SHOULD NOT BE\n.* LONGER THAN 4 CHARACTERS. IF OMITTED, THEN THE DEFAULT OF \"PARM\" IS\n.* USED.\n.*\n.* THE POSITIONAL PARAMETERS (AT LEAST ONE REQUIRED) -\n.*   FROM ONE TO 40 POSITIONAL PARAMETERS MAY BE GIVEN. EACH OF THEM\n.* MUST CONSIST OF A SUBLIST OF TWO ITEMS. THE FIRST MUST BE A PARM\n.* FIELD ENTRY KEYWORD. THE SECOND MUST BE THE ADDRESS (A-TYPE) OF AN\n.* ASSOCIATED HANDLING ROUTINE. THIS ROUTINE IS GIVEN CONTROL IF THE\n.* ASSOCIATED KEYWORD IS FOUND IN THE PARM FIELD.\n.*\n.* THE SUBAD= OPERAND (OPTIONAL) -\n.*   THIS SPECIFIES THE NAME OF A MESSAGE PRINTING SUBROUTINE TO BE\n.* USED BY THE SCAN OUT ROUTINE. IF OMITTED, THEN THE DEFAULT IS TO USE\n.* THE PRINTING SUBROUTINE USED BY THE NEXT PREVIOUS #PARMS OR $PUT\n.* MACRO.\n.*   THE FOLLOWING INFORMATION IS PASSED TO THE MESSAGE PRINTING\n.* SUBROUTINE:\n.*       R14 --> RETURN ADDRESS\n.*       R1 --> A MESSAGE BLOCK. THE FIRST BYTE CONTAINS THE LENGTH OF\n.*              THE MESSAGE. THE REMAINDER OF THE BLOCK CONTAINS THE\n.*              MESSAGE ITSELF (INCLUDING ASA CARRAGE CONTROL).\n.*   THE MESSAGE PRINTING ROUTINE SHOULD RESTORE ALL REGISTERS UPON\n.* RETURN.\n.*\n.* THE SVID= OPERAND (OPTIONAL) -\n.*   THIS MUST SPECIFY THE NAME OF AN ALIGNED 8-WORD REGISTER SAVE\n.* AREA. IF OMITTED, THEN A SAVE AREA IS GENERATED BY THE MACRO.\n.*\n.* THE WKID= OPERAND (OPTIONAL) -\n.*   THIS MUST SPECIFY THE NAME OF AN ALIGNED 1-WORD WORK AREA. IF\n.* OMITTED, THEN A WORK AREA IS GENERATED BY THE MACRO.\n.*\n.* THE PFIX= OPERAND (OPTIONAL) -\n.*   THIS MACRO ATTEMPTS TO USE REGISTER EQUATES IN ITS EXPANSION. THIS\n.* IS SO THAT THE USE OF THE REGISTERS WILL BE INDICATED IN THE CROSS\n.* REFERENCE LISTING. THE PFIX= OPERAND CAN BE USED TO CONTROL THE SET\n.* OF EQUATES USED. FOR EXAMPLE, IF \"PFIX=GPR\" IS SPECIFIED, THEN\n.* \"GPR1\" WILL BE USED WHENEVER THE EXPANSION REFERS TO REGISTER 1.\n.*   IF THE PFIX= OPERAND IS OMITTED, THEN THE SET OF EQUATES DEFINED\n.* BY THE FIRST PRIOR #REGS MACRO WILL BE USED. IF THERE IS NO PRIOR\n.* #REGS MACRO, THEN NO EQUATES WILL BE USED.\n.*\n.*\n.*\n.* SUBROUTINE PROCESSING INFORMATION\n.*\n.*       INPUTS:\n.*             R14 --> RETURN ADDRESS\n.*             R1 --> ANY OS STANDARD PARM FIELD\n.*\n.*       OUTPUTS:\n.*             ALL REGISTERS ARE RESTORED.\n.*             THE PARM FIELD IS PROCESSED AND MAY BE DESTROYED.\n.*       EXITS:\n.*             BRANCH AND LINK TO SPECIFIED HANDLING SUBROUTINES UPON\n.*             RECOGNITION OF VALID KEYWORDS.\n.*\n.*       RETURNS:\n.*             NORMAL:  \" BR R14 \"\n.*             ERROR:  \" B 4(,R14) \"\n.*       ATTRIBUTES:\n.*             NONE (NOT EVEN SERIEALLY REUSABLE)\n.*\n.* METHOD OF SCAN -\n.*   THE PARM FIELD IS CONSIDERED TO BE A LIST OF KEYWORD ENTRIES.\n.* POSITIONAL ENTRIES ARE NOT CONSIDERED.\n.*   EACH ENTRY MUST START WITH ONE OF THE KEYWORDS DEFINED IN THE\n.* MACRO CALL. ANY CHARACTERS THAT MIGHT BE FOUND IN ADDITION TO THE\n.* KEYWORD (I.E. ADJACENT TO AND IMMEDIATELY TO THE RIGHT OF THE\n.* KEYWORD) ARE CONSIDERED TO BE THE VALUE ASSIGNED TO THE KEYWORD.\n.*   NOTE, THIS ROUTINE DOES NOT EXPLICITLY TEST FOR ANY SEPERATOR\n.* CHARACTER BETWEEN THE KEYWORD AND ITS VALUE. SUCH A CHARACTER, IF\n.* DESIRED, MUST BE DEFINED AS PART OF THE KEYWORD (E.G. \"SEQ=\").\n.*   ITEMS OF SYNTAX RECOGNIZED BY THIS ROUTINE ARE COMMAS,\n.* APOSTROPHIES, AND PARENTHESES. APOSTROPHIES MUST OCCURE IN MATCHING\n.* PAIRS. COMMAS AND PARENTHESES FOULD WITHIN MATCHING APOSTROPHIES ARE\n.* IGNORED. PARENTHESES NOT FOUND WITHIN APOSTROPHIES MUST BE BALANCED.\n.* COMMAS FOUND WITHIN PARENTHESES ARE IGNORED.\n.*   COMMAS NOT FOUND WITHING MATCHING APOSTROPHIES OR PARENTHESES ARE\n.* TREATED AS PARM FIELD ENTRY DELIMITERS.\n.*   EACH PARM FIELD ENTRY IS ISSOLATED AT ITS DELIMITERS AND THEN\n.* CHECKED FOR A MATCH IN THE MACRO'S KEYWORD LIST. IF A MATCH IS\n.* FOUND, THEN THE ASSOCIATED HANDLING ROUTINE IS CALLED WITH THE\n.* FOLLOWING INPUTS:\n.*       R14 --> RETURN ADDRESS\n.*       R15 --> HANDLER ENTRY ADDRESS\n.*       R0 = LENGTH OF THE KEYWORD'S VALUE (IF ANY). IF NO VALUE IS\n.*            GIVEN, THEN R0 = 0.\n.*       R1 --> FIRST BYTE PAST THE KEYWORD - I.E. AT THE VALUE (IF\n.*              ANY).\n.*   EACH HANDLER MUST MEET THE FOLLOWING OUTPUT REQUIREMENTS:\n.*       - ALL REGISTERS MUST BE RESTORED EXCEPT THAT FOR ERROR RETURNS\n.*         R1 MUST POINT TO THE LOCATION OF THE ERROR.\n.*   THE FOLLOWING RETURNS ARE PERMITTED:\n.*       NORMAL -  \" BR R14 \"\n.*       ERROR -  \" B 4(,R14) \"\n.*\n.*\n.*\n.* INNER MACROS USED - #TEST, #PUT\n.*\n         GBLC  &#TESRET(20)\n         LCLA  &A1,&A2\n         LCLC  &N,&@,&SAVEA,&WORKA,&C1\n&N       SETC  'PARM'\n         AIF   (K'&NME EQ 0).GOTNME\n&N       SETC  '&NME'\n.GOTNME  ANOP\n&@       SETC  '&PFIX'\n         AIF   (K'&PFIX NE 0).GOTPFIX\n         #TEST PFIX=\n&@       SETC  '&#TESRET(1)'\n.GOTPFIX ANOP\n&SAVEA   SETC  '&SVID'\n         AIF   (K'&SVID NE 0).GOTSAVE\n&SAVEA   SETC  '&N.SAVE'\n.GOTSAVE ANOP\n&WORKA   SETC  '&WKID'\n         AIF   (K'&WKID NE 0).GOTWORK\n&WORKA   SETC  '&N.WORK'\n.GOTWORK ANOP\n* PARM FIELD SCAN-OUT ROUTINE\n*        INPUTS:\n*              R14 --> RETURN ADDRESS\n*              R1 --> PARM FIELD\n         SPACE 1\n&N       STM   &@.14,&@.5,&SAVEA   SAVE REGISTERS\n         LA    &@.4,0(,&@.1)       PNT TO PARM FIELD (CLEAR HI-BYTE)\n         LH    &@.3,0(,&@.4)       GET ITS LENGTH\n         LTR   &@.3,&@.3           PARM FIELD GIVEN?\n         BZ    &N.RET              NO, GO RETURN TO CALLER\n         #PUT  &N.TITL,SUBAD=&SUBAD YES, PRINT AN INTRO LINE\n         LA    &@.2,1              GETA BXLE INCREMENT FOR THE SCAN\n         AR    &@.3,&@.2           GET LENGTH FOR ECHO MSG\n         STC   &@.3,0(,&@.4)       STORE IN THE MSG BLOCK\n         MVI   1(&@.4),C'0'        SET CARRAGE CONTROL CHARACTER\n         #PUT  (&@.4),SUBAD=&SUBAD ECHO THE PARM FIELD\n         AR    &@.3,&@.4           GET THE SCAN BXLE LIMIT\n         LA    &@.5,2(,&@.4)       GET THE SCAN BXLE INDEX\n&N.LOOP  LR    &@.1,&@.5           SAVE KEYWORD STARTING ADDRESS\n         LR    &@.0,&@.2           INIT APOS AND PAREN FLAG\n&N.DELM  CLI   0(&@.5),C''''       APOSTROPHIE?\n         BNE   &N.NAPO             NO, SKIP\n         LCR   &@.0,&@.0           YES, FLIP-FLOP THE APOS FLAG\n         B     &N.DEND             GO LOOP FOR NEXT CHARACTER\n&N.NAPO  LTR   &@.0,&@.0           WITHIN APOSTROPHIES?\n         BNP   &N.DEND             YES, SKIP THIS CHARACTER\n         CLI   0(&@.5),C'('        NO, OPEN PAREN?\n         BNE   &N.NOPN             NO, SKIP\n         CR    &@.0,&@.2           YES, FIRST IN A NEST?\n         BNE   &N.N1ST             NO, SKIP\n         LR    &@.14,&@.5          YES, SAVE A POINTER TO IT ICO ERROR\n&N.N1ST  AR    &@.0,&@.2           COUNT THE NEST LEVEL\n         B     &N.DEND             LOOP FOR NEXT CHARACTER\n&N.NOPN  CLI   0(&@.5),C')'        CLOSE PAREN?\n         BNE   &N.NCPN             NO, SKIP\n         SR    &@.0,&@.2           YES, DECR NEST LEVEL; IMBALANCE?\n         BP    &N.DEND             NO, LOOP FOR NEXT CHARACTER\n         B     &N.SNTX             YES, ERROR; GIVE UP ALTOGETHER\n&N.NCPN  OI    0(&@.5),X'40'       UPCASE THE CHARACTER\n         CR    &@.0,&@.2           WITHIN PARENS?\n         BNE   &N.DEND             YES, SKIP THIS CHARACTER\n         CLI   0(&@.5),C','        NO, DELIMITING COMMA?\n         BE    &N.GOTC             YES, GOT AN ENTRY; GO PROCESS\n&N.DEND  BXLE  &@.5,&@.2,&N.DELM   NO, LOOP FOR NEXT CHARACTER\n         CR    &@.0,&@.2           END OF PARM; PARENS & APOS OK?\n         BE    &N.GOTC             YES, GO PROCESS LAST ENTRY\n         LR    &@.1,&@.14          NO, PNT TO START OF NEST\n         BP    &N.ERRR             UNBALANCED PARENS; ISSUE ERROR MSG\n&N.BAPO  BCTR  &@.5,0              UNMATCHED APOS; BACK-SCAN\n         CLI   0(&@.5),C''''       IS THIS IT?\n         BNE   &N.BAPO             NO, CONTINUE BACK-SCAN\n&N.SNTX  LR    &@.1,&@.5           YES, POINT TO ERROR\n         LR    &@.5,&@.3           PREVENT FURTHER PROCESSING\n         B     &N.ERRR             GO FLAG THE ERROR\n&N.GOTC  CR    &@.1,&@.5           NULL ENTRY?\n         BE    &N.EEND             YES, SKIP\n         LA    &@.15,&N.KEYS       NO, POINT TO KEYWORD LIST\n         SR    &@.14,&@.14         CLEAR LENGTH REGISTER\n&N.SRCH  CLI   0(&@.15),X'FF'      END OF KEYWORDS?\n         BE    &N.ERRR             YES, ERROR\n         IC    &@.14,3(,&@.15)     NO, GET THIS KEYWORD LENGTH - 1\n         CLC   4(*-*,&@.15),0(&@.1) (EXECUTED)\n&N.CLC   EX    &@.14,*-6           RIGHT KEYWORD?\n         BE    &N.GOTK             YES, GO PASS TO HANDLER\n         LA    &@.15,5(&@.14,&@.15) NO, ADVANCE TO NEXT\n         B     &N.SRCH             LOOP TO TRY AGAIN\n&N.GOTK  MVI   4(&@.15),X'FF'      PREVENT RE-USE OF THIS KEYWORD\n         MVC   &WORKA+1(3),0(&@.15) ALIGN THE HANDLER ADDRESS\n         L     &@.15,&WORKA        LOAD IT\n         LA    &@.1,1(&@.14,&@.1)  POINT TO KEYWORD'S VALUE\n         LR    &@.0,&@.5           POINT PAST THE ENTRY\n         SR    &@.0,&@.1           GET THE ENTRY'S VALUE'S LENGTH\n         BALR  &@.14,&@.15         LINK TO THE HANDLER\n         B     &N.EEND             NORMAL RETURN; LOOP FOR NEXT ENTRY\n&N.ERRR  MVI   0(&@.1),X'FF'       ERROR RETURN; FLAG THE ERROR\n         MVI   1(&@.4),X'00'       SIGNEL THAT AN ERROR HAS OCCURED\n&N.EEND  BXLE  &@.5,&@.2,&N.LOOP   LOOP TO PROCESS NEXT ENTRY\n         CLI   1(&@.4),C'0'        ANY ERRORS OCCURE?\n         BE    &N.RET              NO, GO RETURN TO CALLER\n         LA    &@.1,1(,&@.4)       YES, PNT TO PARM CCC.\n&N.FLAG  CLI   0(&@.1),X'FF'       ERROR HERE?\n         MVI   0(&@.1),C' '        (ASSUME NO)\n         BNE   &N.STAR             NO, SKIP TO NEXT CHARACTER\n         MVI   0(&@.1),C'*'        YES, SET A VISUAL SIGNEL\n&N.STAR  BXLE  &@.1,&@.2,&N.FLAG   LOOP FOR NEXT CHARACTER\n         #PUT  (R4),SUBAD=&SUBAD   PRINT THE ERROR FLAG(S)\n         #PUT  &N.ERRM,SUBAD=&SUBAD PRINT ERROR INFO\n         LTR   &@.14,&@.14         SIGNEL ERROR RETURN\n&N.RET   LM    &@.14,&@.5,&SAVEA   (RESTORE REGISTERS)\n         BC    7,4(,&@.14)         ERROR RETURN\n         BR    &@.14               NORMAL RETURN\n         SPACE 3\n         AIF   (K'&SVID NE 0).NOSAVE\n&SAVEA   DS    8A                  REGISTER SAVE AREA\n.NOSAVE  AIF   (K'&WKID NE 0).NOWORK\n&WORKA   DS    A                   WORK AREA\n.NOWORK  AIF   (K'&SVID NE 0 AND K'&WKID NE 0).NOSPACE\n         SPACE 1\n.NOSPACE ANOP\n&N.KEYS  DS    0H                  KEYWORD LIST\n&A1      SETA  0\n.LP1     AIF   (&A1 EQ N'&SYSLIST).END1\n&A1      SETA  &A1+1\n&A2      SETA  K'&SYSLIST(&A1,1)-1\n         DC    AL3(&SYSLIST(&A1,2)),AL1(&A2),C'&SYSLIST(&A1,1)'\n         AGO   .LP1\n.END1    DC    X'FF'               KEYWORD LIST TERMINATOR\n         SPACE 1\n&C1      SETC  'L'''\n         DC    AL1(&C1&N.TITL)\n&N.TITL  DC    C'-THE FOLLOWING PARM FIELD HAS BEEN GIVEN.'\n         SPACE 1\n         DC    AL1(&C1&N.ERRM)\n&N.ERRM  DC    C'0ERRORS HAVE BEEN DETECTED AT THE ABOVE ASTERISKS.'\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "#PLIENV": {"ttr": 2308, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x850/\\x00\\x850/\\x12\\x00\\x00\\xfe\\x00\\xfe\\x00\\x00\\xd6\\xd3\\xc4\\xd4\\xc1\\xc3\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-10-29T00:00:00", "modifydate": "1985-10-29T12:00:00", "lines": 254, "newlines": 254, "modlines": 0, "user": "OLDMACS"}, "text": "         MACRO\n&N       #PLIENV &ISASIZE=,&DSASIZE=,&RECOVER=LOCAL,&BASES=1,          *\n               &ESDTYPE=CSECT,&PFIX=\n.*\n.*\n.*\n.* LAST CHANGE DATE - OCTOBER 18, 1983\n.*                  - MAILING ADDRESS CHANGE\n.*\n.* THIS MACRO WAS WRITTEN - APRIL 21, 1981\n.*\n.* THIS MACRO WAS WRITTEN BY DAVID B. COLE.  ANY QUESTIONS CONCERNING\n.* IT MAY BE ADDRESSED TO:\n.*       RR#2 BOX 712\n.*       AFTON, VA. 22920\n.*\n.*\n.*\n.* THIS MACRO INTERFACES TO THE 'PLIENV' PROGRAM (WRITTEN IN PLI) TO\n.* CREATE A PLI ENVIRONMENT IN WHICH ASSEMBLER LANGUAGE CODE CAN RUN.\n.* THE FLOW OF CONTROL IS DESCRIBED IN THE COMMENTARY GIVEN BELOW.\n.*\n.* THIS MACRO ACCEPTS THE FOLLOWING OPERANDS.\n.*\n.* THE NAME FIELD.\n.*       THIS IS OPTIONAL. IT ASSIGNS A NAME TO THE FIRST SUITABLE\n.*       GENERATED INSTRUCTION. NOTE, THE DEFAULT FIRST INSTRUCTION IS\n.*       A 'CSECT' CARD.\n.*\n.* ISASIZE=\n.*       THIS IS OPTIONAL. IT SPECIFIES THE DESIRED SIZE OF PLI'S\n.*       \"INITIAL STORAGE AREA\". ITS SYNTAX IS IDENTICAL TO PLI'S\n.*       ISASIZE EXECUTION TIME OPTION AS DESCRIBED IN THE PLI\n.*       PROGRAMMER'S GUIDE. IF THIS OPERAND IS OMITTED, THEN THE LOCAL\n.*       INSTALLATION ESTABLISHED DEFAULT ISASIZE IS OBTAINED. NOTE, A\n.*       \"REGISTER FORM\" OF THIS OPERAND IS NOT SUPPORTED.\n.*\n.* DSASIZE=\n.*       THIS IS OPTIONAL. IT SPECIFIES THE DESIRED DATA STORAGE AREA\n.*       SIZE TO BE MADE AVAILABLE TO THE ASSEMBLER CODE FOLLOWING THIS\n.*       MACRO. IF OMITTED, THEN THE MINIMUM VALUE (120 BYTES) IS\n.*       OBTAINED. DSASIZE MUST SPECIFY A NON-RELOCATABLE EXPRESSION.\n.*       THE SPECIFIED VALUE MUST BE EQUAL TO OR GREATER THAN 120 BYTES\n.*       SINCE THE FIRST 120 BYTES ARE REQUIRED BY THE PLI SUBROUTINE\n.*       LINKAGE CONVENTIONS. A \"REGISTER FORM\" OF THIS OPERAND IS NOT\n.*       SUPPORTED.\n.*\n.* RECOVER={LOCAL|PLI}\n.*       THIS CONTROLS WHETHER OR NOT PLI ESTABLISHES A RECOVERY\n.*       ENVIRONMENT (I.E., ISSUES 'ESTAE' AND 'SPIE' MACROS).\n.*\n.*       RECOVER=LOCAL (THE DEFAULT)\n.*       PLI WILL NOT ISSUE 'ESTAE' AND 'SPIE' MACROS. THE ASSEMBLER\n.*       CODE FOLLOWING THIS MACRO EXPANSION MUST PROVIDE FOR ITS OWN\n.*       RECOVERY.\n.*\n.*       RECOVER=PLI\n.*       PLI WILL ISSUE 'ESTAE' AND 'SPIE' MACROS. ALL ABENDS MUST BE\n.*       HANDLER VIA PLI \"ON UNITS\".\n.*\n.* BASES=\n.*       THIS DEFINES THE REGISTERS THAT ARE TO BE USED AS PROGRAM\n.*       BASES FOR THE CODE FOLLOWING THIS MACRO EXPANSION. THIS\n.*       OPERAND MAY SPECIFY EITHER A SINGLE SELF-DEFINING TERM OR IT\n.*       MAY GIVE A PARENTHESIZED LIST OF ONE OR MORE REGISTER NAMES.\n.*\n.*       BASES=<A NUMBER>   (THE DEFAULT IS \"BASES=1\")\n.*       THIS DEFINES THE NUMBER OF BASES REGISTERS THAT ARE TO BE\n.*       LOADED AND DECLARED BY THE MACRO. REGISTERS ARE SELECTED IN\n.*       DESCENDING REGISTER ORDER STARTING WITH REGISTER 11. \"NUMBER\"\n.*       MAY RANGE IN VALUE FROM 0 TO 11.\n.*\n.*       BASES=(<A LIST OF REGISTER NAMES>)\n.*       THIS DEFINES SPECIFIC BASE REGISTERS THAT ARE TO BE LOADED AND\n.*       DECLARED BY THE MACRO. ANY REGISTERS BETWEEN R1 AND R11 MAY\n.*       BE CHOSEN.\n.*\n.* ESDTYPE={CSECT|START|ENTRY|DS|NONE|<NULL>}\n.*\n.*       ESDTYPE=CSECT  (THE DEFAULT)\n.*       THIS CAUSES THE MACRO TO GENERATE A 'CSECT' CARD AS THE FIRST\n.*       CARD OF THE EXPANSION.\n.*\n.*       ESDTYPE=START\n.*       THIS CAUSES THE MACRO TO GENERATE A 'START' CARD AS THE FIRST\n.*       CARD OF THE EXPANSION.\n.*\n.*       ESDTYPE=ENTRY\n.*       THIS CAUSES THE MACRO TO GENERATE A 'ENTRY' CARD NAMING THE\n.*       FIRST EXECUTABLE INSTRUCTION IN THE EXPANSION AS AN ENTRY\n.*       POINT.\n.*\n.*       ESDTYPE=DS\n.*       THIS CAUSES THE MACRO TO GENERATE A 'DS 0H' CARD AS THE FIRST\n.*       CARD OF THE EXPANSION.\n.*\n.*       ESDTYPE=NONE  OR  ESDTYPE=\n.*       THIS SUPPRESSES THIS FUNCTION.\n.*\n.* PFIX=\n.*       THIS CONTROLS THE SET OF REGISTER NAMES TO BE USED BY THE\n.*       MACRO EXPANSION. EXAMPLE: \"PFIX=GPR\" CAUSES THE MACRO TO USE\n.*       \"GPR1\" TO REFER TO REGISTER 1. THE DEFAULT IS TO USE THE\n.*       REGISTER NAME PREFIX DEFINED BY THE FIRST PRECEDING '#REGS'\n.*       MACRO, IF ANY.\n.*\n.* INNER MACROS USED - #REGS #TEST #ENTER GETMAIN FREEMAIN LOAD DELETE\n.*\n         GBLC  &#TESRET(20)\n         LCLC  &#,&@,&PARM,&I,&N2,&W1,&W2\n&#       SETC  '&SYSNDX'\n&@       SETC  '&PFIX'\n         AIF   (K'&PFIX NE 0).GOTPFIX\n         #TEST PFIX=\n&@       SETC  '&#TESRET(1)'\n         AGO   .DONPFIX\n.GOTPFIX #REGS &PFIX,GEN=NO\n.DONPFIX ANOP\n&PARM    SETC  'NOSTAE,NOSPIE'\n         AIF   ('&RECOVER' EQ '' OR '&RECOVER' EQ 'LOCAL').GOTRCVR\n&PARM    SETC  ''\n         AIF   ('&RECOVER'(1,1) EQ 'P').GOTRCVR\n         MNOTE 4,'\"&&RECOVER=&RECOVER\" NOT RECOGNIZED.'\n         MNOTE 4,'\"&&RECOVER=PLI\" ASSUMED.'\n.GOTRCVR ANOP\n         AIF   (K'&ISASIZE EQ 0).GOTISA\n         AIF   ('&ISASIZE' NE '&ISASIZE(1)').GETPISA\n&PARM    SETC  '&PARM.,ISASIZE(&ISASIZE.)'\n         AGO   .GOTISA0\n.GETPISA ANOP\n&PARM    SETC  '&PARM.,ISASIZE&ISASIZE'\n.GOTISA0 AIF   ('&PARM'(1,1) NE ',').GOTISA\n&PARM    SETC  '&PARM'(2,K'&PARM-1)\n.GOTISA  ANOP\n&PARM    SETC  '&PARM./'\n.*\n         SPACE 1\n*************************************************************\n*        ENTRY CODE -- EXECUTED FIRST.                      *\n*        - RECEIVES CONTROL FROM A CALLER.                  *\n*        - SAVES REGISTERS.                                 *\n*        - CONSTRUCTS A SPECIAL PARM FIELD CONTAINING:      *\n*          - PLI EXECUTION TIME OPTIONS;                    *\n*          - INFORMATION SPECIFIC TO THE CONTROL OF THIS    *\n*            INTERFACE.                                     *\n*        - LOCATES THE 'PLIENV' LOAD MODULE.                *\n*        - CALLS 'PLIENV' VIA THE 'PLISTART' ENTRY POINT.   *\n*        - THIS CAUSES THE CREATION OF A PLI ENVIRONMENT.   *\n*        - CONTROL NEXT PASSES TO THE \"INTERFACE CODE\"      *\n*          GENERATED BELOW.                                 *\n*************************************************************\n         SPACE 1\n.*\n&N2      SETC  '&N'\n&W1      SETC  '&ESDTYPE(1)'\n         AIF   ('&W1' EQ 'NONE' OR '&W1' EQ '').ESDDONE\n         AIF   ('&W1' EQ 'ENTRY').ESDENT\n&W2      SETC  ','\n         AIF   ('&W1' EQ 'CSECT' OR '&W1' EQ 'START').ESDNCSC\n&W2      SETC  '0H''0'''\n.ESDNCSC ANOP\n&N       &W1   &W2                 START\n&N2      SETC  ''\n         AGO   .ESDDONE\n.ESDENT  ANOP\n         ENTRY &N                  DECLARE ENTRY NAME\n.ESDDONE ANOP\n.*\n&N2      STM   &@.14,&@.12,12(&@.13) SAVE CALLER'S REGISTERS\n         BALR  &@.14,0             LOAD LOCAL BASE\n         USING *,&@.14             DECLARE IT\n         LA    &@.0,L'PNV&#.P+34   GET L'LCL SAVE AREA + L'PARM FIELD\n         MNOTE '         GETMAIN R,LV=(0)'\n         GETMAIN R,LV=(0)\n         LR    &@.2,&@.1           COPY LOCAL AREA POINTER\n         MVC   0(20,&@.2),12(&@.13) SAVE CALLER'S R14 THRU R2\n         LA    &@.1,24(,&@.2)      --> PARM FIELD\n         ST    &@.1,20(,&@.2)      BUILD 1-ENTRY PLIST\n         MVI   20(&@.2),B'10000000' FLAG THE LAST ENTRY\n         MVC   0(L'PNV&#.P+6,&@.1),PNV&#.P-2 COPY PARM FIELD\n         MVC   L'PNV&#.P+6(4,&@.1),12(&@.2) COPY CALLER'S R1 TO PARM\n         MNOTE '         LOAD  EPLOC=PNV&#.N'\n         LOAD  EPLOC=PNV&#.N\n         LR    &@.15,&@.0          GET PLIENV'S ENTRY ADDRESS\n         LA    &@.1,20(,&@.2)      --> PARM FIELD\n         BALR  &@.14,&@.15         GO ESTABLISH PLI ENVIRONMENT AND\n*                                  EXECUTED THE PROGRAM STARTING AT\n*                                  PNV####R.\n         EJECT ,\n*************************************************************\n*        EXIT CODE -- EXECUTED LAST.                        *\n*        - RECEIVES CONTROL BACK VIA 'PLIENV' UPON          *\n*          COMPLETION OF THE ASSEMBLER CODE BELOW.          *\n*        - NOTE, AT THIS POINT THE PLI ENVIRONMENT NO       *\n*          LONGER EXISTS.                                   *\n*        - CLEANS UP AND RESTORES REGISTERS (PRESERVING THE *\n*          R15 RECEIVED FROM 'PLIENV').                     *\n*        - RETURNS TO \"ENTRY CODE'S\" CALLER.                *\n*************************************************************\n         SPACE 1\n         USING *,&@.14             THE PROGRAM HAS COMPLETED. DECLARE A\n*                                  LOCAL BASE.\n         ST    &@.15,4(,&@.2)      STORE CALLED PROGRAM'S RC\n         MNOTE '         DELETE EPLOC=PNV&#.N'\n         DELETE EPLOC=PNV&#.N\n         MVC   12(20,&@.13),0(&@.2) RESTORE CALLER'S REGS TO SAVE AREA\n         LA    &@.0,L'PNV&#.P+34   GET L'LOCAL WORK AREA\n         MNOTE '         FREEMAIN R,LV=(0),A=(&@.2)'\n         FREEMAIN R,LV=(0),A=(&@.2)\n         LM    &@.14,&@.2,12(&@.13) RESTORE CALLER'S REGISTERS\n         DROP  &@.14               RELEASE LOCAL BASE\n         BR    &@.14               RETURN TO CALLER\n         SPACE 3\nPNV&#.N  DC    CL8'PLIENV'         ROUTINE THAT SETS UP PLI ENVIRONMENT\n         DC    Y(L'PNV&#.P+8)      L'PARM FIELD\nPNV&#.P  DC    C'&PARM',AL4(PNV&#.R) MOST OF PARM FIELD\n         EJECT ,\n*************************************************************\n*        INTERFACE CODE -- EXECUTED SECOND.                 *\n*        - RECEIVES CONTROL FROM 'PLIENV'.                  *\n*        - NOTE, AT THIS POINT A PLI ENVIRONMENT EXISTS.    *\n*        - ESTABLISHES A LOCAL DSA OF THE DESIRED SIZE.     *\n*        - ESTABLISHES THE DESIRED LOCAL PROGRAM BASE       *\n*          REGISTERS.                                       *\n*        - RESTORES THE R1 VALUE ORIGINALLY RECEIVED BY     *\n*          \"ENTRY CODE\" ABOVE.                              *\n*        - FALLS THROUGH TO USER WRITTEN ASSEMBLER CODE.    *\n*************************************************************\n         SPACE 1\n         AIF   ('&DSASIZE' EQ '&DSASIZE(1)').DSASOK\n         MNOTE 4,'\"DSASIZE=&DSASIZE\" IS INVALID.'\n         MNOTE 4,'THE CODE GENERATED BELOW WILL NOT FUNCTION CORRECTLY.*\n               '\n.DSASOK  MNOTE 'PNV&#.R #ENTER &N,SAVTYPE=(PLI,&DSASIZE),BASES=&BASES,'\n         MNOTE '               ESDTYPE=NONE,PFIX=&PFIX'\nPNV&#.R  #ENTER &N,SAVTYPE=(PLI,&DSASIZE),BASES=&BASES,                *\n               ESDTYPE=NONE,PFIX=&PFIX\n         L     &@.1,88(,&@.13)     RESTORE INITIAL PARAMETER REGISTER\n         EJECT ,\n*************************************************************\n*        USER CODE.                                         *\n*        - IF THIS CODE WISHES TO CALL SUBROUTINES USING    *\n*          PLI CONVENTIONS, THEN THE CALLED SUBROUTINES     *\n*          SHOULD START WITH A \"#ENTER SAVTYPE=PLI\" MACRO   *\n*          AND END WITH A \"#EXIT ((R14,R12)),RC=...\" MACRO. *\n*        - WHEN THIS CODE WISHES TO RETURN TO ITS CALLER,   *\n*          IT SHOULD DO SO VIA A \"#EXIT ((R14,R12)),RC=...\" *\n*          MACRO. THIS WILL CAUSE CONTROL TO RETURN TO      *\n*          'PLIENV' WHICH WILL THEN CLEAN UP THE PLI        *\n*          ENVIRONMENT AND THEN RETURN CONTROL TO \"EXIT     *\n*          CODE\" ABOVE.                                     *\n*************************************************************\n         SPACE 1\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "#PUT": {"ttr": 2313, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x850/\\x00\\x850/\\x12\\x00\\x00P\\x00P\\x00\\x00\\xd6\\xd3\\xc4\\xd4\\xc1\\xc3\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-10-29T00:00:00", "modifydate": "1985-10-29T12:00:00", "lines": 80, "newlines": 80, "modlines": 0, "user": "OLDMACS"}, "text": "         MACRO\n&NME     #PUT  &MSG,&PFIX=,&SUBAD=,&MF=\n.*\n.*\n.*\n.* LAST CHANGE DATE - OCTOBER 18, 1983\n.*                  - MAILING ADDRESS CHANGE\n.*\n.* LAST CHANGE DATE - APRIL 21, 1981\n.*                  - MACRO NAME CHANGED FROM $PUT TO #PUT.\n.*\n.* LAST CHANGE DATE - APRIL 20, 1981\n.*                  - \"#REGS GEN=NO\" SUPPORT ADDED.\n.*\n.* LAST CHANGE DATE - JULY 18, 1980\n.*                  - INDIRECT ADDRESSING IS NOW INDICATED BY A\n.*                    TRAILING PERCENT SIGN (%) RATHER THAN A LEADING\n.*                    ONE.\n.*\n.* LAST CHANGE DATE - JANUARY 12, 1977\n.*                  - HANDLING OF THE SUBAD= OPERAND IS REWRITTEN.\n.*                  - MAILING ADDRESS CHANGE.\n.*\n.* THIS MACRO WAS WRITTEN BY DAVID B. COLE. ANY QUESTIONS CONCERNING\n.* IT MAY BE ADDRESSED TO:\n.*       RR#2 BOX 712\n.*       AFTON, VA. 22920\n.*\n         GBLA  &#TESERR\n         GBLC  &#PUTSUB\n         GBLC  &#TESRET(20)\n         LCLA  &A1\n         LCLC  &@,&C1,&N\n         AIF   ('&SUBAD' EQ '').SUBOK\n         AIF   ('&SUBAD(1)' NE '&SUBAD').SUBOK\n&#PUTSUB SETC  '&SUBAD'\n.SUBOK   AIF   ('&MF(1)' EQ 'INIT').MEND\n&N       SETC  '&NME'\n.*\n&@       SETC  '&PFIX'\n         AIF   ('&PFIX' NE '').PFIXOK\n         #TEST PFIX=\n&@       SETC  '&#TESRET(1)'\n         AGO   .DONPFIX\n.PFIXOK  #REGS &PFIX,GEN=NO\n.DONPFIX ANOP\n.*\n         AIF   ('&MSG(1)' EQ '&MSG').NOTREG\n         #TEST REGS=&MSG(1)\n         AIF   (&#TESERR NE 0).LR\n         AIF   (&#TESRET(1) EQ 1).BAL\n.LR      ANOP\n&N       LR    &@.1,&MSG(1)        --> MESSAGE LENGTH FIELD\n&N       SETC  ''\n         AGO   .BAL\n.NOTREG  AIF   ('&MSG' EQ '').BAL\n         AIF   ('&MSG'(K'&MSG,1) EQ '%').MSGINDR\n&N       LA    &@.1,&MSG-1         --> MESSAGE LENGTH FIELD\n         AGO   .MSGOK\n.MSGINDR ANOP\n&C1      SETC  '&MSG'(1,K'&MSG-1)\n&N       L     &@.1,=A(&C1-1)      --> MESSAGE LENGTH FIELD\n.MSGOK   ANOP\n&N       SETC  ''\n.BAL     AIF   ('&SUBAD(1)' NE '&SUBAD').BALR\n         AIF   ('&#PUTSUB'(1,1) EQ '%').BALINDR\n&N       BAL   &@.14,&#PUTSUB      GO DISPLAY THE MESSAGE\n         AGO   .MEND\n.BALR    ANOP\n&N       BALR  &@.14,&SUBAD(1)     GO DISPLAY THE MESSAGE\n         AGO   .MEND\n.BALINDR ANOP\n&A1      SETA  0\n.LP1     ANOP\n&A1      SETA  &A1+1\n         AIF   ('&#PUTSUB'(1,&A1) NE '&#PUTSUB').LP1\n&C1      SETC  '&#PUTSUB'(2,&A1-1)\n&N       L     &@.15,=A(&C1)       --> MESSAGE PRINTING ROUTINE\n         BALR  &@.14,&@.15         GO DISPLAY THE MESSAGE\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "#REGS": {"ttr": 2316, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x850/\\x00\\x850/\\x12\\x00\\x00\\xc5\\x00\\xc5\\x00\\x00\\xd6\\xd3\\xc4\\xd4\\xc1\\xc3\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-10-29T00:00:00", "modifydate": "1985-10-29T12:00:00", "lines": 197, "newlines": 197, "modlines": 0, "user": "OLDMACS"}, "text": "         MACRO\n         #REGS &GEN=YES\n.*\n.*\n.*                                                            09/84 DBC\n.* LAST CHANGE DATE - SEPTEMBER 11, 1984                      09/84 DBC\n.*                  - ADDED SUPPORT FOR PL/S STYLE REGISTER   09/84 DBC\n.*                    NAMES (@00, @01, ---, @15).             09/84 DBC\n.*                  - ATTEMPTS TO MULTIPLY DEFINE THE SAME    09/84 DBC\n.*                    NAME TO THE SAME VALUE WILL NOW BE      09/84 DBC\n.*                    SUPPRESSED WITHOUT ERROR.               09/84 DBC\n.*\n.* LAST CHANGE DATE - OCTOBER 18, 1983\n.*                  - MAILING ADDRESS CHANGE\n.*\n.* LAST CHANGE DATE - APRIL 21, 1981\n.*                  - MACRO NAME CHANGED FROM $REGS TO #REGS\n.*\n.* LAST CHANGE DATE - APRIL 20, 1981\n.*                  - SUPPORT FOR THE \"GEN={YES|NO}\" OPERAND IS ADDED.\n.*\n.* LAST CHANGE DATE - DECEMBER 5, 1977\n.*                  - SINGLE REGISTER EQUATES NOW LINE UP CORRECTLY IN\n.*                    THE LISTING.\n.*\n.* LAST CHANGE DATE - FEBRUARY 2, 1977\n.*                  - MAILING ADDRESS CHANGE.\n.*\n.* LAST CHANGE DATE - APRIL 1, 1975\n.*\n.* THIS MACRO WAS WRITTEN BY DAVID B. COLE.  ANY QUESTIONS CONCERNING\n.* IT MAY BE ADDRESSED TO:\n.*       RR#2 BOX 712\n.*       AFTON, VA. 22920\n.*\n.*\n.*\n.*   THE #REGS MACRO HAS TWO FUNCTIONS. ITS PRIMARY\n.* PURPOSE IS TO PROVIDE A SIMPLE MEANS OF DEFINING SETS\n.* OF REGISTER NAME EQUATES. ITS SECONDARY PURPOSE IS TO\n.* CREATE AN INTERNAL TABLE OF ALL REGISTER NAMES\n.* COUPLED WITH THEIR NUMERIC VALUES. THIS TABLE IS THEN\n.* MADE AVAILABLE TO CERTAIN OTHER MACROS (E.G. #ENTER\n.* AND #EXIT) SO THAT THEY CAN DETERMINE (IF NECESSARY)\n.* THE VALUES OF ANY REGISTER NAMES THAT MIGHT BE PASSED\n.* TO THEM AS OPERANDS AND SO THAT THEY CAN USE REGISTER\n.* NAME EQUATES INSTEAD OF REGISTER NUMBERS IN THE CODE\n.* THAT THEY GENERATE. THIS IS SO THAT ALL REFERENCES TO\n.* REGISTERS WILL BE INDICATED IN THE ASSEMBLER'S CROSS\n.* REFERENCE LISTING.\n.*                                                            09/84 DBC\n.*   THE #REGS MACRO CAN BE USED ANY NUMBER OF TIMES IN\n.* AN ASSEMBLY. EACH TIME THAT IT IS USED, IT CAN BE\n.* GIVEN ANY NUMBER OF POSITIONAL OPERANDS. EACH OPERAND      09/84 DBC\n.* CAN BE EITHER A SINGLE TERM OR A SUB-LIST OF TWO\n.* TERMS.\n.*                                                            09/84 DBC\n.*   IF AN OPERAND IS A SUB-LIST OF TWO TERMS, THEN THE\n.* #REGS MACRO TREATS IT AS A REQUEST TO DEFINE A SINGLE\n.* REGISTER NAME AND IT GENERATES A STATEMENT OF THE\n.* FORM: \" TERM1 EQU TERM2 \". THE FIRST TERM MUST BE ANY\n.* VALID NAME NOT PREVIOUSLY DEFINED. THE SECOND TERM\n.* MUST BE ANY SELF-DEFINING TERM OR ANY REGISTER NAME\n.* THAT HAS BEEN PREVIOUSLY DEFINED BY THIS OR A\n.* PREVIOUS #REGS MACRO. IT SHOULD NOT BE AN EXPRESSION,\n.* AND IT SHOULD NOT BE ANY NAME NOT PREVIOUSLY DEFINED.\n.* THE VALUE OF THE SECOND TERM SHOULD FALL IN THE RANGE\n.* OF 0 THROUGH 15. IF THE SECOND TERM FITS THESE\n.* REQUIREMENTS, THEN THE REGISTER NAME IS SAVED IN AN\n.* INTERNAL TABLE FOR USE BY OTHER MACROS.\n.*                                                            09/84 DBC\n.*   IF AN OPERAND IS ONLY A SINGLE TERM, THEN THE MACRO\n.* TREATS IT AS A REQUEST TO DEFINE A FULL SET OF\n.* REGISTER NAME EQUATES WITH THE GIVEN TERM USED AS THE\n.* REGISTER NAME PREFIX. AS AN EXAMPLE, ASSUME THAT THE\n.* OPERAND IS \"GPR\". IN THIS CASE, THE #REGS MACRO WILL\n.* GENERATE EQUATES DEFINING GPR0, GPR1, ---, GPR15 AND\n.* GPRA, GPRB, ---, GPRF (EQUAVALENT TO GPR10, GPR11,\n.* ---, GPR15). IN ADDITION, THE GENERATED REGISTER\n.* NAMES ARE SAVED IN AN INTERNAL TABLE FOR USE BY OTHER\n.* MACROS.\n.*                                                            09/84 DBC\n.*   A SPECIAL CASE. IF THE SINGLE TERM IS AN \"AT SIGN\"       09/84 DBC\n.* (@), THEN THEN THE GENERATED NAMES WILL BE @00, @01,       09/84 DBC\n.* ---, @15. THIS CONFORMS TO PL/S CONVENTIONS.               09/84 DBC\n.*                                                            09/84 DBC\n.*   IF #REGS IS CALLED WITHOUT OPERANDS, THEN IT IS\n.* TREATED AS A REQUEST TO GENERATE A FULL SET OF\n.* EQUATES USING \"R\" AS THE PREFIX.\n.*\n.*\n.*\n.* GEN={YES|NO}    (DEFAULT IS GEN=YES)\n.*       THIS CONTROLS WHETHER OR NOT THIS MACRO ACTUALLY GENERATES THE\n.*       'EQU' STATEMENTS THAT CREATE THE DESIRED REGISTER NAMES. IF\n.*       \"GEN=NO\" IS GIVEN, THEN PRESUMEDLY THE DESIRED NAMES ARE\n.*       GENERATED ELSEWHERE. IN THIS CASE THE ONLY FUNCTION PERFORMED\n.*       BY THIS MACRO IS TO UPDATE INTERNAL TABLES.\n.*\n.*\n.*\n.* INNER MACROS USED - #TEST\n.*\n         GBLA  &#REGVAL(255)\n         GBLA  &#TESERR\n         GBLC  &#REGNME(255)\n         GBLC  &#TESRET(20)\n         LCLA  &ARG,&CTR,&NEXT,&A1\n         LCLB  &B1\n         LCLC  &LPFX,&C1\n&NEXT    SETA  0\n.LP1     AIF   (&NEXT GE 255).END1\n&NEXT    SETA  &NEXT+1\n         AIF   ('&#REGNME(&NEXT)' NE '').LP1\n&NEXT    SETA  &NEXT-1\n.END1    ANOP\n&ARG     SETA  0\n.LP2     AIF   (&ARG GE N'&SYSLIST).DONE\n&ARG     SETA  &ARG+1\n         AIF   (N'&SYSLIST(&ARG) EQ 0).LP2\n         AIF   (&NEXT LT 255).NOTFULL\n         MNOTE 4,'THE REGISTER NAME SAVE TABLE IS FULL.'\n         MNOTE 4,'THE MAXIMUM CAPACITY IS 255 ENTRIES.'\n.NOTFULL ANOP\n&C1      SETC  '&SYSLIST(&ARG,1)'\n         AIF   (N'&SYSLIST(&ARG) GE 2).ONEREG\n.NULL    ANOP\n&B1      SETB  (1)\n         #TEST PFIX=\n&LPFX    SETC  '&#TESRET(1)'\n.*                                                            09/84 DBC\n         AIF   ('&C1' NE '@').NOT@                            09/84 DBC\n&CTR     SETA  0-1                                            09/84 DBC\n.LP@     AIF   (&CTR EQ 15).END@                              09/84 DBC\n&CTR     SETA  &CTR+1                                         09/84 DBC\n&C1      SETC  '0&CTR'                                        09/84 DBC\n&C1      SETC  '&C1'(K'&C1-1,2)                               09/84 DBC\n         #REGS (@&C1,&LPFX&CTR)                               09/84 DBC\n         AGO   .LP@                                           09/84 DBC\n.END@    AIF   (&NEXT GE 255).LP2                             09/84 DBC\n&NEXT    SETA  &NEXT+1                                        09/84 DBC\n         AIF   ('&#REGNME(&NEXT)' NE '').END@                 09/84 DBC\n&NEXT    SETA  &NEXT-1                                        09/84 DBC\n         AGO   .LP2                                           09/84 DBC\n.NOT@    ANOP                                                 09/84 DBC\n.*                                                            09/84 DBC\n&CTR     SETA  0\n.LP2A    AIF   (&CTR GE &NEXT).PXSAVE\n&CTR     SETA  &CTR+1\n         AIF   (&#REGVAL(&CTR) LT 16 OR '&#REGNME(&CTR)' NE '&C1').LP2A\n         AGO   .LP2                                           09/84 DBC\n.PXSAVE  AIF   (&NEXT GE 255).NOSAVE1                         09/84 DBC\n&NEXT    SETA  &NEXT+1\n&#REGNME(&NEXT) SETC '&C1'\n&#REGVAL(&NEXT) SETA 16\n.NOSAVE1 AIF   ('&GEN(1)'(1,1) NE 'Y').LP2\n&CTR     SETA  0\n.LP3     AIF   (&CTR GT 15).HEX\n&C1&CTR  EQU   &LPFX&CTR\n&CTR     SETA  &CTR+1\n         AGO   .LP3\n.HEX     ANOP\n&C1.A    EQU   &C1.10\n&C1.B    EQU   &C1.11\n&C1.C    EQU   &C1.12\n&C1.D    EQU   &C1.13\n&C1.E    EQU   &C1.14\n&C1.F    EQU   &C1.15\n         AGO   .LP2\n.ONEREG  ANOP\n&B1      SETB  (1)\n         AIF   (N'&SYSLIST(&ARG) EQ 2).NOXCESS\n         MNOTE 4,'\"&SYSLIST(&ARG)\" CONTAINS EXCESS INFORMATION.'\n         MNOTE 4,'THE EXCESS WILL BE IGNORED.'\n.NOXCESS #TEST REGS=&SYSLIST(&ARG,2)\n         AIF   (&#TESERR EQ 0).REGOK\n         MNOTE 4,'THE VALUE OF \"&SYSLIST(&ARG,2)\" IS NOT DETERMINABLE.'\n         AGO   .REGEQU\n.REGOK   ANOP                                                 09/84 DBC\n&A1      SETA  &#TESRET(1)\n&CTR     SETA  0\n.LP3A    AIF   (&CTR GE &NEXT).RGSAVE\n&CTR     SETA  &CTR+1\n         AIF   (&#REGVAL(&CTR) NE &A1 OR '&#REGNME(&CTR)' NE '&C1').LP3*\n               A\n         AGO   .LP2                                           09/84 DBC\n.RGSAVE  AIF   (&NEXT GE 255).REGEQU                          09/84 DBC\n&NEXT    SETA  &NEXT+1\n&#REGNME(&NEXT) SETC '&C1'\n&#REGVAL(&NEXT) SETA &A1\n.REGEQU  AIF   ('&GEN(1)'(1,1) NE 'Y').LP2\n&C1      EQU   &SYSLIST(&ARG,2)\n         AGO   .LP2\n.DONE    ANOP\n&C1      SETC  'R'\n         AIF   (NOT &B1).NULL\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "#RELOAD": {"ttr": 2563, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x850/\\x00\\x850/\\x12\\x00\\x00B\\x00B\\x00\\x00\\xd6\\xd3\\xc4\\xd4\\xc1\\xc3\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-10-29T00:00:00", "modifydate": "1985-10-29T12:00:00", "lines": 66, "newlines": 66, "modlines": 0, "user": "OLDMACS"}, "text": "         MACRO\n&N       #RELOAD &D,&LCLBASE=NONE,&PGMBASE=\n.*\n.*\n.*\n.* LAST CHANGE DATE - OCTOBER 18, 1983\n.*                  - MAILING ADDRESS CHANGE\n.*\n.* LAST CHANGE DATE - APRIL 21, 1981\n.*                  - MACRO NAME CHANGED FROM $RELOAD TO #RELOAD.\n.*\n.* LAST CHANGE DATE - FEBRUARY 2, 1977\n.*                  - MAILING ADDRESS CHANGE.\n.*\n.* LAST CHANGE DATE - AUGUST 23, 1976\n.*\n.* THIS MACRO WAS WRITTEN BY DAVID B. COLE. ANY QUESTIONS CONCERNING IT\n.* MAY BE DIRECTED TO:\n.*       RR#2 BOX 712\n.*       AFTON, VA. 22920\n.*\n.*\n.*\n         GBLA  &#TESERR\n         GBLC  &#TESRET(20)\n         GBLC  &#BS(14)\n         LCLA  &A1,&A2\n         LCLC  &PBA,&#\n&#       SETC  '&SYSNDX.'\n         AIF   ('&#BS(14)' EQ '').MEND\n&PBA     SETC  '#RL&#.B'\n         AIF   (K'&PGMBASE EQ 0).RTY\n         AIF   ('&PGMBASE' EQ '&PGMBASE(1)').GHJ\n         AIF   ('&#BS(13)' EQ '&PGMBASE(1)').KLM\n         #TEST REGS=(&#BS(13),&PGMBASE(1))\n         AIF   (&#TESERR NE 0).MNO\n         AIF   ('&#TESRET(1)' EQ '&#TESRET(2)').KLM\n.MNO     ANOP\n&N       LR    &#BS(13),&PGMBASE(1) LOAD 1ST PROGRAM BASE\n         AGO   .HK\n.KLM     ANOP\n&N       DS    0H                  1ST PROGRAM BASE ALREADY LOADED\n         AGO   .HK\n.GHJ     ANOP\n&PBA     SETC  '&PGMBASE'\n.RTY     AIF   ('&LCLBASE' NE 'NONE').GJ\n&N       BALR  &#BS(13),0          GET TEMPORARY BASE\n         L     &#BS(13),&PBA-*(,&#BS(13)) LOAD 1ST PROGRAM BASE\n         AGO   .HK\n.GJ      ANOP\n&N       L     &#BS(13),&PBA       LOAD 1ST PROGRAM BASE\n.HK      ANOP\n&A1      SETA  13\n&A2      SETA  13\n.LP3     AIF   (&A1 EQ 1).END3\n&A1      SETA  &A1-1\n         AIF   ('&#BS(&A1)' EQ '').LP3\n         LA    &#BS(&A1),X'FFF'(,&#BS(&A2)) LOAD NEXT BASE\n&A2      SETA  &A1\n         AGO   .LP3\n.END3    #USING\n         AIF   (K'&PGMBASE NE 0).MEND\n         B     #RL&#.Y             SKIP OVER DATA AREA\n#RL&#.B  DC    A(&#BS(14))         PROGRAM BASE ADDRESS\n#RL&#.Y  DS    0H                  RECEIVE BRANCH\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#SAL": {"ttr": 2565, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x850/\\x00\\x850/\\x12\\x00\\x00c\\x00c\\x00\\x00\\xd6\\xd3\\xc4\\xd4\\xc1\\xc3\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-10-29T00:00:00", "modifydate": "1985-10-29T12:00:00", "lines": 99, "newlines": 99, "modlines": 0, "user": "OLDMACS"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "#SEARCH": {"ttr": 2568, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x850/\\x00\\x850/\\x12\\x00\\x00\\xdf\\x00\\xdf\\x00\\x00\\xd6\\xd3\\xc4\\xd4\\xc1\\xc3\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-10-29T00:00:00", "modifydate": "1985-10-29T12:00:00", "lines": 223, "newlines": 223, "modlines": 0, "user": "OLDMACS"}, "text": "         MACRO\n&NME     #SEARCH &DUMMY,&PFIX=,&SVID=,&CMPRID=\n.*\n.*\n.*\n.* LAST CHANGE DATE - OCTOBER 18, 1983\n.*                  - MAILING ADDRESS CHANGE\n.*\n.* LAST CHANGE DATE - SEPTEMBER 8, 1981\n.*                  - THE PARAMETERIZATION OF THE SEARCH ROUTINE WAS\n.*                    CHANGED FROM:\n.*                       - R15 = L'LIST\n.*                       - R0 = L'LIST ENTRY\n.*                       - R1 --> SO-LIST\n.*                    TO:\n.*                       - R15 --> SO-LIST\n.*                         R0 = L'LIST ENTRY\n.*                         R1 --> EO-LIST\n.*\n.* LAST CHANGE DATE - APRIL 21, 1981\n.*                  - MACRO NAME CHANGED FROM $SEARCH TO #SEARCH.\n.*\n.* LAST CHANGE DATE - APRIL 20, 1981\n.*                  - \"#REGS GEN=NO\" SUPPORT ADDED.\n.*\n.* LAST CHANGE DATE - MARCH 12, 1980\n.*                  - SUPPORT FOR AN EMPTY LIST HAS BEEN FIXED.\n.*\n.* LAST CHANGE DATE - SEPTEMBER 18, 1978\n.*                  - IF THE LIST HAS MULTIPLE ENTRIES WITH THE SAME\n.*                    KEY AS THE SEARCH OBJECT, THEN THIS ROUTINE NOW\n.*                    RETURNS THE LAST (SEQUENTIALLY) SUCH LIST ENTRY.\n.*\n.* LAST CHANGE DATE - FEBRUARY 2, 1977\n.*                  - MAILING ADDRESS CHANGE\n.*\n.* LAST CHANGE DATE - OCTOBER 28, 1975\n.*\n.* THIS MACRO WAS WRITTEN BY DAVID B. COLE.  ANY QUESTIONS CONCERNING\n.* IT MAY BE ADDRESSED TO:\n.*       RR#2 BOX 712\n.*       AFTON, VA. 22920\n.*\n.*\n.*\n.*   THIS MACRO GENERATES A SUBROUTINE THAT SEARCHES A SORTED LIST.  A\n.* BINARY SEARCH METHOD IS USED.\n.*\n.*   THE SEARCH SUBROUTINE REQUIRES THE FOLLOWING INPUTS:\n.*       - R14 POINTS TO THE RETURN ADDRESS;\n.*       - R15 POINTS TO THE START OF THE LIST TO BE SEARCHED;\n.*       - R0 CONTAINS THE LENGTH (IN BYTES) OF EACH ENTRY IN\n.*         THE LIST;\n.*       - R1 POINTS PAST THE END OF THE LIST.\n.*\n.*   ON OUTPUT THE CONDITION CODE AND R1 ARE SET AS FOLLOWS:\n.*       - CC=0 (EQUAL) MEANS THAT THE SEARCH OBJECT WAS FOUND. R1\n.*         POINTS TO IT. IF THE LIST CONTAINS MORE THAN ONE OBJECT\n.*         HAVING THE SAME KEY AS THE SEARCH OBJECT, THEN R1 POINTS TO\n.*         THE LAST SUCH OBJECT IN THE LIST.\n.*       - CC=2 (HIGH) MEANS THAT THE SEARCH OBJECT WAS NOT FOUND. R1\n.*         POINTS TO WHERE IT SHOULD BE INSERTED.\n.* ALL OTHER REGISTERS ARE RESTORED.\n.*\n.*   THE SEARCH SUBROUTINE IS NOT REENTRANT, BUT IT IS SERIALLY\n.* REUSABLE.\n.*\n.*   THE NAME FIELD\n.* THIS FIELD IS OPTIONAL. IT CAN BE USED TO DEFINE BOTH THE NAME OF\n.* THE SUBROUTINE AND THE PREFIX USED IN ALL GENERATED STATEMENT\n.* LABELS. IF OMITTED, THEN THE CHARACTERS \"SRCH\" WILL BE USED. IF\n.* GIVEN, THEN NO MORE THAN FOUR CHARACTERS SHOULD BE SPECIFIED.\n.*\n.*   THE PFIX= OPERAND\n.* THE #SEARCH MACRO ATTEMPTS TO USE REGISTER EQUATES IN ITS EXPANSION\n.* WHEN REFERING TO REGISTERS. THIS IS SO THAT THE USE OF THE REGISTERS\n.* WILL BE INDICATED IN THE CROSS REFERENCE LISTING. THE PFIX= OPERAND\n.* CAN BE USED TO CONTROL THE SET OF EQUATES USED. FOR EXAMPLE, IF\n.* \"PFIX=GPR\" IS SPECIFIED, THEN \"GPR1\" WILL BE USED WHENEVER THE\n.* EXPANSION REFERS TO REGISTER 1.\n.*   IF THE PFIX= OPERAND IS OMITTED, THEN THE SET OF EQUATES DEFINED\n.* BY THE FIRST PRIOR #REGS MACRO WILL BE USED. IF THERE IS NO PRIOR\n.* #REGS MACRO, THEN NO EQUATES WILL BE USED.\n.*\n.*   THE CMPRID= OPERAND\n.* THIS OPERAND IS REQUIRED. IT INDICATES THE ADDRESS OF A SUBROUTINE\n.* TO BE USED BY THE SEARCH ROUTINE FOR COMPARING THE SEARCH OBJECT\n.* WITH A LIST ENTRY. EITHER A STATEMENT LABEL OR A REGISTER MAY BE\n.* SPECIFIED.\n.*   THE SPECIFIED COMPARISON ROUTINE IS GIVEN THE FOLLOWING INPUTS:\n.*       - R14 POINTS TO THE RETURN ADDRESS.\n.*       - R15 POINTS TO THE LIST ENTRY TO BE COMPARED AGAINST THE\n.*         SEARCH OBJECT.\n.*       - R0 THROUGH R6 CONTAIN DATA ON WHICH THE SEARCH ROUTINE IS\n.*         DEPENDANT.\n.*       - R7 THROUGH R13 CONTAIN WHAT WAS IN THEM PRIOR TO THE START\n.*         OF THE SEARCH ROUTINE.\n.* ON OUTPUT THE COMPARISON ROUTINE MUST PROVIDE THE FOLLOWING:\n.*       - R14 THROUGH R6 MAY NOT BE ALTERED BY THE COMPARISON\n.*         ROUTINE.\n.*       - R7 THROUGH R13 (EXCEPT THOSE THAT ARE USED AS\n.*         PROGRAM BASES) MAY BE USED FREELY SINCE THE SEARCH ROUTINE\n.*         RESTORES ALL REGISTERS WHEN IT IS FINISHED.\n.*       - THE CONDITION CODE MUST BE SET AS FOLLOWS:\n.*             - CC=0 (EQUAL) MEANS THAT THE SEARCH OBJECT MATCHES THE\n.*               CURRENT LIST ENTRY.\n.*             - CC=1 (LOW) MEANS THAT THE SEARCH OBJECT IS LOWER THAN\n.*               THE CURRENT LIST ENTRY.\n.*             - CC=2 (HIGH) MEANS THAT THE SEARCH OBJECT IS HIGHER\n.*               THAN THE CURRENT LIST ENTRY.\n.*\n.*   THE SVID= OPERAND\n.* USE THIS OPERAND TO SPECIFY THE NAME OF A 16-WORD REGISTER SAVE\n.* AREA. IF OMITTED, THEN THE MACRO WILL GENERATE A LOCAL SAVE AREA.\n.*\n.* INNER MACROS USED - #REGS #TEST #DIE\n.*\n.*\n.*\n         GBLA  &#TESERR\n         GBLC  &#TESRET(20)\n         LCLC  &N,&R,&SAVEA\n&N       SETC  'SRCH'\n         AIF   (K'&NME EQ 0).GOTNME\n&N       SETC  '&NME'\n.GOTNME  ANOP\n.*\n&R       SETC  '&PFIX'\n         AIF   (K'&PFIX NE 0).GOTPFIX\n         #TEST PFIX=\n&R       SETC  '&#TESRET(1)'\n         AGO   .DONPFIX\n.GOTPFIX #REGS &PFIX,GEN=NO\n.DONPFIX ANOP\n.*\n* BINARY SEARCH ROUTINE\n*        INPUTS:\n*        - R14 POINTS TO THE RETURN ADDRESS\n*        - R15 POINTS TO THE START OF THE LIST TO BE SEARCHED\n*        - R0 CONTAINS THE LENGTH OF EACH LIST ENTRY (IN BYTES)\n*        - R1 POINTS PAST THE END OF THE LIST\n         SPACE 1\n* COMPARE ROUTINE INPUTS:\n*        - R15 POINTS TO THE LIST ENTRY TO BE COMPARED AGAINST THE\n*          SEARCH OBJECT.\n*        - R14 POINTS TO THE RETURN ADDRESS.\n*        - R14 THROUGH R6 CONTAIN DATA CRITICAL TO THE SEARCH ROUTINE.\n*          THEY MUST NOT BE ALTERED BY THE COMPARE ROUTINE.\n         SPACE 1\n* COMPARE ROUTINE OUTPUTS:\n*        - CC=0 (EQUAL) MEANS THAT THE SEARCH OBJECT MATCHES THE\n*          CURRENT LIST ENTRY.\n*        - CC=1 (LOW) MEANS THAT THE SEARCH OBJECT IS LOWER THAN THE\n*          CURRENT LIST ENTRY.\n*        - CC=2 (HIGH) MEANS THAT THE SEARCH OBJECT IS HIGHER THAN THE\n*          CURRENT LIST ENTRY.\n&SAVEA   SETC  '&N.SAVE'\n         AIF   (K'&SVID EQ 0).GOTSAVE\n&SAVEA   SETC  '&SVID'\n.GOTSAVE ANOP\n&N       STM   &R.14,&R.13,&SAVEA  SAVE ALL WORK REGISTERS\n         AIF   ('&CMPRID' EQ '&CMPRID(1)').NOCMPR1\n         #TEST REGS=&CMPRID(1)\n         AIF   ( &#TESERR EQ 0 AND '&#TESRET(1)' EQ '2').NOCMPR2\n         LR    &R.2,&CMPRID(1)     POINT TO COMPARISON ROUTINE\n         AGO   .NOCMPR2\n.NOCMPR1 LA    &R.2,&CMPRID        POINT TO COMPARISON ROUTINE\n.NOCMPR2 ANOP\n         LNR   &R.15,&R.15         GET NEGATIVE SO-LIST\n         AR    &R.15,&R.1          GET L'LIST\n         SR    &R.1,&R.15          GET SO-LIST\n         SR    &R.14,&R.14         CLEAR FOR DIVIDE\n         DR    &R.14,&R.0          GET LIST'S ENTRY COUNT\n         LTR   &R.4,&R.14          GET INITIAL SEARCH INDEX; WAS THE\n*                                  ABOVE DIVIDE EVEN?\n         #DIE  NZ,'SEARCH LIST SIZE INCOMPATIBLE WITH LIST ENTRY SIZE'\n         LTR   &R.3,&R.15          YES, GET LIST ENTRY COUNT; EMPTY?\n         BZ    &N.NULL             YES, GO RETURN \"NOT FOUND\"\n         LA    &R.5,1(,&R.3)       NO, GET INITIAL WIDTH; INSURE \u00ac0\n         LA    &R.6,1              GET COMBO OF \"1\" AND DIRECTION FLAG\n         SPACE 1\n&N.UP    LCR   &R.6,&R.6           COMPLEMENT FOR TEST\n         CR    &R.5,&R.6           WAS PREV WIDTH 1 AND DIRECTION DOWN?\n         BE    &N.NFND             YES, SEARCH OBJECT NOT FOUND\n&N.UP2   LPR   &R.6,&R.6           NO, SET DIRECTION UP\n         AR    &R.5,&R.6           FORCE WIDTH TO ROUND UP UPON DIVIDE\n         SRL   &R.5,1              CUT WIDTH IN HALF (ROUND UP)\n         AR    &R.4,&R.5           ADVANCE THE SEARCH INDEX\n         B     &N.CMPR             PROCEED\n         SPACE 1\n&N.DOWN  LNR   &R.6,&R.6           SET DIRECTION DOWN\n         SR    &R.5,&R.6           FORCE WIDTH TO ROUND UP UPON DIVIDE\n         SRL   &R.5,1              CUT WIDTH IN HALF (ROUND UP)\n         SR    &R.4,&R.5           RETREAT THE SEARCH INDEX\n         SPACE 1\n&N.CMPR  BM    &N.UP               SCAN UP IF BELOW THE LIST\n         CR    &R.4,&R.3           ABOVE THE LIST?\n         BNL   &N.DOWN             YES, MUST SCAN DOWN\n         SPACE 1\n         LR    &R.15,&R.4          GET CURRENT POSITION INDEX\n         MR    &R.14,&R.0          CNVRT TO LIST DISPLACEMENT\n         AR    &R.15,&R.1          CNVRT TO ABSOLUTE ENTRY POINTER\n         BALR  &R.14,&R.2          LINK TO COMPARISON ROUTINE\n         BL    &N.DOWN             TOO HIGH; MUST MOVE DOWN\n         BH    &N.UP               TOO LOW; MUST MOVE UP\n         SPACE 1\n         LCR   &R.6,&R.6           A HIT; COMPLEMENT FOR TEST\n         CR    &R.5,&R.6           WAS PREVIOUS WIDTH 1 AND DOWN?\n         BE    &N.FND              YES, FOUND LAST OF DUPLICATE KEYS\n         LA    &R.5,4              NO, SET TO FWD SCAN PAST DUP KEYS\n         B     &N.UP2              LOOP TO SKIP PAST DUP KEYS\n         SPACE 1\n&N.NFND  LA    &R.15,1(,&R.4)      NOT FOUND; GET INDEX TO INSERT POINT\n         MR    &R.14,&R.0          CNVRT TO DISPLACEMENT\n&N.NULL  AR    &R.15,&R.1          CNVRT TO ABSOLUTE\n         CLI   *,0                 SET CC\u00ac=0\n&N.FND   ST    &R.15,&SAVEA+12     PRESERVE ENTRY PTR IN R1 SLOT\n         LM    &R.14,&R.13,&SAVEA  RESTORE REGISTERS\n         BR    &R.14               RETURN TO CALLER WITH CC SET\n         AIF   (K'&SVID NE 0).MEND\n         SPACE 1\n&N.SAVE  DC    16A(0)              REGISTER SAVE AREA\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "#SLD": {"ttr": 2573, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x850/\\x00\\x850/\\x12\\x00\\x003\\x003\\x00\\x00\\xd6\\xd3\\xc4\\xd4\\xc1\\xc3\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-10-29T00:00:00", "modifydate": "1985-10-29T12:00:00", "lines": 51, "newlines": 51, "modlines": 0, "user": "OLDMACS"}, "text": "         MACRO\n&N       #SLD  &R,&A\n.*\n.*\n.*\n.* LAST CHANGE DATE - OCTOBER 18, 1983\n.*                  - MAILING ADDRESS CHANGE\n.*\n.* LAST CHANGE DATE - APRIL 21, 1981\n.*                  - MACRO NAME CHANGED FROM SLD TO #SLD.\n.*\n.* LAST CHANGE DATE - FEBRUARY 2, 1977\n.*                  - MAILING ADDRESS CHANGE.\n.*\n.* LAST CHANGE DATE - FEBRUARY 3, 1976\n.*\n.* THIS MACRO WAS WRITTEN BY DAVID B. COLE. ANY QUESTIONS CONCERNING IT\n.* MAY BE ADDRESSED TO:\n.*       RR#2 BOX 712\n.*       AFTON, VA. 22920\n.*\n.*\n.*\n.*   THIS MACRO SIMULATES A HYPOTHETICAL \"SUBTRACT LOGICAL DOUBLE\"\n.* MACHINE INSTRUCTION. ITS FUNCTION IS SIMILAR TO THE \"SL\" MACHINE\n.* INSTRUCTION EXCEPT THAT IT OPERATES ON 64-BIT NUMBERS. WARNING, THE\n.* RESULTING CONDITION CODE IS NOT AN ANALOGOUS EXTENSION FROM THE \"SL\"\n.* INSTRUCTION.\n.*\n.* INNER MACROS USED - #TEST\n.*\n.*\n.*\n         GBLA  &#TESERR\n         GBLC  &#TESRET(20)\n         LCLA  &A1\n         LCLC  &RODD\n&RODD    SETC  '&R+1'\n         #TEST REGS=&R\n         AIF   (&#TESERR NE 0).REGUNKN\n&A1      SETA  &#TESRET(1)+1\n         AIF   (&A1 LE 15).GOTA1\n&A1      SETA  0\n.GOTA1   #TEST PFIX=\n&RODD    SETC  '&#TESRET(1)&A1'\n.REGUNKN ANOP\n&N       SL    &RODD,4+&A LOW-ORDER DIFFERENCE; HI-ORDER AFFECTED?\n         BC    3,SLD&SYSNDX NO, SKIP\n         BCTR  &R,0 YES, ADJUST HI-ORDER\nSLD&SYSNDX SL  &R,&A GET HI-ORDER DIFFERENCE\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "#SLDR": {"ttr": 2575, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x850/\\x00\\x850/\\x12\\x00\\x00<\\x00<\\x00\\x00\\xd6\\xd3\\xc4\\xd4\\xc1\\xc3\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-10-29T00:00:00", "modifydate": "1985-10-29T12:00:00", "lines": 60, "newlines": 60, "modlines": 0, "user": "OLDMACS"}, "text": "         MACRO\n&N       #SLDR &R1,&R2\n.*\n.*\n.*\n.* LAST CHANGE DATE - OCTOBER 18, 1983\n.*                  - MAILING ADDRESS CHANGE\n.*\n.* LAST CHANGE DATE - APRIL 21, 1981\n.*                  - MACRO NAME CHANGED FROM $SLDR TO #SLDR.\n.*\n.* LAST CHANGE DATE - FEBRUARY 2, 1977\n.*                  - MAILING ADDRESS CHANGE.\n.*\n.* LAST CHANGE DATE - FEBRUARY 3, 1976\n.*\n.* THIS MACRO WAS WRITTEN BY DAVID B. COLE. ANY QUESTIONS CONCERNING IT\n.* MAY BE ADDRESSED TO:\n.*       RR#2 BOX 712\n.*       AFTON, VA. 22920\n.*\n.*\n.*\n.*   THIS MACRO SIMULATES A HYPOTHETICAL \"SUBTRACT LOGICAL DOUBLE\n.* REGISTER\" MACHINE INSTRUCTION. ITS FUNCTION IS SIMILAR TO THE \"SLR\"\n.* MACHINE INSTRUCTION EXCEPT THAT IT OPERATES ON 64-BIT NUMBERS.\n.* WARNING, THE RESULTING CONDITION CODE IS NOT AN ANALOGOUS EXTENSION\n.* FROM THE \"SLR\" INSTRUCTION.\n.*\n.* INNER MACROS USED - #TEST\n.*\n.*\n.*\n         GBLA  &#TESERR\n         GBLC  &#TESRET(20)\n         LCLA  &A1\n         LCLC  &R1ODD,&R2ODD\n&R1ODD   SETC  '&R1+1'\n         #TEST REGS=&R1\n         AIF   (&#TESERR NE 0).R1UNKN\n&A1      SETA  &#TESRET(1)+1\n         AIF   (&A1 LE 15).GOTA1A\n&A1      SETA  0\n.GOTA1A  #TEST PFIX=\n&R1ODD   SETC  '&#TESRET(1)&A1'\n.R1UNKN  ANOP\n&R2ODD   SETC  '&R2+1'\n         #TEST REGS=&R2\n         AIF   (&#TESERR NE 0).R2UNKN\n&A1      SETA  &#TESRET(1)+1\n         AIF   (&A1 LE 15).GOTA1B\n&A1      SETA  0\n.GOTA1B  #TEST PFIX=\n&R2ODD   SETC  '&#TESRET(1)&A1'\n.R2UNKN  ANOP\n&N       SLR   &R1ODD,&R2ODD LOW-ORDER DIFFERENCE; HI-ORDER AFFECTED?\n         BC    3,SLDR&SYSNDX NO, SKIP\n         BCTR  &R1,0 YES, ADJUST HI-ORDER\nSLDR&SYSNDX SLR &R1,&R2 GET HI-ORDER DIFFERENCE\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "#SORT": {"ttr": 2817, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x850/\\x00\\x850/\\x12\\x00\\x00\\xf7\\x00\\xf7\\x00\\x00\\xd6\\xd3\\xc4\\xd4\\xc1\\xc3\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-10-29T00:00:00", "modifydate": "1985-10-29T12:00:00", "lines": 247, "newlines": 247, "modlines": 0, "user": "OLDMACS"}, "text": "         MACRO\n&NME     #SORT &SEQ,&PFIX=,&SVID=,&CMPRID=\n.*\n.*\n.*\n.* LAST CHANGE DATE - OCTOBER 18, 1983\n.*                  - MAILING ADDRESS CHANGE\n.*\n.* LAST CHANGE DATE - APRIL 21, 1981\n.*                  - MACRO NAME CHANGED FROM $SORT TO #SORT.\n.*\n.* LAST CHANGE DATE - APRIL 20, 1981\n.*                  - \"#REGS GEN=NO\" SUPPORT ADDED.\n.*\n.* LAST CHANGE DATE - SEPTEMBER 12, 1978\n.*                  - THE SORT ROUTINE IS NOW REENTRANT.\n.*                  - THE LINKAGE FROM A COMPARE ROUTINE IS DIFFERENT\n.*                    IF THE COMPARE ROUTINE ALSO PERFORMS THE\n.*                    EXCHANGE.\n.*\n.* LAST CHANGE DATE - FEBRUARY 2, 1977\n.*                  - MAILING ADDRESS CHANGE.\n.*\n.* LAST CHANGE DATE - OCTOBER 28, 1975\n.*\n.* THIS MACRO WAS WRITTEN BY DAVID B. COLE.  ANY QUESTIONS CONCERNING\n.* IT MAY BE ADDRESSED TO:\n.*       RR#2 BOX 712\n.*       AFTON, VA. 22920\n.*\n.*\n.*\n.*   THIS MACRO GENERATES A SUBROUTINE THAT SORTS A LIST OF ITEMS USING\n.* THE INTERNAL SORTING TECHNIQUE KNOWN AS THE \"SHELL SORT\".\n.*\n.*   THE SORT SUBROUTINE REQUIRES THE FOLLOWING INPUTS:\n.*       - REGISTER 14 POINTS TO THE RETURN ADDRESS;\n.*       - REGISTER 15 CONTAINS THE LENGTH (IN BYTES) OF THE LIST TO BE\n.*         SORTED;\n.*       - REGISTER 0 CONTAINS THE LENGTH (IN BYTES) OF EACH ENTRY IN\n.*         THE LIST;\n.*       - REGISTER 1 POINTS TO THE START OF THE LIST.\n.*\n.*   ON OUTPUT THE LIST DESCRIBED BY THE INPUT PARAMETERS IS SORTED IN\n.* EITHER ASCENDING OR DESCENDING COALATING SEQUENCE (DEPENDING UPON\n.* THE MACRO CALL). ALL REGISTERS ARE RESTORED.\n.*\n.*   THE SORT SUBROUTINE IS REENTRANT.\n.*\n.*   THE NAME FIELD\n.* THIS FIELD IS OPTIONAL. IT CAN BE USED TO DEFINE BOTH THE NAME OF\n.* THE SUBROUTINE AND THE PREFIX USED IN ALL GENERATED STATEMENT\n.* LABELS. IF OMITTED, THE THE CHARACTERS \"SORT\" WILL BE USED. IF\n.* GIVEN, THEN NO MORE THAN FOUR CHARACTERS SHOULD BE SPECIFIED.\n.*\n.*   THE FIRST POSITIONAL OPERAND\n.* THIS FIELD IS OPTIONAL. IT CAN BE USED TO SPECIFY WHETHER THE LIST\n.* IS TO BE SORTED IN ASCENDING OT DESCENDING ORDER. IF OMITTED, THEN\n.* ASCENDING ORDER IS ASSUMED. IF GIVEN, THEN IT SHOULD BE EITHER \"A\"\n.* OR \"D\".\n.*\n.*   THE PFIX= OPERAND\n.* THE #SORT MACRO ATTEMPTS TO USE REGISTER EQUATES IN ITS EXPANSION\n.* WHEN REFERING TO REGISTERS. THIS IS SO THAT THE USE OF THE REGISTERS\n.* WILL BE INDICATED IN THE CROSS REFERENCE LISTING. THE PFIX= OPERAND\n.* CAN BE USED TO CONTROL THE SET OF EQUATES USED. FOR EXAMPLE, IF\n.* \"PFIX=GPR\" IS SPECIFIED, THEN \"GPR1\" WILL BE USED WHENEVER THE\n.* EXPANSION REFERS TO REGISTER 1.\n.*   IF THE PFIX= OPERAND IS OMITTED, THEN THE SET OF EQUATES DEFINED\n.* BY THE FIRST PRIOR #REGS MACRO WILL BE USED. IF THERE IS NO PRIOR\n.* #REGS MACRO, THEN NO EQUATES WILL BE USED.\n.*\n.*   THE CMPRID= OPERAND\n.* WHEN THE CMPRID= OPERAND IS OMITTED, THEN FOR SORTING PURPOSES A CLC\n.* INSTRUCTION IS USED TO COMPARE THE ENTIRETY OF EACH LIST ENTRY. IF\n.* THIS IS NOT ACCEPTABLE, THEN THE CMPRID= OPERAND CAN BE USED TO\n.* INDICATE THAT ENTRY COMPARISON IS TO BE DONE VIA SUBROUTINE CALL. IF\n.* \"CMPRID=0\" IS GIVEN, THEN THE PROGRAMMER MUST PRELOAD THE ADDRESS OF\n.* THE COMPARE SUBROUTINE INTO THE ADDRESS LABELLED \"SORTCMPR\". ON THE\n.* OTHER HAND, IF CMPRID= IS SET EQUAL TO SOMETHING OTHER THAN 0, THEN\n.* THE GIVEN VALUE IS USED EITHER AS THE NAME OF THE SUBROUTINE, OR AS\n.* A REGISTER CONTAINING A POINTER TO THE SUBROUTINE.\n.*   ON ENTRY TO THE COMPARE ROUTINE, R6 AND R7 POINT TO THE TWO LIST\n.* ENTRIES TO BE COMPARED. THE ENTRY POINTED TO BY R6 SEQUENTIALLY\n.* PRECEEDS THE ONE POINTED TO BY R7. R14 POINTS TO THE RETURN ADDRESS.\n.*   UPON RETURN, THE COMPARE ROUTINE MUST SET THE CONDITION CODE AS\n.* FOLLOWS:\n.*       - CC=0 (EQUAL) MEANS THAT THE TWO LIST ENTRIES ARE EQUAL IN\n.*         VALUE AND SHOULD NOT BE EXCHANGED.\n.*       - CC=1 (LOW) MEANS THAT THE FIRST LIST ENTRY HAS A LOWER VALUE\n.*         THAN THE SECOND. WHETHER OR NOT THEY ARE EXCHANGED DEPENDS\n.*         UPON WHETHER OR NOT THIS IS AN ASCENDING OR DESCENDING ORDER\n.*         SORT.\n.*       - CC=2 (HIGH) MEANS THAT THE FIRST LIST ENTRY HAS A HIGHER\n.*         VALUE THAN THE SECOND. WHETHER OR NOT THEY ARE EXCHANGED\n.*         DEPENDS UPON WHETHER OR NOT THIS IS AN ASCENDING OR\n.*         DESCENDING ORDER SORT.\n.*       - CC=3 (OVERFLOW) MEANDS THAT THE TWO ENTRIES WERE OUT OF\n.*         ORDER AND HAVE ALREADY BEEN EXCHANGED BY THE COMPARE\n.*         ROUTINE. THIS RETURN SHOULD BE USED IF THE NATURE OF THE\n.*         LIST ENTRIES IS SUCH THAT THE EXCHANGE CODE GENERATED BY\n.*         THIS MACRO WOULD FAIL.\n.*   THE COMPARE ROUTINE MUST NOT ALTER REGISTERS 14 THROUGH 7. ANY OF\n.* THE REGISTERS 8 THROUGH 13 (EXCEPTING THOSE THAT ARE USED AS PROGRAM\n.* BASES) MAY BE USED FREELY SINCE THE SORT ROUTINE RESTORES ALL\n.* REGISTERS WHEN IT IS FINISHED.\n.*\n.*   THE SVID= OPERAND\n.* USE THIS OPERAND TO SPECIFY THE NAME OF A REGISTER SAVE AREA. IF\n.* OMITTED, THEN THE MACRO WILL GENERATE A LOCAL SAVE AREA.\n.*   IF THE CMPRID= OPERAND IS GIVEN, THEN THE SAVE AREA MUST BE 16\n.* WORDS LONG; OTHERWISE, IT NEED BE ONLY 10 WORDS LONG (FOR REGISTERS\n.* 14 THROUGH 7).\n.*\n.*\n.*\n.* INNER MACROS USED - #REGS #TEST\n.*\n.*\n.*\n         GBLA  &#TESERR\n         GBLC  &#TESRET(20)\n         LCLA  &SAVESZ,&SL\n         LCLC  &N,&R,&SAVEA\n&N       SETC  'SORT'\n         AIF   (K'&NME EQ 0).GOTNME\n&N       SETC  '&NME'\n.GOTNME  ANOP\n.*\n&R       SETC  '&PFIX'\n         AIF   (K'&PFIX NE 0).GOTPFIX\n         #TEST PFIX=\n&R       SETC  '&#TESRET(1)'\n         AGO   .DONPFIX\n.GOTPFIX #REGS &PFIX,GEN=NO\n.DONPFIX ANOP\n.*\n         AIF   ('&SEQ' EQ 'D').DCNDCMT\n* ASCENDING ORDER SORT ROUTINE\n         AGO   .CMT2\n.DCNDCMT ANOP\n* DESCENDING ORDER SORT ROUTINE\n.CMT2    ANOP\n&SAVESZ  SETA  10\n&SL      SETA  7\n         AIF   (K'&CMPRID EQ 0).NOCMPR1\n&SAVESZ  SETA  16\n&SL      SETA  13\n* WITH A CALLER PROVIDED SUBROUTINE FOR ENTRY COMPARISON\n.NOCMPR1 SPACE 1\n* SORT ROUTINE INPUTS:\n*        - R14 POINTS TO THE RETURN ADDRESS\n*        - R15 CONTAINS THE LENGTH OF THE LIST (IN BYTES)\n*        - R0 CONTAINS THE LENGTH OF EACH LIST ENTRY (IN BYTES)\n*        - R1 POINTS TO THE START OF THE LIST\n         AIF   (K'&CMPRID EQ 0).NOCMPR2\n         SPACE 1\n* COMPARE ROUTINE INPUTS:\n*        - R6 AND R7 POINT TO THE TWO LIST ENTRIES TO BE COMPARED. THE\n*          ENTRY POINTED TO BY R6 SEQUENTIALLY PRECEEDS THE ONE POINTED\n*          TO BY R7.\n*        - R14 POINTS TO A RETURN ADDRESS.\n*        - R14 THROUGH R7 CONTAIN DATA CRITICAL TO THE SORT ROUTINE.\n*          THEY MUST NOT BE ALTERED BY THE COMPARE ROUTINE.\n         SPACE 1\n* COMPARE ROUTINE OUTPUTS:\n*        - CC=0 (EQUAL) MEANS THAT THE TWO LIST ENTRIES HAVE EQUAL\n*          VALUES. THEY SHOULD NOT BE EXCHANGED.\n*        - CC=1 (LOW) MEANS THAT THE FIRST ENTRY HAS A VALUE LOWER THAN\n*          THE SECOND. IF THIS IS AN ASCENDING SORT, THEN THEY WILL NOT\n*          BE EXCHANGED.\n*        - CC=2 (HIGH) MEANS THAT THE FIRST ENTRY HAS A VALUE HIGHER\n*          THAN THE SECOND. IF THIS IS AN ASCENDING SORT, THEN THEY\n*          WILL BE EXCHANGED.\n*        - CC=3 (OVERFLOW) MEANS THAT THE TWO ENTRIES WERE OUT OF ORDER\n*          AND THAT THEY HAVE NOW BEEN EXCHANGED BY THE COMPARE\n*          ROUTINE.\n.NOCMPR2 SPACE 1\n&SAVEA   SETC  '&N.SAVE'\n         AIF   (K'&SVID EQ 0).GOTSAVE\n&SAVEA   SETC  '&SVID'\n.GOTSAVE ANOP\n&N       STM   &R.14,&R.&SL,&SAVEA SAVE ALL WORK REGSITERS\n         AIF   ('&CMPRID' EQ '').GOTCMPR\n         AIF   ('&CMPRID' NE '0').CMPRN0\n         L     &R.15,&N.CMPR       --> CALLER PROVIDED COMPARE ROUTINE\n         AGO   .GOTCMPR\n.CMPRN0  AIF   ('&CMPRID' NE '&CMPRID(1)').CMPRREG\n         LA    &R.15,&CMPRID       --> CALLER PROVIDED COMPARE ROUTINE\n         AGO   .GOTCMPR\n.CMPRREG #TEST REGS=&CMPRID(1)\n         AIF   (&#TESERR NE 0).CMPRROK\n         AIF   (&#TESRET(1) GT 1 AND &#TESRET(1) LT 14).CMPRROK\n         MNOTE 8,'ERROR - CMPRID= MAY NOT IDENTIFY REGISTER &$TESRET(1)*\n               '\n.CMPRROK LR    &R.15,&CMPRID(1)    --> CALLER PROVIDED COMPARE ROUTINE\n.GOTCMPR LR    &R.4,&R.0           GET THE ENTRY LENGTH\n         LR    &R.1,&R.0           GET ENTRY LENGTH FOR 'EX'\n         BCTR  &R.1,0              GET THE ENTRY'S MACHINE LENGTH\n         LR    &R.2,&R.4           GET ENTRY LENGTH\n&N.DUBL  AR    &R.2,&R.2           DOUBLE IT\n         C     &R.2,&SAVEA+4       GREATER THAN LIST LENGTH YET?\n         BNH   &N.DUBL             NO, GO RE-DOUBLE\n         SR    &R.2,&R.4           YES, GOT INITIAL INCREMENT\n&N.LP1   SR    &R.2,&R.4           SUBTRACT ONE AND -\n         BZ    &N.RET               (ALL DONE; GO RESTORE AND RETURN)\n         SRL   &R.2,1               TRUNCATE DEVIDE BY TWO\n         L     &R.5,&SAVEA+4       GET THE LENGTH OF THE LIST\n         SR    &R.5,&R.2           SUBTRACT OFF THE INCREMENT\n         LR    &R.3,&R.4           GET THE ENTRY LENGTH\n&N.LP2   LR    &R.0,&R.4           GET THE ENTRY LENGTH AGAIN\n&N.LP3   LR    &R.6,&R.3           DEVELOPE -\n         A     &R.6,&SAVEA+12       THE FIRST -\n         SR    &R.6,&R.0             COMPARE ADDRESS\n         LA    &R.7,0(&R.2,&R.6)   DEVELOPE THE SECOND ADDRESS\n         AIF   ('&CMPRID' EQ '').NOCMPR6\n         BALR  &R.14,&R.15         LINK TO CALLER'S COMPARE ROUTINE\n         BO    &N.NLP3             OUT OF ORDER BUT NOW EXCHANGED\n         AGO   .NOCMPR7\n.NOCMPR6 EX    &R.1,&N.CLC         COMPARE THE TWO ENTRIES\n.NOCMPR7 AIF   ('&SEQ' EQ 'D').DESCEND\n         BNH   &N.NLP2             RIGHT ORDER (ASCENDING); DON'T XCHNG\n         AGO   .ASCEND\n.DESCEND BNL   &N.NLP2             RIGHT ORDER (DESCENDING); DON'T XCHG\n.ASCEND  EX    &R.1,&N.XC1         WRONG -\n         EX    &R.1,&N.XC2          ORDER; -\n         EX    &R.1,&N.XC1           EXCHANGE\n&N.NLP3  BXLE  &R.0,&R.2,&N.LP3    LOOP TO SHIFT THE BUBBLE\n&N.NLP2  BXLE  &R.3,&R.4,&N.LP2    ADVANCE ONE INCREMENT\n         B     &N.LP1              LOOP TO DECREASE THE INCREMENT\n&N.RET   LM    &R.14,&R.&SL,&SAVEA SORT DONE; RESTORE REGS\n         BR    &R.14               RETURN TO CALLER\n         SPACE 1\n         AIF   ('&CMPRID' NE '').DATA1\n&N.CLC   CLC   0(*-*,&R.6),0(&R.7) (EXECUTED)\n.DATA1   ANOP\n&N.XC1   XC    0(*-*,&R.6),0(&R.7) (EXECUTED)\n&N.XC2   XC    0(*-*,&R.7),0(&R.6) (EXECUTED)\n         AIF   ('&CMPRID' NE '0' AND '&SVID' NE '').DATA2\n         SPACE 1\n.DATA2   AIF   ('&CMPRID' NE '0').DATA3\n&N.CMPR  DC    A(*-*)              THE POINTER TO THE COMPARE ROUTINE\n*                                  MUST BE FILLED IN PRIOR TO THE FIRST\n*                                  CALL TO THE SORT ROUTINE.\n.DATA3   AIF   ('&SVID' NE '').DATA4\n&N.SAVE  DC    &SAVESZ.A(0)        LOCAL SAVE AREA\n.DATA4   MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "#TEST": {"ttr": 2822, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x850/\\x00\\x850/\\x12\\x00\\x02\\x88\\x02\\x88\\x00\\x00\\xd6\\xd3\\xc4\\xd4\\xc1\\xc3\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-10-29T00:00:00", "modifydate": "1985-10-29T12:00:00", "lines": 648, "newlines": 648, "modlines": 0, "user": "OLDMACS"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "#UNALIGN": {"ttr": 3079, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x850/\\x00\\x850/\\x12\\x00\\x00Y\\x00Y\\x00\\x00\\xd6\\xd3\\xc4\\xd4\\xc1\\xc3\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-10-29T00:00:00", "modifydate": "1985-10-29T12:00:00", "lines": 89, "newlines": 89, "modlines": 0, "user": "OLDMACS"}, "text": "         MACRO\n&NME     #UNALIGN &OP,&A1,&A2,&A3\n.*\n.*\n.*\n.* LAST CHANGE DATE - OCTOBER 18, 1983\n.*                  - MAILING ADDRESS CHANGE\n.*\n.* LAST CHANGE DATE - APRIL 21, 1981\n.*                  - MACRO NAME CHANGED FROM $UNALIGN TO #UNALIGN.\n.*\n.* LAST CHANGE DATE - FEBRUARY 19, 1978\n.*                  - ADD SUPPORT FOR THE 'LM' AND 'STM' INSTRUCTIONS\n.*\n.* LAST CHANGE DATE - JANUARY 15, 1978\n.*\n.* THIS MACRO WAS WRITTEN BY DAVID B. COLE. ANY QUESTIONS CONCERNING\n.* IT MAY BE ADDRESSED TO:\n.*       RR#2 BOX 712\n.*       AFTON, VA. 22920\n.*\n.*\n.*\n         LCLA  &W1\n         LCLC  &N(30),&O(30)\n&N(1)    SETC  'A'\n&N(2)    SETC  'C'\n&N(3)    SETC  'D'\n&N(4)    SETC  'L'\n&N(5)    SETC  'M'\n&N(6)    SETC  'N'\n&N(7)    SETC  'O'\n&N(8)    SETC  'S'\n&N(9)    SETC  'X'\n&N(10)   SETC  'AH'\n&N(11)   SETC  'AL'\n&N(12)   SETC  'CH'\n&N(13)   SETC  'CL'\n&N(14)   SETC  'LH'\n&N(15)   SETC  'LM'\n&N(16)   SETC  'MH'\n&N(17)   SETC  'SH'\n&N(18)   SETC  'SL'\n&N(19)   SETC  'ST'\n&N(20)   SETC  'CVB'\n&N(21)   SETC  'CVD'\n&N(22)   SETC  'STH'\n&N(23)   SETC  'STM'\n&N(24)   SETC  '\u009f\u009f\u009f\u009f\u009f\u009f\u009f\u009f'\n&O(1)    SETC  '5A'\n&O(2)    SETC  '59'\n&O(3)    SETC  '5D'\n&O(4)    SETC  '58'\n&O(5)    SETC  '5C'\n&O(6)    SETC  '54'\n&O(7)    SETC  '56'\n&O(8)    SETC  '5B'\n&O(9)    SETC  '57'\n&O(10)   SETC  '4A'\n&O(11)   SETC  '5E'\n&O(12)   SETC  '49'\n&O(13)   SETC  '55'\n&O(14)   SETC  '48'\n&O(15)   SETC  '98'\n&O(16)   SETC  '4C'\n&O(17)   SETC  '4B'\n&O(18)   SETC  '5F'\n&O(19)   SETC  '50'\n&O(20)   SETC  '4F'\n&O(21)   SETC  '4E'\n&O(22)   SETC  '40'\n&O(23)   SETC  '90'\n&O(24)   SETC  ''\n&W1      SETA  0\n.LP1     ANOP\n&W1      SETA  &W1+1\n         AIF   ('&N(&W1)' LT '&OP').LP1\n         AIF   ('&N(&W1)' EQ '&OP').END1\n&W1      SETA  24\n.END1    AIF   ('&O(&W1)' GE '80').RS\n&NME     LA    &A1,&A2\n         AGO   .COMMON\n.RS      ANOP\n&NME     ICM   &A1,&A2,&A3\n.COMMON  ANOP\n         ORG   *-4\n         DC    X'&O(&W1)'\n         ORG   *+3\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#USING": {"ttr": 3082, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x850/\\x00\\x850/\\x12\\x00\\x00*\\x00*\\x00\\x00\\xd6\\xd3\\xc4\\xd4\\xc1\\xc3\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-10-29T00:00:00", "modifydate": "1985-10-29T12:00:00", "lines": 42, "newlines": 42, "modlines": 0, "user": "OLDMACS"}, "text": "         MACRO\n         #USING &D\n.*\n.*\n.*\n.* LAST CHANGE DATE - OCTOBER 18, 1983\n.*                  - MAILING ADDRESS CHANGE\n.*\n.* LAST CHANGE DATE - APRIL 21, 1981\n.*                  - MACRO NAME CHANGED FROM $USING TO #USING.\n.*\n.* LAST CHANGE DATE - FEBRUARY 2, 1977\n.*                  - MAILING ADDRESS CHANGE.\n.*\n.* LAST CHANGE DATE - AUGUST 23, 1976\n.*\n.* THIS MACRO WAS WRITTEN BY DAVID B. COLE. ANY QUESTIONS CONCERNING\n.* IT MAY BE ADDRESSED TO:\n.*       RR#2 BOX 712\n.*       AFTON, VA. 22920\n.*\n.*\n.*\n.*   THIS MACRO GENERATES A USING INSTRUCTION THAT REDECLARES ALL BASES\n.* (IF ANY) DECLARED BY A PRIOR #ENTER MACRO EXPANSION.\n.*\n.*\n.*\n.* INNER MACROS USED - NONE\n.*\n         GBLC  &#BS(14)\n         LCLA  &A1,&DISPL\n         AIF   ('&#BS(14)' EQ '').END\n&DISPL   SETA  &DISPL-4095\n&A1      SETA  14\n.LP      AIF   (&A1 EQ 2).END\n&A1      SETA  &A1-1\n         AIF   ('&#BS(&A1)' EQ '').LP\n&DISPL   SETA  &DISPL+4095\n         USING &#BS(14)+&DISPL,&#BS(&A1)\n         AGO   .LP\n.END     MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#XXC": {"ttr": 3084, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x850/\\x00\\x850/\\x12\\x00\\x01\\xb1\\x01\\xb1\\x00\\x00\\xd6\\xd3\\xc4\\xd4\\xc1\\xc3\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-10-29T00:00:00", "modifydate": "1985-10-29T12:00:00", "lines": 433, "newlines": 433, "modlines": 0, "user": "OLDMACS"}, "text": "         MACRO\n&NAME    #XXC  &OP,&T,&F,&L,&SVID=,&PFIX=,&MF=INLINE\n.*\n.*\n.*\n.* LAST CHANGE DATE - OCTOBER 18, 1983\n.*                  - MAILING ADDRESS CHANGE\n.*\n.* LAST CHANGE DATE - MARCH 8, 1982\n.*                  - THE LENGTH VERIFICATION TEST (\"#TEST SIZE=...\")\n.*                    HAS BEEN REMOVED. IT IS NOT REALLY NEEDED.\n.*\n.* LAST CHANGE DATE - DECEMBER 1, 1981\n.*                  - \"PFIX=(...,NOSAVE)\" SUPPORT HAS BEEN ADDED. THIS\n.*                    PROVIDES A MEANS OF BYPASSING THE ISSUENCE OF THE\n.*                    #REGS MACRO. (SOMETIMES, THE #REGS MACRO THAT I\n.*                    WOULD GET IS NOT THE ONE I WANT).\n.*\n.* LAST CHANGE DATE - JUNE 1, 1981\n.*                  - BUG FIXED. NOW, IF MF=SUBROUTINE AND\n.*                    OP=TRT, THEN R1 IS NOT RESTORED WHEN\n.*                    THE SUBROUTINE COMPLETES.\n.*\n.* LAST CHANGE DATE - APRIL 21, 1981\n.*                  - MACRO NAME CHANGED FROM $XXC TO #XXC.\n.*\n.* LAST CHANGE DATE - APRIL 20, 1981\n.*                  - \"#REGS GEN=NO\" SUPPORT ADDED.\n.*\n.* LAST CHANGE DATE - DECEMBER 12, 1977\n.*                  - SYNTAX BUG FIXED. A CONTINUATION CHARACTER WAS\n.*                    NOT PLACE IN COLUMN 72.\n.*\n.* LAST CHANGE DATE - JANUARY 17, 1977\n.*                  - FORM OF &MF= OPERAND REDESIGNED.\n.*                  - DEFAULT MEANINGS OF &T AND &F AND (FOR\n.*                    MF=SUBROUTINE) &L REMOVED.\n.*                  - REGISTER FORM OF &SVID= SUPPORTED.\n.*                  - COMMENTARY REWRITTEN.\n.*                  - MAILING ADDRESS CHANGED.\n.*\n.* LAST CHANGE DATE - SEPTEMBER 27, 1976\n.*                  - FIXED BUG: MISSING SEQUENCE SYMBOL - .TLR\n.*                  - CHANGED LENGTH SIZE TEST TO BE GENERATED WHENEVER\n.*                    &L(2) WAS GIVEN WITH THE NON-ROUTINE/SUBROUTINE\n.*                    FORM OF THE MACRO CALL.\n.*                  - IF THE CALL IS A KNOWN LENGTH FORM AND IF THE\n.*                    LENGTH'S DERIVATIVE EXPRESSION IS GIVEN (&L(2))\n.*                    THEN IT IS USED TO DERIVE THE LENGTH FIELD OF THE\n.*                    LAST SS INSTRUCTION GENERATED.\n.*\n.* LAST CHANGE DATE - JUNE 6, 1975\n.*\n.* THIS MACRO WAS WRITTEN BY DAVID B. COLE. ANY QUESTIONS CONCERNING\n.* IT MAY BE ADDRESSED TO:\n.*       RR#2 BOX 712\n.*       AFTON, VA. 22920\n.*\n.*\n.*    THIS MACRO GENERATES ROUTINES TO PERFORM NON-DECIMAL\n.* STORAGE-TO-STORAGE FUNCTIONS ON OPERANDS OF ARBITRARY LENGTH.\n.* SUPPORTED \"SS-FUNCTIONS\" ARE:\n.*       CLC      MVZ      TR\n.*       MVC      NC       TRT\n.*       MVN      OC       XC\n.*\n.*    THIS MACRO HAS TWO DIFFERENT MODES OF EXPANSION:\n.*     - IF THE OPERAND LENGTHS ARE KNOWN AT ASSEMBLY TIME, THEN THE\n.*       EXPANSION CAN CONSIST OF A SUFFICIENT NUMBER OF\n.*       SS-INSTRUCTIONS TO ACCOMODATE THE GIVEN LENGTH. FOR EACH\n.*       SUCCESSIVE SS-INSTRUCTION GENERATED, THE SINK OPERAND POINTER\n.*       IS INCREMENTED BY 256. THE SOURCE OPERAND POINTER IS ALSO\n.*       INCREMENTED BY 256 UNLESS THE OPERATOR IS EITHER \"TR\" OR\n.*       \"TRT\". ADDITIONALLY FOR \"CLC\" AND \"TRT\", CONDITIONAL BRANCH\n.*       INSTRUCTIONS ARE INSERTED IN THE EXPANSION SO THAT UPON THE\n.*       FIRST OCCURANCE OF A NOT-EQUAL CONDITION THE REMAINING\n.*       SS-INSTRUCTIONS ARE BYPASSED.\n.*     - IF THE OPERAND LENGTHS CANNOT BE KNOWN UNTIL EXECUTION TIME,\n.*       THEN THE EXPANSION IS A GENERALIZED SUBROUTINE CAPABLE OF\n.*       PROCESSING ANY LENGTH.\n.*\n.* &NAME\n.*       THIS OPERAND IS OPTIONAL. IF GIVEN, THEN, OF COURSE, IT LABELS\n.*       THE GENERATED CODE.\n.*\n.* &MF=\n.*       THIS OPERAND IS OPTIONAL. IF OMITTED, THEN MF=INLINE IS\n.*       ASSUMED. &MF= CONTROLS THE OVERALL FORM OF THE MACRO\n.*       EXPANSION. &MF= MAY BE GIVEN IN THE FOLLOWING FORMS:\n.*       -OMITTED-\n.*       MF=\n.*       MF=INLINE\n.*             THE SINK OPERAND LENGTH IS KNOWN AT ASSEMBLY TIME. THE\n.*             MACRO EXPANDS INTO A SUFFICIENT REPETITION OF\n.*             SS-INSTRUCTIONS TO PERFORM THE FUNCTION.\n.*       MF=(SUBROUTINE, --- )\n.*             THE SINK OPERAND LENGTH CANNOT BE KNOWN UNTIL ASSEMBLY\n.*             TIME. THE MACRO EXPANDS INTO A GENERALIZED SUBROUTINE\n.*             CAPABLE OF PERFORMING THE REQUIRED SS-FUNCTION ON\n.*             OPERANDS OF ARBITRARY LENGTH.\n.*       MF=SUBROUTINE\n.*       MF=(SUBROUTINE,(14))\n.*             WHEN THE SS-FUNCTION SUBROUTINE COMPLETES, A RETURN IS\n.*             MADE TO THE ADDRESS POINTED TO BY REGISTER-14.\n.*       MF=(SUBROUTINE,(-X-))\n.*             -X- MUST BE AN ABSOLUTE EXPRESSION REPRESENTING THE NAME\n.*             OF A REGISTER CONTAINING A RETURN ADDRESS.\n.*       MF=(SUBROUTINE,-X-)\n.*             -X- MUST BE AN ABSOLUTE OR RELOCATABLE EXPRESSION\n.*             REPRESENTING A FIXED RETURN ADDRESS.\n.*       MF=(SUBROUTINE,*)\n.*             WHEN THE SS-FUNCTION SUBROUTINE COMPLETES, IT FALLS\n.*             THROUGH TO CODE FOLLOWING THE MACRO EXPANSION.\n.*\n.* &OP\n.*       THIS OPERAND IS REQUIRED. IT IDENTIFIES THE SS-FUNCTION TO BE\n.*       PERFORMED. IF SHOULD BE EITHER:\n.*          CLC      MVZ      TR\n.*          MVC      NC       TRT\n.*          MVN      OC       XC\n.*       IF IT IS ANYTHING ELSE, THEN A SEVERITY-4 DIAGNOSTIC IS ISSUED\n.*       BEFORE THE EXPANSION IS ATTEMPTED.\n.*\n.* &T\n.*       THIS OPERAND IS REQUIRED. IT IDENTIFIES THE LOCATION OF THE\n.*       SINK OPERAND. IT MAY BE EITHER AN ADDRESS, A REGISTER, OR A\n.*       BASE/DISPLACEMENT COMBINATION AS FOLLOWS:\n.*       -X- (ADDRESS FORM): -X- MAY BE EITHER AN ABSOLUTE OR\n.*           RELOCATABLE EXPRESSION IDENTIFYING THE LOCATION OF THE\n.*           SINK OPERAND.\n.*       (-X-) (REGISTER FORM): -X- MUST BE AN ABSOLUTE EXPRESSION\n.*             REPRESENTING THE NAME OF A REGISTER CONTAINING THE\n.*             ADDRESS OF THE SINK OPERAND.\n.*       (-X-,-Y-) (BASE/DISPLACEMENT FORM): -X- MUST BE AN ABSOLUTE\n.*                 EXPRESSION REPRESENTING A DISPLACEMENT. -Y- MUST BE\n.*                 AN ABSOLUTE EXPRESSION REPRESENTING A BASE (REGISTER\n.*                 NAME). TOGETHER THE BASE AND DISPLACEMENT GIVE THE\n.*                 ADDRESS OF THE SINK OPERAND.\n.*\n.* &F\n.*       THIS OPERAND IS REQUIRED. IT IDENTIFIES THE LOCATION OF THE\n.*       SOURCE OPERAND. IT MAY BE EITHER AN ADDRESS, A REGISTER, OR A\n.*       BASE/DISPLACEMENT COMBINATION AS FOLLOWS:\n.*       -X- (ADDRESS FORM): -X- MAY BE EITHER AN ABSOLUTE OR\n.*           RELOCATABLE EXPRESSION IDENTIFYING THE LOCATION OF THE\n.*           SOURCE OPERAND.\n.*       (-X-) (REGISTER FORM): -X- MUST BE AN ABSOLUTE EXPRESSION\n.*             REPRESENTING THE NAME OF A REGISTER CONTAINING THE\n.*             ADDRESS OF THE SOURCE OPERAND.\n.*       (-X-,-Y-) (BASE/DISPLACEMENT FORM): -X- MUST BE AN ABSOLUTE\n.*                 EXPRESSION REPRESENTING A DISPLACEMENT. -Y- MUST BE\n.*                 AN ABSOLUTE EXPRESSION REPRESENTING A BASE (REGISTER\n.*                 NAME). TOGETHER THE BASE AND DISPLACEMENT GIVE THE\n.*                 ADDRESS OF THE SOURCE OPERAND.\n.*\n.* &L\n.*       THIS OPERAND RELATES TO THE LENGTH OF THE SINK (AND,\n.*       THEREFORE, THE SOURCE) OPERAND. ITS PRECISE MEANING, HOWEVER,\n.*       DIFFERS DEPENDING UPON THE VALUE OF THE &MF= OPERAND.\n.*\n.* &L    (MF ==> INLINE)\n.*       HERE, &L IS AN OPTIONAL OPERAND REPRESENTING THE ACTUAL LENGTH\n.*       OF THE SINK OPERAND. IT MAY BE GIVEN IN THE FOLLOWING FORMS:\n.*       -OMITTED-: THE MACRO ATTEMPTS TO USE THE IMPLIED LENGTH OF THE\n.*                  SINK OPERAND. IF THE IMPLIED LENGTH CAN BE KNOWN AT\n.*                  MACRO PASS TIME, THEN IT IS USED TO CONTROL THE\n.*                  NUMBER OF SS-INSTRUCTIONS GENERATED; OTHERWISE,\n.*                  ONLY ONE SS-INSTRUCTION IS GENERATED.\n.*       -X-: -X- MUST BE A SELF-DEFINING TERM (I.E. RESOLVABLE AT\n.*            MACRO PASS TIME) REPRESENTING THE LENGTH OF THE SINK\n.*            OPERAND. IT IS USED TO CONTROL THE NUMBER OF\n.*            SS-INSTRUCTIONS GENERATED.\n.*       (-X-,-Y-): -X- MUST BE AS ABOVE. -Y- MUST BE A ABSOLUTE\n.*                  EXPRESSION (I.E. RESOLVABLE BY FINAL-PASS TIME)\n.*                  ALSO REPRESENTING THE LENGTH OF THE SINK OPERAND.\n.*                  IN OTHER WORDS, -X- AND -Y- MUST REPRESENT THE SAME\n.*                  VALUE. THE DISTINCTION IS THAT -Y- CAN BE\n.*                  RESPONSIVE TO SUCH THINGS AS LENGTH ATTRIBUTES AND\n.*                  EQUATE VALUES WHEREAS -X- CANNOT. -Y- IS NOT USED\n.*                  TO CONTROL THE MACRO EXPANSION. INSTEAD, IT IS USED\n.*                  AS A VALIDITY CHECK ON -X-. WHEN -Y- IS GIVEN, A\n.*                  STATEMENT OF THE FORM:\n.*                        DC    0Y(X'7FFF'-(X-Y),X'7FFF'-(Y-X))\n.*                  IS GENERATED. THIS STATEMENT DOES NOT CREATE ANY\n.*                  OBJECT CODE, BUT IF -X- AND -Y- HAVE UNEQUAL\n.*                  VALUES, THEN IT DOES GENERATE AN ASSEMBLY ERROR.\n.*\n.* &L    (&MF ==> SUBROUTINE)\n.*       HERE, &L IS A REQUIRED OPERAND. IT REPRESENTS THE LOCATION OF\n.*       THE LENGTH OF THE SINK OPERAND. IT MAY BE GIVEN IN THE\n.*       FOLLOWING FORMS:\n.*       -X- (ADDRESS FORM): -X- MUST BE EITHER AN ABSOLUTE OR\n.*           RELOCATABLE EXPRESSION REPRESENTING THE ADDRESS OF A\n.*           FULLWORD CONTAINING THE LENGTH OF THE SINK OPERAND.\n.*       (-X-) (REGISTER FORM): -X- MUST BE AN ABSOLUTE EXPRESSION\n.*             REPRESENTING THE NAME OF A REGISTER CONTAINING THE\n.*             LENGTH OF THE SINK OPERAND.\n.*\n.* &SVID=\n.*       THIS OPERAND IS OPTIONAL. IT IDENTIFIES THE LOCATION OF A\n.*       4-WORD REGISTER SAVE AREA FOR USE BY THE SUBROUTINE FORM OF\n.*       THE MACRO EXPANSION. (FOR THE INLINE FORM OF THE EXPANSION,\n.*       THE &SVID= OPERAND IS IGNORED.) &SVID= MAY BE GIVEN IN THE\n.*       FOLLOWING FORMS:\n.*       -OMITTED-: A 4-WORD SAVE AREA IS INCLUDED IN THE EXPANSION\n.*       SVID=-X- (ADDRESS FORM): -X- MUST BE EITHER AN ABSOLUTE OR\n.*             RELOCATABLE EXPRESSION REPRESENTING THE ADDRESS OF A\n.*             4-WORD SAVE AREA.\n.*       SVID=(-X-) (REGISTER FORM): -X- MUST BE AN ABSOLUTE EXPRESSION\n.*             REPRESENTING THE NAME OF A REGISTER CONTAINING THE\n.*             ADDRESS OF A 4-WORD REGISTER SAVE AREA. WARNING, THE\n.*             REGISTER CANNOT BE EITHER 14, 15, 0, OR 1.\n.*\n.* &PFIX=\n.*       THE #XXC MACRO ATTEMPTS TO USE REGISTER EQUATES IN ITS\n.*       EXPANSION WHEN REFERING TO REGISTERS. THIS IS SO THAT THE USE\n.*       OF THE REGISTERS IS INDICATED IN THE ASSEMBLER'S CROSS\n.*       REFERENCE LISTING. THE PFIX= OPERAND CAN BE USED TO CONTROL\n.*       THE SET OF EQUATES USED. FOR EXAMPLE, IF \"PFIX=GPR\" IS GIVEN,\n.*       THEN \"GPR1\" IS USED WHENEVER THE EXPANSION REFERS FO REGISTER\n.*       1.\n.*          IF THE PFIX= OPERAND IS OMITTED, THEN THE SET OF REGISTER\n.*       EQUATES DEFINED BY THE NEXT PRIOR #REGS MACRO IS USED. IF\n.*       THERE ARE NO PRIOR #REGS MACROS, THEN SELF-DEFINING NUMERICS\n.*       ARE USED.\n.*\n.* &PFIX=(...,NOSAVE)\n.*       THIS PREVENTS THIS MACRO FROM INVOKING THE #REGS MACRO.\n.*\n.*\n.*\n.*\n.* INNER MACROS USED - #REGS #TEST\n.*\n         GBLA  &#TESERR\n         GBLC  &#TESRET(20)\n         LCLA  &TDI,&TRI,&TR\n         LCLA  &FDI,&FRI,&FR\n         LCLA  &A,&D1,&RE\n         LCLB  &LOADR1\n         LCLC  &TZ,&TC,&TLP,&TRP\n         LCLC  &FZ,&FC,&FLP,&FRP\n         LCLC  &#,&C,&CD1,&CD2,&N,&@,&SAVEA\n&#       SETC  '&SYSNDX'\n&N       SETC  '&NAME'\n         AIF   ('&OP' EQ 'CLC' OR '&OP' EQ 'MVC' OR '&OP' EQ 'MVN' OR '*\n               &OP' EQ 'MVZ' OR '&OP' EQ 'NC' OR '&OP' EQ 'OC' OR '&OP'*\n                EQ 'TR' OR '&OP' EQ 'TRT' OR '&OP' EQ 'XC').OPCOK\n         MNOTE 4,'WARNING - THE OPCODE IS \"&OP\".'\n         MNOTE 4,'THIS EXPANSION WILL PROBABLY NOT BE USEFULL.'\n.OPCOK   ANOP\n&TDI     SETA  1\n&TRI     SETA  2\n         AIF   (N'&T GT 1).TREG\n         AIF   ('&T' EQ '&T(1)').TDCODED\n&TDI     SETA  2\n&TRI     SETA  1\n&TZ      SETC  '0'\n.TREG    ANOP\n&TC      SETC  ','\n&TLP     SETC  '('\n&TRP     SETC  ')'\n.TDCODED ANOP\n&FDI     SETA  1\n&FRI     SETA  2\n         AIF   (N'&F GT 1).FREG\n         AIF   ('&F' EQ '&F(1)').FDCODED\n&FDI     SETA  2\n&FRI     SETA  1\n&FZ      SETC  '0'\n.FREG    ANOP\n&FC      SETC  ','\n&FLP     SETC  '('\n&FRP     SETC  ')'\n.FDCODED ANOP\n         AIF   ('&MF(1)' EQ 'INLINE' OR '&MF(1)' EQ '').XXC\n         AIF   ('&MF(1)' EQ 'SUBROUTINE').SUB\n         MNOTE 8,'MF(1)=&MF(1) IS INVALID.'\n         AGO   .MEND\n.SUB     ANOP\n.*\n&@       SETC  '&PFIX(1)'\n         AIF   ('&PFIX(2). '(1,1) EQ 'N').DONPFIX\n         AIF   (K'&PFIX(1) NE 0).GOTPFIX\n         #TEST PFIX=\n&@       SETC  '&#TESRET(1)'\n         AGO   .DONPFIX\n.GOTPFIX #REGS &PFIX(1),GEN=NO\n.DONPFIX ANOP\n.*\n&SAVEA   SETC  'X&#.SVA'\n         AIF   ('&SVID(1)' EQ '').GOTSAVA\n&SAVEA   SETC  '&SVID'\n         AIF   ('&SVID(1)' EQ '&SVID').GOTSAVA\n&SAVEA   SETC  '0(&SVID(1))'\n.GOTSAVA AIF   ('&F(&FRI)' EQ '').GOTFR\n         #TEST REGS=&F(&FRI)\n         AIF   (&#TESERR NE 0).GOTFR\n&FR      SETA  &#TESRET(1)\n.GOTFR   ANOP\n&N       STM   &@.14,&@.1,&SAVEA   SAVE WORK REGISTERS\n         AIF   ('&TZ' EQ '').TLA\n         #TEST REGS=&T(&TRI)\n         AIF   (&#TESERR NE 0).TLR\n&TR      SETA  &#TESRET(1)\n         AIF   (&TR EQ 15).TDONE\n.TLR     LR    &@.15,&T(&TRI)      LOAD SINK REGISTER\n         AGO   .TDONE\n.TLA     LA    &@.15,&T(&TDI)&TLP&TC&T(&TRI)&TRP LOAD SINK REGISTER\n.TDONE   ANOP\n&LOADR1  SETB  (('&OP' NE 'TR' AND '&OP' NE 'TRT') OR (&FR EQ 14 OR &FR*\n                EQ 15))\n         AIF   (NOT &LOADR1).FDONE\n         AIF   ('&FZ' EQ '').FLA\n         AIF   (&FR EQ 15).FLR15\n         AIF   (&FR EQ 1).FDONE\n.FLR     LR    &@.1,&F(&FRI)       LOAD SOURCE REGISTER\n         AGO   .FDONE\n.FLR15   AIF   (&TR EQ 15).FLR\n         L     &@.1,&SAVEA+4       LOAD SOURCE REGISTER\n         AGO   .FDONE\n.FLA     AIF   (&FR EQ 15).FL15\n&FR      SETA  0\n.FLAA    LA    &@.1,&F(&FDI)&FLP&FC&F(&FRI)&FRP LOAD SOURCE REGISTER\n         AGO   .FDONE\n.FL15    AIF   (&TR EQ 15).FLAA\n         L     &@.1,&SAVEA+4       LOAD -\n         LA    &@.1,&F(&FDI)(,&@.1) SOURCE REGISTER\n.FDONE   AIF   ('&L' EQ '&L(1)').LL\n         #TEST REGS=&L(1)\n         AIF   (&#TESERR NE 0).LLTR\n&A       SETA  4\n&D1      SETA  &TR\n         AIF   (&#TESRET(1) EQ 15).LLSVA\n         AIF   (&#TESRET(1) NE 1).LLTR\n&A       SETA  12\n&D1      SETA  &FR\n.LLSVA   AIF   (&#TESRET(1) EQ &D1).LLTR\n         L     &@.0,&SAVEA+&A      LOAD LENGTH REGISTER\n         AGO   .LLTR0\n.LLTR    LTR   &@.0,&L(1)          LOAD LENGTH REGISTER; > 0?\n         AGO   .LDONE\n.LL      L     &@.0,&L             LOAD LENGTH REGISTER\n.LLTR0   LTR   &@.0,&@.0           LENGTH > 0?\n.LDONE   BNP   X&#.RET             NO, EXIT\n         LA    &@.14,256           YES, GET MAX SINGLE EXECUTE LENGTH\nX&#.LP   CR    &@.14,&@.0          LENGTH NEARLY EXHAUSTED YET?\n         BNH   X&#.EX              NO, GO EXECUTE MAX LENGTH\n         LR    &@.14,&@.0          YES, GET LAST EXECUTE LENGTH\nX&#.EX   BCTR  &@.14,0             CONVERT LENGTH TO MACHINE LENGTH\n         EX    &@.14,X&#.XXC       EXECUTE THE FUNCTION\n         AIF   ('&OP' NE 'TRT' AND '&OP' NE 'CLC').TSTSKIP\n         BNE   X&#.RET             INEQUALITY; GO RETURN TO CALLER\n.TSTSKIP LA    &@.14,1(,&@.14)     RESTORE ORIGINAL LENGTH\n         AR    &@.15,&@.14         ADVANCE SINK REGISTER\n         AIF   ('&OP' EQ 'TRT' OR '&OP' EQ 'TR').NOINCR\n         AR    &@.1,&@.14          ADVANCE SOURCE REGISTER\n.NOINCR  SR    &@.0,&@.14          DECRIMENT THE LENGTH; DONE YET?\n         BP    X&#.LP              NO, KEEP LOOPING\n         AIF   ('&OP' NE 'TRT' OR NOT &LOADR1).NOTTRTX\n         L     &@.1,&SAVEA+12      YES, TRT MISSED; INSURE R1 RESTORED\n.NOTTRTX ANOP\n&RE      SETA  1\n         AIF   ('&OP' NE 'TRT').GOTRE\n&RE      SETA  0\n.GOTRE   ANOP\nX&#.RET  LM    &@.14,&@&RE,&SAVEA  RESTORE REGISTERS\n         AIF   ('&MF(2)' EQ '').BR14\n         AIF   ('&MF(2)' EQ '*').BEND\n         AIF   ('&MF(2)'(1,1) EQ '(').BREG\n         B     &MF(2)              EXIT\n         AGO   .DATA\n.BR14    BR    &@.14               RETURN\n         AGO   .DATA\n.BEND    B     X&#.END             EXIT\n         AGO   .DATA\n.BREG    #TEST DCODE=&MF(2)\n         BR    &#TESRET(2)         RETURN\n.DATA    AIF   ('&SVID(1)' NE '').NOSAVEA\nX&#.SVA  DS    4A                  REGISTER SAVE AREA\n.NOSAVEA AIF   (NOT &LOADR1).TRTRTO\nX&#.XXC  &OP   0(*-*,&@.15),0(&@.1) (EXECUTED)\n         AGO   .ENDTST\n.TRTRTO  ANOP\nX&#.XXC  &OP   0(*-*,&@.15),&FZ&F(&FDI)&FLP&F(&FRI)&FRP (EXECUTED)\n.ENDTST  AIF   ('&MF(2)' NE '*').MEND\nX&#.END  DS    0H\n         AGO   .MEND\n.XXC     ANOP\n&C       SETC  T'&L(1)\n         AIF   ('&C' NE 'O').GOTLEN\n&C       SETC  T'&T(&TDI)\n         AIF   ('&C' EQ 'M' OR '&C' EQ 'N' OR '&C' EQ 'O' OR '&C' EQ 'T*\n               ' OR '&C' EQ 'U' OR '&C' EQ 'W' OR '&C' EQ '$').NOLNGTH\n&A       SETA  L'&T(&TDI)\n         AIF   (&A GT 256).LONGMVC\n.NOLNGTH ANOP\n&N       &OP   &TZ&T(&TDI)&TLP&TC&T(&TRI)&TRP,&FZ&F(&FDI)&FLP&F(&FRI)&F*\n               RP\n         AGO   .MEND\n.GOTLEN  AIF   ('&C' NE 'N').SHORTMV\n&A       SETA  &L(1)\n         AIF   (&A GT 256).LONGMVC\n.SHORTMV ANOP\n&A       SETA  1\n         AIF   (K'&L(2) EQ 0).SHORT2\n&A       SETA  2\n.SHORT2  ANOP\n&N       &OP   &TZ&T(&TDI)(&L(&A)&TC&T(&TRI)),&FZ&F(&FDI)&FLP&F(&FRI)&F*\n               RP\n         AGO   .MEND\n.LONGMVC ANOP\n&N       &OP   &TZ&T(&TDI)&CD1.(256&TC&T(&TRI)),&FZ&F(&FDI)&CD2&FLP&F(&*\n               FRI)&FRP\n&N       SETC  ''\n         AIF   ('&OP' NE 'TRT' AND '&OP' NE 'CLC').NOTEST\n         BNE   X&#.END\n.NOTEST  ANOP\n&A       SETA  &A-256\n&D1      SETA  &D1+256\n&CD1     SETC  '+'.'&D1'\n         AIF   ('&OP' EQ 'TR' OR '&OP' EQ 'TRT').TROP\n&CD2     SETC  '&CD1'\n.TROP    AIF   (&A GT 256).LONGMVC\n         AIF   (K'&L(2) EQ 0).LAST2\n         &OP   &TZ&T(&TDI)&CD1.(&L(2)-&D1&TC&T(&TRI)),&FZ&F(&FDI)&CD2&F*\n               LP&F(&FRI)&FRP\n         AGO   .LAST1\n.LAST2   &OP   &TZ&T(&TDI)&CD1.(&A&TC&T(&TRI)),&FZ&F(&FDI)&CD2&FLP&F(&F*\n               RI)&FRP\n.LAST1   AIF   ('&OP' NE 'CLC' AND '&OP' NE 'TRT').MEND\nX&#.END  DS    0H\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE408": {"ttr": 3335, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04]\\x00\\x11\\x01\\x165o\\x01\\x165o\\x15\\x05\\x00P\\x00P\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf3@@@'", "ispf": {"version": "04.93", "flags": 0, "createdate": "2016-12-21T00:00:00", "modifydate": "2016-12-21T15:05:11", "lines": 80, "newlines": 80, "modlines": 0, "user": "CBT-493"}, "text": "//***FILE 408 contains copies of Dave Cole's MACLIB, which          *   FILE 408\n//*           are needed to assemble the following programs.        *   FILE 408\n//*                                                                 *   FILE 408\n//*                   DYNABLDL   ON   FILE 407                      *   FILE 408\n//*                   XREFASM    ON   FILE 162                      *   FILE 408\n//*                   SCHEDULE   ON   FILE 388                      *   FILE 408\n//*                   COMPRSEQ   ON   FILE 226                      *   FILE 408\n//*                   OFFLOAD    ON   FILE 225                      *   FILE 408\n//*                                                                 *   FILE 408\n//*     DAVE COLE IS NOW AT COLE SOFTWARE IN CHARLOTTESVILLE, VA.   *   FILE 408\n//*                                                                 *   FILE 408\n//*          Colesoft Marketing, Inc.                               *   FILE 408\n//*          414 3rd ST. NE                                         *   FILE 408\n//*          Charlottesville, VA 22902 USA                          *   FILE 408\n//*          540-456-8210                                           *   FILE 408\n//*          www.colesoft.com                                       *   FILE 408\n//*          email:  dbcole@gmail.com                               *   FILE 408\n//*                                                                 *   FILE 408\n//*    It is preferred that Dave's free software be obtained        *   FILE 408\n//*    from his web site at http://www.colesoft.com/utilities.html  *   FILE 408\n//*    but we are keeping a copy of his updated macro library here  *   FILE 408\n//*    in case somebody is desperate to assemble something, and it  *   FILE 408\n//*    is difficult to get to Dave's web site on a given day, so    *   FILE 408\n//*    see member NEWMACLB which is Dave's new macro library as     *   FILE 408\n//*    of August 2005, in PDSLOAD (IEBUPDTE SYSIN) format.          *   FILE 408\n//*                                                                 *   FILE 408\n//*    Member MOREMACS will probably not be necessary for anything  *   FILE 408\n//*    you need, but it has been included because it includes the   *   FILE 408\n//*    macros necessary to assemble my old copy of Dave's DSCOPY    *   FILE 408\n//*    program.  The new copy is in member NEWSTUFF of File 199,    *   FILE 408\n//*    and preferably, it should be gotten from Dave Cole's web     *   FILE 408\n//*    site.                                                        *   FILE 408\n//*                                                                 *   FILE 408\n//*    Dave Cole has updated most of his contributions, and         *   FILE 408\n//*    they are available for direct download from his web          *   FILE 408\n//*    site at www.colesoft.com.  The following list of             *   FILE 408\n//*    his software is currently available there:                   *   FILE 408\n//*                                                                 *   FILE 408\n//*         Cole Software LLC's File Upload/Download Area           *   FILE 408\n//*                                                                 *   FILE 408\n//*       The following shareware is available for download         *   FILE 408\n//*                                                                 *   FILE 408\n//*      Filename   Platform            Description                 *   FILE 408\n//*    asm2zap.zip   z/OS      A utility for converting an          *   FILE 408\n//*                            assembly listing into SUPERZAP       *   FILE 408\n//*                            cards.                               *   FILE 408\n//*                                                                 *   FILE 408\n//*    blksptrk.zip  z/OS      A TSO command that computes and      *   FILE 408\n//*                            displays track capacities for any    *   FILE 408\n//*                            IBM DASD device for any BLKSIZE,     *   FILE 408\n//*                            with or without key fields.          *   FILE 408\n//*                                                                 *   FILE 408\n//*    dscopy.zip    z/OS      A flexible program for copying       *   FILE 408\n//*                            any number of sequential files       *   FILE 408\n//*                            in a single jobstep.                 *   FILE 408\n//*                                                                 *   FILE 408\n//*    macros.zip    z/OS      A set of Assembler/390 macros        *   FILE 408\n//*                            needed for assembling the various    *   FILE 408\n//*                            programs available from Cole         *   FILE 408\n//*                            Software LLC.                        *   FILE 408\n//*                                                                 *   FILE 408\n//*    schedrun.zip  z/OS      A set of MVS programs for            *   FILE 408\n//*                            scheduling the execution of System   *   FILE 408\n//*                            Operator Commands on an interval     *   FILE 408\n//*                            or calander basis. Can be used to    *   FILE 408\n//*                            control production scheduling.       *   FILE 408\n//*                                                                 *   FILE 408\n//*    xrefasm.zip   z/OS      A pair of programs for producing     *   FILE 408\n//*                            master cross-reference listings      *   FILE 408\n//*                            for multi-assembly programs.         *   FILE 408\n//*                                                                 *   FILE 408\n//*           Colesoft Marketing, Inc.                              *   FILE 408\n//*           414 3rd ST. NE                                        *   FILE 408\n//*           Charlottesville, VA 22902 USA                         *   FILE 408\n//*           540-456-8210                                          *   FILE 408\n//*           www.colesoft.com                                      *   FILE 408\n//*           email:  dbcole@gmail.com                              *   FILE 408\n//*                                                                 *   FILE 408\n//*    Cole Software          Web Page: http://www.colesoft.com     *   FILE 408\n//*                                                                 *   FILE 408\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GSAMCALL": {"ttr": 3338, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x850/\\x00\\x850/\\x12\\x00\\x00\\xdf\\x00\\xdf\\x00\\x00\\xd6\\xd3\\xc4\\xd4\\xc1\\xc3\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-10-29T00:00:00", "modifydate": "1985-10-29T12:00:00", "lines": 223, "newlines": 223, "modlines": 0, "user": "OLDMACS"}, "text": "         MACRO\n&LABEL   GSAMCALL &VERB,                                               *\n               &MF=,                                                   *\n               &POOL=,                                                 *\n               &FILE=,                                                 *\n               &OPTIONS=,                                              *\n               &BUFFER=,                                               *\n               &BUFFLEN=,                                              *\n               &RECLEN=,                                               *\n               &MSGAREA=,                                              *\n               &RBA=,                                                  *\n               &PASS=\n.************************************************************\n.*                                                          *\n.* MACRO NAME = GSAMCALL                                    *\n.*                                                          *\n.* DESCRIPTIVE NAME = FAKE GSAM CALL MACRO.                 *\n.*                                                          *\n.* FUNCTION = MODIFIES A GSB AND \"BALR\"S TO A GSAM          *\n.*            SIMULATION ROUTINE WHICH TRANSLATES THE GSAM  *\n.*            CALL INTO A SIMPLE VSAM CALL.                 *\n.*                                                          *\n.* PROCESSOR = ASSEMBLER XF                                 *\n.*                                                          *\n.* DATA AREAS = GSB                                         *\n.*                                                          *\n.************************************************************\n         LCLC  &SET\n         LCLC  &RESET\n         LCLA  &I,&GSAMSVC\n         LCLB  &ZERO\n         LCLC  &R\n.************************************************************\n.*       CHANGE THE FOLLOWING LINE IF A DIFFERENT SVC       *\n.*       NUMBER IS ASSIGNED AT YOUR INSTALLATION            *\n.************************************************************\n&GSAMSVC SETA  999                 IMPLIES GSAM NOT AVAILABLE\n         AIF   (K'&LABEL EQ 0).NOLAB\n&LABEL   DS    0H\n.NOLAB   ANOP\n.*       LOCATE THE GSB\n         AIF   ('&MF(1)' NE 'E').BADMF\n         AIF   ('&MF(2)' EQ '').BADMF\n         AIF   ('&MF(2)' EQ '(1)').GOTMF\n         IHBSETR &MF(2),1\n.GOTMF   ANOP\n.*       PROCESS OPTIONS LOOP\n&I       SETA  1\n.OPTLOOP AIF   ('&OPTIONS(&I)' EQ '').ENDOPT\n         AIF   ('&OPTIONS(&I)' NE 'RESET').NZERO\n&ZERO    SETB  (1)\n         AGO   .NEXTOPT\n.NZERO   AIF   ('&OPTIONS(&I)' NE 'INITIAL').NA1\n         MVC   GSBID-GSB(4,1),=CL4'GSB'\n         XC    4(GSBLEN-4,1),4(1)\n&ZERO    SETB  (1)\n         AGO   .NEXTOPT\n.NA1     AIF   ('&OPTIONS(&I)' NE 'WAIT').NA2\n&SET     SETC  '&SET+GSBWAIT'\n         AGO   .NEXTOPT\n.NA2     AIF   ('&OPTIONS(&I)' NE 'NOWAIT').NB1\n&RESET   SETC  '&RESET-GSBWAIT'\n         AGO   .NEXTOPT\n.NB1     AIF   ('&OPTIONS(&I)' NE 'UPDATE').NB2\n&SET     SETC  '&SET+GSBUPD'\n         AGO   .NEXTOPT\n.NB2     AIF   ('&OPTIONS(&I)' NE 'NOUPDATE').NC1\n&RESET   SETC  '&RESET-GSBUPD'\n         AGO   .NEXTOPT\n.NC1     AIF   ('&OPTIONS(&I)' NE 'ASYNC').NC2\n&SET     SETC  '&SET+GSBASYNC'\n         AGO   .NEXTOPT\n.NC2     AIF   ('&OPTIONS(&I)' NE 'SYNC').ND1\n&RESET   SETC  '&RESET-GSBASYNC'\n         AGO   .NEXTOPT\n.ND1     AIF   ('&OPTIONS(&I)' NE 'DIR').ND2\n&SET     SETC  '&SET+GSBDIR'\n         AGO   .NEXTOPT\n.ND2     AIF   ('&OPTIONS(&I)' NE 'SEQ').NE1\n&RESET   SETC  '&RESET-GSBDIR'\n         AGO   .NEXTOPT\n.NE1     AIF   ('&OPTIONS(&I)' NE 'BACK').NE2\n&SET     SETC  '&SET+GSBBACK'\n         AGO   .NEXTOPT\n.NE2     AIF   ('&OPTIONS(&I)' NE 'FWD').NF1\n&RESET   SETC  '&RESET-GSBBACK'\n         AGO   .NEXTOPT\n.NF1     AIF   ('&OPTIONS(&I)' NE 'PTY').NF2\n&SET     SETC  '&SET+GSBPTY'\n         AGO   .NEXTOPT\n.NF2     AIF   ('&OPTIONS(&I)' NE 'NOPTY').NH1\n&RESET   SETC  '&RESET-GSBPTY'\n         AGO   .NEXTOPT\n.NH1     AIF   ('&OPTIONS(&I)' NE 'ABTERM').NH2\n&SET     SETC  '&SET+GSBABTRM'\n         AGO   .NEXTOPT\n.NH2     AIF   ('&OPTIONS(&I)' NE 'NOABTERM').NI1\n&RESET   SETC  '&RESET-GSBABTRM'\n         AGO   .NEXTOPT\n.NI1     AIF   ('&OPTIONS(&I)' NE 'DEBUG').NI2\n&SET     SETC  '&SET+GSBDEBUG'\n         AGO   .NEXTOPT\n.NI2     AIF   ('&OPTIONS(&I)' NE 'NODEBUG').NJ1\n&RESET   SETC  '&RESET-GSBDEBUG'\n         AGO   .NEXTOPT\n.NJ1     MNOTE 8,'GSAM002E INVALID OPTION &OPTIONS(&I)'\n.NEXTOPT ANOP\n&I       SETA  &I+1\n         AGO   .OPTLOOP\n.ENDOPT  ANOP\n.*       NOW EXPAND OUT OPTION BIT SETTING INSTRUCTIONS\n         AIF   (&ZERO).SET2\n         AIF   ('&SET' EQ '').SET1\n&SET     SETC  '&SET'(2,K'&SET-1)\n         OI    GSBFLGS-GSB(1),&SET\n.SET1    AIF   ('&RESET' EQ '').SET3\n         NI    GSBFLGS-GSB(1),X'FF'&RESET\n         AGO   .SET3\n.SET2    AIF   ('&SET' EQ '').SET3\n&SET     SETC  '&SET'(2,K'&SET-1)\n         MVI   GSBFLGS-GSB(1),&SET\n.SET3    ANOP\n         AIF   ('&POOL' EQ '').NOPOOL\n&R       SETC  '&POOL(1)'\n         AIF   ('&R' NE '&POOL').GOTPOOL\n         LA    15,&POOL\n&R       SETC  '15'\n.GOTPOOL ANOP\n         STH   &R,GSBPOOL-GSB(,1)\n.NOPOOL  AIF   ('&FILE' EQ '').NOFILE\n         AIF   ('&FILE'(1,1) NE '''').GETFILE\n         MVC   GSBFILE-GSB(8,1),=CL8&FILE\n         AGO   .NOFILE\n.GETFILE ANOP\n&R       SETC  '&FILE(1)'\n         AIF   ('&R' NE '&FILE').GOTFILE\n         LA    15,&FILE\n&R       SETC  '15'\n.GOTFILE ANOP\n         MVC   GSBFILE-GSB(8,1),0(&R)\n.NOFILE  AIF   ('&BUFFER' EQ '').NOBUF\n&R       SETC  '&BUFFER(1)'\n         AIF   ('&R' NE '&BUFFER').GOTBUF\n         AIF   ('&BUFFER' NE '-1').GETBUF\n         SR    15,15\n         BCTR  15,0\n         AGO   .GETBUF2\n.GETBUF  ANOP\n         LA    15,&BUFFER\n.GETBUF2 ANOP\n&R       SETC  '15'\n.GOTBUF  ANOP\n         ST    &R,GSBBUFA-GSB(,1)\n.NOBUF   AIF   ('&BUFFLEN' EQ '').NOBUFL\n&R       SETC  '&BUFFLEN(1)'\n         AIF   ('&R' NE '&BUFFLEN').GOTBUFL\n         LA    15,&BUFFLEN\n&R       SETC  '15'\n.GOTBUFL ANOP\n         ST    &R,GSBBUFL-GSB(,1)\n.NOBUFL  AIF   ('&RECLEN' EQ '').NORECL\n&R       SETC  '&RECLEN(1)'\n         AIF   ('&R' NE '&RECLEN').GOTRECL\n         LA    15,&RECLEN\n&R       SETC  '15'\n.GOTRECL ANOP\n         ST    &R,GSBRECL-GSB(,1)\n.NORECL  AIF   ('&MSGAREA' EQ '').NOMSG\n&R       SETC  '&MSGAREA(1)'\n         AIF   ('&R' NE '&MSGAREA').GOTMSG\n         LA    15,&MSGAREA\n&R       SETC  '15'\n.GOTMSG  ANOP\n         ST    &R,GSBMSGA-GSB(,1)\n.NOMSG   AIF   ('&RBA' EQ '').NORBA\n&R       SETC  '&RBA(1)'\n         AIF   ('&R' NE '&RBA').GOTRBA\n         LA    15,&RBA\n&R       SETC  '15'\n.GOTRBA  ANOP\n         MVC   GSBRBA-GSB(4,1),0(&R)\n.NORBA   AIF   ('&PASS' EQ '').NOPASS\n&R       SETC  '&PASS(1)'\n         AIF   ('&R' NE '&PASS').GOTPASS\n         LA    15,&PASS\n&R       SETC  '15'\n.GOTPASS ANOP\n         ST    &R,GSBPASSW-GSB(,1)\n.NOPASS  AIF   ('&VERB' EQ 'MODIFY').EXIT\n         AIF   ('&VERB' NE 'READ').NREAD\n         SR    0,0                 INDICATE READ\n         AGO   .SVC\n.NREAD   AIF   ('&VERB' NE 'WRITE').NWRITE\n         LA    0,1                 INDICATE WRITE\n         AGO   .SVC\n.NWRITE  AIF   ('&VERB' NE 'REWRITE').NREWRIT\n         LA    0,2                 INDICATE REWRITE\n         AGO   .SVC\n.NREWRIT AIF   ('&VERB' NE 'DELETE').NDEL\n         LA    0,3                 INDICATE DELETE\n         AGO   .SVC\n.NDEL    AIF   ('&VERB' NE 'RELEASE').NRLSE\n         LA    0,4                 INIDCATE RELEASE\n         AGO   .SVC\n.NRLSE   AIF   ('&VERB' NE 'MONITOR').NMON\n         LA    0,5                 INDICATE MONITOR\n         AGO   .SVC\n.NMON    AIF   ('&VERB' NE 'MAINTAIN').NMAINT\n         LA    0,6                 INDICATE MAINTAIN\n         AGO   .SVC\n.NMAINT  AIF   ('&VERB' NE 'FINISH').VERBERR\n         LA    0,7\n         AGO   .SVC\n.VERBERR MNOTE 8,'GSAM001E UNRECOGNIZED VERB: &VERB'\n.SVC     AIF   (&GSAMSVC GT 255).FAKEIT\n         SVC   &GSAMSVC            ISSUE SVC\n         MEXIT\n.FAKEIT  ANOP\n         L     R15,=V(FAKEGSAM)    --> SUBSTITUTE ROUTINE\n         BALR  R14,R15             GO PERFORM THE VSAM I/O\n         MEXIT\n.BADMF   MNOTE 8,'GSAM003E IMPROPER OR OMITTED ''MF'' PARAMETER'\n.EXIT    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GSB": {"ttr": 3585, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x850/\\x00\\x850/\\x12\\x00\\x00\\x9a\\x00\\x9a\\x00\\x00\\xd6\\xd3\\xc4\\xd4\\xc1\\xc3\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-10-29T00:00:00", "modifydate": "1985-10-29T12:00:00", "lines": 154, "newlines": 154, "modlines": 0, "user": "OLDMACS"}, "text": "         MACRO\n         GSB   &DSECT=YES\n.************************************************************\n.*                                                          *\n.* MACRO NAME = GSB                                         *\n.*                                                          *\n.* DESCRIPTIVE NAME = GSAM SIMULATION ROUTINE'S PARAMETER   *\n.*                    BLOCK.                                *\n.*                                                          *\n.* PROCESSOR = ASSEMBLER XF                                 *\n.*                                                          *\n.************************************************************\n*************************************************************\n*                                                           *\n*        GSB -- GSAM SVC PARAMETER BLOCK                    *\n*                                                           *\n*************************************************************\n         SPACE 1\n         IEZBITS ,\n         AIF   ('&DSECT' NE 'YES').NODSECT\nGSB      DSECT ,\n         AGO   .YESDSEC\n.NODSECT ANOP\nGSB      DS    0F                  ALIGNMENT\n.YESDSEC ANOP\nGSBID    DC    CL4'GSB'            MUST BE FILLED IN\nGSBFILE  DS    CL8                 FILE NAME DEFINED TO GSRTASK\nGSBPOOL  DS    H                   VALUES 0-7. KEY OF GSR POOL.\nGSBFLGW  DS    0H                  OPTION BITS FOR USER -\nGSBFLG1  DS    X                    IN HALFWORD SO THEY CAN -\nGSBFLGS  DS    X                     BE SET IN FORTRAN AND COBOL\nGSBWAIT  EQU   BIT0                INDICATION THAT USER\n*                                  WANTS TO WAIT FOR A\n*                                  RECORD. APPLICABLE ONLY\n*                                  IF UPDATE INDICATOR SET.\nGSBUPD   EQU   BIT1                USER WANTS TO UPDATE THE\n*                                  RECORD. GSAM WILL OBTAIN\n*                                  OWNERSHIP OF THE RECORD\nGSBASYNC EQU   BIT2                THE USER WANTS TO\n*                                  ASYNCHRONOUSLY CONTEND FOR\n*                                  RECORD OWNERSHIP.\n*                                  GSBUPD MUST BE ON,\n*                                  GSBWAIT MUST BE OFF\nGSBDIR   EQU   BIT3                THIS IS A DIRECT REQUEST.\n*                                  FOR A KSDS, A KEY IS IN\n*                                  THE BUFFER. OTHERWISE, IT\n*                                  IS IN GSBRBA.\nGSBBACK  EQU   BIT4                THIS IS A 'BACKWARDS'\n*                                  OPERATION. THE USER WANTS\n*                                  TO SEQUENTIALLY READ RECORDS\n*                                  IN DESCENDING ORDER OF KEY OR\n*                                  ADDRESS. GSBDIR MUST BE OFF.\nGSBPTY   EQU   BIT5                PRIORITY REQUEST. CALLER\n*                                  MUST BE IN SYSTEM KEY OR\n*                                  SUPERVISOR STATE. UPDATE BIT\n*                                  MUST BE ON. CALLER WILL\n*                                  STEAL RECORD OWNERSHIP FROM\n*                                  ANYONE WHO HOLDS IT.\nGSBABTRM EQU   BIT6                ABEND MY TASK WHEN GSAM\n*                                  GOES DOWN OR THIS FILE IS\n*                                  PURGED\nGSBDEBUG EQU   BIT7                INVOKE DBC (REQUIRES AUTH\n*                                  LEVEL 2 AND DEBUG FLAG)\nGSBINDX  DS    H                   INDEX OF OUR GSAM PLACEHOLDER\n*                                  SET TO ZERO BEFORE FIRST CALL\n*                                  USER MUST NOT SUBSEQUENTLY\n*                                  MODIFY THIS FIELD\nGSBRSV1  DS    H                   RESERVED\nGSBBUFL  DS    F                   TOTAL LENGTH OF BUFFER WHOSE\n*                                  ADDRESS IS SPECIFIED IN GSBBUFA.\n*                                  SPECIFIED BY USER.\n*                                  ON A READ REQUEST, BUFFER IS\n*                                  PADDED WITH BLANKS FOR A LENGTH OF\n*                                  GSBBUFL.\n*                                  CANNOT BE GREATER THAN INSTALLATION\n*                                  SPECIFIED MAX.\nGSBBUFA  DS    A                   -> USER BUFFER FOR READS, REWRITES,\n*                                  DELETES.\n*                                  IF F'-1' THEN THE MSG AREA & BUFFER\n*                                  FOLLOW THE GSB (FOR LANGUAGES THAT\n*                                  DO NOT SUPPORT THE PTR DATA TYPE)\nGSBRECL  DS    A                   FOR READ, LENGTH OF BUFFER RETURNED\n*                                  TO USER. FOR REWRITE, WRITE, LENGTH\n*                                  OF RECORD, SUPPLIED BY USER.\n*                                  MUST BE >0, <=GSBBUFL\nGSBMSGA  DS    A                   ->128 BYTE AREA FOR RETURNING I/O\n*                                  ERROR MESSAGES, OR NULL.\nGSBVSAM  DS    F                   VSAM FEEDBACK CODE THAT CAUSED\n*                                  THE SVC'S NON-0 RETURN CODE. 0 IF\n*                                  NONE APPLIES.\n*                                  OR, ON SUCCESSFUL COMPLETION,\n*                                  THE VSAM FEEDBACK CODE FOR 0\n*                                  RETURN CODE. (SEE VSAM MANUAL).\nGSBVSFN  DS    F                   VSAM FUNCTION CODE ON LOGICAL\n*                                  OR PHYSICAL ERROR. -1 WHEN NONE\n*                                  APPLIES.\nGSBECB   DS    A                   ECB WHICH WILL BE POSTED\n*                                  WHEN ASYNCHRONOUS REQUEST FOR\n*                                  RECORD OWNERSHIP COMPLETES\nGSBRBA   DS    F                   RBA OF RECORD FOR READ, REWRITE,\n*                                  WRITE (RETURNED BY SVC).\n*                                  ONLY TRUE WHEN GSBPATH IS OFF\n*                                  RBAS ARE NOT RETURNED BY VSAM FOR\n*                                  A PATH.\nGSBPASSW DS    CL8                 PASSWORD-FOR EXAMINATION BY\n*                                  INSTALLATION EXITS\n*        THE GSBFIL.. FIELDS ARE RETURNED TO THE USER\n*        WHENEVER THE GSAM FILE SPECIFIED IS FOUND BY THE SVC.\nGSBFILKL DS    F                   KEY LENGTH OF FILE. 0 FOR ESDS.\nGSBFILKO DS    F                   KEY OFFSET IN RECS. 0 FOR ESDS.\n*                                  0-INDEXED.\nGSBFILRL DS    F                   MAXINUM RECORD LENGTH FOR THE FILE.\nGSBFILCL DS    F                   CONTROL INTERVAL LENGTH OF FILE\n*                                  (RETURNED W/ OTHER GSBFIL.. FIELDS)\nGSBFILAC DS    C                   ACCESS CODE OF FILE\n*                                  RETURNED WITH OTHER GSBFIL.. INFO\nGSBACC1  EQU   C'1'                READ-ONLY ACCESS.\nGSBACC2  EQU   C'2'                UPDATE ACCESS.\nGSBACC3  EQU   C'3'                WRITE-ONLY,TO AN ESDS.\nGSBFILFG DS    C                   FLAGS RETURNED,DESCRIBING FILE\n*                                  (ALONG WITH OTHER GSBFIL.. FIELDS)\nGSBRD    EQU   C'R'                READ ONLY\nGSBWT    EQU   C'W'                WRITE ONLY\nGSBRDWT  EQU   C'*'                FULL ACCESS\nGSBNO    EQU   C'C'                NO ACCESS\nGSBLEN   EQU   *-GSB\n         SPACE 3\n*************************************************************\n* OPTIONAL FIELDS (IF GSBBUFA IS F'-1')                     *\n*************************************************************\n         SPACE 1\nGSBMSGX  DS    CL128               CONTIGUOUS MESSAGE AREA\nGSBBUFX  DS    0C                  CONTIGUOUS BUFFER.\n         SPACE 3\n*************************************************************\n*        RETURN CODES TO CALLER OF GSAM SVC:                *\n*        (NOTE THAT MEANINGS OF RETURN CODES DEPEND ON      *\n*        THE VSAM RETURN CODE-GSBVSAM).                     *\n*************************************************************\n         SPACE 1\nGSAMEKEY EQU   4                   KEY OR ENDFILE CONDITION\nGSAMEREC EQU   8                   RECORD CONDITION\nGSAMENAV EQU   12                  SOME GSR OBJECT UNAVAILABLE\nGSAMEFIL EQU   16                  UNDEFINEDFILE CONDITION.\nGSAMEPOS EQU   20                  POSITIONING ERROR.\nGSAMEDS  EQU   24                  DATASET FULL OR BAD.\nGSAMEAUT EQU   28                  AUTHORIZATION ERROR.\nGSAMEACC EQU   32                  WRONG KIND OF ACCESS FOR THISFILE.\nGSAMECOR EQU   36                  NOT ENOUGH CORE AVAILABLE.\nGSAMEPRM EQU   40                  PARMS BAD OR INCONSISTANT.\nGSAMEIO  EQU   44                  I/O PHYSICAL ERROR\nGSAMEBUG EQU   48                  BUG IN THE SVC\nGSAMEUBG EQU   52                  BUG IN INSTALLATION EXIT\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MOREMACS": {"ttr": 3589, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x05\"\\x0f\\x01\\x05\"\\x0f\\x08\\x11\\x1e\\xa7\\x1e\\xa7\\x00\\x00\\xe5\\xc5\\xd9\\xe8\\xd6\\xd3\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-08-08T00:00:00", "modifydate": "2005-08-08T08:11:00", "lines": 7847, "newlines": 7847, "modlines": 0, "user": "VERYOLD"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "NEWMACLB": {"ttr": 6666, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x05\"\\x0f\\x01\\x05\"\\x0f\\x07\\x06%\\x88%\\x88\\x00\\x00\\xd5\\xc5\\xe6\\xd4\\xc1\\xc3\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-08-08T00:00:00", "modifydate": "2005-08-08T07:06:00", "lines": 9608, "newlines": 9608, "modlines": 0, "user": "NEWMACS"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "SFR": {"ttr": 10756, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x850/\\x00\\x850/\\x12\\x00\\x00|\\x00|\\x00\\x00\\xd6\\xd3\\xc4\\xd4\\xc1\\xc3\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-10-29T00:00:00", "modifydate": "1985-10-29T12:00:00", "lines": 124, "newlines": 124, "modlines": 0, "user": "OLDMACS"}, "text": "         MACRO\n&NME     SFR   &MF=D\n         LCLC  &D\n         AIF   ('&MF(1)' EQ 'L').MFL\n         AIF   ('&MF(1)' EQ 'D').MFD\n         MNOTE 8,'MF(1)=&MF(1) IS INVALID. MF(1)=D IS ASSUMED.'\n.MFD     ANOP\n&D       SETC  'DSECT'\n         AIF   ('&MF(2)' EQ '').MFDOK3\n         AIF   ('&MF(2)'(1,1) EQ 'Y').MFDOK3\n&D       SETC  'DS'\n         AIF   ('&MF(2)'(1,1) EQ 'N').MFDOK3\n         MNOTE 8,'MF=&MF IS INVALID. MF=(&MF(1),N) IS ASSUMED.'\n.MFDOK3  ANOP\n*************************************************************\n*                                                           *\n*        SFR -- SCHEDULE FILE RECORD                        *\n*                                                           *\n*        A NEW SCHEDULE FILE CAN BE ALLOCATED VIA AN AMS    *\n*        COMMAND SUCH AS THE FOLLOWING:                     *\n*                                                           *\n*        DEF CL(NAME('SYSVSAM.SCHEDULE') VOL(SYSRES) -      *\n*            ATT(3) CODE(SCHEDULE) ERAS KEYS(12 0) -        *\n*            OWNER(DAVECOLE) TO(99365) UNQ MRPW(XYZZY) -    *\n*            RDPW(SCHEDULE)) -                              *\n*                                                           *\n*            DATA(NAME('SYSVSAM.SCHEDULE.DATA')-            *\n*            RECORDS(1000 100) RECSZ(X'48' X'12D')) -       *\n*                                                           *\n*            INDEX(NAME('SYSVSAM.SCHEDULE.INDEX'))          *\n*                                                           *\n*************************************************************\n         SPACE 1\n         AIF   ('&NME' EQ '').MFDOK1\n&NME     &D    0H\nSFR      DS    0H                  MAP NAME\n         AGO   .MFDOK2\n.MFDOK1  ANOP\nSFR      &D    0H\n.MFDOK2  ANOP\nSFRYR    DS    H                   SCHEDULED YEAR\nSFRMO    DS    H                   SCHEDULED MONTH\nSFRDY    DS    H                   SCHEDULED DAY\nSFRYMD   EQU   SFRYR,*-SFRYR       DATE SEGMENT\nSFRHR    DS    H                   SCHEDULED HOUR\nSFRMN    DS    H                   SCHEDULED MINUTE\nSFRHM    EQU   SFRHR,*-SFRHR       TIME-OF-DAY SEGMENT\nSFRTIME  EQU   SFRYR,*-SFRYR       SCHEDULED TIME\nSFRID    DS    H                   UNIQUE IDENTIFICATION NUMBER\nSFRKEY   EQU   SFRYR,*-SFRYR       RECORD'S KEY FIELD\nSFRNAME  DS    CL8                 APPLICATION NAME\n         SPACE 1\nSFRWK    DS    H                   SCHEDULED DAY OF THE WEEK\n         SPACE 1\nSFRXYR   DS    H                   YEAR OF LAST EXECUTION\nSFRXMO   DS    H                   MONTH OF LAST EXECUTION\nSFRXDY   DS    H                   DAY OF LAST EXECUTION\nSFRXYMD  EQU   SFRXYR,*-SFRXYR     DATE SEGMENT\nSFRXHR   DS    H                   HOUR OF LAST EXECUTION\nSFRXMN   DS    H                   MINUTE OF LAST EXECUTION\nSFRXHM   EQU   SFRXHR,*-SFRXHR     TIME-OF-DAY SEGMENT\nSFRXTIME EQU   SFRXYR,*-SFRXYR     LAST EXECUTION TIME\n         SPACE 1\nSFRWHR   DS    H                   LENGTH OF EXECUTION WINDOW: HOURS\nSFRWMN   DS    H                   LENGTH OF EXECUTION WINDOW: MINUTES\n         SPACE 1\nSFRSYSID DS    CL4                 SMF-SYSID OF SYSTEM ON WHICH THIS\n*                                  COMMAND MAY BE EXECUTED. X'0000'\n*                                  IMPLIES \"ANY\" SYSTEM.\n         SPACE 1\nSFRFLAG  DS    B                   FLAG BYTE\nSFRFIPLF EQU   B'10000000'         FORCE REEXECUTION OF THIS COMMAND\n*                                  IF AN IPL OCCURS WITHIN THE CURRENT\n*                                  WINDOW EVEN IF THIS COMMAND HAS\n*                                  ALREADY BEEN EXECUTED IN THIS SAME\n*                                  WINDOW.\nSFRFOVRD EQU   B'01000000'         THIS COMMAND OVERRIDES ALL OTHER\n*                                  COMMANDS FOR THIS APPLICATION FOR\n*                                  THIS DATE FOR WHICH THIS FLAG IS\n*                                  OFF.\nSFRFOBSO EQU   B'00100000'         THIS COMMAND IS OBSOLETE. (SET BY\n*                                  SCHEDRUN. CHECKED BY SCHEDULE).\n         SPACE 1\nSFRCMDL  DS    2H                  L'COMMAND TEXT, ZERO\nSFRCMD   DS    CL255               COMMAND TEXT\n         SPACE 1\nSFREND   EQU   *                   MAX END OF SFR\nSFRLEN   EQU   SFREND-SFR          MAX L'SFR\n         SPACE 3\n*************************************************************\n*        SCHEDULE FILE'S MASTER RECORD                      *\n*************************************************************\n         SPACE 1\n         ORG   SFR                 LOCATE TO START OF BUFFER\nSFMR     DS    0H\nSFMRKEY  DS    XL(L'SFRKEY)      | KEY (ALL HEX-FF)\nSFMRFID  DC    CL8'SCHEDULE'     V FILE ID\nSFMRNXID DS    H                   NEXT DATA RECORD ID VALUE\nSFMREND  EQU   *                   EO-SFMR\nSFMRLEN  EQU   SFMREND-SFMR        L'SFMR\n         ORG   SFREND              RELOCATE HIGH\n         MEXIT\n.*\n.MFL     AIF   ('&MF(2)' EQ '').MFLD\n         AIF   ('&MF(2)'(1,1) EQ 'M').MFLM\n         MNOTE 8,'MF=&MF IS INVALID. MF=L IS ASSUMED'\n.MFLD    ANOP\n&NME     DS    0H\n         DC    5H'0'               SCHEDULED TIME\n         DC    2H'0'               SFRID, SFRWK\n         DC    5H'0'               LAST EXECUTION TIME\n         DC    2H'0'               EXECUTION WINDOW\n         DC    CL4' '              APPLICATION NAME\n         DC    B'00000000'         FLAG BYTE\n         DC    2H'0'               SFRCMDL\n         DC    CL255' '            SFRCMD\n         MEXIT\n.*\n.MFLM    ANOP\n&NME     DS    0H\n         DC    (L'SFMRKEY)X'FF'    SFMRKEY\n         DC    CL(L'SFMRFID)'SCHEDULE' SFMRFID\n         DC    H'0'                SFMRNXID\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SSSHIPE": {"ttr": 10759, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x850/\\x00\\x850/\\x12\\x00\\x00\\x86\\x00\\x86\\x00\\x00\\xd6\\xd3\\xc4\\xd4\\xc1\\xc3\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-10-29T00:00:00", "modifydate": "1985-10-29T12:00:00", "lines": 134, "newlines": 134, "modlines": 0, "user": "OLDMACS"}, "text": "         MACRO\n&NME     SSSHIPE &IID=,&IADR=,&IDA=,&SVC#=,&PRIO=,&MF=D\n         LCLC  &LIID,&LIADR,&LIDA,&LSVC#,&LPRIO,&LBL,&R,&D\n&LIID    SETC  '*'\n         AIF   ('&IID' EQ '').GOTIID\n&LIID    SETC  '&IID'\n         AIF   ('&IID'(1,1) NE '''').GOTIID\n&LIID    SETC  ' '\n         AIF   (K'&IID LE 2).GOTIID\n&LIID    SETC  '&IID'(2,K'&IID-2)\n.GOTIID  ANOP\n&LIADR   SETC  '*-*'\n         AIF   ('&IADR' EQ '').GOTIADR\n&LIADR   SETC  '&IADR'\n.GOTIADR ANOP\n&LIDA    SETC  '*-*'\n         AIF   ('&IDA' EQ '').GOTIDA\n&LIDA    SETC  '&IDA'\n.GOTIDA  ANOP\n&LSVC#   SETC  '*-*'\n         AIF   ('&SVC#' EQ '').GOTSVC#\n&LSVC#   SETC  '&SVC#'\n.GOTSVC# ANOP\n&LPRIO   SETC  '128'\n         AIF   ('&PRIO' EQ '').GOTPRIO\n&LPRIO   SETC  '&PRIO'\n.GOTPRIO AIF   ('&MF(1)' EQ 'E').MFE\n         AIF   ('&MF(1)' EQ 'L').MFL\n         AIF   ('&MF(1)' EQ 'D').MFD\n         MNOTE 8,'MF(1)=&MF(1) IS INVALID. MF(1)=D IS ASSUMED.'\n.MFD     ANOP\n&D       SETC  'DSECT'\n         AIF   ('&MF(2)' EQ '').MFDOK3\n         AIF   ('&MF(2)'(1,1) EQ 'Y').MFDOK3\n&D       SETC  'DS'\n         AIF   ('&MF(2)'(1,1) EQ 'N').MFDOK3\n         MNOTE 8,'MF(2)=&MF(2) IS INVALID. MF(2)=N IS ASSUMED.'\n.MFDOK3  ANOP\n*************************************************************\n*                                                           *\n*        SSSHIPE -- INTERCEPT PARAMETER ENTRY. THIS AREA    *\n*        DESCRIBES DATA ASSOCIATED WITH INDIVIDUAL          *\n*        SUB-SCREEN INTERCEPT ROUTINES.                     *\n*                                                           *\n*************************************************************\n         SPACE 1\n         AIF   ('&NME' EQ ' ').MFDOK1\n&NME     &D    0F\nSSSHIPE  DS    0F                  MAP NAME\n         AGO   .MFDOK2\n.MFDOK1  ANOP\nSSSHIPE  &D    0F\n.MFDOK2  ANOP\nSSSHIID  DC    CL8'&LIID'          IDENTIFIER ASSOCIATED WITH THIS\n*                                  INTERCEPT.\nSSSHIADR DC    A(&LIADR)           ADDRESS OF THE INTERCEPT ROUTINE. A\n*                                  ZERO VALUE MEANS THAT THE INTERCEPT\n*                                  DESCRIBED BY THIS IPE IS TO BE\n*                                  DELETED.\nSSSHIDA  DC    A(&LIDA)            VALUE TO BE MADE AVAILABLE TO THE\n*                                  INTERCEPT ROUTINE.\nSSSHSVC# DC    AL1(&LSVC#)         SVC WHICH THIS ROUTINE INTERCEPTS.\nSSSHPRIO DC    AL1(&LPRIO)         PRIORITY AT WHICH THIS INTERCEPT\n*                                  ROUTINE IS QUEUED.\nSSSHCC   DC    FL1'0'              HIGHEST COMPLETION CODE ASSOCIATED\n*                                  WITH THE ATTEMPT TO QUEUE OR DELETE\n*                                  THIS INTERCEPT ROUTINE. MUST BE\n*                                  PRE-ZEROED BY THE CALLER.\nSSSHIEND DS    0F                  END OF THE IPE.\nSSSHILEN EQU   SSSHIEND-SSSHIPE    LENGTH OF THE IPE.\n         MEXIT\n.MFL     ANOP\n&NME     DS    0F\n         DC    CL8'&LIID'          IDENTIFIER ASSOCIATED WITH THIS\n*                                  INTERCEPT\n         DC    A(&LIADR)           ADDRESS OF THE INTERCEPT ROUTINE. A\n*                                  ZERO VALUE MEANS THAT THE INTERCEPT\n*                                  DESCRIBED BY THIS IPE IS TO BE\n*                                  DELETED.\n         DC    A(&LIDA)            VALUE TO BE MADE AVAILABLE TO THE\n*                                  INTERCEPT ROUTINE.\n         DC    AL1(&LSVC#)         SVC WHICH THIS ROUTINE INTERCEPTS.\n         DC    AL1(&LPRIO)         PRIORITY AT WHICH THIS INTERCEPT\n*                                  ROUTINE IS QUEUED.\n         DC    FL1'0'              HIGHEST COMPLETION CODE ASSOCIATED\n*                                  WITH THE ATTEMPT TO QUEUE OR DELETE\n*                                  THIS INTERCEPT ROUTINE. MUST BE\n*                                  PRE-ZEROED BY THE CALLER.\n         MEXIT\n.MFE     ANOP\n&LBL     SETC  '&NME'\n&R       SETC  '1'\n         AIF   ('&MF(2)' NE '').GETMF2\n&LBL     LA    &R,SSSHIPE          --> IPE\n&LBL     SETC  ''\n         AGO   .GOTMF2\n.GETMF2  AIF   ('&MF(2)'(1,1) EQ '(').MF2REG\n&LBL     LA    &R,&MF(2)           --> IPE\n&LBL     SETC  ''\n         AGO   .GOTMF2\n.MF2REG  ANOP\n&R       SETC  '&MF(2)'(2,K'&MF(2)-2)\n.GOTMF2  ANOP\n&LBL     MVI   SSSHCC-SSSHIPE(&R),0 RESET THE COMPLETION CODE\n&LBL     SETC  ''\n         AIF   ('&IID' EQ '').NOIID\n         AIF   (K'&LIID LE 8).LIIDOK\n         MNOTE 4,'IID=&IID IS TOO LONG.'\n.LIIDOK  ANOP\n         MVC   SSSHIID-SSSHIPE(,&R),=CL8'&LIID' SET NEW IID\n.NOIID   AIF   ('&IADR' EQ '').NOIADR\n         AIF   ('&IADR' NE '&IADR(1)').IADRREG\n         LA    0,&IADR             --> INTERCEPT\n         ST    0,SSSHIADR-SSSHIPE(,&R) STORE\n         AGO   .NOIADR\n.IADRREG ST    &IADR(1),SSSHIADR-SSSHIPE(,&R) STORE DATA AREA ADDRESS\n.NOIADR  AIF   ('&IDA' EQ '').NOIDA\n         AIF   ('&IDA' NE '&IDA(1)').IDAREG\n         LA    0,&IDA              --> DATA AREA\n         ST    0,SSSHIDA-SSSHIPE(,&R) STORE\n         AGO   .NOIDA\n.IDAREG  ST    &IDA(1),SSSHIDA-SSSHIPE(,&R) STORE DATA AREA ADDRESS\n.NOIDA   AIF   ('&SVC#' EQ '').NOSVC#\n         AIF   ('&SVC#' NE '&SVC#(1)').SVC#REG\n         MVI   SSSHSVC#-SSSHIPE(&R),&SVC# SET SVC NUMBER\n         AGO   .NOSVC#\n.SVC#REG STC   &SVC#(1),SSSHSVC#-SSSHIPE(,&R) STORE SVC NUMBER\n.NOSVC#  AIF   ('&PRIO' EQ '').NOPRIO\n         AIF   ('&PRIO' NE '&PRIO(1)').PRIOREG\n         MVI   SSSHPRIO-SSSHIPE(&R),&PRIO SET QUEUING PRIORITY\n         AGO   .NOPRIO\n.PRIOREG STC   &PRIO(1),SSSHPRIO-SSSHIPE(,&R) STORE QUEUING PRIORITY\n.NOPRIO  ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SSSHSPE": {"ttr": 10762, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x850/\\x00\\x850/\\x12\\x00\\x00\\x8e\\x00\\x8e\\x00\\x00\\xd6\\xd3\\xc4\\xd4\\xc1\\xc3\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-10-29T00:00:00", "modifydate": "1985-10-29T12:00:00", "lines": 142, "newlines": 142, "modlines": 0, "user": "OLDMACS"}, "text": "         MACRO\n&NME     SSSHSPE &SID=,&SDA=,&TCB=,&FLAG=,&SVC=XXX,&MF=D\n         LCLA  &A1\n         LCLC  &LSID,&LSDA,&LTCB,&LFLAG,&LBL,&R,&D\n&LSID    SETC  '*'\n         AIF   ('&SID' EQ '').GOTSID\n&LSID    SETC  '&SID'\n         AIF   ('&SID'(1,1) NE '''').GOTSID\n&LSID    SETC  ' '\n         AIF   (K'&SID LE 2).GOTSID\n&LSID    SETC  '&SID'(2,K'&SID-2)\n.GOTSID  ANOP\n&LSDA    SETC  '*-*'\n         AIF   ('&SDA' EQ '').GOTSDA\n&LSDA    SETC  '&SDA'\n.GOTSDA  ANOP\n&LTCB    SETC  '0'\n         AIF   ('&TCB' EQ '').GOTTCB\n&LTCB    SETC  '&TCB'\n.GOTTCB  ANOP\n&LFLAG   SETC  '0'\n&A1      SETA  0\n.LP1     AIF   (&A1 EQ N'&FLAG).END1\n&A1      SETA  &A1+1\n&LFLAG   SETC  '&LFLAG+SSSH&FLAG(&A1)'\n         AGO   .LP1\n.END1    AIF   ('&LFLAG' EQ '0').GOTFLAG\n&LFLAG   SETC  '&LFLAG'(3,K'&LFLAG-2)\n.GOTFLAG AIF   ('&MF(1)' EQ 'E').MFE\n         AIF   ('&MF(1)' EQ 'L').MFL\n         AIF   ('&MF(1)' EQ 'D').MFD\n         MNOTE 8,'MF(1)=&MF(1) IS INVALID. MF(1)=D IS ASSUMED.'\n.MFD     ANOP\n&D       SETC  'DSECT'\n         AIF   ('&MF(2)' EQ '').MFDOK3\n         AIF   ('&MF(2)'(1,1) EQ 'Y').MFDOK3\n&D       SETC  'DS'\n         AIF   ('&MF(2)'(1,1) EQ 'N').MFDOK3\n         MNOTE 8,'MF(2)=&MF(2) IS INVALID. MF(2)=N IS ASSUMED.'\n.MFDOK3  ANOP\n*************************************************************\n*                                                           *\n*        SSSHSPE -- SUB-SCREEN PARAMETER ENTRY. THIS AREA   *\n*        CONTAINS DATA THAT IS ASSOCIATED WITH AN ENTIRE    *\n*        SUB-SCREEN.                                        *\n*                                                           *\n*************************************************************\n         SPACE 1\n         AIF   ('&NME' EQ '').MFDOK1\n&NME     &D    0F\nSSSHSPE  DS    0F                  MAP NAME\n         AGO   .MFDOK2\n.MFDOK1  ANOP\nSSSHSPE  &D    0F\n.MFDOK2  ANOP\nSSSHSID  DC    CL8'&LSID'          NAME OF THIS SUB-SCREEN\nSSSHSDA  DC    A(&LSDA)            VALUE TO BE PROVIDED TO ALL\n*                                  INTERCEPT ROUTINES DEFINED UNDER\n*                                  THIS SUB-SCREEN.\nSSSHTCB  DC    A(&LTCB)            IF SSSHFTCB, THEN THE ADDRESS OF THE\n*                                  (FIRST) TCB TO WHICH THIS SUB-SCREEN\n*                                  IS TO BE ASSIGNED.\nSSSHFLAG DC    AL1(&LFLAG)         FLAG BYTE.\n*                                  NOTE, AT LEAST ONE OF SSSHFCRN,\n*                                  SSSHFTCB, OR SSSHFALL MUST BE ON.\n*                                  REDUNDANT BIT SETTINGS ARE ALLOWED.\nSSSHFDEL EQU   B'10000000'         THIS SUB-SCREEN IS TO BE DELETED\n*                                  FROM THE INDICATED TCB'S.\nSSSHFSUB EQU   B'01000000'         THIS SUB-SCREEN IS TO BE PROPAGATED\n*                                  TO OR DELETED FROM ALL SUBTASKS OF\n*                                  THE INDICATED TCB'S.\nSSSHFCRN EQU   B'00100000'         THIS SUB-SCREEN IS TO BE ASSIGNED TO\n*                                  OR DELETED FROM THE CURRENT TCB.\nSSSHFTCB EQU   B'00010000'         THIS SUB-SCREEN IS TO BE ASSIGNED TO\n*                                  OR DELETED FROM THE TCB POINTED TO\n*                                  BY SSSHTCB.\nSSSHFALL EQU   B'00001000'         THIS SUB-SCREEN IS TO BE ASSIGNED TO\n*                                  OR DELETED FROM ALL TCB'S IN THIS\n*                                  ADDRESS SPACE EXCEPT THE FIRST TCB\n*                                  (THE REGION CONTROL TASK'S TCB).\nSSSHSEND DS    0F                  END OF SSSHSPE.\nSSSHSLEN EQU   SSSHSEND-SSSHSPE    LENGTH OF SSSHSPE.\n         AIF   ('&SVC' EQ '').NOSVC\n         SPACE 3\nSSSHSVC  EQU   &SVC                SSSH'S SVC\n.NOSVC   MEXIT\n.MFL     ANOP\n&NME     DS    0F\n         DC    CL8'&LSID'          NAME OF THIS SUB-SCREEN\n         DC    A(&LSDA)            VALUE TO BE PROVIDED TO ALL\n*                                  INTERCEPT ROUTINES DEFINED UNDER\n*                                  THIS SUB-SCREEN.\n         DC    A(&LTCB)            IF SSSHFTCB, THEN THE ADDRESS OF THE\n*                                  (FIRST) TCB TO WHICH THIS SUB-SCREEN\n*                                  IS TO BE ASSIGNED.\n         DC    AL1(&LFLAG)         FLAG BYTE.\n*                                  NOTE, AT LEAST ONE OF SSSHFCRN,\n*                                  SSSHFTCB, OR SSSHFALL MUST BE ON.\n*                                  REDUNDANT BIT SETTINGS ARE ALLOWED.\n         MEXIT\n.MFE     ANOP\n&LBL     SETC  '&NME'\n&R       SETC  '1'\n         AIF   ('&MF(2)' NE '').GETMF2\n&LBL     LA    &R,SSSHSPE          --> SPE\n&LBL     SETC  ''\n         AGO   .GOTMF2\n.GETMF2  AIF   ('&MF(2)'(1,1) EQ '(').MF2REG\n&LBL     LA    &R,&MF(2)           --> SPE\n&LBL     SETC  ''\n         AGO   .GOTMF2\n.MF2REG  ANOP\n&R       SETC  '&MF(2)'(2,K'&MF(2)-2)\n.GOTMF2  AIF   ('&SID' EQ '').NOSID\n         AIF   (K'&LSID LE 8).LSIDOK\n         MNOTE 4,'SID=&SID IS TOO LONG.'\n.LSIDOK  ANOP\n&LBL     MVC   SSSHSID-SSSHSPE(,&R),=CL8'&LSID' SET NEW SID\n&LBL     SETC  ''\n.NOSID   AIF   ('&SDA' EQ '').NOSDA\n         AIF   ('&SDA' NE '&SDA(1)').SDAREG\n&LBL     LA    0,&SDA              --> SDA\n&LBL     SETC  ''\n         ST    0,SSSHSDA-SSSHSPE(,&R) STORE\n         AGO   .NOSDA\n.SDAREG  ANOP\n&LBL     ST    &SDA(1),SSSHSDA-SSSHSPE(,&R) STORE SDA VALUE\n&LBL     SETC  ''\n.NOSDA   AIF   ('&TCB' EQ '').NOTCB\n         AIF   ('&TCB' NE '&TCB(1)').TCBREG\n&LBL     LA    0,&TCB              --> OBJECT TCB\n&LBL     SETC  ''\n         ST    0,SSSHTCB-SSSHSPE(,&R) STORE\n         AGO   .NOTCB\n.TCBREG  ANOP\n&LBL     ST    &TCB(1),SSSHTCB-SSSHSPE(,&R) STORE TCB PTR\n&LBL     SETC  ''\n.NOTCB   AIF   ('&FLAG' EQ '').NOFLAG\n&LBL     MVC   SSSHFLAG-SSSHSPE(&R),&LFLAG SET FLAGS\n&LBL     SETC  ''\n.NOFLAG  ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT408/FILE408.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT408", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}