{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011617000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 3292016, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 15, "INMDSNAM": "CBT.V500.FILE264.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 3292016, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 3292016, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE264.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x004\\t'", "DS1TRBAL": "b'uh'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x01\\xd3\\x00\\x02\\x01\\xd6\\x00\\t\\x005'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$$READ": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00#\\x01\\x185\\x0f\\x01\\x19\\x04?\\x15 \\x00,\\x00<\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2018-12-16T00:00:00", "modifydate": "2019-02-12T15:20:23", "lines": 44, "newlines": 60, "modlines": 0, "user": "SBGOLOB"}, "text": "            ASSEMBLING LOOK WHEN IBM MACROS CHANGE\n             (It is very important to read this.)\n\nIf you have upgraded a few new operating system levels, then it is\nadvisable to reassemble LODK with CBMACS, because IBM may have added\nmore new fields to their old macros, and you might want to be able to\nformat the new fields in the control block which this macro describes.\n\nLOOK has the very important capability of formatting control blocks\nby reading the macros which describe their contents.  The format of\nthe field in the macro, \"C\" or \"X\" or \"B\" determines how LOOK, and\nspecifically its subprogram CBMACS, will format the control block.\n\nAlso, LOOK will not format a field in the form of 0CLx or 0XLx.\nLOOK will only format fields of \"real length\", as shown in the macro.\n\nOf course, when IBM developers code a macro, they do not have the\nuser-written program LOOK, and specifially CBMACS, in mind.  The IBM\ndevelopers have coded \"C\" where there should have been an \"X\", so\nCBMACS, instead of formatting the field as a hex number, the way it\nshould, it formats the value as a \"character\", which is probably\nunprintable, and the value shows up as a period, which doesn't help\nus to see what the value really is (unless you say ONULL, to see the\nraw data).\n\nSometimes, as in the case of IHACDE and IHALPDE, under z/OS 2.3 and\nhigher, IBM will cause one macro to generate two same-named DSECTs,\nand that causes an assembly error in CBMACS.  So to solve these two\ncases, there is an option in these macros, to create only one DSECT,\nand CBMACS must assemble IHACDE with the proper option,:\n\nExample:   IHACDE   EDCDSECT=YES ,\n           IHALPDE  EDCDSECT=YES ,\n\nNext fact:  I can't publish IBM macros on the CBT Tape, because they\nare copyrighted by IBM and their use is restricted to licensees.  So\ntherefore, in order to assemble CBMACS so it will show all the fields\nthat WE WANT TO SHOW, we have to make copies of the IBM macros, and\nuse the copies, when we assemble CBMACS.\n\nSEE THE MEMBERS $$NOTExx for hints about which IBM macros need to be\ncopied and altered.  You can do the same kind of thing with the\nmacros for control blocks that YOU ARE INTERESTED IN STUDYING.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$$#DATE": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04a\\x002\\x01\\x19\\t\\x7f\\x01\\x19\\t\\x7f\\x11\\x08\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf7@@@'", "ispf": {"version": "04.97", "flags": 0, "createdate": "2019-04-07T00:00:00", "modifydate": "2019-04-07T11:08:32", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-497"}, "text": "REGULAR CBT TAPE - VERSION 497    FILE:  264\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT497.FILE264\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 57 MEMBERS COUNTED; CUMULATIVE SIZE IS 30,715 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   04/07/19    11:08:32    UTC-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$DOC264": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00\\x15\\x00\\x88\\x13\\x7f\\x01\\x19\\x04?\\x15$\\x003\\x00 \\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "1988-05-16T00:00:00", "modifydate": "2019-02-12T15:24:15", "lines": 51, "newlines": 32, "modlines": 0, "user": "SBGOLOB"}, "text": "This documentation is from the original version of File 264.\nLOOK was originally written, in its entirety, by Guy Albertelli,\ntogether with the immensely clever module, CBMACS.\n\nDUDASD was modernized by Albert Cheng, and we present his version\nof DUDASD here (fixed for 4-character unit addresses, etc.).\n\n**FILE 264 Is from BF GOODRICH of AKRON , OHIO and contains two  *\n           TSO command processors and a program.                 *\n           They are:                                             *\n              1  LOOK    -  A TSO COMMAND PROCESSOR THAT ALLOWS  *\n                            FULL SCREEN DISPLAY OF REAL TIME     *\n                            MEMORY .  THIS COMMAND HAS BEEN      *\n                            ENHANCED TO MAKE IT EASY TO ADD      *\n                            NEW CONTROL BLOCK MAPS , USUALLY IN  *\n                            3 OR 4 STATEMENTS                    *\n                             * (refreshed  7/91 v1.1.E -         *\n                                   functions under ESA 4.2)      *\n               -------------------------------------------------\n                 (Note from Sam Golob:  The LOOK program needs\n                  a PARMLIB setting in the active DIAGxx member:\n                  (Valid from z/OS 1.8 thru z/OS 2.3 only.)\n\n     >>>>>>>>               VSM ALLOWUSERKEYCSA(YES)\n\n                  This was the default until z/OS 1.8, but in\n                  z/OS 1.9, VSM ALLOWUSERKEYCSA(NO) is the\n                  default.  It now has to be specifically set to\n                  VSM ALLOWUSERKEYCSA(YES), or LOOK will abend\n                  with a SB0A, reason code 5C.\n               -------------------------------------------------\n     >>>>>>>>    The current LOOKJ was fixed by Joe Reichman to\n                 not allocate CSA in a user key.  It now must\n                 be APF-authorized, and it will allocate that\n                 storage in Key 0 now.\n               -------------------------------------------------\n\n              2 DUDASD      AN UPDATED VERSION FROM FILE 300     *\n                            OF THIS TAPE THAT HAS BEEN CONVERTED *\n                            TO FUNCTION UNDER EITHER SP OR XA    *\n                             * (   functions under ESA 4.2)      *\n              3 JLOG        A PROGRAM TO PRINT OUT THE JES JOBLOG*\n                            AND OR ANY OTHER JES DATASETS, EVEN  *\n                            IF THEY ARE QUEUED TO A DUMMY CLASS. *\n                            USEFUL IN OBTAINING THE JOBLOG OF    *\n                            ABENDING STARTED TASKS.              *\n                             * (refreshed  2/92        -         *\n                                   functions under ESA 4.2)      *\n\n                Guy Albertelli\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$INDEX": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00I\\x00\\x891\\x1f\\x01\\x19\\t\\x7f\\x10T\\x00#\\x00\\x07\\x00\\x1f\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1989-11-07T00:00:00", "modifydate": "2019-04-07T10:54:49", "lines": 35, "newlines": 7, "modlines": 31, "user": "SBGOLOB"}, "text": "This member is an index of the members in this file:\n\n************************************************************\n   for LOOK command\n************************************************************\n\n$DLOOK       Documentation for the LOOK command\n$ILOOK       Install JCL for the LOOK command\nLOOKN        LOOK command source - 64-bit\nLOOKJ        LOOK command source - 31-bit\nCBMACS       LOOK command - IBM control block table\n\n************************************************************\n   for DUDASD command\n************************************************************\n\n#DUDASD      TSO Help member\nDUDASD       Source and JCL for the DUDASD command\n\n************************************************************\n   for JLOG program\n************************************************************\n\n$IJLOG       Install JCL for JLOG program\nJLOG         Source for the JLOG program\n\n$BFGMSG      Macros that output messages with subtitutions\n$BFGMSGC           in the text\n$BFGMSGD\n\nKEYT         Macros to parse keyword strings into meaningful data\nKEYVAL\n\nPROLOGUE     Macros for entry and equates\nREQUATE\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$NOTE00": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x19\\x01\\x19\\t\\x7f\\x01\\x19\\t\\x7f\\x11\\x00\\x00\\x11\\x00\\x11\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-04-07T00:00:00", "modifydate": "2019-04-07T11:00:19", "lines": 17, "newlines": 17, "modlines": 0, "user": "SBGOLOB"}, "text": "A Note about LOOK and CBMACS\n- ---- ----- ---- --- ------\n\nThe two programs, LOOK (i.e. LOOKN or LOOKJ) may be considered as a\n\"driving module\" for CBMACS, which is the module that formats control\nblocks.\n\nSo:\n\nAny version of LOOK can be combined with any version of CBMACS.\n\nTherefore:\n\nIf you've customized your version of CBMACS, and you want to upgrade\nyour version of LOOK, just reassemble your own version of CBMACS\nwith the new version of LOOK.  You should be fine.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE01": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00)\\x01\\x08\\x15?\\x01\\x19\\t_\\x18\\x12\\x00\"\\x00\\x0e\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2008-06-01T00:00:00", "modifydate": "2019-04-05T18:12:29", "lines": 34, "newlines": 14, "modlines": 0, "user": "SBGOLOB"}, "text": "Important note, for the LOOK command to work:\n--------- ----  --- --- ---- ------- -- ----\n     This remark only applies to older versions of LOOK.\n     The new versions:  LOOKN (64-bit) and LOOKJ (31-bit) run\n     APF-authorized all the time, and do not allocate\n     user-key common storage.\n\n               -------------------------------------------------\n                 (Note from Sam Golob:  The LOOK program needs\n                  a PARMLIB setting in the active DIAGxx member:\n\n     >>>>>>>>               VSM ALLOWUSERKEYCSA(YES)\n\n               This was the default until z/OS 1.8, but in\n               z/OS 1.9, VSM ALLOWUSERKEYCSA(NO) is the\n               default.  It now has to be specifically set to\n               VSM ALLOWUSERKEYCSA(YES), or LOOK will abend\n               with a SB0A, reason code 5C (or something similar).\n               -------------------------------------------------\n               If your active DIAGxx member is set to\n                  VSM ALLOWUSERKEYCSA(NO)\n               and you don't want to change it, but you want to\n               use LOOK for a time, use TSO command (included in\n               this pds) UKEYCSA, which has to be authorized,\n               to temporarily turn off the setting:\n                  VSM ALLOWUSERKEYCSA(NO)\n               -------------------------------------------------\n               The newest version of LOOK, member LOOKJ, does\n               not try to acquire user key CSA, and therefore\n               this version of LOOK does not need the PARMLIB\n               setting.  This note is applicable only from\n               z/OS 1.8 thru z/OS 2.3.  In 2.4, acquiring\n               user key CSA will always be forbidden.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$NOTE02": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x009\\x01\\x10\\x15O\\x01\\x185\\x0f\\x13Q\\x00m\\x00A\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2010-06-03T00:00:00", "modifydate": "2018-12-16T13:51:39", "lines": 109, "newlines": 65, "modlines": 0, "user": "SBGOLOB"}, "text": "Example of changing an IBM macro, so CBMACS (in LOOK) will format\nit and show more fields.  This example illustrates the general problem,\nwhich may apply to many IBM macros.  It all depends on what you want\nto see.\n\nIf a field is marked DS 0CLn'   ' (with prefix size of 0) then it\nwill not be formatted by CBMACS.\n\nThis particular example shows a certain field in the TSO Logon Work Area\n(LWA) control block that I want to see, but CBMACS doesn't format it.\nHere's why.  (See code below.)\n\nWe have modified the requisite IBM macro, IKJEFLWA from SYS1.MODGEN\nas follows:\n\nIBM's original macro IKJEFLWA contains the following lines to describe\nthe field LWAPRMLB, which we would like to see formatted:\n\n*\nLWAPROSP DS  1A                        ADDR of KEY 1 stack     @E21D2G9\n*\nLWAPRMLB DS 0F   <--- label was here   PARMLIB FLAGS           @E1502I7\n         DS X                                                  @E1502I7\nLWATAPST EQU X'80'                     1 - INDICATES TAP CAME FROM\n*                                          STEPLIB             @E1502I7\nLWATNSST EQU X'40'                     1 - INDICATES TNS CAME FROM\n*                                          STEPLIB             @E1502I7\nLWATE2ST EQU X'20'                     1 - INDICATES TE2 CAME FROM\n*                                          STEPLIB             @E1502I7\nLWATE8ST EQU X'10'                     1 - INDICATES TE8 CAME FROM\n*                                          STEPLIB             @E1502I7\n         DS 3X                                                 @PEI0253\n*                                                              @PEI0253\n\nNotice that this field is marked as DS 0F, and since it doesn't\nconnote the definition of any actual space, when we assemble CBMACS,\nthe field will not be formatted.  Upon examination of the field we\nREALLY want to see, which is the first byte, we must make another\ncopy of macro IKJEFLWA to assemble with.  These lines are therefore\nchanged to the following:\n\n*\nLWAPROSP DS  1A                        ADDR of KEY 1 stack     @E21D2G9\n*\n         DS 0F                         PARMLIB FLAGS           @E1502I7\nLWAPRMLB DS X      <--- move label here                        @E1502I7\nLWATAPST EQU X'80'                     1 - INDICATES TAP CAME FROM\n*                                          STEPLIB             @E1502I7\nLWATNSST EQU X'40'                     1 - INDICATES TNS CAME FROM\n*                                          STEPLIB             @E1502I7\nLWATE2ST EQU X'20'                     1 - INDICATES TE2 CAME FROM\n*                                          STEPLIB             @E1502I7\nLWATE8ST EQU X'10'                     1 - INDICATES TE8 CAME FROM\n*                                          STEPLIB             @E1502I7\n         DS 3X                                                 @PEI0253\n*                                                              @PEI0253\n\nwhere the label LWAPRMLB is moved down one line, so it defines\nthe actual storage that we want to see.\n\nSince I think it is improper to include the actual IKJEFLWA macro\n(even a modified version - I think) on the CBT Tape, I have to just\nshow you which lines to modify, when you assemble CBMACS with it.\n\nThe correct extra field LWAPRMLB whose contents we want to see, will\nnow be pointing to the real storage that will now be formatted and\nseen.  (Illustration is below.)\n\nI would not put my modified copy of IKJEFLWA on the CBT Tape, so I\nprivately assembled LOOK with it on my own system, and I put that LOOK\nload module on File 035 (the load module library) on the CBT Tape.\nTo reassemble source, you have to do something like the JCL that is\nin member LOOK$, if the modified IKJEFLWA macro is in the pds\nSBGOLOB.LOOK.INSTALL (in that example JCL).\n\nAll the best of everything to all of you...\n\nSam Golob     sbgolob@cbttape.org\n\nIllustration:  Display extra field (marked with asterisks)\n------------\n\nLOOK COMMAND - DISPLAY VIRTUAL MEMORY      DISPLAY ASID= 002E\nENTER CMD -\nLAST CMD  - LLWA\n                          009FCC88  LWA\n ICART   ........          STCK    009C357C  PUTL    009C358C\n PTGT    009C359C  GETL    009C35AC  C441    009C35BC  PHAS2   009C3FEC\n IOBUF   00000000  BLK     0   RESV4   ...     LWC     00000000\n ECBA    00000000  CTDBC   009C346C  RAP     000089D0  EXITP   7F4654D0\n WHOIF   0000000A  LACCT   ACCT      LPROC   ISPFPROC          FLAG1   30\n FLAG2   0000  CTLS2   00  RTRAS   009CE230  SRWA1   009C0258\n DCBCT   00000000  T441R   009C305C  PROSP   00000000  PRMLB   F0\n                                                       **********\n TAPLN   0000  TNSLN   0000  TE2LN   0A78  TE8LN   0000  GENER   0000\n SECL    ........          00026   009C35CC  00027   009C36DC\n CT429   009BD030  SVTAD   00000000  STGST   009BD6D8  STGEN   009BF297\n CNCCB   7F467EB8  CNPRF   EN    TERM    000000C1  TOKEN   ........\n ADVLF   7F464F50  VCPPL   00000000  VECBP   00000000  VJST    00000000\n VFLGS   00  TSLEN   00000000  TMPPB   00000000  DYSEG   7F464FE0\n DTSEG   7F467E28  ISPDT   00000000  MSRM@   00000000  TSTTR   00000000\n FREE    00000000\n\nSimilarly, if you want to see the values in field LWAICART, you should\nchange the field description from CL8 to XL8.\n\nSame with LWARESV4, LWASECL and LWATOKEN.  Change the C to X.\nThen you will see the actual (hex) value of these fields.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$NOTE03": {"ttr": 531, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00B\\x01\\x10\\x15_\\x01\\x19\\x04/\\x18S\\x00&\\x00 \\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2010-06-04T00:00:00", "modifydate": "2019-02-11T18:53:42", "lines": 38, "newlines": 32, "modlines": 0, "user": "SBGOLOB"}, "text": "ASSEMBLING UNDOCUMENTED IBM CONTROL BLOCKS:  (And changing IBM ones)\n\n1.  Included in this pds is the SHOWMACS member from CBT Tape File 492\n    which contains macro descriptions of many IBM control blocks.  One\n    would think that if one includes this library in the SYSLIB\n    concatenation in the LOOK assembly, and the macro descriptions\n    are added to CBMACS, then one can easily format ALL of these\n    undocumented IBM control blocks.\n\n2.  The truth is that this might not happen.  One must be very careful\n    about the label names in each macro.  They should not be too long.\n    Each label name should be no more than 8 characters longer than\n    the macro prefix, preferably a maximum of 7 characters longer.\n\n3.  So to get a readable formatting, the macros may have to be edited.\n    Make a copy of each one you want, and edit it separately.\n\n4.  I have included edited versions of the IKJTPVT and IKJCTLT macros\n    in this pds, which will format the fields better than those in\n    the SHOWMACS macro library.  Remember to adjust the CBMACS calling\n    of these macros, through the BKSTR macro, to reflect the EDITED\n    field names.  I have shown this work, in member CBMACSE.\n\n5.  Lengths should be SPECIFICALLY specified for character fields.\n\n        Example:  Don't allow DS C'VOLSER' to be coded.\n                  Rather code DS CL6'VOLSER'\n\n        Most IBM macros are very specific about field lengths.  The\n        SHOWMACS macros may not be.  Therefore they must be edited\n        to specifically show all (character) field lengths.\n\n    Doing all of this, will make the formatted control blocks clearer\n    to read, with fewer errors, and will avoid unnecessary truncation\n    of the fields, as long as BKSTR can figure out all the field\n    lengths correctly.\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$NOTE04": {"ttr": 533, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00W\\x01\\x14\\x18\\x0f\\x01\\x19\\x04/\\x18R\\x00:\\x00\\x1d\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2014-06-29T00:00:00", "modifydate": "2019-02-11T18:52:57", "lines": 58, "newlines": 29, "modlines": 0, "user": "SBGOLOB"}, "text": "First note:\n\nEvery once in a while, LOOK will have to be reassembled to see new\nfields in the system macros.  The macros will sometimes be changed\nby IBM, and therefore if you want a more realistic formatting, you\nhave to reassemble LOOK and CBMACS, to use the newest versions of\nthe system macros.  (See assembly levels below.)\nAssembly JCL that was used, is in member LOOK$.\n\nSecond note:\n\nI have had difficuly with formatting the newest version of the JMR\n(macro IEFJMR), because of the JMR extension that has been added to\nit, and the BKSTR macro of CBMACS did not understand that properly.\nTherefore, for now, I have left out the formatting of the JMR unitl\nI better understand what is going on, and I can fix the assembly\nerror.\n\nThird note:\n\nI have had to change a few fields in macro IKJEFLWA so that they\nwould show up in the formatted view of the LWA control block.  I\ncould not publish the example of that on the CBT Tape, but the\nchanges to the z/OS 2.1 version (PUT 1405) were as follows:\n(condensed SUPERC listing):\n\n\n                                         MAT=  291\n  I -          DS 0F            13450000 RPL=    2 00292 00292\n  D - LWAFLGS  DS 0F            13450000\n  I - LWAFLGS  DS  X            13500000           00293 00293\n  D -          DS  X            13500000\n                                         MAT=    8\n  I - LWAFLGS2 DS  X            13950001 RPL=    1 00302 00302\n  D -          DS  X            13950000\n                                         MAT=    8\n  I - LWAFLGS3 DS  X            14400001 RPL=    1 00311 00311\n  D -          DS  X            14400000\n                                         MAT=  324\n  I -          DS 0F       02I7 30400000 RPL=    2 00636 00636\n  D - LWAPRMLB DS 0F       02I7 30400000\n  I - LWAPRMLB DS X        02I7 30450000           00637 00637\n  D -          DS X        02I7 30450000\n                                         MAT= 1066\n\nReassembly Dates:\n\n1.  2014/07/01 - z/OS 2.1 level 1405.    (Load module is on File 035)\n\n2.  2019/02/07 - z/OS 2.3 level 1812.    (Load module is on File 035)\n\n\n\n\n\n\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$NOTE05": {"ttr": 535, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x08\\x01\\x17\\x13\\x0f\\x01\\x19\\t_\\x18\\t\\x00*\\x00\\x1d\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2017-05-10T00:00:00", "modifydate": "2019-04-05T18:09:08", "lines": 42, "newlines": 29, "modlines": 0, "user": "SBGOLOB"}, "text": "           Note about the LOOKJ version of LOOK\n\n------------------------------------------------------------\nAll of these remarks pertain to the newest 64-bit version of\nLOOK, called LOOKN.  ABOVE THE BAR STORAGE can be examined\nwith LOOKN.\n------------------------------------------------------------\n\nJoe Reichman has made an attempt to fix the recovery routine in\nLOOK so that it does not S0C4 when you type in a bad address.\nHis version of LOOK will now say \"BAD ADDRESS\" instead of\nabending with a S0C4, and you can keep on using the program,\ninstead of abending out of it.\n\nJoe has also fixed LOOK so it will not allocate user key CSA.  So\nnow, this version of LOOKJ will run without needing any tweaking\nof bits, or changing settings in PARMLIB.  z/OS 2.4 will prohibit\nthe allocation of user key CSA altogether.\n\nLOOKJ will not run (even in your own address space) unless it is\nAPF-authorized, and it will give you a message saying so.  To\nauthorize it, LOOKJ has to be in the AUTHCMD table in IKJTSOxx in\nPARMLIB, or if you are running with an authorized STEPLIB, LOOKJ\nhas to be in the IKJEFTE2 CSECT of the IKJTABLS load module.\n(See CBT Tape File 185 for more information.)  Of course, LOOKJ\nmust reside in an APF-authorized library, and be linkedited with\nSETCODE AC(1).\n\nOr you can use the AUCMD program from CBT File 300 to authorize\nLOOKJ, and say:\n\nTSO AUCMD LOOKJ\n\nif you have authorized AUCMD in the IKJEFTE2 table.\n\nIn any case, LOOKJ should no longer abend, if you type in a bad\naddress.  If it does abend, please tell me so.\n\nSam Golob  -  May 10, 2017    sbgolob@cbttape.org\n\nPlease see member $$NOTE06.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE06": {"ttr": 537, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x007\\x01\\x19\\x03\\x8f\\x01\\x19\\t\\x7f\\x11\\x02\\x00\"\\x00\\x17\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2019-02-07T00:00:00", "modifydate": "2019-04-07T11:02:37", "lines": 34, "newlines": 23, "modlines": 0, "user": "SBGOLOB"}, "text": "LOOKJ, LOOKN, etc.\n\nLOOKN is the 64-bit version of LOOKJ, and you can see storage with it,\nthat is \"above the bar\".  Example:  Type in the address:  1FFFFF00000\nLOOKN is now the preferred version of LOOK to use, if you have a z/OS\nsystem.\n\nJoe Reichman has fixed LOOK so that it does not obtain common storage\nin a user key.  Therefore, LOOKJ can now run when the DIAGxx PARMLIB\nmember contains (or is defaulted to):\n\nVSM ALLOWUSERKEYCSA(NO)\n\nThis parameter will no longer be valid from z/OS 2.4 onward, so\nfrom z/OS 2.4 on, you MUST use this version of LOOKJ, or LOOKN.\n\nThe downside is that LOOKJ now has to be APF-authorized, always.\nSame applies to LOOKN.\n\nI am leaving previous versions of the LOOK code, for people who are\nrunning older operating systems.  And if you are in between from\nz/OS 1.8 to z/OS 2.3, you can use the UKEYCSA program to temporarily\nallow the allocation of user key CSA.\n\nPlease note that LOOK has to be assembled together with CBMACS,\nwhich is the code that formats some control blocks.  The LOOK driver\nprogram is what has been changed, not CBMACS.\n\nYou should assemble LOOK with CBMACS at the system level which your\nsystem is running.  Use the SYS1.MACLIB and SYS1.MODGEN (or AMODGEN)\nwhich is at the level that your system is running.\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$READ$$": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x18\\x01\\x19\\x03\\x8f\\x01\\x19\\tO\\x17U\\x00\"\\x00\\x1e\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2019-02-07T00:00:00", "modifydate": "2019-04-04T17:55:18", "lines": 34, "newlines": 30, "modlines": 0, "user": "SBGOLOB"}, "text": "** -------------------------------------------------------------------\n**   The new 64-bit version of LOOK is called LOOKN.\n**   The revised 31-bit version of LOOK is called LOOKJ.\n**   Both of these versions were developed by Joe Reichman.\n** -------------------------------------------------------------------\n**   The LOOK version called LOOKJ has been revised by Joe Reichman to\n**   allow operation when VSM ALLOWUSERKEY(NO) is set, in the PARMLIB\n**   member DIAGxx.  For cross-memory storage browsing, the SCHEDULE\n**   macro has been replaced by IEAMSCHD, so this version of the\n**   program may not work on old MVS systems (below OS/390 1.3).\n**\n**   THIS VERSION OF LOOK REQUIRES APF-AUTHORIZATON, ALWAYS.\n** -------------------------------------------------------------------\n**   LOOK requires assembly together with the CBMACS module, so that\n**   it can format many system control blocks.  The LOOK module is the\n**   \"driving code\", which can be assembled together with different\n**   versions of CBMACS depending on any specialized needs that you\n**   have, to format specific control blocks.  The CBMACS we have\n**   packaged with CBT File 264, will already format many standard\n**   z/OS (OS390, MVS) control blocks, but you may want to create\n**   your own versions of CBMACS.\n**\n**   Please note:  CBMACS will only format \"real data\" in macros,\n**   so when an IBM macro contains:   label   DS  0CLx   or similarly,\n**   label  DS  0XLx  then CBMACS will not display that field.  You\n**   may want to create your own altered versions of IBM macros, but\n**   we can't publish them for licensing reasons.  Formatting in\n**   CBMACS also depends on the data type (such as C, X, A, F, etc.)\n**   You may want to alter an IBM macro from  DS CL5 to DS XL5, so\n**   that the data will display in hex, instead of showing a dot,\n**   when that data is not a displayable value.\n**\n**   Formatting is turned off, using the ONULL command in LOOK.\n**   -----------------------------------------------------------------\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$ASSEMBL": {"ttr": 771, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00(\\x01\\x00\\x17O\\x01\\x185\\x0f\\x14\\x18\\x00 \\x00\\x1f\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2000-06-22T00:00:00", "modifydate": "2018-12-16T14:18:28", "lines": 32, "newlines": 31, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM - TAKE DEFAULTS\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,FLAG(5))\n//STEPLIB  DD DISP=SHR,DSN=HLA.SASMMOD1\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=SBGOLOB.CBT497.FILE264\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.CBT497.FILE264(LOOKJ)\n//         DD DISP=SHR,DSN=SBGOLOB.CBT497.FILE264(CBMACS)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(CYL,2),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n ENTRY   LOOK\n INCLUDE OBJECT\n SETSSI  CB497264\n SETCODE AC(1)\n NAME    LOOK(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$BFGMSG": {"ttr": 773, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00\\x00\\x00\\x82\\x12\\x7f\\x00\\x83\\x08\\x1f\\x12\"\\x00\\xc9\\x00\\xab\\x00*\\xe2\\xc7\\xe4\\xe8@@@@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "1982-05-07T00:00:00", "modifydate": "1983-03-22T12:22:00", "lines": 201, "newlines": 171, "modlines": 42, "user": "SGUY"}, "text": "         MACRO\n&N       $BFGMSG  &ID,&WORKAR=,&MSGAREA=,&WTO=YES,&PRINT=NO\n.**********************************************************************\n.*                                                                    *\n.*       THIS MACRO GENERATES THE INTERFACE TO THE NEW MESSAGE        *\n.*       PROCESSOR.                                                   *\n.*                                                                    *\n.*       SYNTAX                                                       *\n.*                                                                    *\n.*         $BFGMSG 32,(TYPE,ADDR),(TYPE,ADDR),...                     *\n.*                                                                    *\n.*                  WHERE  TYPE   IS ONE OF CNN    CHAR OF LEN NN     *\n.*                                          D1     1 BYTE DECIMAL     *\n.*                                          D2     2 BYTE DECIMAL     *\n.*                                          D4     3 BYTE DECIMAL     *\n.*                                          H1     1 BYTE HEX         *\n.*                                          H2     2 BYTE HEX         *\n.*                                          H4     4 BYTE HEX         *\n.*                                                                    *\n.*                          ADDR   IS EITHER A SYMBOL OR (REG)        *\n.*                                                                    *\n.*                                                                    *\n.*       ON ENTRY                                                     *\n.*            R0  ===  MESSAGE ID                                     *\n.*            R1  -->  +0   GENERAL FLAGS                             *\n.*                          X'80' IF ON ISSUE WTO,IF OFF DO NOT       *\n.*                     +1   AL3(MESSAGE CSECT BFGIMSG)                *\n.*                     +4   S(18 WORD WORKAREA)                       *\n.*                     +6   S(MESSAGE BUILD AREA, LEN>=132)           *\n.*                     +8   8 BYTE CSECT NAME                         *\n.*                     +16  4 BYTE FIRST INSERTION CONTROL            *\n.*                     +20  4 BYTE SECOND INSERTION CONTROL           *\n.*                     +24  ETC.                                      *\n.*                                                                    *\n.*      EACH INSERTION CONTROL IS FORMATED:                           *\n.*                +0     X'80' IS ON THEN TYPE=C & MAX LEN =X'3F'     *\n.*                       X'80' IS OFF THEN TYPE= X'3F' VALUE          *\n.*                             TYPE = 0  NO OPERATION                 *\n.*                                    1  1 BYTE HEX FORMAT            *\n.*                                    2  1 BYTE DECIMAL FORMAT        *\n.*                                    3  2 BYTE HEX FORMAT            *\n.*                                    4  2 BYTE DECIMAL FORMAT        *\n.*                                    5  4 BYTE HEX FORMAT            *\n.*                                    6  4 BYTE DECIMAL FORMAT        *\n.*                       X'40' IS ON THEN IT IS LAST INSERTION CONTROL*\n.*                       X'40' IS OFF THEN MORE FOLLOW                *\n.*                                                                    *\n.*                +1     NOT USED                                     *\n.*                +2,3   IF < 16 THEN IS REGISTER # WHICH CONTAINS    *\n.*                             ADDRESS OF INSERT VALUE                *\n.*                       IF > 16 THEN IS S-TYPE VALUE (B/DDD) WHICH   *\n.*                             EVALUATES TO THE ADDRESS OF INSERT     *\n.*                             VALUE                                  *\n.*                                                                    *\n.*                                                                    *\n.*                                                                    *\n.**********************************************************************\n         GBLB  &GUYMWK\n         GBLC  &WKAR,&MSGAR\n         LCLC  &LB,&L,&TYPE\n         LCLA  &I,&J,&K\n         LCLB  &WT\n.*\n.**      IF FIRST TIME THROUGH COPY CSECT\n.*\n         AIF   (&GUYMWK).NOTEXT\n         PUSH  USING,PRINT\n         AIF   ('&PRINT' EQ 'YES').COPY\n         PRINT OFF\n.COPY    ANOP\n         COPY  $BFGMSGC                 COPY IN CODE\n         POP   USING,PRINT\n&SYSECT  CSECT\n.NOTEXT  ANOP\n.*\n.**      IF WORKAR AND MSGAREA SPECIFIED THEN SAVE\n.*\n         AIF   (T'&WORKAR EQ 'O' OR T'&MSGAREA EQ 'O').NOWK\n&WKAR    SETC  '&WORKAR'\n&MSGAR   SETC  '&MSGAREA'\n&GUYMWK  SETB  1\n.NOWK    ANOP\n.*\n.**      IF WORKAR AND MSGAREA HAVE NOT YET BEEN SPECIFIED THEN DEFAULT\n.*\n         AIF   (&GUYMWK).WKOK\n         MNOTE 4,'WORKAREA AND MESSAGE AREA NOT DEFINED'\n         MNOTE *,'DEFAULTS USED'\n         MNOTE *,'             WORKAREA=MSGWORK'\n         MNOTE *,'             MSGAREA=MSGAREA'\n&WKAR    SETC  'MSGWORK'\n&MSGAR   SETC  'MSGAREA'\n&GUYMWK  SETB  1\n.WKOK    ANOP\n.*\n.**      SEE IF MESSAGE TO GENERATE\n.*\n         AIF   (T'&ID EQ 'O').ENDIT\n.*\n.**      GENERATE INITIAL CODE\n.*\n&LB      SETC  'ZMSG&SYSNDX'\n         CNOP  0,4\n&N       BAL   R1,&LB\n&WT      SETB  0\n         AIF   ('&WTO' NE 'YES').DONEWTO\n&WT      SETB  1\n.DONEWTO ANOP\n         DC    B'&WT.0000000'\n         DC    AL3(BFGIMSG)        ADDRESS OF MESSAGE CSECT\n         DC    S(&WKAR),S(&MSGAR)\n         AIF   ('&SYSECT' EQ '').NOSECT\n         DC    CL8'&SYSECT'        THIS ID\n         AGO   .GOSECT\n.NOSECT  DC    CL8'UNKNOWN'\n.GOSECT  ANOP\n&I       SETA  2                   POINT AT FIRST TYPE/ADDR PAIR\n.*\n.**      TOP OF LOOP FOR EACH TYPE/ADDR PAIR\n.*\n.LOOP    AIF   (N'&SYSLIST LT &I).DONE\n         AIF   (T'&SYSLIST(&I) EQ 'O').EDNTY\n         AIF   ('&SYSLIST(&I)'(1,1) NE '(').ERR1\n         AIF   (N'&SYSLIST(&I) NE 2).ERR2\n&TYPE    SETC  '&SYSLIST(&I,1)'\n.*\n.**      CHECK FOR LAST ENTRY\n.*\n&K       SETA  0                   ASSUME NO EOF\n         AIF   (N'&SYSLIST NE &I).NOEOF\n&K       SETA  64                  SET EOF FLAG\n.NOEOF   ANOP\n.*\n.**      FORMAT TYPE BYTE\n.*\n         AIF   (K'&SYSLIST(&I,1) LT 2).ERR3\n         AIF   ('&TYPE'(1,1) NE 'C').NOTC\n&J       SETA  128                 SET VALUE\n&L       SETC  '&TYPE'(2,3)\n         DC    AL1(&K+&J+&L)\n         AGO   .DNTY\n.NOTC    ANOP\n         AIF   ('&TYPE'(1,1) NE 'H').NOTH\n&J       SETA  1\n         AGO   .HDLEN\n.NOTH    AIF   ('&TYPE'(1,1) NE 'D').ERR4\n&J       SETA  2\n.HDLEN   ANOP\n         AIF   ('&TYPE'(2,1) EQ '1').GENTYPE\n         AIF   ('&TYPE'(2,1) NE '2').NOT2\n&J       SETA  &J+2\n         AGO   .GENTYPE\n.NOT2    AIF   ('&TYPE'(2,1) NE '4').ERR5\n&J       SETA  &J+4\n.GENTYPE DC    AL1(&J+&K)\n.*\n.**      FORMAT ADDR BYTES\n.*\n.DNTY    ANOP\n         AIF   ('&SYSLIST(&I,2)'(1,1) NE '(').NOTREG\n         DC    AL3(&SYSLIST(&I,2))\n         AGO   .EDNTY\n.NOTREG  DC    AL1(0),S(&SYSLIST(&I,2))\n.EDNTY   ANOP\n.*\n.**      LOOP FOR NEXT ADDR PAIR\n.*\n&I       SETA  &I+1\n         AGO   .LOOP\n.*\n.**      SEE IF NEED TO GENERATE DUMMY ENTRY\n.*\n.DONE    ANOP\n         AIF   (&I NE 2).NODUM\n         DC    AL1(64),AL3(0)      DUMMY LIST FOR NO INSERTION\n.NODUM   ANOP\n.*\n.**      GENERATE FINAL CODE\n.*\n&LB      L     R15,=V(BFGMSG)\n         LA    R0,MSG&ID.ID\n         BALR  R14,R15\n.ENDIT   MEXIT\n.ERR1    MNOTE 12,'INVALID TYPE/ADDR PAIR FORMAT'\n         MNOTE *,'-&I-&SYSLIST(&I)-'\n         MEXIT\n.ERR2    MNOTE 12,'NUMBER OF ITEMS INVALID'\n&J       SETA  N'&SYSLIST(&I)\n         MNOTE *,'-&I-&SYSLIST(&I)-&J'\n         MEXIT\n.ERR3    MNOTE 12,'TYPE=C SPECIFIED WITHOUT MAX LENGTH'\n&J       SETA  K'&SYSLIST(&I,1)\n         MNOTE *,'-&I-&TYPE-&SYSLIST(&I,1)-&J-'\n         MEXIT\n.ERR4    MNOTE 12,'INVALID TYPE CODE SPECIFIED'\n         MNOTE *,'-&I-&TYPE-'\n         MEXIT\n.ERR5    MNOTE 12,'INVALID LENGTH CODE IN TYPE FIELD'\n         MNOTE *,'-&I-&TYPE-'\n         MEXIT\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$BFGMSGC": {"ttr": 777, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x82\\x12\\x7f\\x00\\x89)\\x8f\\x04@\\x019\\x01.\\x00\\x11\\xe2\\xc1\\xd3\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1982-05-07T00:00:00", "modifydate": "1989-10-25T04:40:00", "lines": 313, "newlines": 302, "modlines": 17, "user": "SALBERT"}, "text": "BFGMSG   CSECT\n         SAVE  (14,12),,BFGMSG..&SYSDATE..&SYSTIME\n         LR    R12,R15             SETUP BASE\n         USING BFGMSG,R12          SETUP ADDRESSABILITY\n         LR    R9,R1               SAVE INPUT REG LIST\n         LR    R11,R1              SAVE INPUT REG LIST (FOR GOOD)\n         LR    R3,R0               SAVE MESSSAGE ID\n         LR    R8,R13              SAVE REG SAVE AREA ADDR\n         LA    R1,4(R9)            POINT TO WORKAREA B/DDD\n         BAL   R14,SFMCBD          GET EFF ADDR IN R1\n         ST    R13,4(R1)           CHAIN SAVE AREAS\n         LR    R13,R1              POINT TO NEW SAVE AREA\n         L     R1,0(R9)            GET MESSAGE OFFSET CSECT\n         L     R6,0(R1)            GET MESSAGE TEXT CSECT\n         AR    R1,R3               POINT TO PROPER OFFSET CSECT ENTRY\n         LR    R3,R1               SAVE ADDR OF OFFSET ENTRY\n         AH    R6,0(R1)            INCREMENT TO ACTUAL MSG TEXT\n         LH    R7,0(R6)            GET LENGTH\n         LA    R1,6(R9)            POINT AT MSG AREA B/DDD\n         BAL   R14,SFMCBD          GET EFF ADDR IN R1\n         LR    R5,R1               SAVE IN REG\n*\n**       REGISTER CONTENTS\n**             R9  -->   PLIST\n**             R8  -->   OS SAVE AREA CONTAINING REGS\n**             R7  ===   LENGTH OF MSG TEXT TO MOVE\n**             R6  -->   NEXT BYTE OF MSG TEXT TO MOVE\n**             R5  -->   NEXT BYTE OF MSG OUTPUT TO MOVE\n*\n*\n**       MOVE FIRST 4 BYTES (LENGTH WILL BE SET LATER)\n*\n         MVC   0(4,R5),0(R6)       MOVE IN LEN AND FLAGS\n         LA    R5,4(R5)            POINT TO AREA PAST\n         LA    R6,4(R6)            POINT FROM AREA PAST\n         SH    R7,=H'4'            DECREMENT LENGTH\n*\n**       SETUP MESSAGE NUMBER\n*\n         MVC   0(3,R5),=C'BFG'     MOVE IN BASIC ID\n         MVC   3(8,R5),8(R9)       MOVE IN CSECT NAME\n         LA    R1,11               GET NUMBER TO DO\nSFM04    CLI   0(R5),C' '          READ END OF CSECT YET\n         BE    SFM06               QUIT AT BLANK\n         LA    R5,1(R5)            POINT TO NEXT ONE\n         BCT   R1,SFM04            LOOP TILL DONE\nSFM06    MVC   0(2,R5),2(R3)       MOVE IN MESSAGE NUMBER\n         LA    R5,2(R5)            POINT TO NEXT BYTE\n         LA    R9,16(R9)           POINT AT INSERTION CONTROLS\n*\n**       MOVE MESSAGE TEXT LOOKING FOR INSERTION CHARACTER\n*\nSFM10    CLI   0(R6),C'\u00a2'          IS THIS INSERT CHAR\n         BNE   SFM20               GO AND INSERT DATA\n         BAL   R14,SFMINSRT        GO AND INSERT STRING\n         B     SFM30               IF ALL DONE THE SKIP '\u00a2'\nSFM20    MVC   0(1,R5),0(R6)       MOVE CHAR OF MSG TEXT\n         LA    R5,1(R5)            POINT TO AREA PAST\nSFM30    LA    R6,1(R6)            POINT FROM AREA PAST\n         BCT   R7,SFM10            KEEP GOING\n*\n**       DONE WITH WTO MESSAGE BUT FOR ALL THE ROUT AND DESC CODES\n*\n         MVC   0(4,R5),0(R6)       MOVE IN ROUTE AND DESC CODES\n*\n**       COMPUTE LENGTH OF MESSAGE\n*\n         LA    R1,6(R11)           POINT AT MSG AREA B/DDD\n         BAL   R14,SFMCBD          GET EFF ADDR IN R1\n         SR    R5,R1               GET LENGTH OF WTO\n         STH   R5,0(R1)            SAVE LENGTH\n*\n**       ISSUE WTO AND RETURN\n*\n         TM    0(R11),X'80'        DO THE WTO??\n         BZ    SFM40               NOPE\n         L     R14,4(R13)          ACCESS OLD SAVEAREA\n         L     R0,12+8(R14)        GET ORIG R0\n         WTO   MF=(E,(R1))         ISSUE WTO\nSFM40    L     R13,4(R13)          GET SAVE AREA ADDR\n         RETURN (14,12)\n*\n**       FETCH REGISTER CONTENTS AT ENTRY\n**\n**       INPUT\n**             R1  -->  1 BYTE FIELD BX\n**                            WHERE B IS REGISTER NUMBER TO GET\n**\n**       OUTPUT\n**             R15 === VALUE IN REGISTER B AT ENTRY\n*\nSFMFREG  DS    0H\n         SR    R15,R15             CLEAR REG\n         IC    R15,0(R1)           GET REG NUMBER\n         SRL   R15,4               GET JUST REG NIBBLE\n         SLL   R15,2               TIMES 4\n         CH    R15,=AL2(R13*4)     IS IT R13\n         BE    SFMRG80             YES SO EASY\n         BL    SFMRG30             BEWTEEN R0 AND R12\n         SH    R15,=AL2(16*4)      IF R14 OR R15 GET NEGATIVE\nSFMRG30  L     R15,20(R8,R15)      GET VALUE\n         BR    R14                 EXIT\nSFMRG80  LR    R15,R8              GET ORIG R13 VALUE\n         BR    R14                 EXIT\n*\n**       ROUTINE TO CONVERT B/DDD FORMAT HALFWORDS TO EFFECTIVE ADDRESS\n**\n**       INPUT\n**             R1   -->   2 BYTE FIELD IN B/DDD FORM (S-TYPE CONSTANT)\n**\n**       OUTPUT\n**             R1   ===   EFFECTIVE ADDRESS\n*\nSFMCBD   DS    0H\n         LR    R0,R14              SAVE RETURN ADDR\n         BAL   R14,SFMFREG         GET REGISTER\n         ICM   R1,3,0(R1)          GET B/DDD\n         N     R1,=A(X'00000FFF')  GET JUST DISPLACEMENT\n         AR    R1,R15              GET EFFECTIVE ADDR\n         LR    R14,R0              GET RETURN ADDR\n         BR    R14                 EXIT\n*\n**       ROUTINE TO DO INSERTION\n**\n**       INPUT\n**             R5   -->   OUTPUT AREA TO USE\n**             R9   -->   INSERTION CONTROL TO USE\n**\n**       OUTPUT\n**             R5   -->   NEXT OPEN BYTE IN OUTPUT AREA\n**             R9   -->   NEXT INSERTION CONTROL OR 0\n*\nSFMINSRT DS    0H\n         LTR   R9,R9               ANY INSERTION CONTROL LEFT\n         BZR   R14                 NOPE\n         ST    R14,12(R13)         SAVE RETURN ADDR\n*\n**       HANDLE NOP\n*\n         TM    0(R9),X'BF'         IS THIS NOP\n         BZ    SFMIN90             YES SO SKIP\n*\n**       HANDLE CHARACTER FORMAT\n*\n         TM    0(R9),X'80'         IS THIS CHARACTER\n         BZ    SFMIN20             NOPE\n         BAL   R14,SFMINSAD        GET ADDR IN R1\n         LR    R4,R1               SAVE ADDR TO MOVE\n         SR    R3,R3               CLEAR REG\n         IC    R3,0(R9)            GET LENGTH\n         N     R3,=XL4'0000003F'   GET JUST LENGTH\nSFMIN10  CLI   0(R4),C' '          IS IT BLANK\n         BE    SFMIN90             YES SO DONE\n         MVC   0(1,R5),0(R4)       MOVE IN CHAR\n         LA    R5,1(R5)            UP TO PTR\n         LA    R4,1(R4)            UP FROM PTR\n         BCT   R3,SFMIN10          LOOP TILL DONE OR BLANK\n         B     SFMIN90             ALL DONE\n*\n**       HANDLE OTHER NUMERIC TYPES\n*\nSFMIN20  SR    R1,R1               CLEAR REG\n         IC    R1,0(R9)            GET TYPE BYTE\n         N     R1,=XL4'0000003F'   GET JUST TYPE\n         CH    R1,=H'6'            IS IT TOO BIG\n         BH    SFMIN90             IF SO THEN EXIT NOT SUPPORTED\n         SLL   R1,2                TIMES 4\n         L     R15,SFMTYPE-4(R1)   GET RTN ADDR\n         BR    R15                 AND GO THERE\nSFMTYPE  DC    A(SFMIN30H,SFMIN30D) =1,2    1 BYTE HEX, DECIMAL\n         DC    A(SFMIN40H,SFMIN40D) =3,4    2 BYTE HEX, DECIMAL\n         DC    A(SFMIN50H,SFMIN50D) =5,6    4 BYTE HEX, DECIMAL\n*\n**       FORMAT 1 BYTE IN HEX\n*\nSFMIN30H DS    0H\n         BAL   R14,SFMINSAD        GET ADDR IN R1\n         ICM   R15,8,0(R1)         GET A BYTE\n         BAL   R14,SFMHEX          FORMAT HEX WORD\n         MVC   0(2,R5),20(R13)     MOVE IN CHARS\n         LA    R5,2(R5)            POINT PAST IT\n         B     SFMIN90             NOW EXIT\n*\n**       FORMAT 1 BYTE IN DECIMAL\n*\nSFMIN30D DS    0H\n         BAL   R14,SFMINSAD        GET ADDR IN R1\n         SR    R15,R15             CLEAR REGISTER\n         ICM   R15,1,0(R1)         GET A BYTE\n         BAL   R14,SFMDEC          FORMAT HEX WORD\n         B     SFMIN90             NOW EXIT\n*\n**       FORMAT 2 BYTES IN HEX\n*\nSFMIN40H DS    0H\n         BAL   R14,SFMINSAD        GET ADDR IN R1\n         ICM   R15,12,0(R1)        GET TWO BYTES\n         BAL   R14,SFMHEX          FORMAT HEX WORD\n         MVC   0(4,R5),20(R13)     MOVE IN CHARS\n         LA    R5,4(R5)            POINT PAST IT\n         B     SFMIN90             NOW EXIT\n*\n**       FORMAT 2 BYTES IN DECIMAL\n*\nSFMIN40D DS    0H\n         BAL   R14,SFMINSAD        GET ADDR IN R1\n         SR    R15,R15             CLEAR REGISTER\n         ICM   R15,3,0(R1)         GET A BYTE\n         BAL   R14,SFMDEC          FORMAT HEX WORD\n         B     SFMIN90             NOW EXIT\n*\n**       FORMAT 4 BYTES IN HEX\n*\nSFMIN50H DS    0H\n         BAL   R14,SFMINSAD        GET ADDR IN R1\n         ICM   R15,15,0(R1)        GET TWO BYTES\n         BAL   R14,SFMHEX          FORMAT HEX WORD\n         MVC   0(8,R5),20(R13)     MOVE IN CHARS\n         LA    R5,8(R5)            POINT PAST IT\n         B     SFMIN90             NOW EXIT\n*\n**       FORMAT 4 BYTES IN DECIMAL\n*\nSFMIN50D DS    0H\n         BAL   R14,SFMINSAD        GET ADDR IN R1\n         SR    R15,R15             CLEAR REGISTER\n         ICM   R15,15,0(R1)        GET A BYTE\n         BAL   R14,SFMDEC          FORMAT HEX WORD\n         B     SFMIN90             NOW EXIT\n*\n**       HANDLE POSSIBLE LAST ONE\n*\nSFMIN90  L     R14,12(R13)         GET RETURN ADDR\n         TM    0(R9),X'40'         IS THIS LAST ENTRY\n         BZ    SFMIN92             NOPE\n         SR    R9,R9               YES SO CLEAR INSERTION CONTROL\n         BR    R14                 EXIT\nSFMIN92  LA    R9,4(R9)            POINT TO NEXT\n         BR    R14                 EXIT\n*\n**       ROUTINE TO EVALUATE VALUE ADDRESS FROM INSERTION CONTROL ENTRY\n**\n**       INPUT\n**             R9   -->   INSERTION CONTROL\n**\n**       OUTPUT\n**             R1   -->   VALUE TO BE INSERTED\n*\nSFMINSAD DS    0H\n         CLC   2(2,R9),=H'16'      IS THIS A REG\n         BH    SFMINA10            NOPE\n*\n**       FETCH REGISTER CONTENTS\n*\n         LR    R3,R14              SAVE RETURN ADDR\n         IC    R1,3(R9)            GET REG\n         SLL   R1,4                MOVE TO DIFFERENT NIBBLE\n         STC   R1,0(R13)           SAVE IT\n         LA    R1,0(R13)           POINT AT IT\n         BAL   R14,SFMFREG         GET VALUE\n         LR    R1,R15              RETURN IT PROPERLY\n         BR    R3                  EXIT\n*\n**       EVALUATE B/DDD FIELD\n*\nSFMINA10 DS    0H\n         LA    R1,2(R9)            POINT AT B/DDD\n         B     SFMCBD              GO AND CONVERT HE WILL RETURN\n*\n**       ROUTINE TO FORMAT VALUE IN R15 IN HEX\n**\n**       INPUT\n**             R15  ===   VALUE TO CONVERT TO HEX\n**\n**       OUTPUT\n**             20(R13)   ===   8 CHARACTERS  (HEX REPRESENTATION OF R1)\n*\nSFMHEX   DS    0H\n         ST    R15,16(R13)         SAVE WORD\n         UNPK  20(9,R13),16(5,R13) UNPACK IT\n         TR    20(8,R13),SFMTRTBL-240 MAKE HEX\n         BR    R14\nSFMTRTBL DC    C'0123456789ABCDEF'\n*\n**       ROUTINE TO FORMAT VALUE IN R15 IN DECIMAL\n**\n**       INPUT\n**             R5   -->   AREA TO PUT CONVERTED STRING\n**             R15  ===   VALUE TO CONVERT TO DECIMAL\n**\n**       OUTPUT\n**             R5   -->   NEXT OPEN BYTE\n*\nSFMDEC   DS    0H\n         ST    R15,16(R13)         SAVE WORD\n         MVC   20(15,R13),=XL15'4020206B2020206B2020206B202120'\n         LA    R1,44(R13)          GET ADDRESS\n         N     R1,=XL4'FFFFFFF8'   GET DOUBLE WORD OFFSET\n         CVD   R15,0(R1)           MAKE DECIMAL\n         ED    20(15,R13),2(R1)    MAKE CHARACTER\n         LA    R15,15              NUMBER TO DO\n         LA    R1,20(R13)          POINT AT STRING\nSFMDEC1  CLI   0(R1),C' '          IS IT BLANK\n         BNE   SFMDEC2             NOPE SO MOVE IT\n         LA    R1,1(R1)            MOVE PTR\n         BCT   R15,SFMDEC1         KEEP GOING\n         BR    R14                 EXIT **IMPOSSIBLE ALL BLANK**\nSFMDEC2  BCTR  R15,0               GET MACHINE LENGTH\n         EX    R15,SFMDEC9         MOVE IN DATA\n         LA    R5,1(R5,R15)        POINT TO NEXT BYTE\n         BR    R14\nSFMDEC9  MVC   0(0,R5),0(R1)       MOVE IN STRING\n         LTORG\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$BFGMSGD": {"ttr": 1025, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x82\\x12\\x7f\\x00\\x82\\x19\\x7f\\x14\\x13\\x00\\x17\\x00\\x17\\x00\\x07\\xc7\\xe4\\xe8@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1982-05-07T00:00:00", "modifydate": "1982-07-16T14:13:00", "lines": 23, "newlines": 23, "modlines": 7, "user": "GUY"}, "text": "         MACRO\n         $BFGMSGD &ID,&TX,&ROUTCDE=,&DESC=(7)\n.**********************************************************************\n.*                                                                    *\n.*       THIS MACRO ALLOWS THE DEFINITION OF MESSAGES TO BE PROCESSED *\n.*       BY THE NEW MESSAGE PROCESSOR.                                *\n.*                                                                    *\n.*                                                                    *\n.*                                                                    *\n.**********************************************************************\n         GBLB  &MSGFRST\n         AIF   (&MSGFRST).SKIP\nBFGIMSG  CSECT\n         DC    A(BFGTMSG)          FIRST WORD POINTS TO SECOND CSECT\n&MSGFRST SETB  1\n.SKIP    ANOP\nBFGIMSG  CSECT\nMSG&ID.ID EQU  *-BFGIMSG           GET OFFSET\n         DC    AL2(MSG&ID.T-BFGTMSG),CL2'&ID' GET OFFSET AND ID\nBFGTMSG  CSECT\nMSG&ID.T WTO   &TX,ROUTCDE=&ROUTCDE,DESC=&DESC,MF=L\n&SYSECT  CSECT\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$DLOOK": {"ttr": 1027, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x04\\x00\\x903/\\x01\\x19\\x04?\\x156\\x00;\\x00)\\x00\\x16\\xc7\\xe4\\xe8@@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1990-11-28T00:00:00", "modifydate": "2019-02-12T15:36:04", "lines": 59, "newlines": 41, "modlines": 22, "user": "GUY"}, "text": "LOOK\n\nThis program has its roots in the old DCMS (Dirt Cheap Monitor System)\nprogram package (as was DIDOCS and CSAMON). It has been made a stand-\nalone program with its own screen handling.  The basic purpose that it\nserves is to provide the ability to display core interactively and\nin real time.  To that end it also supports the ability to display any\nmemory in any address space if it is run authorized.  As an aid to\nthe programmers that may use it, it will format MVS control blocks\nin a semi-reasonable format (in pairs of name suffix, data). The\noriginal version of LOOK requried a generated entry for each item\ndisplayed on the screen.  This seemed an unnecessarily time wasting\nand error prone event. A set of macros was written to automate the\ngeneration of the display information necessary from the DSECT expansion\nof the real macro. Thus adding a new control block is as easy as\nadding 3 statements to the control block module.\n\nI would like to thank the original authors of the DCMS system for\nthe original idea of LOOK. Any perceived distortions of their intent\nwas due to my needs.\n\n\nGUY L. ALBERTELLI             (this is an old address)\nB F Goodrich CO.\nD/2223                        Contact Sam Golob if you have any\n9911 Brecksville Rd.          questions:\nBrecksville, OH 44141-3247\n                              email:  sbgolob@cbttape.org\n216-447-5543\n\n***********************************************************************\n\nChanges\n        6/1/88  -  Fix problems with displaying core that really\n         (1.1)     doesn't exist.\n                -  Also fix control block output of char strings\n                   to translate data - thanks to Mr. S. Golob of Newseek\n                -  Support XA via a GLOBAL set symbol\n      11/28/90  -  Added support from Bruce Bordonaro of Pershing\n                   for many more control block formats.\n                         -->  Thanks a lot, Bruce  <--\n                -  Improved error recovery during memory fetch.\n\n      Changes by Joe Reichman during 2017, to eliminate (hopefully)\n      S0C4 abends when reading \"BAD ADDRESSES\", and to modernize\n      the cross-memory access, using the IEAMSCHD macro instead of\n      the SCHEDULE macro, when running the SRB's.\n\n      02/11/19  -  Change by Joe Reichman to get all CSA storage\n                   in Key 0, so as not to try and get user key CSA.\n                   This change forces LOOK to always be authorized.\n                   In modern systems, I guess it is a small price\n                   to pay, for the continuation of the functionality.\n                   From z/OS 2.4 and onward, it will become impossible\n                   to get CSA in a user key.  And even before that,\n                   you have to flip two bits (using the DIAGxx\n                   PARMLIB member, or our TSO commad, UKEYCSA,\n                   presented in this file), to allow user key CSA.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$IJLOG": {"ttr": 1029, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x884O\\x00\\x884O\\x10\"\\x00\\x08\\x00\\x08\\x00\\x01\\xe2\\xc1\\xd3\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-12-09T00:00:00", "modifydate": "1988-12-09T10:22:00", "lines": 8, "newlines": 8, "modlines": 1, "user": "SALBERT"}, "text": "//SALBERTK JOB (U32048,17F),GUY,CLASS=R,MSGCLASS=T,NOTIFY=SALBERT\n//*\n//JLOG    EXEC ASMFCL,MAC1='SYS1.AMODGEN'\n//ASM.SYSLIB DD\n//           DD\n//           DD DSN=SFT.INSTALL.FILE264,DISP=SHR\n//ASM.SYSIN  DD DSN=SFT.INSTALL.FILE264(JLOG),DISP=SHR\n//LKED.SYSLMOD DD DSN=** YOURLIB **(JLOG),DISP=SHR      <== CHANGE THIS\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$ILOOK": {"ttr": 1031, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x86\\x17\\x1f\\x00\\x86\\x17/\\x16\\t\\x00\\t\\x00\\t\\x00\\x02\\xe2\\xc1\\xd3\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1986-06-20T00:00:00", "modifydate": "1986-06-21T16:09:00", "lines": 9, "newlines": 9, "modlines": 2, "user": "SALBERT"}, "text": "//SALBERTK JOB (U32048,17F),GUY,CLASS=R,MSGCLASS=T,NOTIFY=SALBERT\n//*\n//LOOK    EXEC ASMHC,MAC1='SYS1.AMODGEN'\n//ASM.SYSIN DD DSN=SFT.LOOK.INSTALL(LOOK),DISP=SHR\n//*\n//CBMACS  EXEC ASMHCL,MAC1='SYS1.AMODGEN',COND.LKED=(0,LT),\n//    PARM.LKED='LET,LIST,XREF,NCAL,AC=1'\n//ASM.SYSIN DD DSN=SFT.LOOK.INSTALL(CBMACS),DISP=SHR\n//LKED.SYSLMOD DD DSN=** YOURLIB **(LOOK),DISP=SHR      <== CHANGE THIS\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#DUDASD": {"ttr": 1033, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86\\x14\\x1f\\x00\\x86\\x14\\x1f\\x16\\x14\\x00\\x11\\x00\\x11\\x00\\x00\\xe2\\xd9\\xe4\\xc4\\xc4\\xd3\\xc5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-05-21T00:00:00", "modifydate": "1986-05-21T16:14:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "SRUDDLE"}, "text": ")F FUNCTION -\n   THE DUDASD COMMAND DISPLAYS ALL DASD DEVICES\n   DEFINED IN THE SYSTEM, WITH THE FOLLOWING DATA :\n     -  VOLUME ID, IF ONLINE\n     -  ALLOCATION STATUS, AS FOLLOWS :\n        -  O - UNALLOCATED\n        -  A - ALLOCATED\n        -  P - OFFLINE PENDING\n     -  RESERVED INDICATION, IF THE TSO SYSTEM HAS\n        SUCCESSFULLY RESERVED THE DEVICE\n     -  VOLUME STATUS\n        -  RSV - RESERVED ON THE SYSTEM\n        -  RSD - SYSTEM REDIDENT\n)X SYNTAX -\n         DUDASD\n)O OPERANDS -\n  THERE ARE NO OPERANDS ON THE DUDASD COMMAND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FILE264": {"ttr": 1035, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04a\\x00!\\x01\\x19\\t\\x7f\\x01\\x19\\t\\x7f\\x11\\x08\\x00\\x98\\x00\\x98\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf7@@@'", "ispf": {"version": "04.97", "flags": 0, "createdate": "2019-04-07T00:00:00", "modifydate": "2019-04-07T11:08:21", "lines": 152, "newlines": 152, "modlines": 0, "user": "CBT-497"}, "text": "//***FILE 264 is from Guy Albertelli in Akron, Ohio, and contains   *   FILE 264\n//*           several TSO command processors.  A load module for    *   FILE 264\n//*           LOOK is on File 035 of the CBT Tape, and several      *   FILE 264\n//*           of them are included in the LOADLIB member in this    *   FILE 264\n//*           pds, which is in TSO XMIT format.  LOOKN, which is    *   FILE 264\n//*           our 64-bit version of LOOK, is finally out, and is    *   FILE 264\n//*           included here.  Much worth \"look\"ing at.              *   FILE 264\n//*                                                                 *   FILE 264\n//*       Please send inquiries and questions to Sam Golob.         *   FILE 264\n//*                                                                 *   FILE 264\n//*       email:  sbgolob@cbttape.org                               *   FILE 264\n//*                                                                 *   FILE 264\n//*       Please read the $$NOTExx members before assembling the    *   FILE 264\n//*       LOOK command with anything other than the defaults.       *   FILE 264\n//*       An example for coding your own macro definitions can      *   FILE 264\n//*       be found by looking at members CBMACSE and LOOK$$$.       *   FILE 264\n//*                                                                 *   FILE 264\n//*       LOOK or LOOKN is the \"driver program\" for CBMACS, which   *   FILE 264\n//*       formats macro layouts.  Any version of LOOK can drive     *   FILE 264\n//*       any version of CBMACS (I think).  They are put together   *   FILE 264\n//*       at assembly time.  So look carefully at the assembly JCL. *   FILE 264\n//*                                                                 *   FILE 264\n//*           The command processors are:                           *   FILE 264\n//*                                                                 *   FILE 264\n//*             A  LOOKN   -  The 64-bit version of LOOK. 10 years  *   FILE 264\n//*                           in coming out.  Must run authorized.  *   FILE 264\n//*                           Details are almost the same as in     *   FILE 264\n//*                           LOOKJ below. Indirect addressing for  *   FILE 264\n//*                           8-byte (64-bit) addresses, is done    *   FILE 264\n//*                           with a \"G\" command instead of \"J\".    *   FILE 264\n//*                           (Much of the work was done by         *   FILE 264\n//*                            Joe Reichman.  Thanks, Joe.)         *   FILE 264\n//*                                                                 *   FILE 264\n//*             1  LOOKJ   -  LOOK is a TSO command processor that  *   FILE 264\n//*                           allows full screen display of real    *   FILE 264\n//*                           time memory, in any address space.    *   FILE 264\n//*                           The LOOK command has been enhanced    *   FILE 264\n//*                           to make it easy to add new control    *   FILE 264\n//*                           block maps, usually in 3 or 4         *   FILE 264\n//*                           statements.                           *   FILE 264\n//*                                                                 *   FILE 264\n//*                           This is a new version of LOOK,        *   FILE 264\n//*                           designed to eliminate the S0C4        *   FILE 264\n//*                           abends which LOOK gets on z/OS 2.x    *   FILE 264\n//*                           if a bad address is entered.          *   FILE 264\n//*                           (Fixed by Joe Reichman)               *   FILE 264\n//*                                                                 *   FILE 264\n//*                           Very importantly, this version of     *   FILE 264\n//*                           LOOK can be run without getting       *   FILE 264\n//*                           user key CSA.                         *   FILE 264\n//*                                                                 *   FILE 264\n//*                           Downside is that this version must    *   FILE 264\n//*                           be run APF-authorized always.         *   FILE 264\n//*                                                                 *   FILE 264\n//*                           But importantly, you do not need      *   FILE 264\n//*                           to set in PARMLIB DIAGxx member:      *   FILE 264\n//*                           VSM ALLOWUSERKEYCSA(NO) , because     *   FILE 264\n//*                           this version of LOOKJ does not        *   FILE 264\n//*                           obtain user key CSA.  It now gets     *   FILE 264\n//*                           its working storage in Key 0.         *   FILE 264\n//*                                                                 *   FILE 264\n//*                LOOK0x  -  Earlier versions of LOOK (source)     *   FILE 264\n//*                                                                 *   FILE 264\n//*                The LOADLIB contains a version of LOOK which     *   FILE 264\n//*                was assembled against modified IBM macros that   *   FILE 264\n//*                I could not include here, and it formats the     *   FILE 264\n//*                TPVT control block, off the TSVT control block.  *   FILE 264\n//*                It also cleans up the display of macro IKJEFLWA  *   FILE 264\n//*                so that most fields display clearly.             *   FILE 264\n//*                                                                 *   FILE 264\n//*                Members in the LOADLIB XMIT file:                *   FILE 264\n//*                                                                 *   FILE 264\n//*                LOOK    - Assembled with member LOOK$$$          *   FILE 264\n//*                          (current version)                      *   FILE 264\n//*                LOOKX   - Assembled with member LOOK$$           *   FILE 264\n//*                          (current version)                      *   FILE 264\n//*                LOOK1   - Old version of LOOK, before Joe's      *   FILE 264\n//*                          fixes. Subject to S0C4 abends          *   FILE 264\n//*                          in z/OS 2.x                            *   FILE 264\n//*                UKEYCSA - TSO command to flip the bits that      *   FILE 264\n//*                          allow/disallow user key CSA.           *   FILE 264\n//*                          Program only good from z/OS 1.8        *   FILE 264\n//*                          thru z/OS 2.3.  Won't work in 2.4.     *   FILE 264\n//*                                                                 *   FILE 264\n//*            (The LOOK command is a \"MUST\" to know about - SG)    *   FILE 264\n//*                                                                 *   FILE 264\n//*            Important note, for the LOOK command to work:        *   FILE 264\n//*            --------- ----  --- --- ---- ------- -- ----         *   FILE 264\n//*               The newest version of LOOKJ does not obtain       *   FILE 264\n//*               CSA storage in a user key, so it does not         *   FILE 264\n//*               depend on the PARMLIB setting, mentioned          *   FILE 264\n//*               below, which will go away anyway, in z/OS         *   FILE 264\n//*               2.4.                                              *   FILE 264\n//*                                                                 *   FILE 264\n//*               However, for earlier versions of LOOK, which      *   FILE 264\n//*               obtained user key CSA, there is a dependency      *   FILE 264\n//*               on a PARMLIB setting to allow user key CSA.       *   FILE 264\n//*                                                                 *   FILE 264\n//*               This issue only starts with z/OS 1.8. !!!!!       *   FILE 264\n//*               The PARMLIB setting is in the DIAGxx member:      *   FILE 264\n//*                                             ****                *   FILE 264\n//*               >>>>>>>>  VSM ALLOWUSERKEYCSA(YES)   <<<<<<<<     *   FILE 264\n//*                                                                 *   FILE 264\n//*               This was the default at z/OS 1.8, but in          *   FILE 264\n//*               z/OS 1.9, VSM ALLOWUSERKEYCSA(NO) became the      *   FILE 264\n//*               default.  It now has to be specifically set to    *   FILE 264\n//*               VSM ALLOWUSERKEYCSA(YES), or LOOK will abend      *   FILE 264\n//*               with a SB0A, reason code 5C.                      *   FILE 264\n//*            -------------------------------------------------    *   FILE 264\n//*            For commercial installations, it is probably         *   FILE 264\n//*            unsafe to set VSM ALLOWUSERKEYCSA(YES) in the        *   FILE 264\n//*            active DIAGxx member of PARMLIB.  It leaves a bit    *   FILE 264\n//*            too much of a security hole.  So you should set      *   FILE 264\n//*            VSM ALLOWUSERKEYCSA(NO).  But in a pinch, if         *   FILE 264\n//*            you just HAVE to use the LOOK command, there is      *   FILE 264\n//*            an APF-authorized TSO command called UKEYCSA that    *   FILE 264\n//*            has been supplied, which can flip the controlling    *   FILE 264\n//*            bits temporarily, to temporarily allow (globally)    *   FILE 264\n//*            CSA to be allocated in a User Storage Key, just so   *   FILE 264\n//*            you can use LOOK, and then you can set it back       *   FILE 264\n//*            so the system will no longer allow User Key storage  *   FILE 264\n//*            allocation in CSA.  UKEYCSA Y and then UKEYCSA N.    *   FILE 264\n//*                                                                 *   FILE 264\n//*            UKEYCSA will only work in z/OS versions from 1.8     *   FILE 264\n//*            thru 2.3.  It will stop working in z/OS 2.4.         *   FILE 264\n//*            -------------------------------------------------    *   FILE 264\n//*    NOTE:   THE NEW SOURCE FOR LOOKJ DOES NOT GET USER KEY CSA,  *   FILE 264\n//*            SO IT DOES NOT DEPEND ON THE ABOVE PARMLIB SETTING.  *   FILE 264\n//*            -------------------------------------------------    *   FILE 264\n//*            See member $$NOTE02 for assembling fields present    *   FILE 264\n//*              in IBM macros, but which are not shown by the      *   FILE 264\n//*              formatting program CBMACS.  What to do?            *   FILE 264\n//*            See member called LOADLIB for load modules.          *   FILE 264\n//*            -------------------------------------------------    *   FILE 264\n//*                                                                 *   FILE 264\n//*             2 DUDASD      AN UPDATED VERSION FROM FILE 300 OF   *   FILE 264\n//*                           THIS TAPE THAT HAS BEEN CONVERTED     *   FILE 264\n//*                           TO FUNCTION UNDER EITHER SP OR XA.    *   FILE 264\n//*                                                                 *   FILE 264\n//*                           (Fixed by Albert Cheng (CBT File 612) *   FILE 264\n//*                           for 4-digit unit addresses and other  *   FILE 264\n//*                           matters.  DUDASD00 is the original    *   FILE 264\n//*                           version.  JVD***** macros copied here *   FILE 264\n//*                           for completeness, even if not used by *   FILE 264\n//*                           the newer version of the program.)    *   FILE 264\n//*                                                                 *   FILE 264\n//*             3 JLOG        A PROGRAM TO PRINT OUT THE JES JOBLOG *   FILE 264\n//*                           AND OR ANY OTHER JES DATASETS, EVEN   *   FILE 264\n//*                           IF THEY ARE QUEUED TO A DUMMY CLASS.  *   FILE 264\n//*                           USEFUL IN OBTAINING THE JOBLOG OF     *   FILE 264\n//*                           ABENDING STARTED TASKS.               *   FILE 264\n//*                                                                 *   FILE 264\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CBMACS": {"ttr": 1039, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01[\\x002\\x00\\x891\\x1f\\x01\\x185/\\x141\\x02\\x8e\\x01\\xe1\\x00\\xd9\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.91", "flags": 0, "createdate": "1989-11-07T00:00:00", "modifydate": "2018-12-18T14:31:32", "lines": 654, "newlines": 481, "modlines": 217, "user": "SBGOLOB"}, "text": "$DECT    OPSYN DSECT\nDSECT    OPSYN\n$CECT    OPSYN CSECT\nCSECT    OPSYN\n$C       OPSYN DC\nDC       OPSYN\n$S       OPSYN DS\nDS       OPSYN\n         MACRO\n&LBL     DSECT\n.*\n.**      THIS MACRO SAVES THE INDICATOR THAT THE CURRENT SECTION IS A\n.**      DSECT\n.*\n         GBLC  &SECTYP\n         GBLC  &BKBASE,&BKNAME\n         GBLB  &$1DSECT\n         LCLA  &I\n         AIF   ('&LBL' EQ '&BKNAME' AND NOT &$1DSECT).OK\n         AIF   (NOT &$1DSECT).OK\n&LBL     BKSEG\n&BKBASE  SETC  '&LBL'\n.OK      ANOP\n&$1DSECT SETB  1\n&LBL     $DECT\n&SECTYP  SETC  '$DECT'\n         MEND\n         MACRO\n&LBL     CSECT\n.*\n.**      THIS MACRO SAVES THE INDICATOR THAT THE CURRENT SECTION IS A\n.**      CSECT\n.*\n         GBLC  &SECTYP\n&SECTYP  SETC  '$CECT'\n&LBL     $CECT\n         MEND\n         EJECT\n         MACRO\n&LBL     DC\n.*\n.**      THIS MACRO GENERATES NECESSARY FIELDS FOR A DC IN A DSECT\n.*\n         GBLC  &SECTYP,&PRFX,&BKBASE\n         GBLC  &$SEGL,&$SEGST,&$SEGO\n         GBLA  &$LN,&$CO\n         GBLC  &GQ1,&GQ2,&GQ3\n         LCLA  &J,&K,&NSYSL,&LN\n         LCLA  &OLN,&OCO\n         LCLC  &ID,&TY,&C,&D\n&NSYSL   SETA  N'&SYSLIST\n&LBL     $C    &SYSLIST(1)\n&J       SETA  2\n.DCLP    AIF   (&J GT &NSYSL).DONE\n         $C    &SYSLIST(&J)\n&J       SETA  &J+1\n         AGO   .DCLP\n.DONE    ANOP\n.*\n.*       GET LABEL IDENTIFIER\n.*\n&K       SETA  K'&PRFX\n&J       SETA  K'&LBL\n         AIF   (&J LT &K+1).NOGO\n&ID      SETC  '&LBL'(&K+1,&J-&K)\n         AIF   ('&ID'(1,2) EQ 'RV').NOGO\n         AIF   ('&ID'(1,3) EQ 'RSV').NOGO\n.*\n.*       GET OPERAND TYPE\n.*\n&J       SETA  1\n&K       SETA  1\n.LP1     ANOP\n&C       SETC  '&SYSLIST(&K)'(&J,1)\n         AIF   ('&C' EQ '0').SECTYP          IS IT ZERO REP FACTOR\n         AIF   ('&C' EQ '(').SKPREP          IS IT REAL REP FACTOR\n         AIF   ('&C' LT '0').HALPHA          IF ALPHA THEN TYPE CODE\n.LP1E    ANOP\n&J       SETA  &J+1\n         AGO   .LP1\n.SKPREP  ANOP\n&J       SETA  &J+1\n&C       SETC  '&SYSLIST(&K)'(&J,1)\n         AIF   ('&C' EQ ')').LP1E            GO BACK IN LOOK\n         AGO   .SKPREP\n.SECTYP  ANOP                                GET SECOND TYPE DEF\n&K       SETA  &K+1\n&J       SETA  1\n         AIF   (&K LE &NSYSL).LP1\n.* CANT FIND TYPE SO QUIT THIS ONE\n         AGO   .NOGO\n.HALPHA  ANOP\n&TY      SETC  '&C'\n.*\n.*       NOW VALIDATE TYPE OF CONSTANT\n.*\n         AIF   ('&TY' EQ 'C').GOTLN1\n         AIF   ('&TY' EQ 'X').GOTLN1\n         AIF   ('&TY' EQ 'B').GOTLN1\n         AIF   ('&TY' EQ 'P').GOTLN1\n         AIF   ('&TY' EQ 'H').GOTLN2\n         AIF   ('&TY' EQ 'S').GOTLN2\n         AIF   ('&TY' EQ 'Y').GOTLN2\n         AIF   ('&TY' EQ 'F').GOTLN4\n         AIF   ('&TY' EQ 'A').GOTLN4\n         AIF   ('&TY' EQ 'V').GOTLN4\n         AIF   ('&TY' EQ 'E').GOTLN4\n         AIF   ('&TY' EQ 'D').GOTLN8\n         MNOTE 8,'UNKNOWN TYPE &TY ON LABEL &LBL'\n.GOTLN1  ANOP\n&LN      SETA  1\n         AGO   .GOTLN\n.GOTLN2  ANOP\n&LN      SETA  2\n         AGO   .GOTLN\n.GOTLN4  ANOP\n&LN      SETA  4\n         AGO   .GOTLN\n.GOTLN8  ANOP\n&LN      SETA  8\n         AGO   .GOTLN\n.GOTLN   ANOP\n&C       SETC  '&SYSLIST(&K)'(&J+1,1)\n         AIF   ('&C' NE 'L').HAVELN\n&J       SETA  &J+2\n&D       SETC  ''\n.LP2     ANOP\n&C       SETC  '&SYSLIST(&K)'(&J,1)\n         AIF   ('&C' LT '0').CVNLN\n&D       SETC  '&D'.'&C'\n&J       SETA  &J+1\n         AGO   .LP2\n.CVNLN   ANOP\n&LN      SETA  &D\n.HAVELN  ANOP\n.*LN     SETA  L'&LBL\n&OLN     SETA  &$LN\n&OCO     SETA  &$CO\n&$CO     SETA  &$CO+8+&LN+&LN+2\n         AIF   (&$CO LT 81).GOTPOS\n&$CO     SETA  1+8+&LN+&LN+2\n&$LN     SETA  &$LN+1\n&OLN     SETA  &$LN\n&OCO     SETA  1\n         AIF   (&$LN LT 17).GOTPOS\n         BKSEG ,\n&OLN     SETA  &$LN\n&OCO     SETA  &$CO\n&$CO     SETA  1+8+&LN+&LN+2\n.GOTPOS  ANOP\n         AIF   ('&$SEGO' EQ '').NOSEG\n&GQ1     SETC  '&LBL'\n&GQ2     SETC  '&BKBASE'\n&GQ3     SETC  '&$SEGO'\n&$SEGO   SETC  ''\n.NOSEG   ANOP\nCBBKLS   $CECT\n         $C    CL8'&ID',CL1'&TY',AL1(&LN),AL2(&LBL-&BKBASE)\n         $C    AL2(&OLN,&OCO)\n&SYSECT  &SECTYP\n         AIF   ('&$SEGST' NE '').NOGO\n&$SEGST  SETC  '&LBL'\n.NOGO    ANOP\n         MEND\n         EJECT\n         MACRO\n&LBL     DS\n.*\n.**      THIS MACRO GENERATES NECESSARY FIELDS FOR A DS IN A DSECT\n.*\n         GBLC  &SECTYP,&PRFX,&BKBASE\n         GBLC  &$SEGL,&$SEGST,&$SEGO\n         GBLA  &$LN,&$CO\n         GBLC  &GQ1,&GQ2,&GQ3\n         LCLA  &J,&K,&NSYSL,&LN\n         LCLA  &OLN,&OCO\n         LCLC  &ID,&TY,&C,&D\n&NSYSL   SETA  N'&SYSLIST\n&LBL     $S    &SYSLIST(1)\n&J       SETA  2\n.DCLP    AIF   (&J GT &NSYSL).DONE\n         $S    &SYSLIST(&J)\n&J       SETA  &J+1\n         AGO   .DCLP\n.DONE    ANOP\n.*\n.*       GET LABEL IDENTIFIER\n.*\n&K       SETA  K'&PRFX\n&J       SETA  K'&LBL\n         AIF   (&J LT &K+1).NOGO\n&ID      SETC  '&LBL'(&K+1,&J-&K)\n         AIF   ('&ID'(1,2) EQ 'RV').NOGO\n         AIF   ('&ID'(1,3) EQ 'RSV').NOGO\n.*\n.*       GET OPERAND TYPE\n.*\n&J       SETA  1\n&K       SETA  1\n.LP1     ANOP\n&C       SETC  '&SYSLIST(&K)'(&J,1)\n         AIF   ('&C' EQ '0').SECTYP          IS IT ZERO REP FACTOR\n         AIF   ('&C' EQ '(').SKPREP          IS IT REAL REP FACTOR\n         AIF   ('&C' LT '0').HALPHA          IF ALPHA THEN TYPE CODE\n&J       SETA  &J+1\n         AGO   .LP1\n.SKPREP  ANOP\n&J       SETA  &J+1\n&C       SETC  '&SYSLIST(&K)'(&J,1)\n         AIF   ('&C' EQ ')').LP1E            GO BACK IN LOOK\n         AGO   .SKPREP\n.SECTYP  ANOP\n&K       SETA  &K+1\n&J       SETA  1\n         AIF   (&K LE &NSYSL).LP1\n.* CANT FIND TYPE SO QUIT THIS ONE\n         AGO   .NOGO\n.HALPHA  ANOP\n&TY      SETC  '&C'\n.*\n.*       NOW GET THE LENGTH OF THE SYMBOL\n.*\n         AIF   ('&TY' EQ 'C').GOTLN1\n         AIF   ('&TY' EQ 'X').GOTLN1\n         AIF   ('&TY' EQ 'B').GOTLN1\n         AIF   ('&TY' EQ 'P').GOTLN1\n         AIF   ('&TY' EQ 'H').GOTLN2\n         AIF   ('&TY' EQ 'S').GOTLN2\n         AIF   ('&TY' EQ 'Y').GOTLN2\n         AIF   ('&TY' EQ 'F').GOTLN4\n         AIF   ('&TY' EQ 'A').GOTLN4\n         AIF   ('&TY' EQ 'V').GOTLN4\n         AIF   ('&TY' EQ 'E').GOTLN4\n         AIF   ('&TY' EQ 'D').GOTLN8\n         MNOTE 8,'UNKNOWN TYPE &TY ON LABEL &LBL'\n&LN      SETA  0\n.GOTLN1  ANOP\n&LN      SETA  1\n         AGO   .GOTLN\n.GOTLN2  ANOP\n&LN      SETA  2\n         AGO   .GOTLN\n.GOTLN4  ANOP\n&LN      SETA  4\n         AGO   .GOTLN\n.GOTLN8  ANOP\n&LN      SETA  8\n         AGO   .GOTLN\n.GOTLN   ANOP\n         AIF   (K'&SYSLIST(&K) LE &J).HAVELN\n&C       SETC  '&SYSLIST(&K)'(&J+1,1)\n         AIF   ('&C' NE 'L').HAVELN\n&J       SETA  &J+2\n&D       SETC  ''\n.LP2     ANOP\n&C       SETC  '&SYSLIST(&K)'(&J,1)\n         AIF   ('&C' LT '0').CVNLN\n&D       SETC  '&D'.'&C'\n&J       SETA  &J+1\n         AIF   (K'&SYSLIST(&K) GT &J).LP2\n.CVNLN   ANOP\n&LN      SETA  &D\n.HAVELN  ANOP\n.*LN     SETA  L'&LBL\n&OLN     SETA  &$LN\n&OCO     SETA  &$CO\n&$CO     SETA  &$CO+8+&LN+&LN+2\n         AIF   (&$CO LT 81).GOTPOS\n&$CO     SETA  1+8+&LN+&LN+2\n&$LN     SETA  &$LN+1\n&OLN     SETA  &$LN\n&OCO     SETA  1\n         AIF   (&$LN LT 17).GOTPOS\n         BKSEG ,\n&OLN     SETA  &$LN\n&OCO     SETA  &$CO\n&$CO     SETA  1+8+&LN+&LN+2\n.GOTPOS  ANOP\n         AIF   ('&$SEGO' EQ '').NOSEG\n&GQ1     SETC  '&LBL'\n&GQ2     SETC  '&BKBASE'\n&GQ3     SETC  '&$SEGO'\n&$SEGO   SETC  ''\n.NOSEG   ANOP\nCBBKLS   $CECT\n         $C    CL8'&ID',CL1'&TY',AL1(&LN),AL2(&LBL-&BKBASE)\n         $C    AL2(&OLN,&OCO)\n&SYSECT  &SECTYP\n         AIF   ('&$SEGST' NE '').NOGO\n&$SEGST  SETC  '&LBL'\n.NOGO    ANOP\n         MEND\n         EJECT\n         MACRO\n&LBLP    BKSTR &VAL,&OFF,&BASE,&DSECT,&SLS\n         GBLA  &BK\n.*   &BK  -  NUMBER OF CURRENT CONTROL BLOCK (USED FOR NAME GEN)\n         GBLB  &FRST,&$1DSECT\n.*   &FRST  -  TRUE IF NOT FIRST CONTROL BLOCK\n.*   &$1DSECT  -  FALSE ON FIRST DESCT IN CB, TRUE FOR SECONDARY DSECTS\n         GBLC  &PRFX,&BKBASE,&BKNAME,&ORGBSE\n.*   &PRFX  -  PREFIX OF SYMBOLS TO REMOVE\n.*   &BKBASE  -  LABEL OF OFFSET 0 IN MAIN CONTROL BLOCK/CURRENT DSECT\n.*   &BKNAME  -  DSECT NAME OF MAIN CONTROL BLOCK\n.*   &ORGBSE  -  ALWAYS NAME AT OFFSET 0 IN MAIN CONTROL BLOCK\n         GBLC  &SECTYP\n.*   &SECTYP  -  TYPE OF LAST CONTROL SECTION (DSECT/CSECT)\n         GBLC  &#SEGD(10),&#SEGO(10)\n.*   &#SEGD  -  DSECT NAMES OF SECONDARY SECTIONS\n.*   &#SEGO  -  SYMBOL IN MAIN SECTION WITH ADDRESS OF SECONDARY\n         LCLC  &PJ1,&PJ2,&PJ3,&PJ4\n         LCLA  &I,&J\n.*\n.**      BEGINNING OF CONTROL BLOCK MACRO\n.**            NEED TO CREATE AREA IN CBMACS TO INDICATE\n.**            THE START OF A NEW CONTROL BLOCK, AND ITS\n.**            VERIFICATION FIELD\n.**            &LBLP  -   NAME OF BLOCK FOR OVERLAY\n.**            &VAL   -   VALUE OF VALIDATION FIELD\n.**            &OFF   -   LABEL OF FIELD IN DSECT\n.**            &BASE  -   LABEL OF START OF MAIN BODY (GIVES OFFSET)\n.**            &DSECT -   LABEL OF DSECT OF MAIN BODY\n.**            &SLS   -   SUBLIST OF SYMBOLS AND DSECTS FOR SECONDARY\n.**                       SECTIONS\n.*\n&I       SETA  1\n.CRLP    ANOP\n&#SEGD(&I) SETC ''\n&I       SETA  &I+1\n         AIF   (&I LE 10).CRLP\n&$1DSECT SETB  0\n&PRFX    SETC  '&LBLP'\n&PJ1     SETC  'XYZ1&SYSNDX'\n&PJ2     SETC  'XYZ2&SYSNDX'\n&PJ3     SETC  'XYZ3&SYSNDX'\n&PJ4     SETC  'XYZ4&SYSNDX'\nCBMACS   $CECT\n         AIF   (NOT &FRST).SKIPNT\n         ORG   *-4                     BACK UP OVER PREVIOUS FULL WORD\n.SKIPNT  ANOP\n&FRST    SETB  1\n&BK      SETA  &BK+1\n&BKBASE  SETC  '&BASE'\n&ORGBSE  SETC  '&BASE'\n&BKNAME  SETC  '&DSECT'\n         $C    A(&PJ3)                 ADDRESS OF NEXT CONTROL BLOCK\n         $C    A(&OFF-&BASE)           OFFSET TO VALIDATION FIELD\n         $C    A(&PJ4)                 ADDR OF BLOCK IN CBBLKS\n         $C    CL8'&LBLP'              NAME OF BLOCK FOR OVERLAY\n         $C    AL1(&PJ2-&PJ1)          LENGTH OF VALIDATION VALUE\n&PJ1     $C    &VAL                    VALIDATION VALUE\n&PJ2     EQU   *\n&PJ3     $C    F'0'                    IF THIS FIELD IS ZERO THEN\n*                                      THIS IS LAST BLOCK\nCBBKLS   $CECT\n&PJ4     $S    0F\n&SYSECT  &SECTYP\n         AIF   (N'&SLS EQ 0).NOSECS\n&I       SETA  1\n&J       SETA  1\n.SETLP   ANOP\n&#SEGO(&J) SETC '&SLS(&I)'\n&#SEGD(&J) SETC '&SLS(&I+1)'\n&I       SETA  &I+2\n&J       SETA  &J+1\n         AIF   (&I LT N'&SLS).SETLP\n.NOSECS  ANOP\n         BKSEG NEW\n         MEND\n         EJECT\n         MACRO\n&NBS     BKSEG &TYPE\n         GBLA  &NXTSEG,&BK\n         GBLA  &$LN,&$CO\n         GBLC  &$SEGL,&$SEGST,&$SEGO\n         GBLC  &SECTYP\n         GBLC  &#SEGD(10),&#SEGO(10)\n         GBLC  &BKBASE,&BKNAME,&ORGBSE\n         GBLC  &GQ1,&GQ2,&GQ3\n         LCLA  &J,&K\n         LCLC  &PJ0,&PJ1,&PJ2,&PJ3,&PJ4\n         AIF   ('&TYPE' NE 'NEW').NOTNEW\n&NXTSEG  SETA  2\n&PJ0     SETC  'ZZS1&BK'\n&PJ1     SETC  'ZZSZ&BK'\n&PJ2     SETC  'ZZS2&BK'\n&PJ3     SETC  'ZZP1&BK'\n&PJ4     SETC  'ZZQ1&BK'\n         AGO   .ALDN\n.NOTNEW  ANOP\n&GQ3     EQU   &GQ1-&GQ2               OFFSET OF FIRST PIECE OF DATA\n&$SEGL   EQU   *-&$SEGST               FINISH OFF PREVIOUS SEGMENT\n&J       SETA  &NXTSEG+1               GET NEXT SEGMENT NUMBER\n&K       SETA  &NXTSEG-1               GET PREVIOUS SEGMENT NUMBER\n&PJ0     SETC  'ZZS&NXTSEG&BK'         CURRENT LABEL\n&PJ1     SETC  'ZZS&K&BK'              PREVIOUS LABEL\n&PJ2     SETC  'ZZS&J&BK'              NEXT LABEL\n&PJ3     SETC  'ZZP&NXTSEG&BK'\n&PJ4     SETC  'ZZQ&NXTSEG&BK'\n&NXTSEG  SETA  &NXTSEG+1\nCBBKLS   $CECT\n         $C    XL4'00'                 END PREVIOUS SEGMENT FIELDS\n.ALDN    ANOP\n&$LN     SETA  1\n&$CO     SETA  1\n&$SEGST  SETC  ''                      SET SEGMENT START TO NULL\n&$SEGL   SETC  '&PJ3'                  SET LABEL FOR EQU\n&$SEGO   SETC  '&PJ4'                  SET LABEL FOR EQU\nCBBKLS   $CECT\n&PJ0     $C    A(&PJ1)                 PREVIOUS SEGMENT ADDR\n         $C    A(&PJ2)                 NEXT SEGMENT ADDR\n         $C    AL2(&PJ3)               LENGTH OF DATA TO FETCH\n         $C    AL2(&PJ4)               OFFSET OF DATA FROM START OF CB\n         AIF   ('&NBS' EQ '').SETZERO\n&J       SETA  1\n.LKLP    ANOP\n         AIF   ('&NBS' EQ '&#SEGD(&J)').SETFND SEE IF FOUND SEGMENT\n&J       SETA  &J+1\n         AIF   (&J LE 10).LKLP         KEEP GOING FOR ALL ENTRIES\n         AGO   .SETZERO\n.SETFND  $C    AL2(4)\n         $C    AL2(&#SEGO(&J)-&ORGBSE)\n         AGO   .SETDONE\n.SETZERO $C    AL2(0,0)\n.SETDONE ANOP\n&SYSECT  &SECTYP\n         MEND\n         EJECT\n         MACRO\n         BKEND\n         GBLC  &SECTYP\n         GBLC  &$SEGL,&$SEGST\n         GBLA  &NXTSEG,&BK\n         GBLC  &GQ1,&GQ2,&GQ3\n         LCLA  &J\n         LCLC  &PJ1\n.*\n.**      END OF CONTROL BLOCK MACRO\n.*\n&GQ3     EQU   &GQ1-&GQ2               OFFSET OF FIRST PIECE OF DATA\n&$SEGL   EQU   *-&$SEGST\nCBBKLS   $CECT\n         $C    XL4'00'                 END PREVIOUS SEGMENT FIELDS\n&PJ1     SETC  'ZZS&NXTSEG&BK'\n&PJ1     EQU   ZZS1&BK\n&J       SETA  &NXTSEG-1\nZZSZ&BK  EQU   ZZS&J&BK\n&SYSECT  &SECTYP\n         MEND\n         EJECT\nDUMMY    CSECT\nDUMMY    AMODE 31\nDUMMY    RMODE ANY\nCBBKLS   AMODE 31\nCBBKLS   RMODE ANY\nCBMACS   AMODE 31\nCBMACS   RMODE ANY\n         PRINT GEN\nCVT      BKSTR XL4'0A0307FE',CVTEXIT,CVT,CVT,                          X\n               (CVTSMEXT,CVTVSTGX,                                     X\n               CVTEXT1,CVTXTNT1,                                       X\n               CVTEXT2,CVTXTNT2)\n         CVT   DSECT=YES,LIST=YES\n         BKEND\nACEE     BKSTR CL4'ACEE',ACEEACEE,ACEE,ACEE\n         IHAACEE  ,\n         BKEND\nASCB     BKSTR CL4'ASCB',ASCBASCB,ASCB,ASCB\n         IHAASCB LIST=YES,DSECT=YES ,\n         BKEND\nASSB     BKSTR CL4'ASSB',ASSBASSB,ASSB,ASSB\n         IHAASSB LIST=YES ,\n         BKEND\nASTE     BKSTR X'DEADFACE',ASTE,ASTE,ASTE\n         IHAASTE DSECT=YES ,\n         BKEND\nASVT     BKSTR C'ASVT',ASVTASVT,ASVT,ASVT\n         IHAASVT LIST=YES,DSECT=YES ,\n         BKEND\nASXB     BKSTR CL4'ASXB',ASXBASXB,ASXB,ASXB\n         IHAASXB  ,\n         BKEND\nBA       BKSTR CL4'MSER',BACBID,BASE,BASE\n         IEEBASEA ,\n         BKEND\nCD       BKSTR X'DEADFACE',CDCHAIN,CDENTRY,CDENTRY\n         IHACDE   EDCDSECT=YES ,\n         BKEND\nCIB      BKSTR X'DEADFACE',CIBNEXT,CIB,CIB\nCIB      DSECT\n         IEZCIB   ,\n         BKEND\n*********************************************************************\n*    THE FOLLOWING MACRO CHANGED W/ ESA 4.2 (REMOVED ID FIELD).\n*********************************************************************\n*    CH       BKSTR CL4'CSCB',CHCSIDSH,CSCB,CSCB\nCH       BKSTR X'DEADFACE',CHAIN,CSCB,CSCB\nCSCB     DSECT\n         IEECHAIN ,\n         BKEND\n*********************************************************************\n*    THE FOLLOWING MACROS REQUIRE THE PVTMACS LIBRARY  (ESA 4.1)\n*********************************************************************\n*    CSD      BKSTR CL4'CSD ',CSDCSD,CSD,CSD\n*             IHACSD   ,\n*             BKEND\n*********************************************************************\nDCE      BKSTR X'DEADFACE',DCELEN,DCE,DCE\n         IECDDCE  ,\n         BKEND\nECVT     BKSTR CL4'ECVT',ECVTECVT,ECVT,ECVT\n         IHAECVT DSECT=YES,LIST=YES    ,\n         BKEND\nENFCT    BKSTR CL4'ENFC',ENFCTID,ENFCT,ENFCT\n         IEFENFCT ,\n         BKEND\nGDA      BKSTR CL4'GDA ',GDAID,GDA,GDA\n         IHAGDA   ,\n         BKEND\n*********************************************************************\n*    THE FOLLOWING MACROS REQUIRE THE PVTMACS LIBRARY\n*********************************************************************\n*    GVT      BKSTR CL4'GVT ',GVTID,GVT,GVT\n*             ISGGVT   ,\n*             BKEND\n*    GVTX     BKSTR CL4'GVTX',GVTXID,GVTX,GVTX\n*             ISGGVTX  ,\n*             BKEND\n*********************************************************************\nJCT      BKSTR CL4'JCT',JCTJCT,JCT,JCT\nJCT      DSECT\nJCTXXX1  DS    F\nJCTXXX2  DS    F\nJCTXXX3  DS    F\nJCTJCT   DC    CL4'JCT'\n         IEFAJCTB ,\n         BKEND\nJES      BKSTR CL4'JEST',JESCTID,JESCT,JESCT,                          X\n               (JESCTEXT,JESPEXT)\n         IEFJESCT TYPE=DUM    *** TO FORCE REASONABLE EXPANSION\n         BKEND\nJSCB     BKSTR X'DEADFACE',JSCRSV01,IEZJSCB,IEZJSCB\n         IEZJSCB  ,\n         BKEND\n*JMR      BKSTR X'DEADFACE',JMRJOB,JMR,JMR\n*         IEFJMR JMRESEP=N\n*         BKEND\n*   TO FIX THIS, MAKE A COPY OF IEFJMR AND DELETE THE LAST LINE,\n*   WHICH SAYS:  JMR   DSECT\nLCT      BKSTR CL8'ENDOFLCT',LCTLABEL,LCT,LCT\nLCT      DSECT    ,\n         IEFALLCT ,\n         BKEND\nLDA      BKSTR CL4'LDA',LDAID,LDA,LDA\n         IHALDA   ,\n         BKEND\n*********************************************************************\n*    THE FOLLOWING MACROS REQUIRE THE PVTMACS LIBRARY\n*********************************************************************\n*    MPFT     BKSTR CL4'MPFT',MPFTACRN,MPFT,MPFT\n*             IEEZB809 ,\n*             BKEND\n*********************************************************************\nMTT      BKSTR CL4'MTT ',MTTID,MTTABLE,MTTABLE\n         IEEZB806 ,\n         BKEND\nLPDE     BKSTR X'DEADFACE',LPDECHN,LPDE,LPDE\n         IHALPDE   EDCDSECT=YES ,\n         BKEND\nOUCB     BKSTR CL4'OUCB',OUCBNAME,OUCB,OUCB\n         IRAOUCB  ,\n         BKEND\nOUXB     BKSTR CL4'OUXB',OUXBNAME,OUXB,OUXB\n         IHAOUXB  ,\n         BKEND\nPCCB     BKSTR CL4'PCCB',PCCACRO,IEFPCCB,IEFPCCB\n         IEFPCCB  ,\n         BKEND\nPPT      BKSTR CL4'PPT ',PPTID,PPT,PPT\n         IEFZB610 ,\n         BKEND\nPSA      BKSTR X'040C0000',FLCIPPSW,PSA,PSA\n         IHAPSA LIST=YES\n         BKEND\nPSCB     BKSTR X'DEADFACE',PSCBUSER,PSCB,PSCB\n         IKJPSCB  ,\n         BKEND\nRB       BKSTR X'DEADFACE',RBEXRTNM,RBBASIC,RBBASIC\n         IHARB    ,\n         BKEND\n         PRINT GEN\nRCVT     BKSTR CL4'RTSS',RCVTID,RCVT,RCVT  *** ACRONYM FOR TOP SECRET\n         ICHPRCVT , NEED A COPY OF MACRO (REMOVE RCVTSNTD DSECT)\n         BKEND\n         PRINT GEN\n*********************************************************************\n*    THE FOLLOWING MACROS REQUIRE THE PVTMACS LIBRARY\n*********************************************************************\n*    RCT      BKSTR CL4'RCT ',RCTRCT,RCT,RCT\n*             IRARCT   ,\n*             BKEND\n*    RTCT     BKSTR CL4'RTCT',RTCTNAME,RTCT,RTCT\n*             IHARTCT  ,\n*             BKEND\n*********************************************************************\nSCCB     BKSTR X'DEADFACE',SCCBHEAD,SCCB,SCCBSCPI\n         IHASCCB ,\n         BKEND\nSSIB     BKSTR CL4'SSIB',SSIBID,SSIB,SSIB\n         IEFJSSIB ,\n         BKEND\nSSOB     BKSTR CL4'SSOB',SSOBID,SSOB,SSOB\n         IEFSSOBH ,\n         BKEND\nSCVT     BKSTR X'DEADFACE',SCVTPGTM,SCVTSECT,SCVTSECT\n         IHASCVT  ,\n         BKEND\nSMCA     BKSTR CL4'SMCA',SMCASMCA,SMCABASE,SMCABASE\n         IEESMCA  ,\n         BKEND\nSSCT     BKSTR CL4'SSCT',SSCTID,SSCT,SSCT\n         IEFJSCVT ,\n         BKEND\n*********************************************************************\n*    THE FOLLOWING MACROS REQUIRE THE PVTMACS LIBRARY\n*********************************************************************\n*    SVC      BKSTR X'DEADFACE',SVCEP,SVCENTRY,SVCENTRY\n*             IHASVC   ,\n*             BKEND\n*********************************************************************\nTCB      BKSTR CL4'TCB ',TCBTCBID,TCBRBP,TCBFIX,                       X\n               (TCBEXT2,TCBXTNT2)\n         IKJTCB LIST=YES\n         BKEND\nTIO      BKSTR X'DEADFACE',TIOT1,TIO,TIO\nTIO      DSECT\n         IEFTIOT1 ,\n         BKEND\nTCT      BKSTR CL4'TCT ',TCTTCT,SMFTCT,SMFTCT\n         IEFTCT   ,\n         BKEND\nTSB      BKSTR X'DEADFACE',TSBASCBA,TSB,TSB\n         IKJTSB   ,\n         BKEND\nTSVT     BKSTR CL4'TSVT',TSVTTSVT,TSVT,TSVT\n         IKJTSVT  ,\n         BKEND\nLWA      BKSTR CL8'   LWA  ',LWALWA,LWA,LWA\n         IKJEFLWA ,\n         BKEND\nUPT      BKSTR X'DEADFACE',UPTUSER,UPT,UPT\n         IKJUPT   ,\n         BKEND\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CBMACSE": {"ttr": 1288, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01c\\x00\\x11\\x00\\x891\\x1f\\x01\\x19\\tO\"\\x13\\x02\\x9c\\x01\\xe1\\x00\\xed\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.99", "flags": 0, "createdate": "1989-11-07T00:00:00", "modifydate": "2019-04-04T22:13:11", "lines": 668, "newlines": 481, "modlines": 237, "user": "SBGOLOB"}, "text": "$DECT    OPSYN DSECT\nDSECT    OPSYN\n$CECT    OPSYN CSECT\nCSECT    OPSYN\n$C       OPSYN DC\nDC       OPSYN\n$S       OPSYN DS\nDS       OPSYN\n         MACRO\n&LBL     DSECT\n.*\n.**      THIS MACRO SAVES THE INDICATOR THAT THE CURRENT SECTION IS A\n.**      DSECT\n.*\n         GBLC  &SECTYP\n         GBLC  &BKBASE,&BKNAME\n         GBLB  &$1DSECT\n         LCLA  &I\n         AIF   ('&LBL' EQ '&BKNAME' AND NOT &$1DSECT).OK\n         AIF   (NOT &$1DSECT).OK\n&LBL     BKSEG\n&BKBASE  SETC  '&LBL'\n.OK      ANOP\n&$1DSECT SETB  1\n&LBL     $DECT\n&SECTYP  SETC  '$DECT'\n         MEND\n         MACRO\n&LBL     CSECT\n.*\n.**      THIS MACRO SAVES THE INDICATOR THAT THE CURRENT SECTION IS A\n.**      CSECT\n.*\n         GBLC  &SECTYP\n&SECTYP  SETC  '$CECT'\n&LBL     $CECT\n         MEND\n         EJECT\n         MACRO\n&LBL     DC\n.*\n.**      THIS MACRO GENERATES NECESSARY FIELDS FOR A DC IN A DSECT\n.*\n         GBLC  &SECTYP,&PRFX,&BKBASE\n         GBLC  &$SEGL,&$SEGST,&$SEGO\n         GBLA  &$LN,&$CO\n         GBLC  &GQ1,&GQ2,&GQ3\n         LCLA  &J,&K,&NSYSL,&LN\n         LCLA  &OLN,&OCO\n         LCLC  &ID,&TY,&C,&D\n&NSYSL   SETA  N'&SYSLIST\n&LBL     $C    &SYSLIST(1)\n&J       SETA  2\n.DCLP    AIF   (&J GT &NSYSL).DONE\n         $C    &SYSLIST(&J)\n&J       SETA  &J+1\n         AGO   .DCLP\n.DONE    ANOP\n.*\n.*       GET LABEL IDENTIFIER\n.*\n&K       SETA  K'&PRFX\n&J       SETA  K'&LBL\n         AIF   (&J LT &K+1).NOGO\n&ID      SETC  '&LBL'(&K+1,&J-&K)\n         AIF   ('&ID'(1,2) EQ 'RV').NOGO\n         AIF   ('&ID'(1,3) EQ 'RSV').NOGO\n         AIF   ('&ID'(1,2) EQ '1R').NOGO\n         AIF   ('&ID'(1,2) EQ '2R').NOGO\n.*\n.*       GET OPERAND TYPE\n.*\n&J       SETA  1\n&K       SETA  1\n.LP1     ANOP\n&C       SETC  '&SYSLIST(&K)'(&J,1)\n         AIF   ('&C' EQ '0').SECTYP          IS IT ZERO REP FACTOR\n         AIF   ('&C' EQ '(').SKPREP          IS IT REAL REP FACTOR\n         AIF   ('&C' LT '0').HALPHA          IF ALPHA THEN TYPE CODE\n.LP1E    ANOP\n&J       SETA  &J+1\n         AGO   .LP1\n.SKPREP  ANOP\n&J       SETA  &J+1\n&C       SETC  '&SYSLIST(&K)'(&J,1)\n         AIF   ('&C' EQ ')').LP1E            GO BACK IN LOOK\n         AGO   .SKPREP\n.SECTYP  ANOP                                GET SECOND TYPE DEF\n&K       SETA  &K+1\n&J       SETA  1\n         AIF   (&K LE &NSYSL).LP1\n.* CANT FIND TYPE SO QUIT THIS ONE\n         AGO   .NOGO\n.HALPHA  ANOP\n&TY      SETC  '&C'\n.*\n.*       NOW VALIDATE TYPE OF CONSTANT\n.*\n         AIF   ('&TY' EQ 'C').GOTLN1\n         AIF   ('&TY' EQ 'X').GOTLN1\n         AIF   ('&TY' EQ 'B').GOTLN1\n         AIF   ('&TY' EQ 'P').GOTLN1\n         AIF   ('&TY' EQ 'H').GOTLN2\n         AIF   ('&TY' EQ 'S').GOTLN2\n         AIF   ('&TY' EQ 'Y').GOTLN2\n         AIF   ('&TY' EQ 'F').GOTLN4\n         AIF   ('&TY' EQ 'A').GOTLN4\n         AIF   ('&TY' EQ 'V').GOTLN4\n         AIF   ('&TY' EQ 'E').GOTLN4\n         AIF   ('&TY' EQ 'D').GOTLN8\n         MNOTE 8,'UNKNOWN TYPE &TY ON LABEL &LBL'\n.GOTLN1  ANOP\n&LN      SETA  1\n         AGO   .GOTLN\n.GOTLN2  ANOP\n&LN      SETA  2\n         AGO   .GOTLN\n.GOTLN4  ANOP\n&LN      SETA  4\n         AGO   .GOTLN\n.GOTLN8  ANOP\n&LN      SETA  8\n         AGO   .GOTLN\n.GOTLN   ANOP\n&C       SETC  '&SYSLIST(&K)'(&J+1,1)\n         AIF   ('&C' NE 'L').HAVELN\n&J       SETA  &J+2\n&D       SETC  ''\n.LP2     ANOP\n&C       SETC  '&SYSLIST(&K)'(&J,1)\n         AIF   ('&C' LT '0').CVNLN\n&D       SETC  '&D'.'&C'\n&J       SETA  &J+1\n         AGO   .LP2\n.CVNLN   ANOP\n&LN      SETA  &D\n.HAVELN  ANOP\n.*LN     SETA  L'&LBL\n&OLN     SETA  &$LN\n&OCO     SETA  &$CO\n&$CO     SETA  &$CO+8+&LN+&LN+2\n         AIF   (&$CO LT 81).GOTPOS\n&$CO     SETA  1+8+&LN+&LN+2\n&$LN     SETA  &$LN+1\n&OLN     SETA  &$LN\n&OCO     SETA  1\n         AIF   (&$LN LT 17).GOTPOS\n         BKSEG ,\n&OLN     SETA  &$LN\n&OCO     SETA  &$CO\n&$CO     SETA  1+8+&LN+&LN+2\n.GOTPOS  ANOP\n         AIF   ('&$SEGO' EQ '').NOSEG\n&GQ1     SETC  '&LBL'\n&GQ2     SETC  '&BKBASE'\n&GQ3     SETC  '&$SEGO'\n&$SEGO   SETC  ''\n.NOSEG   ANOP\nCBBKLS   $CECT\n         $C    CL8'&ID',CL1'&TY',AL1(&LN),AL2(&LBL-&BKBASE)\n         $C    AL2(&OLN,&OCO)\n&SYSECT  &SECTYP\n         AIF   ('&$SEGST' NE '').NOGO\n&$SEGST  SETC  '&LBL'\n.NOGO    ANOP\n         MEND\n         EJECT\n         MACRO\n&LBL     DS\n.*\n.**      THIS MACRO GENERATES NECESSARY FIELDS FOR A DS IN A DSECT\n.*\n         GBLC  &SECTYP,&PRFX,&BKBASE\n         GBLC  &$SEGL,&$SEGST,&$SEGO\n         GBLA  &$LN,&$CO\n         GBLC  &GQ1,&GQ2,&GQ3\n         LCLA  &J,&K,&NSYSL,&LN\n         LCLA  &OLN,&OCO\n         LCLC  &ID,&TY,&C,&D\n&NSYSL   SETA  N'&SYSLIST\n&LBL     $S    &SYSLIST(1)\n&J       SETA  2\n.DCLP    AIF   (&J GT &NSYSL).DONE\n         $S    &SYSLIST(&J)\n&J       SETA  &J+1\n         AGO   .DCLP\n.DONE    ANOP\n.*\n.*       GET LABEL IDENTIFIER\n.*\n&K       SETA  K'&PRFX\n&J       SETA  K'&LBL\n         AIF   (&J LT &K+1).NOGO\n&ID      SETC  '&LBL'(&K+1,&J-&K)\n         AIF   ('&ID'(1,2) EQ 'RV').NOGO\n         AIF   ('&ID'(1,3) EQ 'RSV').NOGO\n.*\n.*       GET OPERAND TYPE\n.*\n&J       SETA  1\n&K       SETA  1\n.LP1     ANOP\n&C       SETC  '&SYSLIST(&K)'(&J,1)\n         AIF   ('&C' EQ '0').SECTYP          IS IT ZERO REP FACTOR\n         AIF   ('&C' EQ '(').SKPREP          IS IT REAL REP FACTOR\n         AIF   ('&C' LT '0').HALPHA          IF ALPHA THEN TYPE CODE\n&J       SETA  &J+1\n         AGO   .LP1\n.SKPREP  ANOP\n&J       SETA  &J+1\n&C       SETC  '&SYSLIST(&K)'(&J,1)\n         AIF   ('&C' EQ ')').LP1E            GO BACK IN LOOK\n         AGO   .SKPREP\n.SECTYP  ANOP\n&K       SETA  &K+1\n&J       SETA  1\n         AIF   (&K LE &NSYSL).LP1\n.* CANT FIND TYPE SO QUIT THIS ONE\n         AGO   .NOGO\n.HALPHA  ANOP\n&TY      SETC  '&C'\n.*\n.*       NOW GET THE LENGTH OF THE SYMBOL\n.*\n         AIF   ('&TY' EQ 'C').GOTLN1\n         AIF   ('&TY' EQ 'X').GOTLN1\n         AIF   ('&TY' EQ 'B').GOTLN1\n         AIF   ('&TY' EQ 'P').GOTLN1\n         AIF   ('&TY' EQ 'H').GOTLN2\n         AIF   ('&TY' EQ 'S').GOTLN2\n         AIF   ('&TY' EQ 'Y').GOTLN2\n         AIF   ('&TY' EQ 'F').GOTLN4\n         AIF   ('&TY' EQ 'A').GOTLN4\n         AIF   ('&TY' EQ 'V').GOTLN4\n         AIF   ('&TY' EQ 'E').GOTLN4\n         AIF   ('&TY' EQ 'D').GOTLN8\n         MNOTE 8,'UNKNOWN TYPE &TY ON LABEL &LBL'\n&LN      SETA  0\n.GOTLN1  ANOP\n&LN      SETA  1\n         AGO   .GOTLN\n.GOTLN2  ANOP\n&LN      SETA  2\n         AGO   .GOTLN\n.GOTLN4  ANOP\n&LN      SETA  4\n         AGO   .GOTLN\n.GOTLN8  ANOP\n&LN      SETA  8\n         AGO   .GOTLN\n.GOTLN   ANOP\n         AIF   (K'&SYSLIST(&K) LE &J).HAVELN\n&C       SETC  '&SYSLIST(&K)'(&J+1,1)\n         AIF   ('&C' NE 'L').HAVELN\n&J       SETA  &J+2\n&D       SETC  ''\n.LP2     ANOP\n&C       SETC  '&SYSLIST(&K)'(&J,1)\n         AIF   ('&C' LT '0').CVNLN\n&D       SETC  '&D'.'&C'\n&J       SETA  &J+1\n         AIF   (K'&SYSLIST(&K) GE &J).LP2\n.CVNLN   ANOP\n&LN      SETA  &D\n         AIF   (&LN LE 50).HAVELN\n&LN      SETA  50\n.HAVELN  ANOP\n.*LN     SETA  L'&LBL\n&OLN     SETA  &$LN\n&OCO     SETA  &$CO\n&$CO     SETA  &$CO+8+&LN+&LN+2\n         AIF   (&$CO LT 81).GOTPOS\n&$CO     SETA  1+8+&LN+&LN+2\n&$LN     SETA  &$LN+1\n&OLN     SETA  &$LN\n&OCO     SETA  1\n         AIF   (&$LN LT 17).GOTPOS\n         BKSEG ,\n&OLN     SETA  &$LN\n&OCO     SETA  &$CO\n&$CO     SETA  1+8+&LN+&LN+2\n.GOTPOS  ANOP\n         AIF   ('&$SEGO' EQ '').NOSEG\n&GQ1     SETC  '&LBL'\n&GQ2     SETC  '&BKBASE'\n&GQ3     SETC  '&$SEGO'\n&$SEGO   SETC  ''\n.NOSEG   ANOP\nCBBKLS   $CECT\n         $C    CL8'&ID',CL1'&TY',AL1(&LN),AL2(&LBL-&BKBASE)\n         $C    AL2(&OLN,&OCO)\n&SYSECT  &SECTYP\n         AIF   ('&$SEGST' NE '').NOGO\n&$SEGST  SETC  '&LBL'\n.NOGO    ANOP\n         MEND\n         EJECT\n         MACRO\n&LBLP    BKSTR &VAL,&OFF,&BASE,&DSECT,&SLS\n         GBLA  &BK\n.*   &BK  -  NUMBER OF CURRENT CONTROL BLOCK (USED FOR NAME GEN)\n         GBLB  &FRST,&$1DSECT\n.*   &FRST  -  TRUE IF NOT FIRST CONTROL BLOCK\n.*   &$1DSECT  -  FALSE ON FIRST DESCT IN CB, TRUE FOR SECONDARY DSECTS\n         GBLC  &PRFX,&BKBASE,&BKNAME,&ORGBSE\n.*   &PRFX  -  PREFIX OF SYMBOLS TO REMOVE\n.*   &BKBASE  -  LABEL OF OFFSET 0 IN MAIN CONTROL BLOCK/CURRENT DSECT\n.*   &BKNAME  -  DSECT NAME OF MAIN CONTROL BLOCK\n.*   &ORGBSE  -  ALWAYS NAME AT OFFSET 0 IN MAIN CONTROL BLOCK\n         GBLC  &SECTYP\n.*   &SECTYP  -  TYPE OF LAST CONTROL SECTION (DSECT/CSECT)\n         GBLC  &#SEGD(10),&#SEGO(10)\n.*   &#SEGD  -  DSECT NAMES OF SECONDARY SECTIONS\n.*   &#SEGO  -  SYMBOL IN MAIN SECTION WITH ADDRESS OF SECONDARY\n         LCLC  &PJ1,&PJ2,&PJ3,&PJ4\n         LCLA  &I,&J\n.*\n.**      BEGINNING OF CONTROL BLOCK MACRO\n.**            NEED TO CREATE AREA IN CBMACS TO INDICATE\n.**            THE START OF A NEW CONTROL BLOCK, AND ITS\n.**            VERIFICATION FIELD\n.**            &LBLP  -   NAME OF BLOCK FOR OVERLAY\n.**            &VAL   -   VALUE OF VALIDATION FIELD\n.**            &OFF   -   LABEL OF FIELD IN DSECT\n.**            &BASE  -   LABEL OF START OF MAIN BODY (GIVES OFFSET)\n.**            &DSECT -   LABEL OF DSECT OF MAIN BODY\n.**            &SLS   -   SUBLIST OF SYMBOLS AND DSECTS FOR SECONDARY\n.**                       SECTIONS\n.*\n&I       SETA  1\n.CRLP    ANOP\n&#SEGD(&I) SETC ''\n&I       SETA  &I+1\n         AIF   (&I LE 10).CRLP\n&$1DSECT SETB  0\n&PRFX    SETC  '&LBLP'\n&PJ1     SETC  'XYZ1&SYSNDX'\n&PJ2     SETC  'XYZ2&SYSNDX'\n&PJ3     SETC  'XYZ3&SYSNDX'\n&PJ4     SETC  'XYZ4&SYSNDX'\nCBMACS   $CECT\n         AIF   (NOT &FRST).SKIPNT\n         ORG   *-4                     BACK UP OVER PREVIOUS FULL WORD\n.SKIPNT  ANOP\n&FRST    SETB  1\n&BK      SETA  &BK+1\n&BKBASE  SETC  '&BASE'\n&ORGBSE  SETC  '&BASE'\n&BKNAME  SETC  '&DSECT'\n         $C    A(&PJ3)                 ADDRESS OF NEXT CONTROL BLOCK\n         $C    A(&OFF-&BASE)           OFFSET TO VALIDATION FIELD\n         $C    A(&PJ4)                 ADDR OF BLOCK IN CBBLKS\n         $C    CL8'&LBLP'              NAME OF BLOCK FOR OVERLAY\n         $C    AL1(&PJ2-&PJ1)          LENGTH OF VALIDATION VALUE\n&PJ1     $C    &VAL                    VALIDATION VALUE\n&PJ2     EQU   *\n&PJ3     $C    F'0'                    IF THIS FIELD IS ZERO THEN\n*                                      THIS IS LAST BLOCK\nCBBKLS   $CECT\n&PJ4     $S    0F\n&SYSECT  &SECTYP\n         AIF   (N'&SLS EQ 0).NOSECS\n&I       SETA  1\n&J       SETA  1\n.SETLP   ANOP\n&#SEGO(&J) SETC '&SLS(&I)'\n&#SEGD(&J) SETC '&SLS(&I+1)'\n&I       SETA  &I+2\n&J       SETA  &J+1\n         AIF   (&I LT N'&SLS).SETLP\n.NOSECS  ANOP\n         BKSEG NEW\n         MEND\n         EJECT\n         MACRO\n&NBS     BKSEG &TYPE\n         GBLA  &NXTSEG,&BK\n         GBLA  &$LN,&$CO\n         GBLC  &$SEGL,&$SEGST,&$SEGO\n         GBLC  &SECTYP\n         GBLC  &#SEGD(10),&#SEGO(10)\n         GBLC  &BKBASE,&BKNAME,&ORGBSE\n         GBLC  &GQ1,&GQ2,&GQ3\n         LCLA  &J,&K\n         LCLC  &PJ0,&PJ1,&PJ2,&PJ3,&PJ4\n         AIF   ('&TYPE' NE 'NEW').NOTNEW\n&NXTSEG  SETA  2\n&PJ0     SETC  'ZZS1&BK'\n&PJ1     SETC  'ZZSZ&BK'\n&PJ2     SETC  'ZZS2&BK'\n&PJ3     SETC  'ZZP1&BK'\n&PJ4     SETC  'ZZQ1&BK'\n         AGO   .ALDN\n.NOTNEW  ANOP\n&GQ3     EQU   &GQ1-&GQ2               OFFSET OF FIRST PIECE OF DATA\n&$SEGL   EQU   *-&$SEGST               FINISH OFF PREVIOUS SEGMENT\n&J       SETA  &NXTSEG+1               GET NEXT SEGMENT NUMBER\n&K       SETA  &NXTSEG-1               GET PREVIOUS SEGMENT NUMBER\n&PJ0     SETC  'ZZS&NXTSEG&BK'         CURRENT LABEL\n&PJ1     SETC  'ZZS&K&BK'              PREVIOUS LABEL\n&PJ2     SETC  'ZZS&J&BK'              NEXT LABEL\n&PJ3     SETC  'ZZP&NXTSEG&BK'\n&PJ4     SETC  'ZZQ&NXTSEG&BK'\n&NXTSEG  SETA  &NXTSEG+1\nCBBKLS   $CECT\n         $C    XL4'00'                 END PREVIOUS SEGMENT FIELDS\n.ALDN    ANOP\n&$LN     SETA  1\n&$CO     SETA  1\n&$SEGST  SETC  ''                      SET SEGMENT START TO NULL\n&$SEGL   SETC  '&PJ3'                  SET LABEL FOR EQU\n&$SEGO   SETC  '&PJ4'                  SET LABEL FOR EQU\nCBBKLS   $CECT\n&PJ0     $C    A(&PJ1)                 PREVIOUS SEGMENT ADDR\n         $C    A(&PJ2)                 NEXT SEGMENT ADDR\n         $C    AL2(&PJ3)               LENGTH OF DATA TO FETCH\n         $C    AL2(&PJ4)               OFFSET OF DATA FROM START OF CB\n         AIF   ('&NBS' EQ '').SETZERO\n&J       SETA  1\n.LKLP    ANOP\n         AIF   ('&NBS' EQ '&#SEGD(&J)').SETFND SEE IF FOUND SEGMENT\n&J       SETA  &J+1\n         AIF   (&J LE 10).LKLP         KEEP GOING FOR ALL ENTRIES\n         AGO   .SETZERO\n.SETFND  $C    AL2(4)\n         $C    AL2(&#SEGO(&J)-&ORGBSE)\n         AGO   .SETDONE\n.SETZERO $C    AL2(0,0)\n.SETDONE ANOP\n&SYSECT  &SECTYP\n         MEND\n         EJECT\n         MACRO\n         BKEND\n         GBLC  &SECTYP\n         GBLC  &$SEGL,&$SEGST\n         GBLA  &NXTSEG,&BK\n         GBLC  &GQ1,&GQ2,&GQ3\n         LCLA  &J\n         LCLC  &PJ1\n.*\n.**      END OF CONTROL BLOCK MACRO\n.*\n&GQ3     EQU   &GQ1-&GQ2               OFFSET OF FIRST PIECE OF DATA\n&$SEGL   EQU   *-&$SEGST\nCBBKLS   $CECT\n         $C    XL4'00'                 END PREVIOUS SEGMENT FIELDS\n&PJ1     SETC  'ZZS&NXTSEG&BK'\n&PJ1     EQU   ZZS1&BK\n&J       SETA  &NXTSEG-1\nZZSZ&BK  EQU   ZZS&J&BK\n&SYSECT  &SECTYP\n         MEND\n         EJECT\nDUMMY    CSECT\nDUMMY    AMODE 31\nDUMMY    RMODE ANY\nCBBKLS   AMODE 31\nCBBKLS   RMODE ANY\nCBMACS   AMODE 31\nCBMACS   RMODE ANY\n         PRINT GEN\nCVT      BKSTR XL4'0A0307FE',CVTEXIT,CVT,CVT,                          X\n               (CVTSMEXT,CVTVSTGX,                                     X\n               CVTEXT1,CVTXTNT1,                                       X\n               CVTEXT2,CVTXTNT2)\n         CVT   DSECT=YES,LIST=YES\n         BKEND\nACEE     BKSTR CL4'ACEE',ACEEACEE,ACEE,ACEE\n         IHAACEE  ,\n         BKEND\nASCB     BKSTR CL4'ASCB',ASCBASCB,ASCB,ASCB\n         IHAASCB LIST=YES,DSECT=YES ,\n         BKEND\nASSB     BKSTR CL4'ASSB',ASSBASSB,ASSB,ASSB\n         IHAASSB LIST=YES ,\n         BKEND\nASTE     BKSTR X'DEADFACE',ASTE,ASTE,ASTE\n         IHAASTE DSECT=YES ,\n         BKEND\nASVT     BKSTR C'ASVT',ASVTASVT,ASVT,ASVT\n         IHAASVT LIST=YES,DSECT=YES ,\n         BKEND\nASXB     BKSTR CL4'ASXB',ASXBASXB,ASXB,ASXB\n         IHAASXB  ,\n         BKEND\nBA       BKSTR CL4'MSER',BACBID,BASE,BASE\n         IEEBASEA ,\n         BKEND\nCD       BKSTR X'DEADFACE',CDCHAIN,CDENTRY,CDENTRY\n         IHACDE   EDCDSECT=YES ,\n         BKEND\nCIB      BKSTR X'DEADFACE',CIBNEXT,CIB,CIB\nCIB      DSECT\n         IEZCIB   ,\n         BKEND\n*********************************************************************\n*    THE FOLLOWING MACRO CHANGED W/ ESA 4.2 (REMOVED ID FIELD).\n*********************************************************************\n*    CH       BKSTR CL4'CSCB',CHCSIDSH,CSCB,CSCB\nCH       BKSTR X'DEADFACE',CHAIN,CSCB,CSCB\nCSCB     DSECT\n         IEECHAIN ,\n         BKEND\n*********************************************************************\n*    THE FOLLOWING MACROS REQUIRE THE PVTMACS LIBRARY  (ESA 4.1)\n*********************************************************************\n*    CSD      BKSTR CL4'CSD ',CSDCSD,CSD,CSD\n*             IHACSD   ,\n*             BKEND\n*********************************************************************\nDCE      BKSTR X'DEADFACE',DCELEN,DCE,DCE\n         IECDDCE  ,\n         BKEND\nECVT     BKSTR CL4'ECVT',ECVTECVT,ECVT,ECVT\n         IHAECVT DSECT=YES,LIST=YES    ,\n         BKEND\nENFCT    BKSTR CL4'ENFC',ENFCTID,ENFCT,ENFCT\n         IEFENFCT ,\n         BKEND\nGDA      BKSTR CL4'GDA ',GDAID,GDA,GDA\n         IHAGDA   ,\n         BKEND\n*********************************************************************\n*    THE FOLLOWING MACROS REQUIRE THE PVTMACS LIBRARY\n*********************************************************************\n*    GVT      BKSTR CL4'GVT ',GVTID,GVT,GVT\n*             ISGGVT   ,\n*             BKEND\n*    GVTX     BKSTR CL4'GVTX',GVTXID,GVTX,GVTX\n*             ISGGVTX  ,\n*             BKEND\n*********************************************************************\nJCT      BKSTR CL4'JCT',JCTJCT,JCT,JCT\nJCT      DSECT\nJCTXXX1  DS    F\nJCTXXX2  DS    F\nJCTXXX3  DS    F\nJCTJCT   DC    CL4'JCT'\n         IEFAJCTB ,\n         BKEND\nJES      BKSTR CL4'JEST',JESCTID,JESCT,JESCT,                          X\n               (JESCTEXT,JESPEXT)\n         IEFJESCT TYPE=DUM    *** TO FORCE REASONABLE EXPANSION\n         BKEND\nJSCB     BKSTR X'DEADFACE',JSCRSV01,IEZJSCB,IEZJSCB\n         IEZJSCB  ,\n         BKEND\n*JMR      BKSTR X'DEADFACE',JMRJOB,JMR,JMR\n*         IEFJMR JMRESEP=N  ,\n*         BKEND\n*   TO FIX THIS, MAKE A COPY OF IEFJMR AND DELETE THE LAST LINE,\n*   WHICH SAYS:  JMR   DSECT\nLCT      BKSTR CL8'ENDOFLCT',LCTLABEL,LCT,LCT\nLCT      DSECT    ,\n         IEFALLCT ,\n         BKEND\nLDA      BKSTR CL4'LDA',LDAID,LDA,LDA\n         IHALDA   ,\n         BKEND\n*********************************************************************\n*    THE FOLLOWING MACROS REQUIRE THE PVTMACS LIBRARY\n*********************************************************************\n*    MPFT     BKSTR CL4'MPFT',MPFTACRN,MPFT,MPFT\n*             IEEZB809 ,\n*             BKEND\n*********************************************************************\nMTT      BKSTR CL4'MTT ',MTTID,MTTABLE,MTTABLE\n         IEEZB806 ,\n         BKEND\nLPDE     BKSTR X'DEADFACE',LPDECHN,LPDE,LPDE\n         IHALPDE  EDCDSECT=YES ,\n         BKEND\nOUCB     BKSTR CL4'OUCB',OUCBNAME,OUCB,OUCB\n         IRAOUCB  ,\n         BKEND\nOUXB     BKSTR CL4'OUXB',OUXBNAME,OUXB,OUXB\n         IHAOUXB  ,\n         BKEND\nPCCB     BKSTR CL4'PCCB',PCCACRO,IEFPCCB,IEFPCCB\n         IEFPCCB  ,\n         BKEND\nPPT      BKSTR CL4'PPT ',PPTID,PPT,PPT\n         IEFZB610 ,\n         BKEND\nPSA      BKSTR X'040C0000',FLCIPPSW,PSA,PSA\n         IHAPSA LIST=YES\n         BKEND\nPSCB     BKSTR X'DEADFACE',PSCBUSER,PSCB,PSCB\n         IKJPSCB  ,\n         BKEND\nRB       BKSTR X'DEADFACE',RBEXRTNM,RBBASIC,RBBASIC\n         IHARB    ,\n         BKEND\n         PRINT GEN\nRCVT     BKSTR CL4'RTSS',RCVTID,RCVT,RCVT  *** ACRONYM FOR TOP SECRET\n         ICHPRCVT , NEED A COPY OF MACRO (REMOVE RCVTSNTD DSECT)\n         BKEND\n         PRINT GEN\n*********************************************************************\n*    THE FOLLOWING MACROS REQUIRE THE PVTMACS LIBRARY\n*********************************************************************\n*    RCT      BKSTR CL4'RCT ',RCTRCT,RCT,RCT\n*             IRARCT   ,\n*             BKEND\n*    RTCT     BKSTR CL4'RTCT',RTCTNAME,RTCT,RTCT\n*             IHARTCT  ,\n*             BKEND\n*********************************************************************\nSCCB     BKSTR X'DEADFACE',SCCBHEAD,SCCB,SCCBSCPI\n         IHASCCB ,\n         BKEND\nSSIB     BKSTR CL4'SSIB',SSIBID,SSIB,SSIB\n         IEFJSSIB ,\n         BKEND\nSSOB     BKSTR CL4'SSOB',SSOBID,SSOB,SSOB\n         IEFSSOBH ,\n         BKEND\nSCVT     BKSTR X'DEADFACE',SCVTPGTM,SCVTSECT,SCVTSECT\n         IHASCVT  ,\n         BKEND\nSMCA     BKSTR CL4'SMCA',SMCASMCA,SMCABASE,SMCABASE\n         IEESMCA  ,\n         BKEND\nSSCT     BKSTR CL4'SSCT',SSCTID,SSCT,SSCT\n         IEFJSCVT ,\n         BKEND\n*********************************************************************\n*    THE FOLLOWING MACROS REQUIRE THE PVTMACS LIBRARY\n*********************************************************************\n*    SVC      BKSTR X'DEADFACE',SVCEP,SVCENTRY,SVCENTRY\n*             IHASVC   ,\n*             BKEND\n*********************************************************************\nTCB      BKSTR CL4'TCB ',TCBTCBID,TCBRBP,TCBFIX,                       X\n               (TCBEXT2,TCBXTNT2)\n         IKJTCB LIST=YES\n         BKEND\nTIO      BKSTR X'DEADFACE',TIOT1,TIO,TIO\nTIO      DSECT\n         IEFTIOT1 ,\n         BKEND\nTCT      BKSTR CL4'TCT ',TCTTCT,SMFTCT,SMFTCT\n         IEFTCT   ,\n         BKEND\nTSB      BKSTR X'DEADFACE',TSBASCBA,TSB,TSB\n         IKJTSB   ,\n         BKEND\nTSVT     BKSTR CL4'TSVT',TSVTTSVT,TSVT,TSVT\n         IKJTSVT  ,\n         BKEND\nLWA      BKSTR CL8'   LWA  ',LWALWA,LWA,LWA\n         IKJEFLWA ,\n         BKEND\nUPT      BKSTR X'DEADFACE',UPTUSER,UPT,UPT\n         IKJUPT   ,\n         BKEND\n* ----------------------------------------------------------------- *\n* --   UNDOCUMENTED IBM CONTROL BLOCKS                           -- *\n* ----------------------------------------------------------------- *\nTPVT     BKSTR CL4'TPVT',TPVT_ID,TPVT,TPVT\n         IKJTPVT  ,\n         BKEND\nCTLT     BKSTR CL4'CTLT',CTLTID,CTLT,CTLT\n         IKJCTLT  ,\n         BKEND\n* ----------------------------------------------------------------- *\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CBMACSE1": {"ttr": 1545, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01[\\x00A\\x00\\x891\\x1f\\x01\\x16\\x03/\\x11\\x03\\x02\\x93\\x01\\xe1\\x00\\xe4\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.91", "flags": 0, "createdate": "1989-11-07T00:00:00", "modifydate": "2016-02-01T11:03:41", "lines": 659, "newlines": 481, "modlines": 228, "user": "SBGOLOB"}, "text": "$DECT    OPSYN DSECT\nDSECT    OPSYN\n$CECT    OPSYN CSECT\nCSECT    OPSYN\n$C       OPSYN DC\nDC       OPSYN\n$S       OPSYN DS\nDS       OPSYN\n         MACRO\n&LBL     DSECT\n.*\n.**      THIS MACRO SAVES THE INDICATOR THAT THE CURRENT SECTION IS A\n.**      DSECT\n.*\n         GBLC  &SECTYP\n         GBLC  &BKBASE,&BKNAME\n         GBLB  &$1DSECT\n         LCLA  &I\n         AIF   ('&LBL' EQ '&BKNAME' AND NOT &$1DSECT).OK\n         AIF   (NOT &$1DSECT).OK\n&LBL     BKSEG\n&BKBASE  SETC  '&LBL'\n.OK      ANOP\n&$1DSECT SETB  1\n&LBL     $DECT\n&SECTYP  SETC  '$DECT'\n         MEND\n         MACRO\n&LBL     CSECT\n.*\n.**      THIS MACRO SAVES THE INDICATOR THAT THE CURRENT SECTION IS A\n.**      CSECT\n.*\n         GBLC  &SECTYP\n&SECTYP  SETC  '$CECT'\n&LBL     $CECT\n         MEND\n         EJECT\n         MACRO\n&LBL     DC\n.*\n.**      THIS MACRO GENERATES NECESSARY FIELDS FOR A DC IN A DSECT\n.*\n         GBLC  &SECTYP,&PRFX,&BKBASE\n         GBLC  &$SEGL,&$SEGST,&$SEGO\n         GBLA  &$LN,&$CO\n         GBLC  &GQ1,&GQ2,&GQ3\n         LCLA  &J,&K,&NSYSL,&LN\n         LCLA  &OLN,&OCO\n         LCLC  &ID,&TY,&C,&D\n&NSYSL   SETA  N'&SYSLIST\n&LBL     $C    &SYSLIST(1)\n&J       SETA  2\n.DCLP    AIF   (&J GT &NSYSL).DONE\n         $C    &SYSLIST(&J)\n&J       SETA  &J+1\n         AGO   .DCLP\n.DONE    ANOP\n.*\n.*       GET LABEL IDENTIFIER\n.*\n&K       SETA  K'&PRFX\n&J       SETA  K'&LBL\n         AIF   (&J LT &K+1).NOGO\n&ID      SETC  '&LBL'(&K+1,&J-&K)\n         AIF   ('&ID'(1,2) EQ 'RV').NOGO\n         AIF   ('&ID'(1,3) EQ 'RSV').NOGO\n.*\n.*       GET OPERAND TYPE\n.*\n&J       SETA  1\n&K       SETA  1\n.LP1     ANOP\n&C       SETC  '&SYSLIST(&K)'(&J,1)\n         AIF   ('&C' EQ '0').SECTYP          IS IT ZERO REP FACTOR\n         AIF   ('&C' EQ '(').SKPREP          IS IT REAL REP FACTOR\n         AIF   ('&C' LT '0').HALPHA          IF ALPHA THEN TYPE CODE\n.LP1E    ANOP\n&J       SETA  &J+1\n         AGO   .LP1\n.SKPREP  ANOP\n&J       SETA  &J+1\n&C       SETC  '&SYSLIST(&K)'(&J,1)\n         AIF   ('&C' EQ ')').LP1E            GO BACK IN LOOK\n         AGO   .SKPREP\n.SECTYP  ANOP                                GET SECOND TYPE DEF\n&K       SETA  &K+1\n&J       SETA  1\n         AIF   (&K LE &NSYSL).LP1\n.* CANT FIND TYPE SO QUIT THIS ONE\n         AGO   .NOGO\n.HALPHA  ANOP\n&TY      SETC  '&C'\n.*\n.*       NOW VALIDATE TYPE OF CONSTANT\n.*\n         AIF   ('&TY' EQ 'C').GOTLN1\n         AIF   ('&TY' EQ 'X').GOTLN1\n         AIF   ('&TY' EQ 'B').GOTLN1\n         AIF   ('&TY' EQ 'P').GOTLN1\n         AIF   ('&TY' EQ 'H').GOTLN2\n         AIF   ('&TY' EQ 'S').GOTLN2\n         AIF   ('&TY' EQ 'Y').GOTLN2\n         AIF   ('&TY' EQ 'F').GOTLN4\n         AIF   ('&TY' EQ 'A').GOTLN4\n         AIF   ('&TY' EQ 'V').GOTLN4\n         AIF   ('&TY' EQ 'E').GOTLN4\n         AIF   ('&TY' EQ 'D').GOTLN8\n         MNOTE 8,'UNKNOWN TYPE &TY ON LABEL &LBL'\n.GOTLN1  ANOP\n&LN      SETA  1\n         AGO   .GOTLN\n.GOTLN2  ANOP\n&LN      SETA  2\n         AGO   .GOTLN\n.GOTLN4  ANOP\n&LN      SETA  4\n         AGO   .GOTLN\n.GOTLN8  ANOP\n&LN      SETA  8\n         AGO   .GOTLN\n.GOTLN   ANOP\n&C       SETC  '&SYSLIST(&K)'(&J+1,1)\n         AIF   ('&C' NE 'L').HAVELN\n&J       SETA  &J+2\n&D       SETC  ''\n.LP2     ANOP\n&C       SETC  '&SYSLIST(&K)'(&J,1)\n         AIF   ('&C' LT '0').CVNLN\n&D       SETC  '&D'.'&C'\n&J       SETA  &J+1\n         AGO   .LP2\n.CVNLN   ANOP\n&LN      SETA  &D\n.HAVELN  ANOP\n.*LN     SETA  L'&LBL\n&OLN     SETA  &$LN\n&OCO     SETA  &$CO\n&$CO     SETA  &$CO+8+&LN+&LN+2\n         AIF   (&$CO LT 81).GOTPOS\n&$CO     SETA  1+8+&LN+&LN+2\n&$LN     SETA  &$LN+1\n&OLN     SETA  &$LN\n&OCO     SETA  1\n         AIF   (&$LN LT 17).GOTPOS\n         BKSEG ,\n&OLN     SETA  &$LN\n&OCO     SETA  &$CO\n&$CO     SETA  1+8+&LN+&LN+2\n.GOTPOS  ANOP\n         AIF   ('&$SEGO' EQ '').NOSEG\n&GQ1     SETC  '&LBL'\n&GQ2     SETC  '&BKBASE'\n&GQ3     SETC  '&$SEGO'\n&$SEGO   SETC  ''\n.NOSEG   ANOP\nCBBKLS   $CECT\n         $C    CL8'&ID',CL1'&TY',AL1(&LN),AL2(&LBL-&BKBASE)\n         $C    AL2(&OLN,&OCO)\n&SYSECT  &SECTYP\n         AIF   ('&$SEGST' NE '').NOGO\n&$SEGST  SETC  '&LBL'\n.NOGO    ANOP\n         MEND\n         EJECT\n         MACRO\n&LBL     DS\n.*\n.**      THIS MACRO GENERATES NECESSARY FIELDS FOR A DS IN A DSECT\n.*\n         GBLC  &SECTYP,&PRFX,&BKBASE\n         GBLC  &$SEGL,&$SEGST,&$SEGO\n         GBLA  &$LN,&$CO\n         GBLC  &GQ1,&GQ2,&GQ3\n         LCLA  &J,&K,&NSYSL,&LN\n         LCLA  &OLN,&OCO\n         LCLC  &ID,&TY,&C,&D\n&NSYSL   SETA  N'&SYSLIST\n&LBL     $S    &SYSLIST(1)\n&J       SETA  2\n.DCLP    AIF   (&J GT &NSYSL).DONE\n         $S    &SYSLIST(&J)\n&J       SETA  &J+1\n         AGO   .DCLP\n.DONE    ANOP\n.*\n.*       GET LABEL IDENTIFIER\n.*\n&K       SETA  K'&PRFX\n&J       SETA  K'&LBL\n         AIF   (&J LT &K+1).NOGO\n&ID      SETC  '&LBL'(&K+1,&J-&K)\n         AIF   ('&ID'(1,2) EQ 'RV').NOGO\n         AIF   ('&ID'(1,3) EQ 'RSV').NOGO\n.*\n.*       GET OPERAND TYPE\n.*\n&J       SETA  1\n&K       SETA  1\n.LP1     ANOP\n&C       SETC  '&SYSLIST(&K)'(&J,1)\n         AIF   ('&C' EQ '0').SECTYP          IS IT ZERO REP FACTOR\n         AIF   ('&C' EQ '(').SKPREP          IS IT REAL REP FACTOR\n         AIF   ('&C' LT '0').HALPHA          IF ALPHA THEN TYPE CODE\n&J       SETA  &J+1\n         AGO   .LP1\n.SKPREP  ANOP\n&J       SETA  &J+1\n&C       SETC  '&SYSLIST(&K)'(&J,1)\n         AIF   ('&C' EQ ')').LP1E            GO BACK IN LOOK\n         AGO   .SKPREP\n.SECTYP  ANOP\n&K       SETA  &K+1\n&J       SETA  1\n         AIF   (&K LE &NSYSL).LP1\n.* CANT FIND TYPE SO QUIT THIS ONE\n         AGO   .NOGO\n.HALPHA  ANOP\n&TY      SETC  '&C'\n.*\n.*       NOW GET THE LENGTH OF THE SYMBOL\n.*\n         AIF   ('&TY' EQ 'C').GOTLN1\n         AIF   ('&TY' EQ 'X').GOTLN1\n         AIF   ('&TY' EQ 'B').GOTLN1\n         AIF   ('&TY' EQ 'P').GOTLN1\n         AIF   ('&TY' EQ 'H').GOTLN2\n         AIF   ('&TY' EQ 'S').GOTLN2\n         AIF   ('&TY' EQ 'Y').GOTLN2\n         AIF   ('&TY' EQ 'F').GOTLN4\n         AIF   ('&TY' EQ 'A').GOTLN4\n         AIF   ('&TY' EQ 'V').GOTLN4\n         AIF   ('&TY' EQ 'E').GOTLN4\n         AIF   ('&TY' EQ 'D').GOTLN8\n         MNOTE 8,'UNKNOWN TYPE &TY ON LABEL &LBL'\n&LN      SETA  0\n.GOTLN1  ANOP\n&LN      SETA  1\n         AGO   .GOTLN\n.GOTLN2  ANOP\n&LN      SETA  2\n         AGO   .GOTLN\n.GOTLN4  ANOP\n&LN      SETA  4\n         AGO   .GOTLN\n.GOTLN8  ANOP\n&LN      SETA  8\n         AGO   .GOTLN\n.GOTLN   ANOP\n         AIF   (K'&SYSLIST(&K) LE &J).HAVELN\n&C       SETC  '&SYSLIST(&K)'(&J+1,1)\n         AIF   ('&C' NE 'L').HAVELN\n&J       SETA  &J+2\n&D       SETC  ''\n.LP2     ANOP\n&C       SETC  '&SYSLIST(&K)'(&J,1)\n         AIF   ('&C' LT '0').CVNLN\n&D       SETC  '&D'.'&C'\n&J       SETA  &J+1\n         AIF   (K'&SYSLIST(&K) GE &J).LP2\n.CVNLN   ANOP\n&LN      SETA  &D\n.HAVELN  ANOP\n.*LN     SETA  L'&LBL\n&OLN     SETA  &$LN\n&OCO     SETA  &$CO\n&$CO     SETA  &$CO+8+&LN+&LN+2\n         AIF   (&$CO LT 81).GOTPOS\n&$CO     SETA  1+8+&LN+&LN+2\n&$LN     SETA  &$LN+1\n&OLN     SETA  &$LN\n&OCO     SETA  1\n         AIF   (&$LN LT 17).GOTPOS\n         BKSEG ,\n&OLN     SETA  &$LN\n&OCO     SETA  &$CO\n&$CO     SETA  1+8+&LN+&LN+2\n.GOTPOS  ANOP\n         AIF   ('&$SEGO' EQ '').NOSEG\n&GQ1     SETC  '&LBL'\n&GQ2     SETC  '&BKBASE'\n&GQ3     SETC  '&$SEGO'\n&$SEGO   SETC  ''\n.NOSEG   ANOP\nCBBKLS   $CECT\n         $C    CL8'&ID',CL1'&TY',AL1(&LN),AL2(&LBL-&BKBASE)\n         $C    AL2(&OLN,&OCO)\n&SYSECT  &SECTYP\n         AIF   ('&$SEGST' NE '').NOGO\n&$SEGST  SETC  '&LBL'\n.NOGO    ANOP\n         MEND\n         EJECT\n         MACRO\n&LBLP    BKSTR &VAL,&OFF,&BASE,&DSECT,&SLS\n         GBLA  &BK\n.*   &BK  -  NUMBER OF CURRENT CONTROL BLOCK (USED FOR NAME GEN)\n         GBLB  &FRST,&$1DSECT\n.*   &FRST  -  TRUE IF NOT FIRST CONTROL BLOCK\n.*   &$1DSECT  -  FALSE ON FIRST DESCT IN CB, TRUE FOR SECONDARY DSECTS\n         GBLC  &PRFX,&BKBASE,&BKNAME,&ORGBSE\n.*   &PRFX  -  PREFIX OF SYMBOLS TO REMOVE\n.*   &BKBASE  -  LABEL OF OFFSET 0 IN MAIN CONTROL BLOCK/CURRENT DSECT\n.*   &BKNAME  -  DSECT NAME OF MAIN CONTROL BLOCK\n.*   &ORGBSE  -  ALWAYS NAME AT OFFSET 0 IN MAIN CONTROL BLOCK\n         GBLC  &SECTYP\n.*   &SECTYP  -  TYPE OF LAST CONTROL SECTION (DSECT/CSECT)\n         GBLC  &#SEGD(10),&#SEGO(10)\n.*   &#SEGD  -  DSECT NAMES OF SECONDARY SECTIONS\n.*   &#SEGO  -  SYMBOL IN MAIN SECTION WITH ADDRESS OF SECONDARY\n         LCLC  &PJ1,&PJ2,&PJ3,&PJ4\n         LCLA  &I,&J\n.*\n.**      BEGINNING OF CONTROL BLOCK MACRO\n.**            NEED TO CREATE AREA IN CBMACS TO INDICATE\n.**            THE START OF A NEW CONTROL BLOCK, AND ITS\n.**            VERIFICATION FIELD\n.**            &LBLP  -   NAME OF BLOCK FOR OVERLAY\n.**            &VAL   -   VALUE OF VALIDATION FIELD\n.**            &OFF   -   LABEL OF FIELD IN DSECT\n.**            &BASE  -   LABEL OF START OF MAIN BODY (GIVES OFFSET)\n.**            &DSECT -   LABEL OF DSECT OF MAIN BODY\n.**            &SLS   -   SUBLIST OF SYMBOLS AND DSECTS FOR SECONDARY\n.**                       SECTIONS\n.*\n&I       SETA  1\n.CRLP    ANOP\n&#SEGD(&I) SETC ''\n&I       SETA  &I+1\n         AIF   (&I LE 10).CRLP\n&$1DSECT SETB  0\n&PRFX    SETC  '&LBLP'\n&PJ1     SETC  'XYZ1&SYSNDX'\n&PJ2     SETC  'XYZ2&SYSNDX'\n&PJ3     SETC  'XYZ3&SYSNDX'\n&PJ4     SETC  'XYZ4&SYSNDX'\nCBMACS   $CECT\n         AIF   (NOT &FRST).SKIPNT\n         ORG   *-4                     BACK UP OVER PREVIOUS FULL WORD\n.SKIPNT  ANOP\n&FRST    SETB  1\n&BK      SETA  &BK+1\n&BKBASE  SETC  '&BASE'\n&ORGBSE  SETC  '&BASE'\n&BKNAME  SETC  '&DSECT'\n         $C    A(&PJ3)                 ADDRESS OF NEXT CONTROL BLOCK\n         $C    A(&OFF-&BASE)           OFFSET TO VALIDATION FIELD\n         $C    A(&PJ4)                 ADDR OF BLOCK IN CBBLKS\n         $C    CL8'&LBLP'              NAME OF BLOCK FOR OVERLAY\n         $C    AL1(&PJ2-&PJ1)          LENGTH OF VALIDATION VALUE\n&PJ1     $C    &VAL                    VALIDATION VALUE\n&PJ2     EQU   *\n&PJ3     $C    F'0'                    IF THIS FIELD IS ZERO THEN\n*                                      THIS IS LAST BLOCK\nCBBKLS   $CECT\n&PJ4     $S    0F\n&SYSECT  &SECTYP\n         AIF   (N'&SLS EQ 0).NOSECS\n&I       SETA  1\n&J       SETA  1\n.SETLP   ANOP\n&#SEGO(&J) SETC '&SLS(&I)'\n&#SEGD(&J) SETC '&SLS(&I+1)'\n&I       SETA  &I+2\n&J       SETA  &J+1\n         AIF   (&I LT N'&SLS).SETLP\n.NOSECS  ANOP\n         BKSEG NEW\n         MEND\n         EJECT\n         MACRO\n&NBS     BKSEG &TYPE\n         GBLA  &NXTSEG,&BK\n         GBLA  &$LN,&$CO\n         GBLC  &$SEGL,&$SEGST,&$SEGO\n         GBLC  &SECTYP\n         GBLC  &#SEGD(10),&#SEGO(10)\n         GBLC  &BKBASE,&BKNAME,&ORGBSE\n         GBLC  &GQ1,&GQ2,&GQ3\n         LCLA  &J,&K\n         LCLC  &PJ0,&PJ1,&PJ2,&PJ3,&PJ4\n         AIF   ('&TYPE' NE 'NEW').NOTNEW\n&NXTSEG  SETA  2\n&PJ0     SETC  'ZZS1&BK'\n&PJ1     SETC  'ZZSZ&BK'\n&PJ2     SETC  'ZZS2&BK'\n&PJ3     SETC  'ZZP1&BK'\n&PJ4     SETC  'ZZQ1&BK'\n         AGO   .ALDN\n.NOTNEW  ANOP\n&GQ3     EQU   &GQ1-&GQ2               OFFSET OF FIRST PIECE OF DATA\n&$SEGL   EQU   *-&$SEGST               FINISH OFF PREVIOUS SEGMENT\n&J       SETA  &NXTSEG+1               GET NEXT SEGMENT NUMBER\n&K       SETA  &NXTSEG-1               GET PREVIOUS SEGMENT NUMBER\n&PJ0     SETC  'ZZS&NXTSEG&BK'         CURRENT LABEL\n&PJ1     SETC  'ZZS&K&BK'              PREVIOUS LABEL\n&PJ2     SETC  'ZZS&J&BK'              NEXT LABEL\n&PJ3     SETC  'ZZP&NXTSEG&BK'\n&PJ4     SETC  'ZZQ&NXTSEG&BK'\n&NXTSEG  SETA  &NXTSEG+1\nCBBKLS   $CECT\n         $C    XL4'00'                 END PREVIOUS SEGMENT FIELDS\n.ALDN    ANOP\n&$LN     SETA  1\n&$CO     SETA  1\n&$SEGST  SETC  ''                      SET SEGMENT START TO NULL\n&$SEGL   SETC  '&PJ3'                  SET LABEL FOR EQU\n&$SEGO   SETC  '&PJ4'                  SET LABEL FOR EQU\nCBBKLS   $CECT\n&PJ0     $C    A(&PJ1)                 PREVIOUS SEGMENT ADDR\n         $C    A(&PJ2)                 NEXT SEGMENT ADDR\n         $C    AL2(&PJ3)               LENGTH OF DATA TO FETCH\n         $C    AL2(&PJ4)               OFFSET OF DATA FROM START OF CB\n         AIF   ('&NBS' EQ '').SETZERO\n&J       SETA  1\n.LKLP    ANOP\n         AIF   ('&NBS' EQ '&#SEGD(&J)').SETFND SEE IF FOUND SEGMENT\n&J       SETA  &J+1\n         AIF   (&J LE 10).LKLP         KEEP GOING FOR ALL ENTRIES\n         AGO   .SETZERO\n.SETFND  $C    AL2(4)\n         $C    AL2(&#SEGO(&J)-&ORGBSE)\n         AGO   .SETDONE\n.SETZERO $C    AL2(0,0)\n.SETDONE ANOP\n&SYSECT  &SECTYP\n         MEND\n         EJECT\n         MACRO\n         BKEND\n         GBLC  &SECTYP\n         GBLC  &$SEGL,&$SEGST\n         GBLA  &NXTSEG,&BK\n         GBLC  &GQ1,&GQ2,&GQ3\n         LCLA  &J\n         LCLC  &PJ1\n.*\n.**      END OF CONTROL BLOCK MACRO\n.*\n&GQ3     EQU   &GQ1-&GQ2               OFFSET OF FIRST PIECE OF DATA\n&$SEGL   EQU   *-&$SEGST\nCBBKLS   $CECT\n         $C    XL4'00'                 END PREVIOUS SEGMENT FIELDS\n&PJ1     SETC  'ZZS&NXTSEG&BK'\n&PJ1     EQU   ZZS1&BK\n&J       SETA  &NXTSEG-1\nZZSZ&BK  EQU   ZZS&J&BK\n&SYSECT  &SECTYP\n         MEND\n         EJECT\nDUMMY    CSECT\nDUMMY    AMODE 31\nDUMMY    RMODE ANY\nCBBKLS   AMODE 31\nCBBKLS   RMODE ANY\nCBMACS   AMODE 31\nCBMACS   RMODE ANY\n         PRINT GEN\nCVT      BKSTR XL4'0A0307FE',CVTEXIT,CVT,CVT,                          X\n               (CVTSMEXT,CVTVSTGX,                                     X\n               CVTEXT1,CVTXTNT1,                                       X\n               CVTEXT2,CVTXTNT2)\n         CVT   DSECT=YES,LIST=YES\n         BKEND\nACEE     BKSTR CL4'ACEE',ACEEACEE,ACEE,ACEE\n         IHAACEE  ,\n         BKEND\nASCB     BKSTR CL4'ASCB',ASCBASCB,ASCB,ASCB\n         IHAASCB LIST=YES,DSECT=YES ,\n         BKEND\nASSB     BKSTR CL4'ASSB',ASSBASSB,ASSB,ASSB\n         IHAASSB LIST=YES ,\n         BKEND\nASTE     BKSTR X'DEADFACE',ASTE,ASTE,ASTE\n         IHAASTE DSECT=YES ,\n         BKEND\nASVT     BKSTR C'ASVT',ASVTASVT,ASVT,ASVT\n         IHAASVT LIST=YES,DSECT=YES ,\n         BKEND\nASXB     BKSTR CL4'ASXB',ASXBASXB,ASXB,ASXB\n         IHAASXB  ,\n         BKEND\nBA       BKSTR CL4'MSER',BACBID,BASE,BASE\n         IEEBASEA ,\n         BKEND\nCD       BKSTR X'DEADFACE',CDCHAIN,CDENTRY,CDENTRY\n         IHACDE   ,\n         BKEND\nCIB      BKSTR X'DEADFACE',CIBNEXT,CIB,CIB\nCIB      DSECT\n         IEZCIB   ,\n         BKEND\n*********************************************************************\n*    THE FOLLOWING MACRO CHANGED W/ ESA 4.2 (REMOVED ID FIELD).\n*********************************************************************\n*    CH       BKSTR CL4'CSCB',CHCSIDSH,CSCB,CSCB\nCH       BKSTR X'DEADFACE',CHAIN,CSCB,CSCB\nCSCB     DSECT\n         IEECHAIN ,\n         BKEND\n*********************************************************************\n*    THE FOLLOWING MACROS REQUIRE THE PVTMACS LIBRARY  (ESA 4.1)\n*********************************************************************\n*    CSD      BKSTR CL4'CSD ',CSDCSD,CSD,CSD\n*             IHACSD   ,\n*             BKEND\n*********************************************************************\nDCE      BKSTR X'DEADFACE',DCELEN,DCE,DCE\n         IECDDCE  ,\n         BKEND\nENFCT    BKSTR CL4'ENFC',ENFCTID,ENFCT,ENFCT\n         IEFENFCT ,\n         BKEND\nGDA      BKSTR CL4'GDA ',GDAID,GDA,GDA\n         IHAGDA   ,\n         BKEND\n*********************************************************************\n*    THE FOLLOWING MACROS REQUIRE THE PVTMACS LIBRARY\n*********************************************************************\n*    GVT      BKSTR CL4'GVT ',GVTID,GVT,GVT\n*             ISGGVT   ,\n*             BKEND\n*    GVTX     BKSTR CL4'GVTX',GVTXID,GVTX,GVTX\n*             ISGGVTX  ,\n*             BKEND\n*********************************************************************\nJCT      BKSTR CL4'JCT',JCTJCT,JCT,JCT\nJCT      DSECT\nJCTXXX1  DS    F\nJCTXXX2  DS    F\nJCTXXX3  DS    F\nJCTJCT   DC    CL4'JCT'\n         IEFAJCTB ,\n         BKEND\nJES      BKSTR CL4'JEST',JESCTID,JESCT,JESCT,                          X\n               (JESCTEXT,JESPEXT)\n         IEFJESCT TYPE=DUM    *** TO FORCE REASONABLE EXPANSION\n         BKEND\nJSCB     BKSTR X'DEADFACE',JSCRSV01,IEZJSCB,IEZJSCB\n         IEZJSCB  ,\n         BKEND\n*JMR      BKSTR X'DEADFACE',JMRJOB,JMR,JMR\n*         IEFJMR JMRESEP=NO ,\n*         BKEND\nLCT      BKSTR CL8'ENDOFLCT',LCTLABEL,LCT,LCT\nLCT      DSECT    ,\n         IEFALLCT ,\n         BKEND\nLDA      BKSTR CL4'LDA',LDAID,LDA,LDA\n         IHALDA   ,\n         BKEND\n*********************************************************************\n*    THE FOLLOWING MACROS REQUIRE THE PVTMACS LIBRARY\n*********************************************************************\n*    MPFT     BKSTR CL4'MPFT',MPFTACRN,MPFT,MPFT\n*             IEEZB809 ,\n*             BKEND\n*********************************************************************\nMTT      BKSTR CL4'MTT ',MTTID,MTTABLE,MTTABLE\n         IEEZB806 ,\n         BKEND\nLPDE     BKSTR X'DEADFACE',LPDECHN,LPDE,LPDE\n         IHALPDE  ,\n         BKEND\nOUCB     BKSTR CL4'OUCB',OUCBNAME,OUCB,OUCB\n         IRAOUCB  ,\n         BKEND\nOUXB     BKSTR CL4'OUXB',OUXBNAME,OUXB,OUXB\n         IHAOUXB  ,\n         BKEND\nPCCB     BKSTR CL4'PCCB',PCCACRO,IEFPCCB,IEFPCCB\n         IEFPCCB  ,\n         BKEND\nPPT      BKSTR CL4'PPT ',PPTID,PPT,PPT\n         IEFZB610 ,\n         BKEND\nPSA      BKSTR X'040C0000',FLCIPPSW,PSA,PSA\n         IHAPSA LIST=YES ,\n         BKEND\nPSCB     BKSTR X'DEADFACE',PSCBUSER,PSCB,PSCB\n         IKJPSCB  ,\n         BKEND\nRB       BKSTR X'DEADFACE',RBEXRTNM,RBBASIC,RBBASIC\n         IHARB    ,\n         BKEND\n         PRINT GEN\nRCVT     BKSTR CL4'RTSS',RCVTID,RCVT,RCVT  *** ACRONYM FOR TOP SECRET\n         ICHPRCVT , NEED A COPY OF MACRO (REMOVE RCVTSNTD DSECT)\n         BKEND\n         PRINT GEN\n*********************************************************************\n*    THE FOLLOWING MACROS REQUIRE THE PVTMACS LIBRARY\n*********************************************************************\n*    RCT      BKSTR CL4'RCT ',RCTRCT,RCT,RCT\n*             IRARCT   ,\n*             BKEND\n*    RTCT     BKSTR CL4'RTCT',RTCTNAME,RTCT,RTCT\n*             IHARTCT  ,\n*             BKEND\n*********************************************************************\nSCCB     BKSTR X'DEADFACE',SCCBHEAD,SCCB,SCCBSCPI\n         IHASCCB ,\n         BKEND\nSSIB     BKSTR CL4'SSIB',SSIBID,SSIB,SSIB\n         IEFJSSIB ,\n         BKEND\nSSOB     BKSTR CL4'SSOB',SSOBID,SSOB,SSOB\n         IEFSSOBH ,\n         BKEND\nSCVT     BKSTR X'DEADFACE',SCVTPGTM,SCVTSECT,SCVTSECT\n         IHASCVT  ,\n         BKEND\nSMCA     BKSTR CL4'SMCA',SMCASMCA,SMCABASE,SMCABASE\n         IEESMCA  ,\n         BKEND\nSSCT     BKSTR CL4'SSCT',SSCTID,SSCT,SSCT\n         IEFJSCVT ,\n         BKEND\n*********************************************************************\n*    THE FOLLOWING MACROS REQUIRE THE PVTMACS LIBRARY\n*********************************************************************\n*    SVC      BKSTR X'DEADFACE',SVCEP,SVCENTRY,SVCENTRY\n*             IHASVC   ,\n*             BKEND\n*********************************************************************\nTCB      BKSTR CL4'TCB ',TCBTCBID,TCBRBP,TCBFIX,                       X\n               (TCBEXT2,TCBXTNT2)\n         IKJTCB LIST=YES\n         BKEND\nTIO      BKSTR X'DEADFACE',TIOT1,TIO,TIO\nTIO      DSECT\n         IEFTIOT1 ,\n         BKEND\nTCT      BKSTR CL4'TCT ',TCTTCT,SMFTCT,SMFTCT\n         IEFTCT   ,\n         BKEND\nTSB      BKSTR X'DEADFACE',TSBASCBA,TSB,TSB\n         IKJTSB   ,\n         BKEND\nTSVT     BKSTR CL4'TSVT',TSVTTSVT,TSVT,TSVT\n         IKJTSVT  ,\n         BKEND\nLWA      BKSTR CL8'   LWA  ',LWALWA,LWA,LWA\n         IKJEFLWA ,\n         BKEND\nUPT      BKSTR X'DEADFACE',UPTUSER,UPT,UPT\n         IKJUPT   ,\n         BKEND\n* ----------------------------------------------------------------- *\n* --   UNDOCUMENTED IBM CONTROL BLOCKS                           -- *\n* ----------------------------------------------------------------- *\nTPVT     BKSTR CL4'TPVT',TPVT_ID,TPVT,TPVT\n         IKJTPVT  ,\n         BKEND\nCTLT     BKSTR CL4'CTLT',CTLTID,CTLT,CTLT\n         IKJCTLT  ,\n         BKEND\n* ----------------------------------------------------------------- *\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CBMACSE2": {"ttr": 1802, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x003\\x01\\x16\\x03/\\x01\\x16\\x03/\\x11\\x06\\x02\\x93\\x02\\x93\\x00\\x00\\xd9\\xc5\\xe2\\xe3\\xd6\\xd9\\xc5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-01T00:00:00", "modifydate": "2016-02-01T11:06:33", "lines": 659, "newlines": 659, "modlines": 0, "user": "RESTORE"}, "text": "$DECT    OPSYN DSECT\nDSECT    OPSYN\n$CECT    OPSYN CSECT\nCSECT    OPSYN\n$C       OPSYN DC\nDC       OPSYN\n$S       OPSYN DS\nDS       OPSYN\n         MACRO\n&LBL     DSECT\n.*\n.**      THIS MACRO SAVES THE INDICATOR THAT THE CURRENT SECTION IS A\n.**      DSECT\n.*\n         GBLC  &SECTYP\n         GBLC  &BKBASE,&BKNAME\n         GBLB  &$1DSECT\n         LCLA  &I\n         AIF   ('&LBL' EQ '&BKNAME' AND NOT &$1DSECT).OK\n         AIF   (NOT &$1DSECT).OK\n&LBL     BKSEG\n&BKBASE  SETC  '&LBL'\n.OK      ANOP\n&$1DSECT SETB  1\n&LBL     $DECT\n&SECTYP  SETC  '$DECT'\n         MEND\n         MACRO\n&LBL     CSECT\n.*\n.**      THIS MACRO SAVES THE INDICATOR THAT THE CURRENT SECTION IS A\n.**      CSECT\n.*\n         GBLC  &SECTYP\n&SECTYP  SETC  '$CECT'\n&LBL     $CECT\n         MEND\n         EJECT\n         MACRO\n&LBL     DC\n.*\n.**      THIS MACRO GENERATES NECESSARY FIELDS FOR A DC IN A DSECT\n.*\n         GBLC  &SECTYP,&PRFX,&BKBASE\n         GBLC  &$SEGL,&$SEGST,&$SEGO\n         GBLA  &$LN,&$CO\n         GBLC  &GQ1,&GQ2,&GQ3\n         LCLA  &J,&K,&NSYSL,&LN\n         LCLA  &OLN,&OCO\n         LCLC  &ID,&TY,&C,&D\n&NSYSL   SETA  N'&SYSLIST\n&LBL     $C    &SYSLIST(1)\n&J       SETA  2\n.DCLP    AIF   (&J GT &NSYSL).DONE\n         $C    &SYSLIST(&J)\n&J       SETA  &J+1\n         AGO   .DCLP\n.DONE    ANOP\n.*\n.*       GET LABEL IDENTIFIER\n.*\n&K       SETA  K'&PRFX\n&J       SETA  K'&LBL\n         AIF   (&J LT &K+1).NOGO\n&ID      SETC  '&LBL'(&K+1,&J-&K)\n         AIF   ('&ID'(1,2) EQ 'RV').NOGO\n         AIF   ('&ID'(1,3) EQ 'RSV').NOGO\n.*\n.*       GET OPERAND TYPE\n.*\n&J       SETA  1\n&K       SETA  1\n.LP1     ANOP\n&C       SETC  '&SYSLIST(&K)'(&J,1)\n         AIF   ('&C' EQ '0').SECTYP          IS IT ZERO REP FACTOR\n         AIF   ('&C' EQ '(').SKPREP          IS IT REAL REP FACTOR\n         AIF   ('&C' LT '0').HALPHA          IF ALPHA THEN TYPE CODE\n.LP1E    ANOP\n&J       SETA  &J+1\n         AGO   .LP1\n.SKPREP  ANOP\n&J       SETA  &J+1\n&C       SETC  '&SYSLIST(&K)'(&J,1)\n         AIF   ('&C' EQ ')').LP1E            GO BACK IN LOOK\n         AGO   .SKPREP\n.SECTYP  ANOP                                GET SECOND TYPE DEF\n&K       SETA  &K+1\n&J       SETA  1\n         AIF   (&K LE &NSYSL).LP1\n.* CANT FIND TYPE SO QUIT THIS ONE\n         AGO   .NOGO\n.HALPHA  ANOP\n&TY      SETC  '&C'\n.*\n.*       NOW VALIDATE TYPE OF CONSTANT\n.*\n         AIF   ('&TY' EQ 'C').GOTLN1\n         AIF   ('&TY' EQ 'X').GOTLN1\n         AIF   ('&TY' EQ 'B').GOTLN1\n         AIF   ('&TY' EQ 'P').GOTLN1\n         AIF   ('&TY' EQ 'H').GOTLN2\n         AIF   ('&TY' EQ 'S').GOTLN2\n         AIF   ('&TY' EQ 'Y').GOTLN2\n         AIF   ('&TY' EQ 'F').GOTLN4\n         AIF   ('&TY' EQ 'A').GOTLN4\n         AIF   ('&TY' EQ 'V').GOTLN4\n         AIF   ('&TY' EQ 'E').GOTLN4\n         AIF   ('&TY' EQ 'D').GOTLN8\n         MNOTE 8,'UNKNOWN TYPE &TY ON LABEL &LBL'\n.GOTLN1  ANOP\n&LN      SETA  1\n         AGO   .GOTLN\n.GOTLN2  ANOP\n&LN      SETA  2\n         AGO   .GOTLN\n.GOTLN4  ANOP\n&LN      SETA  4\n         AGO   .GOTLN\n.GOTLN8  ANOP\n&LN      SETA  8\n         AGO   .GOTLN\n.GOTLN   ANOP\n&C       SETC  '&SYSLIST(&K)'(&J+1,1)\n         AIF   ('&C' NE 'L').HAVELN\n&J       SETA  &J+2\n&D       SETC  ''\n.LP2     ANOP\n&C       SETC  '&SYSLIST(&K)'(&J,1)\n         AIF   ('&C' LT '0').CVNLN\n&D       SETC  '&D'.'&C'\n&J       SETA  &J+1\n         AGO   .LP2\n.CVNLN   ANOP\n&LN      SETA  &D\n.HAVELN  ANOP\n.*LN     SETA  L'&LBL\n&OLN     SETA  &$LN\n&OCO     SETA  &$CO\n&$CO     SETA  &$CO+8+&LN+&LN+2\n         AIF   (&$CO LT 81).GOTPOS\n&$CO     SETA  1+8+&LN+&LN+2\n&$LN     SETA  &$LN+1\n&OLN     SETA  &$LN\n&OCO     SETA  1\n         AIF   (&$LN LT 17).GOTPOS\n         BKSEG ,\n&OLN     SETA  &$LN\n&OCO     SETA  &$CO\n&$CO     SETA  1+8+&LN+&LN+2\n.GOTPOS  ANOP\n         AIF   ('&$SEGO' EQ '').NOSEG\n&GQ1     SETC  '&LBL'\n&GQ2     SETC  '&BKBASE'\n&GQ3     SETC  '&$SEGO'\n&$SEGO   SETC  ''\n.NOSEG   ANOP\nCBBKLS   $CECT\n         $C    CL8'&ID',CL1'&TY',AL1(&LN),AL2(&LBL-&BKBASE)\n         $C    AL2(&OLN,&OCO)\n&SYSECT  &SECTYP\n         AIF   ('&$SEGST' NE '').NOGO\n&$SEGST  SETC  '&LBL'\n.NOGO    ANOP\n         MEND\n         EJECT\n         MACRO\n&LBL     DS\n.*\n.**      THIS MACRO GENERATES NECESSARY FIELDS FOR A DS IN A DSECT\n.*\n         GBLC  &SECTYP,&PRFX,&BKBASE\n         GBLC  &$SEGL,&$SEGST,&$SEGO\n         GBLA  &$LN,&$CO\n         GBLC  &GQ1,&GQ2,&GQ3\n         LCLA  &J,&K,&NSYSL,&LN\n         LCLA  &OLN,&OCO\n         LCLC  &ID,&TY,&C,&D\n&NSYSL   SETA  N'&SYSLIST\n&LBL     $S    &SYSLIST(1)\n&J       SETA  2\n.DCLP    AIF   (&J GT &NSYSL).DONE\n         $S    &SYSLIST(&J)\n&J       SETA  &J+1\n         AGO   .DCLP\n.DONE    ANOP\n.*\n.*       GET LABEL IDENTIFIER\n.*\n&K       SETA  K'&PRFX\n&J       SETA  K'&LBL\n         AIF   (&J LT &K+1).NOGO\n&ID      SETC  '&LBL'(&K+1,&J-&K)\n         AIF   ('&ID'(1,2) EQ 'RV').NOGO\n         AIF   ('&ID'(1,3) EQ 'RSV').NOGO\n.*\n.*       GET OPERAND TYPE\n.*\n&J       SETA  1\n&K       SETA  1\n.LP1     ANOP\n&C       SETC  '&SYSLIST(&K)'(&J,1)\n         AIF   ('&C' EQ '0').SECTYP          IS IT ZERO REP FACTOR\n         AIF   ('&C' EQ '(').SKPREP          IS IT REAL REP FACTOR\n         AIF   ('&C' LT '0').HALPHA          IF ALPHA THEN TYPE CODE\n&J       SETA  &J+1\n         AGO   .LP1\n.SKPREP  ANOP\n&J       SETA  &J+1\n&C       SETC  '&SYSLIST(&K)'(&J,1)\n         AIF   ('&C' EQ ')').LP1E            GO BACK IN LOOK\n         AGO   .SKPREP\n.SECTYP  ANOP\n&K       SETA  &K+1\n&J       SETA  1\n         AIF   (&K LE &NSYSL).LP1\n.* CANT FIND TYPE SO QUIT THIS ONE\n         AGO   .NOGO\n.HALPHA  ANOP\n&TY      SETC  '&C'\n.*\n.*       NOW GET THE LENGTH OF THE SYMBOL\n.*\n         AIF   ('&TY' EQ 'C').GOTLN1\n         AIF   ('&TY' EQ 'X').GOTLN1\n         AIF   ('&TY' EQ 'B').GOTLN1\n         AIF   ('&TY' EQ 'P').GOTLN1\n         AIF   ('&TY' EQ 'H').GOTLN2\n         AIF   ('&TY' EQ 'S').GOTLN2\n         AIF   ('&TY' EQ 'Y').GOTLN2\n         AIF   ('&TY' EQ 'F').GOTLN4\n         AIF   ('&TY' EQ 'A').GOTLN4\n         AIF   ('&TY' EQ 'V').GOTLN4\n         AIF   ('&TY' EQ 'E').GOTLN4\n         AIF   ('&TY' EQ 'D').GOTLN8\n         MNOTE 8,'UNKNOWN TYPE &TY ON LABEL &LBL'\n&LN      SETA  0\n.GOTLN1  ANOP\n&LN      SETA  1\n         AGO   .GOTLN\n.GOTLN2  ANOP\n&LN      SETA  2\n         AGO   .GOTLN\n.GOTLN4  ANOP\n&LN      SETA  4\n         AGO   .GOTLN\n.GOTLN8  ANOP\n&LN      SETA  8\n         AGO   .GOTLN\n.GOTLN   ANOP\n         AIF   (K'&SYSLIST(&K) LE &J).HAVELN\n&C       SETC  '&SYSLIST(&K)'(&J+1,1)\n         AIF   ('&C' NE 'L').HAVELN\n&J       SETA  &J+2\n&D       SETC  ''\n.LP2     ANOP\n&C       SETC  '&SYSLIST(&K)'(&J,1)\n         AIF   ('&C' LT '0').CVNLN\n&D       SETC  '&D'.'&C'\n&J       SETA  &J+1\n         AIF   (K'&SYSLIST(&K) GT &J).LP2\n.CVNLN   ANOP\n&LN      SETA  &D\n.HAVELN  ANOP\n.*LN     SETA  L'&LBL\n&OLN     SETA  &$LN\n&OCO     SETA  &$CO\n&$CO     SETA  &$CO+8+&LN+&LN+2\n         AIF   (&$CO LT 81).GOTPOS\n&$CO     SETA  1+8+&LN+&LN+2\n&$LN     SETA  &$LN+1\n&OLN     SETA  &$LN\n&OCO     SETA  1\n         AIF   (&$LN LT 17).GOTPOS\n         BKSEG ,\n&OLN     SETA  &$LN\n&OCO     SETA  &$CO\n&$CO     SETA  1+8+&LN+&LN+2\n.GOTPOS  ANOP\n         AIF   ('&$SEGO' EQ '').NOSEG\n&GQ1     SETC  '&LBL'\n&GQ2     SETC  '&BKBASE'\n&GQ3     SETC  '&$SEGO'\n&$SEGO   SETC  ''\n.NOSEG   ANOP\nCBBKLS   $CECT\n         $C    CL8'&ID',CL1'&TY',AL1(&LN),AL2(&LBL-&BKBASE)\n         $C    AL2(&OLN,&OCO)\n&SYSECT  &SECTYP\n         AIF   ('&$SEGST' NE '').NOGO\n&$SEGST  SETC  '&LBL'\n.NOGO    ANOP\n         MEND\n         EJECT\n         MACRO\n&LBLP    BKSTR &VAL,&OFF,&BASE,&DSECT,&SLS\n         GBLA  &BK\n.*   &BK  -  NUMBER OF CURRENT CONTROL BLOCK (USED FOR NAME GEN)\n         GBLB  &FRST,&$1DSECT\n.*   &FRST  -  TRUE IF NOT FIRST CONTROL BLOCK\n.*   &$1DSECT  -  FALSE ON FIRST DESCT IN CB, TRUE FOR SECONDARY DSECTS\n         GBLC  &PRFX,&BKBASE,&BKNAME,&ORGBSE\n.*   &PRFX  -  PREFIX OF SYMBOLS TO REMOVE\n.*   &BKBASE  -  LABEL OF OFFSET 0 IN MAIN CONTROL BLOCK/CURRENT DSECT\n.*   &BKNAME  -  DSECT NAME OF MAIN CONTROL BLOCK\n.*   &ORGBSE  -  ALWAYS NAME AT OFFSET 0 IN MAIN CONTROL BLOCK\n         GBLC  &SECTYP\n.*   &SECTYP  -  TYPE OF LAST CONTROL SECTION (DSECT/CSECT)\n         GBLC  &#SEGD(10),&#SEGO(10)\n.*   &#SEGD  -  DSECT NAMES OF SECONDARY SECTIONS\n.*   &#SEGO  -  SYMBOL IN MAIN SECTION WITH ADDRESS OF SECONDARY\n         LCLC  &PJ1,&PJ2,&PJ3,&PJ4\n         LCLA  &I,&J\n.*\n.**      BEGINNING OF CONTROL BLOCK MACRO\n.**            NEED TO CREATE AREA IN CBMACS TO INDICATE\n.**            THE START OF A NEW CONTROL BLOCK, AND ITS\n.**            VERIFICATION FIELD\n.**            &LBLP  -   NAME OF BLOCK FOR OVERLAY\n.**            &VAL   -   VALUE OF VALIDATION FIELD\n.**            &OFF   -   LABEL OF FIELD IN DSECT\n.**            &BASE  -   LABEL OF START OF MAIN BODY (GIVES OFFSET)\n.**            &DSECT -   LABEL OF DSECT OF MAIN BODY\n.**            &SLS   -   SUBLIST OF SYMBOLS AND DSECTS FOR SECONDARY\n.**                       SECTIONS\n.*\n&I       SETA  1\n.CRLP    ANOP\n&#SEGD(&I) SETC ''\n&I       SETA  &I+1\n         AIF   (&I LE 10).CRLP\n&$1DSECT SETB  0\n&PRFX    SETC  '&LBLP'\n&PJ1     SETC  'XYZ1&SYSNDX'\n&PJ2     SETC  'XYZ2&SYSNDX'\n&PJ3     SETC  'XYZ3&SYSNDX'\n&PJ4     SETC  'XYZ4&SYSNDX'\nCBMACS   $CECT\n         AIF   (NOT &FRST).SKIPNT\n         ORG   *-4                     BACK UP OVER PREVIOUS FULL WORD\n.SKIPNT  ANOP\n&FRST    SETB  1\n&BK      SETA  &BK+1\n&BKBASE  SETC  '&BASE'\n&ORGBSE  SETC  '&BASE'\n&BKNAME  SETC  '&DSECT'\n         $C    A(&PJ3)                 ADDRESS OF NEXT CONTROL BLOCK\n         $C    A(&OFF-&BASE)           OFFSET TO VALIDATION FIELD\n         $C    A(&PJ4)                 ADDR OF BLOCK IN CBBLKS\n         $C    CL8'&LBLP'              NAME OF BLOCK FOR OVERLAY\n         $C    AL1(&PJ2-&PJ1)          LENGTH OF VALIDATION VALUE\n&PJ1     $C    &VAL                    VALIDATION VALUE\n&PJ2     EQU   *\n&PJ3     $C    F'0'                    IF THIS FIELD IS ZERO THEN\n*                                      THIS IS LAST BLOCK\nCBBKLS   $CECT\n&PJ4     $S    0F\n&SYSECT  &SECTYP\n         AIF   (N'&SLS EQ 0).NOSECS\n&I       SETA  1\n&J       SETA  1\n.SETLP   ANOP\n&#SEGO(&J) SETC '&SLS(&I)'\n&#SEGD(&J) SETC '&SLS(&I+1)'\n&I       SETA  &I+2\n&J       SETA  &J+1\n         AIF   (&I LT N'&SLS).SETLP\n.NOSECS  ANOP\n         BKSEG NEW\n         MEND\n         EJECT\n         MACRO\n&NBS     BKSEG &TYPE\n         GBLA  &NXTSEG,&BK\n         GBLA  &$LN,&$CO\n         GBLC  &$SEGL,&$SEGST,&$SEGO\n         GBLC  &SECTYP\n         GBLC  &#SEGD(10),&#SEGO(10)\n         GBLC  &BKBASE,&BKNAME,&ORGBSE\n         GBLC  &GQ1,&GQ2,&GQ3\n         LCLA  &J,&K\n         LCLC  &PJ0,&PJ1,&PJ2,&PJ3,&PJ4\n         AIF   ('&TYPE' NE 'NEW').NOTNEW\n&NXTSEG  SETA  2\n&PJ0     SETC  'ZZS1&BK'\n&PJ1     SETC  'ZZSZ&BK'\n&PJ2     SETC  'ZZS2&BK'\n&PJ3     SETC  'ZZP1&BK'\n&PJ4     SETC  'ZZQ1&BK'\n         AGO   .ALDN\n.NOTNEW  ANOP\n&GQ3     EQU   &GQ1-&GQ2               OFFSET OF FIRST PIECE OF DATA\n&$SEGL   EQU   *-&$SEGST               FINISH OFF PREVIOUS SEGMENT\n&J       SETA  &NXTSEG+1               GET NEXT SEGMENT NUMBER\n&K       SETA  &NXTSEG-1               GET PREVIOUS SEGMENT NUMBER\n&PJ0     SETC  'ZZS&NXTSEG&BK'         CURRENT LABEL\n&PJ1     SETC  'ZZS&K&BK'              PREVIOUS LABEL\n&PJ2     SETC  'ZZS&J&BK'              NEXT LABEL\n&PJ3     SETC  'ZZP&NXTSEG&BK'\n&PJ4     SETC  'ZZQ&NXTSEG&BK'\n&NXTSEG  SETA  &NXTSEG+1\nCBBKLS   $CECT\n         $C    XL4'00'                 END PREVIOUS SEGMENT FIELDS\n.ALDN    ANOP\n&$LN     SETA  1\n&$CO     SETA  1\n&$SEGST  SETC  ''                      SET SEGMENT START TO NULL\n&$SEGL   SETC  '&PJ3'                  SET LABEL FOR EQU\n&$SEGO   SETC  '&PJ4'                  SET LABEL FOR EQU\nCBBKLS   $CECT\n&PJ0     $C    A(&PJ1)                 PREVIOUS SEGMENT ADDR\n         $C    A(&PJ2)                 NEXT SEGMENT ADDR\n         $C    AL2(&PJ3)               LENGTH OF DATA TO FETCH\n         $C    AL2(&PJ4)               OFFSET OF DATA FROM START OF CB\n         AIF   ('&NBS' EQ '').SETZERO\n&J       SETA  1\n.LKLP    ANOP\n         AIF   ('&NBS' EQ '&#SEGD(&J)').SETFND SEE IF FOUND SEGMENT\n&J       SETA  &J+1\n         AIF   (&J LE 10).LKLP         KEEP GOING FOR ALL ENTRIES\n         AGO   .SETZERO\n.SETFND  $C    AL2(4)\n         $C    AL2(&#SEGO(&J)-&ORGBSE)\n         AGO   .SETDONE\n.SETZERO $C    AL2(0,0)\n.SETDONE ANOP\n&SYSECT  &SECTYP\n         MEND\n         EJECT\n         MACRO\n         BKEND\n         GBLC  &SECTYP\n         GBLC  &$SEGL,&$SEGST\n         GBLA  &NXTSEG,&BK\n         GBLC  &GQ1,&GQ2,&GQ3\n         LCLA  &J\n         LCLC  &PJ1\n.*\n.**      END OF CONTROL BLOCK MACRO\n.*\n&GQ3     EQU   &GQ1-&GQ2               OFFSET OF FIRST PIECE OF DATA\n&$SEGL   EQU   *-&$SEGST\nCBBKLS   $CECT\n         $C    XL4'00'                 END PREVIOUS SEGMENT FIELDS\n&PJ1     SETC  'ZZS&NXTSEG&BK'\n&PJ1     EQU   ZZS1&BK\n&J       SETA  &NXTSEG-1\nZZSZ&BK  EQU   ZZS&J&BK\n&SYSECT  &SECTYP\n         MEND\n         EJECT\nDUMMY    CSECT\nDUMMY    AMODE 31\nDUMMY    RMODE ANY\nCBBKLS   AMODE 31\nCBBKLS   RMODE ANY\nCBMACS   AMODE 31\nCBMACS   RMODE ANY\n         PRINT GEN\nCVT      BKSTR XL4'0A0307FE',CVTEXIT,CVT,CVT,                          X\n               (CVTSMEXT,CVTVSTGX,                                     X\n               CVTEXT1,CVTXTNT1,                                       X\n               CVTEXT2,CVTXTNT2)\n         CVT   DSECT=YES,LIST=YES\n         BKEND\nACEE     BKSTR CL4'ACEE',ACEEACEE,ACEE,ACEE\n         IHAACEE  ,\n         BKEND\nASCB     BKSTR CL4'ASCB',ASCBASCB,ASCB,ASCB\n         IHAASCB LIST=YES,DSECT=YES ,\n         BKEND\nASSB     BKSTR CL4'ASSB',ASSBASSB,ASSB,ASSB\n         IHAASSB LIST=YES ,\n         BKEND\nASTE     BKSTR X'DEADFACE',ASTE,ASTE,ASTE\n         IHAASTE DSECT=YES ,\n         BKEND\nASVT     BKSTR C'ASVT',ASVTASVT,ASVT,ASVT\n         IHAASVT LIST=YES,DSECT=YES ,\n         BKEND\nASXB     BKSTR CL4'ASXB',ASXBASXB,ASXB,ASXB\n         IHAASXB  ,\n         BKEND\nBA       BKSTR CL4'MSER',BACBID,BASE,BASE\n         IEEBASEA ,\n         BKEND\nCD       BKSTR X'DEADFACE',CDCHAIN,CDENTRY,CDENTRY\n         IHACDE   ,\n         BKEND\nCIB      BKSTR X'DEADFACE',CIBNEXT,CIB,CIB\nCIB      DSECT\n         IEZCIB   ,\n         BKEND\n*********************************************************************\n*    THE FOLLOWING MACRO CHANGED W/ ESA 4.2 (REMOVED ID FIELD).\n*********************************************************************\n*    CH       BKSTR CL4'CSCB',CHCSIDSH,CSCB,CSCB\nCH       BKSTR X'DEADFACE',CHAIN,CSCB,CSCB\nCSCB     DSECT\n         IEECHAIN ,\n         BKEND\n*********************************************************************\n*    THE FOLLOWING MACROS REQUIRE THE PVTMACS LIBRARY  (ESA 4.1)\n*********************************************************************\n*    CSD      BKSTR CL4'CSD ',CSDCSD,CSD,CSD\n*             IHACSD   ,\n*             BKEND\n*********************************************************************\nDCE      BKSTR X'DEADFACE',DCELEN,DCE,DCE\n         IECDDCE  ,\n         BKEND\nENFCT    BKSTR CL4'ENFC',ENFCTID,ENFCT,ENFCT\n         IEFENFCT ,\n         BKEND\nGDA      BKSTR CL4'GDA ',GDAID,GDA,GDA\n         IHAGDA   ,\n         BKEND\n*********************************************************************\n*    THE FOLLOWING MACROS REQUIRE THE PVTMACS LIBRARY\n*********************************************************************\n*    GVT      BKSTR CL4'GVT ',GVTID,GVT,GVT\n*             ISGGVT   ,\n*             BKEND\n*    GVTX     BKSTR CL4'GVTX',GVTXID,GVTX,GVTX\n*             ISGGVTX  ,\n*             BKEND\n*********************************************************************\nJCT      BKSTR CL4'JCT',JCTJCT,JCT,JCT\nJCT      DSECT\nJCTXXX1  DS    F\nJCTXXX2  DS    F\nJCTXXX3  DS    F\nJCTJCT   DC    CL4'JCT'\n         IEFAJCTB ,\n         BKEND\nJES      BKSTR CL4'JEST',JESCTID,JESCT,JESCT,                          X\n               (JESCTEXT,JESPEXT)\n         IEFJESCT TYPE=DUM    *** TO FORCE REASONABLE EXPANSION\n         BKEND\nJSCB     BKSTR X'DEADFACE',JSCRSV01,IEZJSCB,IEZJSCB\n         IEZJSCB  ,\n         BKEND\n*JMR      BKSTR X'DEADFACE',JMRJOB,JMR,JMR\n*         IEFJMR JMRESEP=NO ,\n*         BKEND\nLCT      BKSTR CL8'ENDOFLCT',LCTLABEL,LCT,LCT\nLCT      DSECT    ,\n         IEFALLCT ,\n         BKEND\nLDA      BKSTR CL4'LDA',LDAID,LDA,LDA\n         IHALDA   ,\n         BKEND\n*********************************************************************\n*    THE FOLLOWING MACROS REQUIRE THE PVTMACS LIBRARY\n*********************************************************************\n*    MPFT     BKSTR CL4'MPFT',MPFTACRN,MPFT,MPFT\n*             IEEZB809 ,\n*             BKEND\n*********************************************************************\nMTT      BKSTR CL4'MTT ',MTTID,MTTABLE,MTTABLE\n         IEEZB806 ,\n         BKEND\nLPDE     BKSTR X'DEADFACE',LPDECHN,LPDE,LPDE\n         IHALPDE  ,\n         BKEND\nOUCB     BKSTR CL4'OUCB',OUCBNAME,OUCB,OUCB\n         IRAOUCB  ,\n         BKEND\nOUXB     BKSTR CL4'OUXB',OUXBNAME,OUXB,OUXB\n         IHAOUXB  ,\n         BKEND\nPCCB     BKSTR CL4'PCCB',PCCACRO,IEFPCCB,IEFPCCB\n         IEFPCCB  ,\n         BKEND\nPPT      BKSTR CL4'PPT ',PPTID,PPT,PPT\n         IEFZB610 ,\n         BKEND\nPSA      BKSTR X'040C0000',FLCIPPSW,PSA,PSA\n         IHAPSA LIST=YES\n         BKEND\nPSCB     BKSTR X'DEADFACE',PSCBUSER,PSCB,PSCB\n         IKJPSCB  ,\n         BKEND\nRB       BKSTR X'DEADFACE',RBEXRTNM,RBBASIC,RBBASIC\n         IHARB    ,\n         BKEND\n         PRINT GEN\nRCVT     BKSTR CL4'RTSS',RCVTID,RCVT,RCVT  *** ACRONYM FOR TOP SECRET\n         ICHPRCVT , NEED A COPY OF MACRO (REMOVE RCVTSNTD DSECT)\n         BKEND\n         PRINT GEN\n*********************************************************************\n*    THE FOLLOWING MACROS REQUIRE THE PVTMACS LIBRARY\n*********************************************************************\n*    RCT      BKSTR CL4'RCT ',RCTRCT,RCT,RCT\n*             IRARCT   ,\n*             BKEND\n*    RTCT     BKSTR CL4'RTCT',RTCTNAME,RTCT,RTCT\n*             IHARTCT  ,\n*             BKEND\n*********************************************************************\nSCCB     BKSTR X'DEADFACE',SCCBHEAD,SCCB,SCCBSCPI\n         IHASCCB ,\n         BKEND\nSSIB     BKSTR CL4'SSIB',SSIBID,SSIB,SSIB\n         IEFJSSIB ,\n         BKEND\nSSOB     BKSTR CL4'SSOB',SSOBID,SSOB,SSOB\n         IEFSSOBH ,\n         BKEND\nSCVT     BKSTR X'DEADFACE',SCVTPGTM,SCVTSECT,SCVTSECT\n         IHASCVT  ,\n         BKEND\nSMCA     BKSTR CL4'SMCA',SMCASMCA,SMCABASE,SMCABASE\n         IEESMCA  ,\n         BKEND\nSSCT     BKSTR CL4'SSCT',SSCTID,SSCT,SSCT\n         IEFJSCVT ,\n         BKEND\n*********************************************************************\n*    THE FOLLOWING MACROS REQUIRE THE PVTMACS LIBRARY\n*********************************************************************\n*    SVC      BKSTR X'DEADFACE',SVCEP,SVCENTRY,SVCENTRY\n*             IHASVC   ,\n*             BKEND\n*********************************************************************\nTCB      BKSTR CL4'TCB ',TCBTCBID,TCBRBP,TCBFIX,                       X\n               (TCBEXT2,TCBXTNT2)\n         IKJTCB LIST=YES\n         BKEND\nTIO      BKSTR X'DEADFACE',TIOT1,TIO,TIO\nTIO      DSECT\n         IEFTIOT1 ,\n         BKEND\nTCT      BKSTR CL4'TCT ',TCTTCT,SMFTCT,SMFTCT\n         IEFTCT   ,\n         BKEND\nTSB      BKSTR X'DEADFACE',TSBASCBA,TSB,TSB\n         IKJTSB   ,\n         BKEND\nTSVT     BKSTR CL4'TSVT',TSVTTSVT,TSVT,TSVT\n         IKJTSVT  ,\n         BKEND\nLWA      BKSTR CL8'   LWA  ',LWALWA,LWA,LWA\n         IKJEFLWA ,\n         BKEND\nUPT      BKSTR X'DEADFACE',UPTUSER,UPT,UPT\n         IKJUPT   ,\n         BKEND\n* ----------------------------------------------------------------- *\n* --   UNDOCUMENTED IBM CONTROL BLOCKS                           -- *\n* ----------------------------------------------------------------- *\nTPVT     BKSTR CL4'TPVT',TPVT_ID,TPVT,TPVT\n         IKJTPVT  ,\n         BKEND\nCTLT     BKSTR CL4'CTLT',CTLTID,CTLT,CTLT\n         IKJCTLT  ,\n         BKEND\n* ----------------------------------------------------------------- *\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CBMACSE3": {"ttr": 2305, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01^\\x00\\x06\\x00\\x891\\x1f\\x01\\x16\\x03\\x1f\\x17U\\x02\\x97\\x01\\xe1\\x00\\xe8\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.94", "flags": 0, "createdate": "1989-11-07T00:00:00", "modifydate": "2016-01-31T17:55:06", "lines": 663, "newlines": 481, "modlines": 232, "user": "SBGOLOB"}, "text": "$DECT    OPSYN DSECT\nDSECT    OPSYN\n$CECT    OPSYN CSECT\nCSECT    OPSYN\n$C       OPSYN DC\nDC       OPSYN\n$S       OPSYN DS\nDS       OPSYN\n         MACRO\n&LBL     DSECT\n.*\n.**      THIS MACRO SAVES THE INDICATOR THAT THE CURRENT SECTION IS A\n.**      DSECT\n.*\n         GBLC  &SECTYP\n         GBLC  &BKBASE,&BKNAME\n         GBLB  &$1DSECT\n         LCLA  &I\n         AIF   ('&LBL' EQ '&BKNAME' AND NOT &$1DSECT).OK\n         AIF   (NOT &$1DSECT).OK\n&LBL     BKSEG\n&BKBASE  SETC  '&LBL'\n.OK      ANOP\n&$1DSECT SETB  1\n&LBL     $DECT\n&SECTYP  SETC  '$DECT'\n         MEND\n         MACRO\n&LBL     CSECT\n.*\n.**      THIS MACRO SAVES THE INDICATOR THAT THE CURRENT SECTION IS A\n.**      CSECT\n.*\n         GBLC  &SECTYP\n&SECTYP  SETC  '$CECT'\n&LBL     $CECT\n         MEND\n         EJECT\n         MACRO\n&LBL     DC\n.*\n.**      THIS MACRO GENERATES NECESSARY FIELDS FOR A DC IN A DSECT\n.*\n         GBLC  &SECTYP,&PRFX,&BKBASE\n         GBLC  &$SEGL,&$SEGST,&$SEGO\n         GBLA  &$LN,&$CO\n         GBLC  &GQ1,&GQ2,&GQ3\n         LCLA  &J,&K,&NSYSL,&LN\n         LCLA  &OLN,&OCO\n         LCLC  &ID,&TY,&C,&D\n&NSYSL   SETA  N'&SYSLIST\n&LBL     $C    &SYSLIST(1)\n&J       SETA  2\n.DCLP    AIF   (&J GT &NSYSL).DONE\n         $C    &SYSLIST(&J)\n&J       SETA  &J+1\n         AGO   .DCLP\n.DONE    ANOP\n.*\n.*       GET LABEL IDENTIFIER\n.*\n&K       SETA  K'&PRFX\n&J       SETA  K'&LBL\n         AIF   (&J LT &K+1).NOGO\n&ID      SETC  '&LBL'(&K+1,&J-&K)\n         AIF   ('&ID'(1,2) EQ 'RV').NOGO\n         AIF   ('&ID'(1,3) EQ 'RSV').NOGO\n         AIF   ('&ID'(1,2) EQ '1R').NOGO\n         AIF   ('&ID'(1,2) EQ '2R').NOGO\n.*\n.*       GET OPERAND TYPE\n.*\n&J       SETA  1\n&K       SETA  1\n.LP1     ANOP\n&C       SETC  '&SYSLIST(&K)'(&J,1)\n         AIF   ('&C' EQ '0').SECTYP          IS IT ZERO REP FACTOR\n         AIF   ('&C' EQ '(').SKPREP          IS IT REAL REP FACTOR\n         AIF   ('&C' LT '0').HALPHA          IF ALPHA THEN TYPE CODE\n.LP1E    ANOP\n&J       SETA  &J+1\n         AGO   .LP1\n.SKPREP  ANOP\n&J       SETA  &J+1\n&C       SETC  '&SYSLIST(&K)'(&J,1)\n         AIF   ('&C' EQ ')').LP1E            GO BACK IN LOOK\n         AGO   .SKPREP\n.SECTYP  ANOP                                GET SECOND TYPE DEF\n&K       SETA  &K+1\n&J       SETA  1\n         AIF   (&K LE &NSYSL).LP1\n.* CANT FIND TYPE SO QUIT THIS ONE\n         AGO   .NOGO\n.HALPHA  ANOP\n&TY      SETC  '&C'\n.*\n.*       NOW VALIDATE TYPE OF CONSTANT\n.*\n         AIF   ('&TY' EQ 'C').GOTLN1\n         AIF   ('&TY' EQ 'X').GOTLN1\n         AIF   ('&TY' EQ 'B').GOTLN1\n         AIF   ('&TY' EQ 'P').GOTLN1\n         AIF   ('&TY' EQ 'H').GOTLN2\n         AIF   ('&TY' EQ 'S').GOTLN2\n         AIF   ('&TY' EQ 'Y').GOTLN2\n         AIF   ('&TY' EQ 'F').GOTLN4\n         AIF   ('&TY' EQ 'A').GOTLN4\n         AIF   ('&TY' EQ 'V').GOTLN4\n         AIF   ('&TY' EQ 'E').GOTLN4\n         AIF   ('&TY' EQ 'D').GOTLN8\n         MNOTE 8,'UNKNOWN TYPE &TY ON LABEL &LBL'\n.GOTLN1  ANOP\n&LN      SETA  1\n         AGO   .GOTLN\n.GOTLN2  ANOP\n&LN      SETA  2\n         AGO   .GOTLN\n.GOTLN4  ANOP\n&LN      SETA  4\n         AGO   .GOTLN\n.GOTLN8  ANOP\n&LN      SETA  8\n         AGO   .GOTLN\n.GOTLN   ANOP\n&C       SETC  '&SYSLIST(&K)'(&J+1,1)\n         AIF   ('&C' NE 'L').HAVELN\n&J       SETA  &J+2\n&D       SETC  ''\n.LP2     ANOP\n&C       SETC  '&SYSLIST(&K)'(&J,1)\n         AIF   ('&C' LT '0').CVNLN\n&D       SETC  '&D'.'&C'\n&J       SETA  &J+1\n         AGO   .LP2\n.CVNLN   ANOP\n&LN      SETA  &D\n.HAVELN  ANOP\n.*LN     SETA  L'&LBL\n&OLN     SETA  &$LN\n&OCO     SETA  &$CO\n&$CO     SETA  &$CO+8+&LN+&LN+2\n         AIF   (&$CO LT 81).GOTPOS\n&$CO     SETA  1+8+&LN+&LN+2\n&$LN     SETA  &$LN+1\n&OLN     SETA  &$LN\n&OCO     SETA  1\n         AIF   (&$LN LT 17).GOTPOS\n         BKSEG ,\n&OLN     SETA  &$LN\n&OCO     SETA  &$CO\n&$CO     SETA  1+8+&LN+&LN+2\n.GOTPOS  ANOP\n         AIF   ('&$SEGO' EQ '').NOSEG\n&GQ1     SETC  '&LBL'\n&GQ2     SETC  '&BKBASE'\n&GQ3     SETC  '&$SEGO'\n&$SEGO   SETC  ''\n.NOSEG   ANOP\nCBBKLS   $CECT\n         $C    CL8'&ID',CL1'&TY',AL1(&LN),AL2(&LBL-&BKBASE)\n         $C    AL2(&OLN,&OCO)\n&SYSECT  &SECTYP\n         AIF   ('&$SEGST' NE '').NOGO\n&$SEGST  SETC  '&LBL'\n.NOGO    ANOP\n         MEND\n         EJECT\n         MACRO\n&LBL     DS\n.*\n.**      THIS MACRO GENERATES NECESSARY FIELDS FOR A DS IN A DSECT\n.*\n         GBLC  &SECTYP,&PRFX,&BKBASE\n         GBLC  &$SEGL,&$SEGST,&$SEGO\n         GBLA  &$LN,&$CO\n         GBLC  &GQ1,&GQ2,&GQ3\n         LCLA  &J,&K,&NSYSL,&LN\n         LCLA  &OLN,&OCO\n         LCLC  &ID,&TY,&C,&D\n&NSYSL   SETA  N'&SYSLIST\n&LBL     $S    &SYSLIST(1)\n&J       SETA  2\n.DCLP    AIF   (&J GT &NSYSL).DONE\n         $S    &SYSLIST(&J)\n&J       SETA  &J+1\n         AGO   .DCLP\n.DONE    ANOP\n.*\n.*       GET LABEL IDENTIFIER\n.*\n&K       SETA  K'&PRFX\n&J       SETA  K'&LBL\n         AIF   (&J LT &K+1).NOGO\n&ID      SETC  '&LBL'(&K+1,&J-&K)\n         AIF   ('&ID'(1,2) EQ 'RV').NOGO\n         AIF   ('&ID'(1,3) EQ 'RSV').NOGO\n.*\n.*       GET OPERAND TYPE\n.*\n&J       SETA  1\n&K       SETA  1\n.LP1     ANOP\n&C       SETC  '&SYSLIST(&K)'(&J,1)\n         AIF   ('&C' EQ '0').SECTYP          IS IT ZERO REP FACTOR\n         AIF   ('&C' EQ '(').SKPREP          IS IT REAL REP FACTOR\n         AIF   ('&C' LT '0').HALPHA          IF ALPHA THEN TYPE CODE\n&J       SETA  &J+1\n         AGO   .LP1\n.SKPREP  ANOP\n&J       SETA  &J+1\n&C       SETC  '&SYSLIST(&K)'(&J,1)\n         AIF   ('&C' EQ ')').LP1E            GO BACK IN LOOK\n         AGO   .SKPREP\n.SECTYP  ANOP\n&K       SETA  &K+1\n&J       SETA  1\n         AIF   (&K LE &NSYSL).LP1\n.* CANT FIND TYPE SO QUIT THIS ONE\n         AGO   .NOGO\n.HALPHA  ANOP\n&TY      SETC  '&C'\n.*\n.*       NOW GET THE LENGTH OF THE SYMBOL\n.*\n         AIF   ('&TY' EQ 'C').GOTLN1\n         AIF   ('&TY' EQ 'X').GOTLN1\n         AIF   ('&TY' EQ 'B').GOTLN1\n         AIF   ('&TY' EQ 'P').GOTLN1\n         AIF   ('&TY' EQ 'H').GOTLN2\n         AIF   ('&TY' EQ 'S').GOTLN2\n         AIF   ('&TY' EQ 'Y').GOTLN2\n         AIF   ('&TY' EQ 'F').GOTLN4\n         AIF   ('&TY' EQ 'A').GOTLN4\n         AIF   ('&TY' EQ 'V').GOTLN4\n         AIF   ('&TY' EQ 'E').GOTLN4\n         AIF   ('&TY' EQ 'D').GOTLN8\n         MNOTE 8,'UNKNOWN TYPE &TY ON LABEL &LBL'\n&LN      SETA  0\n.GOTLN1  ANOP\n&LN      SETA  1\n         AGO   .GOTLN\n.GOTLN2  ANOP\n&LN      SETA  2\n         AGO   .GOTLN\n.GOTLN4  ANOP\n&LN      SETA  4\n         AGO   .GOTLN\n.GOTLN8  ANOP\n&LN      SETA  8\n         AGO   .GOTLN\n.GOTLN   ANOP\n         AIF   (K'&SYSLIST(&K) LE &J).HAVELN\n&C       SETC  '&SYSLIST(&K)'(&J+1,1)\n         AIF   ('&C' NE 'L').HAVELN\n&J       SETA  &J+2\n&D       SETC  ''\n.LP2     ANOP\n&C       SETC  '&SYSLIST(&K)'(&J,1)\n         AIF   ('&C' LT '0').CVNLN\n&D       SETC  '&D'.'&C'\n&J       SETA  &J+1\n         AIF   (K'&SYSLIST(&K) GE &J).LP2\n.CVNLN   ANOP\n&LN      SETA  &D\n         AIF   (&LN LE 50).HAVELN\n&LN      SETA  50\n.HAVELN  ANOP\n.*LN     SETA  L'&LBL\n&OLN     SETA  &$LN\n&OCO     SETA  &$CO\n&$CO     SETA  &$CO+8+&LN+&LN+2\n         AIF   (&$CO LT 81).GOTPOS\n&$CO     SETA  1+8+&LN+&LN+2\n&$LN     SETA  &$LN+1\n&OLN     SETA  &$LN\n&OCO     SETA  1\n         AIF   (&$LN LT 17).GOTPOS\n         BKSEG ,\n&OLN     SETA  &$LN\n&OCO     SETA  &$CO\n&$CO     SETA  1+8+&LN+&LN+2\n.GOTPOS  ANOP\n         AIF   ('&$SEGO' EQ '').NOSEG\n&GQ1     SETC  '&LBL'\n&GQ2     SETC  '&BKBASE'\n&GQ3     SETC  '&$SEGO'\n&$SEGO   SETC  ''\n.NOSEG   ANOP\nCBBKLS   $CECT\n         $C    CL8'&ID',CL1'&TY',AL1(&LN),AL2(&LBL-&BKBASE)\n         $C    AL2(&OLN,&OCO)\n&SYSECT  &SECTYP\n         AIF   ('&$SEGST' NE '').NOGO\n&$SEGST  SETC  '&LBL'\n.NOGO    ANOP\n         MEND\n         EJECT\n         MACRO\n&LBLP    BKSTR &VAL,&OFF,&BASE,&DSECT,&SLS\n         GBLA  &BK\n.*   &BK  -  NUMBER OF CURRENT CONTROL BLOCK (USED FOR NAME GEN)\n         GBLB  &FRST,&$1DSECT\n.*   &FRST  -  TRUE IF NOT FIRST CONTROL BLOCK\n.*   &$1DSECT  -  FALSE ON FIRST DESCT IN CB, TRUE FOR SECONDARY DSECTS\n         GBLC  &PRFX,&BKBASE,&BKNAME,&ORGBSE\n.*   &PRFX  -  PREFIX OF SYMBOLS TO REMOVE\n.*   &BKBASE  -  LABEL OF OFFSET 0 IN MAIN CONTROL BLOCK/CURRENT DSECT\n.*   &BKNAME  -  DSECT NAME OF MAIN CONTROL BLOCK\n.*   &ORGBSE  -  ALWAYS NAME AT OFFSET 0 IN MAIN CONTROL BLOCK\n         GBLC  &SECTYP\n.*   &SECTYP  -  TYPE OF LAST CONTROL SECTION (DSECT/CSECT)\n         GBLC  &#SEGD(10),&#SEGO(10)\n.*   &#SEGD  -  DSECT NAMES OF SECONDARY SECTIONS\n.*   &#SEGO  -  SYMBOL IN MAIN SECTION WITH ADDRESS OF SECONDARY\n         LCLC  &PJ1,&PJ2,&PJ3,&PJ4\n         LCLA  &I,&J\n.*\n.**      BEGINNING OF CONTROL BLOCK MACRO\n.**            NEED TO CREATE AREA IN CBMACS TO INDICATE\n.**            THE START OF A NEW CONTROL BLOCK, AND ITS\n.**            VERIFICATION FIELD\n.**            &LBLP  -   NAME OF BLOCK FOR OVERLAY\n.**            &VAL   -   VALUE OF VALIDATION FIELD\n.**            &OFF   -   LABEL OF FIELD IN DSECT\n.**            &BASE  -   LABEL OF START OF MAIN BODY (GIVES OFFSET)\n.**            &DSECT -   LABEL OF DSECT OF MAIN BODY\n.**            &SLS   -   SUBLIST OF SYMBOLS AND DSECTS FOR SECONDARY\n.**                       SECTIONS\n.*\n&I       SETA  1\n.CRLP    ANOP\n&#SEGD(&I) SETC ''\n&I       SETA  &I+1\n         AIF   (&I LE 10).CRLP\n&$1DSECT SETB  0\n&PRFX    SETC  '&LBLP'\n&PJ1     SETC  'XYZ1&SYSNDX'\n&PJ2     SETC  'XYZ2&SYSNDX'\n&PJ3     SETC  'XYZ3&SYSNDX'\n&PJ4     SETC  'XYZ4&SYSNDX'\nCBMACS   $CECT\n         AIF   (NOT &FRST).SKIPNT\n         ORG   *-4                     BACK UP OVER PREVIOUS FULL WORD\n.SKIPNT  ANOP\n&FRST    SETB  1\n&BK      SETA  &BK+1\n&BKBASE  SETC  '&BASE'\n&ORGBSE  SETC  '&BASE'\n&BKNAME  SETC  '&DSECT'\n         $C    A(&PJ3)                 ADDRESS OF NEXT CONTROL BLOCK\n         $C    A(&OFF-&BASE)           OFFSET TO VALIDATION FIELD\n         $C    A(&PJ4)                 ADDR OF BLOCK IN CBBLKS\n         $C    CL8'&LBLP'              NAME OF BLOCK FOR OVERLAY\n         $C    AL1(&PJ2-&PJ1)          LENGTH OF VALIDATION VALUE\n&PJ1     $C    &VAL                    VALIDATION VALUE\n&PJ2     EQU   *\n&PJ3     $C    F'0'                    IF THIS FIELD IS ZERO THEN\n*                                      THIS IS LAST BLOCK\nCBBKLS   $CECT\n&PJ4     $S    0F\n&SYSECT  &SECTYP\n         AIF   (N'&SLS EQ 0).NOSECS\n&I       SETA  1\n&J       SETA  1\n.SETLP   ANOP\n&#SEGO(&J) SETC '&SLS(&I)'\n&#SEGD(&J) SETC '&SLS(&I+1)'\n&I       SETA  &I+2\n&J       SETA  &J+1\n         AIF   (&I LT N'&SLS).SETLP\n.NOSECS  ANOP\n         BKSEG NEW\n         MEND\n         EJECT\n         MACRO\n&NBS     BKSEG &TYPE\n         GBLA  &NXTSEG,&BK\n         GBLA  &$LN,&$CO\n         GBLC  &$SEGL,&$SEGST,&$SEGO\n         GBLC  &SECTYP\n         GBLC  &#SEGD(10),&#SEGO(10)\n         GBLC  &BKBASE,&BKNAME,&ORGBSE\n         GBLC  &GQ1,&GQ2,&GQ3\n         LCLA  &J,&K\n         LCLC  &PJ0,&PJ1,&PJ2,&PJ3,&PJ4\n         AIF   ('&TYPE' NE 'NEW').NOTNEW\n&NXTSEG  SETA  2\n&PJ0     SETC  'ZZS1&BK'\n&PJ1     SETC  'ZZSZ&BK'\n&PJ2     SETC  'ZZS2&BK'\n&PJ3     SETC  'ZZP1&BK'\n&PJ4     SETC  'ZZQ1&BK'\n         AGO   .ALDN\n.NOTNEW  ANOP\n&GQ3     EQU   &GQ1-&GQ2               OFFSET OF FIRST PIECE OF DATA\n&$SEGL   EQU   *-&$SEGST               FINISH OFF PREVIOUS SEGMENT\n&J       SETA  &NXTSEG+1               GET NEXT SEGMENT NUMBER\n&K       SETA  &NXTSEG-1               GET PREVIOUS SEGMENT NUMBER\n&PJ0     SETC  'ZZS&NXTSEG&BK'         CURRENT LABEL\n&PJ1     SETC  'ZZS&K&BK'              PREVIOUS LABEL\n&PJ2     SETC  'ZZS&J&BK'              NEXT LABEL\n&PJ3     SETC  'ZZP&NXTSEG&BK'\n&PJ4     SETC  'ZZQ&NXTSEG&BK'\n&NXTSEG  SETA  &NXTSEG+1\nCBBKLS   $CECT\n         $C    XL4'00'                 END PREVIOUS SEGMENT FIELDS\n.ALDN    ANOP\n&$LN     SETA  1\n&$CO     SETA  1\n&$SEGST  SETC  ''                      SET SEGMENT START TO NULL\n&$SEGL   SETC  '&PJ3'                  SET LABEL FOR EQU\n&$SEGO   SETC  '&PJ4'                  SET LABEL FOR EQU\nCBBKLS   $CECT\n&PJ0     $C    A(&PJ1)                 PREVIOUS SEGMENT ADDR\n         $C    A(&PJ2)                 NEXT SEGMENT ADDR\n         $C    AL2(&PJ3)               LENGTH OF DATA TO FETCH\n         $C    AL2(&PJ4)               OFFSET OF DATA FROM START OF CB\n         AIF   ('&NBS' EQ '').SETZERO\n&J       SETA  1\n.LKLP    ANOP\n         AIF   ('&NBS' EQ '&#SEGD(&J)').SETFND SEE IF FOUND SEGMENT\n&J       SETA  &J+1\n         AIF   (&J LE 10).LKLP         KEEP GOING FOR ALL ENTRIES\n         AGO   .SETZERO\n.SETFND  $C    AL2(4)\n         $C    AL2(&#SEGO(&J)-&ORGBSE)\n         AGO   .SETDONE\n.SETZERO $C    AL2(0,0)\n.SETDONE ANOP\n&SYSECT  &SECTYP\n         MEND\n         EJECT\n         MACRO\n         BKEND\n         GBLC  &SECTYP\n         GBLC  &$SEGL,&$SEGST\n         GBLA  &NXTSEG,&BK\n         GBLC  &GQ1,&GQ2,&GQ3\n         LCLA  &J\n         LCLC  &PJ1\n.*\n.**      END OF CONTROL BLOCK MACRO\n.*\n&GQ3     EQU   &GQ1-&GQ2               OFFSET OF FIRST PIECE OF DATA\n&$SEGL   EQU   *-&$SEGST\nCBBKLS   $CECT\n         $C    XL4'00'                 END PREVIOUS SEGMENT FIELDS\n&PJ1     SETC  'ZZS&NXTSEG&BK'\n&PJ1     EQU   ZZS1&BK\n&J       SETA  &NXTSEG-1\nZZSZ&BK  EQU   ZZS&J&BK\n&SYSECT  &SECTYP\n         MEND\n         EJECT\nDUMMY    CSECT\nDUMMY    AMODE 31\nDUMMY    RMODE ANY\nCBBKLS   AMODE 31\nCBBKLS   RMODE ANY\nCBMACS   AMODE 31\nCBMACS   RMODE ANY\n         PRINT GEN\nCVT      BKSTR XL4'0A0307FE',CVTEXIT,CVT,CVT,                          X\n               (CVTSMEXT,CVTVSTGX,                                     X\n               CVTEXT1,CVTXTNT1,                                       X\n               CVTEXT2,CVTXTNT2)\n         CVT   DSECT=YES,LIST=YES\n         BKEND\nACEE     BKSTR CL4'ACEE',ACEEACEE,ACEE,ACEE\n         IHAACEE  ,\n         BKEND\nASCB     BKSTR CL4'ASCB',ASCBASCB,ASCB,ASCB\n         IHAASCB LIST=YES,DSECT=YES ,\n         BKEND\nASSB     BKSTR CL4'ASSB',ASSBASSB,ASSB,ASSB\n         IHAASSB LIST=YES ,\n         BKEND\nASTE     BKSTR X'DEADFACE',ASTE,ASTE,ASTE\n         IHAASTE DSECT=YES ,\n         BKEND\nASVT     BKSTR C'ASVT',ASVTASVT,ASVT,ASVT\n         IHAASVT LIST=YES,DSECT=YES ,\n         BKEND\nASXB     BKSTR CL4'ASXB',ASXBASXB,ASXB,ASXB\n         IHAASXB  ,\n         BKEND\nBA       BKSTR CL4'MSER',BACBID,BASE,BASE\n         IEEBASEA ,\n         BKEND\nCD       BKSTR X'DEADFACE',CDCHAIN,CDENTRY,CDENTRY\n         IHACDE   ,\n         BKEND\nCIB      BKSTR X'DEADFACE',CIBNEXT,CIB,CIB\nCIB      DSECT\n         IEZCIB   ,\n         BKEND\n*********************************************************************\n*    THE FOLLOWING MACRO CHANGED W/ ESA 4.2 (REMOVED ID FIELD).\n*********************************************************************\n*    CH       BKSTR CL4'CSCB',CHCSIDSH,CSCB,CSCB\nCH       BKSTR X'DEADFACE',CHAIN,CSCB,CSCB\nCSCB     DSECT\n         IEECHAIN ,\n         BKEND\n*********************************************************************\n*    THE FOLLOWING MACROS REQUIRE THE PVTMACS LIBRARY  (ESA 4.1)\n*********************************************************************\n*    CSD      BKSTR CL4'CSD ',CSDCSD,CSD,CSD\n*             IHACSD   ,\n*             BKEND\n*********************************************************************\nDCE      BKSTR X'DEADFACE',DCELEN,DCE,DCE\n         IECDDCE  ,\n         BKEND\nENFCT    BKSTR CL4'ENFC',ENFCTID,ENFCT,ENFCT\n         IEFENFCT ,\n         BKEND\nGDA      BKSTR CL4'GDA ',GDAID,GDA,GDA\n         IHAGDA   ,\n         BKEND\n*********************************************************************\n*    THE FOLLOWING MACROS REQUIRE THE PVTMACS LIBRARY\n*********************************************************************\n*    GVT      BKSTR CL4'GVT ',GVTID,GVT,GVT\n*             ISGGVT   ,\n*             BKEND\n*    GVTX     BKSTR CL4'GVTX',GVTXID,GVTX,GVTX\n*             ISGGVTX  ,\n*             BKEND\n*********************************************************************\nJCT      BKSTR CL4'JCT',JCTJCT,JCT,JCT\nJCT      DSECT\nJCTXXX1  DS    F\nJCTXXX2  DS    F\nJCTXXX3  DS    F\nJCTJCT   DC    CL4'JCT'\n         IEFAJCTB ,\n         BKEND\nJES      BKSTR CL4'JEST',JESCTID,JESCT,JESCT,                          X\n               (JESCTEXT,JESPEXT)\n         IEFJESCT TYPE=DUM    *** TO FORCE REASONABLE EXPANSION\n         BKEND\nJSCB     BKSTR X'DEADFACE',JSCRSV01,IEZJSCB,IEZJSCB\n         IEZJSCB  ,\n         BKEND\n*JMR      BKSTR X'DEADFACE',JMRJOB,JMR,JMR\n*         IEFJMR JMRESEP=NO ,\n*         BKEND\nLCT      BKSTR CL8'ENDOFLCT',LCTLABEL,LCT,LCT\nLCT      DSECT    ,\n         IEFALLCT ,\n         BKEND\nLDA      BKSTR CL4'LDA',LDAID,LDA,LDA\n         IHALDA   ,\n         BKEND\n*********************************************************************\n*    THE FOLLOWING MACROS REQUIRE THE PVTMACS LIBRARY\n*********************************************************************\n*    MPFT     BKSTR CL4'MPFT',MPFTACRN,MPFT,MPFT\n*             IEEZB809 ,\n*             BKEND\n*********************************************************************\nMTT      BKSTR CL4'MTT ',MTTID,MTTABLE,MTTABLE\n         IEEZB806 ,\n         BKEND\nLPDE     BKSTR X'DEADFACE',LPDECHN,LPDE,LPDE\n         IHALPDE  ,\n         BKEND\nOUCB     BKSTR CL4'OUCB',OUCBNAME,OUCB,OUCB\n         IRAOUCB  ,\n         BKEND\nOUXB     BKSTR CL4'OUXB',OUXBNAME,OUXB,OUXB\n         IHAOUXB  ,\n         BKEND\nPCCB     BKSTR CL4'PCCB',PCCACRO,IEFPCCB,IEFPCCB\n         IEFPCCB  ,\n         BKEND\nPPT      BKSTR CL4'PPT ',PPTID,PPT,PPT\n         IEFZB610 ,\n         BKEND\nPSA      BKSTR X'040C0000',FLCIPPSW,PSA,PSA\n         IHAPSA LIST=YES\n         BKEND\nPSCB     BKSTR X'DEADFACE',PSCBUSER,PSCB,PSCB\n         IKJPSCB  ,\n         BKEND\nRB       BKSTR X'DEADFACE',RBEXRTNM,RBBASIC,RBBASIC\n         IHARB    ,\n         BKEND\n         PRINT GEN\nRCVT     BKSTR CL4'RTSS',RCVTID,RCVT,RCVT  *** ACRONYM FOR TOP SECRET\n         ICHPRCVT , NEED A COPY OF MACRO (REMOVE RCVTSNTD DSECT)\n         BKEND\n         PRINT GEN\n*********************************************************************\n*    THE FOLLOWING MACROS REQUIRE THE PVTMACS LIBRARY\n*********************************************************************\n*    RCT      BKSTR CL4'RCT ',RCTRCT,RCT,RCT\n*             IRARCT   ,\n*             BKEND\n*    RTCT     BKSTR CL4'RTCT',RTCTNAME,RTCT,RTCT\n*             IHARTCT  ,\n*             BKEND\n*********************************************************************\nSCCB     BKSTR X'DEADFACE',SCCBHEAD,SCCB,SCCBSCPI\n         IHASCCB ,\n         BKEND\nSSIB     BKSTR CL4'SSIB',SSIBID,SSIB,SSIB\n         IEFJSSIB ,\n         BKEND\nSSOB     BKSTR CL4'SSOB',SSOBID,SSOB,SSOB\n         IEFSSOBH ,\n         BKEND\nSCVT     BKSTR X'DEADFACE',SCVTPGTM,SCVTSECT,SCVTSECT\n         IHASCVT  ,\n         BKEND\nSMCA     BKSTR CL4'SMCA',SMCASMCA,SMCABASE,SMCABASE\n         IEESMCA  ,\n         BKEND\nSSCT     BKSTR CL4'SSCT',SSCTID,SSCT,SSCT\n         IEFJSCVT ,\n         BKEND\n*********************************************************************\n*    THE FOLLOWING MACROS REQUIRE THE PVTMACS LIBRARY\n*********************************************************************\n*    SVC      BKSTR X'DEADFACE',SVCEP,SVCENTRY,SVCENTRY\n*             IHASVC   ,\n*             BKEND\n*********************************************************************\nTCB      BKSTR CL4'TCB ',TCBTCBID,TCBRBP,TCBFIX,                       X\n               (TCBEXT2,TCBXTNT2)\n         IKJTCB LIST=YES\n         BKEND\nTIO      BKSTR X'DEADFACE',TIOT1,TIO,TIO\nTIO      DSECT\n         IEFTIOT1 ,\n         BKEND\nTCT      BKSTR CL4'TCT ',TCTTCT,SMFTCT,SMFTCT\n         IEFTCT   ,\n         BKEND\nTSB      BKSTR X'DEADFACE',TSBASCBA,TSB,TSB\n         IKJTSB   ,\n         BKEND\nTSVT     BKSTR CL4'TSVT',TSVTTSVT,TSVT,TSVT\n         IKJTSVT  ,\n         BKEND\nLWA      BKSTR CL8'   LWA  ',LWALWA,LWA,LWA\n         IKJEFLWA ,\n         BKEND\nUPT      BKSTR X'DEADFACE',UPTUSER,UPT,UPT\n         IKJUPT   ,\n         BKEND\n* ----------------------------------------------------------------- *\n* --   UNDOCUMENTED IBM CONTROL BLOCKS                           -- *\n* ----------------------------------------------------------------- *\nTPVT     BKSTR CL4'TPVT',TPVT_ID,TPVT,TPVT\n         IKJTPVT  ,\n         BKEND\nCTLT     BKSTR CL4'CTLT',CTLTID,CTLT,CTLT\n         IKJCTLT  ,\n         BKEND\n* ----------------------------------------------------------------- *\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DUDASD": {"ttr": 2563, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00B\\x01\\x142O\\x01\\x142O\\x11Q\\x01\\x8c\\x01\\x8c\\x00\\x00\\xc1`\\xc3\\xc8\\xc5\\xd5\\xc7@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2014-11-20T00:00:00", "modifydate": "2014-11-20T11:51:42", "lines": 396, "newlines": 396, "modlines": 0, "user": "A-CHENG"}, "text": "DUDASD   TITLE 'TSO CP TO DISPLAY ON THE ON-LINE VOLUME SERIAL'\n******************************************************************\n*  SOURCE IS ORIGINATED FROM CBT TAPE FILE 300\n*\n*  FUNCTION: SAME AS MVS COMMAND D U,DASD,ONLINE\n*\n*  MODIFIED BY ALBERT CHENG. FOR DETAIL PLEASE REFER THE COMMENT\n*  THE PROGRAM IS CODED USING TSOCP CONVENTION AND PUTLINE.\n*\n*  REGISTER\n*  R2   - IOPL\n*  R3   - CPPL\n*  R4   - LOOP COUNT (NO OF ELEMENT IN DISPLAY LINE)\n*  R5   - OUTPUT BUFFER POINTER\n*  R6   - ECT\n*  R7   - NOT IN USE\n*  R8   - VIKJPCL/UIKJPCL\n*  R9   - LENGTH OF EXECUTE COMPARE\n*         (IE LENGTH OF INPUT VOLUME SERAIL-1)\n*  R10  - UCBOB\n*  R11  - NOT IN USE\n*  R12  - PROGRAM BASE REGISTER\n*\n*  ABSTRACT\n*  1) REMOVE SOME BUG\n*                                       (ALBERT CHENG)   10 MAR 86\n*  2) MVS/XA ENHANCEMENT\n*                                       (ALBERT CHENG)    1 MAR 87\n*  3) ACCEPT GENERIC VOLUME SERIAL\n*                                       (ALBERT CHENG)    9 OCT 90\n*  4) SUPPORT 4 DIGITS UNIT NUMBER\n*                                       (ALBERT CHENG)   10 FEB 03\n*  5) REMOVE MACRO JVDENTER AND JVDLEAVE.\n*     USE BAKR AND PR.                  (ALBERT CHENG)   14 APR 12\n*\n*  6) PREVENT X'00' FROM LEFT OVER OUPUT FOR THE\n*     LAST UNIT RETURN FROM UCBSCAN     (SAM GOLOB)       4 AUG 14\n*\n*  7) A) ADD ALIAS COMMAND DU TO DISPLAY ALL THE ONLINE VOLUME\n*        SERIAL BY UNIT ADDRESS\n*        DUO 1000        (DISPLAY DASD FROM 1000 TO FFFF)\n*        DUO 1000:1FFF   (DISPLAY DASD FROM 1000 TO 1FFF)\n*     B) ADD ALIAS COMMAND DUA TO DISPLAY THE STATUS OF THE DASD\n*        (ONLINE AND OFFLINE) BY UNIT ADDRESS\n*        DUA             (DISPLAY DASD FROM 0000 TO FFFF)\n*        DUA 1000        (DISPLAY DASD FROM 1000 TO FFFF)\n*        DUA 0A00:1FFF   (DISPLAY DASD FROM 0A00 TO 1FFF)\n*     C) CHANGE THE PROGRAM BASE REGISTER FROM R11 TO R12\n*        USUALLY R12 IS THE PROGRAM BASE REGISTER\n*     D) USE RELATIVE JUMP\n*        CANNOT GET RID OF PROGRAM BASE REGISTER BECAUSE\n*        PUTLINE MACRO STILL USE TRAIDITIONAL BRANCH INSTRUCTION\n*                                       (ALBERT CHENG)    1 SEP 14\n*  8) SUPPORT WILDCARD\n*        DUDASD SY*\n*        DUDASD SY??0*\n*        DUDASD SY??01\n*                                       (ALBERT CHENG)   20 NOV 14\n*******************************************************************\n TITLE 'Z O S   D U D A S D R  ---  D A S D   V S N   D I S P L A Y'\n         PUNCH ' ALIAS DUO'     D U,DASD,ONLINE,UUUU              @07A  00003\n         PUNCH ' ALIAS DUA'     D U,DASD,,UUUU                    @07A  00003\nDUDASD   CSECT\nDUDASD   AMODE    31\nDUDASD   RMODE    24\n*        USING    CVTMAP,R11                                      @07C\n         USING    CPPL,R3\n         USING    IOPL,R2\n         USING    ECT,R6                                          @07A\n         USING    UCBOB,R10\n         USING    DUDASD,R12                                      @07C\n         J        START                                           @07A\n         DC       CL8'DUDAD'                                      @07A\n         DC       C'&SYSDATE &SYSTIME'   ASSEMBLE DATE AND TIME   @07A\nSTART    BAKR     R14,0                  SAVE RSA INTO LINKAGE STK@05A\n         LR       R12,R15                                         @07C\n         XC       PREFIX(4),PREFIX       CLEAR PREFIX FOR PUTLINE\n         LA       R15,L'BUFFER+4\n         STH      R15,PREFIX             SAVE LENGTH OF DISPLAY LINE\n         LR       R2,R13                                           @05A\n* INITIALIZE THE IOPL CONTROL BLOCK\n         LR       R3,R1\n         LA       R2,IOPLIST\n         MVC      IOPLECT,CPPLECT        ADDRESS OF ENVIRONMENT CTL TBL\n         MVC      CMDECT,CPPLECT\n         L        R6,CPPLECT                                       @07A\n         MVC      IOPLUPT,CPPLUPT        ADDRESS OF USER PROFILE TABLE\n         MVC      CMDUPT,CPPLUPT\n         MVC      CMDCBUF,CPPLCBUF       ADDRESS OF COMMAND BUFFER\n         XC       ECB,ECB                CLEAR IOPL ECB\n         LA       R15,ECB\n         ST       R15,CMDECB\n         L        R15,VCLADCON           LOAD DUDAD PARSE PARM     @07C\n         CLC      ECTPCMD,DUD                                      @07A\n         JE       SAVEPCL                BRANCH IF YES             @07A\n         L        R15,UCLADCON           LOAD DU PARSE PARM        @07A\nSAVEPCL  ST       R15,CMDPCL\n         LA       R15,CMDANSR\n         ST       R15,CMDANS\n         LA       R5,BUFFER                                        @07A\n         LA       R1,CMDUPT              PROVIDE LIST FOR PARSE\n         LINK     EP=IKJPARS             PARSE COMMAD\n         LTR      R15,R15\n         JNZ      INVALID_UNIT\n         L        R15,CMDANSR            GET POINTER TO ANSWER AREA\n         CLC      ECTPCMD,DUD            DUDASD COMMAND ?          @07A\n         JNE      CHK_DUO_SYNTAX         BRANCH IF NO              @07A\n         L        R8,PVOLUME-DVOL(,R15)    ADDRESS OF VOLSER       @07C\n         LH       R9,PVOLUME+4-DVOL(,R15)  GET SIZE OF VOLSER      @07C\n         ST       R9,VOLL                  SAVE SIZE OF VOLSER     @08A\n         BCTR     R9,R0                  DECREMENT 1 FOR EXECUTE\n         J        SETUP                                            @07A\n* CHECK THE SYNTAX OF DUA AND DUO                                  @07A\nCHK_DUO_SYNTAX    DS  0H                                           @07A\n         L        R8,PSTARTU-DUNIT(,R15)   ADDRESS OF PSTARTU      @07A\n         LH       R9,PSTARTU+4-DUNIT(,R15) GET SIZE OF PSTARTYU    @07A\n         CHI      R9,4                   ONLY FIRST UNIT ?         @07A\n         JE       STARTU                 BRANCH IF YES             @07A\n         CHI      R9,9                                             @07A\n         JNE      DU_ERR1                BRANCH IF YES             @07A\n         CLI      PRMDLIM-PRM(R8),C':'   DELIMITER = ':'           @07A\n         JNE      DU_ERR1                                          @07A\nSTARTU   MVC      WORKAREA(4),PRMSTART-PRM(R8)  TRANSLATE START    @07A\n         TR       WORKAREA(4),TRHEX        UNIT ADDRESS TO HEX     @07A\n         TRT      WORKAREA(4),TRTHEX     START UNIT HEXIDECIMAL TST@07A\n         JNZ      DU_ERR2                BRANCH IF INVALID HEX     @07A\n         PACK     DBLWD(4),WORKAREA(5)   PACK TO MAKE HEX MAKE HEX @07A\n         MVC      DEVNSTRT,DBLWD+1       MOVE STARTING ADDRESS TO  @07A\n         CHI      R9,4                   ONLY START UNIT           @07A\n         JE       SETUP                  BRANCH IF YES             @07A\n         MVC      WORKAREA(4),PRMEND-PRM(R8)  TRANSLATE END UNIT   @07A\n         TR       WORKAREA(4),TRHEX        ADDRESS TO HEX          @07A\n         TRT      WORKAREA(4),TRTHEX     END UNIT EXIDECIMAL TEST  @07A\n         JNZ      DU_ERR3                BRANCH IF INVALID HEX     @07A\n         PACK     DBLWD(4),WORKAREA(5)   PACK TO MAKE HEX MAKE HEX @07A\n         MVC      DEVNEND,DBLWD+1        COPY END UNIT             @07A\n         CLC      DEVNSTRT,DEVNEND       START UNIT > END UNIT ?   @07A\n         JH       DU_ERR4                BRANCH IF IT IS TRUE      @07A\nSETUP    DS       0H\n         XC       SWITCH,SWITCH          CLEAR SWITCH              @07A\n*        L        R11,CVTPTR             LOAD CVT POINTER          @07D\n         XC       WORKAREA,WORKAREA      CLEAN UP WORKAREA\n         XR       R10,R10\n         EJECT\n***  >>>>>>     UCB SCAN ROUTINE - COMMON RETURN POINT     <<<<<<  @04A\nDUUNIT   DS    0H  -----------------FORMAT IOS SCAN PARM LIST      @04A\n         XC    USCNWK,USCNWK                                       @04A\n         XC    DSXAWORK,DSXAWORK       ZERO OUT UCB WORKAREA       @04A\n         LA    R1,DSXAWORK             ADDR OF UCB WORKAREA        @04A\n         ST    R1,DSXAWA               STORE IT IN PARM LIST       @04A\n         LA    R1,DSXACLAS             PTR TO DEV CLAS TO SEARCH   @04A\n         ST    R1,DSXADEVT             STORE IN PARM LIST          @04A\n         MVI   DSXACLAS,UCB3DACC       ONLY SEARCH DASD            @04A\n         LA    R1,DSXAUCBP             AREA TO STORE UCB ADDR      @04A\n         ST    R1,DSXAUCB              IN PARM LIST                @04A\n         OI    DSXAUCB,X'80'           SIGNIFY END OF PARMLIST     @04A\nDULINE   DS    0H                        NEW DISPLAY LINE\n         SPACE\n         MVI   BUFFER,C' '\n         MVC   BUFFER+1(L'BUFFER-1),BUFFER    INIT BUFFER BY BLANK\n         LA    R5,BUFFER\n         LA    R4,L'BUFFER/L'ELEMENT     NO. OF ENTRIES PER LINE\n         USING ELEMENT,R5\n         SPACE\nUCBLOOP  UCBSCAN COPY,                 NOT APF AUTHORIZED              +\n               WORKAREA=USCNWK,        100-BYTE WORK AREA/SCAN TOKEN   +\n               UCBAREA=USCNUCB,        48-BYTE UCB BASE COPY AREA      +\n               DEVNCHAR=ELEUNIT,       4-BYTE DEVICE NUMBER            +\n               DCEAREA=DCEAREA,        UCB COMMON SEGMENT              +\n               DCELEN=DCELENG,         LENGTH OF DCE                   +\n               DYNAMIC=YES,            UCB CLASS EXTENSION AREA        +\n               DEVN=DEVNSTRT,          START UNIT ADDRESS         @07C +\n               RANGE=ALL,              INCLUDE 4-DIGIT NUMBERS         +\n               NONBASE=NO,             JUST NEED 1 EXPOSURE PER DISK   +\n               DEVCLASS=DASD,          ONLY INTERESTED IN DISKS        +\n               RETCODE=RETCODE,        RETURN CODE                @07A +\n               RSNCODE=RSNCODE,        REASON CODE                @07A +\n               MF=(E,USCNPARM)         POINT TO PARAMETER LIST\n         LTR   R15,R15                 HAS A UCB RETURN ?\n         JNZ   LASTLINE                BRANCH IF NOTHING IS RETURNED\n         LA    R10,USCNUCB               YES, POINT TO UCB COPY    @04A\n         CLC   DUD,ECTPCMD             DUDASD ??                   @07A\n         JE    FMTDASD                   BRANCH IF YES             @07A\n         CLC   UCBCHAN,DEVNEND            LAST DEVICE ADDRESS ?    @07A\n         JH    LASTLINE                   BRANCH IF YES            @07A\n         J     ALLDASD                                             @07A\nFMTDASD  DS    0H                        YES, POINT TO UCB COPY    @04A\n*        CLC   0(3,R8),=CL3'ALL'       DISPLAY ALL THE DASD  ??    @07D\n         CLC   DUD(6),0(R8)            DISPLAY ALL THE DASD  ??    @07C\n         JE    ALLDASD\n*        EX    R9,COMPARE                                          @08D\n*        CALL WILDCARD MATCH SERVICE                               @08A\n         ASAXWC PATTERNSTR=(8),                                        *\n               PATTERNSTRLEN=VOLL,                                     *\n               STRING=UCBVOLI,                                         *\n               STRINGLEN=F0006,                                        *\n               ZEROORMORE=WCZ,                                         *\n               DELIMITER=BLANKS,                                       *\n               ONECHAR=WCO\n         LTR   R15,R15                 .PATTERN MATCH ?            @08A\n         JNZ   UCBLOOP                 .NO                         @08A\n*        JNE   UCBLOOP                                             @08D\nALLDASD  CLC   LASTCUU,ELEUNIT         SAME UNIT ??\n         JE    UCBLOOP                                             @04A\n         TM    SRTESTAT,UCBONLI    80  DEVICE IS ON-LINE ??\n         JO    ONLINE                                              @07C\n         CLC   ECTPCMD,DUA             DUA COMMAND ?               @07A\n         JNE   UCBLOOP                 BRANCH IF NOT TRUE          @07A\n         MVC   ELEVSN,OFFLINE          SET ELEVSN TO OFFLNE        @07A\n         TM    UCBFLA,UCBNRY           DEVICE NOT READY ?          @07A\n         JNO   RESERV                  BRANCH IF NOT TRUE          @07A\n         MVC   ELEVSN,NOTRDY           SET ELEVSN TO F-NRD         @07A\n         J     RESERV                  LOOP                        @07A\nONLINE   MVI   ELEDASH,C'-'\n         MVC   ELEVSN,UCBVOLI          GET VOLUME SERIAL\n         MVI   ELESTAT,C'O'\n         MVC   LASTCUU,ELEUNIT\n         TM    SRTESTAT,UCBALOC    40  ALLOCATED ??\n         JNO   NALLOC\n         MVI   ELESTAT,C'A'\nNALLOC   TM    SRTESTAT,UCBCHGS    08\n         JNO   PUBLIC\n         MVI   ELESTAT,C'P'            ??????\nPUBLIC   TM    UCBSTAB,UCBBPUB\n         JNO   STORAGE\n         MVC   ELESTAT2(L'SLASHP),SLASHP       PUBLIC '/P'         @07C\nSTORAGE  TM    UCBSTAB,UCBBSTR\n         JNO   RESERV\n         MVC   ELESTAT2(L'SLASHS),SLASHS        STORAGE '/S'       @07C\nRESERV   CLI   UCBSQC,0\n         JE    MOUNT\n         MVI   ELERSRV,C'R'            RESERVED\nMOUNT    TM    SRTESTAT,UCBRESV        IS IT RESERVED(MOUNT)\n         JZ    RESIDENT                NO - CHECK RESIDENT\n         MVC   ELEMSTAT(L'SRSV),SRSV   SET C'RSV' IN LINE          @07C\n         J     TSTSYS                   CONTINUE TO NEXT UCB\nRESIDENT TM    SRTESTAT,UCBPRES        IS IT RESIDENT\n         JZ    TSTSYS                   NO - CONTINUE TO NEXT UCB\n         MVC   ELEMSTAT(L'SRSD),SRSD   SET C'RSD' IN LINE          @07C\nTSTSYS   TM    UCBSTAT,UCBSYSR         SYSTEM PACK\n         JZ    ULOOP                   SKIP, IF NO\n         MVI   ELESTAT,C'S'\nULOOP    LA    R5,ELENEXT\n         BRCT  R4,UCBLOOP              NEXT UCB ENTRY\n         SPACE\nPUT      CLI   BUFFER,C' '             EMPTY LINE ?\n         JE    DONE                    BRANCH IF EMPTY LINE\n         SPACE\n         PUTLINE                                                       +\n               PARM=PUTLINE,MF=(E,IOPLIST),ECB=ECB,                    +\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),                     +\n               OUTPUT=(PREFIX,TERM,SINGLE,DATA)\n         SPACE\n         CLI   SWITCH,X'00'\n         JE    DULINE                  IF NOT END THEN\n         EJECT                            PROCEED TO NEXT ENTRY\nDONE     DS    0H\n         IKJRLSA  CMDANSR              FREE PARSE AREA\n         PR                                                        @05A\nLASTLINE OI    SWITCH,X'01'            TURN ON END SWITCH\n         MVC   ELEUNIT(4),BLANKS       PREVENT X'00' FROM UCBSCAN  @06A\n         J     PUT\nINVALID_UNIT   DS  0H                                              @07A\n         MVC   ELEUNIT(L'ERRMSG),ERRMSG                            @07A\n         J     PUT                                                 @07A\nDU_ERR1  DS    0H                                                  @07A\n         MVC   ELEUNIT(L'DUM_ERR1),DUM_ERR1                        @07A\n         J     PUT                                                 @07A\nDU_ERR2  DS    0H                                                  @07A\n         MVC   ELEUNIT(L'DUM_ERR2),DUM_ERR2                        @07A\n         J     PUT                                                 @07A\nDU_ERR3  DS    0H                                                  @07A\n         MVC   ELEUNIT(L'DUM_ERR3),DUM_ERR3                        @07A\n         J     PUT                                                 @07A\nDU_ERR4  DS    0H                                                  @07A\n         MVC   ELEUNIT(L'DUM_ERR4),DUM_ERR4                        @07A\n         J     PUT                                                 @07A\nCOMPARE  CLC   UCBVOLI(1),0(R8)\nVCLADCON DC    A(VIKJPCL)                                          @07A\nUCLADCON DC    A(UIKJPCL)                                          @07A\nDCELENG  DC    H'48'           SPACE FOR THE EVENT CONTROL BLOCK   @04A\nDEVNSTRT DC    XL2'0'                                              @07A\nDEVNEND  DC    XL2'FFFF'                                           @07A\nRETCODE  DC    F'0'                                                @07A\nRSNCODE  DC    F'0'                                                @07A\nF0006    DC    F'6'                                                @08A\nVOLL     DC    F'6'                                                @08A\nDBLWD    DC    D'0'                                                @07A\nSRSD     DC    C'RSD'                                              @07A\nSRSV     DC    C'RSV'                                              @07A\nSLASHS   DC    C'/S'                                               @07A\nSLASHP   DC    C'/P'                                               @07A\nDUO      DC    CL8'DUO'         D U,DASD,ONLINE,UUUU               @07A\nDUA      DC    CL8'DUA'         D U,DASD,,UUUU                     @07A\nDUD      DC    CL8'DUDASD'      D U,DASD,ONLINE                    @07A\nNOTRDY   DC    CL6'F-NRD '                                         @07A\nOFFLINE  DC    CL6'OFFLNE'                                         @07A\nERRMSG   DC    C'EXAMPLE: DU A0B0:A1FF'                            @07A\nDUM_ERR1 DC    C'INVALID SYNTAX  EXAMPLE: DU A0A0:A2FF'            @07A\nDUM_ERR2 DC    C'INVALID START UNIT ADDRESS'                       @07A\nDUM_ERR3 DC    C'INVALID END UNIT ADDRESS'                         @07A\nDUM_ERR4 DC    C'END UNIT ADDRESS IS SMALLER THAN START UNIT ADDRESS'\nBLANKS   DC    CL8' '                                              @06A\nWCZ      DC    C'*'                                                @06A\nWCO      DC    C'?'                                                @06A\nTRTHEX   DS    0X                      VERIFY HEX TABLE            @07A\n         DC    XL16'00'                                            @07A\n         DC    XL240'FF'                                           @07A\n         ORG   TRTHEX+16                                           @07A\nTRHEX    DC    256X'FF'                HEX TRANSLATION TABLE       @07A\n         ORG   TRHEX+C'A'                                          @07A\n         DC    X'0A0B0C0D0E0F'                                     @07A\n         ORG   TRHEX+C'0'                                          @07A\n         DC    X'00010203040506070809'                             @07A\nPARMLIST DS    3F          PARMLIST MAPPING\n         ORG   PARMLIST\nWORKAREA DS    CL100       UCBSCAN ROUTINE WORK AREA\nIOPLIST  DS    07F\nPREFIX   DS    2H\nBUFFER   DS    CL(L'ELEMENT*4)  OUTPUT LINE BUFFER\nLASTCUU  DS    CL4            LAST UNIT ADDRESS                    @04C\nSWITCH   DC    X'01'                                               @07C\nECB      DS    A(0)           ECB POINTER\nCMDANSR  DS    A(0)           PARSE ANSWER AREA POINTER\n* USER PPL (PARSE PARAMETER LIST)\nCMDUPT   DS    A(0)           USER PROFILE TABLE POINTER\nCMDECT   DS    A(0)           ENVIRONMENT CONTROL TABLE\nCMDECB   DS    A(ECB)         ECB POINTER\n*MDPCL   DS    A(IKJPCL)      ADDRESS OF IKJPARM                   @07D\nCMDPCL   DS    A(0)           ADDRESS OF IKJPARM                   @07A\nCMDANS   DS    A(CMDANSR)     PLACE TO PUT ANSWER\nCMDCBUF  DS    A(0)           POINTER TO COMMAND BUFFER\nCMDUWA   DS    A(0)           POINTER TO USER WORK AREA\nCMDVEWA  DS    A(0)           POINTER TO USER WORK AREA USER EXITS\nPUTLINE  PUTLINE MF=L\n         EJECT\n* IKJCPPL - TSO COMMAND PROCESSOR PARAMETER LIST\nUSCNWK   DS    XL100                    UCBSCAN WORK AREA          @04A\nUSCNUCB  DS    XL48                     UCBSCAN UCB COPY AREA      @04A\nDCEAREA  DS    XL48                     @UCB COMMON SEGMENT        @04A\n         UCBSCAN MF=(L,USCNPARM)                                   @04A\nDSXALIST DS    0F                      PARMLIST FOR UCB\nDSXAWA   DS    F                       %100-BYTE WORK AREA\nDSXADEVT DS    F                       %DEV TYPE TO SEARCH\nDSXAUCB  DS    F                       %UCB FULL WORD PTR\n         DS    0D                      FOLLOWING MUST BE ALIGNED\nDSXAWORK DS    CL100                   UCB WORK AREA\nDSXAEUCB EQU   DSXAWORK+00,04          EMULATION CURR. UCB PTR\nDSXAEILK EQU   DSXAWORK+04,04          EMULATION CVTILK2 ADDR\nDSXACLAS DS    CL1                     DEVICE CLASS TO SEARCH\nDSXAUCBP DS    F                       %UCB\n*SAEND   DS    0D\n         EJECT\n         LTORG\nVIKJPCL  IKJPARM DSECT=DVOL                                       @07C\n* IKJPCL TO BEGIN PARAMETER CONTROL LIST (PCL)\nPVOLUME  IKJIDENT 'VOLUME SERIAL',MAXLNTH=6,FIRST=ALPHA,               X\n               DEFAULT='DUDASD',OTHER=ANY                         @07C\n*              OTHER=ALPHANUM,DEFAULT='DUDASD'                    @07D\n* CHANGE THE DEFAULT FROM ALL TO 123456 AS ALL* IS A VALID VOLUME\n* SERIAL. IT IS UNLIKELY DUDASD IS A VOLUME SERAIL.\n         IKJENDP\nUIKJPCL  IKJPARM DSECT=DUNIT                                      @07A\nPSTARTU  IKJIDENT UNIT,LIST,FIRST=ALPHANUM,OTHER=ALPHANUM,CHAR,   @07A X\n               MAXLNTH=9,DEFAULT='0000'                           @07A\n         IKJENDP\n* IKJENDP TO END THE PARAMETER CONTROL LIST (PCL)\n* IKJIOPL - THE I/O PARAMETER LIST FOR GETLINE/PUTLINE/PUTGET/STACK\n         IKJIOPL\n         SPACE\nPRM      DSECT\nPRMSTART DS    CL4     0   START UNIT ADDRESS                     @07A\nPRMDLIM  DS    C       4   DELIMITER                              @07A\nPRMEND   DS    CL4     5   END UNIT ADDRESS                       @07A\nELEWRK   DSECT\nELEMENT  DS    0CL20\nELEUNIT  DS    CL4     0   UNIT NAME                              @04C\n         DS    CL1     4\nELEVSN   DS    CL6     5   VOLUMER SERIAL\nELEDASH  DS    CL1     B   -\nELESTAT  DS    CL1     C   ONLINE / ALLOCATE\nELERSRV  DS    CL1     D   RESERVED\nELEMSTAT DS    CL3     E   RESIDENT/PUB/RESERVED\nELESTAT2 DS    CL3    10                                          @04C\nELENEXT  DS    0CL1\n         SPACE\n******** ***** *********************** END OF UCB LOOKUP DSA\n         PRINT OFF\n         SPACE\n         YREGS\n         EJECT\n         CVT   DSECT=YES\n         IEFUCBOB\n         IKJCPPL\n         IKJECT                                                 @07A\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DUDASD$": {"ttr": 2570, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00I\\x01\\x082\\x1f\\x01\\x18\\x00\\x7f\\x15 \\x00\\x1d\\x00\\x1e\\x00\\x00\\xc1\\xe2\\xd4`\\xd1\\xc3\\xd3@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "2008-11-16T00:00:00", "modifydate": "2018-01-07T15:20:49", "lines": 29, "newlines": 30, "modlines": 0, "user": "ASM-JCL"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,ESD,RLD,BATCH)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.CBT495.FILE264(DUDASD)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,4),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n ENTRY   DUDASD\n SETSSI  CB495264\n SETCODE AC(0)\n NAME    DUDASD(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DUDASD00": {"ttr": 2572, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x14\\x1f\\x00\\x86\\x14/\\x161\\x00\\xa9\\x00\\x86\\x00(\\xe2\\xc1\\xd3\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-05-21T00:00:00", "modifydate": "1986-05-22T16:31:00", "lines": 169, "newlines": 134, "modlines": 40, "user": "SALBERT"}, "text": "//DUDASD       JOB  (U32020,17F),RUDDLE,CLASS=R,MSGCLASS=T\n//*-----------------------------------------------------------------*\n//*       INSTALL OF THE 'DUDASD' TSO CMD                           *\n//*-----------------------------------------------------------------*\n//DUDASD   EXEC ASMHCL,\n//         MAC1='SYS1.AMODGEN',\n//         PARM.LKED='LIST,LET,MAP,XREF,RENT'\n//ASM.SYSLIB  DD   DCB=BLKSIZE=9440\n//            DD\n//            DD\n//            DD   DSN=SFT.INSTALL.TSO.COMMANDS,DISP=SHR\n TITLE 'D U D A S D R  ---   D A S D   V S N   D I S P L A Y'\nDUDASDR  CSECT\n         SPACE\n         USING    DSAWRK,R13\n         USING    CVTMAP,R12\n         USING    CPPL,R1\n         USING    IOPL,R2\n         USING    UCBOB,R10\n         SPACE\n         JVDENTER DSA=(DSAEND-DSAWRK),BASE=(R11),VERSION=&SYSPARM\n         SPACE\n         LA       R2,IOPLIST\n         MVC      IOPLECT,CPPLECT\n         MVC      IOPLUPT,CPPLUPT\n         XC       ECB,ECB\n         XC       PREFIX(4),PREFIX\n         LA       R15,L'BUFFER+4\n         STH      R15,PREFIX\n         L        R12,CVTPTR\n*                                                                XA-BFG\n**  SUPPORT FOR MVS/XA UCB SEARCH ROUTINE                        XA-BFG\n*                                                                XA-BFG\nMYILK2   EQU   X'28'               CVTILK2 OFFSET IN NON-XA      XA-BFG\nMYUCBSC  EQU   X'434'              CVTUCBSC OFFSET IN XA         XA-BFG\n         TM    CVTDCB,X'93'        Q. IS THIS XA                 XA-BFG\n         BO    XA1                 A. YES                        XA-BFG\n         L     R7,MYILK2(,R12)     GET LOOKUP TABLE              XA-BFG\n         B     AL1                                               XA-BFG\nXA1      DS    0H                                                XA-BFG\n         XC    IOSWK(100),IOSWK    CLEAR WORKAREA                XA-BFG\n         LA    R1,IOSWK            GET WORK AREA                 XA-BFG\n         ST    R1,IOSPLST          SAVE IT                       XA-BFG\n         LA    R1,=X'20'           SET DASD TYPE                 XA-BFG\n         ST    R1,IOSPLST+4        SAVE IT ALSO                  XA-BFG\n         LA    R1,UCBADD           LOCATION TO PUT ADDRESS       XA-BFG\n         ST    R1,IOSPLST+8        AND THIS ONE TOO              XA-BFG\n         OI    IOSPLST+8,X'80'     SET END OF PARM LIST INDICATORXA-BFG\n         L     R7,MYUCBSC(,R12)    GET ADDRESS OF ROUTINE        XA-BFG\nAL1      DS    0H                                                XA-BFG\n         XR       R10,R10\n         EJECT\nDULINE   EQU   *\n         SPACE\n         MVI   BUFFER,C' '\n         MVC   BUFFER+1(L'BUFFER-1),BUFFER\n         LA    R5,BUFFER\n         LA    R4,L'BUFFER/L'ELEMENT\n         USING ELEMENT,R5\n         SPACE\nDUUNIT   EQU   *\n         TM    CVTDCB,X'93'        Q. IS THIS XA                 XA-BFG\n         BO    XA2                 A. YES                        XA-BFG\n         CLI   0(R7),X'FF'\n         BE    PUT\n         LH    R15,0(R7)\n         LA    R7,2(R7)\n         CR    R15,R10\n         BNH   DUUNIT\n         LR    R10,R15\n         CLI   UCBTYP+2,X'20'\n         BNE   DUUNIT\n         B     AL2                 SKIP XA CODE                  XA-BFG\nXA2      DS    0H                                                XA-BFG\n         LA    R1,IOSPLST          POINT AT PLIST                XA-BFG\n         LR    R15,R7              GET ROUTINE ADDRESS           XA-BFG\n         BALR  R14,R15             CALL ROUTINE                  XA-BFG\n         LTR   R15,R15             Q. ANY ERRORS                 XA-BFG\n         BNZ   PUT                 A. IF SO THEN ALL DONE        XA-BFG\n         L     R15,UCBADD          GET UCB ADDRESS               XA-BFG\n         CR    R15,R10             Q. SEE IF IN ASSCENDING SEQ   XA-BFG\n         BNH   DUUNIT              A. IF NOT THEN IGNORE         XA-BFG\n         LR    R10,R15             SET NEW ADDRESS               XA-BFG\nAL2      DS    0H                                                XA-BFG\n         CLC   LASTCUU,UCBNAME\n         BE    DUUNIT\n         MVC   ELEUNIT,UCBNAME\n         MVC   LASTCUU,UCBNAME\n         MVC   ELEVSN,SRTEVOLI\n         TM    SRTESTAT,UCBONLI\n         BO    ONLINE\n         MVC   ELEVSN,=CL6'(OFF)'\n         B     ULOOP\nONLINE   MVI   ELEDASH,C'-'\n         MVI   ELESTAT,C'O'\n         TM    SRTESTAT,UCBALOC\n         BNO   NALLOC\n         MVI   ELESTAT,C'A'\nNALLOC   TM    SRTESTAT,UCBCHGS\n         BNO   RESERV\n         MVI   ELESTAT,C'P'\nRESERV   CLI   UCBSQC,0\n         BE    MOUNT\n         MVI   ELERSRV,C'R'\nMOUNT    TM    SRTESTAT,UCBRESV        IS IT RESERVED(MOUNT)\n         BZ    RESIDENT                NO - CHECK RESIDENT\n         MVC   ELEMSTAT(3),=C'RSV'     SET C'RSV' IN LINE\n         B     ULOOP                   CONTINUE TO NEXT UCB\nRESIDENT TM    SRTESTAT,UCBPRES        IS IT RESIDENT\n         BZ    ULOOP                   NO - CONTINUE TO NEXT UCB\n         MVC   ELEMSTAT(3),=C'RSD'     SET C'RSD' IN LINE\nULOOP    LA    R5,ELENEXT\n         BCT   R4,DUUNIT\n         SPACE\nPUT      CLI   BUFFER,C' '\n         BE    DONE\n         SPACE\n         PUTLINE                                                       +\n               PARM=PUTLINE,MF=(E,IOPLIST),ECB=ECB,                    +\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),                     +\n               OUTPUT=(PREFIX,TERM,SINGLE,DATA)\n         SPACE\n         B     DULINE\n         EJECT\nDONE     JVDLEAVE\n         EJECT\n         LTORG\n         SPACE\nELEWRK   DSECT\nELEMENT  DS    0CL20\nELEUNIT  DS    CL3\n         DS    CL1\nELEVSN   DS    CL6\nELEDASH  DS    CL1\nELESTAT  DS    CL1\nELERSRV  DS    CL1\nELEMSTAT DS    CL3\n         DS    CL2\nELENEXT  DS    0CL1\n         SPACE\nDSAWRK   DSECT\nSSA      DS    18F\nIOPLIST  DS    07F\nECB      DS    01F\nPREFIX   DS    2H\nBUFFER   DS    CL(L'ELEMENT*4)\nLASTCUU  DS    CL3\nPUTLINE  PUTLINE MF=L\nUCBADD   DS    F                   ADDRESS OF FOUND UCB          XA-BFG\nIOSPLST  DS    3F                  PARM LIST                     XA-BFG\nIOSWK    DS    25F                 IOS WORK AREA                 XA-BFG\nDSAEND   DS    0D\n         EJECT\n         IKJIOPL\n         EJECT\n         IKJCPPL\n         EJECT\nUCBWRK   DSECT\n         IEFUCBOB\n         SPACE\n         JVDEQU\n         EJECT\n         CVT   DSECT=YES\n         END   DUDASDR\n//LKED.SYSLMOD DD DSN=ISPVS.TEST.LOAD,DISP=SHR,UNIT=,SPACE=\n//SYSIN    DD *\n  ENTRY DUDASDR\n  NAME DUDASD(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DUDASD01": {"ttr": 2819, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01#\\x00%\\x01\\x12)o\\x01\\x14!o\\x116\\x00\\xf2\\x00\\xec\\x00\\x00\\xd7\\xd9\\xc5\\xe5\\xc9\\xd6\\xe4\\xe2@@'", "ispf": {"version": "01.35", "flags": 0, "createdate": "2012-10-22T00:00:00", "modifydate": "2014-08-04T11:36:25", "lines": 242, "newlines": 236, "modlines": 0, "user": "PREVIOUS"}, "text": "DUDASD   TITLE 'TSO CP TO DISPLAY ON THE ON-LINE VOLUUME SERIAL'\n******************************************************************\n*  SOURCE IS ORIGINATED FROM CBT TAPE FILE 300\n*\n*  MODIFIED BY ALBERT CHENG. FOR DETAIL PLEASE REFER THE COMMENT\n*  THE PROGRAM IS CODED USING TSOCP CONVENTION AND PUTLINE.\n*\n*  ABSTRACT\n*  1) REMOVE SOME BUG\n*                                       (ALBERT CHENG)   10 MAR 86\n*  2) MVS/XA ENHANCEMENT\n*                                       (ALBERT CHENG)    1 MAR 87\n*  3) ACCEPT GENERIC VOLUME SERIAL\n*                                       (ALBERT CHENG)    9 OCT 90\n*  4) SUPPORT 4 DIGITS UNIT NUMBER\n*                                       (ALBERT CHENG)   10 FEB 03\n*  5) REMOVE MACRO JVDENTER AND JVDLEAVE\n*                                       (ALBERT CHENG)   14 APR 12\n*\n*  6) PREVENT X'00' FROM LEFT OVER      (SAM GOLOB)       4 AUG 14\n*     OUTPUT  (SBG)\n*\n*******************************************************************\n TITLE 'X A    D U D A S D R  ---   D A S D   V S N   D I S P L A Y'\nDUDASD   CSECT\n         SPACE\n*        USING    DSAWRK,R13                                      @05D\n         USING    CVTMAP,R12\n         USING    CPPL,R3\n         USING    IOPL,R2\n         USING    UCBOB,R10\n*        R8       BASE REGISTER OF INPUT OPERAND\n*        R9       LENGTH OF THE INPUT OPERAND\n         SPACE\n*        JVDENTER DSA=(DSAEND-DSAWRK),BASE=(R11),VERSION=&SYSPARM @05D\n         USING    DUDASD,R11                                      @05A\n         BAKR     R14,0                                           @05A\n         LR       R11,R15                                         @05A\n         LR       R2,R13                                          @05A\n         SPACE\n* INITIALIZE THE IOPL CONTROL BLOCK\n         LR       R3,R1\n         LA       R2,IOPLIST\n         MVC      IOPLECT,CPPLECT        ADDRESS OF ENVIRONMENT CTL TBL\n         MVC      CMDECT,CPPLECT\n         MVC      IOPLUPT,CPPLUPT        ADDRESS OF USER PROFILE TABLE\n         MVC      CMDUPT,CPPLUPT\n         MVC      CMDCBUF,CPPLCBUF       ADDRESS OF COMMAND BUF\n         XC       ECB,ECB                CLEAR IOPL ECB\n         LA       R15,ECB\n         ST       R15,CMDECB\n         L        R15,PCLADCON\n         ST       R15,CMDPCL\n         LA       R15,CMDANSR\n         ST       R15,CMDANS\n         LA       R1,CMDUPT              PROVIDE LIST FOR PARSE\n         LINK     EP=IKJPARS             PARSE COMMAD\n         L        R15,CMDANSR            GET POINTER TO ANSWER AREA\n         USING    IKJPARMD,R15\n         L        R8,IKJOPT              ADDRESS OF VOLSER\n         LH       R9,IKJOPT+4            GET SIZE OF VOLSER\n         BCTR     R9,R0                  DECREMENT FOR EXECUTE\n         DROP     R15\n         XC       PREFIX(4),PREFIX       CLEAR PREFIX FOR PUTLINE\n         LA       R15,L'BUFFER+4\n         STH      R15,PREFIX             SAVE LENGTH OF DISPLAY LINE\n         OI       SWITCH,X'00'\nSETUP    DS       0H\n         L        R12,CVTPTR             LOAD CVT POINTER\n         XC       WORKAREA,WORKAREA      CLEAN UP WORKAREA\n         XR       R10,R10\n         EJECT\n***  >>>>>>     UCB SCAN ROUTINE - COMMON RETURN POINT     <<<<<<  @04A\nDUUNIT   DS    0H  -----------------FORMAT IOS SCAN PARM LIST      @04A\n         XC    USCNWK,USCNWK                                       @04A\n         XC    DSXAWORK,DSXAWORK       ZERO OUT UCB WORKAREA       @04A\n         LA    R1,DSXAWORK             ADDR OF UCB WORKAREA        @04A\n         ST    R1,DSXAWA               STORE IT IN PARM LIST       @04A\n         LA    R1,DSXACLAS             PTR TO DEV CLAS TO SEARCH   @04A\n         ST    R1,DSXADEVT             STORE IN PARM LIST          @04A\n         MVI   DSXACLAS,UCB3DACC       ONLY SEARCH DASD            @04A\n         LA    R1,DSXAUCBP             AREA TO STORE UCB ADDR      @04A\n         ST    R1,DSXAUCB              IN PARM LIST                @04A\n         OI    DSXAUCB,X'80'           SIGNIFY END OF PARMLIST     @04A\nDULINE   DS    0H                        NEW DISPLAY LINE\n         SPACE\n         MVI   BUFFER,C' '\n         MVC   BUFFER+1(L'BUFFER-1),BUFFER    INIT BUFFER BY BLANK\n         LA    R5,BUFFER\n         LA    R4,L'BUFFER/L'ELEMENT     NO. OF ENTRIES PER LINE\n         USING ELEMENT,R5\n         SPACE\nUCBLOOP  UCBSCAN COPY,                 NOT APF AUTHORIZED              +\n               WORKAREA=USCNWK,        100-BYTE WORK AREA/SCAN TOKEN   +\n               UCBAREA=USCNUCB,        48-BYTE UCB BASE COPY AREA      +\n               DEVNCHAR=ELEUNIT,       4-BYTE DEVICE NUMBER            +\n               DCEAREA=DCEAREA,        UCB COMMON SEGMENT              +\n               DCELEN=DCELENG,         LENGTH OF DCE                   +\n               DYNAMIC=YES,            UCB CLASS EXTENSION AREA        +\n               DEVN=0,                 START WITH THE FIRST UCB        +\n               RANGE=ALL,              INCLUDE 4-DIGIT NUMBERS         +\n               NONBASE=NO,             JUST NEED 1 EXPOSURE PER DISK   +\n               DEVCLASS=DASD,          ONLY INTERESTED IN DISKS        +\n               MF=(E,USCNPARM)         POINT TO PARAMETER LIST\n         LTR   R15,R15                 HAS A UCB RETURN ?\n         BNZ   LASTLINE                BRANCH IF NOTHING IS RETURNED\n         LA    R10,USCNUCB               YES, POINT TO UCB COPY     @4A\n         CLC   0(3,R8),=CL3'ALL'       DISPLAY ALL THE DASD  ??\n         BE    ALLDASD\n         EX    R9,COMPARE\n         BNE   UCBLOOP                                             @04A\nALLDASD  CLC   LASTCUU,ELEUNIT         SAME UNIT ??\n         BE    UCBLOOP                                             @04A\n         TM    SRTESTAT,UCBONLI    80  DEVICE IS ON-LINE ??\n         BNO   UCBLOOP                                             @04A\nONLINE   MVI   ELEDASH,C'-'\n         MVC   ELEVSN,UCBVOLI          GET VOLUME SERIAL\n         MVI   ELESTAT,C'O'\n         MVC   LASTCUU,ELEUNIT                      (MODIFIED)\n         TM    SRTESTAT,UCBALOC    40  ALLOCATED ??\n         BNO   NALLOC\n         MVI   ELESTAT,C'A'\nNALLOC   TM    SRTESTAT,UCBCHGS    08\n         BNO   PUBLIC\n         MVI   ELESTAT,C'P'            ??????\nPUBLIC   TM    UCBSTAB,UCBBPUB\n         BNO   STORAGE\n         MVC   ELESTAT2(2),=C'/P'      PUBLIC\nSTORAGE  TM    UCBSTAB,UCBBSTR\n         BNO   RESERV\n         MVC   ELESTAT2(2),=C'/S'      STORAGE\nRESERV   CLI   UCBSQC,0\n         BE    MOUNT\n         MVI   ELERSRV,C'R'            RESERVED\nMOUNT    TM    SRTESTAT,UCBRESV        IS IT RESERVED(MOUNT)\n         BZ    RESIDENT                NO - CHECK RESIDENT\n         MVC   ELEMSTAT(3),=C'RSV'     SET C'RSV' IN LINE\n         B     TSTSYS                   CONTINUE TO NEXT UCB\nRESIDENT TM    SRTESTAT,UCBPRES        IS IT RESIDENT\n         BZ    TSTSYS                   NO - CONTINUE TO NEXT UCB\n         MVC   ELEMSTAT(3),=C'RSD'     SET C'RSD' IN LINE\nTSTSYS   TM    UCBSTAT,UCBSYSR         SYSTEM PACK  (MODIFIED)\n         BZ    ULOOP                   SKIP, IF NO  (MODIFIED)\n         MVI   ELESTAT,C'S'                         (MODIFIED)\nULOOP    LA    R5,ELENEXT\n         BCT   R4,UCBLOOP              NEXT UCB ENTRY            @04A\n         SPACE\nPUT      DS    0H\n         MVC   ELEUNIT(4),BLANKS       PREVENT X'00' FROM OUTPUT    SBG\n         CLI   BUFFER,C' '\n         BE    DONE\n         SPACE\n         PUTLINE                                                       +\n               PARM=PUTLINE,MF=(E,IOPLIST),ECB=ECB,                    +\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),                     +\n               OUTPUT=(PREFIX,TERM,SINGLE,DATA)\n         SPACE\n         CLI   SWITCH,X'00'\n         BE    DULINE                  IF NOT END THEN\n         EJECT                            PROCEED TO NEXT ENTRY\nDONE     DS    0H\n         IKJRLSA  CMDANSR              FREE PARSE AREA\n         PR                                                       @05A\n*        JVDLEAVE RC=0                                            @05D\nLASTLINE OI    SWITCH,X'01'            TURN ON END SWITCH\n         B     PUT\nCOMPARE  CLC   UCBVOLI(1),0(R8)\nPCLADCON DC    A(IKJPCL)\nDCELENG  DC    H'48'           SPACE FOR THE EVENT CONTROL BLOCK  @04A\nBLANKS   DC    CL8' '\n*SAWRK   DSECT                                                    @05D\n*SSA     DS    18F         SYSTEM SAVE AREA                       @05D\nPARMLIST DS    3F          PARMLIST MAPPING\n         ORG   PARMLIST\nWORKAREA DS    CL100       UCBSCAN ROUTINE WORK AREA\nIOPLIST  DS    07F\nPREFIX   DS    2H\nBUFFER   DS    CL(L'ELEMENT*4)  OUTPUT LINE BUFFER\nLASTCUU  DS    CL4            LAST UNIT ADDRESS                  @04C\nSWITCH   DS    C\nECB      DS    A(0)           ECB POINTER\nCMDANSR  DS    A(0)           PARSE ANSWER AREA POINTER\n* USER PPL (PARSE PARAMETER LIST)\nCMDUPT   DS    A(0)           USER PROFILE TABLE POINTER\nCMDECT   DS    A(0)           ENVIRONMENT CONTROL TABLE\nCMDECB   DS    A(ECB)         ECB POINTER\nCMDPCL   DS    A(IKJPCL)      ADDRESS OF IKJPARM\nCMDANS   DS    A(CMDANSR)     PLACE TO PUT ANSWER\nCMDCBUF  DS    A(0)           POINTER TO COMMAND BUFFER\nCMDUWA   DS    A(0)           POINTER TO USER WORK AREA\nCMDVEWA  DS    A(0)           POINTER TO USER WORK AREA USER EXITS\nPUTLINE  PUTLINE MF=L\n         EJECT\n* IKJCPPL - TSO COMMAND PROCESSOR PARAMETER LIST\nUSCNWK   DS    XL100                    UCBSCAN WORK AREA       @04A\nUSCNUCB  DS    XL48                     UCBSCAN UCB COPY AREA   @04A\nDCEAREA  DS    XL48                     @UCB COMMON SEGMENT     @04A\n         UCBSCAN MF=(L,USCNPARM)                                @04A\nDSXALIST DS    0F                      PARMLIST FOR UCB\nDSXAWA   DS    F                       %100-BYTE WORK AREA\nDSXADEVT DS    F                       %DEV TYPE TO SEARCH\nDSXAUCB  DS    F                       %UCB FULL WORD PTR\n         DS    0D                      FOLLOWING MUST BE ALIGNED\nDSXAWORK DS    CL100                   UCB WORK AREA\nDSXAEUCB EQU   DSXAWORK+00,04          EMULATION CURR. UCB PTR\nDSXAEILK EQU   DSXAWORK+04,04          EMULATION CVTILK2 ADDR\nDSXACLAS DS    CL1                     DEVICE CLASS TO SEARCH\nDSXAUCBP DS    F                       %UCB\n*SAEND   DS    0D\n         EJECT\n         LTORG\nIKJPCL   IKJPARM\n* IKJPCL TO BEGIN PARAMETER CONTROL LIST (PCL)\nIKJOPT   IKJIDENT 'VOLUME SERIAL',MAXLNTH=6,FIRST=ALPHA,               X\n               OTHER=ALPHANUM,DEFAULT='ALL'\n* IKJIDENT TO DESCRIBE A NON-DELIMITER-DEPENDENT POSITIONAL OPERAND\n         IKJENDP\n* IKJENDP TO END THE PARAMETER CONTROL LIST (PCL)\n* IKJIOPL - THE I/O PARAMETER LIST FOR GETLINE/PUTLINE/PUTGET/STACK\n         IKJIOPL\n         SPACE\nELEWRK   DSECT\nELEMENT  DS    0CL20\nELEUNIT  DS    CL4     0   UNIT NAME                            @04C\n         DS    CL1     4\nELEVSN   DS    CL6     5   VOLUMER SERIAL\nELEDASH  DS    CL1     B   -\nELESTAT  DS    CL1     C   ONLINE / ALLOCATE\nELERSRV  DS    CL1     D   RESERVED\nELEMSTAT DS    CL3     E   RESIDENT/PUB/RESERVED\nELESTAT2 DS    CL3    10                                        @04C\nELENEXT  DS    0CL1\n         SPACE\n******** ***** *********************** END OF UCB LOOKUP DSA\n         PRINT OFF\n         SPACE\n         YREGS\n         EJECT\n         CVT   DSECT=YES\n         IEFUCBOB\n         IKJCPPL\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IKJCTLT": {"ttr": 2824, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00F\\x01\\x10\\x15_\\x01\\x10\\x15_\\x01!\\x00\\x11\\x00\\x11\\x00\\x04\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2010-06-04T00:00:00", "modifydate": "2010-06-04T01:21:46", "lines": 17, "newlines": 17, "modlines": 4, "user": "SBGOLOB"}, "text": "         MACRO\n         IKJCTLT\nCTLT     DSECT                         TSO/E Control Table\nCTLTID   DS    CL4'CTLT'               BLOCK ID\nCTLTLEN  DS    H'60'                   LENGTH OF CTLT\nCTLTVERS DS    FL1'2'                  version number\n         DS    X                       UNUSED\nCTLTTE2  DS    A,F,H,H                 IKJEFTE2  PTR,LEN,#ENT,ENT_LEN\nCTLTTE8  DS    A,F,H,H                 IKJEFTE8  PTR,LEN,#ENT,ENT_LEN\nCTLTTNS  DS    A,F,H,H                 IKJEFTNS  PTR,LEN,#ENT,ENT_LEN\nCTLTTAP  DS    A,F,H,H                 IKJEFTAP  PTR,LEN,#ENT,ENT_LEN\nCTLTTBFLGS DS X                        tables built from IKJTSOxx\nCTLTTE2_BUILT EQU X'80'\nCTLTTE8_BUILT EQU X'40'\nCTLTTNS_BUILT EQU X'20'\nCTLTTAP_BUILT EQU X'10'\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IKJEFLWC": {"ttr": 2826, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00T\\x01\\x151/\\x01\\x185\\x1f\\x01\\x14\\x00R\\x00\\x19\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2015-11-08T00:00:00", "modifydate": "2018-12-17T01:14:54", "lines": 82, "newlines": 25, "modlines": 0, "user": "SBGOLOB"}, "text": "*  CHANGES ARE NEEDED IN IKJEFLWA TO FORMAT THE FOLLOWING FIELDS:\n*\n*  Labels shown, have to point to real data, and not to 0CLn or 0XLn.\n*\n*  Compare to your system's real IKJEFLWA macro from SYS1.MODGEN.\n*\n*  D - SYS1.MODGEN       I - LOOK.INSTALL version of IKJEFLWA\n*\n*  SUPERC difference report.......\n*\nI - LWAFLGS  DS 0F\nI -          DS  X\nD -          DS 0F\nD - LWAFLGS  DS  X\n\nI -          DS  X\nD - LWAFLGS2 DS  X\n\nI -          DS  X\nD - LWAFLGS3 DS  X\n\nI - LWAPRMLB DS 0F\nD -          DS 0F\nI -          DS X\nD - LWAPRMLB DS X\n\nOther changes that are necessary to view some field, necessitate\nchanging C constants to X constants, so their hex values will show\nin the display, unless you are sure that they have character values,\nsuch as userid fields.  Sample changes to IKJEFLWA are shown below.\n\nI - LWARNML  DS  XL1                       USED FOR MINOR\nD - LWARNML  DS  CL1                       USED FOR MINOR\n\nI - LWANQDQ  DS  XL12                      USED FOR ENQ/DEQ\nD - LWANQDQ  DS  CL12                      USED FOR ENQ/DEQ\n\nI - LWADEST2 DS  XL8                       USERID FOR SYSOUT\nD - LWADEST2 DS  CL8                       USERID FOR SYSOUT\n\nI - LWASRWAA DS  0CL52                     SRWA AREA\nI - LWASRWAX DS  XL26                      SRWA AREA\nI - LWASRWAY DS  XL26                      SRWA AREA\nD - LWASRWAA DS  CL52                      SRWA AREA\n\nI - LWAICART DS  XL8       CART FOR THE COMMAND\nD - LWAICART DS  CL8       CART FOR THE COMMAND\n\nI - LWARESV4 DS  XL3\nD - LWARESV4 DS  CL3\n\nI -          DS 0F                         PARMLIB FLAGS\nD - LWAPRMLB DS 0F                         PARMLIB FLAGS\nI - LWAPRMLB DS X\nD -          DS X\n\nI - LWALSECL DS XL8                      SECLABEL\nD - LWALSECL DS CL8                      SECLABEL\n\nI - LWAWBLBR DS  XL1                     Left bracket for web client\nD - LWAWBLBR DS  CL1                     Left bracket for web client\nI - LWAWBRBR DS  XL1                     Right bracket for web client\nD - LWAWBRBR DS  CL1                     Right bracket for web client\nI - LWAWBDBQ DS  XL1                     Double quote for web client\nD - LWAWBDBQ DS  CL1                     Double quote for web client\nI - LWAWBCMA DS  XL1                     Comma for use in web client\nD - LWAWBCMA DS  CL1                     Comma for use in web client\nI - LWAWBCLN DS  XL1                     Colon for use in web client\nD - LWAWBCLN DS  CL1                     Colon for use in web client\nI - LWAWBSLH DS  XL1                     Backslash for web client\nD - LWAWBSLH DS  CL1                     Backslash for web client\nI - LWAWBEQU DS  XL1                     Equal sign for web client\nD - LWAWBEQU DS  CL1                     Equal sign for web client\nI - LWAWBSPC DS  XL1                     Space for use in web client\nD - LWAWBSPC DS  CL1                     Space for use in web client\n\nI - LWACNPRF DS  XL24                    CONSOLE profile at logon time\nD - LWACNPRF DS  CL24                    CONSOLE profile at logon time\n\nI - LWATOKEN DS  XL8                     Stack token value\nD - LWATOKEN DS  CL8                     Stack token value\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IKJTPVT": {"ttr": 2829, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x14\\x008\\x01\\x07\\x18/\\x01\\x185\\x0f\\x13\\x11\\x00<\\x00!\\x00%\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.20", "flags": 0, "createdate": "2007-07-01T00:00:00", "modifydate": "2018-12-16T13:11:38", "lines": 60, "newlines": 33, "modlines": 37, "user": "SBGOLOB"}, "text": "* -- The names in this macro have been adjusted for format with CBMACS.\n         MACRO\n         IKJTPVT\nTPVT     DSECT                         TSO PARAMETERS VECTOR TABLE\nTPVT_ID  DS    CL4'TPVT'               BLOCK ID\nTPVT_LEN DS    H'72'                   LENGTH OF TPVT\n****     DS    H'220'                  LENGTH OF TPVT          HTE26E2\nTPVT_VERS DS   FL1'2'                  VERSION\nTPVT_MEM1 DS  0C'IKJTSO00'          07 CURRENT PARMLIB MEMBER  HTE25E2\n         DS    X                                               HTE26E2\nTPVT_MEM DS    CL8'IKJTSO00'        08 CURRENT PARMLIB MEMBER  HTE26E2\nTPVT_GEN DS    F                       PARMLIB generation count\nTPVTCTLT DS    V(CTLT)                 IKJCTLT\nTPVTCTLTLEN  DS F'60'                  length of CTLT\n         DS    4X\nTPVTSEND DS    V(SCB)               20 IKJEESCB   (SYS1.BRODCAST)\nTPVTALPL DS    V(ALPL)                 ALPL       (ALLOCATE defaults)\nTPVTTEST DS    V(TPT)                  TPT (TEST)\nTPVTXPRMD DS   V(XPRM)                 INMXPARM   (XMIT)\nTPVTCONSOLE DS V(CNPRM)             30 IKJCNPRM   (CONSOLE)\nTPVTFCVEC DS   A,F                     FCVE       (Platform commands)\nTPVTHELP DS    V(HCB)               3C IKJEFHCB   (HELP)\nTPVTPPVEC DS   A,F                     PPVE       (Platform programs)\n           ORG  TPVT+X'4C'\nTPVTLOGON DS   X                    4C IKJTSOxx LOGON KEYWORD\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n* The following bit settings must correspond to the same bit settings *\n* in the TSVTFLG1 field of the TSVT (TSVT + X'5') - lower nibble only *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nTPVTPHRS  EQU  X'08'                Password phrase support active\nTPVTAPPL  EQU  X'04'                LOGON applid verification active\nTPVTLGNH  EQU  X'02'                LOGONHERE support is active\nTPVTLGPC  EQU  X'01'                LOGONPREPROMPT is active\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nTPVTUMXL  DS   X                4D  MAXIMUM NUMBER OF CHARS IN USERID\n*   This is a reflection of the value in TSVTUMXL, but the \"real      *\n*   switch\" where the system \"decides\" if 8-character userids are     *\n*   allowed, appears to be TSVT+X'6', not in this value.              *\n*   Permissible values:  X'00' for pre z/OS 2.3 systems               *\n*                        X'07' for z/OS 2.3 with 8-char uids off.     *\n*                        X'08' for z/OS 2.3 with 8-char uids on.      *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n           ORG  TPVT+X'50'\nTPVTDSNAM  DS  CL44'SYS1.PARMLIB'   50 dsname                  HTE26E2\nTPVTVOLSER DS  CL6'SYSCAT'          7C VOLSER                  HTE26E2\n           DS  2X                                              HTE26E2\nTPVTSYSNAM DS  CL8'P390'            84 from system             HTE26E2\nTPVTUSERID DS  CL8'IBMUSERM'        8C by userid               HTE26E2\nTPVTHHMMSS DS  CL8'16:59:56'        94 at hh:mm:ss             HTE26E2\nTPVTYYMMDD DS  CL10'1998-10-29'     9C on yyyy-mm-dd           HTE26E2\n           DS  X'0600'\nTPVTCPUID  DS  F                    CPUID\nTPVTMODEL  DS  H                    CPU Model\nTPVTUPDTIM DS  XL4                  Update Time\nTPVTUPDDAT DS  XL4                  Update Date\nTPVTFEATURE DS  X\n*              X'80'            Dynamic Broadcast Feature is available\nTPVTFEATVER DS X\n         ORG   TPVT+X'DC'              end of TPVT             HTE26E2\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "JLOG": {"ttr": 2831, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x92\\x04\\x8f\\x00\\x92\\x04\\x8f\\t\\x13\\x01\\xc5\\x01\\xc5\\x00\\x00\\xe2\\xc1\\xd3\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-02-17T00:00:00", "modifydate": "1992-02-17T09:13:00", "lines": 453, "newlines": 453, "modlines": 0, "user": "SALBERT"}, "text": "*          DATA SET SFT8MVBFN1 AT LEVEL 002 AS OF 02/17/92\n*          DATA SET SFT8MVBFN  AT LEVEL 002 AS OF 12/05/89              00001**1\n         TITLE 'CURRENT JOB LOG PRINT PROGRAM'                          00002**1\n*********************************************************************** 00003**1\n*        THIS PROGRAM FULFILLS THE NEED TO HAVE JES2 JOBLOGS FROM     * 00004**1\n*        CERTAIN STARTED TASKS.  IT WILL ALSO ALLOW THE JOBLOG TO     * 00005**1\n*        BE ARCHIVED TO SAF IF DESIRED.                               * 00006**1\n*                                                                     * 00007**1\n*        IT MUST BE AUTHORIZED TO FUNCTION PROPERLY.                  * 00008**1\n*                                                                     * 00009**1\n*        INPUT CAN COME FROM EITHER THE EXEC PARM OR SYSIN.  IN BOTH  * 00010**1\n*        CASES THE FORMAT IS ONE OR MORE OF THE FOLLOWING KEYWORDS    * 00011**1\n*        SEPERATED BY BLANKS OR COMMAS:                               * 00012**1\n*                                                                     * 00013**1\n*                JLOG         REQUESTS THE JES JOB LOG                * 00014**1\n*                JCL          REQUESTS THE OS JCL LISTING             * 00015**1\n*                JMSG         REQUESTS THE OS ALLOCATION MSGS         * 00016**1\n*                DSID(#,#,...#)  ONE TO NINE JES2 DATASET IDS (LAST   * 00017**1\n*                                FIVE  CHARACTERS OF THE JES2 DSNAME: * 00018**1\n*                                103 IN 'JES2.JOB00451.SO000103'      * 00019**1\n*                                                                     * 00020**1\n*                                                                     * 00021**1\n*                                                                     * 00022**1\n*                                                                     * 00023**1\n*                       AUTHOR: GUY ALBERTELLI   07/18/82             * 00024**1\n*                       LOCATION: SFT.LINKLIB                         * 00025**1\n*                                                                     * 00026**1\n*                       CHANGED 05/06/87 VAUGHN AUSTIN FOR IBM APAR   * 00027**1\n*                       OZ93770 (PTF UZ82296 - HJE2330) WHICH CHANGED * 00028**1\n*                       LENGTH OF DSID FOR PSO DATASETS TO 6 FROM 4.  * 00029**1\n*                                                                     * 00030**1\n*                       CHANGED 12/04/89 GUY ALBERTELLI FOR 370/ESA.  * 00031**1\n*                        JES2 CHANGED THE NAME OF INPUT DSN FROM      * 00032**1\n*                        '.SI000000' TO 'I0000000'                    * 00033**1\n*                                                                     * 00034**1\n*                       CHANGED 02/03/92 GUY ALBERTELLI FOR ESA 4.2.  * 00035**1\n*                        JES2 CHANGED THE NAME OF INPUT DSN FROM      * 00036**1\n*                        TO USER.JOBNAME.JOBID.DSID.? AND             * 00037**1\n*                        CHANGED SPECIFICATION OF SYSIN TO TEXTUNIT.  * 00038**1\n*                                                                     * 00039**1\n*                       CHANGED 02/17/92 GUY ALBERTELLI               * 00040**2\n*                        IN ESA 4.2 IF DSID HAS NEVER BEEN OPENED,    * 00041**2\n*                        JES WILL ALLOCATE IT BUT NOT OPEN IT. HANDLE * 00042**2\n*                        OPEN ERROR.                                  * 00043**2\n*                                                                     * 00044**2\n*********************************************************************** 00045**1\nJOBLOG   CSECT                                                          00046**1\nSFT8MVBF EQU   JOBLOG                                                   00047**1\n         ENTRY SFT8MVBF                                                 00048**1\n         STM   R14,R12,12(R13)         SAVE REGS                        00049**1\n         BALR  R12,0                   LOAD BASE                        00050**1\n         USING *,R12                   DECLARE BASE                     00051**1\n         LR    R15,R13                 DO                               00052**1\n         LA    R13,SAVE                   FORWARD AND                   00053**1\n         ST    R13,8(R15)                 BACKWARD SAVEAREA             00054**1\n         ST    R15,4(R13)                 CHAINING;                     00055**1\n         ST    R1,INPARM           SAVE PARM LIST                       00056**1\n*                                                                       00057**1\n**       SETUP WORKAREAS FOR MESSAGE PROCESSING                         00058**1\n*                                                                       00059**1\n*        $BFGMSG WORKAR=MSGWORK,MSGAREA=MSGAREA                         00060**1\n         $BFGMSG WORKAR=MSGWORK,MSGAREA=MSGAREA                         00061**1\n         SPACE                                                          00062**1\n*        ACCESS THIS JOB ID                                             00063**1\n         SPACE                                                          00064**1\n         USING PSA,R0                                                   00065**1\n         L     R1,PSATOLD          POINT AT TCB                         00066**1\n         L     R1,TCBJSCB-TCB(R1)  GET TO JSCB                          00067**1\n         L     R1,JSCBACT-IEZJSCB(R1) GET TO ACTIVE JSCB                00068**1\n         L     R1,JSCBSSIB-IEZJSCB(R1) GET TO GOOD SSIB                 00069**1\n         USING SSIB,R1                                                  00070**1\n         MVC   MYJBID,SSIBJBID     MOVE IN NAME                         00071**1\n         OC    MYJBID+3(5),=C'00000'                                    00072**1\n         DROP  R1                                                       00073**1\n*                                                                       00074**1\n**       PARSE THE PARM STRING IF ANY                                   00075**1\n*                                                                       00076**1\n         L     R2,INPARM           GET PARM LIST POINTER                00077**1\n         L     R2,0(R2)            GET PARM STRING POINTER              00078**1\n         CLC   0(2,R2),=H'0'       ANY STRING                           00079**1\n         BE    TRYSYSIN            NOPE                                 00080**1\n         MVI   FLAG,0              SET OFF ALL FLAGS                    00081**1\n         XC    DSAREA,DSAREA       SET OFF ALL FLAGS                    00082**1\n         KEYVAL (R2),KEYTAB                                             00083**1\n         B     RCTBL(R15)          GO AND PROCESS IN LOOP               00084**1\nTRYSYSIN DS    0H                                                       00085**1\n*                                                                       00086**1\n**       OPEN SYSIN AND PROCESS EACH CARD                               00087**1\n*                                                                       00088**1\nLOOPA    TM    SYSIN+48,X'10'      IS DCB OPEN                          00089**1\n         BO    LOOPB               IF SO THEN READ CARD                 00090**1\n         OPEN  (SYSIN,(INPUT))                                          00091**1\n         TM    SYSIN+48,X'10'      IS DCB OPEN                          00092**1\n         BZ    NOSYSIN             IF NOT THEN QUIT                     00093**1\nLOOPB    GET   SYSIN,CARD                                               00094**1\n         MVI   FLAG,0              SET OFF ALL FLAGS                    00095**1\n         XC    DSAREA,DSAREA       SET OFF ALL FLAGS                    00096**1\n         KEYVAL CRDHEAD,KEYTAB                                          00097**1\n         B     RCTBL(R15)                                               00098**1\nRCTBL    B     PROCESS             =0  CARD PARSED                      00099**1\n         B     ERR1                =4  VALUE OF KEYWORD BAD             00100**1\n         B     ERR2                =8  KEYWORD INVALID                  00101**1\n         B     ERR3                =12 NUMBR OF VALUES WRONG            00102**1\n         B     PROCESS             =16 CARD BLANK                       00103**1\n         B     ERR4                =20 TYPE CHECK FAILED                00104**1\n         B     ERR5                =24 LENGTH CHECK FAILED              00105**1\n*                                                                       00106**1\n**       VALUE OF KEYWORD INVALID                                       00107**1\n*                                                                       00108**1\nERR1     DS    0H '                                                     00109**1\n         LR    R2,R0               SAVE POINTER                         00110**1\n         $BFGMSG 9,(C4,(R2))                                            00111**1\n         B     LOOPA                                                    00112**1\n*                                                                       00113**1\n**       KEYWORD INVALID                                                00114**1\n*                                                                       00115**1\nERR2     DS    0H                                                       00116**1\n         LR    R2,R0               SAVE POINTER                         00117**1\n         $BFGMSG 5,(C8,(R2))                                            00118**1\n         B     LOOPA                                                    00119**1\n*                                                                       00120**1\n**       NUMBER OF VALUES WRONG                                         00121**1\n*                                                                       00122**1\nERR3     DS    0H                                                       00123**1\n         LR    R2,R0               SAVE POINTER                         00124**1\n         $BFGMSG 6,(C4,(R2))                                            00125**1\n         B     LOOPA                                                    00126**1\n*                                                                       00127**1\n**       TYPE CHECK FAILED                                              00128**1\n*                                                                       00129**1\nERR4     DS    0H                                                       00130**1\n         LR    R2,R0               SAVE POINTER                         00131**1\n         $BFGMSG 7,(C4,(R2))                                            00132**1\n         B     LOOPA                                                    00133**1\n*                                                                       00134**1\n**       LENGTH CHECK FAILED                                            00135**1\n*                                                                       00136**1\nERR5     DS    0H                                                       00137**1\n         LR    R2,R0               SAVE POINTER                         00138**1\n         LR    R3,R1               SAVE POINTER                         00139**1\n         $BFGMSG 8,(C4,(R2)),(C8,(R3))                                  00140**1\n         B     LOOPA                                                    00141**1\n*                                                                       00142**1\n**       IF REQUESTED THEN DUMP OUT THE JLOG                            00143**1\n*                                                                       00144**1\nPROCESS  TM    FLAG,FJLOG          JLOG REQUESTED ?                     00145**1\n         BZ    TRYJCL                                                   00146**1\n         LA    R1,MYJBID           POINT TO MY JOBID                    00147**1\n         LA    R0,2                THE DSID FOR JES LOG                 00148**1\n         LA    R15,MOVEJES         GO AND MOVE IT                       00149**1\n         BALR  R14,R15             GO AND MOVE IT                       00150**1\n*                                                                       00151**1\n**       IF REQUESTED THEN DUMP OUT THE JCL                             00152**1\n*                                                                       00153**1\nTRYJCL   TM    FLAG,FJCL           JCL REQUESTED ?                      00154**1\n         BZ    TRYJMSG                                                  00155**1\n         LA    R1,MYJBID           POINT TO MY JOBID                    00156**1\n         LA    R0,3                THE DSID FOR JES JCL                 00157**1\n         LA    R15,MOVEJES         GO AND MOVE IT                       00158**1\n         BALR  R14,R15             GO AND MOVE IT                       00159**1\n*                                                                       00160**1\n**       IF REQUESTED THEN DUMP OUT THE JMSG                            00161**1\n*                                                                       00162**1\nTRYJMSG  TM    FLAG,FJMSG          JMSG REQUESTED ?                     00163**1\n         BZ    TRYDSID                                                  00164**1\n         LA    R1,MYJBID           POINT TO MY JOBID                    00165**1\n         LA    R0,4                THE DSID FOR MVS ALLOCATION MSGS     00166**1\n         LA    R15,MOVEJES         GO AND MOVE IT                       00167**1\n         BALR  R14,R15             GO AND MOVE IT                       00168**1\n*                                                                       00169**1\n**       IF REQUESTED DO DSIDS                                          00170**1\n*                                                                       00171**1\nTRYDSID  TM    FLAG,FDSID          DSID REQUESTED ?                     00172**1\n         BZ    LOOPA               EXIT IF NOT                          00173**1\n         SR    R5,R5               CLEAR COUNT                          00174**1\n         IC    R5,DSAREA           GET NUMBER TO DO                     00175**1\n         LA    R4,DSAREA+1         POINT TO THE ONE TO DO               00176**1\n         LTR   R5,R5               ANY TO DO                            00177**1\n         BZ    LOOPA               IF NOT THEN ALL DONE                 00178**1\nLOOP1    SR    R2,R2               CLEAR FOR LENGTH                     00179**1\n         IC    R2,0(R4)            GET LENGTH OF DATA                   00180**1\n         BCTR  R2,0                GET MACHING LENGTH                   00181**1\n         EX    R2,PACKIT                                                00182**1\n         LA    R4,2(R2,R4)                                              00183**1\n         CVB   R0,DWORK            GET ID                               00184**1\n         LA    R1,MYJBID                                                00185**1\n         LA    R15,MOVEJES         GO AND MOVE IT                       00186**1\n         BALR  R14,R15             GO AND MOVE IT                       00187**1\n         BCT   R5,LOOP1            DO NEXT ID                           00188**1\n         B     LOOPA               ALL DONE                             00189**1\nPACKIT   PACK  DWORK,1(0,R4)                                            00190**1\n*                                                                       00191**1\n**       OUT OF SYSIN DATA                                              00192**1\n*                                                                       00193**1\nNOCARD   DS    0H                                                       00194**1\n         CLOSE (SYSIN)                                                  00195**1\n         B     EXITPGM             ALL DONE                             00196**1\n*                                                                       00197**1\n**       IF NO SYSIN AVAILABLE AND THERE WAS NO PARM STRING             00198**1\n**       THEN JUST DUMP OUT THE JLOG                                    00199**1\n*                                                                       00200**1\nNOSYSIN  DS    0H                                                       00201**1\n         L     R2,INPARM           GET PARM LIST POINTER                00202**1\n         L     R2,0(R2)            GET PARM STRING POINTER              00203**1\n         CLC   0(2,R2),=H'0'       ANY STRING                           00204**1\n         BNE   EXITPGM             YES SO WE DID SOMETHING              00205**1\n         LA    R1,MYJBID           POINT TO MY JOBID                    00206**1\n         LA    R0,2                THE DSID FOR JES LOG                 00207**1\n         LA    R15,MOVEJES         GO AND MOVE IT                       00208**1\n         BALR  R14,R15             GO AND MOVE IT                       00209**1\n*                                                                       00210**1\n*  EXIT THE PROGRAM                                                     00211**1\n*                                                                       00212**1\nEXITPGM  L     R13,4(R13)                                               00213**1\n         RETURN (14,12),RC=0                                            00214**1\n         EJECT                                                          00215**1\n*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-* 00216**1\n*                                                                     * 00217**1\n*        THIS SUBROUTINE MOVES ONE JES FILE TO THE OUTPUT             * 00218**1\n*        DATASET.                                                     * 00219**1\n*                                                                     * 00220**1\n*        INPUT                                                        * 00221**1\n*              R1  -->   8 BYTE JOBID                                 * 00222**1\n*              R0  ===   DATASET NUMBER                               * 00223**1\n*                                                                     * 00224**1\n*        OUPUT                                                        * 00225**1\n*              R15 ===   0   DATASET MOVED                            * 00226**1\n*                        4   UNABLE TO ALLOCATE DATASET               * 00227**1\n*                        8   ERROR OCCURED DURING MOVE                * 00228**1\n*                                                                     * 00229**1\n*                                                                     * 00230**1\n*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-* 00231**1\n         PUSH  USING                                                    00232**1\nMOVEJES  PROLOGUE SAVE=INLINE                                           00233**1\n*                                                       ESA4.2 2/92 GLA 00234**1\n**       BUILD DSN                                      ESA4.2 2/92 GLA 00235**1\n*                                                       ESA4.2 2/92 GLA 00236**1\n         MVC   DSN,=CL44' '        CLEAR FIELD          ESA4.2 2/92 GLA 00237**1\n         L     R4,PSAAOLD          GET ASCB             ESA4.2 2/92 GLA 00238**1\n         USING ASCB,R4                                  ESA4.2 2/92 GLA 00239**1\n         ICM   R3,15,ASCBJBNI      GET JOB NAME         ESA4.2 2/92 GLA 00240**1\n         BNZ   *+8                                      ESA4.2 2/92 GLA 00241**1\n         L     R3,ASCBJBNS         GET STC NAME         ESA4.2 2/92 GLA 00242**1\n         L     R4,ASCBASXB         POINT TO ASXB        ESA4.2 2/92 GLA 00243**1\n         L     R4,ASXBSENV-ASXB(,R4) GET ACEE ADDR      ESA4.2 2/92 GLA 00244**1\n         USING ACEE,R4                                  ESA4.2 2/92 GLA 00245**1\n         SR    R5,R5               CLEAR REG            ESA4.2 2/92 GLA 00246**1\n         IC    R5,ACEEUSRL         GET LENGTH           ESA4.2 2/92 GLA 00247**1\n         MVC   DSN(8),ACEEUSRI     MOVE IN USERID       ESA4.2 2/92 GLA 00248**1\n         DROP  R4                                       ESA4.2 2/92 GLA 00249**1\n         LA    R5,DSN(R5)          POINT PAST USERID    ESA4.2 2/92 GLA 00250**1\n         MVI   0(R5),C'.'          SET DELIMITER        ESA4.2 2/92 GLA 00251**1\n         LA    R5,1(,R5)           BUMP POINTER         ESA4.2 2/92 GLA 00252**1\n         MVC   0(8,R5),0(R3)       MOVE IN JOB NAME     ESA4.2 2/92 GLA 00253**1\n         LA    R5,8(R5)            POINT PAST           ESA4.2 2/92 GLA 00254**1\nMJ1      CLI   0(R5),C' '          END OF JOB NAME      ESA4.2 2/92 GLA 00255**1\n         BNE   MJ2                 YES- FOUND IT        ESA4.2 2/92 GLA 00256**1\n         BCTR  R5,0                BACK UP              ESA4.2 2/92 GLA 00257**1\n         B     MJ1                 TRY AGAIN            ESA4.2 2/92 GLA 00258**1\nMJ2      MVI   1(R5),C'.'          SET DELIMITER        ESA4.2 2/92 GLA 00259**1\n         LA    R5,2(R5)            BUMP POINTER         ESA4.2 2/92 GLA 00260**1\n         MVC   0(8,R5),0(R1)       MOVE IN ID           ESA4.2 2/92 GLA 00261**1\n         MVC   8(2,R5),=C'.D'      SET NEXT DELIMITER AND HEADER/92 GLA 00262**1\n         LA    R5,10(R5)           BUMP POINTER         ESA4.2 2/92 GLA 00263**1\n         CVD   R0,DWORK            MAKE DECIMAL         ESA4.2 2/92 GLA 00264**1\n         UNPK  0(7,R5),DWORK       PUT IN NUMBER        ESA4.2 2/92 GLA 00265**1\n         OI    6(R5),X'F0'         CONVERT LAST DIGIT   ESA4.2 2/92 GLA 00266**1\n         MVC   7(2,R5),=C'.?'      SET LAST CHARS       ESA4.2 2/92 GLA 00267**1\n*                                                       ESA4.2 2/92 GLA 00268**1\n**       NOW ALLOCATE IT                                ESA4.2 2/92 GLA 00269**1\n*                                                       ESA4.2 2/92 GLA 00270**1\n         MVC   INFO(4),=F'0'       ZERO OUT THE INFO CODES              00271**1\n         LA    R1,DYNALLOC         POINT TO ALLOCATION                  00272**1\n         LR    R5,R1               SAVE R1 IN CASE OF ABEND             00273**1\n         DYNALLOC ALLOCATE THEM                                         00274**1\n         LTR   R15,R15             CHECK ALLOCATION                     00275**1\n         BZ    OPEN                                                     00276**1\n         CLC   INFO(2),=X'0478'    IS DS UNACCESSIBLE                   00277**1\n         BE    BD1                 YES SO DIFFERENT MESSAGE             00278**1\n         $BFGMSG 1,(H2,INFO),(H2,INFO+2)                                00279**1\n         DC    H'0'                                                     00280**1\n         LA    R3,4                SET ALLOCATION ERROR                 00281**1\n         B     ENDJES1                                                  00282**1\nBD1      DS    0H                  CANT ACCESS MESSAGE                  00283**1\n         $BFGMSG 10,(C5,DSID+1)    CHANGED FOR APAR OZ93770       VGA   00284**1\n         DC    H'0'                                                     00285**1\n         LA    R3,4                SET ALLOCATION ERROR                 00286**1\n         B     ENDJES1                                                  00287**1\n         SPACE 3                                                        00288**1\n*                                                                       00289**1\n**       OPEN THE JOB LOG AND OUTPUT FILE                               00290**1\n**       THEN COPY IT                                                   00291**1\n*                                                                       00292**1\nOPEN     DS    0H                                                       00293**1\n         USING IFGACB,R2           SETUP ADDRESS ABILITY                00294**1\n         LA    R2,MACB                                                  00295**1\n         MVC   ACBDDNM,DDNAME      SET DDNAME                           00296**1\n         OPEN  (MACB,(INPUT),OUT,(EXTEND))                              00297**1\n         LTR   R15,R15             GOOD GET                             00298**1\n         BZ    GDOPEN              IF OK                                00299**1\n         $BFGMSG 2,(H1,ACBERFLG)                                        00300**1\n         B     EOF                                     ESA 4.2 02/17/92 00301**2\n         DROP  R2                                                       00302**1\nGDOPEN   NOP   0                                                        00303**1\n         SPACE 3                                                        00304**1\nLOOP     GET   RPL=MRPL            GET A RECORD                         00305**1\n         LTR   R15,R15             GOOD GET                             00306**1\n         BZ    GDGET               IF OK                                00307**1\n         USING IFGRPL,R2                                                00308**1\n         LA    R2,MRPL                                                  00309**1\n*                                                                       00310**1\n**       IF PHYSICAL READ ERROR THEN ASSUME EOF                         00311**1\n*                                                                       00312**1\n         CLI   RPLRTNCD,X'0C'      IS IT PHYSICAL ERROR                 00313**1\n         BNE   BD2                                                      00314**1\n         CLI   RPLERRCD,4          IS IT PHY READ ERROR                 00315**1\n         BE    EOF                 YES SO MAKE EOF                      00316**1\nBD2      DS    0H                                                       00317**1\n         $BFGMSG 3,(H1,RPLRTNCD),(H1,RPLERRCD)                          00318**1\n         DROP  R2                                                       00319**1\n         LA    R3,8                SET RETURN CODE                      00320**1\n         B     ENDJES2             AND EXIT                             00321**1\nGDGET    DS    0H                                                       00322**1\n         SHOWCB RPL=MRPL,AREA=LENGTH,LENGTH=4,FIELDS=(RECLEN)           00323**1\n         LTR   R15,R15             SEE IF OK                            00324**1\n         BZ    GDSHOW              YES                                  00325**1\n         ST    R15,LENGTH                                               00326**1\n         $BFGMSG 4,(H1,LENGTH+3)                                        00327**1\n         LA    R3,8                SET RETURN CODE                      00328**1\n         B     ENDJES2             AND EXIT                             00329**1\nGDSHOW   DS    0H                                                       00330**1\n         L     R1,LENGTH                                                00331**1\n         LA    R1,4(R1)            ADD FOR RDW                          00332**1\n         STH   R1,VBA                                                   00333**1\n         PUT   OUT,VBA             OUTPUT LINE                          00334**1\n         B     LOOP                                                     00335**1\n*                                                                       00336**1\n*  EXIT THE PROGRAM                                                     00337**1\n*                                                                       00338**1\nEOF      EQU   *                                                        00339**1\n         SR    R3,R3                                                    00340**1\nENDJES2  CLOSE (MACB,,OUT)                                              00341**1\nENDJES1  L     R13,4(R13)                                               00342**1\n         LR    R15,R3                                                   00343**1\n         RETURN (14,12),RC=(15)                                         00344**1\n         POP   USING                                                    00345**1\n         EJECT                                                          00346**1\n         PRINT NOGEN                                                    00347**1\n         $BFGMSGD 1,'ALLOCATION FAILED ERRCD=\u00a2, INFO=\u00a2.',ROUTCDE=11     00348**1\n         $BFGMSGD 2,' OPEN FAILED FDBK=\u00a2.',ROUTCDE=11                   00349**1\n         $BFGMSGD 3,' GET FAILED, RC=\u00a2, ERRCD=\u00a2.',ROUTCDE=11            00350**1\n         $BFGMSGD 4,' SHOWCB FAILED, RC=\u00a2.',ROUTCDE=11                  00351**1\n         $BFGMSGD 5,' STRING STARTING WITH ''\u00a2'' IS INVALID.',         X00352**1\n               ROUTCDE=11                                               00353**1\n         $BFGMSGD 6,' NUMBER OF VALUES IN ''\u00a2'' IS ILLEGAL.',          X00354**1\n               ROUTCDE=11                                               00355**1\n         $BFGMSGD 7,' VALUE NOT NUMERIC FOR ''\u00a2''.',                   X00356**1\n               ROUTCDE=11                                               00357**1\n         $BFGMSGD 8,' VALUE FOR ''\u00a2'' THAT STARTS ''\u00a2'' HAS WRONG LENGTH00358**1\n               .',ROUTCDE=11                                            00359**1\n         $BFGMSGD 9,' VALUE INVALID FOR ''\u00a2''.',                       X00360**1\n               ROUTCDE=11                                               00361**1\n         $BFGMSGD 10,' DATASET UNAVAILABLE PROBABLY SPUN DSID=\u00a2',      X00362**1\n               ROUTCDE=11                                               00363**1\n         EJECT                                                          00364**1\n*                                                                       00365**1\n**       INPUT CARD KEY WORDS                                           00366**1\n*                                                                       00367**1\nKEYTAB   KEYT  JLOG,,,,(0,0),                                          X00368**1\n               FIELD1=(,O,FLAG,FJLOG)                                   00369**1\n         KEYT  JCL,,,,(0,0),                                           X00370**1\n               FIELD1=(,O,FLAG,FJCL)                                    00371**1\n         KEYT  JMSG,,,,(0,0),                                          X00372**1\n               FIELD1=(,O,FLAG,FJMSG)                                   00373**1\n         KEYT  DSID,,DSAREA,NUMERIC,(1,9),                             X00374**1\n               FIELD1=(,O,FLAG,FDSID),                                 X00375**1\n               LEN=(1,5),END=YES        CHANGED FOR APAR OZ93770    VGA 00376**1\n         PRINT GEN                                                      00377**1\n         EJECT                                                          00378**1\n*                                                                       00379**1\n**       WORKAREAS FOR MAIN PROGRAM                                     00380**1\n*                                                                       00381**1\nSAVE     DS    18F                                                      00382**1\nMSGWORK  DS    18F                                                      00383**1\nINPARM   DS    F                   PARM LIST VALUE                      00384**1\nMSGAREA  DS    CL133                                                    00385**1\nMYJBID   DS    CL8                 SPACE FOR THIS JOB JBID              00386**1\nFLAG     DC    X'00'               FLAGS                                00387**1\nFJLOG    EQU   X'80'               DUMP JLOG ID=2                       00388**1\nFJCL     EQU   X'40'               DUMP JCL ID=3                        00389**1\nFJMSG    EQU   X'20'               DUMP JMSG ID=4                       00390**1\nFDSID    EQU   X'10'               DUMP LIST OF DSIDS                   00391**1\nDSAREA   DS    (1+(1+3)*9)C        AREA FOR MAX DATA                    00392**1\nCRDHEAD  DC    H'72'                                                    00393**1\nCARD     DS    CL80                                                     00394**1\nSYSIN    DCB   DDNAME=SYSIN,                                           X00395**1\n               LRECL=80,RECFM=FB,EODAD=NOCARD,                         X00396**1\n               MACRF=(GM),DSORG=PS                                      00397**1\n         EJECT                                                          00398**1\n*                                                                       00399**1\n**       WORKAREAS FOR DYNAMIC ALLOCATION                               00400**1\n*                                                                       00401**1\n         DS    0D                                                       00402**1\nDWORK    DS    D                                                        00403**1\nDYNALLOC DC    X'80',AL3(*+3)                                           00404**1\nCODES    DC    X'1401000000000000',A(TEXT,0,0)                          00405**1\nINFO     EQU   CODES+4,2                                                00406**1\nTEXT     DC    A(TEXT1,TEXT2,TEST2A,TEST2B,TEST2C)                      00407**1\n         DC    X'80',AL3(TEXT3)                                         00408**1\nTEXT1    DC    X'005500010008'                DDNAME=                   00409**1\nDDNAME   DC    CL8' '                                                   00410**1\nTEST2A   DC    X'00520000'                    PERMANENT ALLOCATION      00411**1\nTEST2B   DC    X'001C0000'                    FREE AT CLOSE             00412**1\nTEST2C   DC    X'00620001000180'   DALSSAT(SYSIN REQ)   ESA4.2 2/92 GLA 00413**1\nTEXT2    DC    X'005C0000'                    SSREQ                     00414**1\nTEXT3    DC    AL2(2,1,L'DSN)                 DSNAME                    00415**1\nDSN      DC    CL44' '                     CHANGED FOR ESA4.2 2/92 GLA  00416**1\n*        DC    C'JES2.JOB08364.I0000002'   CHANGED FOR ESA 12/04/89 GLA 00417**1\n*        DC    C'JES2.JOB08364.SI000002'   CHANGED FOR APAR OZ93770 VGA 00418**1\nJBID     EQU   DSN+17,8                                                 00419**1\nDSID     EQU   DSN+28,6                    CHANGED FOR APAR OZ93770 VGA 00420**1\n         EJECT                                                          00421**1\n*                                                                       00422**1\n**       WORKAREAS FOR DATA MOVEMENT                                    00423**1\n*                                                                       00424**1\nLENGTH   DC    F'0'                                                     00425**1\nEXLST    EXLST EODAD=(EOF)                                              00426**1\nMACB     ACB   DDNAME=A,                                               X00427**1\n               MACRF=(ADR,SEQ,IN),                                     X00428**1\n               EXLST=EXLST                                              00429**1\nMRPL     RPL   ACB=MACB,                                               X00430**1\n               OPTCD=(ADR,SEQ,SYN,NUP,MVE),                            X00431**1\n               AREA=LINE,                                              X00432**1\n               AREALEN=133                                              00433**1\nOUT      DCB   DDNAME=SYSPRINT,                                        X00434**1\n               LRECL=137,BLKSIZE=141,RECFM=VB,                         X00435**1\n               MACRF=(PM),DSORG=PS                                      00436**1\n         DS    0F                                                       00437**1\nVBA      DC    AL2(0,0)                                                 00438**1\nLINE     DC    CL180' '                                                 00439**1\n         REQUATE                                                        00440**1\n         LTORG                                                          00441**1\n         PRINT NOGEN                                                    00442**1\n         IHAPSA                                                         00443**1\n         IHAASCB ,                                      ESA4.2 2/92 GLA 00444**1\n         IHAASXB ,                                      ESA4.2 2/92 GLA 00445**1\n         IHAACEE ,                                      ESA4.2 2/92 GLA 00446**1\n         IKJTCB                                                         00447**1\n         IEFJSSIB                                                       00448**1\n         IEZJSCB                                                        00449**1\n         IFGACB                                                         00450**1\n         IFGRPL                                                         00451**1\n         END                                                            00452**1\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JVDENTER": {"ttr": 3079, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\\x13o\\x00\\x91\\x13o\\x12\\x00\\x00J\\x00J\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf0\\xf9\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-05-16T00:00:00", "modifydate": "1991-05-16T12:00:00", "lines": 74, "newlines": 74, "modlines": 0, "user": "FILE093"}, "text": "         MACRO , JVDENTER - V1M00 - 01/28/74\n&LABEL   JVDENTER                                                      +\n               &BASE=(11),                                             +\n               &REGS=(14,12),                                          +\n               &ID=,                                                   +\n               &VERSION=,                                              +\n               &DSA=72,                                                +\n               &ORIGIN=*,                                              +\n               &CFL=YES\n.*\n         LCLC  &EPID,&BASR,&START\n.*\n.BEGIN   AIF   ('&LABEL' EQ '').IDT\n.*\n         SPACE\n&LABEL   DS    0H\n         ENTRY &LABEL\n         SPACE\n.*\n.IDT     AIF   (T'&ID EQ 'O').IDD\n&EPID    SETC  '&ID'\n         AGO   .VER\n.IDD     AIF   ('&LABEL' EQ '').IDC\n&EPID    SETC  '&LABEL'\n         AGO   .VER\n.IDC     ANOP\n&EPID    SETC  '&SYSECT'\n.VER     AIF   (T'&VERSION EQ 'O').GEN\n&EPID    SETC  '&EPID-&VERSION-&SYSDATE-&SYSTIME'\n         MNOTE *,'       &EPID'\n.*\n.GEN     ANOP\n&BASR    SETC  '&BASE(1)'\n.*\n&START   SETC  '&ORIGIN'\n         AIF   ('&ORIGIN' NE '@').START\n&START   SETC  '&SYSECT'\n.START   AIF   ('&ORIGIN' EQ '*').HERE\n.*\n         USING &START,&BASR\n         SAVE  &REGS,,&EPID\n         BALR  &BASR,0\n         LA    14,*-&ORIGIN\n         SLR   &BASR,14\n         LR    2,13\n         SPACE\n.*\n         AGO   .GETDSA\n.HERE    ANOP\n.*\n         USING &START,&BASR\n         SAVE  &REGS,,&EPID\n         LR    &BASR,15\n         LR    2,13\n         SPACE\n.*\n.GETDSA  AIF   ('&DSA' EQ '0').NOCFL\n.*\n         LA    3,&DSA\n         GETMAIN R,LV=(3)\n         ST    3,0(1)\n         ST    13,4(1)\n         LR    13,1\n.*\n         AIF   ('&CFL' EQ 'NO').NOCFL\n.*\n         ST    1,8(2)\n.*\n.NOCFL   ANOP\n.*\n         LM    14,04,12(2)\n         SPACE\n.*\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JVDEQU": {"ttr": 3082, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\\x13o\\x00\\x91\\x13o\\x12\\x00\\x00\\x16\\x00\\x16\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf0\\xf9\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-05-16T00:00:00", "modifydate": "1991-05-16T12:00:00", "lines": 22, "newlines": 22, "modlines": 0, "user": "FILE093"}, "text": "         MACRO\n&L       JVDEQU &O\n*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SPACE\n.*\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JVDLEAVE": {"ttr": 3084, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\\x13o\\x00\\x91\\x13o\\x12\\x00\\x007\\x007\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf0\\xf9\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-05-16T00:00:00", "modifydate": "1991-05-16T12:00:00", "lines": 55, "newlines": 55, "modlines": 0, "user": "FILE093"}, "text": "         MACRO , JVDLEAVE - V1M00 - 01/28/74\n&LABEL   JVDLEAVE                                                      +\n               &REGS=(14,12),                                          +\n               &RC=,                                                   +\n               &DSA=\n.*\n         LCLC  &L\n.*\n         AIF   ('&DSA' EQ '0').NODSA\n.*\n&LABEL   LH    0,2(13)\n         LR    1,13\n         L     13,4(13)\n.*\n         AIF   ('&RC' NE '(15)').FREE\n.*\n         LR    2,15\n.*\n.FREE    ANOP\n.*\n         FREEMAIN R,LV=(0),A=(1)\n.*\n.RCCHK   AIF   ('&RC' EQ '').NORC\n         AIF   ('&RC' NE '(15)').RTRN\n.*\n         LR    15,2\n.*\n         AGO   .RTRNN\n.RTRN    AIF   ('&RC'(1,1) NE '(').RTRNC\n.*\n         LR    15,&RC(1)\n.*\n.RTRNN   ANOP\n.*\n&L       RETURN &REGS,RC=(15)\n         SPACE\n.*\n         MEXIT\n.RTRNC   ANOP\n.*\n&L       RETURN &REGS,RC=&RC\n         SPACE\n.*\n         MEXIT\n.NORC    ANOP\n.*\n&L       RETURN &REGS\n         SPACE\n.*\n         MEXIT\n.NODSA   ANOP\n&L       SETC  '&LABEL'\n         AGO   .RCCHK\n.*\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "KEYT": {"ttr": 3086, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'(\\x00\\x00\\x00\\x00\\x82\\x04?\\x00\\x82\\x04?\\tA\\x01A\\x01A\\x00\\x00\\xc2\\xc1\\xe2\\xc5@@@@@@'", "ispf": {"version": "40.00", "flags": 0, "createdate": "1982-02-12T00:00:00", "modifydate": "1982-02-12T09:41:00", "lines": 321, "newlines": 321, "modlines": 0, "user": "BASE"}, "text": "         MACRO\n&NAME    KEYT  &KEYWORD,&RTN,&AREA,&TYPE,&VALCNT,&FIELD1=,&FIELD2=,    X\n               &FIELD3=,&FIELD4=,&FIELD5=,&FIELD6=,&FIELD7=,           X\n               &FIELD8=,&FIELD9=,&FIELD10=,&FIELD11=,&FIELD12=,        X\n               &FIELD13,&FIELD14=,&FIELD15=,&END=,                     X\n               &LEN=\n         LCLA  &KVVN,&CNTR1,&KVLL,&CNTR2\n         LCLC  &P1,&P2,&P3,&P4,&LEN1,&LEN2\n         AIF   ('&SYSLIST(1)' NE '').KVRM020 ONLY REQUIRED KEYWORD\n         MNOTE 8,'1ST PARM MISSING AND IS REQUIRED'\n         MEXIT\n.KVRM020 ANOP\n&KVLL    SETA  K'&SYSLIST(1)-1     SET KEYWORD LENGTH-1\n&NAME    DC    AL1(&KVLL)          KEY LENGTH-1\n         AIF   ('&SYSLIST(2)' NE '').KVRM030 IS EXIT RTN SPECIFIED\n         DC    SL2(0)              EXIT RTN NOT SPECIFIED\n         DC    SL2(0)              EXIT PARM NOT SPECIFIED\n         AGO   .KVRM049\n.KVRM030 ANOP\n         DC    SL2(&SYSLIST(2,1))  EXIT ROUTINE ADDR\n         AIF   (N'&SYSLIST(2) NE 1).KVRM046\n         DC    SL2(0)              NO RTN PARM INFO REQUESTED\n         AGO   .KVRM049\n.KVRM046 ANOP\n         DC    SL2(&SYSLIST(2,2))  EXIT RTN PARM SPECIFIED\n.KVRM049 ANOP\n         AIF   ('&SYSLIST(3)' NE '').KVRM050\n         DC    SL2(0)              NO AREA SPECIFIED\n         AGO   .KVRM060\n.KVRM050 ANOP\n         DC    SL2(&AREA)          AREA ADDR SPECIFIED\n.KVRM060 ANOP\n         AIF   ('&LEN' NE '').KVRM070\n         DC    AL1(0)              VALUE LENGTH LOW DEFAULT\n         DC    AL1(0)              VALUE LENGTH HIGH DEFAULT\n         AGO   .KVRM078\n.KVRM070 ANOP\n&LEN1    SETC  '&LEN(1)'\n&LEN2    SETC  '&LEN(2)'\n         AIF   ('&LEN1' NE '').KVRM074\n         DC    AL1(1)              VALUE LENGTH LOW IMPLIED\n         AGO   .KVRM077\n.KVRM074 ANOP\n         DC    AL1(&LEN1)          VALUE LENGTH LOW SPECIFIED\n.KVRM076 ANOP\n         AIF   ('&LEN2' NE '').KVRM077\n         DC    AL1(&LEN1)          VALUE LENGTH HIGH SPECIFIED\n         AGO   .KVRM078\n.KVRM077 ANOP\n         DC    AL1(&LEN2)          VALUE LENGTH HIGH SPECIFIED\n.KVRM078 ANOP\n         AIF   (N'&SYSLIST(5) NE 0).KVRM090 VALUE COUNT SPECIFIED\n         DC    AL1(1)              VALUE COUNT LOW DEFAULT\n         DC    AL1(1)              VALUE COUNT HIGH DEFAULT\n         AGO   .KVRM110\n.KVRM090 ANOP\n         AIF   (N'&SYSLIST(5) NE 1).KVRM094\n         AIF   ('&SYSLIST(5,1)' EQ '(').KVRM094\n         DC    AL1(0)              VALUE COUNT LOW IMPLIED\n         DC    AL1(&VALCNT)        VALUE COUNT HIGH SPECIFIED\n         AGO   .KVRM110\n.KVRM094 ANOP\n         AIF   ('&SYSLIST(5,1)' EQ ')').KVRM096\n         DC    AL1(&SYSLIST(5,1))  VALUE COUNT LOW\n         DC    AL1(&SYSLIST(5,2))  VALUE COUNT HIGH\n         AGO   .KVRM110\n.KVRM096 ANOP\n         DC    AL1(&SYSLIST(5,1))  VALUE COUNT HIGH\n.KVRM110 ANOP\n         AIF   ('&SYSLIST(4)' NE '').KVRM120\n         DC    X'00'               NO VALUE VALIDATION REQUESTED\n         AGO   .KVRM160\n.KVRM120 ANOP\n         AIF   ('&SYSLIST(4)' NE 'ALPHA').KVRM130\n         DC    X'01'               ALPHA VALIDATION REQUESTED\n         AGO   .KVRM160\n.KVRM130 ANOP\n         AIF   ('&SYSLIST(4)' NE 'NUMERIC').KVRM140\n         DC    X'02'               NUMERIC VALIDATION REQUESTED\n         AGO   .KVRM160\n.KVRM140 ANOP\n         AIF   ('&SYSLIST(4)' NE 'ALPHANUM').KVRM150\n         DC    X'03'               ALPHANUM VALIDATION REQUESTED\n         AGO   .KVRM160\n.KVRM150 ANOP\n         MNOTE 8,'INVALID VALIDATION TYPE SPECIFIED  &TYPE'\n.KVRM160 ANOP\n         AIF   ('&FIELD1' EQ '' ).KVRM166\n&KVVN    SETA  &KVVN+1\n         AIF   ('&FIELD2' EQ '' ).KVRM166\n&KVVN    SETA  &KVVN+1\n         AIF   ('&FIELD3' EQ '' ).KVRM166\n&KVVN    SETA  &KVVN+1\n         AIF   ('&FIELD4' EQ '' ).KVRM166\n&KVVN    SETA  &KVVN+1\n         AIF   ('&FIELD5' EQ '' ).KVRM166\n&KVVN    SETA  &KVVN+1\n         AIF   ('&FIELD6' EQ '' ).KVRM166\n&KVVN    SETA  &KVVN+1\n         AIF   ('&FIELD7' EQ '' ).KVRM166\n&KVVN    SETA  &KVVN+1\n         AIF   ('&FIELD8' EQ '' ).KVRM166\n&KVVN    SETA  &KVVN+1\n         AIF   ('&FIELD9' EQ '' ).KVRM166\n&KVVN    SETA  &KVVN+1\n         AIF   ('&FIELD10' EQ '' ).KVRM166\n&KVVN    SETA  &KVVN+1\n         AIF   ('&FIELD11' EQ '' ).KVRM166\n&KVVN    SETA  &KVVN+1\n         AIF   ('&FIELD12' EQ '' ).KVRM166\n&KVVN    SETA  &KVVN+1\n         AIF   ('&FIELD13' EQ '' ).KVRM166\n&KVVN    SETA  &KVVN+1\n         AIF   ('&FIELD14' EQ '' ).KVRM166\n&KVVN    SETA  &KVVN+1\n         AIF   ('&FIELD15' EQ '' ).KVRM166\n&KVVN    SETA  &KVVN+1\n.KVRM166 ANOP\n         DC    AL1(&KVVN)          COUNT OF FIELDS SPECIFIED\n         DC    C'&KEYWORD'         REQUESTED KEYWORD\n         AGO   .KVRM300\n.KVRM180 ANOP\n         AIF   ('&END' NE 'YES').KVRM190\n         DC    X'FFFF'             END OF TABLE INDICATIOR\n.KVRM190 ANOP\n         MEXIT\n.KVRM300 ANOP\n         AIF   ('&FIELD1' EQ '').KVRM180\n&CNTR1   SETA  1\n&P1      SETC  '&FIELD1(1)'\n&P2      SETC  '&FIELD1(2)'\n&P3      SETC  '&FIELD1(3)'\n&P4      SETC  '&FIELD1(4)'\n         AGO   .KVRM500\n.KVRM320 ANOP\n         AIF   ('&FIELD2' EQ '').KVRM180\n&CNTR1   SETA  2\n&P1      SETC  '&FIELD2(1)'\n&P2      SETC  '&FIELD2(2)'\n&P3      SETC  '&FIELD2(3)'\n&P4      SETC  '&FIELD2(4)'\n         AGO   .KVRM500\n.KVRM330 ANOP\n         AIF   ('&FIELD3' EQ '').KVRM180\n&CNTR1   SETA  3\n&P1      SETC  '&FIELD3(1)'\n&P2      SETC  '&FIELD3(2)'\n&P3      SETC  '&FIELD3(3)'\n&P4      SETC  '&FIELD3(4)'\n         AGO   .KVRM500\n.KVRM340 ANOP\n         AIF   ('&FIELD4' EQ '').KVRM180\n&CNTR1   SETA  4\n&P1      SETC  '&FIELD4(1)'\n&P2      SETC  '&FIELD4(2)'\n&P3      SETC  '&FIELD4(3)'\n&P4      SETC  '&FIELD4(4)'\n         AGO   .KVRM500\n.KVRM350 ANOP\n         AIF   ('&FIELD5' EQ '').KVRM180\n&CNTR1   SETA  5\n&P1      SETC  '&FIELD5(1)'\n&P2      SETC  '&FIELD5(2)'\n&P3      SETC  '&FIELD5(3)'\n&P4      SETC  '&FIELD5(4)'\n         AGO   .KVRM500\n.KVRM360 ANOP\n         AIF   ('&FIELD6' EQ '').KVRM180\n&CNTR1   SETA  6\n&P1      SETC  '&FIELD6(1)'\n&P2      SETC  '&FIELD6(2)'\n&P3      SETC  '&FIELD6(3)'\n&P4      SETC  '&FIELD6(4)'\n         AGO   .KVRM500\n.KVRM370 ANOP\n         AIF   ('&FIELD7' EQ '').KVRM180\n&CNTR1   SETA  7\n&P1      SETC  '&FIELD7(1)'\n&P2      SETC  '&FIELD7(2)'\n&P3      SETC  '&FIELD7(3)'\n&P4      SETC  '&FIELD7(4)'\n         AGO   .KVRM500\n.KVRM380 ANOP\n         AIF   ('&FIELD8' EQ '').KVRM180\n&CNTR1   SETA  8\n&P1      SETC  '&FIELD7(1)'\n&P2      SETC  '&FIELD7(2)'\n&P3      SETC  '&FIELD7(3)'\n&P4      SETC  '&FIELD7(4)'\n         AGO   .KVRM500\n.KVRM390 ANOP\n         AIF   ('&FIELD9' EQ '').KVRM180\n&CNTR1   SETA  9\n&P1      SETC  '&FIELD7(1)'\n&P2      SETC  '&FIELD7(2)'\n&P3      SETC  '&FIELD7(3)'\n&P4      SETC  '&FIELD7(4)'\n         AGO   .KVRM500\n.KVRM3A0 ANOP\n         AIF   ('&FIELD10' EQ '').KVRM180\n&CNTR1   SETA  10\n&P1      SETC  '&FIELD7(1)'\n&P2      SETC  '&FIELD7(2)'\n&P3      SETC  '&FIELD7(3)'\n&P4      SETC  '&FIELD7(4)'\n         AGO   .KVRM500\n.KVRM3B0 ANOP\n         AIF   ('&FIELD11' EQ '').KVRM180\n&CNTR1   SETA  11\n&P1      SETC  '&FIELD7(1)'\n&P2      SETC  '&FIELD7(2)'\n&P3      SETC  '&FIELD7(3)'\n&P4      SETC  '&FIELD7(4)'\n         AGO   .KVRM500\n.KVRM3C0 ANOP\n         AIF   ('&FIELD12' EQ '').KVRM180\n&CNTR1   SETA  12\n&P1      SETC  '&FIELD7(1)'\n&P2      SETC  '&FIELD7(2)'\n&P3      SETC  '&FIELD7(3)'\n&P4      SETC  '&FIELD7(4)'\n         AGO   .KVRM500\n.KVRM3D0 ANOP\n         AIF   ('&FIELD13' EQ '').KVRM180\n&CNTR1   SETA  13\n&P1      SETC  '&FIELD7(1)'\n&P2      SETC  '&FIELD7(2)'\n&P3      SETC  '&FIELD7(3)'\n&P4      SETC  '&FIELD7(4)'\n         AGO   .KVRM500\n.KVRM3E0 ANOP\n         AIF   ('&FIELD14' EQ '').KVRM180\n&CNTR1   SETA  14\n&P1      SETC  '&FIELD7(1)'\n&P2      SETC  '&FIELD7(2)'\n&P3      SETC  '&FIELD7(3)'\n&P4      SETC  '&FIELD7(4)'\n         AGO   .KVRM500\n.KVRM3F0 ANOP\n         AIF   ('&FIELD15' EQ '').KVRM180\n&CNTR1   SETA  15\n&P1      SETC  '&FIELD7(1)'\n&P2      SETC  '&FIELD7(2)'\n&P3      SETC  '&FIELD7(3)'\n&P4      SETC  '&FIELD7(4)'\n         AGO   .KVRM500\n.KVRM500 ANOP\n         AIF   ('&P1' NE '').KVRM720\n         DC    X'00'               NO VALUE IS SPECIFIED\n         AGO   .KVRM730\n.KVRM720 ANOP\n&CNTR2   SETA  K'&P1\n         DC    AL1(&CNTR2)         LENGTH OF VALUE SPECIFIED\n.KVRM730 ANOP\n         AIF   ('&P2' EQ '').KVRM900\n         AIF   ('&P2' NE 'N').KVRM750\n         DC    X'01'               N  OP CODE\n         AGO   .KVRM800\n.KVRM750 ANOP\n         AIF   ('&P2' NE 'O').KVRM760\n         DC    X'02'               O  OP CODE\n         AGO   .KVRM800\n.KVRM760 ANOP\n         AIF   ('&P2' NE 'M').KVRM770\n         DC    X'03'               M  OP CODE\n         AGO   .KVRM800\n.KVRM770 ANOP\n         AIF   ('&P2' NE 'X').KVRM780\n         DC    X'04'               X OP CODE\n         AGO   .KVRM800\n.KVRM780 ANOP\n         MNOTE 8,'INVALID OP SPECIFIED IN FIELDN='\n         MEXIT\n.KVRM800 ANOP\n         AIF   ('&P3' NE '').KVRM820\n         MNOTE 8,'TO ADDR REQ AND NOT SPECIFIED IN FIELDN='\n         MEXIT\n.KVRM820 ANOP\n         DC    SL2(&P3)            TO ADDRESS\n         AIF   ('&P4' NE '').KVRM830\n         MNOTE 8,'FROM ADDR REQ AND NOT SPECIFIED IN FIELDN='\n         MEXIT\n.KVRM830 ANOP\n         DC    SL2(&P4)            FROM ADDRESS\n         DC    AL2(L'&P3)          LENGTH OF TO ADDRESS\n.KVRM834 ANOP\n         AIF   ('&P1' NE '').KVRM840\n         AGO   .KVRM950\n.KVRM840 ANOP\n         DC    C'&P1'              VALUE CONSTANT\n         AGO   .KVRM950\n.KVRM900 ANOP\n         AIF   ('&P3' EQ '').KVRM920\n         MNOTE 8,'MISSING PARMS IN FIELDN= PARAMETER'\n         MEXIT\n.KVRM920 ANOP\n         AIF   ('&P4' EQ '').KVRM930\n         MNOTE 8,'MISSING PARMS IN FIELDN= PARAMETER'\n         MEXIT\n.KVRM930 ANOP\n         DC    X'00'               NO OP CODE\n         DC    SL2(0)              NO TO ADDR\n         DC    SL2(0)              NO FROM ADDR\n         DC    SL2(0)              NO TO LENGTH\n.KVRM950 ANOP\n         AIF   (&CNTR1 EQ 1).KVRM320\n         AIF   (&CNTR1 EQ 2).KVRM330\n         AIF   (&CNTR1 EQ 3).KVRM340\n         AIF   (&CNTR1 EQ 4).KVRM350\n         AIF   (&CNTR1 EQ 5).KVRM360\n         AIF   (&CNTR1 EQ 6).KVRM370\n         AIF   (&CNTR1 EQ 7).KVRM380\n         AIF   (&CNTR1 EQ 8).KVRM390\n         AIF   (&CNTR1 EQ 9).KVRM3A0\n         AIF   (&CNTR1 EQ 10).KVRM3B0\n         AIF   (&CNTR1 EQ 11).KVRM3C0\n         AIF   (&CNTR1 EQ 12).KVRM3D0\n         AIF   (&CNTR1 EQ 13).KVRM3E0\n         AIF   (&CNTR1 EQ 14).KVRM3F0\n         AIF   (&CNTR1 EQ 15).KVRM180\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "KEYVAL": {"ttr": 3334, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00\\x00\\x00\\x88$?\\x00\\x88$O\\x05\\x10\\x03I\\x03\\x01\\x00I\\xe2\\xc1\\xd3\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "1988-08-30T00:00:00", "modifydate": "1988-08-31T05:10:00", "lines": 841, "newlines": 769, "modlines": 73, "user": "SALBERT"}, "text": "         MACRO\n&NAME    KEYVAL &STRING,&TABLE,&PRINT=OFF,&TYPE=PAREN\n         GBLC  &KVRCSEC            CSECT NAME\n         LCLC  &CSNAME             OUTER CSECT NAME\n         LCLB  &KVRCSON            LOCAL SWITCH FOR CSECT GENERATION\n         LCLB  &EQ                  INDICATE = SUPPORT             8/30\n.**********************************************************************\n.***                                                                ***\n.***  MACRO  NAME: KEYWORD VALIDATION ROUTINE                       ***\n.***                                                                ***\n.***                                                                ***\n.***  GENERAL FUNCTION: TO VALIDATE A CHARACTER STRING CONTAINING   ***\n.***                    KEYWORDS AND VALUES AND PERFORM REQUESTED   ***\n.***                    OPERATIONS AS SPECIFIED IN THE KEYWORD      ***\n.***                    VALIDATION TABLE DEFINED WITH ONE OR MORE   ***\n.***                    KEYT MACROS.  THIS MACRO EXPANDS TO AN      ***\n.***                    INDEPENDENT CSECT UPON INITIAL INVOCATION   ***\n.***                    AND IS ACCESSED VIA V-TYPE ADDRESSING       ***\n.***                    FOR SUBSEQUENT INVOCATIONS.  THERE ARE 2    ***\n.***                    BASIC PARTS TO THIS MACRO.  THE FIRST PART  ***\n.***                    SETS UP THE APPROPRIATE PARMS BASED UPON    ***\n.***                    THE USER PARAMETERS SUPPLIED.  THE SECOND   ***\n.***                    PART DOES THE STRING MANIPULATION, PERFORMS ***\n.***                    THE REQUESTED FUNCTIONS AND SETS RETURN     ***\n.***                    CODES.                                      ***\n.***                                                                ***\n.***                                                                ***\n.***  ENTRY REGS:   R1                                              ***\n.***  (PART 1)      R2                                              ***\n.***                R3                                              ***\n.***                R4                                              ***\n.***                R5                                              ***\n.***                R6                                              ***\n.***                R7                                              ***\n.***                R8                                              ***\n.***                R9                                              ***\n.***                R10                                             ***\n.***                R11                                             ***\n.***                R12                                             ***\n.***                R13  SAVE AREA                                  ***\n.***                R14                                             ***\n.***                R15                                             ***\n.***                                                                ***\n.***                                                                ***\n.***  ENTRY REGS:   R0   AL4  ADDR OF CHAR STRING                   ***\n.***  (PART 2)      R1   AL4  ADDRESS OF 1ST KEYT ENTRY             ***\n.***                R2                                              ***\n.***                R3                                              ***\n.***                R4                                              ***\n.***                R5                                              ***\n.***                R6                                              ***\n.***                R7                                              ***\n.***                R8                                              ***\n.***                R9                                              ***\n.***                R10                                             ***\n.***                R11                                             ***\n.***                R12                                             ***\n.***                R13  SAVE AREA                                  ***\n.***                R14  RETURN ADDRESS                             ***\n.***                R15  ENTRY ADDRESS                              ***\n.***                                                                ***\n.***  REGISTER USAGE:  R0   WORK                                    ***\n.***                   R1   WORK                                    ***\n.***                   R2   WORK                                    ***\n.***                   R3   CHAR STRING LENGTH                      ***\n.***                   R4   CHAR STRING ADDRESS                     ***\n.***                   R5   WORK                                    ***\n.***                   R6   WORK                                    ***\n.***                   R7   WORK                                    ***\n.***                   R8   WORK                                    ***\n.***                   R9   SAVED RETURN CODE                       ***\n.***                   R10  WORK                                    ***\n.***                   R11  PROGRAM BASE                            ***\n.***                   R12  WORKAREA BASE                           ***\n.***                   R13  OLD SAVEAREA                            ***\n.***                   R14  KEYWORD TABLE BASE                      ***\n.***                   R15  RETURN CODE                             ***\n.***                                                                ***\n.***                                                                ***\n.***                                                                ***\n.***                                                                ***\n.***  AUTHOR: E STEWART                DATE: 05/29/80               ***\n.***                                                                ***\n.***                                                                ***\n.***  ATTRIBUTES: RENT,REUS,REFR                                    ***\n.***                                                                ***\n.***                                                                ***\n.***  CALLED BY: UTILITY FUNCTION                                   ***\n.***                                                                ***\n.***                                                                ***\n.***  MACROS USED: GETMAIN,FREEMAIN                                 ***\n.***                                                                ***\n.***                                                                ***\n.***  ROUTINES CALLED: NONE                                         ***\n.***                                                                ***\n.***                                                                ***\n.***  NORMAL EXIT: BR R14                                           ***\n.***                                                                ***\n.***  EXIT REGS:     R0   AL4  ADDR OF KEYWORD IN CHAR STRING WHERE ***\n.***                           VALIDATION ERROR OCCURED             ***\n.***                 R1   AL4  ADDR OF VALUE IN CHAR STRING WHERE   ***\n.***                           VALIDATION ERROR OCCURED             ***\n.***                 R15       00  KEYWORD(S)VALUE(S) FOUND AND     ***\n.***                               OP(S) PERFORMED                  ***\n.***                           04  KEYWORD(S) FOUND, SOME VALUE NOT ***\n.***                               FOUND IN KEYT                    ***\n.***                           08  A KEYWORD WAS NOT FOUND IN KEYT  ***\n.***                           12  'VALCNT' DID NOT PASS VALIDATION ***\n.***                           16  MORE INPUT EXPECTED, I.E. ONLY   ***\n.***                               BLANKS, COMMENTS, OR ),BLANK WAS ***\n.***                               FOUND. OTHERWISE RC=00 WOULD HAVE***\n.***                               BEEN RETURNED.                   ***\n.***                           20  'TYPE' DID NOT PASS VALIDATION.  ***\n.***                           24  'LEN' DID NOT PASS VALIDATION.   ***\n.***                                                                ***\n.***                                                                ***\n.***  ABEND CODES: NONE (I HOPE)                                    ***\n.***                                                                ***\n.***                                                                ***\n.***  MESSAGES ISSUED: NONE                                         ***\n.***                                                                ***\n.***                                                                ***\n.***                                                                ***\n.***                                                                ***\n.***  DSECTS/MACROS USED: NONE FROM AN EXTERNAL SOURCE              ***\n.***                                                                ***\n.***                                                                ***\n.***  SPECIAL NOTES:                                                ***\n.***                                                                ***\n.***                                                                ***\n.***  MODIFIED:                                                     ***\n.***           08/30/88   GLA  SUPPORT KEYWORD FORMAT OF            ***\n.***                            KEYWORD=VALUE                       ***\n.***           08/31/88   GLA  ORIGINAL CODE BUG ON VALIDATING      ***\n.***                            NULL VALUES                         ***\n.***                                                                ***\n.**********************************************************************\n         AIF   ('&KVRCSEC' NE '').KVRBALR CSECT ALREADY ASSIGNED\n&KVRCSEC SETC  'KVR'.'&SYSNDX'   SET CSECT NAME\n&KVRCSON SETB  1                   SAY CSECT ASSIGNED THIS PASS\n.KVRBALR ANOP\n         AIF   (N'&SYSLIST(1) EQ  1 AND N'&SYSLIST(2) EQ 1).KVRM010\n         MNOTE 8,'OPERAND SUBLISTS NOT PERMITTED'\n         MEXIT\n.KVRM010 ANOP\n         AIF   ('&NAME' EQ '').KVRM014\n&NAME    DS    0H                  SET LABEL NAME\n.KVRM014 ANOP\n         AIF   ('&SYSLIST(1)' EQ '(0)' OR '&SYSLIST(1)' EQ '(R0)').KVRMX\n               040           STRING AND LENGTH ALREADY OK\n         AIF   ('&SYSLIST(1)' EQ '(0)' OR '&SYSLIST(2)' EQ '(R0)').KVRMX\n               020                CHAR STRING ALREADY IN R0\n         AIF   ('&STRING'(1,1) EQ '(').KVRM016 REG NOTATION\n         LA    0,&STRING           GET ADDR OF CHAR STRING\n         AGO   .KVRM020\n.KVRM016 ANOP\n         LR    0,&STRING           GET ADDR OF CHAR STRING\n.KVRM020 ANOP\n         AGO   .KVRM040\n.KVRM040 ANOP\n         AIF   ('&SYSLIST(2)' EQ '(1)' OR '&SYSLIST(2)' EQ '(R1)').KVRMX\n               060\n         AIF   ('&TABLE'(1,1) EQ '(').KVRM050 REG NOTATION\n         LA    1,&TABLE            KEYWORD TABLE ADDRESS\n         AGO   .KVRM060\n.KVRM050 ANOP\n         LR    1,&TABLE            KEYWORD TABLE ADDRESS\n.KVRM060 ANOP\n&EQ      SETB  0                                                   8/30\n         AIF   ('&TYPE' EQ 'PAREN').NOE                            8/30\n&EQ      SETB  1                                                   8/30\n.NOE     ANOP                                                      8/30\n         L     15,=V(&KVRCSEC)     GET CSECT NAME\n         BALR  14,15               GO TO VALIDATION ROUTINE\n         DC    B'&EQ.0000000',X'00'                                8/30\n         AIF   (NOT(&KVRCSON)).NOGO TERMINATE IF ALREADY EXPANDED\n         PUSH  USING,PRINT\n         AIF   ('&PRINT' EQ 'ON').KVRM070 NO LIST\n         PRINT OFF                 TURN PRINT OFF\n         AGO   .KVRM072\n.KVRM070 ANOP\n         PRINT ON,GEN              TURN ON PRINT\n.KVRM072 ANOP\n&CSNAME  SETC  '&SYSECT'\n&KVRCSEC CSECT\n         USING *,11                SET UP BASE\n         STM   14,12,12(13)        SAVE REGS\n         LR    11,15               GET BASE ADDRESS\n         USING KVDSVR,14           TABLE ADDRESS BASE\n         USING KVWAVR,12           WORKAREA BASE\n         GETMAIN R,LV=KVWALNTH     GET WORKAREA\n         LR    12,1                PUT INTO BASE REG\n         L     4,20(13)            GET STRING ADDRESS INTO REG 4\n         SR    3,3                 CLEAR WORK REG\n         ICM   3,3,0(4)            GET STRING LENGTH\n         LA    4,2(,4)             BUMP OVER STRING LENGTH\n         L     14,12(13)            GET OPTIONS ADDRESS            8/30\n         MVC   KVWAOPTS,0(14)       MOVE IN OPTIONS                8/30\n         LA    14,2(,14)            RESET RETURN ADDRESS           8/30\n         ST    14,12(13)            RESAVE ADDRESS                 8/30\n         MVI   KVWAFL1,0           CLEAR FLAG BYTE\n         MVI   KVWAKWVA,0          CLEAR COUNT BYTE\n         MVC   KVWASAV1(4*13),20(13) SAVE REGS 0-12\n         MVC   KVWASAV1+(4*14)(4*2),12(13) SAVE REGS 14-15\n         ST    13,KVWASAV1+(4*13)  SAVE REG 13 FROM CALLER\nKVR004   DS    0H\n         L     14,24(13)           TABLE ADDRESS\n         XC    0(KVWACLR,12),0(12)   CLEAR WORKAREA\n         LTR   3,3                 Q. ANY DATA TO SCAN\n         BP    KVR005              A. YES, CONTINUE AS NORMAL\n         LA    9,16                SET BAD RC\n         B     KVR900              AND RETURN\nKVR005   DS    0H\n         SR    2,2                 CLEAR FOR LATER\n         ST    4,KVWALOC           SAVE STRING LOC\n         ST    4,KVWAKEY           SAVE STRING LOC\n         LR    15,3                GET LENGTH FOR TRT               GLA\n         CH    15,KVH256           SEE IF TOO BIG FOR TRT           GLA\n         BL    *+8                 NO SO USE AS IS                  GLA\n         LH    15,KVH256           SET TO MAXIMUM                   GLA\n         BCTR  15,0                GET MACHINE LENGTH               GLA\n         EX    15,KVTR1VR          SEARCH FOR NON-BLANK             GLA\n         BNZ   KVR006              OUT IF FOUND                     GLA\n         LA    15,1(,15)           GET REAL LENGTH BACK             GLA\n         AR    4,15                POINT TO NEXT STRING LOC         GLA\n         SR    3,15                DECREMENT LENGTH                 GLA\n         BP    KVR005              IF MORE LEFT THEN REPROCESS      GLA\n         LA    9,16                SET BLANKS RETURN CODE\n         B     KVR900              RETURN TO CALLER\nKVR006   DS    0H\n         LR    5,1                 SAVE REG 1\n         SR    1,4                 GET NEW\n         SR    3,1                 DATA LENGTH\n         LR    4,5                 GET NEW LOCATION\n         CLM   2,1,KVASLASH        Q. COULD THIS BE COMMENT\n         BNE   KVR020              A. NO, CONTINUE\n         CLI   1(4),C'*'           Q .WAS THIS A COMMENT\n         BE    KVR008              A. YES, CONTINUE\n         LA    9,8                 SAY INVALID KEYWORD\n         B     KVR900              AND RETURN\nKVR008   DS    0H                  VALIDATE COMMENT\n         LA    4,2(4)              BUMP OVER /*\n         BCTR  3,0                 REDUCE COUNT\n         BCTR  3,0                 REDUCE COUNT\nKVR010   DS    0H\n         CLI   0(4),C'*'           Q. IS IT REALLY A COMMENT\n         BE    KVR014              A. YES, CONTINUE\nKVR012   DS    0H\n         LA    4,1(4)              BUMP ADDRESS\n         BCT   3,KVR010            LOOP THROUGH\n         LA    9,8                 SET RETURN CODE\n         B     KVR900              AND RETURN\nKVR014   DS 0H\n         CLI   1(4),C'/'           Q. IS 2ND CHAR A SLASH\n         BNE   KVR012              A. NO, CONTINUE SCAN FOR END\n         LA    4,2(4)              BUMP OVER */\n         BCTR  3,0                 REDUCE COUNT\n         BCTR  3,0                 REDUCE COUNT\n         B     KVR005              AND CONTINUE SCAN\nKVR020   DS    0H                  VALIDATE CHARACTERS FOUND\n         ST    4,KVWALOC           SAVE STRING ADDR\n         ST    4,KVWAKEY           SAVE STRING ADDR\n         SR    5,5                 CLEAR FOR KEYWORD COMPARE\n         SR    6,6                 CLEAR FOR KEYWORD COMPARE\n         SR    7,7                 CLEAR FOR KEYWORD COMPARE\nKVR022   DS    0H\n         IC    5,KVLL0001          GET KEYWORD LEN\n         EX    5,KVCVR             Q. KEYWORD FOUND\n         BE    KVR080              A. YES,CONTINUE\nKVR023   DS    0H\n         IC    6,KVVN0001          GET COUNT OF VALUE ENTRIES\n         LA    14,0(14,5)          BUMP OVER VARIABLE KEYWORD\n         LTR   6,6                 Q. ANY MORE VALUES TO DO\n         BZ    KVR028              A. NO, CONTINUE AS IS\nKVR024   DS    0H\n         IC    7,KVVL0001          LENGTH OF VALUE KEYWORD\n         LA    14,KVVG0001(7,14)   BUMP OVER VALUE ENTRY\n         BCT   6,KVR024            CONTINUE THRU ALL VALUES\nKVR028   DS    0H\n         LA    14,KVKL0001+1(14)   BUMP OVER KEYWORD ENTRY\n         CLC   KVAFFFF,KVDSVR      Q. LAST ENTRY\n         BNE   KVR022              A. NO, CONTINUE SCAN\n         LA    9,8                 SET RETURN CODE\n         B     KVR900              AND RETURN\nKVR080   DS    0H                  KEYWORD FOUND\n         LA    6,1(5,4)            GO TO NEXT BYTE BEYOND KEYWORD\n         TM    KVWAOPT1,KVWAOEQ     Q. TYPE=EQUAL                  8/30\n         BO    KVWEQ1               A. YES                         8/30\n         CLI   0(6),C'('           Q. IS THIS DELIMITER\n         BE    KVR082              A. YES, CONTINUE\n         B     KVWNEQ1                                             8/30\nKVWEQ1   DS    0H                                                  8/30\n         CLI   0(6),C'='            Q. IS THIS DELEIMITER          8/30\n         BE    KVR082               A. YES, CONTINUE               8/30\nKVWNEQ1  DS    0H                                                  8/30\n         CLI   0(6),C' '           Q. IS THIS DELIMITER\n         BE    KVR082              A. YES, CONTINUE\n         CLI   0(6),C','           Q. IS THIS DELIMITER\n         BE    KVR082              A. YES, CONTINUE\n         LR    9,3                 CURRENT LENGTH\n         SR    9,5                 MINUS KEYWORD EX LENGTH\n         BCTR  9,0                 MINUS ONE\n         LTR   9,9                 Q. ANY DATA LEFT IN STRING\n         BZ    KVR082              A. NO, JUST CONTINUE NORMALLY\n         SR    6,6                 CLEAR FOR LATER\n         B     KVR023              ELSE LOOK FOR ANOTHER KEYWORD\nKVR082   DS    0H\n         SR    6,6                 CLEAR WORK REG\n         ICM   6,3,KVRA0001        GET EXIT ROUTINE ADDR\n         BZ    KVR084              BRANCH IF NOT SPECIFIED\n         SRDL  6,12                GET REG INTO R6\n         SLL   6,2                 X 4\n         LA    1,KVWASAV1          ADDR OF SAVE AREA\n         L     6,0(6,1)            GET CONTENTS OF RTN BASE REG\n         SRL   7,20                SHIFT TO LOWER END\n         LA    7,0(7,6)            GET ROUTINE ADDRESS\n         ST    7,KVWARTN           SAVE RTN ADDRESS\nKVR084   DS    0H\n         SR    6,6                 CLEAR WORK REG\n         ICM   6,3,KVRP0001        GET EXIT ROUTINE PARM\n         BZ    KVR088              BRANCH IF NOT SPECIFIED\n         SRDL  6,12                GET REG INTO R6\n         SLL   6,2                 X 4\n         LA    1,KVWASAV1          ADDR OF SAVE AREA\n         L     6,0(6,1)            GET CONTENTS OF PARM BASE REG\n         SRL   7,20                SHIFT TO LOWER END\n         LA    7,0(7,6)            GET PARM ADDRESS\n         ST    7,KVWAPRM           SAVE PARM ADDRESS\nKVR088   DS    0H\n         LA    4,1(5,4)            GO TO NEXT BYTE BEYOND KEYWORD\n         SR    3,5                 REDUCE STRING COUNT\n         BCTR  3,0                 REDUCE STRING COUNT\n         TM    KVWAOPT1,KVWAOEQ     Q. TYPE=EQUAL                  8/30\n         BO    KVWEQ2               A. YES                         8/30\n         CLI   0(4),C'('           Q. VALUE(S) SPECIFIED\n         BE    KVR110              A. YES, CONTINUE\n         B     KVWNEQ2                                             8/30\nKVWEQ2   DS    0H                                                  8/30\n         LTR   3,3                  Q. ANY INPUT LEFT              8/30\n         BNP   KVR089               A. NO, SO NO VALUE             8/30\n         CLI   0(4),C'='            Q. VALUE SPECIFIED             8/30\n         BE    KVR110               A. YES, CONTINUE               8/30\nKVR089   DS    0H                                                  8/30\nKVWNEQ2  DS    0H                                                  8/30\n         CLI   KVVN0001,0          Q. ANY VALUES REQUIRED\n         BNE   KVR090              A. NO, JUST RETURN\n         SR    9,9                 SET ZERO RETURN CODE\n         B     KVR900              AND RETURN\nKVR090   DS    0H\n         MVI   KVWAKWVA,0          CLEAR COUNT\n         B     KVR172              GO PROCESS THIS KEYWORD\nKVR110   DS    0H                  MOVE ALL VALUES TO LOCAL STORAGE\n         SR    1,1                 CLEAR FOR LATER\n         MVI   KVWAKWVA,0          CLEAR COUNT\n         BCTR  3,0                 REDUCE COUNT\n         LA    4,1(4)              BUMP TO NEXT BYTE\n         LR    5,4                  POINT AT START OF VALUE IF ANY 8/31\n         ST    5,KVWALOC            SAVE POINTER                   8/31\n         TM    KVWAOPT1,KVWAOEQ     Q. TYPE=EQUAL                  8/30\n         BO    KVWEQ3               A. YES                         8/30\n         CLI   0(4),C')'           Q. NULL KEYWORDS\n         BNE   KVR120              A. NO, CONTINUE NORMALLY\n         B     KVWNEQ3                                             8/30\nKVWEQ3   DS    0H                                                  8/30\n         LTR   3,3                  Q. ANY INPUT YES               8/30\n         BNP   KVR140               A. YES, PROCESS NULL ENTRY     8/30\n         CLI   0(4),C','            Q. NULL KEYWORDS               8/30\n         BE    KVR140               A. YES, PROCESS NULL ENTRY     8/30\n         CLI   0(4),C' '            Q. NULL KEYWORDS               8/30\n         BNE   KVR120               A. NO, CONTINUE NORMALLY       8/30\nKVWNEQ3  DS    0H                                                  8/30\n         B     KVR140              GO PROCESS NULL ENTRY\nKVR120   DS    0H\n         SR    1,1                 CLEAR FOR LATER\n         CLI   0(4),C''''          Q. QUOTED STRING FOR THIS VALUE\n         BNE   KVR124              A. NO, DONT SET FLAG\n         MVI   KVWAQUO,1           SAY IN QUOTE MODE\n         LA    4,1(,4)             BUMP OVER QUOTE\n         BCTR  3,0                 REDUCE STRING COUNT\nKVR124   DS    0H\n         LA    2,KVWATMP           ADDR OF TEMP WORK AREA\n         LR    5,4                 SAVE OLD VALUES LOCATION\n         ST    5,KVWALOC           SAVE STRING ADDR\nKVR130   DS    0H\n         TM    KVWAOPT1,KVWAOEQ     Q. TYPE=EQUAL                  8/30\n         BO    KVWEQ4               A. YES                         8/30\n         CLI   0(4),C','           Q. COMMA DELIMITER\n         BE    KVR140              A. YES, SAVE THIS KEYWORD\n         CLI   0(4),C')'           Q. TERMINATING DELIMITER\n         BE    KVR140              A. YES, PROCESS END KEYWORD VALUES\n         B     KVWNEQ4                                             8/30\nKVWEQ4   DS    0H                                                  8/30\n         LTR   3,3                  Q. ANY INPUT LEFT              8/30\n         BNP   KVR140               A. YES, PROCESS END VALUES     8/30\n         CLI   0(4),C' '            Q. TERMINATING DELIMITER       8/30\n         BE    KVR140               A. YES, PROCESS END VALUES     8/30\n         CLI   0(4),C','            Q. TERMINATING DELIMITER       8/30\n         BE    KVR140               A. YES, PROCESS END VALUES     8/30\nKVWNEQ4  DS    0H                                                  8/30\n         CLI   0(4),C''''          Q. END OF QUOTED STRING\n         BNE   KVR134              A. NO, CONTINUE\n         LA    4,1(,4)             BUMP ADDRESS\n         BCTR  3,0                 REDUCE COUNT\n         LA    1,1(,1)             ADD 1 FOR LATER STRING MOVE\n         CLI   0(4),C''''          Q. REALLY END OF STRING\n         BE    KVR134              A. NO, NOT YET JUST DOUBLE QUOTES\n         MVI   KVWAQUO,0           RESET QUOTE MODE FLAG\n         B     KVR130              AND CONTINUE\nKVR134   DS    0H\n         MVC   0(1,2),0(4)         SAVE THIS BYTE\n         LA    2,1(,2)             BUMP WORK BYTE\n         LA    15,KVWATMP+L'KVWATMP GET MAXIMUM ADDRESS             GLA\n         CR    2,15                SEE IF PAST                      GLA\n         BH    KVR136              IF SO THEN EXIT WITH ERROR       GLA\n         LA    4,1(4)              GO TO NEXT BYTE\n         BCT   3,KVR130            CONTINUE SCAN\n         TM    KVWAOPT1,KVWAOEQ     Q. TYPE=EQUAL                  8/30\n         BZ    KVWNEQ4A                                            8/30\n         CLI   KVWAQUO,0           Q. ARE WE IN QUOTE MODE         8/30\n         BE    KVR140              A. NO, SO OK ENDING             8/30\nKVWNEQ4A DS    0H                                                  8/30\nKVR136   LA    9,4                 SET RETURN CODE                  GLA\n         B     KVR900              AND RETURN\nKVR140   DS    0H                  PROCESS FOUND VALUE\n         CLI   KVWAQUO,0           Q. ARE WE IN QUOTE MODE\n         BNE   KVR134              A. YES, IGNORE OTHER DELIMITERS\n         LR    6,4                 SAVE NEW ADDR\n         SR    6,5                 GET VALUE LENGTH\n         SR    6,1                 SUBTRACT ANY QUOTED STRING BYTES\n         SR    5,5                 CLEAR WORK REG\n         ICM   5,1,KVWAKWVA        GET WORK AREA COUNT\n         BNZ   KVR146              BRANCH IF ALREADY SOME IN THERE\n         LA    8,KVWAKWVA+1        GET NEXT LOC ADDRESS\n         B     KVR148              AND CONTINUE\nKVR146   DS    0H                  LOOK FOR VALUES END LOCATION\n         LA    8,KVWAKWVA+1        GET START ADDRESS\n         SR    7,7                 CLEAR WORK REG\n         ICM   7,1,KVWAKWVA+1      GET LENGTH OF LAST ONE\nKVR147   DS    0H\n         LA    8,1(7,8)            GO TO NEXT SLOT\n         ICM   7,1,0(8)            GET NEXT LENGTH\n         BCT   5,KVR147            LOOP THRU\nKVR148   DS    0H                  MOVE NEW VALUE IN NOW\n         LTR   6,6                 Q. NULL VALUE SPECIFIED\n         BNZ   KVR150              A. NO, CONTINUE MVC\n         STC   6,0(8)              SAVE NULL VALUE LENGTH\n         B     KVR160              AND UPDATE VALUES COUNT\nKVR150   DS    0H                  MOVE NEW VALUES INTO WORKAREA\n         L     5,KVWALOC           RESTORE STRING ADDR\n         STC   6,0(8)              SAVE STRING LENGTH\n         BCTR  6,0                 REDUCE COUNT\n         EX    6,KVM1VR            PERFORM THE MOVE\n         TM    KVVT0001,X'FF'      Q. ANY VALIDATION REQUIRED\n         BZ    KVR160              A. NO, JUST CONTINUE\n         SR    2,2                 CLEAR WORK REG\n         ICM   2,1,KVVT0001        GET VALIDATION CODE\n         SLL   2,2                 X 4\n         B     *+0(2)              GO TO VALIDATE IT\n         B     KVR154              ALPHA\n         B     KVR156              NUMERIC\n         B     KVR158              ALPH/NUMERIC\nKVR154   DS    0H                  ALPHA VALIDATION\n         EX    6,KVTR2VR           A. ALPHA FIELD\n         BZ    KVR160              A. YES, CONTINUE\nKVR155   DS    0H                  ERROR RETURN\n         LA    9,20                SET RC\n         B     KVR900              AND RETURN\nKVR156   DS    0H                  NUMERIC\n         EX    6,KVTR3VR           Q. NUMERIC FIELD\n         BZ    KVR160              A. YES, CONTINUE\n         B     KVR155              ELSE SET BAD RC\nKVR158   DS    0H                  ALPHA/NUMERIC\n         EX    6,KVTR4VR           Q. ALPHA/NUMERIC\n         BZ    KVR160              A. YES, CONTINUE\n         B     KVR155              ELSE ERROR RETURN\nKVR160   DS    0H\n         CLI   KVVLL001,0          Q. WAS VALUE LEN VALIDATION REQUSTED\n         BE    KVR169              A. NO, BYPASS LENGTH VALIDATION\n         LA    6,1(,6)             RESTORE FULL LENGTH\n         CLM   6,1,KVVLL001        Q. WAS LOW VALUE PRECEEDED\n         BL    KVR168              A. YES, ERROR CONDITION\n         CLM   6,1,KVVLH001        Q. WAS HIGH VALUE EXCEEDED\n         BH    KVR168              A. YES, ERROR CONDITION\n         B     KVR169              VALUE LENGTH PASSED VALIDATION\nKVR168   DS    0H\n         LA    9,24                SET VALUE ERROR\n         B     KVR900              AND RETURN\nKVR169   DS    0H\n         IC    7,KVWAKWVA          GET CURRENT COUNT\n         LA    7,1(,7)             ADD ONE\n         STC   7,KVWAKWVA          AND SAVE THE COUNT\n         TM    KVWAOPT1,KVWAOEQ     Q. TYPE=EQUAL                  8/30\n         BO    KVWEQ5               A. YES                         8/30\n         CLI   0(4),C')'           Q. WAS IT ENDING DELIMETER\n         BE    KVR170              A. YES, TERMINATE SCAN\n         B     KVWNEQ5                                             8/30\nKVWEQ5   DS    0H                                                  8/30\n         LTR   3,3                  Q. ANY INPUT LEFT              8/30\n         BNP   KVR170               A. NO,  TERMINATE SCAN         8/30\n         CLI   0(4),C' '            Q. TERMINATING DELIMITER       8/30\n         BE    KVR170               A. YES, TERMINATE SCAN         8/30\n         CLI   0(4),C','            Q. TERMINATING DELIMITER       8/30\n         BE    KVR170               A. YES, TERMINATE SCAN         8/30\nKVWNEQ5  DS    0H                                                  8/30\n         LA    4,1(,4)             BUMP OVER COMMA\n         BCTR  3,0                 REDUCE STRING LENGTH\n         B     KVR120              CONTINUE FOR MORE KEYWORDS\nKVR170   DS    0H                  PROCESS ENDING DELIMITER\n         LA    4,1(,4)             BUMP OVER )\n         BCTR  3,0                 REDUCE COUNT\nKVR172   DS    0H                  PROCESS ENDING DELIMITER\n         SR    5,5                 CLEAR WORK REG\n         SR    6,6                 CLEAR WORK REG\n         ICM   5,1,KVHV0001        GET VALUE(S) COUNT HIGH NUMBER\n         BNZ   KVR180              GO HERE IF NOT ZERO COUNT\n         CLM   5,1,KVWAKWVA        Q. WAS COUNT FOUND ALSO ZERO\n         BE    KVR180              A. YES, CONTINUE WITHOUT ERROR YET\nKVR174   DS    0H\n         LA    9,12                SAY COUNT EXCEEDED\n         B     KVR900              AND RETURN\nKVR180   DS    0H\n         CLM   5,1,KVWAKWVA        Q. HIGH COUNT EXCEEDED\n         BL    KVR174              A. YES, ERROR AND GET OUT\n         ICM   5,1,KVLV0001        GET LOW VALUE(S) COUNT\n         BZ    KVR182              GET OUT IF ZERO COUNT\n         CLM   5,1,KVWAKWVA        Q. COUNT LESS THAN LOW VALUE\n         BH    KVR174              A. YES, GET OUT WITH ERROR\nKVR182   DS    0H\n         ICM   5,3,KVAA0001        Q. IS THERE AN AREA PROVIDED\n         BZ    KVR200              A. NO, JUST CONTINUE\n         SR    6,6                 CLEAR WORK REG\n         SR    7,7                 CLEAR WORK REG\n         ICM   6,3,KVAA0001        GET WORKAREA ADDRESS\n         SRDL  6,12                GET REG NO. INTO R2\n         SLL   6,2                 X 4\n         LA    1,KVWASAV1          ADDR OF SAVE AREA\n         L     6,0(6,1)            GET CONTENTS OF AREA BASE REG\n         SRL   7,20                SHIFT TO LOWER END\n         LA    6,0(7,6)            GET WORKAREA ADDRESS\n         LA    5,KVWAKWVA          GET MY AREA ADDRESS\n         SR    2,2                 CLEAR WORK REG\n         IC    2,KVWAKWVA          GET COUNT\n         MVC   0(1,6),KVWAKWVA     MOVE COUNT BYTE\n         LA    6,1(,6)             BUMP OVER COUNT BYTE\n         LA    5,1(,5)             BUMP OVER COUNT BYTE\nKVR184   DS    0H\n         MVC   0(1,6),0(5)         MOVE FIRST LENGTH BYTE\n         LTR   2,2                 WAS ANYTHING IN THE AREA\n         BNZ   KVR186              YES, CONTINUE WITH MOVE\n         MVI   KVWAKWVA,1          SAY SOMETHING WAS THERE\n         B     KVR200              AND CONTINUE\nKVR186   DS    0H\n         SR    7,7                 CLEAR FOR NEXT INSTR\n         ICM   7,1,0(5)            GET BYTE COUNT\n         BNZ   KVR188              BRANCH FOR NON ZERO MOVE\n         LA    6,1(,6)             BUMP OVER NULL BYTE\n         LA    5,1(,5)             BUMP OVER NULL BYTE\n         B     KVR194              AND CONTINUE\nKVR188   DS    0H\n         BCTR  7,0                 REDUCE BY ONE\n         EX    7,KVM2VR            MOVE DATA OVER\nKVR190   DS    0H\n         LA    6,2(7,6)            BUMP OVER OUTPUT\n         LA    5,2(7,5)            BUMP OVER INPUT\nKVR194   DS    0H\n         BCT   2,KVR184            COUNTINUE MOVE\nKVR200   DS    0H                  SEE IF VALUES TO BE COMPARED\n         SPACE\n*        AT THIS POINT THE VALUES HAVE BEEN MOVED TO MY WORKAREA\n*        AND TO THE USER WORK AREA IF AREA HAS BEEN SPECIFIED\n*        IN THE KEYT MACRO\n         SPACE\n         SR    2,2                 CLEAR WORK REG\n         ICM   2,1,KVVN0001        Q. WERE ANY VALUES TO BE VERIFIED\n*                                     OR WAS THERE WORK TO BE DONE\n         BNZ   KVR220              A. YES, CONTINUE AS USUAL\n         SR    9,9                 CLEAR RC\n         B     KVR900              AND RETURN TO CALLER\nKVR220   DS    0H\n         ST    2,KVVNCNT           SAVE COUNT\n         ST    14,KVWAR14          SAVE KEYT ADDR\n         LA    5,KVWAKWVA+1        ADDR OF FOUND VALUES\n         ST    5,KVWASV            SAVE VALUES ADDR\n         MVC   KVWASVC,KVWAKWVA    SAVE VALUES COUNT\n         SR    2,2                 CLEAR REG\n         ICM   2,1,KVWASVC         Q. ANY VALUES FOUND\n         BNZ   KVR230              A. YES, CONTINUE WITH COUNT\n         MVI   KVWASVC,1           ELSE SAY AT LEAST ONE FOUND\nKVR230   DS    0H\n         L     2,KVVNCNT           GET COUNT\n         L     14,KVWAR14          GET TABLE ADDR\n         L     5,KVWASV            GET ADDR OF CURRENT VALUE TO FIND\n         SR    1,1                 CLEAR WORK REG\n         ICM   1,1,KVWASVC         GET COUNT\n         BZ    KVR500              STOP SCAN IF NONE LEFT\n         BCTR  1,0                 REDUCE COUNT\n         STC   1,KVWASVC           SAVE NEW COUNT\n         ICM   1,1,0(5)            GET LENGTH OF CURRENT VALUE\n         LA    1,1(1,5)            BUMP TO WHERE NEW VALUE WILL BE\n         ST    1,KVWASV            AND SAVE ADDRESS\n         SR    7,7                 CLEAR FOR LATER\n         IC    7,KVLL0001          GET KEYWORD LENGTH\n         LA    14,0(14,7)          BUMP OVER VARIABLE LENGTH KEYWORD\nKVR240   DS    0H                  SCAN TABLE FOR THIS VALUE\n         ST    2,KVWAR2            SAVE CURRENT COUNT\n         ICM   7,1,KVVL0001        LENGTH OF VALUE\n         BZ    KVR300              IF NO KEYWORD VALUE HAS BEEN PUT\n*                                  IN KEYT DONT LOOK FOR A MATCH, JUST\n*                                  DO THE WORK IF ANY\n         BCTR  7,0                 REDUCE FOR EX INSTR\n         EX    7,KVC2VR            Q. ARE VALUES EQUAL\n         BE    KVR300              A. YES, GO SEE IF ANY WORK TO DO\nKVR250   DS    0H\n         L     2,KVWAR2            RELOAD LOOP COUNTER\n         SR    1,1                 CLEAR WORK REG\n         IC    1,KVVL0001          GET LENGTH OF VALUE\n         LA    14,KVVG0001(1,14)   GO TO NEXT ENTRY\n         BCT   2,KVR240            AND CONTINUE SCAN\n         CLI   KVWAVF,X'FF'        Q. WERE VALUE(S) MATCHED IN KEYT\n         BE    KVR260              A. YES, CONTINUE WITH NO ERRORS\n         LA    9,4                 VALUE NOT FOUND RC\n         B     KVR900              AND RETURN\nKVR260   DS    0H\n         MVI   KVWAVF,0            RESET VALUES FOUND FLAG\n         B     KVR230              AND CONTINUE WITH OTHER VALUES\nKVR300   DS    0H                  VALUE FOUND SEE IF ANY WORK TO DO\n         MVI   KVWAVF,X'FF'        SAY VALUES FOUND\n         TM    KVOP0001,X'FF'      Q. ANY OP CODES SPECIFIED\n         BNZ   KVR320              A. YES, SEE IF SOME WORK TO DO\n         B     KVR250              ELSE CONTINUE VALUES SCAN\nKVR320   DS    0H                  DECODE OP CODES AND DO THEM\n         LA    6,KVVV0001          GET ADDR OF VALUES ENTRY\n         LA    1,KVWAFLN           ADDR OF SAVE TABLE\n         ICM   7,15,KVWACN1        GET CURRENT COUNT OF VALUES ALREADY\n*                                  PROCESSED\n         BZ    KVR326              ADD THIS ONE IF NONE YET\nKVR322   DS    0H\n         C     6,0(1)              Q. ALREADY PROCESSED THIS ENTRY\n         BE    KVR250              A. YES BYPASS FURTHER PROCESSING\n         LA    1,4(,1)             BUMP TABLE ADDRESS\n         BCT   7,KVR322            CONTINUE SCAN\nKVR326   DS    0H\n         ST    6,0(1)              SAVE ADDRESS OF THIS ENTRY FOR LATER\n*                                  COMPARE OF OTHER VALUES\n         L     7,KVWACN1           GET OLD COUNT\n         LA    7,1(,7)             ADD 1 TO IT\n         ST    7,KVWACN1           AND SAVE IT\n         SR    6,6                 CLEAR WORK REG\n         SR    7,7                 CLEAR WORK REG\n         ICM   6,3,KVTO0001        GET TO ADDRESS\n         SRDL  6,12                GET REG NO. INTO R2\n         SLL   6,2                 X 4\n         LA    1,KVWASAV1          ADDR OF SAVE AREA\n         L     6,0(6,1)            GET CONTENTS OF TO BASE REG\n         SRL   7,20                SHIFT TO LOWER END\n         LA    2,0(7,6)            GET TO ADDREESS\n         SR    6,6                 CLEAR WORK REG\n         SR    7,7                 CLEAR WORK REG\n         ICM   6,3,KVFR0001        GET FROM ADDRESS\n         SRDL  6,12                GET REG NO. INTO R6\n         SLL   6,2                 X 4\n         LTR   6,6                 Q. WAS THIS SELF DEFINING TERM\n         BZ    KVR330              A. YES, DONT LOAD NONEXISTENT BASE\n         LA    1,KVWASAV1          ADDR OF SAVE AREA\n         L     6,0(6,1)            GET CONTENTS OF FROM BASE REG\nKVR330   DS    0H\n         SRL   7,20                SHIFT TO LOWER END\n         LA    8,0(7,6)            GET FROM ADDRESS\n         SR    1,1                 CLEAR WORK REG\n         ICM   1,3,KVOL0001        GET LENGTH OF FIELD\n         BCTR  1,0                 GET EX LENGTH\n         SR    7,7                 CLEAR WORK REG\n         IC    7,KVOP0001          GET OP CODE\n         SLL   7,2                 MULTIPLY BY 4\n         B     *+0(7)              BRANCH TO OP CODE ROUTINE\n         B     KVR360              N OP CODE SPECIFIED\n         B     KVR380              O OP CODE SPECIFIED\n         B     KVR400              M OP CODE SPECIFIED\n         B     KVR420              X OP CODE SPECIFIED\nKVR360   DS    0H                  N OP CODE\n         LTR   6,6                 Q. WAS FROM FIELD SELF DEFINING\n         BNZ   KVR366              A. NO, CONTINUE STOR-STOR OPERATION\n         EX    8,KVOPNI            ISSUE THE AND OP CODE STOR-IMED\n         B     KVR250              AND CONTINUE WITH OTHER VALUES\nKVR366   DS    0H                  N OP CODE\n         EX    1,KVOPN             ISSUE THE AND OP CODE STOR-STOR\n         B     KVR250              AND CONTINUE WITH OTHER VALUES\nKVR380   DS    0H                  O OP CODE\n         LTR   6,6                 Q. WAS FROM FIELD SELF DEFINING\n         BNZ   KVR386              A. NO, CONTINUE STOR-STOR OPERATION\n         EX    8,KVOPOI            ISSUE THE OR OP CODE STOR-IMED\n         B     KVR250              AND CONTINUE WITH OTHER VALUES\nKVR386   DS    0H                  N OP CODE\n         EX    1,KVOPO             ISSUE THE OR OP CODE STOR-STOR\n         B     KVR250              AND CONTINUE WITH OTHER VALUES\nKVR400   DS    0H                  M OP CODE\n         LTR   6,6                 Q. WAS FROM FIELD SELF DEFINING\n         BNZ   KVR406              A. NO, CONTINUE STOR-STOR OPERATION\n         EX    8,KVOPMI            ISSUE THE MVC OP CODE STOR-IMED\n         B     KVR250              AND CONTINUE WITH OTHER VALUES\nKVR406   DS    0H                  N OP CODE\n         EX    1,KVOPM             ISSUE THE MVC OP CODE STOR-STOR\n         B     KVR250              AND CONTINUE WITH OTHER VALUES\nKVR420   DS    0H                  N OP CODE\n         LTR   6,6                 Q. WAS FROM FIELD SELF DEFINING\n         BNZ   KVR426              A. NO, CONTINUE STOR-STOR OPERATION\n         EX    8,KVOPXI            ISSUE THE XI OP CODE STOR-IMED\n         B     KVR250              AND CONTINUE WITH OTHER VALUES\nKVR426   DS    0H                  N OP CODE\n         EX    1,KVOPX             ISSUE THE XC OP CODE STOR-STOR\n         B     KVR250              AND CONTINUE WITH OTHER VALUES\nKVR500   DS    0H                  ALL VALUES SCANNED\n         SR    9,9                 CLEAR RC\n         B     KVR900              AND RETURN\nKVR900   DS    0H                  RETURN POINT\n         LTR   9,9                 Q . RC=00\n         BNZ   KVR930              A. NO, CONTINUE RETURN TO CALLER\n         ICM   1,15,KVWARTN        Q. RTN TO CALL\n         BZ    KVR910              A. NO, CONTINUE NO CALL\n         ST    14,KVWAR14          SAVE REG 14\n         LR    15,1                GET RTN ADDR\n         LA    0,KVWAKWVA          GET STRING ADDR\n         ST    13,KVWASAV+4        SAVE CALLERS SAVE AREA ADDR\n         LA    13,KVWASAV          MY SAVE AREA\n         L     1,KVWAPRM           GET PARM DATA ADDR\n         BALR  14,15               CALL USERS ROUTINE\n         L     14,KVWAR14          RESTORE REG 14\n         L     13,KVWASAV+4        RESTORE REG 13\nKVR910   DS    0H\n         MVI   KVWAFL1,1           SAY AT LEAST 1 GOOD FIND\n         B     KVR004              GO DO MORE NOW\nKVR930   DS    0H\n         L     4,KVWALOC           SAVE STRING LOCATION\n         L     5,KVWAKEY           SAVE KEYWORD LOCATION\n         CLI   KVWAFL1,0           Q. ANY GOOD FINDS\n         BE    KVR950              A. NO, LEAVE RC AS IS\n         C     9,KVASIX            Q. WAS RC=16\n         BNE   KVR950              A. NO, LEAVE RC AS IS\n         SR    9,9                 SET ZERO RC\nKVR950   DS    0H\n         LR    1,12                GET WORKAREA ADDRESS\n         LA    0,KVWALNTH          GET WORKAREA LENGTH\n         FREEMAIN R,LV=(0),A=(1)   FREE WORKAREA\n         LR    15,9                SETUP RETURN CODE\n         SLL   15,8                CLEAR HIGH BYTE FOR       ECS04/86\n         SRL   15,8                31 BIT MODE XA            ECS04/86\n         LM    6,12,11*4(13)       RESTORE REGS\n         LR    0,5                 PUT IN KEYWORD LOCATION\n         LR    1,4                 PUT IN STRING LOCATION\n         LM    2,5,7*4(13)         RESTORE OTHER REGS\n         L     14,3*4(13)          RESTORE RETURN REG\n         BR    14                  RETURN TO CALLER\n         SPACE 4\nKVOPN    NC    0(0,2),0(8)\nKVOPNI   NI    0(2),0\nKVOPO    OC    0(0,2),0(8)\nKVOPOI   OI    0(2),0\nKVOPM    MVC   0(0,2),0(8)\nKVOPMI   MVI   0(2),0\nKVOPX    XC    0(0,2),0(8)\nKVOPXI   XI    0(2),0\nKVCVR    CLC   KVKV0001(0),0(4)\nKVTR1VR  TRT   0(0,4),KTVRT1-X'40'\nKVTR2VR  TRT   1(0,8),KTVRT3-X'40' ALPHA TEST\nKVTR3VR  TRT   1(0,8),KTVRT2-X'40' NUMERIC TEST\nKVTR4VR  TRT   1(0,8),KTVRT4-X'40' ALPHA/NUMERIC TEST\nKVC2VR   CLC   KVVV0001(0),1(5)\nKVM1VR   MVC   1(0,8),KVWATMP\nKVM2VR   MVC   1(0,6),1(5)\nKTVRT1   DC    10X'00',C'\u00a2.<(+|&&',9X'00',C'!$*);\u00ac-/',10X'00',C'%_>?'\n         DC    9X'00',C''':#@ =\"',X'00',C'ABCDEFGHI',7X'00'\n         DC    C'JKLMNOPQR',8X'00',C'STUVWXYZ',23X'00',C'ABCDEFGHI'\n         DC    7X'FF'\n         DC    C'ABCDEFGHI',7X'00',C'JKLMNOPQR',8X'00',C'STUVWXYZ'\n         DC    6X'00',C'0123456789'\nKTVRT2   DC    176X'FF',10X'00'\nKTVRT3   DC    129X'FF',41X'00',16X'FF'\nKTVRT4   DC    11X'FF',X'00',15X'FF',2X'00',30X'FF',2X'00'\n         DC    68X'FF',63X'00'\nKVAKVVG  DC    Y(KVVG0001)\nKVAFFFF  DC    X'FFFF'\nKVASIX   DC    F'16'\nKVH256   DC    H'256'\nKVAX00   DC    X'00'\nKVASLASH DC    C'/'\nKVDSVR   DSECT\nKVLL0001 DS    AL1                 LENGTH OF KEY-1\nKVRA0001 DS    SL2                 RTN ADDRESS\nKVRP0001 DS    SL2                 RTN PARM\nKVAA0001 DS    SL2                 AREA ADDRESS\nKVVLL001 DS    AL1                 VALUE LENGTH LOW\nKVVLH001 DS    AL1                 VALUE LENGTH HIGH\nKVLV0001 DS    AL1                 VALUE COUNT LOW\nKVHV0001 DS    AL1                 VALUE COUNT HIGH\nKVVT0001 DS    XL1                 VALUE TYPE\nKVTA0001 EQU   X'01'               ALPHA TYPE\nKVTN0001 EQU   X'02'               NUMERIC TYPE\nKVTB0001 EQU   X'03'               ALPHA OR NUMERIC TYPE\nKVVN0001 DS    AL1                 COUNT OF VALUE ENTRIES\nKVKL0001 EQU   *-KVLL0001          LENGTH OF TABLE ENTRY MINUS KEYWORD\nKVKV0001 DS    C                   KEYWORD\nKVVL0001 DS    AL1                 VALUE LENGTH\nKVOP0001 DS    XL1                 OP CODE\nKVVA0001 EQU   X'01'               N  OP CODE\nKVVO0001 EQU   X'02'               O  OP CODE\nKVVM0001 EQU   X'03'               M  OP CODE\nKVVX0001 EQU   X'04'               X  OP CODE\nKVTO0001 DS    SL2                 TO ADDRESS\nKVFR0001 DS    SL2                 FROM ADDRESS\nKVOL0001 DS    AL2                 LENGTH OF TO FIELD\nKVVG0001 EQU   *-KVVL0001          ENTRY LENGTH MINUS VALUE CONSTANT\nKVVV0001 DS    C                   VALUE CONSTANT\nKVLA0001 EQU   *,2                 LAST ENTRY =X'FFFF'\nKVWAVR   DSECT\nKVWAVF   DS    X                   VALUES FOUND FLAG\nKVWAQUO  DS    X                   QUOTED STRING MODE FLAG\nKVWASV   DS    F                   ADDR OF VALUES FOUND\nKVWASAV  DS    18F                 SAVE AREA TO CALL RTN\nKVWARTN  DS    F                   ADDRESS OF RTN TO CALL\nKVWAPRM  DS    F                   ADDRESS OF RTN PARM\nKVWALOC  DS    F                   LOCATION OF INPUT STRING\nKVWAR14  DS    F                   SAVE AREA FOR REG 14\nKVWAR2   DS    F                   SAVE AREA FOR REG 2\nKVVNCNT  DS    F                   VALUE COUNT SAVEAREA\nKVWAKEY  DS    F                   ADDRESS OF CURRENT KEYWORD IN STRING\nKVWACN1  DS    F                   COUNT OF VALUE ADDRS IN KVWAFLN\nKVWASVC  DS    X                   COUNT OF VALUES FOUND\nKVWACLR  EQU   *-KVWAVR            LENGTH OF WORKAREA TO CLEAR\nKVWAFL1  DS    X                   FLAG TO SHOW SOME GOOD WORDS FOUND\nKVWAOPTS DS    XL2                 OPTIONS FROM CALL               8/30\nKVWAOPT1 EQU   KVWAOPTS,1          FIRST BYTE                      8/30\nKVWAOEQ  EQU   X'80'               IF SET THEN TYPE=EQUAL          8/30\nKVWASAV1 DS    16F                 SAVE AREA FOR CALLERS REGS\nKVWAKWVA DS    512X                WORKAREA FOR VALUE MOVE\nKVWAFLN  DS    15XL4               SAVEAREA FOR MAX COUNT OF FIELDN'S\nKVWATMP  DS    XL256               WORKAREA FOR TEMP VALUE MOVE\nKVWALNTH EQU   *-KVWAVR            LENGTH OF WORKAREA TO ALLOC\n&CSNAME  CSECT\n         POP   USING,PRINT\n.NOGO    ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LOADLIB": {"ttr": 3594, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x00&\\x01\\x19\\tO\\x01\\x19\\tO\\x14G\\x13b\\x13b\\x00\\x00\\xe7\\xd4\\xc9\\xe3@@@@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "2019-04-04T00:00:00", "modifydate": "2019-04-04T14:47:26", "lines": 4962, "newlines": 4962, "modlines": 0, "user": "XMIT"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "LOOK": {"ttr": 5641, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x03\\x01\\x18\\x00\\x7f\\x01\\x19\\tO\\x17R\\x00\\x1f\\x00\\x02\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2018-01-07T00:00:00", "modifydate": "2019-04-04T17:52:03", "lines": 31, "newlines": 2, "modlines": 0, "user": "SBGOLOB"}, "text": " Please use source for either LOOKN, LOOKJ or LOOK02 to assemble\n LOOK.  LOOKN is the 64-bit version (the latest (and greatest?)).\n\n The newest version of LOOK is called LOOKN, and it is the 64-bit\n  version.  With it, you can examine storage above the bar.\n\n If you don't mind the program always having to be APF authorized,\n  then use LOOKJ.  It is more reliable.  The old LOOK does not\n  have to be authorized, if you are only looking at storage in\n  your own address space.  But it is subject to S0C4 abends,\n  at least when running on newer z/OS systems.\n\n After z/OS version 2.4 and including 2.4, you will HAVE TO USE\n  either LOOKJ or LOOKN, because the earlier versions of LOOK\n  allocate user key common storage, which is not allowed at\n  z/OS 2.4 or later.\n\n See members LOOKJ$ or LOOK02$ for assembly-linkedit JCL.\n\n If VSM ALLOWUSERKEYCSA(NO) is coded in your DIAGxx PARMLIB member,\n  then you will have to either code VSM ALLOWUSERKEYCSA(YES),\n  or disable the NO setting temporarily using the UKEYCSA Y\n  invocation of the UKEYCSA (APF-authorized) TSO command, which is\n  included in this pds.  (This will no longer work from z/OS 2.4\n  onwards--people will not be able to allocate user key CSA from\n  then on.)\n\n The current version of LOOKJ does not obtain user key CSA, and it\n  therefore can run when VSM ALLOWUSERKEYCSA(NO) is set in DIAGxx,\n  and it should be able to work on z/OS 2.4.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LOOK$$": {"ttr": 5643, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x10\\x00&\\x01\\x00\\x17O\\x01\\x19\\tO\\x14C\\x00\\x1f\\x00\\x1f\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.16", "flags": 0, "createdate": "2000-06-22T00:00:00", "modifydate": "2019-04-04T14:43:26", "lines": 31, "newlines": 31, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//* ---------------------------------------------------------- *//\n//*              ASM LINKEDIT FROM THIS PDS ONLY               *//\n//* ---------------------------------------------------------- *//\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,FLAG(5))\n//SYSLIB   DD DISP=SHR,DSN=SBGOLOB.CBT497.FILE264\n//         DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.CBT497.FILE264(LOOKJ)\n//         DD DISP=SHR,DSN=SBGOLOB.CBT497.FILE264(CBMACS)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(CYL,2),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n ENTRY   LOOK\n INCLUDE OBJECT\n SETSSI  CB497264\n SETCODE AC(1)\n NAME    LOOKX(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LOOK$$$": {"ttr": 5645, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1a\\x00 \\x01\\x00\\x17O\\x01\\x19\\tO\\x14B\\x00,\\x00\\x1f\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.26", "flags": 0, "createdate": "2000-06-22T00:00:00", "modifydate": "2019-04-04T14:42:20", "lines": 44, "newlines": 31, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//* ------------------------------------------------------------ *//\n//*     ASM LINKEDIT USING SOURCE PDS: 'SBGOLOB.LOOK.INSTALL'    *//\n//*          TO INCLUDE MODIFIED IBM MACROS.  IBM MACROS         *//\n//*     IKJEFLWA AND OTHERS (SEE MEMBER $$NOTE2) WERE COPIED     *//\n//*        INTO 'SBGOLOB.LOOK.INSTALL' AND MODIFIED BY ME.       *//\n//*       ALSO ASSEMBLES UNDOCUMENTED \"IBM\" CONTROL BLOCKS,      *//\n//*           SOME OF WHICH ARE INCLUDED IN THIS PDS.            *//\n//*      IF YOU WANT TO MODIFY AN IBM MACRO, COPY IT INTO        *//\n//*    YOUR EQUIVALENT OF LOOK.INSTALL, AND CHANGE IT THERE.     *//\n//* ------------------------------------------------------------ *//\n//* CHANGE YOUR VERSION OF CBMACSE TO FORMAT THE NON-IBM MACROS  *//\n//* ------------------------------------------------------------ *//\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,FLAG(5))\n//SYSLIB   DD DISP=SHR,DSN=SBGOLOB.LOOK.INSTALL   (MACRO CHANGES)\n//         DD DISP=SHR,DSN=SBGOLOB.CBT497.FILE264\n//         DD DISP=SHR,DSN=SYS1.MACLIB\n//*               MOVE LWAPRMLB LABEL TO DS X AND NOT DS 0F.\n//         DD DISP=SHR,DSN=SYS1.MODGEN            (SYS1.MODGEN)\n//         DD DISP=SHR,DSN=SBGOLOB.SHOW723.MACLIB (CBT FILE 492 UNDOC)\n//*               CONTAINS MACROS FOR UNDOCUMENTED CONTROL BLOCKS\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.CBT497.FILE264(LOOKJ)\n//         DD DISP=SHR,DSN=SBGOLOB.CBT497.FILE264(CBMACSE)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(CYL,2),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n ENTRY   LOOK\n INCLUDE OBJECT\n SETSSI  CB497264\n SETCODE AC(1)\n NAME    LOOK(R)\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LOOKJ": {"ttr": 5889, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01c\\x00W\\x00\\x86\\x15/\\x01\\x19\\tO\\x14 \\x08u\\x05#\\x05E\\xf3\\xf1`\\xc2\\xc9\\xe3@@@@'", "ispf": {"version": "01.99", "flags": 0, "createdate": "1986-06-01T00:00:00", "modifydate": "2019-04-04T14:20:57", "lines": 2165, "newlines": 1315, "modlines": 1349, "user": "31-BIT"}, "text": "         TITLE 'LOOK -- DISPLAY VIRTUAL MEMORY'\n*\n** -------------------------------------------------------------------\n**   This version of LOOK has been revised by Joe Reichman to allow\n**   operation when VSM ALLOWUSERKEY(NO) is set, in the PARMLIB\n**   member DIAGxx.  For cross-memory storage browsing, the SCHEDULE\n**   macro has been replaced by IEAMSCHD, so this version of the\n**   program may not work on old MVS systems.  However, IEAMSCHD has\n**   been here at least since ESA.  Its parameter SYNCH=YES has been\n**   in existence since OS/390 Release 1.3 (but not before that).\n**   (Since OS/390 1.3 was the first Y2K-compliant version of MVS,\n**   it is not likely that anyone is running something earlier, in\n**   production.)\n**\n**   From z/OS 2.4 and onward, user key CSA allocation will be\n**   prohibited.  But this version of LOOK should still work there.\n**\n**   THIS VERSION OF LOOK REQUIRES APF-AUTHORIZATON, ALWAYS, BECAUSE\n**   ITS WORKING STORAGE IS NOW OBTAINED IN KEY 0, NOT IN A USER KEY.\n** -------------------------------------------------------------------\n**   LOOK requires assembly together with the CBMACS module, so that\n**   it can format many system control blocks.  The LOOK module is the\n**   \"driving code\", which can be assembled together with different\n**   versions of CBMACS depending on any specialized needs that you\n**   have, to format specific control blocks.  The CBMACS we have\n**   packaged with CBT File 264, will already format many standard\n**   z/OS (OS390, MVS) control blocks, but you may want to create\n**   your own versions of CBMACS.\n**\n**   Please note:  CBMACS will only format \"real data\" in macros,\n**   so when an IBM macro contains:   label   DS  0CLx   or similarly,\n**   label  DS  0XLx  then CBMACS will not display that field.  You\n**   may want to create your own altered versions of IBM macros, but\n**   we can't publish them for licensing reasons.  Formatting in\n**   CBMACS also depends on the data type (such as C, X, A, F, etc.)\n**   You may want to alter an IBM macro from  DS CL5 to DS XL5, so\n**   that the data will display in hex, instead of showing a dot,\n**   when that data is not a displayable value.\n**\n**   Formatting is turned off, using the ONULL command in LOOK.\n**   Formatting is turned on, using the O command, followed by\n**   the name of the control block:\n**   Examples:   OTCB  OPSA  OCVT\n**\n**   If the control block (to be formatted) does not contain an\n**   eyecatcher, such as \"TCB\" (field TCBTCBID in macro IKJTCB),\n**   then you can not format it automatically, but you need to run\n**   an Oblkid command to do the formatting.\n**   -----------------------------------------------------------------\n**\n**       This version of LOOK supports multiple address space\n**       investigation.  Overtype the address space number, at\n**       the upper right side of the screen:\n**\n**       Example:    CURRENT ASID= 0024\n**                                 ----   (overtype hex asid number)\n**\n**       THIS VERSION IS CONFIGURED TO RUN AND RESIDE ABOVE THE LINE,\n**       AND IS THE 31-BIT VERSION.\n**\n** -------------------------------------------------------------------\n**\n**   VERSION 1.1 CHANGES (6/1/88):                                  1.1\n**      - CORRECT ESTAE AND FRR ATTEMPTS TO DETERMINE HOW MUCH      1.1\n**        DATA WAS MOVED.                                           1.1\n**      - GIVE MESSAGES IF DATA WAS NOT MOVED, DISTINGUISH BETWEEN  1.1\n**        NON-EXISTENT (PAGE/SEGMENT FAULT), AND KEY/FETCH          1.1\n**        PROTECTION ERROR.                                         1.1\n**      - TRANSLATE THE OUTPUT CHARACTER STRINGS FOR CONTROL BLOCK  1.1\n**        FORMATTING. THANKS TO MR. S. GOLOB OF NEWSWEEK            1.1\n**      - COMBINE XA AND SP MODULES INTO 1 VIA GLOBAL SYMBOL        1.1\n**\n**   VERSION 1.1A CHANGES (12/5/88):                               1.1A\n**      - CORRECT HANDLING OF ERROR MESSAGES.                      1.1A\n**\n**   VERSION 1.1B CHANGES (10/31/89):                              1.1B\n**      - Change amount of core gotten for ESA.                    1.1B\n**\n**   VERSION 1.1C CHANGES (11/28/90):                              1.1C\n**      - Add changes from Bruce Bordonaro.                        1.1C\n**            - Use STTMPMD.                                       1.1C\n**            - Add significant number of macro formats.           1.1C\n**      - Improve memory fetch when CPU does no data movement.     1.1C\n**      - Fix problem in FRR recovery.                             1.1C\n**\n**   VERSION 1.1D CHANGES (01/22/91):                              1.1D\n**      - Add spelling corrections from Sam Golob.                 1.1D\n**      - Correct HELP screen for Overlay command.                 1.1D\n**      - Correct Mode command.                                    1.1D\n**      - Fix bugs in control block segments.                      1.1D\n**      - Handle 31 bit address correctly when top bit on.         1.1D\n**      - Correct title - Never did and never will actually        1.1D\n**                         zap memory - use INCORZAP or #D         1.1D\n**      - Stop long fields from overlaying next lines.             1.1D\n**      - Correct blanking out of areas not available              1.1D\n**      - Get memory line at a time in dump, if necessary.         1.1D\n**\n**   VERSION 1.1E CHANGES (07/02/91):                              1.1E\n**      - If authorized then do memory fetches in KEY=0.           1.1E\n**\n**   CHANGES (04/21/17)       (Joe Reichman)                       JOE\n**      - Endeavor to fix S0C4 occurrences when storage cannot\n**        be obtained.  Changed SCHEDULE macro call to IEAMSCHD.\n**        Moved FRR call into IEAMSCHD, etc.\n**      - This version needs APF authorization. Message added.\n**\n**   CHANGES (02/06/19)       (Joe Reichman)                       Joe\n**      - Allow LOOK to operate without getting common storage\n**        in a user key.  VSM  ALLOWUSERKEYCSA(NO) in DIAGxx\n**        PARMLIB member, needed to be set, to run LOOK.  Now it\n**        doesn't matter.  VSM ALLOWUSERKEYCSA will be obsolete\n**        after z/OS 2.4.  Also we now require APF authorization\n**        for all invocations of LOOK, even in the current user's\n**        address space, because CSA is now obtained in KEY 0.\n**\n**   CHANGES (02/12/19)       (Sam Golob)\n**      - Cosmetic changes to the HELP screen (PF1) and to the\n**        ASID title, from \"DISPLAY ASID\" to \"CURRENT ASID\" so\n**        that you get the idea that the ASID number can be\n**        changed by typing it over with another hex number.\n**        Add more usage instructions at the beginning of the\n**        program source.\n*\n         EJECT ,                                                   1.1D\n         MACRO\n&N       HEX   &TO,&FROM\n&N       UNPK  TEMP1(9),&FROM.(5,R6)\n         MVC   &TO.(8,R4),TEMP1\n         TR    &TO.(8,R4),HEXTAB\n         MEND\n         EJECT ,                                                   1.1D\nLOOK     CSECT\n******************************                                     1.1D\n**                                                                 1.1D\n**     Fetch constant - maximum amount fetchable in one call       1.1D\n**                                                                 1.1D\nMAXFETCH EQU   4096                                                1.1D\n**                                                                 1.1D\n**                                                                 1.1D\n******************************                                     1.1D\n         SPACE 3                                                   1.1D\n*                                                                   1.1\n*        SET THE FOLLOWING GLOBAL SYMBOL TO 1 FOR XA AND 0 FOR SP   1.1\n*                                                                   1.1\n         GBLB  &XA                                                  1.1\n&XA      SETB  1 =XA MODE              SET TO 1 FOR XA              1.1\n         SPACE 3                                                    1.1\n*  INITIALIZE THE PROGRAM\n         SAVE  (14,12),,'LOOK..&SYSDATE..&SYSTIME'\n         LR    R11,R15                 PERMANENT BASE\n         USING LOOK,R11\n         LA    R9,2048(,R11)           GET A SECOND BASE REG\n         LA    R9,2048(,R9)\n         USING LOOK+4096,R9\n         AIF   (&XA).XA1                                            1.1\n         GETMAIN R,LV=WORKLEN,SP=1                          SP      1.1\n         AGO   .NXA1                                                1.1\n.XA1     ANOP                                                       1.1\nLOOK     AMODE 31                                           XA      1.1\nLOOK     RMODE ANY                                          XA      1.1\n         GETMAIN R,LV=WORKLEN,SP=1,LOC=(BELOW,ANY)          XA      1.1\n.NXA1    ANOP                                                       1.1\n         LR    R10,R1\n         LR    R2,R10                  WORK AREA START\n         L     R3,=A(WORKLEN)          LENGTH TO CLEAR\n         SR    R5,R5                   ZERO PAD BYTE, LENGTH 2\n         MVCL  R2,R4                   CLEAR THE WORK AREA\n         USING WORKAREA,R10\n         LA    R4,QDINIT\n         LA    R3,QDISPLN              GET LENGTH\n         LA    R2,QDISPLAY             POINT AT START\n         LR    R5,R3                   SET FROM LENGTH\n         MVCL  R2,R4                   INIT DISPLAY\n         ST    R13,SAVE+4              CHAIN THE SAVE AREAS\n         LA    R15,SAVE\n         ST    R15,8(,R13)\n         LR    R13,R15                 NEW SAVE AREA\n         STM   R9,R11,BASE1        SAVE FIRST THREE REGS FOR AREA\n         ST    R13,BASR13          AND ORIGINAL R13\n         TESTAUTH FCTN=1               ARE WE AUTHORIZED\n         LTR   R15,R15\n         BNZ   ENDIT0                  IF NOT SEND MESSAGE\n         LA    R1,50*HISTLEN           GET LENGTH OF HIST TBL\n         GETMAIN R,SP=2,LV=(1)\n         ST    R1,HISTORY              SAVE ADDRESS\n         STFSMODE ON,INITIAL=YES       TELL TSO WE ARE FULLSCREEN\n         STTMPMD ON,KEYS=ALL                                       1.1C\n*\n*        SET SUPERVISOR MODE IF AUTHORIZED\n*\n*        OI    FLAGS,NOAUTH            SET NOT AUTHORIZED           Joe\n         L     R1,=A(WORKLN)           GET LENGTH OF CAS BUFFER\n         ST    R1,CSALEN               SET LENGTH AND SP0\n         MVI   CSALEN,241              SET CSA SP\n*        NI    FLAGS,255-NOAUTH        MARK AUTHORIZED              Joe\n         MODESET MODE=SUP              SET TO SUP MODE\n         SPKA  0                       MAKE SURE GETMAIN IS KEY 0   Joe\nNOTAUTH  DS    0H\n         MVC   ASIDLN,ASIDFMT          SET MESSAGE\n         L     R1,16                   GET CVT\n         L     R2,0(,R1)               GET TCBWORDS\n         L     R1,12(,R2)              GET OLD ASCB ADDR (MINE)\n         USING ASCB,R1\n         MVC   MYASID,ASCBASID         MOVE IN MY ASID\n         MVC   CURASID,MYASID\n         DROP  R1\n         XC    CSAASID,CSAASID         CLEAR THE CSA BUFFER INDIC\n         XC    CSASTAR,CSASTAR\n         XC    CSAEND,CSAEND\n         L     R0,CSALEN               GET LENGTH AND SP FOR CSA BUFFER\n         GETMAIN R,LV=(0)\n         ST    R1,CSAWORK              SAVE ADDR OF CSA BUFFER\n         LR    R8,R1                   SET PROPER POINTER\n         USING WORK,R8\n*\n*        SETUP ESTAE IN CORRECT MODE\n*\n         ESTAE RECOVERY,PARAM=(R8),MF=(E,ESTAE)\n*\n*        INITIALIZE ASID POINTERS\n*\n         LR    R0,R2                   Hold R2                    JOE\n         XR    R2,R2                   Clear R2                   JOE\n         IPK                                                      JOE\n         ST    R2,USERSTOR             Sav                        JOE\n         LR    R2,R0                                              JOE\n         MVC   MYTCB,4(R2)             SAVE ADDR OF MY TCB\n         MVC   MYASCB,12(R2)           SAVE ADDR OF MY ASCB\n         LA    R1,BUF                  POINT TO TRUE BUFFER\n         ST    R1,CSABUF\n         LA    R0,SRBCCD               POINT TO CSA SRB CODE AREA\n         LA    R1,SRBCODE              AND LENGTH OF CODE\n         LR    R3,R1\n         LA    R2,D#SRBCD              POINT TO CSECT CODE\n         MVCL  R0,R2                   MOVE SRB CODE TO CSA\n         B     ISCAN1                  GO AND PROCESS\n         DROP  R8\n         EJECT\n***********************************************************************\n*\n*   INPUT SCAN\n*\n***********************************************************************\n         SPACE 2\nISCAN    DS    0H\n         OC    ASIDLN1,=CL4' '         UPPERCASE BEFORE COMPARISON\n         CLC   SAVEASID,ASIDLN1        DID USER CHANGE ASID\n         BE    ISCAN1                  NOPE\n*\n*        FORMAT AND SAVE USER ASID\n*\n*=====>    Validate chars typed into ASID field  -  below\n*        In this section of code, R15 thru R1 are work registers.\n*\n*        VERIFY IF WE TYPED IN NON-HEX CHARACTERS IN ASID FIELD\n*\n         STM   R15,R1,SAVE1501         SAVE REGISTERS AS WORK REGS\n         L     R15,=A(TRVALHEX)        ACCESS THE TRANSLATE TABLE\n         USING TRVALHEX,R15            TELL ASSEMBLER\n         TR    ASIDLN1,TRVALTAB        NON-HEX CHARS BECOME X'CC'\n         LA    R0,4                    SET UP LOOP TO DETECT THEM\n         LA    R1,ASIDLN1              POINT TO TRANSLATED ASID INPUT\nASIDVERL DS    0H                      LOOP TO LOOK FOR NON-HEX CHARS\n         CLI   0(R1),X'CC'             IS IT INVALID?\n         BE    ASIDBCH                 YES. REPORT THAT.\n         LA    R1,1(,R1)               TRY NEXT CHARACTER\n         BCT   R0,ASIDVERL             LOOP 4 TIMES\n         B     ASIDGUDC                GO TELL THAT GOOD ASID CHARS\nASIDGUDC DS    0H                      NO INVALID CHARS TYPED IN\n         DROP  R15\n*=====>    Validate chars typed into ASID field  -  above\n*                                      CONVERT DISPLAY ASID TO HEX HWD\n         MVC   TEMP1(4),ASIDLN1        GET USER INFO\n         OC    TEMP1(4),=CL4' '        MAKE UPPER CASE\n         TR    TEMP1(4),HEXTAB         MAKE PACKABLE\n         PACK  TEMP2(3),TEMP1(5)\n         MVC   CURASID,TEMP2           GET NEW ASID\n*====>     Validate if number typed in, is a valid ASID - below\nASIDVAL  DS    0H                      Now check for invalid ASID nmbrs\n         L     R15,CVTPTR              R15 -> cvt\n         L     R15,CVTASVT-CVT(,R15)   R15 -> asvt\n         USING ASVT,R15\n         XR    R0,R0                   Clear work register\n         LH    R0,CURASID              Load ASID\n         C     R0,ASVTMAXU             Higher than Max defined?\n         BH    ASIDBCH                 Yes. Show error.\n         LA    R1,ASVTENTY-ASVT(,R15)  Get first ASVT slot\n         BCTR  R0,0                    Down By 1 (starts with 0)\n         SLL   R0,2                    Multiply by 4\n         AR    R1,R0                   Point to ASCB addr in ASVT\n         TM    0(R1),X'80'             Is it Available?\n         BO    ASIDINAC                No. Show it is inactive.\nASIDVALE DS    0H\n         LM    R15,R1,SAVE1501         RESTORE R15 THRU R1\n         B     ISCAN1\n         DROP  R15\n*====>     Validate if number typed in, is a valid ASID - above\n*\n*--->  ASID typed entry errors - below\nASIDBCH  DS    0H                      REPORT NON-HEX CHARS TYPED IN\n         MVC   MSGLINE,INVASIDC        INVALID CHARS TYPED IN ASID\n         MVC   ASIDLN1,SAVEASID        PLUG IN PREVIOUS ASID VALUE\n         MVC   CURASID,MYASID          GUARANTEE GOOD ASID (MYASID)\n         B     TPUTSCRN                AND RE-DISPLAY THE SCREEN\n*\nASIDINAC DS    0H                      REPORT INACTIVE ASID TYPED IN\n         MVC   MSGLINE,INVTYPDV        INVALID CHARS TYPED IN ASID\n         MVC   ASIDLN1,SAVEASID        PLUG IN PREVIOUS ASID VALUE\n         MVC   CURASID,MYASID          GUARANTEE GOOD ASID (MYASID)\n         B     TPUTSCRN                AND RE-DISPLAY THE SCREEN\n*--->  ASID typed entry errors - above\n*\nISCAN1   MVC   INPSAVE,INPLINE         SAVE LAST USER INPUT\nISCAN2   LA    R3,INPLINE              POINT TO START OF INPUT\n         LA    R1,SCANTAB              COMMAND TABLE\n         NI    FLAGS,255-INDFLAG-IND31-IND64 TURN OFF INDIRECT FLAGS\n         MVC   MSGLINE,TITLE           CLEAR OUT ERROR MSG\nSCANLOOP L     R2,4(,R1)               GET TABLE ENTRY\n         CLC   0(1,R1),ENDTAB          SEE IF END OF TABLE\n         BE    NUMSCAN                 IF YES, ASSUME NUMERIC INPUT\n         CLC   0(1,R1),INPLINE         SEE IF COMMAND FOUND\n         BER   R2                      IF YES, GO TO COMM ROUINE\n         LA    R1,8(,R1)               NEXT ENTRY ADDRESS\n         B     SCANLOOP\nSAVE1501 DS    3F\nSCANTAB  DS    0F                      COMMAND TABLE\n         DC    CL4' ',A(FORMAT)\n         DC    CL4'I',A(INDIR)\n         DC    CL4'J',A(INDIR31)\n         DC    CL4'G',A(INDIR64)\n         DC    CL4'>',A(FWD)\n         DC    CL4'<',A(BACK)\n         DC    CL4'=',A(DEFINE)\n         DC    CL4',',A(NUMSCAN)\n         DC    CL4'M',A(MODE)\n         DC    CL4'L',A(LINK)\n         DC    CL4'O',A(OVERLAY)\n         DC    CL4'R',A(REFRESH)\nENDTAB   DC    X'FF'                   END OF TABLE INDICATOR\n         SPACE 2\n***********************************************************************\n*\n*     FORMAT THE OUTPUT SCREEN\n*\n***********************************************************************\n         SPACE 2\nFORMAT   LA    R3,INPLINE              CURSOR ADDRESS\n         MVC   INPLINE,BLANKS          CLEAR INPUT LINE\nFORMAT2  BAL   R14,ERASE               CLEAR THE SCREEN\n         LH    R2,CURRENT              HISTORY TABLE POINTER\n         A     R2,HISTORY              POINT AT HISTORY TABLE ENTRY\n         USING HIST,R2                 IDENTIFY HISTORY ENTRY FORMAT\n         L     R4,HISTADDR             GET ADDRESS TO DISPLAY\n         TM    HISTCBHP,X'80'          IS THIS A CB MAP IN USE\n         BO    CBHIT                   IF SO THE PROCESS IT\n         CLC   =X'7FFFFFFF',HISTCBHP   SUPPRESSED CB USAGE\n         BE    NOCB\n         DROP  R2\n         SPACE 2\n*----------------------------------------------------------------------\n*\n*        SEE IF CONTROL BLOCK MAP EXISTS\n*\n*----------------------------------------------------------------------\n         SPACE 2\nDUMP     L     R5,=V(CBMACS)           GET START OF INDEX\n         LTR   R5,R5                   ANY VALUE\n         BZ    NOCB                    NOPE\n         USING CBH,R5                  ADDRESS THE CONTROL BLK HEADER\nDUMPCB   CLC   =F'0',CBHNEXT           SEE IF END OF INDEX\n         BE    NOCB                    IF YES, NO CB FOUND\n         L     R2,CBHVOFF              GET CB IDENTIFIER OFFSET\n         AR    R2,R4                   ADD DISPLAY ADDRESS\n         SR    R3,R3                   CLEAR A REGISTER FOR IC\n         IC    R3,CBHVLEN              GET LENGTH\n         LR    R0,R3                   PUT IN 0 FOR GETSTOR\n         LA    R1,DUMPDATA             TARGET ADDR\n         BAL   R14,GETSTOR             FETCH THE DATA\n         B     NOTCB                   BR IF NO DATA FOUND\n         B     NOTCB                   BR IF PARTIAL DATA FOUND\n         BCTR  R3,0                    GET MACHINE LENGTH\n         EX    R3,CBFNDIT              LOOK FOR VALIDATION FIELD\n         BE    CBHIT                   BR IF YES, CB WAS FOUND\nNOTCB    L     R5,CBHNEXT              NEXT INDEX ENTRY\n         MVC   MSGLINE,BLANKS          Clear useless error msg     1.1C\n         B     DUMPCB                  AND CHECK FOR MORE CB'S\nCBFNDIT  CLC   CBHVAL(*-*),DUMPDATA    SEE IF IDENTIFIER MATCH\n         DROP  R5\n         SPACE 2\n*----------------------------------------------------------------------\n*\n* IF NO CONTROL BLOCK TO BE SHOWN, JUST USE DUMP FORMAT\n*\n*----------------------------------------------------------------------\n         SPACE 2\nNOCB     LR    R2,R4                   COPY ADDR TO DISPLAY\n         TM    MODEFLAG,ALIGN          QUADWORD ALIGNMENT WANTED\n         BZ    DUMPNOA                 BR IF NOT\n         N     R2,=XL4'FFFFFFF0'       ROUND DOWN FOR DISPLAY\nDUMPNOA  TM    MODEFLAG,MIDDUMP        PUT ADDR INCENTER OF SCREEN?\n         BZ    DUMPNOM                 BR IF NOT\n         SH    R2,=H'128'              IF YES, BACK UP QUAD WORDS\n* R2 NOW HAS FIRST ADDRESS TO DISPLAY\nDUMPNOM  LA    R0,256                  LENGTH TO FETCH\n         LA    R1,DUMPDATA             TARGET ADDRESS\n         LA    R2,0(0,R2)              clear top bit               1.1D\n         BAL   R14,GETSTOR             GO FETCH THE DATA\n         B     DUMPLN                  go dump by line             1.1D\n         NOP   0                       RETURN IF PARTIAL DATA FOUND\n         LA    R6,DUMPDATA             POINT TO DATA TO DISPLAY\n         LA    R4,OUT1                 FIRST OUTPUT LINE ADDR\n         LA    R5,16                   NO. OF LINES TO DISPLAY\nDUMPLOOP DS    0H                      FORMAT THE DISPLAY\n         STCM  R2,15,TEMP2             ADDRESS TO SHOW\n         UNPK  TEMP1(9),TEMP2(5)       CONVERT BINARY TO HEX\n         MVC   0(8,R4),TEMP1           LOW ORDER 32 BITS\n         TR    0(8,R4),HEXTAB\n*        MVI   8(R4),C'_'              SEPARATE FROM HI ORDER 32 BITS\n*        MVC   0(8,R4),=C'00000000'    DUMMY FOR HI ORDER ADDRESS\n         HEX   12,0                    CONVERT FIRST WORD TO HEX\n         HEX   22,4                    SECOND WORD TO HEX\n         HEX   32,8                    THIRD WORD\n         HEX   42,12                   FOURTH AND LAST WORD TO HEX\n         MVI   52(R4),C'*'             FRAME THE EBCDIC DISPLAY\n         MVI   69(R4),C'*'             FRAME THE OTHER SIDE\n         MVC   53(16,R4),0(R6)         COPY THE EBCDIC DATA\n         TR    53(16,R4),VALCHAR       DELETE INVALID CHARS\n         LA    R2,16(,R2)              NEXT LINE ADDR\n         LA    R6,16(,R6)              NEXT DATA AREA\n         LA    R4,80(,R4)              NEXT OUTPUT LINE\n         BCT   R5,DUMPLOOP             GO DO NEXT LINE\n         B     BLANKSC                 Try to blank out data not   1.1D\n         SPACE 2                                                   1.1D\nDUMPLN   DS    0H                      Fetch and dump each line    1.1D\n         LA    R4,OUT1                 FIRST OUTPUT LINE ADDR      1.1D\n         LA    R5,16                   NO. OF LINES TO DISPLAY     1.1D\nDUMPLP2  DS    0H                      FORMAT THE DISPLAY          1.1D\n         STCM  R2,15,TEMP2             ADDRESS TO SHOW             1.1D\n         UNPK  TEMP1(9),TEMP2(5)       CONVERT BINARY TO HEX       1.1D\n         MVC   0(8,R4),TEMP1                                       1.1D\n         TR    0(8,R4),HEXTAB                                      1.1D\n         LA    R0,16                   length of a line            1.1D\n         LA    R1,DUMPDATA             where to put data           1.1D\n         BAL   R14,GETSTOR             get it                      1.1D\n         B     DLKILL                  +0 no data found            1.1D\n         NOP   0                       +4 partial data found       1.1D\n         LA    R6,DUMPDATA             +8 all data found           1.1D\n         HEX   12,0                    CONVERT FIRST WORD TO HEX   1.1D\n         HEX   22,4                    SECOND WORD TO HEX          1.1D\n         HEX   32,8                    THIRD WORD                  1.1D\n         HEX   42,12                   FOURTH AND LAST WORD TO HEX 1.1D\n         MVI   52(R4),C'*'             FRAME THE EBCDIC DISPLAY    1.1D\n         MVI   69(R4),C'*'             FRAME THE OTHER SIDE        1.1D\n         MVC   53(16,R4),0(R6)         COPY THE EBCDIC DATA        1.1D\n         TR    53(16,R4),VALCHAR       DELETE INVALID CHARS        1.1D\nDLKILL   DS    0H                                                  1.1D\n         LA    R2,16(,R2)              NEXT LINE ADDR              1.1D\n*        LA    R6,16(,R6)              NEXT DATA AREA              1.1D\n         LA    R4,80(,R4)              NEXT OUTPUT LINE            1.1D\n         BCT   R5,DUMPLP2              GO DO NEXT LINE             1.1D\nBLANKSC  DS    0H                                                  1.1D\n         SPACE 2\n*----------------------------------------------------------------------\n*\n* NOW BLANK OUT THE SCREEN WHERE THE PAGE DIDN'T EXIST\n*\n*----------------------------------------------------------------------\n         SPACE 2\n         LA    R4,OUT1                 POINT TO FIRST OUTPUT LINE\n         SH    R2,=H'256'              FIRST ADDRESS DISPLAYED\n         LA    R5,16                   NUMBER OF LINES DISPLAYED\nBLLOOP   LA    R15,15(,R2)             LAST ADDRESS ON CURRENT LINE\n         CLC   LOGOOD,HIGOOD           ARE WE IN A WRAP CONDITION\n         BH    BLLP0                   YES SO SKIP NOLINE CHECK\n         C     R2,HIGOOD               IF START>=HIGH\n         BNL   NOLINE                     THEN BLANK ENTIRE LINE\nBLLP0    C     R2,LOGOOD               IF START<LOW & END>=LOW\n         BNL   BLLP1                      THEN HI GOOD AND LOW NEEDS\n*                                                  BLANK\n         C     R15,LOGOOD\n         BNL   HIMIX\nBLLP1    C     R2,HIGOOD               IF START<HIGH & END>HIGH\n         BNL   BLLP2                      THEN LOW GOOD AND BLANK\n*                                                HIGH\n         C     R15,HIGOOD\n         BH    LOWOK\nBLLP2    DS    0H                      LINE OK OTHERWISE\n         B     BLOOPEND\n* BOTH LOW AND HIGH MISSING -- BLANK ENTIRE LINE\nNOLINE   MVI   12(R4),C' '             START OF DATA\n         MVC   13(57,R4),12(R4)        CLEAR THE LINE\n         B     BLOOPEND                GO CHECK ANOTHER LINE\n* BR HERE IF LOW END GOOD, HIGH MAY BE  MISSING\nLOWOK    S     R15,HIGOOD              # OF BYTES TO BLANK\n* THE FOLLOWING CODE TAKES CARE OF LOW STORAGE WRAP\n         CH    R15,=H'15'              MORE THAN 15 BYTES TO CLEAR\n         BH    BLOOPEND                IF YES, IT WRAPPED, NO CLEAR\n         LR    R1,R15                  COPY # TO BLANK\n         SRL   R1,2                    FIND # OF WORDS\n         SLL   R1,1                    TWO BLANKS PER WORD\n         AR    R1,R15                  ADD NUMBER OF HEX CHARS\n         AR    R1,R15                  WHICH IS TWICE THE # OF BYTES\n         LA    R6,50(,R4)              POINT JUST AFTER HEX DATA\n         SR    R6,R1                   FIRST BYTE TO CLEAR\n         BCTR  R1,0                    REDUCE BY 1 FOR EXEXUTE\n         EX    R1,CLEARMVC             CLEAR HEX SIDE\n         LA    R6,69(,R4)              POINT TO TRAILING *\n         SR    R6,R15\n         EX    R15,CLEARMVC            CLEAR EBCDIC AND *\n         MVI   0(R6),C'*'              NOTE END OF EBCDIC DATA\n         B     BLOOPEND                GO CHECK NEXT LINE\n* COME HERE WHEN HI END GOOD AND LOW END MISSING\nHIMIX    L     R15,LOGOOD              LOWEST GOOD ADDR\n         SR    R15,R2                  NUMBER OF BYTES TO CLEAR\n         CH    R15,=H'16'              Total line                  1.1D\n         BNL   NOLINE                  Kill complete line          1.1D\n         LR    R1,R15                  COPY # TO CLEAR\n         SRL   R1,2                    # OF WORDS TO CLEAR\n         SLL   R1,1                    NUMBER OF IMBEDDED BLANKS\n         AR    R1,R15                  ADD # OF HEX CHARS\n         AR    R1,R15\n         BCTR  R1,0                    REDUCE BY 1 FOR MVC\n         LA    R6,12(,R4)              START OF HEX DATA\n         EX    R1,CLEARMVC             AND CLEAR THE HEX DATA\n         LA    R6,52(,R4)              POINT TO FIRST * ON LINE\n         EX    R15,CLEARMVC            CLEAR * AND EBCDIC DATA\n         LA    R6,52(R15,R4)           POINT TO FIRST CLEARED BYTE 1.1D\n         MVI   0(R6),C'*'              AND DROP IN A *\nBLOOPEND LA    R4,80(,R4)              POINT TO NEXT LINE\n         LA    R2,16(,R2)              ADDRESS ON NEXT LINE\n         BCT   R5,BLLOOP               AND SCAN ALL LINES\n         SPACE 2\n*----------------------------------------------------------------------\n*\n*  PUT IN ARROWS TO POINT TO DESIRED DATA\n*\n*----------------------------------------------------------------------\n         SPACE 2\n         LA    R4,OUT1                 ADDR OF FIRST LINE\n         TM    MODEFLAG,MIDDUMP        DOES IT BELONG IN THE MIDDLE\n         BZ    ARRTOP                  BR IF NOT\n         LA    R4,OUT9                 POINT TO MIDDLE LINE\nARRTOP   SR    R1,R1                   ASSUME NO QUADWORD ALIGNMENT\n         TM    MODEFLAG,ALIGN          WAS ASSUMPTION CORRECT\n         BZ    ARRALIGN                BR IF YES, ELSE GET OFFSET\n         LA    R1,15                   MASK FOR LOW 4 BITS\n         NR    R1,R2                   GET BYTE OFFSET FOR ARROW\n* FIRST DO THE EBCDIC SIDE\nARRALIGN LA    R15,51(,R4)             BYTE BEFORE FIRST *\n         EX    R1,MOVEMVC              MOVE THE DATA BACK\n         AR    R15,R1                  ADDR OF LAST BYTE MOVED\n         MVI   1(R15),C'>'             PUT IN THE ARROW\n* NOW MOVE THE HEX SIDE\n         SR    R0,R0                   CLEAR HIGH ORDER BITS\n         SLDL  R0,30                   WHICH WORD IS TO BE MOVED\n         SRL   R1,30                   NUMBER OF BYTES TO BE MOVED\n         LR    R15,R0                  COPY OFFSET OF WORD TO MOVE\n         MH    R15,=H'10'              EACH WORD TAKES UP 10 BYTES\n         LA    R15,10(R4,R15)          POINT IN FRONT OF WORD TO MOVE\n         SLL   R1,R1                   NUMBER OF HEX DIGITS TO MOVE\n         EX    R1,MOVEMVC              MOVE THE DATA BACK\n         AR    R15,R1                  POINT TO PLACE FOR ARROW\n         MVI   1(R15),C'>'             AND PUT IT THERE\n* FALL  THRU TO SHOW THE SCREEN\n         EJECT\n*\n* DISPLAY THE PAGE AND CHECK FOR END REQUEST\n*\nDISPLAY  UNPK  TEMP1(5),CURASID(3)     FORMAT CURRENT ASID\n         MVC   ASIDLN1(4),TEMP1        AND PUT ON SCREEN\n         TR    ASIDLN1(4),HEXTAB\n         MVC   SAVEASID,ASIDLN1        SAVE FORMATTED VERSION\n         MVC   KEYS,KEY1               SETUP PFK\n         MVC   KEYS+80,KEY2                 INFO LINE\n*\nTPUTSCRN DS    0H\n         LA    R0,QDSLNG\n         TPUT  QDSCREEN,(0),FULLSCR MF=(E,QTPUT)\n         XC    INPLINE,INPLINE\n         XC    PFREPLY,PFREPLY\n         TGET  PFREPLY,69,ASIS MF=(E,QTGET)\n         LR    R3,R1                   SAVE INPUT LENGTH\n         CH    R15,=H'12'     IS INPUT LONGER THAN BUFFER?\n         BNE   NOCLEAR        NO. CONTINUE.\n         TCLEARQ INPUT        CLEAR THE QUEUE\nNOCLEAR  DS    0H\n*        MVC   MSGLINE,BLANKS          INDICATE NO ERROR           1.1A\n         LA    R1,PFREPLY+3            POINT AT FIRST BYTE\n         SH    R3,=H'3'                ADJUST LENGTH\n*\n**       HANDLE ASID IF NECESSARY\n*\n         CLC   0(3,R1),=X'1140F9'      IS THIS ASID MODIFICATION\n         BNE   NOASID                  NO SO SKIP\n         LA    R1,3(,R1)               POINT AT FIRST BYTE\n         SH    R3,=H'3'                ADJUST LENGTH\n         LR    R2,R1                   SAVE START ADDRESS\nASIDLOOP CLI   0(R1),X'11'             LOOK FOR START FIELD\n         BE    HAVEASID\n         LA    R1,1(,R1)               BUMP POINTER\n         BCT   R3,ASIDLOOP\nHAVEASID LR    R15,R1                  MOVE POINTER\n         SR    R15,R2                  GET LENGTH\n         BZ    NOASID\n         MVC   ASIDLN1,=CL4' '\n         LA    R4,ASIDLN1+4            GET TO ADDRESS +4\n         SR    R4,R15                      - REAL LENGTH\n         BCTR  R15,0                   GET MACHINE LENGTH\n         EX    R15,MOVERPLY\nNOASID   DS    0H\n         LTR   R3,R3                   ANY DATA LEFT\n         BZ    ENDINP\n         CLC   0(3,R1),=X'11C15C'      CHECK FOR START OF FIELD\n         BNE   ENDINP                  IF NOT HERE THEN SKIP\n         LA    R1,3(,R1)               POINT AT FIRST BYTE\n         SH    R3,=H'3'                ADJUST LENGTH\n         LR    R2,R1                   SAVE START ADDRESS\nRPLYLOOP CLI   0(R1),X'11'             LOOK FOR START FIELD\n         BE    HAVERPLY\n         LA    R1,1(,R1)               BUMP POINTER\n         BCT   R3,RPLYLOOP\nHAVERPLY LR    R15,R1                  MOVE POINTER\n         SR    R15,R2                  GET LENGTH\n         BZ    NOASID\n         LA    R4,INPLINE              GET TO ADDRESS\n         BCTR  R15,0                   GET MACHINE LENGTH\n         EX    R15,MOVERPLY\nENDINP   OC    INPLINE,=CL63' '        MAKE UPPERCASE\n         SPACE 2\n         IC    R4,PFCODE\n         XR    R5,R5\n         CLI   PFCODE,X'7D'      ENTER?\n         BE    ENTER             /YES - TREAT AS ENTER\n         CLI   PFCODE,X'F0'      TEST-REQ/SYS-REQ?\n         BE    ENTER             /YES - TREAT AS ENTER\n         CLI   PFCODE,X'01'      OTHER KIND OF SYS-REQ?\n         BE    ENTER             /YES - TREAT AS ENTER\n         CLI   PFCODE,X'6C'      PA1?\n         BE    ENDIT             /YES - TERMINATE\n         CLI   PFCODE,X'6E'      PA2?\n         BE    TPUTSCRN          /YES - GO RESHOW SCREEN\n         CLI   PFCODE,X'6B'      PA3?  (TCAM GENERATED)\n         BE    TPUTSCRN          /YES - GO RESHOW SCREEN\n         N     R4,=X'0000000F'   EXTRACT PF-KEY NUMBER\n         CH    R4,=H'12'\n         BH    ENTER            \"ENTER\" KEY\n         BCTR  R4,0\n         SLL   R4,2              TIMES SIZE OF AN ENTRY\n         B     PFKEYTAB(R4)\nPFKEYTAB B     HELP                    PF1\n         B     DISPLAY                 PF2\n         B     ENDIT                   PF3    QUIT\n         B     DISPLAY                 PF4\n         B     REPEAT                  PF5    REPEAT COMMAND\n         B     DISPLAY                 PF6\n         B     UP                      PF7    SCROLL UP\n         B     DOWN                    PF8    SCROLL DOWN\n         B     BACK                    PF9    SCROLL BACKWARDS\n         B     FWD                     PF10   SCROLL FORWARDS\n         B     DISPLAY                 PF11\n         B     DISPLAY                 PF12\nMOVERPLY MVC   0(0,R4),0(R2)           **EXECUTED**\n         EJECT\nENTER    CLC   =C'END',INPLINE         SEE IF END TYPED\n         BNE   ISCAN                   IF NOT, GO LOOK AT INPUT\n* CLEAN UP AND GO AWAY\nENDIT    DS    0H\n         LM    R0,R1,CSALEN            GET SP, LEN, AND ADDR\n         LTR   R1,R1                   WAS BUFFER GOTTEN\n         BZ    ENDIT1                  NOPE\n         FREEMAIN R,LV=(0),A=(1)       FREE BUFFER\nENDIT1   DS    0H                      NOT AUTH HANDLING\n*        TM    FLAGS,NOAUTH            ARE WE AUTHORIZED            Joe\n*        BO    ENDIT2                  NOPE                         Joe\n         MODESET MODE=PROB             RESET MODE\nENDIT2   DS    0H\n         STTMPMD OFF                                               1.1C\n         STFSMODE OFF                  RESET FULLSCREEN\n         L     R13,SAVE+4              GET ORIGINAL SAVE AREA\n         FREEMAIN R,LV=WORKLEN,SP=1,A=(R10)\n         RETURN (14,12),RC=0\n* ----------------------------------------------------------------- *\nENDIT0   DS    0H\n         MVC   OUTAREA(80),NOTAUTHM\n         STM   R14,R1,SAVE14T1\n         TPUT  OUTAREA,80\n         LM    R14,R1,SAVE14T1\n         B     ENDIT2\nNOTAUTHM DC CL80'***** THIS PROGRAM MUST BE RUN APF AUTHORIZED *****'\n         EJECT\n*----------------------------------------------------------------------\n*\n* CBHIT  -- CONTROL BLOCK FORMATTING ROUTINE\n* AT ENTRY:\n*              R4 HAS ADDRESS TO DISPLAY (OFFSET 0 - MAIN SEGMENT)\n*              R5 HAS CONTROL BLOCK HEADER ADDRESS\n*\n*----------------------------------------------------------------------\n         SPACE 2\nCBHIT    LH    R2,CURRENT              GET HISTORY TABLE POINTER\n         A     R2,HISTORY              GET ENTRY ADDRESS\n         USING HIST,R2                 SETUP FORMAT OF ENTRY\n         ICM   R6,15,HISTCBSP          LAST SEGMENT DISPLAYED\n         BNZ   CBHIT2                  BR IF A CONTINUING DISPLAY\n         USING CBH,R5                  ADDRESS HEADER BLOCK\n         L     R6,CBHCBSP              ELSE GET FIRST SEG ADDRESS\n         ST    R6,HISTCBSP             AND SAVE FOR LATER\n         ST    R5,HISTCBHP             AND SAVE FOR LATER\n         OI    HISTCBHP,X'80'          NOTE CB FORMAT ROUTINE IN USE\n*   GET BLOCK NAME AND HANDLE ANY SEGMENT INDIRECTION\nCBHIT2   DS    0H\n         USING CBS,R6\n         L     R5,HISTCBHP             POINT TO CB HEADER\n         MVC   MSGLINE+36(8),CBHNAME   MOVE IN CB NAME\n         STCM  R4,15,TEMP2             SAVE ADDRESS OF BLOCK\n         UNPK  TEMP1(9),TEMP2(5)          AND CONVERT\n         TR    TEMP1(8),HEXTAB               TO HEX\n         MVC   MSGLINE+26(8),TEMP1     MOVE IN ADDRESS OF BLOCK\n         DROP  R2,R5\n         CLC   =H'0',CBSILEN           IS THIS SEGMENT INDIRECT\n         BE    CBHIT3                  IF NOT THEN SKIP CODE\n         LH    R0,CBSILEN              GET LENGTH TO FETCH (ALWAYS 4\n         LA    R1,DUMPDATA             WHERE TO PUT IT\n         LH    R2,CBSIOFF              GET INDIRECT OFFSET\n         AR    R2,R4                   GET TRUE MAIN BLOCK ADDRESS\n         BAL   R14,GETSTOR             GET THE INDIRECT WORD\n         B     NOCB                    BR IF NO DATA FETCHED\n         B     NOCB                    BR IF PARTIAL DATA FETCHED\n         L     R4,DUMPDATA             RESET THE ADDR TO DUMD\n         LH    R2,CURRENT\n         A     R2,HISTORY              GET ADDR OF ENTRY\n         ST    R4,HISTSADR-HIST(R2)    SAVE SEGMENT ADDRESS\nCBHIT3   DS    0H\n         LH    R0,CBSDLEN              LENGTH TO FETCH\n         LA    R1,DUMPDATA             TARGET ADDRESS\n         LH    R2,CBSDOFF              OFFSET TO FETCH\n         AR    R2,R4                   ADD START OF CB ADDRESS\n         BAL   R14,GETSTOR             GO FETCH THE DATA\n         B     NOCB                    BR IF NO DATA FETCHED\n         B     NOCB                    BR IF PARTIAL DATA FETCHED\n         LA    R5,OUT1-80              START OF SCREEN\n         LA    R2,DUMPDATA             POINT TO DATA BUFFER\n         SH    R2,CBSDOFF              BACKUP TO VIRTUAL CB ORIGIN\n         LA    R6,CBSLEN(,R6)          POINT AT FIRST CB FIELD\n         USING CBF,R6\nCBLOOP   DS    0H\n         LH    R1,CBFLINE              GET LINE NUMBER\n         MH    R1,=H'80'               TIMES LINE LENGTH\n         AH    R1,CBFCOLM              PLUS THE COLUMN NUMBER\n         AR    R1,R5                   PLUS START OF LINE\n         MVC   0(8,R1),CBFNAME         SET NAME FIELD\n         LA    R1,8(,R1)               SKIP NAME\n         LH    R14,CBFOFFS             GET OFFSET INTO CB\n         AR    R14,R2                  GET ADDRESS IN FETCHED DATA\n         SR    R15,R15                 CLEAR REGISTER\n         IC    R15,CBFDLEN             GET LENGTH OF DATA ITEM\n         LA    R0,80-8                 get max column less label   1.1D\n         SH    R0,CBFCOLM              and starting col number     1.1D\n*   FORMAT CHARACTER AS DISPLAY AND REST AS HEX\n         CLI   CBFTYPE,C'C'            WHAT IS TYPE\n         BNE   CBFLP1                  IF NOT CHAR THEN DO HEX     1.1D\n         CR    R15,R0                  see if data too big         1.1D\n         BNH   *+6                     use actual length           1.1D\n         LR    R15,R0                  truncate data               1.1D\n         BCTR  R15,0                   GET MACHINE LENGTH\n         EX    R15,CBMVC               MOVE IN DATA\n         EX    R15,CBTR                OUTPUT ONLY VALID CHARS      1.1\n         B     CBFEND\nCBFLP1   SRL   R0,1                    convert columns to bytes    1.1D\n         CR    R15,R0                  see if data too big         1.1D\n         BNH   *+6                     use actual length           1.1D\n         LR    R15,R0                  truncate data               1.1D\nCBFLOOP  MVC   TEMP2(1),0(R14)         MOVE IN DATA BYTE\n         UNPK  TEMP1(3),TEMP2(2)\n         TR    TEMP1(2),HEXTAB\n         MVC   0(2,R1),TEMP1           MOVE IN CONVERTED BYTE\n         LA    R1,2(,R1)               BUMP OUTPUT ADDRESS\n         LA    R14,1(,R14)             BUMP INPUT ADDRESS\n         BCT   R15,CBFLOOP             KEEP LOOPINT\nCBFEND   LA    R6,CBFLEN(,R6)          BUMP TO NEW FIELD\n         CLC   0(4,R6),=F'0'           END OF SEGMENT\n         BNE   CBLOOP                  IF NOT THEN KEEP GOING\n         B     DISPLAY                 ALL DONE SO DISPLAY IT\n         DROP  R6\n         SPACE 1\nCBMVC    MVC   0(0,R1),0(R14)          **EXECUTED** MOVE IN DATA\nCBTR     TR    0(0,R1),VALCHAR         **EXECUTED** MAKE VALID      1.1\n         SPACE 2\n*----------------------------------------------------------------------\n*\n*  GET ADDRESS OF CURRENT CONTROL BLOCK SEGMENT\n*     ON EXIT R2 = ADDR OF THIS CONTROL BLOCK SEGMENT\n*\n*----------------------------------------------------------------------\nGETCURAD DS    0H\n         LH    R2,CURRENT              GET HIST TABLE OFFSET\n         A     R2,HISTORY              GET ENTRY\n         USING HIST,R2\n         CLC   =F'0',HISTSADR          IS SEGMENT A SECONDARY SEGMENT\n         BE    GCA1                    NOPE, SO SKIP CODE\n         L     R2,HISTSADR             GET ADDRESS OF BLOCK\n         BR    R14\nGCA1     L     R2,HISTADDR             GET MAIN BLOCK ADDR\n         BR    R14\n         DROP  R2\n         EJECT\n***********************************************************************\n*\n* COMMAND ROUTINES\n*\n         SPACE 2\n*----------------------------------------------------------------------\n*\n* HELP -- DISPLAY HELP INFORMATION\n*\n*----------------------------------------------------------------------\n         SPACE 2\nHELP     DS    0H\n         LA    R1,16*80\n         LR    R3,R1\n         L     R2,=A(HELPMSG)      POINT AT FROM\n         LA    R0,OUT1\n         MVCL  R0,R2\n         B     DISPLAY\n         SPACE 2\n*----------------------------------------------------------------------\n*\n* REFRESH -- REFETCH THE CORE AND REDISPLAY IT\n*\n*----------------------------------------------------------------------\n         SPACE 2\nREFRESH  OI    FLAGS,RFRSH             SET REFRESH FLAG\n         B     FORMAT                  REFORMAT SCREEN\n         SPACE 2\n*----------------------------------------------------------------------\n*\n* OVERLAY  --  MANIPULATE CONTROL BLOCK FORMATTING\n*\n*----------------------------------------------------------------------\n         SPACE 2\nOVERLAY  CLC   =C'NULL',INPLINE+1      SEE IF NO FORMATTING WANTED\n         BE    OVERNULL                BR IF YES\n         L     R5,=V(CBMACS)           GET CB MAP INDEX\n         LTR   R5,R5                   ANY MAPS\n         BZ    OVERNULL                IF NOT TREAT AS NULL OVERLAY\n         USING CBH,R5                  SETUP ADDRESSABILITY\nOVERLOOP CLC   =F'0',CBHNEXT           END OF CONTROL BLOCKS\n         BE    FORMAT                  IF YES, IGNORE COMMAND\n         CLC   INPLINE+1(8),CBHNAME    SEE IF CB MATCH\n         BE    OVERHIT                 BR IF YES\n         L     R5,CBHNEXT              ELSE POINT TO NEXT ENTRY\n         B     OVERLOOP                AND KEEP LOOKING\nOVERHIT  L     R6,CBHCBSP              START SEG ADDR FOR CB FOUND\n         LH    R2,CURRENT              CURRENT HIST TABLE ENTRY OFFSET\n         A     R2,HISTORY              GET ENTRY ADDRESS\n         USING HIST,R2                 SETUP ENTRY FORMAT\n         ST    R5,HISTCBHP             POINT AT HEADER\n         ST    R6,HISTCBSP             POINT AT SEGMENT(FIRST)\n         OI    HISTCBHP,X'80'          MARK AS CB\n         XC    HISTSADR,HISTSADR       CLEAR SEC SEG ADDR\n         B     FORMAT                  GO SHOW IT\n         SPACE 1\nOVERNULL LH    R2,CURRENT              CURRENT HIST TABLE ENTRY OFFSET\n         A     R2,HISTORY              POINT AT CURRENT ENTRY\n         MVC   HISTCBHP,=X'7FFFFFFF'   SUPPRESS CB OVERLAY\n         B     FORMAT                  GO SHOW STORAGE\n         DROP  R5,R2\n         SPACE 2\n*----------------------------------------------------------------------\n*\n* DOWN -- SCROLL DOWN 256 BYTES OR NEXT CTRL BLK SEGMENT\n*\n*----------------------------------------------------------------------\n         SPACE 2\nDOWN     LH    R2,CURRENT              CURRENT HIST TABLE POINTER\n         A     R2,HISTORY              POINT TO HIST TABLE ENTRY\n         USING HIST,R2                 SETUP ENTRY FORMAT\n         TM    HISTCBHP,X'80'          SEE IF THIS IS A CB DISPLAY\n         BO    DOWNCB                  BR IF YES\n         L     R1,HISTADDR             ELSE GET ADDR TO SHOW\n         AH    R1,=H'256'              AND MOVE DOWN ONE SCREEN\n         ST    R1,HISTADDR             AND REPLACE IN HIST TABLE\n         B     FORMAT                  GO DISPLAY IT\nDOWNCB   L     R1,HISTCBSP             GET CB SEGMENT ADDR\n         L     R1,CBSNEXT-CBS(,R1)     GET NEXT SEG ADDR\n         ST    R1,HISTCBSP             AND PUT IN HIST TABLE\n         XC    HISTSADR,HISTSADR       CLEAR SEC SEG ADDR\n         B     FORMAT                  GO SHOW IT\n         DROP  R2\n         SPACE 2\n*----------------------------------------------------------------------\n*\n* UP   -- SCROLL UP   256 BYTES OR PREV CTRL BLK SEGMENT\n*\n*----------------------------------------------------------------------\n         SPACE 2\nUP       LH    R2,CURRENT              CURRENT HIST TABLE POINTER\n         A     R2,HISTORY              POINT TO HIST TABLE ENTRY\n         USING HIST,R2                 SETUP FORMAT OF ENTRY\n         TM    HISTCBHP,X'80'          SEE IF THIS IS A CB DISPLAY\n         BO    UPCB                    BR IF YES\n         L     R1,HISTADDR             ELSE GET ADDR TO SHOW\n         SH    R1,=H'256'              AND MOVE UP ONE SCREEN\n         ST    R1,HISTADDR             AND REPLACE IN HIST TABLE\n         B     FORMAT                  GO DISPLAY IT\nUPCB     L     R1,HISTCBSP             GET CB SEGMENT ADDR\n         L     R1,CBSPREV-CBS(,R1)     GET PREV SEG ADDR\n         ST    R1,HISTCBSP             AND PUT IN HIST TABLE\n         XC    HISTSADR,HISTSADR       CLEAR SEC SEG ADDR\n         B     FORMAT                  GO SHOW IT\n         DROP  R2\n         SPACE 2\n*----------------------------------------------------------------------\n*\n* REPEAT -- REPEAT LAST INPUT LINE\n*\n*----------------------------------------------------------------------\n         SPACE 2\nREPEAT   MVC   INPLINE(52),INPSAVE     COPY SAVED INPUT\n         B     ISCAN2                  AND PROCESS IT\n         SPACE 2\n*----------------------------------------------------------------------\n*\n* LINK -- LINK TO LABELED CONTROL BLOCK FIELD\n*\n*----------------------------------------------------------------------\n         SPACE 2\nLINK     LH    R2,CURRENT              CURRENT HIST TABLE POINTER\n         A     R2,HISTORY              POINT TO HIST TABLE ENTRY\n         USING HIST,R2                 SETUP FORMAT OF ENTRY\n         TM    HISTCBHP,X'80'          SEE IF CB FORMATTING IN USE\n         BO    LINK2                   BR IF YES\nLINKERR  MVC   MSGLINE,LINKMSG         NOTE ERROR IN LINK\n         B     FORMAT                  AND RESHOW SCREEN\nLINK2    L     R3,HISTCBSP             GET CURRENT CB SEG ADDRESS\n         LA    R5,0(,R3)               CLEAR FLAGS AND SETUP FOR COMP\n         USING CBS,R4\nLINK2A   LR    R4,R3                   SAVE THE START OF SEG ADDR\n         LA    R3,CBSLEN(,R3)          POINT PAST SEG HEADER\n         USING CBF,R3\nLINK3    CLC   CBFNAME(4),=F'0'        END OF SEGMENT\n         BE    LINK4\n         CLC   CBFNAME,INPLINE+1       DOES NAME MATCH\n         BE    LINKFND                 IF SO THEN FOUND\n         LA    R3,CBFLEN(,R3)          POINT PAST THIS ONE\n         B     LINK3                   KEEP LOOKING\nLINK4    DS    0H\n         L     R3,CBSNEXT              POINT TO NEXT SEGMENT\n         CR    R3,R5                   ARE WE BACK AT START\n         BNE   LINK2A                  IF NOT KEEP GOING\n         B     LINKERR                 IF NOT THEN ISSUE ERROR\n         DROP  R4,R2\n* A MATCH HAS  BEEN FOUND. FETCH THE  ADDRESS TO LINK TO\nLINKFND  DS    0H\n         SR    R0,R0                   CLEAR FOR IC\n         IC    R0,CBFDLEN              LENGTH OF ITEM  MINUS 1\n         LA    R1,DUMPDATA             ADDR TO PLACE DATA IN\n         BAL   R14,GETCURAD            GET ADDR OF CURRENT SEGMENT\n         AH    R2,CBFOFFS              OFFSET OF ITEM TO FETCH\n         BAL   R14,GETSTOR             FETCH THE  ADDRESS\n         B     LINKERR                 BR IF DATA CANT BE FETCHED\n         B     LINKERR                 BR IF DATA CANT BE FETCHED\n         BAL   R15,FWDSUB              UPDATE HIST TABLE TO NEXT\n         L     R0,DUMPDATA             LOAD ADDRESS THAT WAS FETCHED\n         SR    R15,R15                 NOW ADJUST THE\n         IC    R15,CBFDLEN               FETCHED DATA\n         LA    R1,4                        SO THAT\n         SR    R1,R15                        IT IS RIGHT\n         BNP   LF1                             JUSTIFIED IN\n         SLL   R1,3                              REGISTER IF\n         SRL   R0,0(R1)                            LESS THAN 4\nLF1      DS    0H                                    BYTES\n         LH    R2,CURRENT              NEW HIST TABLE POINTER\n         A     R2,HISTORY              GET ENTRY ADDRESS\n         USING HIST,R2\n         ST    R0,HISTADDR             SAVE NEW ADDRESS\n         XC    HISTCBHP,HISTCBHP          AND\n         XC    HISTCBSP,HISTCBSP            CLEAR\n         XC    HISTSADR,HISTSADR               REST\n         B     FORMAT                  GO FORMAT THE NEW CB\n         DROP  R3,R2\n         SPACE 2\n*----------------------------------------------------------------------\n*\n*  SET INDIRECT FLAG\n*\n*----------------------------------------------------------------------\n         SPACE 2\nINDIR64  OI    FLAGS,IND64             SET FLAG\nINDIR31  OI    FLAGS,IND31             SET FLAG\nINDIR    OI    FLAGS,INDFLAG           SET FLAG\n         LA    R3,1(,R3)               UPDATE SCAN POINTER\n         CLI   INPLINE+1,C' '          USE CURRENT ADDRESS\n         BNE   NUMSCAN                 IF NO, GO SCAN INPUT ADDRESS\n         BAL   R14,GETCURAD\n         LR    R4,R2                   MOVE TO RIGHT REGISTER\n         B     ENDNUM\n         SPACE 2\n***********************************************************************\n*\n*  ESTABLISH SCREEN MODE\n*\n***********************************************************************\n         SPACE 2\nMODE     CLC   =C'1 ',INPLINE+1        MODE ONE TEST\n         BE    MODE1                   BR IF YES\n         CLC   =C'0 ',INPLINE+1        CHECK FOR MODE ZERO         1.1D\n         BNE   INVAL                   IF NOT EITHER, INVALID\n         NI    MODEFLAG,255-MIDDUMP    MODE 0 MEANS BACKUP 0\n         B     FORMAT\nMODE1    OI    MODEFLAG,MIDDUMP        MODE 1 MEANS BACK UP 7 LINES\n         B     FORMAT\nINVAL    MVC   MSGLINE,MODEMSG\n         B     FORMAT\nBADADDR  MVC   MSGLINE,INVADDR\n         B     TPUTSCRN\nPRGCHK   MVC   MSGLINE,PROGCHK\n         B     FORMAT\n         SPACE 2\n***********************************************************************\n*\n*  MANIPULATE HISTORY TABLE\n*\n***********************************************************************\n         SPACE 2\nFWD      BAL   R15,FWDSUB              FORWARD 1 IN HIST TABLE\n         B     FORMAT\n         SPACE\nFWDSUB   LH    R1,CURRENT              CURRENT ENTRY INDEX\n         LA    R1,HISTLEN(,R1)\n         CH    R1,=AL2(50*HISTLEN)     SEE IF WRAP NEEDED\n         BL    FWDEND                  BR IF NOT\n         SR    R1,R1                   WRAP TO BEGINNING\nFWDEND   STH   R1,CURRENT              STORE NEW OFFSET\n         BR    R15                     RETURN TO CALLER\n         SPACE 1\nBACK     LH    R1,CURRENT\n         SH    R1,=AL2(HISTLEN)        BACK UP ONE ENTRU\n         BNM   BACKEND                 BR IF NO BACKWARD WRAP\n         LA    R1,49*HISTLEN           ELSE GO TO END OF TABLE\nBACKEND  STH   R1,CURRENT              SAVE RESULT\n         B     FORMAT\n         SPACE 2\n***********************************************************************\n*\n*   ADD ENTRY TO SYMBOL TABLE\n*\n***********************************************************************\n         SPACE 2\nDEFINE   LA    R15,50                  NUMBER OF TABLE ENTRIES\n         LA    R2,NAMES                START OF TABLE\nDEFLOOP1 CLI   0(R2),X'0'              SEE IF UNUSED ENTRY\n         BE    NSPACE                  BR IF SPACE FOUND\n         LA    R2,12(,R2)              NEXT ENTRY ADDR\n         BCT   R15,DEFLOOP1            TRY ALL ENTRIES\n         MVC   MSGLINE,SYMFULL         TABLE IS FULL\n         B     FORMAT\nNSPACE   LA    R15,9                   MAX LENGTH +1\n         LA    R0,INPLINE+1            ADDR OF FIRST BYTE\n         LR    R1,R0                   COPY SYMBOL ADDR\nDEFLOOP2 CLI   0(R1),C' '              SEE IF END OF SYM\n         BE    DEFEND                  BR IF YES\n         LA    R1,1(,R1)               POINT TO NEXT BYTE\n         BCT   R15,DEFLOOP2            CONTINUE FOR 9 BYTES\nDEFBAD   MVC   MSGLINE,DEFMSG          SYMBOL TOO LONG OR TOO SHORT\n         B     FORMAT2                 DISPLAY WITH CURSOR AT ERROR\nDEFEND   SR    R1,R0                   SYMBOL LENGTH\n         BZ    DEFBAD                  NULL SYMBOL ILLEGAL\n         BCTR  R1,R0                   FOR EXECUTE\n         MVC   0(8,R2),=CL8' '         CLEAR TABLE ENTRY\n         EX    R1,DEFMOVE              MOVE SYMBOL\n         LH    R1,CURRENT              GET CURRENT ADDRESS\n         A     R1,HISTORY\n         L     R1,HISTADDR-HIST(,R1)\n         ST    R1,8(,R2)               STORE WITH SYMBOL\n         B     FORMAT\nDEFMOVE  MVC   0(0,R2),INPLINE+1       EXECUTED TO MOVE SYMBOL\n         SPACE 2\n***********************************************************************\n*\n*  SCAN THE ADDRESS EXPRESSION\n* REGISTER USAGE\n* R2 LAST NUMBER SCANNED\n* R3 SCAN POINTER\n* R4 CURRENT OUTPUT VALUE\n* R5 LAST OPERATOR SCANNED\n*\n***********************************************************************\n         SPACE 2\nNUMSCAN  DS    0H\n         BAL   R14,GETCURAD            CURRENT ENTRY IS DEFAULT\n         LR    R4,R2                   CURRENT ENTRY IS DEFAULT\n         LA    R5,0                    ASSUME DEFAULT TO BE TAKEN\n         CLI   0(R3),C'+'              SEE IF PREFIX PLUS\n         BNE   NOTPLUS                 BR IF NOT\n         LA    R5,2                    INDICATE PLUS OPERATOR\n         B     NUMOP                   GO TO ADV POINTER\nNOTPLUS  CLI   0(R3),C'-'              IS IT PREFIX MINUS\n         BNE   NUMLOOP                 BR IF NOT, USE DEFAULT AS LOAD\n         LA    R5,4                    INDICATE MINUS OPERATOR\nNUMOP    LA    R3,1(,R3)               POINT TO NEXT INPUT BYTE\nNUMLOOP  CLI   0(R3),C','              SEE IF NAME INDICATED\n         BE    NAMESCAN                BR IF YES\n         TRT   0(9,R3),NUMTAB          SEARCH FOR DELIMITER\n         LR    R6,R3                   SAVE START OF NUMBER\n         BC    8,BADSTUFF              BR IF INPUT TOO LONG\n         LR    R3,R1                   UPDATE SCAN POINTER\n         SR    R1,R6                   GET LENGTH OF INPUT\n         BZ    BADSTUFF                BR IF ZERO INPUT\n         MVC   TEMP1(8),=CL8' '        CLEAR TEMP AREA\n         LA    R15,TEMP1+8             RIGHT JUSTIFY INPUT\n         SR    R15,R1                  POINT TO RIGHT SPOT IN TEMP AREA\n         BCTR  R1,0                    PREPARE FOR EX\n         EX    R1,HEXMOVE              MOVE INPUT RIGHT JUSTIFIED\n         TR    TEMP1(8),HEXTAB         TRANSLATE TO HEX\n         PACK  TEMP2(5),TEMP1(9)       CONVERT HEX TO BINARY\n         ICM   R2,15,TEMP2             NEW DISPLAY ADDRESS\n         L     R8,CSAWORK              Get Csa Address\n         USING WORK,R8\n         ST    R2,START_ADDR           Starting Address\n         MVC   LEN,=F'100'             ** Temp **\nNUMDELIM EX    0,OPER(R5)              EXECUTE PREVIOUS OPERATOR\n         CLI   0(R3),C' '              IS DELIM A BLANK\n         BE    ENDNUM                  IF YES, END SCAN\n         LA    R5,2                    PLUS OPERATOR CODE\n         CLI   0(R3),C'+'              IS OPER L PLUS\n         BE    NUMOP                   BR IF YES TO CONTINUE SAAN\n         LA    R5,4                    MINUS CODE\n         CLI   0(R3),C'-'              IS OPER MINUS\n         BE    NUMOP                   BR IF YES\n         MVC   MSGLINE,INVALOP         ELSE BAD DELIMITER\n         B     FORMAT2                 DISPLAY WITH CURSOR AT ERROR\nENDNUM   TM    FLAGS,INDFLAG           IS THIS AN INDIRECT REQ\n         BZ    NOTIND                  BR IF NOT\n         TM    FLAGS,IND31             DO WE WANT 31 BIT INDIRECT{\n         BO    *+8                     SKIP CLEAR IF YES\n         ICM   R4,8,=X'00'             CLEAR TOP BYTE\n         LR    R2,R4                   SET ADDR TO GET FROM\n         LA    R0,4                    NUMBER OF BYTES TO GET\n         LA    R1,DUMPDATA             WHERE TO PUT IT\n         BAL   R14,GETSTOR             DO MEMORY FETCH\n         B     BADIND                  NONE GOT\n         B     BADIND                  SOME BUT NOT ALL GOT\n         L     R4,DUMPDATA             DO THE INDIRECT\n* --->\n         TM    FLAGS,AMOD64   BIGGER ADDRESS THAN 8 HEX BYTES?\n         BO    KEEPHIG        DON'T NULLIFY BIT 0 OF 32\n         N     R4,=X'7FFFFFFF'         TURN OFF TOP BIT ALWAYS\nKEEPHIG  DS    0H\n* --->\nNOTIND   BAL   R15,FWDSUB              UPDATE HISTORY POINTR\n         LH    R2,CURRENT              NEW HIST TABLE POINTER\n         A     R2,HISTORY              GET ENTRY ADDRESS\n         USING HIST,R2\n         ST    R4,HISTADDR             SAVE NEW ADDRESS\n         XC    HISTCBHP,HISTCBHP          AND\n         XC    HISTCBSP,HISTCBSP            CLEAR\n         XC    HISTSADR,HISTSADR               REST\n         B     FORMAT\n         DROP  R2\nBADIND   MVC   MSGLINE,BADIMSG         MOVE IN MESSAGE\n         B     FORMAT                  GO AND REDISPLAY\n         SPACE 2\n* SCAN INPUT FOR A NAME IN THE SYMBOL TABLE\nNAMESCAN LA    R3,1(,R3)               SKIP OVER COMMA\n         LR    R1,R3                   COPY INPUT POINTER\n         LA    R15,9                   MAX LENGTH +1\nNAMELOOP DS    0H\n* --- >\n         C     R15,=F'8'               MORE THAN 9 CHARACTERS?\n         BH    FLAGSMAL                NO. NOT 64-BIT ADDRESS.\n         OI    FLAGS,AMOD64            SHOW WE NEED HIGHER ADDRESS\nFLAGSMAL DS    0H\n* --- >\n         CLI   0(R1),C'A'              SEE IF VALID CHAR\n         BL    NAMEEND                 BR IF NOT, DELIM FOUND\n         LA    R1,1(,R1)               POINT TO NEXT BYTE\n         BCT   R15,NAMELOOP            ALLOW EIGHT BYTES PLUS DELIM\nNAMEBAD  MVC   MSGLINE,NAMEMSG         NULL NAME OR NAME TOO LONG\n         B     FORMAT2                 DISPLAY WITH CURSOR AT ERROR\nNAMEEND  SR    R1,R3                   FIND LENGTH\n         BZ    BADSTUFF                BR IF TOO SHORT\n         MVC   TEMP1(8),=CL8' '        CLEA\u00a2  WORK AREA\n         BCTR  R1,0                    SET UP FOR EX\n         EX    R1,NAMEMOVE             MOVE TO WORK AREA, BLANK PAD\n         LA    R3,1(R3,R1)             UPDATE POINTER\n         LA    R15,50                  ENTRIES IN SYM TABLE\n         LA    R1,NAMES                START OF SYM TABLE\nNAMELP2  CLC   TEMP1(8),0(R1)          SEE IF NAME IN TABLE\n         BE    NAMEFIND                BR IF YES\n         LA    R1,12(,R1)              POINT TO NEXT ENTRY\n         BCT   R15,NAMELP2             BR IF ANY ENTRIES LEFT\n         B     NAMEBAD                 BR IF NONE LEFT, UNDEFUNED SYM\nNAMEFIND L     R2,8(,R1)               GET SYMBOL VALUE\n         B     NUMDELIM                USE IN EXPRESSION\n*  THESE INSTRUCTIONS ARE THE OBJECT OF AN EXECUTE\nOPER     LR    R4,R2                   USE HIST TABLE AS DEFAULT INPUT\n         AR    R4,R2                   PLUS OPERATOR\n         SR    R4,R2                   MINUS OPERATOR\nHEXMOVE  MVC   0(0,R15),0(R6)          RIGHT JUSTIFY INPUT DATA\nNAMEMOVE MVC   TEMP1(1),0(R3)          PAD NAME WITH BLANKS BY MOVING\n         SPACE\nBADSTUFF MVC   MSGLINE,ERRMSG          NOTE BAD INPUT\n         B     FORMAT2                 DISPLAY WITH CURSOR AT ERROR\n         SPACE 2\n         SPACE 2\n*----------------------------------------------------------------------\n*\n* ERASE  --  CLEAR THE SCREEN BUFFER\n*\n*----------------------------------------------------------------------\n         SPACE 2\nERASE    SAVE  (2,5)                   NEED SOME WORK REGS\n         LA    R2,OUT1                 START OF AREA TO CLEAR\n         LA    R3,80*16                LENGTH TO CLEAR\n         LA    R5,C' '                 FILL CHAR\n         SLL   R5,24                   MAKE PAD BYTE AND CLEAR SOURCE\n         MVCL  R2,R4                   PROPAGATE BLANKS\n         RETURN (2,5)                  RESTORE REGS AND RETURN\n         EJECT\n* EXECUTED INSTRUCTIONS AND CONSTANTS\nCLEARMVC MVC   0(0,R6),BLANKS          CLEAR SOME SPACE\nMOVEMVC  MVC   0(0,R15),1(R15)         MOVE DATA BACKWARDS\n***********************************************************************\n*\n*\n*        FETCH SOME STORAGE\n*\n*              R0  =  LENGTH TO FETCH <=4096 (MAXFETCH)\n*              R1  => WHERE TO PUT IT\n*              R2  => WHERE TO GET IT FROM\n*\n*\n***********************************************************************\nGETSTOR  SAVE  (14,8)                  SAVE REGS\n*        MODESET KEY=ZERO\n         L     R8,CSAWORK              POINT TO CSA AREA            1.1\n         USING WORK,R8                 SETUP ADDRESSABILITY         1.1\n         MVI   MERRCD,0                INDICATE NO ERROR ON FETCH   1.1\n         LA    R2,0(0,R2)              clear top bit               1.1D\n         CL    R0,=A(MAXFETCH)         Max fetchable size          1.1D\n         BL    *+8                     Requested ok                1.1D\n         L     R0,=A(MAXFETCH)         Force smaller               1.1D\n*\n*        CHECK IF DATA IS IN BUFFER\n*\n         CLC   CSAASID,CURASID         WANT SAME ASID\n         BNE   GETMORE                 NOPE\n         C     R2,CSASTAR              CHECK FOR BEGINNING\n         BL    GETMORE\n         LR    R15,R0                  GET LENGTH\n         AR    R15,R2                  GET END ADDRESS\n         C     R15,CSAEND              CHECK FOR END\n         BH    GETMORE                 NOPE NOT IN BUFFER\n         TM    FLAGS,RFRSH             IS IT REFRESH REQUEST\n         BO    GETMORE                 REGET THE CORE\nMOVEBUF  L     R15,CSASTAR             GET VIRT ADDR OF BUFFER\n         SR    R2,R15                  GET DISPLACEMENT IN BUFFER\n         A     R2,CSABUF               POINT TO BUFFER\n         LR    R3,R0                   MOVE LENGTH\n         LR    R0,R1                   SET \"TO\" ADDR\n         LR    R1,R3                   SET LENGTH\n         MVCL  R0,R2\n         LM    R14,R8,12(R13)          RESTORE REGS                 1.1\n         B     8(R14)                  RETURN ALL GOTTEN\nGETMORE  DS    0H\n         MVC   LENGTH,=F'2048'         Initial fetch is half page  1.1C\n         C     R0,LENGTH               Is req for more than default1.1D\n         BNH   *+8                     No  so skip                 1.1D\n         ST    R0,LENGTH               Set first request for actual1.1D\n         ST    R2,ADDR                 SAVE ADDR TO GET CORE FROM  1.1C\n         ST    R2,CSASTAR              SET CSA VIRT BUFFER ADDR    1.1C\n         NI    FLAGS,255-REFETCH       inidicate first fetch       1.1C\nGETM2    DS    0H                                                  1.1C\n         MVI   MERRCD,0                INDICATE NO ERROR ON FETCH  1.1C\n         NI    FLAGS,255-RFRSH         TURN OFF FLAG\n         MVC   CSAASID,CURASID         SET ASID OF CSABUFFER CONTENTS\n         MVI   FLAG1,0                 CLEAR FLAGS\n         MVI   FLAG2,0\n         CLC   CURASID,MYASID          ARE WE IN THIS ADDR SPACE\n         BNE   DOSRB                   IF NOT USE SRB\n*\n*        INVOKE SRB CODE AS SUBROUTINE\n*\n         OI    FLAG1,FG1SUBR           FLAG AS SUBROUTINE\n         LA    R2,DMYPRMS              SETUP DUMMY FRR PARMS\n*        TM    FLAGS,NOAUTH            ARE WE AUTHORIZIED          1Joe\n*        BO    DOSUB1                  NO SO SKIP                  1Joe\n         MODESET KEY=ZERO              GET TO KEY ZERO             1.1E\n         SPKA  0                                                    Joe\nDOSUB1   DS    0H                                                  1.1E\n         XC    DMYPRMS,DMYPRMS\n         LR    R1,R8                   SETUP PARM REGISTER\n         LA    R15,D#SRBCD             SETUP ENTRY REGISTER\n         LA    R14,GOTBKSUB            SETUP RETURN REGISTER       1.1E\n         OI    FLAGS,GETINPG           FLAG GETSTOR IN PROGRESS\n         BR    R15                     GO TO IT\n         BO    GOTBACK                 NO SO SKIP                  1.1E\nGOTBKSUB DS    0H                                                   Joe\n*        MODESET KEY=NZERO             GET TO TCB KEY              1.1E\n         B     GOTBACK                 CONTINUE                    1.1E\n*\n*        IF AUTHORIZED FOR SRB MODE ...\n*\nDOSRB    DS    0H                                                   Joe\n*OSRB    TM    FLAGS,NOAUTH            ARE WE AUTHORIZED            Joe\n*        BO    FAIL2                   NOPE                         Joe\n*\n*        VALIDATE ASID ...\n*\n         L     R2,CVTPTR               POINT TO CVT\n         LH    R1,CSAASID              GET ASID\n         L     R2,CVTASVT-CVTMAP(,R2)  POINT TO ASVT\n         USING ASVT,R2                 SETUP ADDRESSABILITY\n         C     R1,ASVTMAXU             IS IT TOO BIG\n         BH    FAIL3                   SET INVALID ASID\n         SLL   R1,2                    ASID*4\n         LA    R1,ASVTENTY-4(R1)       POINT AT DESIRED ENTRY\n*        MVC   TOASCB,0(R1)            SAVE ASCB ADDR\n         L     R2,0(,R1)                GET ASCB ADDRESS\n         L     R2,ASCBASSB-ASCB(,R2)   Get Assb\n         MVC   TARGETSTOKN,ASSBSTKN-ASSB(R2)\n         TM    TOASCB,ASVTAVAL         IS THIS ASCB EXISTANT\n*        BO    FAIL3                   NOPE\n         LA    R3,SRBAREA     POINT AT THE SRB\n         DROP  R2\n         L     R2,TOASCB               GET ASCB ADDR\n         USING ASCB,R2                 SETUP ADDRESSABILITY\n         TM    ASCBRCTF,ASCBOUT        IS ASCB SWPPED OUT\n*        BO    FAIL3                   YES SO DONOT TRY TO TOUCH IT\n         DROP  R2\n*\n*        INITIALIZE THE SRB AND INVOKE AS SRB\n*\n         TM    FLAGS,AMOD64   BIGGER ADDRESS THAN 8 HEX BYTES?\n         BO    KEEPHIGH       DON'T NULLIFY BIT 0 OF 32\n*        N     R0,=X'80000000'  LEAV ONLY ADDRESSING MODE      XA   1.1\nKEEPHIGH DS    0H\n         XC    ECB,ECB                 CLEAR THE ECBS FOR THE WAITLIST\n         XC    ECB2,ECB2\n         LA    R0,ECB\n         LA    R1,ECB2\n         STM   R0,R1,ECBLIST\n         MVI   ECBLIST+4,X'80'\n*\n*        NOW ISSUE TIMER INCASE SRB NEVER POSTS US\n*\n*        STIMER REAL,D#STX,BINTVL==A(300)  WAIT 3 SECONDS\n         MODESET KEY=ZERO\n         SPKA  0                                                    Joe\n         LA    R3,SRBCCD      POINT AT SRB CODE IN CSA         XA   1.1\n         ST    R3,SRB_EPA\n         LA    R5,RECOVERY-D#SRBCD(,R3)\n         ST    R5,FRR_EPA\n         L     R2,USERSTOR                   Get Storage Key\n         SLL   R2,4\n         ST    R2,USERSTOR\n         LA    R2,D#RMTR-D#SRBCD(,R3)  GET RESOURCE MGR TERMINATION\n         ST    R2,RTM_EPA\n         ST    R8,WORK_EPA\n*\n         IEAMSCHD EPADDR=SRB_EPA,                                      X\n               ENV=STOKEN,                                             X\n               TARGETSTOKEN=TARGETSTOKN,                               X\n               PRIORITY=GLOBAL,                                        X\n               FRRADDR=FRR_EPA,                                        X\n               KEYVALUE=INVOKERKEY,                                    X\n               RMTRADDR=RTM_EPA,                                       X\n               PARM=WORK_EPA,                                          X\n               SYNCH=YES\n*\n*        MODESET KEY=NZERO\n*\n*        WAIT  ECBLIST=ECBLIST\n*        WAIT  ECB=ECB                                              Joe\n*        TTIMER CANCEL\n*\n*        WE ARE BACK FROM EITHER TIMER OR SRB OR SUB\n*\nGOTBACK  L     R8,CSAWORK              POINT AT CSA AREA\n         NI    FLAGS,255-GETINPG       TURN OFF GET IN PROGRESS\n         TM    FLAG2,FG2ADDR\n         BO    BADADDR\n         TM    FLAG2,FG2PCK\n         BO    PRGCHK\n         TM    FLAG1,FG1SUBR           IS THIS A SUB CALL\n         BO    GOTBK2                  IF SO IGNORE SOME ERRORS\n         TM    FLAG1,FG1SRDN           DID SRB TERMINATE GOOD\n         BZ    FAIL                    NOPE SO ERROR MSG\n         TM    FLAG2,FG2PSTR+FG2PURG+FG2ERRR AN ERRORS\n         BNZ   FAIL                    IF SO ERROR MESSAGE\nGOTBK2   DS    0H\n*\n*        NOW MOVE INFO OUT OF CSA BUFFER\n*\n         L     R2,12+12(,R13)          GET ORIG R1 INTO R2 (DEST ADDR)\n         L     R3,12+8(,R13)           GET DESIRED LENGTH\n         L     R4,CSABUF               POINT TO BUFFER\n         L     R5,LENGTH               GET ACTUAL LENGTH MOVED\n         LTR   R5,R5                   Did any memory get back     1.1C\n         BNZ   GOTBK4                  If so then use it           1.1C\n         C     R3,=F'2048'             Was original req >= default 1.1C\n         BNL   GOTBK4                  If so then cant get it      1.1C\n         TM    FLAGS,REFETCH           Q. Is this first or sec ent 1.1C\n         BO    GOTBK4                  A. Second, return no data   1.1C\n         OI    FLAGS,REFETCH           First entry so indicate     1.1C\n         ST    R3,LENGTH               Retry with orig req         1.1C\n         B     GETM2                                               1.1C\nGOTBK4   DS    0H                                                  1.1C\n         NI    FLAGS,255-REFETCH       reset flag before return    1.1C\n*\n*        NOTE THAT ORIG(R2) IS EFFECTIVELY AT R4\n*        FIRST BYTE DESIRED IS FIRST BYTE IN BUFFER\n*\n         MVCL  R2,R4                   MOVE IN CORE\n         L     R2,CSASTAR              GET START LOC\n         A     R2,LENGTH               PLUS LENGTH MOVED\n         ST    R2,CSAEND               SET CORRECT END ADDR\n         MVC   LOGOOD,CSASTAR          SET LOW RANGE DISPLAYABLE\n         MVC   HIGOOD,CSAEND           AND HIGH RANGE\n         MVC   12+12(4,R13),LENGTH     SET GOTTEN LENGTH\n*                                                                   1.1\n*        SET MESSAGE LINE TO INDICATE HOW SUCCESSFUL                1.1\n*        THE MEMORY FETCH WAS                                       1.1\n*                                                                   1.1\n         CLI   MERRCD,4                IS THIS PROTECTION ERROR    1.1A\n         BNE   GOTBK3A                 NO SO CHECK OTHERS          1.1A\n         MVC   MSGLINE,PROT            MOVE IN PROTECTION MSG      1.1A\n         B     GOTBK3                  ERROR SET                   1.1A\nGOTBK3A  DS    0H                                                  1.1A\n         CLI   MERRCD,X'11'            IS THIS A PAGE FAULT        1.1A\n         BE    GOTBK3B                 YES                         1.1A\n         CLI   MERRCD,X'10'            IS THIS A SEGMENT FAULT     1.1A\n         BNE   GOTBK3                  NO                          1.1A\nGOTBK3B  MVC   MSGLINE,NONEX           SET PAGE FAULT ERROR        1.1A\nGOTBK3   DS    0H                                                   1.1\n         LM    R14,R8,12(R13)          RESTORE REGS\n         LTR   R1,R1                   ANY LENGTH GOTTEN\n         BZR   R14                     IF NOT THEN EXIT +0\n         CR    R0,R1                   ALL DESIRED GOTTEN\n         BH    4(R14)                  IF NOT ALL THEN +4\n         B     8(R14)                  ALL DESIRED GOTTEN THEN +8\n*\n*        IF ANY ERRORS GIVE ERROR MSG AND RETURN +0\n*\nFAIL     DS    0H\n         DC    H'0'\n         MVC   MSGLINE,SRBMSG          MOVE IN MESSAGE\n         MVC   CURRENT+2(2),FLAG1\n         B     FAILALL                 GO TO COMMON ROUTINE\n*\n*        IF NOT AUTHORIZED TO DISPLAY OTHER ASIDS GIVE MSG AND RESET\n*\nFAIL2    DS    0H\n         MVC   MSGLINE,AUTHMSG         MOVE IN MESSAGE\n         B     FAILALL                 GO TO COMMON ROUTINE\n*\n*        IF ASID IS NOT VALID OR SWAPPED OUT GIVE MSG AND RESET\n*\nFAIL3    DS    0H\n         MVC   MSGLINE,BDASMSG         MOVE IN MESSAGE\nFAILALL  DS    0H                      COMMON FAILURE ROUTINE\n         MVC   CSASTAR,=D'0'           CLEAR THE START\n         MVC   CSAEND,=D'0'              AND END ADDR\n         MVC   CSAASID,=H'0'               AND THE ASID\n         MVC   CURASID,MYASID          RESET ASID AVAIL\n         RETURN (14,8)\nKEY0     DC    X'00'\n*\n*        STIMER EXIT ROUTINE\n*        ITS PURPOSE IS TO POST THE ECB AT ECB2 AND WAKE UP THE\n*        LOOK PROCESSOR IF THE SRB FAILS.  TO DO THIS WE MUST\n*        FIND THE ADDRESS OF THE ECB WHICH IS SAVED IN R3 OF\n*        THE RB ABOVE THE WAIT.  IN THAT RB, R2 IS SET TO 'ABCD'.\n*\n         USING *,R12\nD#STX    SAVE  (14,12)                 SAVE REGISTERS\n         LR    R12,R15                 SET BASE REG\n         L     R3,CVTPTR               POINT AT CVT\n         L     R3,0(,R3)               POINT AT TCB WORDS\n         L     R3,0(,R3)               POINT AT MY TCB\n         L     R3,0(,R3)               POINT AT MY RB\n         USING RBBASIC,R3\nD#STX1   DS    0H                      NOW LOOK FOR KEY IN REG2\n         CLC   RBGRS2,=C'ABCD'         IS THE KEY HERE\n         BE    D#STX2                  YES\n         TM    XSTAB2,RBTCBNXT         TEST TCB FLAG\n         BO    D#STX3                  IF NOT FOUND PROPER RB\n         L     R3,RBLINK               POINT AT PREVIOUS RB\n         B     D#STX1\nD#STX2   L     R2,RBGRS3               GET ADDR OF ECB TO POST\n         POST  (R2)                    WAKE UP LOOK\n         RETURN (14,12)\n*\n*        IF WE CANT FIND THE RB THEN DUMP\n*\nD#STX3   DC    H'0'\n         DROP  R12,R3\n         LTORG\n         TITLE 'LOOK --  STORAGE ALTER/DISPLAY - SRB MODE CODE'\n         DROP  R9\nD#SRBCD  DS    0D\n*\n*        THIS CODE PERFORMS THE FOLLOWING FUNCTIONS\n*              1 ESTABLISHES AN FRR FOR ERROR RECOVERY\n*              2 VERIFIES THAT THE ADDRESSES THAT ARE NEEDED DO\n*                EXIST.\n*              3 PERFORM THE MODIFICATION IF ALLOW AND NECESSARY\n*              4 SAVE THE PROPER CORE FOR DUMPING.\n*              5 CROSS-MEMORY POST THE MAIN COMMAND PROCESSOR\n*\n         USING WORK,R8\n         USING D#SRBCD,R7\n         LR    R7,R15         SET THE BASE REGISTER\n         USING PSA,0\n         LR    R8,R1          SET THE MAIN PARM DSECT\n*        ST    R2,FRRPRMS\n         USING PSA,0\n         CLC   PSATOLD,=F'0'\n         BNE   IS_SUB\n         ST    R8,0(R2)        Save work area\nIS_SUB   DS    0H\n         ST    R14,ASRBRTN    SAVE RETURN ADDR\n*        L     R2,FRRPRMS     ACCESS THE 6 WORK PARM AREA\n*        STM   R7,R8,0(R2)    SAVE BASE AND WORK REGS\n*\n*        MOVE MEMORY\n*\n         L     R2,ADDR                 SET START ADDR\n         LA    R0,BUF                  POINT AT BUFFER\n         L     R1,LENGTH               GET DESIRED LENGTH\n         LR    R3,R1                   SET LENGTH\n         OI    FLAG1,FG1MOVE           INDICATE IN MOVE\n         MVCL  R0,R2                   MOVE IN CORE\n         NI    FLAG1,255-FG1MOVE       NOTE NOT IN MOVE\n*\n*        NOW WE TERMINATE PROCESSING BY DOING A CROSS\n*        MEMORY POST IF NOT IN SUBROUTINE MODE\n*\nFRRPOST  TM    FLAG1,FG1SUBR  IS THIS SUBROUTINE MODE\n         BO    D#EXIT         IF SO THEN EXIT\n         L     R10,=A(X'40000000') SET CODE FOR POST\n         LR    R9,R8          SAVE WORK POINTER IN SAFE REG\n         LA    R11,ECB        ADDR OF ECB TO POST\n         ICM   R11,8,=X'80'   FLAG AS XMPOST\n         LA    R12,D#POSTR    SET POST ERROR RETURN\n         L     R13,MYASCB     ASCB TO POST\n         L     R15,CVTPTR     POINT AT CVT\n         L     R15,CVT0PT01-CVTMAP(R15)    GET POST ENTRY POINTR\n         BALR  R14,R15        GO DO POST\n         DROP  R7             KILL MAIN ADDRESS\n         USING *,R14          SET TEMP BASE\nD#PRTN   LR    R8,R9          RESET BASE OF WORK\n         SL    R14,=A(D#PRTN-D#SRBCD)  NOW HAVE CORRECTED BASE\n         LR    R7,R14         SET TO PROPER REG\n         DROP  R14\n         USING D#SRBCD,R7     RESET MAIN BASE\n         OI    FLAG1,FG1SRDN  FLAG SRB AS COMPLETED\nD#EXIT   L     R14,ASRBRTN    RESTORE RETURN ADDR\n         BR    R14            EXIT\n         SPACE 5\n*\n*        POST ERROR ROUTINE  .. FLAG ERROR AND LET TIMER\n*        WAKE UP TASK\n*\nD#POSTR  LR    R8,R9          RESET WORK BASE\n         OI    FLAG2,FG2PSTR  FLAG POST ERROR\n         BR    R14            RETURN TO D#PRTN\n         TITLE 'LOOK --  Common Recovery Routine............'\nRECOVERY DS    0D\n***********************************************************************\n*\n*          Common Recovery Routine\n*\n***********************************************************************\n         SPACE 2\n         DROP  R9,R11\n         USING *,R15               SET TEMP BASE\n         C     R0,=F'12'\n         BER   R14                 SKIP IF NOT SDWA\n         DROP  R10\n         LR    R4,R1                Save R1\n         USING SDWA,R1\n         L     R1,SDWAXPAD          Get Record Able Area\n         DROP  R1\n         USING SDWAPTRS,R1\n         L     R1,SDWASRVP\n         DROP  R1\n         USING SDWARC1,R1\n         CLI   SDWATYPE,SDWATFRR   Is This a FRR\n         BNE   IS_ESTAE            No Must Be Is An Estae\n         L     R2,0(,R2)           Address of 24 byte area\nIS_ESTAE DS    0H\n         LR    R8,R2\n         ST    R14,RECOVRET\n         USING SDWA,R4             SAVE ADDR\n         LR    R12,R15             SAVE BASE REGISTER\n         DROP  R15\n         USING RECOVERY,R12\n*        TM    FLAGS,GETINPG           IS A GETSTOR IN PROGRESS\n*        BZ    SPIEOTR                 NOPE OTHER ERROR\n*        L     R8,CSAWORK          SETUP REG 8\n         USING WORK,R8                 IF FROM GETSTOR THEN R8 POINTS\n*                                      TO WORK\n*        TM    FLAG1,FG1MOVE           ARE WE IN MOVE INSTR\n*        BZ    SPIEOTR                 NOPE\n         MVC   MERRCD,SDWAICD1         SAVE INT CODE                1.1\n         XR    R6,R6                   CLear R6\n         ICM   R6,B'0011',SDWACMPC\n         SRL   R6,4                    Shift Over\n         STCM  R6,B'0011',ABEND_CODE\n         CLC   ABEND_CODE,=X'00C4'     Soc4\n         BNE   PROGCK\n*        CLI   SDWAICD1-SDWA(R4),X'11' PIC 11\n*        BNE   PROGCK                  IF NOT THEN TRY OTHERS\n         OI    FLAG2,FG2ADDR\n         B     SET_RP\nPROGCK   DS    0H\n         OI    FLAG2,FG2PCK\n         B     SET_RP\n*\n*        If We Have Gotten a S0C4 See if Storage is\n*                  Swapped out\n*\n*        Issue all Flavors of VsmLoc to See if Storage\n*\n*                      Was Obtained\n*\n         L     R3,LEN\n         L     R2,START_ADDR\n         MVC   LOC,=CL8'PRIVATE'\n         VSMLOC PVT,AREA=((R2),(R3)),TCB=OWNTCB\n         LTR    R15,R15          Q. Was Storage Obtained\n         BZ     CK_PAGE          Is it paged in\n*\n*\n*\n         MVC   LOC,=CL8'SQA '\n         VSMLOC SQA,AREA=((R2),(R3))\n         LTR    R15,R15          Q. Was Storage Obtained\n         BZ     CK_PAGE          Is it paged in\n*\n*\n*\n         MVC   LOC,=CL8'LSQA'\n         VSMLOC LSQA,AREA=((R2),(R3))\n         LTR    R15,R15          Q. Was Storage Obtained\n         BZ     CK_PAGE          Is it paged in\n*\n*\n*\n         MVC   LOC,=CL8'CSA '\n         VSMLOC CSA,AREA=((R2),(R3))\n         LTR    R15,R15          Q. Was Storage Obtained\n         BZ     CK_PAGE          Is it paged in\n*\n*\n*\n         MVC   LOC,=CL8'CPOOLFIX'\n         VSMLOC CPOOLFIX,AREA=((R2))\n         LTR    R15,R15          Q. Was Storage Obtained\n         BZ     CK_PAGE          Is it paged in\n*\n*\n*\n         MVC   LOC,=CL8'CPOOLLCL'\n         VSMLOC CPOOLLCL,AREA=((R2))\n         LTR    R15,R15          Q. Was Storage Obtained\n         BZ     CK_PAGE          Is it paged in\n*\n         OI     FLAG1,FG1NOAL    Indcate storage Not Allocated\n         B      SETKEY0\n*        B      D#EXIT\n*\n*        Check it storage is paged out\n*\nCK_PAGE  DS    0H\n         STC   R0,SUBPOOL          Store Subpool value\n         L     R2,START_ADDR       Point to What we look at\n         L     R3,USERSTOR         Get Storage Key\n         SRL   R3,4                Put it back in right spot\n*\n         TPROT 0(R2),R3\n         BC    14,MOVE_STOR\n*\n         L     R2,START_ADDR\n         LR    R3,R2\n         A     R3,LEN\n*\nSETKEY0  DS     0H\n         SPKA   0                  We Have to Be In Stor Key 0\n*\n         LA    R3,40(,R2)\n         PGSER R,FIX,A=(R2),EA=(R3),TCB=0,ECB=0,BRANCH=Y\n*\nMOVE_STOR DS   0H\n         L     R2,LENGTH\n         S     R2,SDWAGR01-SDWA(R1)    GET LENGTH NOT MOVED\n         ST    R2,LENGTH               SAVE MOVED LENGTH\n         B     D#FRR0                  ALL DONE\n*        IF ADDRESSING EXCEPTION THEN\n*        REGISTERS NOT ALWAYS UPDATED (PER POPS)\n*        BUT THE TRANSLATION ADDR IS CLOSE.\n*        ALSO NO DATA MAY HAVE BEEN MOVED.\n*        (WE ARE DEALING HERE WITH WHAT MAY BE \"MODEL DEPENDENT\"\n*        FEATURES)\nD#FRR0A  DS    0H\n         L     R2,SDWATRAN-SDWA(,R1)   GET BAD ADDRESS\n         S     R2,ADDR                 LESS START ADDR\n         LTR   R2,R2                   ANY GOOD LENGTH\n         BM    D#FRR0                  NOPE                         1.1\n         C     R2,LENGTH               MAKE SURE IT IS REASONABLE\n         BH    D#FRR0                  SKIP IF NOT\n         ST    R2,LENGTH               SAVE AS GOTTEN LENGTH\n         LTR   R2,R2                   ANY LENGTH AT ALL            1.1\n         BZ    D#FRR0                  NO - SO SKIP MOVE            1.1\n         LR    R3,R2                   SETUP LENGTH\n         LR    R5,R2                                               1.1C\n         L     R2,ADDR                 GET FROM ADDR\n         LA    R4,BUF                  GET TO ADDRESS              1.1C\n         MVCL  R4,R2                                               1.1C\nD#FRR0   OI    FLAG2,FG2IVLD  SET FLAG FOR MESSAGE\nSET_RP   DS    0H\n         LR    R1,R4\n         L     R7,SDWAGR07        Restore\n         SETRP RECORD=NO,RC=4,RETADDR=FRRPOST,DUMP=NO,RETREGS=YES,     X\n               FRESDWA=YES\n         LA    R15,4          Retry\n         L     R14,RECOVRET   Restore Recovery\n         BR    R14            EXIT\n         SPACE 5\n*\n*        ALL OTHER ERRORS\n*\nD#FRR1   OI    FLAG2,FG2ERRR  SET FLAG FOR MESSAGES\n         SETRP RECORD=YES,RC=4,RETADDR=FRRPOST,REGS,DUMP=YES,          X\n               RETREGS=YES,FRESDWA=YES\n         BR    R14            EXIT\nSPIEOTR  DS    0H\n         LR    R1,R4                   RESTORE SDWA REG\n         SETRP REGS=(14,12),DUMP=NO,RC=0,RECORD=NO\n         DROP  R12\n         SPACE 2\n         TITLE 'LOOK --  STORAGE ALTER/DISPLAY - RESOURCE MGR. CLEANUP'\n*\n*        THIS ROUTINE RECEIVES CONTROL IF THE SRB MUST BE\n*        PURGED.\n*\nD#RMTR   DS    0H\n         USING *,R15\n         LR    R7,R15         SET BASE REGISTER\n         SL    R7,=A(D#RMTR-D#SRBCD)   BY COMPUTATION\n         DROP  R15\n         USING D#SRBCD,R7\n         LR    R8,R2          SET UP POINTER TO WORK\n         ST    R14,ASRBRTN    SAVE RETURN ADDR\n         OI    FLAG2,FG2PURG  SET PURGED\n         B     FRRPOST        GO AND POST TO CLEAN UP\n         LTORG\nENDSRB   DS    0H\nSRBCODE  EQU   *-D#SRBCD               LENGTH OF SRB CODE\n         TITLE 'LOOK --  STORAGE ALTER/DISPLAY - MESSAGES, CONSTANTS'\nKEY1 DC CL80'1= HELP      2=           3= END        4=           5= REX\n               PEAT  6=          '\nKEY2 DC CL80'7= BACKWARD  8= FORWARD   9= HIST BWD  10= HIST FWD 11=   X\n                    12=          '\n* ERROR MESSAGE FOR BAD INPUT\nTITLE    DC    CL79' '\nMODEMSG  DC    CL79'***** INVALID MODE'\nINVADDR  DC    CL79'***** BAD ADDRESS '\nPROGCHK  DC    CL79'***** PROGRAM CHECK '\nINVALOP  DC    CL79'***** INVALID OPERATOR'\nSYMFULL  DC    CL79'***** SYMBOL TABLE IS FULL'\nNAMEMSG  DC    CL79'***** UNDEFINED SYMBOL'\nDEFMSG   DC    CL79'***** NULL SYMBOL OR SYMBOL TOO LONG'\nPCMSG    DC    CL79'***** PROGRAM CHECK'\nLINKMSG  DC    CL79'***** LINK FAILED'\nSRBMSG   DC    CL79'***** SRB DATA FETCH FAILED'\nAUTHMSG  DC    CL79'***** LOOK NOT CURRENTLY AUTHORIZED. REQUEST DENIEDX\n               .'\nBDASMSG  DC    CL79'***** ASID INVALID OR SWAPPED OUT.'\nBADIMSG  DC    CL79'***** INDIRECT FAILED.'\nASIDFMT  DC    CL13'CURRENT ASID='\nERRMSG   DC    CL79'INVALID ADDRESS -- TRY AGAIN'\nINVASIDC DC    CL79'INVALID CHARACTERS OR VALUE TYPED INTO ASID'\nINVTYPDV DC    CL79'INACTIVE ASID TYPED IN'\nPROT     DC    CL79'--- PART/ALL OF REQUESTED MEMORY FETCH PROTECTED' 1\nNONEX    DC    CL79'--- PART/ALL OF REQUEST MEMORY NON-EXISTENT'    1.1\nBLANKS   DC    CL79' '\n         EJECT\nHEXTAB   DC    256C' '                 GENERAL HEX CONVERSION TABLE\n         ORG   HEXTAB+C'A'             INPUT CONVERSION\n         DC    X'0A0B0C0D0E0F'\n         ORG   HEXTAB+C'0'             OUTPUT CONVERSION\n         DC    C'0123456789ABCDEF'\n         ORG\n* HEX INPUT TRT TABLE\nNUMTAB   DC    256X'1'\n         ORG   NUMTAB+C'A'\n         DC    6X'0'\n         ORG   NUMTAB+C'0'\n         DC    10X'0'\n         ORG\nVALCHAR  DC    256C'.'                 TRANSLATE TO VALID CHARS\n         ORG   VALCHAR+C' '\n         DC    C' '\n         ORG   VALCHAR+C'\u00a2'\n         DC    C'\u00a2.<(+|&&'\n         ORG   VALCHAR+C'!'\n         DC    C'!$*);\u00ac-/'\n         ORG   VALCHAR+C','\n         DC    C',%_.?'\n         ORG   VALCHAR+C':'\n         DC    C':#@''=\"'\n         ORG   VALCHAR+C'a'\n         DC    C'abcdefghi'\n         ORG   VALCHAR+C'j'\n         DC    C'jklmnopqr'\n         ORG   VALCHAR+C's'\n         DC    C'stuvwxyz'\n         ORG   VALCHAR+C'A'\n         DC    C'ABCDEFGHI'\n         ORG   VALCHAR+C'J'\n         DC    C'JKLMNOPQR'\n         ORG   VALCHAR+C'S'\n         DC    C'STUVWXYZ'\n         ORG   VALCHAR+C'0'\n         DC    C'0123456789'\n         ORG\n         LTORG\n         SPACE 2\n*        SCREEN DEFINITION AREA\nQDINIT   DS    0D             START OS DISPLAY WORK AREA\n         DC    F'0'           ORIG SCREEN DEPTH\n         DC    F'0'           ORIG SCREEN LINESZ\n         DC    H'80'          LENGTH OF DISPLAY LINE\n         DC    PL2'21'        LINES PER SCREEN\n         DS    0D\n         DS    0CL69\n         DC    CL6' '\n         DC    CL63' '\n         DC    CL63' '        CORRECTED DATA FROM SCREEN\n         DS    0C             DISPLAY SCREEN\n         DC    X'27'          CONTROL\n         DC    X'F5'          ERASE/WRITE\n         DC    X'C1115D7F1140403C404000' CLEAR SCREEN\n         DC    CL43'LOOK COMMAND - DISPLAY VIRTUAL MEMORY' TITLE L 1.1D\n         DC    CL13'DISPLAY ASID='\n         DC    X'1DC8'        MARK NEXT FIELD AS INPUT FIELD\n         DC    CL4' '         IN/OUT FOR ASID\n         DC    X'1DF0'        TERMINATE INPUT FIELD\n         DC    X'11'          SET BUFFER ADDRESS\n         DC    X'C150'        (2,1)\n         DC    C'ENTER CMD -'     REPLY PROMPT\n         DC    X'1DC8'        MARK NEXT FIELD AS INPUT FIELD\n         DC    X'13'          SET CURSOR ADDRESS\n         DC    X'11'          SET BUFFER ADDRESS\n         DC    X'C25B'        (2,76)\n         DC    X'1DF0'        TERMINATE INPUT FIELD\n         DC    X'11'          SET BUFFER ADDRESS\n         DC    X'C260'        (3,1)\n         DC    C'LAST CMD  - '\n         DC    CL63' '        PREVIOUS COMMAND\n         DC    X'11'          SET BUFFER ADDRESS\n         DC    X'C3F0'        (4,1)\n         DC    CL79' '\n         DC    C' '\n         DC    16CL80' '      MESSAGE TEXT AREA\n         DC    2CL80' '\n         DC    2CL80' '       PFK DISPLAY AREA\nHELPMSG  DS    0H\n DC CL80'LOOK is a real time core display and formatting program. It alX\n               so has the        '\n DC CL80'capability of displaying memory in any address space.         X\n                                 '\n DC CL80'                                                              X\n                                 '\n DC CL80'The valid commands are:                                       X\n                                 '\n DC CL80'Iexp  24 bit indirect                 | Jexp  31 bit indirect X\n                                 '\n DC CL80'(To change ASID, overtype it in hex.) |                       X\n                                 '\n DC CL80'>     Forward                         | <     Backward        X\n                                 '\n DC CL80'=sym  Define current address as \"sym\" | ,sym  Redisplay core aX\n               t \"sym\"           '\n DC CL80'M0/M1 Flip between top and center     | Lname Indirect thru coX\n               ntrol block field '\n DC CL80'Ocb   Format as \"cb\" control block    | R     Refresh displayeX\n               d storage         '\n DC CL80'      \"cb\" may be NULL to show as hex |                       X\n                                 '\n DC CL80'                                                              X\n                                 '\n DC CL80'where ''exp'' is of the form:                                 X\n                                   '\n DC CL80'    <+/->hhhh<+/-hhhh<+/-hhhh...>>                            X\n                                 '\n DC CL80'and ''hhhh'' is a 1 to 8 digit hex number.                    X\n                                   '\n DC CL80'                                                              X\n                                 '\n DC CL80'                                                              X\n                                 '\n         TITLE 'LOOK --  STORAGE ALTER/DISPLAY - WORK AREAS, DSECTS'\n*----------------------------------------------------------------------\n*\n* HIST -- HISTORY ENTRY FOR ONE OR MORE PREVIOUS ENTRIES\n*\n*----------------------------------------------------------------------\n         SPACE 2\nHIST     DSECT\nHISTADDR DS    D                       ADDR OF STORAGE/MAIN CB ADDRES\nHISTCBHP DS    A                       0 IF NO CB\n*                                      X'7FFFFFFF' IF OVERLAY NULL\n*                                      ADDR OF CBH IF CB DISPLAYED\nHISTCBSP DS    A                       ADDR OF CBS DISPLAYED\nHISTSADR DS    A                       ADDR OF STORAGE FOR THIS SEG\nHISTLEN  EQU   *-HIST                  LENGTH OF ENTRY\n         SPACE 5\n*----------------------------------------------------------------------\n*\n* CBH  -- CONTROL BLOCK HEADER  -  ONE FOR EACH DIFFERENT CONTROL BLK\n*\n*----------------------------------------------------------------------\n         SPACE 2\nCBH      DSECT\nCBHNEXT  DS    A                       ADDR OF NEXT CONTROL BLOCK OR 0\nCBHVOFF  DS    A                       OFFSET OF VALIDATION FIELD\nCBHCBSP  DS    A                       ADDR OF FIRST SEG DESCIPTOR\nCBHNAME  DS    CL8                     NAME OF BLOCK\nCBHVLEN  DS    X                       LENGTH OF VALIDATION FIELD\nCBHVAL   DS    0X                      VALIDATION DATA\n         SPACE 5\n*----------------------------------------------------------------------\n*\n* CBS  -- CONTROL BLOCK SEGMENT\n*\n*----------------------------------------------------------------------\n         SPACE 2\nCBS      DSECT\nCBSPREV  DS    A                       ADDRESS OF PREVIOUS SEGMENT\nCBSNEXT  DS    A                       ADDRESS OF NEXT SEGMENT\nCBSDLEN  DS    AL2                     LENGTH OF DATA TO FETCH\nCBSDOFF  DS    AL2                     OFFSET OF DATA TO FETCH\nCBSILEN  DS    AL2                     LENGTH OF INDIRECT TO FETCH\nCBSIOFF  DS    AL2                     OFFSET OF INDIRECT TO FETCH\nCBSLEN   EQU   *-CBS                   LENGTH OF SEGMENT HEADER\n         SPACE 5\n*----------------------------------------------------------------------\n*\n* CBF  -- CONTROL BLOCK FIELD\n*\n*----------------------------------------------------------------------\n         SPACE 2\nCBF      DSECT\nCBFNAME  DS    CL8                     NAME OF FIELD\nCBFTYPE  DS    CL1                     TYPE OF NAME\nCBFDLEN  DS    XL1                     LENGTH OF DATA TO DISPLAY\nCBFOFFS  DS    H                       OFFSET INTO BLOCK START\nCBFLINE  DS    H                       LINE NUMBER TO PUT ON\nCBFCOLM  DS    H                       COLUMN TO START IN\nCBFLEN   EQU   *-CBF\n         EJECT\n*----------------------------------------------------------------------\n*\n*   MAIN DYNAMIC WORK AREA\n*\n*----------------------------------------------------------------------\nWORKAREA DSECT\nSAVE     DS    18F\nSAVE14T1 DS    2D\nOUTAREA  DS    CL80\nSAVE1    DS    F\nHISTORY  DS    F                       HISTORY TABLE ADDRESS\nTARGETSTOKN DS D\n*RBRET   DS    F\n*RBRETCODE DS  F\n*RBRSN   DS    F\nNAMES    DS    150D                    SYMBOL TABLE\nCURRENT  DS    H                       HIST TABLE OFFSET\nESTAE    ESTAE 1,PARAM=0,MF=L      ROOM FOR ESTAE PARM LIST\n         DS    0F,H                SPACER\nESRUB    DS    H                   BIT INDICATOR SHOULD BE X'0074'\nBASE1    DS    F                   SECOND BASE REG (R9)\nBASR10   DS    F                   NORMAL R10\nBASE2    DS    F                   FIRST BASE REG (R11)\nBASR13   DS    F                   NORMAL R13\nTEMP1    DS    CL9                     CONVERSION WORK AREA\nTEMP2    DS    CL9                     CONVERSION WORK AREA\nLOGOOD   DC    F'0'\nHIGOOD   DC    XL4'FFFFF123'\nCSALEN   DS    F                       SP AND LEN OF CSA WORK AREA\nCSAWORK  DS    A                       ADDRESS OF CSA WORKAREA\nCSABUF   DS    A                       ADDRESS OF CSA DATA BUFFER FOR\n*                                      SRB\nCSASTAR  DS    AD                      USERS ADDR OF BEGINNING OF\n*                                      BUFFER DATA\nCSAEND   DS    AD                      USERS ADDR OF END OF BUFFER DATA\nCSAASID  DS    H                       USERS ASID FOR BUFFER DATA\nMYASID   DS    H                       DCMS ASID\nCURASID  DS    H                       DISPLAYED CORE ASID\nSAVEASID DS    CL4                     FORMATTED VERSION OF CURASID\nFLAGS    DS    X                       ASSORTED FLAGS\nINDFLAG  EQU   X'80'                   INDIRECT IN PROGRESS\n*OAUTH   EQU   X'40'                   IF ON THEN NOT AUTHORIZED    Joe\nGETINPG  EQU   X'20'                   ON IF GETSTOR IN PROGRESS (SUBR)\nRFRSH    EQU   X'10'                   ON TO REFRESH CSA BUFFER\nIND31    EQU   X'08'                   31 BIT INDIRECT IN PROGRESS\nREFETCH  EQU   X'04'                   First get failed and retry  1.1C\nIND64    EQU   X'02'                   64 BIT INDIRECT IN PROGRESS\nAMOD64   EQU   X'01'                   NEEDS ACCESS MODE 64\nMODEFLAG DS    X                       USER OPTION FLAGS\nMIDDUMP  EQU   X'80'                   ON TO FORCE DISPLAY BACK 8 LINES\nALIGN    EQU   X'40'                   ON TO ALIGN DUMP ON QUADWORD\n         SPACE 2\n*        SCREEN DEFINITION AREA\nQDISPLAY DS    0D             START OS DISPLAY WORK AREA\nQDOSZR0  DC    F'0'           ORIG SCREEN DEPTH\nQDOSZR1  DC    F'0'           ORIG SCREEN LINESZ\nQDLNELEN DC    H'80'          LENGTH OF DISPLAY LINE\nQDLNES   DC    PL2'21'        LINES PER SCREEN\n         DS    0D\nPFREPLY  DS    0CL69\nPFCODE   DC    CL6' '\nPFTXT    DC    CL63' '\nINPLINE  DC    CL63' '        CORRECTED DATA FROM SCREEN\nQDSCREEN DS    0C             DISPLAY SCREEN\n         DC    X'27'          CONTROL\n         DC    X'F5'          ERASE/WRITE\n         DC    X'C1115D7F1140403C404000' CLEAR SCREEN\n         DC    CL43'LOOK COMMAND - DISPLAY VIRTUAL MEMORY' TITLE L 1.1D\nASIDLN   DC    CL13'CURRENT ASID='\n         DC    X'1DC8'        MARK NEXT FIELD AS INPUT FIELD\nASIDLN1  DC    CL4' '         IN/OUT FOR ASID\n         DC    X'1DF0'        TERMINATE INPUT FIELD\n         DC    X'11'          SET BUFFER ADDRESS\n         DC    X'C150'        (2,1)\n         DC    C'ENTER CMD -'     REPLY PROMPT\n         DC    X'1DC8'        MARK NEXT FIELD AS INPUT FIELD\n         DC    X'13'          SET CURSOR ADDRESS\n         DC    X'11'          SET BUFFER ADDRESS\n         DC    X'C25B'        (2,76)\n         DC    X'1DF0'        TERMINATE INPUT FIELD\n         DC    X'11'          SET BUFFER ADDRESS\n         DC    X'C260'        (3,1)\n         DC    C'LAST CMD  - '\nINPSAVE  DC    CL63' '        PREVIOUS COMMAND\n         DC    X'11'          SET BUFFER ADDRESS\n         DC    X'C3F0'        (4,1)\nMSGLINE  DC    CL79' '\n         DC    C' '\nOUT1     DC    16CL80' '      MESSAGE TEXT AREA\nOUT9     EQU   OUT1+(8*80)\n         DC    2CL80' '\nKEYS     DC    2CL80' '       PFK DISPLAY AREA\nQDISPLN  EQU   *-QDISPLAY     LENGTH OF ENTIRE DISPLAY\nQDSLNG   EQU   *-QDSCREEN     LENGTH OF SCREEN BUFFER\n*\n**       AREA TO HOLD DATA RETURNED BY GETSTOR\n*\nDUMPDATA DS    XL(MAXFETCH)            DATA RETURNED BY GETSTOR\nWORKLEN  EQU   *-WORKAREA\n         EJECT\n         PRINT NOGEN\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n*        END\n         IHAASCB\n         IHAASSB\n         IHAASVT\n         IHAFRRS\n         IHAPSA\n         IHAPVT\n         IHASDWA\n         IHASRB\n         IHARB\n         CVT   DSECT=YES\n         EJECT\n*\n*        CSA AREA WORK AREA\n*\nWORK     DSECT\nWORKSTRT DS    0D\nDOUBLE   DS    2F\nDMYPRMS  DS    6F             DUMMY AREA FOR FRR PARMS FOR SUBR MODE\nSRB_EPA  DS    A\nFRR_EPA  DS    A\nRTM_EPA  DS    A\nWORK_EPA DS    A\nRECOVRET DS    F\nABEND_CODE DS  XL2\nLOC      DS    CL8\nSTART_ADDR DS  F\nLEN      DS    F\nOWNTCB   DS    F\nFRRPRMS  DS    F              ADDRESS OF 6 WORD FRR PARM\nASRBRTN  DS    F              RETURN ADDR FOR SRB CODE\nMYASCB   DS    F              ASCB ADDR OF MAIN ROUTINE\nMYTCB    DS    F              TCB ADDRESS FOR MAIN ROUTINE\nTOASCB   DS    F              ASCB ADDR OF SRB ROUTINE\nECB      DS    F              ECB FOR MAIN ROUTINE TO WAIT ON\nECB2     DS    F              ECB FOR STIMER TO POST\nECBLIST  DS    2F\nLENGTH   DS    F              LENGTH OF STORAGE TO DUMP\nUSERSTOR DS    F              User Storage Key\nSUBPOOL  DS    X\nSRBAREA  DS    ((SRBSIZE+3)/4)F  THE SRB ITSELF\nADDR     DS    D              ADDRESS TO PROCESS AT\nASID     DS    H              ASID OF TOASCB\nFLAG1    DS    X\nFG1DUMP  EQU   X'80'\nFG1REP   EQU   X'40'\nFG1MOVE  EQU   X'20'                   IF ON DOING MVCL FOR DATA\nFG1NOAL  EQU   X'10'\nFG1SRDN  EQU   X'02'          IF ON SRB HAS TERMINATED\nFG1SUBR  EQU   X'01'\nFLAG2    DS    X\nFG2NVER  EQU   X'01'          VERIFICATION FAILED\nFG2IVLD  EQU   X'02'          VALIDATION FAILED\nFG2ERRR  EQU   X'04'          DISASTER OCCURED IN SRB\nFG2PURG  EQU   X'08'          SRB WAS PURGED\nFG2ADDR  EQU   X'80'\nFG2PCK   EQU   X'40'\nFG2PSTR  EQU   X'10'          IF ON THEN SRB POST HAD ERROR\nMERRCD   DS    X                       INTERRUPT CODE               1.1\nSRBCCD   DS    0D                      ALIGN SRB CODE ON DBL WORD\n         DS    (SRBCODE)X\n         DS    0D                      ALIGN BUFFER\nBUF      DS    (MAXFETCH)X\nWORKLN   EQU   *-WORKSTRT\nTRVALHEX CSECT\nTRVALTAB DC    X'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'   00\n         DC    X'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'   10\n         DC    X'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'   20\n         DC    X'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'   30\n         DC    X'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'   40\n         DC    X'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'   50\n         DC    X'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'   60\n         DC    X'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'   70\n         DC    X'CCC1C2C3C4C5C6CCCCCCCCCCCCCCCCCC'   80\n         DC    X'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'   90\n         DC    X'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'   A0\n         DC    X'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'   B0\n         DC    X'CCC1C2C3C4C5C6CCCCCCCCCCCCCCCCCC'   C0\n         DC    X'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'   D0\n         DC    X'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'   E0\n         DC    X'F0F1F2F3F4F5F6F7F8F9CCCCCCCCCCCC'   F0\n         END\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LOOKJ$": {"ttr": 6662, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x18\\x00#\\x01\\x00\\x17O\\x01\\x19\\tO\\x146\\x00#\\x00\\x1f\\x00\\x00\\xc1\\xe2\\xd4\\xd3\\xd1\\xc3\\xd3@@@'", "ispf": {"version": "01.24", "flags": 0, "createdate": "2000-06-22T00:00:00", "modifydate": "2019-04-04T14:36:23", "lines": 35, "newlines": 31, "modlines": 0, "user": "ASMLJCL"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//* --------------------------------------- *//\n//*     ASM LINKEDIT FROM SOURCE ASM        *//\n//*                                         *//\n//*   --  STANDARD ASSEMBLY OF LOOK  --     *//\n//* --------------------------------------- *//\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,FLAG(5))\n//SYSLIB   DD DISP=SHR,DSN=SBGOLOB.CBT497.FILE264 => EXTRA MACROS\n//*        DD DISP=SHR,DSN=SBGOLOB.LOOK.INSTALL   => ALTERED IBM MACROS\n//         DD DISP=SHR,DSN=SYS1.MACLIB,UNIT=3390\n//         DD DISP=SHR,DSN=SYS1.MODGEN,UNIT=3390\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.CBT497.FILE264(LOOKJ)\n//         DD DISP=SHR,DSN=SBGOLOB.CBT497.FILE264(CBMACSE)\n//*        DD DISP=SHR,DSN=SBGOLOB.B.ASM(CBMACSE)  ==> EXTRA MACROS\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(CYL,2),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n ENTRY   LOOK\n INCLUDE OBJECT\n SETSSI  CB497264\n SETCODE AC(1)\n NAME    LOOK(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LOOKN": {"ttr": 6664, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x13\\x00&\\x00\\x86\\x15/\\x01\\x19\\tO\\x13\\x18\\t=\\x05#\\t=\\xf6\\xf4`\\xc2\\xc9\\xe3@@@@'", "ispf": {"version": "01.19", "flags": 0, "createdate": "1986-06-01T00:00:00", "modifydate": "2019-04-04T13:18:26", "lines": 2365, "newlines": 1315, "modlines": 2365, "user": "64-BIT"}, "text": "         TITLE 'LOOK -- DISPLAY VIRTUAL MEMORY -- 64-BIT VERSION'\n*\n** -------------------------------------------------------------------\n**   This program is not re-entrant, but it should be linkedited\n**   as REUS (reusable), and it has to be SETCODE AC(1), run\n**   from an APF-authorized load library, and marked in the\n**   AUTHCMD NAMES list of the IKJTSOxx PARMLIB member.\n** -------------------------------------------------------------------\n**   This program does not change storage, but lets you look at\n**   storage in any active address space.\n** -------------------------------------------------------------------\n**   This version has been fixed by Joe Reichman, to handle 64-bit\n**   addresses.  When doing indirect addressing for a 64-byte address,\n**   use the letter G instead of the letter J.\n**\n**   Examples:   G+1B8, G+10\n**\n**   How does indirect addressing work for 64-byte addresses?\n**   In this case, LOOK will go to the location indicated, and regard\n**   the first 8 bytes there as an address.  And then it will attempt\n**   to access the storage at that address, displaying its contents.\n**   This is just like the action of J, which does the same thing for\n**   4-byte addresses (or 3-byte addresses, for that matter).\n** -------------------------------------------------------------------\n**   This version of LOOK has been revised by Joe Reichman to allow\n**   operation when VSM ALLOWUSERKEY(NO) is set, in the PARMLIB\n**   member DIAGxx.  For cross-memory storage browsing, the SCHEDULE\n**   macro has been replaced by IEAMSCHD, so this version of the\n**   program may not work on old MVS systems.  However, IEAMSCHD has\n**   been here at least since ESA.  Its parameter SYNCH=YES has been\n**   in existence since OS/390 Release 1.3 (but not before that).\n**   (Since OS/390 1.3 was the first Y2K-compliant version of MVS, it\n**   is not likely that anyone is running something earlier, in\n**   production.)\n**\n**   From z/OS 2.4 and onward, user key CSA allocation will be\n**   prohibited.  But this version of LOOK should still work there.\n**\n**   THIS VERSION OF LOOK REQUIRES APF-AUTHORIZATON, ALWAYS, BECAUSE\n**   ITS WORKING STORAGE IS NOW OBTAINED IN KEY 0, NOT IN A USER KEY.\n** -------------------------------------------------------------------\n**   LOOK requires assembly together with the CBMACS module, so that\n**   it can format many system control blocks.  The LOOK module is the\n**   \"driving code\", which can be assembled together with different\n**   versions of CBMACS depending on any specialized needs that you\n**   have, to format specific control blocks.  The CBMACS we have\n**   packaged with CBT File 264, will already format many standard\n**   z/OS (OS390, MVS) control blocks, but you may want to create\n**   your own versions of CBMACS.\n**\n**   Please note:  CBMACS will only format \"real data\" in macros,\n**   so when an IBM macro contains:   label   DS  0CLx   or similarly,\n**   label  DS  0XLx  then CBMACS will not display that field.  You\n**   may want to create your own altered versions of IBM macros, but\n**   we can't publish them for licensing reasons.  Formatting in\n**   CBMACS also depends on the data type (such as C, X, A, F, etc.)\n**   You may want to alter an IBM macro from  DS CL5 to DS XL5, so\n**   that the data will display in hex, instead of showing a dot,\n**   when that data is not a displayable value.\n**\n**   Formatting is turned off, using the ONULL command in LOOK.\n**   Formatting is turned on, using the O command, followed by\n**   the name of the control block:\n**   Examples:   OTCB  OPSA  OCVT\n**\n**   If the control block (to be formatted) does not contain an\n**   eyecatcher, such as \"TCB\" (field TCBTCBID in macro IKJTCB),\n**   then you can not format it automatically, but you need to run\n**   an Oblkid command to do the formatting.\n**   -----------------------------------------------------------------\n**   The HELP for LOOK is only one screen, accessible if you\n**   press PF1.  It is short and concise, but you should study it.\n**   (Pretty much everything, is there.  You just have to look.)\n**   -----------------------------------------------------------------\n**\n**       This version of LOOK supports multiple address space\n**       investigation.  Overtype the address space number, at\n**       the upper right side of the screen:\n**\n**       Example:    CURRENT ASID= 0024\n**                                 ----   (overtype hex asid number)\n**\n**       (There is quite a bit of validity checking built into this\n**       overtyping process.)\n**\n**       THIS VERSION IS CONFIGURED TO RUN AND RESIDE ABOVE THE LINE,\n**       AND IS THE 31-BIT VERSION.\n**\n** -------------------------------------------------------------------\n**\n**   Original code for this program was largely from Guy Albertelli.\n**\n** -------------------------------------------------------------------\n**   VERSION 1.1 CHANGES (6/1/88):                                  1.1\n**      - CORRECT ESTAE AND FRR ATTEMPTS TO DETERMINE HOW MUCH      1.1\n**        DATA WAS MOVED.                                           1.1\n**      - GIVE MESSAGES IF DATA WAS NOT MOVED, DISTINGUISH BETWEEN  1.1\n**        NON-EXISTENT (PAGE/SEGMENT FAULT), AND KEY/FETCH          1.1\n**        PROTECTION ERROR.                                         1.1\n**      - TRANSLATE THE OUTPUT CHARACTER STRINGS FOR CONTROL BLOCK  1.1\n**        FORMATTING. THANKS TO MR. S. GOLOB OF NEWSWEEK            1.1\n**      - COMBINE XA AND SP MODULES INTO 1 VIA GLOBAL SYMBOL        1.1\n**\n**   VERSION 1.1A CHANGES (12/5/88):                               1.1A\n**      - CORRECT HANDLING OF ERROR MESSAGES.                      1.1A\n**\n**   VERSION 1.1B CHANGES (10/31/89):                              1.1B\n**      - Change amount of core gotten for ESA.                    1.1B\n**\n**   VERSION 1.1C CHANGES (11/28/90):                              1.1C\n**      - Add changes from Bruce Bordonaro.                        1.1C\n**            - Use STTMPMD.                                       1.1C\n**            - Add significant number of macro formats.           1.1C\n**      - Improve memory fetch when CPU does no data movement.     1.1C\n**      - Fix problem in FRR recovery.                             1.1C\n**\n**   VERSION 1.1D CHANGES (01/22/91):                              1.1D\n**      - Add spelling corrections from Sam Golob.                 1.1D\n**      - Correct HELP screen for Overlay command.                 1.1D\n**      - Correct Mode command.                                    1.1D\n**      - Fix bugs in control block segments.                      1.1D\n**      - Handle 31 bit address correctly when top bit on.         1.1D\n**      - Correct title - Never did and never will actually        1.1D\n**                         zap memory - use INCORZAP or #D         1.1D\n**      - Stop long fields from overlaying next lines.             1.1D\n**      - Correct blanking out of areas not available              1.1D\n**      - Get memory line at a time in dump, if necessary.         1.1D\n**\n**   VERSION 1.1E CHANGES (07/02/91):                              1.1E\n**      - If authorized then do memory fetches in KEY=0.           1.1E\n**\n**   CHANGES (04/21/17)       (Joe Reichman)                       JOE\n**      - Endeavor to fix S0C4 occurrences when storage cannot\n**        be obtained.  Changed SCHEDULE macro call to IEAMSCHD.\n**        Moved FRR call into IEAMSCHD, etc.\n**      - This version needs APF authorization. Message added.\n**\n**   CHANGES (02/06/19)       (Joe Reichman)                       Joe\n**      - Allow LOOK to operate without getting common storage\n**        in a user key.  VSM  ALLOWUSERKEYCSA(NO) in DIAGxx\n**        PARMLIB member, needed to be set, to run LOOK.  Now it\n**        doesn't matter.  VSM ALLOWUSERKEYCSA will be obsolete\n**        after z/OS 2.4.  Also we now require APF authorization\n**        for all invocations of LOOK, even in the current user's\n**        address space, because CSA is now obtained in KEY 0.\n**\n**   CHANGES (02/12/19)       (Sam Golob)\n**      - Cosmetic changes to the HELP screen (PF1) and to the\n**        ASID title, from \"DISPLAY ASID\" to \"CURRENT ASID\" so\n**        that you get the idea that the ASID number can be\n**        changed by typing it over with another hex number.\n**        Add more usage instructions at the beginning of the\n**        program source.\n**\n**   CHANGES (02/25/19)       (Joe Reichman)                64 Bit Joe\n**        Allow for 64-bit addressing.  Use G instead of J\n**        to indicate that the contents at the address of the\n**        given location will be regarded as an 8-byte address,\n**        and not as a 4-byte address.  J still works to\n**        indicate that the contents there will be regarded\n**        as a 4-byte address.\n**\n**   CHANGES (04/03/19)    (Joe Reichman and Sam Golob)    (not marked)\n**        This is a repaired version of the 64-bit LOOK.  It is\n**        called LOOKN to distinguish it from the 31-bit versions.\n**        Many bugs were fixed.  You can now type in an invalid\n**        ASID and the program will re-display the former ASID,\n**        with an appropriate error message.  Recovery for S0Cx\n**        abends is much improved (all thanks to Joe).\n**\n*\n         EJECT ,                                                   1.1D\n         MACRO\n&N       HEX   &TO,&FROM\n&N       UNPK  TEMP1(9),&FROM.(5,R6)\n         MVC   &TO.(8,R4),TEMP1\n         TR    &TO.(8,R4),HEXTAB\n         MEND\n         EJECT ,                                                   1.1D\nLOOK     CSECT\n******************************                                     1.1D\n**                                                                 1.1D\n**     Fetch constant - maximum amount fetchable in one call       1.1D\n**                                                                 1.1D\nMAXFETCH EQU   4096                                                1.1D\n**                                                                 1.1D\n**                                                                 1.1D\n******************************                                     1.1D\n         SPACE 3                                                   1.1D\n*                                                                   1.1\n*        SET THE FOLLOWING GLOBAL SYMBOL TO 1 FOR XA AND 0 FOR SP   1.1\n*                                                                   1.1\n         GBLB  &XA                                                  1.1\n&XA      SETB  1 =XA MODE              SET TO 1 FOR XA              1.1\n         SPACE 3                                                    1.1\n*  INITIALIZE THE PROGRAM\n         SAVE  (14,12),,'LOOK..&SYSDATE..&SYSTIME'\n         LR    R11,R15                 PERMANENT BASE\n         USING LOOK,R11\n         LA    R9,2048(,R11)           GET A SECOND BASE REG\n         LA    R9,2048(,R9)\n         USING LOOK+4096,R9\n         USING LOOK+8192,R7\n         LA    R7,2048(,R9)            Need another base 64 bit   Joe\n         LA    R7,2048(,R7)            Need another base 64 bit   Joe\n         AIF   (&XA).XA1                                            1.1\n         GETMAIN R,LV=WORKLEN,SP=1                          SP      1.1\n         AGO   .NXA1                                                1.1\n.XA1     ANOP                                                       1.1\nLOOK     AMODE 31                                           XA      1.1\nLOOK     RMODE ANY                                          XA      1.1\n         GETMAIN R,LV=WORKLEN,SP=1,LOC=(BELOW,ANY)          XA      1.1\n.NXA1    ANOP                                                       1.1\n         LR    R10,R1\n         LR    R2,R10                  WORK AREA START\n         L     R3,=A(WORKLEN)          LENGTH TO CLEAR\n         SR    R5,R5                   ZERO PAD BYTE, LENGTH 2\n         MVCL  R2,R4                   CLEAR THE WORK AREA\n         USING WORKAREA,R10\n         LA    R4,QDINIT\n         LA    R3,QDISPLN              GET LENGTH\n         LA    R2,QDISPLAY             POINT AT START\n         LR    R5,R3                   SET FROM LENGTH\n         MVCL  R2,R4                   INIT DISPLAY\n         STG   R13,SAVE+8              CHAIN THE SAVE AREAS  64 Bit Joe\n         LA    R15,SAVE\n         STG   R15,16(,R13)                                  64 BIT Joe\n         LR    R13,R15                 NEW SAVE AREA\n         STM   R9,R11,BASE1        SAVE FIRST THREE REGS FOR AREA\n         ST    R13,BASR13          AND ORIGINAL R13\n         TESTAUTH FCTN=1               ARE WE AUTHORIZED\n         LTR   R15,R15\n         BNZ   ENDIT0                  IF NOT SEND MESSAGE\n         LA    R1,50*HISTLEN           GET LENGTH OF HIST TBL\n         GETMAIN R,SP=2,LV=(1)\n         ST    R1,HISTORY              SAVE ADDRESS\n         STFSMODE ON,INITIAL=YES       TELL TSO WE ARE FULLSCREEN\n         STTMPMD ON,KEYS=ALL                                       1.1C\n*\n*        SET SUPERVISOR MODE IF AUTHORIZED\n*\n*        OI    FLAGS,NOAUTH            SET NOT AUTHORIZED           Joe\n         L     R1,=A(WORKLN)           GET LENGTH OF CAS BUFFER\n         ST    R1,CSALEN               SET LENGTH AND SP0\n         MVI   CSALEN,241              SET CSA SP\n*        NI    FLAGS,255-NOAUTH        MARK AUTHORIZED              Joe\n         MODESET MODE=SUP              SET TO SUP MODE\n         SPKA  0                       MAKE SURE GETMAIN IS KEY 0   Joe\nNOTAUTH  DS    0H\n         MVC   ASIDLN,ASIDFMT          SET MESSAGE\n         L     R1,16                   GET CVT\n         L     R2,0(,R1)               GET TCBWORDS\n         L     R1,12(,R2)              GET OLD ASCB ADDR (MINE)\n         USING ASCB,R1\n         MVC   MYASID,ASCBASID         MOVE IN MY ASID\n         MVC   CURASID,MYASID\n         DROP  R1\n         XC    CSAASID,CSAASID         CLEAR THE CSA BUFFER INDIC\n         XC    CSASTAR,CSASTAR\n         XC    CSAEND,CSAEND\n         L     R0,CSALEN               GET LENGTH AND SP FOR CSA BUFFER\n         GETMAIN R,LV=(0)\n         ST    R1,CSAWORK              SAVE ADDR OF CSA BUFFER\n         LR    R8,R1                   SET PROPER POINTER\n         USING WORK,R8\n*\n*        SETUP ESTAE IN CORRECT MODE\n*\n         MVC   RETRY,=F'0'\n         ESTAE RECOVERY,PARAM=(R8),MF=(E,ESTAE)\n*\n*        INITIALIZE ASID POINTERS\n*\n         LR    R0,R2                   Hold R2                    JOE\n         XR    R2,R2                   Clear R2                   JOE\n         IPK                                                      JOE\n         ST    R2,USERSTOR             Sav                        JOE\n         LR    R2,R0                                              JOE\n         MVC   MYTCB,4(R2)             SAVE ADDR OF MY TCB\n         MVC   MYASCB,12(R2)           SAVE ADDR OF MY ASCB\n         LA    R1,BUF                  POINT TO TRUE BUFFER\n         ST    R1,CSABUF\n         LA    R0,SRBCCD               POINT TO CSA SRB CODE AREA\n         LA    R1,SRBCODE              AND LENGTH OF CODE\n         LR    R3,R1\n         LA    R2,D#SRBCD              POINT TO CSECT CODE\n         MVCL  R0,R2                   MOVE SRB CODE TO CSA\n         B     ISCAN1                  GO AND PROCESS\n         DROP  R8\n         EJECT\n***********************************************************************\n*\n*   INPUT SCAN\n*\n***********************************************************************\n         SPACE 2\nISCAN    DS    0H\n         OC    ASIDLN1,=CL4' '         UPPERCASE BEFORE COMPARISON\n         CLC   SAVEASID,ASIDLN1        DID USER CHANGE ASID\n         BE    ISCAN1                  NOPE\n*\n*        FORMAT AND SAVE USER ASID.\n*\n*=====>    Validate chars typed into ASID field  -  below\n*        In this section of code, R15 thru R1 are work registers.\n*\n*        VERIFY IF WE TYPED IN NON-HEX CHARACTERS IN ASID FIELD\n*\n         STM   R15,R1,SAVE1501         SAVE REGISTERS AS WORK REGS\n         L     R15,=A(TRVALHEX)        ACCESS THE TRANSLATE TABLE\n         USING TRVALHEX,R15            TELL ASSEMBLER\n         TR    ASIDLN1,TRVALTAB        NON-HEX CHARS BECOME X'CC'\n         LA    R0,4                    SET UP LOOP TO DETECT THEM\n         LA    R1,ASIDLN1              POINT TO TRANSLATED ASID INPUT\nASIDVERL DS    0H                      LOOP TO LOOK FOR NON-HEX CHARS\n         CLI   0(R1),X'CC'             IS IT INVALID?\n         BE    ASIDBCH                 YES. REPORT THAT.\n         LA    R1,1(,R1)               TRY NEXT CHARACTER\n         BCT   R0,ASIDVERL             LOOP 4 TIMES\n         B     ASIDGUDC                GO TELL THAT GOOD ASID CHARS\nASIDGUDC DS    0H                      NO INVALID CHARS TYPED IN\n         DROP  R15\n*=====>    Validate chars typed into ASID field  -  above\n*                                      CONVERT DISPLAY ASID TO HEX HWD\n         MVC   TEMP1(4),ASIDLN1        GET ASID TYPED BY USER\n*                                      ALREADY UPPERCASED VIA TR TABLE\n         TR    TEMP1(4),HEXTAB         MAKE PACKABLE\n         PACK  TEMP2(3),TEMP1(5)\n         MVC   CURASID,TEMP2           GET NEW ASID AS A HALFWORD NMBER\n*====>     Validate if number typed in, is a valid ASID - below\nASIDVAL  DS    0H                      Now check for invalid ASID nmbrs\n         L     R15,CVTPTR              R15 -> cvt\n         L     R15,CVTASVT-CVT(,R15)   R15 -> asvt\n         USING ASVT,R15\n         XR    R0,R0                   Clear work register\n         LH    R0,CURASID              Load ASID\n         C     R0,ASVTMAXU             Higher than Max defined?\n         BH    ASIDBCH                 Yes. Show error.\n         LA    R1,ASVTENTY-ASVT(,R15)  Get first ASVT slot\n         BCTR  R0,0                    Down By 1 (starts with 0)\n         SLL   R0,2                    Multiply by 4\n         AR    R1,R0                   Point to ASCB addr in ASVT\n         TM    0(R1),X'80'             Is it Available?\n         BO    ASIDINAC                No. Show it is inactive.\nASIDVALE DS    0H\n         LM    R15,R1,SAVE1501         RESTORE R15 THRU R1\n         B     ISCAN1\n         DROP  R15\n*====>     Validate if number typed in, is a valid ASID - above\n*\n*--->  ASID typed entry errors - below\nASIDBCH  DS    0H                      REPORT NON-HEX CHARS TYPED IN\n         MVC   MSGLINE,INVASIDC        INVALID CHARS TYPED IN ASID\n         MVC   ASIDLN1,SAVEASID        PLUG IN PREVIOUS ASID VALUE\n         MVC   CURASID,MYASID          GUARANTEE GOOD ASID (MYASID)\n         B     TPUTSCRN                AND RE-DISPLAY THE SCREEN\n*\nASIDINAC DS    0H                      REPORT INACTIVE ASID TYPED IN\n         MVC   MSGLINE,INVTYPDV        INVALID CHARS TYPED IN ASID\n         MVC   ASIDLN1,SAVEASID        PLUG IN PREVIOUS ASID VALUE\n         MVC   CURASID,MYASID          GUARANTEE GOOD ASID (MYASID)\n         B     TPUTSCRN                AND RE-DISPLAY THE SCREEN\n*--->  ASID typed entry errors - above\n*\nISCAN1   MVC   INPSAVE,INPLINE         SAVE LAST USER INPUT\nISCAN2   LA    R3,INPLINE              POINT TO START OF INPUT\n         LA    R1,SCANTAB              COMMAND TABLE\n         NI    FLAGS,255-INDFLAG-IND31-IND64 TURN OFF INDIRECT FLAGS\n         MVC   MSGLINE,TITLE           CLEAR OUT ERROR MSG\nSCANLOOP L     R2,4(,R1)               GET TABLE ENTRY\n         CLC   0(1,R1),ENDTAB          SEE IF END OF TABLE\n         BE    NUMSCAN                 IF YES, ASSUME NUMERIC INPUT\n         CLC   0(1,R1),INPLINE         SEE IF COMMAND FOUND\n         BER   R2                      IF YES, GO TO COMM ROUINE\n         LA    R1,8(,R1)               NEXT ENTRY ADDRESS\n         B     SCANLOOP\nSAVE1501 DS    3F\nSCANTAB  DS    0F                      COMMAND TABLE\n         DC    CL4' ',A(FORMAT)\n         DC    CL4'I',A(INDIR)\n         DC    CL4'J',A(INDIR31)\n         DC    CL4'G',A(INDIR64)\n         DC    CL4'>',A(FWD)\n         DC    CL4'<',A(BACK)\n         DC    CL4'=',A(DEFINE)\n         DC    CL4',',A(NUMSCAN)\n         DC    CL4'M',A(MODE)\n         DC    CL4'L',A(LINK)\n         DC    CL4'O',A(OVERLAY)\n         DC    CL4'R',A(REFRESH)\nENDTAB   DC    X'FF'                   END OF TABLE INDICATOR\n         SPACE 2\n***********************************************************************\n*\n*     FORMAT THE OUTPUT SCREEN\n*\n***********************************************************************\n         SPACE 2\nFORMAT   LA    R3,INPLINE              CURSOR ADDRESS\n         MVC   INPLINE,BLANKS          CLEAR INPUT LINE\nFORMAT2  BAL   R14,ERASE               CLEAR THE SCREEN\n         LLGH  R2,CURRENT              HISTORY TABLE POINTE64 Bit Joe\n         A     R2,HISTORY              POINT AT HISTORY TABLE ENTRY\n         USING HIST,R2                 IDENTIFY HISTORY ENTRY FORMAT\n         LG    R4,HISTADDR             GET ADDRESS TO DISP 64 BIT Joe\n         TM    HISTCBHP,X'80'          IS THIS A CB MAP IN USE\n         BO    CBHIT                   IF SO THE PROCESS IT\n         CLC   =X'7FFFFFFF',HISTCBHP   SUPPRESSED CB USAGE\n         BE    NOCB\n         DROP  R2\n         SPACE 2\n*----------------------------------------------------------------------\n*\n*        SEE IF CONTROL BLOCK MAP EXISTS\n*\n*----------------------------------------------------------------------\n         SPACE 2\nDUMP     L     R5,=V(CBMACS)           GET START OF INDEX\n         LTR   R5,R5                   ANY VALUE\n         BZ    NOCB                    NOPE\n         USING CBH,R5                  ADDRESS THE CONTROL BLK HEADER\nDUMPCB   CLC   =F'0',CBHNEXT           SEE IF END OF INDEX\n         BE    NOCB                    IF YES, NO CB FOUND\n         LLGT  R2,CBHVOFF              GET CB IDENTIFIER OFFSET\n         AGR   R2,R4                   ADD DISPLAY ADDRESS\n         SR    R3,R3                   CLEAR A REGISTER FOR IC\n         IC    R3,CBHVLEN              GET LENGTH\n         LR    R0,R3                   PUT IN 0 FOR GETSTOR\n         LA    R1,DUMPDATA             TARGET ADDR\n         BAL   R14,GETSTOR             FETCH THE DATA\n         B     NOTCB                   BR IF NO DATA FOUND\n         B     NOTCB                   BR IF PARTIAL DATA FOUND\n         BCTR  R3,0                    GET MACHINE LENGTH\n         EX    R3,CBFNDIT              LOOK FOR VALIDATION FIELD\n         BE    CBHIT                   BR IF YES, CB WAS FOUND\nNOTCB    L     R5,CBHNEXT              NEXT INDEX ENTRY\n         MVC   MSGLINE,BLANKS          Clear useless error msg     1.1C\n         B     DUMPCB                  AND CHECK FOR MORE CB'S\nCBFNDIT  CLC   CBHVAL(*-*),DUMPDATA    SEE IF IDENTIFIER MATCH\n         DROP  R5\n         SPACE 2\n*----------------------------------------------------------------------\n*\n* IF NO CONTROL BLOCK TO BE SHOWN, JUST USE DUMP FORMAT\n*\n*----------------------------------------------------------------------\n         SPACE 2\nNOCB     DS    0H\n*        DBGRDIE LINKAGE=SVC\n         LGR   R2,R4                   COPY ADDR TO DISPLAY 64 Bit Joe\n         TM    MODEFLAG,ALIGN          QUADWORD ALIGNMENT WANTED\n         BZ    DUMPNOA                 BR IF NOT\n         NG    R2,=XL8'FFFFFFFFFFFFFFF0'   ROUND DOWN For   64 bit Joe\nDUMPNOA  TM    MODEFLAG,MIDDUMP        PUT ADDR INCENTER OF SCREEN?\n         BZ    DUMPNOM                 BR IF NOT\n         SH    R2,=H'128'              IF YES, BACK UP QUAD WORDS\n* R2 NOW HAS FIRST ADDRESS TO DISPLAY\nDUMPNOM  LA    R0,256                  LENGTH TO FETCH\n         LA    R1,DUMPDATA             TARGET ADDRESS\n         STG   R2,TEMP3                Store 64 bit value 64 bit Joe\n         L     R2,TEMP3                64 bit address\n         C     R2,=F'0'                Is it 64 bit       64 bit Joe\n         BZ    ITS_31                                     64 Bit Joe\n         LG    R2,TEMP3                64 bit address     64 bIT Joe\n         B     GET_STOR\nITS_31   DS    0H                                         64 BIT Joe\n         LG    R2,TEMP3                64 bit address     64 bIT Joe\n         LA    R2,0(0,R2)              clear top bit               1.1D\nGET_STOR DS    0H\n         BAL   R14,GETSTOR             GO FETCH THE DATA\n         B     DUMPLN                  go dump by line             1.1D\n         NOP   0                       RETURN IF PARTIAL DATA FOUND\n         LA    R6,DUMPDATA             POINT TO DATA TO DISPLAY\n         LA    R4,OUT1                 FIRST OUTPUT LINE ADDR\n         LA    R5,16                   NO. OF LINES TO DISPLAY\nDUMPLOOP DS    0H                      FORMAT THE DISPLAY\n         STCM  R2,15,TEMP2             ADDRESS TO SHOW\n         UNPK  TEMP1(9),TEMP2(5)       CONVERT BINARY TO HEX\n         MVC   9(8,R4),TEMP1           LOW ORDER 32 BITS\n         TR    9(8,R4),HEXTAB\n         STG   R2,TEMP3                Store 64 bit value 64 bit Joe\n         L     R2,TEMP3                64 bit address\n         LTR   R2,R2                   64 bit value       64 bit Joe\n         BZ    ITS31\n         STCMH R2,15,TEMP2             Store High Order   64 bit Joe\n         UNPK  TEMP1(9),TEMP2(5)       CONVERT BINARY TO H64 Bit Joe\n         MVC   0(8,R4),TEMP1           LOW ORDER 32 BITS  64 Bit Joe\n         TR    0(8,R4),HEXTAB                             64 bit Joe\n         B     SET64                                      64 Bit Joe\nITS31    DS    0H                                         64 bit Joe\n         MVC   0(8,R4),=C'00000000'    DUMMY FOR HI ORDER ADDRESS\nSET64    DS    0H                                         64 bit Joe\n         LG    R2,TEMP3                Reset R2           64 bit Joe\n         MVI   8(R4),C'_'              SEPARATE FROM HI ORDER 32 BITS\n         HEX   21,0                    CONVERT FIRST WORD TO HEX\n         HEX   31,4                    SECOND WORD TO HEX\n         HEX   41,8                    THIRD WORD\n         HEX   51,12                   FOURTH AND LAST WORD TO HEX\n         MVI   61(R4),C'*'             FRAME THE EBCDIC DISPLAY\n         MVI   78(R4),C'*'             FRAME THE OTHER SIDE\n         MVC   62(16,R4),0(R6)         COPY THE EBCDIC DATA\n         TR    62(16,R4),VALCHAR       DELETE INVALID CHARS\n         AH    R2,=H'16'               BUMP UP LINE       64 BIT jOE\n         LA    R6,16(,R6)              NEXT DATA AREA\n         LA    R4,80(,R4)              NEXT OUTPUT LINE\n         BCT   R5,DUMPLOOP             GO DO NEXT LINE\n         B     BLANKSC                 Try to blank out data not   1.1D\n         SPACE 2                                                   1.1D\nDUMPLN   DS    0H                      Fetch and dump each line    1.1D\n         LA    R4,OUT1                 FIRST OUTPUT LINE ADDR      1.1D\n         LA    R5,16                   NO. OF LINES TO DISPLAY     1.1D\nDUMPLP2  DS    0H                      FORMAT THE DISPLAY          1.1D\n         STCM  R2,15,TEMP2             ADDRESS TO SHOW             1.1D\n         UNPK  TEMP1(9),TEMP2(5)       CONVERT BINARY TO HEX       1.1D\n         MVC   0(8,R4),TEMP1                                       1.1D\n         TR    0(8,R4),HEXTAB                                      1.1D\n         LA    R0,16                   length of a line            1.1D\n         LA    R1,DUMPDATA             where to put data           1.1D\n         BAL   R14,GETSTOR             get it                      1.1D\n         B     DLKILL                  +0 no data found            1.1D\n         NOP   0                       +4 partial data found       1.1D\n         LA    R6,DUMPDATA             +8 all data found           1.1D\n         HEX   21,0                    CONVERT FIRST WORD TO HEX   1.1D\n         HEX   31,4                    SECOND WORD TO HEX          1.1D\n         HEX   41,8                    THIRD WORD                  1.1D\n         HEX   51,12                   FOURTH AND LAST WORD TO HEX 1.1D\n         MVI   61(R4),C'*'             FRAME THE EBCDIC DISPLAY    1.1D\n         MVI   78(R4),C'*'             FRAME THE OTHER SIDE        1.1D\n         MVC   62(16,R4),0(R6)         COPY THE EBCDIC DATA        1.1D\n         TR    62(16,R4),VALCHAR       DELETE INVALID CHARS        1.1D\nDLKILL   DS    0H                                                  1.1D\n         LA    R2,16(,R2)              NEXT LINE ADDR              1.1D\n*        LA    R6,16(,R6)              NEXT DATA AREA              1.1D\n         LA    R4,80(,R4)              NEXT OUTPUT LINE            1.1D\n         BCT   R5,DUMPLP2              GO DO NEXT LINE             1.1D\nBLANKSC  DS    0H                                                  1.1D\n         SPACE 2\n*----------------------------------------------------------------------\n*\n* NOW BLANK OUT THE SCREEN WHERE THE PAGE DIDN'T EXIST\n*\n*----------------------------------------------------------------------\n         SPACE 2\n         LA    R4,OUT1                 POINT TO FIRST OUTPUT LINE\n         SH    R2,=H'256'              FIRST ADDRESS DISPLAYED\n         LA    R5,16                   NUMBER OF LINES DISPLAYED\nBLLOOP   LA    R15,15(,R2)             LAST ADDRESS ON CURRENT LINE\n         CLC   LOGOOD,HIGOOD           ARE WE IN A WRAP CONDITION\n         BH    BLLP0                   YES SO SKIP NOLINE CHECK\n         CG    R2,HIGOOD               IF START>=HIGH    64 BIT     Joe\n         BNL   NOLINE                     THEN BLANK ENTIRE LINE\nBLLP0    C     R2,LOGOOD               IF START<LOW & END>=LOW\n         BNL   BLLP1                      THEN HI GOOD AND LOW NEEDS\n*                                                  BLANK\n         C     R15,LOGOOD\n         BNL   HIMIX\nBLLP1    CG    R2,HIGOOD               IF START<HIGH & END>HI64 BIT Joe\n         BNL   BLLP2                      THEN LOW GOOD AND BLANK\n*                                                HIGH\n         CG    R15,HIGOOD                                    64 bit Joe\n         BH    LOWOK\nBLLP2    DS    0H                      LINE OK OTHERWISE\n         B     BLOOPEND\n* BOTH LOW AND HIGH MISSING -- BLANK ENTIRE LINE\nNOLINE   DS    0H                                           64 BIT JOE\n*OLINE   MVI   12(R4),C' '             START OF DATA        64 BIT JOE\n*        MVC   13(57,R4),12(R4)        CLEAR THE LINE       64 BIT JOE\n         B     BLOOPEND                GO CHECK ANOTHER LINE\n* BR HERE IF LOW END GOOD, HIGH MAY BE  MISSING\nLOWOK    SG    R15,HIGOOD              # OF BYTES TO BLANK   64 BIT Joe\n* THE FOLLOWING CODE TAKES CARE OF LOW STORAGE WRAP\n         CH    R15,=H'15'              MORE THAN 15 BYTES TO CLEAR\n         BH    BLOOPEND                IF YES, IT WRAPPED, NO CLEAR\n         LR    R1,R15                  COPY # TO BLANK\n         SRL   R1,2                    FIND # OF WORDS\n         SLL   R1,1                    TWO BLANKS PER WORD\n         AR    R1,R15                  ADD NUMBER OF HEX CHARS\n         AR    R1,R15                  WHICH IS TWICE THE # OF BYTES\n         LA    R6,50(,R4)              POINT JUST AFTER HEX DATA\n         SR    R6,R1                   FIRST BYTE TO CLEAR\n         BCTR  R1,0                    REDUCE BY 1 FOR EXEXUTE\n         EX    R1,CLEARMVC             CLEAR HEX SIDE\n         LA    R6,69(,R4)              POINT TO TRAILING *\n         SR    R6,R15\n         EX    R15,CLEARMVC            CLEAR EBCDIC AND *\n         MVI   0(R6),C'*'              NOTE END OF EBCDIC DATA\n         B     BLOOPEND                GO CHECK NEXT LINE\n* COME HERE WHEN HI END GOOD AND LOW END MISSING\nHIMIX    L     R15,LOGOOD              LOWEST GOOD ADDR\n         SR    R15,R2                  NUMBER OF BYTES TO CLEAR\n         CH    R15,=H'16'              Total line                  1.1D\n         BNL   NOLINE                  Kill complete line          1.1D\n         LR    R1,R15                  COPY # TO CLEAR\n         SRL   R1,2                    # OF WORDS TO CLEAR\n         SLL   R1,1                    NUMBER OF IMBEDDED BLANKS\n         AR    R1,R15                  ADD # OF HEX CHARS\n         AR    R1,R15\n         BCTR  R1,0                    REDUCE BY 1 FOR MVC\n         LA    R6,12(,R4)              START OF HEX DATA\n         EX    R1,CLEARMVC             AND CLEAR THE HEX DATA\n         LA    R6,52(,R4)              POINT TO FIRST * ON LINE\n         EX    R15,CLEARMVC            CLEAR * AND EBCDIC DATA\n         LA    R6,52(R15,R4)           POINT TO FIRST CLEARED BYTE 1.1D\n         MVI   0(R6),C'*'              AND DROP IN A *\nBLOOPEND LA    R4,80(,R4)              POINT TO NEXT LINE\n         LA    R2,16(,R2)              ADDRESS ON NEXT LINE\n         BCT   R5,BLLOOP               AND SCAN ALL LINES\n         SPACE 2\n*----------------------------------------------------------------------\n*\n*  PUT IN ARROWS TO POINT TO DESIRED DATA\n*\n*----------------------------------------------------------------------\n         SPACE 2\n         LA    R4,OUT1                 ADDR OF FIRST LINE\n         TM    MODEFLAG,MIDDUMP        DOES IT BELONG IN THE MIDDLE\n         BZ    ARRTOP                  BR IF NOT\n         LA    R4,OUT9                 POINT TO MIDDLE LINE\nARRTOP   SR    R1,R1                   ASSUME NO QUADWORD ALIGNMENT\n         TM    MODEFLAG,ALIGN          WAS ASSUMPTION CORRECT\n         BZ    ARRALIGN                BR IF YES, ELSE GET OFFSET\n         LA    R1,15                   MASK FOR LOW 4 BITS\n         NR    R1,R2                   GET BYTE OFFSET FOR ARROW\n* FIRST DO THE EBCDIC SIDE\nARRALIGN LA    R15,60(,R4)             BYTE BEFORE FIRST *\n         EX    R1,MOVEMVC              MOVE THE DATA BACK\n         AR    R15,R1                  ADDR OF LAST BYTE MOVED\n         MVI   1(R15),C'>'             PUT IN THE ARROW\n* NOW MOVE THE HEX SIDE\n         SR    R0,R0                   CLEAR HIGH ORDER BITS\n         SLDL  R0,30                   WHICH WORD IS TO BE MOVED\n         SRL   R1,30                   NUMBER OF BYTES TO BE MOVED\n         LR    R15,R0                  COPY OFFSET OF WORD TO MOVE\n         MH    R15,=H'10'              EACH WORD TAKES UP 10 BYTES\n         LA    R15,19(R4,R15)          POINT IN FRONT OF WORD TO MOVE\n         SLL   R1,R1                   NUMBER OF HEX DIGITS TO MOVE\n         EX    R1,MOVEMVC              MOVE THE DATA BACK\n         AR    R15,R1                  POINT TO PLACE FOR ARROW\n         MVI   1(R15),C'>'             AND PUT IT THERE\n* FALL  THRU TO SHOW THE SCREEN\n         EJECT\n*\n* DISPLAY THE PAGE AND CHECK FOR END REQUEST\n*\nDISPLAY  UNPK  TEMP1(5),CURASID(3)     FORMAT CURRENT ASID\n         MVC   ASIDLN1(4),TEMP1        AND PUT ON SCREEN\n         TR    ASIDLN1(4),HEXTAB\n         MVC   SAVEASID,ASIDLN1        SAVE FORMATTED VERSION\n         MVC   KEYS,KEY1               SETUP PFK\n         MVC   KEYS+80,KEY2                 INFO LINE\n*\nTPUTSCRN DS    0H\n*        XGR   R4,R4                  Clear out data ptr 31 or 64 Joe\n         LA    R0,QDSLNG\n         TPUT  QDSCREEN,(0),FULLSCR MF=(E,QTPUT)\n         XC    INPLINE,INPLINE\n         XC    PFREPLY,PFREPLY\n         TGET  PFREPLY,69,ASIS MF=(E,QTGET)\n         LR    R3,R1                   SAVE INPUT LENGTH\n         CH    R15,=H'12'     IS INPUT LONGER THAN BUFFER?\n         BNE   NOCLEAR        NO. CONTINUE.\n         TCLEARQ INPUT        CLEAR THE QUEUE\nNOCLEAR  DS    0H\n*        MVC   MSGLINE,BLANKS          INDICATE NO ERROR           1.1A\n         LA    R1,PFREPLY+3            POINT AT FIRST BYTE\n         SH    R3,=H'3'                ADJUST LENGTH\n*\n**       HANDLE ASID IF NECESSARY\n*\n         CLC   0(3,R1),=X'1140F9'      IS THIS ASID MODIFICATION\n         BNE   NOASID                  NO SO SKIP\n         LA    R1,3(,R1)               POINT AT FIRST BYTE\n         SH    R3,=H'3'                ADJUST LENGTH\n         LR    R2,R1                   SAVE START ADDRESS\nASIDLOOP CLI   0(R1),X'11'             LOOK FOR START FIELD\n         BE    HAVEASID\n         LA    R1,1(,R1)               BUMP POINTER\n         BCT   R3,ASIDLOOP\nHAVEASID LR    R15,R1                  MOVE POINTER\n         SR    R15,R2                  GET LENGTH\n         BZ    NOASID\n         MVC   ASIDLN1,=CL4' '\n         LA    R4,ASIDLN1+4            GET TO ADDRESS +4\n         SR    R4,R15                      - REAL LENGTH\n         BCTR  R15,0                   GET MACHINE LENGTH\n         EX    R15,MOVERPLY\nNOASID   DS    0H\n         LTR   R3,R3                   ANY DATA LEFT\n         BZ    ENDINP\n         CLC   0(3,R1),=X'11C15C'      CHECK FOR START OF FIELD\n         BNE   ENDINP                  IF NOT HERE THEN SKIP\n         LA    R1,3(,R1)               POINT AT FIRST BYTE\n         SH    R3,=H'3'                ADJUST LENGTH\n         LR    R2,R1                   SAVE START ADDRESS\nRPLYLOOP CLI   0(R1),X'11'             LOOK FOR START FIELD\n         BE    HAVERPLY\n         LA    R1,1(,R1)               BUMP POINTER\n         BCT   R3,RPLYLOOP\nHAVERPLY LR    R15,R1                  MOVE POINTER\n         SR    R15,R2                  GET LENGTH\n         BZ    NOASID\n         LA    R4,INPLINE              GET TO ADDRESS\n         BCTR  R15,0                   GET MACHINE LENGTH\n         EX    R15,MOVERPLY\nENDINP   OC    INPLINE,=CL63' '        MAKE UPPERCASE\n         SPACE 2\n         IC    R4,PFCODE\n         XR    R5,R5\n         CLI   PFCODE,X'7D'      ENTER?\n         BE    ENTER             /YES - TREAT AS ENTER\n         CLI   PFCODE,X'F0'      TEST-REQ/SYS-REQ?\n         BE    ENTER             /YES - TREAT AS ENTER\n         CLI   PFCODE,X'01'      OTHER KIND OF SYS-REQ?\n         BE    ENTER             /YES - TREAT AS ENTER\n         CLI   PFCODE,X'6C'      PA1?\n         BE    ENDIT             /YES - TERMINATE\n         CLI   PFCODE,X'6E'      PA2?\n         BE    TPUTSCRN          /YES - GO RESHOW SCREEN\n         CLI   PFCODE,X'6B'      PA3?  (TCAM GENERATED)\n         BE    TPUTSCRN          /YES - GO RESHOW SCREEN\n         N     R4,=X'0000000F'   EXTRACT PF-KEY NUMBER\n         CH    R4,=H'12'\n         BH    ENTER            \"ENTER\" KEY\n         BCTR  R4,0\n         SLL   R4,2              TIMES SIZE OF AN ENTRY\n         B     PFKEYTAB(R4)\nPFKEYTAB B     HELP                    PF1\n         B     DISPLAY                 PF2\n         B     ENDIT                   PF3    QUIT\n         B     DISPLAY                 PF4\n         B     REPEAT                  PF5    REPEAT COMMAND\n         B     DISPLAY                 PF6\n         B     UP                      PF7    SCROLL UP\n         B     DOWN                    PF8    SCROLL DOWN\n         B     BACK                    PF9    SCROLL BACKWARDS\n         B     FWD                     PF10   SCROLL FORWARDS\n         B     DISPLAY                 PF11\n         B     DISPLAY                 PF12\nMOVERPLY MVC   0(0,R4),0(R2)           **EXECUTED**\n         EJECT\nENTER    CLC   =C'END',INPLINE         SEE IF END TYPED\n         BNE   ISCAN                   IF NOT, GO LOOK AT INPUT\n* CLEAN UP AND GO AWAY\nENDIT    DS    0H\n         LM    R0,R1,CSALEN            GET SP, LEN, AND ADDR\n         LTR   R1,R1                   WAS BUFFER GOTTEN\n         BZ    ENDIT1                  NOPE\n         FREEMAIN R,LV=(0),A=(1)       FREE BUFFER\nENDIT1   DS    0H                      NOT AUTH HANDLING\n*        TM    FLAGS,NOAUTH            ARE WE AUTHORIZED            Joe\n*        BO    ENDIT2                  NOPE                         Joe\n         MODESET MODE=PROB             RESET MODE\nENDIT2   DS    0H\n         STTMPMD OFF                                               1.1C\n         STFSMODE OFF                  RESET FULLSCREEN\n         LG    R13,SAVE+8              GET ORIGINAL SAVE AR 64 Bit Joe\n         FREEMAIN R,LV=WORKLEN,SP=1,A=(R10)\n         RETURN (14,12),RC=0\n* ----------------------------------------------------------------- *\nENDIT0   DS    0H\n         MVC   OUTAREA(80),NOTAUTHM\n         STM   R14,R1,SAVE14T1\n         TPUT  OUTAREA,80\n         LM    R14,R1,SAVE14T1\n         B     ENDIT2\nNOTAUTHM DC CL80'***** THIS PROGRAM MUST BE RUN APF AUTHORIZED *****'\n         EJECT\n*----------------------------------------------------------------------\n*\n* CBHIT  -- CONTROL BLOCK FORMATTING ROUTINE\n* AT ENTRY:\n*              R4 HAS ADDRESS TO DISPLAY (OFFSET 0 - MAIN SEGMENT)\n*              R5 HAS CONTROL BLOCK HEADER ADDRESS\n*\n*----------------------------------------------------------------------\n         SPACE 2\nCBHIT    LH    R2,CURRENT              GET HISTORY TABLE POINTER\n         A     R2,HISTORY              GET ENTRY ADDRESS\n         USING HIST,R2                 SETUP FORMAT OF ENTRY\n         ICM   R6,15,HISTCBSP          LAST SEGMENT DISPLAYED\n         BNZ   CBHIT2                  BR IF A CONTINUING DISPLAY\n         USING CBH,R5                  ADDRESS HEADER BLOCK\n         L     R6,CBHCBSP              ELSE GET FIRST SEG ADDRESS\n         ST    R6,HISTCBSP             AND SAVE FOR LATER\n         ST    R5,HISTCBHP             AND SAVE FOR LATER\n         OI    HISTCBHP,X'80'          NOTE CB FORMAT ROUTINE IN USE\n*   GET BLOCK NAME AND HANDLE ANY SEGMENT INDIRECTION\nCBHIT2   DS    0H\n         USING CBS,R6\n         L     R5,HISTCBHP             POINT TO CB HEADER\n         MVC   MSGLINE+36(8),CBHNAME   MOVE IN CB NAME\n         STG   R4,TEMP2             SAVE ADDRESS OF BLOCK    64 Bit Joe\n         CLC   TEMP2(4),=4X'00'     31 Bit Address           64 bit Joe\n         BE    MAKE31               YES; Forgot top half\n         UNPK  TEMP1(9),TEMP2(5)          AND CONVERT\n         TR    TEMP1(8),HEXTAB               TO HEX\n         MVC   MSGLINE+18(8),TEMP1     MOVE IN ADDRESS OF BLOCK\nMAKE31   DS    0H                                            64 Bit Joe\n         UNPK  TEMP1(9),TEMP2+4(5)        AND CONVERT        64 bit Joe\n         TR    TEMP1(8),HEXTAB               TO HEX          64 bit Joe\n         MVC   MSGLINE+26(8),TEMP1     MOVE IN ADDRESS OF BL 64 bit Joe\n         DROP  R2,R5\n         CLC   =H'0',CBSILEN           IS THIS SEGMENT INDIRECT\n         BE    CBHIT3                  IF NOT THEN SKIP CODE\n         LH    R0,CBSILEN              GET LENGTH TO FETCH (ALWAYS 4\n         LA    R1,DUMPDATA             WHERE TO PUT IT\n         LH    R2,CBSIOFF              GET INDIRECT OFFSET\n         AR    R2,R4                   GET TRUE MAIN BLOCK ADDRESS\n         BAL   R14,GETSTOR             GET THE INDIRECT WORD\n         B     NOCB                    BR IF NO DATA FETCHED\n         B     NOCB                    BR IF PARTIAL DATA FETCHED\n         L     R4,DUMPDATA             RESET THE ADDR TO DUMD\n         LH    R2,CURRENT\n         A     R2,HISTORY              GET ADDR OF ENTRY\n         ST    R4,HISTSADR-HIST(R2)    SAVE SEGMENT ADDRESS\nCBHIT3   DS    0H\n         LH    R0,CBSDLEN              LENGTH TO FETCH\n         LA    R1,DUMPDATA             TARGET ADDRESS\n         LH    R2,CBSDOFF              OFFSET TO FETCH\n         AR    R2,R4                   ADD START OF CB ADDRESS\n         BAL   R14,GETSTOR             GO FETCH THE DATA\n         B     NOCB                    BR IF NO DATA FETCHED\n         B     NOCB                    BR IF PARTIAL DATA FETCHED\n         LA    R5,OUT1-80              START OF SCREEN\n         LA    R2,DUMPDATA             POINT TO DATA BUFFER\n         SH    R2,CBSDOFF              BACKUP TO VIRTUAL CB ORIGIN\n         LA    R6,CBSLEN(,R6)          POINT AT FIRST CB FIELD\n         USING CBF,R6\nCBLOOP   DS    0H\n         LH    R1,CBFLINE              GET LINE NUMBER\n         MH    R1,=H'80'               TIMES LINE LENGTH\n         AH    R1,CBFCOLM              PLUS THE COLUMN NUMBER\n         AR    R1,R5                   PLUS START OF LINE\n         MVC   0(8,R1),CBFNAME         SET NAME FIELD\n         LA    R1,8(,R1)               SKIP NAME\n         LH    R14,CBFOFFS             GET OFFSET INTO CB\n         AR    R14,R2                  GET ADDRESS IN FETCHED DATA\n         SR    R15,R15                 CLEAR REGISTER\n         IC    R15,CBFDLEN             GET LENGTH OF DATA ITEM\n         LA    R0,80-8                 get max column less label   1.1D\n         SH    R0,CBFCOLM              and starting col number     1.1D\n*   FORMAT CHARACTER AS DISPLAY AND REST AS HEX\n         CLI   CBFTYPE,C'C'            WHAT IS TYPE\n         BNE   CBFLP1                  IF NOT CHAR THEN DO HEX     1.1D\n         CR    R15,R0                  see if data too big         1.1D\n         BNH   *+6                     use actual length           1.1D\n         LR    R15,R0                  truncate data               1.1D\n         BCTR  R15,0                   GET MACHINE LENGTH\n         EX    R15,CBMVC               MOVE IN DATA\n         EX    R15,CBTR                OUTPUT ONLY VALID CHARS      1.1\n         B     CBFEND\nCBFLP1   SRL   R0,1                    convert columns to bytes    1.1D\n         CR    R15,R0                  see if data too big         1.1D\n         BNH   *+6                     use actual length           1.1D\n         LR    R15,R0                  truncate data               1.1D\nCBFLOOP  MVC   TEMP2(1),0(R14)         MOVE IN DATA BYTE\n         UNPK  TEMP1(3),TEMP2(2)\n         TR    TEMP1(2),HEXTAB\n         MVC   0(2,R1),TEMP1           MOVE IN CONVERTED BYTE\n         LA    R1,2(,R1)               BUMP OUTPUT ADDRESS\n         LA    R14,1(,R14)             BUMP INPUT ADDRESS\n         BCT   R15,CBFLOOP             KEEP LOOPINT\nCBFEND   LA    R6,CBFLEN(,R6)          BUMP TO NEW FIELD\n         CLC   0(4,R6),=F'0'           END OF SEGMENT\n         BNE   CBLOOP                  IF NOT THEN KEEP GOING\n         B     DISPLAY                 ALL DONE SO DISPLAY IT\n         DROP  R6\n         SPACE 1\nCBMVC    MVC   0(0,R1),0(R14)          **EXECUTED** MOVE IN DATA\nCBTR     TR    0(0,R1),VALCHAR         **EXECUTED** MAKE VALID      1.1\n         SPACE 2\n*----------------------------------------------------------------------\n*\n*  GET ADDRESS OF CURRENT CONTROL BLOCK SEGMENT\n*     ON EXIT R2 = ADDR OF THIS CONTROL BLOCK SEGMENT\n*\n*----------------------------------------------------------------------\nGETCURAD DS    0H\n         LH    R2,CURRENT              GET HIST TABLE OFFSET\n         A     R2,HISTORY              GET ENTRY\n         USING HIST,R2\n         CLC   =F'0',HISTSADR          IS SEGMENT A SECONDARY SEGMENT\n         BE    GCA1                    NOPE, SO SKIP CODE\n         L     R2,HISTSADR             GET ADDRESS OF BLOCK\n         BR    R14\nGCA1     LG    R2,HISTADDR             GET MAIN BLOCK ADDR  64 Bit Joe\n         BR    R14\n         DROP  R2\n         EJECT\n***********************************************************************\n*\n* COMMAND ROUTINES\n*\n         SPACE 2\n*----------------------------------------------------------------------\n*\n* HELP -- DISPLAY HELP INFORMATION\n*\n*----------------------------------------------------------------------\n         SPACE 2\nHELP     DS    0H\n         LA    R1,16*80\n         LR    R3,R1\n         L     R2,=A(HELPMSG)      POINT AT FROM\n         LA    R0,OUT1\n         MVCL  R0,R2\n         B     DISPLAY\n         SPACE 2\n*----------------------------------------------------------------------\n*\n* REFRESH -- REFETCH THE CORE AND REDISPLAY IT\n*\n*----------------------------------------------------------------------\n         SPACE 2\nREFRESH  OI    FLAGS,RFRSH             SET REFRESH FLAG\n         B     FORMAT                  REFORMAT SCREEN\n         SPACE 2\n*----------------------------------------------------------------------\n*\n* OVERLAY  --  MANIPULATE CONTROL BLOCK FORMATTING\n*\n*----------------------------------------------------------------------\n         SPACE 2\nOVERLAY  CLC   =C'NULL',INPLINE+1      SEE IF NO FORMATTING WANTED\n         BE    OVERNULL                BR IF YES\n         L     R5,=V(CBMACS)           GET CB MAP INDEX\n         LTR   R5,R5                   ANY MAPS\n         BZ    OVERNULL                IF NOT TREAT AS NULL OVERLAY\n         USING CBH,R5                  SETUP ADDRESSABILITY\nOVERLOOP CLC   =F'0',CBHNEXT           END OF CONTROL BLOCKS\n         BE    FORMAT                  IF YES, IGNORE COMMAND\n         CLC   INPLINE+1(8),CBHNAME    SEE IF CB MATCH\n         BE    OVERHIT                 BR IF YES\n         L     R5,CBHNEXT              ELSE POINT TO NEXT ENTRY\n         B     OVERLOOP                AND KEEP LOOKING\nOVERHIT  L     R6,CBHCBSP              START SEG ADDR FOR CB FOUND\n         LH    R2,CURRENT              CURRENT HIST TABLE ENTRY OFFSET\n         A     R2,HISTORY              GET ENTRY ADDRESS\n         USING HIST,R2                 SETUP ENTRY FORMAT\n         ST    R5,HISTCBHP             POINT AT HEADER\n         ST    R6,HISTCBSP             POINT AT SEGMENT(FIRST)\n         OI    HISTCBHP,X'80'          MARK AS CB\n         XC    HISTSADR,HISTSADR       CLEAR SEC SEG ADDR\n         B     FORMAT                  GO SHOW IT\n         SPACE 1\nOVERNULL LH    R2,CURRENT              CURRENT HIST TABLE ENTRY OFFSET\n         A     R2,HISTORY              POINT AT CURRENT ENTRY\n         MVC   HISTCBHP,=X'7FFFFFFF'   SUPPRESS CB OVERLAY\n         B     FORMAT                  GO SHOW STORAGE\n         DROP  R5,R2\n         SPACE 2\n*----------------------------------------------------------------------\n*\n* DOWN -- SCROLL DOWN 256 BYTES OR NEXT CTRL BLK SEGMENT\n*\n*----------------------------------------------------------------------\n         SPACE 2\nDOWN     LLGH  R2,CURRENT              CURRENT HIST TABLE POINTER\n         A     R2,HISTORY              POINT TO HIST TABLE ENTRY\n         USING HIST,R2                 SETUP ENTRY FORMAT\n         TM    HISTCBHP,X'80'          SEE IF THIS IS A CB DISPLAY\n         BO    DOWNCB                  BR IF YES\n         LG    R1,HISTADDR             ELSE GET ADDR TO SHOW 64 Bit Joe\n         AH    R1,=H'256'              AND MOVE DOWN ONE SCREEN\n         STG   R1,HISTADDR             AND REPLACE IN HIST TA64 Bit Joe\n         B     FORMAT                  GO DISPLAY IT\nDOWNCB   L     R1,HISTCBSP             GET CB SEGMENT ADDR\n         L     R1,CBSNEXT-CBS(,R1)     GET NEXT SEG ADDR\n         ST    R1,HISTCBSP             AND PUT IN HIST TABLE\n         XC    HISTSADR,HISTSADR       CLEAR SEC SEG ADDR\n         B     FORMAT                  GO SHOW IT\n         DROP  R2\n         SPACE 2\n*----------------------------------------------------------------------\n*\n* UP   -- SCROLL UP   256 BYTES OR PREV CTRL BLK SEGMENT\n*\n*----------------------------------------------------------------------\n         SPACE 2\nUP       LLGH  R2,CURRENT              CURRENT HIST TABLE POINTER\n         A     R2,HISTORY              POINT TO HIST TABLE ENTRY\n         USING HIST,R2                 SETUP FORMAT OF ENTRY\n         TM    HISTCBHP,X'80'          SEE IF THIS IS A CB DISPLAY\n         BO    UPCB                    BR IF YES\n         LG    R1,HISTADDR             ELSE GET ADDR TO SHOW 64 Bit Joe\n         SH    R1,=H'256'              AND MOVE UP ONE SCREEN\n         STG   R1,HISTADDR             AND REPLACE IN HIST TA64 Bit Joe\n         B     FORMAT                  GO DISPLAY IT\nUPCB     L     R1,HISTCBSP             GET CB SEGMENT ADDR\n         L     R1,CBSPREV-CBS(,R1)     GET PREV SEG ADDR\n         ST    R1,HISTCBSP             AND PUT IN HIST TABLE\n         XC    HISTSADR,HISTSADR       CLEAR SEC SEG ADDR\n         B     FORMAT                  GO SHOW IT\n         DROP  R2\n         SPACE 2\n*----------------------------------------------------------------------\n*\n* REPEAT -- REPEAT LAST INPUT LINE\n*\n*----------------------------------------------------------------------\n         SPACE 2\nREPEAT   MVC   INPLINE(52),INPSAVE     COPY SAVED INPUT\n         B     ISCAN2                  AND PROCESS IT\n         SPACE 2\n*----------------------------------------------------------------------\n*\n* LINK -- LINK TO LABELED CONTROL BLOCK FIELD\n*\n*----------------------------------------------------------------------\n         SPACE 2\nLINK     LH    R2,CURRENT              CURRENT HIST TABLE POINTER\n         A     R2,HISTORY              POINT TO HIST TABLE ENTRY\n         USING HIST,R2                 SETUP FORMAT OF ENTRY\n         TM    HISTCBHP,X'80'          SEE IF CB FORMATTING IN USE\n         BO    LINK2                   BR IF YES\nLINKERR  MVC   MSGLINE,LINKMSG         NOTE ERROR IN LINK\n         B     FORMAT                  AND RESHOW SCREEN\nLINK2    L     R3,HISTCBSP             GET CURRENT CB SEG ADDRESS\n         LA    R5,0(,R3)               CLEAR FLAGS AND SETUP FOR COMP\n         USING CBS,R4\nLINK2A   LR    R4,R3                   SAVE THE START OF SEG ADDR\n         LA    R3,CBSLEN(,R3)          POINT PAST SEG HEADER\n         USING CBF,R3\nLINK3    CLC   CBFNAME(4),=F'0'        END OF SEGMENT\n         BE    LINK4\n         CLC   CBFNAME,INPLINE+1       DOES NAME MATCH\n         BE    LINKFND                 IF SO THEN FOUND\n         LA    R3,CBFLEN(,R3)          POINT PAST THIS ONE\n         B     LINK3                   KEEP LOOKING\nLINK4    DS    0H\n         L     R3,CBSNEXT              POINT TO NEXT SEGMENT\n         CR    R3,R5                   ARE WE BACK AT START\n         BNE   LINK2A                  IF NOT KEEP GOING\n         B     LINKERR                 IF NOT THEN ISSUE ERROR\n         DROP  R4,R2\n* A MATCH HAS  BEEN FOUND. FETCH THE  ADDRESS TO LINK TO\nLINKFND  DS    0H\n         SR    R0,R0                   CLEAR FOR IC\n         IC    R0,CBFDLEN              LENGTH OF ITEM  MINUS 1\n         LA    R1,DUMPDATA             ADDR TO PLACE DATA IN\n         BAL   R14,GETCURAD            GET ADDR OF CURRENT SEGMENT\n         AH    R2,CBFOFFS              OFFSET OF ITEM TO FETCH\n         BAL   R14,GETSTOR             FETCH THE  ADDRESS\n         B     LINKERR                 BR IF DATA CANT BE FETCHED\n         B     LINKERR                 BR IF DATA CANT BE FETCHED\n         BAL   R15,FWDSUB              UPDATE HIST TABLE TO NEXT\n         L     R0,DUMPDATA             LOAD ADDRESS THAT WAS FETCHED\n         SR    R15,R15                 NOW ADJUST THE\n         IC    R15,CBFDLEN               FETCHED DATA\n         LA    R1,4                        SO THAT\n         SR    R1,R15                        IT IS RIGHT\n         BNP   LF1                             JUSTIFIED IN\n         SLL   R1,3                              REGISTER IF\n         SRL   R0,0(R1)                            LESS THAN 4\nLF1      DS    0H                                    BYTES\n         LH    R2,CURRENT              NEW HIST TABLE POINTER\n         A     R2,HISTORY              GET ENTRY ADDRESS\n         USING HIST,R2\n         STG   R0,HISTADDR             SAVE NEW ADDRESS     64 Bit Joe\n         XC    HISTCBHP,HISTCBHP          AND\n         XC    HISTCBSP,HISTCBSP            CLEAR\n         XC    HISTSADR,HISTSADR               REST\n         B     FORMAT                  GO FORMAT THE NEW CB\n         DROP  R3,R2\n         SPACE 2\n*----------------------------------------------------------------------\n*\n*  SET INDIRECT FLAG\n*\n*----------------------------------------------------------------------\n         SPACE 2\nINDIR64  OI    FLAGS,IND64             SET FLAG\nINDIR31  OI    FLAGS,IND31             SET FLAG\nINDIR    OI    FLAGS,INDFLAG           SET FLAG\n         LA    R3,1(,R3)               UPDATE SCAN POINTER\n         CLI   INPLINE+1,C' '          USE CURRENT ADDRESS\n         BNE   NUMSCAN                 IF NO, GO SCAN INPUT ADDRESS\n         BAL   R14,GETCURAD\n         LR    R4,R2                   MOVE TO RIGHT REGISTER\n         B     ENDNUM\n         SPACE 2\n***********************************************************************\n*\n*  ESTABLISH SCREEN MODE\n*\n***********************************************************************\n         SPACE 2\nMODE     CLC   =C'1 ',INPLINE+1        MODE ONE TEST\n         BE    MODE1                   BR IF YES\n         CLC   =C'0 ',INPLINE+1        CHECK FOR MODE ZERO         1.1D\n         BNE   INVAL                   IF NOT EITHER, INVALID\n         NI    MODEFLAG,255-MIDDUMP    MODE 0 MEANS BACKUP 0\n         B     FORMAT\nMODE1    OI    MODEFLAG,MIDDUMP        MODE 1 MEANS BACK UP 7 LINES\n         B     FORMAT\nINVAL    MVC   MSGLINE,MODEMSG\n         B     FORMAT\nBADADDR  MVC   MSGLINE,INVADDR\n         B     TPUTSCRN\nPRGCHK   MVC   MSGLINE,PROGCHK\n         B     TPUTSCRN\nLOOKCHK  DS    0H\n         L     R8,CSAWORK\n         USING WORK,R8\n         MVC   MSGLINE(L'LOOKABD),LOOKABD\n         UNPK  WORKA(5),ABEND_CODE(3)\n         TR    WORKA(5),HEXTAB\n         MVC   MSGLINE+12(3),WORKA+1\n         UNPK  WORKA(5),REACDE+1(3)\n         TR    WORKA(5),HEXTAB\n         MVC   MSGLINE+23(3),WORKA+2\n         UNPK  WORKA,OFFSET+2(3)\n         TR    WORKA,HEXTAB\n         MVC   MSGLINE+34(4),WORKA+1\n         B     TPUTSCRN\n         SPACE 2\n***********************************************************************\n*\n*  MANIPULATE HISTORY TABLE\n*\n***********************************************************************\n         SPACE 2\nFWD      BAL   R15,FWDSUB              FORWARD 1 IN HIST TABLE\n         B     FORMAT\n         SPACE\nFWDSUB   LH    R1,CURRENT              CURRENT ENTRY INDEX\n         LA    R1,HISTLEN(,R1)\n         CH    R1,=AL2(50*HISTLEN)     SEE IF WRAP NEEDED\n         BL    FWDEND                  BR IF NOT\n         SR    R1,R1                   WRAP TO BEGINNING\nFWDEND   STH   R1,CURRENT              STORE NEW OFFSET\n         BR    R15                     RETURN TO CALLER\n         SPACE 1\nBACK     LH    R1,CURRENT\n         SH    R1,=AL2(HISTLEN)        BACK UP ONE ENTRU\n         BNM   BACKEND                 BR IF NO BACKWARD WRAP\n         LA    R1,49*HISTLEN           ELSE GO TO END OF TABLE\nBACKEND  STH   R1,CURRENT              SAVE RESULT\n         B     FORMAT\n         SPACE 2\n***********************************************************************\n*\n*   ADD ENTRY TO SYMBOL TABLE\n*\n***********************************************************************\n         SPACE 2\nDEFINE   LA    R15,50                  NUMBER OF TABLE ENTRIES\n         LA    R2,NAMES                START OF TABLE\nDEFLOOP1 CLI   0(R2),X'0'              SEE IF UNUSED ENTRY\n         BE    NSPACE                  BR IF SPACE FOUND\n         LA    R2,12(,R2)              NEXT ENTRY ADDR\n         BCT   R15,DEFLOOP1            TRY ALL ENTRIES\n         MVC   MSGLINE,SYMFULL         TABLE IS FULL\n         B     FORMAT\nNSPACE   LA    R15,9                   MAX LENGTH +1\n         LA    R0,INPLINE+1            ADDR OF FIRST BYTE\n         LR    R1,R0                   COPY SYMBOL ADDR\nDEFLOOP2 CLI   0(R1),C' '              SEE IF END OF SYM\n         BE    DEFEND                  BR IF YES\n         LA    R1,1(,R1)               POINT TO NEXT BYTE\n         BCT   R15,DEFLOOP2            CONTINUE FOR 9 BYTES\nDEFBAD   MVC   MSGLINE,DEFMSG          SYMBOL TOO LONG OR TOO SHORT\n         B     FORMAT2                 DISPLAY WITH CURSOR AT ERROR\nDEFEND   SR    R1,R0                   SYMBOL LENGTH\n         BZ    DEFBAD                  NULL SYMBOL ILLEGAL\n         BCTR  R1,R0                   FOR EXECUTE\n         MVC   0(8,R2),=CL8' '         CLEAR TABLE ENTRY\n         EX    R1,DEFMOVE              MOVE SYMBOL\n         LH    R1,CURRENT              GET CURRENT ADDRESS\n         A     R1,HISTORY\n         LG    R1,HISTADDR-HIST(,R1)                         64 Bit Joe\n         ST    R1,8(,R2)               STORE WITH SYMBOL\n         B     FORMAT\nDEFMOVE  MVC   0(0,R2),INPLINE+1       EXECUTED TO MOVE SYMBOL\n         SPACE 2\n***********************************************************************\n*\n*  SCAN THE ADDRESS EXPRESSION\n* REGISTER USAGE\n* R2 LAST NUMBER SCANNED\n* R3 SCAN POINTER\n* R4 CURRENT OUTPUT VALUE\n* R5 LAST OPERATOR SCANNED\n*\n***********************************************************************\n         SPACE 2\nNUMSCAN  DS    0H\n         BAL   R14,GETCURAD            CURRENT ENTRY IS DEFAULT\n*        LR    R4,R2                   CURRENT ENTRY IS DEFAULT\n         LGR   R4,R2                   CURRENT ENTRY IS      64 bit joe\n         LA    R5,0                    ASSUME DEFAULT TO BE TAKEN\n         CLI   0(R3),C'+'              SEE IF PREFIX PLUS\n         BNE   NOTPLUS                 BR IF NOT\n         LA    R5,4                    INDICATE PLUS OPERATOR\n         B     NUMOP                   GO TO ADV POINTER\nNOTPLUS  CLI   0(R3),C'-'              IS IT PREFIX MINUS\n         BNE   NUMLOOP                 BR IF NOT, USE DEFAULT AS LOAD\n         LA    R5,8                    INDICATE MINUS OPERATOR\nNUMOP    LA    R3,1(,R3)               POINT TO NEXT INPUT BYTE\nNUMLOOP  CLI   0(R3),C','              SEE IF NAME INDICATED\n         BE    NAMESCAN                BR IF YES\n         TRT   0(17,R3),NUMTAB          SEARCH FOR DELIMITER 64 bit Joe\n         LR    R6,R3                   SAVE START OF NUMBER\n         BC    8,BADSTUFF              BR IF INPUT TOO LONG\n         LR    R3,R1                   UPDATE SCAN POINTER\n         SR    R1,R6                   GET LENGTH OF INPUT\n         BZ    BADSTUFF                BR IF ZERO INPUT\n         MVC   TEMP1(16),=CL16' '       CLEAR TEMP AREA     64 bit  Joe\n         LA    R15,TEMP1+16            RIGHT JUSTIFY INPUT  64 bit  Joe\n         SR    R15,R1                  POINT TO RIGHT SPOT IN TEMP AREA\n         BCTR  R1,0                    PREPARE FOR EX\n         EX    R1,HEXMOVE              MOVE INPUT RIGHT JUSTIFIED\n         TR    TEMP1(16),HEXTAB         TRANSLATE TO HEX    64 bit  Joe\n         PACK  TEMP2(5),TEMP1(9)        CONVERT HEX TO BINA 64 bit  Joe\n         MVC   TEMP3(4),TEMP2\n         PACK  TEMP2(5),TEMP1+8(9)      CONVERT HEX TO BINA 64 bit  Joe\n         MVC   TEMP3+4(4),TEMP2                             64 bit  Joe\n         LG    R2,TEMP3                                     64 Bit  Joe\n*        ICM   R2,15,TEMP2             NEW DISPLAY ADDRESS\n         L     R8,CSAWORK              Get Csa Address\n         USING WORK,R8                                      64 Bit  Joe\n         STG   R2,START_ADDR           Starting Address\n         MVC   LEN,=F'100'             ** Temp **\nNUMDELIM EX    0,OPER(R5)              EXECUTE PREVIOUS OPERATOR\n         CLI   0(R3),C' '              IS DELIM A BLANK\n         BE    ENDNUM                  IF YES, END SCAN\n         LA    R5,4                    PLUS OPERATOR CODE\n         CLI   0(R3),C'+'              IS OPER L PLUS\n         BE    NUMOP                   BR IF YES TO CONTINUE SAAN\n         LA    R5,8                    MINUS CODE\n         CLI   0(R3),C'-'              IS OPER MINUS\n         BE    NUMOP                   BR IF YES\n         MVC   MSGLINE,INVALOP         ELSE BAD DELIMITER\n         B     FORMAT2                 DISPLAY WITH CURSOR AT ERROR\nENDNUM   TM    FLAGS,INDFLAG           IS THIS AN INDIRECT REQ\n         BZ    NOTIND                  BR IF NOT\n         TM    FLAGS,IND31+IND64       DO WE WANT 31 BIT INDI64 BIT JOE\n         BNZ   *+8                     SKIP CLEAR IF YES\n         ICM   R4,8,=X'00'             CLEAR TOP BYTE\n*        LR    R2,R4                   SET ADDR TO GET FROM\n         LGR   R2,R4                   SET ADDR TO GET   64 bit Joe\n         TM    FLAGS,IND64             64 BIT ADDRESS    64 bit Joe\n         BZ    GET31                                     64 Bit Joe\n         LA    R0,8                    Address 64 bit    64 Bit Joe\n         B     GOTOSTOR                Get the Address   64 bit Joe\nGET31    DS    0H                                        64 Bit Joe\n         LA    R0,4                    NUMBER OF BYTES TO64 bit Joe\nGOTOSTOR DS    0H                                        64 Bit Joe\n         LA    R1,DUMPDATA             WHERE TO PUT IT\n         BAL   R14,GETSTOR             DO MEMORY FETCH\n         B     BADIND                  NONE GOT\n         B     BADIND                  SOME BUT NOT ALL GOT\n         TM    FLAGS,IND64             64 BIT ADDRESS    64 bit Joe\n         BZ    TRTONEAD                                  64 BIt Joe\n         LG    R4,DUMPDATA             DO THE INDIRECT   64 bit Joe\n         B     CKHIBIT                                   64 bit Joe\nTRTONEAD DS    0H                                        64 Bit Joe\n         LLGT  R4,DUMPDATA             DO THE INDIRECT   64 Bit Joe\n* --->\nCKHIBIT  DS    0H\n         TM    FLAGS,AMOD64   BIGGER ADDRESS THAN 8 HEX BYTES?\n         BO    KEEPHIG        DON'T NULLIFY BIT 0 OF 32\n         CLMH  R4,15,=4X'00'  64 bit address                    Joe\n         BNE   KEEPHIG        64 bit address                    Joe\n         N     R4,=X'7FFFFFFF'         TURN OFF TOP BIT ALWAYS\nKEEPHIG  DS    0H\n* --->\nNOTIND   BAL   R15,FWDSUB              UPDATE HISTORY POINTR\n         LLGH  R2,CURRENT              NEW HIST TABLE POINTER64 Bit Joe\n         A     R2,HISTORY              GET ENTRY ADDRESS\n         USING HIST,R2\n         STG   R4,HISTADDR             SAVE NEW ADDRESS      64 Bit Joe\n         XC    HISTCBHP,HISTCBHP          AND\n         XC    HISTCBSP,HISTCBSP            CLEAR\n         XC    HISTSADR,HISTSADR               REST\n         B     FORMAT\n         DROP  R2\nBADIND   MVC   MSGLINE,BADIMSG         MOVE IN MESSAGE\n         B     FORMAT                  GO AND REDISPLAY\n         SPACE 2\n* SCAN INPUT FOR A NAME IN THE SYMBOL TABLE\nNAMESCAN LA    R3,1(,R3)               SKIP OVER COMMA\n         LR    R1,R3                   COPY INPUT POINTER\n         LA    R15,9                   MAX LENGTH +1\nNAMELOOP DS    0H\n* --- >\n         C     R15,=F'8'               MORE THAN 9 CHARACTERS?\n         BH    FLAGSMAL                NO. NOT 64-BIT ADDRESS.\n         OI    FLAGS,AMOD64            SHOW WE NEED HIGHER ADDRESS\nFLAGSMAL DS    0H\n* --- >\n         CLI   0(R1),C'A'              SEE IF VALID CHAR\n         BL    NAMEEND                 BR IF NOT, DELIM FOUND\n         LA    R1,1(,R1)               POINT TO NEXT BYTE\n         BCT   R15,NAMELOOP            ALLOW EIGHT BYTES PLUS DELIM\nNAMEBAD  MVC   MSGLINE,NAMEMSG         NULL NAME OR NAME TOO LONG\n         B     FORMAT2                 DISPLAY WITH CURSOR AT ERROR\nNAMEEND  SR    R1,R3                   FIND LENGTH\n         BZ    BADSTUFF                BR IF TOO SHORT\n         MVC   TEMP1(8),=CL8' '        CLEA\u00a2  WORK AREA\n         BCTR  R1,0                    SET UP FOR EX\n         EX    R1,NAMEMOVE             MOVE TO WORK AREA, BLANK PAD\n         LA    R3,1(R3,R1)             UPDATE POINTER\n         LA    R15,50                  ENTRIES IN SYM TABLE\n         LA    R1,NAMES                START OF SYM TABLE\nNAMELP2  CLC   TEMP1(8),0(R1)          SEE IF NAME IN TABLE\n         BE    NAMEFIND                BR IF YES\n         LA    R1,12(,R1)              POINT TO NEXT ENTRY\n         BCT   R15,NAMELP2             BR IF ANY ENTRIES LEFT\n         B     NAMEBAD                 BR IF NONE LEFT, UNDEFUNED SYM\nNAMEFIND L     R2,8(,R1)               GET SYMBOL VALUE\n         B     NUMDELIM                USE IN EXPRESSION\n*  THESE INSTRUCTIONS ARE THE OBJECT OF AN EXECUTE\nOPER     LGR   R4,R2                   USE HIST TABLE AS DEF64 Bit Joe\n         AGR   R4,R2                   PLUS OPERATOR\n         SGR   R4,R2                   MINUS OPERATOR\nHEXMOVE  MVC   0(0,R15),0(R6)          RIGHT JUSTIFY INPUT DATA\nNAMEMOVE MVC   TEMP1(1),0(R3)          PAD NAME WITH BLANKS BY MOVING\n         SPACE\nBADSTUFF MVC   MSGLINE,ERRMSG          NOTE BAD INPUT\n         B     FORMAT2                 DISPLAY WITH CURSOR AT ERROR\n         SPACE 2\n         SPACE 2\n*----------------------------------------------------------------------\n*\n* ERASE  --  CLEAR THE SCREEN BUFFER\n*\n*----------------------------------------------------------------------\n         SPACE 2\nERASE    SAVE  (2,5)                   NEED SOME WORK REGS\n         LA    R2,OUT1                 START OF AREA TO CLEAR\n         LA    R3,80*16                LENGTH TO CLEAR\n         LA    R5,C' '                 FILL CHAR\n         SLL   R5,24                   MAKE PAD BYTE AND CLEAR SOURCE\n         MVCL  R2,R4                   PROPAGATE BLANKS\n         RETURN (2,5)                  RESTORE REGS AND RETURN\n         EJECT\n* EXECUTED INSTRUCTIONS AND CONSTANTS\nCLEARMVC MVC   0(0,R6),BLANKS          CLEAR SOME SPACE\nMOVEMVC  MVC   0(0,R15),1(R15)         MOVE DATA BACKWARDS\n***********************************************************************\n*\n*\n*        FETCH SOME STORAGE\n*\n*              R0  =  LENGTH TO FETCH <=4096 (MAXFETCH)\n*              R1  => WHERE TO PUT IT\n*              R2  => WHERE TO GET IT FROM\n*\n*\n***********************************************************************\n*ETSTOR  SAVE  (14,8)                  SAVE REGS\nGETSTOR  STMG  R14,R8,24(R13)          SAVE REGS          64 bit   Joe\n*        MODESET KEY=ZERO\n         L     R8,CSAWORK              POINT TO CSA AREA            1.1\n         USING WORK,R8                 SETUP ADDRESSABILITY         1.1\n         MVI   MERRCD,0                INDICATE NO ERROR ON FETCH   1.1\n         CLMH  R2,15,=4X'00'           Is top Part pop       64 bit Joe\n         BNE   NOCLR64                 Dont CLear it         64 bit Joe\n         LA    R2,0(0,R2)              clear top bit               1.1D\nNOCLR64  DS    0H\n         CL    R0,=A(MAXFETCH)         Max fetchable size          1.1D\n         BL    *+8                     Requested ok                1.1D\n         L     R0,=A(MAXFETCH)         Force smaller               1.1D\n*\n*        CHECK IF DATA IS IN BUFFER\n*\n         CLC   CSAASID,CURASID         WANT SAME ASID\n         BNE   GETMORE                 NOPE\n         CG    R2,CSASTAR              CHECK FOR BEGINNING 64 bit Joe\n         BL    GETMORE\n         LR    R15,R0                  GET LENGTH\n         AGR   R15,R2                  GET END ADDRESS       64 Bit Joe\n         CG    R15,CSAEND              CHECK FOR END         64 BIT Joe\n         BH    GETMORE                 NOPE NOT IN BUFFER\n         TM    FLAGS,RFRSH             IS IT REFRESH REQUEST\n         BO    GETMORE                 REGET THE CORE\nMOVEBUF  LG    R15,CSASTAR             GET VIRT ADDR OF BUFFE64 BIT jOE\n         SGR   R2,R15                  GET DISPLACEMENT IN BU64 BIT JOE\n         A     R2,CSABUF               POINT TO BUFFER\n         LR    R3,R0                   MOVE LENGTH\n         LR    R0,R1                   SET \"TO\" ADDR\n         LR    R1,R3                   SET LENGTH\n         MVCL  R0,R2\n*        LM    R14,R8,12(R13)          RESTORE REGS                 1.1\n         LMG   R14,R8,24(R13)          RESTORE REGS     64 BIT     Joe\n         B     8(R14)                  RETURN ALL GOTTEN\nGETMORE  DS    0H\n         MVC   LENGTH,=F'2048'         Initial fetch is half page  1.1C\n         C     R0,LENGTH               Is req for more than default1.1D\n         BNH   *+8                     No  so skip                 1.1D\n         ST    R0,LENGTH               Set first request for actual1.1D\n         STG   R2,ADDR                 SAVE ADDR TO GET COR64 BIT Joe\n         STG   R2,CSASTAR              SET CSA VIRT BUFFER 64 bit Joe\n         NI    FLAGS,255-REFETCH       inidicate first fetch       1.1C\nGETM2    DS    0H                                                  1.1C\n         MVI   MERRCD,0                INDICATE NO ERROR ON FETCH  1.1C\n         NI    FLAGS,255-RFRSH         TURN OFF FLAG\n         MVC   CSAASID,CURASID         SET ASID OF CSABUFFER CONTENTS\n         MVI   FLAG1,0                 CLEAR FLAGS\n         MVI   FLAG2,0\n         CLC   CURASID,MYASID          ARE WE IN THIS ADDR SPACE\n         BNE   DOSRB                   IF NOT USE SRB\n*\n*        INVOKE SRB CODE AS SUBROUTINE\n*\n         OI    FLAG1,FG1SUBR           FLAG AS SUBROUTINE\n         LA    R2,DMYPRMS              SETUP DUMMY FRR PARMS\n*        TM    FLAGS,NOAUTH            ARE WE AUTHORIZIED          1Joe\n*        BO    DOSUB1                  NO SO SKIP                  1Joe\n         MODESET KEY=ZERO              GET TO KEY ZERO             1.1E\n         SPKA  0                                                    Joe\nDOSUB1   DS    0H                                                  1.1E\n         XC    DMYPRMS,DMYPRMS\n         LR    R1,R8                   SETUP PARM REGISTER\n         ST    R7,SAVE7                Need another Base  64 bit   Joe\n         LA    R15,D#SRBCD             SETUP ENTRY REGISTER\n         MVC   RETRADDR,=A(RETRY0C4)\n         MVC   RETRBAD,=A(FRRPOST)\n         LA    R14,GOTBKSUB            SETUP RETURN REGISTER       1.1E\n         OI    FLAGS,GETINPG           FLAG GETSTOR IN PROGRESS\n         BR    R15                     GO TO IT\n         BO    GOTBACK                 NO SO SKIP                  1.1E\nGOTBKSUB DS    0H                                                   Joe\n*        MODESET KEY=NZERO             GET TO TCB KEY              1.1E\n         L     R7,SAVE7                Need another Base  64 bit   Joe\n         B     GOTBACK                 CONTINUE                    1.1E\n*\n*        IF AUTHORIZED FOR SRB MODE ...\n*\nDOSRB    DS    0H                                                   Joe\n*OSRB    TM    FLAGS,NOAUTH            ARE WE AUTHORIZED            Joe\n*        BO    FAIL2                   NOPE                         Joe\n*\n*        VALIDATE ASID ...\n*\n         L     R2,CVTPTR               POINT TO CVT\n         LH    R1,CSAASID              GET ASID\n         L     R2,CVTASVT-CVTMAP(,R2)  POINT TO ASVT\n         USING ASVT,R2                 SETUP ADDRESSABILITY\n         C     R1,ASVTMAXU             IS IT TOO BIG\n         BH    FAIL3                   SET INVALID ASID\n         SLL   R1,2                    ASID*4\n         LA    R1,ASVTENTY-4(R1)       POINT AT DESIRED ENTRY\n*        MVC   TOASCB,0(R1)            SAVE ASCB ADDR\n         L     R2,0(,R1)               GET ASCB ADDRESS\n         L     R2,ASCBASSB-ASCB(,R2)   Get Assb\n         MVC   TARGETSTOKN,ASSBSTKN-ASSB(R2)\n         TM    TOASCB,ASVTAVAL         IS THIS ASCB EXISTENT\n*        BO    FAIL3                   NOPE\n         LA    R3,SRBAREA     POINT AT THE SRB\n         DROP  R2\n         L     R2,TOASCB               GET ASCB ADDR\n         USING ASCB,R2                 SETUP ADDRESSABILITY\n         TM    ASCBRCTF,ASCBOUT        IS ASCB SWPPED OUT\n*        BO    FAIL3                   YES SO DONOT TRY TO TOUCH IT\n         DROP  R2\n*\n*        INITIALIZE THE SRB AND INVOKE AS SRB\n*\n         TM    FLAGS,AMOD64   BIGGER ADDRESS THAN 8 HEX BYTES?\n         BO    KEEPHIGH       DON'T NULLIFY BIT 0 OF 32\n*        N     R0,=X'80000000'  LEAV ONLY ADDRESSING MODE      XA   1.1\nKEEPHIGH DS    0H\n         XC    ECB,ECB                 CLEAR THE ECBS FOR THE WAITLIST\n         XC    ECB2,ECB2\n         LA    R0,ECB\n         LA    R1,ECB2\n         STM   R0,R1,ECBLIST\n         MVI   ECBLIST+4,X'80'\n*\n*        NOW ISSUE TIMER INCASE SRB NEVER POSTS US\n*\n*        STIMER REAL,D#STX,BINTVL==A(300)  WAIT 3 SECONDS\n         MODESET KEY=ZERO\n         SPKA  0                                                    Joe\n         LA    R3,SRBCCD      POINT AT SRB CODE IN CSA         XA   1.1\n         ST    R3,SRB_EPA\n         LA    R5,RETRY0C4-D#SRBCD(R3)\n         ST    R5,RETRADDR\n         LA    R5,FRRPOST-D#SRBCD(R3)\n         ST    R5,RETRBAD\n         LA    R5,RECOVERY-D#SRBCD(,R3)\n         ST    R5,FRR_EPA\n         L     R2,USERSTOR                   Get Storage Key\n         SLL   R2,4\n         ST    R2,USERSTOR\n         LA    R2,D#RMTR-D#SRBCD(,R3)  GET RESOURCE MGR TERMINATION\n         ST    R2,RTM_EPA\n         ST    R8,WORK_EPA\n*\n         IEAMSCHD EPADDR=SRB_EPA,                                      X\n               ENV=STOKEN,                                             X\n               TARGETSTOKEN=TARGETSTOKN,                               X\n               PRIORITY=GLOBAL,                                        X\n               FRRADDR=FRR_EPA,                                        X\n               KEYVALUE=INVOKERKEY,                                    X\n               RMTRADDR=RTM_EPA,                                       X\n               PARM=WORK_EPA,                                          X\n               SYNCH=YES\n*\n*        MODESET KEY=NZERO\n*\n*        WAIT  ECBLIST=ECBLIST\n*        WAIT  ECB=ECB                                              Joe\n*        TTIMER CANCEL\n*\n*        WE ARE BACK FROM EITHER TIMER OR SRB OR SUB\n*\nGOTBACK  L     R8,CSAWORK              POINT AT CSA AREA\n         NI    FLAGS,255-GETINPG       TURN OFF GET IN PROGRESS\n         TM    FLAG2,FG2ADDR\n         BO    BADADDR\n         TM    FLAG2,FG2PCK\n         BO    PRGCHK\n         TM    FLAG2,FLOOK\n         BO    LOOKCHK\n         TM    FLAG1,FG1SUBR           IS THIS A SUB CALL\n         BO    GOTBK2                  IF SO IGNORE SOME ERRORS\n         TM    FLAG1,FG1SRDN           DID SRB TERMINATE GOOD\n         BZ    FAIL                    NOPE SO ERROR MSG\n         TM    FLAG2,FG2PSTR+FG2PURG+FG2ERRR AN ERRORS\n         BNZ   FAIL                    IF SO ERROR MESSAGE\nGOTBK2   DS    0H\n*\n*        NOW MOVE INFO OUT OF CSA BUFFER\n*\n         LG    R2,24+24(,R13)          GET ORIG R1 INTO R2  64 bit Joe\n         LG    R3,24+16(,R13)           GET DESIRED LENGTH  64 bit Joe\n         L     R4,CSABUF               POINT TO BUFFER\n         L     R5,LENGTH               GET ACTUAL LENGTH MOVED\n         LTR   R5,R5                   Did any memory get back     1.1C\n         BNZ   GOTBK4                  If so then use it           1.1C\n         C     R3,=F'2048'             Was original req >= default 1.1C\n         BNL   GOTBK4                  If so then cant get it      1.1C\n         TM    FLAGS,REFETCH           Q. Is this first or sec ent 1.1C\n         BO    GOTBK4                  A. Second, return no data   1.1C\n         OI    FLAGS,REFETCH           First entry so indicate     1.1C\n         ST    R3,LENGTH               Retry with orig req         1.1C\n         B     GETM2                                               1.1C\nGOTBK4   DS    0H                                                  1.1C\n         NI    FLAGS,255-REFETCH       reset flag before return    1.1C\n*\n*        NOTE THAT ORIG(R2) IS EFFECTIVELY AT R4\n*        FIRST BYTE DESIRED IS FIRST BYTE IN BUFFER\n*\n         MVCL  R2,R4                   MOVE IN CORE\n         LG    R2,CSASTAR              GET START LOC        64 bit Joe\n         A     R2,LENGTH               PLUS LENGTH MOVED\n         STG   R2,CSAEND               SET CORRECT END ADDR  64 BIT Joe\n         MVC   LOGOOD,CSASTAR          SET LOW RANGE DISPLAYABLE\n         MVC   HIGOOD,CSAEND           AND HIGH RANGE\n         MVC   12+12(4,R13),LENGTH     SET GOTTEN LENGTH\n*                                                                   1.1\n*        SET MESSAGE LINE TO INDICATE HOW SUCCESSFUL                1.1\n*        THE MEMORY FETCH WAS                                       1.1\n*                                                                   1.1\n         CLI   MERRCD,4                IS THIS PROTECTION ERROR    1.1A\n         BNE   GOTBK3A                 NO SO CHECK OTHERS          1.1A\n         MVC   MSGLINE,PROT            MOVE IN PROTECTION MSG      1.1A\n         B     GOTBK3                  ERROR SET                   1.1A\nGOTBK3A  DS    0H                                                  1.1A\n         CLI   MERRCD,X'11'            IS THIS A PAGE FAULT        1.1A\n         BE    GOTBK3B                 YES                         1.1A\n         CLI   MERRCD,X'10'            IS THIS A SEGMENT FAULT     1.1A\n         BNE   GOTBK3                  NO                          1.1A\nGOTBK3B  MVC   MSGLINE,NONEX           SET PAGE FAULT ERROR        1.1A\nGOTBK3   DS    0H                                                   1.1\n*        LM    R14,R8,12(R13)          RESTORE REGS\n         LMG   R14,R8,24(R13)          RESTORE REGS       64 Bit Joe\n         LTR   R1,R1                   ANY LENGTH GOTTEN\n         BZR   R14                     IF NOT THEN EXIT +0\n         CR    R0,R1                   ALL DESIRED GOTTEN\n         BH    4(R14)                  IF NOT ALL THEN +4\n         B     8(R14)                  ALL DESIRED GOTTEN THEN +8\n*\n*        IF ANY ERRORS GIVE ERROR MSG AND RETURN +0\n*\nFAIL     DS    0H\n         DC    H'0'\n         MVC   MSGLINE,SRBMSG          MOVE IN MESSAGE\n         MVC   CURRENT+2(2),FLAG1\n         B     FAILALL                 GO TO COMMON ROUTINE\n*\n*        IF NOT AUTHORIZED TO DISPLAY OTHER ASIDS GIVE MSG AND RESET\n*\nFAIL2    DS    0H\n         MVC   MSGLINE,AUTHMSG         MOVE IN MESSAGE\n         B     FAILALL                 GO TO COMMON ROUTINE\n*\n*        IF ASID IS NOT VALID OR SWAPPED OUT GIVE MSG AND RESET\n*\nFAIL3    DS    0H\n         MVC   MSGLINE,BDASMSG         MOVE IN MESSAGE\nFAILALL  DS    0H                      COMMON FAILURE ROUTINE\n         MVC   CSASTAR,=D'0'           CLEAR THE START\n         MVC   CSAEND,=D'0'              AND END ADDR\n         MVC   CSAASID,=H'0'               AND THE ASID\n         MVC   CURASID,MYASID          RESET ASID AVAIL\n         RETURN (14,8)\nKEY0     DC    X'00'\n*\n*        STIMER EXIT ROUTINE\n*        ITS PURPOSE IS TO POST THE ECB AT ECB2 AND WAKE UP THE\n*        LOOK PROCESSOR IF THE SRB FAILS.  TO DO THIS WE MUST\n*        FIND THE ADDRESS OF THE ECB WHICH IS SAVED IN R3 OF\n*        THE RB ABOVE THE WAIT.  IN THAT RB, R2 IS SET TO 'ABCD'.\n*\n         USING *,R12\nD#STX    SAVE  (14,12)                 SAVE REGISTERS\n         LR    R12,R15                 SET BASE REG\n         L     R3,CVTPTR               POINT AT CVT\n         L     R3,0(,R3)               POINT AT TCB WORDS\n         L     R3,0(,R3)               POINT AT MY TCB\n         L     R3,0(,R3)               POINT AT MY RB\n         USING RBBASIC,R3\nD#STX1   DS    0H                      NOW LOOK FOR KEY IN REG2\n         CLC   RBGRS2,=C'ABCD'         IS THE KEY HERE\n         BE    D#STX2                  YES\n         TM    XSTAB2,RBTCBNXT         TEST TCB FLAG\n         BO    D#STX3                  IF NOT FOUND PROPER RB\n         L     R3,RBLINK               POINT AT PREVIOUS RB\n         B     D#STX1\nD#STX2   L     R2,RBGRS3               GET ADDR OF ECB TO POST\n         POST  (R2)                    WAKE UP LOOK\n         RETURN (14,12)\n*\n*        IF WE CANT FIND THE RB THEN DUMP\n*\nD#STX3   DC    H'0'\n         DROP  R12,R3\n         LTORG\n         TITLE 'LOOK --  STORAGE ALTER/DISPLAY - SRB MODE CODE'\n         DROP  R9\nD#SRBCD  DS    0D\n*\n*        THIS CODE PERFORMS THE FOLLOWING FUNCTIONS\n*              1 ESTABLISHES AN FRR FOR ERROR RECOVERY\n*              2 VERIFIES THAT THE ADDRESSES THAT ARE NEEDED DO\n*                EXIST.\n*              3 PERFORM THE MODIFICATION IF ALLOW AND NECESSARY\n*              4 SAVE THE PROPER CORE FOR DUMPING.\n*              5 CROSS-MEMORY POST THE MAIN COMMAND PROCESSOR\n*\n         USING WORK,R8\n         USING D#SRBCD,R7\n         LR    R7,R15         SET THE BASE REGISTER\n         USING PSA,0\n         LLGTR R8,R1          SET THE MAIN PARM DSECT       64 bit Joe\n*        ST    R2,FRRPRMS\n         USING PSA,0\n         CLC   PSATOLD,=F'0'\n         BNE   IS_SUB\n         ST    R8,0(R2)        Save work area\nIS_SUB   DS    0H\n         O     R14,=X'80000000'                             64 BIT Joe\n         ST    R14,ASRBRTN    SAVE RETURN ADDR\n*        L     R2,FRRPRMS     ACCESS THE 6 WORK PARM AREA\n*        STM   R7,R8,0(R2)    SAVE BASE AND WORK REGS\n*\n*        MOVE MEMORY\n*\n*        DBGRDIE LINKAGE=BRANCH\nRETRY0C4 L     R2,ADDR                 Test For 64 bit      64 bit Joe\n         LTR   R2,R2                   64 BIT\n         BZ    RGHTMODE                If high order\n         XGR   R15,R15                                      64 Bit Joe\n         LA    R15,RGHTMODE                                 64 Bit Joe\n         OILL  R15,X'0001'                                  64 bit Joe\n         BSM   0,R15                                        64 bit Joe\nRGHTMODE DS    0H                                           64 bit Joe\n         LG    R2,ADDR                 Other wise           64 bit Joe\n         LA    R0,BUF                  POINT AT BUFFER\n         L     R1,LENGTH               GET DESIRED LENGTH\n         LR    R3,R1                   SET LENGTH\n         OI    FLAG1,FG1MOVE           INDICATE IN MOVE\n         MVCL  R0,R2                   MOVE IN CORE\n         NI    FLAG1,255-FG1MOVE       NOTE NOT IN MOVE\n*\n*        NOW WE TERMINATE PROCESSING BY DOING A CROSS\n*        MEMORY POST IF NOT IN SUBROUTINE MODE\n*\nFRRPOST  TM    FLAG1,FG1SUBR  IS THIS SUBROUTINE MODE\n         BO    D#EXIT         IF SO THEN EXIT\n*        L     R10,=A(X'40000000') SET CODE FOR POST                Joe\n*        LR    R9,R8          SAVE WORK POINTER IN SAFE REG         Joe\n*        LA    R11,ECB        ADDR OF ECB TO POST                   Joe\n*        ICM   R11,8,=X'80'   FLAG AS XMPOST                        Joe\n*        LA    R12,D#POSTR    SET POST ERROR RETURN                 Joe\n*        L     R13,MYASCB     ASCB TO POST                          Joe\n*        L     R15,CVTPTR     POINT AT CVT                          Joe\n*        L     R15,CVT0PT01-CVTMAP(R15)    GET POST ENTRY POINTR    Joe\n*        BALR  R14,R15        GO DO POST\n*        DROP  R7             KILL MAIN ADDRESS\n*        USING *,R14          SET TEMP BASE\n*#PRTN   LR    R8,R9          RESET BASE OF WORK\n*        SL    R14,=A(D#PRTN-D#SRBCD)  NOW HAVE CORRECTED BASE\n*        LR    R7,R14         SET TO PROPER REG\n*        DROP  R14\n*        USING D#SRBCD,R7     RESET MAIN BASE\n         OI    FLAG1,FG1SRDN  FLAG SRB AS COMPLETED\nD#EXIT   L     R14,ASRBRTN    RESTORE RETURN ADDR\n*        BR    R14            EXIT\n         BSM   0,R14          EXIT                           64 bit Joe\n*        COPY  DBGRLIT\n         SPACE 5\n*\n*        POST ERROR ROUTINE  .. FLAG ERROR AND LET TIMER\n*        WAKE UP TASK\n*\n*#POSTR  LR    R8,R9          RESET WORK BASE\n*        OI    FLAG2,FG2PSTR  FLAG POST ERROR                       Joe\n*        BR    R14            RETURN TO D#PRTN                      Joe\n         TITLE 'LOOK --  Common Recovery Routine............'       Joe\nRECOVERY DS    0D\n***********************************************************************\n*\n*          Common Recovery Routine\n*\n***********************************************************************\n         SPACE 2\n         DROP  R9,R11\n         USING *,R15               SET TEMP BASE\n         C     R0,=F'12'\n         BER   R14                 SKIP IF NOT SDWA\n         DROP  R10\n         LR    R4,R1                Save R1\n         USING SDWA,R1\n         L     R1,SDWAXPAD          Get Record Able Area\n         DROP  R1\n         USING SDWAPTRS,R1\n         L     R1,SDWASRVP\n         DROP  R1\n         USING SDWARC1,R1\n         CLI   SDWATYPE,SDWATFRR   Is This a FRR\n         BNE   IS_ESTAE            No Must Be Is An Estae\n         L     R2,0(,R2)           Address of 24 byte area\nIS_ESTAE DS    0H\n         LR    R8,R2\n         ST    R14,RECOVRET\n         USING SDWA,R4             SAVE ADDR\n         LR    R12,R15             SAVE BASE REGISTER\n         DROP  R15\n         USING RECOVERY,R12\n*        TM    FLAGS,GETINPG           IS A GETSTOR IN PROGRESS\n*        BZ    SPIEOTR                 NOPE OTHER ERROR\n*        L     R8,CSAWORK          SETUP REG 8\n         USING WORK,R8                 IF FROM GETSTOR THEN R8 POINTS\n*                                      TO WORK\n*        TM    FLAG1,FG1MOVE           ARE WE IN MOVE INSTR\n*        BZ    SPIEOTR                 NOPE\n         MVC   MERRCD,SDWAICD1         SAVE INT CODE                1.1\n         XR    R6,R6                   CLear R6\n         ICM   R6,B'0011',SDWACMPC\n         SRL   R6,4                    Shift Over\n         STCM  R6,B'0011',ABEND_CODE\n         CLC   ABEND_CODE,=X'00C4'     Soc4\n         BNE   PROGCK\n         CLI   SDWACRC+3,X'11'\n         BNE   PROGCK\n         CLC   RETRY,=F'5'\n         BH    ERRMESS\n         L     R3,SDWANXT1\n         CLC   0(2,R3),=X'0E02'\n         BNE   ERRMESS\n         L     R1,LENGTH\n         L     R2,SDWAGR01\n         SR    R1,R2\n         ST    R1,LENGTH\n         B     SET_RP\nERRMESS  DS    0H\n         MVC   RETRADDR,RETRBAD\n         MVC   RETRY,=F'0'\n         B     SET_RP\n*        CLI   SDWAICD1-SDWA(R4),X'11' PIC 11\n*        BNE   PROGCK                  IF NOT THEN TRY OTHERS\n         OI    FLAG2,FG2ADDR\n         B     SET_RP\nPROGCK   DS    0H\n         CLI   SDWATYPE,SDWATFRR       If this is not a Frr then look\n         BNE   ITSLOOK                 No Must Be Is An Estae\n*        OI    FLAG2,FG2PCK\n         OI    FLAG2,FLOOK\n         L     R6,SDWANXT1             Get Next Address\n         L     R7,SDWAGR07             R11 Base Addrss Of Look\n         SR    R6,R7\n         ST    R6,OFFSET\n         MVC   RETRADDR,RETRBAD\n         MVC   REACDE,SDWACRC+1        Move reason code\n         B     SET_RP\nITSLOOK  DS    0H\n         OI    FLAG2,FLOOK\n*        TM    SDWACMPF,SDWARCF        Is there a reason code\n*        BZ    SETADDR                 No\n         MVC   REACDE,SDWACRC+1        Move reason code\nSETADDR  DS    0H\n         L     R6,SDWANXT1             Get Next Address\n         L     R7,SDWAGR11             R11 Base Addrss Of Look\n         SR    R6,R7\n         ST    R6,OFFSET\n         MVC   RETRADDR,RETRBAD\n         B     SET_RP\n*\n*        If We Have Gotten a S0C4 See if Storage is\n*                  Swapped out\n*\n*        Issue all Flavors of VSMLOC to See if Storage\n*\n*                      Was Obtained\n*\n         L     R3,LEN\n         LG    R2,START_ADDR\n         MVC   LOC,=CL8'PRIVATE'\n         VSMLOC PVT,AREA=((R2),(R3)),TCB=OWNTCB\n         LTR    R15,R15          Q. Was Storage Obtained\n         BZ     CK_PAGE          Is it paged in\n*\n*\n*\n         MVC   LOC,=CL8'SQA '\n         VSMLOC SQA,AREA=((R2),(R3))\n         LTR    R15,R15          Q. Was Storage Obtained\n         BZ     CK_PAGE          Is it paged in\n*\n*\n*\n         MVC   LOC,=CL8'LSQA'\n         VSMLOC LSQA,AREA=((R2),(R3))\n         LTR    R15,R15          Q. Was Storage Obtained\n         BZ     CK_PAGE          Is it paged in\n*\n*\n*\n         MVC   LOC,=CL8'CSA '\n         VSMLOC CSA,AREA=((R2),(R3))\n         LTR    R15,R15          Q. Was Storage Obtained\n         BZ     CK_PAGE          Is it paged in\n*\n*\n*\n         MVC   LOC,=CL8'CPOOLFIX'\n         VSMLOC CPOOLFIX,AREA=((R2))\n         LTR    R15,R15          Q. Was Storage Obtained\n         BZ     CK_PAGE          Is it paged in\n*\n*\n*\n         MVC   LOC,=CL8'CPOOLLCL'\n         VSMLOC CPOOLLCL,AREA=((R2))\n         LTR    R15,R15          Q. Was Storage Obtained\n         BZ     CK_PAGE          Is it paged in\n*\n         OI     FLAG1,FG1NOAL    Indcate storage Not Allocated\n         B      SETKEY0\n*        B      D#EXIT\n*\n*        Check it storage is paged out\n*\nCK_PAGE  DS    0H\n         STC   R0,SUBPOOL          Store Subpool value\n         LG    R2,START_ADDR       Point to What we look at  64 bit Joe\n         L     R3,USERSTOR         Get Storage Key\n         SRL   R3,4                Put it back in right spot\n*\n         TPROT 0(R2),R3\n         BC    14,MOVE_STOR\n*\n         LG    R2,START_ADDR                               64 bit Joe\n         LGR   R3,R2                                       64 BIT jOE\n         A     R3,LEN\n*\nSETKEY0  DS     0H\n         SPKA   0                  We Have to Be In Stor Key 0\n*\n         LA    R3,40(,R2)\n         PGSER R,FIX,A=(R2),EA=(R3),TCB=0,ECB=0,BRANCH=Y\n*\nMOVE_STOR DS   0H\n         L     R2,LENGTH\n         S     R2,SDWAGR01-SDWA(R1)    GET LENGTH NOT MOVED\n         ST    R2,LENGTH               SAVE MOVED LENGTH\n         B     D#FRR0                  ALL DONE\n*        IF ADDRESSING EXCEPTION THEN\n*        REGISTERS NOT ALWAYS UPDATED (PER POPS)\n*        BUT THE TRANSLATION ADDR IS CLOSE.\n*        ALSO NO DATA MAY HAVE BEEN MOVED.\n*        (WE ARE DEALING HERE WITH WHAT MAY BE \"MODEL DEPENDENT\"\n*        FEATURES)\nD#FRR0A  DS    0H\n         L     R2,SDWATRAN-SDWA(,R1)   GET BAD ADDRESS\n         SG    R2,ADDR                 LESS START ADDR       64 BIT Joe\n         LTR   R2,R2                   ANY GOOD LENGTH\n         BM    D#FRR0                  NOPE                         1.1\n         C     R2,LENGTH               MAKE SURE IT IS REASONABLE\n         BH    D#FRR0                  SKIP IF NOT\n         ST    R2,LENGTH               SAVE AS GOTTEN LENGTH\n         LTR   R2,R2                   ANY LENGTH AT ALL            1.1\n         BZ    D#FRR0                  NO - SO SKIP MOVE            1.1\n         LR    R3,R2                   SETUP LENGTH\n         LR    R5,R2                                               1.1C\n         LG    R2,ADDR                 GET FROM ADDR         64 BIT Joe\n         LA    R4,BUF                  GET TO ADDRESS              1.1C\n         MVCL  R4,R2                                               1.1C\nD#FRR0   OI    FLAG2,FG2IVLD  SET FLAG FOR MESSAGE\nSET_RP   DS    0H\n         LR    R1,R4\n         DROP  R4\n         USING SDWA,R1\n         L     R7,SDWAGR07        Restore\n         L     R4,RETRADDR\n         MVC   REGS,SDWAGRSV\n         MVC   REGS+8(4),ADDR+4\n         SETRP RECORD=NO,RC=4,RETADDR=(R4),DUMP=NO,RETREGS=YES,        X\n               FRESDWA=YES,RUB=REGUP\n         LA    R15,4          Retry\n         L     R14,RECOVRET   Restore Recovery\n         BR    R14            EXIT\n         SPACE 5\nREGUP    DC    2X'FF'\nREGS     DS    CL64\n*\n*        ALL OTHER ERRORS\n*\nD#FRR1   OI    FLAG2,FG2ERRR  SET FLAG FOR MESSAGES\n         SETRP RECORD=YES,RC=4,RETADDR=FRRPOST,REGS,DUMP=YES,          X\n               RETREGS=YES,FRESDWA=YES\n         BR    R14            EXIT\nSPIEOTR  DS    0H\n         LR    R1,R4                   RESTORE SDWA REG\n         SETRP REGS=(14,12),DUMP=NO,RC=0,RECORD=NO\n         DROP  R12\n         SPACE 2\n         TITLE 'LOOK --  STORAGE ALTER/DISPLAY - RESOURCE MGR. CLEANUP'\n*\n*        THIS ROUTINE RECEIVES CONTROL IF THE SRB MUST BE\n*        PURGED.\n*\nD#RMTR   DS    0H\n         USING *,R15\n         LR    R7,R15         SET BASE REGISTER\n         SL    R7,=A(D#RMTR-D#SRBCD)   BY COMPUTATION\n         DROP  R15\n         USING D#SRBCD,R7\n         LR    R8,R2          SET UP POINTER TO WORK\n         ST    R14,ASRBRTN    SAVE RETURN ADDR\n         OI    FLAG2,FG2PURG  SET PURGED\n         B     FRRPOST        GO AND POST TO CLEAN UP\n         LTORG\nENDSRB   DS    0H\nSRBCODE  EQU   *-D#SRBCD               LENGTH OF SRB CODE\n         TITLE 'LOOK --  STORAGE ALTER/DISPLAY - MESSAGES, CONSTANTS'\nKEY1 DC CL80'1= HELP      2=           3= END        4=           5= REX\n               PEAT  6=          '\nKEY2 DC CL80'7= BACKWARD  8= FORWARD   9= HIST BWD  10= HIST FWD 11=   X\n                    12=          '\n* ERROR MESSAGE FOR BAD INPUT\nTITLE    DC    CL79' '\nMODEMSG  DC    CL79'***** INVALID MODE'\nINVADDR  DC    CL79'***** BAD ADDRESS '\nPROGCHK  DC    CL79'***** PROGRAM CHECK '\nINVALOP  DC    CL79'***** INVALID OPERATOR'\nSYMFULL  DC    CL79'***** SYMBOL TABLE IS FULL'\nNAMEMSG  DC    CL79'***** UNDEFINED SYMBOL'\nDEFMSG   DC    CL79'***** NULL SYMBOL OR SYMBOL TOO LONG'\nPCMSG    DC    CL79'***** PROGRAM CHECK'\nLINKMSG  DC    CL79'***** LINK FAILED'\nSRBMSG   DC    CL79'***** SRB DATA FETCH FAILED'\nAUTHMSG  DC    CL79'***** LOOK NOT CURRENTLY AUTHORIZED. REQUEST DENIEDX\n               .'\nBDASMSG  DC    CL79'***** ASID INVALID OR SWAPPED OUT.'\nBADIMSG  DC    CL79'***** INDIRECT FAILED.'\nASIDFMT  DC    CL13'CURRENT ASID='\nERRMSG   DC    CL79'INVALID ADDRESS -- TRY AGAIN'\nINVASIDC DC    CL79'INVALID CHARACTERS OR VALUE TYPED INTO ASID'\nINVTYPDV DC    CL79'INACTIVE ASID TYPED IN'\nPROT     DC    CL79'--- PART/ALL OF REQUESTED MEMORY FETCH PROTECTED' 1\nNONEX    DC    CL79'--- PART/ALL OF REQUEST MEMORY NON-EXISTENT'    1.1\nBLANKS   DC    CL79' '\n         EJECT\nHEXTAB   DC    256C' '                 GENERAL HEX CONVERSION TABLE\n         ORG   HEXTAB+C'A'             INPUT CONVERSION\n         DC    X'0A0B0C0D0E0F'\n         ORG   HEXTAB+C'0'             OUTPUT CONVERSION\n         DC    C'0123456789ABCDEF'\n         ORG\n* HEX INPUT TRT TABLE\nNUMTAB   DC    256X'1'\n         ORG   NUMTAB+C'A'\n         DC    6X'0'\n         ORG   NUMTAB+C'0'\n         DC    10X'0'\n         ORG\nVALCHAR  DC    256C'.'                 TRANSLATE TO VALID CHARS\n         ORG   VALCHAR+C' '\n         DC    C' '\n         ORG   VALCHAR+C'\u00a2'\n         DC    C'\u00a2.<(+|&&'\n         ORG   VALCHAR+C'!'\n         DC    C'!$*);\u00ac-/'\n         ORG   VALCHAR+C','\n         DC    C',%_.?'\n         ORG   VALCHAR+C':'\n         DC    C':#@''=\"'\n         ORG   VALCHAR+C'a'\n         DC    C'abcdefghi'\n         ORG   VALCHAR+C'j'\n         DC    C'jklmnopqr'\n         ORG   VALCHAR+C's'\n         DC    C'stuvwxyz'\n         ORG   VALCHAR+C'A'\n         DC    C'ABCDEFGHI'\n         ORG   VALCHAR+C'J'\n         DC    C'JKLMNOPQR'\n         ORG   VALCHAR+C'S'\n         DC    C'STUVWXYZ'\n         ORG   VALCHAR+C'0'\n         DC    C'0123456789'\n         ORG\n         LTORG\n         SPACE 2\n*        SCREEN DEFINITION AREA\nQDINIT   DS    0D             START OS DISPLAY WORK AREA\n         DC    F'0'           ORIG SCREEN DEPTH\n         DC    F'0'           ORIG SCREEN LINESZ\n         DC    H'80'          LENGTH OF DISPLAY LINE\n         DC    PL2'21'        LINES PER SCREEN\n         DS    0D\n         DS    0CL69\n         DC    CL6' '\n         DC    CL63' '\n         DC    CL63' '        CORRECTED DATA FROM SCREEN\n         DS    0C             DISPLAY SCREEN\n         DC    X'27'          CONTROL\n         DC    X'F5'          ERASE/WRITE\n         DC    X'C1115D7F1140403C404000' CLEAR SCREEN\n         DC    CL43'LOOK COMMAND - DISPLAY VIRTUAL MEMORY' TITLE L 1.1D\n         DC    CL13'DISPLAY ASID='\n         DC    X'1DC8'        MARK NEXT FIELD AS INPUT FIELD\n         DC    CL4' '         IN/OUT FOR ASID\n         DC    X'1DF0'        TERMINATE INPUT FIELD\n         DC    X'11'          SET BUFFER ADDRESS\n         DC    X'C150'        (2,1)\n         DC    C'ENTER CMD -'     REPLY PROMPT\n         DC    X'1DC8'        MARK NEXT FIELD AS INPUT FIELD\n         DC    X'13'          SET CURSOR ADDRESS\n         DC    X'11'          SET BUFFER ADDRESS\n         DC    X'C25B'        (2,76)\n         DC    X'1DF0'        TERMINATE INPUT FIELD\n         DC    X'11'          SET BUFFER ADDRESS\n         DC    X'C260'        (3,1)\n         DC    C'LAST CMD  - '\n         DC    CL63' '        PREVIOUS COMMAND\n         DC    X'11'          SET BUFFER ADDRESS\n         DC    X'C3F0'        (4,1)\n         DC    CL79' '\n         DC    C' '\n         DC    16CL80' '      MESSAGE TEXT AREA\n         DC    2CL80' '\n         DC    2CL80' '       PFK DISPLAY AREA\nHELPMSG  DS    0H\n DC CL80'LOOK is a real time core display and formatting program. It alX\n               so has the        '\n DC CL80'capability of displaying memory in any address space.         X\n                                 '\n DC CL80'                                                              X\n                                 '\n DC CL80'The valid commands are:                                       X\n                                 '\n DC CL80'Iexp  24 bit indirect                 | Jexp  31 bit indirect X\n                                 '\n DC CL80'(To change ASID, overtype it in hex.) | Gexp  64 bit indirect X\n                                 '\n DC CL80'>     Forward                         | <     Backward        X\n                                 '\n DC CL80'=sym  Define current address as \"sym\" | ,sym  Redisplay core aX\n               t \"sym\"           '\n DC CL80'M0/M1 Flip between top and center     | Lname Indirect thru coX\n               ntrol block field '\n DC CL80'Ocb   Format as \"cb\" control block    | R     Refresh displayeX\n               d storage         '\n DC CL80'      \"cb\" may be NULL to show as hex |                       X\n                                 '\n DC CL80'                                                              X\n                                 '\n DC CL80'where ''exp'' is of the form:                                 X\n                                   '\n DC CL80'    <+/->hhhh<+/-hhhh<+/-hhhh...>>                            X\n                                 '\n DC CL80'and ''hhhh'' is a 1 to 8 digit hex number.                    X\n                                   '\n DC CL80'                                                              X\n                                 '\n DC CL80'                                                              X\n                                 '\nLOOKABD  DC    C' LOOK ABEND XXX REASON YYY OFFSET NNNN '\n         TITLE 'LOOK --  STORAGE ALTER/DISPLAY - WORK AREAS, DSECTS'\n*----------------------------------------------------------------------\n*\n* HIST -- HISTORY ENTRY FOR ONE OR MORE PREVIOUS ENTRIES\n*\n*----------------------------------------------------------------------\n         SPACE 2\nHIST     DSECT\nHISTADDR DS    D                       ADDR OF STORAGE/MAIN CB ADDRES\nHISTCBHP DS    A                       0 IF NO CB\n*                                      X'7FFFFFFF' IF OVERLAY NULL\n*                                      ADDR OF CBH IF CB DISPLAYED\nHISTCBSP DS    A                       ADDR OF CBS DISPLAYED\nHISTSADR DS    A                       ADDR OF STORAGE FOR THIS SEG\nHISTLEN  EQU   *-HIST                  LENGTH OF ENTRY\n         SPACE 5\n*----------------------------------------------------------------------\n*\n* CBH  -- CONTROL BLOCK HEADER  -  ONE FOR EACH DIFFERENT CONTROL BLK\n*\n*----------------------------------------------------------------------\n         SPACE 2\nCBH      DSECT\nCBHNEXT  DS    A                       ADDR OF NEXT CONTROL BLOCK OR 0\nCBHVOFF  DS    A                       OFFSET OF VALIDATION FIELD\nCBHCBSP  DS    A                       ADDR OF FIRST SEG DESCIPTOR\nCBHNAME  DS    CL8                     NAME OF BLOCK\nCBHVLEN  DS    X                       LENGTH OF VALIDATION FIELD\nCBHVAL   DS    0X                      VALIDATION DATA\n         SPACE 5\n*----------------------------------------------------------------------\n*\n* CBS  -- CONTROL BLOCK SEGMENT\n*\n*----------------------------------------------------------------------\n         SPACE 2\nCBS      DSECT\nCBSPREV  DS    A                       ADDRESS OF PREVIOUS SEGMENT\nCBSNEXT  DS    A                       ADDRESS OF NEXT SEGMENT\nCBSDLEN  DS    AL2                     LENGTH OF DATA TO FETCH\nCBSDOFF  DS    AL2                     OFFSET OF DATA TO FETCH\nCBSILEN  DS    AL2                     LENGTH OF INDIRECT TO FETCH\nCBSIOFF  DS    AL2                     OFFSET OF INDIRECT TO FETCH\nCBSLEN   EQU   *-CBS                   LENGTH OF SEGMENT HEADER\n         SPACE 5\n*----------------------------------------------------------------------\n*\n* CBF  -- CONTROL BLOCK FIELD\n*\n*----------------------------------------------------------------------\n         SPACE 2\nCBF      DSECT\nCBFNAME  DS    CL8                     NAME OF FIELD\nCBFTYPE  DS    CL1                     TYPE OF NAME\nCBFDLEN  DS    XL1                     LENGTH OF DATA TO DISPLAY\nCBFOFFS  DS    H                       OFFSET INTO BLOCK START\nCBFLINE  DS    H                       LINE NUMBER TO PUT ON\nCBFCOLM  DS    H                       COLUMN TO START IN\nCBFLEN   EQU   *-CBF\n         EJECT\n*----------------------------------------------------------------------\n*\n*   MAIN DYNAMIC WORK AREA\n*\n*----------------------------------------------------------------------\nWORKAREA DSECT\nSAVE     DS    18D                                         64 BIT   Joe\nSAVE14T1 DS    2D\nOUTAREA  DS    CL80\nSAVE7    DS    F\nSAVE1    DS    F\nHISTORY  DS    F                       HISTORY TABLE ADDRESS\nTARGETSTOKN DS D\n*RBRET   DS    F\n*RBRETCODE DS  F\n*RBRSN   DS    F\nNAMES    DS    150D                    SYMBOL TABLE\nCURRENT  DS    H                       HIST TABLE OFFSET\nESTAE    ESTAE 1,PARAM=0,MF=L      ROOM FOR ESTAE PARM LIST\n         DS    0F,H                SPACER\nESRUB    DS    H                   BIT INDICATOR SHOULD BE X'0074'\nBASE1    DS    F                   SECOND BASE REG (R9)\nBASR10   DS    F                   NORMAL R10\nBASE2    DS    F                   FIRST BASE REG (R11)\nBASR13   DS    F                   NORMAL R13\nTEMP1    DS    CL17                    CONVERSION WORK AREA  64 bit Joe\nTEMP2    DS    CL9                     CONVERSION WORK AREA\nTEMP3    DS    D                                             64 BIT Joe\nLOGOOD   DC    D'0'                                          64 Bit Joe\nHIGOOD   DC    XL8'FFFFFFFFFFFFF123'                         64 Bit Joe\nCSALEN   DS    F                       SP AND LEN OF CSA WORK AREA\nCSAWORK  DS    A                       ADDRESS OF CSA WORKAREA\nCSABUF   DS    A                       ADDRESS OF CSA DATA BUFFER FOR\n*                                      SRB\nCSASTAR  DS    AD                      USERS ADDR OF BEGINNING OF\n*                                      BUFFER DATA\nCSAEND   DS    AD                      USERS ADDR OF END OF BUFFER DATA\nCSAASID  DS    H                       USERS ASID FOR BUFFER DATA\nMYASID   DS    H                       DCMS ASID\nCURASID  DS    H                       DISPLAYED CORE ASID\nWORKA    DS    CL6\nSAVEASID DS    CL4                     FORMATTED VERSION OF CURASID\nFLAGS    DS    X                       ASSORTED FLAGS\nINDFLAG  EQU   X'80'                   INDIRECT IN PROGRESS\n*OAUTH   EQU   X'40'                   IF ON THEN NOT AUTHORIZED    Joe\nGETINPG  EQU   X'20'                   ON IF GETSTOR IN PROGRESS (SUBR)\nRFRSH    EQU   X'10'                   ON TO REFRESH CSA BUFFER\nIND31    EQU   X'08'                   31 BIT INDIRECT IN PROGRESS\nREFETCH  EQU   X'04'                   First get failed and retry  1.1C\nIND64    EQU   X'02'                   64 BIT INDIRECT IN PROGRESS\nAMOD64   EQU   X'01'                   NEEDS ACCESS MODE 64\nMODEFLAG DS    X                       USER OPTION FLAGS\nMIDDUMP  EQU   X'80'                   ON TO FORCE DISPLAY BACK 8 LINES\nALIGN    EQU   X'40'                   ON TO ALIGN DUMP ON QUADWORD\n         SPACE 2\n*        SCREEN DEFINITION AREA\nQDISPLAY DS    0D             START OS DISPLAY WORK AREA\nQDOSZR0  DC    F'0'           ORIG SCREEN DEPTH\nQDOSZR1  DC    F'0'           ORIG SCREEN LINESZ\nQDLNELEN DC    H'80'          LENGTH OF DISPLAY LINE\nQDLNES   DC    PL2'21'        LINES PER SCREEN\n         DS    0D\nPFREPLY  DS    0CL69\nPFCODE   DC    CL6' '\nPFTXT    DC    CL63' '\nINPLINE  DC    CL63' '        CORRECTED DATA FROM SCREEN\nQDSCREEN DS    0C             DISPLAY SCREEN\n         DC    X'27'          CONTROL\n         DC    X'F5'          ERASE/WRITE\n         DC    X'C1115D7F1140403C404000' CLEAR SCREEN\n         DC    CL43'LOOK COMMAND - DISPLAY VIRTUAL MEMORY' TITLE L 1.1D\nASIDLN   DC    CL13'CURRENT ASID='\n         DC    X'1DC8'        MARK NEXT FIELD AS INPUT FIELD\nASIDLN1  DC    CL4' '         IN/OUT FOR ASID\n         DC    X'1DF0'        TERMINATE INPUT FIELD\n         DC    X'11'          SET BUFFER ADDRESS\n         DC    X'C150'        (2,1)\n         DC    C'ENTER CMD -'     REPLY PROMPT\n         DC    X'1DC8'        MARK NEXT FIELD AS INPUT FIELD\n         DC    X'13'          SET CURSOR ADDRESS\n         DC    X'11'          SET BUFFER ADDRESS\n         DC    X'C25B'        (2,76)\n         DC    X'1DF0'        TERMINATE INPUT FIELD\n         DC    X'11'          SET BUFFER ADDRESS\n         DC    X'C260'        (3,1)\n         DC    C'LAST CMD  - '\nINPSAVE  DC    CL63' '        PREVIOUS COMMAND\n         DC    X'11'          SET BUFFER ADDRESS\n         DC    X'C3F0'        (4,1)\nMSGLINE  DC    CL79' '\n         DC    C' '\nOUT1     DC    16CL80' '      MESSAGE TEXT AREA\nOUT9     EQU   OUT1+(8*80)\n         DC    2CL80' '\nKEYS     DC    2CL80' '       PFK DISPLAY AREA\nQDISPLN  EQU   *-QDISPLAY     LENGTH OF ENTIRE DISPLAY\nQDSLNG   EQU   *-QDSCREEN     LENGTH OF SCREEN BUFFER\n*\n**       AREA TO HOLD DATA RETURNED BY GETSTOR\n*\n*        COPY  DBGRPY\nDUMPDATA DS    XL(MAXFETCH)            DATA RETURNED BY GETSTOR\nWORKLEN  EQU   *-WORKAREA\n         EJECT\n         PRINT NOGEN\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n*        END\n         IHAASCB\n         IHAASSB\n         IHAASVT\n         IHAFRRS\n         IHAPSA\n         IHAPVT\n         IHASDWA\n         IHASRB\n         IHARB\n         IHALCCA\n         CVT   DSECT=YES\n         EJECT\n*\n*        CSA AREA WORK AREA\n*\nWORK     DSECT\nWORKSTRT DS    0D\nDOUBLE   DS    2F\nDMYPRMS  DS    6F             DUMMY AREA FOR FRR PARMS FOR SUBR MODE\nSRB_EPA  DS    A\nFRR_EPA  DS    A\nRTM_EPA  DS    A\nWORK_EPA DS    A\nRECOVRET DS    F\nABEND_CODE DS  XL2\nLOC      DS    CL8\nSTART_ADDR DS  D                                             64 Bit Joe\nLEN      DS    F\nRETRADDR DS    A\nRETRBAD  DS    A\nRETRY    DS    F\nOWNTCB   DS    F\nFRRPRMS  DS    F              ADDRESS OF 6 WORD FRR PARM\nASRBRTN  DS    D              RETURN ADDR FOR SRB CODE       64 bit Joe\nMYASCB   DS    F              ASCB ADDR OF MAIN ROUTINE\nMYTCB    DS    F              TCB ADDRESS FOR MAIN ROUTINE\nTOASCB   DS    F              ASCB ADDR OF SRB ROUTINE\nECB      DS    F              ECB FOR MAIN ROUTINE TO WAIT ON\nECB2     DS    F              ECB FOR STIMER TO POST\nECBLIST  DS    2F\nLENGTH   DS    F              LENGTH OF STORAGE TO DUMP\nUSERSTOR DS    F              User Storage Key\nSUBPOOL  DS    X\nSRBAREA  DS    ((SRBSIZE+3)/4)F  THE SRB ITSELF\nADDR     DS    D              ADDRESS TO PROCESS AT\nASID     DS    H              ASID OF TOASCB\nFLAG1    DS    X\nFG1DUMP  EQU   X'80'\nFG1REP   EQU   X'40'\nFG1MOVE  EQU   X'20'                   IF ON DOING MVCL FOR DATA\nFG1NOAL  EQU   X'10'\nFG1SRDN  EQU   X'02'          IF ON SRB HAS TERMINATED\nFG1SUBR  EQU   X'01'\nFLAG2    DS    X\nFG2NVER  EQU   X'01'          VERIFICATION FAILED\nFG2IVLD  EQU   X'02'          VALIDATION FAILED\nFG2ERRR  EQU   X'04'          DISASTER OCCURED IN SRB\nFG2PURG  EQU   X'08'          SRB WAS PURGED\nFG2ADDR  EQU   X'80'\nFG2PCK   EQU   X'40'\nFLOOK    EQU   X'20'\nFG2PSTR  EQU   X'10'          IF ON THEN SRB POST HAD ERROR\nREACDE   DS    CL3\nOFFSET   DS    F\nMERRCD   DS    X                       INTERRUPT CODE               1.1\nSRBCCD   DS    0D                      ALIGN SRB CODE ON DBL WORD\n         DS    (SRBCODE)X\n         DS    0D                      ALIGN BUFFER\nBUF      DS    (MAXFETCH)X\nWORKLN   EQU   *-WORKSTRT\nTRVALHEX CSECT\nTRVALTAB DC    X'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'   00\n         DC    X'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'   10\n         DC    X'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'   20\n         DC    X'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'   30\n         DC    X'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'   40\n         DC    X'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'   50\n         DC    X'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'   60\n         DC    X'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'   70\n         DC    X'CCC1C2C3C4C5C6CCCCCCCCCCCCCCCCCC'   80\n         DC    X'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'   90\n         DC    X'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'   A0\n         DC    X'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'   B0\n         DC    X'CCC1C2C3C4C5C6CCCCCCCCCCCCCCCCCC'   C0\n         DC    X'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'   D0\n         DC    X'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'   E0\n         DC    X'F0F1F2F3F4F5F6F7F8F9CCCCCCCCCCCC'   F0\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LOOKN$": {"ttr": 7685, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x003\\x01\\x00\\x17O\\x01\\x19\\t?\\x12\\x05\\x00\\x1e\\x00\\x1f\\x00\\x00\\xc1\\xe2\\xd4\\xd3\\xd1\\xc3\\xd3@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "2000-06-22T00:00:00", "modifydate": "2019-04-03T12:05:33", "lines": 30, "newlines": 31, "modlines": 0, "user": "ASMLJCL"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,FLAG(5))\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=SBGOLOB.CBT497.FILE264\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.CBT497.FILE264(LOOKN)\n//         DD DISP=SHR,DSN=SBGOLOB.CBT497.FILE264(CBMACSE)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(CYL,2),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n SETSSI  CB497264\n SETCODE AC(1)\n NAME    LOOKN(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LOOK00": {"ttr": 7687, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01L\\x00\\x01\\x00\\x86\\x15/\\x01\\x06\\x04o\\x08S\\x07Q\\x05#\\x03\\x92\\xd7\\xd9\\xc5\\xe5\\xc9\\xe4\\xe2@@@'", "ispf": {"version": "01.76", "flags": 0, "createdate": "1986-06-01T00:00:00", "modifydate": "2006-02-15T08:53:01", "lines": 1873, "newlines": 1315, "modlines": 914, "user": "PREVIUS"}, "text": "         TITLE 'LOOK --  STORAGE ALTER/DISPLAY'\n*\n**\n**       THIS VERSION OF LOOK SUPPORTS MULTIPLE ADDRESS SPACE\n**       INVESTIGATION.\n**\n**       THIS VERSION DOES NOT YET SUPPORT ALTER CAPABILITY\n**\n**       THIS VERSION IS CONFIGURED TO RUN AND RESIDE ABOVE THE LINE\n**\n**   VERSION 1.1 CHANGES (6/1/88):                                  1.1\n**      - CORRECT ESTAE AND FRR ATTEMPTS TO DETERMINE HOW MUCH      1.1\n**        DATA WAS MOVED.                                           1.1\n**      - GIVE MESSAGES IF DATA WAS NOT MOVED, DISTINGUISH BETWEEN  1.1\n**        NON-EXISTANT (PAGE/SEGMENT FAULT), AND KEY/FETCH          1.1\n**        PROTECTION ERROR.                                         1.1\n**      - TRANSLATE THE OUTPUT CHARACTER STRINGS FOR CONTROL BLOCK  1.1\n**        FORMATING. THANKS TO MR. S. GOLOB OF NEWSWEEK             1.1\n**      - COMBINE XA AND SP MODULES INTO 1 VIA GLOBAL SYMBOL        1.1\n**\n**   VERSION 1.1A CHANGES (12/5/88):                               1.1A\n**      - CORRECT HANDLING OF ERROR MESSAGES.                      1.1A\n**\n**   VERSION 1.1B CHANGES (10/31/89):                              1.1B\n**      - Change amount of core gotten for ESA.                    1.1B\n**\n**   VERSION 1.1C CHANGES (11/28/90):                              1.1C\n**      - Add changes from Bruce Bordonaro.                        1.1C\n**            - Use STTMPMD.                                       1.1C\n**            - Add significant number of macro formats.           1.1C\n**      - Improve memory fetch when CPU does no data movement.     1.1C\n**      - Fix problem in FRR recovery.                             1.1C\n**\n**   VERSION 1.1D CHANGES (01/22/91):                              1.1D\n**      - Add spelling corrections from Sam Golob.                 1.1D\n**      - Correct HELP screen for Overlay command.                 1.1D\n**      - Correct Mode command.                                    1.1D\n**      - Fix bugs in control block segments.                      1.1D\n**      - Handle 31 bit address correctly when top bit on.         1.1D\n**      - Correct title - Never did and never will actually        1.1D\n**                         zap memory - use INCORZAP or #D         1.1D\n**      - Stop long fields from overlaying next lines.             1.1D\n**      - Correct blanking out of areas not available              1.1D\n**      - Get memory line at a time in dump, if necessary.         1.1D\n**\n**   VERSION 1.1E CHANGES (07/02/91):                              1.1E\n**      - If authorized then do memory fetchs in KEY=0.            1.1E\n**\n*\n         EJECT ,                                                   1.1D\n         MACRO\n&N       HEX   &TO,&FROM\n&N       UNPK  TEMP1(9),&FROM.(5,R6)\n         MVC   &TO.(8,R4),TEMP1\n         TR    &TO.(8,R4),HEXTAB\n         MEND\n         EJECT ,                                                   1.1D\nLOOK     CSECT\n******************************                                     1.1D\n**                                                                 1.1D\n**     Fetch constant - maximum amount fetchable in one call       1.1D\n**                                                                 1.1D\nMAXFETCH EQU   4096                                                1.1D\n**                                                                 1.1D\n**                                                                 1.1D\n******************************                                     1.1D\n         SPACE 3                                                   1.1D\n*                                                                   1.1\n*        SET THE FOLLOWING GLOBAL SYMBOL TO 1 FOR XA AND 0 FOR SP   1.1\n*                                                                   1.1\n         GBLB  &XA                                                  1.1\n&XA      SETB  1 =XA MODE              SET TO 1 FOR XA              1.1\n         SPACE 3                                                    1.1\n*  INITIALIZE THE PROGRAM\n         SAVE  (14,12),,'LOOK..&SYSDATE..&SYSTIME'\n         LR    R11,R15                 PERMANENT BASE\n         USING LOOK,R11\n         LA    R9,2048(R11)            GET A SECOND BASE REG\n         LA    R9,2048(R9)\n         USING LOOK+4096,R9\n         AIF   (&XA).XA1                                            1.1\n         GETMAIN R,LV=WORKLEN,SP=1                          SP      1.1\n         AGO   .NXA1                                                1.1\n.XA1     ANOP                                                       1.1\nLOOK     AMODE 31                                           XA      1.1\nLOOK     RMODE ANY                                          XA      1.1\n         GETMAIN R,LV=WORKLEN,SP=1,LOC=(BELOW,ANY)          XA      1.1\n.NXA1    ANOP                                                       1.1\n         LR    R10,R1\n         LR    R2,R10                  WORK AREA START\n         L     R3,=A(WORKLEN)          LENGTH TO CLEAR\n         SR    R5,R5                   ZERO PAD BYTE, LENGTH 2\n         MVCL  R2,R4                   CLEAR THE WORK AREA\n         USING WORKAREA,R10\n         LA    R4,QDINIT\n         LA    R3,QDISPLN              GET LENGTH\n         LA    R2,QDISPLAY             POINT AT START\n         LR    R5,R3                   SET FROM LENGTH\n         MVCL  R2,R4                   INIT DISPLAY\n         ST    R13,SAVE+4              CHAIN THE SAVE AREAS\n         LA    R15,SAVE\n         ST    R15,8(R13)\n         LR    R13,R15                 NEW SAVE AREA\n         STM   R9,R11,BASE1        SAVE FIRST THREE REGS FOR AREA\n         ST    R13,BASR13          AND ORIGINAL R13\n         LA    R1,50*HISTLEN           GET LENGTH OF HIST TBL\n         GETMAIN R,SP=2,LV=(1)\n         ST    R1,HISTORY              SAVE ADDRESS\n         STFSMODE ON,INITIAL=YES       TELL TSO WE ARE FULLSCREEN\n         STTMPMD ON,KEYS=ALL                                       1.1C\n*\n*        SET SUPERVISOR MODE IF AUTHORIZED\n*\n         OI    FLAGS,NOAUTH            SET NOT AUTHORIZED\n         L     R1,=A(WORKLN)           GET LENGTH OF CAS BUFFER\n         ST    R1,CSALEN               SET LENGTH AND SP0\n         TESTAUTH FCTN=1               ARE WE AUTHORIZED\n         LTR   R15,R15\n         BNZ   NOTAUTH                 IF NOT SKIP CODE\n         MVI   CSALEN,241              SET CSA SP\n         NI    FLAGS,255-NOAUTH        MARK AUTHORIZED\n         MODESET MODE=SUP              SET TO SUP MODE\nNOTAUTH  DS    0H\n*\n*        SETUP ESTAE IN CORRECT MODE\n*\n         ESTAE EREXIT,PARAM=(R10),MF=(E,ESTAE)\n*\n*        INITIALIZE ASID POINTERS\n*\n         MVC   ASIDLN,ASIDFMT          SET MESSAGE\n         L     R1,16                   GET CVT\n         L     R2,0(R1)                GET TCBWORDS\n         L     R1,12(R2)               GET OLD ASCB ADDR (MINE)\n         USING ASCB,R1\n         MVC   MYASID,ASCBASID         MOVE IN MY ASID\n         MVC   CURASID,MYASID\n         DROP  R1\n         XC    CSAASID,CSAASID         CLEAR THE CSA BUFFER INDIC\n         XC    CSASTAR,CSASTAR\n         XC    CSAEND,CSAEND\n         L     R0,CSALEN               GET LENGTH AND SP FOR CSA BUFFER\n         GETMAIN R,LV=(0)\n         ST    R1,CSAWORK              SAVE ADDR OF CSA BUFFER\n         LR    R8,R1                   SET PROPER POINTER\n         USING WORK,R8\n         MVC   MYTCB,4(R2)             SAVE ADDR OF MY TCB\n         MVC   MYASCB,12(R2)           SAVE ADDR OF MY ASCB\n         LA    R1,BUF                  POINT TO TRUE BUFFER\n         ST    R1,CSABUF\n         LA    R0,SRBCCD               POINT TO CSA SRB CODE AREA\n         LA    R1,SRBCODE              AND LENGTH OF CODE\n         LR    R3,R1\n         LA    R2,D#SRBCD              POINT TO CSECT CODE\n         MVCL  R0,R2                   MOVE SRB CODE TO CSA\n         B     ISCAN1                  GO AND PROCESS\n         DROP  R8\n         EJECT\n***********************************************************************\n*\n*   INPUT SCAN\n*\n***********************************************************************\n         SPACE 2\nISCAN    CLC   SAVEASID,ASIDLN1        DID USER CHANGE ASID\n         BE    ISCAN1                  NOPE\n*\n*        FORMAT AND SAVE USER ASID\n*\n         MVC   TEMP1(4),ASIDLN1        GET USER INFO\n         OC    TEMP1(4),=CL4' '        MAKE UPPER CASE\n         TR    TEMP1(4),HEXTAB         MAKE PACKABLE\n         PACK  TEMP2(3),TEMP1(5)\n         MVC   CURASID,TEMP2           GET NEW ASID\nISCAN1   MVC   INPSAVE,INPLINE         SAVE LAST USER INPUT\nISCAN2   LA    R3,INPLINE              POINT TO START OF INPUT\n         LA    R1,SCANTAB              COMMAND TABLE\n         NI    FLAGS,255-INDFLAG-IND31 TURN OFF INDIRECT FLAG\n         MVC   MSGLINE,TITLE           CLEAR OUT ERROR MSG\nSCANLOOP L     R2,4(R1)                GET TABLE ENTRY\n         CLC   0(1,R1),ENDTAB          SEE IF END OF TABLE\n         BE    NUMSCAN                 IF YES, ASSUME NUMERIC INPUT\n         CLC   0(1,R1),INPLINE         SEE IF COMMAND FOUND\n         BER   R2                      IF YES, GO TO COMM ROUINE\n         LA    R1,8(R1)                NEXT ENTRY ADDRESS\n         B     SCANLOOP\nSCANTAB  DS    0F                      COMMAND TABLE\n         DC    CL4' ',A(FORMAT)\n         DC    CL4'I',A(INDIR)\n         DC    CL4'J',A(INDIR31)\n         DC    CL4'>',A(FWD)\n         DC    CL4'<',A(BACK)\n         DC    CL4'=',A(DEFINE)\n         DC    CL4',',A(NUMSCAN)\n         DC    CL4'M',A(MODE)\n         DC    CL4'L',A(LINK)\n         DC    CL4'O',A(OVERLAY)\n         DC    CL4'R',A(REFRESH)\nENDTAB   DC    X'FF'                   END OF TABLE INDICATOR\n         SPACE 2\n***********************************************************************\n*\n*     FORMAT THE OUTPUT SCREEN\n*\n***********************************************************************\n         SPACE 2\nFORMAT   LA    R3,INPLINE              CURSOR ADDRESS\n         MVC   INPLINE,BLANKS          CLEAR INPUT LINE\nFORMAT2  BAL   R14,ERASE               CLEAR THE SCREEN\n         LH    R2,CURRENT              HISTORY TABLE POINTER\n         A     R2,HISTORY              POINT AT HISTORY TABLE ENTRY\n         USING HIST,R2                 IDENTIFY HISTORY ENTRY FORMAT\n         L     R4,HISTADDR             GET ADDRESS TO DISPLAY\n         TM    HISTCBHP,X'80'          IS THIS A CB MAP IN USE\n         BO    CBHIT                   IF SO THE PROCESS IT\n         CLC   =X'7FFFFFFF',HISTCBHP   SUPPRESSED CB USAGE\n         BE    NOCB\n         DROP  R2\n         SPACE 2\n*----------------------------------------------------------------------\n*\n*        SEE IF CONTROL BLOCK MAP EXISTS\n*\n*----------------------------------------------------------------------\n         SPACE 2\nDUMP     L     R5,=V(CBMACS)           GET START OF INDEX\n         LTR   R5,R5                   ANY VALUE\n         BZ    NOCB                    NOPE\n         USING CBH,R5                  ADDRESS THE CONTROL BLK HEADER\nDUMPCB   CLC   =F'0',CBHNEXT           SEE IF END OF INDEX\n         BE    NOCB                    IF YES, NO CB FOUND\n         L     R2,CBHVOFF              GET CB IDENTIFIER OFFSET\n         AR    R2,R4                   ADD DISPLAY ADDRESS\n         SR    R3,R3                   CLEAR A REGISTER FOR IC\n         IC    R3,CBHVLEN              GET LENGTH\n         LR    R0,R3                   PUT IN 0 FOR GETSTOR\n         LA    R1,DUMPDATA             TARGET ADDR\n         BAL   R14,GETSTOR             FETCH THE DATA\n         B     NOTCB                   BR IF NO DATA FOUND\n         B     NOTCB                   BR IF PARTIAL DATA FOUND\n         BCTR  R3,0                    GET MACHINE LENGTH\n         EX    R3,CBFNDIT              LOOK FOR VALIDATION FIELD\n         BE    CBHIT                   BR IF YES, CB WAS FOUND\nNOTCB    L     R5,CBHNEXT              NEXT INDEX ENTRY\n         MVC   MSGLINE,BLANKS          Clear useless error msg     1.1C\n         B     DUMPCB                  AND CHECK FOR MORE CB'S\nCBFNDIT  CLC   CBHVAL(*-*),DUMPDATA    SEE IF IDENTIFIER MATCH\n         DROP  R5\n         SPACE 2\n*----------------------------------------------------------------------\n*\n* IF NO CONTROL BLOCK TO BE SHOWN, JUST USE DUMP FORMAT\n*\n*----------------------------------------------------------------------\n         SPACE 2\nNOCB     LR    R2,R4                   COPY ADDR TO DISPLAY\n         TM    MODEFLAG,ALIGN          QUADWORD ALIGNMENT WANTED\n         BZ    DUMPNOA                 BR IF NOT\n         N     R2,=XL4'FFFFFFF0'       ROUND DOWN FOR DISPLAY\nDUMPNOA  TM    MODEFLAG,MIDDUMP        PUT ADDR INCENTER OF SCREEN?\n         BZ    DUMPNOM                 BR IF NOT\n         SH    R2,=H'128'              IF YES, BACK UP QUAD WORDS\n* R2 NOW HAS FIRST ADDRESS TO DISPLAY\nDUMPNOM  LA    R0,256                  LENGTH TO FETCH\n         LA    R1,DUMPDATA             TARGET ADDRESS\n         LA    R2,0(0,R2)              clear top bit               1.1D\n         BAL   R14,GETSTOR             GO FETCH THE DATA\n         B     DUMPLN                  go dump by line             1.1D\n         NOP   0                       RETURN IF PARTIAL DATA FOUND\n         LA    R6,DUMPDATA             POINT TO DATA TO DISPLAY\n         LA    R4,OUT1                 FIRST OUTPUT LINE ADDR\n         LA    R5,16                   NO. OF LINES TO DISPLAY\nDUMPLOOP EQU   *                       FORMAT THE DISPLAY\n         STCM  R2,15,TEMP2             ADDRESS TO SHOW\n         UNPK  TEMP1(9),TEMP2(5)       CONVERT BINARY TO HEX\n         MVC   0(8,R4),TEMP1\n         TR    0(8,R4),HEXTAB\n         HEX   12,0                    CONVERT FIRST WORD TO HEX\n         HEX   22,4                    SECOND WORD TO HEX\n         HEX   32,8                    THIRD WORD\n         HEX   42,12                   FOURTH AND LAST WORD TO HEX\n         MVI   52(R4),C'*'             FRAME THE EBCDIC DISPLAY\n         MVI   69(R4),C'*'             FRAME THE OTHER SIDE\n         MVC   53(16,R4),0(R6)         COPY THE EBCDIC DATA\n         TR    53(16,R4),VALCHAR       DELETE INVALID CHARS\n         LA    R2,16(R2)               NEXT LINE ADDR\n         LA    R6,16(R6)               NEXT DATA AREA\n         LA    R4,80(R4)               NEXT OUTPUT LINE\n         BCT   R5,DUMPLOOP             GO DO NEXT LINE\n         B     BLANKSC                 Try to blank out data not   1.1D\n         SPACE 2                                                   1.1D\nDUMPLN   EQU   *                       Fetch and dump each line    1.1D\n         LA    R4,OUT1                 FIRST OUTPUT LINE ADDR      1.1D\n         LA    R5,16                   NO. OF LINES TO DISPLAY     1.1D\nDUMPLP2  EQU   *                       FORMAT THE DISPLAY          1.1D\n         STCM  R2,15,TEMP2             ADDRESS TO SHOW             1.1D\n         UNPK  TEMP1(9),TEMP2(5)       CONVERT BINARY TO HEX       1.1D\n         MVC   0(8,R4),TEMP1                                       1.1D\n         TR    0(8,R4),HEXTAB                                      1.1D\n         LA    R0,16                   length of a line            1.1D\n         LA    R1,DUMPDATA             where to put data           1.1D\n         BAL   R14,GETSTOR             get it                      1.1D\n         B     DLKILL                  +0 no data found            1.1D\n         NOP   0                       +4 partial data found       1.1D\n         LA    R6,DUMPDATA             +8 all data found           1.1D\n         HEX   12,0                    CONVERT FIRST WORD TO HEX   1.1D\n         HEX   22,4                    SECOND WORD TO HEX          1.1D\n         HEX   32,8                    THIRD WORD                  1.1D\n         HEX   42,12                   FOURTH AND LAST WORD TO HEX 1.1D\n         MVI   52(R4),C'*'             FRAME THE EBCDIC DISPLAY    1.1D\n         MVI   69(R4),C'*'             FRAME THE OTHER SIDE        1.1D\n         MVC   53(16,R4),0(R6)         COPY THE EBCDIC DATA        1.1D\n         TR    53(16,R4),VALCHAR       DELETE INVALID CHARS        1.1D\nDLKILL   DS    0H                                                  1.1D\n         LA    R2,16(R2)               NEXT LINE ADDR              1.1D\n*        LA    R6,16(R6)               NEXT DATA AREA              1.1D\n         LA    R4,80(R4)               NEXT OUTPUT LINE            1.1D\n         BCT   R5,DUMPLP2              GO DO NEXT LINE             1.1D\nBLANKSC  DS    0H                                                  1.1D\n         SPACE 2\n*----------------------------------------------------------------------\n*\n* NOW BLANK OUT THE SCREEN WHERE THE PAGE DIDN'T EXIST\n*\n*----------------------------------------------------------------------\n         SPACE 2\n         LA    R4,OUT1                 POINT TO FIRST OUTPUT LINE\n         SH    R2,=H'256'              FIRST ADDRESS DISPLAYED\n         LA    R5,16                   NUMBER OF LINES DISPLAYED\nBLLOOP   LA    R15,15(R2)              LAST ADDRESS ON CURRENT LINE\n         CLC   LOGOOD,HIGOOD           ARE WE IN A WRAP CONDITION\n         BH    BLLP0                   YES SO SKIP NOLINE CHECK\n         C     R2,HIGOOD               IF START>=HIGH\n         BNL   NOLINE                     THEN BLANK ENTIRE LINE\nBLLP0    C     R2,LOGOOD               IF START<LOW & END>=LOW\n         BNL   BLLP1                      THEN HI GOOD AND LOW NEEDS\n*                                                  BLANK\n         C     R15,LOGOOD\n         BNL   HIMIX\nBLLP1    C     R2,HIGOOD               IF START<HIGH & END>HIGH\n         BNL   BLLP2                      THEN LOW GOOD AND BLANK\n*                                                HIGH\n         C     R15,HIGOOD\n         BH    LOWOK\nBLLP2    DS    0H                      LINE OK OTHERWISE\n         B     BLOOPEND\n* BOTH LOW AND HIGH MISSING -- BLANK ENTIRE LINE\nNOLINE   MVI   12(R4),C' '             START OF DATA\n         MVC   13(57,R4),12(R4)        CLEAR THE LINE\n         B     BLOOPEND                GO CHECK ANOTHER LINE\n* BR HERE IF LOW END GOOD, HIGH MAY BE  MISSING\nLOWOK    S     R15,HIGOOD              # OF BYTES TO BLANK\n* THE FOLLOWING CODE TAKES CARE OF LOW STORAGE WRAP\n         CH    R15,=H'15'              MORE THAN 15 BYTES TO CLEAR\n         BH    BLOOPEND                IF YES, IT WRAPPED, NO CLEAR\n         LR    R1,R15                  COPY # TO BLANK\n         SRL   R1,2                    FIND # OF WORDS\n         SLL   R1,1                    TWO BLANKS PER WORD\n         AR    R1,R15                  ADD NUMBER OF HEX CHARS\n         AR    R1,R15                  WHICH IS TWICE THE # OF BYTES\n         LA    R6,50(R4)               POINT JUST AFTER HEX DATA\n         SR    R6,R1                   FIRST BYTE TO CLEAR\n         BCTR  R1,0                    REDUCE BY 1 FOR EXEXUTE\n         EX    R1,CLEARMVC             CLEAR HEX SIDE\n         LA    R6,69(R4)               POINT TO TRAILING *\n         SR    R6,R15\n         EX    R15,CLEARMVC            CLEAR EBCDIC AND *\n         MVI   0(R6),C'*'              NOTE END OF EBCDIC DATA\n         B     BLOOPEND                GO CHECK NEXT LINE\n* COME HERE WHEN HI END GOOD AND LOW END MISSING\nHIMIX    L     R15,LOGOOD              LOWEST GOOD ADDR\n         SR    R15,R2                  NUMBER OF BYTES TO CLEAR\n         CH    R15,=H'16'              Total line                  1.1D\n         BNL   NOLINE                  Kill complete line          1.1D\n         LR    R1,R15                  COPY # TO CLEAR\n         SRL   R1,2                    # OF WORDS TO CLEAR\n         SLL   R1,1                    NUMBER OF IMBEDDED BLANKS\n         AR    R1,R15                  ADD # OF HEX CHARS\n         AR    R1,R15\n         BCTR  R1,0                    REDUCE BY 1 FOR MVC\n         LA    R6,12(R4)               START OF HEX DATA\n         EX    R1,CLEARMVC             AND CLEAR THE HEX DATA\n         LA    R6,52(R4)               POINT TO FIRST * ON LINE\n         EX    R15,CLEARMVC            CLEAR * AND EBCDIC DATA\n         LA    R6,52(R15,R4)           POINT TO FIRST CLEARED BYTE 1.1D\n         MVI   0(R6),C'*'              AND DROP IN A *\nBLOOPEND LA    R4,80(R4)               POINT TO NEXT LINE\n         LA    R2,16(R2)               ADDRESS ON NEXT LINE\n         BCT   R5,BLLOOP               AND SCAN ALL LINES\n         SPACE 2\n*----------------------------------------------------------------------\n*\n*  PUT IN ARROWS TO POINT TO DESIRED DATA\n*\n*----------------------------------------------------------------------\n         SPACE 2\n         LA    R4,OUT1                 ADDR OF FIRST LINE\n         TM    MODEFLAG,MIDDUMP        DOES IT BELONG IN THE MIDDLE\n         BZ    ARRTOP                  BR IF NOT\n         LA    R4,OUT9                 POINT TO MIDDLE LINE\nARRTOP   SR    R1,R1                   ASSUME NO QUADWORD ALIGNMENT\n         TM    MODEFLAG,ALIGN          WAS ASSUMPTION CORRECT\n         BZ    ARRALIGN                BR IF YES, ELSE GET OFFSET\n         LA    R1,15                   MASK FOR LOW 4 BITS\n         NR    R1,R2                   GET BYTE OFFSET FOR ARROW\n* FIRST DO THE EBCDIC SIDE\nARRALIGN LA    R15,51(R4)              BYTE BEFORE FIRST *\n         EX    R1,MOVEMVC              MOVE THE DATA BACK\n         AR    R15,R1                  ADDR OF LAST BYTE MOVED\n         MVI   1(R15),C'>'             PUT IN THE ARROW\n* NOW MOVE THE HEX SIDE\n         SR    R0,R0                   CLEAR HIGH ORDER BITS\n         SLDL  R0,30                   WHICH WORD IS TO BE MOVED\n         SRL   R1,30                   NUMBER OF BYTES TO BE MOVED\n         LR    R15,R0                  COPY OFFSET OF WORD TO MOVE\n         MH    R15,=H'10'              EACH WORD TAKES UP 10 BYTES\n         LA    R15,10(R4,R15)          POINT IN FRONT OF WORD TO MOVE\n         SLL   R1,R1                   NUMBER OF HEX DIGITS TO MOVE\n         EX    R1,MOVEMVC              MOVE THE DATA BACK\n         AR    R15,R1                  POINT TO PALCE FOR ARROW\n         MVI   1(R15),C'>'             AND PUT IT THERE\n* FALL  THRU TO SHOW THE SCREEN\n         EJECT\n*\n* DISPLAY THE PAGE AND CHECK FOR END REQUEST\n*\nDISPLAY  UNPK  TEMP1(5),CURASID(3)     FORMAT CURRENT ASID\n         MVC   ASIDLN1(4),TEMP1        AND PUT ON SCREEN\n         TR    ASIDLN1(4),HEXTAB\n         MVC   SAVEASID,ASIDLN1        SAVE FORMATED VERSION\n         MVC   KEYS,KEY1               SETUP PFK\n         MVC   KEYS+80,KEY2                 INFO LINE\n*\nTPUTSCRN DS    0H\n         LA    R0,QDSLNG\n         TPUT  QDSCREEN,(0),FULLSCR MF=(E,QTPUT)\n         XC    INPLINE,INPLINE\n         XC    PFREPLY,PFREPLY\n         TGET  PFREPLY,69,ASIS MF=(E,QTGET)\n         LR    R3,R1                   SAVE INPUT LENGTH\n         CH    R15,=H'12'     IS INPUT LONGER THAN BUFFER?\n         BNE   NOCLEAR        NO. CONTINUE.\n         TCLEARQ INPUT        CLEAR THE QUEUE\nNOCLEAR  DS    0H\n         MVC   MSGLINE,BLANKS          INDICATE NO ERROR           1.1A\n         LA    R1,PFREPLY+3            POINT AT FIRST BYTE\n         SH    R3,=H'3'                ADJUST LENGTH\n*\n**       HANDLE ASID IF NECESSARY\n*\n         CLC   0(3,R1),=X'1140F9'      IS THIS ASID MODIFICATION\n         BNE   NOASID                  NO SO SKIP\n         LA    R1,3(R1)                POINT AT FIRST BYTE\n         SH    R3,=H'3'                ADJUST LENGTH\n         LR    R2,R1                   SAVE START ADDRESS\nASIDLOOP CLI   0(R1),X'11'             LOOK FOR START FIELD\n         BE    HAVEASID\n         LA    R1,1(R1)                BUMP POINTER\n         BCT   R3,ASIDLOOP\nHAVEASID LR    R15,R1                  MOVE POINTER\n         SR    R15,R2                  GET LENGTH\n         BZ    NOASID\n         MVC   ASIDLN1,=CL4' '\n         LA    R4,ASIDLN1+4            GET TO ADDRESS +4\n         SR    R4,R15                      - REAL LENGTH\n         BCTR  R15,0                   GET MACHINE LENGTH\n         EX    R15,MOVERPLY\nNOASID   DS    0H\n         LTR   R3,R3                   ANY DATA LEFT\n         BZ    ENDINP\n         CLC   0(3,R1),=X'11C15C'      CHECK FOR START OF FIELD\n         BNE   ENDINP                  IF NOT HERE THEN SKIP\n         LA    R1,3(R1)                POINT AT FIRST BYTE\n         SH    R3,=H'3'                ADJUST LENGTH\n         LR    R2,R1                   SAVE START ADDRESS\nRPLYLOOP CLI   0(R1),X'11'             LOOK FOR START FIELD\n         BE    HAVERPLY\n         LA    R1,1(R1)                BUMP POINTER\n         BCT   R3,RPLYLOOP\nHAVERPLY LR    R15,R1                  MOVE POINTER\n         SR    R15,R2                  GET LENGTH\n         BZ    NOASID\n         LA    R4,INPLINE              GET TO ADDRESS\n         BCTR  R15,0                   GET MACHINE LENGTH\n         EX    R15,MOVERPLY\nENDINP   OC    INPLINE,=CL63' '        MAKE UPPERCASE\n         SPACE 2\n         IC    R4,PFCODE\n         XR    R5,R5\n         CLI   PFCODE,X'7D'      ENTER?\n         BE    ENTER             /YES - TREAT AS ENTER\n         CLI   PFCODE,X'F0'      TEST-REQ/SYS-REQ?\n         BE    ENTER             /YES - TREAT AS ENTER\n         CLI   PFCODE,X'01'      OTHER KIND OF SYS-REQ?\n         BE    ENTER             /YES - TREAT AS ENTER\n         CLI   PFCODE,X'6C'      PA1?\n         BE    ENDIT             /YES - TERMINATE\n         CLI   PFCODE,X'6E'      PA2?\n         BE    TPUTSCRN          /YES - GO RESHOW SCREEN\n         CLI   PFCODE,X'6B'      PA3?  (TCAM GENERATED)\n         BE    TPUTSCRN          /YES - GO RESHOW SCREEN\n         N     R4,=X'0000000F'   EXTRACT PF-KEY NUMBER\n         CH    R4,=H'12'\n         BH    ENTER            \"ENTER\" KEY\n         BCTR  R4,0\n         SLL   R4,2              TIMES SIZE OF AN ENTRY\n         B     PFKEYTAB(R4)\nPFKEYTAB B     HELP                    PF1\n         B     DISPLAY                 PF2\n         B     ENDIT                   PF3    QUIT\n         B     DISPLAY                 PF4\n         B     REPEAT                  PF5    REPEAT COMMAND\n         B     DISPLAY                 PF6\n         B     UP                      PF7    SCROLL UP\n         B     DOWN                    PF8    SCROLL DOWN\n         B     BACK                    PF9    SCROLL BACKWARDS\n         B     FWD                     PF10   SCROLL FORWARDS\n         B     DISPLAY                 PF11\n         B     DISPLAY                 PF12\nMOVERPLY MVC   0(0,R4),0(R2)           **EXECUTED**\n         EJECT\nENTER    CLC   =C'END',INPLINE         SEE IF END TYPED\n         BNE   ISCAN                   IF NOT, GO LOOK AT INPUT\n* CLEAN UP AND GO AWAY\nENDIT    LM    R0,R1,CSALEN            GET SP, LEN, AND ADDR\n         LTR   R1,R1                   WAS BUFFER GOTTEN\n         BZ    ENDIT1                  NOPE\n         FREEMAIN R,LV=(0),A=(1)       FREE BUFFER\nENDIT1   TM    FLAGS,NOAUTH            ARE WE AUTHORIZED\n         BO    ENDIT2                  NOPE\n         MODESET MODE=PROB             RESET MODE\nENDIT2   DS    0H\n         STTMPMD OFF                                               1.1C\n         STFSMODE OFF                  RESET FULLSCREEN\n         L     R13,SAVE+4              GET ORIGINAL SAVE AREA\n         FREEMAIN R,LV=WORKLEN,SP=1,A=(R10)\n         RETURN (14,12),RC=0\n         EJECT\n*----------------------------------------------------------------------\n*\n* CBHIT  -- CONTROL BLOCK FORMATTING ROUTINE\n* AT ENTRY:\n*              R4 HAS ADDRESS TO DISPLAY (OFFSET 0 - MAIN SEGMENT)\n*              R5 HAS CONTROL BLOCK HEADER ADDRESS\n*\n*----------------------------------------------------------------------\n         SPACE 2\nCBHIT    LH    R2,CURRENT              GET HISTORY TABLE POINTER\n         A     R2,HISTORY              GET ENTRY ADDRESS\n         USING HIST,R2                 SETUP FORMAT OF ENTRY\n         ICM   R6,15,HISTCBSP          LAST SEGMENT DISPLAYED\n         BNZ   CBHIT2                  BR IF A CONTINUING DISPLAY\n         USING CBH,R5                  ADDRESS HEADER BLOCK\n         L     R6,CBHCBSP              ELSE GET FIRST SEG ADDRESS\n         ST    R6,HISTCBSP             AND SAVE FOR LATER\n         ST    R5,HISTCBHP             AND SAVE FOR LATER\n         OI    HISTCBHP,X'80'          NOTE CB FORMAT ROUTINE IN USE\n*   GET BLOCK NAME AND HANDLE ANY SEGMENT INDIRECTION\nCBHIT2   DS    0H\n         USING CBS,R6\n         L     R5,HISTCBHP             POINT TO CB HEADER\n         MVC   MSGLINE+36(8),CBHNAME   MOVE IN CB NAME\n         STCM  R4,15,TEMP2             SAVE ADDRESS OF BLOCK\n         UNPK  TEMP1(9),TEMP2(5)          AND CONVERT\n         TR    TEMP1(8),HEXTAB               TO HEX\n         MVC   MSGLINE+26(8),TEMP1     MOVE IN ADDRESS OF BLOCK\n         DROP  R2,R5\n         CLC   =H'0',CBSILEN           IS THIS SEGMENT INDIRECT\n         BE    CBHIT3                  IF NOT THEN SKIP CODE\n         LH    R0,CBSILEN              GET LENGTH TO FETCH (ALWAYS 4\n         LA    R1,DUMPDATA             WHERE TO PUT IT\n         LH    R2,CBSIOFF              GET INDIRECT OFFSET\n         AR    R2,R4                   GET TRUE MAIN BLOCK ADDRESS\n         BAL   R14,GETSTOR             GET THE INDIRECT WORD\n         B     NOCB                    BR IF NO DATA FETCHED\n         B     NOCB                    BR IF PARTIAL DATA FETCHED\n         L     R4,DUMPDATA             RESET THE ADDR TO DUMD\n         LH    R2,CURRENT\n         A     R2,HISTORY              GET ADDR OF ENTRY\n         ST    R4,HISTSADR-HIST(R2)    SAVE SEGMENT ADDRESS\nCBHIT3   DS    0H\n         LH    R0,CBSDLEN              LENGTH TO FETCH\n         LA    R1,DUMPDATA             TARGET ADDRESS\n         LH    R2,CBSDOFF              OFFSET TO FETCH\n         AR    R2,R4                   ADD START OF CB ADDRESS\n         BAL   R14,GETSTOR             GO FETCH THE DATA\n         B     NOCB                    BR IF NO DATA FETCHED\n         B     NOCB                    BR IF PARTIAL DATA FETCHED\n         LA    R5,OUT1-80              START OF SCREEN\n         LA    R2,DUMPDATA             POINT TO DATA BUFFER\n         SH    R2,CBSDOFF              BACKUP TO VIRTUAL CB ORIGIN\n         LA    R6,CBSLEN(R6)           POINT AT FIRST CB FIELD\n         USING CBF,R6\nCBLOOP   DS    0H\n         LH    R1,CBFLINE              GET LINE NUMBER\n         MH    R1,=H'80'               TIMES LINE LENGTH\n         AH    R1,CBFCOLM              PLUS THE COLUMN NUMBER\n         AR    R1,R5                   PLUS START OF LINE\n         MVC   0(8,R1),CBFNAME         SET NAME FIELD\n         LA    R1,8(R1)                SKIP NAME\n         LH    R14,CBFOFFS             GET OFFSET INTO CB\n         AR    R14,R2                  GET ADDRESS IN FETCHED DATA\n         SR    R15,R15                 CLEAR REGISTER\n         IC    R15,CBFDLEN             GET LENGTH OF DATA ITEM\n         LA    R0,80-8                 get max column less label   1.1D\n         SH    R0,CBFCOLM              and starting col number     1.1D\n*   FORMAT CHARACTER AS DISPLAY AND REST AS HEX\n         CLI   CBFTYPE,C'C'            WHAT IS TYPE\n         BNE   CBFLP1                  IF NOT CHAR THEN DO HEX     1.1D\n         CR    R15,R0                  see if data too big         1.1D\n         BNH   *+6                     use actual length           1.1D\n         LR    R15,R0                  truncate data               1.1D\n         BCTR  R15,0                   GET MACHINE LENGTH\n         EX    R15,CBMVC               MOVE IN DATA\n         EX    R15,CBTR                OUTPUT ONLY VALID CHARS      1.1\n         B     CBFEND\nCBFLP1   SRL   R0,1                    convert columns to bytes    1.1D\n         CR    R15,R0                  see if data too big         1.1D\n         BNH   *+6                     use actual length           1.1D\n         LR    R15,R0                  truncate data               1.1D\nCBFLOOP  MVC   TEMP2(1),0(R14)         MOVE IN DATA BYTE\n         UNPK  TEMP1(3),TEMP2(2)\n         TR    TEMP1(2),HEXTAB\n         MVC   0(2,R1),TEMP1           MOVE IN CONVERTED BYTE\n         LA    R1,2(R1)                BUMP OUTPUT ADDRESS\n         LA    R14,1(R14)              BUMP INPUT ADDRESS\n         BCT   R15,CBFLOOP             KEEP LOOPINT\nCBFEND   LA    R6,CBFLEN(R6)           BUMP TO NEW FIELD\n         CLC   0(4,R6),=F'0'           END OF SEGMENT\n         BNE   CBLOOP                  IF NOT THEN KEEP GOING\n         B     DISPLAY                 ALL DONE SO DISPLAY IT\n         DROP  R6\n         SPACE 1\nCBMVC    MVC   0(0,R1),0(R14)          **EXECUTED** MOVE IN DATA\nCBTR     TR    0(0,R1),VALCHAR         **EXECUTED** MAKE VALID      1.1\n         SPACE 2\n*----------------------------------------------------------------------\n*\n*  GET ADDRESS OF CURRENT CONTROL BLOCK SEGMENT\n*     ON EXIT R2 = ADDR OF THIS CONTROL BLOCK SEGMENT\n*\n*----------------------------------------------------------------------\nGETCURAD DS    0H\n         LH    R2,CURRENT              GET HIST TABLE OFFSET\n         A     R2,HISTORY              GET ENTRY\n         USING HIST,R2\n         CLC   =F'0',HISTSADR          IS SEGMENT A SECONDARY SEGMENT\n         BE    GCA1                    NOPE, SO SKIP CODE\n         L     R2,HISTSADR             GET ADDRESS OF BLOCK\n         BR    R14\nGCA1     L     R2,HISTADDR             GET MAIN BLOCK ADDR\n         BR    R14\n         DROP  R2\n         EJECT\n***********************************************************************\n*\n* COMMAND ROUTINES\n*\n         SPACE 2\n*----------------------------------------------------------------------\n*\n* HELP -- DISPLAY HELP INFORMATION\n*\n*----------------------------------------------------------------------\n         SPACE 2\nHELP     DS    0H\n         LA    R1,16*80\n         LR    R3,R1\n         L     R2,=A(HELPMSG)      POINT AT FROM\n         LA    R0,OUT1\n         MVCL  R0,R2\n         B     DISPLAY\n         SPACE 2\n*----------------------------------------------------------------------\n*\n* REFRESH -- REFETCH THE CORE AND REDISPLAY IT\n*\n*----------------------------------------------------------------------\n         SPACE 2\nREFRESH  OI    FLAGS,RFRSH             SET REFRESH FLAG\n         B     FORMAT                  REFORMAT SCREEN\n         SPACE 2\n*----------------------------------------------------------------------\n*\n* OVERLAY  --  MANIPULATE CONTROL BLOCK FORMATTING\n*\n*----------------------------------------------------------------------\n         SPACE 2\nOVERLAY  CLC   =C'NULL',INPLINE+1      SEE IF NO FORMATTING WANTED\n         BE    OVERNULL                BR IF YES\n         L     R5,=V(CBMACS)           GET CB MAP INDEX\n         LTR   R5,R5                   ANY MAPS\n         BZ    OVERNULL                IF NOT TREAT AS NULL OVERLAY\n         USING CBH,R5                  SETUP ADDRESSABILITY\nOVERLOOP CLC   =F'0',CBHNEXT           END OF CONTROL BLOCKS\n         BE    FORMAT                  IF YES, IGNORE COMMAND\n         CLC   INPLINE+1(8),CBHNAME    SEE IF CB MATCH\n         BE    OVERHIT                 BR IF YES\n         L     R5,CBHNEXT              ELSE POINT TO NEXT ENTRY\n         B     OVERLOOP                AND KEEP LOOKING\nOVERHIT  L     R6,CBHCBSP              START SEG ADDR FOR CB FOUND\n         LH    R2,CURRENT              CURRENT HIST TABLE ENTRY OFFSET\n         A     R2,HISTORY              GET ENTRY ADDRESS\n         USING HIST,R2                 SETUP ENTRY FORMAT\n         ST    R5,HISTCBHP             POINT AT HEADER\n         ST    R6,HISTCBSP             POINT AT SEGMENT(FIRST)\n         OI    HISTCBHP,X'80'          MARK AS CB\n         XC    HISTSADR,HISTSADR       CLEAR SEC SEG ADDR\n         B     FORMAT                  GO SHOW IT\n         SPACE 1\nOVERNULL LH    R2,CURRENT              CURRENT HIST TABLE ENTRY OFFSET\n         A     R2,HISTORY              POINT AT CURRENT ENTRY\n         MVC   HISTCBHP,=X'7FFFFFFF'   SUPPRESS CB OVERLAY\n         B     FORMAT                  GO SHOW STORAGE\n         DROP  R5,R2\n         SPACE 2\n*----------------------------------------------------------------------\n*\n* DOWN -- SCROLL DOWN 256 BYTES OR NEXT CTRL BLK SEGMENT\n*\n*----------------------------------------------------------------------\n         SPACE 2\nDOWN     LH    R2,CURRENT              CURRENT HIST TABLE POINTER\n         A     R2,HISTORY              POINT TO HIST TABLE ENTRY\n         USING HIST,R2                 SETUP ENTRY FORMAT\n         TM    HISTCBHP,X'80'          SEE IF THIS IS A CB DISPLAY\n         BO    DOWNCB                  BR IF YES\n         L     R1,HISTADDR             ELSE GET ADDR TO SHOW\n         AH    R1,=H'256'              AND MOVE DOWN ONE SCREEN\n         ST    R1,HISTADDR             AND REPLACE IN HIST TABLE\n         B     FORMAT                  GO DISPLAY IT\nDOWNCB   L     R1,HISTCBSP             GET CB SEGMENT ADDR\n         L     R1,CBSNEXT-CBS(R1)      GET NEXT SEG ADDR\n         ST    R1,HISTCBSP             AND PUT IN HIST TABLE\n         XC    HISTSADR,HISTSADR       CLEAR SEC SEG ADDR\n         B     FORMAT                  GO SHOW IT\n         DROP  R2\n         SPACE 2\n*----------------------------------------------------------------------\n*\n* UP   -- SCROLL UP   256 BYTES OR PREV CTRL BLK SEGMENT\n*\n*----------------------------------------------------------------------\n         SPACE 2\nUP       LH    R2,CURRENT              CURRENT HIST TABLE POINTER\n         A     R2,HISTORY              POINT TO HIST TABLE ENTRY\n         USING HIST,R2                 SETUP FORMAT OF ENTRY\n         TM    HISTCBHP,X'80'          SEE IF THIS IS A CB DISPLAY\n         BO    UPCB                    BR IF YES\n         L     R1,HISTADDR             ELSE GET ADDR TO SHOW\n         SH    R1,=H'256'              AND MOVE UP ONE SCREEN\n         ST    R1,HISTADDR             AND REPLACE IN HIST TABLE\n         B     FORMAT                  GO DISPLAY IT\nUPCB     L     R1,HISTCBSP             GET CB SEGMENT ADDR\n         L     R1,CBSPREV-CBS(R1)      GET PREV SEG ADDR\n         ST    R1,HISTCBSP             AND PUT IN HIST TABLE\n         XC    HISTSADR,HISTSADR       CLEAR SEC SEG ADDR\n         B     FORMAT                  GO SHOW IT\n         DROP  R2\n         SPACE 2\n*----------------------------------------------------------------------\n*\n* REPEAT -- REPEAT LAST INPUT LINE\n*\n*----------------------------------------------------------------------\n         SPACE 2\nREPEAT   MVC   INPLINE(52),INPSAVE     COPY SAVED INPUT\n         B     ISCAN2                  AND PROCESS IT\n         SPACE 2\n*----------------------------------------------------------------------\n*\n* LINK -- LINK TO LABELED CONTROL BLOCK FIELD\n*\n*----------------------------------------------------------------------\n         SPACE 2\nLINK     LH    R2,CURRENT              CURRENT HIST TABLE POINTER\n         A     R2,HISTORY              POINT TO HIST TABLE ENTRY\n         USING HIST,R2                 SETUP FORMAT OF ENTRY\n         TM    HISTCBHP,X'80'          SEE IF CB FORMATTING IN USE\n         BO    LINK2                   BR IF YES\nLINKERR  MVC   MSGLINE,LINKMSG         NOTE ERROR IN LINK\n         B     FORMAT                  AND RESHOW SCREEN\nLINK2    L     R3,HISTCBSP             GET CURRENT CB SEG ADDRESS\n         LA    R5,0(R3)                CLEAR FLAGS AND SETUP FOR COMP\n         USING CBS,R4\nLINK2A   LR    R4,R3                   SAVE THE START OF SEG ADDR\n         LA    R3,CBSLEN(R3)           POINT PAST SEG HEADER\n         USING CBF,R3\nLINK3    CLC   CBFNAME(4),=F'0'        END OF SEGMENT\n         BE    LINK4\n         CLC   CBFNAME,INPLINE+1       DOES NAME MATCH\n         BE    LINKFND                 IF SO THEN FOUND\n         LA    R3,CBFLEN(R3)           POINT PAST THIS ONE\n         B     LINK3                   KEEP LOOKING\nLINK4    DS    0H\n         L     R3,CBSNEXT              POINT TO NEXT SEGMENT\n         CR    R3,R5                   ARE WE BACK AT START\n         BNE   LINK2A                  IF NOT KEEP GOING\n         B     LINKERR                 IF NOT THEN ISSUE ERROR\n         DROP  R4,R2\n* A MATCH HAS  BEEN FOUND. FETCH THE  ADDRESS TO LINK TO\nLINKFND  DS    0H\n         SR    R0,R0                   CLEAR FOR IC\n         IC    R0,CBFDLEN              LENGTH OF ITEM  MINUS 1\n         LA    R1,DUMPDATA             ADDR TO PLACE DATA IN\n         BAL   R14,GETCURAD            GET ADDR OF CURRENT SEGMENT\n         AH    R2,CBFOFFS              OFFSET OF ITEM TO FETCH\n         BAL   R14,GETSTOR             FETCH THE  ADDRESS\n         B     LINKERR                 BR IF DATA CANT BE FETCHED\n         B     LINKERR                 BR IF DATA CANT BE FETCHED\n         BAL   R15,FWDSUB              UPDATE HIST TABLE TO NEXT\n         L     R0,DUMPDATA             LOAD ADDRESS THAT WAS FETCHED\n         SR    R15,R15                 NOW ADJUST THE\n         IC    R15,CBFDLEN               FETCHED DATA\n         LA    R1,4                        SO THAT\n         SR    R1,R15                        IT IS RIGHT\n         BNP   LF1                             JUSTIFIED IN\n         SLL   R1,3                              REGISTER IF\n         SRL   R0,0(R1)                            LESS THAN 4\nLF1      DS    0H                                    BYTES\n         LH    R2,CURRENT              NEW HIST TABLE POINTER\n         A     R2,HISTORY              GET ENTRY ADDRESS\n         USING HIST,R2\n         ST    R0,HISTADDR             SAVE NEW ADDRESS\n         XC    HISTCBHP,HISTCBHP          AND\n         XC    HISTCBSP,HISTCBSP            CLEAR\n         XC    HISTSADR,HISTSADR               REST\n         B     FORMAT                  GO FORMAT THE NEW CB\n         DROP  R3,R2\n         SPACE 2\n*----------------------------------------------------------------------\n*\n*  SET INDIRECT FLAG\n*\n*----------------------------------------------------------------------\n         SPACE 2\nINDIR31  OI    FLAGS,IND31             SET FLAG\nINDIR    OI    FLAGS,INDFLAG           SET FLAG\n         LA    R3,1(R3)                UPDATE SCAN POINTER\n         CLI   INPLINE+1,C' '          USE CURRENT ADDRESS\n         BNE   NUMSCAN                 IF NO, GO SCAN INPUT ADDRESS\n         BAL   R14,GETCURAD\n         LR    R4,R2                   MOVE TO RIGHT REGISTER\n         B     ENDNUM\n         SPACE 2\n***********************************************************************\n*\n*  ESTABLISH SCREEN MODE\n*\n***********************************************************************\n         SPACE 2\nMODE     CLC   =C'1 ',INPLINE+1        MODE ONE TEST\n         BE    MODE1                   BR IF YES\n         CLC   =C'0 ',INPLINE+1        CHECK FOR MODE ZERO         1.1D\n         BNE   INVAL                   IF NOT EITHER, INVALID\n         NI    MODEFLAG,255-MIDDUMP    MODE 0 MEANS BACKUP 0\n         B     FORMAT\nMODE1    OI    MODEFLAG,MIDDUMP        MODE 1 MEANS BACK UP 7 LINES\n         B     FORMAT\nINVAL    MVC   MSGLINE,MODEMSG\n         B     FORMAT\n         SPACE 2\n***********************************************************************\n*\n*  MANIPULATE HISTORY TABLE\n*\n***********************************************************************\n         SPACE 2\nFWD      BAL   R15,FWDSUB              FORWARD 1 IN HIST TABLE\n         B     FORMAT\n         SPACE\nFWDSUB   LH    R1,CURRENT              CURRENT ENTRY INDEX\n         LA    R1,HISTLEN(R1)\n         CH    R1,=AL2(50*HISTLEN)     SEE IF WRAP NEEDED\n         BL    FWDEND                  BR IF NOT\n         SR    R1,R1                   WRAP TO BEGINNING\nFWDEND   STH   R1,CURRENT              STORE NEW OFFSET\n         BR    R15                     RETURN TO CALLER\n         SPACE 1\nBACK     LH    R1,CURRENT\n         SH    R1,=AL2(HISTLEN)        BACK UP ONE ENTRU\n         BNM   BACKEND                 BR IF NO BACKWARD WRAP\n         LA    R1,49*HISTLEN           ELSE GO TO END OF TABLE\nBACKEND  STH   R1,CURRENT              SAVE RESULT\n         B     FORMAT\n         SPACE 2\n***********************************************************************\n*\n*   ADD ENTRY TO SYMBOL TABLE\n*\n***********************************************************************\n         SPACE 2\nDEFINE   LA    R15,50                  NUMBER OF TABLE ENTRIES\n         LA    R2,NAMES                START OF TABLE\nDEFLOOP1 CLI   0(R2),X'0'              SEE IF UNUSED ENTRY\n         BE    NSPACE                  BR IF SPACE FOUND\n         LA    R2,12(R2)               NEXT ENTRY ADDR\n         BCT   R15,DEFLOOP1            TRY ALL ENTRIES\n         MVC   MSGLINE,SYMFULL         TABLE IS FULL\n         B     FORMAT\nNSPACE   LA    R15,9                   MAX LENGTH +1\n         LA    R0,INPLINE+1            ADDR OF FIRST BYTE\n         LR    R1,R0                   COPY SYMBOL ADDR\nDEFLOOP2 CLI   0(R1),C' '              SEE IF END OF SYM\n         BE    DEFEND                  BR IF YES\n         LA    R1,1(R1)                POINT TO NEXT BYTE\n         BCT   R15,DEFLOOP2            CONTINUE FOR 9 BYTES\nDEFBAD   MVC   MSGLINE,DEFMSG          SYMBOL TOO LONG OR TOO SHORT\n         B     FORMAT2                 DISPLAY WITH CURSOR AT ERROR\nDEFEND   SR    R1,R0                   SYMBOL LENGTH\n         BZ    DEFBAD                  NULL SYMBOL ILLEGAL\n         BCTR  R1,R0                   FOR EXECUTE\n         MVC   0(8,R2),=CL8' '         CLEAR TABLE ENTRY\n         EX    R1,DEFMOVE              MOVE SYMBOL\n         LH    R1,CURRENT              GET CURRENT ADDRESS\n         A     R1,HISTORY\n         L     R1,HISTADDR-HIST(R1)\n         ST    R1,8(R2)                STORE WITH SYMBOL\n         B     FORMAT\nDEFMOVE  MVC   0(0,R2),INPLINE+1       EXECUTED TO MOVE SYMBOL\n         SPACE 2\n***********************************************************************\n*\n*  SCAN THE ADDRESS EXPRESSION\n* REGISTER USAGE\n* R2 LAST NUMBER SCANNED\n* R3 SCAN POINTER\n* R4 CURRENT OUTPUT VALUE\n* R5 LAST OPERATOR SCANNED\n*\n***********************************************************************\n         SPACE 2\nNUMSCAN  DS    0H\n         BAL   R14,GETCURAD            CURRENT ENTRY IS DEFAULT\n         LR    R4,R2                   CURRENT ENTRY IS DEFAULT\n         LA    R5,0                    ASSUME DEFAULT TO BE TAKEN\n         CLI   0(R3),C'+'              SEE 2F PREFIX PLUS\n         BNE   NOTPLUS                 BR IF NOT\n         LA    R5,2                    INDICATE PLUS OPERATOR\n         B     NUMOP                   GO TO ADV POINTER\nNOTPLUS  CLI   0(R3),C'-'              IS IT PREFIX MINUS\n         BNE   NUMLOOP                 BR IF NOT, USE DEFAULT AS LOAD\n         LA    R5,4                    INDI\"ATE MINUS OPERATOR\nNUMOP    LA    R3,1(R3)                POINT TO NEXT INPUT BYTE\nNUMLOOP  CLI   0(R3),C','              SEE IF NAME INDICATED\n         BE    NAMESCAN                BR IF YES\n         TRT   0(9,R3),NUMTAB          SEARCH FOR DELIMITER\n         LR    R6,R3                   SAVE START OF NUMBER\n         BC    8,BADSTUFF              BR IF INPUT TOO LONG\n         LR    R3,R1                   UPDATE SCAN POINTER\n         SR    R1,R6                   GET LENGTH OF INPUT\n         BZ    BADSTUFF                BR IF ZERO INPUT\n         MVC   TEMP1(8),=CL8' '        CLEAR TEMP AREA\n         LA    R15,TEMP1+8             RIGHT JUSTIFY INPUT\n         SR    R15,R1                  POINT TO RIGHT SPOT IN TEMP AREA\n         BCTR  R1,0                    PREPARE FOR EX\n         EX    R1,HEXMOVE              MOVE INPUT RIGHT JUSTIFIED\n         TR    TEMP1(8),HEXTAB         TRANSLATE TO HEX\n         PACK  TEMP2(5),TEMP1(9)       CONVERT HEX TO BINARY\n         ICM   R2,15,TEMP2             NEW DISPLAY ADDRESS\nNUMDELIM EX    0,OPER(R5)              EXECUTE PREVIOUS OPERATOR\n         CLI   0(R3),C' '              IS DELIM A BLANK\n         BE    ENDNUM                  IF YES, END SCAN\n         LA    R5,2                    PLUS OPERATOR CODE\n         CLI   0(R3),C'+'              IS OPER L PLUS\n         BE    NUMOP                   BR IF YES TO CONTINUE SAAN\n         LA    R5,4                    MINUS CODE\n         CLI   0(R3),C'-'              IS OPER MINUS\n         BE    NUMOP                   BR IF YES\n         MVC   MSGLINE,INVALOP         ELSE BAD DELIMITER\n         B     FORMAT2                 DISPLAY WITH CURSOR AT ERROR\nENDNUM   TM    FLAGS,INDFLAG           IS THIS AN INDIRECT REQ\n         BZ    NOTIND                  BR IF NOT\n         TM    FLAGS,IND31             DO WE WANT 31 BIT INDIRECT{\n         BO    *+8                     SKIP CLEAR IF YES\n         ICM   R4,8,=X'00'             CLEAR TOP BYTE\n         LR    R2,R4                   SET ADDR TO GET FROM\n         LA    R0,4                    NUMBER OF BYTES TO GET\n         LA    R1,DUMPDATA             WHERE TO PUT IT\n         BAL   R14,GETSTOR             DO MEMORY FETCH\n         B     BADIND                  NONE GOT\n         B     BADIND                  SOME BUT NOT ALL GOT\n         L     R4,DUMPDATA             DO THE INDIRECT\n         N     R4,=X'7FFFFFFF'         TURN OFF TOP BIT ALWAYS\nNOTIND   BAL   R15,FWDSUB              UPDATE HISTORY POINTR\n         LH    R2,CURRENT              NEW HIST TABLE POINTER\n         A     R2,HISTORY              GET ENTRY ADDRESS\n         USING HIST,R2\n         ST    R4,HISTADDR             SAVE NEW ADDRESS\n         XC    HISTCBHP,HISTCBHP          AND\n         XC    HISTCBSP,HISTCBSP            CLEAR\n         XC    HISTSADR,HISTSADR               REST\n         B     FORMAT\n         DROP  R2\nBADIND   MVC   MSGLINE,BADIMSG         MOVE IN MESSAGE\n         B     FORMAT                  GO AND REDISPLAY\n         SPACE 2\n* SCAN INPUT FOR A NAME IN THE SYMBOL TABOL\nNAMESCAN LA    R3,1(R3)                SKIP OVER COMMA\n         LR    R1,R3                   COPY INPUT POINTER\n         LA    R15,9                   MAX LENGTH +1\nNAMELOOP CLI   0(R1),C'A'              SEE IF VALID CHAR\n         BL    NAMEEND                 BR IF NOT, DELIM FOUND\n         LA    R1,1(R1)                POINT TO NEXT BYTE\n         BCT   R15,NAMELOOP            ALLOW EIGHT BYTES PLUS DELIM\nNAMEBAD  MVC   MSGLINE,NAMEMSG         NULL NAME OR NAME TOO LONG\n         B     FORMAT2                 DISPLAY WITH CURSOR AT ERROR\nNAMEEND  SR    R1,R3                   FIND LENGTH\n         BZ    BADSTUFF                BR IF TOO SHORT\n         MVC   TEMP1(8),=CL8' '        CLEA\u00a2  WORK AREA\n         BCTR  R1,0                    SET UP FOR EX\n         EX    R1,NAMEMOVE             MOVE TO WORK AREA, BLANK PAD\n         LA    R3,1(R3,R1)             UPDATE POINTER\n         LA    R15,50                  ENTRIES IN SYM TABLE\n         LA    R1,NAMES                START OF SYM TABLE\nNAMELP2  CLC   TEMP1(8),0(R1)          SEE IF NAME IN TABLE\n         BE    NAMEFIND                BR IF YES\n         LA    R1,12(R1)               POINT TO NEXT ENTRY\n         BCT   R15,NAMELP2             BR IF ANY ENTRIES LEFT\n         B     NAMEBAD                 BR IF NONE LEFT, UNDEFUNED SYM\nNAMEFIND L     R2,8(R1)                GET >YMBOL VALUE\n         B     NUMDELIM                USE IN EXPRESSION\n*  THESE INSTRUCTIONS ARE THE OBJECT OF AN EXECUTE\nOPER     LR    R4,R2                   USE HIST TABLE AS DEFAULT INPUT\n         AR    R4,R2                   PLUS OPERATOR\n         SR    R4,R2                   MINUS OPERATOR\nHEXMOVE  MVC   0(0,R15),0(R6)          RIGHT JUSTIFY INPUT DATA\nNAMEMOVE MVC   TEMP1(1),0(R3)          PAD NAME WITH BLANKS BY MOVING\n         SPACE\nBADSTUFF MVC   MSGLINE,ERRMSG          NOTE BAD INPUT\n         B     FORMAT2                 DISPLAY WITH CURSOR AT ERROR\n         SPACE 2\n***********************************************************************\n*\n*  PROGRAM CHECK EXIT\n*\n***********************************************************************\n         SPACE 2\n         DROP  R9,R11\n         USING *,R15               SET TEMP BASE\nEREXIT   DS    0H                  ESTAE EXIT\n         C     R0,=F'12'\n         BER   R14                 SKIP IF NOT SDWA\n         STM   R14,R12,12(R13)     SAVE REGISTERS\n         LR    R4,R1               SAVE ADDR OF SDWA\n         USING SDWA,R4             SAVE ADDR\n         L     R10,SDWAPARM        GET PARM LIST\n         LR    R12,R15             SAVE BASE REGISTER\n         DROP  R15\n         USING EREXIT,R12\nER200    L     R11,BASE2           GET FIRST BASE\n         L     R9,BASE1            GET SECOND BASE\n         USING LOOK,R11,R9         RESET BASE\n         TM    FLAGS,GETINPG           IS A GETSTOR IN PROGRESS\n         BZ    SPIEOTR                 NOPE OTHER ERROR\n         L     R8,CSAWORK          SETUP REG 8\n         USING WORK,R8                 IF FROM GETSTOR THEN R8 POINTS\n*                                      TO WORK\n         TM    FLAG1,FG1MOVE           ARE WE IN MOVE INSTR\n         BZ    SPIEOTR                 NOPE\n         MVC   MERRCD,SDWAICD1         SAVE INT CODE                1.1\n         CLI   SDWAICD1,X'04'          PROTECTION??\n         BNE   ER250                   IF NOT THEN TRY OTHERS\n*        IF PROTECTION THEN DATA TO POINT OF ERROR\n*        HAS BEEN MOVED SO JUST ADJUST LENGTH\n         L     R2,LENGTH\n         S     R2,SDWAGR01             GET LENGTH NOT MOVED\n         ST    R2,LENGTH               SAVE MOVED LENGTH\n         B     ER300                   ALL DONE\n*        IF ADDRESSING EXCEPTION THEN\n*        REGISTERS NOT ALWAYS UPDATED (PER POPS)\n*        BUT THE TRANSLATION ADDR IS CLOSE.\n*        ALSO NO DATA MAY HAVE BEEN MOVED.\n*        (WE ARE DEALING HERE WITH WHAT MAY BE \"MODEL DEPENDENT\"\n*        FEATURES)\nER250    DS    0H\n         L     R2,SDWATRAN             GET BAD ADDRESS\n         S     R2,ADDR                 LESS START ADDR\n         LTR   R2,R2                   ANY GOOD LENGTH\n         BM    ER300                   NOPE                         1.1\n         C     R2,LENGTH               MAKE SURE IT IS REASONABLE\n         BH    ER300                   SKIP IF NOT\n         ST    R2,LENGTH               SAVE AS GOTTEN LENGTH\n         LTR   R2,R2                   ANY LENGTH AT ALL            1.1\n         BZ    ER300                   NO - SO SKIP MOVE            1.1\n         LR    R3,R2                   SETUP LENGTH\n         LR    R7,R2\n         L     R2,ADDR                 GET FROM ADDR\n         LA    R6,BUF                  GET TO ADDRESS\n         MVCL  R6,R2\nER300    MVC   ESRUB,=X'0074'     FLAG TO RESET REGS\n         LR    R1,R4               RESET SDWA POINTER\n         SETRP REGS=(14,12),DUMP=NO,RC=4,RETADDR=GOTBACK,              X\n               RETREGS=YES,RUB=ESRUB,FRESDWA=YES,RECORD=NO\n         DROP  R8,R4\n*PIEOTR  MVC   MSGLINE,PCMSG           TELL USER OF PC\n*        B     ER300                   SET RETURN FROM GETSTOR\nSPIEOTR  DS    0H\n         LR    R1,R4                   RESTORE SDWA REG\n         SETRP REGS=(14,12),DUMP=NO,RC=0,RECORD=NO\n         DROP  R12\n         SPACE 2\n*----------------------------------------------------------------------\n*\n* ERASE  --  CLEAR THE SCREEN BUFFER\n*\n*----------------------------------------------------------------------\n         SPACE 2\nERASE    SAVE  (2,5)                   NEED SOME WORK REGS\n         LA    R2,OUT1                 START OF AREA TO CLEAR\n         LA    R3,80*16                LENGTH TO CLEAR\n         LA    R5,C' '                 FILL CHAR\n         SLL   R5,24                   MAKE PAD BYTE AND CLEAR SOURCE\n         MVCL  R2,R4                   PROPAGATE BLANKS\n         RETURN (2,5)                  RESTORE REGS AND RETURN\n         EJECT\n* EXECUTED INSTRUCTIONS AND CONSTANTS\nCLEARMVC MVC   0(0,R6),BLANKS          CLEAR SOME SPACE\nMOVEMVC  MVC   0(0,R15),1(R15)         MOVE DATA BACKWARDS\n***********************************************************************\n*\n*\n*        FETCH SOME STORAGE\n*\n*              R0  =  LENGTH TO FETCH <=4096 (MAXFETCH)\n*              R1  => WHERE TO PUT IT\n*              R2  => WHERE TO GET IT FROM\n*\n*\n***********************************************************************\nGETSTOR  SAVE  (14,8)                  SAVE REGS\n         L     R8,CSAWORK              POINT TO CSA AREA            1.1\n         USING WORK,R8                 SETUP ADDRESSABILITY         1.1\n         MVI   MERRCD,0                INDICATE NO ERROR ON FETCH   1.1\n         LA    R2,0(0,R2)              clear top bit               1.1D\n         CL    R0,=A(MAXFETCH)         Max fetchable size          1.1D\n         BL    *+8                     Requested ok                1.1D\n         L     R0,=A(MAXFETCH)         Force smaller               1.1D\n*\n*        CHECK IF DATA IS IN BUFFER\n*\n         CLC   CSAASID,CURASID         WANT SAME ASID\n         BNE   GETMORE                 NOPE\n         C     R2,CSASTAR              CHECK FOR BEGINNING\n         BL    GETMORE\n         LR    R15,R0                  GET LENGTH\n         AR    R15,R2                  GET END ADDRESS\n         C     R15,CSAEND              CHECK FOR END\n         BH    GETMORE                 NOPE NOT IN BUFFER\n         TM    FLAGS,RFRSH             IS IT REFRESH REQUEST\n         BO    GETMORE                 REGET THE CORE\nMOVEBUF  L     R15,CSASTAR             GET VIRT ADDR OF BUFFER\n         SR    R2,R15                  GET DISPLACEMENT IN BUFFER\n         A     R2,CSABUF               POINT TO BUFFER\n         LR    R3,R0                   MOVE LENGTH\n         LR    R0,R1                   SET \"TO\" ADDR\n         LR    R1,R3                   SET LENGTH\n         MVCL  R0,R2\n         LM    R14,R8,12(R13)          RESTORE REGS                 1.1\n         B     8(R14)                  RETURN ALL GOTTEN\nGETMORE  DS    0H\n         MVC   LENGTH,=F'2048'         Initial fetch is half page  1.1C\n         C     R0,LENGTH               Is req for more than default1.1D\n         BNH   *+8                     No  so skip                 1.1D\n         ST    R0,LENGTH               Set first request for actual1.1D\n         ST    R2,ADDR                 SAVE ADDR TO GET CORE FROM  1.1C\n         ST    R2,CSASTAR              SET CSA VIRT BUFFER ADDR    1.1C\n         NI    FLAGS,255-REFETCH       inidicate first fetch       1.1C\nGETM2    DS    0H                                                  1.1C\n         MVI   MERRCD,0                INDICATE NO ERROR ON FETCH  1.1C\n         NI    FLAGS,255-RFRSH         TURN OFF FLAG\n         MVC   CSAASID,CURASID         SET ASID OF CSABUFFER CONTENTS\n         MVI   FLAG1,0                 CLEAR FLAGS\n         MVI   FLAG2,0\n         CLC   CURASID,MYASID          ARE WE IN THIS ADDR SPACE\n         BNE   DOSRB                   IF NOT USE SRB\n*\n*        INVOKE SRB CODE AS SUBROUTINE\n*\n         OI    FLAG1,FG1SUBR           FLAG AS SUBROUTINE\n         LA    R1,DMYPRMS              SETUP DUMMY FRR PARMS\n         ST    R1,FRRPRMS\n         TM    FLAGS,NOAUTH            ARE WE AUTHORIZIED          1.1E\n         BO    DOSUB1                  NO SO SKIP                  1.1E\n         MODESET KEY=ZERO              GET TO KEY ZERO             1.1E\nDOSUB1   DS    0H                                                  1.1E\n         XC    DMYPRMS,DMYPRMS\n         LR    R1,R8                   SETUP PARM REGISTER\n         LA    R15,D#SRBCD             SETUP ENTRY REGISTER\n         LA    R14,GOTBKSUB            SETUP RETURN REGISTER       1.1E\n         OI    FLAGS,GETINPG           FLAG GETSTOR IN PROGRESS\n         BR    R15                     GO TO IT\nGOTBKSUB TM    FLAGS,NOAUTH            ARE WE AUTHORIZIED          1.1E\n         BO    GOTBACK                 NO SO SKIP                  1.1E\n         MODESET KEY=NZERO             GET TO TCB KEY              1.1E\n         B     GOTBACK                 CONTINUE                    1.1E\n*\n*        IF AUTHORIZED FOR SRB MODE ...\n*\nDOSRB    TM    FLAGS,NOAUTH            ARE WE AUTHORIZED\n         BO    FAIL2                   NOPE\n*\n*        VALIDATE ASID ...\n*\n         L     R2,CVTPTR               POINT TO CVT\n         LH    R1,CSAASID              GET ASID\n         L     R2,CVTASVT-CVTMAP(R2)   POINT TO ASVT\n         USING ASVT,R2                 SETUP ADDRESSABILITY\n         C     R1,ASVTMAXU             IS IT TOO BIG\n         BH    FAIL3                   SET INVALID ASID\n         SLL   R1,2                    ASID*4\n         LA    R1,ASVTENTY-4(R1)       POINT AT DESIRED ENTRY\n         MVC   TOASCB,0(R1)            SAVE ASCB ADDR\n         TM    TOASCB,ASVTAVAL         IS THIS ASCB EXISTANT\n         BO    FAIL3                   NOPE\n         LA    R3,SRBAREA     POINT AT THE SRB\n         DROP  R2\n         L     R2,TOASCB               GET ASCB ADDR\n         USING ASCB,R2                 SETUP ADDRESSABILITY\n         TM    ASCBRCTF,ASCBOUT        IS ASCB SWPPED OUT\n         BO    FAIL3                   YES SO DONOT TRY TO TOUCH IT\n         DROP  R2\n*\n*        INITIALIZE THE SRB AND INVOKE AS SRB\n*\n         USING SRBSECT,R3\n         XC    SRBAREA,SRBAREA  CLEAR THE SRB\n         MVC   SRBID,=C'SRB '  SET EBCDIC ID\n         MVC   SRBASCB,TOASCB SET ASCB ADDR TO RUN IN\n         AIF   (&XA).XA2                                            1.1\n         LA    R1,SRBCCD      POINT AT SRB CODE IN CSA        SP    1.1\n         AGO   .NXA2                                                1.1\n.XA2     ANOP                                                       1.1\n         BASR  R0,0           GET ADDRESSING MODE              XA   1.1\n         N     R0,=X'80000000'  LEAV ONLY ADDRESSING MODE      XA   1.1\n         LA    R1,SRBCCD      POINT AT SRB CODE IN CSA         XA   1.1\n         OR    R1,R0          PUT ADDRESSING MODE IN           XA   1.1\n.NXA2    ANOP                                                       1.1\n         ST    R1,SRBEP       SAVE ENTRY POINT\n         ST    R8,SRBPARM     SAVE PARM ADDR AS WORK AREA\n         LA    R1,D#RMTR-D#SRBCD(R1)  GET RESOURCE MGR TERMINATION\n         OR    R1,R0\n         ST    R1,SRBRMTR     AND SAVE IT\n         XC    ECB,ECB                 CLEAR THE ECBS FOR THE WAITLIST\n         XC    ECB2,ECB2\n         LA    R0,ECB\n         LA    R1,ECB2\n         STM   R0,R1,ECBLIST\n         MVI   ECBLIST+4,X'80'\n*\n*        NOW ISSUE TIMER INCASE SRB NEVER POSTS US\n*\n         STIMER REAL,D#STX,BINTVL==A(300)  WAIT 3 SECONDS\n         MODESET KEY=ZERO\n         SCHEDULE SRB=(R3),SCOPE=GLOBAL ISSUE SRB\n         MODESET KEY=NZERO\n         L     R2,=C'ABCD'             SET KEY IN REG\n         LA    R3,ECB2                 AND ADDR TO POST IN STIMER\n         WAIT  ECBLIST=ECBLIST\n         TTIMER CANCEL\n*\n*        WE ARE BACK FROM EITHER TIMER OR SRB OR SUB\n*\nGOTBACK  L     R8,CSAWORK              POINT AT CSA AREA\n         NI    FLAGS,255-GETINPG       TURN OFF GET IN PROGRESS\n         TM    FLAG1,FG1SUBR           IS THIS A SUB CALL\n         BO    GOTBK2                  IF SO IGNORE SOME ERRORS\n         TM    FLAG1,FG1SRDN           DID SRB TERMINATE GOOD\n         BZ    FAIL                    NOPE SO ERROR MSG\n         TM    FLAG2,FG2PSTR+FG2PURG+FG2ERRR AN ERRORS\n         BNZ   FAIL                    IF SO ERROR MESSAGE\nGOTBK2   DS    0H\n*\n*        NOW MOVE INFO OUT OF CSA BUFFER\n*\n         L     R2,12+12(R13)           GET ORIG R1 INTO R2 (DEST ADDR)\n         L     R3,12+8(R13)            GET DESIRED LENGTH\n         L     R4,CSABUF               POINT TO BUFFER\n         L     R5,LENGTH               GET ACTUAL LENGTH MOVED\n         LTR   R5,R5                   Did any memory get back     1.1C\n         BNZ   GOTBK4                  If so then use it           1.1C\n         C     R3,=F'2048'             Was original req >= default 1.1C\n         BNL   GOTBK4                  If so then cant get it      1.1C\n         TM    FLAGS,REFETCH           Q. Is this first or sec ent 1.1C\n         BO    GOTBK4                  A. Second, return no data   1.1C\n         OI    FLAGS,REFETCH           First entry so indicate     1.1C\n         ST    R3,LENGTH               Retry with orig req         1.1C\n         B     GETM2                                               1.1C\nGOTBK4   DS    0H                                                  1.1C\n         NI    FLAGS,255-REFETCH       reset flag before return    1.1C\n*\n*        NOTE THAT ORIG(R2) IS EFFECTIVELY AT R4\n*        FIRST BYTE DESIRED IS FIRST BYTE IN BUFFER\n*\n         MVCL  R2,R4                   MOVE IN CORE\n         L     R2,CSASTAR              GET START LOC\n         A     R2,LENGTH               PLUS LENGTH MOVED\n         ST    R2,CSAEND               SET CORRECT END ADDR\n         MVC   LOGOOD,CSASTAR          SET LOW RANGE DISPLAYABLE\n         MVC   HIGOOD,CSAEND           AND HIGH RANGE\n         MVC   12+12(4,R13),LENGTH     SET GOTTEN LENGTH\n*                                                                   1.1\n*        SET MESSAGE LINE TO INDICATE HOW SUCCESSFUL                1.1\n*        THE MEMORY FETCH WAS                                       1.1\n*                                                                   1.1\n         CLI   MERRCD,4                IS THIS PROTECTION ERROR    1.1A\n         BNE   GOTBK3A                 NO SO CHECK OTHERS          1.1A\n         MVC   MSGLINE,PROT            MOVE IN PROTECTION MSG      1.1A\n         B     GOTBK3                  ERROR SET                   1.1A\nGOTBK3A  DS    0H                                                  1.1A\n         CLI   MERRCD,X'11'            IS THIS A PAGE FAULT        1.1A\n         BE    GOTBK3B                 YES                         1.1A\n         CLI   MERRCD,X'10'            IS THIS A SEGMENT FAULT     1.1A\n         BNE   GOTBK3                  NO                          1.1A\nGOTBK3B  MVC   MSGLINE,NONEX           SET PAGE FAULT ERROR        1.1A\nGOTBK3   DS    0H                                                   1.1\n         LM    R14,R8,12(R13)          RESTORE REGS\n         LTR   R1,R1                   ANY LENGTH GOTTEN\n         BZR   R14                     IF NOT THEN EXIT +0\n         CR    R0,R1                   ALL DESIRED GOTTEN\n         BH    4(R14)                  IF NOT ALL THEN +4\n         B     8(R14)                  ALL DESIRED GOTTEN THEN +8\n*\n*        IF ANY ERRORS GIVE ERROR MSG AND RETURN +0\n*\nFAIL     DS    0H\n         DC    H'0'\n         MVC   MSGLINE,SRBMSG          MOVE IN MESSAGE\n         MVC   CURRENT+2(2),FLAG1\n         B     FAILALL                 GO TO COMMON ROUTINE\n*\n*        IF NOT AUTHORIZED TO DISPLAY OTHER ASIDS GIVE MSG AND RESET\n*\nFAIL2    DS    0H\n         MVC   MSGLINE,AUTHMSG         MOVE IN MESSAGE\n         B     FAILALL                 GO TO COMMON ROUTINE\n*\n*        IF ASID IS NOT VALID OR SWAPPED OUT GIVE MSG AND RESET\n*\nFAIL3    DS    0H\n         MVC   MSGLINE,BDASMSG         MOVE IN MESSAGE\nFAILALL  DS    0H                      COMMON FAILURE ROUTINE\n         MVC   CSASTAR,=F'0'           CLEAR THE START\n         MVC   CSAEND,=F'0'              AND END ADDR\n         MVC   CSAASID,=H'0'               AND THE ASID\n         MVC   CURASID,MYASID          RESET ASID AVAIL\n         RETURN (14,8)\n*\n*        STIMER EXIT ROUTINE\n*        ITS PURPOSE IS TO POST THE ECB AT ECB2 AND WAKE UP THE\n*        LOOK PROCESSOR IF THE SRB FAILS.  TO DO THIS WE MUST\n*        FIND THE ADDRESS OF THE ECB WHICH IS SAVED IN R3 OF\n*        THE RB ABOVE THE WAIT.  IN THAT RB, R2 IS SET TO 'ABCD'.\n*\n         USING *,R12\nD#STX    SAVE  (14,12)                 SAVE REGISTERS\n         LR    R12,R15                 SET BASE REG\n         L     R3,CVTPTR               POINT AT CVT\n         L     R3,0(R3)                POINT AT TCB WORDS\n         L     R3,0(R3)                POINT AT MY TCB\n         L     R3,0(R3)                POINT AT MY RB\n         USING RBBASIC,R3\nD#STX1   DS    0H                      NOW LOOK FOR KEY IN REG2\n         CLC   RBGRS2,=C'ABCD'         IS THE KEY HERE\n         BE    D#STX2                  YES\n         TM    XSTAB2,RBTCBNXT         TEST TCB FLAG\n         BO    D#STX3                  IF NOT FOUND PROPER RB\n         L     R3,RBLINK               POINT AT PREVIOUS RB\n         B     D#STX1\nD#STX2   L     R2,RBGRS3               GET ADDR OF ECB TO POST\n         POST  (R2)                    WAKE UP LOOK\n         RETURN (14,12)\n*\n*        IF WE CANT FIND THE RB THEN DUMP\n*\nD#STX3   DC    H'0'\n         DROP  R12,R3\n         LTORG\n         TITLE 'LOOK --  STORAGE ALTER/DISPLAY - SRB MODE CODE'\n         DROP  R9\nD#SRBCD  DS    0D\n*\n*        THIS CODE PERFORMS THE FOLLOWING FUNCTIONS\n*              1 ESTABLISHES AN FRR FOR ERROR RECOVERY\n*              2 VERIFIES THAT THE ADDRESSES THAT ARE NEEDED DO\n*                EXIST.\n*              3 PERFORM THE MODIFICATION IF ALLOW AND NECESSARY\n*              4 SAVE THE PROPER CORE FOR DUMPING.\n*              5 CROSS-MEMORY POST THE MAIN COMMAND PROCESSOR\n*\n         USING WORK,R8\n         USING D#SRBCD,R7\n         LR    R8,R1          SET THE MAIN PARM DSECT\n         LR    R7,R15         SET THE BASE REGISTER\n         ST    R14,ASRBRTN    SAVE RETURN ADDR\n         TM    FLAG1,FG1SUBR  IS THIS A SUBROUTINE CALL\n         BO    D#SRB1         YES SO SKIP FRR\n         LA    R5,D#FRRCD     POINT AT FRR CODE\n         SETFRR  A,FRRAD=(R5),WRKREGS=(2,3),PARMAD=(R4)\n         ST    R4,FRRPRMS     SAVE ADDR OF FRRPRMS\n*\n*        NOW INIT THE FRR PARM AREA AND VALIDATE THE INPUT ADDR\n*\nD#SRB1   L     R2,FRRPRMS     ACCESS THE 6 WORK PARM AREA\n         STM   R7,R8,0(R2)    SAVE BASE AND WORK REGS\n*\n*        MOVE MEMORY\n*\n         L     R2,ADDR                 SET START ADDR\n         LA    R0,BUF                  POINT AT BUFFER\n         L     R1,LENGTH               GET DESIRED LENGTH\n         LR    R3,R1                   SET LENGTH\n         OI    FLAG1,FG1MOVE           INDICATE IN MOVE\n         MVCL  R0,R2                   MOVE IN CORE\n         NI    FLAG1,255-FG1MOVE       NOTE NOT IN MOVE\n*\n*        NOW WE TERMINATE PROCESSING BY DOING A CROSS\n*        MEMORY POST IF NOT IN SUBROUTINE MODE\n*\nFRRRTY   TM    FLAG1,FG1SUBR  IS THIS SUBROUTINE MODE\n         BO    D#EXIT         IF SO THEN EXIT\n         SETFRR  D,WRKREGS=(2,3)\nFRRPOST  L     R10,=A(X'40000000') SET CODE FOR POST\n         LR    R9,R8          SAVE WORK POINTER IN SAFE REG\n         LA    R11,ECB        ADDR OF ECB TO POST\n         ICM   R11,8,=X'80'   FLAG AS XMPOST\n         LA    R12,D#POSTR    SET POST ERROR RETURN\n         L     R13,MYASCB     ASCB TO POST\n         L     R15,CVTPTR     POINT AT CVT\n         L     R15,CVT0PT01-CVTMAP(R15)    GET POST ENTRY POINTR\n         BALR  R14,R15        GO DO POST\n         DROP  R7             KILL MAIN ADDRESS\n         USING *,R14          SET TEMP BASE\nD#PRTN   LR    R8,R9          RESET BASE OF WORK\n         SL    R14,=A(D#PRTN-D#SRBCD)  NOW HAVE CORRECTED BASE\n         LR    R7,R14         SET TO PROPER REG\n         DROP  R14\n         USING D#SRBCD,R7     RESET MAIN BASE\n         OI    FLAG1,FG1SRDN  FLAG SRB AS COMPLETED\nD#EXIT   L     R14,ASRBRTN    RESTORE RETURN ADDR\n         BR    R14            EXIT\n         SPACE 5\n*\n*        POST ERROR ROUTINE  .. FLAG ERROR AND LET TIMER\n*        WAKE UP TASK\n*\nD#POSTR  LR    R8,R9          RESET WORK BASE\n         OI    FLAG2,FG2PSTR  FLAG POST ERROR\n         BR    R14            RETURN TO D#PRTN\n         TITLE 'LOOK --  STORAGE ALTER/DISPLAY - FRR FOR SRB'\nD#FRRCD  DS    0D\n         L     R2,0(R1)       POINT AT PARM AREA\n         LM    R7,R8,0(R2)    SET BASE REGS\n         TM    FLAG1,FG1MOVE  ARE WE IN VALIDATION\n         BZ    D#FRR1         NOPE\n*\n*        MOVE INCOMPLETE\n*\n         NI    FLAG1,255-FG1MOVE       TURN OFF FLAG\n         MVC   MERRCD,SDWAICD1-SDWA(R1) SAVE INT CODE               1.1\n         CLI   SDWAICD1-SDWA(R1),X'04' PROTECTION??\n         BNE   D#FRR0A                 IF NOT THEN TRY OTHERS\n*        IF PROTECTION THEN DATA TO POINT OF ERROR\n*        HAS BEEN MOVED SO JUST ADJUST LENGTH\n         L     R2,LENGTH\n         S     R2,SDWAGR01-SDWA(R1)    GET LENGTH NOT MOVED\n         ST    R2,LENGTH               SAVE MOVED LENGTH\n         B     D#FRR0                  ALL DONE\n*        IF ADDRESSING EXCEPTION THEN\n*        REGISTERS NOT ALWAYS UPDATED (PER POPS)\n*        BUT THE TRANSLATION ADDR IS CLOSE.\n*        ALSO NO DATA MAY HAVE BEEN MOVED.\n*        (WE ARE DEALING HERE WITH WHAT MAY BE \"MODEL DEPENDENT\"\n*        FEATURES)\nD#FRR0A  DS    0H\n         L     R2,SDWATRAN-SDWA(R1)    GET BAD ADDRESS\n         S     R2,ADDR                 LESS START ADDR\n         LTR   R2,R2                   ANY GOOD LENGTH\n         BM    D#FRR0                  NOPE                         1.1\n         C     R2,LENGTH               MAKE SURE IT IS REASONABLE\n         BH    D#FRR0                  SKIP IF NOT\n         ST    R2,LENGTH               SAVE AS GOTTEN LENGTH\n         LTR   R2,R2                   ANY LENGTH AT ALL            1.1\n         BZ    D#FRR0                  NO - SO SKIP MOVE            1.1\n         LR    R3,R2                   SETUP LENGTH\n         LR    R5,R2                                               1.1C\n         L     R2,ADDR                 GET FROM ADDR\n         LA    R4,BUF                  GET TO ADDRESS              1.1C\n         MVCL  R4,R2                                               1.1C\nD#FRR0   OI    FLAG2,FG2IVLD  SET FLAG FOR MESSAGE\n         SETRP RECORD=NO,RC=4,RETADDR=FRRRTY,REGS,DUMP=NO,             X\n               RETREGS=YES,FRESDWA=YES\n         BR    R14            EXIT\n         SPACE 5\n*\n*        ALL OTHER ERRORS\n*\nD#FRR1   OI    FLAG2,FG2ERRR  SET FLAG FOR MESSAGES\n         SETRP RECORD=YES,RC=4,RETADDR=FRRRTY,REGS,DUMP=YES,           X\n               RETREGS=YES,FRESDWA=YES\n         BR    R14            EXIT\n         TITLE 'LOOK --  STORAGE ALTER/DISPLAY - RESOURCE MGR. CLEANUP'\n*\n*        THIS ROUTINE RECEIVES CONTROL IF THE SRB MUST BE\n*        PURGED.\n*\nD#RMTR   DS    0H\n         USING *,R15\n         LR    R7,R15         SET BASE REGISTER\n         SL    R7,=A(D#RMTR-D#SRBCD)   BY COMPUTATION\n         DROP  R15\n         USING D#SRBCD,R7\n         LR    R8,R2          SET UP POINTER TO WORK\n         ST    R14,ASRBRTN    SAVE RETURN ADDR\n         OI    FLAG2,FG2PURG  SET PURGED\n         B     FRRPOST        GO AND POST TO CLEAN UP\n         LTORG\nENDSRB   EQU   *\nSRBCODE  EQU   *-D#SRBCD               LENGTH OF SRB CODE\n         TITLE 'LOOK --  STORAGE ALTER/DISPLAY - MESSAGES, CONSTANTS'\nKEY1 DC CL80'1= HELP      2=           3= END        4=           5= REX\n               PEAT  6=          '\nKEY2 DC CL80'7= BACKWARD  8= FORWARD   9= HIST BWD  10= HIST FWD 11=   X\n                    12=          '\n* ERROR MESSAGE FOR BAD INPUT\nTITLE    DC    CL79' '\nMODEMSG  DC    CL79'***** INVALID MODE'\nINVALOP  DC    CL79'***** INVALID OPERATOR'\nSYMFULL  DC    CL79'***** SYMBOL TABLE IS FULL'\nNAMEMSG  DC    CL79'***** UNDEFINED SYMBOL'\nDEFMSG   DC    CL79'***** NULL SYMBOL OR SYMBOL TOO LONG'\nPCMSG    DC    CL79'***** PROGRAM CHECK'\nLINKMSG  DC    CL79'***** LINK FAILED'\nSRBMSG   DC    CL79'***** SRB DATA FETCH FAILED'\nAUTHMSG  DC    CL79'***** LOOK NOT CURRENTLY AUTHORIZED. REQUEST DENIEDX\n               .'\nBDASMSG  DC    CL79'***** ASID INVALID OR SWAPPED OUT.'\nBADIMSG  DC    CL79'***** INDIRECT FAILED.'\nASIDFMT  DC    CL13'DISPLAY ASID='\nERRMSG   DC    CL79'INVALID ADDRESS -- TRY AGAIN'\nPROT     DC    CL79'--- PART/ALL OF REQUESTED MEMORY FETCH PROTECTED' 1\nNONEX    DC    CL79'--- PART/ALL OF REQUEST MEMORY NON-EXISTENT'    1.1\nBLANKS   DC    CL79' '\n         EJECT\nHEXTAB   DC    256C' '                 GENERAL HEX CONVERSION TABLE\n         ORG   HEXTAB+C'A'             INPUT CONVERSION\n         DC    X'0A0B0C0D0E0F'\n         ORG   HEXTAB+C'0'             OUTPUT CONVERSION\n         DC    C'0123456789ABCDEF'\n         ORG\n* HEX INPUT TRT TABLE\nNUMTAB   DC    256X'1'\n         ORG   NUMTAB+C'A'\n         DC    6X'0'\n         ORG   NUMTAB+C'0'\n         DC    10X'0'\n         ORG\nVALCHAR  DC    256C'.'                 TRANSLATE TO VALID CHARS\n         ORG   VALCHAR+C' '\n         DC    C' '\n         ORG   VALCHAR+C'\u00a2'\n         DC    C'\u00a2.<(+|&&'\n         ORG   VALCHAR+C'!'\n         DC    C'!$*);\u00ac-/'\n         ORG   VALCHAR+C','\n         DC    C',%_.?'\n         ORG   VALCHAR+C':'\n         DC    C':#@''=\"'\n         ORG   VALCHAR+C'a'\n         DC    C'abcdefghi'\n         ORG   VALCHAR+C'j'\n         DC    C'jklmnopqr'\n         ORG   VALCHAR+C's'\n         DC    C'stuvwxyz'\n         ORG   VALCHAR+C'A'\n         DC    C'ABCDEFGHI'\n         ORG   VALCHAR+C'J'\n         DC    C'JKLMNOPQR'\n         ORG   VALCHAR+C'S'\n         DC    C'STUVWXYZ'\n         ORG   VALCHAR+C'0'\n         DC    C'0123456789'\n         ORG\n         LTORG\n         SPACE 2\n*        SCREEN DEFINITION AREA\nQDINIT   DS    0D             START OS DISPLAY WORK AREA\n         DC    F'0'           ORIG SCREEN DEPTH\n         DC    F'0'           ORIG SCREEN LINESZ\n         DC    H'80'          LENGTH OF DISPLAY LINE\n         DC    PL2'21'        LINES PER SCREEN\n         DS    0D\n         DS    0CL69\n         DC    CL6' '\n         DC    CL63' '\n         DC    CL63' '        CORRECTED DATA FROM SCREEN\n         DS    0C             DISPLAY SCREEN\n         DC    X'27'          CONTROL\n         DC    X'F5'          ERASE/WRITE\n         DC    X'C1115D7F1140403C404000' CLEAR SCREEN\n         DC    CL43'LOOK COMMAND - DISPLAY VIRTUAL MEMORY' TITLE L 1.1D\n         DC    CL13'DISPLAY ASID='\n         DC    X'1DC8'        MARK NEXT FIELD AS INPUT FIELD\n         DC    CL4' '         IN/OUT FOR ASID\n         DC    X'1DF0'        TERMINATE INPUT FIELD\n         DC    X'11'          SET BUFFER ADDRESS\n         DC    X'C150'        (2,1)\n         DC    C'ENTER CMD -'     REPLY PROMPT\n         DC    X'1DC8'        MARK NEXT FIELD AS INPUT FIELD\n         DC    X'13'          SET CURSOR ADDRESS\n         DC    X'11'          SET BUFFER ADDRESS\n         DC    X'C25B'        (2,76)\n         DC    X'1DF0'        TERMINATE INPUT FIELD\n         DC    X'11'          SET BUFFER ADDRESS\n         DC    X'C260'        (3,1)\n         DC    C'LAST CMD  - '\n         DC    CL63' '        PREVIOUS COMMAND\n         DC    X'11'          SET BUFFER ADDRESS\n         DC    X'C3F0'        (4,1)\n         DC    CL79' '\n         DC    C' '\n         DC    16CL80' '      MESSAGE TEXT AREA\n         DC    2CL80' '\n         DC    2CL80' '       PFK DISPLAY AREA\nHELPMSG  DS    0H\n DC CL80'LOOK is a real time core display and formatting program. It alX\n               so has the        '\n DC CL80'capability of displaying memory in any address space (if authoX\n               rized).           '\n DC CL80'                                                              X\n                                 '\n DC CL80'The valid commands are:                                       X\n                                 '\n DC CL80'Iexp  24 bit indirect                 | Jexp  31 bit indirect X\n                                 '\n DC CL80'>     Forward                         | <     Backward        X\n                                 '\n DC CL80'=sym  Define current address as \"sym\" | ,sym  Redisplay core aX\n               t \"sym\"           '\n DC CL80'M0/M1 Flip between top and center     | Lname Indirect thru coX\n               ntrol block field '\n DC CL80'Ocb   Format as \"cb\" control block    | R     Refresh displayeX\n               d storage         '\n DC CL80'      \"cb\" may be NULL to show as hex |                       X\n                                 '\n DC CL80'                                                              X\n                                 '\n DC CL80'where ''exp'' is of the form:                                 X\n                                   '\n DC CL80'    <+/->hhhh<+/-hhhh<+/-hhhh...>>                            X\n                                 '\n DC CL80'and ''hhhh'' is a 1 to 8 digit hex number.                    X\n                                   '\n DC CL80'                                                              X\n                                 '\n DC CL80'                                                              X\n                                 '\n         TITLE 'LOOK --  STORAGE ALTER/DISPLAY - WORK AREAS, DSECTS'\n*----------------------------------------------------------------------\n*\n* HIST -- HISTORY ENTRY FOR ONE OR MORE PREVIOUS ENTRIES\n*\n*----------------------------------------------------------------------\n         SPACE 2\nHIST     DSECT\nHISTADDR DS    A                       ADDR OF STORAGE/MAIN CB ADDRES\nHISTCBHP DS    A                       0 IF NO CB\n*                                      X'7FFFFFFF' IF OVERLAY NULL\n*                                      ADDR OF CBH IF CB DISPLAYED\nHISTCBSP DS    A                       ADDR OF CBS DISPLAYED\nHISTSADR DS    A                       ADDR OF STORAGE FOR THIS SEG\nHISTLEN  EQU   *-HIST                  LENGTH OF ENTRY\n         SPACE 5\n*----------------------------------------------------------------------\n*\n* CBH  -- CONTROL BLOCK HEADER  -  ONE FOR EACH DIFFERENT CONTROL BLK\n*\n*----------------------------------------------------------------------\n         SPACE 2\nCBH      DSECT\nCBHNEXT  DS    A                       ADDR OF NEXT CONTROL BLOCK OR 0\nCBHVOFF  DS    A                       OFFSET OF VALIDATION FIELD\nCBHCBSP  DS    A                       ADDR OF FIRST SEG DESCIPTOR\nCBHNAME  DS    CL8                     NAME OF BLOCK\nCBHVLEN  DS    X                       LENGTH OF VALIDATION FIELD\nCBHVAL   DS    0X                      VALIDATION DATA\n         SPACE 5\n*----------------------------------------------------------------------\n*\n* CBS  -- CONTROL BLOCK SEGMENT\n*\n*----------------------------------------------------------------------\n         SPACE 2\nCBS      DSECT\nCBSPREV  DS    A                       ADDRESS OF PREVIOUS SEGMENT\nCBSNEXT  DS    A                       ADDRESS OF NEXT SEGMENT\nCBSDLEN  DS    AL2                     LENGTH OF DATA TO FETCH\nCBSDOFF  DS    AL2                     OFFSET OF DATA TO FETCH\nCBSILEN  DS    AL2                     LENGTH OF INDIRECT TO FETCH\nCBSIOFF  DS    AL2                     OFFSET OF INDIRECT TO FETCH\nCBSLEN   EQU   *-CBS                   LENGTH OF SEGMENT HEADER\n         SPACE 5\n*----------------------------------------------------------------------\n*\n* CBF  -- CONTROL BLOCK FIELD\n*\n*----------------------------------------------------------------------\n         SPACE 2\nCBF      DSECT\nCBFNAME  DS    CL8                     NAME OF FIELD\nCBFTYPE  DS    CL1                     TYPE OF NAME\nCBFDLEN  DS    XL1                     LENGTH OF DATA TO DISPLAY\nCBFOFFS  DS    H                       OFFSET INTO BLOCK START\nCBFLINE  DS    H                       LINE NUMBER TO PUT ON\nCBFCOLM  DS    H                       COLUMN TO START IN\nCBFLEN   EQU   *-CBF\n         EJECT\n*----------------------------------------------------------------------\n*\n*   MAIN DYNAMIC WORK AREA\n*\n*----------------------------------------------------------------------\nWORKAREA DSECT\nSAVE     DS    18F\nHISTORY  DS    F                       HISTORY TABLE ADDRESS\nNAMES    DS    150F                    SYMBOL TABLE\nCURRENT  DS    H                       HIST TABLE OFFSET\nESTAE    ESTAE 1,PARAM=0,MF=L      ROOM FOR ESTAE PARM LIST\n         DS    0F,H                SPACER\nESRUB    DS    H                   BIT INDICATOR SHOULD BE X'0074'\nBASE1    DS    F                   SECOND BASE REG (R9)\nBASR10   DS    F                   NORMAL R10\nBASE2    DS    F                   FIRST BASE REG (R11)\nBASR13   DS    F                   NORMAL R13\nTEMP1    DS    CL9                     CONVERSION WORK AREA\nTEMP2    DS    CL9                     CONVERSION WORK AREA\nLOGOOD   DC    F'0'\nHIGOOD   DC    XL4'FFFFF123'\nCSALEN   DS    F                       SP AND LEN OF CSA WORK AREA\nCSAWORK  DS    A                       ADDRESS OF CSA WORKAREA\nCSABUF   DS    A                       ADDRESS OF CSA DATA BUFFER FOR\n*                                      SRB\nCSASTAR  DS    A                       USERS ADDR OF BEGINNING OF\n*                                      BUFFER DATA\nCSAEND   DS    A                       USERS ADDR OF END OF BUFFER DATA\nCSAASID  DS    H                       USERS ASID FOR BUFFER DATA\nMYASID   DS    H                       DCMS ASID\nCURASID  DS    H                       DISPLAYED CORE ASID\nSAVEASID DS    CL4                     FORMATED VERSION OF CURASID\nFLAGS    DS    X                       ASSORTED FLAGS\nINDFLAG  EQU   X'80'                   INDIRECT IN PROGRESS\nNOAUTH   EQU   X'40'                   IF ON THEN NOT AUTHORIZED\nGETINPG  EQU   X'20'                   ON IF GETSTOR IN PROGRESS (SUBR)\nRFRSH    EQU   X'10'                   ON TO REFRESH CSA BUFFER\nIND31    EQU   X'08'                   31 BIT INDIRECT IN PROGRESS\nREFETCH  EQU   X'04'                   First get failed and retry  1.1C\nMODEFLAG DS    X                       USER OPTION FLAGS\nMIDDUMP  EQU   X'80'                   ON TO FORCE DISPLAY BACK 8 LINES\nALIGN    EQU   X'40'                   ON TO ALIGN DUMP ON QUADWORD\n         SPACE 2\n*        SCREEN DEFINITION AREA\nQDISPLAY DS    0D             START OS DISPLAY WORK AREA\nQDOSZR0  DC    F'0'           ORIG SCREEN DEPTH\nQDOSZR1  DC    F'0'           ORIG SCREEN LINESZ\nQDLNELEN DC    H'80'          LENGTH OF DISPLAY LINE\nQDLNES   DC    PL2'21'        LINES PER SCREEN\n         DS    0D\nPFREPLY  DS    0CL69\nPFCODE   DC    CL6' '\nPFTXT    DC    CL63' '\nINPLINE  DC    CL63' '        CORRECTED DATA FROM SCREEN\nQDSCREEN DS    0C             DISPLAY SCREEN\n         DC    X'27'          CONTROL\n         DC    X'F5'          ERASE/WRITE\n         DC    X'C1115D7F1140403C404000' CLEAR SCREEN\n         DC    CL43'LOOK COMMAND - DISPLAY VIRTUAL MEMORY' TITLE L 1.1D\nASIDLN   DC    CL13'DISPLAY ASID='\n         DC    X'1DC8'        MARK NEXT FIELD AS INPUT FIELD\nASIDLN1  DC    CL4' '         IN/OUT FOR ASID\n         DC    X'1DF0'        TERMINATE INPUT FIELD\n         DC    X'11'          SET BUFFER ADDRESS\n         DC    X'C150'        (2,1)\n         DC    C'ENTER CMD -'     REPLY PROMPT\n         DC    X'1DC8'        MARK NEXT FIELD AS INPUT FIELD\n         DC    X'13'          SET CURSOR ADDRESS\n         DC    X'11'          SET BUFFER ADDRESS\n         DC    X'C25B'        (2,76)\n         DC    X'1DF0'        TERMINATE INPUT FIELD\n         DC    X'11'          SET BUFFER ADDRESS\n         DC    X'C260'        (3,1)\n         DC    C'LAST CMD  - '\nINPSAVE  DC    CL63' '        PREVIOUS COMMAND\n         DC    X'11'          SET BUFFER ADDRESS\n         DC    X'C3F0'        (4,1)\nMSGLINE  DC    CL79' '\n         DC    C' '\nOUT1     DC    16CL80' '      MESSAGE TEXT AREA\nOUT9     EQU   OUT1+(8*80)\n         DC    2CL80' '\nKEYS     DC    2CL80' '       PFK DISPLAY AREA\nQDISPLN  EQU   *-QDISPLAY     LENGTH OF ENTIRE DISPLAY\nQDSLNG   EQU   *-QDSCREEN     LENGTH OF SCREEN BUFFER\n*\n**       AREA TO HOLD DATA RETURNED BY GETSTOR\n*\nDUMPDATA DS    XL(MAXFETCH)            DATA RETURNED BY GETSTOR\nWORKLEN  EQU   *-WORKAREA\n         EJECT\n         PRINT NOGEN\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n*        END\n         IHAASCB\n         IHAASVT\n         IHAFRRS\n         IHAPSA\n         IHASDWA\n         IHASRB\n         IHARB\n         CVT   DSECT=YES\n         EJECT\n*\n*        CSA AREA WORK AREA\n*\nWORK     DSECT\nWORKSTRT DS    0D\nDOUBLE   DS    2F\nDMYPRMS  DS    6F             DUMMY AREA FOR FRR PARMS FOR SUBR MODE\nFRRPRMS  DS    F              ADDRESS OF 6 WORD FRR PARM\nASRBRTN  DS    F              RETURN ADDR FOR SRB CODE\nMYASCB   DS    F              ASCB ADDR OF MAIN ROUTINE\nMYTCB    DS    F              TCB ADDRESS FOR MAIN ROUTINE\nTOASCB   DS    F              ASCB ADDR OF SRB ROUTINE\nECB      DS    F              ECB FOR MAIN ROUTINE TO WAIT ON\nECB2     DS    F              ECB FOR STIMER TO POST\nECBLIST  DS    2F\nLENGTH   DS    F              LENGTH OF STORAGE TO DUMP\nSRBAREA  DS    ((SRBSIZE+3)/4)F  THE SRB ITSELF\nADDR     DS    F              ADDRESS TO PROCESS AT\nASID     DS    H              ASID OF TOASCB\nFLAG1    DS    X\nFG1DUMP  EQU   X'80'\nFG1REP   EQU   X'40'\nFG1MOVE  EQU   X'20'                   IF ON DOING MVCL FOR DATA\nFG1SRDN  EQU   X'02'          IF ON SRB HAS TERMINATED\nFG1SUBR  EQU   X'01'\nFLAG2    DS    X\nFG2NVER  EQU   X'01'          VERIFICATION FAILED\nFG2IVLD  EQU   X'02'          VALIDATION FAILED\nFG2ERRR  EQU   X'04'          DISASTER OCCURED IN SRB\nFG2PURG  EQU   X'08'          SRB WAS PURGED\nFG2PSTR  EQU   X'10'          IF ON THEN SRB POST HAD ERROR\nMERRCD   DS    X                       INTERRUPT CODE               1.1\nSRBCCD   DS    0D                      ALIGN SRB CODE ON DBL WORD\n         DS    (SRBCODE)X\n         DS    0D                      ALIGN BUFFER\nBUF      DS    (MAXFETCH)X\nWORKLN   EQU   *-WORKSTRT\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LOOK01": {"ttr": 8454, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01O\\x00V\\x00\\x86\\x15/\\x01\\x165O\\x10R\\x07Q\\x05#\\x03\\x9a\\xd7\\xd9\\xc5\\xe5\\xc9\\xe4\\xe2@@@'", "ispf": {"version": "01.79", "flags": 0, "createdate": "1986-06-01T00:00:00", "modifydate": "2016-12-19T10:52:56", "lines": 1873, "newlines": 1315, "modlines": 922, "user": "PREVIUS"}, "text": "         TITLE 'LOOK --  STORAGE ALTER/DISPLAY'\n*\n**\n**       THIS VERSION OF LOOK SUPPORTS MULTIPLE ADDRESS SPACE\n**       INVESTIGATION.\n**\n**       THIS VERSION DOES NOT YET SUPPORT ALTER CAPABILITY\n**\n**       THIS VERSION IS CONFIGURED TO RUN AND RESIDE ABOVE THE LINE\n**\n**   VERSION 1.1 CHANGES (6/1/88):                                  1.1\n**      - CORRECT ESTAE AND FRR ATTEMPTS TO DETERMINE HOW MUCH      1.1\n**        DATA WAS MOVED.                                           1.1\n**      - GIVE MESSAGES IF DATA WAS NOT MOVED, DISTINGUISH BETWEEN  1.1\n**        NON-EXISTANT (PAGE/SEGMENT FAULT), AND KEY/FETCH          1.1\n**        PROTECTION ERROR.                                         1.1\n**      - TRANSLATE THE OUTPUT CHARACTER STRINGS FOR CONTROL BLOCK  1.1\n**        FORMATING. THANKS TO MR. S. GOLOB OF NEWSWEEK             1.1\n**      - COMBINE XA AND SP MODULES INTO 1 VIA GLOBAL SYMBOL        1.1\n**\n**   VERSION 1.1A CHANGES (12/5/88):                               1.1A\n**      - CORRECT HANDLING OF ERROR MESSAGES.                      1.1A\n**\n**   VERSION 1.1B CHANGES (10/31/89):                              1.1B\n**      - Change amount of core gotten for ESA.                    1.1B\n**\n**   VERSION 1.1C CHANGES (11/28/90):                              1.1C\n**      - Add changes from Bruce Bordonaro.                        1.1C\n**            - Use STTMPMD.                                       1.1C\n**            - Add significant number of macro formats.           1.1C\n**      - Improve memory fetch when CPU does no data movement.     1.1C\n**      - Fix problem in FRR recovery.                             1.1C\n**\n**   VERSION 1.1D CHANGES (01/22/91):                              1.1D\n**      - Add spelling corrections from Sam Golob.                 1.1D\n**      - Correct HELP screen for Overlay command.                 1.1D\n**      - Correct Mode command.                                    1.1D\n**      - Fix bugs in control block segments.                      1.1D\n**      - Handle 31 bit address correctly when top bit on.         1.1D\n**      - Correct title - Never did and never will actually        1.1D\n**                         zap memory - use INCORZAP or #D         1.1D\n**      - Stop long fields from overlaying next lines.             1.1D\n**      - Correct blanking out of areas not available              1.1D\n**      - Get memory line at a time in dump, if necessary.         1.1D\n**\n**   VERSION 1.1E CHANGES (07/02/91):                              1.1E\n**      - If authorized then do memory fetchs in KEY=0.            1.1E\n**\n*\n         EJECT ,                                                   1.1D\n         MACRO\n&N       HEX   &TO,&FROM\n&N       UNPK  TEMP1(9),&FROM.(5,R6)\n         MVC   &TO.(8,R4),TEMP1\n         TR    &TO.(8,R4),HEXTAB\n         MEND\n         EJECT ,                                                   1.1D\nLOOK     CSECT\n******************************                                     1.1D\n**                                                                 1.1D\n**     Fetch constant - maximum amount fetchable in one call       1.1D\n**                                                                 1.1D\nMAXFETCH EQU   4096                                                1.1D\n**                                                                 1.1D\n**                                                                 1.1D\n******************************                                     1.1D\n         SPACE 3                                                   1.1D\n*                                                                   1.1\n*        SET THE FOLLOWING GLOBAL SYMBOL TO 1 FOR XA AND 0 FOR SP   1.1\n*                                                                   1.1\n         GBLB  &XA                                                  1.1\n&XA      SETB  1 =XA MODE              SET TO 1 FOR XA              1.1\n         SPACE 3                                                    1.1\n*  INITIALIZE THE PROGRAM\n         SAVE  (14,12),,'LOOK..&SYSDATE..&SYSTIME'\n         LR    R11,R15                 PERMANENT BASE\n         USING LOOK,R11\n         LA    R9,2048(R11)            GET A SECOND BASE REG\n         LA    R9,2048(R9)\n         USING LOOK+4096,R9\n         AIF   (&XA).XA1                                            1.1\n         GETMAIN R,LV=WORKLEN,SP=1                          SP      1.1\n         AGO   .NXA1                                                1.1\n.XA1     ANOP                                                       1.1\nLOOK     AMODE 31                                           XA      1.1\nLOOK     RMODE ANY                                          XA      1.1\n         GETMAIN R,LV=WORKLEN,SP=1,LOC=(BELOW,ANY)          XA      1.1\n.NXA1    ANOP                                                       1.1\n         LR    R10,R1\n         LR    R2,R10                  WORK AREA START\n         L     R3,=A(WORKLEN)          LENGTH TO CLEAR\n         SR    R5,R5                   ZERO PAD BYTE, LENGTH 2\n         MVCL  R2,R4                   CLEAR THE WORK AREA\n         USING WORKAREA,R10\n         LA    R4,QDINIT\n         LA    R3,QDISPLN              GET LENGTH\n         LA    R2,QDISPLAY             POINT AT START\n         LR    R5,R3                   SET FROM LENGTH\n         MVCL  R2,R4                   INIT DISPLAY\n         ST    R13,SAVE+4              CHAIN THE SAVE AREAS\n         LA    R15,SAVE\n         ST    R15,8(,R13)\n         LR    R13,R15                 NEW SAVE AREA\n         STM   R9,R11,BASE1        SAVE FIRST THREE REGS FOR AREA\n         ST    R13,BASR13          AND ORIGINAL R13\n         LA    R1,50*HISTLEN           GET LENGTH OF HIST TBL\n         GETMAIN R,SP=2,LV=(1)\n         ST    R1,HISTORY              SAVE ADDRESS\n         STFSMODE ON,INITIAL=YES       TELL TSO WE ARE FULLSCREEN\n         STTMPMD ON,KEYS=ALL                                       1.1C\n*\n*        SET SUPERVISOR MODE IF AUTHORIZED\n*\n         OI    FLAGS,NOAUTH            SET NOT AUTHORIZED\n         L     R1,=A(WORKLN)           GET LENGTH OF CAS BUFFER\n         ST    R1,CSALEN               SET LENGTH AND SP0\n         TESTAUTH FCTN=1               ARE WE AUTHORIZED\n         LTR   R15,R15\n         BNZ   NOTAUTH                 IF NOT SKIP CODE\n         MVI   CSALEN,241              SET CSA SP\n         NI    FLAGS,255-NOAUTH        MARK AUTHORIZED\n         MODESET MODE=SUP              SET TO SUP MODE\nNOTAUTH  DS    0H\n*\n*        SETUP ESTAE IN CORRECT MODE\n*\n         ESTAE EREXIT,PARAM=(R10),MF=(E,ESTAE)\n*\n*        INITIALIZE ASID POINTERS\n*\n         MVC   ASIDLN,ASIDFMT          SET MESSAGE\n         L     R1,16                   GET CVT\n         L     R2,0(,R1)               GET TCBWORDS\n         L     R1,12(,R2)              GET OLD ASCB ADDR (MINE)\n         USING ASCB,R1\n         MVC   MYASID,ASCBASID         MOVE IN MY ASID\n         MVC   CURASID,MYASID\n         DROP  R1\n         XC    CSAASID,CSAASID         CLEAR THE CSA BUFFER INDIC\n         XC    CSASTAR,CSASTAR\n         XC    CSAEND,CSAEND\n         L     R0,CSALEN               GET LENGTH AND SP FOR CSA BUFFER\n         GETMAIN R,LV=(0)\n         ST    R1,CSAWORK              SAVE ADDR OF CSA BUFFER\n         LR    R8,R1                   SET PROPER POINTER\n         USING WORK,R8\n         MVC   MYTCB,4(R2)             SAVE ADDR OF MY TCB\n         MVC   MYASCB,12(R2)           SAVE ADDR OF MY ASCB\n         LA    R1,BUF                  POINT TO TRUE BUFFER\n         ST    R1,CSABUF\n         LA    R0,SRBCCD               POINT TO CSA SRB CODE AREA\n         LA    R1,SRBCODE              AND LENGTH OF CODE\n         LR    R3,R1\n         LA    R2,D#SRBCD              POINT TO CSECT CODE\n         MVCL  R0,R2                   MOVE SRB CODE TO CSA\n         B     ISCAN1                  GO AND PROCESS\n         DROP  R8\n         EJECT\n***********************************************************************\n*\n*   INPUT SCAN\n*\n***********************************************************************\n         SPACE 2\nISCAN    CLC   SAVEASID,ASIDLN1        DID USER CHANGE ASID\n         BE    ISCAN1                  NOPE\n*\n*        FORMAT AND SAVE USER ASID\n*\n         MVC   TEMP1(4),ASIDLN1        GET USER INFO\n         OC    TEMP1(4),=CL4' '        MAKE UPPER CASE\n         TR    TEMP1(4),HEXTAB         MAKE PACKABLE\n         PACK  TEMP2(3),TEMP1(5)\n         MVC   CURASID,TEMP2           GET NEW ASID\nISCAN1   MVC   INPSAVE,INPLINE         SAVE LAST USER INPUT\nISCAN2   LA    R3,INPLINE              POINT TO START OF INPUT\n         LA    R1,SCANTAB              COMMAND TABLE\n         NI    FLAGS,255-INDFLAG-IND31 TURN OFF INDIRECT FLAG\n         MVC   MSGLINE,TITLE           CLEAR OUT ERROR MSG\nSCANLOOP L     R2,4(,R1)               GET TABLE ENTRY\n         CLC   0(1,R1),ENDTAB          SEE IF END OF TABLE\n         BE    NUMSCAN                 IF YES, ASSUME NUMERIC INPUT\n         CLC   0(1,R1),INPLINE         SEE IF COMMAND FOUND\n         BER   R2                      IF YES, GO TO COMM ROUINE\n         LA    R1,8(,R1)               NEXT ENTRY ADDRESS\n         B     SCANLOOP\nSCANTAB  DS    0F                      COMMAND TABLE\n         DC    CL4' ',A(FORMAT)\n         DC    CL4'I',A(INDIR)\n         DC    CL4'J',A(INDIR31)\n         DC    CL4'>',A(FWD)\n         DC    CL4'<',A(BACK)\n         DC    CL4'=',A(DEFINE)\n         DC    CL4',',A(NUMSCAN)\n         DC    CL4'M',A(MODE)\n         DC    CL4'L',A(LINK)\n         DC    CL4'O',A(OVERLAY)\n         DC    CL4'R',A(REFRESH)\nENDTAB   DC    X'FF'                   END OF TABLE INDICATOR\n         SPACE 2\n***********************************************************************\n*\n*     FORMAT THE OUTPUT SCREEN\n*\n***********************************************************************\n         SPACE 2\nFORMAT   LA    R3,INPLINE              CURSOR ADDRESS\n         MVC   INPLINE,BLANKS          CLEAR INPUT LINE\nFORMAT2  BAL   R14,ERASE               CLEAR THE SCREEN\n         LH    R2,CURRENT              HISTORY TABLE POINTER\n         A     R2,HISTORY              POINT AT HISTORY TABLE ENTRY\n         USING HIST,R2                 IDENTIFY HISTORY ENTRY FORMAT\n         L     R4,HISTADDR             GET ADDRESS TO DISPLAY\n         TM    HISTCBHP,X'80'          IS THIS A CB MAP IN USE\n         BO    CBHIT                   IF SO THE PROCESS IT\n         CLC   =X'7FFFFFFF',HISTCBHP   SUPPRESSED CB USAGE\n         BE    NOCB\n         DROP  R2\n         SPACE 2\n*----------------------------------------------------------------------\n*\n*        SEE IF CONTROL BLOCK MAP EXISTS\n*\n*----------------------------------------------------------------------\n         SPACE 2\nDUMP     L     R5,=V(CBMACS)           GET START OF INDEX\n         LTR   R5,R5                   ANY VALUE\n         BZ    NOCB                    NOPE\n         USING CBH,R5                  ADDRESS THE CONTROL BLK HEADER\nDUMPCB   CLC   =F'0',CBHNEXT           SEE IF END OF INDEX\n         BE    NOCB                    IF YES, NO CB FOUND\n         L     R2,CBHVOFF              GET CB IDENTIFIER OFFSET\n         AR    R2,R4                   ADD DISPLAY ADDRESS\n         SR    R3,R3                   CLEAR A REGISTER FOR IC\n         IC    R3,CBHVLEN              GET LENGTH\n         LR    R0,R3                   PUT IN 0 FOR GETSTOR\n         LA    R1,DUMPDATA             TARGET ADDR\n         BAL   R14,GETSTOR             FETCH THE DATA\n         B     NOTCB                   BR IF NO DATA FOUND\n         B     NOTCB                   BR IF PARTIAL DATA FOUND\n         BCTR  R3,0                    GET MACHINE LENGTH\n         EX    R3,CBFNDIT              LOOK FOR VALIDATION FIELD\n         BE    CBHIT                   BR IF YES, CB WAS FOUND\nNOTCB    L     R5,CBHNEXT              NEXT INDEX ENTRY\n         MVC   MSGLINE,BLANKS          Clear useless error msg     1.1C\n         B     DUMPCB                  AND CHECK FOR MORE CB'S\nCBFNDIT  CLC   CBHVAL(*-*),DUMPDATA    SEE IF IDENTIFIER MATCH\n         DROP  R5\n         SPACE 2\n*----------------------------------------------------------------------\n*\n* IF NO CONTROL BLOCK TO BE SHOWN, JUST USE DUMP FORMAT\n*\n*----------------------------------------------------------------------\n         SPACE 2\nNOCB     LR    R2,R4                   COPY ADDR TO DISPLAY\n         TM    MODEFLAG,ALIGN          QUADWORD ALIGNMENT WANTED\n         BZ    DUMPNOA                 BR IF NOT\n         N     R2,=XL4'FFFFFFF0'       ROUND DOWN FOR DISPLAY\nDUMPNOA  TM    MODEFLAG,MIDDUMP        PUT ADDR INCENTER OF SCREEN?\n         BZ    DUMPNOM                 BR IF NOT\n         SH    R2,=H'128'              IF YES, BACK UP QUAD WORDS\n* R2 NOW HAS FIRST ADDRESS TO DISPLAY\nDUMPNOM  LA    R0,256                  LENGTH TO FETCH\n         LA    R1,DUMPDATA             TARGET ADDRESS\n         LA    R2,0(0,R2)              clear top bit               1.1D\n         BAL   R14,GETSTOR             GO FETCH THE DATA\n         B     DUMPLN                  go dump by line             1.1D\n         NOP   0                       RETURN IF PARTIAL DATA FOUND\n         LA    R6,DUMPDATA             POINT TO DATA TO DISPLAY\n         LA    R4,OUT1                 FIRST OUTPUT LINE ADDR\n         LA    R5,16                   NO. OF LINES TO DISPLAY\nDUMPLOOP DS    0H                      FORMAT THE DISPLAY\n         STCM  R2,15,TEMP2             ADDRESS TO SHOW\n         UNPK  TEMP1(9),TEMP2(5)       CONVERT BINARY TO HEX\n         MVC   0(8,R4),TEMP1\n         TR    0(8,R4),HEXTAB\n         HEX   12,0                    CONVERT FIRST WORD TO HEX\n         HEX   22,4                    SECOND WORD TO HEX\n         HEX   32,8                    THIRD WORD\n         HEX   42,12                   FOURTH AND LAST WORD TO HEX\n         MVI   52(R4),C'*'             FRAME THE EBCDIC DISPLAY\n         MVI   69(R4),C'*'             FRAME THE OTHER SIDE\n         MVC   53(16,R4),0(R6)         COPY THE EBCDIC DATA\n         TR    53(16,R4),VALCHAR       DELETE INVALID CHARS\n         LA    R2,16(,R2)              NEXT LINE ADDR\n         LA    R6,16(,R6)              NEXT DATA AREA\n         LA    R4,80(,R4)              NEXT OUTPUT LINE\n         BCT   R5,DUMPLOOP             GO DO NEXT LINE\n         B     BLANKSC                 Try to blank out data not   1.1D\n         SPACE 2                                                   1.1D\nDUMPLN   DS    0H                      Fetch and dump each line    1.1D\n         LA    R4,OUT1                 FIRST OUTPUT LINE ADDR      1.1D\n         LA    R5,16                   NO. OF LINES TO DISPLAY     1.1D\nDUMPLP2  DS    0H                      FORMAT THE DISPLAY          1.1D\n         STCM  R2,15,TEMP2             ADDRESS TO SHOW             1.1D\n         UNPK  TEMP1(9),TEMP2(5)       CONVERT BINARY TO HEX       1.1D\n         MVC   0(8,R4),TEMP1                                       1.1D\n         TR    0(8,R4),HEXTAB                                      1.1D\n         LA    R0,16                   length of a line            1.1D\n         LA    R1,DUMPDATA             where to put data           1.1D\n         BAL   R14,GETSTOR             get it                      1.1D\n         B     DLKILL                  +0 no data found            1.1D\n         NOP   0                       +4 partial data found       1.1D\n         LA    R6,DUMPDATA             +8 all data found           1.1D\n         HEX   12,0                    CONVERT FIRST WORD TO HEX   1.1D\n         HEX   22,4                    SECOND WORD TO HEX          1.1D\n         HEX   32,8                    THIRD WORD                  1.1D\n         HEX   42,12                   FOURTH AND LAST WORD TO HEX 1.1D\n         MVI   52(R4),C'*'             FRAME THE EBCDIC DISPLAY    1.1D\n         MVI   69(R4),C'*'             FRAME THE OTHER SIDE        1.1D\n         MVC   53(16,R4),0(R6)         COPY THE EBCDIC DATA        1.1D\n         TR    53(16,R4),VALCHAR       DELETE INVALID CHARS        1.1D\nDLKILL   DS    0H                                                  1.1D\n         LA    R2,16(,R2)              NEXT LINE ADDR              1.1D\n*        LA    R6,16(,R6)              NEXT DATA AREA              1.1D\n         LA    R4,80(,R4)              NEXT OUTPUT LINE            1.1D\n         BCT   R5,DUMPLP2              GO DO NEXT LINE             1.1D\nBLANKSC  DS    0H                                                  1.1D\n         SPACE 2\n*----------------------------------------------------------------------\n*\n* NOW BLANK OUT THE SCREEN WHERE THE PAGE DIDN'T EXIST\n*\n*----------------------------------------------------------------------\n         SPACE 2\n         LA    R4,OUT1                 POINT TO FIRST OUTPUT LINE\n         SH    R2,=H'256'              FIRST ADDRESS DISPLAYED\n         LA    R5,16                   NUMBER OF LINES DISPLAYED\nBLLOOP   LA    R15,15(,R2)             LAST ADDRESS ON CURRENT LINE\n         CLC   LOGOOD,HIGOOD           ARE WE IN A WRAP CONDITION\n         BH    BLLP0                   YES SO SKIP NOLINE CHECK\n         C     R2,HIGOOD               IF START>=HIGH\n         BNL   NOLINE                     THEN BLANK ENTIRE LINE\nBLLP0    C     R2,LOGOOD               IF START<LOW & END>=LOW\n         BNL   BLLP1                      THEN HI GOOD AND LOW NEEDS\n*                                                  BLANK\n         C     R15,LOGOOD\n         BNL   HIMIX\nBLLP1    C     R2,HIGOOD               IF START<HIGH & END>HIGH\n         BNL   BLLP2                      THEN LOW GOOD AND BLANK\n*                                                HIGH\n         C     R15,HIGOOD\n         BH    LOWOK\nBLLP2    DS    0H                      LINE OK OTHERWISE\n         B     BLOOPEND\n* BOTH LOW AND HIGH MISSING -- BLANK ENTIRE LINE\nNOLINE   MVI   12(R4),C' '             START OF DATA\n         MVC   13(57,R4),12(R4)        CLEAR THE LINE\n         B     BLOOPEND                GO CHECK ANOTHER LINE\n* BR HERE IF LOW END GOOD, HIGH MAY BE  MISSING\nLOWOK    S     R15,HIGOOD              # OF BYTES TO BLANK\n* THE FOLLOWING CODE TAKES CARE OF LOW STORAGE WRAP\n         CH    R15,=H'15'              MORE THAN 15 BYTES TO CLEAR\n         BH    BLOOPEND                IF YES, IT WRAPPED, NO CLEAR\n         LR    R1,R15                  COPY # TO BLANK\n         SRL   R1,2                    FIND # OF WORDS\n         SLL   R1,1                    TWO BLANKS PER WORD\n         AR    R1,R15                  ADD NUMBER OF HEX CHARS\n         AR    R1,R15                  WHICH IS TWICE THE # OF BYTES\n         LA    R6,50(,R4)              POINT JUST AFTER HEX DATA\n         SR    R6,R1                   FIRST BYTE TO CLEAR\n         BCTR  R1,0                    REDUCE BY 1 FOR EXEXUTE\n         EX    R1,CLEARMVC             CLEAR HEX SIDE\n         LA    R6,69(,R4)              POINT TO TRAILING *\n         SR    R6,R15\n         EX    R15,CLEARMVC            CLEAR EBCDIC AND *\n         MVI   0(R6),C'*'              NOTE END OF EBCDIC DATA\n         B     BLOOPEND                GO CHECK NEXT LINE\n* COME HERE WHEN HI END GOOD AND LOW END MISSING\nHIMIX    L     R15,LOGOOD              LOWEST GOOD ADDR\n         SR    R15,R2                  NUMBER OF BYTES TO CLEAR\n         CH    R15,=H'16'              Total line                  1.1D\n         BNL   NOLINE                  Kill complete line          1.1D\n         LR    R1,R15                  COPY # TO CLEAR\n         SRL   R1,2                    # OF WORDS TO CLEAR\n         SLL   R1,1                    NUMBER OF IMBEDDED BLANKS\n         AR    R1,R15                  ADD # OF HEX CHARS\n         AR    R1,R15\n         BCTR  R1,0                    REDUCE BY 1 FOR MVC\n         LA    R6,12(,R4)              START OF HEX DATA\n         EX    R1,CLEARMVC             AND CLEAR THE HEX DATA\n         LA    R6,52(,R4)              POINT TO FIRST * ON LINE\n         EX    R15,CLEARMVC            CLEAR * AND EBCDIC DATA\n         LA    R6,52(R15,R4)           POINT TO FIRST CLEARED BYTE 1.1D\n         MVI   0(R6),C'*'              AND DROP IN A *\nBLOOPEND LA    R4,80(,R4)              POINT TO NEXT LINE\n         LA    R2,16(,R2)              ADDRESS ON NEXT LINE\n         BCT   R5,BLLOOP               AND SCAN ALL LINES\n         SPACE 2\n*----------------------------------------------------------------------\n*\n*  PUT IN ARROWS TO POINT TO DESIRED DATA\n*\n*----------------------------------------------------------------------\n         SPACE 2\n         LA    R4,OUT1                 ADDR OF FIRST LINE\n         TM    MODEFLAG,MIDDUMP        DOES IT BELONG IN THE MIDDLE\n         BZ    ARRTOP                  BR IF NOT\n         LA    R4,OUT9                 POINT TO MIDDLE LINE\nARRTOP   SR    R1,R1                   ASSUME NO QUADWORD ALIGNMENT\n         TM    MODEFLAG,ALIGN          WAS ASSUMPTION CORRECT\n         BZ    ARRALIGN                BR IF YES, ELSE GET OFFSET\n         LA    R1,15                   MASK FOR LOW 4 BITS\n         NR    R1,R2                   GET BYTE OFFSET FOR ARROW\n* FIRST DO THE EBCDIC SIDE\nARRALIGN LA    R15,51(R4)              BYTE BEFORE FIRST *\n         EX    R1,MOVEMVC              MOVE THE DATA BACK\n         AR    R15,R1                  ADDR OF LAST BYTE MOVED\n         MVI   1(R15),C'>'             PUT IN THE ARROW\n* NOW MOVE THE HEX SIDE\n         SR    R0,R0                   CLEAR HIGH ORDER BITS\n         SLDL  R0,30                   WHICH WORD IS TO BE MOVED\n         SRL   R1,30                   NUMBER OF BYTES TO BE MOVED\n         LR    R15,R0                  COPY OFFSET OF WORD TO MOVE\n         MH    R15,=H'10'              EACH WORD TAKES UP 10 BYTES\n         LA    R15,10(R4,R15)          POINT IN FRONT OF WORD TO MOVE\n         SLL   R1,R1                   NUMBER OF HEX DIGITS TO MOVE\n         EX    R1,MOVEMVC              MOVE THE DATA BACK\n         AR    R15,R1                  POINT TO PALCE FOR ARROW\n         MVI   1(R15),C'>'             AND PUT IT THERE\n* FALL  THRU TO SHOW THE SCREEN\n         EJECT\n*\n* DISPLAY THE PAGE AND CHECK FOR END REQUEST\n*\nDISPLAY  UNPK  TEMP1(5),CURASID(3)     FORMAT CURRENT ASID\n         MVC   ASIDLN1(4),TEMP1        AND PUT ON SCREEN\n         TR    ASIDLN1(4),HEXTAB\n         MVC   SAVEASID,ASIDLN1        SAVE FORMATED VERSION\n         MVC   KEYS,KEY1               SETUP PFK\n         MVC   KEYS+80,KEY2                 INFO LINE\n*\nTPUTSCRN DS    0H\n         LA    R0,QDSLNG\n         TPUT  QDSCREEN,(0),FULLSCR MF=(E,QTPUT)\n         XC    INPLINE,INPLINE\n         XC    PFREPLY,PFREPLY\n         TGET  PFREPLY,69,ASIS MF=(E,QTGET)\n         LR    R3,R1                   SAVE INPUT LENGTH\n         CH    R15,=H'12'     IS INPUT LONGER THAN BUFFER?\n         BNE   NOCLEAR        NO. CONTINUE.\n         TCLEARQ INPUT        CLEAR THE QUEUE\nNOCLEAR  DS    0H\n         MVC   MSGLINE,BLANKS          INDICATE NO ERROR           1.1A\n         LA    R1,PFREPLY+3            POINT AT FIRST BYTE\n         SH    R3,=H'3'                ADJUST LENGTH\n*\n**       HANDLE ASID IF NECESSARY\n*\n         CLC   0(3,R1),=X'1140F9'      IS THIS ASID MODIFICATION\n         BNE   NOASID                  NO SO SKIP\n         LA    R1,3(R1)                POINT AT FIRST BYTE\n         SH    R3,=H'3'                ADJUST LENGTH\n         LR    R2,R1                   SAVE START ADDRESS\nASIDLOOP CLI   0(R1),X'11'             LOOK FOR START FIELD\n         BE    HAVEASID\n         LA    R1,1(R1)                BUMP POINTER\n         BCT   R3,ASIDLOOP\nHAVEASID LR    R15,R1                  MOVE POINTER\n         SR    R15,R2                  GET LENGTH\n         BZ    NOASID\n         MVC   ASIDLN1,=CL4' '\n         LA    R4,ASIDLN1+4            GET TO ADDRESS +4\n         SR    R4,R15                      - REAL LENGTH\n         BCTR  R15,0                   GET MACHINE LENGTH\n         EX    R15,MOVERPLY\nNOASID   DS    0H\n         LTR   R3,R3                   ANY DATA LEFT\n         BZ    ENDINP\n         CLC   0(3,R1),=X'11C15C'      CHECK FOR START OF FIELD\n         BNE   ENDINP                  IF NOT HERE THEN SKIP\n         LA    R1,3(R1)                POINT AT FIRST BYTE\n         SH    R3,=H'3'                ADJUST LENGTH\n         LR    R2,R1                   SAVE START ADDRESS\nRPLYLOOP CLI   0(R1),X'11'             LOOK FOR START FIELD\n         BE    HAVERPLY\n         LA    R1,1(R1)                BUMP POINTER\n         BCT   R3,RPLYLOOP\nHAVERPLY LR    R15,R1                  MOVE POINTER\n         SR    R15,R2                  GET LENGTH\n         BZ    NOASID\n         LA    R4,INPLINE              GET TO ADDRESS\n         BCTR  R15,0                   GET MACHINE LENGTH\n         EX    R15,MOVERPLY\nENDINP   OC    INPLINE,=CL63' '        MAKE UPPERCASE\n         SPACE 2\n         IC    R4,PFCODE\n         XR    R5,R5\n         CLI   PFCODE,X'7D'      ENTER?\n         BE    ENTER             /YES - TREAT AS ENTER\n         CLI   PFCODE,X'F0'      TEST-REQ/SYS-REQ?\n         BE    ENTER             /YES - TREAT AS ENTER\n         CLI   PFCODE,X'01'      OTHER KIND OF SYS-REQ?\n         BE    ENTER             /YES - TREAT AS ENTER\n         CLI   PFCODE,X'6C'      PA1?\n         BE    ENDIT             /YES - TERMINATE\n         CLI   PFCODE,X'6E'      PA2?\n         BE    TPUTSCRN          /YES - GO RESHOW SCREEN\n         CLI   PFCODE,X'6B'      PA3?  (TCAM GENERATED)\n         BE    TPUTSCRN          /YES - GO RESHOW SCREEN\n         N     R4,=X'0000000F'   EXTRACT PF-KEY NUMBER\n         CH    R4,=H'12'\n         BH    ENTER            \"ENTER\" KEY\n         BCTR  R4,0\n         SLL   R4,2              TIMES SIZE OF AN ENTRY\n         B     PFKEYTAB(R4)\nPFKEYTAB B     HELP                    PF1\n         B     DISPLAY                 PF2\n         B     ENDIT                   PF3    QUIT\n         B     DISPLAY                 PF4\n         B     REPEAT                  PF5    REPEAT COMMAND\n         B     DISPLAY                 PF6\n         B     UP                      PF7    SCROLL UP\n         B     DOWN                    PF8    SCROLL DOWN\n         B     BACK                    PF9    SCROLL BACKWARDS\n         B     FWD                     PF10   SCROLL FORWARDS\n         B     DISPLAY                 PF11\n         B     DISPLAY                 PF12\nMOVERPLY MVC   0(0,R4),0(R2)           **EXECUTED**\n         EJECT\nENTER    CLC   =C'END',INPLINE         SEE IF END TYPED\n         BNE   ISCAN                   IF NOT, GO LOOK AT INPUT\n* CLEAN UP AND GO AWAY\nENDIT    LM    R0,R1,CSALEN            GET SP, LEN, AND ADDR\n         LTR   R1,R1                   WAS BUFFER GOTTEN\n         BZ    ENDIT1                  NOPE\n         FREEMAIN R,LV=(0),A=(1)       FREE BUFFER\nENDIT1   TM    FLAGS,NOAUTH            ARE WE AUTHORIZED\n         BO    ENDIT2                  NOPE\n         MODESET MODE=PROB             RESET MODE\nENDIT2   DS    0H\n         STTMPMD OFF                                               1.1C\n         STFSMODE OFF                  RESET FULLSCREEN\n         L     R13,SAVE+4              GET ORIGINAL SAVE AREA\n         FREEMAIN R,LV=WORKLEN,SP=1,A=(R10)\n         RETURN (14,12),RC=0\n         EJECT\n*----------------------------------------------------------------------\n*\n* CBHIT  -- CONTROL BLOCK FORMATTING ROUTINE\n* AT ENTRY:\n*              R4 HAS ADDRESS TO DISPLAY (OFFSET 0 - MAIN SEGMENT)\n*              R5 HAS CONTROL BLOCK HEADER ADDRESS\n*\n*----------------------------------------------------------------------\n         SPACE 2\nCBHIT    LH    R2,CURRENT              GET HISTORY TABLE POINTER\n         A     R2,HISTORY              GET ENTRY ADDRESS\n         USING HIST,R2                 SETUP FORMAT OF ENTRY\n         ICM   R6,15,HISTCBSP          LAST SEGMENT DISPLAYED\n         BNZ   CBHIT2                  BR IF A CONTINUING DISPLAY\n         USING CBH,R5                  ADDRESS HEADER BLOCK\n         L     R6,CBHCBSP              ELSE GET FIRST SEG ADDRESS\n         ST    R6,HISTCBSP             AND SAVE FOR LATER\n         ST    R5,HISTCBHP             AND SAVE FOR LATER\n         OI    HISTCBHP,X'80'          NOTE CB FORMAT ROUTINE IN USE\n*   GET BLOCK NAME AND HANDLE ANY SEGMENT INDIRECTION\nCBHIT2   DS    0H\n         USING CBS,R6\n         L     R5,HISTCBHP             POINT TO CB HEADER\n         MVC   MSGLINE+36(8),CBHNAME   MOVE IN CB NAME\n         STCM  R4,15,TEMP2             SAVE ADDRESS OF BLOCK\n         UNPK  TEMP1(9),TEMP2(5)          AND CONVERT\n         TR    TEMP1(8),HEXTAB               TO HEX\n         MVC   MSGLINE+26(8),TEMP1     MOVE IN ADDRESS OF BLOCK\n         DROP  R2,R5\n         CLC   =H'0',CBSILEN           IS THIS SEGMENT INDIRECT\n         BE    CBHIT3                  IF NOT THEN SKIP CODE\n         LH    R0,CBSILEN              GET LENGTH TO FETCH (ALWAYS 4\n         LA    R1,DUMPDATA             WHERE TO PUT IT\n         LH    R2,CBSIOFF              GET INDIRECT OFFSET\n         AR    R2,R4                   GET TRUE MAIN BLOCK ADDRESS\n         BAL   R14,GETSTOR             GET THE INDIRECT WORD\n         B     NOCB                    BR IF NO DATA FETCHED\n         B     NOCB                    BR IF PARTIAL DATA FETCHED\n         L     R4,DUMPDATA             RESET THE ADDR TO DUMD\n         LH    R2,CURRENT\n         A     R2,HISTORY              GET ADDR OF ENTRY\n         ST    R4,HISTSADR-HIST(R2)    SAVE SEGMENT ADDRESS\nCBHIT3   DS    0H\n         LH    R0,CBSDLEN              LENGTH TO FETCH\n         LA    R1,DUMPDATA             TARGET ADDRESS\n         LH    R2,CBSDOFF              OFFSET TO FETCH\n         AR    R2,R4                   ADD START OF CB ADDRESS\n         BAL   R14,GETSTOR             GO FETCH THE DATA\n         B     NOCB                    BR IF NO DATA FETCHED\n         B     NOCB                    BR IF PARTIAL DATA FETCHED\n         LA    R5,OUT1-80              START OF SCREEN\n         LA    R2,DUMPDATA             POINT TO DATA BUFFER\n         SH    R2,CBSDOFF              BACKUP TO VIRTUAL CB ORIGIN\n         LA    R6,CBSLEN(R6)           POINT AT FIRST CB FIELD\n         USING CBF,R6\nCBLOOP   DS    0H\n         LH    R1,CBFLINE              GET LINE NUMBER\n         MH    R1,=H'80'               TIMES LINE LENGTH\n         AH    R1,CBFCOLM              PLUS THE COLUMN NUMBER\n         AR    R1,R5                   PLUS START OF LINE\n         MVC   0(8,R1),CBFNAME         SET NAME FIELD\n         LA    R1,8(R1)                SKIP NAME\n         LH    R14,CBFOFFS             GET OFFSET INTO CB\n         AR    R14,R2                  GET ADDRESS IN FETCHED DATA\n         SR    R15,R15                 CLEAR REGISTER\n         IC    R15,CBFDLEN             GET LENGTH OF DATA ITEM\n         LA    R0,80-8                 get max column less label   1.1D\n         SH    R0,CBFCOLM              and starting col number     1.1D\n*   FORMAT CHARACTER AS DISPLAY AND REST AS HEX\n         CLI   CBFTYPE,C'C'            WHAT IS TYPE\n         BNE   CBFLP1                  IF NOT CHAR THEN DO HEX     1.1D\n         CR    R15,R0                  see if data too big         1.1D\n         BNH   *+6                     use actual length           1.1D\n         LR    R15,R0                  truncate data               1.1D\n         BCTR  R15,0                   GET MACHINE LENGTH\n         EX    R15,CBMVC               MOVE IN DATA\n         EX    R15,CBTR                OUTPUT ONLY VALID CHARS      1.1\n         B     CBFEND\nCBFLP1   SRL   R0,1                    convert columns to bytes    1.1D\n         CR    R15,R0                  see if data too big         1.1D\n         BNH   *+6                     use actual length           1.1D\n         LR    R15,R0                  truncate data               1.1D\nCBFLOOP  MVC   TEMP2(1),0(R14)         MOVE IN DATA BYTE\n         UNPK  TEMP1(3),TEMP2(2)\n         TR    TEMP1(2),HEXTAB\n         MVC   0(2,R1),TEMP1           MOVE IN CONVERTED BYTE\n         LA    R1,2(R1)                BUMP OUTPUT ADDRESS\n         LA    R14,1(R14)              BUMP INPUT ADDRESS\n         BCT   R15,CBFLOOP             KEEP LOOPINT\nCBFEND   LA    R6,CBFLEN(R6)           BUMP TO NEW FIELD\n         CLC   0(4,R6),=F'0'           END OF SEGMENT\n         BNE   CBLOOP                  IF NOT THEN KEEP GOING\n         B     DISPLAY                 ALL DONE SO DISPLAY IT\n         DROP  R6\n         SPACE 1\nCBMVC    MVC   0(0,R1),0(R14)          **EXECUTED** MOVE IN DATA\nCBTR     TR    0(0,R1),VALCHAR         **EXECUTED** MAKE VALID      1.1\n         SPACE 2\n*----------------------------------------------------------------------\n*\n*  GET ADDRESS OF CURRENT CONTROL BLOCK SEGMENT\n*     ON EXIT R2 = ADDR OF THIS CONTROL BLOCK SEGMENT\n*\n*----------------------------------------------------------------------\nGETCURAD DS    0H\n         LH    R2,CURRENT              GET HIST TABLE OFFSET\n         A     R2,HISTORY              GET ENTRY\n         USING HIST,R2\n         CLC   =F'0',HISTSADR          IS SEGMENT A SECONDARY SEGMENT\n         BE    GCA1                    NOPE, SO SKIP CODE\n         L     R2,HISTSADR             GET ADDRESS OF BLOCK\n         BR    R14\nGCA1     L     R2,HISTADDR             GET MAIN BLOCK ADDR\n         BR    R14\n         DROP  R2\n         EJECT\n***********************************************************************\n*\n* COMMAND ROUTINES\n*\n         SPACE 2\n*----------------------------------------------------------------------\n*\n* HELP -- DISPLAY HELP INFORMATION\n*\n*----------------------------------------------------------------------\n         SPACE 2\nHELP     DS    0H\n         LA    R1,16*80\n         LR    R3,R1\n         L     R2,=A(HELPMSG)      POINT AT FROM\n         LA    R0,OUT1\n         MVCL  R0,R2\n         B     DISPLAY\n         SPACE 2\n*----------------------------------------------------------------------\n*\n* REFRESH -- REFETCH THE CORE AND REDISPLAY IT\n*\n*----------------------------------------------------------------------\n         SPACE 2\nREFRESH  OI    FLAGS,RFRSH             SET REFRESH FLAG\n         B     FORMAT                  REFORMAT SCREEN\n         SPACE 2\n*----------------------------------------------------------------------\n*\n* OVERLAY  --  MANIPULATE CONTROL BLOCK FORMATTING\n*\n*----------------------------------------------------------------------\n         SPACE 2\nOVERLAY  CLC   =C'NULL',INPLINE+1      SEE IF NO FORMATTING WANTED\n         BE    OVERNULL                BR IF YES\n         L     R5,=V(CBMACS)           GET CB MAP INDEX\n         LTR   R5,R5                   ANY MAPS\n         BZ    OVERNULL                IF NOT TREAT AS NULL OVERLAY\n         USING CBH,R5                  SETUP ADDRESSABILITY\nOVERLOOP CLC   =F'0',CBHNEXT           END OF CONTROL BLOCKS\n         BE    FORMAT                  IF YES, IGNORE COMMAND\n         CLC   INPLINE+1(8),CBHNAME    SEE IF CB MATCH\n         BE    OVERHIT                 BR IF YES\n         L     R5,CBHNEXT              ELSE POINT TO NEXT ENTRY\n         B     OVERLOOP                AND KEEP LOOKING\nOVERHIT  L     R6,CBHCBSP              START SEG ADDR FOR CB FOUND\n         LH    R2,CURRENT              CURRENT HIST TABLE ENTRY OFFSET\n         A     R2,HISTORY              GET ENTRY ADDRESS\n         USING HIST,R2                 SETUP ENTRY FORMAT\n         ST    R5,HISTCBHP             POINT AT HEADER\n         ST    R6,HISTCBSP             POINT AT SEGMENT(FIRST)\n         OI    HISTCBHP,X'80'          MARK AS CB\n         XC    HISTSADR,HISTSADR       CLEAR SEC SEG ADDR\n         B     FORMAT                  GO SHOW IT\n         SPACE 1\nOVERNULL LH    R2,CURRENT              CURRENT HIST TABLE ENTRY OFFSET\n         A     R2,HISTORY              POINT AT CURRENT ENTRY\n         MVC   HISTCBHP,=X'7FFFFFFF'   SUPPRESS CB OVERLAY\n         B     FORMAT                  GO SHOW STORAGE\n         DROP  R5,R2\n         SPACE 2\n*----------------------------------------------------------------------\n*\n* DOWN -- SCROLL DOWN 256 BYTES OR NEXT CTRL BLK SEGMENT\n*\n*----------------------------------------------------------------------\n         SPACE 2\nDOWN     LH    R2,CURRENT              CURRENT HIST TABLE POINTER\n         A     R2,HISTORY              POINT TO HIST TABLE ENTRY\n         USING HIST,R2                 SETUP ENTRY FORMAT\n         TM    HISTCBHP,X'80'          SEE IF THIS IS A CB DISPLAY\n         BO    DOWNCB                  BR IF YES\n         L     R1,HISTADDR             ELSE GET ADDR TO SHOW\n         AH    R1,=H'256'              AND MOVE DOWN ONE SCREEN\n         ST    R1,HISTADDR             AND REPLACE IN HIST TABLE\n         B     FORMAT                  GO DISPLAY IT\nDOWNCB   L     R1,HISTCBSP             GET CB SEGMENT ADDR\n         L     R1,CBSNEXT-CBS(R1)      GET NEXT SEG ADDR\n         ST    R1,HISTCBSP             AND PUT IN HIST TABLE\n         XC    HISTSADR,HISTSADR       CLEAR SEC SEG ADDR\n         B     FORMAT                  GO SHOW IT\n         DROP  R2\n         SPACE 2\n*----------------------------------------------------------------------\n*\n* UP   -- SCROLL UP   256 BYTES OR PREV CTRL BLK SEGMENT\n*\n*----------------------------------------------------------------------\n         SPACE 2\nUP       LH    R2,CURRENT              CURRENT HIST TABLE POINTER\n         A     R2,HISTORY              POINT TO HIST TABLE ENTRY\n         USING HIST,R2                 SETUP FORMAT OF ENTRY\n         TM    HISTCBHP,X'80'          SEE IF THIS IS A CB DISPLAY\n         BO    UPCB                    BR IF YES\n         L     R1,HISTADDR             ELSE GET ADDR TO SHOW\n         SH    R1,=H'256'              AND MOVE UP ONE SCREEN\n         ST    R1,HISTADDR             AND REPLACE IN HIST TABLE\n         B     FORMAT                  GO DISPLAY IT\nUPCB     L     R1,HISTCBSP             GET CB SEGMENT ADDR\n         L     R1,CBSPREV-CBS(R1)      GET PREV SEG ADDR\n         ST    R1,HISTCBSP             AND PUT IN HIST TABLE\n         XC    HISTSADR,HISTSADR       CLEAR SEC SEG ADDR\n         B     FORMAT                  GO SHOW IT\n         DROP  R2\n         SPACE 2\n*----------------------------------------------------------------------\n*\n* REPEAT -- REPEAT LAST INPUT LINE\n*\n*----------------------------------------------------------------------\n         SPACE 2\nREPEAT   MVC   INPLINE(52),INPSAVE     COPY SAVED INPUT\n         B     ISCAN2                  AND PROCESS IT\n         SPACE 2\n*----------------------------------------------------------------------\n*\n* LINK -- LINK TO LABELED CONTROL BLOCK FIELD\n*\n*----------------------------------------------------------------------\n         SPACE 2\nLINK     LH    R2,CURRENT              CURRENT HIST TABLE POINTER\n         A     R2,HISTORY              POINT TO HIST TABLE ENTRY\n         USING HIST,R2                 SETUP FORMAT OF ENTRY\n         TM    HISTCBHP,X'80'          SEE IF CB FORMATTING IN USE\n         BO    LINK2                   BR IF YES\nLINKERR  MVC   MSGLINE,LINKMSG         NOTE ERROR IN LINK\n         B     FORMAT                  AND RESHOW SCREEN\nLINK2    L     R3,HISTCBSP             GET CURRENT CB SEG ADDRESS\n         LA    R5,0(R3)                CLEAR FLAGS AND SETUP FOR COMP\n         USING CBS,R4\nLINK2A   LR    R4,R3                   SAVE THE START OF SEG ADDR\n         LA    R3,CBSLEN(R3)           POINT PAST SEG HEADER\n         USING CBF,R3\nLINK3    CLC   CBFNAME(4),=F'0'        END OF SEGMENT\n         BE    LINK4\n         CLC   CBFNAME,INPLINE+1       DOES NAME MATCH\n         BE    LINKFND                 IF SO THEN FOUND\n         LA    R3,CBFLEN(R3)           POINT PAST THIS ONE\n         B     LINK3                   KEEP LOOKING\nLINK4    DS    0H\n         L     R3,CBSNEXT              POINT TO NEXT SEGMENT\n         CR    R3,R5                   ARE WE BACK AT START\n         BNE   LINK2A                  IF NOT KEEP GOING\n         B     LINKERR                 IF NOT THEN ISSUE ERROR\n         DROP  R4,R2\n* A MATCH HAS  BEEN FOUND. FETCH THE  ADDRESS TO LINK TO\nLINKFND  DS    0H\n         SR    R0,R0                   CLEAR FOR IC\n         IC    R0,CBFDLEN              LENGTH OF ITEM  MINUS 1\n         LA    R1,DUMPDATA             ADDR TO PLACE DATA IN\n         BAL   R14,GETCURAD            GET ADDR OF CURRENT SEGMENT\n         AH    R2,CBFOFFS              OFFSET OF ITEM TO FETCH\n         BAL   R14,GETSTOR             FETCH THE  ADDRESS\n         B     LINKERR                 BR IF DATA CANT BE FETCHED\n         B     LINKERR                 BR IF DATA CANT BE FETCHED\n         BAL   R15,FWDSUB              UPDATE HIST TABLE TO NEXT\n         L     R0,DUMPDATA             LOAD ADDRESS THAT WAS FETCHED\n         SR    R15,R15                 NOW ADJUST THE\n         IC    R15,CBFDLEN               FETCHED DATA\n         LA    R1,4                        SO THAT\n         SR    R1,R15                        IT IS RIGHT\n         BNP   LF1                             JUSTIFIED IN\n         SLL   R1,3                              REGISTER IF\n         SRL   R0,0(R1)                            LESS THAN 4\nLF1      DS    0H                                    BYTES\n         LH    R2,CURRENT              NEW HIST TABLE POINTER\n         A     R2,HISTORY              GET ENTRY ADDRESS\n         USING HIST,R2\n         ST    R0,HISTADDR             SAVE NEW ADDRESS\n         XC    HISTCBHP,HISTCBHP          AND\n         XC    HISTCBSP,HISTCBSP            CLEAR\n         XC    HISTSADR,HISTSADR               REST\n         B     FORMAT                  GO FORMAT THE NEW CB\n         DROP  R3,R2\n         SPACE 2\n*----------------------------------------------------------------------\n*\n*  SET INDIRECT FLAG\n*\n*----------------------------------------------------------------------\n         SPACE 2\nINDIR31  OI    FLAGS,IND31             SET FLAG\nINDIR    OI    FLAGS,INDFLAG           SET FLAG\n         LA    R3,1(R3)                UPDATE SCAN POINTER\n         CLI   INPLINE+1,C' '          USE CURRENT ADDRESS\n         BNE   NUMSCAN                 IF NO, GO SCAN INPUT ADDRESS\n         BAL   R14,GETCURAD\n         LR    R4,R2                   MOVE TO RIGHT REGISTER\n         B     ENDNUM\n         SPACE 2\n***********************************************************************\n*\n*  ESTABLISH SCREEN MODE\n*\n***********************************************************************\n         SPACE 2\nMODE     CLC   =C'1 ',INPLINE+1        MODE ONE TEST\n         BE    MODE1                   BR IF YES\n         CLC   =C'0 ',INPLINE+1        CHECK FOR MODE ZERO         1.1D\n         BNE   INVAL                   IF NOT EITHER, INVALID\n         NI    MODEFLAG,255-MIDDUMP    MODE 0 MEANS BACKUP 0\n         B     FORMAT\nMODE1    OI    MODEFLAG,MIDDUMP        MODE 1 MEANS BACK UP 7 LINES\n         B     FORMAT\nINVAL    MVC   MSGLINE,MODEMSG\n         B     FORMAT\n         SPACE 2\n***********************************************************************\n*\n*  MANIPULATE HISTORY TABLE\n*\n***********************************************************************\n         SPACE 2\nFWD      BAL   R15,FWDSUB              FORWARD 1 IN HIST TABLE\n         B     FORMAT\n         SPACE\nFWDSUB   LH    R1,CURRENT              CURRENT ENTRY INDEX\n         LA    R1,HISTLEN(R1)\n         CH    R1,=AL2(50*HISTLEN)     SEE IF WRAP NEEDED\n         BL    FWDEND                  BR IF NOT\n         SR    R1,R1                   WRAP TO BEGINNING\nFWDEND   STH   R1,CURRENT              STORE NEW OFFSET\n         BR    R15                     RETURN TO CALLER\n         SPACE 1\nBACK     LH    R1,CURRENT\n         SH    R1,=AL2(HISTLEN)        BACK UP ONE ENTRU\n         BNM   BACKEND                 BR IF NO BACKWARD WRAP\n         LA    R1,49*HISTLEN           ELSE GO TO END OF TABLE\nBACKEND  STH   R1,CURRENT              SAVE RESULT\n         B     FORMAT\n         SPACE 2\n***********************************************************************\n*\n*   ADD ENTRY TO SYMBOL TABLE\n*\n***********************************************************************\n         SPACE 2\nDEFINE   LA    R15,50                  NUMBER OF TABLE ENTRIES\n         LA    R2,NAMES                START OF TABLE\nDEFLOOP1 CLI   0(R2),X'0'              SEE IF UNUSED ENTRY\n         BE    NSPACE                  BR IF SPACE FOUND\n         LA    R2,12(R2)               NEXT ENTRY ADDR\n         BCT   R15,DEFLOOP1            TRY ALL ENTRIES\n         MVC   MSGLINE,SYMFULL         TABLE IS FULL\n         B     FORMAT\nNSPACE   LA    R15,9                   MAX LENGTH +1\n         LA    R0,INPLINE+1            ADDR OF FIRST BYTE\n         LR    R1,R0                   COPY SYMBOL ADDR\nDEFLOOP2 CLI   0(R1),C' '              SEE IF END OF SYM\n         BE    DEFEND                  BR IF YES\n         LA    R1,1(R1)                POINT TO NEXT BYTE\n         BCT   R15,DEFLOOP2            CONTINUE FOR 9 BYTES\nDEFBAD   MVC   MSGLINE,DEFMSG          SYMBOL TOO LONG OR TOO SHORT\n         B     FORMAT2                 DISPLAY WITH CURSOR AT ERROR\nDEFEND   SR    R1,R0                   SYMBOL LENGTH\n         BZ    DEFBAD                  NULL SYMBOL ILLEGAL\n         BCTR  R1,R0                   FOR EXECUTE\n         MVC   0(8,R2),=CL8' '         CLEAR TABLE ENTRY\n         EX    R1,DEFMOVE              MOVE SYMBOL\n         LH    R1,CURRENT              GET CURRENT ADDRESS\n         A     R1,HISTORY\n         L     R1,HISTADDR-HIST(R1)\n         ST    R1,8(R2)                STORE WITH SYMBOL\n         B     FORMAT\nDEFMOVE  MVC   0(0,R2),INPLINE+1       EXECUTED TO MOVE SYMBOL\n         SPACE 2\n***********************************************************************\n*\n*  SCAN THE ADDRESS EXPRESSION\n* REGISTER USAGE\n* R2 LAST NUMBER SCANNED\n* R3 SCAN POINTER\n* R4 CURRENT OUTPUT VALUE\n* R5 LAST OPERATOR SCANNED\n*\n***********************************************************************\n         SPACE 2\nNUMSCAN  DS    0H\n         BAL   R14,GETCURAD            CURRENT ENTRY IS DEFAULT\n         LR    R4,R2                   CURRENT ENTRY IS DEFAULT\n         LA    R5,0                    ASSUME DEFAULT TO BE TAKEN\n         CLI   0(R3),C'+'              SEE 2F PREFIX PLUS\n         BNE   NOTPLUS                 BR IF NOT\n         LA    R5,2                    INDICATE PLUS OPERATOR\n         B     NUMOP                   GO TO ADV POINTER\nNOTPLUS  CLI   0(R3),C'-'              IS IT PREFIX MINUS\n         BNE   NUMLOOP                 BR IF NOT, USE DEFAULT AS LOAD\n         LA    R5,4                    INDICATE MINUS OPERATOR\nNUMOP    LA    R3,1(R3)                POINT TO NEXT INPUT BYTE\nNUMLOOP  CLI   0(R3),C','              SEE IF NAME INDICATED\n         BE    NAMESCAN                BR IF YES\n         TRT   0(9,R3),NUMTAB          SEARCH FOR DELIMITER\n         LR    R6,R3                   SAVE START OF NUMBER\n         BC    8,BADSTUFF              BR IF INPUT TOO LONG\n         LR    R3,R1                   UPDATE SCAN POINTER\n         SR    R1,R6                   GET LENGTH OF INPUT\n         BZ    BADSTUFF                BR IF ZERO INPUT\n         MVC   TEMP1(8),=CL8' '        CLEAR TEMP AREA\n         LA    R15,TEMP1+8             RIGHT JUSTIFY INPUT\n         SR    R15,R1                  POINT TO RIGHT SPOT IN TEMP AREA\n         BCTR  R1,0                    PREPARE FOR EX\n         EX    R1,HEXMOVE              MOVE INPUT RIGHT JUSTIFIED\n         TR    TEMP1(8),HEXTAB         TRANSLATE TO HEX\n         PACK  TEMP2(5),TEMP1(9)       CONVERT HEX TO BINARY\n         ICM   R2,15,TEMP2             NEW DISPLAY ADDRESS\nNUMDELIM EX    0,OPER(R5)              EXECUTE PREVIOUS OPERATOR\n         CLI   0(R3),C' '              IS DELIM A BLANK\n         BE    ENDNUM                  IF YES, END SCAN\n         LA    R5,2                    PLUS OPERATOR CODE\n         CLI   0(R3),C'+'              IS OPER L PLUS\n         BE    NUMOP                   BR IF YES TO CONTINUE SAAN\n         LA    R5,4                    MINUS CODE\n         CLI   0(R3),C'-'              IS OPER MINUS\n         BE    NUMOP                   BR IF YES\n         MVC   MSGLINE,INVALOP         ELSE BAD DELIMITER\n         B     FORMAT2                 DISPLAY WITH CURSOR AT ERROR\nENDNUM   TM    FLAGS,INDFLAG           IS THIS AN INDIRECT REQ\n         BZ    NOTIND                  BR IF NOT\n         TM    FLAGS,IND31             DO WE WANT 31 BIT INDIRECT{\n         BO    *+8                     SKIP CLEAR IF YES\n         ICM   R4,8,=X'00'             CLEAR TOP BYTE\n         LR    R2,R4                   SET ADDR TO GET FROM\n         LA    R0,4                    NUMBER OF BYTES TO GET\n         LA    R1,DUMPDATA             WHERE TO PUT IT\n         BAL   R14,GETSTOR             DO MEMORY FETCH\n         B     BADIND                  NONE GOT\n         B     BADIND                  SOME BUT NOT ALL GOT\n         L     R4,DUMPDATA             DO THE INDIRECT\n         N     R4,=X'7FFFFFFF'         TURN OFF TOP BIT ALWAYS\nNOTIND   BAL   R15,FWDSUB              UPDATE HISTORY POINTR\n         LH    R2,CURRENT              NEW HIST TABLE POINTER\n         A     R2,HISTORY              GET ENTRY ADDRESS\n         USING HIST,R2\n         ST    R4,HISTADDR             SAVE NEW ADDRESS\n         XC    HISTCBHP,HISTCBHP          AND\n         XC    HISTCBSP,HISTCBSP            CLEAR\n         XC    HISTSADR,HISTSADR               REST\n         B     FORMAT\n         DROP  R2\nBADIND   MVC   MSGLINE,BADIMSG         MOVE IN MESSAGE\n         B     FORMAT                  GO AND REDISPLAY\n         SPACE 2\n* SCAN INPUT FOR A NAME IN THE SYMBOL TABOL\nNAMESCAN LA    R3,1(R3)                SKIP OVER COMMA\n         LR    R1,R3                   COPY INPUT POINTER\n         LA    R15,9                   MAX LENGTH +1\nNAMELOOP CLI   0(R1),C'A'              SEE IF VALID CHAR\n         BL    NAMEEND                 BR IF NOT, DELIM FOUND\n         LA    R1,1(R1)                POINT TO NEXT BYTE\n         BCT   R15,NAMELOOP            ALLOW EIGHT BYTES PLUS DELIM\nNAMEBAD  MVC   MSGLINE,NAMEMSG         NULL NAME OR NAME TOO LONG\n         B     FORMAT2                 DISPLAY WITH CURSOR AT ERROR\nNAMEEND  SR    R1,R3                   FIND LENGTH\n         BZ    BADSTUFF                BR IF TOO SHORT\n         MVC   TEMP1(8),=CL8' '        CLEA\u00a2  WORK AREA\n         BCTR  R1,0                    SET UP FOR EX\n         EX    R1,NAMEMOVE             MOVE TO WORK AREA, BLANK PAD\n         LA    R3,1(R3,R1)             UPDATE POINTER\n         LA    R15,50                  ENTRIES IN SYM TABLE\n         LA    R1,NAMES                START OF SYM TABLE\nNAMELP2  CLC   TEMP1(8),0(R1)          SEE IF NAME IN TABLE\n         BE    NAMEFIND                BR IF YES\n         LA    R1,12(R1)               POINT TO NEXT ENTRY\n         BCT   R15,NAMELP2             BR IF ANY ENTRIES LEFT\n         B     NAMEBAD                 BR IF NONE LEFT, UNDEFUNED SYM\nNAMEFIND L     R2,8(R1)                GET >YMBOL VALUE\n         B     NUMDELIM                USE IN EXPRESSION\n*  THESE INSTRUCTIONS ARE THE OBJECT OF AN EXECUTE\nOPER     LR    R4,R2                   USE HIST TABLE AS DEFAULT INPUT\n         AR    R4,R2                   PLUS OPERATOR\n         SR    R4,R2                   MINUS OPERATOR\nHEXMOVE  MVC   0(0,R15),0(R6)          RIGHT JUSTIFY INPUT DATA\nNAMEMOVE MVC   TEMP1(1),0(R3)          PAD NAME WITH BLANKS BY MOVING\n         SPACE\nBADSTUFF MVC   MSGLINE,ERRMSG          NOTE BAD INPUT\n         B     FORMAT2                 DISPLAY WITH CURSOR AT ERROR\n         SPACE 2\n***********************************************************************\n*\n*  PROGRAM CHECK EXIT\n*\n***********************************************************************\n         SPACE 2\n         DROP  R9,R11\n         USING *,R15               SET TEMP BASE\nEREXIT   DS    0H                  ESTAE EXIT\n         C     R0,=F'12'\n         BER   R14                 SKIP IF NOT SDWA\n         STM   R14,R12,12(R13)     SAVE REGISTERS\n         LR    R4,R1               SAVE ADDR OF SDWA\n         USING SDWA,R4             SAVE ADDR\n         L     R10,SDWAPARM        GET PARM LIST\n         LR    R12,R15             SAVE BASE REGISTER\n         DROP  R15\n         USING EREXIT,R12\nER200    L     R11,BASE2           GET FIRST BASE\n         L     R9,BASE1            GET SECOND BASE\n         USING LOOK,R11,R9         RESET BASE\n         TM    FLAGS,GETINPG           IS A GETSTOR IN PROGRESS\n         BZ    SPIEOTR                 NOPE OTHER ERROR\n         L     R8,CSAWORK          SETUP REG 8\n         USING WORK,R8                 IF FROM GETSTOR THEN R8 POINTS\n*                                      TO WORK\n         TM    FLAG1,FG1MOVE           ARE WE IN MOVE INSTR\n         BZ    SPIEOTR                 NOPE\n         MVC   MERRCD,SDWAICD1         SAVE INT CODE                1.1\n         CLI   SDWAICD1,X'04'          PROTECTION??\n         BNE   ER250                   IF NOT THEN TRY OTHERS\n*        IF PROTECTION THEN DATA TO POINT OF ERROR\n*        HAS BEEN MOVED SO JUST ADJUST LENGTH\n         L     R2,LENGTH\n         S     R2,SDWAGR01             GET LENGTH NOT MOVED\n         ST    R2,LENGTH               SAVE MOVED LENGTH\n         B     ER300                   ALL DONE\n*        IF ADDRESSING EXCEPTION THEN\n*        REGISTERS NOT ALWAYS UPDATED (PER POPS)\n*        BUT THE TRANSLATION ADDR IS CLOSE.\n*        ALSO NO DATA MAY HAVE BEEN MOVED.\n*        (WE ARE DEALING HERE WITH WHAT MAY BE \"MODEL DEPENDENT\"\n*        FEATURES)\nER250    DS    0H\n         L     R2,SDWATRAN             GET BAD ADDRESS\n         S     R2,ADDR                 LESS START ADDR\n         LTR   R2,R2                   ANY GOOD LENGTH\n         BM    ER300                   NOPE                         1.1\n         C     R2,LENGTH               MAKE SURE IT IS REASONABLE\n         BH    ER300                   SKIP IF NOT\n         ST    R2,LENGTH               SAVE AS GOTTEN LENGTH\n         LTR   R2,R2                   ANY LENGTH AT ALL            1.1\n         BZ    ER300                   NO - SO SKIP MOVE            1.1\n         LR    R3,R2                   SETUP LENGTH\n         LR    R7,R2\n         L     R2,ADDR                 GET FROM ADDR\n         LA    R6,BUF                  GET TO ADDRESS\n         MVCL  R6,R2\nER300    MVC   ESRUB,=X'0074'     FLAG TO RESET REGS\n         LR    R1,R4               RESET SDWA POINTER\n         SETRP REGS=(14,12),DUMP=NO,RC=4,RETADDR=GOTBACK,              X\n               RETREGS=YES,RUB=ESRUB,FRESDWA=YES,RECORD=NO\n         DROP  R8,R4\n*PIEOTR  MVC   MSGLINE,PCMSG           TELL USER OF PC\n*        B     ER300                   SET RETURN FROM GETSTOR\nSPIEOTR  DS    0H\n         LR    R1,R4                   RESTORE SDWA REG\n         SETRP REGS=(14,12),DUMP=NO,RC=0,RECORD=NO\n         DROP  R12\n         SPACE 2\n*----------------------------------------------------------------------\n*\n* ERASE  --  CLEAR THE SCREEN BUFFER\n*\n*----------------------------------------------------------------------\n         SPACE 2\nERASE    SAVE  (2,5)                   NEED SOME WORK REGS\n         LA    R2,OUT1                 START OF AREA TO CLEAR\n         LA    R3,80*16                LENGTH TO CLEAR\n         LA    R5,C' '                 FILL CHAR\n         SLL   R5,24                   MAKE PAD BYTE AND CLEAR SOURCE\n         MVCL  R2,R4                   PROPAGATE BLANKS\n         RETURN (2,5)                  RESTORE REGS AND RETURN\n         EJECT\n* EXECUTED INSTRUCTIONS AND CONSTANTS\nCLEARMVC MVC   0(0,R6),BLANKS          CLEAR SOME SPACE\nMOVEMVC  MVC   0(0,R15),1(R15)         MOVE DATA BACKWARDS\n***********************************************************************\n*\n*\n*        FETCH SOME STORAGE\n*\n*              R0  =  LENGTH TO FETCH <=4096 (MAXFETCH)\n*              R1  => WHERE TO PUT IT\n*              R2  => WHERE TO GET IT FROM\n*\n*\n***********************************************************************\nGETSTOR  SAVE  (14,8)                  SAVE REGS\n         L     R8,CSAWORK              POINT TO CSA AREA            1.1\n         USING WORK,R8                 SETUP ADDRESSABILITY         1.1\n         MVI   MERRCD,0                INDICATE NO ERROR ON FETCH   1.1\n         LA    R2,0(0,R2)              clear top bit               1.1D\n         CL    R0,=A(MAXFETCH)         Max fetchable size          1.1D\n         BL    *+8                     Requested ok                1.1D\n         L     R0,=A(MAXFETCH)         Force smaller               1.1D\n*\n*        CHECK IF DATA IS IN BUFFER\n*\n         CLC   CSAASID,CURASID         WANT SAME ASID\n         BNE   GETMORE                 NOPE\n         C     R2,CSASTAR              CHECK FOR BEGINNING\n         BL    GETMORE\n         LR    R15,R0                  GET LENGTH\n         AR    R15,R2                  GET END ADDRESS\n         C     R15,CSAEND              CHECK FOR END\n         BH    GETMORE                 NOPE NOT IN BUFFER\n         TM    FLAGS,RFRSH             IS IT REFRESH REQUEST\n         BO    GETMORE                 REGET THE CORE\nMOVEBUF  L     R15,CSASTAR             GET VIRT ADDR OF BUFFER\n         SR    R2,R15                  GET DISPLACEMENT IN BUFFER\n         A     R2,CSABUF               POINT TO BUFFER\n         LR    R3,R0                   MOVE LENGTH\n         LR    R0,R1                   SET \"TO\" ADDR\n         LR    R1,R3                   SET LENGTH\n         MVCL  R0,R2\n         LM    R14,R8,12(R13)          RESTORE REGS                 1.1\n         B     8(R14)                  RETURN ALL GOTTEN\nGETMORE  DS    0H\n         MVC   LENGTH,=F'2048'         Initial fetch is half page  1.1C\n         C     R0,LENGTH               Is req for more than default1.1D\n         BNH   *+8                     No  so skip                 1.1D\n         ST    R0,LENGTH               Set first request for actual1.1D\n         ST    R2,ADDR                 SAVE ADDR TO GET CORE FROM  1.1C\n         ST    R2,CSASTAR              SET CSA VIRT BUFFER ADDR    1.1C\n         NI    FLAGS,255-REFETCH       inidicate first fetch       1.1C\nGETM2    DS    0H                                                  1.1C\n         MVI   MERRCD,0                INDICATE NO ERROR ON FETCH  1.1C\n         NI    FLAGS,255-RFRSH         TURN OFF FLAG\n         MVC   CSAASID,CURASID         SET ASID OF CSABUFFER CONTENTS\n         MVI   FLAG1,0                 CLEAR FLAGS\n         MVI   FLAG2,0\n         CLC   CURASID,MYASID          ARE WE IN THIS ADDR SPACE\n         BNE   DOSRB                   IF NOT USE SRB\n*\n*        INVOKE SRB CODE AS SUBROUTINE\n*\n         OI    FLAG1,FG1SUBR           FLAG AS SUBROUTINE\n         LA    R1,DMYPRMS              SETUP DUMMY FRR PARMS\n         ST    R1,FRRPRMS\n         TM    FLAGS,NOAUTH            ARE WE AUTHORIZIED          1.1E\n         BO    DOSUB1                  NO SO SKIP                  1.1E\n         MODESET KEY=ZERO              GET TO KEY ZERO             1.1E\nDOSUB1   DS    0H                                                  1.1E\n         XC    DMYPRMS,DMYPRMS\n         LR    R1,R8                   SETUP PARM REGISTER\n         LA    R15,D#SRBCD             SETUP ENTRY REGISTER\n         LA    R14,GOTBKSUB            SETUP RETURN REGISTER       1.1E\n         OI    FLAGS,GETINPG           FLAG GETSTOR IN PROGRESS\n         BR    R15                     GO TO IT\nGOTBKSUB TM    FLAGS,NOAUTH            ARE WE AUTHORIZIED          1.1E\n         BO    GOTBACK                 NO SO SKIP                  1.1E\n         MODESET KEY=NZERO             GET TO TCB KEY              1.1E\n         B     GOTBACK                 CONTINUE                    1.1E\n*\n*        IF AUTHORIZED FOR SRB MODE ...\n*\nDOSRB    TM    FLAGS,NOAUTH            ARE WE AUTHORIZED\n         BO    FAIL2                   NOPE\n*\n*        VALIDATE ASID ...\n*\n         L     R2,CVTPTR               POINT TO CVT\n         LH    R1,CSAASID              GET ASID\n         L     R2,CVTASVT-CVTMAP(R2)   POINT TO ASVT\n         USING ASVT,R2                 SETUP ADDRESSABILITY\n         C     R1,ASVTMAXU             IS IT TOO BIG\n         BH    FAIL3                   SET INVALID ASID\n         SLL   R1,2                    ASID*4\n         LA    R1,ASVTENTY-4(R1)       POINT AT DESIRED ENTRY\n         MVC   TOASCB,0(R1)            SAVE ASCB ADDR\n         TM    TOASCB,ASVTAVAL         IS THIS ASCB EXISTANT\n         BO    FAIL3                   NOPE\n         LA    R3,SRBAREA     POINT AT THE SRB\n         DROP  R2\n         L     R2,TOASCB               GET ASCB ADDR\n         USING ASCB,R2                 SETUP ADDRESSABILITY\n         TM    ASCBRCTF,ASCBOUT        IS ASCB SWPPED OUT\n         BO    FAIL3                   YES SO DONOT TRY TO TOUCH IT\n         DROP  R2\n*\n*        INITIALIZE THE SRB AND INVOKE AS SRB\n*\n         USING SRBSECT,R3\n         XC    SRBAREA,SRBAREA  CLEAR THE SRB\n         MVC   SRBID,=C'SRB '  SET EBCDIC ID\n         MVC   SRBASCB,TOASCB SET ASCB ADDR TO RUN IN\n         AIF   (&XA).XA2                                            1.1\n         LA    R1,SRBCCD      POINT AT SRB CODE IN CSA        SP    1.1\n         AGO   .NXA2                                                1.1\n.XA2     ANOP                                                       1.1\n         BASR  R0,0           GET ADDRESSING MODE              XA   1.1\n         N     R0,=X'80000000'  LEAV ONLY ADDRESSING MODE      XA   1.1\n         LA    R1,SRBCCD      POINT AT SRB CODE IN CSA         XA   1.1\n         OR    R1,R0          PUT ADDRESSING MODE IN           XA   1.1\n.NXA2    ANOP                                                       1.1\n         ST    R1,SRBEP       SAVE ENTRY POINT\n         ST    R8,SRBPARM     SAVE PARM ADDR AS WORK AREA\n         LA    R1,D#RMTR-D#SRBCD(R1)  GET RESOURCE MGR TERMINATION\n         OR    R1,R0\n         ST    R1,SRBRMTR     AND SAVE IT\n         XC    ECB,ECB                 CLEAR THE ECBS FOR THE WAITLIST\n         XC    ECB2,ECB2\n         LA    R0,ECB\n         LA    R1,ECB2\n         STM   R0,R1,ECBLIST\n         MVI   ECBLIST+4,X'80'\n*\n*        NOW ISSUE TIMER INCASE SRB NEVER POSTS US\n*\n         STIMER REAL,D#STX,BINTVL==A(300)  WAIT 3 SECONDS\n         MODESET KEY=ZERO\n         SCHEDULE SRB=(R3),SCOPE=GLOBAL ISSUE SRB\n         MODESET KEY=NZERO\n         L     R2,=C'ABCD'             SET KEY IN REG\n         LA    R3,ECB2                 AND ADDR TO POST IN STIMER\n         WAIT  ECBLIST=ECBLIST\n         TTIMER CANCEL\n*\n*        WE ARE BACK FROM EITHER TIMER OR SRB OR SUB\n*\nGOTBACK  L     R8,CSAWORK              POINT AT CSA AREA\n         NI    FLAGS,255-GETINPG       TURN OFF GET IN PROGRESS\n         TM    FLAG1,FG1SUBR           IS THIS A SUB CALL\n         BO    GOTBK2                  IF SO IGNORE SOME ERRORS\n         TM    FLAG1,FG1SRDN           DID SRB TERMINATE GOOD\n         BZ    FAIL                    NOPE SO ERROR MSG\n         TM    FLAG2,FG2PSTR+FG2PURG+FG2ERRR AN ERRORS\n         BNZ   FAIL                    IF SO ERROR MESSAGE\nGOTBK2   DS    0H\n*\n*        NOW MOVE INFO OUT OF CSA BUFFER\n*\n         L     R2,12+12(R13)           GET ORIG R1 INTO R2 (DEST ADDR)\n         L     R3,12+8(R13)            GET DESIRED LENGTH\n         L     R4,CSABUF               POINT TO BUFFER\n         L     R5,LENGTH               GET ACTUAL LENGTH MOVED\n         LTR   R5,R5                   Did any memory get back     1.1C\n         BNZ   GOTBK4                  If so then use it           1.1C\n         C     R3,=F'2048'             Was original req >= default 1.1C\n         BNL   GOTBK4                  If so then cant get it      1.1C\n         TM    FLAGS,REFETCH           Q. Is this first or sec ent 1.1C\n         BO    GOTBK4                  A. Second, return no data   1.1C\n         OI    FLAGS,REFETCH           First entry so indicate     1.1C\n         ST    R3,LENGTH               Retry with orig req         1.1C\n         B     GETM2                                               1.1C\nGOTBK4   DS    0H                                                  1.1C\n         NI    FLAGS,255-REFETCH       reset flag before return    1.1C\n*\n*        NOTE THAT ORIG(R2) IS EFFECTIVELY AT R4\n*        FIRST BYTE DESIRED IS FIRST BYTE IN BUFFER\n*\n         MVCL  R2,R4                   MOVE IN CORE\n         L     R2,CSASTAR              GET START LOC\n         A     R2,LENGTH               PLUS LENGTH MOVED\n         ST    R2,CSAEND               SET CORRECT END ADDR\n         MVC   LOGOOD,CSASTAR          SET LOW RANGE DISPLAYABLE\n         MVC   HIGOOD,CSAEND           AND HIGH RANGE\n         MVC   12+12(4,R13),LENGTH     SET GOTTEN LENGTH\n*                                                                   1.1\n*        SET MESSAGE LINE TO INDICATE HOW SUCCESSFUL                1.1\n*        THE MEMORY FETCH WAS                                       1.1\n*                                                                   1.1\n         CLI   MERRCD,4                IS THIS PROTECTION ERROR    1.1A\n         BNE   GOTBK3A                 NO SO CHECK OTHERS          1.1A\n         MVC   MSGLINE,PROT            MOVE IN PROTECTION MSG      1.1A\n         B     GOTBK3                  ERROR SET                   1.1A\nGOTBK3A  DS    0H                                                  1.1A\n         CLI   MERRCD,X'11'            IS THIS A PAGE FAULT        1.1A\n         BE    GOTBK3B                 YES                         1.1A\n         CLI   MERRCD,X'10'            IS THIS A SEGMENT FAULT     1.1A\n         BNE   GOTBK3                  NO                          1.1A\nGOTBK3B  MVC   MSGLINE,NONEX           SET PAGE FAULT ERROR        1.1A\nGOTBK3   DS    0H                                                   1.1\n         LM    R14,R8,12(R13)          RESTORE REGS\n         LTR   R1,R1                   ANY LENGTH GOTTEN\n         BZR   R14                     IF NOT THEN EXIT +0\n         CR    R0,R1                   ALL DESIRED GOTTEN\n         BH    4(R14)                  IF NOT ALL THEN +4\n         B     8(R14)                  ALL DESIRED GOTTEN THEN +8\n*\n*        IF ANY ERRORS GIVE ERROR MSG AND RETURN +0\n*\nFAIL     DS    0H\n         DC    H'0'\n         MVC   MSGLINE,SRBMSG          MOVE IN MESSAGE\n         MVC   CURRENT+2(2),FLAG1\n         B     FAILALL                 GO TO COMMON ROUTINE\n*\n*        IF NOT AUTHORIZED TO DISPLAY OTHER ASIDS GIVE MSG AND RESET\n*\nFAIL2    DS    0H\n         MVC   MSGLINE,AUTHMSG         MOVE IN MESSAGE\n         B     FAILALL                 GO TO COMMON ROUTINE\n*\n*        IF ASID IS NOT VALID OR SWAPPED OUT GIVE MSG AND RESET\n*\nFAIL3    DS    0H\n         MVC   MSGLINE,BDASMSG         MOVE IN MESSAGE\nFAILALL  DS    0H                      COMMON FAILURE ROUTINE\n         MVC   CSASTAR,=F'0'           CLEAR THE START\n         MVC   CSAEND,=F'0'              AND END ADDR\n         MVC   CSAASID,=H'0'               AND THE ASID\n         MVC   CURASID,MYASID          RESET ASID AVAIL\n         RETURN (14,8)\n*\n*        STIMER EXIT ROUTINE\n*        ITS PURPOSE IS TO POST THE ECB AT ECB2 AND WAKE UP THE\n*        LOOK PROCESSOR IF THE SRB FAILS.  TO DO THIS WE MUST\n*        FIND THE ADDRESS OF THE ECB WHICH IS SAVED IN R3 OF\n*        THE RB ABOVE THE WAIT.  IN THAT RB, R2 IS SET TO 'ABCD'.\n*\n         USING *,R12\nD#STX    SAVE  (14,12)                 SAVE REGISTERS\n         LR    R12,R15                 SET BASE REG\n         L     R3,CVTPTR               POINT AT CVT\n         L     R3,0(R3)                POINT AT TCB WORDS\n         L     R3,0(R3)                POINT AT MY TCB\n         L     R3,0(R3)                POINT AT MY RB\n         USING RBBASIC,R3\nD#STX1   DS    0H                      NOW LOOK FOR KEY IN REG2\n         CLC   RBGRS2,=C'ABCD'         IS THE KEY HERE\n         BE    D#STX2                  YES\n         TM    XSTAB2,RBTCBNXT         TEST TCB FLAG\n         BO    D#STX3                  IF NOT FOUND PROPER RB\n         L     R3,RBLINK               POINT AT PREVIOUS RB\n         B     D#STX1\nD#STX2   L     R2,RBGRS3               GET ADDR OF ECB TO POST\n         POST  (R2)                    WAKE UP LOOK\n         RETURN (14,12)\n*\n*        IF WE CANT FIND THE RB THEN DUMP\n*\nD#STX3   DC    H'0'\n         DROP  R12,R3\n         LTORG\n         TITLE 'LOOK --  STORAGE ALTER/DISPLAY - SRB MODE CODE'\n         DROP  R9\nD#SRBCD  DS    0D\n*\n*        THIS CODE PERFORMS THE FOLLOWING FUNCTIONS\n*              1 ESTABLISHES AN FRR FOR ERROR RECOVERY\n*              2 VERIFIES THAT THE ADDRESSES THAT ARE NEEDED DO\n*                EXIST.\n*              3 PERFORM THE MODIFICATION IF ALLOW AND NECESSARY\n*              4 SAVE THE PROPER CORE FOR DUMPING.\n*              5 CROSS-MEMORY POST THE MAIN COMMAND PROCESSOR\n*\n         USING WORK,R8\n         USING D#SRBCD,R7\n         LR    R8,R1          SET THE MAIN PARM DSECT\n         LR    R7,R15         SET THE BASE REGISTER\n         ST    R14,ASRBRTN    SAVE RETURN ADDR\n         TM    FLAG1,FG1SUBR  IS THIS A SUBROUTINE CALL\n         BO    D#SRB1         YES SO SKIP FRR\n         LA    R5,D#FRRCD     POINT AT FRR CODE\n         SETFRR  A,FRRAD=(R5),WRKREGS=(2,3),PARMAD=(R4)\n         ST    R4,FRRPRMS     SAVE ADDR OF FRRPRMS\n*\n*        NOW INIT THE FRR PARM AREA AND VALIDATE THE INPUT ADDR\n*\nD#SRB1   L     R2,FRRPRMS     ACCESS THE 6 WORK PARM AREA\n         STM   R7,R8,0(R2)    SAVE BASE AND WORK REGS\n*\n*        MOVE MEMORY\n*\n         L     R2,ADDR                 SET START ADDR\n         LA    R0,BUF                  POINT AT BUFFER\n         L     R1,LENGTH               GET DESIRED LENGTH\n         LR    R3,R1                   SET LENGTH\n         OI    FLAG1,FG1MOVE           INDICATE IN MOVE\n         MVCL  R0,R2                   MOVE IN CORE\n         NI    FLAG1,255-FG1MOVE       NOTE NOT IN MOVE\n*\n*        NOW WE TERMINATE PROCESSING BY DOING A CROSS\n*        MEMORY POST IF NOT IN SUBROUTINE MODE\n*\nFRRRTY   TM    FLAG1,FG1SUBR  IS THIS SUBROUTINE MODE\n         BO    D#EXIT         IF SO THEN EXIT\n         SETFRR  D,WRKREGS=(2,3)\nFRRPOST  L     R10,=A(X'40000000') SET CODE FOR POST\n         LR    R9,R8          SAVE WORK POINTER IN SAFE REG\n         LA    R11,ECB        ADDR OF ECB TO POST\n         ICM   R11,8,=X'80'   FLAG AS XMPOST\n         LA    R12,D#POSTR    SET POST ERROR RETURN\n         L     R13,MYASCB     ASCB TO POST\n         L     R15,CVTPTR     POINT AT CVT\n         L     R15,CVT0PT01-CVTMAP(R15)    GET POST ENTRY POINTR\n         BALR  R14,R15        GO DO POST\n         DROP  R7             KILL MAIN ADDRESS\n         USING *,R14          SET TEMP BASE\nD#PRTN   LR    R8,R9          RESET BASE OF WORK\n         SL    R14,=A(D#PRTN-D#SRBCD)  NOW HAVE CORRECTED BASE\n         LR    R7,R14         SET TO PROPER REG\n         DROP  R14\n         USING D#SRBCD,R7     RESET MAIN BASE\n         OI    FLAG1,FG1SRDN  FLAG SRB AS COMPLETED\nD#EXIT   L     R14,ASRBRTN    RESTORE RETURN ADDR\n         BR    R14            EXIT\n         SPACE 5\n*\n*        POST ERROR ROUTINE  .. FLAG ERROR AND LET TIMER\n*        WAKE UP TASK\n*\nD#POSTR  LR    R8,R9          RESET WORK BASE\n         OI    FLAG2,FG2PSTR  FLAG POST ERROR\n         BR    R14            RETURN TO D#PRTN\n         TITLE 'LOOK --  STORAGE ALTER/DISPLAY - FRR FOR SRB'\nD#FRRCD  DS    0D\n         L     R2,0(R1)       POINT AT PARM AREA\n         LM    R7,R8,0(R2)    SET BASE REGS\n         TM    FLAG1,FG1MOVE  ARE WE IN VALIDATION\n         BZ    D#FRR1         NOPE\n*\n*        MOVE INCOMPLETE\n*\n         NI    FLAG1,255-FG1MOVE       TURN OFF FLAG\n         MVC   MERRCD,SDWAICD1-SDWA(R1) SAVE INT CODE               1.1\n         CLI   SDWAICD1-SDWA(R1),X'04' PROTECTION??\n         BNE   D#FRR0A                 IF NOT THEN TRY OTHERS\n*        IF PROTECTION THEN DATA TO POINT OF ERROR\n*        HAS BEEN MOVED SO JUST ADJUST LENGTH\n         L     R2,LENGTH\n         S     R2,SDWAGR01-SDWA(R1)    GET LENGTH NOT MOVED\n         ST    R2,LENGTH               SAVE MOVED LENGTH\n         B     D#FRR0                  ALL DONE\n*        IF ADDRESSING EXCEPTION THEN\n*        REGISTERS NOT ALWAYS UPDATED (PER POPS)\n*        BUT THE TRANSLATION ADDR IS CLOSE.\n*        ALSO NO DATA MAY HAVE BEEN MOVED.\n*        (WE ARE DEALING HERE WITH WHAT MAY BE \"MODEL DEPENDENT\"\n*        FEATURES)\nD#FRR0A  DS    0H\n         L     R2,SDWATRAN-SDWA(R1)    GET BAD ADDRESS\n         S     R2,ADDR                 LESS START ADDR\n         LTR   R2,R2                   ANY GOOD LENGTH\n         BM    D#FRR0                  NOPE                         1.1\n         C     R2,LENGTH               MAKE SURE IT IS REASONABLE\n         BH    D#FRR0                  SKIP IF NOT\n         ST    R2,LENGTH               SAVE AS GOTTEN LENGTH\n         LTR   R2,R2                   ANY LENGTH AT ALL            1.1\n         BZ    D#FRR0                  NO - SO SKIP MOVE            1.1\n         LR    R3,R2                   SETUP LENGTH\n         LR    R5,R2                                               1.1C\n         L     R2,ADDR                 GET FROM ADDR\n         LA    R4,BUF                  GET TO ADDRESS              1.1C\n         MVCL  R4,R2                                               1.1C\nD#FRR0   OI    FLAG2,FG2IVLD  SET FLAG FOR MESSAGE\n         SETRP RECORD=NO,RC=4,RETADDR=FRRRTY,REGS,DUMP=NO,             X\n               RETREGS=YES,FRESDWA=YES\n         BR    R14            EXIT\n         SPACE 5\n*\n*        ALL OTHER ERRORS\n*\nD#FRR1   OI    FLAG2,FG2ERRR  SET FLAG FOR MESSAGES\n         SETRP RECORD=YES,RC=4,RETADDR=FRRRTY,REGS,DUMP=YES,           X\n               RETREGS=YES,FRESDWA=YES\n         BR    R14            EXIT\n         TITLE 'LOOK --  STORAGE ALTER/DISPLAY - RESOURCE MGR. CLEANUP'\n*\n*        THIS ROUTINE RECEIVES CONTROL IF THE SRB MUST BE\n*        PURGED.\n*\nD#RMTR   DS    0H\n         USING *,R15\n         LR    R7,R15         SET BASE REGISTER\n         SL    R7,=A(D#RMTR-D#SRBCD)   BY COMPUTATION\n         DROP  R15\n         USING D#SRBCD,R7\n         LR    R8,R2          SET UP POINTER TO WORK\n         ST    R14,ASRBRTN    SAVE RETURN ADDR\n         OI    FLAG2,FG2PURG  SET PURGED\n         B     FRRPOST        GO AND POST TO CLEAN UP\n         LTORG\nENDSRB   DS    0H\nSRBCODE  EQU   *-D#SRBCD               LENGTH OF SRB CODE\n         TITLE 'LOOK --  STORAGE ALTER/DISPLAY - MESSAGES, CONSTANTS'\nKEY1 DC CL80'1= HELP      2=           3= END        4=           5= REX\n               PEAT  6=          '\nKEY2 DC CL80'7= BACKWARD  8= FORWARD   9= HIST BWD  10= HIST FWD 11=   X\n                    12=          '\n* ERROR MESSAGE FOR BAD INPUT\nTITLE    DC    CL79' '\nMODEMSG  DC    CL79'***** INVALID MODE'\nINVALOP  DC    CL79'***** INVALID OPERATOR'\nSYMFULL  DC    CL79'***** SYMBOL TABLE IS FULL'\nNAMEMSG  DC    CL79'***** UNDEFINED SYMBOL'\nDEFMSG   DC    CL79'***** NULL SYMBOL OR SYMBOL TOO LONG'\nPCMSG    DC    CL79'***** PROGRAM CHECK'\nLINKMSG  DC    CL79'***** LINK FAILED'\nSRBMSG   DC    CL79'***** SRB DATA FETCH FAILED'\nAUTHMSG  DC    CL79'***** LOOK NOT CURRENTLY AUTHORIZED. REQUEST DENIEDX\n               .'\nBDASMSG  DC    CL79'***** ASID INVALID OR SWAPPED OUT.'\nBADIMSG  DC    CL79'***** INDIRECT FAILED.'\nASIDFMT  DC    CL13'DISPLAY ASID='\nERRMSG   DC    CL79'INVALID ADDRESS -- TRY AGAIN'\nPROT     DC    CL79'--- PART/ALL OF REQUESTED MEMORY FETCH PROTECTED' 1\nNONEX    DC    CL79'--- PART/ALL OF REQUEST MEMORY NON-EXISTENT'    1.1\nBLANKS   DC    CL79' '\n         EJECT\nHEXTAB   DC    256C' '                 GENERAL HEX CONVERSION TABLE\n         ORG   HEXTAB+C'A'             INPUT CONVERSION\n         DC    X'0A0B0C0D0E0F'\n         ORG   HEXTAB+C'0'             OUTPUT CONVERSION\n         DC    C'0123456789ABCDEF'\n         ORG\n* HEX INPUT TRT TABLE\nNUMTAB   DC    256X'1'\n         ORG   NUMTAB+C'A'\n         DC    6X'0'\n         ORG   NUMTAB+C'0'\n         DC    10X'0'\n         ORG\nVALCHAR  DC    256C'.'                 TRANSLATE TO VALID CHARS\n         ORG   VALCHAR+C' '\n         DC    C' '\n         ORG   VALCHAR+C'\u00a2'\n         DC    C'\u00a2.<(+|&&'\n         ORG   VALCHAR+C'!'\n         DC    C'!$*);\u00ac-/'\n         ORG   VALCHAR+C','\n         DC    C',%_.?'\n         ORG   VALCHAR+C':'\n         DC    C':#@''=\"'\n         ORG   VALCHAR+C'a'\n         DC    C'abcdefghi'\n         ORG   VALCHAR+C'j'\n         DC    C'jklmnopqr'\n         ORG   VALCHAR+C's'\n         DC    C'stuvwxyz'\n         ORG   VALCHAR+C'A'\n         DC    C'ABCDEFGHI'\n         ORG   VALCHAR+C'J'\n         DC    C'JKLMNOPQR'\n         ORG   VALCHAR+C'S'\n         DC    C'STUVWXYZ'\n         ORG   VALCHAR+C'0'\n         DC    C'0123456789'\n         ORG\n         LTORG\n         SPACE 2\n*        SCREEN DEFINITION AREA\nQDINIT   DS    0D             START OS DISPLAY WORK AREA\n         DC    F'0'           ORIG SCREEN DEPTH\n         DC    F'0'           ORIG SCREEN LINESZ\n         DC    H'80'          LENGTH OF DISPLAY LINE\n         DC    PL2'21'        LINES PER SCREEN\n         DS    0D\n         DS    0CL69\n         DC    CL6' '\n         DC    CL63' '\n         DC    CL63' '        CORRECTED DATA FROM SCREEN\n         DS    0C             DISPLAY SCREEN\n         DC    X'27'          CONTROL\n         DC    X'F5'          ERASE/WRITE\n         DC    X'C1115D7F1140403C404000' CLEAR SCREEN\n         DC    CL43'LOOK COMMAND - DISPLAY VIRTUAL MEMORY' TITLE L 1.1D\n         DC    CL13'DISPLAY ASID='\n         DC    X'1DC8'        MARK NEXT FIELD AS INPUT FIELD\n         DC    CL4' '         IN/OUT FOR ASID\n         DC    X'1DF0'        TERMINATE INPUT FIELD\n         DC    X'11'          SET BUFFER ADDRESS\n         DC    X'C150'        (2,1)\n         DC    C'ENTER CMD -'     REPLY PROMPT\n         DC    X'1DC8'        MARK NEXT FIELD AS INPUT FIELD\n         DC    X'13'          SET CURSOR ADDRESS\n         DC    X'11'          SET BUFFER ADDRESS\n         DC    X'C25B'        (2,76)\n         DC    X'1DF0'        TERMINATE INPUT FIELD\n         DC    X'11'          SET BUFFER ADDRESS\n         DC    X'C260'        (3,1)\n         DC    C'LAST CMD  - '\n         DC    CL63' '        PREVIOUS COMMAND\n         DC    X'11'          SET BUFFER ADDRESS\n         DC    X'C3F0'        (4,1)\n         DC    CL79' '\n         DC    C' '\n         DC    16CL80' '      MESSAGE TEXT AREA\n         DC    2CL80' '\n         DC    2CL80' '       PFK DISPLAY AREA\nHELPMSG  DS    0H\n DC CL80'LOOK is a real time core display and formatting program. It alX\n               so has the        '\n DC CL80'capability of displaying memory in any address space (if authoX\n               rized).           '\n DC CL80'                                                              X\n                                 '\n DC CL80'The valid commands are:                                       X\n                                 '\n DC CL80'Iexp  24 bit indirect                 | Jexp  31 bit indirect X\n                                 '\n DC CL80'>     Forward                         | <     Backward        X\n                                 '\n DC CL80'=sym  Define current address as \"sym\" | ,sym  Redisplay core aX\n               t \"sym\"           '\n DC CL80'M0/M1 Flip between top and center     | Lname Indirect thru coX\n               ntrol block field '\n DC CL80'Ocb   Format as \"cb\" control block    | R     Refresh displayeX\n               d storage         '\n DC CL80'      \"cb\" may be NULL to show as hex |                       X\n                                 '\n DC CL80'                                                              X\n                                 '\n DC CL80'where ''exp'' is of the form:                                 X\n                                   '\n DC CL80'    <+/->hhhh<+/-hhhh<+/-hhhh...>>                            X\n                                 '\n DC CL80'and ''hhhh'' is a 1 to 8 digit hex number.                    X\n                                   '\n DC CL80'                                                              X\n                                 '\n DC CL80'                                                              X\n                                 '\n         TITLE 'LOOK --  STORAGE ALTER/DISPLAY - WORK AREAS, DSECTS'\n*----------------------------------------------------------------------\n*\n* HIST -- HISTORY ENTRY FOR ONE OR MORE PREVIOUS ENTRIES\n*\n*----------------------------------------------------------------------\n         SPACE 2\nHIST     DSECT\nHISTADDR DS    A                       ADDR OF STORAGE/MAIN CB ADDRES\nHISTCBHP DS    A                       0 IF NO CB\n*                                      X'7FFFFFFF' IF OVERLAY NULL\n*                                      ADDR OF CBH IF CB DISPLAYED\nHISTCBSP DS    A                       ADDR OF CBS DISPLAYED\nHISTSADR DS    A                       ADDR OF STORAGE FOR THIS SEG\nHISTLEN  EQU   *-HIST                  LENGTH OF ENTRY\n         SPACE 5\n*----------------------------------------------------------------------\n*\n* CBH  -- CONTROL BLOCK HEADER  -  ONE FOR EACH DIFFERENT CONTROL BLK\n*\n*----------------------------------------------------------------------\n         SPACE 2\nCBH      DSECT\nCBHNEXT  DS    A                       ADDR OF NEXT CONTROL BLOCK OR 0\nCBHVOFF  DS    A                       OFFSET OF VALIDATION FIELD\nCBHCBSP  DS    A                       ADDR OF FIRST SEG DESCIPTOR\nCBHNAME  DS    CL8                     NAME OF BLOCK\nCBHVLEN  DS    X                       LENGTH OF VALIDATION FIELD\nCBHVAL   DS    0X                      VALIDATION DATA\n         SPACE 5\n*----------------------------------------------------------------------\n*\n* CBS  -- CONTROL BLOCK SEGMENT\n*\n*----------------------------------------------------------------------\n         SPACE 2\nCBS      DSECT\nCBSPREV  DS    A                       ADDRESS OF PREVIOUS SEGMENT\nCBSNEXT  DS    A                       ADDRESS OF NEXT SEGMENT\nCBSDLEN  DS    AL2                     LENGTH OF DATA TO FETCH\nCBSDOFF  DS    AL2                     OFFSET OF DATA TO FETCH\nCBSILEN  DS    AL2                     LENGTH OF INDIRECT TO FETCH\nCBSIOFF  DS    AL2                     OFFSET OF INDIRECT TO FETCH\nCBSLEN   EQU   *-CBS                   LENGTH OF SEGMENT HEADER\n         SPACE 5\n*----------------------------------------------------------------------\n*\n* CBF  -- CONTROL BLOCK FIELD\n*\n*----------------------------------------------------------------------\n         SPACE 2\nCBF      DSECT\nCBFNAME  DS    CL8                     NAME OF FIELD\nCBFTYPE  DS    CL1                     TYPE OF NAME\nCBFDLEN  DS    XL1                     LENGTH OF DATA TO DISPLAY\nCBFOFFS  DS    H                       OFFSET INTO BLOCK START\nCBFLINE  DS    H                       LINE NUMBER TO PUT ON\nCBFCOLM  DS    H                       COLUMN TO START IN\nCBFLEN   EQU   *-CBF\n         EJECT\n*----------------------------------------------------------------------\n*\n*   MAIN DYNAMIC WORK AREA\n*\n*----------------------------------------------------------------------\nWORKAREA DSECT\nSAVE     DS    18F\nHISTORY  DS    F                       HISTORY TABLE ADDRESS\nNAMES    DS    150F                    SYMBOL TABLE\nCURRENT  DS    H                       HIST TABLE OFFSET\nESTAE    ESTAE 1,PARAM=0,MF=L      ROOM FOR ESTAE PARM LIST\n         DS    0F,H                SPACER\nESRUB    DS    H                   BIT INDICATOR SHOULD BE X'0074'\nBASE1    DS    F                   SECOND BASE REG (R9)\nBASR10   DS    F                   NORMAL R10\nBASE2    DS    F                   FIRST BASE REG (R11)\nBASR13   DS    F                   NORMAL R13\nTEMP1    DS    CL9                     CONVERSION WORK AREA\nTEMP2    DS    CL9                     CONVERSION WORK AREA\nLOGOOD   DC    F'0'\nHIGOOD   DC    XL4'FFFFF123'\nCSALEN   DS    F                       SP AND LEN OF CSA WORK AREA\nCSAWORK  DS    A                       ADDRESS OF CSA WORKAREA\nCSABUF   DS    A                       ADDRESS OF CSA DATA BUFFER FOR\n*                                      SRB\nCSASTAR  DS    A                       USERS ADDR OF BEGINNING OF\n*                                      BUFFER DATA\nCSAEND   DS    A                       USERS ADDR OF END OF BUFFER DATA\nCSAASID  DS    H                       USERS ASID FOR BUFFER DATA\nMYASID   DS    H                       DCMS ASID\nCURASID  DS    H                       DISPLAYED CORE ASID\nSAVEASID DS    CL4                     FORMATED VERSION OF CURASID\nFLAGS    DS    X                       ASSORTED FLAGS\nINDFLAG  EQU   X'80'                   INDIRECT IN PROGRESS\nNOAUTH   EQU   X'40'                   IF ON THEN NOT AUTHORIZED\nGETINPG  EQU   X'20'                   ON IF GETSTOR IN PROGRESS (SUBR)\nRFRSH    EQU   X'10'                   ON TO REFRESH CSA BUFFER\nIND31    EQU   X'08'                   31 BIT INDIRECT IN PROGRESS\nREFETCH  EQU   X'04'                   First get failed and retry  1.1C\nMODEFLAG DS    X                       USER OPTION FLAGS\nMIDDUMP  EQU   X'80'                   ON TO FORCE DISPLAY BACK 8 LINES\nALIGN    EQU   X'40'                   ON TO ALIGN DUMP ON QUADWORD\n         SPACE 2\n*        SCREEN DEFINITION AREA\nQDISPLAY DS    0D             START OS DISPLAY WORK AREA\nQDOSZR0  DC    F'0'           ORIG SCREEN DEPTH\nQDOSZR1  DC    F'0'           ORIG SCREEN LINESZ\nQDLNELEN DC    H'80'          LENGTH OF DISPLAY LINE\nQDLNES   DC    PL2'21'        LINES PER SCREEN\n         DS    0D\nPFREPLY  DS    0CL69\nPFCODE   DC    CL6' '\nPFTXT    DC    CL63' '\nINPLINE  DC    CL63' '        CORRECTED DATA FROM SCREEN\nQDSCREEN DS    0C             DISPLAY SCREEN\n         DC    X'27'          CONTROL\n         DC    X'F5'          ERASE/WRITE\n         DC    X'C1115D7F1140403C404000' CLEAR SCREEN\n         DC    CL43'LOOK COMMAND - DISPLAY VIRTUAL MEMORY' TITLE L 1.1D\nASIDLN   DC    CL13'DISPLAY ASID='\n         DC    X'1DC8'        MARK NEXT FIELD AS INPUT FIELD\nASIDLN1  DC    CL4' '         IN/OUT FOR ASID\n         DC    X'1DF0'        TERMINATE INPUT FIELD\n         DC    X'11'          SET BUFFER ADDRESS\n         DC    X'C150'        (2,1)\n         DC    C'ENTER CMD -'     REPLY PROMPT\n         DC    X'1DC8'        MARK NEXT FIELD AS INPUT FIELD\n         DC    X'13'          SET CURSOR ADDRESS\n         DC    X'11'          SET BUFFER ADDRESS\n         DC    X'C25B'        (2,76)\n         DC    X'1DF0'        TERMINATE INPUT FIELD\n         DC    X'11'          SET BUFFER ADDRESS\n         DC    X'C260'        (3,1)\n         DC    C'LAST CMD  - '\nINPSAVE  DC    CL63' '        PREVIOUS COMMAND\n         DC    X'11'          SET BUFFER ADDRESS\n         DC    X'C3F0'        (4,1)\nMSGLINE  DC    CL79' '\n         DC    C' '\nOUT1     DC    16CL80' '      MESSAGE TEXT AREA\nOUT9     EQU   OUT1+(8*80)\n         DC    2CL80' '\nKEYS     DC    2CL80' '       PFK DISPLAY AREA\nQDISPLN  EQU   *-QDISPLAY     LENGTH OF ENTIRE DISPLAY\nQDSLNG   EQU   *-QDSCREEN     LENGTH OF SCREEN BUFFER\n*\n**       AREA TO HOLD DATA RETURNED BY GETSTOR\n*\nDUMPDATA DS    XL(MAXFETCH)            DATA RETURNED BY GETSTOR\nWORKLEN  EQU   *-WORKAREA\n         EJECT\n         PRINT NOGEN\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n*        END\n         IHAASCB\n         IHAASVT\n         IHAFRRS\n         IHAPSA\n         IHASDWA\n         IHASRB\n         IHARB\n         CVT   DSECT=YES\n         EJECT\n*\n*        CSA AREA WORK AREA\n*\nWORK     DSECT\nWORKSTRT DS    0D\nDOUBLE   DS    2F\nDMYPRMS  DS    6F             DUMMY AREA FOR FRR PARMS FOR SUBR MODE\nFRRPRMS  DS    F              ADDRESS OF 6 WORD FRR PARM\nASRBRTN  DS    F              RETURN ADDR FOR SRB CODE\nMYASCB   DS    F              ASCB ADDR OF MAIN ROUTINE\nMYTCB    DS    F              TCB ADDRESS FOR MAIN ROUTINE\nTOASCB   DS    F              ASCB ADDR OF SRB ROUTINE\nECB      DS    F              ECB FOR MAIN ROUTINE TO WAIT ON\nECB2     DS    F              ECB FOR STIMER TO POST\nECBLIST  DS    2F\nLENGTH   DS    F              LENGTH OF STORAGE TO DUMP\nSRBAREA  DS    ((SRBSIZE+3)/4)F  THE SRB ITSELF\nADDR     DS    F              ADDRESS TO PROCESS AT\nASID     DS    H              ASID OF TOASCB\nFLAG1    DS    X\nFG1DUMP  EQU   X'80'\nFG1REP   EQU   X'40'\nFG1MOVE  EQU   X'20'                   IF ON DOING MVCL FOR DATA\nFG1SRDN  EQU   X'02'          IF ON SRB HAS TERMINATED\nFG1SUBR  EQU   X'01'\nFLAG2    DS    X\nFG2NVER  EQU   X'01'          VERIFICATION FAILED\nFG2IVLD  EQU   X'02'          VALIDATION FAILED\nFG2ERRR  EQU   X'04'          DISASTER OCCURED IN SRB\nFG2PURG  EQU   X'08'          SRB WAS PURGED\nFG2PSTR  EQU   X'10'          IF ON THEN SRB POST HAD ERROR\nMERRCD   DS    X                       INTERRUPT CODE               1.1\nSRBCCD   DS    0D                      ALIGN SRB CODE ON DBL WORD\n         DS    (SRBCODE)X\n         DS    0D                      ALIGN BUFFER\nBUF      DS    (MAXFETCH)X\nWORKLN   EQU   *-WORKSTRT\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LOOK02": {"ttr": 9222, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01W\\x00$\\x00\\x86\\x15/\\x01\\x17\\x05\\x9f\\x13T\\x07U\\x05#\\x03\\xb6\\xd7\\xd9\\xc5\\xe5\\xc9\\xd6\\xe4\\xe2@@'", "ispf": {"version": "01.87", "flags": 0, "createdate": "1986-06-01T00:00:00", "modifydate": "2017-02-28T13:54:24", "lines": 1877, "newlines": 1315, "modlines": 950, "user": "PREVIOUS"}, "text": "         TITLE 'LOOK --  STORAGE ALTER/DISPLAY'\n*\n**       CORRECT INSTRUCTIONS WHICH USE INDEX REGISTER INSTEAD\n**       OF DISPLACEMENT.  WON'T WORK IN AN XMEM ENVIRONMENT.\n**\n**       EXAMPLE   LA  1(,R1)  INSTEAD OF  LA  1(R1)\n**\n**       THIS VERSION OF LOOK SUPPORTS MULTIPLE ADDRESS SPACE\n**       INVESTIGATION.\n**\n**       THIS VERSION DOES NOT YET SUPPORT ALTER CAPABILITY\n**\n**       THIS VERSION IS CONFIGURED TO RUN AND RESIDE ABOVE THE LINE\n**\n**   VERSION 1.1 CHANGES (6/1/88):                                  1.1\n**      - CORRECT ESTAE AND FRR ATTEMPTS TO DETERMINE HOW MUCH      1.1\n**        DATA WAS MOVED.                                           1.1\n**      - GIVE MESSAGES IF DATA WAS NOT MOVED, DISTINGUISH BETWEEN  1.1\n**        NON-EXISTENT (PAGE/SEGMENT FAULT), AND KEY/FETCH          1.1\n**        PROTECTION ERROR.                                         1.1\n**      - TRANSLATE THE OUTPUT CHARACTER STRINGS FOR CONTROL BLOCK  1.1\n**        FORMATTING. THANKS TO MR. S. GOLOB OF NEWSWEEK            1.1\n**      - COMBINE XA AND SP MODULES INTO 1 VIA GLOBAL SYMBOL        1.1\n**\n**   VERSION 1.1A CHANGES (12/5/88):                               1.1A\n**      - CORRECT HANDLING OF ERROR MESSAGES.                      1.1A\n**\n**   VERSION 1.1B CHANGES (10/31/89):                              1.1B\n**      - Change amount of core gotten for ESA.                    1.1B\n**\n**   VERSION 1.1C CHANGES (11/28/90):                              1.1C\n**      - Add changes from Bruce Bordonaro.                        1.1C\n**            - Use STTMPMD.                                       1.1C\n**            - Add significant number of macro formats.           1.1C\n**      - Improve memory fetch when CPU does no data movement.     1.1C\n**      - Fix problem in FRR recovery.                             1.1C\n**\n**   VERSION 1.1D CHANGES (01/22/91):                              1.1D\n**      - Add spelling corrections from Sam Golob.                 1.1D\n**      - Correct HELP screen for Overlay command.                 1.1D\n**      - Correct Mode command.                                    1.1D\n**      - Fix bugs in control block segments.                      1.1D\n**      - Handle 31 bit address correctly when top bit on.         1.1D\n**      - Correct title - Never did and never will actually        1.1D\n**                         zap memory - use INCORZAP or #D         1.1D\n**      - Stop long fields from overlaying next lines.             1.1D\n**      - Correct blanking out of areas not available              1.1D\n**      - Get memory line at a time in dump, if necessary.         1.1D\n**\n**   VERSION 1.1E CHANGES (07/02/91):                              1.1E\n**      - If authorized then do memory fetches in KEY=0.           1.1E\n**\n*\n         EJECT ,                                                   1.1D\n         MACRO\n&N       HEX   &TO,&FROM\n&N       UNPK  TEMP1(9),&FROM.(5,R6)\n         MVC   &TO.(8,R4),TEMP1\n         TR    &TO.(8,R4),HEXTAB\n         MEND\n         EJECT ,                                                   1.1D\nLOOK     CSECT\n******************************                                     1.1D\n**                                                                 1.1D\n**     Fetch constant - maximum amount fetchable in one call       1.1D\n**                                                                 1.1D\nMAXFETCH EQU   4096                                                1.1D\n**                                                                 1.1D\n**                                                                 1.1D\n******************************                                     1.1D\n         SPACE 3                                                   1.1D\n*                                                                   1.1\n*        SET THE FOLLOWING GLOBAL SYMBOL TO 1 FOR XA AND 0 FOR SP   1.1\n*                                                                   1.1\n         GBLB  &XA                                                  1.1\n&XA      SETB  1 =XA MODE              SET TO 1 FOR XA              1.1\n         SPACE 3                                                    1.1\n*  INITIALIZE THE PROGRAM\n         SAVE  (14,12),,'LOOK..&SYSDATE..&SYSTIME'\n         LR    R11,R15                 PERMANENT BASE\n         USING LOOK,R11\n         LA    R9,2048(,R11)           GET A SECOND BASE REG\n         LA    R9,2048(,R9)\n         USING LOOK+4096,R9\n         AIF   (&XA).XA1                                            1.1\n         GETMAIN R,LV=WORKLEN,SP=1                          SP      1.1\n         AGO   .NXA1                                                1.1\n.XA1     ANOP                                                       1.1\nLOOK     AMODE 31                                           XA      1.1\nLOOK     RMODE ANY                                          XA      1.1\n         GETMAIN R,LV=WORKLEN,SP=1,LOC=(BELOW,ANY)          XA      1.1\n.NXA1    ANOP                                                       1.1\n         LR    R10,R1\n         LR    R2,R10                  WORK AREA START\n         L     R3,=A(WORKLEN)          LENGTH TO CLEAR\n         SR    R5,R5                   ZERO PAD BYTE, LENGTH 2\n         MVCL  R2,R4                   CLEAR THE WORK AREA\n         USING WORKAREA,R10\n         LA    R4,QDINIT\n         LA    R3,QDISPLN              GET LENGTH\n         LA    R2,QDISPLAY             POINT AT START\n         LR    R5,R3                   SET FROM LENGTH\n         MVCL  R2,R4                   INIT DISPLAY\n         ST    R13,SAVE+4              CHAIN THE SAVE AREAS\n         LA    R15,SAVE\n         ST    R15,8(,R13)\n         LR    R13,R15                 NEW SAVE AREA\n         STM   R9,R11,BASE1        SAVE FIRST THREE REGS FOR AREA\n         ST    R13,BASR13          AND ORIGINAL R13\n         LA    R1,50*HISTLEN           GET LENGTH OF HIST TBL\n         GETMAIN R,SP=2,LV=(1)\n         ST    R1,HISTORY              SAVE ADDRESS\n         STFSMODE ON,INITIAL=YES       TELL TSO WE ARE FULLSCREEN\n         STTMPMD ON,KEYS=ALL                                       1.1C\n*\n*        SET SUPERVISOR MODE IF AUTHORIZED\n*\n         OI    FLAGS,NOAUTH            SET NOT AUTHORIZED\n         L     R1,=A(WORKLN)           GET LENGTH OF CAS BUFFER\n         ST    R1,CSALEN               SET LENGTH AND SP0\n         TESTAUTH FCTN=1               ARE WE AUTHORIZED\n         LTR   R15,R15\n         BNZ   NOTAUTH                 IF NOT SKIP CODE\n         MVI   CSALEN,241              SET CSA SP\n         NI    FLAGS,255-NOAUTH        MARK AUTHORIZED\n         MODESET MODE=SUP              SET TO SUP MODE\nNOTAUTH  DS    0H\n*\n*        SETUP ESTAE IN CORRECT MODE\n*\n         ESTAE EREXIT,PARAM=(R10),MF=(E,ESTAE)\n*\n*        INITIALIZE ASID POINTERS\n*\n         MVC   ASIDLN,ASIDFMT          SET MESSAGE\n         L     R1,16                   GET CVT\n         L     R2,0(,R1)               GET TCBWORDS\n         L     R1,12(,R2)              GET OLD ASCB ADDR (MINE)\n         USING ASCB,R1\n         MVC   MYASID,ASCBASID         MOVE IN MY ASID\n         MVC   CURASID,MYASID\n         DROP  R1\n         XC    CSAASID,CSAASID         CLEAR THE CSA BUFFER INDIC\n         XC    CSASTAR,CSASTAR\n         XC    CSAEND,CSAEND\n         L     R0,CSALEN               GET LENGTH AND SP FOR CSA BUFFER\n         GETMAIN R,LV=(0)\n         ST    R1,CSAWORK              SAVE ADDR OF CSA BUFFER\n         LR    R8,R1                   SET PROPER POINTER\n         USING WORK,R8\n         MVC   MYTCB,4(R2)             SAVE ADDR OF MY TCB\n         MVC   MYASCB,12(R2)           SAVE ADDR OF MY ASCB\n         LA    R1,BUF                  POINT TO TRUE BUFFER\n         ST    R1,CSABUF\n         LA    R0,SRBCCD               POINT TO CSA SRB CODE AREA\n         LA    R1,SRBCODE              AND LENGTH OF CODE\n         LR    R3,R1\n         LA    R2,D#SRBCD              POINT TO CSECT CODE\n         MVCL  R0,R2                   MOVE SRB CODE TO CSA\n         B     ISCAN1                  GO AND PROCESS\n         DROP  R8\n         EJECT\n***********************************************************************\n*\n*   INPUT SCAN\n*\n***********************************************************************\n         SPACE 2\nISCAN    CLC   SAVEASID,ASIDLN1        DID USER CHANGE ASID\n         BE    ISCAN1                  NOPE\n*\n*        FORMAT AND SAVE USER ASID\n*\n         MVC   TEMP1(4),ASIDLN1        GET USER INFO\n         OC    TEMP1(4),=CL4' '        MAKE UPPER CASE\n         TR    TEMP1(4),HEXTAB         MAKE PACKABLE\n         PACK  TEMP2(3),TEMP1(5)\n         MVC   CURASID,TEMP2           GET NEW ASID\nISCAN1   MVC   INPSAVE,INPLINE         SAVE LAST USER INPUT\nISCAN2   LA    R3,INPLINE              POINT TO START OF INPUT\n         LA    R1,SCANTAB              COMMAND TABLE\n         NI    FLAGS,255-INDFLAG-IND31 TURN OFF INDIRECT FLAG\n         MVC   MSGLINE,TITLE           CLEAR OUT ERROR MSG\nSCANLOOP L     R2,4(,R1)               GET TABLE ENTRY\n         CLC   0(1,R1),ENDTAB          SEE IF END OF TABLE\n         BE    NUMSCAN                 IF YES, ASSUME NUMERIC INPUT\n         CLC   0(1,R1),INPLINE         SEE IF COMMAND FOUND\n         BER   R2                      IF YES, GO TO COMM ROUINE\n         LA    R1,8(,R1)               NEXT ENTRY ADDRESS\n         B     SCANLOOP\nSCANTAB  DS    0F                      COMMAND TABLE\n         DC    CL4' ',A(FORMAT)\n         DC    CL4'I',A(INDIR)\n         DC    CL4'J',A(INDIR31)\n         DC    CL4'>',A(FWD)\n         DC    CL4'<',A(BACK)\n         DC    CL4'=',A(DEFINE)\n         DC    CL4',',A(NUMSCAN)\n         DC    CL4'M',A(MODE)\n         DC    CL4'L',A(LINK)\n         DC    CL4'O',A(OVERLAY)\n         DC    CL4'R',A(REFRESH)\nENDTAB   DC    X'FF'                   END OF TABLE INDICATOR\n         SPACE 2\n***********************************************************************\n*\n*     FORMAT THE OUTPUT SCREEN\n*\n***********************************************************************\n         SPACE 2\nFORMAT   LA    R3,INPLINE              CURSOR ADDRESS\n         MVC   INPLINE,BLANKS          CLEAR INPUT LINE\nFORMAT2  BAL   R14,ERASE               CLEAR THE SCREEN\n         LH    R2,CURRENT              HISTORY TABLE POINTER\n         A     R2,HISTORY              POINT AT HISTORY TABLE ENTRY\n         USING HIST,R2                 IDENTIFY HISTORY ENTRY FORMAT\n         L     R4,HISTADDR             GET ADDRESS TO DISPLAY\n         TM    HISTCBHP,X'80'          IS THIS A CB MAP IN USE\n         BO    CBHIT                   IF SO THE PROCESS IT\n         CLC   =X'7FFFFFFF',HISTCBHP   SUPPRESSED CB USAGE\n         BE    NOCB\n         DROP  R2\n         SPACE 2\n*----------------------------------------------------------------------\n*\n*        SEE IF CONTROL BLOCK MAP EXISTS\n*\n*----------------------------------------------------------------------\n         SPACE 2\nDUMP     L     R5,=V(CBMACS)           GET START OF INDEX\n         LTR   R5,R5                   ANY VALUE\n         BZ    NOCB                    NOPE\n         USING CBH,R5                  ADDRESS THE CONTROL BLK HEADER\nDUMPCB   CLC   =F'0',CBHNEXT           SEE IF END OF INDEX\n         BE    NOCB                    IF YES, NO CB FOUND\n         L     R2,CBHVOFF              GET CB IDENTIFIER OFFSET\n         AR    R2,R4                   ADD DISPLAY ADDRESS\n         SR    R3,R3                   CLEAR A REGISTER FOR IC\n         IC    R3,CBHVLEN              GET LENGTH\n         LR    R0,R3                   PUT IN 0 FOR GETSTOR\n         LA    R1,DUMPDATA             TARGET ADDR\n         BAL   R14,GETSTOR             FETCH THE DATA\n         B     NOTCB                   BR IF NO DATA FOUND\n         B     NOTCB                   BR IF PARTIAL DATA FOUND\n         BCTR  R3,0                    GET MACHINE LENGTH\n         EX    R3,CBFNDIT              LOOK FOR VALIDATION FIELD\n         BE    CBHIT                   BR IF YES, CB WAS FOUND\nNOTCB    L     R5,CBHNEXT              NEXT INDEX ENTRY\n         MVC   MSGLINE,BLANKS          Clear useless error msg     1.1C\n         B     DUMPCB                  AND CHECK FOR MORE CB'S\nCBFNDIT  CLC   CBHVAL(*-*),DUMPDATA    SEE IF IDENTIFIER MATCH\n         DROP  R5\n         SPACE 2\n*----------------------------------------------------------------------\n*\n* IF NO CONTROL BLOCK TO BE SHOWN, JUST USE DUMP FORMAT\n*\n*----------------------------------------------------------------------\n         SPACE 2\nNOCB     LR    R2,R4                   COPY ADDR TO DISPLAY\n         TM    MODEFLAG,ALIGN          QUADWORD ALIGNMENT WANTED\n         BZ    DUMPNOA                 BR IF NOT\n         N     R2,=XL4'FFFFFFF0'       ROUND DOWN FOR DISPLAY\nDUMPNOA  TM    MODEFLAG,MIDDUMP        PUT ADDR INCENTER OF SCREEN?\n         BZ    DUMPNOM                 BR IF NOT\n         SH    R2,=H'128'              IF YES, BACK UP QUAD WORDS\n* R2 NOW HAS FIRST ADDRESS TO DISPLAY\nDUMPNOM  LA    R0,256                  LENGTH TO FETCH\n         LA    R1,DUMPDATA             TARGET ADDRESS\n         LA    R2,0(0,R2)              clear top bit               1.1D\n         BAL   R14,GETSTOR             GO FETCH THE DATA\n         B     DUMPLN                  go dump by line             1.1D\n         NOP   0                       RETURN IF PARTIAL DATA FOUND\n         LA    R6,DUMPDATA             POINT TO DATA TO DISPLAY\n         LA    R4,OUT1                 FIRST OUTPUT LINE ADDR\n         LA    R5,16                   NO. OF LINES TO DISPLAY\nDUMPLOOP DS    0H                      FORMAT THE DISPLAY\n         STCM  R2,15,TEMP2             ADDRESS TO SHOW\n         UNPK  TEMP1(9),TEMP2(5)       CONVERT BINARY TO HEX\n         MVC   0(8,R4),TEMP1\n         TR    0(8,R4),HEXTAB\n         HEX   12,0                    CONVERT FIRST WORD TO HEX\n         HEX   22,4                    SECOND WORD TO HEX\n         HEX   32,8                    THIRD WORD\n         HEX   42,12                   FOURTH AND LAST WORD TO HEX\n         MVI   52(R4),C'*'             FRAME THE EBCDIC DISPLAY\n         MVI   69(R4),C'*'             FRAME THE OTHER SIDE\n         MVC   53(16,R4),0(R6)         COPY THE EBCDIC DATA\n         TR    53(16,R4),VALCHAR       DELETE INVALID CHARS\n         LA    R2,16(,R2)              NEXT LINE ADDR\n         LA    R6,16(,R6)              NEXT DATA AREA\n         LA    R4,80(,R4)              NEXT OUTPUT LINE\n         BCT   R5,DUMPLOOP             GO DO NEXT LINE\n         B     BLANKSC                 Try to blank out data not   1.1D\n         SPACE 2                                                   1.1D\nDUMPLN   DS    0H                      Fetch and dump each line    1.1D\n         LA    R4,OUT1                 FIRST OUTPUT LINE ADDR      1.1D\n         LA    R5,16                   NO. OF LINES TO DISPLAY     1.1D\nDUMPLP2  DS    0H                      FORMAT THE DISPLAY          1.1D\n         STCM  R2,15,TEMP2             ADDRESS TO SHOW             1.1D\n         UNPK  TEMP1(9),TEMP2(5)       CONVERT BINARY TO HEX       1.1D\n         MVC   0(8,R4),TEMP1                                       1.1D\n         TR    0(8,R4),HEXTAB                                      1.1D\n         LA    R0,16                   length of a line            1.1D\n         LA    R1,DUMPDATA             where to put data           1.1D\n         BAL   R14,GETSTOR             get it                      1.1D\n         B     DLKILL                  +0 no data found            1.1D\n         NOP   0                       +4 partial data found       1.1D\n         LA    R6,DUMPDATA             +8 all data found           1.1D\n         HEX   12,0                    CONVERT FIRST WORD TO HEX   1.1D\n         HEX   22,4                    SECOND WORD TO HEX          1.1D\n         HEX   32,8                    THIRD WORD                  1.1D\n         HEX   42,12                   FOURTH AND LAST WORD TO HEX 1.1D\n         MVI   52(R4),C'*'             FRAME THE EBCDIC DISPLAY    1.1D\n         MVI   69(R4),C'*'             FRAME THE OTHER SIDE        1.1D\n         MVC   53(16,R4),0(R6)         COPY THE EBCDIC DATA        1.1D\n         TR    53(16,R4),VALCHAR       DELETE INVALID CHARS        1.1D\nDLKILL   DS    0H                                                  1.1D\n         LA    R2,16(,R2)              NEXT LINE ADDR              1.1D\n*        LA    R6,16(,R6)              NEXT DATA AREA              1.1D\n         LA    R4,80(,R4)              NEXT OUTPUT LINE            1.1D\n         BCT   R5,DUMPLP2              GO DO NEXT LINE             1.1D\nBLANKSC  DS    0H                                                  1.1D\n         SPACE 2\n*----------------------------------------------------------------------\n*\n* NOW BLANK OUT THE SCREEN WHERE THE PAGE DIDN'T EXIST\n*\n*----------------------------------------------------------------------\n         SPACE 2\n         LA    R4,OUT1                 POINT TO FIRST OUTPUT LINE\n         SH    R2,=H'256'              FIRST ADDRESS DISPLAYED\n         LA    R5,16                   NUMBER OF LINES DISPLAYED\nBLLOOP   LA    R15,15(,R2)             LAST ADDRESS ON CURRENT LINE\n         CLC   LOGOOD,HIGOOD           ARE WE IN A WRAP CONDITION\n         BH    BLLP0                   YES SO SKIP NOLINE CHECK\n         C     R2,HIGOOD               IF START>=HIGH\n         BNL   NOLINE                     THEN BLANK ENTIRE LINE\nBLLP0    C     R2,LOGOOD               IF START<LOW & END>=LOW\n         BNL   BLLP1                      THEN HI GOOD AND LOW NEEDS\n*                                                  BLANK\n         C     R15,LOGOOD\n         BNL   HIMIX\nBLLP1    C     R2,HIGOOD               IF START<HIGH & END>HIGH\n         BNL   BLLP2                      THEN LOW GOOD AND BLANK\n*                                                HIGH\n         C     R15,HIGOOD\n         BH    LOWOK\nBLLP2    DS    0H                      LINE OK OTHERWISE\n         B     BLOOPEND\n* BOTH LOW AND HIGH MISSING -- BLANK ENTIRE LINE\nNOLINE   MVI   12(R4),C' '             START OF DATA\n         MVC   13(57,R4),12(R4)        CLEAR THE LINE\n         B     BLOOPEND                GO CHECK ANOTHER LINE\n* BR HERE IF LOW END GOOD, HIGH MAY BE  MISSING\nLOWOK    S     R15,HIGOOD              # OF BYTES TO BLANK\n* THE FOLLOWING CODE TAKES CARE OF LOW STORAGE WRAP\n         CH    R15,=H'15'              MORE THAN 15 BYTES TO CLEAR\n         BH    BLOOPEND                IF YES, IT WRAPPED, NO CLEAR\n         LR    R1,R15                  COPY # TO BLANK\n         SRL   R1,2                    FIND # OF WORDS\n         SLL   R1,1                    TWO BLANKS PER WORD\n         AR    R1,R15                  ADD NUMBER OF HEX CHARS\n         AR    R1,R15                  WHICH IS TWICE THE # OF BYTES\n         LA    R6,50(,R4)              POINT JUST AFTER HEX DATA\n         SR    R6,R1                   FIRST BYTE TO CLEAR\n         BCTR  R1,0                    REDUCE BY 1 FOR EXEXUTE\n         EX    R1,CLEARMVC             CLEAR HEX SIDE\n         LA    R6,69(,R4)              POINT TO TRAILING *\n         SR    R6,R15\n         EX    R15,CLEARMVC            CLEAR EBCDIC AND *\n         MVI   0(R6),C'*'              NOTE END OF EBCDIC DATA\n         B     BLOOPEND                GO CHECK NEXT LINE\n* COME HERE WHEN HI END GOOD AND LOW END MISSING\nHIMIX    L     R15,LOGOOD              LOWEST GOOD ADDR\n         SR    R15,R2                  NUMBER OF BYTES TO CLEAR\n         CH    R15,=H'16'              Total line                  1.1D\n         BNL   NOLINE                  Kill complete line          1.1D\n         LR    R1,R15                  COPY # TO CLEAR\n         SRL   R1,2                    # OF WORDS TO CLEAR\n         SLL   R1,1                    NUMBER OF IMBEDDED BLANKS\n         AR    R1,R15                  ADD # OF HEX CHARS\n         AR    R1,R15\n         BCTR  R1,0                    REDUCE BY 1 FOR MVC\n         LA    R6,12(,R4)              START OF HEX DATA\n         EX    R1,CLEARMVC             AND CLEAR THE HEX DATA\n         LA    R6,52(,R4)              POINT TO FIRST * ON LINE\n         EX    R15,CLEARMVC            CLEAR * AND EBCDIC DATA\n         LA    R6,52(R15,R4)           POINT TO FIRST CLEARED BYTE 1.1D\n         MVI   0(R6),C'*'              AND DROP IN A *\nBLOOPEND LA    R4,80(,R4)              POINT TO NEXT LINE\n         LA    R2,16(,R2)              ADDRESS ON NEXT LINE\n         BCT   R5,BLLOOP               AND SCAN ALL LINES\n         SPACE 2\n*----------------------------------------------------------------------\n*\n*  PUT IN ARROWS TO POINT TO DESIRED DATA\n*\n*----------------------------------------------------------------------\n         SPACE 2\n         LA    R4,OUT1                 ADDR OF FIRST LINE\n         TM    MODEFLAG,MIDDUMP        DOES IT BELONG IN THE MIDDLE\n         BZ    ARRTOP                  BR IF NOT\n         LA    R4,OUT9                 POINT TO MIDDLE LINE\nARRTOP   SR    R1,R1                   ASSUME NO QUADWORD ALIGNMENT\n         TM    MODEFLAG,ALIGN          WAS ASSUMPTION CORRECT\n         BZ    ARRALIGN                BR IF YES, ELSE GET OFFSET\n         LA    R1,15                   MASK FOR LOW 4 BITS\n         NR    R1,R2                   GET BYTE OFFSET FOR ARROW\n* FIRST DO THE EBCDIC SIDE\nARRALIGN LA    R15,51(,R4)             BYTE BEFORE FIRST *\n         EX    R1,MOVEMVC              MOVE THE DATA BACK\n         AR    R15,R1                  ADDR OF LAST BYTE MOVED\n         MVI   1(R15),C'>'             PUT IN THE ARROW\n* NOW MOVE THE HEX SIDE\n         SR    R0,R0                   CLEAR HIGH ORDER BITS\n         SLDL  R0,30                   WHICH WORD IS TO BE MOVED\n         SRL   R1,30                   NUMBER OF BYTES TO BE MOVED\n         LR    R15,R0                  COPY OFFSET OF WORD TO MOVE\n         MH    R15,=H'10'              EACH WORD TAKES UP 10 BYTES\n         LA    R15,10(R4,R15)          POINT IN FRONT OF WORD TO MOVE\n         SLL   R1,R1                   NUMBER OF HEX DIGITS TO MOVE\n         EX    R1,MOVEMVC              MOVE THE DATA BACK\n         AR    R15,R1                  POINT TO PLACE FOR ARROW\n         MVI   1(R15),C'>'             AND PUT IT THERE\n* FALL  THRU TO SHOW THE SCREEN\n         EJECT\n*\n* DISPLAY THE PAGE AND CHECK FOR END REQUEST\n*\nDISPLAY  UNPK  TEMP1(5),CURASID(3)     FORMAT CURRENT ASID\n         MVC   ASIDLN1(4),TEMP1        AND PUT ON SCREEN\n         TR    ASIDLN1(4),HEXTAB\n         MVC   SAVEASID,ASIDLN1        SAVE FORMATED VERSION\n         MVC   KEYS,KEY1               SETUP PFK\n         MVC   KEYS+80,KEY2                 INFO LINE\n*\nTPUTSCRN DS    0H\n         LA    R0,QDSLNG\n         TPUT  QDSCREEN,(0),FULLSCR MF=(E,QTPUT)\n         XC    INPLINE,INPLINE\n         XC    PFREPLY,PFREPLY\n         TGET  PFREPLY,69,ASIS MF=(E,QTGET)\n         LR    R3,R1                   SAVE INPUT LENGTH\n         CH    R15,=H'12'     IS INPUT LONGER THAN BUFFER?\n         BNE   NOCLEAR        NO. CONTINUE.\n         TCLEARQ INPUT        CLEAR THE QUEUE\nNOCLEAR  DS    0H\n         MVC   MSGLINE,BLANKS          INDICATE NO ERROR           1.1A\n         LA    R1,PFREPLY+3            POINT AT FIRST BYTE\n         SH    R3,=H'3'                ADJUST LENGTH\n*\n**       HANDLE ASID IF NECESSARY\n*\n         CLC   0(3,R1),=X'1140F9'      IS THIS ASID MODIFICATION\n         BNE   NOASID                  NO SO SKIP\n         LA    R1,3(,R1)               POINT AT FIRST BYTE\n         SH    R3,=H'3'                ADJUST LENGTH\n         LR    R2,R1                   SAVE START ADDRESS\nASIDLOOP CLI   0(R1),X'11'             LOOK FOR START FIELD\n         BE    HAVEASID\n         LA    R1,1(,R1)               BUMP POINTER\n         BCT   R3,ASIDLOOP\nHAVEASID LR    R15,R1                  MOVE POINTER\n         SR    R15,R2                  GET LENGTH\n         BZ    NOASID\n         MVC   ASIDLN1,=CL4' '\n         LA    R4,ASIDLN1+4            GET TO ADDRESS +4\n         SR    R4,R15                      - REAL LENGTH\n         BCTR  R15,0                   GET MACHINE LENGTH\n         EX    R15,MOVERPLY\nNOASID   DS    0H\n         LTR   R3,R3                   ANY DATA LEFT\n         BZ    ENDINP\n         CLC   0(3,R1),=X'11C15C'      CHECK FOR START OF FIELD\n         BNE   ENDINP                  IF NOT HERE THEN SKIP\n         LA    R1,3(,R1)               POINT AT FIRST BYTE\n         SH    R3,=H'3'                ADJUST LENGTH\n         LR    R2,R1                   SAVE START ADDRESS\nRPLYLOOP CLI   0(R1),X'11'             LOOK FOR START FIELD\n         BE    HAVERPLY\n         LA    R1,1(,R1)               BUMP POINTER\n         BCT   R3,RPLYLOOP\nHAVERPLY LR    R15,R1                  MOVE POINTER\n         SR    R15,R2                  GET LENGTH\n         BZ    NOASID\n         LA    R4,INPLINE              GET TO ADDRESS\n         BCTR  R15,0                   GET MACHINE LENGTH\n         EX    R15,MOVERPLY\nENDINP   OC    INPLINE,=CL63' '        MAKE UPPERCASE\n         SPACE 2\n         IC    R4,PFCODE\n         XR    R5,R5\n         CLI   PFCODE,X'7D'      ENTER?\n         BE    ENTER             /YES - TREAT AS ENTER\n         CLI   PFCODE,X'F0'      TEST-REQ/SYS-REQ?\n         BE    ENTER             /YES - TREAT AS ENTER\n         CLI   PFCODE,X'01'      OTHER KIND OF SYS-REQ?\n         BE    ENTER             /YES - TREAT AS ENTER\n         CLI   PFCODE,X'6C'      PA1?\n         BE    ENDIT             /YES - TERMINATE\n         CLI   PFCODE,X'6E'      PA2?\n         BE    TPUTSCRN          /YES - GO RESHOW SCREEN\n         CLI   PFCODE,X'6B'      PA3?  (TCAM GENERATED)\n         BE    TPUTSCRN          /YES - GO RESHOW SCREEN\n         N     R4,=X'0000000F'   EXTRACT PF-KEY NUMBER\n         CH    R4,=H'12'\n         BH    ENTER            \"ENTER\" KEY\n         BCTR  R4,0\n         SLL   R4,2              TIMES SIZE OF AN ENTRY\n         B     PFKEYTAB(R4)\nPFKEYTAB B     HELP                    PF1\n         B     DISPLAY                 PF2\n         B     ENDIT                   PF3    QUIT\n         B     DISPLAY                 PF4\n         B     REPEAT                  PF5    REPEAT COMMAND\n         B     DISPLAY                 PF6\n         B     UP                      PF7    SCROLL UP\n         B     DOWN                    PF8    SCROLL DOWN\n         B     BACK                    PF9    SCROLL BACKWARDS\n         B     FWD                     PF10   SCROLL FORWARDS\n         B     DISPLAY                 PF11\n         B     DISPLAY                 PF12\nMOVERPLY MVC   0(0,R4),0(R2)           **EXECUTED**\n         EJECT\nENTER    CLC   =C'END',INPLINE         SEE IF END TYPED\n         BNE   ISCAN                   IF NOT, GO LOOK AT INPUT\n* CLEAN UP AND GO AWAY\nENDIT    LM    R0,R1,CSALEN            GET SP, LEN, AND ADDR\n         LTR   R1,R1                   WAS BUFFER GOTTEN\n         BZ    ENDIT1                  NOPE\n         FREEMAIN R,LV=(0),A=(1)       FREE BUFFER\nENDIT1   TM    FLAGS,NOAUTH            ARE WE AUTHORIZED\n         BO    ENDIT2                  NOPE\n         MODESET MODE=PROB             RESET MODE\nENDIT2   DS    0H\n         STTMPMD OFF                                               1.1C\n         STFSMODE OFF                  RESET FULLSCREEN\n         L     R13,SAVE+4              GET ORIGINAL SAVE AREA\n         FREEMAIN R,LV=WORKLEN,SP=1,A=(R10)\n         RETURN (14,12),RC=0\n         EJECT\n*----------------------------------------------------------------------\n*\n* CBHIT  -- CONTROL BLOCK FORMATTING ROUTINE\n* AT ENTRY:\n*              R4 HAS ADDRESS TO DISPLAY (OFFSET 0 - MAIN SEGMENT)\n*              R5 HAS CONTROL BLOCK HEADER ADDRESS\n*\n*----------------------------------------------------------------------\n         SPACE 2\nCBHIT    LH    R2,CURRENT              GET HISTORY TABLE POINTER\n         A     R2,HISTORY              GET ENTRY ADDRESS\n         USING HIST,R2                 SETUP FORMAT OF ENTRY\n         ICM   R6,15,HISTCBSP          LAST SEGMENT DISPLAYED\n         BNZ   CBHIT2                  BR IF A CONTINUING DISPLAY\n         USING CBH,R5                  ADDRESS HEADER BLOCK\n         L     R6,CBHCBSP              ELSE GET FIRST SEG ADDRESS\n         ST    R6,HISTCBSP             AND SAVE FOR LATER\n         ST    R5,HISTCBHP             AND SAVE FOR LATER\n         OI    HISTCBHP,X'80'          NOTE CB FORMAT ROUTINE IN USE\n*   GET BLOCK NAME AND HANDLE ANY SEGMENT INDIRECTION\nCBHIT2   DS    0H\n         USING CBS,R6\n         L     R5,HISTCBHP             POINT TO CB HEADER\n         MVC   MSGLINE+36(8),CBHNAME   MOVE IN CB NAME\n         STCM  R4,15,TEMP2             SAVE ADDRESS OF BLOCK\n         UNPK  TEMP1(9),TEMP2(5)          AND CONVERT\n         TR    TEMP1(8),HEXTAB               TO HEX\n         MVC   MSGLINE+26(8),TEMP1     MOVE IN ADDRESS OF BLOCK\n         DROP  R2,R5\n         CLC   =H'0',CBSILEN           IS THIS SEGMENT INDIRECT\n         BE    CBHIT3                  IF NOT THEN SKIP CODE\n         LH    R0,CBSILEN              GET LENGTH TO FETCH (ALWAYS 4\n         LA    R1,DUMPDATA             WHERE TO PUT IT\n         LH    R2,CBSIOFF              GET INDIRECT OFFSET\n         AR    R2,R4                   GET TRUE MAIN BLOCK ADDRESS\n         BAL   R14,GETSTOR             GET THE INDIRECT WORD\n         B     NOCB                    BR IF NO DATA FETCHED\n         B     NOCB                    BR IF PARTIAL DATA FETCHED\n         L     R4,DUMPDATA             RESET THE ADDR TO DUMD\n         LH    R2,CURRENT\n         A     R2,HISTORY              GET ADDR OF ENTRY\n         ST    R4,HISTSADR-HIST(R2)    SAVE SEGMENT ADDRESS\nCBHIT3   DS    0H\n         LH    R0,CBSDLEN              LENGTH TO FETCH\n         LA    R1,DUMPDATA             TARGET ADDRESS\n         LH    R2,CBSDOFF              OFFSET TO FETCH\n         AR    R2,R4                   ADD START OF CB ADDRESS\n         BAL   R14,GETSTOR             GO FETCH THE DATA\n         B     NOCB                    BR IF NO DATA FETCHED\n         B     NOCB                    BR IF PARTIAL DATA FETCHED\n         LA    R5,OUT1-80              START OF SCREEN\n         LA    R2,DUMPDATA             POINT TO DATA BUFFER\n         SH    R2,CBSDOFF              BACKUP TO VIRTUAL CB ORIGIN\n         LA    R6,CBSLEN(,R6)          POINT AT FIRST CB FIELD\n         USING CBF,R6\nCBLOOP   DS    0H\n         LH    R1,CBFLINE              GET LINE NUMBER\n         MH    R1,=H'80'               TIMES LINE LENGTH\n         AH    R1,CBFCOLM              PLUS THE COLUMN NUMBER\n         AR    R1,R5                   PLUS START OF LINE\n         MVC   0(8,R1),CBFNAME         SET NAME FIELD\n         LA    R1,8(,R1)               SKIP NAME\n         LH    R14,CBFOFFS             GET OFFSET INTO CB\n         AR    R14,R2                  GET ADDRESS IN FETCHED DATA\n         SR    R15,R15                 CLEAR REGISTER\n         IC    R15,CBFDLEN             GET LENGTH OF DATA ITEM\n         LA    R0,80-8                 get max column less label   1.1D\n         SH    R0,CBFCOLM              and starting col number     1.1D\n*   FORMAT CHARACTER AS DISPLAY AND REST AS HEX\n         CLI   CBFTYPE,C'C'            WHAT IS TYPE\n         BNE   CBFLP1                  IF NOT CHAR THEN DO HEX     1.1D\n         CR    R15,R0                  see if data too big         1.1D\n         BNH   *+6                     use actual length           1.1D\n         LR    R15,R0                  truncate data               1.1D\n         BCTR  R15,0                   GET MACHINE LENGTH\n         EX    R15,CBMVC               MOVE IN DATA\n         EX    R15,CBTR                OUTPUT ONLY VALID CHARS      1.1\n         B     CBFEND\nCBFLP1   SRL   R0,1                    convert columns to bytes    1.1D\n         CR    R15,R0                  see if data too big         1.1D\n         BNH   *+6                     use actual length           1.1D\n         LR    R15,R0                  truncate data               1.1D\nCBFLOOP  MVC   TEMP2(1),0(R14)         MOVE IN DATA BYTE\n         UNPK  TEMP1(3),TEMP2(2)\n         TR    TEMP1(2),HEXTAB\n         MVC   0(2,R1),TEMP1           MOVE IN CONVERTED BYTE\n         LA    R1,2(,R1)               BUMP OUTPUT ADDRESS\n         LA    R14,1(,R14)             BUMP INPUT ADDRESS\n         BCT   R15,CBFLOOP             KEEP LOOPINT\nCBFEND   LA    R6,CBFLEN(,R6)          BUMP TO NEW FIELD\n         CLC   0(4,R6),=F'0'           END OF SEGMENT\n         BNE   CBLOOP                  IF NOT THEN KEEP GOING\n         B     DISPLAY                 ALL DONE SO DISPLAY IT\n         DROP  R6\n         SPACE 1\nCBMVC    MVC   0(0,R1),0(R14)          **EXECUTED** MOVE IN DATA\nCBTR     TR    0(0,R1),VALCHAR         **EXECUTED** MAKE VALID      1.1\n         SPACE 2\n*----------------------------------------------------------------------\n*\n*  GET ADDRESS OF CURRENT CONTROL BLOCK SEGMENT\n*     ON EXIT R2 = ADDR OF THIS CONTROL BLOCK SEGMENT\n*\n*----------------------------------------------------------------------\nGETCURAD DS    0H\n         LH    R2,CURRENT              GET HIST TABLE OFFSET\n         A     R2,HISTORY              GET ENTRY\n         USING HIST,R2\n         CLC   =F'0',HISTSADR          IS SEGMENT A SECONDARY SEGMENT\n         BE    GCA1                    NOPE, SO SKIP CODE\n         L     R2,HISTSADR             GET ADDRESS OF BLOCK\n         BR    R14\nGCA1     L     R2,HISTADDR             GET MAIN BLOCK ADDR\n         BR    R14\n         DROP  R2\n         EJECT\n***********************************************************************\n*\n* COMMAND ROUTINES\n*\n         SPACE 2\n*----------------------------------------------------------------------\n*\n* HELP -- DISPLAY HELP INFORMATION\n*\n*----------------------------------------------------------------------\n         SPACE 2\nHELP     DS    0H\n         LA    R1,16*80\n         LR    R3,R1\n         L     R2,=A(HELPMSG)      POINT AT FROM\n         LA    R0,OUT1\n         MVCL  R0,R2\n         B     DISPLAY\n         SPACE 2\n*----------------------------------------------------------------------\n*\n* REFRESH -- REFETCH THE CORE AND REDISPLAY IT\n*\n*----------------------------------------------------------------------\n         SPACE 2\nREFRESH  OI    FLAGS,RFRSH             SET REFRESH FLAG\n         B     FORMAT                  REFORMAT SCREEN\n         SPACE 2\n*----------------------------------------------------------------------\n*\n* OVERLAY  --  MANIPULATE CONTROL BLOCK FORMATTING\n*\n*----------------------------------------------------------------------\n         SPACE 2\nOVERLAY  CLC   =C'NULL',INPLINE+1      SEE IF NO FORMATTING WANTED\n         BE    OVERNULL                BR IF YES\n         L     R5,=V(CBMACS)           GET CB MAP INDEX\n         LTR   R5,R5                   ANY MAPS\n         BZ    OVERNULL                IF NOT TREAT AS NULL OVERLAY\n         USING CBH,R5                  SETUP ADDRESSABILITY\nOVERLOOP CLC   =F'0',CBHNEXT           END OF CONTROL BLOCKS\n         BE    FORMAT                  IF YES, IGNORE COMMAND\n         CLC   INPLINE+1(8),CBHNAME    SEE IF CB MATCH\n         BE    OVERHIT                 BR IF YES\n         L     R5,CBHNEXT              ELSE POINT TO NEXT ENTRY\n         B     OVERLOOP                AND KEEP LOOKING\nOVERHIT  L     R6,CBHCBSP              START SEG ADDR FOR CB FOUND\n         LH    R2,CURRENT              CURRENT HIST TABLE ENTRY OFFSET\n         A     R2,HISTORY              GET ENTRY ADDRESS\n         USING HIST,R2                 SETUP ENTRY FORMAT\n         ST    R5,HISTCBHP             POINT AT HEADER\n         ST    R6,HISTCBSP             POINT AT SEGMENT(FIRST)\n         OI    HISTCBHP,X'80'          MARK AS CB\n         XC    HISTSADR,HISTSADR       CLEAR SEC SEG ADDR\n         B     FORMAT                  GO SHOW IT\n         SPACE 1\nOVERNULL LH    R2,CURRENT              CURRENT HIST TABLE ENTRY OFFSET\n         A     R2,HISTORY              POINT AT CURRENT ENTRY\n         MVC   HISTCBHP,=X'7FFFFFFF'   SUPPRESS CB OVERLAY\n         B     FORMAT                  GO SHOW STORAGE\n         DROP  R5,R2\n         SPACE 2\n*----------------------------------------------------------------------\n*\n* DOWN -- SCROLL DOWN 256 BYTES OR NEXT CTRL BLK SEGMENT\n*\n*----------------------------------------------------------------------\n         SPACE 2\nDOWN     LH    R2,CURRENT              CURRENT HIST TABLE POINTER\n         A     R2,HISTORY              POINT TO HIST TABLE ENTRY\n         USING HIST,R2                 SETUP ENTRY FORMAT\n         TM    HISTCBHP,X'80'          SEE IF THIS IS A CB DISPLAY\n         BO    DOWNCB                  BR IF YES\n         L     R1,HISTADDR             ELSE GET ADDR TO SHOW\n         AH    R1,=H'256'              AND MOVE DOWN ONE SCREEN\n         ST    R1,HISTADDR             AND REPLACE IN HIST TABLE\n         B     FORMAT                  GO DISPLAY IT\nDOWNCB   L     R1,HISTCBSP             GET CB SEGMENT ADDR\n         L     R1,CBSNEXT-CBS(,R1)     GET NEXT SEG ADDR\n         ST    R1,HISTCBSP             AND PUT IN HIST TABLE\n         XC    HISTSADR,HISTSADR       CLEAR SEC SEG ADDR\n         B     FORMAT                  GO SHOW IT\n         DROP  R2\n         SPACE 2\n*----------------------------------------------------------------------\n*\n* UP   -- SCROLL UP   256 BYTES OR PREV CTRL BLK SEGMENT\n*\n*----------------------------------------------------------------------\n         SPACE 2\nUP       LH    R2,CURRENT              CURRENT HIST TABLE POINTER\n         A     R2,HISTORY              POINT TO HIST TABLE ENTRY\n         USING HIST,R2                 SETUP FORMAT OF ENTRY\n         TM    HISTCBHP,X'80'          SEE IF THIS IS A CB DISPLAY\n         BO    UPCB                    BR IF YES\n         L     R1,HISTADDR             ELSE GET ADDR TO SHOW\n         SH    R1,=H'256'              AND MOVE UP ONE SCREEN\n         ST    R1,HISTADDR             AND REPLACE IN HIST TABLE\n         B     FORMAT                  GO DISPLAY IT\nUPCB     L     R1,HISTCBSP             GET CB SEGMENT ADDR\n         L     R1,CBSPREV-CBS(,R1)     GET PREV SEG ADDR\n         ST    R1,HISTCBSP             AND PUT IN HIST TABLE\n         XC    HISTSADR,HISTSADR       CLEAR SEC SEG ADDR\n         B     FORMAT                  GO SHOW IT\n         DROP  R2\n         SPACE 2\n*----------------------------------------------------------------------\n*\n* REPEAT -- REPEAT LAST INPUT LINE\n*\n*----------------------------------------------------------------------\n         SPACE 2\nREPEAT   MVC   INPLINE(52),INPSAVE     COPY SAVED INPUT\n         B     ISCAN2                  AND PROCESS IT\n         SPACE 2\n*----------------------------------------------------------------------\n*\n* LINK -- LINK TO LABELED CONTROL BLOCK FIELD\n*\n*----------------------------------------------------------------------\n         SPACE 2\nLINK     LH    R2,CURRENT              CURRENT HIST TABLE POINTER\n         A     R2,HISTORY              POINT TO HIST TABLE ENTRY\n         USING HIST,R2                 SETUP FORMAT OF ENTRY\n         TM    HISTCBHP,X'80'          SEE IF CB FORMATTING IN USE\n         BO    LINK2                   BR IF YES\nLINKERR  MVC   MSGLINE,LINKMSG         NOTE ERROR IN LINK\n         B     FORMAT                  AND RESHOW SCREEN\nLINK2    L     R3,HISTCBSP             GET CURRENT CB SEG ADDRESS\n         LA    R5,0(,R3)               CLEAR FLAGS AND SETUP FOR COMP\n         USING CBS,R4\nLINK2A   LR    R4,R3                   SAVE THE START OF SEG ADDR\n         LA    R3,CBSLEN(,R3)          POINT PAST SEG HEADER\n         USING CBF,R3\nLINK3    CLC   CBFNAME(4),=F'0'        END OF SEGMENT\n         BE    LINK4\n         CLC   CBFNAME,INPLINE+1       DOES NAME MATCH\n         BE    LINKFND                 IF SO THEN FOUND\n         LA    R3,CBFLEN(,R3)          POINT PAST THIS ONE\n         B     LINK3                   KEEP LOOKING\nLINK4    DS    0H\n         L     R3,CBSNEXT              POINT TO NEXT SEGMENT\n         CR    R3,R5                   ARE WE BACK AT START\n         BNE   LINK2A                  IF NOT KEEP GOING\n         B     LINKERR                 IF NOT THEN ISSUE ERROR\n         DROP  R4,R2\n* A MATCH HAS  BEEN FOUND. FETCH THE  ADDRESS TO LINK TO\nLINKFND  DS    0H\n         SR    R0,R0                   CLEAR FOR IC\n         IC    R0,CBFDLEN              LENGTH OF ITEM  MINUS 1\n         LA    R1,DUMPDATA             ADDR TO PLACE DATA IN\n         BAL   R14,GETCURAD            GET ADDR OF CURRENT SEGMENT\n         AH    R2,CBFOFFS              OFFSET OF ITEM TO FETCH\n         BAL   R14,GETSTOR             FETCH THE  ADDRESS\n         B     LINKERR                 BR IF DATA CANT BE FETCHED\n         B     LINKERR                 BR IF DATA CANT BE FETCHED\n         BAL   R15,FWDSUB              UPDATE HIST TABLE TO NEXT\n         L     R0,DUMPDATA             LOAD ADDRESS THAT WAS FETCHED\n         SR    R15,R15                 NOW ADJUST THE\n         IC    R15,CBFDLEN               FETCHED DATA\n         LA    R1,4                        SO THAT\n         SR    R1,R15                        IT IS RIGHT\n         BNP   LF1                             JUSTIFIED IN\n         SLL   R1,3                              REGISTER IF\n         SRL   R0,0(R1)                            LESS THAN 4\nLF1      DS    0H                                    BYTES\n         LH    R2,CURRENT              NEW HIST TABLE POINTER\n         A     R2,HISTORY              GET ENTRY ADDRESS\n         USING HIST,R2\n         ST    R0,HISTADDR             SAVE NEW ADDRESS\n         XC    HISTCBHP,HISTCBHP          AND\n         XC    HISTCBSP,HISTCBSP            CLEAR\n         XC    HISTSADR,HISTSADR               REST\n         B     FORMAT                  GO FORMAT THE NEW CB\n         DROP  R3,R2\n         SPACE 2\n*----------------------------------------------------------------------\n*\n*  SET INDIRECT FLAG\n*\n*----------------------------------------------------------------------\n         SPACE 2\nINDIR31  OI    FLAGS,IND31             SET FLAG\nINDIR    OI    FLAGS,INDFLAG           SET FLAG\n         LA    R3,1(,R3)               UPDATE SCAN POINTER\n         CLI   INPLINE+1,C' '          USE CURRENT ADDRESS\n         BNE   NUMSCAN                 IF NO, GO SCAN INPUT ADDRESS\n         BAL   R14,GETCURAD\n         LR    R4,R2                   MOVE TO RIGHT REGISTER\n         B     ENDNUM\n         SPACE 2\n***********************************************************************\n*\n*  ESTABLISH SCREEN MODE\n*\n***********************************************************************\n         SPACE 2\nMODE     CLC   =C'1 ',INPLINE+1        MODE ONE TEST\n         BE    MODE1                   BR IF YES\n         CLC   =C'0 ',INPLINE+1        CHECK FOR MODE ZERO         1.1D\n         BNE   INVAL                   IF NOT EITHER, INVALID\n         NI    MODEFLAG,255-MIDDUMP    MODE 0 MEANS BACKUP 0\n         B     FORMAT\nMODE1    OI    MODEFLAG,MIDDUMP        MODE 1 MEANS BACK UP 7 LINES\n         B     FORMAT\nINVAL    MVC   MSGLINE,MODEMSG\n         B     FORMAT\n         SPACE 2\n***********************************************************************\n*\n*  MANIPULATE HISTORY TABLE\n*\n***********************************************************************\n         SPACE 2\nFWD      BAL   R15,FWDSUB              FORWARD 1 IN HIST TABLE\n         B     FORMAT\n         SPACE\nFWDSUB   LH    R1,CURRENT              CURRENT ENTRY INDEX\n         LA    R1,HISTLEN(,R1)\n         CH    R1,=AL2(50*HISTLEN)     SEE IF WRAP NEEDED\n         BL    FWDEND                  BR IF NOT\n         SR    R1,R1                   WRAP TO BEGINNING\nFWDEND   STH   R1,CURRENT              STORE NEW OFFSET\n         BR    R15                     RETURN TO CALLER\n         SPACE 1\nBACK     LH    R1,CURRENT\n         SH    R1,=AL2(HISTLEN)        BACK UP ONE ENTRU\n         BNM   BACKEND                 BR IF NO BACKWARD WRAP\n         LA    R1,49*HISTLEN           ELSE GO TO END OF TABLE\nBACKEND  STH   R1,CURRENT              SAVE RESULT\n         B     FORMAT\n         SPACE 2\n***********************************************************************\n*\n*   ADD ENTRY TO SYMBOL TABLE\n*\n***********************************************************************\n         SPACE 2\nDEFINE   LA    R15,50                  NUMBER OF TABLE ENTRIES\n         LA    R2,NAMES                START OF TABLE\nDEFLOOP1 CLI   0(R2),X'0'              SEE IF UNUSED ENTRY\n         BE    NSPACE                  BR IF SPACE FOUND\n         LA    R2,12(,R2)              NEXT ENTRY ADDR\n         BCT   R15,DEFLOOP1            TRY ALL ENTRIES\n         MVC   MSGLINE,SYMFULL         TABLE IS FULL\n         B     FORMAT\nNSPACE   LA    R15,9                   MAX LENGTH +1\n         LA    R0,INPLINE+1            ADDR OF FIRST BYTE\n         LR    R1,R0                   COPY SYMBOL ADDR\nDEFLOOP2 CLI   0(R1),C' '              SEE IF END OF SYM\n         BE    DEFEND                  BR IF YES\n         LA    R1,1(,R1)               POINT TO NEXT BYTE\n         BCT   R15,DEFLOOP2            CONTINUE FOR 9 BYTES\nDEFBAD   MVC   MSGLINE,DEFMSG          SYMBOL TOO LONG OR TOO SHORT\n         B     FORMAT2                 DISPLAY WITH CURSOR AT ERROR\nDEFEND   SR    R1,R0                   SYMBOL LENGTH\n         BZ    DEFBAD                  NULL SYMBOL ILLEGAL\n         BCTR  R1,R0                   FOR EXECUTE\n         MVC   0(8,R2),=CL8' '         CLEAR TABLE ENTRY\n         EX    R1,DEFMOVE              MOVE SYMBOL\n         LH    R1,CURRENT              GET CURRENT ADDRESS\n         A     R1,HISTORY\n         L     R1,HISTADDR-HIST(,R1)\n         ST    R1,8(,R2)               STORE WITH SYMBOL\n         B     FORMAT\nDEFMOVE  MVC   0(0,R2),INPLINE+1       EXECUTED TO MOVE SYMBOL\n         SPACE 2\n***********************************************************************\n*\n*  SCAN THE ADDRESS EXPRESSION\n* REGISTER USAGE\n* R2 LAST NUMBER SCANNED\n* R3 SCAN POINTER\n* R4 CURRENT OUTPUT VALUE\n* R5 LAST OPERATOR SCANNED\n*\n***********************************************************************\n         SPACE 2\nNUMSCAN  DS    0H\n         BAL   R14,GETCURAD            CURRENT ENTRY IS DEFAULT\n         LR    R4,R2                   CURRENT ENTRY IS DEFAULT\n         LA    R5,0                    ASSUME DEFAULT TO BE TAKEN\n         CLI   0(R3),C'+'              SEE IF PREFIX PLUS\n         BNE   NOTPLUS                 BR IF NOT\n         LA    R5,2                    INDICATE PLUS OPERATOR\n         B     NUMOP                   GO TO ADV POINTER\nNOTPLUS  CLI   0(R3),C'-'              IS IT PREFIX MINUS\n         BNE   NUMLOOP                 BR IF NOT, USE DEFAULT AS LOAD\n         LA    R5,4                    INDICATE MINUS OPERATOR\nNUMOP    LA    R3,1(,R3)               POINT TO NEXT INPUT BYTE\nNUMLOOP  CLI   0(R3),C','              SEE IF NAME INDICATED\n         BE    NAMESCAN                BR IF YES\n         TRT   0(9,R3),NUMTAB          SEARCH FOR DELIMITER\n         LR    R6,R3                   SAVE START OF NUMBER\n         BC    8,BADSTUFF              BR IF INPUT TOO LONG\n         LR    R3,R1                   UPDATE SCAN POINTER\n         SR    R1,R6                   GET LENGTH OF INPUT\n         BZ    BADSTUFF                BR IF ZERO INPUT\n         MVC   TEMP1(8),=CL8' '        CLEAR TEMP AREA\n         LA    R15,TEMP1+8             RIGHT JUSTIFY INPUT\n         SR    R15,R1                  POINT TO RIGHT SPOT IN TEMP AREA\n         BCTR  R1,0                    PREPARE FOR EX\n         EX    R1,HEXMOVE              MOVE INPUT RIGHT JUSTIFIED\n         TR    TEMP1(8),HEXTAB         TRANSLATE TO HEX\n         PACK  TEMP2(5),TEMP1(9)       CONVERT HEX TO BINARY\n         ICM   R2,15,TEMP2             NEW DISPLAY ADDRESS\nNUMDELIM EX    0,OPER(R5)              EXECUTE PREVIOUS OPERATOR\n         CLI   0(R3),C' '              IS DELIM A BLANK\n         BE    ENDNUM                  IF YES, END SCAN\n         LA    R5,2                    PLUS OPERATOR CODE\n         CLI   0(R3),C'+'              IS OPER L PLUS\n         BE    NUMOP                   BR IF YES TO CONTINUE SAAN\n         LA    R5,4                    MINUS CODE\n         CLI   0(R3),C'-'              IS OPER MINUS\n         BE    NUMOP                   BR IF YES\n         MVC   MSGLINE,INVALOP         ELSE BAD DELIMITER\n         B     FORMAT2                 DISPLAY WITH CURSOR AT ERROR\nENDNUM   TM    FLAGS,INDFLAG           IS THIS AN INDIRECT REQ\n         BZ    NOTIND                  BR IF NOT\n         TM    FLAGS,IND31             DO WE WANT 31 BIT INDIRECT{\n         BO    *+8                     SKIP CLEAR IF YES\n         ICM   R4,8,=X'00'             CLEAR TOP BYTE\n         LR    R2,R4                   SET ADDR TO GET FROM\n         LA    R0,4                    NUMBER OF BYTES TO GET\n         LA    R1,DUMPDATA             WHERE TO PUT IT\n         BAL   R14,GETSTOR             DO MEMORY FETCH\n         B     BADIND                  NONE GOT\n         B     BADIND                  SOME BUT NOT ALL GOT\n         L     R4,DUMPDATA             DO THE INDIRECT\n         N     R4,=X'7FFFFFFF'         TURN OFF TOP BIT ALWAYS\nNOTIND   BAL   R15,FWDSUB              UPDATE HISTORY POINTR\n         LH    R2,CURRENT              NEW HIST TABLE POINTER\n         A     R2,HISTORY              GET ENTRY ADDRESS\n         USING HIST,R2\n         ST    R4,HISTADDR             SAVE NEW ADDRESS\n         XC    HISTCBHP,HISTCBHP          AND\n         XC    HISTCBSP,HISTCBSP            CLEAR\n         XC    HISTSADR,HISTSADR               REST\n         B     FORMAT\n         DROP  R2\nBADIND   MVC   MSGLINE,BADIMSG         MOVE IN MESSAGE\n         B     FORMAT                  GO AND REDISPLAY\n         SPACE 2\n* SCAN INPUT FOR A NAME IN THE SYMBOL TABLE\nNAMESCAN LA    R3,1(,R3)               SKIP OVER COMMA\n         LR    R1,R3                   COPY INPUT POINTER\n         LA    R15,9                   MAX LENGTH +1\nNAMELOOP CLI   0(R1),C'A'              SEE IF VALID CHAR\n         BL    NAMEEND                 BR IF NOT, DELIM FOUND\n         LA    R1,1(,R1)               POINT TO NEXT BYTE\n         BCT   R15,NAMELOOP            ALLOW EIGHT BYTES PLUS DELIM\nNAMEBAD  MVC   MSGLINE,NAMEMSG         NULL NAME OR NAME TOO LONG\n         B     FORMAT2                 DISPLAY WITH CURSOR AT ERROR\nNAMEEND  SR    R1,R3                   FIND LENGTH\n         BZ    BADSTUFF                BR IF TOO SHORT\n         MVC   TEMP1(8),=CL8' '        CLEA\u00a2  WORK AREA\n         BCTR  R1,0                    SET UP FOR EX\n         EX    R1,NAMEMOVE             MOVE TO WORK AREA, BLANK PAD\n         LA    R3,1(R3,R1)             UPDATE POINTER\n         LA    R15,50                  ENTRIES IN SYM TABLE\n         LA    R1,NAMES                START OF SYM TABLE\nNAMELP2  CLC   TEMP1(8),0(R1)          SEE IF NAME IN TABLE\n         BE    NAMEFIND                BR IF YES\n         LA    R1,12(,R1)              POINT TO NEXT ENTRY\n         BCT   R15,NAMELP2             BR IF ANY ENTRIES LEFT\n         B     NAMEBAD                 BR IF NONE LEFT, UNDEFUNED SYM\nNAMEFIND L     R2,8(,R1)               GET SYMBOL VALUE\n         B     NUMDELIM                USE IN EXPRESSION\n*  THESE INSTRUCTIONS ARE THE OBJECT OF AN EXECUTE\nOPER     LR    R4,R2                   USE HIST TABLE AS DEFAULT INPUT\n         AR    R4,R2                   PLUS OPERATOR\n         SR    R4,R2                   MINUS OPERATOR\nHEXMOVE  MVC   0(0,R15),0(R6)          RIGHT JUSTIFY INPUT DATA\nNAMEMOVE MVC   TEMP1(1),0(R3)          PAD NAME WITH BLANKS BY MOVING\n         SPACE\nBADSTUFF MVC   MSGLINE,ERRMSG          NOTE BAD INPUT\n         B     FORMAT2                 DISPLAY WITH CURSOR AT ERROR\n         SPACE 2\n***********************************************************************\n*\n*  PROGRAM CHECK EXIT\n*\n***********************************************************************\n         SPACE 2\n         DROP  R9,R11\n         USING *,R15               SET TEMP BASE\nEREXIT   DS    0H                  ESTAE EXIT\n         C     R0,=F'12'\n         BER   R14                 SKIP IF NOT SDWA\n         STM   R14,R12,12(R13)     SAVE REGISTERS\n         LR    R4,R1               SAVE ADDR OF SDWA\n         USING SDWA,R4             SAVE ADDR\n         L     R10,SDWAPARM        GET PARM LIST\n         LR    R12,R15             SAVE BASE REGISTER\n         DROP  R15\n         USING EREXIT,R12\nER200    L     R11,BASE2           GET FIRST BASE\n         L     R9,BASE1            GET SECOND BASE\n         USING LOOK,R11,R9         RESET BASE\n         TM    FLAGS,GETINPG           IS A GETSTOR IN PROGRESS\n         BZ    SPIEOTR                 NOPE OTHER ERROR\n         L     R8,CSAWORK          SETUP REG 8\n         USING WORK,R8                 IF FROM GETSTOR THEN R8 POINTS\n*                                      TO WORK\n         TM    FLAG1,FG1MOVE           ARE WE IN MOVE INSTR\n         BZ    SPIEOTR                 NOPE\n         MVC   MERRCD,SDWAICD1         SAVE INT CODE                1.1\n         CLI   SDWAICD1,X'04'          PROTECTION??\n         BNE   ER250                   IF NOT THEN TRY OTHERS\n*        IF PROTECTION THEN DATA TO POINT OF ERROR\n*        HAS BEEN MOVED SO JUST ADJUST LENGTH\n         L     R2,LENGTH\n         S     R2,SDWAGR01             GET LENGTH NOT MOVED\n         ST    R2,LENGTH               SAVE MOVED LENGTH\n         B     ER300                   ALL DONE\n*        IF ADDRESSING EXCEPTION THEN\n*        REGISTERS NOT ALWAYS UPDATED (PER POPS)\n*        BUT THE TRANSLATION ADDR IS CLOSE.\n*        ALSO NO DATA MAY HAVE BEEN MOVED.\n*        (WE ARE DEALING HERE WITH WHAT MAY BE \"MODEL DEPENDENT\"\n*        FEATURES)\nER250    DS    0H\n         L     R2,SDWATRAN             GET BAD ADDRESS\n         S     R2,ADDR                 LESS START ADDR\n         LTR   R2,R2                   ANY GOOD LENGTH\n         BM    ER300                   NOPE                         1.1\n         C     R2,LENGTH               MAKE SURE IT IS REASONABLE\n         BH    ER300                   SKIP IF NOT\n         ST    R2,LENGTH               SAVE AS GOTTEN LENGTH\n         LTR   R2,R2                   ANY LENGTH AT ALL            1.1\n         BZ    ER300                   NO - SO SKIP MOVE            1.1\n         LR    R3,R2                   SETUP LENGTH\n         LR    R7,R2\n         L     R2,ADDR                 GET FROM ADDR\n         LA    R6,BUF                  GET TO ADDRESS\n         MVCL  R6,R2\nER300    MVC   ESRUB,=X'0074'     FLAG TO RESET REGS\n         LR    R1,R4               RESET SDWA POINTER\n         SETRP REGS=(14,12),DUMP=NO,RC=4,RETADDR=GOTBACK,              X\n               RETREGS=YES,RUB=ESRUB,FRESDWA=YES,RECORD=NO\n         DROP  R8,R4\n*PIEOTR  MVC   MSGLINE,PCMSG           TELL USER OF PC\n*        B     ER300                   SET RETURN FROM GETSTOR\nSPIEOTR  DS    0H\n         LR    R1,R4                   RESTORE SDWA REG\n         SETRP REGS=(14,12),DUMP=NO,RC=0,RECORD=NO\n         DROP  R12\n         SPACE 2\n*----------------------------------------------------------------------\n*\n* ERASE  --  CLEAR THE SCREEN BUFFER\n*\n*----------------------------------------------------------------------\n         SPACE 2\nERASE    SAVE  (2,5)                   NEED SOME WORK REGS\n         LA    R2,OUT1                 START OF AREA TO CLEAR\n         LA    R3,80*16                LENGTH TO CLEAR\n         LA    R5,C' '                 FILL CHAR\n         SLL   R5,24                   MAKE PAD BYTE AND CLEAR SOURCE\n         MVCL  R2,R4                   PROPAGATE BLANKS\n         RETURN (2,5)                  RESTORE REGS AND RETURN\n         EJECT\n* EXECUTED INSTRUCTIONS AND CONSTANTS\nCLEARMVC MVC   0(0,R6),BLANKS          CLEAR SOME SPACE\nMOVEMVC  MVC   0(0,R15),1(R15)         MOVE DATA BACKWARDS\n***********************************************************************\n*\n*\n*        FETCH SOME STORAGE\n*\n*              R0  =  LENGTH TO FETCH <=4096 (MAXFETCH)\n*              R1  => WHERE TO PUT IT\n*              R2  => WHERE TO GET IT FROM\n*\n*\n***********************************************************************\nGETSTOR  SAVE  (14,8)                  SAVE REGS\n         L     R8,CSAWORK              POINT TO CSA AREA            1.1\n         USING WORK,R8                 SETUP ADDRESSABILITY         1.1\n         MVI   MERRCD,0                INDICATE NO ERROR ON FETCH   1.1\n         LA    R2,0(0,R2)              clear top bit               1.1D\n         CL    R0,=A(MAXFETCH)         Max fetchable size          1.1D\n         BL    *+8                     Requested ok                1.1D\n         L     R0,=A(MAXFETCH)         Force smaller               1.1D\n*\n*        CHECK IF DATA IS IN BUFFER\n*\n         CLC   CSAASID,CURASID         WANT SAME ASID\n         BNE   GETMORE                 NOPE\n         C     R2,CSASTAR              CHECK FOR BEGINNING\n         BL    GETMORE\n         LR    R15,R0                  GET LENGTH\n         AR    R15,R2                  GET END ADDRESS\n         C     R15,CSAEND              CHECK FOR END\n         BH    GETMORE                 NOPE NOT IN BUFFER\n         TM    FLAGS,RFRSH             IS IT REFRESH REQUEST\n         BO    GETMORE                 REGET THE CORE\nMOVEBUF  L     R15,CSASTAR             GET VIRT ADDR OF BUFFER\n         SR    R2,R15                  GET DISPLACEMENT IN BUFFER\n         A     R2,CSABUF               POINT TO BUFFER\n         LR    R3,R0                   MOVE LENGTH\n         LR    R0,R1                   SET \"TO\" ADDR\n         LR    R1,R3                   SET LENGTH\n         MVCL  R0,R2\n         LM    R14,R8,12(R13)          RESTORE REGS                 1.1\n         B     8(R14)                  RETURN ALL GOTTEN\nGETMORE  DS    0H\n         MVC   LENGTH,=F'2048'         Initial fetch is half page  1.1C\n         C     R0,LENGTH               Is req for more than default1.1D\n         BNH   *+8                     No  so skip                 1.1D\n         ST    R0,LENGTH               Set first request for actual1.1D\n         ST    R2,ADDR                 SAVE ADDR TO GET CORE FROM  1.1C\n         ST    R2,CSASTAR              SET CSA VIRT BUFFER ADDR    1.1C\n         NI    FLAGS,255-REFETCH       inidicate first fetch       1.1C\nGETM2    DS    0H                                                  1.1C\n         MVI   MERRCD,0                INDICATE NO ERROR ON FETCH  1.1C\n         NI    FLAGS,255-RFRSH         TURN OFF FLAG\n         MVC   CSAASID,CURASID         SET ASID OF CSABUFFER CONTENTS\n         MVI   FLAG1,0                 CLEAR FLAGS\n         MVI   FLAG2,0\n         CLC   CURASID,MYASID          ARE WE IN THIS ADDR SPACE\n         BNE   DOSRB                   IF NOT USE SRB\n*\n*        INVOKE SRB CODE AS SUBROUTINE\n*\n         OI    FLAG1,FG1SUBR           FLAG AS SUBROUTINE\n         LA    R1,DMYPRMS              SETUP DUMMY FRR PARMS\n         ST    R1,FRRPRMS\n         TM    FLAGS,NOAUTH            ARE WE AUTHORIZIED          1.1E\n         BO    DOSUB1                  NO SO SKIP                  1.1E\n         MODESET KEY=ZERO              GET TO KEY ZERO             1.1E\nDOSUB1   DS    0H                                                  1.1E\n         XC    DMYPRMS,DMYPRMS\n         LR    R1,R8                   SETUP PARM REGISTER\n         LA    R15,D#SRBCD             SETUP ENTRY REGISTER\n         LA    R14,GOTBKSUB            SETUP RETURN REGISTER       1.1E\n         OI    FLAGS,GETINPG           FLAG GETSTOR IN PROGRESS\n         BR    R15                     GO TO IT\nGOTBKSUB TM    FLAGS,NOAUTH            ARE WE AUTHORIZIED          1.1E\n         BO    GOTBACK                 NO SO SKIP                  1.1E\n         MODESET KEY=NZERO             GET TO TCB KEY              1.1E\n         B     GOTBACK                 CONTINUE                    1.1E\n*\n*        IF AUTHORIZED FOR SRB MODE ...\n*\nDOSRB    TM    FLAGS,NOAUTH            ARE WE AUTHORIZED\n         BO    FAIL2                   NOPE\n*\n*        VALIDATE ASID ...\n*\n         L     R2,CVTPTR               POINT TO CVT\n         LH    R1,CSAASID              GET ASID\n         L     R2,CVTASVT-CVTMAP(,R2)  POINT TO ASVT\n         USING ASVT,R2                 SETUP ADDRESSABILITY\n         C     R1,ASVTMAXU             IS IT TOO BIG\n         BH    FAIL3                   SET INVALID ASID\n         SLL   R1,2                    ASID*4\n         LA    R1,ASVTENTY-4(R1)       POINT AT DESIRED ENTRY\n         MVC   TOASCB,0(R1)            SAVE ASCB ADDR\n         TM    TOASCB,ASVTAVAL         IS THIS ASCB EXISTENT\n         BO    FAIL3                   NOPE\n         LA    R3,SRBAREA     POINT AT THE SRB\n         DROP  R2\n         L     R2,TOASCB               GET ASCB ADDR\n         USING ASCB,R2                 SETUP ADDRESSABILITY\n         TM    ASCBRCTF,ASCBOUT        IS ASCB SWPPED OUT\n         BO    FAIL3                   YES SO DONOT TRY TO TOUCH IT\n         DROP  R2\n*\n*        INITIALIZE THE SRB AND INVOKE AS SRB\n*\n         USING SRBSECT,R3\n         XC    SRBAREA,SRBAREA  CLEAR THE SRB\n         MVC   SRBID,=C'SRB '  SET EBCDIC ID\n         MVC   SRBASCB,TOASCB SET ASCB ADDR TO RUN IN\n         AIF   (&XA).XA2                                            1.1\n         LA    R1,SRBCCD      POINT AT SRB CODE IN CSA        SP    1.1\n         AGO   .NXA2                                                1.1\n.XA2     ANOP                                                       1.1\n         BASR  R0,0           GET ADDRESSING MODE              XA   1.1\n         N     R0,=X'80000000'  LEAV ONLY ADDRESSING MODE      XA   1.1\n         LA    R1,SRBCCD      POINT AT SRB CODE IN CSA         XA   1.1\n         OR    R1,R0          PUT ADDRESSING MODE IN           XA   1.1\n.NXA2    ANOP                                                       1.1\n         ST    R1,SRBEP       SAVE ENTRY POINT\n         ST    R8,SRBPARM     SAVE PARM ADDR AS WORK AREA\n         LA    R1,D#RMTR-D#SRBCD(,R1) GET RESOURCE MGR TERMINATION\n         OR    R1,R0\n         ST    R1,SRBRMTR     AND SAVE IT\n         XC    ECB,ECB                 CLEAR THE ECBS FOR THE WAITLIST\n         XC    ECB2,ECB2\n         LA    R0,ECB\n         LA    R1,ECB2\n         STM   R0,R1,ECBLIST\n         MVI   ECBLIST+4,X'80'\n*\n*        NOW ISSUE TIMER INCASE SRB NEVER POSTS US\n*\n         STIMER REAL,D#STX,BINTVL==A(300)  WAIT 3 SECONDS\n         MODESET KEY=ZERO\n         SCHEDULE SRB=(R3),SCOPE=GLOBAL ISSUE SRB\n         MODESET KEY=NZERO\n         L     R2,=C'ABCD'             SET KEY IN REG\n         LA    R3,ECB2                 AND ADDR TO POST IN STIMER\n         WAIT  ECBLIST=ECBLIST\n         TTIMER CANCEL\n*\n*        WE ARE BACK FROM EITHER TIMER OR SRB OR SUB\n*\nGOTBACK  L     R8,CSAWORK              POINT AT CSA AREA\n         NI    FLAGS,255-GETINPG       TURN OFF GET IN PROGRESS\n         TM    FLAG1,FG1SUBR           IS THIS A SUB CALL\n         BO    GOTBK2                  IF SO IGNORE SOME ERRORS\n         TM    FLAG1,FG1SRDN           DID SRB TERMINATE GOOD\n         BZ    FAIL                    NOPE SO ERROR MSG\n         TM    FLAG2,FG2PSTR+FG2PURG+FG2ERRR AN ERRORS\n         BNZ   FAIL                    IF SO ERROR MESSAGE\nGOTBK2   DS    0H\n*\n*        NOW MOVE INFO OUT OF CSA BUFFER\n*\n         L     R2,12+12(,R13)          GET ORIG R1 INTO R2 (DEST ADDR)\n         L     R3,12+8(,R13)           GET DESIRED LENGTH\n         L     R4,CSABUF               POINT TO BUFFER\n         L     R5,LENGTH               GET ACTUAL LENGTH MOVED\n         LTR   R5,R5                   Did any memory get back     1.1C\n         BNZ   GOTBK4                  If so then use it           1.1C\n         C     R3,=F'2048'             Was original req >= default 1.1C\n         BNL   GOTBK4                  If so then cant get it      1.1C\n         TM    FLAGS,REFETCH           Q. Is this first or sec ent 1.1C\n         BO    GOTBK4                  A. Second, return no data   1.1C\n         OI    FLAGS,REFETCH           First entry so indicate     1.1C\n         ST    R3,LENGTH               Retry with orig req         1.1C\n         B     GETM2                                               1.1C\nGOTBK4   DS    0H                                                  1.1C\n         NI    FLAGS,255-REFETCH       reset flag before return    1.1C\n*\n*        NOTE THAT ORIG(R2) IS EFFECTIVELY AT R4\n*        FIRST BYTE DESIRED IS FIRST BYTE IN BUFFER\n*\n         MVCL  R2,R4                   MOVE IN CORE\n         L     R2,CSASTAR              GET START LOC\n         A     R2,LENGTH               PLUS LENGTH MOVED\n         ST    R2,CSAEND               SET CORRECT END ADDR\n         MVC   LOGOOD,CSASTAR          SET LOW RANGE DISPLAYABLE\n         MVC   HIGOOD,CSAEND           AND HIGH RANGE\n         MVC   12+12(4,R13),LENGTH     SET GOTTEN LENGTH\n*                                                                   1.1\n*        SET MESSAGE LINE TO INDICATE HOW SUCCESSFUL                1.1\n*        THE MEMORY FETCH WAS                                       1.1\n*                                                                   1.1\n         CLI   MERRCD,4                IS THIS PROTECTION ERROR    1.1A\n         BNE   GOTBK3A                 NO SO CHECK OTHERS          1.1A\n         MVC   MSGLINE,PROT            MOVE IN PROTECTION MSG      1.1A\n         B     GOTBK3                  ERROR SET                   1.1A\nGOTBK3A  DS    0H                                                  1.1A\n         CLI   MERRCD,X'11'            IS THIS A PAGE FAULT        1.1A\n         BE    GOTBK3B                 YES                         1.1A\n         CLI   MERRCD,X'10'            IS THIS A SEGMENT FAULT     1.1A\n         BNE   GOTBK3                  NO                          1.1A\nGOTBK3B  MVC   MSGLINE,NONEX           SET PAGE FAULT ERROR        1.1A\nGOTBK3   DS    0H                                                   1.1\n         LM    R14,R8,12(R13)          RESTORE REGS\n         LTR   R1,R1                   ANY LENGTH GOTTEN\n         BZR   R14                     IF NOT THEN EXIT +0\n         CR    R0,R1                   ALL DESIRED GOTTEN\n         BH    4(R14)                  IF NOT ALL THEN +4\n         B     8(R14)                  ALL DESIRED GOTTEN THEN +8\n*\n*        IF ANY ERRORS GIVE ERROR MSG AND RETURN +0\n*\nFAIL     DS    0H\n         DC    H'0'\n         MVC   MSGLINE,SRBMSG          MOVE IN MESSAGE\n         MVC   CURRENT+2(2),FLAG1\n         B     FAILALL                 GO TO COMMON ROUTINE\n*\n*        IF NOT AUTHORIZED TO DISPLAY OTHER ASIDS GIVE MSG AND RESET\n*\nFAIL2    DS    0H\n         MVC   MSGLINE,AUTHMSG         MOVE IN MESSAGE\n         B     FAILALL                 GO TO COMMON ROUTINE\n*\n*        IF ASID IS NOT VALID OR SWAPPED OUT GIVE MSG AND RESET\n*\nFAIL3    DS    0H\n         MVC   MSGLINE,BDASMSG         MOVE IN MESSAGE\nFAILALL  DS    0H                      COMMON FAILURE ROUTINE\n         MVC   CSASTAR,=F'0'           CLEAR THE START\n         MVC   CSAEND,=F'0'              AND END ADDR\n         MVC   CSAASID,=H'0'               AND THE ASID\n         MVC   CURASID,MYASID          RESET ASID AVAIL\n         RETURN (14,8)\n*\n*        STIMER EXIT ROUTINE\n*        ITS PURPOSE IS TO POST THE ECB AT ECB2 AND WAKE UP THE\n*        LOOK PROCESSOR IF THE SRB FAILS.  TO DO THIS WE MUST\n*        FIND THE ADDRESS OF THE ECB WHICH IS SAVED IN R3 OF\n*        THE RB ABOVE THE WAIT.  IN THAT RB, R2 IS SET TO 'ABCD'.\n*\n         USING *,R12\nD#STX    SAVE  (14,12)                 SAVE REGISTERS\n         LR    R12,R15                 SET BASE REG\n         L     R3,CVTPTR               POINT AT CVT\n         L     R3,0(,R3)               POINT AT TCB WORDS\n         L     R3,0(,R3)               POINT AT MY TCB\n         L     R3,0(,R3)               POINT AT MY RB\n         USING RBBASIC,R3\nD#STX1   DS    0H                      NOW LOOK FOR KEY IN REG2\n         CLC   RBGRS2,=C'ABCD'         IS THE KEY HERE\n         BE    D#STX2                  YES\n         TM    XSTAB2,RBTCBNXT         TEST TCB FLAG\n         BO    D#STX3                  IF NOT FOUND PROPER RB\n         L     R3,RBLINK               POINT AT PREVIOUS RB\n         B     D#STX1\nD#STX2   L     R2,RBGRS3               GET ADDR OF ECB TO POST\n         POST  (R2)                    WAKE UP LOOK\n         RETURN (14,12)\n*\n*        IF WE CANT FIND THE RB THEN DUMP\n*\nD#STX3   DC    H'0'\n         DROP  R12,R3\n         LTORG\n         TITLE 'LOOK --  STORAGE ALTER/DISPLAY - SRB MODE CODE'\n         DROP  R9\nD#SRBCD  DS    0D\n*\n*        THIS CODE PERFORMS THE FOLLOWING FUNCTIONS\n*              1 ESTABLISHES AN FRR FOR ERROR RECOVERY\n*              2 VERIFIES THAT THE ADDRESSES THAT ARE NEEDED DO\n*                EXIST.\n*              3 PERFORM THE MODIFICATION IF ALLOW AND NECESSARY\n*              4 SAVE THE PROPER CORE FOR DUMPING.\n*              5 CROSS-MEMORY POST THE MAIN COMMAND PROCESSOR\n*\n         USING WORK,R8\n         USING D#SRBCD,R7\n         LR    R8,R1          SET THE MAIN PARM DSECT\n         LR    R7,R15         SET THE BASE REGISTER\n         ST    R14,ASRBRTN    SAVE RETURN ADDR\n         TM    FLAG1,FG1SUBR  IS THIS A SUBROUTINE CALL\n         BO    D#SRB1         YES SO SKIP FRR\n         LA    R5,D#FRRCD     POINT AT FRR CODE\n         SETFRR  A,FRRAD=(R5),WRKREGS=(2,3),PARMAD=(R4)\n         ST    R4,FRRPRMS     SAVE ADDR OF FRRPRMS\n*\n*        NOW INIT THE FRR PARM AREA AND VALIDATE THE INPUT ADDR\n*\nD#SRB1   L     R2,FRRPRMS     ACCESS THE 6 WORK PARM AREA\n         STM   R7,R8,0(R2)    SAVE BASE AND WORK REGS\n*\n*        MOVE MEMORY\n*\n         L     R2,ADDR                 SET START ADDR\n         LA    R0,BUF                  POINT AT BUFFER\n         L     R1,LENGTH               GET DESIRED LENGTH\n         LR    R3,R1                   SET LENGTH\n         OI    FLAG1,FG1MOVE           INDICATE IN MOVE\n         MVCL  R0,R2                   MOVE IN CORE\n         NI    FLAG1,255-FG1MOVE       NOTE NOT IN MOVE\n*\n*        NOW WE TERMINATE PROCESSING BY DOING A CROSS\n*        MEMORY POST IF NOT IN SUBROUTINE MODE\n*\nFRRRTY   TM    FLAG1,FG1SUBR  IS THIS SUBROUTINE MODE\n         BO    D#EXIT         IF SO THEN EXIT\n         SETFRR  D,WRKREGS=(2,3)\nFRRPOST  L     R10,=A(X'40000000') SET CODE FOR POST\n         LR    R9,R8          SAVE WORK POINTER IN SAFE REG\n         LA    R11,ECB        ADDR OF ECB TO POST\n         ICM   R11,8,=X'80'   FLAG AS XMPOST\n         LA    R12,D#POSTR    SET POST ERROR RETURN\n         L     R13,MYASCB     ASCB TO POST\n         L     R15,CVTPTR     POINT AT CVT\n         L     R15,CVT0PT01-CVTMAP(R15)    GET POST ENTRY POINTR\n         BALR  R14,R15        GO DO POST\n         DROP  R7             KILL MAIN ADDRESS\n         USING *,R14          SET TEMP BASE\nD#PRTN   LR    R8,R9          RESET BASE OF WORK\n         SL    R14,=A(D#PRTN-D#SRBCD)  NOW HAVE CORRECTED BASE\n         LR    R7,R14         SET TO PROPER REG\n         DROP  R14\n         USING D#SRBCD,R7     RESET MAIN BASE\n         OI    FLAG1,FG1SRDN  FLAG SRB AS COMPLETED\nD#EXIT   L     R14,ASRBRTN    RESTORE RETURN ADDR\n         BR    R14            EXIT\n         SPACE 5\n*\n*        POST ERROR ROUTINE  .. FLAG ERROR AND LET TIMER\n*        WAKE UP TASK\n*\nD#POSTR  LR    R8,R9          RESET WORK BASE\n         OI    FLAG2,FG2PSTR  FLAG POST ERROR\n         BR    R14            RETURN TO D#PRTN\n         TITLE 'LOOK --  STORAGE ALTER/DISPLAY - FRR FOR SRB'\nD#FRRCD  DS    0D\n         L     R2,0(,R1)      POINT AT PARM AREA\n         LM    R7,R8,0(R2)    SET BASE REGS\n         TM    FLAG1,FG1MOVE  ARE WE IN VALIDATION\n         BZ    D#FRR1         NOPE\n*\n*        MOVE INCOMPLETE\n*\n         NI    FLAG1,255-FG1MOVE       TURN OFF FLAG\n         MVC   MERRCD,SDWAICD1-SDWA(R1) SAVE INT CODE               1.1\n         CLI   SDWAICD1-SDWA(R1),X'04' PROTECTION??\n         BNE   D#FRR0A                 IF NOT THEN TRY OTHERS\n*        IF PROTECTION THEN DATA TO POINT OF ERROR\n*        HAS BEEN MOVED SO JUST ADJUST LENGTH\n         L     R2,LENGTH\n         S     R2,SDWAGR01-SDWA(R1)    GET LENGTH NOT MOVED\n         ST    R2,LENGTH               SAVE MOVED LENGTH\n         B     D#FRR0                  ALL DONE\n*        IF ADDRESSING EXCEPTION THEN\n*        REGISTERS NOT ALWAYS UPDATED (PER POPS)\n*        BUT THE TRANSLATION ADDR IS CLOSE.\n*        ALSO NO DATA MAY HAVE BEEN MOVED.\n*        (WE ARE DEALING HERE WITH WHAT MAY BE \"MODEL DEPENDENT\"\n*        FEATURES)\nD#FRR0A  DS    0H\n         L     R2,SDWATRAN-SDWA(,R1)   GET BAD ADDRESS\n         S     R2,ADDR                 LESS START ADDR\n         LTR   R2,R2                   ANY GOOD LENGTH\n         BM    D#FRR0                  NOPE                         1.1\n         C     R2,LENGTH               MAKE SURE IT IS REASONABLE\n         BH    D#FRR0                  SKIP IF NOT\n         ST    R2,LENGTH               SAVE AS GOTTEN LENGTH\n         LTR   R2,R2                   ANY LENGTH AT ALL            1.1\n         BZ    D#FRR0                  NO - SO SKIP MOVE            1.1\n         LR    R3,R2                   SETUP LENGTH\n         LR    R5,R2                                               1.1C\n         L     R2,ADDR                 GET FROM ADDR\n         LA    R4,BUF                  GET TO ADDRESS              1.1C\n         MVCL  R4,R2                                               1.1C\nD#FRR0   OI    FLAG2,FG2IVLD  SET FLAG FOR MESSAGE\n         SETRP RECORD=NO,RC=4,RETADDR=FRRRTY,REGS,DUMP=NO,             X\n               RETREGS=YES,FRESDWA=YES\n         BR    R14            EXIT\n         SPACE 5\n*\n*        ALL OTHER ERRORS\n*\nD#FRR1   OI    FLAG2,FG2ERRR  SET FLAG FOR MESSAGES\n         SETRP RECORD=YES,RC=4,RETADDR=FRRRTY,REGS,DUMP=YES,           X\n               RETREGS=YES,FRESDWA=YES\n         BR    R14            EXIT\n         TITLE 'LOOK --  STORAGE ALTER/DISPLAY - RESOURCE MGR. CLEANUP'\n*\n*        THIS ROUTINE RECEIVES CONTROL IF THE SRB MUST BE\n*        PURGED.\n*\nD#RMTR   DS    0H\n         USING *,R15\n         LR    R7,R15         SET BASE REGISTER\n         SL    R7,=A(D#RMTR-D#SRBCD)   BY COMPUTATION\n         DROP  R15\n         USING D#SRBCD,R7\n         LR    R8,R2          SET UP POINTER TO WORK\n         ST    R14,ASRBRTN    SAVE RETURN ADDR\n         OI    FLAG2,FG2PURG  SET PURGED\n         B     FRRPOST        GO AND POST TO CLEAN UP\n         LTORG\nENDSRB   DS    0H\nSRBCODE  EQU   *-D#SRBCD               LENGTH OF SRB CODE\n         TITLE 'LOOK --  STORAGE ALTER/DISPLAY - MESSAGES, CONSTANTS'\nKEY1 DC CL80'1= HELP      2=           3= END        4=           5= REX\n               PEAT  6=          '\nKEY2 DC CL80'7= BACKWARD  8= FORWARD   9= HIST BWD  10= HIST FWD 11=   X\n                    12=          '\n* ERROR MESSAGE FOR BAD INPUT\nTITLE    DC    CL79' '\nMODEMSG  DC    CL79'***** INVALID MODE'\nINVALOP  DC    CL79'***** INVALID OPERATOR'\nSYMFULL  DC    CL79'***** SYMBOL TABLE IS FULL'\nNAMEMSG  DC    CL79'***** UNDEFINED SYMBOL'\nDEFMSG   DC    CL79'***** NULL SYMBOL OR SYMBOL TOO LONG'\nPCMSG    DC    CL79'***** PROGRAM CHECK'\nLINKMSG  DC    CL79'***** LINK FAILED'\nSRBMSG   DC    CL79'***** SRB DATA FETCH FAILED'\nAUTHMSG  DC    CL79'***** LOOK NOT CURRENTLY AUTHORIZED. REQUEST DENIEDX\n               .'\nBDASMSG  DC    CL79'***** ASID INVALID OR SWAPPED OUT.'\nBADIMSG  DC    CL79'***** INDIRECT FAILED.'\nASIDFMT  DC    CL13'DISPLAY ASID='\nERRMSG   DC    CL79'INVALID ADDRESS -- TRY AGAIN'\nPROT     DC    CL79'--- PART/ALL OF REQUESTED MEMORY FETCH PROTECTED' 1\nNONEX    DC    CL79'--- PART/ALL OF REQUEST MEMORY NON-EXISTENT'    1.1\nBLANKS   DC    CL79' '\n         EJECT\nHEXTAB   DC    256C' '                 GENERAL HEX CONVERSION TABLE\n         ORG   HEXTAB+C'A'             INPUT CONVERSION\n         DC    X'0A0B0C0D0E0F'\n         ORG   HEXTAB+C'0'             OUTPUT CONVERSION\n         DC    C'0123456789ABCDEF'\n         ORG\n* HEX INPUT TRT TABLE\nNUMTAB   DC    256X'1'\n         ORG   NUMTAB+C'A'\n         DC    6X'0'\n         ORG   NUMTAB+C'0'\n         DC    10X'0'\n         ORG\nVALCHAR  DC    256C'.'                 TRANSLATE TO VALID CHARS\n         ORG   VALCHAR+C' '\n         DC    C' '\n         ORG   VALCHAR+C'\u00a2'\n         DC    C'\u00a2.<(+|&&'\n         ORG   VALCHAR+C'!'\n         DC    C'!$*);\u00ac-/'\n         ORG   VALCHAR+C','\n         DC    C',%_.?'\n         ORG   VALCHAR+C':'\n         DC    C':#@''=\"'\n         ORG   VALCHAR+C'a'\n         DC    C'abcdefghi'\n         ORG   VALCHAR+C'j'\n         DC    C'jklmnopqr'\n         ORG   VALCHAR+C's'\n         DC    C'stuvwxyz'\n         ORG   VALCHAR+C'A'\n         DC    C'ABCDEFGHI'\n         ORG   VALCHAR+C'J'\n         DC    C'JKLMNOPQR'\n         ORG   VALCHAR+C'S'\n         DC    C'STUVWXYZ'\n         ORG   VALCHAR+C'0'\n         DC    C'0123456789'\n         ORG\n         LTORG\n         SPACE 2\n*        SCREEN DEFINITION AREA\nQDINIT   DS    0D             START OS DISPLAY WORK AREA\n         DC    F'0'           ORIG SCREEN DEPTH\n         DC    F'0'           ORIG SCREEN LINESZ\n         DC    H'80'          LENGTH OF DISPLAY LINE\n         DC    PL2'21'        LINES PER SCREEN\n         DS    0D\n         DS    0CL69\n         DC    CL6' '\n         DC    CL63' '\n         DC    CL63' '        CORRECTED DATA FROM SCREEN\n         DS    0C             DISPLAY SCREEN\n         DC    X'27'          CONTROL\n         DC    X'F5'          ERASE/WRITE\n         DC    X'C1115D7F1140403C404000' CLEAR SCREEN\n         DC    CL43'LOOK COMMAND - DISPLAY VIRTUAL MEMORY' TITLE L 1.1D\n         DC    CL13'DISPLAY ASID='\n         DC    X'1DC8'        MARK NEXT FIELD AS INPUT FIELD\n         DC    CL4' '         IN/OUT FOR ASID\n         DC    X'1DF0'        TERMINATE INPUT FIELD\n         DC    X'11'          SET BUFFER ADDRESS\n         DC    X'C150'        (2,1)\n         DC    C'ENTER CMD -'     REPLY PROMPT\n         DC    X'1DC8'        MARK NEXT FIELD AS INPUT FIELD\n         DC    X'13'          SET CURSOR ADDRESS\n         DC    X'11'          SET BUFFER ADDRESS\n         DC    X'C25B'        (2,76)\n         DC    X'1DF0'        TERMINATE INPUT FIELD\n         DC    X'11'          SET BUFFER ADDRESS\n         DC    X'C260'        (3,1)\n         DC    C'LAST CMD  - '\n         DC    CL63' '        PREVIOUS COMMAND\n         DC    X'11'          SET BUFFER ADDRESS\n         DC    X'C3F0'        (4,1)\n         DC    CL79' '\n         DC    C' '\n         DC    16CL80' '      MESSAGE TEXT AREA\n         DC    2CL80' '\n         DC    2CL80' '       PFK DISPLAY AREA\nHELPMSG  DS    0H\n DC CL80'LOOK is a real time core display and formatting program. It alX\n               so has the        '\n DC CL80'capability of displaying memory in any address space (if authoX\n               rized).           '\n DC CL80'                                                              X\n                                 '\n DC CL80'The valid commands are:                                       X\n                                 '\n DC CL80'Iexp  24 bit indirect                 | Jexp  31 bit indirect X\n                                 '\n DC CL80'>     Forward                         | <     Backward        X\n                                 '\n DC CL80'=sym  Define current address as \"sym\" | ,sym  Redisplay core aX\n               t \"sym\"           '\n DC CL80'M0/M1 Flip between top and center     | Lname Indirect thru coX\n               ntrol block field '\n DC CL80'Ocb   Format as \"cb\" control block    | R     Refresh displayeX\n               d storage         '\n DC CL80'      \"cb\" may be NULL to show as hex |                       X\n                                 '\n DC CL80'                                                              X\n                                 '\n DC CL80'where ''exp'' is of the form:                                 X\n                                   '\n DC CL80'    <+/->hhhh<+/-hhhh<+/-hhhh...>>                            X\n                                 '\n DC CL80'and ''hhhh'' is a 1 to 8 digit hex number.                    X\n                                   '\n DC CL80'                                                              X\n                                 '\n DC CL80'                                                              X\n                                 '\n         TITLE 'LOOK --  STORAGE ALTER/DISPLAY - WORK AREAS, DSECTS'\n*----------------------------------------------------------------------\n*\n* HIST -- HISTORY ENTRY FOR ONE OR MORE PREVIOUS ENTRIES\n*\n*----------------------------------------------------------------------\n         SPACE 2\nHIST     DSECT\nHISTADDR DS    A                       ADDR OF STORAGE/MAIN CB ADDRES\nHISTCBHP DS    A                       0 IF NO CB\n*                                      X'7FFFFFFF' IF OVERLAY NULL\n*                                      ADDR OF CBH IF CB DISPLAYED\nHISTCBSP DS    A                       ADDR OF CBS DISPLAYED\nHISTSADR DS    A                       ADDR OF STORAGE FOR THIS SEG\nHISTLEN  EQU   *-HIST                  LENGTH OF ENTRY\n         SPACE 5\n*----------------------------------------------------------------------\n*\n* CBH  -- CONTROL BLOCK HEADER  -  ONE FOR EACH DIFFERENT CONTROL BLK\n*\n*----------------------------------------------------------------------\n         SPACE 2\nCBH      DSECT\nCBHNEXT  DS    A                       ADDR OF NEXT CONTROL BLOCK OR 0\nCBHVOFF  DS    A                       OFFSET OF VALIDATION FIELD\nCBHCBSP  DS    A                       ADDR OF FIRST SEG DESCIPTOR\nCBHNAME  DS    CL8                     NAME OF BLOCK\nCBHVLEN  DS    X                       LENGTH OF VALIDATION FIELD\nCBHVAL   DS    0X                      VALIDATION DATA\n         SPACE 5\n*----------------------------------------------------------------------\n*\n* CBS  -- CONTROL BLOCK SEGMENT\n*\n*----------------------------------------------------------------------\n         SPACE 2\nCBS      DSECT\nCBSPREV  DS    A                       ADDRESS OF PREVIOUS SEGMENT\nCBSNEXT  DS    A                       ADDRESS OF NEXT SEGMENT\nCBSDLEN  DS    AL2                     LENGTH OF DATA TO FETCH\nCBSDOFF  DS    AL2                     OFFSET OF DATA TO FETCH\nCBSILEN  DS    AL2                     LENGTH OF INDIRECT TO FETCH\nCBSIOFF  DS    AL2                     OFFSET OF INDIRECT TO FETCH\nCBSLEN   EQU   *-CBS                   LENGTH OF SEGMENT HEADER\n         SPACE 5\n*----------------------------------------------------------------------\n*\n* CBF  -- CONTROL BLOCK FIELD\n*\n*----------------------------------------------------------------------\n         SPACE 2\nCBF      DSECT\nCBFNAME  DS    CL8                     NAME OF FIELD\nCBFTYPE  DS    CL1                     TYPE OF NAME\nCBFDLEN  DS    XL1                     LENGTH OF DATA TO DISPLAY\nCBFOFFS  DS    H                       OFFSET INTO BLOCK START\nCBFLINE  DS    H                       LINE NUMBER TO PUT ON\nCBFCOLM  DS    H                       COLUMN TO START IN\nCBFLEN   EQU   *-CBF\n         EJECT\n*----------------------------------------------------------------------\n*\n*   MAIN DYNAMIC WORK AREA\n*\n*----------------------------------------------------------------------\nWORKAREA DSECT\nSAVE     DS    18F\nHISTORY  DS    F                       HISTORY TABLE ADDRESS\nNAMES    DS    150F                    SYMBOL TABLE\nCURRENT  DS    H                       HIST TABLE OFFSET\nESTAE    ESTAE 1,PARAM=0,MF=L      ROOM FOR ESTAE PARM LIST\n         DS    0F,H                SPACER\nESRUB    DS    H                   BIT INDICATOR SHOULD BE X'0074'\nBASE1    DS    F                   SECOND BASE REG (R9)\nBASR10   DS    F                   NORMAL R10\nBASE2    DS    F                   FIRST BASE REG (R11)\nBASR13   DS    F                   NORMAL R13\nTEMP1    DS    CL9                     CONVERSION WORK AREA\nTEMP2    DS    CL9                     CONVERSION WORK AREA\nLOGOOD   DC    F'0'\nHIGOOD   DC    XL4'FFFFF123'\nCSALEN   DS    F                       SP AND LEN OF CSA WORK AREA\nCSAWORK  DS    A                       ADDRESS OF CSA WORKAREA\nCSABUF   DS    A                       ADDRESS OF CSA DATA BUFFER FOR\n*                                      SRB\nCSASTAR  DS    A                       USERS ADDR OF BEGINNING OF\n*                                      BUFFER DATA\nCSAEND   DS    A                       USERS ADDR OF END OF BUFFER DATA\nCSAASID  DS    H                       USERS ASID FOR BUFFER DATA\nMYASID   DS    H                       DCMS ASID\nCURASID  DS    H                       DISPLAYED CORE ASID\nSAVEASID DS    CL4                     FORMATED VERSION OF CURASID\nFLAGS    DS    X                       ASSORTED FLAGS\nINDFLAG  EQU   X'80'                   INDIRECT IN PROGRESS\nNOAUTH   EQU   X'40'                   IF ON THEN NOT AUTHORIZED\nGETINPG  EQU   X'20'                   ON IF GETSTOR IN PROGRESS (SUBR)\nRFRSH    EQU   X'10'                   ON TO REFRESH CSA BUFFER\nIND31    EQU   X'08'                   31 BIT INDIRECT IN PROGRESS\nREFETCH  EQU   X'04'                   First get failed and retry  1.1C\nMODEFLAG DS    X                       USER OPTION FLAGS\nMIDDUMP  EQU   X'80'                   ON TO FORCE DISPLAY BACK 8 LINES\nALIGN    EQU   X'40'                   ON TO ALIGN DUMP ON QUADWORD\n         SPACE 2\n*        SCREEN DEFINITION AREA\nQDISPLAY DS    0D             START OS DISPLAY WORK AREA\nQDOSZR0  DC    F'0'           ORIG SCREEN DEPTH\nQDOSZR1  DC    F'0'           ORIG SCREEN LINESZ\nQDLNELEN DC    H'80'          LENGTH OF DISPLAY LINE\nQDLNES   DC    PL2'21'        LINES PER SCREEN\n         DS    0D\nPFREPLY  DS    0CL69\nPFCODE   DC    CL6' '\nPFTXT    DC    CL63' '\nINPLINE  DC    CL63' '        CORRECTED DATA FROM SCREEN\nQDSCREEN DS    0C             DISPLAY SCREEN\n         DC    X'27'          CONTROL\n         DC    X'F5'          ERASE/WRITE\n         DC    X'C1115D7F1140403C404000' CLEAR SCREEN\n         DC    CL43'LOOK COMMAND - DISPLAY VIRTUAL MEMORY' TITLE L 1.1D\nASIDLN   DC    CL13'DISPLAY ASID='\n         DC    X'1DC8'        MARK NEXT FIELD AS INPUT FIELD\nASIDLN1  DC    CL4' '         IN/OUT FOR ASID\n         DC    X'1DF0'        TERMINATE INPUT FIELD\n         DC    X'11'          SET BUFFER ADDRESS\n         DC    X'C150'        (2,1)\n         DC    C'ENTER CMD -'     REPLY PROMPT\n         DC    X'1DC8'        MARK NEXT FIELD AS INPUT FIELD\n         DC    X'13'          SET CURSOR ADDRESS\n         DC    X'11'          SET BUFFER ADDRESS\n         DC    X'C25B'        (2,76)\n         DC    X'1DF0'        TERMINATE INPUT FIELD\n         DC    X'11'          SET BUFFER ADDRESS\n         DC    X'C260'        (3,1)\n         DC    C'LAST CMD  - '\nINPSAVE  DC    CL63' '        PREVIOUS COMMAND\n         DC    X'11'          SET BUFFER ADDRESS\n         DC    X'C3F0'        (4,1)\nMSGLINE  DC    CL79' '\n         DC    C' '\nOUT1     DC    16CL80' '      MESSAGE TEXT AREA\nOUT9     EQU   OUT1+(8*80)\n         DC    2CL80' '\nKEYS     DC    2CL80' '       PFK DISPLAY AREA\nQDISPLN  EQU   *-QDISPLAY     LENGTH OF ENTIRE DISPLAY\nQDSLNG   EQU   *-QDSCREEN     LENGTH OF SCREEN BUFFER\n*\n**       AREA TO HOLD DATA RETURNED BY GETSTOR\n*\nDUMPDATA DS    XL(MAXFETCH)            DATA RETURNED BY GETSTOR\nWORKLEN  EQU   *-WORKAREA\n         EJECT\n         PRINT NOGEN\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n*        END\n         IHAASCB\n         IHAASVT\n         IHAFRRS\n         IHAPSA\n         IHASDWA\n         IHASRB\n         IHARB\n         CVT   DSECT=YES\n         EJECT\n*\n*        CSA AREA WORK AREA\n*\nWORK     DSECT\nWORKSTRT DS    0D\nDOUBLE   DS    2F\nDMYPRMS  DS    6F             DUMMY AREA FOR FRR PARMS FOR SUBR MODE\nFRRPRMS  DS    F              ADDRESS OF 6 WORD FRR PARM\nASRBRTN  DS    F              RETURN ADDR FOR SRB CODE\nMYASCB   DS    F              ASCB ADDR OF MAIN ROUTINE\nMYTCB    DS    F              TCB ADDRESS FOR MAIN ROUTINE\nTOASCB   DS    F              ASCB ADDR OF SRB ROUTINE\nECB      DS    F              ECB FOR MAIN ROUTINE TO WAIT ON\nECB2     DS    F              ECB FOR STIMER TO POST\nECBLIST  DS    2F\nLENGTH   DS    F              LENGTH OF STORAGE TO DUMP\nSRBAREA  DS    ((SRBSIZE+3)/4)F  THE SRB ITSELF\nADDR     DS    F              ADDRESS TO PROCESS AT\nASID     DS    H              ASID OF TOASCB\nFLAG1    DS    X\nFG1DUMP  EQU   X'80'\nFG1REP   EQU   X'40'\nFG1MOVE  EQU   X'20'                   IF ON DOING MVCL FOR DATA\nFG1SRDN  EQU   X'02'          IF ON SRB HAS TERMINATED\nFG1SUBR  EQU   X'01'\nFLAG2    DS    X\nFG2NVER  EQU   X'01'          VERIFICATION FAILED\nFG2IVLD  EQU   X'02'          VALIDATION FAILED\nFG2ERRR  EQU   X'04'          DISASTER OCCURED IN SRB\nFG2PURG  EQU   X'08'          SRB WAS PURGED\nFG2PSTR  EQU   X'10'          IF ON THEN SRB POST HAD ERROR\nMERRCD   DS    X                       INTERRUPT CODE               1.1\nSRBCCD   DS    0D                      ALIGN SRB CODE ON DBL WORD\n         DS    (SRBCODE)X\n         DS    0D                      ALIGN BUFFER\nBUF      DS    (MAXFETCH)X\nWORKLN   EQU   *-WORKSTRT\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LOOK02$": {"ttr": 9990, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x12\\x00W\\x01\\x00\\x17O\\x01\\x185\\x1f\\x01!\\x00#\\x00\\x1f\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.18", "flags": 0, "createdate": "2000-06-22T00:00:00", "modifydate": "2018-12-17T01:21:57", "lines": 35, "newlines": 31, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//* ------------------------------------------- *//\n//*        ASM LINKEDIT FROM SOURCE ASM         *//\n//*                                             *//\n//*    --  STANDARD ASSEMBLY OF OLD LOOK  --    *//\n//* ------------------------------------------- *//\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,FLAG(5))\n//SYSLIB   DD DISP=SHR,DSN=SBGOLOB.CBT497.FILE264  ==> EXTRA MACROS\n//*        DD DISP=SHR,DSN=SBGOLOB.LOOK.INSTALL    ==> ALTERED IBM MACR\n//         DD DISP=SHR,DSN=SYS1.MACLIB,UNIT=3390\n//         DD DISP=SHR,DSN=SYS1.MODGEN,UNIT=3390\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.CBT497.FILE264(LOOK02)   PREVIOUS\n//         DD DISP=SHR,DSN=SBGOLOB.CBT497.FILE264(CBMACS)\n//*        DD DISP=SHR,DSN=SBGOLOB.CBT497.FILE264(CBMACSE)    ==> PLAY\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(CYL,2),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n ENTRY   LOOK\n INCLUDE OBJECT\n SETSSI  CB497264\n SETCODE AC(1)\n NAME    LOOKX(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PROLOGUE": {"ttr": 9992, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\t\\x00y\\x17/\\x01\\x19\\x04?\\x14V\\x02P\\x02P\\x00\\x0b\\xd9\\xc9\\xc3\\xd2@@@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1979-06-21T00:00:00", "modifydate": "2019-02-12T14:56:09", "lines": 592, "newlines": 592, "modlines": 11, "user": "RICK"}, "text": "         MACRO\n&LABEL   PROLOGUE  &COMMENT,&SAVEREG=12(13),                           X\n               &USING=*,&ID=*,&REPA=15,&BASEREG=12,                    X\n               &TRACE=NO,&OUTPUT=PUT,                                  X\n               &SAVE=R13PLUS18F,&FORECHN=YES,&BACKCHN=YES,             X\n               &EXBASE=,                                               X\n               &DATE=68060\n.**********************************************************************\n.*                                                                    *\n.*       PROLOGUE GENERATES A STANDARD LINKAGE HEADER FOR SUBROUTINES.*\n.*       WHEN USED TO FULL CAPABILITY, IT WILL GENERATE STATEMENTS TO *\n.*       ASSIGN A BASE REGISTER TO THE SUBROUTINE,                    *\n.*       SAVE THE REGISTERS OF THE CALLING PROGRAM,                   *\n.*       TRACE THE SUBROUTINE EXECUTION ON THE OPERATOR CONSOLE OR    *\n.*       ON AN OUTPUT DATA SET OR BOTH,                               *\n.*       OBTAIN A SAVE AREA, EITHER BY INCREMENTING REGISTER 13,      *\n.*       USING A SAVE AREA WHOSE NAME IS SUPPLIED TO PROLOGUE,        *\n.*       GENERATING AN AREA INLINE, OR ISSUING A GETMAIN,             *\n.*       SET UP REGISTER 13 TO CONTAIN THE ADDRESS OF THAT SAVE AREA  *\n.*       FOR LOWER LEVEL SUBROUTINES TO USE FOR SAVING REGISTERS,     *\n.*       FORWARD CHAIN THE SAVE AREA ADDRESSES,                       *\n.*       AND BACK CHAIN THE SAVE AREA ADDRESSES.                      *\n.*                                                                    *\n.*                                                                    *\n.*       &COMMENT             THE POSITIONAL OPERAND &COMMENT INSURES *\n.*                            THAT THE USE OF PROLOGUE IN THE FORM -- *\n.*                                                                    *\n.*                            LABEL PROLOGUE ERROR-GENERATING-COMMENT *\n.*                                                                    *\n.*                            DOES NOT GENERATE INVALID KEYWORD       *\n.*                            ASSEMBLY ERRORS.                        *\n.*                                                                    *\n.*       &USING=*             OR SYMBOL OR OTHER LOCATION COUNTER     *\n.*                            REFERENCE.  OPERAND OF USING STATEMENT. *\n.*                            IF USING=0 IS SPECIFIED, NO USING       *\n.*                            STATEMENT IS GENERATED.                 *\n.*                                                                    *\n.*       &SAVEREG=12(13)      OR SYMBOL OR NO.  UNLESS SAVEREG=NO,    *\n.*                            THE REGISTERS ARE STORED WITH A         *\n.*                                                                    *\n.*                                     STM   14,12,&SAVEREG           *\n.*                                                                    *\n.*                            IF SAVEREG=NO, THE REGISTERS ARE NOT    *\n.*                            SAVED AND ALL OTHER PARAMETERS EXCEPT   *\n.*                            &USING AND &BASEREG ARE IGNORED.        *\n.*                                                                    *\n.*       &ID=*                OR SYMBOL.  IDENTIFIER.                 *\n.*                            IF ID=*, THEN THE IDENTIFIER IS &LABEL  *\n.*                            UNLESS &LABEL IS NULL, IN WHICH CASE    *\n.*                            THE IDENTIFIER IS &SYSECT, THE CURRENT  *\n.*                            CSECT NAME UNLESS &SYSECT IS NULL, IN   *\n.*                            WHICH CASE THE IDENTIFIER IS 'ID ERROR'.*\n.*                            IF &ID IS NOT '*', THEN &ID ITSELF      *\n.*                            IS THE IDENTIFIER.                      *\n.*                            THE IDENTIFIER DETERMINED BY &ID IS     *\n.*                            USED AS FOLLOWS --                      *\n.*                            1.  THE SAVE IDENTIFIER CONSISTS OF     *\n.*                            THE IDENTIFIER DETERMINED BY &ID, CON-  *\n.*                            CATENATED WITH A PERIOD, CONCATENATED   *\n.*                            &DATE, UNLESS DATE=NO, IN WHICH CASE    *\n.*                            BOTH THE PERIOD AND &DATE ARE OMITTED.  *\n.*                            2. THE TRACE IDENTIFIER CONSISTS OF THE *\n.*                            IDENTIFIER DETERMINED BY &ID UP TO THE  *\n.*                            FIRST 126 CHARACTERS, THE LENGTH OF THE *\n.*                            LINE ON THE CONSOLE TYPEWRITER.         *\n.*                                                                    *\n.*       &REPA=15             OR SYMBOL OR NUMBER.  REGISTER WHICH IS *\n.*                            ASSUMED TO CONTAIN THE ADDRESS OF THE   *\n.*                            FIRST INSTRUCTION GENERATED BY PROLOGUE.*\n.*                            OS/360 CONVENTION IS 15, BUT ANY OTHER  *\n.*                            REGISTER CAN BE USED, FOR EXAMPLE --    *\n.*                                  BALR  11,0                        *\n.*                                  PROLOGUE REPA=11                  *\n.*                                                                    *\n.*       &BASEREG=12          OR SYMBOL OR NUMBER.  BASE REGISTER TO  *\n.*                            BE USED.  DEFAULT BASE REGISTER IS 12.  *\n.*                            THE BASE REGISTER IS LOADED BY          *\n.*                                                                    *\n.*                                      LR   &BASEREG,15              *\n.*                                                                    *\n.*                            WHICH IS GENERATED UNLESS BASEREG=15.   *\n.*                                                                    *\n.*       &TRACE=NO            OR YES.                                 *\n.*                                                                    *\n.*                            IF TRACE=NO, NO TRACE CODE IS GENERATED.*\n.*                                                                    *\n.*                            IF TRACE=YES, TRACE CODE IS GENERATED   *\n.*                            TO WRITE OUT A MESSAGE ON THE DEVICE(S) *\n.*                            DETERMINED BY &OUTPUT.                  *\n.*                            THE MESSAGE TEXT IS THE IDENTIFIER      *\n.*                            DETERMINED BY &ID.                      *\n.*                                                                    *\n.*                            IF THE BINARY GLOBAL &PTRACE IS SET TO  *\n.*                            1, THEN TRACE=NO IS SUPERSEDED AND      *\n.*                            CODE IS GENERATED AS IF TRACE=YES.      *\n.*                                                                    *\n.*                            IF NEITHER YES OR NO, YES IS ASSUMED,   *\n.*                            BUT AN ERROR COMMENT IS GENERATED.      *\n.*                                                                    *\n.*       &SAVE=R13PLUS18F     OR GETMAIN, OR INLINE, OR NONE.         *\n.*                            IF NONE OF THESE, &SAVE IS ASSUMED TO BE*\n.*                            THE NAME OF A USER SUPPLIED SAVE AREA.  *\n.*                                                                    *\n.*                            IF SAVE=R13PLUS18F, THE SAVE AREA IS    *\n.*                            ASSUMED TO BE 18 FULL WORDS PAST THE    *\n.*                            SAVE AREA POINTED TO BY REGISTER 13.    *\n.*                                                                    *\n.*                            IF SAVE=INLINE, THERE ARE TWO FORMS --  *\n.*                            SAVE=INLINE, OR                         *\n.*                            SAVE=(INLINE,LENGTH,NAME)               *\n.*                            WHERE EITHER LENGTH OR NAME MAY         *\n.*                            OPTIONALLY BE OMITTED.                  *\n.*                            IF LENGTH IS A NUMBER OR A SYMBOL, IT   *\n.*                            IS ASSUMED TO BE THE SAVE AREA LENGTH   *\n.*                            IN BYTES.                               *\n.*                            LENGTH MAY ALSO BE A NUMBER IMMEDIATELY *\n.*                            FOLLOWED (WITH NO INTERVENING BLANKS) BY*\n.*                            ONE OF THE LETTERS D,F,H,C, OR X,       *\n.*                            SIGNIFYING DOUBLEWORDS, FULLWORDS,      *\n.*                            HALFWORDS, OR BYTES RESPECTIVELY.       *\n.*                            SYMBOLIC LENGTHS MUST NOT END IN D, F,  *\n.*                            H, C, OR X.                             *\n.*                            SYMBOLIC LENGTHS MAY NOT EXCEED         *\n.*                            EIGHT CHARACTERS.                       *\n.*                            IF LENGTH IS OMITTED, 18F IS ASSUMED.   *\n.*                            IF NAME IS OMITTED, SAVE&SYSNDX IS      *\n.*                            ASSUMED.                                *\n.*                            AN AREA WITH THE CORRECT LENGTH AND NAME*\n.*                            IS GENERATED INLINE AND BRANCHED AROUND.*\n.*                                                                    *\n.*                            IF SAVE=GETMAIN, THERE ARE TWO FORMS -- *\n.*                            SAVE=GETMAIN, OR                        *\n.*                            SAVE=(GETMAIN,LENGTH,SANAME,NOMARK)     *\n.*                            WHERE LENGTH, SANAME, OR THE WORD       *\n.*                            NOMARK MAY OPTIONALLY BE OMITTED.       *\n.*                            THE INTERPRETATIONS OF LENGTH AND       *\n.*                            SANAME ARE THE SAME AS FOR SAVE=INLINE. *\n.*                            THE GLOBAL &SGBYTES IS SET TO THE       *\n.*                            NUMBER OF BYTES OBTAINED BY THE GETMAIN,*\n.*                            SO THAT THE EPILOGUE MACRO, IF INVOKED  *\n.*                            WITH SAVE=FREEMAIN, WILL FREE THE       *\n.*                            CORRECT AMOUNT.                         *\n.*                            THE BINARY GLOBAL &NLE4095 IS SET IF    *\n.*                            &SGBYTES IS KNOWN TO BE LESS THAN OR    *\n.*                            EQUAL TO 4095 BYTES.                    *\n.*                            PROLOGUE LEAVES &SGBYTES AND &NLE4095   *\n.*                            UNCHANGED UNLESS SAVE=GETMAIN.          *\n.*                            SAVE=GETMAIN IMPLIES BACKCHN=YES SO     *\n.*                            THAT EPILOGUE WILL BE ABLE TO FIND      *\n.*                            AND FREE THE SAVE AREA CORRECTLY.       *\n.*                            NORMALLY, UNLESS THE WORD 'NOMARK' IS   *\n.*                            INCLUDED AS THE FOURTH POSITIONAL SUB-  *\n.*                            PARAMETER OF &SAVE, CODE IS GENERATED   *\n.*                            TO STORE A 'G' INTO THE HIGH ORDER BYTE *\n.*                            OF THE FORWARD CHAIN ADDRESS (WORD 2)   *\n.*                            OF THE SAVE AREA OBTAINED WITH THE      *\n.*                            GETMAIN, THUS MARKING THE SAVE  AREA AS *\n.*                            HAVING BEEN OBTAINED WITH A GETMAIN.    .\n.*                            IF THE EPILOGUE MACRO IS USED TO        *\n.*                            GENERATE THE RETURN LINKAGE WITH        *\n.*                            SAVE=FREEMAIN, IT WILL GENERATE CODE TO *\n.*                            CHECK FOR THE 'G' AND NOT ISSUE THE     *\n.*                            FREEMAIN IF THE 'G' IS NOT THERE.       *\n.*                            IF PROLOGUE IS USED WITH                *\n.*                            SAVE=(GETMAIN,,NOMARK), THEN THE        *\n.*                            CORRESPONDING EPILOGUE SHOULD BE USED   *\n.*                            WITH SAVE=(FREEMAIN,,NOCHECK), IN WHICH *\n.*                            CASE EPILOGUE WILL NOT GENERATE CODE TO *\n.*                            CHECK FOR A 'G' AND WILL ALWAYS DO THE  *\n.*                            FREEMAIN.  THE NOMARK FORM OF PROLOGUE  *\n.*                            AND THE NOCHECK FORM OF EPILOGUE SHOULD *\n.*                            ONLY BE USED IN CASES WHERE THE         *\n.*                            PROGRAMMER IS SURE THAT THE NUMBER OF   *\n.*                            GETMAINS AND FREEMAINS WILL BE THE SAME.*\n.*                                                                    *\n.*                                                                    *\n.*                            IF NONE, NO SAVE AREA IS GENERATED AND  *\n.*                            USER IS RESPONSIBLE FOR SETTING UP      *\n.*                            REGISTER 13.  THE &FORECHN AND &BACKCHN *\n.*                            PARAMETERS ARE IGNORED.                 *\n.*                                                                    *\n.*       &FORECHN=YES         OR NO.                                  *\n.*                            IF FORECHN=YES, THE ADDRESS OF THE      *\n.*                            SAVE AREA OF THE CALLING PROGRAM IS     *\n.*                            STORED INTO WORD 2 OF THE SAVE AREA OF  *\n.*                            THIS PROGRAM.                           *\n.*                            IF FORECHN=NO, NO FORWARD CHAINING CODE *\n.*                            IS GENERATED.                           *\n.*                            IF NEITHER YES OR NO, NO IS ASSUMED,    *\n.*                            BUT AN ERROR COMMENT IS GENERATED.      *\n.*                                                                    *\n.*       &BACKCHN=YES         OR NO.                                  *\n.*                            IF BACKCHN=YES, THE ADDRESS OF THE      *\n.*                            SAVE AREA OF THIS PROGRAM IS STORED     *\n.*                            INTO WORD 3 OF THE SAVE AREA OF THE     *\n.*                            CALLING PROGRAM.                        *\n.*                            IF BACKCHN=NO, NO CODE IS GENERATED TO  *\n.*                            BACKCHAIN  (PUT THE ADDRESS OF THE SAVE *\n.*                            AREA OF THIS PROGRAM INTO WORD 3 OF THE *\n.*                            SAVE AREA OF THE CALLING PROGRAM).      *\n.*                            IF NEITHER YES OR NO, NO IS ASSUMED,    *\n.*                            BUT AN ERROR COMMENT IS GENERATED.      *\n.*                                                                    *\n.*       &DATE=               DATE TO BE CONCATENATED ONTO THE NORMAL *\n.*                            SAVE IDENTIFIER UNLESS DATE=NONE.       *\n.*                            &DATE IS NOT CONCATENATED ONTO THE      *\n.*                            TRACE MESSAGE.                          *\n.*                                                                    *\n.**********************************************************************\n.*\n.*\n.*\n.**********************************************************************\n.*                                                                    *\n.*       DECLARATIONS                                                 *\n.*                                                                    *\n.**********************************************************************\n         GBLB  &PTRACE        IF SET, OVERRIDES TRACE=NO, CAUSING TRACE\n         GBLB  &NLE4095       SET IF &SBYTES IS KNOWN TO BE LE 4095\n         GBLC  &SGBYTES       GETMAIN SAVE AREA LENGTH -- FOR FREEMAIN\n         LCLA  &I,&J          TEMPORARY NUMERIC VARIABLE\n         LCLA  &#SCHRS        NUMBER OF CHARACTERS IN SAVE ID\n         LCLB  &SLE4095       INTERNAL VARIABLE LIKE &NLE4095\n         LCLA  &#IDCHRS       NUMBER OF CHRS IN &ID OR &IDSTAR\n         LCLC  &IDSTAR        IF ID=* THEN LABEL UNLESS '' THEN &SYSECT\n         LCLC  &FILL          SEPARATOR BETWEEN ID AND DATE\n         LCLC  &SAVNAME       SAVEAREA NAME.\n         LCLC  &SNUMBER       NUMERIC PART OF LENGTH\n         LCLC  &LP,&RP        LEFT AND RIGHT PARAMTHESES FOR &SNUMBER\n         LCLC  &SUNIT         UNIT    PART OF LENGTH\n         LCLC  &MULT          NUMERIC EQUIVALENT OF &SUNIT\n         LCLC  &SBYTES        NUMBER OF BYTES IN SAVE AREA -- SYMBOLIC\n         LCLC  &RTEMP         TEMPORARY REGISTER USED FOR BACK CHAINING\n         LCLC  &OFFSET        SAVE AREA OFFSET TO RESTORE &RTEMP\n         LCLC  &PLIFLAG       HIGH BYTE OF PL/I WORD IN DSA\n         SPACE 3\n***********************************************************************\n*        PROLOGUE GENERATES A STANDARD HEADER FOR A SUBROUTINE.       *\n***********************************************************************\n.*\n.*\n.*\n.**********************************************************************\n.*                                                                    *\n.*       SET UP &RTEMP                                                *\n.*                                                                    *\n.**********************************************************************\n         AIF   ('&BASEREG' NE '15').RTEMP15\n&RTEMP   SETC  '14'\n&OFFSET  SETC  '12'\n         AGO   .RTEMPOK\n.RTEMP15 ANOP\n&RTEMP   SETC  '15'\n&OFFSET  SETC  '16'\n.RTEMPOK ANOP\n.**********************************************************************\n.*                                                                    *\n.*       SET UP SAVE AND TRACE IDENTIFIER PARAMETERS                  *\n.*                                                                    *\n.**********************************************************************\n&#IDCHRS SETA  1\n         AIF   ('&ID' NE '*').ID\n         AIF   ('&LABEL' EQ '').USECS\n&IDSTAR  SETC  '&LABEL'\n         AGO   .GETKID\n.USECS   AIF   ('&SYSECT' EQ '').IDERR\n&IDSTAR  SETC  '&SYSECT'\n         AGO   .GETKID\n.IDERR   ANOP\n&IDSTAR  SETC  'ID ERROR'\n.GETKID  AIF   ('&IDSTAR'(1,&#IDCHRS) EQ '&IDSTAR').KIDOK\n&#IDCHRS SETA  &#IDCHRS+1\n         AGO   .GETKID\n.ID      ANOP\n&#IDCHRS SETA  K'&ID\n.KIDOK   ANOP\n&#SCHRS  SETA  &#IDCHRS\n         AIF   ('&DATE' EQ 'NONE').DATEOK\n&FILL    SETC  '.'\n&#SCHRS  SETA  &#IDCHRS+K'&DATE+1\n.DATEOK  ANOP\n.**********************************************************************\n.*                                                                    *\n.*       GET SAVE AREA NAME                                           *\n.*                                                                    *\n.**********************************************************************\n         AIF   ('&SAVE(1)' EQ 'R13PLUS18F').NAME72\n         AIF   ('&SAVE(1)' EQ 'INLINE').NAMEIN\n&SAVNAME SETC  '&SAVE(1)'    SET &SAVNAME, THE NAME OF THE SAVE AREA.\n         AGO   .NAMEOK\n.NAME72  ANOP\n&SAVNAME SETC  '72(0,13)'\n         AGO   .NAMEOK\n.NAMEIN  AIF   ('&SAVE(3)' EQ '').NAMENDX\n&SAVNAME SETC  '&SAVE(3)'     SET SAVE AREA NAME\n         AGO   .NAMEOK\n.NAMENDX ANOP\n&SAVNAME SETC  'SAVE&SYSNDX'  UNIQUE SAVE AREA NAME.\n.NAMEOK  ANOP\n.**********************************************************************\n.*                                                                    *\n.*       GET SAVE AREA LENGTH FOR SAVE=INLINE, GETMAIN, OR DSA        *\n.*                                                                    *\n.**********************************************************************\n         AIF   ('&SAVE(1)' EQ  'INLINE').SETVALS SET PARAMETER VALUES\n         AIF   ('&SAVE(1)' EQ 'GETMAIN').SETVALS SET PARAMETER VALUES\n         AIF   ('&SAVE(1)' EQ     'DSA').SETVALS SET PARAMETER VALUES\n         AGO   .SAVEOK        NO NEED TO LOOK AT SAVE SUB-PARAMETERS\n.SETVALS ANOP                 GET SAVE SUB-PARAMETER VALUES\n&SBYTES  SETC   '&SAVE(2)'    GET SAVE AREA LENGTH\n         AIF   ('&SBYTES' EQ '').DEFAULT\n         AIF   (T'&SAVE(2) EQ 'N').BYTES  IF NUMERIC, ASSUME BYTES\n&I       SETA  K'&SAVE(2)     GET NUMBER OF CHARACTERS IN LENGTH\n&SNUMBER SETC  '&SBYTES'(1,&I-1)        GET PURE NUMERIC PART OF LENGTH\n&SUNIT   SETC  '&SBYTES'(&I,1)          GET UNIT CHARACTER -- D,F,H,C,X\n&I       SETA  1\n.GETUNIT AIF   ('&SUNIT' EQ 'DFHCX'(&I,1)).MULT\n&I       SETA  &I+1\n         AIF   (&I LE 5).GETUNIT ELSE MUST BE SYMBOLIC SAVE AREA LENGTH\n&LP      SETC  '('\n&SNUMBER SETC  '&SAVE(2)'\n&RP      SETC  ')'\n.BYTES   ANOP\n&SUNIT   SETC  'C'\n         AGO   .LOK\n.MULT    ANOP\n&MULT    SETC  '84211'(&I,1)  GET MULTIPLIER CORRESPONDING TO UNIT\n&I       SETA  &SNUMBER*&MULT\n&SLE4095 SETB  (&I LE 4095)\n&SBYTES  SETC  '&I'\n         AGO   .LOK\n.DEFAULT ANOP\n         AIF   ('&SAVE(1)' NE 'DSA').L72\n&SBYTES  SETC  '88'\n&SLE4095 SETB  1\n         AGO   .LOK\n.L72     ANOP\n&SBYTES  SETC  '72'\n&SNUMBER SETC  '18'\n&SLE4095 SETB  1\n&SUNIT   SETC  'F'\n.LOK     ANOP\n.SAVEOK  ANOP\n         AIF   ('&SAVE(1)' NE 'DSA').PLIFOK\n&PLIFLAG SETC  '&SAVE(4)'\n         AIF   ('&PLIFLAG' NE '').PLIFOK\n&PLIFLAG SETC  'X''80'''\n.PLIFOK  ANOP\n.**********************************************************************\n.*                                                                    *\n.*       USING                                                        *\n.*                                                                    *\n.**********************************************************************\n         AIF   ('&USING' EQ '0').NOUSING\n         USING &USING,&BASEREG !          USE A BASE REGISTER.\n         AIF   (T'&EXBASE EQ 'O').NOUSING\n         AIF   ('&EXBASE'(1,1) EQ '(').USGMA\n         USING &USING+4096,&EXBASE\n         AGO   .NOUSING\n.USGMA   ANOP\n&J       SETA  4096\n&I       SETA  1\n.USGM    ANOP\n         USING &USING+&J,&EXBASE(&I)\n&J       SETA  &J+4096\n&I       SETA  &I+1\n         AIF   (N'&EXBASE GE &I).USGM\n.NOUSING ANOP\n&LABEL   DS    0H\n.**********************************************************************\n.*                                                                    *\n.*       SAVE REGISTERS                                               *\n.*                                                                    *\n.**********************************************************************\n         AIF   ('&SAVEREG' NE 'NO').RSAVE\n***********************************************************************\n*        REGISTERS WERE NOT SAVED IN CALLING PROGRAM SAVE AREA.       *\n***********************************************************************\n         AGO   .ENDPROL\n.RSAVE   ANOP\n&I       SETA  &#SCHRS+5      OFFSET FROM B TO STM\n&I       SETA  ((&I+1)/2)*2   ROUND UP TO HALFWORD ALIGNMENT\n         AIF   ('&USING' EQ '*').BRANCH\n         AIF   ('&USING' EQ '0').BRANCH\n         B     *-(&USING)+&I.(0,&REPA) BRANCH AROUND IDENTIFIER\n         AGO   .BROK\n.BRANCH  B     &I.(0,&REPA) !   BRANCH AROUND IDENTIFIER\n.BROK    DC    AL1(&#SCHRS) !       IDENTIFIER LENGTH\n         AIF   ('&ID' EQ '*').IDSTARS\n         AIF   ('&DATE' EQ 'NONE').MAC001                          6060\n         DC    C'&ID&FILL&DATE' ! IDENTIFIER\n         AGO   .SAVE\n.MAC001  DC    C'&ID'         IDENTIFIER                           6060\n         AGO   .SAVE                                               6060\n.IDSTARS AIF   ('&DATE' EQ 'NONE').MAC002                          6060\n         DC    C'&IDSTAR&FILL&DATE'  IDENTIFIER                    6060\n         AGO   .SAVE                                               6060\n.MAC002  DC    C'&IDSTAR'     IDENTIFIER                           6060\n.SAVE    STM   14,12,&SAVEREG !  SAVE REGISTERS\n.**********************************************************************\n.*                                                                    *\n.*       LOAD BASE REGISTER                                           *\n.*                                                                    *\n.**********************************************************************\n         AIF   ('&BASEREG' EQ '&REPA').NOLOAD\n         LR    &BASEREG,&REPA !         SET UP THE BASE REGISTER.\n         AGO   .BRSETUP\n.NOLOAD  ANOP\n*        BASE REGISTER IS ALREADY SET UP.  NO LR GENERATED.\n.BRSETUP ANOP\n         AIF   (T'&EXBASE EQ 'O').MBASE\n         AIF   ('&EXBASE'(1,1) EQ '(').MLTP\n         LA    &EXBASE,2048(&BASEREG)\n         LA    &EXBASE,2048(&EXBASE)\n         AGO   .MBASE\n.MLTP    ANOP\n&I       SETA  1\n         LA    &EXBASE(1),2048(&BASEREG)\n         LA    &EXBASE(1),2048(&EXBASE(1))\n.MULLP   ANOP\n&I       SETA  &I+1\n         AIF   (N'&EXBASE LT &I).MBASE\n         LA    &EXBASE(&I),2048(&EXBASE(&I-1))\n         LA    &EXBASE(&I),2048(&EXBASE(&I))\n         AGO   .MULLP\n.MBASE   ANOP\n.**********************************************************************\n.*                                                                    *\n.*       GENERATE TRACE CODE                                          *\n.*                                                                    *\n.**********************************************************************\n         AIF   ('&TRACE' NE 'YES' AND NOT &PTRACE).NOTRACE\n&I       SETA  &#IDCHRS+8     GET OFFSET FROM BAL TO IWT SVC\n&I       SETA  ((&I+1)/2)*2   ROUND UP TO HALFWORD ALIGNMENT\n         CNOP  0,4 !           ALIGN PARAMETER LIST\n         BAL   1,*+&I !        BRANCH AROUND PARAMETER LIST\n&#IDCHRS SETA  &#IDCHRS+4     ADD 4 FOR FULLWORD PRECEDING THE MESSAGE\n         AIF   (&#IDCHRS LE 130).#CHRSOK\n&#IDCHRS SETA  130\n.#CHRSOK DC    AL2(&#IDCHRS) !        LENGTH OF PARAMETER LIST\n         DC    AL2(0)\n&#IDCHRS SETA  &#IDCHRS-4     RESTORE # OF ID CHRS TO TRUE VALUE\n         AIF   ('&ID' EQ '*').IDSTART\n         DC    CL&#IDCHRS'&ID' ! MESSAGE\n         AGO   .MESSOK\n.IDSTART DC    CL&#IDCHRS'&IDSTAR' ! MESSAGE\n.MESSOK  SVC   35 !            ISSUE WRITE TO OPERATOR SVC\n         AIF   ('&SAVE(1)' EQ 'GETMAIN').NOLM NO RESTORE IF OTHER SVC\n         AIF   ('&SAVE(1)' EQ     'DSA').NOLM NO RESTORE IF OTHER SVC\n         LM    14,1,12(13) !   RESTORE REGISTERS 14 TO 1 WHICH MAY BE\n*                              DESTROYED BY THE TRACE, FROM SAVE AREA\n.NOLM    ANOP\n.NOTRACE ANOP\n.**********************************************************************\n.*                                                                    *\n.*       SET UP SAVE AREA                                             *\n.*                                                                    *\n.**********************************************************************\n         AIF   ('&SAVE'    EQ    'NONE').NOSAVE\n         AIF   ('&SAVE(1)' EQ 'GETMAIN').GETMAIN\n         AIF   ('&SAVE(1)' EQ     'DSA').GETMAIN\n         AIF   ('&FORECHN' NE 'YES' AND '&BACKCHN' NE 'YES').NOCHAIN\n         LR    &RTEMP,13 !         SAVE ADDRESS OF CALLER'S SAVE AREA\n.NOCHAIN LA    13,&SAVNAME !   LOAD REGISTER 13 WITH SAVE AREA ADDRESS\n         AIF   ('&FORECHN' NE 'YES').NOFORE\n         ST    &RTEMP,4(13) !      FORWARD CHAIN.  PUT ADDRESS OF\n*                              CALLER'S SAVE AREA INTO WORD 2 OF THIS\n*                              PROGRAM'S SAVE AREA.\n.NOFORE  ANOP\n         AIF   ('&BACKCHN' NE 'YES').NOBACK\n         ST    13,8(&RTEMP) !      BACK CHAIN. PUT ADDRESS OF SAVE AREA\n*                              FOR THIS PROGRAM INTO WORD 3 OF CALLER'S\n*                              SAVE AREA\n.NOBACK  ANOP\n         AIF   ('&FORECHN' NE 'YES' AND '&BACKCHN' NE 'YES').NOREST\n         L     &RTEMP,&OFFSET.(&RTEMP) !     RESTORE WORKING REGISTER\n*                              FROM SAVE AREA WHICH REGISTER POINTS TO\n.NOREST  ANOP\n         AIF   ('&SAVE' EQ 'R13PLUS18F').R13SAVE\n         AIF   ('&SAVE(1)' EQ  'INLINE').INLINE\n         AGO   .USESAVE       &SAVE MUST BE NAME OF USER SAVE AREA\n.R13SAVE ANOP\n***********************************************************************\n*        SAVE AREA IS ASSUMED TO BE 18 FULLWORDS PAST                 *\n*        THE SAVE AREA OF THE CALLING PROGRAM.                        *\n***********************************************************************\n         AGO   .ENDPROL\n.INLINE  ANOP\n.SAVEGEN B     &SAVNAME+&SBYTES     !   BRANCH AROUND SAVE AREA\n&SAVNAME DS    &LP&SNUMBER&RP&SUNIT !           SAVE AREA\n***********************************************************************\n*        SAVE AREA GENERATED INLINE.  SUBROUTINE IS                   *\n*        SERIALLY RE-USABLE, BUT IS NOT RE-ENTRANT.                   *\n***********************************************************************\n         AGO   .ENDPROL\n.USESAVE ANOP\n***********************************************************************\n*        SAVE AREA SUPPLIED BY USER.  SUBROUTINE IS                   *\n*        SERIALLY RE-USABLE, BUT IS NOT RE-ENTRANT.                   *\n***********************************************************************\n         AGO   .ENDPROL\n.NOSAVE  ANOP\n***********************************************************************\n*        NO SAVE AREA GENERATED.  USER BEWARE                         *\n*        IF CALLING LOWER LEVEL ROUTINES.                             *\n***********************************************************************\n         AGO   .ENDPROL\n.**********************************************************************\n.*                                                                    *\n.*       GETMAIN FOR SAVE AREA                                        *\n.*                                                                    *\n.**********************************************************************\n.GETMAIN ANOP\n&NLE4095 SETB  (&SLE4095)\n&SGBYTES SETC  '&SBYTES'      SET GLOBAL LENGTH FOR FREEMAIN\n         AIF   (&NLE4095).LAR0\n         CNOP  0,4 !           ALIGN PARAMETER LIST\n         BAL   1,*+8 !         BRANCH AROUND LENGTH\n         DC    A(&SBYTES) !       SAVE AREA LENGTH\n         L     0,0(1,0) !      LOAD SAVE AREA LENGTH INTO REGISTER 0\n         AGO   .GLOK\n.LAR0    LA    0,&SBYTES.(0,0) !     LOAD SAVE AREA LENGTH INTO REG 0\n         BAL   1,*+4 !         INDICATE GETMAIN\n.GLOK    AIF   ('&SAVE(1)' NE 'DSA').PLILOK\n         LR    2,0 !           SAVE LENGTH IN REGISTER 2\n.PLILOK  ANOP\n         SVC   10 !            ISSUE GETMAIN SVC\n*                              ADDRESS OF GETMAIN AREA IS\n*                              RETURNED IN REGISTER 1\n         AIF   ('&FORECHN' EQ 'NO').NOFOREG\n         ST    13,4(1) !       PUT ADDRESS OF CALLER'S SAVE AREA IN\n*                              WORD 2 OF THIS PROGRAM'S SAVE AREA\n.NOFOREG ANOP\n         AIF   ('&SAVE(3)' EQ 'NOMARK').NOMARK\n         MVI   4(1),C'G' !     MARK SAVE AREA AS OBTAINED BY A GETMAIN\n.NOMARK  ANOP\n         AIF   ('&SAVE(1)' NE 'DSA').PLIWOK\n         ST    2,0(0,1) !      STORE LENGTH OF DSA INTO PL/I WORD\n         MVI   0(1),&PLIFLAG !    MOVE PL/I FLAG BITS INTO PL/I WORD\n         S     2,*+12 !        GET HARDWARE LENGTH OF DSA FROM BYTE 73\n         EX    2,*+10 !        CLEAR OUT DSA FROM BYTE 73 ON\n         B     *+12 !          BRANCH AROUND CONSTANT AND CLEAR INSTR\n         DC    H'73'\n         XC    72(0,1),0(1) !  CLEAR OUT DSA FROM BYT 73 ON\n.PLIWOK  ANOP\n         AIF   ('&BACKCHN' NE 'YES').NOBACKG\n         ST    1,8(13) !       BACK CHAIN. PUT ADDRESS OF SAVE AREA FOR\n*                              THIS PROGRAM INTO WORD 3 OF CALLER'S\n*                              SAVE AREA\n         LM    14,2,12(13) !   RESTORE REGISTERS 14 THROUGH 1, WHICH\n*                              MAY BE DESTROYED BY AN SVC, AND 2\n         L     13,8(13) !      LOAD REGISTER 13 WITH SAVE AREA ADDRESS\n         AGO   .ENDGET\n.NOBACKG ANOP\n******** USER MUST EITHER FREE SAVE AREA HIMSELF OR BACK CHAIN BEFORE\n******** ALLOWING EPILOGUE WITH SAVE=FREEMAIN TO FREE THE SAVE AREA\n         LR    14,13 !         SAVE CALLER'S SAVE AREA ADDRESS IN R14\n         LR    13,1 !          LOAD REGISTER 13 WITH SAVE AREA ADDRESS\n         LM    14,1,12(14) !   RESTORE REGISTERS 14 TO 1 WHICH MAY BE\n*                              DESTROYED BY GETMAIN, FROM SAVE AREA\n.ENDGET  ANOP\n***********************************************************************\n*        SAVE AREA OBTAINED WITH GETMAIN.  IF SUBROUTINE              *\n*        IS RE-ENTRANT, THEN IT IS ALSO RECURSIVE.                    *\n***********************************************************************\n.*\n.*\n.**********************************************************************\n.*                                                                    *\n.*       GENERATE WARNING ERROR MESSAGES                              *\n.*                                                                    *\n.**********************************************************************\n.ENDPROL ANOP\n         AIF   ('&TRACE' EQ 'YES' OR '&TRACE' EQ 'NO').TROK\n         MNOTE *,'ERROR IN TRACE PARAMETER.  TRACE=YES ASSUMED.'\n.TROK    ANOP\n AIF ('&OUTPUT'EQ'PUT' OR '&OUTPUT'EQ'WTO' OR '&OUTPUT'EQ'BOTH').OUTOK\n         MNOTE *,'ERROR IN OUTPUT PARAMETER.  OUTPUT=BOTH ASSUMED.'\n.OUTOK   ANOP\n         AIF   ('&FORECHN' EQ 'YES' OR '&FORECHN' EQ 'NO').FCOK\n         MNOTE *,'ERROR IN FORECHN PARAMETER.  FORECHN=NO ASSUMED.'\n.FCOK    ANOP\n         AIF   ('&BACKCHN' EQ 'YES' OR '&BACKCHN' EQ 'NO').BCOK\n         MNOTE *,'ERROR IN BACKCHN PARAMETER.  BACKCHN=NO ASSUMED.'\n.BCOK    ANOP\n         AIF   ('&SAVE(1)' NE 'GETMAIN').NOGET\n         AIF   ('&SAVE(3)' EQ '' OR '&SAVE(3)' EQ 'NOMARK').SMOK\n         MNOTE *,'ERROR IN THIRD SAVE SUB-PARAMETER.  MARK ASSUMED.'\n.SMOK    ANOP\n.NOGET   ANOP\n         EJECT\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "REQUATE": {"ttr": 10247, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x05\\x06\\x8f\\x01\\x05\\x06\\x8f \\x13\\x009\\x009\\x00\\x00\\xe2\\xc2\\xc7@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-03-09T00:00:00", "modifydate": "2005-03-09T20:13:00", "lines": 57, "newlines": 57, "modlines": 0, "user": "SBG"}, "text": "         MACRO\n&LABEL   REQUATE &SAVE=NO\n***********************************************************************\n*                                                                     *\n*                 REGISTER EQUATES                                    *\n*                                                                     *\n***********************************************************************\n         SPACE 3\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         EJECT\n         AIF   ('&SAVE' EQ 'YES').SAVEOK\n         MEXIT\n.SAVEOK  ANOP\n***********************************************************************\n*                                                                     *\n*                  SAVE AREA DESCRIPTOR SECTION                       *\n*                                                                     *\n***********************************************************************\n         SPACE 3\nSAVEAREA DSECT ,\nSAVEWRD1 DS    F .            PL1 WORD\nSAVELAST DS    F .            CHAIN POINTER TO LAST SAVE AREA\nSAVENEXT DS    F .            CHAIN POINTER TO NEXT SAVE AREA\nSAVEREGS DS    0CL60 .        WORKING REGISTER STORAGE AREA\nSAVER14  DS    F .            R14 SLOT\nSAVER15  DS    F .            R15 SLOT\nSAVER0   DS    F .            R0 SLOT\nSAVER1   DS    F .            R1 SLOT\nSAVER2   DS    F .            R2 SLOT\nSAVER3   DS    F .            R3 SLOT\nSAVER4   DS    F .            R4 SLOT\nSAVER5   DS    F .            R5 SLOT\nSAVER6   DS    F .            R6 SLOT\nSAVER7   DS    F .            R7 SLOT\nSAVER8   DS    F .            R8 SLOT\nSAVER9   DS    F .            R9 SLOT\nSAVER10  DS    F .            R10 SLOT\nSAVER11  DS    F .            R11 SLOT\nSAVER12  DS    F .            R12  SLOT\nSAVESIZE EQU   *-SAVEAREA\n         EJECT\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SHOWMACS": {"ttr": 10249, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x07\\x17\\x00\\x17\\x01\\x01\\x07_\\x01\\x166/\\x13C\\x1a\\x07\\r\\xa9\\x1a\\x07\\xe2\\xe8\\xe2\\xd7\\xf0\\xf8@@@@'", "ispf": {"version": "07.23", "flags": 0, "createdate": "2001-03-16T00:00:00", "modifydate": "2016-12-27T13:43:17", "lines": 6663, "newlines": 3497, "modlines": 6663, "user": "SYSP08"}, "text": "//SYSP08SM JOB (40208),SCHIRADIN,MSGCLASS=R,MSGLEVEL=(1,1),\n//             CLASS=A,PRTY=15,NOTIFY=&SYSUID,REGION=60M       **\n//*\n//*       BUILD SHOWMVS.MACLIB LIBRARY FOR SHOWMVS\n//*\n//IDCCAMS EXEC PGM=IDCAMS\n//SYSPRINT  DD SYSOUT=*\n//SYSIN  DD *\n   DELETE 'SYSP08.SHOW723.MACLIB' NONVSAM\n   SET MAXCC=0\n//PVTMACS EXEC PGM=IEBUPDTE,PARM=NEW\n//SYSUT2   DD DSN=SYSP08.SHOW723.MACLIB,\n// DISP=(MOD,CATLG),\n// DSORG=PO,RECFM=FB,LRECL=80,\n// UNIT=SYSALLDA,\n// SPACE=(TRK,(10,5,30))\n//SYSPRINT DD SYSOUT=*\n./ ADD NAME=$$README\n\n    .-----------------------------------------------------------.\n    \u00a6 Control-block mapping macros required to assemble ShowMVS \u00a6\n    '-----------------------------------------------------------'\n\n  Macro name      Real name ?       Origin\n----------------------------------------------------------------------\n    ACCVT            YES            CAIMAC\n    ADYDFLM          YES            Data Areas\n    ADYDSCA          YES            Guesswork\n    AMCBS            YES            Data Areas\n    APPNMTBL         NO             SYS1.MACLIB(IECDSECS)\n    ARCMWE           Yes            Data Areas (HSM)             RS0400\n    ARCQCT           YES            Data Areas (HSM)\n    AXRB             YES            Guesswork                    RS0209\n    BPXZOCVE         YES            Guesswork                    RS1199\n    BPXZOCVT         YES            Guesswork                    RS1199\n    BPXZOPNT         No             Guesswork (will be droped)   RS0301\n    BPXZOPTN         YES            Guesswork                    RS0301\n    CEEOCBRS         Yes            CEE Option CBlock            RS0907\n    CICS             n/a            Several DFH cblocks          RS0904\n    CUNUCCH          n/a            Guesswork                    RS0705\n    CUNUCCE          n/a            Guesswork                    RS0705\n    CVT              n/a            Dummy                        RS0701\n    CSVT             n/a            Guesswork                    RS1007\n    DFSOPT           n/a            Guesswork                    RS0107\n    DIAG             n/a            VM\n    DIAG204          n/a            Guesswork\n    EXIT             n/a            Guesswork\n    DSNDERLY         YES            Guesswork\n    DSNDRIB          Yes            DB2 Release Information Block  $RS\n    ERBCPUDT         NO             Guesswork\n    ERBSTGST         YES            SYS1.MACLIB HBB4430\n    EZASMI           YES            (dummy)\n    EZAZTSAB         YES            Guesswork                    RS0601\n    EZAZTSDB         YES            Guesswork                    RS0601\n    EZAZTSEB         YES            Guesswork                    RS0601\n    ICHPAUTB         YES            SYS1.MACLIB HBB4420\n    ICHPCGRP         YES            SYS1.MACLIB HBB4420\n    ICHPDSDT         YES            Guesswork\n    IEARCTD          YES            Data Areas\n    IEEMBACT         YES            Guesswork\n    IEEMBRDS         YES            IPO1.SAMPLIB(SMFDUMP)\n    IEEMBSST         YES            PVTMACS\n    IEEVC102         YES            PVTMACS\n    IEEZB807         YES            Guesswork\n    IEEZB809         YES            PVTMACS\n    IEEZB816         YES            PVTMACS\n    IEEZB817         ?              Guesswork (RS)\n    IEFENF           ? (partial)    Guesswork (RS)               RS0105\n    IEFZB4D5         YES            PVTMACS\n    IEFZB445         YES            Guesswork\n    IEFZB610         YES            SYS1.MACLIB HBB4420\n    IFASLCA          YES            guesswork                    RS0406\n    IFAQUAAX         YES            SYS1.MACLIB(IFAQUAA)         RS0508\n    IGDAGD           YES            guesswork DFP               +RS/JWM\n    IGDBCD           YES            SYS1.MACLIB HDP3310 + guesswork\n    IGDDCD           YES            guesswork DFP               +RS/JWM\n    IGDDRD           YES            guesswork DFP                RS1002\n    IGDLBD           YES            guesswork DFP               +RS/JWM\n    IGDMCD           YES            guesswork DFP               +RS/JWM\n    IGDSCD           YES            guesswork DFP               +RS/JWM\n    IGDSGCL          YES            SYS1.MODEGN                  RS0905\n    IGDSSIVT         YES            guesswork DFP                RS0100\n    IGGCAXWA         YES            Data Areas\n    IGGCRT           n/a            Guesswork Catlog Resource    RS0803\n    IGVPPD           YES            Data Areas                     $RS\n    IHAAXAT          YES            Data Areas                   RS0700\n    IHADCQ           YES            ?\n    IHAETEX          NO             z/OS manual                  RS0601\n    IHALLCB          YES            SYS1.MACLIB HBB2220\n    IHALLCB3         -              Guesswork (ESA extensions)\n    IHALLDR          ?              Guesswork\n    IHALLDS          ?              Guesswork\n    IHALLLS          ?              Guesswork\n    IHALLT           YES            Data Areas\n    IHALXAT          YES            Data Areas\n    IHANTTE          YES            Guesswork                      $RS\n    IHAPICA          YES            SYS1.MACLIB HBB4430\n    IHARPP           YES            Guesswork\n    IHARTCT          YES            Data Areas\n    IHARTSD          YES            PVTMACS\n    IHASCE           YES            Data Area (JWM)\n    IHASCVA          YES            Data Area (RS)               RS0402\n    IHASETC          ?              ?                            RS0700\n    IHASDDSQ         YES            Data Areas + Guesswork\n    IHASDRTX         YES            Guesswork\n    IHASHDR          YES            Data Area (JWM)\n    IHASLTB          ?              Guesswork (RS)               RS0402\n    IHASVC           YES            SYS1.MACLIB HBB4420\n    IHATQE           YES            SYS1.MACLIB HBB4420\n    IHAXMD           YES            Data Areas\n    IHAXMSE          ?              ?                            RS0700\n    IKJALPL          ?              Guesswork (JWM)\n    IKJCNPRM         ?              Guesswork (JWM)\n    IKJCTLT          ?              Guesswork\n    IKJEFHCB         ?              Guesswork (JWM)\n    IKJEFCVE         ?              Guesswork (JWM) (IKJFCVEC)   SG0416\n    IKJEPPVE         ?              Guesswork (JWM) (IKJPPVEC)   SG0416\n    IKJEXTAB         ?              Guesswork\n    IKJTPT           ?              Guesswork (JWM)\n    IKJTPVT          YES            Guesswork\n    IKJXPRM          ?              Guesswork (JWM) (INMXPRMD)   SG0416\n    ILRASMVT         YES            Data Areas (OS/VS2)\n    ILRPART          YES            Data Areas (OS/VS2)\n    ILRPAT           YES            Data Areas (OS/VS2)\n\n    IOSDICI          YES            Guesswork\n    IOSDIOFC         YES            Guesswork\n    IOSDIOVT         YES            Guesswork\n    IOSDSHID         YES            SYS1.MACLIB HBB5510\n    IOSDULUT         YES            Guesswork\n    IOSDULU2         YES            Guesswork for z/OS R7        RS0405\n    IPST             ?              Guesswork (RS)               RS0601\n    IRADMDT          YES            PVTMACS\n    IRAICST          YES            Guesswork\n    IRARMCT          YES            SYS1.MACLIB HBB4430\n    IRARMPT          YES            Guesswork\n    IRAWMST          YES            SYS1.MODGEN HBB6606\n    ISGGCC           YES            Guesswork\n    ISGRPT           YES            Data Area                    RS0605\n    ISTATCVT         YES            Guesswork\n    ISPCFG           n/a            Guesswork                    JK0209\n    ISPTCM           n/a            Guesswork                    RS0105\n    IXCCPLX          n/a            Guesswork                    RS0504\n    IXGCTA           n/a            Guesswork                    RS1002\n    IXGLCB           n/a            Guesswork                    RS1002\n    IXGLSAB          n/a            Guesswork                    RS1002\n    IXGLSMF          n/a            Guesswork                    RS1002\n    LATENT           n/a            Guesswork                    RS0601\n    J                YES            N/A\n    OCVT             YES            same as BPXZOCVT (z/OS R6)   RS0704\n    SSGARGL          NO             DFSMS Adv. Services          RS1105\n    SHOWMRHA         YES            SEZANMAC                     RS0405\n    SHOW$PAD         YES            SHASMAC                      RS0705\n\n 400 NUMBER ON\n 401 Change DEFTERMJ DEFWTOCF DEFSDSWT DEFVOLUW per JWM\n 401 Delete BCD_TOTAL_LENGTH label\n 401 Add ACCVT (ACF2 CVT)\n 402 TSO/E 2.6\n 403 ISGGCC, IHALLCB3, IRAWMST, DSNDRIB\n 404 Rename job to SHOWMACS and PDS to SHOWMVS.MACLIB\n     Delete ICHPRCVT\n 405 Add IGDAGD,IGDDCD,IGDLBD,IGDMCD,IGDSCD\n     Change EZASMI\n     Change IEFAB445-Csect (Macro IEFZB445) added DEFREDTP per JWM\n 406 Add IHASCE, IHASHDR  JWM\n 407 Change IHALLCB (only for pre V2R6) and IHALLCB3             RS0999\n 407 Add BPXZOCVE, BPXZOCVT, BPXZOPNT per RS                     RS1199\n 407 Add IGDSSIVT                                                RS0100\n 407 Changed ARCQCT, Add ARCMWE                                  RS0400\n 407 Add IHAAXAT                                                 RS0700\n 407 Add IHAXMSE and IHASETC                                     RS0700\n 407 Changes IHASETC BPXZOPNT                                    RS0800\n 701 Changed BPXZOPNT, IGGCAXWA, ISGGVT. Add BPXZOPTN            RS0301\n 702 Add IPST, EZAZTSEB, LATENT, IHAETEX                         RS0601\n 703 Changed IGGCAXWA, Add CVT (Dummy)                           RS0701\n 704 Changed BPXZOPTN                                            RS0302\n     Add IHASCVA, IHASLTB                                        RS0402\n 705 none\n 706 Changed IHAXMSE for z/OS R3                                 RS0902\n     Add IGDDRD, IXGCTA, IXGLCB, IXGLSAB, IXGLSMF                RS1002\n 707 Changed IEFAB445 added DEFAFFTP usage unknown               RS0203\n     Changed IHAETEX, BPXZOPTN, AMCBS, IHARTCT                   RS0703\n     Add IGGCRT                                                  RS0803\n 708 None\n 709 Add IXCCPLX                                                 RS0504\n     Copy BPXZOCVT to OCVT                                       RS0704\n 710 Add CICS                                                    RS0904\n     Add CEEOCB                                                  RS1004\n     Add IOSDICI                                                 RS1004\n     Changed IHALXAT                                             RS1204\n 711 Add IEFENF ISPTCM SHOWMRHA(EZBNMRHA)                        RS0105\n     Changed ARCQCT                                              RS0105\n     Add IOSDULU2   Version2 of ULUT z/OS R7                     RS0405\n     Changed IEEMBSST                                            DB0505\n 712 Add ISGRPT                                                  RS0605\n     Droped ISGGVT                                               RS0605\n     Changed DSNDERLY                                            RS0605\n     ADD SHOW$PAD                                                RS0705\n     ADD CUNUCCH, CUNUCCE                                        RS0705\n     ADD IGDSGCLX becaue of OA13568 (zOS R5, R6, R7)             RS0905\n     ADD SSGARGL                                                 RS0705\n 713 Changed IKJXPRM                                             SG1205\n     Changed ISGRPT  zOS R6                                      RS0406\n     Added IFASLCA   zOS R6                                      RS0406\n     Changed BPXZOPTN                                            RS0506\n     Changed IXGCTA                                              RS0706\n 714 Changed ISGRPT z/OS R8                                      RS0806\n     Changed CEEOCB z/OS R8                                      RS0806\n     Changed DIAG204                                             RS0906\n     Added ISPCFG                                                RS1006\n     Changed IGDLBD, IGDDRD                                      RS1006\n     Changed IOVT                                                RS1106\n 715 Added DFSOPT                                                RS0107\n     Changed IGGCRT                                              RS0307\n     Changed IOVT,ACCVT                                          RS0407\n 717 Rename CEEOCB to CEEOCBRS                                   RS0907\n     Changed IHALLDS for z/OS R9                                 JH0907\n     Added CSVT                                                  RS1007\n 717 Changed IKJALPL                                             RS1207\n 717 Changed IHALLDS                                             RS0408\n     Added IFAQUAAX because of naming conflicts                  RS0508\n 719 Changed IGDBCD                                              RS0908\n     Changed ICHPDSDT                                            RS1108\n     Added IOSDIOFC                                              RS1108\n     Added AXRB                                                  RS0209\n     Changed ISPCFG for z/OS R9                                  JK0209\n 720 Changed IEFAB445 for z/OS R11                               RS0909\n     Changed CEEOCBRS for z/OS R11                               RS0310\n 721 Changed DSAB                                                RS0410\n 722 Changed CEEOCBRS for z/OS R13                               RS0113\n     Changed IEFZB445                                            RS0414\n     Changed OPTN                                                RS0414\n     New     IOSDULU3 UTUL V3 z/OS 2.2                           JH1214\n     Changed IOSDIOVT z/OS V2R2                                  JH1214\n 723 Changed OPTN     for z/OS V2R1                              RS0615\n     Changed IKJTPVT                                             SG1115\n     Changed $$$README Added original IBM names for IKJ* macros  SG0407\n     Changed IEFZB445                                            RS0616\n     Changed IXGCTA for z/OS 2.2                                 PG1216\n\n./ ADD NAME=ACCVT\n         MACRO\n         ACCVT &DSECT=,&PREFIX=\nACCPFX   DSECT                    ACF2 CVT PREFIX AREA\nACCTLEN  DS    F'2096'            TOTAL LENGTH OF ACCVT\nACCPFXL  DS    F'48'              LENGTH OF PREFIX ONLY\nACCPID   EQU   *                  ACF2 SYSTEM IDENT AREA\nACCPIDL  DS    H                  LENGTH OF SYSID BUFFER\nACCPIDO  DS    H                  ZERO\nACCPIDS  DS    CL26'eTrust CA-ACF2 8.0 SP03' ACF2 Sys ID STRING  RS0407\n         DS    XL6'00'                                           RS0407\nACCPFXP  DS    A(ACCPFX)          ADDR OF PREFIX\nACCVT    EQU   *\n         DS    512F               UNUSED\n         MEND\n./ ADD NAME=ADYDFLM\n         MACRO\n         ADYDFLM\nDFLM     DSECT                         DAE Default Module (ADYDFLT)\nDFLID    DS    0CL4                    CB ID\nDFLDFL   DS    CL3                     Acronym 'DFL'\nDFLVSD   DS    C                       Version number\nDFLPLMEM DS    CL8                     Last sys1.parmlib member        X\n                                       successfully processed for a    X\n                                       set DAE command\nDFLCRIT  DS    0CL84                   Criteria for symptom string     X\n                                       to be considered as a unique    X\n                                       identifier by DAE\nDFLSCNT  DS    XL2                     Minimum number of symptom       X\n                                       keywords\nDFLSLN   DS    XL2                     Minimum symptom string length\nDFLREQ   DS    0CL40                   Keys of specific symptoms       X\n                                       required for matching - each    X\n                                       two bytes defines a key\nDFLREQA  DS    20XL2                   Array containing one            X\n                                       required key per entry\nDFLOPT   DS    0CL40                   Optional keys for matching -    X\n                                       each two bytes defines a key    X\n                                       which is optional for matching\nDFLOPTA  DS    20XL2                   Array containing one            X\n                                       optional key per entry\nDFLDSN   DS    CL44                    Name of the data set containing X\n                                       the DAE problem records\nDFLEXPIR DS    XL4                     Expiration period in days for   X\n                                       records in the DAE dataset.     X\n                                       If the date when DAE is started X\n                                       is more than this period after  X\n                                       the last occurrence date, then  X\n                                       the record will be ignored.\nDFLRECNO DS    F                       Maximum size to which the       X\n                                       symptom queue will be allowed   X\n                                       to grow.  RECORD(nn).           X\n                                       This will be rounded up to a    X\n                                       multiple of the cpool blksize.\nDFLOFLAG DS    0CL8                    DAE option flags\nDFLDAEO  DS    X                       Options for DAE keywords which  X\n                                       do not have flags for the       X\n                                       subparameters\nDFLSTRT  EQU   X'80'                   START\nDFLSTOP  EQU   X'40'                   STOP\nDFLSHR   EQU   X'20'                   SHARED DAE data set\nDFLDSNS  EQU   X'10'                   Dataset name specified\nDFLGSTP  EQU   X'08'                   GLOBALSTOP specified\nDFLSHRO  EQU   X'04'                   SHARED OPTIONS\nDFLDOPT  DS    0CL2                    Dump options which are shared   X\n                                       in the sysplex.\nDFLSVC   DS    X                       Options for the\n*                                      SVCDUMP keyword\nDFLSVCM  EQU   X'80'                   SVCDUMP(MATCH)\nDFLSVCS  EQU   X'40'                   SVCDUMP(SUPPRESS)\nDFLSVCU  EQU   X'20'                   SVCDUMP(UPDATE)\nDFLSVCA  EQU   X'10'                   SVCDUMP(SUPPRESSALL)\nDFLSYSM  DS    X                       Options for the\n*                                      SYSMDUMP keyword\nDFLSYSMM EQU   X'80'                   SYSMDUMP(MATCH)\nDFLSYSMS EQU   X'40'                   SYSMDUMP(SUPPRESS)\nDFLSYSMU EQU   X'20'                   SYSMDUMP(UPDATE)\nDFLSYSMA EQU   X'10'                   SYSMDUMP(SUPPRESSALL)\nDFLGLB   DS    X                       Options for GLOBAL\nDFLGLBD  EQU   X'80'                   GLOBAL(DSN)\nDFLGLBO  EQU   X'40'                   GLOBAL(OPTIONS)\n         DS    4X                      reserved\nDFLNOTIF DS    0XL4                    NOTIFY values\nDFLNOTDN DS    H                       notify dump number\nDFLNOTTM DS    H                       notify time number\n         DS    CL36                    reserved\nDFL_LENGTH EQU 196\n         MEND\n./ ADD NAME=ADYDSCA\n         MACRO\n         ADYDSCA\nDSCA     DSECT                         DAE Com area\nDSCID    DS    C'DSCA'                 CB ID\nDSCDFL   DS    A(DFLM)                 DAE default module\nDSCA_LENGTH EQU 192\n         MEND\n./ ADD NAME=AMCBS\n         MACRO\n         AMCBS\nAMCBS    DSECT                         ACCESS METHOD CB STRUCTURE\nCBSID    DS    C'AM'                   AMCBS ID\nCBSSIZ   DS    H'256'                  LENGTH OF THE AMCBS       RS0803\nCBSMCSTA DS    C'CCHH'                 CCHH OF MASTER CATALOG\nCBSACB   DS    V(ACB)                  ACB FOR THE MASTER CATALOG\nCBSCBP   DS    V(IDC019C1)             CONTROL BLOCK MANIPULATION RTNE\nCBSCMP   DS    V(IGG0CLA1)             CATALOG MANAGEMENT ROUTINE\nCBSCAXCN DS    V(IGGCAXWA)             ADDRESS OF THE CAXWA CHAIN\nCBSCRACA DS    V(IGGCAXWA)             ADDRESS OF THE CRA CAXWA CHAIN\n         DS    CL4       +x'1C'        ??\n         DS    CL64      +x'20'        ??\nCBSFLAG  DS    X         +x'60'        ??\nCBSDELW  EQU   X'60'                   Delete UCAT/VVDS warning\nCBSSYSC  EQU   X'40'                   SYS% to SYS1 conversion\n         DS    CL15      +x'61'        ??\n         DS    CL12      +x'70'        ??\nCBSCRT   DS    F         +x'7C'        Catalog Resource Table    RS0803\n         DS    CL16      +x'80'        ??                        RS0803\n         DS    CL11      +x'90'                                  RS0803\nCBSALIL  DS    X         +x'9B'        Alias level 1-4 Default 1 RS0803\n         DS    CL4       +x'9C'                                  RS0803\n         DS    CL16      +x'A0'        ??                        RS0803\nCBSHLQ   DS    CL8       +x'B0'        Volcat HLQ Identifier     RS0803\n         MEND\n./ ADD NAME=APPNMTBL                   from SYS1.MACLIB(IECDSECS)\n         MACRO\n         APPNMTBL\nAPPNMTBL DSECT                         APPENDAGE NAME TABLE\nAPPBAL   DS    H'100'                  balance of unused core\nAPPSIZE  DS    H'128'                  total size of this table\nAPPENTRY DS   0XL4                     EOE (first entry)\nAPPCOUNT DS    H                       number of names\nAPPOFFST DS    H                       offset to first name\n         DS   4XL4                     SIO,PCI,CHE,ABE\nAPPNAMID DS    C'X4'                   first name ID\n         MEND\n./ ADD NAME=ARCMWE\n         MACRO\n         ARCMWE\nMWE      DSECT           HSM Managment Work Element Queue\nMWEHDR   DS    0CL140    Header\nMWEFWD   DS    F         Next MWE element\nMWEBWD   DS    F         prev. MWE element\nMWESPL   DS    0CL4      GetMain/FreeMain values\nMWESPN   DS    CL1       Subpool\nMWELEN   DS    AL3       Length\nMWEUSER  DS    F         MWE users copy\n         ORG   MWEUSER\nMWEFSR   DS    F         Function statistics\n         ORG   *\nMWETOD   DS    0CL8      GetMain/FreeMain values\nMWESTIM  DS    CL4       Time of MWE\nMWESDAT  DS    CL4       Date of MWE\nMWEFUNC  DS    C         Function\nMWEFX00  EQU   X'00'     Returnc QCT pointer\nMWEFX01  EQU   X'01'     StrtUp HSM\nMWEFX02  EQU   X'02'     Shutdown HSM\nMWEFX03  EQU   X'03'     Recall a dataset\nMWEFX04  EQU   X'04'     Unused\nMWEFX05  EQU   X'05'     Recover Dataset or Volume\nMWEFX06  EQU   X'06'     Migrate Dataset or Volume\nMWEFX07  EQU   X'07'     Backup Dataset or Volume\nMWEFX08  EQU   X'08'     Read a control dataset\nMWEFX09  EQU   X'09'     Process Command\nMWEFX10  EQU   X'0A'     Post MWE\nMWEFX11  EQU   X'0B'     Purge MWE\nMWEFX12  EQU   X'0C'     Delete migrated dataset\nMWEFX13  EQU   X'0D'     Perform aggregate backup\nMWEFX14  EQU   X'0E'     Perform aggregate recovery\nMWEFLGS  DS    CL3       Flags\nMWEUID   DS    CL8       Userid of requestor or dummy\nMWERQN   DS    F         Request-Number\nMWEASCB  DS    F         ASCB of requestor\nMWEECB   DS    F         ECB of requestor\nMWERC    DS    F         Returncode of request\nMWEREAS  DS    F         Reasoncode of request\nMWEABCC  DS    F         System abend or completion code\nMWEGROUP DS    CL8       RACF Goup\nMWELOCK  DS    C         Lockbyte\nMWEFLG2  DS    CL2       Flags-2\nMWECLCT  DS    C         Number of attempts to recall\nMWEATCTR DS    C         alternate name for times\nMWEJBN   DS    CL8       Jobname of requestor\nMWERST   DS    CL4       Reader-Time of MWE\nMWERSD   DS    CL4       Reader-Date of MWE\nMWERHSCT DS    C         number of retrys\nMWEFLG3  DS    CL2       Flags-3\nMWEFTYP  DS    C         function code for ARCFAIL\nMWEECBP  DS    F         ECB for local wait\nMWEDFLGS DS    C         Flags\nMWEFFLGS DS    C         Flags\nMWE89VAL DS    H         Priority\nMWECINDX DS    H         Index\nMWEFLG4  DS    C         Flags-4\nMWESMSFG DS    C         SMS functional flags\nMWE_SUBPOOL_AVOVE_LINE DS    H\nMWEFLG6  DS    CL2       Flags-6\nMWEXINFO DS    0CL12     Extended console\nMWEXCNID DS    CL4       Console-ID\nMWEXCART DS    CL4       Console auto resp token\n         DS    CL4\n         DS    CL4       reserved\nMWEDAVP  DS    F         Address of DAV list\n         DS    CL6       reserved\nMWEFLG5  DS    CL2       Flags-5\nMWE_VAR  DS    0C\nMWEMCNT  DS    CL2       Number of MWE in the request\nMWESEQN  DS    CL2       Sequence number in a multiple MWE request\nMWECCNT  DS    CL2       Number of MWEs processed\nMWEDARC  DS    CL2       Returncode Dynamic Allocation\nMWEDSN   DS    CL44      Dataset Name\n         ORG MWE_VAR                                             RS0500\nMWECMDL  DS    H         Length of Command                       RS0500\nMWECMDO  DS    H         Offset                                  RS0500\nMWECMD   DS    CL90      Command variable length MWECMDL         RS0500\n         MEND\n./ ADD NAME=ARCQCT\n         MACRO\n         ARCQCT\n*   DFSMhsm Diagnostic Guide (Layout is NOT complete)\nMQCT     DSECT                         HSM Control Table\nMQCTECBP DS    F                       HSM ECB\nMQCTFLG1 DS    C                       HSM Flags\nMQCTFACT EQU   X'80'                   HSM active\nMQCTJES3 EQU   X'40'                   JES3 specified\nMQCTFLG2 DS    C                       HSM Flags\nMQCTFLG3 DS    C                       HSM Flag reserverd\nMQCTFLG4 DS    C                       HSM Flag reserverd\nMQCTASCB DS    F                       HSM ASCB\nMQCTMEWH DS    F                       HSM MWE first\nMQCTMEWT DS    F                       HSM MWE last\nMQCTRQN  DS    F                       Last Request-number\nMQCTTVOL DS    F                       Address primary volume list\nMQCTPDEQ DS    0CL8                    Queue of pool descr. elements\nMQCTPOOL DS    F                       First descr. elements\nMQCTPLT  DS    F                       Last descr. elements\nMQCTMCVT DS    F                       MCVT control block (ASID HSM)\nMQCTESD  DS    F                       Address of ARCESD (ASID HSM)\nMQCTID   DS    C'QCT*'                 BLOCK ID\nMQCTVER  DS    C' 2'                   VERSION\nMQCTREL  DS    C'5'                    RELEASE\nMQCTMOD  DS    C'0'                    MODIFICATION\nMQCTCSHL DS    F                       Maximum defined stor for MWE\nMQCTCSCU DS    F                       Maximum stor for MWE in use\nMQCTCSIL DS    H                       Inactivity limit for MWE\nMQCTCSAL DS    H                       Activity limit for WAIT MWE\nMQCTCSNL DS    H                       Maximum # of MWE per ASID\nMQCT_LENGTH DS H                       QCT length\nMQCTT57I DS    CL8                     ARC0057I TOD (almost!!!)\nMQCTT58I DS    CL8                     ARC0058I TOD (almost!!!)\nMQCTVOLP DS    0CL8                    Volume-pool table pointers\nMQCTVPOL DS    F                       When on, volume-pool\nMQCTVPLT DS    F                       Volume-pool tail address\nMQCTINTS DS    CL8                     Jobtime stamp of a MAIN host\nMQCTEXTP DS    F                       Extended QCT\nMQCTCNTR DS    F                       Reserved\nMQCT_VRM DS    CL4                     OS, Version, Release, Mod binary\nMQCTMULP DS    F                       pointer to block MQCT_MULT\n         DS    CL8                     Reserved\nMQCTMAS  DS    F                       Maximum ABARS tasks allowed\nMQCTSAS1 DS    CL64        Array for Application Backup and Recovery\nMQCTSAS2 DS    CL64        Array for Application Backup and Recovery\nMQCTSAS3 DS    CL64        Array for Application Backup and Recovery\nMQCTSAS4 DS    CL64        Array for Application Backup and Recovery\nMQCTSAS5 DS    CL64        Array for Application Backup and Recovery\nMQCTSAS6 DS    CL64        Array for Application Backup and Recovery\nMQCTSAS7 DS    CL64        Array for Application Backup and Recovery\nMQCTSAS8 DS    CL64        Array for Application Backup and Recovery\nMQCTMASP DS    F                       Pointer to MASCB\nMQCT_MULT DSECT                        HSM block for host elements\nMQCT_HANCHR DS 0CL8                    Anchor for linked list\nMQCTHADR DS    F                       first element for DFSMShsm host\nMQCTTADR DS    F                       last element for DFSMShsm host\nMQCTMAIN DS    F                       Zero or pointer to host element\n*                                      for HOSTMODE=MAIN\nMQCTGRS  DS    F                       Pointer to GRS block\nMQCTHOST DSECT                         HSM DFSMShsm host element\nMQCT_BLID DS   CL8                     Host element ID *QCTHST*\nMQCTH_ID DS    CL2                     Host identifier\n         DS    CL2                     Reserved\nMQCTH_VRM DS   CL4                     Flag for Vers, Rel, Mod level\nMQCTH_STNAME DS CL8                    Started task name\nMQCTHOST_LENGTH DS H                   Host element length\nMQCTH_ASID DS  H                       Address space ID\nMQCTH_NEXT DS  F                       Next host element\nMQCTH_PREV DS  F                       Prev. host element\nGRSCB    DSECT                         HSM GRS\nGRSCB_EYEC DS CL8                      Eyecatcher GRSCB210\n         DS    F                       ??\nGRCB_MCDSL DS  H                       Length of MCDS DSN\nGRCB_MCDS  DS  CL44                    MCDS DSN\nGRCB_BCDSL DS  H                       Length of BCDS DSN\nGRCB_BCDS  DS  CL44                    BCDS DSN\nGRCB_OCDSL DS  H                       Length of OCDS DSN\nGRCB_OCDS  DS  CL44                    OCDS DSN\nGRCB_JRNLL DS  H                       Length of JRNL DSN\nGRCB_JRNL  DS  CL44                    JRNL DSN\n         MEND\n./ ADD NAME=AXRB\n         MACRO\n         AXRB\nAXRB     DSECT                         ARXB Common Storage Area\nAXRBEYEC DS    CL8                     Eyecatcher AXRB\n         DS    F                       ??\n         DS    H                       ??\nAXRBASID DS    H                       Asid AXR\n         DS    A                       AXRRXPC\n         DS    A                       ??\n         DS    CL40                    ??\n         DS    7F                      ??\nAXRBASCB DS    F                       ASCB AXR\n         DS    CL256                   ??\nAXRBAXRB8P DS  F                       Ptr to AXRB8\n         DS    A                       AXRINLPA\n         DS    A                       ??\n         DS    F                       ??\nAXRB8    DSECT                         AXRB8 Private ASID AXR\nAXRB8EYEC DS   CL8                     Eyecatcher AXRB8\n         DS    CL8                     ??\n         DS    CL4                     ??\n         DS    CL8                     ??\n         DS    CL4                     ??\n         DS    CL20                    ??\nAXRB8AXRBP DS  A                       Ptr to AXRB\n         DS    2F                      ??\n         DS    CL8                     ??\n         DS    F                       ??\n         DS    CL4                     ??\n         DS    4F                      ??\n         DS    CL140                   ??\n         DS    F                       Ptr to RXSV\n         DS    CL8                     ??\n         DS    F                       Ptr to ASACPDFNReqCPCls\n         DS    2F                      ??\n         DS    CL4                     ??\n         DS    F                       ??\n         DS    CL8                     ??\n         DS    F                       ??\n         DS    CL4                     ??\nAXRB8TOD DS    CL8                     TOD Start\n         DS    CL8                     ??\n         DS    3F                      ??\n         DS    CL16                    ??\nAXRB8PCOM DS   F                       Ptr to PCOM\n         DS    F                       Ptr to CPOOL\nPCOM     DSECT                         PCOM   Private ASID AXR\nPCOMEXEC DS    CL4                     Eyecatcher PCOM\nPCOMPARM DS    CL8                     Eyecatcher PCOM\n         DS    CL12                    ??\n         DS    2F                      ??\n         DS    CL12                    ??\n         DS    F                       ??\n         DS    CL20                    ??\n         DS    2F                      ??\n         DS    H                       ??\nPCOMCPFL DS    H                       Length of CPF\nPCOMCPF  DS    CL8                     Name of CPF\n         DS    F                       ??\n         DS    H                       ??\nPCOMUSERL DS   H                       Length of User or Subsystem\nPCOMUSER DS    CL8                     User or Subsystem\n         MEND\n./ ADD NAME=BPXZOCVE\n         MACRO\n         BPXZOCVE\nOCVE     DSECT                                                   RS1199\nOCVEEYEC DS    CL4                     eyecatcher 'OCVE'         RS1199\n         DS    CL2                                               RS1199\nOCVE_LENGTH  DS  H                     length OCVE               RS1199\n         DS    CL4                                               RS1199\nOCVEOPNT DS    F                                                 RS1199\n         MEND\n./ ADD NAME=BPXZOCVT\n         MACRO\n         BPXZOCVT\nOCVT         DSECT                                               RS1199\nOCVTEYEC     DS  CL4                   eyecatcher 'OCVT'         RS1199\n             DS  CL2                                             RS1199\nOCVT_LENGTH  DS  H                     length OCVT               RS1199\nOCVTOCVE     DS  F                     OCVE-Pointer              RS1199\nOCVTOEXT     DS  F                     OEXT-Pointer              RS1199\n             DS  F                                               RS1199\nOCVTASCB1    DS  F                     ASCB-Pointer for USS      RS1199\nOCVTASID     DS  H                     ASID for USS              RS1199\n             DS  CL2                                             RS1199\n             DS  F                                               RS1199\nOCVTSTOKEN   DS  D                     Kernel-Token              RS1199\n             DS  6F                                              RS1199\nOCVTASCB2    DS  F                     ASCB-Pointer for VTAM     RS1199\n             DS  CL248                 ??                        RS1199\nOCVT_STCNAME DS  CL8                                             RS1199\n         MEND\n./ ADD NAME=BPXZOPNT\n         MACRO\n         BPXZOPNT\nOPNT                     DSECT                                   RS1199\nOPNTEYEC                 DS CL4     eyecatcher 'OPNT'            RS1199\n                         DS CL52                                 RS1199\nOPNT_MAXPROCSYSTEM       DS F                                    RS1199\nOPNT_MAXPROCUSER         DS F                                    RS1199\nOPNT_MAXUIDS             DS F                                    RS1199\nOPNT_MAXFILEPROC         DS F                                    RS1199\nOPNT_MAXPTYS             DS F                                    RS1199\nOPNT_TRACEPARM           DS CL8                                  RS1199\nOPNT_MAXTHREADTASKS      DS F                                    RS1199\n                         DS F                                    RS1199\nOPNT_BPXPRM              DS CL8                                  RS1199\nOPNT_MAXTHREADS          DS F                                    RS1199\nOPNT_FORKCOPY_FLAG       DS XL1                                  RS1199\n                         DS CL3                                  RS1199\nOPNT_STEPLIBLIST_LENGTH  DS X                                    RS1199\nOPNT_STEPLIBLIST         DS CL60                                 RS1199\nOPNT_STEPLIBLIST_UNKNOWN DS CL195                                RS1199\nOPNT_PRIORITYGOALS       DS F                                    RS1199\nOPNT_IPCMSGNIDS          DS F                                    RS1199\nOPNT_IPCMSGQBYTES        DS F                                    RS1199\nOPNT_IPCMSGQMNUM         DS F                                    RS1199\nOPNT_IPCSHMNIDS          DS F                                    RS1199\nOPNT_IPCSHMSPAGES        DS F                                    RS1199\nOPNT_IPCSHMMPAGES        DS F                                    RS1199\nOPNT_IPCSHMNSEGS         DS F                                    RS1199\nOPNT_IPCSEMNIDS          DS F                                    RS0301\nOPNT_IPCSEMNSEMS         DS F                                    RS0301\nOPNT_IPCSEMNOPS          DS F                                    RS1199\nOPNT_MAXMMAPAREA         DS F                                    RS1199\nOPNT_MAXRTYS             DS F                                    RS1199\nOPNT_MAXFILESIZE         DS F    HIGHVALUE = Unlimited           RS1199\nOPNT_MAXCORESIZE         DS F                                    RS1199\nOPNT_MAXASSIZE           DS F                                    RS1199\nOPNT_MAXCPUTIME          DS F                                    RS1199\n                         DS 2F                                   RS1199\nOPNT_SUPERUSER           DS CL8                                  RS1199\n                         DS F                                    RS1199\nOPNT_MAXSHAREPAGES       DS F                                    RS1199\nOPNT_TTYGROUP            DS CL8                                  RS1199\n                         DS F                                    RS0800\nOPNT_MAXQUEUEDSIGS       DS F                                    RS0800\n                         DS F                                    RS0800\n                         DS CL8                                  RS1199\n                         DS 14F                                  RS1199\n                         DS CL3                                  RS1199\nOPNT_USERIDALIAS_LENGTH  DS X                                    RS1199\nOPNT_USERIDALIAS         DS CL60                                 RS1199\nOPNT_USERIDALIAS_UNKNOWN DS CL195                                RS1199\n         MEND\n./ ADD NAME=BPXZOPTN\n         MACRO\n         BPXZOPTN\n*  The layout can be taken from CEE.SCEEH.SYS.H(EDC4H01E)\nOPTN                     DSECT\nOPTN_ID                  DS CL4     eyecatcher 'OPTN'\nOPTN_SP                  DS CL1     Subpool\nOPTN_LEN                 DS FL3     Length\nOPTN_RSV1                DS F       Opaque area displacment\nOPTN_RSV2                DS F       Opaque area displacment\nOPTN_RESOLVER_PROC_LEN   DS CL4     Length of ResolverProc       RS0302\nOPTN_RESOLVER_PROC       DS CL8     ResolverProc                 RS0302\nOPTN_RSV3_2              DS CL24    Reserved                     RS0302\nOPTN_RSV4                DS F       Opaque area displacment\nOPTN_MAXPROCSYSTEM       DS F       Max processes on system\nOPTN_MAXPROCUSER         DS F       Max processes per UID\nOPTN_MAXUIDS             DS F       max # of users on system\nOPTN_MAXFILEPROC         DS F       max # of files per proc\nOPTN_MAXPTYS             DS F       Max # of pseudo-term\nOPTN_TRACEPARM           DS CL8     CTrace parmlib member\nOPTN_MAXTHREADTASKS      DS F       max # of tasks per Pthread\nOPTN_OPTION_FLAG         DS XL1\nOPTN_FORKCOPY            EQU X'80'\nOPTN_SYSPLEX             EQU X'40'\nOPTN_CMD_CHANGING        EQU X'20'\nOPTN_CMD_CHANGED         EQU X'10'\nOPTN_SYSCALL_COUNT       EQU X'08'\nOPTN_CMD_RESET           EQU X'04'\nOPTN_CMD_SETOMVS_ONLY    EQU X'02'\nOPTN_CMD_SYNTAXCHECK     EQU X'01'\nOPTN_OPTION_FLAG2        DS XL1\nOPTN_RESPROCSPEC         EQU X'80'     z/OS R2                   RS0803\nOPTN_AFINET              EQU X'40'     z/OS R2                   RS0803\nOPTN_AUTOCVT             EQU X'20'     z/OS R2                   RS0803\nOPTN_SWAAbove            EQU X'10'     z/OS R5                   RS0506\nOPTN_LOSTMSGON           EQU X'01'     z/OS R13                  RS0414\n                         DS CL2     more flags                   RS0803\nOPTN_BPXPRM              DS CL8\nOPTN_MAXTHREADS          DS F\nOPTN_RSV5                DS F       Opaque area displacment\nOPTN_STEPLIBLIST_LENGTH  DS X\nOPTN_STEPLIBLIST         DS CL255\nOPTN_PRIORITYGOALS       DS F       RSV6\nOPTN_IPCMSGNIDS          DS F       max system msg queue IDs\nOPTN_IPCMSGQBYTES        DS F       max bytes per msg queue\nOPTN_IPCMSGQMNUM         DS F       max msgs per queue\nOPTN_IPCSHMNIDS          DS F       max sys shared memory IDs\nOPTN_IPCSHMSPAGES        DS F       max sys shared mem pages all\nOPTN_IPCSHMMPAGES        DS F       max shared mem pages per seg\nOPTN_IPCSHMNSEGS         DS F       max shared mem seg per proc\nOPTN_IPCSEMNIDS          DS F       max system semaphore IDs\nOPTN_IPCSEMNSEMS         DS F       max # of semaph. per semaph.\nOPTN_IPCSEMNOPS          DS F       max # of op per BPX1SOP call\nOPTN_MAXMMAPAREA         DS F       max size of mem map area\nOPTN_MAXRTYS             DS F       max # of remote-term sess.\nOPTN_MAXFILESIZE         DS F       max file size\nOPTN_MAXCORESIZE         DS F       max core size\nOPTN_MAXASSIZE           DS F       max address space size\nOPTN_MAXCPUTIME          DS F       max CPU time\nOPTN_MAXSUBFILESYSTYPES  DS F       max # of subfilesystypes\nOPTN_RSV7                DS F\nOPTN_SUPERUSER           DS CL8\nOPTN_SUPERUSER_LEN       DS F       length of Superuser\nOPTN_MAXSHAREPAGES       DS F       max # of pages shared\nOPTN_TTYGROUP            DS CL8\nOPTN_TTYGROUP_LEN        DS F       length of TTYGROUP\nOPTN_MAXQUEUEDSIGS       DS F\nOPTN_STARTUP_PROC_LEN    DS F       length of Proc\nOPTN_STARTUP_PROC        DS CL8     Proc\nOPTN_STARTUP_DSNMVS_LEN  DS F       length of StartUp-Exec\nOPTN_STARTUP_DSNMVS      DS CL52    StartUp-Exec                 RS0401\nOPTN_USERIDALIAS_LENGTH  DS F\nOPTN_USERIDALIAS         DS CL255\nOPTN_NONEMPTYMOUNTPT     DS CL1                                  RS0414\n* NOWWARN = '01'                                                 RS0414\n* WARN    = '02'                                                 RS0414\n* DENY    = '03'                                                 RS0414\nOPTN_RSV9                DS F\nOPTN_MAXPROCSYSGROWMAX   DS F  largest # of possible proc\nOPTN_MAXMSGIDGROWMAX     DS F  largest # of possible msgqueues\nOPTN_MAXSHMNIDSGROWMAX   DS F  largest # of pos. shared mem\nOPTN_MAXSEMNIDSGROWMAX   DS F  largest # of pos. semaphores\nOPTN_MAXSEMSPAGESGROWMAX DS F  largest # of pos. shared mem pages\nOPTN_PARMMEMLISTMVS      DS CL30  List of Parmlib Members\nOPTN_RSV10               DS CL2\nOPTN_MAXPTYSGROWMAX      DS F  largest # of pos. Ptys\nOPTN_MAXRTYSGROWMAX      DS F  largest # of pos. Rtys\nOPTN_RUNOPTSMVS          DS CL251 LE runtime options\nOPTN_RSV11               DS CL5\nOPTN_RUNOPTSMVS_LEN      DS F   Length of LE runtime options\nOPTN_RSV12               DS F\nOPTN_RSV13               DS F\nOPTN_SHRLIBRGNSIZE       DS F   ShrLibRgnSize\nOPTN_SHRLIBMAXPAGES      DS F   ShrLibMaxPages\nOPTN_LIMMSG              DS F   LimMsg                           RS0803\nOPTN_VERSIONMVS          DS CL8 Version-String                   RS0401\nOPTN_OPTCHFLAG           DS XL4 Change flags                     RS0803\nOPTN_RSV14               DS F\nOPTN_AUTHPGMLIST_LENGTH  DS CL1               z/OS R4            RS0803\nOPTN_AUTHPGMLIST         DS CL255             z/OS R4            RS0803\nOPTN_RSV15               DS CL3               z/OS R7            RS0506\nOPTN_ServLpaLibMVS       DS CL44              z/OS R7            RS0506\nOPTN_ServLinkLibMVS      DS CL44              z/OS R7            RS0506\nOPTN_ServLpaLibVolMVS    DS CL6               z/OS R7            RS0506\nOPTN_ServLinkLibVolMVS   DS CL6               z/OS R7            RS0506\nOPTN_RSV16               DS CL28              z/OS R13           RS0414\nOPTN_MAXUSERMOUNTSYS     DS F                 z/OS R13           RS0414\nOPTN_MAXUSERMOUNTUSER    DS F                 z/OS R13           RS0414\nOPTN_RSV17               DS CL12              z/OS R13           RS0414\nOPTN_MAXIOBUFUSER        DS F                 z/OS V2R1          RS0615\nOPTN_RSV18               DS CL4               z/OS V2R1          RS0615\nOPTN_MAXPIPEUSER         DS F                 z/OS V2R1          RS0615\nOPTN_RSV19               DS CL4               z/OS V2R1          RS0615\nOPTN_PWT                 DS CL6               z/OS V2R1          RS0615\n*\n*\nOPTN_SETP                DSECT\nSETPEYEC                 DS CL4     eyecatcher 'SETP'            RS0800\n                         DS CL4     ? Version+length             RS0800\n                         DS CL1                                  RS0800\nSETP_PG                  DS CL1                                  RS0800\n                         DS CL1                                  RS0800\nSETP_GOALS               DS CL1                                  RS0800\n                         DS CL4                                  RS0800\nSETP_PG1                 DS H                                    RS0800\nSETP_PG2                 DS H                                    RS0800\nSETP_PG3                 DS H                                    RS0800\nSETP_PG4                 DS H                                    RS0800\nSETP_PG5                 DS H                                    RS0800\nSETP_PG6                 DS H                                    RS0800\nSETP_PG7                 DS H                                    RS0800\nSETP_PG8                 DS H                                    RS0800\nSETP_PG9                 DS H                                    RS0800\nSETP_PG10                DS H                                    RS0800\nSETP_PG11                DS H                                    RS0800\nSETP_PG12                DS H                                    RS0800\nSETP_PG13                DS H                                    RS0800\nSETP_PG14                DS H                                    RS0800\nSETP_PG15                DS H                                    RS0800\nSETP_PG16                DS H                                    RS0800\nSETP_PG17                DS H                                    RS0800\nSETP_PG18                DS H                                    RS0800\nSETP_PG19                DS H                                    RS0800\nSETP_PG20                DS H                                    RS0800\nSETP_PG21                DS H                                    RS0800\nSETP_PG22                DS H                                    RS0800\nSETP_PG23                DS H                                    RS0800\nSETP_PG24                DS H                                    RS0800\nSETP_PG25                DS H                                    RS0800\nSETP_PG26                DS H                                    RS0800\nSETP_PG27                DS H                                    RS0800\nSETP_PG28                DS H                                    RS0800\nSETP_PG29                DS H                                    RS0800\nSETP_PG30                DS H                                    RS0800\nSETP_PG31                DS H                                    RS0800\nSETP_PG32                DS H                                    RS0800\nSETP_PG33                DS H                                    RS0800\nSETP_PG34                DS H                                    RS0800\nSETP_PG35                DS H                                    RS0800\nSETP_PG36                DS H                                    RS0800\nSETP_PG37                DS H                                    RS0800\nSETP_PG38                DS H                                    RS0800\nSETP_PG39                DS H                                    RS0800\nSETP_PG40                DS H                                    RS0800\nSETP_GOAL1               DS CL8                                  RS0800\nSETP_GOAL2               DS CL8                                  RS0800\nSETP_GOAL3               DS CL8                                  RS0800\nSETP_GOAL4               DS CL8                                  RS0800\nSETP_GOAL5               DS CL8                                  RS0800\nSETP_GOAL6               DS CL8                                  RS0800\nSETP_GOAL7               DS CL8                                  RS0800\nSETP_GOAL8               DS CL8                                  RS0800\nSETP_GOAL9               DS CL8                                  RS0800\nSETP_GOAL10              DS CL8                                  RS0800\nSETP_GOAL11              DS CL8                                  RS0800\nSETP_GOAL12              DS CL8                                  RS0800\nSETP_GOAL13              DS CL8                                  RS0800\nSETP_GOAL14              DS CL8                                  RS0800\nSETP_GOAL15              DS CL8                                  RS0800\nSETP_GOAL16              DS CL8                                  RS0800\nSETP_GOAL17              DS CL8                                  RS0800\nSETP_GOAL18              DS CL8                                  RS0800\nSETP_GOAL19              DS CL8                                  RS0800\nSETP_GOAL20              DS CL8                                  RS0800\nSETP_GOAL21              DS CL8                                  RS0800\nSETP_GOAL22              DS CL8                                  RS0800\nSETP_GOAL23              DS CL8                                  RS0800\nSETP_GOAL24              DS CL8                                  RS0800\nSETP_GOAL25              DS CL8                                  RS0800\nSETP_GOAL26              DS CL8                                  RS0800\nSETP_GOAL27              DS CL8                                  RS0800\nSETP_GOAL28              DS CL8                                  RS0800\nSETP_GOAL29              DS CL8                                  RS0800\nSETP_GOAL30              DS CL8                                  RS0800\nSETP_GOAL31              DS CL8                                  RS0800\nSETP_GOAL32              DS CL8                                  RS0800\nSETP_GOAL33              DS CL8                                  RS0800\nSETP_GOAL34              DS CL8                                  RS0800\nSETP_GOAL35              DS CL8                                  RS0800\nSETP_GOAL36              DS CL8                                  RS0800\nSETP_GOAL37              DS CL8                                  RS0800\nSETP_GOAL38              DS CL8                                  RS0800\nSETP_GOAL39              DS CL8                                  RS0800\nSETP_GOAL40              DS CL8                                  RS0800\n         MEND\n./ ADD NAME=CEEOCBRS\n         MACRO\n         CEEOCBRS\nCEEOCB   DSECT      LE option cblock (OCO)\nCEEOCB_EYEC       DS CL8               Eyecatcher\nCEEOCB_VER        DS H                 Version\nCEEOCB_LEN        DS AL2               Length of OCB\nCEEOCB_EVP        DS A                 Expansion vector pointer\n                  DS A                 Reserved for future use\nOPTION_RES1       DS 0C                Reserved option\nOPTION_RES1_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_RES1_WHSET DS H                 Where set\n*                                      50 default\n*                                      100 DOPT\n*                                      200 UOPT\n*                                      500 ROPT\nOPTION_RES1_SUBOPT DS A                Offset to sub-options\nOPTION_AIXB       DS 0C                AIXBLD\nOPTION_AIXB_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_AIXB_WHSET DS H                 Where set\n*                                      50 default\n*                                      100 DOPT\n*                                      200 UOPT\n*                                      500 ROPT\nOPTION_AIXB_SUB   DS A                 Offset to sub-options\nOPTION_ALL3       DS 0C                ALL31\nOPTION_ALL3_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_ALL3_WHSET DS H                 Where set\nOPTION_ALL3_SUB   DS A                 Offset to sub-options\nOPTION_BELH       DS 0C                BELOWHEAP\nOPTION_BELH_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_BELH_WHSET DS H                 Where set\nOPTION_BELH_SUB   DS A                 Offset to sub-options\nOPTION_CHEC       DS 0C                CHECK\nOPTION_CHEC_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_CHEC_WHSET DS H                 Where set\nOPTION_CHEC_SUB   DS A                 Offset to sub-options\nOPTION_PLIT       DS 0C                PLITASKCOUNT\nOPTION_PLIT_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_PLIT_WHSET DS H                 Where set\nOPTION_PLIT_SUB   DS A                 Offset to sub-options\nOPTION_ABTE       DS 0C                ABTERMENC\nOPTION_ABTE_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_ABTE_WHSET DS H                 Where set\nOPTION_ABTE_SUB   DS A                 Offset to sub-options\nOPTION_COUN       DS 0C                COUNTRY\nOPTION_COUN_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_COUN_WHSET DS H                 Where set\nOPTION_COUN_SUB   DS A                 Offset to sub-options\nOPTION_DEBU       DS 0C                DEBUG\nOPTION_DEBU_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_DEBU_WHSET DS H                 Where set\nOPTION_DEBU_SUB   DS A                 Offset to sub-options\nOPTION_ERRC       DS 0C                ERRCOUNT\nOPTION_ERRC_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_ERRC_WHSET DS H                 Where set\nOPTION_ERRC_SUB   DS A                 Offset to sub-options\nOPTION_FILE       DS 0C                FILEHIST\nOPTION_FILE_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_FILE_WHSET DS H                 Where set\nOPTION_FILE_SUB   DS A                 Offset to sub-options\nOPTION_ENVA       DS 0C                ENVAR\nOPTION_ENVA_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_ENVA_WHSET DS H                 Where set\nOPTION_ENVA_SUB   DS A                 Offset to sub-options\nOPTION_FLOW       DS 0C                FLOW\nOPTION_FLOW_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_FLOW_WHSET DS H                 Where set\nOPTION_FLOW_SUB   DS A                 Offset to sub-options\nOPTION_HEAP       DS 0C                HEAP\nOPTION_HEAP_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_HEAP_WHSET DS H                 Where set\nOPTION_HEAP_SUB   DS A                 Offset to sub-options\nOPTION_INQP       DS 0C                INQPCOPN\nOPTION_INQP_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_INQP_WHSET DS H                 Where set\nOPTION_INQP_SUB   DS A                 Offset to sub-options\nOPTION_INTE       DS 0C                INTERRUPT\nOPTION_INTE_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_INTE_WHSET DS H                 Where set\nOPTION_INTE_SUB   DS A                 Offset to sub-options\nOPTION_LIBS       DS 0C                LIBSTACK\nOPTION_LIBS_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_LIBS_WHSET DS H                 Where set\nOPTION_LIBS_SUB   DS A                 Offset to sub-options\nOPTION_MSGQ       DS 0C                MSGQ\nOPTION_MSGQ_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_MSGQ_WHSET DS H                 Where set\nOPTION_MSGQ_SUB   DS A                 Offset to sub-options\nOPTION_MSGF       DS 0C                MSGFILE\nOPTION_MSGF_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_MSGF_WHSET DS H                 Where set\nOPTION_MSGF_SUB   DS A                 Offset to sub-options\nOPTION_NATL       DS 0C                NATLANG\nOPTION_NATL_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_NATL_WHSET DS H                 Where set\nOPTION_NATL_SUB   DS A                 Offset to sub-options\nOPTION_ERRU       DS 0C                ERRUNIT\nOPTION_ERRU_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_ERRU_WHSET DS H                 Where set\nOPTION_ERRU_SUB   DS A                 Offset to sub-options\nOPTION_OCST       DS 0C                OCSTATUS\nOPTION_OCST_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_OCST_WHSET DS H                 Where set\nOPTION_OCST_SUB   DS A                 Offset to sub-options\nOPTION_POSI       DS 0C                POSIX\nOPTION_POSI_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_POSI_WHSET DS H                 Where set\nOPTION_POSI_SUB   DS A                 Offset to sub-options\nOPTION_RPTS       DS 0C                RPTSTG\nOPTION_RPTS_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_RPTS_WHSET DS H                 Where set\nOPTION_RPTS_SUB   DS A                 Offset to sub-options\nOPTION_RTER       DS 0C                RTEREUS\nOPTION_RTER_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_RTER_WHSET DS H                 Where set\nOPTION_RTER_SUB   DS A                 Offset to sub-options\nOPTION_SIMV       DS 0C                SIMVRD\nOPTION_SIMV_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_SIMV_WHSET DS H                 Where set\nOPTION_SIMV_SUB   DS A                 Offset to sub-options\nOPTION_STAC       DS 0C                STACK\nOPTION_STAC_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_STAC_WHSET DS H                 Where set\nOPTION_STAC_SUB   DS A                 Offset to sub-options\nOPTION_STOR       DS 0C                STORAGE\nOPTION_STOR_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_STOR_WHSET DS H                 Where set\nOPTION_STOR_SUB   DS A                 Offset to sub-options\nOPTION_AUTO       DS 0C                AUTOTASK\nOPTION_AUTO_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_AUTO_WHSET DS H                 Where set\nOPTION_AUTO_SUB   DS A                 Offset to sub-options\nOPTION_TRAC       DS 0C                TRACE\nOPTION_TRAC_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_TRAC_WHSET DS H                 Where set\nOPTION_TRAC_SUB   DS A                 Offset to sub-options\nOPTION_THRH       DS 0C                THREADHEAP\nOPTION_THRH_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_THRH_WHSET DS H                 Where set\nOPTION_THRH_SUB   DS A                 Offset to sub-options\nOPTION_TEST       DS 0C                TEST\nOPTION_TEST_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_TEST_WHSET DS H                 Where set\nOPTION_TEST_SUB   DS A                 Offset to sub-options\nOPTION_THRS       DS 0C                THREADSTACK\nOPTION_THRS_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_THRS_WHSET DS H                 Where set\nOPTION_THRS_SUB   DS A                 Offset to sub-options\nOPTION_TRAP       DS 0C                TRAP\nOPTION_TRAP_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_TRAP_WHSET DS H                 Where set\nOPTION_TRAP_SUB   DS A                 Offset to sub-options\nOPTION_UPSI       DS 0C                UPSI\nOPTION_UPSI_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_UPSI_WHSET DS H                 Where set\nOPTION_UPSI_SUB   DS A                 Offset to sub-options\nOPTION_VCTR       DS 0C                VCTRSAVE\nOPTION_VCTR_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_VCTR_WHSET DS H                 Where set\nOPTION_VCTR_SUB   DS A                 Offset to sub-options\nOPTION_PRTU       DS 0C                PRTUNIT\nOPTION_PRTU_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_PRTU_WHSET DS H                 Where set\nOPTION_PRTU_SUB   DS A                 Offset to sub-options\nOPTION_XUFL       DS 0C                XUFLOW\nOPTION_XUFL_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_XUFL_WHSET DS H                 Where set\nOPTION_XUFL_SUB   DS A                 Offset to sub-options\nOPTION_CBLO       DS 0C                CBLOPTS\nOPTION_CBLO_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_CBLO_WHSET DS H                 Where set\nOPTION_CBLO_SUB   DS A                 Offset to sub-options\nOPTION_NONI       DS 0C                NONIPTSTACK\nOPTION_NONI_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_NONI_WHSET DS H                 Where set\nOPTION_NONI_SUB   DS A                 Offset to sub-options\nOPTION_RPTO       DS 0C                RPTOPTS\nOPTION_RPTO_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_RPTO_WHSET DS H                 Where set\nOPTION_RPTO_SUB   DS A                 Offset to sub-options\nOPTION_ANYH       DS 0C                ANYHEAP\nOPTION_ANYH_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_ANYH_WHSET DS H                 Where set\nOPTION_ANYH_SUB   DS A                 Offset to sub-options\nOPTION_ABPE       DS 0C                ABPERC\nOPTION_ABPE_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_ABPE_WHSET DS H                 Where set\nOPTION_ABPE_SUB   DS A                 Offset to sub-options\nOPTION_TERM       DS 0C                TERMTHDACT\nOPTION_TERM_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_TERM_WHSET DS H                 Where set\nOPTION_TERM_SUB   DS A                 Offset to sub-options\nOPTION_DEPT       DS 0C                DEPTHCONDLMT\nOPTION_DEPT_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_DEPT_WHSET DS H                 Where set\nOPTION_DEPT_SUB   DS A                 Offset to sub-options\nOPTION_CBLP       DS 0C                CBLPSHPOP\nOPTION_CBLP_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_CBLP_WHSET DS H                 Where set\nOPTION_CBLP_SUB   DS A                 Offset to sub-options\nOPTION_CBLQ       DS 0C                CBLQDA\nOPTION_CBLQ_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_CBLQ_WHSET DS H                 Where set\nOPTION_CBLQ_SUB   DS A                 Offset to sub-options\nOPTION_PUNU       DS 0C                PUNUNIT\nOPTION_PUNU_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_PUNU_WHSET DS H                 Where set\nOPTION_PUNU_SUB   DS A                 Offset to sub-options\nOPTION_RDRU       DS 0C                RDRUNIT\nOPTION_RDRU_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_RDRU_WHSET DS H                 Where set\nOPTION_RDRU_SUB   DS A                 Offset to sub-options\nOPTION_RECP       DS 0C                RECPAD\nOPTION_RECP_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_RECP_WHSET DS H                 Where set\nOPTION_RECP_SUB   DS A                 Offset to sub-options\nOPTION_USRH       DS 0C                USRHDLR\nOPTION_USRH_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_USRH_WHSET DS H                 Where set\nOPTION_USRH_SUB   DS A                 Offset to sub-options\nOPTION_RES2       DS 0C                Reserved option\nOPTION_RES2_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_RES2_WHSET DS H                 Where set\nOPTION_RES2_SUB   DS A                 Offset to sub-options\nOPTION_PC         DS 0C                PC\nOPTION_PC_FLAG    DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_PC_WHSET   DS H                 Where set\nOPTION_PC_SUB     DS A                 Offset to sub-options\nOPTION_LIBR       DS 0C                LIBRARY\nOPTION_LIBR_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_LIBR_WHSET DS H                 Where set\nOPTION_LIBR_SUB   DS A                 Offset to sub-options\nOPTION_VERS       DS 0C                VERSION\nOPTION_VERS_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_VERS_WHSET DS H                 Where set\nOPTION_VERS_SUB   DS A                 Offset to sub-options\nOPTION_RTLS       DS 0C                RTLS\nOPTION_RTLS_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_RTLS_WHSET DS H                 Where set\nOPTION_RTLS_SUB   DS A                 Offset to sub-options\nOPTION_HCHK       DS 0C                HEAPCHK\nOPTION_HCHK_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_HCHK_WHSET DS H                 Where set\nOPTION_HCHK_SUB   DS A                 Offset to sub-options\nOPTION_PROF       DS 0C                PROFILE\nOPTION_PROF_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_PROF_WHSET DS H                 Where set\nOPTION_PROF_SUB   DS A                 Offset to sub-options\nOPTION_HEPP       DS 0C                HEAPPOOLS\nOPTION_HEPP_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_HEPP_WHSET DS H                 Where set\nOPTION_HEPP_SUB   DS A                 Offset to sub-options\nOPTION_INFO       DS 0C                INFOMSGFILTER\nOPTION_INFO_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_INFO_WHSET DS H                 Where set\nOPTION_INFO_SUB   DS A                 Offset to sub-options\nOPTION_XPLI       DS 0C                XPLINK\nOPTION_XPLI_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_XPLI_WHSET DS H                 Where set\nOPTION_XPLI_SUB   DS A                 Offset to sub-options\nOPTION_FILT       DS 0C                FILETAG\nOPTION_FILT_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_FILT_WHSET DS H                 Where set\nOPTION_FILT_SUB   DS A                 Offset to sub-options\nOPTION_HE64       DS 0C                HEAP64\nOPTION_HE64_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_HE64_WHSET DS H                 Where set\nOPTION_HE64_SUB   DS A                 Offset to sub-options\nOPTION_HEPP64     DS 0C                HEAPPOOLS64\nOPTION_HEPP64_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_HEPP64_WHSET DS H                 Where set\nOPTION_HEPP64_SUB   DS A                 Offset to sub-options\nOPTION_IOHE64     DS 0C                IOHEAP64\nOPTION_IOHE64_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_IOHE64_WHSET DS H                 Where set\nOPTION_IOHE64_SUB   DS A                 Offset to sub-options\nOPTION_LIHE64     DS 0C                LIBHEAP64\nOPTION_LIHE64_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_LIHE64_WHSET DS H                 Where set\nOPTION_LIHE64_SUB   DS A                 Offset to sub-options\nOPTION_STAC64     DS 0C                STACK64\nOPTION_STAC64_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_STAC64_WHSET DS H                 Where set\nOPTION_STAC64_SUB   DS A                 Offset to sub-options\nOPTION_THRS64     DS 0C                THREADSTACK64\nOPTION_THRS64_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_THRS64_WHSET DS H                 Where set\nOPTION_THRS64_SUB   DS A                 Offset to sub-options\nOPTION_DYNDMP     DS 0C                DYNDUMP                   RS0806\nOPTION_DYNDMP_FLAG  DS AL1               Flag for option         RS0806\n                  DS X                 Unused                    RS0806\nOPTION_DYNDMP_WHSET DS H                 Where set               RS0806\nOPTION_DYNDMP_SUB   DS A                 Offset to sub-options   RS0806\nOPTION_CEEDMP     DS 0C                CEEDUMP                   RS1007\nOPTION_CEEDMP_FLAG  DS AL1               Flag for option         RS1007\n                  DS X                 Unused                    RS1007\nOPTION_CEEDMP_WHSET DS H                 Where set               RS1007\nOPTION_CEEDMP_SUB   DS A                 Offset to sub-options   RS1007\nOPTION_PAGEFRSIZE DS 0C                PageFrameSize             RS0113\nOPTION_PAGEFRSIZE_FLAG DS AL1             Flag for option        RS0113\n                  DS X                 Unused                    RS0113\nOPTION_PAGEFRSIZE_WHSET DS H             Where set               RS0113\nOPTION_PAGEFRSIZE_SUB DS A               Offset to sub-options   RS0113\nSUBOPT_BELH       DSECT                Suboptions BELOWHEAP\nSUBOPT_BELH_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_BELH_INIT  DS F                 BELOWHEAP initial size\nSUBOPT_BELH_INC   DS F                 BELOWHEAP increment size\nSUBOPT_BELH_ALLOC DS AL1               128 = BELOW, 64 = FREE\nSUBOPT_PLIT       DSECT                Suboptions PLITASKCOUNT\nSUBOPT_PLIT_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_PLIT_COUNT DS F                 PLITASKCOUNT # condition limit\nSUBOPT_ABTE       DSECT                Suboptions ABTERMENC\nSUBOPT_ABTE_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_ABTE_OPT   DS F                 2=ABEND, 1=RETCODE\nSUBOPT_COUN       DSECT                Suboptions COUNTRY\nSUBOPT_COUN_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_COUN_ID    DS CL2               COUNTRY identifier\n                  DS AL2               Unused\nSUBOPT_ERRC       DSECT                Suboptions ERRCOUNT\nSUBOPT_ERRC_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_ERRC_COUNT DS F                 ERRCOUNT # non-fatal errors\nSUBOPT_ENVA       DSECT                Suboptions ENVAR\nSUBOPT_ENVA_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_ENVA_OFFS  DS F                 Offset to envar string\nSUBOPT_ENVA_LEN   DS H                 length of envar\nSUBOPT_ENVA_STR   DS CL250             envar string\nSUBOPT_FLOW       DSECT                Suboptions FLOW\nSUBOPT_FLOW_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_FLOW_COUNT DS F                 FLOWC max # procedures\nSUBOPT_HEAP       DSECT                Suboptions HEAP\nSUBOPT_HEAP_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_HEAP_INIT  DS F                 HEAP initial size\nSUBOPT_HEAP_INC   DS F                 HEAP increment size\nSUBOPT_HEAP_ALLOC DS AL1               128 = BELOW, 64 = FREE\n                  DS AL3               Unused\nSUBOPT_HEAP24_INIT DS F                HEAP24 initial size\nSUBOPT_HEAP24_INC DS F                 HEAP24 increment size\nSUBOPT_LIBS       DSECT                Suboptions LIBSTACK\nSUBOPT_LIBS_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_LIBS_INIT  DS F                 LIBSTACK initial size\nSUBOPT_LIBS_INC   DS F                 LIBSTACK increment size\nSUBOPT_LIBS_ALLOC DS AL1               128 = BELOW, 64 = FREE\n                  DS AL3               Unused\nSUBOPT_MSGQ       DS 0C                Suboptions MSGQ\nSUBOPT_MSGQ_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_MSGQ_COUNT DS F                 MSGQ maximum # MIB entries\nSUBOPT_MSGF       DSECT                Suboptions MSGFILE\nSUBOPT_MSGF_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_MSGF_DDO   DS A                 Offset to DDNAME\nSUBOPT_MSGF_RFMO  DS A                 Offset to RECFM\nSUBOPT_MSGF_RECL  DS F                 RECL\nSUBOPT_MSGF_BLKS  DS F                 Block size\nSUBOPT_MSGF_DDL   DS H                 Effective length of following\nSUBOPT_MSGF_DD    DS CL8               MSGFILE DDname\nSUBOPT_MSGF_ENQ   DS CL2               Space = NOENQ ' *' = ENQ\nSUBOPT_MSGF_RFML  DS H                 Effective length of following\nSUBOPT_MSGF_RFM   DS CL5               Record format\n                  DS CL1               Unused\nSUBOPT_NATL       DSECT                Suboptions NATLANG\nSUBOPT_NATL_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_NATL_ID    DS CL3               COUNTRY identifier\n                  DS AL1               Unused\nSUBOPT_ERRU       DSECT                Suboptions ERRUNIT\nSUBOPT_ERRU_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_ERRU_COUNT DS F                 ERRUNIT # non-fatal errors\nSUBOPT_STAC       DSECT                Suboptions STACK\nSUBOPT_STAC_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_STAC_INIT  DS F                 STACK initial size\nSUBOPT_STAC_INC   DS F                 STACK increment size\nSUBOPT_STAC_ALLOC DS AL1               128 = BELOW, 64 = FREE\n                  DS AL3               Unused\nSUBOPT_STAC_DINIT DS F                 DownSTACK initial size\nSUBOPT_STAC_DINC  DS F                 DownSTACK increment size\nSUBOPT_STOR       DSECT                Suboptions STACK\nSUBOPT_STOR_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_STOR_CSF   DS AL1               Characters-specified flags\nSUBOPT_STOR_AHSC  DS X                 Allocated heap storage character\nSUBOPT_STOR_FHSC  DS X                 Freed heap storage character\nSUBOPT_STOR_ADSC  DS X                 Allocated DSA storage character\nSUBOPT_STOR_SOSSZ DS F                 Short on storage reserve size\nSUBOPT_AUTO       DSECT                Suboptions AUTOTASK\nSUBOPT_AUTO_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_AUTO_LMO   DS A                 Offset to loadmod\nSUBOPT_AUTO_NO    DS F                 Number of subtasks\nSUBOPT_AUTO_LEN   DS H                 Length of Loadmod\nSUBOPT_AUTO_LMOD  DS CL8               Loadmod\n                  DS AL2               Unused\nSUBOPT_TRAC       DSECT                Suboptions TRACE\nSUBOPT_TRAC_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_TRAC_SIZE  DS F                 Trace buffer size\nSUBOPT_TRAC_GFLG  DS XL4               Global trace level bits\nSUBOPT_TRAC_FLG1  DS X                 Trace flags ('80xxxxxx' = DUMP)\nSUBOPT_TRAC_FLG2  DS X                 Trace flags ('xx00xxxx'       )\nSUBOPT_TRAC_FLG3  DS X                 Trace flags ('xxxx00xx'       )\nSUBOPT_TRAC_FLG4  DS X                 Trace flags ('xxxxxx00'       )\nSUBOPT_TRAC_TRVO  DS A                 Offset of Trace level verify\nSUBOPT_TRAC_TRSO  DS A                 Offset of Trace level set\nSUBOPT_TRAC_TRAO  DS A                 Offset of Trace level array\nSUBOPT_TRAC_TRVA  DS AL1               Verify flags for the following\n                  DS AL1                array of trace level\n                  DS AL1\n                  DS AL1\nSUBOPT_TRAC_TRSA  DS XL4               Trace level set flags array\nSUBOPT_TRAC_TRAA  DS XL4               Unused trace level bits\n                  DS XL4               CEL trace level bits\n                  DS XL4               Unused trace level bits\n                  DS XL4               C/370 trace level bits\n                  DS XL4               Unused trace level bits\n                  DS XL4               Unused trace level bits\n                  DS XL4               Unused trace level bits\n                  DS XL4               Unused trace level bits\n                  DS XL4               DCE trace level bits\n                  DS XL4               Unused trace level bits\n                  DS XL4               Unused trace level bits\n                  DS XL4               Unused trace level bits\n                  DS XL4               Sockets trace level bits\n                  DS XL4               Unused trace level bits\n                  DS XL4               Unused trace level bits\n                  DS XL4               Unused trace level bits\n                  DS XL4               Unused trace level bits\n                  DS XL4               Unused trace level bits\nSUBOPT_THRH       DSECT                Suboptions THREADHEAP\nSUBOPT_THRH_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_THRH_INIT  DS F                 THREADHEAP initial size\nSUBOPT_THRH_INC   DS F                 THREADHEAP increment size\nSUBOPT_THRH_ALLOC DS AL1               128 = BELOW, 64 = FREE\n                  DS AL3               Unused\nSUBOPT_TEST       DSECT                Suboptions TEST\nSUBOPT_TEST_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_TEST_OPT   DS F                 1 = NONE, 2 = ERROR, 4 = ALL\nSUBOPT_TEST_CFO   DS A                 Offset of commands_file\nSUBOPT_TEST_CLO   DS A                 Offset of command_list|prompt\nSUBOPT_TEST_PFO   DS A                 Offset of preference_file\nSUBOPT_TEST_CFL   DS H                 Effective length of following\nSUBOPT_TEST_CF    DS CL80              Commands_file name\n                  DS CL2               unused\nSUBOPT_TEST_CLL   DS H                 Effective length of following\nSUBOPT_TEST_CL    DS CL250             Command_list name|prompt option\nSUBOPT_TEST_PFL   DS H                 Effective length of following\nSUBOPT_TEST_PF    DS CL80              Preference_file name\n                  DS CL2               Unused\nSUBOPT_THRS       DSECT                Suboptions THREADSTACK\nSUBOPT_THRS_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_THRS_INIT  DS F                 ThreadStack initial size\nSUBOPT_THRS_INC   DS F                 ThreadStack increment size\nSUBOPT_THRS_ALLOC DS AL1               128 = BELOW, 64 = FREE\n                  DS AL3               Unused\nSUBOPT_THRS_DINIT DS F                 Down STACK initial size\nSUBOPT_THRS_DINC  DS F                 Down  STACK increment size\nSUBOPT_TRAP       DSECT                Suboptions TRAP\nSUBOPT_TRAP_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_TRAP_FLG   DS AL1               Trap  flags ('80xxxxxx' = SPIE)\n                  DS AL3               Unused\nSUBOPT_UPSI       DSECT                Suboptions UPSI\nSUBOPT_UPSI_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_UPSI_SW    DS CL8               8 UPSI switches\nSUBOPT_PRTU       DSECT                Suboptions PRTUNIT\nSUBOPT_PRTU_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_PRTU_COUNT DS F                 PRTUNIT # non-fatal errors\nSUBOPT_XUFL       DSECT                Suboptions XUFLOW\nSUBOPT_XUFL_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_XUFL_COUNT DS F                 4 = OFF, 2 = ON, 1 = AUTOs\nSUBOPT_NONI       DSECT                Suboptions NONIPTSTACK\nSUBOPT_NONI_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_NONI_INIT  DS F                 NONIPTSTACK initial size\nSUBOPT_NONI_INC   DS F                 NONIPTSTACK increment size\nSUBOPT_NONI_ALLOC DS AL1               128 = BELOW, 64 = FREE\n                  DS AL3               Unused\nSUBOPT_ANYH       DSECT                Suboptions ANYHEAP\nSUBOPT_ANYH_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_ANYH_INIT  DS F                 ANYHEAP initial size\nSUBOPT_ANYH_INC   DS F                 ANYHEAP increment size\nSUBOPT_ANYH_ALLOC DS AL1               128 = BELOW, 64 = FREE\n                  DS AL3               Unused\nSUBOPT_ABPE       DSECT                Suboptions ABPERC\nSUBOPT_ABPE_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_ABPE_US    DS AL1               128=NONE, 64=U, 32=S, 16=other\n                  DS AL3               Unused\nSUBOPT_ABPE_CODE  DS F                 Numeric portion of U or S abcode\nSUBOPT_ABPE_ABC   DS CL8               Abcode (blank-padded)\nSUBOPT_TERM       DSECT                Suboptions TERMTHDACT\nSUBOPT_TERM_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_TERM_FLG   DS F                 8=QUIET, 4=MSG, 2=TRACE, 1=DUMP\nSUBOPT_TERM_CESE  DS AL1               128=CESE,64=CICSDDS\n                  DS AL3               Unused\nSUBOPT_TERM_STOR  DS H                 reg_stor_amount suboption\n                  DS AL2               Unused\nSUBOPT_DEPT       DSECT                Suboptions DEPTHCONDLMT\nSUBOPT_DEPT_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_DEPT_COUNT DS F                 DEPTHCONDLMT # condition limit\nSUBOPT_PUNU       DSECT                Suboptions PUNUNIT\nSUBOPT_PUNU_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_PUNU_COUNT DS F                 PUNUNIT # non-fatal errors\nSUBOPT_RDRU       DSECT                Suboptions RDRUNIT\nSUBOPT_RDRU_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_RDRU_COUNT DS F                 RDRUNIT # non-fatal errors\nSUBOPT_RECP       DSECT                Suboptions RECPAD\nSUBOPT_RECP_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_RECP_FLG   DS F                 4 = OFF, 2 = ON, 1 = VAR\nSUBOPT_USRH       DSECT                Suboptions USRHDLR\nSUBOPT_USRH_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_USRH_UN1O  DS A                 Offset of UHname\nSUBOPT_USRH_UN2O  DS A                 Offset of UHname2\nSUBOPT_USRH_UN1L  DS H                 Effective length of following\nSUBOPT_USRH_UN1   DS CL8               USRHDLR UHname\n                  DS CL2\nSUBOPT_USRH_UN2L  DS H                 Effective length of following\nSUBOPT_USRH_UN2   DS CL8               USRHDLR UHname2\n                  DS CL2\nSUBOPT_RES2       DSECT                Suboptions\nSUBOPT_RES2_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_RES2_LVL   DS F                 Level information\nSUBOPT_LIBR       DSECT                Suboptions LIBRARY\nSUBOPT_LIBR_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_LIBR_LMO   DS A                 Offset of load module name\nSUBOPT_LIBR_LML   DS H                 Effective length of following\nSUBOPT_LIBR_LM    DS CL8               Name of load module\n                  DS CL2\nSUBOPT_VERS       DSECT                Suboptions VERSION\nSUBOPT_VERS_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_VERS_LMO   DS A                 Offset of load module name\nSUBOPT_VERS_LML   DS H                 Effective length of following\nSUBOPT_VERS_LM    DS CL8               Name of load module\n                  DS CL2\nSUBOPT_HCHK       DSECT                Suboptions HEAPCHK\nSUBOPT_HCHK_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_HCHK_FREQ  DS F                 HeapChk frequency\nSUBOPT_HCHK_INIT  DS F                 HeapChk initial delay\nSUBOPT_HCHK_CLVL  DS F                 HeapChk call level\nSUBOPT_HCHK_PLVL  DS F                 HeapChk pool call level\nSUBOPT_HCHK_PENT  DS F                 HeapChk pool entries\nSUBOPT_HCHK_PNUM  DS F                 HeapChk pool number\nSUBOPT_HCHK_PENT31 DS F                HeapChk pool entries\nSUBOPT_HCHK_PNUM31 DS F                HeapChk pool number\nSUBOPT_PROF       DSECT                Suboptions PROFILE\nSUBOPT_PROF_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_PROF_STRO  DS A                 Offset of Profiler string\nSUBOPT_PROF_STRL  DS H                 Effective length of following\nSUBOPT_PROF_STR   DS CL250             PROFILE String\nSUBOPT_HEPP       DSECT                Suboptions HEAPPOOLS\nSUBOPT_HEPP_FLG1  DS AL1               Suboption valid bits\nSUBOPT_HEPP_FLG2  DS AL1               Suboption valid bits\n                  DS AL2               Unused suboption valid bits\nSUBOPT_HEPP_CP1S  DS F                 cell pool 1 size\nSUBOPT_HEPP_CP1P  DS F                 cell pool 1 percentage\nSUBOPT_HEPP_CP2S  DS F                 cell pool 2 size\nSUBOPT_HEPP_CP2P  DS F                 cell pool 2 percentage\nSUBOPT_HEPP_CP3S  DS F                 cell pool 3 size\nSUBOPT_HEPP_CP3P  DS F                 cell pool 3 percentage\nSUBOPT_HEPP_CP4S  DS F                 cell pool 4 size\nSUBOPT_HEPP_CP4P  DS F                 cell pool 4 percentage\nSUBOPT_HEPP_CP5S  DS F                 cell pool 5 size\nSUBOPT_HEPP_CP5P  DS F                 cell pool 5 percentage\nSUBOPT_HEPP_CP6S  DS F                 cell pool 6 size\nSUBOPT_HEPP_CP6P  DS F                 cell pool 6 percentage\nSUBOPT_HEPP_CP7S  DS F                 cell pool 7 size\nSUBOPT_HEPP_CP7P  DS F                 cell pool 7 percentage\nSUBOPT_HEPP_CP8S  DS F                 cell pool 8 size\nSUBOPT_HEPP_CP8P  DS F                 cell pool 8 percentage\nSUBOPT_HEPP_CP9S  DS F                 cell pool 9 size\nSUBOPT_HEPP_CP9P  DS F                 cell pool 9 percentage\nSUBOPT_HEPP_CP10S DS F                 cell pool 10 size\nSUBOPT_HEPP_CP10P DS F                 cell pool 10 percentage\nSUBOPT_HEPP_CP11S DS F                 cell pool 11 size\nSUBOPT_HEPP_CP11P DS F                 cell pool 11 percentage\nSUBOPT_HEPP_CP12S DS F                 cell pool 12 size\nSUBOPT_HEPP_CP12P DS F                 cell pool 12 percentage\nSUBOPT_INFO       DSECT                Suboptions INFOMSGFILTER\nSUBOPT_INFO_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_INFO_ID1   DS CL1               Single char environment ids\nSUBOPT_INFO_ID2   DS CL1\nSUBOPT_INFO_ID3   DS CL1\nSUBOPT_INFO_ID4   DS CL1\nSUBOPT_FILT       DSECT                Suboptions FILETAG\nSUBOPT_FILT_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_FILT_FLG   DS AL1               FILETAG Flags\n                  DS CL3               Unused\nSUBOPT_HE64       DSECT                Suboptions HEAP\nSUBOPT_HE64_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_HE64_INIT  DS FDL8              HEAP initial size\nSUBOPT_HE64_INC   DS FDL8              HEAP increment size\nSUBOPT_HE64_ALLOC DS AL1               128 = BELOW, 64 = FREE\n                  DS AL3               Unused\nSUBOPT_HE6431_INIT DS F                HEAP24 initial size\nSUBOPT_HE6431_INC  DS F                 HEAP24 increment size\nSUBOPT_HE6431_ALLOC DS AL1               128 = BELOW, 64 = FREE\n                   DS AL3               Unused\nSUBOPT_HE6424_INIT DS F                HEAP24 initial size\nSUBOPT_HE6424_INC  DS F                 HEAP24 increment size\nSUBOPT_HE6424_ALLOC DS AL1               128 = BELOW, 64 = FREE\n                   DS AL3               Unused\nSUBOPT_HEPP64     DSECT                Suboptions HEAPPOOLS\nSUBOPT_HEPP64_FLG1  DS AL1               Suboption valid bits\nSUBOPT_HEPP64_FLG2  DS AL1               Suboption valid bits\n                  DS AL2               Unused suboption valid bits\nSUBOPT_HEPP64_CP1S  DS F                 cell pool 1 size\nSUBOPT_HEPP64_CP1P  DS F                 cell pool 1 percentage\nSUBOPT_HEPP64_CP2S  DS F                 cell pool 2 size\nSUBOPT_HEPP64_CP2P  DS F                 cell pool 2 percentage\nSUBOPT_HEPP64_CP3S  DS F                 cell pool 3 size\nSUBOPT_HEPP64_CP3P  DS F                 cell pool 3 percentage\nSUBOPT_HEPP64_CP4S  DS F                 cell pool 4 size\nSUBOPT_HEPP64_CP4P  DS F                 cell pool 4 percentage\nSUBOPT_HEPP64_CP5S  DS F                 cell pool 5 size\nSUBOPT_HEPP64_CP5P  DS F                 cell pool 5 percentage\nSUBOPT_HEPP64_CP6S  DS F                 cell pool 6 size\nSUBOPT_HEPP64_CP6P  DS F                 cell pool 6 percentage\nSUBOPT_HEPP64_CP7S  DS F                 cell pool 7 size\nSUBOPT_HEPP64_CP7P  DS F                 cell pool 7 percentage\nSUBOPT_HEPP64_CP8S  DS F                 cell pool 8 size\nSUBOPT_HEPP64_CP8P  DS F                 cell pool 8 percentage\nSUBOPT_HEPP64_CP9S  DS F                 cell pool 9 size\nSUBOPT_HEPP64_CP9P  DS F                 cell pool 9 percentage\nSUBOPT_HEPP64_CP10S DS F                 cell pool 10 size\nSUBOPT_HEPP64_CP10P DS F                 cell pool 10 percentage\nSUBOPT_HEPP64_CP11S DS F                 cell pool 11 size\nSUBOPT_HEPP64_CP11P DS F                 cell pool 11 percentage\nSUBOPT_HEPP64_CP12S DS F                 cell pool 12 size\nSUBOPT_HEPP64_CP12P DS F                 cell pool 12 percentage\nSUBOPT_IOHE64       DSECT                Suboptions IOHEAP64\nSUBOPT_IOHE64_FLAG  DS AL1               Suboption valid bits\nSUBOPT_IOHE64_OPT   DS AL1               Suboption valid bits (part 2)\n                    DS AL2               Unused suboption valid bits\nSUBOPT_IOHE64_INIT  DS FDL8              IOHEAP64 initial size 64\nSUBOPT_IOHE64_INC   DS FDL8              IOHEAP64 increment size 64\nSUBOPT_IOHE64_ALLOC DS AL1               128 = BELOW, 64 = FREE\n                    DS AL3               Unused\nSUBOPT_IOHE6431_INIT DS F                IOHEAP64 initial size 31\nSUBOPT_IOHE6431_INC  DS F                IOHEAP64 increment size 31\nSUBOPT_IOHE6431_ALLOC DS AL1             128 = BELOW, 64 = FREE\n                    DS AL3               Unused\nSUBOPT_IOHE6424_INIT DS F                IOHEAP64 initial size 24\nSUBOPT_IOHE6424_INC  DS F                IOHEAP64 increment size 24\nSUBOPT_IOHE6424_ALLOC DS AL1             128 = BELOW, 64 = FREE\nSUBOPT_LIHE64       DSECT                Suboptions LIBHEAP64\nSUBOPT_LIHE64_FLAG  DS AL1               Suboption valid bits\nSUBOPT_LIHE64_OPT   DS AL1               Suboption valid bits (part 2)\n                    DS AL2               Unused suboption valid bits\nSUBOPT_LIHE64_INIT  DS FDL8              LIBHEAP64 initial size 64\nSUBOPT_LIHE64_INC   DS FDL8              LIBHEAP64 increment size 64\nSUBOPT_LIHE64_ALLOC DS AL1               128 = BELOW, 64 = FREE\n                    DS AL3               Unused\nSUBOPT_LIHE6431_INIT DS F                LIBHEAP64 initial size 31\nSUBOPT_LIHE6431_INC  DS F                LIBHEAP64 increment size 31\nSUBOPT_LIHE6431_ALLOC DS AL1             128 = BELOW, 64 = FREE\n                    DS AL3               Unused\nSUBOPT_LIHE6424_INIT DS F                LIBHEAP64 initial size 24\nSUBOPT_LIHE6424_INC  DS F                LIBHEAP64 increment size 24\nSUBOPT_LIHE6424_ALLOC DS AL1             128 = BELOW, 64 = FREE\n                    DS AL3               Unused\nSUBOPT_STAC64       DSECT                Suboptions STACK64\nSUBOPT_STAC64_FLAG  DS AL1               Suboption valid bits\n                    DS AL3               Unused suboption valid bits\nSUBOPT_STAC64_INIT  DS FDL8              STACK64 initial size\nSUBOPT_STAC64_INC   DS FDL8              STACK64 increment size\nSUBOPT_STAC64_MAX   DS FDL8              STACK64 maximum\nSUBOPT_THRS64       DSECT                Suboptions THREADSTACK64\nSUBOPT_THRS64_FLAG  DS AL1               Suboption valid bits\n                    DS AL3               Unused suboption valid bits\nSUBOPT_THRS64_INIT  DS FDL8              THREADSTACK64 initial size\nSUBOPT_THRS64_INC   DS FDL8              THREADSTACK64 increment size\nSUBOPT_THRS64_MAX   DS FDL8              THREADSTACK64 maximum\nSUBOPT_DYNDMP       DSECT                Suboptions DYNDUMP      RS0806\nSUBOPT_DYNDMP_FLAG  DS AL1               Suboption valid bits    RS0806\n                    DS AL3               Unused suboption valid bits806\nSUBOPT_DYNDMP_HLQP  DS A                 DYNDUMP HLQ-Option Ptr  RS0806\nSUBOPT_DYNDMP_FLG1  DS X                 DYNDUMP FLAG 4039       RS0806\nSUBOPT_DYNDMP_FLG2  DS X                 DYNDUMP FLAG 40xx       RS0806\nSUBOPT_DYNDMP_HLQO  DSECT                DYNDUMP HLQ             RS0806\nSUBOPT_DYNDMP_HLQL  DS H                 Length of DYNDUMP HLQ   RS0806\nSUBOPT_DYNDMP_HLQS  DS CL26              String of DYNDUMP HLQ   RS0806\nSUBOPT_CEEDMP       DSECT                Suboptions CEEDUMP      RS1007\nSUBOPT_CEEDMP_FLAG  DS AL1               Suboption valid bits    RS1007\n                    DS AL3               Unused suboption valid bits007\nSUBOPT_CEEDMP_PAGL  DS F                 CEEDUMP Pagelength      RS1007\nSUBOPT_CEEDMP_SYSO  DS CL4               CEEDUMP Sysout-Fname    RS1007\nSUBOPT_CEEDMP_SYSC  DS CL1               CEEDUMP Sysout-Class    RS1007\nSUBOPT_CEEDMP_FREE  DS X                 CEEDUMP 0=FREE=END      RS1007\nSUBOPT_CEEDMP_SPIN  DS X                 CEEDUMP 0=SPIN=UNALLOC  RS1007\n                    DS X                 CEEDUMP padding         RS1007\nSUBOPT_PAGEFRSIZE   DSECT                Suboptions PageFrame    RS1007\nSUBOPT_PAGEFRSIZE_FLAG DS AL1            Suboption               RS0113\n                    DS AL3               Unused suboption valid bits113\nSUBOPT_PAGEFRSIZE_HEAP DS H              Suboption               RS0113\nSUBOPT_PAGEFRSIZE_ANYHEAP DS H           Suboption               RS0113\nSUBOPT_PAGEFRSIZE_STACK   DS H           Suboption               RS0113\n         MEND\n./ ADD NAME=CICS\n         MACRO\n         CICS\n*\n** CICS: DFHSAB - CICS subsystem Anchor Block\n** (Based on CICS 4.1)\n*\nSAB      DSECT ,\nSABCDD   DS    F                          Addr of CEC 'inop' data\nSABSCTE  DS    F                          Addr of SCTE\nSAB_ID   DS    C'DFHSAB'                  Eyecatcher\n         ORG   SAB+X'18'\nSABMAPPT DS    F                          Addr of bit map: act CICS\n         ORG   ,\nSABL     EQU   32\n*\n** CICS: SCTE - Subsystem Control Table Extension\n** (Based on CICS 4.1, Update 5.1, Update 6.2                    RS0904\n*\nSCTE     DSECT                                                   RS0904\nSCTELACB DS    A                                                 RS0904\nSCTECNT  DS    FL3                                               RS0904\nSCTEMOD# DS    FL1                                               RS0904\nSCTEMOD1 EQU   1              SCTE modification 1 - CICS/TS 2.2  RS0904\n         DS    F              Reserved - must not be deleted     RS0904\nSCTESVCI DS    H              INSTRUCTION TO INVOKE CICS SVC -   RS0904\nSCTEVER# DS    AL1            SCTE version no.                   RS0904\nSCTEVER1 EQU   1              SCTE version 1 - CICS 4.1          RS0904\nSCTEVER2 EQU   2              SCTE version 2 - CICS 5.1          RS0904\nSCTEVER3 EQU   3              SCTE version 3 - CICS/TS 2.2       RS0904\nSCTEFLGS DS    B              Various flags                      RS0904\nSCTEFSP4 EQU   X'80'          MVS includes XCF support (SP4 plus)RS0904\nSCTEFXCF EQU   X'40'          XCF level satisfies all IRP's needsRS0904\nSCTEL    EQU   *-SCTE         Length of SCTE entry               RS0904\n*\n** CICS: LCB - Logon Control Block\n** (Based on CICS 4.1, updated for 5.3)\n*\nLCB      DSECT ,\n         ORG   LCB+X'60'\nLCBAPPLD53 DS  CL8' '\n         ORG   ,\n         ORG   LCB+X'7C'\nLCBAPPLD41 DS  CL8' '\n         ORG   ,\nLCBLNGTH EQU   X'D8'\n*\n** CICS: LACB - Logon Address Space Control Block\n** (Based on CICS 4.1, updated for 5.3)\n*\nLACB     DSECT ,\n         ORG   LACB+X'08'                                        RS0400\nLACBSUD2 DS    F               SUDB ptr for CICS 5.2/CTS 1.2     RS0400\nLACBSUDB DS    F               SUDB ptr for CICS 4.1\nLACBL    EQU   X'58'\n*\nLACBE    DSECT ,\nLACBENM  DS    CL8\nLACBELEN EQU   X'14'\n*\n** CICS: SUDB - SubSystem User Definition Control Block\n** (Based on CICS 4.1)\n*\nSUDB     DSECT ,\nSUDBCHN  DS    A\nSUDBLACB DS    A\n         ORG   SUDB+X'0E'\n         DS    H\n         DS    F\nSUDBASCB DS    F\nSUDBJSB  DS    F\nSUDBAWS  DS    F\nSUDBLCB  DS    F\n         ORG   ,\nSUDBLEN  EQU   X'58'\n         MEND\n./ ADD NAME=CUNUCCH                                              RS0705\n         MACRO\n         CUNUCCH\nUCCH         DSECT\nUCCHEYEC     DS  CL16                  eyecatcher '*** UNICODE ****'\n             DS  X                     Flag ???\nUCCHEYEC2    DS  CL3                   eyecatcher 'IR4'\nUCCHTOD      DS  XL8                   Tod ?\n             DS  XL8                   ?\nUCCHCDTT     DS  CL20                  Image Create Date/Time\nUCCHSTK      DS  XL8                   DS Token\nUCCHALET     DS  XL4                   DS Alet\n             DS  7F                    ??\nUCCHACTP     DS  F                     Active Pages\nUCCH#UCCE_INT DS F                     Number of UCCEs\nUCCH#UCCE    DS  F                     Number of top level UCCEs\nUCCH#UCAE    DS  F                     Number of UCAEs\n             DS  F                     AR\nUCCHUCCE     DS  F                     Ptr to first UCCE\n             DS  F                     AR\nUCCHUCAE     DS  F                     Ptr to first UCAE\n             DS  8F                    ??\n         MEND\n./ ADD NAME=CUNUCCE                                              RS0705\n         MACRO\n         CUNUCCE\nUCCE         DSECT\nUCCEEYEC     DS  CL4                   eyecatcher 'UCCE'\nUCCELEN      DS  F                     Length of UCCE\n             DS  2F                    ??\nUCCECPFR     DS  F                     From Codepage\nUCCECPTO     DS  F                     To Codepage\nUCCESR       DS  CL8                   Search technics\nUCCECP       DS  F                     Codepage long\n         MEND\n./ ADD NAME=CVT\n         MACRO\n&CVTNAME CVT   &PREFIX=NO,&DSECT=NO,&LIST=NO\n         MNOTE 12,'Your Syslib-Concatenation is wrong. Please put'\n         MNOTE 12,'SYS1.MACLIB and SYS1.MODGEN in front of the   '\n         MNOTE 12,'<userid>.SHOWMVS.MACLIB.'\n         MEND\n./ ADD NAME=CSVT\n         MACRO\n         CSVT\nCSVT     DSECT                         CSV Table OCO             RS1007\nCSVTCBID DS    C'CSVT'                 CB Id                     RS1007\nCSVTLLTS DS    A                       PTR to LLTX               RS1007\n         DS    A                       PGM ??                    RS1007\nCSVTAPFA DS    A                       PTR to APFA               RS1007\n         DS    A                       ?                         RS1007\n         DS    A                       PGM CSVINFOM              RS1007\n         DS    A                       ?                         RS1007\n         DS    A                       PGM CSVEXFP               RS1007\n         DS    A                       PGM ??                    RS1007\nCSVTVOLS DS    CL6                     VOLSER ??                 RS1007\n         DS    CL2                     ??                        RS1007\n         DS    3A                      ??                        RS1007\nCSVTCDXHT DS    A                      PTR to CDXHT              RS1007\n         DS    A                       ??                        RS1007\nCSVTEXTA DS    A                       PTR to EXTA               RS1007\n         DS    A                       ??                        RS1007\nCSVTDYNLA DS    A                      PTR to DYNLA              RS1007\n         DS    CL44                    SYS1.LINKLIB              RS1007\n         DS    CL44                    SYS1.MIGLIB               RS1007\n         DS    CL44                    SYS1.CSSLIB               RS1007\n         DS    CL4                     ?? Flags ??               RS1007\n         DS    CL6                     VOLSER                    RS1007\n         DS    CL6                     VOLSER                    RS1007\n         DS    CL6                     VOLSER                    RS1007\nCSVTFLAG DS    X                       Flag                      RS1007\nCSVTRFRP EQU   X'80'                   System wide REFRPROT      RS1007\n         MEND\n./ ADD NAME=DB2NTOKN\n         MACRO\n         DB2NTOKN\nDB2NTOKN DSECT                         Data from DB2 name/token pair\n         DS    F\nDB2GANT  DS    CL4                     Identifier GANT\nDB2SSN   DS    CL4                     Subsystem name\n         DS    F\nDB2MBENT DS    CL128                   Max. 16 members\n*DB2MBRN DS    CL4                     Member name\n*DB2ERLP DS    F                       Pointer to Erly code offset??\n         MEND\n./ ADD NAME=DSNDERLY\n         MACRO\n         DSNDERLY\nERLY     DSECT                         DB2/MQSeries\n         DS    F\nERLYCBID DS    C'ERLY'                 CB Id\n         ORG   ERLY+56\nERLYSCOM DS    V(SCOM)                 SCOM addr\n         ORG   ERLY+84\nERLYMODN DS    C'DSN'                  EARLY MODNAME DSN or CSQ\n         ORG   ERLY+92\nERLYPROD DS    C'5740XYR01'            Product code\n         MEND\n./ ADD NAME=DSNDRIB\n         MACRO                     DB2 Release Information Block   $RS\n         DSNDRIB\nRIB      DSECT\nRIBCODE  DS    H                   BLOCK IDENTIFIER\nRIBTLEN  DS    H                   BLOCK LENGTH\nRIBEYEC  DS    CL4                 EYE-CATCHER \"RIB \"\nRIBCID   DS    0C                  COMPONENT IDENTIFIER:\nRIBECODE DS    CL4                 ENVIRONMENT CODE\nRIBPCODE DS    CL3                 PRODUCT CODE\nRIBFCODE DS    CL2                 FEATURE CODE\nRIBREL   DS    CL3                 RELEASE IDENTIFIER:\n*                                  VERSION, RELEASE, MODIFICATION\n*                                  for V9 or earlier.  '999'\n*                                  indicates V10 or later, use\n*                                  RIBRELX.\nRIBCPTR  DS    F                   ADDR OF CHANGE LEVEL\n*                                  INFORMATION ARRAY RIBCINFO\nRIBCNUMB DS    XL1                 NUMBER OF ELEMENTS\n*                                  IN CHANGE LEVEL ARRAY\nRIBRESV1 DS    XL3                 RESERVED\nRIBCLID  DS    F                   RELEASE ID\nRIBSPEL  DS    F                   SPE LEVEL ID\nRIBCATVS DS    CL20                CURRENT CATALOG LEVELS UNDERSTOOD\nRIBRELX  DS    CL4                 DB2 VER REL MOD: VVRM\n*                                  e.g. 1010 for V10R1M0\n         ORG   RIBRELX\nRIBREL3  DS    CL3                 e.g. 101  for V10R1\n         ORG   RIBRELX\nRIBRELV  DS    CL2                 e.g. 10   for V10\nRIBRELR  DS    CL1                 e.g.   1  for    R1\nRIBRELM  DS    CL1                 e.g.    0 for      M0\nRIBRESV2 DS    CL2                 RESERVED\nRIBCINFO DS    0F                  CHANGE LEVEL INFO ARRAY\n*                                  CURRENTLY EMPTY\n         MEND\n./ ADD NAME=DFSOPT\n         MACRO\n         DFSOPT\nICEOPT   DSECT\nADATA    DS    A                       Address of Data Section\nAIDENT   DS    A                       Address of Ident Section\nASELTDX  DS    A                       Address of Seltdx Section\nDFSIDENT DSECT                         Start of Ident Section\nDFSPGM   DS    CL8                     Module Name\nDFSREL   DS    CL8                     Release\nDFSAPAR  DS    CL8                     APAR Level\nDFSDATE  DS    CL8                     Compilation Date\nDFSSELTDX DSECT                       Start of Select TDX Section\nDFSSTDX  DS    CL16                    TDX\nDFSTOD   DSECT                         Start of TOD Section\nDFSSUN   DS    0CL16                   Sunday\nDFSSUN1  DS    AL2\nDFSSUN2  DS    AL2\nDFSSUN3  DS    AL2\nDFSSUN4  DS    AL2\nDFSSUN5  DS    AL2\nDFSSUN6  DS    AL2\nDFSSUN7  DS    AL2\nDFSSUN8  DS    AL2\nDFSMON   DS    0CL16                   Monday\nDFSMON1  DS    AL2\nDFSMON2  DS    AL2\nDFSMON3  DS    AL2\nDFSMON4  DS    AL2\nDFSMON5  DS    AL2\nDFSMON6  DS    AL2\nDFSMON7  DS    AL2\nDFSMON8  DS    AL2\nDFSTUE   DS    0CL16                   Tuesday\nDFSTUE1  DS    AL2\nDFSTUE2  DS    AL2\nDFSTUE3  DS    AL2\nDFSTUE4  DS    AL2\nDFSTUE5  DS    AL2\nDFSTUE6  DS    AL2\nDFSTUE7  DS    AL2\nDFSTUE8  DS    AL2\nDFSWED   DS    0CL16                   Wednesday\nDFSWED1  DS    AL2\nDFSWED2  DS    AL2\nDFSWED3  DS    AL2\nDFSWED4  DS    AL2\nDFSWED5  DS    AL2\nDFSWED6  DS    AL2\nDFSWED7  DS    AL2\nDFSWED8  DS    AL2\nDFSTHU   DS    0CL16                   Thursday\nDFSTHU1  DS    AL2\nDFSTHU2  DS    AL2\nDFSTHU3  DS    AL2\nDFSTHU4  DS    AL2\nDFSTHU5  DS    AL2\nDFSTHU6  DS    AL2\nDFSTHU7  DS    AL2\nDFSTHU8  DS    AL2\nDFSFRI   DS    0CL16                   Friday\nDFSFRI1  DS    AL2\nDFSFRI2  DS    AL2\nDFSFRI3  DS    AL2\nDFSFRI4  DS    AL2\nDFSFRI5  DS    AL2\nDFSFRI6  DS    AL2\nDFSFRI7  DS    AL2\nDFSFRI8  DS    AL2\nDFSSAT   DS    0CL16                   Saturday\nDFSSAT1  DS    AL2\nDFSSAT2  DS    AL2\nDFSSAT3  DS    AL2\nDFSSAT4  DS    AL2\nDFSSAT5  DS    AL2\nDFSSAT6  DS    AL2\nDFSSAT7  DS    AL2\nDFSSAT8  DS    AL2\nDFSDATA  DSECT                         Start of Data Section\nDFSDSIZE DS    F                       Size Value\nDFSDMAXL DS    F                       Maxlim value\nDFSDMINL DS    F                       Minlim value\nDFSDRESA DS    F                       Resall value\nDFSDRESI DS    F                       Resinv value\nDFSDDYNA DS    CL8                     Dynalloc Device value\nDFSDDYNN DS    H                       Dynalloc Number value\nDFSDDYNI DS    CL1                     Dynauto Indicator\nDFSDABCI DS    XL1                     Abcode Indicator/Value\nDFSDS2AI DS    C                       Sortwk secondary alloc value\nDFSDS2AV DS    AL3                     Sortwk secondary alloc value\nDFSDO2AI DS    C                       Output secondary alloc value\nDFSDO2AV DS    AL3                     Output secondary alloc value\nDFSDMSGP DS    C                       MSGPRT Indicator\nDFSDEQUA DS    C                       EQUALS Indicator\nDFSDLIST DS    C                       LIST Indicator\nDFSDERET DS    C                       ERET Indicator\nDFSDMSGD DS    CL8                     MSGDDN\nDFSDVIO  DS    C                       VIO Indicator\nDFSDWRKR DS    C                       WRKREL Indicator\nDFSDOUTR DS    C                       OUTREL Indicator\nDFSDSTIM DS    C                       STIMER Indicator\nDFSDVERI DS    C                       VERIFY Indicator\nDFSDCHAL DS    C                       CHALT Indicator\nDFSDSVCN DS    AL1                     SVC Number\nDFSDSVCR DS    AL1                     SVC ESR Number\nDFSDCHK  DS    C                       Check Indicator\nDFSDSMF  DS    C                       SMF Indicator\nDFSDIGN  DS    C                       IGNCKPT Indicator\nDFSDCOB  DS    C                       COBOL2 Indicator\nDFSDMSGC DS    C                       MSGCON Indicator\nDFSDVLS  DS    C                       VLSHRT Indicator\nDFSDIEXI DS    C                       IEXIT Indicator\nDFSDTEXI DS    C                       TEXIT Indicator\nDFSDOVRG DS    F                       OVERRGN Indicator\nDFSDTMAX DS    F                       TMAXLIM value\nDFSDARSA DS    F                       ARESALL value\nDFSDARSI DS    F                       ARESINV value\nDFSDZDPR DS    C                       ZDPRINT Indicator\nDFSDEXIT DS    C                       EXIT Indicator (Exitchk)\nDFSDNMSG DS    C                       NOMSGDD Indicator\nDFSDLSTX DS    C                       LISTX Indicator\nDFSDEFSN DS    CL8                     EFS name\nDFSDGENE DS    CL8                     GENER value NOT USED\nDFSDHMAX DS    XL2                     HIPRMAX value\nDFSDSOLR DS    C                       SOLRF Indicator\nDFSDESTA DS    C                       ESTAE Indicator\nDFSDDFSP DS    CL8                     DFSPARM Name\nDFSDCINV DS    C                       CINV Indicator\nDFSDSRTL DS    CL7                     SORTLIB Indicator\nDFSDFSZ  DS    C                       FSZEST Indicator\n         DS    AL1\nDFSDSDB  DS    AL1                     SDB Indicator\nDFSDGPAD DS    C                       GNPAD Indicator\nDFSDGTRU DS    C                       GNTRUNC Indicator\nDFSDCFW  DS    C                       CFW Indicator\nDFSDIDRC DS    H                       IDRCPCT Value\n         DS    AL1\n         DS    AL1\n         DS    AL1\n         DS    AL1\nDFSDVBUF DS    C                       VSAMBSP Indicator\nDFSDDIAS DS    C                       DIAGSIM Indicator\nDFSDDSMX DS    H                       DSPSIZE Value\n         DS    XL1\nDFSDVSLC DS    C                       VLSCMP Indicator\nDFSDDYNS DS    AL2                     DYNSPC Value\nDFSDSDBM DS    XL1                     SDBMSG Indicator\nDFSDSZER DS    C                       SZERO Indicator\nDFSDSPRC DS    C                       SPANINC Value RC=16\nDFSDPADV DS    C                       PADVAL Value\nDFSDTRUN DS    C                       TRUNC Value\nDFSDIVFL DS    C                       OVFLOW Value\nDFSDY2P  DS    AL2                     Y2PAST Value\nDFSDIOMA DS    F                       IOMAXBF Value\nDFSDDSA  DS    AL2                     DSA Value\n         DS    AL2\nDFSDODMA DS    F                       ODMAXBF Value\nDFSDEXPM DS    F                       EXPMAX Value\nDFSDEXPO DS    F                       EXPOLD Value\nDFSDEXPR DS    F                       EXPRES Value\n         DS    F\n         DS    F\nDFSDLOCA DS    CL32                    LOCALE Value\nDFSDVLLO DS    C                       VLLONG Indicator\nDFSDVSIO DS    C                       VSAMIO Indicator\nDFSDRESE DS    C                       RESET Indicator\nDFSDVSEM DS    C                       VSAMEMT Indicator\n         DS    F\nDFSDMSIZ DS    F                       MOSIZE Value\nDFSDNULO DS    C                       NULLOUT Value\nDFSDNULF DS    C                       NULLOFL Value\n         DS    F\n         DS    4XL1\nDFSDALTS DS    256AL1                  ALTSEQ\n         MEND\n./ ADD NAME=DIAG\n         MACRO\n&NAME    DIAG &RX,&RY,&C               Generate DIAGNOSE Instruction\n&NAME    DC   X'83',AL1(&RX*16+&RY),S(&C)\n         MEND\n./ ADD NAME=DIAG204\n         MACRO\n         DIAG204\nD204     DSECT                         Data from DIAGNOSE X'204'\nD204HDR  DS   0XL16                    TABLE HEADER\nD204LEN  DS    H,H                     LENGTH OF D204 TABLE\nD204PCCT DS    H'8'                    NUMBER OF PHYSICAL CPU'S\nD204OWNP DS    Y(D204LPAR-D204)        OFFSET TO OWN LPAR\nD204STCK DS    XL8                     LAST DIAG204'S TOD CLOCK VALUE\nD204LPAR DS   0XL16                    LPAR HEADER\nD204LPNO DS    X                       LOGICAL PARTITION NUMBER\nD204LPCP DS    X                       NUMBER OF CPUS FOR THIS LPAR\n         DS    H,F                     RESERVED\nD204LPNM DS    CL8                     LPAR NAME\nD204LPAD DS    H,H,H                   CPU ADDRESS\nD204LPRS DS    H'25'                   PROCESSOR RELATIVE SHARE\nD204LPT1 DS    XL8                     LPAR TOTAL DISPATCH TIME\nD204LPT2 DS    XL8                     LPAR EFFECTIVE DISPATCH TIME\nD2047     DSECT                         Data from DIAGNOSE X'204'\nD2047HDR  DS   0XL64                    TABLE HEADER\nD2047LEN  DS    H,H                     LENGTH OF D204 TABLE\nD2047PCCT DS    H'8'                    NUMBER OF PHYSICAL CPU'S\nD2047OWNP DS    Y(D204LPAR-D204)        OFFSET TO OWN LPAR\n          DS    X\nD2047STCK DS    XL8                     LAST DIAG204'S TOD CLOCK VALUE\n          DS    CL63                    ???\nD2047LPAR DS   0XL96                    LPAR HEADER\nD2047LPNO DS    X                       LOGICAL PARTITION NUMBER\nD2047LPCP DS    X                       NUMBER OF CPUS FOR THIS LPAR\nD2047LPEN DS    X                       Number of CPUs entries\n          DS    X,F                     RESERVED\nD2047LPNM DS    CL8                     LPAR NAME\nD2047SYSID DS    CL8                    SYSID NAME\nD2047SYS  DS    CL8                     SYSTEM NAME\n          DS    CL64\nD2047LPAD DS    H,H                     CPU ADDRESS Entry\nD2047CPF1 DS    X                       Flag ??\nD2047CPF2 DS    X                       Flag ??\nD2047LPRS DS    H'25'                   PROCESSOR RELATIVE SHARE\nD2047LPT1 DS    XL8                     LPAR TOTAL DISPATCH TIME\nD2047LPT2 DS    XL8                     LPAR EFFECTIVE DISPATCH TIME\n          DS    H\n         MEND\n./ ADD NAME=ERBSTGST\n         MACRO\n&NAME    ERBSTGST\n&NAME    DSECT                         GLOBAL SUPERVISOR TABLE (RMF)\nSTGSNAME DS    C'STGS'\n         ORG   ERBSTGST+X'048'\nSTGSCPU  DS    V(ERBCPUDT)             CPU DATA ADDRESS (RMF)\n         MEND\n./ ADD NAME=ERBCPUDT\n         MACRO\n&NAME    ERBCPUDT\n&NAME    DSECT                         CPU DATA TABLE (RMF)\n         ORG   &NAME+X'2B0'\nCPUD204$ DS    A(D204)                 DIAG X'204' area (4.2)\n         ORG   &NAME+X'2EC'\nCPUD204  DS    A(D204)                 DIAG X'204' area (4.3)\n         MEND\n./ ADD NAME=EZASMI\n         MACRO\n&NAM     EZASMI &TYPE=,                                                *\n               &S=,                                                    *\n               &NS=,                                                   *\n               &SOCRECV=,                                              *\n               &NAME=,                                                 *\n               &ERRNO=,                                                *\n               &RETCODE=,                                              *\n               &ECB=,                                                  *\n               &REQAREA=,                                              *\n               &ERROR=,                                                *\n               &COMMAND=,                                              *\n               &REQARG=,                                               *\n               &RETARG=,                                               *\n               &NAMELEN=,                                              *\n               &OPTNAME=,                                              *\n               &OPTLEN=,                                               *\n               &OPTVAL=,                                               *\n               &CLIENT=,                                               *\n               &MAXSOC=,                                               *\n               &MAXSNO=,                                               *\n               &UEEXIT=,                                               *\n               &ASYNC=,                                                *\n               &SUBTASK=,                                              *\n               &IDENT=,                                                *\n               &APITYPE=,                                              *\n               &BACKLOG=,                                              *\n               &NBYTE=,                                                *\n               &BUF=,                                                  *\n               &IOVCNT=,                                               *\n               &IOV=,                                                  *\n               &ALET=,                                                 *\n               &CALAREA=,                                              *\n               &CALLAREA=,                                             *\n               &FLAGS=,                                                *\n               &TIMEOUT=,                                              *\n               &RSNDMSK=,                                              *\n               &WSNDMSK=,                                              *\n               &ESNDMSK=,                                              *\n               &RRETMSK=,                                              *\n               &WRETMSK=,                                              *\n               &ERETMSK=,                                              *\n               &HOW=,                                                  *\n               &SOCTYPE=,                                              *\n               &AF=,                                                   *\n               &PROTO=,                                                *\n               &STORAGE=,                                              *\n               &HOSTENT=,                                              *\n               &HOSTADR=,                                              *\n               &CICS=,                                                 *\n               &TASK=,                                                 *\n               &MF=,                                                   *\n               &MSG=,                                                  *\n               &SELECB=,                                               *\n               &DUMMY=DUMMY\n&NAM     LA    R15,16                  TCP/IP not available\n         MEND\n./ ADD NAME=EXIT\n         MACRO\n&NAME    EXIT  &P\n&NAME    SVC   3                       ISSUE EXIT SVC\n         MEND\n./ ADD NAME=EZAZTSAB\n         MACRO\n         EZAZTSAB\nTSAB         DSECT                                               RS0100\nTSABEYEC     DS  CL4                   eyecatcher 'TSAB'         RS0100\nTSAB_LENGTH  DS  H                     length TSAB               RS0100\n             DS  H                     Version of TSAB ??        RS0100\n             DS  CL8                   ?                         RS0100\nTSAB_TSREQ_P DS  F                     EZATSREQ entry point      RS0100\nTSABCSVT     DS  F                     CSVT pointer              RS0100\n             DS  CL40                                            RS0100\nTSAB_L       EQU *-TSAB                length of TSAB_header     RS0100\n         MEND\n./ ADD NAME=EZAZTSEB\n         MACRO\n         EZAZTSEB\nTSEB         DS  0H                    one per TCPIP stack       RS0100\n*                                      max 8 entries             RS0100\nTSEBEYEC     DS  CL4                   eyecatcher 'TSEB'         RS0100\nTSEB_Length  DS  H                     length TSEB               RS0100\nTSEB_Version DS  H                     Version of TSAB           RS0100\nTSEB_Access  DS  0H\n             ORG TSEB_Access\nTSEB_Flags   DS  0H\nTSEB_Status  DS  X                     IP-Status                 RS0100\nTSEB_ACTIVE  EQU X'80'                 Active\nTSEB_TERM    EQU X'40'                 Terminating\nTSEB_DOWN    EQU X'20'                 Down\nTSEB_STOP    EQU X'10'                 Stoped\n             DS  CL3                   more flags\n             DS  F                     ?\nTSEB_TcpIp_Name DS  CL8                Name of TCPIP stack\nTSEB_SI      DS  X                     ?\n             DS  C                     ?\nTSEB_TCPIP_Version DS  XL2             Version (internal)\n*                                      X'0302' TCP V3R2\n*                                      X'0305' TCP V3R5 OS V2R6\nTSEB_Tsdb    DS  F                     TSDB pointer              RS0100\nTSEB_Lx      DS  F                     Lx\nTSEB_TCA     DS  F                     TCA pointer               RS0100\nTSEB_TRACE   DS  F                     Trace Settings            RS0100\nTSEB_Pvg_Addr DS  F                    ?\nTSEB_Pvg_Len DS  F                     ?\nTSEB_Events  DS  F                     ?\nTSEB_Asid    DS  H                     TCPIP Asid\n             DS CL2\nTSEB_SAddr   DS  F                     ?\nTSEB_EAddr   DS  F                     ?\nTSEB_Stream_Op DS F                    pointer to EZBSKSTO\nTSEB_EZBITDCR  DS F                    pointer to EZBITDCR\nTSEB_itCvt     DS F                    itCvt-pointer\nTSEB_s_Flags   DS F\nTSEB_Duaf      DS F\nTSEB_TokenId   DS F\nTSEB_Tcmt      DS F                    TCMT-Pointer\nTSEB_COM_Len   DS F\n               DS 7F                   ?\n         MEND\n./ ADD NAME=EZAZTSDB\n         MACRO\n         EZAZTSDB\nTSDB         DSECT                                               RS0100\nTSDB_Acronym DS  CL4                   eyecatcher 'TSDB'         RS0100\nTSDB_Length  DS  H                     length TSDB               RS0100\nTSDB_Version DS  H                     Version of TSDB           RS0100\nTSDB_State   DS  H                     ?\nTSDB_Asid    DS  H                     Asid\n             DS  F\nTSDB_Mt      DS  F                     MTBL pointer              RS0100\n             DS  8F\nTSDB_Mt_Len  DS  F                     ?                         RS0100\nTSDB_Mt_Sp   DS  F                     ?                         RS0100\n             DS  F                     ? Messages                RS0100\nTSDB_Tsdx    DS  F                     TSDX pointer\nTSDB_Opmsb   DS  F                     CSVT pointer              RS0100\nTSDB_Stoken1 DS  D                     Stoken                    RS0100\nTSDB_Stoken2 DS  D                     Stoken                    RS0100\nTSDB_Ctrcx   DS  F                     EZBCTRCD entry\nTSDB_Tsreq   DS  F                     ?\nTSDB_CT_Name DS  CL8                   TraceMember SYS1.PARMLIB\nTSDB_Smca    DS  F                     ?\nTSDB_Smca2   DS  F     ??              ?\nTSDB_Smca3   DS  F     ??              ?\nTSDB_Port1   DS  F                     ?\nTSDB_Port2   DS  F                     ?\nTSDB_BITMSN  DS  F                     EZBITMSN entry\nTSDB_ECB     DS  F                     ECB Starting/Terminating?\nTSDB_Duaf    DS  F                     ?\nTSDB_Tsca    DS  F                     ?\nTSDB_OCIFptr DS  F                     EZBSOCIF entry\nTSDB_OMIFptr DS  F                     EZBSOMIF entry\nTSDB_XGLUptr DS  F                     EZBRXGLU entry\nTSDB_FSTaddr DS  F                     ?\nTSDB_FSTRC   DS  F                     ?\nTSDB_FSTsave DS  F                     ?\n         MEND\n./ ADD NAME=ICHPDSDT\n         MACRO\n         ICHPDSDT\nDSDT     DSECT                RCVTDSDT\nDSDTID   DS    C'DSDT'        EBCDIC ID\nDSDTNUM  DS    F              NUMBER OF ENTRIES IN TABLE\nDSDTDSDX DS    A              POINTER TO EXTENSION\nDSDTVRSN DS    X'01'          VERSION NUMBER OF DSDT (RACF 1.9)\nDSDTFLAG DS    X              DSDT FLAGS OR INDICATORS\nDSDTPFMT EQU   X'80'          FLAG FOR PRIMARY FORMAT 0 = OLD/1 = NEW\nDSDTBFMT EQU   X'40'          FLAG FOR BACK-UP FORMAT 0 = OLD/1 = NEW\n         DS    2X             DOUBLE-WORD ALIGNMENT\n         DS    8X             RESERVED FOR EXPANSION              1.8\nDSDTENTY1 DS   0XL160         ENTRY FOR DATA-SET INFORMATION      1.8\n         DS    112X           RESERVED FOR EXPANSION              2.1\nDSDTDSFL DS    X              Data sharing                       RS1108\nDSDTDSRQ EQU   X'80'                                             RS1108\nDSDTDSRQ_NO EQU  X'00'                                           RS1108\nDSDTDSMO DS    C              RACF Data sharing mode             RS1108\nDSDTDSNO EQU   X'00'          No data sharing                    RS1108\nDSDTDSHR EQU   X'01'          Data sharing mode                  RS1108\nDSDTDSRO EQU   X'02'          Readonly                           RS1108\nDSDTTRAN EQU   X'03'          Transition mode                    RS1108\n         DS    6X             Filler                             RS1108\nDSDTENTY2 DS   0XL(176+176)   ENTRY FOR DATA-SET INFORMATION      2.1\n*        DSECT TO MAP A SINGLE ENTRY IN TABLE\nDSDE     DSECT\nDSDENT1  DS    0XL80          ENTRY FOR DATA-SET                  1.9\nDSDENT2  DS    0XL176         ENTRY FOR DATA-SET                  2.1\nDSDEDCB  DS    A              PTR DCB FOR DATA-SET\nDSDEDEB  DS    A              PTR DEB FOR DATA-SET\nDSDEINDX DS    A              PTR TO IN-STORAGE BUFFERS\nDSDEHRD  DS    A              PTR RACF IN-STORAGE DS HEADER RECORD\nDSDERUCB DS    A              PTR UCB FOR DATA-SET\nDSDEXLEN DS    A              LENGTH OF IN-STORAGE INDEX\nDSDEBAM  DS    A              LOCATES IN-STORAGE BAM INFORMATION\nDSDEDSNL DS    X              LENGTH OF DATA-SET NAME\nDSDESTAT DS    X              DATA-SET STATUS\nDSDEACTV EQU   X'80'          THIS DATA-SET IS ACTIVE\nDSDEPRIM EQU   X'40'          THIS DATA-SET IS A PRIMARY\nDSDEMSTR EQU   X'20'          THIS DATA-SET IS THE MASTER RACF DATA-SET\nDSDERFSH EQU   X'10'          REFRESH ICB\nDSDESHR  EQU   X'08'          DATA-SET IS (OR WAS) SHARED\nDSDEALTI EQU   X'04'          ALTERI REQUESTS ARE BACKED-UP\nDSDEDAT  EQU   X'02'          IN-STORAGE BLOCKS CAN BE DATA BLOCKS\nDSDECMS  EQU   X'01'          DATA-SET IS VM CMS FILE\nDSDENREC DS    H              # RECORDS PER TRACK ON DATA-SET\nDSDERXNO DS    X              # IN-STORAGE BUFFERS OR RES INDEX BLKS\nDSDEDSN  DS    CL44           NAME OF DATA-SET\nDSDEDSNO DS    X              DATA-SET SEQUENCE NUMBER\nDSDECBLN DS    H              LENGTH OF DSDE (RACF 1.9 only)\n         MEND\n./ ADD NAME=ICHPAUTB\n         MACRO\n         ICHPAUTB\nRCATABLE DSECT                TABLE OF AUTHORIZED RACF SVC CALLERS\nRCNAME   DS    CL8            NAME OF CALLER\nRCFLAGS  DS    B              FLAG BYTE\nRCINIT   EQU   X'80'          CALLER AUTHORIZED TO USE RACINIT SVC\n*                             WITHOUT NEWPASSWORD\nRCRSV    EQU   X'40'          CALLER AUTHORIZED TO USE RACLIST SVC\n         MEND\n./ ADD NAME=ICHPCGRP\n         MACRO\n         ICHPCGRP\nCGRP     DSECT                      CONNECT GROUP NAME TABLE (RACF)\nCGRPID   DS   C'CGRP'               TABLE IDENTIFIER\nCGRPCORE DS   F                     TABLE SUBPOOL AND SIZE\nCGRPNUM  DS   H                     MAXIMUM NUMBER OF ENTRIES IN TABLE\nCGRPVRSN DS   FL1,X                 VERSION = 1\nCGRPSYNC DS   F                     SYNCHRONIZE VALUE\nCGRPGPAT DS   A                     ADDRESS OF GROUP AUTHORITIES TABLE\n         DS   CL12                  RESERVED\nCGRPENT  DS   CL24                  First group entry\nCGRPENTD DSECT\nCGRPNAME DS   CL8                   GROUP NAME\n         DS   X,X,H,A,H,CL6         IND,AUTH,GPNM,GPTE,SUPG,RSVD\n         MEND\n./ ADD NAME=IEARCTD\n         MACRO\n         IEARCTD &DSECT=YES\nRCTD     DSECT                         RCT Data Area\n         ORG   RCTD+X'AC'\nRCTDTAXE DS    A                       ADDRESS OF TAXE QUEUE\n         MEND\n./ ADD NAME=IEEMBSST\n         MACRO\n         IEEMBSST\nSST      DSECT                         SMF Selectivity Table\nSSTNAME  DS    CL4'SYS'                sub-system name\nSSTFLAGS DS    X\nSSTDETAL EQU   X'80'                   DETAILED ACCT'NG\nSSTACTIV EQU   X'40'                   SUBSYSTEM ACTIVE\nSSTRESET EQU   X'20'\nSSTNOTYP EQU   X'10'                   NOTYPE specified\n         DS    XL3\nSSTINTVL DS    XL8                     INTERVAL LENGTH\nSSTRCDON DS    32X                     ONE BIT PER RECORD\nSSTEXTAB DS    A(EXITTAB)              A(EXIT TABLE)\n         DS    4F\nSSTSUBTP DS    A(STSTABLE)             SubType selectivity table\n*\nSTSTABLE DSECT ,                       SubType Selectivity Table\nSTSTSP   DS    FL1                     Subpool ID\nSTSTLEN  DS    FL3                     Length of storage\nSTSTNMBR DS    H                       Number of SMF record types\nSTSTNTRY EQU   *                       Record type entry\nSTSTTYPE DS    H                           SMF Record Type\nSTSTSUBC DS    H                           Number of subtype ranges\nSTSTSENT DS    0XL4                        Subtype range entry\nSTSTBEG  DS    H                               Beginning of range\nSTSTEND  DS    H                               End of range\n*\nEXITTAB  DSECT\nEXITSPL  DS    XL4                     SUBPOOL ID AND LENGTH\nEXITNMBR DS    F                       NUMBER OF EXITS\nEXITNTRY EQU   *\nEXITNAME DS    CL8                     EXIT NAME\nEXITFLGS DS    XL4                     Flags\nEXITADDR DS    A                       A(EXIT)\nEXITINAC EQU   X'80'                   EXIT ACTIVE\nEXITEND  DS    0H\n         MEND\n./ ADD NAME=IEEMBACT\n         MACRO\n         IEEMBACT\nIEEMBACT DSECT                         Application Control Table\n         ORG   IEEMBACT+46\nACTMEMID DS    C'00'                   SMFPRMxx\n         MEND\n./ ADD NAME=IEEMBRDS\n         MACRO\n         IEEMBRDS\nIEEMBRDS DSECT                         SMF RDS\nRDSID    DS    C'RDS '                 CONTROL BLOCK ID\nRDSNEXT  DS    A(IEEMBRDS)             FORWARD CHAIN POINTER\nRDSPREV  DS    A(IEEMBRDS)             BACKWARD CHAIN POINTER\n*\nRDSFLG1  DS    X\nRDSFREE  EQU   X'10'                   NEED TO FREE DATASET\nRDSDUMP  EQU   X'08'                   OPER HAS BEEN TOLD TO DUMP DS\nRDSREADY EQU   X'04'                   DS IS OPEN AND READY\nRDSCLOSE EQU   X'02'                   DS NEEDS TO BE CLOSED\nRDSNDOP  EQU   X'01'                   DS NEEDS TO BE OPENED\n*\nRDSFLG2  DS    X\nRDSLOST  EQU   X'80'                   DUMMY RDS FOR LOST DATA\nRDSPHYER EQU   X'40'                   PHYSICAL I/O ERROR\nRDSLOGER EQU   X'20'                   LOGICAL I/O ERROR\nRDSFLG3  DS    X                       RESERVED\nRDSDSLEN DS    AL1(L'RDSNAME)          LENGTH OF DATA SET NAME  HBB5510\nRDSNAME  DS    CL44'SYS1.MANX '        DATA SET NAME            HBB5510\nRDSVOLID DS    C'SYSRES'               VOLUME SERIAL\n         DS    2X                      alignment                HBB5510\nRDSDDN   DS    C'SYS00001'             DDNAME RETURNED BY DYNALLOC\nRDSCAPTY DS    F                       CAPACITY IN # OF BLOCKS\nRDSNXTBL DS    F                       NUMBER OF NEXT AVAIL BLOCK\nRDSBQE   DS    A                       ADDR OF BQE BEING WRITTEN\nRDSAVSPC DS    F                       AVAIL SPACE FROM SHOWCB\nRDSENRBA DS    F                       ENDRBA FROM SHOWCB\nRDSCINV  DS    F                       CONTROL INTERVAL SIZE\nRDSDOMID DS    F                       MSG # OF DUMP MSG\n         DS    F                                                HBB5510\nRDSRPL   DS    19F                     VSAM RPL\nRDSACB   DS    19F                     VSAM ACB\n         MEND\n./ ADD NAME=IEFENF\n         MACRO\n         IEFENF\nENFC     DSECT\nENFCEYEC DS    CL4                     ENFC Eyecatcher\n         DS    CL16                    ??\nENFCENFV DS    F                       ENFV pointer\n*\nENFV     DSECT\nENFVEYEC DS    CL4                     ENFV Eyecatcher\nENFV_ENTRY DS  0CL20                   ENFV Entry\nENFVXITA DS    F                       Preprocessing exit\nENFVPTR  DS    F                       ENFL first pointer\nENFVLPTR DS    F                       ENFL last pointer\nENFVDTOK DS    XL4                     Dtoken\nENFV_FLAGS DS  XL1                     FLAGS (IEAVNP47)\nENFV_SRB_EXIT EQU   X'80'              SRBEXIT\nENFV_EXIT EQU   X'40'                  Exit\nENFV_XSYS_CAPABLE EQU   X'20'          XSYS enabled\nENFV_RSV2 DS   XL3                     Reserved\n*\nENFL     DSECT\nENFLSID  DS    CL4                     ENFL Eyecatcher\nENFLFLGS DS    XL1                     FLAG\nENFLERR  EQU   X'80'                   ENFLS NOT USABLE\nENFLDIS  EQU   X'40'                   Disable ENFLS if error\nENFL_EOT EQU   X'20'                   End of task requested\nENFL_EOM EQU   X'10'                   End of memory requested\nENFL_EXIT_TYPE EQU   X'08'         Exit type. OFF - Exit ON - SRBEXIT\nENFLXSYS EQU   X'04'                   If set, listener accepts\n*                                      notifications originating on\n*                                      other systems\nENFLQMSK DS    XL1                     Mask for comparing Qualifiers\nENFLFLG2 DS    XL1                     0-3 Bits for comparison\nENFLRSV1 DS    XL1                     Subpool for Freemain Area\nENFLQUAL DS    XL4                     Qualifier\nENFLRTN  DS    F                       Entry Point\nENFLTOKN DS    F                       TOKEN\nENFLUSE  DS    F                       Use Count for\nENFLDEL  EQU   X'80'                   ENFL avaiable for reuse\nENFLNPTR DS    F                       next ENFL if any\nENFLPPTR DS    F                       prev ENFL if any\nENFLR14  DS    F                       R14 of establisher of listener\nENFLENME DS    CL8                     Name of Establisher\nENFLXNME DS    CL8                     Name of Listener\nENFLPARM DS    F                       PLIST of Listener\nENFL_ASCB DS   F                       ASCB of Listener\nENFL_TCB DS    F                       TCB of Listener\nENFL_ASID DS   H                       ASID of Listener\nENFLJNME DS    CL8                     Jobname of Listener\nENFLBMQ  DS    CL32                    Bit-mapped qualifier\n         DS    CL2\nENFL_SRBEXIT_CPID_CHAR  DS  CL4        CPID for IEFENFSR\nENFL_SRBEXIT_CPOOL_SAVE DS  F          Ptr to 72 bytes save area\nENFL_STOKEN DS CL8                     Stoken of ASID (SRB mode)\nENFL_RMTR_L DS CL4                     RMTR\nENFL_RMTR_BR DS CL2                    RMTR\nENFL_RMTR_NOP DS CL2                   RMTR\nENFL_RMTR_ADDR DS F                    RMTR\n         MEND\n./ ADD NAME=IEFZB610\n         MACRO\n         IEFZB610\nPPT      DSECT           Program Properties Table\nPPTID    DS    C'PPT '\nPPTVERS  DS    X,X       VERSION NUMBER\nPPTCVERS EQU   X'01'     CURRENT VERSION NUMBER\nPPTHDRLN DS    H         LENGTH OF PPT HEADER\nPPTENTLN DS    H         LENGTH OF A PPT ENTRY\nPPTUSED  DS    H         NUMBER OF USED PPT ENTRIES\nPPTENTS  DS    H         TOTAL NUMBER OF PPT ENTRIES\n         DS    H\nPPTMSGAD DS    A         ADDRESS OF MSGAREA USED IN IEFPPT\nPPTIB650 DS    A         ADDRESS OF MESSAGE MODULE IEFIB650\nPPTOLD   DS    A         ADDRESS OF NEXT LOGICALLY DELETED PPT\nPPTENTRY DSECT\nPPTNAME  DS    CL8       PROGRAM NAME\nPPTBYTE1 DS    X         FIRST BYTE OF PROPERTIES\nPPTNCNCL EQU   X'80'     THIS PROGRAM IS NON-CANCELABLE\nPPTSKEY  EQU   X'40'     THIS PROGRAM REQUIRES THE SPECIAL PROTECT\nPPTNSWP  EQU   X'20'     THIS PROGRAM IS TO BE AUTHORIZED TO BE\nPPTPRIV  EQU   X'10'     THIS PROGRAM IS TO BE 'PRIVILEGED' (WITH\nPPTSYSTK EQU   X'08'     THIS PROGRAM IS A SYSTEM TASK\nPPTNDSI  EQU   X'04'     THIS PROGRAM IS NOT TO BE GIVEN DATA SET\nPPTNOPAS EQU   X'02'     BYPASS PASSWORD PROTECTION\nPPTKEY   DS    X -       THIS KEY IS TO BE GIVEN TO THE PROGRAM\nPPTCPUA  DS    BL2       BIT MASK OF CPU'S ON WHICH THIS PGM CAN RUN\nPPTPUBYT DS    X         PREFERRED USAGE FLAGS\nPPT2LPU  EQU   X'80'     2ND LEVEL PREFERRED USAGE\nPPT1LPU  EQU   X'40'     1ST LEVEL PREFERRED USAGE\nPPTN2LP  EQU   X'20'     NOT 2ND LEVEL PREFERRED USAGE\nPPTORIG  DS    X         PPT ENTRY ORIGIN\nPPTDEFLT EQU   X'80'     FROM IBM SUPPLIED DEFAULT TABLE\n         MEND\n./ ADD NAME=IEEZB807\n         MACRO\n         IEEZB807\nSNPL     DSECT                         SCHEDULER NIP PARAMETER LIST\n         DS    A                       ?\n         DS    F'0'                    ?\n         DS    V(IEFU84)               ?\n         DS    F'0'                 12 ?\nSCHEDPRM DS    C'00'                16 SCHED(NN)\nSCHEDJCL DS    C'00'                   MSTRJCL(NN)\n         DS    F'0'                    ?\n         DS    F'0'                    ?\n         DS    F'0'                    ?\n         MEND\nSNPL     EQU   0,32,C'C'                                   HBB6601-DEL-\nSNPPTRS  EQU   SNPL,32,C'C'                                HBB6601-DEL-\nSNPCMD   EQU   SNPPTRS,4,C'A'                              HBB6601-DEL-\nSNPSSN   EQU   SNPPTRS+4,4,C'A'                            HBB6601-DEL-\nSNPNDA   EQU   SNPPTRS+8,4,C'A'                            HBB6601-DEL-\nSNPMSJCL EQU   SNPPTRS+12,4,C'A'                           HBB6601-DEL-\nSNPMJCL  EQU   SNPPTRS+16,2,C'C'                           HBB6601-DEL-\nSNPFLAG  EQU   SNPPTRS+18,1,C'C'                           HBB6601-DEL-\nSNPJCLP  EQU   SNPFLAG,,C'B'                               HBB6601-DEL-\nSNPMSTL  EQU   SNPFLAG,,C'B'                               HBB6601-DEL-\nSNPSUBP  EQU   SNPPTRS+19,1,C'F'                           HBB6601-DEL-\nSNPRSV4  EQU   SNPPTRS+20,4,C'A'                           HBB6601-DEL-\nSNPRSV5  EQU   SNPPTRS+24,4,C'A'                           HBB6601-DEL-\nSNPRSV6  EQU   SNPPTRS+28,4,C'A'                           HBB6601-DEL-\nSNPSSP   EQU   0,,C'C'C'                                   HBB6601-DEL-\nSNPMEM   EQU   SNPSSP+1,2,C'C'                             HBB6601-DEL-\nSNPNUM   EQU   SNPSSP,1,C'F'                               HBB6601-DEL-\n*                                                                 -DEL-\nSNPL     EQU   0,32,C'C'                                   HBB4430-DEL-\nSNPPTRS  EQU   SNPL,32,C'C'                                HBB4430-DEL-\nSNPCMD   EQU   SNPPTRS,4,C'A'                              HBB4430-DEL-\nSNPSSN   EQU   SNPPTRS+4,4,C'A'                            HBB4430-DEL-\nSNPNDA   EQU   SNPPTRS+8,4,C'A'                            HBB4430-DEL-\nSNPRSV2  EQU   SNPPTRS+12,4,C'A'                           HBB4430-DEL-\nSNPMJCL  EQU   SNPPTRS+16,2,C'C'                           HBB4430-DEL-\nSNPRSV3  EQU   SNPPTRS+18,2,C'C'                           HBB4430-DEL-\nSNPRSV4  EQU   SNPPTRS+20,4,C'A'                           HBB4430-DEL-\nSNPRSV5  EQU   SNPPTRS+24,4,C'A'                           HBB4430-DEL-\nSNPRSV6  EQU   SNPPTRS+28,4,C'A'                           HBB4430-DEL-\nSNPSSP   EQU   0,,C'C'                                     HBB4430-DEL-\nSNPNUM   EQU   SNPSSP,1,C'F'                               HBB4430-DEL-\nSNPMEM   EQU   SNPSSP+1,2,C'C'                             HBB4430-DEL-\n./ ADD NAME=IEEZB809\n         MACRO           Message Processing Facility Table (MPFT)\n         IEEZB809\nMPFT     DSECT           MPF TABLE HEADER\nMPFTACRN DS   CL4        CHARACTERS 'MPFT'\nMPFTVRSN DS   X          VERSION LEVEL\nMPFTS212 EQU  1          LEVEL OF OS/VS2 JBB2125\nMPFTS410 EQU  2          LEVEL OF OS/VS2 HBB4410\nMPFTS422 EQU  3          LEVEL OF OS/VS2 JBB4422\nMPFTVERN EQU  MPFTS422   CURRENT VERSION LEVEL\nMPFTFLG  DS   XL1        MPF FLAGS\nMPFTDFLT EQU  X'80'      MPF .NOENTRY MESSAGE ID FOUND\nMPFTDSUP EQU  X'40'      MPF .NOENTRY SUP(YES)\nMPFTDRET EQU  X'20'      MPF .NOENTRY RETENTION INDICATOR FOR DISPLAY  *\n                         MPF OUTPUT\nMPFTDAUT EQU  X'10'      MPF .NOENTRY AUTO(YES)\nMPFTDRYS EQU  X'08'      MPF .NOENTRY RETAIN(YES)\nMPFTDRI  EQU  X'04'      MPF .NOENTRY RETAIN(I)\nMPFTDRE  EQU  X'02'      MPF .NOENTRY RETAIN(E)\nMPFTDRCE EQU  X'01'      MPF .NOENTRY RETAIN(CE)\nMPFTFLG2 DS   CL1        MPF FLAG BYTE TWO\nMPFTDSPA EQU  X'80'      MPF .NOENTRY SUP(ALL)\nMPFTRSV4 DS   CL1        RESERVED\nMPFTSPN  DS   FL1        SUBPOOL NUMBER\nMPFTSIZE DS   FL3        SIZE OF MPF TABLE TOTAL\nMPFTNENG DS   H          NUMBER OF ENTRIES IN GENERIC TABLE\nMPFTNENS DS   H          NUMBER OF ENTRIES IN SPECIFIC TABLE\nMPFTENLN DS   H          LENGTH OF EACH ENTRY\nMPFTRSV3 DS   CL2        RESERVED\nMPFTGENP DS   A          POINTER TO THE FIRST GENERIC ENTRY\nMPFTSENP DS   A          POINTER TO THE FIRST SPECIFIC ENTRY\nMPFTRSV5 DS   F          reserved\nMPFTCECB DS   F          SET MPF COMMAND ECB\nMPFTASCB DS   A          ASCB ADDRESS OF IEECB805 TASK FOR             *\n                         IEAVM700 POST\nMPFTDATK DS   CL8        MPF .NOENTRY TOKEN\nMPFTRSV1 DS   XL4        RESERVED\nMPFTDALN DS   FL2        LENGTH OF DATA AREAS\nMPFTRSV2 DS   CL2        RESERVED\nMPFTRSV  DS   XL8        RESERVED\n*\nMPFTENTY DSECT           MPF TABLE ENTRY\nMPFMSGID DS    CL10      MESSAGE ID\nMPFTIDLN DS    FL1       LENGTH OF MESSAGE ID\nMPFTEFLG DS    B         ENTRY FLAGS\nMPFTPREF EQU   X'80'     PREFIX ENTRY\nMPFSUPMS EQU   X'40'     SUPPRESS THE MESSAGE\nMPFABEND EQU   X'20'     USER EXIT ROUTINE ABENDED\nMPFNTFND EQU   X'10'     USER EXIT ROUTINE NOT FOUND\nMPFXACTV EQU   X'08'     USER EXIT IS ACTIVE\nMPFRETAN EQU   X'04'     RETENTION INDICATOR FOR DISPLAY MPF OUTPUT\nMPFAUTO  EQU   X'02'     AUTOMATION SPECIFIED FOR THIS MESSAGE\nMPFSUPA  EQU   X'01'     ALL MESSAGES SUPPRESSED, INCLUDING COMMAND    *\n                         RESPONSES\nMPFEXNME DS    CL8       USER EXIT ROUTINE MODULE NAME\nMPFEXENT DS    A         ADDRESS OF ENTRY POINT\nMPFAUTOT DS    CL8       AUTOMATION TOKEN VALUE\nMPFTIWKP DS    A         POINTER TO 8-BYTE DATA AREA FOR AN            *\n                         INDIVIDUAL EXIT\nMPFRFLGS DS    B         INDIVIDUAL RETENTION FLAGS\nMPFRETYS EQU   X'80'     RETAIN ALL ACTION MSGS\nMPFRETI  EQU   X'40'     RETAIN IF IMMEDIATE ACTION MSG\nMPFRETE  EQU   X'20'     RETAIN IF EVENTUAL ACTION MSG\nMPFRETCE EQU   X'10'     RETAIN IF CRITICAL EVENTUAL ACTION MSG\nMPFSUFFX DS    CL2       INDIVIDUAL SUFFIX\n         DS    CL1       RESERVED\n         MEND\n./ ADD NAME=IEEVC102\n         MACRO\n         IEEVC102\nCLRATT   DSECT                    COLOR/HIGHLIGHTING ATTRIBUTE TABLE\nCLRNAME  DS    CL4                ACROYNM 'CLRA'\nCLRVER   DS    CL1                VERSION LEVEL\nCLRSP21  EQU   1                  CLRATT IS AT OS/VS2 HBB2102 LEVEL\nCLRSP212 EQU   2                  CLRATT IS AT OS/VS2 JBB2125 LEVEL\nCLRSP422 EQU   3                  CLRATT IS AT MVS/ESA JBB4222 LEVEL\nCLRVERSN EQU   CLRSP422           CURRENT VERSION LEVEL\nCLRATTRS DS    0C                 ATTRIBUTES\n         DS    0CL6               ATTRIBUTES FOR URGENT ATTENION       X\n                                  MESSAGES\nCLRCAURG DS    CL1                  COLOR ATTRIBUTE\nCLRHAURG DS    CL1                  HIGHLIGHTING ATTRIBUTE\nCLRIAURG DS    CL1                  INTENSITY ATTRIBUTE\nCLRSAURG DS    CL3                  SUFFIX\n         DS    0CL6               ATTRIBUTES FOR IMMEDIATE ACTION      X\n                                  MESSAGES\nCLRCAIMM DS    CL1                  COLOR ATTRIBUTE\nCLRHAIMM DS    CL1                  HIGHLIGHTING ATTRIBUTE\nCLRIAIMM DS    CL1                  INTENSITY ATTRIBUTE\nCLRSAIMM DS    CL3                  SUFFIX\n         DS    0CL6               ATTRIBUTES FOR EVENTUAL ACTION       X\n                                  MESSAGES\nCLRCAEVE DS    CL1                  COLOR ATTRIBUTE\nCLRHAEVE DS    CL1                  HIGHLIGHTING ATTRIBUTE\nCLRIAEVE DS    CL1                  INTENSITY ATTRIBUTE\nCLRSAEVE DS    CL3                  SUFFIX\n         DS    0CL6               ATTRIBUTES FOR GENERAL MESSAGES\nCLRCAGEN DS    CL1                  COLOR ATTRIBUTE\nCLRHAGEN DS    CL1                  HIGHLIGHTING ATTRIBUTE\nCLRIAGEN DS    CL1                  INTENSITY ATTRIBUTE\nCLRSAGEN DS    CL3                  SUFFIX\n         DS    0CL6               ATTRIBUTES FOR PROBLEM PROGRAM       X\n                                  MESSAGES\nCLRCAPPM DS    CL1                  COLOR ATTRIBUTE\nCLRHAPPM DS    CL1                  HIGHLIGHTING ATTRIBUTE\nCLRIAPPM DS    CL1                  INTENSITY ATTRIBUTE\nCLRSAPPM DS    CL3                  SUFFIX\n         DS    0CL6               ATTRIBUTES FOR SELECTOR PEN FIELD\nCLRCASEL DS    CL1                  COLOR ATTRIBUTE\nCLRHASEL DS    CL1                  HIGHLIGHTING ATTRIBUTE\nCLRIASEL DS    CL1                  INTENSITY ATTRIBUTE\nCLRSASEL DS    CL3                  SUFFIX\n         DS    0CL6               ATTRIBUTES FOR ERROR MESSAGES        X\n                                  DISPLAYED IN INSTRUCTION LINE\nCLRCAINS DS    CL1                  COLOR ATTRIBUTE\nCLRHAINS DS    CL1                  HIGHLIGHTING ATTRIBUTE\nCLRIAINS DS    CL1                  INTENSITY ATTRIBUTE\nCLRSAINS DS    CL3                  SUFFIX\n         DS    0CL6               ATTRIBUTES FOR ENTRY AREA\nCLRCAENT DS    CL1                  COLOR ATTRIBUTE\nCLRHAENT DS    CL1                  HIGHLIGHTING ATTRIBUTE\nCLRIAENT DS    CL1                  INTENSITY ATTRIBUTE\nCLRSAENT DS    CL3                  SUFFIX\n         DS    0CL6               ATTRIBUTES FOR LEFT SIDE OF          X\n                                  WARNING LINE - GENERAL MESSAGES\nCLRCAWLG DS    CL1                  COLOR ATTRIBUTE\nCLRHAWLG DS    CL1                  HIGHLIGHTING ATTRIBUTE\nCLRIAWLG DS    CL1                  INTENSITY ATTRIBUTE\nCLRSAWLG DS    CL3                  SUFFIX\n         DS    0CL6               ATTRIBUTES FOR RIGHT SIDE OF         X\n                                  WARNING LINE - GENERAL MESSAGES\nCLRCAWRG DS    CL1                  COLOR ATTRIBUTE\nCLRHAWRG DS    CL1                  HIGHLIGHTING ATTRIBUTE\nCLRIAWRG DS    CL1                  INTENSITY ATTRIBUTE\nCLRSAWRG DS    CL3                  SUFFIX\n         DS    0CL6               ATTRIBUTES FOR RIGHT SIDE OF         X\n                                  WARNING LINE - URGENT ATTENTION      X\n                                  MESSAGES\nCLRCAWRU DS    CL1                  COLOR ATTRIBUTE\nCLRHAWRU DS    CL1                  HIGHLIGHTING ATTRIBUTE\nCLRIAWRU DS    CL1                  INTENSITY ATTRIBUTE\nCLRSAWRU DS    CL3                  SUFFIX\n         DS    0CL6               ATTRIBUTES FOR O-O-L CONTROL LINE\nCLRCAOLC DS    CL1                  COLOR ATTRIBUTE\nCLRHAOLC DS    CL1                  HIGHLIGHTING ATTRIBUTE\nCLRIAOLC DS    CL1                  INTENSITY ATTRIBUTE\nCLRSAOLC DS    CL3                  SUFFIX\n         DS    0CL6               ATTRIBUTES FOR O-O-L LABEL LINES\nCLRCAOLL DS    CL1                  COLOR ATTRIBUTE\nCLRHAOLL DS    CL1                  HIGHLIGHTING ATTRIBUTE\nCLRIAOLL DS    CL1                  INTENSITY ATTRIBUTE\nCLRSAOLL DS    CL3                  SUFFIX\n         DS    0CL6               ATTRIBUTES FOR O-O-L DATA LINES\nCLRCAOLD DS    CL1                  COLOR ATTRIBUTE\nCLRHAOLD DS    CL1                  HIGHLIGHTING ATTRIBUTE\nCLRIAOLD DS    CL1                  INTENSITY ATTRIBUTE\nCLRSAOLD DS    CL3                  SUFFIX\nCLRALEN  EQU   *-CLRATT           LENGTH OF ATTRIBUTE TABLE\n*\n*        VALUES FOR THE COLOR ATTRIBUTES\n*\nCLRBLUE  EQU   X'F1'              THE COLOR BLUE\nCLRRED   EQU   X'F2'              THE COLOR RED\nCLRPINK  EQU   X'F3'              THE COLOR PINK\nCLRGREEN EQU   X'F4'              THE COLOR GREEN\nCLRTURQ  EQU   X'F5'              THE COLOR TURQUOISE\nCLRYELOW EQU   X'F6'              THE COLOR YELLOW\nCLRWHITE EQU   X'F7'              THE COLOR WHITE\n*\n*        VALUES FOR THE HIGHLIGHTING ATTRIBUTES\n*\nCLRHNONE EQU   X'00'              NO HIGHLIGHTING IS IN EFFECT\nCLRBLINK EQU   X'F1'              HIGHLIGHTING IS BLINKING\nCLRRVIDO EQU   X'F2'              HIGHLIGHTING IS REVERSE VIDEO\nCLRUNDER EQU   X'F4'              HIGHLIGHTING IS UNDERSCORING\n*\n*        VALUES FOR THE INTENSITY ATTRIBUTES\n*\nCLRINORM EQU   X'E4'              INTENSITY IS NORMAL\nCLRIHIGH EQU   X'E8'              INTENSITY IS HIGH\n         MEND\n./ ADD NAME=IEEZB816\n         MACRO\n         IEEZB816\nGENX     DSECT                         GENERAL WTO USER EXIT TABLE\nGENXACRN DS    CL4                     ACRONYM 'GENX'\nGENXVRSN DS    X                       VERSION LEVEL\nGENXS212 EQU   1                       LEVEL OF OS/VS2 JBB2125\nGENXS410 EQU   2                       LEVEL OF OS/VS2 HBB4410\nGENXVERN EQU   GENXS410                CURRENT VERSION LEVEL\nGENXSP   EQU   241                     SUBPOOL WHERE GENX RESIDES\nGENXFLGS DS    B                       ENTRY FLAGS\nGENXACTV EQU   X'80'                   IEAVMXIT IS ACTIVE\nGENXABND EQU   X'40'                   IEAVMXIT HAS ABENDED\n*        EQU   X'20'-X'01'             RESERVED\nGENXRSVD DS    XL6                     RESERVED\nGENXENTY DS    A                       ENTRY POINT ADDRESS OF IEAVMXIT\nGENXCECB DS    0F                      K M,UEXIT= COMMAND ECB\n         DS    B                       BITS PORTION OF ECB\nGENXPCOD DS    FL3                     POST CODE\nGENXCWKP DS    A                       POINTER TO 8-BYTE COMMON DATA\n*                                      AREA\nGENXRSV1 DS    CL8                     RESERVED\nGENXCUDA DS    CL8                     IEAVMXIT DATA AREA\n         MEND\n./ ADD NAME=IEEZB817\n         MACRO\n         IEEZB817\nCPFT     DSECT                         Command Prefix Table\nCPFTACRO DS    CL4                     Eyecatcher 'CPFT'           @RS\nCPFTVRSN DS    XL1                     Version                     @RS\nCPFTRSV1 DS    CL3                     free                        @RS\nCPFTNUME DS    F                       number of entries           @RS\nCPFT1ST  DS    F                       offset first entry          @RS\nCPFTLAST DS    F                       offset last entry           @RS\nCPFTRSV2 DS    CL8                     free                        @RS\n*                                                                  @RS\nCPFT_ENTRY DSECT                       Start of an entry           @RS\nCPFTFLGS DS    X                       flags                       @RS\nCPFTSCOP EQU   X'80'                   Scope                       @RS\nCPFTFDP1 EQU   X'20'                   Faildisp                    @RS\nCPFTREMV EQU   X'10'                   Remove                      @RS\nCPFTRSV3 DS    CL3                     free                        @RS\nCPFTPRFX DS    CL8                     Prefix                      @RS\nCPFTPRLN DS    XL1                     Prefix_length               @RS\nCPFTRSV4 DS    CL3                     free                        @RS\nCPFTOWNR DS    CL8                     Owner                       @RS\nCPFTSYS  DS    CL8                     System                      @RS\nCPFTASID DS    H                       ASID                        @RS\nCPFTRSV5 DS    CL10                    free                        @RS\nCPFT_ENTRY_LENGTH EQU *-CPFT_ENTRY     length                      @RS\n         MEND\n./ ADD NAME=IEFZB445\n         MACRO\n         IEFZB445\nIEFAB445 DSECT                         Device Allocation Defaults\nDEFPQTY  DS    FL3                     PRIMARY QUANTITY\nDEFSQTY  DS    FL3                     SECONDARY QUANTITY\nDEFDRLH  DS    FL3                     AVERAGE DATA BLOCK LENGTH\nDEFDQTY  DS    FL3                     DIRECTORY BLOCKS\nDEFFLG1  DS    X                       FLAGS\nDEFTRK   EQU   X'80'\nDEFCYL   EQU   X'40'\nDEFBLKLN EQU   X'20'\nDEFRLSE  EQU   X'10'\nDEFCONTG EQU   X'08'\nDEFMIXG  EQU   X'04'\nDEFALX   EQU   X'02'\nDEFROUND EQU   X'01'\nDEFUNIT  DS    C'SYSALLDA'             default unit name\nDEFFLG2  DS    X,X                     FLAGS\nDEFTERMJ EQU   X'80'\nDEFWTOCF EQU   X'40'\nDEFSDSWT EQU   X'20'\nDEFREDTP EQU   X'08'                   REDIRECTED_TAPE(DASD)\nDEFTIOTS DS    FL1                     TIOT SIZE\nDEFID    DS    C'ALCD'                 CB acronym\nDEFVERS  DS    X'01'               1C  CB version\nDEFVOLS  DS    X                       Flags\nDEFVOLUC EQU   X'80'\nDEFVOLUM EQU   X'40'\nDEFVOLUW EQU   X'08'\nDEFMNTS  DS    X                       Flags\nDEFMOUNC EQU   X'80'\nDEFMOUNT EQU   X'40'\nDEFSPCS  DS    X                       Flags\nDEFSPCWC EQU   X'80'\nDEFSPCWS EQU   X'40'\nDEFSPCWW EQU   X'20'\nDEFSPCWH EQU   X'10'\nDEFSPMAX DS    X                   20  Flags\nDEFSNWAI DS    X                       Flags\nDEFSNWC  EQU   X'80'\nDEFSNW   EQU   X'40'\n         DS    X\nDEFOFFS  DS    X                       Flags\nDEFOFFLC EQU   X'80'\nDEFOFFLN EQU   X'40'\nDEFOFFLW EQU   X'20'\nDEFOFFLH EQU   X'10'\nDEFAOMAX DS    X                   24  Flags\nDEFNWAIT DS    X                       Flags\nDEFNWC   EQU   X'80'\nDEFNW    EQU   X'40'\n         DS    X\nDEFAFFNM DS    CL8                     Unit Aff\nDEFAFFTP DS    CL4                     Don't know !!             RS0203\n         DS    X                       Filler                    RS0909\nDEFBR14  DS    X                       Recall migrate DSN        RS0909\nDEFBR14N EQU   X'80'                                             RS0909\nDEFBR14Y EQU   X'40'                                             RS0909\nDEFTPLB  DS    X                       Tread Tape Library        RS0909\nDEFTPLBE EQU   X'80'                     Equal                   RS0909\nDEFTPLBY EQU   X'40'                                             RS0909\nDEFRINTV DS    H                       Time interval??           RS0909\nDEFTSIZE DS    F                       Size decimal              RS0909\nDEFMAXDD DS    F                       Maximum DD                RS0909\nDEFVUFL  DS    X                   40  Flags                     RS0310\nDEFVRUNC EQU   x'80'                   FAIL UNCATALOG            RS0310\nDEFVUTRK EQU   X'40'                   TRACK UNCATALOG ONLY      RS0310\nDEFVUMTR EQU   X'20'                 TRACK AND MESSAGE UNCATALOG RS0310\nDEFTDSF  DS    X                       Flags                     RS0414\nDEFTDSFI EQU   X'40'                   Use Label on temp ds      RS0414\nDEFMDSEM DS    X                       Flags                     RS0414\nDEFDSEMD EQU   X'40'                   Disable                   RS0414\nDEFBCHRC DS    X                       Flags                     RS0616\nDEFBCHRS EQU   X'80'                   BATCH RECALL SERIAL BEH.  RS0616\nDEFOPTCD DS    X                       Flags                     RS0414\nDEFOPEXP EQU   X'80'                   OPTCDB_SPLIT(EXPLICIT)    RS0414\n         MEND\n./ ADD NAME=IEFZB4D5\n         MACRO\n         IEFZB4D5\nDSABQDB  DSECT                         DSAB QUEUE DESCRIPTOR BLOCK\nDSQDBID  DS    C'DSAB'                 ACRONYM\nDSQATTRS DS    XL2                     ATTRIBUTES\nDSQQDBLN DS    H'32'                   QDB LENGTH\nDSQNELMS DS    F                       NUMBER OF ELEMENTS ON QUEUE\nDSQFRSTP DS    A(DSAB)                 FIRST DSAB\nDSQLASTP DS    A(DSAB)                 LAST DSAB\nDSQFDSP  DS    H                       Disp into DSAB FWD Ptr\nDSQBDSP  DS    H                       Disp into DSAB BWD Ptr\nDSQDCPID DS    F                       DSAB Cell Pool Id\nDSQRIUTP DS    A                       Pointer to RIU table\nDSQFRSTA DS    A(DSAB)                 Pointer to 1. DSAB above/below\nDSQLASTA DS    A(DSAB)               Pointer to last DASB above/below\n         MEND\n./ ADD NAME=IFASLCA                                              RS0406\n         MACRO\n         IFASLCA\nSLCA     DSECT                         SLCA\nSLCASLCA DS CL4                CONTROL BLOCK ID  - SLCA        *\nSLCATEMP DS F             POINTER TO TEMPORARY BUFFER AREA *\nSLCAECB0 DS F             RESERVED                         *\nSLCAECB1 DS F             ISSUE I/O ERROR MESSAGE ECB     *\nSLCAECB2 DS F             COMPLETE DATA SET SWITCH ECB    *\nSLCAECB6 DS F             ISSUE MESSAGE IEE979W ECB       *\nSLCABQEH DS CL4         /* BQE CHAIN HEADER                *\nSLCAFBQE DS F           /* ADDRESS OF FIRST BQE            *\nSLCALBQE DS F           /* ADDRESS OF LAST BQE             *\nSLCACBQE DS F           /* ADDRESS OF CURRENT BQE          *\nSLCABQGM DS F           /* BQE GETMAIN PARAMETERS          *\n* SLCABQSP FIXED(8),    /* BQE SUBPOOL                     *\n* SLCABQSZ FIXED(24),   /* BQE SIZE                        *\nSLCACNBF DS F           /* CURRENT NUMBER OF BQES          *\nSLCABFTM DS F           /* TIME OF LAST BQE OBTAINED OR\n*                          LAST ATTEMPT TO FREE BQES   \u00a701C*\nSLCABFLS DS F           /* NUMBER OF BUFFERS LOST DUE TO\n*                          BUFFER SHORTAGE                 *\n* VARIABLES FOR THE BUFFER CONTROL AREA         */\nSLCAECBG DS F           /* ECB TO SIGNAL IFASMF TO GET A\n*                                  BCA\nSLCAECBF DS F            /* ECB TO SIGNAL IFASMF TO FREE\n*                                  A BCA\nSLCABCAP DS F           /* POINTER TO FIRST BUFFER CONTROL\n*                                 AREA (BCA)\nSLCABCAC DS F           /* POINTER TO CURRENT BCA\nSLCATBFS DS F           /* POINTER TO STACK OF BCA'S TO BE\n* MISC. VARIABLES */\nSLCANUM  DS F     /*BQENUM FROM LAST BQE WRITTEN BY SRB\nSLCAINDX DS F            /* LAST DOMID FOR 948E\nSLCAD948 DS 256F         /* IEE948E DOMID ARRAY\nSLCABFTL DS F            /* Total buffer storage allocated\n*                           and were on in-use queue. Do\n*                           include BCAs on AvailQ.\nSLCABFPM DS F            /* NUMBER OF PERM BQE ALLOCED\nSLCABFAL DS F            /* BUFFER STORAGE ALLOC REQUEST\n*                           (incremental buffers)\nSLCAD985 DS F            /* DOM ID FOR IEE985I\nSLCABFMX DS F            /* MAX BUFFER STORAGE REQSTED\n*                           (BUFSIZMAX)\nSLCABFWN DS F            /* Buffer warning level message\n*                           requested (BUFUSEWARN). When thi\n*                           percent of the maximum buffers\n*                           (slcabfmx) is reached, start\n*                           warning messages.\nSLCABFHW DS F            /* BUFFER STORAGE HIGH-WATER-MARK\nSLCABFIA DS F            /* Initial Buffer Size Request\nSLCABFBW DS F            /* Individual buffer warning level\n*                           used as trigger to get next\n*                           incremental buffer (see\n*                           SLCA_PercentFullGetNext)\nSLCABQGT DS F            /* Size of permanent BQEs\nSLCABFGT DS F            /* Buffer storage getmained. This\n*                            will match SLCABFMX except\n*                            when SLCABFMX changes\n* Put new things here. Long names are OK */\n*******************************************************************\n*\n*     Variables used for BUFSIZxxx related keywords\n*\n*******************************************************************\n\nSLCA_BUFSIZMAXC DS CL5      BufSizMAX in EBCDIC\n                DS CL1      Reserved\nSLCA_BUFUSEWARNC DS CL2     BufUseWarn value in EBCDIC,\n*                                   percent full warning\nSLCA_M986ePercent DS X      Percent value used in last\n*                                   issuance of Iee986e message\n                DS CL7      Reserved\nSLCA_BCA_AvailQ DS F        Pointer to queue of ready to\n*                                      be used BCAs\nSLCABFRF        DS F        Buffer last referenced factor\n*                                   (see SLCA_TWOMIN)\n         MEND\n./ ADD NAME=IFAQUAAX                                             RS0508\n         MACRO\n         IFAQUAAX &DSECT=YES,&LIST=YES,&TITLE=YES,&PREFIX=,            *\n               &QUAHDRTYPE=YES,&QUALSTYPE=COND\n         GBLC  &IFAQUAA_INCLUDED\n         GBLC  &ZCBPRINT\n&IFAQUAA_INCLUDED SETC 'YES'\n         AIF   ('&LIST' EQ 'NONE').P0\n         AIF   ('&TITLE' EQ 'NO').P5\n TITLE   'IFAQUAA  - SMF Query Answer Area                          '\n.P5      ANOP\n**/ IFAQUAA_1:;\n*/* START OF SPECIFICATIONS *******************************************\n*\n*  **PROPRIETARY_STATEMENT********************************************\n***01* PROPRIETARY STATEMENT=                                        *\n*                                                                    *\n*                                                                    *\n*   LICENSED MATERIALS - PROPERTY OF IBM                             *\n*   5694-A01 COPYRIGHT IBM CORP. 2007                                *\n*                                                                    *\n*   STATUS= HBB7740                                                  *\n*                                                                    *\n*  **END_OF_PROPRIETARY_STATEMENT*************************************\n*\n*01* DESCRIPTIVE NAME:  SMF Query Answer Area\n*02*  ACRONYM:  QUAA\n*\n*01* MACRO NAME:  IFAQUAA\n*\n*01* EXTERNAL CLASSIFICATION: GUPI\n*01* END OF EXTERNAL CLASSIFICATION:\n*\n*01* DSECT NAME:\n*     QUAHDR\n*     QUALS\n*\n*01* COMPONENT:  System Management Facility (SC100)\n*\n*01* EYE-CATCHER:  NONE\n*\n*01* STORAGE ATTRIBUTES:\n*02*  SUBPOOL:  Caller-supplied\n*02*  KEY:  Caller-supplied\n*02*  RESIDENCY:  Caller-supplied\n*\n*01* SIZE:  Variable\n*            QUAHDRTYPE -- X'0010' bytes\n*            QUALSTYPE  -- X'0050' bytes\n*\n*01* CONTROL BLOCK CHANGES:\n*02*  IFAU29LM\n*02*   5.3\n*03*    New\n*03*    Migration Considerations: NONE\n*01* END CONTROL BLOCK CHANGES\n*\n*01* CREATED BY:\n*     Caller and passed as parameter on ANSAREA keyword\n*      on IFAQUERY invocation\n*\n*01* POINTED TO BY:\n*     IFAQUERY parameter list\n*\n*01* SERIALIZATION:\n*     None required\n*\n*01* FUNCTION:\n*02* Maps the data returned by the IFAQUERY macro request.\n*\n*\n*01* METHOD OF ACCESS:\n*02*  ASM:\n*      IFAQUERY\n*           DSECT=YES]NO  -- Request DSECT definition\n*           QUALS=YES]NO]COND -- Request QUALS record mapping\n*     Default: DSECT=YES\n*     Notes: name=YES  => expand\n*            name=NO   => do not expand\n*            name=COND => expand only if DSECT=YES\n*\n*02*  PL/AS:\n*\n*\n*01* DELETED BY:  Caller\n*\n*01* FREQUENCY:  Created by caller\n*\n*01* DEPENDENCIES:  None\n*\n*01* DISTRIBUTION LIBRARY:  AMACLIB\n*\n*01* CHANGE ACTIVITY:\n*\n*  $L0=SMFDV   ,HBB7740,061212,PDHV: SMF DATA VOLUME             \u00a7L0A\n*  $P1=MExxxxx ,HBB77??,080509,PDHV: Add PREFIXing for compatibility\n*                                    between macros              \u00a7P1A\n*\n*\n* Change activity details:\n*  A - Created                                                   \u00a7L0A\n*\n* END OF SPECIFICATIONS **********************************************/\n*% /*\n.P0      ANOP\n         AIF   ('&ZCBPRINT' EQ 'NO').P1\n         AIF   ('&LIST' EQ 'YES').P2\n.P1      ANOP\n         PUSH  PRINT\n         PRINT OFF\n.P2      ANOP\n         AIF   ('&QUAHDRTYPE' EQ 'NO').L0002\n         AIF   ('&DSECT' EQ 'YES').L0003\n         AIF   ('&QUAHDRTYPE' NE 'YES').L0002\n&PREFIX.QUAHDRTYPE DS 0F Header section\n         AGO   .L0004\n.L0003   ANOP\n&PREFIX.QUAHDRTYPE DSECT   Header section\n.L0004   ANOP\n&PREFIX.QUAH#REC DS F    Number of QUALS or QUADS records which        *\n                         follow. Note: this field is zero with zero    *\n                         return code, when the service could not find  *\n                         any records and SMF is recording\n&PREFIX.QUAH#REM DS F    Number of QUALS or QUADS records which were   *\n                         not returned because of insufficient space\n&PREFIX.QUAHTLEN DS F    Total length of answer area needed to contain *\n                         all the requested information. This includes  *\n                         the area for the records that were returned   *\n                         on this call.\n&PREFIX.QUAHDOFF DS F    Offset from QUAHDR to the first data record.\n&PREFIX.QUAHDRTYPE_LEN EQU *-&PREFIX.QUAHDRTYPE\n.L0002   ANOP\n         AIF   ('&QUALSTYPE' EQ 'NO').L0005\n         AIF   ('&DSECT' EQ 'YES').L0006\n         AIF   ('&QUALSTYPE' NE 'YES').L0005\n.L0006   ANOP\n*\n*    *****************************************************************\n*    *                                                               *\n*    * QUAA Logstream Data WARNING\u00dc You must use the QUALSLEN to     *\n*    * determine the size of QUALS that is presented. This size can  *\n*    * change at any time due to new SMF support or service.         *\n*    *                                                               *\n*    *****************************************************************\n*\n*\n         AIF   ('&DSECT' EQ 'YES').L0007\n&PREFIX.QUALSTYPE DS 0F  Logstream Record data format\n         AGO   .L0008\n.L0007   ANOP\n&PREFIX.QUALSTYPE DSECT   Logstream Record data format\n.L0008   ANOP\n&PREFIX.QUALSTYP DS B    X'02' Logstream record, X'82' last Logstream  *\n                         record\n         DS    B         Reserved X'00'\n&PREFIX.QUALSLEN DS H    Length of Logstream record\n&PREFIX.QUALSNAME DS CL26 Logstream name\n         DS    H         Reserved\n&PREFIX.QUALSREC DS CL32 256 bit bitstring describing record types     *\n                         being recorded to this logstream (record 0 is *\n                         in first bit of first byte, record 255 is     *\n                         last bit of byte 32.)\n&PREFIX.QUALSBSZ DS F    Logstream bufsize in bytes\n&PREFIX.QUALSTOD DS BL8  Last successful write TOD\n&PREFIX.QUALSTAT DS BL4  Logstream Status\n         ORG   &PREFIX.QUALSTAT\n&PREFIX.QUALSTB1 DS B    Status byte 1\n*  Bit definitions:\n&PREFIX.QUALSDEF EQU X'80' Default logstream, accepting records which  *\n                         are not being recorded in any other           *\n                         logstream.\n&PREFIX.QUALSACT EQU X'40' Active\n&PREFIX.QUALSCLN EQU X'20' being cleaned up\n&PREFIX.QUALSCNT EQU X'10' Connected\n&PREFIX.QUALSTB2 DS B    Status byte 2\n&PREFIX.QUALSTB3 DS B    Status byte 3\n&PREFIX.QUALSTB4 DS B    Status byte 4\n&PREFIX.QUALSTYPE_LEN EQU *-&PREFIX.QUALSTYPE\n.L0005   ANOP\n         AIF   ('&ZCBPRINT' EQ 'NO').P3\n         AIF   ('&LIST' EQ 'YES').P4\n.P3      ANOP\n         POP   PRINT\n.P4      ANOP\n.P_EXIT  ANOP\n         MEND\n./ ADD NAME=IGDAGD\n         MACRO\n         IGDAGD\nIGDAGD   DSECT\nAGD      DS    0C\n***********************************************************************\n*        AGGRGATE GROUP HEADER FOR AGGRGATE GROUP SET                 *\n***********************************************************************\nAGDP     DS    CL24                     Aggrgate Group Prefix\n         ORG   AGD+0\nAGDPID   DS    CL8                      AG ID = 'IGDAGD'\n         DS    CL2                      Unused\nAGDPSVER DS    H                        Version of macro\nAGDPCNT  DS    F                        Number of AG defs count\nAGDPTYP  DS    H                        Type of items in list\n         DS    CL2                      Reserved\nAGDPLEN  DS    F                        Length of one def AGDEF\nAGDH_LENGTH EQU *-AGD                                              +JM\n***********************************************************************\n*        AGGRGATE GROUPS                                              *\n***********************************************************************\n         DS    CL832     DIMENSION=(*)\n         ORG   AGD+24\nAGDEF    DS    CL832                    Array of AGGREGATE groups\n         ORG   AGD+24\nAGDNM    DS    CL32                     Space for name and length\n         ORG   AGD+24\nAGDNMLEN DS    H                        Reserved (would be name len)\nAGDFNAME DS    CL30                     Aggrgate Group Name\nAGDFUSER DS    CL8                      USERID of last updater\nAGDFDATE DS    CL10                     Date last updated\n         DS    CL6                      Reserved\nAGDFTIME DS    CL8                      Time last updated\nAGDFDESC DS    CL120                    Description of Aggrgate Group\nAGDSUBDF DS    CL400                    Sub definition\n*\n         MEND\n./ ADD NAME=IGDBCD\n         MACRO\n         IGDBCD\nIGDBCD   DSECT                         BASE CONFIG DEFINITION\nBCDP     DS   0CL24                    BASE CONFIGURATION DEF PREFIX\nBCDPID   DS    CL8                     ID = 'IGDBCD'\n         DS    CL2                     UNUSED\nBCDPVER  DS    H                       VERSION OF MACRO\nBCDCNT   DS    F                       COUNT  MUST BE 1\nBCDPTYP  DS    H                       TYPE OF ITEM FOLLOWING HEADER\n         DS    CL2                     RESERVED\nBCDPLEN  DS    F                       LENGTH OF BCDEF\nBCDEF    DS   0CL384                   BASE CONFIGURATION DEF   HDZ11B0\n         DS    CL32                    RESERVED\nBCDFUSER DS    CL8                     USERID OF LAST UPDATER\nBCDFDATE DS    CL10                    DATE OF LAST UPDATE\n         DS    CL6                     RESERVED\nBCDFTIME DS    CL8                     TIME OF LAST UPDATE\nBCDFDESC DS    CL120                   DESCRIPTION\nBCDSUBDF DS   0CL192                   SUB DEFINITION\nBCDFLAGS DS    CL4                     RESERVED FOR FLAGS, ETC\nBCDDEFMC DS   0CL32                    DEFAULT MANAGEMENT CLASS\nBCDMCLEN DS    H                       DEFAULT MC LENGTH OF NAME\nBCDMCNAM DS    CL30                    DEFAULT MANAGEMENT CLASS NAME\nBCDDGEOM DS   0CL8                     DEFAULT DEVICE GEOMETRY\nBCDTRKSZ DS    F                       TRACK SIZE IN BYTES\nBCDCYLCP DS    F                       CYL CAPACITY (TRK/CYL)\nBCDDUNIT DS    CL8                     DEFAULT UNIT\nBCDSRST  DS    CL8                     SMS RESOURCE STATUS TOKEN\nBCDSTAT  DS    AL1                     DATA SET STATUS SEE CONSTS\n         DS    CL3                     RESERVED\nBCDFSYSN DS   8CL8      DIMENSION=(8)  SYSTEM NAMES\nBCDSCDSN DS    CL44                    FOR ACDS ONLY  NAME OF SCDS     X\n                                       FROM WHICH IT WAS ACTIVATED\nBCDSFEAT DS   8CL2      DIMENSION=(8)  SUPPORTED SYSTEM FEATURES\n         DS    X'00010100'        018C ?                        HDZ11B0\n         DS    XL8                0190 ?                        HDZ11B0\n         DS    XL4                0198 ?                        HDZ11C0\nBCDSYSOF DS    A(BCDEND-BCDEF)    019C OFFSET TO SYSTEM DATA    HDZ11C0\nBCDSYSLN DS    A(BCDEND2-BCDSYSDT) 1A0 LENGTH OF SYSTEM DATA    HDZ11C0\n         DS    A(BCDEND-BCDEF)     1A4 ?                        HDZ11C0\n         DS    XL2                01A8 Reserved                 HDZ11C0\n         DS    CL54               01AA ?\n         DS    XL64               01E0 ?\nBCDEND   DS    0D                 01B8 ROUND TO DWORD BOUNDARY  HDZ11C0\n* BCDSYSDT DSECT                       SYSTEM RELATED DATA      HDZ11C0\nBCDSYSDT DS    0H\nBCDSSTAT DS    256CL16                 ONE ENTRY PER SYSTEM     HDZ11C0\nBCDEND2  DS    0D                      ROUND TO DWORD BOUNDARY  HDZ11C0\nBCDVALID EQU   1                       DATA SET IS VALID\nBCDINVAL EQU   2                       DATA SET IS INVALID\nBCDUNKWN EQU   3                       DATA SET STATUS IS UNKNOWN\nBCDTYP   EQU   10                      CONSTANT TYPE OF LIST\nBCDVER0  EQU   0                       IGDBCD VERSION           HDP3310\nBCDVER1  EQU   1                       IGDBCD VERSION           HDZ11B0\nBCDVER2  EQU   2                       IGDBCD VERSION           HDZ11C0\nBCDVER   EQU   2                       IGDBCD VERSION (current)\n         MEND\n./ ADD NAME=IGDDCD\n         MACRO\n         IGDDCD\nIGDDCD   DSECT\n***********************************************************************\n* ASSEMBLER OUTPUT GENERATED BY PLASMAP TO ASSEMBLER CONVERSION       *\n*  14 OCT 1986 13:04:44                                               *\n***********************************************************************\n***********************************************************************\n*        DATA CLASS DEFINITION                                        *\n***********************************************************************\nIGDDCDH  DSECT\nDCD      DS    0C                       DATA CLASS MAPPING\nDCDP     DS    CL24                     DATA CLASS PREFIX\n         ORG   DCD+0\nDCDPID   DS    CL8                      ID = 'IGDDCD'\n         DS    CL2                      UNUSED\nDCDPVER  DS    H                        VERSION OF MACRO\nDCDPCNT  DS    F                        NUMBER OF DC DEFS COUNT\nDCDPTYP  DS    H                        TYPE OF ITEMS IN LIST\n         DS    CL2                      RESERVED\nDCDPLEN  DS    F                        LENGTH OF ONE DEF DCDEF\nDCDH_LENGTH EQU *-DCD\nIGDDCDE  DSECT\nDCDNMLEN DS    H                        LENGTH OF NAME\nDCDNAME  DS    CL30                     NAME OF DATA CLASS\nDCDUSER  DS    CL8                      USERID OF LAST UPDATER\nDCDDATE  DS    CL10                     DATE OF LAST UPDATE\n         DS    CL6                      RESERVED\nDCDTIME  DS    CL8                      TIME OF LAST UPDATE\nDCDDESC  DS    CL120                    DESCRIPTION\nDCDDS    DS    CL4                      DATA SET ATTRIBUTES\nDCDRCORG DS    AL1                      DATA SET RECORG SEE CONSTANTS  X\n                                        BELOW\nDCDRECFM DS    AL1                      DATA SET RECFM SEE CONSTANTS   X\n                                        BELOW\n         DS    CL1\nDCDBLK   EQU   B'10000000'              1 = BLOCKED, 0 = UNBLKED/NULL\nDCDSTSP  EQU   B'01000000'              1 = STANDARD OR SPANNED,ELSE 0\nDCDCNTL  DS    AL1                      CARRIAGE CONTROL SEE CONSTANTS X\n                                        BELOW\nDCDSPEC  DS    CL3                      SPECIFIED FIELDS FLAGS  1 =    X\n                                        SPECIFIED, 0 = NOT SPEC'D\nDCDFRORG EQU   B'10000000'              RECORG SPECIFIED FLAG\nDCDFLREC EQU   B'01000000'              LRECL SPECIFIED FLAG\nDCDFRFM  EQU   B'00100000'              RECFM SPECIFIED FLAG\nDCDFKLEN EQU   B'00010000'              KEYLEN SPECIFIED FLAG\nDCDFKOFF EQU   B'00001000'              KEYOFF SPECIFIED FLAG\nDCDFEXP  EQU   B'00000100'              EXPIRATION ATTRIB SPEC'D FLAG\nDCDFRET  EQU   B'00000010'              RETENTION ATTRIB SPEC'D FLAG\nDCDFPSP  EQU   B'00000001'              PRIMARY SPACE SPECIFIED FLAG\nDCDFSSP  EQU   B'10000000'              SECONDARY SPACE SPEC'D FLAG\nDCDFDIR  EQU   B'01000000'              DIRECTORY BLOCKS SPEC'D FLAG\nDCDFAUN  EQU   B'00100000'              ALLOCATION UNIT SPEC'D FLAG\nDCDFAVR  EQU   B'00010000'              AVGREC SPECIFIED FLAG\nDCDFVOL  EQU   B'00001000'              VOLUME CNT SPECIFIED FLAG\nDCDFCIS  EQU   B'00000100'              CIZIZE SPECIFIED FLAG\nDCDFCIF  EQU   B'00000010'              FREE CI % SPECIFIED FLAG\nDCDFCAF  EQU   B'00000001'              FREE CA % SPECIFIED FLAG\nDCDFXREG EQU   B'10000000'              SHAREOPT XREGION SPEC'D FLAG\nDCDFXSYS EQU   B'01000000'              SHAREOPT XSYSTEM SPEC'D FLAG\nDCDFIMBD EQU   B'00100000'              VSAM IMBED SPECIFIED FLAG\nDCDFRPLC EQU   B'00010000'              VSAM REPLICATE SPECIFIED FLAG\n         DS    CL1                      RESERVED\nDCDKEY   DS    CL4                      VSAM KEY INFORMATION\nDCDKOFF  DS    H                        VSAM KEY OFFSET\nDCDKLEN  DS    AL1                      VSAM KEY LENGTH\n         DS    AL1                      RESERVED\nDCDSIZE  DS    CL24                     DATA SET SIZE INFORMATION\nDCDSPPRI DS    F                        PRIMARY SPACE AMOUNT\nDCDSPSEC DS    F                        SECONDARY SPACE AMOUNT\nDCDDIBLK DS    F                        DIRECTORY BLOCKS\nDCDAVREC DS    AL1                      AVGREC M, K, U  SEE CONSTS\n         DS    CL3                      RESERVED\nDCDAUNIT DS    F                        ALLOCATION UNIT AMOUNT\n         DS    CL4                      RESERVED\nDCDLRECL DS    F                        RECORD LENGTH\nDCDVSAM  DS    CL12                     VSAM DATA SET PROPERTIES\nDCDCISZ  DS    F                        CISIZE FOR KS, ES OR RR\nDCDFRSP  DS    CL4                      FREESPACE\nDCDCIPCT DS    H                        CI FREESPACE %\nDCDCAPCT DS    H                        CA FREESPACE %\nDCDSHROP DS    H                        VSAM SHARE OPTIONS\nDCDXSYS  DS    AL1                      VSAM XSYSTEM SHARE OPTIONS\nDCDXREG  DS    AL1                      VSAM XREGION SHARE OPTIONS\nDCDVINDX DS    CL1                      INDEX OPTIONS, ALL 0 = NONE\nDCDIMBED EQU   B'10000000'              1 = IMBED, 0 = NO\nDCDREPLC EQU   B'01000000'              1 = REPLICATE, 0 = NO\n         DS    CL1                      RESERVED\nDCDVOLCT DS    H                        MAXIMUM VOL COUNT FOR EXTEND\n         DS    CL2                      RESERVED\nDCDRETPD DS    F                        RETPD TIME ACCESSIBLE TO SYS\nDCDEXPYR DS    H                        EXPDT YEAR\nDCDEXPDY DS    H                        EXPDT ABSOLUTE DAY OF YEAR\n         DS    CL20                     RESERVED\n         DS    CL32                     RESERVED\n         DS    0C                       ROUND TO DWORD BOUNDARY\nDCDE_LENGTH  EQU *-DCDNMLEN             LENGTH OF ENTRY            +RS\nDCDORGKS EQU   1                        RECORG IS VSAM KSDS\nDCDORGES EQU   2                        RECORG IS VSAM ESDS\nDCDORGRR EQU   3                        RECORG IS VSAM RRDS\nDCDORGLS EQU   4                        RECORG IS VSAM LDS\nDCDORGNL EQU   0                        RECORG IS NULL SAM\n***********************************************************************\n*        CONSTANTS FOR DCDRECFM                                       *\n***********************************************************************\nDCDFMNUL EQU   0                        RECFM IS NULL\nDCDFMU   EQU   1                        RECFM IS UNDEFINED\nDCDFMV   EQU   2                        RECFM IS VARIABLE\nDCDFMVS  EQU   3                        RECFM IS VARIABLE SPANNED\nDCDFMVB  EQU   4                        RECFM IS VARIABLE BLOCKED\nDCDFMVBS EQU   5                        RECFM IS VARIABLE BLKD SPANNED\nDCDFMF   EQU   6                        RECFM IS FIXED\nDCDFMFS  EQU   7                        RECFM IS FIXED STANDARD\nDCDFMFB  EQU   8                        RECFM IS FIXED BLOCKED\nDCDFMFBS EQU   9                        RECFM IS FIXED BLKED SPANNED\n***********************************************************************\n*        CONSTANTS FOR DCDCNTL                                        *\n***********************************************************************\nDCDCNTLA EQU   1                        CARRIAGE CONTROL IS ANSI\nDCDCNTLM EQU   2                        CARRIAGE CONTROL IS MACHINE\nDCDCNTLN EQU   3                        CARRIAGE CONTROL IS NULL\n***********************************************************************\n*        CONSTANTS FOR DCDAVREC                                       *\n***********************************************************************\nDCDBYTES EQU   1                        AVGREC IS BYTES\nDCDKB    EQU   2                        AVGREC IS KB\nDCDMB    EQU   3                        AVGREC IS MB\nDCDTYP   EQU   8                        CONSTANT LIST TYPE\nDCDVER   EQU   0                        CONSTANT MACRO VERSION\n*\n         MEND\n./ ADD NAME=IGDDRD\n         MACRO\n         IGDDRD\nIGDDRDH  DSECT\nDRD      DS    0C                       Optical drive mapping\nDRDP     DS    CL24                     Opt drive prefix\n         ORG   DRD+0\nDRDPID   DS    CL8                      ID = 'IGDDRD'\n         DS    CL2                      UNUSED\nDRDPVER  DS    H                        VERSION OF MACRO\nDRDPCNT  DS    F                        NUMBER OF OL DEFS COUNT\nDRDPTYP  DS    H                        TYPE OF ITEMS IN LIST\n         DS    CL2                      RESERVED\nDRDELNG  DS    F                        LENGTH OF ONE DEF DCDEF\nDRDH_LENGTH EQU *-DRD\nIGDDRDE  DSECT\nDRDNMLEN DS    H                        LENGTH OF NAME\nDRDNAME  DS    CL30                     Name of opt. drive\nDRDUSER  DS    CL8                      USERID OF LAST UPDATER\nDRDDATE  DS    CL10                     DATE OF LAST UPDATE\n         DS    CL6                      RESERVED\nDRDTIME  DS    CL8                      TIME OF LAST UPDATE\nDRDLNMLEN DS    H                        LENGTH OF LIB-NAME\nDRDLNAME  DS    CL30                     NAME OF LIB\n         DS    CL2144                  ?\nDRDE_LENGTH  EQU *-DRDNMLEN             LENGTH OF ENTRY            +RS\n         MEND\n./ ADD NAME=IGDLBD\n         MACRO\n         IGDLBD\nIGDLBDH  DSECT                         Optical library header       +JM\nLBDHID   DS    CL8                     ID = 'IGDLBD'\n         DS    F                       Unknown\nLBDPCNT  DS    F                       Count of LBD entries\n         DS    F                       Unknown\nLBDELNG  DS    F                       Length of LBD entry\nLBDH_LENGTH EQU *-LBDHID               Length of header\nIGDLBDE  DSECT                         IGDLBD\nLBDNAML  DS    H                       LENGTH Optical lib\nLBDNAME  DS    CL30                    Optical lib\nLBDUSER  DS    CL8                     USERID\nLBDDATE  DS    CL10                    YYYY/MM/DD\n         DS    CL6                     Unknown\nLBDTIME  DS    CL8                     HH:MM\n         DS    CL36                    ?\nLBDLIBID DS    CL12                    HH:MM\n         DS    CL2128                  ?\nLBDE_LENGTH EQU *-LBDNAML              Length of entry\n         MEND\n./ ADD NAME=IGDMCD\n         MACRO\n         IGDMCD\nIGDMCD   DSECT\n***********************************************************************\n* ASSEMBLER OUTPUT GENERATED BY PLASMAP TO ASSEMBLER CONVERSION       *\n*  29 JUN 1987 10:17:48                                               *\n***********************************************************************\n***********************************************************************\n*        MANAGEMENT CLASS DEFINITION                                  *\n***********************************************************************\nIGDMCDH  DSECT\nMCD      DS    0C                       MANAGEMENT CLASS MAPPING\nMCDP     DS    CL24                     MANAGEMENT CLASS PREFIX\n         ORG   MCD+0\nMCDPID   DS    CL8                      ID = 'IGDMCD'\n         DS    CL2                      UNUSED\nMCDPVER  DS    H                        VERSION OF MACRO\nMCDPCNT  DS    F                        NUMBER OF MC DEFS COUNT\nMCDPTYP  DS    H                        TYPE OF ITEMS IN LIST\n         DS    CL2                      RESERVED\nMCDPLEN  DS    F                        LENGTH OF ONE DEF MCDEF\nMCDH_LENGTH EQU *-MCD                                              +RS\nIGDMCDE  DSECT\nMCDNMLEN DS    H                        LENGTH OF NAME\nMCDNAME  DS    CL30                     NAME OF MANAGEMENT CLASS\nMCDUSER  DS    CL8                      USERID OF LAST UPDATER\nMCDDATE  DS    CL10                     DATE OF LAST UPDATE\n         DS    CL6                      RESERVED\nMCDTIME  DS    CL8                      TIME OF LAST UPDATE\nMCDDESC  DS    CL120                    DESCRIPTION\nMCDFLG1  DS    CL1                      FLAGS AND RESERVED\nMCDRELE  EQU   B'11000000'              PARTIAL RELEASE CHOICES @P2A\nMCDPREL  EQU   B'10000000'              DATA SET ELIGIBLE FOR PARTIAL  X\n                                        RELEASE, 1=YES, 0=NO\nMCDPRCN  EQU   B'01000000'              CONDITIONAL PARTIAL            X\n                                        RELEASE @P2A\nMCDSPEC  DS    CL2                      ATTRIBUTE SPECIFIED FLAGS  1=  X\n                                        SPECIFIED, 0= NOT SPEC'D\nMCDFBVER EQU   B'10000000'              WAS MCDBKVS SPECIFIED?\nMCDFBVRD EQU   B'01000000'              WAS MCDBVRD SPECIFIED?\nMCDFRBK  EQU   B'00100000'              WAS MCDBKDY SPECIFIED?\nMCDFRNP  EQU   B'00010000'              WAS MCDBKNP SPECIFIED?\nMCDFEXDT EQU   B'00001000'              WAS MCDEXDAT SPECIFIED?\nMCDFEXDY EQU   B'00000100'              WAS MCDEXPDY SPECIFIED?\nMCDFPRDY EQU   B'00000010'              WAS MCDPRDY SPECIFIED?\nMCDFL1DY EQU   B'10000000'              WAS MCDL1DY SPECIFIED?\nMCDFRLMG EQU   B'01000000'              WAS MCDRLOMG SPECIFIED?\nMCDFPELE EQU   B'00100000'              WAS MCDPELEM SPECIFIED?\nMCDFBKFQ EQU   B'00010000'              WAS MCDBKFQ SPECIFIED?\n         DS    CL1                      RESERVED\n***********************************************************************\n*        DATA SET MIGRATION ATTRIBUTES -- NO MIGRATION IS ALLOWED IF  *\n*        MCDCMAU = MCDMNONE  MCDPRDY IS VALID IF MCDFPRDY IS ON       *\n*        MCDL1DY IS VALID IF MCDFL1DY IS ON AND MCDL1NOL IS OFF       *\n*        VALUE IS NOLIMIT IF MCDL1NOL IS ON                           *\n***********************************************************************\nMCDMIGRT DS    CL2\nMCDMIGF  DS    CL1                      DATA SET MIGRATION FLAGS\nMCDL1NOL EQU   B'00100000'              MIN DAYS ON LEVEL 1/LAST USE,  X\n                                        1=NOLIMIT, ELSE SEE MCDL1DY\n         DS    CL1                      RESERVED\nMCDPRDY  DS    H                        MIN DAYS ON PRIM / LAST USE\nMCDL1DY  DS    H                        MIN DAYS ON LVL 1 / LAST USE\nMCDCMAU  DS    AL1                      COMMAND OR AUTO MIGRATE SEE    X\n                                        CONSTANTS BELOW\n         DS    CL1                      RESERVED\n***********************************************************************\n*        GENERATION DATA GROUP ATTRIBUTES -- MCDRLOMG IS VALID IF     *\n*        MCDFRLMG IS ON  MCDPELEM IS VALID IF MCDFPELE IS ON          *\n***********************************************************************\nMCDGDG   DS    CL4\nMCDGDGFL DS    CL1                      GDG ATTRIBUTE FLAGS\nMCDRLOMG EQU   B'10000000'              MIGRATE OR EXPIRE ROLLED OFF   X\n                                        GDS, 1 = MIGRATE, 0 = EXPIRE\n         DS    CL1                      RESERVED\nMCDPELEM DS    H                        NUM GDG ELEMENTS ON PRIMARY\n***********************************************************************\n*        ACTION ON DATA SET EXPIRATION (RESERVED FOR FUTURE USE)      *\n***********************************************************************\nMCDEXPIR DS    CL4\n         DS    CL4                      RESERVED\n***********************************************************************\n*        DATA SET RETENTION ATTRIBUTES -- MCDEXPDY IS VALID IF        *\n*        MCDFEXDY IS ON AND MCDDYNOL IS OFF  VALUE IS NOLIMIT IF      *\n*        MCDDYNOL IS ON  MCDEXDAT IS VALID IF MCDFEXDT IS ON AND      *\n*        MCDDTNOL IS OFF  VALUE IS NOLIMIT IF MCDDTNOL IS ON  THIS    *\n*        FIELD IS A NUMBER OF DAYS IF MCDRFMT = MCDFDAYS AND IS A     *\n*        DATE IF MCDRFMT = MCDFDATE                                   *\n***********************************************************************\nMCDRETEN DS    CL12\nMCDRETF  DS    CL1                      DATA SET RETENTION FLAGS\nMCDDYNOL EQU   B'10000000'              1=EXPIRE AFTER DAYS= NOLIMIT   X\n                                        ELSE 0 AND SEE MCDEXPDY\nMCDDTNOL EQU   B'01000000'              1=EXPIRE AFTER DATE= NOLIMIT   X\n                                        ELSE 0 AND SEE MCDEXDAT\nMCDRFMT  DS    AL1                      FORMAT USED FOR MCDEXDAT DATE  X\n                                        OR DAYS  SEE CONSTANTS\n         DS    CL2                      RESERVED\nMCDEXPDY DS    F                        EXPIRE AFTER DAYS NO USE\nMCDEXDAT DS    F                        EXPIR  DAYS SINCE CREATE OR\nMCDEYEAR DS    AL2                      EXPIRE DATE SINCE CREATE\nMCDEDAY  DS    AL2                      SEE MCDRFMT TO FOR FORMAT\n***********************************************************************\n*        DATA SET BACKUP CRITERIA -- MCDBKFQ IS VALID IF MCDFBKFQ IS  *\n*        ON  MCDBKVS IS VALID IF MCDFBVER IS ON  MCDBVRD IS VALID IF  *\n*        MCBFBVRD IS ON                                           @P1C*\n*        MCDBKDY IS VALID IF MCDFRBK IS ON AND MCDNPNOL IS OFF    @P1C*\n*        VALUE IS NOLIMIT IF MCDNPNOL IS ON                       @P1C*\n*        MCDBKNP IS VALID IF MCDFRNPR IS ON AND MCDRBNOL IS OFF   @P1C*\n*        VALUE IS NOLIMIT IF MCDRBNOL IS ON                       @P1C*\n*        AUTO BACKUP IS NOT ALLOWED IF MCDAUTBK IS OFF            @P1C*\n*        NO COMMAND BACKUP IS ALLOWED IF MCDBADU = MCDBNONE       @P1C*\n*        IF MCDBADU=MCDBBOTH BOTH ADMIN AND USER COMMAND              *\n*        ALLOWED  IF MCDBADU=MCDBADM ONLY ADMIN COMMAND BACKUP IS     *\n*        ALLOWED                                                      *\n***********************************************************************\nMCDBKUP  DS    CL24                     DATA SET BACKUP CRITERIA\n         DS    CL1                      FLAGS AND RESERVED\nMCDRBNOL EQU   B'10000000'              1=RETAIN DAYS ONLY BACKUP VER= X\n                                        NOLIMIT  0=SEE MCDBKNP FOR     X\n                                        DAYS TO RETAIN            @P1C\nMCDNPNOL EQU   B'01000000'              1=RETAIN DAYS EXTRA BACKUP     X\n                                        VERSION=NOLIMIT  0=> SEE       X\n                                        MCDBKDY FOR DAYS TO RETAIN@P1C\nMCDAUTBK EQU   B'00010000'              1=AUTO BACKUP ALLOWED, ELSE 0\n         DS    CL3                      RESERVED\nMCDBKFQ  DS    H                        BACKUP FREQUENCY\nMCDBKVS  DS    H                        NUMBER OF BACKUP VERSIONS\nMCDBVRD  DS    H                        NUM OF VERSIONS  DS DELETED\nMCDBKDY  DS    H                        DAYS TO KEEP BACKUP VERSION\nMCDBKNP  DS    H                        DAYS TO KEEP ONLY BACKUP\nMCDBADU  DS    AL1                      ALLOW ADMIN OR USER BACKUP SEE X\n                                        CONSTANTS BELOW\n         DS    CL1                      RESERVED\n         DS    CL8                      RESERVED FOR BACKUP DEST CLASS\n***********************************************************************\n*        MAXIMUM RETENTION CRITERIA -- LIMITS USER SPECIFIABLE        *\n*        EXPIRATION DATE AND RETENTION PERIOD  NOLIMIT IF MCDRPNOL IS *\n*        ON, ELSE VALUE IN MCDMRTDY                                   *\n***********************************************************************\nMCDMRET  DS    CL4                      MAXIMUM RETENTION CRITERIA\nMCDMRETF DS    CL1                      MAXIMUM RETENTION FLAGS\nMCDRPNOL EQU   B'10000000'              RETPD (RETAIN PD) 1=NOLIMIT    X\n                                        ELSE SEE MCDMRTDY         @P1C\n         DS    CL1                      RESERVED\nMCDMRTDY DS    H                        MAXIMUM DAYS TO RETAIN\n         DS    CL20                     RESERVED\n         DS    CL560                    RESERVED\n         DS    0C                       ROUND TO DWORD BOUNDARY\nMCDE_LENGTH  EQU *-MCDNMLEN             LENGTH OF ENTRY            +RS\n***********************************************************************\n*        CONSTANTS FOR MCDRFMT                                        *\n***********************************************************************\nMCDNULL  EQU   0                        FIELD WAS NOT USED\nMCDFDATE EQU   1                        EXPIRE FORMAT  DATE/CREATE\nMCDFDAYS EQU   2                        EXPIRE FORMAT  DAYS/CREATE\n***********************************************************************\n*        CONSTANTS FOR MCDCMAU                                        *\n***********************************************************************\nMCDMNONE EQU   0                        NO MIGRATION ALLOWED\nMCDMCMD  EQU   1                        MIGRATE ON COMMAND ONLY\nMCDMBOTH EQU   2                        AUTO MIGRATE OR ON COMMAND\n***********************************************************************\n*        CONSTANTS FOR MCDBADU                                        *\n***********************************************************************\nMCDBNONE EQU   0                        NO USER OR ADMIN BACKUP\nMCDBADM  EQU   1                        ALLOW ADMIN COMMAND BACKUP\nMCDBBOTH EQU   2                        ALLOW ADMIN OR USER COMMAND\n***********************************************************************\n*        CONSTANTS FOR MCDRELE                                        *\n***********************************************************************\nMCDRELYE EQU   B'10'                    PARTIAL RELEASE = YES @P2A\nMCDRELCN EQU   B'01'                    PARTIAL REL=CONDITIONAL @P2A\nMCDRELNO EQU   B'00'                    PARTIAL RELEASE = NO @P2A\n***********************************************************************\n*        OTHER CONSTANTS                                              *\n***********************************************************************\nMCDTYP   EQU   7                        CONSTANT LIST TYPE\nMCDVER   EQU   0                        CONSTANT MACRO VERSION\n*\n         MEND\n./ ADD NAME=IGDSCD\n         MACRO\n         IGDSCD\nIGDSCD   DSECT\n***********************************************************************\n* ASSEMBLER OUTPUT FIXED BY APAR OY19402                     @YA19402 *\n*  14 DEC 1988                                               @YA19402 *\n***********************************************************************\n***********************************************************************\n*        STORAGE CLASS DEFINITION                                     *\n***********************************************************************\nIGDSCDH  DSECT\nSCD      DS    0C                       STORAGE CLASS MAPPING\nSCDP     DS    CL24                     STORAGE CLASS PREFIX\n         ORG   SCD+0\nSCDPID   DS    CL8                      ID = 'IGDSCD'\n         DS    CL2                      UNUSED                 @YA19402\nSCDPVER  DS    H                        VERSION OF MACRO       @YA19402\nSCDPCNT  DS    F                        NUMBER OF STOR CLASSES  COUNT\nSCDPTYP  DS    H                        TYPE OF ITEMS IN LIST\n         DS    CL2                      RESERVED               @YA19402\nSCDPLEN  DS    F                        LENGTH OF ONE DEF SCDEF@YA19402\nSCDH_LENGTH  EQU *-SCD                  LENGTH OF HEADER           +RS\nIGDSCDE  DSECT\nSCDNMLEN DS    H                        LENGTH OF NAME\nSCDNAME  DS    CL30                     NAME OF STORAGE CLASEE\nSCDUSER  DS    CL8                      USERID OF LAST UPDATER\nSCDDATE  DS    CL10                     DATE OF LAST UPDATE\n         DS    CL6                      RESERVED\nSCDTIME  DS    CL8                      TIME OF LAST UPDATE\nSCDDESC  DS    CL120                    DESCRIPTION\nSCDSUBDF DS    CL40                     SUB DEFINITION\n         ORG   SCDSUBDF\nSCDFLG1  DS    CL1                      FLAGS AND RESERVED\nSCDDFGSP EQU   B'10000000'              GUARANTEED SPACE 1=YES,0=NO\nSCDDFAVL EQU   B'01000000'              AVAILABILITY, 1=SEE SCDAVAIL   X\n                                        0=DEFAULT=STANDARD\nSCDFDIRR EQU   B'00100000'              DIRECT REPSONSE TIME OBJECT ,  X\n                                        0= DON'T CARE, 1= SEE SCDDIRR\nSCDFDIRB EQU   B'00010000'              DIRECT BIAS, 0= DON'T CARE 1=  X\n                                        SEE SCDDIRB\nSCDFSEQR EQU   B'00001000'              SEQ  REPSONSE TIME OBJECTIVE,  X\n                                        0= DON'T CARE, 1= SEE SCDSEQR\nSCDFSEQB EQU   B'00000100'              SEQ  BIAS, 0= DON'T CARE 1=    X\n                                        SEE SCDSEQB\nSCDFLG2  DS    CL1                      FLAGS AND RESERVED\n         DS    CL2                      RESERVED\nSCDDIRR  DS    F                        MICROSECOND RESPONSE TIME      X\n                                        OBJECTIVE DIRECT\nSCDSEQR  DS    F                        MICROSECOND RESPONSE TIME      X\n                                        OBJECTIVE SEQUENTIAL\nSCDAVAIL DS    AL1                      AVAILABILITY OPTIONS\nSCDDIRB  DS    AL1                      DIRECT BIAS  SEE CONSTS BELOW\nSCDSEQB  DS    AL1                      SEQ  BIAS  SEE CONSTS BELOW\n         DS    CL25                     RESERVED\n         DS    CL24                     RESERVED                   +JM\n         DS    0C                       ROUND TO DWORD BOUNDARY\nSCDE_LENGTH  EQU *-SCDNMLEN             LENGTH OF ENTRY            +RS\nSCDTYP   EQU   6                        CONSTANT FOR LIST TYPE\nSCDVER   EQU   0                        CONSTANT FOR MACRO VERSION\n***********************************************************************\n*        CONSTANTS FOR DIRECT/SEQUENTIAL BIAS                         *\n***********************************************************************\nSCDBIADC EQU   0                        BIAS = DON'T CARE\nSCDBIARD EQU   1                        BIAS = READ\nSCDBIAWR EQU   2                        BIAS = WRITE\n***********************************************************************\n*        CONSTANTS FOR AVAILABILITY                                   *\n***********************************************************************\nSCDAVLDC EQU   0                        AVAILABILITY = DON'T CARE\nSCDAVLST EQU   1                        AVAILABILITY = STANDARD\nSCDAVLCN EQU   2                        AVAILABILITY = CONTINUOUS\n*\n         MEND\n./ ADD NAME=IGDSGCLX\n         MACRO\n         IGDSGCLX\nIGDSGCL   DSECT\nSGC      DS    0C\n***********************************************************************\n*        STORAGE GROUP COLLECTION HEADER FOR STORAGE GROUP SET        *\n***********************************************************************\nSGCP     DS    CL24                     Storage Group Prefix\n         ORG   SGC+0\nSGCPID   DS    CL8                      SG ID = 'IGDSGC'\n         DS    CL2                      Unused\nSGCPSVER DS    H                        Version of macro\nSGCPCNT  DS    F                        Number of SG defs count\nSGCPTYP  DS    H                        Type of items in list\n         DS    CL2                      Reserved\nSGCPLEN  DS    F                        Length of one def SGCEF\n***********************************************************************\n*        STORAGE GROUPS                                               *\n***********************************************************************\nSGCDEF   DS    0H                       Array of STORGRP defs\n         ORG   SGC+24\nSGCNM    DS    CL32                     Space for name and length\n         ORG   SGC+24\nSGCNMLN  DS    H                        Reserved (would be name len)\nSGCNAME  DS    CL30                     Storage Group Name\nSGCUSER  DS    CL8                      USERID of last updater\nSGCDATE  DS    CL10                     Date last updated\n         DS    CL6                      Reserved\nSGCTIME  DS    CL8                      Time last updated\nSGCDESC  DS    CL120                    Description of Storage Group\nSGCSBDF  DS    0CL1                     Sub Definition\nSGCTYPE  DS    CL1                      Collection SG type\n         DS    CL1                      Specified by user flags\nSGCVERSP EQU   B'10000000'              User specified SGCVERSN\n         DS    CL2                      Reserved\nSGCVERSN DS    F                        Number of copy versions\n         DS    CL64                     Reserved\nSGCOLOF  DS    F                        Offset from SGCP to SGCOL\nSGCOLLN  DS    F                        SGCOL Length\n         DS    CL40                     Reserved\nSGCEND   DS    0D                       Round to DWORD boundary\n***********************************************************************\n*    Collection related data, one entry per system.                   *\n*    The basing expression is not provided as it can be affected      *\n*    by use of LIKE, etc. Respecify it based on the address of        *\n*    your copy of SGCEF + the value in SGCSYSOF.                      *\n***********************************************************************\nSGCOL    DSECT                          Collection related data\n         DS    CL4                      Reserved\n         DS    CL2                      Reserved for SGCNUM expand\nSGCNUM   DS    H                        Number of SGs in collection\nSGCNAMES DS    256CL40                  SG Name Array\n         ORG   SGCNAMES\nSGCOLNL  DS    H                        SG Name Length\nSGCOLNM  DS    CL30                     SG Name\n         DS    CL8                      Reserved\n         ORG\nSGCOLEND DS    0D                       Round to DWORD boundary\n***********************************************************************\n*        Constants                                                    *\n***********************************************************************\nSGCVER   EQU   1                        Construct Version\nSGCPOOL  EQU   0                        Collection SG type is POOL\nSGCVERFR EQU   2                        Default number of HSM Fast\n*                                        Replicate versions\n         MEND\n./ ADD NAME=IGDSSIVT\n         MACRO\n         IGDSSIVT\nIGDSSIVTAB DSECT\nIGDS_ID  DS    CL8                      EYECATCHER 'IGDSSIVT'\nIGDS_LEN DS    H                        LENGTH IGDSSIVT\nIGDS_VER DS    H                        VERSION\nIGDS_MOD DS    F                        IGD MODULE MAP\nIGDSASID DS    F                        ASID\nIGDSASCB DS    F                        ASCB\nIGDSLX   DS    F                        LX-INDEX\nIGDSCONS DS    F                        CONSOLE-ID\nIGDSSYID DS    CL8                      SYSTEM ID\nIGDSINT  DS    F                        INTERVAL\nIGDSACDS DS    CL44                     DSNAME ACDS\nIGDSCODS DS    CL44                     DSNAME COMMDS\nIGDSPARM DS    CL2                      IGDSMSXX PARMLIB SUFFIX\nIGDSOPFL DS    XL2                      OPERATOR COMMANDS FLAGS\nIGDSPRMT DS    F                        PROMPT OPTIONS\nIGDSTRT  DS    F                        TRACE-TABLE\nIGDSAUTH DS    F                        AUTHORIZATION OPTIONS\nIGDSSMSS DS    F                        SMS ADDRESS SPACE STATUS\nIGDSREST DS    F                        RESTARTS\nIGDSADRS DS    F                        ADDRESSSPACE RESTART\nIGDSSMSV DS    F                        SMS AS VECTOR TABEL\nIGDSSQPF DS    CL4                      SEQ_PREFIX\nIGDSSQNO DS    F                        SEQ_NUM\nIGDSACS  DS    0H                       SEQ_NUM\nIGDSACSC DS    F                        ACS_SC_EXIT\nIGDSACDC DS    F                        ACS_DC_EXIT\nIGDSACMC DS    F                        ACS_MC_EXIT\n         DS    5F                       ?\nIGDSACOP DS    F                        ACS_OPTIONS\nIGDSSMST DS    D                        SMS RESOURCE TOKEN\nIGDSICMO DS    F                        ICM OPTIONS\nIGDSDCFI DS    F                        DCF RST INTERVAL\nIGDSSPS2 DS    F                        IGDSSIP2 SPACE SWITCH\nIGDSSPN2 DS    F                        IGDSSIP2 NO SPACE SWITCH\nIGDSSPN3 DS    F                        IGDSSIP3 NO SPACE SWITCH\nIGDSSPN4 DS    F                        IGDSSIP4 NO SPACE SWITCH\nIGDSSPN5 DS    F                        IGDSSIP5 NO SPACE SWITCH\n         DS    2F                       ?\nIGDSSIV2 DS    F                        IGDSSIV2 POINTER\n         DS    F                        ?\nIGDSSSAT DS    F                        SSAT INDEX\nIGDSSTFL DS    F                        STATUS FLAG\n         MEND\n./ ADD NAME=IGGCAXWA\n         MACRO\n         IGGCAXWA\nIGGCAXWA DSECT                         Catalog Work Area\nCAXID    DS    C'CAX'                  CAX ID\nCAXFLG4  DS    X                       FLAGS (4)\nCAXLOCK  EQU   X'01'                   Catalog locked            RS0301\nCAXCHN   DS    A(IGGCAXWA)             NEXT CAXWA IN CHAIN\nCAXFLGS  DS    X                       FLAGS (1)\nCAXCLS   EQU   X'20'                   CLOSE in control\nCAXMCT   EQU   X'04'                   MASTER CATALOG\nCAXCMR   EQU   X'02'                   CATALOG MANAGEMENT INVOKED\nCAXSCR   EQU   X'01'                   SCHEDULER INVOKED\nCAXFLG2  DS    X                       FLAGS (2)\nCAXF2DT  EQU   X'80'                   Catalog Deleted\nCAXF2REC EQU   X'02'                   Recoverable Catalog\nCAXFLG3  DS    X                       FLAGS (3)\nCAXF3ICF EQU   X'20'                   ICF Type Catalog          RS1199\nCAXF3SO4 EQU   X'02'                   ICF Share Option          RS1199\nCAXF3SHD EQU   X'01'                   ICF Cat on Shared Dasd    RS1199\nCAXFLG5  DS    X                       FLAGS (5)                 RS1199\nCAXXX    EQU   X'80'                   CAX entry ok??????        RS0310\nCAXLCDB  EQU   X'10'                   VLF Cache active          RS1199\n         DS    3F                                                RS1199\nCAXACB   DS    V(IFGACB)               CATALOG'S ACB\nCAXUCB   DS    V(UCBOB)                CATALOG'S UCB address (24-bit)\n         DS    FL3,FL3,FL3,FL3,H,H,A\nCAXCNAM  DS    CL44                    CATALOG'S DSNAME\n         ORG   IGGCAXWA+147                                      RS1199\nCAXFLG6  DS    X                       FLAGS (6)                 RS1199\nCAXCDSCA EQU   X'20'                   VLF Cache active          RS1199\nCAXISC   DS    F                       ISC TABLE POINTER         RS1199\n         ORG   IGGCAXWA+188\nCAXREUCB DS    V(UCBOB)                CATALOG'S UCB ADDRESS (31-bit)\n         DS    CL4,F                                             RS1199\nCAXDSABP DS    F                       DSAB Pointer              RS1199\n         DS    CL24                                              RS0701\nCAXRECO  DS    F                       Records                   RS0701\nCAXSEAR  DS    F                       Search                    RS0701\nCAXFOUND DS    F                       Found                     RS0701\nCAXDELET DS    F                       Deletes                   RS0701\nCAXUPD   DS    F                       Upd                       RS0701\nCAXPURGE DS    F                       Purge                     RS0701\n         DS    CL4                                               RS0701\nCAXECS   DS    F                       ECS indicator             RS0301\n         MEND\n./ ADD NAME=IGGCRT\n         MACRO\n         IGGCRT\nCRT      DSECT\nCRTID    DS    C'CRT-'  or 'CRT/'      CB ID  CRT/ --> CRT2\nCRTL     DS    F'4096'                 CB length?\n         DS    F                       ??\n         DS    X                       ??\nCRTFLAG1 DS    X                       Flag\nCRTALIT  EQU X'80'                     Catalog Alias Table\nCRTASID  DS    H                       Catalog Asid\n         DS    CL12                    ??\nCRTCTASK DS    F           +x'1C'      CAS MOTHER TASK\n         DS    CL112       +x'20'      ??\n         DS    CL8         +x'90'      ??\nCRTSTLOW DS    F           +x'98'      Service Task lower limit\nCRTSTCUR DS    F           +x'9C'      Service Tasl Current\n         DS    CL3456      +x'A0'      ??\n         DS    CL8         +x'E20'     ??\nCRTSULIM DS    F           +x'E28'     Service Task Upper Limit\nCRTOPCAT DS    F           +x'E2C'     max # of open catalog\nCRTHTASK DS    F           +x'E30'     Highest Service Task\n         DS    CL12                    ??\n         DS    CL32        +x'E40'     ??\nCRTCOMP  DS    CL8         +x'E60'     Catlog Component Level\nCRTMTASK DS    F           +x'E68'     CAS Modify Task\nCRTATASK DS    F           +x'E6C'     CAS Allocation Task\n         DS    CL16        +x'E70'     ??\n         DS    CL4         +x'E80'     ??\nCRTNOTEX DS    X           +x'E84'     Notify extent\n         DS    CL10        +x'E85'     ??\n         DS    CL64        +x'E90'     ??\n         DS    CL12        +x'ED0'     ??\nCRTANTSK DS    F           +x'EDC'     CAS Analyze Task\n         DS    CL240       +x'EE0'     ??\n         DS    CL8         +x'FD0'     ??\n         DS    X           +x'FD8'     ??\nCRTFLAG3 DS    X           +x'FD9'     Flag\nCRTDSCHK EQU X'20'                     Dataset Syntax Checking\nCRT2     DSECT\nCRT2ID   DS    C'CRT/'                 CB ID  CRT2\nCRT2L    DS    F'888'                  CB length?  X'0378'\n         DS    F                       ??\n         DS    X                       ??\nCRT2FLAG1 DS    X                      Flag\nCRT2ALIT EQU X'80'                     Catalog Alias Table\nCRT2ASID DS    H                       Catalog Asid\n         DS    CL12                    ??\nCRT2CTASK DS    F          +x'1C'      CAS MOTHER TASK\n         DS    CL112       +x'20'      ??\n         DS    CL8         +x'90'      ??\nCRT2STLOW DS    F          +x'98'      Service Task lower limit\nCRT2STCUR DS    F          +x'9C'      Service Tasl Current\n         DS    CL248       +x'A0'      ??\n         DS    CL8         +x'198'     ??\nCRT2SULIM DS    F          +x'1A0'     Service Task Upper Limit\nCRT2OPCAT DS    F          +x'1A4'     max # of open catalog\nCRT2HTASK DS    F          +x'1A8'     Highest Service Task\n         DS    CL12        +x'1AC'     ??\n         DS    CL32        +x'1B8'     ??\nCRT2COMP  DS    CL8        +x'1D8'    Catlog Component Level\nCRT2MTASK DS    F          +x'1E0'     CAS Modify Task\nCRT2ATASK DS    F          +x'1E4'     CAS Allocation Task\n         DS    CL16        +x'1E8'     ??\n         DS    CL4         +x'1F8'     ??\nCRT2NOTEX DS    X          +x'1FC'     Notify extent\n         DS    CL10        +x'1FD'     ??\n         DS    CL64        +x'207'     ??\n         DS    CL12        +x'247'     ??\nCRT2ANTSK DS    F          +x'254'     CAS Analyze Task\n         DS    CL240       +x'258'     ??\n         DS    CL4         +x'348'     ??\nCRT2TRK1 DS    H           +x'34C'     Default VVDS Space\nCRT2TRK2 DS    H           +x'34E'     Default VVDS Space\n          DS    X          +x'350'     Flag\nCRT2FLAG3 DS    X          +x'351'     Flag\nCRT2DSCHK EQU X'20'                    Dataset Syntax Checking\nCRT2FLAG4 DS    X          +x'352'     Flag\n         MEND\n./ ADD NAME=IGVPPD\n         MACRO\n         IGVPPD\nPPD      DSECT                         Cell Pool Primary Descriptor\nPPDID    DS    C'PPD '                 Eyecatcher 'PPD '           @RS\nPPDCPID  DS    A(PPDIDENT)             Cell-Pool-Id                @RS\nPPDSPD   DS    A                       Pointer to Top SPD          @RS\nPPDPCNT  DS    F                       Primary Cell-Count          @RS\nPPDSCNT  DS    F                       Secondary Cell-Count        @RS\nPPDSPID  DS    0H                      Halfword Subpool-ID         @RS\n         DS    CL1                     Reserved                    @RS\nPPDSP    DS    FL1                     Subpool ID                  @RS\nPPDKEY   DS    FL1                     Protection Key (bits 4-7)   @RS\nPPDFLAGS DS    CL1                     Flags                       @RS\nPPDTCB   DS    V(TCB)                  TCB address                 @RS\nPPDCSIZE DS    F                       Cell size                   @RS\nPPDPSIZE DS    F                       Size of primary extent      @RS\nPPDSSIZE DS    F                       Size of secondary extent    @RS\nPPDASCB  DS    V(ASCB)                 ASCB address                @RS\nPPDNEXT  DS    A(PPD)                  next PPD                    @RS\nPPDINDX  DS    F                       index to SPD                @RS\n         DS    F                       doubleword boundary         @RS\nPPD_ENTRY_LENGTH EQU *-PPD             length                      @RS\n*                                                                  @RS\nPPDIDENT DSECT                         Start of an entry           @RS\nPPDIDEYE DS    CL24                    Cell-Pool-ID                @RS\n         MEND\n./ ADD NAME=IHAAXAT\n         MACRO\n         IHAAXAT\nAXAT     DSECT         Auth Index Allocation Table\nAXATHDR  DS    0CL16   AXAT header\nAXATNAME DS    CL4     id 'AXAT'\nAXATCT   DS    F       Count of entries in the AXAT\nAXATAVAL DS    F       Unreserved AX in AXAT\nAXATRSVD DS    F       Reserved\nAXATENT  DS    0XL12   Auth Index entry\n*                      the first two AX entries are permanently\n*                      assigned 0 is unauthorized, 1 is system auth\n*                      All other entries are zero when unreserved\n*                      or contain a SToken value when reserved\nAXATSTKN DS    D       Stoken of owning address space\nAXATETC  DS    H       Count of entry tables which use this AX as EAX\nAXATFLG1 DS    X       flags\nAXATEAXC EQU   X'80'   EAX exist or has existed in an ET which has\n*                      been connected\nAXATRSV1 DS    X       reserved\n         MEND\n./ ADD NAME=IHADCQ\n         MACRO\n         IHADCQ\nDCQ      DSECT                         Device class table\nDCQNAME  DS    C'DCQ '\nDCQLNGTH DS    H\nDCQCOUNT DS    H\nDCQFIRST DS    A(DCQELMNT)             First element\nDCQDSTCT DS    XL4\nDCQUCBNO DS    F\nDCQELMNT DSECT\nDCQCHAIN DS    A(DCQELMNT)             NEXT DCQ\nDCQDEVCL DS    X                       DEVICE CLASS\nDCQFLG1  DS    X                       RESERVED\nDCQUCBCT DS    H                       # OF UCBS\nDCQUCBAD DS    V(UCBOB)                FIRST UCB\nDCQDEVNM DS    CL8                     CLASS NAME\n         DS    XL8                     RESERVED\n         MEND\n./ ADD NAME=IHAETEX\n           MACRO\n           IHAETEX\nETEX     DSECT\n         DS    0D             ENTRY TABLE ENTRY DESCRIPTION\n         DS    A\nETEXEPA  DS    A              entry point\n         ORG   *-1\nETEXPBYTE DS    B             BYTE NAME TO ACCESS ETEPS\nETEXPS    EQU   X'01'         CALLED ROUTINE EXECUTES (0) SUPERVISOR\nETEXAKM  DS    H              MASK OF STORAGE KEYS AUTHORIZED TO\n*                             INVOKE THIS ROUTINE\nETEXASID DS    H             ASID IN WHICH THE CALLED ROUTINE WILL\nETEXEKM  DS    H             KEY MASK TO BE COMBINED WITH CALLERS KEY\nETEXR00E DS    CL2            RESERVED                             @L1C\nETEXOPTB1 DS   B              ETE OPTIONS BYTE                     @L1A\nETEXEK   DS    B              ENTRY KEY (HIGH 4 BITS)              @L1A\nETEXEAX  DS    H              EXTENDED AUTHORITY INDEX             @L1A\nETEXASTE DS    A              REAL ADDRESS OF THE ASTE\nETEXPARM_1 DS  A              First part of PARM\nETEXPARM_2 DS  A              Second part of PARM\nETEXEND  EQU   *\nETEXLEN  EQU   ETEXEND-ETEX   LENGTH OF THE ETEX\n         MEND  ,  */\n./ ADD NAME=IHALLCB\n         MACRO\n         IHALLCB\nLLCB     DSECT                         LLA Control Block\nLLCBID   DS    C'LLCB'                 TABLE ID 'LLCB'\nLLCBLVEL DS    XL1                     LEVEL NUMBER OF THIS LLCB\nLLCBFLGS DS    B                       FLAG BYTE\nLLCBAVAL EQU   X'80'                   LLA SEARCH SERVICES AV.\nLLCBSTOP EQU   X'40'                   LLA TERMINATED BY OPERAT.\nLLCBFAIL EQU   X'20'                   RESTART IN PROGRESS\nLLCBX1OK EQU   X'10'                   CSVLLIX1 CAN BE CALLED      ESA\nLLCBTLNK EQU   X'08'                   LNKLST WAS TRUNCATED\nLLCBTLPA EQU   X'04'                   LPALST WAS TRUNCATED\nLLCBRSV3 DS    CL2                     RESERVED\nLLCBRSCD DS    F                       COMPONENT REASON CODE\nLLCBASCB DS    A                       ADDRESS OF LLA ASCB\nLLCBTCB  DS    A                       ADDRESS OF LLA STEP TCB\n         DS    A,F                     RESERVED\nLLCBNXT1 DS    A\nLLCBDOM  DS    XL4                     WTO ID TO DELETE ERR MESS\nLLCBABCC DS    XL4                     ABEND CC (SDWAABCC)\n         ORG   LLCBABCC                                          RS0999\nLLCBCMPF DS    C                       FLAGS IN COMPLETION CODE\nLLCBRSOK EQU   X'04'                   LLCBRSCD IS VALID\nLLCBCMPC DS    XL3                     SYSTEM/USER CC\nLLCBXXLN DS    CL2                     SUFFIX OF \"LNKLSTNN\"\nLLCBXXLP DS    CL2                     SUFFIX OF \"LPALSTNN\"\n         MEND\n./ ADD NAME=IHALLCB3                   LLCB extension for ESA\n         MACRO\n         IHALLCB3\n         DS    A,F                     TCB ADDRESS ????\n         DS    F,F                     CSVLLTCH ADDRESS\n*        DS    F,5F                    FLAGS ????               RS0999\n         DS    F,6F                    FLAGS ????               RS0999\n         DS    A                       LLCB START POINTER\n         DS    A                       LLCB END   POINTER\nLLCBLLT  DS    A                       LLT POINTER\n         DS    A                       MASTER ASCB ADDRESS ???\n         DS    A                       LPAT POINTER\n         DS    A                       LPAT LAST ENTRY POINTER\n         DS    6F                      RESERVED ???\nLLCBLLDR DS    V(LLDR)            088  LLDR POINTER\n         DS    A                       LLDR POINTER ???\nLLCBPARM DS    CL2                     CSVLLA PARMLIB SUFFIX\n         DS    XL2\n         DS    A                       TCB ADDRESS ???\nLLCBNAME DS    CL8                     LLA ADDRESS SPACE NAME\n         MEND\n./ ADD NAME=IHALLDR\n         MACRO\n         IHALLDR\nLLDR     DSECT\nLLDRNAME DS    C'LLDR'                 LLDR acronym\n         DS    XL2                     Flags ?\nLLDRLEN  DS    H                       control block len (X'18')\n         DS    F                       Reserved (x'00') ?\nLLDRLLDS DS    A                       LLDS pointer\n         DS    F                       Reserved (x'00') ?\nLLDRTOD  DS    A                       TOD LLA start ?\nLLDR_LENGTH EQU *-LLDR\n         MEND\n./ ADD NAME=IHALLDS\n         MACRO\n         IHALLDS\nLLDS     DSECT\nLLDSNAME DS    C'LLDS'                 LLDS acronym\nLLDSFLG1 DS    B                       FLAG ???\nLLDSFLG2 DS    B                       Flag byte\nLLDSLTSE EQU   X'80'                   1=LNKLST treated as a single    X\n                                       entity by LLA (see APAR OW06194)\nLLDSLEN  DS    H                       LLDS control block length\nLLDSTOD  DS    XL4                     LLA start time ?\n         DS    F,A,A\nLLDSNUM  DS    F                       Number of LLDS entries\nLLDSENT  EQU   *\nLLDSUCB  DS    A(UCBOB)                UCB Pointer\n         DS    BL4                     Flag bytes ???\n         DS    A                       Pointer to other entries?\nLLDSLLDB DS    V(LLDB)            028  LLDB Pointer\nLLDSLLLS DS    A(LLLS)                 LLLS Pointer\nLLDSFLG3 DS    X'8A'                   Flag byte\nLLDSLNK  EQU   X'80'                   On=LNKLST, Off=PRIVATE\nLLDSFLG4 DS    X'C0'                   Flag byte\nLLDSNOFR EQU   X'80'                   On=NOFREEZE\nLLDSFREZ EQU   X'40'                   On=FREEZE\n         DS    XL10                    Reserved ??? (X'00')\nLLDSELEN EQU   *-LLDSENT               LLDS entry length (32)\nLLD9     DSECT                         LLDS for z/OS R9          RS0408\nLLD9NAME DS    C'LLDS'                 LLDS acronym\nLLD9FLG1 DS    B                       FLAG ???\nLLD9FLG2 DS    B                       Flag byte\nLLD9LTSE EQU   X'80'                   1=LNKLST treated as a single    X\n                                       entity by LLA (see APAR OW06194)\nLLD9LEN  DS    H                       LLD9 control block length\nLLD9TOD  DS    XL4                     LLA start time ?\n         DS    F,A,A\nLLD9NUM  DS    F                       Number of LLD9 entries\n         DS    7F                      ????????                  JH0907\nLLD9ENT  EQU   *\nLLD9UCB  DS    A(UCBOB)                UCB Pointer\n         DS    BL4                     Flag bytes ???\n         DS    A                       Pointer to other entries?\nLLD9LLDB DS    V(LLDB)            028  LLDB Pointer\nLLD9LLLS DS    A(LLLS)                 LLLS Pointer\nLLD9FLG3 DS    X'8A'                   Flag byte\nLLD9LNK  EQU   X'80'                   On=LNKLST, Off=PRIVATE\nLLD9FLG4 DS    X'C0'                   Flag byte\nLLD9NOFR EQU   X'80'                   On=NOFREEZE\nLLD9FREZ EQU   X'40'                   On=FREEZE\n         DS    XL10                    Reserved ??? (X'00')\nLLD9ELEN EQU   *-LLD9ENT               LLD9 entry length (32)\n         MEND\n./ ADD NAME=IHALLLS\n         MACRO\n         IHALLLS\nLLLS     DSECT\nLLLSNAME DS    C'LLLS'                 LLLS acronym\n         DS    BL4                     Flags ???\nLLLSTOD  DS    XL4                     TOD library added\n         DS    A\n         DS    15F                     Reserved ???\n         DS    XL2\nLLLSVOL  DS    CL6                     Volume serial\nLLLSDSN  DS    CL44                    Dataset name\nLLLSDDN  DS    CL8                     LLA's DDNAME\n         DS    A                       Pointer (LLLS+X'A0')\n         DS    A                       Pointer (LLLS+X'F8')\n         DS    6F                      Reserved ???\n         DS    BL4                     Flags ???\nLLLS_LENGTH EQU *-LLLS\n         MEND\n./ ADD NAME=IHALLT\n         MACRO\n         IHALLT &DSECT=YES             LNKLST/LPALST tables\nLLT      DSECT\nLLTID    DS    C'LLT '                 BLOCK ACRONYM\nLLTCOUNT DS    F                       NUMBER OF ENTRIES\nLLTENTRY DS    0CL45                   DSNAME ENTRY\nLLTDSLTH DS    FL1                     DSNAME LENGTH AFTER TRUNCATION\nLLTDSN   DS    CL44                    DATA SET NAME\nLLTNEXT  EQU   *                       NEXT ENTRY\n         MEND\n./ ADD NAME=IHALXAT\n         MACRO\n         IHALXAT\nLXAT     DSECT         Linkage Index Allocation Table\n*        The first entry is a 8-byte header followed by up to 1024\n*        8-byte entries\n*        z/OS R6+\n*        The first entry is a 32-byte header followed by\n*        16-byte entries\nLXATHDR  DS    0CL32   LXAT header\nLXATLXAT DS    CL4     id 'LXAT'\nLXATHILX DS    H       highest LX contained in LXAT\nLXATMSLX DS    H       Maximum System LX in LXAT\n* The following fields only present in z/OS 1.6+\nLXATHISLTBLXI   DS  F   Highest \"Big\" LX\nLXATMSBLXI      DS  F   Max System \"Big\" LX\nLXATHILXI_USED  DS  F\nLXATHIBLXI_USED DS  F\n                DS  XL8 Reserved\n*\n* LXATINCR = 32 = number of entries per LXAT expansion\n* LXATMAX = 1023 = maximum lx value supported\n*           2047 = maximum lx value supported (OS/390 R5 and up)\n*\nLXATINDX DS    0XL16   Array of Linkage Indexes\nLXATASID DS    H       Asid owning this index (valid only when\n*                      LXATOWND is on)\nLXATBIND DS    H       Count of address spaces using this index.\n*                      (for a system LX that was never connected this\n*                      value will be x'ffff')\nLXATETCT DS    H       Count of entry tables connected to this index.\n*                      (for a system LX which is connected this\n*                      value will be x'ffff')\nLXATFLGS DS    X       flags\nLXATRIP  EQU   X'80'   Reserve in process for this LX\nLXATOWND EQU   X'40'   This LX is reserved (owned) LX\nLXATSYS  EQU   X'20'   This is a System LX\nLXATDORM EQU   X'10'   This System LX is dormant\nLXATREUS EQU   X'08'   Re-usable LX\nLXATWASA EQU   X'04'   This LX was assigned\nLXATRSV2 DS    X       reserved\n* The following fields only present in z/OS 1.6+\nLXATSEQNUM DS    F      Used by LX Re-use facility\nLXATRSV3   DS    XL4    Reserved\n*\n*\nLXATINCR EQU   32      Number of entries per LXAT expansion\n* This Equate is not in use but the number has been increased from\n* 1023 to 2047 in OS/390 R5\nLXATMAX  EQU   2047    Maximum lx value supported\n         MEND\n./ ADD NAME=IHANTTE\n         MACRO\n         IHANTTE\nNTTH     DSECT                         Name/Token Header           @RS\nNTTHEYEC DS    C'NTTH'                 Eyecatcher 'NTTH'           @RS\nNTTHELEN DS    F                       Length Name/Token           @RS\n         DS    CL56                    ?                           @RS\nNTTHNTTF DS    A                       First NTTE                  @RS\nNTTHNTTL DS    A                       Last  NTTE                  @RS\nNTTE     DSECT                         Name/Token Entry            @RS\nNTTEEYEC DS    C'NTTE'                 Eyecatcher 'NTTE'           @RS\n         DS    XL4                     ?                           @RS\nNTTENAME DS    CL16                    Name                        @RS\nNTTETOKN DS    CL16                    Token                       @RS\n         DS    CL16                    ?                           @RS\n         DS    XL2                                                 @RS\nNTTEASID DS    H                       Asid                        @RS\n         DS    XL4                     ?                           @RS\nNTTENEXT DS    F                       Next entry                  @RS\nNTTEPREV DS    F                       Previous entry              @RS\n         MEND\n./ ADD NAME=IHARPP\n         MACRO\n         IHARPP\nRPP      DSECT                         Recovery PIE PICA\nRPPNPTR  DS    A(RPP)                  Next RPIEPICA\nRPPPRB   DS    A(RBBASIC)              Corresponding PRB\nRPPPIE   DS    V(PIE)                  PIE address\nRPPPICA  DS    V(PICA)                 PICA address\nRPPFLAG1 DS    X                       Flags\nRPPTYPE  EQU   X'80'                   On if ESPIE\nRPPPIE17 EQU   X'40'                   IC 17 (page fault)\nRPPMASK  DS    X,X,X                   Mask\nRPPEXITA DS    A                       Addr of exit routine\nRPPPARMA DS    A                       Parameter\nRPPITMK  DS    XL4                     Interrupt mask\nRPPTOKEN DS    XL4                     Token\n         MEND\n./ ADD NAME=IHAPICA\n         MACRO\n         IHAPICA\nPICA     DSECT\nPICAPRMK DS    B                   PROGRAM MASK TO BE USED IN THE PSW\nPICEXITA DS    AL3                 USER'S PROGRAM INTERRUPTION EXIT RTN\nPICAITMK DS   0XL4                 PROGRAM INTERRUPTION TYPES\nPICITMK1 DS    BL1\nPICAEXT  EQU   X'80'               AN EXTENDED PICA IS IN EFFECT\nPICITMK2 DS    BL1\nPICITMK3 DS    BL1\n         MEND\n./ ADD NAME=IHARTCT\n         MACRO\n         IHARTCT\nRTCT     DSECT                         RTM CONTROL TABLE\nRTCTNAME DS    C'RTCT'\nRTCTSAP  DS    XL4                     SYSABEND initial values\nRTCTSUP  DS    XL4                     SYSUDUMP initial values\nRTCTSYD  DS    XL4                     SYSMDUMP initial values\n         DS    5F\nRTCTSDDS DS    V(SDDSQ)                SYS1.DUMP QUEUE\nRTCTSDDC DS    H                       NUMBER OF ENTRIES IN SDDSQ\n         ORG   RTCT+X'058'\nRTCTDSCA DS    V(DSC)                  DAE comm area\n         ORG   RTCT+X'0EC'\nRTCTSAO  DS    XL4                     SYSABEND effective options\nRTCTSUO  DS    XL4                     SYSUDUMP effective options\nRTCTSYO  DS    XL4                     SYSMDUMP effective options\nRTCTSDO  DS    XL4                     SDUMP effective options\n         ORG   RTCT+X'101'\nRTCTBUFV DS    XL4                     BUFFERS=nnnn value\n         ORG   RTCT+X'158'\nRTCTOPT2 DS    0XL8                    Type and exit flags\nRTCTSD1  DS    0XL4                    SDUMP flags\nRTCTTYP1 DS    X                       TYPE FLAG\nRTCTXMEM EQU   X'80'                   XMEM\nRTCTXMEE EQU   X'40'                   XMEME\nRTCTNOLC EQU   X'20'                   NOLOCAL\n         DS    X\nRTCTEX1  DS    X                       EXIT FLAG1\nRTCTGRSQ EQU   X'80'                   GRSQ                     RS0803\nRTCTCPL  EQU   X'10'                   COUPLE\nRTCTXES  EQU   X'08'                   XESDATA\nRTCTWLM  EQU   X'02'                   WLM\n         DS    X\nRTCTSM1  DS    0XL4                    SYSMDUMP flags\nRTCTSMTY DS    XL2                     Type options\nRTCTSMEX DS    0XL2                    Exit options\nRTCTSMX1 DS    X                       1st exit byte\nRTCTMGRS EQU   X'80'                   GRSQ\n         DS    X\n         ORG   RTCT+X'16A'\nRTCTMEX1 DS    X                       FIRST EXIT BYTE\nRTCTMXGR EQU   X'80'                   1=GRSQ OPTION\nRTCTSMX2 DS    X                       SECOND EXIT BYTE\nRTCTRTSD DS    V(RTSD)             16C RTCT SDUMP Extension        @522\n         ORG   RTCT+X'1A4'\nRTCTMMTI DS    XL4                     MAX MESSAGE WAIT TIME\n         DS    XL8\nRTCTMXSP DS    XL4                     MAXSPACE\n         MEND\n./ ADD NAME=IHASCE\n         MACRO\n         IHASCE\nSCE      DSECT            SLIP CONTROL ELEMENT\n         ORG   SCE+4                                             RS0402\nSCESCVAP DS    F                       SCVA pointer              RS0402\n         ORG   SCE+20\nSCEFLG1  DS    X                       FLAGS\nSCEDSABL EQU   X'80'                   OFF=ENABLED,ON=DISABLED\n         ORG   SCE+32\nSCEID    DS    CL4                    TRAP IDENTIFIER\n         ORG   SCE+48\nSCEIDQF  DS    A                      FORWARD POINTER\n         MEND\n./ ADD NAME=IHASCVA                                              RS0402\n         MACRO\n         IHASCVA\nSCVA     DSECT\nSCVAHDR  DS    CL4                     Header 'SVCA'\nSCVALEN  DS    H                       Length\n         DS    H\nSCVACOM  DS    0C\nSCVACOLN DS    H                       Length variable area\nSCVACOID DS    X                       ID variable area\nSCVAIDL  EQU X'01'                     mark last entry\nSCVAIDCC EQU X'02'                     COMP entry\nSCVAIDAS EQU X'03'                     ASID entry\nSCVAIDJN EQU X'04'                     Jobname ID\nSCVAIDJS EQU X'05'                     JSPGM ID\nSCVAIDPV EQU X'06'                     PVTMOD ID\nSCVAIDLP EQU X'07'                     LPAMOD ID\nSCVAIDAD EQU X'08'                     ADDRESS ID\nSCVAIDMD EQU X'09'                     MODE ID\nSCVAIDER EQU X'10'                     ErrTyp ID\nSCVAIDML EQU X'11'                     MatchLim ID\nSCVAIDPL EQU X'12'                     PrcntLim ID\nSCVAIDRA EQU X'13'                     Range ID\nSCVAIDDA EQU X'14'                     Data ID\nSCVAIDSD EQU X'15'                     SData ID\nSCVAIDSL EQU X'16'                     SumList ID\nSCVAIDLS EQU X'17'                     List ID\nSCVAIDAL EQU X'18'                     AsidList ID\nSCVAIDTD EQU X'19'                     TrData ID\nSCVAIDSA EQU X'20'                     AsidSA ID\nSCVAIDDP EQU X'21'                     DumpId ID\nSCVAIDRC EQU X'22'                     ReasonCode ID\nSCVAIDNU EQU X'23'                     NucMod ID\nSCVAIDPA EQU X'24'                     PswAsc ID\nSCVAIDDN EQU X'25'                     DSPName ID\nSCVAIDDS EQU X'26'                     DSSA ID\nScvaIdRemote EQU X'27'                 Remote ID\nScvaIdSt EQU X'28'                     StrList ID\nScvaIdJl EQU X'29'                     Joblist ID\nScvaIdRefBefor EQU X'30'               Refresh before ID\nScvaIdRefAfter EQU X'31'               Refresh after ID\nSCVAIdMsg EQU X'32'                    MSGID ID\nSCVAIDMX EQU X'32'                     Maxmimum ID\n         ORG   SCVACOM\nSCVACOMP DS    0H                      COMP Entry\nSCVACCLN DS    H                       Length\nSCVACCID DS    X                       Id\nSCVACCB  DS    X                       User or System\nSCVACCU  EQU   X'80'                   UserAbendCode\nSCVACCM  DS    CL3                     Mask for significant\nSCVACCD  DS    CL3                     CompletionCode\n         DS    CL2                     Reserved\n         ORG   SCVACOM\nSCVAJOBN DS    0H                      JogName-JSPGM Entry\nSCVAJNLN DS    H                       Length\nSCVAJNID DS    X                       Id\n         DS    CL1                     Reserved\nSCVAJND  DS    CL8                     Jobname/JSPGM\n         ORG   SCVACOM\nSCVADAHD DS    0H                      Data-Entry\nSCVADALN DS    H                       Length\n         ORG   SCVACOM\nSCVASDHD DS    0H                      SDATA-Entry\nSCVASDLN DS    H                       Length\nSCVASDID DS    X                       Id\n         DS    CL1                     Reserved\nSCVASLTB DS    F                       SLTB ptr\n         MEND\n./ ADD NAME=IHASETC\n         MACRO                         Set Connection\n         IHASETC\nSETC     DSECT\nSETCHDR  DS    0CL6    header\nSETCEYEC DS    CL4     id 'SETC'\nSETCLENG DS    H       length of SETC\nSETCFLG1 DS    X       Reserved\nSETCLXUS EQU   X'80'   This ASID has an entry table for LX\nSETCFLG2 DS    X       Reserved\nSETCSTKN DS    D       Stoken\n         DS    2H      ?\nSETCTONO DS    H       Number of \"TO\" entries\nSETCFRNO DS    H       Number of \"FROM\" entries\nSETCALLC DS    H       Number of ALL connections                 RS0800\n         DS    H       ?                                         RS0800\n         DS    1F      ?                                         RS0800\nSETCENTP DS    F       multiple depending on SETCALLC            RS0800\nSETCNOUS EQU   X'01'   Not in use (low order bit)\nSETCTO   EQU   X'80'   It is a To connection (high order bit)\n         MEND\n./ ADD NAME=IHASDDSQ\n         MACRO\n         IHASDDSQ\n*\n*        SDDSQDDS is set to 1 when a dump is written, then reset\n*        to zero by DD CLEAR.  If IEBGENER is used to clear the\n*        dump data set, SDDSQDDS remains ON although the data set\n*        is now empty.  See OZ94510.\n*\nSDDSQ    DSECT                         SDUMP DATA SET QUEUE\nSDDSQID  DS    C'SDDS'\nSDDSQFWD DS    V(SDDSQ)                FORWARD PTR\nSDDSQBWD DS    V(SDDSQ)                BACKWARD PTR\nSDDSQDAN DS    C'00',C' '              SYS1.DUMP SUFFIX (00 THRU 99)\nSDDSQCTL DS    X                   0F  CONTROL BITS\nSDDSQFLG DS    X                   10  FLAGS\nSDDSQDDS EQU   X'80'                   DATA SET IS FULL\nSDDSQDYN EQU   X'40'                   DATA SET DYNAMICALLY ALLOCATED\nSDDSQNIP EQU   X'10'                   DATA SET INITIALIZED BY NIP\n         DS    X\nSDDSQNMB DS    FL1'00'                 DATA SET NUMBER IN BINARY\nSDDSQBKS DS    FL1'01'                 SDUMP BLOCKS ON 1 TRACK\nSDDSQDEB DS    A                       ADDRESS OF THE DEB\nSDDSQDEV DS    XL4                     DEVICE CODE\nSDDSQDDN DS    C'SYS00002'         1C  DDNAME\nSDDSQDOM DS    F                       MESSAGE ID OF DOM OF IEA911E\n         DS    X,X,X               28  reserved                 HBB5520\nSDDSQDSNL DS   FL1                     length of dsname         HBB5520\nSDDSQDSN DS    CL44                2C  dsname                   HBB5520\n         MEND\n./ ADD NAME=IHARTSD\n         MACRO\n         IHARTSD\nRTSD     DSECT                         RTCT SDUMP Extension\n         ORG   RTSD+X'2C'\nRTSDXADR DS    A(SDRTX)\n         MEND\n./ ADD NAME=IHASDRTX\n         MACRO\n         IHASDRTX\nSDRTX    DSECT                         RTCT SDUMP Extension\n         DS    C'SDRTX'\nSDRTXFLAGS DS  X\nSDRTXFDYN  EQU X'80'                   dynamic allocation active\n         ORG   SDRTX+X'20'\nSDRTX_DSNPAT DS CL128                  DSNAME pattern\nSDRTX_DSNPATL DS FL1               A1  length of DSNAME pattern\n              DS X,X\nSDRTX_SDDSQ#  DS FL1               A3  number of automatic SDDSQs\n              DS A,A\nSDRTX_SDDSQ1  DS A(SDDSQ)          AC  First automatic SDDSQ\n              DS F\nSDRTX_LENGTH EQU *-SDRTX\n*SDRTX   EQU   0,3656,C'C'                                        -DEL-\n*SDRTXKEEP EQU SDRTX,224,C'C'                                     -DEL-\n*SDRTXID EQU   SDRTXKEEP,5,C'C'                                   -DEL-\n*SDRTXFLAGS EQU SDRTXKEEP+5,1,C'B'                                -DEL-\n*SDRTXALLOCACTIVE EQU SDRTXFLAGS,,C'B'                            -DEL-\n*SDRTXSIGNALDSPSTOKEN EQU SDRTXKEEP+8,8,C'C'                      -DEL-\n*SDRTXS1TECB EQU SDRTXKEEP+16,4,C'F'                              -DEL-\n*SDRTXWORKAREA@ EQU SDRTXKEEP+20,4,C'A'                           -DEL-\n*SDRTXS1TTIMEOUTECB EQU SDRTXKEEP+24,4,C'F'                       -DEL-\n*SDRTXS1TSEQ# EQU SDRTXKEEP+28,4,C'F'                             -DEL-\n*SDRTXNAMEPATTERN EQU SDRTXKEEP+32,128,C'C'                       -DEL-\n*SDRTXNAMEPATTERNLENGTH EQU SDRTXKEEP+160,1,C'F'                  -DEL-\n*SDRTXSMSSDDSQCOUNT EQU SDRTXKEEP+161,1,C'F'                      -DEL-\n*SDRTXVOLSDDSQCOUNT EQU SDRTXKEEP+162,1,C'F'                      -DEL-\n*SDRTXAUTOSDDSQCOUNT EQU SDRTXKEEP+163,1,C'F'                     -DEL-\n*SDRTXSMSSDDSQ EQU SDRTXKEEP+164,4,C'A'                           -DEL-\n*SDRTXVOLSDDSQ EQU SDRTXKEEP+168,4,C'A'                           -DEL-\n*SDRTXAUTOSDDSQ EQU SDRTXKEEP+172,4,C'A'                          -DEL-\n*SDRTXAUTOSDDSQEND EQU SDRTXKEEP+176,4,C'A'                       -DEL-\n*SDRTXSDATA EQU SDRTX+280,8,C'C'                                  -DEL-\n*SDRTXASIDLST EQU SDRTX+288,32,C'C'                               -DEL-\n*SDRTXASIDLST# EQU SDRTXASIDLST,2,C'H'                            -DEL-\n*SDRTXASIDLSTENTRY EQU SDRTXASIDLST+2,2,C'C'                      -DEL-\n*SDRTXASIDLSTEOL EQU SDRTXASIDLSTENTRY,,C'B'                      -DEL-\n*SDRTXINTOKEN EQU SDRTX+320,32,C'C'                               -DEL-\n*SDRTXLISTDAREA EQU SDRTX+352,484,C'C'                            -DEL-\n*SDRTXLISTDAREALEN EQU SDRTXLISTDAREA,4,C'F'                      -DEL-\n*SDRTXJOBLISTAREA EQU SDRTX+840,256,C'C'                          -DEL-\n*SDRTXDSPLISTAREA EQU SDRTX+1096,512,C'C'                         -DEL-\n*SDRTXREMOTEAREA EQU SDRTX+1608,1024,C'C'                         -DEL-\n*SDRTXPROBDESCAREA EQU SDRTX+2632,1024,C'C'                       -DEL-\n*SDRTXWORKAREA EQU 0,3456,C'C'                                    -DEL-\n*SDRTXWAC256 EQU SDRTXWORKAREA,256,C'C'                           -DEL-\n*SDRTXWAC128 EQU SDRTXWORKAREA+256,128,C'C'                       -DEL-\n*SDRTXWADSPLISTW EQU SDRTXWORKAREA+384,3072,C'C'                  -DEL-\n         MEND\n./ ADD NAME=IHASHDR\n         MACRO\n         IHASHDR\nSHDR     DSECT\nSHDRCBID DS    CL4                 CONTROL BLOCK ID=SHDR\n         ORG   SHDR+180\nSHDRIDQ  DS    A                   QUEUE OF IDS WITH SCES\n         MEND\n./ ADD NAME=IHASLTB\n         MACRO\n         IHASLTB\nSLTB     DSECT\nSLTBHDR  DS    CL4                     Header 'SLTB'\nSLTBLEN  DS    F                       length of Slip-Data\n         DS    2F                      ?\nSLTBCOM  DS    CL50                    Slip Command\n         MEND\n./ ADD NAME=IHASVC                     NOT ALWAYS PRESENT IN XA\n         MACRO\n         IHASVC\nSVCENTRY DSECT\nSVCEP    DS    A                       SVC ENTRY POINT ADDRESS\nSVCATTR1 DS    0H                      ATTRIBUTES\nSVCTP    DS    B                       TYPE FIELD\nSVCTP1   EQU   X'00'                   TYPE 1 SVC\nSVCTP2   EQU   X'80'                   TYPE 2 SVC\nSVCTP34  EQU   X'C0'                   TYPE 3 OR 4 SVC\nSVCTP6   EQU   X'20'                   TYPE 6 SVC\nSVCAPF   EQU   X'08'                   APF AUTHORIZED 1-AUTHORIZED\nSVCESR   EQU   X'04'                   SVC IS A PART OF THE ESR\nSVCNP    EQU   X'02'                   NON-PREEMPTIVE SVC\nSVCASF   EQU   X'01'                   SVC CAN BE ASSISTED\nSVCRESV1 DS    B                       RESERVED BYTE\nSVCLOCKS DS    H                       LOCK ATTRIBUTES\nSVCLL    EQU   X'80'                   LOCAL LOCK NEEDED\nSVCCMS   EQU   X'40'                   CMS LOCK NEEDED\nSVCOPT   EQU   X'20'                   OPT LOCK NEEDED\nSVCALLOC EQU   X'10'                   SALLOC LOCK NEEDED\nSVCDISP  EQU   X'08'                   DISP LOCK NEEDED\nSVCESRAD EQU   SVCEP,4                 ADDRESS OF ESR TABLE IF\nSVCESRMX EQU   SVCATTR1,4              MAXIMUM ESR NUMBER\n         MEND\n./ ADD NAME=IHATQE\n         MACRO\n         IHATQE\nTQE      DSECT                         TIMER QUEUE ELEMENT\nTQETQE   DS    C' TQE'                 TQE IDENTIFICATION\nTQEFLNK  DS    A(TQE)                  ADDRESS OF NEXT TQE\nTQEBLNK  DS    A(TQE)                  ADDRESS OF PREVIOUS TQE\nTQEAID   DS    H                       REQUESTORS ASID\nTQEFLGS  DS    BL1                     TQE FLAG BYTE 1\nTQEOFF   EQU   X'80'                   TQE IS OFF TIMER QUEUE\nTQETOD   EQU   X'40'                   TOD OPTION SPECIFIED\nTQEGMT   EQU   X'20'                   GMT OPTION SPECIFIED\nTQEWLIM  EQU   X'10'                   WAIT LIMIT EXCEEDED\nTQEINCOM EQU   X'08'                   INTERVAL IS COMPLETE\nTQEXITSP EQU   X'04'                   AN EXIT WAS SPECIFIED\nTQETYPE  EQU   X'03'                   TQE TYPE     00=TASK TYPE\nTQEFLGS2 DS    BL1                     TQE FLAG BYTE 2\nTQECOMP  EQU   X'80'                   REAL TQE IS BEING TIMED\nTQEUSER  EQU   X'40'                   NON SYSTEM TQE\nTQEETRSS EQU   X'20'                   ETR SUBSET MONITOR TQE      @L1A\nTQEDUM   EQU   X'10'                   DUMMY SYSTEM TQE\nTQELM    EQU   X'08'                   TIME LIMIT CHECKING SYSTEM TQE\nTQEOPT   EQU   X'04'                   SYSTEM RESOURCES MANAGER TQE\nTQEMF1   EQU   X'02'                   RMF SYSTEM TQE\nTQEMIDN  EQU   X'01'                   MIDNIGHT SYSTEM TQE\nTQEVAL   DS    2F                      EXPIRATION TIME OR TIME LEFT\nTQESADDR DS    A                       ADDRESS OF PP SAVE AREA\nTQEEXIT  DS    A                       ADDRESS OF USER EXIT RTN\nTQEECB   EQU   TQEEXIT                 ECB IF WAIT TYPE TQE\nTQETCB   DS    A(TCB)                  ADDRESS OF USER TCB\nTQEASCB  DS    A(ASCB)                 ADDRESS OF USER ASCB\nTQELHPSW DS    F                       FIRST WORD OF CURRENT PSW\nTQESRB   DS    CL44                    SRB\nTQEFLGS3 DS    BL1                     TQE FLAG BYTE 3\nTQEDIE   EQU   X'80'                   DIE TQE\nTQEAMODE EQU   X'40'                   EXIT AMODE IN TQEXMODE\nTQEPURGE EQU   X'20'                   TQE SHOULD BE PURGED BY IEAVRSAE\n         DS    XL2                     RESERVED\nTQELEVEL DS    B                       TQE LEVEL INDICATOR\nTQEID    DS    F                       STIMERM REQUEST ID\nTQELINK  DS    A(TQE)                  ADDR OF NEXT TQE ON TCBTME QUEUE\nTQEPARAM DS    F                       USER EXIT ROUTINE PARAMETER\n         MEND\n./ ADD NAME=IHAXMD\n         MACRO\n         IHAXMD\nXMD      DSECT                         PC/AUTH\nXMDXMD   DS    CL4'XMD'\nXMDLXAT  DS    A(LXAT) Pointer to Linkage Index Allocation Table\nXMDETIBH DS    0XL8    Header of entry table information block queue\nXMDETIBF DS    A       Pointer to the first ETYIB on queue\nXMDETIBL DS    A       Pointer to last ETIB on queue\nXMDAXAT  DS    A       Address of Authorization Index Allocation Tables\nXMDFLAGS DS    X       Flag byte\nXMDRSV1  EQU   X'80'   reserved flag\nXMDRSV2  EQU   X'40'   reserved flag\nXMDRSV9  DS    XL3     reserved field\nXMDXMSE  DS    A       Address of the queue of XMSE's in PC/AUTH's\n*                      address space\nXMDATLNB DS    XL2     Length of the System Authorization Table\n*                      (in bytes)\nXMDSATLN DS    XL2     Length of the System Authorization Table\n*                      (0030) used to initialize an ASTE\nXMDSATOR DS    A       The real address of the System Authorization\n*                      Table in format to initialize the ASTE\nXMDSATOV DS    A       The virtual address of the System Authorization\n*                      Table\nXMDSLTD  DS    A       Read address and length of the System Linkage\n*                      Table (with the valid bit on) in ASTE format\nXMDSLT   DS    A       Address of the System Linkage Table which\n*                      contains only system wide entries\nXMDXMSEL DS    A       Address of the last XMSE on the queue anchored\n*                      by XMDXMSE\nXMDR034  DS    XL4     reserved\n*\nXMDLNTH  EQU   *-XMD   length of XMD\n         MEND\n./ ADD NAME=IHAXMSE\n         MACRO                         Cross Memory Service\n         IHAXMSE\nXMSE     DSECT\nXMSEEYEC DS    CL4     id 'XMSE'\nXMSESETC DS    F       pointer to SETC\nXMSESTKN DS    D       Stoken\nXMSENXTP DS    F       pointer to next XMSE\nXMSEPRVP DS    F       pointer tp prev XMSE\nXMSESETP DS    F       pointer to SETP\nXMSEJOBN DS    CL8     Jobname\nXMSEASID DS    H       Asid\n         DS    H       ?\nXMSE_LENGTH EQU *-XMSE Length of XMSE\nXMSEFORW DS    F       ? Forward pointer   z/OS R3               RS0902\n         DS    F       ?                                         RS0902\nXMSE_LENGTH_ZOS3 EQU *-XMSE                                      RS0902\n         MEND\n./ ADD NAME=IKJEXTAB\n         MACRO                         TSO EXIT/TABLE VECTOR\n         IKJEXTAB\nEXTAB_VECT     DSECT\nEXTV_HEADER    DS 0CL16                HEADER\nEXTV_ID        DS C'EXTV'\nEXTV_VERS      DS FL1\nEXTV_LEN       DS F\nEXTV_ENTRY#    DS F\nEXTV_ENT       DS 0XL16                ENTRY\nEXTV_ENT_NAME  DS C'IKJEFTAP'\nEXTV_FLAG1     DS X\nEXTV_FLAG1_LPA     EQU X'80'\nEXTV_FLAG1_LNKLST  EQU X'40'\nEXTV_FLAG1_STEPLIB EQU X'20'\nEXTV_LOAD_ADDR DS V(IKJEFTAP)\n         MEND\n./ ADD NAME=IKJTPVT\n         MACRO\n         IKJTPVT\nTPVT     DSECT                         TSO PARAMETERS VECTOR TABLE\nTPVT_ID  DS    C'TPVT'                 BLOCK ID\nTPVT_LEN DS    H'72'                   LENGTH OF TPVT\n****     DS    H'220'                  LENGTH OF TPVT          HTE26E2\nTPVT_VERS DS   FL1'2'                  VERSION\nTPVT_MEM1 DS  0C'IKJTSO00'          07 CURRENT PARMLIB MEMBER  HTE25E2\n         DS    X                                               HTE26E2\nTPVT_MEM DS    C'IKJTSO00'          08 CURRENT PARMLIB MEMBER  HTE26E2\nTPVT_GEN DS    F                       PARMLIB generation count\nTPVTCTLT DS    A(CTLT)                 IKJCTLT\nTPVTCTLT_LEN DS F'60'                  length of CTLT\n         DS    4X\nTPVTSEND DS    V(SCB)               20 IKJEESCB   (SYS1.BRODCAST)\nTPVTALPL DS    V(ALPL)                 ALPL       (ALLOCATE defaults)\nTPVTTEST DS    V(TPT)                  TPT (TEST)\nTPVTXPRMD DS   V(XPRM)                 INMXPARM   (XMIT)\nTPVTCONSOLE DS V(CNPRM)             30 IKJCNPRM   (CONSOLE)\nTPVTFCVEC DS   A,F                     FCVE       (Platform commands)\nTPVTHELP DS    V(HCB)               3C IKJEFHCB   (HELP)\nTPVTPPVEC DS   A,F                     PPVE       (Platform programs)\n           ORG  TPVT+X'4C'\nTPVTLOGON DS   X                    4C IKJTSOxx LOGON KEYWORD\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n* The following bit settings must correspond to the same bit settings *\n* in the TSVTFLG1 field of the TSVT (TSVT + X'5') - lower nibble only *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nTPVTPHRS  EQU  X'08'                Password phrase support active\nTPVTAPPL  EQU  X'04'                LOGON applid verification active\nTPVTLGNH  EQU  X'02'                LOGONHERE support is active\nTPVTLGPC  EQU  X'01'                LOGONPREPROMPT is active\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n           ORG  TPVT+X'50'\nTPVTDSNAM  DS  CL44'SYS1.PARMLIB'   50 dsname                  HTE26E2\nTPVTVOLSER DS  C'SYSCAT'            7C volser                  HTE26E2\n           DS  2X                                              HTE26E2\nTPVTSNAME  DS  CL8'P390'            84 from system             HTE26E2\nTPVTUSERID DS  CL8'IBMUSERM'        8C by userid               HTE26E2\nTPVTHHMMSS DS  CL8'16:59:56'        94 at hh:mm:ss             HTE26E2\nTPVTYYMMDD DS  C'1998-10-29'        9C on yyyy-mm-dd           HTE26E2\n           DS  X'0600,00000001,7490,16595156,19981029'         HTE26E2\n         ORG   TPVT+X'DC'              end of TPVT             HTE26E2\n         MEND\n./ ADD NAME=IKJCTLT\n         MACRO\n         IKJCTLT\nCTLT     DSECT                         TSO/E Control Table\nCTLT_ID  DS    C'CTLT'                 BLOCK ID\nCTLT_LEN DS    H'60'                   LENGTH OF CTLT\nCTLT_VERS DS   FL1'2'                  version number\n         DS    X                       UNUSED\nCTLTTE2  DS    A,F,H,H                 IKJEFTE2  PTR,LEN,#ENT,ENT_LEN\nCTLTTE8  DS    A,F,H,H                 IKJEFTE8  PTR,LEN,#ENT,ENT_LEN\nCTLTTNS  DS    A,F,H,H                 IKJEFTNS  PTR,LEN,#ENT,ENT_LEN\nCTLTTAP  DS    A,F,H,H                 IKJEFTAP  PTR,LEN,#ENT,ENT_LEN\nCTLT_TABLE_BUILT_FLAGS DS X            tables built from IKJTSOxx\nCTLTTE2_BUILT EQU X'80'\nCTLTTE8_BUILT EQU X'40'\nCTLTTNS_BUILT EQU X'20'\nCTLTTAP_BUILT EQU X'10'\n         MEND\n./ ADD NAME=IKJEFCVE\n         MACRO\n         IKJEFCVE\nFCVE     DSECT                         Platform Commands\nFCVE_ID  DS    C'FCVE'                 Block id\nFCVE_VER DS    X'01'                   Version\n         DS    XL3                     ?\nFCVE_LEN DS    F                       Length of table\nFCVE_COUNT DS  F                       Number of entries\nFCVE_ENTRY DS  0CL8                    Start of table\n         MEND\n./ ADD NAME=IKJEPPVE\n         MACRO\n         IKJEPPVE\nPPVE     DSECT                         Platform Programs\nPPVE_ID  DS    C'PPVE'                 Block id\nPPVE_VER DS    X'01'                   Version\n         DS    XL3                     ?\nPPVE_LEN DS    F                       Length of table\nPPVE_COUNT DS  F                       Number of entries\nPPVE_ENTRY DS  0CL8                    Start of table\n         MEND\n./ ADD NAME=IKJXPRM\n         MACRO\n         IKJXPRM\nXPRM     DSECT                         INMXPARM Control Table\nXPRM_ID  DC    C'INMXPARM'             Block id\nXPRM_LEN DS    H                       Length of XPRM\nXPRM_NJE# DS   H                       Count of NJE/SMF id's\nXPRM_NJE_START DS A(XPRM_NODE)         A(start NJE/SMF id's)\nXPRM_VERS  DS  X'02',3X                version number          HTE26D2\nXPRM_WARN1 DS  F                       OUTWARN 1\nXPRM_WARN2 DS  F                       OUTWARN 2\nXPRM_LIM DS    F                       Outlim\n         DS    F,F,H                   ?                         SG0106\nXPRM_VIO_U_SIZE DS H                   Length of VIO unit name   SG0106\nXPRM_VIO_U DS  CL8                     VIO unit name\n         DS    F,F                     ?\nXPRM_SW  DS    X                       Cipher flag\nXPRM_CIPHER_NO EQU X'10'               Cipher - NO\nXPRM_CIPHER_ALWAYS EQU X'20'           Cipher - ALWAYS\nXPRM_CIPHER_YES EQU X'40'              Cipher - YES\nXPRM_USERID EQU X'08'                  Daprefix - userid\n         DS    X                       ?\nXPRM_SOUT DS   C                       SYSOUT class\n         DS    C                       ?                         SG1205\nXPRM_LOGNAME DS CL8                    LOGNAME\n         DS    H                       ?\nXPRM_LOGSEL_1 DS C                     '*'\nXPRM_LOGSEL DS  CL8                    LOGSEL name\nXPRM_LOGSEL_SIZE DS H                  LOGSEL size (halfword)    SG0106\nXPRM_SYSCTL DS CL44                    SYSCTL name\nXPRM_SYSCTL_SIZE DS H                  SYSCTL size (halfword)    SG0106\nXPRM_USRCTL DS CL44                    USRCTL name\nXPRM_USRCTL_SIZE DS H                  USRCTL size (halfword)    SG0106\nXPRM_SPOOLCL DS C                      SPOOL CLASS\n         ORG   XPRM+X'0F0'             filler                  HTE26D2\nXPRM_NODE DS   CL8                     NJE node name\nXPRM_SMF DS    CL4                     SMF ID\n         DS    XL4\nXPRM_NS_L EQU  *-XPRM_NODE             Length of a pair\n         MEND\n./ ADD NAME=IKJCNPRM\n         MACRO\n         IKJCNPRM\nCNPRM    DSECT                         IKJCNPRM Control Table\nCNPRM_ID DC    C'IKJCNPRM'             Block id\n         DS    H                       ?\nCNPRM_LENGTH DS H                      Total length of c.b.\nCNPRM_MAXSNUM DS F\nCNPRM_MAXUNUM DS F\nCNPRM_INITSNUM DS F\nCNPRM_INITUNUM DS F\n         DS    3F\n         MEND\n./ ADD NAME=IKJEFHCB\n         MACRO\n         IKJEFHCB\nHELP     DSECT                         IKJEFHCB Control Table\nHELP_ID  DC    C'IKJEFHCB'             Block id\n         DS    H                       ?\nHELP_LENGTH DS H                       Total length of c.b.\nHELP_LANG_CNT DS F                     Number of languages\nHELP_FIRST_LANG_ENTRY DS A             A(first lang entry)\nHELP_LANG_ENTRY DS 0C                  A lng entry and dsn list\nHELP_NEXT_LANG_ENTRY DS A              Next lang entry or 0\nHELP_LANG_TYPE DS CL3                  Language\nHELP_DSN_COUNT DS X                    dsn count for this\n*                                      language\nHELP_DSN_ENTRY DS 0C                   A dsn entry\nHELP_DSN_LENGTH DS F                   length of a dsn\nHELP_DSN DS    CL44                    a dsn\nHELP_END_ENTRY DS 0C\n         MEND\n./ ADD NAME=IKJTPT\n         MACRO\n         IKJTPT\nTPT      DSECT                         TPT Control block\nTPT_ID   DS    C'TPT '                 Block id\nTPT_LENGTH DS H                        Total length of c.b.\n         DS    H                       ?\n         DS    F                       zeros\nTPT_TCT_ENTRY DS A                     Address of TSOCMD c.b.\nTPT_TCT_LENGTH DS F                    Length of TSOCMD c.b.\n*                                      Length - 4 / 8 = #\nTPT_SCT_ENTRY DS A                     Address of SUBCMD c.b.\nTPT_SCT_LENGTH DS F                    Length of SUBCMD c.b.\n*                                      Length - 4 / 16 = #\n         DS    3F\nTCT_TEST DSECT\nTCT_ID   DS    C'TCT '                 Block id\nTCT_TSOCMD DS  CL8                     A TSOCMD\nTCT_ENTRY_END DS 0C\n*                                      The last entry is x'40'\nSCT_TEST DSECT\nSCT_ID   DS    C'SCT '                 Block id\nSCT_SUBCMD DS  CL8                     A SUBCMD\nSCT_PGM  DS    CL8                     A SUBCMD entry name\n*                                      The last entry is x'40'\nSCT_ENTRY_END DS 0C\n         MEND\n./ ADD NAME=IKJALPL\n         MACRO\n         IKJALPL\nALPL     DSECT                         ALLOC command defaults\nALPL_ID  DS    C'ALPL'                 Block id\nALPL_LENGTH DS H                       length of control block\nALPL_LEVEL  DS H                       level of control block\n         DS    F                       zero\nALPL_FLAG DS   X                       Allocate flag\nALPL_OLD EQU  X'80'                    OLD\nALPL_SHR EQU  X'40'                    SHR\n         DS   4F\n         MEND\n./ ADD NAME=IOSDIOFC\n         MACRO\n         IOSDIOFC\nIOFC     DSECT                         IOS Facilities\nIOFC_VERSION DS  C                     Version number\nIOFC_FLAG1   DS  X                     Flag 1\nIOFC_MIDAW_HW EQU X'80'                The MIDAW facility is\n*                                      supported by the\n*                                      hardware\nIOFC_MIDAW_SW EQU X'40'                The MIDAW facility is\n*                                      supported and enabled\n*                                      by the software. This\n*                                      bit will only be on if\n*                                      IOFC_MIDAW_HW is on\n*                                      and the MIDAW facility\n*                                      has not been disabled\n*                                      via the IECIOSxx\n*                                      parmlib member or the\n*                                      SETIOS command.\nIOFC_FCX_HW   EQU X'20'                The FICON Channel\n*                                      Extensions (FCX)\n*                                      facility (i.e., High\n*                                      Performance FICON) is\n*                                      supported by the\n*                                      hardware\nIOFC_FCX_SW   EQU X'10'                The FICON Channel\n*                                      Extensions (FCX)\n*                                      facility (i.e., High\n*                                      Performance FICON) is\n*                                      supported and enabled\n*                                      by the software.  This\n*                                      bit will only be on if\n*                                      IOFC_FCX_HW is on and\n*                                      the facility has not\n*                                      been disabled via the\n*                                      IECIOSxx parmlib\n*                                      member or the SETIOS\n*                                      command\n         DS    CL254                   Reserved\n         MEND\n./ ADD NAME=IOSDIOVT\n         MACRO\n         IOSDIOVT\nIOVT     DSECT                         IOS Vector Table          ESA41\n         DS    C'IOVT'\n         DS    H'476'                  Length of IOVT            RS1106\n         DS    XL2\nIOVTULUT DS    V(ULUT)                 UCB LOOK-UP TABLE\n         DS    3F\nIOVTCDA  DS    V(CDA)                  Config Data Area\n         DS    1F                      ???\n         DS    A                       IASC ??\n         DS    A                       IOS PIN QUEUE HEADERS\n         DS    A                       IOS PIN QUEUE ELEMENTS\n         DS    1F                      ???\n         DS    A                       TQE\n         DS    6F                      ???\n         DS    A                       CSC\n         DS    1F                      ???\n         DS    A                       IOS 31 BIT DST ENTRIES\n         DS    A                       IOS 24 BIT DST ENTRIES\n         DS    1F                      ???\n         DS    A                       IOS UCB SERVICES PC RTN\n         DS    A                       IODE\n         DS    3F                      ???\n         DS    A                       IOS HASH\n         DS    A                       IOS UCB HASH COLISIONS\n         DS    1F                      ???\n         DS    A                       DDT\n         DS    A                       DDT\n         DS    A                       DDT\n         DS    4F                      ???\n         DS    A                       CAPT\n         DS    2F                      ???\n         DS    A                       DDT\n         DS    A                       DDT\n         DS    1F                      ???\n         DS    A                       DDT\n         DS    A                       IOS CAPTURE UCB SERVICE\n         DS    A                       TRCB\n         DS    2F                      ???\n         DS    1F                      ???\n         DS    A                       MGFQ\n         DS    A                       CMVT\n         DS    A                       CPCT\n         DS    1F                      ???\n         DS    1F                      ???\n         DS    A                       IXSD\n         DS    CL8'SYSIOS01'\n         DS    6F                      ???\n         DS    A                       QDIO\n         DS    1F                      ???\n         DS    A                       SAUT\n         DS    4F                      ???\n         DS    A                       IOS PURGE WORK AREAS\nIOVTFLG1 DS    X                       IOVT-Flag\nIOVTMIDAW EQU   X'08'                  MIDAW ON?\n         DS    XL3                     ???\n         DS    A                       CCAP\n         ORG   IOVT+440                0x1B8                     JH1214\nIOVT3LUT DS    D                       UCB V3 look-up table      JH1214\n         ORG   ,                                                 JH1214\n         MEND\n./ ADD NAME=IOSDCDA\n         MACRO\n         IOSDCDA\nCDA      DSECT                         Configuration Data Area\nCDACDA   DS    C'CDA ' 0\nCDAVERN  DS    X'01',X,CL2           4 Level of this control block\nCDAFLAGS DS    XL4,4F                8 Flags\nCDAINACT EQU   X'80'                   HCD is not used ????\nCDAIIT   DS    V(IIT)               28 IIT\nCDAIODF  DS    CL44'SYS1.IODF00'    32 IODF data set name\nCDACPUID DS    X'00000123,00339121' 76 CPU ID\nCDALTIME DS    X'05334455'          84 Config time (HHMMSSHH)\nCDALDATE DS    X'0092135F'          88 Config julian date\nCDACONID DS    C'IPO100  '          92 Configuration Id\nCDAUPDCT DS    H'0'                100 Configuration Update Count\n         DS    H'0'                102 ?\nCDAEDTID DS    C'00'               104 EDT SUFFIX\n         DS    XL2,4F              106 ?\nCDAPROCE DS    C'AL9121  '         124 Processor - D IOS,CONFIG\nCDACPUI2 DS    X'00000113,07489121' 132CPUID\nCDATIM2  DS    X'14471300'         140 Config time (HHMMSSHH)\nCDALDAT2 DS    X'0095270F'         144 Config julian date\n         DS    XL4,XL4             148\nCDASDAT  DS    C'95-09-27'         156 Config date - D IOS,CONFIG\nCDASTIM  DS    C'14:27:13'         164 Config time - D IOS,CONFIG\nCDASDESC DS    CL16'SYS2    IODF03' 172 Description - D IOS,CONFIG\n         DS    CL8'       '        188 Description - D IOS,CONFIG\n         DS    6F                  196 ???\n         DS    C'95-09-27'         220 ???\n         DS    C'14:27:13'         228 ???\n         DS    CL16'SYS2    IODF03' 236 Description - D IOS,CONFIG\nCDAMIFID DS    X'00'               252 MIF ID\n         MEND\n./ ADD NAME=IOSDICI\n         MACRO\n         IOSDICI\nIOSDICI      DSECT\nDICIEYEC     DS  CL4                   eyecatcher 'ICI '\nDICI_VERSION DS  X                     version ??\n             DS  XL3                   ?\n             DS  XL4                   ?\nDICI_IODF    DS  CL44                  IODF DSN\nDICI_IOC     DS  0CL32\n             DS  CL8\nDICI_LDATE   DS  CL4                   IODF Token Date 0104222\nDICI_LTIME   DS  CL4                   IODF Token Time HHMMSSHH\nDICI_IOCID   DS  CL8                   IODF Config ID\nDICI_EDT     DS  CL2                   IODF EDT\nDICI_FLAGS   DS  CL2                   IODF FLAGS\nDICI_PROCE   DS  CL8                   IODF Token Processor\n             DS  CL16\n             DS  CL8\nDICI_SDATE   DS  CL8                   IODF Date YY-MM-DD\nDICI_STIME   DS  CL8                   IODF Time HH:MM:SS\nDICI_DESC    DS  CL16                  IODF Description\n         MEND\n./ ADD NAME=IOSDSHID                   OW13347\n         MACRO\n         IOSDSHID\nSHID     DSECT                         System Host ID\nSHID_SHID   DS   0CL11                   System Host Identifier\nSHID_CPUAD  DS    CL2                    CPU address\nSHID_INFO   DS   0CL5                    CPU serial/model numbers\nSHID_CPUID  DS    CL3                    CPU serial number\nSHID_MODNO  DS    CL2                    CPU model number\nSHID_TODCL  DS    CL4                    Time of day clock (left half)\nSHID_AHID   DS   0CL11                   Alternate System Host ID\nAHID_CPUAD  DS    CL2                    CPU address\nAHID_INFO   DS   0CL5                    CPU serial/model numbers\nAHID_CPUID  DS    CL3                    CPU serial number\nAHID_MODNO  DS    CL2                    CPU model number\nAHID_TODCL  DS    CL4                    Time of day clock (left half)\nSHID_CPCND  DS   0CL32                   CPC Node Descriptor\nCPCND_FLAGS DS    BL1                    Flags\nCPCND_VALID EQU  X'E0'                   Node descriptor validity\nCPCND_INVAL EQU  X'40'                   Node descriptor invalid\nCPCND_NTYPE EQU  X'10'                   Node type\nCPCND_PARMS DS    CL3                    Node parameters\nCPCND_SDC   DS   0CL28                   Self-describing component\nCPCND_TYPE  DS    CL6                    Type number\nCPCND_MODEL DS    CL3                    Model number\nCPCND_MAN   DS    CL3                    Manufacturer\nCPCND_PLANT DS    CL2                    Plant of manufacture\nCPCND_SEQNO DS    CL12                   Sequence number\nCPCND_TAG   DS    CL2                    Tag\nSHID_RSVD   DS    CL2                    Reserved\n         MEND\n./ ADD NAME=IOSDULUT                   Version1                  RS0405\n         MACRO\n         IOSDULUT\nULUT     DSECT                         UCB Look-up Table         ESA41\n         DS    C'ULUT'\nULUTVERS DS    X                       version 1 or 2            RS0405\n         DS    AL1(245)                Subpool\n         DS    XL2,F                   UNUSED,DASB\nULUT1ST  DS    A(ULUENTRY)             FIRST LOOK-UP ENTRY\nULUTUCBC DS    F'561'                  Total number of LOOK-UP Entries\nULUTTAPE DS    F'064'                  number of TAPE LOOK-UP Entries\nULUTCOMM DS    F'032'                  number of COMM LOOK-UP Entries\nULUTDASD DS    F'256'                  number of DASD LOOK-UP Entries\nULUTDISP DS    F'128'                  number of DISP LOOK-UP Entries\nULUTUREC DS    F'032'                  number of UREC LOOK-UP Entries\nULUTCHAR DS    F'008'                  number of CHAR LOOK-UP Entries\nULUTCTCA DS    F'016'                  number of CTCA LOOK-UP Entries\n         ORG   ULUT+132\nULUENTRY DSECT                         UCB LOOK-UP ENTRY\nULUEDEVN DS    X'000D'                 DEVICE NUMBER\nULUEFLGS DS    X'4000'                 Flags\nULUEDYN   EQU  X'40'                   Dynamic UCB\nULUESEQN DS    XL2                     ?\n         DS    XL2                     ?\nULUEUCBP DS    V(UCBOB)                UCB ADDRESS\nULUELEN  EQU   *-ULUENTRY\n         MEND\n./ ADD NAME=IOSDULU2                   Version2 for z/OS R7      RS0405\n         MACRO\n         IOSDULU2\nULU2     DSECT                         UCB Look-up Table\n         DS    C'ULUT'\nULU2VERS DS    X                       version 1 or 2\n         DS    AL1(245)                Subpool\n         DS    XL2,F                   UNUSED,DASB\n         DS    F,F\nULU21ST  DS    A(UL2ENTRY)             FIRST LOOK-UP ENTRY\nULU2UCBC DS    F'561'                  Total number of LOOK-UP Entries\nULU2TAPE DS    F'064'                  number of TAPE LOOK-UP Entries\nULU2COMM DS    F'032'                  number of COMM LOOK-UP Entries\nULU2DASD DS    F'256'                  number of DASD LOOK-UP Entries\nULU2DISP DS    F'128'                  number of DISP LOOK-UP Entries\nULU2UREC DS    F'032'                  number of UREC LOOK-UP Entries\nULU2CHAR DS    F'008'                  number of CHAR LOOK-UP Entries\nULU2CTCA DS    F'016'                  number of CTCA LOOK-UP Entries\n         ORG   ULU2+264\nUL2ENTRY DSECT                         UCB LOOK-UP ENTRY\nUL2EDEVN DS    X'000D'                 DEVICE NUMBER\nUL2EFLGS DS    X'4000'                 Flags\nUL2EDYN   EQU  X'40'                   Dynamic UCB\nUL2ESEQN DS    XL2                     ?\n         DS    XL2                     ?\nUL2EUCBP DS    V(UCBOB)                UCB ADDRESS\nUL2ELEN  EQU   *-UL2ENTRY\n         MEND\n./ ADD NAME=IOSDULU3\n         MACRO\n         IOSDULU3\nULU3     DSECT                         UCB Look-up Table\n         DS    C'ULUT'\nULU3VERS DS    X                       version 3                 JH1214\n         DS    AL1                     Subpool\n         DS    XL2                     <filler>\n         DS    F                       <filler>\n         DS    F                       <filler>\nULU31ST  DS    D                       FIRST LOOK-UP ENTRY (V3)\n         DS    XL2                     <filler>\n         DS    XL2                     <filler>\nULU3UCBC DS    F                       Total number of LOOK-UP Entries\nULU3TAPE DS    F'064'                  number of TAPE LOOK-UP Entries\nULU3COMM DS    F'032'                  number of COMM LOOK-UP Entries\nULU3DASD DS    F'256'                  number of DASD LOOK-UP Entries\nULU3DISP DS    F'128'                  number of DISP LOOK-UP Entries\nULU3UREC DS    F'032'                  number of UREC LOOK-UP Entries\nULU3CHAR DS    F'008'                  number of CHAR LOOK-UP Entries\nULU3CTCA DS    F'016'                  number of CTCA LOOK-UP Entries\n         ORG   ULU3+264\nUL3ENTRY DSECT                         UCB LOOK-UP ENTRY\nUL3EDEVN DS    X'000D'                 DEVICE NUMBER\nUL3EFLGS DS    X'4000'                 Flags\nUL3EDYN   EQU  X'40'                   Dynamic UCB\nUL3ESEQN DS    XL2                     ?\n         DS    XL2                     ?\nUL3EUCBP DS    V(UCBOB)                UCB ADDRESS\nUL3ELEN  EQU   *-UL3ENTRY\n         MEND\n./ ADD NAME=ILRASMVT\n         MACRO\n         ILRASMVT &DSECT=YES           AUXILIARY STRGE MGR VECTOR TABLE\nASMVT    DSECT                         ILRASMVT\nASMFLAG1 DS    X                       FLAGS 1\nASMFLAG2 DS    X,2X                    FLAGS 2\nASMQUICK EQU   X'08'                   QUICK START (ON means noCLPA)\nASMWARM  EQU   X'04'                   WARM START  (ON means noCVIO)\nASMSART  DS    V(SART)                 SWAP ACTIVITY REFERENCE TABLE\nASMPART  DS    V(PART)                 PAGE ACTIVITY REFERENCE TABLE\n         MEND\n./ ADD NAME=ILRPART\n         MACRO\n         ILRPART\nPART     DSECT                         PAGING ACTIVITY REFERENCE TABLE\nPARTIDEN DS    C'PART'                 EYE CATCHER\nPARTSIZE DS    F             +4        NUMBER OF ENTRIES IN THE PART\nPARTEUSE DS    F             +8\nPARTCIR0 DS    A             +C\nPARTCIR1 DS    A             +10\nPARTCIR2 DS    A             +14\nPARTTPAR DS    0A            +18\nPARTDSNL DS    A             +18       ADDR OF DSN LIST\nPARTPCTQ DS    A             +1C\nPARTLCNT DS    H             +20\nPARTFLG1 DS    B             +22\n         DS    X             +23\nPARTNPCF DS    A             +24\nPARTNPCL DS    A             +28\nPARTTIME DS    F             +2C\n         DS    CL32          +30\nPARTENTS EQU   *\n*\nPARTENT  DSECT                         PAGE DATA SET TABLE ENTRY\nPAREPARE DS    A             +0\nPAREBRST DS    AL1           +4\nPAREIORN DS    AL1           +5\n         DS    XL2           +6\nPARETYPE DS    B             +8\nPAREPLPA EQU   X'80'                   PLPA\nPARECOMM EQU   X'40'                   COMMON\nPAREDPLX EQU   X'20'                   DUPLEX\nPARELOCL EQU   X'10'                   LOCAL\nPAREBPF  EQU   X'08'                   CACHED DEVICE\nPARESPP  EQU   X'04'                   SET PAGING PARAMETERS OK\nPAREPD   EQU   X'02'                   PAGEDEL IN PROCESS\nPAREDRN  EQU   X'01'                   DRAINING\nPAREFLG1 DS    B             +9\nPARENUSE EQU   X'80'                   NOT IN USE\nPARENVIO EQU   X'10'                   VIO=NO\nPARENN   DS    H             +A\nPAREDEIB DS    A             +C        POINTER TO DEIB\nPARESZSL DS    F             +10       SIZE OF DATA SET (IN SLOTS)\nPARESLTA DS    F             +14       NUMBER OF AVAILABLE SLOTS\nPARERRCT DS    F             +18       NUMBER OF PERMANENT I/O ERRORS\nPAREIORB DS    A             +1C       ADDR OF 1ST IORB\nPAREPATP DS    A(PAT)        +20       POINTER TO PAT\nPAREPCTP DS    A             +24       POINTER TO PCT\nPAREEDBP DS    A             +28       POINTER TO EDB\nPAREUCBP DS    A(UCBOB)      +2C       POINTER TO UCB\nPARETIOR DS    A             +30\nPARETIME DS    F             +34\nPARERQTM DS    F             +38       LATEST REQUEST SERVICE TIME\n         DS    H             +3C       RESERVED\nPAREREQS DS    H             +3E       OUTSTANDING I/O REQUESTS\nPAREFLG2 DS    B             +40       FLAGS\nPARELSLT DS    XL3           +41       WRITE CURSOR\nPAREOCTB DS    A             +44       OLD CTB ADDR\nPAREMIGA DS    A             +48       MIGRATED SLOT COUNT\nPARECADR DS    FL1           +4C       INDEX NUMBER FOR CACHE ENTRY\n         DS    XL19          +4D       RESERVED\nPARTELEN EQU   *-PARTENT               96 BYTES\n         MEND\n./ ADD NAME=ILRPAT\n         MACRO\n         ILRPAT\nPAT      DSECT                         Page Allocation Table\nPATIDENT DS    C'PAT '\nPATPART  DS    A(PARTENT)              POINTER TO PART ENTRY\nPATCYLNO DS    H                       NUMBER OF CYLINDER MAPS\nPATCYLSZ DS    H                       NUMBER OF SLOTS PER CYLINDER\nPATCYLMW DS    H,2X                    NO OF WORDS REQ TO MAP 1 CYL\nPATCCHHB DS    X'0001,0000'            BEGIN CCHH\nPATCCHHE DS    X'0001,000E'            END CCHH\nPATMAP   EQU   *\nPATCYL   DS    XL4                     CYLINDER MAP WORDS\n         MEND\n./ ADD NAME=IRARMCT\n         MACRO\n         IRARMCT &DSECT=YES\nRMCT     DSECT                     RESOURCE MANAGER CONTROL TABLE\nRMCTNAME DS    C'RMCT' -           BLOCK IDENTIFICATION\nRMCTCCT  DS    V(CCT) -            CPU MANAGEMENT CONTROL TABLE\nRMCTICT  DS    V(ICT) -            I/O MANAGEMENT CONTROL TABLE\nRMCTMCT  DS    V(MCT) -            STORAGE MANAGEMENT CONTROL TABLE\nRMCTRMPT DS    V(RMPT) -           CTL ALGORITHM PARAMETER TABLE\nRMCTRMCA DS    V(RMCA) -           CTL ALGORITHM CONTROL AREA\nRMCTWMST DS    A(0) -              ADDR OF WLM SPECIFICATION TABLE\nRMCTRLCT DS    A(0) -              ADDR OF LOGICAL CHANNEL MGMT TABLE\nRMCTRMSA DS    A(0) -              ADDR OF RESOURCES MANAGER SAVE AREA\nRMCTRMPD DS    A(0) -              ADDR OF RESOURCES MANAGER PERF DATA\nRMCTRMEX DS    V(RMEX) -           ROUTINE EXITING VECTOR TABLE\nRMCTRMSB DS    V(RMSB) -           SUBROUTINE CALLING VECTOR TABLE\nRMCTEPPA DS    V(IRAEPPA) -        PRTL ANALYSIS ENTRY TABLE\nRMCTEPDT DS    V(EPDTSCN) -        USER ACTION ENTRY TABLE\nRMCTEPAT DS    V(EPATSCN) -        ALGORITHM ENTRY TABLE\nRMCTEPBG DS    V(EPAT) -           ADDR OF ALG ENTRY PT TABLE\nRMCTADJC DS    F'0' -              ADJUSTMENT FACTOR FOR CPU RATE\nRMCTITT  DS    V(IRASECHT) -       INTFC EVENT CHARACTERISTICS TABLE\nRMCTEPET DS    V(IRAPRCSR) -       EVENT ROUTING VECTOR TABLE\nRMCTFLTM DS    V(IRAFLTM) -        TIME OF DAY ADJUST VECTOR TABLE\nRMCTEPPR DS    V(IRAEPPR) -        PROCESS RATE DEPENDENT ENTRY TABLE\nRMCTWAST DS    A(0) -              ADDR OF WAR SPECIFICATION TABLE\nRMCTWAMT DS    A(0) -              ADDR OF WAR MEASUREMENT TABLE\nRMCTTMQE DS    V(IRACTMQE) -       SCHEDULED RTNE QUEUE HEADER ADDR\nRMCTAQCT DS    F'0' -              ACTION QUEUE MEMBER COUNT\nRMCTAQHD DS    V(IRAOUCB) -        ACTION QUEUE FORWARD POINTER\nRMCTWTQE DS    V(IRAWTQE) -        WAIT - QUEUE HEADER BLOCK ADDRESS\nRMCTOTQE DS    V(IRAOTQE) -        OUT - QUEUE HEADER BLOCK ADDRESS\nRMCTINQE DS    V(IRAINQE) -        IN - QUEUE HEADER BLOCK ADDRESS\nRMCTR10  DS    F'0' -              RESERVED\nRMCTTBS  DS    F'0' -              STARTING TIME BASE FOR TIME OF DAY\nRMCTTOD  DS    F'0' -              TIME OF DAY - SYST RSRC MGR INVOKE\nRMCTTOC  DS    D'0' -              TIME OF CENTURY - 64BIT BINARY NMB\nRMCTALA  DS    4B'00000000' -      ALGORITHM REQUEST ACCUMULATOR FIELD\nRMCTALR  DS    4B'00000000' -      IMMEDIATE ALGORITHM REQUEST FIELD\nRMCTRQSV DS    V(RQSV) -           ADDR OF REQ SRV DATA AREA\nRMCTFLGS DS    1B'00000000' -      PROCESSING CONTROL FLAGS\nRMCTMFA  EQU   BIT0 -              MEASUREMENT FACILITY ACTIVE\nRMCTCPS1 EQU   BIT1                CAP SWITCH\nRMCTINIT EQU   BIT3 -              SRM INITIALIZATION WAS PERFORMED\nRMCTSTW  EQU   BIT5 -              SET HAS STOPPED WAR COLLECTION\nRMCTWLM  EQU   BIT7 -              WLM mode active              HBB5510\n         DS    1B'00000000' -      OVERRIDE CONDITION FLAGS\nRMCTMFS  EQU   BIT1 -              MF1 ACTIVE,SET IPS RCVD\nRMCTTAPE DS    X,X                     SELTAPE\nRMCTSLTN EQU   X'80'                     NEXT\nRMCTSLTR EQU   X'40'                     RANDOM\nRMCTSLTL EQU   X'20'                     LAST\nRMCTSLTF EQU   X'10'                     FIRST\nRMCTTELM DS    V(IEATSELM) -       RESOURCES MANAGER TIMING ELEMENT\nRMCTCPID DS    C'RM1',X'03' -      RESOURCES MANAGER CELL POOL ID\nRMCTTOCI DS    D'0' -              CLOCK READ AREA - 64BIT BINARY NMB\nRMCTOUCB DS    V(IRAOUCB) -        PREASSEMBLED MODEL OUCB\nRMCTOUXB DS    V(IRAOUXB) -        INTERPOSED DUMMY OUXB\nRMCTSRBT DS    V(IRASRBT) -        RESOURCES MANAGER SRB TABLE\nRMCTDMDT DS    A(DMDT)             ADDR OF DOMAIN TABLE\nRMCTDMDE DS    A(DMDT)             ADDR OF LAST DMN TAB ENTRY\nRMCTDMNC DS    H'0' -              NUMBER OF DOMAINS\n         DS    H,7F\nRMCTICST DS    V(ICST)             ICS TABLE\n         MEND\n./ ADD NAME=IRARMPT\n         MACRO\n         IRARMPT &DSECT=YES\nRMPT     DSECT                         SRM PARAM TABLE (IRARMPT)\n         DC    C'RMPT'\n         ORG   RMPT+X'53'\nRMPTOPTN DC    C'00'                   SYS1.PARMLIB(IEAIPSXX)\n         MEND\n./ ADD NAME=IRAWMST\n         MACRO\n         IRAWMST &DSECT=YES\nWMST     DSECT                         WORKLOAD MGR SPECIFICATIONS TBLE\n         DC    C'WMST'\nWMSTID   DC    C'00'                   SYS1.PARMLIB(IEAIPSXX)\nWMSTIPM  EQU   WMST+X'54',8            MSO SERVICE COEFFICIENT (ESA V5)\nWMSTIPC  EQU   WMST+X'9C',4            CPU SERVICE COEFFICIENT (ESA V5)\nWMSTIPI  EQU   WMST+X'A0',4            I/O SERVICE COEFFICIENT (ESA V5)\nWMSTIPB  EQU   WMST+X'A8',4            SRB SERVICE COEFFICIENT (ESA V5)\n         MEND\n./ ADD NAME=IRAICST\n         MACRO\n         IRAICST &DSECT=YES\nICST     DSECT                         SRM ICS TABLE\nICSTID   DC    C'00'                   SYS1.PARMLIB(IEAICSXX)\n         MEND\n./ ADD NAME=IPST\n         MACRO\n         IPST\nIPST     DSECT\nIPSTEYEC DS    CL4       eyecatcher 'IPST'\nIPSTENDP DS    F         end of IPST area'\nIPSTNXTP DS    F         next free entry\nIPST_ENTRY  DS  0H\nIPST_TYPE   DS  CL1       Type of entry\nIPST_IPL    EQU X'01'     type IPL\nIPST_NIP    EQU X'02'     type NIP\nIPST_MSI    EQU X'03'     type MSI\nIPST_DATA_LENGTH DS FL1   length of data\nIPST_DATA1        DS 0CL6  Data field in case of IPL/NIP\nIPST_DATA1_MODID  DS CL2   MODID\nIPST_DATA1_TIMEU  DS FL4   Time Units\n            ORG IPST_DATA1\nIPST_ENTRY_DATA2  DS 0CL12 Data field in case of MSI\nIPST_DATA2_MODID  DS CL8   MOD-NAME\nIPST_DATA2_TIMEU  DS FL4   Time Units\n         MEND\n./ ADD NAME=IRADMDT\n         MACRO\n*\n*        SRM DOMAIN TABLE (IRADMDT)\n*\n*        THIS MAPPING IS VALID FOR MVS/XA THROUGH MVS/ESA 4.1.\n*        STARTING WITH MVS/ESA 4.2, THE DOMAIN TABLE ENTRIES ARE\n*        X'B4' BYTES LONG.\n*\n         IRADMDT &DSECT=YES\nDMDT     DSECT\nDMDTNO   DS    FL1,X,X                 DOMAIN NUMBER\nDMDTWT   DS    FL1                     WEIGHTING FACTOR\nDMDTMPLT DS    H                       CURRENT MPL TARGET\nDMDTRUA  DS    H,2X                    AVG # OF READY USERS * 16\nDMDTCMPL DS    H                       CURRENT MPL\nDMDTOUTU DS    H                       USERS SWAPPED OUT\nDMDTINCU DS    H                       INCORE USERS\nDMDTRUC  DS    F,F                     ACCUM FOR READY USER AVG\nDMDTTWSR DS    F                       WEIGHTED INTVL DMN SVCE\nDMDTAOBJ DS    FL1                     USER PERF OBJ NUMBER\nDMDTDOBJ DS    FL1                     USER PERF OBJ NUMBER\nDMDTFWKL DS    FL2                     DOMAIN FIXED WKLD * 256\nDMDTCIDX DS    FL2                     CONTENTION INDEX\nDMDTNSW  DS    H                       NON-SWAPPABLE USERS\nDMDTRUMX DS    H                       MAX # READY USERS IN INTVL\nDMDTFLGS DS    X,X                     FLAGS\nDMDTTRNC DS    F                       XACTN COUNT FOR RTO\nDMDTTRNT DS    F                       ELAPSED TIME ACCUM FOR RTO\nDMDTTWET DS    F                       ELAPSED TIME AVG FOR RTO\nDMDTLO   DS    H                       MIN MPL\nDMDTHI   DS    H                       MAX MPL\nDMDTHIRV DS    V(ASCB),4X              USER WITH MAX RECOMMENDATION VAL\nDMDTEND  EQU   *                X'40'\n         MEND\n./ ADD NAME=ISGGCC\n         MACRO\n         ISGGCC\nGCC      DSECT\nGCCID    DS    C'GCC '\n         DS    F\nGCCMBRNM DS    C'GRSCNF00'             member name\n         DS    F,F\nGCCFLAGS DS    XL4                     flags ?\nGCCRESMIL DS   F                       RESMIL\n         MEND\n./ ADD NAME=ISGRPT\n         MACRO\n         ISGRPT\nRPT   DSECT\nRPT_ID   DS   CL4                      Control Block Acronym RPT\n              DS XL1                   Reserved\nRPT_#ENTRIES  DS XL1                   Number of entries\n              DS XL2                   Reserved\nRPT_INACTIVEQHDR DS 0F                 Inactive PEXB Queue Header\nRPT_INACTIVEQ    DS F                  Inactive PEXB Queue\nRPT_INACTIVEQSWAPCNT DS XL4            Inactive PEXB Queue Swap Count\nRPT_PAGERLSECTRLAREA DS 0F             Inactive PEXB on RPT\nRPT_INACTIVEPEXBCNT  DS XL4            Count of inactive PEXB on RPT\nRPT_SRBSYNCWORD      DS XL4            Control SRB Schedule\nRPT_QCB#INDEXPTR     DS F              Pointer to QCB array\nRPT_TOTAL#EXTENTS    DS XL4            Total # of extents\nRPT_#EXTENTS         DS XL4            # of extents\nRPT_PERCENT#EXTENTSUSED DS XL4         % of active PEXB on the RPT\nRPT_MESSAGECONTROL   DS CL8\nRPT_SMCURMESSAGEID   DS XL4            Current MSG\nRPT_SMINDEXLEVEL     DS XL1            Threshold data array index\n                     DS CL107          ???\nRPTE                 DSECT\nRPTE_ID              DS CL4            SIZE or CELLID\nRPTE_CELLSIZE        DS H              Size of cell\nRPTE_RPTE#           DS XL1            Number of RPT\nRPTE_FLAGS1          DS XL1            Flags\nRPTE_INACTIVEPEXBSQUEUED EQU X'80'\nRPTE_EXTENTQHDR      DS 0F\nRPTE_EXTENT          DS F              Chain of in-use PEXB\nRPTE_EXTENTQSWAPCNT  DS F              Control Count\nRPTE_#EXTENTS        DS F              Total number of PEXB\n                     DS CL4            For further use z/OS R6\nRPTE_BITMAPMODEL     DS CL16           PEXB Bitmap\nRPTE_FLAGS2          DS XL1            Flags2 z/OS R6\nRPTE_SHADOWSUPPORT   EQU X'80'\nRPTE_SECONDSHADOWSUPPORT EQU X'40'\nRPTE_HOTQUEUESUPPORT     EQU X'20'\n                     DS CL11\nRPT8                 DSECT             for z/OS R8\nRPT8_ID              DS CL4            SIZE or CELLID\nRPT8_CELLSIZE        DS H              Size of cell\nRPT8_RPTE#           DS XL1            Number of RPT\nRPT8_FLAGS1          DS XL1            Flags\nRPT8_INACTIVEPEXBSQUEUED EQU X'80'\n                     DS CL8            Filler\nRPT8_EXTENTQHDR      DS 0F\n                     DS CL4            Perhaps use later\nRPT8_RPTQUEUE31      DS F              Chain of in-use PEXB\nRPT8_SEQ#            DS D              Sequence number\nRPT8_#EXTENTS        DS F              Total number of PEXB\n                     DS CL4            For further use\nRPT8_BITMAPMODEL     DS CL16           PEXB Bitmap\n                     DS CL8            For further use z/OS R8\nRPT8_FLAGS2          DS XL1            Flags2 z/OS R8\nRPT8_SHADOWSUPPORT   EQU X'80'\nRPT8_SECONDSHADOWSUPPORT EQU X'40'\nRPT8_HOTQUEUESUPPORT     EQU X'20'\n         MEND\n./ ADD NAME=ISTATCVT\n         MACRO                         VTAM CVT\n         ISTATCVT\nATCVT    DSECT\nATCVTLVL DS    CL8                     VTAM Release Level\n         MEND\n./ ADD NAME=ISPCFG\n         MACRO                         ISPF\n         ISPCFG\nISPCFG_D DSECT\nCFG_TABLEID      DS  CL8                      TABLEID\nCFG_LEVEL        DS  CL8                      LEVEL\nCFG_DAT          DS  CL8\n*\n* PDF Installation Exits\n*\nCFG_ALLOCPGM     DS   CL8' '\nCFG_PRTPGM       DS   CL8' '\nCFG_PRTCLIST     DS   CL8' '\nCFG_CMPPGM       DS   CL8' '\nCFG_CMPCLIST     DS   CL8' '\nCFG_DSLSTPGM     DS   CL8' '\nCFG_MLFPGM       DS   CL8' '\nCFG_NMCHGPGM     DS   CL8' '\nCFG_DSLLCPGM     DS   CL8' '\nCFG_INSTACCT     DS   CL8' '\nCFG_MEMCPEXT     DS   CL8' '\nCFG_MEMCCEXT     DS   CL8' '\n*\n* THE FOLLOWING FIELDS ARE FOR PDF DEFAULTS\n*\nCFG_PDFUNIT      DS   CL8'SYSALLDA'\nCFG_UNITAUTH     DS   CL8'A'\nCFG_ICFPRT       DS   CL3'NO'\nCFG_PCFALLOC     DS   CL3'NO'\nCFG_CHECKEXP     DS   CL3'YES'\nCFG_ECRALLOC     DS   CL3'YES'\n* THE FOLLOWING FIELDS ARE FOR THE OUTLIST UTILITY TEMPORARY DATA S\nCFG_OLRECL       DS   F'133'\nCFG_OBLKSIZE     DS   F'13566'\nCFG_OPRIMQTY     DS   F'200'\nCFG_OSECQTY      DS   F'100'\n*\nCFG_TSOPANEL     DS   CL3'NO'\nCFG_SCLMCHK      DS   CL5'WARN'\nCFG_DELVOL       DS   CL6'MIGRAT'\nCFG_DELCMD       DS   CL8'HDELETE'\n* THE FOLLOWING FIELDS ARE FOR SUPERC\nCFG_SUPCLBLK     DS   CL5'0'\nCFG_SUPCUBLK     DS   CL5'0'\nCFG_SUPCPBLK     DS   CL5'0'\nCFG_SUPCSBLK     DS   CL5'0'\nCFG_SUPCPGM      DS   CL3'YES'\n*\nCFG_BRSUBMIT     DS   CL3'YES'\nCFG_VWSUBMIT     DS   CL3'YES'\nCFG_RENAMGDG     DS   CL3'YES'\nCFG_DSLMEML      DS   CL3'YES'\nCFG_SUPPVIEW     DS   CL3'YES'\n* MOVE/COPY\nCFG_UMCALLOC     DS   CL3'YES'\nCFG_RESERVE1     DS   CL1' '\nCFG_COPYRC       DS   F'0'\nCFG_COPYOPT      DS   F'2'\nCFG_IEBCOPT      DS   F'0'\n* LMF\nCFG_LMFSVCNO     DS   AL1(0)\nCFG_RESERVE2     DS   CL3'   '\nCFG_CBLKSIZE     DS   F'0'\nCFG_CLRECL       DS   F'0'\nCFG_CSIZE        DS   F'0'\nCFG_CPRIMQTY     DS   F'0'\nCFG_CSECQTY      DS   F'0'\nCFG_CDBLKS       DS   F'0'\nCFG_MBLKSIZE     DS   F'0'\nCFG_MLRECL       DS   F'0'\nCFG_MSIZE        DS   F'0'\nCFG_MPRIMQTY     DS   F'0'\nCFG_MSECQTY      DS   F'0'\nCFG_MDBLKS       DS   F'0'\n*\n* EDIT\n*\nCFG_ACEXEDMA     DS   CL3'NO'\nCFG_RESERVE3     DS   CL1' '\nCFG_EDTPROFT     DS   F'25'\nCFG_EBLKSIZE     DS   F'13680'\nCFG_EPRIMQTY     DS   F'40'\nCFG_ESECQTY      DS   F'200'\nCFG_UNDOSIZE     DS   F'0'\nCFG_CLIPNUM      DS   H'11'\nCFG_CLIPSIZE     DS   H'0'\nCFG_ANYCOLOR     DS   CL3'YES'\nCFG_DFLTCOLR     DS   FL1'3'\nCFG_EDITSTOR     DS   F'0'\nCFG_ASMVIDEO     DS   CL4'YES'\nCFG_TRUNCWRN     DS   CL3'YES'\nCFG_TFLOW        DS   CL8'.:&&<....'\nCFG_RESERVE4     DS   CL1' '\n* VSAM SUPPORT\nCFG_VSAMEE       DS   CL3'NO'\nCFG_VSAMEC       DS   CL50'DITTO VE /'\nCFG_VSAMEL       DS   CL3'NO'\nCFG_VSAMBE       DS   CL3'NO'\nCFG_VSAMBC       DS   CL50'DITTO VB /'\nCFG_VSAMBL       DS   CL3'NO'\nCFG_VSAMVE       DS   CL3'NO'\nCFG_VSAMVC       DS   CL50'DITTO VB /'\nCFG_VSAMVL       DS   CL3'NO'\n* EDIT PROFILE\nCFG_PDFCEIMACRO  DS   CL8' '\nCFG_EDITSTAT     DS   CL3'ON'\nCFG_EDITSTATF    DS   CL3'NO'\nCFG_EDITREC      DS   CL3'OFF'\nCFG_EDITRECF     DS   CL3'NO'\nCFG_EDITRECW     DS   CL6'WARN'\nCFG_EDITRECWF    DS   CL3'NO'\nCFG_EDITSETU     DS   CL3'ON'\nCFG_EDITSETUF    DS   CL3'NO'\nCFG_EDITPACK     DS   CL3'OFF'\nCFG_EDITPACKF    DS   CL3'NO'\nCFG_EDITUSERMAC  DS   CL8' '\nCFG_EDITUSERMACF DS   CL3'NO'\nCFG_EDITCAPS     DS   CL3'OFF'\nCFG_EDITNOTE     DS   CL3'ON'\nCFG_EDITHEX      DS   CL4'OFF'\nCFG_EDITNULL     DS   CL3'STD'\nCFG_EDITNUMD     DS   CL3'ON'\nCFG_EDITNUMC     DS   CL3'OFF'\nCFG_EDITNUMS     DS   CL3'ON'\nCFG_EDITAUTON    DS   CL3'OFF'\nCFG_EDITPRT      DS   CL3'OFF'\nCFG_EDITLOCK     DS   CL6'UNLOCK'\nCFG_EDITASAVE    DS   CL3'ON'\nCFG_EDITASAVP    DS   CL8'PROMPT'\nCFG_RESERVE5     DS   CL1' '\nCFG_EDITCOLOR    DS   CL3'OFF'\nCFG_EDITDOLOGIC  DS   CL3'OFF'\nCFG_EDITIFLOGIC  DS   CL3'OFF'\nCFG_EDITPAREN    DS   CL3'OFF'\nCFG_EDITFIND     DS   CL3'ON'\nCFG_EDITCURSOR   DS   CL3'ON'\nCFG_EDITHILANG   DS   AL1(1)\nCFG_RESERVE6     DS   CL3'   '\n*\n* GENERAL DM DEFAULTS\n*\nCFG_SCRMAX       DS   F'8'\nCFG_USERCMDS     DS   CL4' '\nCFG_SITECMDS     DS   CL4' '\nCFG_SCTSRCH      DS   CL1'B'\nCFG_ZWSAWARN     DS   CL3'YES'\nCFG_YEAR2000     DS   F'65'\n* ISPDFLTS\nCFG_TBADDROW     DS   F'1'\nCFG_RETCMDSZ     DS   F'512'\nCFG_ISPFEXIT     DS   XL1'60'\nCFG_TCPDATA      DS   CL49'DEFAULT'\nCFG_TCPPREF      DS   CL8'DEFAULT'\nCFG_RESERVE8     DS   CL2'  '\nCFG_USEOE        DS   F'0'\n*\n* SITE-WIDE DEFAULTS\n*\nCFG_ZVERMOD      DS   CL5'43000'\nCFG_ZTPS         DS   CL3'NO'\nCFG_ZTPSF        DS   CL3'NO'\nCFG_ZTA          DS   CL3'YES'\nCFG_ZTAF         DS   CL3'NO'\nCFG_ZSM          DS   CL3'NO'\nCFG_ZSMF         DS   CL3'NO'\nCFG_ZJMP         DS   CL3'YES'\nCFG_ZJMPF        DS   CL3'NO'\nCFG_ZASL         DS   CL3'YES'\nCFG_ZASLF        DS   CL3'NO'\nCFG_ZLMP         DS   CL3'YES'\nCFG_ZLMPF        DS   CL3'NO'\nCFG_ZEPDSC       DS   CL3'NO'\nCFG_ZEPDSCF      DS   CL3'NO'\nCFG_ZTTR         DS   CL3'YES'\nCFG_ZTTRF        DS   CL3'NO'\nCFG_ZCUAH        DS   CL3'YES'\nCFG_ZCUAHF       DS   CL3'NO'\nCFG_ZLOGFDSP     DS   CL1' '\nCFG_ZLOGFDF      DS   CL3'NO'\nCFG_ZLSTFDSP     DS   CL1' '\nCFG_ZLSTFDF      DS   CL3'NO'\nCFG_ZPLACE       DS   CL8' '\nCFG_ZPLF         DS   CL3'NO'\nCFG_ZKLUSE       DS   CL1'Y'\nCFG_ZKLF         DS   CL3'NO'\nCFG_ZPFSHOW      DS   CL3'ON'\nCFG_ZPFF         DS   CL3'NO'\nCFG_LSTBLK#      DS   F'26'\nCFG_LOGBLKSZ     DS   F'129'\nCFG_LOGLRECL     DS   F'125'\nCFG_TPCBLKSZ     DS   F'800'\nCFG_TCNTLRCL     DS   F'80'\nCFG_TPLBLKSZ     DS   F'3146'\nCFG_TLSTLRCL     DS   F'121'\nCFG_TWRKBLKS     DS   F'2560'\nCFG_TWRKLRCL     DS   F'256'\nCFG_PDSOPR       DS   CL6'DEST'\nCFG_LOCALPR1     DS   CL32'NONUM                           '\nCFG_LOCALPR2     DS   CL32'                                '\nCFG_LOCALPR3     DS   CL32'                                '\nCFG_LOCALPR4     DS   CL32'                                '\nCFG_PDSYFPALT    DS   CL3'NO'\n*\n* CUA PANEL ELEMENT ATTRIBUTES\n*\nCFG_CHCUA        DS   CL3'YES'\nCFG_ABSC         DS   CL3'600'\nCFG_ABSCF        DS   CL3'NO'\nCFG_ABSL         DS   CL3'100'\nCFG_ABSLF        DS   CL3'NO'\nCFG_ABUC         DS   CL3'720'\nCFG_ABUCF        DS   CL3'NO'\nCFG_AMT          DS   CL3'220'\nCFG_AMTF         DS   CL3'NO'\nCFG_CT           DS   CL3'620'\nCFG_CTF          DS   CL3'NO'\nCFG_CEF          DS   CL3'504'\nCFG_CEFF         DS   CL3'NO'\nCFG_CH           DS   CL3'120'\nCFG_CHF          DS   CL3'NO'\nCFG_DT           DS   CL3'400'\nCFG_DTF          DS   CL3'NO'\nCFG_ET           DS   CL3'520'\nCFG_ETF          DS   CL3'NO'\nCFG_EE           DS   CL3'622'\nCFG_EEF          DS   CL3'NO'\nCFG_FP           DS   CL3'400'\nCFG_FPF          DS   CL3'NO'\nCFG_FK           DS   CL3'100'\nCFG_FKF          DS   CL3'NO'\nCFG_IMT          DS   CL3'720'\nCFG_IMTF         DS   CL3'NO'\nCFG_LEF          DS   CL3'504'\nCFG_LEFF         DS   CL3'NO'\nCFG_LID          DS   CL3'400'\nCFG_LIDF         DS   CL3'NO'\nCFG_LI           DS   CL3'700'\nCFG_LIF          DS   CL3'NO'\nCFG_NEF          DS   CL3'504'\nCFG_NEFF         DS   CL3'NO'\nCFG_NT           DS   CL3'400'\nCFG_NTF          DS   CL3'NO'\nCFG_PIN          DS   CL3'400'\nCFG_PINF         DS   CL3'NO'\nCFG_PT           DS   CL3'100'\nCFG_PTF          DS   CL3'NO'\nCFG_PDAC         DS   CL3'700'\nCFG_PDACF        DS   CL3'NO'\nCFG_PDUAC        DS   CL3'100'\nCFG_PDUACF       DS   CL3'NO'\nCFG_RP           DS   CL3'720'\nCFG_RPF          DS   CL3'NO'\nCFG_SI           DS   CL3'720'\nCFG_SIF          DS   CL3'NO'\nCFG_SAC          DS   CL3'700'\nCFG_SACF         DS   CL3'NO'\nCFG_SUC          DS   CL3'100'\nCFG_SUCF         DS   CL3'NO'\nCFG_VOI          DS   CL3'500'\nCFG_VOIF         DS   CL3'NO'\nCFG_WMT          DS   CL3'620'\nCFG_WMTF         DS   CL3'NO'\nCFG_WT           DS   CL3'220'\nCFG_WTF          DS   CL3'NO'\nCFG_WASL         DS   CL3'100'\nCFG_WASLF        DS   CL3'NO'\nCFG_PS           DS   CL3'520'\nCFG_PSF          DS   CL3'NO'\n*\n* LOG/LIST DEFAULTS\n*\n*\nCFG_ZLLGJOB1     DS   CL36' '\n                 DS   CL36' '\nCFG_ZLLGJOB2     DS   CL36' '\n                 DS   CL36' '\nCFG_ZLLGJOB3     DS   CL36' '\n                 DS   CL36' '\nCFG_ZLLGJOB4     DS   CL36' '\n                 DS   CL36' '\nCFG_ZLOGCHAR     DS   CL1'1'\nCFG_ZLOGCLA      DS   CL15' '\nCFG_LOGCLAF      DS   CL3'NO'\nCFG_ZLOGIDSP     DS   CL1'N'\nCFG_ZLOGKEPT     DS   CL1'N'\nCFG_RESERVE9     DS   CL1' '\nCFG_ZLOGLIN      DS   F'60'\nCFG_ZLOGMID      DS   CL1'N'\nCFG_ZLOGPID2     DS   CL17' '\nCFG_LOGPID2F     DS   CL3'NO'\nCFG_RESERVEA     DS   CL3'   '\nCFG_ZLOG1PG      DS   F'10'\nCFG_ZLOG2PG      DS   F'10'\nCFG_ZLSTCHAR     DS   CL1'1'\nCFG_ZLSTCLA      DS   CL15' '\nCFG_LSTCLAF      DS   CL3'NO'\nCFG_ZLSTIDSP     DS   CL1'N'\nCFG_ZLSTKEPT     DS   CL1'N'\nCFG_RESERVEB     DS   CL3'   '\nCFG_ZLSTLIN      DS   F'60'\nCFG_ZLSTLLEN     DS   F'120'\nCFG_ZLSTPID2     DS   CL17' '\nCFG_LSTPID2F     DS   CL3'NO'\nCFG_ZLSTRCFM     DS   CL3'FBA'\nCFG_RESERVEC     DS   CL1' '\nCFG_ZLSTRECL     DS   F'121'\nCFG_ZLST1PG      DS   F'100'\nCFG_ZLST2PG      DS   F'200'\nCFG_ZJCHAR       DS   CL1' '\n*\n* SETTINGS/TERMINAL DEFAULTS\n*\nCFG_ZFMT         DS   CL1'S'\nCFG_ZTERM        DS   CL8'3278'\nCFG_RESERVED     DS   CL2'  '\nCFG_ZFAMPRT      DS   F'2'\nCFG_ZDEVNAM      DS   CL8' '\nCFG_DEVNAMF      DS   CL3'NO'\nCFG_RESERVEE     DS   CL1' '\nCFG_ZASPECT      DS   F'0'\nCFG_ZPADC        DS   CL1'B'\nCFG_ZDEL         DS   CL1';'\nCFG_ZCHAREUR     DS   CL1'N'\nCFG_CHAREURF     DS   CL3'NO'\nCFG_RESERVEF     DS   CL2'  '\n*\n* RETRIEVE DEFAULTS\n*\nCFG_ZRETMINL     DS   F'1'\nCFG_ZRETPOSC     DS   F'1'\n*\n* ENVIRON\n*\nCFG_ZENBLDMP     DS   CL3'OFF'\nCFG_ZTERMTDD     DS   CL8'ISPSNAP'\nCFG_TERMTDDF     DS   CL3'NO'\nCFG_ZTERMTR      DS   CL5'OFF'\n*\n* FUNCTION KEYS\n*\nCFG_ZPPRFX       DS   CL3'YES'\nCFG_ZFKA         DS   CL5'LONG'\nCFG_ZKEYS        DS   CL2'12'\n*\n* GENERAL\n*\nCFG_ZCHARLM      DS   CL8'ISP3278'\nCFG_CHARLMF      DS   CL3'NO'\nCFG_RESERVEG     DS   CL8'        '\nCFG_RESERVEH     DS   CL3'   '\nCFG_ZFRAMIC      DS   XL1'18'\nCFG_ZTPUTBSZ     DS   F'0'\n*\n* COLORS\n*\nCFG_ZGCOLORS     DS   CL8' 1234567'\nCFG_ZGGCOLRS     DS   CL16'  01041302030600'\nCFG_ZGHCOLR      DS   CL1' '\nCFG_ZGPCOLR      DS   CL1' '\n*\n* WORKSTATION\n*\nCFG_ZGUIAPPC     DS   CL32' '\n                 DS   CL32' '\nCFG_ZGUIAPP2     DS   CL32' '\n                 DS   CL32' '\nCFG_ZGUIAPP3     DS   CL32' '\n                 DS   CL32' '\nCFG_ZGUIAPP4     DS   CL32' '\n                 DS   CL32' '\nCFG_ZGUIAPP5     DS   CL32' '\n                 DS   CL32' '\nCFG_ZGUICL       DS   CL1'1'\nCFG_ZGUIEN       DS   CL1'/'\nCFG_ZGUIFR       DS   CL1'1'\nCFG_ZGUINET      DS   CL1'1'\nCFG_ZGUION       DS   CL1'1'\nCFG_ZGUISAVE     DS   CL1'Y'\nCFG_ZGUITCP      DS   CL32' '\n                 DS   CL32' '\nCFG_ZGUITCP2     DS   CL32' '\n                 DS   CL32' '\nCFG_ZGUITCP3     DS   CL32' '\n                 DS   CL32' '\nCFG_ZGUITCP4     DS   CL32' '\n                 DS   CL32' '\nCFG_ZGUITCP5     DS   CL32' '\n                 DS   CL32' '\nCFG_ZGUITIT      DS   CL32' '\n                 DS   CL32' '\nCFG_RESERVEN     DS   CL55' '\nCFG_ZGUIACCL     DS   CL1'/'\nCFG_ZGUICDPG     DS   XL2'0000'\nCFG_GUICDPGF     DS   CL3'NO'\nCFG_RESERVEI     DS   CL1' '\nCFG_ZGUICHST     DS   XL2'0000'\nCFG_GUICHSTF     DS   CL3'NO'\nCFG_ZGUIDBC      DS   CL1'1'\nCFG_ZGUIDOWN     DS   CL1'/'\nCFG_ZGUIMPTH     DS   CL1' '\n*\n* IDENTIFIER\n*\nCFG_ZSETMDS      DS   CL1'1'\nCFG_ZSETPDS      DS   CL1'1'\nCFG_ZSETSDS      DS   CL1'1'\n*\n* WSA DOWNLOAD\n*\nCFG_ZDTVOPT      DS   CL1'1'\nCFG_RESERVEJ     DS   CL2'  '\nCFG_ZDTWARN      DS   F'0'\nCFG_ZWSDADD      DS   CL32' '\n                 DS   CL32' '\nCFG_ZWSDBRO      DS   CL1'/'\nCFG_ZWSDCRE      DS   CL1' '\nCFG_ZWSDDIR      DS   CL30' '\n                 DS   CL30' '\nCFG_ZWSDMTHD     DS   CL1' '\nCFG_ZWSDPDS      DS   CL46'''ISP.SISPGUI'''\nCFG_WSDPDSF      DS   CL3'NO'\nCFG_ZWSDPLAT     DS   CL1' '\nCFG_ZWSDUSR      DS   CL30' '\n*\n* DATE AND TIME SEPARATOR\n*\nCFG_ZDATEFD      DS   CL8'DEFAULT'\nCFG_ZDATEF       DS   CL8'DEFAULT'\nCFG_ZTSEP        DS   CL1'D'\n*\nCFG_ZTBSRT       DS   CL3'NEW'\nCFG_ZGUI3270     DS   CL1'/'\n*\nCFG_ZLOGCLAL     DS   CL15' '\nCFG_LOGCLALF     DS   CL3'NO'\nCFG_ZLSTCLAL     DS   CL15' '\nCFG_LSTCLALF     DS   CL3'NO'\nCFG_SUPCLSPR     DS   CL5'50'\nCFG_SUPCLSSC     DS   CL5'100'\nCFG_SUPCUPPR     DS   CL5'15'\nCFG_SUPCUPSC     DS   CL5'30'\nCFG_OPT34HLQ     DS   CL3'NO'\nCFG_PID          DS   CL3'100'\nCFG_PIDF         DS   CL3'NO'\nCFG_ZDEFPPAN     DS   CL8'ISP@MSTR'\nCFG_ZSHOWENQ     DS   CL3'YES'\nCFG_ZDEFLANG     DS   CL8'ENGLISH'\nCFG_ZTMPUNIT     DS   CL3'NO'\nCFG_RESERVEK     DS   CL1' '\nCFG_ZCTLPQTY     DS   F'10'\nCFG_ZCTLSQTY     DS   F'100'\nCFG_ZWRKPQTY     DS   F'10'\nCFG_ZWRKSQTY     DS   F'100'\nCFG_ZTMPQUAL     DS   CL8' '\nCFG_ZLMFLOCK     DS   CL3'YES'\nCFG_PDFFVBRL     DS   CL3'NO'\nCFG_PDFEVBRL     DS   CL3'NO'\nCFG_EDITCUT      DS   CL7'REPLACE'\nCFG_EDITPAST     DS   CL6'KEEP'\nCFG_PDFDSCRL     DS   CL4'PAGE'\nCFG_PDFDSTAT     DS   CL3'SES'\n*\nCFG_PDFDSCVR     DS   CL3'NO'\nCFG_PDFDSMIN     DS   F'0'\nCFG_PDFDSMAX     DS   F'9999'\n*\nCFG_USR2CMDS     DS   CL4' '\nCFG_USR3CMDS     DS   CL4' '\nCFG_SIT2CMDS     DS   CL4' '\nCFG_SIT3CMDS     DS   CL4' '\nCFG_RFNDCHG      DS   CL3'NO'\nCFG_RESERVEL     DS   CL1' '\nCFG_ZTMPQVAR     DS   CL24' '\nCFG_PDFDSML      DS   CL3'YES'\nCFG_PDFDSMLF     DS   CL3'NO'\nCFG_PDFEPDSE     DS   CL1'NO'\nCFG_PDFEPDSP     DS   CL1'NO'\nCFG_PDFEPDSF     DS   CL1'YES'\nCFG_PDFEPDSR     DS   CL1'NO'\nCFG_RESERVEM     DS   CL2' '\nCFG_PDFC0BLK     DS   F'800'\nCFG_PDFC0LRC     DS   F'80'\nCFG_PDFCT0PQ     DS   F'10'\nCFG_PDFCT0SQ     DS   F'100'\nCFG_PDFLSXPQ     DS   F'10'\nCFG_PDFLSXSQ     DS   F'100'\nCFG_PDFDLIBD     DS   CL8'UNCOND'                                JK0209\n*\nCFG_PDFEHMCL     DS   H'-1'                                      JK0209\nCFG_PDFEHMCR     DS   H'-1'                                      JK0209\nCFG_PDFEHMIL     DS   H'-1'                                      JK0209\nCFG_PDFEHMIR     DS   H'-1'                                      JK0209\nCFG_PDFEHMXL     DS   H'-1'                                      JK0209\nCFG_PDFEHMXR     DS   H'-1'                                      JK0209\nCFG_PDFDRMID     DS   CL4'EDG'                                   JK0209\nCFG_PDFDRMCC     DS   CL45'%EDGRPD34'                            JK0209\nCFG_PDFDRMEE     DS   CL3'YES'                                   JK0209\nCFG_PDFPTHNS     DS   CL1'!'                                     JK0209\nCFG_PDFTMLS      DS   CL1'NO'                                    JK0209\nCFG_PDFTNQW      DS   H'1000'                                    JK0209\nCFG_PDFTNQK      DS   H'1'                                       JK0209\nCFG_PDFTNQP      DS   CL1'YES'                                   JK0209\nCFG_PDFTUCS      DS   CL1'KEEP'                                  JK0209\nCFG_PDFTUCI      DS   CL1'KEEP'                                  JK0209\nCFG_PDFTUCP      DS   CL1'KEEP'                                  JK0209\nCFG_PDFTUCR      DS   CL1'KEEP'                                  JK0209\nCFG_PDFTUCE      DS   CL1'KEEP'                                  JK0209\nCFG_PDFTUCB      DS   CL1'DISCARD'                               JK0209\nCFG_PDFTUCO      DS   CL1'KEEP'                                  JK0209\nCFG_PDFTUC1      DS   CL1' '                                     JK0209\nCFG_PDFTMLR      DS   CL1'NO'                                    JK0209\n*\nCFG_ZLSTRATR     DS   CL1'NO'                                    JK0209\nCFG_RESERVEY     DS   CL95' '                                    JK0209\nCFG_RESERVEZ     DS   3CL256' '\n*\nCFG_COMPDATE     DS   CL8'&SYSDATC'\nCFG_COMPTIME     DS   CL8'&SYSTIME'\nCFG_KWSOURCE     DS   CL54'SYSP08.ISPF.CFG.DATA(ISPCFIG)'\n         MEND\n./ ADD NAME=ISPTCM\n         MACRO                         ISPF\n         ISPTCM\nISPTCM_D DSECT\nTCMNAM  DS  CL8\nTCMDATE DS  CL8\nTCMLN   DS  FL1\nTCMUF   DS  FL1\nTCMCT   DS  H\nTCMCMTP DS  AL4\nTCMENTRY DS 0C              Starts of an entry\nTCMNAME DS  CL8             Name\nTCMDEFF DS  XL1             Default flag\nTCMDEFF_RSV  EQU X'80'        Reserved\nTCMDEFF_POOL EQU X'40'        Pool\nTCMDEFF_AUTH EQU X'20'        Auth check\nTCMDEFF_NOLOG EQU X'10'       No LOG\nTCMDEFF_INVALID EQU X'08'     Invalid\nTCMDEFF_CLIST EQU X'04'       CLIST\nTCMDEFF_CMD  EQU X'02'        CMD\nTCMDEFF_BLDL EQU X'01'        BLDL\nTCMDEFL DS  FL1             Default clear lines\n         MEND\n./ ADD NAME=IXCCPLX\n         MACRO                         XCF\n         IXCCPLX\nCPLX     DSECT\nCPLXEYEC   DS  CL4                     Eyecatcher 'CPLX'\nCPLXVERS   DS  CL1                     CPLX version '1'\n           DS  CL3\n           DS  CL4\nCPLXCPLC   DS  F                       CPLC pointer\nCPLXSMCA   DS  F                       SMCA ASID XCFAS\nCPLXSPCA   DS  F                       SPCA ??? ASID XCFAS\n           DS  XL4\nCPLXASCB   DS  F                       ASCB XCFAS ASID\n           DS  CL144                   PTR to PGM's and ???\nCPLXDS1    DS  CL8                     Dataspace name\nCPLXDS2    DS  CL8                     Dataspace name\nCPLXDS3    DS  CL8                     Dataspace name\nCPLXDST1   DS  CL8                     Dataspace token\nCPLXDST2   DS  CL8                     Dataspace token\nCPLXDST3   DS  CL8                     Dataspace token\n           DS  CL648\nCPLXTOD    DS  D                       TOD cold start??? X'368'\n           DS  CL76\nCPLXPTR    DS  F                       Ptr list to Couple-DS\n           DS  CL84\nCPLXTQE    DS  F                       TQE --> IHATQE X'414'\nCPLXDS   DSECT\nCPLXDSPTR  DS  F                       Ptr to Couple-DS CPLXDSE\nCPLXDSE  DSECT                         Couple-DS entry\n         DS    CL4\nCPLXDSNUM DS   C                       LPAR seq num\n         DS    CL3                     ???\nCPLXLPAR DS    CL8                     LPAR name\nCPLXCLCK1 DS    D                      Checkpoint ?? date/time (UTC)\n         DS    CL20                    ??\nCPLXPRI  DS    CL44                    Prim Couple DS\nCPLXPRIVOL DS  CL6                          VOLSER\nCPLXPRICRE DS  CL8                          Creation date/time (UTC)\nCPLXSEC  DS    CL44                    Sec  Couple DS\nCPLXSECVOL DS  CL6                          VOLSER\nCPLXSECCRE DS  CL8                          Creation date/time (UTC)\nCPLX_JOIN  DS  D                       Join to sysplex date/time (UTC)\nCPLXLPARNO DS  CL2                     Lpar number\n*\nCPLXSYSID1 DS  0CL4                    System Identifier Part 1\nCPLXCPUID  DS  CL2                       CPU-ID\nCPLXCPTYP  DS  CL2                       CPU-type\n*\n           DS  CL2                  ???\n           DS  CL3                  ???\nCPLXCLONE  DS  CL2                     SysClone\n           DS  CL1                  ???\n           DS  CL16                 ???\n           DS  CL3                  ???\nCPLXWEIGHT DS  CL1                    Weight\n           DS  CL8                  ???\n           DS  CL4                  ???\n           DS  CL3                  ???\nCPLXCLEAN  DS  CL1                    CleanUp\n           DS  CL28                 ???\n           DS  CL4                  ???\n*                                          siehe cmd D XCF,COUPLE\nCPLXSYSID2 DS  CL4                    System Identifier part 2\n         DS    CL8                    LPAR name\n         MEND\n./ ADD NAME=IXGCTA\n         MACRO                         Logger CTA\n         IXGCTA\nCTA@     DSECT         CTA@ header\nCTA@HEYE DS    CL4     id 'CTA '\nCTA@VER  DS    XL1     version of CTA                            RS0706\nCTA@LEN  DS    FL3     length of CTA                             RS0706\nCTA@HLEN EQU   *-CTA@  length of CTA@ header\nCTA@ENTR DSECT         CTA@ entry\nCTA@STRC DS    F       STRC\nCTA@ECBL DS    F       ECBL\nCTA@TCB  DS    F       TCB\nCTA@CONN_SEQNO DS    F   Connection sequence\nCTA@SLSA DS    F       Structure latch\n         DS    XL4     ??  X'E0000000' in my first cta\n*                      ??  X'F0000000' in my second cta\n         DS    F       some 31bit pointer no eyecatcher\n         DS    F       ??  X'00000000' in my first cta\n*                      ??  X'00000000' in my second cta\n         DS    F       some 24bit pointer no eyecatcher ECB????\n         DS    XL4     ??  X'00000000' in my first cta\n*                      ??  X'00000000' in my second cta\n         DS    XL4     ??  X'00000100' in my first cta\n*                      ??  X'00000101' in my second cta\n         DS    XL4     ??  X'00000000' in my first cta\n*                      ??  X'00000000' in my second cta\n         DS    XL4     ??  X'00000000' in my first cta\n*                      ??  X'00007fff' in my second cta\n         DS    XL4     ??  X'00000000' in my first cta\n*                      ??  X'00000000' in my second cta\nCTA@LSMF_L DS    F     last LSMF for z/OS < 2.2\nCTA@LSMF_F DS    F     first LSMF for z/OS < 2.2\n         DS    CL40                                              PG1216\nCTA@LSMF_L22 DS    F     last LSMF for z/OS >= 2.2\nCTA@LSMF_F22 DS    F     first LSMF for z/OS >= 2.2\n         DS    CL48    ???                                       PG1216\nCTA@ELEN EQU   *-CTA@ENTR  length of CTA@ entry\n*\n         MEND\n*\n         MEND\n./ ADD NAME=IXGLCB\n         MACRO                         Logger LCB\n         IXGLCB\nLCB      DSECT\nLCBEYEC  DS    CL4     id 'LCB'\nLCBLENGTH DS   FL3     length x'200'\nLCBVER   DS    XL1     version\nLCBDOMID DS    XL4     MSGIXG257_DOMID\n         DS    XL4     ??\nLCBSTRCB DS    F       STRCB cblock\nLCBFLAGS DS    XL4     ??\nLCB_CURDS_MMIBPTR DS  F MMIB\nLCB_CISIZE  DS XL4\nLCB_INDEX   DS XL4\nLCBLCCBQ DS    F       LCCB\nLCBSEQ#  DS    F       Sequence number\nLCBALLOCT DS   F       ALLOCT\nLCBLBLB  DS    F       LBLB\nLCBLSMF  DS    F       LSMF\nLCB_STREAM_NAME DS CL26 Stream-Name\nLCBCONID DS    XL2     Conn-ID\nLCB_LSR_TOKEN DS  XL4  LSR-Token\nLCB_CAPACITY_THRESHOLD DS  XL4  CAPACITY_THRESHOLD\nLCB_DISCONNECT_ATTRIBUTES DS  XL4  DISCONNECT_ATTRIBUTES\nLCB_LATCHINDEX DS  XL4  LATCH-Index\nLCB_RECOVER_BLKID DS XL4  Recover Block-ID\nLCB_LS_DATACLAS  DS CL8  Dataclass\nLCB_LS_MGMTCLAS  DS CL8  Mgmtclass\nLCB_LS_STORCLAS  DS CL8  Storclass\nLCB_STG_DATACLAS DS CL8  Dataclass\nLCB_STG_MGMTCLAS DS CL8  Mgmtclass\nLCB_STG_STORCLAS DS CL8  Storclass\nLCB_HLQ          DS CL8  HLQ\nLCB_STG_SIZE     DS XL4  Size\nLCB_LS_SIZE      DS XL4  Size\n         DS    CL344\nLCBLEN  EQU   *-LCB    length of LCB  entry\n         MEND\n./ ADD NAME=IXGLSAB\n         MACRO                         Logger LSAB\n         IXGLSAB\nLSAB     DSECT\nLSABEYEC DS    CL4     id 'LSAB'\n         DS    CL364   ???\nLSABASCB DS    F       pointer to ASCB\n         DS    CL384   ???\nLSABCTA@ DS    F       pointer to CTA@\n         MEND\n./ ADD NAME=IXGLSMF\n         MACRO                         Logger LSMF\n         IXGLSMF\nLSMF     DSECT\nLSMFEYEC DS    CL4     id 'LSMF'\nLSMFLENGTH DS   FL3    length\nLSMFVER    DS   XL1    version\nLSMFFORW DS    F       forward pointer chain\nLSMFBACW DS    F       backward pointer chain\nLSMFTOD  DS    XL8\nLSMFTYPE DS    CL16    '*DASDONLY*' in my case\nLSMFDSN  DS    CL26    without HLQ\n         DS    XL2     x'C000' in my case\nLSMFLCB  DS    F       LCB\n         DS    CL184\nLSMFLEN  EQU   *-LSMF  length of LSMF entry\n         MEND\n./ ADD NAME=J\n         MACRO\n&NAME    J     &D\n&NAME    DC    AL4(X'A7F40000'+(&D-*)/2)\n         MEND\n./ ADD NAME=LATENT\n         MACRO\n         LATENT\nLATENT   DSECT\nLATENTPARM1 DS F       Latent Parameter 1\nLATENTPARM2 DS F       Latent Parameter 2\nLATENTARR   DS F       Latent ARR recovery\n            DS F\n         MEND\n./ ADD NAME=OCVT\n         MACRO\n         OCVT\nOCVT         DSECT                                               RS1199\nOCVTEYEC     DS  CL4                   eyecatcher 'OCVT'         RS1199\n             DS  CL2                                             RS1199\nOCVT_LENGTH  DS  H                     length OCVT               RS1199\nOCVTOCVE     DS  F                     OCVE-Pointer              RS1199\nOCVTOEXT     DS  F                     OEXT-Pointer              RS1199\n             DS  F                                               RS1199\nOCVTASCB1    DS  F                     ASCB-Pointer for USS      RS1199\nOCVTASID     DS  H                     ASID for USS              RS1199\n             DS  CL2                                             RS1199\n             DS  F                                               RS1199\nOCVTSTOKEN   DS  D                     Kernel-Token              RS1199\n             DS  6F                                              RS1199\nOCVTASCB2    DS  F                     ASCB-Pointer for VTAM     RS1199\n             DS  CL248                 ??                        RS1199\nOCVT_STCNAME DS  CL8                                             RS1199\n         MEND\n./ ADD NAME=SHOWMRHA\n         MACRO\n         SHOWMRHA &DSECT=YES,&LIST=YES,&TITLE=YES,&NWMLIST=YES\n.********************** START OF SPECIFICATIONS ***********************\n.*                                                                    *\n.*  HEADER NAME:      EZBNMRHA                                        *\n.*                                                                    *\n.*  DESCRIPTIVE NAME: Network Monitor API Mapping                     *\n.*                                                                    *\n.*  COMPONENT NAME:   NMI                                             *\n.*                                                                    *\n.*  Copyright:    Licensed Materials - Property of IBM                *\n.*                5694-A01 (C) Copyright IBM Corp. 2003               *\n.*                All Rights Reserved.                                *\n.*                US Government Users Restricted Rights -             *\n.*                Use, duplication or disclosure restricted by        *\n.*                GSA ADP Schedule Contract with IBM Corp.            *\n.*                See IBM Copyright Instructions.                     *\n.*                                                                    *\n.*  Status:    CSV1R5                                                 *\n.*                                                                    *\n.*  Function:           This macro is used to map Network Monitor     *\n.*                      records.                                      *\n.*                                                                    *\n.*  Part Type:          Assembler macro                               *\n.*                                                                    *\n.*  Storage Attributes:                                               *\n.*    Subpool:          0-255                                         *\n.*    Data Space:       N/A                                           *\n.*    Key:              0-15                                          *\n.*    Residency:        N/A                                           *\n.*                                                                    *\n.*  Method of Access:   Assembler                                     *\n.*                                                                    *\n.*                        EZBNMRHA DSECT=YES,NWMLIST=YES              *\n.*                                                                    *\n.*  Notes for Use:      None.                                         *\n.*                                                                    *\n.*  Change Activity:                                                  *\n.*                                                                    *\n.*  $MAC(EZBNMRHA),COMP(IE),PROD(TCPIP):                              *\n.*                                                                    *\n.*  Flag Reason   Release  Date   Origin    Description               *\n.*  ---- -------- -------- ------ --------  ------------------------  *\n.*  $Q0= D316.66  CSV1R5   030212 JPWAJDA : Created (NMI support)     *\n.*  $Q1= D316.68  CSV1R5   030217 Callis  : Add Storage Statistics    *\n.*  $Q2= MV27886  D316.66  030306 JPWAJDA : Fix request/response      *\n.*                                            mappings                *\n.*  $Q3= MV27903  D316.66  030307 JPWAJDA : Fix request/response      *\n.*                                            mappings                *\n.*  $Q4= MV27965  D316.66  030310 JPWAJDA : Collect additional data   *\n.*  $Q5= MV27961  D316     030325 SMOONEN : Fix copyright statement   *\n.*  $  = PQ79566  HIP6140  031014 Klingman: Fix copyright statement   *\n.*                                          Sysroute (MV28994)        *\n.*  $A1= PQ86370  HIP6140  040322 MWS     : Correct alignment         *\n.*  $R1= PQ86370  HIP6140  040205 JPWAJDA : Fix IPv6 socket options   *\n.*                                          (Sysroute of MV29892)     *\n.*                                                                    *\n.**********************************************************************\n         GBLC  &EZBNMRHA_INCLUDED\n         GBLC  &ZCBPRINT\n&EZBNMRHA_INCLUDED SETC 'YES'\n         AIF   ('&LIST' EQ 'NONE').P0\n         AIF   ('&TITLE' EQ 'NO').P5\n TITLE   'EZBNMRHA  - TCPIP Network Management Parameter List     '\n.P5      ANOP\n.P0      ANOP\n         AIF   ('&ZCBPRINT' EQ 'NO').P1\n         AIF   ('&LIST' EQ 'YES').P2\n.P1      ANOP\n         PUSH  PRINT\n         PRINT OFF\n.P2      ANOP\n         AIF   ('&NWMLIST' EQ 'NO').L0002\n         AIF   ('&DSECT' EQ 'YES').L0003\n         AIF   ('&NWMLIST' NE 'YES').L0002\nNWMHeader                 DS    0D\n         AGO   .L0004\n.L0003   ANOP\nNWMHeader                 DSECT\n.L0004   ANOP\nNWMHeaderIdent            DS    CL4\nNWMHeaderLength           DS    F\nNWMVersion                DS    H\nNWMType                   DS    H\nNWMBytesNeeded            DS    F\n                          DS    CL20                             @Q4A\nNWMInputDataDescriptors   DS    0F                               @A1C\nNWMFilters                DS    (NWMTripletSize)C\nNWMOutputDataDescriptors  DS    0F                               @A1C\nNWMTcpConnDesc            DS    (NWMQuadrupletSize)C\n                          ORG   NWMOutputDataDescriptors\nNWMTcpListenDesc          DS    (NWMQuadrupletSize)C\n                          ORG   NWMOutputDataDescriptors\nNWMUdpConnDesc            DS    (NWMQuadrupletSize)C\n                          ORG   NWMOutputDataDescriptors         @Q1A\nNWMStgStatsDesc           DS    (NWMQuadrupletSize)C             @Q1A\n                          ORG   ,\nNWMHeaderSize             EQU   *-NWMHeader\nNWMHeaderIdentifier       EQU   C'NWMH'\nNWMVersion1               EQU   1\nNWMCurrentVer             EQU   NWMVersion1\nNWMTcpConnType            EQU   1\nNWMTcpListenType          EQU   2\nNWMUdpConnType            EQU   3\nNWMStgStatsType           EQU   4                                @Q1A\nNWMTriplet        DSECT\nNWMTOffset        DS    F\nNWMTLength        DS    F                                        @Q4C\nNWMTNumber        DS    F                                        @Q4C\nNWMTripletSize    EQU   *-NWMTriplet\nNWMQuadruplet     DSECT\nNWMQOffset        DS    F\nNWMQLength        DS    F                                        @Q4C\nNWMQNumber        DS    F                                        @Q4C\nNWMQMatch         DS    F                                        @Q4C\nNWMQuadrupletSize EQU   *-NWMQuadruplet\nNWMFilter                  DSECT\nNWMFilterIdent             DS    CL4\nNWMFilterFlags             DS    4XL1\nNWMFilterResNameMask       EQU   X'80000000'\nNWMFilterResIdMask         EQU   X'40000000'\nNWMFilterLclAddrMask       EQU   X'20000000'\nNWMFilterLclPortMask       EQU   X'10000000'\nNWMFilterLclPfxMask        EQU   X'08000000'\nNWMFilterRmtAddrMask       EQU   X'04000000'\nNWMFilterRmtPortMask       EQU   X'02000000'\nNWMFilterRmtPfxMask        EQU   X'01000000'\nNWMFilterAsidMask          EQU   X'00800000'\nNWMFilterLSResIdMask       EQU   X'00400000'\nNWMFilterResourceName      DS    CL8\nNWMFilterResourceId        DS    F\nNWMFilterListenerId        DS    F\nNWMFilterLocal             DS    0F\nNWMFilterLocalAddr4        DS    CL16\n                           ORG   NWMFilterLocal\nNWMFilterLocalAddr6        DS    CL28\n                           ORG   ,\nNWMFilterRemote            DS    0F\nNWMFilterRemoteAddr4       DS    CL16\n                           ORG   NWMFilterRemote\nNWMFilterRemoteAddr6       DS    CL28\n                           ORG   ,\nNWMFilterLocalNumMaskBits  DS    H\nNWMFilterRemoteNumMaskBits DS    H\nNWMFilterAsid              DS    Y\n                           DS    CL42                              @Q4C\nNWMFilterSize              EQU   *-NWMFilter\nNWMFilterIdentifier        EQU   C'NWMF'\nNWMFilterNumber_Max        EQU   4\nNWMTCPListenEntry      DSECT\nNWMTCPLIdent           DS    CL4\nNWMTCPLLocal           DS    0F\nNWMTCPLLocalAddr4      DS    CL16\n                       ORG   NWMTCPLLocal\nNWMTCPLLocalAddr6      DS    CL28\n                       ORG   ,\n                       DS    H\nNWMTCPLAsid            DS    Y\nNWMTCPLResourceName    DS    CL8\nNWMTCPLResourceID      DS    F\nNWMTCPLSubtask         DS    F\nNWMTCPLAcceptCount     DS    F\nNWMTCPLExceedBacklog   DS    F\nNWMTCPLCurrBacklog     DS    F\nNWMTCPLMaxBacklog      DS    F\nNWMTCPLCurrActive      DS    F\nNWMTCPLStartTime       DS    CL8                                   @Q4C\nNWMTCPLLastActivity    DS    CL8                                   @Q4C\nNWMTCPLLastReject      DS    CL8                                   @Q4C\nNWMTCPListenEntrySize  EQU   *-NWMTCPListenEntry\nNWMTCPListenIdentifier EQU   C'NWMT'\nNWMTCPConnEntry               DSECT\nNWMConnIdent                  DS    CL4\nNWMConnLocal                  DS    0F\nNWMConnLocalAddr4             DS    CL16\n                              ORG   NWMConnLocal\nNWMConnLocalAddr6             DS    CL28\n                              ORG   ,\nNWMConnRemote                 DS    0F\nNWMConnRemoteAddr4            DS    CL16\n                              ORG   NWMConnRemote\nNWMConnRemoteAddr6            DS    CL28\n                              ORG   ,\nNWMConnStartTime              DS    CL8                            @Q4A\nNWMConnLastActivity           DS    CL8\nNWMConnBytesIn                DS    CL8\nNWMConnBytesOut               DS    CL8\nNWMConnInSegs                 DS    CL8\nNWMConnOutSegs                DS    CL8\nNWMConnState                  DS    H                              @Q3C\nNWMTCPSTATEKLOSED             EQU   1\nNWMTCPSTATELISTEN             EQU   2\nNWMTCPSTATESYNSENT            EQU   3\nNWMTCPSTATESYNRCVD            EQU   4\nNWMTCPSTATEESTAB              EQU   5\nNWMTCPSTATEFINWAIT1           EQU   6\nNWMTCPSTATEFINWAIT2           EQU   7\nNWMTCPSTATECLOSWAIT           EQU   8\nNWMTCPSTATELASTACK            EQU   9\nNWMTCPSTATECLOSING            EQU   10\nNWMTCPSTATETIMEWAIT           EQU   11\nNWMTCPSTATEDELETTCB           EQU   12\nNWMConnActiveOpen             DS    B\n                              DS    B\nNWMConnOutBuffered            DS    F\nNWMConnInBuffered             DS    F\nNWMConnMaxSndWnd              DS    F\nNWMConnReXmtCount             DS    F\nNWMConnCongestionWnd          DS    F\nNWMConnSSThresh               DS    F\nNWMConnRoundTripTime          DS    F\nNWMConnRoundTripVar           DS    F\nNWMConnSendMSS                DS    F\nNWMConnSndWnd                 DS    F\nNWMConnRcvBufSize             DS    F\nNWMConnSndBufSize             DS    F\nNWMConnOutOfOrderCount        DS    F\nNWMConnLcl0WindowCount        DS    F\nNWMConnRmt0WindowCount        DS    F\nNWMConnDupacks                DS    F\n                              DS    H\nNWMConnAsid                   DS    Y\nNWMConnResourceName           DS    CL8\nNWMConnResourceId             DS    F\nNWMConnSubtask                DS    F                              @Q3M\nNWMConnSockOpt                DS    B\nNWMConnSOCKOPT_SO_REUSERADDR  EQU   X'80'\nNWMConnSOCKOPT_SO_OOBONLINE   EQU   X'40'\nNWMConnSOCKOPT_SO_LINGER      EQU   X'20'\nNWMConnSOCKOPT_T_MSGDONTROUTE EQU   X'10'\nNWMConnSOCKOPT_NO_DELAY       EQU   X'08'\nNWMConnSOCKOPT_SO_KEEPALIVE   EQU   X'04'\nNWMConnSOCKOPT_TIMING_LINGER  EQU   X'02'\nNWMConnSOCKOPT_TIMING_KEEPALI EQU   X'01'\nNWMConnSockOpt6               DS    B\nNWMConnSOCKOPT_UNICAST_HOPS   EQU   X'80'\nNWMConnSOCKOPT_HOPLIMIT       EQU   X'40'                     /* @R1C*/\nNWMConnSOCKOPT_USEMINMTU      EQU   X'20'                     /* @R1C*/\nNWMConnSOCKOPT_PKTINFO        EQU   X'10'                     /* @R1A*/\nNWMConnSOCKOPT_RCVPKTINFO     EQU   X'08'                     /* @R1A*/\nNWMConnSOCKOPT_RCVHOPLIM      EQU   X'04'                     /* @R1C*/\nNWMConnSOCKOPT_V6ONLY         EQU   X'02'                     /* @R1C*/\n*                             EQU   X'01'                     /* @R1A*/\nNWMConnClusterConnFlag        DS    B\nNWMConnINTERNALCLUSTER        EQU   X'08'\nNWMConnSAMEIMAGE              EQU   X'04'\nNWMConnSAMECLUSTER            EQU   X'02'\nNWMConnNOCLUSTER              EQU   X'01'\nNWMConnProto                  DS    B\nNWMConnPROTO_TN3270E          EQU   X'04'\nNWMConnPROTO_TN3270           EQU   X'02'\nNWMConnPROTO_LINE_MODE        EQU   X'01'\nNWMConnTargetAppl             DS    CL8\nNWMConnLuName                 DS    CL8\nNWMConnClientUserId           DS    CL8\nNWMConnLogMode                DS    CL8\nNWMConnTimeStamp              DS    F\nNWMConnTimeStampAge           DS    F\nNWMConnServerResourceId       DS    F                              @Q2C\nNWMConnIntfName               DS    CL16                           @Q4A\nNWMTCPConnEntrySize           EQU   *-NWMTCPConnEntry\nNWMTCPConnIdentifier          EQU   C'NWMC'\nNWMUDPConnEntry               DSECT\nNWMUDPConnIdent               DS    CL4\nNWMUDPCLocal                  DS    0F\nNWMUDPCLocalAddr4             DS    CL16\n                              ORG   NWMUDPCLocal\nNWMUDPCLocalAddr6             DS    CL28\n                              ORG   ,\nNWMUDPCRemote                 DS    0F\nNWMUDPCRemoteAddr4            DS    CL16\n                              ORG   NWMUDPCRemote\nNWMUDPCRemoteAddr6            DS    CL28\n                              ORG   ,\nNWMUDPCStartTime              DS    CL8                            @Q4A\nNWMUDPCLastAcxtivity          DS    CL8\nNWMUDPCDgramIn                DS    CL8\nNWMUDPCBytesIn                DS    CL8\nNWMUDPCDgramOut               DS    CL8\nNWMUDPCBytesOut               DS    CL8\n                              DS    H\nNWMUDPCAsid                   DS    Y\nNWMUDPCResourceName           DS    CL8\nNWMUDPCResourceId             DS    F\nNWMUDPCSubtask                DS    F\nNWMUDPCSockOpt                DS    B\nNWMUDPCSOCKOPT_BROADCAST      EQU   X'80'\nNWMUDPCSOCKOPT_LOOPBACK       EQU   X'40'\nNWMUDPCSOCKOPT_BYPASSRTE      EQU   X'20'\nNWMUDPCSOCKOPT_ICMPFWD        EQU   X'10'\nNWMUDPCSOCKOPT_SENDMULTI      EQU   X'08'\nNWMUDPCSOCKOPT_RECVMULTI      EQU   X'04'\nNWMUDPC6SockOpt1              DS    B\nNWMUDPC6SOCKOPT1_AF_INET6     EQU   X'80'\nNWMUDPC6SOCKOPT1_V6ONLY       EQU   X'40'\nNWMUDPC6SOCKOPT1_RCVPKT       EQU   X'20'\nNWMUDPC6SOCKOPT1_RCVHOP       EQU   X'10'\nNWMUDPC6SOCKOPT1_MINMTU       EQU   X'08'\nNWMUDPC6SOCKOPT1_SENDPKTADDR  EQU   X'04'\nNWMUDPC6SOCKOPT1_SENDPKTINTF  EQU   X'02'\nNWMUDPC6SOCKOPT1_HOPLIMIT     EQU   X'01'\nNWMUDPC6SockOpt2              DS    B\nNWMUDPC6SOCKOPT1_USEMINMTU    EQU   X'80'\n                              DS    B\nNWMUDPCSendLim                DS    F\nNWMUDPCRecvLim                DS    F\nNWMUDPCReadQueueCount         DS    F\nNWMUDPCReadQueueByteCount     DS    F\nNWMUDPCReadQueueLimit         DS    F\nNWMUDPCReadQueueByteLimit     DS    F\nNWMUDPCReadQueueLimitDiscards DS    F\nNWMUDPConnEntrySize           EQU   *-NWMUDPConnEntry\nNWMUDPCIdentifier             EQU   C'NWMU'\nNWMStgStatEntry               DSECT                              @Q1A\nNWMStgIdent                   DS    CL4                          @Q1A\n                              DS    CL4                          @Q1A\nNWMStgECSACurrent             DS    FD                           @Q1A\nNWMStgECSAMax                 DS    FD                           @Q1A\nNWMStgECSALimit               DS    FD                           @Q1A\nNWMStgPrivateCurrent          DS    FD                           @Q1A\nNWMStgPrivateMax              DS    FD                           @Q1A\nNWMStgPrivateLimit            DS    FD                           @Q1A\nNWMStgStatEntrySize           EQU   *-NWMStgStatEntry            @Q1A\nNWMStgStatsIdentifier         EQU   C'NWMS'                      @Q1A\n.L0002   ANOP\n         AIF   ('&ZCBPRINT' EQ 'NO').P3\n         AIF   ('&LIST' EQ 'YES').P4\n.P3      ANOP\n         POP   PRINT\n.P4      ANOP\n.P_EXIT  ANOP\n         MEND\n./ ADD NAME=SHOW$PAD\n         MACRO\n         SHOW$PAD   ,\nPAD      DSECT ,                   PROCLIB allocation DSECT\nPADID    DC    CL4'PAD'            Eyecatcher\nPADSIZE  DS    F                   PAD length\nPADNAME  DS    CL8                 Logical DD name\nPADALCDD DS    CL8                 Allocated DD name\nPADCRTIM DS    D                   PAD creation time\nPADDLTIM DS    D                   Time of last PAD deletion attempt\nPADFLAG1 DS    B                   General flag byte\nPAD1DEL  EQU   B'10000000'           PAD deleted\nPAD1UNC  EQU   B'01000000'           Unconditional allocation\nPAD1COND EQU   B'00100000'           Conditional allocation\n         DS    XL3                 Reserved\nPADPAD   DS    A                   PAD chain pointer\nPADALT   DS    A                   Alternate PAD chain\nPADDAD   DS    A                   Owning (main) pad\nPADUSE   DS    F                   PAD use count\nPADDSNLW DS    F                   Low data set subscript (always 1)\nPADDSNCT DS    F                   Data set count\nPADDSET  DS    0D                  Data set specifications\n         DS    255XL(PADELEN)      Max data set specifications\n         DS    0D                  Ensure alignment\nPADLEN   EQU   *-PAD               Maximum PAD length\n*--------------------------------------------------------------------*\n*        Data set specification                                      *\n*--------------------------------------------------------------------*\nPADE     DSECT ,                   PAD data set entry\nPADEDSN  DS    CL44                Data set name\nPADEUNIT DS    CL8                 Data set unit\nPADEVOL  DS    CL6                 Data set VOLSER\nPADEFLG1 DS    B                   Flag byte\nPADE1ALF EQU   B'10000000'           Data set not allocated (failed)\n         DS    X                   Reserved\n         DS    0F                  Align\nPADELEN  EQU   *-PADE              Length of data set entry\n         MEND\n./ ADD NAME=SSGARGL              IDCSS01\n         MACRO\n         SSGARGL\nSSGARGL  DSECT\n.**********************************************************************\n.* MAPS PARAMETER LIST FOR CALL TO IDCSS01                            *\n.* DOC IS: CACHE DEVICE ADMINISTRATION.                               *\n.**********************************************************************\n         DS    0F\nSSGHEAD  DC    CL8' '           SET BY IDCSS01\nSSGADDN  DC    F'0'             ADDR OF DDNAME OR ZERO\nSSGAVOL  DC    F'0'             ADDR OF VOLSER OR ZERO\nSSGUNIT  DC    X'3010200E'      UNIT TYPE\nSSGOLN   DC    F'0'             LENGTH OF BUFFER STORAGE AREA\nSSGOADR  DC    F'0'             ADDR OF BUFFER AREA\nSSGOPT   DC    0F'0'\nSSGOPT1  DC    X'00'\nSSGRPD   EQU   X'80'            REQ TO SENSE SUBSYSTEM COUNTS\nSSGRSS   EQU   X'40'            REQ TO SENSE SUBSYSTEM STATUS\nSSGCACHE EQU   X'20'            CACHE IF ON\nSSGSDS   EQU   X'10'            CACHE IF ON\nSSGALL   EQU   X'08'            REQ COUNTS FOR ALL LIKE SUBSYSTEMS\nSSG1SS   EQU   X'04'            REQ COUNTS FOR A SPECIFIED SUBSYS\nSSGDEV   EQU   X'02'            REQ COUNTS FOR SPECIFIED DEVICE\nSSGAMD   EQU   X'01'            PTR TO 3880 PASSED\nSSGOPT2  DC    X'00'\nSSG2SD   EQU   X'80'            PRINT BOTH SDS\nSSGMDLID DC    X'00'            SUBSYSTEM IDS\nSSGRCIOS DC    X'00'            IOS RETURN CODE\nSSGARGR  DSECT\n.**********************************************************************\n.* MAPS RETURN AREA FROM IDCSS01                                      *\n.* DOC IS: CACHE DEVICE ADMINISTRATION.                               *\n.**********************************************************************\n         DS    0F\nSSGDAVOL DC    CL6' '           RETURNED VOLSER\n         DC    CL2' '           RESERVED\nSSGDAUA1 DC    CL3' '           UNIT ADDRESS\nSSGDAUA2 DC    CL3' '           UNIT ADDRESS\nSSGDALN  DC    2X'00'           DATA LENGTH\nSSGDADA  DC    0X'00'           VARIABLE LENGTH DATA AREA\nSSGDASS  EQU   40,2\nSSGDA2SD EQU   80,2\nSSGDAIPF EQU   80,2\nSSGDAXPF EQU   96,2\nSSGDASPF EQU   160,2\nSSSTAT   DSECT              DESCRIBES RETURNED DATA AREA\n         DC    X'00'        RESERVED\n         DC    X'00'        DEVICE UNIT ADDRESS\n         DC    X'00'        NUMBER OF DEVICES\n         DC    X'00'        NUMBER STATS PER DEVICE\nCACHSTAT DC    X'00'        OVERALL CACHING STATUS\nNVSSTAT  DC    X'00'        NVS STATUS\n         DC    4X'00'       RESERVED\n         DC    4X'00'       CONFIGURED SSIDCHK\n         DC    4X'00'       AVAILABLE SSIDCHK\n         DC    4X'00'       PINNED SSIDCHK SPACE\n         DC    4X'00'       OFFLINE SSIDCHK CAPACITY\nDEVSTAT  DC    2X'00'\n         DC    4X'00'       CONFIGURED NVS\n         DC    4X'00'       PINNED NVS STORAGE\n         DC    X'00'        DEVICE STATUS\n         DC    X'00'        RESERVED\nSSID     DC    2X'00'       SUBSYSTEM ID\n         MEND\n./ ADD NAME=FLATMAC                                               -DEL-\n*PVTMACS(FLATMAC)                                                 -DEL-\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "UKEYCSA": {"ttr": 13061, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01(\\x00C\\x01\\x08\\x15?\\x01\\x19\\t\\x7f\\x11\\x06\\x02\\x84\\x00a\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.40", "flags": 0, "createdate": "2008-06-01T00:00:00", "modifydate": "2019-04-07T11:06:43", "lines": 644, "newlines": 97, "modlines": 0, "user": "SBGOLOB"}, "text": "UKEYCSA  TITLE 'Whether or not to allow allocation of CSA in User Key'\n*  -----------------------------------------------------------------  *\n*                                                                     *\n*    Function:   To turn the global setting of whether a program      *\n*                can allocate Key 8 storage in common storage.        *\n*                This is determined by a PARMLIB setting in the       *\n*                DIAGxx member:  VSM ALLOWUSERKEYCSA(YES)   or        *\n*                                VSM ALLOWUSERKEYCSA(NO) .            *\n*                                                                     *\n*                If you want to switch this setting temporarily,      *\n*                then issue this APF-authorized TSO command:          *\n*                                                                     *\n*                Bit settings are found in the DGNBOPTIONS1 byte      *\n*                of the DGNB control block mapped by the IGVDGNB      *\n*                macro in SYS1.MODGEN.                                *\n*                                                                     *\n*          UKEYCSA N   -  to not allow Common Storage allocations     *\n*                         in Key 8 or a user key - X'80'              *\n*                                                                     *\n*          UKEYCSA Y   -  to allow Common Storage allocations         *\n*                         in Key 8 or a user key - X'40' (or X'00')   *\n*                                                                     *\n*          UKEYCSA (anything else) - to display the current setting   *\n*                                    of the DGNBOPTIONS1 byte         *\n*                                                                     *\n*          Note.  This functionality is going away with z/OS 2.4.     *\n*                 The bit that this program sets, will not work       *\n*                 anymore after that time.  So the effective life     *\n*                 of this program is from z/OS 1.8 thru z/OS 2.3.     *\n*                 (Feb 2019 - announced by IBM)                       *\n*                                                                     *\n*    Date:       June 2, 2008                                         *\n*                                                                     *\n*    Technical Detail:  PUTLINE interface for TSO Output.             *\n*                                                                     *\n*    Release Dependencies:  Needs z/OS 1.8 or above.                  *\n*                                                                     *\n*            Only effective for z/OS 1.8 and higher.  At the          *\n*            z/OS 1.7 level, the DGNB control block exists            *\n*            at Level 03, but changing the DGNBOPTIONS1 bit           *\n*            is not effective, and does not do anything.              *\n*            Same for the z/OS 1.6 level.  At the z/OS 1.5            *\n*            level, the DGNB control block is at Level 02,            *\n*            and the entire control block does not even have          *\n*            any space for the DGBNOPTIONS1 field.  At or             *\n*            below the z/OS 1.4 level, the IGVDGNB control            *\n*            block is at Level 01.  The DGNB control block            *\n*            was created at the OS/390 2.6 level, and did not         *\n*            exist before that.                                       *\n*                                                                     *\n*    Changes:                                                         *\n*                                                                     *\n*            This program will be useless from z/OS 2.4 onward.       *\n*                                                                     *\n*                                                                     *\n*  -----------------------------------------------------------------  *\n         MACRO\n&NAME    HEX   &TO,&LEN,&FROM\n&NAME    STM   15,1,HEXSAVE\n         LA    1,&FROM\n         LA    0,&LEN\n         LA    15,&TO\n         BAL   4,HEX\n         LM    15,1,HEXSAVE\n         MEND\n*  -----------------------------------------------------------------  *\n         MACRO\n&NAME    REGS\n         LCLA  &I\n&I       SETA  0\n.LUP     ANOP\nR&I      EQU   &I\n&I       SETA  &I+1\n         AIF   (&I LE 15).LUP\n         MEND\n*  -----------------------------------------------------------------  *\n*  --           Create PUTLINE environment.                       --  *\n*  -----------------------------------------------------------------  *\n         MACRO\n&LABEL   APUT  &MSG,                    @MESSAGE TEXT                  &\n               &LEN,                    @LENGTH OF MESSAGE             &\n               &RSA=,                   OPTIONAL 2 WORD SAVE AREA      &\n               &EPA=                    EPUTL EPA\n.*\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n.*  --> E@PUT\n.*\n.*  THIS MACRO SETS UP A PARAMETERS AND INVOKES THE EPUTL ROUTINE.\n.*\n.*\n.*  ARGUMENTS: -----------------------------------------------------\n.*\n.*      &MSG : ADDRESS OF MESSAGE TEXT OR A LITERAL\n.*\n.*      &LEN : LENGTH OF MESSAGE TEXT (DEFAULT IS L'&MSG)\n.*\n.*      &RSA :(OPTIONAL) 1 WORD SAVE AREA TO PRESERVE R14 FOR TPUT\n.*            COMPATIBILITY.\n.*\n.*      &EPA :(OPTIONAL) EPA FOR EPUTL ROUTINE\n.*\n.*\n.*   EXAMPLES: -----------------------------------------------------\n.*\n.*      1) APUT  'LITERAL'\n.*\n.*      2) APUT  (R3),80\n.*\n.*      3) APUT  LABEL\n.*\n.*      4) APUT  LABEL,40\n.*\n.*\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n.*\n.*  LOCAL SET SYMBOLS\n.*\n         LCLC  &SMA                     MESSAGE ADDRESS (REG)\n         LCLC  &SML                     MESSAGE LENGTH (REG)\n         LCLC  &SEP                     EPA (REGISTER)\n.*\n         LCLC  &L1,&L2,&L3              LOCAL LABELS\n.*\n&L1      SETC  'EP'.'&SYSNDX'.'L1'      LOCAL LABELS\n&L2      SETC  'EP'.'&SYSNDX'.'L2'      LOCAL LABELS\n&L3      SETC  'EP'.'&SYSNDX'.'L3'      LOCAL LABELS\n.*\n.*\n.*  MESSAGE ADDRESS\n.*\n         AIF   (T'&LABEL EQ 'O').A0500                      *HMD 11/86*\n.*                                                          *HMD 11/86*\n&LABEL   DS    0H                                           *HMD 11/86*\n.*                                                          *HMD 11/86*\n.A0500   ANOP                                               *HMD 11/86*\n         AIF   ('&MSG' NE '').A2000\n         MNOTE 8,'''&MSG='' MISSING / REQUIRED'\n         MEXIT\n.*\n.A2000   ANOP\n         AIF   ('&MSG'(1,1) NE '(').A2400\n&SMA     SETC  '&MSG'(2,K'&MSG-2)\n         LR    R1,&SMA                  @MESSAGE TEXT\n         AGO   .A2600\n.*\n.A2400   ANOP\n         AIF   ('&MSG'(1,1) NE '''').A2500\n         B     &L3                      BRANCH AROUND MESSAGE\n&L2      DC    C&MSG\n&L3      DS    0H\n         LA    R1,&L2                   @MESSAGE\n         AGO   .A2600\n.*\n.A2500   ANOP\n         LA    R1,&MSG                  @MESSAGE TEXT\n.A2600   ANOP\n.*\n.*  MESSAGE LENGTH\n.*\n         AIF   ('&LEN' NE '').A3000\n         AIF   ('&MSG'(1,1) NE '''').A2800\n         LA    R0,L'&L2                 MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A2800   ANOP\n         AIF   ('&MSG'(1,1) EQ '(').A2900\n         LA    R0,L'&MSG                MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A2900   ANOP\n         MNOTE 8,'''LEN'' MISSING / REQUIRED'\n         MEXIT\n.*\n.A3000   ANOP\n         AIF   ('&LEN'(1,1) NE '(').A3400\n&SML     SETC  '&LEN'(2,K'&LEN-2)\n         LR    R0,&SML                  MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A3400   ANOP\n         LA    R0,&LEN                  MESSAGE LENGTH\n.A3600   ANOP\n.*\n.*  RSA\n.*\n         AIF   ('&RSA' EQ '').A4900\n         ST    R14,&RSA                 SAVE REGS 14\n.A4900   ANOP\n.*\n.*  ENTRY POINT\n.*\n         AIF   ('&EPA' NE '').A5000\n         L     R15,=V(EPUTL)            EPA\n         AGO   .A5600\n.*\n.A5000   AIF   ('&EPA'(1,1) NE '(').A5400\n&SEP     SETC  '&EPA'(2,K'&EPA-2)\n         LR    R15,&SEP                 EPA\n         AGO   .A5600\n.*\n.A5400   ANOP\n         L     R15,&EPA                 EPA\n.*\n.A5600   ANOP\n.*\n.*  CALL LINKAGE\n.*\n.ACALL   BALR  R14,R15                  CALL PUTLINE ROUTINE\n.*\n         AIF   ('&RSA' EQ '').A6900\n         L     R14,&RSA                 RESTORE R14\n.A6900   ANOP\n.*\n.AMEND   MEND\n* ------------------------------------------------------------------- *\n* --       End of Internal Macros......                            -- *\n* ------------------------------------------------------------------- *\n         SPACE 3\nUKEYCSA  CSECT\nUKEYCSA  AMODE 31\nUKEYCSA  RMODE ANY\n         REGS\n         USING UKEYCSA,R15         (ESTABLISH TEMPORARY BASE).\n         B     BEGIN               SKIP OVER HEADER.\nEYEC0    DC    AL1(EYECL)          EXCLUSIVE LENGTH OF HEADER.\nEYEC     DC    C' UKEYCSA - &SYSDATE - &SYSTIME -'\n         DC    C'     --------------------------------    '\n         DC    C'             '\n         DC    C'                   '\nEYECL    EQU   *-EYEC\n         DROP  R15                 (DROP TEMPORARY BASE).\nBEGIN    STM   R14,R12,12(R13)     SAVE CALLER'S REGISTERS\n         LR    R12,R15             COPY BASE.\n         USING UKEYCSA,R12         (TELL ASSEMBLER).\n         LR    R14,R13             COPY CALLER'S SAVE AREA POINTER.\n         LA    R13,SAVE            POINT TO MY SAVE AREA.\n         ST    R13,8(,R14)         CHAIN ...\n         ST    R14,SAVE+4          ... SAVE AREAS.\n         SPACE 1\n         LTR   R1,R1               ANY CPPL OR PARM POINTER?\n         BZ    RETURN              B IF NOT.\n         L     R2,0(,R1)           POINT TO BUFFER\n         LTR   R2,R2               ANY?\n         BZ    RETURN              B IF NOT.\n         LH    R3,0(R2)            LOAD LENGTH.\n         LTR   R3,R3               ANY?\n         BZ    RETURN              B IF NOT.\n         CLI   2(R2),X'00'         COMMAND PROCESSOR INVOCATION?\n         BE    RLDCP\n         LA    R2,2(,R2)           POINT TO PARM.\n         B     PARM\nRLDCP    CH    R3,=H'4'            ANY PARM?\n         BE    NEITHER             B IF NOT.\n         AH    R2,2(,R2)           POINT TO ...\n         LA    R2,4(,R2)           ... PARM.\nPARM     OI    0(R2),C' '          UPPERCASE.\n*\n* --- Parms gotten at this point.                            -------- *\n* --- Are we allowing Key 8 allocation of CSA, YES or NO ?   -------- *\n*\nSETFLAGS DS    0H\n         MVI   FLAG1,X'00'\nUNALLOW  CLI   0(R2),C'N'          N. We don't want to allow?\n         BNE   ALLOW               No. Try if Y.\n         OI    FLAG1,FLAGCSNO      Set up for not allowing.\n         B     FINDDATA            Go get DGNBOPTIONS1 bit.\nALLOW    CLI   0(R2),C'Y'          Y. We want to allow?\n         BNE   NEITHER             No. Must be No Change.\n         OI    FLAG1,FLAGCSYS      Set up for allowing.\n         B     FINDDATA            Go get DGNBOPTIONS1 bit.\nNEITHER  DS    0H                  No change.\n         MVI   FLAG1,X'00'         Nullify change flags.\n*\n* - Parm chosen. Get the DGNB control block and the switching bits. - *\n*\nFINDDATA L     R5,X'10'            POINT TO THE CVT.\n         L     R5,X'8C'(,R5)       POINT TO THE ECVT.\n         L     R5,X'14C'(,R5)      POINT TO THE DGNB.\n         USING DGNB,R5             (TELL ASSEMBLER).\n         CLC   =C'DGNB',0(R5)      Are we really there?\n         BNE   RELERR              No. Report a problem.\n         CLC   =C'03',4(R5)        Proper level of IGVDGNB?\n         BH    RELERR              Too low. Report the problem.\n* -- >     Further tests for release dependency - below\n         L     R6,16               Get CVT\n         USING CVT,R6\n         TM    CVTDCB,CVTOSEXT     Does CVTOSLVL exist?\n         BZ    RELERR              No. Wrong release.\n         TM    CVTOSLV5,CVTH7730   Are we at least at z/OS 1.8 ?\n         BZ    RELERR              No. Wrong release.\n         DROP  R6\n* -- >     Further tests for release dependency - above\nDISPFLAG DS    0H\n         MVC   STORFLAG(1),DGNBOPTIONS1  Save entire byte for reporting\n         CLI   FLAG1,X'00'               Did we have a valid parm?\n         BE    MESSAGES                  No. Just report no change.\nON       DS    0H                  This section is for the Key 0 stuff.\n* -- >       Test if this command is being run APF Authorized\n         STM   R15,R1,SAVE14T1     Now save registers and test if APF\n         XR    R15,R15                  authorized.\n         TESTAUTH FCTN=1           Are we authorized?\n         LTR   R15,R15             Test the return code.\n         BNZ   NOTAUTH             Not zero, tell not authorized.\n         LM    R15,R1,SAVE14T1     Restore registers used by TESTAUTH.\n* -- >                             We're authorized. Go Key 0.\n         MODESET KEY=ZERO\n         TM    FLAG1,FLAGCSNO      Flag setting to NOT allow?\n         BNO   ALLOWX              No. Try and see if we want to allow.\nUNALLOWX OI    DGNBOPTIONS1,X'80'           Set bit to NOT allow.\n         NI    DGNBOPTIONS1,X'FF'-X'40'     Turn off bit to allow.\n         B     ENDMOD                       Save bit settings.\nALLOWX   TM    FLAG1,FLAGCSYS      Flag setting to ALLOW?\n         BNO   ENDMOD              No. No changes will be made.\n         OI    DGNBOPTIONS1,X'40'           Turn on bit to allow.\n         NI    DGNBOPTIONS1,X'FF'-X'80'     Turn off bit to NOT allow.\n         B     ENDMOD                       Save bit settings.\nENDMOD   DS    0H                           Leave Key 0\n         MVC   STORFLAG(1),DGNBOPTIONS1   Save bit settings for report.\n         MODESET KEY=NZERO\n         DROP  R5\nMESSAGES DS    0H                         Program Title\n         APUT  'Allow Userkey CSA Allocations - No or Yes ',42\n         APUT  '----- ------- --- ----------- - -- -- --- ',42\n         APUT  '                                          ',42\n** ---------------------------------------------------------------- **\nMESSAGOF DS    0H                         Report Key 8 CSA NOT allowed.\n         TM    FLAG1,FLAGCSNO             Test if making NOT allowed.\n         BNO   MESSAGON                   No. Try allowed.\n         STM   R14,R1,SAVE14T1            Save registers for APUT.\n         MVC   OUTPUT,OUTPUT-1            Show state of DGNB byte.\n         MVC   OUTPUT(18),=C'DGNBOPTIONS1 Flag '\n         HEX   OUTPUT+20,1,STORFLAG\n         TM    STORFLAG,X'80'\n         BO    MESS01NO\n         MVC   OUTPUT+24(3),=C'YES'\n         B     MESS01YS\nMESS01NO MVC   OUTPUT+24(3),=C'NO '\nMESS01YS DS    0H                         Write actual message.\n         APUT  OUTPUT,27\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(MSGOFLEN),MSGOF\n         APUT  OUTPUT,MSGOFLEN\n         APUT  '                                          ',42\n         LM    R14,R1,SAVE14T1            Restore registers, and\n         B     RETURN                       Get out....\n** ---------------------------------------------------------------- **\nMESSAGON DS    0H                         Report Key 8 CSA is allowed.\n         TM    FLAG1,FLAGCSYS             Test if making YES allowed.\n         BNO   MESSAGNC                   No. Then we're not changing.\n         STM   R14,R1,SAVE14T1            Save registers for APUT.\n         MVC   OUTPUT,OUTPUT-1            Show state of DGNB byte.\n         MVC   OUTPUT(18),=C'DGNBOPTIONS1 Flag '\n         HEX   OUTPUT+20,1,STORFLAG\n         TM    STORFLAG,X'80'\n         BO    MESS02NO\n         MVC   OUTPUT+24(3),=C'YES'\n         B     MESS02YS\nMESS02NO MVC   OUTPUT+24(3),=C'NO '\nMESS02YS DS    0H                         Write actual message.\n         APUT  OUTPUT,27\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(MSGONLEN),MSGON\n         APUT  OUTPUT,MSGONLEN\n         APUT  '                                          ',42\n         LM    R14,R1,SAVE14T1            Restore registers, and\n         B     RETURN                       Get out....\n** ---------------------------------------------------------------- **\nMESSAGNC DS    0H                         Report NO CHANGE.\n         STM   R14,R1,SAVE14T1            Save registers for APUT.\n         MVC   OUTPUT,OUTPUT-1            Show state of DGNB byte.\n         MVC   OUTPUT(18),=C'DGNBOPTIONS1 Flag '\n         HEX   OUTPUT+20,1,STORFLAG\n         TM    STORFLAG,X'80'\n         BO    MESS03NO\n         MVC   OUTPUT+24(3),=C'YES'\n         B     MESS03YS\nMESS03NO MVC   OUTPUT+24(3),=C'NO '\nMESS03YS DS    0H                         Write actual message.\n         APUT  OUTPUT,27\n         MVC   OUTPUT,OUTPUT-1\n         MVC   OUTPUT(MSGNCLEN),MSGNC\n         APUT  OUTPUT,MSGNCLEN\n         APUT  '                                          ',42\n         LM    R14,R1,SAVE14T1            Restore registers, and\n         B     RETURN                       Get out....\n** ---------------------------------------------------------------- **\nRETURN   L     R13,SAVE+4             E\n         LM    R14,R12,12(R13)          X\n         SR    R15,R15                    I\n         BR    R14                          T\n** ---------------------------------------------------------------- **\nNOTAUTH  DS    0H                  Command not APF authorized message.\n         APUT  MESSAG2C,L'MESSAG2C\n         B     RETURN\n** ---------------------------------------------------------------- **\nRELERR   DS    0H                  Command not APF authorized message.\n         APUT  MESSAG1C,L'MESSAG1C\n         B     RETURN\n** ---------------------------------------------------------------- **\n** --         C  O  N  S  T  A  N  T  S                          -- **\n** ---------------------------------------------------------------- **\nMESSAG1C DC    C'UKEYCSA is only supported for z/OS 1.8 and higher.'\nMESSAG2C DC    C'Command was not invoked APF authorized.'\nFLAG1    DC    X'00'\nFLAGCSNO EQU   B'10000000'            DGNBALLOWUSERKEYCSANO\nFLAGCSYS EQU   B'01000000'            DGNBALLOWUSERKEYSPEC\nSTORFLAG DC    X'00'\nHEXSAVE  DS    3F                  SAVE FOR HEX MACRO\n         DS    0D\nMSGOF    DC    C'ALLOWUSERKEYCSA has been set to NO  '\nMSGOFLEN EQU   *-MSGOF\n         DS    0D\nMSGON    DC    C'ALLOWUSERKEYCSA has been set to YES '\nMSGONLEN EQU   *-MSGON\n         DS    0D\nMSGNC    DC    C'ALLOWUSERKEYCSA has not been changed'\nMSGNCLEN EQU   *-MSGNC\nSAVE     DS    9D                  Program Save Area\nSAVE14T1 DS    2D                  Save \"system-used\" registers.\n         DC    C' '                Blank before OUTPUT line.\nOUTPUT   DC    CL80'  '            Variable output line.\n         LTORG\n** ---------------------------------------------------------------- **\nHEX      DS    0H\n         MVC   1(1,R15),0(R1)      MOVE BYTE\n         UNPK  0(3,R15),1(2,R15)   UNPACK\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)         INCREMENT OUTPUT PTR\n         LA    R1,1(,R1)           INCREMENT INPUT PTR\n         BCT   R0,HEX              DECREMENT LENGTH, THEN LOOP\n         MVI   0(R15),C' '         BLANK THE TRAILING BYTE\n         BR    R4                  RETURN TO CALLER\nHEXTAB   DC    C'0123456789ABCDEF' TRANSLATE TABLE\n         SPACE\n         TITLE '- MAPPING MACROS.'\n         CVT   DSECT=YES           Map the CVT.\n         IGVDGNB                   Map the DGNB control block.\n         END   UKEYCSA\n** ---------------------------------------------------------------- **\n*  -----------------------------------------------------------------  *\n*  --           Create PUTLINE environment.                       --  *\n*  -----------------------------------------------------------------  *\nEPUTL    TITLE 'PUTLINE FOR FEWER THAN 83 ARGUMENTS IN THE KEY OF C MAJ&\n               OR'\nEPUTL    CSECT                                              *HMD 10/85*\n         LCLB  &XA                                          *HMD 10/85*\n&XA      SETB  1                  SET TO ZERO ON NON/XA     *HMD 10/85*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*  MODULE NAME  . . . . EPUTL\n*\n*  ALIASES  . . . . . . NONE\n*\n*  DATE WRITTEN . . . . 06/85\n*  UPDATED      . . . . 04/88                                  HD APR88\n*\n*  AUTHOR . . . . . . . JIM ELSWORTH\n*  UPDATOR  . . . . . . HOWARD M. DEAN                         HD APR88\n*\n*  ENVIRONMENT  . . . . TSO COMMAND-PROCESSOR\n*\n*  PURPOSE:\n*    ALLOW AN EASY INTERFACE TO PUTLINE ROUTINE\n*\n*\n*  DESCRIPTION:\n*    BUILDS PUTLINE PARAMETER LIST BASED ON INPUT ARGUMENTS.\n*    ISSUES SINGLE LINE PUTLINE.\n*\n*\n*  ATTRIBUTES:\n*    REENTRANT\n*\n*  FEATURES:\n*    WILL RUN UNDER BATCH TMP SINCE PUTLINE USED INSTEAD OF TPUT.\n*\n*  CALLED MODULES:\n*    PUTLINE\n*\n*  ASSUMPTIONS:\n*    CALLED BY A TSO-CP THAT IS OBSERVING STANDARD LINKAGE\n*\n*  ABENDS:\n*    POSSIBLE 0CX IF BAD ARGUEMNTS\n*\n*  CAVEATS:\n*    UNPREDICTABLE RESULTS IF FIRST PROGRAM RUNNING UNDER THIS TCB\n*    DID NOT SAVE (14,12) BEFOR R1 WAS MODIFIED.\n*\n*\n*  INPUT ARGUMENTS:\n*    1)  R1 : ADDRESS OF MESSAGE TEXT\n*    2)  R0 : LENGTH OF MESSAGE TEXT\n*    3) R13 : STANDARD OS SAVE AREA\n*    4) R14 : RETURN ADDRESS\n*    5) R15 : ENTRY ADDRESS\n*\n*               ( CONTINUED ... )\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*\n*  OUTPUT ARGUMENT: RETURN CODE FROM PUTLINE OR\n*\nRCBA     EQU   100                 BAD MESSAGE ADDRESS\nRCBL     EQU   104                 MESSAGE LENGTH <1 OR >MAXMSG\n*\nMAXMSG   EQU   128                 MAXIMUM MESSAGE LENGTH\n*\n*\n*  REGISTERS USED:\n*\nR0       EQU   0                   MESSAGE LENGTH AT ENTRY\nR1       EQU   1                   MESSAGE ADDRESS AT ENTRY\nR2       EQU   2                   WORK\nRMA      EQU   4                   @MESSAGE TEXT\nRML      EQU   5                   MESSAGE LENGTH\nRUPT     EQU   6                   @UPT (USER PROFILE TABLE)\nRECT     EQU   7                   @ECT\nR12      EQU   12                  CSECT BASE\nR13      EQU   13                  @SAVE AREA AND DYNAMIC WORK AREA\nR14      EQU   14                  WORK/LINKAGE\nR15      EQU   15                  WORK/LINKAGE\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n         IKJCPPL\n         EJECT\n         IKJTCB   LIST=YES                                  *HMD 10/85*\n         EJECT                                              *HMD 10/85*\n         CVT      DSECT=YES,LIST=YES                        *HMD 10/85*\n         EJECT\n         IHAPSA   LIST=YES                                     HD APR88\n         EJECT                                                 HD APR88\nPUTLDS   DSECT\n         DS    18F                      OS SAVE AREA\nPUTAAA   EQU   *\nPUTECB   DS    F                        ECB\nPUTIOPL  DS    4F                       IOPLADS\nPUTBLOK  PUTLINE MF=L\nPUTLEN   DS    H                        LENGTH\nPUTZZZ   DS    H                        RESERVED\nPUTMSG   DS    (MAXMSG)C                MESSAGE TEXT AREA\nPUTSIZE  EQU   *-PUTLDS                 SIZE OF PUTLINE PARMS\n         EJECT\n***********************************************************************\n*  SET UP LINKAGE\n***********************************************************************\n         SPACE 1\nEPUTL    CSECT\n         AIF  (NOT &XA).X001                                *HMD 10/85*\nEPUTL    AMODE 31\n.X001    ANOP                                               *HMD 10/85*\n         STM   14,12,12(13)       SAVE CALLERS REGS\n         LR    R12,R15            COPY EPA\n         USING EPUTL,R12          ADDRESSABILITY\n         AIF   (NOT &XA).X002                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE,        STANDARD OS SA PLUS ANY EXTRA        &\n               LOC=RES            RELATIVE TO 16MB LINE\n         AGO   .X003                                        *HMD 10/85*\n.X002    ANOP                                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE         STANDARD OS SA PLUS ANY EXTRA\n.X003    ANOP                                               *HMD 10/85*\n         ST    1,8(13)            OUR SAVE AREA POINTER\n         ST    13,4(1)            POINTER TO CALLERS SAVE AREA\n         LR    13,1               @OUR SAVE AREA\n         USING PUTLDS,R13         MAP SA AND WORK AREA\n         L     R14,4(R13)         POINT TO CALLERS RSA\n         LM    R0,R1,20(R14)      RESTORE REGS CHANGED BY GETMAIN\n         SPACE 2\n***********************************************************************\n*  UNLOAD ARGUMENTS AND VALIDATE WHERE POSSIBLE\n***********************************************************************\n         SPACE 1\n         LA    R15,RCBA                 ASSUME BAD ADDRESS\n         LTR   RMA,R1                   MESSAGE ADDRESS\n         BNP   RETURN                   GOOD ASSUMPTION\n         LA    R15,RCBL                 ASSUME BAD LENGTH\n         LTR   RML,R0                   POSITIVE?\n         BNP   RETURN                   -NO\n         C     RML,=A(MAXMSG)           MORE THAN MAX?\n         BH    RETURN                   -YES\n         SPACE 2\n***********************************************************************\n*  BUILD PARAMETER LIST\n***********************************************************************\n         SPACE 1\n         LA    R15,4(RML)               MESSAGE LENGTH\n         STH   R15,PUTLEN                 PLUS HEADER\n         XC    PUTZZZ,PUTZZZ            CLEAR 2ND HWORD OF RDW\n         BCTR  RML,0                    REDUCE FOR MOVE\n         EX    RML,PUTMOVE\n         EJECT\n***********************************************************************\n*  DIG UP ADDRESS OF UPT AND ECT\n***********************************************************************\n         SPACE 1\n         L     R2,PSATOLD-PSA           @TCB                   HD APR88\n         L     R2,TCBFSA-TCB(R2)        @1ST PROBLEM PGM SAVE AREA\n         L     R2,24(R2)                REG1 THAT WAS PASSED TO CP\n         USING CPPL,R2                  MAP CPPL\n         L     RUPT,CPPLUPT             @UPT\n         L     RECT,CPPLECT             @ECT\n         SPACE 2\n***********************************************************************\n*  ISSUE PUTLINE CALL\n***********************************************************************\n         SPACE 1\n         XC    PUTECB,PUTECB            CLEAR ECB\n         XC    PUTBLOK(12),PUTBLOK      CLEAR PARM BLOCK       HD APR88\n         PUTLINE PARM=PUTBLOK,          PARAMETER BLOCK                &\n               UPT=(RUPT),              @UPT                           &\n               ECT=(RECT),              @ECT                           &\n               ECB=PUTECB,              @ECB                           &\n               OUTPUT=(PUTLEN,TERM,SINGLE,DATA),                       &\n               MF=(E,PUTIOPL)\n         EJECT\n***********************************************************************\n*  RETURN TO CALLER\n***********************************************************************\n         SPACE 1\nRETURN   EQU   *\n         LR    2,R13                    @OUR SAVE AREA\n         LR    3,R15                    SAVE RETURN CODE\n         L     R13,4(R13)               @CALLERS SAVE AREA\n         FREEMAIN RU,LV=PUTSIZE,A=(R2),SP=0\n         LR    R15,3                    RESTORE RC\n         RETURN (14,12),RC=(15)         RESTORE CALLERS REGS\n         SPACE 5\n***********************************************************************\n*  CONSTANTS AND NON-REENTRANT WORK AREAS\n***********************************************************************\n         SPACE 1\nPUTMOVE  MVC   PUTMSG(*-*),0(RMA)       MOVE MESSAGE TO BUFFER\n         SPACE 2\n         LTORG\n         SPACE 2\n         END EPUTL\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "UKEYCSA$": {"ttr": 13318, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00\\t\\x01\\x07\"\\x7f\\x01\\x08\\x15?\\x19\\x06\\x00\\x1b\\x00\\x1c\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "2007-08-15T00:00:00", "modifydate": "2008-06-01T19:06:09", "lines": 27, "newlines": 28, "modlines": 0, "user": "IBMUSER"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD)\n//SYSLIB   DD DISP=SHR,DSN=SBGOLOB.S19.MACLIB\n//         DD DISP=SHR,DSN=SBGOLOB.S19.MODGEN\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(UKEYCSA)\n//SYSUT1   DD UNIT=SYSDA,SPACE=(CYL,20)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=SYSDA,SPACE=(TRK,30),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.W$$.LINKLIB,UNIT=SYSALLDA,VOL=SER=\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.W$$.LINKLIB,UNIT=SYSALLDA,VOL=SER=\n//SYSLIN   DD  DSN=&&TEMP,DISP=(OLD,PASS)\n//         DD  DDNAME=SYSIN\n//SYSIN    DD  *\n ENTRY   UKEYCSA\n SETCODE AC(1)\n NAME    UKEYCSA(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "UKEYCSA@": {"ttr": 13320, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x19\\x01\\x08\\x15_\\x01\\x19\\x04/\\x18\\x14\\x00\\x19\\x00\\x15\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2008-06-03T00:00:00", "modifydate": "2019-02-11T18:14:19", "lines": 25, "newlines": 21, "modlines": 0, "user": "SBGOLOB"}, "text": ")F FUNCTION -\n\n  The UKEYCSA command is an APF-Authorized TSO command\n  to change or list the global PARMLIB setting of\n\n     VSM ALLOWUSERKEYCSA(YES) or VSM ALLOWUSERKEYCSA(NO)\n\n  in the DIAGxx PARMLIB member.\n\n)X SYNTAX  -\n\n       UKEYCSA  N      (Do not allow a user to allocate Key 8 CSA)\n       UKEYCSA  Y      (Allow a user to allocate Key 8 CSA)\n       UKEYCSA  blank or anything else  (list current status and\n                                         don't change anything)\n\n)O OPERANDS -\n))N         -  (Do not allow a user to allocate Key 8 CSA)\n))Y         -  (Allow a user to allocate Key 8 CSA)\n\nNote.  This functionality is going away with z/OS 2.4.  The bit that\n       this program sets, will not work anymore after that time.\n       So the effective life of this program is from z/OS 1.8\n       thru z/OS 2.3.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT264/FILE264.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT264", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}