{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220013716000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 940576, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 21, "INMDSNAM": "CBT.V500.FILE990.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 940576, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 940576, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE990.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x11\\n'", "DS1TRBAL": "b'\\xa4('"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xd0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xd0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\n\\x81\\x00\\x07\\n\\x82\\x00\\t\\x00\\x12'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04c\\x00\\x06\\x01 \\x13_\\x01 \\x13_\\x11\\x11\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf9@@@'", "ispf": {"version": "04.99", "flags": 0, "createdate": "2020-05-14T00:00:00", "modifydate": "2020-05-14T11:11:06", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-499"}, "text": "REGULAR CBT TAPE - VERSION 499    FILE:  990\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT499.FILE990\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 91 MEMBERS COUNTED; CUMULATIVE SIZE IS 8,271 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   05/14/20    11:11:06    UTC-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$$VER": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00%\\x01 \\x02\\x8f\\x01 \\x03\\x1f\\t4\\x00\\x01\\x00\\x01\\x00\\x00\\xe5\\xc5\\xd9@@@@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2020-01-28T00:00:00", "modifydate": "2020-01-31T09:34:25", "lines": 1, "newlines": 1, "modlines": 0, "user": "VER"}, "text": "ISPF Developer Tips and Tricks version 1.7\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$README": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x00C\\x01\\x19\\x07O\\x01 \\x10?\\x12U\\x00}\\x00\\x0b\\x00\\x00\\xd9\\xc5\\xc1\\xc4\\xd4\\xc5@@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "2019-03-15T00:00:00", "modifydate": "2020-04-12T12:55:43", "lines": 125, "newlines": 11, "modlines": 0, "user": "README"}, "text": "This PDS contains the sample code that is referenced in the ISPF Tips\nand Tricks publication. Code snippets are not included here as the\nsnippets are short examples.\n\nAn ISPF dialog has been provided to simplify access to these examples.\n\nTo experiment with the samples:  Execute the $DEVISPF exec\n\nThere are 2 TSO Transmit (XMIT) format files must be received and\ninstalled to be used. These reside members of this PDS.  See member $$XMIT\nfor information on how to do this.\n\nTo experiment with these copy the REXX members into a library included in\nyour SYSEXEC (or SYSPROC) concatenation, and copy the Panel members into\na library in your ISPPLIB concatenation.\n\nDocumentation can be found at www.lbdsoftware.com where it is available in\nePUB, Mobi (Old Kindle), AZW3 (New Kindle) and PDF formats.\n\nMember naming convention:\n    $$   Informational members\n    $    Code use to drive the driver ISPF application\n    #    Members in TSO Transmit format\n    JC   JCL members\n    PN   Panel members\n    RX   Rexx members\n    CMT and LOADISPF are included as is\n    S    Sample members used by sample code\n\nMember types by ID:\n    Macro  REXX ISPF Edit Macros\n    Panel  ISPF Panels\n    Rexx   REXX Exec\n    Skel   ISPF Skeleton\n    Text   Something to read\n    XMIT   TSO Transmit format membetr\n    Sample Sample member used by sample code\n\nThe members of this PDS are:\n\nMember   Type    Description\n$$README Text    Overview of the Samples\n$$XMIT   Text    Doc on how to process the XMIT members\n$DEVCPY  Rexx    Exec using LMCOPY to copy Samples into User Libraries\n$DEVCPYP Panel   ISPF Prompt Panel for $DEVCPY\n$DEVISPF Rexx    Exec to display the Sample Members\n$DEVPH   Panel   ISPF Tutorial Panel for $DEVPP\n$DEVPP   Panel   ISPF Panel used by $DEVISPF\n$DEVPX   Panel   ISPF Popup Panel to Prompt for parms when executing Rexx\n#RXFORM  XMIT    #RXFORM  tool in TSO Transmit format\n#TRYIT   XMIT    #TRYIT tool in TSO Transmit format\nCMT      Macro   Rexx Edit Macro to insert Comments in Code/JCL/etc.\nJCBAT1   JCL     Sample ISPF in Batch JCL using the TASID Utility\nJCBAT2   JCL     Sample ISPF in Batch JCL using the RXLMD   Rexx\nLOADISPF Rexx    REXX code to be used with other code\nPNABC    Panel   Sample ISPF Panel to demonstrate an Action Bar\nPNAREA   Panel   ISPF Panel to demonstrate a scrolling Panel\nPNDYN    Panel   ISPF Panel demonstrating a dynamic area\nPNDYNTBL PANEL   ISPF Panel used by the RXDYNTBL - Dynamic Table Adds\nPNDYNTP  Panel   ISPF Panel used by RXDYNTBL to prompt for values\nPNEDITHL Panel   ISPF Panel demonstrating changing the data colors\nPNFLDH   Panel   ISPF Panel to demonstrate Field Level Help\nPNFLDH1  Panel   Sample Field Level Help panel\nPNFLDH2  Panel   Sample Field Level Help panel\nPNNUMC   Panel   ISPF Panel used by the RXNUMCE exec\nPNPNS    Panel   ISPF Panel to demonstrate Point-and-Shoot\nPNPOP    Panel   ISPF Panel to demonstrate ISPF Popup Panels\nPNPOPV   Panel   ISPF Panel to demonstrate ISPF Popup Panels with dynamic msgs\nPNPREXX  Panel   ISPF Panel to demonstrate Panel REXX\nPNPROG1  Panel   ISPF Panel used by RXPROG1\nPNPROG2  Panel   ISPF Panel used by RXPROG2\nPNSCRL   Panel   ISPF Panel to demonstrate a scrollable field\nPNTAB    Panel   ISPF Panel used by the RXTAB Exec and RXTABLE Exec\nPNVDSN   Panel   ISPF Panel to demonstrate Panel REXX to validate a Data Set\nRXABC    Rexx    Rexx code to drive the Action Bar Panel\nRXAREA   Rexx    Rexx Exec to drive RXAREAP\nRXCENTER Macro   Rexx Edit Macro to Center text and use a Range\nRXCMDS   Rexx    Exec to demonstrate File Tailoring\nRXDYN    Rexx    Rexx to demonstrate a dynamic ISPF Panel (PNDYN)\nRXDYNTBL Rexx    Rexx to demonstrate adding rows to a table when needed\nRXEDITHL Rexx    Rexx to demonstrate dyamic panel colors (PNEDITHL)\nRXEDMHL  Rexx    Rexx used by RXEDITHL to insert messages\nRXEM     Macro   Primary ISPF Edit macro for Alias Demonstration\nRXEMAC   Macro   ISPF Edit Macro\nRXEMACE  Rexx    Exec to demonstrate the ISPF Edit Macro use\nRXEME    Macro   Edit Macro to replace the ISPF Edit END command\nRXEMS    Macro   Edit Macro to replace the ISPF Edit SAVE command\nRXEMTRY  Rexx    Exec to demonstrate ISPF command Aliases\nRXFLD    Rexx    REXX code to drive PNFLDH\nRXIVAR   Rexx    Rexx to display the value of any ISPF variable\nRXLISPF  Rexx    Single Exec to demonstrate LOADISPF more fully\nRXLMD    Rexx    Rexx to demonstrate using LMDLIST service\nRXLMM    Rexx    Rexx to demonstrate using LMMLIST service\nRXMSG    Rexx    Exec to demonstrate ISPF Messages\nRXNOTEPD Rexx    Sample ISPF NotePad application\nRXNUMC   Rexx    Exec subroutine to convert numbers to human readable\nRXNUMCE  Rexx    Exec to demonstrate RXNUMC\nRXPNS    Rexx    Exec to drive PNPNS\nRXPNSL   Rexx    Single Exec using LOADISPF to demonstrate Point-and-Shoot\nRXPOP    Rexx    Exec to drive PNPOP\nRXPOPDO  Rexx    Exec to drive RXPOPM on all members of a data set\nRXPOPKEY Rexx    Exec to drive RXPOP and demonstrate turning PFSHOW Off\nRXPOPM   REXX    ISPF Edit Macro to report 'ideal' location for addpop\nRXPREXX  Rexx    Exec to drive PNPREXX\nRXPROG1  Rexx    Exec to demonstrate a progress popup\nRXPROG2  Rexx    Exec to demonstrate a progress popup meter\nRXRAND   Rexx    Exec to demonstrate various Random ddname techniques\nRXRVAR   Rexx    Rexx to display/evaluate any REXX expression\nRXSCRL   Rexx    Exec to display a panel with a scrollable field\nRXSKLCMD Rexx    Exec to Demonstrate File Tailoring (Skel)\nRXSKLRX  Rexx    Sample to demonstrate File Tailoring with REXX (Skel)\nRXSKLRXE Rexx    Exec to demonstrate File Tailoring (Skel)\nRXSKLRXV Rexx    Exec to demonstrate File Tailoring with variable (Skel)\nRXSTEM   Rexx    Exec to demonstrate how to browse data in a stem variable\nRXSTEME  Rexx    Exec to demonstrate how to STEMEDIT to browse a stem\nRXSTEMS  Rexx    Exec to demonstrate sorting a stem variable\nRXTAB    Rexx    Exec to demonstrate Table processing\nRXTABLE  Rexx    Exec to demonstrate Table processing (improved)\nRXTM     Rexx    Exec to demonstrate calling RXTSOMAC\nRXTSOMAC Rexx    Exec to demonstrate detecting call as TSO or Edit Macro\nRXVDSN   Rexx    Exec to drive RXVDSNP Panel\nSKCMD    Skel    Sample Skeleton for RXSKLCMD\nSKREXX   Skel    Sample Skeleton with REXX\nSKREXXE  Skel    Skeleton to demonstrate Skeleton REXX with Execio\nSKREXXV  Skel    Skeleton to demonstrate Skeleton REXX with variable\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$XMIT": {"ttr": 523, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x004\\x01\\x19\\x07O\\x01 \\x02o\\x18#\\x00\\r\\x00\\r\\x00\\x00\\xd9\\xc5\\xc1\\xc4\\xd4\\xc5@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2019-03-15T00:00:00", "modifydate": "2020-01-26T18:23:34", "lines": 13, "newlines": 13, "modlines": 0, "user": "README"}, "text": "The members in TSO Transmit (XMIT) format have a userid of XMIT for easy\nidentification.\n\nTo process these you need to use the TSO RECEIVE command:\n\n   RECEIVE INDS(XMIT.PDS(xmit-member))\n\nThen the 1st prompt is the data set name for the member to be processed into -\nthis will be a PDS.  The default may be adequate for you, if not then use a\nreply of the form DS(new.tool.pds).\n\nThen review the members in the newly created PDS for installation and use\ninstructions.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$DEVCPY": {"ttr": 525, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x000\\x01\\x19\\x08\\x8f\\x01\\x19\\x10\\x8f\\x14\\x03\\x00z\\x00\\x1c\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-03-29T00:00:00", "modifydate": "2019-04-18T14:03:30", "lines": 122, "newlines": 28, "modlines": 0, "user": "REXX"}, "text": "  /* --------------------  rexx procedure  -------------------- *\n  | Name:      $devcpy                                         |\n  |                                                            |\n  | Function:  Prompt for target Panel, REXX, and Skel libs    |\n  |            and then copy the sample members to their       |\n  |            respective locations.                           |\n  |                                                            |\n  | Syntax:    %devcopy                                        |\n  |                                                            |\n  | Usage Notes: Should be executed from a member list         |\n  |              of the devtips.pds library so that the        |\n  |              source library can be dynamically found.      |\n  |                                                            |\n  * ---------------------------------------------------------- */\n  parse source src\n  parse value '' with null panels rexx skels\n\n  /* ----------------------------------------------- *\n  | Get the source data set name either from        |\n  | word 5 of the source, or if that is unknown (?) |\n  | then using the ddname with listdsi to get it.   |\n  * ----------------------------------------------- */\n  devtdsn = word(src,5)\n  if strip(devtdsn) = '?' then\n  if word(src,4) = '?' then do\n    say 'bad'\n    exit\n  end\n  else do\n    x = listdsi(word(src,4) 'FILE')\n    devtdsn = sysdsname\n  end\n\n  /* ----------------------- *\n  | Libdef to this data set |\n  * ----------------------- */\n  Address ISPExec\n  \"Libdef ISPPLIB Dataset ID('\"devtdsn\"') Stack\"\n\n  do\n    'Addpop'\n    'Display Panel($devcpyp)'\n    drc = rc\n    'Rempop'\n  end\n  if drc > 0 then call done\n\n  dd = '$D'random(99999)\n  Address TSO\n  \"Alloc f(\"dd\") shr reuse ds('\"devtdsn\"($$readme)')\"\n  'Execio * diskr' dd '(finis stem in.'\n  'Free f('dd')'\n\n  /* ------------------ *\n  | Find Header Record |\n  * ------------------ */\n  do i = 1 to in.0\n    if word(in.i,1) = 'Member'\n    then if word(in.i,2) = 'Type'\n    then leave\n  end\n  /* ---------------------- *\n  | Process member records |\n  * ---------------------- */\n  do m = i+1 to in.0\n    parse value in.m with mem type .\n    type = translate(type)\n    if type = 'PANEL' then\n    panels = panels mem\n    if type = 'REXX' then\n    rexx = rexx mem\n    if type = 'MACRO' then\n    rexx = rexx mem\n    if type = 'SKEL' then\n    skels = skels mem\n  end\n\n  /* ----------------- *\n  | Now do the Copies |\n  * ----------------- */\n  Address ISPExec\n  \"lminit dataid(indd1) dataset('\"devtdsn\"')\"\n  \"lminit dataid(outdd1) dataset(\"pnldsn\")\"\n  do i = 1 to words(panels)\n    fm = word(panels,i)\n    prog = 'Copying Panel' fm\n    'Control Display Lock'\n    'Addpop'\n    'Display Panel(pnprog2)'\n    'Rempop'\n    \"lmcopy fromid(\"indd1\") todataid(\"outdd1\") frommem(\"fm\") replace\"\n  end\n  \"lmfree dataid(\"outdd1\")\"\n  \"lminit dataid(outdd1) dataset(\"rxdsn\")\"\n  do i = 1 to words(rexx)\n    fm = word(rexx,i)\n    prog = 'Copying Rexx' fm\n    'Control Display Lock'\n    'Addpop'\n    'Display Panel(pnprog2)'\n    'Rempop'\n    \"lmcopy fromid(\"indd1\") todataid(\"outdd1\") frommem(\"fm\") replace\"\n  end\n  \"lmfree dataid(\"outdd1\")\"\n  \"lminit dataid(outdd1) dataset(\"skdsn\")\"\n  do i = 1 to words(skels)\n    fm = word(skels,i)\n    prog = 'Copying Skels' fm\n    'Control Display Lock'\n    'Addpop'\n    'Display Panel(pnprog2)'\n    'Rempop'\n    \"lmcopy fromid(\"indd1\") todataid(\"outdd1\") frommem(\"fm\") replace\"\n  end\n  \"lmfree dataid(\"indd1\")\"\n  \"lmfree dataid(\"outdd1\")\"\n\n  /* ------------------------------------- *\n  | Finished for free the Libdef and exit |\n  * ------------------------------------- */\nDone:\n  'Libdef ISPPLIB'\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$DEVCPYP": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\"\\x01\\x19\\x08\\x8f\\x01\\x19\\x10\\x0f\\x08\\x00\\x002\\x00 \\x00\\x00\\xd7\\xc1\\xd5\\xc5\\xd3@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-03-29T00:00:00", "modifydate": "2019-04-10T08:00:22", "lines": 50, "newlines": 32, "modlines": 0, "user": "PANEL"}, "text": ")Attr DEFAULT(%+_)\n   /* ISPF - Developers - Tips and Tricks */\n  $ type(input) intens(low) hilite(uscore) caps(on)\n  @ type(output) intens(high)\n)Body expand(\\\\) window(68,10)\n+Copying from @devtdsn\n+\n+Enter the Target Data Set Names:\n+\n%Panel Library%===>$pnldsn                                        +\n%Rexx Library %===>$rxdsn                                         +\n%Skel Library %===>$skdsn                                         +\n+\n         +Enter all data sets and then Enter to continue,\n                 +or F3 to Cancel the operation.\n)INIT\n  &zwinttl = 'Copy Samples members to User Libraries'\n  &csr = &z\n)PROC\n*REXX(* pnldsn rxdsn skdsn zedsmsg zedlmsg csr)\n  zedsmsg = ''\n  zedlmsg = ''\n  csr = ''\n  if sysdsn(pnldsn) /= 'OK' then do\n     zedsmsg = 'Failure'\n     zedlmsg = pnldsn sysdsn(pnldsn)\n     csr = 'P'\n     end\n  if zedsmsg = '' then\n  if sysdsn(rxdsn) /= 'OK' then do\n     zedsmsg = 'Failure'\n     zedlmsg = rxdsn sysdsn(rxdsn)\n     csr = 'R'\n     end\n  if zedsmsg = '' then\n  if sysdsn(skdsn) /= 'OK' then do\n     zedsmsg = 'Failure'\n     zedlmsg = skdsn sysdsn(skdsn)\n     csr = 'S'\n     end\n*ENDREXX\n IF (&ZEDSMSG NE &Z)\n    .MSG = ISRZ001\n IF (&CSR EQ P)\n    .CURSOR = PNLDSN\n IF (&CSR EQ R)\n    .CURSOR = RXDSN\n IF (&CSR EQ S)\n    .CURSOR = SKDSN\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$DEVISPF": {"ttr": 530, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x009\\x01\\x19\\x07\\x9f\\x01\\x19\\x15o\\x06\\x08\\x01\\x02\\x00E\\x00\\x00[\\xd9\\xe4\\xd5\\xd4\\xc5[@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2019-03-20T00:00:00", "modifydate": "2019-06-05T06:08:39", "lines": 258, "newlines": 69, "modlines": 0, "user": "$RUNME$"}, "text": "  /*%NOcomment ----------  rexx procedure  -------------------- *\n  | Name:      $devispf                                        |\n  |                                                            |\n  |            ISPF - Developers - Tips and Tricks             |\n  |                                                            |\n  | Function:  Display the list of ISPF Developer Tips         |\n  |            and Tricks Examples                             |\n  |                                                            |\n  | Syntax:    %$devispf                                       |\n  |                                                            |\n  | History:  (most recent on top)                             |\n  |            04/02/19 - Add Tryit for Panels                 |\n  |            04/01/19 - Only Execute REXX members            |\n  |            03/29/19 - Make dynamic for the dsn             |\n  |                     - Change to $$README                   |\n  |            03/25/19 - Improve comemnts                     |\n  |            03/21/19 - Add Find and Locate                  |\n  |            03/20/19 - Creation                             |\n  |                                                            |\n  * ---------------------------------------------------------- */\n  parse source src\n  if word(src,5) = '?' then do\n     x = listdsi(word(src,4) 'FILE')\n     dev_tips_dsn = sysdsname\n     end\n  else dev_tips_dsn = word(src,5)\n  null = ''\n\n  /* ----------------------------------------- *\n  | Read in the $README Member for Table data |\n  * ----------------------------------------- */\n  dd = 'DD'random(99999)\n  \"Alloc f(\"dd\") shr reuse ds('\"dev_tips_dsn\"($$readme)')\"\n  'Execio * diskr 'dd '(finis stem in.'\n  'Free f('dd')'\n\n  /* ------------------------------------------------------ *\n  | Define the devtips pds as an alternate SYSEXEC library |\n  | and as an ISPPLIB (Panels)                             |\n  * ------------------------------------------------------ */\n  \"Altlib Act App(Exec) Dataset('\"dev_tips_dsn\"')\"\n  Address ISPExec\n  \"Libdef ISPPLIB Dataset ID('\"dev_tips_dsn\"') stack\"\n  \"Libdef ISPSLIB Dataset ID('\"dev_tips_dsn\"') stack\"\n\n  /* -------------------------------------------------------- *\n  | This enables RFIND which assumes that in one of the      |\n  | system command tables an entry for RFIND has been added  |\n  | with TRUNC of 0 and VERB of &USRRFIND. This allows an    |\n  | application to set the USRRFIND variable to PASSTHRU or  |\n  | to null. If PASTHRU then the application will see RFIND. |\n  * -------------------------------------------------------- */\n  usrrfind = 'PASSTHRU'\n  'vput (usrrfind) shared'\n\n  /* ---------------- *\n  | Create the Table |\n  * ---------------- */\n  'Control Errors Return'\nRefresh:\n  'TBCreate devtips names(dmem dtype ddesc) NoWrite'\n\n  /* ---------------------- *\n  | Now populate the table |\n  * ---------------------- */\n  hit = 0\n  do i = 1 to in.0\n    if hit = 0 then do\n      if word(in.i,1) /= 'Member' then iterate\n      if word(in.i,2) /= 'Type' then iterate\n      else do\n        hit = 1\n        iterate\n      end\n    end\n    if left(in.i,1) = ' ' then iterate\n    parse value in.i with dmem dtype ddesc\n    ddesc = strip(ddesc)\n    'TBAdd devtips'\n  end\n\n  /* ------------------- *\n  | Sort by Member Name |\n  * ------------------- */\n  'TBSort devtips Fields(dmem,C,A)'\n\n  /* --------------------------------------------- *\n  | Display the ISPF Table and process selections |\n  * --------------------------------------------- */\n  ztdtop = 1\n  ztdsels = 0\n  save_loc = 0\n  save_floc = 0\n  do forever\n    if ztdsels > 1 then do\n      'tbdispl devtips'\n    end\n    else do\n      'tbtop devtips'\n      'tbskip devtips number('ztdtop')'\n      'tbdispl devtips panel($devpp)'\n    end\n    if rc > 4 then leave\n    if zcmd /= null then\n    if zcmd = 'RFIND' then\n    zcmd = 'FIND' save_find\n    if zcmd /= null then\n    Select\n      When abbrev(\"FIND\",word(zcmd,1),1) = 1 then do\n        find = word(zcmd,2)\n        save_find = find\n        wrap   = 0\n        if save_floc > 0 then do\n          'tbtop devtips'\n          'tbskip devtips number('save_floc')'\n        end\n        do forever\n          'tbskip devtips'\n          if rc > 0 then do\n            'tbtop devtips'\n            'tbskip devtips'\n            if wrap = 1 then do\n              zedsmsg = 'Not Found'\n              zedlmsg = find 'string not found in any member' ,\n                'name. Try again.'\n              'setmsg msg(isrz001)'\n              leave\n            end\n            else wrap = 1\n          end\n          if pos(find,translate(dmem ddesc)) > 0 then do\n            'tbquery devtips position(row)'\n            ztdtop = row\n            save_floc = row\n            if wrap = 1 then do\n              zedsmsg = 'Wrapped'\n              zedlmsg = 'Find restarted at the top of the table.'\n              'setmsg msg(isrz001)'\n            end\n            leave\n          end\n        end\n      end\n      When abbrev(\"LOCATE\",word(zcmd,1),1) = 1 then do\n        locate = word(zcmd,2)\n        dmem = translate(word(zcmd,2))\n        'tbtop devtips'\n        ztdtop = 0\n        'tbsarg devtips'\n        'tbscan devtips arglist(dmem) position(scanrow) condlist(ge)'\n        if rc = 0 then do\n          ztdtop = scanrow\n          zedsmsg = 'Found'\n          zedlmsg = word(zcmd,2) 'was found in row' ztdtop\n          'Setmsg msg(isrz001)'\n        end\n        else do\n          zedsmsg = 'Not Found'\n          zedlmsg = word(zcmd,2) 'was not found'\n          'Setmsg msg(isrz001)'\n        end\n      end\n      When abbrev(\"ONLY\",word(zcmd,1),1) = 1 then do\n        'tbtop devtips'\n        'tbskip devtips'\n        string = subword(zcmd,2)\n        do forever\n          if pos(string,translate(dmem dtype ddesc)) = 0 then\n          'tbdelete devtips'\n          'tbskip devtips'\n          if rc > 0 then do\n            ztdtop = 1\n            leave\n          end\n        end\n      end\n      When abbrev(\"REFRESH\",word(zcmd,1),1) = 1 then do\n        'TBEnd devtips'\n        signal refresh\n      end\n      Otherwise do\n        zedsmsg = 'Unknown'\n        zedlmsg = zcmd 'is an unknown command - try again.'\n        'setmsg msg(isrz001)'\n      end\n    end\n    zcmd = null\n    if dsel /= null then do\n      'Control Display Save'\n      Select\n        When dsel = 'B' | dsel = 'S' then\n        \"Browse Dataset('\"dev_tips_dsn\"(\"dmem\")')\"\n        When dsel = 'E' then\n        \"Edit Dataset('\"dev_tips_dsn\"(\"dmem\")')\"\n        When dsel = 'R' then do\n          Address TSO\n          x = Prompt('on')\n          \"Receive inds('\"dev_tips_dsn\"(\"dmem\")')\"\n          Address ISPExec\n        end\n        When dsel = 'T' then do\n          if translate(dtype) /= 'PANEL' then do\n            zedsmsg = 'Error'\n            zedlmsg = 'Not able to TRYIT on a non-PANEL member.'\n            'Setmsg msg(isrz001)'\n          end\n          else do\n            x = testtry()\n            if x = 8 then\n            \"View Dataset('\"dev_tips_dsn\"(\"dmem\")') Macro(tryit)\"\n            else do\n              zedsmsg = 'Error'\n              zedlmsg = left('The TRYIT Edit Macro is not available.',75) ,\n                left('Receive and install it from the #TRYIT member of',75) ,\n                'this samples data set and then try it again.'\n              'Setmsg msg(isrz001)'\n            end\n          end\n        end\n        When dsel = 'X' then do\n          if translate(dtype) /= 'REXX' then do\n            zedsmsg = 'Error'\n            zedlmsg = 'Not able to execute a non-REXX member.'\n            'Setmsg msg(isrz001)'\n          end\n          else do\n            zxcmd = null\n            'Addpop'\n            'Display Panel($devpx)'\n            'Rempop'\n            Address TSO dmem zxcmd\n            zxcmd = null\n          end\n        end\n        Otherwise nop\n      end\n      'Control Display Restore'\n    end\n    dsel = null\n  end\n\n  /* ------------------------- *\n  | Done to clean up and exit |\n  * ------------------------- */\nDone:\n  'TBEnd devtips'\n  'Libdef ISPPLIB'\n  'Libdef ISPSLIB'\n  Address TSO 'Altlib Deact App(Exec)'\n  Exit\n\nTestTry:\n  Address TSO\n  call outtrap 't.'\n  '%tryit'\n  trc = rc\n  call outtrap 'off'\n  return trc\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$DEVPH": {"ttr": 771, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x16\\x01\\x19\\x07\\x9f\\x01\\x19\\t/\\x13\\x15\\x00\\x1f\\x00\\x13\\x00\\x00\\xd7\\xc1\\xd5\\xc5\\xd3@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-03-20T00:00:00", "modifydate": "2019-04-02T13:15:16", "lines": 31, "newlines": 19, "modlines": 0, "user": "PANEL"}, "text": ")Attr Default(%+_)\n   /* ISPF - Developers - Tips and Tricks */\n   ! type( input) intens(high) caps(on ) just(left ) hilite(uscore)\n   @ type(output) intens(low ) caps(off) just(asis )\n)Body  Expand(\\\\)\n%-\\-\\- ISPF Developer Tips/Tricks Tutorial -\\-\\-\n%Command ===>_zcmd\n%\n+ISPF Developer Tips and Tricks Sample Code Members:\n+\n%Commands:\n      %Find    +Find string in member/description\n      %Locate  +Locate member name\n      %Only    +Only display members with string xxx\n      %Refresh +Refresh the member list\n\n%Selection Options:\n      %B+       Browse selected member\n      %E+       Edit selected member\n      %R+       Receive the XMIT member\n      %T+       View the Panel using the TRYIT macro%*\n      %X+       eXecute the REXX member\n               +A popup will appear to solicit options for the exec\n+\n   %*+The TRYIT macro must be installed from the #XMIT sample member\n+\n)Init\n)Proc\n  &zup = $devph\n  &zcont = $devph\n)End\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$DEVPP": {"ttr": 773, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x14\\x01\\x19\\x07\\x9f\\x01\\x19\\t/\\x13\\x14\\x00\\x17\\x00\\x13\\x00\\x00\\xd7\\xc1\\xd5\\xc5\\xd3@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-03-20T00:00:00", "modifydate": "2019-04-02T13:14:14", "lines": 23, "newlines": 19, "modlines": 0, "user": "PANEL"}, "text": ")Attr Default(%+_)\n   /* ISPF - Developers - Tips and Tricks */\n   ! type( input) intens(high) caps(on ) just(left ) hilite(uscore)\n   @ type(output) intens(low ) caps(off) just(asis )\n)Body  Expand(\\\\)\n%-\\-\\- ISPF Developer Tips/Tricks Examples -\\-\\-\n%Command ===>_zcmd                                 \\ \\%Scroll ===>_amt +\n%\n+Commands:  %Find xx%Locate xx%Only xx %R+Refresh\n+Selections:%B+Browse%E+Edit%R+Receive%T+Tryit%X+eXecute\n+\n%Sel Member   Type  Description\n+\n)Model\n!z+ @z       @z    @z\n)Init\n  .ZVARS = '(dsel dmem dtype ddesc)'\n  &amt = CSR\n  .help = $devph\n)Reinit\n)Proc\n  ver (&dsel,list,B,E,R,X,S,C,T)\n)End\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$DEVPX": {"ttr": 775, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00B\\x01\\x19\\x07\\x9f\\x01\\x19\\x08\\x8f\\x105\\x00\\x1d\\x00\\x15\\x00\\x00\\xd7\\xc1\\xd5\\xc5\\xd3@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-03-20T00:00:00", "modifydate": "2019-03-29T10:35:42", "lines": 29, "newlines": 21, "modlines": 0, "user": "PANEL"}, "text": ")Attr Default(%+_)\n   /* ISPF - Developers - Tips and Tricks */\n $ Type(input) hilite(uscore) caps(off) just(left) intens(high)\n @ type(output)\n)Body window(70,9) expand(\\\\)\n+-\\-\\%ISPF Developer Tips Execute Prompt+\\-\\-\n%Command ===>_zcmd\n+\n+Enter the command arguments to be passed to the member:@dmem\n+\n%==>$zxcmd                                                         @z\n    @lr1sc\n+   (Scroll Left or Right for up to 255 characters)\n+\n)Init\n .cursor = zxcmd\n .zvars = '(scind)'\n vget (scrflag)\n*REXX(* scrflag zxcmd)\n if scrflag = 1 then\n zxcmd = 'Scroll left (F10), or right (F11) to view all of the' ,\n         'data on this scrolling line. Then F3 to exit.'\n*ENDREXX\n)Proc\nif (&zcmd = 'END')\n   &zxcmd = &Z\n)Field\n Field(zxcmd) ind(scind,'<>') len(255) scale(lr1sc)\n)End\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "#RXFORM": {"ttr": 777, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00'\\x01\\x19\\x07O\\x01\\x19\\x08\\x8f\\x06F\\x02\\x03\\x02\\x03\\x00\\x00\\xe7\\xd4\\xc9\\xe3@@@@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-03-15T00:00:00", "modifydate": "2019-03-29T06:46:27", "lines": 515, "newlines": 515, "modlines": 0, "user": "XMIT"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "#TRYIT": {"ttr": 1028, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x03\\x04\\x006\\x01\\x19\\x07O\\x01\\x19 ?\\x06%\\x05J\\x05!\\x00\\x00\\xe7\\xd4\\xc9\\xe3@@@@@@'", "ispf": {"version": "03.04", "flags": 0, "createdate": "2019-03-15T00:00:00", "modifydate": "2019-07-22T06:25:36", "lines": 1354, "newlines": 1313, "modlines": 0, "user": "XMIT"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "@FILE990": {"ttr": 1542, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04c\\x00Y\\x01 \\x13_\\x01 \\x13_\\x11\\x10\\x00s\\x00s\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf9@@@'", "ispf": {"version": "04.99", "flags": 0, "createdate": "2020-05-14T00:00:00", "modifydate": "2020-05-14T11:10:59", "lines": 115, "newlines": 115, "modlines": 0, "user": "CBT-499"}, "text": "//***FILE 990 is from Lionel Dyck, and contains a guide,            *   FILE 990\n//*           hopefully an expanding one, to help ISPF              *   FILE 990\n//*           developers with tricks and coding examples.           *   FILE 990\n//*                                                                 *   FILE 990\n//*           Version 1.7   -  May 13, 2020                         *   FILE 990\n//*                                                                 *   FILE 990\n//*           email:  lbdyck@gmail.com                              *   FILE 990\n//*                                                                 *   FILE 990\n//*           All of the documentation and this data can be         *   FILE 990\n//*           found and downloaded from www.lbdsoftware.com.        *   FILE 990\n//*                                                                 *   FILE 990\n//*           To help you out, we have RECEIVEd all the coding      *   FILE 990\n//*           examples into this pds, and we also uploaded          *   FILE 990\n//*           the .docx and .pdf formatted documents to here.       *   FILE 990\n//*                                                                 *   FILE 990\n//*           The documents in this pds are:                        *   FILE 990\n//*                                                                 *   FILE 990\n//*           DEVTIPS#  -  document in PDF format                   *   FILE 990\n//*           DEVTIPS@  -  document in MSWORD format                *   FILE 990\n//*                                                                 *   FILE 990\n//*           Enjoy......                                           *   FILE 990\n//*                                                                 *   FILE 990\n//*       NAME       VER.MOD   LAST MODIFIED     SIZE   ID          *   FILE 990\n//*       $$$#DATE    04.99   2020/05/14 11:10     12 CBT-499       *   FILE 990\n//*       $$$VER      01.07   2020/01/31 09:34      1 VER           *   FILE 990\n//*       $$README    01.13   2020/04/12 12:55    125 README        *   FILE 990\n//*       $$XMIT      01.02   2020/01/26 18:23     13 README        *   FILE 990\n//*       $DEVCPY     01.01   2019/04/18 14:03    122 REXX          *   FILE 990\n//*       $DEVCPYP    01.01   2019/04/10 08:00     50 PANEL         *   FILE 990\n//*       $DEVISPF    01.04   2019/06/05 06:08    258 $RUNME$       *   FILE 990\n//*       $DEVPH      01.01   2019/04/02 13:15     31 PANEL         *   FILE 990\n//*       $DEVPP      01.01   2019/04/02 13:14     23 PANEL         *   FILE 990\n//*       $DEVPX      01.01   2019/03/29 10:35     29 PANEL         *   FILE 990\n//*       #RXFORM     01.01   2019/03/29 06:46    515 XMIT          *   FILE 990\n//*       #TRYIT      03.04   2019/07/22 06:25   1354 XMIT          *   FILE 990\n//*       @FILE990    01.06   2020/01/28 16:24    106 CBT           *   FILE 990\n//*       CMT         01.01   2019/03/29 06:58   1287 REXX          *   FILE 990\n//*       DEVTIPS#    01.02   2020/05/13 09:47     21 PDF           *   FILE 990\n//*       DEVTIPS@    01.02   2020/05/13 09:47     12 DOCX          *   FILE 990\n//*       JCBAT1      01.01   2019/03/29 10:36     22 JCL           *   FILE 990\n//*       JCBAT2      01.01   2019/03/29 10:37     21 JCL           *   FILE 990\n//*       LOADISPF    01.01   2019/01/25 10:32    324 REXX          *   FILE 990\n//*       PNABC       01.01   2019/03/29 10:37     23 PANEL         *   FILE 990\n//*       PNAREA      01.01   2019/04/02 09:51    250 PANEL         *   FILE 990\n//*       PNDYN       01.01   2019/03/27 13:32     23 PANEL         *   FILE 990\n//*       PNDYNTBL    01.01   2020/04/11 08:47     16 PANEL         *   FILE 990\n//*       PNDYNTP     01.04   2020/04/12 12:53     21 PANEL         *   FILE 990\n//*       PNEDITHL    01.03   2019/12/26 13:41    137 PANEL         *   FILE 990\n//*       PNFLDH      01.01   2019/03/29 10:38     21 PANEL         *   FILE 990\n//*       PNFLDH1     01.01   2019/03/29 10:38     10 PANEL         *   FILE 990\n//*       PNFLDH2     01.01   2019/03/29 10:38     10 PANEL         *   FILE 990\n//*       PNNUMC      01.00   2019/10/07 10:05     17 PANEL         *   FILE 990\n//*       PNPNS       01.01   2019/03/29 10:38     38 PANEL         *   FILE 990\n//*       PNPOP       01.01   2019/03/29 10:38     16 PANEL         *   FILE 990\n//*       PNPOPV      01.02   2019/10/22 10:34     13 PANEL         *   FILE 990\n//*       PNPREXX     01.06   2020/01/31 09:33     47 PANEL         *   FILE 990\n//*       PNPROG1     01.01   2019/03/29 10:39     12 PANEL         *   FILE 990\n//*       PNPROG2     01.01   2019/03/29 10:39     11 PANEL         *   FILE 990\n//*       PNSCRL      01.01   2019/03/29 10:39     22 PANEL         *   FILE 990\n//*       PNTAB       01.02   2019/11/04 07:13     37 PANEL         *   FILE 990\n//*       PNVDSN      01.05   2020/04/12 14:50     30 PANEL         *   FILE 990\n//*       RXABC       01.01   2019/04/01 14:25     12 REXX          *   FILE 990\n//*       RXAREA      01.01   2019/03/29 10:41      9 REXX          *   FILE 990\n//*       RXCENTER    01.01   2019/03/29 10:42     49 REXX          *   FILE 990\n//*       RXCMDS      01.01   2019/04/10 07:15     13 REXX          *   FILE 990\n//*       RXDOALL     01.02   2019/07/22 10:27     55 REXX          *   FILE 990\n//*       RXDYN       01.01   2019/04/01 12:47     51 REXX          *   FILE 990\n//*       RXDYNTBL    01.14   2020/04/12 12:59    191 REXX          *   FILE 990\n//*       RXEDITHL    01.03   2019/12/26 13:20     10 REXX          *   FILE 990\n//*       RXEM        01.01   2019/04/17 09:13     29 MACRO         *   FILE 990\n//*       RXEMAC      01.01   2019/03/29 10:43     18 REXX          *   FILE 990\n//*       RXEMACE     01.01   2019/03/29 10:43     41 REXX          *   FILE 990\n//*       RXEME       01.01   2019/04/08 12:01     24 MACRO         *   FILE 990\n//*       RXEMS       01.01   2019/04/08 12:00     22 MACRO         *   FILE 990\n//*       RXEMTRY     01.01   2019/04/08 12:03     12 REXX          *   FILE 990\n//*       RXFLD       01.01   2019/03/29 10:43     10 REXX          *   FILE 990\n//*       RXIVAR      01.00   2019/05/06 07:15     10 REXX          *   FILE 990\n//*       RXLISPF     01.01   2019/10/23 06:29    433 REXX          *   FILE 990\n//*       RXLMD       01.01   2019/03/29 10:43     58 REXX          *   FILE 990\n//*       RXLMM       01.01   2019/03/29 10:44     72 REXX          *   FILE 990\n//*       RXMEDHL     01.00   2019/12/26 10:59     17 REXX          *   FILE 990\n//*       RXMSG       01.01   2019/03/29 10:45     15 REXX          *   FILE 990\n//*       RXNOTEPD    01.01   2020/04/13 09:54     82 REXX          *   FILE 990\n//*       RXNUMC      01.00   2019/10/07 09:34     18 REXX          *   FILE 990\n//*       RXNUMCE     01.02   2019/10/07 10:10     13 REXX          *   FILE 990\n//*       RXPNS       01.01   2019/03/29 10:45     30 REXX          *   FILE 990\n//*       RXPNSL      01.01   2019/03/29 10:46    402 REXX          *   FILE 990\n//*       RXPOP       01.02   2019/04/23 06:18      9 REXX          *   FILE 990\n//*       RXPOPDO     01.01   2019/04/03 07:11     82 REXX          *   FILE 990\n//*       RXPOPKEY    01.07   2019/10/22 10:40     37 REXX          *   FILE 990\n//*       RXPOPM      01.01   2019/04/03 07:06     72 MACRO         *   FILE 990\n//*       RXPREXX     01.01   2019/03/29 10:46     26 REXX          *   FILE 990\n//*       RXPROG1     01.01   2019/03/29 10:47     15 REXX          *   FILE 990\n//*       RXPROG2     01.01   2019/03/29 10:47     46 REXX          *   FILE 990\n//*       RXRAND      01.02   2019/05/03 08:17     26 REXX          *   FILE 990\n//*       RXRVAR      01.00   2019/05/06 07:16      6 REXX          *   FILE 990\n//*       RXSCRL      01.01   2019/03/29 10:47     13 REXX          *   FILE 990\n//*       RXSKLCMD    01.01   2019/04/16 10:03     11 REXX          *   FILE 990\n//*       RXSKLRX     01.02   2019/04/23 09:37      9 REXX          *   FILE 990\n//*       RXSKLRXE    01.03   2019/05/02 08:45      9 REXX          *   FILE 990\n//*       RXSKLRXV    01.05   2019/09/27 16:48     10 REXX          *   FILE 990\n//*       RXSTEM      01.01   2019/03/29 10:48     36 REXX          *   FILE 990\n//*       RXSTEME     01.01   2019/03/29 10:48     12 REXX          *   FILE 990\n//*       RXSTEMS     01.00   2019/05/07 09:39     22 REXX          *   FILE 990\n//*       RXTAB       01.13   2020/01/25 10:39    427 REXX          *   FILE 990\n//*       RXTABLE     01.08   2020/05/04 07:27    434 REXX          *   FILE 990\n//*       RXTM        01.05   2020/04/01 09:33     21 REXX          *   FILE 990\n//*       RXTSOMAC    01.12   2020/04/02 04:27     26 REXX          *   FILE 990\n//*       RXVDSN      01.01   2019/03/29 10:49     15 REXX          *   FILE 990\n//*       SAMPGIT     01.03   2019/12/26 13:44     39 SAMPLE        *   FILE 990\n//*       SKCMDS      01.01   2019/04/16 09:54     12 SKEL          *   FILE 990\n//*       SKREXX      01.00   2019/04/23 09:36     28 SKEL          *   FILE 990\n//*       SKREXXE     01.01   2019/05/02 08:46     25 SKEL          *   FILE 990\n//*       SKREXXV     01.00   2019/09/27 16:42     18 SKEL          *   FILE 990\n//*                                                                 *   FILE 990\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CMT": {"ttr": 1545, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00%\\x01\\x19\\x07\\x8f\\x01\\x19\\x08\\x8f\\x06X\\x05\\x07\\x05\\x07\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-03-19T00:00:00", "modifydate": "2019-03-29T06:58:25", "lines": 1287, "newlines": 1287, "modlines": 0, "user": "REXX"}, "text": "/* --------------------  rexx procedure  ------------------------- *\n * Name:      CMT                         Version 3.5    09/16/16  */\n                                          vernbr=\"3.5\"\n/*                                                                 *\n * Function:  Create a documentation 'box' within the object       *\n *            being edited. The syntax of the comment box          *\n *            is based on the object type which is determined by   *\n *            this REXX or set by the user via the popup panel.    *\n *                                                                 *\n * Syntax1:   Entered on Command line to add comments.             *\n *            CMT I,B,text          (all parameters are optional)  *\n *                                  (and must be separated by a ,) *\n *            I = nbr 1-65, C (Center) or R (Right justify)        *\n *                The number of spaces to Indent added text box    *\n *                or if text should be Centered or Right justified.*\n *                (Default is 0)                                   *\n *            B = V,S,F or blank  (BOXSIZE)                        *\n *                V = uses a Variable box based on longest line    *\n *                F = uses a Fixed box size (70 characters long)   *\n *                S = same as F (Fixed) S = a Set size             *\n *                (See Syntax2 for means to set defaults)          *\n *            Text = optional one line of text to include.         *\n *                (Default displays a popup panel for text entry)  *\n *                (and allows an unlimited number of lines.)       *\n *                                                                 *\n * Syntax2:   Entered on Command line to set/change default values *\n *            CMT SET <parm to set> <parm value>                   *\n *                                                                 *\n *            parm to set: INDENT  or abbrev of (set indent value) *\n *                       : BOXSIZE or abbrev of (set box size)     *\n *                       : CHARIZE or abbrev of (set boxing char)  *\n *            parm value : for INDEND either 1 - 65, C or R        *\n *                         for BOXSIZE either F,S or V             *\n *                       : for CHARIZE any character is valid      *\n *                                                                 *\n * Syntax3:   Entered as Line Command (see NOTE below)             *\n *            CMT        (all parameters default, panel displayed) *\n *                                                                 *\n *            NOTE: A line command macro is required to utilize    *\n *            syntax option 3. LINEMAC is include in this package  *\n *            but requires the use of Doug Nagel's LMAC or UMAC.   *\n *            Please see http://www.mindspring.com/~somebody/      *\n *            \"A few ISPF or OS/390 tools and toys\" for a complete *\n *            desciption of how to use and setup either LMAC or    *\n *            UMAC so the LINEMAC macro may be called to process   *\n *            user defined line commands.                          *\n *                                                                 *\n * Author:    Lionel B. Dyck                                       *\n *            Internet: lbdyck@gmail.com                           *\n *                                                                 *\n * Additions: Bill George                                          *\n *            Internet: billgeo@bigfoot.com                        *\n *                                                                 *\n * History:                                                        *\n *            09/16/16 - Change REXX comment char to |             *\n *            Ver 3.5    Lionel B. Dyck                            *\n *                                                                 *\n *            06/14/16 - Add Comment support for Shell Scripts     *\n *            Ver 3.4    Lionel B. Dyck                            *\n *                                                                 *\n *            09/09/13 - Add Comment support for ISPF Skeletons    *\n *            Ver 3.3    Lionel B. Dyck                            *\n *                                                                 *\n *            06/20/07 - Expand width of comments thanks to        *\n *            Ver 3.2    Bill Lambert                              *\n *                                                                 *\n *            06/22/06 - Add support for PLI thanks to             *\n *            Ver 3.1    Hans Geiser                               *\n *                     - Fix undefined variable when using on new  *\n *                       (empty) member                            *\n *                     - Correction for SAS and PLI usage for Var  *\n *                       size comment boxes                        *\n *                                                                 *\n *            01/16/06 - Updated doc and help to indicate that a   *\n *            Ver 3.0    target line must be specified.            *\n *                                                                 *\n *            01/24/03 - Updated to deal with a COBOL profile      *\n *            Ver 2.9    of NUMERS ON COBOL                        *\n *            BG       - changed method of producing in-line       *\n *                       panels. Less error prone method.          *\n *                                                                 *\n *            02/17/01 - Update to check for data type.            *\n *            Ver 2.8  - check for EXEC, CNTL, SAS, and ASM        *\n *            LBD      - Added test for filename                   *\n *                                                                 *\n *            01/30/01 - Updated help for the CMT command.         *\n *            Ver 2.7  - Added   help for the CMT panel.           *\n *            BG       - Added FIXLEN parm. It controls the size   *\n *                       of a Fixed length box. It defaults to 57  *\n *                       and has a max of 60. It may be set via    *\n *                       the panel or CMT SET F # command.         *\n *                                                                 *\n *            01/29/01 - Updated panel to show Fixed option.       *\n *            Ver 2.6    Updated error message if no destination   *\n *            BG         was set to indicate help is available via *\n *                       the CMT HELP command.                     *\n *                                                                 *\n *            01/25/01 - Added F (Fixed) as valid BOXSIZE parm.    *\n *            Ver 2.5    Works same as S, might be more intuitive. *\n *            BG         Updated HELP accordingly.                 *\n *                     - Added C (CENTER) and R (Right Justify)    *\n *                       as valid INDENT parameters.               *\n *                       These comment box placements are calc'ed  *\n *                       off the object's RIGHT BOUNDS setting.    *\n *                     - Added INDENT prompt to panel.             *\n *                     - Added Version number to panel.            *\n *                     - Move the panel definition in-line.        *\n *                       (member CMTPANEL not required now)        *\n *                     - Fixed bug that displayed the Version nbr  *\n *                       When CMT V (variable boxsize) entered.    *\n *                     - Fix bug that didn't set the BOXSIZE parm  *\n *                       correctly in the panel if BOXSIZE sent    *\n *                       with command.  ie, CMT 5,V                *\n *                                                                 *\n *            01/17/01 - Fixed bug in CANCEL process.              *\n *            Ver 2.4  - Added code to allow parms in any order    *\n *            BG       - Adjusted order of some object type tests  *\n *                     - Fixed bug in check for special functions  *\n *                       chgd Pos(functn_ck.. to Wordpos(functn_ck *\n *                     - Added code to add an empty box with one   *\n *                       line if PF3 entered with no text entered. *\n *                     - Added error msg for invalid INDENT value. *\n *                     - Added logic to allow for debugging.       *\n *                     - Added ability to change box outlining char*\n *                       CMT SET CHARBOX (or C) to change default. *\n *                     - Added boxing character and BOXSIZE parms  *\n *                       to the panel for user changing.           *\n *                     - Updated some doco typos and added some    *\n *                       comments on use of LINEMAC macro included *\n *                                                                 *\n *            01/16/01 - Moved Doug Nadel's Linemac into this code *\n *            01/11/01 - Added SAS as an option.                   *\n *            01/08/01 - Added flexibility to create comments in   *\n *                       he proper syntax for different object     *\n *                       types. CLIST,REXX,C,COBOL,DOC,ASM,PANELS  *\n *                     - Added additional box type via a new parm. *\n *                     - Added logic to store default values for   *\n *                       the INDENT and BOXSIZE parms via the      *\n *                       CMT SET <parms> function.                 *\n *                     - Added code to function with Doug Nagel's  *\n *                       LINEMAC line command function so CMT may  *\n *                       be entered as a line command.             *\n *                     - Added a HELP function.                    *\n *                     - Added a VERSION function.                 *\n *            01/03/01 - Convert to use table                      *\n *            12/22/00 - Added. for blank lines in popup           *\n *            12/22/00 - Added # for indent                        *\n *            12/22/00 - Creation                                  *\n * --------------------------------------------------------------- */\n  Address Isredit\n \"MACRO (TEXT) NOPROCESS\"\n  Address Ispexec \"Control Errors Return\"\n /* ----------------------------- *\n  * Check for a debugging request *\n  * ----------------------------- */\n  Parse Var text text '<<' TraceVal\n  if TraceVal > '' then x = Trace(TraceVal)\n  text = Strip(text)\n\n /* -------------------- *\n  * Init Some Variables  *\n  * -------------------- */\n  Parse Value \"\" with null cmt_suf indent boxsize ddname\n  cmt_last = \"*\"\n  valid_box_values = \"F S V\"\n  Panels_Created = 0\n  x_rc = 0\n\n /* --------------------------------------------------------- *\n  * Save the display position so it may be restored when done *\n  * as subsequent processing may do havoc to its position.    *\n  * --------------------------------------------------------- */\n  top = null\n '(top,bot) = DISPLAY_LINES'\n  \"LABEL\" top \"= .SAV 0\"\n \"(holdrow,holdcol) = CURSOR\"                /* save cursor position */\n if top = null then top = 1\n\n /* --------------------------------- *\n  * Check/Arrange entered parameters. *\n  * Process special command if found. *\n  * --------------------------------- */\n  if Length(text) > 0 then do\n     Parse Value text with indent \",\" boxsize \",\" text2\n     Parse Upper VAR indent functn_ck .\n\n    /* -------------------------------------- *\n     * Process special commands.              *\n     * CMT ends if special command processed. *\n     * -------------------------------------- */\n     if functn_ck = \"SET\" then do\n        Call Set_CMT_Default\n        Signal Exit_Macro\n     end\n\n     if Abbrev(\"HELP\",functn_ck,1),\n     |  functn_ck =  \"?\" then do\n        Call Get_Help\n        Signal Exit_Macro\n     end\n\n     if Abbrev(\"VERSION\",functn_ck,2) then do\n        zedsmsg = \"CMT Version\" vernbr\n        zedLmsg = \"CMT Version\" vernbr\n        Address Ispexec \"Setmsg Msg(isrz000)\"\n        Signal Exit_Macro\n     end\n\n    /* ---------------------------------------- *\n     * Arrange parameters into processing order *\n     * of indent,boxsize,test                   *\n     * ---------------------------------------- */\n     Call Arrange_Parameters\n\n     end\n  else\n   /* ----------------------------------------- *\n    * No parameters entered, use default values *\n    * ----------------------------------------- */\n     Call Get_Default_Values\n\n /* ------------------------------------ *\n  * Use defaults for any null parameters *\n  * ------------------------------------ */\n  if indent  = null then indent  = cmtdfInd\n  if boxsize = null then boxsize = cmtdfBox\n  Upper boxsize\n\n /* ------------------------------*\n  * Test for a valid INDENT value *\n  * ------------------------------*/\n  if Datatype(indent) = \"NUM\",\n  &  indent > 65 then do\n     zedsmsg = null\n     zedlmsg = Left(\"ERROR: INDENT value,\" indent \"invalid.\",81),\n             \"Must be between 0 - 65,  C=Center or  R=Right Justify\"\n     Address Ispexec \"Setmsg Msg(isrz000)\"\n     x_rc = 8\n     Signal Exit_Macro\n  end\n\n /* --------------------------------- *\n  * Test for a target destination set *\n  * via an \"A\" or \"B\" line command.   *\n  * --------------------------------- */\n \"PROCESS DEST\"\n  dest_rc = rc\n\n  if dest_rc = 0 then\n    \"(DEST) = LINENUM .ZDEST\"\n\n  else do\n    /* ---------------------------------------------------- *\n     * \"A\" or \"B\" line destination not found, check if      *\n     * called via LINEMAC, (\"PROCESS DEST\" gets a non 0 rc) *\n     * look for a .CMT line LABEL set in LINEMAC.           *\n     * ---------------------------------------------------- */\n    \"Locate .CMT\"\n\n     if rc = 0 then do\n      /* ------------------------------ *\n       * Set the target destination and *\n       * RESET LABEL set in LINEMAC     *\n       * ------------------------------ */\n      \"(DEST) = LINENUM .ZCSR\"\n      \"Reset label\" DEST-1 DEST+1\n       end\n     else do\n        zedsmsg = \"\"\n        zedlmsg =,\n           Left(\"A destination line must be specified, try again.\",81),\n           Left(\"Use an A(After) or B(Before) on a line in your data.\",\n                 ,81),\n                \"For help, enter CMT HELP\"\n        Address Ispexec \"Setmsg Msg(ISRZ001)\"\n        x_rc = 8\n        Signal Exit_Macro\n     end\n  end\n\n  Call Determine_Object_Type\n\n /* ---------------------------------------------------------- *\n  * Send message if object type is not valid for indentation.  *\n  * NOTE: ASM & JCL require chars in column 1 but if an indent *\n  *       value is input, another '*' is placed at the indent  *\n  *       position to start an indented box at that point.     *\n  * ---------------------------------------------------------- */\n  if Pos(mbr_type,\"COBOL\") > 0,\n  &  indent > 0 then do\n     zedsmsg = \"\"\n     zedlmsg = \"Indentation parm of,\" indent,\n               \"is not valid for this mbr type\"\n     Address Ispexec \"Setmsg Msg(isrz000)\"\n  end\n\n /* ------------------------ *\n  * if no TEXT entered then  *\n  * display the popup panel. *\n  * ------------------------ */\n  if Length(text) = 0 then Call Process_Via_Panel\n\n /* ---------------------------------------------------- *\n  * else just add the provided line - (No panel input)   *\n  * ---------------------------------------------------- */\n  else do\n     boxlen = Length(text)\n     Call Setup_Member_Type_Parameters\n     Call do_box first_line\n     Call do_line text\n  end\n\n /* ----------------------------------------- *\n  * Put out the last line of the comment box. *\n  * ----------------------------------------- */\n  Call do_box last_line\n\nExit_Macro:\n\n \"locate .sav\"\n \"(dest) = linenum .ZCSR\"\n \"reset label\" top-1 top+1\n \"cursor = (holdrow,holdcol)\"               /* restore cursor postn */\n /* ------------------------------------- *\n  * Deallocate panel's temporary library. *\n  * ------------------------------------- */\n  if ddname \\= null then do\n     Address Ispexec \"Libdef ispplib\"\n     Address Tso \"Free f(\"ddname\")\"\n  end\n\nExit x_rc\n\n             /*-------------------------------            /* Ge150606 */\n                C A L L E D   R O U T I N E S\n               -------------------------------*/          /* Ge150606 */\n\n/*===========================================================*\n* Routine: Process_Via_Panel:                                *\n*   Display a popup panel for the user to input comments.    *\n*   Process the comments and/or commands enntered.           *\n*===========================================================*/\nProcess_Via_Panel:\n\n   Call Create_Panels\n\n  /* ---------------------- *\n   * Create the ISPF Table  *\n   * and prefill in 150 rows*\n   * ---------------------- */\n   Address Ispexec\n  \"Tbcreate cmt Names(rxline)\"\n   rxline = null\n\n   do i = 1 to 150\n     \"Tbadd cmt\"\n   end\n  \"Tbtop cmt\"\n  \"Addpop\"\n\n  /* ---------------------- *\n   * Now display the table  *\n   * ---------------------- */\n   trc = 0\n   cmt_suf = null\n   do until trc > 4\n     \"Tbdispl cmt Panel(cmtpanel)\"\n      trc = rc\n\n     /* ---------------- *\n      * Test for Cancel  *\n      * ---------------- */\n      if Abbrev(\"CANCEL\",zcmd,1) then do\n        \"Tbend cmt\"\n         Signal Exit_Macro\n      end\n\n     /* ---------------- *\n      * Test for Insert  *\n      * ---------------- */\n      if Abbrev(\"INSERT\",WORD(zcmd,1),1) = 1 then do\n         Parse Value zcmd with x count\n         zcmd   = null\n         rxline = null\n        \"Tbbottom cmt\"\n         do i = 1 to count\n           \"Tbadd cmt\"\n         end\n        \"Tbtop cmt\"\n        \"Tbskip cmt number(\"ztdtop\")\"\n      end\n\n     /* ----------------------------------------------- *\n      * if user requests to use parameters as defaults, *\n      * store the default values in the PROFILE pool.   *\n      * ----------------------------------------------- */\n      if Translate(setdflt) = \"Y\" then do\n         cmtdfInd = indent\n         cmtdfBox = boxsize\n        \"Vput (cmtdfInd cmtdfBox cmtdfChr cmtdfFix) profile\"\n      end\n\n     /* ------------------------------ *\n      * Process multiple rows of text  *\n      * ------------------------------ */\n     \"Tbput cmt\"\n      do i = 1 to ztdsels-1\n        \"Tbdispl cmt\"\n        \"Tbput cmt\"\n      end\n   end\n\n  /* ------------------------------------------------------ *\n   * end of Table Display                                   *\n   * Remove popup and go to top of table.                   *\n   * Check if the member type has been changed by the user. *\n   * ------------------------------------------------------ */\n  \"Rempop\"\n  \"Tbtop cmt\"\n\n   if MbrType /= mbr_type then do\n      mbr_type = MbrType\n      boxlen = Length(text)\n      Call Setup_Member_Type_Parameters\n   end\n\n  /* --------------------------------------------------------- *\n   * Process all entered rows of information by loading a      *\n   * REXX STEM variable with the text lines and checking for   *\n   * the longest line as we go incase a Variable box required. *\n   * --------------------------------------------------------- */\n   cmts. = null\n   Parse Value '0' WITH 1 cnt 1 boxlen 1 blank_cnt\n\n   Do Forever\n     \"Tbskip cmt\"\n      if rc > 0 then Leave\n\n     /* ----------------------------------------------------- *\n      * if text found on line, check if its the longest line. *\n      * Start the blank line count over.                      *\n      * ----------------------------------------------------- */\n      if Length(rxline) > 0 then do\n         len = Length(rxline)\n         if len > boxlen then boxlen = len\n         blank_cnt = 0\n         end\n      else do\n\n        /* ------------------------------------------------------ *\n         * Leave if we have found the 2nd consecutive blank line. *\n         * ------------------------------------------------------ */\n         blank_cnt = blank_cnt + 1\n         if blank_cnt > 1 then do\n            cnt = cnt - 1\n            Leave\n         end\n      end\n     /* --------------------- *\n      * Save the comment text *\n      * --------------------- */\n      cnt = cnt + 1\n      cmts.cnt = rxline\n   end\n\n   if cnt = 0    then cnt = 1\n   if boxlen = 0 then boxlen = 55\n\n  /* -------------------- *\n   * Close out the table  *\n   * -------------------- */\n  \"Tbend cmt\"\n\n  /* ---------------------------------- *\n   * Write out the comment box.         *\n   * Last boarder line for box written  *\n   * out upon RETURN from this routine. *\n   * ---------------------------------- */\n   Address Isredit\n   Call Setup_Member_Type_Parameters\n   Call do_box first_line\n\n   do i = 1 to cnt\n      Call do_line cmts.i\n   end\n\nReturn\n\n/*===========================================================*\n* Routine: Do_Line:                                          *\n* This routine sets up the comment line between * and        *\n* then inserts it into the code.                             *\n*===========================================================*/\nDo_Line:\n\n  Parse Arg data\n  if data = \".\" then data = \" \"\n  data = indent_spc || cmt_chars Left(data,boxlen) cmt_last\"\"cmt_suf\n \"Line_After\" dest \"= (data)\"\n  dest = dest + 1\n\nReturn\n\n/*===========================================================*\n* Routine: Do_Box:                                           *\n* Do_Box Routine is called to output the first and last      *\n* lines of the comment box.                                  *\n*===========================================================*/\nDo_Box:\n  Parse Arg data\n \"Line_After\" dest \"= (data)\"\n  dest = dest + 1\nReturn\n\n/*===========================================================*\n* Routine: Determine_Object_Type:                            *\n*   Determine the type of member being edited                *\n*   so the proper comment syntax may be used.                *\n*============================================================*/\nDetermine_Object_Type:\n\n  mbr_type = null\n /* ----------------------------------------------- *\n  * Check if the member type can be determined from *\n  * the data found in the first line of the member. *\n  * if determined, Exit the routine.                *\n  * ----------------------------------------------- */\n '(line1) = LINE 1'\n  Upper Line1\n  Select\n     When Left(line1,2) = '//'       then mbr_type = 'JCL'\n     When Left(line1,1) = '#'        then mbr_type = 'SHELL'\n     When Wordpos('REXX',line1) > 0  then mbr_type = 'REXX'\n     Otherwise Nop\n  end\n\n  if mbr_type /= null then Signal Type_Exit\n\n /* -------------------------- *\n  * Ad hoc CLIST/PANEL checks  *\n  * -------------------------- */\n \"Find first X'50E2E3D9'\"                          /* &STR(    */\n  if rc = 0 then do\n     mbr_type = 'CLIST'\n     Signal Type_Exit\n  end\n\n \"Find first X'50E2E4C2E2E3D94D'\"                  /* &Substr( */\n  if rc = 0 then do\n     mbr_type = 'CLIST'\n     Signal Type_Exit\n  end\n\n \"Find first X'50D3C1E2E3C3C3'\"                    /* &LASTCC  */\n  if rc = 0 then do\n     mbr_type = 'CLIST'\n     Signal Type_Exit\n  end\n\n \"Find first ')ATTR '\"\n  if rc = 0 then do\n     mbr_type = 'PANEL'\n     Signal Type_Exit\n  end\n\n /* ------------------ *\n  * Ad hoc ASM checks  *\n  * ------------------ */\n \"Find first 'DSECT ' 10 20\"\n  if rc = 0 then do\n     mbr_type = 'ASM'\n     Signal Type_Exit\n  end\n\n \"Find first 'DS  ' 10\"\n  if rc = 0 then do\n     mbr_type = 'ASM'\n     Signal Type_Exit\n  end\n\n \"Find first 'MVC  ' 10\"\n  if rc = 0 then do\n     mbr_type = 'ASM'\n     Signal Type_Exit\n  end\n\n /* ------------------- *\n  * Ad hoc REXX checks  *\n  * ------------------- */\n \"Find first 'Wordpos('\"\n  if rc = 0 then do\n     mbr_type = 'REXX'\n     Signal Type_Exit\n  end\n\n \"Find first ' Parse v'\"\n  if rc = 0 then do\n     mbr_type = 'REXX'\n     Signal Type_Exit\n  end\n\n \"Find first ' Parse u'\"\n  if rc = 0 then do\n     mbr_type = 'REXX'\n     Signal Type_Exit\n  end\n\n \"Find first ' address i'\"\n  if rc = 0 then do\n     mbr_type = 'REXX'\n     Signal Type_Exit\n  end\n\n \"Find first ' address t'\"\n  if rc = 0 then do\n     mbr_type = 'REXX'\n     Signal Type_Exit\n  end\n\n /* ------------------- *\n  * Ad hoc COBOL checks *\n  * ------------------- */\n \"Find first 'IDENTIFICATION DIVISION.' 8\"\n  if rc = 0 then do\n     mbr_type = 'COBOL'\n     Signal Type_Exit\n  end\n\n \"Find first ' 01 ' 7\"\n  if rc = 0 then do\n     mbr_type = 'COBOL'\n     Signal Type_Exit\n  end\n\n \"Find first ' PIC X(' 30 60\"\n  if rc = 0 then do\n     mbr_type = 'COBOL'\n     Signal Type_Exit\n  end\n\n /* --------------- *\n  * Ad hoc C checks *\n  * --------------- */\n \"Find first 'stdio.h'\"\n  if rc = 0 then do\n     mbr_type = 'C'\n     Signal Type_Exit\n  end\n\n/* --------------------------- *\n * Test for ISPF Skeleton Type *\n * --------------------------- */\n \"Find first ')CM'\"\n if rc = 0 then do\n    mbr_type = \"SKEL\"\n     Signal Type_Exit\n     end\n\n \"Find first ')DO'\"\n if rc = 0 then do\n    mbr_type = \"SKEL\"\n     Signal Type_Exit\n     end\n\n \"Find first ')I'\"\n if rc = 0 then do\n    mbr_type = \"SKEL\"\n     Signal Type_Exit\n     end\n\n \"Find first ')SE'\"\n if rc = 0 then do\n    mbr_type = \"SKEL\"\n     Signal Type_Exit\n     end\n\n/* --------------------------------------------------------- *\n * Test for SAS Language Type                                *\n * --------------------------------------------------------- */\n \"Find first t'RUN;'\"\n  if rc = 0 then do\n     mbr_type = \"SAS\"\n     Signal Type_Exit\n     end\n\n /* ------------------ *                                  /* Ge150606 */\n  * Ad hoc PLI checks  *                                  /* Ge150606 */\n  * ------------------ */                                 /* Ge150606 */\n \"FIND FIRST 'DCL '\"                                      /* Ge150606 */\n  if rc = 0 then do                                       /* Ge150606 */\n     mbr_type = 'PLI'                                     /* Ge150606 */\n     Signal Type_EXIT                                     /* Ge150606 */\n  end                                                     /* Ge150606 */\n                                                          /* Ge150606 */\n \"FIND FIRST 'OPTIONS(MAIN'\"                              /* Ge150606 */\n  if rc = 0 then do                                       /* Ge150606 */\n     mbr_type = 'PLI'                                     /* Ge150606 */\n     Signal Type_EXIT                                     /* Ge150606 */\n  end                                                     /* Ge150606 */\n                                                          /* Ge150606 */\n \"FIND FIRST 'CALL PLIRET'\"                               /* Ge150606 */\n  if rc = 0 then do                                       /* Ge150606 */\n     mbr_type = 'PLI'                                     /* Ge150606 */\n     Signal Type_EXIT                                     /* Ge150606 */\n  end                                                     /* Ge150606 */\n                                                          /* Ge150606 */\n \"FIND FIRST ' BUILTIN'\"                                  /* Ge150606 */\n  if rc = 0 then do                                       /* Ge150606 */\n     mbr_type = 'PLI'                                     /* Ge150606 */\n     Signal Type_EXIT                                     /* Ge150606 */\n  end                                                     /* Ge150606 */\n                                                          /* Ge150606 */\n /* ----------------------------------------------- *\n  * Check type based on a node of the dataset name  *\n  * ----------------------------------------------- */\n '(dsname) = dataset'\n  if Pos('ASM',dsname)   > 0  then mbr_type = 'ASM'\n  if Pos('CLIST',dsname) > 0  then mbr_type = 'CLIST'\n  if Pos('CNTL',dsname)  > 0  then mbr_type = 'JCL'\n  if Pos('EXEC',dsname)  > 0  then mbr_type = 'REXX'\n  if Pos('REXX',dsname)  > 0  then mbr_type = 'REXX'\n  if Pos('SAS',dsname)   > 0  then mbr_type = 'SAS'\n  if Pos('PLI',dsname)   > 0  then mbr_type = 'PLI'   /* Ge150606 */\n  if Pos('SKEL',dsname)  > 0  then mbr_type = 'SKEL'\n  if mbr_type \\= null then Signal Type_Exit\n\n /* -------------------- *\n  * Default to DOC type  *\n  * -------------------- */\n  mbr_type = 'DOC'\n\nType_Exit:\n 'reset'\n  MbrType = Mbr_Type                       /* Setup panel's disp var */\n\nReturn\n\n/*========================================================*\n* Routine: Setup_Member_Type_Parameters                   *\n*   Setup processing parameters based on the member type. *\n*========================================================*/\nSetup_Member_Type_Parameters:\n\n /* ----------------------------------------------- *\n  * Set 'boxlen' value for a Fixed length box type. *\n  * Set character used for the box outside borders. *\n  * ----------------------------------------------- */\n  if Pos(boxsize,'SF') > 0 then boxlen = cmtdfFix\n  dash_char  = cmtdfChr\n  dash_line  = Left(dash_char,boxlen,dash_char)\n\n /* ------------------------------------------------------ *\n  * if Centering requested, determine indent value to use. *\n  * Centering is based on the objects RIGHT BOUNDS value.  *\n  * ------------------------------------------------------ */\n  if Translate(indent) = 'C' then do\n     Address Isredit \"(,rbnds) = BOUNDS\"\n     indent = (rbnds - boxlen - 6) % 2\n  end\n\n /* ---------------------------------------------------- *\n  * if RIGHT justify requested, determine indent value.  *\n  * Calculation based on the objects RIGHT BOUNDS value. *\n  * ---------------------------------------------------- */\n  right_just = 0\n  if Translate(indent) = 'R' then do\n     right_just = 1\n     Address Isredit \"(,rbnds) = BOUNDS\"\n     indent = rbnds - (boxlen + 6)\n  end\n\n /* --------------------------------------------------------- *\n  * Setup the comment box syntax appropriate for the mbr type *\n  * --------------------------------------------------------- */\n  Select\n     When mbr_type = 'ASM' then do\n          if right_just then indent = indent + 2\n         /* --------------------------------------- *\n          * Setup special indent for assembler type *\n          * --------------------------------------- */\n          if indent > 1 then do\n             cmt_chars  = \"*\"\n             indent_spc = \"*\"Left(null,indent-1)\n             end\n          else do\n             cmt_chars  = null\n             indent_spc = \"*\"\n             end\n          first_line = indent_spc||cmt_chars dash_line \"*\"\n          last_line  = indent_spc||cmt_chars dash_line \"*\"\n          end\n     When mbr_type = 'CLIST',\n        | mbr_type = 'PANEL' then do\n          cmt_chars  = \"/*\"\n          cmt_suf    = \"/\"\n          indent_spc = Left(null,indent)\n          first_line = indent_spc\"/*\" dash_line \"*/\"\n          last_line  = indent_spc\"/*\" dash_line \"*/\"\n          end\n     When mbr_type = 'COBOL' then do\n         \"(stat,fmt) = NUMBER\"\n          cmt_chars  = \"*\"\n          if Pos(\"COBOL\",fmt) > 0 then\n             indent_spc = \"*\"Left(null,indent)\n          else\n             indent_spc = \"      *\"Left(null,indent)\n          first_line = indent_spc\"*\" dash_line \"*\"\n          last_line  = first_line\n          end\n     When mbr_type = 'JCL'   then do\n         /* --------------------------------- *\n          * Setup special indent for JCL type *\n          * --------------------------------- */\n          if indent > 3 then do\n             cmt_chars  = \"*\"\n             indent_spc = \"//*\"Left(null,indent-1)\n             end\n          else do\n             cmt_chars  = null\n             indent_spc = \"//*\"\n             end\n          first_line = indent_spc||cmt_chars dash_line \"*\"\n          last_line  = indent_spc||cmt_chars dash_line \"*\"\n          end\n     When mbr_type = 'SKEL'  then do\n         /* ---------------------------------- *\n          * Setup special indent for SKEL type *\n          * ---------------------------------- */\n          cmt_chars  = \"*\"\n          cmt_chars  = null\n          indent_spc = \")CM *\"\n          first_line = indent_spc||cmt_chars dash_line \"*\"\n          last_line  = indent_spc||cmt_chars dash_line \"*\"\n          end\n     When mbr_type = 'REXX',\n        | mbr_type = 'C'     then do\n          cmt_chars  = \" |\"\n          cmt_last   = \"|\"\n          indent_spc = Left(null,indent)\n          first_line = indent_spc\"/*\" dash_line \"*\"\n          last_line  = indent_spc\" *\" dash_line \"*/\"\n          end\n     When mbr_type = 'SHELL' then do                    /* lbd */\n          cmt_chars  = \"# \"                             /* lbd */\n          cmt_suf    = \"#\"                              /* lbd */\n          cmt_last   = \"\"                               /* lbd */\n          indent_spc = Left(null,indent)                /* lbd */\n          first_line = indent_spc\"# \" dash_line \"#\"     /* lbd */\n          last_line  = indent_spc\"# \" dash_line \"#\"     /* lbd */\n          end                                           /* lbd */\n     When mbr_type = 'SAS' then do\n          cmt_chars  = \"*\"\n          cmt_suf    = \";\"\n          indent_spc = Left(null,indent)\n          first_line = indent_spc\"*\" dash_line \"*;\"\n          last_line  = indent_spc\"*\" dash_line \"*;\"\n          end\n     When mbr_type = 'PLI' then do                        /* Ge150606 */\n          if indent > 1 then do                           /* Ge150606 */\n             cmt_chars  = \" *\"                            /* Ge150606 */\n             indent_spc = Left(null,indent-1)             /* Ge150606 */\n             end                                          /* Ge150606 */\n          else do                                         /* Ge150606 */\n             cmt_chars  = \" *\"                            /* Ge150606 */\n             indent_spc = \" \"                             /* Ge150606 */\n             end                                          /* Ge150606 */\n          first_line = indent_spc\"/*\" dash_line \"*\"       /* Ge150606 */\n          last_line  = indent_spc\" *\" dash_line \"*/\"      /* Ge150606 */\n          end                                             /* Ge150606 */\n     Otherwise do\n          if right_just then indent = indent + 2\n          cmt_chars  = \"*\"\n          indent_spc = Left(null,indent)\n          first_line = indent_spc||cmt_chars dash_line \"*\"\n          last_line  = indent_spc||cmt_chars dash_line \"*\"\n          end\n  end\n\nReturn\n\n/*=========================================================*\n * Routine: Set_CMT_Defaults                               *\n * This routine processes a CMT SET function to set a      *\n * user's default value for the INDENT or BOXSIZE parms.   *\n * if a current setting is not found for these, they are   *\n * defaulted to INDENT = 0 and BOXSIZE = S (Set size)      *\n *=========================================================*/\nSet_CMT_Default:\n\n  Parse Upper VAR indent cmd parm_id hlddfval\n\n  Call Get_Default_Values\n\n  Error = null\n  Address Ispexec\n\n  Select\n  /* ------------------ *\n   * Set INDENT default *\n   * ------------------ */\n     When Left(parm_id,1) = \"I\" then do\n          parm_id  = \"Indent\"\n          if Datatype(hlddfVal) = \"NUM\" then\n             if hlddfInd < 66 then\n                cmtdfInd = hlddfVal\n             else\n                Error=\"value must be a nbr 1-65, C=Center  R=Rt Justify\"\n          else\n            if Pos(hlddfVal,\"CR\") > 0 then\n                cmtdfInd = hlddfVal\n            else\n               Error=\"value must be a nbr 1-65, C=Center  R=Rt Justify\"\n          end /*when*/\n\n  /* ------------------- *\n   * Set BOXSIZE default *\n   * ------------------- */\n     When Left(parm_id,1) = \"B\" then do\n          parm_id  = \"BOXSIZE\"\n          if Pos(hlddfVal,\"FSV\") > 0 then\n             cmtdfBox = hlddfVal\n          else\n             Error = \"must be F or S (Fixed or Set) or V (Variable)\"\n          end\n\n  /* ------------------------ *\n   * Set the BOX CHAR default *\n   * ------------------------ */\n     When Left(parm_id,1) = \"C\" then do\n          parm_id  = \"CHARBOX\"\n          cmtdfChr = hlddfVal\n          end\n\n  /* -------------------------- *\n   * Set the FIX LENGTH default *\n   * -------------------------- */\n     When Left(parm_id,1) = \"F\" then do\n          parm_id  = \"FIXLEN\"\n          if Datatype(hlddfVal) = \"NUM\" then\n             if hlddfInd < 61 then\n                cmtdfFix = hlddfVal\n             else\n                Error = \"value must be a number from 1 - 75\"\n          else\n                Error = \"value must be a number from 1 - 75\"\n          end\n\n  /* ------------------------ *\n   * Error: no SET parameters *\n   * ------------------------ */\n     When parm_id = null then do\n          parm_id = \"<blank>\"\n          Error=\"Invalid parm ID.  Enter Indent, Boxsize, Charbox or\",\n                \"Fixlen\"\n          end\n\n     Otherwise\n          Error=\"Invalid parm ID.  Enter Indent, Boxsize, Charbox or\",\n                \"Fixlen\"\n  end\n\n /* -------------------- *\n  * Set description text *\n  * -------------------- */\n  if Datatype(cmtdfInd) = \"NUM\" then\n     indd = \" (Indent the comment box\" cmtdfInd \"characters)\"\n  if Pos(cmtdfInd,\"cC\") > 0   then\n     indd = \" (Comment box will be CENTERed based on RIGHT BOUNDS)\"\n  if Pos(cmtdfInd,\"rR\") > 0   then\n     indd = \" (Comment box will be RIGHT justified on RIGHT BOUNDS)\"\n\n  if Pos(cmtdfBox,\"FS\") > 0 then boxd =,\n     \" (Box size fixed at\" cmtdfFix \"characters. See FIXLEN setting)\"\n  if cmtdfBox=\"V\" then boxd =,\n  \" (Box size based on longest comment line)\"\n\n  chrd = \" (Box outlining character)\"\n  fixd = \" (Box length When a Fixed/Set BOXSIZE used)\"\n\n /* ----------------- *\n  * Send Good message *\n  * ----------------- */\n  if Error = null then do\n     zedsmsg = null\n     zedlmsg = Left(\"CMT default values were set to:\",81),\n               Left(\".    INDENT :\" Left(cmtdfInd,2) \" \" indd,81),\n               Left(\".    BOXSIZE:\" Left(cmtdfBox,2) \" \" boxd,81),\n               Left(\".    CHARBOX:\" Left(cmtdfChr,2) \" \" chrd,81),\n                    \".    FIXLEN :\" Left(cmtdfFix,2) \" \" fixd\n     end\n  else do\n /* --------------------- *\n  * Send an Error message *\n  * --------------------- */\n     zedsmsg = ' '\n     zedlmsg = Left(\"Error setting default for '\"parm_id\"' \",\n                    \"SYNTAX: CMT SET <parmId> <dflt value>\",81),\n               Left(parm_id Error,81),\n               Left(\"Current CMT defaults are:\",81),\n               Left(\".    INDENT :\" cmtdfInd \" \" indd,81),\n               Left(\".    BOXSIZE:\" cmtdfBox \" \" boxd,81),\n               Left(\".    CHARBOX:\" cmtdfChr \" \" chrd,81),\n                    \".    FIXLEN :\" Left(cmtdfFix,2) \" \" fixd\n     end\n \"Setmsg Msg(isrz000)\"\n /* ---------------------------------------------------- *\n  * Store the default values in the current PROFILE pool *\n  * ---------------------------------------------------- */\n \"Vput (cmtdfInd cmtdfBox cmtdfChr cmtdfFix) profile\"\n\nReturn\n\n/*========================================================*\n * Routine: Arrange_Parameters                            *\n *    Arrange parameters into indent,boxsize,text order,  *\n *    then assign the default to any null parameters.     *\n *    ASSUMPTION: at least one parm (indent) has a value. *\n *========================================================*/\nArrange_Parameters:\n\n  Call Get_Default_Values\n\n  text = text2\n  Parse Value \"\" With indent_save box_save text_save\n\n /* ------------------------------- *\n  * Check the current INDENT value. *\n  * ------------------------------- */\n  if Datatype(indent) = \"NUM\",\n  |  Pos(indent,\"cCrR\") > 0 then Nop\n\n  else\n    /* -------------------------------- *\n     * Move it to appropriate parameter *\n     * since it is NOT the INDENT parm. *\n     * -------------------------------- */\n     if Wordpos(indent,Valid_Box_Values) > 0 then do\n        box_save = indent\n        indent = null\n        end\n     else do\n        text_save = indent\n        indent = null\n     end\n\n /* -------------------------------- *\n  * Check the current BOXSIXE value. *\n  * -------------------------------- */\n  if Wordpos(boxsize,Valid_Box_Values) = 0 then\n    /* -------------------------------- *\n     * Move it to appropriate parameter *\n     * since it is NOT the BOXSIZE parm *\n     * -------------------------------- */\n     if Datatype(boxsize) = \"NUM\",\n     |  Pos(boxsize,\"cCrR\") > 0 then do\n        indent_save = boxsize\n        boxsize = null\n        end\n     else do\n        if boxsize \\= null then do\n           text_save = boxsize\n           boxsize = null\n        end\n     end\n\n /* ----------------------------- *\n  * Check the current TEXT value. *\n  * ----------------------------- */\n  if Wordpos(text,Valid_Box_Values) > 0 then do\n     box_save = text\n     text = null\n     end\n\n  if Datatype(text) = \"NUM\",\n  |  Pos(text,\"cCrR\") > 0 then do\n     indent_save = text\n     text = null\n     end\n\n /* ----------------------------------- *\n  * Move in appropriate values for the  *\n  * parms if they came in out of order. *\n  * ----------------------------------- */\n  if indent_save \\= null then indent  = indent_save\n  if box_save    \\= null then boxsize = box_save\n  if text_save   \\= null then text    = text_save\n\nReturn\n\n/*=============================================================*\n * Retrieve defaults for INDENT, BOXSIZE & CHARBOX  parameters *\n *=============================================================*/\nGet_Default_Values:\n\n  Address Ispexec \"Vget (CmtdfInd CmtdfBox CmtdfChr CmtdfFix) profile\"\n  if CmtdfInd = null then CmtdfInd = 0\n  if CmtdfBox = null then CmtdfBox = 'F'\n  if CmtdfChr = null then CmtdfChr = '-'\n  if CmtdfFix = null then CmtdfFix = 65\n\nReturn\n\n/*==========================*\n * Display HELP information *\n *==========================*/\nGet_Help:\n\n  Call Get_Default_Values\n  Call Create_Panels\n  Address Ispexec\n \"Addpop\"\n \"Display Panel(cmthelp)\"\n \"Rempop\"\n\nReturn\n\n/* ========================================================= *\n * Function: Create_Panels                                   *\n *    The following is a process to define panels in-line.   *\n *    Panels are defined and loaded into a temporary dataset *\n *    and then dataset is Libdef'ed so it is allocated.      *\n *    A deallocation of the Libdef happens in Exit_Macro.    *\n * ========================================================= */\nCreate_Panels:\n\n /* ---------------------------------------- *\n  * If the panels have already been          *\n  * created then bypass additional attempts. *\n  * ---------------------------------------- */\n  if Panels_Created then Return\n\n /* ---------------------------------------------- *\n  * Create temp DS to hold inline panel definition *\n  * ---------------------------------------------- */\n  x = Msg(on)\n  Address Tso\n  prefix = Sysvar('SYSPREF')                  /* tso profile prefix  */\n  uid    = Sysvar('SYSUID')                   /* tso userid          */\n  if prefix =  '' then prefix = uid           /* use uid if null prfx*/\n  if prefix <> '' & prefix <> uid then        /* diff prefix than uid*/\n     prefix = prefix || '.' || uid            /*    use prefix.uid   */\n  ddname = \"$\"Right(Time(S),7,\"0\")\n  flname = prefix\".\"ddname\".ISPPLIB\"\n\n \"Alloc File(\"ddname\") da('\"flname\"') new del tracks space(1,1)\",\n       \"lrecl(80) recfm(f b) blksize(3120) dir(1) reuse\"\n\n/* ------------------------------------ *\n * Three panels are created here.       *\n * CMTPANEL - Main comment entry panel. *\n * CMTHELP  - CMT command Help panel.   *\n * CMTHELPP - CMT panel Help panel.     *\n * ------------------------------------ */\n  Call Create_Main_Panel\n  Call Create_Help_Panels\n\n  Panels_Created = 1\n  Address Ispexec \"libdef ispplib library id(\"ddname\") stack\"\n\nReturn\n\nCreate_Main_Panel:\n  NEWSTACK\n  mbname = \"cmtpanel\"\n\nQueue \")Attr Default(%+{)                                           \"\nQueue \" @ type(input) intens(high) caps(off) just(asis) color(white)\",\n      \"    hilite(uscore)\"\nQueue \" _ type(input) intens(high) caps(on)  just(asis) color(white)\",\n      \"    hilite(uscore)\"\nQueue \" $ type(output) intens(high) just(asis ) color(turq)             \"\nQueue \" ~ type(text)   intens(high) caps(off) just(asis ) color(blue)   \"\nQueue \" + type(text)   intens(low ) skip(on)                            \"\nQueue \" { type(text)   intens(low ) skip(on)  color(green)              \"\nQueue \")Body                                                           \"\nQueue \"+------------------%Comments Entry Ver$Z  +--------------------- \"\nQueue \"+Command ===>_zcmd                             +Scroll ===>_zcsr+\"\nQueue \"+                                                                \"\nQueue \"%Parms:{Indent     :_Z {   Box Size   :_Z{                       \"\nQueue \"+      {Fixed Size :_Z {   Boxing Char:_Z{    Set as defaults:_Z+\"\nQueue \"+                                                                \"\nQueue \"+      {Member Type:_Z    +   %END~add cmt %HELP %CANcel  Insert#\"\nQueue \")Model                                                           \"\nQueue ,\n\"+>@z                                                                +<\"\nQueue \")Init                                                            \"\nQueue \"  &zcsr = CSR                                                    \"\nQueue \"  .ZVARS = '(vernbr indent boxsize cmtdfFix cmtdfChr +           \"\nQueue \"             setdflt mbrtype rxline)'                            \"\nQueue \"  .cursor= mbrtype                                               \"\nQueue \"  .help = cmthelpp                                               \"\nQueue \"  &setdflt = 'N'                                                 \"\nQueue \")Proc                                                            \"\nQueue \" ver (&mbrtype,LIST,'ASM','C','CLIST','COBOL','JCL',             \"\nQueue \"  'PANEL','REXX','DOC','SAS','PLI','SKEL','SHELL')               \"\nQueue \" ver (&boxsize,LIST,'C','F','S','V')                             \"\nQueue \" ver (&cmtdfFix,RANGE,1,65)                                         \"\nQueue \" ver (&setdflt,LIST,'Y','N')                                     \"\nQueue \")End                                                             \"\nQueue \"\"\n\n  Call Write_Panel_Member\n\nReturn\n\nCreate_Help_Panels:\n  NEWSTACK\n  mbname = \"cmthelp\"\n\nQueue \")Attr Default(%+_)                                              \"\nQueue \" ~ type(text)   intens(high) caps(off) just(asis ) color(turq)  \"\nQueue \" @ type(text)   intens(high) caps(off) just(asis ) color(yellow)\"\nQueue \" $ type(output) intens(high) just(asis ) color(turq)             \"\nQueue \" ` type(text)   intens(high) caps(off) just(asis ) color(red)   \"\nQueue \")Body Window(64,20)                                             \"\nQueue \"+-----------------%CMT Command HELP  Ver$Z  +-------------------\"\nQueue \"+Command ===>_zcmd                                              \"\nQueue \"% CMT+is an ISPF edit macro to simplify entry of comments. CMT  \"\nQueue \"+ enters all comments in the syntax of the object being edited  \"\nQueue \"+ and formats them via sent/defaulted user parameters. Defaults \"\nQueue \"+ for execution are set/inquired via the CMT syntax #2, shown   \"\nQueue \"+ below, and some may be overridden via the main CMT syntax #1. \"\nQueue \"` All comments require a target line be defined in your data.   \"\nQueue \"~                                                               \"\nQueue \"~ Syntax 1 to add comment line(s)    +(all parms optional)      \"\nQueue \"% CMT #,B,text  +                                               \"\nQueue \"%     #+=INDENT   %1+-%70, C+(Center) or%R+(Right Justify) box  \"\nQueue \"%     B+=BOXSIZE  %F S+(Fixed$Z +chars) or %V+(Variable size)   \"\nQueue \"%     cmt text+   @blank shows popup panel to enter mult lines. \"\nQueue \"~                                                               \"\nQueue \"~ Syntax 2 to Set CMT defaults @(also may be set on popup panel)\"\nQueue \"% CMT SET <parmId> <parm value>                                 \"\nQueue \"%     parmid    %Indent, Boxsize, Charbox or Fixlength          \"\nQueue \"%     parm value+for I:%#1-70, C or R    +B:%F,S or V           \"\nQueue \"%                   +C:%any character    +F:%1-65               \"\nQueue \")Init                                                           \"\nQueue \"  .ZVARS = '(vernbr cmtdfFix)'                                  \"\nQueue \")End\"\nQueue \"\"\n\n  Call Write_Panel_Member\n\n  NEWSTACK\n  mbname = \"cmthelpp\"\n\nQueue \")Attr Default(%+_)                                              \"\nQueue \" ~ type(text)   intens(high) caps(off) just(asis ) color(turq)  \"\nQueue \" @ type(text)   intens(high) caps(off) just(asis ) color(yellow)\"\nQueue \"   type(output) intens(high)                                    \"\nQueue \" $ type(output) intens(high) just(asis ) color(turq)             \"\nQueue \")Body Window(64,20)                                             \"\nQueue \"+------------------%CMT Panel HELP  Ver$Z  +--------------------\"\nQueue \"+Command ===>_zcmd                                              \"\nQueue \"+ Parameters shown are initially set with your default values.  \"\nQueue \"+ They may be changed as needed for the comments to be added.   \"\nQueue \"+ Enter 'Y' in%Set as defaults+to make the parms your defaults. \"\nQueue \"%Cmds ~End+   text entered on panel is added to the source.     \"\nQueue \"      ~Insert <n>+inserts <n> blank lines into displayed table. \"\nQueue \"      ~Cancel+cancels with no comments added to the source.     \"\nQueue \"%Indent     :+Valid:%1-70+ or %C+(Center box) %R+(Right Justify)\"\nQueue \"            :+Enter how, or number of characters, to indent box.\"\nQueue \"%Box Size   :+Valid:%F+or%S+for a Fixed Size %V+- Variable.     \"\nQueue \"              Fixed - box size set to the \"Fixed Size\" value.   \"\nQueue \"              Variable - size set = to the longest line entered.\"\nQueue \"%Fixed Size :+Valid: nbr from%1-65 +Used ONLY if Box Size fixed.\"\nQueue \"%Boxing Char:+Character used as outside board of the box.       \"\nQueue \"%Member type:+Language syntax to use When comments are added.   \"\nQueue \"%Comments   :+Enter as many lines as needed. 150 lines initially\"\nQueue \"             +given. Use command %Insert <n>+to add lines.      \"\nQueue \"%For CMT command help enter CMT HELP while editing source.      \"\nQueue \")Init                                                           \"\nQueue \"  .ZVARS = '(vernbr)'                                           \"\nQueue \")End\"\nQueue \"\"\n\n  Call Write_Panel_Member\n\nReturn\n\nWrite_Panel_Member:\n\n \"ALLOC File(\"mbname\") SHR REUSE DA('\"flname\"(\"mbname\")')\"\n \"EXECIO * DISKW\" mbname \"(FINIS\"\n \"FREE FI(\"mbname\")\"\n  DELSTACK\n\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DEVTIPS#": {"ttr": 2057, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00T\\x01\\x196\\x1f\\x01 \\x13O\\tG\\x00\\x152t\\x00\\x00\\xd7\\xc4\\xc6@@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2019-12-27T00:00:00", "modifydate": "2020-05-13T09:47:54", "lines": 21, "newlines": 12916, "modlines": 0, "user": "PDF"}, "mimetype": "application/pdf", "datatype": "binary", "extension": ".pdf"}, "DEVTIPS@": {"ttr": 2059, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x08\\x01\\x196\\x1f\\x01 \\x13O\\tG\\x00\\x0c\\x1b^\\x00\\x00\\xc4\\xd6\\xc3\\xe7@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2019-12-27T00:00:00", "modifydate": "2020-05-13T09:47:08", "lines": 12, "newlines": 7006, "modlines": 0, "user": "DOCX"}, "mimetype": "application/zip", "datatype": "binary", "extension": ".zip"}, "JCBAT1": {"ttr": 2061, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\"\\x01\\x19\\x07\\x8f\\x01\\x19\\x08\\x8f\\x106\\x00\\x16\\x00\\x13\\x00\\x00\\xd1\\xc3\\xd3@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-03-19T00:00:00", "modifydate": "2019-03-29T10:36:22", "lines": 22, "newlines": 19, "modlines": 0, "user": "JCL"}, "text": "//JOBNAME JOB (BATCH),REGION=0M,NOTIFY=&SYSUID,CLASS=A\n//OUT   OUTPUT DEFAULT=YES,JESDS=ALL,OUTDISP=(HOLD,HOLD)\n//* ------------------------------------------------------ *\n//* Demonstration of running an ISPF application in Batch. *\n//* ISPF - Developers - Tips and Tricks                    *\n//* ------------------------------------------------------ *\n//TSO      EXEC  PGM=IKJEFT1B\n//STEPLIB  DD  DISP=SHR,DSN=TASID.LOAD   <=== Change\n//SYSTSPRT DD  SYSOUT=*\n//SYSTSIN  DD  *\n PROFILE PREFIX(userid)      <=== Change\n ISPSTART PGM(TASID) PARM(8)\n PRINTDS DSNAME(TASID.SNAPSHOT) CCHAR NOTITLE SYSOUT(R) HOLD\n//ISPPROF  DD  UNIT=VIO,SPACE=(TRK,(1,1,5)),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160)\n//ISPMLIB DD   DISP=SHR,DSN=ISP.SISPMENU\n//ISPPLIB DD   DISP=SHR,DSN=ISP.SISPPENU\n//ISPSLIB DD   DISP=SHR,DSN=ISP.SISPSENU\n//ISPTLIB DD   UNIT=VIO,DISP=(NEW,PASS),SPACE=(TRK,(1,1,5)),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=27920)\n//        DD   DISP=SHR,DSN=ISP.SISPTENU\n//ISPLOG  DD   DUMMY,DCB=(LRECL=120,BLKSIZE=2400,DSORG=PS,RECFM=FB)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "JCBAT2": {"ttr": 2063, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x18\\x01\\x19\\x07\\x8f\\x01\\x19\\x08\\x8f\\x107\\x00\\x15\\x00\\x13\\x00\\x00\\xd1\\xc3\\xd3@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-03-19T00:00:00", "modifydate": "2019-03-29T10:37:18", "lines": 21, "newlines": 19, "modlines": 0, "user": "JCL"}, "text": "//JOBNAME JOB (BATCH),REGION=0M,NOTIFY=&SYSUID,CLASS=A\n//OUT   OUTPUT DEFAULT=YES,JESDS=ALL,OUTDISP=(HOLD,HOLD)\n//* ----------------------------------------- *\n//* Sample Batch JCL demonstrating running an *\n//* ISPF Servie (LMD) in batch.               *\n//*  ISPF - Developers - Tips and Tricks      *\n//* ----------------------------------------- *\n//TSO      EXEC  PGM=IKJEFT1B\n//SYSEXEC  DD  DISP=SHR,DSN=hlq.DEVTIPS.PDS   <=== Change\n//SYSTSPRT DD  SYSOUT=*\n//SYSTSIN  DD  *\n ISPF CMD(%RXLMD)\n//ISPMLIB DD   DISP=SHR,DSN=ISP.SISPMENU\n//ISPTLIB DD  DISP=SHR,DSN=ISP.SISPTENU\n//ISPPROF  DD  UNIT=VIO,SPACE=(TRK,(1,1,5)),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160)\n//ISPPLIB DD   UNIT=VIO,DISP=(NEW,PASS),SPACE=(TRK,(1,1,5)),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=27920)\n//ISPSLIB DD   UNIT=VIO,DISP=(NEW,PASS),SPACE=(TRK,(1,1,5)),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=27920)\n//ISPLOG  DD   DUMMY,DCB=(LRECL=120,BLKSIZE=2400,DSORG=PS,RECFM=FB)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LOADISPF": {"ttr": 2305, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00W\\x01\\x02!\\x7f\\x01\\x19\\x02_\\x102\\x01D\\x00L\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-08-05T00:00:00", "modifydate": "2019-01-25T10:32:57", "lines": 324, "newlines": 76, "modlines": 0, "user": "REXX"}, "text": "/* --------------------  rexx procedure  -------------------- *\n * Name:      LoadISPF                                        *\n *                                                            *\n * Function:  Load ISPF elements that are inline in the       *\n *            REXX source code.                               *\n *                                                            *\n * Syntax:    load_info = loadispf()                          *\n *            rc = dropispf(load_info)                        *\n *                                                            *\n *            The inline ISPF resources are limited to        *\n *            ISPF Messages, Panels, and Skeletons,           *\n *                 CLISTs and EXECs are also supported.       *\n *                                                            *\n *            The inline resources must start in column 1     *\n *            and use the following syntax:                   *\n *                                                            *\n *            >START    used to indicate the start of the     *\n *                      inline data                           *\n *                                                            *\n *            >END    - used to indicate the end of the       *\n *                      inline data                           *\n *                                                            *\n *            Each resource begins with a type record:        *\n *            >type name                                      *\n *               where type is CLIST, EXEC, MSG, PANEL, SKEL  *\n *                     name is the name of the element        *\n *                                                            *\n * Sample usage:                                              *\n *          -* rexx *-                                        *\n *          load_info = loadispf()                            *\n *          ... magic code happens here (your code) ...       *\n *          rc = dropispf(load_info)                          *\n *          exit                                              *\n *          >Start inline elements                            *\n *          >Panel panel1                                     *\n *          ...                                               *\n *          >Msg msg1                                         *\n *          ...                                               *\n *          >End of inline elements                           *\n *                                                            *\n * Returns:   the list of ddnames allocated for use along     *\n *            with the libdef's performed or altlib           *\n *                                                            *\n *            format is ddname libdef ddname libdef ...       *\n *                   libdef may be altlibc or altlibe         *\n *                   for altlib clist or altlib exec          *\n *                                                            *\n * Notes:     Entire routine must be included with REXX       *\n *            exec - inline with the code.                    *\n *                                                            *\n * Comments:  The entire rexx program is processed from the   *\n *            last record to the first to find the >START     *\n *            record at which point all records from that     *\n *            point on are processed until the >END           *\n *            statement or the end of the program is found.   *\n *                                                            *\n *            It is *strongly* suggested that the inline      *\n *            elements be at the very end of your code so     *\n *            that the search for them is faster.             *\n *                                                            *\n *            Inline ISPTLIB or ISPLLIB were not supported    *\n *            because the values for these would have to be   *\n *            in hex.                                         *\n *                                                            *\n * Author:    Lionel B. Dyck                                  *\n *                                                            *\n * History:                                                   *\n *            01/09/19 - Include DROPISPF routine             *\n *            08/29/17 - Fixup static values that were vars   *\n *            05/31/17 - Change default directory count       *\n *            12/09/16 - update for add_it routine            *\n *            05/10/16 - correction for clist and exec        *\n *            04/19/16 - bug correction                       *\n *            06/04/04 - Enhancements for speed               *\n *            08/05/02 - Creation                             *\n *                                                            *\n * ---------------------------------------------------------- *\n * Disclaimer: There is no warranty, either explicit or       *\n * implied with this code. Use it at your own risk as there   *\n * is no recourse from either the author or his employeer.    *\n * ---------------------------------------------------------- */\nLoadISPF: Procedure\n\n  parse value \"\" with null kmsg kpanel kskel first returns ,\n    kclist kexec\n/* ------------------------------------------------------- *\n * Find the InLine ISPF Elements and load them into a stem *\n * variable.                                               *\n *                                                         *\n * Elements keyword syntax:                                *\n * >START - start of inline data                           *\n * >CLIST name                                             *\n * >EXEC name                                              *\n * >MSG name                                               *\n * >PANEL name                                             *\n * >SKEL name                                              *\n * >END   - end of all inline data (optional if last)      *\n * ------------------------------------------------------- */\n  last_line = sourceline()\n  do i = last_line to 1 by -1\n    line = sourceline(i)\n    if translate(left(line,6)) = \">START \" then leave\n  end\n  rec = 0\n/* --------------------------------------------------- *\n * Flag types of ISPF resources by testing each record *\n * then add each record to the data. stem variable.    *\n * --------------------------------------------------- */\n  do j = i+1 to last_line\n    line = sourceline(j)\n    if translate(left(line,5)) = \">END \"   then leave\n    if translate(left(line,7)) = \">CLIST \" then kclist = 1\n    if translate(left(line,6)) = \">EXEC \"  then kexec  = 1\n    if translate(left(line,5)) = \">MSG \"   then kmsg   = 1\n    if translate(left(line,7)) = \">PANEL \" then kpanel = 1\n    if translate(left(line,6)) = \">SKEL \"  then kskel  = 1\n    rec  = rec + 1\n    data.rec = line\n  end\n\n/* ----------------------------------------------------- *\n * Now create the Library and Load the Member(s)         *\n * ----------------------------------------------------- */\n  Address ISPExec\n/* ----------------------------- *\n * Assign dynamic random ddnames *\n * ----------------------------- */\n  clistdd = \"lc\"random(999)\n  execdd  = \"le\"random(999)\n  msgdd   = \"lm\"random(999)\n  paneldd = \"lp\"random(999)\n  skeldd  = \"ls\"random(999)\n\n/* ---------------------------------------- *\n *  LmInit and LmOpen each resource library *\n * ---------------------------------------- */\n  if kclist <> null then do\n    call alloc_dd clistdd\n    \"Lminit dataid(clist) ddname(\"clistdd\")\"\n    \"LmOpen dataid(\"clist\") Option(Output)\"\n    returns = strip(returns clistdd 'ALTLIBC')\n  end\n  if kexec <> null then do\n    call alloc_dd execdd\n    \"Lminit dataid(exec) ddname(\"execdd\")\"\n    \"LmOpen dataid(\"exec\") Option(Output)\"\n    returns = strip(returns execdd 'ALTLIBE')\n  end\n  if kmsg <> null then do\n    call alloc_dd msgdd\n    \"Lminit dataid(msg) ddname(\"msgdd\")\"\n    \"LmOpen dataid(\"msg\") Option(Output)\"\n    returns = strip(returns msgdd 'ISPMLIB')\n  end\n  if kpanel <> null then do\n    call alloc_dd paneldd\n    \"Lminit dataid(panel) ddname(\"paneldd\")\"\n    \"LmOpen dataid(\"panel\") Option(Output)\"\n    returns = strip(returns paneldd 'ISPPLIB')\n  end\n  if kskel <> null then do\n    call alloc_dd skeldd\n    \"Lminit dataid(skel) ddname(\"skeldd\")\"\n    \"LmOpen dataid(\"skel\") Option(Output)\"\n    returns = strip(returns skeldd 'ISPSLIB')\n  end\n\n/* ----------------------------------------------- *\n * Process all records in the data. stem variable. *\n * ----------------------------------------------- */\n  do i = 1 to rec\n    record = data.i\n    recordu = translate(record)\n    if left(recordu,5) = \">END \" then leave\n    if left(recordu,7) = \">CLIST \" then do\n      if first = 1 then call add_it\n      type = \"Clist\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n    if left(recordu,6) = \">EXEC \" then do\n      if first = 1 then call add_it\n      type = \"Exec\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n    if left(recordu,5) = \">MSG \" then do\n      if first = 1 then call add_it\n      type = \"Msg\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n    if left(recordu,7) = \">PANEL \" then do\n      if first = 1 then call add_it\n      type = \"Panel\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n    if left(recordu,6) = \">SKEL \" then do\n      if first = 1 then call add_it\n      type = \"Skel\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n   /* --------------------------------------------*\n    * Put the record into the appropriate library *\n    * based on the record type.                   *\n    * ------------------------------------------- */\n    Select\n      When type = \"Clist\" then\n      \"LmPut dataid(\"clist\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(255)\"\n      When type = \"Exec\" then\n      \"LmPut dataid(\"exec\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(255)\"\n      When type = \"Msg\" then\n      \"LmPut dataid(\"msg\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(80)\"\n      When type = \"Panel\" then\n      \"LmPut dataid(\"panel\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(80)\"\n      When type = \"Skel\" then\n      \"LmPut dataid(\"skel\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(80)\"\n      Otherwise nop\n    end\n  end\n  if type <> null then call add_it\n/* ---------------------------------------------------- *\n * Processing completed - now lmfree the allocation and *\n * Libdef the library.                                  *\n * ---------------------------------------------------- */\n  if kclist <> null then do\n    Address TSO,\n      \"Altlib Act Application(Clist) File(\"clistdd\")\"\n    \"LmFree dataid(\"clist\")\"\n  end\n  if kexec <> null then do\n    Address TSO,\n      \"Altlib Act Application(Exec) File(\"execdd\")\"\n    \"LmFree dataid(\"exec\")\"\n  end\n  if kmsg <> null then do\n    \"LmFree dataid(\"msg\")\"\n    \"Libdef ISPMlib Library ID(\"msgdd\") Stack\"\n  end\n  if kpanel <> null then do\n    \"Libdef ISPPlib Library ID(\"paneldd\") Stack\"\n    \"LmFree dataid(\"panel\")\"\n  end\n  if kskel <> null then do\n    \"Libdef ISPSlib Library ID(\"skeldd\") Stack\"\n    \"LmFree dataid(\"skel\")\"\n  end\n  return returns\n\n/* --------------------------- *\n * Add the Member using LmmAdd *\n * based upon type of resource *\n * --------------------------- */\nAdd_It:\n  Select\n    When type = \"Clist\" then\n    \"LmmAdd dataid(\"clist\") Member(\"name\")\"\n    When type = \"Exec\" then\n    \"LmmAdd dataid(\"exec\") Member(\"name\")\"\n    When type = \"Msg\" then\n    \"LmmAdd dataid(\"msg\") Member(\"name\")\"\n    When type = \"Panel\" then\n    \"LmmAdd dataid(\"panel\") Member(\"name\")\"\n    When type = \"Skel\" then\n    \"LmmAdd dataid(\"skel\") Member(\"name\")\"\n    Otherwise nop\n  end\n  type = null\n  return\n\n/* ------------------------------ *\n * ALlocate the temp ispf library *\n * ------------------------------ */\nAlloc_DD:\n  arg dd\n  Address TSO\n  if pos(left(dd,2),\"lc le\") > 0 then\n  \"Alloc f(\"dd\") unit(sysda) spa(5,5) dir(5)\",\n    \"recfm(v b) lrecl(255) blksize(32760)\"\n  else\n  \"Alloc f(\"dd\") unit(sysda) spa(5,5) dir(5)\",\n    \"recfm(f b) lrecl(80) blksize(23440)\"\n  return\n\n/* --------------------  rexx procedure  -------------------- *\n * Name:      DropISPF                                        *\n *                                                            *\n * Function:  Remove ISPF LIBDEF's and deactivate ALTLIB's    *\n *            that were created by the LoadISPF function.     *\n *                                                            *\n * Syntax:    rc = dropispf(load_info)                        *\n *                                                            *\n * Author:    Janko                                           *\n *                                                            *\n * History:                                                   *\n *            12/05/18 - Creation                             *\n * ---------------------------------------------------------- */\nDropISPF: Procedure\n  arg load_info\n  Address ISPEXEC\n  do until length(load_info) = 0\n    parse value load_info with dd libd load_info\n    if left(libd,6) = \"ALTLIB\" then do\n      if libd = \"ALTLIBC\" then lib = \"CLIST\"\n      else lib = \"EXEC\"\n      Address TSO,\n        \"Altlib Deact Application(\"lib\")\"\n    end\n    else \"libdef\" libd\n    address tso \"free f(\"dd\")\"\n  end\n  return 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PNABC": {"ttr": 2311, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00F\\x01\\x19\\x07\\x9f\\x01\\x19\\x08\\x8f\\x107\\x00\\x17\\x00\\x16\\x00\\x00\\xd7\\xc1\\xd5\\xc5\\xd3@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-03-20T00:00:00", "modifydate": "2019-03-29T10:37:46", "lines": 23, "newlines": 22, "modlines": 0, "user": "PANEL"}, "text": ")ATTR DEFAULT(%+_)\n   /* ISPF - Developers - Tips and Tricks */\n  $ TYPE(AB)           /* Action bar                */\n  @ TYPE(ABSL) GE(ON)  /* Action bar separator line */\n)ABC DESC(Menu) MNEM(1)\n  PDC DESC('Save')   ACTION RUN(SAVE)\n  PDC DESC('End')    ACTION RUN(END)\n  PDC DESC('Cancel') ACTION RUN(CANCEL)\n)ABCINIT\n  .ZVARS = 'MENUX'\n)ABC DESC(Help) MNEM(1)\n  PDC DESC('Extended Help...')\n  ACTION RUN(XHELP)\n)ABCINIT\n  .ZVARS = HELPX\n)BODY WINDOW(48,6)\n+$ Menu $ Help +\n@----------------------------------------------+\n%         Action bars and pull-downs\n%===>_ZCMD                                     +\n\n Action bars are cool.  Right?_ans+ (Yes, No)\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PNAREA": {"ttr": 2313, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00 \\x01\\x19\\x08\\x7f\\x01\\x19\\t/\\tQ\\x00\\xfa\\x00\\xf5\\x00\\x00\\xd7\\xc1\\xd5\\xc5\\xd3@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-03-28T00:00:00", "modifydate": "2019-04-02T09:51:20", "lines": 250, "newlines": 245, "modlines": 0, "user": "PANEL"}, "text": ")Attr Default(%+_)\n   /* ISPF - Developers - Tips and Tricks */\n} area(SCRL) Extend(ON)\n)Body Expand(\\\\)\n%Sample -\\-\\(Scrolling Panel Demo)\\-\\- Sample\n%Command ===>_ZCMD                                                          +\n+\n+     Sample of a Scrolling Area - use &zpf07 and &zpf08 keys to scroll +\n+     And then%F3+to Exit.\n%-----------------------------------------------------------------------------\n}help ------------------------------------------------------------------------}\n)Area Help\n+With thanks to Mr. John Kalinch for allowing us to 'borrow' the FAQ for the\n+PDS 8.6 command (found on the CBTTape File 182 at www.cbttape.org)\n+\n+ PDS Command Processor FAQ\n+ -------------------------\n+\n+ This document is for the new PDS user who may be struggling to use\n+ the vast number of PDS subcommands and their operands.\n+\n+ 1.  \"I took a quick look at PDS via TSO.  Some of the things displayed\n+     when 'help' is entered don't work.\"   Why?\n+\n+     Some of the PDS subcommands such as BLKDISK, COMPARE, DSAT, DVOL,\n+     HEL, RELEASE, REVIEW and VTOC are TSO command processors and they\n+     must be installed and available via a TASKLIB in order to work.\n+     They can be installed by issuing a TSO RECEIVE on the UTILXMIT\n+     member of the installation library.  You can use the TSOLIB command\n+     to define a task library for these command processors.\n+\n+     Another reason PDS subcommands might not work is improper syntax.\n+     The vast majority of subcommands require a \"member name\" or \"member\n+     group\" specification as the first positional operand.  Exceptions\n+     to this are the following commands:\n+\n+     CHANGE   COMPRESS CONTROL  DSNAME   END      EDREC    EXEC\n+     FIXPDS   ISPF     ISPMODE  ISPXEQ   OPTIONS  RECALL   TSO     USAGE\n+\n+     Consider the following scenario...a new user is staring at a\n+     MEMLIST display in dialog (aka ISPMODE) mode.  They want to find a\n+     string in all members in the MEMLIST display.  They enter the\n+     following command:\n+\n+       FIND 'a needle in a haystack'\n+\n+     which returns an error message about an invalid member name.\n+\n+     In order to search all of the members displayed in the MEMLIST\n+     table, you first must make the current member group equal to\n+     all members in the MEMLIST display.\n+\n+     SUBLIST = MEMLIST\n+     FIND * 'a needle in a haystack'\n+\n+     Note:  See Faq #13 for additional info on invalid subcommands.\n+\n+ 2.  Why doesn't the FIND command work?\n+\n+     In dialog mode, there are two different \"find\" commands.\n+\n+     \"F\"    is find in table (Log, MEMLIST, LISTA, LISTF, LISTV, ...)\n+     \"FInd\" is find in member(s) data\n+\n+ 3.  How do I get HELP?\n+\n+     In dialog mode, there are prompting panels for each subcommand.\n+     Enter \"O\" or \"O.subcommand\" to display the prompt panel.  A\n+     quick reference pop-up display panel is available via the QR\n+     special dialog command.  For line command help, enter \"O\",\n+     \"/\", or \"?\" in the line command area to the left.\n+\n+     To display the TSO HELP member for PDS, just enter \"H\" or \"HEL\"\n+     to invoke full-screen help.  You can jump to the subcommand\n+     help section by entering \"H subcommand\".\n+\n+       Note:  The &CHEL global variable must be set to 'HEL'\n+       in order to use full-screen help.\n+\n+     The dialog \"FN\" command will display a PDS Function Selection\n+     panel.\n+\n+ 4.  After exiting the ISPF tutorial via PF3, and attempting to\n+     immediately scroll left via PF10 on the next keystroke, why\n+     do I get the error message, \"LEFT    \" is not active?\n+\n+     Press Enter immediately after exiting the tutorial, then the\n+     LEFT and RIGHT user variables will be set and function\n+     correctly.\n+\n+ 5.  Why does the following IF command fail in batch mode?\n+\n+     //TSO      EXEC  PGM=IKJEFT01\n+     //STEPLIB  DD  DSN=name.of.pds.loadlib,DISP=SHR\n+     //SYSTSPRT DD  SYSOUT=*\n+     //SYSTSIN  DD  *\n+     pds 'sys1.nucleus' volume(npsrs1)\n+     if a:z sctr noalias then(map * relink)\n+     end\n+\n+     IF does not allow any operands on subcommands in the\n+     THEN or ELSE clauses.  If you use SUBLIST in the THEN\n+     clause, the current member group (*) can be used on a\n+     subsequent subcommand.  For example,\n+\n+     pds 'sys1.nucleus' volume(npsrs1)\n+     if a:z sctr noalias then(sublist)\n+     map * relink\n+     end\n+\n+ 6.  Why does message PDS856E STOW ERROR, R15=16, R0=00000001\n+     display after FIXPDS RESET subcommands on small PDS's\n+     with one or two directory blocks?\n+\n+     This only happens if the PDS has a one track extent\n+     and less than 3 directory blocks.  Use FIXPDS RESET(3).\n+\n+ 7.  Why does message PDS715E NO MATCHING ATTRIBUTES WERE FOUND\n+     display in the ISPMODE log after an Edit line command was\n+     entered in the MEMLIST table?\n+\n+     Check the \"Set MEMLIST Defaults\" for Auto member update: YES.\n+     YES means that after every EDIT a MEMLIST is run on the whole\n+     directory for changed members (based on date and time).  If\n+     there were no changes, message PDS715E will display.\n+\n+ 8.  Why do I get a data truncation error on a CAX line command?\n+\n+     ***********************************************************\n+     * ISPV006\n+     *\n+     * Data truncation occurred\n+     * Data for CHAR format variable \"PDSLN1\" was too long.\n+     *\n+     ***********************************************************\n+\n+     If you are running with the &LOGWIDE global variable set\n+     to YES, then you need to copy clist PDSTRAPW as PDSTRAP\n+     into your SYSPROC concatenation.  See member $$$TRAP.\n+\n+ 9.  What causes a S0C4 on a USAGE ALL for a PDSE dataset?\n+\n+     This happened when running PDS from an APF library.  The\n+     problem has been fixed in the 8.6.08 level of PDS.\n+\n+ 10. I am trying to include a lot of members in a sublist, but\n+     I get an error message.\n+\n+     //TSO      EXEC  PGM=IKJEFT01\n+     //STEPLIB  DD  DSN=pds.loadlib,DISP=SHR\n+     //SYSTSPRT DD  SYSOUT=*\n+     //SYSTSIN  DD  *\n+     pds 'your.dataset'\n+     sublist (membera, memberb, memberc, memberd, membere, +\n+              memberf, memberg, memberh, memberi, memberj, +\n+              memberk, memberl, memberm, membern, membero, +\n+              memberp, memberq, memberr, members, membert, +\n+              memberu, memberv, memberw, memberx, membery, +\n+              memberz, member1, member2, member3, member4)\n+     IKJ56702I INVALID MEMBER NAME\n+\n+\n+     This is because the maximum subcommand size is 256 characters.\n+     Use multiple sublist subcommands with the current member\n+     group designator (*) to keep adding members.\n+\n+     sublist (   membera, memberb, memberc, memberd, membere)\n+     sublist (*, memberf, memberg, memberh, memberi, memberj)\n+     sublist (*, memberk, memberl, memberm, membern, membero)\n+     sublist (*, memberp, memberq, memberr, members, membert)\n+     sublist (*, memberu, memberv, memberw, memberx, membery)\n+     sublist (*, memberz, member1, member2, member3, member4)\n+\n+ 11. How do I display PDS message numbers in output messages?\n+\n+     Enter the TSO command, PROFILE MSGID.\n+\n+ 12. How do I find all ISPF PACKed members and turn off packing?\n+\n+     find : x000140C6x then(sublist)  /* if RECFM=F */\n+       |\n+       or\n+       |\n+       v\n+     find : x000140E5x then(sublist)  /* if RECFM=V */\n+     edit * macro(PACKOFF)\n+\n+     <packoff>\n+     ISREDIT MACRO\n+     CONTROL NOMSG NOFLUSH NOLIST NOCONLIST NOSYMLIST\n+     ISREDIT PACK = OFF\n+     ISREDIT END\n+\n+ 13. ------ PDS Error Prompt Panel ------ Invalid option\n+\n+     COMMAND ===> control listenv\n+\n+     The above command is invalid or has invalid operands,\n+     correct and enter.\n+\n+\n+     When running the following dialog functions, you can only\n+     issue \"function specific\" commands that are defined in\n+     the PDS dialog command table (@DIATBL).\n+\n+     Option   Function     -- Description --\n+     LA     - LISTA        Allocation list\n+     LF     - LISTF        File list\n+     LV     - LISTV        Volume list\n+     CAX    - CAX          Active catalog list\n+     TCT    - TCT          TSO command table\n+\n+ 14. When I enter \"TSO PDS\" from the ISPF Command prompt\n+     message PDS100I does not display like it does\n+     when entered from the TSO READY prompt.\n+\n+     If PDS was generated with the automatic ISPMODE\n+     (&ISPOPT SETC 'ISPMODE') option, then you will\n+     not receive message PDS100I with the dataset\n+     prompt in ISPF.\n+\n+     To force message PDS100I to display, issue:\n+\n+     Command ===> tso pds / xispmode\n+\n+       PDS100I PDS -- VERSION 8.6.13.0  FEBRUARY 29, 2012\n+\n+       IKJ56700A ENTER NAME OF DATA SET -\n+\n+ 15. The ISPMODE session ends unexpectedly with no message\n+     after I enter a subcommand.\n+\n+     When running in ISPMODE, certain error conditions\n+     cause PDS to end without displaying the error message.\n+\n+     One example is message PDS832E DUMMY MEMBER ADD\n+     FAILED, RC=8.  This can be caused by trying to REPRO\n+     a null member.  Start PDS in line mode (or suspend\n+     ISPMODE) and run the subcommand again.  You will see\n+     the error message.\n+\n+ 16. LI * NONUM does not display PDS002I before first member.\n+\n+     Workaround:\n+     LI dummy nonum\n+     <PDS subcommand to build a sublist of members>\n+     LI\n)Init\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PNDYN": {"ttr": 2561, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00@\\x01\\x19\\x08o\\x01\\x19\\x08o\\x132\\x00\\x17\\x00\\x15\\x00\\x00\\xd7\\xc1\\xd5\\xc5\\xd3@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-03-27T00:00:00", "modifydate": "2019-03-27T13:32:40", "lines": 23, "newlines": 21, "modlines": 0, "user": "PANEL"}, "text": ")ATTR\n  @ AREA(DYNAMIC)           SCROLL(ON) EXTEND(ON)\n  01 TYPE(DATAOUT)          COLOR(RED)\n  02 TYPE(DATAOUT)          COLOR(BLUE)\n  03 TYPE(DATAOUT)          COLOR(GREEN)\n  04 TYPE(DATAOUT)          COLOR(WHITE)\n  r  TYPE(CHAR) COLOR(RED) HILITE(REVERSE)\n  g  TYPE(CHAR) COLOR(GREEN) HILITE(REVERSE)\n  b  TYPE(CHAR) COLOR(BLUE) HILITE(REVERSE)\n  $  TYPE(TEXT)            COLOR(YELLOW)\n)BODY\n%------------------  EXAMPLE FOR USING A DYNAMIC AREA -------------------%\n%COMMAND ===>_ZCMD                                      %SCROLL ===>_AMT +\n%\n+ This area is fixed.   size: &size\n+\n+ This is an input field%===>_somevar +\n+\n+This is extendable  @DYNAREA,DYNSHAD             @\n\n       $This should be at the bottom of the screen when in full screen.\n)END\n/* Doug Nadel, ISPF Panels - beyond the basics, March 2000            */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PNDYNTBL": {"ttr": 2563, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x13\\x01 \\x10/\\x01 \\x10/\\x08G\\x00\\x10\\x00\\x0c\\x00\\x00\\xd7\\xc1\\xd5\\xc5\\xd3@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2020-04-11T00:00:00", "modifydate": "2020-04-11T08:47:13", "lines": 16, "newlines": 12, "modlines": 0, "user": "PANEL"}, "text": ")Attr\n @ type(output) intens(high) caps(off)\n $ type(output) intens(low ) caps(off)\n # type(text) intens(high) hilite(uscore) caps(off)\n)Body Expand(\\\\)\n+-\\-\\%Dynamic Table Addition Example+\\-\\-\n+Command ===>_zcmd       \\ \\+Scroll ===>_tamt+\n+\n#Key+   #Day+       #Time+\n)Model\n@Data   $date       $time\n)Init\n &tamt = 'CSR'\n)Proc\n)End\n/* Sample ISPF Table Panel for demonstration */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PNDYNTP": {"ttr": 2565, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00E\\x01\\x19\\x07\\x1f\\x01 \\x10?\\x12S\\x00\\x15\\x00\\x0e\\x00\\x00\\xd7\\xc1\\xd5\\xc5\\xd3@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2019-03-12T00:00:00", "modifydate": "2020-04-12T12:53:45", "lines": 21, "newlines": 14, "modlines": 0, "user": "PANEL"}, "text": ")ATTR DEFAULT(%+_)\n  /* ISPF - Developers - Tips and Tricks */\n  @ type(output) caps(off) just(left)\n  _ type(input ) caps(on) intens(low) hilite(uscore)\n)Body Window(46,6)\n%Enter/Review:\n+\n+Total number of rows to generate :_z     +\n+Number of rows to add at one time:_z   +\n+\n+Press%Enter+to Continue, or%F3+to Cancel\n)INIT\n &total  = 10000\n &incrnum = 100\n .zvars = '(total incrnum)'\n  &ZWINTTL = 'Prompt for Dynamic Table Info'\n)Proc\n ver(&total,nb,range,1,999999)\n ver(&incrnum,nb,range,1,9999)\n)END\n/* Sample ISPF Popup Panel for demonstration */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PNEDITHL": {"ttr": 2567, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00G\\x01\\x196\\x0f\\x01\\x196\\x0f\\x13A\\x00\\x89\\x00\\x88\\x00\\x00\\xd7\\xc1\\xd5\\xc5\\xd3@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2019-12-26T00:00:00", "modifydate": "2019-12-26T13:41:47", "lines": 137, "newlines": 136, "modlines": 0, "user": "PANEL"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "PNFLDH": {"ttr": 2570, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00 \\x01\\x19\\x07\\x9f\\x01\\x19\\x08\\x8f\\x108\\x00\\x15\\x00\\x14\\x00\\x00\\xd7\\xc1\\xd5\\xc5\\xd3@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-03-20T00:00:00", "modifydate": "2019-03-29T10:38:20", "lines": 21, "newlines": 20, "modlines": 0, "user": "PANEL"}, "text": ")ATTR DEFAULT(%+_)\n   /* ISPF - Developers - Tips and Tricks */\n  $ TYPE(INPUT) INTENS(LOW) hilite(uscore)\n)BODY Expand(\\\\)\n+\\-\\%Sample Panel with Field Level Help+\\-\\\n%Command ===>_zcmd                                                             +\n%\n+   Place the cursor on any of the fields below and press F1 to\n+   view the Field Level Help.\n+\n+   Field one: $z      +          Sample Input Field\n+   Field two: $z      +          Sample Input Field\n+\n   +Press%F3+when ready to exit.\n)INIT\n  .zvars = '(field1 field2)'\n)PROC\n)Help\n Field(field1)  panel(pnfldh1)\n Field(field2)  panel(pnfldh2)\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PNFLDH1": {"ttr": 2572, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x001\\x01\\x19\\x07\\x9f\\x01\\x19\\x08\\x8f\\x108\\x00\\n\\x00\\x08\\x00\\x00\\xd7\\xc1\\xd5\\xc5\\xd3@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-03-20T00:00:00", "modifydate": "2019-03-29T10:38:31", "lines": 10, "newlines": 8, "modlines": 0, "user": "PANEL"}, "text": ")ATTR DEFAULT(%+_)\n   /* ISPF - Developers - Tips and Tricks */\n)BODY WINDOW(45,4)\n+\n+ This is a sample help for%Field One\n+\n+(Press%F3+to close)\n)INIT\n  &ZWINTTL = 'Field Level Help One'\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PNFLDH2": {"ttr": 2574, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x008\\x01\\x19\\x07\\x9f\\x01\\x19\\x08\\x8f\\x108\\x00\\n\\x00\\x08\\x00\\x00\\xd7\\xc1\\xd5\\xc5\\xd3@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-03-20T00:00:00", "modifydate": "2019-03-29T10:38:38", "lines": 10, "newlines": 8, "modlines": 0, "user": "PANEL"}, "text": ")ATTR DEFAULT(%+_)\n   /* ISPF - Developers - Tips and Tricks */\n)BODY WINDOW(45,4)\n+\n+ This is a sample help for%Field Two\n+\n+(Press%F3+to close)\n)INIT\n  &ZWINTTL = 'Field Level Help Two'\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PNNUMC": {"ttr": 2576, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00'\\x01\\x19(\\x0f\\x01\\x19(\\x0f\\x10\\x05\\x00\\x11\\x00\\x11\\x00\\x00\\xd7\\xc1\\xd5\\xc5\\xd3@@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-10-07T00:00:00", "modifydate": "2019-10-07T10:05:27", "lines": 17, "newlines": 17, "modlines": 0, "user": "PANEL"}, "text": ")ATTR DEFAULT(%+_)\n  /* ISPF - Developers - Tips and Tricks */\n  @ type(output) caps(off) just(left)\n)BODY WINDOW(57,8)\n+\n+Enter any number:_number                            +\n+\n+Readable number:@read\n+\n+Press%Enter+after entering a number to see it readable\n+or press%F3+to Exit.\n)INIT\n  &ZWINTTL = 'Sample Popup Panel'\n)Proc\n ver(&number,num)\n)END\n/* Sample ISPF Popup Panel for demonstration */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PNPNS": {"ttr": 2578, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00F\\x01\\x19\\x07O\\x01\\x19\\x08\\x8f\\x108\\x00&\\x00$\\x00\\x00\\xd7\\xc1\\xd5\\xc5\\xd3@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-03-15T00:00:00", "modifydate": "2019-03-29T10:38:46", "lines": 38, "newlines": 36, "modlines": 0, "user": "PANEL"}, "text": ")ATTR DEFAULT(%+_)\n   /* ISPF - Developers - Tips and Tricks */\n $ type(ps)\n # type(output) caps(off) just(left) color(red) hilite(uscore)\n @ type(output) caps(off) pas(on) hilite(uscore) color(yellow)\n } type(output) caps(off) pas(on) hilite(uscore) color(blue)\n)Body Expand(\\\\)\n+-\\-\\%ISPF Panel to Demonstrate Point-and-Shoot Fields+\\-\\-\n%Command ==>_zcmd              +\n+\n%Test:  $One+     $Two+\n+       $Three+   $Four+\n+       @Five+    @Six+\n+\n%Value #result                                  +\n+\n+Click here when ready to}Exit+\n+\n+Tab to any of the point and shoot fields and press%Enter+or move the\n+mouse point to them and double click. See the results in the%Value+field.\n+Note that the%Five+and%Six+fields are point and shoot fields but you can\n+change the text that displays in them with a drawback that you can\n+actually type into those fields with zero affect.\n+\n)Init\n &five = 'Five'\n &six  = 'Six'\n &exit = 'Exit'\n)Proc\n)PNTS\n FIELD(ZPS00001) VAR(RESULT) VAL('Value of 1')\n FIELD(ZPS00002) VAR(RESULT) VAL('We have two')\n FIELD(ZPS00003) VAR(RESULT) VAL('Now three')\n FIELD(ZPS00004) VAR(RESULT) VAL('Four')\n FIELD(Five)     VAR(RESULT) VAL('Five or 5')\n FIELD(Six)      VAR(RESULT) VAL('Six or 6')\n FIELD(Exit)     VAR(zcmd)   VAL(Exit)\n)end\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PNPOP": {"ttr": 2580, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00W\\x01\\x19\\x07\\x1f\\x01\\x19\\x08\\x8f\\x108\\x00\\x10\\x00\\x0e\\x00\\x00\\xd7\\xc1\\xd5\\xc5\\xd3@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-03-12T00:00:00", "modifydate": "2019-03-29T10:38:57", "lines": 16, "newlines": 14, "modlines": 0, "user": "PANEL"}, "text": ")ATTR DEFAULT(%+_)\n  /* ISPF - Developers - Tips and Tricks */\n  @ type(output) caps(off) just(left)\n)BODY WINDOW(45,8)\n+\n%This is a sample POPUP panel\n    +to demonstrate the capabilities of it.\n+\n+and how to add a variable of the userid\n+\n   %Userid:@zuser\n+\n)INIT\n  &ZWINTTL = 'Sample Popup Panel'\n)END\n/* Sample ISPF Popup Panel for demonstration */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PNPOPV": {"ttr": 2582, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x003\\x01\\x19\\x07\\x1f\\x01\\x19)_\\x104\\x00\\r\\x00\\x0e\\x00\\x00\\xd7\\xc1\\xd5\\xc5\\xd3@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2019-03-12T00:00:00", "modifydate": "2019-10-22T10:34:33", "lines": 13, "newlines": 14, "modlines": 0, "user": "PANEL"}, "text": ")ATTR DEFAULT(%+_)\n  /* ISPF - Developers - Tips and Tricks */\n  @ type(output) caps(off) just(left)\n)BODY WINDOW(45,5)\n+\n@msg1\n@msg2\n+\n+\n)INIT\n  &ZWINTTL = 'Sample Popup Panel'\n)END\n/* Sample ISPF Popup Panel for demonstration */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PNPREXX": {"ttr": 2584, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00$\\x01\\x19\\x07O\\x01 \\x03\\x1f\\t3\\x00/\\x00\\x1a\\x00\\x00\\xd7\\xc1\\xd5\\xc5\\xd3@@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2019-03-15T00:00:00", "modifydate": "2020-01-31T09:33:24", "lines": 47, "newlines": 26, "modlines": 0, "user": "PANEL"}, "text": ")Attr\n   /* ISPF - Developers - Tips and Tricks */\n  + Type(text) Just(left) skip(on)\n  @ Type(output) Just(left) intens(high)\n  _ Type(input) hilite(uscore)\n)Body Window(50,6) Expand(\\\\)\n+\n%Enter From Date (mm dd yyyy):_z +_z +_z   +\n%Enter To Date   (mm dd yyyy):_z +_z +_z   +\n+\n%Days between the above dates: @z      +\n%Years: @z   +\n)Init\n  .zvars = '(fromm fromd fromy tom tod toy days years)'\n   &zwinttl = 'Days between Dates'\n)Proc\n ver (&fromm,range,1,12)\n ver (&tom,range,1,12)\n ver (&fromd,range,1,31)\n ver (&tod,range,1,31)\n ver (&fromy,num)\n ver (&toy,num)\n vput (fromm fromd fromy tom tod toy)\n &resp = .resp\n*REXX(* resp)\n if resp = 'END' then exit\n null = ''\n if fromm = null then fromm = 0\n if fromd = null then fromd = 0\n if fromy = null then fromy = 0\n if tom   = null then tom   = 0\n if tod   = null then tod   = 0\n if toy   = null then toy   = 0\n fromx = fromy''fromm''fromd\n from = date('b',fromx,'s')\n tox   = toy''tom''tod\n to   = date('b',tox,'s')\n days = to - from\n years = days/365\n /* this translate code to insert commas stolen from\n    Doug Nadel */\n days=strip(translate('0,123,456,789,abc,def', ,\n   right(days,16,','), ,\n   '0123456789abcdef'),'L',',')\n   bytes = strip(days)\n*EndRexx\n)End\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PNPROG1": {"ttr": 2586, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x17\\x01\\x19\\x07o\\x01\\x19\\x08\\x8f\\x109\\x00\\x0c\\x00\\x0c\\x00\\x00\\xd7\\xc1\\xd5\\xc5\\xd3@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-03-17T00:00:00", "modifydate": "2019-03-29T10:39:17", "lines": 12, "newlines": 12, "modlines": 0, "user": "PANEL"}, "text": ")Attr\n   /* ISPF - Developers - Tips and Tricks */\n @ Type(Output) intens(High)\n)Body Window(24,3)\n+\n+Progress count:@z  +\n+\n)Init\n &zwinttl = 'Progress Counter'\n .zvars = '(pcount)'\n)Proc\n)End\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PNPROG2": {"ttr": 2588, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00$\\x01\\x16 /\\x01\\x19\\x08\\x8f\\x109\\x00\\x0b\\x00\\x11\\x00\\x00\\xd7\\xc1\\xd5\\xc5\\xd3@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2016-07-20T00:00:00", "modifydate": "2019-03-29T10:39:24", "lines": 11, "newlines": 17, "modlines": 0, "user": "PANEL"}, "text": ")Attr Default(%+_)\n   /* ISPF - Developers - Tips and Tricks */\n   @ type(output) intens(high) caps(off) color(blue)\n)Body window(50,3) expand(\\\\)\n+\n+   Progress:@prog\n+\n)Init\n &zwinttl = 'Progress Meter'\n)Proc\n)End\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PNSCRL": {"ttr": 2590, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x001\\x01\\x19\\x07\\x9f\\x01\\x19\\x08\\x8f\\x109\\x00\\x16\\x00\\x14\\x00\\x00\\xd7\\xc1\\xd5\\xc5\\xd3@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-03-20T00:00:00", "modifydate": "2019-03-29T10:39:31", "lines": 22, "newlines": 20, "modlines": 0, "user": "PANEL"}, "text": ")Attr Default(%+_)\n   /* ISPF - Developers - Tips and Tricks */\n $ Type(input) hilite(uscore) caps(off) just(left) intens(high)\n @ type(output)\n)Body window(70,10) expand(\\\\)\n+-\\-\\%Sample Scrolling Field Panel+\\-\\-\n%Command ===>_zcmd\n+\n+Enter data into the scrolling field and then scroll Right (F11) or\n+Left (F10) to continue to enter data and to view it.\n+\n%==>$scrfld                                                        @z\n    @lr1sc\n+   (Scroll Left or Right for up to 255 characters)\n+\n)Init\n .cursor = scrfld\n .zvars = '(scind)'\n)Proc\n)Field\n Field(scrfld) ind(scind,'<>') len(255) scale(lr1sc)\n)End\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PNTAB": {"ttr": 2592, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00Y\\x01\\x19\\x08\\x0f\\x01\\x190\\x8f\\x07\\x13\\x00%\\x00\\x17\\x00\\x00\\xd7\\xc1\\xd5\\xc5\\xd3@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2019-03-21T00:00:00", "modifydate": "2019-11-04T07:13:59", "lines": 37, "newlines": 23, "modlines": 0, "user": "PANEL"}, "text": ")Attr Default(%+_)\n   /* ISPF - Developers - Tips and Tricks */\n   ! type( input) intens(high) caps(on ) just(left ) hilite(uscore)\n   \u00ac type(output) intens(low ) caps(off) just(asis )\n)Body  Expand(\\\\)\n%-\\-\\- Sample Table Display Panel -\\-\\-\n%Command ===>_zcmd                                 \\ \\%Scroll ===>_amt +\n%\n+Commands: %REF+refresh the display%Only string+Filter on string\n+Selection:%S+Browse%SS/SS+Selection Range%S##+Selection Count\n+\n%Sel      Status     Item\n+\n)Model\n!z +     \u00acz       + \u00acz                                      +\n)Init\n  .ZVARS = '(vsel vstate vitem)'\n  &amt = CSR\n  &vset = 0\n)Reinit\n)Proc\n IF (&ZCMD = &Z)\n     if (&ztdsels = 0000)\n        &row = .csrrow\n        if (&row \u00ac= 0)\n            if (&vsel = &z)\n                &vsel = S\n                &vset = 1\n     if (&ztdsels \u00ac= 0000)\n          &row = &z\n     IF (&vsel \u00ac= &Z)\n        if (&vsel = '=')\n           &vsel = &osel\n     &osel = &vsel\n     if (&row = 0)\n        &vsel = &Z\n)End\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PNVDSN": {"ttr": 2818, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x01\\x19\\x08_\\x01 \\x10?\\x14P\\x00\\x1e\\x00\\x1a\\x00\\x00\\xd7\\xc1\\xd5\\xc5\\xd3@@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2019-03-26T00:00:00", "modifydate": "2020-04-12T14:50:00", "lines": 30, "newlines": 26, "modlines": 0, "user": "PANEL"}, "text": ")Attr DEFAULT(%+_)\n  $ type(input) intens(low) hilite(uscore) caps(on)\n)Body expand(\\\\) window(54,5)\n+Enter/Verify Data Set Name:\n%===>$verdsn                                        +\n+\n +Enter any data set name and press enter to verify.\n                     +F3 to Exit.\n)INIT\n  &zwinttl = 'Verify DSN Exists via Panel Rexx'\n)PROC\n &resp = .resp\n*REXX(* resp zedsmsg zedlmsg)\n if resp = 'END' then exit\n  parse value '' with zedsmsg zedlmsg\n  msgvalue = msg()              /* Save the current TSO Message State */\n  call msg 'off'                /* Turn off TSO Messages */\n  if sysdsn(verdsn) = 'OK' then do\n     zedsmsg = 'Confirmed'\n     zedlmsg = verdsn 'does exist.'\n     end\n  else do\n     zedsmsg = 'Failure'\n     zedlmsg = verdsn sysdsn(verdsn)\n     end\n  call msg msgvalue             /* Restore TSO Message State */\n*ENDREXX\n if (&zedsmsg NE &Z)\n    .MSG = ISRZ001\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXABC": {"ttr": 2820, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x07\\x01\\x19\\x07\\x9f\\x01\\x19\\t\\x1f\\x14%\\x00\\x0c\\x00\\x08\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-03-20T00:00:00", "modifydate": "2019-04-01T14:25:07", "lines": 12, "newlines": 8, "modlines": 0, "user": "REXX"}, "text": "/* --------------- REXX ------------------- *\n | Display the Action Bar ISPF Sample Panel |\n | ISPF - Developers - Tips and Tricks      |\n * ---------------------------------------- */\n Address ISPExec\n do forever\n    'addpop'\n    'display panel(pnabc)'\n    drc = rc\n    'rempop'\n    if drc > 0 then leave\n    end\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXAREA": {"ttr": 2822, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x002\\x01\\x19\\x08\\x7f\\x01\\x19\\x08\\x8f\\x10A\\x00\\t\\x00\\x06\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-03-28T00:00:00", "modifydate": "2019-03-29T10:41:32", "lines": 9, "newlines": 6, "modlines": 0, "user": "REXX"}, "text": "/* ---------------- REXX ----------------- *\n | Sample REXX to display the pnarea panel |\n | ISPF - Developers - Tips and Tricks     |\n * --------------------------------------- */\n Address ISPExec\n do forever\n   'display panel(pnarea)'\n   if rc > 0 then leave\n   end\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXCENTER": {"ttr": 2824, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00Q\\x01\\x19\\x04?\\x01\\x19\\x08\\x8f\\x10B\\x001\\x00\\x1c\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-02-12T00:00:00", "modifydate": "2019-03-29T10:42:51", "lines": 49, "newlines": 28, "modlines": 0, "user": "REXX"}, "text": "/* ---------------------- REXX ------------------------ *\n | Demonstration of processing records in a range.      |\n |                                                      |\n | ISPF - Developers - Tips and Tricks                  |\n |                                                      |\n | Center selected records.                             |\n |                                                      |\n | Record selection:                                    |\n |    C   -  individual record                          |\n |    C## -  ## records starting at the selected record |\n |    CC  -  paired for start and ending records        |\n |                                                      |\n | If no records selected then all are processed.       |\n |                                                      |\n | Can pass a data width to be used for the centering   |\n | when invoking this edit macro.                       |\n * ---------------------------------------------------- */\n  Address ISREdit\n/* ----------------------------------------------------- *\n | Indicate this is a macro and accept passed parms into |\n | variable macopt while NOT Processing any row cmds     |\n * ----------------------------------------------------- */\n  'Macro (dw) NOPROCESS'\n/* ------------------------------- *\n | Request Edit Identify any Range |\n * ------------------------------- */\n  \"Process Range C\"\n/* -------------------------------------------------------- *\n | Get the start (zfrange) and stop (zlrange) row locations |\n * -------------------------------------------------------- */\n  \"(start) = linenum .zfrange\"\n  \"(stop) = linenum .zlrange\"\n/* ---------------------------------------------- *\n | Test if a parm indicating the width to use for |\n | centering the text was passed. If not use the  |\n | actual data width.                             |\n * ---------------------------------------------- */\n  if dw = '' then\n  '(dw) = data_width'\n/* ----------------------------------------------- *\n | Loop through all the records from start to stop |\n | centering the data on each record and then      |\n | replacing the data on that row.                 |\n * ----------------------------------------------- */\n  do i = start to stop\n    '(data) = line' i\n    data = center(strip(data),dw)\n    'line' i '= (data)'\n  end\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXCMDS": {"ttr": 2826, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x006\\x01\\x19\\x10\\x0f\\x01\\x19\\x10\\x0f\\x07\\x15\\x00\\r\\x00\\x0b\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-04-10T00:00:00", "modifydate": "2019-04-10T07:15:36", "lines": 13, "newlines": 11, "modlines": 0, "user": "REXX"}, "text": " /* ------------------ REXX ---------------------- *\n  * Demonstrate File Tailoring by working with the *\n  * active ispf command table ISPCMDS to generate  *\n  * a report.                                      *\n  * ---------------------------------------------- */\n  Address ISPExec\n  table = 'ISPCMDS'\n  'vput (table)'\n  'ftopen temp'\n  'ftincl skcmds'\n  'ftclose'\n  'vget (ztempf)'\n  \"Browse dataset('\"ztempf\"')\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXDOALL": {"ttr": 2828, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x02\\x00!\\x01\\x19\\t?\\x01\\x19 ?\\x10'\\x007\\x008\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@\"", "ispf": {"version": "01.02", "flags": 0, "createdate": "2019-04-03T00:00:00", "modifydate": "2019-07-22T10:27:21", "lines": 55, "newlines": 56, "modlines": 0, "user": "REXX"}, "text": " /* ---------------------  rexx procedure  ---------------------- *\n  | Name:      DoAll                                              |\n  | ISPF - Developers - Tips and Tricks                           |\n  |                                                               |\n  | Function:  This rexx exec will process the specified          |\n  |            ispf edit macro against every member of the        |\n  |            specified partitioned dataset.                     |\n  |                                                               |\n  |            Only standard system services are used. The        |\n  |            LISTD TSO command with the MEMBERS keyword         |\n  |            is used to extract the member names.               |\n  |                                                               |\n  | Syntax:    %DoAll dsname edit-macro                           |\n  |                                                               |\n  | Sample Edit Macro to change SYS1 to SYS2 (name it chsys1t2):  |\n  |                                                               |\n  |  Address ISREDIT                                              |\n  |  \"MACRO\"                                                      |\n  |  \"CHANGE 'DSN=SYS1.' 'DSN=SYS2.' ALL\"                         |\n  |  \"SAVE\"                                                       |\n  |  \"END\"                                                        |\n  |                                                               |\n  | Sample Execution:  %Doall 'sys2.testjcl' chsys1t2             |\n  |                                                               |\n  * ------------------------------------------------------------- */\n\n  /* --------------------------------- *\n  | Get the target data set and macro |\n  * --------------------------------- */\n  arg dsn exec\n\n  /* ---------------------------------------- *\n  | Fix up data set name for use (no quotes) |\n  * ---------------------------------------- */\n  if left(dsn,1) <> \"'\" then do\n    dsn = sysvar(syspref)\".\"dsn\n  end\n  else do\n    dsn = substr(dsn,2,length(dsn)-2)\n  end\n\n  /* -------------------------- *\n  | Setup Outtrap and do ListD |\n  * -------------------------- */\n  x = outtrap(\"lm.\",\"*\")\n  \"LISTD\" \"'\"dsn\"'\" \"MEMBERS\"\n  x = outtrap(\"off\")\n\n  /* ------------------- *\n  | Process all members |\n  * ------------------- */\n  do i = 7 to lm.0\n    parse value lm.i with mem extra\n    Address ISPEXEC \"EDIT DATASET('\"dsn\"(\"mem\")') MACRO(\"exec\")\"\n  end\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXDYN": {"ttr": 2830, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00$\\x01\\x19\\x08o\\x01\\x19\\t\\x1f\\x12G\\x003\\x002\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-03-27T00:00:00", "modifydate": "2019-04-01T12:47:24", "lines": 51, "newlines": 50, "modlines": 0, "user": "REXX"}, "text": "/* REXX - A Dynamic area example */\n/* Doug Nadel, ISPF Panels - beyond the basics, March 2000            */\nAddress ISPEXEC                             /* Calls go to ISPF       */\nred   = '01'x                               /* Assign colors to       */\nblue  = '02'x                               /*     Attribute bytes    */\ngreen = '03'x                               /*     found in the data  */\nwhite = '04'x\nmaxlines = 600                              /* set max number of lines*/\ndyndata  = ''                               /* initialize data        */\nshadata  = ''                               /* initialize shadow var  */\n\nDo  a = 1 to maxlines by 3                  /* Create some dummy data */\n  dyndata=dyndata||white||left('This is'red  ||'red  'white||a  , 29)\n  dyndata=dyndata||white||left('This is'blue ||'blue 'white||a+1, 29)\n  dyndata=dyndata||white||left('This is'green||'green'white||a+2, 29)\n  shadata=shadata||' r                            '\n  shadata=shadata||' b                            '\n  shadata=shadata||' g                            '\nEnd\n\n/*    Add a bottom of data maker to the end of the data      */\ndyndata = dyndata||blue||centre(green||'BOTTOM'||blue,29,'*')\nshadata = shadata||'                              '\n\ncurline = 1;                                /* set current line #     */\n\n/* -------------------------------------------------------------------*/\n/* Display loop until end or error                                    */\n/* -------------------------------------------------------------------*/\n\nDo Until disprc > 0\n  dynarea = substr(dyndata,1+(curline-1)*30) /* set dynamic variable  */\n  dynshad = substr(shadata,1+(curline-1)*30) /* set shadow variable   */\n  size = length(dynarea)                   /* Set a scalar variable   */\n  'ISPEXEC DISPLAY PANEL(PNDYN)'           /* Display the data        */\n  disprc = rc                              /* save return code        */\n  'ISPEXEC VGET (ZVERB,ZSCROLLA,ZSCROLLN)' /* get scroll values       */\n  Select                                   /* Process scrolling       */\n    When(zverb = 'UP')   Then              /* Scroll up               */\n     If zscrolla = 'MAX' Then              /*  if scroll was max      */\n      curline = 1                          /*     scroll to top       */\n     Else                                  /*  else a number is known */\n      curline = max(1,curline-zscrolln);   /* (maximum is top)        */\n    When(zverb = 'DOWN') Then              /* Scroll down             */\n     If zscrolla = 'MAX' Then              /*  if scroll was max      */\n      curline = maxlines                   /*     scroll to bottom    */\n     Else                                  /*  else a number is known */\n      curline = min(maxlines,curline+zscrolln); /* (max is bottom)    */\n     Otherwise;                     /* could use left & right too     */\n  End\nEnd                                        /* End of display loop     */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXDYNTBL": {"ttr": 2832, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0e\\x00D\\x01 \\x10/\\x01 \\x10?\\x12Y\\x00\\xbf\\x00\\x95\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.14", "flags": 0, "createdate": "2020-04-11T00:00:00", "modifydate": "2020-04-12T12:59:44", "lines": 191, "newlines": 149, "modlines": 0, "user": "REXX"}, "text": "  /* ------------------------- REXX ----------------------------- *\n  | Sample REXX Exec to demonstrate how to dynamically add       |\n  | rows to a table while processing. This is primarily intended |\n  | for use with large amounts of data so that the user can get  |\n  | started using the table quickly, with a subset of the table  |\n  | rows. Then as the user scrolls the additional table rows     |\n  | are added.                                                   |\n  |                                                              |\n  | A popup panel will ask for the total number of records and   |\n  | the incremental number to add.                               |\n  |                                                              |\n  | A popup is used to inform the user the rows are about to     |\n  | be added - requiring the user to press enter to continue     |\n  | (otherwise the popup would disappear too fast).              |\n  |                                                              |\n  | Dependencies:                                                |\n  | ISPF Panels:  PNDYNTBL                                       |\n  |               PNPOPV                                         |\n  |               PNDYNTP                                        |\n  * ------------------------------------------------------------ *\n  |  ISPF - Developers - Tips and Tricks                         |\n  * ------------------------------------------------------------ */\n\n  /* ----------------------------------- *\n  | Define initial values for the table |\n  * ----------------------------------- */\n  total   = 10000\n  incrnum = 100\n\n  /* ------------------------------------------------- *\n  | Prompt the user to change the values if they want |\n  * ------------------------------------------------- */\n  Address ISPExec\n  'addpop row(4) column(4)'\n  'display panel(PNDYNTP)'\n  'rempop'\n\n  /* set our defaults */\n  parse value '' with null bottom\n\n  /* 1st build a stem with a bunch of records */\n  str = 'one two three four five six seven eight nine ten'\n  do i = 1 to total\n    off = i//10\n    if off = 0 then off = 10\n    stem.i = word(str,off) date(w) time('l')\n  end\n  stem.0 = total\n\n  /* now create the table and prime it with n records */\n  tbl = 'DT'time('s')   /* random table name */\n  Address ISPExec\n  'tbcreate' tbl 'names(data date time) nowrite'\n  ztdamtl = incrnum /* set initial # of rows to add */\n  last = 1            /* initialize the last record added */\n  ztdret = 'DOWN'     /* instruct tbdispl to return to us on DOWN */\n\n  c = 0                         /* set row added counter    */\n  call start_time               /* Get start time for routine */\n  x = add_rows()                /* call routine to add rows */\n  call end_time                 /* get end time for routine */\n\n  /* ---------------------------------------------------- *\n  | Display the table of records                         |\n  | - if the scoll is past the bottom then add more rows |\n  * ---------------------------------------------------- */\n  dtop = 1                      /* set top of table variable */\n\n  do forever\n    'tbtop' tbl                      /* Get to the top of the table */\n    'tbskip' tbl 'number('dtop')'    /* Scroll down to where the user\n    scrolled last */\n    'tbdispl' tbl 'panel(pndyntbl)'  /* display the table */\n    if rc > 0 then leave             /* Leave if F3/End requested */\n    dtop = ztdtop                   /* save the top displayed row */\n    'vget (zscrolla)'               /* get scroll amount          */\n    /* query the table for information */\n    'tbquery' tbl 'rownum(totrows) position(pos)'\n\n    /* -------------------------------------------------------- *\n    | if ztdadd is YES (indicating TBDISPL wants more rows to  |\n    | to added then test if all records have been added.       |\n    * -------------------------------------------------------- */\n    if ztdadd = 'YES' then      /* Add more rows ? */\n    if totrows = stem.0         /* if Yes have all records been added */\n    then ztdadd = 'NO'          /* If all added change ztdadd to NO */\n    if zscrolla = 'CSR' then    /* Test scroll amount for CSR */\n    if pos = 0 then do          /* If CSR then is cursor at 0 */\n      dtop = dtop + ztdvrows    /* If at 0 then down down 1 screen of data */\n      if dtop >= totrows then   /* If top >= total rows */\n      dtop = totrows - ztdvrows +1  /* then reset the top row */\n    end\n    if ztdadd = 'YES' then do forever   /* Request to add more rows */\n      c = 0                             /* Set added counter */\n      if zscrolla = 'MAX' then ztdamtl = stem.0  /* test for max */\n      call start_time\n      x = add_rows()                   /* call add_rows subroutine */\n      call end_time\n      if c > 0 then do          /* records added */\n        if ZTDSCRP > 0 then     /* update top row to display */\n        dtop = ZTDSCRP\n        else do\n          /* ------------------------------------ *\n          | Test to setup the top row to display |\n          * ------------------------------------ */\n          'tbquery' tbl 'rownum(totrows) position(pos)'\n          if datatype(zscrolla) /= 'NUM'\n          then if zscrolla /= 'MAX'\n          then zscrolla = 0\n          if zscrolla = 'MAX'\n          then dtop = totrows - ztdvrows +1  /* adjust to see the bottom row */\n          else dtop = dtop + zscrolla\n        end\n        leave\n      end\n      if x > 0 then bottom = 1  /* set the bottom flag if all records\n      are added */\n      if bottom = 1 then leave  /* if at bottom then leave add loop */\n    end\n  end\n\n  /* ------------------------------------ *\n  | Done so need to close the ISPF table |\n  | and then Exit                        |\n  * ------------------------------------ */\nDone:\n  'tbend' tbl\n  Exit\n\n  /* ------------------------------------------------------ *\n  | Add more rows to the table                             |\n  | - test amount to add and if < 100 make it 100          |\n  | - skip to the bottom of the table to start adding rows |\n  | - begin adding the the last row added                  |\n  * ------------------------------------------------------ */\nAdd_Rows:\n  if bottom = 1 then return 8   /* If already at the bottom then return\n  quickly */\n  msg1 = 'Adding more records.'\n  msg2 = 'Starting with record' last\n  call pop                      /* Inform the user of the adds in\n  progress */\n  if ztdamtl < incrnum          /* add at least n each time */\n  then ztdamtl = incrnum\n  'tbbottom' tbl                /* Get to the bottom of the table to\n  start */\n  do i = last to last+ztdamtl\n    if i > stem.0 then do\n      last = i\n      return 8\n    end\n    parse value stem.i with data date time\n    'tbadd' tbl\n    c = c + 1\n  end\n  last = i\n  return 0\n\n  /* ----------------------- *\n  | Popup information panel |\n  * ----------------------- */\npop:\n  'addpop row(4) column(3)'\n  'display panel(pnpopv)'\n  'rempop'\n  return\n\n  /* ------------------------------------ *\n  | Save starting service units and time |\n  * ------------------------------------ */\nStart_time:\n  s_service = sysvar('SYSSRV')\n  s_time    = sysvar('SYSCPU')\n  return\n\n  /* -------------------------------------------- *\n  | Get the end service units count and end time |\n  | Calculate the delta                          |\n  | Report out                                   |\n  * -------------------------------------------- */\nEnd_time:\n  e_service = sysvar('SYSSRV')\n  e_time    = sysvar('SYSCPU')\n\n  total_service = e_service - s_service\n  total_time    = e_time    - s_time\n\n  zedsmsg = 'Time:' total_time 'seconds'\n  zedlmsg = 'Total Service:' total_service 'Total Time:' total_time 'seconds.'\n  'setmsg msg(isrz001)'\n  return\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXEDITHL": {"ttr": 2836, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00E\\x01\\x196\\x0f\\x01\\x196\\x0f\\x13 \\x00\\n\\x00\\x08\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2019-12-26T00:00:00", "modifydate": "2019-12-26T13:20:45", "lines": 10, "newlines": 8, "modlines": 0, "user": "REXX"}, "text": "/* ---------------------- REXX ------------------------------- *\n * Drive the PNEDITHL ISPF Edit panel that has been customized *\n * to colorize records based on the content of the records.    *\n * ----------------------------------------------------------- */\n parse source src\n parse var src x1 x2 x3 dd .\n x = listdsi(dd 'FILE')\n sdsn = \"'\"sysdsname\"(sampgit)'\"\n  address ispexec\n  'View dataset('sdsn') panel(pnedithl) macro(rxmedhl)'\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXEM": {"ttr": 2838, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x15\\x01\\x19\\t\\x8f\\x01\\x19\\x10\\x7f\\t\\x13\\x00\\x1d\\x00\\x05\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-04-08T00:00:00", "modifydate": "2019-04-17T09:13:15", "lines": 29, "newlines": 5, "modlines": 0, "user": "MACRO"}, "text": "  /* ------------------------ REXX ---------------------------- *\n  | This ISPF Edit macro demonstrates how to change the        |\n  | action of an ISPF Edit command. In this case both the      |\n  | END and SAVE commands are changed by making them an        |\n  | ALIAS of REXX Edit Macros.                                 |\n  |                                                            |\n  | The edit macros will not allow either the Save or the End  |\n  | commands to be used unless the user first enters the word  |\n  | DONE (in any case) in any record of the data being edited. |\n  * ---------------------------------------------------------- */\n  Address ISREdit\n  'Macro'                       /* First indicate we are an Edit Macro */\n  'Reset all'                   /* Then Reset to turn off all messages */\n  'Define end  alias rxeme'     /* Now define END as an Alias */\n  'Define save alias rxems'     /* And Save as an Alias */\n  'caps off'                    /* Now turn off Caps */\n  'numbers off'                /* and turn Numbers off as well */\n\n  /* ---------------------------------------------------- *\n  | Now insert some message lines to given the user some |\n  | idea of what's happening.                            |\n  * ---------------------------------------------------- */\n  text = 'This demonstrates changing the Save and End commands.'\n  'line_after .zfirst = msgline (text) '\n  text = 'Enter the word DONE (any case) in a record to allow Save' ,\n    'or End to work.'\n  'line_after .zfirst = msgline (text) '\n  text = 'Or enter the CANCEL command to exit ISPF Edit.'\n  'line_after .zfirst = msgline (text) '\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXEMAC": {"ttr": 2840, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x004\\x01\\x19\\x07\\x8f\\x01\\x19\\x08\\x8f\\x10C\\x00\\x12\\x00\\x04\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-03-19T00:00:00", "modifydate": "2019-03-29T10:43:34", "lines": 18, "newlines": 4, "modlines": 0, "user": "REXX"}, "text": "/* --------------- REXX -------------- *\n | Sample ISPF Edit Macro              |\n | ISPF - Developers - Tips and Tricks |\n * ----------------------------------- */\n  Address ISREdit         /* Get into ISPF Edit environment */\n  'macro (macopt)'        /* Indicate we are a macro */\n  'caps off'              /* Turn Caps Off */\n  'number off'            /* Turn numbers off */\n  'recovery on'           /* Enable Recovery */\n/* --------------------- *\n | Insert 2 data records |\n * --------------------- */\n  \"line_after .zfirst = 'This is line number 1'\"\n  \"line_after .zfirst = 'This is line number 2'\"\n/* ------------------------------------------------- *\n | Insert a message line with the parm text (macopt) |\n * ------------------------------------------------- */\n  'line_before .zfirst = msgline (macopt)'\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXEMACE": {"ttr": 3073, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00B\\x01\\x19\\x07\\x8f\\x01\\x19\\x08\\x8f\\x10C\\x00)\\x00\\x08\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-03-19T00:00:00", "modifydate": "2019-03-29T10:43:42", "lines": 41, "newlines": 8, "modlines": 0, "user": "REXX"}, "text": "  /* ------------------ REXX --------------------- *\n  | Demonstrate calling ISPF Edit from REXX while |\n  | invoking an Edit Macro and passing data to    |\n  | the Edit Macro.                               |\n  | ISPF - Developers - Tips and Tricks           |\n  * --------------------------------------------- */\n  /* -------------------- *\n  | Create random DDname |\n  * -------------------- */\n  dd = 'DD'random(99999)\n  /* ----------------------------- *\n  | Allocate a temporary data set |\n  * ----------------------------- */\n  'alloc f('dd') ds(temp.text) new spa(1,1) tr' ,\n    'recfm(f b) lrecl(80) blksize(32720)'\n  /* ------------------------- *\n  | Setup the macro parameter |\n  * ------------------------- */\n  macopt = 'This is a test of the ISPF Edit Macro Parm'\n  /* ------------------------------ *\n  | Change to the ISPF Environment |\n  * ------------------------------ */\n  Address ISPExec\n  /* -------------------------------- *\n  | Save current display environment |\n  * -------------------------------- */\n  'Control Display Save'\n  /* --------------------------------------------- *\n  | Edit the dataset while specifying a macro and |\n  | a parameter.                                  |\n  * --------------------------------------------- */\n  'Edit Dataset(temp.text) Macro(rxemac) Parm(macopt)'\n  /* ------------------------------- *\n  | Restore the display environment |\n  * ------------------------------- */\n  'Control Display Restore'\n  /* ------------------------------------------ *\n  | Return to TSO and Free/Delete the data set |\n  * ------------------------------------------ */\n  Address TSO\n  'free f('dd') delete'\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXEME": {"ttr": 3075, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x19\\x01\\x19\\t\\x8f\\x01\\x19\\t\\x8f\\x12\\x01\\x00\\x18\\x00\\x0c\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-04-08T00:00:00", "modifydate": "2019-04-08T12:01:19", "lines": 24, "newlines": 12, "modlines": 0, "user": "MACRO"}, "text": "  /* ------------------------ REXX ------------------------ *\n  | Sample ISPF Edit Macro to replace the ISPF Edit END    |\n  | command until the user enters the word Done (any case) |\n  | on any record in the data.                             |\n  * ------------------------------------------------------ */\n  Address ISREdit               /* Setup Addressing to ISPF Edit */\n  'Macro'                       /* Indicate we are a macro */\n  \"Find 'done' first\"           /* Do a FIND for the word 'DONE' */\n  if rc = 0 then do             /* if found then: */\n    'define end reset'          /* Reset the alias definition for END */\n    'define save reset'         /* Reset the alias definition for SAVE */\n    'end'                       /* Do the real Edit END command */\n    exit 0                      /* And edit the macro */\n  end\n  /* ----------------------------------------------------- *\n  | If 'DONE' is not found then tell the user that they   |\n  | can not end ISPF Edit until it is found or the CANCEL |\n  | command is used.                                      |\n  * ----------------------------------------------------- */\n  zedsmsg = 'Warning'\n  zedlmsg = left('To exit ISPF Edit enter the word DONE somewhere',75) ,\n    'in the text or enter the CANCEL command.'\n  Address ISPExec\n  'setmsg msg(isrz001)'\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXEMS": {"ttr": 3077, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x008\\x01\\x19\\t\\x8f\\x01\\x19\\t\\x8f\\x12\\x00\\x00\\x16\\x00\\x0c\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-04-08T00:00:00", "modifydate": "2019-04-08T12:00:38", "lines": 22, "newlines": 12, "modlines": 0, "user": "MACRO"}, "text": "  /* ------------------------ REXX ------------------------ *\n  | Sample ISPF Edit Macro to replace the ISPF Edit SAVE   |\n  | command until the user enters the word Done (any case) |\n  | on any record in the data.                             |\n  * ------------------------------------------------------ */\n  Address ISREdit               /* Setup Addressing to ISPF Edit */\n  'Macro'                       /* Indicate we are a macro */\n  \"Find 'done' first\"           /* Do a FIND for the word 'DONE' */\n  if rc = 0 then do             /* if found then: */\n    'SAVE'                      /* Do the real Edit SAVE command */\n    exit 0                      /* And edit the macro */\n  end\n  /* ----------------------------------------------------- *\n  | If 'DONE' is not found then tell the user that they   |\n  | can not SAVE the data until it is found or the CANCEL |\n  | command is used.                                      |\n  * ----------------------------------------------------- */\n  zedsmsg = 'Warning'\n  zedlmsg = left('To Save the data enter the word DONE somewhere',75) ,\n    'in the text or enter the CANCEL command to exit.'\n  Address ISPExec\n  'setmsg msg(isrz001)'\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXEMTRY": {"ttr": 3079, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x003\\x01\\x19\\t\\x8f\\x01\\x19\\t\\x8f\\x12\\x03\\x00\\x0c\\x00\\x04\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-04-08T00:00:00", "modifydate": "2019-04-08T12:03:33", "lines": 12, "newlines": 4, "modlines": 0, "user": "REXX"}, "text": "/* ------------------------ REXX -------------------------- *\n | Driver REXX to demonstrate the use of ISPF Command       |\n | Aliases by Editing the ztempf (temp data set) while      |\n | invoking the RXEM Edit Macro that will Alias both the    |\n | ISPF End and Save commands. This change will prevent the |\n | user from using either END or SAVE until the word DONE   |\n | (in any case - upper/lower/mixed) is entered on a data   |\n | record.                                                  |\n * -------------------------------------------------------- */\nAddress ISPExec\n'vget (ztempf)'\n\"Edit dataset('\"ztempf\"') macro(rxem)\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXFLD": {"ttr": 3081, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00I\\x01\\x19\\x07\\x9f\\x01\\x19\\x08\\x8f\\x10C\\x00\\n\\x00\\x06\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-03-20T00:00:00", "modifydate": "2019-03-29T10:43:49", "lines": 10, "newlines": 6, "modlines": 0, "user": "REXX"}, "text": "/* --------------------- REXX ------------------------ *\n | REXX code to drive the demonstration of Field Level |\n | Help in an ISPF Panel                               |\n | ISPF - Developers - Tips and Tricks                 |\n * --------------------------------------------------- */\n  Address ISPExec\n  do forever\n    'Display Panel(PNFLDH)'\n    if rc > 0 then leave\n  end\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXIVAR": {"ttr": 3083, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x07\\x01\\x19\\x12o\\x01\\x19\\x12o\\x07\\x15\\x00\\n\\x00\\n\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-05-06T00:00:00", "modifydate": "2019-05-06T07:15:07", "lines": 10, "newlines": 10, "modlines": 0, "user": "REXX"}, "text": "/* ------------------------- rexx-------------------------- *\n * IVAR - display the contents of the ispf variable that is *\n * passed as an argument.                                   *\n * -------------------------------------------------------- */\n  arg var\n  address ispexec 'vget ('var zapplid')'\n  say 'Requested variable' var 'in ISPF Applid' zapplid 'value is:'\n  say ' '\n  interpret 'str ='var\n  say '>'str'<'\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXLISPF": {"ttr": 3085, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00A\\x01\\x19)o\\x01\\x19)o\\x06)\\x01\\xb1\\x01\\xad\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-10-23T00:00:00", "modifydate": "2019-10-23T06:29:41", "lines": 433, "newlines": 429, "modlines": 0, "user": "REXX"}, "text": "  /* ------------------------- REXX -------------------------------- *\n  | Sample to demonstrate using the LOADISPF routines to dynamically |\n  | load/libdef an ISPF Panel, an ISPF Message, and an ISPF Skeleton.|\n  | Note that LOADISPF can also be used for other CLISTs and EXECs   |\n  | which will result in an ALTLIB.                                  |\n  |                                                                  |\n  | Scroll down to the LOADISPF routine for additional comments      |\n  | on how to use it.                                                |\n  |                                                                  |\n  | Note: the DROPISPF routine is included in the LOADISPF package   |\n  | to make things easy.                                             |\n  |                                                                  |\n  | The imbedded elements are after the >Start record found below.   |\n  |                                                                  |\n  | ISPF - Developers - Tips and Tricks                              |\n  * ---------------------------------------------------------------- */\n\n  /* ----------------------------------- *\n  | First set the Addressing to ISPExec |\n  * ----------------------------------- */\n  Address ISPExec\n  /* ------------------------------- *\n  | Now invoke the LOADISPF routine |\n  * ------------------------------- */\n  loadinfo = loadispf()\n  /* ------------------------------ *\n  | 1st Example is an ISPF Message |\n  * ------------------------------ */\n  msgsmsg = 'Press F1 to Read'\n  msglmsg = 'This is a Longer Message using a ISPF message that is' ,\n    \"dynamically loaded and libdef'd using LoadISPF.\"\n  'setmsg msg(msg001)'\n  /* --------------------------------- *\n  | Now display the loaded ISPF Panel |\n  * --------------------------------- */\n  'Display Panel(p1)'\n  /* --------------------------------------------- *\n  | Next File Tailor an ISPF Skeleton and view it |\n  * --------------------------------------------- */\n  'ftopen temp'\n  'ftincl tskel'\n  'ftclose'\n  'vget (ztempf)'\n  \"View dataset('\"ztempf\"')\"\n /* ------------------------------------------- *\n  | Now demonstrate the dynamically loaded rexx |\n  * ------------------------------------------- */\n  Address TSO ,\n  '%texec'\n  /* ----------------------- *\n  | Now deallocate and exit |\n  * ----------------------- */\n  x = dropispf(loadinfo)\n  exit\n\n/* --------------------  rexx procedure  -------------------- *\n * Name:      LoadISPF                                        *\n *                                                            *\n * Function:  Load ISPF elements that are inline in the       *\n *            REXX source code.                               *\n *                                                            *\n * Syntax:    load_info = loadispf()                          *\n *            rc = dropispf(load_info)                        *\n *                                                            *\n *            The inline ISPF resources are limited to        *\n *            ISPF Messages, Panels, and Skeletons,           *\n *                 CLISTs and EXECs are also supported.       *\n *                                                            *\n *            The inline resources must start in column 1     *\n *            and use the following syntax:                   *\n *                                                            *\n *            >START    used to indicate the start of the     *\n *                      inline data                           *\n *                                                            *\n *            >END    - used to indicate the end of the       *\n *                      inline data                           *\n *                                                            *\n *            Each resource begins with a type record:        *\n *            >type name                                      *\n *               where type is CLIST, EXEC, MSG, PANEL, SKEL  *\n *                     name is the name of the element        *\n *                                                            *\n * Sample usage:                                              *\n *          -* rexx *-                                        *\n *          load_info = loadispf()                            *\n *          ... magic code happens here (your code) ...       *\n *          rc = dropispf(load_info)                          *\n *          exit                                              *\n *          >Start inline elements                            *\n *          >Panel panel1                                     *\n *          ...                                               *\n *          >Msg msg1                                         *\n *          ...                                               *\n *          >End of inline elements                           *\n *                                                            *\n * Returns:   the list of ddnames allocated for use along     *\n *            with the libdef's performed or altlib           *\n *                                                            *\n *            format is ddname libdef ddname libdef ...       *\n *                   libdef may be altlibc or altlibe         *\n *                   for altlib clist or altlib exec          *\n *                                                            *\n * Notes:     Entire routine must be included with REXX       *\n *            exec - inline with the code.                    *\n *                                                            *\n * Comments:  The entire rexx program is processed from the   *\n *            last record to the first to find the >START     *\n *            record at which point all records from that     *\n *            point on are processed until the >END           *\n *            statement or the end of the program is found.   *\n *                                                            *\n *            It is *strongly* suggested that the inline      *\n *            elements be at the very end of your code so     *\n *            that the search for them is faster.             *\n *                                                            *\n *            Inline ISPTLIB or ISPLLIB were not supported    *\n *            because the values for these would have to be   *\n *            in hex.                                         *\n *                                                            *\n * Author:    Lionel B. Dyck                                  *\n *                                                            *\n * History:                                                   *\n *            01/09/19 - Include DROPISPF routine             *\n *            08/29/17 - Fixup static values that were vars   *\n *            05/31/17 - Change default directory count       *\n *            12/09/16 - update for add_it routine            *\n *            05/10/16 - correction for clist and exec        *\n *            04/19/16 - bug correction                       *\n *            06/04/04 - Enhancements for speed               *\n *            08/05/02 - Creation                             *\n *                                                            *\n * ---------------------------------------------------------- *\n * Disclaimer: There is no warranty, either explicit or       *\n * implied with this code. Use it at your own risk as there   *\n * is no recourse from either the author or his employeer.    *\n * ---------------------------------------------------------- */\nLoadISPF: Procedure\n\n  parse value \"\" with null kmsg kpanel kskel first returns ,\n    kclist kexec\n/* ------------------------------------------------------- *\n * Find the InLine ISPF Elements and load them into a stem *\n * variable.                                               *\n *                                                         *\n * Elements keyword syntax:                                *\n * >START - start of inline data                           *\n * >CLIST name                                             *\n * >EXEC name                                              *\n * >MSG name                                               *\n * >PANEL name                                             *\n * >SKEL name                                              *\n * >END   - end of all inline data (optional if last)      *\n * ------------------------------------------------------- */\n  last_line = sourceline()\n  do i = last_line to 1 by -1\n    line = sourceline(i)\n    if translate(left(line,6)) = \">START \" then leave\n  end\n  rec = 0\n/* --------------------------------------------------- *\n * Flag types of ISPF resources by testing each record *\n * then add each record to the data. stem variable.    *\n * --------------------------------------------------- */\n  do j = i+1 to last_line\n    line = sourceline(j)\n    if translate(left(line,5)) = \">END \"   then leave\n    if translate(left(line,7)) = \">CLIST \" then kclist = 1\n    if translate(left(line,6)) = \">EXEC \"  then kexec  = 1\n    if translate(left(line,5)) = \">MSG \"   then kmsg   = 1\n    if translate(left(line,7)) = \">PANEL \" then kpanel = 1\n    if translate(left(line,6)) = \">SKEL \"  then kskel  = 1\n    rec  = rec + 1\n    data.rec = line\n  end\n\n/* ----------------------------------------------------- *\n * Now create the Library and Load the Member(s)         *\n * ----------------------------------------------------- */\n  Address ISPExec\n/* ----------------------------- *\n * Assign dynamic random ddnames *\n * ----------------------------- */\n  clistdd = \"lc\"random(999)\n  execdd  = \"le\"random(999)\n  msgdd   = \"lm\"random(999)\n  paneldd = \"lp\"random(999)\n  skeldd  = \"ls\"random(999)\n\n/* ---------------------------------------- *\n *  LmInit and LmOpen each resource library *\n * ---------------------------------------- */\n  if kclist <> null then do\n    call alloc_dd clistdd\n    \"Lminit dataid(clist) ddname(\"clistdd\")\"\n    \"LmOpen dataid(\"clist\") Option(Output)\"\n    returns = strip(returns clistdd 'ALTLIBC')\n  end\n  if kexec <> null then do\n    call alloc_dd execdd\n    \"Lminit dataid(exec) ddname(\"execdd\")\"\n    \"LmOpen dataid(\"exec\") Option(Output)\"\n    returns = strip(returns execdd 'ALTLIBE')\n  end\n  if kmsg <> null then do\n    call alloc_dd msgdd\n    \"Lminit dataid(msg) ddname(\"msgdd\")\"\n    \"LmOpen dataid(\"msg\") Option(Output)\"\n    returns = strip(returns msgdd 'ISPMLIB')\n  end\n  if kpanel <> null then do\n    call alloc_dd paneldd\n    \"Lminit dataid(panel) ddname(\"paneldd\")\"\n    \"LmOpen dataid(\"panel\") Option(Output)\"\n    returns = strip(returns paneldd 'ISPPLIB')\n  end\n  if kskel <> null then do\n    call alloc_dd skeldd\n    \"Lminit dataid(skel) ddname(\"skeldd\")\"\n    \"LmOpen dataid(\"skel\") Option(Output)\"\n    returns = strip(returns skeldd 'ISPSLIB')\n  end\n\n/* ----------------------------------------------- *\n * Process all records in the data. stem variable. *\n * ----------------------------------------------- */\n  do i = 1 to rec\n    record = data.i\n    recordu = translate(record)\n    if left(recordu,5) = \">END \" then leave\n    if left(recordu,7) = \">CLIST \" then do\n      if first = 1 then call add_it\n      type = \"Clist\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n    if left(recordu,6) = \">EXEC \" then do\n      if first = 1 then call add_it\n      type = \"Exec\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n    if left(recordu,5) = \">MSG \" then do\n      if first = 1 then call add_it\n      type = \"Msg\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n    if left(recordu,7) = \">PANEL \" then do\n      if first = 1 then call add_it\n      type = \"Panel\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n    if left(recordu,6) = \">SKEL \" then do\n      if first = 1 then call add_it\n      type = \"Skel\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n   /* --------------------------------------------*\n    * Put the record into the appropriate library *\n    * based on the record type.                   *\n    * ------------------------------------------- */\n    Select\n      When type = \"Clist\" then\n      \"LmPut dataid(\"clist\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(255)\"\n      When type = \"Exec\" then\n      \"LmPut dataid(\"exec\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(255)\"\n      When type = \"Msg\" then\n      \"LmPut dataid(\"msg\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(80)\"\n      When type = \"Panel\" then\n      \"LmPut dataid(\"panel\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(80)\"\n      When type = \"Skel\" then\n      \"LmPut dataid(\"skel\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(80)\"\n      Otherwise nop\n    end\n  end\n  if type <> null then call add_it\n/* ---------------------------------------------------- *\n * Processing completed - now lmfree the allocation and *\n * Libdef the library.                                  *\n * ---------------------------------------------------- */\n  if kclist <> null then do\n    Address TSO,\n      \"Altlib Act Application(Clist) File(\"clistdd\")\"\n    \"LmFree dataid(\"clist\")\"\n  end\n  if kexec <> null then do\n    Address TSO,\n      \"Altlib Act Application(Exec) File(\"execdd\")\"\n    \"LmFree dataid(\"exec\")\"\n  end\n  if kmsg <> null then do\n    \"LmFree dataid(\"msg\")\"\n    \"Libdef ISPMlib Library ID(\"msgdd\") Stack\"\n  end\n  if kpanel <> null then do\n    \"Libdef ISPPlib Library ID(\"paneldd\") Stack\"\n    \"LmFree dataid(\"panel\")\"\n  end\n  if kskel <> null then do\n    \"Libdef ISPSlib Library ID(\"skeldd\") Stack\"\n    \"LmFree dataid(\"skel\")\"\n  end\n  return returns\n\n/* --------------------------- *\n * Add the Member using LmmAdd *\n * based upon type of resource *\n * --------------------------- */\nAdd_It:\n  Select\n    When type = \"Clist\" then\n    \"LmmAdd dataid(\"clist\") Member(\"name\")\"\n    When type = \"Exec\" then\n    \"LmmAdd dataid(\"exec\") Member(\"name\")\"\n    When type = \"Msg\" then\n    \"LmmAdd dataid(\"msg\") Member(\"name\")\"\n    When type = \"Panel\" then\n    \"LmmAdd dataid(\"panel\") Member(\"name\")\"\n    When type = \"Skel\" then\n    \"LmmAdd dataid(\"skel\") Member(\"name\")\"\n    Otherwise nop\n  end\n  type = null\n  return\n\n/* ------------------------------ *\n * ALlocate the temp ispf library *\n * ------------------------------ */\nAlloc_DD:\n  arg dd\n  Address TSO\n  if pos(left(dd,2),\"lc le\") > 0 then\n  \"Alloc f(\"dd\") unit(sysda) spa(5,5) dir(5)\",\n    \"recfm(v b) lrecl(255) blksize(32760)\"\n  else\n  \"Alloc f(\"dd\") unit(sysda) spa(5,5) dir(5)\",\n    \"recfm(f b) lrecl(80) blksize(23440)\"\n  return\n\n/* --------------------  rexx procedure  -------------------- *\n * Name:      DropISPF                                        *\n *                                                            *\n * Function:  Remove ISPF LIBDEF's and deactivate ALTLIB's    *\n *            that were created by the LoadISPF function.     *\n *                                                            *\n * Syntax:    rc = dropispf(load_info)                        *\n *                                                            *\n * Author:    Janko                                           *\n *                                                            *\n * History:                                                   *\n *            12/05/18 - Creation                             *\n * ---------------------------------------------------------- */\nDropISPF: Procedure\n  arg load_info\n  Address ISPEXEC\n  do until length(load_info) = 0\n    parse value load_info with dd libd load_info\n    if left(libd,6) = \"ALTLIB\" then do\n      if libd = \"ALTLIBC\" then lib = \"CLIST\"\n      else lib = \"EXEC\"\n      Address TSO,\n        \"Altlib Deact Application(\"lib\")\"\n    end\n    else \"libdef\" libd\n    address tso \"free f(\"dd\")\"\n  end\n  return 0\n\n  /*  The data from >Start to >End is the imbedded data that will\n      become ispf panels, skels, and a message. */\n>Start\n>Panel P1\n)attr\n)body expand(\\\\)\n%Demo+\\-\\%Demo+\\-\\%Demo\n%Command ===>_zcmd\n+\n+This is a demonstration of dynamically loading ISPF elements. This is\n%obviously+an ISPF panel.\n+\n+This demonstration shows how to dynamically load:\n %Rexx Exec      ALTLIB\n %ISPF Message   ISPMLIB\n %ISPF Panel     ISPPLIB\n %ISPF Skeleton  ISPTLIB\n+\n +Press%F1+to view the long message (%the short is at the top right+)\n+\n +Enter%ISPLIBD+to view the LIBDEF libraries.\n+\n +Press%Enter+to continue.\n)Init\n)Proc\n)End\n>msg MSG00\nMSG001   '&msgsmsg                ' .ALARM=NO .HELP=*\n'&msglmsg'\n>Skel tskel\nWhat follows is a short report of the dynamically allocated\ndatasets by ddname and by type from the use of the LOADISPF\nroutine:\n------------------------------------------------------------\n)REXX STACKN loadinfo\n \"delstack\"\n do i = 1 to words(loadinfo) by 2\n ddn = translate(word(loadinfo,i))\n type = word(loadinfo,i+1)\n queue 'DDname is:' left(ddn,8) 'DD Type is:' type\n end\n stackn = queued()\n)ENDREXX\n)DO N = 1 TO &STACKN\n)REXX DATA\n parse pull data\n)ENDREXX\n&data\n)ENDDO\n>exec texec\n/* rexx */\nsay 'this is from the dynamically loaded rexx exec'\n>End\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXLMD": {"ttr": 3330, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00X\\x00\\x93\\x07\\x7f\\x01\\x19\\x08\\x8f\\x10C\\x00:\\x00\\x10\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1993-03-18T00:00:00", "modifydate": "2019-03-29T10:43:58", "lines": 58, "newlines": 16, "modlines": 0, "user": "REXX"}, "text": "/* ------------------------ rexx ---------------------------- *\n | This REXX code demonstrates using the LMDLIST ISPF Service |\n | to list information about data sets under the provided     |\n | high-level-qualifier (hlq).                                |\n |                                                            |\n | If no hlq is provided then the users prefix or userid      |\n | will be used.                                              |\n |                                                            |\n | ISPF - Developers - Tips and Tricks                        |\n * ---------------------------------------------------------- */\n  arg hlq\n/* -------------------------------- *\n | initialize our working variables |\n * -------------------------------- */\n  parse value '' with null dsn\n  parse value '0 0 0' with total count used\n\n/* --------------------------- *\n | Validate and/or set the HLQ |\n * --------------------------- */\n  if hlq = null then do\n    if sysvar('syspref') /= null then\n    hlq = sysvar('syspref')\n    else hlq = sysvar('sysuid')\n  end\n\n/* ----------------------- *\n | Define ISPF Environment |\n * ----------------------- */\n  Address ISPEXEC\n/* ------------- *\n | Setup LMDINIT |\n * ------------- */\n  \"Lmdinit Listid(LMD) Level(\"hlq\")\"\n/* ----------------------------------- *\n | Process ALL data sets under the HLQ |\n * ----------------------------------- */\n  do forever\n    \"Lmdlist Listid(\"lmd\") Stats(YES) Dataset(dsn) Option(LIST)\"\n/* ---------------------------- *\n | If return > 0 then finish up |\n * ---------------------------- */\n    if rc > 0 then do\n      \"Lmdfree listid(\"lmd\")\"\n      say \"All done - count:\" count 'used:' used\n      exit 4\n    end\n/* ----------------------------- *\n | Update counter and report out |\n * ----------------------------- */\n    count = count + 1\n    say count\":\" \"Dataset:\" dsn \"Vol:\" zdlvol \"Used:\" zdlsize ,\n      \"Device: *\"zdldev\"*\" ,\n      \"Mig:\" zdlmigr\n    sysvolume = \"\"\n    if datatype(zdlsize) = 'NUM' then\n    used = used + zdlsize\n  end\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXLMM": {"ttr": 3332, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00'\\x00\\x93\\x07o\\x01\\x19\\x08\\x8f\\x10D\\x00H\\x00\\x1b\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "1993-03-17T00:00:00", "modifydate": "2019-03-29T10:44:27", "lines": 72, "newlines": 27, "modlines": 0, "user": "REXX"}, "text": "/* ------------------- REXX-------------------------------- *\n * This routine will demonstrate the use of LMMLIST         *\n *                                                          *\n * Syntax:  %rxlmm dsname member                            *\n *                                                          *\n * where member is optional and may be a prefix (e.g. xxx*) *\n *                                                          *\n * ISPF - Developers - Tips and Tricks                      *\n * -------------------------------------------------------- */\n arg dsn imem\n if dsn = \"\" then exit 8\n\n/* ------------------ *\n * Define ISPF Dataid *\n * ------------------ */\n Address ISPEXEC\n \"LMINIT DATAID(STATUS) DATASET(\"dsn\")\"\n \"LMOPEN DATAID(\"STATUS\") OPTION(INPUT)\"\n/* ------------ *\n * Set defaults *\n * ------------ */\n parse value \"\" with member mem. ,\n         ZLCDATE ZLMDATE ZLVERS ZLMOD ZLMTIME ZLCNORC,\n         ZLINORC ZLMNORC ZLUSER ,\n         zlcnorce zlinorce zlmnorce\n mem.0  = 0\n\n/* ----------------------- *\n * Now process all members *\n * ----------------------- */\n do forever\n    if length(imem) = 0 then\n      \"LMMLIST Dataid(\"status\") OPTION(LIST) MEMBER(MEMBER)\" ,\n              \"STATS(YES)\"\n    else\n      \"LmmList Dataid(\"status\") Option(List) Member(member)\",\n              \"Pattern(\"imem\") stats(yes)\"\n    if rc = 4 then do\n       say 'no members found matching pattern'\n       exit\n       end\n   /* --------------------------------- *\n    * If RC 8 or more leave the do loop *\n    * --------------------------------- */\n    if rc > 7 then leave\n   /* ------------------------------ *\n    * Add each member info to a stem *\n    * ------------------------------ */\n    c = mem.0 + 1\n    mem.c = member ,\n        ZLCDATE  ZLMDATE  ZLVERS ZLMOD ZLMTIME ZLCNORC ,\n        ZLINORC ZLMNORC ZLUSER ,\n        zlcnorce zlinorce zlmnorce\n    mem.0 = c\n    end\n\n/* ------------------------- *\n * Close and Free the Dataid *\n * ------------------------- */\n \"LMClose Dataid(\"status\")\"\n \"LMFree  Dataid(\"status\")\"\n/* ------------------- *\n * Say the Header line *\n * ------------------- */\n  say \"Member  \",\n         \"Cdate    MDate   Ver Mod Time   Cur  Init   Mod User\"\n/* ------------------------------ *\n * Now say the Member information *\n * ------------------------------ */\n do i = 1 to mem.0\n    say mem.i\n    end\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXMEDHL": {"ttr": 3335, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x001\\x01\\x196\\x0f\\x01\\x196\\x0f\\x10Y\\x00\\x11\\x00\\x11\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-12-26T00:00:00", "modifydate": "2019-12-26T10:59:31", "lines": 17, "newlines": 17, "modlines": 0, "user": "REXX"}, "text": "  /* ---------------------- REXX --------------------------- *\n  * Edit macro used by the RXEDITHL example to:             *\n  * 1. do a reset all on entry                              *\n  * 2. insert some explanatory messages using line_before 1 *\n  * ------------------------------------------------------- */\n  Address ISREdit\n  'Macro'\n  'Reset All'\n  call do_msg 'This is an example git diff file and the git records'\n  call do_msg 'will be highlighted to easily identify where to make'\n  call do_msg 'the deletions/etc. to resolve the conflict.'\n  exit\n\ndo_msg:\n  parse arg msg\n  'line_before 1 = msgline (msg)'\n  return\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXMSG": {"ttr": 3337, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x19\\x00\\x92$\\x0f\\x01\\x19\\x08\\x8f\\x10E\\x00\\x0f\\x00\\x05\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1992-08-27T00:00:00", "modifydate": "2019-03-29T10:45:19", "lines": 15, "newlines": 5, "modlines": 0, "user": "REXX"}, "text": "/* ---------------- REXX ------------------- *\n | Sample of using a ISPF Message by taking  |\n | advantage of the IBM Edit generic message |\n | variables.                                |\n |                                           |\n | ISPF - Developers - Tips and Tricks       |\n * ----------------------------------------- */\n  Address ISPExec                         /* Define the ISPF\n                                             Environment */\n  zerrsm = 'Error'                        /* Define the Short Message */\n  zerralrm = \"NO\"                         /* Define the Alarm setting */\n  zerrlm = left('test message',75,'*') ,  /* Define the Long Message */\n    left('test message 2',75,'*')\n  zerrhm   = \"ispftutr\"                   /* Define the Tutorial Panel */\n  \"Setmsg msg(isrz002)\"                   /* Issue the Message */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXNOTEPD": {"ttr": 3339, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x17\\x01 \\t\\x8f\\x01 \\x10O\\tT\\x00R\\x00R\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2020-04-07T00:00:00", "modifydate": "2020-04-13T09:54:17", "lines": 82, "newlines": 82, "modlines": 0, "user": "REXX"}, "text": "  /* ------------------------- REXX ------------------------------- *\n  | Name: RXNOTEPD  (REXX NotePad)                                 |\n  |                                                                |\n  | Provide quick access to a z/OS PDS to track notes and anything |\n  | else of interest.                                              |\n  |                                                                |\n  | Create an ISPF Command Table entry similar to this:            |\n  |                                                                |\n  | Verb:   NOTEPAD                                                |\n  | Trunc:  4                                                      |\n  | Description: ISPF Notepad                                      |\n  | Action: SELECT CMD(%RXNOTEPD &ZPARM)                           |\n  |                                                                |\n  | Find *CUSTOM* below to update site customizations.             |\n  |                                                                |\n  | Then from any ISPF panel enter NOTE or NOTE member-name        |\n  |                                                                |\n  | Uses userid.NOTEPAD.PDSE or user-prefix.NOTEPAD.PDSE           |\n  | and will allocate it if it doesn't exist                       |\n  * -------------------------------------------------------------- *\n  | ISPF - Developers - Tips and Tricks                            |\n  * -------------------------------------------------------------- */\n  arg note\n\n  /* -------*CUSTOM*--------------- *\n  | Set the desired editor to use: |\n  | 1 - PDSEGEN                    |\n  | 2 - ISPF Edit                  |\n  | 3 - ISPF Edit Member List      |\n  * ------------------------------ */\n  Editor = 3   /* change per above */\n\n  /* ---------- *CUSTOM* -------------- *\n  | Construct the notepad dataset name |\n  * ---------------------------------- */\n  if sysvar('syspref') /= ''\n  then notesdsn = sysvar('syspref')'.NOTEPAD.PDSE'\n  else notesdsn = sysvar('sysuid')'.NOTEPAD.PDSE'\n\n  /* ------------------------------------------------------- *\n  | If the notepad dataset does not exist then allocate it. |\n  | If using PDSEGEN, or some other editor that supports    |\n  | member generations then change the MAXGEN from 0 to     |\n  | something more useful.                                  |\n  * ------------------------------------------------------- */\n  if sysdsn(\"'\"notesdsn\"'\") /= 'OK' then do\n    \"Alloc ds('\"notesdsn\"') new spa(30,30) tr recfm(f b) lrecl(80)\" ,\n      'blksize(32720) dir(1) dsntype(library,2) maxgen(0)'\n    \"Free ds('\"notesdsn\"')\"\n  end\n\n  Select\n    When editor = 1 then do\n      /* ------------------------------------------- *\n      | Use PDSEGEN to read/update/create the notes |\n      * ------------------------------------------- */\n      \"%pg '\"notesdsn\"'\" note\n    end\n\n    When editor = 2 then do\n      /* --------------------------------------------- *\n      | Use ISPF Edit to read/update/create the notes |\n      * --------------------------------------------- */\n      if note /= ''\n      then notesdsn = notesdsn'('note')'\n      Address ISPExec ,\n        \"Edit dataset('\"notesdsn\"')\"\n    end\n\n    When editor = 3 then do\n      /* --------------------------------------------- *\n      | Use ISPF Edit to read/update/create the notes |\n      * --------------------------------------------- */\n      Address ISPExec\n      \"LMInit Dataid(notes) Dataset('\"notesdsn\"')\"\n      \"Memlist Dataid(\"notes\") Default(E) Member(\"note\")\"\n      \"LMfree Dataid(\"notes\")\"\n    end\n    Otherwise nop\n  end\n\n  Exit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXNUMC": {"ttr": 3342, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x06\\x01\\x19(\\x0f\\x01\\x19(\\x0f\\t4\\x00\\x12\\x00\\x12\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-10-07T00:00:00", "modifydate": "2019-10-07T09:34:06", "lines": 18, "newlines": 18, "modlines": 0, "user": "REXX"}, "text": "  /* ----------------- REXX ------------------------- *\n  | Take a number and display it with comma's in it. |\n  |                                                  |\n  | e.g.  1000 becomes 1,000                         |\n  |                                                  |\n  | usage:   comma_num = addcomma(number)            |\n  |                                                  |\n  | supports numbers up to 34 digits long            |\n  |                                                  |\n  | Copied from Doug Nadel                           |\n  | ISPF - Developers - Tips and Tricks              |\n  * ------------------------------------------------ */\nAddComma:\n  arg bignum\n  cnum = strip(translate('0,123,456,789,abc,def,ghi,jkl,mno,pqr,stu,vwx', ,\n    right(bignum,34,','), ,\n    '0123456789abcdefghijklmnopqrstuvwx'),'L',',')\n  return cnum\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXNUMCE": {"ttr": 3344, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x19\\x01\\x19(\\x0f\\x01\\x19(\\x0f\\x10\\x10\\x00\\r\\x00\\x07\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2019-10-07T00:00:00", "modifydate": "2019-10-07T10:10:19", "lines": 13, "newlines": 7, "modlines": 0, "user": "REXX"}, "text": "/* ------------------------------------ *\n | Drive RXNUMC to demonstrate it's use |\n * ------------------------------------ */\n Address ISPExec\n parse value '' with number read\n do forever\n    'addpop'\n    'display panel(pnnumc)'\n    drc = rc\n    'rempop'\n    if drc > 0 then leave\n    read = rxnumc(number)\n    end\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXPNS": {"ttr": 3346, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00H\\x01\\x19\\x03O\\x01\\x19\\x08\\x8f\\x10E\\x00\\x1e\\x01b\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-02-03T00:00:00", "modifydate": "2019-03-29T10:45:48", "lines": 30, "newlines": 354, "modlines": 0, "user": "REXX"}, "text": "/* --------------------  rexx procedure  -------------------- *\n | Name:      rxpns                                           |\n |                                                            |\n |            ISPF - Developers - Tips and Tricks             |\n |                                                            |\n | Function:  demonstrate different ispf panel point and      |\n |            shoot field types.  TYPE(PS) and PAS(ON)        |\n |                                                            |\n | Syntax:    %rxpns                                          |\n |                                                            |\n | Usage Notes:                                               |\n |     1. Exit the code by pressing Enter on the Exit field   |\n |        or double click it, or enter EXIT in the command    |\n |        field.                                              |\n * ---------------------------------------------------------- */\nAddress ISPExec\n\ndo forever\n   'Display Panel(pnpns)'\n   if rc = 8 then call done\n   if rc > 8 then do\n      say zerrsm\n      say zerrlm\n      call done\n      end\n   if translate(zcmd) = 'EXIT' then leave\n   end\n\nDone:\nexit\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXPNSL": {"ttr": 3348, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00$\\x01\\x19\\x03O\\x01\\x19\\x08\\x8f\\x10F\\x01\\x92\\x01b\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-02-03T00:00:00", "modifydate": "2019-03-29T10:46:24", "lines": 402, "newlines": 354, "modlines": 0, "user": "REXX"}, "text": "/* --------------------  rexx procedure  -------------------- *\n | Name:      rxpnsl                                          |\n |                                                            |\n | ISPF - Developers - Tips and Tricks                        |\n |                                                            |\n | Function:  demonstrate different ispf panel point and      |\n |            shoot field types.  TYPE(PS) and PAS(ON)        |\n |                                                            |\n | Syntax:    %rxpnsl                                         |\n |                                                            |\n | Usage Notes:                                               |\n |     1. The ISPF Panel is dynamically loaded using the      |\n |        LOADISPF routine and then dynamically released      |\n |        using the DROPISPF routine.                         |\n |     2. The actual ISPF Panel can be found by doing a       |\n |        F '>' 1 (it's at the bottom of the code)            |\n |     3. Exit the code by pressing Enter on the Exit field   |\n |        or double click it, or enter EXIT in the command    |\n |        field.                                              |\n * ---------------------------------------------------------- */\nAddress ISPExec\nloadispf = loadispf()\n\ndo forever\n   'Display Panel(pnpns)'\n   if rc = 8 then call done\n   if rc > 8 then do\n      say zerrsm\n      say zerrlm\n      call done\n      end\n   if translate(zcmd) = 'EXIT' then leave\n   end\n\nDone:\nx = dropispf(loadispf)\nexit\n/* --------------------  rexx procedure  -------------------- *\n * Name:      LoadISPF                                        *\n *                                                            *\n * Function:  Load ISPF elements that are inline in the       *\n *            REXX source code.                               *\n *                                                            *\n * Syntax:    load_info = loadispf()                          *\n *            rc = dropispf(load_info)                        *\n *                                                            *\n *            The inline ISPF resources are limited to        *\n *            ISPF Messages, Panels, and Skeletons,           *\n *                 CLISTs and EXECs are also supported.       *\n *                                                            *\n *            The inline resources must start in column 1     *\n *            and use the following syntax:                   *\n *                                                            *\n *            >START    used to indicate the start of the     *\n *                      inline data                           *\n *                                                            *\n *            >END    - used to indicate the end of the       *\n *                      inline data                           *\n *                                                            *\n *            Each resource begins with a type record:        *\n *            >type name                                      *\n *               where type is CLIST, EXEC, MSG, PANEL, SKEL  *\n *                     name is the name of the element        *\n *                                                            *\n * Sample usage:                                              *\n *          -* rexx *-                                        *\n *          load_info = loadispf()                            *\n *          ... magic code happens here (your code) ...       *\n *          rc = dropispf(load_info)                          *\n *          exit                                              *\n *          >Start inline elements                            *\n *          >Panel panel1                                     *\n *          ...                                               *\n *          >Msg msg1                                         *\n *          ...                                               *\n *          >End of inline elements                           *\n *                                                            *\n * Returns:   the list of ddnames allocated for use along     *\n *            with the libdef's performed or altlib           *\n *                                                            *\n *            format is ddname libdef ddname libdef ...       *\n *                   libdef may be altlibc or altlibe         *\n *                   for altlib clist or altlib exec          *\n *                                                            *\n * Notes:     Entire routine must be included with REXX       *\n *            exec - inline with the code.                    *\n *                                                            *\n * Comments:  The entire rexx program is processed from the   *\n *            last record to the first to find the >START     *\n *            record at which point all records from that     *\n *            point on are processed until the >END           *\n *            statement or the end of the program is found.   *\n *                                                            *\n *            It is *strongly* suggested that the inline      *\n *            elements be at the very end of your code so     *\n *            that the search for them is faster.             *\n *                                                            *\n *            Inline ISPTLIB or ISPLLIB were not supported    *\n *            because the values for these would have to be   *\n *            in hex.                                         *\n *                                                            *\n * Author:    Lionel B. Dyck                                  *\n *                                                            *\n * History:                                                   *\n *            01/09/19 - Include DROPISPF routine             *\n *            08/29/17 - Fixup static values that were vars   *\n *            05/31/17 - Change default directory count       *\n *            12/09/16 - update for add_it routine            *\n *            05/10/16 - correction for clist and exec        *\n *            04/19/16 - bug correction                       *\n *            06/04/04 - Enhancements for speed               *\n *            08/05/02 - Creation                             *\n *                                                            *\n * ---------------------------------------------------------- *\n * Disclaimer: There is no warranty, either explicit or       *\n * implied with this code. Use it at your own risk as there   *\n * is no recourse from either the author or his employeer.    *\n * ---------------------------------------------------------- */\nLoadISPF: Procedure\n\n  parse value \"\" with null kmsg kpanel kskel first returns ,\n    kclist kexec\n/* ------------------------------------------------------- *\n * Find the InLine ISPF Elements and load them into a stem *\n * variable.                                               *\n *                                                         *\n * Elements keyword syntax:                                *\n * >START - start of inline data                           *\n * >CLIST name                                             *\n * >EXEC name                                              *\n * >MSG name                                               *\n * >PANEL name                                             *\n * >SKEL name                                              *\n * >END   - end of all inline data (optional if last)      *\n * ------------------------------------------------------- */\n  last_line = sourceline()\n  do i = last_line to 1 by -1\n    line = sourceline(i)\n    if translate(left(line,6)) = \">START \" then leave\n  end\n  rec = 0\n/* --------------------------------------------------- *\n * Flag types of ISPF resources by testing each record *\n * then add each record to the data. stem variable.    *\n * --------------------------------------------------- */\n  do j = i+1 to last_line\n    line = sourceline(j)\n    if translate(left(line,5)) = \">END \"   then leave\n    if translate(left(line,7)) = \">CLIST \" then kclist = 1\n    if translate(left(line,6)) = \">EXEC \"  then kexec  = 1\n    if translate(left(line,5)) = \">MSG \"   then kmsg   = 1\n    if translate(left(line,7)) = \">PANEL \" then kpanel = 1\n    if translate(left(line,6)) = \">SKEL \"  then kskel  = 1\n    rec  = rec + 1\n    data.rec = line\n  end\n\n/* ----------------------------------------------------- *\n * Now create the Library and Load the Member(s)         *\n * ----------------------------------------------------- */\n  Address ISPExec\n/* ----------------------------- *\n * Assign dynamic random ddnames *\n * ----------------------------- */\n  clistdd = \"lc\"random(999)\n  execdd  = \"le\"random(999)\n  msgdd   = \"lm\"random(999)\n  paneldd = \"lp\"random(999)\n  skeldd  = \"ls\"random(999)\n\n/* ---------------------------------------- *\n *  LmInit and LmOpen each resource library *\n * ---------------------------------------- */\n  if kclist <> null then do\n    call alloc_dd clistdd\n    \"Lminit dataid(clist) ddname(\"clistdd\")\"\n    \"LmOpen dataid(\"clist\") Option(Output)\"\n    returns = strip(returns clistdd 'ALTLIBC')\n  end\n  if kexec <> null then do\n    call alloc_dd execdd\n    \"Lminit dataid(exec) ddname(\"execdd\")\"\n    \"LmOpen dataid(\"exec\") Option(Output)\"\n    returns = strip(returns execdd 'ALTLIBE')\n  end\n  if kmsg <> null then do\n    call alloc_dd msgdd\n    \"Lminit dataid(msg) ddname(\"msgdd\")\"\n    \"LmOpen dataid(\"msg\") Option(Output)\"\n    returns = strip(returns msgdd 'ISPMLIB')\n  end\n  if kpanel <> null then do\n    call alloc_dd paneldd\n    \"Lminit dataid(panel) ddname(\"paneldd\")\"\n    \"LmOpen dataid(\"panel\") Option(Output)\"\n    returns = strip(returns paneldd 'ISPPLIB')\n  end\n  if kskel <> null then do\n    call alloc_dd skeldd\n    \"Lminit dataid(skel) ddname(\"skeldd\")\"\n    \"LmOpen dataid(\"skel\") Option(Output)\"\n    returns = strip(returns skeldd 'ISPSLIB')\n  end\n\n/* ----------------------------------------------- *\n * Process all records in the data. stem variable. *\n * ----------------------------------------------- */\n  do i = 1 to rec\n    record = data.i\n    recordu = translate(record)\n    if left(recordu,5) = \">END \" then leave\n    if left(recordu,7) = \">CLIST \" then do\n      if first = 1 then call add_it\n      type = \"Clist\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n    if left(recordu,6) = \">EXEC \" then do\n      if first = 1 then call add_it\n      type = \"Exec\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n    if left(recordu,5) = \">MSG \" then do\n      if first = 1 then call add_it\n      type = \"Msg\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n    if left(recordu,7) = \">PANEL \" then do\n      if first = 1 then call add_it\n      type = \"Panel\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n    if left(recordu,6) = \">SKEL \" then do\n      if first = 1 then call add_it\n      type = \"Skel\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n   /* --------------------------------------------*\n    * Put the record into the appropriate library *\n    * based on the record type.                   *\n    * ------------------------------------------- */\n    Select\n      When type = \"Clist\" then\n      \"LmPut dataid(\"clist\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(255)\"\n      When type = \"Exec\" then\n      \"LmPut dataid(\"exec\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(255)\"\n      When type = \"Msg\" then\n      \"LmPut dataid(\"msg\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(80)\"\n      When type = \"Panel\" then\n      \"LmPut dataid(\"panel\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(80)\"\n      When type = \"Skel\" then\n      \"LmPut dataid(\"skel\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(80)\"\n      Otherwise nop\n    end\n  end\n  if type <> null then call add_it\n/* ---------------------------------------------------- *\n * Processing completed - now lmfree the allocation and *\n * Libdef the library.                                  *\n * ---------------------------------------------------- */\n  if kclist <> null then do\n    Address TSO,\n      \"Altlib Act Application(Clist) File(\"clistdd\")\"\n    \"LmFree dataid(\"clist\")\"\n  end\n  if kexec <> null then do\n    Address TSO,\n      \"Altlib Act Application(Exec) File(\"execdd\")\"\n    \"LmFree dataid(\"exec\")\"\n  end\n  if kmsg <> null then do\n    \"LmFree dataid(\"msg\")\"\n    \"Libdef ISPMlib Library ID(\"msgdd\") Stack\"\n  end\n  if kpanel <> null then do\n    \"Libdef ISPPlib Library ID(\"paneldd\") Stack\"\n    \"LmFree dataid(\"panel\")\"\n  end\n  if kskel <> null then do\n    \"Libdef ISPSlib Library ID(\"skeldd\") Stack\"\n    \"LmFree dataid(\"skel\")\"\n  end\n  return returns\n\n/* --------------------------- *\n * Add the Member using LmmAdd *\n * based upon type of resource *\n * --------------------------- */\nAdd_It:\n  Select\n    When type = \"Clist\" then\n    \"LmmAdd dataid(\"clist\") Member(\"name\")\"\n    When type = \"Exec\" then\n    \"LmmAdd dataid(\"exec\") Member(\"name\")\"\n    When type = \"Msg\" then\n    \"LmmAdd dataid(\"msg\") Member(\"name\")\"\n    When type = \"Panel\" then\n    \"LmmAdd dataid(\"panel\") Member(\"name\")\"\n    When type = \"Skel\" then\n    \"LmmAdd dataid(\"skel\") Member(\"name\")\"\n    Otherwise nop\n  end\n  type = null\n  return\n\n/* ------------------------------ *\n * ALlocate the temp ispf library *\n * ------------------------------ */\nAlloc_DD:\n  arg dd\n  Address TSO\n  if pos(left(dd,2),\"lc le\") > 0 then\n  \"Alloc f(\"dd\") unit(sysda) spa(5,5) dir(5)\",\n    \"recfm(v b) lrecl(255) blksize(32760)\"\n  else\n  \"Alloc f(\"dd\") unit(sysda) spa(5,5) dir(5)\",\n    \"recfm(f b) lrecl(80) blksize(23440)\"\n  return\n\n/* --------------------  rexx procedure  -------------------- *\n * Name:      DropISPF                                        *\n *                                                            *\n * Function:  Remove ISPF LIBDEF's and deactivate ALTLIB's    *\n *            that were created by the LoadISPF function.     *\n *                                                            *\n * Syntax:    rc = dropispf(load_info)                        *\n *                                                            *\n * Author:    Janko                                           *\n *                                                            *\n * History:                                                   *\n *            12/05/18 - Creation                             *\n * ---------------------------------------------------------- */\nDropISPF: Procedure\n  arg load_info\n  Address ISPEXEC\n  do until length(load_info) = 0\n    parse value load_info with dd libd load_info\n    if left(libd,6) = \"ALTLIB\" then do\n      if libd = \"ALTLIBC\" then lib = \"CLIST\"\n      else lib = \"EXEC\"\n      Address TSO,\n        \"Altlib Deact Application(\"lib\")\"\n    end\n    else \"libdef\" libd\n    address tso \"free f(\"dd\")\"\n  end\n  return 0\n/*\n>Start\n>Panel pnpns\n)ATTR DEFAULT(%+_)\n $ type(ps)\n # type(output) caps(off) just(left) color(red) hilite(uscore)\n @ type(output) caps(off) pas(on) hilite(uscore) color(yellow)\n } type(output) caps(off) pas(on) hilite(uscore) color(blue)\n)body\n%Command ==>_zcmd              +\n+\n%Test:  $One+     $Two+\n+       $Three+   $Four+\n+       @Five+    @Six+\n+\n%Value #result                                  +\n+\n+Click here when ready to}Exit+\n+\n+Tab to any of the point and shoot fields and press%Enter+or move the\n+mouse point to them and double click. See the results in the%Value+field.\n+Note that the%Five+and%Six+fields are point and shoot fields but you can\n+change the text that displays in them with a drawback that you can\n+actually type into those fields with zero affect.\n+\n)Init\n &five = 'Five'\n &six  = 'Six'\n &exit = 'Exit'\n)Proc\n)PNTS\n FIELD(ZPS00001) VAR(RESULT) VAL('Value of 1')\n FIELD(ZPS00002) VAR(RESULT) VAL('We have two')\n FIELD(ZPS00003) VAR(RESULT) VAL('Now three')\n FIELD(ZPS00004) VAR(RESULT) VAL('Four')\n FIELD(Five)     VAR(RESULT) VAL('Five or 5')\n FIELD(Six)      VAR(RESULT) VAL('Six or 6')\n FIELD(Exit)     VAR(zcmd)   VAL(Exit)\n)end\n>end\n*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXPOP": {"ttr": 3589, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00A\\x01\\x012?\\x01\\x19\\x11?\\x06\\x18\\x00\\t\\x00\\t\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2001-11-19T00:00:00", "modifydate": "2019-04-23T06:18:41", "lines": 9, "newlines": 9, "modlines": 0, "user": "REXX"}, "text": "/* ---------------- rexx ------------------ *\n | Demonstrate how to display a popup panel |\n | ISPF - Developers - Tips and Tricks      |\n * ---------------------------------------- */\n Address ISPEXEC                    /* Set the ISPF Environment */\n 'Addpop Row(4) Column(6)'          /* Define the Popup Row/Column */\n 'Display Panel(pnpop)'             /* Display the Panel */\n save_rc = rc                       /* Save return code  */\n 'Rempop'                           /* Remove the Popup setting */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXPOPDO": {"ttr": 3591, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x009\\x01\\x19\\x07\\x1f\\x01\\x19\\t?\\x07\\x11\\x00R\\x00\\x18\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-03-12T00:00:00", "modifydate": "2019-04-03T07:11:39", "lines": 82, "newlines": 24, "modlines": 0, "user": "REXX"}, "text": "/* --------------------  rexx procedure  -------------------- *\n | Name:      RXPopDo                                         |\n | ISPF - Developers - Tips and Tricks                        |\n |                                                            |\n | Function:  Scan the provided PDS and invoke the            |\n |            rxpopm edit macro to generate a report          |\n |            of a possible ADDPOP command with the Row       |\n |            and Column mostly centered.                     |\n |                                                            |\n | Syntax:    %rxpopdo                                        |\n |                                                            |\n * ---------------------------------------------------------- */\n  arg dsn\n\n  if sysdsn(dsn) /= 'OK' then do\n    say 'invalid dsn' dsn\n    say sysdsn(dsn)\n    exit\n  end\n\n  call outtrap 'x.'\n  address tso 'listd' dsn 'mem'\n  call outtrap 'off'\n\n  x=listdsi(dsn)\n  dsn = sysdsname\n\n  c = 4\n  l.1 = 'ISPF Panel PopUp Centering Suggestions'\n  l.2 = ' '\n  l.3 = left('Panel',8) 'ADDPOP Command'\n  l.4 = left('-',8,'-') left('-',25,'-')\n  row = 24   /* starting place */\n\n  Address ISPExec\n  do i = 7 to x.0\n    m = word(x.i,1)\n    poplog = 'x'\n    'vput (poplog)'\n    \"view dataset('\"dsn\"(\"m\")')  macro(rxpopm)\"\n    'vget (poplog)'\n    if strip(poplog) /= 'x' then do\n      c = c + 1\n      l.c = m poplog\n      parse value poplog with rw cl\n      if rw < row then row = rw\n    end\n  end\n\n  l.0 = c\n  do i = 5 to l.0\n     parse value l.i with m rw cl\n     rw = row\n     l.i = left(m,8) 'ADDPOP ROW('rw') COLUMN('cl')'\n     end\n\n Address TSO\n  dd = 'dd'random(9999)\n/* ------------------------------------------ *\n | Allocate a temporary data set for our data |\n * ------------------------------------------ */\n  'Alloc f('dd') new spa(5,5) tr' ,\n    'recfm(v b) lrecl(80) blksize(0)'\n/* ----------------------- *\n | Write out the stem data |\n * ----------------------- */\n  'Execio * diskw' dd '(finis stem l.'\n/* -------------------------------------------------- *\n | Access the Temporary Data Set using ISPF           |\n | Library Services.                                  |\n | Then using ISPF Browse service to browse the data. |\n | And use Library Services to Free the Data Set.     |\n * -------------------------------------------------- */\n  Address ISPExec\n  'lminit dataid(ddb) ddname('dd')'\n  'browse dataid('ddb')'\n  'lmfree dataid('ddb')'\n/* ----------------------------- *\n | Last Free the z/OS Allocation |\n * ----------------------------- */\n  Address TSO\n  'Free f('dd')'\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXPOPKEY": {"ttr": 3594, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00I\\x01\\x19\\x10\\x0f\\x01\\x19)_\\x10@\\x00%\\x00\"\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2019-04-10T00:00:00", "modifydate": "2019-10-22T10:40:49", "lines": 37, "newlines": 34, "modlines": 0, "user": "REXX"}, "text": "  /* ------------------------ REXX ------------------------ *\n  | This code demonstrates how to dynamically turn off,    |\n  | and then back on, the PFSHOW setting. This is useful   |\n  | if the user may have PFSHOW ON to prevent the function |\n  | keys from overlaying the popup.                        |\n  * ------------------------------------------------------ */\n  Address ISPExec\n  call pfshow 'off'           /* make sure pfshow is off */\n  'addpop'\n  msg1 = 'Sample Popup with room for PF Keys'\n  msg2 = 'in the room below.'\n  'display panel(pnpopv)'\n  'rempop'\n  call pfshow 'reset'         /* restore pfshow setting */\n  exit\n  /* ------------------------------------------------------ *\n  | The pfshow routine will:                               |\n  | 1. check to see the passed option                      |\n  | 2. if Off then it will save the current pfshow setting |\n  |    - save the current setting                          |\n  |    - turn off pfshow                                   |\n  | 3. if the option is Reset then it will                 |\n  |    - test if pfshow was on and turn it back on         |\n  * ------------------------------------------------------ */\npfshow:\n  arg pfkopt\n  if pfkopt = 'RESET' then do\n    if pfkeys = 'ON' then\n    'select pgm(ispopf) parm(FKA,ON)'\n  end\n  if pfkopt = 'OFF' then do\n    'vget (zpfshow)'\n    pfkeys = zpfshow\n    if pfkeys /= 'OFF' then\n    'select pgm(ispopf) parm(FKA,OFF)'\n  end\n  return\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXPOPM": {"ttr": 3596, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x16\\x01\\x19\\x07\\x1f\\x01\\x19\\t?\\x07\\x06\\x00H\\x00\\x10\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-03-12T00:00:00", "modifydate": "2019-04-03T07:06:16", "lines": 72, "newlines": 16, "modlines": 0, "user": "MACRO"}, "text": "/* --------------------  rexx procedure  -------------------- *\n | Name:      RXPOPM                                          |\n | ISPF - Developers - Tips and Tricks                        |\n |                                                            |\n | Options:   ISPF variable poplog - if x then save info      |\n |            in the poplog variable and vput it.             |\n |            Otherwise put info into the member as a         |\n |            ISPF Edit noteline.                             |\n |                                                            |\n | Function:  ISPF Edit Macro to propose ADDPOP ROW/COLUMN    |\n |            values for an ISPF POPUP Panel                  |\n * ---------------------------------------------------------- */\n Address ISREdit\n 'Macro'\n\n/* ------------------------------------------- *\n | Check for the WINDOW( keyword in the member |\n * ------------------------------------------- */\n  \"find 'WINDOW(' first\"\n  if rc > 0 then do\n    'end'\n    exit\n  end\n\n/* --------------------------------- *\n | Verify it is on a )BODY statement |\n | - if not exit Edit                |\n * --------------------------------- */\n  '(data) = line .zcsr'\n  if left(translate(data),5) /= ')BODY' then do\n     'end'\n     exit\n     end\n\n/* -------------------------------------------- *\n | Get the member name and then the window info |\n * -------------------------------------------- */\n  '(member) = member'\n  parse value translate(data) with . 'WINDOW('col','row')' .\n\n/* -------------------------- *\n | VGET the processing option |\n * -------------------------- */\n  Address ISPExec 'vget (poplog)'\n\n/* ----------------------------------- *\n | Calculate the ideal AddPop location |\n * ----------------------------------- */\n  col = ((80 - col) % 2 ) +1\n  row = ((23 - row) % 2 ) +1\n  data = row  col\n\n/* ------------------------------------------------- *\n | If poplog is x then put the ideal window location |\n | back in the poplog variable and vput it.          |\n |                                                   |\n | Otherwise insert as a noteline at the top of the  |\n | member.                                           |\n * ------------------------------------------------- */\n  if poplog = 'x'\n  then do\n    poplog = data\n    Address ISPExec 'vput (poplog)'\n  'end'\n  end\n  else do\n    'reset'\n    'reset find'\n    Data = 'Suggested ADDPOP Command: ADDPOP Row('row') Column('col')'\n    'line_before 1 = noteline (data)'\n    'cursor = 1 1'\n  end\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXPREXX": {"ttr": 3599, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00A\\x01\\x19\\x07O\\x01\\x19\\x08\\x8f\\x10F\\x00\\x1a\\x00\\x06\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-03-15T00:00:00", "modifydate": "2019-03-29T10:46:41", "lines": 26, "newlines": 6, "modlines": 0, "user": "REXX"}, "text": "/* ------------- REXX ------------------- *\n | Demonstrate the use of Panel Rexx by   |\n | displaying the ISPF Panel that has the |\n | Panel Rexx.                            |\n | ISPF - Developers - Tips and Tricks    |\n * -------------------------------------- */\n/* ----------------------------- *\n | Get into the ISPF Environment |\n * ----------------------------- */\n  Address ISPExec\n/* ----------------------------------- *\n | Setup the Popup Settings Row/Column |\n * ----------------------------------- */\n  'addpop row(6) column(6)'\n/* ------------------------------------------------ *\n | Display the Panel Rexx test panel until F3 (End) |\n * ------------------------------------------------ */\n  do forever\n    'display panel(pnprexx)'\n    xrc = rc\n    if xrc > 0 then leave\n  end\n/* ------------------------- *\n | Remove the Popup Settings |\n * ------------------------- */\n  'rempop'\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXPROG1": {"ttr": 3601, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x006\\x01\\x19\\x07o\\x01\\x19\\x08\\x8f\\x10G\\x00\\x0f\\x00\\x07\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-03-17T00:00:00", "modifydate": "2019-03-29T10:47:36", "lines": 15, "newlines": 7, "modlines": 0, "user": "REXX"}, "text": "/* ------------------ REXX ---------------------- *\n | Demonstrate an ISPF Popup Progress meter panel |\n |                                                |\n | ISPF - Developers - Tips and Tricks            |\n * ---------------------------------------------- */\n  Address ISPExec\n  do i = 1 to 5\n    'control display lock'               /* Lock the Display */\n    'addpop'                             /* Setup for a Pop Up Panel */\n    pcount = i                           /* Update the variable for the panel */\n    'display panel(pnprog1)'             /* Display the ISPF Panel */\n    'rempop'                             /* Remove the Pop Up Setup */\n    address syscall 'sleep 1'            /* Now sleep for 1 second to\n                                            simulate work. */\n  end\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXPROG2": {"ttr": 3603, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00D\\x01\\x16 /\\x01\\x19\\x08\\x8f\\x10G\\x00.\\x00\\x12\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2016-07-20T00:00:00", "modifydate": "2019-03-29T10:47:44", "lines": 46, "newlines": 18, "modlines": 0, "user": "REXX"}, "text": "/* ------------------ REXX ---------------------- *\n | Demonstrate an ISPF Popup Progress meter panel |\n |                                                |\n | ISPF - Developers - Tips and Tricks            |\n * ---------------------------------------------- */\n/* ------------------------------------------------- *\n| Provide a total number of iterations for the Demo |\n* ------------------------------------------------- */\n  arg total\n  if total = '' then total = 100\n/* ----------------------------- *\n| Change to ISPExec environment |\n* ----------------------------- */\n  Address ISPexec\n/* -------------------------------------------- *\n| Define our increment so it fits in the panel |\n* -------------------------------------------- */\n  incr = (total % 10) + 1\n/* ------------------------------ *\n| Define our increment indicator |\n* ------------------------------ */\n  progc = '**'\n  i = 0\n  perc# = 0\n/* ----------------------------------------- *\n| Now loop thru and show the progress meter |\n* ----------------------------------------- */\n  do until i = total\n    i = i + 1\n    if i//incr = 0 then do\n      progc = progc'**'\n      perc# = perc# + 10\n      perc = perc#\"%\"\n      prog = progc '('perc')'\n/* ---------------------------------------- *\n| Lock the display since the user will not |\n| be able to do anything other than watch. |\n| Then sleep for 1 second to simulate work.|\n* ---------------------------------------- */\n      \"Control Display Lock\"\n      'addpop'\n      'display panel(pnprog2)'\n      'rempop'\n      Address syscall 'sleep 1'\n    end\n  end\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXRAND": {"ttr": 3605, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x17\\x01\\x19\\x12?\\x01\\x19\\x12?\\x08\\x17\\x00\\x1a\\x00\\x17\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2019-05-03T00:00:00", "modifydate": "2019-05-03T08:17:17", "lines": 26, "newlines": 23, "modlines": 0, "user": "REXX"}, "text": "  /* ---------------- REXX ---------------- *\n  | Demonstrate various randomized options |\n  * -------------------------------------- */\n\n  /* ----------------------------------- *\n  | Getting the active Exec name to use |\n  * ----------------------------------- */\n  parse source . . exec .\n  say 'DDname based on the active exec name:'\n  say 'DDname:' exec\n\n  /* -------------------------- *\n  | Using REXX Random Function |\n  * -------------------------- */\n  say ' '\n  dd = 'DDN'random(99999)\n  say 'DDname based on a random number:'\n  say 'DDname:' dd\n\n  /* ------------------------------------------------ *\n  | Using the day of month and second since midnight |\n  * ------------------------------------------------ */\n  say ' '\n  say 'DDname based on day of month and seconds since midnight:'\n  ddn = 'D'left(date('e'),2)''right(time('l'),5)\n  say 'DDname:' ddn\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXRVAR": {"ttr": 3607, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00$\\x01\\x19\\x12o\\x01\\x19\\x12o\\x07\\x16\\x00\\x06\\x00\\x06\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-05-06T00:00:00", "modifydate": "2019-05-06T07:16:24", "lines": 6, "newlines": 6, "modlines": 0, "user": "REXX"}, "text": "/* ---------------------- REXX -------------------------- *\n | Display any REXX variable, or evaluate and display any |\n | REXX expression.                                       |\n * ------------------------------------------------------ */\n  parse arg opt\n  interpret say opt\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXSCRL": {"ttr": 3841, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00V\\x01\\x19\\x07\\x9f\\x01\\x19\\x08\\x8f\\x10G\\x00\\r\\x00\\x0c\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-03-20T00:00:00", "modifydate": "2019-03-29T10:47:56", "lines": 13, "newlines": 12, "modlines": 0, "user": "REXX"}, "text": "/* ------------------- REXX ------------------------ *\n | This sample REXX code displays a popup panel that |\n | demonstrates a scrolling panel field.             |\n | ISPF - Developers - Tips and Tricks               |\n * ------------------------------------------------- */\n Address ISPExec\n do forever\n    'addpop'\n    'display panel(pnscrl)'\n    xrc = rc\n    'rempop'\n    if xrc > 0 then leave\n    end\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXSKLCMD": {"ttr": 3843, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x01\\x01\\x19\\x10o\\x01\\x19\\x10o\\x10\\x03\\x00\\x0b\\x00\\x0e\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-04-16T00:00:00", "modifydate": "2019-04-16T10:03:01", "lines": 11, "newlines": 14, "modlines": 0, "user": "REXX"}, "text": "  /* --------------- REXX -------------------- *\n  | Demonstration of ISPF Skeleton Processing |\n  * ----------------------------------------- */\n  Arg Table\n  if table = '' then table = 'ISPCMDS'\n  Address ISPExec\n  'ftopen temp'\n  'ftincl skcmds'\n  'ftclose'\n  'vget (ztempf)'\n  \"View dataset('\"ztempf\"')\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXSKLRX": {"ttr": 3845, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00E\\x01\\x19\\x10o\\x01\\x19\\x11?\\t7\\x00\\t\\x00\\x0e\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2019-04-16T00:00:00", "modifydate": "2019-04-23T09:37:45", "lines": 9, "newlines": 14, "modlines": 0, "user": "REXX"}, "text": "  /* --------------- REXX -------------------- *\n  | Demonstration of ISPF Skeleton Processing |\n  * ----------------------------------------- */\n  Address ISPExec\n  'ftopen temp'\n  'ftincl skrexx'\n  'ftclose'\n  'vget (ztempf)'\n  \"View dataset('\"ztempf\"')\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXSKLRXE": {"ttr": 3847, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x006\\x01\\x19\\x10o\\x01\\x19\\x12/\\x08E\\x00\\t\\x00\\x0e\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2019-04-16T00:00:00", "modifydate": "2019-05-02T08:45:36", "lines": 9, "newlines": 14, "modlines": 0, "user": "REXX"}, "text": "  /* --------------- REXX -------------------- *\n  | Demonstration of ISPF Skeleton Processing |\n  * ----------------------------------------- */\n  Address ISPExec\n  'ftopen temp'\n  'ftincl skrexxe'\n  'ftclose'\n  'vget (ztempf)'\n  \"View dataset('\"ztempf\"')\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXSKLRXV": {"ttr": 3849, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x05\\x00X\\x01\\x19\\x10o\\x01\\x19'\\x0f\\x16H\\x00\\n\\x00\\x0e\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@\"", "ispf": {"version": "01.05", "flags": 0, "createdate": "2019-04-16T00:00:00", "modifydate": "2019-09-27T16:48:58", "lines": 10, "newlines": 14, "modlines": 0, "user": "REXX"}, "text": "  /* --------------- REXX ------------------------------------------ *\n  | Demonstration of ISPF Skeleton Processing with a passed variable |\n  * ---------------------------------------------------------------- */\n  arg dsname\n  Address ISPExec\n  'ftopen temp'\n  'ftincl skrexxv'\n  'ftclose'\n  'vget (ztempf)'\n  \"View dataset('\"ztempf\"')\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXSTEM": {"ttr": 3851, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x06\\x01\\x19\\x07\\x7f\\x01\\x19\\x08\\x8f\\x10H\\x00$\\x00#\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-03-18T00:00:00", "modifydate": "2019-03-29T10:48:06", "lines": 36, "newlines": 35, "modlines": 0, "user": "REXX"}, "text": "/* --------------------- REXX ------------------------ *\n | Sample routine to browse data from a stem variable. |\n | ISPF - Developers - Tips and Tricks                 |\n * --------------------------------------------------- */\n  do i = 1 to 200  /* Define our test data */\n    stem.i = 'Test data record number' right(i+1000,3)\n  end\n  stem.0 = i      /* update the stem.0 with record count */\n/* ------------------------------- *\n | Randomly define a DDName to use |\n * ------------------------------- */\n  dd = 'dd'random(9999)\n/* ------------------------------------------ *\n | Allocate a temporary data set for our data |\n * ------------------------------------------ */\n  'Alloc f('dd') new spa(5,5) tr' ,\n    'recfm(v b) lrecl(80) blksize(0)'\n/* ----------------------- *\n | Write out the stem data |\n * ----------------------- */\n  'Execio * diskw' dd '(finis stem stem.'\n/* -------------------------------------------------- *\n | Access the Temporary Data Set using ISPF           |\n | Library Services.                                  |\n | Then using ISPF Browse service to browse the data. |\n | And use Library Services to Free the Data Set.     |\n * -------------------------------------------------- */\n  Address ISPExec\n  'lminit dataid(ddb) ddname('dd')'\n  'browse dataid('ddb')'\n  'lmfree dataid('ddb')'\n/* ----------------------------- *\n | Last Free the z/OS Allocation |\n * ----------------------------- */\n  Address TSO\n  'Free f('dd')'\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXSTEME": {"ttr": 3853, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x15\\x01\\x19\\x07\\x8f\\x01\\x19\\x08\\x8f\\x10H\\x00\\x0c\\x00\\x08\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-03-19T00:00:00", "modifydate": "2019-03-29T10:48:15", "lines": 12, "newlines": 8, "modlines": 0, "user": "REXX"}, "text": "/* --------------------- REXX ------------------------ *\n | Sample routine to browse data from a stem variable. |\n | ISPF - Developers - Tips and Tricks                 |\n * --------------------------------------------------- */\n  do i = 1 to 200  /* Define our test data */\n    stem.i = 'Test data record number' right(i+1000,3)\n  end\n  stem.0 = i      /* update the stem.0 with record count */\n/* ------------------------- *\n | Call the StemEdit routine |\n * ------------------------- */\n  call stemedit 'Browse',stem.,,,'Stem stem. Browsing'\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXSTEMS": {"ttr": 3855, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00)\\x01\\x19\\x12\\x7f\\x01\\x19\\x12\\x7f\\t9\\x00\\x16\\x00\\x16\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-05-07T00:00:00", "modifydate": "2019-05-07T09:39:29", "lines": 22, "newlines": 22, "modlines": 0, "user": "REXX"}, "text": "  /* ---------------------- REXX --------------------------- *\n  | From John McKown to sort a stem using unix sort in OMVS |\n  * ------------------------------------------------------- */\n  XX=SYSCALLS('ON')\n  If xx > 3 Then Do\n    Say \"SYSCALLS('ON') Failed. RC=\"xx\n    exit\n  End\n  do i = 1 to 12\n    a.i = random(999)\n  end\n  a.0=12\n  stdout.0=0 ; stderr.0=0\n  call bpxwunix \"/bin/sort -n\",a.,a.,stderr.\n  say 'a.0='a.0\n  do  i=1 to a.0\n    say \"a.\"i\"=\"a.i\n  end\n  say 'stderr.0='stderr.0\n  do  i=1 to stderr.0\n    say \"stderr.\"i\"=\"stderr.i\n  end\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXTAB": {"ttr": 3857, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x00Y\\x01\\x01\\x11O\\x01 \\x02_\\x109\\x01\\xab\\x00\\x12\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "2001-04-24T00:00:00", "modifydate": "2020-01-25T10:39:59", "lines": 427, "newlines": 18, "modlines": 0, "user": "REXX"}, "text": "  /* ------------------------ REXX ------------------------ *\n  | Sample REXX Code to drive an ISPF Table to demonstrate |\n  | 1. Processing a command (Refresh)                      |\n  | 2. Processing individual line selections               |\n  | 3. Processing multiple line selections                 |\n  | 4. Processing a range selection (SS/SS)                |\n  | 5. Processing a range count (S###)                     |\n  | 6. Demonstrate Only string capability                  |\n  | 7. Uses IBM's ISRZ001 message (zedsmsg/zedlmsg)        |\n  | 8. Use of Find and RFIND                               |\n  | 9. Use of Locate (TBSCAN)                              |\n  * ------------------------------------------------------ *\n  | ISPF - Developers - Tips and Tricks                    |\n  * ------------------------------------------------------ */\n  /* ------------------------------------ *\n  | Define Addressing to ISPFExec (ISPF) |\n  * ------------------------------------ */\n  Address ISPExec\n  /* --------> Enable Repeat Find <------------ *\n  | Check for APPLID (TABT) and if not then    |\n  |   - create an ISPF Commands Table          |\n  |   - add RFIND to it with a variable        |\n  |   - reinvoke the current exec with NEWAPPL |\n  |   - on return close the commands table     |\n  * ------------------------------------------ */\n  \"VGET ZAPPLID\"\n  if zapplid <> \"TABT\" then do\n    \"TBCreate tabtcmds names(zctverb zcttrunc zctact\" ,\n      \"zctdesc) replace share nowrite\"\n    zctverb = \"RFIND\"\n    zcttrunc = 0\n    zctact = \"&USRRFIND\"\n    zctdesc = \"User controlled Repeat Find (RFIND)\"\n    \"TBAdd tabtcmds\"\n    \"Select CMD(%\"sysvar('sysicmd') options \") Newappl(tabt)\" ,\n      \"passlib scrname(TABLE)\"\n    x_rc = rc\n    \"TBClose tabtcmds\"\n    Exit x_rc\n  end\n  /* --------------- *\n  | Define defaults |\n  * --------------- */\n  null    = ''                            /* Null variable for compare */\n  /* ---------------------------- *\n  | Label for Refresh Processing |\n  * ---------------------------- */\nRefresh:\n  /* ------------------------------------------------------- *\n  | Define our ISPF Table with two variables and NOWRITE as |\n  | it will not be saved.                                   |\n  * ------------------------------------------------------- */\n  \"TBCreate test names(vitem vstate) nowrite\"\n  /* -------------------------------------- *\n  | Now fill the ISPF table with test data |\n  * -------------------------------------- */\n  str = 'AbcDefGhiJklMnoPqrStuVwxYz0123456789'\n  strc = 1\n  vstate = null\n  do i = 1 to 100\n    vitem =  substr(str,strc,3) 'Test data number:' right(i+1000,3)\n    strc = strc +3\n    if strc > 34 then strc = 1\n    \"TBAdd test\"\n  end\n  /* ------------------------------------------------ *\n  | Table defined and populated - get to the top now |\n  | and define our working variables                 |\n  * ------------------------------------------------ */\n  ztdsels = 0                   /* Define # rows selected to 0 */\n  crp     = 1                   /* Define the starting row to 1 */\n  save_floc = 0                 /* Save last find location */\n  save_find = null              /* save last find string */\n  /* --------------------------------------------------- *\n  | Process the table forever - until we say we're done |\n  * --------------------------------------------------- */\n  do forever\n    /* -------------------------------------------- *\n    | Define USRRFIND for Passthru to enable RFIND |\n    * -------------------------------------------- */\n    usrrfind = 'PASSTHRU'\n    'vput (usrrfind)'\n    /* ---------------------------------------------------- *\n    | Test ZTDSELS - if greater than zero than display the |\n    | table without the Panel name                         |\n    | - if zero than display with the Panel name           |\n    |   after 1st reseting the display to the last location|\n    * ---------------------------------------------------- */\n    if ztdsels > 0\n    then 'tbdispl test'\n    else do\n      'tbtop test'\n      'tbskip test number('crp')'\n      'tbdispl test panel(pntab)'\n    end\n    trc = rc            /* Save the TBDISPL return code */\n    /* ----------------------- *\n    | Reset USRRFIND to blank |\n    * ----------------------- */\n    usrrfind = ''\n    'vput (usrrfind)'\n    /* ---------------------------------------------------------- *\n    | If the return code from the table display (TBDISPL) is     |\n    | greater than 4 then we are done so leave the forever loop. |\n    * ---------------------------------------------------------- */\n    if trc > 4 then leave\n    /* ------------------------------------------------------- *\n    | Test the zcmd for any commands that we are to           |\n    | process.                                                |\n    * ------------------------------------------------------- */\n   /* ------------------------------- *\n    | Test if there is a command      |\n    * ------------------------------- */\n    if zcmd /= null then\n    if  abbrev(\"FIND\",word(zcmd,1),1) = 1 then\n       save_floc = ztdtop\n    if zcmd = 'RFIND' then\n       zcmd = 'FIND' save_find\n    Select\n      /* ------------------------------------------------- *\n      | Find and Repeat Find processed.                   |\n      |                                                   |\n      |   Checks for the provided string in the specified |\n      |   row variables.                                  |\n      * ------------------------------------------------- */\n      When abbrev(\"FIND\",word(zcmd,1),1) = 1 then do\n        find = translate(word(zcmd,2))\n        save_find = find\n        wrap   = 0\n        if save_floc > 0 then do\n          'tbtop test'\n          'tbskip test number('save_floc')'\n        end\n        do forever\n          'tbskip test'\n          if rc > 0 then do\n            'tbtop test'\n            'tbskip test'\n            if wrap = 1 then do\n              zedsmsg = 'Not Found'\n              zedlmsg = find 'string not found in any member' ,\n                'name. Try again.'\n              'setmsg msg(isrz001)'\n              leave\n            end\n            else wrap = 1\n          end\n          if pos(find,translate(vitem)) > 0 then do\n            'tbquery test position(row)'\n            crp = row\n            save_floc = row\n            if wrap = 1 then do\n              zedsmsg = 'Wrapped'\n              zedlmsg = 'Find restarted at the top of the table.'\n              'setmsg msg(isrz001)'\n            end\n            else do\n              zedsmsg = 'Found'\n              zedlmsg = 'Found in row:' row\n              'setmsg msg(isrz001)'\n            end\n            leave\n          end\n        end\n      end\n      /* ---------------------------------------- *\n      | Demonstrate Locate Processing on the row |\n      * ---------------------------------------- */\n      When abbrev(\"LOCATE\",word(zcmd,1),1) = 1 then do\n        vitem = translate(word(zcmd,2))\n        'tbtop test'\n        crp = 0\n        'tbscan test arglist(vitem) position(crp) condlist(ge)'\n        if rc = 0 then do\n          zedsmsg = 'Found'\n          zedlmsg = word(zcmd,2) 'was found in row' crp\n          'Setmsg msg(isrz001)'\n        end\n        else do\n          zedsmsg = 'Not Found'\n          zedlmsg = word(zcmd,2) 'was not found'\n          'Setmsg msg(isrz001)'\n        end\n      end\n      /* ----------------------------------------------------------- *\n      | Only will check for the provided string (case insensitive)  |\n      | in any location within the row variables.                   |\n      * ----------------------------------------------------------- */\n      When abbrev(\"ONLY\",word(zcmd,1),1) = 1 then do\n        str = subword(zcmd,2)\n        if strip(str) = null then do\n          zedsmsg = 'Only Invalid'\n          zedlmsg = 'Only requires a string parameter.'\n          'Setmsg msg(isrz001)'\n        end\n        else do\n          'tbtop test'\n          do forever\n            'tbskip test'\n            if rc > 0 then do\n              'tbtop test'\n              leave\n            end\n            if pos(str,translate(vitem vstate)) = 0 then\n            'tbdelete test'\n          end\n        end\n      end\n      /* ------------------------------------------------------- *\n      | Refresh will close the table and then signal (goto) the |\n      | Refresh label to start over.                            |\n      * ------------------------------------------------------- */\n      When abbrev(\"REFRESH\",zcmd,1) = 1 then do\n        'tbend test'\n        signal Refresh\n      end\n      /* ------------------------------------------------------ *\n      | Process unknown commands here - basically let the user |\n      | know we didn't know what the command is that they      |\n      | entered.                                               |\n      * ------------------------------------------------------ */\n      Otherwise do\n        zedsmsg = 'Unknown'\n        zedlmsg = zcmd 'is an unknown command - try again.'\n        'Setmsg Msg(isrz001)'\n      end\n    end\n    /* ------------------------------------------------------------ *\n    | Process the line selections if the selection variable (vsel) |\n    | is not null.                                                 |\n    * ------------------------------------------------------------ */\n    if strip(vsel) /= null then do\n\n      /* ------------------------------------------------- *\n      | This code is to support the selection by the user |\n      | pressing enter on the row and not entering any    |\n      | selection value (point and shoot).                |\n      |                                                   |\n      | 1. save the current top row                       |\n      | 2. if the row selected via enter (vset = 1)       |\n      |    then tbtop and then skip to that row           |\n      * ------------------------------------------------- */\n      crp = ztdtop\n      if vset = 1 then do\n        vset = 0\n        \"TBTop test\"\n        \"TBSkip test NUMBER(\"row\")\"\n      end\n\n      Select\n        /* ------------------------- *\n        | Process an individual row |\n        * ------------------------- */\n        When vsel = 'S' then do\n          zedsmsg = null\n          zedlmsg = 'Row data:' vitem\n          'setmsg msg(isrz001)'\n          say 'Row data:' vitem\n          vstate = 'Selected'\n          'tbput test'\n        end\n        /* ---------------------------------------------------------------- *\n        | Process a range selection where the 1st row is selected using SS |\n        | and then the last row with an SS.                                |\n        * ---------------------------------------------------------------- */\n        When vsel = 'SS' then do\n          /* ------------------------------------ *\n          | When only 1 SS is specified           |\n          | if block indicator on then process it |\n          | if not set the block indicator and    |\n          | get the 1st row location              |\n          * ------------------------------------- */\n          if ztdsels = 1 then do\n            if block = 1 then call do_ss\n            else do\n              block = 1\n              vstate = 'SS'\n              'tbput test'\n              'tbquery test position(row1)'\n              row2 = 0\n            end\n          end\n          /* ---------------------------------------- *\n          | When Both from SS and to SS are provided |\n          | - get the 1st row                        |\n          | - set row2 to 0                          |\n          | - set block indicator to on              |\n          * ---------------------------------------- */\n          else do\n            'tbquery test position(row1)'\n            row2 = 0\n            block = 1\n          end\n        end\n        /* -------------------------------------- *\n        | Process a selection with a count S###) |\n        * -------------------------------------- */\n        When left(vsel,1) = 'S' then do\n          /* -------------------------------------------- *\n          | Extract the count from the selection command |\n          * -------------------------------------------- */\n          vcount = substr(vsel,2)\n          /* -------------------- *\n          | Save current top row |\n          * -------------------- */\n          save_top = ztdtop\n          /* --------------------------- *\n          | Validate that it is numeric |\n          * --------------------------- */\n          if datatype(vcount) /= 'NUM' then do\n            zedsmsg = null\n            zedlmsg = 'Invalid selection' vsel '- expecting S###'\n            'setmsg msg(isrz001)'\n          end\n          else do\n            /* -------------------------- *\n            | Get the current row number |\n            | and the # of rows in table |\n            * -------------------------- */\n            'tbquery test position(row1) rownum(rows)'\n            /* -------------------------------- *\n            | Identify the last row to process |\n            * -------------------------------- */\n            row2 = row1 + (vcount - 1)\n            /* -------------------------------- *\n            | Test for going past end of table |\n            * -------------------------------- */\n            if row2 > rows then do\n              zedsmsg = null\n            zedlmsg = vsel 'is invalid as it goes beyond the end of the table.'\n              'setmsg msg(isrz001)'\n            end\n            else do\n              /* --------------------------------------------------- *\n              | Process the 1st row and update the state in the row |\n              * --------------------------------------------------- */\n              say 'Row data:' vitem\n              vstate = 'Selected'\n              'tbput test'\n              /* ------------------------------- *\n              | Skip 1 row and process the rest |\n              * ------------------------------- */\n              'tbskip test'\n              do (row2-row1)\n                'tbget test'\n                say 'Row data:' vitem\n                vstate = 'Selected'\n                'tbput test'\n                'tbskip test'\n              end\n              'tbtop test'\n              'tbskip test number('save_top')'\n            end\n          end\n        end\n        /* ------------------------------ *\n        | Process unknown row selections |\n        * ------------------------------ */\n        Otherwise do\n          zedsmsg = 'Unknown'\n          zedlmsg = vsel 'is an unknown row selection - try again.'\n          'setmsg msg(isrz001)'\n        end\n      end\n      vsel = null\n    end\n  end\n  /* ------------------------------- *\n  | All done so close out the table |\n  | and Exit                        |\n  * ------------------------------- */\n  \"TBEnd test\"\n  Exit 0\n\n  /* ------------------------------- *\n  | Process the SS/SS Range command |\n  * ------------------------------- */\nDo_SS:\n  /* -------------------------------- *\n  | Get the row number of the 2nd SS |\n  * -------------------------------- */\n  'tbquery test position(row2)'\n  /* -------------------------------------------------------- *\n  | Test to see which SS entry is the 1st row to process and |\n  | arrange row1 to the lowest row number and row2 to the    |\n  | highest row number. This allows the range to be selected |\n  | in either direction from any panel.                      |\n  * -------------------------------------------------------- */\n  if row2 < row1 then do\n    rowx = row2\n    row2 = row1\n    row1 = rowx\n  end\n  /* ------------------------------------------------- *\n  | Position to the top row and then skip down to the |\n  | 1st row to process.                               |\n  * ------------------------------------------------- */\n  'tbtop test'\n  'tbskip test number('row1')'\n  /* ------------------------- *\n  | Process the selected rows |\n  * ------------------------- */\n  do row2 - row1 +1\n    /* ---------------- *\n    | Get the row data |\n    * ---------------- */\n    'tbget test'\n    say 'Row data:' vitem\n    /* -------------------------------- *\n    | Update the row state variable    |\n    | Then update the row in the table |\n    | Then skip to the next row.       |\n    * -------------------------------- */\n    vstate = 'Selected'\n    'tbput test'\n    'tbskip test'\n  end\n  /* ----------------------------------------------------- *\n  | When done then reset our working variables and return |\n  * ----------------------------------------------------- */\n  row1 = 0\n  row2 = 0\n  block = 0\n  ztdsels = 0\n  'tbtop test'\n  'tbskip test number('ztdtop')'\n  return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXTABLE": {"ttr": 4100, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x08\\x005\\x01\\x01\\x11O\\x01 \\x12_\\x07'\\x01\\xb2\\x00\\x12\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@\"", "ispf": {"version": "01.08", "flags": 0, "createdate": "2001-04-24T00:00:00", "modifydate": "2020-05-04T07:27:35", "lines": 434, "newlines": 18, "modlines": 0, "user": "REXX"}, "text": "  /* ------------------------ REXX ------------------------ *\n  | Sample REXX Code to drive an ISPF Table to demonstrate |\n  | 1. Processing a command (Refresh)                      |\n  | 2. Processing individual line selections               |\n  | 3. Processing multiple line selections                 |\n  | 4. Processing a range selection (SS/SS)                |\n  | 5. Processing a range count (S###)                     |\n  | 6. Demonstrate Only string capability                  |\n  | 7. Uses IBM's ISRZ001 message (zedsmsg/zedlmsg)        |\n  | 8. Use of Find and RFIND                               |\n  | 9. Use of Locate (TBSCAN)                              |\n  * ------------------------------------------------------ *\n  | ISPF - Developers - Tips and Tricks                    |\n  * ------------------------------------------------------ */\n  /* ------------------------------------ *\n  | Define Addressing to ISPFExec (ISPF) |\n  * ------------------------------------ */\n  Address ISPExec\n\n  /* --------------- *\n  | Define defaults |\n  * --------------- */\n  null    = ''                            /* Null variable for compare */\n\n/* --------------> Enable Repeat Find <------------------- *\n | This approach does not require recursion or creating an |\n | ISPF table for the applications commands. This approach |\n | updates the active site command table in memory.        |\n |                                                         |\n | This does:                                              |\n | 1. Define the commmand table entry                      |\n | 2. vget the variable with the prefix for the site ISPF  |\n |    command table.                                       |\n | 3. define a varable with the command table name         |\n | 4. Move to the top of the command table                 |\n | 5. Establish the table search                           |\n | 6. if the entry is found then add it                    |\n | 7. prime the variable to null                           |\n * ------------------------------------------------------- */\n  zctverb = 'RFIND'\n  zctact = \"&devrfind\"\n  zctdesc = \"User controlled Repeat Find (RFIND)\"\n  zcttrunc = 0\n  'vget (zsctpref)'\n  ctab = zsctpref'cmds'\n  'tbtop' ctab\n  'tbscan' ctab 'arglist(zctdesc) condlist(EQ) Next'\n  if rc > 0 then 'tbadd' ctab\n  devrfind = null\n  'vput (devrfind)'\n\n  /* ---------------------------- *\n  | Label for Refresh Processing |\n  * ---------------------------- */\nRefresh:\n  /* ------------------------------------------------------- *\n  | Define our ISPF Table with two variables and NOWRITE as |\n  | it will not be saved.                                   |\n  * ------------------------------------------------------- */\n  \"TBCreate test names(vitem vstate) nowrite\"\n  /* -------------------------------------- *\n  | Now fill the ISPF table with test data |\n  * -------------------------------------- */\n  str = 'AbcDefGhiJklMnoPqrStuVwxYz0123456789'\n  strc = 1\n  vstate = null\n  do i = 1 to 100\n    vitem =  substr(str,strc,3) 'Test data number:' right(i+1000,3)\n    strc = strc +3\n    if strc > 34 then strc = 1\n    \"TBAdd test\"\n  end\n  /* ------------------------------------------------ *\n  | Table defined and populated - get to the top now |\n  | and define our working variables                 |\n  * ------------------------------------------------ */\n  ztdsels = 0                   /* Define # rows selected to 0 */\n  crp     = 1                   /* Define the starting row to 1 */\n  save_floc = 0                 /* Save last find location */\n  save_find = null              /* save last find string */\n  /* --------------------------------------------------- *\n  | Process the table forever - until we say we're done |\n  * --------------------------------------------------- */\n  do forever\n    /* -------------------------------------------- *\n    | Define devrfind for Passthru to enable RFIND |\n    * -------------------------------------------- */\n    devrfind = 'PASSTHRU'\n    'vput (devrfind)'\n    /* ---------------------------------------------------- *\n    | Test ZTDSELS - if greater than zero than display the |\n    | table without the Panel name                         |\n    | - if zero than display with the Panel name           |\n    |   after 1st reseting the display to the last location|\n    * ---------------------------------------------------- */\n    if ztdsels > 0\n    then 'tbdispl test'\n    else do\n      'tbtop test'\n      'tbskip test number('crp')'\n      'tbdispl test panel(pntab)'\n    end\n    trc = rc            /* Save the TBDISPL return code */\n    /* ----------------------- *\n    | Reset devrfind to blank |\n    * ----------------------- */\n    devrfind = ''\n    'vput (devrfind)'\n    /* ---------------------------------------------------------- *\n    | If the return code from the table display (TBDISPL) is     |\n    | greater than 4 then we are done so leave the forever loop. |\n    * ---------------------------------------------------------- */\n    if trc > 4 then leave\n    /* ------------------------------------------------------- *\n    | Test the zcmd for any commands that we are to           |\n    | process.                                                |\n    * ------------------------------------------------------- */\n   /* ------------------------------- *\n    | Test if there is a command      |\n    * ------------------------------- */\n    if zcmd /= null then\n    if  abbrev(\"FIND\",word(zcmd,1),1) = 1 then\n       save_floc = ztdtop\n    if zcmd = 'RFIND' then\n       zcmd = 'FIND' save_find\n    Select\n      /* ------------------------------------------------- *\n      | Find and Repeat Find processed.                   |\n      |                                                   |\n      |   Checks for the provided string in the specified |\n      |   row variables.                                  |\n      * ------------------------------------------------- */\n      When abbrev(\"FIND\",word(zcmd,1),1) = 1 then do\n        find = translate(word(zcmd,2))\n        save_find = find\n        wrap   = 0\n        if save_floc > 0 then do\n          'tbtop test'\n          'tbskip test number('save_floc')'\n        end\n        do forever\n          'tbskip test'\n          if rc > 0 then do\n            'tbtop test'\n            'tbskip test'\n            if wrap = 1 then do\n              zedsmsg = 'Not Found'\n              zedlmsg = find 'string not found in any member' ,\n                'name. Try again.'\n              'setmsg msg(isrz001)'\n              leave\n            end\n            else wrap = 1\n          end\n          if pos(find,translate(vitem)) > 0 then do\n            'tbquery test position(row)'\n            crp = row\n            save_floc = row\n            if wrap = 1 then do\n              zedsmsg = 'Wrapped'\n              zedlmsg = 'Find restarted at the top of the table.'\n              'setmsg msg(isrz001)'\n            end\n            else do\n              zedsmsg = 'Found'\n              zedlmsg = 'Found in row:' row\n              'setmsg msg(isrz001)'\n            end\n            leave\n          end\n        end\n      end\n      /* ---------------------------------------- *\n      | Demonstrate Locate Processing on the row |\n      * ---------------------------------------- */\n      When abbrev(\"LOCATE\",word(zcmd,1),1) = 1 then do\n        vitem = translate(word(zcmd,2))\n        'tbtop test'\n        crp = 0\n        'tbscan test arglist(vitem) position(crp) condlist(ge)'\n        if rc = 0 then do\n          zedsmsg = 'Found'\n          zedlmsg = word(zcmd,2) 'was found in row' crp\n          'Setmsg msg(isrz001)'\n        end\n        else do\n          zedsmsg = 'Not Found'\n          zedlmsg = word(zcmd,2) 'was not found'\n          'Setmsg msg(isrz001)'\n        end\n      end\n      /* ----------------------------------------------------------- *\n      | Only will check for the provided string (case insensitive)  |\n      | in any location within the row variables.                   |\n      * ----------------------------------------------------------- */\n      When abbrev(\"ONLY\",word(zcmd,1),1) = 1 then do\n        str = subword(zcmd,2)\n        if strip(str) = null then do\n          zedsmsg = 'Only Invalid'\n          zedlmsg = 'Only requires a string parameter.'\n          'Setmsg msg(isrz001)'\n        end\n        else do\n          'tbtop test'\n          do forever\n            'tbskip test'\n            if rc > 0 then do\n              'tbtop test'\n              leave\n            end\n            if pos(str,translate(vitem vstate)) = 0 then\n            'tbdelete test'\n          end\n        end\n      end\n      /* ------------------------------------------------------- *\n      | Refresh will close the table and then signal (goto) the |\n      | Refresh label to start over.                            |\n      * ------------------------------------------------------- */\n      When abbrev(\"REFRESH\",zcmd,1) = 1 then do\n        'tbend test'\n        signal Refresh\n      end\n      /* ------------------------------------------------------ *\n      | Process unknown commands here - basically let the user |\n      | know we didn't know what the command is that they      |\n      | entered.                                               |\n      * ------------------------------------------------------ */\n      Otherwise do\n        zedsmsg = 'Unknown'\n        zedlmsg = zcmd 'is an unknown command - try again.'\n        'Setmsg Msg(isrz001)'\n      end\n    end\n    /* ------------------------------------------------------------ *\n    | Process the line selections if the selection variable (vsel) |\n    | is not null.                                                 |\n    * ------------------------------------------------------------ */\n    if strip(vsel) /= null then do\n\n      /* ------------------------------------------------- *\n      | This code is to support the selection by the user |\n      | pressing enter on the row and not entering any    |\n      | selection value (point and shoot).                |\n      |                                                   |\n      | 1. save the current top row                       |\n      | 2. if the row selected via enter (vset = 1)       |\n      |    then tbtop and then skip to that row           |\n      * ------------------------------------------------- */\n      crp = ztdtop\n      if vset = 1 then do\n        vset = 0\n        \"TBTop test\"\n        \"TBSkip test NUMBER(\"row\")\"\n      end\n\n      Select\n        /* ------------------------- *\n        | Process an individual row |\n        * ------------------------- */\n        When vsel = 'S' then do\n          zedsmsg = null\n          zedlmsg = 'Row data:' vitem\n          'setmsg msg(isrz001)'\n          say 'Row data:' vitem\n          vstate = 'Selected'\n          'tbput test'\n        end\n        /* ---------------------------------------------------------------- *\n        | Process a range selection where the 1st row is selected using SS |\n        | and then the last row with an SS.                                |\n        * ---------------------------------------------------------------- */\n        When vsel = 'SS' then do\n          /* ------------------------------------ *\n          | When only 1 SS is specified           |\n          | if block indicator on then process it |\n          | if not set the block indicator and    |\n          | get the 1st row location              |\n          * ------------------------------------- */\n          if ztdsels = 1 then do\n            if block = 1 then call do_ss\n            else do\n              block = 1\n              vstate = 'SS'\n              'tbput test'\n              'tbquery test position(row1)'\n              row2 = 0\n            end\n          end\n          /* ---------------------------------------- *\n          | When Both from SS and to SS are provided |\n          | - get the 1st row                        |\n          | - set row2 to 0                          |\n          | - set block indicator to on              |\n          * ---------------------------------------- */\n          else do\n            'tbquery test position(row1)'\n            row2 = 0\n            block = 1\n          end\n        end\n        /* -------------------------------------- *\n        | Process a selection with a count S###) |\n        * -------------------------------------- */\n        When left(vsel,1) = 'S' then do\n          /* -------------------------------------------- *\n          | Extract the count from the selection command |\n          * -------------------------------------------- */\n          vcount = substr(vsel,2)\n          /* -------------------- *\n          | Save current top row |\n          * -------------------- */\n          save_top = ztdtop\n          /* --------------------------- *\n          | Validate that it is numeric |\n          * --------------------------- */\n          if datatype(vcount) /= 'NUM' then do\n            zedsmsg = null\n            zedlmsg = 'Invalid selection' vsel '- expecting S###'\n            'setmsg msg(isrz001)'\n          end\n          else do\n            /* -------------------------- *\n            | Get the current row number |\n            | and the # of rows in table |\n            * -------------------------- */\n            'tbquery test position(row1) rownum(rows)'\n            /* -------------------------------- *\n            | Identify the last row to process |\n            * -------------------------------- */\n            row2 = row1 + (vcount - 1)\n            /* -------------------------------- *\n            | Test for going past end of table |\n            * -------------------------------- */\n            if row2 > rows then do\n              zedsmsg = null\n            zedlmsg = vsel 'is invalid as it goes beyond the end of the table.'\n              'setmsg msg(isrz001)'\n            end\n            else do\n              /* --------------------------------------------------- *\n              | Process the 1st row and update the state in the row |\n              * --------------------------------------------------- */\n              say 'Row data:' vitem\n              vstate = 'Selected'\n              'tbput test'\n              /* ------------------------------- *\n              | Skip 1 row and process the rest |\n              * ------------------------------- */\n              'tbskip test'\n              do (row2-row1)\n                'tbget test'\n                say 'Row data:' vitem\n                vstate = 'Selected'\n                'tbput test'\n                'tbskip test'\n              end\n              'tbtop test'\n              'tbskip test number('save_top')'\n            end\n          end\n        end\n        /* ------------------------------ *\n        | Process unknown row selections |\n        * ------------------------------ */\n        Otherwise do\n          zedsmsg = 'Unknown'\n          zedlmsg = vsel 'is an unknown row selection - try again.'\n          'setmsg msg(isrz001)'\n        end\n      end\n      vsel = null\n    end\n  end\n  /* ------------------------------- *\n  | All done so close out the table |\n  | and Exit                        |\n  * ------------------------------- */\n  \"TBEnd test\"\n  Exit 0\n\n  /* ------------------------------- *\n  | Process the SS/SS Range command |\n  * ------------------------------- */\nDo_SS:\n  /* -------------------------------- *\n  | Get the row number of the 2nd SS |\n  * -------------------------------- */\n  'tbquery test position(row2)'\n  /* -------------------------------------------------------- *\n  | Test to see which SS entry is the 1st row to process and |\n  | arrange row1 to the lowest row number and row2 to the    |\n  | highest row number. This allows the range to be selected |\n  | in either direction from any panel.                      |\n  * -------------------------------------------------------- */\n  if row2 < row1 then do\n    rowx = row2\n    row2 = row1\n    row1 = rowx\n  end\n  /* ------------------------------------------------- *\n  | Position to the top row and then skip down to the |\n  | 1st row to process.                               |\n  * ------------------------------------------------- */\n  'tbtop test'\n  'tbskip test number('row1')'\n  /* ------------------------- *\n  | Process the selected rows |\n  * ------------------------- */\n  do row2 - row1 +1\n    /* ---------------- *\n    | Get the row data |\n    * ---------------- */\n    'tbget test'\n    say 'Row data:' vitem\n    /* -------------------------------- *\n    | Update the row state variable    |\n    | Then update the row in the table |\n    | Then skip to the next row.       |\n    * -------------------------------- */\n    vstate = 'Selected'\n    'tbput test'\n    'tbskip test'\n  end\n  /* ----------------------------------------------------- *\n  | When done then reset our working variables and return |\n  * ----------------------------------------------------- */\n  row1 = 0\n  row2 = 0\n  block = 0\n  ztdsels = 0\n  'tbtop test'\n  'tbskip test number('ztdtop')'\n  return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXTM": {"ttr": 4108, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00%\\x01 \\t/\\x01 \\t/\\t3\\x00\\x15\\x00\\t\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2020-04-01T00:00:00", "modifydate": "2020-04-01T09:33:25", "lines": 21, "newlines": 9, "modlines": 0, "user": "REXX"}, "text": " /* -------------------- REXX ---------------------------- *\n  | Driver for the RXTSOMAC to demonstrate calling it      |\n  | as a TSO command and then as an ISPF Edit Macro.       |\n  |                                                        |\n  | ISPF - Developers - Tips and Tricks                    |\n  * ------------------------------------------------------ */\n\n/* -------------------- *\n | Run as a TSO command |\n * -------------------- */\n  '%rxtsomac'\n/* --------------------------------------------------- *\n | Get the current dataset name from the parse source  |\n | Get into ISPExec                                    |\n | View the RXTSOMAC member with a macro of RXTSOMAC   |\n | - should issue a SAY running as macro and then exit |\n * --------------------------------------------------- */\n  parse source x1 x2 x3 dsn x5\n  x = listdsi(dsn \"File\")\n  Address ISPExec\n  \"View dataset('\"sysdsname\"(rxtsomac)') macro(rxtsomac)\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXTSOMAC": {"ttr": 4110, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x0c\\x00\\x04\\x01 \\t/\\x01 \\t?\\x04'\\x00\\x1a\\x00\\x10\\x00\\x00\\xe2\\xd3\\xc2\\xc4@@@@@@\"", "ispf": {"version": "01.12", "flags": 0, "createdate": "2020-04-01T00:00:00", "modifydate": "2020-04-02T04:27:04", "lines": 26, "newlines": 16, "modlines": 0, "user": "SLBD"}, "text": "  /* ------------------------------------------------------ *\n  | Test if called as an Edit Macro                        |\n  | RC > 0 means TSO else Edit Macro                       |\n  |                                                        |\n  | ISPF - Developers - Tips and Tricks                    |\n  * ------------------------------------------------------ */\n  Address ISREdit\n  'macro (options)'\n  if rc > 0 then do\n    Address TSO\n    tsomac = 1\n    parse arg options\n    say 'Lines of code via sourceline:' sourceline()\n  end\n  else tsomac = 0\n  If tsomac = 1\n  then say 'Running as a TSO Command'\n  else do\n    say 'Running as an ISPF Edit Macro'\n    '(dataset) = dataset'\n    '(member) = member'\n    '(last) = linenum .zlast'\n    say 'Dataset:' dataset 'Member:' member 'Lines:' last+0\n    'end'\n  end\n  Exit\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXVDSN": {"ttr": 4112, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\"\\x01\\x19\\x08_\\x01\\x19\\x08\\x8f\\x10I\\x00\\x0f\\x00\\t\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-03-26T00:00:00", "modifydate": "2019-03-29T10:49:22", "lines": 15, "newlines": 9, "modlines": 0, "user": "REXX"}, "text": "/* ---------------- REXX ------------------------ *\n | Demonstate using ISPF Panel Rexx to validatee  |\n | that a data set exists and is not just entered |\n | with a valid format.                           |\n |                                                |\n | ISPF - Developers - Tips and Tricks            |\n * ---------------------------------------------- */\n  address ispexec\n  do forever\n    'addpop'\n    'display panel(pnvdsn)'\n    drc = rc\n    'rempop'\n    if drc > 0 then leave\n  end\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SAMPGIT": {"ttr": 4353, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x03\\x00R\\x01\\x196\\x0f\\x01\\x196\\x0f\\x13D\\x00'\\x00\\x08\\x00\\x00\\xe2\\xc1\\xd4\\xd7\\xd3\\xc5@@@@\"", "ispf": {"version": "01.03", "flags": 0, "createdate": "2019-12-26T00:00:00", "modifydate": "2019-12-26T13:44:52", "lines": 39, "newlines": 8, "modlines": 0, "user": "SAMPLE"}, "text": "The goal in a merge resolution is to merge the two sections\ninto one and remove the merge separators. Then when saved the\nmerge is completed and the remote file is merged into the current\nfile. If the text is colorized that may indicate that the ISPF Edit\nhilite is enabled.\n<<<<<<< HEAD\nThis is a sample merge file with\nhead section denoted by the <<<<<<< HEAD being the\ndata in the current file. And data after the =======\nbeing in the file being merged into the current file.\nThe >>>>>>> x is the tail end of the data from the\nremote file delta.\n=======\nThis is a sample merge file with head section\ndenoted by the <<<<<<< HEAD being the data in the\ncurrent file. And data after the ======= being in the\nfile being merged into the current file.  The >>>>>>> x\nis the tail end of the data from the remote file delta.\n>>>>>>> x\nThis is data that is the same in both files.\nAnd thus does not need any attention during the\nconflict resolution.\n<<<<<<< HEAD\nThis is a sample merge file with\nhead section denoted by the <<<<<<< HEAD being the\ndata in the current file. And data after the =======\nbeing in the file being merged into the current file.\nThe >>>>>>> x is the tail end of the data from the\nremote file delta.\n=======\nThis is a sample merge file with head section\ndenoted by the <<<<<<< HEAD being the data in the\ncurrent file. And data after the ======= being in the\nfile being merged into the current file.  The >>>>>>> x\nis the tail end of the data from the remote file delta.\n>>>>>>> x\nThis is data that is the same in both files.\nAnd thus does not need any attention during the\nconflict resolution.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SKCMDS": {"ttr": 4355, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x03\\x00\\x850\\x1f\\x01\\x19\\x10o\\tT\\x00\\x0c\\x00\\x05\\x00\\x00\\xe2\\xd2\\xc5\\xd3@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1985-10-28T00:00:00", "modifydate": "2019-04-16T09:54:03", "lines": 12, "newlines": 5, "modlines": 0, "user": "SKEL"}, "text": ")TB  20\n)SET CNT = 50\n)DOT &TABLE\n)SET CNT = &CNT + 3\n)SEL &CNT > 50\n1 ISPF Command Table &TABLE       Date: &zdate Time: &ztime\n)SET CNT = 1\n)ENDSEL\n0CMD:  &ZCTVERB!&ZCTTRUNC\n Action: &ZCTACT\n Desc:   &ZCTDESC\n)ENDDOT\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SKREXX": {"ttr": 4357, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00S\\x01\\x19\\x11?\\x01\\x19\\x11?\\t6\\x00\\x1c\\x00\\x1c\\x00\\x00\\xe2\\xd2\\xc5\\xd3@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-04-23T00:00:00", "modifydate": "2019-04-23T09:36:53", "lines": 28, "newlines": 28, "modlines": 0, "user": "SKEL"}, "text": ")CM Demo use of TSO stack in an ISPF skeleton\n\n)CM Make list\n)REXX STACKN\n \"delstack\"\n queue 'Kilroy'\n queue 'was'\n queue 'here'\n stackn = queued()\n)ENDREXX\n\n)CM Make fixed front\n//SKEL1    JOB (1),'BACKUP',CLASS=A,COND=(0,LT),REGION=64M\n//L        EXEC PGM=IEBGENER\n//SYSIN    DD DUMMY\n//SYSPRINT DD SYSOUT=*\n//SYSUT1   DD *\n\n)CM Make SYSUT1 from list in stack\n)DO N = 1 TO &STACKN\n)REXX DATA\n parse pull data\n)ENDREXX\n&data\n)ENDDO\n\n)CM Make fixed back\n//SYSUT2   DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SKREXXE": {"ttr": 4359, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x06\\x01\\x19\\x11?\\x01\\x19\\x12/\\x08F\\x00\\x19\\x00\\x1c\\x00\\x00\\xe2\\xd2\\xc5\\xd3@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-04-23T00:00:00", "modifydate": "2019-05-02T08:46:06", "lines": 25, "newlines": 28, "modlines": 0, "user": "SKEL"}, "text": ")CM Demo use of TSO stack in an ISPF skeleton\n)REXX STACKN\n\"alloc f(in) ds('sys1.proclib(bpxas)') shr reuse\"\n'execio * diskr in (finis stem in.'\n'free f(in)'\n \"delstack\"\n queue 'Reviewing BPXAS Proc'\n queue left('-',80,'-')\ndo i = 1 to in.0\n  queue in.i\n  end\n queue left('-',80,'-')\n queue '  '\n queue 'Including' in.0 'records.'\n stackn = queued()\n)ENDREXX\n)CM Get the data from the stack\n)CM The variable STACKN is passed from the Skeleton REXX above\n)CM with the number of records in the stack (queue)\n)DO N = 1 TO &STACKN\n)REXX DATA\n parse pull data\n)ENDREXX\n&data\n)ENDDO\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SKREXXV": {"ttr": 4361, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x17\\x01\\x19'\\x0f\\x01\\x19'\\x0f\\x16B\\x00\\x12\\x00\\x12\\x00\\x00\\xe2\\xd2\\xc5\\xd3@@@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-09-27T00:00:00", "modifydate": "2019-09-27T16:42:17", "lines": 18, "newlines": 18, "modlines": 0, "user": "SKEL"}, "text": ")CM Demo use of TSO stack in an ISPF skeleton with a passed variable\n\n)REXX STACKN dsname\n \"delstack\"\n x = listdsi(dsname)\n queue 'DSName is:' sysdsname\n queue 'Volser is:' sysvolume\n queue 'RECFM:' sysrecfm 'LRECL:' syslrecl 'BLKSIZE:' sysblksize\n stackn = queued()\n)ENDREXX\n\n)CM Insert the information from the LISTDSI\n)DO N = 1 TO &STACKN\n)REXX DATA\n parse pull data\n)ENDREXX\n&data\n)ENDDO\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT990/FILE990.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT990", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}