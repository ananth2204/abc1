{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012214000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 117572, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 6, "INMDSNAM": "CBT.V500.FILE496.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 117572, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 117572, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE496.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x03\\x06'", "DS1TRBAL": "b'gv'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xb0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xb0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x03\\xca\\x00\\x0b\\x03\\xca\\x00\\x0e\\x00\\x04'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04`\\x00D\\x01\\x18$\\x8f\\x01\\x18$\\x8f\\x14B\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf6@@@'", "ispf": {"version": "04.96", "flags": 0, "createdate": "2018-09-05T00:00:00", "modifydate": "2018-09-05T14:42:44", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-496"}, "text": "REGULAR CBT TAPE - VERSION 496    FILE:  496\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT496.FILE496\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 4 MEMBERS COUNTED; CUMULATIVE SIZE IS 885 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   09/05/18    14:42:44    UTC-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FILE496": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04`\\x008\\x01\\x18$\\x8f\\x01\\x18$\\x8f\\x14B\\x00\\x13\\x00\\x13\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf6@@@'", "ispf": {"version": "04.96", "flags": 0, "createdate": "2018-09-05T00:00:00", "modifydate": "2018-09-05T14:42:38", "lines": 19, "newlines": 19, "modlines": 0, "user": "CBT-496"}, "text": "//***FILE 496 is from Ken MacKenzie and contains a REXX exec to     *   FILE 496\n//*           display your TSO session's dataset allocations.       *   FILE 496\n//*           Better than LISTA.  There are others like it, but     *   FILE 496\n//*           this one's good, too.                                 *   FILE 496\n//*                                                                 *   FILE 496\n//*           This exec works well with the DISP exec from File     *   FILE 496\n//*           487.  TSO DISP TIOT  is the command, and you can      *   FILE 496\n//*           then ISPF VIEW your allocations.                      *   FILE 496\n//*                                                                 *   FILE 496\n//*           Ken's exec has been modified by Marty Kuntz.  We      *   FILE 496\n//*           have kept the old exec as member TIOT01.  The new     *   FILE 496\n//*           one is member TIOT.                                   *   FILE 496\n//*                                                                 *   FILE 496\n//*           Ken MacKenzie                                         *   FILE 496\n//*           Ken.MacKenzie@prudential.com                          *   FILE 496\n//*                                                                 *   FILE 496\n//*           Home Email: ken.mackenzie@tesco.net                   *   FILE 496\n//*                     : ken.mackenzie@talk21.com                  *   FILE 496\n//*                                                                 *   FILE 496\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TIOT": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x000\\x01\\x18$\\x8f\\x01\\x18$\\x8f\\x139\\x01\\xb8\\x01\\xb8\\x00\\x00\\xd4\\xd2\\xe4\\xd5\\xe3\\xe9@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-09-05T00:00:00", "modifydate": "2018-09-05T13:39:30", "lines": 440, "newlines": 440, "modlines": 0, "user": "MKUNTZ"}, "text": "  trace_setting = Trace('O') /**REXX**/\n/**********************************************************************\n*  TIOT exec - Ken MacKenzie - May 1998                               *\n*                                                                     *\n*  This exec will display (or return) a list of all datasets          *\n*  allocated to a particular ddname or all datasets allocated to all  *\n*  ddnames.  If the exec is entered as a command, the results are     *\n*  displayed (using \"STEMDISP\" or \"say\" ) or, if the command is       *\n*  invoked from another exec, the results are returned as a string    *\n*  consisting of the ddname enclosed in asterisks followed by a list  *\n*  of dataset names (individually) enclosed in quotes.  Use of this   *\n*  exec is faster and a lot less messy than using a combination of    *\n*  OUTTRAP and the LISTALC ST H command.  If you don't have STEMDISP  *\n*  at your site, you can obtain a copy of Gilbert Saint-Flour's       *\n*  version via the CBT (file 183).                                    *\n*                                                                     *\n*  Additionally, a TABLE parameter can be supplied.  This is in the   *\n*  form TABLE(table-name dd-var-name dsn-var-name).  If this          *\n*  parameter is supplied, the results are written to an ISPF table    *\n*  which can then be used to drive another process.                   *\n*---------------------------------------------------------------------*\n*  Limited support can be obtained from the author:                   *\n*  ken.mackenzie@bigfoot.com                                          *\n*---------------------------------------------------------------------*\n*  Examples of use can be found at the end of the exec                *\n*---------------------------------------------------------------------*\n*  Amendment History (Latest First)                                   *\n*                                                                     *\n*  05 November  2002 - Ken MacKenzie                                  *\n*                    - Changed TABLE processing to allow output       *\n*                      to a permanent table (via the LIBRARY option)  *\n*                                                                     *\n*  19 January   2001 - Ken MacKenzie                                  *\n*                    - Changed TABLE processing to NOWRITE            *\n*                    - Added \"Address TSO\" to VIEWSTEM procedure      *\n*                                                                     *\n*  09 January   2001 - Ken MacKenzie                                  *\n*                    - Added TABLE processing                         *\n*                    - Changed the parameter handling                 *\n*                      (/DEBUG has changed to DEBUG(opt))             *\n*                      and the TABLE() parameter can now be used      *\n*                                                                     *\n*  08 January   2001 - Ken MacKenzie                                  *\n*                    - Simplify detection of the '/DEBUG'             *\n*                      parameter                                      *\n*                    - Use an internal routine to VIEW the            *\n*                      output if STEMDISP isn't available             *\n*                                                                     *\n*  04 January   2001 - Ken MacKenzie                                  *\n*                    - Updated the comments                           *\n*                    - Added a call to STEMDISP                       *\n*                    - SWAREQ coding brought in-line                  *\n*                    - Added Examples of Use                          *\n*                    - Use Numeric Digits 10 to allow for             *\n*                      addresses greater than 3B9AC9FF                *\n*                    - allow a '/DEBUG' parameter to be               *\n*                      supplied                                       *\n*                                                                     *\n*  15 December  2000 - Ken MacKenzie                                  *\n*                    - Turn off tracing                               *\n*                                                                     *\n*  20 May       1998 - Ken MacKenzie                                  *\n*                    - Initial coding                                 *\n**********************************************************************/\n\n/**********************************************************************\n*  Parm handling has been moved to a called routine: Extract_Parms    *\n**********************************************************************/\n  true = 1; false = 0\n  Call Extract_Parms Arg(1)\n  trace_setting = Trace(debug)         /*Set debugging option       */\n  Numeric Digits 10                    /*Allow for big addresses    */\n  Parse Source . calltype .            /*Determine if we were called*/\n  If calltype = 'FUNCTION',            /*as a subroutine and set a  */\n   | calltype = 'SUBROUTINE' Then      /*variable as appropriate    */\n    subroutine = true\n  Else\n    subroutine = false\n\n  If tb_required Then\n    Do\n      If lib_required Then\n        libparm = 'LIBRARY('libnam') WRITE'\n      Else\n        libparm = ''\n      Address ISPEXEC\n      \"TBCREATE\" tbnam \"NAMES(\" tbddn tbdsn \") REPLACE\" libparm\n    End\n  xlen = 0                             /*bypassing jobname/stepnames*/\n\n  If subroutine Then\n    xstring =\n  Else\n    xstring.0 = 0\n  ddfound = false\n/*******************************************************************\n*  Loop through the TIOT looking for DDnames.                      *\n*  The first byte of each entry contains the length of that entry  *\n*  The first bit of the second byte is on if the entry is not in   *\n*  use.                                                            *\n*  Bytes  5-12 contain the DDname.                                 *\n*  Bytes 13-15 contain the SWA address                             *\n*  If there is a requested DD, we use the ddfound flag to control  *\n*  whether we've found the requested DD.  This is because          *\n*  concatenated files have a blank DDname.                         *\n*******************************************************************/\n  relno = 0\n  Do Forever\n    relno = relno + 1\n    Call Bpxwdyn 'Info Inrelno('relno') Inrtlst(last)',\n      'inrtddn(ddname) inrtdsn(dsname)'\n    Select\n      When result \\= 0 Then\n        Leave\n      When reqdd = '' Then\n        ddfound = true\n      When ddname = reqdd Then\n        ddfound = true\n      When ddname = '' Then\n        Nop\n      When ddname \\= reqdd Then\n        If ddfound Then\n          Leave\n      Otherwise\n        Nop\n    End\n    If \\ddfound Then\n      iterate\n    If subroutine Then\n      If ddname \\= '' Then\n        xstring = xstring '*'Strip(ddname,'T')'*'\n    If subroutine Then\n      xstring = xstring \"'\"dsname\"'\"\n    Else\n      Do\n        xstring.0 = xstring.0 + 1\n        If ddname \\= '' & xstring.0 \\= 1 Then\n          Do\n            x = Value('xstring.'xstring.0, ' ')\n            xstring.0 = xstring.0 + 1\n          End\n        x = Value('xstring.'xstring.0, Left(ddname,8) dsname)\n      End\n    If tb_required Then\n      Do\n        Address ISPEXEC\n        Call Value tbddn, ddname\n        Call Value tbdsn, dsname\n        \"TBADD\" tbnam\n      End\n  End\n  If tb_required & lib_required Then\n    Do\n    \"TBCLOSE\" tbnam \"LIBRARY(\"libnam\")\"\n    \"CONTROL ERRORS RETURN\"\n    \"TBOPEN 0H-DEAR LIBRARY(0H-DEAR) NOWRITE\"\n    End\n/********************************************************************\n*  If we're running as a subroutine then we simply return a string  *\n********************************************************************/\n  If Subroutine Then\n    Return xstring\n/***********************************************************************\n*  If we're running as a command then we have to display the           *\n*  allocations.                                                        *\n*  If we are running under ISPF, we attempt to use \"STEMDISP\" and, if  *\n*  that fails, we use the internal \"VIEWSTEM\" routine; if that fails,  *\n*  we use \"say\" statements.                                            *\n*  If we are running under native TSO, we just use \"say\" statements.   *\n***********************************************************************/\n  If reqdd = '' Then                   /*Set                         */\n    view_dd = 'all files'              /*    up a                    */\n  Else                                 /*         header             */\n    view_dd = reqdd                    /*                line        */\n  view_header = 'User:' Sysvar(Sysuid) '- file allocations:' view_dd\n  If Sysvar(Sysispf) \\= 'ACTIVE' Then\n    Call Non_Ispf_Display\n  Else\n    Do\n      Signal On Syntax                 /*In case STEMDISP fails      */\n      Call 'STEMDISP'  'VIEW', 'XSTRING.',,, view_header\n      Signal Off Syntax\n    End\n  Return 0\nSyntax:\n/*****************************************************************\n*  We come here in the event of a SYNTAX error.  Basically that  *\n*  means that the call to STEMDISP failed.                       *\n*  So we attempt to use the internal VIEWSTEM.  If that returns  *\n*  \"true\" it worked and we exit; otherwise we continue just      *\n*  with \"say\" statements.                                        *\n*****************************************************************/\n    Address ISPEXEC \"CONTROL DISPLAY LINE START(1)\"\n    If Viewstem() Then\n      Return\nNon_Ispf_Display:\n/*****************************************************************\n*  We come here either by dropping through from the SYNTAX error *\n*  routine (above) or when we are running in native TSO          *\n*****************************************************************/\n  Say view_header\n  Do i = 1 To xstring.0\n    Say xstring.i\n  End\n  Return 0\n/***************************************************************\n *  The following routine was provided by Gilbert Saint-Flour  *\n *  and later, Sam Golob.                                      *\n *  I have included it as an internal function because it is   *\n *  easier to package that way.                                *\n ***************************************************************/\n/*---- REXX ---- */ /*------------------------------------------------*\\\n|*                                                                    *|\n|* MODULE NAME = SWAREQ                                               *|\n|*                                                                    *|\n|* DESCRIPTIVE NAME = Convert an SVA to a 31-bit address              *|\n|*                                                                    *|\n|* STATUS = R200                                                      *|\n|*                                                                    *|\n|* FUNCTION = The SWAREQ function simulates the SWAREQ macro to       *|\n|*            convert an SWA Virtual Address (SVA) to a full 31-bit   *|\n|*            address which can be used to access SWA control blocks  *|\n|*            in the SWA=ABOVE environment.  The input is a 3-byte    *|\n|*            SVA; the output value is a 10-digit decimal number.     *|\n|*                                                                    *|\n|* AUTHOR   =  Gilbert Saint-Flour <gsf@pobox.com>                    *|\n|*                                                                    *|\n|* DEPENDENCIES = TSO/E V2                                            *|\n|*                                                                    *|\n|* SYNTAX   =  SWAREQ(sva)                                            *|\n|*                                                                    *|\n|*             sva must contain a 3-byte SVA.                         *|\n|*                                                                    *|\n|* Sample Invocation:                                                 *|\n|*                                                                    *|\n|*    NUMERIC DIGITS 10                                               *|\n|*    tcb = C2D(STORAGE(21C,4))         /* TCB          PSATOLD  */   *|\n|*    tiot= C2D(STORAGE(D2X(tcb+12),4)) /* TIOT         TCBTIO   */   *|\n|*    sva = STORAGE(D2X(tiot+36),3)     /* First JFCB   TIOEJFCB */   *|\n|*    jfcb=SWAREQ(sva)             /* convert SVA to 31-bit addr */   *|\n|*    dsn=STORAGE(D2X(jfcb),44)         /* dsname       JFCBDSNM */   *|\n|*    vol=STORAGE(D2X(jfcb+118),6)      /* volser       JFCBVOLS */   *|\n|*    SAY 'sva='C2X(sva) 'jfcb='D2X(jfcb) 'dsn='dsn 'vol='vol         *|\n|*                                                                    *|\n\\*--------------------------------------------------------------------*/\n/*SWAREQ: PROCEDURE */\nNUMERIC DIGITS 20                         /* allow up to 2**64    */\nsva=C2D(ARG(1))                           /* convert to decimal   */\ntcb = C2D(STORAGE(21C,4))                 /* TCB         PSATOLD  */\njscb = C2D(STORAGE(D2X(tcb+180),4))       /* JSCB        TCBJSCB  */\nqmpl = C2D(STORAGE(D2X(jscb+244),4))      /* QMPL        JSCBQMPI */\n/* See if qmat can be above the bar */\nqmsta= C2X(STORAGE(D2X(qmpl+16),1))       /* JOB STATUS BYTE      */\nif SUBSTR(X2B(qmsta),6,1) then            /* is QMQMAT64 bit on?  */\ndo                                        /* yes, qmat can be ATB */\n  IF RIGHT(X2B(C2X(ARG(1))),1) \\= '1' THEN/* SWA=BELOW ?          */\n    RETURN C2D(ARG(1))+16                 /* yes, return sva+16   */\n  qmat=C2D(STORAGE(D2X(qmpl+10),2))*(2**48) +,/* QMAT+0  QMADD01  */\n       C2D(STORAGE(D2X(qmpl+18),2))*(2**32) +,/* QMAT+2  QMADD23  */\n       C2D(STORAGE(D2X(qmpl+24),4))       /* QMAT+4      QMADD    */\n  RETURN C2D(STORAGE(D2X(qmat+(sva*12)+64),4))+16\nend\nelse\ndo                                        /* no, qmat is BTB      */\n  IF RIGHT(C2X(ARG(1)),1) \\= 'F' THEN     /* SWA=BELOW ?          */\n    RETURN C2D(ARG(1))+16                 /* yes, return sva+16   */\n  qmat = C2D(STORAGE(D2X(qmpl+24),4))     /* QMAT        QMADD    */\n  DO WHILE sva>65536\n    qmat = C2D(STORAGE(D2X(qmat+12),4))   /* next QMAT   QMAT+12  */\n    sva=sva-65536                         /* 010006F -> 000006F   */\n  END\n  RETURN C2D(STORAGE(D2X(qmat+sva+1),4))+16\nend\n/*-------------------------------------------------------------------*/\nViewstem:\nProcedure Expose xstring. view_header\n/********************************************************************\n*  This routine attempts to allocate a temporary file whose DDname  *\n*  is based around the current time (in an effort to be unique).    *\n*  The view header and all xstring. variables are then written to   *\n*  the file and the file is then passed to ISPF view.               *\n*  If everything appeared to work OK, we return TRUE otherwise we   *\n*  return FALSE.                                                    *\n********************************************************************/\n  Parse Value Time('L') With hh ':' mm ':' ss '.' ths\n  true = 1; false = 0\n  p = substr('ABCDEFGHIJKLMNOPQRSTUVWXY',hh+1,1)\n  viewdd = Left(p || mm || ss || ths, 8)\n\n  Address TSO\n  Signal On Error\n  x = Msg('OFF')\n  \"ALLOC F(\"viewdd\") SPACE(2 2) CYLINDER\"\n  x = Msg(x)\n  Signal Off Error\n  Push View_header\n  \"EXECIO 1 DISKW\" viewdd\n  \"EXECIO * DISKW\" viewdd \"(STEM XSTRING. FINIS\"\n  Address ISPEXEC\n  \"LMINIT DATAID(VIEWID) DDNAME(\"viewdd\")\"\n  \"VIEW DATAID(\"viewid\")\" /*\"NOMACRO\"*/\n  \"LMFREE DATAID(\"viewid\")\"\n  Address TSO \"FREE FI(\"viewdd\")\"\n  Return true\nError:\n  Return false\n/*-------------------------------------------------------------------*/\nExtract_Parms:\n/******************************************************************\n*  Extracts parameter information.                                *\n*                                                                 *\n*  Available parameters are:                                      *\n*  - DEBUG(trace-options)                                         *\n*  - TABLE(table-name dd-var-name dsn-var-name)                   *\n*  - LIBRARY(library-name)                                        *\n*  - required-dd-name                                             *\n*                                                                 *\n*  These parameters can be supplied in any order and the default  *\n*  values are:                                                    *\n*      trace-options:  'O' (no tracing)                           *\n*         table-name:  TIOT                                       *\n*        dd-var-name:  DDNAME                                     *\n*       dsn-var-name:  DSNAME                                     *\n*       library-name:  (blank)                                    *\n*                                                                 *\n*  My thanks go to Roy Gardiner who helped me to make my          *\n*  parameter processing much more simple than I had managed to    *\n*  do on my own.                                                  *\n******************************************************************/\n  Arg Argstring\n  If Pos('TABLE(', argstring) \\= 0 Then\n    Do\n      Parse Var argstring p1 'TABLE(' tbnam tbddn tbdsn ')' p2\n      tb_required = true\n      argstring = p1 || p2\n    End\n  Else\n    tb_required = false\n  If Pos('LIBRARY(', argstring) \\= 0 Then\n    Do\n      lib_required = true\n      Parse Var argstring p1 'LIBRARY(' libnam ')' p2\n    End\n  Else\n    lib_required = false\n  if pos('DEBUG(',argstring) > 0 Then\n    Do\n      debug_required = true\n      Parse Value argstring With p1 'DEBUG(' debug ')' p2\n    End\n  Else\n    debug_required = false\n  If tb_required | debug_required | lib_required Then\n    reqdd  = strip(p1 || p2)\n  Else\n    reqdd = argstring\n  If tb_required Then\n    Do\n      If tbnam = '' Then\n        tbnam  = 'TIOT'\n      If tbddn = '' Then\n        tbddn  = 'DDNAME'\n      If tbdsn = '' Then\n        tbdsn  = 'DSNAME'\n    End\n  If \\debug_required Then\n    debug = 'O'\n  Return\n/*---------------------------------------------------------------------\n: Examples of use of the TIOT exec                                    :\n:                                                                     :\n: 1.  From the command line enter TSO TIOT and you will be presented  :\n:     with a list of all ddnames allocated to your session along with :\n:     the associated dsnames.  Each dsname occupies one line.         :\n:     The display will look something like this:                      :\n:           User: userid - file allocations: all files                :\n:           ISPTLIB  SYS1.SISPTENU                                    :\n:                    SYS1.SISFTLIB                                    :\n:                                                                     :\n:           SYSIN    SYS01004.T130908.RA000.MACKEKM.R0579190          :\n:                                                                     :\n:           ISPMLIB  SYS1.SISPMENU                                    :\n:                    SYS1.SISFMLIB                                    :\n:                    .                                                :\n:                    .                                                :\n:                                                                     :\n: 2.  From the command line enter TSO TIOT ISPPLIB and the result     :\n:     will look something like this:                                  :\n:           User: userid - file allocations: ISPPLIB                  :\n:           ISPPLIB  SYS1.SISPPENU                                    :\n:                    SYS1.SISFPLIB                                    :\n:                                                                     :\n: 3.  From another exec, to find what's allocated to ISPMLIB use      :\n:     something like this:                                            :\n:           x = Tiot('ISPMLIB')                                       :\n:     and the variable x will contain something like this:            :\n:           *ISPMLIB* 'SYS1.SISPMENU' 'SYS1.SISFMLIB'                 :\n:                                                                     :\n: 4.  Or, to use it more intelligently use something like this:       :\n:           ddname = 'ISPPLIB'                                        :\n:           placeholder = '*'ddname'*'                                :\n:           Parse Value Tiot(ddname) With (placeholder) dslist        :\n:     and dslist would contain something like this:                   :\n:           'SYS1.SISPPENU' 'SYS1.SISFPLIB'                           :\n:                                                                     :\n: 5.  To get a full list of all allocations and parse them yourself   :\n:     use:                                                            :\n:           y = Tiot()                                                :\n:     and the variable y will contain something like this:            :\n:           *ISPTLIB*  'SYS1.SISPTENU' 'SYS1.SISFTLIB' *SYSIN*        :\n:           'SYS01004.T130908.RA000.MACKEKM.R0579190' *ISPMLIB*       :\n:           'SYS1.SISPMENU' 'SYS1.SISFMLIB'                           :\n:     as one continuous string which you could then parse with:       :\n:           Parse Var dsnlist . '*ISPMLIB*' my_list '*' .             :\n:     and my_list would contain:                                      :\n:           'SYS1.SISPMENU' 'SYS1.SISFMLIB'                           :\n:                                                                     :\n: 6.  To get a full list of all allocations into a table caled RUBBLE :\n:     with the DDname variable set as BARNEY and the DSname variable  :\n:     set as BETTY use:                                               :\n:           TSO TIOT TABLE(RUBBLE BARNEY BETTY)                       :\n:               - or -                                                :\n:           x = TIOT('TABLE(RUBBLE BARNEY BETTY)')                    :\n:                                                                     :\n: 7.  To get a full list of all allocations into a table using the    :\n:     default names of TIOT, DDNAME and DSNAME use:                   :\n:           TSO TIOT TABLE()                                          :\n:               - or -                                                :\n:           x = TIOT('TABLE()')                                       :\n:                                                                     :\n: 8.  To get a list of files allocated to SYSEXEC into a table called :\n:     WONKA with the default variable names of DDNAME & DSNAME use:   :\n:           TSO TIOT TABLE(WONKA) SYSEXEC                             :\n:               - or -                                                :\n:           TSO TIOT SYSEXEC TABLE(WONKA)                             :\n:               - or -                                                :\n:           x = TIOT('TABLE(WONKA)' 'SYSEXEC')                        :\n:               - or -                                                :\n:           x = TIOT('SYSEXEC' 'TABLE(WONKA)')                        :\n---------------------------------------------------------------------*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TIOT01": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x02\\x1f\\x01\\x01\\x02\\x1f\\x12\\x16\\x01\\x9e\\x01\\x9e\\x00\\x00\\xd4\\xc1\\xc3\\xd2\\xc5\\xd2\\xd4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-01-21T00:00:00", "modifydate": "2001-01-21T12:16:00", "lines": 414, "newlines": 414, "modlines": 0, "user": "MACKEKM"}, "text": "/**REXX****************************************************************\n*  TIOT exec - Ken MacKenzie - May 1998                               *\n*                                                                     *\n*  This exec will display (or return) a list of all datasets          *\n*  allocated to a particular ddname or all datasets allocated to all  *\n*  ddnames.  If the exec is entered as a command, the results are     *\n*  displayed (using \"STEMDISP\" or \"say\" ) or, if the command is       *\n*  invoked from another exec, the results are returned as a string    *\n*  consisting of the ddname enclosed in asterisks followed by a list  *\n*  of dataset names (individually) enclosed in quotes.  Use of this   *\n*  exec is faster and a lot less messy than using a combination of    *\n*  OUTTRAP and the LISTALC ST H command.  If you don't have STEMDISP  *\n*  at your site, you can obtain a copy of Gilbert Saint-Flour's       *\n*  version via the CBT (file 183).                                    *\n*                                                                     *\n*  Additionally, a TABLE parameter can be supplied.  This is in the   *\n*  form TABLE(table-name dd-var-name dsn-var-name).  If this          *\n*  parameter is supplied, the results are written to an ISPF table    *\n*  which can then be used to drive another process.                   *\n*---------------------------------------------------------------------*\n*  Limited support can be obtained from the author:                   *\n*  ken.mackenzie@bigfoot.com                                          *\n*---------------------------------------------------------------------*\n*  Examples of use can be found at the end of the exec                *\n*---------------------------------------------------------------------*\n*  Amendment History (Latest First)                                   *\n*                                                                     *\n*  19 January   2001 - Ken MacKenzie                                  *\n*                    - Changed TABLE processing to NOWRITE            *\n*                    - Added \"Address TSO\" to VIEWSTEM procedure      *\n*                                                                     *\n*  09 January   2001 - Ken MacKenzie                                  *\n*                    - Added TABLE processing                         *\n*                    - Changed the parameter handling                 *\n*                      (/DEBUG has changed to DEBUG(opt))             *\n*                      and the TABLE() parameter can now be used      *\n*                                                                     *\n*  08 January   2001 - Ken MacKenzie                                  *\n*                    - Simplify detection of the '/DEBUG'             *\n*                      parameter                                      *\n*                    - Use an internal routine to VIEW the            *\n*                      output if STEMDISP isn't available             *\n*                                                                     *\n*  04 January   2001 - Ken MacKenzie                                  *\n*                    - Updated the comments                           *\n*                    - Added a call to STEMDISP                       *\n*                    - SWAREQ coding brought in-line                  *\n*                    - Added Examples of Use                          *\n*                    - Use Numeric Digits 10 to allow for             *\n*                      addresses greater than 3B9AC9FF                *\n*                    - allow a '/DEBUG' parameter to be               *\n*                      supplied                                       *\n*                                                                     *\n*  15 December  2000 - Ken MacKenzie                                  *\n*                    - Turn off tracing                               *\n*                                                                     *\n*  20 May       1998 - Ken MacKenzie                                  *\n*                    - Initial coding                                 *\n**********************************************************************/\n\n/**********************************************************************\n*  Parm handling has been moved to a called routine: Extract_Parms    *\n**********************************************************************/\n  trace_setting = Trace('O')\n  true = 1; false = 0\n  Call Extract_Parms Arg(1)\n  trace_setting = Trace(debug)         /*Set debugging option       */\n  Numeric Digits 10                    /*Allow for big addresses    */\n  Parse Source . calltype .            /*Determine if we were called*/\n  If calltype = 'FUNCTION',            /*as a subroutine and set a  */\n   | calltype = 'SUBROUTINE' Then      /*variable as appropriate    */\n    subroutine = true\n  Else\n    subroutine = false\n\n  If tb_required Then\n    Do\n      Address ISPEXEC\n      \"TBCREATE\" tbnam \"NAMES(\" tbddn tbdsn \") REPLACE\"\n    End\n  tcb = C2d(Storage('21c', 4))         /*Address the TCB            */\n  tcb = tcb + 12\n  tcb = d2x(tcb)\n  tiot = c2d(Storage(tcb, 4))          /*Address the TIOT           */\n  tiot = tiot + 24                     /*Address the first DD entry */\n  xlen = 0                             /*bypassing jobname/stepnames*/\n\n  If subroutine Then\n    xstring =\n  Else\n    xstring.0 = 0\n  ddfound = false\n/*******************************************************************\n*  Loop through the TIOT looking for DDnames.                      *\n*  The first byte of each entry contains the length of that entry  *\n*  The first bit of the second byte is on if the entry is not in   *\n*  use.                                                            *\n*  Bytes  5-12 contain the DDname.                                 *\n*  Bytes 13-15 contain the SWA address                             *\n*  If there is a requested DD, we use the ddfound flag to control  *\n*  whether we've found the requested DD.  This is because          *\n*  concatenated files have a blank DDname.                         *\n*******************************************************************/\n  Do Forever\n    tiot = tiot + xlen\n    addr = tiot\n    xlen = C2d(Storage(D2x(addr), 1))\n    If xlen = 0 Then\n      Leave\n    If Bitand(Storage(d2x(addr + 1), 1), '80'x) = '80'x Then\n      iterate\n    addr = tiot + 4\n    ddname = Storage(D2x(addr), 8)\n    Select\n      When reqdd = '' Then\n        ddfound = true\n      When ddname = reqdd Then\n        ddfound = true\n      When ddname = '' Then\n        Nop\n      When ddname \\= reqdd Then\n        If ddfound Then\n          Leave\n      Otherwise\n        Nop\n    End\n    If \\ddfound Then\n      iterate\n    If subroutine Then\n      If ddname \\= '' Then\n        xstring = xstring '*'Strip(ddname,'T')'*'\n    addr = tiot + 12\n/*  dsnaddr = d2x(c2d(Storage(d2x(addr),3)) + 16)*/\n    dsnaddr = d2x(swareq(Storage(d2x(addr),3)))\n    dsname = Strip(Storage(dsnaddr, 44), 'T')\n    If subroutine Then\n      xstring = xstring \"'\"dsname\"'\"\n    Else\n      Do\n        xstring.0 = xstring.0 + 1\n        If ddname \\= '' & xstring.0 \\= 1 Then\n          Do\n            x = Value('xstring.'xstring.0, ' ')\n            xstring.0 = xstring.0 + 1\n          End\n        x = Value('xstring.'xstring.0, ddname dsname)\n      End\n    If tb_required Then\n      Do\n        Address ISPEXEC\n        x = Value(tbddn, ddname)\n        x = Value(tbdsn, dsname)\n        \"TBADD\" tbnam\n      End\n  End\n/********************************************************************\n*  If we're running as a subroutine then we simply return a string  *\n********************************************************************/\n  If Subroutine Then\n    Return xstring\n/***********************************************************************\n*  If we're running as a command then we have to display the           *\n*  allocations.                                                        *\n*  If we are running under ISPF, we attempt to use \"STEMDISP\" and, if  *\n*  that fails, we use the internal \"VIEWSTEM\" routine; if that fails,  *\n*  we use \"say\" statements.                                            *\n*  If we are running under native TSO, we just use \"say\" statements.   *\n***********************************************************************/\n  If reqdd = '' Then                   /*Set                         */\n    view_dd = 'all files'              /*    up a                    */\n  Else                                 /*         header             */\n    view_dd = reqdd                    /*                line        */\n  view_header = 'User:' Sysvar(Sysuid) '- file allocations:' view_dd\n  If Sysvar(Sysispf) \\= 'ACTIVE' Then\n    Call Non_Ispf_Display\n  Else\n    Do\n      Signal On Syntax                 /*In case STEMDISP fails      */\n      Call 'STEMDISP'  'VIEW', 'XSTRING.',,, view_header\n      Signal Off Syntax\n    End\n  Return 0\nSyntax:\n/*****************************************************************\n*  We come here in the event of a SYNTAX error.  Basically that  *\n*  means that the call to STEMDISP failed.                       *\n*  So we attempt to use the internal VIEWSTEM.  If that returns  *\n*  \"true\" it worked and we exit; otherwise we continue just      *\n*  with \"say\" statements.                                        *\n*****************************************************************/\n    Address ISPEXEC \"CONTROL DISPLAY LINE START(1)\"\n    If Viewstem() Then\n      Return\nNon_Ispf_Display:\n/*****************************************************************\n*  We come here either by dropping through from the SYNTAX error *\n*  routine (above) or when we are running in native TSO          *\n*****************************************************************/\n  Say view_header\n  Do i = 1 To xstring.0\n    Say xstring.i\n  End\n  Return 0\n/***************************************************************\n *  The following routine was provided by Gilbert Saint-Flour  *\n *  I have included it as an internal function because it is   *\n *  easier to package that way.                                *\n ***************************************************************/\n/*--------------------------------------------------------------------*\\\n\u00a6*                                                                    *\u00a6\n\u00a6* MODULE NAME = SWAREQ                                               *\u00a6\n\u00a6*                                                                    *\u00a6\n\u00a6* DESCRIPTIVE NAME = Convert an SVA to a 31-bit address              *\u00a6\n\u00a6*                                                                    *\u00a6\n\u00a6* STATUS = R200                                                      *\u00a6\n\u00a6*                                                                    *\u00a6\n\u00a6* FUNCTION = The SWAREQ function simulates the SWAREQ macro to       *\u00a6\n\u00a6*            convert an SWA Virtual Address (SVA) to a full 31-bit   *\u00a6\n\u00a6*            address which can be used to access SWA control blocks  *\u00a6\n\u00a6*            in the SWA=ABOVE environment.  The input is a 3-byte    *\u00a6\n\u00a6*            SVA; the output value is a 10-digit decimal number.     *\u00a6\n\u00a6*                                                                    *\u00a6\n\u00a6* AUTHOR   =  Gilbert Saint-flour <gsf@ibm.net>                      *\u00a6\n\u00a6*                                                                    *\u00a6\n\u00a6* DEPENDENCIES = TSO/E V2                                            *\u00a6\n\u00a6*                                                                    *\u00a6\n\u00a6* SYNTAX   =  SWAREQ(sva)                                            *\u00a6\n\u00a6*                                                                    *\u00a6\n\u00a6*             sva must contain a 3-byte SVA.                         *\u00a6\n\u00a6*                                                                    *\u00a6\n\u00a6* Sample Invocation:                                                 *\u00a6\n\u00a6*                                                                    *\u00a6\n\u00a6*    NUMERIC DIGITS 10                                               *\u00a6\n\u00a6*    tcb = C2D(STORAGE(21C,4))         /* TCB          PSATOLD  */   *\u00a6\n\u00a6*    tiot= C2D(STORAGE(D2X(tcb+12),4)) /* TIOT         TCBTIO   */   *\u00a6\n\u00a6*    sva = STORAGE(D2X(tiot+36),3)     /* First JFCB   TIOEJFCB */   *\u00a6\n\u00a6*    jfcb=SWAREQ(sva)             /* convert SVA to 31-bit addr */   *\u00a6\n\u00a6*    dsn=STORAGE(D2X(jfcb),44)         /* dsname       JFCBDSNM */   *\u00a6\n\u00a6*    vol=STORAGE(D2X(jfcb+118),6)      /* volser       JFCBVOLS */   *\u00a6\n\u00a6*    SAY 'sva='C2X(sva) 'jfcb='D2X(jfcb) 'dsn='dsn 'vol='vol         *\u00a6\n\u00a6*                                                                    *\u00a6\n\\*--------------------------------------------------------------------*/\nSWAREQ: PROCEDURE\n  IF RIGHT(C2X(ARG(1)),1) \\= 'F' THEN       /* SWA=BELOW ?          */\n    RETURN C2D(ARG(1))+16                   /* yes, return sva+16   */\n  NUMERIC DIGITS 10                         /* allow up to 7FFFFFFF */\n  sva=C2D(ARG(1))                           /* convert to decimal   */\n  tcb = C2D(STORAGE(21C,4))                 /* TCB         PSATOLD  */\n  jscb = C2D(STORAGE(D2X(tcb+180),4))       /* JSCB        TCBJSCB  */\n  qmpl = C2D(STORAGE(D2X(jscb+244),4))      /* QMPL        JSCBQMPI */\n  qmat = C2D(STORAGE(D2X(qmpl+24),4))       /* QMAT        QMADD    */\n    DO WHILE sva>65536\n      qmat = C2D(STORAGE(D2X(qmat+12),4)) /* next QMAT     QMAT+12  */\n      sva=sva-65536                         /* 010006F -> 000006F   */\n    END\n  RETURN C2D(STORAGE(D2X(qmat+sva+1),4))+16\n/*-------------------------------------------------------------------*/\nViewstem:\nProcedure Expose xstring. view_header\n/********************************************************************\n*  This routine attempts to allocate a temporary file whose DDname  *\n*  is based around the current time (in an effort to be unique).    *\n*  The view header and all xstring. variables are then written to   *\n*  the file and the file is then passed to ISPF view.               *\n*  If everything appeared to work OK, we return TRUE otherwise we   *\n*  return FALSE.                                                    *\n********************************************************************/\n  Parse Value Time('L') With hh ':' mm ':' ss '.' ths\n  true = 1; false = 0\n  p = substr('ABCDEFGHIJKLMNOPQRSTUVWXY',hh+1,1)\n  viewdd = Left(p || mm || ss || ths, 8)\n\n  Address TSO\n  Signal On Error\n  x = Msg('OFF')\n  \"ALLOC F(\"viewdd\") SPACE(2 2) CYLINDER\"\n  x = Msg(x)\n  Signal Off Error\n  Push View_header\n  \"EXECIO 1 DISKW\" viewdd\n  \"EXECIO * DISKW\" viewdd \"(STEM XSTRING. FINIS\"\n  Address ISPEXEC\n  \"LMINIT DATAID(VIEWID) DDNAME(\"viewdd\")\"\n  \"VIEW DATAID(\"viewid\")\"\n  \"LMFREE DATAID(\"viewid\")\"\n  Address TSO \"FREE FI(\"viewdd\")\"\n  Return true\nError:\n  Return false\n/*-------------------------------------------------------------------*/\nExtract_Parms:\n/******************************************************************\n*  Extracts parameter information.                                *\n*                                                                 *\n*  Available parameters are:                                      *\n*  - DEBUG(trace-options)                                         *\n*  - TABLE(table-name dd-var-name dsn-var-name)                   *\n*  - required-dd-name                                             *\n*                                                                 *\n*  These parameters can be supplied in any order and the default  *\n*  values are:                                                    *\n*      trace-options:  'O' (no tracing)                           *\n*         table-name:  TIOT                                       *\n*        dd-var-name:  DDNAME                                     *\n*       dsn-var-name:  DSNAME                                     *\n*                                                                 *\n*  My thanks go to Roy Gardiner who helped me to make my          *\n*  parameter processing much more simple than I had managed to    *\n*  do on my own.                                                  *\n******************************************************************/\n  Arg Argstring\n  If Pos('TABLE(', argstring) \\= 0 Then\n    Do\n      Parse Var argstring p1 'TABLE(' tbnam tbddn tbdsn ')' p2\n      tb_required = true\n      argstring = p1 || p2\n    End\n  Else\n    tb_required = false\n  if pos('DEBUG(',argstring) > 0 Then\n    Do\n      debug_required = true\n      Parse Value argstring With p1 'DEBUG(' debug ')' p2\n    End\n  Else\n    debug_required = false\n  If tb_required | debug_required Then\n    reqdd  = strip(p1 || p2)\n  Else\n    reqdd = argstring\n  If tb_required Then\n    Do\n      If tbnam = '' Then\n        tbnam  = 'TIOT'\n      If tbddn = '' Then\n        tbddn  = 'DDNAME'\n      If tbdsn = '' Then\n        tbdsn  = 'DSNAME'\n    End\n  If \\debug_required Then\n    debug = 'O'\n  Return\n/*---------------------------------------------------------------------\n: Examples of use of the TIOT exec                                    :\n:                                                                     :\n: 1.  From the command line enter TSO TIOT and you will be presented  :\n:     with a list of all ddnames allocated to your session along with :\n:     the associated dsnames.  Each dsname occupies one line.         :\n:     The display will look something like this:                      :\n:           User: userid - file allocations: all files                :\n:           ISPTLIB  SYS1.SISPTENU                                    :\n:                    SYS1.SISFTLIB                                    :\n:                                                                     :\n:           SYSIN    SYS01004.T130908.RA000.MACKEKM.R0579190          :\n:                                                                     :\n:           ISPMLIB  SYS1.SISPMENU                                    :\n:                    SYS1.SISFMLIB                                    :\n:                    .                                                :\n:                    .                                                :\n:                                                                     :\n: 2.  From the command line enter TSO TIOT ISPPLIB and the result     :\n:     will look something like this:                                  :\n:           User: userid - file allocations: ISPPLIB                  :\n:           ISPPLIB  SYS1.SISPPENU                                    :\n:                    SYS1.SISFPLIB                                    :\n:                                                                     :\n: 3.  From another exec, to find what's allocated to ISPMLIB use      :\n:     something like this:                                            :\n:           x = Tiot('ISPMLIB')                                       :\n:     and the variable x will contain something like this:            :\n:           *ISPMLIB* 'SYS1.SISPMENU' 'SYS1.SISFMLIB'                 :\n:                                                                     :\n: 4.  Or, to use it more intelligently use something like this:       :\n:           ddname = 'ISPPLIB'                                        :\n:           placeholder = '*'ddname'*'                                :\n:           Parse Value Tiot(ddname) With (placeholder) dslist        :\n:     and dslist would contain something like this:                   :\n:           'SYS1.SISPPENU' 'SYS1.SISFPLIB'                           :\n:                                                                     :\n: 5.  To get a full list of all allocations and parse them yourself   :\n:     use:                                                            :\n:           y = Tiot()                                                :\n:     and the variable y will contain something like this:            :\n:           *ISPTLIB*  'SYS1.SISPTENU' 'SYS1.SISFTLIB' *SYSIN*        :\n:           'SYS01004.T130908.RA000.MACKEKM.R0579190' *ISPMLIB*       :\n:           'SYS1.SISPMENU' 'SYS1.SISFMLIB'                           :\n:     as one continuous string which you could then parse with:       :\n:           Parse Var dsnlist . '*ISPMLIB*' my_list '*' .             :\n:     and my_list would contain:                                      :\n:           'SYS1.SISPMENU' 'SYS1.SISFMLIB'                           :\n:                                                                     :\n: 6.  To get a full list of all allocations into a table caled RUBBLE :\n:     with the DDname variable set as BARNEY and the DSname variable  :\n:     set as BETTY use:                                               :\n:           TSO TIOT TABLE(RUBBLE BARNEY BETTY)                       :\n:               - or -                                                :\n:           x = TIOT('TABLE(RUBBLE BARNEY BETTY)')                    :\n:                                                                     :\n: 7.  To get a full list of all allocations into a table using the    :\n:     default names of TIOT, DDNAME and DSNAME use:                   :\n:           TSO TIOT TABLE()                                          :\n:               - or -                                                :\n:           x = TIOT('TABLE()')                                       :\n:                                                                     :\n: 8.  To get a list of files allocated to SYSEXEC into a table called :\n:     WONKA with the default variable names of DDNAME & DSNAME use:   :\n:           TSO TIOT TABLE(WONKA) SYSEXEC                             :\n:               - or -                                                :\n:           TSO TIOT SYSEXEC TABLE(WONKA)                             :\n:               - or -                                                :\n:           x = TIOT('TABLE(WONKA)' 'SYSEXEC')                        :\n:               - or -                                                :\n:           x = TIOT('SYSEXEC' 'TABLE(WONKA)')                        :\n---------------------------------------------------------------------*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT496/FILE496.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT496", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}