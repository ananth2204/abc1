{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011241000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 1293292, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 8, "INMDSNAM": "CBT.V500.FILE108.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 1293292, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 1293292, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE108.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x15\\x04'", "DS1TRBAL": "b'\\x98\\x9a'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x00\\xb5\\x00\\t\\x00\\xb7\\x00\\x00\\x00\\x16'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"@FILE108": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x99\\x08?\\x01\\x00\"o\\x15U\\x00/\\x00\\x05\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1999-03-24T00:00:00", "modifydate": "2000-08-13T15:55:00", "lines": 47, "newlines": 5, "modlines": 0, "user": "WSBG"}, "text": "//***FILE 108 is the Clemson University Structured Macro SAMPLIB    *   FILE 108\n//*           from Mr James C Blalock.  This file contains the      *   FILE 108\n//*           SAMPLIB for the Macro System contained in File 107    *   FILE 108\n//*           of this tape.                                         *   FILE 108\n//*                                                                 *   FILE 108\n//*           See documentation for this package in the doc for     *   FILE 108\n//*           File 107.  The contents of this package was           *   FILE 108\n//*           downloaded from the author's home page at:            *   FILE 108\n//*                                                                 *   FILE 108\n//*           http://people.clemson.edu/~carey                      *   FILE 108\n//*                                                                 *   FILE 108\n//*           email:   carey@clemson.edu                            *   FILE 108\n//*                                                                 *   FILE 108\n//*   -----------------------------------------------------------   *   FILE 108\n//*                                                                 *   FILE 108\n//*    Clemson University Structured Macros SAMPLIB Contents        *   FILE 108\n//*                                                                 *   FILE 108\n//*     JCL Procedures:                                             *   FILE 108\n//*                                                                 *   FILE 108\n//*       ASMP     - Run structured listing pgm only                *   FILE 108\n//*       ASMPC    - Run list pgm, Assembler H                      *   FILE 108\n//*       ASMPCL   - Run list pgm, Assembler H, linkedit            *   FILE 108\n//*       ASMPCLG  - Run list pgm, Assembler H, linkedit,           *   FILE 108\n//*                  execute user pgm                               *   FILE 108\n//*                                                                 *   FILE 108\n//*     Sample Programs:                                            *   FILE 108\n//*                                                                 *   FILE 108\n//*       BAR      - ISPF edit macro: puts ' | ' in col 38-40       *   FILE 108\n//*                  of source code                                 *   FILE 108\n//*       CC       - ISPF edit macro: puts '*' in column 72         *   FILE 108\n//*       FLIP     - ISPF edit macro: swaps excluded,               *   FILE 108\n//*                  nonexcluded lines                              *   FILE 108\n//*       MASKDATA - ISPF edit macro: applies maskline to           *   FILE 108\n//*                  existing source code                           *   FILE 108\n//*       MSC0150$ - Structured listing pgm.  Example of            *   FILE 108\n//*                  reentrant code.  Used in ASMPxxx procs.        *   FILE 108\n//*       STGMAP   - Prints addresses of MVS/XA storage areas       *   FILE 108\n//*                  (ECSA, LPA, etc).  Example of AMODE            *   FILE 108\n//*                  switching.  Writes to //SYSPRINT.              *   FILE 108\n//*                                                                 *   FILE 108\n//*     Other Tools:                                                *   FILE 108\n//*                                                                 *   FILE 108\n//*       CMTCLIST - ISPF edit macro (in CLIST) which will          *   FILE 108\n//*                  insert various types of comment 'blocks'       *   FILE 108\n//*                  for different block structures.  Refer to      *   FILE 108\n//*                  the member for details.                        *   FILE 108\n//*                                                                 *   FILE 108\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ASMP": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98$\\x0f\\x00\\x98$\\x0f\\x13\\x19\\x00\\x07\\x00\\x07\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-08-28T00:00:00", "modifydate": "1998-08-28T13:19:00", "lines": 7, "newlines": 7, "modlines": 0, "user": "CLEMSON"}, "text": "//ASMP  PROC  SYSOUT=A\n//*   THIS IS AN PROC USED INTERNALLY BY THE SYSTEMS GROUP.\n//*   ADDED - 7/29/83      MGG\n//P       EXEC PGM=MSC0150$\n//SYSPRINT DD  SYSOUT=&SYSOUT,DCB=BLKSIZE=141\n//SYSPUNCH DD  SPACE=(CYL,(1,1)),UNIT=DISK,DCB=BLKSIZE=3120,\n//             DSN=&&SRC,DISP=(,PASS)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ASMPC": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98$\\x0f\\x00\\x98$\\x0f\\x13\\x19\\x00\\x15\\x00\\x15\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-08-28T00:00:00", "modifydate": "1998-08-28T13:19:00", "lines": 21, "newlines": 21, "modlines": 0, "user": "CLEMSON"}, "text": "//ASMPC   PROC  OBJECT=DUMMY,COPT=,SYSOUT=A,MAC=SYS2\n//*   THE ASMPC PROC USES THE CLEMSON STRUCTURED PROGRAMMING MACROS.\n//*   ADDED       -- 7/29/83  MGG\n//*   MADE PUBLIC -- 10/15/84 JCB\n//*   ADDED MAC KEYWORD -- 7/15/85 MGG\n//P       EXEC PGM=MSC0150$\n//SYSPRINT DD  SYSOUT=A,DCB=BLKSIZE=141\n//SYSPUNCH DD  SPACE=(CYL,(1,1)),UNIT=DISK,DCB=BLKSIZE=3120,\n//             DSN=&&SRC,DISP=(,PASS)\n//C       EXEC PGM=IEV90,\n//             PARM='OBJECT,XREF(SHORT),TERM&COPT',\n//             COND=(5,LT)\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=(SHR,PASS)\n//         DD  DSN=&MAC..STRUC.MACLIB,DISP=(SHR,PASS)\n//SYSPRINT DD  SYSOUT=&SYSOUT,DCB=BLKSIZE=121\n//SYSTERM  DD  SYSOUT=&SYSOUT\n//SYSUT1   DD  UNIT=DISK,SPACE=(CYL,(5,5)),DSN=&&UT1\n//SYSLIN   DD  UNIT=SYSDA,SPACE=(CYL,(1,1)),DISP=(MOD,PASS),DSN=&&OBJ,\n//             DCB=(LRECL=80,RECFM=FB,BLKSIZE=400)\n//SYSIN    DD  DSN=&&SRC,DISP=(OLD,DELETE)\n//SYSPUNCH DD  &OBJECT,DCB=BLKSIZE=80\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ASMPCL": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98$\\x0f\\x00\\x98$\\x0f\\x13\\x19\\x00\\x1b\\x00\\x1b\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-08-28T00:00:00", "modifydate": "1998-08-28T13:19:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "CLEMSON"}, "text": "//ASMPCL  PROC  OBJECT=DUMMY,COPT=,LOPT=,PDS=,NAME=,SYSOUT=A,MAC=SYS2\n//*   THIS PROC USES THE CLEMSON STRUCTURED PROGRAMMING MACROS.\n//*   ADDED       -- 7/29/83 MGG\n//*   MADE PUBLIC -- 10/5/84 JCB\n//*   ADDED MAC KEYWORD -- 7/15/85 MGG\n//P       EXEC PGM=MSC0150$\n//SYSPRINT DD  SYSOUT=A,DCB=BLKSIZE=141\n//SYSPUNCH DD  SPACE=(CYL,(1,1)),UNIT=DISK,DCB=BLKSIZE=3120,\n//             DSN=&&SRC,DISP=(,PASS)\n//C       EXEC PGM=IEV90,\n//             PARM='OBJECT,XREF(SHORT),TERM&COPT',\n//             COND=(5,LT)\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=(SHR,PASS)\n//         DD  DSN=&MAC..STRUC.MACLIB,DISP=(SHR,PASS)\n//SYSPRINT DD  SYSOUT=&SYSOUT,DCB=BLKSIZE=121\n//SYSTERM  DD  SYSOUT=&SYSOUT\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(CYL,(5,5)),DSN=&&UT1\n//SYSLIN   DD  UNIT=SYSDA,SPACE=(CYL,(1,1)),DISP=(MOD,PASS),DSN=&&OBJ,\n//             DCB=(LRECL=80,RECFM=FB,BLKSIZE=3200)\n//SYSIN    DD  DSN=&&SRC,DISP=(OLD,DELETE)\n//SYSPUNCH DD  &OBJECT,DCB=BLKSIZE=80\n//L       EXEC PGM=IEWL,COND=(5,LT),PARM='LIST,MAP&LOPT'\n//SYSPRINT DD  SYSOUT=&SYSOUT\n//SYSUT1   DD  UNIT=VIO,SPACE=(CYL,(1,1)),DSN=&&UT1\n//SYSLIN   DD  DSN=&&OBJ,DISP=(OLD,DELETE),UNIT=SYSDA\n//         DD  DDNAME=SYSIN\n//SYSLMOD  DD  DSN=&PDS.(&NAME),DISP=SHR\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ASMPCLG": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98$\\x0f\\x00\\x98$\\x0f\\x13\\x19\\x00!\\x00!\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-08-28T00:00:00", "modifydate": "1998-08-28T13:19:00", "lines": 33, "newlines": 33, "modlines": 0, "user": "CLEMSON"}, "text": "//ASMPCLG PROC OBJECT=DUMMY,PUNCH=DUMMY,COPT=,LOPT=,SYSOUT=A,MAC=SYS2\n//*   THE ASMPCLG PROC USES THE CLEMSON STRUCTURED PROGRAMMING MACROS.\n//*   ADDED       -- 2/4/85  MGG\n//*   ADDED MAC KEYWORD -- 7/15/85\n//P       EXEC PGM=MSC0150$\n//SYSPRINT DD  SYSOUT=A,DCB=BLKSIZE=141\n//SYSPUNCH DD  SPACE=(CYL,(1,1)),UNIT=DISK,DCB=BLKSIZE=3120,\n//             DSN=&&SRC,DISP=(,PASS)\n//C      EXEC  PGM=IEV90,\n//             PARM='OBJECT,XREF(SHORT),TERM&COPT',\n//             COND=(5,LT)\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=(SHR,PASS)\n//         DD  DSN=&MAC..STRUC.MACLIB,DISP=(SHR,PASS)\n//SYSPRINT DD  SYSOUT=&SYSOUT,DCB=BLKSIZE=121\n//SYSTERM  DD  SYSOUT=&SYSOUT\n//SYSLIN   DD  UNIT=SYSDA,SPACE=(CYL,(1,1)),DISP=(MOD,PASS),DSN=&&OBJ,\n//             DCB=(LRECL=80,RECFM=FB,BLKSIZE=400)\n//SYSIN    DD  DSN=&&SRC,DISP=(OLD,DELETE)\n//SYSPUNCH DD  &OBJECT,DCB=BLKSIZE=80\n//SYSUT1   DD  UNIT=DISK,SPACE=(CYL,(3,2)),DSN=&&UT1\n//L      EXEC  PGM=IEWL,COND=(5,LT,C),PARM='LIST,MAP&LOPT'\n//SYSUT1 DD    UNIT=VIO,SPACE=(CYL,(1,1)),DSN=&&UT1\n//SYSPRINT DD SYSOUT=&SYSOUT\n//SYSLIN   DD  DSN=&&OBJ,DISP=(OLD,DELETE),UNIT=SYSDA\n//         DD  DDNAME=SYSIN\n//SYSLMOD  DD  DSN=&&PDS(MAIN),DISP=(,PASS),UNIT=SYSDA,\n//    SPACE=(CYL,(1,1,1),RLSE)\n//G      EXEC  PGM=MAIN,COND=((5,LT,C),(5,LT,L)),TIME=1400\n//STEPLIB DD DSN=&&PDS,DISP=(OLD,DELETE)\n//SYSPRINT DD  SYSOUT=&SYSOUT,DCB=(LRECL=133,RECFM=FA,BLKSIZE=133)\n//SYSPUNCH DD  &PUNCH,DCB=BLKSIZE=80\n//SYSOUT DD SYSOUT=&SYSOUT\n//SYSUDUMP DD SYSOUT=&SYSOUT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "BAR": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98$\\x0f\\x00\\x98$\\x0f\\x13\\x19\\x00\\xfc\\x00\\xfc\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-08-28T00:00:00", "modifydate": "1998-08-28T13:19:00", "lines": 252, "newlines": 252, "modlines": 0, "user": "CLEMSON"}, "text": "//BARMACRO JOB ,'BAR Macro',\n//  TIME=(,3),REGION=1M\n/*JOBPARM Q=H\n//BAR EXEC    ASMPCL,PDS='....................',NAME=BAR\n//P.SYSIN  DD  *\nBAR      TITLE 'Comment Bar Edit Program Macro'\n         SMLIST CONVERT=YES\n*---------------------------------------------------------------------*\n*\n*  COPYRIGHT (C) 1986 CLEMSON UNIVERSITY\n*\n*  PROGRAM     BAR\n*\n*  ABSTRACT    This is the 'BAR' macro, which will add standard\n*              Assembler comment bars to column 39 of the data lines\n*              specified by 'OO' line commands.  Also, the operands 'X'\n*              or 'NX' on the command line will cause 'BAR' to process\n*              only the excluded ('X') or nonexcluded ('NX') lines.\n*              'BAR' will not insert its '|' for lines that begin with\n*              a '*', '.*', '/', '++*' or lines where columns 38-40 are\n*              not blank.\n*\n*  INPUTS:\n*      PARAMETERS  None\n*      FILES       None\n*      OTHER       Variables from ISPF/PDF Edit (See code)\n*\n*  OUTPUTS:\n*      MESSAGES\n*        Enter \"O\" line cmd\n*           . \"BAR\" requires an \"O\" cmd to indicate line(s) to be\n*             processed\n*        Invalid BAR option\n*           . On command line, use \"X\" for excluded lines or \"NX\" for\n*             nonexcluded lines.\n*        BAR command incomplete\n*           . Use \"O\" line command to specify lines to be processed by\n*             BAR.\n*      FILES       None\n*      OTHER       Modifies lines in dataset currently under edit\n*\n*  PROGRAM     NONREENTRANT, PROBLEM KEY AND STATE, STANDARD LINKAGE,\n*  ATTRIBUTES  NON-AUTHORIZED, AMODE(31), RMODE(ANY)\n*\n*  SPECIAL\n*  NOTES       None\n*\n*  CHANGE\n*  HISTORY     07/19/88 PLH - New\n*              01/11/89 PLH - Cleaned up\n*\n*  METHOD OF\n*  OPERATION   See code\n*\n*\n*---------------------------------------------------------------------*\n         eject\n block   name=bar,type=program,options=(*norent,xa,mode),              *\n               amode=31,rmode=any,pl=(parmlist,6)\n         space 1\n  load   ep=isplink                   | Get ISPLINK.\n  st     r0,isplink                   |\n* *-------------------------------------------------------------------*\n* *  Issue VDEFINEs for the following variables:\n* *    XNXPARM - Parameter 'X' or 'NX' from command line\n* *    XNX     - Exclude status of current line\n* *    LRECL   - LRECL of current dataset.\n* *    LINE    - Data line currently being processed\n* *    LINE1   - Starting line of range entered by user. Also used\n* *              as pointer to current line.\n* *    LINE2   - Ending line of range entered by user.\n* *-------------------------------------------------------------------*\n  callx  isplink,('vdefine','(xnxparm)',xnxparm,'char',2)\n  callx  isplink,('isredit',0,'\u00a2 macro (xnxparm) noprocess \u00a2')\n  callx  isplink,('vdefine','(xnx)',xnx,'char',2)\n  callx  isplink,('vdefine','(line1)',line1,'fixed',4)\n  callx  isplink,('vdefine','(line2)',line2,'fixed',4)\n  callx  isplink,('vdefine','(lrecl)',lrecl,'fixed',4)\n  callx  isplink,('isredit',0,'\u00a2 (lrecl) = lrecl \u00a2')\n  callx  isplink,('vdefine','(line)',line,'char',lrecl)\n         space 1\n* *-------------------------------------------------------------------*\n* *  Use ISREDIT service to extract range of lines specified by user.\n* *-------------------------------------------------------------------*\n  callx  isplink,('isredit',0,'\u00a2 process range o $ \u00a2')\n  errexit name=block_incomplete,(ch,r15,eq,=h'16')\n  errexit name=process_error,(treg,r15,nz)\n  callx  isplink,('isredit',0,'\u00a2 (line1) = linenum .zfrange \u00a2')\n  callx  isplink,('isredit',0,'\u00a2 (line2) = linenum .zlrange \u00a2')\n* *-------------------------------------------------------------------*\n* *  Determine if user requested processing of excluded or non-\n* *  excluded lines. Note that &XNXPARM is not converted to uppercase\n* *  by ISREDIT.\n* *-------------------------------------------------------------------*\n  oc     xnxparm,=c'  '               | Convert &XNXPARM to uppercase\n  if     (clc,xnxparm,eq,=c'x ')      | Excluded lines only?\n   sbit  stcf1x                       |  Set flag for later.\n  elseif (clc,xnxparm,eq,=c'nx')      | Nonexcluded lines only?\n   sbit  stcf1nx                      |  Set flag for later.\n  elseif (clc,xnxparm,ne,=c'  ')      | Something else?\n   errexit name=invalid_xnxparm       |  Issue error message.\n  endif                               | Endif. (X or NX specified)\n         space 3\n* *-------------------------------------------------------------------*\n* *  Loop thru the lines specified, rotating the lines as required.\n* *  If \"X\" or \"NX\" was requested, query the exclude status of each\n* *  line as it goes by: otherwise, don't bother.\n* *-------------------------------------------------------------------*\n  l      r5,line1                     | Get starting line\n  loop   while,(c,r5,le,line2)        | Do for all lines requested\n   callx isplink,('isredit',0,'\u00a2 (line) = line &&line1 \u00a2')\n*                                     |  Get the data line\n         space 2\n*  *------------------------------------------------------------------*\n*  * Ignore lines we don't want to process.\n*  *------------------------------------------------------------------*\n   if    ((clc,line+37(3),eq,=c'   '),and, If bar area blank, and      *\n               (cli,line,ne,c'*'),and,       not assembler comment, and*\n               (cli,line,ne,c'/'),and,       not JCL statement, and    *\n               (clc,line(2),ne,=c'.*'),and,  not Macro comment, and,   *\n               (clc,line(3),ne,=c'++*'))     not Xsub statement, then\n    if   not,(tbit,(stcf1x+stcf1nx),off)   If X or NX requested\n     callx isplink,('isredit',0,'\u00a2 (xnx) = xstatus &&line1 \u00a2')\n    endif                             |  Get exclude status.\n          space 2\n    if   (tbit,stcf1x+stcf1nx,off),or,   If exclude status OK,         *\n               ((tbit,stcf1x,on),and,(clc,xnx,eq,=c'x ')),or,          *\n               ((tbit,stcf1nx,on),and,(clc,xnx,eq,=c'nx'))\n     mvi line+38,c'|'                 |   Insert bar.\n     callx isplink,('isredit',0,'\u00a2 line &&line1 = (line) \u00a2')\n     l   r1,count                     |   Update line counter.\n     la  r1,1(r1)                     |     and save back\n     st  r1,count                     |       for next loop.\n    endif                             |  Endif. (Exclude status OK)\n   endif                              | Endif. (OK data line)\n   la    r5,1(r5)                     | Increment 'line number'\n   st    r5,line1                     | Save where ISREDIT can get it\n  endloop while                       | Loop thru all lines.\n         space 1\n  callsub display_count               | Display # of lines processed.\n         space 1\n endblk  block=bar,rc=0\n         eject\n*---------------------------------------------------------------------*\n*  Subroutine: Display_Count\n*  Abstract:   Display an ISPF short msg/long msg telling the user\n*              how many lines were rotated.\n*---------------------------------------------------------------------*\n         SPACE 1\n block   name=display_count,type=subroutine,save=(r14,stcr14),         *\n               pl=(parmlist,6)\n         space 1\n  l      r1,count\n  cvd    r1,stcd\n  ed     cntsmsg+dspcsm(l'dspcsm),stcd+5\n  ed     cntlmsg+dspclm(l'dspclm),stcd+5\n  callx  isplink,('vdefine','(zedsmsg)',cntsmsg,'char',=a(l'cntsmsg))\n  callx  isplink,('vdefine','(zedlmsg)',cntlmsg,'char',=a(l'cntlmsg))\n  callx  isplink,('setmsg','isrz001 ')\n         space 1\n endblk  block=display_count,rc=0\n         space 3\n*---------------------------------------------------------------------*\n*  Errexit:    Process_Error\n*  Purpose:    Called when there was an error in processing the user's\n*              line commands.\n*  Called By:  Mainline\n*  Inputs:     None.\n*  Outputs:    Issues error message telling user to use \"O\" line cmd.\n*---------------------------------------------------------------------*\n         SPACE 1\n block   name=process_error,type=errexit,pl=(parmlist,6)\n  callx  isplink,('vdefine','(zedsmsg)',procsmsg,'char',=a(l'procsmsg))\n  callx  isplink,('vdefine','(zedlmsg)',proclmsg,'char',=a(l'proclmsg))\n  callx  isplink,('setmsg','isrz001 ')\n endblk  block=process_error,rc=12\n         space 3\n*---------------------------------------------------------------------*\n*  Errexit:    Invalid_XNXPARM\n*  Purpose:    Called when user specified something other than X or\n*              NX on the command line.\n*  Called By:  Mainline\n*  Inputs:     None.\n*  Outputs:    Issues error message telling user to use \"X\" or \"NX\"\n*              on command line.\n*---------------------------------------------------------------------*\n         space 1\n block   name=invalid_xnxparm,type=errexit,pl=(parmlist,6)\n  callx  isplink,('vdefine','(zedsmsg)',xnxsmsg,'char',=a(l'xnxsmsg))\n  callx  isplink,('vdefine','(zedlmsg)',xnxlmsg,'char',=a(l'xnxlmsg))\n  callx  isplink,('setmsg','isrz001 ')\n endblk  block=invalid_xnxparm,rc=12\n         space 3\n*---------------------------------------------------------------------*\n*  Errexit:    Block_Incomplete\n*  Purpose:    Called when PROCESS says the user didn't specify the\n*              whole block command.\n*  Called By:  Mainline\n*  Inputs:     None.\n*  Outputs:    Issues error message telling user to use \"O\" block cmd.\n*---------------------------------------------------------------------*\n         space 1\n block   name=block_incomplete,type=errexit,pl=(parmlist,6)\n  callx  isplink,('vdefine','(zedsmsg)',blkismsg,'char',=a(l'blkismsg))\n  callx  isplink,('vdefine','(zedlmsg)',blkilmsg,'char',=a(l'blkilmsg))\n  callx  isplink,('setmsg','isrz001 ')\n endblk  block=block_incomplete,rc=12\n         space 1\n*---------------------------------------------------------------------*\n*  Storage area.  (Non-reentrant.)\n*---------------------------------------------------------------------*\n         psd\nstc      ds    d                      |\nstcd     ds    d                      |\nstcr14   ds    f                      |\nisplink  ds    f                      | Address of ISPLINK in LPA\nparmlist ds    6f                     | Place for CALLX parmlists\nxnxparm  dc    cl2' '                 | 'X'/'NX' from BAR command\nxnx      dc    cl2' '                 | Current line exclude status\nstcf1    dc    x'00'                  | Work flags:\nstcf1x   equ   x'80'   |1... ....|    |  \"BAR X\" was specified\nstcf1nx  equ   x'40'   |.1.. ....|    |  \"BAR NX\" was specified\nline     dc    cl255' '               | Current line from file\nline1    dc    f'0'                   | Starting/current line #\nline2    dc    f'0'                   | Last line #\nlrecl    dc    f'0'                   | LRECL of data set.\n         space 1\ncount    dc    f'0'                   |\ncntsmsg  dc    c\"...... lines changed\"\ndspcsm   equ   0,6                    |\n         org   cntsmsg+dspcsm         |\n         dc    x'402020202120'        |\n         org   ,                      |\ncntlmsg  dc    c\"The BAR macro modified...... data lines.\"\ndspclm   equ   22,6                   |\n         org   cntlmsg+dspclm         |\n         dc    x'402020202120'        |\n         org   ,                      |\n*\n         SMLIST CONVERT=NO\nPROCSMSG DC    C'Enter \"O\" line cmd'\nPROCLMSG DC    C'BAR requires an \"O\" command to indicate line(s) to be *\n               processed.'\nXNXSMSG  DC    C'Invalid BAR option'  |\nXNXLMSG  DC    C'On command line, use \"X\" for excluded lines or \"NX\" fo*\n               r nonexcluded lines.'  |\nBLKISMSG DC    C'BAR command incomplete'\nBLKILMSG DC    C'Use \"O\" line commands to specify lines to be processed*\n                by BAR.'\n         SMLIST CONVERT=YES\n         endpsd\n         end\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CC": {"ttr": 531, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98$\\x0f\\x00\\x98$\\x0f\\x13\\x19\\x00\\xb1\\x00\\xb1\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-08-28T00:00:00", "modifydate": "1998-08-28T13:19:00", "lines": 177, "newlines": 177, "modlines": 0, "user": "CLEMSON"}, "text": "//CCMACRO JOB (H2803302,S08,,3),'CC MACRO',\n//  TIME=(,3),REGION=1M\n//CC EXEC ASMPCL,PDS='....................',NAME=CC\n//P.SYSIN  DD  *\nCC       TITLE 'CC -- CC PROGRAM MACRO'\n*---------------------------------------------------------------------*\n*\n*  COPYRIGHT (C) 1986 CLEMSON UNIVERSITY\n*\n*  PROGRAM     CC\n*\n*  ABSTRACT    THIS IS THE 'CC' MACRO, WHICH WILL STICK A '*' IN\n*              COLUMN 72 FOR LINES MARKED BY 'OO' OR '$$'.\n*\n*  INPUTS:\n*      PARAMETERS  NONE\n*      FILES       NONE\n*      OTHER       VARIABLES FROM ISPF/PDF EDIT (SEE CODE)\n*\n*  OUTPUTS:\n*      MESSAGES ENTER \"O\"/\"$\" LINE CMD\n*               INVALID CC OPTION\n*               . ON COMMAND LINE, USE \"X\" FOR EXCLUDED LINES OR\n*                   \"NX\" FOR NONEXCLUDED LINES.\n*               CC COMMAND INCOMPLETE\n*               . USE \"O\" OR \"$\" LINE COMMANDS TO SPECIFY LINES TO\n*                   BE PROCESSED BY CC.\n*      FILES       NONE\n*      OTHER       MODIFIED LINES IN DATASET CURRENTLY UNDER EDIT\n*\n*  PROGRAM     REENTRANT, PROBLEM KEY AND STATE, STANDARD LINKAGE,\n*  ATTRIBUTES  NON-AUTHORIZED, AMODE(24), RMODE(24)\n*\n*  SPECIAL\n*  NOTES       NONE\n*\n*  CHANGE\n*  HISTORY     02/04/87 JCB - NEW\n*              __/__/__ ___\n*              __/__/__ ___\n*\n*  METHOD OF\n*  OPERATION   SEE CODE\n*\n*\n*---------------------------------------------------------------------*\n         EJECT                        |\n BLOCK NAME=CC,TYPE=PROGRAM,OPTIONS=*NORENT,PL=(PARMLIST,6)\n        SPACE 1                       |\n  LOAD  EP=ISPLINK                    |\n  ST    R0,ISPLINK                    |\n* *-------------------------------------------------------------------*\n* *  ISSUE VDEFINES FOR THE FOLLOWING VARIABLES:\n* *    XNXPARM - PARAMETER 'X' OR 'NX' FROM COMMAND LINE\n* *    XNX     - EXCLUDE STATUS OF CURRENT LINE\n* *    CMD     - LINE COMMAND ENTERED (\"O\" OR \"$\")\n* *    LINE    - DATA LINE CURRENTLY BEING PROCESSED\n* *    LINE1   - STARTING LINE OF RANGE ENTERED BY USER. ALSO USED\n* *              AS POINTER TO CURRENT LINE.\n* *    LINE2   - ENDING LINE OF RANGE ENTERED BY USER.\n* *-------------------------------------------------------------------*\n  CALLX ISPLINK,('VDEFINE','(CMD)',CMD,'CHAR',1)\n  CALLX ISPLINK,('VDEFINE','(LINE)',LINE,'CHAR',80)\n  CALLX ISPLINK,('VDEFINE','(LINE1)',LINE1,'FIXED',4)\n  CALLX ISPLINK,('VDEFINE','(LINE2)',LINE2,'FIXED',4)\n        SPACE 1                       |\n* *-------------------------------------------------------------------*\n* *  USE ISREDIT SERVICE TO EXTRACT RANGE OF LINES SPECIFIED BY USER.\n* *-------------------------------------------------------------------*\n  CALLX ISPLINK,('ISREDIT',0,'\u00a2 MACRO (XNXPARM) NOPROCESS \u00a2')\n  CALLX ISPLINK,('ISREDIT',0,'\u00a2 PROCESS RANGE O $ \u00a2')\n  LEAVE BLOCK=CC,(TREG,R15,NZ)        |\n* ERREXIT NAME=PROCESS_ERROR,(CH,R15,GE,=H'16')\n  CALLX ISPLINK,('ISREDIT',0,'\u00a2 (CMD) = RANGE_CMD \u00a2')\n  CALLX ISPLINK,('ISREDIT',0,'\u00a2 (LINE1) = LINENUM .ZFRANGE \u00a2')\n  ERREXIT NAME=BLOCK_INCOMPLETE,(TREG,R15,NZ)\n  CALLX ISPLINK,('ISREDIT',0,'\u00a2 (LINE2) = LINENUM .ZLRANGE \u00a2')\n  ERREXIT NAME=BLOCK_INCOMPLETE,(TREG,R15,NZ)\n         EJECT                        |\n* *-------------------------------------------------------------------*\n* *  LOOP THRU THE LINES SPECIFIED, MERGING THE MASKLINE AS REQUIRED.\n* *  IF \"X\" OR \"NX\" WAS REQUESTED, QUERY THE EXCLUDE STATUS OF EACH\n* *  LINE AS IT GOES BY: OTHERWISE, DON'T BOTHER.\n* *-------------------------------------------------------------------*\n  L     R5,LINE1                      |   GET STARTING LINE\n  LOOP  WHILE,(C,R5,LE,LINE2)         |   DO FOR ALL LINES REQUESTED\n   CALLX  ISPLINK,('ISREDIT',0,'\u00a2 (LINE) = LINE &&LINE1 \u00a2')\n*                                          GET THE DATA LINE\n*  *------------------------------------------------------------------*\n*  *   BOTH 'O' AND '$' STOMP WHATEVER WAS THERE ORIGINALLY.\n*  *------------------------------------------------------------------*\n   IF     (CLI,LINE,NE,C'*'),AND,     | DONT DO COMMENTS OR JCL        *\n               (CLI,LINE,NE,C'/')     |\n    MVI   LINE+71,C'*'                |\n    CALLX ISPLINK,('ISREDIT',0,'\u00a2 LINE &&LINE1 = (LINE) \u00a2')\n    L     R1,COUNT                    | COUNT A CHANGED LINE\n    LA    R1,1(R1)                    |\n    ST    R1,COUNT                    |\n   ENDIF                              |\n   LA    R5,1(R5)                     | INCREMENT 'LINE NUMBER'\n   ST    R5,LINE1                     | SAVE WHERE ISREDIT CAN GET IT\n  ENDLOOP WHILE                       | LOOP THRU ALL LINES.\n        SPACE 1                       |\n  CALLSUB DISPLAY_COUNT               | ZZZZ9 LINES CHANGED\n        SPACE 1                       |\n ENDBLK BLOCK=CC,RC=0                 |\n         EJECT                        |\n BLOCK NAME=DISPLAY_COUNT,TYPE=SUBROUTINE,SAVE=(R14,STCR14),           *\n               PL=(PARMLIST,6)        |\n        SPACE 1                       |\n  L     R1,COUNT                      |\n  CVD   R1,STCD                       |\n  ED    CNTSMSG+DSPCSM(L'DSPCSM),STCD+5\n  ED    CNTLMSG+DSPCLM(L'DSPCLM),STCD+5\n  CALLX ISPLINK,('VDEFINE','(ZEDSMSG)',CNTSMSG,'CHAR',=A(L'CNTSMSG))\n  CALLX ISPLINK,('VDEFINE','(ZEDLMSG)',CNTLMSG,'CHAR',=A(L'CNTLMSG))\n  CALLX ISPLINK,('SETMSG','ISRZ001 ') |\n        SPACE 1                       |\n ENDBLK BLOCK=DISPLAY_COUNT,RC=0      |\n        SPACE 1                       |\n BLOCK NAME=PROCESS_ERROR,TYPE=ERREXIT,PL=(PARMLIST,6)\n        SPACE 1                       |\n  CALLX ISPLINK,('VDEFINE','(ZEDSMSG)',PROCSMSG,'CHAR',=A(L'PROCSMSG))\n  CALLX ISPLINK,('VDEFINE','(ZEDLMSG)',PROCLMSG,'CHAR',=A(L'PROCLMSG))\n  CALLX ISPLINK,('SETMSG','ISRZ001 ') |\n        SPACE 1                       |\n ENDBLK BLOCK=PROCESS_ERROR,RC=12     |\n        SPACE 1                       |\n BLOCK NAME=INVALID_XNXPARM,TYPE=ERREXIT,PL=(PARMLIST,6)\n        SPACE 1                       |\n  CALLX ISPLINK,('VDEFINE','(ZEDSMSG)',XNXSMSG,'CHAR',=A(L'XNXSMSG))\n  CALLX ISPLINK,('VDEFINE','(ZEDLMSG)',XNXLMSG,'CHAR',=A(L'XNXLMSG))\n  CALLX ISPLINK,('SETMSG','ISRZ001 ') |\n        SPACE 1                       |\n ENDBLK BLOCK=INVALID_XNXPARM,RC=12   |\n        SPACE 1                       |\n BLOCK NAME=BLOCK_INCOMPLETE,TYPE=ERREXIT,PL=(PARMLIST,6)\n        SPACE 1                       |\n  CALLX ISPLINK,('VDEFINE','(ZEDSMSG)',BLKISMSG,'CHAR',=A(L'BLKISMSG))\n  CALLX ISPLINK,('VDEFINE','(ZEDLMSG)',BLKILMSG,'CHAR',=A(L'BLKILMSG))\n  CALLX ISPLINK,('SETMSG','ISRZ001 ') |\n        SPACE 1                       |\n ENDBLK BLOCK=BLOCK_INCOMPLETE,RC=12  |\n        SPACE 1                       |\nSTC      DS    0D                     |\nSTCD     DC    D'0'                   |\nSTCR14   DS    F                      |\nISPLINK  DS    F                      | ADDRESS OF ISPLINK\nPARMLIST DS    6F                     | PLACE TO BUILD PARMLISTS\nCMD      DC    C' '                   |\nLINE     DC    CL80' '                | PLACE FOR ISPF TO RETURN LINES\nLINE1    DC    F'0'                   | STARTING/CURRENT LINE NUMBER\nLINE2    DC    F'0'                   | ENDING LINE NUMBER\nCOUNT    DC    F'0'                   | COUNT OF CHANGED LINES\nCNTSMSG  DC    C'...... LINES CHANGED'  'NN LINES CHANGED' SHORT MSG\nDSPCSM   EQU   0,6                    |\n         ORG   CNTSMSG+DSPCSM         |\n         DC    X'402020202120'        | ZZZZ9 EDITMASK\n         ORG   ,                      |\nCNTLMSG  DC    C'THE CC MACRO MODIFIED...... DATA LINES.'\nDSPCLM   EQU   22,6                   | 'NN LINES CHANGED' LONG MSG\n         ORG   CNTLMSG+DSPCLM         |\n         DC    X'402020202120'        | ZZZZ9 EDITMASK\n         ORG   ,                      |\n*---------------------------------------------------------------------*\n* SHORT AND LONG ERROR MESSAGES FOR USE WITH ISPF SERVICE 'SETMSG'.\n*---------------------------------------------------------------------*\nPROCSMSG DC    C'ENTER \"O\"/\"$\" LINE CMD'\nPROCLMSG DC    C'\"CC\" REQUIRES AN \"O\" OR \"$\" CMD TO INDICATE LINE(S) TO*\n                BE CONTINUED'\nXNXSMSG  DC    C'INVALID CC OPTION'   |\nXNXLMSG  DC    C'ON COMMAND LINE, USE \"X\" FOR EXCLUDED LINES OR \"NX\" FO*\n               R NONEXCLUDED LINES.'  |\nBLKISMSG DC    C'CC COMMAND INCOMPLETE' |\nBLKILMSG DC    C'USE \"O\" OR \"$\" LINE COMMANDS TO SPECIFY LINES TO BE PR*\n               OCESSED BY CC.'        |\n         END    ,                     |\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CMTCLIST": {"ttr": 771, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98$\\x0f\\x00\\x98$\\x0f\\x13\\x19\\x01\\x85\\x01\\x85\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-08-28T00:00:00", "modifydate": "1998-08-28T13:19:00", "lines": 389, "newlines": 389, "modlines": 0, "user": "CLEMSON"}, "text": "ISREDIT MACRO (TYPE) NOPROCESS\n  /*------------------------------------------------------*/\n  /*  MACRO NAME: CMT                                     */\n  /*    FUNCTION: INCLUDE ASSEMBLER COMMENT BLOCK INTO    */\n  /*              MEMBER CURRENTLY BEING EDITED.          */\n  /*     TO USE : ON COMMAND LINE TYPE:                   */\n  /*                 %COMMENT P|S|D|I|E                   */\n  /*              WHERE: P GETS A PROGRAM BLOCK COMMENTS  */\n  /*                     S GETS SUBROUTINE COMMENTS       */\n  /*                     D GETS A 'BOX' FOR DATA CMTS.    */\n  /*                     I GETS AN 'INDENTED BOX' FOR     */\n  /*                       STRUCTURED CODE COMMENTS       */\n  /*                     E GETS ERREXIT COMMENTS          */\n  /*                     M GETS MACRO COMMENTS            */\n  /*                     J GETS JCL COMMENTS              */\n  /*                     x GETS XSUB comments (++* * cmt) */\n  /*              IN DATA, TYPE AN 'A' OR 'B' TO TELL     */\n  /*                %CMT WHERE TO PUT THE BLOCK.          */\n  /*    PROBLEMS: NONE KNOWN                              */\n  /*     AUTHOR : JIM BLALOCK, 1/86                       */\n  /*------------------------------------------------------*/\n  ISREDIT (CAPSMODE) = CAPS\n  IF &CAPSMODE = OFF THEN +\n    SET SYSASIS = ON\n  ELSE +\n    SET SYSASIS = OFF\n  IF &STR(&TYPE) = &STR() THEN   SET T = I\n  ELSE                           SET T = &SYSCAPS(&SUBSTR(1,&TYPE))\n  SET DASHES = &STR(+\n*---------------------------------------------------------------------*)\n  ISREDIT PROCESS DEST\n  IF &LASTCC \u00ac= 0 THEN DO\n    SET ZEDSMSG = &STR(A or B line cmd required)\n    SET ZEDLMSG = &STR(+\nUse A or B line command to tell CMT where to stick it, like COPY.)\n    ISPEXEC SETMSG MSG(ISRZ001)\n    EXIT CODE(12)\n  END\n  IF &T = P THEN DO          /* PROGRAM BLOCK */\n    ISREDIT (MBR) = MEMBER\n    ISREDIT (LINE) = LINENUM .ZDEST\n /* ISREDIT TABSLINE = <1,-,16,->   */\n /* ISREDIT BOUNDS = 16 70          */\n    ISREDIT LINE_AFTER &LINE = +\n      \"&MBR     TITLE '_____________________________________________'\"\n    SET LINE = &LINE + 1\n /*   ISREDIT LINE_BEFORE &LINE = MSGLINE +             */\n /*     'WARNING: BOUNDS AND TABS HAVE BEEN CHANGED.'   */\n    ISREDIT LINE_AFTER &LINE = &DASHES\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*'\n    SET LINE = &LINE + 1\n    SET YR2 = &SUBSTR(1:2,&SYSJDATE)\n /* ISREDIT LINE_AFTER &LINE = +\n      '*  Copyright (C) 19&YR2 Clemson University'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*'   */\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*  Program     &MBR '\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*  Abstract    xxx'\n    SET LINE = &LINE + 1\n    SET CSRLINE = &LINE\n    ISREDIT LINE_AFTER &LINE = '*              xxx'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*              xxx'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*  Inputs:'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*      Parameters  xxxxx'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*      Files       xxxxx'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*      Other       None'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*  Outputs:'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*      Returncodes xxxxx'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*      Messages    xxxxx'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*      Files       xxxxx'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*      Other       None'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = +\n'*  PROGRAM     Reentrant, problem key and state, standard linkage,'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = +\n'*  ATTRIBUTES  non-authorized, AMODE(24), RMODE(24)'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*  Special     xxx'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*  Notes       xxx'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*  Change '\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*  History     &SYSDATE ___ - New'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*              __/__/__ ___ '\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*              __/__/__ ___ '\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*  Method of   xxx'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*  Operation   xxx'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = &DASHES\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '         EJECT '\n    ISREDIT CURSOR = &CSRLINE 16\n    EXIT CODE(0)\n  END\n  IF &T = S THEN DO       /* SUBROUTINE BLOCK */\n    ISREDIT (LINE) = LINENUM .ZDEST\n    ISREDIT LINE_AFTER &LINE = &DASHES\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*  Subroutine: xxxxx'\n    SET LINE = &LINE + 1\n    SET CSRLINE = &LINE\n    ISREDIT LINE_AFTER &LINE = '*  Abstract:   xxxxx'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*              xxxxx'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*  Inputs:     xxxxx'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*  Outputs:    xxxxx'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*  Special     xxxxx'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*  Notes:      xxxxx'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = &DASHES\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '         SPACE 1'\n    SET LINE = &LINE + 1\n    ISREDIT CURSOR = &CSRLINE 16\n    EXIT CODE(0)\n  END\n  IF &T = D THEN DO       /* DATA BLOCK */\n    ISREDIT (LINE) = LINENUM .ZDEST\n    ISREDIT LINE_AFTER &LINE = &DASHES\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*'\n    SET LINE = &LINE + 1\n    SET CSRLINE = &LINE\n    ISREDIT LINE_AFTER &LINE = '*'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = &DASHES\n    SET LINE = &LINE + 1\n    ISREDIT CURSOR = &CSRLINE 4\n    EXIT CODE(0)\n  END\n  IF &T = I THEN DO       /* INLINE BLOCK */\n    ISREDIT (LINE) = LINENUM .ZDEST\n    ISREDIT (LAST) = LINENUM .ZLAST\n    SET LINE = &LINE + 1\n    IF &LINE > &LAST THEN DO\n      SET ZEDSMSG = &STR(Invalid line)\n      SET ZEDLMSG = &STR(+\n%CMT macro cannot insert an inline block past the last line of a file.)\n      ISPEXEC SETMSG MSG(ISRZ001)\n      EXIT CODE(12)\n    END\n    ISREDIT (TEXT) = LINE &LINE\n    SET I = 1\n    DO WHILE (&I <= 72)\n     IF &SUBSTR(&I,&TEXT) \u00ac= &STR( )  THEN GOTO ENDSCAN\n     SET I = &I + 1\n    END\nENDSCAN: -\n    IF &I >= 72 THEN DO\n      SET ZEDSMSG = &STR(Unable to indent)\n      SET ZEDLMSG = &STR(+\nLine following inline block destination has no text to indent on.)\n      ISPEXEC SETMSG MSG(ISRZ001)\n      SET RC = 12\n      EXIT CODE(&RC)\n    END\n    SET ASTERS = &STR(*)\n    IF &I = 1 THEN DO\n     SET DASHES = &STR(+\n--------------------------------------------------------------------*)\n     GOTO INLINEGO\n    END\n    SET J = 1\n    DO WHILE (&J < &I.- 1)\n     SET ASTERS = &STR(&ASTERS&STR( ))\n     SET J = &J + 1\n    END\n    SET ASTERS = &STR(&ASTERS&STR(*))\n    SET J = &J + 1    /* SKIP PAST 2ND ASTERISK */\n    SET K = &J + 2    /* COLUMN ADDRESS FOR CURSOR LATER */\n    SET DASHES = &STR()\n    DO WHILE (&J < 70)\n     SET DASHES = &STR(&DASHES&STR(-))\n     SET J = &J + 1\n    END\n    SET DASHES = &STR(&DASHES&STR(*))\nINLINEGO:+\n    SET LINE = &LINE - 1        /* RESTORE ORIGINAL .ZDEST LINE */\n    ISREDIT LINE_AFTER &LINE = '&STR(&ASTERS&DASHES)'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '&ASTERS'\n    SET LINE = &LINE + 1\n    SET CSRLINE = &LINE\n    ISREDIT LINE_AFTER &LINE = '&ASTERS'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '&STR(&ASTERS&DASHES)'\n    SET LINE = &LINE + 1\n    ISREDIT CURSOR = &CSRLINE &K\n    EXIT CODE(0)\n  END\n  IF &T = E THEN DO       /* ERREXIT BLOCK */\n    ISREDIT (LINE) = LINENUM .ZDEST\n    ISREDIT LINE_AFTER &LINE = &DASHES\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*  Errexit:    xxxxx'\n    SET LINE = &LINE + 1\n    SET CSRLINE = &LINE\n    ISREDIT LINE_AFTER &LINE = '*  Purpose:    xxxxx'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*  Called By:  xxxxx'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*  Inputs:     xxxxx'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*  Outputs:    xxxxx'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*  Special     xxxxx'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*  Notes:      xxxxx'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = &DASHES\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '         SPACE 1'\n    SET LINE = &LINE + 1\n    ISREDIT CURSOR = &CSRLINE 16\n    EXIT CODE(0)\n  END\n  IF &T = M THEN DO       /* MACRO BLOCK */\n    ISREDIT (MBR) = MEMBER\n    ISREDIT (LINE) = LINENUM .ZDEST\n    ISREDIT LINE_AFTER &LINE = &DASHES\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*  Macro:      &MBR'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*  Title:      xxxxxxxxxxxxxx'\n    SET LINE = &LINE + 1\n    SET CSRLINE = &LINE\n    ISREDIT LINE_AFTER &LINE = '*'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*  Purpose:    xxxxxxxxxxxxxx'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*              xxxxxxxxxxxxxx'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*  Created By: xxxxxxxx'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*  Special     xxxxxxxxxxxxxxx'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*  Notes:      xxxxxxxxxxxxxxx'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*  Change '\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*  History:    &SYSDATE ___ - New'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*              __/__/__ ___ '\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*              __/__/__ ___ '\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '*'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = &DASHES\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '         SPACE 1'\n    SET LINE = &LINE + 1\n    ISREDIT CURSOR = &CSRLINE 16\n    EXIT CODE(0)\n  END\n  IF &T = J THEN DO          /* JCL BLOCK */\n    ISREDIT (MBR) = MEMBER\n    ISREDIT (LINE) = LINENUM .ZDEST\n    ISREDIT LINE_AFTER &LINE = +\n      \"//************************************************************\"\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '//*'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '++* INCLUDE 'SYSTEMS.JCLLIB(JCLDOC)''\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '//*'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '//*  Purpose:'\n    SET LINE = &LINE + 1\n    SET CSRLINE = &LINE\n    ISREDIT LINE_AFTER &LINE = '//*'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '//*  User: Systems'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '//*'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '//*  Problem Contact: '\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '//*'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '//*  Run cycle:'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '//*'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '//*  JCL Routing:'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '//*'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '//*  Report Routing: '\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '//*'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '//*  Output Verification:'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '//*'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '//*  Rerun Instructions:'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '//*'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = +\n      \"//************************************************************\"\n    ISREDIT CURSOR = &CSRLINE 16\n    EXIT CODE(0)\n  END\n  IF &T = X THEN DO          /* JCL BLOCK */\n    ISREDIT (LINE) = LINENUM .ZDEST\n    ISREDIT LINE_AFTER &LINE = +\n\"++* *---------------------------------------------------------------*\"\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '++* *'\n    SET LINE = &LINE + 1\n    SET &CSRLINE = &LINE\n    ISREDIT LINE_AFTER &LINE = '++* *'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = '++* *'\n    SET LINE = &LINE + 1\n    ISREDIT LINE_AFTER &LINE = +\n\"++* *---------------------------------------------------------------*\"\n    ISREDIT CURSOR = &CSRLINE 7\n    EXIT CODE(0)\n  END\n  SET ZEDSMSG = &STR(Invalid comment type)\n  SET ZEDLMSG = &STR(+\nValid types are: Program/Subroutine/Inline/Errexit/Data/Macro/JCL.)\n  ISPEXEC SETMSG MSG(ISRZ001)\n  EXIT CODE(12)\nEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DOCUMENT": {"ttr": 778, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98$\\x0f\\x00\\x98$\\x0f\\x13\\x19\\x00\\x19\\x00\\x19\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-08-28T00:00:00", "modifydate": "1998-08-28T13:19:00", "lines": 25, "newlines": 25, "modlines": 0, "user": "CLEMSON"}, "text": "          Clemson University Structured Macros SAMPLIB Contents\n\nJCL Procedures:\n\n  ASMP     - Run structured listing pgm only\n  ASMPC    - Run list pgm, Assembler H\n  ASMPCL   - Run list pgm, Assembler H, linkedit\n  ASMPCLG  - Run list pgm, Assembler H, linkedit, execute user pgm\n\nSample Programs:\n\n  BAR      - ISPF edit macro: puts ' | ' in col 38-40 of source code\n  CC       - ISPF edit macro: puts '*' in column 72\n  FLIP     - ISPF edit macro: swaps excluded, nonexcluded lines\n  MASKDATA - ISPF edit macro: applies maskline to existing source code\n  MSC0150$ - Structured listing pgm.  Example of reentrant code.  Used\n             in ASMPxxx procs.\n  STGMAP   - Prints addresses of MVS/XA storage areas (ECSA, LPA, etc).\n             Example of AMODE switching.  Writes to //SYSPRINT.\n\nOther Tools:\n\n  CMTCLIST - ISPF edit macro (in CLIST) which will insert various types\n             of comment 'blocks' for different block structures.  Refer\n             to the member for details.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FLIP": {"ttr": 780, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98$\\x0f\\x00\\x98$\\x0f\\x13\\x19\\x006\\x006\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-08-28T00:00:00", "modifydate": "1998-08-28T13:19:00", "lines": 54, "newlines": 54, "modlines": 0, "user": "CLEMSON"}, "text": "//FLIPMAC  JOB ,'FLIP Edit Macro',TIME=(,2)\n/*JOBPARM Q=H\n//S1 EXEC ASMPCL,PDS='....................',NAME=FLIP\n//P.SYSIN DD *\n**********************************************************************\n* This ISPF Edit macro will exclude all unexcluded lines and         *\n* unexclude all excluded lines.  This operation is equivalent to     *\n* to the \"FLIP\" command in the Clemson Editor.                       *\n**********************************************************************\n   SMLIST CONVERT=YES\n block name=msc0203$,type=program,options=(*norent,xa,mode),           *\n               amode=31,rmode=any,vl,pl=(parmlist,6)\n  load   ep=isplink                   | Get ISPLINK.\n  st     r0,isplink                   |\n* *-------------------------------------------------------------------*\n* * Define ISPF variables, and declare that this is an edit macro\n* *-------------------------------------------------------------------*\n  callx  isplink,('vdefine','(ctr last)',line#s,'fixed',4)\n  callx  isplink,('vdefine','(xcluded)',xcluded,'char',2)\n  callx  isplink,('isredit',0,'\u00a2 macro \u00a2')\n         space 1\n* *-------------------------------------------------------------------*\n* * Flip the exclude status of all lines\n* *-------------------------------------------------------------------*\n  callx  isplink,('isredit',0,'\u00a2 (ctr) = linenum .zf \u00a2')\n  callx  isplink,('isredit',0,'\u00a2 (last)  = linenum .zl \u00a2')\n  loop   while,(clc,ctr,le,last)      | Loop through all lines.\n   callx isplink,('isredit',0,'\u00a2 (xcluded) = xstatus (ctr) \u00a2')\n   if    (clc,xcluded,eq,=c'x ')      |  If line is excluded,\n    callx isplink,('isredit',0,'\u00a2 xstatus (ctr) = nx \u00a2')  unexclude it.\n   else                               |  Else it is unexcluded,\n    callx isplink,('isredit',0,'\u00a2 xstatus (ctr) = x \u00a2')  so exclude it.\n   endif                              |  Endif. (Line excluded or not)\n   l     r1,ctr                       |  Update line\n   la    r1,1(,r1)                    |    counter\n   st    r1,ctr                       |      field.\n  endloop while                       | Endloop. (Thru all lines)\n  callx  isplink,('vdelete','*')      | Delete all variables defined.\n endblk  block=msc0203$\n         eject\n**********************************************************************\n*                                                                    *\n*                             Data Section                           *\n*                                                                    *\n**********************************************************************\n              ltorg\n              ds  0f                  | Force a fullword boundary.\nisplink       ds  f                   | Holds address of ISPLINK.\nline#s        ds  0cl(2*4)            | Array(2) of line# counters.\nctr           ds  f                   | Line counter.\nlast          ds  f                   | Last line in file.\nxcluded       ds  cl2                 | Exclude status of current line.\nparmlist      ds  cl(6*4)             | Parmlist goes here.\n              end\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MASKDATA": {"ttr": 782, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98$\\x0f\\x00\\x98$\\x0f\\x13\\x19\\x01\\x00\\x01\\x00\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-08-28T00:00:00", "modifydate": "1998-08-28T13:19:00", "lines": 256, "newlines": 256, "modlines": 0, "user": "CLEMSON"}, "text": "//MASKDATA JOB ,'MASKDATA Macro',\n//  TIME=(,3),REGION=1M\n/*JOBPARM Q=H\n//MASKDATA EXEC ASMPCL,PDS='....................',NAME=MASKDATA\n//P.SYSIN  DD  *\nMASKDATA TITLE 'MASKDATA Edit Program Macro'\n         PUNCH ' ALIAS MD'\n         SMLIST CONVERT=YES\n*---------------------------------------------------------------------*\n*\n*  COPYRIGHT (C) 1986 CLEMSON UNIVERSITY\n*\n*  PROGRAM     MASKDATA\n*\n*  ABSTRACT    This is the 'MASKDATA' macro, which will merge the lines\n*              specifed by 'OO' or '$$' line commands with the current\n*              mask like.  Also, the operands 'X' or 'NX' on the\n*              command line will cause 'MASKDATA' to process only the\n*              excluded ('X') or nonexcluded ('NX') lines.\n*\n*  INPUTS:\n*      PARAMETERS  None\n*      FILES       None\n*      OTHER       Variables from ISPF/PDF Edit (See code)\n*\n*  OUTPUTS:\n*      MESSAGES\n*        Enter \"O\" line cmd\n*           . \"MASKDATA\" requires an \"O\" cmd to indicate line(s)\n*             merged with maskline\n*        Invalid MD option\n*           . On command line, use \"X\" for excluded lines or \"NX\" for\n*             nonexcluded lines.\n*        MD command incomplete\n*           . Use \"O\" line command to specify lines to be processed by\n*             MASKDATA.\n*      FILES       None\n*      OTHER       Modifies lines in dataset currently under edit\n*\n*  PROGRAM     NONREENTRANT, PROBLEM KEY AND STATE, STANDARD LINKAGE,\n*  ATTRIBUTES  NON-AUTHORIZED, AMODE(31), RMODE(ANY)\n*\n*  SPECIAL\n*  NOTES       None\n*\n*  CHANGE\n*  HISTORY     09/12/86 JCB - New\n*              01/11/89 PLH - Cleaned up\n*\n*  METHOD OF\n*  OPERATION   See code\n*\n*---------------------------------------------------------------------*\n         space 2\n block   name=md,type=program,options=(*norent,xa,mode),               *\n               amode=31,rmode=any,pl=(parmlist,6)\n         space 1\n  load   ep=isplink                   | Get ISPLINK.\n  st     r0,isplink                   |\n         space 2\n* *-------------------------------------------------------------------*\n* *  Issue VDEFINEs for the following variables:\n* *    XNXPARM - Parameter 'X' or 'NX' from command line\n* *    XNX     - Exclude status of current line\n* *    CMD     - Line command entered (\"O\" or \"$\")\n* *    LINE1   - Starting line of range entered by user. Also used\n* *              as pointer to current line.\n* *    LINE2   - Ending line of range entered by user.\n* *    LRECL   - LRECL of current dataset.\n* *    LINE    - Data line currently being processed\n* *-------------------------------------------------------------------*\n  callx  isplink,('vdefine','(xnxparm)',xnxparm,'char',2)\n  callx  isplink,('isredit',0,'\u00a2 macro (xnxparm) noprocess \u00a2')\n  callx  isplink,('vdefine','(xnx)',xnx,'char',2)\n  callx  isplink,('vdefine','(cmd)',cmd,'char',1)\n  callx  isplink,('vdefine','(line1)',line1,'fixed',4)\n  callx  isplink,('vdefine','(line2)',line2,'fixed',4)\n  callx  isplink,('vdefine','(lrecl)',lrecl,'fixed',4)\n  callx  isplink,('isredit',0,'\u00a2 (lrecl) = lrecl \u00a2')\n  callx  isplink,('vdefine','(line)',line,'char',lrecl)\n         space 1\n* *-------------------------------------------------------------------*\n* *  Use ISREDIT service to extract range of lines specified by user.\n* *-------------------------------------------------------------------*\n  callx  isplink,('isredit',0,'\u00a2 process range o $ \u00a2')\n  errexit name=block_incomplete,(ch,r15,eq,=h'16')\n  errexit name=process_error,(treg,r15,nz)\n  callx  isplink,('isredit',0,'\u00a2 (cmd) = range_cmd \u00a2')\n  callx  isplink,('isredit',0,'\u00a2 (line1) = linenum .zfrange \u00a2')\n  callx  isplink,('isredit',0,'\u00a2 (line2) = linenum .zlrange \u00a2')\n         space 3\n* *-------------------------------------------------------------------*\n* *  Determine if user requested processing of excluded or non-\n* *  excluded lines. Note that &XNXPARM is not converted to uppercase\n* *  by ISREDIT.\n* *-------------------------------------------------------------------*\n  oc     xnxparm,=c'  '               | Convert &XNXPARM to uppercase\n  if     (clc,xnxparm,eq,=c'x ')      | Excluded lines only?\n   sbit  stcf1x                       |  Set flag for later.\n  elseif (clc,xnxparm,eq,=c'nx')      | Nonexcluded lines only?\n   sbit  stcf1nx                      |  Set flag for later.\n  elseif (clc,xnxparm,ne,=c'  ')      | Something else?\n   errexit name=invalid_xnxparm       |  Issue error message.\n  endif                               | Endif. (Excluded lines or not)\n         space 3\n* *-------------------------------------------------------------------*\n* *  Loop thru the lines specified, rotating the lines as required.\n* *  If \"X\" or \"NX\" was requested, query the exclude status of each\n* *  line as it goes by: otherwise, don't bother.\n* *-------------------------------------------------------------------*\n  l      r5,line1                     | Get starting line\n  loop   while,(c,r5,le,line2)        | Do for all lines requested\n   callx isplink,('isredit',0,'\u00a2 (line) = line &&line1 \u00a2')\n*                                     |  Get the data line\n   if    not,(tbit,(stcf1x+stcf1nx),off) If X or NX requested\n    callx isplink,('isredit',0,'\u00a2 (xnx) = xstatus &&line1 \u00a2')\n   endif                              |   Get exclude status.\n         space 2\n*  *------------------------------------------------------------------*\n*  * A line command of \"$\" causes the mask line to overlay data.\n*  * A line command of \"O\" causes data to overlay the mask line.\n*  *------------------------------------------------------------------*\n   if    (tbit,stcf1x+stcf1nx,off),or,                                 *\n               ((tbit,stcf1x,on),and,(clc,xnx,eq,=c'x ')),or,          *\n               ((tbit,stcf1nx,on),and,(clc,xnx,eq,=c'nx'))\n    if   (clc,line(72),eq,=cl72' ')   |   If line is blank, line=mask\n     callx isplink,('isredit',0,'\u00a2 line &&line1 = maskline \u00a2')\n    elseif (cli,cmd,eq,c'$')          |   Elseif mask overlays data,\n     callx isplink,('isredit',0,'\u00a2 line &&line1 = (line) + maskline \u00a2')\n    else                              |   Else data overlays mask\n     callx isplink,('isredit',0,'\u00a2 line &&line1 = maskline + (line) \u00a2')\n    endif                             |   Endif. (Blank, $, or O)\n         space 1\n    l    r1,count                     |   Count number\n    la   r1,1(,r1)                    |     of lines\n    st   r1,count                     |       changed.\n   endif                              |  Endif. (Exclude status OK)\n   la    r5,1(r5)                     |  Increment 'line number'\n   st    r5,line1                     |  Save where ISREDIT can get it\n  endloop while                       | Endloop. (Thru all lines)\n         space 1\n  callsub display_count               | Display # of lines changed.\n         space 1\n endblk  block=md,rc=0\n         eject\n*---------------------------------------------------------------------*\n*  Subroutine: Display_Count\n*  Abstract:   Display an ISPF short msg/long msg telling the user\n*              how many lines were rotated.\n*---------------------------------------------------------------------*\n         SPACE 1\n block   name=display_count,type=subroutine,save=(r14,stcr14),         *\n               pl=(parmlist,6)\n         space 1\n  l      r1,count\n  cvd    r1,stcd\n  ed     cntsmsg+dspcsm(l'dspcsm),stcd+5\n  ed     cntlmsg+dspclm(l'dspclm),stcd+5\n  callx  isplink,('vdefine','(zedsmsg)',cntsmsg,'char',=a(l'cntsmsg))\n  callx  isplink,('vdefine','(zedlmsg)',cntlmsg,'char',=a(l'cntlmsg))\n  callx  isplink,('setmsg','isrz001 ')\n         space 1\n endblk  block=display_count,rc=0\n         space 3\n*---------------------------------------------------------------------*\n*  Errexit:    Process_Error\n*  Purpose:    Called when there was an error in processing the user's\n*              line commands.\n*  Called By:  Mainline\n*  Inputs:     None.\n*  Outputs:    Issues error message telling user to use \"O\" line cmd.\n*---------------------------------------------------------------------*\n         space 1\n block   name=process_error,type=errexit,pl=(parmlist,6)\n  callx  isplink,('vdefine','(zedsmsg)',procsmsg,'char',=a(l'procsmsg))\n  callx  isplink,('vdefine','(zedlmsg)',proclmsg,'char',=a(l'proclmsg))\n  callx  isplink,('setmsg','isrz001 ')\n endblk  block=process_error,rc=12\n         space 3\n*---------------------------------------------------------------------*\n*  Errexit:    Invalid_XNXPARM\n*  Purpose:    Called when user specified something other than X or\n*              NX on the command line.\n*  Called By:  Mainline\n*  Inputs:     None.\n*  Outputs:    Issues error message telling user to use \"X\" or \"NX\"\n*              on command line.\n*---------------------------------------------------------------------*\n         space 1\n block   name=invalid_xnxparm,type=errexit,pl=(parmlist,6)\n  callx  isplink,('vdefine','(zedsmsg)',xnxsmsg,'char',=a(l'xnxsmsg))\n  callx  isplink,('vdefine','(zedlmsg)',xnxlmsg,'char',=a(l'xnxlmsg))\n  callx  isplink,('setmsg','isrz001 ')\n endblk  block=invalid_xnxparm,rc=12\n         space 3\n*---------------------------------------------------------------------*\n*  Errexit:    Block_Incomplete\n*  Purpose:    Called when PROCESS says the user didn't specify the\n*              whole block command.\n*  Called By:  Mainline\n*  Inputs:     None.\n*  Outputs:    Issues error message telling user to use \"O\" block cmd.\n*---------------------------------------------------------------------*\n         space 1\n block   name=block_incomplete,type=errexit,pl=(parmlist,6)\n  callx  isplink,('vdefine','(zedsmsg)',blkismsg,'char',=a(l'blkismsg))\n  callx  isplink,('vdefine','(zedlmsg)',blkilmsg,'char',=a(l'blkilmsg))\n  callx  isplink,('setmsg','isrz001 ')\n endblk  block=block_incomplete,rc=12\n         space 1\n*---------------------------------------------------------------------*\n*  Storage area.  (Non-reentrant.)\n*---------------------------------------------------------------------*\n         psd\nstc      ds    d                      |\nstcd     ds    d                      |\nstcr14   ds    f                      |\nisplink  ds    f                      | Address of ISPLINK in LPA\nparmlist ds    6f                     | Place for CALLX parmlists\ncmd      dc    c' '                   | Line command 'O'/'$'.\nxnxparm  dc    cl2' '                 | 'X'/'NX' from MD command\nxnx      dc    cl2' '                 | Current line exclude status\nstcf1    dc    x'00'                  | Work flags:\nstcf1x   equ   x'80'   |1... ....|    |  \"MD X\" was specified\nstcf1nx  equ   x'40'   |.1.. ....|    |  \"MD NX\" was specified\nline     dc    cl255' '               | Current line from file\nline1    dc    f'0'                   | Starting/current line #\nline2    dc    f'0'                   | Last line #\nlrecl    dc    f'0'                   | LRECL of data set.\n         space 1\ncount    dc    f'0'                   |\ncntsmsg  dc    c\"...... lines changed\"\ndspcsm   equ   0,6                    |\n         org   cntsmsg+dspcsm         |\n         dc    x'402020202120'        |\n         org   ,                      |\ncntlmsg  dc    c\"The MASKDATA macro modified...... data lines.\"\ndspclm   equ   27,6\n         org   cntlmsg+dspclm\n         dc    x'402020202120'\n         org   ,\n*\n         SMLIST CONVERT=NO\nPROCSMSG DC    C'Enter \"O\"/\"$\" line cmd'\nPROCLMSG DC    C'MASKDATA requires an \"O\" or \"$\" cmd to indecate line(s*\n               ) merged with Maskline.'\nXNXSMSG  DC    C'Invalid MD option'\nXNXLMSG  DC    C'On command line, use \"X\" for excluded lines or \"NX\" fo*\n               r nonexcluded lines.'\nBLKISMSG DC    C'MD command incomplete'\nBLKILMSG DC    C'Use \"O\" or \"$\" line commands to specify lines to be pr*\n                ocessed by MASKDATA.'\n         SMLIST CONVERT=YES\n*\n         endpsd\n         end\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSC0150$": {"ttr": 1029, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98$\\x0f\\x00\\x98$\\x0f\\x13 \\x03\\xad\\x03\\xad\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-08-28T00:00:00", "modifydate": "1998-08-28T13:20:00", "lines": 941, "newlines": 941, "modlines": 0, "user": "CLEMSON"}, "text": "//MSC0150$ JOB (H2803302,S17,,8),'S17 ASSEMBLE&LINK',TIME=(,4)\n/*JOBPARM Q=T,I\n// EXEC ASMPCL,COPT=',RENT',LOPT=',RENT',\n//     PDS='SYS1.LINK2LIB',NAME=MSC0150$,COND=(0,NE)\n//P.SYSIN    DD  *\nMSC0150 TITLE 'STRUCTURED MACRO LISTING PROGRAM'\n*---------------------------------------------------------------------*\n*\n*  CSECT: MSC0150\n*\n*  COPYRIGHT: (C) COPYRIGHT CLEMSON UNIVERSITY 1983, 1988.\n*\n*  ABSTRACT: THIS PROGRAM READS AN ASSEMBLER SOURCE PROGRAM CONTAINING\n*            THE CLEMSON STRUCTURED MACROS AND PRODUCES A LISTING\n*            WITH TITLING, SPACING, AND NESTING INFORMATION.  THE\n*            ASSEMBLER SOURCE IS WRITTEN TO DDNAME SYSPUNCH FOR\n*            FURTHER PROCESSING BY THE ASSEMBLER.  SOME ERROR CHECKING\n*            IS DONE FOR STRUCTURAL PROBLEMS BUT THIS CHECKING\n*            IS BY NO MEANS EXTENSIVE.\n*\n*  FILES: SYSIN    - SOURCE INPUT FILE\n*         SYSPRINT - LISTING FILE\n*         SYSPUNCH - SOURCE OUTPUT FILE\n*\n*  RETURN CODES:  0 - GOOD\n*                 4 - A WARNING ERROR WAS ENCOUNTERED\n*                 8 - A ERROR WAS ENCOUNTERED\n*                16 - A SEVERE ERROR CAUSED THE PROGRAM TO TERMINATE\n*\n*  ATTRIBUTES: REENTRENT, AMODE 24, RMODE 24\n*\n*  DEPENDENCIES: DEFAULT ICTL IS REQUIRED FOR SYSIN.  THIS ASSMEMBLY\n*                REQUIRES THE CLEMSON STRUCTURED MACROS.\n*\n*  METHOD OF OPERATION:\n*\n*     OPEN FILES\n*     READ FIRST SYSIN RECORD\n*     DO WHILE NOT END OF FILE ON SYSIN\n*       WRITE RECORD TO SYSPUNCH\n*       IF NOT COMMENT CARD OR CONTINUED LINE\n*         SCAN FOR OPCODE\n*         IF OPCODE IS ONE OF THE STRUCTURED MACRO THAT START OR END\n*           A STRUCTURE OR MACRO OR MEND , DO NESTING AND UNNESTING\n*           PROCESSING FOR LISTING\n*         ELSEIF 'SPACE', 'TITLE', OR 'EJECT', DO APPROPRIATE\n*           LISTING PROCESSING\n*       ENDIF\n*       DO CONTINUATION PROCESSING\n*       PRINT TITLE AND HEADING IF OVERFLOW\n*       PRINT LINE IF APPROPRIATE\n*       READ NEXT SYSIN RECORD\n*     ENDDO\n*     CLOSE FILES\n*     RETURN\n*\n*  MODULE ACTIVITY:  MGG 07/29/83 NEW\n*                    MGG 09/04/84 FIXED TITLE STATMENT PROCESSING.\n*                                 PUT IN CONTINUED STATEMENT CHECK.\n*                                 INSTREAM MACRO SUPPORT\n*                                 GENERAL CLEANUP\n*                    MGG 01/29/87 RESTRUCTURED AND REMOVED @CN.\n*                    MGG  8/08/88 ADDED SMLIST SUPPORT              @C4\n*---------------------------------------------------------------------*\n  EJECT                               |\n BLOCK NAME=MSC0150,TYPE=PROGRAM,OPTIONS=(*PWA),SUBOPTS=*SWA,       @C4$\n               BASEREG=(R12,R11)      |                             @C4\n* *-------------------------------------------------------------------*\n* *  INITIALIZE THE PROGRAM WORK AREA.\n* *-------------------------------------------------------------------*\n  CALLSUB INITIALIZE_PWA              | INITIALIZE PWA\n* *-------------------------------------------------------------------*\n* *  OPEN SOURCE INPUT AND OUTPUT FILES AND PRINT FILE.\n* *-------------------------------------------------------------------*\n  MVC   PWADIN,PSDDIN                 | MOVE SYSIN DCB TO PWA\n  MVC   PWADOUT,PSDDOUT               | MOVE SYSPUNCH DCB TO PWA\n  MVC   PWADPRT,PSDDPRT               | MOVE SYSPRINT DCB TO PWA\n  MVC   PWAOPN3,PSDOPN3               | MOVE OPEN LIST FORM TO PWA\n  OPEN  (PWADIN,INPUT,PWADOUT,OUTPUT,PWADPRT,OUTPUT),MF=(E,PWAOPN3)\n  ERREXIT (TBIT,PWADIN+DCBOFLGS-IHADCB,DCBOFOPN,OFF),CODE=0\n  ERREXIT (TBIT,PWADOUT+DCBOFLGS-IHADCB,DCBOFOPN,OFF),CODE=1\n  ERREXIT (TBIT,PWADPRT+DCBOFLGS-IHADCB,DCBOFOPN,OFF),CODE=2\n* *-------------------------------------------------------------------*\n* *  PRINT LISTING UNTIL END OF FILE ON SYSIN.\n* *-------------------------------------------------------------------*\n  CALLSUB READ_SYSIN_AND_WRITE_SRCOUT | DO PRIMING READ\n  LOOP WHILE,NOT,(TBIT,PWAF1EOF)      | LOOP WHILE NOT END OF FILE\n*  *------------------------------------------------------------------*\n*  *  IF NOT A COMMENT CARD, SEARCH FOR AN OPCODE ON THE LINE AND\n*  *  DO THE APPROPRIATE LISTING PROCESSING.\n*  *------------------------------------------------------------------*\n   IF (CLI,PWATEXT,NE,C'*'),AND,      |  IF NOT A COMMENT CARD         $\n               (CLC,PWATEXT(2),NE,=C'.*')\n    LA    R1,PWALNE                   |   POINT R1 TO START OF TEXT\n    LA    R15,PWATEXT+L'PWATEXT       |   POINT R15 TO LAST BYTE\n    LA    R14,1                       |   SET INCREMENT TO 1\n    LOOP  BXLE                        |   USE BXLE TO FIND THE\n     LEAVE LOOP=*,(CLI,0(R1),EQ,X'40')     FIRST BLANK AFTER\n    ENDLOOP BXLE,R1,R14               |    AN OPTIONAL TAG\n    XC    PWAAOPR,PWAAOPR             |   CLEAR POINTER TO OPCODE\n    LOOP  BXH,R1,R14                  |   SEARCH FOR NONBLANK\n     IF  (CLI,0(R1),NE,X'40')         |    IF NONBLANK FOUND\n      ST    R1,PWAAOPR                |     SAVE POINTER TO OPCODE\n      CALLSUB PROCESS_OPCODE          |     PROCESS THE OPCODE\n      LEAVE LOOP=*                    |     LEAVE SEARCH FOR OPCODE\n     ENDIF                            |    ENDIF\n    ENDLOOP BXH                       |   END OF SEARCH\n   ENDIF                              |  ENDIF\n*  *------------------------------------------------------------------*\n*  *  IF A STATEMENT IS CONTINUED, PROCESS CONTINUATION LINES.\n*  *------------------------------------------------------------------*\n   IF (CLI,PWACONT,NE,X'40')          |  IF CONTINUED STATEMENT\n    CALLSUB PROCESS_CONTINUATION_LINES    PROCESS CONTINUATION LINES\n   ENDIF                              |  ENDIF\n*  *------------------------------------------------------------------*\n*  *  IF THE NOWRITE FLAG IS NOT SET,  PRINT A STATEMENT LINE.\n*  *------------------------------------------------------------------*\n   IF (TBIT,PWAF1NOW,OFF)             |  IF NO WRITE FLAG IS OFF\n    CALLSUB PRINT_STATEMENT_LINE      |   PRINT STATEMENT\n   ENDIF                              |  ENDIF\n   RBIT  PWAF1NOW                     |  RESET NOWRITE FLAG\n*  *------------------------------------------------------------------*\n*  *  READ NEXT STATEMENT\n*  *------------------------------------------------------------------*\n   IF NOT,(TBIT,PWAF1EOF)             |  IF NOT END OF FILE\n    CALLSUB READ_SYSIN_AND_WRITE_SRCOUT   GET NEXT RECORD\n   ENDIF                              |  ENDIF\n*  *------------------------------------------------------------------*\n  ENDLOOP WHILE                       | ENDLOOP\n* *-------------------------------------------------------------------*\n* *  IF STRUCTURAL LEVEL IS NON-ZERO, ISSUE ERROR MESSAGE.\n* *-------------------------------------------------------------------*\n  IF (CLC,PWANSTL,NE,=H'0')           | IF LEVEL NOT ZERO\n   PUT   PWADPRT,PSDERLVL             |  ISSUE ERROR MESSAGE\n   IF (CLI,PWAMAXRC,LT,8)             |  IF MAX RETURN CODE < 8\n    MVI   PWAMAXRC,8                  |   MOVE 8 TO MAX RETURN CODE\n   ENDIF                              |  ENDIF\n  ENDIF                               | ENDIF\n* *-------------------------------------------------------------------*\n* *  CLOSE FILES AND RETURN WITH MAXIMUM RETURN CODE.\n* *-------------------------------------------------------------------*\n  MVC   PWAOPN3,PSDOPN3               | MOVE OPEN LIST FORM TO PWA\n  CLOSE (PWADIN,,PWADOUT,,PWADPRT),MF=(E,PWAOPN3) CLOSE FILES\n* *-------------------------------------------------------------------*\n* *  SET RETURN CODE.\n* *-------------------------------------------------------------------*\n  SLR   R15,R15                    CLEAR R15\n  IC    R15,PWAMAXRC               LOAD MAXIMUM RETURN CODE\n* *-------------------------------------------------------------------*\n ENDBLK BLOCK=MSC0150,RC=(R15)  END OF PROGRAM BLOCK\n EJECT                                |\n**--------------------------------------------------------------------*\n**  EODAD EXIT - FOR SYSIN FILE\n**--------------------------------------------------------------------*\n SPACE 1                              |\n BLOCK NAME=EODADIN,TYPE=SUBROUTINE,OPTIONS=*NOSUBOPTS\n  SBIT  PWAF1EOF                      | SET END OF FILE FLAG\n ENDBLK BLOCK=EODADIN                 |\n EJECT                                |\n**--------------------------------------------------------------------*\n**  SUBROUTINE: INITIALIZE_PWA\n**\n**  THIS SUBROUTINE INITIALIZES FIELDS IN THE PWA.\n**--------------------------------------------------------------------*\n BLOCK TYPE=SUBROUTINE,NAME=INITIALIZE_PWA\n  ZAP   PWALNUM,=P'999'               | FORCE TITLES\n  ZAP   PWAPGN,=P'0'                  | SET PAGE NUMBER TO ZERO\n  ZAP   PWAMNL,=P'0'                  | SET MACRO NESTING LEVEL TO ZERO\n  FILL  PWANSTK,X'40'                 | INITIALIZE NESTING STACK\n  MVC   PWAT,PSDT                     | INITIALIZE TITLE LINE\n  MVC   PWAH,PSDH                     | INITIALIZE HEADING LINE\n  TIME  ,                             | GET TIME\n  ST    R1,PWAD                       | STORE DATE\n  MVC   PWAHDTE,PSDMDTE               | MOVE MASK FOR DATE\n  ED    PWAHDTE,PWAD+1                | EDIT DATE INTO HEADING LINE\n  ST    R0,PWAD                       | STORE TIME\n  MVC   PWAHTME,PSDMTME               | MOVE EDIT MASK FOR TIME\n  ED    PWAHTME,PWAD                  | EDIT TIME INTO HEADING LINE\n  MVC   PWAL,PSDL                     | INITIALIZE TEXT LINE\n  MVC   PWABLINE,PSDBLINE             | INITIALIZE BLANK LINE\n ENDBLK BLOCK=INITIALIZE_PWA          |\n EJECT                                |\n**--------------------------------------------------------------------*\n**  SUBROUTINE: PROCESS_OPCODE\n**\n**  THIS SUBROUTINE WILL CHECK TO SEE IF THE OPCODE POINTED TO\n**  BY REGISTER 1 IS ONE OF THE STRUCTURED MACROS, TITLE, EJECT,\n**  SPACE, MACRO OR MEND AND TAKE THE APPROPRIATE LISTING ACTIONS.\n**  IF THE OPCODE IS ONE OF THE MACROS THAT START A STRUCTURE, CALLS\n**  NEST.  IF IT IS ONE OF THE MACROS THAT END A STRUCTURE, CALL\n**  UNNEST.  IF WE ARE INSIDE A MACRO DEFINITION,  ALL THAT IS LOOKED\n**  FOR IS MEND AND MACRO MNEMONICS.\n**--------------------------------------------------------------------*\n BLOCK TYPE=SUBROUTINE,NAME=PROCESS_OPCODE\n  IF (CP,PWAMNL,GT,=P'0')             | IF MACRO NESTING IS NON-ZERO\n   IF (CLC,=C'MEND ',EQ,0(R1))        |  IF 'MEND'\n    CALLSUB UNNEST,('M')              |   CALL UNNEST\n    SP    PWAMNL,=P'1'                |   DEC MACRO NESTING LVL\n   ELSEIF (CLC,=C'MACRO ',EQ,0(R1))   |  ELSE IF 'MACRO'\n    CALLSUB NEST,('M')                |   CALL NEST\n    AP    PWAMNL,=P'1'                |   INC MACRO NESTING LVL\n   ENDIF                              |  ENDIF\n  ELSEIF (CLC,=C'BLOCK ',EQ,0(R1))    | ELSEIF 'BLOCK'\n   CALLSUB NEST,('B')                 |  CALL NEST\n  ELSEIF (CLC,=C'ENDBLK ',EQ,0(R1))   | ELSEIF 'ENDBLK'\n   CALLSUB UNNEST,('B')               |  CALL UNNEST\n  ELSEIF (CLC,=C'CASEBLK ',EQ,0(R1))  | ELSEIF 'CASEBLK'\n   CALLSUB NEST,('C')                 |  CALL NEST\n  ELSEIF (CLC,=C'ENDCASE ',EQ,0(R1))  | ELSEIF 'ENDCASE'\n   CALLSUB UNNEST,('C')               |  CALL UNNEST\n  ELSEIF (CLC,=C'IF ',EQ,0(R1))       | ELSEIF 'IF'\n   CALLSUB NEST,('I')                 |  CALL NEST\n  ELSEIF (CLC,=C'ENDIF ',EQ,0(R1))    | ELSEIF 'ENDIF'\n   CALLSUB UNNEST,('I')               |  CALL UNNEST\n  ELSEIF (CLC,=C'LOOP ',EQ,0(R1))     | ELSEIF 'LOOP'\n   CALLSUB NEST,('L')                 |  CALL NEST\n  ELSEIF (CLC,=C'ENDLOOP ',EQ,0(R1))  | ELSEIF 'ENDLOOP'\n   CALLSUB UNNEST,('L')               |  CALL UNNEST\n  ELSEIF (CLC,=C'MACRO ',EQ,0(R1))    | ELSEIF 'MACRO'\n   CALLSUB NEST,('M')                 |  CALL NEST\n   AP    PWAMNL,=P'1'                 |  UP MACRO NESTING LEVEL\n  ELSEIF (CLC,=C'MEND ',EQ,0(R1))     | ELSEIF 'MEND'\n   MVC   PWALMSG(26),=C'>E-4 MEND OUTSIDE OF MACRO'\n   IF (CLI,PWAMAXRC,LT,4)             |  IF MAX RETURN CODE < 4\n    MVI   PWAMAXRC,4                  |   SET RETURN CODE TO 4\n   ENDIF                              |  ENDIF\n  ELSEIF (CLC,=C'TITLE ',EQ,0(R1))    | ELSEIF 'TITLE'\n   CALLSUB PROCESS_TITLE              |  PROCESS TITLE\n  ELSEIF (CLC,=C'SPACE ',EQ,0(R1))    | ELSEIF 'SPACE'\n   CALLSUB PROCESS_SPACE              |  PROCESS SPACE\n  ELSEIF (CLC,=C'EJECT ',EQ,0(R1))    | ELSEIF 'EJECT'\n   ZAP   PWALNUM,=P'999'              |  CAUSE TITLE TO PRINT\n   SBIT  PWAF1NOW                     |  INDICATE NO WRITE\n  ELSEIF (CLC,=C'END ',EQ,0(R1))      | ELSEIF 'END'\n   SBIT  PWAF1EOF                     |  INDICATE END OF FILE\n  ELSEIF (CLC,=C'SMLIST ',EQ,0(R1))   | ELSEIF 'SMLIST'             @C4\n   CALLSUB PROCESS_SMLIST             |  PROCESS SMLIST COMMAND     @C4\n  ENDIF                               | ENDIF\n ENDBLK BLOCK=PROCESS_OPCODE          |\n  EJECT                               |\n**--------------------------------------------------------------------*\n**  SUBROUTINE - PROCESS_TITLE\n**\n**  IF 'TITLE' IS THE OPCODE, ISOLATE THE TITLE, MOVE IT TO THE TITLE\n**  LINE, AND FORCE OVERFLOW.  THIS CODE HANDLES DOUBLE QUOTES BUT\n**  DOES NOT AND IN FACT CAN NOT HANDLE SYMBOLIC VARIABLE\n**  SUBSTITUTION.  IF THIS CODE DETECTS A SYNTAX ERROR, THE MOVE OF\n**  THE TITLE IS TERMINATED BUT NO SYNTAX ERROR IS ISSUED.\n**--------------------------------------------------------------------*\n BLOCK TYPE=SUBROUTINE,NAME=PROCESS_TITLE\n* *-------------------------------------------------------------------*\n* *  IF NAME FIELD IS NON-BLANK AND NOT A SEQUENCE SYMBOL AND AN\n* *  IDENTIFICATION IS SPECIFIED IN THE NAME FIELD OF THE TITLE\n* *  STATEMENT AND WE HAVE NOT ALREADY DONE SO, MOVE THE\n* *  IDENTIFICATION TO THE MODEL OUTPUT TITLE LINE.\n* *-------------------------------------------------------------------*\n  IF (CLI,PWATEXT,NE,C'.'),AND,       | IF NAME FIELD IS NOT A         $\n               (CLI,PWATEXT,NE,X'40'),AND, SEQUENCE SYMBOL OR BLANK    $\n               (CLI,PWATID,EQ,X'40')  |    AND THIS IS THE 1ST TIME\n   L     R3,PWAAOPR                   |  POINT R3 TO 'TITLE'\n   LA    R2,PWALNE                    |  POINT R2 TO START OF LINE\n   SLR   R3,R2                        |  CALC LENGTH BEFORE 'TITLE'\n   LA    R4,PWATID                    |  POINT TO ID IN TITLE LINE\n   LA    R5,L'PWATID                  |  LOAD R5 WITH LENGTH OF ID\n   ICM   R3,B'1000',=X'40'            |  FILL CHAR IS SPACE\n   MVCL  R4,R2                        |  MOVE ID TO TITLE\n  ENDIF                               | ENDIF\n* *-------------------------------------------------------------------*\n* *  BLANK OUT PLACE TO PUT TITLE IN MODEL TITLE OUTPUT LINE AND\n* *  POINT R4 TO PLACE, LOAD R5 WITH LENGTH OF PLACE, AND POINT R1\n* *  TO FIRST NON-BLANK AFTER 'TITLE'.\n* *-------------------------------------------------------------------*\n  FILL  PWATDTA,X'40'                 | BLANK OUT PLACE TO PUT TITLE\n  LA    R4,PWATDTA                    | POINT R4 TO PLACE\n  LA    R5,L'PWATDTA                  | LOAD R5 WITH IT'S LENGTH\n  L     R1,PWAAOPR                    | POINT R1 TO 'TITLE'\n  LA    R1,5(,R1)                     | POINT R1 PAST 'TITLE'\n  LA    R14,1                         | SET INCREMENT TO 1\n  LA    R15,PWATEXT+L'PWATEXT         | POINT R15 TO LAST BYTE\n  LOOP  BXH,R1,R14                    | SEARCH FOR NON-BLANK\n   LEAVE LOOP=*,(CLI,0(R1),NE,X'40')  |  PAST 'TITLE'\n  ENDLOOP BXH                         | END SEARCH\n* *-------------------------------------------------------------------*\n* *  IF THERE WAS A NON-BLANK AND IT IS A QUOTE, MOVE TITLE TO\n* *  MODEL TITLE OUTPUT LINE ONE BYTE AT A TIME.\n* *-------------------------------------------------------------------*\n  IF (CLR,R1,LT,R15),AND,(CLI,0(R1),EQ,C'''')\n   LA    R1,1(,R1)                    |  POINT R1 PAST QUOTE\n   LOOP BCT                           |  LOOP FOR EACH BYTE\n*   *-----------------------------------------------------------------*\n*   *  IF WE HAVE SCANNED TO THE END OF THE TEXT AREA ON THE CARD\n*   *  AND IT IS A CONTINUATION,  READ ANOTHER CARD AND REESTABLISH\n*   *  R1 AND R15.  IF END OF FILE ON SYSIN, CONSIDER MOVE COMPLETE.\n*   *-----------------------------------------------------------------*\n    IF (CLR,R1,GE,R15)                |   IF AT END OF TEXT AREA\n     LEAVE LOOP=*,(CLI,PWACONT,EQ,X'40')   FINISHED IF NOT CONTINUATION\n     CALLSUB READ_SYSIN_AND_WRITE_SRCOUT   READ A NEW RECORD\n     LEAVE LOOP=*,(TBIT,PWAF1EOF)     |    FINISHED IF EOF\n     LA    R1,PWATEXT+16-1            |    POINT R1 TO COL 16\n     LA    R14,1                      |    REESTABLISH R14\n     LA    R15,PWATEXT+L'PWATEXT      |    REESTABLISH R15\n    ENDIF                             |   ENDIF\n*   *-----------------------------------------------------------------*\n*   *  IF NEXT CHARACTER IN INPUT RECORD IS A QUOTE, INCREMENT TO\n*   *  NEXT CHARACTER.  IF NEXT CHARACTER IS NOT A QUOTE, ASSUME\n*   *  THE MOVE IS COMPLETE EVEN IF IT IS A NON-SPACE.\n*   *-----------------------------------------------------------------*\n    IF (CLI,0(R1),EQ,C'''')           |   IF QUOTE\n     LA    R1,1(,R1)                  |    INCREMENT POINTER\n     IF (CLR,R1,GE,R15)               |    IF AT END OF CARD\n      LEAVE LOOP=*,(CLI,PWACONT,EQ,X'40')   THROUGH IF NOT CONTINUATION\n      CALLSUB READ_SYSIN_AND_WRITE_SRCOUT   READ A NEW RECORD\n      LEAVE LOOP=*,(TBIT,PWAF1EOF)    |     FINISHED IF EOF\n      LEAVE LOOP=*,(CLI,PWATEXT+16-1,NE,C'''')\n      LA    R1,PWATEXT+16-1           |     POINT R1 TO COL 16\n      LA    R14,1                     |     REESTABLISH R14\n      LA    R15,PWATEXT+L'PWATEXT     |     REESTABLISH R15\n     ELSE                             |    ELSEIF NEXT CHAR IS NOT AN\n      LEAVE LOOP=*                    |     QUOTE, LEAVE LOOP\n     ENDIF                            |    ENDIF\n    ENDIF                             |   ENDIF\n*   *-----------------------------------------------------------------*\n*   *  MOVE ONE CHARACTER TO OUTPUT AREA AND ADJUST POINTERS.\n*   *-----------------------------------------------------------------*\n    MVC   0(1,R4),0(R1)               |   MOVE A CHARACTER\n    LA    R1,1(,R1)                   |   BUMP POINTER INTO INPUT\n    LA    R4,1(,R4)                   |   BUMP POINTER INTO OUTPUT\n   ENDLOOP BCT,R5                     |  ENDLOOP\n  ENDIF                               | ENDIF\n* *-------------------------------------------------------------------*\n  ZAP   PWALNUM,=P'999'               | CAUSE TITLE TO PRINT\n  SBIT  PWAF1NOW                      | INDICATE NO WRITE\n ENDBLK BLOCK=PROCESS_TITLE           |ENDBLK\n  EJECT                               |\n**--------------------------------------------------------------------*\n**  SUBROUTINE - PROCESS_SPACE\n**\n**  IF SPACE IS OPCODE, ISOLATE NUMBER OF LINES TO SPACE AND PRINT\n**  BLANK LINES IF NECESSARY.\n**--------------------------------------------------------------------*\n BLOCK TYPE=SUBROUTINE,NAME=PROCESS_SPACE\n  L     R1,PWAAOPR                    | POINT R1 TO OPCODE FIELD\n  LA    R14,1                         | SET INCREMENT TO 1\n  LA    R15,PWATEXT+L'PWATEXT         | POINT R15 TO LAST BYTE\n  LA    R0,1                          | ASSUME ONE SPACE\n  LA    R1,5(,R1)                     | POINT R1 PAST 'SPACE'\n  LOOP  BXH,R1,R14,NAME=SCANSP        | SCAN FOR NUMBER AFTER SPACE\n   IF (CLI,0(R1),NE,X'40')            |  IF NON-BLANK FOUND\n    LR   R2,R1                        |   SAVE ADDRESS IN R2\n    LOOP BXH,R1,R14                   |   SCAN FOR NEXT BLANK\n     IF (CLI,0(R1),EQ,X'40')          |    IF NEXT BLANK FOUND\n      SLR   R1,R2                     |     CALC LENGTH OF NON-BLANKS\n      IF (CH,R1,LT,=H'3')             |     IF LENGTH < 3\n       BCTR  R1,0                     |      PACK INTO\n       EXI   R1,(PACK,PWAD,0(*-*,R2)) |      .PWAD\n      ELSE                            |     IF LENGTH >= 3\n       ZAP   PWALNUM,=P'999'          |      FORCE EJECT ON NEXT PRINT\n      ENDIF                           |     ENDIF\n      LEAVE LOOP=SCANSP               |     LEAVE SCANSP\n     ELSE                             |    ELSE IF NOT BLANK\n      LEAVE LOOP=*,                   |     JUST TAKE DEFAULT OF       $\n               (CLI,0(R1),LT,C'0'),OR,       ONE IF NON-NUMERIC        $\n               (CLI,0(R1),GT,C'9')    |      ENCOUNTERED\n     ENDIF                            |    ENDIF\n    ENDLOOP BXH                       |   ENDLOOP\n    LEAVE LOOP=SCANSP                 |   LEAVE SCANSP\n   ENDIF                              |  ENDIF\n  ENDLOOP BXH,LOOP=SCANSP             | ENDLOOP\n* *-------------------------------------------------------------------*\n* *  GENERATE SPACING\n* *-------------------------------------------------------------------*\n  LR    R2,R0                         | R2 = COUNT ON 'SPACE'\n  LEAVE BLOCK=*,(CP,PWALNUM,GT,PSDLPP)  LEAVE IF OVERFLOW\n  MVC   PWABLCC,PWALCC                | PUT BLANK LINES BASED ON\n  PUT   PWADPRT,PWABLINE              | .CC IN STATMENT LINE\n  MVI   PWALCC,X'40'                  | SET STMT LINE TO SINGLE SPACE\n  BCTR  R2,0                          | ADJUST COUNT\n  AP    PWALNUM,=P'1'                 | ADD ONE TO LINE NUMBER\n  LOOP WHILE,(TREG,R2,NZ)             | SET CC FOR NEXT LINE\n   IF (CH,R2,EQ,=H'1')                |  IF ONE SPACE\n    AP    PWALNUM,=P'1'               |   ADD 1 TO LINE NUMBER\n    MVI   PWALCC,C'0'                 |   SET CC TO DOUBLE SPACE\n    LEAVE LOOP=*                      |   LEAVE LOOP\n   ENDIF                              |  ENDIF\n   IF (CH,R2,EQ,=H'2')                |  IF TWO SPACES\n    AP    PWALNUM,=P'2'               |   ADD 2 TO LINE NUMBER\n    MVI   PWALCC,C'-'                 |   SET CC TO TRIPLE SPACE\n    LEAVE LOOP=*                      |   LEAVE LOOP\n   ENDIF                              |  ENDIF\n   AP    PWALNUM,=P'3'                |  ADD 3 TO LINE NUMBER\n   SH    R2,=H'3'                     |  SUB 3 FROM SPACING\n   LEAVE LOOP=*,(CP,PWALNUM,GT,PSDLPP)   LEAVE IF OVERFLOW\n   MVI   PWABLCC,C'-'                 |  SET CC TO TRIPLE SPACE\n   PUT   PWADPRT,PWABLINE             |  PUT 3 BLANK LINES\n  ENDLOOP WHILE                       | KEEP LOOPING IF MORE\n  SBIT  PWAF1NOW                      | INDICATE NO WRITE\n ENDBLK BLOCK=PROCESS_SPACE           |ENDBLK\n EJECT                                |\n**------------------------------------------------------------------@C4\n**  SUBROUTINE - PROCESS_SMLIST                                     @C4\n**                                                                  @C4\n**  IF SMLIST IS OPCODE, PROCESS THE LISTING OPTIONS.               @C4\n**                                                                  @C4\n**------------------------------------------------------------------@C4\n BLOCK TYPE=SUBROUTINE,NAME=PROCESS_SMLIST                          @C4\n  L     R1,PWAAOPR                    | POINT R1 TO OPCODE FIELD    @C4\n  LA    R14,1                         | SET INCREMENT TO 1          @C4\n  LA    R15,PWATEXT+L'PWATEXT         | POINT R15 TO LAST BYTE      @C4\n  LA    R0,1                          | ASSUME ONE SPACE            @C4\n  LA    R1,6(,R1)                     | POINT R1 PAST 'SMLIST'      @C4\n  LOOP  BXH,R1,R14                    | SCAN FOR NUMBER AFTER SPACE @C4\n   IF (CLI,0(R1),NE,X'40')            |  IF NON-BLANK FOUND         @C4\n    LR    R2,R15                      |   CALCULATE                 @C4\n    SLR   R2,R1                       |    REMAINING LENGHT         @C4\n    IF (CH,R2,GE,=H'11'),AND,         |   IF OPERAND IS             @C4$\n               (CLC,=C'CONVERT=YES',EQ,0(R1))  CONVERT=YES          @C4\n     SBIT  PWAF1CUP                   |    TURN CONVERSION ON       @C4\n    ELSEIF (CH,R2,GE,=H'10'),AND,     |   ELSE IF OPERAND IS        @C4$\n               (CLC,=C'CONVERT=NO',EQ,0(R1))   CONVERT=NO           @C4\n     RBIT  PWAF1CUP                   |    TURN CONVERSION OFF      @C4\n    ELSE                              |   ELSE                      @C4\n     MVC   PWALMSG,=CL27'>E-8 INVALID SMLIST STATEMENT'  ERROR      @C4\n     IF (CLI,PWAMAXRC,LT,8)           |    IF HIGHEST RC < 8        @C4\n      MVI  PWAMAXRC,8                 |     SET HIGHEST TO 8        @C4\n     ENDIF                            |    ENDIF                    @C4\n    ENDIF                             |   ENDIF                     @C4\n    LEAVE LOOP=*                      |   LEAVE LOOP                @C4\n   ENDIF                              |  ENDIF                      @C4\n  ENDLOOP BXH                         | ENDLOOP                     @C4\n ENDBLK BLOCK=PROCESS_SMLIST          |ENDBLK                       @C4\n EJECT                                |                             @C4\n**--------------------------------------------------------------------*\n**  SUBROUTINE - PROCESS_CONTINUATION_LINES\n**\n**  THIS SUBROUTINE PROCESSES CONTINUATION LINES AND ISSUES WARNING\n**  MESSAGES FOR POSSIBLE CONTINUATION ERRORS.  A POSSIBLE\n**  CONTINUATION ERROR IN WHEN COLUMN 16 OF A CONTINUATION CARD IS\n**  BLANK WHEN IT IS NOT PART OF A QUOTED STRING.\n**\n**--------------------------------------------------------------------*\n BLOCK TYPE=SUBROUTINE,NAME=PROCESS_CONTINUATION_LINES\n  L     R1,PWAAOPR                    | POINT R1 TO OPCODE FIELD\n* *-------------------------------------------------------------------*\n* *  IF NOT A CONDITIONAL ASSEMBLY STATEMENT, CHECK FOR POSSIBLE\n* *  CONTINUATION ERRORS.\n* *-------------------------------------------------------------------*\n  IF           (CLC,0(4,R1),NE,=C'AGO '),AND,                          $\n               (CLC,0(4,R1),NE,=C'AIF '),AND,                          $\n               (CLC,0(5,R1),NE,=C'GBLA '),AND,                         $\n               (CLC,0(5,R1),NE,=C'GBLB '),AND,                         $\n               (CLC,0(5,R1),NE,=C'GBLC '),AND,                         $\n               (CLC,0(5,R1),NE,=C'LCLA '),AND,                         $\n               (CLC,0(5,R1),NE,=C'LCLB '),AND,                         $\n               (CLC,0(5,R1),NE,=C'LCLC '),AND,                         $\n               (CLC,0(5,R1),NE,=C'SETA '),AND,                         $\n               (CLC,0(5,R1),NE,=C'SETB '),AND,                         $\n               (CLC,0(5,R1),NE,=C'SETC ')\n*  *------------------------------------------------------------------*\n*  *  SEARCH FOR SPACE PAST MNEUMONIC.\n*  *------------------------------------------------------------------*\n   LA    R14,1                        |  LOAD R14 WITH INCREMENT\n   LA    R15,PWATEXT+L'PWATEXT        |  POINT R15 TO BYTE AFTER TEXT\n   LOOP BXH,R1,R14                    |  SEARCH FOR BLANK\n    LEAVE LOOP=*,(CLI,0(R1),EQ,X'40') |   COMPLETE IF FOUND\n   ENDLOOP BXH                        |  END OF SEARCH\n*  *------------------------------------------------------------------*\n*  *  SCAN CHARACTER BY CHARACTER THRU RECORDS\n*  *------------------------------------------------------------------*\n   LOOP BXH,R1,R14,NAME=SCAN_RECORD   |\n*   *-----------------------------------------------------------------*\n*   *  IF A COMMA IS FOUND THAT IS FOLLOWED BY A SPACE, READ\n*   *  NEXT LINE AND IF COLUMN 16 IS BLANK, WARN OF A POSSIBLE\n*   *  ERROR.\n*   *-----------------------------------------------------------------*\n    IF (CLI,0(R1),EQ,C',')            |   IF COMMA FOUND\n     LA   R2,1(,R1)                   |    POINT R2 TO NEXT BYTE\n     IF (CLR,R2,GE,R15),OR,           |    IF END OF CARD OR SPACE     $\n               (CLI,0(R2),EQ,X'40')   |\n      CALLSUB READ_CONTINUATION_LINE  |     READ CONTINUATION\n      LEAVE LOOP=SCAN_RECORD,(TREG,R15,NZ)  LEAVE IF READ UNSUCCESSFUL\n      IF (CLI,PWATEXT+16-1,EQ,X'40')  |     IF COL 16 BLANK\n       MVC   PWALMSG(23),=C'>E-4 COLUMN 16 IS BLANK' MOVE IN ERROR MSG\n       IF (CLI,PWAMAXRC,LT,4)         |      IF MAX RETURN CODE < 4\n        MVI   PWAMAXRC,4              |       SET MAX TO 4\n       ENDIF                          |      ENDIF\n       LEAVE LOOP=SCAN_RECORD         |      STOP SCAN OF RECORD\n      ENDIF                           |     ENDIF\n      LEAVE BLOCK=*,(CLI,PWACONT,EQ,X'40')  STOP SCAN IF NOT CONTINUED\n      LA    R1,PWATEXT+16-1           |     POINT R1 TO COL 16\n      LA    R14,1                     |     REESTABLISH R14\n      LA    R15,PWATEXT+L'PWATEXT     |     REESTABLISH R15\n     ENDIF                            |    ENDIF\n    ENDIF                             |   ENDIF\n*   *-----------------------------------------------------------------*\n*   *  IF QUOTE IS FOUND THAT IS NOT PRECEEDED BY A SPECIAL CHARACTER\n*   *  OTHER THAN '&' FOLLOWED BY THE CHARACTER 'L', SEARCH FOR THE\n*   *  ENDING QOUTE.  AN ERROR IS WARNED OF IF COLUMN 71 IS A SINGLE\n*   *  QUOTE AND COLUMN 16 OF THE NEXT CARD IS A SPACE.\n*   *-----------------------------------------------------------------*\n    IF (CLI,0(R1),EQ,C'''')           |   IF QUOTE FOUND\n     LR    R2,R1                      |    POINT R2 TWO BYTES\n     SL    R2,=F'2'                   |     BEFORE CURRENT CHARACTER\n     LA    R3,=C'+-,=.*()''/ '        |    POINT R3 TO SPECIAL CHARS\n     LA    R4,11                      |    LOAD R4 WITH NUMBER OF CHARS\n     LOOP BCT                         |    CHECK TO SEE IF CHARACTER\n      LEAVE LOOP=*,(CLC,0(1,R2),EQ,0(R3))   TWO BYTES BEFORE CURRENT\n      LA    R3,1(,R3)                 |     CHARACTER IS ONE OF THE\n     ENDLOOP BCT,R4                   |     SPECIAL CHARS EXCEPT &\n     LA     R3,0                      |    ZERO R0 WITHOUT CHANGING CC\n     IF NE,OR,(CLI,1(R2),NE,C'L')     |    IF NOT SPECIAL FOLLOWED BY L\n      LOOP BXH,R1,R14                 |     SCAN FOR OTHER QUOTE\n       LA    R2,1(,R1)                |      POINT R2 TO NEXT BYTE\n       IF (CLR,R2,GE,R15)             |      IF OUT OF CHAR ON THIS LIN\n        CALLSUB READ_CONTINUATION_LINE READ CONTINUATION LINE\n        LEAVE LOOP=SCAN_RECORD,(TREG,R15,NZ) LEAVE IF READ FAILED\n        LA    R1,PWATEXT+16-1         |      POINT R1 TO COL 16\n        LA    R14,1                   |      REESTABLISH R14\n        LA    R15,PWATEXT+L'PWATEXT   |      REESTABLISH R15\n        IF (CLM,R3,B'0001',EQ,=C'''') |      IF LAST CHAR WAS QUOTE\n         IF (CLI,PWATEXT+16-1,EQ,X'40')       IF COL 16 IS BLANK\n          MVC   PWALMSG(23),=C'>E-4 COLUMN 16 IS BLANK' MOVE ERR MSG\n          IF (CLI,PWAMAXRC,LT,4)      |        IF MAX RC < 4\n           MVI   PWAMAXRC,4           |         SET MAX RC TO 4\n          ENDIF                       |        ENDIF\n         ENDIF                        |       ENDIF\n         LEAVE BLOCK=*,(CLI,PWACONT,EQ,X'40')\n         LEAVE LOOP=*,(CLI,PWATEXT+16-1,NE,C'''') LEAVE IF NOT ''\n        ELSE                          |      ELSE\n         LEAVE BLOCK=*,(CLI,PWACONT,EQ,X'40')\n         LEAVE LOOP=*,(CLI,1(R1),NE,C'''')    LEAVE IF NOT ''\n         LA    R1,1(,R1)              |       SKIP SECOND '\n        ENDIF                         |      ENDIF\n       ENDIF                          |     ENDIF\n       IC    R3,1(,R1)                |     LOAD R3 WITH NEXT BYTE\n      ENDLOOP BXH                     |    ENDLOOP\n     ENDIF                            |   ENDIF\n    ENDIF                             |  ENDIF\n*   *-----------------------------------------------------------------*\n*   *  LEAVE IF SPACE FOUND OUTSIDE OF QUOTES.\n*   *-----------------------------------------------------------------*\n    LEAVE LOOP=*,(CLI,0(R1),EQ,X'40') |\n   ENDLOOP BXH,LOOP=SCAN_RECORD       |  ENDLOOP\n  ENDIF                               | ENDIF\n* *-------------------------------------------------------------------*\n* *  EAT REST OF CONTINUATION LINES.\n* *-------------------------------------------------------------------*\n  LOOP WHILE,NOT,(TBIT,PWAF1EOF),AND, | LOOP UNTIL END OF CONTINUATION $\n               (CLI,PWACONT,NE,X'40') |  LINES\n   CALLSUB READ_CONTINUATION_LINE     |  READ A CONTINUATION LINE\n  ENDLOOP WHILE                       | ENDLOOP\n ENDBLK BLOCK=PROCESS_CONTINUATION_LINES\n EJECT                                |\n**--------------------------------------------------------------------*\n**  SUBROUTINE - READ_CONTINUATION_LINE\n**\n**  PRINT LAST LINE AND READ CONTINUATION LINE.  IF COL 1-15 IS\n**  NOT BLANK, ISSUE A WARNING.\n**--------------------------------------------------------------------*\n BLOCK TYPE=SUBROUTINE,NAME=READ_CONTINUATION_LINE\n  CALLSUB PRINT_STATEMENT_LINE        | PRINT STATEMENT LINE\n  CALLSUB READ_SYSIN_AND_WRITE_SRCOUT | GET NEXT RECORD\n  LA    R15,8                         | ASSUME 8 RETURN CODE FOR SUB\n  LEAVE BLOCK=*,(TBIT,PWAF1EOF)       | LEAVE IF END OF FILE\n  SLR   R15,R15                       | ASSUME 0 RETURN CODE FOR SUB\n  IF (CLI,PWATEXT,NE,X'40'),OR,       | IF COLUMN 1-15 IS NOT BLANK    $\n               (CLC,PWATEXT+1(15-1),NE,PWATEXT)\n   MVC   PWALMSG(26),=C'>E-4 COLUMN 1-16 NOT BLANK'\n   IF (CLI,PWAMAXRC,LT,4)             |  IF PROGRAM RETURN CODE < 4\n    MVI   PWAMAXRC,4                  |   SET PROGRAM RETURN CODE TO 4\n   ENDIF                              |  ENDIF\n  ENDIF                               | ENDIF\n ENDBLK BLOCK=READ_CONTINUATION_LINE  |\n EJECT                                |\n**--------------------------------------------------------------------*\n**  SUBROUTINE - READ_SYSIN_AND_WRITE_SRCOUT\n**\n**  READ A RECORD FROM SYSIN AND PLACE IT IN THE PWA.\n**--------------------------------------------------------------------*\n BLOCK TYPE=SUBROUTINE,NAME=READ_SYSIN_AND_WRITE_SRCOUT\n* *-----------------------------------------------------------------@C4\n* *  GET A RECORD FROM THE SYSIN FILE AND IF NOT AT END OF FILE,    @C4\n* *  PROCESS IT.                                                    @C4\n* *-----------------------------------------------------------------@C4\n  GET   PWADIN                        | GET RECORD FROM SYSIN\n  IF NOT,(TBIT,PWAF1EOF)              | IF NOT END OF FILE ON SYSIN\n*  *----------------------------------------------------------------@C4\n*  *  MAKE TWO COPIES OF THE RECORD, ONE TO ALTER AND ONE TO LEAVE  @C4\n*  *  ALONE.                                                        @C4\n*  *----------------------------------------------------------------@C4\n   MVC   PWALNE,0(R1)                 |  MOVE RECORD TO PWA\n   MVC   PWAUNALT,0(R1)               |  MOVE UNALTERED RECORD TO PW@C4\n*  *----------------------------------------------------------------@C4\n*  *  IF TRANSLATION IS ON, TRANSLATE LOWER CASE TO UPPER IF IT IS N@C4\n*  *  WITHIN A \"ED STRING.                                          @C4\n*  *----------------------------------------------------------------@C4\n   IF (TBIT,PWAF1CUP),AND,            |  IF CONVERSION IS ON        @C4$\n               (CLI,PWATEXT,NE,C'*'),AND, AND NOT COMMENT LINE      @C4$\n               (CLC,=C'.*',NE,PWATEXT)                              @C4\n    LA    R1,PWATEXT                  |   POINT R1 TO TEXT          @C4\n    LA    R14,1                       |   SET INCREMENT TO 1        @C4\n    LA    R15,L'PWATEXT+PWATEXT-1     |   POINT R15 TO TEXT         @C4\n    LOOP  BXLE                        |   LOOP THROUGH LINE         @C4\n     IF (TBIT,PWAF1QT)                |    IF WORKING ON QUOTED STNG@C4\n      IF (CLI,0(R1),EQ,C'\"')          |     IF DOUBLE QUOTE         @C4\n       RBIT  PWAF1QT                  |      RESET \"INSIDE QUOTED\"  @C4\n       MVI   0(R1),C''''              |      CHANGE TO SINGLE QUOTE @C4\n      ENDIF                           |     ENDIF                   @C4\n     ELSEIF (CLI,0(R1),EQ,C'\"')       |    ELSEIF DOUBLE QUOTE      @C4\n      SBIT PWAF1QT                    |     TURN ON \"INSIDE QUOTED\" @C4\n      MVI  0(R1),C''''                |     CHANGE TO SINGLE QUOTE  @C4\n     ELSE                             |    ELSE                     @C4\n      TR   0(1,R1),S01_TRT_TABLE      |     TRANSLATE TO UPPER      @C4\n     ENDIF                            |    ENDIF                    @C4\n    ENDLOOP BXLE,R1,R14               |   ENDLOOP                   @C4\n   ENDIF                              |  ENDIF                      @C4\n*  *----------------------------------------------------------------@C4\n*  *  IF THIS IS NOT A CONTINUED LINE AND THE QUOTED FLAG IS STILL O@C4\n*  *  CONSIDER IT AN ERROR AND TURN OFF THE FLAG.                   @C4\n*  *----------------------------------------------------------------@C4\n   IF (TBIT,PWAF1QT),AND,(CLI,PWACONT,EQ,C' ') IF UNMATCHED QUOTE   @C4\n    MVC   PWALMSG,=CL27'>E-8 ENDING QUOTE EXPECTED'  ERROR          @C4\n    IF (CLI,PWAMAXRC,LT,8)            |         SET MAX             @C4\n     MVI  PWAMAXRC,8                  |           RETURN            @C4\n    ENDIF                             |           CODE              @C4\n    RBIT  PWAF1QT                     |         RESET \"INSIDE QUOTE\"@C4\n   ENDIF                              |        ENDIF                @C4\n*  *----------------------------------------------------------------@C4\n*  *  WRITE THE MODIFIED COPY OF THE RECORD TO THE OUTPUT FILE.     @C4\n*  *----------------------------------------------------------------@C4\n   PUT   PWADOUT,PWALNE               |  PUT COPY OF RECORD IN SRCOU@C4\n  ENDIF                               | ENDIF\n ENDBLK BLOCK=READ_SYSIN_AND_WRITE_SRCOUT\n SPACE 1                              |                             @C4\n         PSD ,                        |                             @C4\nS01_TRT_TABLE DC 256AL1(*-S01_TRT_TABLE)                            @C4\n         ORG   S01_TRT_TABLE+C'a'     |                             @C4\n         DC    C'ABCDEFGHI'           |                             @C4\n         ORG   S01_TRT_TABLE+C'j'     |                             @C4\n         DC    C'JKLMNOPQR'           |                             @C4\n         ORG   S01_TRT_TABLE+C's'     |                             @C4\n         DC    C'STUVWXYZ'            |                             @C4\n         ORG   ,                      |                             @C4\n         ENDPSD ,                     |                             @C4\n EJECT                                |\n**------------------------------------------------------------------\n**  SUBROUTINE - PRINT_STATEMENT_LINE\n**\n**  IF A PAGE OVERFLOW OCCURS,  SKIP TO THE TOP OF A NEW PAGE\n**  AND PRINT NEW TITLE AND HEADING LINES.  PAGE OVERFLOW IS\n**  FORCED IN VARIOUS PARTS OF THIS PROGRAM BY SETTING CURRENT\n**  LINE NUMBER TO 999.  PRINT THE PRE-PREPARED OUTPUT LINE THEN\n**  CLEAR THE MESSAGE AREA IN THE LINE AND RESET THE CARRIAGE\n**  CONTROL TO SINGLE SPACING.\n**------------------------------------------------------------------\n BLOCK TYPE=SUBROUTINE,NAME=PRINT_STATEMENT_LINE\n  IF (CP,PWALNUM,GT,PSDLPP)           | IF PAGE OVERFLOW THEN\n   AP    PWAPGN,=P'1'                 |  ADD ONE TO PAGE NUMBER\n   MVC   PWATPGN,PSDMPGN              |  MOVE PAGE NUM MASK TO TITLE\n   ED    PWATPGN,PWAPGN               |  EDIT PAGE NUMBER INTO TITLE\n   PUT   PWADPRT,PWAT                 |  PUT TITLE LINE\n   PUT   PWADPRT,PWAH                 |  PUT HEADING LINE\n   MVI   PWALCC,C'0'                  |  NEXT LINE SHOULD DOUBLE SPACE\n   ZAP   PWALNUM,=P'5'                |  SET LINE NUMBER\n  ENDIF                               | ENDIF\n  MVC   PWALTEXT,PWAUNALT             | MOVE LINE TO OUTPUT LINE    @C4\n  PUT   PWADPRT,PWAL                  | PUT LINE\n  FILL  PWALMSG,X'40'                 | CLEAR MESSAGE\n  MVI   PWALCC,X'40'                  | RESET TO SINGLE SPACEING\n  AP    PWALNUM,=P'1'                 | ADD ONE TO LINE NUMBER\n ENDBLK BLOCK=PRINT_STATEMENT_LINE    |\n EJECT                                |\n**--------------------------------------------------------------------*\n**  SUBROUTINE - NEST\n**\n**  PARAMETERS - (CL1-TYPE)\n**\n**  THE ONE BYTE TYPE PASSED IS PUSHED ON THE NESTING STACK.  IF THE\n**  STACK DOES NOT OVERFLOW, THE CURRENT NESTING LEVEL AND A GROUP OF\n**  16 BYTE FROM SIZE DIV 16 * 16 INTO THE STACK ARE MOVED TO THE\n**  PRINT LINE.  IF THE STACK OVERFLOWS, AN ERROR MESSAGE IS MOVED TO\n**  THE MESSAGE AREA OF THE PRINT LINE AND *'S MOVED WHERE THE 16\n**  BYTES OF THE STACK WOULD HAVE BEEN MOVED.\n**--------------------------------------------------------------------*\n   SPACE 1                            |\n BLOCK NAME=NEST,TYPE=SUBROUTINE      |\n  L     R1,0(,R1)                     | POINT R1 TO ONLY PARAMETER\n  IC    R0,0(,R1)                     | INSERT TYPE PASSED IN R0\n  LH    R15,PWANSTL                   | LOAD LENGTH OF STACK\n  IF (CH,R15,LT,=Y(L'PWANSTK))        | IF STACK WILL NOT OVERFLOW\n   STC   R0,PWANSTK(R15)              |  STORE BYTE ON STACK\n   SRA   R15,4                        |  DIVIDE LENGTH BY 16\n   SLA   R15,4                        |  CALCULATE LENGTH / 16 * 16\n   LA    R15,PWANSTK(R15)             |  POINT R15 TO GROUP TO 16 BYTES\n   MVC   PWALNST,0(15)                |  MOVE GROUP TO PRINT LINE\n  ELSE                                | IF STACK OVERFLOWED\n   FILL  PWALNST,C'*'                 |  MOVE *'S TO NESTING PART OF LI\n   MVC   PWALMSG(19),=C'>E-4 STACK OVERFLOW' MOVE ERROR MESSAGE\n   IF (CLI,PWAMAXRC,LT,4)             |  IF MAX RETURN CODE < 4\n    MVI   PWAMAXRC,4                  |   MOVE 4 TO MAX RETURN CODE\n   ENDIF                              |  ENDIF\n  ENDIF                               | ENDIF\n  LH    R15,PWANSTL                   | LOAD LENGTH OF STACK\n  LA    R15,1(,R15)                   | INCREMENT\n  STH   R15,PWANSTL                   | STORE NEW LENGTH OF STACK\n  CVD   R15,PWAD                      | CONVERT NESTING DEPTH TO DEC\n  UNPK  PWALNL,PWAD                   | UNPACK INTO LINE\n  OI    PWALNL+L'PWALNL-1,X'F0'       | REMOVE SIGN\n  MVI   PWALPLS,X'40'                 | MOVE SPACE TO >16 FLAG\n  IF (CH,R15,GT,=H'16')               | IF DEPTH > 16\n   MVI   PWALPLS,C'+'                 |  MOVE PLUS SIGN TO >16 FLAG\n  ENDIF                               | ENDIF\n ENDBLK BLOCK=NEST                    |\n EJECT                                |\n**--------------------------------------------------------------------*\n**  SUBROUTINE - UNNEST\n**\n**  PARAMETERS - (CL1-TYPE)\n**\n**  THE ONE BYTE TYPE PASSED SHOULD BE EQUAL TO THE TOP ELEMENT ON THE\n**  NESTING STACK.  IF IT MATCHES, THE ELEMENT IS POPPED OFF THE\n**  STACK.  IF NOT, AN ERROR MESSAGE IS MOVED TO THE PRINT LINE.  IN\n**  BOTH CASES,  16 BYTES OF THE STACK ARE MOVE TO THE PRINT LINE AS\n**  DISCRIBED IN SUBROUTINE NEST.\n**--------------------------------------------------------------------*\n   SPACE 1                            |\n BLOCK NAME=UNNEST,TYPE=SUBROUTINE    |\n  L     R1,0(,R1)                     | POINT R1 TO ONLY PARAMETER\n  IC    R0,0(,R1)                     | INSERT TYPE PASSED IN R0\n  LH    R15,PWANSTL                   | LOAD LENGTH OF STACK\n  BCTR  R15,0                         | SUBTRACT 1\n  IF (TREG,R15,NM)                    | IF STACK HAS NOT UNDERFLOWED\n   IF (CH,R15,LT,=Y(L'PWANSTK))       |  IF STACK IS NOT IN OVERFLOW\n    LA    R1,PWANSTK(R15)             |   POINT R1 TO TO ELEMENT OF STK\n    IF (CLM,R0,B'0001',EQ,0(R1))      |   IF TOP ELEMENT IS CORRECT\n     STH   R15,PWANSTL                |    STORE NEW LENGTH OF STACK\n     CVD   R15,PWAD                   |    CONVERT NESTING DEPTH TO DEC\n     UNPK  PWALNL,PWAD                |    UNPACK INTO LINE\n     OI    PWALNL+L'PWALNL-1,X'F0'    |    REMOVE SIGN\n     MVI   PWALPLS,X'40'              |    MOVE SPACE TO >16 FLAG\n     IF (CH,R15,GT,=H'16')            |    IF DEPTH > 16\n      MVI   PWALPLS,C'+'              |     MOVE PLUS SIGN TO >16 FLAG\n     ENDIF                            |    ENDIF\n     MVI   0(R1),X'40'                |    BLANK OUT OLD ELEMENT\n     BCTR  R15,0                      |    SUB 1 FROM R15\n     SRA   R15,4                      |    DIVIDE LENGTH BY 16\n     SLA   R15,4                      |    CALCULATE LENGTH / 16 * 16\n     IF M                             |    IF NEGATIVE\n      LA    R15,0                     |     SET R15 TO ZERO\n     ENDIF                            |    ENDIF\n     LA    R15,PWANSTK(R15)           |    POINT R15 TO 16 BYTE GROUP\n     MVC   PWALNST,0(15)              |    MOVE GROUP TO PRINT LINE\n    ELSE                              |   IF TOP ELEMENT NOT CORRECT\n     MVC   PWALMSG(20),=C'>E-8 NESTING PROBLEM' MOVE ERROR MESSAGE\n     IF (CLI,PWAMAXRC,LT,8)           |    IF MAX RC < 8\n      MVI   PWAMAXRC,8                |     SET MAX RC TO 8\n     ENDIF                            |    ENDIF\n    ENDIF                             |   ENDIF\n   ELSE                               |  IF STACK IS STILL OVERFLOWED\n    STH   R15,PWANSTL                 |   SAVE NEW LENGTH OF STACK\n    CVD   R15,PWAD                    |   CONVERT NESTING DEPTH TO DEC\n    UNPK  PWALNL,PWAD                 |   UNPACK INTO LINE\n    OI    PWALNL+L'PWALNL-1,X'F0'     |   REMOVE SIGN\n   ENDIF                              |  ENDIF\n  ELSE                                | IF STACK WILL UNDERFLOW\n   MVC   PWALMSG(22),=C'>E-8 NESTING UNDERFLOW' MOVE ERROR MESSAGE\n   IF (CLI,PWAMAXRC,LT,8)             |  IF MAX RETURN CODE < 8\n    MVI   PWAMAXRC,8                  |   MOVE 8 TO MAX RETURN CODE\n   ENDIF                              |  ENDIF\n  ENDIF                               | ENDIF\n ENDBLK BLOCK=UNNEST                  |\n EJECT                                |\n**--------------------------------------------------------------------*\n**  ERREXIT (UNNAMED)\n**\n**  WTO ERROR MESSAGE BASED ON CODE IN R14\n**\n**--------------------------------------------------------------------*\n   SPACE 1                            |\n BLOCK TYPE=ERREXIT                   |ERREXIT (UNNAMED)\n  MVC   PWAOPNER,PSDOPNER             | MOVE WTO LIST FORM TO PWA\n  CASEBLK REG=R14                     | MOVE DDNAME FAILING TO WTO MSG\n  CASE 0                              | CASE 0\n   MVC   PWAEDDN,=CL8'SYSIN'          |  SYSIN DATASET OPEN ERROR\n  CASE 1                              | CASE 1\n   MVC   PWAEDDN,=CL8'SYSPUNCH'       |  SYSPUNCH DATASET OPEN ERROR\n  CASE 2                              | CASE 2\n   MVC   PWAEDDN,=CL8'SYSPRINT'       |  SYSPRINT DATASET OPEN ERROR\n  ENDCASE                             | ENDCASE\n  WTO   MF=(E,PWAOPNER)               | USE WTO TO ISSUE MESSAGE\n  LA    R15,16                        | SET BASE RETURN CODE\n ENDBLK ,                             |ENDBLK\n         TITLE 'PROGRAM STATIC DATA'  |\n         PSD                          |\nPSDOPNER WTO   'ERROR OPENING DDNAME=........',MF=L,ROUTCDE=11\nPSDEDDN  EQU   PSDOPNER+4+21,8,C'C'   | TAG FOR DDNAME\nPSDOPNER_LENGTH EQU *-PSDOPNER        | LENGTH OF WTO LIST FORM\n         SPACE 1                      |\nPSDMTME  DC    X'402120',C':',X'2020' | MASK FOR TIME\nPSDMDTE  DC    X'402120',C'.',X'202020' MASK FOR DATE\nPSDMPGN  DC    X'402020202120'        | MASK FOR PAGE\n         SPACE 1                      |\nPSDLPP   DC    PL2'60'                | MAXIMUM LINES PER PAGE\n         SPACE 1                      |\n*        TITLE LINE\nPSDT     DC    CL137' '               | TITLE LINE 1\n         ORG   PSDT                   | ORG TO START OF TITLE LINE\n         DC    AL2(137)               | LENGTH OF LINE\n         DC    AL2(0)                 |\n         DC    C'1'                   | SKIP TO TOP OF PAGE\nPSDTID   DC    CL8' '                 | ID FROM TITLE\n         DC    C' '                   | SPACE\nPSDTDTA  DC    CL100' '               | DATA FROM TITLE STATEMENT\n         DC    CL12' '                | TIME\n         DC    C' PAGE'               | C'PAGE'\nPSDTPGN  DC    CL6' '                 | PAGE NUMBER\n         ORG   ,                      |\n         SPACE 1                      |\n*        HEADING LINE\nPSDH     DC    CL137' '               | PRINT LINE\n         ORG   PSDH                   | ORG TO START OF LINE\n         DC    AL2(137)               |\n         DC    AL2(0)                 |\n         DC    C'-'                   | CC\n         DC    CL3'LVL'               | NESTING DEPTH\n         DC    C' '                   | SPACE\n         DC    C'+'                   | PLUS SIGN IF DEEPER THAN 16\n         DC    CL16'    NESTING     ' | NESTING INFO\n         DC    C'  '                  |\n         DC    CL80' SOURCE STATEMENT'  TEXT OF LINE\n         DC    C'  '                  |\n         DC    C'MSC0150$ V1R4 '      | PROGRAM VERSION AND RELEASE @C4\nPSDHTME  DC    CL6' '                 | TIME\nPSDHDTE  DC    CL7' '                 | DATE\n         ORG   ,                      |\n         SPACE 1                      |\n*        LINE\nPSDL     DC    CL137' '               | PRINT LINE\n         ORG   PSDL                   | ORG TO START OF LINE\n         DC    AL2(137)               |\n         DC    AL2(0)                 |\nPSDLCC   DC    C' '                   | CC\nPSDLNL   DC    CL3' '                 | NESTING LEVEL\n         DC    C' '                   | SPACE\nPSDLPLS  DC    C' '                   | PLUS SIGN IF DEEPER THAN 16\nPSDLNST  DC    CL16' '                | NESTING INFO\n         DC    C' |'                  |\nPSDLTEXT DC    CL80' '                | TEXT OF LINE\n         DC    C'| '                  |\nPSDLMSG  DC    CL27' '                | MESSAGE\n         ORG   ,                      |\n         SPACE 1                      |\n*        BLANK LINE USED IN SPACING\nPSDBLINE DC    AL2(6),AL2(0)          | BLANK LINE\nPSDBLCC  DC    C' '                   | CC\n         DC    C' '                   | BLANK FOR BLANK LINE\nPSDBLINE_LENGTH EQU *-PSDBLINE        | LENGTH OF BLANK LINE\n         SPACE 1                      |\n*        NOT AT LEVEL ZERO ERROR MESSAGE\nPSDERLVL DC    AL2(45),AL2(0),C'0>E-8 ENDING STRUCTURAL LEVEL IS NON-ZE$\n               RO'                    |\n         SPACE 1                      |\n*        LITERAL POOL                                               @C4\n         LTORG ,                      |                             @C4\n         SPACE 1                      |                             @C4\nPSDOPN3  OPEN  (*,,*,,*),MF=L         |\nPSDOPN3_LENGTH EQU *-PSDOPN3          |\n         SPACE 3                      |\nPSDDIN   DCB   DDNAME=SYSIN,MACRF=GL,EODAD=EODADIN,DSORG=PS\nPSDDIN_LENGTH EQU *-PSDDIN            |\n         SPACE 3                      |\nPSDDOUT  DCB   DDNAME=SYSPUNCH,MACRF=PM,LRECL=80,DSORG=PS,RECFM=FB\nPSDDOUT_LENGTH EQU *-PSDDOUT          |\n         SPACE 3                      |\nPSDDPRT  DCB   DDNAME=SYSPRINT,MACRF=PM,LRECL=137,                     $\n               RECFM=VBA,DSORG=PS     |\nPSDDPRT_LENGTH EQU *-PSDDPRT          |\n         SPACE 3                      |\n         ENDPSD ,                     |                             @C4\n         TITLE 'DSECTS'               |\n         PUSH  PRINT                  |\n         PRINT NOGEN                  |\n         DCBD  DSORG=PS               |\n         POP   PRINT                  |\n         SPACE 3                      |\n         TITLE 'PROGRAM WORK AREA'    |\n         PWA                          |\nPWAD     DS    D                      | WORK DOUBLE WORD\nPWAAOPR  DS    A                      | ADDRESS OF OPERATION FIELD\nPWAF1    DS    BL1                    | BIT FLAG\nPWAF1EOF EQU   B'10000000'            |   END OF FILE ON SYSIN\nPWAF1NOW EQU   B'01000000'            |   DO NOT WRITE\nPWAF1QT  EQU   B'00100000'            |   INSIDE OF A QUOTED STRING @C4\nPWAF1CUP EQU   B'00010000'            |   CONVERT TO UPPER IS ON    @C4\nPWALNUM  DS    PL2                    | LINE NUMBER (TITLES FIRST TIME)\nPWAPGN   DS    PL3                    | PAGE NUMBER\nPWAMNL   DS    PL3                    | MACRO NESTING LEVEL\nPWAMAXRC DS    X                      | MAXIMUM RETURN CODE\nPWANSTK  DS    CL256                  | NESTING STACK\nPWANSTL  DS    H                      | DISP OF NEXT ELEMENT ON STACK\n*        INPUT LINE\nPWALNE   DS    0CL80                  | INPUT LINE\nPWATEXT  DS    CL71                   | LINE TEXT\nPWACONT  DS    C                      | CONTINUE\n         DS    CL8                    | LINE NUMBER\n*        TITLE LINE\nPWAT     DS    CL(L'PSDT)             | TITLE LINE 1\nPWATID   EQU   PWAT+PSDTID-PSDT,L'PSDTID,C'C'      SEE PSDTID\nPWATDTA  EQU   PWAT+PSDTDTA-PSDT,L'PSDTDTA,C'C'    SEE PSDTDTA\nPWATPGN  EQU   PWAT+PSDTPGN-PSDT,L'PSDTPGN,C'C'    SEE PSDTPGN\n*        HEADING LINE\nPWAH     DS    CL(L'PSDH)             | HEADING LINE\nPWAHTME  EQU   PWAH+PSDHTME-PSDH,L'PSDHTME,C'C'    SEE PSDHTME\nPWAHDTE  EQU   PWAH+PSDHDTE-PSDH,L'PSDHDTE,C'C'    SEE PSDHDTE\n*        UNALTERED LINE                                             @C4\nPWAUNALT DS    CL80                   | UNALTERED PRINT LINE        @C4\n*        LINE\nPWAL     DS    CL(L'PSDL)             | PRINT LINE\nPWALCC   EQU   PWAL+PSDLCC-PSDL,L'PSDLCC,C'C'      SEE PSDLCC\nPWALNL   EQU   PWAL+PSDLNL-PSDL,L'PSDLNL,C'C'      SEE PSDLNL\nPWALPLS  EQU   PWAL+PSDLPLS-PSDL,L'PSDLPLS,C'C'    SEE PSDLPLS\nPWALNST  EQU   PWAL+PSDLNST-PSDL,L'PSDLNST,C'C'    SEE PSDLNST\nPWALTEXT EQU   PWAL+PSDLTEXT-PSDL,L'PSDLTEXT,C'C'  SEE PSDLTEST\nPWALMSG  EQU   PWAL+PSDLMSG-PSDL,L'PSDLMSG,C'C'    SEE PSDLMSG\n*        BLANK LINE USED IN SPACING\nPWABLINE DS    CL(PSDBLINE_LENGTH)    | BLANK LINE\nPWABLCC  EQU   PWABLINE+PSDBLCC-PSDBLINE,L'PSDBLCC SEE PSDBLCC\n*        ERROR WTO STORAGE\n         DS    0F                     | INSURE FULLWORD ALIGNMENT\nPWAOPNER DS    CL(PSDOPNER_LENGTH)    |\nPWAEDDN  EQU   PWAOPNER+PSDEDDN-PSDOPNER           SEE PSDEDDN\n*        DCB STORAGE\n         DS    0F                     | INSURE FULLWORD ALIGNMENT\nPWAOPN3  DS    XL(PSDOPN3_LENGTH)     |\n         DS    0D                     | INSURE DOUBLEWORD ALIGNMENT\nPWADIN   DS    XL(PSDDIN_LENGTH)      |\n         DS    0D                     | INSURE DOUBLEWORD ALIGNMENT\nPWADOUT  DS    XL(PSDDOUT_LENGTH)     |\n         DS    0D                     | INSURE DOUBLEWORD ALIGNMENT\nPWADPRT  DS    XL(PSDDPRT_LENGTH)     |\n         ENDPWA ,                     |\n         END     ,                    |\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STGMAP": {"ttr": 1290, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98$\\x0f\\x00\\x98$\\x0f\\x13 \\x016\\x016\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-08-28T00:00:00", "modifydate": "1998-08-28T13:20:00", "lines": 310, "newlines": 310, "modlines": 0, "user": "CLEMSON"}, "text": "//MSC0195$ JOB (H2803302,S08,,4),'STORAGE MAP',REGION=1M,TIME=(,4)\n//  EXEC ASMPCL,PDS='CAREY.LOAD',NAME=MSC0195$\n//P.SYSIN DD *\n         TITLE 'STGMAP -- Display Major MVS/XA Virtual Storage Areas.'\n*---------------------------------------------------------------------*\n*\n*  CSECT NAME: STGMAP\n*\n*     PURPOSE: DISPLAYS WHERE MAJOR MVS/XA VIRTUAL STORAGE AREAS\n*              BEGIN AND END.\n*\n*  ATTRIBUTES: ENTRY AND EXIT IN AMODE(24): AMODE(31) EXCEPT WHEN\n*              USING QSAM SERVICES.\n*              NON-REENTRANT, UNAUTHORIZED, PROBLEM STATE AND KEY.\n*\n*     Warning: This module contains lowercase text. Use caution\n*              when editing.\n*\n*     HISTORY:  11/8/85 -- JCB -- ORIGINALLY WRITTEN\n*\n*---------------------------------------------------------------------*\n         SPACE 1                      |\n         MACRO ,                      |\n&TAG     GENTAG &TEXT                 |\n         AIF   ('&TAG' EQ '').BADTAG  |\n&TAG     DS  X                        |\n#GT&SYSNDX  DC  C&TEXT                |\n         ORG   &TAG                   |\n         DC    AL1(L'#GT&SYSNDX.)     |\n         ORG ,                        |\n         MEXIT ,                      |\n.BADTAG  MNOTE 8,'GENTAG REQUIRES A LABEL.'\n         MEND ,                       |\n         SPACE 1                      |\n BLOCK         NAME=STGMAP,           |                                *\n               TYPE=PROGRAM,          |                                *\n               OPTIONS=(*NORENT,XA,MODE), Turn on AMODE support        *\n               AMODE=24,              | AMODE on entry                 *\n               SMWA=STCSMWA           | SMWA for AMODE switching\n         SPACE 1                      |\n  OPEN  (SYSPRINT,(OUTPUT))           | get something to write with\n  IF    (TREG,R15,NZ)                 | if sysprint dd is missing\n   ABEND 1                            |  figure it out: you're a\n  ENDIF                               |   system programmer.\n  BLOCK NAME=PROCESS,AMODE=31         | Switch to amode(31)\n   FILL  STCLINE,C' '                 |\n   CALLSUB SIMPLE_PRINT               | write blank line\n   MVC   STCTAG(L'STCHDRA),STCHDRA    |\n   MVC   STCDASH(L'STCHDRB),STCHDRB   |\n   CALLSUB SIMPLE_PRINT               | write header line\n   FILL  STCTAG,C' ',LENGTH=L'STCHDRA |\n   FILL  STCDASH,C'-'                 | write top of the 'box'\n   MVI   STCBAR1,C'|'                 |\n   MVI   STCBAR2,C'|'                 |\n   MVI   STCBAR3,C'|'                 |\n   CALLSUB SIMPLE_PRINT               | write header line\n   FILL  STCLINE,C' '                 |\n         SPACE 1                      |\n   L     R10,CVTPTR                   | base on cvt\n   USING CVT,R10                      |\n   L     R9,CVTSMEXT                  | base on 1st cvt extension\n   USING CVTVSTGX,R9                  |\n   L     R8,CVTGDA                    | base on gda. it's amode(31)\n   USING GDA,R8                       | get how big private area is:\n   L     R1,GDAECSA                   |  get a(ext. csa start)\n   AL    R1,GDAECSAS                  |  add its size\n   ST    R1,STCF                      |  that's it.\n   CALLSUB     PRINT_LINE,            | print ext. private stuff       *\n               (STCEPA,STCF,=X'7FFFFFFF'),  (assume top is 7fffffff)   *\n               PL=(STCPL,12)          |\n         SPACE 1                      |\n   L     R1,GDAECSA                   | get the start\n   ST    R1,STCF                      | save for amode 24 code\n   AL    R1,GDAECSAS                  | add its size\n   BCTR  R1,0                         | make it print 'xxxxfff' addr\n   ST    R1,STCF+4                    | save that too\n   CALLSUB     PRINT_LINE,            | print ext. csa numbers         *\n               (STCECSA,STCF,STCF+4), |                                *\n               PL=(STCPL,12)          |\n         SPACE 1                      |\n   IF    (CLC,CVTEMLPS,NE,=F'0')      | if there's some extended\n    CALLSUB    PRINT_LINE,            |  mlpa around, print that.      *\n               (STCEMLPA,CVTEMLPS,CVTEMLPE),                           *\n               PL=(STCPL,12)          |\n   ENDIF                              |\n   CALLSUB     PRINT_LINE,            | print eflpa numbers            *\n               (STCEFLPA,CVTEFLPS,CVTEFLPE),                           *\n               PL=(STCPL,12)          |\n   CALLSUB     PRINT_LINE,            | print eplpa numbers            *\n               (STCEPLPA,CVTEPLPS,CVTEPLPE),                           *\n               PL=(STCPL,12)          |\n         SPACE 1                      |\n   L     R1,GDAESQA                   | get where it starts\n   ST    R1,STCF                      | stuff for amode 24 code\n   AL    R1,GDAESQAS                  | add its length\n   BCTR  R1,0                         | make it print xxxxfff address\n   ST    R1,STCF+4                    | stuff\n   CALLSUB     PRINT_LINE,            | print esqa numbers             *\n               (STCESQA,STCF,STCF+4), |                                *\n               PL=(STCPL,12)          |\n         SPACE 1                      |\n   CALLSUB     PRINT_LINE,            | print extended read/write      *\n               (STCERWN,CVTERWNS,CVTERWNE),  nucleus numbers           *\n               PL=(STCPL,12)          |\n   CALLSUB     PRINT_LINE,            | print read-only nucleus        *\n               (STCRON,CVTRONS,CVTRONE),     numbers. note this is     *\n               PL=(STCPL,12)          |    what straddles 16m.\n   CALLSUB     PRINT_LINE,            | print read/write nuc below     *\n               (STCRWN,CVTRWNS,CVTRWNE),     16m numbers.              *\n               PL=(STCPL,12)          |\n         SPACE 1                      |\n   L     R1,GDASQA                    |  get start address\n   ST    R1,STCF                      |  save for amode(24) code\n   AL    R1,GDASQASZ                  |  add ending address\n   BCTR  R1,0                         |  make it print xxxxfff addr\n   ST    R1,STCF+4                    |  save that too\n   CALLSUB     PRINT_LINE,            | print sqa numbers.             *\n               (STCSQA,STCF,STCF+4),  |                                *\n               PL=(STCPL,12)          |\n         SPACE 1                      |\n   CALLSUB     PRINT_LINE,            | print plpa numbers             *\n               (STCPLPA,CVTPLPAS,CVTPLPAE),                            *\n               PL=(STCPL,12)          |\n   CALLSUB     PRINT_LINE,            | print flpa numbers             *\n               (STCFLPA,CVTFLPAS,CVTFLPAE),                            *\n               PL=(STCPL,12)          |\n   IF    (CLC,CVTMLPAS,NE,=F'0')      | if there's any mlpa around\n    CALLSUB    PRINT_LINE,            |  print its stuff too.          *\n               (STCMLPA,CVTMLPAS,CVTMLPAE),                            *\n               PL=(STCPL,12)          |\n   ENDIF                              |\n         SPACE 1                      |\n   L     R1,GDACSA                    |  get start address\n   ST    R1,STCF                      |  save for later.\n   LR    R5,R1                        |  save another copy.\n   AL    R1,GDACSASZ                  |  add length\n   BCTR  R1,0                         |  make it print xxxxfff addr\n   ST    R1,STCF+4                    |  stuff.\n   CALLSUB     PRINT_LINE,            | print csa numbers              *\n               (STCCSA,STCF,STCF+4),  |                                *\n               PL=(STCPL,12)          |\n         SPACE 1                      |\n   BCTR  R5,0                         | knock 1 off top of csa\n   ST    R5,STCF                      | stuff for parmlist\n   CALLSUB     PRINT_LINE,            | print private area numbers     *\n               (STCPA,=F'4096',STCF), |                                *\n               PL=(STCPL,12)          |\n   CALLSUB     PRINT_LINE,            | print psa size for the         *\n               (STCPSA,=F'0',=F'4095'),  hell of it                    *\n               PL=(STCPL,12)          |\n   FILL  STCLINE,C' '                 | blank line\n   CALLSUB SIMPLE_PRINT               | write blank line\n   MVC   STCLINE(L'TX1),TX1           | print messages about how\n   CALLSUB SIMPLE_PRINT               |  to use csa value to see if\n   MVC   STCLINE(L'TX2),TX2           |   csa growth is about to munch\n   CALLSUB SIMPLE_PRINT               |    another 1M segment.\n   MVC   STCLINE(L'TX3),TX3           |\n   CALLSUB SIMPLE_PRINT               |\n   FILL  STCLINE,C' '                 | final blank line\n   CALLSUB SIMPLE_PRINT               | write blank line\n  ENDBLK BLOCK=PROCESS                | end of amode 31 mainline\n  CLOSE (SYSPRINT)                    | close up and quit.\n ENDBLK BLOCK=STGMAP,RC=0             |\n         TITLE 'STGMAP -- Print a detail line'\n*---------------------------------------------------------------------*\n*\n*  SUBROUTINE: PRINT_LINE\n*     PURPOSE: WRITE A DETAIL LINE ABOUT AN AREA OF VIRTUAL STORAGE\n*       INPUT: ON ENTRY, R1 POINTS TO ADDRESSES OF:\n*                .. A(TAG TEXT)  -- INCLUDING LENGTH BYTE\n*                .. A(AREA START) - WHERE SAID AREA BEGINS\n*                .. A(AREA END)  -- WHERE SAID AREA STOPS\n*      OUTPUT: DETAIL LINE WRITTEN TO SYSPRINT WITH ABOVE INFORMATION,\n*              ALONG WITH SIZE OF AREA IN DECIMAL K.\n*\n*---------------------------------------------------------------------*\n         SPACE 1                      |\n BLOCK       NAME=PRINT_LINE,         |                                *\n               TYPE=SUBROUTINE,       |                                *\n               SAVE=(R0,R15,STCSAVE), |                                *\n               AMODE=24               |\n  LM    R2,R4,0(R1)                   | load up parms\n  FILL  STCLINE,C' '                  | wipe printline\n  MVC   STCTAG,STCDOTS                | lay some dots in tag area\n  MVI   STCBAR1,C'|'                  | put the bars in\n  MVI   STCBAR2,C'|'                  |\n  MVI   STCBAR3,C'|'                  |\n  L8    R1,0(R2)                      | get length of tag\n  BCTR  R1,0                          |  minus 1 for execute\n  EXI   R1,(MVC,STCTAG(0),1(R2))      | move in tag\n  LR    R1,R3                         | point r1 at start address\n  CALLSUB CONVERT_HEX                 | convert to printable hex\n  MVC   STCVAL1,STCUNPK               | move out starting value\n  LR    R1,R4                         | point r1 at end address\n  CALLSUB CONVERT_HEX                 | convert it too\n  MVC   STCVAL2,STCUNPK               | move out to printline.\n  L     R1,0(R4)                      | get end address value\n  SL    R1,0(R3)                      | subtract starting address\n  AL    R1,=F'1023'                   | round up 1k-1\n  SRL   R1,10                         | divide by 1024\n  CVD   R1,STCD                       | make it packed\n  MVC  STCVAL3,=XL9'402020202020202120' lay out edit mask\n  ED    STCVAL3,STCD+4                | make pretty decimal number\n  MVI   STCVAL3+L'STCVAL3,C'K'        | hang a k on it\n  PUT   SYSPRINT,STCLINE              |  and print it.\n ENDBLK BLOCK=PRINT_LINE              |\n         TITLE 'STGMAP -- Simple print subroutine'\n*---------------------------------------------------------------------*\n*\n*  ON ENTRY, STCLINE CONTAINS TEXT TO BE WRITTEN TO SYSPRINT.\n*\n*  THE ONLY REASON THIS IS A SUBROUTINE IS TO ALLOW THE MAIN PORTION\n*  OF STGMAP TO RUN AMODE 31.\n*\n*---------------------------------------------------------------------*\n BLOCK       NAME=SIMPLE_PRINT,       |                                *\n               TYPE=SUBROUTINE,       |                                *\n               SAVE=(R14,STCR14),     |                                *\n               AMODE=24               |\n  PUT   SYSPRINT,STCLINE              |\n ENDBLK BLOCK=SIMPLE_PRINT            |\n         TITLE 'STGMAP -- Hex-EBCDIC value converter'\n*---------------------------------------------------------------------*\n*\n*  ON ENTRY, R1 -> A FULLWORD VALUE TO CONVERT.\n*  ON EXIT, STCUNPK(8) WILL CONTAIN THE EDITED EBCDIC EQUIVALENT.\n*  NO REGISTERS ARE SAVED: R1 AND R15 ARE DESTROYED.\n*\n*---------------------------------------------------------------------*\n BLOCK NAME=CONVERT_HEX,TYPE=SUBROUTINE\n  UNPK  STCUNPK(9),0(5,R1)            | unpack 1r%\n  TR    STCUNPK(8),STCHEXTR           | 'fa' -> 'c1', etc\n  LA    R1,STCUNPK                    | eat the zeros off the front:\n  LA    R15,L'STCUNPK-1               | make sure we can leave one\n  LOOP  BCT                           | loop thru result:\n   LEAVE LOOP=*,(CLI,0(R1),NE,C'0')   |  nonzero? quit.\n   MVI   0(R1),C' '                   |  blank it out\n   LA    R1,1(R1)                     |  next one\n  ENDLOOP BCT,R15                     | go thru all but last one.\n ENDBLK BLOCK=CONVERT_HEX             |\n*\nSTCLINE  DC    CL80' '                |\nSTCTAG   EQU   STCLINE+2,26           |\nSTCDASH  EQU   STCLINE+30,44          |\nSTCBAR1  EQU   STCLINE+29             |\nSTCVAL1  EQU   STCLINE+33,8           |\nSTCBAR2  EQU   STCLINE+46             |\nSTCVAL2  EQU   STCLINE+51,8           |\nSTCBAR3  EQU   STCLINE+61             |\nSTCVAL3  EQU   STCLINE+63,9           |\n         SPACE 1                      |\nSTCHDRA  DC    C'MVS/XA Virtual Storage Map'\nSTCHDRB  DC    C'  Start Address |  End Address | Size in K'\nSTCDOTS  DC    C' . . . . . . . . . . . . .'\n         SPACE 1                      |\nTX1 DC C'    To determine the amount of storage available in common sto*\n               rage'                  |\nTX2 DC C'    below 16M before another 1M segment is allocated, subtract*\n                the'                  |\nTX3 DC C'    first CSA= value in IEASYS00 from the CSA size value shown*\n                here.'                |\n         SPACE 1                      |\nSTCEPA   GENTAG 'Extended Private Area '\nSTCECSA  GENTAG 'Extended CSA '       |\nSTCEMLPA GENTAG 'Extended MLPA '      |\nSTCEFLPA GENTAG 'Extended FLPA '      |\nSTCEPLPA GENTAG 'Extended PLPA '      |\nSTCESQA  GENTAG 'Extended SQA '       |\nSTCERWN  GENTAG 'Extended R/W Nucleus '\nSTCRON   GENTAG 'Read-Only Nucleus '  |\nSTCRWN   GENTAG 'Read-Write Nucleus ' |\nSTCSQA   GENTAG 'System Queue Area '  |\nSTCPLPA  GENTAG 'Pageable LPA '       |\nSTCFLPA  GENTAG 'Fixed LPA '          |\nSTCMLPA  GENTAG 'Modified LPA '       |\nSTCCSA   GENTAG 'Common Storage Area '\nSTCPA    GENTAG 'Private Area '       |\nSTCPSA   GENTAG 'Prefixed Save Area ' |\n         SPACE 1                      |\nSTCSAVE  DS    16F                    |\nSTCSMWA  DS    2F                     |\nSTCR14   DS    F                      |\n         SPACE 1                      |\n         DS    0D                     |\nSTCF     DS    0F                     |\nSTCD     DS    D                      |\n         SPACE 1                      |\nSTCPL    DS    3F                     |\n         SPACE 1                      |\nSYSPRINT DCB DDNAME=SYSPRINT,LRECL=80,RECFM=FB,BLKSIZE=6160,           *\n               DSORG=PS,MACRF=PM      |\n         SPACE 1                      |\nSTCUNPK  DS    CL8,C                  |\n         DC    C'0123456789ABCDEF'    |\n         ORG   *-256                  |\nSTCHEXTR DS    CL256                  |\n         ORG   ,                      |\n         LTORG                        |\n         PRINT NOGEN                  |\nCVTMAP   CVT   DSECT=YES              |\n         IHAGDA                       |\n         PRINT GEN                    |\n         END   ,                      |\n//C.SYSLIB DD\n//         DD\n//         DD DSN=SYS1.AMODGEN,DISP=SHR\n//L.SYSIN  DD *\n ALIAS STGMAP                         |\n NAME MSC0195$(R)                     |\n//\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "USERDOCP": {"ttr": 1542, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98$\\x0f\\x00\\x98$\\x0f\\x13 $\\xa1$\\xa1\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-08-28T00:00:00", "modifydate": "1998-08-28T13:20:00", "lines": 9377, "newlines": 9377, "modlines": 0, "user": "CLEMSON"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT108/FILE108.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT108", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}