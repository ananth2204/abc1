{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012711000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 764218, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 12, "INMDSNAM": "CBT.V500.FILE742.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 764218, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 764218, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE742.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x0e\\x02'", "DS1TRBAL": "b'\\xcaF'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x05\\x0b\\x00\\x05\\x05\\x0c\\x00\\x04\\x00\\x0f'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04O\\x00\\x10\\x01\\x10\\x02O\\x01\\x10\\x02O\\x157\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf9@@@'", "ispf": {"version": "04.79", "flags": 0, "createdate": "2010-01-24T00:00:00", "modifydate": "2010-01-24T15:37:10", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-479"}, "text": "REGULAR CBT TAPE - VERSION 479    FILE:  742\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT479.FILE742\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 38 MEMBERS COUNTED; CUMULATIVE SIZE IS 6,897 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   01/24/10    15:37:10    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$DATFRM": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x06\\x08_\\x01\\x06\\x08_\\x11\\x12\\x01\\xc7\\x01\\xc7\\x00\\x00\\xd4\\xe2\\xe6\\xd6\\xd9\\xc4@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2006-03-26T00:00:00", "modifydate": "2006-03-26T11:12:00", "lines": 455, "newlines": 455, "modlines": 0, "user": "MSWORD"}, "mimetype": "application/msword", "datatype": "binary", "extension": ".doc"}, "$$NOTE1": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x18\\x01\\x06\\x08O\\x01\\x10\\x01?\\x14I\\x00&\\x00)\\x00\\x00\\xc8\\xf2\\xf2\\xf4@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2006-03-25T00:00:00", "modifydate": "2010-01-13T14:49:18", "lines": 38, "newlines": 41, "modlines": 0, "user": "H224"}, "text": "Subject:     'Archive' source versioning system\nFrom:        \"Bob Birdsall\" <bsquare@med.umich.edu>\nDate:        Wed, 22 Mar 2006 08:01:55 -0500  (updated 13 Jan 2010)\nTo:          <sbgolob@cbttape.org>\n\nHi.  'Archive' is a source versioning system for ISPF Edit/View.\n\nIt is in the early stages of development (it works, but...  :)\nThe documentation members all begin with #.\nEverything else begins with A#.\n\nWe do use this for SYS1.PARMLIB, SYS1.TCPPARMS and other\ndatasets, but there are only 4 z/OS system programmers in my\nshop.\n\nWe do not use this for application source code, yet.  It needs\nsome more work (and management acceptance) first.\n\nThe only warning I would like to give those to whom this is\ndistributed follows:\n\nNOTE: all these rexx execs, etc. are SAMPLES ONLY.  Any\nexperimentation with them is at your own risk.  Do not trust your\ndata/processes to them without personally verifying all logic and\noperation.  All supplied execs are works in progress and DO\ncontain bugs and significant undocumented limitations.\n\nI hope you enjoy this.\n\n=================================================================\nBob Birdsall, Systems Programmer/Support     bsquare@umich.edu\nUniversity of Michigan                       Tue-Fri, 0700-1700\nMedical Center Information Technology        Phone (734) 936-2148\nArbor Lakes Building, 4251 Plymouth Rd.      FAX   (734) 763-0629\nAnn Arbor, MI  48105\nBuilding 3, Floor 3, Suite 3300\n=================================================================\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$PGMDSC": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x06\\x08_\\x01\\x06\\x08_\\x11\\x12\\x01\\xb4\\x01\\xb4\\x00\\x00\\xd4\\xe2\\xe6\\xd6\\xd9\\xc4@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2006-03-26T00:00:00", "modifydate": "2006-03-26T11:12:00", "lines": 436, "newlines": 436, "modlines": 0, "user": "MSWORD"}, "mimetype": "application/msword", "datatype": "binary", "extension": ".doc"}, "#CONFIG": {"ttr": 777, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x05\"/\\x01\\x05\"/\\x08\\x13\\x00\\x05\\x00\\x05\\x00\\x00\\xc8\\xf2\\xf2\\xf4@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2005-08-10T00:00:00", "modifydate": "2005-08-10T08:13:00", "lines": 5, "newlines": 5, "modlines": 0, "user": "H224"}, "text": "/* ISPF Configuration entries.                                        */\n/*   Include these entries in your own configuration member.          */\n/*   Create the ISPCFIGU load module using TSO ISPCCONF.              */\nMEMBER_LIST_LINE_COMMAND_COMMAND_EXIT       = A#CMDCK\nSITE_WIDE_INITIAL_MACRO                     = A#INIT\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "#CPARC": {"ttr": 779, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x14\\x00\"\\x01\\t\\t\\x8f\\x01\\x10\\x01?\\x126\\x00\\x14\\x01)\\x00\\x00\\xc8\\xf2\\xf2\\xf4@@@@@@'", "ispf": {"version": "01.20", "flags": 0, "createdate": "2009-04-08T00:00:00", "modifydate": "2010-01-13T12:36:22", "lines": 20, "newlines": 297, "modlines": 0, "user": "H224"}, "text": "//CPARC    PROC\n//*\n//* Copy a PDS member to an archive\n//*------------------------------------------------------------\n//*\n//*\n//* Update the member(s)\n//COPY     EXEC PGM=IKJEFT01,PARM='ISPSTART CMD(%A#CPARC)'\n//SYSEXEC  DD DISP=SHR,DSN=PUBLIC.ARCHIVE.SOURCE\n//SYSTSIN  DD DUMMY\n//SYSTSPRT DD SYSOUT=*\n//ISPPROF  DD DISP=(NEW,PASS),DSN=&&PROFILE,DSORG=PO,LRECL=80,RECFM=FB\n//ISPTLIB  DD DISP=SHR,DSN=ISP.SISPTENU\n//ISPTABL  DD DISP=(OLD,DELETE),VOL=REF=*.ISPPROF,DSN=&&PROFILE\n//ISPLOG   DD SYSOUT=*,LRECL=125,BLKSIZE=129,RECFM=VB\n//ISPPLIB  DD DISP=SHR,DSN=ISP.SISPPENU\n//ISPMLIB  DD DISP=SHR,DSN=ISP.SISPMENU\n//ISPSLIB  DD DISP=SHR,DSN=ISP.SISPSENU\n//OLDDD    DD DDNAME=SOURCE\n//NEWDD    DD DDNAME=TARGET\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "#DESC": {"ttr": 781, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\"\\x01\\x05$\\x9f\\x01\\x10\\x01?\\x13R\\x00R\\x007\\x00\\x00\\xc8\\xf2\\xf2\\xf4@@@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2005-09-06T00:00:00", "modifydate": "2010-01-13T13:52:22", "lines": 82, "newlines": 55, "modlines": 0, "user": "H224"}, "text": "Archive program description:\nThe purpose of the archive application is to facilitate maintaining\nprevious versions of edited source PDS members (and sequential\ndatasets) 'transparently'.  It is intended for source (text) datasets\nand PDSs only, and handles only ISPF edit as a means of altering\ndatasets and members.\n\nIts benefits are:\nUses ISPF edit to update source data - no new editing to learn, new\nfeatures accrue with ISPF.\nArchive creation, deletion, and backup are simple and efficient using\nstandard z/OS utilities.\nIt is possible to archive any source dataset* that we control update of\n- e.g. SYS1.PARMLIB.\nBoth source and control datasets are standard datasets or PDSs - they\ncan be SMS managed, archived, etc.\nAn archive control PDS can constitute a complete PDS backup - recovery\nof the source PDS can be as simple as copying the archive control PDS\ninto it.\nIt can also maintain a 'Last Known Working Member' - a backup of a\nmember as of its last known 'good' version.  This is useful for datasets\nlike SYS1.IPLPARM and SYS1.PARMLIB, where the system may be unavailable\nto restore a member to a previous version, but an alternate member can\nbe specified for the IPL.\nWe own the source code - alterations and improvements are at our\ndiscretion.\n\nIts detriments are:\nIt is neither bulletproof nor foolproof - Use of utilities other than\nISPF edit to alter source or control dataset contents will affect the\nintegrity of the archive.  The source may or may not be recoverable.\nIt acts to facilitate a source control convention, it does not enforce\nit.  Archives can be intentionally bypassed or altered to affect (or\neffect) an apparent history which is bogus.  In order for archiving to\nwork, anyone having update access to a source dataset must also have\nupdate access to the archive control dataset.\n\nAdditional available commands while editing an archived source:\nCOMPARE vers     - compare the currently edited source to a previous\n                   version\nHISTORY | HIST   - display a table of all of the available versions of\n                   this source\n                 - from the table, you can display the history entry\n                   or view a specific version\nOPTIONS | OPTS   - set Dataset or Member options for an archive\nRESTORE vers     - restore the currently edited source to a previous\n                   version\nVIEW vers        - view a previous version of the edited source\n\nwhere vers = {\u00ddv\u00a8VV.MM} or {-N}\n      VV and MM can be 1 or 2 digits that specify the absolute\n      version.  N is a non-zero whole number that specifies how\n      many versions to go back (e.g. -1 is the previous version).\n      Thus, if the archive consists of versions 01.03,01.12,02.05,02.06\n      where 2.06 is the currently edited version,\n      COMPARE -2 will compare the current version with v01.12 and\n      RESTORE v1.3 will restore the member to v01.03.\n\n*Restrictions on datasets that can be archived:\nDatasets must be editable by ISPF edit - DSORG PS or PO, RECFM F or V\n(not U).\nFor source datasets with a separate control dataset, the target DSN must\nbe 40 characters or less.\nThe source dataset can not end with '.ARC'.\nFor PDS targets which are their own control, LRECL must be at least 80\n(84 for RECFM V).\n\nAdditional available ISPF PDS member list commands:\nH                - Same as HISTORY, above\nO                - Same as OPTIONS, above\n\nFuture features that should be implemented:\nThe external data editing commands CREATE, MOVE and REPLACE commands\nshould be DEFINEd to allow checking for creating, deleting or\noverwriting archives regardless of whether they are used in an archived\ndataset or not.\nThe BuiltIn, Define, Stats, Version and Level commands should be DEFINEd\nto deny inappropriate usage.\nAn option should be provided to drop versions of edited data more than a\ncertain age or number of versions.\nA utility should be provided to allow the user to change the data\ndescription, and perhaps to set/change an archive description.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "#DETAIL": {"ttr": 1025, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00\\x13\\x01\\x05$\\x9f\\x01\\t\\x12\\x7f\\x11\\x19\\x00~\\x004\\x00\\x00\\xc8\\xf2\\xf2\\xf4@@@@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "2005-09-06T00:00:00", "modifydate": "2009-05-07T11:19:13", "lines": 126, "newlines": 52, "modlines": 0, "user": "H224"}, "text": "NOTE: If you are modifying the code, you should be aware of some Rexx\n      tricks I use.  See the TRICKS section of this member for more\n      details.\n\nImplementation details:\nThe archive application consists of 2 ISPF configuration options and a\nPDS of rexx execs and ISPF panels.\nThe ISPF configuration options are:\nMEMBER_LIST_LINE_COMMAND_COMMAND_EXIT       = A#CMDCK\nSITE_WIDE_INITIAL_MACRO                     = A#INIT\nThese options are in source PDS member #CONFIG.\n\nThe a#CmdCk, a#Init and a#Open rexx programs MUST exist in a PDS that\nis in every TSO user's SYSPROC or SYSEXEC concatenation.  The other\narchive application rexx execs and ISPF panels can either be in the same\nPDS or in another PDS that will be dynamically allocated during edit\nsessions.\nIf the a#CmdCk exec cannot be found, you will not be able to use ISPF\nsingle character line commands on any member lists.  Archiving will\nstill be in effect for edit sessions.\nIf the a#Init edit macro cannot be found, you will get an error every\ntime you enter ISPF edit or view and archiving will not be in effect.\na#Open is used by both a#CmdCk and a#Init and will cause problems with\narchives if it cannot be found.\n\nThese are the rexx execs that currently make up the archive\napplication:\na#Can   - Terminate ISPF Edit sessions - undo a#Init.\n          CANCEL is aliased to this macro.\na#CmdCk - Validate ISPF member list single character built-in commands.\n          Alter rename and delete requests to maintain archive integrity.\n          Allow O (Options) and H (History) from member lists.\na#Cmp   - Allow COMPARE against previous versions of the data.\n          COMPARE is aliased to this macro.\na#cpArc - Copy members from a Source to a Target archive in batch.\n          Use the #CPARC job to execute this.\na#End   - Call a#Save if required and terminate ISPF Edit sessions like\n          CANCEL.  Undoes a#Init just like a#Can.\n          END is aliased to this macro.\na#Info  - Get archive information for execs which are not run as edit\n          macros.  May open an ARCnn table, which the caller needs to\n          close.\na#Init  - Initialize ISPF Edit sessions:\n          Allocate rexx and panel libraries, if necessary.\n          Define SAVE, END and CANCEL, COMPARE and VIEW as macros (not\n          built-in).\n          Define macro aliases HIST/HISTORY and OPTS/OPTIONS.\n          Create or open and initialize tables used in the application.\n          These tables are closed by a#End and a#Can.\na#Make  - Used internally to create a 'temporary' dataset with a\n          previous version of the data.\na#Open  - Used internally to resolve and open the archive control\n          dataset for a member.\na#Opt   - Set the options for a dataset or member.\n          OPTS and OPTIONS are aliased to this macro.\n          a#CmdCk calls this for member list command O.\na#Opts  - Used internally to parse options strings.\na#Rest  - Restore a previous version (an alias of Restore is provided by\n          a#Init).\n          RESTORE is aliased to this macro.\na#Save  - Save the currently edited data, maintaining archived versions.\n          SAVE is aliased to this macro.\na#Touch - Exec to be used in foreground or batch to set the date and\n          time that a member was last known to be working correctly.\na#VHist - Display version history.\n          Allow a user to view a previous version of the edited data.\n          HIST and HISTORY are aliased to this macro.\n          a#CmdCk calls this for member list command H.\na#View  - View a previous version of the edited data.\n          VIEW is aliased to this macro.\n\nThese are the ISPF panels that are part of the archive application:\na#DescP - Data entry panel to create or modify the dataset (member)\n          description.\na#DHistP- Display panel to show a specific version's history (change)\n          information.\na#HistP - Data entry panel to create or modify a version's history\n          (change description).\na#OptDP - Data entry panel to modify the dataset options.\na#OptMP - Data entry panel to modify the member options.\na#VersP - Table display panel to show or select dataset (member)\n          versions.\n\nIn addition,\n#cpArc    is JCL that can be used to run a#cpArc in batch.\n#TouchJb  is JCL that can be used to run a#Touch in batch.\n\nTRICKS:\n   Initializing variables\n      To set multiple variables in one statement, I use\n      parse VALUE a b c... WITH Var1 Var2 Var3 ...\n      If I am setting all the variables to '', I use\n      parse VALUE WITH VarX,VarY,VarZ ...\n      If I want to set SOME variables to values, and others to '', I use\n      parse VALUE expression WITH VarA VarB,EmptyA,EmptyB\n      I might also use parse VAR a VarA VarB,Empty1,Empty2...\n      Anything after the 1st comma gets a null ('') value.\n      NOTE that this is NOT the case for parse ARG.\n      I might occasionally parse the output of a function\n      parse VALUE FuncA(parm1,parm2) WITH RC Var1...\n   Formatting\n      To format an expression, I use\n      new = Translate(OutputFormat,old,InputFormat)\n      like this: nDate = Translate('1234/56/78',Date('S'),'12345678')\n      which would set nDate to '2005/09/15'\n      if Date('S') returns '20050915'.\n      The characters in the InputFormat MUST be unique.\n      Read the TSO-E Rexx Reference manual Built-in Functions/Translate\n      description for more information.\n   ISPF and ISPF edit\n      I use both the ISPF &variable notation and the ISPF Edit\n      (variable) notation to reference the value of a variable.\n      So  \"LMClose DataID(&DataID)\" is the same as\n          \"LMClose DataID(\"DataID\")\"\n      and \"LINE_AFTER\" i-1 \"= (Cur)\" is like\n          \"LINE_AFTER\" i-1 \"= '\"Cur\"'\"\n      In the LINE_AFTER case, (Cur) will work properly even\n      if Cur contains the character '.\n   Value()\n      The statement\n      call Value oType,Value(oType) v||'('Val')'\n      is equivalent to\n      interpret oType '=' oType \"v||'('Val')'\"\n      Thus, if oType is 'MEMBER', v is 'Hist' and Val is 'no', then\n      the expression evaluates to:\n      MEMBER = MEMBER 'Hist'||'(no)'\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "#FORMAT": {"ttr": 1028, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00 \\x01\\x10\\x01?\\x01\\x10\\x01?\\x137\\x00\\xb8\\x00\\x14\\x00\\x00\\xc8\\xf2\\xf2\\xf4@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2010-01-13T00:00:00", "modifydate": "2010-01-13T13:37:20", "lines": 184, "newlines": 20, "modlines": 0, "user": "H224"}, "text": "Archive dataset format:\n\nKey:\nKeywords are not case sensitive.\nVariable data is retained as entered.\nData enclosed in \u00dd\u00a8 is optional, and the \u00dd\u00a8 characters are not part of\nthe format.\nArchive members are broken into sections similar to ISPF panels.\nEach section begins with a ')' character in column 1, followed by the\nsection type.\nA section may contain header and data lines.\nIf it has header or data lines, it will describe the number of header\nand data lines in the section line.\nFor instance,\n)Section Header(5) Data(7) Property(variable data)\nwould describe a section of type Section containing 5 header and 7 data\nlines.\nThe entire section would then be 13 lines - the )Section line, 5 header\nlines and 7 data lines.\nThe next section (if any) would immediately follow.\nAll header lines begin with a '-' in column 1.\nData lines may or may not begin with a '-' depending on the type of\ndata.\nSection and Header lines are limited to 80 characters maximum.\nData lines may be as long as the data being archived.\n\nIn section and header description lines, all variable data is enclosed\nin parentheses, which are required.\n\nThe format of the parenthesized data is:\n#      decimal number, may be preceded by the number of digits expected,\n       otherwise free form\nname   a name following standard conventions\ntext   free form text, may be preceded by a maximum number of characters\nbool   boolean (yes or no) data.  omitting the data in parentheses is\n       the same as YES.\n       omitting the keyword completely is the same as NO.\n       0 = YES, 1 = NO.\nother  any characters not described above are as written\n\nIn a PDS archive:\nMember names containing or ending with a '{' character are reserved for\narchive use.\nEven if the archive is a separate PDS, data members must not contain or\nend with '{'.\n\nZ{PARMS{ member - describes archive.\nThere are no header or data lines in the Z{PARMS{ member.\nAny number of lines, format follows:\n)Opts Hist(#|bool) NoArc(bool) NoSync(bool) Desc(bool) Quiet(bool) Limit(#)\n)Resolve ID(4#)\n\nThe )Opts line declares archive-wide options.  You may have as many as\n      required.\n      Hist is how many versions of history to display on open.\n      NoArc displays a warning if no archive data is present for source\n      data.\n      NoSync displays a warning if edited data is out-of-sync with\n      archive control data.\n      Desc displays the data description on open.\n      Limit is a limit on the number of versions to keep (not yet\n      implemented).\n      All options are optional.\n      Quiet or Quiet(yes) is the same as\n       Hist(0) NoArc(no) NoSync(no) Desc(no).\n      Hist or Hist(yes) is the same as Hist(1),\n      Hist(no) is the same as Hist(0).\nThe )Resolve line defines the highest used 4 digit contention ID,\n      described below.\n      There can only be 1 )Resolve line.  ID is required.\n\nIf the member name is less than 7 characters, the archive member is the\nmember name followed by a '{' character.\nFor example, if the data member is 'BACKUP', the archive member is\n'BACKUP{'.\nIf the data member name is 8 characters, the last character is replaced\nby '{'.\nThus, the archive member for data member 'PSSU$MAP' would be 'PSSU$MA{'.\nThis has the potential for name contention, however, since the archive\nmember for 'PSSU$MAT' is also 'PSSU$MA{'.  In fact, the archive member\nfor 'PSSU$MA' is ALSO 'PSSU$MA{'.\nIn cases like this, the \"natural\" archive member (e.g. 'PSSU$MA{') is\nused as a \"contention\" member.\nThe contention member contains one line:\n)Resolve ID(4#)\n\nThe actual archive member name is then formed from the contention ID,\nlike 'Z{'+ID+x+'{', where ID is the 4 digit contention ID and x is the\n8th character of the member name.\nFor example, if the contention ID for 'PSSU$MAx' is 1032, the archive\nmember for 'PSSU$MAP' would be 'Z{1032P{', and the archive member for\n'PSSU$MA' would be 'Z{1032{'.\n\nIn a sequential archive, the member naming issues described above are\nnot relevant.\n\nIn all archives the archive dataset or member MUST begin with a\n)Current section.\nThe )Current section description line's format is:\n)Current \u00ddHeader(#)\u00a8 \u00ddData(#)\u00a8 \u00ddMember(name)\u00a8\n\nThe Header property is a number indicating how many header lines\nimmediately follow.  All header lines are optional.\nThe possible header lines are:\n-Stats \u00ddVersion(2#.2#)\u00a8 \u00ddUser(name)\u00a8 \u00ddModified(4#/2#/2# 2#:2#:2#)\u00a8\n-Opts Hist(#|bool) NoArc(bool) NoSync(bool) Desc(bool) Quiet(bool) Limit(#)\n-Desc (60text)\n-Hist (60text)\n\nThe -Stats line will almost always exist, and describes the statistics\nof the current state of the member or dataset.\nIt will not exist if the member previously existed without stats, is\nnewly archived, and has not been updated after archiving.\nThe -Opts line is identical to the )Opts section of the Z{PARMS{ member.\nThere may be as many as 6 -Desc lines.  This is a description of this\narchived dataset or member.\nThe -Hist line will only exist for a deleted member.  It describes the\ndeletion.\n\nThe Data property is a number indicating how many data lines follow the\nheader lines.  It is used for sequential archives and archives of\ndeleted members in a PDS.  The data lines are the most current contents\nof the data member or dataset.\n\nThe Member property is the name of the member being archived.  It is\nused during member name contention resolution.  It is required for PDS\narchives and not used for sequential archives.\n\nFollowing the )Current section there may be any number (perhaps limited\nby the Limit option) of )Archive sections.\nThe )Archive section description line's format is:\n)Archive \u00ddHeader(#)\u00a8 \u00ddData(#)\u00a8\n\nThe Header property is a number indicating how many header lines\nimmediately follow.  All header lines are optional.\nThe possible header lines are:\n-Stats \u00ddVersion(2#.2#)\u00a8 \u00ddUser(name)\u00a8 \u00ddModified(4#/2#/2# 2#:2#:2#)\u00a8\n-Hist (60text)\n\nThe -Stats line will almost always exist, and describes the statistics\nfor this version of the member or dataset.\nIt will not exist if the member previously existed without stats and has\nbeen updated with history after archiving.\nThere may be as many as 6 -Hist lines.  This is a description of the\nchanges made to this version of the archived dataset or member.\n\nThe Data property is a number indicating how many data lines follow the\nheader lines.\nThe data lines describe how to regress the member from the version\ndescribed immediately before it to the version being described.  For\ninstance, in the archive fragment below,\n)Current Header(2) Member(BIRTHS)\n-Stats Version(07.05) User(NOAH) Modified(2075/12/31 23:59:59)\n-Desc (Keep track of birth dates)\n)Archive Header(2) Data(...)\n-Stats Version(01.12) User(DUMMY) Modified(1963/08/24 11:32:51)\n-Hist (Bob was born)\n...\n)Archive Header(2) Data(...)\n-Stats Version(01.11) User(OLDDUMMY) Modified(1927/10/30 11:32:51)\n-Hist (Ted was born)\n...\n\nthe data lines described in the 2nd )Archive section describe how to\nregress the member BIRTHS from version 01.12 back to 01.11.\n\nThe data lines consist of -Del lines and -Ins lines (with the data to be\ninserted).\nThe format of a -Del line is:\n-Del Count(#) Start(#)\n\nwhere the Count property is how many lines to delete and the Start\nproperty is the 1st line to delete.  Line numbers are ISPF edit\nrelative line numbers - that is, they start at 1 and are numbered\nsequentially to the end of the data set or member.\n\nThe format of a -Ins line group is:\n-Ins Lines(#) Start(#)\nLines lines of data\n\nwhere the Lines property is how many lines of data to insert (these\nlines immediately follow the -Ins line) and the Start property is the\nline number the 1st inserted data line will have after insertion.  Line\nnumbers are ISPF edit relative line numbers.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "#HISTORY": {"ttr": 1032, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00@\\x01\\x10\\x01?\\x01\\x10\\x01?\\x12G\\x00\\x0b\\x00\\x07\\x00\\x00\\xc8\\xf2\\xf2\\xf4@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2010-01-13T00:00:00", "modifydate": "2010-01-13T12:47:40", "lines": 11, "newlines": 7, "modlines": 0, "user": "H224"}, "text": "v102:\n-  Allow O (Options) and H (History) line commands from member lists.\n-  Fixed a bug with recursive edit/view (table failure on exit).\n-  Fixed a bug with exiting with '=x' (looping, high CPU).\n-  Added the #CPARC job to copy archive members in batch.\n-  Allow Opts and Hist short-forms for Options and History commands.\n-  Use new ISPF \"MACRO_MSG = ON\" feature to display edit messages\n   for builtin commands.\n-  Exclude HFS/ZFS files from archive processing (can't handle them).\n-  miscellaneous other minor fixes.\nv101: First public version, added to CBT472 as File #742.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "#INSTALL": {"ttr": 1034, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x03\\x000\\x01\\x05$\\x9f\\x01\\x10\\x01?\\x128\\x00'\\x00$\\x00\\x00\\xc8\\xf2\\xf2\\xf4@@@@@@\"", "ispf": {"version": "01.03", "flags": 0, "createdate": "2005-09-06T00:00:00", "modifydate": "2010-01-13T12:38:30", "lines": 39, "newlines": 36, "modlines": 0, "user": "H224"}, "text": "In the install PDS:\nThe member #CONFIG contains definitions needed for ISPF customization.\nCopy this member into your site ISPF customization PDS member (for us,\nthis is 'OS390.MAINT.CONFIG.Z110(ISPFCFG)'.  You will use this to build\nan ISPF configuration module.\n\nFrom an ISPF command line, type 'TSO ISPCCONF'.\n   This will bring up the ISPF Configuration Utility.\nPut your configuration dataset and member in the Keyword File Data Set\nsection.\nSelect option 3, Verify Keyword Table Contents.\n   You should get the message 'Keyword file verified' in the upper right.\nSelect option 4, Build Configuration Table Load Module.\n   Verify that the 'Input Keyword File Data set' is the same as used\n   above, and select an Output Configuration Table Load Module Data Set.\n   I would suggest putting this in a dataset that is NOT in the\n   LPA/Link/Joblib/Steplib/ISPLLib search sequence for now.\nPress Enter to generate the load module.\n   It will be named ISPCFIGU.\n\nAlter your logon PROC/CList/Exec to allocate the install PDS to SYSEXEC\nand ISPPLIB.\nNow either alter the above to allocate your ISPF configuration module\ndataset to ISPLLIB, or copy ISPCFIGU from your configuration module\ndataset to a library in the search concatenation.\nFor example - to add this to MCIT's #SYSTSO5 proc, you would edit\nSYS2.PROD.TSO5.ISRPRIM.Z110(ISPFTSO) to add PUBLIC.ARCHIVE.SOURCE to\nSYSEXEC and ISPPLIB.  If you put the ISPCFIGU module into\nPUBLIC.ARCHIVE.LOAD, you would add that to ISPLLIB in the same dataset.\nIf you added ISPCFIGU to the Link list, you will need to refresh it.\n\nYou should now be able to log on to your TSO proc, and use Archive.\nI use an alias PUBLIC.ARCHIVE.SOURCE which points at the current\nversion, e.g. PUBLIC.ARCHIVE.V102.SOURCE to simplify upgrades.\n\nNOTE:  Every TSO user that will get the ISPCFIGU module you created MUST\nhave the ARCHIVE.SOURCE PDS in their SYSEXEC and ISPPLIB concatenations.\nOtherwise they will get failures using ISPF member list line commands\nand ISPF edit/view.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "#TOUCHJB": {"ttr": 1036, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00R\\x01\\x05$\\x9f\\x01\\x10\\x01?\\x126\\x00\\x13\\x00\\x18\\x00\\x00\\xc8\\xf2\\xf2\\xf4@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2005-09-06T00:00:00", "modifydate": "2010-01-13T12:36:52", "lines": 19, "newlines": 24, "modlines": 0, "user": "H224"}, "text": "//TOUCHJOB JOB 0200,'archive',MSGCLASS=X,CLASS=X,NOTIFY=&SYSUID\n//*\n//* Touch the members of an archive.\n// SET SOURCE=SYS1.PARMLIB\n// SET LIB=PUBLIC.ARCHIVE.SOURCE\n//*\n//* Touch\n//TOUCH    EXEC PGM=IKJEFT01,PARM='ISPSTART CMD(%A#TOUCH)'\n//SYSEXEC  DD DISP=SHR,DSN=&LIB\n//ISPPROF  DD DISP=(NEW,PASS),DSN=&&PROFILE,LRECL=80,RECFM=FB,DSORG=PO\n//ISPTLIB  DD DISP=SHR,DSN=ISP.SISPTENU\n//ISPTABL  DD DISP=(OLD,DELETE),DSN=&&PROFILE,VOL=REF=*.ISPPROF\n//ISPLOG   DD SYSOUT=*,LRECL=125,BLKSIZE=129,RECFM=VB\n//ISPPLIB  DD DISP=SHR,DSN=ISP.SISPPENU\n//ISPMLIB  DD DISP=SHR,DSN=ISP.SISPMENU\n//ISPSLIB  DD DISP=SHR,DSN=ISP.SISPSENU\n//SYSTSIN  DD DUMMY\n//SYSTSPRT DD SYSOUT=*\n//ARCHIVE  DD DISP=SHR,DSN=&SOURCE\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE742": {"ttr": 1038, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04O\\x00X\\x01\\x10\\x02O\\x01\\x10\\x02O\\x156\\x00+\\x00+\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf9@@@'", "ispf": {"version": "04.79", "flags": 0, "createdate": "2010-01-24T00:00:00", "modifydate": "2010-01-24T15:36:58", "lines": 43, "newlines": 43, "modlines": 0, "user": "CBT-479"}, "text": "//***FILE 742 is from Bob Birdsall and contains a source code       *   FILE 742\n//*           versioning system that works for PARMLIB and other    *   FILE 742\n//*           system level datasets such as TCPPARMS.               *   FILE 742\n//*                                                                 *   FILE 742\n//*           email:  \"Bob Birdsall\" <bsquare@med.umich.edu>        *   FILE 742\n//*                                                                 *   FILE 742\n//*     Hi.  'Archive' is a source versioning system for ISPF       *   FILE 742\n//*     Edit/View.                                                  *   FILE 742\n//*                                                                 *   FILE 742\n//*     It is in the early stages of development (it works,         *   FILE 742\n//*     but...  :)                                                  *   FILE 742\n//*     The documentation members all begin with #.                 *   FILE 742\n//*     Everything else begins with A#.                             *   FILE 742\n//*                                                                 *   FILE 742\n//*     Documentation members are:                                  *   FILE 742\n//*        #CONFIG  - ISPF configuration data                       *   FILE 742\n//*        #CPARC   - Job to copy archive members                   *   FILE 742\n//*        #DESC    - Overview of the system                        *   FILE 742\n//*        #DETAIL  - Detailed information                          *   FILE 742\n//*        #FORMAT  - Data format used for the archives             *   FILE 742\n//*        #HISTORY - Revision history                              *   FILE 742\n//*        #INSTALL - Installation instructions                     *   FILE 742\n//*        #TOUCHJB - update Last Known Working Member's time       *   FILE 742\n//*                                                                 *   FILE 742\n//*     We do use this for SYS1.PARMLIB, SYS1.TCPPARMS and          *   FILE 742\n//*     other datasets, but there are only 3 z/OS system            *   FILE 742\n//*     programmers in my shop.                                     *   FILE 742\n//*                                                                 *   FILE 742\n//*     We do not use this for application source code, yet.        *   FILE 742\n//*     It needs some more work (and management acceptance).        *   FILE 742\n//*                                                                 *   FILE 742\n//*     The only warning I would like to give those to whom         *   FILE 742\n//*     this is distributed follows:                                *   FILE 742\n//*                                                                 *   FILE 742\n//*     NOTE: all these rexx execs, etc. are SAMPLES ONLY.  Any     *   FILE 742\n//*     experimentation with them is at your own risk.  Do not      *   FILE 742\n//*     trust your data/processes to them without personally        *   FILE 742\n//*     verifying all logic and operation.  All supplied execs      *   FILE 742\n//*     are works in progress and DO contain bugs and               *   FILE 742\n//*     significant undocumented limitations.                       *   FILE 742\n//*                                                                 *   FILE 742\n//*     I hope you enjoy this.                                      *   FILE 742\n//*                                                                 *   FILE 742\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "A#CAN": {"ttr": 1040, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00\\x04\\x01\\x05\\x19?\\x01\\t\\x18?\\x15T\\x00\\x14\\x00\\x0c\\x00\\x00\\xc8\\xf2\\xf2\\xf4@@@@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "2005-07-12T00:00:00", "modifydate": "2009-07-02T15:54:04", "lines": 20, "newlines": 12, "modlines": 0, "user": "H224"}, "text": "/* Rexx program to end an edit session, archiving as necessary.\n*  Usage: Install using #CONFIG.\n*  This will close the tables opened by a#Init.\n*.\n*. 2005/07/12 Created by bsquare\n*/\naddress ISREdit\n\"Macro\"\n\"(Vol) = VOLUME\"\n\"(DSN) = DATASET\"\n\"(Mem) = MEMBER\"\nArcKey = Vol':'DSN'('Mem')'\naddress ISPExec\n\"TBGet archive\"\n\"TBEnd\" ArcTbl\n\"TBDelete archive\"       /* delete this archive entry */\n\"TBClose archive\"\n/* \"LIBDEF ISPPLIB\" */\n/* address TSO \"AltLib DEACTIVATE APPLICATION(EXEC)\" */\naddress ISREdit \"BuiltIn CANCEL\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "A#CMDCK": {"ttr": 1042, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01 \\x00(\\x01\\x05\"/\\x01\\t\\x12\\x7f\\t\\x10\\x01\\n\\x00\\xad\\x00\\x00\\xc8\\xf2\\xf2\\xf4@@@@@@'", "ispf": {"version": "01.32", "flags": 0, "createdate": "2005-08-10T00:00:00", "modifydate": "2009-05-07T09:10:28", "lines": 266, "newlines": 173, "modlines": 0, "user": "H224"}, "text": "/* Rexx ISPF exit */\n/* exit 0 uses ISPF processing.  exit 8 skips ISPF processing. */\narg Cmd . \"'\" DSN '(' Mem ')' . VolSer Tail\nif Pos(Cmd,'DHOR') = 0 then exit 0\nif Cmd = 'H' then do\n   call a#vHist SubWord(arg(1),2)\n   exit 8\nend\nif Cmd = 'O' then do\n   call a#Opt SubWord(arg(1),2)\n   exit 8\nend\nif Right(Mem,1) = '{' then exit 0\nif Right(DSN,4) = '.ARC' then exit 0\nDT = Date('D')*86400+Time('S')\naddress ISPExec\n\"VGet (MCMDDSN) SHARED\"\nif RC = 0 then do\n   if Word(MCMDDSN,1) = VolSer':'DSN then do\n      oDT = Word(MCMDDSN,2)\n      if DT = oDT then exit 0\n      else if (DT - oDT) <= 10 then do\n         MCMDDSN = oDSN DT\n         \"VPut (MCMDDSN) SHARED\"\n         exit 0\n      end\n   end\nend\nIsCat = ListDSI(\"'\"DSN\"'\") = 0\nif IsCat then IsCat = (SysVolume = VolSer)\nif IsCat then Vol = ''\nelse Vol = ' VOLUME('VolSer')'\nSysDSOrg = 'BAD'\nArcDSN = DSN'.ARC'\nif Length(ArcDSN) <= 44 then call ListDSI \"'\"ArcDSN\"'\"||Vol\nif Left(SysDSOrg,2) <> 'PO' then ArcDSN = DSN\nArcMem = Strip(Left(Mem,7))'{'\n\n\"VGet (ZTERM)\"\nif ZTerm <> '3278' & ZTerm <> '3278A' then\n   \"Select Pgm(ISPTTDef) Parm(3278)\"\n\"LMInit DataID(DID) DataSet('\"ArcDSN\"')\"Vol \"ENQ(SHRW)\"\n\"LMOpen DataID(&DID)\"\n\"LMMFind DataID(&DID) Member(Z{PARMS{)\"\nzParms = (RC = 0)\nif ArcDSN = DSN & zParms = 0 then do           /* No archive dataset */\n   MCMDDSN = VolSer':'DSN DT\n   \"VPut (MCMDDSN) SHARED\"\n   signal Quit\nend\nArcCopy = 0\nif ArcDSN <> DSN then do\n   \"LMMFind DataID(&DID) Member(&Mem)\"\n   ArcCopy = (RC = 0)\nend\n\"LMMFind DataID(&DID) Member(&ArcMem)\"\nif RC = 0 then\n  \"LMGet DataID(&DID) Mode(INVAR) MaxLen(80) DataLoc(Data) DataLen(Len)\"\nif RC <> 0 then IsArc = 0\nelse do\n   parse UPPER VAR Data 2 Type Info\n   if Type = 'CURRENT' then do\n      parse VAR Info 'MEMBER('aMem')'\n      if aMem = Mem then IsArc = 1\n      else do\n         IsArc = 0\n         ArcMem = ''\n      end\n   end; else do\n      parse VAR Info 'ID('ConID')'\n      ArcMem = 'Z{'Right(ConID,4,0)||SubStr(Mem,8)||'{'\n      \"LMMFind DataID(&DID) Member(&ArcMem)\"\n      IsArc = (RC = 0)\n   end\nend\nif Left(Tail,1) = '*' then Tail = ''\nSelect\nWhen Cmd = 'R' then do\n   if IsArc = 0 & ArcCopy = 0 then signal Quit\n   if Tail <> '' then parse VAR Tail UDARen .\n   else do\n      address ISPExec\n      UDMSMem = Mem\n      \"AddPop\"\n      \"Display Panel(ISRUREN)\"\n      RV = RC\n      \"RemPop\"\n      if RV <> 0 then signal Done\n   end\n   /* If not archived, do this the simple way */\n   if IsArc = 0 then do\n      \"LMClose DataID(&DID)\"\n      \"LMOpen DataID(&DID) Option(OUTPUT)\"\n      \"LMMRen DataID(&DID) Member(&Mem) NewName(&UDARen)\"\n      \"LMClose DataID(&DID)\"\n      \"LMFree DataID(&DID)\"\n      \"LMInit DataID(DID) DataSet('\"DSN\"')\"Vol \"Enq(SHRW)\"\n      \"LMOpen DataID(&DID) Option(OUTPUT)\"\n      \"LMMRen DataID(&DID) Member(&Mem) NewName(&UDARen)\"\n      signal Done\n   end\n   address TSO\n   \"Alloc f(in) dsn('\"ArcDSN\"(\"ArcMem\")')\"Vol \"SHR REUSE\"\n   \"ExecIO * DiskR in (STEM Arc. FINIS\"\n   \"Free f(in)\"\n   ms = 'MEMBER('                /* string to look for */\n   lp = Pos(ms,Translate(Arc.1))\n   if lp <> 0 then ms = SubStr(Arc.1,lp,Length(ms))\n   parse VAR Arc.1 Left (ms) . ')' Right\n   Arc.1 = Strip(Left,'T') 'Member('UDARen')'||Right\n   NewArc = Strip(Left(UDARen,7))'{'\n   address ISPExec\n   /* Check for contention */\n   if NewArc = ArcMem then RC = 4           /* contention with self */\n   else \"LMMFind DataID(&DID) Member(&NewArc)\"\n   if RC = 0 then do\n      \"LMGet DataID(&DID) Mode(INVAR) MaxLen(80) DataLoc(Data) DataLen(Len)\"\n      parse UPPER VAR Data 2 Type Info\n      if Type = 'RESOLVE' then parse VAR Info 'ID('ConID')'\n      else do\n         \"LMClose DataID(&DID)\"\n         address TSO\n         parse VAR Info 'MEMBER('OldMem')'\n         Parms. = 0\n         ConID = ''\n         if zParms then do\n            \"Alloc f(in) dsn('\"ArcDSN\"(Z{PARMS{)')\"Vol \"SHR REUSE\"\n            \"ExecIO * DiskR in (STEM Parms. FINIS\"\n            \"Free f(in)\"\n            do i=1 to Parms.0\n               parse UPPER VAR Parms.i 2 Type Info\n               if Type <> 'RESOLVE' then iterate\n               pl = i\n               parse UPPER VAR Parms.i . 'ID('ConID')'\n            end\n         end\n         if ConID <> '' then ConID = Right(ConID+1,4,0)\n         else do\n            ConID = '0000'\n            pl = Parms.0+1; Parms.0 = pl\n         end\n         Parms.pl = ')Resolve ID('ConID')'\n         \"Alloc f(out) dsn('\"ArcDSN\"(Z{PARMS{)')\"Vol \"SHR REUSE\"\n         \"ExecIO\" Parms.0 \"DiskW out (STEM Parms. FINIS\"\n         \"Free f(out)\"\n         OldArc = 'Z{'ConID||SubStr(OldMem,8)||'{'\n         address ISPExec\n         \"LMOpen DataID(&DID) Option(OUTPUT)\"\n         \"LMMRen DataID(&DID) Member(&NewArc) NewName(&OldArc)\"\n         Data = Parms.pl\n         \"LMPut DataID(&DID) Mode(INVAR) DataLoc(Data) DataLen(80)\"\n         \"LMMAdd DataID(&DID) Member(&NewArc) Stats(NO)\"\n      end\n      ConID = Right(ConID,4,0)\n      NewArc = 'Z{'ConID||SubStr(UDARen,8)||'{'\n   end\n   \"LMClose DataID(&DID)\"\n   address TSO\n   \"Alloc f(out) dsn('\"ArcDSN\"(\"NewArc\")')\"Vol \"SHR REUSE\"\n   \"ExecIO * DiskW out (STEM Arc. FINIS\"\n   \"Free f(out)\"\n   address ISPExec\n   \"LMOpen DataID(&DID) Option(OUTPUT)\"\n   if NewArc <> ArcMem then\n      \"LMMDel DataID(&DID) Member(&ArcMem)\"\n   if ArcCopy then\n      \"LMMRen DataID(&DID) Member(&Mem) NewName(&UDARen)\"\n   \"LMClose DataID(&DID)\"\n   \"LMFree DataID(&DID)\"\n   \"LMInit DataID(DID) DataSet('\"DSN\"')\"Vol \"Enq(SHRW)\"\n   \"LMOpen DataID(&DID) Option(OUTPUT)\"\n   \"LMMRen DataID(&DID) Member(&Mem) NewName(&UDARen)\"\n   end\nWhen Cmd = 'D' then do\n   \"VGet (ZMemConf)\"\n   if ZMemConf <> 'OFF' then do\n      ZCFDSN = DSN\n      ZCFMEM = Mem\n      \"AddPop\"\n      \"Display Panel(ISRUDELC)\"\n      RV = RC\n      \"RemPop\"\n      if RV <> 0 then signal Done\n   end\n   \"LMClose DataID(&DID)\"\n   \"LMFree DataID(&DID)\"\n   address TSO\n   if IsArc then do\n      \"Alloc f(in) dsn('\"ArcDSN\"(\"ArcMem\")')\"Vol \"SHR REUSE\"\n      \"ExecIO 1 DiskR in (STEM Head\"\n      parse UPPER VAR Head1 'HEADER('Header')' 1 'DATA('Data')'\n      if Header = '' then Header = 0\n   end; else Data = ''\n   /* if the archive is already wrapped then ignore the new junk */\n   if Data <> '' then do\n      \"ExecIO 0 DiskR in (FINIS\"\n      \"Free f(in)\"\n   end; else do\n      /* Wrap the data into the archive */\n      if IsArc = 0 then do\n         Header = 0\n         address ISPExec\n         \"LMInit DataID(DID) DataSet('\"DSN\"')\"Vol \"Enq(SHRW)\"\n         \"LMOpen DataID(&DID)\"\n         \"LMMFind DataID(&DID) Member(&Mem) STATS(YES)\"\n         \"LMClose DataID(&DID)\"\n         \"LMFree DataID(&DID)\"\n         if ZLVers <> '' then do\n            Stats = 'Version('ZLVers'.'ZLMod')',\n                    'User('ZLUser')',\n                    'Modified('ZLM4Date ZLMTime':'ZLMSec')'\n            Header = 1\n            Header.1 = '-Stats' Stats\n         end\n         Header.0 = Header\n         address TSO\n      end; else do\n         if Header = 0 then Header.0 = 0\n         else \"ExecIO\" Header \"DiskR in (STEM Header.\"\n         \"ExecIO * DiskR in (STEM Arc. FINIS\"\n         \"Free f(in)\"\n      end\n      \"Alloc f(data) dsn('\"DSN\"(\"Mem\")')\"Vol \"SHR REUSE\"\n      \"ExecIO * DiskR data (STEM Data. FINIS\"\n      \"Free f(data)\"\n      if a#Open('OUT',VolSer':'DSN'('Mem')','WRITE') <> '' then do\n         push ')Current Header('Header+1') Data('Data.0') Member('Mem')'\n         \"ExecIO 1 DiskW out\"\n         \"ExecIO * DiskW out (STEM Header.\"\n         Mod = Translate('1234/56/78',Date('S'),'12345678') Time()\n         push '-Hist (Deleted at' Mod 'by' UserID()')'\n         \"ExecIO 1 DiskW out\"\n         \"ExecIO * DiskW out (STEM Data.\"\n         \"ExecIO * DiskW out (STEM Arc. FINIS\"\n         \"Free f(out)\"\n      end\n   end\n   address ISPExec\n   if ArcCopy then do\n      \"LMInit DataID(DID) DataSet('\"ArcDSN\"')\"Vol \"Enq(SHRW)\"\n      \"LMOpen DataID(&DID) Option(OUTPUT)\"\n      \"LMMDel DataID(&DID) Member(&Mem)\"\n      \"LMClose DataID(&DID)\"\n      \"LMFree DataID(&DID)\"\n   end\n   \"LMInit DataID(DID) DataSet('\"DSN\"')\"Vol \"Enq(SHRW)\"\n   \"LMOpen DataID(&DID) Option(OUTPUT)\"\n   \"LMMDel DataID(&DID) Member(&Mem)\"\n   end\nOtherwise nop\nEnd\n/* All done */\nDone:\n\"LMClose DataID(&DID)\"\n\"LMFree DataID(&DID)\"\nif ZTerm <> '3278' & ZTerm <> '3278A' then\n   \"Select Pgm(ISPTTDef) Parm(\"ZTerm\")\"\nexit 8\n\n/* Let ISPF handle this one. */\nQuit:\n\"LMClose DataID(&DID)\"\n\"LMFree DataID(&DID)\"\nif ZTerm <> '3278' & ZTerm <> '3278A' then\n   \"Select Pgm(ISPTTDef) Parm(\"ZTerm\")\"\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "A#CMP": {"ttr": 1285, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00S\\x01\\t\\x08o\\x01\\t\\x08o\\x11\\x00\\x00T\\x00S\\x00\\x00\\xc8\\xf2\\xf2\\xf4@@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2009-03-27T00:00:00", "modifydate": "2009-03-27T11:00:53", "lines": 84, "newlines": 83, "modlines": 0, "user": "H224"}, "text": "/* Rexx program to supplement the ISPF edit COMPARE command, allowing\n*  the user to compare against a previous versions of an archived\n*  dataset or member.\n*  Usage: Install using #CONFIG.\n*  The macro will just call the BUILTIN COMPARE command unless the\n*  argument string is a valid version string.\n*.\n*. 2009/03/27 Show results of builtin compare - new ISPF edit feature.\n*. 2005/08/09 Created by bsquare\n*/\naddress ISREdit\n\"Macro (Parm)\"\n\"MACRO_MSG = ON\"\nZEdMsgNo = ''\nif Parm = '' then signal Settings         /* Stupid ISPF! */\nparse VAR Parm RV Tail\nif Translate(Left(RV,1)) = 'V' & Pos('.',RV) > 0 then\n   RV = SubStr(RV,2)\nif \\DataType(RV,'N') then \"BuiltIn COMPARE\" Parm\nelse do\n   \"(Vol) = VOLUME\"\n   \"(DSN) = DATASET\"\n   \"(Mem) = MEMBER\"\n   \"(Changed) = DATA_CHANGED\"\n   ArcKey = Vol':'DSN'('Mem')'\n   address ISPExec\n   \"TBGet archive\"\n   \"TBTop &ArcTbl\"\n   if RV < 0 then do\n      if DataType(RV,'W') = 0 then signal Err   /* not a whole number */\n      do (Changed = 'NO') - RV\n         \"TBSkip &ArcTbl\"\n         if RC <> 0 then signal Err\n      end\n      RV = Vers\n   end; else do\n      parse VAR RV VV '.' LL\n      RV = Right(VV,2,0)'.'Right(LL,2,0)\n      do until Vers = RV\n         \"TBSkip &ArcTbl\"\n         if RC <> 0 then signal Err\n      end\n   end\n   Vers = 'VERSION('Vers') USER('User') MODIFIED('Mod')'\n   ViewDS = A#Make(ArcKey,Vers)\n   if ViewDS = '' then signal Err\n   address ISREdit \"BUILTIN COMPARE\" ViewDS Tail\n   om = Msg('OFF')\n   address TSO \"Delete\" ViewDS\n   call Msg om\nend\nif ZEdMsgNo <> '' then do\n   ZEdLMsg = ZEdiLMsg\n   ZEdSMsg = ZEdiSMsg\n   address ISPExec \"SetMsg Msg(ISRZ000)\"\nend\nexit\n\nErr:\n   ZEdLMsg = 'The archive does not contain version' RV\n   ZEdSMsg = 'Not found'\n   address ISPExec \"SetMsg Msg(ISRZ000)\"\n   exit\n\nSettings:\n   address ISPExec\n   \"VGet (ZEdUpdOp ZUpXSiz ZUpdLab)\"\n   ZUpXSizT = ZUpXSiz\n   ZUpdLabT = ZUpdLab\n   parse VAR ZEdUpdOp RefMovr 2 AnyC 3 Mixed 4 DPPlCmt 5,\n         DPPsCmt 6 DPAdCmt 7 DPACmt 8 DPFtCmt 9 DPCbCmt 10 DPBlkCl\n   \"AddPop\"\n   do until RC <> 0\n      \"Display Panel(ISREUPP)\"\n   end\n   \"RemPop\"\n   \"VGet (ZVerb)\"\n   if ZVerb <> 'END' then exit\n   ZEdUpdOp = RefMovr||AnyC||Mixed,\n   || DPPlCmt||DPPsCmt||DPAdCmt||DPACmt||DPFtCmt||DPCbCmt||DPBlkCl\n   ZUpXSiz = ZUpXSizT\n   ZUpdLab = ZUpdLabT\n   \"VPut (ZEdUpdOp ZUpXSiz ZUpdLab) PROFILE\"\n   exit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "A#CPARC": {"ttr": 1288, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01;\\x00\\x05\\x01\\t\\t\\x8f\\x01\\t\\x13O\\x14X\\x01\\xa8\\x00\\xd6\\x00\\x00\\xc8\\xf2\\xf2\\xf4@@@@@@'", "ispf": {"version": "01.59", "flags": 0, "createdate": "2009-04-08T00:00:00", "modifydate": "2009-05-14T14:58:05", "lines": 424, "newlines": 214, "modlines": 0, "user": "H224"}, "text": "/* Rexx program to copy members from a source PDS to a target PDS.\n*  Usage: Batch only: use proc #CPARC.\n*  Supply the OLDDD, NEWDD and CNTL DDs.\n*  The OLDDD DD identifies the PDS/archive to copy members from.\n*  The NEWDD DD identifies the PDS/archive to copy members to.\n*  The format of the CNTL DD is:\n*  -Copy member\n*  -Desc (description of member)\n*  -Hist (history for this update)\n*\n*  The -Copy card MUST precede the -Desc and -Hist cards for each\n*  member to be copied.  The Description and History data MUST be\n*  enclosed in parentheses ().\n*  You can supply up to 6 -Desc cards to provide a description for the\n*  member.  The description will be copied from the source archive if\n*  it exists and you don't supply one.\n*  You can supply up to 6 -Hist cards to provide history for the\n*  copied version of the member.  The history will be copied from the\n*  source archive if it exists and you don't supply it.\n*.\n*. 2009/04/08 Created by bsquare\n*/\nZISPFRC = 0\naddress ISPExec \"CONTROL ERRORS RETURN\"\naddress TSO\n/* Read the archive update statements */\n\"ExecIO * DiskR CNTL (STEM Cntl. FINIS\"\nif RC <> 0 then call Issue 16,'Unable to read CNTL DD'\nparse VALUE '' WITH MemList,Name\nDesc. = 0\nHist. = 0\ndo i=1 to Cntl.0\n   parse UPPER VAR Cntl.i Cmd cName .\n   if Left(Cmd,1) <> '-' then iterate\n   Select\n   When Cmd = '-COPY' then do\n      if Name <> '' then parse VALUE d h WITH Desc.Name.0 Hist.Name.0\n      parse VALUE 0 0 WITH d h\n      Name = cName\n      if WordPos(Name,MemList) = 0 then MemList = MemList||Name||' '\n      else call Issue 16,'Duplicate member name' Name 'on line' i'.'\n      call Issue 'Request to copy member' Name\n      end\n   When Name = '' then\n      call Issue 16,'No -Copy statement before' Cmd 'on line' i'.'\n   When Cmd = '-DESC' then parse VALUE d+1 Cntl.i WITH d Desc.Name.d\n   When Cmd = '-HIST' then parse VALUE h+1 Cntl.i WITH h Hist.Name.h\n   Otherwise call Issue 4,'Unrecognized command' Cmd 'on line' i'.'\n   End\nend\nif Name <> '' then parse VALUE d h WITH Desc.Name.0 Hist.Name.0\n\nif MemList = '' then do\n   call Issue 4,'No members were selected to copy'\n   exit ZISPFRC\nend\n\naddress ISPExec\n\"LMInit DATAID(InID) DDNAME(OLDDD)\"\nif RC > 0 then call Issue 16,'Unable to init ID for DD OLDDD'\n\"LMInit DATAID(OutID) DDNAME(NEWDD) ENQ(SHRW)\"\nif RC > 0 then call Issue 16,'Unable to init ID for DD NEWDD'\nArcID = ''\n\nTargetInfo = ArcInfo(OutID)\nparse VAR TargetInfo TargetDS ',' TargetArc ',' TargetVol\nSourceInfo = ArcInfo(InID)\nparse VAR SourceInfo SourceDS ',' SourceArc ',' SourceVol\n\nif TargetInfo = '' then\n   call Issue 'NEWDD is not an archive.  Processing as a PDS.'\nelse do\n   /* Do a SuperC compare of the selected members */\n   address TSO\n   \"Alloc f(OUTDD) DUMMY REUSE\"\n   \"Alloc f(SYSIN) NEW DELETE UNIT(SYSDA) SPACE(1,1) TRACKS\",\n      \"DSORG(PS) RECFM(F B) LRECL(80) REUSE\"\n   do i=1 to Words(MemList)\n      queue 'SELECT' Word(MemList,i)\n   end\n   \"ExecIO\" Words(MemList) \"DiskW SYSIN (FINIS\"\n   \"Alloc f(DELDD) NEW RECFM(F,B) LRECL(80) REUSE\",\n       \"SPACE(1,1) CYL BLKSIZE(0) DSORG(PS)\"\n   if RC > 0 then call Issue 16,'Unable to open temporary DS for SuperC'\n\n   address ISPExec \"Select Pgm(ISRSUPC) Parm(NOLISTL,CMP,UPDCNTL)\"\n   if RC > 4 then call Issue 16,'Failure calling SuperC'\n\n   \"ExecIO * DiskR DELDD (STEM Compare. FINIS\"\n   if RC > 4 then call Issue 16,'Returned data failure from SuperC'\n   \"Free f(OUTDD SYSIN DELDD)\"\n   Name = ''\n   Diff. = 0\n   do i=1 to Compare.0\n      Select\n      When Left(Compare.i,1) = '*' then do\n         parse UPPER VAR Compare.i . Stmt Info .\n         if Stmt = 'NEW:' then parse VAR Info '(' Name ')'\n         if Stmt = 'END' then Name = ''\n         Ln = 0\n         end\n      When Name = '' then call Issue 4,'???? from SuperC:' Compare.i\n      Otherwise\n         Ln = Ln+1\n         Diff.Name.Ln = Compare.i\n         Diff.Name.0 = Ln\n      End\n   end\nend\n\ndo while MemList <> ''\n   parse VAR MemList Name MemList\n   call Issue 'Processing member' Name '...'\n   if TargetInfo = '' then do\n      /* Not an archive.  Just copy the member */\n      \"LMCopy FromID(&InID) FromMem(&Name) ToDataID(&OutID) REPLACE\"\n      if RC = 0 then call Issue '   'Name 'copied.'\n      else do\n         call Issue 8,'   Failed to copy' Name\n         call Issue '   'ZErrLM\n      end\n      iterate\n   end\n\n   /* The rest of this is only for Archived targets. */\n   /* Get Stats of source member */\n   address ISPExec\n   NewStats = ''\n   \"LMOpen DataID(&InID)\"\n   \"LMMFind DataID(&InID) Member(&Name) Stats(YES)\"\n   fRC = RC\n   \"LMClose DataID(&InID)\"\n   if fRC > 0 then do\n      call Issue 8,'   Failed to locate OLDDD' Name\n      iterate\n   end\n   parse VALUE '' WITH Vers User Mod\n   if ZLVers <> '' then\n      Vers = 'Version('Right(ZLVers,2,0)'.'Right(ZLMod,2,0)')'\n   if ZLUser <> '' then User = 'User('Strip(ZLUser)')'\n   if ZLM4Date <> '' then\n      Mod = 'Modified('ZLM4Date ZLMTime':'ZLMSec')'\n   NewStats = Vers User Mod\n\n   address TSO\n   CntlDesc = (Desc.Name.0 > 0)\n   CntlHist = (Hist.Name.0 > 0)\n   if TargetVol = '' then ArcKey = TargetDS'('Name')'\n   else ArcKey = TargetVol':'TargetDS'('Name')'\n   parse VALUE a#Open('IN',ArcKey) WITH Archive VolInfo\n   HasArc = (Archive <> '')\n   TgtDesc. = 0\n   parse VALUE '' WITH OldStats,Opts\n   if Archive = '' then call Issue '   'Name 'not previously archived'\n   else do\n      \"ExecIO * DiskR IN (STEM In. FINIS\"\n      \"Free f(IN)\"\n      if In.0 < 1 then do\n         call Issue 8,'   Malformed archive' Archive VolInfo\n         iterate\n      end\n      parse UPPER VAR In.1 2 Type Info\n      if Type <> 'CURRENT' then do\n         call Issue 8,'   Unsupported archive' Archive VolInfo\n         iterate\n      end\n      parse VAR Info,\n         'HEADER('hLines')' 1 'DATA('dLines')' 1 'MEMBER('ArcMem')'\n      if ArcMem <> Name then do\n         call Issue 8,'   Archive member' ArcMem 'should be' Name\n         iterate\n      end\n      if hLines = '' then hLines = 0\n      if dLines = '' then dLines = 0\n      do i=2 for hLines\n         Type = Translate(Word(In.i,1))\n         Select\n         When Type = '-STATS' then OldStats = In.i\n         When Type = '-OPTS'  then Opts = In.i\n         When Type = '-DESC'  then do\n            TgtDesc.Name.0 = TgtDesc.Name.0+1\n            parse VALUE TgtDesc.Name.0 In.i WITH td TgtDesc.Name.td\n            end\n         When Type = '-HIST'  then nop  /* ignore old history */\n         Otherwise\n            call Issue 4,'   Ignored unrecognized archive instruction-'\n            call Issue 4,'   'In.i\n         End\n      end\n   end\n\n   if \\(CntlDesc & CntlHist) then do 1\n      /* Get the Description and/or History from the source archive */\n      if SourceDS = '' then leave /* temp ds?  not an archive, anyway */\n      if SourceVol = '' then SrcKey = SourceDS'('Name')'\n      else SrcKey = SourceVol':'SourceDS'('Name')'\n      parse VALUE a#Open('IN',SrcKey) WITH SrcArc svInfo\n      if SrcArc = '' then leave\n      \"ExecIO * DiskR IN (STEM Src. FINIS\"\n      \"Free f(IN)\"\n      /* Get the Description from the )Current section */\n      if Src.0 < 1 then leave\n      parse UPPER VAR Src.1 2 Type Info\n      if Type <> 'CURRENT' then leave\n      parse VAR Info 'HEADER('hl')' 1 'DATA('dl')' 1 'MEMBER('am')'\n      if am <> Name then leave\n      parse VALUE 0||hl 0||dl WITH hl dl\n      do i=2 for hl\n         Type = Translate(Word(Src.i,1))\n         if Type = '-DESC' then do\n            if CntlDesc then iterate   /* Desc overridden in CNTL */\n            Desc.Name.0 = Desc.Name.0+1\n            parse VALUE Desc.Name.0 Src.i WITH d Desc.Name.d\n         end\n         /* It is possible to have History in the )Current section */\n         if Type = '-HIST' then do\n            if CntlHist then iterate   /* Hist overridden in CNTL */\n            Hist.Name.0 = Hist.Name.0+1\n            parse VALUE Hist.Name.0 Src.i WITH h Hist.Name.h\n         end\n      end\n      /* Get the History from the 1st )Archive section */\n      al = 2+hl+dl\n      if al > Src.0 then leave\n      parse UPPER VAR Src.al 2 Type Info\n      if Type <> 'ARCHIVE' then leave\n      parse VAR Info 'HEADER('hl')' 1 'DATA('dl')'\n      do i=al+1 for hl\n         Type = Translate(Word(Src.i,1))\n         if Type = '-HIST' then do\n            if CntlHist then iterate   /* Hist overridden in CNTL */\n            Hist.Name.0 = Hist.Name.0+1\n            parse VALUE Hist.Name.0 Src.i WITH h Hist.Name.h\n         end\n      end\n   end\n   if Desc.Name.0 = TgtDesc.Name.0 then do alone=1 for 1\n      do i=1 to Desc.Name.0\n         if Desc.Name.i <> TgtDesc.Name.i then leave alone\n      end\n      Desc.Name.0 = 0\n   end\n\n   /* Determine whether the target member exists or not */\n   address ISPExec\n   \"LMOpen DataID(&OutID)\"\n   \"LMMFind DataID(&OutID) Member(&Name)\"\n   isNew = (RC <> 0)\n   \"LMClose DataID(&OutID)\"\n\n   address TSO\n   Stmt. = 0\n   if isNew then call Issue '   adding new'\n   else do 1\n      \"Alloc f(InDD) dsn('\"TargetDS\"(\"Name\")') SHR REUSE\"\n      if RC <> 0 then leave\n      s = 0\n      /* Generate the archive update statements */\n      do i=1 to Diff.Name.0\n         /* Match, Insert, Delete, Alter */\n         parse VAR Diff.Name.i NewLine OldLine,\n            22 mLen . 31 iLen . 40 dlen . 49 aLen .\n         parse VALUE NewLine+0 OldLine+0 WITH NewLine OldLine\n         if aLen <> '' then do; iLen = aLen; dLen = aLen; end\n         if iLen <> '' then do\n            Len = iLen+0\n            s = s+1; Stmt.s = '-Ins Lines('Len') Start('NewLine')'\n            \"ExecIO\" Len \"DiskR InDD\" NewLine \"(STEM Temp.\"\n            do t=1 to Len\n               s = s+1; Stmt.s = Strip(Temp.t,'T')\n            end\n         end\n         if dLen <> '' then do\n            Len = dLen+0\n            s = s+1; Stmt.s = '-Del Count('Len') Start('OldLine')'\n         end\n      end\n      \"ExecIO 0 DiskR InDD (FINIS\"\n      \"Free f(InDD)\"\n      Stmt.0 = s\n   end\n\n   /* Copy the member */\n   address ISPExec,\n      \"LMCopy FromID(&InID) FromMem(&Name) ToDataID(&OutID) REPLACE\"\n   if RC = 0 then call Issue '   'Name 'copied.'\n   else do\n      call Issue 8,'   Failed to copy' Name 'to' TargetDS\n      call Issue '   'ZErrLM\n      iterate\n   end\n\n   parse VALUE Desc.Name.0 Hist.Name.0 WITH d h\n   /* if we are not changing the archive, don't write it */\n   if isNew+d+Stmt.0 = 0 then do\n      call Issue 4,'   'Name 'no changes to archive'\n      iterate\n   end\n\n   /* Use the target description if no other is available */\n   if d = 0 then do\n      d = TgtDesc.Name.0\n      do i=1 to d\n         Desc.Name.i = TgtDesc.Name.i\n      end\n   end\n\n   /* Attempt to open the Archive for output */\n   parse VALUE a#Open('OUT',ArcKey,'WRITE') WITH Archive VolInfo\n   if Archive = '' then\n      call Issue 16,'   Unable to open archive for writing:' ArcKey\n\n   /* If the source didn't change, ignore change history */\n   if isNew+Stmt.0 = 0 then parse VALUE 0 WITH h,OldStats\n   if isNew & \\HasArc then parse VALUE 0 h WITH h nh\n   else nh = 0\n   nLines = (NewStats <> '') + (Opts <> '') + d + nh\n   oLines = (OldStats <> '') + h\n   queue ')Current Header('nLines') Member('Name')'\n   if NewStats <> '' then queue '-Stats' NewStats\n   if Opts <> '' then queue Opts\n   do i=1 to d\n      queue Desc.Name.i\n   end\n   do i=1 to nh\n      queue Hist.Name.i\n   end\n   if oLines+Stmt.0 > 0 then do\n      queue ')Archive Header('oLines') Data('Stmt.0')'\n      if OldStats <> '' then queue OldStats\n      do i=1 to h\n         queue Hist.Name.i\n      end\n      do i=1 to Stmt.0\n         queue Stmt.i\n      end\n   end\n   if HasArc then do i=2+hLines+dLines to In.0; queue In.i; end\n   \"ExecIO\" Queued() \"DiskW OUT (FINIS\"\n   eRC = RC\n   \"Free f(OUT)\"\n   if RC > 0 then\n      call Issue 16,'   Failure writing archive for' ArcKey\n   call Issue '   'Name 'archive updated.'\n   if TargetArc <> TargetDS then do\n      address ISPExec\n      Copy = \"'\"TargetArc\"'\"\n      if ArcID = '' then \"LMInit DATAID(ArcID) DataSet(&Copy)\" VolInfo\n      \"LMCopy FromID(&InID) FromMem(&Name) ToDataID(&ArcID) REPLACE\"\n      if RC > 0 then\n         call Issue 12,'   Failed to back up' Name 'to' TargetArc\n      else call Issue '   'Name 'archival copy made.'\n   end\nend\naddress ISPExec\n\"LMFree DATAID(INID)\"\n\"LMFree DATAID(OUTID)\"\nif ArcID <> '' then \"LMFree DATAID(ARCID)\"\nexit ZISPFRC\n\n/* Issue a (possibly error) message */\nIssue: procedure EXPOSE ZISPFRC\n   parse arg Code,Message\n   if Code = '' then Code = 0\n   if Message = '' & DataType(Code,'W') = 0 then\n      parse VALUE 0 Code WITH Code Message\n   RCMsg = 'RC='Right(Code,2,0)' '\n   if Code = 0 then RCMsg = '      '\n   say RCMsg||Message\n   if Code > ZISPFRC then ZISPFRC = Code\n   address ISPExec \"VPut ZISPFRC\"\n   if ZISPFRC > 12 then exit ZISPFRC\n   return\n\n/* Return DSN,ArcDSN,VolSer for an archived dataset or '' otherwise. */\nArcInfo: procedure\n   arg DID\n   address ISPExec\n   \"LMOpen DataID(&DID)\"\n   if RC > 0 then return ''\n   \"LMQuery DataID(&DID) DDName(DD)\",\n      \"LRecL(LRecL) RecFm(RecFm) DSOrg(DSOrg) oVolume(VolSer)\"\n   SysDSName = ''      /* if DID refers to VIO, this will not change */\n   IsCat = ListDSI(DD 'FILE') < 8\n   if IsCat then IsCat = ListDSI(\"'\"SysDSName\"'\") <= 4\n   if IsCat then IsCat = (SysVolume = VolSer)\n   if IsCat then VolSer = ''\n\n   if DSOrg <> 'PO' then call Issue 16,'DD is not a PDS:' DD\n   DSN = SysDSName\n   if Right(DSN,4) = '.ARC' then do\n      \"LMClose DataID(&DID)\"\n      return ''\n   end\n\n   /* Check for an externally archived dataset. */\n   IsArc = 0\n   if DSN <> '' then do\n      ArcDSN = DSN'.ARC'\n      if VolSer <> '' then VolInfo = ' VOLUME('VolSer')'\n      else VolInfo = ''\n      if Length(ArcDSN) <= 44 then do 1\n         RC = ListDSI(\"'\"ArcDSN\"'\"||VolInfo)\n         if RC > 4 then leave\n         if Left(SysDSOrg,2) <> 'PO' then leave\n         if Left(SysRecFm,1) = 'V' then SysLRecL = SysLRecL-4\n         if SysLRecL < LRecL then leave\n         IsArc = 1\n      end\n   end\n\n   /* Could this be a self-archived PDS? */\n   if IsArc = 0 then do\n      ArcDSN = DSN\n      \"VGet (ZTERM)\"\n      SetTerm = (WordPos(ZTerm,'3278 3278A') = 0)\n      if SetTerm then \"Select Pgm(ISPTTDef) Parm(3278)\"\n      \"LMMFind DataID(&DID) Member(Z{PARMS{)\"\n      IsArc = (RC = 0)\n      if SetTerm then \"Select Pgm(ISPTTDef) Parm(\"ZTerm\")\"\n   end\n   \"LMClose DataID(&DID)\"\n   if IsArc then return DSN','ArcDSN','VolSer\n   return ''\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "A#DESCP": {"ttr": 1541, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00)\\x01\\x05\\x19?\\x01\\x05 \\x9f\\x16\\x00\\x00\\x12\\x00\\x19\\x00\\x00\\xc8\\xf2\\xf2\\xf4@@@@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "2005-07-12T00:00:00", "modifydate": "2005-07-28T16:00:29", "lines": 18, "newlines": 25, "modlines": 0, "user": "H224"}, "text": ")ATTR\n _ TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(ASIS)\n)BODY EXPAND(\\\\)\n%&ZUSER---- MCIT Edit Archive Control \\-\\&ZDATE-&ZTIME--\n%Option  ===>_ZCMD\\ \\+\n+\n%\\ \\Archive Description\\ \\+\n+ Enter a description for%&DSN\n+\n+ Line 1:_Desc1                                                       +\n+ Line 2:_Desc2                                                       +\n+ Line 3:_Desc3                                                       +\n+ Line 4:_Desc4                                                       +\n+ Line 5:_Desc5                                                       +\n+ Line 6:_Desc6                                                       +\n+\n+ Press%Enter+to accept or%PF3+to%CANCEL+the SAVE\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "A#DHISTP": {"ttr": 1543, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x000\\x01\\x05\\x19O\\x01\\x05 \\x9f\\x16\\x01\\x00\\x1b\\x00\\x13\\x00\\x00\\xc8\\xf2\\xf2\\xf4@@@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2005-07-13T00:00:00", "modifydate": "2005-07-28T16:01:30", "lines": 27, "newlines": 19, "modlines": 0, "user": "H224"}, "text": ")ATTR\n _ TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(ASIS)\n)BODY EXPAND(\\\\)\n%&ZUSER---- MCIT Edit Archive Control \\-\\&ZDATE-&ZTIME--\n%Option  ===>_ZCMD\\ \\+\n+\n%\\ \\Archive History\\ \\+\n+\n+ &Desc1\n+ &Desc2\n+ &Desc3\n+ &Desc4\n+ &Desc5\n+ &Desc6\n+\n%&DSN v&Vers\n+ Modified &Mod by &User\n+\n+ Line 1:%&Hist1\n+ Line 2:%&Hist2\n+ Line 3:%&Hist3\n+ Line 4:%&Hist4\n+ Line 5:%&Hist5\n+ Line 6:%&Hist6\n+\n+\\ \\Press%Enter+or%PF3\\ \\+\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "A#END": {"ttr": 1545, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1d\\x00\"\\x01\\x05\\x18\\x9f\\x01\\t\\x18?\\x15U\\x00\\x1d\\x00\\x0c\\x00\\x00\\xc8\\xf2\\xf2\\xf4@@@@@@'", "ispf": {"version": "01.29", "flags": 0, "createdate": "2005-07-08T00:00:00", "modifydate": "2009-07-02T15:55:22", "lines": 29, "newlines": 12, "modlines": 0, "user": "H224"}, "text": "/* Rexx program to end an edit session, archiving as necessary.\n*  Usage: Install using #CONFIG.\n*  When you END in ISPF edit, this will call SAVE if AUTOSAVE is on.\n*  SAVE is also modified in a#Init.\n*  This exec also closes the tables opened by a#Init.\n*.\n*. 2005/07/08 Created by bsquare\n*/\naddress ISREdit\n\"Macro\"\n\"(Sess) = SESSION\"\n\"(Changed) = DATA_CHANGED\"  /* Changed? */\nif Changed <> 'NO' then do\n   \"(AUTO) = AUTOSAVE\"\n   if AUTO = 'ON' then \"SAVE\"\n   if RC > 4 then exit      /* User canceled out of SAVE */\nend\n\"(Vol) = VOLUME\"\n\"(DSN) = DATASET\"\n\"(Mem) = MEMBER\"\nArcKey = Vol':'DSN'('Mem')'\naddress ISPExec\n\"TBGet archive\"\n\"TBEnd\" ArcTbl\n\"TBDelete archive\"       /* delete this archive entry */\n\"TBClose archive\"\n/* \"LIBDEF ISPPLIB\" */\n/* address TSO \"AltLib DEACTIVATE APPLICATION(EXEC)\" */\naddress ISREdit \"BuiltIn END\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "A#HISTP": {"ttr": 1547, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00\\x13\\x01\\x05\\x19?\\x01\\x05\"?\\x146\\x00\\x1a\\x00\\x1a\\x00\\x00\\xc8\\xf2\\xf2\\xf4@@@@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "2005-07-12T00:00:00", "modifydate": "2005-08-11T14:36:13", "lines": 26, "newlines": 26, "modlines": 0, "user": "H224"}, "text": ")ATTR\n _ TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(ASIS)\n)BODY EXPAND(\\\\)\n%&ZUSER---- MCIT Edit Archive Control \\-\\&ZDATE-&ZTIME--\n%Option  ===>_ZCMD\\ \\+\n+\n%\\ \\Archive History\\ \\+\n+\n+ &Desc1\n+ &Desc2\n+ &Desc3\n+ &Desc4\n+ &Desc5\n+ &Desc6\n+\n+ Describe your changes to%&DSN v&Vers\n+\n+ Line 1:_Hist1                                                       +\n+ Line 2:_Hist2                                                       +\n+ Line 3:_Hist3                                                       +\n+ Line 4:_Hist4                                                       +\n+ Line 5:_Hist5                                                       +\n+ Line 6:_Hist6                                                       +\n+\n+ Press%Enter+to accept or%PF3+to%CANCEL+the SAVE\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "A#INFO": {"ttr": 1549, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x00Y\\x01\\t\\x12_\\x01\\t\\x12o\\x17\\x01\\x00\\xc9\\x01/\\x00\\x00\\xc8\\xf2\\xf2\\xf4@@@@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "2009-05-05T00:00:00", "modifydate": "2009-05-06T17:01:59", "lines": 201, "newlines": 303, "modlines": 0, "user": "H224"}, "text": "/* Rexx program.  Get archive info for a rexx exec that executes outside\n*  of ISPF edit.\n*  Usage: a#Info 'DSN(Member)' Volume\n*  This is what is passed to the a#CmdCk exit, which calls this.\n*  Archiving is done in one of 3 ways:\n*  1.  Seq dataset, seq archive named dataset.ARC\n*  2.  PDS dataset, PDS archive named dataset.ARC\n*  3.  PDS dataset with a PDS member named Z{PARMS{\n*\n*  In any case, the archive must have a LRecL >= 80 (84 if V).\n*  The archive LRecL must also be >= the LRecL of the dataset (if the\n*  dataset is RecFM F or FB and the archive is V or VB, the LRecL of\n*  the archive must be at least 4 more than the dataset.\n*  NOTE: In order to use the LKWM feature, the archive MUST have\n*        RecFM FB, LRecL 80.\n*.\n*. 2009/05/05 Copied from a#Init\n*/\naddress ISPExec\narg DSN Vol .\nDSN = Strip(DSN,'B',\"'\")\nparse VAR DSN DSN '(' Mem ')'\n\n/* Check the dataset (the target). */\nif Right(DSN,4) = '.ARC' then exit ''       /* No archive info */\n\n/* Check the control dataset (the archive). */\nzParms = 0\nif ListDSI(\"'\"DSN\"'\") = 0,\n&  (Vol = '' | Vol = SysVolume) then ArcVol = ''\nelse ArcVol = 'VOLUME('Vol')'         /* accessed by volume */\nif ArcVol <> '' then\n   if ListDSI(\"'\"DSN\"'\" ArcVol) <> 0 then exit ''     /* No dataset? */\nArcKey = SysVolume':'DSN'('Mem')'           /* Key for archive table */\nLRecL = SysLRecL\nRecFm = SysRecFm\nArcDSN = DSN'.ARC'\nArcLen = Length(ArcDSN)\nLKWMTbl = ''                             /* ISPF table for LKWM */\nDSOrg = Left(SysDSOrg,2)\nif DSOrg <> 'PO' & DSOrg <> 'PS' then exit ''        /* Bad Org */\nif DSOrg = 'PS' then do                   /* sequential dataset */\n   if ArcLen > 44 then exit ''  /* can't archive, name too long */\n   /* Archive doesn't exist */\n   if ListDSI(\"'\"ArcDSN\"'\" ArcVol) <> 0 then exit ''\n   if Left(SysDSOrg,2) <> 'PS' then exit ''/* archive must be seq */\nend; else do                               /* PDS dataset */\n   if Right(Mem,1) = '{' then exit ''      /* Can't archive these. */\n   if ArcLen > 44 then lRC = 16\n   else lRC = ListDSI(\"'\"ArcDSN\"'\" ArcVol)\n   if lRC = 0 then zParms = FindM(ArcDSN,\"Z{PARMS{\",ArcVol)\n   else do\n      ArcDSN = DSN                        /* self-archived */\n      zParms = FindM(ArcDSN,\"Z{PARMS{\",ArcVol)\n      if zParms = 0 then exit ''\n      call ListDSI \"'\"DSN\"'\" ArcVol\n   end\n   if Left(SysDSOrg,2) <> 'PO' then exit '' /* archive must be PDS */\n   if Left(SysRecFM,2) = 'FB' & SysLRecL = 80 then LKWMTbl = 'Z{LKWM{'\nend\n\n/* Make sure LRecL is long enough */\nif SysLRecL < 80 | SysLRecL < LRecL then exit ''\n\n/* O.K. - looks like an archive - get archive data */\nArcTbl = ''\naddress ISPExec\n\"TbOpen archive NOWRITE SHARE\"\nif RC = 0 then do\n   \"TbGet archive\"\n   \"TbEnd archive\"\nend\nVars = \"(ArcKey DSOrg ArcDSN ArcTbl ArcVol LKWMTbl Opts\",\n        \"DL Desc1 Desc2 Desc3 Desc4 Desc5 Desc6)\"\nif ArcTbl <> '' then do\n   \"VPut\" Vars \"SHARED\"\n   return Vars\nend\n\n/* Not currently in an Edit/View session.  Get Info. */\nOpts = 'Hist(5) NoArc NoSync Desc'        /* Defaults */\nparse VALUE 5 1 1 1 0 WITH Hist NoArc NoSync Desc Quiet\n\n/* Set up for Global opts */\nGlobal = ''\nif zParms then do\n   address TSO\n   \"Alloc f(in) dsn('\"ArcDSN\"(Z{PARMS{)')\" ArcVol \"SHR REUSE\"\n   \"ExecIO * DiskR in (STEM Parms. FINIS\"\n   \"Free f(in)\"\n   do i=1 to Parms.0\n      parse VAR Parms.i 2 Type Info\n      if Translate(Type) = 'OPTS' then Global = Global Info\n   end\n   Global = Space(Global)\n   interpret a#Opts(Global)\nend\nOpts = Opts'00'x||Global\n\naddress ISPExec\nif DSOrg = 'PO' & Mem = '' then Archive = ''\nelse parse VALUE A#Open('ARC',ArcKey,'READ') WITH Archive .\nif Archive = '' then do        /* No archive member - no history */\n   \"VPut\" Vars \"SHARED\"\n   return Vars\nend\n\n/* Create a table to store history information in. */\ndo i=1 to 99 until RC = 0\n   ArcTbl = 'ARC'i\n   \"TbCreate &ArcTbl NOWRITE SHARE KEYS(Mod)\",\n      \"Names(User Vers HL Hist1 Hist2 Hist3 Hist4 Hist5 Hist6)\"\nend\n\naddress TSO\nline = 1\nparse VALUE '0' WITH dl,Desc1,Desc2,Desc3,Desc4,Desc5,Desc6\nparse VALUE '0' WITH hl,Hist1,Hist2,Hist3,Hist4,Hist5,Hist6\nparse VALUE '0' WITH Data,Mbr\ndo forever\n   \"ExecIO 1 DiskR arc\" line\n   if RC <> 0 then leave\n   line = line+1\n   pull 2 Type . 'HEADER('Header')' 1 'DATA('Data')' 1 'MEMBER('Mbr')'\n   if Header = '' then Header = 0\n   if Data = '' then Data = 0\n   if Header = 0 then Head.0 = 0\n   else \"ExecIO\" Header \"DiskR arc\" line \"(STEM Head.\"\n   line = line + Header\n   if WordPos(Type,'CURRENT ARCHIVE') = 0 then leave  /* error */\n   parse VALUE '00.00' WITH pVers pUser pMod\n   if Head.0 = 0 then do\n      if Type = 'CURRENT' then ArcVers = pVers\n      else do\n         address ISPExec \"TbAdd\" ArcTbl\n         parse VALUE '0' WITH hl,Hist1,Hist2,Hist3,Hist4,Hist5,Hist6\n      end\n   end; else do\n      Local = ''                      /* Set up for Local opts */\n      do i=1 to Head.0\n         parse UPPER VAR Head.i 2 Op .\n         Select\n         When Op = 'OPTS' then Local = Local||'00'x SubWord(Head.i,2)\n         When Op = 'STATS' then do\n            parse UPPER VAR Head.i,\n               'VERSION('pVers')' 1 'USER('pUser')' 1 'MODIFIED('pMod')'\n            end\n         When Op = 'HIST' then do\n            hl = hl+1\n            parse VALUE Strip(Head.i) WITH . '(' Info\n            call Value 'HIST'hl, Left(Info,Length(Info)-1)\n            end\n         When Op = 'DESC' then do\n            dl = dl+1\n            parse VALUE Strip(Head.i) WITH . '(' Info\n            call Value 'DESC'dl, Left(Info,Length(Info)-1)\n            end\n         Otherwise nop\n         End\n      end\n      if Type <> 'CURRENT' then do\n         address ISPExec \"TbAdd\" ArcTbl\n         parse VALUE '0' WITH hl,Hist1,Hist2,Hist3,Hist4,Hist5,Hist6\n      end; else do\n         interpret a#Opts(Local)\n         Opts = Opts||Local\n         ArcVers = pVers\n      end\n   end\n   Vers = pVers; User = pUser; Mod = pMod\n   line = line + Data\nend\n\"ExecIO 0 DiskR arc (FINIS\"\n\"Free f(arc)\"\naddress ISPExec\n\"TbQuery &ArcTbl RowNum(Rows)\"\nif Rows = 0 & Data = 0 & Mbr = '' then do       /* No archive data */\n   \"TbEnd\" ArcTbl\n   ArcTbl = ''\nend; else \"TbAdd\" ArcTbl\n\"VPut\" Vars \"SHARED\"\nreturn Vars\n\n/* Find a member in a dataset */\nFindM: procedure\n   arg DataSet,Mem,Vol\n   address ISPExec\n   \"Control ERRORS RETURN\"\n   \"VGet (ZTerm)\"                /* deal with strange term types */\n   if ZTerm <> '3278' & ZTerm <> '3278A' then\n      \"Select Pgm(ISPTTDef) Parm(3278)\"\n   \"LMInit DataID(ID) DataSet('\"DataSet\"')\" Vol\n   \"LMOpen DataID(&ID)\"\n   oRC = RC\n   \"LMMFind DataID(&ID) Member(&Mem)\"\n   Found = (RC = 0)\n   if oRC < 12 then \"LMClose DataID(&ID)\"\n   if ZTerm <> '3278' & ZTerm <> '3278A' then\n      \"Select Pgm(ISPTTDef) Parm(\"ZTerm\")\"\n   \"LMFree DataID(&ID)\"\n   return Found\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "A#INIT": {"ttr": 1553, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01_\\x00S\\x01\\x05!\\x7f\\x01\\t(\\x8f\\x140\\x01M\\x00\\xcb\\x00\\x00\\xc8\\xf2\\xf2\\xf4@@@@@@'", "ispf": {"version": "01.95", "flags": 0, "createdate": "2005-08-05T00:00:00", "modifydate": "2009-10-15T14:30:53", "lines": 333, "newlines": 203, "modlines": 0, "user": "H224"}, "text": "/* Rexx program.  Initialize the archive macros that replace ISPF edit\n*  commands - END, CANCEL, SAVE, VIEW, COMPARE (add HISTORY).\n*  Usage: Install using #CONFIG.\n*  Archiving is done in one of 3 ways:\n*  1.  Seq dataset, seq archive named dataset.ARC\n*  2.  PDS dataset, PDS archive named dataset.ARC\n*  3.  PDS dataset with a PDS member named Z{PARMS{\n*\n*  In any case, the archive must have a LRecL >= 80 (84 if V).\n*  The archive LRecL must also be >= the LRecL of the dataset (if the\n*  dataset is RecFM F or FB and the archive is V or VB, the LRecL of\n*  the archive must be at least 4 more than the dataset.\n*  NOTE: In order to use the LKWM feature, the archive MUST have\n*        RecFM FB, LRecL 80.\n*.\n*. 2005/07/08 Created by BSquare\n*. 2005/07/12 Allow sequential archives, add CANCEL.\n*.            Moved the macros to a seperate library.\n*. 2005/07/15 Use INFOLINE for description in member.\n*. 2005/07/21 Change format of archives.\n*. 2005/07/28 Change format of archives (again).\n*. 2005/08/03 Change INFOLINE to NOTELINE, use INFOLINE for WARNINGS.\n*. 2005/08/05 Use external a#Open instead of internal Resolve.\n*. 2005/08/12 Added Default, Global and Local options.\n*. 2005/08/30 Add Last Known Working Member copy.\n*. 2005/09/06 Fix LKWM for sequential datasets (i.e. remove).\n*. 2005/09/07 Only allow FB80 for LKWM.\n*. 2009/05/20 Add HISTORY alias HIST.\n*.            Fix recursive VIEW of the same PDS member.\n*.            Add DSOrg to the archive table to allow fixing broken\n*.            archive members.\n*.            Fix v01.00 for no disk stats (is now v00.00).\n*/\naddress ISREdit\n\"Macro\"\n\n\"(Sess) = SESSION\"\n/* Archive can not be used in EDIF or VIIF */\nif WordPos(Sess,'EDIT VIEW') = 0 then exit\n\n/* Check the dataset being edited (the target). */\n\"(DID) = DATAID\"\n\"(Vol) = VOLUME\"\n\"(Mem) = MEMBER\"\n\"(DSN) = DATASET\"\nif Left(DSN,1) = '/' then exit        /* Can't archive a unix file */\nif Right(DSN,4) = '.ARC' then exit    /* Can't archive an archive */\nif Left(DSN,1)  = '/' then exit       /* Can't archive a unix file */\nArcKey = Vol':'DSN'('Mem')'           /* Key for archive table */\n\"(LRecL)   = LRECL\"\n\"(RecFm)   = RECFM\"\nif RecFm = 'V' then LRecL = LRecL+4\n\n/* Check the control dataset (the archive). */\nzParms = 0\nif ListDSI(\"'\"DSN\"'\") = 0 & Vol = SysVolume then ArcVol = ''\nelse ArcVol = 'VOLUME('Vol')'         /* accessed by volume */\nDSOrg = Left(SysDSOrg,2)\nArcDSN = DSN'.ARC'\nArcLen = Length(ArcDSN)\nLKWMTbl = ''                          /* ISPF table for LKWM */\nif Mem = '' then do                       /* sequential dataset */\n   if ArcLen > 44 then exit     /* can't archive, name too long */\n   /* Archive doesn't exist */\n   if ListDSI(\"'\"ArcDSN\"'\" ArcVol) <> 0 then exit\n   if Left(SysDSOrg,2) <> 'PS' then exit  /* archive must be seq */\nend; else do                              /* PDS dataset */\n   if Right(Mem,1) = '{' then exit        /* Can't archive these. */\n   if ArcLen > 44 | ListDSI(\"'\"ArcDSN\"'\" ArcVol) <> 0 then do\n      address ISPExec\n      \"Control ERRORS RETURN\"\n      \"VGet (ZTerm)\"                /* deal with strange term types */\n      if ZTerm <> '3278' & ZTerm <> '3278A' then\n         \"Select Pgm(ISPTTDef) Parm(3278)\"\n      \"LMOpen DataID(&DID)\"\n      oRC = RC\n      \"LMMFind DataID(&DID) Member(Z{PARMS{)\"\n      zParms = (RC = 0)\n      \"LMQuery DataID(&DID) LRecL(SysLRecL) RecFm(SysRecFm)\",\n         \"DSOrg(SysDSOrg)\"\n      if oRC < 12 then \"LMClose DataID(&DID)\"\n      if ZTerm <> '3278' & ZTerm <> '3278A' then\n         \"Select Pgm(ISPTTDef) Parm(\"ZTerm\")\"\n      if zParms = 0 then exit\n      if Left(SysRecFm,1) = 'V' then SysLRecL = SysLRecL+4\n      ArcDSN = DSN                        /* self-archived */\n      address\n   end\n   if Left(SysDSOrg,2) <> 'PO' then exit  /* archive must be PDS */\n   if Left(SysRecFM,2) = 'FB' & SysLRecL = 80 then LKWMTbl = 'Z{LKWM{'\nend\n\n/* Make sure LRecL is long enough */\nif SysLRecL < 80 | SysLRecL < LRecL then exit\n\n/* O.K. - set up for archiving */\nOpts = 'Hist(5) NoArc NoSync Desc'        /* Defaults */\nparse VALUE 5 1 1 1 0 WITH Hist NoArc NoSync Desc Quiet\n\n/*\nSrc = \"H224.ARCHIVE.SOURCE\"\naddress TSO,\n   \"AltLib ACTIVATE APPLICATION (EXEC) DATASET('\"Src\"') UNCOND\"\nif RC <> 0 then exit */               /* No archive source library! */\n\naddress ISPExec\n\"Control ERRORS RETURN\"        /* No ugly dialog boxes */\n/* \"LIBDEF ISPPLIB DATASET ID('\"Src\"') STACK\" */\nArcTbl = ''\n\"TbCreate archive NOWRITE SHARE KEYS(ArcKey)\",\n   \"Names(DSOrg ArcDSN ArcTbl ArcVol LKWMTbl Opts\",\n         \"DL Desc1 Desc2 Desc3 Desc4 Desc5 Desc6)\"\nif RC = 8 then do\n   \"TbOpen archive NOWRITE SHARE\"\n   \"TbGet archive\"\nend\n\nif ArcTbl <> '' then \"TbOpen &ArcTbl NOWRITE SHARE\"\nelse do\n   do i=1 to 99 until RC = 0\n      ArcTbl = 'ARC'i\n      \"TbCreate &ArcTbl NOWRITE SHARE KEYS(Mod)\",\n         \"Names(User Vers HL Hist1 Hist2 Hist3 Hist4 Hist5 Hist6)\"\n   end\n   if RC = 0 then \"TbAdd archive\"  /* Save the archive data */\nend\nif RC <> 0 then exit 12            /* major failure */\n\n/* These definitions add archive processing to ISPF commands. */\naddress ISREdit\nif Sess = 'VIEW' then\n   \"Define END     ALIAS A#CAN\"\nelse do\n   \"Define END     ALIAS A#END\"\n   \"Define SAVE    ALIAS A#SAVE\"\nend\n\"Define CANCEL  ALIAS A#CAN\"\n\"Define COMPARE ALIAS A#CMP\"\n\"Define HIST    ALIAS A#VHIST\"\n\"Define HISTORY ALIAS A#VHIST\"\n\"Define OPTS    ALIAS A#OPT\"\n\"Define OPTIONS ALIAS A#OPT\"\n\"Define RESTORE ALIAS A#REST\"\n\"Define VIEW    ALIAS A#VIEW\"\n\n/* Copy the member to the Last Known Working Member if required. */\naddress ISPExec\nif LKWMTbl <> '' then do\n   address TSO \"Alloc f(arc) dsn('\"ArcDSN\"')\" ArcVol \"SHR REUSE\"\n   \"TbOpen\" LKWMTbl \"NOWRITE Library(ARC)\"\n   if RC = 0 then do\n      \"TbGet\" LKWMTbl\n      GotLKWM = (RC = 0 & LKWM <> '')\n      \"TbClose\" LKWMTbl\n      if GotLKWM then do\n         DoCopy = 0\n         \"LMOpen DataID(&DID)\"\n         \"LMMFind DataID(&DID) Member(&Mem) Stats(YES)\"\n         cMod = ZLM4Date ZLMTime':'ZLMSec\n         if Mod > cMod then do\n            \"LMMFind DataID(&DID) Member(&LKWM) Stats(YES)\"\n            if RC = 8 then lMod = ''\n            else lMod = ZLM4Date ZLMTime':'ZLMSec\n            if cMod > lMod then DoCopy = 1\n         end\n         \"LMClose DataID(&DID)\"\n         if DoCopy then do\n            \"LMInit DataID(ToID) DataSet('\"DSN\"')\" ArcVol\n            \"LMCopy FromID(&DID) FromMem(&Mem)\",\n               \"ToDataID(&ToID) ToMem(&LKWM) REPLACE\"\n            \"LMFree DataID(&ToID)\"\n         end\n      end\n   end\n   \"TbStats BADTABLE Library(BADLIB)\" /* workaround for ISPF bug */\n   address TSO \"Free f(arc)\"\nend\n\n/* Set CAPS OFF for messages. */\naddress ISREdit\n\"(CM) = CAPS\"\n\"CAPS = OFF\"\nGlobal = ''                           /* Set up for Global opts */\nif zParms = 0 & Mem <> '' then do\n   address ISPExec\n   \"LMInit DataID(ArcID) DataSet('\"ArcDSN\"')\" ArcVol\n   \"LMOpen DataID(&ArcID)\"\n   \"LMMFind DataID(&ArcID) Member(Z{PARMS{)\"\n   zParms = (RC = 0)\n   \"LMClose DataID(&ArcID)\"\n   \"LMFree DataID(&ArcID)\"\nend\naddress TSO\nif zParms then do\n   \"Alloc f(in) dsn('\"ArcDSN\"(Z{PARMS{)')\" ArcVol \"SHR REUSE\"\n   \"ExecIO * DiskR in (STEM Parms. FINIS\"\n   \"Free f(in)\"\n   do i=1 to Parms.0\n      parse VAR Parms.i 2 Type Info\n      if Translate(Type) = 'OPTS' then Global = Global Info\n   end\n   Global = Space(Global)\n   interpret a#Opts(Global)\nend\nOpts = Opts'00'x||Global\naddress ISPExec \"TbMod archive\"\nparse VALUE A#Open('ARC',ArcKey,'READ') WITH Archive .\nif Archive = '' then do               /* No archive member */\n   address ISREdit\n   if NoArc then\n      \"LINE_AFTER 0 = MSGLINE 'No archive exists for this member'\"\n   \"CAPS = &CM\"\n   exit                               /* OK - continue editing. */\nend\n\nline = 1\nparse VALUE '0' WITH dl,Desc1,Desc2,Desc3,Desc4,Desc5,Desc6\nparse VALUE '0' WITH hl,Hist1,Hist2,Hist3,Hist4,Hist5,Hist6\nparse VALUE '0' WITH Data,Mbr\ndo forever\n   \"ExecIO 1 DiskR arc\" line\n   if RC <> 0 then leave\n   line = line+1\n   pull 2 Type . 'HEADER('Header')' 1 'DATA('Data')' 1 'MEMBER('Mbr')'\n   if Header = '' then Header = 0\n   if Data = '' then Data = 0\n   if Header = 0 then Head.0 = 0\n   else \"ExecIO\" Header \"DiskR arc\" line \"(STEM Head.\"\n   line = line + Header\n   if WordPos(Type,'CURRENT ARCHIVE') = 0 then leave  /* error */\n   parse VALUE '00.00' WITH pVers pUser pMod\n   if Head.0 = 0 then do\n      if Type = 'CURRENT' then ArcVers = pVers\n      else do\n         address ISPExec \"TbAdd\" ArcTbl\n         parse VALUE '0' WITH hl,Hist1,Hist2,Hist3,Hist4,Hist5,Hist6\n      end\n   end; else do\n      Local = ''                      /* Set up for Local opts */\n      do i=1 to Head.0\n         parse UPPER VAR Head.i 2 Op .\n         Select\n         When Op = 'OPTS' then Local = Local||'00'x SubWord(Head.i,2)\n         When Op = 'STATS' then do\n            parse UPPER VAR Head.i,\n               'VERSION('pVers')' 1 'USER('pUser')' 1 'MODIFIED('pMod')'\n            end\n         When Op = 'HIST' then do\n            hl = hl+1\n            parse VALUE Strip(Head.i) WITH . '(' Info\n            call Value 'HIST'hl, Left(Info,Length(Info)-1)\n            end\n         When Op = 'DESC' then do\n            dl = dl+1\n            parse VALUE Strip(Head.i) WITH . '(' Info\n            call Value 'DESC'dl, Left(Info,Length(Info)-1)\n            end\n         Otherwise nop\n         End\n      end\n      if Type <> 'CURRENT' then do\n         address ISPExec \"TbAdd\" ArcTbl\n         parse VALUE '0' WITH hl,Hist1,Hist2,Hist3,Hist4,Hist5,Hist6\n      end; else do\n         interpret a#Opts(Local)\n         Opts = Opts||Local\n         address ISPExec \"TbMod archive\"\n         ArcVers = pVers\n      end\n   end\n   Vers = pVers; User = pUser; Mod = pMod\n   line = line + Data\nend\n\"ExecIO 0 DiskR arc (FINIS\"\n\"Free f(arc)\"\naddress ISPExec \"TbQuery\" ArcTbl \"RowNum(Rows)\"\naddress ISREdit\nif Rows = 0 & Data = 0 & Mbr = '' then do  /* No archive data */\n   if Mem = '' then type = 'dataset'\n   else type = 'member'\n   if NoArc then\n      \"LINE_AFTER 0 = MSGLINE 'There is no history for this &type'\"\n   \"CAPS = &CM\"\n   exit\nend\naddress ISPExec \"TbAdd\" ArcTbl\n\n/* Put the recent change history in message lines on the display */\naddress ISPExec\n/* archive description */\nif Desc then do i=1 to dl\n   push Value('DESC'i)\nend\nif Queued() > 0 then push ' '\n\n/* recent change history */\n\"TbTop\" ArcTbl\ndo v=1 to Hist\n   \"TbSkip\" ArcTbl\n   if RC > 0 then leave\n   if Mod <> '' then Mod = 'Modified at' Mod\n   if User <> '' then User = 'by' User\n   push 'v'Vers Mod User\n   do i=1 to hl\n      push '       'Value('HIST'i)\n   end\nend\naddress ISREdit\ndo Queued()\n   parse PULL Data\n   \"LINE_AFTER 0 = NOTELINE (Data)\"\nend\nif Mem <> '' then do\n   VV = ''; LL = ''\n   \"(VV) = VERSION\"\n   \"(LL) = LEVEL\"\n   DiskVers = Right(VV,2,0)'.'Right(LL,2,0)\n   /* No disk stats and disk stats of 01.00 get VV.LL of 01.00 */\n   if DiskVers = '01.00' then do\n      parse VALUE '' WITH ZLVers,ZLMod\n      address ISPExec\n      \"LMOpen DataID(&DID)\"\n      \"LMMFind DataID(&DID) Member(&Mem) Stats(YES)\"\n      \"LMClose DataID(&DID)\"\n      DiskVers = Right(ZLVers,2,0)'.'Right(ZLMod,2,0)\n      address\n   end\n   if DiskVers <> ArcVers & NoSync then\n      \"LINE_AFTER 0 = MSGLINE\",\n         \"'WARNING: Current v&DiskVers differs from archive v&ArcVers'\"\nend\n\"CAPS = &CM\"\nexit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "A#MAKE": {"ttr": 1798, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x16\\x00'\\x01\\x05!o\\x01\\x07\\x15\\x7f\\x12@\\x00\\x92\\x00n\\x00\\x00\\xc8\\xf2\\xf2\\xf4@@@@@@\"", "ispf": {"version": "01.22", "flags": 0, "createdate": "2005-08-04T00:00:00", "modifydate": "2007-06-06T12:40:27", "lines": 146, "newlines": 110, "modlines": 0, "user": "H224"}, "text": "/* Rexx function to make a temporary dataset containing a specific\n*  Dataset(Member) at a specific Version() User() Modified() level.\n*  Usage: a#Make(ArcKey,Stats)\n*  Returns the dataset name of the temporary dataset.\n*  ArcKey is in the format Volume:DSN(Member),\n*  Stats is in the format\n*  Version(vv.ll) User(uuuuuuu) Modified(yyyy/mm/dd hh:mm:ss)\n*.\n*. 2005/12/02 Use the archive copy, not the edited dataset.\n*. 2005/08/09 Created by bsquare\n*/\narg ArcKey,Stats\nif ArcKey = '' then signal Macro\nparse VAR ArcKey Vol ':' DSN\nif DSN = '' then parse VAR Vol DSN,Vol\nparse VAR DSN DSN '('Mem')'\nif DSN = '' then return ''\n\nif Vol <> '' then Vol = ' VOLUME('Vol')'\nif ListDSI(\"'\"DSN\"'\"Vol) <> 0 then return ''\nRecFm = Left(SysRecFm,1)\nif RecFm <> 'F' & RecFm <> 'V' then return ''\n\n/* Find LLQ of ArcKey */\nLLQ = Translate(DSN,,'.')\nLLQ = Word(LLQ,Words(LLQ))\nTemp = 'DS'Right(Time('S'),5,0)\nTempDS = 'TEMP.'Temp'.'LLQ\naddress TSO\n\"Alloc f(\"Temp\") dsn(\"TempDS\") NEW CATALOG\",\n   \"RecFm(\"RecFM \"B) LRecL(\"SysLRecL\") DSOrg(PS) SPACE(15,15) TRACKS\"\nif RC <> 0 then return ''\n\"Free f(\"Temp\")\"\n\naddress ISPExec\n\"VPut (ArcKey Stats) SHARED\"\n\"Edit DataSet(\"TempDS\") MACRO(a#Make)\"\nreturn TempDS\n\nMacro:\n   address ISPExec\n   \"Control ERRORS RETURN\"\n   \"VGet (ArcKey Stats) SHARED\"\n   if RC <> 0 then return\n   address ISREdit\n   \"Macro\"\n   if RC <> 0 then return\n\n   parse VALUE a#Open('IN',ArcKey,'READ') WITH Archive VolInfo\n   if Archive = '' then signal Cancel\n   address TSO\n   \"ExecIO * DiskR in (STEM Arc. FINIS\"\n   \"Free f(in)\"\n\n   address ISREdit\n   parse VAR ArcKey Vol ':' DSN\n   if DSN = '' then parse VAR Vol DSN,Vol\n\n   /* Set up the initial dataset contents */\n   if Arc.0 = 0 then signal Cancel          /* empty archive */\n   parse UPPER VAR Arc.1 2 Section . 'HEADER('Header')',\n         1 'DATA('Data')' 1 'MEMBER('Mem')'\n   if Section <> 'CURRENT' then signal Cancel /* bad archive */\n   if Header = '' then Header = 0\n   if Data <> '' then do\n      do i=1 to Data\n         Cur = Value('ARC.'Header+i+1)\n         \"LINE_AFTER\" i-1 \"= (Cur)\"\n      end\n   end; else do\n      if Mem = '' then signal Cancel        /* No archive copy! */\n      parse VAR Archive ArcDSN '('\n      ArcCopy = ArcDSN'('Mem')'\n      if VolInfo = '' then do\n         \"COPY '\"ArcCopy\"' BEFORE .ZFIRST\"\n         if RC <> 0 then signal Cancel      /* No archive copy! */\n      end; else do\n         address TSO\n         \"Alloc f(in) dsn('\"ArcCopy\"')\"VolInfo \"SHR REUSE\"\n         if RC <> 0 then signal Cancel\n         \"ExecIO * DiskR in (STEM In. FINIS\"\n         \"Free f(in)\"\n         address ISREdit\n         do i=1 to In.0\n            Cur = In.i\n            \"LINE_AFTER\" i-1 \"= (Cur)\"\n         end\n      end\n   end\n   if Data = '' then Data = 0\n\n   parse UPPER VAR Stats,\n      'VERSION('Vers')' 1 'USER('User')' 1 'MODIFIED('Mod')'\n   if Mod <> '' then Key = 'MOD'\n   else if Vers <> '' then Key = 'VERS'\n   else Key = 'USER'\n   ln = 2\n   do until ln > Arc.0 | Value(Key) = Value('A'Key)\n      aVers = '00.00'; aUser = ''; aMod = ''\n      do Header\n         parse UPPER VALUE ln+1||Arc.ln WITH ln '-' Type Info\n         if Type <> 'STATS' then iterate\n         parse VAR Info,\n            'VERSION('aVers')' 1 'USER('aUser')' 1 'MODIFIED('aMod')'\n      end\n      last = ln+Data\n      offset = 0                   /* line offset */\n      if Section = 'ARCHIVE' then do while ln < last\n         parse UPPER VALUE ln+1||Arc.ln WITH ln '-' Type Info\n         Select\n         When Type = 'INS' then do          /* Insert Lines at Start */\n            parse VAR Info 'LINES('Lines')' 1 'START('Start')'\n            Start = Start-1\n            do i=ln to ln+Lines-1\n               Cur = Arc.i\n               \"LINE_AFTER &Start = (Cur)\"\n               Start = Start+1\n            end\n            ln = ln+Lines\n            offset = offset + Lines\n            end\n         When Type = 'DEL' then do\n            parse VAR Info 'COUNT('Count')' 'START('Start')'\n            Start = Start + offset\n            do Count\n               \"DELETE &Start\"\n            end\n            offset = offset - Count\n            end\n         Otherwise nop\n         End\n      end\n      ln = last\n      parse UPPER VALUE ln+1||Arc.ln WITH ln ')' Section Info\n      if Section <> 'ARCHIVE' then leave\n      parse VAR Info 'HEADER('Header')' 1 'DATA('Data')'\n      if Header = '' then Header = 0\n      if Data   = '' then Data   = 0\n   end\n   \"BUILTIN SAVE\"\n   \"BUILTIN END\"\n   exit\n\nCancel: /* Cancel the macro - major error */\n   address ISREdit \"CANCEL\"\n   exit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "A#OPEN": {"ttr": 1802, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x11\\x00\\x13\\x01\\x05!o\\x01\\x05\"\\x9f\\x08%\\x00\\x80\\x00\\x8a\\x00\\x00\\xc8\\xf2\\xf2\\xf4@@@@@@'", "ispf": {"version": "01.17", "flags": 0, "createdate": "2005-08-04T00:00:00", "modifydate": "2005-08-17T08:25:13", "lines": 128, "newlines": 138, "modlines": 0, "user": "H224"}, "text": "/* Rexx function to open the archive(member) for a given\n*  Dataset(Member).  This will be slightly different for READ and WRITE.\n*  Usage: a#Open(DD,ArcKey,Purpose)\n*  Returns archive\u00dd(member)\u00a8 \u00ddVOLUME(volser)\u00a8 or '' on failure.\n*  ArcKey is in the format Volume:DSN(Member),\n*  Purpose is either READ or WRITE.\n*.\n*. 2005/08/04 Created by bsquare\n*. 2005/08/17 Add ISPTTDef for strange terminal types.\n*.            LMMFind screws up with terminal types other than 3278(a).\n*/\narg DD,ArcKey,Purpose\nif DD = '' then return ''\nparse VAR ArcKey Vol ':' DSN\nif DSN = '' then parse VAR ArcKey DSN,Vol\nparse VAR DSN DSN '('Mem')'\nif DSN = '' then return ''\nif Purpose = '' then Purpose = 'READ'\nif Purpose <> 'READ' & Purpose <> 'WRITE' then return ''\n\naddress TSO\nif Right(DSN,4) = '.ARC' then return ''\nif Right(Mem,1) = '{' then return ''\n\n/* Use volume information for uncataloged datasets */\nIsCat = ListDSI(\"'\"DSN\"'\") = 0\nif IsCat & Vol <> '' then IsCat = (SysVolume = Vol)\nif IsCat then Vol = ''\nelse Vol = ' VOLUME('Vol')'\n\n/* Check the control dataset (the archive). */\nSysDSOrg = 'BAD'\nArcDSN = DSN'.ARC'\nif Length(ArcDSN) <= 44 then call ListDSI \"'\"ArcDSN\"'\"||Vol\n\n/* Check sequential datasets first, they're simpler */\nif Mem = '' then do\n   if Left(SysDSOrg,2) <> 'PS' then return ''\n   if Purpose = 'READ' then\n        \"Alloc f(\"DD\") dsn('\"ArcDSN\"') SHR REUSE\"\n   else \"Alloc f(\"DD\") dsn('\"ArcDSN\"') OLD REUSE\"\n   if RC <> 0 then return ''\n   return ArcDSN\nend\n\n/* The remainder of this is only for PDS archives */\nif Left(SysDSOrg,2) <> 'PO' then ArcDSN = DSN\nArcMem = Strip(Left(Mem,7))'{'\n\naddress ISPExec\n\"VGet (ZTerm)\"\nif ZTerm <> '3278' & ZTerm <> '3278A' then\n   \"Select Pgm(ISPTTDEF) Parm(3278)\"\n\"LMInit DataID(DID) DataSet('\"ArcDSN\"')\"Vol \"ENQ(SHRW)\"\n\"LMOpen DataID(&DID)\"\n\"LMMFind DataID(&DID) Member(&ArcMem)\"\nif RC = 0 then\n   \"LMGet DataID(&DID) Mode(INVAR) MaxLen(80) DataLoc(Data) DataLen(Len)\"\nif RC <> 0 then signal NoMem\n\nparse UPPER VAR Data 2 Type Info\nif Type = 'RESOLVE' then do\n   parse VAR Info 'ID('ConID')'\n   ArcMem = 'Z{'Right(ConID,4,0)||SubStr(Mem,8)||'{'\n   \"LMMFind DataID(&DID) Member(&ArcMem)\"\n   if RC <> 0 then signal NoMem\n   call RetMem ArcDSN'('ArcMem')'\nend\n/* Type = 'CURRENT' */\nparse VAR Info 'MEMBER('aMem')'\nif aMem = Mem then call RetMem ArcDSN'('ArcMem')'\nif Purpose = 'READ' then call RetMem\n\n/* Resolve contention for WRITE */\nParms. = 0\nConID = ''\n\"LMMFind DataID(&DID) Member(Z{PARMS{)\"\nif RC = 0 then do\n   address TSO\n   \"Alloc f(in) dsn('\"ArcDSN\"(Z{PARMS{)')\"Vol \"SHR REUSE\"\n   \"ExecIO * DiskR in (STEM Parms. FINIS\"\n   \"Free f(in)\"\n   do i=1 to Parms.0\n      parse UPPER VAR Parms.i 2 Type Info\n      if Type <> 'RESOLVE' then iterate\n      pl = i\n      parse UPPER VAR Parms.i . 'ID('ConID')'\n      leave\n   end\nend\nif ConID <> '' then ConID = Right(ConID+1,4,0)\nelse do\n   ConID = '0000'\n   pl = Parms.0+1; Parms.0 = pl\nend\nParms.pl = ')Resolve ID('ConID')'\naddress TSO\n\"Alloc f(out) dsn('\"ArcDSN\"(Z{PARMS{)')\"Vol \"SHR REUSE\"\n\"ExecIO\" Parms.0 \"DiskW out (STEM Parms. FINIS\"\n\"Free f(out)\"\nOldArc = 'Z{'ConID||SubStr(aMem,8)||'{'\naddress ISPExec\n\"LMClose DataID(&DID)\"\n\"LMOpen DataID(&DID) Option(OUTPUT)\"\n\"LMMRen DataID(&DID) Member(&ArcMem) NewName(&OldArc)\"\nData = Parms.pl\n\"LMPut DataID(&DID) Mode(INVAR) DataLoc(Data) DataLen(80)\"\n\"LMMAdd DataID(&DID) Member(&ArcMem) Stats(NO)\"\nArcMem = 'Z{'ConID||SubStr(Mem,8)||'{'\ncall RetMem ArcDSN'('ArcMem')'\n\nNoMem:\n   if Purpose = 'READ' then call RetMem\n   else call RetMem ArcDSN'('ArcMem')'\n\nRetMem:\n   arg DSN\n   address ISPExec\n   \"LMClose DataID(&DID)\"\n   \"LMFree DataID(&DID)\"\n   if ZTerm <> '3278' & ZTerm <> '3278A' then\n      \"Select Pgm(ISPTTDEF) Parm(\"ZTerm\")\"\n   if DSN <> '' then do\n      address TSO,\n         \"Alloc f(\"DD\") dsn('\"DSN\"')\"Vol \"SHR REUSE\"\n      if RC <> 0 then exit ''\n   end\n   exit DSN||Vol\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "A#OPT": {"ttr": 1805, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01N\\x00Q\\x01\\x05#\\x8f\\x01\\t\\x12\\x7f\\x08S\\x00\\xd0\\x00\\x1a\\x00\\x00\\xc8\\xf2\\xf2\\xf4@@@@@@'", "ispf": {"version": "01.78", "flags": 0, "createdate": "2005-08-26T00:00:00", "modifydate": "2009-05-07T08:53:51", "lines": 208, "newlines": 26, "modlines": 0, "user": "H224"}, "text": "/* Rexx edit macro to set options for an archive (global or local).\n*  Usage: Install using #CONFIG.\n*.\n*. 2005/08/26 Created by bsquare\n*. 2005/09/06 Fix for sequential datasets (remove LKWM).\n*. 2005/09/07 Check for LKWM allowable (set in a#Init).\n*/\naddress ISREdit \"Macro\"\nisMacro = (RC = 0)\nif isMacro then do     /* called as edit macro */\n   address ISREdit\n   \"(Vol) = VOLUME\"\n   \"(DSN) = DATASET\"\n   \"(Mem) = MEMBER\"\n   ArcKey = Vol':'DSN'('Mem')'\n   address ISPExec\n   \"TbGet archive\"\nend; else do           /* called from dataset or member list */\n   address ISPExec\n   Info = a#Info(arg(1))\n   if Info = '' then do\n      ZEdLMsg = 'Unable to obtain option information for' arg(1)\n      ZEdSMsg = 'No Archive Opts'\n      address ISPExec \"SetMsg Msg(ISRZ000)\"\n      exit 8\n   end\n   \"VGet\" Info \"SHARED\"\n   parse VAR ArcKey ':'DSN'('Mem')'\n   if ArcTbl <> '' then \"TbEnd &ArcTbl\"\nend\nCopy = DSN             /* used for LKWM */\nif Mem <> '' then DSN = DSN'('Mem')'\nLKWM = ''\nif LKWMTbl <> '' then do\n   address TSO \"Alloc f(arc) dsn('\"ArcDSN\"')\" ArcVol \"SHR REUSE\"\n   \"TbOpen\" LKWMTbl \"NOWRITE Library(ARC)\"\n   if RC = 0 then do\n      \"TbGet\" LKWMTbl\n      \"TbClose\" LKWMTbl\n   end\nend\nPanel.MEMBER  = 'a#OptMP'\nPanel.DATASET = 'a#OptDP'\n\nif DSOrg = 'PS' then\n   parse VAR Opts Def '00'x . '00'x DataSet,Member\nelse\n   parse VAR Opts Def '00'x DataSet '00'x Member\nDataSet = Space(Translate(DataSet,,'00'x))\nMember  = Space(Translate(Member ,,'00'x))\noDS = DataSet; oMem = Member\nif LKWM <> '' | Member <> '' then OptType = 'MEMBER'\nelse OptType = 'DATASET'\nparse VALUE 0 LKWM WITH Accept OldLKWM .,CopyLKWM\ndo until RV <> 0\n   parse VALUE WITH Hist,Desc,NoArc,NoSync,Quiet\n   interpret a#Opts(Value(OptType))\n   if Hist Desc NoArc NoSync = '0 0 0 0' then\n      parse VALUE 1 WITH Quiet,Hist,Desc,NoArc,NoSync\n   if Mem = '' & OptType = 'MEMBER' then do\n      OptType = 'DATASET'\n      say 'Hey!!'\n   end\n   oType = OptType\n   \"Display Panel(\"Panel.OptType\")\"\n   RV = RC\n   Vars = 'Hist Desc NoArc NoSync Quiet'\n   call Value oType,''\n   do while Vars <> ''\n      parse VAR Vars v Vars\n      Val = Strip(Value(v))\n      if Val = 'YES' then call Value oType,Value(oType) v\n      else if Val <> '' then\n         call Value oType,Value(oType) v||'('Val')'\n   end\nend\nif LKWMTbl <> '' then do\n   if Accept then do\n      if LKWM = '' then CopyLKWM = ''\n      if CopyLKWM <> '' then do\n         if isMacro then\n            address ISREdit \"(DID) = DATAID\"\n         else\n            \"LMInit DataID(DID) DataSet('\"Copy\"')\" ArcVol\n         address ISPExec\n         \"LMInit DataID(ToID) DataSet('\"Copy\"')\" ArcVol\n         \"LMCopy FromID(&DID) FromMem(&Mem)\",\n            \"ToDataID(&ToID) ToMem(&LKWM) REPLACE\"\n         \"LMFree DataID(&ToID)\"\n         if \\isMacro then \"LMFree DataID(&DID)\"\n      end\n      if OldLKWM <> LKWM | CopyLKWM <> '' then do\n         Mod = Translate('1234/56/78',Date('S'),'12345678') Time()\n         \"TbOpen\" LKWMTbl \"Library(ARC)\"\n         if RC <> 0 then\n            \"TbCreate\" LKWMTbl \"Keys(Mem) Names(LKWM Mod) Library(ARC)\"\n         if LKWM <> '' then \"TbMod\" LKWMTbl\n         else \"TbDelete\" LKWMTbl\n         \"TbClose\" LKWMTbl \"Library(ARC)\"\n      end\n   end\n   \"TbStats BADTABLE Library(BADLIB)\" /* workaround for ISPF bug */\n   address TSO \"Free f(arc)\"\nend\n/* normalize options for test */\nDataSet = Space(DataSet)\nMember  = Space(Member)\n/* quit if there is nothing to do */\nif Accept = 0 | (oDS = DataSet & oMem = Member) then exit\n\n/* Set Global and Local from DataSet and Member */\nif DSORg = 'PS' then do; Loc = DataSet; Global = ''; end\nelse do; Global = DataSet; Loc = Member; end\nLocal = ''                          /* split options into lines */\ndo while Loc <> ''\n   p = LastPos(' ',Loc' ',70)\n   parse VAR Loc cur =(p) Loc\n   Local = Local||'00'x||cur\nend\nLocal = SubStr(Local,2)\n\nOpts = Def'00'x||Global'00'x||Local\nif isMacro then \"TbMod archive\"     /* update options in table */\n\n/* cLocal  = Local options changed */\n/* cGlobal = Global options changed */\ncLocal  = (DSOrg = 'PS' & oDS <> DataSet) | (Mem <> '' & oMem <> Member)\ncGlobal = (DSOrg = 'PO' & oDS <> DataSet)\nif cLocal then do                   /* local options changed */\n   parse VALUE '0 0' WITH Arc.0 Head.0,Data,Mbr\n   if a#Open('IN',ArcKey,'READ') <> '' then do\n      address TSO\n      \"ExecIO 1 DiskR in\"\n      if RC = 0 then do\n         pull 'HEADER(' Hdr ')' 1 'DATA(' Data ')' 1 'MEMBER(' Mbr ')'\n         if Hdr <> '' then \"ExecIO\" Hdr \"DiskR in (STEM Head.\"\n         do i=1 to Head.0\n            if Translate(Word(Head.i,1)) = '-OPTS' then Head.i = ''\n         end\n      end\n      \"ExecIO * DiskR in (STEM Arc. FINIS\"\n      \"Free f(in)\"\n   end\n   if a#Open('OUT',ArcKey,'WRITE') <> '' then do\n      do i=1 to Head.0\n         if Head.i <> '' then queue Head.i\n      end\n      do while Local <> ''\n         parse VAR Local cur '00'x Local\n         queue '-Opts' cur\n      end\n      Extra = ''\n      if Data <> '' then Extra = Extra 'Data('Data')'\n      if Mbr  <> '' then Extra = Extra 'Member('Mbr')'\n      if Queued() = 0 & Extra = '' & Arc.0 = 0 then\n         \"ExecIO 0 DiskW out (OPEN FINIS\"      /* truncate */\n      else do\n         push ')Current Header('Queued()')'||Extra\n         \"ExecIO\" Queued() \"DiskW out\"\n         \"ExecIO\" Arc.0 \"DiskW out (STEM Arc. FINIS\"\n      end\n      \"Free f(out)\"\n   end\nend\nif cGlobal then do                  /* global options changed */\n   address ISPExec\n   \"VGet (ZTerm)\"                   /* deal with strange term types */\n   if ZTerm <> '3278' & ZTerm <> '3278A' then\n      \"Select Pgm(ISPTTDef) Parm(3278)\"\n   \"LMInit DataID(DataID) DataSet('\"ArcDSN\"')\" ArcVol\n   \"LMOpen DataID(&DataID)\"\n   \"LMMFind DataID(&DataID) Member(Z{PARMS{)\"\n   Exists = (RC = 0)                /* this member already exists. */\n   \"LMClose DataID(&DataID)\"\n   \"LMFree DataID(&DataID)\"\n   if ZTerm <> '3278' & ZTerm <> '3278A' then\n      \"Select Pgm(ISPTTDef) Parm(\"ZTerm\")\"\n   address TSO\n   if Exists then do\n      \"Alloc f(arc) dsn('\"ArcDSN\"(Z{PARMS{)')\" ArcVol \"SHR REUSE\"\n      \"ExecIO * DiskR arc (STEM Arc. FINIS\"\n      \"Free f(arc)\"\n   end; else Arc.0 = 0\n   if DataSet = '' then Opts = ''\n   else Opts = ')Opts' Strip(DataSet)\n   \"Alloc f(arc) dsn('\"ArcDSN\"(Z{PARMS{)')\" ArcVol \"SHR REUSE\"\n   \"ExecIO 0 DiskW arc (OPEN\"       /* force truncation */\n   do while Length(Opts) > 80\n      p = LastPos(' ',Opts' ',79)\n      parse VAR Opts cur =(p) Opts\n      queue cur\n      \"ExecIO 1 DiskW arc\"\n      if Opts <> '' then Opts = ')Opts' Strip(Opts)\n   end\n   if Opts <> '' then do\n      queue Opts\n      \"ExecIO 1 DiskW arc\"\n   end\n   do i=1 to Arc.0\n      parse VAR Arc.i Type Info\n      if Translate(Type) <> ')OPTS' then do\n         queue Strip(Arc.i)\n         \"ExecIO 1 DiskW arc\"\n      end\n   end\n   \"ExecIO 0 DiskW arc (FINIS\"\n   \"Free f(arc)\"\nend\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "A#OPTDP": {"ttr": 2052, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00T\\x01\\x05#\\x8f\\x01\\x05%\\x8f\\tC\\x008\\x00/\\x00\\x00\\xc8\\xf2\\xf2\\xf4@@@@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "2005-08-26T00:00:00", "modifydate": "2005-09-15T09:43:54", "lines": 56, "newlines": 47, "modlines": 0, "user": "H224"}, "text": ")ATTR\n _ TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(ASIS)\n ! TYPE(INPUT) INTENS(HIGH) CAPS(ON)  JUST(ASIS) PAS(ON)\n * TYPE(OUTPUT) PAS(ON)\n $ TYPE(PS)\n)BODY EXPAND(\\\\)\n%&ZUSER---- MCIT Edit Archive Control \\-\\&ZDATE-&ZTIME--\n%Option  ===>_ZCMD\\ \\+\n+\n+ Set%DataSet+Options for%&tDSN\n+                                               *GotoMem\n+\n+ Display the following upon entry to an Edit/View session:\n+      Number of versions for History:_Hist+    +(default 5)\n+                 Archive description:%&Desc    $(Change)\n+          No Archive warning message:%&NoArc   $(Change)\n+ Archive out of sync warning message:%&NoSync  $(Change)\n+               SUPPRESS ALL MESSAGES:%&Quiet   $(Change)\n+\n+\\ \\Use%END+to CANCEL or$ACCEPT+to ACCEPT the changes\\ \\+\n)INIT\n &Toggle = ''\n &Desc   = Trans(Trunc(&Desc  ,1) 0,NO 1,YES N,NO Y,YES *,' ')\n &NoArc  = Trans(Trunc(&NoArc ,1) 0,NO 1,YES N,NO Y,YES *,' ')\n &NoSync = Trans(Trunc(&NoSync,1) 0,NO 1,YES N,NO Y,YES *,' ')\n &Quiet  = Trans(Trunc(&Quiet ,1) 0,NO 1,YES N,NO Y,YES *,' ')\n &tDSN = Trunc(&DSN,'(')\n if (&Mem = &Z)\n    &GotoMem = ''\n    .ATTR(GotoMem) = 'PAS(OFF)'\n else\n    &GotoMem = '(Member Options)'\n)PROC\n if (&Toggle = 1)\n    &Desc   = Trans(Trunc(&Desc  ,1) ' ',NO N,YES Y,' ' *,' ')\n if (&Toggle = 2)\n    &NoArc  = Trans(Trunc(&NoArc ,1) ' ',NO N,YES Y,' ' *,' ')\n if (&Toggle = 3)\n    &NoSync = Trans(Trunc(&NoSync,1) ' ',NO N,YES Y,' ' *,' ')\n if (&Toggle = 4)\n    &Quiet  = Trans(Trunc(&Quiet ,1) ' ',YES Y,NO N,' ' *,' ')\n    if (&Quiet = YES)\n       &Hist = &Z\n       &Desc = &Z\n       &NoArc = &Z\n       &NoSync = &Z\n if (&Accept = 1)\n    .RESP = END\n)PNTS\n FIELD(GotoMem)  VAR(OptType) VAL(MEMBER)\n FIELD(ZPS00001) VAR(Toggle) VAL(1)\n FIELD(ZPS00002) VAR(Toggle) VAL(2)\n FIELD(ZPS00003) VAR(Toggle) VAL(3)\n FIELD(ZPS00004) VAR(Toggle) VAL(4)\n FIELD(ZPS00005) VAR(ACCEPT) VAL(1)\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "A#OPTMP": {"ttr": 2054, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01%\\x00@\\x01\\x05#\\x8f\\x01\\x05%\\x0f\\tY\\x00<\\x00 \\x00\\x00\\xc8\\xf2\\xf2\\xf4@@@@@@'", "ispf": {"version": "01.37", "flags": 0, "createdate": "2005-08-26T00:00:00", "modifydate": "2005-09-07T09:59:40", "lines": 60, "newlines": 32, "modlines": 0, "user": "H224"}, "text": ")ATTR\n _ TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(ASIS)\n ! TYPE(INPUT) INTENS(HIGH) CAPS(ON)  JUST(ASIS)\n $ TYPE(PS)\n)BODY EXPAND(\\\\)\n%&ZUSER---- MCIT Edit Archive Control \\-\\&ZDATE-&ZTIME--\n%Option  ===>_ZCMD\\ \\+\n+\n+ Set%Member +Options for%&DSN\n+                                               $(DataSet Options)\n+\n+ Display the following upon entry to an Edit/View session:\n+      Number of versions for History:_Hist+    +(default 5)\n+                 Archive description:%&Desc    $(Change)\n+          No Archive warning message:%&NoArc   $(Change)\n+ Archive out of sync warning message:%&NoSync  $(Change)\n+               SUPPRESS ALL MESSAGES:%&Quiet   $(Change)\n+\n+ For RECFM=FB,LRECL=80 archives ONLY:\n+ Set the Last Known Working Member to keep a specific version\n+ of &DSN in case of logical errors.\n+           Last Known Working Member:!LKWM    +&Mod\n+Copy the current version to the LKWM:%&CopyLKWM$(Change)\n+\n+\\ \\Use%END+to CANCEL or$ACCEPT+to ACCEPT the changes\\ \\+\n)INIT\n &Toggle = ''\n &Desc   = Trans(Trunc(&Desc  ,1) 0,NO 1,YES N,NO Y,YES *,' ')\n &NoArc  = Trans(Trunc(&NoArc ,1) 0,NO 1,YES N,NO Y,YES *,' ')\n &NoSync = Trans(Trunc(&NoSync,1) 0,NO 1,YES N,NO Y,YES *,' ')\n &Quiet  = Trans(Trunc(&Quiet ,1) 0,NO 1,YES N,NO Y,YES *,' ')\n if (&CopyLKWM \u00ac= &Z)\n    &CopyLKWM = 'Y'\n)PROC\n if (&Toggle = 1)\n    &Desc   = Trans(Trunc(&Desc  ,1) ' ',NO N,YES Y,' ' *,' ')\n if (&Toggle = 2)\n    &NoArc  = Trans(Trunc(&NoArc ,1) ' ',NO N,YES Y,' ' *,' ')\n if (&Toggle = 3)\n    &NoSync = Trans(Trunc(&NoSync,1) ' ',NO N,YES Y,' ' *,' ')\n if (&Toggle = 4)\n    &Quiet  = Trans(Trunc(&Quiet ,1) ' ',YES Y,NO N,' ' *,' ')\n    if (&Quiet = YES)\n       &Hist = &Z\n       &Desc = &Z\n       &NoArc = &Z\n       &NoSync = &Z\n if (&Toggle = 5)\n    &CopyLKWM= Trans(&CopyLKWM Y,' ' *,Y)\n if (&Accept = 1)\n    .RESP = END\n)PNTS\n FIELD(ZPS00001) VAR(OptType) VAL(DATASET)\n FIELD(ZPS00002) VAR(Toggle) VAL(1)\n FIELD(ZPS00003) VAR(Toggle) VAL(2)\n FIELD(ZPS00004) VAR(Toggle) VAL(3)\n FIELD(ZPS00005) VAR(Toggle) VAL(4)\n FIELD(ZPS00006) VAR(Toggle) VAL(5)\n FIELD(ZPS00007) VAR(ACCEPT) VAL(1)\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "A#OPTS": {"ttr": 2056, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00(\\x01\\x05\"O\\x01\\x05\"O\\t \\x00\\x17\\x00\\x17\\x00\\x00\\xc8\\xf2\\xf2\\xf4@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-08-12T00:00:00", "modifydate": "2005-08-12T09:20:28", "lines": 23, "newlines": 23, "modlines": 0, "user": "H224"}, "text": "/* Rexx function to return a line of executable rexx code given an\n*  option string.\n*  Usage: a#Opts(String)\n*  Returns 1 line of Rexx code which can be executed with interpret.\n*.\n*. 2005/08/12 Created by bsquare\n*/\nKeyWords = 'QUIET HIST NOARC NOSYNC DESC'\narg Opts\nOpts = Translate(Opts,,'00'x)    /* '00'x is used as a separator */\nret = ''\ndo Words(Opts)\n   parse VAR Opts o Opts\n   parse VAR o Name '(' Val ')'\n   if WordPos(Name,KeyWords) = 0 then iterate\n   if Val = '' then Val = 1\n   if Val = 'YES' then Val = 1\n   if Val = 'NO' then Val = 0\n   if Name = 'QUIET' & Val = 1 then\n      ret = ret||'Hist=0; NoArc=0; NoSync=0; Desc=0; '\n   else ret = ret||Name\"='\"Val\"'; \"\nend\nreturn ret\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "A#REST": {"ttr": 2058, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00%\\x01\\x05\"?\\x01\\x053o\\x12 \\x00L\\x003\\x00\\x00\\xc8\\xf2\\xf2\\xf4@@@@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "2005-08-11T00:00:00", "modifydate": "2005-12-02T12:20:25", "lines": 76, "newlines": 51, "modlines": 0, "user": "H224"}, "text": "/* Rexx program to restore the current edit session to a previous\n*  version.\n*  Usage: Install using #CONFIG.\n*  The macro will a#Make the correct version and copy it in.\n*.\n*. 2005/08/11 Created by bsquare\n*/\naddress ISREdit\n\"Macro (parm)\"\nif Parm = '' then Parm = -1\nRV = Translate(Parm)\nif DataType(RV,'N') then signal OK\nparse VAR RV c 2 RV\nif c = 'V' & DataType(RV,'N') & Pos('.',RV) > 0 then signal OK\n\nZEdLMsg = 'Usage: Restore \u00ddv\u00a8VV.MM'\nZEdSMsg = 'Bad version spec'\naddress ISPExec \"SetMsg Msg(ISRZ000)\"\nexit\n\nOK:\n   \"(Vol) = VOLUME\"\n   \"(DSN) = DATASET\"\n   \"(Mem) = MEMBER\"\n   \"(Changed) = DATA_CHANGED\"\n   VV = ''; LL = ''\n   \"(VV) = VERSION\"\n   \"(LL) = LEVEL\"\n   DiskVers = Right(VV,2,0)'.'Right(LL,2,0)\n   ArcKey = Vol':'DSN'('Mem')'\n   address ISPExec\n   \"TBGet archive\"\n   \"TBTop &ArcTbl\"\n   if RV < 0 then do\n      if DataType(RV,'W') = 0 then signal Err   /* not a whole number */\n      \"TBSkip &ArcTbl\"\n      if RC <> 0 then signal Err\n      RV = RV+1                      /* count skip to current version */\n      if DiskVers <> Vers then Changed = 'YES'\n      do (Changed = 'NO') - RV\n         \"TBSkip &ArcTbl\"\n         if RC <> 0 then signal Err\n      end\n      RV = Vers\n   end; else do\n      parse VAR RV VV '.' LL\n      RV = Right(VV,2,0)'.'Right(LL,2,0)\n      do until Vers = RV\n         \"TBSkip &ArcTbl\"\n         if RC <> 0 then signal Err\n      end\n   end\n   address ISREdit\n   Vers = 'VERSION('Vers') USER('User') MODIFIED('Mod')'\n   ViewDS = a#Make(ArcKey,Vers)\n   if ViewDS = '' then signal Err\n   \"X ALL\"\n   \"DEL ALL X\"\n   \"COPY\" ViewDS \"BEFORE .ZFIRST\"\n   parse VAR RV VV '.' LL\n   if VV = 0 then \"STATS OFF\"\n   else do\n      \"VERSION = (VV)\"\n      \"LEVEL   = (LL)\"\n   end\n   om = Msg('OFF')\n   address TSO \"Delete\" ViewDS\n   call Msg om\n   \"RESET\"\n   exit\n\nErr:\n   ZEdLMsg = 'The archive does not contain version' RV\n   ZEdSMsg = 'Not found'\n   address ISPExec \"SetMsg Msg(ISRZ000)\"\n   exit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "A#SAVE": {"ttr": 2061, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01c\\x00R\\x01\\x05\\x17O\\x01\\t\\x12\\x8f\\x00\\x17\\x01\\xa8\\x005\\x00\\x00\\xc8\\xf2\\xf2\\xf4@@@@@@'", "ispf": {"version": "01.99", "flags": 0, "createdate": "2005-06-23T00:00:00", "modifydate": "2009-05-08T00:17:52", "lines": 424, "newlines": 53, "modlines": 0, "user": "H224"}, "text": "/* Rexx program to save a dataset\u00dd(member)\u00a8 from ISPF edit with\n*  version control.\n*  Usage: Install using #CONFIG.\n*  When you SAVE from ISPF edit, this will check to see if a control\n*  dataset exists.  See a#Init for a description.\n*  If this data set exists, a session comparison will be done and the\n*  changes stored in the archive dataset, along with history information\n*  obtained via an ISPF panel.\n*.\n*. 2005/06/23 Created by bsquare\n*. 2005/07/08 Decided not to allow sequential datasets.\n*. 2005/07/12 Rescinded the above decision.\n*. 2005/07/21 Changed format of archive datasets.\n*. 2005/08/17 Handle odd terminal types for LMMFind bug.\n*. 2006/01/13 Fix cancelled save of existing unarchived member. (v1.1)\n*/\naddress ISREdit\n\"Macro (parms)\"\n\n/* Get information about the dataset being edited (the target). */\n\"(DID)     = DATAID\"        /* Data ID for target dataset */\n\"(Vol)     = VOLUME\"\n\"(DSN)     = DATASET\"       /* Target dataset */\n\"(Mem)     = MEMBER\"        /*        member */\nArcKey = Vol':'DSN'('Mem')' /* Key for archive table */\nif Mem = '' then Target = DSN\nelse Target = DSN'('Mem')'\n\"(Changed) = DATA_CHANGED\"\n\"(State)   = USER_STATE\"\n\n/* Get information about the control dataset (the archive). */\naddress ISPExec\n\"TbGet archive\"             /* ArcDSN ArcTbl dl Desc1-6 */\n\"TbQuery\" ArcTbl \"ROWNUM(Versions)\"\naddress ISREdit\nIsArc = (Versions > 0)\n\nStats = GetStats(DID,Mem)\n/* Treat previously deleted member as \"Stats don't match\" */\nif Stats = 'NEW' & IsArc then Stats = ''\nif Stats = 'NEW' then do\n   if Changed = 'NO' then call Done 0   /* nothing to save or archive */\n   dl = GetDesc(Target)            /* Get a description for this data */\n   address ISPExec \"TbMod archive\" /* Save the description */\n\n   /* SAVE */\n   if Mem <> '' then \"STATS ON\"  /* Make sure STATS are ON */\n   \"BuiltIn SAVE\"\n   if RC > 4 then call Fail 'SAVE Failed RC' RC\n   if Mem <> '' then Stats = GetStats(DID,Mem)\n   else do\n      Mod = Translate('Year/Mm/Dd',Date('S'),'YearMmDd') Time()\n      Stats = 'Version('IncRev()') User('UserID()') Modified('Mod')'\n   end\n   sLines = (Stats <> '')          /* should ALWAYS be 1 */\n   if sLines = 0 then Vers = '00.00'\n   else do\n      parse UPPER VAR Stats,\n         'VERSION('Vers')' 1 'USER('User')' 1 'MODIFIED('Mod')'\n   end\n   address ISPExec \"TbTop\" ArcTbl\n   address ISPExec \"TbAdd\" ArcTbl\n\n   \"(Lines)   = LINENUM .ZLAST\"\n   Lines = Lines+0               /* reformat as number */\n   parse VALUE a#Open('OUT',ArcKey,'WRITE') WITH Archive VolInfo\n   /* Copy the member to the archive PDS if required. */\n   if ArcDSN <> DSN & Archive <> ArcDSN then do\n      Copy = \"'\"ArcDSN\"'\"\n      address ISPExec\n      \"LMInit DataID(ToID) DataSet(&Copy)\" VolInfo\n      \"LMCopy FromID(&DID) FromMem(&Mem) ToDataID(&ToID) REPLACE\"\n      \"LMFree DataID(&ToID)\"\n   end\n   address TSO\n   if Mem <> '' then\n      queue ')Current Header('sLines+dl') Member('Mem')'\n   else\n      queue ')Current Header('sLines+dl') Data('Lines')'\n   if sLines > 0 then queue '-Stats' Stats\n   do i=1 to dl\n      queue '-Desc' '('Value('DESC'i)')'\n   end\n   \"ExecIO\" 1+sLines+dl \"DiskW out\"\n\n   /* Put the data inline if required. */\n   if Archive = ArcDSN then do i=0 to Lines-1 by 100\n      do j=1 until j=min(100,Lines-i)\n         address ISREdit \"(Cur) = LINE\" i+j\n         Line.j = Strip(Cur,'T')  /* small savings for VB */\n      end\n      \"ExecIO\" j \"DiskW out (STEM Line.\"\n   end\n   \"ExecIO 0 DiskW out (FINIS\"\n   \"Free f(out)\"\n   address ISREdit\nend; else do\n   OldArc.0 = 0\n   ArcStats = ''; CompDS = ''\n   if IsArc then do\n      address ISPExec\n      \"TbTop\" ArcTbl\n      \"TbSkip\" ArcTbl\n      if Vers = '00.00' then Vers = ''\n      if Vers <> '' then ArcStats = 'Version('Vers')'\n      if User <> '' then ArcStats = ArcStats 'User('User')'\n      if Mod  <> '' then ArcStats = ArcStats 'Modified('Mod')'\n      if Mem = '' then Stats = ArcStats\n      if Changed = 'NO' then do\n         /* no need to archive or save if Stats match Archive */\n         if Stats = ArcStats then call Done 0\n         /* Oops. Data changed outside of Archive. */\n         if DSN = ArcDSN then\n            call Fail 'Inconsistent versions cannot be reconciled'\n         /* Oh, good.  The old version should be in the archive. */\n         /* reconcile with old version */\n      end\n      if Stats = '' then dl = GetDesc(Target)\n      parse VALUE a#Open('IN',ArcKey,'READ') WITH Archive VolInfo\n      if Archive = '' then do   /* previously cancelled save. */\n         Header = 0; Data = ''\n         CompDS = 'SESSION'\n      end; else do\n         address TSO\n         \"ExecIO 1 DiskR in\"\n         pull 'HEADER('Header')' 1 'DATA('Data')'\n         if Header = '' then Header = 0\n         /* Obtain old data for deleted or munged members */\n         if Data <> '' then do\n            \"ExecIO\" Data \"DiskR in\" Header+2 \"(STEM Old.\"\n            if Old.0 = 0 then CompDS = 'NONE'\n            else do\n               CompDS = 'ARCHIVE.TEMP.S'Time('S')\n               \"Alloc f(tmp) dsn(\"CompDS\") NEW CATALOG DSORG(PS) LIKE('\"DSN\"')\"\n               \"ExecIO\" Data \"DiskW tmp (STEM Old. FINIS\"\n               \"Free f(tmp)\"\n            end\n         end\n         if Data <> '' then Header = Header+Data\n         /* Read archive, skipping )Current data */\n         \"ExecIO * DiskR in\" Header+2 \"(STEM OldArc. FINIS\"\n         \"Free f(in)\"\n      end\n      address ISREdit\n   end; else do\n      dl = GetDesc(Target)            /* get data description */\n      address ISPExec \"TbMod archive\" /* save the description */\n      parse UPPER VAR Stats,\n         'VERSION('Vers')' 1 'USER('User')' 1 'MODIFIED('Mod')'\n      parse VALUE '' WITH Hist1 Hist2 Hist3 Hist4 Hist5 Hist6\n      if Vers = '' then Vers = '00.00'\n      address ISPExec \"TbAdd\" ArcTbl  /* save the old version */\n      ArcStats = Stats\n      CompDS = 'SESSION'              /* no archive yet       */\n   end\n   if Changed = 'YES' | Stats <> ArcStats then do\n      /* complete replacement or difference? */\n      if CompDS = 'NONE' then do\n         \"(Lines) = LINENUM .ZLAST\"\n         Lines = Lines+0               /* reformat as number */\n         if Lines > 0 then queue '-Del Count('Lines') Start(1)'\n      end; else do\n         /* Save the old compare options for later restoration */\n         address ISPExec \"VGet (ZEDUPDOP ZUPXSIZ)\"\n         OldOpts = ZEdUpdOp; OldXSize = ZUpXSiz\n         ZEdUpdOp = '0000000000'; ZUpXSiz = 0\n         address ISPExec \"VPut (ZEDUPDOP ZUPXSIZ) ASIS\"\n\n         /* Compare to the disk copy of this dataset */\n         if CompDS = '' then\n            if ArcDSN = DSN then CompDS = 'SESSION'\n            else CompDS = \"'\"ArcDSN\"(\"Mem\")'\"\n         \"BuiltIn Compare\" CompDS \"SAVE\"\n         RV = RC\n\n         /* restore old compare options */\n         ZEdUpdOp = OldOpts; ZUpXSiz = OldXSize\n         address ISPExec \"VPut (ZEDUPDOP ZUPXSIZ) ASIS\"\n         \"Reset LABEL SPECIAL\"\n\n         if RV <> 0 then do\n            if CompDS <> 'SESSION' & Pos('(',CompDS) = 0 then do\n               prev = Msg('OFF')\n               \"Delete\" CompDS\n               call Msg prev\n            end\n            call Fail 'Unexpected error from Compare, RC' RV\n         end\n         address TSO\n         \"Alloc f(in) dsn(ISPFEDIT.COMPARE.LIST) SHR REUSE\"\n         \"ExecIO * DiskR in (STEM Compare. FINIS\"\n         \"Free f(in)\"\n         prev = Msg('OFF')\n         \"Delete ISPFEDIT.COMPARE.LIST\"\n         call Msg prev\n\n         /* Process the comparison output */\n         if CompDS = 'SESSION' then\n            \"Alloc f(from) dsn('\"Target\"') SHR REUSE\"   /* disk copy */\n         else\n            \"Alloc f(from) dsn(\"CompDS\") SHR REUSE\"     /* disk copy */\n         mark = 122\n         do i=1 to Compare.0\n            if Left(Compare.i,2) = 'ID' then\n               mark = pos('TYPE',Compare.i)\n            if SubStr(Compare.i,3,1) <> '-' then iterate\n            parse VAR Compare.i,\n               Op 3 =(mark) Type +3 +1 Len +5 +1 nLine +5 +1 oLine +5\n            Len = Strip(Len)\n            /* reformat as number */\n            nLine = ('0'nLine)+0\n            oLine = ('0'oLine)+0\n            Len   = ('0'Len)+0\n            Select\n            When Len = 0 then say Compare.i  /* ERROR! */\n            When Type = 'INS' then do    /* From lines */\n               queue '-Ins Lines('Len') Start('nLine')'\n               \"ExecIO\" Len \"DiskR from\" nLine \"(STEM Temp.\"\n               do t=1 to Len; queue Strip(Temp.t,'T'); end\n               i = i + Len - 1\n               end\n            When Type = 'DEL' then do    /* To lines */\n               queue '-Del Count('Len') Start('oLine')'\n               i = i + Len - 1\n               end\n            When Type = 'RPL' | Type = 'RFM' then do\n               queue '-Ins Lines('Len') Start('nLine')'\n               \"ExecIO\" Len \"DiskR from\" nLine \"(STEM Temp.\"\n               do t=1 to Len; queue Strip(Temp.t,'T'); end\n               queue '-Del Count('Len') Start('oLine')'\n               i = i + (Len*2) - 1\n               end\n            Otherwise say Compare.i          /* ERROR! */\n            End\n         end\n         \"ExecIO 0 DiskR from (FINIS\"\n         \"Free f(from)\"\n         if CompDS <> 'SESSION' & Pos('(',CompDS) = 0 then do\n            prev = Msg('OFF')\n            \"Delete\" CompDS\n            call Msg prev\n         end\n      end\n      address ISREdit\n      Lines = Queued()\n      if Changed <> 'YES' then do\n         hl = GetHist(Target,Vers)\n         do i=hl to 1 by -1\n            push '-Hist' '('Value('HIST'i)')'\n         end\n         if ArcStats <> '' then push '-Stats' ArcStats\n         push ')Archive Header('Queued()-Lines') Data('Lines')'\n      end; else do\n         NewRev = IncRev(Vers)\n         hl = GetHist(Target,NewRev) /* get history entry */\n         do i=hl to 1 by -1\n            push '-Hist' '('Value('HIST'i)')'\n         end\n         if Stats = '' & ArcStats <> '' then Stats = ArcStats\n         if Stats <> '' then push '-Stats' Stats\n         push ')Archive Header('Queued()-Lines') Data('Lines')'\n\n         /* SAVE */\n         if Mem <> '' then \"STATS ON\"  /* Make sure STATS are ON */\n         \"BuiltIn SAVE\"\n         if RC > 4 then call Fail 'SAVE Failed RC' RC\n         if RC = 4 & ArcStats <> '' then do\n            \"VERSION =\" Left(NewRev,2)\n            \"LEVEL   =\" Right(NewRev,2)\n         end\n         if Mem <> '' then Stats = GetStats(DID,Mem)\n         else do\n            Mod = Translate('Year/Mm/Dd',Date('S'),'YearMmDd') Time()\n            Stats = 'Version('NewRev') User('UserID()') Modified('Mod')    '\n         end\n      end\n      parse UPPER VAR Stats,\n         'VERSION('Vers')' 1 'USER('User')' 1 'MODIFIED('Mod')'\n      address ISPExec \"TbTop\" ArcTbl\n      if Vers = '' then Vers = '00.00'\n      address ISPExec \"TbAdd\" ArcTbl\n   end\n   \"(Lines)   = LINENUM .ZLAST\"\n   Lines = Lines+0               /* reformat as number */\n   parse VALUE a#Open('OUT',ArcKey,'WRITE') WITH Archive VolInfo\n   /* Copy the member to the archive PDS if required. */\n   if ArcDSN <> DSN & Archive <> ArcDSN then do\n      address ISPExec\n      Copy = \"'\"ArcDSN\"'\"\n      \"LMInit DataID(ToID) DataSet(&Copy)\"VolInfo\n      \"LMCopy FromID(&DID) FromMem(&Mem) ToDataID(&ToID) REPLACE\"\n      \"LMFree DataID(&ToID)\"\n   end\n   address TSO\n   \"NEWSTACK\"\n      parse VAR Opts Default '00'x Global '00'x Local\n      if Stats <> '' then queue '-Stats' Stats\n      if Mem = '' then\n         do while Global <> ''\n            parse VAR Global cl '00'x Global\n            queue '-Opts' Strip(cl)\n         end\n      else\n         do while Local <> ''\n            parse VAR Local cl '00'x Local\n            queue '-Opts' Strip(cl)\n         end\n      do i=1 to dl\n         queue '-Desc' '('Value('DESC'i)')'\n      end\n      if Mem <> '' then\n         push ')Current Header('Queued()') Member('Mem')'\n      else\n         push ')Current Header('Queued()') Data('Lines')'\n      \"ExecIO\" Queued() \"DiskW out\"\n\n      /* Put the data inline if required. */\n      if Archive = ArcDSN then do i=0 to Lines-1 by 100\n         do j=1 until j=min(100,Lines-i)\n            address ISREdit \"(Cur) = LINE\" i+j\n            Line.j = Strip(Cur,'T')  /* small savings for VB */\n         end\n         \"ExecIO\" j \"DiskW out (STEM Line.\"\n      end\n   \"DELSTACK\"\n   if Queued() > 0 then \"ExecIO\" Queued() \"DiskW out\"\n   if OldArc.0 > 0 then\n      \"ExecIO\" OldArc.0 \"DiskW out (STEM OldArc.\"\n   \"ExecIO 0 DiskW out (FINIS\"\n   \"Free f(out)\"\nend\ncall Done 0\n\nDone:\n   arg ret\n   address TSO \"DelStack\"        /* eliminate old garbage */\n   address ISREdit \"USER_STATE = (State)\"\nexit ret\n\n/* Get statistics for a member. */\nGetStats: PROCEDURE\n   arg DataID,Member\n   if Member = '' then return '' /* no stats for sequential dataset */\n   address ISPExec\n   \"VGet (ZTerm)\"                /* deal with strange term types */\n   if ZTerm <> '3278' & ZTerm <> '3278A' then\n      \"Select Pgm(ISPTTDef) Parm(3278)\"\n   \"LMOpen DataID(\"DataID\")\"\n   \"LMMFind DataID(\"DataID\") Member(\"Member\") STATS(YES)\"\n   Exists = (RC = 0)           /* this member already exists. */\n   \"LMClose DataID(\"DataID\")\"\n   if ZTerm <> '3278' & ZTerm <> '3278A' then\n      \"Select Pgm(ISPTTDef) Parm(\"ZTerm\")\"\n   if Exists = 0 then return 'NEW'\n\n   parse VALUE '' WITH Vers User Mod\n   if ZLVers <> '' then Vers = 'Version('ZLVers'.'ZLMod')'\n   if ZLM4Date <> '' then\n      Mod  = 'Modified('ZLM4Date ZLMTime':'ZLMSec')'\n   if ZLUser <> '' then User = 'User('Strip(ZLUser)')'\n   return Vers User Mod\n\n/* Get a description of this data from the User. */\nGetDesc: PROCEDURE EXPOSE State Desc1 Desc2 Desc3 Desc4 Desc5 Desc6\n   arg DSN\n   address ISPExec\n   if Desc1 = '' then Desc1 = 'Original' DSN 'by' UserID()\n   \"Display Panel(a#DescP)\"\n   if RC = 8 then do\n      \"VGet (ZVERB)\"\n      if ZVERB = 'END' then call Done 8\n   end\n   do i=6 to 1 by -1 until Value('DESC'i) <> ''; end\n   return i\n\n/* Get a description of these changes from the User. */\nGetHist: PROCEDURE EXPOSE State,\n   Hist1 Hist2 Hist3 Hist4 Hist5 Hist6,\n   Desc1 Desc2 Desc3 Desc4 Desc5 Desc6\n   arg DSN,Vers        /* Vers,Desc are displayed in ArcHist */\n   parse VALUE '' WITH Hist1 Hist2 Hist3 Hist4 Hist5 Hist6\n   address ISPExec\n   \"Display Panel(a#HistP)\"\n   if RC = 8 then do\n      \"VGet (ZVERB)\"\n      if ZVERB = 'END' then call Done 8\n   end\n   do i=6 to 1 by -1 until Value('HIST'i) <> ''; end\n   return i\n\n/* Increment the revision (Version.Level). */\nIncRev: PROCEDURE\n   arg OldRev\n   address ISREdit\n   \"(Mem)   = MEMBER\"\n   if Mem = '' then NewRev = OldRev\n   else do\n      \"(Vers)  = VERSION\"       /* version and */\n      \"(Level) = LEVEL\"         /* modification level */\n      if RC <> 0 then NewRev = ''\n      else NewRev = Right(Vers,2,0)'.'Right(Level,2,0)\n   end\n   if OldRev <> '' then do\n      if OldRev < 1 then NewRev = 1\n      if NewRev = '' then NewRev = OldRev\n      if NewRev = OldRev then NewRev = NewRev + 0.01\n   end; else if NewRev = '' then NewRev = 1\n   parse VAR NewRev Vers '.' Level\n   Vers = Right(Vers,2,0)\n   Level = Right(Level,2,0)\n   if Mem <> '' then do\n      \"VERSION =\" Vers\n      \"LEVEL   =\" Level\n   end\n   return Vers'.'Level\n\n/* Fail with a message. */\nFail: PROCEDURE EXPOSE State\n   parse ARG ZEdLMsg\n   ZEdSMsg = \"Archive Failure\"\n   address ISPExec \"SetMsg Msg(ISRZ000)\"\n   address TSO \"DelStack\"          /* kill old garbage */\n   address ISREdit \"USER_STATE = (State)\"\n   exit 8\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "A#TOUCH": {"ttr": 2310, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00F\\x01\\x05$?\\x01\\x05%\\x0f\\x084\\x00^\\x00H\\x00\\x00\\xc8\\xf2\\xf2\\xf4@@@@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "2005-08-31T00:00:00", "modifydate": "2005-09-07T08:34:46", "lines": 94, "newlines": 72, "modlines": 0, "user": "H224"}, "text": "/* Rexx program to update the Last Known Working Member's ACCEPT time.\n*  Usage: a#Touch Archive \u00dd(member)\u00a8\n*  Archive is the PDS whose members should be updated.  TSO syntax is\n*  accepted for the Archive DSN.\n*  Archive can be specified as a DD statement, which should specify\n*  the DS name, not a specific member.\n*  If member is not supplied, a#Touch updates the time for ALL members\n*  of the selected PDS.  The () are required.\n*  This can be run in batch or interactively.\n*.\n*. 2005/08/31 Created by bsquare\n*/\nif arg(1) = '?' then signal ShowHelp\nLKWMTbl = 'Z{LKWM{'\ncTime = Translate('1234/56/78',Date('S'),'12345678') Time()\n\n/* Get ArcDSN and ArcVol */\narg DSN . '('Member')'\nif Member = '' then Member = '*'\nif DSN <> '' then Vol = ''\nelse do\n   if ListDSI('ARCHIVE FILE') > 4 then exit 20\n   Vol = SysVolume\n   DSN = \"'\"SysDSName\"'\"\n   if ListDSI(DSN) <= 4 & SysVolume = Vol then Vol = ''\n   else Vol = 'VOLUME('Vol')'\nend\nif Right(Strip(DSN,,\"'\"),4) <> '.ARC' then do\n   if Left(DSN,1) = \"'\" then\n      aDSN = \"'\"Strip(DSN,,\"'\")\".ARC'\"\n   else aDSN = DSN'.ARC'\n   om = Msg('OFF')\n   if ListDSI(aDSN Vol) <= 4 then DSN = aDSN\n   call Msg om\nend\n\n/* Get ArcDSN ArcVol */\naddress TSO \"Alloc f(arc) dsn(\"DSN\")\" Vol \"SHR REUSE\"\nLKWM = ''\naddress ISPExec\n\"TbOpen\" LKWMTbl \"Library(ARC)\"\nif RC <> 0 then say 'Could not open archive table'\nelse do until RC > 0\n   /* Use TbScan to scan the table for matches (allows * wildcard) */\n   Mem = Member\n   \"TbScan\" LKWMTbl \"ArgList(Mem)\"\n   if RC = 0 then do\n      Mod = cTime\n      \"TbPut\" LKWMTbl\n      say 'Set' Mem 'to' Mod\n   end\nend\n\"TbClose\" LKWMTbl \"Library(ARC)\"\n\"TbStats BADTABLE Library(BADLIB)\" /* workaround for ISPF bug */\naddress TSO \"Free f(arc)\"\nexit\n\n/* Show the Help text for the rexx exec (from the comments) */\nShowHelp:  /* Not a procedure.  Doesn't return. */\n   do i=1 for SourceLine() until s = '*/'\n      s = Strip(SourceLine(i))\n      if Left(s,2) = '* ' | Left(s,3) = '/* ' then queue SubStr(s,3)\n   end\n   call ViewQ\n   exit\n\n/* Display the data stack with ISPF View.\n*  Note: not a procedure.  This is so the passed-in stem can be EXPOSEd\n*  to the calling routine.\n*/\nViewQ: arg $Stem$; call $ViewQ$; return\n$ViewQ$: procedure EXPOSE ($Stem$)\n   /* Queue any stem variable output */\n   if $Stem$ \u00ac= '' then do l=1 to Value($Stem$||0)\n      queue Value($Stem$||l)\n   end\n\n   address TSO\n   'ISPQRY'\n   if (RC /= 0) then \"EXECIO\" Queued() \"DISKW SYSPRINT\"\n   else do\n      dd = 'VWQ' || Right(SysVar('SYSSRV'),5,0)\n      /* Allocate space for the output */\n      \"Alloc f(\"dd\") UNIT(VIO) LRECL(256) RECFM(V) DSORG(PS) NEW DELETE\"\n      \"EXECIO\" Queued() \"DISKW\" dd \"(FINIS\"\n      /* Use ISPF View to display the output */\n      address ISPExec\n      \"LMINIT DataID(temp) DDName(\"dd\")\"\n      \"VIEW   DataID(\"temp\") CONFIRM(NO) CHGWARN(NO) MACRO(NORECOV)\"\n      \"LMFREE DataID(\"temp\")\"\n      /* Free the space */\n      address TSO \"FREE f(\"dd\")\"\n   end\n   return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "A#VERSP": {"ttr": 2313, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1b\\x00\\x17\\x01\\x05\\x19O\\x01\\t\\x12\\x7f\\x13T\\x00\\x1b\\x00\\x13\\x00\\x00\\xc8\\xf2\\xf2\\xf4@@@@@@'", "ispf": {"version": "01.27", "flags": 0, "createdate": "2005-07-13T00:00:00", "modifydate": "2009-05-07T13:54:17", "lines": 27, "newlines": 19, "modlines": 0, "user": "H224"}, "text": ")ATTR\n   $ TYPE(OUTPUT)  INTENS(LOW) CAPS(OFF)  COLOR(GREEN)\n   ! TYPE(OUTPUT)  INTENS(LOW) CAPS(OFF)  COLOR(RED)\n   _ TYPE(OUTPUT)  INTENS(LOW) CAPS(OFF)  COLOR(TURQ)\n   @ TYPE(INPUT)  INTENS(LOW) CAPS(ON)  COLOR(TURQ)\n)BODY EXPAND(\\\\)\n+CMD%=>@ZCMD                   \\ \\+SCROLL%=>@SCR +\n%\\ \\Available Versions\\ \\  +\n_DSN\n+ &Desc1\n+ &Desc2\n+ &Desc3\n+ &Desc4\n+ &Desc5\n+ &Desc6\n+Version Last Modified       User    +\n+------- ------------------- --------+\n)MODEL\n@Z!Vers _Mod                _User    +\n        $Hist1\\ \\+\n)INIT\n .ZVARS = 'SelCode'\n .AUTOSEL=YES\n)PROC\n &Row = .CSRROW\n if (&Row \u00ac= '00000000') .CSRROW = &Row\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "A#VHIST": {"ttr": 2315, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x010\\x008\\x01\\x05\\x19O\\x01\\t\\x12\\x7f\\t\\x05\\x00S\\x00\\n\\x00\\x00\\xc8\\xf2\\xf2\\xf4@@@@@@'", "ispf": {"version": "01.48", "flags": 0, "createdate": "2005-07-13T00:00:00", "modifydate": "2009-05-07T09:05:38", "lines": 83, "newlines": 10, "modlines": 0, "user": "H224"}, "text": "/* Rexx edit macro to display archive history for the edited dataset.\n*  Usage: Install using #CONFIG.\n*.\n*. 2005/07/12 Created by bsquare\n*/\naddress ISREdit \"Macro\"\nisMacro = (RC = 0)\nif isMacro then do     /* called as edit macro */\n   address ISREdit\n   \"(Vol) = VOLUME\"\n   \"(DSN) = DATASET\"\n   \"(Mem) = MEMBER\"\n   ArcKey = Vol':'DSN'('Mem')'\n   address ISPExec\n   \"TbGet archive\"\nend; else do           /* called from dataset or member list */\n   address ISPExec\n   Info = a#Info(arg(1))\n   if Info <> '' then \"VGet\" Info \"SHARED\"\n   if Info = '' | ArcTbl = '' then do\n      ZEdLMsg = 'Unable to obtain archive history for' arg(1)\n      ZEdSMsg = 'No Archive History'\n      address ISPExec \"SetMsg Msg(ISRZ000)\"\n      exit\n   end\n   parse VAR ArcKey ':'DSN'('Mem')'\nend\n\n\"TbTop &ArcTbl\"\n\"TbSkip &ArcTbl\"\nif RC <> 0 then do\n   if Mem = '' then\n      ZEdLMsg = 'No archive history exists for this dataset yet.'\n   else ZEdLMsg = 'No archive history exists for this member yet.'\n   ZEdSMsg = 'No history'\n   \"SetMsg Msg(ISRZ000)\"\n   if \\isMacro then \"TbEnd &ArcTbl\"\n   exit\nend\nif Mem <> '' then DSN = DSN'('Mem')'\ndo forever\n   \"TbDispl &ArcTbl PANEL(a#VersP)\"\n   if RC > 0 then leave\n   if Row = 0 then iterate\n   \"TbTop &ArcTbl\"\n   \"TbSkip &ArcTbl NUMBER(&Row)\"\n   /* You can check the value of SelCode here */\n   Select\n   When SelCode = '' | SelCode = 'S' then \"Display Panel(a#DHistP)\"\n   When SelCode = 'V' then do\n      Stats = 'Version('Vers') User('User') Modified('Mod')'\n      Archive = a#Make(ArcKey,Stats)\n      if Archive <> '' then do\n         \"View Dataset(\"Archive\")\"\n         om = Msg('OFF')\n         address TSO \"Delete\" Archive\n         call Msg om\n      end\n      end\n   When SelCode = 'R' then do\n      Stats = 'Version('Vers') User('User') Modified('Mod')'\n      Archive = a#Make(ArcKey,Stats)\n      if Archive <> '' then do\n         address ISREdit\n         \"X ALL\"\n         \"DEL ALL X\"\n         \"COPY\" Archive \"BEFORE .ZFIRST\"\n         parse VAR Vers VV'.'LL\n         if VV <> '' then do\n            \"VERSION = (VV)\"\n            \"LEVEL   = (LL)\"\n         end\n         om = Msg('OFF')\n         address TSO \"Delete\" Archive\n         call Msg om\n         address ISPExec\n      end\n      end\n   Otherwise nop\n   End\n   SelCode = ' '\nend\nif \\isMacro then \"TbEnd &ArcTbl\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "A#VIEW": {"ttr": 2318, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x14\\x01\\x05\"\\x1f\\x01\\x052\\x1f\\x07\\x17\\x006\\x00*\\x00\\x00\\xc8\\xf2\\xf2\\xf4@@@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2005-08-09T00:00:00", "modifydate": "2005-11-17T07:17:14", "lines": 54, "newlines": 42, "modlines": 0, "user": "H224"}, "text": "/* Rexx program to supplement the ISPF edit VIEW command, allowing\n*  the user to view previous versions of an archived dataset or member.\n*  Usage: Install using #CONFIG.\n*  The macro will just call the BUILTIN VIEW command unless the argument\n*  string is a valid version string.\n*.\n*. 2005/08/09 Created by bsquare\n*/\naddress ISREdit\n\"Macro (parm)\"\nRV = Translate(Parm)\nif DataType(RV,'N') then signal OK\nparse VAR RV c 2 RV\nif c = 'V' & DataType(RV,'N') & Pos('.',RV) > 0 then signal OK\n\"BUILTIN VIEW\" Parm\nexit RC\n\nOK:\n   \"(Vol) = VOLUME\"\n   \"(DSN) = DATASET\"\n   \"(Mem) = MEMBER\"\n   ArcKey = Vol':'DSN'('Mem')'\n   address ISPExec\n   \"TBGet archive\"\n   \"TBTop &ArcTbl\"\n   if RV < 0 then do\n      if DataType(RV,'W') = 0 then signal Err   /* not a whole number */\n      do 1-RV\n         \"TBSkip &ArcTbl\"\n         if RC <> 0 then signal Err\n      end\n      RV = Vers\n   end; else do\n      parse VAR RV VV '.' LL\n      RV = Right(VV,2,0)'.'Right(LL,2,0)\n      do until Vers = RV\n         \"TBSkip &ArcTbl\"\n         if RC <> 0 then signal Err\n      end\n   end\n   Vers = 'VERSION('Vers') USER('User') MODIFIED('Mod')'\n   ViewDS = a#Make(ArcKey,Vers)\n   if ViewDS = '' then signal Err\n   address ISPExec \"View Dataset(\"ViewDS\")\"\n   om = Msg('OFF')\n   address TSO \"Delete\" ViewDS\n   call Msg om\n   exit\n\nErr:\n   ZEdLMsg = 'The archive does not contain version' RV\n   ZEdSMsg = 'Not found'\n   address ISPExec \"SetMsg Msg(ISRZ000)\"\n   exit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PDS2TXT": {"ttr": 2320, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00U\\x01\\x06\\x08O\\x01\\x06\\x08_\\x04W\\x00\\x8a\\x00\\x8a\\x00\\x00\\xc8\\xf2\\xf2\\xf4@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2006-03-25T00:00:00", "modifydate": "2006-03-26T04:57:55", "lines": 138, "newlines": 138, "modlines": 0, "user": "H224"}, "text": "/* Rexx program to copy members of a PDS to a flat text dataset\n*  suitable for download with the name of each PDS member preceding it.\n*  Usage: PDS2Txt pds \u00dddataset\u00a8 \u00ddMOD\u00a8\n*  where  pds is the name of the PDS to copy members from, and\n*         dataset is the name of the output dataset.\n*\n*. 1994/07/12 Created by bsquare\n*. 1995/05/01 Added options (MOD/NEW/etc.) to file allocate.\n*. 2006/02/24 Modernized slightly.  Only allow MOD as allocate option.\n*. 2006/02/24 Renamed exec and modified ATTR segment.\n*/\nif arg(1) = '?' then signal ShowHelp\n\nparse arg PDS DataSet Opt\nif PDS = '' then signal ShowHelp\ntPDS = Strip(PDS,,\"'\")\nif tPDS = PDS then Quote = ''\nelse do\n   dsPref = SysVar('SYSPREF')'.'\n   if \\Abbrev(tPDS,dsPref) then Quote = \"'\"\n   else do\n      PDS = SubStr(tPDS,Length(dsPref)+1)\n      tPDS = PDS\n      Quote = ''\n   end\nend\nif Opt = '' & DataSet = 'MOD' then parse VALUE 'MOD' WITH Opt,DataSet\nif DataSet = '' then DataSet = Quote || tPDS'.TXT' || Quote\nif Opt <> 'MOD' & Opt <> '' then signal ShowHelp\n\n/* Check the input dataset. */\nRC = ListDSI(PDS 'DIRECTORY')\nif RC > 4 then do\n   say 'Unable to access' PDS\n   say SysMsgLvl2\n   exit RC\nend\nif Left(SysDSOrg,2) <> 'PO' then do\n   say PDS 'is not partitioned'\n   exit 12\nend\n\n/* Allocate the output dataset. */\nif Opt = '' then do\n   om = Msg('OFF')\n   \"Alloc f(out) dsn(\"DataSet\") OLD REUSE\"\n   if RC <> 0 then\n      \"Alloc f(out) dsn(\"DataSet\") LIKE(\"PDS\") DSORG(PS) NEW CATALOG\"\n   call Msg om\nend; else do\n   \"Alloc f(out) dsn(\"DataSet\") LIKE(\"PDS\") DSORG(PS)\",\n      Opt \"CATALOG REUSE\"\nend\nif RC <> 0 then do\n   say 'Unable to allocate' DataSet\n   exit 12\nend\n\n/* Get a list of the PDS members */\ncall OutTrap Member.\n\"LISTDS\" PDS \"MEMBERS\"\ncall OutTrap 'OFF'\nif SysMembers = '' then do\n   do i=1 to Member.0 while Member.i <> '--MEMBERS--'; nop; end\n   SysMembers = Member.0 - i\nend\n\n/* Save the input dataset attributes in the output dataset */\nif \\DataType(SysUsed,'W') then do\n   SysUsed = SysUsedPages\n   Used = 'BLOCK(4096) DSNTYPE(LIBRARY)'\nend; else do\n   if SysUnits = 'BLOCK' then SysUnits = 'BLOCK('SysBlkSize')'\n   if SysUDirBlk = '' then SysUDirBlk = SysMembers/6\n   Used = 'DIR('SysUDirBlk')' SysUnits\nend\n/* Put commas in the Record Format for ALLOCATE */\nout = Left('1,2,3,4',Length(SysRecFM)*2-1)\nRecFm = Translate(out,SysRecFm,'1234')\nAttr = 'RECFM('RecFm') LRECL('SysLRecL')'\nSec = Max(SysUsed%2,1)\nqueue ')PDS' PDS 'MEMBERS('SysMembers')'\nqueue ')ATTR' Attr 'SPACE('SysUsed','Sec')' Used\n\"ExecIO 2 DiskW out\"\n\ndo in=Member.0-SysMembers+1 to Member.0\n   mem = Strip(Member.in)\n   cm = Quote || tPDS'('mem')' || Quote\n   \"Alloc f(in) dsn(\"cm\") SHR REUSE\"\n   \"ExecIO * DiskR in (STEM Cur. FINIS\"\n   \"Free f(in)\"\n   if (in//10) == 0 then say ')MEMBER' mem 'LINES('Cur.0')'\n   queue ')MEMBER' mem 'LINES('Cur.0')'\n   \"ExecIO 1 DiskW out\"\n   \"ExecIO\" Cur.0 \"DiskW out (STEM Cur.\"\nend\n\"ExecIO 0 DiskW out (FINIS\"\n\"Free f(out)\"\nexit\n\n/* Show the Help text for the rexx exec (from the comments) */\nShowHelp:  /* Not a procedure.  Doesn't return. */\n   do i=1 for SourceLine() until s = '*/'\n      s = Strip(SourceLine(i))\n      if Left(s,2) = '* ' | Left(s,3) = '/* ' then queue SubStr(s,3)\n   end\n   call ViewQ\n   exit\n\n/* Display the data stack with ISPF View.\n*  Note: not a procedure.  This is so the passed-in stem can be EXPOSEd\n*  to the calling routine.\n*/\nViewQ: arg $Stem$; call $ViewQ$; return\n$ViewQ$: procedure EXPOSE ($Stem$)\n   /* Queue any stem variable output */\n   if $Stem$ \u00ac= '' then do l=1 to Value($Stem$||0)\n      queue Value($Stem$||l)\n   end\n\n   address TSO\n   'ISPQRY'\n   if (RC /= 0) then \"EXECIO\" Queued() \"DISKW SYSPRINT\"\n   else do\n      CmdName = sysvar('SYSICMD')\n      dd = 'VWQ' || Right(SysVar('SYSSRV'),5,0)\n      /* Allocate space for the output */\n      \"Alloc f(\"dd\") UNIT(VIO) LRECL(256) RECFM(V) DSORG(PS) NEW DELETE\",\n         \"dsn(TEMP.\"dd\".\"CmdName\")\"\n      \"EXECIO\" Queued() \"DISKW\" dd \"(FINIS\"\n      /* Use ISPF View to display the output */\n      address ISPExec\n      \"LMINIT DataID(temp) DDName(\"dd\")\"\n      \"VIEW   DataID(\"temp\") CONFIRM(NO) CHGWARN(NO) MACRO(NORECOV)\"\n      \"LMFREE DataID(\"temp\")\"\n      /* Free the space */\n      address TSO \"FREE f(\"dd\")\"\n   end\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SOURCE": {"ttr": 2563, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x02\\x00E\\x01\\x06\\x08O\\x01\\x06\\x08_\\x04T\\t'\\t'\\x00\\x00\\xc8\\xf2\\xf2\\xf4@@@@@@\"", "ispf": {"version": "01.02", "flags": 0, "createdate": "2006-03-25T00:00:00", "modifydate": "2006-03-26T04:54:45", "lines": 2343, "newlines": 2343, "modlines": 0, "user": "H224"}, "text": ")PDS CBT.ARCHIVE.V101.SOURCE MEMBERS(25)\n)ATTR RECFM(F,B) LRECL(80) SPACE(1,1) DIR(5) CYLINDER\n)MEMBER #CONFIG LINES(5)\n/* ISPF Configuration entries.                                        */\n/*   Include these entries in your own configuration member.          */\n/*   Create the ISPCFIGU load module using TSO ISPCCONF.              */\nMEMBER_LIST_LINE_COMMAND_COMMAND_EXIT       = A#CMDCK\nSITE_WIDE_INITIAL_MACRO                     = A#INIT\n)MEMBER #DESC LINES(69)\nArchive program description:\nThe purpose of the archive application is to facilitate maintaining\nprevious versions of edited source PDS members (and sequential\ndatasets) 'transparently'.  It is intended for source (text) datasets\nand PDSs only, and handles only ISPF edit as a means of altering\ndatasets and members.\n\nIts benefits are:\nUses ISPF edit to update source data - no new editing to learn, new\nfeatures accrue with ISPF.\nArchive creation, deletion, and backup are simple and efficient using\nstandard OS/390 utilities.\nIt is possible to archive any source dataset  that we control update of\n- e.g. SYS1.PARMLIB.\nBoth source and control datasets are standard datasets or PDSs - they\ncan be SMS managed, archived, etc.\nAn archive control PDS can constitute a complete PDS backup - recovery\nof the source PDS can be as simple as copying the archive control PDS\ninto it.\nIt can also maintain a 'Last Known Working Member' - a backup of a\nmember as of its last known 'good' version.  This is useful for datasets\nlike SYS1.IPLPARM and SYS1.PARMLIB, where the system may be unavailable\nto restore a member to a previous version, but an alternate member can\nbe specified for the IPL.\nWe own the source code - alterations and improvements are at our\ndiscretion.\n\nIts detriments are:\nIt is neither bulletproof nor foolproof - Use of utilities other than\nISPF edit to alter source or control dataset contents will affect the\nintegrity of the archive.  The source may or may not be recoverable.\nIt acts to facilitate a source control convention, it does not enforce\nit.  Archives can be intentionally bypassed or altered to affect (or\neffect) an apparent history which is bogus.  In order for archiving to\nwork, anyone having update access to a source dataset must also have\nupdate access to the archive control dataset.\n\nAdditional available commands while editing an archived source:\nCOMPARE vers     - compare the currently edited source to a previous\n                   version\nHISTORY          - display a table of all of the available versions of\n                   this source\n                 - from the table, you can display the history entry\n                   or view a specific version\nOPTIONS | OPTS   - set Dataset or Member options for an archive\nRESTORE vers     - restore the currently edited source to a previous\n                   version\nVIEW vers        - view a previous version of the edited source\n\nwhere vers = {\u00ddv\u00a8VV.MM} or {-N}\n      VV and MM can be 1 or 2 digits that specify the absolute\n      version.  N is a non-zero whole number that specifies how\n      many versions to go back (e.g. -1 is the previous version).\n      Thus, if the archive consists of versions 01.03,01.12,02.05,02.06\n      where 2.06 is the currently edited version,\n      COMPARE -2 will compare the current version with v01.12 and\n      RESTORE v1.3 will restore the member to v01.03.\n\nFuture features that should be implemented:\nThe external data editing commands CREATE, MOVE and REPLACE commands\nshould be DEFINEd to allow checking for creating, deleting or\noverwriting archives regardless of whether they are used in an archived\ndataset or not.\nThe BuiltIn, Define, Stats, Version and Level commands should be DEFINEd\nto deny inappropriate usage.\nAn option should be provided to drop versions of edited data more than a\ncertain age or number of versions.\nA utility should be provided to allow the user to change the data\ndescription, and perhaps to set/change an archive description.\n)MEMBER #DETAIL LINES(107)\nNOTE: If you are modifying the code, you should be aware of some Rexx\n      tricks I use.  See the TRICKS section of this member for more\n      details.\n\nImplementation details:\nThe archive application consists of 2 ISPF configuration options and a\nPDS of rexx execs and ISPF panels.\nThe ISPF configuration options are:\nMEMBER_LIST_LINE_COMMAND_COMMAND_EXIT       = A#CMDCK\nSITE_WIDE_INITIAL_MACRO                     = A#INIT\nThese options are in source PDS member #CONFIG.\n\nThe a#CmdCk, a#Init and a#Open rexx programs MUST exist in a PDS that\nis in every TSO user's SYSPROC or SYSEXEC concatenation.  The other\narchive application rexx execs and ISPF panels can either be in the same\nPDS or in another PDS that will be dynamically allocated during edit\nsessions.\nIf the a#CmdCk exec cannot be found, you will not be able to use ISPF\nsingle character line commands on any member lists.  Archiving will\nstill be in effect for edit sessions.\nIf the a#Init edit macro cannot be found, you will get an error every\ntime you enter ISPF edit or view.\na#Open is used by both a#CmdCk and a#Init and will cause problems with\narchives if it cannot be found.\n\nThese are the rexx execs that currently make up the archive\napplication:\na#Can   - Terminate ISPF Edit sessions - undo a#Init\na#CmdCk - Validate ISPF member list single character built-in commands.\n          Alter rename and delete requests to maintain archive integrity.\na#Cmp   - Allow COMPARE against previous versions of the data\na#End   - Call a#Save if required and terminate ISPF Edit sessions like\n          CANCEL\na#Init  - Initialize ISPF Edit sessions:\n          Allocate rexx and panel libraries, if necessary\n          Define SAVE, END and CANCEL, COMPARE and VIEW as macros (not\n          built-in)\n          Create or open and initialize tables used in the application\na#Make  - Used internally to create a 'temporary' dataset with a\n          previous version of the data\na#Open  - Used internally to resolve and open the archive control\n          dataset for a member\na#Opt   - Set the options for a dataset or member\na#Opts  - Used internally to parse options strings.\na#Rest  - Restore a previous version (an alias of Restore is provided by\n          a#Init).\na#Save  - Save the currently edited data, maintaining archived versions.\na#Touch - Exec to be used in foreground or batch to set the date and\n          time that a member was last known to be working correctly.\na#VHist - Display version history (an alias of History is provided by\n          a#Init).\n          Allow a user to view a previous version of the edited data.\na#View  - View a previous version of the edited data\n\nThese are the ISPF panels that are part of the archive application:\na#DescP - Data entry panel to create or modify the dataset (member)\n          description.\na#DHistP- Display panel to show a specific version's history (change)\n          information.\na#HistP - Data entry panel to create or modify a version's history\n          (change description).\na#OptDP - Data entry panel to modify the dataset options.\na#OptMP - Data entry panel to modify the member options.\na#VersP - Table display panel to show or select dataset (member)\n          versions.\n\nIn addition, #TouchJb is JCL that can be used to run a#Touch in batch.\n\nTRICKS:\n   Initializing variables\n      To set multiple variables in one statement, I use\n      parse VALUE a b c... WITH Var1 Var2 Var3 ...\n      If I am setting all the variables to '', I use\n      parse VALUE WITH VarX,VarY,VarZ ...\n      If I want to set SOME variables to values, and others to '', I use\n      parse VALUE expression WITH VarA VarB,EmptyA,EmptyB\n      I might also use parse VAR a VarA VarB,Empty1,Empty2...\n      Anything after the 1st comma gets a null ('') value.\n      NOTE that this is NOT the case for parse ARG.\n      I might occasionally parse the output of a function\n      parse VALUE FuncA(parm1,parm2) WITH RC Var1...\n   Formatting\n      To format an expression, I use\n      new = Translate(OutputFormat,old,InputFormat)\n      like this: nDate = Translate('1234/56/78',Date('S'),'12345678')\n      which would set nDate to '2005/09/15'\n      if Date('S') returns '20050915'.\n      The characters in the InputFormat MUST be unique.\n      Read the TSO-E Rexx Reference manual Built-in Functions/Translate\n      description for more information.\n   ISPF and ISPF edit\n      I use both the ISPF &variable notation and the ISPF Edit\n      (variable) notation to reference the value of a variable.\n      So  \"LMClose DataID(&DataID)\" is the same as\n          \"LMClose DataID(\"DataID\")\"\n      and \"LINE_AFTER\" i-1 \"= (Cur)\" is like\n          \"LINE_AFTER\" i-1 \"= '\"Cur\"'\"\n      In the LINE_AFTER case, (Cur) will work properly even\n      if Cur contains the character '.\n   Value()\n      The statement\n      call Value oType,Value(oType) v||'('Val')'\n      is equivalent to\n      interpret oType '=' oType \"v||'('Val')'\"\n      Thus, if oType is 'MEMBER', v is 'Hist' and Val is 'no', then\n      the expression evaluates to:\n      MEMBER = MEMBER 'Hist'||'(no)'\n)MEMBER #INSTALL LINES(36)\nIn the install PDS:\nThe member #CONFIG contains definitions needed for ISPF customization.\nCopy this member into your site ISPF customization PDS member (for us,\nthis is 'OS390.MAINT.CONFIG.R210(ISPFCFG)'.  You will use this to build\nan ISPF configuration module.\n\nFrom an ISPF command line, type 'TSO ISPCCONF'.\n   This will bring up the ISPF Configuration Utility.\nPut your configuration dataset and member in the Keyword File Data Set\nsection.\nSelect option 3, Verify Keyword Table Contents.\n   You should get the message 'Keyword file verified' in the upper right.\nSelect option 4, Build Configuration Table Load Module.\n   Verify that the 'Input Keyword File Data set' is the same as used\n   above, and select an Output Configuration Table Load Module Data Set.\n   I would suggest putting this in a dataset that is NOT in the\n   LPA/Link/Joblib/Steplib/ISPLLib search sequence for now.\nPress Enter to generate the load module.\n   It will be named ISPCFIGU.\n\nAlter your logon PROC/CList/Exec to allocate the install PDS to SYSEXEC\nand ISPPLIB.\nNow either alter the above to allocate your ISPF configuration module\ndataset to ISPLLIB, or copy ISPCFIGU from your configuration module\ndataset to a library in the search concatenation.\nFor example - to add this to MCIT's #SYSTSO5 proc, you would edit\nSYS2.TSO5.ISRPRIM.R210(ISPFTSO) to add H224.ARCHIVE.SOURCE to SYSEXEC\nand ISPPLIB.  If you put the ISPCFIGU module into H224.ARCHIVE.LOAD, you\nwould add that to ISPLLIB in the same dataset.\nIf you added ISPCFIGU to the Link list, you will need to refresh it.\n\nYou should now be able to log on to your TSO proc, and use Archive.\nNOTE:  Every TSO user that will get the ISPCFIGU module you created MUST\nhave the ARCHIVE.SOURCE PDS in their SYSEXEC and ISPPLIB concatenations.\nOtherwise they will get failures using ISPF member list line commands\nand ISPF edit/view.\n)MEMBER #TOUCHJB LINES(24)\n//TOUCHJOB JOB 0200,'archive',MSGCLASS=X,CLASS=X,NOTIFY=&SYSUID\n//*\n//* Touch the members of an archive.\n// SET SOURCE=SYS1.PARMLIB\n// SET LIB=H224.ARCHIVE.SOURCE\n//*\n//* Create a new profile for the following step\n//NEWPROF  EXEC IEFBR14\n//ISPPROF  DD DISP=(NEW,PASS),DSN=&&PROFILE,UNIT=SYSDA,\n//         SPACE=(CYL,(1,1,1)),LRECL=80,BLKSIZE=27920\n//*\n//* Touch\n//TOUCH    EXEC PGM=IKJEFT01,PARM='ISPSTART CMD(%A#TOUCH)'\n//SYSEXEC  DD DISP=SHR,DSN=&LIB\n//ISPPROF  DD DISP=(SHR,PASS),DSN=&&PROFILE\n//ISPTLIB  DD DISP=SHR,DSN=ISP.SISPTENU\n//ISPTABL  DD DISP=(SHR,PASS),DSN=&&PROFILE,VOL=REF=*.ISPPROF\n//ISPLOG   DD SYSOUT=*,LRECL=125,BLKSIZE=129,RECFM=VB\n//ISPPLIB  DD DISP=SHR,DSN=ISP.SISPPENU\n//ISPMLIB  DD DISP=SHR,DSN=ISP.SISPMENU\n//ISPSLIB  DD DISP=SHR,DSN=ISP.SISPSENU\n//SYSTSIN  DD DUMMY\n//SYSTSPRT DD SYSOUT=*\n//ARCHIVE  DD DISP=SHR,DSN=&SOURCE\n)MEMBER A#CAN LINES(19)\n/* Rexx program to end an edit session, archiving as necessary.\n*  Usage: Install using #CONFIG.\n*  This will close the tables opened by a#Init.\n*.\n*. 2005/07/12 Created by bsquare\n*/\naddress ISREdit\n\"Macro\"\n\"(Vol) = VOLUME\"\n\"(DSN) = DATASET\"\n\"(Mem) = MEMBER\"\nArcKey = Vol':'DSN'('Mem')'\naddress ISPExec\n\"TBGet archive\"\n\"TBEnd\" ArcTbl\n\"TBClose archive\"\n/* \"LIBDEF ISPPLIB\" */\n/* address TSO \"AltLib DEACTIVATE APPLICATION(EXEC)\" */\naddress ISREdit \"BuiltIn CANCEL\"\n)MEMBER A#CMDCK LINES(258)\n/* Rexx ISPF exit */\n/* exit 0 uses ISPF processing.  exit 8 skips ISPF processing. */\narg Cmd . \"'\" DSN '(' Mem ')' . VolSer Tail\nif Pos(Cmd,'DR') = 0 then exit 0\nif Right(Mem,1) = '{' then exit 0\nif Right(DSN,4) = '.ARC' then exit 0\nDT = Date('D')*86400+Time('S')\naddress ISPExec\n\"VGet (MCMDDSN) SHARED\"\nif RC = 0 then do\n   if Word(MCMDDSN,1) = VolSer':'DSN then do\n      oDT = Word(MCMDDSN,2)\n      if DT = oDT then exit 0\n      else if (DT - oDT) <= 10 then do\n         MCMDDSN = oDSN DT\n         \"VPut (MCMDDSN) SHARED\"\n         exit 0\n      end\n   end\nend\nIsCat = ListDSI(\"'\"DSN\"'\") = 0\nif IsCat then IsCat = (SysVolume = VolSer)\nif IsCat then Vol = ''\nelse Vol = ' VOLUME('VolSer')'\nSysDSOrg = 'BAD'\nArcDSN = DSN'.ARC'\nif Length(ArcDSN) <= 44 then call ListDSI \"'\"ArcDSN\"'\"||Vol\nif Left(SysDSOrg,2) <> 'PO' then ArcDSN = DSN\nArcMem = Strip(Left(Mem,7))'{'\n\n\"VGet (ZTERM)\"\nif ZTerm <> '3278' & ZTerm <> '3278A' then\n   \"Select Pgm(ISPTTDef) Parm(3278)\"\n\"LMInit DataID(DID) DataSet('\"ArcDSN\"')\"Vol \"ENQ(SHRW)\"\n\"LMOpen DataID(&DID)\"\n\"LMMFind DataID(&DID) Member(Z{PARMS{)\"\nzParms = (RC = 0)\nif ArcDSN = DSN & zParms = 0 then do           /* No archive dataset */\n   MCMDDSN = VolSer':'DSN DT\n   \"VPut (MCMDDSN) SHARED\"\n   signal Quit\nend\nArcCopy = 0\nif ArcDSN <> DSN then do\n   \"LMMFind DataID(&DID) Member(&Mem)\"\n   ArcCopy = (RC = 0)\nend\n\"LMMFind DataID(&DID) Member(&ArcMem)\"\nif RC = 0 then\n  \"LMGet DataID(&DID) Mode(INVAR) MaxLen(80) DataLoc(Data) DataLen(Len)\"\nif RC <> 0 then IsArc = 0\nelse do\n   parse UPPER VAR Data 2 Type Info\n   if Type = 'CURRENT' then do\n      parse VAR Info 'MEMBER('aMem')'\n      if aMem = Mem then IsArc = 1\n      else do\n         IsArc = 0\n         ArcMem = ''\n      end\n   end; else do\n      parse VAR Info 'ID('ConID')'\n      ArcMem = 'Z{'Right(ConID,4,0)||SubStr(Mem,8)||'{'\n      \"LMMFind DataID(&DID) Member(&ArcMem)\"\n      IsArc = (RC = 0)\n   end\nend\nif Left(Tail,1) = '*' then Tail = ''\nSelect\nWhen Cmd = 'R' then do\n   if IsArc = 0 & ArcCopy = 0 then signal Quit\n   if Tail <> '' then parse VAR Tail UDARen .\n   else do\n      address ISPExec\n      UDMSMem = Mem\n      \"AddPop\"\n      \"Display Panel(ISRUREN)\"\n      RV = RC\n      \"RemPop\"\n      if RV <> 0 then signal Done\n   end\n   /* If not archived, do this the simple way */\n   if IsArc = 0 then do\n      \"LMClose DataID(&DID)\"\n      \"LMOpen DataID(&DID) Option(OUTPUT)\"\n      \"LMMRen DataID(&DID) Member(&Mem) NewName(&UDARen)\"\n      \"LMClose DataID(&DID)\"\n      \"LMFree DataID(&DID)\"\n      \"LMInit DataID(DID) DataSet('\"DSN\"')\"Vol \"Enq(SHRW)\"\n      \"LMOpen DataID(&DID) Option(OUTPUT)\"\n      \"LMMRen DataID(&DID) Member(&Mem) NewName(&UDARen)\"\n      signal Done\n   end\n   address TSO\n   \"Alloc f(in) dsn('\"ArcDSN\"(\"ArcMem\")')\"Vol \"SHR REUSE\"\n   \"ExecIO * DiskR in (STEM Arc. FINIS\"\n   \"Free f(in)\"\n   ms = 'MEMBER('                /* string to look for */\n   lp = Pos(ms,Translate(Arc.1))\n   if lp <> 0 then ms = SubStr(Arc.1,lp,Length(ms))\n   parse VAR Arc.1 Left (ms) . ')' Right\n   Arc.1 = Strip(Left,'T') 'Member('UDARen')'||Right\n   NewArc = Strip(Left(UDARen,7))'{'\n   address ISPExec\n   /* Check for contention */\n   if NewArc = ArcMem then RC = 4           /* contention with self */\n   else \"LMMFind DataID(&DID) Member(&NewArc)\"\n   if RC = 0 then do\n      \"LMGet DataID(&DID) Mode(INVAR) MaxLen(80) DataLoc(Data) DataLen(Len)\"\n      parse UPPER VAR Data 2 Type Info\n      if Type = 'RESOLVE' then parse VAR Info 'ID('ConID')'\n      else do\n         \"LMClose DataID(&DID)\"\n         address TSO\n         parse VAR Info 'MEMBER('OldMem')'\n         Parms. = 0\n         ConID = ''\n         if zParms then do\n            \"Alloc f(in) dsn('\"ArcDSN\"(Z{PARMS{)')\"Vol \"SHR REUSE\"\n            \"ExecIO * DiskR in (STEM Parms. FINIS\"\n            \"Free f(in)\"\n            do i=1 to Parms.0\n               parse UPPER VAR Parms.i 2 Type Info\n               if Type <> 'RESOLVE' then iterate\n               pl = i\n               parse UPPER VAR Parms.i . 'ID('ConID')'\n            end\n         end\n         if ConID <> '' then ConID = Right(ConID+1,4,0)\n         else do\n            ConID = '0000'\n            pl = Parms.0+1; Parms.0 = pl\n         end\n         Parms.pl = ')Resolve ID('ConID')'\n         \"Alloc f(out) dsn('\"ArcDSN\"(Z{PARMS{)')\"Vol \"SHR REUSE\"\n         \"ExecIO\" Parms.0 \"DiskW out (STEM Parms. FINIS\"\n         \"Free f(out)\"\n         OldArc = 'Z{'ConID||SubStr(OldMem,8)||'{'\n         address ISPExec\n         \"LMOpen DataID(&DID) Option(OUTPUT)\"\n         \"LMMRen DataID(&DID) Member(&NewArc) NewName(&OldArc)\"\n         Data = Parms.pl\n         \"LMPut DataID(&DID) Mode(INVAR) DataLoc(Data) DataLen(80)\"\n         \"LMMAdd DataID(&DID) Member(&NewArc) Stats(NO)\"\n      end\n      ConID = Right(ConID,4,0)\n      NewArc = 'Z{'ConID||SubStr(UDARen,8)||'{'\n   end\n   \"LMClose DataID(&DID)\"\n   address TSO\n   \"Alloc f(out) dsn('\"ArcDSN\"(\"NewArc\")')\"Vol \"SHR REUSE\"\n   \"ExecIO * DiskW out (STEM Arc. FINIS\"\n   \"Free f(out)\"\n   address ISPExec\n   \"LMOpen DataID(&DID) Option(OUTPUT)\"\n   if NewArc <> ArcMem then\n      \"LMMDel DataID(&DID) Member(&ArcMem)\"\n   if ArcCopy then\n      \"LMMRen DataID(&DID) Member(&Mem) NewName(&UDARen)\"\n   \"LMClose DataID(&DID)\"\n   \"LMFree DataID(&DID)\"\n   \"LMInit DataID(DID) DataSet('\"DSN\"')\"Vol \"Enq(SHRW)\"\n   \"LMOpen DataID(&DID) Option(OUTPUT)\"\n   \"LMMRen DataID(&DID) Member(&Mem) NewName(&UDARen)\"\n   end\nWhen Cmd = 'D' then do\n   \"VGet (ZMemConf)\"\n   if ZMemConf <> 'OFF' then do\n      ZCFDSN = DSN\n      ZCFMEM = Mem\n      \"AddPop\"\n      \"Display Panel(ISRUDELC)\"\n      RV = RC\n      \"RemPop\"\n      if RV <> 0 then signal Done\n   end\n   \"LMClose DataID(&DID)\"\n   \"LMFree DataID(&DID)\"\n   address TSO\n   if IsArc then do\n      \"Alloc f(in) dsn('\"ArcDSN\"(\"ArcMem\")')\"Vol \"SHR REUSE\"\n      \"ExecIO 1 DiskR in (STEM Head\"\n      parse UPPER VAR Head1 'HEADER('Header')' 1 'DATA('Data')'\n      if Header = '' then Header = 0\n   end; else Data = ''\n   /* if the archive is already wrapped then ignore the new junk */\n   if Data <> '' then do\n      \"ExecIO 0 DiskR in (FINIS\"\n      \"Free f(in)\"\n   end; else do\n      /* Wrap the data into the archive */\n      if IsArc = 0 then do\n         Header = 0\n         address ISPExec\n         \"LMInit DataID(DID) DataSet('\"DSN\"')\"Vol \"Enq(SHRW)\"\n         \"LMOpen DataID(&DID)\"\n         \"LMMFind DataID(&DID) Member(&Mem) STATS(YES)\"\n         \"LMClose DataID(&DID)\"\n         \"LMFree DataID(&DID)\"\n         if ZLVers <> '' then do\n            Stats = 'Version('ZLVers'.'ZLMod')',\n                    'User('ZLUser')',\n                    'Modified('ZLM4Date ZLMTime':'ZLMSec')'\n            Header = 1\n            Header.1 = '-Stats' Stats\n         end\n         Header.0 = Header\n         address TSO\n      end; else do\n         if Header = 0 then Header.0 = 0\n         else \"ExecIO\" Header \"DiskR in (STEM Header.\"\n         \"ExecIO * DiskR in (STEM Arc. FINIS\"\n         \"Free f(in)\"\n      end\n      \"Alloc f(data) dsn('\"DSN\"(\"Mem\")')\"Vol \"SHR REUSE\"\n      \"ExecIO * DiskR data (STEM Data. FINIS\"\n      \"Free f(data)\"\n      if a#Open('OUT',VolSer':'DSN'('Mem')','WRITE') <> '' then do\n         push ')Current Header('Header+1') Data('Data.0') Member('Mem')'\n         \"ExecIO 1 DiskW out\"\n         \"ExecIO * DiskW out (STEM Header.\"\n         Mod = Translate('1234/56/78',Date('S'),'12345678') Time()\n         push '-Hist (Deleted at' Mod 'by' UserID()')'\n         \"ExecIO 1 DiskW out\"\n         \"ExecIO * DiskW out (STEM Data.\"\n         \"ExecIO * DiskW out (STEM Arc. FINIS\"\n         \"Free f(out)\"\n      end\n   end\n   address ISPExec\n   if ArcCopy then do\n      \"LMInit DataID(DID) DataSet('\"ArcDSN\"')\"Vol \"Enq(SHRW)\"\n      \"LMOpen DataID(&DID) Option(OUTPUT)\"\n      \"LMMDel DataID(&DID) Member(&Mem)\"\n      \"LMClose DataID(&DID)\"\n      \"LMFree DataID(&DID)\"\n   end\n   \"LMInit DataID(DID) DataSet('\"DSN\"')\"Vol \"Enq(SHRW)\"\n   \"LMOpen DataID(&DID) Option(OUTPUT)\"\n   \"LMMDel DataID(&DID) Member(&Mem)\"\n   end\nOtherwise nop\nEnd\n/* All done */\nDone:\n\"LMClose DataID(&DID)\"\n\"LMFree DataID(&DID)\"\nif ZTerm <> '3278' & ZTerm <> '3278A' then\n   \"Select Pgm(ISPTTDef) Parm(\"ZTerm\")\"\nexit 8\n\n/* Let ISPF handle this one. */\nQuit:\n\"LMClose DataID(&DID)\"\n\"LMFree DataID(&DID)\"\nif ZTerm <> '3278' & ZTerm <> '3278A' then\n   \"Select Pgm(ISPTTDef) Parm(\"ZTerm\")\"\nexit 0\n)MEMBER A#CMP LINES(79)\n/* Rexx program to supplement the ISPF edit COMPARE command, allowing\n*  the user to compare against a previous versions of an archived\n*  dataset or member.\n*  Usage: Install using #CONFIG.\n*  The macro will just call the BUILTIN COMPARE command unless the\n*  argument string is a valid version string.\n*.\n*. 2005/08/09 Created by bsquare\n*/\naddress ISREdit\n\"Macro (Parm)\"\nif Parm = '' then signal Settings         /* Stupid ISPF! */\nparse VAR Parm RV Tail\nupper RV\nif DataType(RV,'N') then signal OK\nparse VAR RV c 2 RV\nif c = 'V' & DataType(RV,'N') & Pos('.',RV) > 0 then signal OK\n\"BuiltIn COMPARE\" Parm\nexit RC\n\nOK:\n   \"(Vol) = VOLUME\"\n   \"(DSN) = DATASET\"\n   \"(Mem) = MEMBER\"\n   \"(Changed) = DATA_CHANGED\"\n   ArcKey = Vol':'DSN'('Mem')'\n   address ISPExec\n   \"TBGet archive\"\n   \"TBTop &ArcTbl\"\n   if RV < 0 then do\n      if DataType(RV,'W') = 0 then signal Err   /* not a whole number */\n      do (Changed = 'NO') - RV\n         \"TBSkip &ArcTbl\"\n         if RC <> 0 then signal Err\n      end\n      RV = Vers\n   end; else do\n      parse VAR RV VV '.' LL\n      RV = Right(VV,2,0)'.'Right(LL,2,0)\n      do until Vers = RV\n         \"TBSkip &ArcTbl\"\n         if RC <> 0 then signal Err\n      end\n   end\n   Vers = 'VERSION('Vers') USER('User') MODIFIED('Mod')'\n   ViewDS = A#Make(ArcKey,Vers)\n   if ViewDS = '' then signal Err\n   address ISREdit \"BUILTIN COMPARE\" ViewDS Tail\n   om = Msg('OFF')\n   address TSO \"Delete\" ViewDS\n   call Msg om\n   exit\n\nErr:\n   ZEdLMsg = 'The archive does not contain version' RV\n   ZEdSMsg = 'Not found'\n   address ISPExec \"SetMsg Msg(ISRZ000)\"\n   exit\n\nSettings:\n   address ISPExec\n   \"VGet (ZEdUpdOp ZUpXSiz ZUpdLab)\"\n   ZUpXSizT = ZUpXSiz\n   ZUpdLabT = ZUpdLab\n   parse VAR ZEdUpdOp RefMovr 2 AnyC 3 Mixed 4 DPPlCmt 5,\n         DPPsCmt 6 DPAdCmt 7 DPACmt 8 DPFtCmt 9 DPCbCmt 10 DPBlkCl\n   \"AddPop\"\n   do until RC <> 0\n      \"Display Panel(ISREUPP)\"\n   end\n   \"RemPop\"\n   \"VGet (ZVerb)\"\n   if ZVerb <> 'END' then exit\n   ZEdUpdOp = RefMovr||AnyC||Mixed,\n   || DPPlCmt||DPPsCmt||DPAdCmt||DPACmt||DPFtCmt||DPCbCmt||DPBlkCl\n   ZUpXSiz = ZUpXSizT\n   ZUpdLab = ZUpdLabT\n   \"VPut (ZEdUpdOp ZUpXSiz ZUpdLab) PROFILE\"\n   exit\n)MEMBER A#DESCP LINES(18)\n)ATTR\n _ TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(ASIS)\n)BODY EXPAND(\\\\)\n%&ZUSER---- MCIT Edit Archive Control \\-\\&ZDATE-&ZTIME--\n%Option  ===>_ZCMD\\ \\+\n+\n%\\ \\Archive Description\\ \\+\n+ Enter a description for%&DSN\n+\n+ Line 1:_Desc1                                                       +\n+ Line 2:_Desc2                                                       +\n+ Line 3:_Desc3                                                       +\n+ Line 4:_Desc4                                                       +\n+ Line 5:_Desc5                                                       +\n+ Line 6:_Desc6                                                       +\n+\n+ Press%Enter+to accept or%PF3+to%CANCEL+the SAVE\n)END\n)MEMBER A#DHISTP LINES(27)\n)ATTR\n _ TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(ASIS)\n)BODY EXPAND(\\\\)\n%&ZUSER---- MCIT Edit Archive Control \\-\\&ZDATE-&ZTIME--\n%Option  ===>_ZCMD\\ \\+\n+\n%\\ \\Archive History\\ \\+\n+\n+ &Desc1\n+ &Desc2\n+ &Desc3\n+ &Desc4\n+ &Desc5\n+ &Desc6\n+\n%&DSN v&Vers\n+ Modified &Mod by &User\n+\n+ Line 1:%&Hist1\n+ Line 2:%&Hist2\n+ Line 3:%&Hist3\n+ Line 4:%&Hist4\n+ Line 5:%&Hist5\n+ Line 6:%&Hist6\n+\n+\\ \\Press%Enter+or%PF3\\ \\+\n)END\n)MEMBER A#END LINES(28)\n/* Rexx program to end an edit session, archiving as necessary.\n*  Usage: Install using #CONFIG.\n*  When you END in ISPF edit, this will call SAVE if AUTOSAVE is on.\n*  SAVE is also modified in a#Init.\n*  This exec also closes the tables opened by a#Init.\n*.\n*. 2005/07/08 Created by bsquare\n*/\naddress ISREdit\n\"Macro\"\n\"(Sess) = SESSION\"\n\"(Changed) = DATA_CHANGED\"  /* Changed? */\nif Changed <> 'NO' then do\n   \"(AUTO) = AUTOSAVE\"\n   if AUTO = 'ON' then \"SAVE\"\n   if RC > 4 then exit      /* User canceled out of SAVE */\nend\n\"(Vol) = VOLUME\"\n\"(DSN) = DATASET\"\n\"(Mem) = MEMBER\"\nArcKey = Vol':'DSN'('Mem')'\naddress ISPExec\n\"TBGet archive\"\n\"TBEnd\" ArcTbl\n\"TBClose archive\"\n/* \"LIBDEF ISPPLIB\" */\n/* address TSO \"AltLib DEACTIVATE APPLICATION(EXEC)\" */\naddress ISREdit \"BuiltIn END\"\n)MEMBER A#HISTP LINES(26)\n)ATTR\n _ TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(ASIS)\n)BODY EXPAND(\\\\)\n%&ZUSER---- MCIT Edit Archive Control \\-\\&ZDATE-&ZTIME--\n%Option  ===>_ZCMD\\ \\+\n+\n%\\ \\Archive History\\ \\+\n+\n+ &Desc1\n+ &Desc2\n+ &Desc3\n+ &Desc4\n+ &Desc5\n+ &Desc6\n+\n+ Describe your changes to%&DSN v&Vers\n+\n+ Line 1:_Hist1                                                       +\n+ Line 2:_Hist2                                                       +\n+ Line 3:_Hist3                                                       +\n+ Line 4:_Hist4                                                       +\n+ Line 5:_Hist5                                                       +\n+ Line 6:_Hist6                                                       +\n+\n+ Press%Enter+to accept or%PF3+to%CANCEL+the SAVE\n)END\n)MEMBER A#INIT LINES(299)\n/* Rexx program.  Initialize the archive macros that replace ISPF edit\n*  commands - END, CANCEL, SAVE, VIEW, COMPARE (add HISTORY).\n*  Usage: Install using #CONFIG.\n*  Archiving is done in one of 3 ways:\n*  1.  Seq dataset, seq archive named dataset.ARC\n*  2.  PDS dataset, PDS archive named dataset.ARC\n*  3.  PDS dataset with a PDS member named Z{PARMS{\n*\n*  In any case, the archive must have a LRecL >= 80 (84 if V).\n*  The archive LRecL must also be >= the LRecL of the dataset (if the\n*  dataset is RecFM F or FB and the archive is V or VB, the LRecL of\n*  the archive must be at least 4 more than the dataset.\n*  NOTE: In order to use the LKWM feature, the archive MUST have\n*        RecFM FB, LRecL 80.\n*.\n*. 2005/07/08 Created by BSquare\n*. 2005/07/12 Allow sequential archives, add CANCEL.\n*.            Moved the macros to a seperate library.\n*. 2005/07/15 Use INFOLINE for description in member.\n*. 2005/07/21 Change format of archives.\n*. 2005/07/28 Change format of archives (again).\n*. 2005/08/03 Change INFOLINE to NOTELINE, use INFOLINE for WARNINGS.\n*. 2005/08/05 Use external a#Open instead of internal Resolve.\n*. 2005/08/12 Added Default, Global and Local options.\n*. 2005/08/30 Add Last Known Working Member copy.\n*. 2005/09/06 Fix LKWM for sequential datasets (i.e. remove).\n*. 2005/09/07 Only allow FB80 for LKWM.\n*/\naddress ISREdit\n\"Macro\"\n\n\"(Sess) = SESSION\"\n/* Archive can not be used in EDIF or VIIF */\nif WordPos(Sess,'EDIT VIEW') = 0 then exit\n\n/* Check the dataset being edited (the target). */\n\"(DID) = DATAID\"\n\"(Vol) = VOLUME\"\n\"(Mem) = MEMBER\"\n\"(DSN) = DATASET\"\nif Right(DSN,4) = '.ARC' then exit    /* Can't archive an archive */\nArcKey = Vol':'DSN'('Mem')'           /* Key for archive table */\n\"(LRecL)   = LRECL\"\n\"(RecFm)   = RECFM\"\nif RecFm = 'V' then LRecL = LRecL+4\n\n/* Check the control dataset (the archive). */\nzParms = 0\nif ListDSI(\"'\"DSN\"'\") = 0 & Vol = SysVolume then ArcVol = ''\nelse ArcVol = 'VOLUME('Vol')'         /* accessed by volume */\nArcDSN = DSN'.ARC'\nArcLen = Length(ArcDSN)\nLKWMTbl = ''                          /* ISPF table for LKWM */\nif Mem = '' then do                       /* sequential dataset */\n   if ArcLen > 44 then exit     /* can't archive, name too long */\n   /* Archive doesn't exist */\n   if ListDSI(\"'\"ArcDSN\"'\" ArcVol) <> 0 then exit\n   if Left(SysDSOrg,2) <> 'PS' then exit  /* archive must be seq */\nend; else do                              /* PDS dataset */\n   if Right(Mem,1) = '{' then exit        /* Can't archive these. */\n   if ArcLen > 44 | ListDSI(\"'\"ArcDSN\"'\" ArcVol) <> 0 then do\n      address ISPExec\n      \"VGet (ZTerm)\"                /* deal with strange term types */\n      if ZTerm <> '3278' & ZTerm <> '3278A' then\n         \"Select Pgm(ISPTTDef) Parm(3278)\"\n      \"LMOpen DataID(&DID)\"\n      \"LMMFind DataID(&DID) Member(Z{PARMS{)\"\n      zParms = (RC = 0)\n      \"LMClose DataID(&DID)\"\n      if ZTerm <> '3278' & ZTerm <> '3278A' then\n         \"Select Pgm(ISPTTDef) Parm(\"ZTerm\")\"\n      if zParms = 0 then exit\n      ArcDSN = DSN                        /* self-archived */\n      call ListDSI \"'\"DSN\"' Volume(\"Vol\")\"\n      address\n   end\n   if Left(SysDSOrg,2) <> 'PO' then exit  /* archive must be PDS */\n   if Left(SysRecFM,2) = 'FB' & SysLRecL = 80 then LKWMTbl = 'Z{LKWM{'\nend\n\n/* Make sure LRecL is long enough */\nif SysLRecL < 80 | SysLRecL < LRecL then exit\n\n/* O.K. - set up for archiving */\nOpts = 'Hist(5) NoArc NoSync Desc'        /* Defaults */\nparse VALUE 5 1 1 1 0 WITH Hist NoArc NoSync Desc Quiet\n\n/*\nSrc = \"H224.ARCHIVE.SOURCE\"\naddress TSO,\n   \"AltLib ACTIVATE APPLICATION (EXEC) DATASET('\"Src\"') UNCOND\"\nif RC <> 0 then exit */               /* No archive source library! */\n\n/* These definitions add archive processing to ISPF commands. */\nif Sess = 'VIEW' then\n   \"Define END     ALIAS A#CAN\"\nelse do\n   \"Define END     ALIAS A#END\"\n   \"Define SAVE    ALIAS A#SAVE\"\nend\n\"Define CANCEL  ALIAS A#CAN\"\n\"Define COMPARE ALIAS A#CMP\"\n\"Define HISTORY ALIAS A#VHIST\"\n\"Define OPTS    ALIAS A#OPT\"\n\"Define OPTIONS ALIAS A#OPT\"\n\"Define RESTORE ALIAS A#REST\"\n\"Define VIEW    ALIAS A#VIEW\"\n\naddress ISPExec\n/* \"LIBDEF ISPPLIB DATASET ID('\"Src\"') STACK\" */\n\"TbCreate archive NOWRITE SHARE KEYS(ArcKey)\",\n   \"Names(ArcDSN ArcTbl ArcVol LKWMTbl Opts\",\n         \"DL Desc1 Desc2 Desc3 Desc4 Desc5 Desc6)\"\nif RC = 8 then \"TbOpen archive NOWRITE SHARE\"\n\ndo i=1 to 20 until RC = 0\n   ArcTbl = 'ARC'i\n   \"TbCreate\" ArcTbl \"NOWRITE KEYS(Mod)\",\n      \"Names(User Vers HL Hist1 Hist2 Hist3 Hist4 Hist5 Hist6)\"\nend\n\"TbAdd archive\"                       /* Save the archive data */\n\n/* Copy the member to the Last Known Working Member if required. */\nif LKWMTbl <> '' then do\n   address TSO \"Alloc f(arc) dsn('\"ArcDSN\"')\" ArcVol \"SHR REUSE\"\n   \"TbOpen\" LKWMTbl \"NOWRITE Library(ARC)\"\n   if RC = 0 then do\n      \"TbGet\" LKWMTbl\n      GotLKWM = (RC = 0 & LKWM <> '')\n      \"TbClose\" LKWMTbl\n      if GotLKWM then do\n         DoCopy = 0\n         \"LMOpen DataID(&DID)\"\n         \"LMMFind DataID(&DID) Member(&Mem) Stats(YES)\"\n         cMod = ZLM4Date ZLMTime':'ZLMSec\n         if Mod > cMod then do\n            \"LMMFind DataID(&DID) Member(&LKWM) Stats(YES)\"\n            if RC = 8 then lMod = ''\n            else lMod = ZLM4Date ZLMTime':'ZLMSec\n            if cMod > lMod then DoCopy = 1\n         end\n         \"LMClose DataID(&DID)\"\n         if DoCopy then do\n            \"LMInit DataID(ToID) DataSet('\"DSN\"')\" ArcVol\n            \"LMCopy FromID(&DID) FromMem(&Mem)\",\n               \"ToDataID(&ToID) ToMem(&LKWM) REPLACE\"\n            \"LMFree DataID(&ToID)\"\n         end\n      end\n   end\n   \"TbStats BADTABLE Library(BADLIB)\" /* workaround for ISPF bug */\n   address TSO \"Free f(arc)\"\nend\n\n/* Set CAPS OFF for messages. */\naddress ISREdit\n\"(CM) = CAPS\"\n\"CAPS = OFF\"\nGlobal = ''                           /* Set up for Global opts */\nif zParms = 0 & Mem <> '' then do\n   address ISPExec\n   \"LMInit DataID(ArcID) DataSet('\"ArcDSN\"')\" ArcVol\n   \"LMOpen DataID(&ArcID)\"\n   \"LMMFind DataID(&ArcID) Member(Z{PARMS{)\"\n   zParms = (RC = 0)\n   \"LMClose DataID(&ArcID)\"\n   \"LMFree DataID(&ArcID)\"\nend\naddress TSO\nif zParms then do\n   \"Alloc f(in) dsn('\"ArcDSN\"(Z{PARMS{)')\" ArcVol \"SHR REUSE\"\n   \"ExecIO * DiskR in (STEM Parms. FINIS\"\n   \"Free f(in)\"\n   do i=1 to Parms.0\n      parse VAR Parms.i 2 Type Info\n      if Translate(Type) = 'OPTS' then Global = Global Info\n   end\n   Global = Space(Global)\n   interpret a#Opts(Global)\nend\nOpts = Opts'00'x||Global\naddress ISPExec \"TbMod archive\"\nparse VALUE A#Open('ARC',ArcKey,'READ') WITH Archive .\nif Archive = '' then do               /* No archive member */\n   address ISREdit\n   if NoArc then\n      \"LINE_AFTER 0 = MSGLINE 'No archive exists for this member'\"\n   \"CAPS = &CM\"\n   exit                               /* OK - continue editing. */\nend\n\nline = 1\nparse VALUE '0' WITH dl,Desc1,Desc2,Desc3,Desc4,Desc5,Desc6\nparse VALUE '0' WITH hl,Hist1,Hist2,Hist3,Hist4,Hist5,Hist6\nparse VALUE '0' WITH Data,Mbr\ndo forever\n   \"ExecIO 1 DiskR arc\" line\n   if RC <> 0 then leave\n   line = line+1\n   pull 2 Type . 'HEADER('Header')' 1 'DATA('Data')' 1 'MEMBER('Mbr')'\n   if Header = '' then Header = 0\n   if Data = '' then Data = 0\n   if Header = 0 then Head.0 = 0\n   else \"ExecIO\" Header \"DiskR arc\" line \"(STEM Head.\"\n   line = line + Header\n   if WordPos(Type,'CURRENT ARCHIVE') = 0 then leave  /* error */\n   parse VALUE '00.00' WITH pVers pUser pMod\n   if Head.0 = 0 then do\n      if Type = 'CURRENT' then ArcVers = pVers\n      else do\n         address ISPExec \"TbAdd\" ArcTbl\n         parse VALUE '0' WITH hl,Hist1,Hist2,Hist3,Hist4,Hist5,Hist6\n      end\n   end; else do\n      Local = ''                      /* Set up for Local opts */\n      do i=1 to Head.0\n         parse UPPER VAR Head.i 2 Op .\n         Select\n         When Op = 'OPTS' then Local = Local||'00'x SubWord(Head.i,2)\n         When Op = 'STATS' then do\n            parse UPPER VAR Head.i,\n               'VERSION('pVers')' 1 'USER('pUser')' 1 'MODIFIED('pMod')'\n            end\n         When Op = 'HIST' then do\n            hl = hl+1\n            parse VALUE Strip(Head.i) WITH . '(' Info\n            call Value 'HIST'hl, Left(Info,Length(Info)-1)\n            end\n         When Op = 'DESC' then do\n            dl = dl+1\n            parse VALUE Strip(Head.i) WITH . '(' Info\n            call Value 'DESC'dl, Left(Info,Length(Info)-1)\n            end\n         Otherwise nop\n         End\n      end\n      if Type <> 'CURRENT' then do\n         address ISPExec \"TbAdd\" ArcTbl\n         parse VALUE '0' WITH hl,Hist1,Hist2,Hist3,Hist4,Hist5,Hist6\n      end; else do\n         interpret a#Opts(Local)\n         Opts = Opts||Local\n         address ISPExec \"TbMod archive\"\n         ArcVers = pVers\n      end\n   end\n   Vers = pVers; User = pUser; Mod = pMod\n   line = line + Data\nend\n\"ExecIO 0 DiskR arc (FINIS\"\n\"Free f(arc)\"\naddress ISPExec \"TbQuery\" ArcTbl \"RowNum(Rows)\"\naddress ISREdit\nif Rows = 0 & Data = 0 & Mbr = '' then do  /* No archive data */\n   if Mem = '' then type = 'dataset'\n   else type = 'member'\n   if NoArc then\n      \"LINE_AFTER 0 = MSGLINE 'There is no history for this &type'\"\n   \"CAPS = &CM\"\n   exit\nend\naddress ISPExec \"TbAdd\" ArcTbl\n\n/* Put the recent change history in message lines on the display */\naddress ISPExec\n/* archive description */\nif Desc then do i=1 to dl\n   push Value('DESC'i)\nend\nif Queued() > 0 then push ' '\n\n/* recent change history */\n\"TbTop\" ArcTbl\ndo v=1 to Hist\n   \"TbSkip\" ArcTbl\n   if RC > 0 then leave\n   if Mod <> '' then Mod = 'Modified at' Mod\n   if User <> '' then User = 'by' User\n   push 'v'Vers Mod User\n   do i=1 to hl\n      push '       'Value('HIST'i)\n   end\nend\naddress ISREdit\ndo Queued()\n   parse PULL Data\n   \"LINE_AFTER 0 = NOTELINE (Data)\"\nend\nif Mem <> '' then do\n   VV = ''; LL = ''\n   \"(VV) = VERSION\"\n   \"(LL) = LEVEL\"\n   DiskVers = Right(VV,2,0)'.'Right(LL,2,0)\n   if DiskVers <> ArcVers & NoSync then\n      \"LINE_AFTER 0 = MSGLINE\",\n         \"'WARNING: Current v&DiskVers differs from archive v&ArcVers'\"\nend\n\"CAPS = &CM\"\nexit\n)MEMBER A#MAKE LINES(144)\n/* Rexx function to make a temporary dataset containing a specific\n*  Dataset(Member) at a specific Version() User() Modified() level.\n*  Usage: a#Make(ArcKey,Stats)\n*  Returns the dataset name of the temporary dataset.\n*  ArcKey is in the format Volume:DSN(Member),\n*  Stats is in the format\n*  Version(vv.ll) User(uuuuuuu) Modified(yyyy/mm/dd hh:mm:ss)\n*.\n*. 2005/12/02 Use the archive copy, not the edited dataset.\n*. 2005/08/09 Created by bsquare\n*/\narg ArcKey,Stats\nif ArcKey = '' then signal Macro\nparse VAR ArcKey Vol ':' DSN\nif DSN = '' then parse VAR Vol DSN,Vol\nparse VAR DSN DSN '('Mem')'\nif DSN = '' then return ''\n\nif Vol <> '' then Vol = ' VOLUME('Vol')'\nif ListDSI(\"'\"DSN\"'\"Vol) <> 0 then return ''\nRecFm = Left(SysRecFm,1)\nif RecFm <> 'F' & RecFm <> 'V' then return ''\n\n/* Find LLQ of ArcKey */\nLLQ = Translate(DSN,,'.')\nLLQ = Word(LLQ,Words(LLQ))\nTemp = 'DS'Right(Time('S'),5,0)\nTempDS = 'TEMP.'Temp'.'LLQ\naddress TSO\n\"Alloc f(\"Temp\") dsn(\"TempDS\") NEW CATALOG\",\n   \"RecFm(\"RecFM \"B) LRecL(\"SysLRecL\") DSOrg(PS) SPACE(15,15) TRACKS\"\nif RC <> 0 then return ''\n\"Free f(\"Temp\")\"\n\naddress ISPExec\n\"VPut (ArcKey Stats) SHARED\"\n\"Edit DataSet(\"TempDS\") MACRO(a#Make)\"\nreturn TempDS\n\nMacro:\n   address ISPExec\n   \"VGet (ArcKey Stats) SHARED\"\n   if RC <> 0 then return\n   address ISREdit\n   \"Macro\"\n   if RC <> 0 then return\n\n   parse VALUE a#Open('IN',ArcKey,'READ') WITH Archive VolInfo\n   if Archive = '' then signal Cancel\n   address TSO\n   \"ExecIO * DiskR in (STEM Arc. FINIS\"\n   \"Free f(in)\"\n\n   address ISREdit\n   parse VAR ArcKey Vol ':' DSN\n   if DSN = '' then parse VAR Vol DSN,Vol\n\n   /* Set up the initial dataset contents */\n   if Arc.0 = 0 then signal Cancel          /* empty archive */\n   parse UPPER VAR Arc.1 2 Section . 'HEADER('Header')',\n         1 'DATA('Data')' 1 'MEMBER('Mem')'\n   if Section <> 'CURRENT' then signal Cancel /* bad archive */\n   if Header = '' then Header = 0\n   if Data <> '' then do\n      do i=1 to Data\n         Cur = Value('ARC.'Header+i+1)\n         \"LINE_AFTER\" i-1 \"= (Cur)\"\n      end\n   end; else do\n      if Mem = '' then signal Cancel        /* No archive copy! */\n      parse VAR Archive ArcDSN '('\n      ArcCopy = ArcDSN'('Mem')'\n      if VolInfo = '' then do\n         \"COPY '\"ArcCopy\"' BEFORE .ZFIRST\"\n         if RC <> 0 then signal Cancel      /* No archive copy! */\n      end; else do\n         address TSO\n         \"Alloc f(in) dsn('\"ArcCopy\"')\"VolInfo \"SHR REUSE\"\n         if RC <> 0 then signal Cancel\n         \"ExecIO * DiskR in (STEM In. FINIS\"\n         \"Free f(in)\"\n         address ISREdit\n         do i=1 to In.0\n            Cur = In.i\n            \"LINE_AFTER\" i-1 \"= (Cur)\"\n         end\n      end\n   end\n   if Data = '' then Data = 0\n\n   parse UPPER VAR Stats,\n      'VERSION('Vers')' 1 'USER('User')' 1 'MODIFIED('Mod')'\n   if Mod <> '' then Key = 'MOD'\n   else if Vers <> '' then Key = 'VERS'\n   else Key = 'USER'\n   ln = 2\n   do until ln > Arc.0 | Value(Key) = Value('A'Key)\n      aVers = '00.00'; aUser = ''; aMod = ''\n      do Header\n         parse UPPER VALUE ln+1||Arc.ln WITH ln '-' Type Info\n         if Type <> 'STATS' then iterate\n         parse VAR Info,\n            'VERSION('aVers')' 1 'USER('aUser')' 1 'MODIFIED('aMod')'\n      end\n      last = ln+Data\n      offset = 0                   /* line offset */\n      if Section = 'ARCHIVE' then do while ln < last\n         parse UPPER VALUE ln+1||Arc.ln WITH ln '-' Type Info\n         Select\n         When Type = 'INS' then do          /* Insert Lines at Start */\n            parse VAR Info 'LINES('Lines')' 1 'START('Start')'\n            Start = Start-1\n            do i=ln to ln+Lines-1\n               Cur = Arc.i\n               \"LINE_AFTER &Start = (Cur)\"\n               Start = Start+1\n            end\n            ln = ln+Lines\n            offset = offset + Lines\n            end\n         When Type = 'DEL' then do\n            parse VAR Info 'COUNT('Count')' 'START('Start')'\n            Start = Start + offset\n            do Count\n               \"DELETE &Start\"\n            end\n            offset = offset - Count\n            end\n         Otherwise nop\n         End\n      end\n      ln = last\n      parse UPPER VALUE ln+1||Arc.ln WITH ln ')' Section Info\n      if Section <> 'ARCHIVE' then leave\n      parse VAR Info 'HEADER('Header')' 1 'DATA('Data')'\n      if Header = '' then Header = 0\n   end\n   \"BUILTIN SAVE\"\n   \"BUILTIN END\"\n   exit\n\nCancel: /* Cancel the macro - major error */\n   address ISREdit \"CANCEL\"\n   exit\n)MEMBER A#OPEN LINES(128)\n/* Rexx function to open the archive(member) for a given\n*  Dataset(Member).  This will be slightly different for READ and WRITE.\n*  Usage: a#Open(DD,ArcKey,Purpose)\n*  Returns archive\u00dd(member)\u00a8 \u00ddVOLUME(volser)\u00a8 or '' on failure.\n*  ArcKey is in the format Volume:DSN(Member),\n*  Purpose is either READ or WRITE.\n*.\n*. 2005/08/04 Created by bsquare\n*. 2005/08/17 Add ISPTTDef for strange terminal types.\n*.            LMMFind screws up with terminal types other than 3278(a).\n*/\narg DD,ArcKey,Purpose\nif DD = '' then return ''\nparse VAR ArcKey Vol ':' DSN\nif DSN = '' then parse VAR ArcKey DSN,Vol\nparse VAR DSN DSN '('Mem')'\nif DSN = '' then return ''\nif Purpose = '' then Purpose = 'READ'\nif Purpose <> 'READ' & Purpose <> 'WRITE' then return ''\n\naddress TSO\nif Right(DSN,4) = '.ARC' then return ''\nif Right(Mem,1) = '{' then return ''\n\n/* Use volume information for uncataloged datasets */\nIsCat = ListDSI(\"'\"DSN\"'\") = 0\nif IsCat & Vol <> '' then IsCat = (SysVolume = Vol)\nif IsCat then Vol = ''\nelse Vol = ' VOLUME('Vol')'\n\n/* Check the control dataset (the archive). */\nSysDSOrg = 'BAD'\nArcDSN = DSN'.ARC'\nif Length(ArcDSN) <= 44 then call ListDSI \"'\"ArcDSN\"'\"||Vol\n\n/* Check sequential datasets first, they're simpler */\nif Mem = '' then do\n   if Left(SysDSOrg,2) <> 'PS' then return ''\n   if Purpose = 'READ' then\n        \"Alloc f(\"DD\") dsn('\"ArcDSN\"') SHR REUSE\"\n   else \"Alloc f(\"DD\") dsn('\"ArcDSN\"') OLD REUSE\"\n   if RC <> 0 then return ''\n   return ArcDSN\nend\n\n/* The remainder of this is only for PDS archives */\nif Left(SysDSOrg,2) <> 'PO' then ArcDSN = DSN\nArcMem = Strip(Left(Mem,7))'{'\n\naddress ISPExec\n\"VGet (ZTerm)\"\nif ZTerm <> '3278' & ZTerm <> '3278A' then\n   \"Select Pgm(ISPTTDEF) Parm(3278)\"\n\"LMInit DataID(DID) DataSet('\"ArcDSN\"')\"Vol \"ENQ(SHRW)\"\n\"LMOpen DataID(&DID)\"\n\"LMMFind DataID(&DID) Member(&ArcMem)\"\nif RC = 0 then\n   \"LMGet DataID(&DID) Mode(INVAR) MaxLen(80) DataLoc(Data) DataLen(Len)\"\nif RC <> 0 then signal NoMem\n\nparse UPPER VAR Data 2 Type Info\nif Type = 'RESOLVE' then do\n   parse VAR Info 'ID('ConID')'\n   ArcMem = 'Z{'Right(ConID,4,0)||SubStr(Mem,8)||'{'\n   \"LMMFind DataID(&DID) Member(&ArcMem)\"\n   if RC <> 0 then signal NoMem\n   call RetMem ArcDSN'('ArcMem')'\nend\n/* Type = 'CURRENT' */\nparse VAR Info 'MEMBER('aMem')'\nif aMem = Mem then call RetMem ArcDSN'('ArcMem')'\nif Purpose = 'READ' then call RetMem\n\n/* Resolve contention for WRITE */\nParms. = 0\nConID = ''\n\"LMMFind DataID(&DID) Member(Z{PARMS{)\"\nif RC = 0 then do\n   address TSO\n   \"Alloc f(in) dsn('\"ArcDSN\"(Z{PARMS{)')\"Vol \"SHR REUSE\"\n   \"ExecIO * DiskR in (STEM Parms. FINIS\"\n   \"Free f(in)\"\n   do i=1 to Parms.0\n      parse UPPER VAR Parms.i 2 Type Info\n      if Type <> 'RESOLVE' then iterate\n      pl = i\n      parse UPPER VAR Parms.i . 'ID('ConID')'\n      leave\n   end\nend\nif ConID <> '' then ConID = Right(ConID+1,4,0)\nelse do\n   ConID = '0000'\n   pl = Parms.0+1; Parms.0 = pl\nend\nParms.pl = ')Resolve ID('ConID')'\naddress TSO\n\"Alloc f(out) dsn('\"ArcDSN\"(Z{PARMS{)')\"Vol \"SHR REUSE\"\n\"ExecIO\" Parms.0 \"DiskW out (STEM Parms. FINIS\"\n\"Free f(out)\"\nOldArc = 'Z{'ConID||SubStr(aMem,8)||'{'\naddress ISPExec\n\"LMClose DataID(&DID)\"\n\"LMOpen DataID(&DID) Option(OUTPUT)\"\n\"LMMRen DataID(&DID) Member(&ArcMem) NewName(&OldArc)\"\nData = Parms.pl\n\"LMPut DataID(&DID) Mode(INVAR) DataLoc(Data) DataLen(80)\"\n\"LMMAdd DataID(&DID) Member(&ArcMem) Stats(NO)\"\nArcMem = 'Z{'ConID||SubStr(Mem,8)||'{'\ncall RetMem ArcDSN'('ArcMem')'\n\nNoMem:\n   if Purpose = 'READ' then call RetMem\n   else call RetMem ArcDSN'('ArcMem')'\n\nRetMem:\n   arg DSN\n   address ISPExec\n   \"LMClose DataID(&DID)\"\n   \"LMFree DataID(&DID)\"\n   if ZTerm <> '3278' & ZTerm <> '3278A' then\n      \"Select Pgm(ISPTTDEF) Parm(\"ZTerm\")\"\n   if DSN <> '' then do\n      address TSO,\n         \"Alloc f(\"DD\") dsn('\"DSN\"')\"Vol \"SHR REUSE\"\n      if RC <> 0 then exit ''\n   end\n   exit DSN||Vol\n)MEMBER A#OPT LINES(191)\n/* Rexx edit macro to set options for an archive (global or local).\n*  Usage: Install using #CONFIG.\n*.\n*. 2005/08/26 Created by bsquare\n*. 2005/09/06 Fix for sequential datasets (remove LKWM).\n*. 2005/09/07 Check for LKWM allowable (set in a#Init).\n*/\naddress ISREdit\n\"Macro\"                /* called as edit macro */\nif RC <> 0 then exit   /* called from dataset or member list */\nPanel.MEMBER  = 'a#OptMP'\nPanel.DATASET = 'a#OptDP'\n\"(Vol) = VOLUME\"\n\"(DSN) = DATASET\"\n\"(Mem) = MEMBER\"\nArcKey = Vol':'DSN'('Mem')'\nif Mem <> '' then DSN = DSN'('Mem')'\naddress ISPExec\n\"TbGet archive\"\nLKWM = ''\nif LKWMTbl <> '' then do\n   address TSO \"Alloc f(arc) dsn('\"ArcDSN\"')\" ArcVol \"SHR REUSE\"\n   \"TbOpen\" LKWMTbl \"NOWRITE Library(ARC)\"\n   if RC = 0 then do\n      \"TbGet\" LKWMTbl\n      \"TbClose\" LKWMTbl\n   end\nend\n\nif Mem = '' then\n   parse VAR Opts Def '00'x . '00'x DataSet,Member\nelse\n   parse VAR Opts Def '00'x DataSet '00'x Member\nDataSet = Space(Translate(DataSet,,'00'x))\nMember  = Space(Translate(Member ,,'00'x))\noDS = DataSet; oMem = Member\nif LKWM <> '' | Member <> '' then OptType = 'MEMBER'\nelse OptType = 'DATASET'\nparse VALUE 0 LKWM WITH Accept OldLKWM .,CopyLKWM\ndo until RV <> 0\n   parse VALUE WITH Hist,Desc,NoArc,NoSync,Quiet\n   interpret a#Opts(Value(OptType))\n   if Hist Desc NoArc NoSync = '0 0 0 0' then\n      parse VALUE 1 WITH Quiet,Hist,Desc,NoArc,NoSync\n   if Mem = '' & OptType = 'MEMBER' then do\n      OptType = 'DATASET'\n      say 'Hey!!'\n   end\n   oType = OptType\n   \"Display Panel(\"Panel.OptType\")\"\n   RV = RC\n   Vars = 'Hist Desc NoArc NoSync Quiet'\n   call Value oType,''\n   do while Vars <> ''\n      parse VAR Vars v Vars\n      Val = Strip(Value(v))\n      if Val = 'YES' then call Value oType,Value(oType) v\n      else if Val <> '' then\n         call Value oType,Value(oType) v||'('Val')'\n   end\nend\nif LKWMTbl <> '' then do\n   if Accept then do\n      if LKWM = '' then CopyLKWM = ''\n      if CopyLKWM <> '' then do\n         address ISREdit\n         \"(Copy) = DATASET\"\n         \"(DID) = DATAID\"\n         address ISPExec\n         \"LMInit DataID(ToID) DataSet('\"Copy\"') VOLUME(\"Vol\")\"\n         \"LMCopy FromID(&DID) FromMem(&Mem)\",\n            \"ToDataID(&ToID) ToMem(&LKWM) REPLACE\"\n         \"LMFree DataID(&ToID)\"\n      end\n      if OldLKWM <> LKWM | CopyLKWM <> '' then do\n         Mod = Translate('1234/56/78',Date('S'),'12345678') Time()\n         \"TbOpen\" LKWMTbl \"Library(ARC)\"\n         if RC <> 0 then\n            \"TbCreate\" LKWMTbl \"Keys(Mem) Names(LKWM Mod) Library(ARC)\"\n         if LKWM <> '' then \"TbMod\" LKWMTbl\n         else \"TbDelete\" LKWMTbl\n         \"TbClose\" LKWMTbl \"Library(ARC)\"\n      end\n   end\n   \"TbStats BADTABLE Library(BADLIB)\" /* workaround for ISPF bug */\n   address TSO \"Free f(arc)\"\nend\n/* normalize options for test */\nDataSet = Space(DataSet)\nMember  = Space(Member)\n/* quit if there is nothing to do */\nif Accept = 0 | (oDS = DataSet & oMem = Member) then exit\n\n/* Set Global and Local from DataSet and Member */\nif Mem = '' then do; Loc = DataSet; Global = ''; end\nelse do; Global = DataSet; Loc = Member; end\nLocal = ''                          /* split options into lines */\ndo while Loc <> ''\n   p = LastPos(' ',Loc' ',70)\n   parse VAR Loc cur =(p) Loc\n   Local = Local||'00'x||cur\nend\nLocal = SubStr(Local,2)\n\nOpts = Def'00'x||Global'00'x||Local\n\"TbMod archive\"                     /* update options in table */\n\n/* cLocal  = Local options changed */\n/* cGlobal = Global options changed */\ncLocal  = (Mem <> '' & oMem <> Member) | (Mem = '' & oDS <> DataSet)\ncGlobal = (Mem <> '' & oDS <> DataSet)\nif cLocal then do                   /* local options changed */\n   parse VALUE '0 0' WITH Arc.0 Head.0,Data,Mbr\n   if a#Open('IN',ArcKey,'READ') <> '' then do\n      address TSO\n      \"ExecIO 1 DiskR in\"\n      if RC = 0 then do\n         pull 'HEADER(' Hdr ')' 1 'DATA(' Data ')' 1 'MEMBER(' Mbr ')'\n         if Hdr <> '' then \"ExecIO\" Hdr \"DiskR in (STEM Head.\"\n         do i=1 to Head.0\n            if Translate(Word(Head.i,1)) = '-OPTS' then Head.i = ''\n         end\n      end\n      \"ExecIO * DiskR in (STEM Arc. FINIS\"\n      \"Free f(in)\"\n   end\n   if a#Open('OUT',ArcKey,'WRITE') <> '' then do\n      do i=1 to Head.0\n         if Head.i <> '' then queue Head.i\n      end\n      do while Local <> ''\n         parse VAR Local cur '00'x Local\n         queue '-Opts' cur\n      end\n      Extra = ''\n      if Data <> '' then Extra = Extra 'Data('Data')'\n      if Mbr  <> '' then Extra = Extra 'Member('Mbr')'\n      if Queued() = 0 & Extra = '' & Arc.0 = 0 then\n         \"ExecIO 0 DiskW out (OPEN FINIS\"      /* truncate */\n      else do\n         push ')Current Header('Queued()')'||Extra\n         \"ExecIO\" Queued() \"DiskW out\"\n         \"ExecIO\" Arc.0 \"DiskW out (STEM Arc. FINIS\"\n      end\n      \"Free f(out)\"\n   end\nend\nif cGlobal then do                  /* global options changed */\n   address ISPExec\n   \"VGet (ZTerm)\"                   /* deal with strange term types */\n   if ZTerm <> '3278' & ZTerm <> '3278A' then\n      \"Select Pgm(ISPTTDef) Parm(3278)\"\n   \"LMInit DataID(DataID) DataSet('\"ArcDSN\"')\" ArcVol\n   \"LMOpen DataID(&DataID)\"\n   \"LMMFind DataID(&DataID) Member(Z{PARMS{)\"\n   Exists = (RC = 0)                /* this member already exists. */\n   \"LMClose DataID(&DataID)\"\n   \"LMFree DataID(&DataID)\"\n   if ZTerm <> '3278' & ZTerm <> '3278A' then\n      \"Select Pgm(ISPTTDef) Parm(\"ZTerm\")\"\n   address TSO\n   if Exists then do\n      \"Alloc f(arc) dsn('\"ArcDSN\"(Z{PARMS{)')\" ArcVol \"SHR REUSE\"\n      \"ExecIO * DiskR arc (STEM Arc. FINIS\"\n      \"Free f(arc)\"\n   end; else Arc.0 = 0\n   if DataSet = '' then Opts = ''\n   else Opts = ')Opts' Strip(DataSet)\n   \"Alloc f(arc) dsn('\"ArcDSN\"(Z{PARMS{)')\" ArcVol \"SHR REUSE\"\n   \"ExecIO 0 DiskW arc (OPEN\"       /* force truncation */\n   do while Length(Opts) > 80\n      p = LastPos(' ',Opts' ',79)\n      parse VAR Opts cur =(p) Opts\n      queue cur\n      \"ExecIO 1 DiskW arc\"\n      if Opts <> '' then Opts = ')Opts' Strip(Opts)\n   end\n   if Opts <> '' then do\n      queue Opts\n      \"ExecIO 1 DiskW arc\"\n   end\n   do i=1 to Arc.0\n      parse VAR Arc.i Type Info\n      if Translate(Type) <> ')OPTS' then do\n         queue Strip(Arc.i)\n         \"ExecIO 1 DiskW arc\"\n      end\n   end\n   \"ExecIO 0 DiskW arc (FINIS\"\n   \"Free f(arc)\"\nend\n)MEMBER A#OPTDP LINES(56)\n)ATTR\n _ TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(ASIS)\n ! TYPE(INPUT) INTENS(HIGH) CAPS(ON)  JUST(ASIS) PAS(ON)\n * TYPE(OUTPUT) PAS(ON)\n $ TYPE(PS)\n)BODY EXPAND(\\\\)\n%&ZUSER---- MCIT Edit Archive Control \\-\\&ZDATE-&ZTIME--\n%Option  ===>_ZCMD\\ \\+\n+\n+ Set%DataSet+Options for%&tDSN\n+                                               *GotoMem\n+\n+ Display the following upon entry to an Edit/View session:\n+      Number of versions for History:_Hist+    +(default 5)\n+                 Archive description:%&Desc    $(Change)\n+          No Archive warning message:%&NoArc   $(Change)\n+ Archive out of sync warning message:%&NoSync  $(Change)\n+               SUPPRESS ALL MESSAGES:%&Quiet   $(Change)\n+\n+\\ \\Use%END+to CANCEL or$ACCEPT+to ACCEPT the changes\\ \\+\n)INIT\n &Toggle = ''\n &Desc   = Trans(Trunc(&Desc  ,1) 0,NO 1,YES N,NO Y,YES *,' ')\n &NoArc  = Trans(Trunc(&NoArc ,1) 0,NO 1,YES N,NO Y,YES *,' ')\n &NoSync = Trans(Trunc(&NoSync,1) 0,NO 1,YES N,NO Y,YES *,' ')\n &Quiet  = Trans(Trunc(&Quiet ,1) 0,NO 1,YES N,NO Y,YES *,' ')\n &tDSN = Trunc(&DSN,'(')\n if (&Mem = &Z)\n    &GotoMem = ''\n    .ATTR(GotoMem) = 'PAS(OFF)'\n else\n    &GotoMem = '(Member Options)'\n)PROC\n if (&Toggle = 1)\n    &Desc   = Trans(Trunc(&Desc  ,1) ' ',NO N,YES Y,' ' *,' ')\n if (&Toggle = 2)\n    &NoArc  = Trans(Trunc(&NoArc ,1) ' ',NO N,YES Y,' ' *,' ')\n if (&Toggle = 3)\n    &NoSync = Trans(Trunc(&NoSync,1) ' ',NO N,YES Y,' ' *,' ')\n if (&Toggle = 4)\n    &Quiet  = Trans(Trunc(&Quiet ,1) ' ',YES Y,NO N,' ' *,' ')\n    if (&Quiet = YES)\n       &Hist = &Z\n       &Desc = &Z\n       &NoArc = &Z\n       &NoSync = &Z\n if (&Accept = 1)\n    .RESP = END\n)PNTS\n FIELD(GotoMem)  VAR(OptType) VAL(MEMBER)\n FIELD(ZPS00001) VAR(Toggle) VAL(1)\n FIELD(ZPS00002) VAR(Toggle) VAL(2)\n FIELD(ZPS00003) VAR(Toggle) VAL(3)\n FIELD(ZPS00004) VAR(Toggle) VAL(4)\n FIELD(ZPS00005) VAR(ACCEPT) VAL(1)\n)END\n)MEMBER A#OPTMP LINES(60)\n)ATTR\n _ TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(ASIS)\n ! TYPE(INPUT) INTENS(HIGH) CAPS(ON)  JUST(ASIS)\n $ TYPE(PS)\n)BODY EXPAND(\\\\)\n%&ZUSER---- MCIT Edit Archive Control \\-\\&ZDATE-&ZTIME--\n%Option  ===>_ZCMD\\ \\+\n+\n+ Set%Member +Options for%&DSN\n+                                               $(DataSet Options)\n+\n+ Display the following upon entry to an Edit/View session:\n+      Number of versions for History:_Hist+    +(default 5)\n+                 Archive description:%&Desc    $(Change)\n+          No Archive warning message:%&NoArc   $(Change)\n+ Archive out of sync warning message:%&NoSync  $(Change)\n+               SUPPRESS ALL MESSAGES:%&Quiet   $(Change)\n+\n+ For RECFM=FB,LRECL=80 archives ONLY:\n+ Set the Last Known Working Member to keep a specific version\n+ of &DSN in case of logical errors.\n+           Last Known Working Member:!LKWM    +&Mod\n+Copy the current version to the LKWM:%&CopyLKWM$(Change)\n+\n+\\ \\Use%END+to CANCEL or$ACCEPT+to ACCEPT the changes\\ \\+\n)INIT\n &Toggle = ''\n &Desc   = Trans(Trunc(&Desc  ,1) 0,NO 1,YES N,NO Y,YES *,' ')\n &NoArc  = Trans(Trunc(&NoArc ,1) 0,NO 1,YES N,NO Y,YES *,' ')\n &NoSync = Trans(Trunc(&NoSync,1) 0,NO 1,YES N,NO Y,YES *,' ')\n &Quiet  = Trans(Trunc(&Quiet ,1) 0,NO 1,YES N,NO Y,YES *,' ')\n if (&CopyLKWM \u00ac= &Z)\n    &CopyLKWM = 'Y'\n)PROC\n if (&Toggle = 1)\n    &Desc   = Trans(Trunc(&Desc  ,1) ' ',NO N,YES Y,' ' *,' ')\n if (&Toggle = 2)\n    &NoArc  = Trans(Trunc(&NoArc ,1) ' ',NO N,YES Y,' ' *,' ')\n if (&Toggle = 3)\n    &NoSync = Trans(Trunc(&NoSync,1) ' ',NO N,YES Y,' ' *,' ')\n if (&Toggle = 4)\n    &Quiet  = Trans(Trunc(&Quiet ,1) ' ',YES Y,NO N,' ' *,' ')\n    if (&Quiet = YES)\n       &Hist = &Z\n       &Desc = &Z\n       &NoArc = &Z\n       &NoSync = &Z\n if (&Toggle = 5)\n    &CopyLKWM= Trans(&CopyLKWM Y,' ' *,Y)\n if (&Accept = 1)\n    .RESP = END\n)PNTS\n FIELD(ZPS00001) VAR(OptType) VAL(DATASET)\n FIELD(ZPS00002) VAR(Toggle) VAL(1)\n FIELD(ZPS00003) VAR(Toggle) VAL(2)\n FIELD(ZPS00004) VAR(Toggle) VAL(3)\n FIELD(ZPS00005) VAR(Toggle) VAL(4)\n FIELD(ZPS00006) VAR(Toggle) VAL(5)\n FIELD(ZPS00007) VAR(ACCEPT) VAL(1)\n)END\n)MEMBER A#OPTS LINES(23)\n/* Rexx function to return a line of executable rexx code given an\n*  option string.\n*  Usage: a#Opts(String)\n*  Returns 1 line of Rexx code which can be executed with interpret.\n*.\n*. 2005/08/12 Created by bsquare\n*/\nKeyWords = 'QUIET HIST NOARC NOSYNC DESC'\narg Opts\nOpts = Translate(Opts,,'00'x)    /* '00'x is used as a separator */\nret = ''\ndo Words(Opts)\n   parse VAR Opts o Opts\n   parse VAR o Name '(' Val ')'\n   if WordPos(Name,KeyWords) = 0 then iterate\n   if Val = '' then Val = 1\n   if Val = 'YES' then Val = 1\n   if Val = 'NO' then Val = 0\n   if Name = 'QUIET' & Val = 1 then\n      ret = ret||'Hist=0; NoArc=0; NoSync=0; Desc=0; '\n   else ret = ret||Name\"='\"Val\"'; \"\nend\nreturn ret\n)MEMBER A#REST LINES(76)\n/* Rexx program to restore the current edit session to a previous\n*  version.\n*  Usage: Install using #CONFIG.\n*  The macro will a#Make the correct version and copy it in.\n*.\n*. 2005/08/11 Created by bsquare\n*/\naddress ISREdit\n\"Macro (parm)\"\nif Parm = '' then Parm = -1\nRV = Translate(Parm)\nif DataType(RV,'N') then signal OK\nparse VAR RV c 2 RV\nif c = 'V' & DataType(RV,'N') & Pos('.',RV) > 0 then signal OK\n\nZEdLMsg = 'Usage: Restore \u00ddv\u00a8VV.MM'\nZEdSMsg = 'Bad version spec'\naddress ISPExec \"SetMsg Msg(ISRZ000)\"\nexit\n\nOK:\n   \"(Vol) = VOLUME\"\n   \"(DSN) = DATASET\"\n   \"(Mem) = MEMBER\"\n   \"(Changed) = DATA_CHANGED\"\n   VV = ''; LL = ''\n   \"(VV) = VERSION\"\n   \"(LL) = LEVEL\"\n   DiskVers = Right(VV,2,0)'.'Right(LL,2,0)\n   ArcKey = Vol':'DSN'('Mem')'\n   address ISPExec\n   \"TBGet archive\"\n   \"TBTop &ArcTbl\"\n   if RV < 0 then do\n      if DataType(RV,'W') = 0 then signal Err   /* not a whole number */\n      \"TBSkip &ArcTbl\"\n      if RC <> 0 then signal Err\n      RV = RV+1                      /* count skip to current version */\n      if DiskVers <> Vers then Changed = 'YES'\n      do (Changed = 'NO') - RV\n         \"TBSkip &ArcTbl\"\n         if RC <> 0 then signal Err\n      end\n      RV = Vers\n   end; else do\n      parse VAR RV VV '.' LL\n      RV = Right(VV,2,0)'.'Right(LL,2,0)\n      do until Vers = RV\n         \"TBSkip &ArcTbl\"\n         if RC <> 0 then signal Err\n      end\n   end\n   address ISREdit\n   Vers = 'VERSION('Vers') USER('User') MODIFIED('Mod')'\n   ViewDS = a#Make(ArcKey,Vers)\n   if ViewDS = '' then signal Err\n   \"X ALL\"\n   \"DEL ALL X\"\n   \"COPY\" ViewDS \"BEFORE .ZFIRST\"\n   parse VAR RV VV '.' LL\n   if VV = 0 then \"STATS OFF\"\n   else do\n      \"VERSION = (VV)\"\n      \"LEVEL   = (LL)\"\n   end\n   om = Msg('OFF')\n   address TSO \"Delete\" ViewDS\n   call Msg om\n   \"RESET\"\n   exit\n\nErr:\n   ZEdLMsg = 'The archive does not contain version' RV\n   ZEdSMsg = 'Not found'\n   address ISPExec \"SetMsg Msg(ISRZ000)\"\n   exit\n)MEMBER A#SAVE LINES(401)\n/* Rexx program to save a dataset\u00dd(member)\u00a8 from ISPF edit with\n*  version control.\n*  Usage: Install using #CONFIG.\n*  When you SAVE from ISPF edit, this will check to see if a control\n*  dataset exists.  See a#Init for a description.\n*  If this data set exists, a session comparison will be done and the\n*  changes stored in the archive dataset, along with history information\n*  obtained via an ISPF panel.\n*.\n*. 2005/06/23 Created by bsquare\n*. 2005/07/08 Decided not to allow sequential datasets.\n*. 2005/07/12 Rescinded the above decision.\n*. 2005/07/21 Changed format of archive datasets.\n*. 2005/08/17 Handle odd terminal types for LMMFind bug.\n*. 2006/01/13 Fix cancelled save of existing unarchived member. (v1.1)\n*/\naddress ISREdit\n\"Macro (parms)\"\n\n/* Get information about the dataset being edited (the target). */\n\"(DID)     = DATAID\"        /* Data ID for target dataset */\n\"(Vol)     = VOLUME\"\n\"(DSN)     = DATASET\"       /* Target dataset */\n\"(Mem)     = MEMBER\"        /*        member */\nArcKey = Vol':'DSN'('Mem')' /* Key for archive table */\nif Mem = '' then Target = DSN\nelse Target = DSN'('Mem')'\n\"(Changed) = DATA_CHANGED\"\n\"(State)   = USER_STATE\"\n\n/* Get information about the control dataset (the archive). */\naddress ISPExec\n\"TbGet archive\"             /* ArcDSN ArcTbl dl Desc1-6 */\n\"TbQuery\" ArcTbl \"ROWNUM(Versions)\"\naddress ISREdit\nIsArc = (Versions > 0)\n\nStats = GetStats(DID,Mem)\n/* Treat previously deleted member as \"Stats don't match\" */\nif Stats = 'NEW' & IsArc then Stats = ''\nif Stats = 'NEW' then do\n   if Changed = 'NO' then call Done 0   /* nothing to save or archive */\n   dl = GetDesc(Target)            /* Get a description for this data */\n   address ISPExec \"TbMod archive\" /* Save the description */\n\n   /* SAVE */\n   if Mem <> '' then \"STATS ON\"  /* Make sure STATS are ON */\n   \"BuiltIn SAVE\"\n   if RC > 4 then call Fail 'SAVE Failed RC' RC\n   if Mem <> '' then Stats = GetStats(DID,Mem)\n   else do\n      Mod = Translate('Year/Mm/Dd',Date('S'),'YearMmDd') Time()\n      Stats = 'Version('IncRev()') User('UserID()') Modified('Mod')'\n   end\n   sLines = (Stats <> '')          /* should ALWAYS be 1 */\n   if sLines = 0 then Vers = '00.00'\n   else do\n      parse UPPER VAR Stats,\n         'VERSION('Vers')' 1 'USER('User')' 1 'MODIFIED('Mod')'\n   end\n   address ISPExec \"TbTop\" ArcTbl\n   address ISPExec \"TbAdd\" ArcTbl\n\n   \"(Lines)   = LINENUM .ZLAST\"\n   Lines = Lines+0               /* reformat as number */\n   parse VALUE a#Open('OUT',ArcKey,'WRITE') WITH Archive VolInfo\n   /* Copy the member to the archive PDS if required. */\n   if ArcDSN <> DSN & Archive <> ArcDSN then do\n      Copy = \"'\"ArcDSN\"'\"\n      address ISPExec\n      \"LMInit DataID(ToID) DataSet(&Copy)\" VolInfo\n      \"LMCopy FromID(&DID) FromMem(&Mem) ToDataID(&ToID) REPLACE\"\n      \"LMFree DataID(&ToID)\"\n   end\n   address TSO\n   if Mem <> '' then\n      queue ')Current Header('sLines+dl') Member('Mem')'\n   else\n      queue ')Current Header('sLines+dl') Data('Lines')'\n   if sLines > 0 then queue '-Stats' Stats\n   do i=1 to dl\n      queue '-Desc' '('Value('DESC'i)')'\n   end\n   \"ExecIO\" 1+sLines+dl \"DiskW out\"\n\n   /* Put the data inline if required. */\n   if Archive = ArcDSN then do i=0 to Lines-1 by 100\n      do j=1 until j=min(100,Lines-i)\n         address ISREdit \"(Cur) = LINE\" i+j\n         Line.j = Strip(Cur,'T')  /* small savings for VB */\n      end\n      \"ExecIO\" j \"DiskW out (STEM Line.\"\n   end\n   \"ExecIO 0 DiskW out (FINIS\"\n   \"Free f(out)\"\n   address ISREdit\nend; else do\n   OldArc.0 = 0\n   ArcStats = ''; CompDS = ''\n   if IsArc then do\n      address ISPExec\n      \"TbTop\" ArcTbl\n      \"TbSkip\" ArcTbl\n      if Vers = '00.00' then Vers = ''\n      if Vers <> '' then ArcStats = 'Version('Vers')'\n      if User <> '' then ArcStats = ArcStats 'User('User')'\n      if Mod  <> '' then ArcStats = ArcStats 'Modified('Mod')'\n      if Mem = '' then Stats = ArcStats\n      /* no need to archive or save */\n      if Changed = 'NO' then call Done 0\n      if Stats = '' then dl = GetDesc(Target)\n      parse VALUE a#Open('IN',ArcKey,'READ') WITH Archive VolInfo\n      if Archive = '' then do   /* previously cancelled save. */\n         Header = 0; Data = ''\n         CompDS = 'SESSION'\n      end; else do\n         address TSO\n         \"ExecIO 1 DiskR in\"\n         pull 'HEADER('Header')' 1 'DATA('Data')'\n         if Header = '' then Header = 0\n         /* Obtain old data for deleted or munged members */\n         if Data <> '' then do\n            \"ExecIO\" Data \"DiskR in\" Header+2 \"(STEM Old.\"\n            if Old.0 = 0 then CompDS = 'NONE'\n            else do\n               CompDS = 'ARCHIVE.TEMP.S'Time('S')\n               \"Alloc f(tmp) dsn(\"CompDS\") NEW CATALOG DSORG(PS) LIKE('\"DSN\"')\"\n               \"ExecIO\" Data \"DiskW tmp (STEM Old. FINIS\"\n               \"Free f(tmp)\"\n            end\n         end\n         if Data <> '' then Header = Header+Data\n         /* Read archive, skipping )Current data */\n         \"ExecIO * DiskR in\" Header+2 \"(STEM OldArc. FINIS\"\n         \"Free f(in)\"\n      end\n      address ISREdit\n   end; else do\n      dl = GetDesc(Target)            /* get data description */\n      address ISPExec \"TbMod archive\" /* save the description */\n      parse UPPER VAR Stats,\n         'VERSION('Vers')' 1 'USER('User')' 1 'MODIFIED('Mod')'\n      parse VALUE '' WITH Hist1 Hist2 Hist3 Hist4 Hist5 Hist6\n      if Vers = '' then Vers = '00.00'\n      address ISPExec \"TbAdd\" ArcTbl  /* save the old version */\n      CompDS = 'SESSION'              /* no archive yet       */\n   end\n   if Changed = 'YES' then do\n      /* complete replacement or difference? */\n      if CompDS = 'NONE' then do\n         \"(Lines) = LINENUM .ZLAST\"\n         Lines = Lines+0               /* reformat as number */\n         if Lines > 0 then queue '-Del Count('Lines') Start(1)'\n      end; else do\n         /* Save the old compare options for later restoration */\n         address ISPExec \"VGet (ZEDUPDOP ZUPXSIZ)\"\n         OldOpts = ZEdUpdOp; OldXSize = ZUpXSiz\n         ZEdUpdOp = '0000000000'; ZUpXSiz = 0\n         address ISPExec \"VPut (ZEDUPDOP ZUPXSIZ) ASIS\"\n\n         /* Compare to the disk copy of this dataset */\n         if CompDS = '' then\n            if ArcDSN = DSN then CompDS = 'SESSION'\n            else CompDS = \"'\"ArcDSN\"(\"Mem\")'\"\n         \"BuiltIn Compare\" CompDS \"SAVE\"\n         RV = RC\n\n         /* restore old compare options */\n         ZEdUpdOp = OldOpts; ZUpXSiz = OldXSize\n         address ISPExec \"VPut (ZEDUPDOP ZUPXSIZ) ASIS\"\n         \"Reset LABEL SPECIAL\"\n\n         if RV <> 0 then do\n            if CompDS <> 'SESSION' & Pos('(',CompDS) = 0 then do\n               prev = Msg('OFF')\n               \"Delete\" CompDS\n               call Msg prev\n            end\n            call Fail 'Unexpected error from Compare, RC' RV\n         end\n         address TSO\n         \"Alloc f(in) dsn(ISPFEDIT.COMPARE.LIST) SHR REUSE\"\n         \"ExecIO * DiskR in (STEM Compare. FINIS\"\n         \"Free f(in)\"\n         prev = Msg('OFF')\n         \"Delete ISPFEDIT.COMPARE.LIST\"\n         call Msg prev\n\n         /* Process the comparison output */\n         if CompDS = 'SESSION' then\n            \"Alloc f(from) dsn('\"Target\"') SHR REUSE\"   /* disk copy */\n         else\n            \"Alloc f(from) dsn(\"CompDS\") SHR REUSE\"     /* disk copy */\n         mark = 122\n         do i=1 to Compare.0\n            if Left(Compare.i,2) = 'ID' then\n               mark = pos('TYPE',Compare.i)\n            if SubStr(Compare.i,3,1) <> '-' then iterate\n            parse VAR Compare.i,\n               Op 3 =(mark) Type +3 +1 Len +5 +1 nLine +5 +1 oLine +5\n            Len = Strip(Len)\n            /* reformat as number */\n            nLine = ('0'nLine)+0\n            oLine = ('0'oLine)+0\n            Len   = ('0'Len)+0\n            Select\n            When Len = 0 then say Compare.i  /* ERROR! */\n            When Type = 'INS' then do    /* From lines */\n               queue '-Ins Lines('Len') Start('nLine')'\n               \"ExecIO\" Len \"DiskR from\" nLine \"(STEM Temp.\"\n               do t=1 to Len; queue Strip(Temp.t,'T'); end\n               i = i + Len - 1\n               end\n            When Type = 'DEL' then do    /* To lines */\n               queue '-Del Count('Len') Start('oLine')'\n               i = i + Len - 1\n               end\n            When Type = 'RPL' | Type = 'RFM' then do\n               queue '-Ins Lines('Len') Start('nLine')'\n               \"ExecIO\" Len \"DiskR from\" nLine \"(STEM Temp.\"\n               do t=1 to Len; queue Strip(Temp.t,'T'); end\n               queue '-Del Count('Len') Start('oLine')'\n               i = i + (Len*2) - 1\n               end\n            Otherwise say Compare.i          /* ERROR! */\n            End\n         end\n         \"ExecIO 0 DiskR from (FINIS\"\n         \"Free f(from)\"\n         if CompDS <> 'SESSION' & Pos('(',CompDS) = 0 then do\n            prev = Msg('OFF')\n            \"Delete\" CompDS\n            call Msg prev\n         end\n      end\n      address ISREdit\n      Lines = Queued()\n      NewRev = IncRev(Vers)\n      hl = GetHist(Target,NewRev) /* get history entry */\n      do i=hl to 1 by -1\n         push '-Hist' '('Value('HIST'i)')'\n      end\n      if Stats = '' & ArcStats <> '' then Stats = ArcStats\n      if Stats <> '' then push '-Stats' Stats\n      push ')Archive Header('Queued()-Lines') Data('Lines')'\n\n      /* SAVE */\n      if Mem <> '' then \"STATS ON\"  /* Make sure STATS are ON */\n      \"BuiltIn SAVE\"\n      if RC > 4 then call Fail 'SAVE Failed RC' RC\n      if RC = 4 & ArcStats <> '' then do\n         \"VERSION =\" Left(NewRev,2)\n         \"LEVEL   =\" Right(NewRev,2)\n      end\n      if Mem <> '' then Stats = GetStats(DID,Mem)\n      else do\n         Mod = Translate('Year/Mm/Dd',Date('S'),'YearMmDd') Time()\n         Stats = 'Version('NewRev') User('UserID()') Modified('Mod')    '\n      end\n      parse UPPER VAR Stats,\n         'VERSION('Vers')' 1 'USER('User')' 1 'MODIFIED('Mod')'\n      address ISPExec \"TbTop\" ArcTbl\n      if Vers = '' then Vers = '00.00'\n      address ISPExec \"TbAdd\" ArcTbl\n   end\n   \"(Lines)   = LINENUM .ZLAST\"\n   Lines = Lines+0               /* reformat as number */\n   parse VALUE a#Open('OUT',ArcKey,'WRITE') WITH Archive VolInfo\n   /* Copy the member to the archive PDS if required. */\n   if ArcDSN <> DSN & Archive <> ArcDSN then do\n      address ISPExec\n      Copy = \"'\"ArcDSN\"'\"\n      \"LMInit DataID(ToID) DataSet(&Copy)\"VolInfo\n      \"LMCopy FromID(&DID) FromMem(&Mem) ToDataID(&ToID) REPLACE\"\n      \"LMFree DataID(&ToID)\"\n   end\n   address TSO\n   \"NEWSTACK\"\n      parse VAR Opts Default '00'x Global '00'x Local\n      if Stats <> '' then queue '-Stats' Stats\n      if Mem = '' then\n         do while Global <> ''\n            parse VAR Global cl '00'x Global\n            queue '-Opts' Strip(cl)\n         end\n      else\n         do while Local <> ''\n            parse VAR Local cl '00'x Local\n            queue '-Opts' Strip(cl)\n         end\n      do i=1 to dl\n         queue '-Desc' '('Value('DESC'i)')'\n      end\n      if Mem <> '' then\n         push ')Current Header('Queued()') Member('Mem')'\n      else\n         push ')Current Header('Queued()') Data('Lines')'\n      \"ExecIO\" Queued() \"DiskW out\"\n\n      /* Put the data inline if required. */\n      if Archive = ArcDSN then do i=0 to Lines-1 by 100\n         do j=1 until j=min(100,Lines-i)\n            address ISREdit \"(Cur) = LINE\" i+j\n            Line.j = Strip(Cur,'T')  /* small savings for VB */\n         end\n         \"ExecIO\" j \"DiskW out (STEM Line.\"\n      end\n   \"DELSTACK\"\n   if Queued() > 0 then \"ExecIO\" Queued() \"DiskW out\"\n   if OldArc.0 > 0 then\n      \"ExecIO\" OldArc.0 \"DiskW out (STEM OldArc.\"\n   \"ExecIO 0 DiskW out (FINIS\"\n   \"Free f(out)\"\nend\ncall Done 0\n\nDone:\n   arg ret\n   address TSO \"DelStack\"        /* eliminate old garbage */\n   address ISREdit \"USER_STATE = (State)\"\nexit ret\n\n/* Get statistics for a member. */\nGetStats: PROCEDURE\n   arg DataID,Member\n   if Member = '' then return '' /* no stats for sequential dataset */\n   address ISPExec\n   \"VGet (ZTerm)\"                /* deal with strange term types */\n   if ZTerm <> '3278' & ZTerm <> '3278A' then\n      \"Select Pgm(ISPTTDef) Parm(3278)\"\n   \"LMOpen DataID(\"DataID\")\"\n   \"LMMFind DataID(\"DataID\") Member(\"Member\") STATS(YES)\"\n   Exists = (RC = 0)           /* this member already exists. */\n   \"LMClose DataID(\"DataID\")\"\n   if ZTerm <> '3278' & ZTerm <> '3278A' then\n      \"Select Pgm(ISPTTDef) Parm(\"ZTerm\")\"\n   if Exists = 0 then return 'NEW'\n\n   parse VALUE '' WITH Vers User Mod\n   if ZLVers <> '' then Vers = 'Version('ZLVers'.'ZLMod')'\n   if ZLM4Date <> '' then\n      Mod  = 'Modified('ZLM4Date ZLMTime':'ZLMSec')'\n   if ZLUser <> '' then User = 'User('Strip(ZLUser)')'\n   return Vers User Mod\n\n/* Get a description of this data from the User. */\nGetDesc: PROCEDURE EXPOSE State Desc1 Desc2 Desc3 Desc4 Desc5 Desc6\n   arg DSN\n   address ISPExec\n   if Desc1 = '' then Desc1 = 'Original' DSN 'by' UserID()\n   \"Display Panel(a#DescP)\"\n   if RC = 8 then call Done 8\n   do i=6 to 1 by -1 until Value('DESC'i) <> ''; end\n   return i\n\n/* Get a description of these changes from the User. */\nGetHist: PROCEDURE EXPOSE State,\n   Hist1 Hist2 Hist3 Hist4 Hist5 Hist6,\n   Desc1 Desc2 Desc3 Desc4 Desc5 Desc6\n   arg DSN,Vers        /* Vers,Desc are displayed in ArcHist */\n   parse VALUE '' WITH Hist1 Hist2 Hist3 Hist4 Hist5 Hist6\n   address ISPExec\n   \"Display Panel(a#HistP)\"\n   if RC = 8 then call Done 8\n   do i=6 to 1 by -1 until Value('HIST'i) <> ''; end\n   return i\n\n/* Increment the revision (Version.Level). */\nIncRev: PROCEDURE\n   arg OldRev\n   address ISREdit\n   \"(Mem)   = MEMBER\"\n   if Mem = '' then NewRev = OldRev\n   else do\n      \"(Vers)  = VERSION\"       /* version and */\n      \"(Level) = LEVEL\"         /* modification level */\n      if RC <> 0 then NewRev = ''\n      else NewRev = Right(Vers,2,0)'.'Right(Level,2,0)\n   end\n   if OldRev <> '' then do\n      if OldRev < 1 then NewRev = 1\n      if NewRev = '' then NewRev = OldRev\n      if NewRev = OldRev then NewRev = NewRev + 0.01\n   end; else if NewRev = '' then NewRev = 1\n   parse VAR NewRev Vers '.' Level\n   Vers = Right(Vers,2,0)\n   Level = Right(Level,2,0)\n   if Mem <> '' then do\n      \"VERSION =\" Vers\n      \"LEVEL   =\" Level\n   end\n   return Vers'.'Level\n\n/* Fail with a message. */\nFail: PROCEDURE EXPOSE State\n   parse ARG ZEdLMsg\n   ZEdSMsg = \"Archive Failure\"\n   address ISPExec \"SetMsg Msg(ISRZ000)\"\n   address TSO \"DelStack\"          /* kill old garbage */\n   address ISREdit \"USER_STATE = (State)\"\n   exit 8\n)MEMBER A#TOUCH LINES(94)\n/* Rexx program to update the Last Known Working Member's ACCEPT time.\n*  Usage: a#Touch Archive \u00dd(member)\u00a8\n*  Archive is the PDS whose members should be updated.  TSO syntax is\n*  accepted for the Archive DSN.\n*  Archive can be specified as a DD statement, which should specify\n*  the DS name, not a specific member.\n*  If member is not supplied, a#Touch updates the time for ALL members\n*  of the selected PDS.  The () are required.\n*  This can be run in batch or interactively.\n*.\n*. 2005/08/31 Created by bsquare\n*/\nif arg(1) = '?' then signal ShowHelp\nLKWMTbl = 'Z{LKWM{'\ncTime = Translate('1234/56/78',Date('S'),'12345678') Time()\n\n/* Get ArcDSN and ArcVol */\narg DSN . '('Member')'\nif Member = '' then Member = '*'\nif DSN <> '' then Vol = ''\nelse do\n   if ListDSI('ARCHIVE FILE') > 4 then exit 20\n   Vol = SysVolume\n   DSN = \"'\"SysDSName\"'\"\n   if ListDSI(DSN) <= 4 & SysVolume = Vol then Vol = ''\n   else Vol = 'VOLUME('Vol')'\nend\nif Right(Strip(DSN,,\"'\"),4) <> '.ARC' then do\n   if Left(DSN,1) = \"'\" then\n      aDSN = \"'\"Strip(DSN,,\"'\")\".ARC'\"\n   else aDSN = DSN'.ARC'\n   om = Msg('OFF')\n   if ListDSI(aDSN Vol) <= 4 then DSN = aDSN\n   call Msg om\nend\n\n/* Get ArcDSN ArcVol */\naddress TSO \"Alloc f(arc) dsn(\"DSN\")\" Vol \"SHR REUSE\"\nLKWM = ''\naddress ISPExec\n\"TbOpen\" LKWMTbl \"Library(ARC)\"\nif RC <> 0 then say 'Could not open archive table'\nelse do until RC > 0\n   /* Use TbScan to scan the table for matches (allows * wildcard) */\n   Mem = Member\n   \"TbScan\" LKWMTbl \"ArgList(Mem)\"\n   if RC = 0 then do\n      Mod = cTime\n      \"TbPut\" LKWMTbl\n      say 'Set' Mem 'to' Mod\n   end\nend\n\"TbClose\" LKWMTbl \"Library(ARC)\"\n\"TbStats BADTABLE Library(BADLIB)\" /* workaround for ISPF bug */\naddress TSO \"Free f(arc)\"\nexit\n\n/* Show the Help text for the rexx exec (from the comments) */\nShowHelp:  /* Not a procedure.  Doesn't return. */\n   do i=1 for SourceLine() until s = '*/'\n      s = Strip(SourceLine(i))\n      if Left(s,2) = '* ' | Left(s,3) = '/* ' then queue SubStr(s,3)\n   end\n   call ViewQ\n   exit\n\n/* Display the data stack with ISPF View.\n*  Note: not a procedure.  This is so the passed-in stem can be EXPOSEd\n*  to the calling routine.\n*/\nViewQ: arg $Stem$; call $ViewQ$; return\n$ViewQ$: procedure EXPOSE ($Stem$)\n   /* Queue any stem variable output */\n   if $Stem$ \u00ac= '' then do l=1 to Value($Stem$||0)\n      queue Value($Stem$||l)\n   end\n\n   address TSO\n   'ISPQRY'\n   if (RC /= 0) then \"EXECIO\" Queued() \"DISKW SYSPRINT\"\n   else do\n      dd = 'VWQ' || Right(SysVar('SYSSRV'),5,0)\n      /* Allocate space for the output */\n      \"Alloc f(\"dd\") UNIT(VIO) LRECL(256) RECFM(V) DSORG(PS) NEW DELETE\"\n      \"EXECIO\" Queued() \"DISKW\" dd \"(FINIS\"\n      /* Use ISPF View to display the output */\n      address ISPExec\n      \"LMINIT DataID(temp) DDName(\"dd\")\"\n      \"VIEW   DataID(\"temp\") CONFIRM(NO) CHGWARN(NO) MACRO(NORECOV)\"\n      \"LMFREE DataID(\"temp\")\"\n      /* Free the space */\n      address TSO \"FREE f(\"dd\")\"\n   end\n   return\n)MEMBER A#VERSP LINES(26)\n)ATTR\n   $ TYPE(OUTPUT)  INTENS(LOW) CAPS(OFF)  COLOR(GREEN)\n   ! TYPE(OUTPUT)  INTENS(LOW) CAPS(OFF)  COLOR(RED)\n   _ TYPE(OUTPUT)  INTENS(LOW) CAPS(OFF)  COLOR(TURQ)\n   @ TYPE(INPUT)  INTENS(LOW) CAPS(ON)  COLOR(TURQ)\n)BODY EXPAND(\\\\)\n+CMD%=>@ZCMD                   \\ \\+SCROLL%=>@SCR +\n%\\ \\Available Versions\\ \\  +\n+ &Desc1\n+ &Desc2\n+ &Desc3\n+ &Desc4\n+ &Desc5\n+ &Desc6\n+Version Last Modified       User    +\n+------- ------------------- --------+\n)MODEL\n@Z!Vers _Mod                _User    +\n        $Hist1\\ \\+\n)INIT\n .ZVARS = 'SelCode'\n .AUTOSEL=YES\n)PROC\n &Row = .CSRROW\n if (&Row \u00ac= '00000000') .CSRROW = &Row\n)END\n)MEMBER A#VHIST LINES(68)\n/* Rexx edit macro to display archive history for the edited dataset.\n*  Usage: Install using #CONFIG.\n*.\n*. 2005/07/12 Created by bsquare\n*/\naddress ISREdit\n\"Macro\"                /* called as edit macro */\nif RC <> 0 then exit   /* called from dataset or member list */\n\"(Vol) = VOLUME\"\n\"(DSN) = DATASET\"\n\"(Mem) = MEMBER\"\nArcKey = Vol':'DSN'('Mem')'\naddress ISPExec\n\"TbGet archive\"\n\n\"TbTop &ArcTbl\"\n\"TbSkip &ArcTbl\"\nif RC <> 0 then do\n   if Mem = '' then\n      ZEdLMsg = 'No archive history exists for this dataset yet.'\n   else ZEdLMsg = 'No archive history exists for this member yet.'\n   ZEdSMsg = 'No history'\n   \"SetMsg Msg(ISRZ000)\"\n   exit\nend\nif Mem <> '' then DSN = DSN'('Mem')'\ndo forever\n   \"TbDispl &ArcTbl PANEL(a#VersP)\"\n   if RC > 0 then leave\n   if Row = 0 then iterate\n   \"TbTop &ArcTbl\"\n   \"TbSkip &ArcTbl NUMBER(&Row)\"\n   /* You can check the value of SelCode here */\n   Select\n   When SelCode = '' | SelCode = 'S' then \"Display Panel(a#DHistP)\"\n   When SelCode = 'V' then do\n      Stats = 'Version('Vers') User('User') Modified('Mod')'\n      Archive = a#Make(ArcKey,Stats)\n      if Archive <> '' then do\n         \"View Dataset(\"Archive\")\"\n         om = Msg('OFF')\n         address TSO \"Delete\" Archive\n         call Msg om\n      end\n      end\n   When SelCode = 'R' then do\n      Stats = 'Version('Vers') User('User') Modified('Mod')'\n      Archive = a#Make(ArcKey,Stats)\n      if Archive <> '' then do\n         address ISREdit\n         \"X ALL\"\n         \"DEL ALL X\"\n         \"COPY\" Archive \"BEFORE .ZFIRST\"\n         parse VAR Vers VV'.'LL\n         if VV <> '' then do\n            \"VERSION = (VV)\"\n            \"LEVEL   = (LL)\"\n         end\n         om = Msg('OFF')\n         address TSO \"Delete\" Archive\n         call Msg om\n         address ISPExec\n      end\n      end\n   Otherwise nop\n   End\n   SelCode = ' '\nend\n)MEMBER A#VIEW LINES(54)\n/* Rexx program to supplement the ISPF edit VIEW command, allowing\n*  the user to view previous versions of an archived dataset or member.\n*  Usage: Install using #CONFIG.\n*  The macro will just call the BUILTIN VIEW command unless the argument\n*  string is a valid version string.\n*.\n*. 2005/08/09 Created by bsquare\n*/\naddress ISREdit\n\"Macro (parm)\"\nRV = Translate(Parm)\nif DataType(RV,'N') then signal OK\nparse VAR RV c 2 RV\nif c = 'V' & DataType(RV,'N') & Pos('.',RV) > 0 then signal OK\n\"BUILTIN VIEW\" Parm\nexit RC\n\nOK:\n   \"(Vol) = VOLUME\"\n   \"(DSN) = DATASET\"\n   \"(Mem) = MEMBER\"\n   ArcKey = Vol':'DSN'('Mem')'\n   address ISPExec\n   \"TBGet archive\"\n   \"TBTop &ArcTbl\"\n   if RV < 0 then do\n      if DataType(RV,'W') = 0 then signal Err   /* not a whole number */\n      do 1-RV\n         \"TBSkip &ArcTbl\"\n         if RC <> 0 then signal Err\n      end\n      RV = Vers\n   end; else do\n      parse VAR RV VV '.' LL\n      RV = Right(VV,2,0)'.'Right(LL,2,0)\n      do until Vers = RV\n         \"TBSkip &ArcTbl\"\n         if RC <> 0 then signal Err\n      end\n   end\n   Vers = 'VERSION('Vers') USER('User') MODIFIED('Mod')'\n   ViewDS = a#Make(ArcKey,Vers)\n   if ViewDS = '' then signal Err\n   address ISPExec \"View Dataset(\"ViewDS\")\"\n   om = Msg('OFF')\n   address TSO \"Delete\" ViewDS\n   call Msg om\n   exit\n\nErr:\n   ZEdLMsg = 'The archive does not contain version' RV\n   ZEdSMsg = 'Not found'\n   address ISPExec \"SetMsg Msg(ISRZ000)\"\n   exit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TXT2PDS": {"ttr": 3338, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x03\\x01\\x06\\x08O\\x01\\x06\\x08_\\x04@\\x00\\x8b\\x00\\x8b\\x00\\x00\\xc8\\xf2\\xf2\\xf4@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2006-03-25T00:00:00", "modifydate": "2006-03-26T04:40:03", "lines": 139, "newlines": 139, "modlines": 0, "user": "H224"}, "text": "/* Rexx program to reconstitute or update a PDS from a flat text\n*  dataset by PDS2Txt.\n*  Usage: Txt2PDS dataset \u00ddpds\u00a8 \u00ddMOD\u00a8\n*  where  dataset is the name of the input dataset, and\n*         pds is the name of the output PDS to copy members to.\n*  If pds is not specified, it will be taken from the input dataset.\n*\n*. 2006/03/03 Renamed and worked on.\n*. 2006/02/24 Copied from PDS2Seq and modified.\n*/\nif arg(1) = '?' then signal ShowHelp\n\n/* parse the arguments */\nparse ARG DSN PDS Opt\nif DSN = '' then signal ShowHelp\nif Opt = '' & PDS = 'MOD' then parse VALUE 'MOD' WITH Opt,PDS\nif Opt <> 'MOD' & Opt <> '' then signal ShowHelp\n\n/* Check the input dataset. */\nGotIn = 0                 /* Set dataset states for Fail */\nRC = ListDSI(DSN)\nif RC > 4 then\n   call Fail RC,'Unable to access' DSN,SysMsgLvl2\nif Left(SysDSOrg,2) <> 'PS' then\n   call Fail 12,DSN 'is not sequential'\n\n/* Allocate the input dataset. */\n\"Alloc f(in) dsn(\"DSN\") SHR REUSE\"\nif RC <> 0 then\n   call Fail 12,'Unable to allocate' DSN 'for input.'\nGotIn = 1                 /* Got the input dataset (for Fail) */\n\nparse VAR PDS InPDS,Members,Attr,OutPDS\ndo forever\n   \"ExecIO 1 DiskR in (STEM Cntl\"\n   if RC <> 0 then leave\n   parse UPPER VAR Cntl1 c 2 Type Parms\n   Select\n   When c = '(' then do\n      do while Right(Strip(Line1),1) <> ')'\n         \"ExecIO 1 DiskR in (STEM Line\"\n      end\n      iterate\n      end\n   When Type = 'PDS' then do\n      parse VAR Parms InPDS . 'MEMBERS('Members')',Attr\n      say 'Reading PDS' InPDS '('Members 'members)'\n      if PDS <> '' then InPDS = PDS\n      end\n   When Type = 'ATTR' then Attr = Strip(Parms)\n   When Type = 'MEMBER' then do\n      if Members = '' then Members = 0\n      parse VAR Parms mName . 'LINES('Lines')'\n      if Lines = '' then call Fail 8,Cntl1,'Invalid )MEMBER card'\n      /* Set up the output dataset. */\n      if OutPDS <> InPDS then do\n         RC = ListDSI(InPDS)\n         if RC > 4 then do\n            \"Alloc f(pds) dsn(\"InPDS\") LIKE(\"DSN\")\" Attr,\n               \"DSORG(PO) NEW CATALOG\"\n            if RC <> 0 then call Fail 12,'Unable to allocate' InPDS\n            \"Free f(pds)\"\n            SysDSOrg = 'PO'\n         end\n         if Left(SysDSOrg,2) <> 'PO' then\n            call Fail 12,InPDS 'is not a PDS'\n         OutPDS = InPDS\n         say 'Reading Member' mName '('Lines 'lines)'\n      end; else if Members//10 = 0 then\n         say 'Reading Member' mName '('Lines 'lines)'\n      if Members > 0 then Members = Members-1\n      drop Line.\n      \"ExecIO\" Lines \"DiskR in (STEM Line.\"\n      sPDS = Strip(OutPDS,,\"'\")\n      if OutPDS = sPDS then q = ''\n      else q = \"'\"\n      Mem = q||sPDS'('mName')'||q\n      \"Alloc f(out) dsn(\"Mem\") SHR REUSE\"\n      if RC <> 0 then call Fail 12,'Unable to allocate' Mem\n      \"ExecIO\" Lines \"DiskW out (STEM Line. FINIS\"\n      trc = RC\n      \"Free f(out)\"\n      if trc <> 0 then call Fail 8,'Error writing' Mem 'RC='trc\n      end\n   Otherwise call Fail 8,'garbage in' DSN\n   End\nend\nexit\n\n/* Fail with an error message. */\nFail:\n   arg Code,Msg1,Msg2\n   if GotIn then do\n      address TSO\n      \"ExecIO 0 DiskR in (FINIS\"\n      \"Free f(in)\"\n   end\n   if Msg1 <> '' then say Msg1\n   if Msg2 <> '' then say Msg2\n   exit Code\n\n/* Show the Help text for the rexx exec (from the comments) */\nShowHelp:  /* Not a procedure.  Doesn't return. */\n   do i=1 for SourceLine() until s = '*/'\n      s = Strip(SourceLine(i))\n      if Left(s,2) = '* ' | Left(s,3) = '/* ' then queue SubStr(s,3)\n   end\n   call ViewQ\n   exit\n\n/* Display the data stack with ISPF View.\n*  Note: not a procedure.  This is so the passed-in stem can be EXPOSEd\n*  to the calling routine.\n*/\nViewQ: arg $Stem$; call $ViewQ$; return\n$ViewQ$: procedure EXPOSE ($Stem$)\n   /* Queue any stem variable output */\n   if $Stem$ \u00ac= '' then do l=1 to Value($Stem$||0)\n      queue Value($Stem$||l)\n   end\n\n   address TSO\n   'ISPQRY'\n   if (RC /= 0) then \"EXECIO\" Queued() \"DISKW SYSPRINT\"\n   else do\n      CmdName = sysvar('SYSICMD')\n      dd = 'VWQ' || Right(SysVar('SYSSRV'),5,0)\n      /* Allocate space for the output */\n      \"Alloc f(\"dd\") UNIT(VIO) LRECL(256) RECFM(V) DSORG(PS) NEW DELETE\",\n         \"dsn(TEMP.\"dd\".\"CmdName\")\"\n      \"EXECIO\" Queued() \"DISKW\" dd \"(FINIS\"\n      /* Use ISPF View to display the output */\n      address ISPExec\n      \"LMINIT DataID(temp) DDName(\"dd\")\"\n      \"VIEW   DataID(\"temp\") CONFIRM(NO) CHGWARN(NO) MACRO(NORECOV)\"\n      \"LMFREE DataID(\"temp\")\"\n      /* Free the space */\n      address TSO \"FREE f(\"dd\")\"\n   end\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT742/FILE742.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT742", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}