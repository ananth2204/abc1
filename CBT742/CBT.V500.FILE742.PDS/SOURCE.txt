)PDS CBT.ARCHIVE.V101.SOURCE MEMBERS(25)
)ATTR RECFM(F,B) LRECL(80) SPACE(1,1) DIR(5) CYLINDER
)MEMBER #CONFIG LINES(5)
/* ISPF Configuration entries.                                        */
/*   Include these entries in your own configuration member.          */
/*   Create the ISPCFIGU load module using TSO ISPCCONF.              */
MEMBER_LIST_LINE_COMMAND_COMMAND_EXIT       = A#CMDCK
SITE_WIDE_INITIAL_MACRO                     = A#INIT
)MEMBER #DESC LINES(69)
Archive program description:
The purpose of the archive application is to facilitate maintaining
previous versions of edited source PDS members (and sequential
datasets) 'transparently'.  It is intended for source (text) datasets
and PDSs only, and handles only ISPF edit as a means of altering
datasets and members.

Its benefits are:
Uses ISPF edit to update source data - no new editing to learn, new
features accrue with ISPF.
Archive creation, deletion, and backup are simple and efficient using
standard OS/390 utilities.
It is possible to archive any source dataset  that we control update of
- e.g. SYS1.PARMLIB.
Both source and control datasets are standard datasets or PDSs - they
can be SMS managed, archived, etc.
An archive control PDS can constitute a complete PDS backup - recovery
of the source PDS can be as simple as copying the archive control PDS
into it.
It can also maintain a 'Last Known Working Member' - a backup of a
member as of its last known 'good' version.  This is useful for datasets
like SYS1.IPLPARM and SYS1.PARMLIB, where the system may be unavailable
to restore a member to a previous version, but an alternate member can
be specified for the IPL.
We own the source code - alterations and improvements are at our
discretion.

Its detriments are:
It is neither bulletproof nor foolproof - Use of utilities other than
ISPF edit to alter source or control dataset contents will affect the
integrity of the archive.  The source may or may not be recoverable.
It acts to facilitate a source control convention, it does not enforce
it.  Archives can be intentionally bypassed or altered to affect (or
effect) an apparent history which is bogus.  In order for archiving to
work, anyone having update access to a source dataset must also have
update access to the archive control dataset.

Additional available commands while editing an archived source:
COMPARE vers     - compare the currently edited source to a previous
                   version
HISTORY          - display a table of all of the available versions of
                   this source
                 - from the table, you can display the history entry
                   or view a specific version
OPTIONS | OPTS   - set Dataset or Member options for an archive
RESTORE vers     - restore the currently edited source to a previous
                   version
VIEW vers        - view a previous version of the edited source

where vers = {Ýv¨VV.MM} or {-N}
      VV and MM can be 1 or 2 digits that specify the absolute
      version.  N is a non-zero whole number that specifies how
      many versions to go back (e.g. -1 is the previous version).
      Thus, if the archive consists of versions 01.03,01.12,02.05,02.06
      where 2.06 is the currently edited version,
      COMPARE -2 will compare the current version with v01.12 and
      RESTORE v1.3 will restore the member to v01.03.

Future features that should be implemented:
The external data editing commands CREATE, MOVE and REPLACE commands
should be DEFINEd to allow checking for creating, deleting or
overwriting archives regardless of whether they are used in an archived
dataset or not.
The BuiltIn, Define, Stats, Version and Level commands should be DEFINEd
to deny inappropriate usage.
An option should be provided to drop versions of edited data more than a
certain age or number of versions.
A utility should be provided to allow the user to change the data
description, and perhaps to set/change an archive description.
)MEMBER #DETAIL LINES(107)
NOTE: If you are modifying the code, you should be aware of some Rexx
      tricks I use.  See the TRICKS section of this member for more
      details.

Implementation details:
The archive application consists of 2 ISPF configuration options and a
PDS of rexx execs and ISPF panels.
The ISPF configuration options are:
MEMBER_LIST_LINE_COMMAND_COMMAND_EXIT       = A#CMDCK
SITE_WIDE_INITIAL_MACRO                     = A#INIT
These options are in source PDS member #CONFIG.

The a#CmdCk, a#Init and a#Open rexx programs MUST exist in a PDS that
is in every TSO user's SYSPROC or SYSEXEC concatenation.  The other
archive application rexx execs and ISPF panels can either be in the same
PDS or in another PDS that will be dynamically allocated during edit
sessions.
If the a#CmdCk exec cannot be found, you will not be able to use ISPF
single character line commands on any member lists.  Archiving will
still be in effect for edit sessions.
If the a#Init edit macro cannot be found, you will get an error every
time you enter ISPF edit or view.
a#Open is used by both a#CmdCk and a#Init and will cause problems with
archives if it cannot be found.

These are the rexx execs that currently make up the archive
application:
a#Can   - Terminate ISPF Edit sessions - undo a#Init
a#CmdCk - Validate ISPF member list single character built-in commands.
          Alter rename and delete requests to maintain archive integrity.
a#Cmp   - Allow COMPARE against previous versions of the data
a#End   - Call a#Save if required and terminate ISPF Edit sessions like
          CANCEL
a#Init  - Initialize ISPF Edit sessions:
          Allocate rexx and panel libraries, if necessary
          Define SAVE, END and CANCEL, COMPARE and VIEW as macros (not
          built-in)
          Create or open and initialize tables used in the application
a#Make  - Used internally to create a 'temporary' dataset with a
          previous version of the data
a#Open  - Used internally to resolve and open the archive control
          dataset for a member
a#Opt   - Set the options for a dataset or member
a#Opts  - Used internally to parse options strings.
a#Rest  - Restore a previous version (an alias of Restore is provided by
          a#Init).
a#Save  - Save the currently edited data, maintaining archived versions.
a#Touch - Exec to be used in foreground or batch to set the date and
          time that a member was last known to be working correctly.
a#VHist - Display version history (an alias of History is provided by
          a#Init).
          Allow a user to view a previous version of the edited data.
a#View  - View a previous version of the edited data

These are the ISPF panels that are part of the archive application:
a#DescP - Data entry panel to create or modify the dataset (member)
          description.
a#DHistP- Display panel to show a specific version's history (change)
          information.
a#HistP - Data entry panel to create or modify a version's history
          (change description).
a#OptDP - Data entry panel to modify the dataset options.
a#OptMP - Data entry panel to modify the member options.
a#VersP - Table display panel to show or select dataset (member)
          versions.

In addition, #TouchJb is JCL that can be used to run a#Touch in batch.

TRICKS:
   Initializing variables
      To set multiple variables in one statement, I use
      parse VALUE a b c... WITH Var1 Var2 Var3 ...
      If I am setting all the variables to '', I use
      parse VALUE WITH VarX,VarY,VarZ ...
      If I want to set SOME variables to values, and others to '', I use
      parse VALUE expression WITH VarA VarB,EmptyA,EmptyB
      I might also use parse VAR a VarA VarB,Empty1,Empty2...
      Anything after the 1st comma gets a null ('') value.
      NOTE that this is NOT the case for parse ARG.
      I might occasionally parse the output of a function
      parse VALUE FuncA(parm1,parm2) WITH RC Var1...
   Formatting
      To format an expression, I use
      new = Translate(OutputFormat,old,InputFormat)
      like this: nDate = Translate('1234/56/78',Date('S'),'12345678')
      which would set nDate to '2005/09/15'
      if Date('S') returns '20050915'.
      The characters in the InputFormat MUST be unique.
      Read the TSO-E Rexx Reference manual Built-in Functions/Translate
      description for more information.
   ISPF and ISPF edit
      I use both the ISPF &variable notation and the ISPF Edit
      (variable) notation to reference the value of a variable.
      So  "LMClose DataID(&DataID)" is the same as
          "LMClose DataID("DataID")"
      and "LINE_AFTER" i-1 "= (Cur)" is like
          "LINE_AFTER" i-1 "= '"Cur"'"
      In the LINE_AFTER case, (Cur) will work properly even
      if Cur contains the character '.
   Value()
      The statement
      call Value oType,Value(oType) v||'('Val')'
      is equivalent to
      interpret oType '=' oType "v||'('Val')'"
      Thus, if oType is 'MEMBER', v is 'Hist' and Val is 'no', then
      the expression evaluates to:
      MEMBER = MEMBER 'Hist'||'(no)'
)MEMBER #INSTALL LINES(36)
In the install PDS:
The member #CONFIG contains definitions needed for ISPF customization.
Copy this member into your site ISPF customization PDS member (for us,
this is 'OS390.MAINT.CONFIG.R210(ISPFCFG)'.  You will use this to build
an ISPF configuration module.

From an ISPF command line, type 'TSO ISPCCONF'.
   This will bring up the ISPF Configuration Utility.
Put your configuration dataset and member in the Keyword File Data Set
section.
Select option 3, Verify Keyword Table Contents.
   You should get the message 'Keyword file verified' in the upper right.
Select option 4, Build Configuration Table Load Module.
   Verify that the 'Input Keyword File Data set' is the same as used
   above, and select an Output Configuration Table Load Module Data Set.
   I would suggest putting this in a dataset that is NOT in the
   LPA/Link/Joblib/Steplib/ISPLLib search sequence for now.
Press Enter to generate the load module.
   It will be named ISPCFIGU.

Alter your logon PROC/CList/Exec to allocate the install PDS to SYSEXEC
and ISPPLIB.
Now either alter the above to allocate your ISPF configuration module
dataset to ISPLLIB, or copy ISPCFIGU from your configuration module
dataset to a library in the search concatenation.
For example - to add this to MCIT's #SYSTSO5 proc, you would edit
SYS2.TSO5.ISRPRIM.R210(ISPFTSO) to add H224.ARCHIVE.SOURCE to SYSEXEC
and ISPPLIB.  If you put the ISPCFIGU module into H224.ARCHIVE.LOAD, you
would add that to ISPLLIB in the same dataset.
If you added ISPCFIGU to the Link list, you will need to refresh it.

You should now be able to log on to your TSO proc, and use Archive.
NOTE:  Every TSO user that will get the ISPCFIGU module you created MUST
have the ARCHIVE.SOURCE PDS in their SYSEXEC and ISPPLIB concatenations.
Otherwise they will get failures using ISPF member list line commands
and ISPF edit/view.
)MEMBER #TOUCHJB LINES(24)
//TOUCHJOB JOB 0200,'archive',MSGCLASS=X,CLASS=X,NOTIFY=&SYSUID
//*
//* Touch the members of an archive.
// SET SOURCE=SYS1.PARMLIB
// SET LIB=H224.ARCHIVE.SOURCE
//*
//* Create a new profile for the following step
//NEWPROF  EXEC IEFBR14
//ISPPROF  DD DISP=(NEW,PASS),DSN=&&PROFILE,UNIT=SYSDA,
//         SPACE=(CYL,(1,1,1)),LRECL=80,BLKSIZE=27920
//*
//* Touch
//TOUCH    EXEC PGM=IKJEFT01,PARM='ISPSTART CMD(%A#TOUCH)'
//SYSEXEC  DD DISP=SHR,DSN=&LIB
//ISPPROF  DD DISP=(SHR,PASS),DSN=&&PROFILE
//ISPTLIB  DD DISP=SHR,DSN=ISP.SISPTENU
//ISPTABL  DD DISP=(SHR,PASS),DSN=&&PROFILE,VOL=REF=*.ISPPROF
//ISPLOG   DD SYSOUT=*,LRECL=125,BLKSIZE=129,RECFM=VB
//ISPPLIB  DD DISP=SHR,DSN=ISP.SISPPENU
//ISPMLIB  DD DISP=SHR,DSN=ISP.SISPMENU
//ISPSLIB  DD DISP=SHR,DSN=ISP.SISPSENU
//SYSTSIN  DD DUMMY
//SYSTSPRT DD SYSOUT=*
//ARCHIVE  DD DISP=SHR,DSN=&SOURCE
)MEMBER A#CAN LINES(19)
/* Rexx program to end an edit session, archiving as necessary.
*  Usage: Install using #CONFIG.
*  This will close the tables opened by a#Init.
*.
*. 2005/07/12 Created by bsquare
*/
address ISREdit
"Macro"
"(Vol) = VOLUME"
"(DSN) = DATASET"
"(Mem) = MEMBER"
ArcKey = Vol':'DSN'('Mem')'
address ISPExec
"TBGet archive"
"TBEnd" ArcTbl
"TBClose archive"
/* "LIBDEF ISPPLIB" */
/* address TSO "AltLib DEACTIVATE APPLICATION(EXEC)" */
address ISREdit "BuiltIn CANCEL"
)MEMBER A#CMDCK LINES(258)
/* Rexx ISPF exit */
/* exit 0 uses ISPF processing.  exit 8 skips ISPF processing. */
arg Cmd . "'" DSN '(' Mem ')' . VolSer Tail
if Pos(Cmd,'DR') = 0 then exit 0
if Right(Mem,1) = '{' then exit 0
if Right(DSN,4) = '.ARC' then exit 0
DT = Date('D')*86400+Time('S')
address ISPExec
"VGet (MCMDDSN) SHARED"
if RC = 0 then do
   if Word(MCMDDSN,1) = VolSer':'DSN then do
      oDT = Word(MCMDDSN,2)
      if DT = oDT then exit 0
      else if (DT - oDT) <= 10 then do
         MCMDDSN = oDSN DT
         "VPut (MCMDDSN) SHARED"
         exit 0
      end
   end
end
IsCat = ListDSI("'"DSN"'") = 0
if IsCat then IsCat = (SysVolume = VolSer)
if IsCat then Vol = ''
else Vol = ' VOLUME('VolSer')'
SysDSOrg = 'BAD'
ArcDSN = DSN'.ARC'
if Length(ArcDSN) <= 44 then call ListDSI "'"ArcDSN"'"||Vol
if Left(SysDSOrg,2) <> 'PO' then ArcDSN = DSN
ArcMem = Strip(Left(Mem,7))'{'

"VGet (ZTERM)"
if ZTerm <> '3278' & ZTerm <> '3278A' then
   "Select Pgm(ISPTTDef) Parm(3278)"
"LMInit DataID(DID) DataSet('"ArcDSN"')"Vol "ENQ(SHRW)"
"LMOpen DataID(&DID)"
"LMMFind DataID(&DID) Member(Z{PARMS{)"
zParms = (RC = 0)
if ArcDSN = DSN & zParms = 0 then do           /* No archive dataset */
   MCMDDSN = VolSer':'DSN DT
   "VPut (MCMDDSN) SHARED"
   signal Quit
end
ArcCopy = 0
if ArcDSN <> DSN then do
   "LMMFind DataID(&DID) Member(&Mem)"
   ArcCopy = (RC = 0)
end
"LMMFind DataID(&DID) Member(&ArcMem)"
if RC = 0 then
  "LMGet DataID(&DID) Mode(INVAR) MaxLen(80) DataLoc(Data) DataLen(Len)"
if RC <> 0 then IsArc = 0
else do
   parse UPPER VAR Data 2 Type Info
   if Type = 'CURRENT' then do
      parse VAR Info 'MEMBER('aMem')'
      if aMem = Mem then IsArc = 1
      else do
         IsArc = 0
         ArcMem = ''
      end
   end; else do
      parse VAR Info 'ID('ConID')'
      ArcMem = 'Z{'Right(ConID,4,0)||SubStr(Mem,8)||'{'
      "LMMFind DataID(&DID) Member(&ArcMem)"
      IsArc = (RC = 0)
   end
end
if Left(Tail,1) = '*' then Tail = ''
Select
When Cmd = 'R' then do
   if IsArc = 0 & ArcCopy = 0 then signal Quit
   if Tail <> '' then parse VAR Tail UDARen .
   else do
      address ISPExec
      UDMSMem = Mem
      "AddPop"
      "Display Panel(ISRUREN)"
      RV = RC
      "RemPop"
      if RV <> 0 then signal Done
   end
   /* If not archived, do this the simple way */
   if IsArc = 0 then do
      "LMClose DataID(&DID)"
      "LMOpen DataID(&DID) Option(OUTPUT)"
      "LMMRen DataID(&DID) Member(&Mem) NewName(&UDARen)"
      "LMClose DataID(&DID)"
      "LMFree DataID(&DID)"
      "LMInit DataID(DID) DataSet('"DSN"')"Vol "Enq(SHRW)"
      "LMOpen DataID(&DID) Option(OUTPUT)"
      "LMMRen DataID(&DID) Member(&Mem) NewName(&UDARen)"
      signal Done
   end
   address TSO
   "Alloc f(in) dsn('"ArcDSN"("ArcMem")')"Vol "SHR REUSE"
   "ExecIO * DiskR in (STEM Arc. FINIS"
   "Free f(in)"
   ms = 'MEMBER('                /* string to look for */
   lp = Pos(ms,Translate(Arc.1))
   if lp <> 0 then ms = SubStr(Arc.1,lp,Length(ms))
   parse VAR Arc.1 Left (ms) . ')' Right
   Arc.1 = Strip(Left,'T') 'Member('UDARen')'||Right
   NewArc = Strip(Left(UDARen,7))'{'
   address ISPExec
   /* Check for contention */
   if NewArc = ArcMem then RC = 4           /* contention with self */
   else "LMMFind DataID(&DID) Member(&NewArc)"
   if RC = 0 then do
      "LMGet DataID(&DID) Mode(INVAR) MaxLen(80) DataLoc(Data) DataLen(Len)"
      parse UPPER VAR Data 2 Type Info
      if Type = 'RESOLVE' then parse VAR Info 'ID('ConID')'
      else do
         "LMClose DataID(&DID)"
         address TSO
         parse VAR Info 'MEMBER('OldMem')'
         Parms. = 0
         ConID = ''
         if zParms then do
            "Alloc f(in) dsn('"ArcDSN"(Z{PARMS{)')"Vol "SHR REUSE"
            "ExecIO * DiskR in (STEM Parms. FINIS"
            "Free f(in)"
            do i=1 to Parms.0
               parse UPPER VAR Parms.i 2 Type Info
               if Type <> 'RESOLVE' then iterate
               pl = i
               parse UPPER VAR Parms.i . 'ID('ConID')'
            end
         end
         if ConID <> '' then ConID = Right(ConID+1,4,0)
         else do
            ConID = '0000'
            pl = Parms.0+1; Parms.0 = pl
         end
         Parms.pl = ')Resolve ID('ConID')'
         "Alloc f(out) dsn('"ArcDSN"(Z{PARMS{)')"Vol "SHR REUSE"
         "ExecIO" Parms.0 "DiskW out (STEM Parms. FINIS"
         "Free f(out)"
         OldArc = 'Z{'ConID||SubStr(OldMem,8)||'{'
         address ISPExec
         "LMOpen DataID(&DID) Option(OUTPUT)"
         "LMMRen DataID(&DID) Member(&NewArc) NewName(&OldArc)"
         Data = Parms.pl
         "LMPut DataID(&DID) Mode(INVAR) DataLoc(Data) DataLen(80)"
         "LMMAdd DataID(&DID) Member(&NewArc) Stats(NO)"
      end
      ConID = Right(ConID,4,0)
      NewArc = 'Z{'ConID||SubStr(UDARen,8)||'{'
   end
   "LMClose DataID(&DID)"
   address TSO
   "Alloc f(out) dsn('"ArcDSN"("NewArc")')"Vol "SHR REUSE"
   "ExecIO * DiskW out (STEM Arc. FINIS"
   "Free f(out)"
   address ISPExec
   "LMOpen DataID(&DID) Option(OUTPUT)"
   if NewArc <> ArcMem then
      "LMMDel DataID(&DID) Member(&ArcMem)"
   if ArcCopy then
      "LMMRen DataID(&DID) Member(&Mem) NewName(&UDARen)"
   "LMClose DataID(&DID)"
   "LMFree DataID(&DID)"
   "LMInit DataID(DID) DataSet('"DSN"')"Vol "Enq(SHRW)"
   "LMOpen DataID(&DID) Option(OUTPUT)"
   "LMMRen DataID(&DID) Member(&Mem) NewName(&UDARen)"
   end
When Cmd = 'D' then do
   "VGet (ZMemConf)"
   if ZMemConf <> 'OFF' then do
      ZCFDSN = DSN
      ZCFMEM = Mem
      "AddPop"
      "Display Panel(ISRUDELC)"
      RV = RC
      "RemPop"
      if RV <> 0 then signal Done
   end
   "LMClose DataID(&DID)"
   "LMFree DataID(&DID)"
   address TSO
   if IsArc then do
      "Alloc f(in) dsn('"ArcDSN"("ArcMem")')"Vol "SHR REUSE"
      "ExecIO 1 DiskR in (STEM Head"
      parse UPPER VAR Head1 'HEADER('Header')' 1 'DATA('Data')'
      if Header = '' then Header = 0
   end; else Data = ''
   /* if the archive is already wrapped then ignore the new junk */
   if Data <> '' then do
      "ExecIO 0 DiskR in (FINIS"
      "Free f(in)"
   end; else do
      /* Wrap the data into the archive */
      if IsArc = 0 then do
         Header = 0
         address ISPExec
         "LMInit DataID(DID) DataSet('"DSN"')"Vol "Enq(SHRW)"
         "LMOpen DataID(&DID)"
         "LMMFind DataID(&DID) Member(&Mem) STATS(YES)"
         "LMClose DataID(&DID)"
         "LMFree DataID(&DID)"
         if ZLVers <> '' then do
            Stats = 'Version('ZLVers'.'ZLMod')',
                    'User('ZLUser')',
                    'Modified('ZLM4Date ZLMTime':'ZLMSec')'
            Header = 1
            Header.1 = '-Stats' Stats
         end
         Header.0 = Header
         address TSO
      end; else do
         if Header = 0 then Header.0 = 0
         else "ExecIO" Header "DiskR in (STEM Header."
         "ExecIO * DiskR in (STEM Arc. FINIS"
         "Free f(in)"
      end
      "Alloc f(data) dsn('"DSN"("Mem")')"Vol "SHR REUSE"
      "ExecIO * DiskR data (STEM Data. FINIS"
      "Free f(data)"
      if a#Open('OUT',VolSer':'DSN'('Mem')','WRITE') <> '' then do
         push ')Current Header('Header+1') Data('Data.0') Member('Mem')'
         "ExecIO 1 DiskW out"
         "ExecIO * DiskW out (STEM Header."
         Mod = Translate('1234/56/78',Date('S'),'12345678') Time()
         push '-Hist (Deleted at' Mod 'by' UserID()')'
         "ExecIO 1 DiskW out"
         "ExecIO * DiskW out (STEM Data."
         "ExecIO * DiskW out (STEM Arc. FINIS"
         "Free f(out)"
      end
   end
   address ISPExec
   if ArcCopy then do
      "LMInit DataID(DID) DataSet('"ArcDSN"')"Vol "Enq(SHRW)"
      "LMOpen DataID(&DID) Option(OUTPUT)"
      "LMMDel DataID(&DID) Member(&Mem)"
      "LMClose DataID(&DID)"
      "LMFree DataID(&DID)"
   end
   "LMInit DataID(DID) DataSet('"DSN"')"Vol "Enq(SHRW)"
   "LMOpen DataID(&DID) Option(OUTPUT)"
   "LMMDel DataID(&DID) Member(&Mem)"
   end
Otherwise nop
End
/* All done */
Done:
"LMClose DataID(&DID)"
"LMFree DataID(&DID)"
if ZTerm <> '3278' & ZTerm <> '3278A' then
   "Select Pgm(ISPTTDef) Parm("ZTerm")"
exit 8

/* Let ISPF handle this one. */
Quit:
"LMClose DataID(&DID)"
"LMFree DataID(&DID)"
if ZTerm <> '3278' & ZTerm <> '3278A' then
   "Select Pgm(ISPTTDef) Parm("ZTerm")"
exit 0
)MEMBER A#CMP LINES(79)
/* Rexx program to supplement the ISPF edit COMPARE command, allowing
*  the user to compare against a previous versions of an archived
*  dataset or member.
*  Usage: Install using #CONFIG.
*  The macro will just call the BUILTIN COMPARE command unless the
*  argument string is a valid version string.
*.
*. 2005/08/09 Created by bsquare
*/
address ISREdit
"Macro (Parm)"
if Parm = '' then signal Settings         /* Stupid ISPF! */
parse VAR Parm RV Tail
upper RV
if DataType(RV,'N') then signal OK
parse VAR RV c 2 RV
if c = 'V' & DataType(RV,'N') & Pos('.',RV) > 0 then signal OK
"BuiltIn COMPARE" Parm
exit RC

OK:
   "(Vol) = VOLUME"
   "(DSN) = DATASET"
   "(Mem) = MEMBER"
   "(Changed) = DATA_CHANGED"
   ArcKey = Vol':'DSN'('Mem')'
   address ISPExec
   "TBGet archive"
   "TBTop &ArcTbl"
   if RV < 0 then do
      if DataType(RV,'W') = 0 then signal Err   /* not a whole number */
      do (Changed = 'NO') - RV
         "TBSkip &ArcTbl"
         if RC <> 0 then signal Err
      end
      RV = Vers
   end; else do
      parse VAR RV VV '.' LL
      RV = Right(VV,2,0)'.'Right(LL,2,0)
      do until Vers = RV
         "TBSkip &ArcTbl"
         if RC <> 0 then signal Err
      end
   end
   Vers = 'VERSION('Vers') USER('User') MODIFIED('Mod')'
   ViewDS = A#Make(ArcKey,Vers)
   if ViewDS = '' then signal Err
   address ISREdit "BUILTIN COMPARE" ViewDS Tail
   om = Msg('OFF')
   address TSO "Delete" ViewDS
   call Msg om
   exit

Err:
   ZEdLMsg = 'The archive does not contain version' RV
   ZEdSMsg = 'Not found'
   address ISPExec "SetMsg Msg(ISRZ000)"
   exit

Settings:
   address ISPExec
   "VGet (ZEdUpdOp ZUpXSiz ZUpdLab)"
   ZUpXSizT = ZUpXSiz
   ZUpdLabT = ZUpdLab
   parse VAR ZEdUpdOp RefMovr 2 AnyC 3 Mixed 4 DPPlCmt 5,
         DPPsCmt 6 DPAdCmt 7 DPACmt 8 DPFtCmt 9 DPCbCmt 10 DPBlkCl
   "AddPop"
   do until RC <> 0
      "Display Panel(ISREUPP)"
   end
   "RemPop"
   "VGet (ZVerb)"
   if ZVerb <> 'END' then exit
   ZEdUpdOp = RefMovr||AnyC||Mixed,
   || DPPlCmt||DPPsCmt||DPAdCmt||DPACmt||DPFtCmt||DPCbCmt||DPBlkCl
   ZUpXSiz = ZUpXSizT
   ZUpdLab = ZUpdLabT
   "VPut (ZEdUpdOp ZUpXSiz ZUpdLab) PROFILE"
   exit
)MEMBER A#DESCP LINES(18)
)ATTR
 _ TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(ASIS)
)BODY EXPAND(\\)
%&ZUSER---- MCIT Edit Archive Control \-\&ZDATE-&ZTIME--
%Option  ===>_ZCMD\ \+
+
%\ \Archive Description\ \+
+ Enter a description for%&DSN
+
+ Line 1:_Desc1                                                       +
+ Line 2:_Desc2                                                       +
+ Line 3:_Desc3                                                       +
+ Line 4:_Desc4                                                       +
+ Line 5:_Desc5                                                       +
+ Line 6:_Desc6                                                       +
+
+ Press%Enter+to accept or%PF3+to%CANCEL+the SAVE
)END
)MEMBER A#DHISTP LINES(27)
)ATTR
 _ TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(ASIS)
)BODY EXPAND(\\)
%&ZUSER---- MCIT Edit Archive Control \-\&ZDATE-&ZTIME--
%Option  ===>_ZCMD\ \+
+
%\ \Archive History\ \+
+
+ &Desc1
+ &Desc2
+ &Desc3
+ &Desc4
+ &Desc5
+ &Desc6
+
%&DSN v&Vers
+ Modified &Mod by &User
+
+ Line 1:%&Hist1
+ Line 2:%&Hist2
+ Line 3:%&Hist3
+ Line 4:%&Hist4
+ Line 5:%&Hist5
+ Line 6:%&Hist6
+
+\ \Press%Enter+or%PF3\ \+
)END
)MEMBER A#END LINES(28)
/* Rexx program to end an edit session, archiving as necessary.
*  Usage: Install using #CONFIG.
*  When you END in ISPF edit, this will call SAVE if AUTOSAVE is on.
*  SAVE is also modified in a#Init.
*  This exec also closes the tables opened by a#Init.
*.
*. 2005/07/08 Created by bsquare
*/
address ISREdit
"Macro"
"(Sess) = SESSION"
"(Changed) = DATA_CHANGED"  /* Changed? */
if Changed <> 'NO' then do
   "(AUTO) = AUTOSAVE"
   if AUTO = 'ON' then "SAVE"
   if RC > 4 then exit      /* User canceled out of SAVE */
end
"(Vol) = VOLUME"
"(DSN) = DATASET"
"(Mem) = MEMBER"
ArcKey = Vol':'DSN'('Mem')'
address ISPExec
"TBGet archive"
"TBEnd" ArcTbl
"TBClose archive"
/* "LIBDEF ISPPLIB" */
/* address TSO "AltLib DEACTIVATE APPLICATION(EXEC)" */
address ISREdit "BuiltIn END"
)MEMBER A#HISTP LINES(26)
)ATTR
 _ TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(ASIS)
)BODY EXPAND(\\)
%&ZUSER---- MCIT Edit Archive Control \-\&ZDATE-&ZTIME--
%Option  ===>_ZCMD\ \+
+
%\ \Archive History\ \+
+
+ &Desc1
+ &Desc2
+ &Desc3
+ &Desc4
+ &Desc5
+ &Desc6
+
+ Describe your changes to%&DSN v&Vers
+
+ Line 1:_Hist1                                                       +
+ Line 2:_Hist2                                                       +
+ Line 3:_Hist3                                                       +
+ Line 4:_Hist4                                                       +
+ Line 5:_Hist5                                                       +
+ Line 6:_Hist6                                                       +
+
+ Press%Enter+to accept or%PF3+to%CANCEL+the SAVE
)END
)MEMBER A#INIT LINES(299)
/* Rexx program.  Initialize the archive macros that replace ISPF edit
*  commands - END, CANCEL, SAVE, VIEW, COMPARE (add HISTORY).
*  Usage: Install using #CONFIG.
*  Archiving is done in one of 3 ways:
*  1.  Seq dataset, seq archive named dataset.ARC
*  2.  PDS dataset, PDS archive named dataset.ARC
*  3.  PDS dataset with a PDS member named Z{PARMS{
*
*  In any case, the archive must have a LRecL >= 80 (84 if V).
*  The archive LRecL must also be >= the LRecL of the dataset (if the
*  dataset is RecFM F or FB and the archive is V or VB, the LRecL of
*  the archive must be at least 4 more than the dataset.
*  NOTE: In order to use the LKWM feature, the archive MUST have
*        RecFM FB, LRecL 80.
*.
*. 2005/07/08 Created by BSquare
*. 2005/07/12 Allow sequential archives, add CANCEL.
*.            Moved the macros to a seperate library.
*. 2005/07/15 Use INFOLINE for description in member.
*. 2005/07/21 Change format of archives.
*. 2005/07/28 Change format of archives (again).
*. 2005/08/03 Change INFOLINE to NOTELINE, use INFOLINE for WARNINGS.
*. 2005/08/05 Use external a#Open instead of internal Resolve.
*. 2005/08/12 Added Default, Global and Local options.
*. 2005/08/30 Add Last Known Working Member copy.
*. 2005/09/06 Fix LKWM for sequential datasets (i.e. remove).
*. 2005/09/07 Only allow FB80 for LKWM.
*/
address ISREdit
"Macro"

"(Sess) = SESSION"
/* Archive can not be used in EDIF or VIIF */
if WordPos(Sess,'EDIT VIEW') = 0 then exit

/* Check the dataset being edited (the target). */
"(DID) = DATAID"
"(Vol) = VOLUME"
"(Mem) = MEMBER"
"(DSN) = DATASET"
if Right(DSN,4) = '.ARC' then exit    /* Can't archive an archive */
ArcKey = Vol':'DSN'('Mem')'           /* Key for archive table */
"(LRecL)   = LRECL"
"(RecFm)   = RECFM"
if RecFm = 'V' then LRecL = LRecL+4

/* Check the control dataset (the archive). */
zParms = 0
if ListDSI("'"DSN"'") = 0 & Vol = SysVolume then ArcVol = ''
else ArcVol = 'VOLUME('Vol')'         /* accessed by volume */
ArcDSN = DSN'.ARC'
ArcLen = Length(ArcDSN)
LKWMTbl = ''                          /* ISPF table for LKWM */
if Mem = '' then do                       /* sequential dataset */
   if ArcLen > 44 then exit     /* can't archive, name too long */
   /* Archive doesn't exist */
   if ListDSI("'"ArcDSN"'" ArcVol) <> 0 then exit
   if Left(SysDSOrg,2) <> 'PS' then exit  /* archive must be seq */
end; else do                              /* PDS dataset */
   if Right(Mem,1) = '{' then exit        /* Can't archive these. */
   if ArcLen > 44 | ListDSI("'"ArcDSN"'" ArcVol) <> 0 then do
      address ISPExec
      "VGet (ZTerm)"                /* deal with strange term types */
      if ZTerm <> '3278' & ZTerm <> '3278A' then
         "Select Pgm(ISPTTDef) Parm(3278)"
      "LMOpen DataID(&DID)"
      "LMMFind DataID(&DID) Member(Z{PARMS{)"
      zParms = (RC = 0)
      "LMClose DataID(&DID)"
      if ZTerm <> '3278' & ZTerm <> '3278A' then
         "Select Pgm(ISPTTDef) Parm("ZTerm")"
      if zParms = 0 then exit
      ArcDSN = DSN                        /* self-archived */
      call ListDSI "'"DSN"' Volume("Vol")"
      address
   end
   if Left(SysDSOrg,2) <> 'PO' then exit  /* archive must be PDS */
   if Left(SysRecFM,2) = 'FB' & SysLRecL = 80 then LKWMTbl = 'Z{LKWM{'
end

/* Make sure LRecL is long enough */
if SysLRecL < 80 | SysLRecL < LRecL then exit

/* O.K. - set up for archiving */
Opts = 'Hist(5) NoArc NoSync Desc'        /* Defaults */
parse VALUE 5 1 1 1 0 WITH Hist NoArc NoSync Desc Quiet

/*
Src = "H224.ARCHIVE.SOURCE"
address TSO,
   "AltLib ACTIVATE APPLICATION (EXEC) DATASET('"Src"') UNCOND"
if RC <> 0 then exit */               /* No archive source library! */

/* These definitions add archive processing to ISPF commands. */
if Sess = 'VIEW' then
   "Define END     ALIAS A#CAN"
else do
   "Define END     ALIAS A#END"
   "Define SAVE    ALIAS A#SAVE"
end
"Define CANCEL  ALIAS A#CAN"
"Define COMPARE ALIAS A#CMP"
"Define HISTORY ALIAS A#VHIST"
"Define OPTS    ALIAS A#OPT"
"Define OPTIONS ALIAS A#OPT"
"Define RESTORE ALIAS A#REST"
"Define VIEW    ALIAS A#VIEW"

address ISPExec
/* "LIBDEF ISPPLIB DATASET ID('"Src"') STACK" */
"TbCreate archive NOWRITE SHARE KEYS(ArcKey)",
   "Names(ArcDSN ArcTbl ArcVol LKWMTbl Opts",
         "DL Desc1 Desc2 Desc3 Desc4 Desc5 Desc6)"
if RC = 8 then "TbOpen archive NOWRITE SHARE"

do i=1 to 20 until RC = 0
   ArcTbl = 'ARC'i
   "TbCreate" ArcTbl "NOWRITE KEYS(Mod)",
      "Names(User Vers HL Hist1 Hist2 Hist3 Hist4 Hist5 Hist6)"
end
"TbAdd archive"                       /* Save the archive data */

/* Copy the member to the Last Known Working Member if required. */
if LKWMTbl <> '' then do
   address TSO "Alloc f(arc) dsn('"ArcDSN"')" ArcVol "SHR REUSE"
   "TbOpen" LKWMTbl "NOWRITE Library(ARC)"
   if RC = 0 then do
      "TbGet" LKWMTbl
      GotLKWM = (RC = 0 & LKWM <> '')
      "TbClose" LKWMTbl
      if GotLKWM then do
         DoCopy = 0
         "LMOpen DataID(&DID)"
         "LMMFind DataID(&DID) Member(&Mem) Stats(YES)"
         cMod = ZLM4Date ZLMTime':'ZLMSec
         if Mod > cMod then do
            "LMMFind DataID(&DID) Member(&LKWM) Stats(YES)"
            if RC = 8 then lMod = ''
            else lMod = ZLM4Date ZLMTime':'ZLMSec
            if cMod > lMod then DoCopy = 1
         end
         "LMClose DataID(&DID)"
         if DoCopy then do
            "LMInit DataID(ToID) DataSet('"DSN"')" ArcVol
            "LMCopy FromID(&DID) FromMem(&Mem)",
               "ToDataID(&ToID) ToMem(&LKWM) REPLACE"
            "LMFree DataID(&ToID)"
         end
      end
   end
   "TbStats BADTABLE Library(BADLIB)" /* workaround for ISPF bug */
   address TSO "Free f(arc)"
end

/* Set CAPS OFF for messages. */
address ISREdit
"(CM) = CAPS"
"CAPS = OFF"
Global = ''                           /* Set up for Global opts */
if zParms = 0 & Mem <> '' then do
   address ISPExec
   "LMInit DataID(ArcID) DataSet('"ArcDSN"')" ArcVol
   "LMOpen DataID(&ArcID)"
   "LMMFind DataID(&ArcID) Member(Z{PARMS{)"
   zParms = (RC = 0)
   "LMClose DataID(&ArcID)"
   "LMFree DataID(&ArcID)"
end
address TSO
if zParms then do
   "Alloc f(in) dsn('"ArcDSN"(Z{PARMS{)')" ArcVol "SHR REUSE"
   "ExecIO * DiskR in (STEM Parms. FINIS"
   "Free f(in)"
   do i=1 to Parms.0
      parse VAR Parms.i 2 Type Info
      if Translate(Type) = 'OPTS' then Global = Global Info
   end
   Global = Space(Global)
   interpret a#Opts(Global)
end
Opts = Opts'00'x||Global
address ISPExec "TbMod archive"
parse VALUE A#Open('ARC',ArcKey,'READ') WITH Archive .
if Archive = '' then do               /* No archive member */
   address ISREdit
   if NoArc then
      "LINE_AFTER 0 = MSGLINE 'No archive exists for this member'"
   "CAPS = &CM"
   exit                               /* OK - continue editing. */
end

line = 1
parse VALUE '0' WITH dl,Desc1,Desc2,Desc3,Desc4,Desc5,Desc6
parse VALUE '0' WITH hl,Hist1,Hist2,Hist3,Hist4,Hist5,Hist6
parse VALUE '0' WITH Data,Mbr
do forever
   "ExecIO 1 DiskR arc" line
   if RC <> 0 then leave
   line = line+1
   pull 2 Type . 'HEADER('Header')' 1 'DATA('Data')' 1 'MEMBER('Mbr')'
   if Header = '' then Header = 0
   if Data = '' then Data = 0
   if Header = 0 then Head.0 = 0
   else "ExecIO" Header "DiskR arc" line "(STEM Head."
   line = line + Header
   if WordPos(Type,'CURRENT ARCHIVE') = 0 then leave  /* error */
   parse VALUE '00.00' WITH pVers pUser pMod
   if Head.0 = 0 then do
      if Type = 'CURRENT' then ArcVers = pVers
      else do
         address ISPExec "TbAdd" ArcTbl
         parse VALUE '0' WITH hl,Hist1,Hist2,Hist3,Hist4,Hist5,Hist6
      end
   end; else do
      Local = ''                      /* Set up for Local opts */
      do i=1 to Head.0
         parse UPPER VAR Head.i 2 Op .
         Select
         When Op = 'OPTS' then Local = Local||'00'x SubWord(Head.i,2)
         When Op = 'STATS' then do
            parse UPPER VAR Head.i,
               'VERSION('pVers')' 1 'USER('pUser')' 1 'MODIFIED('pMod')'
            end
         When Op = 'HIST' then do
            hl = hl+1
            parse VALUE Strip(Head.i) WITH . '(' Info
            call Value 'HIST'hl, Left(Info,Length(Info)-1)
            end
         When Op = 'DESC' then do
            dl = dl+1
            parse VALUE Strip(Head.i) WITH . '(' Info
            call Value 'DESC'dl, Left(Info,Length(Info)-1)
            end
         Otherwise nop
         End
      end
      if Type <> 'CURRENT' then do
         address ISPExec "TbAdd" ArcTbl
         parse VALUE '0' WITH hl,Hist1,Hist2,Hist3,Hist4,Hist5,Hist6
      end; else do
         interpret a#Opts(Local)
         Opts = Opts||Local
         address ISPExec "TbMod archive"
         ArcVers = pVers
      end
   end
   Vers = pVers; User = pUser; Mod = pMod
   line = line + Data
end
"ExecIO 0 DiskR arc (FINIS"
"Free f(arc)"
address ISPExec "TbQuery" ArcTbl "RowNum(Rows)"
address ISREdit
if Rows = 0 & Data = 0 & Mbr = '' then do  /* No archive data */
   if Mem = '' then type = 'dataset'
   else type = 'member'
   if NoArc then
      "LINE_AFTER 0 = MSGLINE 'There is no history for this &type'"
   "CAPS = &CM"
   exit
end
address ISPExec "TbAdd" ArcTbl

/* Put the recent change history in message lines on the display */
address ISPExec
/* archive description */
if Desc then do i=1 to dl
   push Value('DESC'i)
end
if Queued() > 0 then push ' '

/* recent change history */
"TbTop" ArcTbl
do v=1 to Hist
   "TbSkip" ArcTbl
   if RC > 0 then leave
   if Mod <> '' then Mod = 'Modified at' Mod
   if User <> '' then User = 'by' User
   push 'v'Vers Mod User
   do i=1 to hl
      push '       'Value('HIST'i)
   end
end
address ISREdit
do Queued()
   parse PULL Data
   "LINE_AFTER 0 = NOTELINE (Data)"
end
if Mem <> '' then do
   VV = ''; LL = ''
   "(VV) = VERSION"
   "(LL) = LEVEL"
   DiskVers = Right(VV,2,0)'.'Right(LL,2,0)
   if DiskVers <> ArcVers & NoSync then
      "LINE_AFTER 0 = MSGLINE",
         "'WARNING: Current v&DiskVers differs from archive v&ArcVers'"
end
"CAPS = &CM"
exit
)MEMBER A#MAKE LINES(144)
/* Rexx function to make a temporary dataset containing a specific
*  Dataset(Member) at a specific Version() User() Modified() level.
*  Usage: a#Make(ArcKey,Stats)
*  Returns the dataset name of the temporary dataset.
*  ArcKey is in the format Volume:DSN(Member),
*  Stats is in the format
*  Version(vv.ll) User(uuuuuuu) Modified(yyyy/mm/dd hh:mm:ss)
*.
*. 2005/12/02 Use the archive copy, not the edited dataset.
*. 2005/08/09 Created by bsquare
*/
arg ArcKey,Stats
if ArcKey = '' then signal Macro
parse VAR ArcKey Vol ':' DSN
if DSN = '' then parse VAR Vol DSN,Vol
parse VAR DSN DSN '('Mem')'
if DSN = '' then return ''

if Vol <> '' then Vol = ' VOLUME('Vol')'
if ListDSI("'"DSN"'"Vol) <> 0 then return ''
RecFm = Left(SysRecFm,1)
if RecFm <> 'F' & RecFm <> 'V' then return ''

/* Find LLQ of ArcKey */
LLQ = Translate(DSN,,'.')
LLQ = Word(LLQ,Words(LLQ))
Temp = 'DS'Right(Time('S'),5,0)
TempDS = 'TEMP.'Temp'.'LLQ
address TSO
"Alloc f("Temp") dsn("TempDS") NEW CATALOG",
   "RecFm("RecFM "B) LRecL("SysLRecL") DSOrg(PS) SPACE(15,15) TRACKS"
if RC <> 0 then return ''
"Free f("Temp")"

address ISPExec
"VPut (ArcKey Stats) SHARED"
"Edit DataSet("TempDS") MACRO(a#Make)"
return TempDS

Macro:
   address ISPExec
   "VGet (ArcKey Stats) SHARED"
   if RC <> 0 then return
   address ISREdit
   "Macro"
   if RC <> 0 then return

   parse VALUE a#Open('IN',ArcKey,'READ') WITH Archive VolInfo
   if Archive = '' then signal Cancel
   address TSO
   "ExecIO * DiskR in (STEM Arc. FINIS"
   "Free f(in)"

   address ISREdit
   parse VAR ArcKey Vol ':' DSN
   if DSN = '' then parse VAR Vol DSN,Vol

   /* Set up the initial dataset contents */
   if Arc.0 = 0 then signal Cancel          /* empty archive */
   parse UPPER VAR Arc.1 2 Section . 'HEADER('Header')',
         1 'DATA('Data')' 1 'MEMBER('Mem')'
   if Section <> 'CURRENT' then signal Cancel /* bad archive */
   if Header = '' then Header = 0
   if Data <> '' then do
      do i=1 to Data
         Cur = Value('ARC.'Header+i+1)
         "LINE_AFTER" i-1 "= (Cur)"
      end
   end; else do
      if Mem = '' then signal Cancel        /* No archive copy! */
      parse VAR Archive ArcDSN '('
      ArcCopy = ArcDSN'('Mem')'
      if VolInfo = '' then do
         "COPY '"ArcCopy"' BEFORE .ZFIRST"
         if RC <> 0 then signal Cancel      /* No archive copy! */
      end; else do
         address TSO
         "Alloc f(in) dsn('"ArcCopy"')"VolInfo "SHR REUSE"
         if RC <> 0 then signal Cancel
         "ExecIO * DiskR in (STEM In. FINIS"
         "Free f(in)"
         address ISREdit
         do i=1 to In.0
            Cur = In.i
            "LINE_AFTER" i-1 "= (Cur)"
         end
      end
   end
   if Data = '' then Data = 0

   parse UPPER VAR Stats,
      'VERSION('Vers')' 1 'USER('User')' 1 'MODIFIED('Mod')'
   if Mod <> '' then Key = 'MOD'
   else if Vers <> '' then Key = 'VERS'
   else Key = 'USER'
   ln = 2
   do until ln > Arc.0 | Value(Key) = Value('A'Key)
      aVers = '00.00'; aUser = ''; aMod = ''
      do Header
         parse UPPER VALUE ln+1||Arc.ln WITH ln '-' Type Info
         if Type <> 'STATS' then iterate
         parse VAR Info,
            'VERSION('aVers')' 1 'USER('aUser')' 1 'MODIFIED('aMod')'
      end
      last = ln+Data
      offset = 0                   /* line offset */
      if Section = 'ARCHIVE' then do while ln < last
         parse UPPER VALUE ln+1||Arc.ln WITH ln '-' Type Info
         Select
         When Type = 'INS' then do          /* Insert Lines at Start */
            parse VAR Info 'LINES('Lines')' 1 'START('Start')'
            Start = Start-1
            do i=ln to ln+Lines-1
               Cur = Arc.i
               "LINE_AFTER &Start = (Cur)"
               Start = Start+1
            end
            ln = ln+Lines
            offset = offset + Lines
            end
         When Type = 'DEL' then do
            parse VAR Info 'COUNT('Count')' 'START('Start')'
            Start = Start + offset
            do Count
               "DELETE &Start"
            end
            offset = offset - Count
            end
         Otherwise nop
         End
      end
      ln = last
      parse UPPER VALUE ln+1||Arc.ln WITH ln ')' Section Info
      if Section <> 'ARCHIVE' then leave
      parse VAR Info 'HEADER('Header')' 1 'DATA('Data')'
      if Header = '' then Header = 0
   end
   "BUILTIN SAVE"
   "BUILTIN END"
   exit

Cancel: /* Cancel the macro - major error */
   address ISREdit "CANCEL"
   exit
)MEMBER A#OPEN LINES(128)
/* Rexx function to open the archive(member) for a given
*  Dataset(Member).  This will be slightly different for READ and WRITE.
*  Usage: a#Open(DD,ArcKey,Purpose)
*  Returns archiveÝ(member)¨ ÝVOLUME(volser)¨ or '' on failure.
*  ArcKey is in the format Volume:DSN(Member),
*  Purpose is either READ or WRITE.
*.
*. 2005/08/04 Created by bsquare
*. 2005/08/17 Add ISPTTDef for strange terminal types.
*.            LMMFind screws up with terminal types other than 3278(a).
*/
arg DD,ArcKey,Purpose
if DD = '' then return ''
parse VAR ArcKey Vol ':' DSN
if DSN = '' then parse VAR ArcKey DSN,Vol
parse VAR DSN DSN '('Mem')'
if DSN = '' then return ''
if Purpose = '' then Purpose = 'READ'
if Purpose <> 'READ' & Purpose <> 'WRITE' then return ''

address TSO
if Right(DSN,4) = '.ARC' then return ''
if Right(Mem,1) = '{' then return ''

/* Use volume information for uncataloged datasets */
IsCat = ListDSI("'"DSN"'") = 0
if IsCat & Vol <> '' then IsCat = (SysVolume = Vol)
if IsCat then Vol = ''
else Vol = ' VOLUME('Vol')'

/* Check the control dataset (the archive). */
SysDSOrg = 'BAD'
ArcDSN = DSN'.ARC'
if Length(ArcDSN) <= 44 then call ListDSI "'"ArcDSN"'"||Vol

/* Check sequential datasets first, they're simpler */
if Mem = '' then do
   if Left(SysDSOrg,2) <> 'PS' then return ''
   if Purpose = 'READ' then
        "Alloc f("DD") dsn('"ArcDSN"') SHR REUSE"
   else "Alloc f("DD") dsn('"ArcDSN"') OLD REUSE"
   if RC <> 0 then return ''
   return ArcDSN
end

/* The remainder of this is only for PDS archives */
if Left(SysDSOrg,2) <> 'PO' then ArcDSN = DSN
ArcMem = Strip(Left(Mem,7))'{'

address ISPExec
"VGet (ZTerm)"
if ZTerm <> '3278' & ZTerm <> '3278A' then
   "Select Pgm(ISPTTDEF) Parm(3278)"
"LMInit DataID(DID) DataSet('"ArcDSN"')"Vol "ENQ(SHRW)"
"LMOpen DataID(&DID)"
"LMMFind DataID(&DID) Member(&ArcMem)"
if RC = 0 then
   "LMGet DataID(&DID) Mode(INVAR) MaxLen(80) DataLoc(Data) DataLen(Len)"
if RC <> 0 then signal NoMem

parse UPPER VAR Data 2 Type Info
if Type = 'RESOLVE' then do
   parse VAR Info 'ID('ConID')'
   ArcMem = 'Z{'Right(ConID,4,0)||SubStr(Mem,8)||'{'
   "LMMFind DataID(&DID) Member(&ArcMem)"
   if RC <> 0 then signal NoMem
   call RetMem ArcDSN'('ArcMem')'
end
/* Type = 'CURRENT' */
parse VAR Info 'MEMBER('aMem')'
if aMem = Mem then call RetMem ArcDSN'('ArcMem')'
if Purpose = 'READ' then call RetMem

/* Resolve contention for WRITE */
Parms. = 0
ConID = ''
"LMMFind DataID(&DID) Member(Z{PARMS{)"
if RC = 0 then do
   address TSO
   "Alloc f(in) dsn('"ArcDSN"(Z{PARMS{)')"Vol "SHR REUSE"
   "ExecIO * DiskR in (STEM Parms. FINIS"
   "Free f(in)"
   do i=1 to Parms.0
      parse UPPER VAR Parms.i 2 Type Info
      if Type <> 'RESOLVE' then iterate
      pl = i
      parse UPPER VAR Parms.i . 'ID('ConID')'
      leave
   end
end
if ConID <> '' then ConID = Right(ConID+1,4,0)
else do
   ConID = '0000'
   pl = Parms.0+1; Parms.0 = pl
end
Parms.pl = ')Resolve ID('ConID')'
address TSO
"Alloc f(out) dsn('"ArcDSN"(Z{PARMS{)')"Vol "SHR REUSE"
"ExecIO" Parms.0 "DiskW out (STEM Parms. FINIS"
"Free f(out)"
OldArc = 'Z{'ConID||SubStr(aMem,8)||'{'
address ISPExec
"LMClose DataID(&DID)"
"LMOpen DataID(&DID) Option(OUTPUT)"
"LMMRen DataID(&DID) Member(&ArcMem) NewName(&OldArc)"
Data = Parms.pl
"LMPut DataID(&DID) Mode(INVAR) DataLoc(Data) DataLen(80)"
"LMMAdd DataID(&DID) Member(&ArcMem) Stats(NO)"
ArcMem = 'Z{'ConID||SubStr(Mem,8)||'{'
call RetMem ArcDSN'('ArcMem')'

NoMem:
   if Purpose = 'READ' then call RetMem
   else call RetMem ArcDSN'('ArcMem')'

RetMem:
   arg DSN
   address ISPExec
   "LMClose DataID(&DID)"
   "LMFree DataID(&DID)"
   if ZTerm <> '3278' & ZTerm <> '3278A' then
      "Select Pgm(ISPTTDEF) Parm("ZTerm")"
   if DSN <> '' then do
      address TSO,
         "Alloc f("DD") dsn('"DSN"')"Vol "SHR REUSE"
      if RC <> 0 then exit ''
   end
   exit DSN||Vol
)MEMBER A#OPT LINES(191)
/* Rexx edit macro to set options for an archive (global or local).
*  Usage: Install using #CONFIG.
*.
*. 2005/08/26 Created by bsquare
*. 2005/09/06 Fix for sequential datasets (remove LKWM).
*. 2005/09/07 Check for LKWM allowable (set in a#Init).
*/
address ISREdit
"Macro"                /* called as edit macro */
if RC <> 0 then exit   /* called from dataset or member list */
Panel.MEMBER  = 'a#OptMP'
Panel.DATASET = 'a#OptDP'
"(Vol) = VOLUME"
"(DSN) = DATASET"
"(Mem) = MEMBER"
ArcKey = Vol':'DSN'('Mem')'
if Mem <> '' then DSN = DSN'('Mem')'
address ISPExec
"TbGet archive"
LKWM = ''
if LKWMTbl <> '' then do
   address TSO "Alloc f(arc) dsn('"ArcDSN"')" ArcVol "SHR REUSE"
   "TbOpen" LKWMTbl "NOWRITE Library(ARC)"
   if RC = 0 then do
      "TbGet" LKWMTbl
      "TbClose" LKWMTbl
   end
end

if Mem = '' then
   parse VAR Opts Def '00'x . '00'x DataSet,Member
else
   parse VAR Opts Def '00'x DataSet '00'x Member
DataSet = Space(Translate(DataSet,,'00'x))
Member  = Space(Translate(Member ,,'00'x))
oDS = DataSet; oMem = Member
if LKWM <> '' | Member <> '' then OptType = 'MEMBER'
else OptType = 'DATASET'
parse VALUE 0 LKWM WITH Accept OldLKWM .,CopyLKWM
do until RV <> 0
   parse VALUE WITH Hist,Desc,NoArc,NoSync,Quiet
   interpret a#Opts(Value(OptType))
   if Hist Desc NoArc NoSync = '0 0 0 0' then
      parse VALUE 1 WITH Quiet,Hist,Desc,NoArc,NoSync
   if Mem = '' & OptType = 'MEMBER' then do
      OptType = 'DATASET'
      say 'Hey!!'
   end
   oType = OptType
   "Display Panel("Panel.OptType")"
   RV = RC
   Vars = 'Hist Desc NoArc NoSync Quiet'
   call Value oType,''
   do while Vars <> ''
      parse VAR Vars v Vars
      Val = Strip(Value(v))
      if Val = 'YES' then call Value oType,Value(oType) v
      else if Val <> '' then
         call Value oType,Value(oType) v||'('Val')'
   end
end
if LKWMTbl <> '' then do
   if Accept then do
      if LKWM = '' then CopyLKWM = ''
      if CopyLKWM <> '' then do
         address ISREdit
         "(Copy) = DATASET"
         "(DID) = DATAID"
         address ISPExec
         "LMInit DataID(ToID) DataSet('"Copy"') VOLUME("Vol")"
         "LMCopy FromID(&DID) FromMem(&Mem)",
            "ToDataID(&ToID) ToMem(&LKWM) REPLACE"
         "LMFree DataID(&ToID)"
      end
      if OldLKWM <> LKWM | CopyLKWM <> '' then do
         Mod = Translate('1234/56/78',Date('S'),'12345678') Time()
         "TbOpen" LKWMTbl "Library(ARC)"
         if RC <> 0 then
            "TbCreate" LKWMTbl "Keys(Mem) Names(LKWM Mod) Library(ARC)"
         if LKWM <> '' then "TbMod" LKWMTbl
         else "TbDelete" LKWMTbl
         "TbClose" LKWMTbl "Library(ARC)"
      end
   end
   "TbStats BADTABLE Library(BADLIB)" /* workaround for ISPF bug */
   address TSO "Free f(arc)"
end
/* normalize options for test */
DataSet = Space(DataSet)
Member  = Space(Member)
/* quit if there is nothing to do */
if Accept = 0 | (oDS = DataSet & oMem = Member) then exit

/* Set Global and Local from DataSet and Member */
if Mem = '' then do; Loc = DataSet; Global = ''; end
else do; Global = DataSet; Loc = Member; end
Local = ''                          /* split options into lines */
do while Loc <> ''
   p = LastPos(' ',Loc' ',70)
   parse VAR Loc cur =(p) Loc
   Local = Local||'00'x||cur
end
Local = SubStr(Local,2)

Opts = Def'00'x||Global'00'x||Local
"TbMod archive"                     /* update options in table */

/* cLocal  = Local options changed */
/* cGlobal = Global options changed */
cLocal  = (Mem <> '' & oMem <> Member) | (Mem = '' & oDS <> DataSet)
cGlobal = (Mem <> '' & oDS <> DataSet)
if cLocal then do                   /* local options changed */
   parse VALUE '0 0' WITH Arc.0 Head.0,Data,Mbr
   if a#Open('IN',ArcKey,'READ') <> '' then do
      address TSO
      "ExecIO 1 DiskR in"
      if RC = 0 then do
         pull 'HEADER(' Hdr ')' 1 'DATA(' Data ')' 1 'MEMBER(' Mbr ')'
         if Hdr <> '' then "ExecIO" Hdr "DiskR in (STEM Head."
         do i=1 to Head.0
            if Translate(Word(Head.i,1)) = '-OPTS' then Head.i = ''
         end
      end
      "ExecIO * DiskR in (STEM Arc. FINIS"
      "Free f(in)"
   end
   if a#Open('OUT',ArcKey,'WRITE') <> '' then do
      do i=1 to Head.0
         if Head.i <> '' then queue Head.i
      end
      do while Local <> ''
         parse VAR Local cur '00'x Local
         queue '-Opts' cur
      end
      Extra = ''
      if Data <> '' then Extra = Extra 'Data('Data')'
      if Mbr  <> '' then Extra = Extra 'Member('Mbr')'
      if Queued() = 0 & Extra = '' & Arc.0 = 0 then
         "ExecIO 0 DiskW out (OPEN FINIS"      /* truncate */
      else do
         push ')Current Header('Queued()')'||Extra
         "ExecIO" Queued() "DiskW out"
         "ExecIO" Arc.0 "DiskW out (STEM Arc. FINIS"
      end
      "Free f(out)"
   end
end
if cGlobal then do                  /* global options changed */
   address ISPExec
   "VGet (ZTerm)"                   /* deal with strange term types */
   if ZTerm <> '3278' & ZTerm <> '3278A' then
      "Select Pgm(ISPTTDef) Parm(3278)"
   "LMInit DataID(DataID) DataSet('"ArcDSN"')" ArcVol
   "LMOpen DataID(&DataID)"
   "LMMFind DataID(&DataID) Member(Z{PARMS{)"
   Exists = (RC = 0)                /* this member already exists. */
   "LMClose DataID(&DataID)"
   "LMFree DataID(&DataID)"
   if ZTerm <> '3278' & ZTerm <> '3278A' then
      "Select Pgm(ISPTTDef) Parm("ZTerm")"
   address TSO
   if Exists then do
      "Alloc f(arc) dsn('"ArcDSN"(Z{PARMS{)')" ArcVol "SHR REUSE"
      "ExecIO * DiskR arc (STEM Arc. FINIS"
      "Free f(arc)"
   end; else Arc.0 = 0
   if DataSet = '' then Opts = ''
   else Opts = ')Opts' Strip(DataSet)
   "Alloc f(arc) dsn('"ArcDSN"(Z{PARMS{)')" ArcVol "SHR REUSE"
   "ExecIO 0 DiskW arc (OPEN"       /* force truncation */
   do while Length(Opts) > 80
      p = LastPos(' ',Opts' ',79)
      parse VAR Opts cur =(p) Opts
      queue cur
      "ExecIO 1 DiskW arc"
      if Opts <> '' then Opts = ')Opts' Strip(Opts)
   end
   if Opts <> '' then do
      queue Opts
      "ExecIO 1 DiskW arc"
   end
   do i=1 to Arc.0
      parse VAR Arc.i Type Info
      if Translate(Type) <> ')OPTS' then do
         queue Strip(Arc.i)
         "ExecIO 1 DiskW arc"
      end
   end
   "ExecIO 0 DiskW arc (FINIS"
   "Free f(arc)"
end
)MEMBER A#OPTDP LINES(56)
)ATTR
 _ TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(ASIS)
 ! TYPE(INPUT) INTENS(HIGH) CAPS(ON)  JUST(ASIS) PAS(ON)
 * TYPE(OUTPUT) PAS(ON)
 $ TYPE(PS)
)BODY EXPAND(\\)
%&ZUSER---- MCIT Edit Archive Control \-\&ZDATE-&ZTIME--
%Option  ===>_ZCMD\ \+
+
+ Set%DataSet+Options for%&tDSN
+                                               *GotoMem
+
+ Display the following upon entry to an Edit/View session:
+      Number of versions for History:_Hist+    +(default 5)
+                 Archive description:%&Desc    $(Change)
+          No Archive warning message:%&NoArc   $(Change)
+ Archive out of sync warning message:%&NoSync  $(Change)
+               SUPPRESS ALL MESSAGES:%&Quiet   $(Change)
+
+\ \Use%END+to CANCEL or$ACCEPT+to ACCEPT the changes\ \+
)INIT
 &Toggle = ''
 &Desc   = Trans(Trunc(&Desc  ,1) 0,NO 1,YES N,NO Y,YES *,' ')
 &NoArc  = Trans(Trunc(&NoArc ,1) 0,NO 1,YES N,NO Y,YES *,' ')
 &NoSync = Trans(Trunc(&NoSync,1) 0,NO 1,YES N,NO Y,YES *,' ')
 &Quiet  = Trans(Trunc(&Quiet ,1) 0,NO 1,YES N,NO Y,YES *,' ')
 &tDSN = Trunc(&DSN,'(')
 if (&Mem = &Z)
    &GotoMem = ''
    .ATTR(GotoMem) = 'PAS(OFF)'
 else
    &GotoMem = '(Member Options)'
)PROC
 if (&Toggle = 1)
    &Desc   = Trans(Trunc(&Desc  ,1) ' ',NO N,YES Y,' ' *,' ')
 if (&Toggle = 2)
    &NoArc  = Trans(Trunc(&NoArc ,1) ' ',NO N,YES Y,' ' *,' ')
 if (&Toggle = 3)
    &NoSync = Trans(Trunc(&NoSync,1) ' ',NO N,YES Y,' ' *,' ')
 if (&Toggle = 4)
    &Quiet  = Trans(Trunc(&Quiet ,1) ' ',YES Y,NO N,' ' *,' ')
    if (&Quiet = YES)
       &Hist = &Z
       &Desc = &Z
       &NoArc = &Z
       &NoSync = &Z
 if (&Accept = 1)
    .RESP = END
)PNTS
 FIELD(GotoMem)  VAR(OptType) VAL(MEMBER)
 FIELD(ZPS00001) VAR(Toggle) VAL(1)
 FIELD(ZPS00002) VAR(Toggle) VAL(2)
 FIELD(ZPS00003) VAR(Toggle) VAL(3)
 FIELD(ZPS00004) VAR(Toggle) VAL(4)
 FIELD(ZPS00005) VAR(ACCEPT) VAL(1)
)END
)MEMBER A#OPTMP LINES(60)
)ATTR
 _ TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(ASIS)
 ! TYPE(INPUT) INTENS(HIGH) CAPS(ON)  JUST(ASIS)
 $ TYPE(PS)
)BODY EXPAND(\\)
%&ZUSER---- MCIT Edit Archive Control \-\&ZDATE-&ZTIME--
%Option  ===>_ZCMD\ \+
+
+ Set%Member +Options for%&DSN
+                                               $(DataSet Options)
+
+ Display the following upon entry to an Edit/View session:
+      Number of versions for History:_Hist+    +(default 5)
+                 Archive description:%&Desc    $(Change)
+          No Archive warning message:%&NoArc   $(Change)
+ Archive out of sync warning message:%&NoSync  $(Change)
+               SUPPRESS ALL MESSAGES:%&Quiet   $(Change)
+
+ For RECFM=FB,LRECL=80 archives ONLY:
+ Set the Last Known Working Member to keep a specific version
+ of &DSN in case of logical errors.
+           Last Known Working Member:!LKWM    +&Mod
+Copy the current version to the LKWM:%&CopyLKWM$(Change)
+
+\ \Use%END+to CANCEL or$ACCEPT+to ACCEPT the changes\ \+
)INIT
 &Toggle = ''
 &Desc   = Trans(Trunc(&Desc  ,1) 0,NO 1,YES N,NO Y,YES *,' ')
 &NoArc  = Trans(Trunc(&NoArc ,1) 0,NO 1,YES N,NO Y,YES *,' ')
 &NoSync = Trans(Trunc(&NoSync,1) 0,NO 1,YES N,NO Y,YES *,' ')
 &Quiet  = Trans(Trunc(&Quiet ,1) 0,NO 1,YES N,NO Y,YES *,' ')
 if (&CopyLKWM ¬= &Z)
    &CopyLKWM = 'Y'
)PROC
 if (&Toggle = 1)
    &Desc   = Trans(Trunc(&Desc  ,1) ' ',NO N,YES Y,' ' *,' ')
 if (&Toggle = 2)
    &NoArc  = Trans(Trunc(&NoArc ,1) ' ',NO N,YES Y,' ' *,' ')
 if (&Toggle = 3)
    &NoSync = Trans(Trunc(&NoSync,1) ' ',NO N,YES Y,' ' *,' ')
 if (&Toggle = 4)
    &Quiet  = Trans(Trunc(&Quiet ,1) ' ',YES Y,NO N,' ' *,' ')
    if (&Quiet = YES)
       &Hist = &Z
       &Desc = &Z
       &NoArc = &Z
       &NoSync = &Z
 if (&Toggle = 5)
    &CopyLKWM= Trans(&CopyLKWM Y,' ' *,Y)
 if (&Accept = 1)
    .RESP = END
)PNTS
 FIELD(ZPS00001) VAR(OptType) VAL(DATASET)
 FIELD(ZPS00002) VAR(Toggle) VAL(1)
 FIELD(ZPS00003) VAR(Toggle) VAL(2)
 FIELD(ZPS00004) VAR(Toggle) VAL(3)
 FIELD(ZPS00005) VAR(Toggle) VAL(4)
 FIELD(ZPS00006) VAR(Toggle) VAL(5)
 FIELD(ZPS00007) VAR(ACCEPT) VAL(1)
)END
)MEMBER A#OPTS LINES(23)
/* Rexx function to return a line of executable rexx code given an
*  option string.
*  Usage: a#Opts(String)
*  Returns 1 line of Rexx code which can be executed with interpret.
*.
*. 2005/08/12 Created by bsquare
*/
KeyWords = 'QUIET HIST NOARC NOSYNC DESC'
arg Opts
Opts = Translate(Opts,,'00'x)    /* '00'x is used as a separator */
ret = ''
do Words(Opts)
   parse VAR Opts o Opts
   parse VAR o Name '(' Val ')'
   if WordPos(Name,KeyWords) = 0 then iterate
   if Val = '' then Val = 1
   if Val = 'YES' then Val = 1
   if Val = 'NO' then Val = 0
   if Name = 'QUIET' & Val = 1 then
      ret = ret||'Hist=0; NoArc=0; NoSync=0; Desc=0; '
   else ret = ret||Name"='"Val"'; "
end
return ret
)MEMBER A#REST LINES(76)
/* Rexx program to restore the current edit session to a previous
*  version.
*  Usage: Install using #CONFIG.
*  The macro will a#Make the correct version and copy it in.
*.
*. 2005/08/11 Created by bsquare
*/
address ISREdit
"Macro (parm)"
if Parm = '' then Parm = -1
RV = Translate(Parm)
if DataType(RV,'N') then signal OK
parse VAR RV c 2 RV
if c = 'V' & DataType(RV,'N') & Pos('.',RV) > 0 then signal OK

ZEdLMsg = 'Usage: Restore Ýv¨VV.MM'
ZEdSMsg = 'Bad version spec'
address ISPExec "SetMsg Msg(ISRZ000)"
exit

OK:
   "(Vol) = VOLUME"
   "(DSN) = DATASET"
   "(Mem) = MEMBER"
   "(Changed) = DATA_CHANGED"
   VV = ''; LL = ''
   "(VV) = VERSION"
   "(LL) = LEVEL"
   DiskVers = Right(VV,2,0)'.'Right(LL,2,0)
   ArcKey = Vol':'DSN'('Mem')'
   address ISPExec
   "TBGet archive"
   "TBTop &ArcTbl"
   if RV < 0 then do
      if DataType(RV,'W') = 0 then signal Err   /* not a whole number */
      "TBSkip &ArcTbl"
      if RC <> 0 then signal Err
      RV = RV+1                      /* count skip to current version */
      if DiskVers <> Vers then Changed = 'YES'
      do (Changed = 'NO') - RV
         "TBSkip &ArcTbl"
         if RC <> 0 then signal Err
      end
      RV = Vers
   end; else do
      parse VAR RV VV '.' LL
      RV = Right(VV,2,0)'.'Right(LL,2,0)
      do until Vers = RV
         "TBSkip &ArcTbl"
         if RC <> 0 then signal Err
      end
   end
   address ISREdit
   Vers = 'VERSION('Vers') USER('User') MODIFIED('Mod')'
   ViewDS = a#Make(ArcKey,Vers)
   if ViewDS = '' then signal Err
   "X ALL"
   "DEL ALL X"
   "COPY" ViewDS "BEFORE .ZFIRST"
   parse VAR RV VV '.' LL
   if VV = 0 then "STATS OFF"
   else do
      "VERSION = (VV)"
      "LEVEL   = (LL)"
   end
   om = Msg('OFF')
   address TSO "Delete" ViewDS
   call Msg om
   "RESET"
   exit

Err:
   ZEdLMsg = 'The archive does not contain version' RV
   ZEdSMsg = 'Not found'
   address ISPExec "SetMsg Msg(ISRZ000)"
   exit
)MEMBER A#SAVE LINES(401)
/* Rexx program to save a datasetÝ(member)¨ from ISPF edit with
*  version control.
*  Usage: Install using #CONFIG.
*  When you SAVE from ISPF edit, this will check to see if a control
*  dataset exists.  See a#Init for a description.
*  If this data set exists, a session comparison will be done and the
*  changes stored in the archive dataset, along with history information
*  obtained via an ISPF panel.
*.
*. 2005/06/23 Created by bsquare
*. 2005/07/08 Decided not to allow sequential datasets.
*. 2005/07/12 Rescinded the above decision.
*. 2005/07/21 Changed format of archive datasets.
*. 2005/08/17 Handle odd terminal types for LMMFind bug.
*. 2006/01/13 Fix cancelled save of existing unarchived member. (v1.1)
*/
address ISREdit
"Macro (parms)"

/* Get information about the dataset being edited (the target). */
"(DID)     = DATAID"        /* Data ID for target dataset */
"(Vol)     = VOLUME"
"(DSN)     = DATASET"       /* Target dataset */
"(Mem)     = MEMBER"        /*        member */
ArcKey = Vol':'DSN'('Mem')' /* Key for archive table */
if Mem = '' then Target = DSN
else Target = DSN'('Mem')'
"(Changed) = DATA_CHANGED"
"(State)   = USER_STATE"

/* Get information about the control dataset (the archive). */
address ISPExec
"TbGet archive"             /* ArcDSN ArcTbl dl Desc1-6 */
"TbQuery" ArcTbl "ROWNUM(Versions)"
address ISREdit
IsArc = (Versions > 0)

Stats = GetStats(DID,Mem)
/* Treat previously deleted member as "Stats don't match" */
if Stats = 'NEW' & IsArc then Stats = ''
if Stats = 'NEW' then do
   if Changed = 'NO' then call Done 0   /* nothing to save or archive */
   dl = GetDesc(Target)            /* Get a description for this data */
   address ISPExec "TbMod archive" /* Save the description */

   /* SAVE */
   if Mem <> '' then "STATS ON"  /* Make sure STATS are ON */
   "BuiltIn SAVE"
   if RC > 4 then call Fail 'SAVE Failed RC' RC
   if Mem <> '' then Stats = GetStats(DID,Mem)
   else do
      Mod = Translate('Year/Mm/Dd',Date('S'),'YearMmDd') Time()
      Stats = 'Version('IncRev()') User('UserID()') Modified('Mod')'
   end
   sLines = (Stats <> '')          /* should ALWAYS be 1 */
   if sLines = 0 then Vers = '00.00'
   else do
      parse UPPER VAR Stats,
         'VERSION('Vers')' 1 'USER('User')' 1 'MODIFIED('Mod')'
   end
   address ISPExec "TbTop" ArcTbl
   address ISPExec "TbAdd" ArcTbl

   "(Lines)   = LINENUM .ZLAST"
   Lines = Lines+0               /* reformat as number */
   parse VALUE a#Open('OUT',ArcKey,'WRITE') WITH Archive VolInfo
   /* Copy the member to the archive PDS if required. */
   if ArcDSN <> DSN & Archive <> ArcDSN then do
      Copy = "'"ArcDSN"'"
      address ISPExec
      "LMInit DataID(ToID) DataSet(&Copy)" VolInfo
      "LMCopy FromID(&DID) FromMem(&Mem) ToDataID(&ToID) REPLACE"
      "LMFree DataID(&ToID)"
   end
   address TSO
   if Mem <> '' then
      queue ')Current Header('sLines+dl') Member('Mem')'
   else
      queue ')Current Header('sLines+dl') Data('Lines')'
   if sLines > 0 then queue '-Stats' Stats
   do i=1 to dl
      queue '-Desc' '('Value('DESC'i)')'
   end
   "ExecIO" 1+sLines+dl "DiskW out"

   /* Put the data inline if required. */
   if Archive = ArcDSN then do i=0 to Lines-1 by 100
      do j=1 until j=min(100,Lines-i)
         address ISREdit "(Cur) = LINE" i+j
         Line.j = Strip(Cur,'T')  /* small savings for VB */
      end
      "ExecIO" j "DiskW out (STEM Line."
   end
   "ExecIO 0 DiskW out (FINIS"
   "Free f(out)"
   address ISREdit
end; else do
   OldArc.0 = 0
   ArcStats = ''; CompDS = ''
   if IsArc then do
      address ISPExec
      "TbTop" ArcTbl
      "TbSkip" ArcTbl
      if Vers = '00.00' then Vers = ''
      if Vers <> '' then ArcStats = 'Version('Vers')'
      if User <> '' then ArcStats = ArcStats 'User('User')'
      if Mod  <> '' then ArcStats = ArcStats 'Modified('Mod')'
      if Mem = '' then Stats = ArcStats
      /* no need to archive or save */
      if Changed = 'NO' then call Done 0
      if Stats = '' then dl = GetDesc(Target)
      parse VALUE a#Open('IN',ArcKey,'READ') WITH Archive VolInfo
      if Archive = '' then do   /* previously cancelled save. */
         Header = 0; Data = ''
         CompDS = 'SESSION'
      end; else do
         address TSO
         "ExecIO 1 DiskR in"
         pull 'HEADER('Header')' 1 'DATA('Data')'
         if Header = '' then Header = 0
         /* Obtain old data for deleted or munged members */
         if Data <> '' then do
            "ExecIO" Data "DiskR in" Header+2 "(STEM Old."
            if Old.0 = 0 then CompDS = 'NONE'
            else do
               CompDS = 'ARCHIVE.TEMP.S'Time('S')
               "Alloc f(tmp) dsn("CompDS") NEW CATALOG DSORG(PS) LIKE('"DSN"')"
               "ExecIO" Data "DiskW tmp (STEM Old. FINIS"
               "Free f(tmp)"
            end
         end
         if Data <> '' then Header = Header+Data
         /* Read archive, skipping )Current data */
         "ExecIO * DiskR in" Header+2 "(STEM OldArc. FINIS"
         "Free f(in)"
      end
      address ISREdit
   end; else do
      dl = GetDesc(Target)            /* get data description */
      address ISPExec "TbMod archive" /* save the description */
      parse UPPER VAR Stats,
         'VERSION('Vers')' 1 'USER('User')' 1 'MODIFIED('Mod')'
      parse VALUE '' WITH Hist1 Hist2 Hist3 Hist4 Hist5 Hist6
      if Vers = '' then Vers = '00.00'
      address ISPExec "TbAdd" ArcTbl  /* save the old version */
      CompDS = 'SESSION'              /* no archive yet       */
   end
   if Changed = 'YES' then do
      /* complete replacement or difference? */
      if CompDS = 'NONE' then do
         "(Lines) = LINENUM .ZLAST"
         Lines = Lines+0               /* reformat as number */
         if Lines > 0 then queue '-Del Count('Lines') Start(1)'
      end; else do
         /* Save the old compare options for later restoration */
         address ISPExec "VGet (ZEDUPDOP ZUPXSIZ)"
         OldOpts = ZEdUpdOp; OldXSize = ZUpXSiz
         ZEdUpdOp = '0000000000'; ZUpXSiz = 0
         address ISPExec "VPut (ZEDUPDOP ZUPXSIZ) ASIS"

         /* Compare to the disk copy of this dataset */
         if CompDS = '' then
            if ArcDSN = DSN then CompDS = 'SESSION'
            else CompDS = "'"ArcDSN"("Mem")'"
         "BuiltIn Compare" CompDS "SAVE"
         RV = RC

         /* restore old compare options */
         ZEdUpdOp = OldOpts; ZUpXSiz = OldXSize
         address ISPExec "VPut (ZEDUPDOP ZUPXSIZ) ASIS"
         "Reset LABEL SPECIAL"

         if RV <> 0 then do
            if CompDS <> 'SESSION' & Pos('(',CompDS) = 0 then do
               prev = Msg('OFF')
               "Delete" CompDS
               call Msg prev
            end
            call Fail 'Unexpected error from Compare, RC' RV
         end
         address TSO
         "Alloc f(in) dsn(ISPFEDIT.COMPARE.LIST) SHR REUSE"
         "ExecIO * DiskR in (STEM Compare. FINIS"
         "Free f(in)"
         prev = Msg('OFF')
         "Delete ISPFEDIT.COMPARE.LIST"
         call Msg prev

         /* Process the comparison output */
         if CompDS = 'SESSION' then
            "Alloc f(from) dsn('"Target"') SHR REUSE"   /* disk copy */
         else
            "Alloc f(from) dsn("CompDS") SHR REUSE"     /* disk copy */
         mark = 122
         do i=1 to Compare.0
            if Left(Compare.i,2) = 'ID' then
               mark = pos('TYPE',Compare.i)
            if SubStr(Compare.i,3,1) <> '-' then iterate
            parse VAR Compare.i,
               Op 3 =(mark) Type +3 +1 Len +5 +1 nLine +5 +1 oLine +5
            Len = Strip(Len)
            /* reformat as number */
            nLine = ('0'nLine)+0
            oLine = ('0'oLine)+0
            Len   = ('0'Len)+0
            Select
            When Len = 0 then say Compare.i  /* ERROR! */
            When Type = 'INS' then do    /* From lines */
               queue '-Ins Lines('Len') Start('nLine')'
               "ExecIO" Len "DiskR from" nLine "(STEM Temp."
               do t=1 to Len; queue Strip(Temp.t,'T'); end
               i = i + Len - 1
               end
            When Type = 'DEL' then do    /* To lines */
               queue '-Del Count('Len') Start('oLine')'
               i = i + Len - 1
               end
            When Type = 'RPL' | Type = 'RFM' then do
               queue '-Ins Lines('Len') Start('nLine')'
               "ExecIO" Len "DiskR from" nLine "(STEM Temp."
               do t=1 to Len; queue Strip(Temp.t,'T'); end
               queue '-Del Count('Len') Start('oLine')'
               i = i + (Len*2) - 1
               end
            Otherwise say Compare.i          /* ERROR! */
            End
         end
         "ExecIO 0 DiskR from (FINIS"
         "Free f(from)"
         if CompDS <> 'SESSION' & Pos('(',CompDS) = 0 then do
            prev = Msg('OFF')
            "Delete" CompDS
            call Msg prev
         end
      end
      address ISREdit
      Lines = Queued()
      NewRev = IncRev(Vers)
      hl = GetHist(Target,NewRev) /* get history entry */
      do i=hl to 1 by -1
         push '-Hist' '('Value('HIST'i)')'
      end
      if Stats = '' & ArcStats <> '' then Stats = ArcStats
      if Stats <> '' then push '-Stats' Stats
      push ')Archive Header('Queued()-Lines') Data('Lines')'

      /* SAVE */
      if Mem <> '' then "STATS ON"  /* Make sure STATS are ON */
      "BuiltIn SAVE"
      if RC > 4 then call Fail 'SAVE Failed RC' RC
      if RC = 4 & ArcStats <> '' then do
         "VERSION =" Left(NewRev,2)
         "LEVEL   =" Right(NewRev,2)
      end
      if Mem <> '' then Stats = GetStats(DID,Mem)
      else do
         Mod = Translate('Year/Mm/Dd',Date('S'),'YearMmDd') Time()
         Stats = 'Version('NewRev') User('UserID()') Modified('Mod')    '
      end
      parse UPPER VAR Stats,
         'VERSION('Vers')' 1 'USER('User')' 1 'MODIFIED('Mod')'
      address ISPExec "TbTop" ArcTbl
      if Vers = '' then Vers = '00.00'
      address ISPExec "TbAdd" ArcTbl
   end
   "(Lines)   = LINENUM .ZLAST"
   Lines = Lines+0               /* reformat as number */
   parse VALUE a#Open('OUT',ArcKey,'WRITE') WITH Archive VolInfo
   /* Copy the member to the archive PDS if required. */
   if ArcDSN <> DSN & Archive <> ArcDSN then do
      address ISPExec
      Copy = "'"ArcDSN"'"
      "LMInit DataID(ToID) DataSet(&Copy)"VolInfo
      "LMCopy FromID(&DID) FromMem(&Mem) ToDataID(&ToID) REPLACE"
      "LMFree DataID(&ToID)"
   end
   address TSO
   "NEWSTACK"
      parse VAR Opts Default '00'x Global '00'x Local
      if Stats <> '' then queue '-Stats' Stats
      if Mem = '' then
         do while Global <> ''
            parse VAR Global cl '00'x Global
            queue '-Opts' Strip(cl)
         end
      else
         do while Local <> ''
            parse VAR Local cl '00'x Local
            queue '-Opts' Strip(cl)
         end
      do i=1 to dl
         queue '-Desc' '('Value('DESC'i)')'
      end
      if Mem <> '' then
         push ')Current Header('Queued()') Member('Mem')'
      else
         push ')Current Header('Queued()') Data('Lines')'
      "ExecIO" Queued() "DiskW out"

      /* Put the data inline if required. */
      if Archive = ArcDSN then do i=0 to Lines-1 by 100
         do j=1 until j=min(100,Lines-i)
            address ISREdit "(Cur) = LINE" i+j
            Line.j = Strip(Cur,'T')  /* small savings for VB */
         end
         "ExecIO" j "DiskW out (STEM Line."
      end
   "DELSTACK"
   if Queued() > 0 then "ExecIO" Queued() "DiskW out"
   if OldArc.0 > 0 then
      "ExecIO" OldArc.0 "DiskW out (STEM OldArc."
   "ExecIO 0 DiskW out (FINIS"
   "Free f(out)"
end
call Done 0

Done:
   arg ret
   address TSO "DelStack"        /* eliminate old garbage */
   address ISREdit "USER_STATE = (State)"
exit ret

/* Get statistics for a member. */
GetStats: PROCEDURE
   arg DataID,Member
   if Member = '' then return '' /* no stats for sequential dataset */
   address ISPExec
   "VGet (ZTerm)"                /* deal with strange term types */
   if ZTerm <> '3278' & ZTerm <> '3278A' then
      "Select Pgm(ISPTTDef) Parm(3278)"
   "LMOpen DataID("DataID")"
   "LMMFind DataID("DataID") Member("Member") STATS(YES)"
   Exists = (RC = 0)           /* this member already exists. */
   "LMClose DataID("DataID")"
   if ZTerm <> '3278' & ZTerm <> '3278A' then
      "Select Pgm(ISPTTDef) Parm("ZTerm")"
   if Exists = 0 then return 'NEW'

   parse VALUE '' WITH Vers User Mod
   if ZLVers <> '' then Vers = 'Version('ZLVers'.'ZLMod')'
   if ZLM4Date <> '' then
      Mod  = 'Modified('ZLM4Date ZLMTime':'ZLMSec')'
   if ZLUser <> '' then User = 'User('Strip(ZLUser)')'
   return Vers User Mod

/* Get a description of this data from the User. */
GetDesc: PROCEDURE EXPOSE State Desc1 Desc2 Desc3 Desc4 Desc5 Desc6
   arg DSN
   address ISPExec
   if Desc1 = '' then Desc1 = 'Original' DSN 'by' UserID()
   "Display Panel(a#DescP)"
   if RC = 8 then call Done 8
   do i=6 to 1 by -1 until Value('DESC'i) <> ''; end
   return i

/* Get a description of these changes from the User. */
GetHist: PROCEDURE EXPOSE State,
   Hist1 Hist2 Hist3 Hist4 Hist5 Hist6,
   Desc1 Desc2 Desc3 Desc4 Desc5 Desc6
   arg DSN,Vers        /* Vers,Desc are displayed in ArcHist */
   parse VALUE '' WITH Hist1 Hist2 Hist3 Hist4 Hist5 Hist6
   address ISPExec
   "Display Panel(a#HistP)"
   if RC = 8 then call Done 8
   do i=6 to 1 by -1 until Value('HIST'i) <> ''; end
   return i

/* Increment the revision (Version.Level). */
IncRev: PROCEDURE
   arg OldRev
   address ISREdit
   "(Mem)   = MEMBER"
   if Mem = '' then NewRev = OldRev
   else do
      "(Vers)  = VERSION"       /* version and */
      "(Level) = LEVEL"         /* modification level */
      if RC <> 0 then NewRev = ''
      else NewRev = Right(Vers,2,0)'.'Right(Level,2,0)
   end
   if OldRev <> '' then do
      if OldRev < 1 then NewRev = 1
      if NewRev = '' then NewRev = OldRev
      if NewRev = OldRev then NewRev = NewRev + 0.01
   end; else if NewRev = '' then NewRev = 1
   parse VAR NewRev Vers '.' Level
   Vers = Right(Vers,2,0)
   Level = Right(Level,2,0)
   if Mem <> '' then do
      "VERSION =" Vers
      "LEVEL   =" Level
   end
   return Vers'.'Level

/* Fail with a message. */
Fail: PROCEDURE EXPOSE State
   parse ARG ZEdLMsg
   ZEdSMsg = "Archive Failure"
   address ISPExec "SetMsg Msg(ISRZ000)"
   address TSO "DelStack"          /* kill old garbage */
   address ISREdit "USER_STATE = (State)"
   exit 8
)MEMBER A#TOUCH LINES(94)
/* Rexx program to update the Last Known Working Member's ACCEPT time.
*  Usage: a#Touch Archive Ý(member)¨
*  Archive is the PDS whose members should be updated.  TSO syntax is
*  accepted for the Archive DSN.
*  Archive can be specified as a DD statement, which should specify
*  the DS name, not a specific member.
*  If member is not supplied, a#Touch updates the time for ALL members
*  of the selected PDS.  The () are required.
*  This can be run in batch or interactively.
*.
*. 2005/08/31 Created by bsquare
*/
if arg(1) = '?' then signal ShowHelp
LKWMTbl = 'Z{LKWM{'
cTime = Translate('1234/56/78',Date('S'),'12345678') Time()

/* Get ArcDSN and ArcVol */
arg DSN . '('Member')'
if Member = '' then Member = '*'
if DSN <> '' then Vol = ''
else do
   if ListDSI('ARCHIVE FILE') > 4 then exit 20
   Vol = SysVolume
   DSN = "'"SysDSName"'"
   if ListDSI(DSN) <= 4 & SysVolume = Vol then Vol = ''
   else Vol = 'VOLUME('Vol')'
end
if Right(Strip(DSN,,"'"),4) <> '.ARC' then do
   if Left(DSN,1) = "'" then
      aDSN = "'"Strip(DSN,,"'")".ARC'"
   else aDSN = DSN'.ARC'
   om = Msg('OFF')
   if ListDSI(aDSN Vol) <= 4 then DSN = aDSN
   call Msg om
end

/* Get ArcDSN ArcVol */
address TSO "Alloc f(arc) dsn("DSN")" Vol "SHR REUSE"
LKWM = ''
address ISPExec
"TbOpen" LKWMTbl "Library(ARC)"
if RC <> 0 then say 'Could not open archive table'
else do until RC > 0
   /* Use TbScan to scan the table for matches (allows * wildcard) */
   Mem = Member
   "TbScan" LKWMTbl "ArgList(Mem)"
   if RC = 0 then do
      Mod = cTime
      "TbPut" LKWMTbl
      say 'Set' Mem 'to' Mod
   end
end
"TbClose" LKWMTbl "Library(ARC)"
"TbStats BADTABLE Library(BADLIB)" /* workaround for ISPF bug */
address TSO "Free f(arc)"
exit

/* Show the Help text for the rexx exec (from the comments) */
ShowHelp:  /* Not a procedure.  Doesn't return. */
   do i=1 for SourceLine() until s = '*/'
      s = Strip(SourceLine(i))
      if Left(s,2) = '* ' | Left(s,3) = '/* ' then queue SubStr(s,3)
   end
   call ViewQ
   exit

/* Display the data stack with ISPF View.
*  Note: not a procedure.  This is so the passed-in stem can be EXPOSEd
*  to the calling routine.
*/
ViewQ: arg $Stem$; call $ViewQ$; return
$ViewQ$: procedure EXPOSE ($Stem$)
   /* Queue any stem variable output */
   if $Stem$ ¬= '' then do l=1 to Value($Stem$||0)
      queue Value($Stem$||l)
   end

   address TSO
   'ISPQRY'
   if (RC /= 0) then "EXECIO" Queued() "DISKW SYSPRINT"
   else do
      dd = 'VWQ' || Right(SysVar('SYSSRV'),5,0)
      /* Allocate space for the output */
      "Alloc f("dd") UNIT(VIO) LRECL(256) RECFM(V) DSORG(PS) NEW DELETE"
      "EXECIO" Queued() "DISKW" dd "(FINIS"
      /* Use ISPF View to display the output */
      address ISPExec
      "LMINIT DataID(temp) DDName("dd")"
      "VIEW   DataID("temp") CONFIRM(NO) CHGWARN(NO) MACRO(NORECOV)"
      "LMFREE DataID("temp")"
      /* Free the space */
      address TSO "FREE f("dd")"
   end
   return
)MEMBER A#VERSP LINES(26)
)ATTR
   $ TYPE(OUTPUT)  INTENS(LOW) CAPS(OFF)  COLOR(GREEN)
   ! TYPE(OUTPUT)  INTENS(LOW) CAPS(OFF)  COLOR(RED)
   _ TYPE(OUTPUT)  INTENS(LOW) CAPS(OFF)  COLOR(TURQ)
   @ TYPE(INPUT)  INTENS(LOW) CAPS(ON)  COLOR(TURQ)
)BODY EXPAND(\\)
+CMD%=>@ZCMD                   \ \+SCROLL%=>@SCR +
%\ \Available Versions\ \  +
+ &Desc1
+ &Desc2
+ &Desc3
+ &Desc4
+ &Desc5
+ &Desc6
+Version Last Modified       User    +
+------- ------------------- --------+
)MODEL
@Z!Vers _Mod                _User    +
        $Hist1\ \+
)INIT
 .ZVARS = 'SelCode'
 .AUTOSEL=YES
)PROC
 &Row = .CSRROW
 if (&Row ¬= '00000000') .CSRROW = &Row
)END
)MEMBER A#VHIST LINES(68)
/* Rexx edit macro to display archive history for the edited dataset.
*  Usage: Install using #CONFIG.
*.
*. 2005/07/12 Created by bsquare
*/
address ISREdit
"Macro"                /* called as edit macro */
if RC <> 0 then exit   /* called from dataset or member list */
"(Vol) = VOLUME"
"(DSN) = DATASET"
"(Mem) = MEMBER"
ArcKey = Vol':'DSN'('Mem')'
address ISPExec
"TbGet archive"

"TbTop &ArcTbl"
"TbSkip &ArcTbl"
if RC <> 0 then do
   if Mem = '' then
      ZEdLMsg = 'No archive history exists for this dataset yet.'
   else ZEdLMsg = 'No archive history exists for this member yet.'
   ZEdSMsg = 'No history'
   "SetMsg Msg(ISRZ000)"
   exit
end
if Mem <> '' then DSN = DSN'('Mem')'
do forever
   "TbDispl &ArcTbl PANEL(a#VersP)"
   if RC > 0 then leave
   if Row = 0 then iterate
   "TbTop &ArcTbl"
   "TbSkip &ArcTbl NUMBER(&Row)"
   /* You can check the value of SelCode here */
   Select
   When SelCode = '' | SelCode = 'S' then "Display Panel(a#DHistP)"
   When SelCode = 'V' then do
      Stats = 'Version('Vers') User('User') Modified('Mod')'
      Archive = a#Make(ArcKey,Stats)
      if Archive <> '' then do
         "View Dataset("Archive")"
         om = Msg('OFF')
         address TSO "Delete" Archive
         call Msg om
      end
      end
   When SelCode = 'R' then do
      Stats = 'Version('Vers') User('User') Modified('Mod')'
      Archive = a#Make(ArcKey,Stats)
      if Archive <> '' then do
         address ISREdit
         "X ALL"
         "DEL ALL X"
         "COPY" Archive "BEFORE .ZFIRST"
         parse VAR Vers VV'.'LL
         if VV <> '' then do
            "VERSION = (VV)"
            "LEVEL   = (LL)"
         end
         om = Msg('OFF')
         address TSO "Delete" Archive
         call Msg om
         address ISPExec
      end
      end
   Otherwise nop
   End
   SelCode = ' '
end
)MEMBER A#VIEW LINES(54)
/* Rexx program to supplement the ISPF edit VIEW command, allowing
*  the user to view previous versions of an archived dataset or member.
*  Usage: Install using #CONFIG.
*  The macro will just call the BUILTIN VIEW command unless the argument
*  string is a valid version string.
*.
*. 2005/08/09 Created by bsquare
*/
address ISREdit
"Macro (parm)"
RV = Translate(Parm)
if DataType(RV,'N') then signal OK
parse VAR RV c 2 RV
if c = 'V' & DataType(RV,'N') & Pos('.',RV) > 0 then signal OK
"BUILTIN VIEW" Parm
exit RC

OK:
   "(Vol) = VOLUME"
   "(DSN) = DATASET"
   "(Mem) = MEMBER"
   ArcKey = Vol':'DSN'('Mem')'
   address ISPExec
   "TBGet archive"
   "TBTop &ArcTbl"
   if RV < 0 then do
      if DataType(RV,'W') = 0 then signal Err   /* not a whole number */
      do 1-RV
         "TBSkip &ArcTbl"
         if RC <> 0 then signal Err
      end
      RV = Vers
   end; else do
      parse VAR RV VV '.' LL
      RV = Right(VV,2,0)'.'Right(LL,2,0)
      do until Vers = RV
         "TBSkip &ArcTbl"
         if RC <> 0 then signal Err
      end
   end
   Vers = 'VERSION('Vers') USER('User') MODIFIED('Mod')'
   ViewDS = a#Make(ArcKey,Vers)
   if ViewDS = '' then signal Err
   address ISPExec "View Dataset("ViewDS")"
   om = Msg('OFF')
   address TSO "Delete" ViewDS
   call Msg om
   exit

Err:
   ZEdLMsg = 'The archive does not contain version' RV
   ZEdSMsg = 'Not found'
   address ISPExec "SetMsg Msg(ISRZ000)"
   exit
