{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012552000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 2762942, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 20, "INMDSNAM": "CBT.V500.FILE669.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 2762942, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 2762942, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE669.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00,\\n'", "DS1TRBAL": "b'O\\x8e'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x04\\xbb\\x00\\t\\x04\\xbe\\x00\\x08\\x00-'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$$EDIT": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x13\\x01\\x17\\x08\\x9f\\x01\\x19\\x19\\x9f\\x11@\\x00&\\x00\\x17\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2017-03-30T00:00:00", "modifydate": "2019-07-18T11:40:13", "lines": 38, "newlines": 23, "modlines": 0, "user": "DVL"}, "text": "/*                                                                     rexx\n Update values in the FILE669 library.\n The PDSMAIN command is required.\n*/\n cbtpfx     = userid()\n cbtlib     = cbtpfx'.CBT669.LIB'\n linklib    = cbtpfx'.LIB.LOADLIB'\n lpalib     = cbtpfx'.LIB.LOADLIB'\n asmproc    = 'HLA.SASMSAM1'\n pdspgm     = 'PDSMAIN'  /* alternates are PDS86, STARTOOL */\n\n \"\"pdspgm \"'\"cbtlib\"'\",\n  \"replace a:z 'CBT669.LIB' '\"cbtlib\"' write\"\n\n \"\"pdspgm \"'\"cbtlib\"'\",\n  \"replace a:z 'DVL.CBT669' '\"cbtlib\"' write\"\n\n \"\"pdspgm \"'\"cbtlib\"'\",\n  \"replace a:z 'YOUR.LINKLIB' '\"linklib\"' write\"\n\n \"\"pdspgm \"'\"cbtlib\"'\",\n  \"replace a:z 'CBT669.LINKLIB' '\"linklib\"' write\"\n\n \"\"pdspgm \"'\"cbtlib\"'\",\n  \"replace a:z 'CBT669.LPALIB' '\"lpalib\"' write\"\n\nif asmproc<>'' & asmproc<>'HLA.SASMSAM1' then,\n  \"\"pdspgm \"'\"cbtlib\"'\",\n   \"replace a:z 'HLA.SASMSAM1' '\"asmproc\"' write\"\n\nif asmprlb='' then do\n  \"\"pdspgm \"'\"cbtlib\"'\",\n   \"replace a:z '// JCLLIB' '//* JCLLIB' write\"\n  \"\"pdspgm \"'\"cbtlib\"'\",\n   \"replace a:z '//  JCLLIB' '//* JCLLIB' write\"\n  \"\"pdspgm \"'\"cbtlib\"'\",\n   \"replace a:z '//   JCLLIB' '//* JCLLIB' write\"\n end\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$$#DATE": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00\\x03\\x01  \\x9f\\x01  \\x9f\\x11\\x10\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf5\\xf0\\xf0@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "2020-07-27T00:00:00", "modifydate": "2020-07-27T11:10:03", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-500"}, "text": "REGULAR CBT TAPE - VERSION 500    FILE:  669\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT500.FILE669\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 85 MEMBERS COUNTED; CUMULATIVE SIZE IS 25,663 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   07/27/20    11:10:03    UTC-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$NOTE01": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x10\\x01\\x19 ?\\x01\\x19 ?\\x123\\x00\\x16\\x00\\x16\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-07-22T00:00:00", "modifydate": "2019-07-22T12:33:10", "lines": 22, "newlines": 22, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  Update CBT FILE669\nFrom:     Willy Jensen <Willy.h.jensen@outlook.com>\nDate:     7/22/2019, 11:01 AM\nTo:       \"'(sbgolob@cbttape.org)'\" <sbgolob@cbttape.org>\n\nHello Sam,\nI have a new CBT file 669 build ready.\n\nNote that it is a complete replacement of the earlier build. You\nmight want to change the $$$#DATE member, all else should be\nready to roll out.\n\nHighlights\nREXXGBLV - major virtual storage constraint relief, new operand\n           DATA(mask) to filter on data contents.\nRXVSAMBA - support for ESDS.\nRXPATTRN - new, test a string by a mask.\nRXWAIT - new, can wait for whole seconds or fractions of a second.\n\nBest regards\nWilly\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE02": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x11\\x01\\x193\\x9f\\x01\\x193\\x9f\\x12@\\x00\\x12\\x00\\x12\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-12-05T00:00:00", "modifydate": "2019-12-05T12:40:11", "lines": 18, "newlines": 18, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  New CBT 669\nFrom:     Willy Jensen <Willy.h.jensen@outlook.com>\nDate:     12/5/2019, 11:01 AM\nTo:       \"'(sbgolob@cbttape.org)'\" <sbgolob@cbttape.org>\n\nHi Sam,\n\nI have made a replacement for CBT file 669. As recently\nmentioned, I have updated the STRPATRN subroutine, so programs\nusing that use that must of course also be updated.\n\nThe CBT 669 replacement is in the Dallas system as dataset\nWJENSEN.CBT669.LIB. Please note that it is a total replacement,\ndo not use anything from the old dataset.\n\nBest regards\nWilly\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE03": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00&\\x01  \\x9f\\x01  \\x9f\\x11\\t\\x00\\x10\\x00\\x10\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-07-27T00:00:00", "modifydate": "2020-07-27T11:09:26", "lines": 16, "newlines": 16, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  New CBT 669\nFrom:     Willy Jensen <Willy.h.jensen@outlook.com>\nDate:     7/27/2020, 8:16 AM\nTo:       \"'(sbgolob@cbttape.org)'\" <sbgolob@cbttape.org>\n\nHello Sam,\n\nI have made a replacement for CBT file 669, mostly because of an\nupdate to the STRPATRN macro.\n\nPlease note that this version is a total replacement.\nDo not use anything from the old dataset.\n\nAll the best...\nWilly\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE669": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00U\\x01  \\x9f\\x01  \\x9f\\x11\\t\\x00\\xa7\\x00\\xa7\\x00\\x00\\xc3\\xc2\\xe3`\\xf5\\xf0\\xf0@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "2020-07-27T00:00:00", "modifydate": "2020-07-27T11:09:55", "lines": 167, "newlines": 167, "modlines": 0, "user": "CBT-500"}, "text": "//***FILE 669  REXX Global Variables, VSAM bulk access, OpComm etc  *   FILE 669\n//*                                                                 *   FILE 669\n//*            Contact email: willy@harders-jensen.com              *   FILE 669\n//*            Web:           http://harders-jensen.com/wjtech      *   FILE 669\n//*                                                                 *   FILE 669\n//*            Programs in package:                                 *   FILE 669\n//*                                                                 *   FILE 669\n//*             ISPDPX01 - ISPF panel exit, supply panel lines in   *   FILE 669\n//*                        REXX stem(s)                             *   FILE 669\n//*                        Build: 003 2019-12-04                    *   FILE 669\n//*             REXXGBLV - REXX function to implement global        *   FILE 669\n//*                        variables.                               *   FILE 669\n//*                        Build: 064 2020-07-22                    *   FILE 669\n//*             REXXSTOR - REXX function to save and retrieve a     *   FILE 669\n//*                        string in command storage.               *   FILE 669\n//*                        Build: 005 2019-12-04                    *   FILE 669\n//*             RXPATTRN - REXX function to test a string against   *   FILE 669\n//*                        a pattern.                               *   FILE 669\n//*                        Build: 003 2020-07-21                    *   FILE 669\n//*             RXRDPRML - REXX function to copy a parmlib          *   FILE 669\n//*                        member to a stem.                        *   FILE 669\n//*                        Build: 005 2019-12-04                    *   FILE 669\n//*             RXOPCOMM - REXX function allowing a REXX program    *   FILE 669\n//*                        to support operator MODIFY and STOP      *   FILE 669\n//*                        commands.                                *   FILE 669\n//*                        Build: 006 2019-12-04                    *   FILE 669\n//*             RXVSAMBA - REXX function to read and update a       *   FILE 669\n//*                        VSAM KSDS and RRDS database through      *   FILE 669\n//*                        stem or stack.                           *   FILE 669\n//*                        Build: 026 2020-07-22                    *   FILE 669\n//*             RXWAIT   - REXX function to wait whole or           *   FILE 669\n//*                        fractions of seconds.                    *   FILE 669\n//*                        May also be used as a TSO command and    *   FILE 669\n//*                        a batch pgm                              *   FILE 669\n//*                        Build: 002 2019-12-04                    *   FILE 669\n//*                                                                 *   FILE 669\n//*            This update is mostly because a fix to a bug in the  *   FILE 669\n//*            STRPATRN macro, which is used in several of the      *   FILE 669\n//*            programs.                                            *   FILE 669\n//*                                                                 *   FILE 669\n//*            Install a program                                    *   FILE 669\n//*                                                                 *   FILE 669\n//*             RECEIVE the transport dataset, this will generate   *   FILE 669\n//*             a pds with all neccessary members.                  *   FILE 669\n//*             Edit and excute the $$$$EDIT member to update       *   FILE 669\n//*             library names throughout the CBT library.           *   FILE 669\n//*             Review and run the program member. This will        *   FILE 669\n//*             install and verify the program.                     *   FILE 669\n//*             You may edit and execute member Z669UPDT to update  *   FILE 669\n//*             library names etc in the install lib.               *   FILE 669\n//*                                                                 *   FILE 669\n//*            ISPDPX01 description                                 *   FILE 669\n//*                                                                 *   FILE 669\n//*             This  ISPF panel  exit is  used to  insert records  *   FILE 669\n//*             into  an ISPF  panel.  It can  replace the  entire  *   FILE 669\n//*             panel, or one  or more sections with  data in REXX  *   FILE 669\n//*             stem variable(s).                                   *   FILE 669\n//*             Build: 003                                          *   FILE 669\n//*             See member ISX1DOC for full  documentation.         *   FILE 669\n//*             Members ISX1* are part of the ISPDPX01 package.     *   FILE 669\n//*                                                                 *   FILE 669\n//*            REXXGBLV description                                 *   FILE 669\n//*                                                                 *   FILE 669\n//*             Provides   a  variable   store  external   to  the  *   FILE 669\n//*             currently running REXX program. REXX variables can  *   FILE 669\n//*             be  copied to  the  external  store and  retrieved  *   FILE 669\n//*             again at  some later time  by the same  or another  *   FILE 669\n//*             REXX  process. The  saved  variables  can even  be  *   FILE 669\n//*             written to and retrieved from  a disk file, so can  *   FILE 669\n//*             be  used across  logons and  even be  shared among  *   FILE 669\n//*             users.                                              *   FILE 669\n//*             Plus numerous REXX variable handling functions.     *   FILE 669\n//*             Build: 062                                          *   FILE 669\n//*             See member RXGVDOC for full  documentation.         *   FILE 669\n//*             See member RXGVRDME for a member list.              *   FILE 669\n//*             Members RXGV* are part of the REXXGBLV package.     *   FILE 669\n//*                                                                 *   FILE 669\n//*            REXXSTOR description                                 *   FILE 669\n//*                                                                 *   FILE 669\n//*             Allow a REXX program to  store a string of data in  *   FILE 669\n//*             common storage and retrieve  it later, either from  *   FILE 669\n//*             the  same program  or from  another REXX  program.  *   FILE 669\n//*             Build: 005                                          *   FILE 669\n//*             See member RXSTDOC for full  documentation.         *   FILE 669\n//*             Members RXST* are part of the REXXSTOR package.     *   FILE 669\n//*                                                                 *   FILE 669\n//*            RXPATTRN description                                 *   FILE 669\n//*                                                                 *   FILE 669\n//*             Test a string by a mask, return 0 if match.         *   FILE 669\n//*             See member RXPNDOC for full  documentation.         *   FILE 669\n//*             Build: 002                                          *   FILE 669\n//*             Members RXPN* are part of the RXPATTRN package.     *   FILE 669\n//*                                                                 *   FILE 669\n//*            RXRDPRML description                                 *   FILE 669\n//*                                                                 *   FILE 669\n//*             Read parmlib member, return data in stem.           *   FILE 669\n//*             Some comments may be ignored.                       *   FILE 669\n//*             Build: 005                                          *   FILE 669\n//*             See member RXRPDOC for full  documentation.         *   FILE 669\n//*             Members RXRP* are part of the RXRDPRML package.     *   FILE 669\n//*                                                                 *   FILE 669\n//*            RXOPCOMM description                                 *   FILE 669\n//*                                                                 *   FILE 669\n//*             Allow MODIFY and STOP operator command for REXX     *   FILE 669\n//*             programs (F jobname,some text, or P jobname).       *   FILE 669\n//*             Build: 006                                          *   FILE 669\n//*             See member RXOPDOC for full  documentation.         *   FILE 669\n//*             Members RXOP* are part of the RXOPCOMM package.     *   FILE 669\n//*                                                                 *   FILE 669\n//*            RXVSAMBA description                                 *   FILE 669\n//*                                                                 *   FILE 669\n//*             The program  can add, replace, retrieve  or delete  *   FILE 669\n//*             records from a VSAM database. Acess is normally by  *   FILE 669\n//*             key/keyprefix,  but  some functions  allow  access  *   FILE 669\n//*             based on text anywhere in the record.               *   FILE 669\n//*             Data is either read from  a REXX stem or stored in  *   FILE 669\n//*             a REXX stem.                                        *   FILE 669\n//*             Build: 025                                          *   FILE 669\n//*             See member RXVBDOC for full  documentation.         *   FILE 669\n//*             Members RXVB* are part of the RXVSAMBA package.     *   FILE 669\n//*                                                                 *   FILE 669\n//*            RXWAIT description                                   *   FILE 669\n//*                                                                 *   FILE 669\n//*              cc=RXWAIT(time-spec)                 REXX function *   FILE 669\n//*               or                                                *   FILE 669\n//*              RXWAIT timespec                      TSO cmd       *   FILE 669\n//*               or                                                *   FILE 669\n//*              // EXEC PGM=RXWAIT,PARM=timespec     batch step    *   FILE 669\n//*                time-spec:                                       *   FILE 669\n//*                  n          seconds                             *   FILE 669\n//*                  .nn        fractions of seconds                *   FILE 669\n//*                  =hhmmssth                                      *   FILE 669\n//*             Members RXWT* are part of the RXWAIT package.       *   FILE 669\n//*             Build: 002                                          *   FILE 669\n//*                                                                 *   FILE 669\n//*            Changes in this package:                             *   FILE 669\n//*                                                                 *   FILE 669\n//*             REXXGBLV  Fix DATA(ccc) issue                       *   FILE 669\n//*                                                                 *   FILE 669\n//*             RXPATTRN  Change ASAXWC call to own StrPatrn        *   FILE 669\n//*                                                                 *   FILE 669\n//*             RXVSAMBA  Fix MASK(ccc) issue                       *   FILE 669\n//*                                                                 *   FILE 669\n//*             RXWAIT    Add '.' and '=' parm formats              *   FILE 669\n//*                       Add CDEUCTZ2 macro to keep lmod in        *   FILE 669\n//*                       storage.                                  *   FILE 669\n//*                                                                 *   FILE 669\n//*             See the xxxxHIST members for details.               *   FILE 669\n//*                                                                 *   FILE 669\n//*            Other members of possible interest                   *   FILE 669\n//*                                                                 *   FILE 669\n//*              ISPXMACS  ASM copy book containing my macros for   *   FILE 669\n//*                        interfacing with ISPF.                   *   FILE 669\n//*              REXXMACS  ASM copy book containing my macros for   *   FILE 669\n//*                        interfacing with REXX.                   *   FILE 669\n//*              WSAMMACS  ASM copy book containing my structured   *   FILE 669\n//*                        assembler macro set. WSAM is similar,    *   FILE 669\n//*                        but not identical, to IBM's Structured   *   FILE 669\n//*                        Programming Macros.                      *   FILE 669\n//*                                                                 *   FILE 669\n//*            Some notes                                           *   FILE 669\n//*              Common macros devloped by me are combined in       *   FILE 669\n//*              member DVLMACS. This member is included by the     *   FILE 669\n//*              various products.                                  *   FILE 669\n//*              Use member Z669UPDT to update JCL - if you have    *   FILE 669\n//*              STARTOOL or PDS86 installed.                       *   FILE 669\n//*                                                                 *   FILE 669\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DVLXMACS": {"ttr": 530, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x12\\x01\\x19$\\x8f\\x01\\x193\\x7f\\x18\\x15\\x05u\\x00\\x02\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2019-09-05T00:00:00", "modifydate": "2019-12-03T18:15:12", "lines": 1397, "newlines": 2, "modlines": 0, "user": "DVL"}, "text": "*/ ADD NAME=$LA\n         Macro\n.*-\n.* $LA - build LA instruction (inner macro)\n.*\n.* Returns length in a global variable, length either defined by the\n.* 2rd operand, or computed from the 2nd operand.\n.* Syntax:\n.*   $la  r1,label      -> la    r1,label\n.*   $la  r1,,label     -> la    r1,label\n.*   $la  r1,number     -> lgfi  r1,nnn\n.*   $la  r1,4(,r3)     -> la    r1,4(,r3)                -> length=0\n.*   $la  r1,(r2)       -> lr    r1,r2                    -> length=0\n.*   $la  r1,'kilroy'   -> la    r1,=c'kilroy'\n.*   $la  r1,0          -> slr   r1,r1                    -> length=0\n.*   $la  r1,x.label    -> lx    r1,label  (x: B, F or H) -> length=0\n.* The length is returned in global variable $lalen, the type in\n.* global variable $latype.\n.*\n.* updates\n.* 2017-14-03  numeric value now different from label\n.* 2018-06-16  2rd operand is now alternate src, not global length\n.* 2019-01-11  change global $LALENC\n.*-\n&mlbl    $la   &reg,&psrc,&pasrc,&pasrc2,&glen=,&src2=\n         lcla  &n,&l\n         lclc  &s,&c,&r,&srct,&srcl,&src\n         gbla  &$lalen\n         gblc  &$lalenc\n         gblc  &$latype\n&$lalen  seta  0\n&$lalenc setc ''\n.* select source\n         aif   (k'&psrc   gt 0).setsrc1\n         aif   (k'&pasrc  gt 0).setsrc2\n         aif   (k'&pasrc2 gt 0).setsrc3\n         aif   (k'&src2   gt 0).setsrc4\n         mnote  8,'** $LA mising source'\n.setsrc1 anop\n&src     setc  '&psrc'\n         ago   .setsrcn\n.setsrc2 anop\n&src     setc  '&pasrc'\n         ago   .setsrcn\n.setsrc3 anop\n&src     setc  '&pasrc2'\n         ago   .setsrcn\n.setsrc4 anop\n&src     setc  '&src2'\n.setsrcn anop\n.*\n&s       setc  Upper('&src')\n         aif   ('&s   '(1,3) eq 'L''''').litlen\n&srct    setc  t'&src\n&srcl    setc  Lower('&src')\n.* mnote *,'type &srct'\n.*-\n.* what kind of 1st operand do we have?\n.*-\n         aif   (k'&src gt 0).cp1\n         mnote 8,'src operand missing'\n         mexit\n.cp1     aif   ('&src '(2,1) eq '.').load\n         aif   ('&src' eq '0').clr          clear register\n         aif   ('&src'(1,1) eq '(').reg     register\n         aif   ('&src'(1,1) eq '''').txt    text\n         aif   ('&srct' eq 'N').num        number\n         ago   .lbl\n.*- src is 0, means clear reg\n.clr     anop  ,\n&$latype setc  'CLR'\n&mlbl    slr   &reg,&reg\n         mexit\n.*- src is a number\n.num     anop  ,\n&$latype setc  'NUM'\n&mlbl    lgfi  &reg,&src\n&$lalen  seta  &src\n         mexit\n.*- src is a label or address\n.lbl     anop  ,                           label\n&$latype setc  'LBL'\n&mlbl    la    &reg,&src\n&$lalenc setc  'l''&src'\n&c       setc  t'&src\n         aif   ('&c' ne 'A').setl0\n&n       seta  l'&src\n&$lalen  seta  &n\n         mexit\n.*- src is a register\n.reg     anop  ,                           register\n&$latype setc  'REG'\n&n       seta  (k'&src)-2\n&s       setc  '&src'(2,&n)\n&mlbl    lr    &reg,&s\n&$lalen  seta  1                            default\n         mexit\n.*- src is text\n.txt     anop  ,\n&$latype setc  'TXT'\n&s       setc  '=c&src'\n&mlbl    la    &reg,&s\n&n       seta  (k'&src)-2\n&$lalen  seta  &n\n&$lalenc setc  '&n'\n         mexit\n.*- load from storage\n.load    anop  ,\n.* mnote *,'load'\n&c       setc  Upper('&srcl'(1,1))\n&n       seta  (k'&src)-2\n&s       setc  '&src'(3,&n)\n&$latype setc  'LFS'\n&$lalen  seta  0\n         aif   ('&c' eq 'F' or '&c' eq 'A').loadf\n         aif   ('&c' eq 'H').loadh\n         aif   ('&c' eq 'B').loadb\n         mnote 8,*** invalid load parm &c'\n         mexit\n.loadf   anop  ,\n&mlbl    l     &reg,&s                     load from fullword\n         mexit\n.loadh   anop  ,\n&mlbl    lh    &reg,&s                     load from halfword\n         mexit\n.loadb   anop  ,\n&mlbl    sr    &reg,&reg\n         ic    &reg,&s                     load from byte\n         mexit\n*-\n.litlen  anop\n&n       seta  (k'&src)-4\n&$lalen  seta  &n\n         la    &reg,&n                     length of literal\n         mexit\n*-\n.setl0   anop\n&$lalen  seta  0\n.x       Mend\n*/ ADD NAME=REXXMACS\n.*-\n.* REXXMACS - Interface macros for REXX\n.*-\n.* This is assembler copybook, use as follows:\n.*         Print off\n.*         Copy RexxMacs\n.*         Print on\n.*-\n.* Sample\n.*       ereg  0,1\n.*       RxInit parmlist=((prm1,8),(prm2,8),(prm3,8))\n.*       ltr   r0,r0\n.*       jnz   *not REXX*\n.*       RxSay Welcomemsg,l'Welcomemsg\n.*       mvc   rc,=c'04'\n.*       RxRetval rc,l'rc\n.*       . . .\n.*       RexxMacs ds\n.*  rc   dc    c'00'\n.*       . . .\n.*       RexxMacs dsect\n.*-\n.* History\n.* 2017-09-28   enhance parm handling for RXSAY\n.* 2018-06-16   new macro RXSTACK\n.*              new macro REXXMACSMODS\n.* 2018-10-29   small fix to RXINIT test for REXX\n.* 2019-06-17   add TDL=reg to RxVNext stats\n.* 2019-09-01   add 1 as default 2nd parm for RXINIT PARMVECT\n.* 2019-09-12   new internal macro RXLA, change all '$LA' to 'RXLA'\n.* 2019-10-03   fix default data length in RXVACC\n.* 2019-10-25   fix RXSAY literal length\n.*-\n\n         Macro\n.*-\n.* RxInit - initialise interface\n.*\n.* Parameters\n.*\n.*  first positional\n.*   DS               Generate data section\n.*   DSECT            Generate data- and dummy sections\n.*   null             Generate standard initialization\n.*  keywords\n.*   PARMAREA=address Copy 1st or only parm to 'address'. R15 will\n.*                    retain length of the data copied.\n.*   PARMLIST=addr1,..,adrn  Copy arguments to local storage with\n.*                    length prefix. Each addrx must include a field\n.*                    length if not implied like (address,length).\n.*                    'length' may be a value, (register), f.addr or\n.*                    A for storing the address instead of the value.\n.*                    For each argument a structure is build:\n.*                      arg1_fs ds x  field length\n.*                      arg1_ds ds x  data length\n.*                      arg1    ds c  data\n.*                    Samples\n.*                      RxInit parmlist=string,pattern\n.*                      RxInit parmlist=((string,A),(pattern,A))\n.*   PARMVECT=(addr,count)   Copy argument address ad length as\n.*                    fullword pairs.\n.*                    Sample\n.*                         RxInit parmvect=(pl,4)\n.*                         lm    r2,r3,pl   addr,length of 1st parm\n.*                         lm    r4,r5,pl+8 addr,length of 2nd parm\n.*                      pl  dc  (4*2)a(0)\n.*\n.*   NOPARM=address   Jump to 'address' it no parameter is supplied.\n.*   NOREXX=address   Jump to 'address' it no REXX environment is\n.*   DS=N             Do not generate internal data section. Assume\n.*                    that a RXINIT DS, a RXINIT DSECT and a RXVACC PL\n.*                    are done elsewhere.\n.*-\n         RxInit &parmlist=,&parmarea=,&norexx=,&noparm=,&parmvect=\n         gbla  &RXPIC\n         gblc  &RXPIN(20),&RXPIL(20)\n         lclc  &q,&l,&s,&wl,&name,&len,&pa,&pl,&norexxa\n         lcla  &n,&p,&ofs,&fl\n&l       setc  'rxi&sysndx'\n&norexxa setc  '&norexx'\n         aif   (k'&norexx gt 0).nrx1n\n&norexxa setc  '&l.n'\n.nrx1n   anop\n&l.a     cnop  0,4\n         xc    zrx_area(zrx_areal),zrx_area\n.* note that r0 and r1 must contain the original values.\n.* data block must be generated using RxInit DB macro call.\n         stm   r0,r1,zrx_r0            save entry r0,r1\n* test for REXX envblock\n         lr    r14,r0                  -> envblock (hopefully)\n         clc   &l.eb,0(r14)\n         je    &l.b\n         xc    zrx_r0,zrx_r0\n         j     &norexxa                no REXX\n&l.eb    dc    cl8'ENVBLOCK'\n&l.b     equ   *\n* end test\n         using efpl,r1                 point to parmlist\n         mvc   zrx_ebp,efpleval        -> evaluation block pointer\n         drop  r1\n.*\n         RxComBlk init                 GET/PUT comblk\n.*\n         lr    r15,r0\n* get interface routine addresses\n         using envblock,r15\n         l     r15,envblock_irxexte    rexx vector of external entries\n         using irxexte,r15\n         mvc   zrx_coma,irxexcom       address of module irxexcom\n         mvc   zrx_SayA,irxsay         address of module irxsay\n         drop  r15\n         aif   (k'&parmlist gt 0).prminit\n         aif   (k'&parmvect gt 0).prmvect\n         aif   (k'&parmarea gt 0).prmarea\n&l.n     l     r0,zrx_r0               nz if REXX, z if not REXX\n         Mexit\n.* Copy parm to area\n.prmarea anop\n         l     r2,zrx_r1               old r1\n         using efpl,r2                 point to parmlist\n         l     r2,efplarg              -> arguments table\n         drop  r2\n         ltr   r2,r2                   test no\n         jz    &l.n                      input\n         cli   0(r2),x'FF'             end of source list?\n         lm    r14,r15,0(r2)           source address and length\n         ltr   r15,r15                 zero length?\n         jnz   &l.c                    ok, go copy\n         sr    r15,r15                 just in case\n         j     &l.n\n&l.c     bctr  r15,0                   mch length\n         mvc   &parmarea.(*-*),0(r14)\n         ex    r15,*-6\n         la    r15,1(,r15)             reinstate length\n&l.n     l     r0,zrx_r0               nz if REXX, z if not REXX\n         Mexit\n.*\n.* Get positional parameters\n.*\n.PrmInit Anop\n.*\n*- init parameter address list --------------------------------\n.*\n         aif   (n'&parmlist eq 0).noparm\n&RXPIC   seta  n'&parmlist\n&n       seta  1\n&ofs     seta  0\n         la    r1,zrx_parmarea\n.prmi010 anop\n&name    setc  '&parmlist(&n,1)'\n         la    r14,&name._fs\n         st    r14,&ofs.(,r1)\n&ofs     seta  &ofs+4\n&len     setc  '&parmlist(&n,2)'\n&RXPIN(&n) setc  '&name'\n&RXPIL(&n) setc  '&len'\n         aif   ('&len' ne 'A').prmi110\n         xc    &name._fs(10),&name._fs\n         ago   .prmi200\n.prmi110 anop\n         mvi   &name._fs,&len\n         mvi   &name._ds,0\n         mvi   &name,c' '\n         aif   ('&len' eq '1').prmi200\n         mvc   &name.+1(&len-1),&name\n.prmi200 anop\n&n       seta  &n+1\n         aif   (&n le n'&parmlist).prmi010\n&ofs     seta  &ofs-4\n         oi    &ofs.(r1),x'80'\n.*\n*- obtain parameters ------------------------------------------\n.*\n.PrmGet  Anop\n         l     r2,zrx_r1               old r1\n         using efpl,r2                 point to parmlist\n         l     r2,efplarg              -> arguments table\n         drop  r2\n         la    r3,zrx_parmarea\n         ltr   r2,r2                   test no\n         jz    &l.n0                     input\n&l.1     equ   *\n         cli   0(r2),x'FF'             end of source list?\n         je    &l.n0\n         l     r1,0(,r3)               output area\n         la    r1,0(,r1)               clear vl bit\n         lm    r14,r15,0(r2)           source address and length\n         ltr   r14,r14                 check zero address\n         jz    &l.3                    then go get next\n         ltr   r15,r15                 zero length\n         jz    &l.3                    then go get next\n.* r1 -> al1(field length,data length),c'data'\n         ic    r1,0(,r1)               load target field length\n         sll   r1,24                   drop upper\n         srl   r1,24                     3 bytes\n.* store address/length pair\n         ltr   r1,r1                   field len=0 => store addresses\n         jnz   &l.2\n         l     r1,0(,r3)               output area\n         la    r1,0(,r1)               clear vl bit\n         stm   r14,r15,2(r1)\n         mvi   1(r1),8                 set data length\n         j     &l.3\n.* get text data\n&l.2     cr    r15,r1\n         bnh   *+6\n         lr    r15,r1                  reset to max\n         l     r1,0(,r3)               output area\n         stc   r15,1(,r1)              save data length\n         bctr  r15,0\n         mvc   2(*-*,r1),0(r14)\n         ex    r15,*-6\n&l.3     tm    0(r3),x'80'             end of target list?\n         jo    &l.n0                   yes\n.*       jo    &l.n4                   not so good\n         la    r2,8(,r2)\n         la    r3,4(,r3)\n         j     &l.1\n&l.n0    sr    r15,r15\n         j     &l.n\n&l.n4    la    r15,4\n&l.n     l     r0,zrx_r0               nz if REXX, z if not REXX\n         Mexit\n.*\n.* Copy parameter address / length pairs\n.*\n.PrmVect Anop\n         l     r1,zrx_r1               old r1\n         using efpl,r1                 point to parmlist\n         l     r1,efplarg              -> arguments table\n         drop  r1\n         RxLa  r14,&parmvect(1)        -> output area\n         RxLa  r15,&parmvect(2),1      max number of pairs\n&l.pv1   tm    0(r1),x'80'             end of source list?\n         jo    &l.pv0\n         mvc   0(8,r14),0(r1)          copy address and length\n         la    r1,8(,r1)\n         la    r14,8(,r14)\n         bct   r15,&l.pv1              get next\n         la    r15,1                   set 'overflow'\n         j     &l.n\n&l.pv0   sr    r15,r15\n&l.n     l     r0,zrx_r0               nz if REXX, z if not REXX\n.*-\n.noparm  anop\n.x       Mend\n\n*--------------------------------------------------------------\n\n         Macro\n.*-\n.* Comm-block for VGET / VPUT\n.* Internal macro called by RXINIT and REXXMACS respectively\n.*-\n         RxComBlk &what,&stat,&prefix=zrx_\n         lclc  &pf,&s\n&pf      setc  '&prefix'\n&s       setc  Upper('&what')\n         aif   ('&s' eq 'DS' or k'&what eq 0).ds\n         aif   ('&s' eq 'DSECT').dsect\n         aif   ('&s' eq 'INIT').init\n         aif   ('&s' eq 'TEST').test\n         mnote 'RXCOMBLK Invalid call: &s'\n         mexit\n.init    anop\n* init VGET / VPUT comblk begin\n         la    r14,=cl8'IRXEXCOM'\n         st    r14,&pf.ComBlkp1\n         la    r14,=a(0)\n         st    r14,&pf.ComBlkp2\n         st    r14,&pf.ComBlkp3\n         st    r14,&pf.ComBlkp5\n         la    r14,&pf.ShVb\n         st    r14,&pf.ComBlkp4\n         la    r14,&pf.XComRc\n         st    r14,&pf.ComBlkp6\n         oi    &pf.ComBlkP6,x'80'\n* init VGET / VPUT comblk end\n         Mexit\n.dsect   anop\nRxComBlK DSECT\n.ds      anop\n&pf.ComBlk   ds    0x\n&pf.ComBlkp1 ds    a                   -> EXCOM eyecatcher\n&pf.ComBlkp2 ds    a                   Reserved\n&pf.ComBlkp3 ds    a                   Reserved\n&pf.ComBlkp4 ds    a                   -> 1st SVHB\n&pf.ComBlkp5 ds    a                   -> Env-block or zero\n&pf.ComBlkp6 ds    a                   -> Return code field\n*-\n&pf.XComRc   ds    a\n&pf.StAdjCnt ds    a                   storage adjustment count\n&pf.NextCnt  ds    a                   'next' counter\n*-\n&pf.ShVb     ds    0d\n&pf.ShVbNext ds    a                   -> next  ShVb\n&pf.ShVUser  ds    f                   Used by 'next' function\n&pf.ShVCode  ds    0c                  F=Fetch, S=Set (put)\n&pf.ShVbFunc ds    c                   F=Fetch, S=Set (put)\n&pf.ShVRet   ds    0x                  Return code area\n&pf.ShVbRc   ds    x                   Return code area\n&pf.last     equ   x'02'               'last-var' flag\n&pf.trunc    equ   x'04'               'truncated' flag\n             ds    h                   Reserved\n&pf.ShVbFbl  ds    a                   Length of fetch buffer\n&pf.ShVbVna  ds    a                   -> variable name\n&pf.ShVbVnl  ds    a                   length of variable name\n&pf.ShVbVba  ds    a                   -> value buffer\n&pf.ShVbVbl  ds    a                   Length of fetched value\n&pf.namea    equ   &pf.ShVbVna,4\n&pf.namel    equ   &pf.ShVbVnl,4\n&pf.dataa    equ   &pf.ShVbVba,4\n&pf.datal    equ   &pf.ShVbVbl,4\n&pf.ShVbl    equ   *-&pf.ShVb\n&pf.ComBlkl  equ   *-&pf.ComBlk\n.* names from the manual\n&pf.ShvBufl  equ   &pf.ShVbFbl,4\n&pf.ShvNama  equ   &pf.ShVbVna,4\n&pf.ShvNaml  equ   &pf.ShVbVnl,4\n&pf.ShvVala  equ   &pf.ShVbVba,4\n&pf.ShvVall  equ   &pf.ShVbVbl,4\n         Mexit\n.TEST    anop\n.* Test return code flags stored in SHVRET:\n.*  SHVCLEAN EQU X'00' Execution was OK\n.*  SHVNEWV  EQU X'01' Variable did not exist\n.*  SHVLVAR  EQU X'02' Last variable transferred (for \"N\")\n.*  SHVTRUNC EQU X'04' Truncation occurred during \"Fetch\"\n.*  SHVBADN  EQU X'08' Invalid variable name\n.*  SHVBADV  EQU X'10' Value too long\n.*  SHVBADF  EQU X'80' Invalid function code (SHVCODE)\n.* Special flags: LAST\n&s       setc  Upper('&stat')\n         aif   ('&s' ne 'EOF').test999\n         tm    &prefix.SHVRET,SHVLVAR  last??\n         mexit\n.test999 tm    &prefix.SHVRET,&s\n         mexit\n.x       Mend\n\n*--------------------------------------------------------------\n\n         Macro\n.*-\n.* Generate data areas\n.* Usage:\n.*       RexxMacs dsect\n.*-\n         REXXMACS &what,&comblk=Y,&cbpfx=zrx_\n         lcla  &sln,&n,&l\n         lclc  &sl,&c,&name,&len,&s,&cbp\n         gbla  &RXPIC\n         gblc  &RXPIN(20),&RXPIL(20),&RXCBPFX\n.* select action\n         aif   (k'&what eq 0).defsect\n&s       setc  Upper('&what')\n         aif   ('&s' eq 'DS').DefSect\n         aif   ('&s' eq 'DSECT').DefSect\n         aif   ('&s' eq 'SET').set\n         mnote 8,'** Invalid p1'\n         mexit\n.* set global settings - under construction\n.SET     anop\n         aif   (k'&cbpfx eq 0).cbpfxn\n&rxcbpfx setc  '&cbpfx'\n.cbpfxn  anop\n         mexit\n.*-\n.* Datablock and dummy sects common to the macro seet\n.*-\n.DEFSECT anop\n&sln     seta  &sln+1\n         aif   (&sln gt N'&syslist).x\n&sl      setc  Upper('&syslist(&sln)')\n         aif   ('&sl' eq 'DS').ds\n         aif   ('&sl' eq 'DSECT').dsect\n&sl      setc  'syslist(&sln)'\n         mnote 8,'*** Invalid option: &sl'\n         mexit\n.DS      anop\n*-\n* Data areas for the REXXMACS set\n*-\n*\n*- global area\nzrx_area     ds    0a\nzrx_envba    ds    0a\nzrx_r0       ds    a\nzrx_r1       ds    a\nzrx_Excoma   ds    0a\nzrx_coma     ds    a\nzrx_saya     ds    a\nzrx_EnvBlka  ds    0a\nzrx_ebp      ds    a\nzrx_fw       ds    f\nzrx_dw       ds    0d\nzrx_wrk      ds    6a\nzrx_wrkp1    equ   zrx_wrk,4\nzrx_wrkp2    equ   zrx_wrk+4,4\nzrx_wrkp3    equ   zrx_wrk+8,4\nzrx_wrkp4    equ   zrx_wrk+12,4\nzrx_wrkp5    equ   zrx_wrk+16,4\nzrx_wrkp6    equ   zrx_wrk+20,4\n*-Comm-block\n         aif   ('&comblk' ne 'y' and '&comblk' ne 'Y').comblkn\n             RxComBlk\n.comblkn anop\n*-end of area\nzrx_areal    equ   *-zrx_area\n*- parameter area, &rxpic parameters handled\nzrx_parmarea ds    0a\n         aif   (&RXPIC eq 0).DefSect\n          ds    &RXPIC.a       parm vector\n&n       seta  1\n.parmdef aif   (&n gt &RXPIC).DefSect\n&name    setc  '&RXPIN(&n)'\n&len     setc  '&RXPIL(&n)'\n         aif   ('&len' ne 'A').mpa010\n         ds     0a                    align data\n         ds     h                       on fullword\n&len     setc  '8'                    room for 2 adress fields\n.mpa010  anop\n&name._fs ds    al1\n&name._ds ds    al1\n&name     ds    cl(&len)\n&n       seta  &n+1\n         ago   .parmdef\n*-\n.Dsect   anop\n*-\n* Dsects for the REXXMACS set\n*-\n         Print  nogen\n         Dsect\n         IRXEFPL                      REXX EXTERNAL FUNCTION\n         IRXEVALB                     REXX EVALUATION BLOCK\n         IRXENVB                      REXX ENVIRONMENT BLOCK\n         IRXARGTB DECLARE=YES         REXX ARGUMENT TABLE\n         IRXEXTE\n         IRXSHVB\n         Print  gen\n*-\n         ago   .DefSect\n.X       Mend\n\n         Macro\n.*-\n.* REXX interface macro - terminate with return code\n.* Parms\n.*   EXIT=N      do not terminate program, allow for freemains etc\n.*   RC=         number or (register)\n.*   RCH=address address of halfword containing the rc\n.*   RCF=address address of fullword containing the rc\n.* Default rc=0\n.*-\n&mlbl    RxTerm &rc=,&data=,&exit=Y\n         lclc  &data1,&data2,&l\n&l       setc  'z&sysndx'\n&data1   setc  '&data(1)'\n&data2   setc  '&data(2)'\n&mlbl    cnop  0,4\n         l     r14,zrx_ebp             -> evaluation block pointer\n         l     r14,0(r14)              point to evalblock\n         using evalblock,r14\n         aif   (k'&rc gt 0).rc\n         aif   (k'&data gt 0).data\n&data1   setc  '=c''0000'''\n&data2   setc  '4'\n         ago   .data\n.rc      RxLa  r15,&rc                 rc\n         cvd   r15,evalblock_evdata+8\n         unpk  evalblock_evdata(8),evalblock_evdata+8\n         oi    evalblock_evdata+7,x'F0'\n         mvc   evalblock_evlen,=a(8)\n         ago   .b\n.data    anop\n         la    r2,&data2             length\n         l     r15,EVALBLOCK_EVSIZE   for data size check\n         sll   r15,3                  doublewords to bytes\n         cr    r2,r15\n         jnh   &l.b\n         lr    r2,r15               use max\n&l.b     st    r2,evalblock_evlen   store reply length\n         ltr   r2,r2\n         jz    &l.c\n         bctr  r2,0\n         mvc   evalblock_evdata(*-*),&data1\n         ex    r2,*-6\n&l.c     equ   *\n.b       drop  r14\n&q       setc  Upper('&exit')\n         aif   ('&q' eq 'N').x\n         sr    r15,r15                 caller must use the RC value\n         pr\n.x       Mend\n\n         Macro\n.*-\n.* REXX interface macro - store return value\n.* Parms\n.*   data        address of the data to return\n.*   size        size of the data to return\n.*-\n&mlbl    RxRetVal &data,&size,&wto=N\n         lclc  &l\n&l       setc  'zrx&sysndx'\n&mlbl    cnop  0,4\n         RxLa  r0,&size\n         l     r14,zrx_ebp             -> evironment block pointer\n         l     r14,0(r14)              point to evalblock\n         using evalblock,r14\n         l     r1,evalblock_evsize    for data size check\n         drop  r14\n         sll   r1,3                   doublewords to bytes\n         ahi   r1,-16                 minus header\n         cr    r0,r1                  fits in current buffer ?\n         jnh   &l.c                   yes, go copy\n.*-\n* get a bigger buffer\n.*-\n         aif   ('&wto' ne 'Y').wton\n         wto   'RxRetval expand'\n.wton    anop\n         la    r14,=cl8'GETBLOCK'\n         la    r15,zrx_wrkp5          new evaluation block addr\n         stm   r14,r15,zrx_wrkp1\n         st    r0,zrx_wrkp4           store length\n         la    r14,zrx_wrkp4          -> length\n         st    r14,zrx_wrkp3          save\n         oi    zrx_wrkp3,x'80'        end-of-parm flag\n.*\n         load  EP=IRXRLT\n         lr    r15,r0                 copy module address\n         l     r0,zrx_envba           envbp (optional)\n         la    r1,zrx_wrkp1           -> start of parmlist\n         basr  r14,r15\n         st    r15,zrx_wrkp6          save rc\n.*\n         delete EP=IRXRLT\n         icm   r15,15,zrx_wrkp6       reload rc, test cond\n         jnz   &l.x                   nope\n.*-\n* copy data to buffer\n.*-\n&l.c     l     r14,zrx_ebp             -> evironment block pointer\n         l     r14,0(r14)              point to evalblock\n         using evalblock,r14\n.* just use copy-long, simpler and dont happen that often\n         RxLa  r0,&data\n         RxLa  r1,&size\n         st    r1,evalblock_evlen     store length\n         la    r14,evalblock_evdata\n         drop  r14\n         lr    r15,r1                 copy size\n         mvcl  r14,r0\n         sr    r15,r15\n&l.x     equ   *\n.x       Mend\n\n\n         Macro\n         RxStemName &base=,&stema=,&num=,&pnum=,&clear=n\n.*-\n.* Build a rexx stemname composed by a base, including the dot,\n.* concatenated with the number.\n.*   base=(address,length)\n.*   name=address\n.*   num=binary number\n.*   pnum=packed-decimal number - note must be pl4'n'\n.*   clear=Y   clear varname before build-up\n.* Sample:\n.*     RxStemName base=(stemname,7),stema=varname,num=f.seqnr\n.*-\n         lcla  &n\n         lclc  &base1,&base2\n&base1   setc  '&base(1)'\n&base2   setc  '&base(2)'\n         aif   ('&base1 '(1,1) ne '''').b1litn\n&n       seta  k'&base1-2\n&base2   setc  '&n'\n         ago   .basen\n.b1litn  anop\n         aif   (k'&base2 ne 0).b2nuln\n&n       seta  l'&base1\n&base2   setc  '&n'\n.b2nuln  anop\n.basen   anop\n.*       aif   (n'&base ne 2 or k'&stema eq 0).err1\n         aif   ('&clear' ne 'Y' and '&clear' ne 'y').clrn\n         mvi   &stema,c' '\n         mvc   &stema.+1(l'&stema.-1),&stema\n.clrn    anop\n         RxLa  r14,&base1              addr\n         RxLa  r15,&base2              length\n         bctr  r15,0                   mch length\n         mvc   &stema.(*-*),0(r14)     get stem base\n         ex    r15,*-6\n         RxLa  r14,&stema+1(r15)       -> number area\n         RxStemNum (r14),bin=&num,dec=&pnum\n         RxLa  r14,&base2              stem base length\n         ar    r15,r14                 plus number length\n         lr    r0,r15                  copy length\n         mexit\n.err1    mnote 8,'**STEMNAME Missing base or name'\n         Mend\n\n         Macro\n.*-\n.* Build a rexx stemnumber\n.* Parameters\n.*   addr      build-up area, must be large enough to hold the result\n.*   bin       value, (reg) or f.addr\n.*   dec       value address\n.* Samples\n.*         RxStemNum value,bin=f.xval\n.*         lr    r2,r15        copy length\n.*         RxStemNum value,dec=pval\n.*         lr    r2,r15        copy length\n.*  value  dc    cl8' '\n.*  xval   dc    a(123)\n.*  pval   dc    p'456'\n.*-\n         RxStemNum &addr,&dec=,&bin=\n         lclc  &l\n&l       setc  'R&sysndx'\n         mvc   40(8,r13),=x'4020202020202020'\n         aif   (k'&bin eq 0 and k'&dec eq 0).err1\n         aif   (k'&dec gt 0).dec\n         RxLa  r15,&bin                seqnr\n         cvd   r15,24(r13)\n         edmk  40(8,r13),28(r13)       unpack\n         ago   .nlen\n.dec     edmk  40(8,r13),&dec          unpack\n.nlen    anop\n         bnz   &l.cl                   nonzero value\n         la    r1,=c'0'                -> c'0'\n         sr    r15,r15                 mchlen=0\n         b     &l.m\n.* r1 -> 1st non-zero byte\n&l.cl    la    r15,48(,r13)            calc\n         sr    r15,r1                    length\n         bctr  r15,0                   mch length\n&l.M     RxLa  r14,&addr               -> target area\n         mvc   0(*-*,r14),0(r1)        append seq number\n         ex    r15,*-6\n         la    r15,1(,r15)             reinstate length\n         mexit\n.err1    mnote 8,'**STEMNUM Missing number parm'\n         Mend\n\n         Macro\n.*-\n.* Say\n.*\n.* Parameters\n.*   1  address    label, (reg) or 'literal'\n.*   2  length     value, (reg) or null if address is literal\n.*\n.* sets up 5 fullword work area\n.*   1  -> 'WRITE'\n.*   2  -> address of dataaddress field\n.*   3  -> address of length field\n.*   4  dataaddress field\n.*   5  length field\n.*-\n&mlbl    RXSAY &adr,&len,&wrk=zrx_wrk\n         gblc  &rxlalen\n&mlbl    la    r14,=cl8'WRITE'         -> operation\n         rxla  r15,&adr                -> data\n         rxla  r0,&len,&rxlalen,l'&adr length\n         stm   r15,r0,&wrk+12\n         la    r15,&wrk+12\n         la    r0,&wrk+16\n         stm   r14,r0,&wrk\n         oi    &wrk+8,x'80'            set end of list\n         sr    r0,r0\n         La    R1,&wrk\n         L     R15,zrx_SayA            address of module\n         Basr  R14,R15\n         Mend\n\n         MACRO\n.*-\n.* REXX get or put variable\n.*\n.* Can be used directly, but should really be used through the\n.* RXVGET, RXVPUT and RXSTEMPUT macros.\n.*\n.* Required dsects: IRXENVB IRXEXTE\n.* you must use the PL expansion for either GET or PUT\n.* The INIT call is done in RXINIT.\n.*\n.* Parameters, see the RXVGET, RXVPUT and RXVNECT macros later.\n.*\n.* Sample:\n.*           RxVacc init,enva=zrx_envba,pl=vapl\n.*\n.*           RxVacc get,name=('TESTVAR1',8),data=(value,l'value)\n.*           l     r2,vaplShVbVbl       actual data length\n.*\n.*           mvlit value,'finally weekend'\n.*           la    r2,15\n.*           RxVacc put,name=('TESTVAR1',8),data=(value,(r2))\n.*\n.*  vapl     RxVacc pl\n.*  value    dc    cl100' '\n.*-\n&mlbl    RXVACC &what,&name=,&data=,&envptr=,&st=,&sth=,&src=,         c\n               &reg=r14,&enva=zrx_envba,&comblk=zrx_\n         lclc  &que,&lbl,&c,&lsrc,&lpl,&l,&s,&cb\n         lcla  &m,&n,&i,&ln,&p\n         gblc  &rxlalen\n&l       setc  'z&sysndx'\n&cb      setc  '&comblk'\n&que     setc  Upper('&what')\n&lbl     setc  'RXV&sysndx'\n&mlbl    ds    0h\n         aif   ('&que' eq 'GET').get\n         aif   ('&que' eq 'PUT').put\n         aif   ('&que' eq 'NEXT').next\n         aif   ('&que' eq 'RESET').reset\n         Mnote 8,'*** invalid parm: &what'\n         Mexit\n.*-get\n.Get     Anop\n         mvi   &cb.ShVbFunc,C'F'           fetch\n         ago   .call\n.*-getnext prep\n.Next    Anop\n         mvi   &cb.ShVbFunc,C'N'           fetch\n         ago   .call\n.*-put\n.Put     Anop\n         mvi   &cb.ShVbFunc,C'S'           set\n.call    Anop\n         aif   (k'&data(1) eq 0).call2     no data\n*setup for data\n         RxLa  r14,&data(1)\n         RxLa  r15,&data(2),&rxlalen\n         stm   r14,r15,&cb.ShVbVba\n         st    r15,&cb.ShVbFbl\n.call2   anop\n*setup for name\n&s       setc  Upper('&name(1)')           ensure literal is ucase\n         RxLa  r14,&s\n         aif   ('&name(1) '(1,1) eq '''' and k'&name(2) eq 0).call2nl\n         RxLa  r15,&name(2),l'&name(1)\n         ago   .call2nn\n.call2nl anop\n&n       seta  k'&name(1)-2\n         la    r15,&n\n.call2nn anop\n         stm   r14,r15,&cb.ShVbVna\n*setup for call\n         mvc   &cb.ShVUser,&cb.ShVbVnl for 'next'\n         l     r15,zrx_coma                address of module irxexcom\n         l     r0,zrx_envba\n         la    r1,&cb.Comblk\n         Basr  r14,r15\n.* load data- and name length\n         l     r0,&cb.ShVbVbl\n         l     r1,&cb.ShVbVnl\n.*-getnext post, check for end of list\n         aif   ('&que' ne 'NEXT').X\n         if    (tm,&cb.SHVRET,SHVLVAR,o)     end of list set\n           la    r15,1\n         endif\n         if    (tm,&cb.SHVRET,SHVTRUNC,o)    truncation occurred\n           la    r15,2\n         endif\n         ltr    r15,r15                      set cc\n         Mexit\n.* reset the interface block\n.RESET   Anop\n         xc    &comblk.ShVb(&comblk.ShVbl),&comblk.ShVb\n         xc    &comblk.StAdjCnt,&comblk.StAdjCnt\n         xc    &comblk.NextCnt,&comblk.NextCnt\n         Mexit\n.*\n.x       MEND\n\n         Macro\n.*-\n.* Get a REXX variable to local storage\n.*\n.* Parameters;\n.*   DATA=(address,length)  Address is the address of the buffer which\n.*                          will receive the data.\n.*                          Length is the length of the buffer\n.*   NAME=(address,length)  Address is the variable name.\n.*                          The name may a literal in quotes.\n.*                          Length will default to the length of a\n.*                          literal of the generated length of a field.\n.*                          Note, the name in a field must be in ucase,\n.*                          a literal is ucased internally.\n.*   STOR=length            Size of dynamic data area. The area will be\n.*                          automatically reallocated if too small. You\n.*                          must use the STOR=DROP option when finished\n.*                          to release the storage.\n.*\n.*   address can be a label or a (register).\n.*   length can be a numbeer or a (register).\n.*\n.* Registers after call\n.* r15  return code\n.* r0   data length\n.*\n.* Sample\n.*   RxVGet name='TESTVAR1',data=(value,(r2))\n.*   RxVGet name=(varname,(r3)),data=(value,(r2))\n.*   RxVGet name='longvar',stor=200\n.*   lr    r2,r0         copy data length\n.*   RxVGet stor=drop\n.*-\n&mlbl    RXvGet &name=,&data=,&comblk=zrx_,&stor=,&acc=GET\n         lclc  &l,&q,&ac\n&l       setc  'RG&sysndx'\n&q       setc  Upper('&syslist(1)')\n&ac      setc  Upper('&acc')\n         aif   ('&q' eq 'RESET').reset\n         aif   (k'&stor ne 0).stor\n&mlbl    RxVacc &acc,name=&name,data=&data,comblk=&comblk\n         Mexit\n.* reset the interface block\n.RESET   Anop\n         xc    &comblk.ShVb(&comblk.ShVbl),&comblk.ShVb\n         xc    &comblk.stadjcnt,&comblk.stadjcnt\n         xc    &comblk.nextcnt,&comblk.nextcnt\n         Mexit\n.* use dynamic storage for data area\n.STOR    Anop\n&q       setc  Upper('&stor')\n         aif   ('&q' eq 'DROP').stordrp\n         RxLa  r14,&stor\n&l.cs    c     r14,&comblk.ShVbFbl\n         jnh   &l.cl                   ok, go call\n*-freemain\n         l     r0,&comblk.ShVbFbl      size\n         icm   r1,15,&comblk.ShVbVba   if null address\n         jz    &l.gm                   then no previous storage\n         Freemain R,lv=(0),a=(1)\n*-getmain\n&l.gm    st    r14,&comblk.ShVbFbl     save as buffer length\n         Getmain R,lv=(14),loc=31\n         st    r1,&comblk.ShVbVba      save address\n*-call\n&l.cl    xc    &comblk.ShVbVbl,&comblk.ShVbVbl\n         RxVacc &acc,name=&name,comblk=&comblk\n         tm    &comblk.ShVRet,SHVTRUNC\n         jz    &l.sl\n         l     r14,&comblk.stadjcnt\n         la    r14,1(,r14)\n         st    r14,&comblk.stadjcnt\n         l     r14,&comblk.ShVbVbl\n         j     &l.cs\n&l.sl    l     r0,&comblk.ShVbVbl      size of retrieved\n         l     r1,&comblk.ShVbVba      addr of retrieved\n         Mexit\n.STORDRP Anop\n         l     r0,&comblk.ShVbFbl      size\n         l     r1,&comblk.ShVbVba      address\n         Freemain R,lv=(0),a=(1)\n         Mexit\n.x       MEND\n\n         Macro\n.*-\n.* Create or update a REXX variable from local storage\n.*\n.* Parameters;\n.*   DATA and NAME same as for the RxVGet macro.\n.*\n.* Registers after call\n.* r15  return code\n.*\n.* Sample\n.*   RxVPut name=('TESTVAR1',8),data=(value,(r2))\n.*-\n&mlbl    RXvPut &name=,&data=,&comblk=zrx_\n.* bl    RxVacc put,name=(&name(1),&name(2)),data=(&data(1),&data(2)),\n&mlbl    RxVacc put,name=&name,data=&data,comblk=&comblk\n.x       MEND\n\n         Macro\n.*-\n.* Retrieve all REXX variable from current environment, or information\n.* about variables.\n.*\n.* Parameters;\n.*   DATA and NAME same as for the RxVGet macro.\n.*  If p1 = 'STATS' then the following parameters are used:\n.*   NL     register to receive name length\n.*   DL     register to receive data length\n.*   TDL    register to add data length (must be 0 before first call).\n.*   COUNT  register to hold count\n.*\n.* Both the NAME and the DATA fields will be filled in by the function.\n.*\n.* Registers after call\n.* r15  return code\n.*      special code 1 means that the variable retrieved is the last.\n.*      special code 2 means that the name or the data was truncated.\n.* r0   data length\n.* r1   name length\n.*\n.* Sample\n.*   RxVNext name=(namebfr,l'namebfr),data=(databfr,l'databfr)\n.*   lr    r2,r0         copy data length\n.*   lr    r3,r1         copy name length\n.*-\n&mlbl    RxVNext &name=,&data=,&nl=,&dl=,&tdl=,&count=,                c\n               &comblk=zrx_\n         lclc  &l,&q\n&l       setc  'RN&sysndx'\n&q       setc  Upper('&syslist(1)')\n         aif   ('&q' eq 'STATS').stats\n&mlbl    RxVacc next,name=&name,data=&data,comblk=&comblk\n         mexit\n.STATS   ANOP\n&mlbl    RxVacc reset\n         sr    &nl,&nl                 name length\n         sr    &dl,&dl                 data length\n         sr    &count,&count           count\n&l.a     RxVacc next,name=(0,0),data=(0,0)\n         tm    zrx_SHVRET,SHVLVAR\n         jo    &l.x\n         cr    r1,&nl\n         jnh   *+6\n         lr    &nl,r1\n         cr    r0,&dl\n         jnh   *+6\n         lr    &dl,r0\n         aif   (k'&tdl eq 0).count\n         ar    &tdl,r0\n.count   la    &count,1(,&count)\n         j     &l.a\n&l.x     RxVacc reset\n         mexit\n.x       MEND\n\n         Macro\n.*-\n.* Read or write a stemvar, combining the basename and the number.\n.* Parameters are a combination of those for RXSTEMNAME\n.* and RXVGET/VPUT\n.*-\n         RxStemAcc &name=,&stema=,&base=,&num=,&pnum=,&data=,          c\n               &comblk=zrx_,&acc=???,&namelenr=r1\n         lclc  &vn\n&vn      setc  '&name'\n         aif   (k'&name ne 0).vnok\n&vn      setc  '&stema'\n.vnok    anop\n mnote *,'-RxStemname'\n         RxStemname stema=&vn,base=&base,num=&num,pnum=&pnum\n         lr    &namelenr,r15\n mnote *,'-RxV&acc'\n         RxV&acc name=(&vn,(&namelenr)),data=&data,&comblk=&comblk\n         Mend\n\n         Macro\n         RxStemGet &name=,&stema=,&base=,&num=,&pnum=,&data=,          c\n               &comblk=zrx_\n.* call common access macro\n         RxStemAcc acc=GET,name=&name,stema=&stema,                    c\n               base=&base,num=&num,pnum=&pnum,data=&data,comblk=&comblk\n         Mend\n\n         Macro\n         RxStemPut &name=,&stema=,&base=,&num=,&pnum=,&data=,          c\n               &comblk=zrx_,&namelenr=r1\n.* call common access macro\n         RxStemAcc acc=PUT,name=&name,stema=&stema,                    c\n               namelenr=&namelenr,                                     c\n               base=&base,num=&num,pnum=&pnum,data=&data,comblk=&comblk\n         Mend\n\n         Macro\n.*-\n.* Acces the REXX data stack\n.*\n.* Parameters;\n.*   what  function - PUSH, QUEUE, QUEUED ...\n.*   data  address or (address,length) for functions PULL, QUEUE,\n.*         PUSH and QUEUED. Must be a fullword if QUEUED.\n.*\n.* Registers after call\n.* r15  return code\n.* r0   data length if function is PULL\n.* r1   data address if function is PULL\n.*      value if function is QUEUED\n.*\n.* Sample\n.*   RxStack pull,data=buffer\n.*   RxStack queued\n.*-\n         RxStack &what,&data=,&mode=,&wrka=,&lenreg=\n         lclc  &que,&l,&s\n&func    setc  Upper('&what')\n&l       setc  'zrx&sysndx'\n         la    r14,=cl8'&func'         function\n&s       setc  Upper('&mode')\n         aif   ('&mode' eq 'CALL').call\n         xc    zrx_datal,zrx_datal\n         xc    zrx_xComRc,zrx_xComRc\n         aif   ('&func' ne 'QUEUE' and '&func' ne 'PUSH').quefn\n         aif   (n'&data eq 0).datafn\n         RxLa  r15,&data(1),0\n         st    r15,zrx_dataa           address of data\n         RxLa  r15,&data(2),l'&data,0\n         st    r15,zrx_datal           save data length\n.datafn  anop\n.quefn   anop\n         la    r15,zrx_dataa           address of data returned\n         la    r0,zrx_datal            length of data returned\n         la    r1,zrx_xComRc           value returned by irxstk\n         stm   r14,r1,zrx_wrk\n         oi    zrx_wrk+12,x'80'        set VL bit\n         l     r15,zrx_envba\n         l     r15,envblock_irxexte-envblock(,r15) a(irxexte)\n         l     r15,irxstk-irxexte(,r15) stack manager\n         la    r1,zrx_wrk              parm list\n         basr  r14,r15                 call irxstk\n         aif   ('&func' eq 'PULL').pullbe\n         aif   ('&func' eq 'QUEUED').quedbe\n         ago   .other\n.quedbe  anop                          QUEUED back end\n         l     r1,zrx_xComRc           value\n         aif   (k'&data eq 0).quedb2\n         st    r1,&data\n.quedb2  ltr   r15,r15                 set rc\n         mexit\n.pullbe  anop                          PULL back end\n         ltr   r15,r15                 test rc\n         aif   (n'&data eq 0).pullb2\n         jnz   &l.b2                   exit if bad rc\n         StrCopy  from=(f.zrx_dataa,f.zrx_datal),                      c\n               to=(&data(1),&data(2)),lenreg=&lenreg\n         sr    r15,r15\n         ltr   r15,r15\n&l.b2    equ   *\n         mexit\n.pullb2  anop                          PULL back end\n         l     r0,zrx_datal\n         l     r1,zrx_dataa\n         mexit\n.other   ltr   r15,r15\n         ago   .x\n.*- call\n         l     r15,zrx_envba\n         RxLa  r0,&data(1)\n         RxLa  r1,&data(2),l'&data(1)\n         stm   r14,r1,zrx_wrk\n         RxLa  r1,&wrka,0\n         st    r1,zrx_wrk+16\n         la    r1,zrx_wrk\n         Call  ZRXSTACK\n         ltr   r15,r15\n.*- end\n.x       anop\n&l.x     equ   *\n         Mend\n\n         Macro\n*-\n* ZRXSTACK - stack interface\n* At entry\n*  r1 -> ZRXSTACK_prm\n* At exit\n*  r15  0  all ok, though the string may have been truncated\n*      >0  return code from IRXSTK\n*-\n         RexxMacsMods\n         using ZRXSTACK,r12\n         using ZRXSTACK_PRM,r9\n         using ZRXSTACK_WRK,r10\n*-\n*  initialize module\n*-\nZRXSTACK Csect\n         save  (14,12)\n         lr    r12,r15\n         lr    r9,r1\n         icm   r10,r15,ZRXSTACK_prmwa\n         jnz   ZRXSTACK_ini1n\n         Getmain R,lv=ZRXSTACK_wrkl,loc=31\n         lr    r10,r1\nZRXSTACK_ini1n equ   *\n         la    r14,ZRXSTACK_sa1\n         st    r14,8(,r13)\n         st    r13,4(,r14)\n         lr    r13,r14\n         xc    ZRXSTACK_pl(ZRXSTACK_wrkn-ZRXSTACK_pl),ZRXSTACK_pl\n*-\n*  setup and call service\n*-\n         l     r14,ZRXSTACK_prmfa      -> function\n         la    r15,ZRXSTACK_dataa      address of data returned\n         la    r0,ZRXSTACK_datal       length of data returned\n         la    r1,ZRXSTACK_val         value returned by irxstk\n         stm   r14,r1,ZRXSTACK_pl\n         oi    ZRXSTACK_pl+12,x'80'    set VL bit\n         l     r15,ZRXSTACK_prmea\n         l     r15,envblock_irxexte-envblock(,r15) a(irxexte)\n         l     r15,irxstk-irxexte(,r15) stack manager\n         la    r1,ZRXSTACK_pl          parm list\n         l     r0,ZRXSTACK_prmea\n         basr  r14,r15                 call irxstk\n         ltr   r15,r15                 quit now\n         jnz   ZRXSTACK_rtn              if bad rc\n         l     r2,ZRXSTACK_prmfa       -> function\n*be aware of special cases\n         clc   =c'QUEUED',0(r2)        special case 'queued'\n         je    ZRXSTACK_qed\n         j     ZRXSTACK_norm\n*-\n*  handle special case QUEUED\n*-\nZRXSTACK_qed   equ *\n         l     r2,ZRXSTACK_prmda       address of data returned\n         mvc   0(4,r2),ZRXSTACK_val\n         j     ZRXSTACK_rtn\n*-\n*  return data for normal cases\n*-\nZRXSTACK_norm  equ *\n         lr    r5,r15                     save rc\n         StrCopy from=(f.ZRXSTACK_dataa,f.ZRXSTACK_datal),             c\n               to=(f.ZRXSTACK_prmda,f.ZRXSTACK_prmdl)\n         lr    r15,r5                     restore rc\n*-\n*  return\n*-\nZRXSTACK_rtn   equ  *\n         lr    r5,r15\n         clc   ZRXSTACK_prmwa,=a(0)       work area supplied??\n         jne   ZRXSTACK_rtn2              yes\n         Freemain R,lv=ZRXSTACK_wrkl,a=(10)\nZRXSTACK_rtn2  equ  *\n         lr    r15,r5\n         l     r13,4(,r13)\n         l     r14,12(,r13)\n         Return (2,12)\n\n         ltorg\n         drop\n\n*-\n*  parm area  4x6=16 bytes\n*-\nZRXSTACK_prm   dsect\nZRXSTACK_prmfa ds    a                 address\nZRXSTACK_prmea ds    a                 address\nZRXSTACK_prmda ds    a                 address\nZRXSTACK_prmdl ds    a                 address\nZRXSTACK_prmwa ds    a                 address or 0\n\n*-\n*  work area  28x4=112 bytes\n*-\nZRXSTACK_wrk   dsect\nZRXSTACK_sa1   ds    18a\nZRXSTACK_pl    ds    6a\nZRXSTACK_rc    ds    a\nZRXSTACK_val   ds    a\nZRXSTACK_dataa ds    a                 address\nZRXSTACK_datal ds    a                 value\nZRXSTACK_wrkn  equ   *\nZRXSTACK_wrkl  equ   *-ZRXSTACK_wrk\n         Mend\n\n         MACRO\n.*-\n.* Subroutine, generate Lx instruction\n.* Syntax: RXLA  reg,what1,what2,,whatn\n.*         what: label or (reg) or 'literal' or f/h/b/c.label\n.*               b/c.label -> reg is cleared and the entire byte loaded\n.*               1st non-null 'what' is used\n.*-\n&ml      RXLA\n         lclc  &xlar,&xlap,&xla\n         lcla  &xlapn,&xlan\n         gblc  &rxlalen\n&rxlalen setc ''\n&xlar    setc  '&syslist(1)'\n&xlapn   seta  1\n.xlanext anop\n&xlapn   seta  &xlapn+1\n         aif   (&xlapn gt n'&syslist).x\n&xlap    setc  '&syslist(&xlapn)'\n         aif   (k'&xlap eq 0 or '&xlap' eq '''''').xlanext\n         aif   ('&xlap '(1,1) eq '(').xlareg\n         aif   ('&xlap '(1,1) eq '''').xlalit\n         aif   ('&xlap '(2,1) eq '.').xlafld\n&xla     setc  t'&xlap\n         aif   ('&xla' eq 'N').xlanum\n&ml      la    &xlar,&xlap\n         aif   ('&xlap  '(1,2) eq 'l''').x\n&rxlalen setc 'l''&xlap'\n         mexit\n.xlanum  anop\n&ml      lgfi  &xlar,&xlap\n         mexit\n.xlafld  anop\n&xlan    seta  k'&xlap-2\n&xla     setc  '&xlap'(1,1)\n&xlap    setc  '&xlap'(3,&xlan)\n&xla     setc  lower('&xla')\n         aif   ('&xla' eq 'b').xlaopb\n         aif   ('&xla' eq 'c').xlaopb\n         aif   ('&xla' eq 'h').xlaoph\n         aif   ('&xla' eq 'f').xlaopf\n         mnote 8,'Invalid argument &xla'\n         mexit\n.xlaopb  anop\n&ml      llc   &xlar,&xlap\n         mexit\n.xlaoph  anop\n&ml      lh    &xlar,&xlap\n         mexit\n.xlaopf  anop\n&ml      l     &xlar,&xlap\n         mexit\n.xlareg  anop\n&xlan    seta  k'&xlap-2\n&xlap    setc  '&xlap'(2,&xlan)\n&ml      lr    &xlar,&xlap\n         mexit\n.xlalit  anop\n&ml      la    &xlar,=c&xlap\n&xlan    seta k'&xlap-2\n&rxlalen setc '&xlan'\n         mexit\n.x       MEND\n\n*-RXMACS end\n*/ ADD NAME=STRLEN\n         Macro\n.* return length of string in r15\n.* data=(addr,len) or label\n&ml      StrLen &data=,&pad=c' '\n         gblc  &$lalenc\n         $la   r14,&data(1)\n         $la   r15,&data(2),&$lalenc\n         ar    r15,r14\n         bctr  r15,0\n         cli   0(r15),&pad\n         je    *-6\n         cr    r15,r14\n.*       jh    *+10\n         jnl   *+10\n         sr    r15,r15                 null string\n         j     *+10\n         sr    r15,r14\n         la    r15,1(,r15)\n         ltr   r15,r15\n         Mend\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ISPDPX01": {"ttr": 1034, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1a\\x00X\\x01\\x17\\x11\\x8f\\x01\\x193\\x8f\\x17P\\x01\\x17\\x01<\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.26", "flags": 0, "createdate": "2017-04-28T00:00:00", "modifydate": "2019-12-04T17:50:58", "lines": 279, "newlines": 316, "modlines": 0, "user": "DVL"}, "text": "//ISX1003  JOB (1),'ispf-pnl-exit',CLASS=A,REGION=32M,COND=(0,LT)\n//*\n//* ?? ISPDPX01 - Panel exit 01 - Use REXX stem as panel part ? e ?\n//*\n//C        EXEC ASMACL,PARM.C='TERM',  compile-link-go\n//             PARM.L='AMODE=31,RMODE=24,LIST,XREF'\n//C.SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR\n//           DD  DSN=SYS1.MODGEN,DISP=SHR\n//           DD  DISP=SHR,DSN=CBT669.LIB\n//C.SYSTERM  DD  SYSOUT=*\n//C.SYSIN    DD *\n**asma syslib *\n**asma opt    term\n*Process compat(macrocase)\n*\n* This ISPF panel exit is used to insert records into an ISPF panel.\n* It can replace the entire panel, or one or more sections\n* with data in REXX stem variable(s).\n* Note that the )END statement must still be present in the panel.\n*\n* The exit looks for a line starting with '*ISPDPX01 vname' in the\n* panel, then inserts the entire stem vname there.\n* The vname must include the trailing dot, max width incl the dot\n* is 5 characters.\n*\n* Multiple occurences of '*ISPDPX01 vname' is allowed, see member\n* ISX1PNL2 for a sample.\n*\n* Sample panel, named TESTX001:\n*\n*  )INEXIT LOAD,ISPDPX01\n*  *ISPDPX01 pl.\n*  )END\n*\n* Sample REXX code for using the above panel:\n*\n*  pl.1 = ')ATTR'\n*  pl.2 = ')BODY expand(\\\\)'\n*  pl.3 = '%Test panel exit 1'\n*  pl.4 = '%Cmd =>_zcmd  \\ \\ +'\n*  pl.5 = '+'\n*  pl.6 = 'Just some text'\n*  pl.7 = '+'\n*  pl.8 = ')INIT'\n*  pl.9 = ')PROC'\n*  pl.0 = 9\n*  address ispexec \"display panel(TESTX001)\"\n*\n* The program is written using my structured assembly macro set WSAM.\n* These macros are similar but not identical to IBM's structured\n* assembly macros.\n*\n*\n         lclc  &module,&forcewto\n&module   setc  'ISPDPX01'\n&forcewto setc  'N'\n*\n         print off\n         COPY  SYSMACS\n         COPY  WSAMMACS           allow structured asembly language\n         COPY  REXXMACS           REXX i/f\n         COPY  ISPXMACS           ISPF i/f\n         COPY  ISX1MACS           local combined macros\n         print on\n*        COPY  Z10MACS\n\n* -------------initialization------------------------------------------\n\n         Using $wrk,r10\n         using pnlparm,r9\n&module  #module base=r12,amode=31,rmode=24\n         lr    r9,r1\n*\n* if first time then get some storage\n*\n         l      r2,pnldataa\n         if    (icm,r10,15,0(r2),z)\n           Getmain R,lv=$wrkl,loc=31\n           lr    r10,r1\n           st    r10,0(r2)\n           clear vdata,l=256\n           mvc   vname,vdata\n           zap   vnum,=p'0'\n           mvi   action,0\n         endif\n         la    r13,sa1\n*\n* Process according to action code\n*  0  scan for the insertion point\n*  1  insert next record\n*     the insertion point record is deleted by end of insert\n*  2  process complete, cleanup\n*\n\n*\n* Action 0 : locate insertion point\n*\n         if    (cli,action,eq,0)\n           l     r6,pnlbfra             -> buffer address\n           l     r6,0(r6)               -> buffer\n           clear wtot\n           mvc   wtot(30),0(r6)\n           mvc   wtox,=al2(40,0)\n           xwto  l=40,force=&forcewto\n           if    (tm,pnlflgs,x'80',o)  end of file?\n             Terminate\n           endif\n           if    (clc,=c'*&module',ne,0(r6))\n             #module exit,rc=0\n           endif\n* insertion point found, locate variable name\n           la    r1,10(,r6)             bump label\n           la    r2,5                   max length\n           do    over(r2)\n             if    (cli,0(r1),ne,c' ')  find start of data\n               leave\n             endif\n             la    r1,1(,r1)            bump ptr\n           enddo\n           if    (clfi,r2,gt,5)         too wide?\n             wto   'vname is too wide'\n             Terminate\n           endif\n           mvc   vname,0(r1)            copy to name field\n           oc    vname,blank\n           la    r1,vname               bump label\n           do    inf\n             if    (cli,0(r1),eq,c' ')  find end of name\n               leave\n             endif\n             la    r1,1(,r1)            bump ptr\n           enddo\n           st    r1,vnump\n           lr    r15,r1\n           la    r14,vname\n           sr    r15,r14\n           st    r15,vnamel\n* get count\n           l     r1,vnump\n           mvi   0(r1),c'0'\n           IspxVget vname,(vdata,8),pl=ispxpl\n           if    (ltr,r15,r15,nz)\n             zap   vmax,=p'0'        no records to process\n* get stem max\n           else\n             st    r0,vlen\n             lr    r2,r0\n             strmake wtot,vname,+1,(r2,,cvdr,4),+1,(vdata,8),          c\n               lenreg=r3\n             xwto  l=(r3),force=&forcewto\n             bctr  r2,0\n             j     *+10\n             pack  vmax,vdata(*-*)\n             ex    r2,*-6\n             strmake wtot,vname,' count ',(vmax,4,c2x),lenreg=r3\n             xwto  l=(r3),force=&forcewto\n           endif\n           mvi   action,1\n         endif\n*\n* Action 1 : insert next record\n*\n         if    (cli,action,eq,1)\n           ap    vnum,=p'1'\n           if    (cp,vnum,gt,vmax)  all done?\n             mvi   action,0         0 = scan for further insertions\n* reset fields\n             clear vname\n             zap   vnum,=p'0'\n             #module exit,rc=4      delete record\n           endif\n* construct varname for vget\n           RxStemName base=(vname,f.vnamel),stema=vname,pnum=vnum\n           l     r2,=a(vdatal)\n           IspxVget vname,(vdata,(r2)),pl=ispxpl\n           st    r0,vlen\n* replace screen buffer\n           lm    r2,r3,pnlbfra\n           l     r2,0(r2)           -> buffer\n           l     r3,0(r3)           -> buffer sz\n           st    r3,fw\n           StrMake  wtot,'insert in bfr ',(fw,4,cvxd),' ',((2),30)\n           xwto  l=60,force=&forcewto\n\n           bctr  r3,0               mch len of buffer\n           bctr  r3,0               minus char 1\n           mvi   0(r2),c' '\n           mvc   1(*-*,r2),0(r2)\n           ex    r3,*-6             clear buffer\n\n           la    r3,2(,r3)          reinstate buffer length\n           l     r4,vlen            variable width\n           if    (cr,r4,gt,r3)      longer than buffer?\n             lr    r4,r3            use buffer length\n             ahi   r4,-2\n             StrMake  wtot,'vl gt bl ',(vdata,40)\n             xwto  l=60,force=&forcewto\n           endif                    else use buffer width\n           bctr  r4,0               mch len of buffer\n           mvc   0(*-*,r2),vdata\n           ex    r4,*-6             copy data\n           #module exit,rc=2        2 = insert\n         endif\n*\n* Action 2 : cleanup and terminate\n*\n         if    (cli,action,eq,2)\n           Terminate\n         endif\n*\n* Action ?\n*\n         StrMake wtot,'internal error ',(action,1,cvxd),lenreg=r3\n         xwto  l=(r3),force=Y\n         Terminate\n\n*\n* local data\n*\nzero     dc    a(0)\nblank    dc    cl140' '\n         ltorg\n*\n* Map panel parm\n*\npnlparm  dsect\npnlnamea ds   a\npnlbfra  ds   a\npnlbfrl  ds   a\npnlrecl  ds   a\npnlflgs  ds   a\npnldataa ds   a\n*\n* Own dsect\n*\n$wrk     dsect\nsa1      ds    18a\nsa2      ds    18a\naction   ds    x\nlogr     ds    cl120\nVGetsa   ds    a\nvlen     ds    a\nvnamel   ds    a\nvname    ds    cl8\nvnum     ds    pl4                 current stem num\nvnump    ds    a                   address of number in name\nvmax     ds    pl4                 max stem num\nfw       ds    f\ndw       ds    d\ncallpm   ds    8a\nwtox     ds    a\nwtot     ds    cl80\nispxpl   ds    8a\nwrk      ds    xl512\nvdata    ds    xl(1024*4)\nvdatal   equ   *-vdata\n$wrkl    equ   *-$wrk\n         END\n//*\n//* prod version goes to linklib\n//*\n//L.SYSLMOD  DD DISP=SHR,DSN=CBT669.LINKLIB(ISPDPX01)\n//L.SYSLIB   DD DISP=SHR,DSN=ISP.SISPLOAD\n//*\n//* production version is in linklib\n//*\n//IVP      EXEC PGM=IKJEFT1B,\n//             PARM='ISPSTART CMD(ISX1IVP1)'\n//STEPLIB  DD DISP=SHR,DSN=CBT669.LINKLIB\n//SYSEXEC  DD DISP=SHR,DSN=CBT669.LIB\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD DUMMY\n//ISPMLIB  DD DISP=SHR,DSN=ISP.SISPMENU\n//ISPPLIB  DD DISP=SHR,DSN=ISP.SISPPENU\n//ISPSLIB  DD DISP=SHR,DSN=ISP.SISPSENU\n//ISPTLIB  DD DISP=SHR,DSN=ISP.SISPTENU\n//ISPPROF  DD UNIT=SYSDA,SPACE=(TRK,(5,5,4)),RECFM=FB,LRECL=80\n//ISPLOG   DD SYSOUT=*,RECFM=VA,LRECL=125,BLKSIZE=129\n//ISPFILE  DD SYSOUT=*,RECFM=FB,LRECL=80,BLKSIZE=6240\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ISPXMACS": {"ttr": 1285, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00\\x10\\x01\\x184?\\x01\\x184O\\x10S\\x00N\\x00\\x1d\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "2018-12-09T00:00:00", "modifydate": "2018-12-10T10:53:10", "lines": 78, "newlines": 29, "modlines": 0, "user": "DVL"}, "text": "*-\n* ISPF interface macros\n*-\n\n*- ISPEXEC - general interface macro\n         Macro\n.* mode of operation\n.*  Literal operands are upper-cased, if staring with '(' they are\n.*  adresses as cl8'value', else as c'value'.\n.*  Anything else is an address or a value.\n&mlbl    IspExec &pl=\n         lcla  &p,&sn\n         lclc  &s,&ppl\n&ppl     setc  '&pl'\n         aif   (k'&pl gt 0).ppln\n&ppl     setc  '=6a(x''FFFFFFFF'')'\n.ppln    anop\n&mlbl    $la   r1,&ppl\n&sn      seta  1\n.a       anop\n         aif   (&sn gt n'&syslist).c\n&s       setc  '&syslist(&sn)'\n         aif   ('&s '(1,1) eq '''').lit\n         $la   r0,&s\n         ago   .st\n.lit     anop\n&s       setc  Upper('&s')\n         aif   ('&s '(1,1) eq '(').longlst\n         la    r0,=cl8&s\n         ago   .st\n.longlst la    r0,=c&s\n.st      anop\n         st    r0,&p.(,r1)\n&sn      seta  &sn+1\n&p       seta  &p+4\n         ago   .a\n.c       Call  ISPLINK\n         ltr   r15,r15\n.x       mexit\n         Mend\n\n*- VGET - specific interface macro\n         Macro\n.* CALL ISPLINK ('VCOPY',name,length-array,value-array,'MOVE')\n.* sample\n.*           l     r2,=a(1024*4)\n.*           IspxVget vname,(vdata,(r2)),pl=ispxpl\n.*           lr    r2,r0             length of received date\n.*  vname    ds    cl8\n.*  vdata    ds    xl(1024*4)\n.*  ispxpl   ds    8a\n         IspxVget &name,&data,&pl=\n         $la   r1,&pl\n         $la   r14,&data(2),l'&data(1)\n         st    r14,20(,r1)\n         la    r14,20(,r1)\n         IspExec 'vcopy',&name,(r14),&data(1),'move',pl=&pl\n         $la   r1,&pl\n         l     r0,20(,r1)\n         Mend\n\n*- VPUT - specific interface macro\n         Macro\n.* CALL ISPLINK ('VREPLACE',name-list,lengths,values)\n.* sample\n.*           IspxVput 'address',address,pl=ispxpl\n.*           la    r2,8\n.*           IspxVput 'address',(address,(r2)),pl=ispxpl\n.*           IspxVput 'address',(address,(r2)),pl=ispxpl\n.*  ispxpl   ds    8a\n.*  address  dc    c'Merianvej 11'\n         IspxVput &name,&data,&pl=\n         $la   r1,&pl\n         $la   r14,&data(2),l'&data(1)  length\n         st    r14,20(,r1)\n         la    r14,20(,r1)\n         IspExec 'vreplace',&name,(r14),&data(1),pl=&pl\n         Mend\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ISX1DOC": {"ttr": 1288, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00U\\x01\\x17\\x03O\\x01\\x18%\\x7f\\x10\\x18\\x007\\x00)\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "2017-02-03T00:00:00", "modifydate": "2018-09-14T10:18:55", "lines": 55, "newlines": 41, "modlines": 0, "user": "DVL"}, "text": "ISPF exit 1 - make dynamic panels from REXX stem(s)\n\n Current build: 002\n\n This ISPF panel exit is used to insert records into an ISPF panel\n from one or more REXX stems.\n It can replace the entire panel, or parts of the panel, with data\n from the stem(s).\n\n The exit looks for a line starting with '*ISPDPX01 vname' in the\n panel, then inserts the entire stem vname there.\n The vname must include the trailing dot, max width incl the dot\n is 5 characters.\n\n Multiple occurences of '*ISPDPX01 vname' is allowed.\n\n The length of the variable is internally reduced to the panel buffer\n size, which is the record length of the panel library.\n\n Sample panel, named TESTX001:\n\n  )INEXIT LOAD,ISPDPX01\n  *ISPDPX01 pl.\n  )END\n\n Note that the )END statement must still be present in the panel.\n\n Sample REXX code for using the above panel:\n\n  pl.1 = ')ATTR'\n  pl.2 = ')BODY expand(\\\\)'\n  pl.3 = '%Test panel exit 1'\n  pl.4 = '%Cmd =>_zcmd  \\ \\ +'\n  pl.5 = '+'\n  pl.6 = 'Just some text'\n  pl.7 = '+'\n  pl.8 = ')INIT'\n  pl.9 = ')PROC'\n  pl.0 = 9\n  address ispexec \"display panel(TESTX001)\"\n\n The program is written using my structured assembly macro set WSAM.\n These macros are similar but not identical to IBM's structured\n assembly macros.\n\n Members in the dataset:\n  ISPDPX01  Source - assemble and link.\n  ISX1DOC   Documentation (you are reading it now).\n  ISX1MACS  Macro copy book.\n  ISX1IVP1  Verification pgm.\n  ISX1PNL*  Sample panels etc.\n\nInstallation notes:\nIf the assmebly fails for enhanced immediate instruction, i.e. LGFI,\nthen remove the asterix in front of 'COPY  Z10MACS' and reassemble.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ISX1IVP$": {"ttr": 1290, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00%\\x01\\x18#\\x0f\\x01\\x19\\x10\\x1f#2\\x00\\x10\\x00\\x10\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-08-18T00:00:00", "modifydate": "2019-04-11T23:32:25", "lines": 16, "newlines": 16, "modlines": 0, "user": "DVL"}, "text": "//ISX1IVP$ JOB (1),'ISX1IVP$',CLASS=A\n//*\n//* IVP - dynamic display\n//*\n//IVP      EXEC PGM=IKJEFT1B,\n//             PARM='ISPSTART CMD(ISX1IVP1)'\n//SYSEXEC  DD DISP=SHR,DSN=CBT669.PP.ISPDPX01.V002.LIB\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD DUMMY\n//ISPMLIB  DD DISP=SHR,DSN=ISP.SISPMENU\n//ISPPLIB  DD DISP=SHR,DSN=ISP.SISPPENU\n//ISPSLIB  DD DISP=SHR,DSN=ISP.SISPSENU\n//ISPTLIB  DD DISP=SHR,DSN=ISP.SISPTENU\n//ISPPROF  DD UNIT=SYSDA,SPACE=(TRK,(5,5,4)),RECFM=FB,LRECL=80\n//ISPLOG   DD SYSOUT=*,RECFM=VA,LRECL=125,BLKSIZE=129\n//ISPFILE  DD SYSOUT=*,RECFM=FB,LRECL=80,BLKSIZE=6240\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ISX1IVP1": {"ttr": 1292, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0f\\x00\\x19\\x01\\x17\\x03O\\x01\\x19\\x10\\x1f#2\\x00z\\x003\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.15", "flags": 0, "createdate": "2017-02-03T00:00:00", "modifydate": "2019-04-11T23:32:19", "lines": 122, "newlines": 51, "modlines": 0, "user": "DVL"}, "text": " /* test ispf panel exit                         rexx */\n\n say 'ISPF panel exit ISPDPX01 installation verification'\n\n pp ='ISX1PNL'\n say 'Panel prefix' pp\n zz=Listdsi('sysexec file')\n plib=sysdsname\n llib='CBT669.LOADLIB'\n env = left(sysvar('sysenv'),1)   /* Fore/Back */\n libdef=''\n address ispexec\n /*\n zerrlm=''\n \"libdef ispllib dataset id('\"llib\"') stack\"\n if rc<>0 then call close 8 'Libdef llib' llib 'failed rc' rc zerrlm\n libdef=libdef 'ISPLLIB'\n */\n zerrlm=''\n \"libdef ispplib dataset id('\"plib\"') stack\"\n if rc<>0 then call close 8 'Libdef plib' plib 'failed rc' rc zerrlm\n libdef=libdef 'ISPPLIB'\n\n say 'testing' pp'A, supplying everything in the stem'\n pl.1  = \")ATTR                          \"\n pl.2  = \" + type(text) color(green) skip(on)  \"\n pl.3  = \" _ type(input) color(turq) hilite(uscore) caps(on)\"\n pl.4  = \" ! type(input) color(turq) hilite(uscore) caps(off)\"\n pl.5  = \")BODY expand(\\\\)               \"\n pl.6  = center('%Test panel exit 1 - IVP 2',78)\n pl.7  = \"%Cmd =>_zcmd    \\ \\ +\"\n pl.8  = \"+                              \"\n pl.9  = \"Just some text                 \"\n pl.10 = \"+\"\n pl.11 = left(\"Input your name!name\",60)\"+\"\n pl.12 = \"+                              \"\n pl.13 = \")INIT                          \"\n pl.14 = \" &name = 'test1'                \"\n pl.15 = \")PROC                          \"\n pl.16 = \" ver (&name,nb)\"\n pl.0 = 16\n zerrlm=''\n if enf='B' then \"control nondispl enter\"\n \"display panel(\"pp\"1)\"\n if rc>8 then call close 8 'display' pp'1 rc' rc zerrlm\n say 'Display test 1 ok, rc='rc', name='name\n say ''\n\n say 'testing' pp'2, separate stem per panel section'\n /* ATTR */\n pa.1 = \" + type(text) color(green) skip(on)  \"\n pa.2 = \" _ type(input) color(turq) hilite(uscore) caps(on)\"\n pa.3 = \" ! type(input) color(turq) hilite(uscore) caps(off)\"\n pa.0 = 3\n /* BODY */\n pb.1 = center('%Test panel exit 1 - IVP 2',78)\n pb.2 = left(\"%Cmd =>_zcmd\",78)\"+\"\n pb.3 = \"+                              \"\n pb.4 = \"Just some text                 \"\n pb.5 = \"+\"\n pb.6 = left(\"Input your name!name\",60)\"+\"\n pb.7 = \"+                              \"\n pb.0 = 7\n /* INIT */\n pi.1 = \" &name = 'test2'                \"\n pi.0 = 1\n /* REINIT */\n pr.0 = 0\n /* PROC */\n pp.1 = \" ver (&name,nb)\"\n pp.0 = 1\n zerrlm=''\n if enf='B' then \"control nondispl enter\"\n \"display panel(\"pp\"2)\"\n if rc>8 then call close 8 'display' pp'2 rc' rc zerrlm\n say 'Display test 2 ok, rc='rc', name='name\n say ''\n\n say 'testing' pp'2, separate stem per panel section, with some missing'\n drop pa. pb. pi. pr. pp.\n /* ATTR */\n pa.1 = \" + type(text) color(green) skip(on)  \"\n pa.2 = \" _ type(input) color(turq) hilite(uscore) caps(on)\"\n pa.3 = \" ! type(input) color(turq) hilite(uscore) caps(off)\"\n pa.0 = 3\n /* BODY */\n pb.1 = center('%Test panel exit 1 - IVP 3',78)\n pb.2 = left(\"%Cmd =>_zcmd\",78)\"+\"\n pb.3 = \"+                              \"\n pb.4 = \"Just some text                 \"\n pb.5 = \"+\"\n pb.6 = left(\"Input your name!name\",60)\"+\"\n pb.7 = \"+                              \"\n pb.0 = 7\n /* INIT */\n pi.1 = \" &name = 'test3'                \"\n pi.0 = 1\n zerrlm=''\n if enf='B' then \"control nondispl enter\"\n \"display panel(\"pp\"2)\"\n if rc>8 then call close 8 'display' pp'2 rc' rc zerrlm\n say 'Display test 3 ok, name=' name\n say ''\n\n say 'testing' pp'2, with incomplete stems'\n drop pb.4\n zerrlm=''\n if enf='B' then \"control nondispl enter\"\n \"display panel(\"pp\"2)\"\n if rc>8 then call close 8 'display' pp'2 rc' rc zerrlm\n say 'Display test ok'\n say ''\n\n call close 0\n\nClose:\n parse arg n m\n if m<>'' then say m\n do dn=1 to words(libdef)\n   \"libdef\" word(libdef,dn)\n end\n exit word(n 0,1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ISX1MACS": {"ttr": 1295, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00G\\x01\\x17\\x04\\x7f\\x01\\x193\\x8f\\x10\\x03\\x00\\x1a\\x00\\x03\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "2017-02-16T00:00:00", "modifydate": "2019-12-04T10:03:47", "lines": 26, "newlines": 3, "modlines": 0, "user": "DVL"}, "text": "*-\n* macros for ISPPDX01\n*-\n\n         Macro\n         Terminate\n         Freemain R,lv=$wrkl,a=(10)\n         #module exit,rc=8\n         Mend\n\n         Macro\n         XWTO  &l=,&force=N\n         aif   (k'&syslist(1) eq 0).l\n         mvlit wtot,&syslist(1),lr=r15\n         ago   .l2\n.l       aif   (k'&l eq 0).g\n         $la   r15,&l\n.l2      la    r15,4(,r15)\n         sll   r15,16\n         st    r15,wtox\n.g       la    r1,wtox\n         sr    r0,r0\n         aif   ('&force' ne 'Y').b\n         svc   35\n.b       clear wtot\n         Mend\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ISX1PNL1": {"ttr": 1297, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\"\\x01\\x17\\x03O\\x01\\x18!\\x1f\\x14\\x16\\x00\\x06\\x00\\x06\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2017-02-03T00:00:00", "modifydate": "2018-07-30T14:16:22", "lines": 6, "newlines": 6, "modlines": 0, "user": "DVL"}, "text": ")INEXIT LOAD,ISPDPX01\n*ISPDPX01 pl.\n)END\n\n  This panel allows the entire panel definition, all sections,\n  to be supplied in the DYNP. stem.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ISX1PNL2": {"ttr": 1299, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x07\\x01\\x17\\x03O\\x01\\x17\\x03O\\x17\\x01\\x00\\x0e\\x00\\x0e\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2017-02-03T00:00:00", "modifydate": "2017-02-03T17:01:07", "lines": 14, "newlines": 14, "modlines": 0, "user": "DVL"}, "text": ")INEXIT LOAD,ISPDPX01\n)ATTR\n*ISPDPX01 pa.\n)BODY\n*ISPDPX01 pb.\n)INIT\n*ISPDPX01 pi.\n)REINIT\n*ISPDPX01 pr.\n)PROC\n*ISPDPX01 pp.\n)END\n\n Panel sections are supplied as separate stems.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ISX1RDME": {"ttr": 1301, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x004\\x01\\x193\\x8f\\x01\\x193\\x8f\\x10$\\x00\\r\\x00\\r\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-12-04T00:00:00", "modifydate": "2019-12-04T10:24:34", "lines": 13, "newlines": 13, "modlines": 0, "user": "DVL"}, "text": "Description of members:\n\n ISPDPX01  Product, edit and run this member.\n ISX1DOC   Documentation.\n ISX1HIST  Product history.\n ISX1IVPx  IVPs\n ISX1PNLx  ISPF panels for IVPs\n ISX1MACS  Local macros.\n SYSMACS   ASM copy book containing combined non-IBM macros.\n ISPXMACS  ASM copy book containing my macros for interfacing with ISPF.\n REXXMACS  ASM copy book containing my macros for interfacing with REXX.\n WSAMMACS  ASM copy book containig my structured assembler macro set.\n           The macros are equivalent but not identical to IBM's macros.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PERFTEST": {"ttr": 1538, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x000\\x01\\x19\\t/\\x01  O\\x14S\\x00:\\x000\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2019-04-02T00:00:00", "modifydate": "2020-07-22T14:53:30", "lines": 58, "newlines": 48, "modlines": 0, "user": "DVL"}, "text": "//RXGVPRFT JOB (1),'RXGV-perf-test',CLASS=A,COND=(5,LT)\n//*\n//* REXXGBLV\n//* Compare performance LPALIB to STEPLIB to STEPLIB with CDEUCTZ2\n//*\n//U1      EXEC PGM=IEBUPDTE,PARM=NEW\n//SYSPRINT DD DUMMY\n//SYSUT2   DD DISP=(,PASS),DSN=&&EXECLIB,UNIT=SYSDA,\n//            SPACE=(TRK,(2,2,2)),DCB=(SYS1.MACLIB)\n//SYSIN    DD *\n./ ADD NAME=RXGVPERF\n /* test REXXGBLV performance                                   rexx */\n parse arg pgm loops text\n say 'testing' pgm loops 'times' text\n m=0\n t1=time('e')\n interpret,\n \"do loops;\",\n   \"cc=\"pgm\"('Kilroy was here only last Tuesday','*her*');\",\n \"end\"\n say 'cpu:' sysvar('syscpu') 'time:' time('e')-t1\n exit\n//*\n//LKED     EXEC PGM=IEWL,PARM='REUS,RMODE(ANY),AMODE(31)'\n//SYSUT1   DD  UNIT=SYSALLDA,SPACE=(1024,(200,20))\n//SYSPRINT DD  DUMMY\n//SYSLIB   DD  DISP=SHR,DSN=CBT669.LOADLIB\n//SYSLMOD  DD  DISP=(,PASS),DSN=&&LOADLIB,UNIT=SYSDA,\n//            SPACE=(TRK,(2,2,2)),DCB=(CBT669.LPALIB)\n//SYSLIN   DD  *\n INCLUDE SYSLIB(REXXGBLV)\n ENTRY   REXXGBLV\n NAME    XXXXGBLV(R)\n//*\n//* 1 - Running from LPA\n//*\n//LPA      EXEC PGM=IKJEFT1B,PARM='%RXGVPERF REXXGBLV 500 from lpa'\n//SYSEXEC  DD DISP=SHR,DSN=&&EXECLIB\n//SYSTSPRT DD SYSOUT=*,OUTLIM=(5000)\n//SYSTSIN  DD DUMMY\n//*\n//* 2 - Running from steplib with hiper option\n//*\n//SLB1     EXEC PGM=IKJEFT1B,\n//         PARM='%RXGVPERF REXXGBLV 500 steplib with hiper'\n//STEPLIB  DD DISP=SHR,DSN=CBT669.LOADLIB\n//SYSEXEC  DD DISP=SHR,DSN=&&EXECLIB\n//SYSTSPRT DD SYSOUT=*,OUTLIM=(5000)\n//SYSTSIN  DD DUMMY\n//*\n//* 3 - Running from steplib without hiper option\n//*\n//SLB2     EXEC PGM=IKJEFT1B,PARM='%RXGVPERF XXXXGBLV 500 steplib'\n//STEPLIB  DD DISP=SHR,DSN=&&LOADLIB\n//SYSEXEC  DD DISP=SHR,DSN=&&EXECLIB\n//SYSTSPRT DD SYSOUT=*,OUTLIM=(5000)\n//SYSTSIN  DD DUMMY\n//*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXXGBLV": {"ttr": 1540, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01c\\x00\\x17\\x01\\x18!_\\x01  O\\x14S\\n\\x0b\\tR\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.99", "flags": 0, "createdate": "2018-08-03T00:00:00", "modifydate": "2020-07-22T14:53:17", "lines": 2571, "newlines": 2386, "modlines": 0, "user": "DVL"}, "text": "//RXGV064  JOB (DVL),'REXXGBLV-064',\n//*    RESTART=IVP1,\n//             CLASS=A,REGION=64M,COND=(0,LT),TIME=(1)\n//*\n/*JOBPARM L=99999\n//*\n//     SET IVP=IVP1\n//*\n//A         EXEC ASMACL,PARM.C='TERM,RENT',\n//             PARM.L='RENT,REUS,LIST,MAP,RMODE(ANY)'\n//C.SYSLIB  DD DISP=SHR,DSN=CBT669.LIB\n//          DD DISP=SHR,DSN=SYS1.MACLIB\n//          DD DISP=SHR,DSN=SYS1.MODGEN\n//C.SYSTERM DD SYSOUT=*\n//C.SYSIN   DD *\n**asma syslib *\n**asma opt    term\n*-\n*  Save/load REXX variables to/from address-space common storage.\n*  This storage is available as long as the user/program is active.\n*\n*  Build: 064.1 2020-07-22\n*\n*  New in this build:\n*\n*  Changed in this build:\n*  - Set rc=4 if no records are returned.\n*    This is customizable, see new customization member RXGVCUST.\n*  - Set rc=4 for some founctions if pool is not found.\n*    This is customizable, see new customization member RXGVCUST.\n*  - Set rc=4 if SAVE could not retrieve variables to store.\n*    This is customizable, see new customization member RXGVCUST.\n*\n*  Fixed in this build:\n*  - STEMIX did not work.\n*  - Possible false negative for DATA(mask) filters.\n*\n*  See the RXGVHIST member for earlier changes\n*\n*  Warnings\n*  - build 063 changes the return code for no-records-loaded and\n*    pool-not-found. See the customization member RXGVCUST.\n*\n*  Global register usage\n*   12 mainline base\n*   11 subroutime base (in general, not guaranteed)\n*   10 mainline workarea\n*\n*  Syntax: see member RXGVDOC\n*-\n\n*-\n* Set local customization. Externalized in member RXGVCUST.\n*-\n         lclc  &JPAQopt\n         lcla  &NullLoadRc,&NoPoolRc,&SaveNoVarRc\n&JPAQopt     setc  'Y'\n&NullLoadRc  seta  4\n&SaveNoVarRc seta  4\n&NoPoolRc    seta  4\n         Copy  RXGVCUST\n\n*-\n* Set module variables\n*-\n           lclc rxgvver\n&rxgvver   setc  '064.2'\n           gblc  &@modname,&@vdatal,&@ntname,&@mainver\n           gblc  &@maintrc,&@pvtnum\n&@modname  setc 'REXXGBLV'\n&@mainver  setc '&rxgvver'\n&@maintrc  setc 'Y'\n*\n&@vdatal   setc '32700'                initial max length of data\n&@pvtnum   setc '10'                   numer of pvt entries per block\n*////////////////////////////////////////////////////////////////////*\n* Update the ntname if the storage block structure (VCB) has changed *\n*////////////////////////////////////////////////////////////////////*\n&@ntname setc 'REXXGBLV.060'\n\n         Print off\n         Copy  SYSMACS                 non-IBM macros\n         Copy  REXXMACS                REXX interfacing macros\n         Copy  VCBMACS                 Variable-store macros\n         Copy  WSAMMACS                Willow Structured Assembler Macs\n         Copy  RXGVMACS                REXXGBLV macros\n*        Copy  z10macs                 new immediates emulation\n         Print on\n\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n*                               Prolog                                *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n\n         VCBGlobal anchor=f.PACBcur,keepnum=20,keepmaxw=512\n         #subr set,entry=csect,base=r11,saend=saheapn\n         gblc  &#subrbase\n\nREXXGBLV #module base=(r12),text='&rxgvver',  print=GEN,               c\n               work=(lclstorl,lclstor,r10),sa=SAheap,xepilog=MainEpil\n*-\n* Keep module in JPAQ for duration of job / TSO session\n*-\n&JPAQopt setc  Upper('&JPAQopt')\n* Retain module in JPAQ\n         aif   ('&JPAQopt' ne 'Y').JPAQend\n         CDEUCTZ2 dsect=N\n.JPAQend anop\n\n*-\n* initialize global fields\n*-\n         lgfi  r1,DynDataL\n         ClrLong DynData,(r1)\n         ereg  0,1\n         stm   r0,r1,parmlist      save callers r0,r1\n         mvlit SAheap,'F1SA'       indicate that we used linkage stack\n         st    r12,mainaddr\n         mvi   rc,c'0'\n         xc    rxrc1(l'rxrc1+l'rxrc2),rxrc1\n         mvi   options,0\n         xc    zero,zero\n         xc    rtndef(8),rtndef\n         mvi   generic,c'N'\n         zap   p1,=p'1'\n         mvc   sanum,p1                  reset counter\n         la    r1,p0fields\n         la    r2,p0fieldn\n         do    until,(cr,r1,ge,r2)\n           zap   0(4,r1),=p'0'           reset counter\n           la    r1,4(,r1)\n         enddo\n         mvc   NtName,=cl16'&@ntname'\n         clear blank\n         clear parmstr\n         clear logr\n         clear emsg\n         clear rxtext\n         mvc   varpool,blank\n         mvc   ddname,blank\n         mvc   wtopfx(2),=al2(100)\n* REXX setup\n         lm    r0,r1,parmlist          reload\n         RxInit parmarea=parmstr\n         if    (ltr,0,0,z)               no REXX\n           wto   'RxInit err'\n           #modend 99\n         endif\n         if    (cli,parmstr,eq,c' ')\n           emsg  'Missing parm',rc=8\n           #module end,rc=0\n         endif\n*\n         la    r2,parmstr-5(r15)\n         mvc   dw,0(r2)\n         oc    dw,blank\n* some initial logging\n         if    (=c'TRACE',eq,dw)\n           mvi   trace,c'Y'\n           st    r12,dw\n           st    r10,dw+4\n           strmake logr,'epa ',(dw,4,c2x),' ws ',(dw+4,4,c2x)\n           trclog ,\n         endif\n* Pool anchor setup\n         Call PACBinit\n         if   (ltr,r15,r15,nz)\n           #module end,rc=0\n         endif\n*\n         trclog 'drop temp pool'\n         Pool  Drop,=cl16')TEMP'\n         mvc   varpool,blank\n         xc    PACBcur,PACBcur\n* parameter verify/split\n         Call  PRMinit\n         if    (ltr,r15,r15,nz)\n           #module end,rc=0\n         endif\n* some logging\n         TrcBlk\n         STRMAKE logr,'RXINIT Excoma ',(zrx_ExComA,4,cvxd)\n         STRMAKE        ,' Envblka ',(zrx_EnvBlka,4,cvxd)\n         STRMAKE        ,' Comblka ',(zrx_Comblk,4,cvxd)\n         trclog  ,\n         st    r10,dw\n         lgfi  r1,lclstorl\n         st    r1,dw+4\n         STRMAKE logr,'LclStor ',(dw+4,4,cvd,8),                       c\n               ' at ',(dw,4,cvxd)\n         trclog ,\n         TrcBlkEnd\n* get variable data block\n         l     r1,=a(&@vdatal)         var data max size\n         call  AcqDatab\n         if    (ltr,r15,r15,nz),then=(#modend,8)\n\n* call processor\n         mvi   RxFlags,0\n         sr    r1,r1\n         l     r15,funcaddr\n         balr  r14,r15\n         if    (c,r15,gt,rc),then=(st,r15,rc)\n* end\n         #module end,rc=0\n         ltorg\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n*                           Epilog                                    *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\nMainEpil #subr\n         trclog 'Epilog'\n         strmake logr,'rc ',(rc,4,c2x),lenreg=r2\n         trclog ,(r2)\n*-\n* free data buffers\n*-\n         lm    r3,r4,databfra          address, length             v051\n         if    (ltr,r3,r3,nz)          if acquired                 v051\n           trclog 'Releasing databfr'\n           STORAGE RELEASE,LENGTH=(4),ADDR=(3)                     v051\n         endif ,                                                   v051\n*-\n* cleanup temp pool\n*-\n         trclog 'drop temp pool'\n         mvc   varpool,=cl16')TEMP'\n         sr    r1,r1\n         Call  PoolLoc\n         Call  PoolDrop\n*-\n* back now if REXX is not avaiable\n*-\n         if    (zrx_EnvBlka,eq,zero)    REXX initialized??\n           wto   'Back - no REXX'\n           #subr  exit,8\n         endif\n*-\n* build variables to externalize various internal values\n*-\n         Using VCBAnchr,r8\n         if    (icm,r8,15,PACBcur,z)\n           xc    wrk256,wrk256       make null\n           la    r8,wrk256             VCB anchor\n         endif\n         vputc2d maxnl,VCBAvmaxnl    max name length\n         vputc2d maxdl,VCBAvmaxdl    max data length\n         vputc2d maxndl,VCBAvmaxndl  max name+data length\n         drop  r8\n*\n         vputp2d vlistn,vlistcnt\n         vputp2d vloadn,vloadcnt\n         vputp2d vsaven,vsavecnt\n         vputp2d vdeln,vdelcnt\n         vputp2d importn,vimpcnt\n         vputp2d exportn,vexpcnt\n         vputp2d rlistn,rlistcnt\n         vputp2d rloadn,rloadcnt\n*-\n* make message variable\n*-\n         if    (cli,emsg,ne,c' '),and,(emsgl,eq,zero)\n           la    r1,l'emsg\n           st    r1,emsgl\n         endif\n         RxVput name=('REXXGBLV_MSG'),data=(emsg,f.emsgl)\n\n* if rtn not set, then use rc\n         if     (rtndef(4),eq,zero)\n           l     r1,rc\n           $cvd  r1,rcc,len=8\n           la    r1,rcc                set\n           la    r2,8                    rc\n           stm   r1,r2,rtndef          address, length\n         endif\n*\n         lm    r4,r5,rtndef            address, length\n         strmake logr,'rxretval l=',(r5,,cvdr,4),                      c\n               ' t=\"',((r4),(r5),,60),'\"',lenreg=r2\n         trclog ,(r2)\n*\n         RxRetval f.rtndef,f.rtndef+4\n*-\n* back\n*-\n         #subr exit,rc=0\n         #subr drop\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n*                     parameter evaluation/obtain                     *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\nPRMinit  #subr\n         if    (blank,eq,parmstr)        blank is the shorter string\n           emsg  'Parm err 1',rc=8\n           #subr exit,rc=8\n         endif\n*\n         StrParse (parmstr,l'parmstr),                                 +\n               (#p,function,l=10,c=u),            1st pos = function   c\n               (var,varname,l=255,c=u),                                +\n               (stem,stemnm,l=255,c=u),                                +\n               (liststem,liststem,l=255,c=u,a=5),                      +\n               (value,value,l=200),                                    +\n               (data,data,l=200),                                      +\n               (valvar,valvar,l=255,c=u),                              +\n               (prefix,prefix,l=20,c=u),          v051/v052            +\n               (pool,varpool,l=16,c=u),                                +\n               (where,where,l=40,c=u),                                 +\n               (xtended,xtended,l=1,c=u),                              +\n               (length,length,l=1,c=u),                                +\n               (ddname,ddname,l=8,c=u,a=2),                            +\n               (nw,pnw,c=b,l=f,i=35),                                  +\n               (dw,pdw,c=b,l=f,i=80),                                  +\n               (trace,trace,l=1,c=u),                                  +\n               msg=logr,pp=#p,align=f,build=Y\n*              build=y,msg=logr,align=f,pp=#p    future\n*              (dump,funcdump,l=1,c=u),          future\n*-\n* some general checks\n*-\n         if    (ltr,r5,r15,nz)\n           emsg  'Parm error',rc=8\n           #subr exit,rc=8\n         endif\n         if       (cli,varpool,eq,c'-'),                               c\n               or,(cli,varpool,eq,c'('),                               c\n               or,(cli,varpool,eq,c')')\n           emsg  'Invalid pool',rc=8\n           #subr exit,rc=8\n         endif\n*-\n* validate function name\n*-\n         if    (cli,function,eq,c' ')\n           emsg  'Function missing',rc=8\n           #subr exit,rc=8\n         endif\n         oc    function,blank\n         strmake logr,'function ',function\n         trclog\n         la    r14,funclist\n         do    forever\n           if    (function,eq,0(r14)),then=leave\n           la    r14,14(,r14)\n           if    (cli,0(r14),eq,x'ff')\n             emsg  'Function invalid',rc=8\n             #subr exit,rc=8\n           endif\n         enddo\n         mvc   funcaddr,10(r14)\n*-\n* special process\n*-\n         if    (funcaddr,eq,=v(STEMIX))\n           mvc   varnamel,stemnml\n           mvc   varname,stemnm\n         endif\n*-\n* set defaults\n*-\n         if    (cli,ddname,eq,c' '),then=(mvlit,ddname,'RXGVEXP ')\n         if    (cli,varpool,eq,c' '),or,(cli,varpool,eq,c'*')\n           mvc   varpool,=cl16')DEFAULT'\n         endif\n         strmake logr,'prmi varpool ',varpool\n         trclog\n*\n         if    (cli,where_dl,ne,0)     test contents??\n           lb    r15,where_dl          size of needle\n           $cvd  logr+12,len=2,reg=r15\n           bctr  r15,0\n           mvc   logr+16(*-*),where\n           ex    r15,*-6\n           trclog 'where:'\n         endif\n\n*setup length fields\n         xc    varname_z(3),varname_z leave as 4-byte length\n         xc    stemnm_z(3),stemnm_z   leave as 4-byte length\n*-\n* check for generic variable name\n*-\n         oc    varname,blank\n         if    (cli,varname_dl,eq,0)  no varname given\n*          mvi   varname_dl,1         default\n*          mvi   varname,c'*'           to '*'\n           oi    options,opt_generic+opt_all\n           trclog 'all vars'\n         else ,                       try for generic\n           sr    r15,r15\n           ic    r15,varname_dl        length\n           la    r14,varname-1(r15)    -> last byte of string\n           if    (cli,0(r14),eq,c'.')  stem base (stem.) ?\n             lb    r15,varname_dl\n             la    r15,1(,r15)\n             stc   r15,varname_dl      update length\n             mvi   1(r14),c'*'         add '*' to name\n             oi    options,opt_generic+opt_stem\n             trclog 'stembase var'\n           else ,                      could contain generic char\n             la    r14,varname\n             ic    r15,varname_dl\n             do    over=(r15)\n               if    (cli,0(r14),eq,c'%'),or,(cli,0(r14),eq,c'*')\n                 oi    options,opt_generic\n               endif\n               la    r14,1(,r14)\n             enddo\n           endif\n         endif\n         if    (tm,options,opt_generic,o)\n           mvi   generic,c'Y'\n           trclog 'generic var'\n         else\n           trclog 'named var'\n         endif\n*\n         #subr exit,rc=0\n\n* Function list\n         Macro\n         SetFunc &name,&addr\n         lclc  &s\n&s       setc  Upper('&name')\n         aif   (k'&addr eq 0).addr2\n         dc    cl10'&s',vl4(&addr)\n         mexit\n.addr2   dc    cl10'&s',vl4(&s)\n         Mend\n\nFunclist ds    0a\n         SetFunc copy,rcopy\n         SetFunc return,vreturn\n         SetFunc load,vload\n         SetFunc loaddrop,vloaddrp\n         SetFunc pull,vpull\n         SetFunc list,vlist\n         SetFunc rlist\n         SetFunc rstat\n         SetFunc del,vdel\n         SetFunc drop,Drop\n         SetFunc save,vsave\n         SetFunc dropsave\n         SetFunc clrsave,dropsave      alias, deprecated\n         SetFunc delsave\n         SetFunc clrvsave,delsave      alias, deprecated\n         SetFunc add,vadd\n*export/import\n         SetFunc export,Export\n         SetFunc import,Import\n         SetFunc rexport\n         SetFunc rimport\n         SetFunc saveexp,saveexp       not recommended, use rexport\n         SetFunc impload,impload       not recommended, use rimport\n*indexing\n         SetFunc index,vindex\n         SetFunc varix,vindex\n         SetFunc varindex,vindex\n         SetFunc rindex\n         SetFunc stemix\n         SetFunc stmx,stemix           alias\n         SetFunc stemindex,stemix      alias\n*info\n         SetFunc map,map\n         SetFunc version\n*        SetFunc dump,vdump\n*        SetFunc brif,POOLBRIF,type=R                 045\n         dc    x'FF'\n*\n         #subr drop\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n* Init PACB chain / get anchor point                                  *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n\nPACBinit #subr xprolog=SubrProl,xepilog=SubrEpil\n*-\n* retrieve if done previously\n*-\n         NTServx rt,name==cl16'&@ntname',token=NtToken,                c\n               rc=wrk256,pl=wrk256+4\n         if    (z)\n           trclog 'NTrt &@ntname ok'\n           #subr exit,rc=0\n         endif\n*-\n* first time, go get\n*-\n         xc    nttoken,nttoken\n         PACBnew name==cl16')SELF',vcbainit=N  1st PACB\n         st    r1,PACBhead\n         st    r1,PACBcur\n*\n         NTServx cr,name==cl16'&@ntname',token=NtToken,                c\n               rc=wrk256,pl=wrk256+4\n         if    (nz)\n           lr    r5,r15\n           st    r5,fw\n           strmake logr,'NTCR &@ntname rc ',(fw,4,c2x),lenreg=r2\n           logwto ,(2)\n           abend 103\n         endif\n         trclog 'NTcr &@ntname ok'\n*\n         Pool  add,=cl16')DEFAULT'\n         if    (nz),then=(#subrend,8)\n         Pool  add,=cl16')TEMP'\n         if    (nz),then=(#subrend,8)\n*\n         #subr exit,rc=0\n         #subr drop\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n*         SETVERS - return version                                    *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\nVersion  #subr xprolog=SubrProl,xepilog=SubrEpil\n         la    r1,verstxt\n         la    r2,l'verstxt\n         stm   r1,r2,rtndef\n         #subr exit\n         #subr drop\n         Macro\n         MkVersion &t\n         lclc  &c\n&c       setc  '&sysclock'(1,19)\nverstxt  dc    c'&t &c'\n         Mend\n         MkVersion &@modname..&rxgvver\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n* DroPSave : Drop pool, then save                                     *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\nDropSave #subr xprolog=SubrProl,xepilog=SubrEpil\n         Pool  Drop,0\n         Call  Vsave\n         #subr exit\n         #subr drop\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n* DelSave  : Delete vars, then save                                   *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\nDelSave  #subr xprolog=SubrProl,xepilog=SubrEpil\n         Call  Vdel\n         if    (ltr,r15,r15,z)\n           Call  Vsave\n         endif\n         #subr exit,rc=(r15)\n         #subr drop\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n* REXPORT  save to temp and export                                    *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\nRexport  #subr xprolog=SubrProl,xepilog=SubrEpil\n         mvc   varpool,=cl16')TEMP'\n         Call  SaveExp\n         #subr exit,rc=(r15)\n         #subr drop\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n* SAVEEXP  save to pool and export                                    *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\nSaveExp  #subr xprolog=SubrProl,xepilog=SubrEpil\n         Call  Vsave\n         if    (ltr,r15,r15,z)\n           oi    options,opt_all\n           Call  Export\n         endif\n         #subr exit,rc=(r15)\n         #subr drop\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n* Rimport  Import and then load                                       *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\nRImport  #subr xprolog=SubrProl,xepilog=SubrEpil\n         mvc   varpool,=cl16')TEMP'\n         Call  ImpLoad\n         #subr exit,rc=(r15)\n         #subr drop\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n* IMPLOAD  Import to pool and then load                               *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\nImpLoad  #subr xprolog=SubrProl,xepilog=SubrEpil\n         Call  Import\n         if    (ltr,r15,r15,z)\n           oi    options,opt_all\n           Call  Vload\n         endif\n         #subr exit,rc=(r15)\n         #subr drop\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n*         LoadDrop : Load, then drop pool                             *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\nVLoadDrp #subr\n         call  Vload\n         if    (ltr,r15,r15,z)\n           call  PoolDrop\n         endif\n         #subr exit\n         #subr drop\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n*         DROP : drop pool                                            *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\nDrop     #subr xprolog=SubrProl,xepilog=SubrEpil\n*\n         if    (cli,varpool,eq,c' ')\n           emsg  'missing pool name',rc=8\n           mvc   logr,emsg\n           trclog ,\n           #subr exit\n         endif\n*        if    (cli,varpool,eq,c')')\n*          emsg  'internal pool name'\n*          mvc   logr,emsg\n*          trclog ,\n*          #subr exit,rc=8\n*        endif\n*\n         Call  PoolDrop\n         #subrend rc=(r15)\n         #subr drop\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n*         Pull : Load, then delete variables in pool                  *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\nVPull    #subr\n*\n*        if    (cli,varname_dl,eq,0)  no varname given\n*          mvi   varname_dl,1         default\n*          mvi   varname,c'*'           to '*'\n*          oi    options,opt_generic+opt_all\n*          trclog 'set all vars'\n*        endif\n*\n         call  Vload\n         if    (ltr,r15,r15,z)\n           call  Vdel\n         endif\n*\n         #subr exit,rc=(r15)\n         #subr drop\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n* RLIST: show list of REXX variables                                  *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\nRList    #subr xprolog=SubrProl,xepilog=SubrEpil\n*\n         mvc   varpool,=cl16')TEMP'\n         sr    r1,r1\n         call  VSave\n*\n         if    (ltr,r15,r15,z)\n           ni    options,255-opt_generic\n           oi    options,opt_all\n           call  VList\n           mvc   rlistcnt,vlistcnt\n           zap   vlistcnt,=p'0'\n         endif\n*\n         #subr exit,rc=(r15)\n         #subr drop\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n* RCOPY:   copy REXX variables with a prefix                          *\n* Syntax                                                              *\n*   COPY VAR(varmask) PREFIX(text)                                    *\n* Sadly it is not possible to use REXX VGET NEXT followed by REXX     *\n* VPUT because the VPUT will clear the internal REXX next-ptr.        *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\nRCOPY    #subr xprolog=SubrProl,xepilog=SubrEpil\n         if    (tm,options,opt_generic,z) descrete name?\n           emsg  'VAR must be generic',rc=8\n           #subr exit\n         endif\n         if    (cli,prefix_dl,eq,0)\n           emsg  'Prefix missing',rc=8\n           #subr exit\n         endif\n*\n         mvc   varpool,=cl16')TEMP'\n         Call  VSave                   save selected\n         oi    options,opt_all\n         Call  Vload                   load all, with rename\n*\n         #subr exit\n         #subr drop\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n*         MAP  - map PACB structure                                   *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\nMap      #subr xprolog=SubrProl,xepilog=SubrEpil\n         using PACBblk,r8\n         using VCBanchr,r6\n*-\n* get total active count\n*-\n         sr    r4,r4                   active\n         sr    r5,r5                   total\n         l     r8,PACBhead\n         strmake logr,'N/T name ',ntname,lenreg=r3\n         SayOrList logr,(3)\n         clear logr\n*\n         Do    until,(ltr,r8,r8,z)\n           la    r5,1(,r5)\n           st    r8,fw\n           if    (cli,pacbname,ne,c'-'),then=(la,r4,1(,r4))\n           la    r6,PACBvcba\n           strmake logr,(fw,4,c2x),+1,pacbname,reg=r3\n           if    (=c')SELF',ne,pacbname)\n* compute size\n             l     r14,VCBAaqh\n             l     r15,VCBAaqn\n             sr    r1,r1\n             do    over(r15)\n               a     r1,VCBsize-VCB(,r14)\n               l     r14,VCBnext-VCB(,r14)\n             enddo\n             st    r1,fw\n             strmake ((r3)),                                           c\n               ' aqn ',(VCBAaqn,4,cvd,6),                              c\n               ' aqh ',(VCBAaqh,4,cvxd),                               c\n               ' aqt ',(VCBAaqt,4,cvxd),                               c\n               ' siz ',(fw,4,cvd,8),                                   c\n               ' fqn ',(VCBAfqn,4,cvd,2),                              c\n               ' csr ',(VCBAcsrp,4,cvxd),reg=r3\n             la    r2,logr\n             sr    r3,r2\n             SayOrList logr,(r3)\n             clear logr\n             if    (cli,xtended,eq,c'Y')\n               l     r2,VCBAaqh\n               using VCB,r2\n               l     r2,VCBnext\n               l     r3,VCBAaqn\n               bctr  r3,0\n               sr    r1,r1\n               do    over(r3)\n                 stm   r2,r3,dw\n                 strmake logr,'ent ',(dw,4,c2x),                       c\n               ' sz ',(VCBsize,4,cvd,6),                               c\n               ' nl ',(VCBnamel,4,cvd,3),                              c\n               ' dl ',(VCBdatal,4,cvd,6),                              c\n               +1,(VCBname,f.vcbnamel,,30),                            c\n               =74,(f.VCBdataa,f.vcbdatal,,40),                        c\n               reg=r3\n                 la    r2,logr\n                 sr    r3,r2\n                 SayOrList logr,(r3)\n                 clear logr\n                 lm    r2,r3,dw\n                 l     r2,VCBnext\n               enddo\n               drop  r2\n             endif\n           endif\n           clear logr\n           l     r8,PACBnext\n         Enddo\n*\n         strmake logr,'Allocated ',(r5,,cvdr,4),                       c\n               ' active ',(r4,,cvdr,4),lenreg=r3\n         SayOrList logr,(r3)\n         clear logr\n*\n         if    (cli,liststem_dl,ne,0)\n           strp2d from=stemnum,to=dw\n           RxStemPut stema=wrkname,base=(liststem,b.liststem_dl),      c\n               num=f.zero,data=dw\n         endif\n*\n         #subr exit\n         #subr drop\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n*         VSAVE: copy variable from REXX and store into pool          *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\nVSave    #subr xprolog=SubrProl,xepilog=SubrEpil\n         sr    r5,r5                      preset counter\n         sr    r7,r7                      preset rc\n*\n         Pool  loc,0\n         if    (nz)\n           Pool  add,0\n           if    (ltr,r2,r15,nz)\n             SubEnd text='Pool add failed',maxrc=8\n           endif\n         endif\n*-\n* save descrete\n*-\n         if    (tm,options,opt_generic,z) descrete name?\n           trclog 'descrete'\n           la    r1,varname\n           l     r0,varnamel\n           Call  REXXVGET                 go get variable data\n           if    (ltr,r15,r15,nz)\n             SubEnd maxrc=&SaveNoVarRc,text='Descrete var not found'\n           endif\n           trclog 'call VCBput'\n           VCBcall VCBput,                                             c\n               name=(varname,b.varname_dl),data=(f.vardataa,f.vardatal)\n           if    (nz)\n             SubEnd ctext='Write to pool failed',maxrc=8\n           endif\n           mvc   vsavecnt,p1\n           trclog 'call VCBput done'\n           #subr exit,rc=0\n         endif\n*-\n* save generic\n*-\n         trclog 'generic'\n         l     r3,PACBcur\n         STRMAKE logr,'anchor ',(PACBcur,4,cvxd),' ',((r3),8)\n         trclog ,\n         do forever\n           Call  REXXVNXT                 get next\n           if    (ltr,r15,r15,nz),then=leave  end of list ??\n           trclog 'call VCBput'\n           VCBCall VCBPut,             add/update VCB                  c\n               name=(rnvvar,f.rnvvarl),data=(f.vardataa,f.vardatal)\n           lr    r2,r15\n           strmake logr,'call VCBput rc ',(r2,,cvdr,6)\n           trclog\n           if    (ltr,r2,r2,nz)\n             SubEnd ctext='Write to pool failed',maxrc=8\n           endif\n           la    r5,1(,r5)\n           ap    vsavecnt,p1\n         enddo\n\n         if    (cp,vsavecnt,eq,p0)\n           SubEnd maxrc=&SaveNoVarRc,text='Generic var not found'\n         endif\n         #subr exit,rc=0\n         #subr drop\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n*         VLOAD: load variables from pool into REXX                   *\n*                                                                     *\n* reg use                                                             *\n*   r5 : cond code                                                    *\n*   r6 > VCB                                                          *\n*                                                                     *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\nVLoad    #subr xprolog=SubrProl,xepilog=SubrEpil\n         Using VCB,r6\n         Using VCBANCHR,r8\n\n*\n         Pool  loc,0\n         if    (nz)\n           emsg  'Pool not found',rc=&NoPoolRc\n           #subr end,rc=0\n         endif\n*\n         lr    r8,r1\n         if    (icm,r3,15,varnamel,nz)\n           STRMAKE logr,'VLOAD name ',(varname,(r3),,60)\n           TrcLog ,\n         else\n           TrcLog 'VLOAD all'\n         endif\n\n*- descrete\n         if    (tm,options,opt_generic,z)\n           VCBlocate name=(varname,f.varnamel)\n           lr    r5,r15\n           lr    r6,r1                   -> VCB\n           strmake logr,'locate rc ',(r5,,cvdr,6)\n           trclog\n           if    (ltr,r5,r5,z)\n             RexxPut (vcbvar,f.vcbnamel),(f.vcbdataa,f.vcbdatal)\n             ap    vloadcnt,p1\n             lr    r5,r15\n             #subr end,rc=0\n           endif\n           emsg  'Variable not found',rc=&NullLoadRc\n           #subr end,rc=0\n         endif\n\n*- generic\n         xc    pgetnxtp,pgetnxtp\n         Do    forever\n           PGetNext vcba=(r8),name=(varname,varnamel),                 c\n               cursor=pgetnxtp,pl=parmlist\n           if    (nz),then=leave\n           lr    r6,r1                   -> VCB\n           if    (cli,prefix_dl,eq,0)\n* write variable as received\n             RexxPut (vcbvar,f.vcbnamel),(f.vcbdataa,f.vcbdatal)\n           else\n* copy name after prefix, compute new length\n             lb    r3,prefix_dl          prefix length\n             la    r2,prefix\n             ar    r2,r3                 -> after prefix\n             l     r15,vcbnamel\n             bctr  r15,0\n             mvc   0(*-*,r2),vcbname\n             ex    r15,*-6\n             la    r3,1(r3,r15)          new length\n             STRMAKE logr,'load newname ',(prefix,(r3),,40),           c\n               '=',(f.vcbdataa,f.vcbdatal,,50)\n           trclog\n             RexxPut (prefix,(r3)),(f.vcbdataa,f.vcbdatal)\n           endif\n           ap    vloadcnt,p1\n         Enddo\n\n         if    (cp,vloadcnt,eq,p0)\n           emsg  'Variable not found',rc=&NullLoadRc\n         endif\n         #subr end,rc=0\n         #subr drop\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n*         VRETURN: return contents of a variable                      *\n*                                                                     *\n* reg use                                                             *\n*   r5 : cond code                                                    *\n*   r6 > VCB                                                          *\n*                                                                     *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\nVReturn  #subr xprolog=SubrProl,xepilog=SubrEpil\n         Using VCB,r7\n*\n         Pool  loc,0\n         if    (nz)\n           emsg  'Pool not found'\n           la    r0,=c' '                set\n           sr    r1,r1                     'null data'\n           stm   r0,r1,rtndef\n           #subr end,rc=0\n         endif\n*\n         l     r8,PACBcur                -> VCB anchor\n         trclog 'locate'\n         VCBLocate name=(varname,f.varnamel),anchor=(r8)\n         if    (ltr,r15,r15,z)           got it\n           lr    r7,r1                   -> VCB\n           trclog 'data to return'\n           l     r0,VCBdataa             addr of data\n           l     r1,VCBdatal             size of data\n         else\n           trclog 'no data to return'\n           la    r0,=c' '                set\n           sr    r1,r1                     'null data'\n         endif\n         stm   r0,r1,rtndef\n         #subr exit\nvrtrnptr ds    a\n         #subr drop\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n* VADD - add data directly to the pool                                *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n\nVAdd     #subr xprolog=SubrProl,xepilog=SubrEpil\n         Using VCBAnchr,r8\n*\n         if    (tm,options,opt_generic,o)\n           emsg 'Generic variable not allowed',rc=8\n           #subr exit\n         endif\n         if    (cli,value_dl,ne,0),and,(cli,valvar_dl,ne,0)\n           emsg 'Mutually exclusive parameters',rc=8\n           #subr exit\n         endif\n         if    (cli,value_dl,eq,0),and,(cli,valvar_dl,eq,0)\n           emsg 'Required parameter missing',rc=8\n           #subr exit\n         endif\n*\n         Pool  loc,0\n         if    (nz)\n           Pool  add,0\n           if    (ltr,r2,r15,nz)\n             emsg  'Pool create failed',rc=(r2)\n             #subr end,rc=8\n           endif\n         endif\n         l     r8,PACBcur             VCB anchor\n\n* setup for either 'value' in parm, or by 'valver' variable\n         if    (cli,value_dl,ne,0)    in-parm value\n           trclog 'value'\n           sr    r1,r1\n           ic    r1,value_dl          value length\n           st    r1,vadddl\n           la    r1,value             value address\n           st    r1,vaddda\n         endif\n\n         if    (cli,valvar_dl,ne,0)   by variable\n           trclog 'valvar'\n*          Name is defined by r1 address) and r0 (length)\n*          Returns data via vardataa/vardatal.\n           la    r1,valvar\n           sr    r0,r0\n           ic    r0,valvar_dl\n           call  REXXVGET\n           if    (ltr,r15,r15,nz)\n             emsg 'VALVAR name not found',rc=8\n             #subr exit\n           endif\n           mvc   vaddda,vardataa\n           mvc   vadddl,vardatal\n         endif\n\n         STRMAKE logr,'VADD ',                                         c\n               (varname,f.varnamel,,40),'=',(f.vaddda,f.vadddl,,60)\n         TrcLog ,\n\n* if the last chars of varname='.+' then\n*   get &varname.0 from pool. make &varname.0 if not found\n*   &varname.0=1+&varname.0\n*   &varname=varname.\n\n         la    r6,varname\n         a     r6,varnamel             -> after name\n         lr    r1,r6\n         ahi   r1,-2                   -> '.+'\n*-\n* add varname\n*-\n         if    (=c'.+',ne,0(r1))       normal name add\n           trclog 'VADD normal'\n           VCBput name=(varname,f.varnamel,,40),                       c\n               data=(f.vaddda,f.vadddl,,40)\n           ap    vsavecnt,p1\n           #subr exit\n         endif\n*-\n* add var.+1\n*-\n         trclog 'VADD get .0'\n* generate and write varname.0\n         bctr  r6,0                    -> '+'\n         mvi   0(r6),c'0'              &varname.0\n         VCBget name=(varname,f.varnamel),data=wrk256\n         lr    r2,r0                   data length from VCBget\n         if    (nz),or,(ltr,r2,r2,z)   not found\n           zap   stemnum,=p'0'\n         else\n           bctr  r2,0\n           j     *+10\n           pack  stemnum,wrk256(*-*)\n           ex    r2,*-6\n         endif\n         ap    stemnum,=p'1'            add one\n         unpk  dw,stemnum\n         oi    dw+7,x'f0'\n         VCBput name=(varname,f.varnamel),data=dw    write stemname.0\n         ap    vsavecnt,p1\n*generate and write varname.n\n         trclog 'write varname.n'\n         l     r2,varnamel\n         bctr  r2,0                    minus '+'\n*\n         RxStemname base=(varname,(r2)),stema=wrkname,pnum=stemnum\n         lr    r2,r0                   length of name\n         VCBput name=(wrkname,(r2)),data=(f.vaddda,f.vadddl)\n         ap    vsavecnt,p1\n\n         #subr exit\n         #subr drop\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n*         VDEL : delete variables from pool (logical delete) -        *\n*                move to 'deleted' queue.                             *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\nVDel     #subr xprolog=SubrProl,xepilog=SubrEpil\n         Using VCB,r6\n         Using VCBANCHR,r8\n*\n         if    (cli,varname_dl,eq,0)\n           emsg  'Missing var parm',rc=8\n           mvc   logr,emsg\n           trclog\n           #subr exit\n         endif\n*\n         Pool  loc,0\n         if    (nz)\n           emsg  'Pool not found',rc=8\n           mvc   logr,emsg\n           trclog\n           #subr exit,rc=8\n         endif\n*\n         lr    r8,r1\n         xc    pgetnxtp,pgetnxtp\n         Do    forever\n           PGetNext vcba=(r8),name=(varname,varnamel),                 c\n               cursor=pgetnxtp,pl=parmlist\n           if    (nz),then=leave\n           lr    r6,r1                   -> VCB\n           mvc   pgetnxtp,VCBprev        use ptr before\n           STRMAKE logr,'VDEL ',(varname,f.varnamel,,60)\n           trclog\n           lr    r1,r6                    -> VCB to delete\n           VCBCall VCBDel,anchor=(r8)\n           ap    vdelcnt,=p'1'\n         Enddo\n*\n         #subr exit\n         #subr drop\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n* VList - show names in pool                                          *\n* Syntax:                                                             *\n*  LIST VAR(name) POOL(pool) LENGTH NW(name-width) DW(data-width)     *\n* Register usage:                                                     *\n*  r12: local base                                                    *\n*  r10: global storage                                                *\n*  r09: local branch                                                  *\n*  r08: VCBanchor                                                     *\n*  r07: VCB queue                                                     *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\nVLIST    #subr xprolog=SubrProl,xepilog=SubrEpil\n         Using VCB,r7\n*\n         Pool  loc,0\n         if    (nz)\n           emsg  'Pool not found',rc=&NoPoolRc\n           #subr end,rc=1\n         endif\n         lr    r8,r1                     PAcb\n*\n         if    (cli,function,ne,c'R')    no heading for RLIST\n           strmake logr,'Pool name ',(pacbname-pacb(r8),16),lenreg=r3\n           SayOrList logr,(r3),counter=vlistcnt\n         endif\n         zap   vlistcnt,p0               don't count the header\n*\n         xc    pgetnxtp,pgetnxtp\n         Do    forever\n           PGetNext vcba=(r8),name=(varname,varnamel),                 c\n               cursor=pgetnxtp,pl=parmlist\n           if    (nz),then=leave\n           lr    r7,r1                   -> VCB\n*- trace\n           TrcBlk\n           la    r4,VCBvar\n           a     r4,VCBnamel\n           strmake logr,'vcbdata ',                                    c\n               (vcbnamel,4,cvd,4),+1,(vcbdatal,4,cvd,6),               c\n               +1,(vcbvar,f.vcbnamel,,30),                             c\n               +1,((r4),f.vcbdatal,,40)\n           trclog ,\n           TrcBlkEnd\n\n*- make list line\n           clear wrk64k,l=255\n           la    r5,wrk64k           -> name in output buffer\n           la    r6,wrk64k+2         -> data in\n           a     r6,pnw                output buffer\n           if    (cli,length,eq,c'Y')\n             strmake wrk64k,(vcbnamel,4,cvd,4),                        c\n               ':',(vcbdatal,4,cvd,8),' '\n             la    r5,15(,r5)        past length\n             la    r6,15(,r6)          fields\n           endif\n           StrMake ((r5)),(vcbvar,f.vcbnamel,,f.pnw),reg=r2\n           if    (pnw,eq,zero)       unformatted name width\n             la    r6,1(,r2)         data immediately following name\n           endif\n           StrMake ((r6)),(f.vcbdataa,f.vcbdatal,,f.pdw),reg=r2\n           la    r1,wrk64k\n           sr    r2,r1\n           SayOrList wrk64k,(r2),counter=vlistcnt\n         Enddo\n\n*- stats after processing\n         if    (cli,liststem_dl,eq,0)\n           clear logr\n           STRMAKE logr,'# of records listed: ',(vlistcnt,4,unpk,8),   c\n               lenreg=r5\n           RxSay logr,(r5)\n         else ,                      write stem.0\n           strp2d from=vlistcnt,to=dw\n           RxStemPut stema=wrkname,base=(liststem,b.liststem_dl),      c\n               num=f.zero,data=dw\n         endif\n         clear logr\n*\n         #subr exit\n         #subr drop\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n* Vindex - return list of pool variable names in a stem               *\n* Syntax:                                                             *\n*  INDEX VAR(name) STEM(stem) POOL(pool)                              *\n* Register usage                                                      *\n*  r6  : VCB                                                          *\n*  r7  : local dsect                                                  *\n*  r12 : global base                                                  *\n*  r11 : local base                                                   *\n*  r10 : global area                                                  *\n*  r9  : local call                                                   *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\nVindex   #subr xprolog=SubrProl,xepilog=SubrEpil\n         Using VCB,r6\n*\n         if    (cli,stemnm_dl,eq,0)\n           emsg  'Missing stemname',rc=8\n           #subr exit\n         endif\n*\n         Pool  loc,0\n         if    (ltr,r2,r15,nz)\n           emsg  'Pool not found',rc=&NoPoolRc\n           #subr end,rc=1\n         endif\n         lr    r8,r1\n*\n         Do    forever\n           PGetNext vcba=(r8),name=(varname,varnamel),                 c\n               cursor=pgetnxtp,pl=parmlist\n           if    (nz),then=leave\n           lr    r6,r1                   -> VCB\n           ap    vlistcnt,p1\n           RxStemPut stema=wrkname,base=(stemnm,b.stemnm_dl),          c\n               pnum=vlistcnt,data=(vcbname,f.vcbnamel)\n         Enddo\n* build stem.0\n         strp2d from=vlistcnt,to=dw\n         RxStemPut stema=wrkname,base=(stemnm,b.stemnm_dl),            c\n               num=f.zero,data=dw\n\n*        if    (cp,VindexStemN,eq,=pl4'0'),then=(la,r2,4)\n         if    (cp,vlistcnt,eq,p0),then=(#subrend,4)\n         #subr exit,rc=0\n         #subr drop\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n* EXPORT  Copy VCBs to file                                           *\n*                                                                     *\n* Register usage                                                      *\n* r6  -> VCB data                                                     *\n* r7  -> remaining data length                                        *\n* r8  -> VCB anchor block                                             *\n* r9  -> VCB located by PGETNEXT                                      *\n* r10 -> global dynamic area                                          *\n* r11 :  base                                                         *\n* r12 -> I/O buffer                                                   *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n\nExport   #subr xprolog=SubrProl,xepilog=SubrEpil\n         Using VCB,r9\n         Using VCBAnchr,r8\n         Using VExpdsct,r12\n*-\n         Pool  loc,0\n         if    (ltr,r2,r15,nz)\n           emsg  'Pool not found',rc=&NoPoolRc\n           #subr end,rc=1\n         endif\n         lr    r8,r1\n         la    r12,wrk64k\n*-\n         STRMAKE logr,'ddname ',(ddname,8)\n         trclog ,\n         Qsam31 open,dcba=vexpdcba,gen=y,ddname=ddname,acc=p\n*-\n         Qsam31 expose,dcba=vexpdcba,field=recl\n         lh    r1,0(,r1)\n         st    r1,Vexplrecl\n         ahi   r1,-8                   minus rdw and length-field\n         st    r1,Vexpmaxdl\n\n         l     r3,Vexplrecl\n         STRMAKE logr,'lrecl ',(r3,,cvdr,5)\n         trclog ,\n\n         xc    vexpptr,vexpptr\n         Do    forever\n           PGetNext vcba=(r8),name=(varname,varnamel),                 c\n               cursor=vexpptr,pl=parmlist\n           if    (nz)\n             if    (clfi,r15,eq,1),then=(sr,r15,r15) 1 = end of vars\n             leave\n           endif\n           lr    r9,r1                   -> VCB\n           call  Export2                 go copy\n           if    (ltr,r15,r15,nz),then=leave\n         Enddo\n         lr    r5,r15                    save rc\n         trclog 'end write'\n\n         Qsam31 close,dcba=vexpdcba,drop=y\n         trclog 'file closed'\n\n         STRMAKE logr,'count ',(vexpcnt,4,p2d,6)\n         trclog ,\n\n         #subr exit,rc=(r5)\n\n* build and write record\n*  r5  -> start of source segment\n*  r6  -> end of source segment\n*  r7  -> end of source\n*  r8  -> VCB anchor\n*  r9  -> VCB\n*  r11 -> dynamic area incl i/o buffer\nExport2  #subr label\n* log it\n         trcblk\n         l     r2,VCBnamel\n         l     r3,VCBdatal\n         la    r4,VCBvar\n         a     r4,VCBnamel\n         STRMAKE logr,'write ',(VCBnamel+2,2,cvd),' ',                 c\n               (VCBdatal,4,cvd,6),' ',                                 c\n               (VCBvar,(r2),,30),'=',((r4),(r3),,40)\n         trclog ,\n         trcblkend\n\n* initialize before write\n         l     r1,VCBnamel\n         a     r1,VCBdatal\n         la    r1,8(,r1)               plus length fields\n         st    r1,vexpreclen           save combined length\n         la    r7,VCBnamel\n         ar    r7,r1                   -> last source byte\n         la    r5,VCBnamel             -> start of source\n\n         sr    r4,r4                  save number of segments\n         do    forever\n           lr    r6,r5\n           a     r6,vexpmaxdl\n           if    (cr,r6,gt,r7)        past source end?\n             lr    r6,r7              then use last\n           endif\n           lr    r2,r6                copy end address\n           sr    r2,r5                get length\n           StrCopy from=((r5),(r2)),to=(vexprecdata,(r2))\n           la    r2,8(,r2)            plus rdw and length\n           sll   r2,16\n           st    r2,vexprecrdw\n           Qsam31 put,dcba=vexpdcba,data=vexprecrdw\n           la    r4,1(,r4)\n           lr    r5,r6                bump source\n           if    (cr,r5,ge,r7),then=leave\n           xc    vexpreclen,vexpreclen\n         enddo\n*\n         strmake logr,'write done, ',(r4,,cvdr,4),' segments'\n         trclog\n*\n         ap    vexpcnt,p1\n         #subr end\n         #subr drop\n\nVexpDsct    dsect\nvexplrecl   ds   a\nvexpmaxdl   ds   a\nvexpptr     ds   a\nvexpdcba    qsam31 dcba\nVexprec     ds    0a\nVexprecrdw  ds    a\nVexpreclen  ds    a\nVexprecdata ds    0c\n            ds    xl32800\n            ds    0d\nVexpdsctl   equ   *-vexpdsct\n*-\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n* IMPORT   copy variables from file to pool                           *\n* register usage                                                      *\n*  r11  base                                                          *\n*  r8   VCB anchor (not really needed)                                *\n*  r7   I/O buffer 327800 bytes                                       *\n*  r6   structure buffer                                              *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\nImport   #subr xprolog=SubrProl,epilog=ImportX  SubrEpil\n         Using vimpstrb,r6\n         Using vimpiob,r7\n         la    r7,wrk64k                 copy ptr\n         xc    vimpdcba,vimpdcba\n         xc    vimpstrbl,vimpstrbl\n*- open\n         trclog 'open'\n         Estaexx a,addr=importoe\n         Qsam31 open,dcba=vimpdcba,ddname=ddname,acc=g,eod=vimpeof,    c\n               gen=y\n         Estaexx c\n         mvi   vimpopen,c'Y'\n         trclog 'open done'\n*-\n         Qsam31 expose,dcba=vimpdcba,field=recl\n         lh    r3,0(,r1)\n         st    r3,vimpdcblr\n         STRMAKE logr,'lrecl ',(r3,,cvdr,5)\n         trclog ,\n*- VCB pool\n         Pool  loc,0\n         if    (nz)\n           Pool  add,0\n           if    (nz)\n             emsg  'Pool create failed',rc=8\n             #subr end,rc=8\n           endif\n         endif\n*-\n         GETMAIN R,LV=40000,LOC=31       resultant structure area\n         lr    r6,r1                     copy ptr\n         mvc   vimpstrbl,=a(40000)\n\n*construct name/data structure from one or more records\n       Do forever                    till eof\n         trclog 'Get vimpdcb'\n         Qsam31 Get,dcba=vimpdcba,data=vimpiorec\n         l     r3,vimpiorec+4        name+data length\n         clear logr\n         STRMAKE logr,'imprec ',(vimpiorec,16,cvxd),                   c\n               +1,(vimpiorec+16,(r3),,80)\n         trclog ,\n* ensure structure work area is big enough\n         if    (vimpioblkl,gt,vimpstrbl) will entire record fit?\n           trclog 'realloc structure bfr'\n           l     r2,vimpstrbl\n           FREEMAIN R,LV=(2),A=(6)\n           l     r2,vimpioblkl        new blklen\n           srl   r2,12                d by 4096\n           sll   r2,12                m by 4096\n           ahi   r2,8192              plus some\n           GETMAIN R,LV=(2),LOC=31    new structure buffer\n           lr    r6,r1\n           st    r2,vimpstrbl\n         else\n           trclog 'data fits in buffer'\n         endif\n\n* copy initial data to structure\n         lh    r2,Vimpiorl\n         ahi   r2,-4                  minus rdw\n         StrCopy from=(vimpiodata,(2)),to=(vimpstr,(r2))\n\n* add additional records to structure\n         l     r5,vimpstrl            size of structure in file\n         sr    r4,r4                  prep for divide\n         lh    r1,vimpiorl            input data\n         ahi   r1,-4                    length (minus rdw)\n         dr    r4,r1                  r5 = number of addntl records\n\n         la    r4,vimpstr             -> structure\n         ah    r4,vimpiorl            add current\n         ahi   r4,-4                  minus rdw\n         do    over(r5)\n           trclog 'read 2nd'\n           Qsam31 Get,dcba=vimpdcba,data=vimpiorec\n           STRMAKE logr,'imprec2 ',(vimpiorec,40,cvxd)\n           trclog ,\n           lh    r2,Vimpiorl\n           ahi   r2,-8                minus rdw and length field\n           StrCopy from=(vimpioblkl+4,(r2)),to=((r4),(r2))\n           ar    r4,r2                -> end of added\n         enddo\n\n*if varname then check\n         if    (tm,options,opt_all,z)\n           StrPatrn data=(Vimpstrnm,f.vimpstrnl),                      c\n               mask=(varname,b.varname_dl)\n           if    (nz)\n             trclog 'pattern check failed'\n             iterate\n           endif\n         endif\n\n*make VCB\n         la    r3,Vimpstrnm           -> name\n         a     r3,vimpstrnl           + name length -> data\n         VCBCall VCBPut,                 add VCB                       c\n               name=(Vimpstrnm,f.vimpstrnl),                           c\n               data=((r3),f.vimpstrdl)\n         if    (ltr,r15,r15,nz)\n           trclog 'vcbput fail'\n           #subr exit,rc=8\n         endif\n         ap    vimpcnt,p1\n       Enddo\n*-\nVImpEof  cnop  0,4\n         trclog 'eof'\n         #subr exit,rc=0\n*- import open error\nimportoe cnop  0,4\n         Estaexx c\n         trclog 'open failed'\n         strmake emsg,'open ',ddname,' ',estxtext,lr=r14\n         st    r14,emsgl\n         SetMaxRc 8\n         #subr exit,rc=8\n*\nImportx  #subr label\n         trclog 'closing'\n         Qsam31 close,dcba=vimpdcba,drop=y\n         if    (lt,r2,vimpstrbl,nz)\n           trclog 'freeing'\n           FREEMAIN R,LV=(2),A=(6)\n           trclog 'free done'\n         else\n           trclog 'free bypassed'\n         endif\n         Call  subrEpil\n         #subr end\n         #subr drop\n*-\n* Vimpiob, i/o area, pointed by r7\nVimpiob    Dsect\nvimpdcba   Qsam31 dcba\nvimpopen   ds    c\nvimpdcblr  ds    a\nvimpstrbl  ds    a\nVimpiorec  ds    0a\nVimpiordw  ds    0a\nVimpiorl   ds    h\n           ds    h\nVimpiodata ds    0a\nVimpioblkl ds    a\n\n* Vimpstrb pointed to by r6\nVimpstrb   Dsect\nVimpstr    ds    0a\nVimpstrl   ds    a\nVimpstrnl  ds    a\nVimpstrdl  ds    a\nVimpstrnm  ds    0c\n*-\n\n ago .pbrifend\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n*        PoolBRIF: browse variables in pool                           *\n*        r12: local base                                              *\n*        r10: global storage                                          *\n*        r09: local branch                                            *\n*        r08: VCBanchor                                               *\n*        r07: VCB queue                                               *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n         MACRO\n&NAME    ISPLINK &OPRNDS,&ERRET=\n         GBLB  &IHBSWA\n&IHBSWA  SETB  1                       VL=1\n&NAME    LA    R1,PARMLIST             parm list\n         IHBOPLST ,&OPRNDS,MF=(E,(1))\n         L     R15,ISPLINK@            ISPLINK bootstrap\n         BALR  R14,R15                 invoke ISPLINK\n         AIF   (T'&ERRET EQ 'O').MEND\n         LTR   R15,R15                 Any error?\n         BNZ   &ERRET                  yes, jump\n.MEND    MEND\n\nPoolBRIF #subr , base=r11\n         Using VCB,r7\n         Using VCBAnchr,r8\n         l     r8,PACBcur                VCB anchor\n         zap   pbrifCnt,=p'0'            reset counter\n\n* setup parmlist for ISPLINK\n         la    r1,=cl8'BRIF'           function\n         la    r2,=cl1' '              title\n         la    r3,=c'V '\n         l     r4,vcbavmaxndl\n         la    r4,4(,r1)\n         st    r4,pbriflrecl\n         la    r4,pbriflrecl\n         la    r5,PBRIFR\n         stm   r1,r5,pbrifpl\n         oi    pbrifplv,x'80'          set VL\n         la    r1,pbrifpl\n         Link  EP=ISPLINK\n\n         if    (cp,pbrifCnt,eq,=pl4'0'),then=(la,r2,4)\n         #subr exit rc=(r2)\n\npbrifpl  ds    5a\npbrifplv equ   *-4\npbrifWk  ds    4a\npbrifCnt ds    pl4\npbrifCx1 clc   VCBvar(*-*),varname\n\n* VCB found, now format\npbrif2   ds    0a\n*        trclog 'pbrif2'\n         if    (cli,xtended,ne,c'Y')\n*          trclog 'not extended'\n           if    (c,r7,eq,VCBAaqh),or,(c,r7,eq,VCBAaqt),then=(br,r9)\n         endif\n\n         clear logr\n         la    r5,logr\n* format extended\n         if    (cli,xtended,eq,c'Y')\n*          trclog 'Extended'\n           st    r7,fw\n           StrC2X from=(fw,4),to=logr\n           if    (c,r7,eq,VCBAaqh)\n              mvi   8(r5),c'<'\n           endif\n           if    (c,r7,eq,VCBAaqt)\n              mvi   8(r5),c'>'\n           endif\n           la    r5,9(,r5)\n\n           st    r7,fw\n           STRMAKE logr,'VLIST match at ',(fw,4,cvxd)\n           trclog\n\n           l     r2,VCBnamel\n           cvd   r2,dw\n           unpk  0(4,r5),dw+6(2)\n           oi    3(r5),x'f0'\n           la    r5,5(,r5)\n\n           l     r3,VCBsize\n           cvd   r3,dw\n           unpk  0(4,r5),dw+6(2)\n           oi    3(r5),x'f0'\n           la    r5,5(,r5)\n\n           l     r3,VCBdatal\n           cvd   r3,dw\n           unpk  0(4,r5),dw+6(2)\n           oi    3(r5),x'f0'\n           la    r5,5(,r5)\n         endif\n*\n         l     r2,VCBnamel\n         l     r3,VCBdatal\n         la    r4,VCBvar\n         ar    r4,r2\n         STRMAKE logr,'Vlist2 ',                                       c\n               (VCBvar,(r2),,40),'=',((r4),(r3),,40)\n         trclog  ,\n\n         l     r2,VCBnamel\n         l     r3,VCBdatal\n         la    r4,VCBvar\n         if    (c,r2,gt,=a(35))            vname length\n           mvc   0(34,r5),0(r4)\n           mvi   34(r5),c'+'\n         else\n           bctr  r2,0\n           mvc   0(*-*,r5),0(r4)           vname lt 35\n           ex    r2,*-6\n         endif\n         la    r5,36(,r5)\n\n         a     r4,VCBnamel                -> data\n         if    (ltr,r3,r3,nz)\n           if    (c,r3,gt,=a(75))            vname length\n             mvc   0(74,r5),0(r4)\n             mvi   74(r5),c'+'\n           else\n             bctr  r3,0\n             mvc   0(*-*,r5),0(r4)           vname lt 35\n             ex    r3,*-6\n           endif\n         endif\n\n         trclog 'pbrif2 return'\n         br    r9\n\nPBRIFRECFM  DS    C'V '\n         ltorg\n         #subr drop\n\n* ------------------------------------------------------------------- *\n*         Pool BRIF read routine                                      *\n* ------------------------------------------------------------------- *\npbrifr   #subr\n         #subr exit\n.pbrifend anop\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n* STEMIX: Enum a stem.                                                *\n* Syntax: STEMIX stem(name.)                                          *\n* i.e. city.sydney -> 'SYDNEY' in stem.1                              *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\nStemIx   #subr xprolog=SubrProl,xepilog=SubrEpil\n         if    (cli,stemnm_dl,eq,0)\n           emsg 'STEM parameter missing'\n           #subr exit,rc=8\n         endif\n*-\n* 1 - make pool with selected stem variables\n*-\n         mvc   varpool,=cl16')TEMP'\n         pool  loc,0\n* add '*' at the end if not already there\n         mvc   varname,stemnm\n         mvc   varname_dl,stemnm_dl\n         la    r1,varname\n         sr    r15,r15\n         ic    r15,varname_dl\n         ar    r1,r15                    -> after name\n         bctr  r1,0                      -> last byte\n         if    (cli,0(r1),ne,c'*')\n           if    (cli,0(r1),eq,c'.')\n             mvi   1(r1),c'*'            add generic\n             la    r15,1(,r15)\n             stc   r15,varname_dl        update length\n             trclog 'genchar added'\n           endif\n         endif\n         call  vsave\n*-\n* 2 - build stem with suffix as data\n*-\n         trclog 'build stems'\n         using  VCB,r6\n         xc    pgetnxtp,pgetnxtp\n         oi    options,opt_all\n         l     r8,PACBcur\n         Do    forever\n           PGetNext vcba=(r8),name=(stemnm,stemnml),                   c\n               cursor=pgetnxtp,pl=parmlist\n           if    (nz),then=leave\n           lr    r6,r1                   -> VCB\n* point to suffix\n           lb    r2,stemnm_dl            length of base\n           la    r4,VCBname\n           ar    r4,r2                   past base\n           if    (cli,0(r4),ge,c'0')     may not be numeric\n             iterate\n           endif\n           la    r4,VCBname\n           ar    r4,r2\n           l     r3,VCBnamel\n           sr    r3,r2\n           ap    vloadcnt,p1\n           RxStemPut stema=wrkname,base=(stemnm,b.stemnm_dl),          c\n               pnum=vloadcnt,data=((r4),(r3))\n           lr    r2,r0\n           strmake logr,(wrkname,(r2),,40),'=',((r4),(r3),,60)\n           trclog\n         Enddo\n         drop  r6\n* stem.0\n         unpk  dw,vloadcnt\n         oi    dw+7,x'f0'\n         RxStemPut stema=wrkname,base=(stemnm,b.stemnm_dl),            c\n               pnum=p0,data=dw\n*-\n* back\n*-\n         #subr exit\n         #subr drop\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n* RINDEX   make a list (stem) of REXX variable names                  *\n*  Syntax: RINDEX var(varname) STEM(stemname)                         *\n*                                                                     *\n*  We need to VSAVE up front as REXX do not allow mix of READNEXT     *\n*  and PUT.                                                           *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\nRINDEX   #subr xprolog=SubrProl,xepilog=SubrEpil\n*\n         if    (tm,options,opt_generic,z)\n           emsg  'Var is not generic',rc=8\n           #subr exit,rc=8\n         endif\n         if    (cli,stemnm_dl,eq,0)\n           emsg  'STEM missing',rc=8\n           #subr exit,rc=8\n         endif\n*\n         mvc   varpool,=cl16')TEMP'\n         pool  loc,0\n*\n         do forever\n           Call  REXXVNXT                 get next\n           if    (ltr,r15,r15,nz),then=leave  end of list ??\n           ap    vsavecnt,p1\n           RxStemname base=(stemnm,b.stemnm_dl),                       c\n               stema=wrk256,pnum=vsavecnt\n           lr    r2,r0                 length of name\n           strmake logr,'VCBput ',(wrk256,(r2),,40),                   c\n               '=',(rnvvar,f.rnvvarl,,60)\n           trclog\n           VCBcall VCBput,name=(wrk256,(r2)),data=(rnvvar,f.rnvvarl)\n           lr    r2,r15\n           strmake logr,'VCBput rc ',(r2,,cvdr,6)\n           trclog\n           if    (ltr,r2,r2,nz),then=(leave)\n         enddo\n* stem.0\n         RxStemname base=(stemnm,b.stemnm_dl),stema=wrk256,pnum=p0\n         lr    r2,r0                     length of name\n         unpk  dw,vsavecnt\n         oi    dw+l'dw-1,x'f0'\n         VCBcall VCBput,name=(wrk256,(r2)),data=(dw,l'dw)\n*\n         oi    options,opt_all           get all from pool\n         call  VLoad\n*\n         #subr exit,rc=0\n         #subr drop\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n* RSTAT:   return number and total size of varfiables                 *\n*  Syntax:  RSTAT var(varmask)                                        *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\nRSTAT    #subr xprolog=SubrProl,xepilog=SubrEpil\n*\n         if    (icm,r15,15,varnamel,z)\n           emsg  'Mising VAR',rc=8\n           #subr exit,rc=8\n         endif\n         if    (tm,options,opt_generic,z)\n           emsg  'Var is not generic',rc=8\n           #subr exit,rc=8\n         endif\n*\n         strmake logr,'varname \"',(varname,f.varnamel),'\"'\n         trclog ,\n*\n         RxVGet reset\n         sr    r7,r7                   total data length\n         sr    r8,r8                   count\n         do    forever\n           RxVnext name=wrk256,data=(0,0)\n           if    (tm,zrx_SHVRET,SHVLVAR,o),then=leave\n           lr    r5,r1                 copy name length\n           lr    r6,r0                 copy data length\n           strmake logr,(wrk256,(r5),,30),+1,(r6,,cvdr,8)\n           trclog ,\n           StrPatrn data=(wrk256,(r5)),mask=(varname,f.varnamel)\n           if    (ltr,r15,r15,nz),then=iterate\n           trclog 'passed'\n           ar    r7,r6                 total data size\n           la    r8,1(,r8)             count\n         enddo\n*\n         strmake rxtext,'count ',(r8,,cvdr,8),' dtotz ',(r7,,cvdr,12), c\n               lr=r3\n         la    r2,rxtext\n         stm   r2,r3,rtndef\n*\n         #subr exit,rc=0\n         #subr drop\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n*                       Get variable from REXX                        *\n*  Name to look for is defined by r1 (pointer) and r0 (length)        *\n*  Returns data via vardataa/vardatal.                                *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\nREXXVGET #subr xprolog=SubrProl,xepilog=SubrEpil\n         xc    vardatal,vardatal\n         lr    r4,r1                   name address\n         lr    r5,r0                   name length\n         xc    rxrc1(l'rxrc1+l'rxrc2),rxrc1\n         clear rxtext\n\n         STRMAKE logr,'name ',((r4),(r5),,60)\n         trclog\n\n         do forever\n           RxVget name=((r4),(r5)),data=(f.vardataa,f.databfrl)\n           st    r15,fw\n           st    r0,vardatal           save data length\n           lr    r2,r15\n*\n           trcblk\n           strmake logr,'RxVget rc ',(r2,,cvdr,6),reg=r3\n           if    (ltr,r2,r2,z)\n             strmake ,' namel ',(zrx_ShVbVnl,4,cvd,4),                 c\n               ' datal ',(zrx_ShVbVbl,4,cvd,6),                        c\n               ' data ',(f.vardataa,f.zrx_ShVbVbl,,40),reg=r3\n           endif\n           trclog\n           trcblkend\n\n* handle truncation\n           if    (tm,zrx_shvret,zrx_trunc,o)\n             l     r1,zrx_ShVbVbl        get required size\n             call  AcqDatab              reacquire data block\n             if    (ltr,r15,r15,nz),then=(#subrend,8)\n             iterate\n           endif\n           leave\n         enddo\n\n* check rc\n         if    (ltr,r2,r2,nz)\n           strmake emsg,'RxVget rc ',(r2,,cvdr,6),reg=r3\n           st    r3,emsgl\n           #subr end,rc=8\n         endif\n\n* if data=name then => 'not found'\n         if    (c,r5,eq,vardatal)        same length\n           l     r2,vardataa             -> data\n           l     r3,vardatal             length\n           bctr  r3,0\n           if    (ex,r3,REXXVGET_cd,eq)  name=data?\n             trclog 'data=name=>no var'\n             mvlit emsg,'Variable not found',lenreg=r2\n             st    r2,emsgl\n             #subr exit,rc=1             yes\n           endif\n         endif\n*\n         #subr exit,rc=0\nREXXVGET_cd clc 0(*-*,r2),0(r4)\n         #subr drop\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n*                   Get next variable from REXX                       *\n*  Name to look for is defined by the varname/varnamel fields         *\n*  Returns                                                            *\n*   r15 = 0 then                                                      *\n*    returns name via rnvvar/rnvvarl                                  *\n*    returns data via vardataa/vardatal                               *\n*   r15 <>0 then most likely eof                                      *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\nREXXVNXT #subr xprolog=SubrProl,xepilog=SubrEpil\n\n* last record already processed?\n         if    (tm,zrx_ShVRet,shvlvar,o)  all done\n           #subr exit,rc=2\n         endif\n\n* if first time around?\n         if    (RexxVNxtblk(4),eq,zero)\n           RxVNext stats,nl=r3,dl=r5,count=r6\n           StrMake logr,'count ',(r6,,cvdr,6),                         c\n               ' maxnl ',(r3,,cvdr,4),+1,'maxdl ',(r5,,cvdr,4)\n           trclog ,\n           if    (ltr,r6,r6,z)         no variables\n             #subr exit,rc=2\n           endif\n           Getmain R,lv=(r5),loc=31    data max size\n           lr    r4,r1\n           st    r4,vardataa\n           stm   r4,r6,RexxVNxtblk\n         endif\n\n* locate and return value\n         lm    r4,r5,RexxVNxtblk\n         do    forever\n           RxVNext name=rnvvar,data=((r4),(r5))\n           if    (ltr,r15,r15,nz),then=leave\n           mvc   rnvvarl,zrx_ShVbVnl   copy name length\n           mvc   vardatal,zrx_ShVbVbl  copy data length\n           st    r15,fw\n           trcblk\n           strmake logr,'shvret ',(zrx_shvret,1,c2x),                  c\n               ' r15 ',(fw,4,c2x),                                     c\n               +1,(rnvvarl,4,cvd,3),                                   c\n               +1,(vardatal,4,cvd,5),                                  c\n               +1,(rnvvar,f.rnvvarl,,20),                              c\n               '=',((r4),f.vardatal,,40)\n           trclog ,\n           trcblkend\n\n           if    (tm,options,opt_all,o),then=(#subrend,0)\n\n* do pattern check - name\n           StrPatrn data=(rnvvar,f.rnvvarl),mask=(varname,b.varname_dl)\n           lr    r3,r15\n           strmake logr,'pattern name check rc ',(r3,,cvdr,6)\n           trclog\n           if    (ltr,r3,r3,nz),then=iterate\n* do pattern check - data\n           if    (cli,data_dl,ne,0)\n             StrPatrn data=((r4),f.vardatal),mask=(data,b.data_dl)\n             lr    r3,r15\n             strmake logr,'pattern data check rc ',(r3,,cvdr,6)\n             trclog\n             if    (ltr,r3,r3,nz),then=iterate\n           endif\n           #subr end,rc=0              all tests passed\n         enddo\n\n* end of file\n         lm    r4,r5,RexxVNxtblk\n         Freemain R,a=(4),lv=(5)\n         xc    RexxVNxtblk,RexxVNxtblk\n         xc    databfra,databfra\n         #subr exit,rc=2\n         #subr drop\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n*                        Write REXX variable                          *\n* at entry                                                            *\n*  r1 -> a(varname)                                                   *\n*        a(l'varname)                                                 *\n*        a(data)                                                      *\n*        a(l'data)                                                    *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\nREXXVPUT #subr xprolog=SubrProl,xepilog=SubrEpil\n         lr    r6,r1\n\n         lm    r2,r5,0(r6)             load values\n         STRMAKE logr,'RexxVput: ',                                    c\n               ((r2),(r3),,40),'=',((r4),(r5),,60)\n         trclog  ,\n\n         lm    r2,r5,0(r6)             load values\n         RxVput name=((r2),(r3)),data=((r4),(r5))\n         if    (ltr,r5,r15,nz)\n           strmake logr,'RxVput rc ',(r5,,cvdr,4),lenreg=r2\n           mvc   emsg,logr\n           st    r2,emsgl\n           SetMaxRc 8\n         endif\n\n         #subr exit,rc=(r5)\n         #subr drop\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n*               (re)acquire data block storage                        *\n* at entry                                                            *\n*  r1 =  size to acquire                                              *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\nAcqDatab #subr xprolog=SubrProl,xepilog=SubrEpil\n         lr    r6,r1\n* drop old\n         if    (clc,databfra,ne,zero)\n           STRMAKE logr,'Release ',(databfrl,4,cvd,8)\n           trclog ,\n           l     r2,databfra         current block address\n           l     r3,databfrl         current block size\n           STORAGE RELEASE,LENGTH=(3),ADDR=(2)\n         endif\n\n* compute 4k boundary and get\n         a     r6,=a(4093)         required data size\n         srl   r6,12               adjust\n         sll   r6,12                to 4k\n         st    r6,databfrl\n         STRMAKE logr,'Obtain ',(databfrl,4,cvd,8)\n         trclog ,\n         STORAGE OBTAIN,LENGTH=(6),loc=31,cond=YES\n         if    (ltr,r15,r15,nz)\n           lr    r5,r15\n           strmake emsg,'Obtain for ',(r6,,cvdr,6),' rc ',             c\n               (r5,,cvdr,6)\n           mvc   rc+3,20\n           SetMaxRc 8\n           #subr end,rc=8\n         endif\n         st    r1,databfra\n         st    r1,vardataa\n         #subr exit,rc=0\n         #subr drop\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n* Write logrecord to terminal                                         *\n* At entry:                                                           *\n*  r1 -> cl120'log data'                                              *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n         ds    0d\nlogrdsct dsect\nlogrsa   ds    18a\nlogrwrk  ds    xl256\nlogrdsctl equ  *-logrdsct\n\n         push  using\n         using logger,r7\n         using logrdsct,r8\nLogger   #module base=r7,work=(logrdsctl,logrdsct,r8),sa=logrsa\n         ereg  0,r1\n*-\n         NTServx rt,name='REXXGBLV$LOGGER$',                           c\n               token=logrwrk,rc=logrwrk+16,pl=logrwrk+20\n         l     r10,logrwrk\n         RxSay (r9),l'logr\n*-\n         #module exit\n         ltorg\n         pop   using\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n* Pool anchor - new cb                                                *\n*  r1 -> cl16'name'                                                   *\n*  returns r15=0\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\nPoolAdd  #Subr xprolog=SubrProl,xepilog=SubrEpil\n         if    (ltr,r4,r1,z)          if null ptr\n           la   r4,varpool            then use default name\n         endif\n         strmake logr,'name ',((r4),16)\n         trclog\n         l     r8,PACBhead             -> 1st PACB\n         Using PACBblk,r8\n*-\n* locate free\n*-\n         Do    until,(ltr,r8,r8,z)\n           strmake logr,'check ',pacbname\n           trclog ,\n           if    (cli,PACBname,eq,c'-')  use if free\n             strmake logr,'reuse ',pacbname\n             trclog ,\n             mvc   PACBname,0(r4)      obtain\n             st    r8,PACBcur          save as current\n             lr    r1,r8\n             #subr exit,rc=0\n           endif\n           lr    r7,r8                 save address for current\n           l     r8,PACBnext           -> next if any\n         enddo\n         drop  r8\n*-\n* setup new chained PACB\n*-\n         Using PACBblk,r7\n         trclog 'add'\n         PACBnew name=(r4)\n         st    r1,PACBnext            set fwd ptr\n         drop  r7\n         Using PACBblk,r3\n         lr    r3,r1\n         st    r3,PACBcur             save as current\n         strmake logr,lenreg=r2,'at ',(pacbcur,4,c2x)\n         trclog ,(r2)\n         lr    r1,r3\n         drop  r3\n*-\n* back\n*-\n         #subr end\n         #subr drop\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n* POOL locate entry                                                   *\n*  r1 -> cl16'name'                                                   *\n*  returns r15=rc, r1 -> PACB entry                                   *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\nPoolLoc  #Subr xprolog=SubrProl,xepilog=SubrEpil\n         Using PACBblk,r8\n*-\n         if    (ltr,r9,r1,z)          if null ptr\n           la   r9,varpool            then use default\n         endif\n         strmake logr,'name ',((r9),16)\n         trclog\n*-\n* test if already current\n*-\n         l     r8,PACBcur\n         if    (PACBname,eq,0(r9))\n           trclog 'alrady current'\n           lr    r1,r8\n           #subr exit,0\n         endif\n*-\n* locate named\n*-\n         xc    PACBcur,PACBcur         prevent accidental reuse\n         l     r8,PACBhead             -> 1st PACB\n         Do    until,(ltr,r8,r8,z)\n           if    (PACBname,eq,0(r9))\n             st    r8,fw\n             strmake logr,'at ',(fw,4,c2x),lenreg=r2\n             trclog ,(r2)\n             st    r8,PACBcur          save as current\n             lr    r1,r8\n             #subr exit,rc=0           back\n           endif\n           l     r8,PACBnext           -> next if any\n         enddo\n*-\n* back\n*-\n         sr    r1,r1\n         #subr end,rc=4                not found\n         #subr drop\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n* PoolDrop : relase all pool storage, except anchor                   *\n* entry                                                               *\n*  r1 -> cl16'name' or 0                                              *\n*   'varpool' contains name of pool                                   *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\nPoolDrop #subr xprolog=SubrProl,xepilog=SubrEpil\n*\n         if    (ltr,r9,r1,z)          if null ptr\n           la   r9,varpool            then use default\n         endif\n         strmake logr,'name ',((r9),16)\n         trclog\n*\n         Pool  Loc,(r9)\n         if    (nz)\n           trclog 'not found'\n           #subr exit,rc=0\n         endif\n*\n         trcblk\n         l     r8,PACBcur\n         using PACBblk,r8\n         strmake logr,'drop ',pacbname,                                c\n               ' pacb ',(pacbcur,4,c2x)\n         trclog ,\n         trcblkend\n         VCBCall VCBDelAc              delete active VCBs, keep free\n         l     r8,PACBcur\n         if    (cli,pacbname,ne,c')')\n           mvi   pacbname,c'-'\n*          trclog 'marked'\n         endif\n*\n         #subr exit\n         #subr drop\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n*        PGETNEXT - get next VCB record                               *\n*  r1-> parm block as follows                                         *\n*   +00 a(VCB anchor)                         load to r2              *\n*   +04 a(varname)        point to field      load to r3              *\n*   +08 a(varname-length) point to field      load to r4              *\n*   +12 a(cursor)         point to field      load to r5              *\n*   varname and varnamel only relevant if not all                     *\n*  returns                                                            *\n*       r15 = 0 if found                                              *\n*       r1 -> VCB if found                                            *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\nPGetNext #subr xprolog=SubrProl,xepilog=SubrEpil\n         lr    r9,r1\n         lm    r2,r5,0(r1)\n         lr    r8,r2\n         using VcbAnchr,r8\n*\n         if    (VCBAeye,ne,=c'VCBANCHR')  better check\n           mvlit emsg,'PGetNext bad anchor',lenreg=r3\n           st    r3,emsgl\n           SetMaxRc 99\n           #subr end,rc=99\n         endif\n         if    (VCBAaqn,eq,zero)          any entries?\n           #subr end,rc=1\n         endif\n*\n         using Vcb,r7\n         l     r7,0(,r5)               cursor\n         if    (ltr,r7,r7,z)           first ??\n           l     r7,VCBAaqh            -> first (pseudo VCB)\n         endif\n         Do    forever\n           l     r7,VCBnext\n           if    (c,r7,eq,VCBAaqt)     last done?\n             #subr exit,rc=1\n           endif\n           l     r2,12(,r9)            update\n           st    r7,0(r2)                cursor\n           strmake logr,'vcbname \"',(vcbname,f.vcbnamel,,60),'\"'\n           trclog ,\n           if    (tm,options,opt_all,o),then=leave leave if all\n* do pattern check - name\n           StrPatrn data=(vcbname,f.vcbnamel),                         c\n               mask=(varname,b.varname_dl)\n           lr   r2,r15\n           strmake logr,'pattern check name rc ',(r2,,cvdr,6)\n           trclog\n           if    (ltr,r2,r2,nz),then=iterate not matched\n* do pattern check - data\n           if    (cli,data_dl,ne,0)\n             StrPatrn data=(f.vcbdataa,f.vcbdatal),                    c\n               mask=(data,b.data_dl)\n             lr   r2,r15\n             strmake logr,'pattern check data rc ',(r2,,cvdr,6)\n             trclog\n             if    (ltr,r2,r2,nz),then=iterate\n           endif\n           leave\n         enddo\n*\n         lr    r1,r7\n         #subr exit,rc=0\n         #subr drop\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n* Subroutine prolog / epilog  - do tracing                            *\n* r10 -> global storage                                               *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\nSubrProl #subr base=r6\n         ap    sanum,=p'1'\n         if    (zrx_ExComA,eq,zero),then=(#subrend,0)   no REXX\n*\n         TrcBlk\n         l     r3,4(,r13)              reload callers\n         l     r3,64(,r3)                basereg (r11)\n         strmake logr,(10(,r3),8),' ',(sanum,4,p2d,2),' entry',        c\n               lenreg=r2\n         trclog   ,(r2)\n         l     r1,4(,r13)              reload callers\n         lm    r0,r1,20(r1)              r0+r1\n         TrcBlkEnd\n*\n         #subr exit,rc=0\n         #subr drop\n*--\n* r2 = #subr end rc\nSubrEpil #subr base=r6\n         if    (zrx_ExComA,eq,zero),then=(#subrend,(r2))  no REXX\n         lr    r5,r2                   copy rc\n*\n         TrcBlk\n         l     r3,4(,r13)              reload callers\n         l     r3,64(,r3)                basereg\n         strmake logr,(10(,r3),8),' ',(sanum,4,p2d,2),                 c\n               ' exit rc ',(r5,,cvdr,8),lenreg=r2\n         trclog   ,(r2)\n         l     r1,4(,r13)              reload callers\n         lm    r0,r1,20(r1)              r0+r1\n         TrcBlkEnd\n*\n         sp    sanum,=p'1'\n         #subr exit,rc=(r5)            r5 = original r15\n         #subr drop\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n*                            dynamic area                             *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\nLclStor  Dsect\n*save areas\n         ds    0a\nSAheap   ds    xl(8*72)                6 saveareas\nSAheapN  ds    0a                      end\nDynData  ds    0a\nmainaddr ds    a                       -> main routine\nPACBcur  ds    a                       -> current PACB\nsanum    ds    pl4\nZero     ds    a\nrc       ds    a                       return code\nrcc      ds    cl8                     return code\np0fields equ   *\np0       ds    pl4\nstemnum  ds    pl4\nvsavecnt ds    pl4\nvloadcnt ds    pl4\nvdelcnt  ds    pl4\nVlistCnt ds    pl4\nvexpcnt  ds    pl4\nvimpcnt  ds    pl4\nrlistcnt ds    pl4\nrloadcnt ds    pl4\np0fieldn equ   *\np1       ds    pl4\nNtName   ds    cl16\nNtToken  ds    0xl16\nPACBhead ds    a                       -> 1st pool anchor\n         ds    xl12                    not used\nNtRc     ds    a\nrtndef   ds    2a\nsubrc    ds    a                       #subr return code\nparmlist ds    8a                      address/length of parm\nEnvb_Ptr equ   parmlist,4              address of environment block\ninitr0   equ   parmlist,4              original r0\ninitr1   equ   parmlist+4,4            original r1\nprocadr  ds    a\n\nblank    ds    cl120\nwtopfx   ds    a\nlogr     ds    cl120\nemsgl    ds    a\nemsg     ds    cl120\ntrclogrp ds    c\nRxText   ds    cl48\nsubxwrk  ds    d\ndw       ds    d\ndw2      ds    d\nfw       ds    f\nfw2      ds    f\n* REXX return and reason code\n         ds    d\nResult   ds    c                       result area\nRxFlags  ds    x\nRxRc1    ds    x\nRxRc2    ds    x\n*\nrnvvarl  ds    a\nRnvVar   ds    cl(255)\ntrcwrk   ds    8a\n         estaexx ds\n\n*fields passed as parms from caller\nfuncaddr    ds    a                    address of main function to run\nfuncname    ds    cl4\nfunctype    ds    c\n\nXComRc      ds    a\noptions      ds  x\n.*opt_status   equ x'40'\nopt_generic  equ x'80'               varname is generic\nopt_stem     equ x'40'               varname is a stem base\nopt_all      equ x'20'               no varname, select all\ngeneric      ds  c                   Y/N\n*-\n         ds    0a\n         StrParse area\nvarnamel equ   varname_z,4\nstemnml  equ   stemnm_z,4\n*-\n         RexxMacs ds\n*-\npatrninf    ds    cl16\nsomeptrs    ds    0a\nclrsavevl   ds    a\nclrsaveopt  ds    x\npgetnxtp    ds    a\n            org   someptrs\nvaddda      ds    a\nvadddl      ds    a\n            org\nVCBptr      ds    a\nVCBAptr     ds    a\nRexxVNxtBlk ds    3a                     databfra,databfrl,count\n*-\nvardataa    ds    0a\n*next 2 fields must be kept on order bfra,bfrl\ndatabfra    ds    a                      address of var-data block\ndatabfrl    ds    a                      size of var-data area\nvardatal    ds    a\n* following will be moved to separate getmained area\n*ardatab ds    a                      var data block / rdw\nwrknamel    ds    a\nwrkname     ds    cl255\n            ds    0d\nwrk256      ds    xl256\nwrk64k      ds    xl65512\n            org   wrk64k\nparmstr     ds    cl255\n            org   wrk64k\niordw       ds    a\nioreclen    equ   iordw,2\niodata      ds    0x\n            org\nLclStorL    equ   *-LclStor\nDynDataL    equ   *-DynData\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n*                            other dsects                             *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n\n*-\n* Pool Anchor CB\n*-\nPACBblk  Dsect\nPACB     ds    0x\nPACBvcba ds    xl(VCBAnchrl)\nPACBnext ds    a          -> next vector table\nPACBname ds    cl16\nPACBblkl equ   *-PACBblk\n\n*-\n* other\n*-\n         RexxMacs dsect\n         VCBANCHR dsect=yes\n         VCBmodul\n         VCB   ,   dsect\n\n         IeaNtAsm\n         print nogen\n         IkjTcb\n         IHACDE                       used by CDEUCTZ2\n         IHAPSA DSECT=YES             used by CDEUCTZ2\n         Qsam31 Dsects                DCB, DCBE\n*-\n         END\n//*\n//L.SYSLIB   DD DISP=SHR,DSN=SYS1.CSSLIB\n//L.SYSLMOD  DD DISP=SHR,DSN=CBT669.LPALIB(REXXGBLV)\n//*\n//* Production version is in LPALIB\n//*\n//* activate dynamic:\n//*   SETPROG LPA,ADD,MODNAME=REXXGBLV,DSNAME=CBT669.LPALIB\n//*\n//IVP1     EXEC PGM=IKJEFT1B,PARM='%RXGV&IVP'\n//STEPLIB  DD DISP=SHR,DSN=CBT669.LPALIB\n//SYSEXEC  DD DISP=SHR,DSN=CBT669.LIB\n//SYSTSPRT DD SYSOUT=*,OUTLIM=(5000)\n//RXGVDUMP DD SYSOUT=*\n//SYSTSIN  DD DUMMY\n//RXGVEXP  DD RECFM=VB,LRECL=23000,SPACE=(TRK,(5,5)),UNIT=SYSDA\n//*XGVEXP  DD DISP=OLD,DSN=CBT669.REXXGBLV.EXPORT\n//*YSMDUMP DD DISP=OLD,DSN=CBT669.SYSMDUMP\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXXMACS": {"ttr": 2564, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01c\\x00\\x00\\x01\\x17\\t_\\x01\\x19)\\x8f\\x15G\\x04\\xd4\\x03\\x15\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.99", "flags": 0, "createdate": "2017-04-05T00:00:00", "modifydate": "2019-10-25T15:47:00", "lines": 1236, "newlines": 789, "modlines": 0, "user": "DVL"}, "text": ".*-\n.* REXXMACS - Interface macros for REXX\n.*-\n.* This is assembler copybook, use as follows:\n.*         Print off\n.*         Copy RexxMacs\n.*         Print on\n.*-\n.* Sample\n.*       ereg  0,1\n.*       RxInit parmlist=((prm1,8),(prm2,8),(prm3,8))\n.*       ltr   r0,r0\n.*       jnz   *not REXX*\n.*       RxSay Welcomemsg,l'Welcomemsg\n.*       mvc   rc,=c'04'\n.*       RxRetval rc,l'rc\n.*       . . .\n.*       RexxMacs ds\n.*  rc   dc    c'00'\n.*       . . .\n.*       RexxMacs dsect\n.*-\n.* History\n.* 2017-09-28   enhance parm handling for RXSAY\n.* 2018-06-16   new macro RXSTACK\n.*              new macro REXXMACSMODS\n.* 2018-10-29   small fix to RXINIT test for REXX\n.* 2019-06-17   add TDL=reg to RxVNext stats\n.* 2019-09-01   add 1 as default 2nd parm for RXINIT PARMVECT\n.* 2019-09-12   new internal macro RXLA, change all '$LA' to 'RXLA'\n.* 2019-10-03   fix default data length in RXVACC\n.* 2019-10-25   fix RXSAY literal length\n.*-\n\n         Macro\n.*-\n.* RxInit - initialise interface\n.*\n.* Parameters\n.*\n.*  first positional\n.*   DS               Generate data section\n.*   DSECT            Generate data- and dummy sections\n.*   null             Generate standard initialization\n.*  keywords\n.*   PARMAREA=address Copy 1st or only parm to 'address'. R15 will\n.*                    retain length of the data copied.\n.*   PARMLIST=addr1,..,adrn  Copy arguments to local storage with\n.*                    length prefix. Each addrx must include a field\n.*                    length if not implied like (address,length).\n.*                    'length' may be a value, (register), f.addr or\n.*                    A for storing the address instead of the value.\n.*                    For each argument a structure is build:\n.*                      arg1_fs ds x  field length\n.*                      arg1_ds ds x  data length\n.*                      arg1    ds c  data\n.*                    Samples\n.*                      RxInit parmlist=string,pattern\n.*                      RxInit parmlist=((string,A),(pattern,A))\n.*   PARMVECT=(addr,count)   Copy argument address ad length as\n.*                    fullword pairs.\n.*                    Sample\n.*                         RxInit parmvect=(pl,4)\n.*                         lm    r2,r3,pl   addr,length of 1st parm\n.*                         lm    r4,r5,pl+8 addr,length of 2nd parm\n.*                      pl  dc  (4*2)a(0)\n.*\n.*   NOPARM=address   Jump to 'address' it no parameter is supplied.\n.*   NOREXX=address   Jump to 'address' it no REXX environment is\n.*   DS=N             Do not generate internal data section. Assume\n.*                    that a RXINIT DS, a RXINIT DSECT and a RXVACC PL\n.*                    are done elsewhere.\n.*-\n         RxInit &parmlist=,&parmarea=,&norexx=,&noparm=,&parmvect=\n         gbla  &RXPIC\n         gblc  &RXPIN(20),&RXPIL(20)\n         lclc  &q,&l,&s,&wl,&name,&len,&pa,&pl,&norexxa\n         lcla  &n,&p,&ofs,&fl\n&l       setc  'rxi&sysndx'\n&norexxa setc  '&norexx'\n         aif   (k'&norexx gt 0).nrx1n\n&norexxa setc  '&l.n'\n.nrx1n   anop\n&l.a     cnop  0,4\n         xc    zrx_area(zrx_areal),zrx_area\n.* note that r0 and r1 must contain the original values.\n.* data block must be generated using RxInit DB macro call.\n         stm   r0,r1,zrx_r0            save entry r0,r1\n* test for REXX envblock\n         lr    r14,r0                  -> envblock (hopefully)\n         clc   &l.eb,0(r14)\n         je    &l.b\n         xc    zrx_r0,zrx_r0\n         j     &norexxa                no REXX\n&l.eb    dc    cl8'ENVBLOCK'\n&l.b     equ   *\n* end test\n         using efpl,r1                 point to parmlist\n         mvc   zrx_ebp,efpleval        -> evaluation block pointer\n         drop  r1\n.*\n         RxComBlk init                 GET/PUT comblk\n.*\n         lr    r15,r0\n* get interface routine addresses\n         using envblock,r15\n         l     r15,envblock_irxexte    rexx vector of external entries\n         using irxexte,r15\n         mvc   zrx_coma,irxexcom       address of module irxexcom\n         mvc   zrx_SayA,irxsay         address of module irxsay\n         drop  r15\n         aif   (k'&parmlist gt 0).prminit\n         aif   (k'&parmvect gt 0).prmvect\n         aif   (k'&parmarea gt 0).prmarea\n&l.n     l     r0,zrx_r0               nz if REXX, z if not REXX\n         Mexit\n.* Copy parm to area\n.prmarea anop\n         l     r2,zrx_r1               old r1\n         using efpl,r2                 point to parmlist\n         l     r2,efplarg              -> arguments table\n         drop  r2\n         ltr   r2,r2                   test no\n         jz    &l.n                      input\n         cli   0(r2),x'FF'             end of source list?\n         lm    r14,r15,0(r2)           source address and length\n         ltr   r15,r15                 zero length?\n         jnz   &l.c                    ok, go copy\n         sr    r15,r15                 just in case\n         j     &l.n\n&l.c     bctr  r15,0                   mch length\n         mvc   &parmarea.(*-*),0(r14)\n         ex    r15,*-6\n         la    r15,1(,r15)             reinstate length\n&l.n     l     r0,zrx_r0               nz if REXX, z if not REXX\n         Mexit\n.*\n.* Get positional parameters\n.*\n.PrmInit Anop\n.*\n*- init parameter address list --------------------------------\n.*\n         aif   (n'&parmlist eq 0).noparm\n&RXPIC   seta  n'&parmlist\n&n       seta  1\n&ofs     seta  0\n         la    r1,zrx_parmarea\n.prmi010 anop\n&name    setc  '&parmlist(&n,1)'\n         la    r14,&name._fs\n         st    r14,&ofs.(,r1)\n&ofs     seta  &ofs+4\n&len     setc  '&parmlist(&n,2)'\n&RXPIN(&n) setc  '&name'\n&RXPIL(&n) setc  '&len'\n         aif   ('&len' ne 'A').prmi110\n         xc    &name._fs(10),&name._fs\n         ago   .prmi200\n.prmi110 anop\n         mvi   &name._fs,&len\n         mvi   &name._ds,0\n         mvi   &name,c' '\n         aif   ('&len' eq '1').prmi200\n         mvc   &name.+1(&len-1),&name\n.prmi200 anop\n&n       seta  &n+1\n         aif   (&n le n'&parmlist).prmi010\n&ofs     seta  &ofs-4\n         oi    &ofs.(r1),x'80'\n.*\n*- obtain parameters ------------------------------------------\n.*\n.PrmGet  Anop\n         l     r2,zrx_r1               old r1\n         using efpl,r2                 point to parmlist\n         l     r2,efplarg              -> arguments table\n         drop  r2\n         la    r3,zrx_parmarea\n         ltr   r2,r2                   test no\n         jz    &l.n0                     input\n&l.1     equ   *\n         cli   0(r2),x'FF'             end of source list?\n         je    &l.n0\n         l     r1,0(,r3)               output area\n         la    r1,0(,r1)               clear vl bit\n         lm    r14,r15,0(r2)           source address and length\n         ltr   r14,r14                 check zero address\n         jz    &l.3                    then go get next\n         ltr   r15,r15                 zero length\n         jz    &l.3                    then go get next\n.* r1 -> al1(field length,data length),c'data'\n         ic    r1,0(,r1)               load target field length\n         sll   r1,24                   drop upper\n         srl   r1,24                     3 bytes\n.* store address/length pair\n         ltr   r1,r1                   field len=0 => store addresses\n         jnz   &l.2\n         l     r1,0(,r3)               output area\n         la    r1,0(,r1)               clear vl bit\n         stm   r14,r15,2(r1)\n         mvi   1(r1),8                 set data length\n         j     &l.3\n.* get text data\n&l.2     cr    r15,r1\n         bnh   *+6\n         lr    r15,r1                  reset to max\n         l     r1,0(,r3)               output area\n         stc   r15,1(,r1)              save data length\n         bctr  r15,0\n         mvc   2(*-*,r1),0(r14)\n         ex    r15,*-6\n&l.3     tm    0(r3),x'80'             end of target list?\n         jo    &l.n0                   yes\n.*       jo    &l.n4                   not so good\n         la    r2,8(,r2)\n         la    r3,4(,r3)\n         j     &l.1\n&l.n0    sr    r15,r15\n         j     &l.n\n&l.n4    la    r15,4\n&l.n     l     r0,zrx_r0               nz if REXX, z if not REXX\n         Mexit\n.*\n.* Copy parameter address / length pairs\n.*\n.PrmVect Anop\n         l     r1,zrx_r1               old r1\n         using efpl,r1                 point to parmlist\n         l     r1,efplarg              -> arguments table\n         drop  r1\n         RxLa  r14,&parmvect(1)        -> output area\n         RxLa  r15,&parmvect(2),1      max number of pairs\n&l.pv1   tm    0(r1),x'80'             end of source list?\n         jo    &l.pv0\n         mvc   0(8,r14),0(r1)          copy address and length\n         la    r1,8(,r1)\n         la    r14,8(,r14)\n         bct   r15,&l.pv1              get next\n         la    r15,1                   set 'overflow'\n         j     &l.n\n&l.pv0   sr    r15,r15\n&l.n     l     r0,zrx_r0               nz if REXX, z if not REXX\n.*-\n.noparm  anop\n.x       Mend\n\n*--------------------------------------------------------------\n\n         Macro\n.*-\n.* Comm-block for VGET / VPUT\n.* Internal macro called by RXINIT and REXXMACS respectively\n.*-\n         RxComBlk &what,&stat,&prefix=zrx_\n         lclc  &pf,&s\n&pf      setc  '&prefix'\n&s       setc  Upper('&what')\n         aif   ('&s' eq 'DS' or k'&what eq 0).ds\n         aif   ('&s' eq 'DSECT').dsect\n         aif   ('&s' eq 'INIT').init\n         aif   ('&s' eq 'TEST').test\n         mnote 'RXCOMBLK Invalid call: &s'\n         mexit\n.init    anop\n* init VGET / VPUT comblk begin\n         la    r14,=cl8'IRXEXCOM'\n         st    r14,&pf.ComBlkp1\n         la    r14,=a(0)\n         st    r14,&pf.ComBlkp2\n         st    r14,&pf.ComBlkp3\n         st    r14,&pf.ComBlkp5\n         la    r14,&pf.ShVb\n         st    r14,&pf.ComBlkp4\n         la    r14,&pf.XComRc\n         st    r14,&pf.ComBlkp6\n         oi    &pf.ComBlkP6,x'80'\n* init VGET / VPUT comblk end\n         Mexit\n.dsect   anop\nRxComBlK DSECT\n.ds      anop\n&pf.ComBlk   ds    0x\n&pf.ComBlkp1 ds    a                   -> EXCOM eyecatcher\n&pf.ComBlkp2 ds    a                   Reserved\n&pf.ComBlkp3 ds    a                   Reserved\n&pf.ComBlkp4 ds    a                   -> 1st SVHB\n&pf.ComBlkp5 ds    a                   -> Env-block or zero\n&pf.ComBlkp6 ds    a                   -> Return code field\n*-\n&pf.XComRc   ds    a\n&pf.StAdjCnt ds    a                   storage adjustment count\n&pf.NextCnt  ds    a                   'next' counter\n*-\n&pf.ShVb     ds    0d\n&pf.ShVbNext ds    a                   -> next  ShVb\n&pf.ShVUser  ds    f                   Used by 'next' function\n&pf.ShVCode  ds    0c                  F=Fetch, S=Set (put)\n&pf.ShVbFunc ds    c                   F=Fetch, S=Set (put)\n&pf.ShVRet   ds    0x                  Return code area\n&pf.ShVbRc   ds    x                   Return code area\n&pf.last     equ   x'02'               'last-var' flag\n&pf.trunc    equ   x'04'               'truncated' flag\n             ds    h                   Reserved\n&pf.ShVbFbl  ds    a                   Length of fetch buffer\n&pf.ShVbVna  ds    a                   -> variable name\n&pf.ShVbVnl  ds    a                   length of variable name\n&pf.ShVbVba  ds    a                   -> value buffer\n&pf.ShVbVbl  ds    a                   Length of fetched value\n&pf.namea    equ   &pf.ShVbVna,4\n&pf.namel    equ   &pf.ShVbVnl,4\n&pf.dataa    equ   &pf.ShVbVba,4\n&pf.datal    equ   &pf.ShVbVbl,4\n&pf.ShVbl    equ   *-&pf.ShVb\n&pf.ComBlkl  equ   *-&pf.ComBlk\n.* names from the manual\n&pf.ShvBufl  equ   &pf.ShVbFbl,4\n&pf.ShvNama  equ   &pf.ShVbVna,4\n&pf.ShvNaml  equ   &pf.ShVbVnl,4\n&pf.ShvVala  equ   &pf.ShVbVba,4\n&pf.ShvVall  equ   &pf.ShVbVbl,4\n         Mexit\n.TEST    anop\n.* Test return code flags stored in SHVRET:\n.*  SHVCLEAN EQU X'00' Execution was OK\n.*  SHVNEWV  EQU X'01' Variable did not exist\n.*  SHVLVAR  EQU X'02' Last variable transferred (for \"N\")\n.*  SHVTRUNC EQU X'04' Truncation occurred during \"Fetch\"\n.*  SHVBADN  EQU X'08' Invalid variable name\n.*  SHVBADV  EQU X'10' Value too long\n.*  SHVBADF  EQU X'80' Invalid function code (SHVCODE)\n.* Special flags: LAST\n&s       setc  Upper('&stat')\n         aif   ('&s' ne 'EOF').test999\n         tm    &prefix.SHVRET,SHVLVAR  last??\n         mexit\n.test999 tm    &prefix.SHVRET,&s\n         mexit\n.x       Mend\n\n*--------------------------------------------------------------\n\n         Macro\n.*-\n.* Generate data areas\n.* Usage:\n.*       RexxMacs dsect\n.*-\n         REXXMACS &what,&comblk=Y,&cbpfx=zrx_\n         lcla  &sln,&n,&l\n         lclc  &sl,&c,&name,&len,&s,&cbp\n         gbla  &RXPIC\n         gblc  &RXPIN(20),&RXPIL(20),&RXCBPFX\n.* select action\n         aif   (k'&what eq 0).defsect\n&s       setc  Upper('&what')\n         aif   ('&s' eq 'DS').DefSect\n         aif   ('&s' eq 'DSECT').DefSect\n         aif   ('&s' eq 'SET').set\n         mnote 8,'** Invalid p1'\n         mexit\n.* set global settings - under construction\n.SET     anop\n         aif   (k'&cbpfx eq 0).cbpfxn\n&rxcbpfx setc  '&cbpfx'\n.cbpfxn  anop\n         mexit\n.*-\n.* Datablock and dummy sects common to the macro seet\n.*-\n.DEFSECT anop\n&sln     seta  &sln+1\n         aif   (&sln gt N'&syslist).x\n&sl      setc  Upper('&syslist(&sln)')\n         aif   ('&sl' eq 'DS').ds\n         aif   ('&sl' eq 'DSECT').dsect\n&sl      setc  'syslist(&sln)'\n         mnote 8,'*** Invalid option: &sl'\n         mexit\n.DS      anop\n*-\n* Data areas for the REXXMACS set\n*-\n*\n*- global area\nzrx_area     ds    0a\nzrx_envba    ds    0a\nzrx_r0       ds    a\nzrx_r1       ds    a\nzrx_Excoma   ds    0a\nzrx_coma     ds    a\nzrx_saya     ds    a\nzrx_EnvBlka  ds    0a\nzrx_ebp      ds    a\nzrx_fw       ds    f\nzrx_dw       ds    0d\nzrx_wrk      ds    6a\nzrx_wrkp1    equ   zrx_wrk,4\nzrx_wrkp2    equ   zrx_wrk+4,4\nzrx_wrkp3    equ   zrx_wrk+8,4\nzrx_wrkp4    equ   zrx_wrk+12,4\nzrx_wrkp5    equ   zrx_wrk+16,4\nzrx_wrkp6    equ   zrx_wrk+20,4\n*-Comm-block\n         aif   ('&comblk' ne 'y' and '&comblk' ne 'Y').comblkn\n             RxComBlk\n.comblkn anop\n*-end of area\nzrx_areal    equ   *-zrx_area\n*- parameter area, &rxpic parameters handled\nzrx_parmarea ds    0a\n         aif   (&RXPIC eq 0).DefSect\n          ds    &RXPIC.a       parm vector\n&n       seta  1\n.parmdef aif   (&n gt &RXPIC).DefSect\n&name    setc  '&RXPIN(&n)'\n&len     setc  '&RXPIL(&n)'\n         aif   ('&len' ne 'A').mpa010\n         ds     0a                    align data\n         ds     h                       on fullword\n&len     setc  '8'                    room for 2 adress fields\n.mpa010  anop\n&name._fs ds    al1\n&name._ds ds    al1\n&name     ds    cl(&len)\n&n       seta  &n+1\n         ago   .parmdef\n*-\n.Dsect   anop\n*-\n* Dsects for the REXXMACS set\n*-\n         Print  nogen\n         Dsect\n         IRXEFPL                      REXX EXTERNAL FUNCTION\n         IRXEVALB                     REXX EVALUATION BLOCK\n         IRXENVB                      REXX ENVIRONMENT BLOCK\n         IRXARGTB DECLARE=YES         REXX ARGUMENT TABLE\n         IRXEXTE\n         IRXSHVB\n         Print  gen\n*-\n         ago   .DefSect\n.X       Mend\n\n         Macro\n.*-\n.* REXX interface macro - terminate with return code\n.* Parms\n.*   EXIT=N      do not terminate program, allow for freemains etc\n.*   RC=         number or (register)\n.*   RCH=address address of halfword containing the rc\n.*   RCF=address address of fullword containing the rc\n.* Default rc=0\n.*-\n&mlbl    RxTerm &rc=,&data=,&exit=Y\n         lclc  &data1,&data2,&l\n&l       setc  'z&sysndx'\n&data1   setc  '&data(1)'\n&data2   setc  '&data(2)'\n&mlbl    cnop  0,4\n         l     r14,zrx_ebp             -> evaluation block pointer\n         l     r14,0(r14)              point to evalblock\n         using evalblock,r14\n         aif   (k'&rc gt 0).rc\n         aif   (k'&data gt 0).data\n&data1   setc  '=c''0000'''\n&data2   setc  '4'\n         ago   .data\n.rc      RxLa  r15,&rc                 rc\n         cvd   r15,evalblock_evdata+8\n         unpk  evalblock_evdata(8),evalblock_evdata+8\n         oi    evalblock_evdata+7,x'F0'\n         mvc   evalblock_evlen,=a(8)\n         ago   .b\n.data    anop\n         la    r2,&data2             length\n         l     r15,EVALBLOCK_EVSIZE   for data size check\n         sll   r15,3                  doublewords to bytes\n         cr    r2,r15\n         jnh   &l.b\n         lr    r2,r15               use max\n&l.b     st    r2,evalblock_evlen   store reply length\n         ltr   r2,r2\n         jz    &l.c\n         bctr  r2,0\n         mvc   evalblock_evdata(*-*),&data1\n         ex    r2,*-6\n&l.c     equ   *\n.b       drop  r14\n&q       setc  Upper('&exit')\n         aif   ('&q' eq 'N').x\n         sr    r15,r15                 caller must use the RC value\n         pr\n.x       Mend\n\n         Macro\n.*-\n.* REXX interface macro - store return value\n.* Parms\n.*   data        address of the data to return\n.*   size        size of the data to return\n.*-\n&mlbl    RxRetVal &data,&size,&wto=N\n         lclc  &l\n&l       setc  'zrx&sysndx'\n&mlbl    cnop  0,4\n         RxLa  r0,&size\n         l     r14,zrx_ebp             -> evironment block pointer\n         l     r14,0(r14)              point to evalblock\n         using evalblock,r14\n         l     r1,evalblock_evsize    for data size check\n         drop  r14\n         sll   r1,3                   doublewords to bytes\n         ahi   r1,-16                 minus header\n         cr    r0,r1                  fits in current buffer ?\n         jnh   &l.c                   yes, go copy\n.*-\n* get a bigger buffer\n.*-\n         aif   ('&wto' ne 'Y').wton\n         wto   'RxRetval expand'\n.wton    anop\n         la    r14,=cl8'GETBLOCK'\n         la    r15,zrx_wrkp5          new evaluation block addr\n         stm   r14,r15,zrx_wrkp1\n         st    r0,zrx_wrkp4           store length\n         la    r14,zrx_wrkp4          -> length\n         st    r14,zrx_wrkp3          save\n         oi    zrx_wrkp3,x'80'        end-of-parm flag\n.*\n         load  EP=IRXRLT\n         lr    r15,r0                 copy module address\n         l     r0,zrx_envba           envbp (optional)\n         la    r1,zrx_wrkp1           -> start of parmlist\n         basr  r14,r15\n         st    r15,zrx_wrkp6          save rc\n.*\n         delete EP=IRXRLT\n         icm   r15,15,zrx_wrkp6       reload rc, test cond\n         jnz   &l.x                   nope\n.*-\n* copy data to buffer\n.*-\n&l.c     l     r14,zrx_ebp             -> evironment block pointer\n         l     r14,0(r14)              point to evalblock\n         using evalblock,r14\n.* just use copy-long, simpler and dont happen that often\n         RxLa  r0,&data\n         RxLa  r1,&size\n         st    r1,evalblock_evlen     store length\n         la    r14,evalblock_evdata\n         drop  r14\n         lr    r15,r1                 copy size\n         mvcl  r14,r0\n         sr    r15,r15\n&l.x     equ   *\n.x       Mend\n\n\n         Macro\n         RxStemName &base=,&stema=,&num=,&pnum=,&clear=n\n.*-\n.* Build a rexx stemname composed by a base, including the dot,\n.* concatenated with the number.\n.*   base=(address,length)\n.*   name=address\n.*   num=binary number\n.*   pnum=packed-decimal number - note must be pl4'n'\n.*   clear=Y   clear varname before build-up\n.* Sample:\n.*     RxStemName base=(stemname,7),stema=varname,num=f.seqnr\n.*-\n         lcla  &n\n         lclc  &base1,&base2\n&base1   setc  '&base(1)'\n&base2   setc  '&base(2)'\n         aif   ('&base1 '(1,1) ne '''').b1litn\n&n       seta  k'&base1-2\n&base2   setc  '&n'\n         ago   .basen\n.b1litn  anop\n         aif   (k'&base2 ne 0).b2nuln\n&n       seta  l'&base1\n&base2   setc  '&n'\n.b2nuln  anop\n.basen   anop\n.*       aif   (n'&base ne 2 or k'&stema eq 0).err1\n         aif   ('&clear' ne 'Y' and '&clear' ne 'y').clrn\n         mvi   &stema,c' '\n         mvc   &stema.+1(l'&stema.-1),&stema\n.clrn    anop\n         RxLa  r14,&base1              addr\n         RxLa  r15,&base2              length\n         bctr  r15,0                   mch length\n         mvc   &stema.(*-*),0(r14)     get stem base\n         ex    r15,*-6\n         RxLa  r14,&stema+1(r15)       -> number area\n         RxStemNum (r14),bin=&num,dec=&pnum\n         RxLa  r14,&base2              stem base length\n         ar    r15,r14                 plus number length\n         lr    r0,r15                  copy length\n         mexit\n.err1    mnote 8,'**STEMNAME Missing base or name'\n         Mend\n\n         Macro\n.*-\n.* Build a rexx stemnumber\n.* Parameters\n.*   addr      build-up area, must be large enough to hold the result\n.*   bin       value, (reg) or f.addr\n.*   dec       value address\n.* Samples\n.*         RxStemNum value,bin=f.xval\n.*         lr    r2,r15        copy length\n.*         RxStemNum value,dec=pval\n.*         lr    r2,r15        copy length\n.*  value  dc    cl8' '\n.*  xval   dc    a(123)\n.*  pval   dc    p'456'\n.*-\n         RxStemNum &addr,&dec=,&bin=\n         lclc  &l\n&l       setc  'R&sysndx'\n         mvc   40(8,r13),=x'4020202020202020'\n         aif   (k'&bin eq 0 and k'&dec eq 0).err1\n         aif   (k'&dec gt 0).dec\n         RxLa  r15,&bin                seqnr\n         cvd   r15,24(r13)\n         edmk  40(8,r13),28(r13)       unpack\n         ago   .nlen\n.dec     edmk  40(8,r13),&dec          unpack\n.nlen    anop\n         bnz   &l.cl                   nonzero value\n         la    r1,=c'0'                -> c'0'\n         sr    r15,r15                 mchlen=0\n         b     &l.m\n.* r1 -> 1st non-zero byte\n&l.cl    la    r15,48(,r13)            calc\n         sr    r15,r1                    length\n         bctr  r15,0                   mch length\n&l.M     RxLa  r14,&addr               -> target area\n         mvc   0(*-*,r14),0(r1)        append seq number\n         ex    r15,*-6\n         la    r15,1(,r15)             reinstate length\n         mexit\n.err1    mnote 8,'**STEMNUM Missing number parm'\n         Mend\n\n         Macro\n.*-\n.* Say\n.*\n.* Parameters\n.*   1  address    label, (reg) or 'literal'\n.*   2  length     value, (reg) or null if address is literal\n.*\n.* sets up 5 fullword work area\n.*   1  -> 'WRITE'\n.*   2  -> address of dataaddress field\n.*   3  -> address of length field\n.*   4  dataaddress field\n.*   5  length field\n.*-\n&mlbl    RXSAY &adr,&len,&wrk=zrx_wrk\n         gblc  &rxlalen\n&mlbl    la    r14,=cl8'WRITE'         -> operation\n         rxla  r15,&adr                -> data\n         rxla  r0,&len,&rxlalen,l'&adr length\n         stm   r15,r0,&wrk+12\n         la    r15,&wrk+12\n         la    r0,&wrk+16\n         stm   r14,r0,&wrk\n         oi    &wrk+8,x'80'            set end of list\n         sr    r0,r0\n         La    R1,&wrk\n         L     R15,zrx_SayA            address of module\n         Basr  R14,R15\n         Mend\n\n         MACRO\n.*-\n.* REXX get or put variable\n.*\n.* Can be used directly, but should really be used through the\n.* RXVGET, RXVPUT and RXSTEMPUT macros.\n.*\n.* Required dsects: IRXENVB IRXEXTE\n.* you must use the PL expansion for either GET or PUT\n.* The INIT call is done in RXINIT.\n.*\n.* Parameters, see the RXVGET, RXVPUT and RXVNECT macros later.\n.*\n.* Sample:\n.*           RxVacc init,enva=zrx_envba,pl=vapl\n.*\n.*           RxVacc get,name=('TESTVAR1',8),data=(value,l'value)\n.*           l     r2,vaplShVbVbl       actual data length\n.*\n.*           mvlit value,'finally weekend'\n.*           la    r2,15\n.*           RxVacc put,name=('TESTVAR1',8),data=(value,(r2))\n.*\n.*  vapl     RxVacc pl\n.*  value    dc    cl100' '\n.*-\n&mlbl    RXVACC &what,&name=,&data=,&envptr=,&st=,&sth=,&src=,         c\n               &reg=r14,&enva=zrx_envba,&comblk=zrx_\n         lclc  &que,&lbl,&c,&lsrc,&lpl,&l,&s,&cb\n         lcla  &m,&n,&i,&ln,&p\n         gblc  &rxlalen\n&l       setc  'z&sysndx'\n&cb      setc  '&comblk'\n&que     setc  Upper('&what')\n&lbl     setc  'RXV&sysndx'\n&mlbl    ds    0h\n         aif   ('&que' eq 'GET').get\n         aif   ('&que' eq 'PUT').put\n         aif   ('&que' eq 'NEXT').next\n         aif   ('&que' eq 'RESET').reset\n         Mnote 8,'*** invalid parm: &what'\n         Mexit\n.*-get\n.Get     Anop\n         mvi   &cb.ShVbFunc,C'F'           fetch\n         ago   .call\n.*-getnext prep\n.Next    Anop\n         mvi   &cb.ShVbFunc,C'N'           fetch\n         ago   .call\n.*-put\n.Put     Anop\n         mvi   &cb.ShVbFunc,C'S'           set\n.call    Anop\n         aif   (k'&data(1) eq 0).call2     no data\n*setup for data\n         RxLa  r14,&data(1)\n         RxLa  r15,&data(2),&rxlalen\n         stm   r14,r15,&cb.ShVbVba\n         st    r15,&cb.ShVbFbl\n.call2   anop\n*setup for name\n&s       setc  Upper('&name(1)')           ensure literal is ucase\n         RxLa  r14,&s\n         aif   ('&name(1) '(1,1) eq '''' and k'&name(2) eq 0).call2nl\n         RxLa  r15,&name(2),l'&name(1)\n         ago   .call2nn\n.call2nl anop\n&n       seta  k'&name(1)-2\n         la    r15,&n\n.call2nn anop\n         stm   r14,r15,&cb.ShVbVna\n*setup for call\n         mvc   &cb.ShVUser,&cb.ShVbVnl for 'next'\n         l     r15,zrx_coma                address of module irxexcom\n         l     r0,zrx_envba\n         la    r1,&cb.Comblk\n         Basr  r14,r15\n.* load data- and name length\n         l     r0,&cb.ShVbVbl\n         l     r1,&cb.ShVbVnl\n.*-getnext post, check for end of list\n         aif   ('&que' ne 'NEXT').X\n         if    (tm,&cb.SHVRET,SHVLVAR,o)     end of list set\n           la    r15,1\n         endif\n         if    (tm,&cb.SHVRET,SHVTRUNC,o)    truncation occurred\n           la    r15,2\n         endif\n         ltr    r15,r15                      set cc\n         Mexit\n.* reset the interface block\n.RESET   Anop\n         xc    &comblk.ShVb(&comblk.ShVbl),&comblk.ShVb\n         xc    &comblk.StAdjCnt,&comblk.StAdjCnt\n         xc    &comblk.NextCnt,&comblk.NextCnt\n         Mexit\n.*\n.x       MEND\n\n         Macro\n.*-\n.* Get a REXX variable to local storage\n.*\n.* Parameters;\n.*   DATA=(address,length)  Address is the address of the buffer which\n.*                          will receive the data.\n.*                          Length is the length of the buffer\n.*   NAME=(address,length)  Address is the variable name.\n.*                          The name may a literal in quotes.\n.*                          Length will default to the length of a\n.*                          literal of the generated length of a field.\n.*                          Note, the name in a field must be in ucase,\n.*                          a literal is ucased internally.\n.*   STOR=length            Size of dynamic data area. The area will be\n.*                          automatically reallocated if too small. You\n.*                          must use the STOR=DROP option when finished\n.*                          to release the storage.\n.*\n.*   address can be a label or a (register).\n.*   length can be a numbeer or a (register).\n.*\n.* Registers after call\n.* r15  return code\n.* r0   data length\n.*\n.* Sample\n.*   RxVGet name='TESTVAR1',data=(value,(r2))\n.*   RxVGet name=(varname,(r3)),data=(value,(r2))\n.*   RxVGet name='longvar',stor=200\n.*   lr    r2,r0         copy data length\n.*   RxVGet stor=drop\n.*-\n&mlbl    RXvGet &name=,&data=,&comblk=zrx_,&stor=,&acc=GET\n         lclc  &l,&q,&ac\n&l       setc  'RG&sysndx'\n&q       setc  Upper('&syslist(1)')\n&ac      setc  Upper('&acc')\n         aif   ('&q' eq 'RESET').reset\n         aif   (k'&stor ne 0).stor\n&mlbl    RxVacc &acc,name=&name,data=&data,comblk=&comblk\n         Mexit\n.* reset the interface block\n.RESET   Anop\n         xc    &comblk.ShVb(&comblk.ShVbl),&comblk.ShVb\n         xc    &comblk.stadjcnt,&comblk.stadjcnt\n         xc    &comblk.nextcnt,&comblk.nextcnt\n         Mexit\n.* use dynamic storage for data area\n.STOR    Anop\n&q       setc  Upper('&stor')\n         aif   ('&q' eq 'DROP').stordrp\n         RxLa  r14,&stor\n&l.cs    c     r14,&comblk.ShVbFbl\n         jnh   &l.cl                   ok, go call\n*-freemain\n         l     r0,&comblk.ShVbFbl      size\n         icm   r1,15,&comblk.ShVbVba   if null address\n         jz    &l.gm                   then no previous storage\n         Freemain R,lv=(0),a=(1)\n*-getmain\n&l.gm    st    r14,&comblk.ShVbFbl     save as buffer length\n         Getmain R,lv=(14),loc=31\n         st    r1,&comblk.ShVbVba      save address\n*-call\n&l.cl    xc    &comblk.ShVbVbl,&comblk.ShVbVbl\n         RxVacc &acc,name=&name,comblk=&comblk\n         tm    &comblk.ShVRet,SHVTRUNC\n         jz    &l.sl\n         l     r14,&comblk.stadjcnt\n         la    r14,1(,r14)\n         st    r14,&comblk.stadjcnt\n         l     r14,&comblk.ShVbVbl\n         j     &l.cs\n&l.sl    l     r0,&comblk.ShVbVbl      size of retrieved\n         l     r1,&comblk.ShVbVba      addr of retrieved\n         Mexit\n.STORDRP Anop\n         l     r0,&comblk.ShVbFbl      size\n         l     r1,&comblk.ShVbVba      address\n         Freemain R,lv=(0),a=(1)\n         Mexit\n.x       MEND\n\n         Macro\n.*-\n.* Create or update a REXX variable from local storage\n.*\n.* Parameters;\n.*   DATA and NAME same as for the RxVGet macro.\n.*\n.* Registers after call\n.* r15  return code\n.*\n.* Sample\n.*   RxVPut name=('TESTVAR1',8),data=(value,(r2))\n.*-\n&mlbl    RXvPut &name=,&data=,&comblk=zrx_\n.* bl    RxVacc put,name=(&name(1),&name(2)),data=(&data(1),&data(2)),\n&mlbl    RxVacc put,name=&name,data=&data,comblk=&comblk\n.x       MEND\n\n         Macro\n.*-\n.* Retrieve all REXX variable from current environment, or information\n.* about variables.\n.*\n.* Parameters;\n.*   DATA and NAME same as for the RxVGet macro.\n.*  If p1 = 'STATS' then the following parameters are used:\n.*   NL     register to receive name length\n.*   DL     register to receive data length\n.*   TDL    register to add data length (must be 0 before first call).\n.*   COUNT  register to hold count\n.*\n.* Both the NAME and the DATA fields will be filled in by the function.\n.*\n.* Registers after call\n.* r15  return code\n.*      special code 1 means that the variable retrieved is the last.\n.*      special code 2 means that the name or the data was truncated.\n.* r0   data length\n.* r1   name length\n.*\n.* Sample\n.*   RxVNext name=(namebfr,l'namebfr),data=(databfr,l'databfr)\n.*   lr    r2,r0         copy data length\n.*   lr    r3,r1         copy name length\n.*-\n&mlbl    RxVNext &name=,&data=,&nl=,&dl=,&tdl=,&count=,                c\n               &comblk=zrx_\n         lclc  &l,&q\n&l       setc  'RN&sysndx'\n&q       setc  Upper('&syslist(1)')\n         aif   ('&q' eq 'STATS').stats\n&mlbl    RxVacc next,name=&name,data=&data,comblk=&comblk\n         mexit\n.STATS   ANOP\n&mlbl    RxVacc reset\n         sr    &nl,&nl                 name length\n         sr    &dl,&dl                 data length\n         sr    &count,&count           count\n&l.a     RxVacc next,name=(0,0),data=(0,0)\n         tm    zrx_SHVRET,SHVLVAR\n         jo    &l.x\n         cr    r1,&nl\n         jnh   *+6\n         lr    &nl,r1\n         cr    r0,&dl\n         jnh   *+6\n         lr    &dl,r0\n         aif   (k'&tdl eq 0).count\n         ar    &tdl,r0\n.count   la    &count,1(,&count)\n         j     &l.a\n&l.x     RxVacc reset\n         mexit\n.x       MEND\n\n         Macro\n.*-\n.* Read or write a stemvar, combining the basename and the number.\n.* Parameters are a combination of those for RXSTEMNAME\n.* and RXVGET/VPUT\n.*-\n         RxStemAcc &name=,&stema=,&base=,&num=,&pnum=,&data=,          c\n               &comblk=zrx_,&acc=???,&namelenr=r1\n         lclc  &vn\n&vn      setc  '&name'\n         aif   (k'&name ne 0).vnok\n&vn      setc  '&stema'\n.vnok    anop\n mnote *,'-RxStemname'\n         RxStemname stema=&vn,base=&base,num=&num,pnum=&pnum\n         lr    &namelenr,r15\n mnote *,'-RxV&acc'\n         RxV&acc name=(&vn,(&namelenr)),data=&data,&comblk=&comblk\n         Mend\n\n         Macro\n         RxStemGet &name=,&stema=,&base=,&num=,&pnum=,&data=,          c\n               &comblk=zrx_\n.* call common access macro\n         RxStemAcc acc=GET,name=&name,stema=&stema,                    c\n               base=&base,num=&num,pnum=&pnum,data=&data,comblk=&comblk\n         Mend\n\n         Macro\n         RxStemPut &name=,&stema=,&base=,&num=,&pnum=,&data=,          c\n               &comblk=zrx_,&namelenr=r1\n.* call common access macro\n         RxStemAcc acc=PUT,name=&name,stema=&stema,                    c\n               namelenr=&namelenr,                                     c\n               base=&base,num=&num,pnum=&pnum,data=&data,comblk=&comblk\n         Mend\n\n         Macro\n.*-\n.* Acces the REXX data stack\n.*\n.* Parameters;\n.*   what  function - PUSH, QUEUE, QUEUED ...\n.*   data  address or (address,length) for functions PULL, QUEUE,\n.*         PUSH and QUEUED. Must be a fullword if QUEUED.\n.*\n.* Registers after call\n.* r15  return code\n.* r0   data length if function is PULL\n.* r1   data address if function is PULL\n.*      value if function is QUEUED\n.*\n.* Sample\n.*   RxStack pull,data=buffer\n.*   RxStack queued\n.*-\n         RxStack &what,&data=,&mode=,&wrka=,&lenreg=\n         lclc  &que,&l,&s\n&func    setc  Upper('&what')\n&l       setc  'zrx&sysndx'\n         la    r14,=cl8'&func'         function\n&s       setc  Upper('&mode')\n         aif   ('&mode' eq 'CALL').call\n         xc    zrx_datal,zrx_datal\n         xc    zrx_xComRc,zrx_xComRc\n         aif   ('&func' ne 'QUEUE' and '&func' ne 'PUSH').quefn\n         aif   (n'&data eq 0).datafn\n         RxLa  r15,&data(1),0\n         st    r15,zrx_dataa           address of data\n         RxLa  r15,&data(2),l'&data,0\n         st    r15,zrx_datal           save data length\n.datafn  anop\n.quefn   anop\n         la    r15,zrx_dataa           address of data returned\n         la    r0,zrx_datal            length of data returned\n         la    r1,zrx_xComRc           value returned by irxstk\n         stm   r14,r1,zrx_wrk\n         oi    zrx_wrk+12,x'80'        set VL bit\n         l     r15,zrx_envba\n         l     r15,envblock_irxexte-envblock(,r15) a(irxexte)\n         l     r15,irxstk-irxexte(,r15) stack manager\n         la    r1,zrx_wrk              parm list\n         basr  r14,r15                 call irxstk\n         aif   ('&func' eq 'PULL').pullbe\n         aif   ('&func' eq 'QUEUED').quedbe\n         ago   .other\n.quedbe  anop                          QUEUED back end\n         l     r1,zrx_xComRc           value\n         aif   (k'&data eq 0).quedb2\n         st    r1,&data\n.quedb2  ltr   r15,r15                 set rc\n         mexit\n.pullbe  anop                          PULL back end\n         ltr   r15,r15                 test rc\n         aif   (n'&data eq 0).pullb2\n         jnz   &l.b2                   exit if bad rc\n         StrCopy  from=(f.zrx_dataa,f.zrx_datal),                      c\n               to=(&data(1),&data(2)),lenreg=&lenreg\n         sr    r15,r15\n         ltr   r15,r15\n&l.b2    equ   *\n         mexit\n.pullb2  anop                          PULL back end\n         l     r0,zrx_datal\n         l     r1,zrx_dataa\n         mexit\n.other   ltr   r15,r15\n         ago   .x\n.*- call\n         l     r15,zrx_envba\n         RxLa  r0,&data(1)\n         RxLa  r1,&data(2),l'&data(1)\n         stm   r14,r1,zrx_wrk\n         RxLa  r1,&wrka,0\n         st    r1,zrx_wrk+16\n         la    r1,zrx_wrk\n         Call  ZRXSTACK\n         ltr   r15,r15\n.*- end\n.x       anop\n&l.x     equ   *\n         Mend\n\n         Macro\n*-\n* ZRXSTACK - stack interface\n* At entry\n*  r1 -> ZRXSTACK_prm\n* At exit\n*  r15  0  all ok, though the string may have been truncated\n*      >0  return code from IRXSTK\n*-\n         RexxMacsMods\n         using ZRXSTACK,r12\n         using ZRXSTACK_PRM,r9\n         using ZRXSTACK_WRK,r10\n*-\n*  initialize module\n*-\nZRXSTACK Csect\n         save  (14,12)\n         lr    r12,r15\n         lr    r9,r1\n         icm   r10,r15,ZRXSTACK_prmwa\n         jnz   ZRXSTACK_ini1n\n         Getmain R,lv=ZRXSTACK_wrkl,loc=31\n         lr    r10,r1\nZRXSTACK_ini1n equ   *\n         la    r14,ZRXSTACK_sa1\n         st    r14,8(,r13)\n         st    r13,4(,r14)\n         lr    r13,r14\n         xc    ZRXSTACK_pl(ZRXSTACK_wrkn-ZRXSTACK_pl),ZRXSTACK_pl\n*-\n*  setup and call service\n*-\n         l     r14,ZRXSTACK_prmfa      -> function\n         la    r15,ZRXSTACK_dataa      address of data returned\n         la    r0,ZRXSTACK_datal       length of data returned\n         la    r1,ZRXSTACK_val         value returned by irxstk\n         stm   r14,r1,ZRXSTACK_pl\n         oi    ZRXSTACK_pl+12,x'80'    set VL bit\n         l     r15,ZRXSTACK_prmea\n         l     r15,envblock_irxexte-envblock(,r15) a(irxexte)\n         l     r15,irxstk-irxexte(,r15) stack manager\n         la    r1,ZRXSTACK_pl          parm list\n         l     r0,ZRXSTACK_prmea\n         basr  r14,r15                 call irxstk\n         ltr   r15,r15                 quit now\n         jnz   ZRXSTACK_rtn              if bad rc\n         l     r2,ZRXSTACK_prmfa       -> function\n*be aware of special cases\n         clc   =c'QUEUED',0(r2)        special case 'queued'\n         je    ZRXSTACK_qed\n         j     ZRXSTACK_norm\n*-\n*  handle special case QUEUED\n*-\nZRXSTACK_qed   equ *\n         l     r2,ZRXSTACK_prmda       address of data returned\n         mvc   0(4,r2),ZRXSTACK_val\n         j     ZRXSTACK_rtn\n*-\n*  return data for normal cases\n*-\nZRXSTACK_norm  equ *\n         lr    r5,r15                     save rc\n         StrCopy from=(f.ZRXSTACK_dataa,f.ZRXSTACK_datal),             c\n               to=(f.ZRXSTACK_prmda,f.ZRXSTACK_prmdl)\n         lr    r15,r5                     restore rc\n*-\n*  return\n*-\nZRXSTACK_rtn   equ  *\n         lr    r5,r15\n         clc   ZRXSTACK_prmwa,=a(0)       work area supplied??\n         jne   ZRXSTACK_rtn2              yes\n         Freemain R,lv=ZRXSTACK_wrkl,a=(10)\nZRXSTACK_rtn2  equ  *\n         lr    r15,r5\n         l     r13,4(,r13)\n         l     r14,12(,r13)\n         Return (2,12)\n\n         ltorg\n         drop\n\n*-\n*  parm area  4x6=16 bytes\n*-\nZRXSTACK_prm   dsect\nZRXSTACK_prmfa ds    a                 address\nZRXSTACK_prmea ds    a                 address\nZRXSTACK_prmda ds    a                 address\nZRXSTACK_prmdl ds    a                 address\nZRXSTACK_prmwa ds    a                 address or 0\n\n*-\n*  work area  28x4=112 bytes\n*-\nZRXSTACK_wrk   dsect\nZRXSTACK_sa1   ds    18a\nZRXSTACK_pl    ds    6a\nZRXSTACK_rc    ds    a\nZRXSTACK_val   ds    a\nZRXSTACK_dataa ds    a                 address\nZRXSTACK_datal ds    a                 value\nZRXSTACK_wrkn  equ   *\nZRXSTACK_wrkl  equ   *-ZRXSTACK_wrk\n         Mend\n\n         MACRO\n.*-\n.* Subroutine, generate Lx instruction\n.* Syntax: RXLA  reg,what1,what2,,whatn\n.*         what: label or (reg) or 'literal' or f/h/b/c.label\n.*               b/c.label -> reg is cleared and the entire byte loaded\n.*               1st non-null 'what' is used\n.*-\n&ml      RXLA\n         lclc  &xlar,&xlap,&xla\n         lcla  &xlapn,&xlan\n         gblc  &rxlalen\n&rxlalen setc ''\n&xlar    setc  '&syslist(1)'\n&xlapn   seta  1\n.xlanext anop\n&xlapn   seta  &xlapn+1\n         aif   (&xlapn gt n'&syslist).x\n&xlap    setc  '&syslist(&xlapn)'\n         aif   (k'&xlap eq 0 or '&xlap' eq '''''').xlanext\n         aif   ('&xlap '(1,1) eq '(').xlareg\n         aif   ('&xlap '(1,1) eq '''').xlalit\n         aif   ('&xlap '(2,1) eq '.').xlafld\n&xla     setc  t'&xlap\n         aif   ('&xla' eq 'N').xlanum\n&ml      la    &xlar,&xlap\n         aif   ('&xlap  '(1,2) eq 'l''').x\n&rxlalen setc 'l''&xlap'\n         mexit\n.xlanum  anop\n&ml      lgfi  &xlar,&xlap\n         mexit\n.xlafld  anop\n&xlan    seta  k'&xlap-2\n&xla     setc  '&xlap'(1,1)\n&xlap    setc  '&xlap'(3,&xlan)\n&xla     setc  lower('&xla')\n         aif   ('&xla' eq 'b').xlaopb\n         aif   ('&xla' eq 'c').xlaopb\n         aif   ('&xla' eq 'h').xlaoph\n         aif   ('&xla' eq 'f').xlaopf\n         mnote 8,'Invalid argument &xla'\n         mexit\n.xlaopb  anop\n&ml      llc   &xlar,&xlap\n         mexit\n.xlaoph  anop\n&ml      lh    &xlar,&xlap\n         mexit\n.xlaopf  anop\n&ml      l     &xlar,&xlap\n         mexit\n.xlareg  anop\n&xlan    seta  k'&xlap-2\n&xlap    setc  '&xlap'(2,&xlan)\n&ml      lr    &xlar,&xlap\n         mexit\n.xlalit  anop\n&ml      la    &xlar,=c&xlap\n&xlan    seta k'&xlap-2\n&rxlalen setc '&xlan'\n         mexit\n.x       MEND\n\n*-RXMACS end\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXXSTOR": {"ttr": 3076, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1f\\x00\\x18\\x01\\x17&\\x1f\\x01\\x193\\x8f\\x17P\\x03\\x0c\\x02\\x95\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.31", "flags": 0, "createdate": "2017-09-18T00:00:00", "modifydate": "2019-12-04T17:50:18", "lines": 780, "newlines": 661, "modlines": 0, "user": "DVL"}, "text": "//RXST005  JOB (G4LT),'REXXSTOR-005',CLASS=A,REGION=32M,\n//*  RESTART=IVP,\n//             MSGLEVEL=(1,1),MSGCLASS=X,TIME=NOLIMIT,COND=(0,LT)\n/*JOBPARM L=999999\n//* ?? REXXSTOR - Write and read data to nameed storage area ? e ?\n//*\n//   EXEC ASMACL,PARM.C='TERM,RENT',\n//          PARM.L='RENT,REFR,XREF,LIST,RMODE(ANY)'\n//C.SYSLIB  DD DISP=SHR,DSN=CBT669.LIB\n//          DD DISP=SHR,DSN=SYS1.MACLIB\n//          DD DISP=SHR,DSN=SYS1.MODGEN\n//C.SYSTERM DD SYSOUT=*\n//C.SYSIN   DD *\n**asma syslib * CBT669.maclib\n**asma opt    term\n*Process compat(macrocase)\n*\n* Write and read data to nameed storage area.\n*\n*\n* Syntax:\n*  action,name,data|variablename|length\n*    action is A, D, G, GA, GX, I, MAP, P or VER\n*\n* Return:\n*   data    if action is G or I\n*   address if action is A, GA or P\n*   text    if action is VER\n*   ' '     for other actions\n*\n* Variable REXXSTOR_RC is set as follows:\n*    0     all ok\n*  <>0     error, varaiable REXXSTOR_RS contains the reason text.\n*\n* Global register usage:\n*   r11    basereg\n*   r10    global storage\n*\n* Samples:\n*\n*  cc=REXXSTOR('a','test1','200')  /* get block                   */\n*  va=REXXSTOR('ga','test1')       /* get block address           */\n*  va=REXXSTOR('d','test1')        /* remove block                */\n*  cc=REXXSTOR('p','test1','a nice day') /* write to store        */\n*  v =REXXSTOR('g','test1')        /* get data                    */\n*\n* The STORAGE function can be used to store data directly in the data\n* block, and retrieve data from the storage block, like this:\n*\n*  p1 = REXXSTOR('p','storblk1','Kilroy was here')\n*  say  Storage(p1,8)                      /* 'kilroy w'        */\n*  p2 = RexxStor('a','2k',2014)            /* acquire storage   */\n*  text = 'Another fine mess you''ve gotten me in to'\n*  cc = Storage(p2,,text)                  /* overwrite storage */\n*  say  Storage(p2,length(text))\n*\n*\n* Changelog\n*  003 2017-03-11 support new REXXMACS macro set\n*  004 2017-09-18 reentrant, refreshable\n*  005 2018-11-25 internal restructure, cleanup\n*\n         print off\n         Copy  WSAMMACS\n         Copy  REXXMACS\n         Copy  SYSMACS\n         Copy  RXSTMACS\n         print on\n*        COPY  Z10MACS\n\n* ------------------------------------------------------------------- *\n* Prolog                                                              *\n* ------------------------------------------------------------------- *\n         lclc  &$module\n&$module setc 'REXXSTOR'\n&$build  setc '005'\n         #subr set,entry=csect,base=r11,saend=saend\n         gblc  &#subrbase\n\nREXXSTOR #module base=(r12),text='&$build',                            c\n               work=(lclstorl,lclstor,r10,C),                          c\n               sa=sa1,xepilog=MainEpil\n*-\n         clear blank\n         mvc   logr,blank\n         mvc   inforec,blank\n         mvc   reason,blank\n         mvc   reasonl,=a(1)\n         la    r14,blank\n         la    r15,1\n         stm   r14,r15,retval\n         zap   sanum,p0\n\n         ereg  0,1\n*                           p1          p2        p3       p4\n         RxInit parmlist=((action,4),(name,8),(data,A),(opt,8))\n         lr    r7,r15             copy rc\n         oc    opt,blank\n         if    (=c'TRACE',eq,opt)\n           mvi   trace,c'Y'\n           trclog 'trace on'\n         endif\n         StrMake logr,'Modid  ',(REXXSTOR_id,REXXSTOR_idl)\n         trclog ,\n\n*- get the system anchor block (name/token)\n         Call  NtAcq\n         if    (ltr,r15,r15,nz)\n           #module exit,20\n         endif\n\n*- debug - show parameter fields\n         trcblk\n         StrMake logr,'action ',(action_ds,1,cvd,6),' ',action,        c\n               lenreg=r2\n         trclog ,(r2)\n         StrMake logr,'name   ',(name_ds,1,cvd,6),' ',name,            c\n               lenreg=r2\n         trclog ,(r2)\n         StrMake logr,'data   ',reg=r4,lenreg=r3\n         if    (cli,data_ds,ne,0)\n           StrMake ((r4)),(data+6,2,cvd,6),+1,                         c\n               (f.data,f.data+4,,60),lenreg=r3\n         endif\n         trclog ,(r3)\n         StrMake logr,'opt    ',(opt_ds,1,cvd,6),' ',opt,              c\n               lenreg=r2\n         trclog ,(r2)\n         trcblkend\n*-\n         if    (ltr,r7,r7,nz)\n           StrMake logr,'init rc ',(r7,,cvdr,6)\n           #module end\n         endif\n         oc    action,blank\n\n*-\n* check parms\n*-\n\n* check parm 1 - action\n         if    (cli,action_ds,eq,0)   if zero then missing name\n           Reason 'No action',1\n           trclog 'No action'\n           #module end\n         endif\n\n* get process address\n         la    r2,actlist\n         do    until,(cli,0(r2),eq,255)\n           if    (clc,action,eq,0(r2))\n             mvc   suba,4(r2)\n             leave\n           endif\n           la    r2,8(,r2)\n         enddo\n         if    (suba,eq,zero)         if zero then unkown action\n           Reason 'Bad action',1\n           trclog 'Bad action'\n           #module end\n         endif\n\n* check parm 2 - name\n         if    (action,ne,=cl4'MAP'),and,(action,ne,=cl4'VER')\n           if    (cli,name_ds,eq,0)   if zero then missing name\n             Reason 'Missing name',2\n             trclog 'Missing name'\n             #module end\n           endif\n         endif\n\n* call processor\n         if    (cli,action,ne,c'D')\n           l     r15,suba\n           balr  r14,r15\n         endif\n         #module end,rc=0\n\n* -------------fixed data----------------------------------------------\n\nzero     dc    a(0)\np0       dc    p'0'\np1       dc    p'1'\nntname   dc    cl16'&$module..&$build'\n         ds    0a\nactlist  dc    cl4'A',v(acquire)\n         dc    cl4'D',v(drop)\n         dc    cl4'G',v(get)\n         dc    cl4'GX',v(getx)\n         dc    cl4'GA',v(geta)\n         dc    cl4'P',v(put)\n         dc    cl4'I',v(info)\n         dc    cl4'MAP',v(map)\n         dc    cl4'VER',v(version)\n         dc    al1(255)\n         ltorg\n\n*=====================================================================*\n*  End of module processing                                           *\n*=====================================================================*\nMainEpil #subr\n*\n         if    (zero,ne,retval)        data to return?\n           RxRetVal f.retval,f.retval+4  address, length\n         endif\n\n* write variables\n         l     r14,rc                  rc\n         $cvd  r14,dw,len=8            as char\n         RxVput name=('REXXSTOR_RC'),data=dw\n         RxVput name=('REXXSTOR_RS'),data=(reason,f.reasonl)\n*\n         StrMake logr,'exit rc ',(rc,4,cvd,4)\n         trclog ,20\n*\n         if    (cli,action,eq,c'D'),or,(cli,action+1,eq,c'X')\n           Call  Drop\n         endif\n*\n         #subr end\n         #subr drop\n\n*=====================================================================*\n*  NT acquire                                                         *\n*=====================================================================*\nNtAcq    #subr xprolog=SubrProl,xepilog=SubrEpil\n\n*\n         Strmake logr,'NT acq ',ntname,lenreg=r2\n         Trclog ,(r2)\n\n* check for existing\n         xc    ntblk(ntblkl),ntblk\n         NTSERVX    rt,name=ntname,token=NtToken,rc=NtRc,pl=NtParms,   c\n               level=HOME\n         if   (clc,ntrc,eq,zero)\n           mvc   SACBanch,nttokadr\n           strmake logr,'NT rt ok, sacbanch ',(SACBanch,4,c2x),        c\n               lenreg=r2\n           trclog ,(r2)\n           #subr end,rc=0\n         endif\n\n* setup anchor block\n         trclog 'NT make'\n         STORAGE OBTAIN,LENGTH=SAABblkl,SP=131,CALLRKY=YES\n         xc    0(SAABblkl,r1),0(r1)   just in case\n         st    r1,SACBanch            save anchor address\n         using SACBblk,r1\n         mvc   SACBname,=cl8')ANCHOR'\n         mvi   SACBaddr,x'FF'         make it occupied\n         drop  r1\n         strmake logr,'SACBanch ',(SACBanch,4,c2x),lenreg=r2\n         trclog ,(r2)\n\n* create NT\n         xc    ntblk(ntblkl),ntblk\n         mvc   nttokadr,SACBanch\n         NTSERVX cr,name=ntname,token=NtToken,rc=NtRc,pl=NtParms,      c\n               level=HOME\n         lr    r5,r15\n         strmake logr,'NTcr rc ',(r5,,cvdr,6),' ntrc ',(ntrc,4,c2x),   c\n               lenreg=r3\n         if    (ltr,r5,r5,nz)\n           mvc   reason,logr\n           mvc   rc,=a(8)\n         endif\n         trclog ,(r3)\n*\n         #subr end,rc=(r5) f.ntrc\n         #subr drop                   includes ltorg\n\n*=====================================================================*\n*  Action 'V', Return version info                                    *\n*=====================================================================*\nVersion  #subr xprolog=SubrProl,xepilog=SubrEpil\n*\n         la    r14,verstr\n         la    r15,l'verstr\n         stm   r14,r15,retval\n*\n         #subr end\n         #subr drop                   includes ltorg\nverstr   dc    c'&$module..&$build &sysdate &systime'\n\n*=====================================================================*\n*  Action 'A', Acquire area                                           *\n*=====================================================================*\nAcquire  #subr xprolog=SubrProl,xepilog=SubrEpil\n* check for required parameters\n         if    (cli,name_ds,eq,0)\n           reason 'Missing name',8\n           #subrend rc=8            missing data\n         endif\n         if    (cli,data_ds,eq,0)\n           reason 'Missing size data',8\n           #subrend rc=8            missing data\n         endif\n         lm    r2,r3,data\n         if    (ltr,r2,r2,z),or,(ltr,r3,r3,z)\n           reason 'Missing size data',8\n           #subrend rc=8            missing data\n         endif\n\n* go get\n         sr    r1,r1                use name\n         sr    r0,r0                length in data\n         Call  StAdd\n         if    (ltr,r15,r15,nz)\n           reason 'Add failed',8\n           #subr end,rc=8\n         endif\n         st    r1,fw                -> storage\n         Strc2x from=fw,to=retval8\n         la    r1,retval8\n         la    r2,8\n         stm   r1,r2,retval\n\n* return\n         #subr end\n         #subr drop\n\n*=====================================================================*\n*  Action 'D', Drop area                                              *\n*=====================================================================*\nDrop     #subr xprolog=SubrProl,xepilog=SubrEpil\n*\n         if    (cli,name,eq,c' ')\n           reason 'Name missing',8\n           mvc   logr,reason\n           trclog ,\n         endif\n*\n         sr    r1,r1\n         Call  StDel\n         if    (ltr,r15,r15,nz)\n           reason 'Area not found',8\n           mvc   logr,reason\n           trclog ,\n         endif\n*\n         #subr end\n         #subr drop\n\n*=====================================================================*\n*  Action 'G', Get data                                               *\n*=====================================================================*\nGet      #subr xprolog=SubrProl,xepilog=SubrEpil\n\n* locate SACB\n         sr    r1,r1                   use name\n         Call  StLoc\n         if    (ltr,r5,r1,z)\n           reason 'Area not found',8\n           mvc   logr,reason\n           trclog ,\n           #subr end,rc=8\n         endif\n         using SACBblk,r5\n*\n         strmake logr,(sacbaddr,4,c2x),+1,(sacbsize,4,cvd,6),          c\n               +1,(f.sacbaddr,f.sacbsize,,60)\n         trclog ,\n\n* copy data to variable?\n         if    (cli,data_ds,ne,0)\n           lm    r2,r3,data\n           bctr  r3,0\n           mvc   wrk256(*-*),0(r2)\n           ex    r3,*-6\n           oc    wrk256(l'blank),blank\n           strmake logr,'name ',(wrk256,1(r3)),lenreg=r2\n           trclog ,(r2)\n           RxvPut name=(wrk256,1(r3)),data=(f.sacbaddr,f.sacbsize)\n           RxRetVal =c'0',1\n           #subr exit,rc=0\n         endif\n\n* return data\n         mvc   retval,SACBaddr\n         mvc   retval+4,SACBsize\n         #subr end\n         #subr drop\n\n*=====================================================================*\n*  Action 'GA' - get address of block                                 *\n*=====================================================================*\nGetA     #subr xprolog=SubrProl,xepilog=SubrEpil\n\n* locate SACB\n         sr    r1,r1                   use name\n         Call  StLoc\n         if    (ltr,r5,r1,z)\n           reason 'Area not found',8\n           mvc   logr,reason\n           la    r14,=c' '\n           la    r15,1\n           stm   r14,r15,retval\n           trclog ,\n           #subr end,rc=8\n         endif\n\n* return data\n         using SACBblk,r5\n         StrC2x from=SACBaddr,to=retval8\n         la    r14,retval8\n         la    r15,8\n         stm   r14,r15,retval\n*\n         #subr end\n         #subr drop\n\n*=====================================================================*\n*  Action 'GX', Get data and delete storage                           *\n*=====================================================================*\nGetX     #subr xprolog=SubrProl,xepilog=SubrEpil\n\n         sr    r1,r1                   use name\n         Call  Get\n         if    (ltr,r15,r15,nz)\n           #subr end,rc=8\n         endif\n         sr    r1,r1                   use name\n         Call  StDel\n\n         #subr end\n         #subr drop\n\n*=====================================================================*\n* Action 'P' - write data to storage                                  *\n*=====================================================================*\nPut      #subr xprolog=SubrProl,xepilog=SubrEpil\n\n* get new / replace old\n         l     r0,data+4               use data width\n         sr    r1,r1                   use name from parm\n         Call  StAdd                   new element\n         lr    r5,r0                   -> SCBA\n\n* copy data\n         using SACBblk,r5\n         lm    r14,r15,data             -> source\n         l     r0,SACBaddr              -> target\n         lr    r1,r15                   copy size\n         mvcl  r0,r14\n*\n         StrC2x from=SACBaddr,to=retval8\n         la    r14,retval8\n         la    r15,8\n         stm   r14,r15,retval\n*\n         #subr end\n         #subr drop\n\n*=====================================================================*\n*  Action 'I', Information about a storage element                    *\n*=====================================================================*\nInfo     #subr xprolog=SubrProl,xepilog=SubrEpil\n\n* locate SACB\n         sr    r1,r1                   use name\n         Call  StLoc\n         if    (ltr,r5,r1,z)\n           reason 'Area not found',8\n           mvc   logr,reason\n           trclog ,\n           la    r14,blank\n           la    r15,1\n           stm   r14,r15,retval\n           #subr end,rc=8\n         endif\n\n* make list\n         using SACBblk,r5\n         strmake inforec,name,' at ',(SACBaddr,4,c2x),                 c\n               +1,' len ',(SACBsize,4,cvd,6),lenreg=r2\n         mvc   logr,inforec\n         trclog ,(r2)\n         la    r14,inforec\n         lr    r15,r2\n         stm   r14,r15,retval\n\n* return\n         #subr end\n         #subr drop\n\n*=====================================================================*\n*  Action 'MAP' - list all SACBs                                      *\n*=====================================================================*\nMAP      #subr xprolog=SubrProl,xepilog=SubrEpil\n* anchor\n         strmake logr,ntname,' Anchor ',(SACBanch,4,c2x),lenreg=r2\n         RxSay logr,(r2)\n* make list\n         l     r5,SACBanch\n         using SACBblk,r5\n         do    until,(icm,r5,15,SACBnext,z)\n           st    r5,fw\n           strmake logr,'SACB at ',(fw,4,c2x),                         c\n               ' name ',sacbname,' addr ',(SACBaddr,4,c2x),            c\n               +1,' len ',(SACBsize,4,cvd,6),lenreg=r2\n           RxSay logr,(r2)\n         enddo\n* return\n         #subr end\n         #subr drop\n\n*=====================================================================*\n* STLOC - locate storage element by name                              *\n* Entry                                                               *\n*  r1 -> name or 0                                                    *\n* Exit                                                                *\n*  r1 -> SACB or 0                                                    *\n*=====================================================================*\nStLoc    #subr xprolog=SubrProl,xepilog=SubrEpil\n*\n         if    (ltr,r6,r1,z)           if null parm\n           la    r6,name               then use name from parm\n         endif\n         strmake logr,'locate ',((r6),8),lenreg=r2\n         trclog   ,(r2)\n*\n         Using SACBblk,r5\n         l     r5,SACBanch             -> 1st\n         do    while,(SACBname,ne,0(r6))\n           if    (icm,r5,15,SACBnext,z)  no next\n             leave ,                   return 'not found' (r1 = 0)\n           endif\n         enddo\n         if    (SACBaddr,eq,zero)\n           sr    r5,r5                 deleted\n         endif\n         drop  r5\n*\n         if    (ltr,r5,r5,nz)          nz => found\n           lr    r1,r5\n           #subr end,rc=0\n         endif\n         sr    r1,r1\n         #subr end,rc=1\n         #subr drop\n\n*=====================================================================*\n* STADD - new storage element (reuse free cb if found)                *\n* Entry                                                               *\n*  r1 -> cl8'name' or 0. if 0 then use parm # 2 (name)                *\n*  r0 =  size or 0. if 0 then use parm # 3 (pdata)                    *\n* Exit                                                                *\n*  r1 -> Storage obtained                                             *\n*  r0 -> SACB element                                                 *\n*=====================================================================*\nStAdd    #subr xprolog=SubrProl,xepilog=SubrEpil\n\n* if null name then use name from parm\n         if    (ltr,r6,r1,z)\n           la    r6,name\n         endif\n\n* if null size then use address and length from parm\n         if    (ltr,r7,r0,z)\n           lm    r2,r3,data\n           bctr  r3,0\n           j     *+10\n           pack  dw,0(*-*,r2)\n           ex    r3,*-6\n           cvb   r7,dw\n         endif\n\n* if already there, then delete\n         lr    r1,r6                   -> name\n         Call  StDel\n\n* locate a free element ( SACBaddr = 0 => free ) or get a new\n         Using SACBblk,r5\n         l     r5,SACBanch             -> 1st\n         strmake logr,'SACBanch ',(SACBanch,4,cvxd),lenreg=r2\n         trclog ,(r2)\n         do    forever\n           if    (icm,r1,15,SACBaddr,z)  free\n             st    r5,fw\n             strmake logr,'free SACB at ',(fw,4,cvxd),                 c\n               +1,SACBname,lenreg=r2\n             trclog ,(r2)\n             leave\n           endif\n           if    (icm,r1,15,SACBnext,z)  no next\n             STORAGE OBTAIN,LENGTH=SACBblkl,SP=131,CALLRKY=YES\n             st    r1,SACBnext         update fwd ptr\n             lr    r4,r1               copy address\n             strmake logr,'new SACB at ',(SACBnext,4,cvxd),lenreg=r2\n             trclog ,(r2)\n             lr    r5,r4               use new\n             leave\n           endif\n           lr    r5,r1                 try next\n         enddo\n\n* finally, get storage and hook to chain\n         STORAGE OBTAIN,LENGTH=(r7),SP=131,CALLRKY=YES\n         mvc   SACBname,0(r6)          copy name\n         st    r1,SACBaddr             save address\n         st    r7,SACBsize             save size\n         strmake logr,'getmain ',(SACBsize,4,cvd,6),                   c\n               ' at ',(SACBaddr,4,cvxd),' for ',sacbname,lenreg=r2\n         trclog ,(r2)\n         l     r1,SACBaddr             storage address\n         lr    r0,r5                   SACB element address\n*\n         #subr end\n         #subr drop\n\n*=====================================================================*\n* STDEL - delete entry                                                *\n* Entry                                                               *\n*  r1 -> cl8'name' or 0. passed unmodified to STLOC                   *\n*=====================================================================*\nStDel    #subr xprolog=SubrProl,xepilog=SubrEpil\n\n* locate named element\n         Call StLoc\n         if    (ltr,r15,r15,nz)\n           #subr  exit,rc=0 1\n         endif\n\n* delete\n         trclog 'releasing..'\n         lr    r5,r1\n         Using SACBblk,r5\n         l     r3,SACBaddr\n         l     r4,SACBsize\n         STORAGE RELEASE,LENGTH=(4),ADDR=(3),SP=131,CALLRKY=YES\n         xc    SACBaddr,SACBaddr\n         xc    SACBsize,SACBsize\n         strmake logr,(fw,4,c2x),+1,SACBname,' deleted',lenreg=r2\n         trclog   ,(r2)\n\n* return\n         #subr end\n         #subr drop\n\n*=====================================================================*\n*  STMAP - list structure                                             *\n*=====================================================================*\nStMap    #subr xprolog=SubrProl,xepilog=SubrEpil\n\n         Using SACBblk,r5\n         l     r5,SACBanch             -> 1st\n         do    until,(icm,r5,15,SACBnext,z)\n           st  r5,fw\n           strmake logr,(fw,4,c2x),+1,SACBname,+1,                     c\n               ' addr ',(SACBaddr,4,c2x),' size ',(SACBblkl,4,cvd,6),  c\n               lenreg=r2\n           trclog   ,(r2)\n         enddo\n\n         #subr end\n         #subr drop\n\n*=====================================================================*\n*  Subroutine prolog / epilog  - do tracing                           *\n*  r10 -> global storage                                              *\n*=====================================================================*\nSubrProl #subr base=r6\n         ap    sanum,=p'1'\n         if    (zrx_ExComA,eq,zero),then=(#subrend,0)   no REXX\n*\n         TrcBlk\n         l     r3,4(,r13)              reload callers\n         l     r3,64(,r3)                basereg (r11)\n         strmake logr,(10(,r3),8),' ',(sanum,4,p2d,2),                 c\n               ' entry',lenreg=r2\n*              ' entry prc ',(rc,4,cvd,4),lenreg=r2\n         trclog   ,(r2)\n         l     r1,4(,r13)              reload callers\n         lm    r0,r1,20(r1)              r0+r1\n         TrcBlkEnd\n*\n         #subr exit,rc=0\n         #subr drop\n*--\n* r2 = #subr end rc\nSubrEpil #subr base=r6\n         if    (zrx_ExComA,eq,zero),then=(#subrend,(r2))  no REXX\n         lr    r5,r2                   copy rc\n*\n         TrcBlk\n         l     r3,4(,r13)              reload callers\n         l     r3,64(,r3)                basereg\n         strmake logr,(10(,r3),8),' ',(sanum,4,p2d,2),                 c\n               ' exit rc ',(r5,,cvdr,8),' prc ',(rc,4,cvd,4),lenreg=r2\n         trclog   ,(r2)\n         l     r1,4(,r13)              reload callers\n         lm    r0,r1,20(r1)              r0+r1\n         TrcBlkEnd\n*\n         sp    sanum,=p'1'\n         #subr exit,rc=(r5)            r5 = original r15\n         #subr drop\n\n*=====================================================================*\n*  dynamic area                                                       *\n*=====================================================================*\n\nLclStor  Dsect\nsa1      ds    (6*18)f                 save areas\nsaend    equ   *\n*-\nblank    ds    cl150\nlogrpfx  ds    a\nlogr     ds    cl120\ninforec  ds    cl120\ntrace    ds    c\nfw       ds    f\ndw       ds    d\nsanum    ds    pl4\nstoradrc ds    cl8\nreasonl  ds    a\nreason   ds    cl120\n*-\nrc       ds    a\nretval   ds    2a(0)\nretval8  ds    cl8\nsuba     ds    a\nacqsz    ds    a\nsacbanch ds    a\n*-\n         RexxMacs ds\n*-\nwrk256   ds    xl256\n         org   wrk256\nNtBlk    ds    0a\nntLevel  ds    a\nNtRc     ds    a\nNtToken  ds    4a\nNtTokAdr equ   NtToken,4\nNtParms  ds    6a\nNtBlkl   equ   *-NtBlk\n         org\n*-\nLclStorL equ   *-LclStor\n\n*=====================================================================*\n*  Storage Aquisition Control Block                                   *\n*=====================================================================*\nSACBblk  dsect\nSACB     ds    0x\nSACBname ds    cl8\nSACBaddr ds    a                       address of area\nSACBsize ds    a                       size of area\nSACBnext ds    a                       next in queue\nSACBblkl equ   *-SACBblk\n\n*=====================================================================*\n*  Storage Aquisition Anchor Block                                    *\n*=====================================================================*\nSAABblk  dsect\nSAAB     ds    0x\nSAABSACB ds    xl(SACBblkl)\nSAABcnt  ds    a                       number of elements\nSAABactn ds    a                       number of active\nSAABblkl equ   *-SAABblk\n\n*=====================================================================*\n*  Various dsects                                                     *\n*=====================================================================*\n         IeaNtAsm\n         RexxMacs dsect\n*-\n         END\n//*\n//* Prod version goes to lpalib\n//*\n//L.SYSLMOD DD DISP=SHR,DSN=CBT669.LPALIB(REXXSTOR)\n//*\n//IVP      EXEC PGM=IKJEFT1B,PARM='%RXSTIVP'\n//STEPLIB  DD DISP=SHR,DSN=CBT669.LPALIB\n//SYSEXEC  DD DISP=SHR,DSN=CBT669.LIB\n//SYSTSPRT DD SYSOUT=*,OUTLIM=2000\n//*YSUDUMP DD SYSOUT=*\n//SYSTSIN  DD DUMMY\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXGVCUST": {"ttr": 3335, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x06\\x01 \\x00O\\x01 \\x00o\\x15\\x15\\x00\\x1a\\x00\\x07\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2020-01-04T00:00:00", "modifydate": "2020-01-06T15:15:06", "lines": 26, "newlines": 7, "modlines": 0, "user": "DVL"}, "text": "*-\n* Local customization\n*-\n*\n* JPAQopt determines if the module is kept in storage after first load.\n* This can significantly improve performance if REXXGBLV is loaded from\n* a private library and is used a lot.\n* Set JPAQopt to 'N' if you do not want to retain the module.\n&JPAQopt     setc  'Y'\n*\n* NullLoadRC controls the return code set when a LOAD does not\n* return any records. This also covers the situation where the pool\n* do not exist. You can check the REXXGBLV_MSG varaible for the\n* reason why no records were returned.\n*  Default rc as of build 63 is 4 - note that this has changed from\n* 0 due to user request.\n&NullLoadRC  seta  4\n*\n* NoPoolRc controls the return code set by some functions when the pool\n* is not found.\n*  Default rc as of build 63 is 4 - note that this has changed from\n* 0 due to user request.\n&NoPoolRc    seta  4\n* SaveNoVarRc is the return code set when the SAVE function cannot\n* retrieve the named variable(s) - descrete or generic.\n&SaveNoVarRc seta 4\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXGVDOC": {"ttr": 3337, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01c\\x00\\x12\\x01\\x04\\x07O\\x01 \\x19\\x1f\\x11$\\x023\\x00\\xd5\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.99", "flags": 0, "createdate": "2004-03-14T00:00:00", "modifydate": "2020-07-09T11:24:12", "lines": 563, "newlines": 213, "modlines": 0, "user": "DVL"}, "text": "REXXGBLV - REXX function - Global variable support\n\nSee the PDF version at http://harders-jensen.com/wjtech/programs.html\nor in the install.lib member RXGVPDF. The WORD document is in the\ninstall.lib member RXGVDOCX. They mest be downloaded to a PC before\nthey can be opened.\n\n\nChanges in this build (064)\n\n - Fix STEMIX function.\n\n *Warning - the build id is part of the id of the storage blocks, so\n if you upgrade REXXGBLV to LPALIB then active tasks will not see\n storage blocks created before the upgrade. You must bounce\n long-running tasks immediately after the upgrade. This is to prevent\n errors in case of changes to the storage block structure.\n  Future builds will only change the storage block id if a change to\n the storage block structure has been done.\n\n *Warning - build 063 changes the return code when no records are found\n for load.\n\n\nShort description\n\n REXXGBLV addresses the lack of global storage in REXX. While REXX\n does provide some means of passing data to and retrieve data from\n subroutines, there is no easy method for storing data for later\n retrieval.\n\n REXXGBLV provides a variable store external to the currently\n running REXX program. Variables can be saved and later retrieved by\n the same or another REXX process. The saved variables can be written\n to and retrieved from a disk file, so can be used across logons and\n even be shared amongst users.\n\n The data is stored in a named pool in the home address space above\n the 16MB border.\n\n Any number of pools can be created, till the virtual storage runs\n full.\n\n The maximum length of a variable name is 250. There is no maximum\n data length. Export and import will split the data over more records\n if needed.\n\n The program is re-entrant, so can be installed in LPALIB. See the\n 'Performance' section later for other options.\n\n Additionally, REXXGBLV can index variables, copy variables and list\n variables (useful for debugging).\n\n\nFunction call syntax\n\n REXXGBLV must run as a function:\n       n= REXXGBLV('function parameters')\n\n Refer to the section 'Parameter description' later for a detailed\n description of the parameters.\n\n Add data directly to a pool variable\n\n       ADD  VAR(name) VALUE(data) | VALVAR(varname) \u00ddPOOL(pool)\u00a8\n\n       Data can be a string of max 200 characters without\n       parenthesis or other characters which can invalidate the\n       parm string. Varname is the name of a variable containing\n       the data. Use this instead of VALUE(data) if you are unsure\n       of the data or if the data length is more than 200.\n\n       If the last chars of the name are '.+' then a new stem\n       variable is created with suffix = name.0 + 1 and name.0 is\n       updated. If name.0 do not exist it is created. This is\n       intended for making a simple log feature.\n\n       See sample Add a pool variable directly .\n\n Clear an entire pool and then save REXX variables to the pool\n\n       CLRSAVE VAR(name) \u00ddPOOL(pool)\u00a8\n\n       This is a combined DEL * and SAVE.\n       *deprecated, use DROPSAVE instead.\n\n Delete pool variables, then save REXX variables in the pool\n\n       CLRVSAVE VAR(name) \u00ddPOOL(pool)\u00a8      *deprecated*\n       DELSAVE VAR(name) \u00ddDATA(mask)\u00a8 \u00ddPOOL(pool)\u00a8\n\n       This is a combined DEL and SAVE.\n\n       This call will delete all pool variables matching name ,\n       then save REXX variables matching name in the pool. It can\n       be useful if you previously have stored many variables and\n       now wish to start from scratch.\n       The VAR parameter is required.\n\n Copy REXX variables with prefix\n\n       COPY VAR(name) DATA(mask) PREFIX(prefix)\n\n       'name' must be generic, like MYVAR. or MYVAR* .\n       'prefix' can be any valid variable prefix.\n\n Delete pool variables\n\n       DEL VAR(name) \u00ddPOOL(pool)\u00a8\n\n       The VAR parameter is required.\n\n Delete a pool\n\n       DROP POOL(pool)\n\n       Releases storage.\n       Poolname is required. You cannot delete the internal pools.\n\n Delete a pool, then save REXX variables to the pool\n\n       DROPSAVE VAR(name) \u00ddDATA(mask)\u00a8 POOL(pool)\n\n       This is a combined DEL * and SAVE.\n       Poolname is required. You cannot delete the internal pools.\n\n Export a pool to file\n\n       EXPORT DD(fileref) \u00ddPOOL(pool)\u00a8 \u00ddVAR(name)\u00a8 \u00ddDATA(mask)\u00a8\n\n Imports file to a pool\n\n       IMPORT DD(fileref) \u00ddPOOL(pool)\u00a8 \u00ddVAR(name)\u00a8\n\n       File must have been created by the EXPORT/REXPORT function.\n\n Import file to a pool, then load the pool to REXX variables\n\n       IMPLOAD DD(fileref) \u00ddPOOL(pool)\u00a8 \u00ddVAR(name)\u00a8 \u00ddDATA(mask)\u00a8\n\n       This is a combination of IMPORT and LOAD.\n       File must have been created by the EXPORT/REXPORT function.\n\n Build a REXX stem containing the names of variables in a pool\n\n       INDEX VAR(name) STEM(stem) \u00ddPOOL(pool)\u00a8\n\n       Build a stem containing the names of variables in a pool\n       matching 'name'. Note the stem is built in REXX, not in\n       the pool.\n\n List contents of a pool\n\n       LIST VAR(name) \u00ddPOOL(pool)\u00a8 \u00ddLENGTH\u00a8 \u00ddNW(name-width)\u00a8 \u00ddDW(data-width)\u00a8\n               \u00ddLISTSTEM(listname)\u00a8\n       See the DW, NW, LENGTH and LISTSTEM operands later.\n\n Load pool variables to REXX\n\n       LOAD VAR(name) \u00ddDATA(mask)\u00a8 \u00ddPOOL(pool)\u00a8 \u00ddPREFIX(prefix)\u00a8\n\n       REXX variables can optionally be prefixed, otherwise they\n       are loaded (and replaced) with the pool variable name.\n\n       See sample  Save and retrieve REXX variables .\n\n\n Load pool variables to REXX, then drop the pool\n\n       LOADDROP VAR(name) \u00ddDATA(mask)\u00a8 \u00ddPOOL(pool)\u00a8 \u00ddPREFIX(prefix)\u00a8\n\n       REXX variables can optionally be prefixed, otherwise they are loaded\n       (and replaced) with the pool variable name.\n\n Map the internal memory storage structure\n\n       MAP \u00ddXTENDED\u00a8    XTENDED will map storage entries.\n\n       For debugging.\n\n Load pool variables to REXX, then delete the variables from the pool\n\n       PULL VAR(name) \u00ddDATA(mask)\u00a8 \u00ddPOOL(pool)\u00a8 \u00ddPREFIX(prefix)\u00a8\n\n       This is a combination of LOAD and DEL.\n\n       REXX variables can optionally be prefixed, otherwise they are loaded\n       (and replaced) with the pool variable name.\n\n       The VAR parameter is required.\n\n Return the value from a pool variable\n\n       RETURN VAR(name) \u00ddPOOL(pool)\u00a8\n\n       Null is returned if the variable is null, if the variable\n       does not exist, or if the pool does not exist.\n\n Export REXX variables directly to file\n\n       REXPORT VAR(name) \u00ddDATA(mask)\u00a8 \u00ddDD(fileref)\u00a8\n\n Imports REXX variables directly from file\n\n       RIMPORT \u00ddVAR(name)\u00a8 \u00ddDATA(mask)\u00a8 \u00ddDD(fileref)\u00a8\n\n       File must have been created by the EXPORT/REXPORT function.\n\n Build a stem containing the names of selected REXX variables\n\n       RINDEX VAR(name) \u00ddDATA(mask)\u00a8 STEM(stem) \u00ddDATA(mask)\u00a8\n\n       Create a listing of the variable names matching 'var' in\n       stem 'stem'.\n\n       See sample Build a stem of REXX variable names .\n\n List contents of REXX variables\n\n       RLIST VAR(name) \u00ddDATA(mask)\u00a8 \u00ddLENGTH\u00a8 \u00ddNW(name-width)\u00a8 \u00ddDW(data-width)\u00a8\n             \u00ddLISTSTEM(listname)\u00a8\n\n       See the DW, NW, LENGTH and LISTSTEM operands later.\n       Default is to list to terminal, LISTSTEM can be used to save the list.\n\n Save REXX variables to a pool\n\n       SAVE VAR(name) \u00ddPOOL(pool)\u00a8 \u00ddDATA(mask)\u00a8\n\n       See sample  Save and retrieve REXX variables .\n\n Save REXX variables to a pool, then export the pool to file\n\n       SAVEEXP VAR(name) \u00ddDD(fileref)\u00a8 \u00ddPOOL(pool)\u00a8 \u00ddDATA(mask)\u00a8\n\n       This is a combination of SAVE and EXPORT.\n\n Index a REXX stem\n\n       STEMIX STEM(stem.) \u00ddDATA(mask)\u00a8\n\n       Indexes a stem by taking the basename and putting a running\n       number as the new suffix, plus .0 of course. This is\n       intended to create an index over a stem with non-numeric\n       suffixes.\n\n       Notes - the stem is not sorted\n             - if the stem already has entries with numeric suffixes\n               they may be overwritten.\n\n       See sample Index a REXX stem .\n\n Index a stem (old)\n\n       VARINDEX | VARIX  VAR(var) STEM(stem) \u00ddPOOL(pool)\u00a8\n\n       See INDEX for parameter syntax and usage notes.\n       *deprecated, use INDEX instead*\n\n Shows build info\n\n       VERSION\n\n       Shows build id and date/time of assembly.\n\n       sample:\n          ver=REXXGBLV('version')\n\n Shows totals for selected variables\n\n       RSTAT VAR(var)\n\n       Sample:\n         r=RexxGblv('rlist var(i*)')\n         might return 'count 000012 dtotz 000000000121'\n\n\nParameter description\n\n DATA(mask)\n  Data filter - when name is generic.\n  Mask characters are * for all or none, % for single.\n  Note that the mask is case sensitive.\n  i.e. DATA(K*r*)\n\n DD(fileref)\n  Optional fileref for export and import. Default is RXGVEXP.\n\n DW(data-width)\n  Width of data - LIST/RLIST functions. Default=85 If specified as\n  0 then the actual data width is used.\n\n NW(name-width)\n  Width of name - LIST/RLIST functions. Default=35 If specified as\n  0 then the actual name width is used.\n\n LENGTH\n  Show name- and data length for LIST and RLIST.\n\n POOL(pool)\n  Pool name, max length=16. The name is translated to uppercase, it\n  may contain any characters, but may not begin with '-', '(' or\n  ')'.\n\n PREFIX(p)\n  Prefix for generated variable names. Maximum length is 20 bytes.\n\n STEM(name)\n  Stem name do include the dot. Maximum length is 250 bytes.\n\n TRACE\n  Writes a lot of diagnostic info.\n\n VALUE(data)\n  Data to store for the VAR(name) variable. Used with the ADD\n  function. Maximum length is 200 bytes, do not use parenthesis or\n  quotes.\n\n VALVAR(name)\n  Name of variable containing data. Used with the ADD function when\n  the VALUE parameter would conflict with the syntax parser.\n\n VAR(name)\n  Variable name. Can contain wildcards '*' for multiple or null\n  characters and '%' for a single character.\n  A trailing dot (.) defines a stem base.\n  Maximum length is 250 bytes.\n\n\nDD statements\n\n RXGVEXP\n  Fileref for the EXPORT, IMPORT, REXPORT and RIMPORT functions.\n  RECFM=VB, LRECL should be half-track size. Make LRECL=27994 and\n  BLKSIZE=27994 and you should be ok on a 3390 (like) disk.\n  Alternative DDname can be defined by the DD operand.\n\n\nVariables set at termination\n\n Some information is externalized through the variables below. They\n are all returned, though most will contain zeroes.\n\n  REXXGBLV_EXPORTN  Number of entries exported to pool.\n  REXXGBLV_IMPORTN  Number of entries imported from pool.\n  REXXGBLV_MAXDL    Max data length\n  REXXGBLV_MAXNDL   Max name+data length\n  REXXGBLV_MAXNL    Max name length\n  REXXGBLV_MSG      Reason or failure message\n  REXXGBLV_RLISTN   Number of REXX variables listed.\n  REXXGBLV_RLOADN   Number of REXX variables loaded.\n  REXXGBLV_VDELN    Number of pool variables deleted.\n  REXXGBLV_VLISTN   Number of pool entries listed\n  REXXGBLV_VLOADN   Number of REXX variables loaded.\n  REXXGBLV_VSAVEN   Number of REXX variables saved.\n\n\nPrinciples of operation\n\n REXXGBLV creates a storage areas and use IEANTCR services to build\n name/token pairs to save the information for the areas. The pool name\n can be set in the call to REXXGBLV, thus allowing a virtually\n unlimited number of variable stores.\n\n\nStorage\n\n Pool storage is obtained from storage pool 131, so it survives till\n the TSO online- or batch session is terminated (step end) unless\n specifically freed. All storage, except 64K used for I/O operations,\n is requested from above the line. Using 64-bit storage or data spaces\n has been deemed unnecessary so far.\n  The initial amount of storage for a pool is 1452 bytes. As the pool\n sees activity this will of course increase, actual amount depending on\n the number of variables saved and the combined size of the stored\n variables.\n  Storage is not necessarily released when a variable is deleted.\n Depending on internal settings storage is released or moved to free\n queues from where it can be quickly reused. This is done as an attempt\n to avoid excessive getmain/freemain activity.\n  Not all storage is released when a pool is dropped. Some basic\n control blocks and a number of free elements are kept as an attempt to\n avoid excessive getmain/freemain activity. The maximum storage\n Retained for a dropped pool is currently 11K. There are 3 internal\n pools so assuming one user pool has been created used and dropped, the\n storage retained would be 44K.\n\n\nSamples\n\n Save and retrieve REXX variables\n\n   parse value 'Kilroy was here' with p1 p2 p3\n   cc=REXXGBLV('save pool(p1) var(p*)')\n   say 'List pool.....'\n   cc=REXXGBLV('list pool(p1)')   /* list stored */\n   say 'List actual...'\n   cc=REXXGBLV('rlist var(p*)')   /* list actual */\n   p1='The president'\n   say 'List actual after setting P1'\n   cc=REXXGBLV('rlist var(p*)')   /* list actual */\n   cc=REXXGBLV('load  pool(p1)')  /* reload      */\n   say 'List actual after reload'\n   cc=REXXGBLV('rlist var(p*)')   /* list actual */\n\n  Displays\n\n   List pool.....\n   P1                                  Kilroy\n   P2                                  was\n   P3                                  here\n   # of records listed: 00000003\n   List actual...\n   P1                                  Kilroy\n   P3                                  here\n   P2                                  was\n   List actual after setting P1\n   P1                                  The president\n   P3                                  here\n   P2                                  was\n   List actual after reload\n   P1                                  Kilroy\n   P3                                  here\n   P2                                  was\n\n  Note that REXX variables are not necessarily shown in alphabetical\n  order.\n\n Add a pool variable directly\n\n  Callers code:\n   cc=RexxGblv( del var(log.) )\n   /*or cc=RexxGblv( add var(log.0) value(0) ) */\n   Call Sub1\n   cc=RexxGblv('load var(log.)')\n   do n=1 to log.0\n     say log.n\n   end\n\n  Sub1 code:\n   cc=RexxGblv( add var(log.+) value( time()  Program started) )\n     .. some code ..\n   cc=RexxGblv( add var(log.+) value( time()  Program ended) )\n   Return 0\n\n  Will show something like this:\n   15:24:33 Program started\n   15:24:34 Program ended\n\n Export and import directly to/from file\n\n  Fileref\n    //RXGVEXP  DD RECFM=VB,LRECL=27994,SPACE=(TRK,(5,5)),UNIT=SYSDA,..\n\n  Program\n    Alpha    = 'Letter nr 01'\n    Charlie  = 'Letter nr 03'\n    India    = 'Letter nr 09'\n    Juliet   = 'Letter nr 10'\n    Romeo    = 'Letter nr 18'\n    Sierra   = 'Letter nr 19'\n    Tango    = 'Letter nr 20'\n    Zulu     = 'Letter nr 26'\n    cc=RexxGblv('rexport var(*ie*)')\n    say REXXGBLV_EXPORTN+0 'variables exported'\n    drop alpha charlie india juliet romeo sierra tango zulu\n    say  alpha charlie india juliet romeo sierra tango zulu\n    cc=RexxGblv('rimport var(*lie*)')\n    say REXXGBLV_IMPORTN+0 'variables imported'\n    say  alpha charlie india juliet romeo sierra tango zulu\n    cc=RexxGblv('rimport')\n    say REXXGBLV_IMPORTN+0 'variables imported'\n    say  alpha charlie india juliet romeo sierra tango zulu\n\n   Shows\n    3 variables exported\n    ALPHA CHARLIE INDIA JULIET ROMEO SIERRA TANGO ZULU\n    2 variables imported\n    ALPHA Letter nr 03 INDIA Letter nr 10 ROMEO SIERRA TANGO ZULU\n    3 variables imported\n    ALPHA Letter nr 03 INDIA Letter nr 10 ROMEO Letter nr 19 TANGO ZULU\n\n Build a stem of REXX variable names\n\n   data.0   = 'zero'\n   dataf    = 'sixth letter in the alphabet'\n   foxtrot  = 'foxtrot is a dance'\n   datad    = 'delta'\n   faulty   = 'Faulty Towers'\n   function = 'test filter'\n   cc=REXXGBLV('rindex var(f*t*) stem(filter.)')\n\n  creates\n\n   FILTER.0 = '00000003'\n   FILTER.1 = 'FAULTY'\n   FILTER.2 = 'FUNCTION'\n   FILTER.3 = 'FOXTROT'\n\n Index a REXX stem\n\n   CAR.BMW   = 'german car make'\n   CAR.FORD  = 'USA car make'\n   CAR.MAZDA = 'japanese car make'\n   cc=RexxGblv('stemix stem(car.)')\n\n  creates\n\n   CAR.0  = '00000003'\n   CAR.1  = 'BMW'\n   CAR.2  = 'MAZDA'\n   CAR.3  = 'FORD'\n\n See member RXGVSAMP for more samples.\n\n\nInstallation\n\n See member REXXGBLV.\n\n If you do not want to use the stay-in-JPAQ feature, then change the\n statement\n    CDEUCTZ2 dsect=N\n to a comment.\n\n\nInitial verification\n\n See members RXGVIVP$ (JCL) and RXGVIVP (program). The REXXGBLV\n installation step is set up to execute the IVP member as well. The IVP\n job can also be used for samples, but the RXGVSAMP member is probably\n more readable.\n\n\nPerformance\n\n REXXGBLV is fully reentrant, so can reside in LPALIB or linklist.\n LPALIB is recommended. If run from JOBLIB or STEPLIB the program will\n reload itself, thus remaining in JPAQ - or in other words there will\n be only one program load for the entire session. See the Install\n section for how to disable this feature.\n\n\nComments etc\n\n Comments can be sent as email to\n\n   Willy(at)harders-jensen(dot)com\n\n substitute (at) with @ and (dot) with .\n\n\nWeb\n\n The newest version of REXXGBLV, plus much much more, is found at\n       Http://harders-jensen.com/wjtech/programs.html\n\n\nHave fun\n\n Willy Jensen\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXGVHIST": {"ttr": 3591, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01D\\x00\\x05\\x01\\x032o\\x01 \\x18\\x8f\\x15\\x07\\x00u\\x00\\x07\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.68", "flags": 0, "createdate": "2003-11-22T00:00:00", "modifydate": "2020-07-06T15:07:05", "lines": 117, "newlines": 7, "modlines": 0, "user": "DVL"}, "text": "Vers  Desc\n019   the first real production ready version\n020   change VCB to double-linked list as a prep for later performance\n      enhancement.\n      move logically deleted VCBs to a separate (single-linked) list (perf).\n021   add the EXPORT/IMPORT commands\n022   beautifying\n023   add 'SHORT' operand to VLIST.\n024   add 'ADD VAR(name) function.\n025   fix problem with the PARMSCAN subroutine when value is 1 byte.\n      fix variable handling problem with the ADD subroutine.\n027   add new VCBs in sorted order, so the locate function can stop when\n      reaching a lower collating seq (perf).\n028   LISTVAR, VERSION and REXXVPUT added.\n029   INDEX function added. Major rewrite as I am starting to use the\n      structured macros.\n030   Maintenance.\n031   Variable length set default to 250 after a request from ibm-main.\n032   Fixed bug in the import function - it didn't add data to the\n      internal data store.\n033 - Allow poolname gt 8 bytes, max 16.\n      Note that the poolname becomes part of the name of a name/token pair.\n      If the poolname length is less than or equal to 8 then the name\n      is internally prefixed with '$REXXGB' which should make it unique.\n      If a poolname wider than 8 bytes is supplied, then the user must\n      ensure uniqueness!!\n    - Show 'Listing' and the poolname in the output from the LIST\n      function.\n034 - Fix problem where \"export\" function truncates values.\n      Thanks to Johann Sagm\u00fcller from s-itsolutions for finding the problem\n      and suggesting a fix.\n035 - RC=4 if no variables loaded.\n      RC=8 if type READ and pool not found.\n036 - RLIST is not a pool read function, so a pool must not exist\n      and by the way, RLIST is now documented.\n037 - RINDEX changed so that the value of the generated stem is the source\n      stem suffix, not the entire stem name. I.e if the original stem name\n      is cities.sydney, then only 'sydney' is stored in the numbered stem.\n038 - Fix problem with save of variables with length shorter than stored.\n      Before this fix the data length was not updated.\n      New parm DD(ddname) to EXPORT and IMPORT.\n      if VAR(var) specifies a stem then generic processing is used.\n      Fix loop with VLOAD and an empty pool\n039 - New functions CLRSAVE and CLRVSAVE.\n      New functions SAVEEXP and IMPLOAD.\n040 - use PARMSCN2 for parameter extraction\n041 - return value: vv=REXXGBLV('return var(name)')\n042 - use external copybook REXXMACS for REXX interface macros\n      Trace ddname now RXGVLOG\n043 - Internal data length limit removed.\n      Problems with generic retrieval fixed.\n044 - export/import data length limit removed.\n      return error message in REXXGBLV_MSG instead of SAYing it.\n045 - externalizing values\n        REXXGBLV_MAXNL   max name length\n        REXXGBLV_MAXDL   max data length\n        REXXGBLV_MAXNDL  max name+data length\n      STEMIX call should now be: STEMIX STEM(stemname.)\n046 - fix storage overlay\n      new externalized values\n        REXXGBLV_RLISTN  number of entries listed for RLIST\n        REXXGBLV_VLISTN  number of entries listed for LIST\n047 - minor internal fixes\n        RxStemNm -> RxStemName\n048 - add the COPY command.\n049 - add the VARIX command.\n    - change: RETURN will return a null value if pool or variable do not exist.\n050 - add the LOADDROP command.\n      externalizing values\n        REXXGBLV_VSAVEN  number of entries saved\n051 - fix creeping storage, 32K was not freed at end\n052 - program is now fully reentrant, so can reside in LPALIB\n053 - LOGGER subroutine uses REXX SAY instead of write to RXGVLOG DD.\n      VEXP and VIMP have been changed so that the entire program can\n      reside in 31-bit storage.\n054 - Changes in this build\n        The RINDEX command is dropped, use VARIX instead.\n      Fixed in this build\n        INDEX STEM operand not handled correctly.\n        Tracing now works for all components\n\n055 - add command PULL - load vars and delete from store.\n056 - add operand VALVAR - name of variable containing value, used with\n      function ADD\n\n057 - add operand LISTSTEM for LIST and RLIST commands\n      change internals re the STRMAKE and STRCOPY macros etc.\n      fix potential abend S0C4 when building trace records\n\n058 - Major internal rewrite.\n    - Some functions like IMPLOAD now uses an temporary pool, so you do\n      not have to delete a named pool before and after.\n    - Command CLRVSAVE renamed to DELSAVE, CLRVSAVE kept as alias.\n    - Command CLRSAVE renamed to DROPSAVE, CLRSAVE kept as alias.\n    - New command REXPORT exports REXX variables directly to the file.\n    - New command RIMPORT imports  REXX variables directly from export\n      file.\n    - New command MAP for debugging.\n\n059 - Performance enhancement, keep module in JPAQ\n    - Documentation changes\n\n060 - Fix abend S40A in RLIST when no REXX variables exist.\n    - Virtual storage constraint relief, minimize risk of abend S878.\n    - Internal change, use own pattern match routine instead of ASAXWC.\n    - New command RLIST - return count and total data size of selected\n      variable(s).\n    - New operand DATA(mask) to filter on data contents.\n\n061 - Handle abends in IMPORT open, i.e. when empty dataset.\n\n062 - 31-bit I/O buffers, linked as rmode any\n063 - Set rc=4 if no records are returned.\n    - Set rc=4 for some founctions if pool is not found.\n    - Set rc=4 if SAVE could not retrieve variables to store.\n    This is customizable, see new customization member RXGVCUST.\n064 - Fix STEMIX function function.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXGVIVP$": {"ttr": 3594, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x16\\x00\\x10\\x01\\x17\\x05o\\x01  O\\x14S\\x00\\t\\x00\\x08\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.22", "flags": 0, "createdate": "2017-02-25T00:00:00", "modifydate": "2020-07-22T14:53:10", "lines": 9, "newlines": 8, "modlines": 0, "user": "DVL"}, "text": "//RXGVIVP$ JOB (1),'REXXGBLV-IVP',CLASS=A,MSGCLASS=X,REGION=0M\n//*\n//IVP      EXEC PGM=IKJEFT1B,PARM=RXGVIVP1\n//STEPLIB  DD DISP=SHR,DSN=CBT669.LPALIB\n//SYSEXEC  DD DISP=SHR,DSN=CBT669.PP.REXXGBLV.V062.LIB\n//*YSMDUMP DD DISP=OLD,DSN=CBT669.SYSMDUMP\n//RXGVEXP  DD RECFM=VB,LRECL=23000,SPACE=(TRK,(5,5)),UNIT=SYSDA\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD DUMMY\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RXGVIVPX": {"ttr": 3596, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x04\\x01\\x19'\\x7f\\x01\\x19'\\x7f\\x155\\x00{\\x01\\xe9\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-10-04T00:00:00", "modifydate": "2019-10-04T15:35:04", "lines": 123, "newlines": 489, "modlines": 0, "user": "DVL"}, "text": "/*                                                                rexx\n REXXGBLV test - recovery\n*/\n arg p\n parse var p . 'PGM('pgm')' . 0 . 'TRC('trc')' .\n pgm=word(pgm 'REXXGBLV',1)\n if p<>'' then do\n   say 'Parameters:' p\n   say 'Pgmname:' pgm\n   say 'Trace:  ' trc\n end\n Interpret \"say 'Version:'\" pgm\"('version')\"\n say ''\n\n /*- Import from null dataset - build 061                -*/\n zz=bpxwdyn('alloc new delete dd(b061dd)',\n   'lrecl(80) recfm(f,b) tracks space(1,1) unit(sysda)')\n Call RunPgm 'import pool(b061) dd(b061dd) trace','import from null ds',8\n zz=bpxwdyn('free dd(b061dd)')\n\n /*-------------------- all ok ---------------------------*/\n /* end */\n say ''\n exit xmsg('All ok',0)\n\nXMsg: if arg(1)<>'' then say arg(1);return word(arg(2) 99,1)\n\nDoListVar:\n trace off\n do $=1 to words(arg(1))\n   say left(word(arg(1),$),12)':<'Value(word(arg(1),$))'>'\n end\n return 0\n\nRunPgm:\n if arg(2)<>'' then say '->' arg(1) '-' arg(2)\n else say '->' arg(1)\n t=''\n if wordpos(translate(word(arg(1),1)),trc)>0 then t='TRACE'\n rexxgblv_msg=''\n Interpret \"cc=\"pgm\"(arg(1)\" t\")\"\n say 'retval  \"'cc'\"'\n say 'message \"'strip(REXXGBLV_msg,'t')'\"'\n testvl='VSAVEN VLOADN VLISTN RLISTN RLOADN importn exportn vdeln',\n        'MAXNL MAXDL MAXNDL'\n do n=1 to words(testvl)\n   w =word(testvl,n)\n   zz=Value(w,Value('REXXGBLV_'w)+0)\n end\n say 'vsaven='REXXGBLV_VSAVEN+0,\n     'vloadn='REXXGBLV_VLOADN+0,\n     'vlistn='REXXGBLV_VLISTN+0,\n     'vdeln='REXXGBLV_VdelN+0,\n     'rlistn='REXXGBLV_RLISTN+0,\n     'rloadn='REXXGBLV_RLOADN+0,\n     'importn='REXXGBLV_importn+0,\n     'exportn='REXXGBLV_exportn+0,\n     'maxnl='REXXGBLV_MAXNL+0,\n     'maxdl='REXXGBLV_MAXDL+0,\n     'maxndl='REXXGBLV_MAXNDL+0\n if cc=0 then return 0\n say '    Rc' cc rexxgblv_msg\n if arg(3)<>'' then if cc>arg(3) then exit 20\n return  cc\n\nDataSort: procedure expose data.\n n=data.0\n h=n\n do while h>1\n   h=h%2\n   do i=1 to n-h\n     j=i\n     k=h+i\n     do while data.k<data.j\n       t=data.j\n       data.j=data.k\n       data.k=t\n       if h>=j then leave\n       j=j-h\n       k=k-h\n     end   /*while data.k<data.j*/\n   end     /*i*/\n end       /*while h>1*/\n return\n\n/* Return region in use.  Origin: Mark Zelden's REXXSTOR       */\nRgnInUse: Procedure\nNumeric digits 14                            /* dflt of 9 not enough!*/\nASCB     = C2d(Storage(224,4))               /* current ASCB         */\nLDA      = C2d(Storage(D2x(ASCB + 48),4))    /* local data area      */\nLDAEVVRG = C2d(storage(D2x(LDA + 220),4))    /* >16m reg size        */\nLDAEVVRG = Right(LDAEVVRG/1024,9)            /* convert to kbytes    */\nLDALOAL  = C2d(storage(D2x(LDA + 232),4))    /* <16m reg alloc       */\nLDALOAL  = Right(LDALOAL/1024,9)             /* convert to kbytes    */\nReturn  LDALOAL\n\nV054TestTrace: Procedure expose pgm\n say 'v054 passed trace test'\n v054.1='Kilroy'\n v054.2='was'\n v054.3='here'\n Call RunPgm 'Save  var(v054.)  pool(tracetest) trace(y)'\n Call RunPgm 'Drop pool(tracetest)'\n return 0\n\nDrWhoData:\n drop drwho.\n drwho.1  =  'Doctor Who is a British science-fiction television'\n drwho.2  =  'Programme produced by the BBC from 1963 to the present'\n drwho.3  =  'Day. The programme depicts the adventures of The'\n drwho.4  =  'Doctor, a Time Lord a time-travelling humanoid alien.'\n drwho.5  =  'He explores the universe in his TARDIS, a sentient'\n drwho.6  =  'Time-travelling space ship. Its exterior appears as a'\n drwho.7  =  'Blue British police box, which was a common sight in'\n drwho.8  =  'Britain in 1963 when the series first aired. Along'\n drwho.9  =  'With a succession of companions, the Doctor combats a'\n drwho.10 =  'Variety of foes while working to save civilisations'\n drwho.11 =  'And help people in need.'\n drwho.0  =  11\n drwhowhat=  'Doctor Who is a British sci-fi tv programme from 1963'\n drwhobox =  'TARDIS looks like a blue British police box'\n drwhowho =  'a Time Lord working to save civilisations'\n return 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXGVIVP1": {"ttr": 3841, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01c\\x00D\\x01\\x17\\x05o\\x01  O\\tI\\x02\\x0e\\x00N\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.99", "flags": 0, "createdate": "2017-02-25T00:00:00", "modifydate": "2020-07-22T09:49:44", "lines": 526, "newlines": 78, "modlines": 0, "user": "DVL"}, "text": "/*                                                                rexx\n REXXGBLV test 0 - initial - basic functions\n*/\n arg p\n parse var p . 'PGM('pgm')' . 0 . 'TRC('trc')' .\n pgm=word(pgm 'REXXGBLV',1)\n if p<>'' then do\n   say 'Parameters:' p\n   say 'Pgmname:' pgm\n   say 'Trace:  ' trc\n end\n Interpret \"say 'Returned version:'\" pgm\"('version')\"\n say ''\n\n /* signal v050 */\n\n F='foxtrot'\n D='delta'\n Delta='d'\n X='xerox'\n K='kilo'\n E='echo'\n M='midway'\n\n Call RunPgm 'rlist','List all known variables...',0\n Call RunPgm 'save var(D*) ','Save D*',0\n Call RunPgm 'list','List pool, should only contain D*',0\n if rexxgblv_vlistn<>2 then,\n   exit xmsg('Number of variables listed is' rexxgblv_vlistn+0', not 2',8)\n Call RunPgm 'save','Save all known variables...',0\n Call RunPgm 'list'\n\n say 'Variables before drop'\n Call DoListVar 'F D X K E M '\n\n drop  F D X K E M\n say 'Variables after drop'\n Call DoListVar 'F D X K E M '\n\n Call RunPgm 'load','Reload saved variables',0\n say 'Variables after load'\n Call DoListVar 'F D X K E M '\n\n /* compare contents after load */\n if  F<>'foxtrot' then exit xmsg('var F not loaded ok',8)\n if  D<>'delta'   then exit xmsg('var D not loaded ok',8)\n if  X<>'xerox'   then exit xmsg('var X not loaded ok',8)\n if  K<>'kilo'    then exit xmsg('var K not loaded ok',8)\n if  E<>'echo'    then exit xmsg('var E not loaded ok',8)\n if  M<>'midway'  then exit xmsg('var M not loaded ok',8)\n say 'Variables reloaded successfully'\n say ''\n\n /* now test subset of variables */\n Call RunPgm 'drop','Drop variable pool',0\n say 'Test subset of variables'\n va1='kilroy'\n va2=' was'\n va3='  here'\n vb1='    yesterday'\n qq1='q-var 1'\n qq2='q-var 2'\n Call RunPgm 'save var(v*)',,0\n Call RunPgm 'save var(q*)',,0\n Call RunPgm 'list','List store',0\n parse value 'winter is comming' with va1 va2 va3\n vb1='day before yesterday'\n say 'va1-3 and vb1 set to:' va1 ','va2','va3','vb1\n Call RunPgm 'rlist var(v*)','List actual',0\n\n Call RunPgm 'load  var(va*)','reload va*',0\n if REXXGBLV_VLOADN<>3 then exit xmsg('# of records loaded not 3',20)\n say ''\n\n say 'Call IVP2'\n if RxGvIvp2()<>0 then exit 8\n say 'Call IVP2 done'\n\n Call RunPgm 'rlist var(v*)','List actual after update of va*',0\n if va1<>'kilroy' then exit xmsg('var VA1 not loaded ok',8)\n if vb1<>'day before yesterday' then exit xmsg('var VB1 overwritten',8)\n say 'Variables successfully replaced'\n say ''\n\n say 'Test export / import'\n drop data.\n data='alpha beta foxtrot delta xerox kilo echo midway'\n datan=200\n data.0=datan\n save.0=datan\n expml=0\n do n=1 to datan\n   data.n=time('l') copies(data' ',n)\n   save.n=data.n\n   expml=max(expml,length(data.n))\n end\n say datan 'test records generated for export, size of last:',\n   length(data.datan) 'size of largest:' expml\n cc=RunPgm('rexport var(data.) ',,0)\n say 'data.0 after export:' data.0\n drop data.\n\n cc=RunPgm('rimport',,0)\n impml=0\n say 'data.0 after import:' data.0\n do n=0 to datan\n   if data.n<>save.n then do\n     say 'Data not matched at #' n\n     say '  Old:   ' save.n\n     say '  Reload:' data.n\n     exit 20\n   end\n   impml=max(impml,length(data.n))\n end\n if impml<>expml then,\n   exit xmsg('imported maxlength' impml 'does not match saved',20)\n say 'Imported data matches exported'\n drop data. save.\n say ''\n\n /* demo stem-index feature\n    for each data.name a data.n is created, plus a data.0  */\n say 'Make index over stem. (INDEX)'\n data.f='foxtrot'\n data.d='delta'\n data.x='xerox'\n data.k='kilo'\n data.e='echo'\n data.m='midway'\n data.2='two'\n data.9='niner'\n Call RunPgm 'rlist var(data.)','data. before',0\n Call RunPgm 'rindex var(data.) stem(index.)','make index',0\n say ''\n Call RunPgm 'rlist var(index.)'\n say ''\n if index.0<>8 then exit xmsg('index.0 is' index.0', not 8')\n say 'data.0=6 as expected'\n say ''\n Call RunPgm 'rlist var(data.)','After'\n\n say 'Make index over stem. (STEMIX)'\n CAR.BMW     = 'german car make'\n CAR.FORD    = 'USA car make'\n CAR.MAZDA   = 'japanese car make'\n CAR.PEUGEOT = 'french car make'\n Call RunPgm 'stemix stem(car.) ',0\n Call RunPgm 'rlist var(car.)'\n if car.0<>4 then exit xmsg('Stemix not correct',8)\n\n /* test COPY (build 048) */\n say ''\n say 'Test COPY'\n Call RunPgm 'copy var(data.) prefix(z)'\n Call RunPgm 'rlist var(data.)'\n testcopyn=REXXGBLV_RLISTN\n say REXXGBLV_RLISTN+0 'data. entries found'\n Call RunPgm 'rlist var(zdata.)'\n say REXXGBLV_RLISTN+0 'zdata. entries found'\n if testcopyn<>REXXGBLV_RLISTN then exit xmsg('** missmatch',20)\n say 'counts match'\n\n /* demo var-index feature introduced in build 049\n    for each data* name a stem.n is created, plus a stem.0  */\n say 'Make index over data. (VARIX)'\n drop data. a b c d e f g h i j k l m n o p q r s t u v w x y z\n data.f='foxtrot'\n dataf ='foxtrot'\n data.d='delta'\n data.x='xerox'\n data.k='kilo'\n data.kilo='1000g'\n datae ='echo'\n data.e='echo'\n data.m='midway'\n drop #data.\n Call RunPgm 'rindex var(data*) stem(#data.)','make var index',0\n say ''\n if #data.0<>11 then exit xmsg('#data.0 ne 11, it is' #data.0)\n say '#data.0=11 as expected'\n say ''\n do n=1 to #data.0\n   say left('#data.'n,12) left(#data.n,20)\n end\n say ''\n\n /* test RETURN modification (build 049) */\n say ''\n say 'Test RETURN'\n cc=rexxgblv('return var(t1)')   /* non-existing variable */\n if cc<>'' then exit xmsg('return var(t1) returned' cc', not null')\n say 'return var(t1) returned null as expected'\n cc=rexxgblv('add var(t1) value(test) ')\n cc=rexxgblv('return var(t1)')\n if cc<>'test' then exit xmsg('return var(t1) returned' cc', not ''test''')\n say 'return var(t1) returned ''test'' as expected'\n cc=rexxgblv('return var(t1) pool(t1)')\n if cc<>'' then exit xmsg('return var(t1) pool(t1) returned' cc', not null')\n say 'return var(t1) pool(t1) returned null as expected'\n longvar=copies(xrange('a','z'),100)\n say 'length of longvar:' length(longvar)\n cc=rexxgblv('save var(longvar)')\n nv=rexxgblv('return var(longvar)')\n if nv<>longvar then exit xmsg('returned data not eq LONGVAR variable')\n say 'Test RETURN successful, length of returned value is' length(nv)\n drop nv longvar\n\n /* test LOADDROP (build 050) */\nV050:\n say ''\n say 'Test LOAD&DROP (build 050)'\n v050.v1='Kilroy'\n v050.v2='was'\n v050.v3='here'\n Call RunPgm 'save var(v050.) pool(v050)'\n say REXXGBLV_VSAVEN+0 'entries saved'\n if REXXGBLV_VSAVEN<>3 then exit xmsg('Error, should have been 3')\n drop v050.\n call RunPgm 'rlist var(v050.)','After drop'\n say REXXGBLV_RLISTN+0 'entries listed'\n if REXXGBLV_RLISTN<>0 then exit xmsg('Error, should have been 0')\n Call RunPgm 'map'\n Call RunPgm 'map xtended'\n Call RunPgm 'loaddrop var(v050.) pool(v050)'\n say 'Entries loaded:' REXXGBLV_VLOADN +0\n if REXXGBLV_VLOADN<>3 then exit xmsg('Error, vloadn should have been 3')\n cc=RunPgm('list pool(v050)')\n if REXXGBLV_VLISTN<>3 then exit xmsg('Error, vlistn should have been 3')\ntrace off\n\n /* test V051 storage creep fixed */\nV051:\n say ''\n say 'v051 test'\n rgn1=RgnInUse()\n cc=RexxGblv('version')\n rgn2=RgnInUse()\n if rgn2<>rgn1 then,\n   exit xmsg('Storage creep detected, region increased by' rgn2-rgn1'K',8)\n say 'v051 passed test, region use stayed at' space(rgn1)'K'\n\n /* test V054 - INDEX fix, full tracing  */\nV054:\n say ''\n say \"v054 test '\"index\"'\"\n v054d.0 ='zero'\n v054df  ='foxtrot'\n v054dd  ='delta'\n v054d.n ='Norway'\n v054d.6 ='six'\n Call RunPgm 'Save  var(v054d*)   pool(indextest)'\n Call RunPgm 'Index stem(v054x.)  pool(indextest)'\n if v054x.0<>5 then,\n   exit xmsg('V054 - Index stem size is' v054x.0', 5 was expected')\n say 'v054 passed index test, index stem size is 5'\n Call RunPgm 'Drop pool(indextest)'\n drop v054d. v054x.\n Call V054TestTrace\n\n /* test V055 - PULL  */\nV055:\n say ''\n say \"v055 test '\"PULL\"'\"\n v055d.0 ='zero'\n v055df ='foxtrot'\n v055dd ='delta'\n v055d.n ='Norway'\n v055d.6 ='six'\n parse value 'kilroy was here' with v055p.1 v055p.2 v055p.3\n Call RunPgm 'Save var(v055*) pool(i055)'\n Call RunPgm 'Pull var(v055d*) pool(i055)'\n say 'loadcnt:' rexxgblv_vloadn', delcnt:' rexxgblv_vdeln\n if rexxgblv_vloadn<>5 | rexxgblv_vdeln<>5 then ,\n    exit xmsg('Unexpected values, both should have benn 5',8)\n Call RunPgm 'List  pool(i055)'\n if rexxgblv_vlistn<>3 then exit xmsg('List should have shown 3 records',8)\n Call RunPgm 'RList var(v055d*)'\n if rexxgblv_rlistn<>5 then exit xmsg('List should have shown 5 records',8)\n Call RunPgm 'Drop pool(i055)'\n drop v055d. v055p. v055dd v055df\n\n /* test V056 - ADD, old and new   */\nV056:\n say ''\n say 'v056 test ADD'\n Call RunPgm 'drop pool(i056test)'\n testdata1=mvsvar('sysname') date() time('l')\n say 'testdata:' testdata1\n Call RunPgm 'add var(td1) value('testdata1') pool(i056test)'\n Call RunPgm 'List  pool(i056test)'\n\n testdatavar='i056_test_variable'\n zz=Value(testdatavar,mvsvar('sysname') date() time('l'))\n say 'testdatavar/testdata:' testdatavar'/'Value(testdatavar)\n Call RunPgm 'add var('testdatavar') valvar('testdatavar') pool(i056test)'\n Call RunPgm 'List  pool(i056test)'\n\n say 'test +1'\n Call RunPgm 'add var(i056var.+) valvar('testdatavar') pool(i056test)'\n Call RunPgm 'List  pool(i056test)'\n\n /* now verify contents */\n v = rexxgblv('return var(td1) pool(i056test)')\n if v<>testdata1 then exit xmsg(\"var td1 not '\"testdata1\"'\",8)\n v = rexxgblv('return var('testdatavar') pool(i056test)')\n if v<>value(testdatavar) then,\n   exit xmsg('var' testdatavar 'not' value(testdatavar),8)\n v = rexxgblv('return var(i056var.0) pool(i056test)')\n if v<>1 then exit xmsg(\"var i056var.0 not 1\",8)\n v = rexxgblv('return var(i056var.1) pool(i056test)')\n if v<>value(testdatavar) then,\n   exit xmsg('var i056var.1 not' value(testdatavar),8)\n say ''\n\n /* ADD ok  */\n Say 'ADD and V056 ok'\n\n /*---------------- list to stem - build 057 -------------*/\n drop ls.\n call drwhodata\n cc=RunPgm('save var(drwho*) pool(test057)',,0)\n cc=RunPgm('list pool(test057) liststem(ls.)',,0)\n do n=0 to ls.0\n   say 'ls.'n '=' ls.n\n end\n if ls.0<>4+drwho.0 then,\n   exit xmsg('ls.0 is' 0+ls.0', not' 4+drwho.0,8)\n drop drwho.\n say 'List DrWho stem... ('ls.0' entries)'\n do n=1 to ls.0\n   say ls.n\n end\n cc=RunPgm('drop pool(test057)',,0)\n drop ls. drwho.\n\n /*---------------- long variable names ------------------*/\n testinganextremelylongstemnameaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaz.1=,\n 'testinganextremelylongstemdataaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1'\n testinganextremelylongstemnameaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaz.2=,\n 'testinganextremelylongstemdataaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa2'\n testinganextremelylongstemnameaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaz.3=,\n 'testinganextremelylongstemdataaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3'\n cc=RunPgm('save var(testing*) pool(longvar)',,0)\n cc=RunPgm('list pool(longvar)',,0)\n drop ,\n testinganextremelylongstemnameaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaz.\n cc=RunPgm('load  pool(longvar)',,0)\n say ''\n\n /*---------------- map PVT - build 057     -------------*/\n cc=RunPgm('map',,0)\n\n /*---------------- test invalid command handling -------*/\n kilroy='was here'\n cc=RunPgm('zave var(kilroy) trace',,8)\n cc=RunPgm('save vzr(kilroy)',,8)\n say ''\n\nV060:\n /* V060 - test RSTAT              */\n Call DrWhoData\n say 'test V060 - RSTAT'\n Call RunPgm('rlist var(DrWho.)')\n xl=0\n do n=0 to drwho.0\n   xl=xl+length(drwho.n)\n end\n say 'RSTAT expected length' xl\n say ''\n r = RunPgm('rstat var(drwho.)')\n say 'RSTAT returned:' r\n if word(r,4)+0 <> xl then exit xmsg('Length missmatch',8)\n\n /* v060 - test data pattern check */\n v060xn=2 /* expected # of records */\n Call RunPgm 'rindex var(drwho*) data(*program*) stem(#data.)',,\n             'make var index',0\n say ''\n if #data.0<>v060xn then exit xmsg('#data.0 ne' v060xn ', it is' #data.0)\n say '#data.0='v060xn 'as expected'\n say ''\n do n=1 to #data.0\n   say left('#data.'n,12) left(#data.n,20) value(#data.n)\n end\n say ''\n\n Call RunPgm 'dropsave var(drwho*) data(*program*) pool(drwho)',,\n             'make pool from drwho',0\n Call RunPgm 'list pool(drwho)','list drwho pool',0\n if REXXGBLV_VLISTN<>v060xn,\n then exit xmsg('# records in pool is not' v060xn,20)\n\n /*- Import from null dataset - build 061                -*/\n zz=bpxwdyn('alloc new delete dd(b061dd)',\n   'lrecl(80) recfm(f,b) tracks space(1,1) unit(sysda)')\n Call RunPgm 'import pool(b061) dd(b061dd)','import from null ds',8\n zz=bpxwdyn('free dd(b061dd)')\n say ''\n\n /*---- rc=4 when no records saved or loaded - build 063 -*/\n drop kilroy kilroy.\n say 'test rc=4 when no records returned - build 063'\n text='kilroy was here'\n zz=RexxGblv('save var(text) pool(p063)')\n cc=RunPgm('load var(test) pool(p063)',,4)\n if cc<>4 then exit xmsg('Null load should set rc 4',20)\n cc=RunPgm('load var(text) pool(z063)',,4)\n if cc<>4 then exit xmsg('Null load should set rc 4',20)\n say ''\n\n say 'Save non-existing descrete variable'\n cc=RexxGblv('save var(kilroy) pool(p063)')\n if cc<>4 then exit xmsg('Null save should set rc 4',20)\n say 'rc='cc 'text='rexxgblv_msg\n say ''\n\n say 'Save non-existing generic variable'\n cc=RexxGblv('save var(kilroy.) pool(p063)')\n if cc<>4 then exit xmsg('Null save should set rc 4',20)\n say 'rc='cc 'text='rexxgblv_msg\n say ''\n\n\n /*-------------------- all ok ---------------------------*/\n /* end */\n say ''\n exit xmsg('All ok',0)\n\nXMsg: if arg(1)<>'' then say arg(1);return word(arg(2) 99,1)\n\nDoListVar:\n trace off\n do $=1 to words(arg(1))\n   say left(word(arg(1),$),12)':<'Value(word(arg(1),$))'>'\n end\n return 0\n\nRunPgm:\n if arg(2)<>'' then say '->' arg(1) '-' arg(2)\n else say '->' arg(1)\n t=''\n if wordpos(translate(word(arg(1),1)),trc)>0 then t='TRACE'\n rexxgblv_msg=''\n Interpret \"cc=\"pgm\"(arg(1)\" t\")\"\n say 'retval  \"'cc'\"'\n say 'message \"'strip(REXXGBLV_msg,'t')'\"'\n testvl='VSAVEN VLOADN VLISTN RLISTN RLOADN importn exportn vdeln',\n        'MAXNL MAXDL MAXNDL'\n do n=1 to words(testvl)\n   w =word(testvl,n)\n   zz=Value(w,Value('REXXGBLV_'w)+0)\n end\n say 'vsaven='REXXGBLV_VSAVEN+0,\n     'vloadn='REXXGBLV_VLOADN+0,\n     'vlistn='REXXGBLV_VLISTN+0,\n     'vdeln='REXXGBLV_VdelN+0,\n     'rlistn='REXXGBLV_RLISTN+0,\n     'rloadn='REXXGBLV_RLOADN+0,\n     'importn='REXXGBLV_importn+0,\n     'exportn='REXXGBLV_exportn+0,\n     'maxnl='REXXGBLV_MAXNL+0,\n     'maxdl='REXXGBLV_MAXDL+0,\n     'maxndl='REXXGBLV_MAXNDL+0\n if cc=0 then return 0\n say '    Rc' cc rexxgblv_msg\n if arg(3)<>'' then if cc>arg(3) then exit 20\n return  cc\n\nDataSort: procedure expose data.\n n=data.0\n h=n\n do while h>1\n   h=h%2\n   do i=1 to n-h\n     j=i\n     k=h+i\n     do while data.k<data.j\n       t=data.j\n       data.j=data.k\n       data.k=t\n       if h>=j then leave\n       j=j-h\n       k=k-h\n     end   /*while data.k<data.j*/\n   end     /*i*/\n end       /*while h>1*/\n return\n\n/* Return region in use.  Origin: Mark Zelden's REXXSTOR       */\nRgnInUse: Procedure\nNumeric digits 14                            /* dflt of 9 not enough!*/\nASCB     = C2d(Storage(224,4))               /* current ASCB         */\nLDA      = C2d(Storage(D2x(ASCB + 48),4))    /* local data area      */\nLDAEVVRG = C2d(storage(D2x(LDA + 220),4))    /* >16m reg size        */\nLDAEVVRG = Right(LDAEVVRG/1024,9)            /* convert to kbytes    */\nLDALOAL  = C2d(storage(D2x(LDA + 232),4))    /* <16m reg alloc       */\nLDALOAL  = Right(LDALOAL/1024,9)             /* convert to kbytes    */\nReturn  LDALOAL\n\nV054TestTrace: Procedure expose pgm\n say 'v054 passed trace test'\n v054.1='Kilroy'\n v054.2='was'\n v054.3='here'\n Call RunPgm 'Save  var(v054.)  pool(tracetest) trace(y)'\n Call RunPgm 'Drop pool(tracetest)'\n return 0\n\nDrWhoData:\n drop drwho.\n drwho.1  =  'Doctor Who is a British science-fiction television'\n drwho.2  =  'Programme produced by the BBC from 1963 to the present'\n drwho.3  =  'Day. The programme depicts the adventures of The'\n drwho.4  =  'Doctor, a Time Lord a time-travelling humanoid alien.'\n drwho.5  =  'He explores the universe in his TARDIS, a sentient'\n drwho.6  =  'Time-travelling space ship. Its exterior appears as a'\n drwho.7  =  'Blue British police box, which was a common sight in'\n drwho.8  =  'Britain in 1963 when the series first aired. Along'\n drwho.9  =  'With a succession of companions, the Doctor combats a'\n drwho.10 =  'Variety of foes while working to save civilisations'\n drwho.11 =  'And help people in need.'\n drwho.0  =  11\n drwhowhat=  'Doctor Who is a British sci-fi tv programme from 1963'\n drwhobox =  'TARDIS looks like a blue British police box'\n drwhowho =  'a Time Lord working to save civilisations'\n return 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXGVIVP2": {"ttr": 3850, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x19\\x01\\x19\\x16\\x8f\\x01\\x193/\\x003\\x00\\x11\\x00\\x01\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2019-06-17T00:00:00", "modifydate": "2019-11-28T00:33:19", "lines": 17, "newlines": 1, "modlines": 0, "user": "DVL"}, "text": "/*                                                                      rexx\n  REXXGBLV IVP - subroutine, test retreival of variables created\n                 in the main routine.\n*/\ntrace r\n say 'IVP2 - load variables in subroutine'\n cc=RexxGblv('load  var(va*)')\n cc=RexxGblv('rlist var(va*)')\n cc=RexxGblv('rstat var(va*) trace') /* count 000003 dtotz 00000016 */\n say 'Stats:' cc\n parse var cc . count . totsz\n if count<>3  then exit xmsg('Count not 3',8)\n if totsz<>16 then exit xmsg('Totsz not 16',8)\n say 'Load variables in subroutine successful'\n say ''\n exit 0\nXMsg: if arg(1)<>'' then say arg(1);return word(arg(2) 0,1)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXGVI064": {"ttr": 3852, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00H\\x01 \\x18\\x8f\\x01 \\x18\\x9f \\x11\\x009\\x001\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2020-07-06T00:00:00", "modifydate": "2020-07-07T20:11:48", "lines": 57, "newlines": 49, "modlines": 0, "user": "DVL"}, "text": "/*                                                                      rexx\n  REXXGBLV IVP - test build 064\n*/\ntrace off\n\n say 'RexxGblv version:' Rexxgblv('version')\n say ''\n\n say 'Test index'\n data.f='foxtrot'\n data.d='delta'\n data.x='xerox'\n data.k='kilo'\n data.e='echo'\n data.m='midway'\n Call RunPgm 'rlist var(data.)','data. before',0\n Call RunPgm 'rindex var(data.) stem(index.)','make index',0\n Call RunPgm 'rlist var(index.)'\n if index.0<>6 | index.6<>'DATA.F' then exit xmsg('Index not correct',8)\n drop data. index.\n\n say 'Test stemix'\n CAR.BMW   = 'german car make'\n CAR.FORD  = 'USA car make'\n CAR.MAZDA = 'japanese car make'\n CAR.PEUGEOT = 'french car make'\n Call RunPgm 'stemix stem(car.) ',0\n Call RunPgm 'rlist var(car.)'\n if car.0<>4               then exit xmsg('Stemix not correct',8)\n\n /* * for default pool */\n call Runpgm 'save var(car.) pool(*)'\n call Runpgm 'list           pool(*)'\n\n exit Xmsg('All ok...')\n\nRunPgm:\n if arg(2)<>'' then say '->' space(arg(2) '-' arg(1))\n else               say '->' space(arg(1))\n cc=RexxGblv(arg(1))\n say 'rc='cc+0,\n     'vsaven='REXXGBLV_VSAVEN+0,\n     'vloadn='REXXGBLV_VLOADN+0,\n     'vlistn='REXXGBLV_VLISTN+0,\n     'vdeln='REXXGBLV_VdelN+0,\n     'rlistn='REXXGBLV_RLISTN+0,\n     'rloadn='REXXGBLV_RLOADN+0,\n     'importn='REXXGBLV_importn+0,\n     'exportn='REXXGBLV_exportn+0,\n     'maxnl='REXXGBLV_MAXNL+0,\n     'maxdl='REXXGBLV_MAXDL+0,\n     'maxndl='REXXGBLV_MAXNDL+0,\n     'text='space(REXXGBLV_msg)\n say ''\n if cc<=word(arg(3) 0,1) then return 0\n exit xmsg('**Error',8)\nXMsg: if arg(1)<>'' then say arg(1);return word(arg(2) 0,1)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXGVMACS": {"ttr": 4097, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x019\\x00\\x14\\x01\\x17\\x05\\x0f\\x01 \\x00o\\x16\\x03\\x01\\x1b\\x00\\x01\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.57", "flags": 0, "createdate": "2017-02-19T00:00:00", "modifydate": "2020-01-06T16:03:14", "lines": 283, "newlines": 1, "modlines": 0, "user": "DVL"}, "text": "*-\n* Macros etc for REXX Global Variables program REXXGBLV\n* Updated for build 058\n*-\n\n*------------------Macro Log/TrcLog----------------------------------*\n\n         MACRO\n&lbl    zVCBTrace\n*VCBTrace\n&lbl     Call  Logger\n         clear VCBAtrrec\n         MEND\n\n         Macro\n&lbl     DoSay &t,&k\n         mvlit logr,&t\n         RxSay logr,l'logr,wrk=wrk256\n         clear logr\n         Mend\n\n*------------------Trace block start/end-----------------------------*\n\n         Macro\n.* TrcBlk / TrcBlkEnd is used around larger trace blocks. This\n.* cuts down on the number of instructions executed.\n         TrcBlk\n         gblc  &trcblka\n         aif   ('&trcblka' eq '').go\n         mnote 8,'***trcblka ne null'\n         mexit\n.go      anop\n&trcblka setc  'TB&sysndx.END'\n         cli   trace,c'Y'\n         jne   &trcblka\n         Mend\n\n         Macro\n         TrcBlkEnd\n         gblc  &trcblka\n&trcblka ds    0h\n&trcblka setc  ''\n         Mend\n\n         Macro\n&ml      TrcLog   &t,&k\n         lclc  &l\n&l       setc  'TL&sysndx'\n&ml      cli   trace,c'Y'\n         jne   &l.x\n         mvlit logr,&t\n         aif   (k'&k eq 0).k0\n         RxSay logr,&k\n         ago   .b\n.k0      RxSay logr\n.b       anop\n         clear logr\n&l.x     equ   *\n         Mend\n\n*------------------Log REXX data-------------------------------------*\n\n         Macro\n         LogRexxData &t\n         clear logr\n         STRMAKE logr,&t,lenck=Y,                                      c\n               =12,(rnvvarl,4,cvd,4),                                  c\n               ':',(vardatal,4,cvd,4),                                 c\n               +1,(rnvvar,f.rnvvarl,,35),                              c\n               '=',(vardata,f.vardataa,,,45)\n         trclog ,\n         Mend\n\n*------------------Pool access---------------------------------------*\n\n         Macro\n&mlbl    POOL  &what,&name\n&lbl     setc  'Z&sysndx'\n         aif   (k'&name eq 0).namen\n&mlbl    $la   r1,&name\n.namen   anop\n         Call  POOL&what\n         ltr   r15,r15\n         Mend\n\n*- LogWto\n         Macro\n&lbl     LogWto &t,&l\n&lbl     ds    0h\n         aif   (k'&t eq 0).tl\n         mvlit logr,&t,lr=r1\n         sth   r1,wtopfx\n         ago   .go\n.tl      aif   (k'&l eq 0).go\n         $la   r1,&l\n         sth   r1,wtopfx\n.go      lh    r1,wtopfx\n         la    r1,4(,r1)\n         sth   r1,wtopfx\n         la    r1,wtopfx\n         sr    r0,r0\n         svc   35\n         clear logr\n         Mend\n\n*- PGetNext\n         Macro\n&lbl     PGetNext &vcba=,&name=,&namel,&cursor=,&pl=\n         $la   r14,&vcba               -> VCB anchor\n         aif   (k'&name ne 0).setnam1\n         sr    r15,r15\n         sr    r0,r0\n         ago   .setnamn\n.setnam1 $la   r15,&name(1)\n         $la   r0,&name(2)\n.setnamn anop\n         la    r1,&cursor\n         stm   r14,r1,&pl\n         la    r1,&pl\n         call  PGetNext\n         ltr   r15,r15\n         Mend\n\n*- Vputc2d\n         Macro\n         vputc2d &name,&var\n         lclc  &s\n&s       setc  Upper('&name')\n         l     r1,&var\n         $cvd  r1,dw,len=8\n         RxVput name=('REXXGBLV_&s'),data=dw\n         Mend\n\n*- Vputp2d\n         Macro\n         vputp2d &name,&var\n         lclc  &s\n&s       setc  Upper('&name')\n         unpk  dw,&var\n         oi    dw+7,x'f0'\n         RxVput name=('REXXGBLV_&s'),data=(dw,8)\n         Mend\n\n*- RexxPut\n         Macro\n.* syntax NAME=(addr,len),DATA=(addr,len)  *recommended*\n.*     or (nameaddr,namelen),(dataaddr,datalen)\n&lbl     RexxPut &name=,&data=\n         aif   (n'&name gt 0).b\n         $la   r14,&syslist(1,1)       -> name\n         $la   r15,&syslist(1,2)       name length\n         $la   r0,&syslist(2,1)        -> data\n         $la   r1,&syslist(2,2)        data length\n         ago   .c\n.b       $la   r14,&name(1)            -> name\n         $la   r15,&name(2)            name length\n         $la   r0,&data(1)             -> data\n         $la   r1,&data(2)             data length\n.c       stm   r14,r1,parmlist\n         la    r1,parmlist\n         call  REXXVPUT\n         Mend\n\n*- EMsg\n         Macro\n         EMSG  &rc=,&force=Y\n*Emsg\n         lclc  &l\n&l       setc  'M&sysndx'\n         aif   ('&force' eq 'Y').forcen\n         cli   emsgl+3,0               text already set?\n         jne   &l.x                    then do not override\n.forcen  anop\n         mvlit emsg,&syslist(1),lenreg=r14\n         st    r14,emsgl\n         aif   (k'&rc eq 0).x\n         $la   r0,&rc\n         st    r0,rc\n.x       anop\n&l.x     equ   *\n*Emsg end\n         Mend\n\n*- set max rc\n         Macro\n         SetMaxRc &rc\n*SetMaxRc\n         lgfi  r0,&rc\n         c     r0,rc\n         jnh   *+8\n         st    r0,rc\n*SetMaxRc end\n.x       Mend\n\n*- Return from sub, set max rc and/or text\n         Macro\n&lbl     SubEnd &rc=0,&maxrc=,&text=,&ctext=\n         aif   (k'&lbl eq 0).lbln\n&lbl     ds    0h\n.lbln    anop\n         aif   (k'&maxrc eq 0).maxrcn\n         SetMaxRc &maxrc\n.maxrcn  anop\n         aif   (k'&text eq 0).textn\n         Emsg  &text\n.textn   anop\n         aif   (k'&ctext eq 0).ctextn\n         Emsg  &ctext,force=N\n.ctextn  anop\n         #subr end,rc=&rc\n.x       Mend\n\n*- Count\n         Macro\n         Count &q,&v,&reg=r15\n         lclc  &a,&b\n         l     &reg,&v\n&a       setc  Upper('&q')\n         aif   ('&a'(1,1) eq 'U').up\n         aif   ('&a'(1,1) eq 'D').down\n         mnote 8,'**Invalid action'\n         mexit\n.up      la    &reg,1(,&reg)\n         ago   .st\n.down    bctr  &reg,0\n         ago   .st\n.st      st    &reg,&v\n         Mend\n\n*- Required\n\n         Macro\n         Required\n         lcla  &pn,&pc\n         lclc  &name,&cmd,&l\n&l       setc  'rq&sysndx'\n&pn      seta  1\n.a       anop\n&name    setc  '&syslist(&pn)'\n         cli   &name._dl,0\n         jne   &l.x\n&pn      seta  &pn+1\n         aif   (&pn le n'&syslist).a\n         emsg 'required parameter missing'\n         #subr exit,rc=8\n&l.x     ds   0h\n         Mend\n\n*- SayOrList\n\n         Macro\n         SayOrList &a,&l,&counter=stemnum\n         ap    &counter,=p'1'\n         if    (cli,liststem_dl,eq,0)\n           RxSay &a,&l\n         else\n           RxStemPut stema=wrkname,base=(liststem,b.liststem_dl),      c\n               pnum=&counter,data=(&a,&l)\n         endif\n         Mend\n\n*- get new PACB, return address in r1\n         Macro\n&mlbl    PACBnew &name=,&vcbainit=Y\n&mlbl    STORAGE OBTAIN,LENGTH=PACBblkl,SP=131,CALLRKY=YES,LOC=31\n         stm   r14,r3,12(r13)        save\n         aif   ('&vcbainit' eq 'Y').vcbai\n         lr    r14,r1                -> area\n         lgfi  r15,PACBblkl\n         lr    r0,r14\n         sr    r1,r1\n         mvcl  r14,r0                clear\n         ago   .rld\n.vcbai   anop\n         lr    r3,r1\n         xc    PACBnext-PACB(l'PACBnext,r3),PACBnext-PACB(r3)\n         Using VCBanchr,r3\n         VCBAinit ,\n         drop  r3\n.rld     lm    r14,r3,12(r13)        reload\n         $la   r15,&name\n         mvc   PACBname-PACB(l'PACBname,r1),0(r15)\n         Mend\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXGVPDF": {"ttr": 4103, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x17\\x01  O\\x01  O\\tS\\x0e\\x99\\x0e\\x99\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-07-22T00:00:00", "modifydate": "2020-07-22T09:53:17", "lines": 3737, "newlines": 3737, "modlines": 0, "user": "DVL"}, "mimetype": "application/pdf", "datatype": "binary", "extension": ".pdf"}, "RXGVRDME": {"ttr": 5639, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00@\\x01\\x193\\x8f\\x01\\x193\\x8f\\x10!\\x00\\x0b\\x00\\x0b\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-12-04T00:00:00", "modifydate": "2019-12-04T10:21:40", "lines": 11, "newlines": 11, "modlines": 0, "user": "DVL"}, "text": "Description of members:\n\n REXXGBLV  Product, edit and run this member.\n RXGVDOC   Documentation.\n RXGVHIST  Product history.\n RXGVIVPx  IVPs\n RXGVMACS  Local macros.\n SYSMACS   ASM copy book containing combined non-IBM macros.\n REXXMACS  ASM copy book containing my macros for interfacing with REXX.\n WSAMMACS  ASM copy book containig my structured assembler macro set.\n           The macros are equivalent but not identical to IBM's macros.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXGVSAMP": {"ttr": 5641, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00E\\x01\\x182o\\x01\\x19(\\x0f\\x19@\\x00G\\x01\\x90\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2018-11-22T00:00:00", "modifydate": "2019-10-07T19:40:45", "lines": 71, "newlines": 400, "modlines": 0, "user": "DVL"}, "text": "REXXGBLV saamples\n\n\nPass data to a program not called directly from the current one, and\nalso want to get data back from that program. This is probably the\nmost common use, it is what REXXGBLV was originally written to do. It\naddress the lack of global variables in REXX.\n\nProgram TOP contains:\n\n Parm1 = 'Kilroy'\n Zz=RexxGblv('save var(parm1)')\n Call Middle\n Zz=RexxGblv('load var(resp1)')\n Say 'Response to Kilroy was' resp1\n\nProgram MIDDLE contains:\n Call Bottom\n Exit 0\n\nProgram BOTTOM contains:\n Zz=RexxGblv('load var(parm1)')\n If parm1 = 'Kilroy' then resp1 = 'was here'\n Zz=RexxGblv('save var(resp1)')\n Exit 0\n\n\nSame sample really, but with a specific pool so not to conflict with\nother programs. The pool is dropped when retrieved, so it doesn't\nconsume space.\n\nProgram TOP contains:\n\n Parm1 = 'Kilroy'\n Zz=RexxGblv('save var(parm1) pool(kilroy)')\n Call Middle\n Zz=RexxGblv('loaddrop var(resp1) pool(kilroy)')\n Say 'Response to Kilroy was' resp1\n\nProgram MIDDLE contains:\n Call Bottom\n Exit 0\n\nProgram BOTTOM contains:\n cc=RexxGblv('load var(parm1) pool(kilroy)')\n If parm1 = 'Kilroy' then resp1 = 'was here'\n cc=RexxGblv('save var(resp1) pool(kilroy)')\n Exit 0\n\n\nList REXX variables. This is very usefull for debugging, when you\ndon't really know what variables might have been set by a program.\n\n cc=RexxGblv('rlist var(resp*)')   /* everything resp* */\n cc=RexxGblv('rlist')              /* everything       */\n\n\nMake an index over a stem with non-numeric suffixes. If you don't\nknow in advance what will be generated, it is impossible for a program\nto know the variable names. With the STEMINDEX function, you will.\n\n Car.mazda='japanese car make'\n Car.ford ='USA car make'\n Car.bmw ='german car make'\n cc=RexxGblv('StemIndex stem(car.)')\nWill generate\n CAR.0 = 00000003\n CAR.1 = 'BMW'\n CAR.2 = 'FORD'\n CAR.3 = 'MAZDA'\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXGVVIEW": {"ttr": 5644, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00(\\x01\\x08#?\\x01\\x17\\x15\\x8f\\x17W\\x001\\x001\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2008-08-20T00:00:00", "modifydate": "2017-06-07T17:57:28", "lines": 49, "newlines": 49, "modlines": 0, "user": "DVL"}, "text": " /* ------------------------------------------------------------ REXX\n\n  name  : RXGVVIEW\n  desc  : Save variables and view file\n  author: WJensen\n\n  ------------------------------------------------------------------ */\n\n arg prm\n Address TSO \"delstack\"\n\n /*--------------------------------------------------------------------\n                 make vars, push to external store\n --------------------------------------------------------------------*/\n\n address TSO\n x=bpxwdyn('alloc new dd(rxgvexp)',\n           'lrecl(6000) recfm(v,b) blksize(0)',\n           'tracks space(2,2) unit(sysda)',\n           'rtddn(xdd) rtdsn(xds)')\n if x<>0 then call error \"bpxwdyn rxgvexp failed\" x\n\n n= REXXGBLV('export pool('prm')')\n \"execio * diskr rxgvexp (finis)\"\n\n qn=queued()\n do qn\n   parse pull sz1 +4 sz2 +4 rest\n   sz1=c2d(sz1)\n   sz2=c2d(sz2)\n   parse var rest kw +(sz1) data +(sz2) .\n   queue kw data\n end\n\n /*--------------------------------------------------------------------\n                                exit\n --------------------------------------------------------------------*/\n Call Quit\n\nQuit:  parse arg m;Call Epilog m; exit 0\nError: parse arg m;Call Epilog m; exit 8\nEpilog:\n parse arg m\n if m<>'' then say m\n Address TSO \"delstack\"\n z=outtrap('z.')\n Address TSO \"free  dd(rxgvexp)\"\n z=outtrap('off')\n Return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXOPCOMM": {"ttr": 5646, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x11\\x00G\\x01\\x19\\x14o\\x01\\x193\\x8f\\x17P\\x01\\xa3\\x01\\x99\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.17", "flags": 0, "createdate": "2019-05-26T00:00:00", "modifydate": "2019-12-04T17:50:47", "lines": 419, "newlines": 409, "modlines": 0, "user": "DVL"}, "text": "//RXOP006  JOB (1),'REXX-OPCOM-QEDIT',\n//*  RESTART=IVP1,\n//             CLASS=A,MSGCLASS=X,REGION=32M,COND=(0,LT)\n//*\n//* ?? RXOPCOMM - modify/stop operator command for REXX ? e ?\n//*\n//   EXEC ASMACL,\n//        PARM.C='TERM,RENT',\n//        PARM.L='LIST,AMODE(31),RMODE(ANY),RENT,REFR'\n//C.SYSLIB  DD DISP=SHR,DSN=SYS1.MACLIB\n//          DD DISP=SHR,DSN=SYS1.MODGEN\n//          DD DISP=SHR,DSN=CBT669.LIB\n//C.SYSTERM DD SYSOUT=*\n//C.SYSIN   DD *\n*Process compat(macrocase)\n**asma syslib *\n**asma opt    term\n*\n* RXOPCOMM - MODIFY/STOP operator command for REXX programs.\n*\n* Build: 006\n*\n* Changes in this build\n*  Some cleanup and beautification\n*\n* Syntax\n*  cc=RXOPCOMM('INIT')\n*    Setup control blocks\n*  cc=RXOPCOMM('TERM')\n*    Release control blocks\n*  cc=RXOPCOMM('GET'\u00dd,'wto-text'\u00a8)\n*    Check for response, return response text.\n*    Max response length is 255.\n*    Optionally issue a WTO before check.\n*  cc=RXOPCOMM('WTO','wto-text'\u00dd,H\u00a8)\n*    Issue a WTO. Option H retains the text on the console.\n*\n         lclc  &JPAQ\n&JPAQ    SETC  'Y'                     Retain module in the JPAQ\n*\n         print off\n         Copy  WSAMMacs\n         Copy  RexxMacs\n         Copy  SYSMACS\n*        COPY  Z10MACS\n         print on\n\n         Macro\n         SayIt &t\n         lcla  &tl\n         aif   (k'&t eq 0).go\n&tl      seta  (k'&t)-2\n         mvc   logr(&tl),=c&t\n.go      anop\n         RXSAY logr,l'logr,wrk=rxwork\n.x       clear logr\n         Mend\n\n         Macro\n         SubCall &name\n         l    r15,=v(&name)\n         balr  r14,r15\n         Mend\n\n* ------------------------------------------------------------------- *\n* Prolog                                                              *\n* ------------------------------------------------------------------- *\n         lclc  &$module,&version\n&version setc  '006'\n&$module setc  'RXOPCOMM'\n         #subr set,entry=csect,base=r11,saend=saend\n*\n&$module #module amode=31,rmode=31,base=r12,                           c\n               work=(lclstorl,lclstor,r10,C),sa=sa1,epilog=MainEpi,    c\n               text=' V&version'\n\n*- init storage\n         clear blank\n         mvc   action,blank\n         mvc   reason,blank\n         mvc   zero8,=8c'0'\n         mvc   logr,blank\n         mvc   retval,blank\n         mvlit retval,'00000000'\n         mvc   retvall,=a(8)\n         mvc   NtName,=cl8'&$module'\n         mvc   NtName2,blank\n         la    r1,l'logr\n         sll   r1,16\n         st    r1,logrwto\n\n         aif   ('&JPAQ' ne 'Y').jpaqn\n*-\n* Keep module in JPAQ for duration of job / TSO session  (change 005)\n* Ignored if module is loaded from the LPA.\n*-\n*        CDEUCTZ2 dsect=N\n\n.jpaqn   anop\n*-\n* Initialize REXX interfaces\n*-\n         ereg  0,1\n         RxInit ,\n*        sayit 'init done'\n\n*-\n* check parms\n*-\n         l     r4,zrx_r1               old r1\n         using efpl,r4                 point to parmlist\n         mvc   parmarga,efplarg        save\n         drop  r4\n         if    (cli,parmarga,eq,x'FF')\n           mvc  rc,=al2(10)\n           #module exit\n         endif\n\n* get and check parm 1 - action\n* sayit 'p1'\n         l     r5,parmarga\n         lm    r14,r15,0(r5)           address and length\n         if    (ltr,r15,r15,z),or,(clfi,r15,gt,l'action)\n           mvc  rc,=al2(8)\n           $cvd  r15,reason+14,len=4\n           mvlit reason,'parm 1 length'\n           #module exit\n         endif\n         lr    r3,r15\n         bctr  r15,0\n         mvc   action(*-*),0(r14)\n         ex    r15,*-6\n         oc    action,blank\n\n         la    r2,actlist\n         do    until,(cli,0(r2),eq,255)\n           if    (clc,action,eq,0(r2))\n             leave\n           endif\n           la    r2,actlistl(,r2)\n         enddo\n\n         if    (cli,0(r2),eq,255)\n           mvlit reason,'invalid action'\n           mvc  rc,=al2(11)\n           #module exit\n         endif\n\n* perform action\n*sayit 'call'\n         l     r15,actlistnl(,r2)\n         balr  r14,r15\n         #module exit\n\n* -------------end of module processing--------------------------------\nMainEpi  #subr label\n         RxVPut name='&$module._REASON',data=(reason,l'reason)\n\n         if    (rc,ne,zero)\n           lh   r1,rc\n           $cvd  r1,retval,len=8\n         endif\n\n         RxRetval retval,f.retvall\n         #subr end\n\n* -------------fixed data----------------------------------------------\n\nzero     dc    a(0)\nactlist  dc    cl8'INIT',v(init)\nactlistnl equ   8\nactlistl  equ   12\n         dc    cl8'GET',v(get)\n         dc    cl8'TERM',v(term)\n         dc    cl8'WTO',v(WTO)\n         dc    cl8'VERSION',v(version)\n         dc    al1(255)\n\n         ltorg\n\n* -------------Version           --------------------------------------\n\nVersion  #subr\n*        sayit 'Version'\n         mvc   retval(l'vertext),vertext\n         mvc   retvall,=a(l'vertext)\n         #subr exit\n\nVerText  dc    c'&$module &version &sysdate &systime'\n         #subr drop\n\n* -------------Initialize ---------------------------------------------\n\nINIT     #subr\n* sayit 'init'\n\n* is there an N/T block already?\n         NTSERVX rt,n=NtName,t=NtToken,l=home,rc=NtRc,pl=NtParms\n         if   (clc,ntrc,ne,zero)      nope\n*   get storage\n           la    r9,qedblkl\n           STORAGE OBTAIN,LENGTH=(9),SP=131,CALLRKY=YES\n           st    r1,NtTokAdr            address\n           st    r9,NtTokSiz            size\n           lr    r8,r1\n*   make NT\n           NTSERVX  cr,n=NtName,t=NtToken,l=home,rc=NtRc,pl=NtParms\n           if    (clc,ntrc,ne,zero)\n             l     r15,ntrc\n             $cvd  r15,reason+17,len=8\n             mvlit reason,'NT create failed'\n             mvc   rc,=al2(8)\n             #subr exit,rc=8\n           endif\n         endif\n\n* setup QEDIT request\n         Using  qedblk,r8\n         OPCOMM INIT\n         drop  r8\n\n         #subr exit\n         #subr drop\n\n* -------------Terminate ----------------------------------------------\n\nTERM     #subr\n*        sayit 'drop'\n         NTSERVX rt,n=NtName,t=NtToken,l=home,rc=NtRc,pl=NtParms\n         if    (clc,ntrc,ne,zero)\n           l     r15,ntrc\n           $cvd  r15,reason+25,len=8\n           mvlit reason,'TERM - locate NT failed'\n           mvc   rc,=al2(8)\n*          sayit 'not found'\n           #Subr exit,rc=8\n         endif\n*-storage\n         l     r3,NtTokAdr\n         l     r4,NtTokSiz\n         STORAGE RELEASE,LENGTH=(4),ADDR=(3),SP=131,CALLRKY=YES\n*-N/T\n         NTSERVX dl,n=NtName,rc=NtRc,pl=NtParms\n         if    (clc,ntrc,ne,zero)\n           l     r15,ntrc\n           $cvd  r15,reason+25,len=8\n           mvlit reason,'TERM - delete NT failed'\n           mvc   rc,=al2(8)\n           #subr exit,rc=8\n         endif\n*        cvxd  in=ntrc,out=logr+20,len=4\n*        sayit 'drop ntrc'\n\n         #subr exit\n         #subr drop\n\n* -------------Get response -------------------------------------------\n\nGet      #subr\n* sayit 'get'\n         NTSERVX rt,n=NtName,t=NtToken,l=home,rc=NtRc,pl=NtParms\n         if    (clc,ntrc,ne,zero)\n           l     r15,ntrc\n           $cvd  r15,reason+24,len=8\n           mvlit reason,'GET - locate NT failed'\n           mvc   rc,=al2(8)\n           #subr exit,rc=8\n         endif\n\n* WTO text?\n         l     r5,parmarga\n         if    (cli,8(r5),ne,x'ff'),then=(subcall,WTO)\n\n         l     r9,NtTokAdr\n         using qedblk,r9\n         clear qedresp\n         xc    qedrespl,qedrespl\n         OPCOMM GET,MAREA=qedresp\n\n         la    r4,qedrespd\n         lh    r5,qedrespl\n*        if    (cli,qedresp,ne,c' ')\n*          cvxd  in=qedrespl,out=qedresp+10,len=8\n*          la    r5,40\n*        endif\n         st    r5,retvall\n         if    (ltr,r5,r5,nz)\n           bctr  r5,0\n           mvc   retval(*-*),0(r4)\n           ex    r5,*-6\n         endif\n*\n         #subr exit\n         #subr drop\n\n* -------------WTO          -------------------------------------------\n\nWTO      #subr\n*        sayit 'WTO entered'\n\n* get parm 2 - text\n         l     r8,parmarga\n         if    (cli,8(r8),eq,x'ff')\n           mvlit reason,'WTO - no data'\n           mvi   retval+7,c'8'\n           #subr exit,rc=8\n         endif\n         lm    r4,r5,8(r8)             p2 address and length\n         if    (ltr,r5,r5,z),or,(clfi,r5,gt,126)\n           StrMake reason,'WTO - text length ',(r5,,cvdr,4)\n           mvi   retval+7,c'8'\n           #subr exit,rc=8\n         endif\n*- get text\n         lr    r15,r5\n         bctr  r15,0\n         mvc   wrk256+4(*-*),0(r4)\n         ex    r15,*-6\n*- build suffix\n         la    r15,wrk256\n         la    r15,4(r5,r15)\n         mvc   0(4,r15),=x'00204000' for desc=11\n*- build prefix\n         la    r5,4(,r5)             plus prefix\n         sll   r5,16\n         st    r5,wrk256\n*- set wto type\n         la    r1,=c'N'\n         if    (cli,16(r8),ne,x'ff')\n           l     r1,20(,r8)            -> opt\n         endif\n         if    (cli,0(r1),eq,c'H')   hold it\n           oi    wrk256+2,x'80'      flags at front\n         endif\n*- issue wto\n         la    r1,wrk256\n         sr    r0,r0\n         svc   35\n*\n         #subr exit\n         #subr drop\n\n* -------------dynamic area--------------------------------------------\n\nLclStor  Dsect\nsa1      ds    18f                     save area\nsa2      ds    18f                     save area\nsa3      ds    18f                     save area\nsa4      ds    18f                     save area\nsaend    equ   *\n*-\nblank    ds    cl120\nreason   ds    cl100\nretval   ds    cl120\nretvall  ds    a\nparmarga ds    a\naction   ds    cl8\nsuba     ds    a\nNtParms  ds    0a(0),xl(20+32)\nntLevel  ds    a\nNtId     ds    0cl16\nNtName   ds    cl8\nNtName2  ds    cl8\n         ds    0d\nNtToken  ds    xl16\n         org   NtToken\nNtTokAdr ds    a\nNtTokSiz ds    a\nNtTokRln ds    a\n         org\nNtRc     ds    a\np2def    ds    2a\nLendef   ds    2a\nDatadef  ds    2a\n\nrc       ds    h\nzero8    ds    cl8\n         ds    0a\nfw       ds    f\ndw       ds    d\nlogrwto  ds    a\nlogr     ds    cl120\nvarname  ds    cl(l'blank)\n         RexxMacs ds\nwrk256   ds    cl256\n*-\nLclStorL equ   *-LclStor\n\n         IeaNtAsm\n\n         RexxMacs dsect\n*-QEDIT block\nQEDBLK   dsect\nqedresp  ds    0cl100\nqedrespl ds    xl2\nqedrespd ds    cl98\n*-\n         OPCOMM ds\n         ds    0d\nqedblkl  equ   *-qedblk\n*-\n         OPCOMM dsect\n         Print nogen\n         IHACDE                       used by CDEUCTZ2\n         IHAPSA DSECT=YES             used by CDEUCTZ2\n         IkjTcb                       used by CDEUCTZ2\n*-\n         END\n//*\n//L.SYSLMOD DD DSN=CBT669.LPALIB(RXOPCOMM),DISP=SHR\n//*\n//* Activate dynamic if in lpalib:\n//*   SETPROG LPA,ADD,MODNAME=RXOPCOMM,DSNAME=CBT669.LPALIB\n//*\n//IVP1     EXEC PGM=IKJEFT1B,PARM='RXOPIVP1'\n//SYSEXEC  DD DISP=SHR,DSN=CBT669.LIB\n//STEPLIB  DD DISP=SHR,DSN=CBT669.LPALIB\n//SYSTSPRT DD SYSOUT=*,OUTLIM=2000\n//SYSTSIN  DD DUMMY\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXOPDOC": {"ttr": 5894, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x006\\x01\\x17\\x05\\x1f\\x01\\x19)_\\x16\\x02\\x009\\x00\\x04\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "2017-02-20T00:00:00", "modifydate": "2019-10-22T16:02:36", "lines": 57, "newlines": 4, "modlines": 0, "user": "DVL"}, "text": ")F REXX function - MODIFY/STOP operator command for REXX programs.\n\nCurrent build: 006\n\nSyntax\n\n RXOPCOMM must ce used as a function.\n\n r=RXOPCOMM('INIT')\n   Setup control blocks\n r=RXOPCOMM('TERM')\n   Release control blocks\n r=RXOPCOMM('GET'\u00dd,'wto-text'\u00a8)\n   Check for response, return response text.\n   Max response length is 255.\n   Optionally issue a WTO before check.\n r=RXOPCOMM('WTO','wto-text'\u00dd,H\u00a8)\n   Issue a WTO. Option H retains the text on the console.\n\nSample\n\n cc=RXOPCOMM('INIT')\n if cc<>0 then exit 20\n cc=RXOPCOMM('WTO','OPCOMM initialization complete')\n wtotext='Enter command'\n Do $main=1 to 999 until rs='STOP'\n   rs=RXOPCOMM('GET',wtotext)\n   Select\n     when datatype(cc)='NUM' & cc<>0 then do\n       say 'RXOPCOMM error rc' rs RXOPCOMM_REASON\n       exit 8\n     end\n     when rs='' then do\n       wtotext=''\n       call syscalls 'ON'         /* wait  */\n       address syscall 'sleep' 2  /* 2     */\n       call syscalls 'OFF'        /* secs  */\n     end\n     when rs='something-else' then do\n     end\n     Otherwise cc=RXOPCOMM('WTO','OPCOMM invalid command:' rs)\n   end\n end\n cc=RXOPCOMM('TERM')\n cc=RXOPCOMM('WTO','OPCOMM ended')\n\nMembers\n RXOPDOC  - this member\n RXOPCOMM - install program\n RXOPIVP* - installation verification / sample program\n RXOPMACS - assembler macros used in the program\n\nInstallation notes\n RXOPCOMM is fully reentrant so can and should be in the LPA.\n If not, it will reload itself once to remain in the LPA - you\n can disable this behaviour by changing the JPAQ option at the\n top of the source.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXOPHIST": {"ttr": 5896, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x04\\x01\\x19\\x19\\x9f\\x01\\x19)_\\x16\\x03\\x00\\x08\\x00\\x07\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2019-07-18T00:00:00", "modifydate": "2019-10-22T16:03:04", "lines": 8, "newlines": 7, "modlines": 0, "user": "DVL"}, "text": "History\n001  2017-01-12  Initial version\n002  2017-03-13  Add WTO\n003  2018-08-18  Make reentrant\n                 Fix return of the VERSION info\n004  2018-12-05  Internal changes, use macros #MODULE and #SUBR\n005  2019-05-26  Can keep module in JPAQ for entire job session.\n006  2019-10-22  Some cleanup and beautification\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXOPIVP$": {"ttr": 5898, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x006\\x01\\x17\\x05\\x1f\\x01\\x18)?\\x158\\x00\\x07\\x00\\x07\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2017-02-20T00:00:00", "modifydate": "2018-10-20T15:38:36", "lines": 7, "newlines": 7, "modlines": 0, "user": "DVL"}, "text": "//RXOPIVP$ JOB (1),'RXOPIVP$',CLASS=A\n//*\n//IVP1     EXEC PGM=IKJEFT1B,PARM='RXOPIVP1'\n//STEPLIB  DD DISP=SHR,DSN=CBT669.LPALIB\n//SYSEXEC  DD DISP=SHR,DSN=CBT669.LIB\n//SYSTSPRT DD SYSOUT=*,OUTLIM=200\n//SYSTSIN  DD DUMMY\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RXOPIVP1": {"ttr": 5900, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01#\\x00!\\x01\\x17\\x05\\x1f\\x01\\x18%\\x7f\\x11\\x08\\x00(\\x00\\x0f\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.35", "flags": 0, "createdate": "2017-02-20T00:00:00", "modifydate": "2018-09-14T11:08:21", "lines": 40, "newlines": 15, "modlines": 0, "user": "DVL"}, "text": "/*                                                                 rexx\n   RXOPCOMM IVP\n*/\n v=RXOPCOMM('version')\n if word(v,1)<>'RXOPCOMM' then,\n   exit xmsg('Version does not begin with program name:' v,8)\n call xmsg('Version:' v)\n\n cc=DoIt('init')\n cc=DoIt('wto','Inititialization done for' word(v,1) 'version' subword(v,2))\n\n wto='Waiting for response or STOP'\n do n=1 to 9999\n   cc=DoIt('get',wto)\n   wto=''\n   if cc<>'' then do\n     if cc='STOP' then leave\n     cc=DoIt('wto',cc)\n     wto='Waiting for response or STOP'\n   end\n   call syscalls 'ON'\n   call time 'E'\n   address syscall 'sleep' 2  /* secs  */\n   call syscalls 'OFF'\n end\n cc=DoIt('term')\n cc=DoIt('wto','Termination done')\n\n exit 0\n\nDoIt:\ntrace off\n if translate(arg(1)''arg(2))<>'GET' then,\n   say time() arg(1)','arg(2)','arg(3)\n cc=RXOPCOMM(arg(1),arg(2),arg(3))\n if datatype(cc)='NUM' & cc<>0 then,\n   exit xmsg(RXOPCOMM_REASON,8)\n if cc<>'' then say time() 'response:' cc\n return cc\nXMsg: if arg(1)<>'' then say time() arg(1);return word(arg(2) 0,1)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXOPRDME": {"ttr": 5902, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00@\\x01\\x193\\x8f\\x01\\x193\\x8f\\x10C\\x00\\x0b\\x00\\x0b\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-12-04T00:00:00", "modifydate": "2019-12-04T10:43:40", "lines": 11, "newlines": 11, "modlines": 0, "user": "DVL"}, "text": "Description of members:\n\n RXOPCOMM  Product, edit and run this member.\n RXOPDOC   Documentation.\n RXOPHIST  Product history.\n RXOPIVPx  IVPs\n RXOPMACS  Local macros.\n SYSMACS   ASM copy book containing combined non-IBM macros.\n REXXMACS  ASM copy book containing my macros for interfacing with REXX.\n WSAMMACS  ASM copy book containig my structured assembler macro set.\n           The macros are equivalent but not identical to IBM's macros.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXPATTRN": {"ttr": 5904, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01-\\x00)\\x01\\x184\\x1f\\x01  O\\x14S\\x01\\x1f\\x00\\xdc\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.45", "flags": 0, "createdate": "2018-12-07T00:00:00", "modifydate": "2020-07-22T14:53:29", "lines": 287, "newlines": 220, "modlines": 0, "user": "DVL"}, "text": "//RXPN003  JOB (1),'RXPATTRN-V003',\n//*  RESTART=IVP1,\n//         CLASS=A,COND=(0,LT)\n//*\n//* REXX function, Test a string against a pattern\n//  SET IVP=1\n//*\n//A  EXEC ASMACL,PARM.C='TERM,RENT',\n//          PARM.L='RENT,REUS,LIST,MAP,XREF,RMODE(ANY),AMODE(31)'\n//C.SYSLIB  DD DISP=SHR,DSN=CBT669.LIB\n//          DD DISP=SHR,DSN=SYS1.MACLIB\n//          DD DISP=SHR,DSN=SYS1.MODGEN\n//C.SYSTERM DD SYSOUT=*\n//C.SYSIN   DD *\n**asma syslib *\n**asma opt term\n*Process compat(macrocase)\n*\n* Test a string against a pattern\n*\n* Build: 003, 2020-07-21\n*\n*  Fixes in this build\n*  - Possible false negative when mask and string has same length.\n*    This is really a fix to the STRPATRN macro.\n*\n*  Changes in this build\n*  - 4th parameter change to T for trace, better info for tracing.\n*\n* Syntax\n*\n*  rc = RxPattrn(string,pattern,wildcard,options)\n*\n* Parameters\n*  string    just a string\n*  pattern   the pattern to test against, or preprocess\n*  wildcard  2 chars for one-char and zero-or-none test.\n*            Optional, default is '%*'.\n*  options   T for tracing\n*\n*  Return\n*    0   ok\n*    1   pattern not match\n*    2   missing string\n*    3   missing pattern\n*    4   invalid wildcard length\n*\n* Installation notes\n*\n*  The  program will  by default  reload itself  thus retaining  the\n* module in the  JPAQ. This improves performance  for multiple calls\n* significantly. This load will not be  done if the program is added\n* to the LPA, which is the recommended placement.\n*  You can disable  the self-load option by  removing the 'CDEUCTZ2'\n* statement.\n*\n\n         lclc  &name,&build\n&name    setc  'RXPATTRN'\n&build   setc  '003.1'\n*-\n         print off\n         Copy  SYSMACS\n         Copy  WSAMMACS\n         Copy  REXXMACS\n         print on\n*- Reason\n         Macro\n         Reason &t,&c,&p3\n         lcla  &l\n&l       seta  k'&t-2\n         mvc   reason(&l),=c&t\n         mvc   reasonl,=a(&l)\n         aif   (k'&c eq 0).x\n         mvc   rc,=a(&c)\n         aif   ('&p3' ne 'T' and '&p3' ne 't').x\n         mvc   logr,reason\n         trclog ,\n.x       Mend\n\n*- Trclog\n         Macro\n&ml      TrcLog &t,&k\n         lclc  &l\n&l       setc  'TL&sysndx'\n&ml      ds    0h\n         cli   trace,c'Y'\n         jne   &l.x\n         mvlit logr,&t\n         aif   (k'&k eq 0).k0\n         RxSay logr,&k\n         ago   .b\n.k0      RxSay logr\n.b       anop\n         clear logr\n&l.x     equ   *\n         Mend\n*-\n* Start module\n*-\n&name    #module base=r11,sa=sa1,work=(lclstorl,lclstor,r10,C),        c\n               text='&build',epilog=epilog\n         clear blank\n         mvc   logr,blank\n         mvc   reason,blank\n         xc    rc,rc\n\n*-\n* Make sure module stays in memory\n*-\n         CDEUCTZ2 wto=N\n\n*-\n* init REXX interface\n*-\n         ereg  0,1\n         RxInit parmlist=((string,A),(mask,A),       pointers          c\n               (wildcd,2),(opt,1))                   data\n         oc    opt,blank\n         if    (cli,opt,eq,c'T'),then=(mvi,trace,c'Y')\n         if    (cli,wildcd_ds,eq,0)\n           mvc   wildcd(2),=c'*%'\n           mvi   wildcd_ds,2\n         endif\n\n*-\n* return version\n*-\n         if    (=a(7),eq,string+4),and,(zero,eq,mask+4) lengths\n           l     r1,string\n           mvc   dw(7),0(r1)                 copy text\n           oc    dw,blank\n           if    (=c'VERSION',eq,dw)\n             la    r1,=cl6'&build'\n             la    r2,6\n             stm   r1,r2,retval\n             #module end\n           endif\n         endif\n\n*-\n* list parameters if tracing\n*-\n         if    (cli,trace,eq,c'Y')\n           print nogen\n           trclog 'version &build'\n           StrMake logr,'text    ',                                    c\n               (string+0,4,cvxd),+1,         address                   c\n               (string+4,4,cvxd),+1,         length                    c\n               (string+6,2,cvd,3),+1,(f.string,f.string+4,,60)\n           trclog\n           StrMake logr,'mask    ',                                    c\n               (mask+0,4,cvxd),+1,           address                   c\n               (mask+4,4,cvxd),+1,           length                    c\n               (mask+6,2,cvd,3),+1,(f.mask,f.mask+4)\n           trclog\n           StrMake logr,'wildcds ',                                    c\n               (wildcd_ds,1,cvd,3),' \"',wildcd,'\"'\n           trclog\n           print gen\n         endif\n\n*-\n* check parameters\n*-\n         if    (cli,string_ds,eq,0)\n           Reason 'Missing string',2,t\n           #module end\n         endif\n         if    (cli,mask_ds,eq,0)\n           Reason 'Missing mask',3,t\n           #module end\n         endif\n         if    (cli,wildcd_ds,ne,2)\n           Reason 'Invalid wildcard',4,t\n           #module end\n         endif\n\n*-\n* Do pattern check\n*-\n         StrPatrn str=(f.string,f.string+4),                           c\n               mask=(f.mask,f.mask+4),                                 c\n               wc=wildcd\n         st    r15,rc\n\n         if    (cli,trace,eq,c'Y')\n           lr    r2,r0            string addr\n           la    r2,1(,r2)\n           s     r2,string        pos -> offset\n           lr    r3,r1            mask addr\n           la    r3,1(,r3)\n           s     r3,mask          pos -> offset\n           strmake logr,'Result  x',(rc,4,cvxd),+1,(rc+2,2,cvd),       c\n               ' strpos ',(r2,,cvdr,4),                                c\n               ' maskpos ',(r3,,cvdr,4)\n           TrcLog   ,\n         endif\n\n         if    (rc,ne,zero)\n           strmake reason,'x',(rc,4,cvxd),lr=r2\n           st    r2,reasonl\n           mvc   rc,=a(1)\n         endif\n         #module end\n\n*-\n* Backend\n*-\n\nEpilog   #subr label\n\n         if    (icm,r5,15,reasonl,nz)\n           la    r4,reason\n         else\n           la    r4,=c' '\n           la    r5,1\n         endif\n         RxVput name='RXPATTRN_RS',data=((r4),(r5))\n\n         if     (icm,r4,15,retval,nz)        -> text\n           l     r5,retval+4                 text length\n         else\n           l     r15,rc\n           StrR2D reg=r15,to=(dw,8)\n           la    r4,dw                       -> text\n           la    r5,8                        text length\n         endif\n         if    (cli,trace,eq,c'Y')\n           strmake logr,'rc ',((r4),(r5)),lenreg=r3\n           trclog\n         endif\n         RxRetval (r4),(r5)\n\n         #subr exit,rc=0\n\n*-\n* Inline data\n*-\n\nzero     dc    a(0)\n         ltorg\n\n*-\n* Dynamic area\n*-\n\nLclStor  Dsect\nsa1      ds    (2*18)f                 save areas\n*-\nblank    ds    cl150\nreasonl  ds    a\nreason   ds    cl100\nfw       ds    f\ndw       ds    d\nrc       ds    a\nretval   ds    2a(0)\n*-\n         RexxMacs ds\n*-\n         ds    0d\ntrace    ds    c\nlogrl    ds    a\nlogr     ds    cl130\n         ds    0d\nwrk256   ds    xl256\n*-\nLclStorL equ   *-LclStor\n\n         Dsect\n         RexxMacs dsect\n\n         End\n//*\n//L.SYSLMOD DD DISP=SHR,DSN=CBT669.LPALIB(RXPATTRN)\n//*\n//* Production version is in LPALIB\n//*\n//* activate dynamic:\n//*   SETPROG LPA,ADD,MODNAME=RXPATTRN,DSNAME=CBT669.LPALIB\n//*\n//IVP1     EXEC PGM=IKJEFT1B,PARM='%RXPNIVP&IVP'\n//STEPLIB  DD DISP=SHR,DSN=CBT669.LPALIB\n//SYSEXEC  DD DISP=SHR,DSN=CBT669.LIB\n//SYSTSPRT DD SYSOUT=*,OUTLIM=(5000)\n//SYSTSIN  DD DUMMY\n//*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXPNDOC": {"ttr": 6149, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01H\\x00F\\x01\\x04\\x07O\\x01  ?\\x18Q\\x00D\\x00\\xd5\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.72", "flags": 0, "createdate": "2004-03-14T00:00:00", "modifydate": "2020-07-21T18:51:46", "lines": 68, "newlines": 213, "modlines": 0, "user": "DVL"}, "text": ")F REXX function - Test a string against a pattern\n\nBuild: 003\n\n Fixes in this build\n - Possible false negative when mask and string has same langth.\n\n Changes in this build\n - 4th parameter change to T for trace, better info for tracing.\n\n\nSyntax\n\n rc = RxPattrn(string,pattern,wildcard)\n\n Parameters\n  string    just a string\n  pattern   the pattern to test against, or preprocess\n  wildcard  2 chars for zero-or-none and one-char test.\n            Optional, default is '*%'.\n\n Return\n   0   ok\n   1   pattern not match\n   2   missing string\n   3   missing pattern\n   4   invalid wildcard length\n\n   if rc gt 1 then variable RXPATTRN_RS contains a reason text.\n\n\nSome samples\n\n Text                           Pattern  Wildcd  rc reaseon\n IEFBR14                        %%%BR*           00\n IEFBR14                        ???BR#   #?      00\n IEFBR14                        IEFB*            00\n IEFBR14                        IEFBR14*         00\n Kilroy was here some time ago  %%%BR*           01\n Kilroy was here some time ago  *her*            00\n string names Gandalf and Frodo *not*            01\n string names Gandalf and Frodo *nam*            00\n                                *nam*            02 Missing string\n string names Gandalf and Frodo                  03 Missing pattern\n\n\nInstallation notes\n\n  The program will  by default reload itself thus  retaining the module\n in   the  JPAQ.   This   improves  performance   for  multiple   calls\n significantly. This load  will not be done if the  program is added to\n the LPA, which is the recommended placement.\n  You  can disable  the  self-load option  by  removing the  'CDEUCTZ2'\n statement.\n\n Small test of RXPATTRN in a REXX pgm, scan 36 records 100 times.\n\n                        EXCP   CONN    TCB\n  CDEUCTZ2 disabled     7284      0   1.35\n  CDEUCTZ2 enabled        90      0    .09\n  Running from LPA        51      0    .14\n\n Admittedly  I haven't  tried to  mimic  the pattern  check using  REXX\n statements. It  probably would not  increase the EXCP values,  but the\n cpu- and elaps times might very well go throuh the roof.\n\n\nSee SYS1.MODGEN(ASAXWC) for details about the ASAXWC syntax\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXPNHIST": {"ttr": 6151, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x018\\x007\\x01\\x032o\\x01  ?\\x19Y\\x00\\t\\x00\\x07\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.56", "flags": 0, "createdate": "2003-11-22T00:00:00", "modifydate": "2020-07-21T19:59:37", "lines": 9, "newlines": 7, "modlines": 0, "user": "DVL"}, "text": "Vers  Desc\n001   Initial\n002   Change ASAXWC call to own StrPatrn\n003   2020-07-21\n      Fixes in this build\n      - Possible false negative when mask and string has same length.\n        This is really a fix to the STRPATRN macro.\n      Changes in this build\n      - 4th parameter change to T for trace, better info for tracing.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXPNIVP$": {"ttr": 6153, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x009\\x01\\x184\\x1f\\x01  O\\x14S\\x00\\n\\x00\\x07\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "2018-12-07T00:00:00", "modifydate": "2020-07-22T14:53:39", "lines": 10, "newlines": 7, "modlines": 0, "user": "DVL"}, "text": "//RXPNIVP$ JOB (1),'RXPNIVP$',CLASS=A,COND=(5,LT)\n//*\n//* RXPATTRN - REXX string pattern check\n//*\n//IVP1     EXEC PGM=IKJEFT1B,PARM='RXPNIVP1'\n//STEPLIB  DD DISP=SHR,DSN=CBT669.LPALIB\n//SYSEXEC  DD DISP=SHR,DSN=CBT669.PP.RXPATTRN.V002.LIB\n//SYSTSPRT DD SYSOUT=*,OUTLIM=(5000)\n//SYSTSIN  DD DUMMY\n//*\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXPNIVP1": {"ttr": 6155, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1e\\x00@\\x01\\x184\\x1f\\x01  ?\\x19R\\x009\\x00\\x1f\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.30", "flags": 0, "createdate": "2018-12-07T00:00:00", "modifydate": "2020-07-21T19:52:40", "lines": 57, "newlines": 31, "modlines": 0, "user": "DVL"}, "text": "/*                                                         rexx\n    REXX Pattern Check IVP\n    positional parms: string,pattern,wildcard,expect-rc\n*/\n\ntrace off\n say 'Test REXX Pattern Check utility RXPATTRN (IVP1)'\n testrc=0\n say ''\n say 'Version:' RXPATTRN('version')\n say ''\n\n text1 = 'Kilroy was here some time ago'\n text2 = 'this is a string with some names - Gandalf and Frodo'\n\n /* parms: text, mask, wildcards, expect-rc, Trace */\n cc = Test('IEFBR14','%%%BR*',,0 )\n cc = Test('IEFBR14','???BR#','#?',0 )\n cc = Test('IEFBR14','IEFB*',,0  )\n cc = Test('IEFBR14','IEFBR14*',,0 )\n cc = Test('TESTAAA','TEST%%%',,0,'T')\n cc = Test('Kilroy was here','*',,0)\n cc = Test(text1,'%%%BR*',,1   )\n cc = Test(text1,'*her*',,0    )\n cc = Test(text2,'*not*',,1    )\n cc = Test(text2,'*nam*',,0    )\n cc = Test(,'*nam*',,2         )\n cc = Test(text2,,,3           )\n\n cc = Test('Aexor Blixzgsnn Lexxiko22ersxc. AG 1234 Yolixaon',,\n           'A*x%r Bl%xz*nn%Le%%ik%%%ersxc*AG*Y%%%%%on',,0)\n\n cc = Test('Aexor Blixzgsnn Lexxiko22ersxc. AG 1234 Yolixaon',,\n           'A*x%r Bl%xz*nn%Le%%ik%%%ersxc*AX*Y%%%%%on',,1)\n\n say ''\n exit xmsg('Test completed rc' testrc,testrc)\n\nTest:\ntrace off\n parse arg tdata,tmask,twc,txrc,topt /* topt: T=trace */\n txrc=word(txrc 0,1)\n say ''\n say 'string  ' right(length(tdata),3,0) tdata\n say 'pattern ' right(length(tmask),3,0) tmask\n say 'wildcard' right(length(twc),3,0) twc\n say 'expectrc' txrc\n if topt<>'' then say 'option  ' topt\n cc=RXPATTRN(tdata,tmask,twc,topt)\n /*=RXPATTRN(arg(1),arg(2),arg(3),arg(5))  */\n say 'rc      ' cc 'reason' strip(RXPATTRN_RS)\n if cc>txrc then do\n   testrc=8\n   return xmsg('Bad rc ******',8)\n end\n return xc\nXMsg: if arg(1)<>'' then say arg(1);return word(arg(2) 0,1)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXPNIVP2": {"ttr": 6157, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00S\\x01\\x184\\x1f\\x01\\x184\\x1f\\x17\\x14\\x00\\x0e\\x00\\r\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2018-12-07T00:00:00", "modifydate": "2018-12-07T17:14:53", "lines": 14, "newlines": 13, "modlines": 0, "user": "DVL"}, "text": " /* test RXPATTRN performance                                     rexx */\n parse arg loops test .\n say 'testing' loops 'times for' test\n \"execio * diskr testdata (stem d. finis)\"\n say d.0 'test data records loaded'\n m=0\n do l=1 to loops\n   do n=1 to d.0\n     m=m+(RxPattrn(d.n,test)=0)\n   end\n   if l=1 then say 'pattern matched' m 'times'\n end\n say 'cpu:' sysvar('syscpu')\n exit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXPNIV2$": {"ttr": 6159, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00C\\x01\\x184\\x7f\\x01\\x19 \\x1f\\x16\\x16\\x00$\\x00$\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2018-12-13T00:00:00", "modifydate": "2019-07-20T16:16:43", "lines": 36, "newlines": 36, "modlines": 0, "user": "DVL"}, "text": "//RXPCIVP2 JOB (1),'RXPCIVP$',CLASS=A,COND=(5,LT)\n//*\n//* RXPATTRN - REXX string pattern check\n//* Compare performance LPALIB to STEPLIB\n//*\n//*\n//* 1 - Running from LPA\n//*\n//LPA1     EXEC PGM=IKJEFT1B,PARM='%RXPCIVP2 10   *who*'\n//SYSEXEC  DD DISP=SHR,DSN=CBT669.PP.RXPATTRN.V001.LIB\n//TESTDATA DD DISP=SHR,DSN=WJ.LIB.DATA(DRWHO)\n//SYSTSPRT DD SYSOUT=*,OUTLIM=(5000)\n//SYSTSIN  DD DUMMY\n//*\n//LPA2     EXEC PGM=IKJEFT1B,PARM='%RXPCIVP2 100  *who*'\n//SYSEXEC  DD DISP=SHR,DSN=CBT669.PP.RXPATTRN.V001.LIB\n//TESTDATA DD DISP=SHR,DSN=WJ.LIB.DATA(DRWHO)\n//SYSTSPRT DD SYSOUT=*,OUTLIM=(5000)\n//SYSTSIN  DD DUMMY\n//*\n//* 2 - Running from steplib\n//*\n//SLB1     EXEC PGM=IKJEFT1B,PARM='%RXPCIVP2 10   *who*'\n//STEPLIB  DD DISP=SHR,DSN=CBT669.LPALIB\n//SYSEXEC  DD DISP=SHR,DSN=CBT669.PP.RXPATTRN.V001.LIB\n//TESTDATA DD DISP=SHR,DSN=WJ.LIB.DATA(DRWHO)\n//SYSTSPRT DD SYSOUT=*,OUTLIM=(5000)\n//SYSTSIN  DD DUMMY\n//*\n//SLB2     EXEC PGM=IKJEFT1B,PARM='%RXPCIVP2 100  *who*'\n//STEPLIB  DD DISP=SHR,DSN=CBT669.LPALIB\n//SYSEXEC  DD DISP=SHR,DSN=CBT669.PP.RXPATTRN.V001.LIB\n//TESTDATA DD DISP=SHR,DSN=WJ.LIB.DATA(DRWHO)\n//SYSTSPRT DD SYSOUT=*,OUTLIM=(5000)\n//SYSTSIN  DD DUMMY\n//*\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXPNMACS": {"ttr": 6161, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0f\\x00@\\x01\\x17\\x05\\x0f\\x01\\x184\\x1f\\x16\\x17\\x00#\\x00\\x01\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.15", "flags": 0, "createdate": "2017-02-19T00:00:00", "modifydate": "2018-12-07T16:17:40", "lines": 35, "newlines": 1, "modlines": 0, "user": "DVL"}, "text": "*-\n* Macros and copybooks for RXPATTRN.\n*-\n\n*- Reason\n         Macro\n         Reason &t,&c,&p3\n         lcla  &l\n&l       seta  k'&t-2\n         mvc   reason(&l),=c&t\n         mvc   reasonl,=a(&l)\n         aif   (k'&c eq 0).x\n         mvc   rc,=a(&c)\n         aif   ('&p3' ne 'T' and '&p3' ne 't').x\n         mvc   logr,reason\n         trclog ,\n.x       Mend\n\n*- Trclog\n         Macro\n&ml      TrcLog &t,&k\n         lclc  &l\n&l       setc  'TL&sysndx'\n&ml      ds    0h\n         cli   trace,c'Y'\n         jne   &l.x\n         mvlit logr,&t\n         aif   (k'&k eq 0).k0\n         RxSay logr,&k\n         ago   .b\n.k0      RxSay logr\n.b       anop\n         clear logr\n&l.x     equ   *\n         Mend\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXPNPRFT": {"ttr": 6163, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x06\\x01\\x184\\x1f\\x01  O\\x14S\\x00$\\x00$\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2018-12-07T00:00:00", "modifydate": "2020-07-22T14:53:06", "lines": 36, "newlines": 36, "modlines": 0, "user": "DVL"}, "text": "//RXPNPRFT JOB (1),'RXPN-perf-test',CLASS=A,COND=(5,LT)\n//*\n//* RXPATTRN - REXX string pattern check\n//* Compare performance LPALIB to STEPLIB\n//*\n//*\n//* 1 - Running from LPA\n//*\n//LPA1     EXEC PGM=IKJEFT1B,PARM='%RXPNIVP2 10   *who*'\n//SYSEXEC  DD DISP=SHR,DSN=CBT669.PP.RXPATTRN.V002.LIB\n//TESTDATA DD DISP=SHR,DSN=CBT669.PP.RXPATTRN.V002.LIB(RXPNTEXT)\n//SYSTSPRT DD SYSOUT=*,OUTLIM=(5000)\n//SYSTSIN  DD DUMMY\n//*\n//LPA2     EXEC PGM=IKJEFT1B,PARM='%RXPNIVP2 100  *who*'\n//SYSEXEC  DD DISP=SHR,DSN=CBT669.PP.RXPATTRN.V002.LIB\n//TESTDATA DD DISP=SHR,DSN=CBT669.PP.RXPATTRN.V002.LIB(RXPNTEXT)\n//SYSTSPRT DD SYSOUT=*,OUTLIM=(5000)\n//SYSTSIN  DD DUMMY\n//*\n//* 2 - Running from steplib\n//*\n//SLB1     EXEC PGM=IKJEFT1B,PARM='%RXPNIVP2 10   *who*'\n//STEPLIB  DD DISP=SHR,DSN=CBT669.LOADLIB\n//SYSEXEC  DD DISP=SHR,DSN=CBT669.PP.RXPATTRN.V002.LIB\n//TESTDATA DD DISP=SHR,DSN=CBT669.PP.RXPATTRN.V002.LIB(RXPNTEXT)\n//SYSTSPRT DD SYSOUT=*,OUTLIM=(5000)\n//SYSTSIN  DD DUMMY\n//*\n//SLB2     EXEC PGM=IKJEFT1B,PARM='%RXPNIVP2 100  *who*'\n//STEPLIB  DD DISP=SHR,DSN=CBT669.LOADLIB\n//SYSEXEC  DD DISP=SHR,DSN=CBT669.PP.RXPATTRN.V002.LIB\n//TESTDATA DD DISP=SHR,DSN=CBT669.PP.RXPATTRN.V002.LIB(RXPNTEXT)\n//SYSTSPRT DD SYSOUT=*,OUTLIM=(5000)\n//SYSTSIN  DD DUMMY\n//*\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXPNRDME": {"ttr": 6165, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x11\\x01\\x193\\x8f\\x01\\x193\\x8f\\x103\\x00\\x0b\\x00\\x0b\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-12-04T00:00:00", "modifydate": "2019-12-04T10:33:11", "lines": 11, "newlines": 11, "modlines": 0, "user": "DVL"}, "text": "Description of members:\n\n RXPATTRN  Product, edit and run this member.\n RXPNDOC   Documentation.\n RXPNHIST  Product history.\n RXPNIVPx  IVPs\n RXPNMACS  Local macros.\n SYSMACS   ASM copy book containing combined non-IBM macros.\n REXXMACS  ASM copy book containing my macros for interfacing with REXX.\n WSAMMACS  ASM copy book containig my structured assembler macro set.\n           The macros are equivalent but not identical to IBM's macros.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXPNTEXT": {"ttr": 6167, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x008\\x01\\x19\\x03o\\x01\\x19\\x03o\\x147\\x00$\\x00$\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-02-05T00:00:00", "modifydate": "2019-02-05T14:37:38", "lines": 36, "newlines": 36, "modlines": 0, "user": "DVL"}, "text": "Doctor Who is a British science-fiction\ntelevision programme produced by the BBC from 1963 to the\npresent day. The programme depicts the adventures of the\nDoctor, a Time Lord\na time-travelling humanoid alien. He explores the\nuniverse in his TARDIS, a sentient time-travelling\nspace ship. Its exterior appears as a blue British\npolice box, which was a common sight in Britain\nin 1963 when the series first aired. Along with a\nsuccession of companions, the Doctor combats a variety\nof foes while working to save civilisations and help\npeople in need.\n\nThe show is a significant part of British popular\nculture,and elsewhere it has become a cult television\nfavourite. The show has influenced generations of\nBritish television professionals, many of whom grew\nup watching the series.\u00dd4\u00a8 The programme originally\nran from 1963 to 1989. After an unsuccessful attempt\nto revive regular production in 1996 with a backdoor\npilot in the form of a television film, the programme\nwas relaunched in 2005 by Russell T Davies who was\nshowrunner and head writer for the first five years\nof its revival, produced in-house by BBC Wales in\nCardiff. The first series of the 21st century,\nfeaturing Christopher Eccleston in the title role,\nwas produced by the BBC. Series two and three had\nsome development money contributed by the Canadian\nBroadcasting Corporation (CBC), which was credited\nas a co-producer.\u00dd5\u00a8 Doctor Who also spawned spin-offs\nin multiple media, including Torchwood (2006 11) and\nThe Sarah Jane Adventures (2007 11), both created by\nRussell T Davies; K-9 (2009 10); and a single pilot\nepisode of K-9 and Company (1981). There also have\nbeen many spoofs and cultural references of the\ncharacter in other media.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXRDDOC": {"ttr": 6169, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x009\\x01\\x19!\\x1f\\x01\\x19(\\x0f\\x18D\\x00$\\x00\\x0f\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2019-07-30T00:00:00", "modifydate": "2019-10-07T18:44:39", "lines": 36, "newlines": 15, "modlines": 0, "user": "DVL"}, "text": ")F Function returns real name for relative gds or alias.\n\nBuild\n\n 001  Initial\n\n\nSyntax\n\n cc=RxRealDs(name,\u00ddnft\u00a8)\n\n  name   Relative gds or alias. Gdsrel may be positive like (+1).\n         The name is internally upcased.\n  nft    Returned text if name is not found. Default is a null string\n         The text is returned asis, not upcased.\n\n\nReturns\n\n Real name if such exists. Note that this could be the 'name' value\n if the name is already the real name.\n null or the nft value if name cannot be located.\n\n\nSamples\n\n ds=RxRealDs('WJ.TEST.GDG(-1)')\n say ds   /*  WJ.TEST.GDG.V1001V00 */\n\n ds=RxRealDs('WJ.TEST.GDG(+1)')\n say ds   /*  WJ.TEST.GDG.V1003V00 */\n\n cc=ListDsi(\"'\"RxRealDs('WJ.TEST.GDG(-1)')\"'\")\n\n Edit member of partitioned gds:\n  Address ispexec \"Edit dataset(\"'\"RxRealDs(wj.pgds(0)\"(member1)'\")\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXRDHIST": {"ttr": 6401, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00E\\x01\\x19!\\x1f\\x01\\x19!\\x1f\\x19W\\x00\\x04\\x00\\x04\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-07-30T00:00:00", "modifydate": "2019-07-30T19:57:45", "lines": 4, "newlines": 4, "modlines": 0, "user": "DVL"}, "text": "RXLOCATE history\n\nBld  Date        Text\n001  2019-07-30  Initial\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXRDIVP1": {"ttr": 6403, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x15\\x01\\x19!\\x1f\\x01\\x19!/\\x16\\x00\\x00]\\x00\\r\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2019-07-30T00:00:00", "modifydate": "2019-07-31T16:00:15", "lines": 93, "newlines": 13, "modlines": 0, "user": "DVL"}, "text": " /* rexx */\n\n dbase = userid()'.RXREALDS'\n gbase = dbase'.GDS'\n\n say 'Deleting orphans from earlier run'\n Call DelTestDs\n\n say ''\n say 'Start IVP1'\n zz=Outtrap('lst.')\n \"listc lvl(\"gbase\")\"\n c1=rc\n zz=Outtrap('off')\n if c1<>0 then do\n   \"DEFINE GDG(NAME('\"gbase\"') LIMIT(4) SCRATCH )\"\n   if rc<>0 then exit xmsg('Cannot define new gdg' gbase 'rc' rc,8)\n   say 'gdgbase' gbase 'defined'\n   say ''\n   /* create test gdss */\n   do gn=1 to 4\n     cc=bpxwdyn('alloc da('gbase'(+1)) new catalog gdgnt',\n            'lrecl(200) recfm(v,b) blksize(0)',\n            'tracks space(1,1) unit(sysda) rtddn(xdd)')\n     /*\n     Note using the GDGNT flag because an allocation of a GDG data set\n     refers to the same data set for the life of the job (or TSO/E\n     logon session), even if another generation is added during the\n     job, unless the GDGNT option is used.\n     */\n     if cc<>0 then exit xmsg('Alloc gds#' gn 'failed' cc,8)\n     cc=bpxwdyn('free dd('xdd')')\n   end\n end\n say 'Test gds created'\n zz=Outtrap('lst.')\n \"listc lvl(\"gbase\")\"\n zz=Outtrap('off')\n do n=1 to lst.0\n   if word(lst.n,1)='NONVSAM' then say word(lst.n,3)\n end\n say ''\n\n /* create dataset with alias */\n trace r\n testlib=dbase'.TEST.LIB'\n alias  =dbase'.TESTLIB'\n cc=bpxwdyn('alloc da('testlib') new catalog',\n            'lrecl(200) recfm(v,b) blksize(0)',\n            'tracks space(1,1) unit(sysda) rtddn(xdd)')\n trace off\n if cc<>0 then exit xmsg('Alloc testlib' testlib 'failed' cc,8)\n say 'Alloc testlib' testlib 'ok'\n \"DEFINE ALIAS(NAME('\"alias\"') RELATE('\"testlib\"'))\"\n if rc<>0 then exit xmsg('Create alias' alias 'failed' rc,8)\n cc=bpxwdyn('free dd('xdd')')\n\n /* start test */\n Call Go gbase'(-1)',,'Testing relative gds'\n Call Go dbase'.TEST.LIB',,'Testing real name'\n Call Go dbase'.TESTLIB',,'Testing alias'\n Call Go 'DOES.NOT.EXIST',,'Testing non-exist without alternate name'\n Call Go 'DOES.NOT.EXIST','alt.ds','Testing non-exist with alternate name'\n Call Go gbase'(+1)',,'Testing relative positive gds'\n say ''\n say 'Cleanup...'\n Call DelTestDs\n\n exit 0\n\nGo:\n parse arg ds,nft,text\n say ''\n if text<>'' then say text\n say 'testing' ds\n say 'returns' RxRealDs(ds,nft)\n return 0\n\nXMsg: if arg(1)<>'' then say arg(1);return word(arg(2) 0,1)\n\nDelTestDs:\n zz=Outtrap('lst.')\n \"listc lvl(\"gbase\")\"\n cc=rc\n zz=Outtrap('off')\n do n=1 to lst.0\n   if word(lst.n,1)='NONVSAM' then \"delete '\"word(lst.n,3)\"'\"\n end\n if cc=0 then \"delete '\"gbase\"'\"\n say ''\n if Sysdsn(\"'\"dbase\".TESTLIB'\")='OK' then \"delete '\"dbase\".TESTLIB'\"\n if Sysdsn(\"'\"dbase\".TEST.LIB'\")='OK' then \"delete '\"dbase\".TEST.LIB'\"\n return 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXRDPRML": {"ttr": 6406, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x15\\x00F\\x01\\x17\\x13\\x1f\\x01\\x193\\x8f\\x17P\\x01P\\x00\\xde\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.21", "flags": 0, "createdate": "2017-05-11T00:00:00", "modifydate": "2019-12-04T17:50:46", "lines": 336, "newlines": 222, "modlines": 0, "user": "DVL"}, "text": "//RXRP005   JOB (1),'RXRDPRML-005',\n//*  RESTART=IVP1,\n//          CLASS=A,REGION=32M,COND=(0,LT)\n//*\n//* ?1 Read parmlib member, return in stem : e\n//*\n//   EXEC ASMACL,PARM.C='TERM',PARM.L='LIST,MAP,XREF,RMODE(ANY)'\n//C.SYSLIB  DD DISP=SHR,DSN=SYS1.MACLIB\n//          DD DISP=SHR,DSN=SYS1.MODGEN\n//          DD DISP=SHR,DSN=CBT669.LIB\n//C.SYSTERM DD SYSOUT=*\n//C.SYSIN   DD *\n*Process compat(macrocase)\n*\n* Build 005\n*\n* Read parmlib member, return in stem\n* Parameters are positional\n*   mbrname,opt1,opt2,stemname,records,trace\n*   opt1      'XC1' exclude comments = '*' in col1\n*             'XC2' exclude comments = '/*' in col1-2\n*   opt2      'Y'   retain blank lines (default)\n*             'N'   ignore blank lines\n*   stemname  Must inclusd trailing dot, Default is 'PARMREC.'\n*   records   Max number of records, default is 500.\n*             Program will redrive the load if the value is too\n*             small - but you will see 2 IEE252I messages.\n*   trace     'Y'   create trace info (REXX SAY)\n*             'N'   do not create trace info. Default.\n*\n*  Sample: cc=RXRDPRML('IEASYSX0','xc1','n','parmlib.','20')\n*\n*  Return\n*    0   ok\n*   >0   not ok, variable RXRDPRML_ERRMSG contains the reason\n*\n* New/changed in this build\n*  Minor fixes\n*\n\n         lclc  &name,&build\n&name    setc  'RXRDPRML'\n&build   setc  '005'\n\n         print off\n         COPY  WSAMMACS\n         Copy  REXXMACS\n         Copy  SYSMACS\n*        Copy  z10macs\n         print on\n*- say\n         Macro\n         Say   &text,&len=\n         aif   (k'&text eq 0).defl\n         mvlit logr,&text,lr=r0\n         ago   .doit\n.defl    $la   r0,&len,&syslist(2),l'logr\n.doit    RxSay logr,(0)\n         clear logr\n         Mend\n*- trace\n         Macro\n         XTrace &text,&len=\n         if    (cli,trace,eq,c'Y')\n         Say   &text,len=&len\n         endif\n         Mend\n\n*-\n* start module\n*-\nRXRDPRML #module amode=31,rmode=any,base=(r11,r12),sa=sa1,             c\n               text='&build',epilog=epilog\n         sr    r10,r10\n\n* positional parms: mbrname,opt1,opt2,stemname,records,trace\n         RxInit parmlist=((mbrname,8),(opt1,4),(opt2,4),(stemname,40), c\n               (records,4),(trace,1))\n         oc    trace,blank\n\n         if    (cli,trace,eq,c'Y')\n           strmake logr,'Version ','&name &build',lenreg=r2\n           rxsay logr,(r2)\n           clear logr\n         endif\n\n         if    (cli,stemname,eq,c' ')\n           mvi   stemname_ds,8\n           mvc   stemname(8),=cl8'PARMREC.'\n         endif\n         oc    stemname,blank\n*-\n         if    (cli,trace,eq,c'Y')\n           StrMake logr,'mbrname  ',lenreg=r2,                         c\n               (mbrname_ds,1,cvd,3),+1,(mbrname,b.mbrname_ds)\n           rxsay logr,(r2)\n           StrMake logr,'stembase ',lenreg=r2,                         c\n               (stemname_ds,1,cvd,3),+1,(stemname,b.stemname_ds)\n           rxsay logr,(r2)\n           clear logr\n         endif\n\n* preset stem.0 to '0'\n         RxStemPut stema=varname,base=(stemname,b.stemname_ds),        c\n               num=0,data='0',namelenr=r2\n         if    (ltr,r5,r15,nz)\n           strmake reason,'stemput ',(varname,(r2)),' rc ',            c\n               (r5,,cvdr,4),lenreg=r3\n           st    r3,reasonl\n           if    (cli,trace,eq,c'Y')\n             rxsay reason,(r3)\n           endif\n           #module exit,rc=8\n         endif\n\n         if    (cli,mbrname,eq,c' ')\n           mvc   rc,=a(1)\n           mvlit reason,'Missing name',lr=r3\n           st    r3,reasonl\n           if    (cli,trace,eq,c'Y')\n             rxsay reason,(r3)\n           endif\n           #module exit\n         endif\n\n         oc    mbrname,blank\n         oc    opt1,blank\n         oc    opt2,blank\n\n*-\n*\n* Read named parmlib member into a buffer, size is either in the\n* 4th parm, or 500.\n*\n*-\n\n         if    (cli,records,eq,c' ')\n           mvi   records_ds,3\n           mvc   records(3),=cl3'500'\n         endif\n\n         lb    r15,records_ds\n         bctr  r15,0\n         j     *+10\n         pack  dw,records(*-*)\n         ex    r15,*-6\n         cvb   r15,dw                     # records\n         st    r15,recnum\n         mhi   r15,80                     80 = record length\n         la    r15,PRM_RECORDS-PRM_READ_BUFFER(,r15)\n         st    r15,bufsize\n\n         if    (cli,trace,eq,c'Y')\n           StrMake logr,'records ',(records,b.records_ds),lenreg=r2,   c\n               ' recnum ',(recnum,4,cvd,4),' bufsz ',(bufsize,4,cvd,6)\n           rxsay logr,(r2)\n         endif\n\n*-\n* compute buffer size, get buffer\n* fields of interest:\n*   PRM_MSG_BUFFER_SIZE 1F Input - Size of buffer including header\n*   PRM_MESSAGE_COUNT   1F Output - number of messages in the buffer\n*-\n\n         using PRM_READ_BUFFER,r10        map buffer\n         do forever\n           l     r4,bufsize\n           Getmain R,lv=(4)\n           lr    r10,r1\n           st    r4,PRM_READ_BUFF_SIZE\n\n           IEFPRMLB REQUEST=ALLOCATE,ALLOCDDNAME=ddname,BLANK72=YES,   +\n               CALLERNAME=callname,MEMNAME=mbrname,MOUNT=NO,           +\n               READ=YES,READBUF=(10),RETMSG=NO,S99RB=NO,WAITDSN=NO,    +\n               RETCODE=prrc,RSNCODE=prrs,FREECLOSE=YES\n           if    (clc,prrc,ne,zero)\n             mvc   fw,prrc+3\n             mvc   fw+1,prrs+3\n             if     (=x'0C01',eq,fw)\n               mvlit reason,'member not found',lr=r1\n               st    r1,reasonl\n             elseif (=x'0C0A',eq,fw)\n               l     r4,PRM_BUFF_SIZE_NEEDED\n               st    r4,bufsize\n               if    (cli,trace,eq,c'Y')\n                 strmake logr,'bfrsz reqd ',(r4,,cvdr,6),lenreg=r3\n                 rxsay  logr,(r3)\n                 clear  logr\n               endif\n               l     r2,PRM_READ_BUFF_SIZE\n               Freemain R,lv=(2),a=(10)\n               sr    r10,r10\n               iterate\n             else\n               strmake reason,'allocate rc ',lenreg=r3,                c\n               (prrc+3,1,c2x),' rs ',(prrs+3,1,c2x)\n               st    r3,reasonl\n             endif\n             if    (cli,trace,eq,c'Y')\n               rxsay reason,(r3)\n             endif\n             mvc   rc,=a(8)\n             #module exit\n           else\n             xtrace 'alloc done'\n           endif\n           leave\n         enddo\n\n*-\n*\n* Copy records to stem\n*\n*-\n\n         if    (icm,r6,15,PRM_TOTAL_RECORDS,z)  member record count\n           mvlit reason,'Null member'\n           mvc   reasonl,=a(11)\n           if    (cli,trace,eq,c'Y')\n             rxsay reason,(r3)\n           endif\n           mvc   rc,=a(8)\n           #module exit                         is zero\n         endif\n         sr    r5,r5                 output count\n         la    r7,PRM_RECORDS        -> 1st record\n\n         do    over(r6)\n* drop comments and blanks is requested\n           if     (clc,=c'XC1',eq,opt1),and,(cli,0(r7),eq,c'*')\n           elseif (clc,=c'XC2',eq,opt1),and,(clc,=c'/*',eq,0(r7))\n           elseif (clc,=c'XC2',eq,opt1),and,(clc,=c'/*',eq,1(r7))\n           elseif (clc,=c'N',eq,opt2),and,(clc,0(72,r7),eq,blank)\n           else\n             la    r5,1(,r5)          counter\n             RxStemPut  stema=varname,                                 c\n               base=(stemname,b.stemname_ds),num=(r5),data=((r7),71)\n             if    (ltr,r2,r15,nz)\n               strmake logr,'VPUT rc ',(r2,,cvdr,4),lenreg=r3\n               st    r3,logrl\n               mvc   rc,=a(3)\n               if    (cli,trace,eq,c'Y')\n                 rxsay logr,(r3)\n               endif\n               leave\n             endif\n           endif\n           la    r7,80(,r7)            bump data pointer\n         enddo\n\n         $cvd  r5,fw,len=4             save count\n         RxStemPut  stema=varname,                                     c\n               base=(stemname,b.stemname_ds),num=0,data=fw\n\n         #module exit\n\n*-\n*\n* Backend\n*\n*-\n\nEpilog   #subr label\n         if    (ltr,r10,r10,nz)           got a buffer\n           l     r2,PRM_READ_BUFF_SIZE\n           Freemain R,lv=(2),a=(10)\n         endif\n\n         if    (icm,r5,15,reasonl,nz)\n           la    r4,reason\n         else\n           la    r4,=c' '\n           la    r5,1\n         endif\n         RxVput name='RXRDPRML_ERRMSG',data=((r4),(r5))\n\n         l     r15,rc\n         $cvd  r15,dw,len=8\n         if    (cli,trace,eq,c'Y')\n           strmake logr,'rc ',dw,lenreg=r3\n           rxsay logr,(r3)\n           clear logr\n         endif\n\n         RxRetval dw,8\n         #subr exit,rc=0\n\n*-\n*\n* Data\n*\n*-\n\nzero     dc    a(0)\nblank    dc    cl100' '\n         ds    0a\nlogrl    dc    a(0)\nlogr     dc    cl100' '\nreasonl  dc    a(0)\nreason   dc    cl100' '\nsa1      ds    18f\nsa2      ds    18f\ndw       ds    d\nfw       ds    f\nrc       dc    a(0)\nrecnum   dc    a(0)\nbufsize  dc    a(0)\n\nCallname dc    cl16'&name..&build'\nDDname   dc    cl8' '\nprrc     dc    a(0)\nprrs     dc    a(0)\nvarnamel dc    a(0)\nvarname  dc    cl120' '\n\n         RexxMacs ds\n\n         ltorg\n\n         Dsect\n         RexxMacs dsect\n         IEZVX100 ,                   message dsect\n         IEFZPMAP ,                   iefprmlb buffer mapping\n         IEFZPRC  ,                   iefprmlb completion codes\n\n         End\n//*\n//* prod version goes to linklib\n//L.SYSLMOD DD DSN=CBT669.LINKLIB(RXRDPRML),DISP=SHR\n//*\n//IVP1     EXEC PGM=IKJEFT1B,PARM='RXRPIVP1'\n//STEPLIB  DD DISP=SHR,DSN=CBT669.LINKLIB\n//SYSEXEC  DD DISP=SHR,DSN=CBT669.LIB\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD DUMMY\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXREALDS": {"ttr": 6412, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x12\\x00\\x14\\x01\\x19!\\x1f\\x01\\x193\\x8f\\x17P\\x00\\x89\\x00\\x8a\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.18", "flags": 0, "createdate": "2019-07-30T00:00:00", "modifydate": "2019-12-04T17:50:14", "lines": 137, "newlines": 138, "modlines": 0, "user": "DVL"}, "text": "//RXRD001  JOB (1),'RXREALDS',\n//*  RESTART=IVP1,\n//        CLASS=A,COND=(0,LT),REGION=64M\n//*\n//* ?? REXX return actual ds from rel gds or alias\n//*\n//A       EXEC ASMACL,PARM.C='RENT,TERM',\n//        PARM.L='NCAL,LET,LIST,XREF,RENT,RMODE(ANY)'\n//C.SYSLIB  DD DISP=SHR,DSN=SYS1.MACLIB\n//          DD DISP=SHR,DSN=SYS1.MODGEN\n//          DD DISP=SHR,DSN=CBT669.LIB\n//C.SYSTERM DD SYSOUT=*\n//C.SYSIN   DD *\n**asma opt term\n**asma syslib sys1.maclib sys1.modgen CBT669.maclib\n\n* The JPAQ option will improve performance if the module is not\n* in the lpalib, as it will retain the module in the JPAQ.\n* The module is not very big so should not impact virtual storage.\n&jpaq    setc  'Y'                     Keep module in the JPAQ\n&jpaq    setc  'N'                     Do not keep module in the JPAQ\n\nRXREALDS TITLE 'Return Absolute or True name'\n*-\n*\n* Function returns real name for relative gds or alias.\n* Will return requested name if neither reative gds nor alias.\n*\n* Syntax\n*\n* cc=RXREALDS(name,\u00ddnft\u00a8)\n*\n* name   relative gds or alias\n* nft    returned text if name is not found. Default is a null string\n*\n* Sample\n*\n*  cc=RXREALDS('WJ.TEST.GDG(-1)')\n*  say cc   /*  WJ.TEST.GDG.V1001V00 */\n*  cc=ListDsi(\"'\"RXREALDS('WJ.TEST.GDG(-1)')\"'\")\n*\n* New in this build\n*  initial\n*\n*-\n\n         print off\n         copy dvlxmacs\n         yregs ,\n         print on\n\nRXREALDS Csect ,\nRXREALDS amode 31\nRXREALDS rmode any\n         bakr  14,0\n         lr    r12,r15\n         Using RXREALDS,r12\n\n         Getmain R,lv=$wrkl,loc=ABOVE\n         lr    r10,r1\n         using $wrk,r10\n         la    r13,sa1\n         mvi   dsname,c' '\n         mvc   dsname+1(l'dsname-1),dsname\n         oc    dsname,blanks\n\n         aif   ('&jpaq' ne 'Y').jpaqn\n*- Keep module in JPAQ for duration of job / TSO session\n         CDEUCTZ2\n.jpaqn   anop\n\n*- Initiate rexx env\n         ereg  0,1\n         RxInit parmlist=((p1,A),(p2,A))  area=dsname\n         lm    r14,r15,p1\n         bctr  r15,0\n         j     *+10\n         mvc   dsname(*-*),0(r14)\n         ex    r15,*-6\n\n*- Locate the catalog entry\n         mvc   camlste(camlstll),camlstl\n         la    r0,dsname\n         st    r0,camlste+4\n         la    r0,camlwrk\n         st    r0,camlste+12\n         LOCATE camlste            Locate Catalog Entry\n         ltr   r15,r15\n         jnz   LocErr\n\n*- Return original parm\n         StrLen data=dsname        r15 = length\n         RxRetval dsname,(r15)\n\nExit     ds    0h\n         Freemain R,lv=$wrkl,a=(r10)\n         sr    r15,r15\n         pr    ,\n\n*- Locate error, return parm 2 (not-found-string)\nLocErr   ds    0h\n         lm    r2,r3,p2\n         RxRetval (r2),(r3)\n         j    exit\n\n*-\ncamlstl  CAMLST NAME,*-*,,*-*\ncamlstll EQU   *-camlstl\nblanks   dc    cl120' '\n         ltorg\n\n$wrk     Dsect ,\nsa1      ds    18f\ncamlste  ds    xl(camlstll)\ndsname   ds    cl44\n         ds    0d\ncamlwrk  ds    cl265                    Locate really only uses 265\n         ds    0d\n         RexxMacs ds\n         ds    0d\n$wrkl    equ   *-$wrk\n\n         RexxMacs dsect\n         END   ,\n//L.SYSLMOD  DD DISP=SHR,DSN=CBT669.LINKLIB(RXREALDS)\n//*\n//* Production version is in CBT669.LINKLIB but could be\n//* in CBT669.LPALIB as program is RENT and REFR.\n//*\n//* Activate dynamic if in lpalib:\n//*   SETPROG LPA,ADD,MODNAME=RXREALDS,DSNAME=CBT669.LINKLIB\n//*\n//IVP1     EXEC PGM=IKJEFT1B,PARM='RXRDIVP1'\n//STEPLIB  DD DISP=SHR,DSN=*.A.L.SYSLMOD\n//SYSEXEC  DD DISP=SHR,DSN=CBT669.LIB\n//SYSTSPRT DD SYSOUT=*,OUTLIM=1000\n//SYSTSIN  DD DUMMY\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXRPDOC": {"ttr": 6415, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00I\\x01\\x17\\x08\\x7f\\x01\\x19(\\x0f\\x18C\\x00\\x15\\x00\\x11\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2017-03-28T00:00:00", "modifydate": "2019-10-07T18:43:49", "lines": 21, "newlines": 17, "modlines": 0, "user": "DVL"}, "text": ")F REXX function - Read parmlib member, return data in stem\n\n Build: 005\n\n Parameters\n  1  membername\n  2  option 1:\n      'XC1' exclude comments = '*' in col1\n      'XC2' exclude comments = '/*' in col1-2\n  3  option 3:\n      'Y'   retain blank lines (default)\n      'N'   ignore blank lines\n  4  stemname, inkl trailing dot, Default is 'PARMREC.'\n  5  max number of records, default is 500\n\n Sample: cc=RXRDPRML('IEASYSX0','xc1','n','parmlib.','20')\n\n Return\n   0   ok\n  >0   not ok, variable RXRDPRML_ERRMSG contains the reason\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXRPHIST": {"ttr": 6658, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x02\\x001\\x01\\x19\\x19\\x9f\\x01\\x19'o\\x17\\x15\\x00\\x07\\x00\\x06\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@\"", "ispf": {"version": "01.02", "flags": 0, "createdate": "2019-07-18T00:00:00", "modifydate": "2019-10-03T17:15:31", "lines": 7, "newlines": 6, "modlines": 0, "user": "DVL"}, "text": "History\n 003  Support new version of the REXXMACS macro set.\n 004  Use macros #module and #subr for entry and exit.\n      Provide text for some reason codes.\n      Redrive load if 'records' value is too small.\n      Trace option.\n 005  Minor fixes\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXRPIVP$": {"ttr": 6660, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x007\\x01\\x17\\x08O\\x01\\x19\\x10\\x1f#2\\x00\\x08\\x00\\x08\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2017-03-25T00:00:00", "modifydate": "2019-04-11T23:32:37", "lines": 8, "newlines": 8, "modlines": 0, "user": "DVL"}, "text": "//RXRPIVP$ JOB (1),'RXRDPRML-IVP-1',CLASS=A,REGION=32M\n//*\n//IVP1     EXEC PGM=IKJEFT1B,PARM='RXRPIVP1'\n//STEPLIB  DD DISP=SHR,DSN=CBT669.LINKLIB\n//SYSEXEC  DD DISP=SHR,DSN=CBT669.PP.RXRDPRML.V003.LIB\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD DUMMY\n//TESTDATA DD RECFM=VB,LRECL=100,SPACE=(TRK,(5,5)),UNIT=(SYSDA)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RXRPIVP1": {"ttr": 6662, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x13\\x00\\x02\\x01\\x17\\x08O\\x01\\x184\\x0f\\x19\\x12\\x00.\\x00\\x18\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.19", "flags": 0, "createdate": "2017-03-25T00:00:00", "modifydate": "2018-12-06T19:12:02", "lines": 46, "newlines": 24, "modlines": 0, "user": "DVL"}, "text": "/*                                                             rexx\n\n RXRDPRML IVP\n\n Positional parms: mbrname,opt1,opt2,stemname,records,trace\n\n  stemname\n   default='PARMREC.'\n  opt1\n   'XC1' exclude comments = '*' in col1\n   'XC2' exclude comments = '/*' in col1-2\n  opt2\n   'Y'   retain blank lines (default)\n   'N'   ignore blank lines\n  records\n   default=500\n  trace\n   'Y'   do trace\n*/ */\n\n Call DoIt 'ADYSET00'\n Call DoIt 'ADYSET00 opt1(xc1)'\n Call DoIt 'ANTMIN00'\n Call DoIt 'ANTMIN00 stem(antm.) opt1(xc2)'\n Call DoIt 'NOTEXIST'\n Call DoIt 'diag00 recs(10)'\n\nExit 0\n\nDoIt: Procedure\n arg p\n parse var p mbr . 'OPT1(' opt1 . ')' . 0 . 'OPT2(' opt2 . ')' .,\n 0 . 'RECS(' recs . ')' . 0 . 'STEM(' stm . ')' . 0 . 'TRACE(' trc . ')' .\n say 'Read parmlib mbr' mbr 'to stem' stm 'opt1='opt1 'opt2='opt2,\n     'records='recs 'trace='trc\n cc=RXRDPRML(mbr,opt1,opt2,stm,recs,trc)\n say 'rc' cc  'rs' strip(RXRDPRML_ERRMSG)\n /*cc=rexxgblv('rlist')  */\n\n stm=word(stm 'PARMREC.',1)\n doitl=\"say '\"stm\"0='\"stm\"0;\",\n       \"do n=1 to\" stm\"0;say\" stm\"n;end;drop\" stm\n if cc<>0 then say 'Reason:' RXRDPRML_ERRMSG\n else interpret doitl\n say ''\n return 0.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXRPRDME": {"ttr": 6664, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x06\\x01\\x193\\x8f\\x01\\x193\\x8f\\x107\\x00\\x0b\\x00\\x0b\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-12-04T00:00:00", "modifydate": "2019-12-04T10:37:06", "lines": 11, "newlines": 11, "modlines": 0, "user": "DVL"}, "text": "Description of members:\n\n RXRDPRML  Product, edit and run this member.\n RXRPDOC   Documentation.\n RXRPHIST  Product history.\n RXRPIVPx  IVPs\n RXRPMACS  Local macros.\n SYSMACS   ASM copy book containing combined non-IBM macros.\n REXXMACS  ASM copy book containing my macros for interfacing with REXX.\n WSAMMACS  ASM copy book containig my structured assembler macro set.\n           The macros are equivalent but not identical to IBM's macros.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXSTDOC": {"ttr": 6666, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00G\\x01\\x17&\\x1f\\x01\\x183\\x8f\\x15S\\x00V\\x00U\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2017-09-18T00:00:00", "modifydate": "2018-12-04T15:53:47", "lines": 86, "newlines": 85, "modlines": 0, "user": "DVL"}, "text": " REXX function - Write and read data to named storage area.\n\n Current build: 004\n\n\n The purpose of the  program is to allow a REXX  program to store a\n string of  data in  common storage and  retrieve it  later, either\n from the same program or from another REXX program.\n\n REXXSTOR is reentrant and refreshable, so can reside in the LPAlib.\n\n REXXSTOR must be called as a function !\n\n REXXSTOR sets the following variables:\n   REXXSTOR_RC  return code, not the same as the return value. See\n                later for details.\n   REXXSTOR_RS  reason code when return code is not 0.\n\n\n Syntax:\n   action,name,data|variablename|length\n\n   action is folded to uppercase internally\n     A          Acquire a data block. This is sort-of a GETMAIN.\n                Returns the address of the area.\n                You can then use the STORAGE function to update\n                and retrieve data.\n     D          Delete (release) the storage.\n     G          Get data from storage. If the 'variablename'\n                parameter is used, then data will be written\n                to the named variable, otherwise data will be in\n                the return value.\n     GA         Get the address of the storage area. Useful if\n                you intend to use the STORAGE function to update\n                or retrieve data. the same information is returned\n                from the A action.\n     GX         Same as G, plus the storage will be deleted (released)\n     I          Get some information about the storage area.\n     P          Write (put) data to storage. If the storageblock\n                exists already, it will be overwritten.\n     VER        Return the program name and build.\n\n   name         Name of storage area. 1-8 bytes. Can be virtually\n                anything. It is not folded to uppercase.\n\n   data         Data to write to storage. Used with action P.\n\n   length       Size of storage to acquire. Used with action A.\n\n   variablename Name of variable to copy data to.\n\n\n Return:\n   data if action is G or I\n   address if action is A or GA\n   ' '     if action is P, or if no data for action Gx\n\n\n Variable REXXSTOR_RC is set as follows:\n    0     all ok\n    1     missing or invalid parm 1\n    2     missing or invalid parm 2\n    3     missing or invalid parm 3\n    8     no data in requested block\n    9     unknown storage block\n   11     set of large return value failed\n   99     some other error, see reason variable\n\n\n Samples:\n\n  cc   = REXXSTOR('a','stblk1','200') /* get block                   */\n  va   = REXXSTOR('ga','stblk1')      /* get block address           */\n  va   = REXXSTOR('d','stblk1')       /* remove block                */\n  data = copies('a string ',100)\n  cc   = REXXSTOR('p','stblk2',data)  /* write to store              */\n\n The STORAGE function can be used to store data directly in the data\n block, and retrieve data from the storage block, like this:\n\n Sample\n\n  addr = REXXSTOR('a','stblk2',2000)       /* acquire storage         */\n  cc   = Storage(addr,,'Kilroy was here')  /* write string to storage */\n  resp = Storage(d2x(x2d(addr)+7),3)       /* get 'was'               */\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXSTHIST": {"ttr": 6669, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00R\\x01\\x17&\\x1f\\x01\\x182\\x9f\\x17!\\x00\\x04\\x00\\x03\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2017-09-18T00:00:00", "modifydate": "2018-11-25T17:21:52", "lines": 4, "newlines": 3, "modlines": 0, "user": "DVL"}, "text": "Changelog\n 003 2017-03-11 support new REXXMACS macro set\n 004 2017-09-18 reentrant and refreshable\n 005 2018-11-25 internal restructure and cleanup\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXSTIVP": {"ttr": 6671, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01<\\x00H\\x01\\x17&\\x1f\\x01\\x183\\x9f\\x17\\x06\\x00g\\x00\\x19\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.60", "flags": 0, "createdate": "2017-09-18T00:00:00", "modifydate": "2018-12-05T17:06:48", "lines": 103, "newlines": 25, "modlines": 0, "user": "DVL"}, "text": " /*                           IVP for REXXSTOR\n\n   Testing actions:\n     A          Acquire a data block.\n     D          Delete (release) the storage.\n     G          Get data from storage.\n     GA         Get the address of the named storage area.\n     GX         Same as G, plus the storage will be deleted.\n     I          Get some information about the storage area.\n     P          Write (put) data to storage. If the storageblock\n     VER        Return the program name and build.\n */\n address TSO\n\n say '-------------------  version -------------------'\n\n v = RexxStor('ver')\n if left(v,8)<>'REXXSTOR' then exit xmsg('Version not pgmname:' v,8)\n say 'Version:' v\n say ''\n\n say '-----------  acquire, storage function ---------'\n\n cc   = Test('a','stblk0',2000,)          /* acquire storage         */\n addr = rv\n say 'address of stblk0:' addr\n cc   = Storage(addr,,'Kilroy was here')  /* write string to storage */\n resp = Storage(d2x(x2d(addr)+7),3)       /* get 'was'               */\n if resp<>'was' then exit xmsg('Storage string is not ''was''',8)\n cc   = Test('ga','stblk0')               /* get address             */\n if rv<>addr then exit xmsg('GA failed, addr:' addr',rv:' rv,8)\n say 'GA ok, addr' addr 'confirmed'\n say ''\n\n say '------------------ map and info ----------------'\n\n cc=Test('map')\n if rc<>0 then exit xmsg('Bad rc',20)\n\n cc=Test('i','stblk0')\n if rc<>0 then exit xmsg('Bad rc',20)\n if word(rv,1)<>'stblk0' then exit xmsg('Storage id not ''stblk0''',8)\n say ''\n\n say '----------------- put and get ------------------'\n\n text1 = 'another fine day'\n say   = 'text='text1\n cc=Test('p','stblk1',text1)\n if cc<>0 then exit xmsg('rc<>0',20)\n cc=Test('g','stblk1')                   /* return value */\n if cc<>0 then exit xmsg('rc<>0',20)\n if rv<>text1 then exit xmsg('Text not as expected',20)\n cc=Test('g','stblk1','newtext1')        /* value to variable */\n if cc<>0 then exit xmsg('rc<>0',20)\n say 'newtext1='newtext1\n if newtext1<>text1 then exit xmsg('Get text to var not as expected',20)\n say ''\n\n say '---------------- get&delete --------------------'\n\n cc=Test('i','stblk1')\n say 'info:' rv\n cc=Test('gx','stblk1')\n say 'data:' rv\n cc=Test('i','stblk1')\n if rv<>'' then exit xmsg('Storage stblk1 not deleted')\n say ''\n\n say '----------------  delete -----------------------'\n\n cc=Test('p','stblk3','Kilroy was here....')\n cc=Test('i','stblk3')\n say 'info:' rv\n cc=Test('d','stblk3')\n if cc<>0 then exit xmsg('Bad rc',20)\n cc=Test('i','stblk3')\n if rv<>'' then exit xmsg('Storage stblk3 not deleted')\n say ''\n\n say '------------------ map -------------------------'\n\n cc=Test('map')\n say ''\n\n say '---------------- invalid calls -----------------'\n\n cc= Test('i')\n if cc<>2 then exit xmsg('Bad rc' cc', should have been 2',20)\n say 'rc 2 received as expected'\n say ''\n\n exit xmsg('All ok')\n\nTest:\n say '->REXXSTOR' arg(1)','arg(2)','arg(3)','arg(4)\n rv=RexxStor(arg(1),arg(2),arg(3),arg(4))\n rc=REXXSTOR_Rc+0\n rs=strip(REXXSTOR_RS,'b')\n say 'rv \"'rv'\" rc \"'rc'\" rs \"'rs'\"'\n return rc\n\nXMsg: if arg(1)<>'' then say arg(1);return word(arg(2) 0,1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXSTIVP$": {"ttr": 6674, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x12\\x01\\x17&\\x1f\\x01\\x18)?\\x158\\x00\\x08\\x00\\x07\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2017-09-18T00:00:00", "modifydate": "2018-10-20T15:38:12", "lines": 8, "newlines": 7, "modlines": 0, "user": "DVL"}, "text": "//RXSTIVP$ JOB (1),'RXSTIVP$',\n//             CLASS=A,MSGCLASS=X,REGION=32M,TIME=NOLIMIT,COND=(5,LT)\n//*\n//GO       EXEC PGM=IKJEFT1B,PARM='%RXSTIVP'\n//STEPLIB  DD DISP=SHR,DSN=CBT669.TEST.LINKLIB\n//SYSEXEC  DD DISP=SHR,DSN=CBT669.LIB\n//SYSTSPRT DD SYSOUT=*,OUTLIM=2000\n//SYSTSIN  DD DUMMY\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RXSTMACS": {"ttr": 6676, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x001\\x01\\x17&\\x1f\\x01\\x19)_\\x15\\x14\\x00M\\x00S\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "2017-09-18T00:00:00", "modifydate": "2019-10-22T15:14:31", "lines": 77, "newlines": 83, "modlines": 0, "user": "DVL"}, "text": "\n*------------------REXX Say------------------------------------------*\n\n         Macro\n         SayIt &t,&l\n         gblc  &trace\n         aif   ('&trace' ne 'Y').x\n         lcla  &len\n         lclc  &lbl\n&lbl     setc  'S&sysndx'\n&len     seta  l'logr\n         aif   (k'&t eq 0).txn\n&len     seta  (k'&t)-2\n         mvc   logr(&len),=c&t\n.txn     anop\n         aif   (k'&l eq 0).tln\n&len     seta  &l\n.tln     anop\n         clc   =c'TRACE',opt\n         jne   &lbl.c\n         RXSAY logr,&len\n.clr     anop\n&lbl.c   equ   *\n         clear logr\n.x       Mend\n\n*------------------Set reason text-----------------------------------*\n\n         Macro\n         Reason &t,&c\n         lcla  &l\n&l       seta  k'&t-2\n         mvc   reason(&l),=c&t\n         mvc   reasonl,=a(&l)\n         aif   (k'&c eq 0).x\n         mvc   rc,=a(&c)\n.x       Mend\n\n*------------------Trace block start/end-----------------------------*\n\n         Macro\n.* TrcBlk / TrcBlkEnd is used around larger trace blocks. This\n.* cuts down on the number of instructions executed.\n         TrcBlk\n         gblc  &trcblka\n         aif   ('&trcblka' eq '').go\n         mnote 8,'***trcblka ne null'\n         mexit\n.go      anop\n&trcblka setc  'TB&sysndx.END'\n         cli   trace,c'Y'\n         jne   &trcblka\n         Mend\n\n         Macro\n         TrcBlkEnd\n         gblc  &trcblka\n&trcblka ds    0h\n&trcblka setc  ''\n         Mend\n\n         Macro\n&ml      TrcLog &t,&k\n         lclc  &l\n&l       setc  'TL&sysndx'\n&ml      ds    0h\n         cli   trace,c'Y'\n         jne   &l.x\n         mvlit logr,&t\n         aif   (k'&k eq 0).k0\n         RxSay logr,&k\n         ago   .b\n.k0      RxSay logr\n.b       anop\n         clear logr\n&l.x     equ   *\n         Mend\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXSTRDME": {"ttr": 6679, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00E\\x01\\x193\\x8f\\x01\\x193\\x8f\\x10)\\x00\\x0b\\x00\\x0b\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-12-04T00:00:00", "modifydate": "2019-12-04T10:29:45", "lines": 11, "newlines": 11, "modlines": 0, "user": "DVL"}, "text": "Description of members:\n\n REXXSTOR  Product, edit and run this member.\n RXSTDOC   Documentation.\n RXSTHIST  Product history.\n RXSTIVPx  IVPs\n RXSTMACS  Local macros.\n SYSMACS   ASM copy book containing combined non-IBM macros.\n REXXMACS  ASM copy book containing my macros for interfacing with REXX.\n WSAMMACS  ASM copy book containig my structured assembler macro set.\n           The macros are equivalent but not identical to IBM's macros.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXVBDOC": {"ttr": 6681, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01:\\x00\\x16\\x01\\x134o\\x01  O\\tY\\x00\\xcb\\x003\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.58", "flags": 0, "createdate": "2013-12-12T00:00:00", "modifydate": "2020-07-22T09:59:16", "lines": 203, "newlines": 51, "modlines": 0, "user": "DVL"}, "text": ")F REXX function - VSAM db bulk access\n\nCurrent build: 026\n\nFixed in this version\n Possible filter (MASK parameter) error\n\nNew in this version\n none\n\nChanges in this version\n none\n\nThe program can add, replace, retrieve or delete records from a VSAM\ndatabase. Access is normally by key/keyprefix, but some functions allow\naccess based on text anywhere in the record. Data is either read from a\nREXX stem or stack, or written to a REXX stem or stack.\n\nVSAM types KSDS and fixed-length RRDS are supported.\n\nInitial load of both types is supported.\n\nRXVSAMBA is  reentrant and refreshable,  so can reside in  the LPAlib.\n\nRXVSAMBA must be called as a function !\n\nRXVSAMBA sets the following variables:\n RXVBVERS  version info\n RXVBREAD  number of reads\n RXVBWRIT  total number of writes (updates+inserts)\n RXVBINSE  number of inserts\n RXVBUPDT  number of updates\n RXVBDELE  number of deletes\n RXVBKEYL  key length from the ACB\n RXVBKEYP  key position from the ACB\n RXVBRECL  data base lrecl\n RXVBDBTY  data base type K=KSDS, R=RRDS\n RXVBERRM  error message\n\nThe program returns a return value\n\n   0    all ok\n  >0    some error, check the RXVBERRM value\n\n** warning **\nBuild 015   Redefines the use  of operands LIST(name) and\n            KEYSTEM(name).\n            Changes the FILTER(name) operand to TEXTSTEM(name).\n            Redefines the use for  the RXVBWRIT variable\n\n\nSyntax\n\n  rc=RXVSAMBA(action required-parameters other-parameters)\n\nRequired parameters - must be used in all calls\n\n  DD(ddname)               Refers to the database\n  or\n  DA(datasetname)          Name of the database, it will be allocated\n                           dynamically and freed.\n\nRead database records\n\n  GET    STEM(stemname)    Copy records to stem 'stemname'.\n         STACK             Copy records to the stack.\n                           Either STEM or STACK is required, they are\n                           mutually exclusive.\n         KEY(key-value)    KSDS: select by specific key, note that\n                           leading and trailing blanks are stripped.\n                           RRDS: record number, leading zeros are added\n                           internally.\n         KEYVAR(var-name)  Name of variable containing key, including\n                           leading or trailing blanks.\n         KEYSTEM(stemname) Select by keys in stem.\n         MASK(mask)        Scan the entire database, select by mask.\n                           Mask wildcards are '%' for one character and\n                           '*' for any number, incl no, characters.\n         TEXT(text) POS(start) \u00ddENDPOS(end)\u00a8\n         TEXTSTEM(stemname) POS(start) \u00ddENDPOS(end)\u00a8\n                           Scan the entire database, select by value 'text'\n                           or text in stem 'stemname'\n         TO(to-val)        RRDS only, ending record number to retrieve.\n\n         KEY and MASK may be used together, thereby significantly reducing\n         wild-card search time. I.e. 'KEY(M) MASK(M*NTH*)' will often be\n         much faster than just 'MASK(M*NTH*)'\n\nGet data by key to stem, delete retrieved records.\n\n  PULL   operands\n\n  Same operand syntax as for the GET command.\n\nDelete database records.\n\n  DELETE KEY(key-value)    Select by specific key.\n         KEYVAR(var-name)  Name of variable containing key, including\n                           leading or trailing blanks.\n         KEYSTEM(stemname) Select by keys in stem.\n         MASK(mask) POS(start) \u00ddENDPOS(end)\u00a8\n         MASKSTEM(stemname) POS(start) \u00ddENDPOS(end)\u00a8\n         TEXT(text) POS(start) \u00ddENDPOS(end)\u00a8\n         TEXTSTEM(stemname) POS(start) \u00ddENDPOS(end)\u00a8\n                           Scan the entire database, select by value 'text'\n                           or text in stem 'stemname'\n         LIST(stemname)    Copy deleted records to list.\n\n         KEY  and  MASK  may  be  used  together,  thereby  significantly\n         reducing wild-card search time.  I.e. 'KEY(M) MASK(M*NTH*)' will\n         often be much faster than just 'MASK(M*NTH*)'\n\nInsert records  - records must  be sorted in ascending  order and\nmust be new.\n\n  INSERT STEM(stemname)    Insert records from stem 'stemname'.\n         STACK             Insert records from the stack.\n                           Either STEM or STACK is required, they are\n                           mutually exclusive.\n\nAdd records  - records  need not be  sorted, exising  records are\nupdated.\n\n  PUT    STEM(stemname)    Add records from stem 'stemname'.\n         STACK             Add records from the stack.\n                           Either STEM or STACK is required, they are\n                           mutually exclusive.\n\n         VALUE(text)       'text' is the data to add, max length 120 bytes.\n                           If output is to a RRDS then value must start\n                           with an 8-byte record number.\n\nRetrieve information about the cluster\n\n  INFO\n         Sets the following variables:\n         RXVBKEYL  key length\n         RXVBKEYP  key offset\n         RXVBRECL  max record length\n         RXVBDBTY  data base type K=KSDS, R=RRDS\n\nRetrieve the program build info\n\n  VERSION\n         returns version info, i.e. RXVSAMBA.020 2019-01-26 14.12\n         Sets the following variable\n         RXVBVERS\n\n\nNotes to syntax\n\n Stemname must have a dot '.' at the end.\n Key-value can be a key prefix.\n Key-value and value are case sensitive.\n KEY specification. The KEY operand is stripped by leading and trailing\n blanks. This maens that if you specify a key with a length shorter\n than the database reclen, then an additional READ is done, due to the\n key-sequential processing done for keyed request. This can be avoided\n by one of these means:\n  Use the KEYVAR or KETSTEM operand, values there are not stripped.\n  Pad the KEY value to the db reclen and add a non-blank at the end. The\n  KEY value is truncated to the DB reclen internally.\n\n\nSamples\n\n  See the RXGVIVP1 member.\n\n\nRRDS Support\n\n The program now supports fixed-length RRDS databases. All the GET and\n PUT features are available, plus the GET .. TO (to-val) option. DELETE\n and thus PULL are not supported for RRDS as you cannot delete records in\n a RRDS, only replace. INSERT works as an alias for PUT, so you really\n should use just the PUT command.\n\n Records have the following format:\n   1-8  record number\n   9-   data\n This format must be also used when adding data.\n\n Even though data is stored as fixed length, they need not be filled to\n the lrecl when added, as records are padded with blanks when stored and\n stripped for trailing blanks when retrieved.\n\n Records can be written in any order.\n\n Sample read, get slots 6-8 to list\n   cc=RxVsamBa('get dd(rrds) stem(lst.) key(6) to(8)')\n\n Sample read, get slots 8, 6, 4 and 2 to list\n\n   parse value '4 8 6 4 2' with ks.0 ks.1 ks.2 ks.3 ks.4\n   cc=RxVsamBa('get dd(rrds) stem(lst.) keystem(ks.)')\n\n Sample write, (re) write slots 11, 13 and 15:\n\n   new.1= '00000011RXVSAMBA supports'\n   new.2= '00000013VSAM fixed-length RRDS databases'\n   new.3= '00000015as of build 022'\n   new.0= 3\n   cc=RXVSAMBA('put dd(rrds) stem(new.)')\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXVBHIST": {"ttr": 6915, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x17\\x00U\\x01\\x171\\x8f\\x01  O\\x10\\x07\\x00h\\x00\\x1c\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.23", "flags": 0, "createdate": "2017-11-14T00:00:00", "modifydate": "2020-07-22T10:07:55", "lines": 104, "newlines": 28, "modlines": 0, "user": "DVL"}, "text": "History\n\n003 2016-02-01\n Changed\n   Use PARMSCN2 macro for parameter extract\n004 2016-08-28\n New\n   parameter: IGNDUP(Y) Ignore duplicates\n Changed\n   statvar names renamed to RXVB....\n     RXVBVERS  version info\n     RXVBREAD  number of reads\n     RXVBWRIT  number of PUTs\n     RXVBDELE  number of deletes\n     RXVBINSE  number of INSERTs\n     RXVBERRM  error message\n005 2016-10-23\n New\n   DELETE STEM(s) POS(p) Delete by text in stem.\n   Get sequential by filter stem\n006 2016-11-08\n Changed\n   Build filterlist internally instead of stemgets\n007 2017-02-20\n Changed\n   Internal macros stored seperately as copybook\n008 2017-02-29\n Changed\n   Minor internal changes to support outside macro changes.\n009 2017-05-12\n Changed\n   Minor internal changes to support new REXXMACS\n010 2017-08-27\n Fixed\n   Fix problem with update record length\n011 2017-09-18\n Changed\n   Program is now reentrant\n New\n   option:   ENQ(name)  1-16 chars\n012 2017-09-19\n New\n   option:   VALUE(t) for PUT\n014 2017-11-10\n New\n   info variable RXVBRECL - record length\n   Set rc 8 for stem.0 not found\n Fixed\n   Abend S0C7 for stem.0 not found\n015 2018-07-04\n Changed\n   Redefines the use of operands LIST(name) and KEYSTEM(name).\n   Redefines the use of the RXVBWRIT variable\n   Removes the FILTER(name) operand.\n New\n   RXVBUPDT variable\n   STACK option - use the REXX stack for input/output\n Fixed\n   LOGR field overflow\n016 2018-08-11\n Changed\n   Minor internal changes, external macros\n017 2018-08-16\n Changed\n   Prevent additional READs if requested keylen = db keylen\n   Add operand KEYVAR(var-name)\n Fixed\n   Abend S0C7 when stem.0 is not numeric\n018 2018-09-18\n Fixed\n   Abend S0C4 when using keystem.\n019 2018-12-07\n New\n   MASK operand\n Changed\n   Internal changes, using macros #module and #subr instead\n   of specialized macros.\n020 2019-01-26\n Fixed loop when using GET with both KEY and MASK\n021 2019-04-21\n Fixed\n  - S0C4 when using invalid parm i.e. START(n) instead of POS(n), it\n    was actually a bug in the STRMAKE macro, but still..\n  - Missing handling of error encountered in PROLOG processing.\n022 2019-06-07\n Changed\n  Some internal changes, primarily with handling of masks.\n New\n  Support for RRDS databases\n  Can now load into an empty KSDS\n023 2019-08-15\n New\n  DA(datasetname) in addition to dD(ddname)\n024 2019-10-10\n Changed\n  Linked with RMODE ANY\n Fixed\n  PUT .. VALUE was not working after RRDS support added\n025 2019-12-02\n Fixed\n  problems with  mask + pos + endpos\n026 2020-07-22\n Fixed\n  Possible filter (MASK parameter) error\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXVBIVP$": {"ttr": 6918, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0e\\x009\\x01\\x17\\x05\\x1f\\x01\\x193\\x8f\\x17P\\x00\\x08\\x00\\x05\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.14", "flags": 0, "createdate": "2017-02-20T00:00:00", "modifydate": "2019-12-04T17:50:39", "lines": 8, "newlines": 5, "modlines": 0, "user": "DVL"}, "text": "//RXVBIVP1 JOB (1),'RXVSAMBA-IVP-1',\n//             CLASS=A,REGION=32M,TIME=NOLIMIT,COND=(5,LT)\n//*\n//IVP1     EXEC PGM=IKJEFT1B,PARM='RXVBIVP1'  PFX(Z)'  PGM(RXVSAMBT)'\n//STEPLIB  DD DISP=SHR,DSN=CBT669.LPALIB\n//SYSEXEC  DD DISP=SHR,DSN=CBT669.PP.RXVSAMBA.LIB\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD DUMMY\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RXVBIVPX": {"ttr": 6920, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00D\\x01\\x191_\\x01\\x191_\\x17!\\x00\\xcf\\x02g\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2019-11-11T00:00:00", "modifydate": "2019-11-11T17:21:44", "lines": 207, "newlines": 615, "modlines": 0, "user": "DVL"}, "text": " /*                                                             REXX\n  RXVSAMBA Installation Verification build 024\n */\n parse source sys type whoami ddn whereami .\n address tso\n maxrc=0\n totdel=0\n totins=0\n dbkeylen=25\n cols100= '----+----1----+----2----+----3----+----4',\n       || '----+----5----+----6----+----7----+----8',\n       || '----+----9----+----0'\n cols40=left(cols100,40)\n cols80=left(cols100,80)\n\n arg p\n if p<>'' then say 'Parameters:    ' p\n parse var p . 'PFX('dspfx')' . 0 . 'PGM('pgmname')' .,\n       0 . 'DELA('dela')' . 0 . 'VOL('testvol')' .\n parse var whereami q1'.'\n if dspfx='' then dspfx=userid()\n if pos('.',dspfx)=0 then dspfx=dspfx'.RXVSAMBA'\n ksdsds =\"'\"dspfx\".TEST.KSDS'\"\n rrdsds =\"'\"dspfx\".TEST.RRDS'\"\n if testvol='' then do\n   zz=listdsi('sysexec file')\n   call silent \"listc ent('\"sysdsname\"') vol\"\n   testvol= word(translate(value('$.'$.0),' ','-'),2)\n end\n pgmname=word(pgmname 'RXVSAMBA',1)\n dela   =word(dela    'N',1)\n call xmsg 'Program test specs'\n say 'Dataset prefix..' dspfx\n say 'Test KSDS name..' ksdsds\n say 'Test RRDS name..' rrdsds\n say 'Test volume.....' testvol\n say 'Program name....' pgmname\n say 'Delete-after....' dela\n say ''\n\n /*------------------ Version ----------------------------------------*/\n call xmsg 'Test version'\n cc=RunPgm('version')\n say 'version' RXVBVERS\n say ''\n\n /*------------------ Status -----------------------------------------*/\n call xmsg center('KSDS',70,'-')\n say ''\n Call MakeKSDS     /* setup test data */\n Call DBinfo 'KSDS'\n if RXVBrecl<>200 then Exit Xmsg('*error*, lrecl should be 200',20)\n say ''\n\n call xmsg 'Get all begin'\n cc=RxVsamBa('get dd(ksds) stem(lst.)')\n call xmsg 'Get all ended rc' cc 'returned' lst.0 'records'\n\n Call ListDB 'ListDB before'\n say ''\n\n\n /*------------------ Get with mask  ---------------------------------*/\n\n call xmsg '- Get sequential with mask -'\n cc=RunPgm('get dd(ksds) mask(*LIB*) pos(03) endpos(10) stem(lst.) trace')\n if lst.0<>11 then,\n   exit Xmsg('*'lst.0 'records retrieved, not 11',20)+Listlst()\n Call ListLst 'Listed 11 records with mask *LIB* in pos 3-10'\n say ''\n\n /*------------------ Delete by mask ---------------------------------*/\n call xmsg '- Delete by mask -'\n cc=RunPgm('delete dd(ksds) mask(*PO-*) list(lst.)')\n if RXVBDELE<>3 then,\n   exit Xmsg('*'rxvbdele+0 'records deleted, not 3',20)+Listlst()\n Call ListLst 'Deleted 3 records with mask *PO-*'\n say ''\n\n\n /*------------------ End ok         ---------------------------------*/\nok:\n Call Rtn 'All ok'\n\nRtn:\n if arg(1)<>'' then say arg(1)\n if arg(2)<>'' then maxrc=word(arg(2) maxrc,1)\n if dela='Y'   then do\n   if Silent(\"Delete\" ksdsds \"cl\")=0 then,\n     say 'Testcl' ksdsds 'deleted'\n   else  say 'Testcl' ksdsds 'delete failed'\n end\n exit xmsg('IVP ended rc' maxrc,maxrc)\n\nRunPgm:\n say time() 'Runpgm' arg(1)\n /*\n parse upper value arg(1) with . ' STEM('s')' .\n if s<>'' then zz=Value(s'0',0)\n */\n parse upper value arg(1) with . ' LISTSTEM('s')' .\n if s<>'' then zz=Value(s'0',0)\n Interpret \"cc=\"pgmname\"('\"arg(1)\"')\"\n call liststat\n if arg(2)='' then return cc\n if cc<>arg(2) then exit xmsg('rc' cc+0 'ne' arg(2),20)\n return cc\n\nListStat:\n say time() 'rc' cc 'reads' rxvbread+0,\n     'writes' rxvbwrit+0 'inserts' rxvbinse+0 'updates' rxvbupdt+0,\n     'deletes' rxvbdele+0 'errmsg \"'space(rxvberrm)'\"'\n return cc\n\nSilent: zz=outtrap(word(arg(2) '$.',1))\n        address tso arg(1);zz=outtrap('off');return rc\n\nXmsg: say time() arg(1);maxrc=word(arg(2) maxrc,1);return word(arg(2) 0,1)\n\nSayError:\n say 'Error' arg(1)\n cc=RexxGblv('rlist var(rxvb*)')\n return 0\n\nListDb:\n if arg(1)<>'' then say arg(1)\n Interpret \"cc=\"pgmname\"('get dd(ksds) stem(lst.)')\"\n if cc<>0 then exit xmsg('listdb rc' cc,99)\n say cols80\n listdbn=lst.0\n Call ListLst 'Database list.....'\n say cols80\n return 0\n\nDBinfo:\n call xmsg 'DB info for DD' arg(1)\n cc=RxVsamBa('info dd('arg(1)')')\n say 'keylen ' RXVBkeyl\n say 'keypos ' RXVBkeyp\n say 'lrecl  ' RXVBrecl\n say 'dbtype ' RXVBdbty\n return 0\n\nListLst:\n if arg(1)<>'' then say arg(1)\n if datatype(lst.0)<>'NUM' then exit ('Bad list',20)\n say lst.0 'records in list'\n if datatype(lst.0)<>'NUM' | lst.0>200 then exit xmsg('*count error',20)\n say '        'cols100\n do n=1 to lst.0\n   say right(n,3,0) right(length(lst.n),3,0) lst.n\n end\n return 0\n\nListStack:\n do queued()\n   parse pull r\n   say r\n end\n return 0\n\nMakeKSDS:\n arg p\n cc=Silent(\"Free dd(ksds)\")\n cc=Silent(\"DELETE\" ksdsds \"cl\")\n \"DEFINE CLUSTER(NAME(\"ksdsds\") VOLUME(\"testvol\")\",\n \"TRACKS(3 3) KEYS(\"dbkeylen \"0) RECORDSIZE(60 200) )\",\n \"DATA(CISZ(4196))\"\n if rc<>0 then do\n   say 'Define failed rc' rc,20\n   exit 20\n end\n \"alloc dd(ksds) da(\"ksdsds\") shr\"\n if rc<>0 then exit xmsg('Alloc test db failed' rc)\n say  'Test cluster allocated to fileref KSDS'\n\n Call MakeTestData\n datan=data.0\n trace off\n /*\n data.0=2\n cc=RxVsamBA('put dd(ksds) stem(data.)')\n if cc<>0 then exit xmsg('Initial write failed rc' cc,20)\n call liststat\n data.0=datan\n */\n cc=RxVsamBA('put dd(ksds) stem(data.)')\n if cc<>0 then exit xmsg('2nd write failed rc' cc,20)\n trace off\n call liststat\n drop data.\n return 0\n if p<>'SILENT' then say qn 'records written to db'\n return 0\n\nMakeTestData:\n queue cols40\n queue 'DOCLIB                            ZXSYS2 PO-E VB            200 32760'\n queue 'ISPF34.LIB                '\n queue 'ISPLLIB                           ZXSYS2 PO         U     27920 27920'\n queue 'ISPMLIB                   '\n data.0=queued()\n do n=1 to data.0\n   parse pull r\n   data.n=r\n end\n return 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXVBIVP1": {"ttr": 6924, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01c\\x008\\x01\\x17\\x05\\x1f\\x01\\x19(?!0\\x02g\\x00\\xed\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.99", "flags": 0, "createdate": "2017-02-20T00:00:00", "modifydate": "2019-10-10T21:30:38", "lines": 615, "newlines": 237, "modlines": 0, "user": "DVL"}, "text": " /*                                                             REXX\n  RXVSAMBA Installation Verification build 022\n */\n parse source sys type whoami ddn whereami .\n address tso\n maxrc=0\n totdel=0\n totins=0\n dbkeylen=25\n cols100= '----+----1----+----2----+----3----+----4',\n       || '----+----5----+----6----+----7----+----8',\n       || '----+----9----+----0'\n cols40=left(cols100,40)\n cols80=left(cols100,80)\n\n arg p\n if p<>'' then say 'Parameters:    ' p\n parse var p . 'PFX('dspfx')' . 0 . 'PGM('pgmname')' .,\n       0 . 'DELA('dela')' . 0 . 'VOL('testvol')' .\n parse var whereami q1'.'\n if dspfx='' then dspfx=userid()\n if pos('.',dspfx)=0 then dspfx=dspfx'.RXVSAMBA'\n ksdsds =\"'\"dspfx\".TEST.KSDS'\"\n rrdsds =\"'\"dspfx\".TEST.RRDS'\"\n if testvol='' then do\n   zz=listdsi('sysexec file')\n   call silent \"listc ent('\"sysdsname\"') vol\"\n   testvol= word(translate(value('$.'$.0),' ','-'),2)\n end\n pgmname=word(pgmname 'RXVSAMBA',1)\n dela   =word(dela    'N',1)\n call xmsg 'Program test specs'\n say 'Dataset prefix..' dspfx\n say 'Test KSDS name..' ksdsds\n say 'Test RRDS name..' rrdsds\n say 'Test volume.....' testvol\n say 'Program name....' pgmname\n say 'Delete-after....' dela\n say ''\n\n /*------------------ Version ----------------------------------------*/\n call xmsg 'Test version'\n cc=RunPgm('version')\n say 'version' RXVBVERS\n say ''\n\n /*------------------ Status -----------------------------------------*/\n call xmsg center('KSDS',70,'-')\n say ''\n Call MakeKSDS     /* setup test data */\n Call DBinfo 'KSDS'\n if RXVBrecl<>200 then Exit Xmsg('*error*, lrecl should be 200',20)\n say ''\n\n call xmsg 'Get all begin'\n cc=RxVsamBa('get dd(ksds) stem(lst.)')\n call xmsg 'Get all ended rc' cc 'returned' lst.0 'records'\n\n Call ListDB 'ListDB before'\n say ''\n\n /*------------------ Get        -------------------------------------*/\n call xmsg 'Test get by key ISP to stem'\n key='ISP'\n drop lst.\n lstn=5\n cc=RunPgm('get dd(ksds) key('key') stem(lst.)')\n if lst.0<>lstn then exit Xmsg('*'0+lst.0 'records read, not' lstn,20) ,\n      + Listlst()\n say  0+lst.0 'records returned as expected'\n Call ListLst\n\n call xmsg 'Test get by key ISP to stack'\n cc=RunPgm('get dd(ksds) key('key') stack')\n if queued()<>lstn then exit Xmsg('*wrong number of records read',20)\n call xmsg queued() 'records returned as expected'\n Call ListStack\n\n say ''\n call xmsg 'Test get by text ZXSYS1 to stem'\n drop lst.\n lstn=6\n cc=RunPgm('get dd(ksds) text(ZXSYS1) pos(30) stem(lst.)')\n if lst.0<>lstn then exit Xmsg('*'0+lst.0 'records read, not' lstn,20) ,\n      + Listlst()\n call xmsg 0+lst.0 'records returned as expected'\n Call ListLst\n\n say ''\n call xmsg 'Test get by key ISP and text ZXSYS2 to stem'\n drop lst.\n lstn=2\n cc=RunPgm('get dd(ksds) key(ISP) text(ZXSYS2) pos(30) stem(lst.)')\n if lst.0<>lstn then exit Xmsg('*'0+lst.0 'records read, not' lstn,20) ,\n      + Listlst()\n call xmsg 0+lst.0 'records returned as expected'\n Call ListLst\n\n call xmsg 'Test get by keylist to stem'\n keyl.1='MSGX'\n keyl.2='CBT'\n keyl.3='YNOTFOUND1'\n keyl.4='YNOTFOUND2'\n keyl.0=4\n do n=1 to keyl.0\n   say '  ->' keyl.n\n end\n drop lst.\n cc=RunPgm('get dd(ksds) keystem(keyl.) stem(lst.)')\n Call ListLst\n if lst.0<>4 then exit Xmsg('*wrong number of records read, not 4',20)\n call xmsg '4 records returned as expected'\n say ''\n\n call xmsg 'Test get by key ISP to stem'\n key='ISP'\n drop lst.\n lstn=5\n cc=RunPgm('get dd(ksds) text(.LOAD) pos(5) endpos(35) stem(lst.)')\n if lst.0<>lstn then exit Xmsg('*'0+lst.0 'records read, not' lstn,20) ,\n      + Listlst()\n call xmsg 0+lst.0 'records returned as expected'\n Call ListLst\n say ''\n\n call xmsg 'Get by text in list by pos 59:'\n getlst.1='  255 27998'; say ' list -> \"'getlst.1'\"'\n getlst.2='  150 32'   ; say ' list -> \"'getlst.2'\"'\n getlst.3='  200 '     ; say ' list -> \"'getlst.3'\"'\n getlst.0=3\n xn      =7 /* expected number of returned records */\n drop lst.\n cc=RunPgm('get dd(ksds) textstem(getlst.) pos(59) stem(lst.)')\n if lst.0<>xn then do\n   say '*'lst.0 'records retrieved, not' xn\n   call Listlst\n   call ListDb 'Db data'\n   exit 20\n end\n call xmsg xn 'records retrieved as expected'\n Call ListLst 'Retrieved records:'\n say ''\n\n /*------------------ PUT --------------------------------------------*/\n call xmsg 'Test PUT'\n Call ListDB 'Before updates'\n upd.1=right( 4,25,0) 'This is an updated record -  1'\n upd.2=right( 6,25,0) 'This is an updated record -  2'\n upd.3=right(10,25,0) 'This is an updated record - 10, some additional data'\n upd.4=right(100,25,0) 'This is a new record - 100, some additional data'\n upd.0=4\n say upd.0 'Updates in stem'\n do n=1 to upd.0\n   say upd.n\n end\n cc=RunPgm('put dd(ksds) stem(upd.) ')\n if cc<>0 then call rtn '**update 1 rc' cc RXVBERRM,20\n if rxvbwrit<>4 then,\n   exit xmsg('**Expected writes: 4, actual:' rxvbwrit+0,20)\n if rxvbinse<>1 then,\n   exit xmsg('**Expected inserts: 1, actual:' rxvbinse+0,20)\n say ''\n Call ListDB 'After updates by stem'\n say ''\n\n Call MakeKSDS 'silent'\n queue right(11,25,0) 'This is an updated record - 11'\n queue right(12,25,0) 'This is an updated record - 12'\n queue right(25,25,0) 'This is an inserted record - 25, some additional data'\n\n say  queued() 'records in stack'\n cc=RunPgm('put dd(ksds) stack')\n if cc<>0 then call rtn '**update 1 rc' cc RXVBERRM,20\n if rxvbwrit<>3 then,\n   exit xmsg('**Expected writes: 3, actual:' rxvbwrit+0,20)\n if rxvbinse<>1 then,\n   exit xmsg('**Expected inserts: 1, actual:' rxvbinse+0,20)\n say ''\n Call ListDB 'After updates by stack'\n say ''\n\n /*------------------ INSERT -----------------------------------------*/\n call xmsg 'Test INSERT'\n Call MakeKSDS 'silent'\n ins.1='CBT.CNTL.INSERT              I-STEM PO   FB       80 27920'\n ins.2='LINKLIB.INSERT               I-STEM PO   U     27998 32756'\n ins.3='TOOLBOX.LIB.OLD.INSERT       I-STEM PO   FB       80 27920'\n ins.4='WSA4.MENU.INSERT             I-STEM PO-E VB      150 32760'\n ins.0=4\n say 'Inserting' ins.0 'records from stem'\n cc=RunPgm('insert dd(ksds) stem(ins.) ')\n if RXVBINSE<>ins.0 then ,\n   exit Xmsg('*wrong number of records inserted' 0+rxvbinse', not' 0+ins.0,20)\n say RXVBINSE+0 'records inserted as expected'\n say ''\n Call ListDB 'After inserts by stem'\n say ''\n\n Call MakeKSDS 'silent'\n queue 'ZCBT.CNTL.INSERT             I-STACK PO   FB       80 27920'\n queue 'ZLINKLIB.INSERT              I-STACK PO   U     27998 32756'\n queue 'ZTOOLBOX.LIB.OLD.INSERT      I-STACK PO   FB       80 27920'\n queue 'ZWSA4.MENU.INSERT            I-STACK PO-E VB      150 32760'\n qn=queued()\n call xmsg 'Inserting' qn 'records from stack'\n cc=RunPgm('insert dd(ksds) stack ')\n if RXVBINSE<>qn then exit Xmsg('*wrong number of records inserted',20)\n call xmsg RXVBINSE+0 'records inserted as expected'\n say ''\n\n /*------------------ Add/update by value-----------------------------*/\n call xmsg 'Test add by value'\n val=left('MSGX.LINKLIB2',44) 'added by value'\n cc=RunPgm('Put dd(ksds) value('val')')\n if RXVBINSE<>1 then exit Xmsg('*number of records inserted not 1',20)\n call xmsg 'Test update by value'\n val=left('MSGX.LINKLIB',44) 'updated by value'\n cc=RunPgm('Put dd(ksds) val('val')')\n if RXVBUPDT<>1 then exit Xmsg('*number of records updated not 1',20)\n say ''\n\n Call ListDB 'After add/inserts by stack and value'\n say ''\n\n /*------------------ Delete          --------------------------------*/\n call xmsg 'Delete by key WSA4.'\n Call MakeKSDS 'silent'\n cc=RunPgm('delete dd(ksds) key(WSA4.) list(lst.) ')\n deln=4                   /* expected no of deletes */\n if RXVBDELE<>deln then,\n   exit Xmsg('*'0+rxvbdele 'records deleted, not' deln,20)\n say deln 'records deleted as expected'\n Call ListLst 'records deleted:'\n Call ListDb\n say ''\n\n call xmsg 'Delete by text:'\n Call MakeKSDS 'silent'\n cc=RunPgm('delete dd(ksds) text(.LOAD) pos(5) endpos(35) list(lst.)')\n deln=5                   /* expected no of deletes */\n if RXVBDELE<>deln then,\n   exit Xmsg('*'0+rxvbdele 'records deleted, not' deln,20)\n call xmsg '10 records deleted as expected'\n Call ListLst 'records deleted:'\n say ''\n\n call xmsg 'Delete by data in list by pos 59:'\n Call MakeKSDS 'silent'\n dellst.1='  255 27998'; say ' delete ->' dellst.1\n dellst.2='  200 27800'; say ' delete ->' dellst.2\n dellst.0=2\n delxn   =4 /* expected number of deletes */\n cc=RunPgm('delete dd(ksds) textstem(dellst.) pos(59) list(lst.)')\n if RXVBDELE<>delxn then,\n   exit Xmsg('*wrong number of records deleted, not' delxn,20) + ListDb()\n call xmsg delxn 'records deleted as expected'\n Call ListLst 'Deleted records:'\n Call ListDb\n say ''\n\n /*------------------ Pull records   ---------------------------------*/\n call xmsg 'Pull records with key WSA4.'\n Call MakeKSDS 'silent'\n drop lst.\n cc=RunPgm('pull dd(ksds) key(WSA4.) stem(lst.)')\n xn=4\n if rxvbdele<>xn then,\n   exit Xmsg('*delete count is' 0+rxvbdele', not' xn,20) + Listlst()\n if lst.0<>xn then,\n   exit Xmsg('*'0+lst.0 'records pulled, not' xn,20) + Listlst()\n Call ListLst 'Records pulled:'\n say ''\n\n call xmsg 'Pull by text in list by pos 59:'\n drop getlst. lst.\n Call MakeKSDS 'silent'\n getlst.1='  255 27998'; say ' list -> \"'getlst.1'\"'\n getlst.2='  150 32'   ; say ' list -> \"'getlst.2'\"'\n getlst.0=2\n xn   =4 /* expected number of returned records */\n cc=RunPgm('pull dd(ksds) textstem(getlst.) pos(59) stem(lst.)')\n if lst.0<>xn then,\n   exit Xmsg('*'lst.0 'records retrieved, not' xn,20)+Listlst()\n Call ListLst 'Retrieved records:'\n say ''\n\n /*------------------ Get with mask  ---------------------------------*/\n drop lst.\n call xmsg '- Get keyed with mask -'\n cc=RunPgm('get dd(ksds) key(M) mask(*.CNT*) pos(2) endpos(16)',\n           'stem(lst.) ')\n if lst.0<>2  then,\n   exit Xmsg('*'lst.0 'records retrieved, not 2 ',20)+Listlst()\n Call ListLst 'List key(M) mask(*.CNT*) pos(2) endpos(16)'\n say ''\n drop lst.\n\n call xmsg '- Get sequential with mask -'\n cc=RunPgm('get dd(ksds) mask(*LIB*) pos(03) endpos(10) stem(lst.) ')\n if lst.0<>11 then,\n   exit Xmsg('*'lst.0 'records retrieved, not 11',20)+Listlst()\n Call ListLst 'Listed 11 records with mask *LIB* in pos 3-10'\n say ''\n\n /*------------------ Delete by mask ---------------------------------*/\n call xmsg '- Delete by mask -'\n cc=RunPgm('delete dd(ksds) mask(*PO-*) list(lst.)')\n if RXVBDELE<>3 then,\n   exit Xmsg('*'rxvbdele+0 'records deleted, not 3',20)+Listlst()\n Call ListLst 'Deleted 3 records with mask *PO-*'\n say ''\n\n /*------------------ Get with trace ---------------------------------*/\n call xmsg '- Get with trace -'\n cc=RunPgm('get dd(ksds) key(WFM) stem(lst.) trace')\n say ''\n /* sequential\n cc=RunPgm('get dd(ksds) stem(lst.) trace')\n say ''        */\n\n /*------------------ Invalid comand ---------------------------------*/\n call xmsg '- invalid command -'\n cc=RunPgm('zet dd(ksds) key(WFM) stem(lst.)',12)\n cc=RunPgm('del dd(ksds) textstem(dsns.) start(21) stem(dbl.)',12)\n say ''\n Call Silent(\"free dd(ksds)\")\n say ''\n\n /*------------------ RRDS make DB -----------------------------------*/\n call xmsg center('RRDS',70,'-')\n say ''\n call xmsg 'Make RRDS db' rrdsds\n Call Silent \"DELETE\" rrdsds\n             \"DEFINE CLUSTER(NAME(\"rrdsds\")\",\n             \"RECORDSIZE(100 100) TRACKS(3) VOL(\"testvol\") NUMBERED)\"\n if rc<>0 then exit xmsg('Define failed rc' rc ,8)\n\n cc=BpxWdyn(\"alloc dd(rrds) da(\"rrdsds\") old reuse\")\n if cc<>0 then exit xmsg('Allocate failed rc' cc ,8)\n\n Call DBinfo 'rrds'\n\n call xmsg 'Load DB'\n queue 'Doctor Who is a British science-fiction television programme'\n queue 'produced by the BBC from 1963 to the present day. The programme'\n queue 'depicts the adventures of the Doctor, a Time Lord a time-travelling'\n queue 'humanoid alien. He explores the universe in his TARDIS, a sentient'\n queue 'time-travelling space ship. Its exterior appears as a blue British'\n queue 'police box, which was a common sight in Britain in 1963 when the'\n queue 'series first aired. Along with a succession of companions, the'\n queue 'Doctor combats a variety of foes while working to save civilisations'\n queue 'and help people in need.'\n db.0=     queued()\n do n=1 to queued()\n   parse pull r\n   db.n=right(n,8,0)r\n end\n cc=RunPgm('put dd(rrds) stem(db.)',0)\n if cc<>0 then exit 20\n say rxvbinse+0 'record added to db'\n\n /*------------------ RRDS get   -------------------------------------*/\n call xmsg 'RRDS get all'\n cc=RunPgm('get dd(rrds) stem(lst.) ',0)\n say 'Get all rc' cc 'returned' lst.0 'records'\n Call ListLst\n if lst.0<>9 then exit xmsg('Should have been 9 records')\n drop lst.\n\n call xmsg 'Get #6-8'\n cc=RunPgm('get dd(rrds) stem(lst.) key(6) to(8)',0)\n say 'Get #6-8 rc' cc 'returned' lst.0 'records'\n Call ListLst\n if lst.0<>3 then exit xmsg('Should have been 3 records')\n drop lst.\n\n call xmsg 'Get #8,6,4,2 using list'\n parse value '4 8 6 4 2' with ks.0 ks.1 ks.2 ks.3 ks.4\n cc=RunPgm('get dd(rrds) stem(lst.) keystem(ks.)',0)\n call xmsg 'Get #8,6,4,2 rc' cc 'returned' lst.0 'records'\n Call ListLst\n if lst.0<>4 then exit xmsg('Should have been 4 records')\n say ''\n\n /*------------------ RRDS put   -------------------------------------*/\n\n drop lst. upd. new.\n upd.1= '00000002 record #2 updated'\n upd.0= 1\n call xmsg 'Upd record #2'\n cc=RunPgm('put dd(rrds) stem(upd.)',0)\n call xmsg 'Upd record #2 updated'\n\n call xmsg 'Add records #11, 13 and 15'\n new.1= '00000011 record #11 added'\n new.2= '00000013 record #13 added'\n new.3= '00000015 record #15 added'\n new.0= 3\n cc=RunPgm('put dd(rrds) stem(new.) ',0)\n if rxvbinse<>3 then exit xmsg('Insert value should have been 3')\n\n call xmsg 'Add record #16 using INSERT'\n new.1= '00000016 record #16 INSERTed'\n new.0= 1\n cc=RunPgm('insert dd(rrds) stem(new.) ',0)\n if rxvbinse<>1 then exit xmsg('Insert value should have been 1')\n\n cc=RunPgm('put dd(rrds) value(00000019This is inserted by value)',0)\n if rxvbinse<>1 then exit xmsg('Insert value should have been 1')\n\n /* list and test bypass empty slots */\n cc=RunPgm('get dd(rrds) stem(lst.) key(1) to(20)',0)\n Call ListLst\n if lst.0<>14 then exit xmsg('Should have been 14 records')\n say ''\n\n /*------------------ V023 - dynamic allocation ----------------------*/\n say 'V023 - dynamic allocation'\n Call Silent 'lista st','la1.'\n cc=RunPgm('get da('strip(rrdsds,\"b\",\"'\")') stem(lst.) ',0)\n say 'Get all rc' cc 'returned' lst.0 'records'\n if rxvbread<>14 then call rtn 'Wrong # of records read' rxvbread+0,\n   'expected 14',8\n Call Silent 'lista st','la2.'\n mm=0\n do n=0 to max(la1.0,la2.0) while mm=0\n   mm=(la1.n<>la2.n)\n end\n if mm then do\n   say 'Lista missmatch'\n   say 'Before..'\n   do n=1 to la1.0\n     say la1.n\n   end\n   say 'Before..'\n   do n=1 to la1.0\n     say la1.n\n   end\n   Call rtn 'Failed'\n end\n say ''\n\n /*------------------ End ok         ---------------------------------*/\nok:\n Call Rtn 'All ok'\n\nRtn:\n if arg(1)<>'' then say arg(1)\n if arg(2)<>'' then maxrc=word(arg(2) maxrc,1)\n if dela='Y'   then do\n   if Silent(\"Delete\" ksdsds \"cl\")=0 then,\n     say 'Testcl' ksdsds 'deleted'\n   else  say 'Testcl' ksdsds 'delete failed'\n end\n exit xmsg('IVP ended rc' maxrc,maxrc)\n\nRunPgm:\n say time() 'Runpgm' arg(1)\n /*\n parse upper value arg(1) with . ' STEM('s')' .\n if s<>'' then zz=Value(s'0',0)\n */\n parse upper value arg(1) with . ' LISTSTEM('s')' .\n if s<>'' then zz=Value(s'0',0)\n Interpret \"cc=\"pgmname\"('\"arg(1)\"')\"\n call liststat\n if arg(2)='' then return cc\n if cc<>arg(2) then exit xmsg('rc' cc+0 'ne' arg(2),20)\n return cc\n\nListStat:\n say time() 'rc' cc 'reads' rxvbread+0,\n     'writes' rxvbwrit+0 'inserts' rxvbinse+0 'updates' rxvbupdt+0,\n     'deletes' rxvbdele+0 'errmsg \"'space(rxvberrm)'\"'\n return cc\n\nSilent: zz=outtrap(word(arg(2) '$.',1))\n        address tso arg(1);zz=outtrap('off');return rc\n\nXmsg: say time() arg(1);maxrc=word(arg(2) maxrc,1);return word(arg(2) 0,1)\n\nSayError:\n say 'Error' arg(1)\n cc=RexxGblv('rlist var(rxvb*)')\n return 0\n\nListDb:\n if arg(1)<>'' then say arg(1)\n Interpret \"cc=\"pgmname\"('get dd(ksds) stem(lst.)')\"\n if cc<>0 then exit xmsg('listdb rc' cc,99)\n say cols80\n listdbn=lst.0\n Call ListLst 'Database list.....'\n say cols80\n return 0\n\nDBinfo:\n call xmsg 'DB info for DD' arg(1)\n cc=RxVsamBa('info dd('arg(1)')')\n say 'keylen ' RXVBkeyl\n say 'keypos ' RXVBkeyp\n say 'lrecl  ' RXVBrecl\n say 'dbtype ' RXVBdbty\n return 0\n\nListLst:\n if arg(1)<>'' then say arg(1)\n if datatype(lst.0)<>'NUM' then exit ('Bad list',20)\n say lst.0 'records in list'\n if datatype(lst.0)<>'NUM' | lst.0>200 then exit xmsg('*count error',20)\n say '        'cols100\n do n=1 to lst.0\n   say right(n,3,0) right(length(lst.n),3,0) lst.n\n end\n return 0\n\nListStack:\n do queued()\n   parse pull r\n   say r\n end\n return 0\n\nMakeKSDS:\n arg p\n cc=Silent(\"Free dd(ksds)\")\n cc=Silent(\"DELETE\" ksdsds \"cl\")\n \"DEFINE CLUSTER(NAME(\"ksdsds\") VOLUME(\"testvol\")\",\n \"TRACKS(3 3) KEYS(\"dbkeylen \"0) RECORDSIZE(60 200) )\",\n \"DATA(CISZ(4196))\"\n if rc<>0 then do\n   say 'Define failed rc' rc,20\n   exit 20\n end\n \"alloc dd(ksds) da(\"ksdsds\") shr\"\n if rc<>0 then exit xmsg('Alloc test db failed' rc)\n say  'Test cluster allocated to fileref KSDS'\n\n Call MakeTestData\n datan=data.0\n trace off\n /*\n data.0=2\n cc=RxVsamBA('put dd(ksds) stem(data.)')\n if cc<>0 then exit xmsg('Initial write failed rc' cc,20)\n call liststat\n data.0=datan\n */\n cc=RxVsamBA('put dd(ksds) stem(data.)')\n if cc<>0 then exit xmsg('2nd write failed rc' cc,20)\n trace off\n call liststat\n drop data.\n return 0\n if p<>'SILENT' then say qn 'records written to db'\n return 0\n\nMakeTestData:\n queue cols40\n queue 'AUTO.LOAD                         ZXSYS2 PO         U         0 23200'\n queue 'AXR.EXEC                          ZXSYS2 PO         VB      255 27998'\n queue 'CBT.CNTL                          ZXSYS2 PO         FB       80 27920'\n queue 'CBT.OBJ                           ZXSYS2 PO         FB       80  3040'\n queue 'DOCLIB                            ZXSYS2 PO-E VB            200 32760'\n queue 'EXEC.XMIT                         ZXSYS1                             '\n queue 'ICFCAT.BACKUPS            '\n queue 'ISPF.CNTL                         ZXSYS2 PO         VB     1024 27998'\n queue 'ISPF34.LIB                '\n queue 'ISPLLIB                           ZXSYS2 PO         U     27920 27920'\n queue 'ISPMLIB                   '\n queue 'ISPPLIB.XMIT                      ZXSYS1                             '\n queue 'JOBLIB.DATA                       ZXSYS2 PO         FB       80  9040'\n queue 'LINKLIB                           ZXSYS2 PO         U     27998 32756'\n queue 'LOCMBR.CNTL                       ZXSYS2 PO         FB       80 27920'\n queue 'LOCMBR.LOAD                       ZXSYS2 PO         U         0 23200'\n queue 'MIGRTOOL.ZFS.JOB          '\n queue 'MIGRTOOL.ZFS.LOAD                 ZXSYS1                             '\n queue 'MODEL.CNTL.LIB                    ZXSYS2 PO         FB       80  4080'\n queue 'MODEL.LIB                         ZXSYS2 PO         FB       80  4080'\n queue 'MPF.CNTL                  '\n queue 'MSGX.LINKLIB                      ZXSYS2 PO         U         0 32756'\n queue 'MSGX3.LOAD.OLD            '\n queue 'PDSXLOAD                  '\n queue 'PKG0002.DATA                      ZXSYS2 PO         FB       80  3120'\n queue 'PRD.LOAD                  '\n queue 'PROFICS.VSAVE                     ZXSYS1 PS         VB    23400 27998'\n queue 'SYSREXX.EXEC                      ZXSYS2 PO         VB      255 27998'\n queue 'TOOLBOX.LIB                       ZXSYS2 PO         FB       80 27920'\n queue 'TOOLBOX.LIB.OLD                   ZXSYS2 PO         FB       80 27920'\n queue 'TOOLBOX.SMALLSMS.CNTL             ZXSYS2 PO         FB       80 27920'\n queue 'WFM.LIB                   '\n queue 'WFM3.LIB                          ZXSYS2 PO         FB       80 27920'\n queue 'WLM.SYSDISK.DATEFILE              ZXSYS1 PS         FB      200 27800'\n queue 'WLM.USERDISK.DATEFILE             ZXSYS1 PS         FB      200 27800'\n queue 'WSA4.CKPT                         ZXSYS2 PS         FB    27900 27900'\n queue 'WSA4.MENU                         ZXSYS2 PO-E VB            150 32760'\n queue 'WSA4.MENU.OLD                     ZXSYS2 PO-E VB            250 32760'\n queue 'WSA4.PROC                         ZXSYS2 PO-E VB            150 32720'\n queue 'ZAUTO.EXEC                        ZXSYS2 PO         FB       80 27920'\n queue 'ZBOX.LIB                          ZXSYS2 PO         FB       80 27920'\n queue 'ZCBT.JCLLIB                       ZXSYS2 PO-E FB             80  6160'\n queue 'ZCBT.LOADLIB                      ZXSYS2 PO         U         0 32760'\n queue 'Z113.VTAMLST                      ZXSYS2 PO         FB       80 27920'\n cols=cols100 || cols100\n n=0\n do m=1 to 30 by 2\n   n=n+1\n   queue right(n,25,0)left(cols,m*2)\n end\n data.0=queued()\n do n=1 to data.0\n   parse pull r\n   data.n=r\n end\n return 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXVBMACS": {"ttr": 7176, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1c\\x00\\x16\\x01\\x17\\x05\\x1f\\x01\\x184_\\x115\\x00\\xa0\\x00\\xac\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.28", "flags": 0, "createdate": "2017-02-20T00:00:00", "modifydate": "2018-12-11T11:35:16", "lines": 160, "newlines": 172, "modlines": 0, "user": "DVL"}, "text": "*-\n* macros for RXVSAMBA\n* latest update for build 015\n*-\n\n         Macro\n         ICall &n\n         l     r15,=a(&n)\n         balr  r14,r15\n         ltr   r15,r15\n         Mend\n\n         Macro\n         @NZ   &nz\n         gblc  &iexit\n         aif   (k'&nz eq 0).x\n&unz     setc  Upper('&nz')\n         aif   ('&unz' eq 'EXIT').exit\n         aif   ('&unz' eq 'LEAVE').leave\n         mnote 8,'Invalid nz: &nz '\n         mexit\n.exit    mnote *,'------------- @nz begin           --------------'\n         if    (nz)\n           #subr exit,rc=8\n         endif\n         mexit\n.leave   mnote *,'@nz -> leave'\n         if    (nz),then=leave\n.x       anop\n         mnote *,'------------- @nz end             --------------'\n         Mend\n\n         Macro\n         VSAM  &what,&nz=\n         lclc  &uw,&unz\n&uw      setc  Upper('&what')\n&unz     setc  Upper('&nz')\n         aif   ('&what' eq 'STAT').byname\n         lr    r0,r15\n.byname  l     r15,=V(VSAM&uw)\n         balr  r14,r15\n         ltr   r15,r15\n         @NZ   &nz\n.x       Mend\n\n         Macro\n         Countup &f,&value=1\n         ap    &f,=p'&value'\n         Mend\n\n         Macro\n         TestText\n*        TestText begin\n         la    r1,1                    default=ok\n         if    (cli,text_dl,ne,0)\n.*         if    (cli,ptrace,eq,c'Y'),then=(log,'testtext')\n.* compute endpos, test for short record\n           if    (icm,r15,15,endpos,nz)\n             la    r15,1(,r15)         compute\n             s     r15,pos               length\n           else\n             l     r15,vsbfr1dl        use record length\n           endif\n           sr    r14,r14\n           ic    r14,text_dl\n           a     r14,pos\n           sr    r1,r1                 default = bad length = not ok\n           if    (cr,r14,le,r15)       record length ok\n             l     r14,pos\n             la    r14,vsbfr1-1(r14)\n.*           if    (cli,ptrace,eq,c'Y')\n.*             stm   r2,r3,dw\n.*             stm   r14,r15,dw2\n.*             lr    r2,r14\n.*             lr    r3,r15\n.*             StrMake logr,'data \"',((r2),(r3)),'\"'\n.*             log   ,\n.*             lm    r2,r3,dw\n.*             lm    r14,r15,dw2\n.*           endif\n*            strpos begin\n             StrPos (text,b.text_dl),((r14),(r15))\n*            strpos end\n.*         else\n.*           if    (cli,ptrace,eq,c'Y'),then=(log,'shortrec')\n           endif\n         endif\n.*\n.*       if    (cli,ptrace,eq,c'Y')\n.*         if    (ltr,r2,r1,nz)\n.*           log   'ok'\n.*         else\n.*           log   'nok'\n.*         endif\n.*         lr    r1,r2\n.*       endif\n*        TestText end\n         Mend\n\n         Macro\n.* TrcBlk / TrcBlkEnd is used around larger trace blocks. This\n.* cuts down on the number of instructions executed.\n         TrcBlk\n         gblc  &trcblka\n         aif   ('&trcblka' eq '').go\n         mnote 8,'***trcblka ne null'\n         mexit\n.go      anop\n&trcblka setc  'TB&sysndx.END'\n         cli   ptrace,c'Y'\n         jne   &trcblka\n         Mend\n\n         Macro\n         TrcBlkEnd\n         gblc  &trcblka\n&trcblka ds    0h\n&trcblka setc  ''\n         Mend\n\n         Macro\n         SetRc &n\n         $la   r0,&n\n         st    r0,rc\n         Mend\n\n         Macro\n         Trace &t,&lr=,&l=\n         lclc  &cl,&lbl\n&cl      setc  '&l'\n&lbl     setc  'TR&sysndx'\n         lcla  &n\n         cli   ptrace,c'Y'\n         jne   &lbl.x\n         aif   (k'&t eq 0).go\n         mvlit logr,&t,lr=r0\n&cl      setc  '(r0)'\n.go      aif   (k'&cl gt 0).say\n&cl      setc  'l''logr'\n.say     RxSay logr,&cl\n         clear logr\n&lbl.x   equ   *\n         Mend\n\n*- errmsg\n         Macro\n.* t   text in quotes\n.* c   return code, set in field RC\n.* p   'T'  copy to log field, run TRCLOG macro\n         SetErr &t,&c,&p\n         lcla  &l\n&l       seta  k'&t-2\n         mvc   errmsg(&l),=c&t\n         mvc   errmsgl,=a(&l)\n         aif   (k'&c eq 0).x\n         mvc   rc,=a(&c)\n         aif   ('&p' ne 'T' and '&p' ne 't').x\n         mvc   logr,errmsg\n         trace l=&l\n.x       Mend\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXVBRDME": {"ttr": 7180, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Q\\x01\\x193\\x8f\\x01\\x193\\x8f\\x10F\\x00\\x0b\\x00\\x0b\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-12-04T00:00:00", "modifydate": "2019-12-04T10:46:51", "lines": 11, "newlines": 11, "modlines": 0, "user": "DVL"}, "text": "Description of members:\n\n RXVSAMBA  Product, edit and run this member.\n RXVBDOC   Documentation.\n RXVBHIST  Product history.\n RXVBIVPx  IVPs\n RXVBMACS  Local macros.\n SYSMACS   ASM copy book containing combined non-IBM macros.\n REXXMACS  ASM copy book containing my macros for interfacing with REXX.\n WSAMMACS  ASM copy book containig my structured assembler macro set.\n           The macros are equivalent but not identical to IBM's macros.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXVSAMBA": {"ttr": 7425, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01c\\x008\\x01\\x18\"O\\x01  O\\x14T\\x07\\x02\\x06G\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.99", "flags": 0, "createdate": "2018-08-12T00:00:00", "modifydate": "2020-07-22T14:54:38", "lines": 1794, "newlines": 1607, "modlines": 0, "user": "DVL"}, "text": "//RXVB026  JOB (1),'vsam-bulkaccess-026',\n//*    RESTART=IVP1,\n//             CLASS=A,COND=(0,LT),TIME=(1),REGION=64M\n//*\n// SET IVP=1\n//* ?? RXVSAMBA - VSAM bulk access from REXX ? e ?\n/*JOBPARM L=9999\n//*\n//*** Build 026\n//***\n//*** Warning:\n//*** Build 015 Redefines the use of operands LIST(name) and\n//***           KEYSTEM(name).\n//***      -    Changes the FILTER(name) operand to\n//***           TEXTSTEM(name).\n//***      -    Redefines the use for the RXVBWRIT variable\n//*\n//A  EXEC ASMACL,PARM.C='TERM,RENT',\n//             PARM.L='LIST,RENT,REUS,REFR,RMODE(ANY)'\n//C.SYSLIB  DD DISP=SHR,DSN=SYS1.MACLIB\n//          DD DISP=SHR,DSN=SYS1.MODGEN\n//          DD DISP=SHR,DSN=CBT669.LIB\n//C.SYSTERM DD SYSOUT=*\n//C.SYSIN   DD *\n**asma syslib *\n**asma opt    term\n         lclc  &vsrclog,&section,&sectid,&name,&vers,&s,&jpaq\n&jpaq    setc  'N'                     Do not keep module in the JPAQ\n&jpaq    setc  'Y'                     Keep module in the JPAQ\n&vsrclog setc  'N'\n&name    setc  'RXVSAMBA'\n&vers    setc  '026'\n*\n*-\n* Register usage\n*\n* 12     base for top routine (scheduler etc)\n* 11     base for functional routines (GET.. PUT.. etc)\n* 10     base for global dynamic work area\n*  9     base for sub-functions (STEMGET STEMPUT etc)\n*-\n* Changes in this build - see member RVVBHIST for full list\n*\n*  Changed\n*   none\n*\n*  New\n*   none\n*\n*  Fixed\n*   Possible filter (MASK parameter) error\n*\n* Installation notes\n*\n*   The  program may  be  set  to reload  itself  thus retaining  the\n*  module in the  JPAQ. This improves performance  for multiple calls\n*  significantly. This load will not be  done if the program is added\n*  to the LPA, which is the recommended placement.\n*   Enable  the   self-load  option  by  setting the &JPAQ variable\n*  to 'Y'.\n*-\n\n         print off\n         Copy  WsamMacs\n         Copy  RexxMacs\n         Copy  SysMacs\n         Copy  RXVBMacs\n*        COPY  Z10MACS\n         print on\n\n*-\n*\n* VSAM  bulk access\n*\n*-\n*\n* Syntax, see the RXVBDOC member\n         #subr set,entry=csect,base=r11,saend=@@@saend\nRXVSAMBA #module base=(r12),text='&vers',                              c\n               work=($wrkl,$wrk,r10,C),sa=@@@sa,                       c\n               xprolog=prolog,xepilog=epilog\n         if    (ltr,r15,r15,nz)           prolog ok?\n           #module exit\n         endif\n\n         zap   sanum,=p'0'\n\n*-\n* Keep module in JPAQ for duration of job / TSO session\n*-\n         aif   ('&jpaq' ne 'Y').jpaqn\n         CDEUCTZ2\n.jpaqn   anop\n\n* some functions do not require a libref\n* i.e. RXVSAMBA.022 01/26/19 14.12\n         if    (=c'VER',eq,function)\n           la    r2,verinfo\n           la    r3,l'verinfo\n           stm   r2,r3,retval\n           #module exit,rc=0\n         endif\n*-\n* handle allocation\n*-\n         if    (cli,da,ne,c' ')\n           clear alcbfr1\n           mvc   alcbfr2,alcbfr1\n           strmake alcbfr1+2,'Alloc SHR Dsn(',(da,b.da_dl),')',        c\n               lenreg=r2\n           sth   r2,alcbfr1\n           mvlit alcbfr2+2,'RTDDN'\n           mvc   alcbfr2(2),=y(9)\n           if    (cli,ptrace,eq,c'Y')\n             strmake tracerec,(alcbfr1+2,(r2))\n             trace ,(r2)\n           endif\n           la    r14,alcbfr1\n           la    r15,alcbfr2\n           sr    r0,r0\n           Link  EP=BPXWDYN,param=((r14),(r15)),VL=1,mf=(E,alcpl)\n           st    r15,fw\n           if    (ltr,r15,r15,z)\n             mvc   dd,alcbfr2+2\n             mvc   dd_dl,alcbfr2+1\n             trace 'Ok'\n           else\n             seterr 'alloc failure',12\n             mvi   da,c' '\n             #module exit,rc=12\n           endif\n         endif\n         if    (cli,dd,eq,c' '),and,(cli,da,eq,c' ')\n           mvc   dd,=cl8'VSAM'\n         endif\n*-\n* determine which function to run\n*-\n         if     (cli,enq_dl,ne,0)     do enqueue\n           la    r2,=cl8'RXVSAMBA'\n           lb    r3,enq_dl\n           la    r4,dd\n           j     enqm\nenqd       ENQ   (0,0,E,0,SYSTEMS),ret=HAVE,mf=L\nenqm       mvc   wrk256(enqm-enqd),enqd\n           ENQ   ((2),(4),E,(3),SYSTEMS),ret=HAVE,mf=(E,wrk256)\n         endif\n\n* load list\n         if    (cli,textstem_dl,ne,0)\n           la    r0,txtlstad\n           la    r1,textstem_dl\n           ICall stmcpymk              go make internal copy\n         endif\n\n* info\n         if     (=c'INFO ',eq,function)\n           ICall Info\n* get\n         elseif (=c'GET ',eq,function)\n           if    (cli,stem_dl,eq,0),and,(cli,pstack,ne,c'Y')\n             seterr 'Data target missing',12\n           elseif (cli,key_dl,ne,0),or,(cli,keyvar_dl,ne,0)\n             ICall GetKey\n           elseif (cli,pkeystem_dl,ne,0)\n             ICall GetKeyl\n           else\n             ICall GetTxt               really = ALL\n           endif\n* delete\n         elseif (=c'DEL',eq,function),or,(=c'PULL ',eq,function)\n           if     (cli,key_dl,ne,0)\n             ICall DelKey               delete by key\n           elseif (cli,pkeystem_dl,ne,0)\n             ICall DelKeyl              delete sequential\n           elseif (cli,mask_dl,ne,0)\n             ICall DelTxt               delete by mask\n           elseif (cli,text_dl,ne,0)\n             ICall DelTxt    txt        delete by text\n           elseif (cli,textstem_dl,ne,0)\n             ICall DelTxt               delete by text in stem\n           else\n             seterr 'Delete cmd error',12,t\n           endif\n* write\n         elseif (=c'PUT ',eq,function),and,(cli,value_dl,ne,0)\n           ICall PUTVAL\n         elseif (=c'PUT ',eq,function)\n           ICall PUT\n         elseif (=c'INS',eq,function)\n           ICall INSERT\n         else\n           seterr 'Cmd error',12,t\n         endif\n\n         #module exit\n*\n*---------------------------------------------------------------------*\n*\nacb1m    ACB   DDNAME=VSAM,RMODE31=ALL\nacb1ml   equ   *-acb1m\n         ds    xl40\nrpl1m    RPL   acb=0 Acb1\nrpl1ml   equ   *-rpl1m\n         ds    xl40\nacbopnm  open  0,mf=L\nacbopnml equ   *-acbopnm\n*\n*---------------------------------------------------------------------*\n*\nzero     dc    a(0)\nverinfo  dc    c'&name..&vers &sysdatc &systime'\n* i.e. RXVSAMBA.022 01/26/19 14.12\n*\n*---------------------------------------------------------------------*\n*\n         ltorg\n\n*---------------------------------------------------------------------*\n*                        trace major values                           *\n*---------------------------------------------------------------------*\nTrace1   #subr\n         st    r12,fw\n         StrMake logr,'epa ',(fw,4,cvxd),                              c\n               ' function ',function,                                  c\n               ' key_dl ',(key_dl,1,cvd),                              c\n               ' stem_dl ',(stem_dl,1,cvd),                            c\n               ' list_dl ',(list_dl,1,cvd),                            c\n               ' text_dl ',(text_dl,1,cvd),                            c\n               ' pos ',(pos,4,cvd,4),                                  c\n               ' endpos ',(endpos,4,cvd,4),lr=r0\n         trace ,(r0)\n         #subr exit,rc=0\n         #subr drop\n\n*---------------------------------------------------------------------*\n*              parse parameters                                       *\n*---------------------------------------------------------------------*\nProlog   #subr\n         clear blank\n         mvc   logr,blank\n         mvc   errmsg,blank\n         l     r1,=a(vsbfr1-$wrk)\n         ar    r1,r10\n         st    r1,vsbfr1a\n         l     r1,=a(vsbfr2-$wrk)\n         ar    r1,r10\n         st    r1,vsbfr2a\n         clear tracerec\n         la    r3,pl4\n         do    from=(r2,pl4num)\n           zap   0(4,r3),=p'0'\n           la    r3,4(,r3)\n         enddo\n         mvc   dd,blank\n         mvc   stem,blank\n         mvc   pkeystem,blank\n         mvc   list,blank\n         mvc   key,blank\n         mvc   text,blank\n         mvi   acb1stat,c' '\n         mvc   vsbfr1l,=a(l'vsbfr1)\n         mvc   vsbfr2l,=a(l'vsbfr2)\n         mvc   acb1(acb1ml),acb1m\n         mvc   rpl1(rpl1ml),rpl1m\n         mvc   acbopn(acbopnml),acbopnm\n*\n         ereg  0,1\n         RxInit parmlist=((parmstr,120))\n*\n         StrParse (parmstr,l'parmstr),                                 +\n               (#p,function,l=8,c=u),             1st pos = function   c\n               (igndup,pigndup,c=u,l=1),                               +\n               (trace,ptrace,c=u,l=1),                                 +\n               (dd,dd,v=a,c=u,l=8),                                    +\n               (da,da,v=a,c=u,l=44),                                   +\n               (enq,enq,v=a,c=u,l=16),                                 +\n               (stem,stem,v=a,c=u,l=120),                              +\n               (stack,pstack,c=u,l=1),                                 +\n               (keystem,pkeystem,v=a,c=u,l=120),                       +\n               (keyvar,keyvar,v=a,c=u,l=120),                          +\n               (list,list,v=a,c=u,l=120),                              +\n               (key,key,l=120),                                        +\n               (value,value,l=120,a=3),                                +\n               (mask,mask,l=60),                  v019                 +\n               (text,text,l=120),                                      +\n               (textstem,textstem,v=a,c=u,l=120),                      +\n               (pos,pos,v=n,c=b,l=f),                                  +\n               (endpos,endpos,v=n,c=b,l=f),                            +\n               (to,keyto,l=120),                                       +\n               msg=logr,build=y,pp=#p   ,trace=Y\n*              (to,to,v=n,c=b,l=f),\n*              (version,cversion,c=u,l=1,a=4),\n*              (info,cinfo,c=u,l=1),\n*              (get,cget,c=u,l=1),\n*              (pull,cpull,c=u,l=1),\n*              (put,cput,c=u,l=1),\n*              (insert,cinsert,a=3,c=u,l=1),\n*              (delete,cdelete,a=3,c=u,l=1),\n         if    (ltr,r5,r15,nz)         return message from parmscan\n           strlen data=logr\n           lr    r2,r15                copy length\n           st    r2,errmsgl\n           bctr  r2,0\n           j     *+10\n           mvc   errmsg(*-*),logr\n           ex    r2,*-6\n           mvi   rc+3,12\n           #subr exit,rc=12\n         endif\n         clear logr\n         oc    function,blank\n\n* test for some mutually exclusive parms\n         sr    r1,r1\n         if    (cli,mask_dl,ne,0),then=(la,r1,1(,r1))\n         if    (cli,text_dl,ne,0),then=(la,r1,1(,r1))\n         if    (cli,textstem_dl,ne,0),then=(la,r1,1(,r1))\n         if    (clfi,r1,gt,1)\n           seterr 'mutually exclusive parms',12\n           #subr exit,rc=12\n         endif\n\n* select stem or stack\n         if    (cli,stem_dl,ne,0),and,(cli,pstack,eq,c'Y')\n           seterr 'stem and stack are mutually exclusive',12,t\n           #subr exit,rc=12\n         endif\n         if    (cli,stem_dl,ne,0),and,(cli,function,eq,c'G')\n           RxStemPut name=wrk256,base=(stem,b.stem_dl),num=0,          c\n               data==c'0'\n         endif\n\n* keyvar\n         if    (cli,keyvar_dl,ne,0),and,(cli,key_dl,eq,0)\n           RXvGet name=(keyvar,b.keyvar_dl),data=(key,l'key)\n           if    (nz)           get failed\n             strmake errmsg,'not found: ',(keyvar,b.keyvar_dl,,80),    c\n               lr=r2\n             st    r2,errmsgl\n             setrc 12\n             #subr exit,rc=8\n           endif\n           stc   r0,key_dl       save length\n           mvi   keyvar_dl,0\n         endif\n*\n         if    (pos,eq,zero),then=(mvc,pos,=A(1))\n         if    (cli,ptrace,eq,c'Y'),then=(ICall,trace1)\n         if    (cli,mask_dl,gt,0),or,(cli,text_dl,gt,0),               c\n               or,(cli,textstem_dl,gt,0)\n           mvi   filter,c'Y'\n         endif\n*\n         #subr exit,rc=0\n         #subr drop\n\n*---------------------------------------------------------------------*\n*                    Epilog                                           *\n*---------------------------------------------------------------------*\nEpilog   #subr\n\n*- close ACB\n         if    (cli,dd,ne,c' '),and,(cli,openstat,eq,c'O')\n           if    (cli,ptrace,eq,c'Y')\n             trace 'close ACB1'\n           endif\n           j     acbclsm\nacbclsd    close 0,mf=L,mode=31\nacbclsm    mvc   wrk256(acbclsm-acbclsd),acbclsd\n           la    r2,ACB1         just in case\n           Close ((2)),mf=(E,wrk256),mode=31\n           mvi   openstat,0\n           if    (cli,ptrace,eq,c'Y')\n             trace 'close ACB1 done'\n           endif\n         endif\n\n         if     (cli,enq_dl,ne,0)     do enqueue\n           la    r2,=cl8'RXVSAMBA'\n           lb    r3,enq_dl\n           la    r4,dd\n           j     deqm\ndeqd       DEQ   (0,0,0,SYSTEMS),ret=HAVE,mf=L\ndeqm       mvc   wrk256(deqm-deqd),deqd\n           DEQ   ((2),(4),(3),SYSTEMS),ret=HAVE,mf=(E,wrk256)\n         endif\n*-\n* free dynamically allocated database\n*-\n         if    (cli,da,ne,c' ')\n           clear alcbfr1\n           strmake alcbfr1+2,'Free DD(',(dd,b.dd_dl),')',lenreg=r2\n           sth   r2,alcbfr1\n           if    (cli,ptrace,eq,c'Y')\n             strmake tracerec,(alcbfr1,2,c2x),+1,(alcbfr1+2,40)\n             trace ,\n           endif\n           la    r14,alcbfr1\n           sr    r0,r0\n           Link  EP=BPXWDYN,param=((r14)),VL=1,mf=(E,alcpl)\n         endif\n*\n         if     (cli,stemupd,eq,c'Y')  stem.0\n           StrP2d to=dw,from=stemnum\n           RxStemPut name=wrk256,base=(stem,b.stem_dl),num=0,          c\n               data=dw\n         endif\n\n         if     (cli,list_dl,ne,0)     stem.0\n           StrP2d to=dw,from=listnum\n           RxStemPut name=wrk256,base=(list,b.list_dl),num=0,          c\n               data=dw\n         endif\n\n         if     (cli,pkeystem_dl,ne,0) keystem.0\n           StrP2d to=dw,from=keynum\n           RxStemPut name=wrk256,base=(pkeystem,b.pkeystem_dl),num=0,  c\n               data=dw\n         endif\n\n         Macro\n         VputDec &name=,&field=\n         lclc  &s\n         lcla  &l\n&s       setc  Upper('&name')\n&l       seta  k'&name\n         la    r15,&field\n         la    r0,=c'&s'\n         la    r1,&l\n         bal   r9,VputDec\n         Mend\n\n         VputDec name=RXVBREAD,field=reads\n         VputDec name=RXVBINSE,field=inserts\n         VputDec name=RXVBUPDT,field=updates\n         ap    updates,inserts\n         VputDec name=RXVBWRIT,field=updates\n         VputDec name=RXVBDELE,field=deletes\n         if    (rc,ne,zero),and,(cli,tracerec,ne,c' '),                c\n               and,(cli,errmsg,eq,c' ')\n           mvc   errmsg,tracerec\n         endif\n         RxVput name='RXVBDBTY',data=vsdbtype\n         RxVput name='RXVBERRM',data=errmsg\n         RxVput name='RXVBVERS',data=(verinfo,l'verinfo)\n         strc2d from=(dbkeylen,4),to=(dw,8)\n         RxVput name='RXVBKEYL',data=(dw,8)\n         strc2d from=(dbkeypos,4),to=(dw,8)\n         RxVput name='RXVBKEYP',data=(dw,8)\n         strc2d from=(dbilrecl,4),to=(dw,8)\n         RxVput name='RXVBRECL',data=(dw,8)\n\n* drop stem copies\n         SlnkLst dropall,addr=f.txtlstad\n*        if    (icm,r2,15,txtlstad,nz)\n*          l     r3,0(r2)                     size\n*          STORAGE RELEASE,LENGTH=(3),ADDR=(2)\n*        endif\n\n*-\n* set return value\n*-\n         if    (icm,r4,15,retval,nz)          specific retval\n           l    r5,retval+4\n         else\n           strc2d from=rc,to=(dw,8)\n           la    r4,dw\n           la    r5,8\n         endif\n         RxRetval (r4),(r5)\n         #subr exit,rc=0\n\n*-\nVputDec  ds    0a\n         stm   r0,r1,wrk256\n         unpk  dw,0(4,r15)\n         oi    dw+7,x'f0'\n         lm    r2,r3,wrk256\n         RxVput name=((r2),(r3)),data=(dw,8)\n         lm    r2,r3,wrk256+8                 restore\n         br    r9\n*-\n         #subr drop\n*\n*---------------------------------------------------------------------*\n*---------------------------------------------------------------------*\n*  Global workarea                                                    *\n*---------------------------------------------------------------------*\n*---------------------------------------------------------------------*\n$wrk     dsect\n@@@sa    ds    (6*18)f\n@@@saend equ   *\n@@@salvl ds    pl2\nblank    ds    cl120\nsanum    ds    pl4\nlogr     ds    cl120\nerrmsgl  ds    a\nerrmsg   ds    cl120\nacb1     ds    0a(0),xl(acb1ml)\nrpl1     ds    0a(0),xl(rpl1ml)\nacbopn   ds    0a(0),xl(acbopnml)\n* do not change the order or size of DbKeyPos-DbReclen\nDbKeypos ds    a\nDbKeylen ds    a\nDbilrecl ds    a                     info - reclen\nDbReclen ds    a\nacb1stat ds    c\nopenstat ds    c\nwrimode  ds    c\nDbRecNum ds    a                     for RRDS\ndw       ds    d\ndw2      ds    d\nfw       ds    f\nfw2      ds    f\nreason   ds    a\ncallparm ds    4a\nstemupd  ds    c\nlistupd  ds    c\nfilter   ds    c\nreadtype ds    c\nstacknum ds    a\nstackcnt ds    a\npl4      equ   *\nstemnum  ds    pl4\nstemcnt  ds    pl4\nkeynum   ds    pl4\nlistnum  ds    pl4\nreads    ds    pl4\nupdates  ds    pl4\ninserts  ds    pl4\ndeletes  ds    pl4\npl4num   equ   (*-pl4)/4\ntextnum  ds    a\nkeycnt   ds    a\ntxtlstad ds    a\nstemiorc ds    a\nstemionl ds    a\nstemida  ds    a\nstemidl  ds    a\nrc       ds    a\nretval   ds    2a\nvsbfr1a  ds    a\nvsbfr1l  ds    a\nvsbfr1dl ds    a\nvsbfr2a  ds    a\nvsbfr2l  ds    a\nvsbfr2dl ds    a\nvsdbtype ds    c\nFDBAREA  DS    0F Feedback area for SHOWCB.\n         DS    1x Reserved.\nTYPECD   DS    1x Error type code.\nCMPCD    DS    1x Component code.\nERRCD    DS    1x Reason code.\ndupind   ds    1x\n\nVsamRc   ds    a\nvsamrs   ds    0a\nVsamFdbk ds    a\nfdbkcde  equ   *-1,1\nfdbkeod  equ   4                       End of data set found\nfdbkrnf  equ   16                      Record not found\nfdbkild  equ   116                     Initial load\n*-\n         ds    0d\n         StrParse area\n         ds    0d\n         RexxMacs ds\nstemdl   equ   zrx_ShVbVbl,l'zrx_ShVbVbl\n*\nkeypos   ds    a\nkeypos1  equ   keypos,l'keypos\nkeylen   ds    a\n         ds    0d\nwrk256   ds    xl256\n\ntracerec ds    cl120\ntracesa  ds    16a\ntracesar15 equ *-4,4\n*\n*\nrexxdata ds    0d\nalcpl    ds    4a\nalcbfr1  ds    cl120\nalcbfr2  ds    cl120\n         org   rexxdata\nvsbfr1   ds    xl(32760)\nvsbfr2   ds    xl(32760)\n$wrkl    equ   *-$wrk\n\n*---------------------------------------------------------------------*\n*        Get next record from REXX list - stem or stack               *\n*---------------------------------------------------------------------*\n\nREXXGETL #subr xprolog=SubrProl,xepilog=SubrEpil\n         if    (cli,stem_dl,eq,0),and,(cli,pstack,ne,c'Y')\n           mvlit errmsg,'Data source missing'\n           mvi   rc+3,20\n           #subr exit,rc=8\n         endif\n\n*-\n* handle data from stem\n*-\n         if    (cli,stem_dl,ne,0)\n* if 1st time around get count from stem.0\n           if    (cp,stemcnt,eq,=p'0')\n             mvc   vsbfr1(8),blank\n             RxStemGet name=wrk256,base=(stem,b.stem_dl),num=0,        c\n               data=(vsbfr1,8)\n             lr    r3,r0             data length\n             trcblk\n             StrMake logr,(stem,b.stem_dl),'0=\"',(vsbfr1,(r3)),'\"'\n             trace ,\n             trcblkend\n* test datatype\n             StrTest str=(vsbfr1,(r3)),test=num\n             if    (nz)\n               SetErr 'Stem.0 not numeric',8\n               #subr exit,rc=8\n             endif\n*\n             bctr  r3,0\n             pack  stemcnt,vsbfr1(*-*)\n             ex    r3,*-6\n             if    (cp,stemcnt,eq,=p'0'),then=(#subrend,3) no data\n           endif\n* get stem data\n           ap    stemnum,=p'1'\n           if    (cp,stemnum,gt,stemcnt),then=(#subrend,3)\n           if    (cli,ptrace,eq,c'Y'),then=(trace,'stemget')\n           RxStemGet name=wrk256,base=(stem,b.stem_dl),pnum=stemnum,   c\n               data=(vsbfr1,f.vsbfr1l)\n           lr    r5,r15                   rc\n           lr    r6,r0                    data length\n           if    (ltr,r5,r5,z),and,(cli,ptrace,eq,c'Y')\n             StrMake logr,'stemdata ',(r6,,cvdr,6),                    c\n               +1,(vsbfr1,(r6),,80)\n             trace ,\n           endif\n           lr    r0,r6                    data length\n           #subr exit,rc=(r5)\n         endif\n\n*-\n* handle data from stack\n*-\n         if    (cli,pstack,eq,c'Y')\n* if 1st time around get count\n           if    (stacknum,eq,zero)\n             RxStack queued,data=stackcnt\n             TrcBlk\n             StrMake logr,'stackcnt ',(stackcnt,4,cvd,6)\n             trace ,\n             TrcBlkEnd\n             if    (stackcnt,eq,zero),then=(#subrend,8)\n           endif\n* get data\n           l     r1,stacknum\n           la    r1,1(,r1)\n           st    r1,stacknum\n           if    (c,r1,gt,stackcnt),then=(#subrend,3)\n           if    (cli,ptrace,eq,c'Y'),then=(trace,'stackget')\n           RxStack pull,data=(vsbfr1,f.vsbfr1l),lenreg=r6\n           lr    r5,r15                       rc\n           if    (ltr,r5,r5,z),and,(cli,ptrace,eq,c'Y')\n             StrMake logr,'stackdata ',(r6,,cvdr,6),                   c\n               +1,(vsbfr1,(r6),,80)\n             trace ,\n           endif\n           lr    r0,r6                   copy data length\n           #subr exit,rc=(r5)\n         endif\n\n         #subr exit,rc=0\n         #subr drop\n\n*---------------------------------------------------------------------*\n*        Write record to REXX list - stem or stack                    *\n*---------------------------------------------------------------------*\n\nREXXPUTL #subr xprolog=SubrProl,xepilog=SubrEpil\n         if    (cli,stem_dl,eq,0),and,(cli,pstack,ne,c'Y')\n           mvlit errmsg,'Data source missing'\n           mvi   rc+3,20\n           #subr exit,rc=8\n         endif\n\n*-\n* handle data to stem\n*-\n         if    (cli,stem_dl,ne,0)\n           ap    stemnum,=p'1'\n           mvi   stemupd,c'Y'             remember update\n           RxStemPut name=wrk256,base=(stem,b.stem_dl),pnum=stemnum,   c\n               data=(vsbfr1,f.vsbfr1dl),namelenr=r3\n           TrcBlk\n           StrMake logr,'STEMPUT  ',(wrk256,(r3),,40),                 c\n               '=',(vsbfr1,f.vsbfr1dl,,60)\n           trace ,\n           TrcBlkEnd\n           #subr exit,rc=(r15)\n         endif\n\n*-\n* handle data to stack\n*-\n         if    (cli,pstack,eq,c'Y')\n           l     r1,stacknum\n           la    r1,1(,r1)\n           st    r1,stacknum\n           TrcBlk\n           StrMake logr,'STACKPUT ',(vsbfr1,f.vsbfr1dl,,100)\n           trace ,\n           TrcBlkEnd\n           RxStack queue,data=(vsbfr1,f.vsbfr1dl)\n           #subr exit,rc=(r15)\n         endif\n\n         #subr exit,rc=0\n         #subr drop\n\n*---------------------------------------------------------------------*\n*        Write record to list stem                                    *\n*---------------------------------------------------------------------*\nLISTPUT  #subr xprolog=SubrProl,xepilog=SubrEpil\n         if    (cli,list_dl,eq,0),then=(#subrend,0)\n*\n         ap    listnum,=p'1'\n         mvi   listupd,c'Y'             remember update\n         TrcBlk\n         StrMake logr,'listput ',(listnum,4,cvd,6),                    c\n               +1,(vsbfr1,f.vsbfr1dl,,80)\n         trace ,\n         TrcBlkEnd\n         RxStemPut name=wrk256,base=(list,b.list_dl),pnum=listnum,     c\n               data=(vsbfr1,f.vsbfr1dl)\n*\n         #subr exit,rc=0\n         #subr drop\n\n*---------------------------------------------------------------------*\n*---------------------------------------------------------------------*\n*                   VSAM                                              *\n*---------------------------------------------------------------------*\n*---------------------------------------------------------------------*\n\n*-\n* open\n*-\nVsamOpen #subr xprolog=SubrProl,xepilog=SubrEpil\n         if    (cli,openstat,eq,c'O')    already open?\n           #subr exit,rc=0\n         endif\n\n         mvi   vsdbtype,c'K'             default is KSDS\n         l     r2,vsbfr1a\n         l     r3,vsbfr1l\n         la    r4,acb1\n         la    r14,rpl1\n         ModCb rpl=(14),AREA=(2),arealen=(3),acb=(4),mf=(G,wrk256)\n*\n         StrMake logr,'VSMO open dd ',dd\n         trace   ,\n         mvc   acb1+40(8),dd      not nice\n         la    r2,Acb1\n         Open  ((2)),mf=(E,acbopn),mode=31\n         st    r15,vsamrc\n         lr    r5,r15\n         StrMake logr,'VSMO open rc ',(r5,,cvdr,6)\n         trace    ,\n         Vsam  stat\n         if    (ltr,r5,r5,z)\n           la    r2,dbkeypos\n           la    r4,acb1\n           Showcb acb=(4),area=(2),                                    c\n               length=16,fields=(RKP,KEYLEN,LRECL),                    c\n               MF=(G,wrk256)\n           mvi   acb1stat,c'O'\n           mvi   openstat,c'O'\n           if    (DbKeylen,eq,=a(0))\n             mvi   vsdbtype,c'R'      set RRDS\n           endif\n           trcblk\n           StrMake logr,'VSMO keyp ',(dbkeypos,4,cvd,4),               c\n               ' keyl ',(dbkeylen,4,cvd,4),                            c\n               ' recl ',(dbilrecl,4,cvd,6),                            c\n               ' dbty ',vsdbtype\n*            ' hex ',(dbkeypos,4,c2x),+1,(dbkeypos+4,4,c2x),         c\n*            +1,(dbkeypos+8,4,c2x),lr=r2\n           trace ,(r2)\n           trcblkend\n         else\n           mvi   acb1stat,c'F'        open failed\n           mvi   openstat,c'F'        open failed\n         endif\n\n         #subr exit,rc=(r5)\n         #subr drop\n\n*-\n* Get\n*  returns code in r15:\n*    00  all ok, data retrieved\n*    01  mask/text check failed or short record\n*    02  record not found / key check failed\n*    03  end of file\n*    >3  some error, refer to vsamrc / vsamfdbk\n*-\nVsamGet  #subr xprolog=SubrProl,xepilog=SubrEpil\n\n         Get   rpl=rpl1\n         lr    r5,r15\n         st    r5,vsamrc\n         mvi   acb1stat,c' '\n         Vsam  stat\n* if get rc > 0\n         if    (ltr,r5,r5,nz)\n           trace 'rc>0'\n           if    (c,r5,eq,=a(8))\n             if     (VsamFdbk,eq,=a(4))\n               mvi   acb1stat,c'E'       set end-of-file\n               xc    rc,rc               force rc 0\n               #subr exit,rc=3\n             elseif (VsamFdbk,eq,=a(16)),or,(VsamFdbk,eq,=a(116))\n               mvi   acb1stat,c'N'       record not found\n               xc    rc,rc               force rc 0\n               #subr exit,rc=2           record not found\n             endif\n           endif\n           #subr exit,rc=(r5)\n         endif\n* if get rc = 0\n         Countup reads\n         la    r2,DbReclen\n         la    r4,rpl1\n         ShowCb rpl=(4),area=(2),length=4,fields=RECLEN,               c\n               MF=(G,wrk256)\n*        handle recln<startpos\n         if    (DbReclen,lt,pos)\n           trace 'shortrec'\n           #subr end,rc=1                same as filter fail\n         endif\n         mvc   vsbfr1dl,DbReclen\n* check key\n         if    (cli,vsdbtype,eq,c'K'),and,(cli,key_dl,ne,0) Indexd,KEY\n           la    r2,vsbfr1\n           a     r2,dbkeypos             -> key\n           lb    r3,key_dl\n           bctr  r3,0\n*          j     *+10\n*          clc   key(*-*),0(r2)\n*          ex    r3,*-6\n*          if    (ne),then=(#subrend,2) rc= key_check_failed\n           if    (ex,r3,clc,key(*-*),0(r2),ne),then=(#subrend,2)\n         endif\n* text/mask search\n         if    (cli,filter,eq,c'Y')\n           la    r1,vsbfr1\n           l     r0,vsbfr1dl\n           icall FilterCk\n           if    (nz),then=(#subrend,1)\n         endif\n\n         #subr exit,rc=0\n         #subr drop\n\n*-\n* Put\n*-\nVsamPut  #subr xprolog=SubrProl,xepilog=SubrEpil\n         Put   rpl=rpl1\n         st    r15,vsamrc\n         lr    r5,r15\n         Vsam  stat\n         if     (ltr,r5,r5,z)\n           Countup updates\n         endif\n         #subr exit,rc=(r5)\n         #subr drop\n\n*-\n* Insert\n*-\nVsamIns  #subr xprolog=SubrProl,xepilog=SubrEpil\n         Put   rpl=rpl1\n         st    r15,vsamrc\n         lr    r5,r15\n         Vsam  stat\n         if     (ltr,r5,r5,z)\n           Countup inserts\n         endif\n         #subr exit,rc=(r5)\n         #subr drop\n\n*-\n* Delete\n*-\nVsamDel  #subr xprolog=SubrProl,xepilog=SubrEpil\n         Erase rpl=rpl1\n         st    r15,vsamrc\n         lr    r5,r15\n         Vsam  stat\n         if     (ltr,r5,r5,z)\n           Countup deletes\n         endif\n         #subr exit,rc=(r5)\n         #subr drop\n\n*-\n* Status\n*-\nVsamStat #subr , xprolog=SubrProl,xepilog=SubrEpil\n         xc    VsamFdbk,VsamFdbk\n         if    (vsamrc,ne,zero),or,(cli,ptrace,eq,c'Y')\n           la    r2,VsamFdbk\n           la    r4,rpl1\n           SHOWCB RPL=(4),AREA=(2),FIELDS=FDBK,LENGTH=4,mf=(G,wrk256)\n           TrcBlk\n           clear tracerec\n           StrMake tracerec,'rc(',(VsamRc,4,cvxd),                     c\n               ') fdbk(',(VsamFdbk,4,cvxd),')'\n           TrcBlkEnd\n         endif\n         TrcBlk\n         clear logr\n         StrMake logr,'VSTA     ',(tracerec,28),(vsbfr1,f.vsbfr1l,,60)\n         trace ,\n         TrcBlkEnd\n         l     r5,vsamrc\n         if    (=a(8),eq,VsamRc),and,(=a(8),eq,VSamFdbk),and,          c\n               (cli,pigndup,eq,c'Y'),then=(sr,r5,r5) ignore duplicates\n         #subr exit,rc=(r5)\n         #subr drop\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   GET skip-sequential subroutine                                    *\n*   parms: KEY(value) | KEYVAR(name)  STEM(stembase) | STACK          *\n*                                                                     *\n*---------------------------------------------------------------------*\nGETKEY   #subr xprolog=SubrProl,xepilog=SubrEpil\n\n* open  db\n         la    r14,acb1\n         Modcb acb=(14),MACRF=(KEY,DIR,SEQ,IN),mf=(G,wrk256)\n         mvi   readtype,c'K'           inital keyed access\n         VSAM  Open,nz=exit\n         if    (cli,vsdbtype,eq,c'R'),then=(j,GetKeyR)  RRDS?\n\n* setup for KSDS\n         la    r4,key\n         lb    r5,key_dl\n         if    (c,r5,gt,dbkeylen),then=(l,r5,dbkeylen)\n         la    r14,rpl1\n         ModCb rpl=(14),arg=(4),keylen=(5),mf=(G,wrk256),              c\n               OPTCD=(KEY,DIR,SYN,NSP,KEQ,GEN,MVE)\n*\n         TrcBlk\n         StrMake logr,'key ',(r5,,cvdr,4),' ',(key,(r5),,60)\n         trace ,\n         TrcBlkEnd\n*\n* locate and read record with matching key prefix into vsbfr1,\n* data length in vsbfr1dl.\n         if    (cli,ptrace,eq,c'Y'),then=(trace,'GETK get first')\n         VSAM  Get\n         if    (clfi,r15,ge,2),then=#subrend eof\n         if    (ltr,r15,r15,z),then=(icall,REXXPUTL)\n\n* if request keylen = dbkeylen then no next\n         if    (c,r5,ge,DbKeylen),then=(#subrend,0)\n\n* get rest\n         la    r14,rpl1\n         Modcb rpl=(14),optcd=SEQ,mf=(G,wrk256)\n         mvi   readtype,c'S'           set sequrential\n*\n         l     r8,vsbfr1a\n         a     r8,DbKeypos      key address\n         l     r7,DbKeyLen      db key length\n         bctr  r5,0             mch search key length\n\n         trace 'GET seq hereafter'\n         do    forever\n           VSAM  Get   ,nz=leave\n           if    (clfi,r15,ge,2),then=#subrend eof\n           if    (ltr,r15,r15,z),then=(icall,REXXPUTL)\n         enddo  ,          do inf\n\n         #subr exit,rc=8           shouldnt come here\n*-\n* RRDS\n*-\nGetKeyR  ds    0a\n         trace 'GetKeyR'\n* convert key to binary slotnum\n         lb    r2,key_dl              key length\n         bctr  r2,0\n         j     *+10\n         pack  dw,key(*-*)\n         ex    r2,*-6\n         cvb   r2,dw\n         st    r2,dbRecNum\n* setup for RRDS\n         la    r14,rpl1\n         la    r2,DbRecNum\n         l     r3,vsbfr1a\n         la    r3,8(,r3)\n         l     r4,vsbfr1l\n         Modcb rpl=(14),arg=(2),area=(3),arealen=(4),                  c\n               OPTCD=(KEY,DIR,SYN,NUP,KEQ,GEN,MVE),mf=(G,wrk256)\n         VSAM  Get\n         if    (ltr,r15,r15,nz),then=(#subrend,8) error\n\n         l     r1,vsbfr1dl\n         la    r1,8(,r1)               add slot number\n         st    r1,vsbfr1dl\n         l     r1,dbrecnum\n         $cvd  r1,vsbfr1,len=8\n         StrLen data=(vsbfr1,f.vsbfr1dl)\n         st    r15,vsbfr1dl\n         ICall REXXPUTL\n\n* do to\n         if    (cli,keyto_dl,eq,0),then=(#subrend,0) just the one\n         lb    r4,keyto_dl            key length\n         bctr  r4,0\n         j     *+10\n         pack  dw,keyto(*-*)\n         ex    r4,*-6\n         cvb   r4,dw\n         s     r4,dbrecnum\n* get rest\n         do over(r4)\n           l     r1,dbrecnum\n           la    r1,1(,r1)\n           st    r1,dbrecnum\n           VSAM  Get\n           if    (cli,acb1stat,eq,c'N') not found is acceptable\n             trace 'record not found'\n             iterate\n           endif\n           if    (clfi,r15,ge,2),then=(#subrend,0) eof\n           if    (ltr,r5,r15,z)        all ok?\n             l     r1,vsbfr1dl\n             la    r1,8(,r1)           add slot number\n             st    r1,vsbfr1dl\n             l     r1,dbrecnum\n             $cvd  r1,vsbfr1,len=8\n             StrLen data=(vsbfr1,f.vsbfr1dl)\n             st    r15,vsbfr1dl\n             ICall REXXPUTL\n           endif\n         enddo\n*\n         #subr exit,rc=0\n         #subr drop\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   GET data based on a keylist, write to stem or stack.              *\n*   Parms: KEYSTEM(name) STEM(name) | STACK                           *\n*                                                                     *\n*---------------------------------------------------------------------*\nGETKEYL  #subr xprolog=SubrProl,xepilog=SubrEpil\n\n* get count from keystem.0\n         RxStemGet name=wrk256,base=(pkeystem,b.pkeystem_dl),          c\n               data=(vsbfr1,8),pnum=keynum\n         lr    r3,r0\n* test datatype\n         StrTest str=(vsbfr1,(r3)),test=num\n         if    (nz)\n           SetErr 'Stem.0 not numeric',8\n           #subr exit,rc=8\n         endif\n*\n         bctr  r3,0\n         j     *+10\n         pack  dw,vsbfr1(*-*)\n         ex    r3,*-6\n         cvb   r9,dw\n         mvc   keycnt,dw+4\n\n         do    over(r9)\n           ap    keynum,=p'1'\n           RxStemGet name=wrk256,base=(pkeystem,b.pkeystem_dl),        c\n               data=(key,b.key_fl),pnum=keynum\n           stc   r0,key_dl\n           TrcBlk\n           lr    r4,r0\n           StrMake logr,'keylst ',(r4,,cvdr,3),+1,(key,(r4),,80)\n           trace ,\n           TrcBlkEnd\n           ICall GetKey                read and copy\n         enddo\n*\n         #subr exit,rc=0\n         #subr drop\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   GET for text or mask, scan entire db                              *\n*   Syntax: GET \u00dd\u00ddTEXT(value)\u00a8 \u00ddMASK(value)\u00a8 POS(p) \u00ddENDPOS=n\u00a8\u00a8       *\n*               STEM(stembase) | STACK                                *\n*           GET STEM(result) | STACK                                  *\n*                                                                     *\n*---------------------------------------------------------------------*\nGETTXT   #subr xprolog=SubrProl,xepilog=SubrEpil\n* open db\n         mvi   readtype,c'S'           set sequrential\n         la    r14,acb1\n         Modcb acb=(14),MACRF=(KEY,SEQ,IN),mf=(G,wrk256)\n         la    r14,rpl1\n         Modcb rpl=(14),OPTCD=(KEY,SEQ,SYN,NUP,MVE),mf=(G,wrk256)\n*\n         VSAM  Open\n         if    (nz),then=(#subrend,20)\n         if    (cli,vsdbtype,eq,c'R'),then=(j,GetTxtR)  RRDS?\n*\n         do inf\n           VSAM  Get\n           if    (clfi,r15,ge,2),then=(#subrend,0) eof\n           lr    r5,r15\n           if    (ltr,r5,r5,z)         all ok?\n             ICall REXXPUTL\n           endif\n         enddo\n*\n         #subr exit,rc=0\n*\nGetTxtR  ds    0a\n         xc    DbRecNum,DbRecNum       just in case\n         la    r14,rpl1\n         la    r2,DbRecNum\n         l     r3,vsbfr1a\n         la    r3,8(,r3)\n         l     r4,vsbfr1l\n         Modcb rpl=(14),arg=(2),area=(3),arealen=(4),mf=(G,wrk256)\n*\n         do inf\n           VSAM  Get\n           if    (clfi,r15,ge,2),then=(#subrend,0) eof\n           if    (ltr,r5,r15,z)        get ok?\n             l     r1,vsbfr1dl\n             la    r1,8(,r1)           add slot number length (8)\n             st    r1,vsbfr1dl\n             l     r1,dbrecnum\n             $cvd  r1,vsbfr1,len=8\n             StrLen data=(vsbfr1,f.vsbfr1dl)\n             st    r15,vsbfr1dl\n             ICall REXXPUTL\n           endif\n         enddo\n*\n         #subr exit,rc=0\n         #subr drop\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   DEL - delete by key prefix                                        *\n*   parms: KEY(value) | KEYVAR(name) \u00ddLIST(name)\u00a8                     *\n*                                                                     *\n*---------------------------------------------------------------------*\nDELKEY   #subr xprolog=SubrProl,xepilog=SubrEpil\n         if    (cli,ptrace,eq,c'Y')\n           trace 'Delkey'\n         endif\n         if    (key_dl,eq,0)\n           seterr 'KEY missing',12\n           #subr exit,rc=20\n         endif\n*\n         la    r14,acb1\n         ModCb Acb=(14),MACRF=(KEY,DIR,SEQ,OUT),mf=(G,wrk256)\n         la    r14,rpl1\n         ModCb Rpl=(14),OPTCD=(KEY,DIR,SYN,UPD,KEQ,GEN,MVE),           c\n               mf=(G,wrk256)\n         VSAM  Open,nz=exit\n*\n* locate and read record with matching key prefix\n         la    r4,key\n         lb    r5,key_dl\n         if    (c,r5,gt,dbkeylen),then=(l,r5,dbkeylen)\n         la    r14,rpl1\n         ModCb rpl=(14),arg=(4),keylen=(5),mf=(G,wrk256)\n         VSAM  Get\n         if    (clfi,r15,ge,2),then=(#subrend,2) eof\n         if    (ltr,r15,r15,z)                  all ok\n*          if list requested, then write to list\n           if    (cli,list_dl,ne,0),then=(icall,ListPut)\n*          if PULL then write stem or stack\n           if    (=c'PULL',eq,function),then=(ICall,REXXPUTL)\n         endif\n* get rest\n         la    r14,rpl1\n         Modcb rpl=(14),optcd=SEQ,mf=(G,wrk256)\n         l     r4,vsbfr1a\n         a     r4,DbKeypos\n         bctr  r5,0\n\n         do    inf\n           VSAM  Del,nz=leave\n*          if request keylen = dbkeylen then no next\n           lb    r2,key_dl\n           if    (c,r2,ge,DbKeylen),then=(#subrend,0)\n           VSAM  Get\n           if    (clfi,r15,ge,2),then=leave\n           if    (ltr,r15,r15,nz),then=iterate\n*          if list requested, then write to list\n           if    (cli,list_dl,ne,0),then=(icall,ListPut)\n*          if PULL then write stem or stack\n           if    (=c'PULL',eq,function),then=(ICall,REXXPUTL)\n         enddo\n*- if PULL then stem.0 is written at program exit\n\n         #subr exit,rc=0\n         #subr drop\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   DELKEYL - delete by key values in stem                            *\n*   Parms: KEYSTEM(name) \u00ddLIST(name)\u00a8                                 *\n*                                                                     *\n*---------------------------------------------------------------------*\nDELKEYL  #subr xprolog=SubrProl,xepilog=SubrEpil\n\n* get count from keystem.0\n         RxStemGet name=wrk256,base=(pkeystem,b.pkeystem_dl),          c\n               data=(vsbfr1,8),pnum=keynum\n         lr    r3,r0\n* test datatype\n         StrTest str=(vsbfr1,(r3)),test=num\n         if    (nz)\n           SetErr 'Stem.0 not numeric',8\n           #subr exit,rc=8\n         endif\n*\n         bctr  r3,0\n         j     *+10\n         pack  dw,vsbfr1(*-*)\n         ex    r3,*-6\n         cvb   r9,dw\n         mvc   keycnt,dw+4\n\n         do    over(r9)\n           ap    keynum,=p'1'\n           RxStemGet name=wrk256,base=(pkeystem,b.pkeystem_dl),        c\n               data=(key,b.key_fl),pnum=keynum\n           stc   r0,key_dl\n           TrcBlk\n           lr    r4,r0\n           StrMake logr,'keylst ',(r4,,cvdr,3),+1,(key,(r4),,80)\n           trace ,\n           TrcBlkEnd\n           ICall DelKey                delete\n         enddo\n         #subr exit,rc=0\n         #subr drop\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   DELTXT  - delete by text or mask                                  *\n*   Parms: TEXT(v) | MASK(v) POS(p) \u00ddENDPOS(ep)\u00a8 \u00ddLIST(name)\u00a8         *\n*                                                                     *\n*---------------------------------------------------------------------*\nDELTXT   #subr xprolog=SubrProl,xepilog=SubrEpil\n*\n         la    r14,acb1\n         Modcb acb=(14),MACRF=(KEY,SEQ,OUT),mf=(G,wrk256)\n         la    r14,rpl1\n         Modcb rpl=(14),OPTCD=(KEY,SEQ,SYN,UPD,MVE),mf=(G,wrk256)\n         VSAM  Open,nz=exit\n\n*\n         Do    inf\n           VSAM  Get\n           if    (clfi,r15,ge,2),then=#subrend\n           if    (ltr,r15,r15,nz),then=iterate\n* if list requested then write it\n           if    (cli,list_dl,ne,0),then=(icall,ListPut)\n* if PULL then write stem or stack\n           if    (=c'PULL',eq,function),then=(ICall,REXXPUTL)\n* finally delete\n           VSAM  Del,nz=leave\n         Enddo\n\n         #subr exit,rc=0\n         #subr drop\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   PUT - write data in stem or stack to database                     *\n*   Parms: STEM(name) | STACK                                         *\n*                                                                     *\n*---------------------------------------------------------------------*\nPUT      #subr xprolog=SubrProl,xepilog=SubrEpil\n\n*- setup VSAM options, open\n         la    r14,acb1\n         modcb acb=(14),MACRF=(KEY,DIR,OUT),mf=(G,wrk256)\n*\n         la    r14,rpl1\n         modcb rpl=(14),OPTCD=(KEY,DIR,SYN,UPD,KEQ,FKS,MVE),           c\n               mf=(G,wrk256)\n*\n         Vsam  open\n         if    (ltr,r15,r15,nz)\n           StrMake errmsg,'Open rc ',(vsamrc,8,cvxd)\n           mvi   rc+3,20\n           #subr exit,rc=8\n         endif\n\n         do    forever\n\n* get data to write\n           ICall REXXGETL\n           if    (ltr,r15,r15,nz)\n             if    (clfi,r15,gt,4),then=(#subrend,(r15))\n             mvc   rc,zero\n             #subr exit,rc=0\n           endif\n           lr    r6,r0              data size\n\n*read VSAM, determine INSERT or UPDATE\n           if    (cli,wrimode,ne,c'L')  not initial load\n             l     r4,vsbfr2a         -> data area\n             l     r5,vsbfr2l         data length\n             if    (cli,vsdbtype,eq,c'K') KSDS\n               l     r2,vsbfr1a       -> key area\n               a     r2,dbkeypos      key offset\n               l     r3,dbkeylen      key length\n             endif\n             if    (cli,vsdbtype,eq,c'R') RRDS\n               pack  dw,vsbfr1(8)     convert 8-byte key\n               cvb   r2,dw             to\n               st    r2,dbrecnum         binary recno\n               la    r2,dbrecnum      record number\n               la    r3,4             key length\n             endif\n             la    r14,rpl1\n             modcb rpl=(14),arg=(2),keylen=(3),area=(4),arealen=(5),   c\n               OPTCD=UPD,mf=(G,wrk256)\n\n             VSAM  get\n             if    (ltr,r5,r15,nz)\n               if   (cli,acb1stat,ne,c'N') if not 'record not found'\n                 clear errmsg\n                 StrMake errmsg,'Get ',(tracerec,100)\n                 mvi   rc+3,20\n                 leave\n               endif\n               if    (cli,fdbkcde,eq,fdbkild)  initial load?\n                 mvi   wrimode,c'L' remember\n               endif\n             endif\n           endif\n\n* update or insert\n           if    (cli,vsdbtype,eq,c'K') KSDS\n             trace 'put ksds'\n             l     r2,vsbfr1a       -> key\n             a     r2,dbkeypos        area\n             l     r3,dbkeylen      key length\n             la    r4,vsbfr1        -> data\n           endif\n           if    (cli,vsdbtype,eq,c'R') KSDS\n             la    r2,dbrecnum      -> rec no\n             la    r3,4\n             ahi   r6,-8            adjust data size\n             trcblk\n             strmake logr,'put rrds # ',(dbrecnum,4,cvd,6),            c\n               +1,(vsbfr1+8,(r6),,60),lenreg=r7\n             trace    ,(r7)\n             trcblkend\n* copy and pad\n             la    r14,vsbfr1+8      -> source\n             lr    r15,r6            source length\n             la    r1,c' '           set\n             sll   r1,24               pad\n             ar    r15,r1                in source length\n             l     r0,vsbfr2a        -> target\n             l     r1,dbilrecl       target size\n             mvcl  r0,r14\n             l     r4,vsbfr2a        -> target\n             l     r6,dbilrecl       target size\n           endif\n*\n           if    (ltr,r5,r5,nz)     record don't exist, insert\n             if   (cli,wrimode,eq,c'L')   initial load?\n               trace 'first'\n               la    r14,rpl1\n               modcb rpl=(14),arg=(2),keylen=(3),area=(4),reclen=(6),  c\n               OPTCD=(KEY,SEQ,SYN,NUP,MVE),mf=(G,wrk256)\n             else\n               trace 'insert'\n               la    r14,rpl1\n               modcb rpl=(14),arg=(2),keylen=(3),area=(4),reclen=(6),  c\n               OPTCD=(KEY,DIR,SYN,NUP,KEQ,FKS,MVE),mf=(G,wrk256)\n             endif\n             VSAM ins\n           else  ,                  record found, update\n             trace 'update'\n             la    r14,rpl1\n             modcb rpl=(14),arg=(2),keylen=(3),area=(4),reclen=(6),    c\n               OPTCD=UPD,mf=(G,wrk256)\n             VSAM put\n           endif\n           if    (ltr,r15,r15,nz)\n             st    r15,dw\n             mvc   dw+4(4),vsamfdbk\n             StrMake errmsg,'Put rc ',(dw,8,cvxd)\n             mvi   rc+3,20\n             leave\n           endif\n\n         enddo\n\n         #subr exit,rc=0\n         #subr drop\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   PUT data in 'value' to databazse                                  *\n*   Parms: VALUE(text)                                                *\n*                                                                     *\n*---------------------------------------------------------------------*\nPUTVAL   #subr xprolog=SubrProl,xepilog=SubrEpil\n*\n         if    (cli,value_dl,eq,0)\n           mvlit errmsg,'VALUE missing'\n           mvi   rc+3,20\n           #subr exit,rc=8\n         endif\n*\n         la    r14,acb1\n         modcb acb=(14),MACRF=(KEY,DIR,OUT),mf=(G,wrk256)\n         la    r14,rpl1\n         modcb rpl=(14),OPTCD=(KEY,DIR,SYN,UPD,KEQ,FKS,MVE),           c\n               mf=(G,wrk256)\n*\n         Vsam  open\n         if    (ltr,r15,r15,nz)\n           StrMake errmsg,'Open rc ',(vsamrc,8,cvxd)\n           mvi   rc+3,20\n           #subr exit,rc=8\n         endif\n*\n* read using key\n         if    (cli,vsdbtype,eq,c'R') RRDS\n           pack  dw,value(8)      convert 8-byte key\n           cvb   r2,dw             to\n           st    r2,dbrecnum         binary recno\n           la    r2,dbrecnum      record number\n           la    r3,4             key length\n         else\n           la    r2,value         -> key area\n           a     r2,dbkeypos      key offset\n           l     r3,dbkeylen      key length\n         endif\n         l     r4,vsbfr2a         -> data output area\n         l     r5,vsbfr2l         output area length\n         la    r14,rpl1\n         modcb rpl=(14),arg=(2),keylen=(3),area=(4),arealen=(5),       c\n               OPTCD=UPD,mf=(G,wrk256)\n*\n         VSAM  get\n         if    (ltr,r5,r15,nz)\n           if   (cli,acb1stat,ne,c'N') if not 'record not found'\n             clear errmsg\n             StrMake errmsg,'Get ',(tracerec,100)\n             mvi   rc+3,20\n             #subr exit,rc=8\n           endif\n         endif\n*\n* update or insert\n         if    (cli,vsdbtype,eq,c'R') KSDS\n           la    r2,dbrecnum      -> rec no\n           la    r3,4\n           lb    r4,value_dl\n           ahi   r4,-8            adjust data size\n           trcblk\n           strmake logr,'put rrds # ',(dbrecnum,4,cvd,6),              c\n               +1,(value+8,(r4),,60),lenreg=r7\n           trace    ,(r7)\n           trcblkend\n* copy and pad\n           la    r14,value+8       -> source\n           lr    r15,r4            adjusted source length\n           la    r1,c' '           set\n           sll   r1,24               pad\n           ar    r15,r1                in source length\n           l     r0,vsbfr2a        -> target\n           l     r1,dbilrecl       target size\n           mvcl  r0,r14\n           l     r5,vsbfr2a        -> target\n           l     r4,dbilrecl       target size\n         else\n           la    r2,value           -> key area\n           a     r2,dbkeypos        key offset\n           l     r3,dbkeylen        key length\n           lb    r4,value_dl\n           la    r5,value           -> data area\n         endif\n         la    r14,rpl1\n*        if    (ltr,r5,r5,nz)       record don't exist, insert\n         if    (cli,acb1stat,eq,c'N') record not found, insert\n           modcb rpl=(14),arg=(2),keylen=(3),area=(5),reclen=(4),      c\n               OPTCD=NUP,mf=(G,wrk256)\n           VSAM ins\n           la    r6,=c'INS '\n         else  ,                     record found, update\n           modcb rpl=(14),arg=(2),keylen=(3),area=(5),reclen=(4),      c\n               OPTCD=UPD,mf=(G,wrk256)\n           VSAM put\n           la    r6,=c'UPD '\n         endif\n         if    (ltr,r15,r15,nz)\n           st    r15,dw\n           mvc   dw+4(4),vsamfdbk\n           StrMake errmsg,((r6),4),'rc ',(dw,8,cvxd)\n           mvi   rc+3,20\n           #subr exit,rc=8\n         endif\n\n         #subr exit,rc=0\n         #subr drop\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   INSERT data in stem to database. Like PUT above execpt no         *\n*          GET is attempted and we don't care about the key           *\n*          position nor length.                                       *\n*   parms: STEM(s)                                                    *\n*                                                                     *\n*---------------------------------------------------------------------*\nINSERT   #subr xprolog=SubrProl,xepilog=SubrEpil\n         if    (cli,ptrace,eq,c'Y')\n           trace 'insert'\n         endif\n*\n         la    r14,acb1\n         modcb acb=(14),MACRF=(KEY,DIR,OUT),mf=(G,wrk256)\n         la    r14,rpl1\n         modcb rpl=(14),OPTCD=(KEY,DIR,SYN,NUP,MVE),mf=(G,wrk256)\n         VSAM  Open\n\n* Insert into a RRDS = PUT\n         if    (cli,vsdbtype,eq,c'R') RRDS\n           ICall  Put\n           #subrend rc=(r15)\n         endif\n\n* Process list\n         do    forever\n* get data from REXX\n           ICall REXXGETL\n           if    (ltr,r15,r15,nz)\n             if    (clfi,r15,lt,4),then=(sr,r15,r15)  just EOF\n             leave\n           endif\n           lr    r6,r0                     data length\n* write data to db\n           la    r14,rpl1\n           modcb rpl=(14),reclen=(6),mf=(G,wrk256)\n           VSAM  Ins,nz=leave\n         enddo\n         st    r15,rc\n\n         #subr exit,rc=(r15)\n         #subr drop\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   Copy data from stem to internal buffer                            *\n*                                                                     *\n*   At entry                                                          *\n*     r0  -> list anchor point                                        *\n*     r1  -> al1(l'stemname),c'stemname'                              *\n*                                                                     *\n*   At exit                                                           *\n*     r15  rc  0=ok, else not ok                                      *\n*                                                                     *\n*---------------------------------------------------------------------*\nStmCpyMk #subr xprolog=SubrProl,xepilog=SubrEpil\n         lr    r8,r0              -> list anchor\n         lr    r9,r1              -> list name\n* copy stemname\n         sr    r2,r2\n         ic    r2,0(,r9)\n         j     *+10\n         mvc   wrk256(*-*),0(r9)  length plus name\n         ex    r2,*-6\n\n* get count from stem.0\n         clear vsbfr1,l=200\n         RxStemGet name=wrk256+140,base=(wrk256+1,b.wrk256),           c\n               data=(vsbfr1,8),pnum=keynum\n         lr    r3,r0              datalength\n* test datatype\n         StrTest str=(vsbfr1,(r3)),test=num\n         if    (nz)\n           SetErr 'Stem.0 not numeric',8\n           #subr exit,rc=8\n         endif\n*\n         bctr  r3,0\n         j     *+10               around pack\n         pack  dw,vsbfr1(*-*)\n         ex    r3,*-6\n         cvb   r7,dw              r7=count\n\n* get filter list\n         do    over(r7)\n           ap    keynum,=p'1'\n           RxStemGet name=wrk256+140,base=(wrk256+1,b.wrk256),         c\n               data=(vsbfr1,f.vsbfr1l),pnum=keynum\n           if    (ltr,r15,r15,nz),then=iterate\n           lr    r3,r0            copy length\n           SlnkLst add,size=(r3),addr=(r8),data=(vsbfr1,(r3))\n           lr    r8,r1            copy new address\n         enddo\n\n         #subr exit,rc=0\n         #subr drop\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   SHOW vsam specs                                                   *\n*   key length- and offset are set by VSAM open                       *\n*                                                                     *\n*---------------------------------------------------------------------*\nINFO     #subr xprolog=SubrProl,xepilog=SubrEpil\n         if    (DbKeylen,ne,zero)       already set??\n           #subr exit,rc=0\n         endif\n*\n         if    (cli,ptrace,eq,c'Y')\n           trace 'modacb'\n         endif\n         la    r3,acb1\n         modcb acb=(3),MACRF=(KEY,DIR,SEQ,OUT),mf=(G,wrk256)\n*\n ago .b\n         if    (cli,ptrace,eq,c'Y')\n           trace 'modrpl'\n         endif\n         la    r4,rpl1\n         la    r3,acb1\n         modcb rpl=(4),acb=(3),OPTCD=(KEY,DIR,SYN,NUP,MVE),            c\n               mf=(G,wrk256)\n*\n.b anop\n         if    (cli,ptrace,eq,c'Y')\n           trace 'open'\n         endif\n         VSAM  Open\n*\n         #subr exit,rc=0\n         #subr drop\n\n*-------------------------------------------------------------------- *\n*-------------------------------------------------------------------- *\n* Filter - check string for text/textstem, mask/maskstem              *\n*                                                                     *\n*  at entry                                                           *\n*    r0 =  string length                                              *\n*    r1 -> string                                                     *\n*                                                                     *\n*  at exit                                                            *\n*    r15 = 0 => ok                                                    *\n*    r15 > 0 => not ok                                                *\n*-------------------------------------------------------------------- *\n*-------------------------------------------------------------------- *\nFilterCk #subr xprolog=SubrProl,xepilog=SubrEpil\n\n* setup for start and length of string\n         lr    r8,r1                  -> string\n         lr    r9,r0                  length of string\n         if    (c,r9,lt,pos),then=(#subrend,4) short record\n         a     r8,pos                 adjust\n         bctr  r8,0                    address\n         if    (endpos,ne,zero),and,(c,r9,gt,endpos)\n           l     r9,endpos            adjust length\n         endif\n         s     r9,pos                 minus start\n         la    r9,1(,r9)\n*\n\n* r8 -> string, r9 = length\n         sr    r3,r3\n\n* test for text\n         if    (icm,r3,1,text_dl,nz)         text search\n           trace 'test for text'\n           StrPos arg=(text,(r3)),str=((r8),(r9))\n           if    (ltr,r1,r1,nz),then=(#subrend,0) match\n           #subr exit,rc=8                   no match\n         endif\n\n* test for text in stem\n         if    (icm,r3,1,textstem_dl,nz)     text search\n           trace 'test for text in stem'\n           if    (icm,r6,15,txtlstad,z),then=(#subrend,8)\n           do    forever\n             l     r3,4(,r6)                 length\n             ahi   r3,-slnklstpfxl           data length\n             StrPos arg=(slnklstdatao(r6),(r3)),str=((r8),(r9))\n             if    (ltr,r1,r1,nz),then=(#subrend,0) match\n             SlnkLst next,addr=(r6)\n             if    (ltr,r6,r1,z),then=(#subrend,8)\n           enddo\n         endif\n\n* test for mask\n         if    (icm,r3,1,mask_dl,nz)         text search\n           trcblk\n           strmake logr,'test for mask \"',(mask,b.mask_dl,,40),        c\n               '\" in \"',((r8),(r9),,40),'\"',lr=r2\n           trace ,(r2)\n           trcblkend\n           StrPatrn str=((r8),(r9)),mask=(mask,b.mask_dl)\n           #subr end,rc=(r15)\n         endif\n*\n         #subr exit,rc=8\n         #subr drop\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n* Subroutine prolog / epilog  - do tracing                            *\n* r10 -> global storage                                               *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\nSubrProl #subr base=r6\n         ap    sanum,=p'1'\n         if    (zrx_ExComA,eq,zero),then=(#subrend,0)   no REXX\n*\n         TrcBlk\n         l     r3,4(,r13)              reload callers\n         l     r3,64(,r3)                basereg (r11)\n         strmake logr,(10(,r3),8),' ',(sanum,4,p2d,2),' entry',        c\n               lenreg=r2\n         trace    ,(r2)\n         l     r1,4(,r13)              reload callers\n         lm    r0,r1,20(r1)              r0+r1\n         TrcBlkEnd\n*\n         #subr exit,rc=0\n         #subr drop\n*--\n* r2 = #subr end rc\nSubrEpil #subr base=r6\n         if    (zrx_ExComA,eq,zero),then=(#subrend,(r2))  no REXX\n         lr    r5,r2                   copy rc\n*\n         TrcBlk\n         l     r3,4(,r13)              reload callers\n         l     r3,64(,r3)                basereg\n         strmake logr,(10(,r3),8),' ',(sanum,4,p2d,2),                 c\n               ' exit rc ',(r5,,cvdr,8),lenreg=r2\n         trace    ,(r2)\n         l     r1,4(,r13)              reload callers\n         lm    r0,r1,20(r1)              r0+r1\n         TrcBlkEnd\n*\n         sp    sanum,=p'1'\n         #subr exit,rc=(r5)            r5 = original r15\n         #subr drop\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*          end of program                                             *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         RexxMacs dsect\n         End\n//*\n//* Production version is in LPALIB\n//*\n//* activate dynamic:\n//*   SETPROG LPA,ADD,MODNAME=RXVSAMBA,DSNAME=CBT669.LPALIB\n//*\n//L.SYSLMOD DD DSN=CBT669.LPALIB(RXVSAMBA),DISP=SHR\n//*.SYSLMOD DD DSN=&YOUR.LINKLIB(RXVSAMBA)\n//*\n//IVP1     EXEC PGM=IKJEFT1B,PARM='RXVBIVP&IVP'\n//STEPLIB  DD DISP=SHR,DSN=*.A.L.SYSLMOD\n//SYSEXEC  DD DISP=SHR,DSN=CBT669.LIB\n//SYSTSPRT DD SYSOUT=*,OUTLIM=10000\n//SYSTSIN  DD DUMMY\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXWAIT": {"ttr": 7946, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1c\\x00I\\x01\\x19\\x18\\x9f\\x01\\x193\\x8f\\x17P\\x01\\x13\\x00\\xc7\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.28", "flags": 0, "createdate": "2019-07-08T00:00:00", "modifydate": "2019-12-04T17:50:49", "lines": 275, "newlines": 199, "modlines": 0, "user": "DVL"}, "text": "//RXWT002  JOB (1),'REXX-WAIT',\n//*  RESTART=IVP1,\n//             CLASS=A,MSGCLASS=X,REGION=32M,COND=(0,LT)\n//* ?? RXWAIT - wait a number of seconds              ? e ?\n//A  EXEC ASMACL,\n//        PARM.C='TERM',PARM.L='RENT,LIST' ,AMODE(31)\n//C.SYSLIB  DD DISP=SHR,DSN=SYS1.MACLIB\n//          DD DISP=SHR,DSN=SYS1.MODGEN\n//          DD DISP=SHR,DSN=CBT669.LIB\n//C.SYSTERM DD SYSOUT=*\n//C.SYSIN   DD *\n**asma syslib  CBT669.LIB\n*Process compat(macrocase)\n*\n* RXWAIT - wait some seconds\n*\n* Build: 002\n*\n* Syntax\n*  cc=RXWAIT(time-spec)                   REXX function\n*   or\n*  RXWAIT timespec                        TSO cmd\n*   or\n*  // EXEC PGM=RXWAIT,PARM=timespec       batch step\n*\n*    time-spec:\n*      n          seconds\n*      .nn        fractions of seconds\n*      =hhmmssth  hours, minutes, seconds, thousands of seconds\n*      VERSION    return version info (REXX only)\n*\n* Return code\n*  0   ok\n*  8   parameter error\n*\n* Samples\n*  zz=RxWait(10)           /* 10 seconds */\n*  zz=RxWait('=00001000')  /* 10 seconds */\n*  zz=RxWait('=00000050')  /* half of a second */\n*  zz=RxWait('.5')         /* half of a second */\n*  zz=RxWait('.25')        /* quarter of a second */\n*\n* Installation notes:\n*   Fully reentrant, so can (should) be in the lpalib. If not, then\n*   the program will reload itself the first time, thus stay in the\n*   JPAQ.\n*\n* Non-IBM macros:\n*   $CVD     $LA      CDEUCTZ2 EQUATE   MPRINT   MVLIT\n*   REXXMACS WSAMMACS\n*\n* New in this build:\n* 2019-07-08  002  Add '.' and '=' parm formats\n*                  Add CDEUCTZ2 macro to keep lmod in storage\n*                  Allow TSO cmd and batch pgm\n*\n\n         print off\n         Copy  WsamMacs\n         Copy  RexxMacs\n         Copy  SysMacs\n         Copy  RXWTMacs\n         print on\n\n* ------------------------------------------------------------------- *\n* Prolog                                                              *\n* ------------------------------------------------------------------- *\n         lclc  &$module,&basereg,&version\n&version setc  '002'\n&basereg setc  'R11'\n&$module setc  'RXWAIT'\n&$module AMODE 31\n&$module RMODE ANY\n         Equate R\n&$module Csect\n         using &$module,r15\n         j     prolog\n         drop  r15\n$version dc    C'&$module '\n         dc    C'&version &SYSDATC &SYSTIME'\n$versionl equ  *-$version\nProlog   ds    0a\n         bakr  14,0\n         lr    &basereg,r15        set up a base register\n         using &$module,&basereg   establish addressability\n         lnr   r15,r15\n         bassm r15,0                   set amode 31\n\n         STORAGE OBTAIN,LENGTH=LCLSTORL  GET A LOCAL DATA AREA\n         lr    r10,r1              use ldareg (r13) for local data area\n         using lclstor,r10         establish addressability\n         la    r13,sa1\n         mvlit retval,'00000000'\n         mvc   retvall,=a(8)\n         mvc   rc,zero\n         mvi   isrexx,0\n         mvi   istso,0\n*-\n* Keep module in JPAQ for duration of job / TSO session\n*-\n         CDEUCTZ2\n*-\n* Test for TSO user\n*-\n         $Locate jscb\n         if    (lt,r1,JSCBPSCB-IEZJSCB(,r15),nz)\n           mvi   istso,1\n         endif\n*-\n* Init REXX interface\n*-\n         if    (cli,istso,eq,1)\n           ereg  0,1\n           RxInit ,\n           if    (ltr,r0,r0,nz)        REXX init ok?\n             mvi   isrexx,1\n           endif\n         endif\n*-\n* get parm 1\n*-\n         if    (cli,isrexx,eq,1)\n           l     r4,zrx_r1             old r1\n           using efpl,r4               point to parmlist\n           if    (cli,efplarg,eq,x'FF')\n             mvc  rc,=al2(10)\n             j    Back\n           endif\n           l     r5,efplarg\n           drop  r4\n           lm    r14,r15,0(r5)         address and length\n           if    (ltr,r15,r15,z)\n             mvc  rc,=al2(8)\n             j    Back\n           endif\n           bctr  r15,0\n           j     *+10\n           mvc   parm(*-*),0(r14)\n           ex    r15,*-6\n           la    r15,1(,r15)\n         else\n           ereg  0,1\n           getparm parm                r15 = length\n         endif\n         st    r15,parml\n         oc    parm,=cl20' '\n*-\n*        Version\n*-\n         if    (cfi,r15,eq,7),and,(cli,isrexx,eq,1),                   c\n               and,(=c'VERSION',eq,parm)\n             RxRetval $version,$versionl\n             j    Back2\n*-\n*        dintvl format: HHMMSSth\n*-\n         elseif (cli,parm,eq,c'=')     full parm\n           if    (cfi,r15,ne,9)        check length\n             mvc  rc,=al2(9)\n             j    Back\n           endif\n           mvc   dw,parm+1\n           STIMER WAIT,DINTVL=dw\n           j     back\n*-\n*        .fractions\n*-\n         elseif (cli,parm,eq,c'.')     fractions\n           if    (cfi,r15,gt,3)\n             mvc  rc,=al2(8)\n             j    Back\n           endif\n           lr    r3,r15\n           bctr  r15,0\n           bctr  r15,0\n           j     *+10\n           pack  dw,parm+1(*-*)\n           ex    r15,*-6\n           cvb   r2,dw\n           if    (cfi,r3,eq,2)        .n\n             mhi   r2,10              then *10\n           endif\n           st    r2,fw\n           STIMER WAIT,BINTVL=fw\n           j     back\n         elseif (tm,parm,x'f0',o)\n         else\n           mvi   rc+1,8\n           j     back\n         endif\n*-\n*        whole seconds\n*-\n         bctr  r15,0\n         j     *+10\n         pack  dw,parm(*-*)\n         ex    r15,*-6\n         cvb   r2,dw\n         mhi   r2,100                 *100 => seconds\n         st    r2,fw\n         STIMER WAIT,BINTVL=fw\n\n* -------------end of module processing--------------------------------\nBack     Cnop  0,4\n         if    (cli,isrexx,eq,1)\n           lh   r1,rc\n           $cvd  r1,retval,len=8\n           RxRetval retval,f.retvall\n         endif\n\nBack2    Cnop  0,4\n         sr    r5,r5\n         if    (cli,isrexx,eq,0)\n           lh    r5,rc\n         endif\n         l     r13,4(,r13)\n         STORAGE RELEASE,LENGTH=LCLSTORL,ADDR=(R10)\n         lr    r15,r5\n         pr\n\n* -------------fixed data----------------------------------------------\n         Ltorg\n         ds    0a\n\nzero     dc    a(0)\n         ds    0a\n         ltorg\n         ds    0d\n\n* -------------dynamic area--------------------------------------------\n\nLclStor  Dsect\nsa1      ds    18f                     save area\nsaend    equ   *\n*-\nrc       ds    h\nfw       ds    f\ndw       ds    d\nisrexx   ds    x\nistso    ds    x\nparml    ds    a\nparm     ds    cl20\nretval   ds    cl8\nretvall  ds    a\n         RexxMacs ds\n*-\n         ds    0d\nLclStorL equ   *-LclStor\n\n         RexxMacs dsect\n         print nogen\n         IEZJSCB\n*-\n         END\n//*\n//* Production version can be in LPALIB\n//* activate dynamically:\n//*   SETPROG LPA,ADD,MODNAME=RXWAIT,DSNAME=CBT669.LINKLIB\n//*\n//L.SYSLMOD DD DSN=CBT669.LINKLIB(RXWAIT),DISP=SHR\n//*\n//IVP1     EXEC PGM=IKJEFT1B,PARM='RXWTIVP1'\n//STEPLIB  DD DISP=SHR,DSN=*.A.L.SYSLMOD\n//SYSEXEC  DD DISP=SHR,DSN=CBT669.LIB\n//SYSTSPRT DD SYSOUT=*,OUTLIM=1000\n//SYSTSIN  DD DUMMY\n//*\n//IVP2     EXEC PGM=RXWAIT,PARM=6\n//STEPLIB  DD DISP=SHR,DSN=*.A.L.SYSLMOD\n//*\n//IVP3     EXEC PGM=IKJEFT1B\n//STEPLIB  DD DISP=SHR,DSN=*.A.L.SYSLMOD\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD  *\n RxWait 6\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXWTDOC": {"ttr": 8197, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x13\\x01\\x19\\x19\\x0f\\x01\\x19\"?\\x12D\\x00\\x1a\\x00\\x0f\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2019-07-09T00:00:00", "modifydate": "2019-08-11T12:44:13", "lines": 26, "newlines": 15, "modlines": 0, "user": "DVL"}, "text": "RXWAIT - REXX function - wait some seconds or fractions of a second\n\n Syntax\n  cc=RXWAIT(time-spec)                   REXX function\n   or\n  RXWAIT timespec                        TSO cmd\n   or\n  // EXEC PGM=RXWAIT,PARM=timespec       batch step\n\n    time-spec:\n      n          seconds\n      .nn        fractions of seconds\n      =hhmmssth  hours, minutes, seconds, thousands of seconds\n      VERSION    return version info (REXX only)\n\n Return code\n  0   ok\n  8   parameter error\n\n Samples\n  zz=RxWait(10)           /* 10 seconds */\n  zz=RxWait('=00001000')  /* 10 seconds */\n  zz=RxWait('=00000050')  /* half of a second */\n  zz=RxWait('.5')         /* half of a second */\n  zz=RxWait('.25')        /* quarter of a second */\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXWTHIST": {"ttr": 8199, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x16\\x01\\x19\\x19\\x9f\\x01\\x19\\x19\\x9f\\x11U\\x00\\x04\\x00\\x04\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-07-18T00:00:00", "modifydate": "2019-07-18T11:55:16", "lines": 4, "newlines": 4, "modlines": 0, "user": "DVL"}, "text": "History\n001  2017-07-18  Initial version\n002  2019-07-08  Add '.' and '=' parm formats\n                 Add CDEUCTZ2 macro to keep lmod in storage\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXWTIVP1": {"ttr": 8201, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00\\x04\\x01\\x19\\x18\\x9f\\x01\\x19 \\x0f\\x11\\x01\\x00\\x1a\\x00\\x0f\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "2019-07-08T00:00:00", "modifydate": "2019-07-19T11:01:04", "lines": 26, "newlines": 15, "modlines": 0, "user": "DVL"}, "text": " /* rexx */\n\n say RxWait('version')\n zz=Test(3)              /* 3 seconds */\n zz=Test(13)             /* 13 seconds */\n zz=Test('=00001300')    /* hhmmssth 13 seconds   */\n zz=Test('=00000050')    /* hhmmssth .5 seconds   */\n zz=Test('.50')          /* fractions .5 seconds  */\n zz=Test('.5')           /* fractions .5 seconds  */\n zz=Test('.05')          /* fractions .05 seconds */\n zz=Test('.555')        /* -> rc=8  */\n\n say time() 'Testing non-REXX'\n trace r\n zz=time('r')\n \"rxwait 3\"\n trace off\n say time() 'Done, rc' cc+0 time('l') format(time('e'),2,3)\n exit 0\n\nTest:\n zz=time('r')\n cc=RxWait(arg(1))\n if cc>0 then say left(arg(1),10) 'rc' cc+0\n else say left(arg(1),10) 'rc' cc+0 time('l') format(time('e'),2,3)\n return cc\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXWTMACS": {"ttr": 8203, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00S\\x01\\x19 ?\\x01\\x19 ?\\x18\\x04\\x00\\x01\\x00\\x01\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-07-22T00:00:00", "modifydate": "2019-07-22T18:04:53", "lines": 1, "newlines": 1, "modlines": 0, "user": "DVL"}, "text": "* Local macros\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXWTRDME": {"ttr": 8205, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00)\\x01\\x193\\x8f\\x01\\x193\\x8f\\x10&\\x00\\x0e\\x00\\x0e\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-12-04T00:00:00", "modifydate": "2019-12-04T10:26:29", "lines": 14, "newlines": 14, "modlines": 0, "user": "DVL"}, "text": "RXWAIT - REXX function to wait whole or fractions of seconds. May also\nbe used as a TSO command and a batch pgm\n\nDescription of members:\n\n RXWAIT    Product, edit and run this member.\n RXWTDOC   Documentation.\n RXWTHIST  Product history.\n RXWTIVPx  IVPs\n RXWTMACS  Local macros.\n SYSMACS   ASM copy book containing combined non-IBM macros.\n REXXMACS  ASM copy book containing my macros for interfacing with REXX.\n WSAMMACS  ASM copy book containig my structured assembler macro set.\n           The macros are equivalent but not identical to IBM's macros.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SYSMACS": {"ttr": 8207, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00G\\x01\\x19$\\x9f\\x01  O\\x14S\\x13[\\x00\\x03\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2019-09-06T00:00:00", "modifydate": "2020-07-22T14:53:47", "lines": 4955, "newlines": 3, "modlines": 0, "user": "DVL"}, "text": ".* ADD NAME=$LA\n         Macro\n.*-\n.* $LA - build LA instruction (inner macro)\n.*\n.* Returns length in a global variable, length either defined by the\n.* 2rd operand, or computed from the 2nd operand.\n.* Syntax:\n.*   $la  r1,label      -> la    r1,label\n.*   $la  r1,,label     -> la    r1,label\n.*   $la  r1,number     -> lgfi  r1,nnn\n.*   $la  r1,4(,r3)     -> la    r1,4(,r3)                -> length=0\n.*   $la  r1,(r2)       -> lr    r1,r2                    -> length=0\n.*   $la  r1,'kilroy'   -> la    r1,=c'kilroy'\n.*   $la  r1,0          -> slr   r1,r1                    -> length=0\n.*   $la  r1,x.label    -> lx    r1,label  (x: B, F or H) -> length=0\n.* The length is returned in global variable $lalen, the type in\n.* global variable $latype.\n.*\n.* updates\n.* 2017-14-03  numeric value now different from label\n.* 2018-06-16  2rd operand is now alternate src, not global length\n.* 2019-01-11  change global $LALENC\n.*-\n&mlbl    $la   &reg,&psrc,&pasrc,&pasrc2,&glen=,&src2=\n         lcla  &n,&l\n         lclc  &s,&c,&r,&srct,&srcl,&src\n         gbla  &$lalen\n         gblc  &$lalenc\n         gblc  &$latype\n&$lalen  seta  0\n&$lalenc setc ''\n.* select source\n         aif   (k'&psrc   gt 0).setsrc1\n         aif   (k'&pasrc  gt 0).setsrc2\n         aif   (k'&pasrc2 gt 0).setsrc3\n         aif   (k'&src2   gt 0).setsrc4\n         mnote  8,'** $LA mising source'\n.setsrc1 anop\n&src     setc  '&psrc'\n         ago   .setsrcn\n.setsrc2 anop\n&src     setc  '&pasrc'\n         ago   .setsrcn\n.setsrc3 anop\n&src     setc  '&pasrc2'\n         ago   .setsrcn\n.setsrc4 anop\n&src     setc  '&src2'\n.setsrcn anop\n.*\n&s       setc  Upper('&src')\n         aif   ('&s   '(1,3) eq 'L''''').litlen\n&srct    setc  t'&src\n&srcl    setc  Lower('&src')\n.* mnote *,'type &srct'\n.*-\n.* what kind of 1st operand do we have?\n.*-\n         aif   (k'&src gt 0).cp1\n         mnote 8,'src operand missing'\n         mexit\n.cp1     aif   ('&src '(2,1) eq '.').load\n         aif   ('&src' eq '0').clr          clear register\n         aif   ('&src'(1,1) eq '(').reg     register\n         aif   ('&src'(1,1) eq '''').txt    text\n         aif   ('&srct' eq 'N').num        number\n         ago   .lbl\n.*- src is 0, means clear reg\n.clr     anop  ,\n&$latype setc  'CLR'\n&mlbl    slr   &reg,&reg\n         mexit\n.*- src is a number\n.num     anop  ,\n&$latype setc  'NUM'\n&mlbl    lgfi  &reg,&src\n&$lalen  seta  &src\n         mexit\n.*- src is a label or address\n.lbl     anop  ,                           label\n&$latype setc  'LBL'\n&mlbl    la    &reg,&src\n&$lalenc setc  'l''&src'\n&c       setc  t'&src\n         aif   ('&c' ne 'A').setl0\n&n       seta  l'&src\n&$lalen  seta  &n\n         mexit\n.*- src is a register\n.reg     anop  ,                           register\n&$latype setc  'REG'\n&n       seta  (k'&src)-2\n&s       setc  '&src'(2,&n)\n&mlbl    lr    &reg,&s\n&$lalen  seta  1                            default\n         mexit\n.*- src is text\n.txt     anop  ,\n&$latype setc  'TXT'\n&s       setc  '=c&src'\n&mlbl    la    &reg,&s\n&n       seta  (k'&src)-2\n&$lalen  seta  &n\n&$lalenc setc  '&n'\n         mexit\n.*- load from storage\n.load    anop  ,\n.* mnote *,'load'\n&c       setc  Upper('&srcl'(1,1))\n&n       seta  (k'&src)-2\n&s       setc  '&src'(3,&n)\n&$latype setc  'LFS'\n&$lalen  seta  0\n         aif   ('&c' eq 'F' or '&c' eq 'A').loadf\n         aif   ('&c' eq 'H').loadh\n         aif   ('&c' eq 'B').loadb\n         mnote 8,*** invalid load parm &c'\n         mexit\n.loadf   anop  ,\n&mlbl    l     &reg,&s                     load from fullword\n         mexit\n.loadh   anop  ,\n&mlbl    lh    &reg,&s                     load from halfword\n         mexit\n.loadb   anop  ,\n&mlbl    sr    &reg,&reg\n         ic    &reg,&s                     load from byte\n         mexit\n*-\n.litlen  anop\n&n       seta  (k'&src)-4\n&$lalen  seta  &n\n         la    &reg,&n                     length of literal\n         mexit\n*-\n.setl0   anop\n&$lalen  seta  0\n.x       Mend\n.* ADD NAME=#MODULE\n         Macro\n.*\n.* Setup module start - basereg, working storage etc.\n.*\n.* base=(reg1\u00dd,reg2\u00dd,reg3\u00a8\u00a8)      setup up to 3 baseregs\n.* work=(length,label,reg)        acquire dynamic storage\n.* work24=(length,label,reg)      acquire dynamic 24-bit storage\n.* sa=label | *\u00ddn\u00a8                save area label or inline\n.* prolog=address                 address of prolog subroutine\n.* epilog=address                 address of epilog subroutine\n.* end\u00dd,rc=value\u00a8                 return via epilog\n.* return\u00dd,rc=value\u00a8              return via epilog\n.*\n.* Changelog\n.* 2018-10-27  rc value for end can be syslist(2) i.e #module end,123\n.* 2018-11-26  4th parm of work/work24 can be set to 'C' => clear stg\n.* 2019-02-05  use &SYSCLOCK(1,16) instead of &SYSDATE+&SYSTIME\n.*             add &ver option\n.* 2019-02-14  add SYSSTATE OSREL=SYSSTATE,ARCHLVL=OSREL\n.*\n&mlbl    #MODULE &p1,&text=,&ver=,&rc=,&csect=csect,&amode=,&rmode=,   c\n               &base=r12,&sa=,&work=,&work24=,&sp=*future*,            c\n               &prolog=,&epilog=,&xprolog=,&xepilog=,&print=NOGEN\n.*-\n         gblb  &#modequ\n         gbla  &iezbits\n         gblc  &#modname,&#modrmod,&#modamod\n         lcla  &n,&m\n         lclc  &s,&l,&base1,&base2,&base3,&dt\n         lclc  &worksz,&workrg,&worklb,&workloc,&workclr\n&l        setc  '#M&sysndx'\n          aif   (k'&p1 eq 0).nop1\n&s        setc  Upper('&p1')\n          aif   ('&s' eq 'END' or '&s' eq 'RETURN'                     c\n               or '&s' eq 'EXIT').end\n          mnote 8,'*** Invalid p1'\n          mexit\n.nop1     anop\n          aif   (k'&mlbl gt 0).lblok\n          mnote 8,'*** Missing label'\n          mexit\n.lblok    anop\n&#modname setc  '&mlbl'\n&base1    setc  '&base(1)'\n&base2    setc  '&base(3)'\n&base3    setc  '&base(4)'\n&worksz   setc  '&work(1)&work24(1)'\n&worklb   setc  '&work(2)&work24(2)'\n&workrg   setc  '&work(3)&work24(3)'\n&workclr  setc  Upper('&work(4)&work24(4)')\n.*-\n.* Equate regs and bits\n.*-\n         push  print\n         print &print\n&n       seta  0\n         aif   (&#modequ).equregn  bits allready set\n&#modequ setb  1\n.equreg  anop\nr&n      equ   &n\n&n       seta  &n+1\n         aif   (&n le 16).equreg\n.equregn anop\n         aif   (&iezbits ne 0).equbitn  bits allready set\n         IEZBITS\n.equbitn anop\n*-\n* Module start\n*-\n.*       SYSSTATE OSREL=SYSSTATE,ARCHLVL=OSREL\n*-\n&mlbl    amode 31\n&mlbl    rmode any\n&mlbl    &Csect\n         bakr  14,0\n*setup base register(s)\n         lr    &base1,r15\n         using &mlbl,&base1\n         aif   (n'&base eq 1).basen\n         lr    &base(2),&base(1)\n         alfi  &base(2),4096\n         using &mlbl.+4096,&base(2)\n         aif   (n'&base eq 2).basen\n         lr    &base(3),&base(2)\n         alfi  &base(3),4096\n         using &mlbl.+8192,&base(3)\n.basen   anop\n         j     &l.idn\n&dt      setc  '&sysclock'(1,16)       YYYY-MM-DD HH:MM\n         aif   (k'&text eq 0).id\n&n       seta  k'&text\n&s       setc  '&text'(2,&n-2)\n&mlbl._id dc    c'&mlbl&ver &dt &s'\n         ago   .idl\n.id      anop\n&mlbl._id dc    c'&mlbl&ver &dt'\n.idl     anop\n&mlbl._idl equ   *-&mlbl._id\n&l.idn   ds    0a\n.*-\n.* get working storage\n.*-\n         aif   ('&worksz' eq '').workn\n&workloc setc  '31'\n         aif   (k'&work24 eq 0).wrklocn\n&workloc setc  '24'\n.wrklocn anop\n         mnote *,'obtain storage, length=&worksz,loc=&workloc'\n         Storage OBTAIN,length=&worksz,loc=&workloc\n         aif   (k'&workrg eq 0).workn\n         lr    &workrg,r1\n.* clear storage\n         aif   ('&workclr' ne 'C').clrstrn\n         lr    r0,r1                   target\n         lgfi  r1,&worksz              target length\n         la    r14,=al1(0)             source\n         la    r15,1                   source length\n         mvcl  r0,r14                  clear storage\n.clrstrn anop\n.*\n         aif   (k'&worklb eq 0).workn\n         using &worklb,&workrg\n.workn   anop\n.*-\n.* setup save area\n.*-\n         aif   (k'&sa eq 0).saven\n*setup save area\n         aif   ('&sa '(1,1) eq '*').saveint\n         la    r13,&sa\n         ago  .saven\n.saveint cnop  0,4\n&s       setc  '1'\n&n       seta  k'&sa\n         aif   (&n eq 1).savein2\n&s       setc  '&sa'(2,&n-1)\n.savein2 bas   r13,*+(&s*72)+4         address internal save area\n         ds    (&s*18)a                internal save area\n.saven   anop\n.*-\n.* setup prolog\n.*-\n         aif   (k'&prolog ne 0).prologl\n         aif   (k'&xprolog ne 0).prologv\n         ago   .prologn\n.prologl larl  r15,&prolog             prolog address\n         ago   .prologc\n.prologv l     r15,=v(&xprolog)        prolog address\n.prologc basr  r14,r15                 call prolog\n.prologn anop\n         j     &l.X\n.*-\n.* setup termination\n.*-\n* module termination\n&mlbl._X cnop  0,4\n.*-\n.* setup epilog\n.*-\n         aif   (k'&epilog eq 0 and k'&xepilog eq 0).epilogn\n         lr    r2,r15                  copy rc\n         aif   (k'&epilog ne 0).epilogl\n         aif   (k'&epilog ne 0).epilogl\n         aif   (k'&xepilog ne 0).epilogv\n         ago   .epilogn\n.epilogl larl  r15,&epilog             epilog address\n         ago   .epilogc\n.epilogv l     r15,=v(&xepilog)        epilog address\n.epilogc basr  r14,r15                 call epilog\n.epilogn anop\n         aif   ('&worksz' eq '').xworkn\n         mnote *,'release storage, length=&worksz,addr=&workrg'\n         lr    r2,r15\n         Storage RELEASE,length=&worksz,addr=(&workrg)\n         lr    r15,r2\n.xworkn  pr    ,\n* end of termination\n&l.X     ereg  0,1                     reload regs 0 and 1\n*-\n* End of module start\n*-\n         pop   print\n         Mexit\n.*-\n.* return\n.*-\n.end     anop\n&s       setc  '&syslist(2)'\n&mlbl    $la   r15,&rc,&s,0\n         j     &#modname._X\n         Mend\n.* ADD NAME=CLEAR\n         MACRO\n&LBL     CLEAR &A=,&C=C' ',&L=\n         LCLC  &LEN,&ADDR\n&ADDR    SETC  '&A'\n         AIF   (K'&A GT 0).SETL\n&ADDR    SETC  '&SYSLIST(1)'\n.SETL    ANOP\n&LEN     SETC  'L''&ADDR.-1'\n         AIF   (K'&L EQ 0).L0900\n&LEN     SETC  '&L-1'\n.L0900   ANOP\n&LBL     MVI   &ADDR,&C\n         MVC   &ADDR+1(&LEN),&ADDR\n         MEND\n.* ADD NAME=STRC2X\n         MACRO\n.*-\n.* This routine  converts each byte from  an input area to  an output\n.* area in dump  format, so that one byte in  input is represented by\n.* two bytes in output.\n.*\n.* ex. input x'C1' output x'C3F1'\n.*\n.* Syntax\n.*   STRC2X FROM=(addr\u00dd,length\u00a8),TO=addr\u00dd,LEN=length\u00a8\u00dd,CSECT=Y|n\u00a8\n.*        addr      label, (reg) or F.label\n.*        length    value, (reg) or F.label. Default is length of addr\n.*        LEN=      is an alternative to using 2nd operand of FROM=\n.*        CSECT=N   will generate straight code, no subroutine call\n.*        SETLEN=Y  set r0 = output length at termination if CSECT=Y\n.*\n.* If CSECT=Y then the macro calls an internally generated\n.* subroutine. This shortens the code length for multiple\n.* executions of STRC2B, though adds a bit to the program\n.* complexity.\n.*\n.* Registers 14, 15, 0 and 1 are used in the macro proper\n.*\n.* Returns the output length in r0 if CSECT=Y\n.*\n.* Sample, converting 4 bytes of hex value\n.*           StrC2X from=(xvalue,4),to=result\n.*  xvalue   dc    x'2cabc1c94298f0f1fa'\n.*  result   dc    cl(l'cvalue)' '\n.*\n.* Author\n.*     Willy Jensen\n.*     mail: willy@harders-jensen.com\n.*     web : http://harders-jensen.com/wjtech\n.*-\n&name    StrC2X &from=,&to=,&len=,&csect=Y,&setlen=Y\n         lclc  &l,&s,&csct,&sloc\n         gblb  &$STRC2X\n         gblc  &$lalenc\n&l       setc  'C2X&sysndx'\n         aif   (k'&from eq 0).parmmiss\n         aif   (k'&to eq 0).parmmiss\n&csct    setc  upper('&csect')\n         aif   ('&csct'(1,1) eq 'Y').csect1\n.* setup for direct execution\n         $la   r14,&from(1)\n         $la   r15,&from(2),&len,&$lalenc\n         $la   r1,&to\n         ago   .go\n.* setup for subroutine call\n.csect1  anop\n.*call\n.*- make call to module\n         $la   r15,&from(1)\n         $la   r0,&from(2),&len,&$lalenc\n         $la   r1,&to\n         l     r14,=v(ZSTRC2X)\n         basr  r14,r14\n.* StrC2X as module\n         aif   (&$STRC2X).x            already done\n&$STRC2X setb  1\n&sloc    setc  '&sysloc'\nZSTRC2X  Amode 31\nZSTRC2X  Rmode any\nZSTRC2X  CSECT\n         stm   r14,r2,12(r13)\n         basr  r2,0\n         ahi   r2,-6\n         push  using\n         using ZSTRC2X,r2\n.*setup\n         lm    r14,r0,16(r13)          from-addr, from-len, to-addr\n         lr    r1,r0                   to-addr to r1\n.* this is where it happens\n.go      anop\n         sr    r0,r0\n.* upper nibble\n&l.a     ic    r0,0(r14)               insert into workreg one byte\n         srl   r0,4                    shift last four bit away\n         ahi   r0,240\n         cfi   r0,x'fa'                nibble gt 9?\n         jl    *+8\n         ahi   r0,-57                  then use C'A'-C'F'\n         stc   r0,0(r1)\n.* lower nibble\n         ic    r0,0(r14)               insert into workreg one byte\n         sll   r0,28                   leave\n         srl   r0,28                     lower nibble\n         ahi   r0,240\n         cfi   r0,x'fa'                nibble gt 9?\n         jl    *+8\n         ahi   r0,-57                  then use C'A'-C'F'\n         stc   r0,1(r1)\n.* next\n         la    r1,2(,r1)\n         la    r14,1(,r14)\n         bct   r15,&l.a\n         aif   ('&csct'(1,1) ne 'Y').x\n.* end\n         l     r0,20(,r13)\n         sll   r0,1\n         l     r14,12(r13)\n         l     r2,28(r13)\n         bsm   0,r14\n         drop  r2\n         pop   using\n&sloc    Loctr                         resume main\n         Mexit\n.PARMMIS ANOP\n         mnote 12,'Error, parameter(s) missing.'\n         Mexit\n.x       MEND\n.* ADD NAME=STRMAKE\n         Macro\n.* ------------------------------------------------------------------ *\n.*                                                                    *\n.* StrMake                                                            *\n.*                                                                    *\n.* Build a string from literals and fields. Specific position and     *\n.* skips are also possible.                                           *\n.*                                                                    *\n.* Syntax                                                             *\n.*                                                                    *\n.*  STRMAKE fld,.,pos,.,fld,REG=R14|posreg,LR=lenreg,PRINT=print      *\n.*                                                                    *\n.*    fld   (field,length,conversion,out-length)                      *\n.*          length, conversion and out-length are optional.           *\n.*                                                                    *\n.*          field         label, (reg), literal, f.address            *\n.*          length        value, (reg), f|h|b.address                 *\n.*          conversion                                                *\n.*            C2B         storage -> binary c'0' and c'1'             *\n.*            CVD  | C2D  storage -> dec                              *\n.*                        in-length and out-length are reqd           *\n.*            CVDR        register -> dec                             *\n.*                        out-length is required                      *\n.*            CVXD | C2X  hex-> dec, i.e. x'1A' -> c'F1C1'            *\n.*            UNPK | P2D  packed dec i.e. x'0123C' -> c'123'          *\n.*            ST          store register asis (using STCM)            *\n.*            STH         store half of register asis (using STCM)    *\n.*                        out-length is required                      *\n.*          out-length    value, (reg), f|h|b.address                 *\n.*          pos           position in string                          *\n.*                        +n  skip n positions forward                *\n.*                        -n  skip n positions backward               *\n.*                        =n  position at n                           *\n.*                        =B  position at next blank                  *\n.*                                                                    *\n.*    posreg        register pointing to the end of the               *\n.*                  generated string. Default is R14.                 *\n.*    lenreg        register set to length of string                  *\n.*    print         print macro option OFF or NOGEN.                  *\n.*                                                                    *\n.* Registers 14, 15, 0 and 1 may be used internally as work regs, so  *\n.* the 'reg' value should not be any of those.                        *\n.*                                                                    *\n.* Conversion sub-functions typically uses the save are for storing   *\n.* intermediate values, so a save area must be available.             *\n.*                                                                    *\n.* ------------------------------------------------------------------ *\n&mlbl    StrMake &reg=R14,&print=,&lenck=N,&lenreg=,&lr=\n         aif   (k'&mlbl eq 0).mlbl2\n&mlbl    ds    0h\n.mlbl2   anop\n         aif   (k'&print eq 0).pr1n\n         push  print\n         print &print\n.pr1n    anop\n         lcla  &pix,&litl,&incr,&n,&mvcn\n         lclc  &str,&fld,&srcl,&cnv,&src,&srcu,&tgt,&tgtl,&s,&lbl,&outl\n         lclc  &mask,&lb1,&r,&lm(4),&unpkadr,&strl\n         gblc  strmakea,strmakel,&strp2dl\n&lm(1)   setc  '1'\n&lm(2)   setc  '3'\n&lm(3)   setc  '7'\n&lm(4)   setc  '15'\n.*\n.* output string address\n.*\n&str     setc  '&syslist(1,1)'\n         aif   ('&str' eq '*').setstrn\n         aif   (k'&str eq 0).setstrn\n         $la   &reg,&str               ->str\n&strl    setc  '&syslist(1,2)'\n         aif   (k'&strl ne 0).strl2\n&strl    setc  'l''&str'\n.strl2   anop\n&strmakea setc '&str'                  remember address\n&strmakel setc '&strl'                 remember length\n.setstrn anop\n.*-\n.* do over parmlist\n.*-\n&pix     seta  1\n.scan    anop\n&lbl     setc  'SM&sysndx.#&pix'\n&pix     seta  &pix+1\n         aif   (&pix gt n'&syslist).quit\n&src     setc  '&syslist(&pix,1)'\n&srcu    setc  (UPPER '&src')\n&srcl    setc  '&syslist(&pix,2)'\n         aif   (k'&srcl ne 0).srcl2\n&srcl    setc  'l''&src'\n.srcl2   anop\n&cnv     setc  (UPPER '&syslist(&pix,3)')\n&outl    setc  '&syslist(&pix,4)'\n.* junction 1\n         aif   ('&src '(1,1) ne '=').tpositn\n         aif   ('&src '(2,1) eq '(').posit     position in register\n&n       seta  k'&src\n&s       setc  '&src'(2,&n-1)\n         aif   (t'&s eq 'N').posit\n.tpositn anop\n         aif   ('&srcu'(1,2) eq '=B').posbl\n         aif   (T'&src eq 'N').posit\n         aif   ('&src'(1,1) eq '+').skip\n         aif   ('&src'(1,1) eq '-').skipb\n.* the width check is not very good, but better than nothing\n&s       setc  Upper('&lenck ')\n         aif   ('&s'(1,1) ne 'Y' and n'&syslist(1) lt 2).lenckn\n         $la   r15,&strmakea\n         $la   r0,&strmakel\n         ar    r15,r0\n         $la   r0,&outl,&srcl\n         ar    r0,&reg                    -> after insert\n         cr    r0,r15\n         jl    &lbl.s\n         mvi   0(r14),c'+'\n&s       setc  'SM&sysndx.Q'\n         j     &s\n&lbl.s   equ   *\n.lenckn  anop\n.* width check end\n.* junction 2\n         aif   ('&src '(1,1) eq '''').lit\n         aif   (k'&cnv eq 0).mvc\n         aif   ('&cnv' eq 'CVD').c2d      binary to decimal\n         aif   ('&cnv' eq 'C2D').c2d              -\n         aif   ('&cnv' eq 'CVDR').cvdr    binary in reg to decimal\n         aif   ('&cnv' eq 'P2D').p2d      packed dec -> zoned\n         aif   ('&cnv' eq 'UNPK').p2d             -\n         aif   ('&cnv' eq 'C2B').c2b      byte to readable bits\n         aif   ('&cnv' eq 'C2X').c2x      hex to readable hex\n         aif   ('&cnv' eq 'CVX').c2x              -\n         aif   ('&cnv' eq 'CVXD').c2x             -\n         aif   ('&cnv' eq 'ST').st        store register\n         aif   ('&cnv' eq 'STH').sth      store register halfword\n         mnote 8,'invalid format: &cnv'\n         ago   .quit\n.*-\n.* src is a field\n.* 'outl' is max length\n.*-\n.mvc     anop\n         $la   r15,&srcl\n         ltr   r15,r15\n         jz    &lbl.N                        no data\n         aif   (k'&outl eq 0).mvc2\n         $la   r0,&outl\n         ltr   r0,r0                         zsro => no check\n         jz    &lbl.cf1\n         cr    r15,r0\n         jnh   &lbl.cf1\n         lr    r15,r0\n.mvc2    anop\n&lbl.cf1 cfi   r15,256\n         jh    &lbl.l                        long string\n         bctr  r15,0\n         $la   r1,&src\n         mvc   0(*-*,&reg),0(r1)\n         ex    r15,*-6\n         la    &reg,1(r15,&reg)\n         j     &lbl.n\n&lbl.l   equ   *\n         stm   r14,r15,12(r13)\n         lr    r0,&reg                       -> target\n         $la   r14,&src                      -> source\n         lr    r1,r15                        copy length\n         mvcl  r0,r14\n         lm    r14,r15,12(r13)\n         ar    &reg,r15\n&lbl.n   equ   *\n         ago   .scan\n.*-\n.* Convert hex value in register to decimal\n.*-\n.cvdr    anop                               source is register\n         cvd   &src,16(r13)\n         unpk  0(&outl,&reg),16(8,r13)\n         oi    &outl-1(&reg),x'f0'\n         la    &reg,&outl.(,&reg)\n         ago   .scan\n.*-\n.* Convert hex in string to decimal\n.*-\n.c2d     anop\n         st    &reg,68(,r13)               save pos\n         lr    r0,&reg                     preserve r14\n         StrC2d call,from=(&src,&srcl),to=((r0),&outl)\n         l     &reg,68(,r13)               load pos\n         ar    &reg,r0\n         ago   .scan\n.*-\n.* packed dec field\n.*-\n.p2d     anop                              packed dec\n         st    &reg,68(,r13)               save pos\n         lr    r0,&reg\n         StrP2D call,from=(&src,&srcl),to=((r0),&outl)\n         l     &reg,68(,r13)               load pos\n         ar    &reg,r0\n         ago   .scan\n.*-\n.* hex-to-char\n.*-\n.c2x     anop\n         st    &reg,68(,r13)               save pos\n.* preserve r14\n         lr    r1,&reg                     to addr\n.*  r14=from,r15=to,r0=len\n         StrC2X call,from=(&src,&srcl),to=(r1),setlen=Y\n         l     &reg,68(,r13)               load pos\n         ar    &reg,r0                     update pos\n         ago   .scan\n.*-\n.* byte to bits\n.*-\n.c2b     anop\n         st    &reg,68(,r13)               save pos\n         StrC2B call,from=&src,to=(&reg)\n         l     &reg,68(,r13)               load pos\n         la    &reg,8(,&reg)\n         ago   .scan\n.*-\n.* literal\n.*-\n.lit     anop\n         aif   (k'&src eq 3).lit100        one char\n&litl    seta  k'&src-2\n         mvc   0(&litl,&reg),=c&src\n         la    &reg,&litl.(,&reg)\n         ago   .scan\n.lit100  anop\n         mvi   0(&reg),c&src\n         la    &reg,1(,&reg)\n         ago   .scan\n.*-\n.* store register\n.*-\n.st      anop\n         stcm  &src,15,0(&reg)\n         la    &reg,4(,&reg)\n         ago   .scan\n.*-\n.* store lower half of register\n.*-\n.sth     anop\n         stcm  &src,3,0(&reg)\n         la    &reg,2(,&reg)\n         ago   .scan\n.*-\n.* skip\n.*-\n.skip    anop\n&s       setc  '&src'(2,k'&src-1)\n         ahi   &reg,&s\n         ago   .scan\n.skipb   anop\n&s       setc  '&src'(2,k'&src-1)\n         ahi   &reg,-&s\n         ago   .scan\n.*-\n.* position pointer in string\n.*-\n.posit   anop\n&c       setc  '&src'(2,k'&src-1)\n.*       la    &reg,&strmakea+&c-1\n         $la   &reg,&strmakea\n         $la   r15,&c\n         bctr  r15,0\n         ar    &reg,r15\n         ago   .scan\n.*-\n.* position at next blank\n.*-\n.posbl   anop\n         cli   0(&reg.),c' '\n         bne   *+8\n         bct   &reg.,*-8\n         la    &reg.,1(,&reg.)\n         ago   .scan\n.*-\n.* end of macro\n.*-\n.quit    anop\n&r       setc  '&lenreg&lr'\n         aif   (k'&r eq 0).lenregn\n         $la   r0,&strmakea\n.*       sr    r14,r0\n.*       lr    r0,r14                    copy gend length\n         lr    &r,r14\n         sr    &r,r0                     set length\n.lenregn anop\n         aif   (k'&print eq 0).pr2n\n         pop  print\n.pr2n    anop\n&s       setc  'SM&sysndx.Q'\n&s       ds    0h\n         Mend\n.* ADD NAME=$CVD\n         MACRO\n.*\n.* Convert value in register to decimal string\n.*\n.* Syntax\n.*   $CVD addr,REG=reg,LEN=len\n.*   $CVD reg,addr\u00dd,len\u00a8\n.*        addr must be a address or a register (r)\n.*\n         $CVD  &REG=,&LEN=\n         lclc  &dest,&ln,&r,&t\n         lcla  &n\n.*\n&ln      setc  '&len'\n         aif   (n'&syslist ge 2).parm2\n&r       setc  '&reg'\n&dest    setc  '&syslist(1)'\n         ago   .parmend\n.parm2   anop\n&r       setc  '&syslist(1)'\n&dest    setc  '&syslist(2)'\n         aif   (k'&len gt 0).parmend\n&ln      setc  '&syslist(3)'\n.parmend anop\n.* t'dest = C if address, U if register (r)\n.*\n         aif   (k'&r eq 0).regmiss\n         aif   (k'&ln gt 0).lnn\n&ln      setc  '4'\n.lnn     anop\n         cvd   &r,56(r13)\n         aif   ('&dest'(1,1) eq '(').destr\n         unpk  &dest.(&ln),56(8,r13)\n         oi    &dest+&ln-1,x'f0'\n         mexit\n.destr   anop\n&n       seta  k'&dest-2\n&dest    setc  '&dest'(2,&n)\n         unpk  0(&ln,&dest),56(8,r13)\n         oi    &ln-1(&dest),x'f0'\n         mexit\n.regmiss mnote  8,'*** error - missing register spec'\n         mexit\n         MEND\n.* ADD NAME=#MODEND\n         Macro\n.*\n.* companion to #MODULE, set rc and jump to termination routine\n.*\n&mlbl    #MODEND &rc=\n&mlbl    #MODULE END,RC=&rc&syslist(1)\n         Mend\n.* ADD NAME=#SUBR\n         Macro\n.*-\n.* Subroutine infrastructure\n.*\n.* Syntax\n.*   label SUBR action,parameters\n.*\n.*   Action description\n.*     CSECT | LABEL   subroutine start\n.*     EXIT | END      subroutine return\n.*     DROP            drop registers, do ltorg\n.*     CALL            call subroutine\n.*     SET             set defaults\n.*     EREG            restore regs 0 and 1 (simulate EREG instr)\n.*\n.*   Note - for each CSECT there must be a DROP later\n.*\n.* Some defaults can be changed by the #SUBR SET invocation:\n.*   base sa saend rcfield entry\n.*\n.* Changelog\n.* 2018-10-27  Rc value for end can be syslist(2) i.e #subr end,123\n.* 2018-10-30  Add DROP\n.* 2019-10-02  Restructure the handling of multiple base regs\n.*             Add PUSH using and POP USING, making DROP neccessary.\n.*\n.* Sample\n.*\n.*           #subr call,sub1\n.*           . . .\n.*  sub1     #subr csect,sa=sa2,xprolog=sub1pro,xepilog=sub1epi\n.*           . . .\n.*           open  (dcb1,(OUTPUT))\n.*           . . .\n.*           #subr end,rc=1\n.*           . . .\n.*           #subr end,rc=2\n.*           #subr drop\n.*           . . .\n.*  sub1pro  #subr csect,base=r6,sa=sa3\n.*           . . .\n.*           #subr exit\n.*           #subr drop\n.*           . . .\n.*  sub1epi  #subr csect,base=r6,sa=sa3\n.*           close dcb1\n.*           #subr exit\n.*           #subr drop\n.*-\n&mname   #SUBR &p1,&base=,                                             c\n               &sa=,&saend=,&drop=,                                    c\n               &prolog=,&epilog=,&xprolog=,&xepilog=,                  c\n               &rcfield=,&rc=,&entry=,&upcase=,&print=\n.*-\n         gblc  &#subrname,&#subrsaend,&#subrbase,&#subrrcfld\n         gblc  &#subrentry,&#subrsa,&gblsetp\n         gblc  &#modrmod\n         gblb  &subrexit\n         lclc  &name,&what,&r,&s,&l,&mcsect,&msaend\n         lcla  &n\n&l       setc  'sx&sysndx'\n&name    setc  (UPPER '&mname')\n.*-\n         GblSetP &p1,&#subrentry,LABEL,upcase=YES,no=NULL\n&what    setc  '&gblsetp'\n         aif   ('&what' eq 'LABEL').label\n         aif   ('&what' eq 'ENTRY').csect\n         aif   ('&what' eq 'CSECT').csect\n         aif   ('&what' eq 'EXIT').exit\n         aif   ('&what' eq 'END').exit\n         aif   ('&what' eq 'CALL').call\n         aif   ('&what' eq 'EREG').ereg\n         aif   ('&what' eq 'DROP').drop\n         aif   ('&what' eq 'SET').set\n         mnote  8,'**Invalid entry type'\n         mexit\n.*-\n.* Entry label\n.*-\n.label   anop\n         Entry &mname\n&mname   cnop  0,4\n         stm   14,12,12(r13)\n         ago   .start\n.*-\n.* Entry csect\n.*-\n.csect   anop\n         aif   (k'&print eq 0).csectp1n\n         push  print\n         print &print\n.csectp1n anop\n         Push  Using\n&name    amode 31\n&name    rmode any\n.csect2  anop\n&name    Csect\n         stm   14,12,12(r13)\n         aif   (k'&base gt 0).base1\n         lr    &#subrbase,r15\n         using &name,&#subrbase\n         ago   .basen\n.*-\n.base1   anop\n&r       setc '&base(1)'\n         lr    &r,r15                set local base\n         using &name,&r\n         aif   (n'&base eq 1).basen\n&s       setc '&base(2)'\n         lr    &s,&r\n         alfi  &s,4096\n         using &name.+4096,&s\n         aif   (n'&base eq 2).basen\n&s       setc '&base(3)'\n         lr    &s,&r\n         alfi  &s,8192\n         using &name.+8192,&s\n.basen   anop\n.*-\n.start   anop\n&#subrname setc '&name'\n         j     *+12\n&name._id dc    cl8'&name'\n&subrexit setb 0\n.*-\n.* setup save area\n.*-\n.sa      anop\n         GblSetP &sa,&#subrsa,next,upcase=yes,no=NULL\n         aif   (k'&gblsetp eq 0).san\n         aif   ('&gblsetp' eq 'NEXT').sanxt\n         aif   ('&gblsetp' eq '*').sainl\n         la    r14,&gblsetp\n         ago   .sachn\n.sanxt   anop\n         la    r14,72(,r13)            -> next sa slot\n.* save area check\n         GblSetP &saend,&#subrsaend,no=NULL\n         aif   (k'&gblsetp eq 0).saendn\n         la    r15,&gblsetp            check\n         cr    r14,r15                  inside\n         jl    *+10                      save\n         la    r1,888                     arealist\n         svc   13                      or else..\n.saendn  anop\n         ago   .sachn\n.sainl   anop\n         cnop  0,4\n         bas   r13,*+76\n         ds    18a\n         ago   .sachn\n.* save area chaining\n.sachn   anop\n         st    r14,8(,r13)             ->\n         st    r13,4(,r14)             <-\n         lr    r13,r14\n.san     anop\n.* call prolog\n         aif   (k'&prolog ne 0).prologl\n         aif   (k'&xprolog ne 0).prologv\n         ago   .prologn\n.prologl larl  r15,&prolog             prolog address\n         ago   .prologc\n.prologv l     r15,=v(&xprolog)        prolog address\n.prologc basr  r14,r15                 call prolog\n.prologn anop\n.* end of start\n         j     &l.N\n.* setup return\n&name._X equ  *\n.* update rc field\n         GblSetP &rcfield,&#subrrcfld,no=NULL\n         aif   (k'&gblsetp eq 0).rcfldn\n         c     r15,&gblsetp            if rc gt stored\n         jl    *+8                      then\n         st    r15,&gblsetp              replace stored\n.rcfldn  anop\n.* call epilog\n         aif   (k'&epilog eq 0 and k'&xepilog eq 0).epilogn\n         lr    r2,r15                  copy rc\n         aif   (k'&xepilog ne 0).epilogv\n.epilogl larl  r15,&epilog             epilog address\n         ago   .epilogc\n.epilogv l     r15,=v(&xepilog)        epilog address\n.epilogc basr  r14,r15                 call epilog\n.epilogn anop\n.* unchain sa and return\n         l     r13,4(,r13)             <- prev save\n         l     r14,12(r13)             return addr\n         lm    2,12,28(r13)\n         br    r14\n.* continue mainline\n&l.N     equ  *\n         aif   (k'&print eq 0).csectp2n\n         pop   print\n.csectp2n anop\n         Mexit\n.*-\n.* Exit\n.*-\n.Exit    anop\n&s       setc  '&syslist(2)'\n&name    $la   r15,&rc,&s,0\n         j     &#subrname._X\n&s       setc  '&drop '(1,1)\n         aif   ('&s' ne 'Y').x\n         #subr drop\n         Mexit\n.*-\n.* Call\n.*-\n.Call    anop\n&name    setc  '&syslist(2)'\n         l     r15,=V(&name)\n         basr  r14,r15\n         ltr   r15,r15\n         Mexit\n.*-\n.* Ereg - restore regs 0 and 1 (simulate EREG instr)\n.*-\n.Ereg    anop\n         l     r1,4(,r13)              <- old sa\n         lm    r0,r1,20(r1)            reload\n         Mexit\n.*-\n.* Drop #subr basereg\n.*-\n.Drop    anop\n         ltorg\n.*       drop  &#subrbase\n         Pop   Using\n         Mexit\n.*-\n.* Set globals\n.*-\n.Set     anop\n&#subrbase  setc '&base'\n&#subrsa    setc '&sa'\n&#subrsaend setc '&saend'\n&#subrrcfld setc '&rcfield'\n&#subrentry setc '&entry'\n         Mexit\n.*-\n.x       Mend\n.* ADD NAME=#SUBREND\n         Macro\n.*\n.* companion to #SUBR, set rc and execute #SUBR termination\n.*\n&mlbl    #SUBREND &rc=\n&mlbl    #SUBR END,RC=&rc&syslist(1)\n         Mend\n.* ADD NAME=CDEUCTZ2\n         Macro\n.*\n.* Bump program use count (IHACDE CDUSE) to keep program in JPAQ.\n.* This will improve performance of an often loaded program\n.* significantly.\n.* For reentrant and optionally serially reusable programs.\n.*\n.* Syntax\n.*\n.*  label  CDEUCTZ2 \u00ddBASE=reg\u00a8\u00dd,SER=Y\u00a8\u00dd,DSECT=N\u00a8\u00dd,PRINT=OFF|NOGEN\u00a8\n.*         reg       Basereg for main module. Default is determined\n.*                   basereg when macro is expanded.\n.*         SER=Y     Change uct for serially reusable module too.\n.*         DESCT=N   Do not include DSESCTs in the macro expansion.\n.*                   The DSECTs are\n.*                      IKJTCB DSECT=YES\n.*                      IHAPSA DSECT=YES\n.*                      IHACDE\n.*         PRINT=    Print option for DSECT expansions.\n.*                   Default is NOGEN.\n.*\n.* Sample\n.*\n.*         YREGS\n.*   A     Csect\n.*         bakr  r14,r0\n.*         lr    r9,r15\n.*         Using A,r9\n.*         CDEUCTZ2\n.*\n.* Performance\n.*\n.*  A small performance  test when CDEUCTZ2 is used in  a program run\n.*  in  an REXX  exec  to scan  36  records 100  times  for a  match.\n.*   The  program is  RXPATTRN  and  can be  found  at  the web  site\n.*  mentioned below.\n.*\n.*                        EXCP   CONN    TCB\n.*  CDEUCTZ2 disabled     7284      0   1.35\n.*  CDEUCTZ2 enabled        90      0    .09\n.*  Running from LPA        51      0    .14\n.*\n.* Author\n.*     Willy Jensen\n.*     mail: willy@harders-jensen.com\n.*     web : http://harders-jensen.com/wjtech\n.*-\n&ml      CDEUCTZ2 &base=*,&wto=N,&ser=N,&dsect=Y,&print=NOGEN\n         lclc  &l,&s,&br\n&l       setc  'CT&sysndx'\n         using tcb,r14\n         using cdentry,r15\n&ml      l     r14,psatold-psa(0,0)    -> my tcb\n         l     r14,tcbjstcb            job-step tcb\n         l     r15,tcbjpq              my cde\n         drop  r14                     TCB\n         cli   cduse+1,1               first time through?\n         jne   &l.999                  no, jump\n&s       setc  Upper('&ser')\n         aif   ('&s '(1,1) ne 'Y').cdattrr\n         tm    cdattr,cdren+cdser      reentrant or reuseable ??\n         ago   .cdattrn\n.cdattrr tm    cdattr,cdren            reentrant ??\n.cdattrn anop\n         jz    &l.999                  no, jump\n.* do basereg test\n         aif   ('&base' ne '*').base2  specific base (we hope)\n         j     &l.e\n&l.C     c     r0,cdentpt              executed, check cde\n&l.D     dc    sl2(*)                  basereg + offsett\n&l.E     sr    r1,r1\n         ic    r1,&l.d                 load basereg+offsett\n         srl   r1,4                    leave basereg\n         sll   r1,4                    for execute\n         ex    r1,&l.c                 check base against cdentpt\n         ago   .base3\n.base2   c     &base,cdentpt           my cde?\n.base3   jne   &l.999                  no, jump\n.* all seems ok, do load\n         load  eploc=cdname            bump my own use count\n         drop  r15                     CDE\n&s       setc  Upper('&wto')\n         aif   ('&s' ne 'Y').wton\n         wto   'use count bumped'      for debugging\n.wton    anop\n&l.999   equ   *\n.* dsects\n&s       setc  Upper('&dsect')\n         aif   ('&s' ne 'Y').dsectn\n*dsects\n&s       setc  '&sysect'\n         Push  print\n         Print &print\n         gblb  &$DSCT_IKJTCB,&$DSCT_IHAPSA,&$DSCT_IHACDE\n         aif   (&$DSCT_ikjtcb).dsect2\n         IKJTCB DSECT=YES\n&$DSCT_IKJTCB setb 1\n.dsect2  aif   (&$DSCT_IHAPSA).dsect3\n         IHAPSA DSECT=YES\n&$DSCT_IHAPSA setb 1\n.dsect3  aif   (&$DSCT_IHACDE).dsect4\n         IHACDE\n&$DSCT_IHACDE setb 1\n.dsect4  Pop  print\n*dsects end\n&s       Csect\n.dsectn  anop\n.*-\n.x       Mend\n.* ADD NAME=CLRLONG\n         Macro\n         ClrLong\n.* clear up to 16M storage area\n.* operand 1 -> target\n.* operand 2 =  target size\n.* operand 3 =  pad chr, optional, defalt is x'00'\n         lclc  &pad\n         gblc  &$lalenc\n         $la   r0,&syslist(1)          address\n         $la   r1,&syslist(2),l'&syslist(1)\n         sr    r14,r14                 null source\n         sr    r15,r15                 null source length\n         aif   (n'&syslist lt 3).padn\n&pad     setc  '&syslist(3)'\n         la    r15,&pad\n         sll   r15,24\n.padn    anop\n         mvcl  r0,r14                  clear\n         Mend\n.* ADD NAME=ESTAEXX\n         Macro\n.*-\n.*\n.* Extended ESTAE - recover system and user abends\n.*\n.* Syntax\n.*   ESTAEXX action,ADDR=reta\n.*    action  A | ACTVATE  Activate intercept, SETADDR required\n.*            C | CANCEL   Stop intercept\n.*            S | SET      Set retaddr\n.*            DS           Data area\n.*          ( R | RESET    Reset retaddr and regs to initial - future)\n.*    reta    address of where to continue after intercept\n.*\n.*    Note, ACTIVATE, SET and RESET will save all registers, they\n.*    are restored to this value when the recovery routine is\n.*    invoked.\n.*\n.*  Sample\n.*\n.*             Estaexx activate,retaddr=recover\n.*             . . .\n.*             Estaexx set,retaddr=rcv0c1\n.*             . . .\n.*             dc    X'0000'\n.*    rcv0c1   ds    0a                  estae re\n.*             ESTAEXX cancel\n.*             . . .\n.*    recover  ds    0h                  estae retry routine\n.*             ESTAEXX cancel\n.*             . . .\n.*             Estaexx ds\n.*\n.* History\n.* 2019-10-07  Initial\n.* 2019-10-12  Add field estxtext for formatted abend info\n.*-\n&mlbl    ESTAEXX &addr=,&retaddr=,&print=nogen,&dsect=Y\n         lclc  &c,&p,&s,&l,&lbl,&csct,&addrp\n&addrp   setc  '&addr&retaddr'     allow both operands\n         gblb  &estaexx\n&l       setc  'ZE&sysndx'\n&p       setc  Upper('&syslist(1)')\n         aif   ('&p' eq 'DS').ds\n         aif   (&estaexx).modtn\n&estaexx setb  1\n         j     &l.md\n         ago   .mod\n.moddone anop\n&l.md    cnop  0,4\n.modtn   anop\n&p       setc  Upper('&syslist(1)')\n         aif   ('&p' eq 'A' or '&p' eq 'ACTIVATE').act\n         aif   ('&p' eq 'C' or '&p' eq 'CANCEL').can\n.*       aif   ('&p' eq 'R' or '&p' eq 'RESET').res\n         aif   ('&p' eq 'S' or '&p' eq 'SET').set\n         mnote 8,'**Invalid or missing action'\n         mexit\n.*- Activate\n.act     anop\n&mlbl    mvc   estxeye,=c'ESTX'\n         mvi   estxdone,c'N'\n         la    r15,&addrp\n         st    r15,estxreta        current return address\n         stm   r0,r15,estxregs     save all registers\n.*       st    r15,estxreto        original return address\n.*       stm   r0,r15,estxrego     save all registers\n         l     r15,=v(zEstxmod)\n         ESTAEX (r15),CT,param=estxblk,mf=(E,estxmfl)\n         mexit\n.*- Cancel\n.can     anop\n&mlbl    lt    r15,estxreta\n         jz    &l.b\n         ESTAEX 0\n&l.b     xc    estxreta,estxreta\n         mexit\n.*- Set return address\n.set     anop\n&mlbl    la    r15,&addrp\n         st    r15,estxreta        current return address\n         stm   r0,r15,estxregs     save all registers\n         mexit\n.*- Reset return address\n.res     anop\n&mlbl    mvc   estxreta,estxreto   restore retry addr\n         mvc   estxregs,estxrego   restore registers\n         mexit\n.*- Data area\n.ds      anop\nestxblk  ds    0a\nestxeye  ds    cl4                 'ESTX'\nestxdone ds    c                   prevent loop\nestxmfl  ESTAEX ,MF=L              data list\nestxmfll equ   *-estxmfl\nestxcode ds    a\nestxsys  equ   estxcode,2          system abend\nestxusr  equ   estxcode+2,2        user abend\nestxrsn  ds    a\nestxname ds    cl8                 pgm name\nestxpsw  ds    xl8                 ec mode psw\nestxreta ds    a                   current return address\nestxregs ds    16a                 save registers\n.*txreto ds    a                   return address at activate\n.*txrego ds    16a                 save registers\nestxtext ds    cl16                formatted abend info\n.* test model\n.* ----+----1----+----2----+----3----+----4----+----5----+\n.* S0C1 00CF6618    GO       078D00009E80025A\n         mexit\n.*- Recovery routine\n.mod     anop\n         ltorg\n*-\n*  ESTAEXX recovery routine\n*-\n&sect    setc  '&sysloc'\n mnote *,'ESTAEXX mod - sysloc: &sect'\n         push  using\n         drop  ,\nzEstxmod amode 31\nzEstxmod rmode any\nzEstxmod Csect\n         push  print\n         print &print\n         using zEstxmod,r15        map code page for estxe recrtn\n         cfi   r0,12               sdwa exist ?\n         jne   zEstxmgo            yes, go on\n         wto   'no SDWA'\n         sr    r15,r15             rc=0 => continue with error\n         br    r14\n* SDWA provided\nzEstxmgo save (14,12)\n         lr    r5,r15              copy estae rec rtn epa to base\n         drop  r15\n         using zEstxmod,r5         map code page for estxe recrtn\n         lr    r3,r1               copy sdwa ptr\n         using SDWA,r3             map sdwa\n.*       wto   'Estx-recov'\n         using estxblk,r2\n         clc   =c'ESTX',estxeye\n         jne   zEstxmne\n         cli   estxdone,c'Y'\n         je    zEstxm2t\n.*       mvi   estxdone,c'Y'\n* save abend and reason codes and info\n         l     r15,SDWAABCC\n         sll   r15,8\n         srl   r15,20\n         sth   r15,estxsys\n         l     r15,SDWAABCC\n         sll   r15,20\n         srl   r15,20\n         sth   r15,estxusr\n         l     r1,SDWAXPAD         -> SDWAPTRS\n         l     r1,0(,r1)           -> SDWARC1\n         mvc   estxrsn,SDWACRC-SDWARC1(r1) copy reason code\n         lt    r1,estxrsn          was there a code?\n         jnz   *+10                yes\n         mvc   estxrsn,SDWAGR15    else use r15\n         mvc   estxname,=cl8' '\n         cli   SDWANAME,x'00'\n         je    *+10                not a valid name\n         mvc   estxname,SDWANAME   pgm name\n         mvc   estxpsw,SDWAEC1     extended mode psw\n* build readable abend text\n         mvi   estxtext,c' '\n         mvc   estxtext+1(l'estxtext-1),estxtext\n         la    r7,c'S'\n         la    r14,estxsys\n         icm   r1,3,estxusr            user abend?\n         jz    *+12                    yes\n         la    r7,c'U'\n         la    r14,estxusr\n         la    r15,2                   input length\n         la    r1,estxtext\n         bal   r9,zEstxmxd\n         stc   r7,estxtext\n* build readable reason code\n         la    r14,estxrsn\n         la    r15,4\n         la    r1,estxtext+5\n         bal   r9,zEstxmxd\n.* * get name and psw\n.*          mvc   estxtext+17(8),estxname\n.*          la    r14,estxpsw\n.*          la    r15,8                   input length\n.*          la    r1,estxtext+26\n.*          bal   r9,zEstxmxd\n* recover/retry\n         mvc   SDWASRSV,estxregs   restore regs 0-15\n         lr    r1,r3               -> SDWA\n         l     r4,estxreta\n         SETRP RETADDR=(r4),       retry routine                       c\n               RC=4,               request retry                       c\n               REMREC=NO,          remove this intercept YES/NO        c\n               FRESDWA=YES,        free the sdwa storage               c\n               WKAREA=(r3),        sdwa                                c\n               RECORD=YES,DUMP=NO, record error to logrec              c\n               RETREGS=YES\n         j     zEstxmx\n* do not recover\nzEstxmne wto   'eye not found'\n         j     zEstxmsr\nzEstxm2t wto   '2nd time around'\nzEstxmsr lr    r1,r3               -> SDWA\n         SETRP RC=0,               do not retry                        c\n               WKAREA=(r3),        sdwa                                c\n               RECORD=NO,DUMP=NO,  no recording                        c\n               RETREGS=NO\nzEstxmx  l     r14,12(,r13)\n         sr    r15,r15             request no-retry\n         return (2,12)             return from recovery rtn\n         ltorg\n* subroutine, convert binary to printable. return via r9\nzEstxmxd ds    0h\n         sr    r0,r0\n.* upper nibble\n         ic    r0,0(r14)               insert into workreg one byte\n         srl   r0,4                    shift last four bit away\n         ahi   r0,240\n         cfi   r0,x'fa'                nibble gt 9?\n         jl    *+8\n         ahi   r0,-57                  then use C'A'-C'F'\n         stc   r0,0(r1)\n.* lower nibble\n         ic    r0,0(r14)               insert into workreg one byte\n         sll   r0,28                   leave\n         srl   r0,28                     lower nibble\n         ahi   r0,240\n         cfi   r0,x'fa'                nibble gt 9?\n         jl    *+8\n         ahi   r0,-57                  then use C'A'-C'F'\n         stc   r0,1(r1)\n.* next\n         la    r1,2(,r1)\n         la    r14,1(,r14)\n         bct   r15,zEstxmxd+2\n         br    r9\n         pop   using\n.*\n&s       setc  Upper('&dsect')\n         aif   ('&s' ne 'Y').dsctn\n         IHASDWA\n.dsctn   anop\n         pop   print\n&sect    loctr\n         ago   .moddone\n.*- End\n.x       Mend\n.* ADD NAME=GBLSETP\n         Macro\n         GblSetP &no=,&upcase=,&listval=\n.* Set a global variable to the first non-blank parameter\n.* This is an called macro (subroutine).\n.* syntax: parm1,parm2,..,parmn\n.*\n.* Sample:\n.*         Macro\n.*         TestSetP &anchor=\n.*         gblc  &gblsetp\n.*         lclc  &lanchr\n.*         GblSetp &anchor,&anchor,*\n.*         Mend\n.*         TestSetP     -> &gblsetp='*'\n.*         TestSetP f1  -> &gblsetp='f1'\n.*\n         gblc  &gblsetp\n         lcla  &n\n         lclc  &p,&s\n&pupper  setc  Upper('&upcase')\n&n       seta  1\n.gblset1 anop\n&gblsetp setc  '&syslist(&n)'\n         aif   (k'&gblsetp ne 0).gblset2\n&n       seta  &n+1\n         aif   (&n le n'&syslist).gblset1\n         mexit\n.gblset2 anop\n&s       setc  Upper('&upcase')\n         aif   ('&s '(1,1) ne 'Y').gblset3\n&gblsetp setc  Upper('&gblsetp')\n.gblset3 anop\n&s       setc  Upper('&no')\n&p       setc  Upper('&gblsetp')\n         aif   ('&p' ne 'NO' or '&s' ne 'NULL').gblset4\n&gblsetp setc  ''\n.gblset4 anop\n         aif   ('&listval' ne 'y' and '&listval' ne 'Y').gblset5\n         mnote *,'gblsetp value=&gblsetp'\n.gblset5 anop\n         mexit\n.*-\n.x       Mend\n.* ADD NAME=MVLIT\n         MACRO\n&lbl     MVLIT &A,&T,&LR=,&lenreg=,&LA=\n.* move literal to area\n.*  lr : load text length to register\n.*  la : load register with address of end of text\n         aif   (k'&t eq 0).nullp\n         lcla  &tl\n&tl      seta  (k'&t)-2\n&lbl     mvc   &a.(&tl),=c&t\n         aif   (k'&lr eq 0 and k'&lenreg eq 0).lrn\n         la    &lr&lenreg,&tl\n.lrn     anop\n         aif   (k'&la eq 0).lan\n         la    &la,&a+&tl\n.lan     mexit\n.nullp   anop\n         aif   (k'&lbl eq 0).x\n&lbl     ds    0h\n.x       MEND\n.* ADD NAME=NTSERVX\n         Macro\n&mlbl    NTSERVX &what,&pl=,&rc=,                                      c\n               &level=,&l=,&persist=,&p=,&name=,&n=,&token=,&t=\n.*  see MVS Programming: Authorized Assembler Services Reference,\n.*  volume 2 - (EDTINFO-IXGWRITE) for details of the IEANTxx i/f.\n.*  Amode 31 is required for the call method used in this macro.\n.*\n.*  Retrieve may  use the  caller's save  area as  work area,  see the\n.*  retrieve  section  for details.  The  token  is then  returned  in\n.*  registers 1-4.\n.*   Note that this  is only valid if caller's registers  5-9 have not\n.*  yet been modified.\n.*\n.*  IEANT_NOPERSIST         EQU     0\n.*  IEANT_PERSIST           EQU     1\n.*  IEANT_TASK_LEVEL        EQU     1\n.*  IEANT_HOME_LEVEL        EQU     2\n.*  IEANT_PRIMARY_LEVEL     EQU     3\n.*  IEANT_SYSTEM_LEVEL      EQU     4\n.*  IEANT_TASKAUTH_LEVEL    EQU    11\n.*  IEANT_HOMEAUTH_LEVEL    EQU    12\n.*  IEANT_PRIMARYAUTH_LEVEL EQU    13\n.*\n.* Changelog\n.*  2018-10-25 change PL=SA to use SA+40 (r5-r9) and return token\n.*             in r1-r4.\n.*  2019-10-22 short forms of name, level, token and persist parms\n.*\n         lclc  &u,&lbl,&ofs,&$csect,&$pl,&$token,&$rc,&$what\n         lclc  &$level,&$pers,&$plsave\n&lbl     setc  'NTX&sysndx'\n&$csect  setc  '&sysect'\n&u       setc  Upper('&what')\n         aif   ('&u' eq 'PL').pl\n&$token  setc  '&token.&t'\n&$rc     setc  '&rc'\n.*\n.*- level\n&u       setc  Upper('&level.&l.H '(1,1))\n&$level  setc  '1'\n         aif   ('&u' eq 'T').lvlok\n&$level  setc  '2'\n         aif   ('&u' eq 'H').lvlok\n&$level  setc  '3'\n         aif   ('&u' eq 'P').lvlok\n&$level  setc  '4'\n         aif   ('&u' eq 'S').lvlok\n         mnote '8,'** Invalid level, must be T, H, P or S'\n         mexit\n.lvlok   anop\n.*- persist\n&u       setc  Upper('&persist.&p.N '(1,1))\n&$pers   setc  '1'\n         aif   ('&u' eq 'Y').persok\n&$pers   setc  '0'\n         aif   ('&u' eq 'N').persok\n         mnote  8,'** Invalid persist, must ne Y or N'\n         mexit\n.persok  anop                          IEANT_PERSIST\n.*- what\n&$what   setc  Upper('&what')\n         aif   ('&$what' eq 'CR').cr\n         aif   ('&$what' eq 'RT').rt\n         aif   ('&$what' eq 'DL').dl\n         mnote 8,'invalid entry: &what'\n         mexit\n.* -- create\n.CR      ANOP\n         aif   (k'&$token ne 0).cr2\n         mnote 8,'** Token missing'\n         mexit\n.cr2     anop\n         mnote *,'NT create'\n         $la   r1,&pl\n         la    r14,=a(&$level)         level\n.*       mnote *,'name:  &name.&n'\n         $la   r15,&name,&n            name\n.*       mnote *,'token: &$token'\n         $la   r0,&$token              token\n         stm   r14,r0,0(r1)\n         la    r14,=a(&$pers.)         persist\n         $la   r15,&rc\n         stm   r14,r15,12(r1)\n&offs    setc  '04'\n         ago   .exec\n.* -- retrieve\n.*  Retrieve may use the caller's save area as work area as follows\n.*  parmlist is  r13+40, length 16, overlaying r5-r8\n.*  token    is also r13+40 length 16, overlaying r5-r8\n.*  rc       is r13+40+16, length 4, overlaying r9\n.*  The token is loaded to r1-4. The original r1-4 can be restored\n.*  from the save area if needed.\n.RT      ANOP\n         mnote 'NT retrieve'\n&$pl     setc  Upper('&pl')\n&$plsave setc  Upper('&pl')\n         aif   ('&$pl' ne 'SA').rt2\n&$pl     setc  '40(r13)'\n&$token  setc  '40(r13)'\n&$rc     setc  '40+16(r13)'\n.rt2     anop\n.*       mnote 'RT r14 (level)=&$level'\n.*       mnote '   r15 (name )=&name.&n'\n.*       mnote '   r0  (token)=&$token'\n.*       mnote '   r1  (rc   )=&$rc   '\n.*       mnote '   r1  (pl   )=&$pl   '\n         la    r1,&$pl\n         la    r14,=a(&$level.)       level\n         $la   r15,&name,&n            name\n         $la   r0,&$token\n         stm   r14,r0,0(r1)\n         $la   r14,&$rc\n         st    r14,12(,r1)\n&offs    setc  '08'\n         ago   .exec\n.* -- delete\n.DL      ANOP\n         mnote 'NT delete'\n         la    r1,&pl\n         la    r14,=a(&$level.)        level\n         $la   r15,&name,&n            name\n         $la   r0,&rc\n         stm   r14,r0,0(r1)\n&offs    setc  '0C'\n         ago   .exec\n.* -- exec\n.exec    anop\n         L     r15,X'10'\n         L     r15,X'220'(,r15)\n         L     r15,X'14'(,r15)\n         L     r15,X'&offs'(,r15)\n         basr  r14,r15\n         l     r15,&$rc\n         aif   ('&$what' eq 'RT' and '&$plsave' eq 'SA').exec2\n         ltr   r15,r15\n         mexit\n.* using save area as token output area\n.exec2   anop\n         mnote 'token is in the SA'\n         lm    r1,r4,&$token         load token\n         save  (5,9)                 re-save\n         ltr   r15,r15\n         Mexit\n.* -- parmlist\n.pl      anop\n&mlbl    dc   6a(0)\n.x       Mend\n.* ADD NAME=QSAM31\n         Macro\n.*-\n.*  Do  QSAM i/o  using 31-bit  buffers and  rmode any.  The generated\n.*  code is fully reentrant.\n.*\n.* Syntax\n.*\n.*  label    QSAM31 parameters\n.*\n.* Parameter description\n.*\n.*  GEN,DCBA=label,DDNAME='ddname',ACC=Get|Put,EOD=label,\n.*    RECFM=F|V,RECLEN=nnnnn,PRINT=NOGEN|gen\n.*    recfm and reclen are taken from dataset if not specified.\n.*    ddname is right-padded to 8 bytes and uppercased.\n.*    'print' handles listing the DCB/DCBE expansions (1st call only).\n.*  MOD,DCBA=label,DDNAME='ddname',EOD=label,RECFM=F|V,RECLEN=nnnnn\n.*  OPEN,DCBA=label,GEN=N|y\n.*    Input or output is determined from the DCB.\n.*    if GEN=Y then the GEN function is called before OPEN, add\n.*    required GEN parameters to the call.\n.*  CLOSE,DCBA=label,DROP=N|y\n.*    If DROP=Y then the DROP function is called internally.\n.*  DROP,DCBA=label\n.*  For all of the above you can use dcba-label instead of DCBA=label\n.*  GET,DCBA=label,DATA=label\n.*  GET,dcba-label,data-label\n.*  PUT,DCBA=label,DATA=label\n.*  PUT,dcba-label,data-label\n.*  EXPOSE,DCBA=label,FIELD=fieldname,OUT=label | REG=r1\n.*  DCBA      generate area anchor\n.*  DSECTS\n.*    Generate dsects DCBD and IHADCBE\n.*\n.* Sample - note that dcb 'LIST' uses the 'GEN' option.\n.*\n.*            QSAM31 gen,dcba=datadcba,acc=g\n.*            QSAM31 mod,dcba=datadcba,ddname=dataddn,eod=dataeod\n.*            QSAM31 open,dcba=datadcba\n.*            QSAM31 open,dcba=listdcba,gen=yes,ddname='list',acc=p,\n.*                     recfm=f,reclen=l'iobfr\n.*   dataread QSAM31 get,data=iobfr,dcba=datadcba\n.*            QSAM31 put,data=iobfr,dcba=listdcba\n.*            j     dataread\n.*   dataeod  QSAM31 close,dcba=datadcba\n.*            QSAM31 drop,dcba=datadcba\n.*            QSAM31 close,dcba=listdcba,drop=yes\n.*   datadcba QSAM31 dcba\n.*   listdcba QSAM31 dcba\n.*   iobfr    ds    cl120\n.*   dataddn  dc    cl8'DATA'\n.*            QSAM31 dsects\n.*   //DATA   DD *\n.*   Kilroy\n.*     was\n.*       here\n.*   //LIST   DD SYSOUT=*\n.*\n.* History\n.* 2019-10-12  Initial\n.*-\n&mlbl    QSAM31 &dcba=,&ddname=,&reclen=,&recfm=,&acc=,&data=,         c\n               &eod=,&gen=N,&drop=N,&print=nogen,                      c\n               &field=,&out=,&reg=r1\n.*\n         gblc  &#modrmod,&#modamod\n         lclc  &que,&dcbap,&accp,&genp,&dropp,&l,&s,&msect,&p1,&p2\n         gblb  &QSAM31_init,&QSAM31_dsects\n         aif   (&QSAM31_init eq 0).init\n.*\n.start   anop\n&que     setc  Upper('&syslist(1)')\n&p1      setc  Upper('&syslist(2)')\n&p2      setc  Upper('&syslist(3)')\n&accp    setc  Upper('&acc '(1,1))\n&genp    setc  Upper('&gen '(1,1))\n&dropp   setc  Upper('&drop '(1,1))\n         aif   ('&accp' eq 'G' or '&accp' eq 'P' or k'&acc eq 0).jump1\n         mnote 8,'*Invalid acc &accp'\n         mexit\n.jump1   anop\n         aif   ('&que' eq 'SUBI').subi\n         aif   ('&que' eq 'SUBX').subx\n         aif   ('&que' eq 'LA').la\n         aif   ('&que' eq 'DCBA').dcba   DCB area anchor\n         aif   ('&que' eq 'DSECTS').dsects\n.*\n&dcbap   setc  '&dcba&p1'\n         aif   (k'&dcbap eq 0).nodcba\n         aif   ('&que' eq 'GEN').gen     make cbs\n         aif   ('&que' eq 'MOD').mod     updt cb\n         aif   ('&que' eq 'OPEN').open\n         aif   ('&que' eq 'CLOSE').close\n         aif   ('&que' eq 'DROP').drop\n         aif   ('&que' eq 'GET').get\n         aif   ('&que' eq 'PUT').put\n         aif   ('&que' eq 'EXPOSE').expose\n         mnote 8,'*Invalid option &que'\n         mexit\n.*-\n.* Generate reentrant cbs\n.*-\n.gen     anop\n&mlbl    sr    r0,r0\n         aif   ('&accp' ne 'P').gencall\n         la    r0,1                     set 'put'\n.gencall Qsam31 la,r1,&dcbap\n         l     r15,=v(QSAM31G)         -> generate routine\n         balr  r14,r15\n         QSAM31 mod,dcba=&dcbap,ddname=&ddname,reclen=&reclen,         c\n               recfm=&recfm,eod=&eod,print=&print\n         Mexit\n.*-\n.* IO blk\n.*-\n.dcba    anop\n&mlbl    dc    a(0)\n         Mexit\n.*-\n.* Modify control blocks\n.*-\n.mod     anop\n&mlbl    Qsam31 la,r14,&dcbap\n         l     r14,0(,r14)\n         using QSAM31blk,r14\n         aif   (k'&ddname eq 0).modddnn\n         aif   ('&ddname'(1,1) eq '''').modddnl\n         QSAM31 la,r1,&ddname\n         ago   .modddng\n.modddnl la    r1,=cl8&ddname\n.modddng mvc   QSAM31bdcb+(dcbddnam-ihadcb)(8),0(r1)\n         oc    QSAM31bdcb+(dcbddnam-ihadcb)(8),=cl8' '\n.modddnn anop\n         aif   (k'&reclen eq 0).modrcln\n         qsam31 la,r1,&reclen\n         sth   r1,QSAM31bdcb+(dcblrecl-ihadcb)\n.modrcln anop\n&s       setc  Upper('&recfm '(1,1))\n         aif   ('&s' ne 'F').modrffn\n         oi    QSAM31bdcb+(dcbrecfm-ihadcb),DCBRECF\n.modrffn anop\n         aif   ('&s' ne 'V').modrfvn\n         oi    QSAM31bdcb+(dcbrecfm-ihadcb),DCBRECV\n.modrfvn anop\n         aif   (k'&eod eq 0).modeodn\n         QSAM31 la,r1,&eod\n         st    r1,QSAM31bdcbe+(dcbeeoda-dcbe)\n.modeodn anop\n         drop  r14\n         mexit\n.*-\n.* Open DCB\n.*-\n.open    anop\n&l       setc  'QSO&sysndx'\n         aif   (k'&mlbl eq 0).open2\n&mlbl    ds    0h\n.open2   anop\n         aif   ('&genp' ne 'Y').open3\n         QSAM31 gen,dcba=&dcbap,ddname=&ddname,acc=&acc,               c\n               reclen=&reclen,recfm=&recfm,eod=&eod,print=&print\n.open3   anop\n         Qsam31 la,r1,&dcbap\n         l     r15,=v(QSAM31O)         -> open routine\n         balr  r14,r15\n         mexit\n.*-\n.* Close DCB\n.*-\n.close   anop\n&mlbl    Qsam31 la,r15,&dcbap\n         l     r15,0(,r15)\n         Close ((r15)),mode=31,mf=(E,QSAM31bocb-QSAM31blk(15))\n         aif   ('&dropp' ne 'Y').close2\n         QSAM31 drop,dcba=&dcbap\n.close2  anop\n         mexit\n.*-\n.* Read\n.*-\n.get     anop\n&mlbl    Qsam31 la,r15,&dcbap\n         l     r15,0(,r15)\n         get   ((r15)),&data&p2          get\n         mexit\n.*-\n.* Write\n.*-\n.put     anop\n&mlbl    Qsam31 la,r15,&dcbap\n         l     r15,0(,r15)\n         put   ((r15)),&data&p2          put\n         mexit\n.*-\n.* Drop resources\n.*-\n.drop    anop\n         Qsam31 la,r1,&dcbap\n         l     r15,=v(QSAM31D)         -> generate routine\n         balr  r14,r15\n         mexit\n.*-\n.* Expose fields\n.*-\n.expose  anop\n&mlbl    Qsam31 la,&reg,&dcbap\n         l     &reg,0(,&reg)\n         aif   (k'&out ne 0).exposef\n         la    &reg,QSAM31b&field.o(,&reg)\n         ago   .exposex\n.exposef Qsam31 la,r14,&out\n         mvc   0(l'QSAM31b&field,r14),QSAM31b&field.o(&reg)\n.exposex mexit\n.*-\n.* Build internal modules\n.*-\n.subi    anop\n.* amode\n         aif   ('&#modamod' ne '').#modam2\n&mlbl    Amode 31\n         ago   .#modamn\n.#modam2 anop\n&mlbl    Amode &#modamod\n.#modamn anop\n.* rmode\n         aif   ('&#modrmod' ne '').#modrm2\n&mlbl    Rmode ANY\n         ago   .#modrmn\n.#modrm2 anop\n&mlbl    rmode &#modrmod\n.#modrmn anop\n&mlbl    Csect\n         Save  (14,12)\n         lr    r11,r15\n         Using &mlbl,r11\n         mexit\n.subx    anop\n         l     r14,12(,r13)\n         Return (2,12)\n         mexit\n.init    anop\n&QSAM31_init setb 1\n&l       setc  'QSI&sysndx'\n         j     &l.b\n         ltorg\n&l.b     ds    0h\n&msect   setc  '&sysloc'\n         push using\nQSAM31blk    Dsect\nQSAM31bdcb   ds    xl(QSAM31gdl)\nQSAM31bdcbe  ds    xl(QSAM31gel)\nQSAM31bocb   ds    2a\nQSAM31breclo equ   *-QSAM31blk\nQSAM31brecl  ds    h\nQSAM31brecfo equ   *-QSAM31blk\nQSAM31brecf  ds    c               F or V\nQSAM31blkl   equ   *-QSAM31blk\n.*\n* Generate 24-bit area holding DCB and DCBE\n* at entry\n* r1 -> dcb anchor\n* r0 = 0 => Get, r0 = 1 => Put\n.*\nQSAM31G  Qsam31 subi\n         lr    r2,r1\n         lr    r3,r0\n         Getmain R,lv=QSAM31blkl,loc=BELOW\n         st    r1,0(,r2)                 save ptr\n         lr    r2,r1\n         using QSAM31blk,r2\n         ltr   r3,r3\n         jnz   QSAM31G_put\n         mvc   QSAM31bdcb(QSAM31gdl),QSAM31gd\n         mvc   QSAM31bdcbe(QSAM31gel),QSAM31ge\n         j     QSAM31G_set\nQSAM31G_put    equ   *\n         mvc   QSAM31bdcb(QSAM31pdl),QSAM31pd\n         mvc   QSAM31bdcbe(QSAM31pel),QSAM31pe\nQSAM31G_set    equ   *\n         la    r14,QSAM31bdcbe                -> DECB\n         st    r14,QSAM31bdcb+(dcbdcbe-ihadcb) store in DCB\n         xc    QSAM31bocb(8),QSAM31bocb      prep open/close list\n         mvi   QSAM31bocb,x'80'            prep open/close list\n         sr    r15,r15\n         Qsam31 subx\n* cb models\n          push  print\n          print &print\nQSAM31gd  DCB   ddname=Z,macrf=GM,dsorg=PS,eodad=0,dcbe=*\nQSAM31gdl equ     *-QSAM31gd\nQSAM31ge  DCBE  RMODE31=BUFF,EODAD=*\nQSAM31gel equ     *-QSAM31ge\nQSAM31pd  DCB   ddname=Z,macrf=PM,dsorg=PS,eodad=0,dcbe=*\nQSAM31pdl equ     *-QSAM31pd\nQSAM31pe  DCBE  RMODE31=BUFF\nQSAM31pel equ     *-QSAM31pe\n          pop   print\n          ds    0a\n         pop  using\n.*\n* Open DCB after determining input or output\n* at entry\n*  r1 -> dcb anchor\n.*\n&l       setc  'QSO&sysndx'\n         push using\nQSAM31O  Qsam31 subi\n         l     r2,0(,r1)                   -> DCB blk\n         using QSAM31blk,r2\n.* go\n         cli   DCBMACR1-ihadcb(r2),0       z=output, nz=input\n         je    &l.o                        output\n* input\n         OPEN  ((r2)),mode=31,mf=(E,QSAM31bocb)\n         j     &l.s\n* output\n&l.o     equ   *\n         OPEN  ((r2),(OUTPUT)),mode=31,                                c\n               mf=(E,QSAM31bocb)\n.* store some info\n&l.s     mvc   QSAM31brecl,QSAM31bdcb+(dcblrecl-ihadcb)\n         mvi   QSAM31brecf,c'F'\n         tm    QSAM31bdcb+(dcbrecfm-ihadcb),DCBRECV\n         jz    *+8\n         mvi   QSAM31brecf,c'V'\n.* back\n&l.n     sr    r15,r15\n         Qsam31 subx\n         pop  using\n.*\n* Free 24-bit area holding DCB and DCBE\n* at entry\n*  r1 -> dcb anchor\n.*\n         push using\nQSAM31D  Qsam31 subi\n         lr    r2,r1\n.* go\n         l     r3,0(,r2)\n         Freemain R,lv=QSAM31blkl,a=(r3)\n         xc    0(4,r2),0(r2)\n.* back\n         sr    r15,r15\n         Qsam31 subx\n         pop  using\n.* resume main\n&msect   Loctr ,                       resume\n         ago   .start\n.*-\n.* Dsects\n.*-\n.dsects  anop\n         aif   (&QSAM31_dsects).dsectsn\n&QSAM31_dsects setb 1\n         Dsect\n         Push  print\n         Print &print\n         DCBD  DSORG=PS                 map DCB\n         IHADCBE ,                      map DCBE\n         Pop   print\n.dsectsn mexit\n.*-\n.* Subroutine, generate Lx instruction (shortened $LA)\n.*\n.* Syntax: LA  reg,what1,what2,,whatn\n.*         what: label or (reg) or 'literal' or f/h/b/c.label\n.*               x.label -> reg is cleared and the value is loaded\n.*               1st non-null 'what' is used\n.*-\n.LA      anop\n         lclc  &xlar,&xlap,&xla,&xlapu\n         lcla  &xlapn,&xlan\n         gblc  &$$lalen\n&$$lalen setc  ''\n&xlapn   seta  2\n&xlar    setc  '&syslist(&xlapn)'\n.xlanext anop\n&xlapn   seta  &xlapn+1\n         aif   (&xlapn gt n'&syslist).x\n&xlap    setc  '&syslist(&xlapn)'\n         aif   (k'&xlap eq 0 or '&xlap' eq '''''').xlanext\n         aif   ('&xlap '(1,1) eq '(').xlareg\n         aif   ('&xlap '(1,1) eq '''').xlalit\n         aif   ('&xlap '(2,1) eq '.').xlafld\n&xla     setc  t'&xlap\n         aif   ('&xla' eq 'N').xlanum\n&mlbl    la    &xlar,&xlap\n         aif   ('&xlap  '(1,2) eq 'l''').x\n&$$lalen setc  'l''&xlap'\n         mexit\n.xlanum  anop\n&mlbl    lgfi  &xlar,&xlap\n         mexit\n.xlareg  anop\n&xlan    seta  k'&xlap-2\n&xlap    setc  '&xlap'(2,&xlan)\n&mlbl    lr    &xlar,&xlap\n         mexit\n.xlalit  anop\n&mlbl    la    &xlar,=c&xlap\n&xlan    seta k'&xlap-2\n         mexit\n.xlafld  anop\n&xlan    seta  k'&xlap-2\n&xlapu   setc  Upper('&xlap'(1,1))\n&xlap    setc  '&xlap'(3,&xlan)\n&$$lalen setc '&xlan'\n         aif   ('&xlapu' eq 'F').xlaflf\n         aif   ('&xlapu' eq 'H').xlaflh\n         aif   ('&xlapu' eq 'B' or '&xlapu' eq 'C').xlaflb\n         mnote 8,'* Invalid load parm'\n         mexit\n.xlaflf  anop\n&mlbl    l     &xlar,&xlap\n         mexit\n.xlaflh  anop\n&mlbl    lh    &xlar,&xlap\n         mexit\n.xlaflb  anop\n&mlbl    llc   &xlar,&xlap\n         mexit\n.*-\n.* Macro end\n.*-\n.nodcba  mnote 8,'**Missing DCBA'\n.x       MEND\n.* ADD NAME=STRCOPY\n         Macro\n.*-\n.* Copy string\n.*\n.* The generated code determines if the length is le or gt 255\n.* and does MVC or MVCL accordingly.\n.*\n.* Syntax\n.*  STRCOPY FROM=(addr,len),TO=(addr,len) \u00dd,LENREG=lr\u00a8\n.*        addr     label, (reg), F.label\n.*        len      value, (reg), F.label, default is len of addr\n.*        lr       register to save the length.\n.*\n.* len values are optional, thet defaults to the with of addr.\n.* FROM-len will be adjusted if gt than TO-len.\n.*\n.* Registers 14, 15, 0 and 1 are all used internally.\n.*\n.* Uses macro $LA to set values.\n.*\n.* Samples\n.*     STRCOPY  from=target,to=(source,(r3))\n.*-\n&mlbl    StrCopy  &from=,&to=,&lenreg=\n         lclc  &l,&s\n         gblc  &$lalenc\n&l       setc  'zsc&sysndx'\n.* setup address and length info\n&mlbl    $la   r14,&from(1)\n         $la   r15,&from(2),&$lalenc\n         $la   r0,&to(1)\n         $la   r1,&to(2),&$lalenc\n.* beware of overflow\n         cr    r1,r15               check target big enough\n         jh    *+6                  target size ok\n         lr    r15,r1               overflow, use target length\n.* copy length\n         aif   (k'&lenreg eq 0).cplrn\n         lr    &lenreg,r15\n.cplrn   anop\n.* select method\n         clfi  r15,255              if source length\n         jh    &l.ml                  gt 255 then use movelong\n         bctr  r15,0\n         lr    r1,r0                copy target address\n         ex    r15,&l.ms\n         j     &l.x\n&l.ms    mvc   0(*-*,r1),0(r14)\n&l.ml    lr    r1,r15               copy length\n         mvcl  r0,r14\n&l.x     ds    0h\n         Mend\n.* ADD NAME=STRC2D\n         Macro\n.*-\n.* STRC2D - convert hex value to readable (decimal)\n.*\n.* Syntax\n.*  STRC2D FROM=(addr,len),TO=(addr,len)\n.*        addr      label, (reg), F.label\n.*        from-len  value 1-4, can be in (reg) or f.label\n.*        to-len    value, (reg) or f.label. Default is from-len*3\n.*\n.* The  macro calls  an internally  generated subroutine.  This\n.* shortens the code length  for multiple executions of STRC2D,\n.* though adds a bit to the program complexity.\n.*\n.* Returns\n.*  r0  = length of output if r15=0\n.*  r15 = 0 if all ok, else 4\n.*\n.* Notes\n.*  registes 0,1,14,15 are used by the macro\n.*\n.* Author\n.*     Willy Jensen\n.*     mail: willy@harders-jensen.com\n.*     web : http://harders-jensen.com/wjtech\n.*-\n&mlbl    StrC2d &from=,&to=,&print=nogen\n         gblb  &$strc2d\n         gblc  &$lalenc\n         lclc  &s,&l,&froml,&tol\n&l       setc  'CD&sysndx'\n.* call\n         $la   r15,&from(1)\n&froml   setc  '&$lalenc'\n         $la   r0,&to(1)\n&tol     setc  '&$lalenc'\n         $la   r1,&from(2),&froml\n         $la   r14,&to(2),0\n         sll   r1,16\n         ar    r1,r14\n         l     r14,=v(zstrc2d)\n         basr  r14,r14\n         aif   (&$strc2d).x\n&$strc2d setb  1\n* module\n         push  print\n         print &print\n&s       setc  '&sysloc'\nZSTRC2D  Amode 31\nZSTRC2D  Rmode any\nZSTRC2D  Csect\n         stm   r14,r2,12(r13)\n         basr  r2,0\n         ahi   r2,-6\n         push  using\n         using zstrc2d,r2\n.* get length mask\n         l     r14,16(,r13)            from addr\n         lh    r15,24(,r13)            from len\n         cfi   r15,4\n         jh    &l.e1\n         sr    r1,r1                   not really necessary, but...\n         ic    r1,&l.m-1(r15)          load mask\n.* load source\n         sr    r15,r15\n         ex    r1,&l.i\n         cvd   r15,60(,r13)\n.* make decimal\n         l     r14,20(,r13)            to addr\n         lh    r15,26(,r13)            to len\n         ltr   r15,r15                 to-len given?\n         jnz   &l.b                    yes\n         lh    r15,24(,r13)            use from-length\n         mhi   r15,3                   *3\n&l.b     lr    r0,r15                  save target size\n         bctr  r15,0\n         sll   r15,4\n         ex    r15,&l.u\n         srl   r15,4\n         la    r15,0(r14,r15)\n         oi    0(r15),x'f0'\n         j     &l.x0\n&l.m     dc    x'0103070F'             length masks\n&l.i     icm   r15,0,0(r14)\n&l.u     unpk  0(*-*,r14),60(8,r13)\n&l.x0    sr    r15,r15\n&l.x1    l     r14,12(,r13)\n         l     r2,28(,r13)\n         bsm   0,r14\n&l.e1    la    r15,4\n         j     &l.x1\n         drop  r2\n         pop   using\n         pop   print\n.* resume main\n&s       Loctr                         resume main\n.x       Mend\n.* ADD NAME=STRPARSE\n         Macro\n&lbl     StrParse &value=,&init=N,&link=CALL,&trace=,&msg=0,           c\n               &v=Z,&c=Z,&l=N,&i=,&q=z,&pp=--,&area=N,&build=N,&align=\n.*----------------------------------------------\n.*\n.*  Really just a copy of PARMSCN2 of 2018/12/05\n.*\n.*  Syntax\n.*    StrParse (stringaddr,stringlength),\n.*             (keyword,area,F=format-verify,C=convert,A=abbrev,\n.*             I=init-value,q=quote),\n.*             INIT=i,PP=pp,LINK=llll\n.*          keyword: verb, will be capped internally\n.*          area   : address of a StrParse DC/DS macro\n.*          verify : A alphanum, letters and numbers\n.*                   C char, only letters\n.*                   N only numbers\n.*          format : B convert to binary, forces length=4\n.*                   P packed binary\n.*                   U uppercase string\n.*          'verify' and 'format' can be entered in any case\n.*          'verify' and 'format' are only honored if INIT=Y\n.*          quote    K keep. default is to drop quotes.\n.*      . . .\n.*      BUILD=Y      Stack internal list for 'AREA' call.\n.*      INIT=Y       Initialize area covered by a\n.*                   StrParse DC/DS macro. only the first byte\n.*                   of the area is initialized.\n.*      PP=cc        positional value prefix\n.*      link=CALL|link   'call' generates internal\n.*      AREA         Build 'DS' list from internal stack.\n.*                   Must be the only parameter, otherwise assumed\n.*                   to be string name.\n.*\n.* Define area\n.* areaname StrParse DC|ds,size,format=.convert=\n.*          verify and format see above. Only honored for DC.\n.*          if size F then force full-word, format N and convert B\n.*\n.*          StrParse area expansion:\n.*             areaname_fl ds  al1  field length\n.*             areaname_dl ds  al1  data length\n.*             areaname dc|ds  &type&value\n.*\n.* Notes:\n.*  If the same parameter is entered multiple times then the last\n.*  entry is use.\n.*  An entry can be use multiple times, i.e.:\n.*               StrParse (workrec,l'workrec),\n.*    -  -  -  -  -  -  -  -  -  -  -  -  -  -\n.*                   (msg,msg1),\n.*                   (msg,msg2),\n.*    -  -  -  -  -  -  -  -  -  -  -  -  -  -\n.*    msg1     StrParse dc,12,v=z,c=z\n.*    msg2     StrParse dc,12,v=z,c=z\n.*  if msg(something) is entered more than twice, then the 'msg2'\n.*  field is overwritten.\n.*\n.* Updates\n.* 2019-09-05 Add Q= option, include XLA subroutine\n.* 2019-09-30 Add amode and rmode to all internal csects\n.*\n.*----------------------------------------------\n         gblb  &strparsmodule,&strparsdsect\n         gbla  &strparsn\n         gblc  &strparsl(100),&strparsk(100),&strparst(100)\n         gblc  &strparsf(100),&strparsc(100),&strparsq(100)\n         gblc  &strparsalign\n         lcla  &n,&l1,&l2,&flgs,&sln,&ofs,&oln,&setinil\n         lclc  &name,&data,&type,&req,&opt,&optu,&optd,&lb1\n         lclc  &thissect,&sect,&s,&s1,&s2,&s3\n         lclc  &pl,&pvfy,&pcnv,&pabr,&plst\n         lclc  &plen,&pinit,&trn,&setini,&palign,&pqopt\n.* xla sub\n         gblc  &xlalen\n&s       setc  Upper('&syslist(1)')\n         aif   ('&s' eq 'XLA').xla\n.*\n         aif   (k'&align eq 0).palignn\n&strparsalign  setc  (UPPER '&align')\n.palignn anop\n.*       mnote *,'align=&strparsalign'\n\n&pinit   setc  (UPPER '&init')\n&s3      setc  (UPPER '&build')\n         aif   ('&s3' ne 'Y').pbuildn\n&pinit   setc  'Y'\n.pbuildn anop\n&s3      setc  (UPPER '&syslist(1)')\n         aif   ('&s3' eq 'AREA' and n'&syslist eq 1).area\n         aif   ('&s3' eq 'DS').ds\n         aif   ('&s3' eq 'DC').dc\n&thissect setc '&sysect'\n.*       mnote *,'thissect: &thissect'\n.* preserve ltorg'd fields\n&lb1     setc  'zps&sysndx.a'\n         b     &lb1\n         ltorg\n&lb1     ds    0h\n         call  ZPS&sysndx.M\n.*\n*----------- build keyword table --------------\n         aif   (&strparsdsect ne 0).dsectn\n*PS2D1 keyword list area\nPS2D1    Dsect\nPS2D1eye ds    cl8                    eyecatcher\nPS2D1siz ds    a                      total size of obtained area\nPS2D1sa1 ds    18a                    save area\nPS2D1sa2 ds    18a                    save area\nPS2D1bln ds    cl120                  blank area\nPS2D1fw  ds    f                      work area\nPS2D1dw  ds    d                      work area\nPS2D1wrk ds    xl256                  work area\nPS2D1sta ds    a                      string address\nPS2D1stl ds    a                      string length\nPS2D1stp ds    a                      string position\nPS2D1vpb ds    a                      verb portion begin\nPS2D1vpe ds    a                      verb portion end\nPS2D1dpb ds    a                      data portion begin\nPS2D1dpe ds    a                      data portion end\nPS2D1msg ds    a                      -> message buffer (cl100)\nPS2D1num ds    a                      number of named operands in list\nPS2D1d2a ds    a                      -> data (work)\nPS2D1pp  ds    cl2                    Positional prefix\nPS2D1pn  ds    al1                    Positional count\n         ds    xl1                    future use\nPS2D1lst ds    0x                     start of named operand list\nPS2D1pfl equ   *-PS2D1                size of area prefix\n.*\n*PS2D2 keyword list entry\nPS2D2    Dsect ,                      keyword list\nPS2D2nam ds    a                      address of name\nPS2D2opt ds    x                      options\nPS2D2use equ   x'80'                  in use\n         ds    x                      future\nPS2D2len ds    al1                    verb length\nPS2D2abr ds    al1                    verb abbreviation\nPS2D2d3a ds    a                      address of data definition\nPS2D2nxt ds    0x                     next entry\n.*\n*PS2D3 data entry\nPS2D3    Dsect ,                      data entry\nPS2D3opt ds    x                      future\n.*2D3use equ   x'80'                  in use\nPS2D3vfc equ   128                    verify is char\nPS2D3vfn equ   64                     verify is num\nPS2D3vfa equ   128+64                 verify is alpha-num\nPS2D3vfz equ   0                      null\nPS2D3qok equ   32                     quote opt - keep quotes\nPS2D3qoz equ   0                                - drop quotes\nPS2D3cvu equ   8                      convert to upcase chars\nPS2D3cvp equ   4                      convert to packed decimal\nPS2D3cvb equ   2                      convert to binary\nPS2D3lst equ   1                      data is a list\nPS2D3cvz equ   0                      null\nPS2D3fl  ds    x                      field length\nPS2D3dl  ds    x                      data length\nPS2D3dat ds    0c                     data\n.dsectn  anop\n&sect    setc  'ZPS&sysndx.M'\n.* &sect $$modes\n&sect    amode 31\n&sect    rmode any\n&sect    csect\n         bakr  14,0\n         lr    r5,r15\n         using &sect,r5\n         using PS2D1,r6\n&sln     seta  12*n'&syslist\n mnote *,'storage obtain sz &sln'\n         STORAGE OBTAIN,LENGTH=PS2D1pfl+&sln,LOC=31\n         lr    r6,r1\n         mvc   PS2D1eye,=cl8'&sect'    eyecatcher\n         mvc   PS2D1siz,=a(PS2D1pfl+&sln) obtained area size\n         STRPARSE XLA,r1,&msg\n         st    r1,PS2D1msg\n.*       STRPARSE XLA,r1,&unsol\n.*       st    r1,PS2D1uos\n&s       setc  (Upper '&pp')\n         mvc   PS2D1pp,=cl2'&s'        positional var prefix\n         mvi   PS2D1pn,0               positional number\n         aif   (n'&syslist(1) ne 2).strerr1\n         STRPARSE XLA,r14,&syslist(1,1) string address\n         STRPARSE XLA,r15,&syslist(1,2) string length\n         stm   r14,r15,PS2D1sta\n         st    r14,PS2D1stp            save start pos\n&sln     seta  n'&syslist-1\n         mvc   PS2D1num,=a(&sln)       number of named operands\n.*\n&sln     seta 2\n         la    r7,PS2D1lst\n         la    r13,PS2D1sa1\n.*--\n.pars100 anop\n&name    setc  Upper('&syslist(&sln,1)')\n&data    setc  'name'\n         aif   (n'&syslist(&sln) eq 1).pars200\n&data    setc  '&syslist(&sln,2)'\n.pars200 anop\n&trn     setc  'CALL'\n&oln     seta  2                     past name and dataaddres\n         ago   .opt2\n.callopt anop\n&l1      seta  k'&name\n         la    r2,=c'&name'\n         lh    r3,=y((256*&l1)+&pabr) verb length, abbrev\n         la    r4,&data._op\n         stm   r2,r4,0(r7)\n         aif   ('&pinit' ne 'Y').pars300\n         mnote *,'do init'\n         aif   ('&plst' eq 'Y').pars220\n         aif   ('&plen' eq '?').pars210\n&s3      setc  '&plen'\n         aif   ('&plen' eq 'F').pars205\n&s1      setc  'PS2D3vf&pvfy+PS2D3cv&pcnv+PS2D3qo&pqopt'\n         mvc   &data._op(4),=al1(&s1,&s3,0,c' ')\n         ago   .pars206\n.pars205 mvc   &data._op(4),=al1(PS2D3vf&pvfy+PS2D3cv&pcnv,4,0,0)\n.pars206 anop\n&strparsn seta &strparsn+1\n&strparsl(&strparsn) setc '&data'\n&strparst(&strparsn) setc 'C'\n&strparsk(&strparsn) setc '&plen'\n&strparsf(&strparsn) setc '&pvfy'\n&strparsc(&strparsn) setc '&pcnv'\n&strparsq(&strparsn) setc '&pqopt'\n         ago   .pars300\n.pars210 anop\n&s1      setc  'PS2D3vf&pvfy+PS2D3cv&pcnv+PS2D3qo&pqopt'\n         mvc   &data._op(4),=al1(&s1,l'&data,0,c' ')\n         ago   .pars300\n.pars220 anop  ,                       list\n&s1      setc  'PS2D3vf&pvfy+PS2D3cv&pcnv+PS2D3lst+PS2D3qo&pqopt'\n         mvc   &data._op(4),=al1(&s1,0),y(l'&data)\n.pars300 anop\n         aif   (&setinil eq 0).pars400\n         aif   ('&pcnv' eq 'P').pars310\n         aif   ('&pcnv' eq 'B').pars320\n&setinil seta  &setinil-2\n         mvi   &data._dl,&setinil\n         mvc   &data.(&setinil),=c&setini\n         ago   .pars400\n.pars310 anop  ,                       packed dec\n         mvi   &data._dl,l'&data       full field\n         zap   &data,=p'&setini'       set value\n         ago   .pars400\n.pars320 anop  ,                       binary\n         mvi   &data._dl,4\n         mvc   &data,=al4(&setini)\n.pars400 anop\n         la    r7,PS2D2nxt-PS2D2(,r7)\n&sln     seta  &sln+1\n         aif   (&sln le n'&syslist).pars100\n* Call parser\n         lr    r1,r6\n         Call  STRPARS2\n         lr    r2,r15                 save rc\n         l     r3,PS2D1siz\n         STORAGE RELEASE,LENGTH=(3),ADDR=(6)\n         lr    r15,r2\n         pr\n         ltorg\n         drop  r5,r6\n.*-\n         aif   (&strparsmodule).modulen\n         push  using\n.*-\n.*       Module\n.*-\n&strparsmodule setb 1\n*\n*-\n*        Parser\n*-\n         USING PS2D1,r10\n         USING STRPARS2,r11        ESTABLISH ADDRESSABILITY\n aif ('&trace' eq '').trc0n\n         USING &thissect,r12\n.trc0n anop\n.* SCN02 $$modes\nSTRPARS2 amode 31\nSTRPARS2 rmode any\nSTRPARS2 Csect\n         save  (14,12)             save caller's status on stack\n         lr    r11,r15             set up a base register\n         lr    r10,r1              -> Keylist setup dynamic area\n         la    r14,PS2D1sa2\n         st    r14,8(,r13)\n         st    r13,4(,r14)\n         lr    r13,r14\n         l     r7,PS2D1sta         string address\n         l     r6,PS2D1stl         string length\n         xc    PS2D1wrk,PS2D1wrk\n         clear PS2D1bln\n         ar    r6,r7               -> 1 past string\n         bctr  r6,0                -> last byte of string\n         la    r9,PS2D1lst         -> keyword table\n\n aif ('&trace' eq '').trc1n\n      lr    r14,r6\n      sr    r14,r7\n      bctr  r14,0\n      sh    r14,=h'18'\n      mvc   logr+18(*-*),0(r7)\n      ex    r14,*-6\n      la    r14,1(,r14)\n      $cvd  r14,logr+12,len=4\n      log   'str:'\n.trc1n anop\n\n*locate start of kw (1st non-blank)\nps2slkw0 equ   *\n         l     r7,PS2D1stp           load position\nps2slkw1 equ   *\n         cr    r7,r6                 end of string?\n         bh    ps2send               yes, end\n         cli   0(r7),c' '            look for non-blank\n         bne   ps2slkw2              got it\n         la    r7,1(,r7)\n         b     ps2slkw1\n*locate end of keyword\nps2slkw2 equ   *\n         st    r7,PS2D1vpb           save verb start\n         la    r4,1(r7)\nps2slkw3 equ   *                     look for '('\n         cli   0(r4),c'('            look for '('\n         be    ps2slkwend            got it\n         cli   0(r4),c' '            positional\n         be    ps2slkwend            got it\n         la    r4,1(,r4)\n         cr    r4,r6                 end of string?\n         bnh   ps2slkw3\nps2slkwend equ *                     start and end of kw found\n         st    r4,PS2D1vpe           save verb end\n         st    r4,PS2D1stp           update position\n         sr    r4,r7                 length of keyword\n.*       lr    r15,r5                copy length dropped 2017-02-25\n         lr    r15,r4                copy length\n         bctr  r15,0                 mch length\n         mvc   PS2D1wrk+2(*-*),0(r7)   copy verb\n         ex    r15,*-6\n         oc    PS2D1wrk+2(l'PS2D1bln),PS2D1bln  uppercase\n         xc    PS2D1d2a,PS2D1d2a\n aif ('&trace' eq '').trc2n\n      mvlit logr,'kw:'\n      lr    r14,r4\n      bctr  r14,0\n      mvc   logr+12(*-*),0(r7)\n      ex    r14,*-6\n      log\n.trc2n anop\n\n*find the entry in the keyword table\n*r7 ->start of keyword, r4=length\n         Using PS2D2,r5\n         la    r5,PS2D1lst           ->table\n         l     r8,PS2D1num           number of entries\n         sr    r2,r2\nps2slkwt1 equ *\n         lb    r2,PS2D2len           load length\n         l     r3,PS2D2nam           ->keyword\n aif ('&trace' eq '').trc3n\n     lb    r14,PS2D2len\n     bctr  r14,0\n     mvc   logr+12(*-*),0(r3)\n     ex    r14,*-6\n     log   'kwt entry:'\n.trc3n anop\n         cli   PS2D2abr,0            abbreviation allowed?\n         be    ps2snabr              nope\n aif ('&trace' eq '').trc31n\n     log   'test abr'\n.trc31n anop\n         clm   r4,1,PS2D2len         check length\n         bh    ps2slkwt2             verb len gt max\n         clm   r4,1,PS2D2abr         check abbrev length\n         bl    ps2slkwt2             verb len lt abbrev\n         lr    r2,r4                 copy verb\nps2snabr equ   *\n         cr    r4,r2                 check length\n         bne   ps2slkwt2             no, try next\nps2stvrb equ   *\n         bctr  r2,0\n.*       clc   0(*-*,r7),0(r3)\n         clc   PS2D1wrk+2(*-*),0(r3)\n         ex    r2,*-6\n         be    ps2slkwt3             gotit\nps2slkwt2 equ *\n         la    r5,PS2D2nxt           ->next entry\n         bct   r8,ps2slkwt1          if any left\n         icm   r14,15,PS2D1d2a       is\n         bz    ps2slkwt2a              there\n         lr    r5,r14                    a previous\n         b     ps2slkwt3a                  entry we can use?\nps2slkwt2a equ *\n         l     r1,PS2D1vpe\n         cli   0(r1),c'('            has data?\n         be    ps2serr2              yup, not positional\n         cli   PS2D1pp,c'-'          positional ?\n         bne   ps2spp                yes, go check\n         b     ps2serr2              else not found\nps2slkwt3 equ *\n         st    r5,PS2D1d2a           save\n.* if entry has been used already then ignore\n         l     r14,PS2D2d3a          -> data\n         cli   PS2D3dl-PS2D3(r14),0  test data length\n         bne   ps2slkwt2             not zero, then already used\n.* -\nps2slkwt3a equ *\n aif ('&trace' eq '').trc4n\n     mvc   logr+12(*-*),0(r3)\n     ex    r2,*-6\n     log   'kw valid:'\n.trc4n anop\n.*       oi    PS2D2opt,PS2D2use     set 'keyword found'\n.*       l     r15,PS2D2d3a          ->data section\n.*       using PS2D3,r15\n.*       tm    PS2D3opt,PS2D3use     already used?\n.*       bo    ps2serr3              yep, error\n.*       oi    PS2D3opt,PS2D3use     mark it in use\n.*       drop  r15\n\n*-------------describe parmdata---------------------------\n         la    r7,0(r4,r7)           -> past kw\n         cli   0(r7),c'('            type of delimiter\n         be    ps2sld1               go get data\n aif ('&trace' eq '').trc51n\n      log   'no data'\n.trc51n anop\n         l     r14,PS2D2d3a          -> data\n         mvi   PS2D3dl-PS2D3(r14),1  set data length\n         mvi   PS2D3dat-PS2D3(r14),c'Y' default value\n         b     ps2slkw0              next\nps2sld1  equ    *\n         sr    r8,r8                 keep count of sub-parms\n*find start of data\n.*       cli   pskdmaxl,0            keyword only?\n.*       be    ps2serr4              then error\n aif ('&trace' eq '').trc5n\n      log   'has data'\n.trc5n anop\n         la    r7,1(,r7)             bump ptr\n         cr    r7,r6                 past end of string?\n         bh    ps2serr1              end-of-data missing\n         cli   0(r7),c' '\n         be    ps2sld1\n         st    r7,PS2D1dpb           save address of data\n\n*find end of data\n aif ('&trace' eq '').trc6n\n      mvc   logr+12(8),0(r7)\n      log   'data start:'\n.trc6n anop\n         lr    r4,r7                 ->data\nps2sld2 equ    *\n         cr    r4,r6                 past end of string?\n         bh    ps2serr1              error\n         cli   0(r4),c')'            end of parm?\n         be    ps2sld3\n         cli   0(r4),c'('            start of sub-parm?\n         bne   *+8                   nope\n         la    r8,1(,r8)             indicate\n         la    r4,1(,r4)\n         b     ps2sld2\nps2sld3 equ    *\n         ltr   r8,r8                 end of all (sub-)parms?\n         bz    ps2sld3a              yes\n         bctr  r8,0                  else subtract one\n         la    r4,1(,r4)\n         b     ps2sld2               and continue\nps2sld3a equ   *\n         st    r4,PS2D1dpe           save address of data end\n aif ('&trace' eq '').trc7n\n      mvc   logr+12(8),0(r4)\n      log   'data end:'\n.trc7n anop\n         la    r14,1(,r4)\n         st    r14,PS2D1stp          update position\n*locate last non-blank of data\n         lr    r2,r4\nps2sld4 equ    *\n         bctr  r2,0\n         cli   0(r2),c' '\n         be    ps2sld4\nps2sld5  equ    *\n         cr    r2,r7                null string?\n         bl    ps2sldend            yes\n         la    r2,1(,r2)            past end\n         sr    r2,r7                length of data\n aif ('&trace' eq '').trc81n\n      mvlit logr,'datalen:'\n      $cvd  r2,logr+12,len=4\n      mvlit logr+18,'fldl'\n      l     r14,PS2D2d3a         -> data structure\n      sr    r14,r14\n      ic    r14,PS2D3fl-PS2D3(,r14) field length\n      $cvd  r14,logr+24,len=4\n      log   ,\n.trc81n anop\n         l     r14,PS2D2d3a         -> data\n         tm    PS2D3opt-PS2D3(r14),PS2D3cvb  if convert to bin\n         bo    ps2scfl9             then bypass this check\n         lr    r1,r14\n         sr    r14,r14\n         ic    r14,PS2D3fl-PS2D3(,r1)  load field length\n         cr    r2,r14               test size, r2=dl r14=fl\n         bnh   ps2scfl9             ok\n* error 5 : data too wide\n* dc h'0'\n         la    r15,5                set rc\n         icm   r1,15,PS2D1msg\n         bz    ps2sendx             no message area\n*                             ----+----1----+----2----+----3----+----4\n         mvc   0(20,r1),=cl20'0005 Datalength at'\n         mvc   20(8,r1),0(r7)\n         la    r1,30(,r1)\n.*       $cvd  r2,19(r1),len=4\n         mvc   0(2,r1),=c'dl'\n         cvd   r2,PS2D1dw\n         unpk  3(8,r1),PS2D1dw+4(4)\n         oi    3+8-1(r1),x'f0'\n         la    r1,12(,r1)\n.*       $cvd  r14,27(r1),len=4\n         mvc   0(2,r1),=c'fl'\n         cvd   r14,PS2D1dw\n         unpk  3(8,r1),PS2D1dw+4(4)\n         oi    3+8-1(r1),x'f0'\n         b     ps2sendx             too big\nps2scfl9 equ   *\n         l     r4,PS2D2d3a\n         using PS2D3,r4\n         stc   r2,PS2D3dl           save data length\n         bctr  r2,0\n* verify data contents ?\n         tm    PS2D3opt,x'f0'      test format?\n         bz    ps2svf9             nope\n         tm    PS2D3opt,PS2D3vfa   test for alphanum?\n         bz    ps2svfa9            else go check next\n         la    r3,=c'A'\n         ex    r2,ps2svfax\n         bz    ps2svf9             ok\n         b     ps2serr6\nps2svfax trt   0(*-*,r7),ps2svfat\nps2svfa9 equ   *\n         tm    PS2D3opt,PS2D3vfc   test for char\n         bz    ps2svfc9            else go check num\n         la    r3,=c'C'\n         ex    r2,ps2svfcx\n         bz    ps2svf9             ok\n         b     ps2serr6\nps2svfcx trt   0(*-*,r7),ps2svfct\nps2svfc9 equ   *\n         tm    PS2D3opt,PS2D3vfn   test for numerics\n         bz    ps2svfn9            nope\n         la    r3,=c'N'\n         ex    r2,ps2svfnx\n         bz    ps2svfn9             ok\n         b     ps2serr6\nps2svfnx trt   0(*-*,r7),ps2svfnt\nps2svfn9 equ   *\nps2svf9  equ   *\n* convert data ?\n         lm    r14,r15,PS2D1dpb    start and end of data\n         sr    r15,r14             length\n         bctr  r15,0               machine length\n         l     r2,PS2D2d3a         -> target structure\n         tm    PS2D3opt,PS2D3cvp   packed decimal ?\n         bo    ps2scvp             go do\n         tm    PS2D3opt,PS2D3cvb   binary ?\n         bo    ps2scvb             go do\n.* convert: move\n         tm    PS2D3opt,PS2D3qok   keep quotes?\n         jo    ps2scpy             yes\n         cli   0(r14),c''''        quoted??\n         bne   ps2scpy\n         llc   r0,PS2D3dl          adjust\n         ahi   r0,-2                 data\n         stc   r0,PS2D3dl              length\n         la    r14,1(,r14)\n         bctr  r15,0\n         bctr  r15,0\nps2scpy  ex    r15,ps2scvmx        else just move\n         tm    PS2D3opt,PS2D3cvu   uppercase?\n         bz    ps2scv9             nope\n         ex    r15,ps2scvux        then upcase\n         b     ps2scv9             and exit\nps2scvmx mvc   PS2D3dat(*-*),0(r14)\nps2scvux oc    PS2D3dat(*-*),PS2D1bln\nps2scvm9 equ   *\n.* convert: binary\nps2scvb  cli   PS2D3fl,4           target better be ge 4\n         bl    ps2serr7\n         ex    r15,ps2scvbx        pack to work area\n         cvb   r1,PS2D1dw          to binary\n         stcm  r1,15,PS2D3dat      and store\n         mvi   PS2D3dl,4           force length 4\n aif ('&trace' eq '').trccvbn\n         mvc   PS2D1wrk(4),PS2D3dat\n         cvxd  in=PS2D1wrk,out=logr+12,len=4\n         log   'bindata:'\n.trccvbn anop\n         b     ps2scv9\nps2scvbx pack  PS2D1dw,0(*-*,r14)\n.* convert: packed decimal\nps2scvp  lr    r3,r15              copy mch length\n         sll   r3,4                move up one nibble\n         or    r3,r15              copy mch length to low nibble\n         ex    r3,ps2scvpx         pack to work area\n         b     ps2scv9\nps2scvpx pack  PS2D3dat(*-*),0(*-*,r14)\nps2scvp9 equ   *\n.*\nps2scv9  equ   *\nps2svcn  equ   *\n aif ('&trace' eq '').trc8n\n      tm    PS2D3opt,PS2D3cvb   binary ?\n      bo    trc8n               already done\n      mvc   logr+18(*-*),PS2D3dat\n      ex    r2,*-6\n      la    r15,1(,r2)\n      $cvd  r15,logr+12,len=4\n      log   'data:'\ntrc8n equ   *\n.trc8n anop\n         drop  r4\n\nps2sldend equ *\n         l     r1,PS2D1stp          load last pos\n         la    r1,1(,r1)            bump ')'\n         l     r1,PS2D1stp          update last pos\n         b     ps2slkw0             get next\n*-\n* positional value support\n*-\nps2spp   cnop  0,4\n aif ('&trace' eq '').trcpp1n\n      mvlit logr,'positional value support'\n      lr    r14,r4\n      bctr  r14,0\n      mvc   logr+26(2),PS2D1pp\n      mvc   logr+30(*-*),0(r7)\n      ex    r14,*-6\n      log   ,\n.trcpp1n anop\n*find the entry in the keyword table\n*r7 ->start of keyword, r4=length\n         la    r5,PS2D1lst           ->table\n         l     r8,PS2D1num           number of entries\nps2spptn equ   *\n         l     r3,PS2D2nam           -> name\n aif ('&trace' eq '').trcpp2n\n      mvlit logr,'name'\n      lb    r14,PS2D2len\n      bctr  r14,0\n      mvc   logr+6(*-*),0(r3)\n      ex    r14,*-6\n      log   ,\n.trcpp2n anop\n         clc   PS2D1pp,0(r3)\n         bne   ps2sppnx              not positional\n         l     r14,PS2D2d3a          -> data area\n         Using PS2D3,r14\n         cli   PS2D3dl,0\n         bne   ps2sppnx              occupied\n         sr    r2,r2\n         ic    r2,PS2D3fl\n         cr    r4,r2\n         bh    ps2spper\n         stc   r4,PS2D3dl            save length\n         bctr  r4,0\n         mvc   PS2D3dat(*-*),0(r7)\n         ex    r4,*-6\n.* upcase positional parm\n         tm    PS2D3opt,PS2D3cvu     uppercase?\n         bz    *+14                  nope\n         oc    PS2D3dat(*-*),PS2D1bln\n         ex    r4,*-6                then upcase\n aif ('&trace' eq '').trcpp3n\n      log   'positional value added'\n.trcpp3n anop\n         la    r7,2(r4,r7)\n         st    r7,PS2D1stp           save position\n         b     ps2slkw0\n         drop  r14\nps2sppnx la    r5,PS2D2nxt           -> next entry\n         bct   r8,ps2spptn           if any left\n.* no free entries\nps2spper la    r15,8\n         icm   r14,15,PS2D1msg\n         bz    ps2sendx             no message area\n         mvc   0(30,r14),=cl30'Positional values exhausted'\n         b     ps2sendx             get back\n\n         Macro\n&lbl     PS2MSG &rc,&txt\n         lcla  &l\n&l       seta  (k'&txt)-2\n&lbl     la    r15,&rc\n         icm   r14,15,PS2D1msg\n         bz    ps2sendx             no message area\n         mvc   0(&l,r14),=c&txt\n         b     ps2sendx             get back\n         Mend\n\n         Macro\n         ISMSG &rc\n         la    r15,&rc\n         icm   r14,15,PS2D1msg\n         bz    ps2sendx             no message area\n         Mend\n\n         Macro\n&lbl     PS2MSGKW &rc,&txt\n         lcla  &l\n&l       seta  (k'&txt)-2\n&lbl     la    r15,&rc\n         icm   r14,15,PS2D1msg\n         bz    ps2sendx             no message area\n         mvc   0(&l,r14),=c&txt\n         bctr  r4,0\n         mvc   &l+1(*-*,r14),0(r7)\n         ex    r4,*-6\n         b     ps2sendx             get back\n         Mend\n\nps2serr1 ds    0h\n aif ('&trace' eq '').trc9n\n        log   'missing end-of-data'\n.trc9n anop\n         PS2MSG 1,'missing end-of-data'\nps2serr2 ds    0h\n aif ('&trace' eq '').trc10n\n        log   'kw not in table'\n.trc10n anop\n         PS2MSGKW 2,'Keyword not in table:'\nps2serr3 ds    0h\n aif ('&trace' eq '').trc11n\n        log   'keyword already found'\n.trc11n anop\n         PS2MSGKW 3,'Keyword already used:'\nps2serr4 ds    0h\n aif ('&trace' eq '').trc12n\n        log   'keyword already found'\n.trc12n anop\n         PS2MSGKW 4,'Keyword cant have data'\nps2serr6 ds    0h\n         icm   r14,15,PS2D1msg\n         bz    ps2sendx             no message area\n         mvc   0(12,r14),=c'Format error'\n         mvc   13(1,r14),0(r3)\n         mvc   15(8,r14),0(r7)\n         la    r15,6\n         b     ps2sendx             get back\nps2serr7 ds    0h\n         icm   r1,15,PS2D1msg\n         bz    ps2sendx             no message area\n         mvc   0(20,r1),=cl20'Field length error'\n         lm    r14,r15,PS2D1vpb\n         sr    r15,r14\n         bctr  r15,0\n         mvc   21(*-*,r1),0(r14)\n         ex    r15,*-6\n         la    r15,7\n         b     ps2sendx             get back\n.*\nps2send ds     0h\n aif ('&trace' eq '').trc14n\n        log   'string end'\n.trc14n anop\n         sr    r15,r15\n         b     ps2sendx\n         drop  r5\nps2send8 equ   *\n         lr    r0,r7\n         la    r15,8\nps2sendx equ   *\n         l     r13,4(,r13)\n         l     r14,12(,r13)\n         lm    r2,r12,28(r13)\n         br    r14\n         ltorg\nps2svfat dc    256al1(*-ps2svfat)     verify alpha-num\n         org   ps2svfat+c'A'\n         dc    9x'00'                 ABCDEFGHI\n         org   ps2svfat+c'J'\n         dc    9x'00'                 JKLMNOPQR\n         org   ps2svfat+c'S'\n         dc    8x'00'                 STUVWXYZ\n         org   ps2svfat+c'a'\n         dc    9x'00'                 abcdefghi\n         org   ps2svfat+c'j'\n         dc    9x'00'                 jklmnopqr\n         org   ps2svfat+c's'\n         dc    8x'00'                 stuvwxyz\n         org   ps2svfat+c'$'\n         dc    x'00'\n         org   ps2svfat+c'.'\n         dc    x'00'\n         org   ps2svfat+c'@'\n         dc    x'00'\n         org   ps2svfat+c'#'\n         dc    x'00'\n         org   ps2svfat+c'0'\n         dc    10x'00'                0123456789\n         org\nps2svfct dc    256al1(*-ps2svfct)     verify char\n         org   ps2svfat+c'A'\n         dc    9x'00'                 ABCDEFGHI\n         org   ps2svfat+c'J'\n         dc    9x'00'                 JKLMNOPQR\n         org   ps2svfat+c'S'\n         dc    8x'00'                 STUVWXYZ\n         org   ps2svfat+c'a'\n         dc    9x'00'                 abcdefghi\n         org   ps2svfat+c'j'\n         dc    9x'00'                 jklmnopqr\n         org   ps2svfat+c'$'\n         dc    x'00'\n         org   ps2svfat+c'@'\n         dc    x'00'\n         org   ps2svfat+c'#'\n         dc    x'00'\n         org\nps2svfnt dc    256al1(*-ps2svfnt)     verify numerics\n         org   ps2svfnt+c'0'\n         dc    10x'00'\n         org\n         drop  r10,r11\n         pop   using\n.modulen anop\n         mnote *,'#parm: &strparsn'\n&thissect csect\n.*-\n.*       inline area\n.*-\n&s3      setc  (Upper '&area')\n         aif   ('&s3' ne 'Y').x\n* inline area\n&s3      setc  'p&sysndx.arean'\n         b     &s3\n         mnote *,'StrParse Inline area'\n         mnote *,'#parm: &strparsn'\n         StrParse AREA\n&s3      ds    0a\n.*\n         Mexit\n.*-\n.*       area definitions\n.*- ds\n.ds      anop\n&s2      setc  (Upper '&syslist(2)')\n         aif   ('&s2' eq 'F').dsf\n         aif   ('&strparsalign' ne 'F').ds1an\n&lbl._pfx  ds    0f                      align=F\n&lbl._z  ds    x\n.ds1an   anop\n&plst    setc  (Upper '&l')\n         aif   ('&plst' eq 'Z').dsl\n&lbl._op ds    x\n&lbl._fl ds    x\n&lbl._dl ds    x\n&lbl        ds    cl&s2\n         mexit\n.dsf     ds    0a,1x\n&lbl._op ds    x\n&lbl._fl ds    x\n&lbl._dl ds    x\n&lbl        ds    f\n         mexit\n.dsl     anop\n&lbl._op ds    al1                    options\n&lbl._cn ds    al1                    count\n&lbl._fl ds    al2                    field length\n&lbl        ds    0x                     start of list\n         mexit\n.*- dc\n.dc      anop\n         aif   ('&SYSSTYP' eq 'CSECT').dcopt\n         mnote 4,'Section type should be CSECT, not &sysstyp'\n.*       mexit\n.*   &sln     seta  3                      past 'dc,len,'\n.*   &oln     seta  0                      first inside\n.*   &rtn     setc  'DC'\n.*            ago   .opt2\n.dcopt   anop\n&qopt    setc  (Upper '&q')\n&pvfy    setc  (Upper '&v')\n&pcnv    setc  (Upper '&c')\n         aif   ('&pcnv' ne 'P').dcoptpn   if packed\n&pvfy    setc  'N'                        then must be numeric\n.dcoptpn anop\n&plst    setc  (Upper '&l')\n         aif   ('&plst' eq 'Y').dc2l\n&s2      setc  (Upper '&syslist(2)')  length\n         aif   ('&s2' eq 'F').dc2f    full-word\n         aif   ('&strparsalign' ne 'F').dc1an\n&lbl._pfx  ds    0f                      align=F\n&lbl._z  ds    x\n.dc1an   anop\n&lbl._op dc    al1(PS2D3vf&pvfy+PS2D3cv&pcnv+PS2D3qo&pqopt)\n&lbl._fl dc    al1(&s2)\n&lbl._dl dc    al1(0)\n&lbl        dc    cl&s2.' '\n         Mexit\n.dc2f    ds    0a,1x\n&lbl._op dc    al1(PS2D3vfN+PS2D3cvB)\n&lbl._fl dc    al1(4)\n&lbl._dl dc    al1(0)\n&lbl        dc    f'0'\n         Mexit\n.dc2l    ds    0a\n&lbl._op dc    al1(PS2D3vf&pvfy+PS2D3cv&pcnv+PS2D3lst+PS2D3qo&pqopt)\n&lbl._cn dc    al1(0)                 count\n&lbl._fl dc    al2(&syslist(2))\n&lbl        ds    0x                     start of list\n         Mexit\n.*\n.strerr1 mnote 8,'Number of string parms ne 2'\n         Mexit\n.*== do over optlist\n.opt2    anop\n&pvfy    setc  'Z'\n&pcnv    setc  'Z'\n&pqopt   setc  'Z'\n&plst    setc  'N'\n&pabr    setc  '0'\n&plen    setc  '?'\n&setini  setc  '?'\n&setinil seta  0\n.optnext anop  , next\n&oln     seta  &oln+1\n         aif   (&oln gt n'&syslist(&sln)).opt2x\n&opt     setc  '&syslist(&sln,&oln)'\n&optl    seta  k'&opt\n         aif   (&optl ge 3).optl9\n         mnote 8,'*Length error: &opt'\n         mexit\n.optl9   anop\n&optu    setc  (Upper '&opt')\n&optd    setc  '&optu'(3,&optl-2)\n.*       mnote *,'sln: &sln, iln: &oln opt: &opt / &optu, optd: &optd'\n         aif   ('&optu'(1,2) eq 'V=').optfmt\n         aif   ('&optu'(1,2) eq 'C=').optcnv\n         aif   ('&optu'(1,2) eq 'A=').optabr\n         aif   ('&optu'(1,2) eq 'I=').optini\n         aif   ('&optu'(1,2) eq 'L=').optlen\n         aif   ('&optu'(1,2) eq 'Q=').optqt\n         aif   ('&optu'      eq 'L=Y').optlst\n         mnote 8,'*Invalid option &opt in &sln,&oln'\n         mexit\n.optabr  anop\n&pabr    setc  '&optd'\n         ago   .optnext\n.optlen  anop\n&plen    setc  '&optd'\n         ago   .optnext\n.optqt   anop\n&pqopt   setc  '&optd'\n         ago   .optnext\n.optfmt  anop\n&pvfy    setc  '&optd'\n         ago   .optnext\n.optfmtn anop\n&pvfy    setc  'N'\n         ago   .optnext\n.optcnv  anop\n&pcnv    setc  '&optd'\n         aif   ('&optd' eq 'B' or '&optd' eq 'P').optfmtn\n         ago   .optnext\n.optlst  anop\n&plst    setc  'Y'\n         ago   .optnext\n.optini  anop\n&setinil seta  k'&opt-2\n&setini  setc  '&opt'(3,&optl-2)\n         ago   .optnext\n.opt2x   anop\n         aif   ('&trn' eq 'CALL').callopt\n.*       aif   ('&trn' eq 'DC').dcopt\n         mnote 8,'*Invalid opt2 return: &rtn'\n         Mexit\n.*== optlist end\n.*== build remote data list\n.area    anop\n         mnote *,'#parm: &strparsn'\n&n       seta    0\n.area100 anop\n         aif   (&n ge &strparsn).area999\n&n       seta  &n+1\n&name    setc  '&strparsl(&n)'\n&pvfy    setc  '&strparsf(&n)'\n&pcnv    setc  '&strparsc(&n)'\n&qopt    setc  '&strparsq(&n)'\n&plen    setc  '&strparsk(&n)'\n&name    StrParse ds,&plen,v=&pvfy,c=&pcnv,q=&pqopt\n         ago   .area100\n.area999 Mexit\n.*-\n.* XLA - subroutine, generate Lx instruction\n.*-\n.xla     anop\n         lclc  &xlar,&xlap,&xla\n         lcla  &xlapn,&xlan\n&xlalen  setc   ''\n&xlar    setc  '&syslist(2)'\n&xlapn   seta  2\n.xlanext anop\n&xlapn   seta  &xlapn+1\n         aif   (&xlapn gt n'&syslist).xlax\n&xlap    setc  '&syslist(&xlapn)'\n         aif   (k'&xlap eq 0).xlanext\n         aif   ('&xlap '(1,1) eq '(').xlareg\n         aif   ('&xlap '(1,1) eq '''').xlalit\n         aif   ('&xlap '(2,1) eq '.').xlafld\n&xla     setc  t'&xlap\n         aif   ('&xla' eq 'N').xlanum\n&lbl     la    &xlar,&xlap\n         aif   ('&xlap  '(1,2) eq 'l''').xlax\n&xlalen  setc   'l''&xlap'\n         mexit\n.xlanum  anop\n&lbl     lgfi  &xlar,&xlap\n         mexit\n.xlafld  anop\n&xlan    seta  k'&xlap-2\n&xla     setc  '&xlap'(1,1)\n&xlap    setc  '&xlap'(3,&xlan)\n&xla     setc  lower('&xla')\n         aif   ('&xla' ne 'c').xlafld1\n&lbl     sr    &xlar,&xlar\n         ic    &xlar,&xlap\n         mexit\n.xlafld1 aif   ('&xla' ne 'f').xlafld2\n&xla     setc  ''\n.xlafld2 anop\n&lbl     l&xla &xlar,&xlap\n         mexit\n.xlareg  anop\n&xlan    seta  k'&xlap-2\n&xlap    setc  '&xlap'(2,&xlan)\n&lbl     lr    &xlar,&xlap\n         mexit\n.xlalit  anop\n&lbl     la    &xlar,=c&xlap\n&xlan    seta  k'&xlap-2\n&xlalen  setc  '&xlan'\n.xlax    mexit\n.x       Mend\n.* ADD NAME=STRPATRN\n         Macro\n.*-\n.* Test string against a pattern/mask.\n.*\n.* Syntax\n.*  STRPATRN DATA=data-addr,MASK=mask-addr,WC=ao|*%\n.*\n.*   'addr' is either a label, or (label,len) or 'literal'. 'label'\n.*   and 'len' may be a register like (rn) or f/h/b/c.label to load\n.*   from a fullword, halfword, byte or char field. See .XLA below.\n.*   The mask may contain wildcards % for a single char and * for\n.*   multiple or no chars.\n.*   'ao' mask chars for all or none, or any one char. default is *%.\n.*   STR= can be used instead of DATA=. This will probably be removed\n.*   in a later version, so please use DATA=.\n.*\n.* Returns result in r15:\n.*   0  Data matches mask\n.*  >1  Data does not match mask, code indicates where in STRPATRN\n.*      the check failed. Additional info is returned as follows:\n.*        r0 -> data addr when check failed\n.*        r1 -> mask addr when check failed\n.*\n.* Operation\n.*   First time the macro is invoked an internal CSECT is generated,\n.*   further macro invocations call the same CSECT.\n.*   The save area pointed to by r13 is used as work area both for\n.*   the call parameters and for saving registers. Registers 4-12 are\n.*   restore when the program returns, registers 2 and 3 are not used\n.*   so need not be preserved. Registers 0, 1, 14 and 15 are changed\n.*   by the macro.\n.*\n.* Samples\n.*    STRPATRN data=text1,mask=mask1\n.*    STRPATRN data='ABCDE',mask='A%C*'\n.*    STRPATRN data=((r2),(r3)),mask=(f.maskaddr,b.masklen)\n.*    STRPATRN data=text1,mask='Doc*Brit*'\n.*    . .\n.*  text1    dc    c'Doctor Who is a British sci-fi TV series'\n.*  mask1    dc    c'*Who*Brit*'\n.*  maskaddr ds    a       contains address of mask\n.*  masklen  ds    al1     max len 128 as field is signed\n.*\n.* Note that IBM supplies a similar function in macro ASAXWC in\n.* SYS1.MODGEN. STRPATRN, however, is simpler to use and test has\n.* shown it to be up to 4 times as fast as ASAXWC.\n.*\n.* History\n.*  2019-12-01  Total rewrite, so is now new base\n.*  2020-07-21  Fix false negative with equal mask- and string length\n.*\n.* Author\n.*     Willy Jensen\n.*     mail: willy@harders-jensen.com\n.*     web : http://harders-jensen.com/wjtech\n.*-\n&ml      STRPATRN &str=,&data=,&mask=,&wc='*%'\n         lclc  &l,&s,&c\n         lcla  &qn\n&l       setc  'sp&sysndx'\n         gblb  &$STRPATRN\n.* xla sub\n         gblc  &xlalen\n&s       setc  Upper('&syslist(1)')\n         aif   ('&s' eq 'XLA').xla\n.* call\n&ml      la    r1,8(,r13)\n         STRPATRN XLA,r14,&data(1),&str(1)\n         STRPATRN XLA,r15,&data(2),&str(2),&xlalen,1\n         stm   r14,r15,0(r1)\n         STRPATRN XLA,r14,&mask(1)\n         STRPATRN XLA,r15,&mask(2),&xlalen,1\n         stm   r14,r15,8(r1)\n         STRPATRN XLA,r14,&wc\n         mvc   16(2,r1),0(r14)\n         mvc   18(2,r1),=x'0000'\n         l     r15,=v(ZTRPATRN)\n         basr  r14,r15\n         aif   (&$STRPATRN).x\n&$STRPATRN setb 1\n         j     &l.ltn\n         ltorg\n&l.ltn   ds    0a\n* STRPATRN module\n* r14  return address\n* r12  basereg\n* r11  -> string\n* r10  -> mask\n* r9   -> string end\n* r8   -> mask end\n* r7   wildcards : byte0 is 'all', byte1 = one\n* r6   -> save mask ptr\n* r5   -> last '*'\n* r2-r4 are not used, they are not saved and restored as that space in\n* the save area is used for the parm block.\n&s       setc  '&sysect'\nZTRPATRN Amode 31\nZTRPATRN Rmode any\nZTRPATRN Csect\n         save  (4,12)\n         push  using\n         lr    r12,r15\n         using ZTRPATRN,r12\n* set up registers\n         using zptrnblk,r1\n         l     r11,zptrnsa            -> string\n         l     r9,zptrnsl             string length\n         ar    r9,r11                 -> past string\n         ahi   r9,-1                  -> end of string\n         l     r10,zptrnma            -> mask\n         l     r8,zptrnml             mask length\n         ar    r8,r10                 -> past mask\n         ahi   r8,-1                  -> end of mask\n         l     r7,zptrnwc             wild cards and opts\n* special case, mask='*' (fix 2020-07-21)\n         la    r15,1\n         c     r15,zptrnml            masklen=1 ?\n         jne   &l.f001                no\n         clm   r7,8,0(r10)            mask = '*' ?\n         je    &l.q0                  yes\n&l.f001  equ   *\n*-\n* Frontend - till '*' or end of mask or end of string\n*-\n         drop  r1\n&l.f100  equ   *\n         clm   r7,8,0(r10)            '*' ?\n         je    &l.f400                then go handle block\n\n* test char\n&l.f200  equ   *\n         clm   r7,4,0(r10)            '%' ?\n         je    &l.f300                yes\n         clc   0(1,r10),0(r11)        same char in string and mask?\n         jne   &l.fe01                no, abort\n\n* char ok, check/bump pointers\n&l.f300  equ   *\n         sr    r1,r1                  mask must also not be at end\n         cr    r10,r8                 end of mask?\n.*       jnh   &l.f302                nope        (fix 2020-07-21)\n         jne   &l.f302                nope\n         ahi   r1,1                   mask\n&l.f302  cr    r11,r9                 end of data?\n.*       jnh   &l.f304                nope        (fix 2020-07-21)\n         jne   &l.f304                nope\n         ahi   r1,1                   mark\n&l.f304  ltr   r1,r1                  both before end?\n         jz    &l.f310                good\n         clfi  r1,2                   both are at the end\n         je    &l.q0                  good\n         cr    r10,r8                 end of mask?\n         je    &l.fe03                mask end before string end\n\n* string end before mask end, check if mask+1='*' and end of mask\n         ahi   r10,1                  -> past '*'\n         cr    r10,r8                 now end of mask?\n         jne   &l.fe04                sadly not\n         clm   r7,8,0(r10)            '*' ?\n         je    &l.q0                  ok\n         j     &l.fe05                bad\n\n* both mask and string within bounds, bump and try next\n&l.f310  equ   *\n         ahi   r10,1                  bump mask ptr\n         ahi   r11,1                  bump string ptr\n         j     &l.f100                continue frontend processing\n\n* mask (r10->) chr is '*'\n&l.f400  equ   *\n         cr    r10,r8                 end of mask?\n         je    &l.q0                  yup, all is well\n\n* handle multiple consequitive '*'\n&l.f410  equ   *\n         ahi   r10,1                  -> past '*'\n         cr    r10,r8                 end of mask?\n         je    &l.f430\n         clm   r7,8,0(r10)            mask is * ?\n         je    &l.f410                yes\n\n* not end of mask, not '*'\n&l.f420  equ   *\n         ahi   r10,-1                 -> * ?\n         j     &l.f500                go prep for mid- and backend\n\n* end of mask\n&l.f430  equ   *\n         clm   r7,8,0(r10)            mask is * ?\n         je    &l.q0                  yes\n* small backend of one char\n         clm   r7,4,0(r10)            mask is % ?\n         je    &l.q0                  yes\n         clc   0(1,r10),0(r11)        char match ?\n         je    &l.q0                  yes\n         j     &l.fe06\n\n* mask chr (r10->) is '*', locate last '*' in mask\n* if this '*' is also last '*' in mask then just do backend\n&l.f500  equ   *\n         lr    r5,r8                  -> mask end\n&l.f510  equ   *\n         cr    r5,r10                 test against located '*'\n         je    &l.f520                reached that\n         clm   r7,8,0(r5)             is mask '*' ?\n         je    &l.f530                yes\n         bct   r5,&l.f510             else go test next\n\n* last '*' = first '*' then no mid section, go do backend\n&l.f520  equ   *\n         j     &l.bep\n\n* last '*' <> first '*' then there is a mid section\n&l.f530  equ   *\n         j     &l.msp\n\n* Set return codes\n&l.fe01  la    r15,101\n         j     &l.qx\n&l.fe02  la    r15,102\n         j     &l.qx\n&l.fe03  la    r15,103\n         j     &l.qx\n&l.fe04  la    r15,104\n         j     &l.qx\n&l.fe05  la    r15,105\n         j     &l.qx\n&l.fe06  la    r15,106\n         j     &l.qx\n\n*-\n* mid section processing, find matching block in string.\n* at entry: r10 -> position in mask, r11 -> position in text\n* r6  -> save mask ptr\n* r5  -> last '*'\n*-\n&l.msp   equ   *\n\n* handle multiple '*'\n&l.m010  equ   *\n         ahi   r10,1                  -> past '*'\n         clm   r7,8,0(r10)            mask is * ?\n         jne   &l.m100                init properly\n         cr    r10,r5                 = last '*' ?\n         je    &l.m020                yes\n         cr    r10,r8                 end of mask?\n         je    &l.q0\n         j     &l.bep                 else go do backend\n\n* r10 -> last '*', also mask end?\n&l.m020  equ   *\n         cr    r10,r8                 mask end too?\n         je    &l.q0                  then all is good\n         j     &l.bep                 else do backend\n\n* (re)start at submask\n&l.m100  equ   *\n         lr    r6,r10                 work mask ptr -> past '*'\n\n&l.m200  equ   *\n         cr    r6,r5                  mask work ptr gt subend?\n         jh    &l.m100                then iterate\n&l.m210  equ   *\n         cr    r11,r9                 string gt end?\n         jh    &l.me01                then error\n\n* test match\n&l.m300  equ   *\n         clm   r7,4,0(r6)             mask is % ?\n         je    &l.m310\n         clc   0(1,r6),0(r11)         mask matches string?\n         jne   &l.m400                nope, try next\n* char match\n&l.m310  equ   *\n         ahi   r6,1                   bump maskworkptr\n         cr    r6,r5                  last submsk done?\n         je    &l.m600                yes, do backend\n         clm   r7,8,0(r6)             mask is * ?  (submask end)\n         je    &l.m500                nope\n         ahi   r11,1                  bump strptr\n         j     &l.m210                cont with test\n\n* char don't match\n&l.m400  equ   *\n         cr    r6,r10                 past 1st char?\n         jh    &l.m410                yes\n         ahi   r11,1                  bump strptr\n         j     &l.m100                restart submask\n&l.m410  equ   *\n         j     &l.m100                restart submask\n\n* submask end\n&l.m500  equ   *\n         la    r10,1(,r6)             -> past '*'\n         ahi   r11,1                  bump strptr\n         j     &l.m100                restart submask\n\n* work ptr -> last '*'\n&l.m600  equ   *\n         cr    r6,r8                  also end of mask?\n         je    &l.q0\n         lr    r10,r6\n         j     &l.bep\n\n* Set return code\n&l.me01  la    r15,201\n         j     &l.qx\n&l.me02  la    r15,202\n         j     &l.qx\n&l.me03  la    r15,203\n         j     &l.qx\n&l.me04  la    r15,204\n         j     &l.qx\n&l.me05  la    r15,205\n         j     &l.qx\n&l.me06  la    r15,206\n         j     &l.qx\n\n*-\n* backend procesing, scan backwards till '*'\n* r11 -> string pos\n* r10 -> last '*'\n* r9  -> last byte of pos\n* r8  -> last byte of mask\n*-\n&l.bep   equ   *\n         ahi   r10,1\n         lr    r4,r8\n         sr    r4,r10                 length of backend\n         lr    r5,r9\n         sr    r5,r11                 length of str remainder\n         cr    r5,r4\n         jl    &l.be01\n\n&l.b100  equ   *\n         clm   r7,4,0(r8)             mask is % ?\n         je    &l.b200                bad if not\n         clc   0(1,r8),0(r9)          mask = text?\n         jne   &l.be03                bad if not\n&l.b200  equ   *\n         cr    r8,r10                 locate last mask?\n         jnh   &l.q0                  then all ok\n\n&l.b300  equ   *\n         ahi   r9,-1                  decr string ptr\n         bct   r8,&l.b100             decr mask ptr\n\n&l.be01  equ   *\n         la    r15,301\n         j     &l.be99\n&l.be02  equ   *\n         la    r15,302\n         j     &l.be99\n&l.be03  equ   *\n         la    r15,303\n         j     &l.be99\n&l.be99  equ   *\n         lr    r0,r9                  copy string addr for reporting\n         lr    r1,r8                  copy mask addr for reporting\n         j     &l.qx\n\n*-\n* return\n*-\n&l.q0    equ   *                      set good rc\n         sr    r15,r15                set good rc\n&l.qx    lr    r0,r11                 updated str addr for reporting\n         lr    r1,r10                 updated mask addr for reporting\n         return (4,12)\n         ltorg\n         pop   using\n\nzptrnblk dsect\nzptrnsa  ds    a                      string address\nzptrnsl  ds    a                      string length\nzptrnma  ds    a                      mask address\nzptrnml  ds    a                      mask length\nzptrnwc  ds    a                      wild cards etc\nzptrnblkl equ  *-zptrnblk\n.* resume main\n&s       Csect                        resume main\n         Mexit\n.*-\n.* $$LA - subroutine, generate Lx instruction (shortened $LA)\n.* Syntax: $$LA  reg,what1,what2,,whatn\n.*         what: label or (reg) or 'literal' or f/h/b/c.label\n.*               c.label -> reg is cleared and the entire byte loaded\n.*               1st non-null what is used\n.*-\n.xla     anop\n         lclc  &xlar,&xlap,&xla\n         lcla  &xlapn,&xlan\n&xlalen  setc   ''\n&xlar    setc  '&syslist(2)'\n&xlapn   seta  2\n.xlanext anop\n&xlapn   seta  &xlapn+1\n         aif   (&xlapn gt n'&syslist).xlax\n&xlap    setc  '&syslist(&xlapn)'\n         aif   (k'&xlap eq 0).xlanext\n         aif   ('&xlap '(1,1) eq '(').xlareg\n         aif   ('&xlap '(1,1) eq '''').xlalit\n         aif   ('&xlap '(2,1) eq '.').xlafld\n&xla     setc  t'&xlap\n         aif   ('&xla' eq 'N').xlanum\n&ml      la    &xlar,&xlap\n         aif   ('&xlap  '(1,2) eq 'l''').xlax\n&xlalen  setc   'l''&xlap'\n         mexit\n.xlanum  anop\n&ml      lgfi  &xlar,&xlap\n         mexit\n.xlafld  anop\n&xlan    seta  k'&xlap-2\n&xla     setc  '&xlap'(1,1)\n&xlap    setc  '&xlap'(3,&xlan)\n&xla     setc  lower('&xla')\n         aif   ('&xla' ne 'c').xlafld1\n&ml      sr    &xlar,&xlar\n         ic    &xlar,&xlap\n         mexit\n.xlafld1 aif   ('&xla' ne 'f').xlafld2\n&xla     setc  ''\n.xlafld2 anop\n&ml      l&xla &xlar,&xlap\n         mexit\n.xlareg  anop\n&xlan    seta  k'&xlap-2\n&xlap    setc  '&xlap'(2,&xlan)\n&ml      lr    &xlar,&xlap\n         mexit\n.xlalit  anop\n&ml      la    &xlar,=c&xlap\n&xlan    seta  k'&xlap-2\n&xlalen  setc  '&xlan'\n.xlax    mexit\n.x       Mend\n.* ADD NAME=STRP2D\n         Macro\n.*-\n.* STRP2D - String convert packed decimal to zoned decimal\n.*\n.* Syntax\n.*  STRP2D FROM=(addr,len),TO=(addr,len)\n.*        addr      label, (reg), F.label\n.*        from-len  1-4\n.*        to-len    default is from-len*3\n.*\n.* The  macro calls  an internally  generated subroutine.  This\n.* shortens the code length  for multiple executions of STRC2B,\n.* though adds a bit to the program complexity.\n.*\n.* Returns\n.*  r0  = length of output\n.*\n.* Notes\n.*  registes 0,1,14,15 are used by the macro\n.*-\n&ml      StrP2D &from=,&to=\n         lclc  &l,&s,&froml,&tol\n         gblb  &$STRP2D\n         gblc  &$lalenc\n&l       setc  'PD&sysndx'\n&ml      $la   r15,&from(1)\n&froml   setc  '&$lalenc'\n         $la   r0,&to(1)\n&tol     setc  '&$lalenc'\n         $la   r1,&from(2),&froml\n         $la   r14,&to(2),0\n         sll   r1,16\n         ar    r1,r14\n         l     r14,=v(ZSTRP2D)\n         basr  r14,r14\n.* module\n         aif   (&$STRP2D).x            already done\n&$STRP2D setb  1\n&s       setc  '&sysloc'\nZSTRP2D  Amode 31\nZSTRP2D  Rmode any\nZSTRP2D  CSECT\n         stm   r14,r2,12(r13)\n         basr  r2,0\n         ahi   r2,-6\n         push  using\n         using ZSTRP2D,r2\n.* setup source length\n         lh    r14,24(,r13)\n.* setup target length\n         lh    r15,26(,r13)\n         ltr   r15,r15\n         jnz   *+10\n         lr    r15,r14                  use source\n         sll   r15,1                    length*2\n         lr    r0,r15                   save target length\n.* compute and run\n         bctr  r14,0\n         bctr  r15,0\n         sll   r15,4\n         ar    r15,r14\n         l     r14,16(,r13)            from\n         l     r1,20(,r13)             to\n         ex    r15,&l.a\n         j     &l.a+6\n&l.a     unpk  0(*-*,r1),0(*-*,r14)\n         srl   r15,4                   leave mch tgt len\n         ar    r1,r15\n         oi    0(r1),x'F0'\n.* back\n         l     r14,12(r13)\n         l     r2,28(r13)\n         bsm   0,r14\n         drop  r2\n         pop   using\n&s       Loctr                         resume main\n.x       MEND\n.* ADD NAME=OPCOMM\n         MACRO\n.*\n.* Get modify/stop console response\n.* format of 'marea':\n.*   pos  len  desc\n.*    1    2   length of text\n.*    3    n   text\n.*\n.* Call type\n.*   INIT    setup control clocks\n.*   GET     test for command, r15=4 if no command waiting\n.*   WAIT    wait for a command\n.*\n.* Sample\n.*           OPCOMM INIT\n.*           OPCOMM GET,MAREA=comresp\n.*           OPCOMM WAIT,MAREA=comresp\n.*  comresp  ds    0CL100\n.*  comlen   dc    al2(0)\n.*  comtext  dc    cl98' '\n.*\n&NAME    OPCOMM &FUNC,&NUM=1,&MAREA=,&STOP=STOP,&COMBLK=OPCOMM\n         LCLA  &N,&M\n         LCLC  &L,&C,&s\n&L       SETC  'OP&SYSNDX'\n.*\n&S       SETC  Upper('&func')\n         AIF   ('&s' EQ 'INIT').INIT\n         AIF   ('&s' EQ 'WAIT').WAIT\n         AIF   ('&s' EQ 'GET').GET\n         AIF   ('&s' EQ 'DS').DS\n         AIF   ('&s' EQ 'DSECT').DSECT\n         MNOTE 8,'*** ERROR - INVALID FUNCTION - &FUNC'\n         Mexit\n.*\n.*--------------------------------------------------------------------*\n.INIT    ANOP\n** Init\n** obtain address of cib\n&NAME    CNOP  0,4\n         xc    &comblk.(&comblk.bl),&comblk\n         la    r1,&comblk\n         LA    R14,&comblk.ra          -> REPLY AREA\n         EXTRACT (R14),FIELDS=COMM,MF=(E,&comblk)\n.*--------------------------------------------------------------------*\n**   FREE START CIB\n         L     R14,&comblk.ra          -> COMM AREA\n         USING iezcom,R14              COVER\n         L     R15,COMCIBPT            -> CIB\n         USING iezcib,R15              COVER\n         CLI   CIBVERB,CIBSTART        START CIB ??\n         BNE   &L.LM                   NOPE - GO SET LIMIT\n         QEDIT ORIGIN=COMCIBPT,BLOCK=(R15)\n         DROP  R14,R15\n         LTR   R15,R15                 OK ??\n         BNZ   &L.X4                   ELSE GET OUT NOW\n.*--------------------------------------------------------------------*\n**   SET LIMIT OF OUTSTANDING MODIFYES\n&L.LM    L     R14,&comblk.ra          -> COMM AREA\n         LA    R14,COMCIBPT-iezcom(,R14)  -> COM CIBP\n         QEDIT ORIGIN=(R14),CIBCTR=&NUM\n&L.X4    CNOP  0,4\n         LTR   R15,R15                 SET RETURN CODE\n         mexit\n.*\n.*--------------------------------------------------------------------*\n.WAIT    ANOP\n**   WAIT FOR OPERATOR\n         AIF   (K'&MAREA(1) GT 0).WAI0100\n         MNOTE 8,'*** ERROR - MISSING OPERAND - MAREA'\n         mexit\n.WAI0100 ANOP\n         xc    &marea.(2),&marea       reset length field\n         mvi   &marea+2,c' '           reset 1st text byte\n         L     R2,&comblk.ra           -> COMM AREA\n         USING iezcom,R2               COVER\n         L     R1,COMECBPT             -> ECB\n         WAIT  ECB=(R1)\n         ago   .GetRply\n.*\n.*--------------------------------------------------------------------*\n.GET     ANOP\n**   get reply if ecb is posted\n         AIF   (K'&MAREA(1) GT 0).GET0100\n         MNOTE 8,'*** ERROR - MISSING OPERAND - MAREA'\n         MEXIT\n.GET0100 ANOP\n         xc    &marea.(2),&marea       reset length field\n         mvi   &marea+2,c' '           reset 1st text byte\n         L     R2,&comblk.ra           -> COMM AREA\n         USING iezcom,R2               COVER\n         L     R1,COMECBPT             -> ECB\n         tm    0(r1),x'40'             (ECBPOST)  Posted?\n         jo    *+12                    yup\n         la    r15,4\n         j     &l.x\n         ago   .GetRply\n.*\n.*--------------------------------------------------------------------*\n.GetRply ANOP\n**  GET REPLY FROM OPERATOR\n         L     R3,COMCIBPT             -> CIB\n         USING iezcib,R3               COVER CIB\n         LA    R1,CIBDATLN             -> DATA IN CIB\n         CLI   CIBVERB,CIBMODFY        MODIFY ??\n         BE    &L.M1                   YES - MOVE IN REPLY\n         CLI   CIBVERB,CIBSTOP         STOP ??\n         BNE   &L.E2                   NOPE - ERROR\n         LA    R1,&L.stop              -> STOP VALUE\n         B     &L.M1                   AND MOVE IN AS REPLY\n&L.E2    LA    R15,8                   SET BAD ID\n         j     &L.X6\n&L.M1    LH    R15,0(,R1)              GET LENGTH OF DATA\n         la    r14,2(,r1)              -> data\n         cli   0(r14),c''''            quoted?\n         jne   &l.m2\n         la    r14,1(,r14)             bump ptr\n         ahi   r15,-2                  adjust length\n&l.m2    LA    R0,l'&marea.-2          SET MAX LENGTH\n         CR    R15,R0                  CHECK MAX LENGTH\n         BNH   &l.m3                   OK THEN BUMP\n         LR    R15,R0                  ELSE SET MAX\n&l.m3    STCM  R15,3,&marea            SAVE IN RECEIVING AREA\n         BCTR  R15,0                   GET MCH LEN\n         EX    R15,&L.TX               COPY TEXT\n         SLR   R15,R15                 SET GOOD RC\n         j     &L.X6                   AND GET OUT\n&N       SETA  K'&STOP\n&L.STOP  DC    al2(&N),C'&STOP'        STOP VALUE\n&l.tx    mvc   &marea.+2(*-*),0(r14)   get text\n&L.X6    CNOP  0,4\n.*--------------------------------------------------------------------*\n**  FREE CIB\n         QEDIT ORIGIN=COMCIBPT,BLOCK=(R3)\n         DROP  R2,R3\n         ago   .x\n.*\n.*--------------------------------------------------------------------*\n**  Data map\n.ds      ANOP  ,                       BUILD RPL LIST\n&s       setc  '&name'\n         aif   ('&s' ne '').ds0100\n&s       setc  'OPCOMM'\n.ds0100  anop\n&s       ds    0a\n&s.xf    EXTRACT FIELDS=COMM,MF=L\n&s.ra    ds    a                       -> QEDIT RESPONSE AREA\n&s.bl    equ   *-&s\n         Mexit\n.*--------------------------------------------------------------------*\n.dsect   ANOP  ,                       BUILD RPL LIST\n**   dsects\n         PRINT NOGEN\nIEZCOM   DSECT\n         IEZCOM\nIEZCIB   DSECT\n         IEZCIB\n         Mexit\n.*\n.*-- END OF MACRO ----------------------------------------------------*\n.x       anop\n&l.x     cnop  0,4\n         MEND\n.* ADD NAME=SLNKLST\n         MACRO\n.*-\n.* Single-linked list\n.* Syntax:\n.*   label  SLNKLST ADD,SIZE=n,ADDR=addr|0\n.*   label  SLNKLST NEXT,ADDR=addr\n.*   label  SLNKLST DROP,ADDR=addr,PREV=addr|0\n.*   label  SLNKLST DROPALL,ADDR=addr-of-first\n.*   label  SLNKLST ANCHOR\n.*          n        Value, (reg) or f.label\n.*          addr     Label, (reg) or f.label\n.*                   Can be '0' for ADD, in which case neither\n.*                   forward nor backward pointers are updated -\n.*                   note that '0' may be a register with zeroes.\n.*                   f.label => l  reg,label\n.*   registers after ADD and NEXT:\n.*     r1 -> block, r0 -> data section. r1 is 0 if no next.\n.*\n.* Samples\n.*\n.* add first\n.*           SLNKLST add,size=textl,addr=0\n.*           st    r1,SLNKlsta\n.*\n.* add 2 entries (first and second)\n.*           la    r8,SLNKLSTA\n.*           SLNKLST add,size=textl,addr=(r8)\n.*           lr    r8,r1\n.*           SLNKLST add,size=textl,addr=(r8)\n.*           st    r8,SLNKLSTE               save address of last\n.* add 1 after last\n.*           l     r8,SLNKLSTE\n.*           SLNKLST add,size=textl,addr=(r8)\n.* drop one\n.*           SLNKLST drop,addr=(r2),prev=(r3)\n.* drop all\n.*           SLNKLST dropall,addr=f.SLNKLSTA\n.* scan list\n.*           l     r2,SLNKLSTA             -> first\n.*  SCAN     equ   *\n.*        .. do something ..\n.*           SLNKLST next,addr=(r2)\n.*           ltr   r2,r1\n.*           jnz   SCAN\n.*\n.*  SLNKLSTA dc   a(0)\n.*  SLNKLSTE dc   a(0)\n.*\n.* Changelog\n.*  2019-01-05  Expand dsect at first call, unless DSECT=N\n.*\n.* By\n.*  Willy Jensen\n.*     mail: willy@harders-jensen.com\n.*  web : http://harders-jensen.com/wjtech/index.html\n.*-\n&ml      SLNKLST &addr=,&prev=,&clear=,&size=,&sp=0,&data=,&trace=,    c\n               &dsect=Y\n         lclc  &que,&s,&l\n         lcla  &nexto,&sizeo,&datao,&poolo,&pfxl\n         gblc  $xlalen\n&nexto   seta  0\n&sizeo   seta  4\n&poolo   seta  8\n&datao   seta  12\n&pfxl    seta  12\n&l       setc  'SLL&sysndx'\n         gblb  @SLNKlst\n&que     setc  Upper('&syslist(1)')\n         aif   ('&que' eq 'XLA').xla\n         aif   ('&que' eq 'DSECT').dsect\n         aif   ('&que' eq 'ANCHOR').anchr\n         aif   (k'&addr eq 0).err2      ADDR= required for rest\n.*\n         aif   ('&dsect' ne 'Y' or &@SLNKlst).dsct1n\n&s       setc  '&sysect'\n         SLNKLST DSECT\n&s       Csect\n.dsct1n  anop\n.*\n         aif   ('&que' eq 'ADD').add\n         aif   ('&que' eq 'NEXT').next\n         aif   ('&que' eq 'DROP').drop\n         aif   ('&que' eq 'DROPALL').dropa\nerr1     mnote 8,'***Error invalid option'\n         mexit\nerr2     mnote 8,'***Error ADDR parm is required'\n         mexit\nerr3     mnote 8,'***Error PREV parm is required'\n         mexit\n.*-\n.* add new entry\n.*-\n.ADD     ANOP\n&ml      SLNKLST XLA,r0,&sp\n*getmain\n         SLNKLST XLA,r14,&size\n         la    r14,&pfxl.(,r14)        add prefix\n         Getmain R,lv=(14),bndry=DBLWD,sp=&sp\n         xc    0(&pfxl,r1),0(r1)\n         st    r14,&sizeo.(,r1)        save size\n         aif   ('&sp' eq '0').sp0\n         SLNKLST XLA,r0,&sp\n         stc   r0,&poolo.(,r1)         save subpool\n.sp0     anop\n.* chain\n*chain\n         SLNKLST XLA,r15,&addr\n         ltr   r15,r15                 any current\n         jz    &l.b                    else bypass chaining\n         l     r14,&nexto.(r15)        -> next\n         st    r1,&nexto.(r15)         set next in current\n         st    r14,&nexto.(,r1)        set next in new\n&l.b     equ   *\n.* clear\n&s       setc  Upper('&clear')\n         aif   ('&s '(1,1) ne 'Y').addcn\n*clear\n         st    r1,24(,r13)\n         la    r0,&datao.(,r1)         set target addr\n         SLNKLST XLA,r1,&size\n         sr    r14,r14\n         sr    r15,r15\n         mvcl  r0,r14\n         l     r1,24(,r13)\n.addcn   anop\n         aif   (n'&data eq 0).adddn\n*get data\n         SLNKLST XLA,r14,&data(1)\n         SLNKLST XLA,r15,&data(2),&$xlalen\n         st    r1,24(,r13)\n         la    r0,&datao.(,r1)\n         SLNKLST XLA,r1,&size\n         cr    r1,r15                  test l'target gt l'data\n         jh    *+6\n         lr    r15,r1                  else use l'target\n         mvcl  r0,r14\n         l     r1,24(,r13)\n.adddn   anop\n.* setup pointers for caller\n*data ptr\n         la    r0,&datao.(r1)          -> data section\n*end\n         mexit\n.*-\n.* address next entry\n.*-\n.NEXT    ANOP\n&ml      SLNKLST XLA,r1,&addr\n         ltr   r1,r1\n         jz    &l.x                    no current\n         l     r1,&nexto.(,r1)         -> next\n         la    r0,&datao.(r1)          -> data section\n&l.x     equ   *\n         mexit\n.*-\n.* drop one\n.*-\n.DROP    ANOP\n         aif   (k'&prev eq 0).err3     PREV= required for rest\n*unchain\n&ml      SLNKLST XLA,r1,&addr\n         SLNKLST XLA,r14,&prev         -> previous\n         ltr   r14,r14\n         jz    &l.a\n         l     r15,&nexto.(,r1)        -> next\n         st    r15,&nexto.(,r14)       update next in prev\n*free\n&l.a     l     r15,&sizeo.(,r1)        size\n         lb    r0,&poolo.(,r1)\n         Freemain R,lv=(15),a=(1),sp=(0)\n*end\n         mexit\n.*-\n.* drop all\n.*-\n.DROPA   ANOP\n&ml      SLNKLST XLA,r14,&addr         -> starting point\n&l.a     ltr   r14,r14                 test for block\n         jz    &l.x                    no queue\n         l     r15,&sizeo.(,r14)       size\n         lr    r1,r14                  copy address\n         lb    r0,&poolo.(,r1)         sp\n         l     r14,&nexto.(,r14)       -> next\n         aif   (k'&trace eq 0).dropatn\n         &trace\n.dropatn anop\n         Freemain R,lv=(15),a=(1),sp=(0)\n         j     &l.a\n&l.x     equ   *\n         mexit\n.*-\n.* anchor\n.*-\n.anchr   anop\n&ml      dc    a(0)\n         mexit\n.*-\n.* dsect\n.*-\n.dsect   anop\n         aif   (&@SLNKlst).mend\n&@SLNKlst    setb 1\nSLNKLSTBLOK  dsect\nSLNKlstnexto equ   &nexto\nSLNKlstnext  ds    a                   -> next in queue\nSLNKlstsizeo equ   &sizeo\nSLNKlstsize  ds    a                   size of block incl pfx\nSLNKlstpoolo equ   &poolo\nSLNKlstpool  ds    x                   subpool #\n             ds    3x                  future\nSLNKlstpfxl  equ   &datao              prefix size\nSLNKlstdatao equ   &datao\nSLNKlstdata  ds    0a\n         mexit\n.*-\n.* XLA - subroutine, generate Lx instruction\n.* Syntax: macname XLA,reg,ahat\n.*                 what: label, (reg), 'literal', f/h/b.label\n.*-\n.XLA     anop\n         lclc  &xlar,&xlap,&xla\n         lcla  &xlapn,&xlan\n&$xlalen setc  ''\n&xlar    setc  '&syslist(2)'\n&xlapn   seta  2\n.xlanext anop\n&xlapn   seta  &xlapn+1\n         aif   (&xlapn gt n'&syslist).xlan\n&xlap    setc  '&syslist(&xlapn)'\n         aif   (k'&xlap eq 0).xlanext\n         aif   ('&xlap '(1,1) eq '(').xlareg\n         aif   ('&xlap '(1,1) eq '''').xlalit\n         aif   ('&xlap  '(2,1) eq '.').xlafld\n&xla     setc  t'&xlap\n         aif   ('&xla' eq 'N').xlanum\n         la    &xlar,&xlap\n&$xlalen setc 'l''&xlap'\n         mexit\n.xlanum  anop\n         lgfi  &xlar,&xlap\n         mexit\n.xlafld  anop\n&xlan    seta  k'&xlap-2\n&xla     setc  '&xlap'(1,1)\n&xla     setc  Upper('&xla')\n         aif   ('&xla' ne 'F').xlafld2\n&xla     setc  ''\n.xlafld2 anop\n&xlap    setc  '&xlap'(3,&xlan)\n         l&xla &xlar,&xlap\n         mexit\n.xlareg  anop\n&xlan    seta  k'&xlap-2\n&xlap    setc  '&xlap'(2,&xlan)\n         lr    &xlar,&xlap\n         mexit\n.xlalit  anop\n         la    &xlar,=c&xlap\n&xlan    seta k'&xlap-2\n&$xlalen setc '&xlan'\n.xlan    mexit\n.mend    MEND\n.* ADD NAME=STRLEN\n         Macro\n.* return length of string in r15\n.* data=(addr,len) or label\n&ml      StrLen &data=,&pad=c' '\n         gblc  &$lalenc\n         $la   r14,&data(1)\n         $la   r15,&data(2),&$lalenc\n         ar    r15,r14\n         bctr  r15,0\n         cli   0(r15),&pad\n         je    *-6\n         cr    r15,r14\n.*       jh    *+10\n         jnl   *+10\n         sr    r15,r15                 null string\n         j     *+10\n         sr    r15,r14\n         la    r15,1(,r15)\n         ltr   r15,r15\n         Mend\n.* ADD NAME=STRPOS\n         Macro\n.*-\n.* Find position of argument in string.\n.*\n.* Parameters\n.*  arg       address and optionally length of argument\n.*  str       address and optionally length of string\n.*  default length for both is the first operand length\n.*\n.* Registers used\n.*  r0, r1, r14, r15\n.*\n.* Registers at exit\n.*  r1  -> argument in string if found\n.*  r1  = 0 if argument is not found, or string is not big enough\n.*\n.* Samples\n.*\n.*         StrPos arg=arg1,str=str1    sets r1 = 7\n.*         ltr   r1,r1\n.*         bz    notfound\n.*  arg1   dc    c'was'\n.*  str1   dc    c'Kilroy was here'\n.*\n.*         StrPos arg=((r2),(r3)),str=((r4,r5)))\n.*\n.* yeah I know I really should use the SRST instruction, but that\n.* requires more registers, and end-of-string handling is weird.\n.*\n.* Author\n.*     Willy Jensen\n.*     mail: willy@harders-jensen.com\n.*     web : http://harders-jensen.com/wjtech/index.html\n.*-\n&ml      StrPos  &arg=,&str=\n         gbla  &$lalen\n         lclc  &l,&s\n&l       setc  'zsp&sysndx'\n&ml      $la   r1,&str(1)            -> string begin\n         $la   r0,&str(2),l'&str(1)  string length\n         $la   r14,&arg(1)           arg\n         $la   r15,&arg(2),l'&arg(1) arg length\n.*\n         cr    r0,r15                is string as wide\n         jl    &l.n                    as arg?\n         sr    r0,r15                length to scan\n         ar    r0,r1                 last pos to scan\n         bctr  r15,0                 arg mch length\n         icm   r15,2,0(r14)          1st char of arg to 3rd byte of reg\n&l.a     clm   r15,2,0(r1)           compare 1st char\n         jne   &l.b\n         ex    r15,&l.t              compare\n         je    &l.x\n&l.b     la    r1,1(,r1)             bump string ptr\n         cr    r1,r0                 test end of string\n         jnh   &l.a                  try next\n&l.n     sr    r1,r1                 set not found\n         j     &l.x\n&l.t     clc   0(*-*,r1),0(r14)\n&l.x     ltr   r1,r1\n         Mend\n.* ADD NAME=STRTEST\n          Macro\n.*\n.* Test string for contents\n.* Contents types: NUMeric\n.*\n&mlbl    StrTest &str=,&test=\n         lclc  &s,&t,&l\n         gblc  &$lalenc\n&l       setc  'st&sysndx'\n&mlbl    $la   r14,&str(1)\n         $la   r15,&str(2),&$lalenc\n&t       setc  Upper('&test')\n         aif   ('&t' eq 'NUM').num\n         mnote 8,'Invalid test type'\n         mexit\n.num     anop\n&l.a     cli   0(r14),c'0'\n         jl    &l.x\n         cli   0(r14),c'9'\n         jh    &l.x\n         la    r14,1(,r14)\n         bct   r15,&l.a\n&l.x     ltr   r15,r15          zero => ok\n         mexit\n         Mend\n.* ADD NAME=STRR2D\n         Macro\n.*-\n.* STRR2D - convert hex value in register to readable (decimal)\n.*\n.* Syntax\n.*  STRR2D \u00ddCALL,\u00a8REG=register,TO=(addr,len)\n.*        addr      label, (reg), F.label\n.*        from-len  1-4\n.*        to-len    default is from-len*3\n.*        CALL      generates call to an internally created csect\n.*\n.* Returns\n.*  r0  = length of output\n.*\n.* The  macro calls  an internally  generated subroutine.  This\n.* shortens the code length  for multiple executions of STRC2B,\n.* though adds a bit to the program complexity.\n.*\n.* Notes\n.*  registers 0,1,14,15 are used by the macro\n.*\n.* Author\n.*     Willy Jensen\n.*     mail: willy@harders-jensen.com\n.*     web : http://harders-jensen.com/wjtech\n.*-\n&mlbl    STRR2D &reg=,&to=\n         lclc  &s,&l\n         gblb  &$strr2d\n&l       setc  'RD&sysndx'\n.* call\n         lr    r15,&reg\n         $la   r0,&to(1)\n         $la   r1,&to(2),0\n         l     r14,=v(zstrr2d)\n         basr  r14,r14\n         aif   (&$strr2d).x\n&$strr2d setb  1\n.* module\n&s       setc  '&sysloc'\nZSTRR2D  Amode 31\nZSTRR2D  Rmode any\nZSTRR2D  CSECT\n         stm   r14,r2,12(r13)\n         basr  r2,0\n         ahi   r2,-6\n         push  using\n         using zstrr2d,r2\n.* process\n         l     r14,16(,r13)\n         cvd   r14,60(,r13)\n         lm    r14,r15,20(r13)         to addr and len\n         ltr   r15,r15                 to-len given?\n         jnz   *+8                     yes\n         la    r15,12                  set default length\n         lr    r0,r15                  save target size\n         bctr  r15,0\n         sll   r15,4\n         ex    r15,&l.u\n         srl   r15,4\n         la    r15,0(r14,r15)\n         oi    0(r15),x'f0'\n.* return\n         l     r14,12(,r13)\n         l     r2,28(,r13)\n         sr    r15,r15\n         bsm   0,r14\n&l.u     unpk  0(*-*,r14),60(8,r13)\n         drop  r2\n         pop   using\n&s       Loctr                         resume main\n.x       MEND\n.* ADD NAME=EQUATE\n         MACRO\n&NAME    EQUATE &PRINT=\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*   LIB : SYS2.MACLIB(EQUATE)                                        *\n.*   DOC : GENERATE EQUATES FOR SYMBOLS                               *\n.*   REF : CCS/CS - WJ                                                *\n.*                                                                    *\n.*   SYNTAX :                                                         *\n.*     LABEL  EQUATE GR     => GR0 -> GR15                            *\n.*     LABEL  EQUATE GR,CR  => GR0 -> GR15 AND CR0 -> CR15            *\n.*     LABEL  EQUATE        => R0 -> R15 AND BIT0 -> BIT7 (DEFAULT)   *\n.*     LABEL  SA/SAVEAREA   => SAR0 -> SAR15                          *\n.*     LABEL  EQUATE PRINT=NOGEN => DON'T SHOW MACRO EXPANSION        *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n         LCLA  &INDX,&INCR,&HIGH\n         LCLC  &P\n         GBLA  &IEZBITS\n         GBLB  &EQUATEREGS,&EQUATEBITS,&EQUATESA\n.*\n         AIF   (K'&NAME EQ 0).LBL099\n&NAME    CNOP  0,4\n.LBL099  ANOP\n         MPRINT PUSH,&PRINT\n         AIF   (N'&SYSLIST GT 0).INIT\n         MNOTE *,'*** DEFAULT EQUATES REGS, BITS ASSUMED'\n         EQUATE R,B                    EQUATE REGS AND BITS\n         AGO    .END                   AND TERMINATE\n.*\n.INIT    ANOP\n&INDX    SETA  1\n&HIGH    SETA  15\n&INCR    SETA  0                       INIT COUNTER\n.*\n.SETC    ANOP\n&P       SETC  UPPER('&SYSLIST(&INDX)')\n         AIF   ('&P' EQ 'SA' OR '&P' EQ 'SAVE').SA\n         AIF   ('&P' EQ 'B' OR '&P' EQ 'BITS' ).BITS\n.*\n         AIF   (&EQUATEREGS NE 0).REGS99  BITS ALLREADY SET\n&EQUATEREGS SETB 1\n.EQU     ANOP\n&P.&INCR EQU   &INCR\n         AIF   (&INCR GE &HIGH).NEXT\n&INCR    SETA  &INCR+1\n         AGO   .EQU\n.REGS99  ANOP\n.*\n.NEXT    ANOP\n         AIF   (&INDX GE N'&SYSLIST).END\n&INCR    SETA  0                       INIT COUNTER\n&HIGH    SETA  15                      DEFAULT HIGH-RANGE\n&INDX    SETA  &INDX+1\n         AGO  .SETC\n.*\n.*----\n.BITS    ANOP\n         AIF   (&EQUATEBITS NE 0).BITS99  BITS ALLREADY SET\n&EQUATEBITS SETB 1\n         AIF   (&IEZBITS NE 0).BITS99  BITS ALLREADY SET\n         IEZBITS\n.BITS99  AGO   .NEXT\n.*----\n.SA      ANOP\n         AIF   (&EQUATESA NE 0).SA99   ALREDY DONE?\n&EQUATESA SETB 1\n&P.WD1   EQU   0                       PL/1 ONLY\n&P.HSA   EQU   4                       BACK CHAIN\n&P.LSA   EQU   8                       FWD    -\n&P.RET   EQU   12                      RETURN ADDRESS (R14)\n&P.R14   EQU   SARET\n&P.EPA   EQU   16                      ENTRY POINT ADDRESS (R15)\n&P.R15   EQU   SAEPA\n&P.R0    EQU   20                      REGISTER 0\n&P.R1    EQU   24                      REGISTER 1\n&P.R2    EQU   28                      REGISTER 2\n&P.R3    EQU   32                      REGISTER 3\n&P.R4    EQU   36                      REGISTER 4\n&P.R5    EQU   40                      REGISTER 5\n&P.R6    EQU   44                      REGISTER 6\n&P.R7    EQU   48                      REGISTER 7\n&P.R8    EQU   52                      REGISTER 8\n&P.R9    EQU   56                      REGISTER 9\n&P.R10   EQU   60                      REGISTER 10\n&P.R11   EQU   64                      REGISTER 11\n&P.R12   EQU   68                      REGISTER 12\n         AGO   .NEXT\n.*----\n.END     ANOP\n         MPRINT POP\n         MEND\n.* ADD NAME=MPRINT\n         MACRO\n         MPRINT\n         GBLA  &MPRINTN\n         GBLC  &MPRINT\n.*\n         AIF   ('&SYSLIST(1)' EQ 'PUSH' OR                             +\n               '&SYSLIST(1)'(1,2) EQ 'SA').SA\n         AIF   ('&SYSLIST(1)' EQ 'POP' OR                              +\n               '&SYSLIST(1)'(1,2) EQ 'RE').RS\n         MNOTE 12,'***ERROR - INVALID FUNCTION &SYSLIST(1)'\n         MEXIT\n.*\n.SA      ANOP\n&MPRINT  SETC  '&SYSLIST(2)'           USE IF SPECIFIED\n         AIF   (K'&SYSLIST(2) EQ 0 AND K'&SYSLIST(3) EQ 0).SA900\n         AIF   (K'&SYSLIST(2) EQ 0).SA030\n.SA020   ANOP\n&MPRINT  SETC  '&SYSLIST(2)'           USE SPECIFIED\n         AGO   .SA100\n.SA030   ANOP\n&MPRINT  SETC  '&SYSLIST(3)'           USE DEFAULT\n.*\n.SA100   PUSH  PRINT\n&MPRINTN SETA  &MPRINTN+1\n         PRINT &MPRINT\n.SA900   ANOP\n         MEXIT\n.*\n.RS      ANOP\n         AIF   (K'&MPRINT EQ 0).RS999\n         AIF   (&MPRINTN EQ 0).RS0800\n         AIF   (N'&SYSLIST EQ 1).RS0100\n         AGO   .RS0200\n.*--------------------------------------------------------------------*\n.*  POP SINGLE STACK                                                  *\n.*--------------------------------------------------------------------*\n.RS0100  ANOP\n         POP   PRINT\n&MPRINTN SETA  &MPRINTN-1\n         MEXIT\n.*--------------------------------------------------------------------*\n.*  POP ENTIRE STACK                                                  *\n.*--------------------------------------------------------------------*\n.RS0200  ANOP\n         AIF   ('&SYSLIST(2)' NE 'ALL').RS02E1\n.RS0210  ANOP\n         POP   PRINT\n&MPRINTN SETA  &MPRINTN-1\n         AIF   (&MPRINTN GT 0).RS0210\n         MNOTE *,'*** ENTIRE STACK CLEARED'\n         MEXIT\n.RS02E1  ANOP\n         MNOTE 8,'*** ERROR - INVALID SECOND OPERAND - &SYSLIST(2)'\n         MEXIT\n.*--------------------------------------------------------------------*\n.*  EMPTY STACK                                                       *\n.*--------------------------------------------------------------------*\n.RS0800  ANOP\n         MNOTE *,'*** PUSH STACK EMPTY'\n.RS999   MEXIT\n         MEND\n.* ADD NAME=$LOCATE\n         MACRO\n.*\n.* LOCATE VARIOUS CONTROL BLOCKS\n.*\n&LBL     $LOCATE &QCB,&TYPE,&REG=R15,&USING=NO,&DCB=,&NAME=,           +\n               &DDNAME=,&ERROR=,&PRINT=,&ECB=,&TIOTA=,                 +\n               &DSECTS=\n.*--\n         LCLA  &N,&M\n         LCLC  &L,&C,&O,&CB,&USNG\n&CB      SETC  UPPER('&QCB')\n&USNG    SETC  UPPER('&USING')\n&L       SETC  'Z'.'&SYSNDX'\n.*--\n         AIF   (K'&PRINT EQ 0).PRINTIN\n         PUSH  PRINT\n         PRINT &PRINT\n.PRINTIN ANOP\n         AIF   (K'&LBL EQ 0).LBL099\n&LBL     CNOP  0,4\n.LBL099  ANOP\n.*--\n         AIF   ('&CB' EQ 'TCB').TCB\n         AIF   ('&CB' EQ 'JSTCB').JSTCB\n         AIF   ('&CB' EQ 'JSCB').JSCB\n         AIF   ('&CB' EQ 'JCT').JCT\n         AIF   ('&CB' EQ 'ASCB').ASCB\n         AIF   ('&CB' EQ 'TIOT').TIOT\n         AIF   ('&CB' EQ 'JOBNAME' OR '&CB' EQ 'JBN').JBN\n         AIF   ('&CB' EQ 'DDENTRY' OR '&CB' EQ 'DD').DDENT\n         AIF   ('&CB' EQ 'DDNAME' OR '&CB' EQ 'DDN'                    +\n               OR K'&DDNAME GT 0).DDN\n         AIF   ('&CB' EQ 'SUBSYS').SSYS\n         AIF   ('&CB' EQ 'JESCOMCHAR').JCOM\n         AIF   ('&CB' EQ 'SMFID').SMFID\n         AIF   ('&CB' EQ 'PGMNAME').PGMN\n         AIF   ('&CB' EQ 'PGM').PGMN\n         AIF   ('&CB' EQ 'ECT').ECT\n         MNOTE 8,'*** ERROR - INVALID BLOCK - &CB'\n         MEXIT\n.*--\n.* TCB - REQUIRED MAPPING MACRO: IKJTCB\n.TCB     ANOP\n         L     &REG,16                 -> CVT\n         L     &REG,0(,&REG)           -> TCBWORDS\n         L     &REG,4(,&REG)           -> CURRENT TCB\n         AIF   ('&USING' NE 'YES').MEXIT\n         USING TCB,&REG\n         AGO   .MEXIT\n.*--\n.* JSTCB - REQUIRED MAPPING MACRO: IKJTCB\n.JSTCB   ANOP\n         $LOCATE TCB,REG=&REG\n         L     &REG,TCBJSTCB-TCB(,&REG)  -> JOBSTEP TCB\n         AIF   ('&USING' NE 'YES').MEXIT\n         USING TCB,&REG\n         AGO   .MEXIT\n.*--\n.* JSCB - REQUIRED MAPPING MACRO: IEZJSCB\n.JSCB    ANOP\n         $LOCATE JSTCB,REG=&REG\n         L     &REG,TCBJSCB-TCB(,&REG)   -> JSCB\n         AIF   ('&USING' NE 'YES').MEXIT\n         USING IEZJSCBG,&REG\n         AGO   .MEXIT\n.*--\n.* JCT  - REQUIRED MAPPING MACRO: IEFAJCTB\n.JCT     ANOP\n         $LOCATE JSCB,REG=&REG\n         ICM   &REG,7,JSCBJCTA-IEZJSCB(&REG) -> JCT\n         SLL   &REG,4                    CLEAR\n         SRL   &REG,4                      HI-ORDER BYTE\n         LA    &REG,16(,&REG)            FOUND BY TESTING\n         AIF   ('&USING' NE 'YES').MEXIT\n         USING INJMJCT,&REG\n         AGO   .MEXIT\n.*--\n.* ASCB - REQUIRED MAPPING MACRO: IHAASCB\n.ASCB    ANOP\n         L     &REG,16                 -> CVT\n         L     &REG,0(,&REG)           -> TCBWORDS\n         L     &REG,12(,&REG)          -> CURRENT ASCB\n         AIF   ('&USING' NE 'YES').MEXIT\n         USING ASCB,&REG\n         AGO   .MEXIT\n.*--\n.TIOT    ANOP\n.JBN     ANOP\n         $LOCATE TCB,USING=NO,REG=&REG\n         L     &REG,12(,&REG)          -> TIOT\n         AIF   (K'&TIOTA EQ 0).TIOTAN\n         ST    &REG,&TIOTA             SAVE ADDRESS\n.TIOTAN  ANOP\n         AIF   ('&CB' NE 'JOBNAME' AND '&CB' NE 'JBN').MEXIT\n         MNOTE *,'* &REG -> DC CL8''JOBNAME'' '\n         AGO   .MEXIT\n.*--\n.* ECT  - REQUIRED MAPPING MACROS:\n.*       IHAPSA,IKJTCB,IEZJSCB,IKJPSCB,IKJRLGB,IKJECT\n.ECT     ANOP\n         L     &reg,PSATOLD-PSA     -> TCB\n         L     &reg,TCBJSCB-TCB(,&reg) -> JSCB\n         L     &reg,JSCBPSCB-IEZJSCB(,&reg) -> PSCB\n         L     &reg,PSCBRLGB-PSCB(,&reg) -> RELOGON BUFFER\n         L     &reg,RLGBECT-RLGB(,&reg) -> ECT\n         AIF   ('&USING' EQ 'NO').MEXIT\n         USING ECT,&REG\n         AGO   .MEXIT\n.*--\n.DDENT   ANOP\n         $LOCATE TIOT,REG=&REG\n         AH    &REG,&DCB+DCBTIOT-IHADCB  ADD OFFSET INTO TIOT\n         MNOTE *,'* &REG + 4 -> DC CL8''DDNAME'' '\n         AGO   .MEXIT\n.*--\n.DDN     ANOP\n.*--------------------------------------------------------------------*\n.*    LOCATE DDNAME THROUGH TIOT                                      *\n.*    IF DDNAME = '*', THEN LOCATE NEXT OR FIRST IF ECB IS ZERO.      *\n.*    ALSO SCAN IF &TYPE EQ '*'                                       *\n.*    BYPASS USE OF ECB IF DDNAME IF NOT NULL.                        *\n.*--------------------------------------------------------------------*\n         LCLC  &DDNECB\n.*--\n         AIF   ('&TYPE' EQ '*' OR '&DDNAME' EQ '*').DDN10\n         AGO   .DDN50                  ELSE TRY SPECIFIC DDNAME\n.*--\n.DDN10   ANOP\n.*--\n&DDNECB  SETC  '&ECB'                  SET ADDRESS\n         AIF   (K'&DDNECB GT 0).DDNECB2\n&DDNECB  SETC  '&L.ECB'                SET ADDRESS\n         B     &DDNECB+4               JUMP AROUND ECB\n&DDNECB  DC    A(0)\n.DDNECB2 ANOP\n.*--\n         $LA   R14,&DDNECB             -> ECB\n         ICM   R15,15,0(R14)           LOAD AND TEST\n         BNZ   &L.N1                   IF ZERO, THEN NOT FIRST TRY\n         $LOCATE  TIOT                 FIND TIOT, SET ADDRESS IN GR15\n         LA    R15,24(,R15)            JUMP TO 1ST DD ENTRY\n         B     &L.N3                   PROCESS 1ST ENTRY\n&L.N1    SLR   R0,R0\n         ICM   R0,B'0001',0(R15)       GET  LENGTH OF DD-ENTRY\n         BNZ   &L.N2                   GOODBYE IF LAST DD-ENTRY\n         LA    R15,4                   SET RC FOR LAST DD-ENTRY\n         B     &L.X                    AND SAY GOODBYE\n&L.N2    AR    R15,R0                  CHAIN TO NEXT DD ENTRY\n&L.N3    LA    R1,4(,R15)              -> DDNAME\n         ST    R15,0(R14)              SAVE ADDRESS IN ECB\n         SLR   R15,R15                 SET GOOD RC\n&L.X     LTR   R15,R15                 AND SET FOR BRANCH\n         AGO   .MEXIT\n.*--\n.DDN50   ANOP\n         $LOCATE  TIOT                 FIND TIOT, SET ADDRESS IN GR15\n         LA    R15,24(,R15)            JUMP TO 1ST DD ENTRY\n         SLR   R0,R0                   LOCATE DD ENTRY IN TIOT\n         AIF   ('&DDNAME'(1,1) NE '''').DDNLA\n         LA    R1,=CL8&DDNAME\n         AGO   .DDNLN\n.DDNLA   $LA   R1,&DDNAME              -> DDNANE\n.DDNLN   ANOP\n&L.L     ICM   R0,B'0001',0(R15)       GET  LENGTH OF DD-ENTRY\n         BZ    &L.X4                   GOODBYE IF LAST DD-ENTRY\n         CLC   4(8,R15),0(R1)          COMPARE AGAINST TARGET\n         BE    &L.X0\n         AR    R15,R0                  CHAIN TO NEXT DD ENTRY\n         B     &L.L\n&L.X0    SLR   R15,R15                 SET GOOD RETURN\n         B     &L.N                    AND CONTINUE MAINLINE\n.DDNX4   ANOP\n&L.X4    LA    R15,4                   DD ENTRY NOT FOUND\n&L.N     LTR   R15,R15                 SET RETURN CODE\n         AIF   (K'&ERROR EQ 0).MEXIT\n         BNZ   &ERROR\n*-\n         AGO   .MEXIT\n.*--------------------------------------------------------------------*\n.*   LOCATE SUBSYSTEM CONTROL BLOCK                                   *\n.*--------------------------------------------------------------------*\n.SSYS    ANOP\n         AIF   ('&REG' EQ 'R1').SSYS901\n.*--------------------------------------------------------------------*\n.*   GENERATE DSECTS                                                  *\n.*--------------------------------------------------------------------*\n         GBLB  &DSCTCVT,&DSCTTCB,&DSCTJES,&DSCTSSV,&DSCTSCV\n         AIF   (N'&DSECTS EQ 0).DSCT090\n         PUSH  PRINT\n         PRINT NOGEN\n&C       SETC  '&SYSECT'\n&N       SETA  0\n.DSCT010 ANOP\n         AIF   (&N EQ N'&DSECTS).DSCT090\n&N       SETA  &N+1\n&O       SETC  '&DSECTS(&N)'\n         AIF   ('&O' EQ 'CVT').DSCTCVT\n         AIF   ('&O' EQ 'TCB').DSCTTCB\n         AIF   ('&O' EQ 'JESCT').DSCTJES\n         AIF   ('&O' EQ 'SSVT').DSCTSSV\n         AIF   ('&O' EQ 'SCVT').DSCTSCV\n         MNOTE  8,'*** INVALID DSECTNAME - &O'\n         MEXIT\n.DSCTCVT AIF   (&DSCTCVT).DSCT010\n&DSCTCVT SETB  1\n         CVT   DSECT=YES,PREFIX=NO\n         AGO   .DSCT010\n.DSCTTCB AIF   (&DSCTTCB).DSCT010\n&DSCTTCB SETB  1\n         IKJTCB\n         AGO   .DSCT010\n.DSCTJES AIF   (&DSCTJES).DSCT010\n&DSCTJES SETB  1\n         IEFJESCT\n         AGO   .DSCT010\n.DSCTSCV AIF   (&DSCTSCV).DSCT010\n&DSCTSCV SETB  1\n         IEFJSCVT\n         AGO   .DSCT010\n.DSCTSSV AIF   (&DSCTSSV).DSCT010\n&DSCTSSV SETB  1\n         IEFJSSVT\n         AGO   .DSCT010\n.DSCT090 ANOP\n         POP   PRINT\n&C       CSECT\n.*--------------------------------------------------------------------*\n.*   LOCATE SUBSYSTEM VECTOR TABLE                                    *\n.*--------------------------------------------------------------------*\n.SSYS100 ANOP\n         L     R1,16                   -> CVT\n         LA    R14,255                 LOOP PROTECTION\n         L     R1,CVTJESCT-CVT(R1)\n         L     &REG,JESSSCT-JESCT(R1)  POINT TO SUBSYS CVT\n&L.A     CLC   =CL4'&NAME',SSCTSNAM-SSCT(&REG) CHECK NAME\n         BE    &L.X0\n         CLC   =XL4'00',SSCTSCTA-SSCT(&REG)  END OF SUBSYS CHAIN\n         BE    &L.X4\n         L     &REG,SSCTSCTA-SSCT(&REG)  GET NEXT SUBSYS CVT\n         BCT   R14,&L.A\n&L.X4    EQU   *\n         SLR   &REG,&REG               NOT FOUND\n&L.X0    EQU   *\n         LTR   &REG,&REG\n         AGO   .MEXIT\n.SSYS901 ANOP\n         MNOTE 8,'*** ERROR - REGISTERS 1 AND/OR 14 ARE USED INSIDE THE+\n                MACRO AND CANNOT BE USED FOR THE REG OPERAND'\n         AGO   .MEXIT\n.*--------------------------------------------------------------------*\n.*   LOCATE JES2 COMMAND CHAR                                         *\n.*--------------------------------------------------------------------*\n.JCOM    ANOP\n         GBLB  &$LOCDSC2\n         AIF   ('&DSECTS' EQ 'NO' OR &$LOCDSC2).JCOM100\n         PUSH  PRINT\n         PRINT NOGEN\n&C       SETC  '&SYSECT'\n         CVT   DSECT=YES,PREFIX=NO\n         IEFJESCT\n         IEFJSCVT\n*        IEFJSSVT\n         $XECB\n         $SCAT\n         $SVT\n         POP   PRINT\n&C       CSECT\n&$LOCDSC2 SETB 1\n.JCOM100 ANOP\n&C       SETC  'JES2'\n         AIF   (K'&NAME EQ 0).JCOM101\n&C       SETC  '&NAME'\n.JCOM101 ANOP\n         $LOCATE SUBSYS,NAME=&C,REG=&REG,DSECTS=NO\n         BZ    &L.X                    SUBSYSTEM NOT FOUND IF ZERO\n         L     &REG,SSCTSSVT-SSCT(&REG) -> SUBSYSTEM VECTOR TABLE\n         LA    &REG,$SVCOMCH-SSVT(&REG) -> COMMAND CHAR\n&L.X     EQU   *\n.*\n.*--------------------------------------------------------------------*\n.*   LOCATE SMFID - REDQ DSECTS : SMCA, CVT                           *\n.*--------------------------------------------------------------------*\n.SMFID  ANOP\n         L     &REG,16                        -> CVT\n         L     &REG,CVTSMCA-CVTMAP(&REG)      -> IEESMCA\n         LA    &REG,SMCASID-SMCABASE(&REG)    SMFID\n         MEXIT\n.*--------------------------------------------------------------------*\n.*   LOCATE PROGRAM NAME IN THE CDE                                   *\n.*--------------------------------------------------------------------*\n.PGMN    ANOP\n         $LOCATE TCB,REG=&REG\n         L     &REG,TCBRBP-TCB(&REG)          -> CURRENT RB\n         LA    &REG,0(,&REG)\n         L     &REG,RBCDE-RBBASIC(&REG)       -> CDE\n         LA    &REG,8(,&REG)                  ->  PROGRAMNAME\n         MEXIT\n.*--------------------------------------------------------------------*\n.MEXIT   ANOP\n         AIF   (K'&PRINT EQ 0).PRINTTN\n         POP   PRINT\n.PRINTTN ANOP\n         MEND\n.* ADD NAME=GETPARM\n         MACRO\n&LBL     GETPARM &AREADEF=,&MAXLEN=,&NOPARM=,&REG=R1,&CLEAR=YES,       +\n               &TSO=YES,               BEWARE OF TSO CALL              +\n               &PRINT=GEN\n.*\n.*  MOVE PARAMETER FIELD FROM THE 'EXEC' JCL STATEMENT TO AN\n.*  INTERNAL AREA.\n.*\n.*  OPERANDS :\n.*      AREADEF A-TYPE ADDRESS OF RECEIVING AREA.\n.*              MAY ALSO BE SYSLIST(1).\n.*      MAXLEN  MAXIMUM LENGTH OF PARAMETER. DEFAULT IS LENGTH\n.*              OF RECEIVING FIELD.\n.*      NOPARM  A-TYPE ADDRESS. CONTINUE HERE IF THERE ARE\n.*              NO PARAMETER FIELD SPECIFIED.\n.*      REG     DEFINES TO WHICH R1 HAS BEEN COPIED.\n.*      CLEAR   SET RECEIVE AREA TO BALNKS BEFORE RETREIVE.\n.*      PRINT   GEN/NOGEN - USED TO SUPPRESS PRINT OF MACRO\n.*              EXPANSION.\n.*\n.*   THE MACRO USES R0 AND R15 AS WORK REGISTERS.\n.*\n.*\n         LCLA  &N,&M\n         LCLC  &L,&NOPA,&AL\n         LCLC  &AREA\n&AREA    SETC  '&AREADEF&SYSLIST(1)'\n.*\n&L       SETC  'Z&SYSNDX'\n&NOPA    SETC  '&L.X'                  DEFAULT\n         AIF   (K'&NOPARM EQ 0).ZP99\n&NOPA    SETC  '&NOPARM'               ADDRESS WHEN NO PARMS\n.ZP99    ANOP\n&AL      SETC  'L''&AREA'\n         AIF   (K'&MAXLEN EQ 0).MAXL99\n&AL      SETC  '&MAXLEN'\n.MAXL99  ANOP\n         PUSH  PRINT\n         PRINT &PRINT\n*---------------------------------------------------------------------*\n*   OBTAIN PARAMETER STRING IF PRESENT                                *\n*---------------------------------------------------------------------*\n         AIF   ('&CLEAR' NE 'YES').CLRN\n&N       SETA  (L'&AREA)-1\n         AIF   (&N LT 254).CLR200\n&N       SETA  254\n.CLR200  ANOP\n         MVI   &AREA,C' '              INITIALIZE FIRST BYTE\n         MVC   &AREA+1(&N),&AREA       FORCE THROUGH REST\n.CLRN    ANOP\n         SR    R15,R15                 INITIAL LENGTH = 0\n         ICM   &REG,15,0(&REG)\n         BZ    &NOPA                   NO PARMS IF ZERO\n         SLR   R15,R15\n         ICM   R15,3,0(&REG)           LOAD LENGTH\n         BZ    &NOPA                   NO PARMS IF ZERO\n         LA    R0,&AL\n         CR    R15,R0                  CHECK MAX LENGTH\n         BNH   *+6\n         LR    R15,R0                  TRUNCATE\n.*--------------------------------------------------------------------*\n.*   TSO PARM : BEWARE OF PREFIX AND SUFFIX                           *\n.*--------------------------------------------------------------------*\n.TSO     AIF   ('&TSO' NE 'YES').TSON\n         CLI   2(&REG),X'00'           INDICATE TSO ??\n         BNE   &L.TN                   NOPE\n         SH    R15,2(,&REG)            SUBTRACT PREFIX LENGTH\n         BCTR  R15,0                   SUBTRACT PREFIX 1ST BYTE\n         BCTR  R15,0                               -   2ND BYTE\n         BCTR  R15,0                   SUBTRACT SUFFIX 1ST BYTE\n         BCTR  R15,0                               -   2ND BYTE\n         AH    &REG,2(&REG)            BUMP POINTER\n         LA    &REG,2(,&REG)                -\n&L.TN    EQU   *\n.TSON    ANOP\n.*--------------------------------------------------------------------*\n.*   MOVE TO RECEIVING AREA                                           *\n.*--------------------------------------------------------------------*\n         BCTR  R15,0                   GET MACHINE LENGTH\n         EX    R15,*+8\n         B     *+10\n         MVC   &AREA.(*-*),2(&REG)     COPY TO OWN AREA\n         LA    R15,1(,R15)             REINSTATE REAL LENGTH\n&L.X     EQU   *\n.MEXIT   ANOP\n         POP   PRINT\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "VCBMACS": {"ttr": 10246, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01a\\x00P\\x01\\x16\\x01\\x0f\\x01\\x19'_ 3\\x06B\\x03\\xcc\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@\"", "ispf": {"version": "01.97", "flags": 0, "createdate": "2016-01-10T00:00:00", "modifydate": "2019-10-02T20:33:50", "lines": 1602, "newlines": 972, "modlines": 0, "user": "DVL"}, "text": "*-\n* VCBMACS\n* Macros for handling local memory structure.\n* Storage areas can be added, updated, deleted and searched.\n* Each area is named.\n*\n*  Sample\n*        VCBGlobal anchor=f.VCBa,subbase=r11,keepnum=30,keepmaxw=1024\n*        . .\n*        VCBAACQ init=y,anchorr=r8\n*        st    r8,VCBa\n*        . .\n*        la    r2,6\n*        VCBPut name=(name,(r2)),data=((r6),(r4))\n*        . .\n*        la    r2,name\n*        la    r3,6\n*        VCBGet name=((r2),(r3)),data=data\n*        . .\n*        VCBCall Drop\n*        . .\n*  name  dc  c20'KILROY'\n*  data  dc  cl200' '\n*        . .\n*        VCBANCHR dsect=yes\n*        VCBmodul\n*        VCB   ,   dsect\n*\n* Updates\n*  2016-01-11 VCBscan fix handling of 'all'\n*  2016-08-12 Fix updates of fields VCBAaqn and VCBAfqn\n*  2017-09-08 Load of changes to make VCB reentrant\n*             Reverse order of len,addr parameters for VCBLOCATE\n*             New macro VCBGET\n*             VCBSCAN is disabled\n*  2018-08-04 'C,rx,eq=a(n)' changed to 'CLFI,rx,eq,n)'\n*  2018-11-01 add 'subbase' to globals, change VCBENTRY accordingly.\n*  2018-11-05 add function 'VCBDELAL' - delete all entries in a pool.\n*             change VCBDEL, only move VCB to free if size le 4k.\n*  2018-12-19 add macro VCBAACQ for getmain and init of anchor\n*  2019-01-15 use macro STRC2X instead of CVXD.\n*  2019-06-17 add LOC=31 to all STORAGE OBTAIN\n*\n* Author\n*     Willy Jensen\n*     mail: willy@harders-jensen.com\n*     web : http://harders-jensen.com/wjtech/index.html\n*-\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n*        VCBGLOBAL   : set globals                                    *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n         Macro\n         VCBGLOBAL &anchor=,&trace=N,&subbase=,&keepnum=,&keepmaxw=,   c\n               &sp=131\n         gblc  &$$vcbanchor,&$$vcbtrace,&VCBsubbase\n         gblc  &$$vcbkeepnum,&$$vcbkeepmaxw,&$$vcbsp\n&$$vcbanchor   setc '&anchor'\n&$$vcbtrace    setc '&trace'\n&VCBsubbase    setc '&subbase'\n&$$vcbkeepnum  setc '&keepnum'\n&$$vcbkeepmaxw setc '&keepmaxw'\n&$$vcbsp       setc '&sp'\n mnote *,'VCB globals: anchor=&$$vcbanchor trace=&$$vcbtrace subbase=&V+\n               CBsubbase sp=&$$vcbsp'\n         Mend\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n*        VCBCALL     : Call VCB routine                               *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n         Macro\n         VCBCALL &mod,&anchor=,&name=,&data=,&parmlist=\n         gblc  &$$vcbanchor,&gblsetpc\n         lclc  &l,&s,&lanchr\n         lcla  &n,&p\n         aif   (k'&mod ne 0).modn\n         mnote 8,'*** modname (parm 1) missing'\n         mexit\n.modn    anop\n         VCBsetgp C,&anchor,&$$vcbanchor\n         aif   (k'&gblsetpc ne 0).anchr1\n         mnote 8,'*** VCBCALL Anchor not defined'\n         mexit\n.anchr1  anop\n&lanchr  setc  '&gblsetpc'\n&l       setc  'VCB&sysndx'\n         aif   (k'&parmlist eq 0 and k'&name eq 0                      c\n               and k'&data eq 0).call\n         $la   r1,&lanchr\n         la    r1,VCBAcpl-VCBAnchr(,r1) -> call parameter list\n         aif   (k'&parmlist ne 0).prmlst   superceedes name/data\n         aif   (k'&name gt 0 and k'&data gt 0).ndsetb\n         aif   (k'&name gt 0 and k'&data eq 0).ndsetn\n         aif   (k'&name eq 0 and k'&data gt 0).ndsetd\n         ago   .call\n.ndsetb  anop\n*name\n         $la   r14,&name(1)            address\n         $la   r15,&name(2)            length\n         stm   r14,r15,0(r1)           save\n*data\n         $la   r14,&data(1)            address\n         $la   r15,&data(2)            length\n         stm   r14,r15,8(r1)           save\n         ago   .call\n.ndsetn  anop\n*name\n         $la   r14,&name(1)\n         $la   r15,&name(2)\n         stm   r14,r15,0(r1)           save\n         ago   .call\n.ndsetd  anop\n*data\n         $la   r14,&data(1)\n         $la   r15,&data(2)\n         stm   r14,r15,0(r1)           save\n         ago   .call\n.prmlst  anop  ,\n*parmlist\n&n       seta  &n+1\n         aif   (&n gt n'&parmlist).prmlstn\n&l       setc  '&parmlist(&n)'\n         $la   r14,&l\n         st    r14,&p.(,r1)\n&p       seta  &p+4\n         ago   .prmlst\n.prmlstn anop\n         oi    VCBAcpl+&p,x'80'         set VL flag\n.call    anop\n         $la   r0,&lanchr              -> VCB anchor\n&s       setc  Upper('&mod')\n         aif   ('&s   '(1,3) eq 'VCB').call2\n         l     r15,=V(VCB&mod)\n         ago   .callx\n.call2   l     r15,=V(&mod)\n.callx   basr  r14,r15\n         ltr   r15,r15\n         Mend\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n*        VCBSETGP  subroutine, set parameter                          *\n* syntax: what,parm1,parm2,..,parmn                                   *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n         Macro\n         VCBSETGP\n         gblc  &gblsetpc\n         gbla  &gblsetpa\n         lcla  &n\n         lclc  &p,&s\n&gblsetpc  setc  ''\n&gblsetpa  seta  0\n&s       setc  Upper('&syslist(1)')\n         aif   ('&s' eq 'A' or '&s' eq 'C').typeok\n         mnote 8,'** Invalid 1st operand, must be A or C'\n         mexit\n.typeok  anop\n&n       seta  1\n.a       anop\n&n       seta  &n+1\n&p       setc  '&syslist(&n)'\n         aif   (k'&p ne 0 and '&s' eq 'A').seta\n         aif   (k'&p ne 0 and '&s' eq 'C').setc\n         aif   (&n lt n'&syslist).a\n         mexit\n.seta    anop\n&gblsetpa seta  &p\n         mexit\n.setc    anop\n&gblsetpc setc  '&p'\n         mexit\n         Mend\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n*        VCBENTRY  subroutine entry                                   *\n* r0 -> Anchor                                                        *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n         MACRO\n&name    VCBEntry &BASE=,&ANCHORR=\n         gblc  &VCBsubname,&VCBsubbase,&VCBentbase\n         gblc  &$$vcbsave,&VCBanchrr\n         mnote *,'save: &$$vcbsave'\n         lclc  &pgm,&l,&lbase\n&l       setc  '$$&sysndx'\n&pgm     setc  (UPPER '&name')\n&VCBsubname setc '&pgm'\n&VCBanchrr  setc '&anchorr'\n         ds    0d\n&lbase   setc  '&base'\n         aif   (k'&lbase ne 0).basen\n&lbase   setc  '&VCBsubbase'\n         aif   (k'&lbase ne 0).basen\n&lbase   setc  'r12'\n.basen   anop\n&VCBentbase setc '&lbase'\n         using &pgm,&lbase\n         using VCBanchr,&anchorr\n.* &pgm  $$modes\n&pgm     Amode 31\n&pgm     Rmode any\n&pgm     Csect\n         bakr  14,0                    save callers status on stack\n         lr    &lbase,r15\n         lr    &anchorr,r0\n         la    r15,VCBAsan             end of save areas\n         la    r13,VCBAsa1             locate free save area\n         do    forever\n           if    (cli,0(r13),eq,0),then=leave  free\n           la    r13,72(,r13)          -> next\n           if    (cr,r13,ge,r15)       overflow?\n             ABEND 401,DUMP\n           endif\n         enddo\n         mvi   0(r13),255              set 'in use'\n         clear VCBAtrrec\n         VCBtrcX '&pgm begin'\n         Ereg  0,1\n.x       MEND\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n*        VCBEXIT  subroutine exit                                     *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n         MACRO\n&name    VCBExit  &RC=,&R1=r1,&SAC=,&trace=Y\n.* trace=y is to allow trace, not neccessarily do it\n         lclc  &pgm,&l,&p1,&u\n         gblc  &VCBsubname,&VCBentbase,&VCBanchrr\n&pgm     setc  '&VCBsubname'\n&l       setc  '$$&sysndx'\n&name    Cnop  0,4\n         aif   (K'&sac eq 0).sac99\n&p1      setc  (UPPER '&sac')\n         aif   ('&p1' eq 'OFF').sacoff\n         sac   &sac\n         ago   .sac99\n.sacoff  sac   0\n.sac99   anop\n.back    anop\n         aif   ('&trace' ne 'Y').trcn\n         VCBtrcX '&pgm exit'\n.trcn    anop\n         aif   (K'&RC eq 0).rcn\n         $la   r15,&RC\n.rcn     anop\n         mvi   0(r13),0                mark savearea as free\n         pr    ,\n.tfinal  anop\n&p1      setc  (UPPER '&syslist(1)')\n         aif   (K'&p1 eq 0).x\n         aif   ('&p1' eq 'FINAL').final\n         mnote 8,'*Invalid 1st parm: &p1'\n         ago   .x\n.final   anop\n         Ltorg\n         ds    0d\n         drop  &VCBentbase,&VCBanchrr\n.x       MEND\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n*              VCB   : data area map (dsect)                          *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n              Macro\n              VCB  &prefix=VCB\n&q            setc  (UPPER '&syslist(1)')\n              aif  ('&q' EQ 'DSECT' or k'&q eq 0).dsect\n              ago   .define\n.dsect        anop\n&prefix       dsect\n.define       anop\n.* Variable Container Block (VCB)\n&prefix.fix   ds  0a\n&prefix.next  ds  a                    -> next block\n&prefix.prev  ds  a                    <- previous block\n&prefix.size  ds  a                    size of block\n&prefix.dataa ds  a                    address of data\n.* keep namel and datal together and right before fixl\n&prefix.rec   ds  0a                   start of external record\n&prefix.namel ds  a                    length of variable name\n&prefix.datal ds  a                    size of data\n&prefix.fixl  equ *-&prefix.fix        length of fixed area\n&prefix.var   equ *                    begin variable section\n&prefix.name  ds  c                    name of variable\n*VCBdata      ds  v                    start of data\n              Mend\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n*              VCBANCHR : anchor data block                           *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n             Macro\n             VCBAnchr &DSECT=YES\n             lclc  &s\n&s           setc  Upper('&dsect')\n             aif   ('&s' ne 'YES').dsectn\n* VCB anchor block, pointed to by the Name/Token service\nVCBAnchr     dsect\n             ago   .dsectx\n.dsectn      anop\nVCBAnchr     ds   0a\n.dsectx      anop\nVCBAeye      ds   cl8                 name\nVCBAflgs1    ds   x                   flags\nVCBAtrace    equ  1                   trace\nVCBArsv1     ds   xl3                 for future use\nVCBAaqh      ds   a                   -> active queue head\nVCBAaqt      ds   a                   -> active queue tail\nVCBAaqn      ds   a                   number of elements on active que\nVCBAfqh      ds   a                   -> free queue head\nVCBAfqt      ds   a                   -> free queue tail\nVCBAfqn      ds   a                   number of elements on free queue\nVCBAmaxdl    ds   a                   max length of VCB data\nVCBAcsrp     ds   a                   cursor (last_key) pointer\n.* internal VCBs\n             VCB  ds,prefix=VCBAH     Pseudo VCB: Head of active queue\n             VCB  ds,prefix=VCBAT     Pseudo VCB: Tail of active queue\n             VCB  ds,prefix=VCBFH     Pseudo VCB: Head of free queue\n             VCB  ds,prefix=VCBFT     Pseudo VCB: Tail of free queue\nVCBAuser     ds   4a                  for caller\nVCBAcpl      ds   0d                  call parameter list\nVCBAwrk      ds   5d                  some work (10 fullwords)\nVCBAcpll     equ  *-VCBAcpl           parameter list size\nVCBAvmaxnl   ds   a                   max length name\nVCBAvmaxdl   ds   a                   max length data\nVCBAvmaxndl  ds   a                   max length name+data\nVCBAfw       ds   a                   internal work\nVCBAdw       ds   d                   internal work\nVCBAsa1      ds   18a                 savearea for module\nVCBAsa2      ds   18a                 savearea for module\nVCBAsa3      ds   18a                 savearea for module\nVCBAsa4      ds   18a                 savearea for module\nVCBAsan      equ  *                   savearea end\nVCBAtrsa0    ds   18a                 savearea for trace\nVCBAtrname   ds   cl9                 for internal tracing\nVCBAtrrec    ds   cl160               for internal tracing\n* work areas for VCBloc\nVCBAlocsn    ds    cl(256)\nVCBAlocvn    ds    cl(256)\n* work areas for VCBFmtNd\nVCBAFmtNdr   ds   cl150\n             ds   0d\nVCBAnchrl    equ  *-VCBAnchr          length\n             Mend\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n*              VCBAACQ  : Acquire storage                             *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n         Macro\n&mlbl    VCBAACQ &init=no,&anchorr=\n         lclc  &ar,&s\n         gblc  &$$vcbanchor,&$$vcbsp\n&mlbl    STORAGE OBTAIN,LENGTH=VCBAnchrl,SP=&$$vcbsp,CALLRKY=YES,loc=31\n         aif   (k'&anchorr eq 0).arn\n         lr    &anchorr,r1\n         using VCBAnchr,&anchorr\n.arn     anop\n&s       setc  Upper('&init')\n         aif   ('&s '(1,1) ne 'Y').initn\n         VCBAinit\n.initn   anop\n.x       Mend\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n*              VCBAINIT : Initialize anchor block                     *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n         Macro\n         VCBAINIT &p1\n         lclc  &what\n         aif   (k'&p1 eq 0).all\n&what    setc  Upper('&p1')\n         aif   ('&what' eq 'ALL').all\n         aif   ('&what' eq 'ACTIVE').act\n         aif   ('&what' eq 'FREE').free\n         mnote 8,*** Invalid parm &p1'\n.all     anop\n&ahat    setc  'ALL'\n         la    r14,VCBAnchr            target address\n         lr    r0,r14                  = source address\n         la    r15,VCBAnchrl           target size\n         sr    r1,r1                   source size and pad\n         mvcl  r14,r0                  all binary zeroes\n         mvc   VCBAeye,=cl8'VCBANCHR'\n.act     anop\n*setup active head\n         la    r1,1\n         st    r1,VCBAHnamel\n         st    r1,VCBAHdatal\n         la    r14,VCBAHfix\n         st    r14,VCBAaqh\n         st    r14,VCBAcsrp            cursor = first\n         st    r14,VCBATprev           back ptr\n*setup active tail\n         la    r1,1\n         st    r1,VCBATnamel           size=1\n         st    r1,VCBATdatal           size=1\n         mvi   VCBATname,X'FF'         tail name\n         la    r14,VCBATfix\n         st    r14,VCBAaqt\n         st    r14,VCBAHnext           fwd ptr\n         xc    VCBAaqn,VCBAaqn         count=0\n         aif   ('&what' eq 'ACTIVE').x only active\n.free    anop\n*setup free head\n         la    r1,1\n         st    r1,VCBFHnamel           size=1\n         st    r1,VCBFHdatal           size=1\n         la    r14,VCBFHfix\n         st    r14,VCBAfqh\n         st    r14,VCBFTprev           back ptr\n*setup free tail\n         la    r1,1\n         st    r1,VCBFTnamel\n         st    r1,VCBFTdatal\n         la    r14,VCBFTfix\n         st    r14,VCBAfqt\n         st    r14,VCBFHnext           fwd ptr\n         xc    VCBAfqn,VCBAfqn         count=0\n         aif   ('&what' eq 'FREE').x   only free\n.x       Mend\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n*              VCBHOOK  : set or update hook                          *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n         Macro\n         VCBHOOK &vcb=,&csr=\n.* hook work VCB onto chain\n         lclc  &l,&q,&r1,&r2\n&q       setc  (UPPER '&syslist(1)')\n&r1      setc  (UPPER '&vcb')\n&r2      setc  (UPPER '&csr')\n         aif   ('&r1' ne 'R15' and '&r2' ne 'R15').onoff\n         mnote 8,'R15 is used internally'\n         mexit\n.onoff   aif   ('&q' eq 'ON' ).on\n         aif   ('&q' eq 'OFF').off\n         mnote 8,'VCBHOOK invalid parm: &q'\n         mexit\n.on      anop\n         l     r15,vcbnext-vcb(,&csr)    current next\n         st    r15,vcbnext-vcb(,&vcb)    set fwd in new\n         st    &csr,vcbprev-vcb(,&vcb)   set bwd in new\n         st    &vcb,vcbnext-vcb(,&csr)   set fwd in current\n         st    &vcb,vcbprev-vcb(,r15)    set bwd in next\n         Mexit\n.off     anop\n         l     r15,vcbnext-vcb(,&vcb)    current next\n         mvc   vcbprev-vcb(4,r15),vcbprev-vcb(&vcb)\n         l     r15,vcbprev-vcb(,&vcb)    current prev\n         mvc   vcbnext-vcb(4,r15),vcbnext-vcb(&vcb)\n* beware of the system cursor\n         if    (c,&vcb,eq,VCBAcsrp),then=(st,r15,VCBAcsrp)\n         Mend\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n*        VCBLOCATE: Find VCB with matching key                        *\n* name=(address,length)                                               *\n* returns if r15=0 then r1 -> VCB                                     *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n         Macro\n         VCBLOCATE &name=,&anchor=\n         lclc  &nd,&nl\n&na      setc  '&name(1)'\n&nl      setc  '&name(2)'\n         gblc  &$$vcbanchor,&gblsetpc\n         VCBsetgp C,&anchor,&$$vcbanchor\n         VCBCall VCBLoc,name=(&na,&nl),anchor=&gblsetpc\n         Mend\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n*           VCBSCAN  : Scan the VCB chain for given key/prefix        *\n* It will execute the 'onmatch' value when match is found, i.e.       *\n* ONMATCH=(BAL,R4,GOTMATCH) and continue scan afterwards.             *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n         Macro\n        zVCBSCAN &vcbr=r1,&varname=,&onmatch=,&testsub=,&anchor=,      c\n               &generic='N'\n         gblc  &VCBsubname,&subtrace,&gblsetpc\n         lclc  &l,&m1,&m2,&m3,&tsub,&s,&va,&vl\n.* varname=(length,address)\n&va      setc  '&varname(1)'\n&vl      setc  '&varname(2)'\n&l       setc  'VSC&SYSNDX'\n&m1      setc  '&onmatch(1)'\n&m2      setc  '&onmatch(2)'\n&m3      setc  '&onmatch(3)'\n&tsub    setc  (UPPER '&testsub')\n.*--\n         if    (VCBAaqh,eq,VCBAcsrp)      no entries               0001\n           sr    r15,r15                                           0001\n           j     &l.X                                              0001\n         endif                                                     0001\n.*--\n*List all\n         $la   r2,&vl                     load length\n         If    (ltr,r2,r2,z)              all?\n           VCBtrcX 'VCBscan all'\n           l     &vcbr,VCBAaqh\n           Do    Until,(c,&vcbr,eq,VCBAaqt) until tail end\n             if    (c,&vcbr,ne,VCBAaqh),then=(&m1,&m2,&m3)\n             aif   ('&testsub' eq '').tsub10n\n             bas   r14,&testsub\n             if    (ltr,r15,r15,nz),then=leave\n.tsub10n     anop\n             l     &vcbr,VCBnext\n           Enddo\n           sr    r15,r15\n           j     &l.X\n         Endif\n.*--\n*List descrete varname = VCBLOC\n         $la    r1,&generic\n         If  (cli,0(r1),ne,c'Y')\n           VCBtrcX 'VCBscan descrete = VCBLOC'\n           $la   r14,&va                  name\n           $la   r15,&vl                  length\n           stm   r14,r15,VCBAclp\n           la    r1,VCBAclp\n           VCBsetgp C,&anchor,&gblsetpc\n           VCBCall VCBLoc,anchor=&gblsetpc\n           lr    &vcbr,r1\n           if    (ltr,r15,r15,z),then=(&m1,&m2,&m3)\n           j     &l.X\n         Endif\n.*--\n*Must be search by generic name\n         $la   r14,&vl                  length\n         st    r14,VCBAfw\n         bctr  r14,0                      as machine\n         $la   r15,&va                  name\n         stm   r14,r15,VCBAclp\n         VCBtrcX begin\n         l     r2,VCBAfw\n         if    (clfi,r2,gt,20),then=(la,r2,20)\n         StrMake  VCBAtrrec,'VCBscan generic ',                        c\n               (VCBAfw,4,cvxd),' ',(&va,(r2)),reg=r3\n         VCBtrcX end\n         sr    r15,r15                  preset rc\n         l     &vcbr,VCBAaqh            queue head\n         l     &vcbr,VCBnext            first real VCB\n         Do    While,(c,&vcbr,ne,VCBAaqt)  until tail\n           l     r2,VCBnamel\n           if    (clfi,r2,gt,20),then=(la,r2,20)\n           VCBtrcX begin\n           StrMake VCBAtrrec,'name: ',(VCBname,(r2)),' ',              c\n               (VCBnamel,4,cvxd),reg=r3\n           VCBtrcX end\n           if    (clc,VCBAclp,le,VCBnamel)\n             VCBtrcX 'length ok'\n             lm    r14,r15,VCBAclp         mch length, address\n             ex    r14,&l.C                check name against VCB\n             if    (gt),then=leave         VCBname is high\n             if    (eq)\n               VCBtrcX 'name ok'\n               &m1 &m2,&m3\n               aif   ('&testsub' eq '').tsub20n\n               if    (ltr,&testsub,&testsub,nz),then=leave\n.tsub20n anop\n             endif\n           else\n             VCBtrcX 'length not ok'\n           endif\n           l     &vcbr,VCBnext\n         Enddo\n         sr    r15,r15\n         j     &l.X\n\n&l.C     clc   VCBvar(*-*),0(r15)\n&l.X     ds    0a\n         MEND\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n*           VCBGET : get named entry                                  *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n         Macro\n         VCBGET &name=,&data=,&anchor=\n         gblc  &$$vcbanchor,&gblsetpc\n         lcla  &l\n         lclc  &na,&nl,&da,&dl\n&na      setc  '&name(1)'\n&nl      setc  '&name(2)'\n         aif   ('&na'(1,1) ne '''').nln\n&l       seta  (k'&na)-2\n&nl      setc  '&l'\n.nln     anop\n&da      setc  '&data(1)'\n&dl      setc  '&data(2)'\n         aif   (k'&dl gt 0).dln\n&dl      setc  'l''&da'\n.dln     anop\n.* getloc syntax: name=(len,adr)\n         $la   r14,&na\n         $la   r15,&nl\n         $la   r0,&da\n         $la   r1,&dl\n         stm   r14,r1,VCBAcpl\n         la    r1,VCBAcpl\n         VCBsetgp C,&anchor,&$$vcbanchor\n         VCBCall VCBget,anchor=&gblsetpc\n         ltr   r15,r15\n         Mend\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n*           VCBGETNEXT  : Locate next matching VCB, optionally        *\n*                         return data.                                *\n* See module VCBNEXT for call, return and parmlist                    *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n         Macro\n         VCBGETNEXT &name=(0,0),&data=(0,0),&anchor=,&generic=,&ptr=\n.* name=(address,length) data=(address,length)\n.* parm field..\n.*    a  name-length\n.*    a  name-address\n.*    a  data-length\n.*    a  data-address\n.*    a  address of Y (generic) or 'N' (descrete)\n.*    a  address of VCB pointer\n         gblc  &$$vcbanchor,&gblsetpc\n         lclc  &l,&m1,&m2,&m3,&tsub,&s,&va,&vl,&lanchr\n         VCBsetgp C,&anchor,&$$vcbanchor\n         $la   r1,&gblsetpc          -> anchor\n         la    r1,VCBAcpl-VCBAnchr(,r1) -> cpl\n         $la   r14,&name(1)          length\n         $la   r15,&name(2)          address\n         stm   r14,r15,0(r1)\n         $la   r14,&data(1)          length\n         $la   r15,&data(2)          address\n         stm   r14,r15,8(r1)\n         $la   r14,&generic\n         $la   r15,&ptr\n         stm   r14,r15,16(r1)\n         $la   r0,&gblsetpc\n         Call  VCBGETNX\n         ltr   r15,r15\n         MEND\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n*           VCBPUT : write named entry                                *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n         Macro\n         VCBPUT &name=,&data=,&anchor=\n         gblc  &$$vcbanchor,&gblsetpc\n         lcla  &l\n         lclc  &na,&nl,&da,&dl\n         aif   (k'&name eq 0 or k'&data eq 0).err1\n&na      setc  '&name(1)'\n&nl      setc  '&name(2)'\n         aif   ('&na'(1,1) ne '''').nln\n&l       seta  (k'&na)-2\n&nl      setc  '&l'\n.nln     anop\n&da      setc  '&data(1)'\n&dl      setc  '&data(2)'\n         aif   (k'&dl gt 0).dln\n&dl      setc  'l''&da'\n.dln     anop\n         $la   r14,&na\n         $la   r15,&nl\n         $la   r0,&da\n         $la   r1,&dl\n         stm   r14,r1,VCBAcpl\n         la    r1,VCBAcpl\n         VCBsetgp C,&anchor,&$$vcbanchor\n         VCBCall VCBput,anchor=&gblsetpc\n         ltr   r15,r15\n         mexit\n.err1    mnote 8,'** name or data parm missing'\n         Mend\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n*              VCBCOMPSTR                                             *\n* compare 2 strings of possible unequal length                        *\n* max length for compare is 256 bytes                                 *\n* 1. compare using shortest length                                    *\n* 2. if equal then compare lengths                                    *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n         Macro\n         VCBCompStr &str1,&str2\n         lclc  &l\n&l       setc  'VC&sysndx'\n         $la   r1,&str1(2)           length of string 1\n         $la   r0,&str2(2)           length of string 2\n         cr    r1,r0                 test length\n         jnh   &l.B                  l'str1 le l'str2\n         lr    r1,r0                 use the shorter\n&l.B     bctr  r1,0\n         $la   r14,&str1(1)          address of string 1\n         $la   r15,&str2(1)          address of string 2\n         ex    r1,&l.C\n         jne   &l.C+6                use compare cond\n         $la   r1,&str1(2)           length of string 1\n         cr    r1,r0                 compare lengths\n         j     &l.C+6\n&l.C     clc   0(*-*,r14),0(r15)\n         Mend\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n*              VCBTRACE : Generate trace record                       *\n* initially a dummy macro, to be re-created by the caller             *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n         MACRO\n         VCBTrace\n.* dummy macro, must be replaced by proper macro in mainline pgm\n         MEND\n\n         MACRO\n         VCBTrcX  &text\n         gblc  &$$vcbtrace\n         lclc  &q\n&q       setc  Upper('&text')\n         aif   ('&q' eq 'BEGIN').begin\n         aif   ('&q' eq 'END').end\n         if    (tm,VCBAflgs1,VCBAtrace,o)\n           aif   (k'&text eq 0).go\n           clear VCBAtrrec\n           mvlit VCBAtrrec,&text\n.go        stm   r0,r15,VCBAtrsa0\n           la    r1,VCBAtrrec\n*call VCBtrace\n           VCBtrace\n           lm    r0,r15,VCBAtrsa0\n         endif\n         mexit\n.begin   if    (tm,VCBAflgs1,VCBAtrace,o)\n           clear VCBAtrrec\n         mexit\n.end       stm   r0,r15,VCBAtrsa0\n           la    r1,vcbatrrec\n*call VCBtrace\n           VCBtrace\n           lm    r0,r15,VCBAtrsa0\n         endif\n         mexit\n         MEND\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n*                              modules                                *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n         Macro\n         VCBMODUL\n         gblc  &$$vcbkeepnum,&$$vcbkeepmaxw,&$$vcbsp\n         lclc  &vcbkeepn,&vcbkeepmw\n&vcbkeepn setc '&$$vcbkeepnum'\n         aif   (k'&$$vcbkeepnum gt 0).keepnn\n&vcbkeepn setc '10'\n.keepnn  anop\n&vcbkeepmw setc '&$$vcbkeepmaxw'\n         aif   (k'&$$vcbkeepmaxw gt 0).keepmwn\n&vcbkeepmw setc '4096'\n.keepmwn anop\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n*              VCBAlc: find free space or get new VCB                 *\n*              entry:r1 = l'data                                      *\n*              exit: r1 -> VCB or 0                                   *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n\nVCBAlc   VCBEntry anchorr=r8\n         lr    r6,r1                    save size of name/data\n         srl   r6,5                     round up to\n         sll   r6,5                      to nearest\n         la    r6,32(,r6)                   multipla of adjust factor\n         if    (c,r6,gt,VCBAmaxdl)      if gt current max data len\n           st     r6,VCBAmaxdl          then update max data len\n         endif\n         la    r6,VCBfixl(r6)           add base\n\n         $cvd  r6,VCBAtrrec+12,len=6\n         VCBtrcX 'VCBAlc sz'\n\n* any suitable entries on the 'free' chain?\n         if    (icm,r2,15,VCBAfqn,nz)  number of free VCBs > 0 ?\n\n* scan 'free' chain to see if we have a big enough free entry\n           using VCB,r4\n           l     r4,VCBAfqh               -> start of 'free' chain\n           Do    While,(c,r4,ne,VCBAfqt)\n             if    (c,r6,le,VCBsize)       if size is ok\n* move free VCB to active\n               l     r15,VCBAfqn           decrease\n               bctr  r15,0                   free VCB\n               st    r15,VCBAfqn               count\n               VCBtrcX begin\n               StrMake VCBAtrrec,'VCBAlc found free ',((r4),4,cvxd),   c\n               reg=r3\n               VCBtrcX end\n               VCBHOOK OFF,vcb=r4\n               l     r15,VCBAaqn           increase\n               la    r15,1(,r15)             active VCB\n               st    r15,VCBAaqn               count\n               lr    r1,r4                 -> VCB\n               VCBExit rc=0\n             endif\n             l     r4,VCBnext             try next\n           Enddo\n           drop  r4\n\n         endif\n\n*create a new VCB\n         VCBtrcX 'VCBAlc new'\n         la    r5,8                 initial rc\n         STORAGE OBTAIN,LENGTH=(R6),SP=&$$vcbsp,CALLRKY=YES,COND=YES,  c\n               loc=31\n         if    (ltr,r15,r15,z)\n           lr    r4,r1\n           st    r1,VCBAfw\n           VCBtrcX begin\n           StrMake VCBAtrrec,'VCBAlc new VCB:',(VCBAfw,4,cvxd),        c\n               reg=r2\n           VCBtrcX end\n           lr    r1,r4\n           using VCB,r1\n           xc    VCBfix(VCBfixl),VCBfix\n           st    r6,VCBsize\n           drop  r1\n           sr    r5,r5\n           l     r15,VCBAaqn           number of active VCBs\n           la    r15,1(,r15)           count up\n           st    r15,VCBAaqn           update\n         endif\n\n         VCBExit rc=(r5),final\nVCBAlcWrk1 ds  4a\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n*              VCBLoc: find existing VCB by name                      *\n* <logic>                                                             *\n* The search is using the cursor set by VCBPUT or first               *\n*                                                                     *\n* at entry r1 -> search value: a(nameaddr,namelen)                    *\n*                                                                     *\n* if search_key lt cursor then search from queue head                 *\n* else search from cursor                                             *\n*                                                                     *\n* if found then                                                       *\n*   r1->VCB                                                           *\n*   return 0                                                          *\n* else                                                                *\n*   r1->VCBprev                                                       *\n*   return 4                                                          *\n*                                                                     *\n*        r12: local base                                              *\n*        r11: main module area                                        *\n*        r10: global storage                                          *\n*        r09: local call                                              *\n*        r08 -> VCBanchor                                             *\n*        r07 -> VCB queue                                             *\n*        r06 -> name to locate                                        *\n*        r05 -> length of name                                        *\n*        r04 -> machine length of name                                *\n*                                                                     *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n\n         Macro\n         LocGetVn\n         gblc  &$$vcbkeepnum,&$$vcbkeepmaxw,&$$vcbsp\n         l     r15,VCBnamel\n         bctr  r15,0\n         clear a=VCBAlocvn\n         mvc   VCBAlocvn(*-*),VCBname\n         ex    r15,*-6\n         Mend\n\n         Using VCB,r7\nVCBLoc   VCBEntry anchorr=r8\n\n         clear a=VCBAlocsn\n         lm    r2,r3,0(r1)              name addr, length\n         bctr  r3,0                     machine length\n         mvc   VCBAlocsn(*-*),0(r2)     copy name to work\n         ex    r3,*-6\n         VCBtrcX begin\n         StrMake VCBAtrrec,'VCBLOC search ',(VCBAlocsn,1(r3))\n         VCBtrcX end\n\n*search before or after cursor\n         l     r7,VCBAcsrp              load cursor\n         LocGetVn\n         VCBtrcX begin\n         StrMake VCBAtrrec,'csr ',(VCBAlocvn,30),' ',(vcbacsrp,4,cvxd)\n         VCBtrcX end\n         if    (clc,VCBAlocsn,lt,VCBAlocvn)\n           l     r7,VCBAaqh             use queue start\n           VCBtrcX 'VCBLOC use qh'\n         else\n           VCBtrcX 'VCBLOC use csr'\n         endif\n* l r7,VCBAaqh\n*        if    (c,r7,eq,VCBAaqh),then=(l,r7,VCBnext)\n\n*search forward from r7\n         Do    inf\n\n           lr    r1,r7\n           VCBcall VCBFmtNd,anchor=(r8)\n           VCBtrcX begin\n           mvlit VCBAtrrec,'VCBLOC'\n           mvc   VCBAtrrec+7(110),0(r1)\n           mvi   VCBAtrrec+61,c':'\n           VCBtrcX end\n\n           LocGetVn\n           clc   VCBAlocsn,VCBAlocvn\n           if    (eq)\n             VCBtrcX 'VCBLOC match'\n             la    r5,0                  set rc\n             leave\n           endif\n           if    (l)\n             VCBtrcX 'VCBLOC overshoot'\n             l     r7,VCBprev\n             la    r5,4                  set rc\n             leave\n           endif\n           l     r7,VCBnext\n           if    (c,r7,eq,VCBAaqt)\n             VCBtrcX 'VCBLOC no match'\n             l     r7,VCBprev\n             la    r5,4                  set rc\n             leave\n           endif\n\n         Enddo\n\n         if    (ltr,r7,r7,z)             shouldn't happen, but still..\n           VCBtrcX 'VCBLOC reset to qh'\n           l     r7,VCBAaqh\n           la    r5,4\n         endif\n\n         st    r7,VCBAfw\n         VCBtrcX begin\n         StrMake VCBAtrrec,'VCBLOC csr ',(VCBAfw,4,cvxd),reg=r3\n         VCBtrcX end\n\n         lr    r1,r7\n         VCBExit rc=(r5),final\n\n         drop  r7\n\n*-------------------------- VCBPUT -----------------------------------*\n*---------------------------------------------------------------------*\n* Copy name and data to VCB                                           *\n* VCB will created if no suitable                                     *\n* Input data are defined by rnvvar/rnvvarl and vardataa/vardatal      *\n* At entry:                                                           *\n*   r1 -> a(namelen,nameadr,datalen,dataadr)                          *\n*                                                                     *\n*---------------------------------------------------------------------*\n*---------------------------------------------------------------------*\nVcbPutParm Dsect\nVcbPutNa   ds    a\nVcbPutNl   ds    a\nVcbPutDa   ds    a\nVcbPutDl   ds    a\n\nVCBPut   VCBEntry Anchorr=r8\n         lr    r9,r1\n         Using VCBPutParm,r9\n\n* update anchor length fields\n         if    (VcbPutNl,gt,VCBAvmaxnl)\n           mvc   VCBAvmaxnl,VcbPutNl\n         endif\n         if    (VcbPutDl,gt,VCBAvmaxdl)\n           mvc   VCBAvmaxdl,VcbPutDl\n         endif\n         l     r14,VcbPutNl    name length\n         a     r14,VcbPutDl    plus data length\n         if    (c,r14,gt,VCBAvmaxndl)\n           st    r14,VCBAvmaxndl\n         endif\n\n*log REXX data\n         lm    r2,r5,VCBputparm\n         VCBtrcX begin\n         StrMake VCBAtrrec,'vputdata ',reg=r7,                         c\n               (VCBputnl+2,2,cvd,4),':',(VCBputdl+2,2,cvd,6),          c\n               ' ',((r2),(r3),,20),':',((r4),(r5),,35)\n         VCBtrcX end\n\n*  VCBLOC entry  r1 -> a(length),a(->name)\nVCBputp  equ   VCBAwrk+16\n         mvc   VCBputp(4),VCBputna\n         mvc   VCBputp+4(4),VCBputnl\n         la    r1,VCBputp\n         VCBCall VCBLoc,anchor=(r8)\n         lr    r6,r15                   save locate result\n         lr    r7,r1                    save locate cursor\n         st    r6,VCBAfw\n         VCBtrcX begin\n         StrMake VCBAtrrec,'VCBLoc result ',(VCBAfw,4,cvxd),reg=r2\n         VCBtrcX end\n\n         if    (ltr,r6,r6,z)              found\n*-check size\n           using VCB,r7\n           VCBtrcX 'VCBPut var on chain'\n           l     r2,VCBPutDl\n           if    (c,r2,le,VCBdatal)       big enough??\n             la    r2,VCBvar              target addr\n             a     r2,VCBnamel            -> data section\n             l     r14,VCBPutDa           source addr\n             if    (icm,r15,15,VCBPutDl,nz) source length\n               lr    r3,r15                 target length\n               mvcl  r2,r14                 get data\n             endif\n             mvc   VCBdatal,VCBPutDl      copy length\n             st    r7,VCBAcsrp            update cursor\n             VCBExit rc=0\n           endif\n           VCBtrcX begin\n           mvlit  VCBAtrrec,'VCBPUT insuf sz VCBPutDl ........ VCBdatal+\n               '\n           $cvd  r2,VCBAtrrec+26,len=8\n           l     r3,VCBdatal\n           $cvd  r3,VCBAtrrec+44,len=8\n           VCBtrcX end\n           drop  r7\n         endif\n\n         if    (ltr,r6,r6,z)              found but not sufficient\n           lr   r1,r7                     -> VCB\n           l    r7,VCBprev-vcb(,r7)\n           st   r7,VCBAcsrp               updte system cursor\n           VCBCall VCBDel,anchor=(r8)     delete\n         endif\n         la    r5,8                     preset rc\n\n         l     r2,VCBPutNl              name length\n         l     r3,VCBPutDl              data length\n         lr    r1,r2                    length of name\n         ar    r1,r3                    add data length\n         lr    r4,r1\n         st    r1,VCBAfw\n         VCBtrcX begin\n         StrMake VCBAtrrec,'VCBPut alloc sz ',(VCBAfw,4,cvxd)\n         VCBtrcX end\n         lr    r1,r4\n\n         VCBCall VCBAlc,anchor=(r8)     Go get a VCB\n\n         lr    r3,r15\n         lr    r4,r1\n         st    r15,VCBAfw\n         VCBtrcX begin\n         StrMake VCBAtrrec,'VCBPut alloc rc ',(VCBAfw,4,cvxd)\n         VCBtrcX end\n         lr    r1,r4\n         lr    r15,r3\n\n         ltr   r15,r15\n         if    (z)                      got on\n           lr    r3,r1\n           VCBtrcX 'VCBPut VCBalc ok'\n           lr    r1,r3\n           st    r1,VCBAcsrp            update cursor\n           VCBHOOK ON,vcb=r1,csr=r7     on to chain\n           lr    r7,r1                  -> new VCB\n           st    7,VCBAfw\n           VCBtrcX begin\n           StrMake VCBAtrrec,'VCBPut update ',(VCBAfw,4,cvxd),reg=r2\n           VCBtrcX end\n           using VCB,r7\n           l     r2,VCBPutNl\n           st    r2,VCBnamel\n           l     r3,VCBPutDl\n           st    r3,VCBdatal\n           la    r14,VCBvar               -> name\n           ar    r14,r2                   -> data\n           st    r14,VCBdataa             save address\n           bctr  r2,0                     mch length\n           l     r14,VCBPutNa\n           mvc   VCBvar(*-*),0(r14)       get name\n           ex    r2,*-6                   get data\n           if    (ltr,r3,r3,nz)           data present??\n             la    r2,VCBvar+1(r2)        -> data section\n             l     r14,VCBPutDa           source\n             lr    r15,r3                 length\n             mvcl  r2,r14                 get data\n           endif\n           drop  r7\n           lr    r1,r7                    copy VCB address\n           sr    r5,r5\n         endif\n\n         VCBExit rc=(r5)\n*VCBPutP  ds    4a\n         ltorg\n         drop  r8,r9\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n*              VCBDel: delete VCB                                     *\n*   move VCB from active to free queue, or free storage               *\n*                                                                     *\n* at entry                                                            *\n*  r0 -> VCB anchor                                                   *\n*  r1 -> VCB to logically remove                                      *\n*                                                                     *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n\n         Using VCB,r6\nVCBDel   VCBEntry anchorr=r8\n\n*-from current (active) queue\n         lr    r6,r1\n         VCBHOOK OFF,vcb=r6\n         VCBtrcX 'VCBDEL unhooked from active'\n         l     r15,VCBAaqn              decrease\n         bctr  r15,0                      number of\n         st    r15,VCBAaqn                 active VCBs\n\n         l     r15,VCBAfqn              number of free VCBs\n         l     r4,VCBsize\n* keep only a limited number, and only smaller blocks\n         if    (clfi,r15,lt,&vcbkeepn),and,(clfi,r4,le,&vcbkeepmw)\n           l     r5,VCBAFqh             'free' queue head\n           VCBHOOK ON,vcb=r6,csr=r5\n           VCBtrcX 'VCBDEL hooked on free'\n           l     r15,VCBAfqn            increase\n           la    r15,1(,r15)              number of\n           st    r15,VCBAfqn               free VCBs\n         else\n           if    (ltr,r4,r4,nz)\n             STORAGE RELEASE,LENGTH=(4),ADDR=(6),                      c\n               SP=&$$vcbsp,CALLRKY=YES\n             VCBtrcX 'VCBDEL freemained'\n           endif\n         endif\n\n         VCBExit final,rc=0\n         drop  r6\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n* VCBDelAc : delete all active VCBs, leaving free VCBs                *\n* at entry                                                            *\n*  r0 -> VCB anchor                                                   *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\nVCBDelAc VCBEntry anchorr=r8\n*\n         if    (VCBAaqn,eq,=a(0))\n           VCBtrcX 'vcbdelalc empty aq'\n           VCBExit rc=0\n         endif\n*\n         VCBtrcX 'vcbdel active q'\n*\n         using VCB,r6\n         l     r6,VCBAaqh                 -> header\n         l     r6,VCBnext                 -> 1st real\n         do    forever\n           l     r5,VCBnext               -> next\n           lr    r1,r6\n           VCBCall VCBDel,anchor=(r8)    Go delete VCB\n           if    (c,r5,eq,VCBAaqt),then=leave  dont drop trail\n           lr    r6,r5\n         enddo\n         drop  r6\n*\n         VCBExit final,rc=0\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n* VCBDelAl : delete all VCBs from one anchor                          *\n* Essentially VCBDROP without dropping the anchor too.                *\n* at entry                                                            *\n*  r0 -> VCB anchor                                                   *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\nVCBDelAl VCBEntry anchorr=r8\n*\n         if    (VCBAaqn,ne,=a(0))\n           VCBtrcX 'vcbdelall active q'\n           la    r1,VCBAaqh\n           VCBCall VCBDropQ,anchor=(r8)    Go drop queue\n           VCBAinit active\n         else\n           VCBtrcX 'vcbdelall empty aq'\n         endif\n*\n         if    (VCBAfqn,ne,=a(0))\n           VCBtrcX 'vcbdelall free q'\n           la    r1,VCBAfqh\n           VCBCall VCBDropQ,anchor=(r8)    Go drop queue\n           VCBAInit free\n         else\n           VCBtrcX 'vcbdelall empty fq'\n         endif\n*\n         VCBExit final,rc=0\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n*              VCBDrop : delete entire storage structure              *\n* at entry                                                            *\n*  r0 -> VCB anchor                                                   *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\nVCBDrop  VCBEntry anchorr=r8\n         clc   VCBAeye,=cl8'VCBANCHR'\n         je    VCBDrop1\n         abend 1\nVCBdrop1 ds    0h\n\n*---------------------------------------------------------------------*\n*        release queues                                               *\n*---------------------------------------------------------------------*\n\n         VCBtrcX 'vcbdrop active q'\n         la    r1,VCBAaqh\n         VCBCall VCBDropQ,anchor=(r8)    Go drop queue\n\n         VCBtrcX 'vcbdrop free q'\n         la    r1,VCBAfqh\n         VCBCall VCBDropQ,anchor=(r8)    Go drop queue\n\n         VCBtrcX 'release anchor'\n         la    r2,VCBAnchrl\n         STORAGE RELEASE,ADDR=(8),LENGTH=(2),                          c\n               SP=&$$vcbsp,CALLRKY=YES\n\n*        VCBExit final,trace=n\n* VCBEXIT TRACE=Y (default) test/updates fields in the anchor block,\n* which normally leads to an abend S0C4\n         sr    r15,r15\n         pr    ,\n         ltorg\n         drop  r8,r12\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n*              VCBDropQ: delete queue (active or free)                *\n* at entry                                                            *\n*  r0 -> VCB anchor                                                   *\n*  r1 -> VCB queue pointer                                            *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n         Using VCB,r6\nVCBDropQ VCBEntry anchorr=r8\n         lr    r7,r1                      save queue pointer\n* r7 -> a(queue-head,queue-trail)\n         l     r6,0(,r7)                  -> 1st VCB\n         do    until,(ltr,r5,r5,z)\n           l     r5,VCBnext               -> next\n           if    (c,r5,eq,4(r7)),then=leave  dont drop trail\n           st    r6,VCBAfw\n           VCBtrcX begin\n           StrMake VCBAtrrec,'vcba ',(VCBAfw,4,cvxd),                  c\n               ' sz ',(VCBsize,4,cvxd)\n           VCBtrcX end\n           if    (icm,r4,15,VCBsize,nz)\n             STORAGE RELEASE,LENGTH=(4),ADDR=(6),                      c\n               SP=&$$vcbsp,CALLRKY=YES\n           endif\n           lr    r6,r5\n         enddo\n         VCBExit final\n         drop  r6\n\n*---------------------------------------------------------------------*\n*---------------------------------------------------------------------*\n* Locate named VCB, return data if requeted                           *\n*                                                                     *\n* At entry:                                                           *\n*   r1 -> a(nameaddr)                                                 *\n*         a(namelen)                                                  *\n*         a(dataaddr)  optional                                       *\n*         a(datalen)   optional                                       *\n*                                                                     *\n* At exit:                                                            *\n*   r1 -> VCB if r15 = 0 or 2                                         *\n*   r15 00  VCB located, data returned if requested                   *\n*   r15 01  VCB not found                                             *\n*   r15 02  VCB found, data buffer too small, data truncated          *\n*                                                                     *\n*---------------------------------------------------------------------*\n*---------------------------------------------------------------------*\n         using VCB,r7\nVCBGet   VCBEntry anchorr=r8\n         lr    r9,r1\n         sr    r6,r6\n* getloc syntax: name=(addr,len)\n         lm    r2,r5,0(r1)\n         VCBLocate name=((r2),(r3)),anchor=(r8)\n         if    (nz)                    not found\n           VCBExit rc=1\n         endif\n* get data, r1 -> VCB\n         lr    r7,r1             save VCB addr\n         if    (icm,r15,15,VCBdatal,z)  if data eq NULL\n           VCBExit rc=0          fine then\n         endif\n         if    (cr,r15,gt,r5)    check data buffer size\n           lr    r15,r5          use max\n           la    r6,2            set 'truncation'\n         endif\n         lr    r5,r15            copy data length\n         la    r2,VCBname        address of name\n         a     r2,VCBnamel       add length of name, -> data src\n         if    (clfi,r15,le,255)  small data?\n           bctr  r15,0             mch len of data\n           mvc   0(*-*,r4),0(r2)   get data\n           ex    r15,*-6\n         else    ,               data length gt 255\n           lr    r14,r4          -> target\n           lr    r3,r15          copy length\n           mvcl  r14,r2          copy data\n         endif\n         lr    r0,r5             copy data length\n         lr    r1,r7             copy VCB address\n         VCBExit final,rc=(r6)\n         drop  r7\n\n*---------------------------------------------------------------------*\n*---------------------------------------------------------------------*\n* Locate next VCB with matching name (generic or descrete).           *\n* Return data in buffer if requested.                                 *\n*                                                                     *\n* At entry:                                                           *\n*   r1 -> see dsect below                                             *\n*                                                                     *\n* At exit:                                                            *\n*   r1 -> VCB or zero                                                 *\n*   r15 00  VCB located, data returned if requested                   *\n*   r15 01  VCB not found                                             *\n*   r15 02  VCB found, data buffer too small                          *\n*                                                                     *\n*---------------------------------------------------------------------*\n*---------------------------------------------------------------------*\nVcbGnWrk    Dsect\n*parameter mapping\nVcbGnWna    ds    a     name address\nVcbGnWnl    ds    a     name length\nVcbGnWda    ds    a     data address\nVcbGnWdl    ds    a     data length\nVcbGnWgen   ds    a     -> 'Y' or 'N'\nVcbGnWptr   ds    a     -> latest VCB\n\n         using  VCB,r7\n         using  VCBGnWrk,r10\nVCBGetNx VCBEntry anchorr=r8\n         lr    r10,r1\n\n         VCBtrcX begin\n         if    (vcbgnwnl,ne,=a(0))      no name = all entries\n           l     r4,vcbgnwna\n           l     r5,vcbgnwnl\n           if    (clfi,r5,gt,40),then=(la,r5,40)\n           l     r2,VcbGnwgen\n           StrMake  VCBAtrrec,'generic ',((r2),1),                     c\n               ' name ',((4),(5))\n         else\n           StrMake  VCBAtrrec,'all entries'\n         endif\n         VCBtrcX end\n\n*First time around?\n         l     r7,VcbGnWptr               -> VCB ptr\n         if    (icm,r7,15,0(r7),z)        1st time around?\n           VCBtrcX '1st time around'\n           if    (=a(0),eq,VCBAaqn)       empty list?\n             la    r0,1                   reason\n             VCBexit rc=1\n           endif\n           l     r7,VCBAaqh               use header\n         endif\n\n*Next sequential?               a\n         if    (vcbgnwnl,eq,=a(0))        all entries ?\n           VCBtrcX 'next sequential'\n           l     r7,VCBnext               next\n           if    (c,r7,eq,VCBAaqt)        past last?\n             la    r0,1                   reason\n             VCBexit rc=1\n           endif\n\n*Locate next entry if not all\n* r9 -> generic Y or N\n* r8 -> VCB anchor\n* r7 -> current VCB\n* r6 :  real name length\n* r5 :  machine name length\n* r4 -> name\n         else                             no name = all entries\n           VCBtrcX 'next by key'\n           l     r4,VcbGnWna              name\n           l     r6,VcbGnWnl              name length\n           lr    r5,r6\n           bctr  r5,0                     machine length\n           l     r9,VcbGnwgen             -> N/Y generic option\n           if    (cli,0(r9),ne,c'Y'),then=(sr,r9,r9)  zero = N\n\n*Locate VCB with matching name\n           Do    forever\n             vcbtrcx 'next'\n             l     r7,VCBnext               next\n             if    (c,r7,eq,VCBAaqt)        past last?\n               la    r0,1                   reason\n               VCBexit rc=1\n             endif\n             VCBtrcX begin\n             l     r3,VCBnamel              name length\n             if    (clfi,r3,gt,40),then=(la,r3,40)\n             StrMake VCBAtrrec,'VCBname ',(VCBName,(r3))\n             VCBtrcX end\n\n* check for within range (by key value)\n             lr    r2,r6                    name length\n             if    (c,r2,gt,VCBnamel),then=(l,r2,VCBnamel) use small\n             bctr  r2,0                     machine length\n             ex    r2,VcbGnExCn             check name against VCBname\n             if    (gt)                     lt => not there yet\n               VCBtrcX 'key high'\n               iterate\n             endif\n             if    (lt)                     gt => overshoot\n               VCBtrcX 'key low'\n               la    r0,1                   reason\n               VCBexit rc=1\n             endif\n\n* check value if generic\n             if  (ltr,r9,r9,nz)           generic ?\n               VCBtrcX 'check generic'\n               if    (c,r6,le,VCBnamel)   length le?\n                 if    (ex,r5,VcbGnExCn,eq),then=leave name match?\n               endif\n* check value if descrete\n             else                         not generic\n               VCBtrcX 'check descrete'\n               if    (c,r6,eq,VCBnamel)   length must be eq\n                 if    (ex,r5,VcbGnExCn,eq),then=leave name match?\n               endif\n             endif\n\n           Enddo\n\n         Endif\n\n         l     r2,VcbGnWptr               -> ptr\n         st    r7,0(,r2)                  save ptr\n         lr    r1,r7                      copy ptr\n\n*Return data if requested\n         if    (icm,r3,15,VcbGnWdl,z)     no data requested\n           la    r0,4\n           VCBExit rc=0\n         endif\n         if    (c,r3,lt,VCBdatal)         no fit\n           VCBExit rc=2\n         endif\n         l     r2,VCBGnWda                -> target buffer\n         l     r5,VCBDatal                source data length\n         st    r5,VCBGnWdl                save as target length\n         la    r4,VCBname                 -> source name\n         a     r4,VCBnamel                -> source data\n         if    (clfi,r5,le,256)           short buffer\n           bctr  r5,0                     mch length\n           mvc   0(*-*,r2),0(r4)\n           ex    r5,*-6\n         else\n           lr    r3,r5\n           mvcl  r2,r4\n         endif\n         l     r1,VcbGnWptr               -> ptr\n         l     r1,0(,r1)                  -> VCB\n         VCBExit rc=0\n\nVcbGnZero dc    a(0)\nVcbGnExCn clc   0(*-*,r4),VCBname\n         ltorg\n         drop  r7,r8,r10\n\n ago .vcbzcsrn\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n*              VCBZCsr: set the cursor                                *\n*   r1->VCB                                                           *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\nVCBZCSR  VCBEntry anchorr=r8\n         Using VCB,r1\n         st    r1,VCBAcsrp              pointer\n         l     r2,VCBnamel              name length\n         bctr  r2,0\n         clear VCBAcsrv\n         mvc   VCBAcsrv(*-*),VCBname\n         ex    r2,*-6\n         drop  r1\n         VCBExit final\n.vcbzcsrn anop\n\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n*        VCBFmtNd : format name/data part of VCB                      *\n*        at entry  r0 -> VCB anchor                                   *\n*                  r1 -> VCB                                          *\n*        at exit   r1 -> formatted record                             *\n*        registers:                                                   *\n*          r9 :  base                                                 *\n*          r7 -> VCB                                                  *\n*          r8 -> VCBAnchor                                            *\n*          r5 -> pos in formatted record                              *\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n         Using VCB,r7\nVCBFmtNd VCBEntry anchorr=r8\n         lr    r7,r1\n         clear VCBAfmtndr\n         la    r5,VCBAfmtndr\n\n         st    r7,VCBAfw\n         strc2x from=(VCBAfw,4),to=(r5)\n         if    (c,r7,eq,VCBAaqh)\n            mvi   8(r5),c'<'\n         endif\n         if    (c,r7,eq,VCBAaqt)\n            mvi   8(r5),c'>'\n         endif\n         la    r5,9(,r5)\n\n         l     r2,VCBnamel         <<--\n         cvd   r2,VCBAdw\n         unpk  0(4,r5),VCBAdw+6(2)\n         oi    3(r5),x'f0'\n         la    r5,5(,r5)\n\n         l     r3,VCBdatal\n         cvd   r3,VCBAdw\n         unpk  0(4,r5),VCBAdw+6(2)\n         oi    3(r5),x'f0'\n         la    r5,5(,r5)\n\n         la    r4,VCBvar\n         if    (clfi,r2,gt,35)             vname length\n           mvc   0(34,r5),0(r4)\n           mvi   34(r5),c'+'\n         else\n           bctr  r2,0\n           mvc   0(*-*,r5),0(r4)           vname lt 35\n           ex    r2,*-6\n         endif\n         la    r5,36(,r5)\n\n         a     r4,VCBnamel                -> data\n         if    (ltr,r3,r3,nz)\n           if    (clfi,r3,gt,75)          vname length\n             mvc   0(74,r5),0(r4)\n             mvi   74(r5),c'+'\n           else\n             bctr  r3,0\n             mvc   0(*-*,r5),0(r4)           vname lt 35\n             ex    r3,*-6\n           endif\n         endif\n\n         la    r1,VCBAfmtndr\n         VCBExit final\n\n         drop  r7\n\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "WSAMMACS": {"ttr": 11009, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01:\\x00\\x00\\x01\\x16\\x01_\\x01\\x19\"\\x1f\\x16\\x19\\x03\\xb9\\x03?\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.58", "flags": 0, "createdate": "2016-01-15T00:00:00", "modifydate": "2019-08-09T16:19:00", "lines": 953, "newlines": 831, "modlines": 0, "user": "DVL"}, "text": ".*-\n.* Willow Structured Assembler Macros (WSAM)\n.*-\n.* This is assembler copybook, use as follows:\n.*         Print off\n.*         Copy VsamMacs\n.*         Print on\n.*-\n.*\n.* The WSAM macro set allows an  assembler programmer to do away with\n.* most labels, and make more  readable code. You can use multi-level\n.* IF and DO constructs with boolean logic.\n.*\n.* WSAM is  (very) similar,  but not  identical, to  IBM's Structured\n.* Programming  Macros. WSAM  was started  a long  time ago  and some\n.* parts do look their age - but as they still work...\n.*\n.* Recent  enhancements are  using newer  instructions like  the long\n.* immediate. If  that is a problem  then contact me for  a solution.\n.*\n.* The macro  set is  supplied as  a copy  book, thus  allowing macro\n.* names longer than 8 bytes.\n.*\n.* General syntax, check the macros for detailed syntax.\n.*\n.*     DO expr\n.*      ITERATE\n.*      LEAVE\n.*     ENDDO\n.*\n.*     IF expr\n.*     ELSEIF expr\n.*     ELSEIF expr\n.*     ELSE\n.*     ENDIF\n.*\n.*     IIF  expr,(if-true),(if-false)\n.*\n.*     SKIP\n.*     .. data block ..\n.*     ENDSKIP\n.*\n.*     LITERALS        junp around LTORG\n.*\n.* WSAM does  not have  a SELECT structure,  but the  IF/ELSEIF works\n.* just as well, though not quite as pretty,\n.*\n.* Check the DO and IF macro for details.\n.*\n.* Sample\n.*\n.*    if    (ltr,r15,r15,z),or,(clc,rc,eq,zero)\n.*      .. code ..\n.*    elseif (clc,rc,eq,=a(4))\n.*      .. code ..\n.*    else\n.*      .. code ..\n.*    endif\n.*\n.* If the  action is a single  instruction then the THEN  operand can\n.* be used to  shorten the written program - the  generated code will\n.* be the same.\n.*\n.*    if    (cfi,r1,gt,4196),then=(la,r2,48)\n.*\n.* WSAM macros are packaged in copy member WSAMMACS (thisaone).\n.*\n.*\n.* Changelog\n.* 2017-09-13  latest major rewrite\n.* 2018-10-27  add value to 'over' -> OVER=(r,v)\n.* 2019-01-30  allow full EX instruction - ex,rx,instr,addr1,addr2,cn\n.*             allow numeric cc testing i.e. IF (2)\n.*             some internal cleanup\n.* 2019-06-21  change how to differentiate between i.e. (lt,r1,zero,z)\n.*             and (c,r1,eq,zero).\n.*\n.* Contact\n.*  email  willy(at)harders-jensen.com\n.*  Check also my website for newer versions and other stuff\n.*   http://harders-jensen.com/wjtech/index.html\n.*-\n         MACRO\n         BREAK\n         mnote 12,'*** BREAK is discontinued, use LEAVE insstead'\n         MEND\n\n         MACRO\n.*----------< WILLOW STRUCTURED ASSEMBLER MACROS        >-------------*\n.*   'LEAVE' - leave a DO or IF group.                                *\n.* Syntax                                                             *\n.*   LEAVE             leave current group                            *\n.*   LEAVE label       leave labelled group (label on DO stmt)        *\n.*   LEAVE ALL         leave outermost group                          *\n.*--------------------------------------------------------------------*\n&MLBL    LEAVE &PREFIX=ZBR,&SUFFIX=\n         GBLA  &WAMBRLV            'LEAVE' LABEL\n         GBLC  &WAMBRLB(16)        'LEAVE' LABEL\n         GBLA  &WAMIFLV\n         GBLC  &WAMIFLB(16)\n         LCLC  &L,&C\n&C       SETC  Upper('&SYSLIST(1)')\n         AIF   ('&C' EQ 'SET').SET\n         AIF   ('&C' EQ 'RESET').RSET\n         AIF   ('&C' EQ 'LABEL').LBL\n         AIF   ('&C' EQ 'ALL').BRA\n         AIF   ('&C' EQ 'OUTER').BRA\n         AIF   (K'&SYSLIST(1) EQ 0).BRO0100\n.*-\n.*    BREAK TO SPECIFIC LABEL\n.*-\n         B     &SYSLIST(1)._END\n         MEXIT\n.*-\n.*    BREAK OUT FROM CURRENT LEVEL\n.*-\n.BRO0100 ANOP\n         AIF   (K'&WAMBRLB(&WAMBRLV) GT 0).BRO0200\n         MNOTE 12,'*** ERROR: NO LEAVE LABEL GEN''D (LV=&WAMBRLV)'\n         MNOTE 12,'*** LEAVE IS MOST LIKELY ATTEMPTED OUTSIDE A DO GRP'\n         MEXIT\n.BRO0200 ANOP\n&L       SETC  '&WAMBRLB(&WAMBRLV)'\n         B     &L\n.BRO0900 ANOP\n         MEXIT\n.*-\n.*   BREAK OUT TO FIRST LEVEL\n.*-\n.BRA     ANOP\n         B     &WAMBRLB(1)\n         MEXIT\n.*-\n.*   SETUP BREAK-OUT LABEL\n.*-\n.SET     ANOP\n&WAMBRLV SETA &WAMBRLV+1\n&WAMBRLB(&WAMBRLV) SETC '&PREFIX.&SYSNDX.&SUFFIX'\n         AIF   (N'&SYSLIST LE 1).SET020\n&WAMBRLB(&WAMBRLV) SETC '&SYSLIST(2)'\n.SET020  ANOP\n         MEXIT\n.*\n.*-\n.*   GENERATE LABEL\n.*-\n.LBL     ANOP\n         AIF   ('&WAMBRLB(&WAMBRLV)' NE '').LBL0100\n         MNOTE *,'*** WARNING - LEAVE LABEL MISSING LEVEL &WAMBRLV'\n         MEXIT\n.LBL0100 ANOP\n&L       SETC  '&WAMBRLB(&WAMBRLV)'\n&L       EQU   *\n&WAMBRLV SETA  &WAMBRLV-1\n         MEXIT\n.LBLE100 ANOP\n         MEXIT\n.*-\n.*   RESET BREAK-OUT LABEL\n.*-\n.RSET    ANOP\n&WAMBRLB(&WAMBRLV) SETC ' '\n         MEXIT\n.*-\n.*   END OF MACRO\n.*-\n.MEXIT   MEND\n\n         MACRO\n.*----------< WILLOW STRUCTURED ASSEMBLER MACROS        >-------------*\n.*   'DO   ' FUNCTION.                                                *\n.*   Syntax                                                           *\n.*   DO ,           no test, do once                                  *\n.*   DO INF         INFINITE EXECUTION ( SUPPORT JSX MACS )           *\n.*   DO FOREVER     INFINITE EXECUTION ( SUPPORT JSX MACS )           *\n.*   DO OVER(r)     DOWN FROM VALUE IN R - stops when r = 1           *\n.*   DO OVER(r,v)   DOWN FROM VALUE V IN R - stops when r = 1         *\n.*   DO OVER=R      DOWN FROM VALUE IN R - stops when r = 1           *\n.*   DO FROM=(r,v)  load v to reg r, then count down to zero          *\n.*   DO FROM=(r,v),TO=v,BY=v  by-v may be negative for countdown      *\n.*   DO WHILE,COND1,AND/OR,COND2,..,AND/OR,COND15                     *\n.*   DO UNTIL,COND1,AND/OR,COND2,..,AND/OR,COND15                     *\n.*--------------------------------------------------------------------*\n&MLBL    DO    &FROM=,&TO=,&DOWNTO=,&BY=1,&OVER=\n         LCLC  &C,&L,&FROMREG,&TOREG,&BYREG,&OP,&CND,&CFROM\n         LCLC  &r1,&r2,&r3,&v1,&v2,&v3\n         LCLA  &N,&M\n         GBLA  &WAMDOLV\n         GBLC  &WAMDOLA(16)  action\n         GBLC  &WAMDOLB(16)  branch\n.*-\n.*   DEFINE LABELS\n.*-\n         AIF   (K'&MLBL EQ 0).TOPLB20\n&L       SETC  '&MLBL'\n         AGO   .TOPLB99\n.TOPLB20 ANOP\n&L       SETC  'DO&SYSNDX'\n.TOPLB99 ANOP\n.DEFTOPL ANOP\n&WAMDOLV SETA  &WAMDOLV+1\n&WAMDOLA(&WAMDOLV) SETC  ''\n&WAMDOLB(&WAMDOLV) SETC  '&L._BGN'\n         LEAVE SET,&L._END\n.*-\n.*   CONTROL FUNCTION\n.*-\n&c       setc  Upper('&syslist(1)')\n         AIF   ('&C&FROM&TO&OVER' eq '').once\n.*       aif   (k'&from ne 0 and k'&to ne 0).FTB\n         aif   (k'&from ne 0).FTB\n         AIF   ('&c' EQ 'INF').INFIN\n         AIF   ('&c' EQ 'FOREVER').INFIN\n         AIF   ('&c' EQ 'WHILE').WHILE\n         AIF   ('&c' EQ 'UNTIL').UNTIL\n         AIF   ('&OVER' NE '').OVER1\n&c       setc  Upper('&syslist(1).')\n         AIF   ('&c     '(1,5) EQ 'OVER(').OVER2\n         AIF   (N'&SYSLIST EQ 0).INFIN\n         mnote 8,'*** error : invalid specification for do macro: &c'\n         MEXIT\n.*-\n.*   DO ONCE\n.*-\n.ONCE    ANOP\n&L._BGN  CNOP  0,4\n&WAMDOLA(&WAMDOLV) SETC 'ONCE'\n         MEXIT\n.*-\n.*   DO UNTIL JUDGEMENT DAY\n.*-\n.INFIN   ANOP\n&L._BGN  CNOP  0,4           do until judgement day\n.*  ALL DONE BY ENDDO FUNCTION\n         MEXIT\n.*-\n.*   DO 'WHILE' MEANS CONDITION TEST BEFORE PROCESS\n.*-\n.WHILE   ANOP\n&L._BGN  CNOP  0,4\n         IF                &SYSLIST(2),&SYSLIST(3),&SYSLIST(4),        +\n               &SYSLIST(5),&SYSLIST(6),&SYSLIST(7),&SYSLIST(8),        +\n               &SYSLIST(9),&SYSLIST(10),&SYSLIST(11),&SYSLIST(12),     +\n               &SYSLIST(13),&SYSLIST(14),&SYSLIST(15),&SYSLIST(16)\n         B     &L._OK\n         ENDIF\n         B     &L._END\n&L._OK   EQU   *\n         MEXIT\n.*-\n.*   DO 'UNTIL' MEANS CONDITION TEST AFTER PROCESS\n.*-\n.UNTIL   ANOP\n         B     &L._OK\n&L._BGN  EQU   *\n         IF                &SYSLIST(2),&SYSLIST(3),&SYSLIST(4),        +\n               &SYSLIST(5),&SYSLIST(6),&SYSLIST(7),&SYSLIST(8),        +\n               &SYSLIST(9),&SYSLIST(10),&SYSLIST(11),&SYSLIST(12),     +\n               &SYSLIST(13),&SYSLIST(14),&SYSLIST(15),&SYSLIST(16)\n         B     &L._END\n         ENDIF\n&L._OK   EQU   *\n         MEXIT\n.*\n.*-\n.*      1) DO OVER=(rn,value)                                2018-10-27\n.*      2) DO OVER(rn)\n.*-\n.OVRF    ANOP                          this is really FROM=(reg)\n mnote *,'Over from'\n&FROMREG SETC  '&FROM'(2,k'&from-2)\n         AGO   .over10\n.OVER1   ANOP\n&FROMREG SETC  '&OVER(1)'                                    2018-10-27\n         aif   (n'&over lt 2).over10                         2018-10-27\n&v1      setc  '&over(2)'                                    2018-10-27\n.*?      $la   &fromreg,&v1                                  2018-10-27\n         WSAMLA &fromreg,&v1                                 2019-01-30\n         AGO   .over10                                       2018-10-27\n.OVER2   ANOP\n&N       SETA  (K'&SYSLIST(1))-6\n&FROMREG SETC  '&SYSLIST(1)'(6,&N)\n         AGO   .over10\n.OVER10  ltr   &fromreg,&fromreg       prevent loop for reg le 0\n         bnp   &l._end\n         AGO   .BCT0500\n.*--------------------------------------------------------------------*\n.*   DO DOWN FROM VALUE IN REGISTER                                   *\n.*--------------------------------------------------------------------*\n.BCT     ANOP\n&FROMREG SETC  '&FROM(1)'\n         AIF   (N'&FROM EQ 1).BCT0500\n         LA    &FROMREG,&FROM(2)\n.BCT0500 ANOP\n         B     &L._OK\n&L._BGN  BCT   &FROMREG,&L._OK\n         B     &L._END                 END OF COUNT\n&L._OK   EQU   *\n         MEXIT\n.*--------------------------------------------------------------------*\n.*   DO 'FROM' 'TO' 'BY'                                              *\n.*                                                                    *\n.*   Syntax: FROM=(r1,v1),TO=v2,BY=v3                                 *\n.*         v1, v2 and v3 can all be actual values, i.e. 2000, or      *\n.*         registers in paranthesis, i.e. (r1).                       *\n.*         Values may be negative.                                    *\n.*--------------------------------------------------------------------*\n.FTB     ANOP\n&cnd     setc  'h'\n&op      setc  'a'\n&r1      setc  '&from(1)'\n&v1      setc  '&from(2)'\n&v2      setc  '0'                      to\n&v3      setc  '1'                      by\n.* count down from value\n         aif   (k'&to ne 0 and k'&by ne 0).ftb2\n&cnd     setc  'l'\n&op      setc  's'\n.* setup rest\n.ftb2    anop\n         aif   (k'&to eq 0).ftbzton\n         aif   (n'&to eq 2).ftbzto2\n&v2      setc  '&to'\n         ago   .ftbzton\n.ftbzto2 anop\n&r2      setc  '&to(1)'\n&v2      setc  '&to(2)'\n         WSAMLA &r2,&v2\n&v2      setc  '(&to(1).)'\n.ftbzton anop\n         aif   (k'&by eq 0).ftbzbyn\n&v3      setc  '&by'\n.ftbzbyn anop\n         aif   ('&v3 '(1,1) ne '-').ftbv3m\n&cnd     setc  'l'\n&op      setc  's'\n&v3      setc  '&v3'(2,k'&v3-1)\n.ftbv3m  anop\n         WSAMLA &r1,&v1                from\n         j     &l._tst\n&l._bgn  equ   *\n.* setup add/subtract value\n         aif   ('&v3'(1,1) eq '(').ftbbyr     by\n         &op.lfi &r1,&v3\n         ago   .ftbbyn\n.ftbbyr  anop\n&v3      setc  '&v3'(2,k'&v3-2)\n         &op.r &r1,&v3\n.ftbbyn  anop\n.* test value\n&l._tst  equ   *\n         aif   ('&v2'(1,1) eq '(').ftbtor     by\n         cfi   &r1,&v2\n         ago   .ftbton\n.ftbtor  anop\n&v2      setc  '&v2'(2,k'&v2-2)\n         cr    &r1,&v2\n.ftbton  anop\n         j&cnd &l._end\n.* end\n&l._ok   equ   *\n         MEXIT\n.*------\n.MEXIT   ANOP\n         MEND\n\n         MACRO\n.*----------< WILLOW STRUCTURED ASSEMBLER MACROS        >-------------*\n.*   'ELSE'                                                           *\n.*--------------------------------------------------------------------*\n&MLBL    ELSE\n         GBLA  &WAMIFLV\n         GBLC  &WAMIFLB(16)\n.* MNOTE *,'<ELSE  > SYSINDEX: &SYSNDX, IF-LVL: &WAMIFLV'\n.*\n         LCLA  &N,&NEWL2\n         LCLC  &L1,&L2\n.*\n&L1      SETC  '&WAMIFLB(&WAMIFLV)'  CURRENT LABEL PREFIX\n&L2      SETC  'IF&SYSNDX'           NEW LABEL PREFIX\n&WAMIFLB(&WAMIFLV) SETC  '&L2'\n         B     &L2._END\n&L1._END EQU   *\n         MEND\n\n         MACRO\n.*----------< WILLOW STRUCTURED ASSEMBLER MACROS        >-------------*\n.*   'ELSEIF'                                                         *\n.*--------------------------------------------------------------------*\n&MLBL    ELSEIF &THEN=\n         GBLA  &WAMIFLV\n         GBLC  &WAMIFLB(16)\n         GBLC  &WAMEILB(16)\n         LCLC  &L1,&L2\n&L1      SETC  '&WAMIFLB(&WAMIFLV)'\n.*\n         AIF   (K'&WAMEILB(&WAMIFLV) NE 0).EI0100\n&WAMEILB(&WAMIFLV) SETC  '&L1'\n.EI0100  ANOP\n&L2      SETC  '&WAMEILB(&WAMIFLV)'\n         B     &L2._EEND           PROCESS COMPLETED\n.*\n&WAMIFLV SETA  &WAMIFLV-1\n.* MNOTE *,'<ELSEIF> SYSINDEX: &SYSNDX, IF-LVL: &WAMIFLV'\n&L1._END EQU   *\n         IF    &SYSLIST(1),&SYSLIST(2),&SYSLIST(3),&SYSLIST(4),        +\n               &SYSLIST(5),&SYSLIST(6),&SYSLIST(7),&SYSLIST(8),        +\n               &SYSLIST(9),&SYSLIST(10),&SYSLIST(11),&SYSLIST(12),     +\n               &SYSLIST(13),&SYSLIST(14),&SYSLIST(15),&SYSLIST(16),    +\n               THEN=&THEN\n.MX      MEND\n\n         MACRO\n.*----------< WILLOW ASSEMBLY MACROS                    >-------------*\n.*   'ENDDO' FUNCTION.                                                *\n.*   DESC  : TERMINATE THE 'DO' FUNCTON.                              *\n.*   SYNTAX:  ENDDO                                                   *\n.*--------------------------------------------------------------------*\n         ENDDO\n         GBLA  &WAMDOLV\n         GBLC  &WAMDOLA(16)\n         GBLC  &WAMDOLB(16)\n         LCLC  &C\n&c       setc  '&WAMDOLA(&WAMDOLV)'\n         aif   ('&WAMDOLA(&WAMDOLV)' EQ 'ONCE').b\n         B     &WAMDOLB(&WAMDOLV)\n.b       anop\n&WAMDOLV SETA  &WAMDOLV-1\n         LEAVE LABEL\n         MEND\n\n         MACRO\n.*----------< WILLOW STRUCTURED ASSEMBLER MACROS        >-------------*\n.*   'ENDIF'                                                          *\n.*--------------------------------------------------------------------*\n&MLBL    ENDIF\n         GBLA  &WAMIFLV\n         GBLC  &WAMIFLB(16)\n         GBLC  &WAMEILB(16)        'ELSEIF' LABELS\n         LCLC  &L\n         AIF   (K'&MLBL EQ 0).MLB0900\n&MLBL    EQU   *\n.MLB0900 ANOP\n.*-\n.*   SET END-OF-EXECUTION LABEL\n.*-\n&L       SETC  '&WAMIFLB(&WAMIFLV)'\n&L._END  EQU   *\n.*-\n.*   SET END OF 'ELSEIF' CONSTRUCT\n.*-\n         AIF   (K'&WAMEILB(&WAMIFLV) EQ 0).EE0999\n&L       SETC  '&WAMEILB(&WAMIFLV)'\n&WAMEILB(&WAMIFLV) SETC  ''        RESET LABEL\n&L._EEND EQU   *                   END OF ELSEIF\n.EE0999  ANOP\n.*-\n.*   END OF MACRO\n.*-\n.MX      ANOP\n&WAMIFLV SETA  &WAMIFLV-1               BACK UP ONE LEVEL\n         MEND\n\n         MACRO\n.*----------< WILLOW STRUCTURED ASSEMBLER MACROS        >-------------*\n.*  'IF' FUNCTION.                                                    *\n.*                                                                    *\n.*  IF expr                                                           *\n.*   .. code ..                                                       *\n.*  ELSEIF expr                                                       *\n.*   .. code ..                                                       *\n.*  ELSE                                                              *\n.*   .. code ..                                                       *\n.*  ENDIF                                                             *\n.*  IF expr,THEN=(instruction)                                        *\n.*                                                                    *\n.*  'expr' is one or more tests combined by boolean logic AND or      *\n.*  OR. Each test should be enclosed in paranthesis, even if it       *\n.*  consist of only a single operand like (NZ).                       *\n.*    i.e. IF (CLC,FW,EQ,=A(0)),AND,(LTR,R15,R15,Z)                   *\n.*  'expr' is case insensitive.                                       *\n.*                                                                    *\n.*  IF (cond)    test condition listed below                          *\n.*     i.e.      IF (NZ) after a LTR rx,rx                            *\n.*  IF (cc)      test condition code                                  *\n.*     i.e.      IF (2) after a CLC arg1,arg2                         *\n.*  IF (compare,arg1,cond,arg2)                                       *\n.*     compare   One of the compare instructions CLx, CR ...          *\n.*     arg1      argument 1 of compare                                *\n.*     cond      condition listed below                               *\n.*     arg2      argument 2 of compare                                *\n.*     i.e.      IF (CLC,RC,EQ,=A(8))                                 *\n.*  IF (test,arg1,arg2,cond)                                          *\n.*     test      Test instruction, i.e. LTR                           *\n.*     arg1      argument 1 of test                                   *\n.*     arg2      argument 2 of test                                   *\n.*     cond      condition listed below                               *\n.*     i.e.      IF (LTR,R5,R15,NZ)                                   *\n.*  IF (test,arg1,arg2,arg3,cond)                                     *\n.*     instr     Test instruction, i.e. LTR and TM                    *\n.*     arg1      argument 1 of test                                   *\n.*     arg2      argument 2 of test                                   *\n.*     arg3      argument 3 of test                                   *\n.*     cond      condition listed below                               *\n.*     i.e.      IF (TM,BYTE1,X'01',O)   bit is ONE                   *\n.*                                                                    *\n.*  Some short-cuts                                                   *\n.*    IF (arg1,cond,arg2) is short for IF (compare,arg1,cond,arg2)    *\n.*    IF (Rx,cond)        is short for IF (LTR,Rx,Rx,cond)            *\n.*                                                                    *\n.*  List of conditions                                                *\n.*    EQ     Equal                                                    *\n.*    NE     Not equal                                                *\n.*    GT     Greater then                                             *\n.*    LT     Less than                                                *\n.*    LE     Less than or equal                                       *\n.*    GE     Greater then or equal                                    *\n.*    O      One   - used with bit-testing, i.e. TM, and LTR          *\n.*    Z      Zero  - used with bit-testing, i.e. TM, and LTR          *\n.*    NZ     Not zero                                                 *\n.*    conditions are case insensitive.                                *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n&MLBL    IF    &THEN=,&LP=\n         AIF   (K'&MLBL EQ 0).MLB0900\n&MLBL    CNOP  0,4\n.MLB0900 ANOP\n         LCLA  &N,&M,&SLN,&LSUF\n         LCLC  &I,&O,&C,&L,&LEX,&LCUR,&LNXT,&LPF,&COND,&S\n         GBLA  &WAMIFLV\n         GBLC  &WAMIFLB(16)\n.*-\n.*   preset variables\n.*-\n&LPF     SETC  'IF&SYSNDX'\n         AIF   (K'&LP EQ 0).LP099\n&LPF     SETC  '&LP'\n.LP099   ANOP\n&LSUF    SETA  0\n&WAMIFLV SETA  &WAMIFLV+1              FWD IN ARRAY\n&WAMIFLB(&WAMIFLV) SETC '&LPF'        LABEL PREFIX FROM ABOVE\n.*-\n.*   process parm field(s)\n.*-\n&SLN     SETA  1\n.OP00    ANOP\n&LSUF    SETA  &LSUF+1\n&LCUR    SETC  '&LPF.&LSUF'            CURRENT\n.*** don't use label for first test\n         AIF   (&SLN NE 1).OP10\n&LCUR    SETC  ''                      DON'T USE LABEL FOR FIRST TEST\n.OP10    ANOP\n&N       SETA  &LSUF+1\n&LNXT    SETC  '&LPF.&N._BGN'          NEXT\n.*-\n.*   generate instructions incl branch\n.*-\n&S       SETC  '&SYSLIST(&SLN+1)'\n&COND    SETC  UPPER('&s')\n         AIF   ('&COND' EQ 'OR').BC0200\n         AIF   (N'&SYSLIST EQ 1).BC0400\n         AIF   (&SLN GE N'&SYSLIST OR '&SYSLIST(&SLN+1)' EQ '').BC0300\n.*-\n.*   use inverted branch to end-of-proc for 'and' function\n.*-\n&LCUR    WSAMIFB &SYSLIST(&SLN),&LPF._END,N\n         AGO   .BC0900\n.*-\n.*   'or' : setup branch address by look-ahead\n.*-\n.BC0200  ANOP\n&N       SETA  &SLN+1                  -> CURRENT 'OR' WORD\n.BC0220  ANOP\n&N       SETA  &N+2                    -> NEXT 'OR' WORD\n&S       SETC  '&SYSLIST(&N)'\n&COND    SETC  UPPER('&s')\n         AIF   (&N LT N'&SYSLIST AND '&COND' EQ 'OR').BC0220\n&N       SETA  (&N/2)+1                <- NEXT NOT 'OR' COMPARE\n&LNXT    SETC  '&LPF.&N._BGN'   NEXT\n.*-\n.* use inverted branch for 'or' comparison\n.*-\n&LCUR    WSAMIFB &SYSLIST(&SLN),&LPF.&N._BGN\n         AGO   .BC0900\n.*-\n.*   last check\n.*-\n.BC0300  ANOP\n&LCUR    WSAMIFB &SYSLIST(&SLN),&LNXT\n         B     &LPF._END\n&LNXT    EQU   *\n         AGO   .BC0600\n.*-\n.*   only one item\n.*-\n.BC0400  ANOP\n         WSAMIFB &SYSLIST(&SLN),&LPF._END,N\n.*\n.BC0600  ANOP\n         AIF   (K'&SYSLIST(2) EQ 0).THN0000  ONLY 1 ITEM\n         AGO   .THN0000\n.*\n.BC0900  ANOP\n.*-\n.*   next syslist\n.*-\n&SLN     SETA  &SLN+2\n         AGO  .OP00\n.EX00    ANOP\n         B         &LEX                NO GO\n&LNXT    EQU   *\n.*-\n.*   'then' process\n.*-\n.THN0000 aif   (k'&then eq 0).thn0900\n         WSAMINSTR &then\n         ENDIF\n.THN0900 ANOP\n.*-\n.* end of macro\n.*-\n.MEXIT   MEND\n\n         MACRO\n.*----------< WILLOW STRUCTURED ASSEMBLER MACROS        >-------------*\n.*   'ITERATE'                                                        *\n.*   FUNCTION:  JUMP TO START OF CURRENT DO GROUP OR TOP              *\n.*   SYNTAX:    ITERATE \u00ddlabel\u00a8                                       *\n.*--------------------------------------------------------------------*\n         ITERATE  &DOLBL\n         LCLA  &N,&M\n         GBLA  &WAMDOLV\n         GBLC  &WAMDOLB(16)\n         LCLC  &S\n.*\n&S       SETC  UPPER('&DOLBL')\n         AIF   ('&S' EQ 'OUTER').OUTER\n         AIF   ('&S' EQ 'TOP').OUTER\n         AIF   (K'&DOLBL GT 0).LBL100\n&N       SETA  &WAMDOLV\n         B     &WAMDOLB(&N)\n         MEXIT\n.*\n.LBL100  ANOP\n         B     &DOLBL._BGN\n         MEXIT\n.*\n.OUTER   ANOP\n         B     &WAMDOLB(1)\n         MEXIT\n.*\n         MEND\n\n         MACRO\n.*----------< WILLOW STRUCTURED ASSEMBLER MACROS        >-------------*\n.*   'LEAVEALL' - BREAK OUT OF ALL DO BLOCKS                          *\n.*--------------------------------------------------------------------*\n         LEAVEALL\n         LEAVE ALL\n         MEND\n\n         MACRO\n.*----------< WILLOW STRUCTURED ASSEMBLER MACROS        >-------------*\n.*   'SKIP'  - unconditional jump around a section                    *\n.*--------------------------------------------------------------------*\n&LBL     SKIP\n         GBLC  &SKIPLBL\n&SKIPLBL SETC  'SKP&SYSNDX'\n         B     &SKIPLBL\n         MEND\n\n         MACRO\n.*----------< WILLOW STRUCTURED ASSEMBLER MACROS        >-------------*\n.*   'ENDSKIP'                                                        *\n.*--------------------------------------------------------------------*\n         ENDSKIP\n         GBLC  &SKIPLBL\n&SKIPLBL CNOP  0,4\n         MEND\n\n         MACRO\n.*----------< WILLOW STRUCTURED ASSEMBLER MACROS        >-------------*\n.*   SETUP INSTRUCTION OPERANDS AND BRANCH COND                       *\n.*--------------------------------------------------------------------*\n&LBL     WSAMIFB &EXPR,&BADDR,&NEG\n         LCLA  &N,&M\n         LCLC  &C,&L\n         LCLC  &CI                        EXTRACTED INSTRUCTION\n         LCLC  &BI                        GENERATED BRANCH INSTRUCTION\n         LCLC  &ADDR1                     1ST ADDRESS OF INSTRUCTION\n         LCLC  &ADDR2                     2ND ADDRESS OF INSTRUCTION\n         LCLC  &COND                      CONDITION\n.*-\n.*   setup instruction operands\n.*-\n&c       setc  Upper('&expr(1)')\n         AIF   (N'&EXPR EQ 0).T0E\n         AIF   (N'&EXPR EQ 1).T100     ONLY COND\n         AIF   (N'&EXPR EQ 2).T200     LOAD-AND-TEST\n         AIF   (N'&EXPR EQ 3).T300    'SHORT' COMPARE\n         AIF   (N'&EXPR EQ 4).T400     4-PART OPERAND\n         AIF   (N'&EXPR EQ 5).T500     5-PART OPERAND\n         AIF   (N'&EXPR EQ 6 and '&c' eq 'EX').exlong\n         MNOTE 8,'** NUMBER OF EXPRESSIONS GT 5 - &EXPR'\n         MEXIT\n.T0E     MNOTE 8,'** MISSING EXPRESSION'\n         MEXIT\n.*\n.*------ 1-PART : ONLY COND SPECIFIED - I.E. (Z)\n.T100    ANOP\n&COND    SETC  UPPER('&EXPR(1)')             COND\n         AIF   (K'&LBL EQ 0).BC00\n&LBL     EQU   *\n         AGO   .BC00\n.*\n.*------ 2-PART : SHORT LOAD-AND-TEST - I.E. (R5,Z)\n.T200    ANOP\n&LBL     LTR   &EXPR(1),&EXPR(1)\n&COND    SETC  Upper('&EXPR(2)')              COND\n         AGO   .BC00\n.*\n.*------ 3-PART : SHORT COMPARE - I.E. (SRCE,EQ,TGT)\n.T300    ANOP\n&LBL     CLC   &EXPR(1),&EXPR(3)\n&COND    SETC  Upper('&EXPR(2)')              COND\n         AGO   .BC00\n.*\n.*------ 4-PART :i.e. (clc,srce,eq,tgt) or (lt,r1,zero,z)\n.T400    ANOP\n&CI      SETC  Upper('&EXPR(1)')       CONDITIONAL INSTRUCTION\n&N       SETA  K'&EXPR(1)              LENGTH OF INSTR\n&C       SETC  Upper('&EXPR(4)')       condition maybe\n&ADDR1   SETC  '&EXPR(2)'              1ST ADDRESS\n.* if the condition is in p4 then jump\n         aif   ('&c' eq 'Z' or '&c' eq 'NZ'                            c\n               or '&c' eq 'O'  or '&c' eq 'M'                          c\n               or '&c' eq 'EQ' or '&c' eq 'NE'                         c\n               or '&c' eq 'GE' or '&c' eq 'GT'                         c\n               or '&c' eq 'LE' or '&c' eq 'LT').T420\n.* the condition is supposedly in p3, i.e. (c,r1,eq,fw1)\n&ADDR2   SETC  '&EXPR(4)'          2ND ADDRESS\n&COND    SETC  Upper('&EXPR(3)')   COND\n         AGO   .T490\n.* the condition is in p4, i.e. (lt,r1,fw1,z)\n.T420    ANOP\n&ADDR2   SETC  '&EXPR(3)'              2ND ADDRESS\n&COND    SETC  Upper('&EXPR(4)')       COND\n.* PERFORM INSTRUCTION\n.T490    ANOP\n&LBL     &CI   &ADDR1,&ADDR2\n         AGO   .BC00\n.*\n.*------ 5-PART\n.T500    ANOP\n&CI      SETC  Upper('&EXPR(1)')              CONDITIONAL INSTRUCTION\n         AIF   ('&CI'(1,1) EQ 'C').T520\n.*------ 1) I.E. (ICM,R1,7,SOURCE,Z)\n&COND    SETC  Upper('&EXPR(5)')              COND\n         &CI   &EXPR(2),&EXPR(3),&EXPR(4)\n         AGO   .BC00\n.*------ 2) I.E. (CLM,R1,1,EQ,SOURCE)\n.T520    ANOP\n&COND    SETC  Upper('&EXPR(4)')              COND\n&CI      SETC  Upper('&EXPR(1)')   CONDITIONAL INSTRUCTION\n&LBL     &CI   &EXPR(2),&EXPR(3),&EXPR(5)\n         AGO   .BC00\n.*------ long EXexute including the executed instructions\n.ExLong  ANOP\n&l       setc  'xl&sysndx'\n&cond    setc  upper('&expr(6)')              cond\n&ci      setc  upper('&expr(3)')              EX'd instruction\n&lbl     j     &l.b\n&l.t     &ci   &expr(4),&expr(5)\n&l.b     ex    &expr(2),&l.t\n         AGO   .BC00\n.*\n.T999    ANOP\n.*-\n.*     SETUP BRANCH - NORMAL AND INVERTED\n.*-\n.BC00    ANOP\n&COND    SETC  Upper('&COND')\n         AIF   ('&COND' NE 'EQ').BC100\n&COND    SETC  'E'                     CHANGE 'EQ' TO 'E'\n         AGO   .BC199\n.BC100   AIF   ('&COND' NE 'GT').BC101\n&COND    SETC  'H'                     CHANGE 'GREATER THAN' TO 'HIGH'\n         AGO   .BC199\n.BC101   AIF   ('&COND' NE 'LT').BC102\n&COND    SETC  'L'                     CHANGE 'LESS THAN' TO 'LOW'\n         AGO   .BC199\n.BC102   AIF   ('&COND' NE 'LE').BC103\n&COND    SETC  'NH'                    LOW-OR-EQUAL => NOT-HIGH\n         AGO   .BC199\n.BC103   AIF   ('&COND' NE 'GE').BC104\n&COND    SETC  'NL'                    GT-OR-EQUAL  => NOT-LOW\n         AGO   .BC199\n.BC104   AIF   (T'&COND NE 'N').BC105\n         aif   ('&neg' eq 'N').bc104n\n         bc    &cond,&baddr            by cond-code\n         ago   .bc900\n.bc104n  bc    15-&cond,&baddr         by reversed cond-code\n         ago   .bc900\n.BC105   ANOP\n.BC199   ANOP\n.*-------\n         AIF   ('&COND '(1,1) NE 'N' AND '&NEG' NE 'N').BC210\n         AIF   ('&COND '(1,1) EQ 'N' AND '&NEG' NE 'N').BC220\n         AIF   ('&COND '(1,1) NE 'N' AND '&NEG' EQ 'N').BC230\n         AIF   ('&COND '(1,1) EQ 'N' AND '&NEG' EQ 'N').BC240\n         MNOTE 8,'** ERROR - COND &COND AND NEGATION ''&NEG'' MISMATCH'\n         MEXIT\n.* NOT NEGATED BY CALLER\n.BC210   ANOP\n.BC220   ANOP\n&BI      SETC  '&COND'                LEAVE TO NORMAL\n         AGO   .BC800\n.* NOT NEGATIVE CONDITION, NEGATED\n.BC230   ANOP\n&BI      SETC  'N&COND'               NEGATE CONDITION\n         AGO   .BC800\n.* NEGATIVE CONDITION, NOT NEGATED\n.BC240   ANOP\n&N       SETA  (K'&COND)-1            NORMAL IS NEGATIVE\n&BI      SETC  '&COND'(2,&N)          INVERTED WILL BE POSITIVE\n.*\n.BC800   ANOP\n         AIF   (K'&BADDR EQ 0).BC900  NO ADDRESS PROVIDED\n         B&BI  &BADDR\n.BC900   ANOP\n.*-\n.*   END OF MACRO\n.*-\n.MEXIT   ANOP\n         MEND\n\n         Macro\n.*----------< WILLOW STRUCTURED ASSEMBLER MACROS        >-------------*\n.*   IIF - short IF/ELSE/ENDIF                                        *\n.*--------------------------------------------------------------------*\n         IIF  &cond,&true,&false\n         IF    &cond\n           WSAMINSTR &true\n         ELSE\n           WSAMINSTR &false\n         ENDIF\n         MEND\n\n         MACRO\n.*----------< WILLOW STRUCTURED ASSEMBLER MACROS        >-------------*\n.*   start of data block                  (not really part of WSAM)   *\n.*--------------------------------------------------------------------*\n&name    DATABLK\n         gblc  &WSAMDBLK\n&wsamdblk setc 'WSAMDBLK_&sysndx'\n         cnop  0,4\n         j     &wsamdblk._END\n         Mend\n\n         MACRO\n.*----------< WILLOW STRUCTURED ASSEMBLER MACROS        >-------------*\n.*   end of data block                    (not really part of WSAM)   *\n.*--------------------------------------------------------------------*\n         DATABLKE\n         gblc  &WSAMDBLK\n&wsamdblk._END ds  0a\n         Mend\n\n         MACRO\n.*----------< WILLOW STRUCTURED ASSEMBLER MACROS        >-------------*\n.*   Generate LTORG in instruction block (not really part of WSAM)    *\n.*--------------------------------------------------------------------*\n         LITERALS\n         lclc  &l\n&l       setc 'ILT&sysndx'\n         j     &l\n         LTORG\n&l       ds  0h\n         Mend\n\n         MACRO\n.*----------< WILLOW STRUCTURED ASSEMBLER MACROS        >-------------*\n.*   Generate instruction (internal support macro)                    *\n.*   Operands needs to remain separated for macro calls               *\n.*--------------------------------------------------------------------*\n&ml      WSAMINSTR &istr\n         lclc  &i,&o\n         lcla  &n,&m\n&i       setc  '&istr(1)'\n         aif   (n'&istr eq 1).gen1\n         aif   (n'&istr eq 2).gen2\n         aif   (n'&istr eq 3).gen3\n         aif   (n'&istr eq 4).gen4\n         mnote 8,'Too many operands'\n         mexit\n.gen1    &i\n         mexit\n.gen2    &i    &istr(2)\n         mexit\n.gen3    &i    &istr(2),&istr(3)\n         mexit\n.gen4    &i    &istr(2),&istr(3),&istr(4)\n         mexit\n         Mend\n\n         MACRO\n.*----------< WILLOW STRUCTURED ASSEMBLER MACROS        >-------------*\n.* Generate L/LA instruction (internal support macro)                 *\n.* Adaption of the $LA general macro.                                 *\n.* Syntax: WSAMLA reg,value                                           *\n.*         what: label or (reg) or 'literal' or f/h/b.label           *\n.*--------------------------------------------------------------------*\n&ml      WSAMLA\n         lclc  &xlar,&xlap,&xla\n         lcla  &xlapn,&xlan\n&xlar    setc  '&syslist(1)'\n&xlapn   seta  1\n.xlanext anop\n&xlapn   seta  &xlapn+1\n         aif   (&xlapn gt n'&syslist).xlan\n&xlap    setc  '&syslist(&xlapn)'\n         aif   (k'&xlap eq 0).xlanext\n         aif   ('&xlap '(1,1) eq '(').xlareg\n         aif   ('&xlap '(1,1) eq '''').xlalit\n         aif   ('&xlap  '(2,1) eq '.').xlafld\n&xla     setc  t'&xlap\n         aif   ('&xla' eq 'N').xlanum\n         la    &xlar,&xlap\n         aif   ('&xlap  '(1,2) eq 'l''').mend\n         mexit\n.xlanum  anop\n         lgfi  &xlar,&xlap\n         mexit\n.xlafld  anop\n&xlan    seta  k'&xlap-2\n&xla     setc  '&xlap'(1,1)\n&xla     setc  Upper('&xla')\n         aif   ('&xla' ne 'F').xlafld2\n&xla     setc  ''\n.xlafld2 anop\n&xlap    setc  '&xlap'(3,&xlan)\n         l&xla &xlar,&xlap\n         mexit\n.xlareg  anop\n&xlan    seta  k'&xlap-2\n&xlap    setc  '&xlap'(2,&xlan)\n         lr    &xlar,&xlap\n         mexit\n.xlalit  anop\n         la    &xlar,=c&xlap\n&xlan    seta k'&xlap-2\n.xlan    mexit\n.mend    MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "Z669MAC1": {"ttr": 11271, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00E\\x01\\x193\\x7f\\x01\\x193\\x9f\\x16\\x11\\x00\\x15\\x00\\x12\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2019-12-03T00:00:00", "modifydate": "2019-12-05T16:11:45", "lines": 21, "newlines": 18, "modlines": 0, "user": "DVL"}, "text": "Address Isredit \"MACRO NOPROCESS (PRM)\"\nAddress Isredit\n\"(ds)=dataset\"\n\"(mb)=member\"\n\nparse upper var prm ,\n  . 'JP('JP')' . 0 . 'JA('JA')' . 0 . 'JC('JC')' . 0 . 'JM('JM')' .\n\n\"delete 1 3\"\njbn = left(jp''mb,8)\njc1=\"//\"jbn \"JOB (\"ja\"),'CBT669-\"mb\"',CLASS=\"jc\",\"\njc2=\"//      MSGCLASS=\"jm\",COND=(0,LT),REGION=64M\"\njc3=\"//* CBT 669 product\" mb\njc4=\"//*\"\n\n\"line_after 0 = (jc1)\"\n\"line_after 1 = (jc2)\"\n\"line_after 2 = (jc3)\"\n\"line_after 3 = (jc4)\"\n\"save\"\n\"cancel\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Z669UPDT": {"ttr": 11273, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x004\\x01\\x193\\x7f\\x01\\x193\\x9f\\x16\\x13\\x00*\\x00\\x1c\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2019-12-03T00:00:00", "modifydate": "2019-12-05T16:13:34", "lines": 42, "newlines": 28, "modlines": 0, "user": "DVL"}, "text": "/*                                                                    rexx\n\n Update members of the CBT 669 library\n Requires the STARTOOL or PDS86 program.\n\n*/\n\n parse source sys type whoami ddn whereami .\n\n /* select program to use for update */\n pgm='STARTOOL'                   /* choose one   */\n pgm='PDS86'                      /* or the other */\n\n /* target loadlib(s) */\n lpalib =userid()'.test.lpalib'\n linklib=userid()'.test.linklib'\n\n /* edit job options */\n jp  = left(userid(),2)     /* job name prefix */\n ja  = '1'                  /* job account     */\n jc  = 'A'                  /* job class       */\n jm  = 'T'                  /* message class   */\n\n /* now do updates */\n upper lpalib linklib\n \"\"pgm \"'\"whereami\"' repl a:y 'cbt669.lib' '\"whereami\"' write\"\n \"\"pgm \"'\"whereami\"' repl a:y 'cbt669.lpalib' '\"lpalib\"' write\"\n \"\"pgm \"'\"whereami\"' repl a:y 'cbt669.linklib' '\"linklib\"' write\"\n\n /* Use edit macro to update job stmt - edit member ZCSMAC */\n names='ISPDPX01 REXXGBLV REXXSTOR RXPATTRN RXRDPRML',\n       'RXOPCOMM RXVSAMBA RXWAIT'\n \"altlib act appl(exec) da('\"whereami\"')\"\n p='jp('jp') ja('ja') jc('jc') jm('jm')'\n do n=1 to words(names)\n   name=word(names,n)\n   say 'Job stmt update for' name\n   address ispexec \"edit dataset('\"whereami\"(\"name\")')\",\n                   \"macro(z669mac1) parm(p)\"\n   if rc<>0 then leave\n end\n \"altlib deact appl(exec)\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT669/FILE669.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT669", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}