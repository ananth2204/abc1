//RXOP006  JOB (1),'REXX-OPCOM-QEDIT',
//*  RESTART=IVP1,
//             CLASS=A,MSGCLASS=X,REGION=32M,COND=(0,LT)
//*
//* ?? RXOPCOMM - modify/stop operator command for REXX ? e ?
//*
//   EXEC ASMACL,
//        PARM.C='TERM,RENT',
//        PARM.L='LIST,AMODE(31),RMODE(ANY),RENT,REFR'
//C.SYSLIB  DD DISP=SHR,DSN=SYS1.MACLIB
//          DD DISP=SHR,DSN=SYS1.MODGEN
//          DD DISP=SHR,DSN=CBT669.LIB
//C.SYSTERM DD SYSOUT=*
//C.SYSIN   DD *
*Process compat(macrocase)
**asma syslib *
**asma opt    term
*
* RXOPCOMM - MODIFY/STOP operator command for REXX programs.
*
* Build: 006
*
* Changes in this build
*  Some cleanup and beautification
*
* Syntax
*  cc=RXOPCOMM('INIT')
*    Setup control blocks
*  cc=RXOPCOMM('TERM')
*    Release control blocks
*  cc=RXOPCOMM('GET'Ý,'wto-text'¨)
*    Check for response, return response text.
*    Max response length is 255.
*    Optionally issue a WTO before check.
*  cc=RXOPCOMM('WTO','wto-text'Ý,H¨)
*    Issue a WTO. Option H retains the text on the console.
*
         lclc  &JPAQ
&JPAQ    SETC  'Y'                     Retain module in the JPAQ
*
         print off
         Copy  WSAMMacs
         Copy  RexxMacs
         Copy  SYSMACS
*        COPY  Z10MACS
         print on

         Macro
         SayIt &t
         lcla  &tl
         aif   (k'&t eq 0).go
&tl      seta  (k'&t)-2
         mvc   logr(&tl),=c&t
.go      anop
         RXSAY logr,l'logr,wrk=rxwork
.x       clear logr
         Mend

         Macro
         SubCall &name
         l    r15,=v(&name)
         balr  r14,r15
         Mend

* ------------------------------------------------------------------- *
* Prolog                                                              *
* ------------------------------------------------------------------- *
         lclc  &$module,&version
&version setc  '006'
&$module setc  'RXOPCOMM'
         #subr set,entry=csect,base=r11,saend=saend
*
&$module #module amode=31,rmode=31,base=r12,                           c
               work=(lclstorl,lclstor,r10,C),sa=sa1,epilog=MainEpi,    c
               text=' V&version'

*- init storage
         clear blank
         mvc   action,blank
         mvc   reason,blank
         mvc   zero8,=8c'0'
         mvc   logr,blank
         mvc   retval,blank
         mvlit retval,'00000000'
         mvc   retvall,=a(8)
         mvc   NtName,=cl8'&$module'
         mvc   NtName2,blank
         la    r1,l'logr
         sll   r1,16
         st    r1,logrwto

         aif   ('&JPAQ' ne 'Y').jpaqn
*-
* Keep module in JPAQ for duration of job / TSO session  (change 005)
* Ignored if module is loaded from the LPA.
*-
*        CDEUCTZ2 dsect=N

.jpaqn   anop
*-
* Initialize REXX interfaces
*-
         ereg  0,1
         RxInit ,
*        sayit 'init done'

*-
* check parms
*-
         l     r4,zrx_r1               old r1
         using efpl,r4                 point to parmlist
         mvc   parmarga,efplarg        save
         drop  r4
         if    (cli,parmarga,eq,x'FF')
           mvc  rc,=al2(10)
           #module exit
         endif

* get and check parm 1 - action
* sayit 'p1'
         l     r5,parmarga
         lm    r14,r15,0(r5)           address and length
         if    (ltr,r15,r15,z),or,(clfi,r15,gt,l'action)
           mvc  rc,=al2(8)
           $cvd  r15,reason+14,len=4
           mvlit reason,'parm 1 length'
           #module exit
         endif
         lr    r3,r15
         bctr  r15,0
         mvc   action(*-*),0(r14)
         ex    r15,*-6
         oc    action,blank

         la    r2,actlist
         do    until,(cli,0(r2),eq,255)
           if    (clc,action,eq,0(r2))
             leave
           endif
           la    r2,actlistl(,r2)
         enddo

         if    (cli,0(r2),eq,255)
           mvlit reason,'invalid action'
           mvc  rc,=al2(11)
           #module exit
         endif

* perform action
*sayit 'call'
         l     r15,actlistnl(,r2)
         balr  r14,r15
         #module exit

* -------------end of module processing--------------------------------
MainEpi  #subr label
         RxVPut name='&$module._REASON',data=(reason,l'reason)

         if    (rc,ne,zero)
           lh   r1,rc
           $cvd  r1,retval,len=8
         endif

         RxRetval retval,f.retvall
         #subr end

* -------------fixed data----------------------------------------------

zero     dc    a(0)
actlist  dc    cl8'INIT',v(init)
actlistnl equ   8
actlistl  equ   12
         dc    cl8'GET',v(get)
         dc    cl8'TERM',v(term)
         dc    cl8'WTO',v(WTO)
         dc    cl8'VERSION',v(version)
         dc    al1(255)

         ltorg

* -------------Version           --------------------------------------

Version  #subr
*        sayit 'Version'
         mvc   retval(l'vertext),vertext
         mvc   retvall,=a(l'vertext)
         #subr exit

VerText  dc    c'&$module &version &sysdate &systime'
         #subr drop

* -------------Initialize ---------------------------------------------

INIT     #subr
* sayit 'init'

* is there an N/T block already?
         NTSERVX rt,n=NtName,t=NtToken,l=home,rc=NtRc,pl=NtParms
         if   (clc,ntrc,ne,zero)      nope
*   get storage
           la    r9,qedblkl
           STORAGE OBTAIN,LENGTH=(9),SP=131,CALLRKY=YES
           st    r1,NtTokAdr            address
           st    r9,NtTokSiz            size
           lr    r8,r1
*   make NT
           NTSERVX  cr,n=NtName,t=NtToken,l=home,rc=NtRc,pl=NtParms
           if    (clc,ntrc,ne,zero)
             l     r15,ntrc
             $cvd  r15,reason+17,len=8
             mvlit reason,'NT create failed'
             mvc   rc,=al2(8)
             #subr exit,rc=8
           endif
         endif

* setup QEDIT request
         Using  qedblk,r8
         OPCOMM INIT
         drop  r8

         #subr exit
         #subr drop

* -------------Terminate ----------------------------------------------

TERM     #subr
*        sayit 'drop'
         NTSERVX rt,n=NtName,t=NtToken,l=home,rc=NtRc,pl=NtParms
         if    (clc,ntrc,ne,zero)
           l     r15,ntrc
           $cvd  r15,reason+25,len=8
           mvlit reason,'TERM - locate NT failed'
           mvc   rc,=al2(8)
*          sayit 'not found'
           #Subr exit,rc=8
         endif
*-storage
         l     r3,NtTokAdr
         l     r4,NtTokSiz
         STORAGE RELEASE,LENGTH=(4),ADDR=(3),SP=131,CALLRKY=YES
*-N/T
         NTSERVX dl,n=NtName,rc=NtRc,pl=NtParms
         if    (clc,ntrc,ne,zero)
           l     r15,ntrc
           $cvd  r15,reason+25,len=8
           mvlit reason,'TERM - delete NT failed'
           mvc   rc,=al2(8)
           #subr exit,rc=8
         endif
*        cvxd  in=ntrc,out=logr+20,len=4
*        sayit 'drop ntrc'

         #subr exit
         #subr drop

* -------------Get response -------------------------------------------

Get      #subr
* sayit 'get'
         NTSERVX rt,n=NtName,t=NtToken,l=home,rc=NtRc,pl=NtParms
         if    (clc,ntrc,ne,zero)
           l     r15,ntrc
           $cvd  r15,reason+24,len=8
           mvlit reason,'GET - locate NT failed'
           mvc   rc,=al2(8)
           #subr exit,rc=8
         endif

* WTO text?
         l     r5,parmarga
         if    (cli,8(r5),ne,x'ff'),then=(subcall,WTO)

         l     r9,NtTokAdr
         using qedblk,r9
         clear qedresp
         xc    qedrespl,qedrespl
         OPCOMM GET,MAREA=qedresp

         la    r4,qedrespd
         lh    r5,qedrespl
*        if    (cli,qedresp,ne,c' ')
*          cvxd  in=qedrespl,out=qedresp+10,len=8
*          la    r5,40
*        endif
         st    r5,retvall
         if    (ltr,r5,r5,nz)
           bctr  r5,0
           mvc   retval(*-*),0(r4)
           ex    r5,*-6
         endif
*
         #subr exit
         #subr drop

* -------------WTO          -------------------------------------------

WTO      #subr
*        sayit 'WTO entered'

* get parm 2 - text
         l     r8,parmarga
         if    (cli,8(r8),eq,x'ff')
           mvlit reason,'WTO - no data'
           mvi   retval+7,c'8'
           #subr exit,rc=8
         endif
         lm    r4,r5,8(r8)             p2 address and length
         if    (ltr,r5,r5,z),or,(clfi,r5,gt,126)
           StrMake reason,'WTO - text length ',(r5,,cvdr,4)
           mvi   retval+7,c'8'
           #subr exit,rc=8
         endif
*- get text
         lr    r15,r5
         bctr  r15,0
         mvc   wrk256+4(*-*),0(r4)
         ex    r15,*-6
*- build suffix
         la    r15,wrk256
         la    r15,4(r5,r15)
         mvc   0(4,r15),=x'00204000' for desc=11
*- build prefix
         la    r5,4(,r5)             plus prefix
         sll   r5,16
         st    r5,wrk256
*- set wto type
         la    r1,=c'N'
         if    (cli,16(r8),ne,x'ff')
           l     r1,20(,r8)            -> opt
         endif
         if    (cli,0(r1),eq,c'H')   hold it
           oi    wrk256+2,x'80'      flags at front
         endif
*- issue wto
         la    r1,wrk256
         sr    r0,r0
         svc   35
*
         #subr exit
         #subr drop

* -------------dynamic area--------------------------------------------

LclStor  Dsect
sa1      ds    18f                     save area
sa2      ds    18f                     save area
sa3      ds    18f                     save area
sa4      ds    18f                     save area
saend    equ   *
*-
blank    ds    cl120
reason   ds    cl100
retval   ds    cl120
retvall  ds    a
parmarga ds    a
action   ds    cl8
suba     ds    a
NtParms  ds    0a(0),xl(20+32)
ntLevel  ds    a
NtId     ds    0cl16
NtName   ds    cl8
NtName2  ds    cl8
         ds    0d
NtToken  ds    xl16
         org   NtToken
NtTokAdr ds    a
NtTokSiz ds    a
NtTokRln ds    a
         org
NtRc     ds    a
p2def    ds    2a
Lendef   ds    2a
Datadef  ds    2a

rc       ds    h
zero8    ds    cl8
         ds    0a
fw       ds    f
dw       ds    d
logrwto  ds    a
logr     ds    cl120
varname  ds    cl(l'blank)
         RexxMacs ds
wrk256   ds    cl256
*-
LclStorL equ   *-LclStor

         IeaNtAsm

         RexxMacs dsect
*-QEDIT block
QEDBLK   dsect
qedresp  ds    0cl100
qedrespl ds    xl2
qedrespd ds    cl98
*-
         OPCOMM ds
         ds    0d
qedblkl  equ   *-qedblk
*-
         OPCOMM dsect
         Print nogen
         IHACDE                       used by CDEUCTZ2
         IHAPSA DSECT=YES             used by CDEUCTZ2
         IkjTcb                       used by CDEUCTZ2
*-
         END
//*
//L.SYSLMOD DD DSN=CBT669.LPALIB(RXOPCOMM),DISP=SHR
//*
//* Activate dynamic if in lpalib:
//*   SETPROG LPA,ADD,MODNAME=RXOPCOMM,DSNAME=CBT669.LPALIB
//*
//IVP1     EXEC PGM=IKJEFT1B,PARM='RXOPIVP1'
//SYSEXEC  DD DISP=SHR,DSN=CBT669.LIB
//STEPLIB  DD DISP=SHR,DSN=CBT669.LPALIB
//SYSTSPRT DD SYSOUT=*,OUTLIM=2000
//SYSTSIN  DD DUMMY
