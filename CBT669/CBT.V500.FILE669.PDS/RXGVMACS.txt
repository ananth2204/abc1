*-
* Macros etc for REXX Global Variables program REXXGBLV
* Updated for build 058
*-

*------------------Macro Log/TrcLog----------------------------------*

         MACRO
&lbl    zVCBTrace
*VCBTrace
&lbl     Call  Logger
         clear VCBAtrrec
         MEND

         Macro
&lbl     DoSay &t,&k
         mvlit logr,&t
         RxSay logr,l'logr,wrk=wrk256
         clear logr
         Mend

*------------------Trace block start/end-----------------------------*

         Macro
.* TrcBlk / TrcBlkEnd is used around larger trace blocks. This
.* cuts down on the number of instructions executed.
         TrcBlk
         gblc  &trcblka
         aif   ('&trcblka' eq '').go
         mnote 8,'***trcblka ne null'
         mexit
.go      anop
&trcblka setc  'TB&sysndx.END'
         cli   trace,c'Y'
         jne   &trcblka
         Mend

         Macro
         TrcBlkEnd
         gblc  &trcblka
&trcblka ds    0h
&trcblka setc  ''
         Mend

         Macro
&ml      TrcLog   &t,&k
         lclc  &l
&l       setc  'TL&sysndx'
&ml      cli   trace,c'Y'
         jne   &l.x
         mvlit logr,&t
         aif   (k'&k eq 0).k0
         RxSay logr,&k
         ago   .b
.k0      RxSay logr
.b       anop
         clear logr
&l.x     equ   *
         Mend

*------------------Log REXX data-------------------------------------*

         Macro
         LogRexxData &t
         clear logr
         STRMAKE logr,&t,lenck=Y,                                      c
               =12,(rnvvarl,4,cvd,4),                                  c
               ':',(vardatal,4,cvd,4),                                 c
               +1,(rnvvar,f.rnvvarl,,35),                              c
               '=',(vardata,f.vardataa,,,45)
         trclog ,
         Mend

*------------------Pool access---------------------------------------*

         Macro
&mlbl    POOL  &what,&name
&lbl     setc  'Z&sysndx'
         aif   (k'&name eq 0).namen
&mlbl    $la   r1,&name
.namen   anop
         Call  POOL&what
         ltr   r15,r15
         Mend

*- LogWto
         Macro
&lbl     LogWto &t,&l
&lbl     ds    0h
         aif   (k'&t eq 0).tl
         mvlit logr,&t,lr=r1
         sth   r1,wtopfx
         ago   .go
.tl      aif   (k'&l eq 0).go
         $la   r1,&l
         sth   r1,wtopfx
.go      lh    r1,wtopfx
         la    r1,4(,r1)
         sth   r1,wtopfx
         la    r1,wtopfx
         sr    r0,r0
         svc   35
         clear logr
         Mend

*- PGetNext
         Macro
&lbl     PGetNext &vcba=,&name=,&namel,&cursor=,&pl=
         $la   r14,&vcba               -> VCB anchor
         aif   (k'&name ne 0).setnam1
         sr    r15,r15
         sr    r0,r0
         ago   .setnamn
.setnam1 $la   r15,&name(1)
         $la   r0,&name(2)
.setnamn anop
         la    r1,&cursor
         stm   r14,r1,&pl
         la    r1,&pl
         call  PGetNext
         ltr   r15,r15
         Mend

*- Vputc2d
         Macro
         vputc2d &name,&var
         lclc  &s
&s       setc  Upper('&name')
         l     r1,&var
         $cvd  r1,dw,len=8
         RxVput name=('REXXGBLV_&s'),data=dw
         Mend

*- Vputp2d
         Macro
         vputp2d &name,&var
         lclc  &s
&s       setc  Upper('&name')
         unpk  dw,&var
         oi    dw+7,x'f0'
         RxVput name=('REXXGBLV_&s'),data=(dw,8)
         Mend

*- RexxPut
         Macro
.* syntax NAME=(addr,len),DATA=(addr,len)  *recommended*
.*     or (nameaddr,namelen),(dataaddr,datalen)
&lbl     RexxPut &name=,&data=
         aif   (n'&name gt 0).b
         $la   r14,&syslist(1,1)       -> name
         $la   r15,&syslist(1,2)       name length
         $la   r0,&syslist(2,1)        -> data
         $la   r1,&syslist(2,2)        data length
         ago   .c
.b       $la   r14,&name(1)            -> name
         $la   r15,&name(2)            name length
         $la   r0,&data(1)             -> data
         $la   r1,&data(2)             data length
.c       stm   r14,r1,parmlist
         la    r1,parmlist
         call  REXXVPUT
         Mend

*- EMsg
         Macro
         EMSG  &rc=,&force=Y
*Emsg
         lclc  &l
&l       setc  'M&sysndx'
         aif   ('&force' eq 'Y').forcen
         cli   emsgl+3,0               text already set?
         jne   &l.x                    then do not override
.forcen  anop
         mvlit emsg,&syslist(1),lenreg=r14
         st    r14,emsgl
         aif   (k'&rc eq 0).x
         $la   r0,&rc
         st    r0,rc
.x       anop
&l.x     equ   *
*Emsg end
         Mend

*- set max rc
         Macro
         SetMaxRc &rc
*SetMaxRc
         lgfi  r0,&rc
         c     r0,rc
         jnh   *+8
         st    r0,rc
*SetMaxRc end
.x       Mend

*- Return from sub, set max rc and/or text
         Macro
&lbl     SubEnd &rc=0,&maxrc=,&text=,&ctext=
         aif   (k'&lbl eq 0).lbln
&lbl     ds    0h
.lbln    anop
         aif   (k'&maxrc eq 0).maxrcn
         SetMaxRc &maxrc
.maxrcn  anop
         aif   (k'&text eq 0).textn
         Emsg  &text
.textn   anop
         aif   (k'&ctext eq 0).ctextn
         Emsg  &ctext,force=N
.ctextn  anop
         #subr end,rc=&rc
.x       Mend

*- Count
         Macro
         Count &q,&v,&reg=r15
         lclc  &a,&b
         l     &reg,&v
&a       setc  Upper('&q')
         aif   ('&a'(1,1) eq 'U').up
         aif   ('&a'(1,1) eq 'D').down
         mnote 8,'**Invalid action'
         mexit
.up      la    &reg,1(,&reg)
         ago   .st
.down    bctr  &reg,0
         ago   .st
.st      st    &reg,&v
         Mend

*- Required

         Macro
         Required
         lcla  &pn,&pc
         lclc  &name,&cmd,&l
&l       setc  'rq&sysndx'
&pn      seta  1
.a       anop
&name    setc  '&syslist(&pn)'
         cli   &name._dl,0
         jne   &l.x
&pn      seta  &pn+1
         aif   (&pn le n'&syslist).a
         emsg 'required parameter missing'
         #subr exit,rc=8
&l.x     ds   0h
         Mend

*- SayOrList

         Macro
         SayOrList &a,&l,&counter=stemnum
         ap    &counter,=p'1'
         if    (cli,liststem_dl,eq,0)
           RxSay &a,&l
         else
           RxStemPut stema=wrkname,base=(liststem,b.liststem_dl),      c
               pnum=&counter,data=(&a,&l)
         endif
         Mend

*- get new PACB, return address in r1
         Macro
&mlbl    PACBnew &name=,&vcbainit=Y
&mlbl    STORAGE OBTAIN,LENGTH=PACBblkl,SP=131,CALLRKY=YES,LOC=31
         stm   r14,r3,12(r13)        save
         aif   ('&vcbainit' eq 'Y').vcbai
         lr    r14,r1                -> area
         lgfi  r15,PACBblkl
         lr    r0,r14
         sr    r1,r1
         mvcl  r14,r0                clear
         ago   .rld
.vcbai   anop
         lr    r3,r1
         xc    PACBnext-PACB(l'PACBnext,r3),PACBnext-PACB(r3)
         Using VCBanchr,r3
         VCBAinit ,
         drop  r3
.rld     lm    r14,r3,12(r13)        reload
         $la   r15,&name
         mvc   PACBname-PACB(l'PACBname,r1),0(r15)
         Mend
