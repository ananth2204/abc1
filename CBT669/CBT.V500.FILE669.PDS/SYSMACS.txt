.* ADD NAME=$LA
         Macro
.*-
.* $LA - build LA instruction (inner macro)
.*
.* Returns length in a global variable, length either defined by the
.* 2rd operand, or computed from the 2nd operand.
.* Syntax:
.*   $la  r1,label      -> la    r1,label
.*   $la  r1,,label     -> la    r1,label
.*   $la  r1,number     -> lgfi  r1,nnn
.*   $la  r1,4(,r3)     -> la    r1,4(,r3)                -> length=0
.*   $la  r1,(r2)       -> lr    r1,r2                    -> length=0
.*   $la  r1,'kilroy'   -> la    r1,=c'kilroy'
.*   $la  r1,0          -> slr   r1,r1                    -> length=0
.*   $la  r1,x.label    -> lx    r1,label  (x: B, F or H) -> length=0
.* The length is returned in global variable $lalen, the type in
.* global variable $latype.
.*
.* updates
.* 2017-14-03  numeric value now different from label
.* 2018-06-16  2rd operand is now alternate src, not global length
.* 2019-01-11  change global $LALENC
.*-
&mlbl    $la   &reg,&psrc,&pasrc,&pasrc2,&glen=,&src2=
         lcla  &n,&l
         lclc  &s,&c,&r,&srct,&srcl,&src
         gbla  &$lalen
         gblc  &$lalenc
         gblc  &$latype
&$lalen  seta  0
&$lalenc setc ''
.* select source
         aif   (k'&psrc   gt 0).setsrc1
         aif   (k'&pasrc  gt 0).setsrc2
         aif   (k'&pasrc2 gt 0).setsrc3
         aif   (k'&src2   gt 0).setsrc4
         mnote  8,'** $LA mising source'
.setsrc1 anop
&src     setc  '&psrc'
         ago   .setsrcn
.setsrc2 anop
&src     setc  '&pasrc'
         ago   .setsrcn
.setsrc3 anop
&src     setc  '&pasrc2'
         ago   .setsrcn
.setsrc4 anop
&src     setc  '&src2'
.setsrcn anop
.*
&s       setc  Upper('&src')
         aif   ('&s   '(1,3) eq 'L''''').litlen
&srct    setc  t'&src
&srcl    setc  Lower('&src')
.* mnote *,'type &srct'
.*-
.* what kind of 1st operand do we have?
.*-
         aif   (k'&src gt 0).cp1
         mnote 8,'src operand missing'
         mexit
.cp1     aif   ('&src '(2,1) eq '.').load
         aif   ('&src' eq '0').clr          clear register
         aif   ('&src'(1,1) eq '(').reg     register
         aif   ('&src'(1,1) eq '''').txt    text
         aif   ('&srct' eq 'N').num        number
         ago   .lbl
.*- src is 0, means clear reg
.clr     anop  ,
&$latype setc  'CLR'
&mlbl    slr   &reg,&reg
         mexit
.*- src is a number
.num     anop  ,
&$latype setc  'NUM'
&mlbl    lgfi  &reg,&src
&$lalen  seta  &src
         mexit
.*- src is a label or address
.lbl     anop  ,                           label
&$latype setc  'LBL'
&mlbl    la    &reg,&src
&$lalenc setc  'l''&src'
&c       setc  t'&src
         aif   ('&c' ne 'A').setl0
&n       seta  l'&src
&$lalen  seta  &n
         mexit
.*- src is a register
.reg     anop  ,                           register
&$latype setc  'REG'
&n       seta  (k'&src)-2
&s       setc  '&src'(2,&n)
&mlbl    lr    &reg,&s
&$lalen  seta  1                            default
         mexit
.*- src is text
.txt     anop  ,
&$latype setc  'TXT'
&s       setc  '=c&src'
&mlbl    la    &reg,&s
&n       seta  (k'&src)-2
&$lalen  seta  &n
&$lalenc setc  '&n'
         mexit
.*- load from storage
.load    anop  ,
.* mnote *,'load'
&c       setc  Upper('&srcl'(1,1))
&n       seta  (k'&src)-2
&s       setc  '&src'(3,&n)
&$latype setc  'LFS'
&$lalen  seta  0
         aif   ('&c' eq 'F' or '&c' eq 'A').loadf
         aif   ('&c' eq 'H').loadh
         aif   ('&c' eq 'B').loadb
         mnote 8,*** invalid load parm &c'
         mexit
.loadf   anop  ,
&mlbl    l     &reg,&s                     load from fullword
         mexit
.loadh   anop  ,
&mlbl    lh    &reg,&s                     load from halfword
         mexit
.loadb   anop  ,
&mlbl    sr    &reg,&reg
         ic    &reg,&s                     load from byte
         mexit
*-
.litlen  anop
&n       seta  (k'&src)-4
&$lalen  seta  &n
         la    &reg,&n                     length of literal
         mexit
*-
.setl0   anop
&$lalen  seta  0
.x       Mend
.* ADD NAME=#MODULE
         Macro
.*
.* Setup module start - basereg, working storage etc.
.*
.* base=(reg1Ý,reg2Ý,reg3¨¨)      setup up to 3 baseregs
.* work=(length,label,reg)        acquire dynamic storage
.* work24=(length,label,reg)      acquire dynamic 24-bit storage
.* sa=label | *Ýn¨                save area label or inline
.* prolog=address                 address of prolog subroutine
.* epilog=address                 address of epilog subroutine
.* endÝ,rc=value¨                 return via epilog
.* returnÝ,rc=value¨              return via epilog
.*
.* Changelog
.* 2018-10-27  rc value for end can be syslist(2) i.e #module end,123
.* 2018-11-26  4th parm of work/work24 can be set to 'C' => clear stg
.* 2019-02-05  use &SYSCLOCK(1,16) instead of &SYSDATE+&SYSTIME
.*             add &ver option
.* 2019-02-14  add SYSSTATE OSREL=SYSSTATE,ARCHLVL=OSREL
.*
&mlbl    #MODULE &p1,&text=,&ver=,&rc=,&csect=csect,&amode=,&rmode=,   c
               &base=r12,&sa=,&work=,&work24=,&sp=*future*,            c
               &prolog=,&epilog=,&xprolog=,&xepilog=,&print=NOGEN
.*-
         gblb  &#modequ
         gbla  &iezbits
         gblc  &#modname,&#modrmod,&#modamod
         lcla  &n,&m
         lclc  &s,&l,&base1,&base2,&base3,&dt
         lclc  &worksz,&workrg,&worklb,&workloc,&workclr
&l        setc  '#M&sysndx'
          aif   (k'&p1 eq 0).nop1
&s        setc  Upper('&p1')
          aif   ('&s' eq 'END' or '&s' eq 'RETURN'                     c
               or '&s' eq 'EXIT').end
          mnote 8,'*** Invalid p1'
          mexit
.nop1     anop
          aif   (k'&mlbl gt 0).lblok
          mnote 8,'*** Missing label'
          mexit
.lblok    anop
&#modname setc  '&mlbl'
&base1    setc  '&base(1)'
&base2    setc  '&base(3)'
&base3    setc  '&base(4)'
&worksz   setc  '&work(1)&work24(1)'
&worklb   setc  '&work(2)&work24(2)'
&workrg   setc  '&work(3)&work24(3)'
&workclr  setc  Upper('&work(4)&work24(4)')
.*-
.* Equate regs and bits
.*-
         push  print
         print &print
&n       seta  0
         aif   (&#modequ).equregn  bits allready set
&#modequ setb  1
.equreg  anop
r&n      equ   &n
&n       seta  &n+1
         aif   (&n le 16).equreg
.equregn anop
         aif   (&iezbits ne 0).equbitn  bits allready set
         IEZBITS
.equbitn anop
*-
* Module start
*-
.*       SYSSTATE OSREL=SYSSTATE,ARCHLVL=OSREL
*-
&mlbl    amode 31
&mlbl    rmode any
&mlbl    &Csect
         bakr  14,0
*setup base register(s)
         lr    &base1,r15
         using &mlbl,&base1
         aif   (n'&base eq 1).basen
         lr    &base(2),&base(1)
         alfi  &base(2),4096
         using &mlbl.+4096,&base(2)
         aif   (n'&base eq 2).basen
         lr    &base(3),&base(2)
         alfi  &base(3),4096
         using &mlbl.+8192,&base(3)
.basen   anop
         j     &l.idn
&dt      setc  '&sysclock'(1,16)       YYYY-MM-DD HH:MM
         aif   (k'&text eq 0).id
&n       seta  k'&text
&s       setc  '&text'(2,&n-2)
&mlbl._id dc    c'&mlbl&ver &dt &s'
         ago   .idl
.id      anop
&mlbl._id dc    c'&mlbl&ver &dt'
.idl     anop
&mlbl._idl equ   *-&mlbl._id
&l.idn   ds    0a
.*-
.* get working storage
.*-
         aif   ('&worksz' eq '').workn
&workloc setc  '31'
         aif   (k'&work24 eq 0).wrklocn
&workloc setc  '24'
.wrklocn anop
         mnote *,'obtain storage, length=&worksz,loc=&workloc'
         Storage OBTAIN,length=&worksz,loc=&workloc
         aif   (k'&workrg eq 0).workn
         lr    &workrg,r1
.* clear storage
         aif   ('&workclr' ne 'C').clrstrn
         lr    r0,r1                   target
         lgfi  r1,&worksz              target length
         la    r14,=al1(0)             source
         la    r15,1                   source length
         mvcl  r0,r14                  clear storage
.clrstrn anop
.*
         aif   (k'&worklb eq 0).workn
         using &worklb,&workrg
.workn   anop
.*-
.* setup save area
.*-
         aif   (k'&sa eq 0).saven
*setup save area
         aif   ('&sa '(1,1) eq '*').saveint
         la    r13,&sa
         ago  .saven
.saveint cnop  0,4
&s       setc  '1'
&n       seta  k'&sa
         aif   (&n eq 1).savein2
&s       setc  '&sa'(2,&n-1)
.savein2 bas   r13,*+(&s*72)+4         address internal save area
         ds    (&s*18)a                internal save area
.saven   anop
.*-
.* setup prolog
.*-
         aif   (k'&prolog ne 0).prologl
         aif   (k'&xprolog ne 0).prologv
         ago   .prologn
.prologl larl  r15,&prolog             prolog address
         ago   .prologc
.prologv l     r15,=v(&xprolog)        prolog address
.prologc basr  r14,r15                 call prolog
.prologn anop
         j     &l.X
.*-
.* setup termination
.*-
* module termination
&mlbl._X cnop  0,4
.*-
.* setup epilog
.*-
         aif   (k'&epilog eq 0 and k'&xepilog eq 0).epilogn
         lr    r2,r15                  copy rc
         aif   (k'&epilog ne 0).epilogl
         aif   (k'&epilog ne 0).epilogl
         aif   (k'&xepilog ne 0).epilogv
         ago   .epilogn
.epilogl larl  r15,&epilog             epilog address
         ago   .epilogc
.epilogv l     r15,=v(&xepilog)        epilog address
.epilogc basr  r14,r15                 call epilog
.epilogn anop
         aif   ('&worksz' eq '').xworkn
         mnote *,'release storage, length=&worksz,addr=&workrg'
         lr    r2,r15
         Storage RELEASE,length=&worksz,addr=(&workrg)
         lr    r15,r2
.xworkn  pr    ,
* end of termination
&l.X     ereg  0,1                     reload regs 0 and 1
*-
* End of module start
*-
         pop   print
         Mexit
.*-
.* return
.*-
.end     anop
&s       setc  '&syslist(2)'
&mlbl    $la   r15,&rc,&s,0
         j     &#modname._X
         Mend
.* ADD NAME=CLEAR
         MACRO
&LBL     CLEAR &A=,&C=C' ',&L=
         LCLC  &LEN,&ADDR
&ADDR    SETC  '&A'
         AIF   (K'&A GT 0).SETL
&ADDR    SETC  '&SYSLIST(1)'
.SETL    ANOP
&LEN     SETC  'L''&ADDR.-1'
         AIF   (K'&L EQ 0).L0900
&LEN     SETC  '&L-1'
.L0900   ANOP
&LBL     MVI   &ADDR,&C
         MVC   &ADDR+1(&LEN),&ADDR
         MEND
.* ADD NAME=STRC2X
         MACRO
.*-
.* This routine  converts each byte from  an input area to  an output
.* area in dump  format, so that one byte in  input is represented by
.* two bytes in output.
.*
.* ex. input x'C1' output x'C3F1'
.*
.* Syntax
.*   STRC2X FROM=(addrÝ,length¨),TO=addrÝ,LEN=length¨Ý,CSECT=Y|n¨
.*        addr      label, (reg) or F.label
.*        length    value, (reg) or F.label. Default is length of addr
.*        LEN=      is an alternative to using 2nd operand of FROM=
.*        CSECT=N   will generate straight code, no subroutine call
.*        SETLEN=Y  set r0 = output length at termination if CSECT=Y
.*
.* If CSECT=Y then the macro calls an internally generated
.* subroutine. This shortens the code length for multiple
.* executions of STRC2B, though adds a bit to the program
.* complexity.
.*
.* Registers 14, 15, 0 and 1 are used in the macro proper
.*
.* Returns the output length in r0 if CSECT=Y
.*
.* Sample, converting 4 bytes of hex value
.*           StrC2X from=(xvalue,4),to=result
.*  xvalue   dc    x'2cabc1c94298f0f1fa'
.*  result   dc    cl(l'cvalue)' '
.*
.* Author
.*     Willy Jensen
.*     mail: willy@harders-jensen.com
.*     web : http://harders-jensen.com/wjtech
.*-
&name    StrC2X &from=,&to=,&len=,&csect=Y,&setlen=Y
         lclc  &l,&s,&csct,&sloc
         gblb  &$STRC2X
         gblc  &$lalenc
&l       setc  'C2X&sysndx'
         aif   (k'&from eq 0).parmmiss
         aif   (k'&to eq 0).parmmiss
&csct    setc  upper('&csect')
         aif   ('&csct'(1,1) eq 'Y').csect1
.* setup for direct execution
         $la   r14,&from(1)
         $la   r15,&from(2),&len,&$lalenc
         $la   r1,&to
         ago   .go
.* setup for subroutine call
.csect1  anop
.*call
.*- make call to module
         $la   r15,&from(1)
         $la   r0,&from(2),&len,&$lalenc
         $la   r1,&to
         l     r14,=v(ZSTRC2X)
         basr  r14,r14
.* StrC2X as module
         aif   (&$STRC2X).x            already done
&$STRC2X setb  1
&sloc    setc  '&sysloc'
ZSTRC2X  Amode 31
ZSTRC2X  Rmode any
ZSTRC2X  CSECT
         stm   r14,r2,12(r13)
         basr  r2,0
         ahi   r2,-6
         push  using
         using ZSTRC2X,r2
.*setup
         lm    r14,r0,16(r13)          from-addr, from-len, to-addr
         lr    r1,r0                   to-addr to r1
.* this is where it happens
.go      anop
         sr    r0,r0
.* upper nibble
&l.a     ic    r0,0(r14)               insert into workreg one byte
         srl   r0,4                    shift last four bit away
         ahi   r0,240
         cfi   r0,x'fa'                nibble gt 9?
         jl    *+8
         ahi   r0,-57                  then use C'A'-C'F'
         stc   r0,0(r1)
.* lower nibble
         ic    r0,0(r14)               insert into workreg one byte
         sll   r0,28                   leave
         srl   r0,28                     lower nibble
         ahi   r0,240
         cfi   r0,x'fa'                nibble gt 9?
         jl    *+8
         ahi   r0,-57                  then use C'A'-C'F'
         stc   r0,1(r1)
.* next
         la    r1,2(,r1)
         la    r14,1(,r14)
         bct   r15,&l.a
         aif   ('&csct'(1,1) ne 'Y').x
.* end
         l     r0,20(,r13)
         sll   r0,1
         l     r14,12(r13)
         l     r2,28(r13)
         bsm   0,r14
         drop  r2
         pop   using
&sloc    Loctr                         resume main
         Mexit
.PARMMIS ANOP
         mnote 12,'Error, parameter(s) missing.'
         Mexit
.x       MEND
.* ADD NAME=STRMAKE
         Macro
.* ------------------------------------------------------------------ *
.*                                                                    *
.* StrMake                                                            *
.*                                                                    *
.* Build a string from literals and fields. Specific position and     *
.* skips are also possible.                                           *
.*                                                                    *
.* Syntax                                                             *
.*                                                                    *
.*  STRMAKE fld,.,pos,.,fld,REG=R14|posreg,LR=lenreg,PRINT=print      *
.*                                                                    *
.*    fld   (field,length,conversion,out-length)                      *
.*          length, conversion and out-length are optional.           *
.*                                                                    *
.*          field         label, (reg), literal, f.address            *
.*          length        value, (reg), f|h|b.address                 *
.*          conversion                                                *
.*            C2B         storage -> binary c'0' and c'1'             *
.*            CVD  | C2D  storage -> dec                              *
.*                        in-length and out-length are reqd           *
.*            CVDR        register -> dec                             *
.*                        out-length is required                      *
.*            CVXD | C2X  hex-> dec, i.e. x'1A' -> c'F1C1'            *
.*            UNPK | P2D  packed dec i.e. x'0123C' -> c'123'          *
.*            ST          store register asis (using STCM)            *
.*            STH         store half of register asis (using STCM)    *
.*                        out-length is required                      *
.*          out-length    value, (reg), f|h|b.address                 *
.*          pos           position in string                          *
.*                        +n  skip n positions forward                *
.*                        -n  skip n positions backward               *
.*                        =n  position at n                           *
.*                        =B  position at next blank                  *
.*                                                                    *
.*    posreg        register pointing to the end of the               *
.*                  generated string. Default is R14.                 *
.*    lenreg        register set to length of string                  *
.*    print         print macro option OFF or NOGEN.                  *
.*                                                                    *
.* Registers 14, 15, 0 and 1 may be used internally as work regs, so  *
.* the 'reg' value should not be any of those.                        *
.*                                                                    *
.* Conversion sub-functions typically uses the save are for storing   *
.* intermediate values, so a save area must be available.             *
.*                                                                    *
.* ------------------------------------------------------------------ *
&mlbl    StrMake &reg=R14,&print=,&lenck=N,&lenreg=,&lr=
         aif   (k'&mlbl eq 0).mlbl2
&mlbl    ds    0h
.mlbl2   anop
         aif   (k'&print eq 0).pr1n
         push  print
         print &print
.pr1n    anop
         lcla  &pix,&litl,&incr,&n,&mvcn
         lclc  &str,&fld,&srcl,&cnv,&src,&srcu,&tgt,&tgtl,&s,&lbl,&outl
         lclc  &mask,&lb1,&r,&lm(4),&unpkadr,&strl
         gblc  strmakea,strmakel,&strp2dl
&lm(1)   setc  '1'
&lm(2)   setc  '3'
&lm(3)   setc  '7'
&lm(4)   setc  '15'
.*
.* output string address
.*
&str     setc  '&syslist(1,1)'
         aif   ('&str' eq '*').setstrn
         aif   (k'&str eq 0).setstrn
         $la   &reg,&str               ->str
&strl    setc  '&syslist(1,2)'
         aif   (k'&strl ne 0).strl2
&strl    setc  'l''&str'
.strl2   anop
&strmakea setc '&str'                  remember address
&strmakel setc '&strl'                 remember length
.setstrn anop
.*-
.* do over parmlist
.*-
&pix     seta  1
.scan    anop
&lbl     setc  'SM&sysndx.#&pix'
&pix     seta  &pix+1
         aif   (&pix gt n'&syslist).quit
&src     setc  '&syslist(&pix,1)'
&srcu    setc  (UPPER '&src')
&srcl    setc  '&syslist(&pix,2)'
         aif   (k'&srcl ne 0).srcl2
&srcl    setc  'l''&src'
.srcl2   anop
&cnv     setc  (UPPER '&syslist(&pix,3)')
&outl    setc  '&syslist(&pix,4)'
.* junction 1
         aif   ('&src '(1,1) ne '=').tpositn
         aif   ('&src '(2,1) eq '(').posit     position in register
&n       seta  k'&src
&s       setc  '&src'(2,&n-1)
         aif   (t'&s eq 'N').posit
.tpositn anop
         aif   ('&srcu'(1,2) eq '=B').posbl
         aif   (T'&src eq 'N').posit
         aif   ('&src'(1,1) eq '+').skip
         aif   ('&src'(1,1) eq '-').skipb
.* the width check is not very good, but better than nothing
&s       setc  Upper('&lenck ')
         aif   ('&s'(1,1) ne 'Y' and n'&syslist(1) lt 2).lenckn
         $la   r15,&strmakea
         $la   r0,&strmakel
         ar    r15,r0
         $la   r0,&outl,&srcl
         ar    r0,&reg                    -> after insert
         cr    r0,r15
         jl    &lbl.s
         mvi   0(r14),c'+'
&s       setc  'SM&sysndx.Q'
         j     &s
&lbl.s   equ   *
.lenckn  anop
.* width check end
.* junction 2
         aif   ('&src '(1,1) eq '''').lit
         aif   (k'&cnv eq 0).mvc
         aif   ('&cnv' eq 'CVD').c2d      binary to decimal
         aif   ('&cnv' eq 'C2D').c2d              -
         aif   ('&cnv' eq 'CVDR').cvdr    binary in reg to decimal
         aif   ('&cnv' eq 'P2D').p2d      packed dec -> zoned
         aif   ('&cnv' eq 'UNPK').p2d             -
         aif   ('&cnv' eq 'C2B').c2b      byte to readable bits
         aif   ('&cnv' eq 'C2X').c2x      hex to readable hex
         aif   ('&cnv' eq 'CVX').c2x              -
         aif   ('&cnv' eq 'CVXD').c2x             -
         aif   ('&cnv' eq 'ST').st        store register
         aif   ('&cnv' eq 'STH').sth      store register halfword
         mnote 8,'invalid format: &cnv'
         ago   .quit
.*-
.* src is a field
.* 'outl' is max length
.*-
.mvc     anop
         $la   r15,&srcl
         ltr   r15,r15
         jz    &lbl.N                        no data
         aif   (k'&outl eq 0).mvc2
         $la   r0,&outl
         ltr   r0,r0                         zsro => no check
         jz    &lbl.cf1
         cr    r15,r0
         jnh   &lbl.cf1
         lr    r15,r0
.mvc2    anop
&lbl.cf1 cfi   r15,256
         jh    &lbl.l                        long string
         bctr  r15,0
         $la   r1,&src
         mvc   0(*-*,&reg),0(r1)
         ex    r15,*-6
         la    &reg,1(r15,&reg)
         j     &lbl.n
&lbl.l   equ   *
         stm   r14,r15,12(r13)
         lr    r0,&reg                       -> target
         $la   r14,&src                      -> source
         lr    r1,r15                        copy length
         mvcl  r0,r14
         lm    r14,r15,12(r13)
         ar    &reg,r15
&lbl.n   equ   *
         ago   .scan
.*-
.* Convert hex value in register to decimal
.*-
.cvdr    anop                               source is register
         cvd   &src,16(r13)
         unpk  0(&outl,&reg),16(8,r13)
         oi    &outl-1(&reg),x'f0'
         la    &reg,&outl.(,&reg)
         ago   .scan
.*-
.* Convert hex in string to decimal
.*-
.c2d     anop
         st    &reg,68(,r13)               save pos
         lr    r0,&reg                     preserve r14
         StrC2d call,from=(&src,&srcl),to=((r0),&outl)
         l     &reg,68(,r13)               load pos
         ar    &reg,r0
         ago   .scan
.*-
.* packed dec field
.*-
.p2d     anop                              packed dec
         st    &reg,68(,r13)               save pos
         lr    r0,&reg
         StrP2D call,from=(&src,&srcl),to=((r0),&outl)
         l     &reg,68(,r13)               load pos
         ar    &reg,r0
         ago   .scan
.*-
.* hex-to-char
.*-
.c2x     anop
         st    &reg,68(,r13)               save pos
.* preserve r14
         lr    r1,&reg                     to addr
.*  r14=from,r15=to,r0=len
         StrC2X call,from=(&src,&srcl),to=(r1),setlen=Y
         l     &reg,68(,r13)               load pos
         ar    &reg,r0                     update pos
         ago   .scan
.*-
.* byte to bits
.*-
.c2b     anop
         st    &reg,68(,r13)               save pos
         StrC2B call,from=&src,to=(&reg)
         l     &reg,68(,r13)               load pos
         la    &reg,8(,&reg)
         ago   .scan
.*-
.* literal
.*-
.lit     anop
         aif   (k'&src eq 3).lit100        one char
&litl    seta  k'&src-2
         mvc   0(&litl,&reg),=c&src
         la    &reg,&litl.(,&reg)
         ago   .scan
.lit100  anop
         mvi   0(&reg),c&src
         la    &reg,1(,&reg)
         ago   .scan
.*-
.* store register
.*-
.st      anop
         stcm  &src,15,0(&reg)
         la    &reg,4(,&reg)
         ago   .scan
.*-
.* store lower half of register
.*-
.sth     anop
         stcm  &src,3,0(&reg)
         la    &reg,2(,&reg)
         ago   .scan
.*-
.* skip
.*-
.skip    anop
&s       setc  '&src'(2,k'&src-1)
         ahi   &reg,&s
         ago   .scan
.skipb   anop
&s       setc  '&src'(2,k'&src-1)
         ahi   &reg,-&s
         ago   .scan
.*-
.* position pointer in string
.*-
.posit   anop
&c       setc  '&src'(2,k'&src-1)
.*       la    &reg,&strmakea+&c-1
         $la   &reg,&strmakea
         $la   r15,&c
         bctr  r15,0
         ar    &reg,r15
         ago   .scan
.*-
.* position at next blank
.*-
.posbl   anop
         cli   0(&reg.),c' '
         bne   *+8
         bct   &reg.,*-8
         la    &reg.,1(,&reg.)
         ago   .scan
.*-
.* end of macro
.*-
.quit    anop
&r       setc  '&lenreg&lr'
         aif   (k'&r eq 0).lenregn
         $la   r0,&strmakea
.*       sr    r14,r0
.*       lr    r0,r14                    copy gend length
         lr    &r,r14
         sr    &r,r0                     set length
.lenregn anop
         aif   (k'&print eq 0).pr2n
         pop  print
.pr2n    anop
&s       setc  'SM&sysndx.Q'
&s       ds    0h
         Mend
.* ADD NAME=$CVD
         MACRO
.*
.* Convert value in register to decimal string
.*
.* Syntax
.*   $CVD addr,REG=reg,LEN=len
.*   $CVD reg,addrÝ,len¨
.*        addr must be a address or a register (r)
.*
         $CVD  &REG=,&LEN=
         lclc  &dest,&ln,&r,&t
         lcla  &n
.*
&ln      setc  '&len'
         aif   (n'&syslist ge 2).parm2
&r       setc  '&reg'
&dest    setc  '&syslist(1)'
         ago   .parmend
.parm2   anop
&r       setc  '&syslist(1)'
&dest    setc  '&syslist(2)'
         aif   (k'&len gt 0).parmend
&ln      setc  '&syslist(3)'
.parmend anop
.* t'dest = C if address, U if register (r)
.*
         aif   (k'&r eq 0).regmiss
         aif   (k'&ln gt 0).lnn
&ln      setc  '4'
.lnn     anop
         cvd   &r,56(r13)
         aif   ('&dest'(1,1) eq '(').destr
         unpk  &dest.(&ln),56(8,r13)
         oi    &dest+&ln-1,x'f0'
         mexit
.destr   anop
&n       seta  k'&dest-2
&dest    setc  '&dest'(2,&n)
         unpk  0(&ln,&dest),56(8,r13)
         oi    &ln-1(&dest),x'f0'
         mexit
.regmiss mnote  8,'*** error - missing register spec'
         mexit
         MEND
.* ADD NAME=#MODEND
         Macro
.*
.* companion to #MODULE, set rc and jump to termination routine
.*
&mlbl    #MODEND &rc=
&mlbl    #MODULE END,RC=&rc&syslist(1)
         Mend
.* ADD NAME=#SUBR
         Macro
.*-
.* Subroutine infrastructure
.*
.* Syntax
.*   label SUBR action,parameters
.*
.*   Action description
.*     CSECT | LABEL   subroutine start
.*     EXIT | END      subroutine return
.*     DROP            drop registers, do ltorg
.*     CALL            call subroutine
.*     SET             set defaults
.*     EREG            restore regs 0 and 1 (simulate EREG instr)
.*
.*   Note - for each CSECT there must be a DROP later
.*
.* Some defaults can be changed by the #SUBR SET invocation:
.*   base sa saend rcfield entry
.*
.* Changelog
.* 2018-10-27  Rc value for end can be syslist(2) i.e #subr end,123
.* 2018-10-30  Add DROP
.* 2019-10-02  Restructure the handling of multiple base regs
.*             Add PUSH using and POP USING, making DROP neccessary.
.*
.* Sample
.*
.*           #subr call,sub1
.*           . . .
.*  sub1     #subr csect,sa=sa2,xprolog=sub1pro,xepilog=sub1epi
.*           . . .
.*           open  (dcb1,(OUTPUT))
.*           . . .
.*           #subr end,rc=1
.*           . . .
.*           #subr end,rc=2
.*           #subr drop
.*           . . .
.*  sub1pro  #subr csect,base=r6,sa=sa3
.*           . . .
.*           #subr exit
.*           #subr drop
.*           . . .
.*  sub1epi  #subr csect,base=r6,sa=sa3
.*           close dcb1
.*           #subr exit
.*           #subr drop
.*-
&mname   #SUBR &p1,&base=,                                             c
               &sa=,&saend=,&drop=,                                    c
               &prolog=,&epilog=,&xprolog=,&xepilog=,                  c
               &rcfield=,&rc=,&entry=,&upcase=,&print=
.*-
         gblc  &#subrname,&#subrsaend,&#subrbase,&#subrrcfld
         gblc  &#subrentry,&#subrsa,&gblsetp
         gblc  &#modrmod
         gblb  &subrexit
         lclc  &name,&what,&r,&s,&l,&mcsect,&msaend
         lcla  &n
&l       setc  'sx&sysndx'
&name    setc  (UPPER '&mname')
.*-
         GblSetP &p1,&#subrentry,LABEL,upcase=YES,no=NULL
&what    setc  '&gblsetp'
         aif   ('&what' eq 'LABEL').label
         aif   ('&what' eq 'ENTRY').csect
         aif   ('&what' eq 'CSECT').csect
         aif   ('&what' eq 'EXIT').exit
         aif   ('&what' eq 'END').exit
         aif   ('&what' eq 'CALL').call
         aif   ('&what' eq 'EREG').ereg
         aif   ('&what' eq 'DROP').drop
         aif   ('&what' eq 'SET').set
         mnote  8,'**Invalid entry type'
         mexit
.*-
.* Entry label
.*-
.label   anop
         Entry &mname
&mname   cnop  0,4
         stm   14,12,12(r13)
         ago   .start
.*-
.* Entry csect
.*-
.csect   anop
         aif   (k'&print eq 0).csectp1n
         push  print
         print &print
.csectp1n anop
         Push  Using
&name    amode 31
&name    rmode any
.csect2  anop
&name    Csect
         stm   14,12,12(r13)
         aif   (k'&base gt 0).base1
         lr    &#subrbase,r15
         using &name,&#subrbase
         ago   .basen
.*-
.base1   anop
&r       setc '&base(1)'
         lr    &r,r15                set local base
         using &name,&r
         aif   (n'&base eq 1).basen
&s       setc '&base(2)'
         lr    &s,&r
         alfi  &s,4096
         using &name.+4096,&s
         aif   (n'&base eq 2).basen
&s       setc '&base(3)'
         lr    &s,&r
         alfi  &s,8192
         using &name.+8192,&s
.basen   anop
.*-
.start   anop
&#subrname setc '&name'
         j     *+12
&name._id dc    cl8'&name'
&subrexit setb 0
.*-
.* setup save area
.*-
.sa      anop
         GblSetP &sa,&#subrsa,next,upcase=yes,no=NULL
         aif   (k'&gblsetp eq 0).san
         aif   ('&gblsetp' eq 'NEXT').sanxt
         aif   ('&gblsetp' eq '*').sainl
         la    r14,&gblsetp
         ago   .sachn
.sanxt   anop
         la    r14,72(,r13)            -> next sa slot
.* save area check
         GblSetP &saend,&#subrsaend,no=NULL
         aif   (k'&gblsetp eq 0).saendn
         la    r15,&gblsetp            check
         cr    r14,r15                  inside
         jl    *+10                      save
         la    r1,888                     arealist
         svc   13                      or else..
.saendn  anop
         ago   .sachn
.sainl   anop
         cnop  0,4
         bas   r13,*+76
         ds    18a
         ago   .sachn
.* save area chaining
.sachn   anop
         st    r14,8(,r13)             ->
         st    r13,4(,r14)             <-
         lr    r13,r14
.san     anop
.* call prolog
         aif   (k'&prolog ne 0).prologl
         aif   (k'&xprolog ne 0).prologv
         ago   .prologn
.prologl larl  r15,&prolog             prolog address
         ago   .prologc
.prologv l     r15,=v(&xprolog)        prolog address
.prologc basr  r14,r15                 call prolog
.prologn anop
.* end of start
         j     &l.N
.* setup return
&name._X equ  *
.* update rc field
         GblSetP &rcfield,&#subrrcfld,no=NULL
         aif   (k'&gblsetp eq 0).rcfldn
         c     r15,&gblsetp            if rc gt stored
         jl    *+8                      then
         st    r15,&gblsetp              replace stored
.rcfldn  anop
.* call epilog
         aif   (k'&epilog eq 0 and k'&xepilog eq 0).epilogn
         lr    r2,r15                  copy rc
         aif   (k'&xepilog ne 0).epilogv
.epilogl larl  r15,&epilog             epilog address
         ago   .epilogc
.epilogv l     r15,=v(&xepilog)        epilog address
.epilogc basr  r14,r15                 call epilog
.epilogn anop
.* unchain sa and return
         l     r13,4(,r13)             <- prev save
         l     r14,12(r13)             return addr
         lm    2,12,28(r13)
         br    r14
.* continue mainline
&l.N     equ  *
         aif   (k'&print eq 0).csectp2n
         pop   print
.csectp2n anop
         Mexit
.*-
.* Exit
.*-
.Exit    anop
&s       setc  '&syslist(2)'
&name    $la   r15,&rc,&s,0
         j     &#subrname._X
&s       setc  '&drop '(1,1)
         aif   ('&s' ne 'Y').x
         #subr drop
         Mexit
.*-
.* Call
.*-
.Call    anop
&name    setc  '&syslist(2)'
         l     r15,=V(&name)
         basr  r14,r15
         ltr   r15,r15
         Mexit
.*-
.* Ereg - restore regs 0 and 1 (simulate EREG instr)
.*-
.Ereg    anop
         l     r1,4(,r13)              <- old sa
         lm    r0,r1,20(r1)            reload
         Mexit
.*-
.* Drop #subr basereg
.*-
.Drop    anop
         ltorg
.*       drop  &#subrbase
         Pop   Using
         Mexit
.*-
.* Set globals
.*-
.Set     anop
&#subrbase  setc '&base'
&#subrsa    setc '&sa'
&#subrsaend setc '&saend'
&#subrrcfld setc '&rcfield'
&#subrentry setc '&entry'
         Mexit
.*-
.x       Mend
.* ADD NAME=#SUBREND
         Macro
.*
.* companion to #SUBR, set rc and execute #SUBR termination
.*
&mlbl    #SUBREND &rc=
&mlbl    #SUBR END,RC=&rc&syslist(1)
         Mend
.* ADD NAME=CDEUCTZ2
         Macro
.*
.* Bump program use count (IHACDE CDUSE) to keep program in JPAQ.
.* This will improve performance of an often loaded program
.* significantly.
.* For reentrant and optionally serially reusable programs.
.*
.* Syntax
.*
.*  label  CDEUCTZ2 ÝBASE=reg¨Ý,SER=Y¨Ý,DSECT=N¨Ý,PRINT=OFF|NOGEN¨
.*         reg       Basereg for main module. Default is determined
.*                   basereg when macro is expanded.
.*         SER=Y     Change uct for serially reusable module too.
.*         DESCT=N   Do not include DSESCTs in the macro expansion.
.*                   The DSECTs are
.*                      IKJTCB DSECT=YES
.*                      IHAPSA DSECT=YES
.*                      IHACDE
.*         PRINT=    Print option for DSECT expansions.
.*                   Default is NOGEN.
.*
.* Sample
.*
.*         YREGS
.*   A     Csect
.*         bakr  r14,r0
.*         lr    r9,r15
.*         Using A,r9
.*         CDEUCTZ2
.*
.* Performance
.*
.*  A small performance  test when CDEUCTZ2 is used in  a program run
.*  in  an REXX  exec  to scan  36  records 100  times  for a  match.
.*   The  program is  RXPATTRN  and  can be  found  at  the web  site
.*  mentioned below.
.*
.*                        EXCP   CONN    TCB
.*  CDEUCTZ2 disabled     7284      0   1.35
.*  CDEUCTZ2 enabled        90      0    .09
.*  Running from LPA        51      0    .14
.*
.* Author
.*     Willy Jensen
.*     mail: willy@harders-jensen.com
.*     web : http://harders-jensen.com/wjtech
.*-
&ml      CDEUCTZ2 &base=*,&wto=N,&ser=N,&dsect=Y,&print=NOGEN
         lclc  &l,&s,&br
&l       setc  'CT&sysndx'
         using tcb,r14
         using cdentry,r15
&ml      l     r14,psatold-psa(0,0)    -> my tcb
         l     r14,tcbjstcb            job-step tcb
         l     r15,tcbjpq              my cde
         drop  r14                     TCB
         cli   cduse+1,1               first time through?
         jne   &l.999                  no, jump
&s       setc  Upper('&ser')
         aif   ('&s '(1,1) ne 'Y').cdattrr
         tm    cdattr,cdren+cdser      reentrant or reuseable ??
         ago   .cdattrn
.cdattrr tm    cdattr,cdren            reentrant ??
.cdattrn anop
         jz    &l.999                  no, jump
.* do basereg test
         aif   ('&base' ne '*').base2  specific base (we hope)
         j     &l.e
&l.C     c     r0,cdentpt              executed, check cde
&l.D     dc    sl2(*)                  basereg + offsett
&l.E     sr    r1,r1
         ic    r1,&l.d                 load basereg+offsett
         srl   r1,4                    leave basereg
         sll   r1,4                    for execute
         ex    r1,&l.c                 check base against cdentpt
         ago   .base3
.base2   c     &base,cdentpt           my cde?
.base3   jne   &l.999                  no, jump
.* all seems ok, do load
         load  eploc=cdname            bump my own use count
         drop  r15                     CDE
&s       setc  Upper('&wto')
         aif   ('&s' ne 'Y').wton
         wto   'use count bumped'      for debugging
.wton    anop
&l.999   equ   *
.* dsects
&s       setc  Upper('&dsect')
         aif   ('&s' ne 'Y').dsectn
*dsects
&s       setc  '&sysect'
         Push  print
         Print &print
         gblb  &$DSCT_IKJTCB,&$DSCT_IHAPSA,&$DSCT_IHACDE
         aif   (&$DSCT_ikjtcb).dsect2
         IKJTCB DSECT=YES
&$DSCT_IKJTCB setb 1
.dsect2  aif   (&$DSCT_IHAPSA).dsect3
         IHAPSA DSECT=YES
&$DSCT_IHAPSA setb 1
.dsect3  aif   (&$DSCT_IHACDE).dsect4
         IHACDE
&$DSCT_IHACDE setb 1
.dsect4  Pop  print
*dsects end
&s       Csect
.dsectn  anop
.*-
.x       Mend
.* ADD NAME=CLRLONG
         Macro
         ClrLong
.* clear up to 16M storage area
.* operand 1 -> target
.* operand 2 =  target size
.* operand 3 =  pad chr, optional, defalt is x'00'
         lclc  &pad
         gblc  &$lalenc
         $la   r0,&syslist(1)          address
         $la   r1,&syslist(2),l'&syslist(1)
         sr    r14,r14                 null source
         sr    r15,r15                 null source length
         aif   (n'&syslist lt 3).padn
&pad     setc  '&syslist(3)'
         la    r15,&pad
         sll   r15,24
.padn    anop
         mvcl  r0,r14                  clear
         Mend
.* ADD NAME=ESTAEXX
         Macro
.*-
.*
.* Extended ESTAE - recover system and user abends
.*
.* Syntax
.*   ESTAEXX action,ADDR=reta
.*    action  A | ACTVATE  Activate intercept, SETADDR required
.*            C | CANCEL   Stop intercept
.*            S | SET      Set retaddr
.*            DS           Data area
.*          ( R | RESET    Reset retaddr and regs to initial - future)
.*    reta    address of where to continue after intercept
.*
.*    Note, ACTIVATE, SET and RESET will save all registers, they
.*    are restored to this value when the recovery routine is
.*    invoked.
.*
.*  Sample
.*
.*             Estaexx activate,retaddr=recover
.*             . . .
.*             Estaexx set,retaddr=rcv0c1
.*             . . .
.*             dc    X'0000'
.*    rcv0c1   ds    0a                  estae re
.*             ESTAEXX cancel
.*             . . .
.*    recover  ds    0h                  estae retry routine
.*             ESTAEXX cancel
.*             . . .
.*             Estaexx ds
.*
.* History
.* 2019-10-07  Initial
.* 2019-10-12  Add field estxtext for formatted abend info
.*-
&mlbl    ESTAEXX &addr=,&retaddr=,&print=nogen,&dsect=Y
         lclc  &c,&p,&s,&l,&lbl,&csct,&addrp
&addrp   setc  '&addr&retaddr'     allow both operands
         gblb  &estaexx
&l       setc  'ZE&sysndx'
&p       setc  Upper('&syslist(1)')
         aif   ('&p' eq 'DS').ds
         aif   (&estaexx).modtn
&estaexx setb  1
         j     &l.md
         ago   .mod
.moddone anop
&l.md    cnop  0,4
.modtn   anop
&p       setc  Upper('&syslist(1)')
         aif   ('&p' eq 'A' or '&p' eq 'ACTIVATE').act
         aif   ('&p' eq 'C' or '&p' eq 'CANCEL').can
.*       aif   ('&p' eq 'R' or '&p' eq 'RESET').res
         aif   ('&p' eq 'S' or '&p' eq 'SET').set
         mnote 8,'**Invalid or missing action'
         mexit
.*- Activate
.act     anop
&mlbl    mvc   estxeye,=c'ESTX'
         mvi   estxdone,c'N'
         la    r15,&addrp
         st    r15,estxreta        current return address
         stm   r0,r15,estxregs     save all registers
.*       st    r15,estxreto        original return address
.*       stm   r0,r15,estxrego     save all registers
         l     r15,=v(zEstxmod)
         ESTAEX (r15),CT,param=estxblk,mf=(E,estxmfl)
         mexit
.*- Cancel
.can     anop
&mlbl    lt    r15,estxreta
         jz    &l.b
         ESTAEX 0
&l.b     xc    estxreta,estxreta
         mexit
.*- Set return address
.set     anop
&mlbl    la    r15,&addrp
         st    r15,estxreta        current return address
         stm   r0,r15,estxregs     save all registers
         mexit
.*- Reset return address
.res     anop
&mlbl    mvc   estxreta,estxreto   restore retry addr
         mvc   estxregs,estxrego   restore registers
         mexit
.*- Data area
.ds      anop
estxblk  ds    0a
estxeye  ds    cl4                 'ESTX'
estxdone ds    c                   prevent loop
estxmfl  ESTAEX ,MF=L              data list
estxmfll equ   *-estxmfl
estxcode ds    a
estxsys  equ   estxcode,2          system abend
estxusr  equ   estxcode+2,2        user abend
estxrsn  ds    a
estxname ds    cl8                 pgm name
estxpsw  ds    xl8                 ec mode psw
estxreta ds    a                   current return address
estxregs ds    16a                 save registers
.*txreto ds    a                   return address at activate
.*txrego ds    16a                 save registers
estxtext ds    cl16                formatted abend info
.* test model
.* ----+----1----+----2----+----3----+----4----+----5----+
.* S0C1 00CF6618    GO       078D00009E80025A
         mexit
.*- Recovery routine
.mod     anop
         ltorg
*-
*  ESTAEXX recovery routine
*-
&sect    setc  '&sysloc'
 mnote *,'ESTAEXX mod - sysloc: &sect'
         push  using
         drop  ,
zEstxmod amode 31
zEstxmod rmode any
zEstxmod Csect
         push  print
         print &print
         using zEstxmod,r15        map code page for estxe recrtn
         cfi   r0,12               sdwa exist ?
         jne   zEstxmgo            yes, go on
         wto   'no SDWA'
         sr    r15,r15             rc=0 => continue with error
         br    r14
* SDWA provided
zEstxmgo save (14,12)
         lr    r5,r15              copy estae rec rtn epa to base
         drop  r15
         using zEstxmod,r5         map code page for estxe recrtn
         lr    r3,r1               copy sdwa ptr
         using SDWA,r3             map sdwa
.*       wto   'Estx-recov'
         using estxblk,r2
         clc   =c'ESTX',estxeye
         jne   zEstxmne
         cli   estxdone,c'Y'
         je    zEstxm2t
.*       mvi   estxdone,c'Y'
* save abend and reason codes and info
         l     r15,SDWAABCC
         sll   r15,8
         srl   r15,20
         sth   r15,estxsys
         l     r15,SDWAABCC
         sll   r15,20
         srl   r15,20
         sth   r15,estxusr
         l     r1,SDWAXPAD         -> SDWAPTRS
         l     r1,0(,r1)           -> SDWARC1
         mvc   estxrsn,SDWACRC-SDWARC1(r1) copy reason code
         lt    r1,estxrsn          was there a code?
         jnz   *+10                yes
         mvc   estxrsn,SDWAGR15    else use r15
         mvc   estxname,=cl8' '
         cli   SDWANAME,x'00'
         je    *+10                not a valid name
         mvc   estxname,SDWANAME   pgm name
         mvc   estxpsw,SDWAEC1     extended mode psw
* build readable abend text
         mvi   estxtext,c' '
         mvc   estxtext+1(l'estxtext-1),estxtext
         la    r7,c'S'
         la    r14,estxsys
         icm   r1,3,estxusr            user abend?
         jz    *+12                    yes
         la    r7,c'U'
         la    r14,estxusr
         la    r15,2                   input length
         la    r1,estxtext
         bal   r9,zEstxmxd
         stc   r7,estxtext
* build readable reason code
         la    r14,estxrsn
         la    r15,4
         la    r1,estxtext+5
         bal   r9,zEstxmxd
.* * get name and psw
.*          mvc   estxtext+17(8),estxname
.*          la    r14,estxpsw
.*          la    r15,8                   input length
.*          la    r1,estxtext+26
.*          bal   r9,zEstxmxd
* recover/retry
         mvc   SDWASRSV,estxregs   restore regs 0-15
         lr    r1,r3               -> SDWA
         l     r4,estxreta
         SETRP RETADDR=(r4),       retry routine                       c
               RC=4,               request retry                       c
               REMREC=NO,          remove this intercept YES/NO        c
               FRESDWA=YES,        free the sdwa storage               c
               WKAREA=(r3),        sdwa                                c
               RECORD=YES,DUMP=NO, record error to logrec              c
               RETREGS=YES
         j     zEstxmx
* do not recover
zEstxmne wto   'eye not found'
         j     zEstxmsr
zEstxm2t wto   '2nd time around'
zEstxmsr lr    r1,r3               -> SDWA
         SETRP RC=0,               do not retry                        c
               WKAREA=(r3),        sdwa                                c
               RECORD=NO,DUMP=NO,  no recording                        c
               RETREGS=NO
zEstxmx  l     r14,12(,r13)
         sr    r15,r15             request no-retry
         return (2,12)             return from recovery rtn
         ltorg
* subroutine, convert binary to printable. return via r9
zEstxmxd ds    0h
         sr    r0,r0
.* upper nibble
         ic    r0,0(r14)               insert into workreg one byte
         srl   r0,4                    shift last four bit away
         ahi   r0,240
         cfi   r0,x'fa'                nibble gt 9?
         jl    *+8
         ahi   r0,-57                  then use C'A'-C'F'
         stc   r0,0(r1)
.* lower nibble
         ic    r0,0(r14)               insert into workreg one byte
         sll   r0,28                   leave
         srl   r0,28                     lower nibble
         ahi   r0,240
         cfi   r0,x'fa'                nibble gt 9?
         jl    *+8
         ahi   r0,-57                  then use C'A'-C'F'
         stc   r0,1(r1)
.* next
         la    r1,2(,r1)
         la    r14,1(,r14)
         bct   r15,zEstxmxd+2
         br    r9
         pop   using
.*
&s       setc  Upper('&dsect')
         aif   ('&s' ne 'Y').dsctn
         IHASDWA
.dsctn   anop
         pop   print
&sect    loctr
         ago   .moddone
.*- End
.x       Mend
.* ADD NAME=GBLSETP
         Macro
         GblSetP &no=,&upcase=,&listval=
.* Set a global variable to the first non-blank parameter
.* This is an called macro (subroutine).
.* syntax: parm1,parm2,..,parmn
.*
.* Sample:
.*         Macro
.*         TestSetP &anchor=
.*         gblc  &gblsetp
.*         lclc  &lanchr
.*         GblSetp &anchor,&anchor,*
.*         Mend
.*         TestSetP     -> &gblsetp='*'
.*         TestSetP f1  -> &gblsetp='f1'
.*
         gblc  &gblsetp
         lcla  &n
         lclc  &p,&s
&pupper  setc  Upper('&upcase')
&n       seta  1
.gblset1 anop
&gblsetp setc  '&syslist(&n)'
         aif   (k'&gblsetp ne 0).gblset2
&n       seta  &n+1
         aif   (&n le n'&syslist).gblset1
         mexit
.gblset2 anop
&s       setc  Upper('&upcase')
         aif   ('&s '(1,1) ne 'Y').gblset3
&gblsetp setc  Upper('&gblsetp')
.gblset3 anop
&s       setc  Upper('&no')
&p       setc  Upper('&gblsetp')
         aif   ('&p' ne 'NO' or '&s' ne 'NULL').gblset4
&gblsetp setc  ''
.gblset4 anop
         aif   ('&listval' ne 'y' and '&listval' ne 'Y').gblset5
         mnote *,'gblsetp value=&gblsetp'
.gblset5 anop
         mexit
.*-
.x       Mend
.* ADD NAME=MVLIT
         MACRO
&lbl     MVLIT &A,&T,&LR=,&lenreg=,&LA=
.* move literal to area
.*  lr : load text length to register
.*  la : load register with address of end of text
         aif   (k'&t eq 0).nullp
         lcla  &tl
&tl      seta  (k'&t)-2
&lbl     mvc   &a.(&tl),=c&t
         aif   (k'&lr eq 0 and k'&lenreg eq 0).lrn
         la    &lr&lenreg,&tl
.lrn     anop
         aif   (k'&la eq 0).lan
         la    &la,&a+&tl
.lan     mexit
.nullp   anop
         aif   (k'&lbl eq 0).x
&lbl     ds    0h
.x       MEND
.* ADD NAME=NTSERVX
         Macro
&mlbl    NTSERVX &what,&pl=,&rc=,                                      c
               &level=,&l=,&persist=,&p=,&name=,&n=,&token=,&t=
.*  see MVS Programming: Authorized Assembler Services Reference,
.*  volume 2 - (EDTINFO-IXGWRITE) for details of the IEANTxx i/f.
.*  Amode 31 is required for the call method used in this macro.
.*
.*  Retrieve may  use the  caller's save  area as  work area,  see the
.*  retrieve  section  for details.  The  token  is then  returned  in
.*  registers 1-4.
.*   Note that this  is only valid if caller's registers  5-9 have not
.*  yet been modified.
.*
.*  IEANT_NOPERSIST         EQU     0
.*  IEANT_PERSIST           EQU     1
.*  IEANT_TASK_LEVEL        EQU     1
.*  IEANT_HOME_LEVEL        EQU     2
.*  IEANT_PRIMARY_LEVEL     EQU     3
.*  IEANT_SYSTEM_LEVEL      EQU     4
.*  IEANT_TASKAUTH_LEVEL    EQU    11
.*  IEANT_HOMEAUTH_LEVEL    EQU    12
.*  IEANT_PRIMARYAUTH_LEVEL EQU    13
.*
.* Changelog
.*  2018-10-25 change PL=SA to use SA+40 (r5-r9) and return token
.*             in r1-r4.
.*  2019-10-22 short forms of name, level, token and persist parms
.*
         lclc  &u,&lbl,&ofs,&$csect,&$pl,&$token,&$rc,&$what
         lclc  &$level,&$pers,&$plsave
&lbl     setc  'NTX&sysndx'
&$csect  setc  '&sysect'
&u       setc  Upper('&what')
         aif   ('&u' eq 'PL').pl
&$token  setc  '&token.&t'
&$rc     setc  '&rc'
.*
.*- level
&u       setc  Upper('&level.&l.H '(1,1))
&$level  setc  '1'
         aif   ('&u' eq 'T').lvlok
&$level  setc  '2'
         aif   ('&u' eq 'H').lvlok
&$level  setc  '3'
         aif   ('&u' eq 'P').lvlok
&$level  setc  '4'
         aif   ('&u' eq 'S').lvlok
         mnote '8,'** Invalid level, must be T, H, P or S'
         mexit
.lvlok   anop
.*- persist
&u       setc  Upper('&persist.&p.N '(1,1))
&$pers   setc  '1'
         aif   ('&u' eq 'Y').persok
&$pers   setc  '0'
         aif   ('&u' eq 'N').persok
         mnote  8,'** Invalid persist, must ne Y or N'
         mexit
.persok  anop                          IEANT_PERSIST
.*- what
&$what   setc  Upper('&what')
         aif   ('&$what' eq 'CR').cr
         aif   ('&$what' eq 'RT').rt
         aif   ('&$what' eq 'DL').dl
         mnote 8,'invalid entry: &what'
         mexit
.* -- create
.CR      ANOP
         aif   (k'&$token ne 0).cr2
         mnote 8,'** Token missing'
         mexit
.cr2     anop
         mnote *,'NT create'
         $la   r1,&pl
         la    r14,=a(&$level)         level
.*       mnote *,'name:  &name.&n'
         $la   r15,&name,&n            name
.*       mnote *,'token: &$token'
         $la   r0,&$token              token
         stm   r14,r0,0(r1)
         la    r14,=a(&$pers.)         persist
         $la   r15,&rc
         stm   r14,r15,12(r1)
&offs    setc  '04'
         ago   .exec
.* -- retrieve
.*  Retrieve may use the caller's save area as work area as follows
.*  parmlist is  r13+40, length 16, overlaying r5-r8
.*  token    is also r13+40 length 16, overlaying r5-r8
.*  rc       is r13+40+16, length 4, overlaying r9
.*  The token is loaded to r1-4. The original r1-4 can be restored
.*  from the save area if needed.
.RT      ANOP
         mnote 'NT retrieve'
&$pl     setc  Upper('&pl')
&$plsave setc  Upper('&pl')
         aif   ('&$pl' ne 'SA').rt2
&$pl     setc  '40(r13)'
&$token  setc  '40(r13)'
&$rc     setc  '40+16(r13)'
.rt2     anop
.*       mnote 'RT r14 (level)=&$level'
.*       mnote '   r15 (name )=&name.&n'
.*       mnote '   r0  (token)=&$token'
.*       mnote '   r1  (rc   )=&$rc   '
.*       mnote '   r1  (pl   )=&$pl   '
         la    r1,&$pl
         la    r14,=a(&$level.)       level
         $la   r15,&name,&n            name
         $la   r0,&$token
         stm   r14,r0,0(r1)
         $la   r14,&$rc
         st    r14,12(,r1)
&offs    setc  '08'
         ago   .exec
.* -- delete
.DL      ANOP
         mnote 'NT delete'
         la    r1,&pl
         la    r14,=a(&$level.)        level
         $la   r15,&name,&n            name
         $la   r0,&rc
         stm   r14,r0,0(r1)
&offs    setc  '0C'
         ago   .exec
.* -- exec
.exec    anop
         L     r15,X'10'
         L     r15,X'220'(,r15)
         L     r15,X'14'(,r15)
         L     r15,X'&offs'(,r15)
         basr  r14,r15
         l     r15,&$rc
         aif   ('&$what' eq 'RT' and '&$plsave' eq 'SA').exec2
         ltr   r15,r15
         mexit
.* using save area as token output area
.exec2   anop
         mnote 'token is in the SA'
         lm    r1,r4,&$token         load token
         save  (5,9)                 re-save
         ltr   r15,r15
         Mexit
.* -- parmlist
.pl      anop
&mlbl    dc   6a(0)
.x       Mend
.* ADD NAME=QSAM31
         Macro
.*-
.*  Do  QSAM i/o  using 31-bit  buffers and  rmode any.  The generated
.*  code is fully reentrant.
.*
.* Syntax
.*
.*  label    QSAM31 parameters
.*
.* Parameter description
.*
.*  GEN,DCBA=label,DDNAME='ddname',ACC=Get|Put,EOD=label,
.*    RECFM=F|V,RECLEN=nnnnn,PRINT=NOGEN|gen
.*    recfm and reclen are taken from dataset if not specified.
.*    ddname is right-padded to 8 bytes and uppercased.
.*    'print' handles listing the DCB/DCBE expansions (1st call only).
.*  MOD,DCBA=label,DDNAME='ddname',EOD=label,RECFM=F|V,RECLEN=nnnnn
.*  OPEN,DCBA=label,GEN=N|y
.*    Input or output is determined from the DCB.
.*    if GEN=Y then the GEN function is called before OPEN, add
.*    required GEN parameters to the call.
.*  CLOSE,DCBA=label,DROP=N|y
.*    If DROP=Y then the DROP function is called internally.
.*  DROP,DCBA=label
.*  For all of the above you can use dcba-label instead of DCBA=label
.*  GET,DCBA=label,DATA=label
.*  GET,dcba-label,data-label
.*  PUT,DCBA=label,DATA=label
.*  PUT,dcba-label,data-label
.*  EXPOSE,DCBA=label,FIELD=fieldname,OUT=label | REG=r1
.*  DCBA      generate area anchor
.*  DSECTS
.*    Generate dsects DCBD and IHADCBE
.*
.* Sample - note that dcb 'LIST' uses the 'GEN' option.
.*
.*            QSAM31 gen,dcba=datadcba,acc=g
.*            QSAM31 mod,dcba=datadcba,ddname=dataddn,eod=dataeod
.*            QSAM31 open,dcba=datadcba
.*            QSAM31 open,dcba=listdcba,gen=yes,ddname='list',acc=p,
.*                     recfm=f,reclen=l'iobfr
.*   dataread QSAM31 get,data=iobfr,dcba=datadcba
.*            QSAM31 put,data=iobfr,dcba=listdcba
.*            j     dataread
.*   dataeod  QSAM31 close,dcba=datadcba
.*            QSAM31 drop,dcba=datadcba
.*            QSAM31 close,dcba=listdcba,drop=yes
.*   datadcba QSAM31 dcba
.*   listdcba QSAM31 dcba
.*   iobfr    ds    cl120
.*   dataddn  dc    cl8'DATA'
.*            QSAM31 dsects
.*   //DATA   DD *
.*   Kilroy
.*     was
.*       here
.*   //LIST   DD SYSOUT=*
.*
.* History
.* 2019-10-12  Initial
.*-
&mlbl    QSAM31 &dcba=,&ddname=,&reclen=,&recfm=,&acc=,&data=,         c
               &eod=,&gen=N,&drop=N,&print=nogen,                      c
               &field=,&out=,&reg=r1
.*
         gblc  &#modrmod,&#modamod
         lclc  &que,&dcbap,&accp,&genp,&dropp,&l,&s,&msect,&p1,&p2
         gblb  &QSAM31_init,&QSAM31_dsects
         aif   (&QSAM31_init eq 0).init
.*
.start   anop
&que     setc  Upper('&syslist(1)')
&p1      setc  Upper('&syslist(2)')
&p2      setc  Upper('&syslist(3)')
&accp    setc  Upper('&acc '(1,1))
&genp    setc  Upper('&gen '(1,1))
&dropp   setc  Upper('&drop '(1,1))
         aif   ('&accp' eq 'G' or '&accp' eq 'P' or k'&acc eq 0).jump1
         mnote 8,'*Invalid acc &accp'
         mexit
.jump1   anop
         aif   ('&que' eq 'SUBI').subi
         aif   ('&que' eq 'SUBX').subx
         aif   ('&que' eq 'LA').la
         aif   ('&que' eq 'DCBA').dcba   DCB area anchor
         aif   ('&que' eq 'DSECTS').dsects
.*
&dcbap   setc  '&dcba&p1'
         aif   (k'&dcbap eq 0).nodcba
         aif   ('&que' eq 'GEN').gen     make cbs
         aif   ('&que' eq 'MOD').mod     updt cb
         aif   ('&que' eq 'OPEN').open
         aif   ('&que' eq 'CLOSE').close
         aif   ('&que' eq 'DROP').drop
         aif   ('&que' eq 'GET').get
         aif   ('&que' eq 'PUT').put
         aif   ('&que' eq 'EXPOSE').expose
         mnote 8,'*Invalid option &que'
         mexit
.*-
.* Generate reentrant cbs
.*-
.gen     anop
&mlbl    sr    r0,r0
         aif   ('&accp' ne 'P').gencall
         la    r0,1                     set 'put'
.gencall Qsam31 la,r1,&dcbap
         l     r15,=v(QSAM31G)         -> generate routine
         balr  r14,r15
         QSAM31 mod,dcba=&dcbap,ddname=&ddname,reclen=&reclen,         c
               recfm=&recfm,eod=&eod,print=&print
         Mexit
.*-
.* IO blk
.*-
.dcba    anop
&mlbl    dc    a(0)
         Mexit
.*-
.* Modify control blocks
.*-
.mod     anop
&mlbl    Qsam31 la,r14,&dcbap
         l     r14,0(,r14)
         using QSAM31blk,r14
         aif   (k'&ddname eq 0).modddnn
         aif   ('&ddname'(1,1) eq '''').modddnl
         QSAM31 la,r1,&ddname
         ago   .modddng
.modddnl la    r1,=cl8&ddname
.modddng mvc   QSAM31bdcb+(dcbddnam-ihadcb)(8),0(r1)
         oc    QSAM31bdcb+(dcbddnam-ihadcb)(8),=cl8' '
.modddnn anop
         aif   (k'&reclen eq 0).modrcln
         qsam31 la,r1,&reclen
         sth   r1,QSAM31bdcb+(dcblrecl-ihadcb)
.modrcln anop
&s       setc  Upper('&recfm '(1,1))
         aif   ('&s' ne 'F').modrffn
         oi    QSAM31bdcb+(dcbrecfm-ihadcb),DCBRECF
.modrffn anop
         aif   ('&s' ne 'V').modrfvn
         oi    QSAM31bdcb+(dcbrecfm-ihadcb),DCBRECV
.modrfvn anop
         aif   (k'&eod eq 0).modeodn
         QSAM31 la,r1,&eod
         st    r1,QSAM31bdcbe+(dcbeeoda-dcbe)
.modeodn anop
         drop  r14
         mexit
.*-
.* Open DCB
.*-
.open    anop
&l       setc  'QSO&sysndx'
         aif   (k'&mlbl eq 0).open2
&mlbl    ds    0h
.open2   anop
         aif   ('&genp' ne 'Y').open3
         QSAM31 gen,dcba=&dcbap,ddname=&ddname,acc=&acc,               c
               reclen=&reclen,recfm=&recfm,eod=&eod,print=&print
.open3   anop
         Qsam31 la,r1,&dcbap
         l     r15,=v(QSAM31O)         -> open routine
         balr  r14,r15
         mexit
.*-
.* Close DCB
.*-
.close   anop
&mlbl    Qsam31 la,r15,&dcbap
         l     r15,0(,r15)
         Close ((r15)),mode=31,mf=(E,QSAM31bocb-QSAM31blk(15))
         aif   ('&dropp' ne 'Y').close2
         QSAM31 drop,dcba=&dcbap
.close2  anop
         mexit
.*-
.* Read
.*-
.get     anop
&mlbl    Qsam31 la,r15,&dcbap
         l     r15,0(,r15)
         get   ((r15)),&data&p2          get
         mexit
.*-
.* Write
.*-
.put     anop
&mlbl    Qsam31 la,r15,&dcbap
         l     r15,0(,r15)
         put   ((r15)),&data&p2          put
         mexit
.*-
.* Drop resources
.*-
.drop    anop
         Qsam31 la,r1,&dcbap
         l     r15,=v(QSAM31D)         -> generate routine
         balr  r14,r15
         mexit
.*-
.* Expose fields
.*-
.expose  anop
&mlbl    Qsam31 la,&reg,&dcbap
         l     &reg,0(,&reg)
         aif   (k'&out ne 0).exposef
         la    &reg,QSAM31b&field.o(,&reg)
         ago   .exposex
.exposef Qsam31 la,r14,&out
         mvc   0(l'QSAM31b&field,r14),QSAM31b&field.o(&reg)
.exposex mexit
.*-
.* Build internal modules
.*-
.subi    anop
.* amode
         aif   ('&#modamod' ne '').#modam2
&mlbl    Amode 31
         ago   .#modamn
.#modam2 anop
&mlbl    Amode &#modamod
.#modamn anop
.* rmode
         aif   ('&#modrmod' ne '').#modrm2
&mlbl    Rmode ANY
         ago   .#modrmn
.#modrm2 anop
&mlbl    rmode &#modrmod
.#modrmn anop
&mlbl    Csect
         Save  (14,12)
         lr    r11,r15
         Using &mlbl,r11
         mexit
.subx    anop
         l     r14,12(,r13)
         Return (2,12)
         mexit
.init    anop
&QSAM31_init setb 1
&l       setc  'QSI&sysndx'
         j     &l.b
         ltorg
&l.b     ds    0h
&msect   setc  '&sysloc'
         push using
QSAM31blk    Dsect
QSAM31bdcb   ds    xl(QSAM31gdl)
QSAM31bdcbe  ds    xl(QSAM31gel)
QSAM31bocb   ds    2a
QSAM31breclo equ   *-QSAM31blk
QSAM31brecl  ds    h
QSAM31brecfo equ   *-QSAM31blk
QSAM31brecf  ds    c               F or V
QSAM31blkl   equ   *-QSAM31blk
.*
* Generate 24-bit area holding DCB and DCBE
* at entry
* r1 -> dcb anchor
* r0 = 0 => Get, r0 = 1 => Put
.*
QSAM31G  Qsam31 subi
         lr    r2,r1
         lr    r3,r0
         Getmain R,lv=QSAM31blkl,loc=BELOW
         st    r1,0(,r2)                 save ptr
         lr    r2,r1
         using QSAM31blk,r2
         ltr   r3,r3
         jnz   QSAM31G_put
         mvc   QSAM31bdcb(QSAM31gdl),QSAM31gd
         mvc   QSAM31bdcbe(QSAM31gel),QSAM31ge
         j     QSAM31G_set
QSAM31G_put    equ   *
         mvc   QSAM31bdcb(QSAM31pdl),QSAM31pd
         mvc   QSAM31bdcbe(QSAM31pel),QSAM31pe
QSAM31G_set    equ   *
         la    r14,QSAM31bdcbe                -> DECB
         st    r14,QSAM31bdcb+(dcbdcbe-ihadcb) store in DCB
         xc    QSAM31bocb(8),QSAM31bocb      prep open/close list
         mvi   QSAM31bocb,x'80'            prep open/close list
         sr    r15,r15
         Qsam31 subx
* cb models
          push  print
          print &print
QSAM31gd  DCB   ddname=Z,macrf=GM,dsorg=PS,eodad=0,dcbe=*
QSAM31gdl equ     *-QSAM31gd
QSAM31ge  DCBE  RMODE31=BUFF,EODAD=*
QSAM31gel equ     *-QSAM31ge
QSAM31pd  DCB   ddname=Z,macrf=PM,dsorg=PS,eodad=0,dcbe=*
QSAM31pdl equ     *-QSAM31pd
QSAM31pe  DCBE  RMODE31=BUFF
QSAM31pel equ     *-QSAM31pe
          pop   print
          ds    0a
         pop  using
.*
* Open DCB after determining input or output
* at entry
*  r1 -> dcb anchor
.*
&l       setc  'QSO&sysndx'
         push using
QSAM31O  Qsam31 subi
         l     r2,0(,r1)                   -> DCB blk
         using QSAM31blk,r2
.* go
         cli   DCBMACR1-ihadcb(r2),0       z=output, nz=input
         je    &l.o                        output
* input
         OPEN  ((r2)),mode=31,mf=(E,QSAM31bocb)
         j     &l.s
* output
&l.o     equ   *
         OPEN  ((r2),(OUTPUT)),mode=31,                                c
               mf=(E,QSAM31bocb)
.* store some info
&l.s     mvc   QSAM31brecl,QSAM31bdcb+(dcblrecl-ihadcb)
         mvi   QSAM31brecf,c'F'
         tm    QSAM31bdcb+(dcbrecfm-ihadcb),DCBRECV
         jz    *+8
         mvi   QSAM31brecf,c'V'
.* back
&l.n     sr    r15,r15
         Qsam31 subx
         pop  using
.*
* Free 24-bit area holding DCB and DCBE
* at entry
*  r1 -> dcb anchor
.*
         push using
QSAM31D  Qsam31 subi
         lr    r2,r1
.* go
         l     r3,0(,r2)
         Freemain R,lv=QSAM31blkl,a=(r3)
         xc    0(4,r2),0(r2)
.* back
         sr    r15,r15
         Qsam31 subx
         pop  using
.* resume main
&msect   Loctr ,                       resume
         ago   .start
.*-
.* Dsects
.*-
.dsects  anop
         aif   (&QSAM31_dsects).dsectsn
&QSAM31_dsects setb 1
         Dsect
         Push  print
         Print &print
         DCBD  DSORG=PS                 map DCB
         IHADCBE ,                      map DCBE
         Pop   print
.dsectsn mexit
.*-
.* Subroutine, generate Lx instruction (shortened $LA)
.*
.* Syntax: LA  reg,what1,what2,,whatn
.*         what: label or (reg) or 'literal' or f/h/b/c.label
.*               x.label -> reg is cleared and the value is loaded
.*               1st non-null 'what' is used
.*-
.LA      anop
         lclc  &xlar,&xlap,&xla,&xlapu
         lcla  &xlapn,&xlan
         gblc  &$$lalen
&$$lalen setc  ''
&xlapn   seta  2
&xlar    setc  '&syslist(&xlapn)'
.xlanext anop
&xlapn   seta  &xlapn+1
         aif   (&xlapn gt n'&syslist).x
&xlap    setc  '&syslist(&xlapn)'
         aif   (k'&xlap eq 0 or '&xlap' eq '''''').xlanext
         aif   ('&xlap '(1,1) eq '(').xlareg
         aif   ('&xlap '(1,1) eq '''').xlalit
         aif   ('&xlap '(2,1) eq '.').xlafld
&xla     setc  t'&xlap
         aif   ('&xla' eq 'N').xlanum
&mlbl    la    &xlar,&xlap
         aif   ('&xlap  '(1,2) eq 'l''').x
&$$lalen setc  'l''&xlap'
         mexit
.xlanum  anop
&mlbl    lgfi  &xlar,&xlap
         mexit
.xlareg  anop
&xlan    seta  k'&xlap-2
&xlap    setc  '&xlap'(2,&xlan)
&mlbl    lr    &xlar,&xlap
         mexit
.xlalit  anop
&mlbl    la    &xlar,=c&xlap
&xlan    seta k'&xlap-2
         mexit
.xlafld  anop
&xlan    seta  k'&xlap-2
&xlapu   setc  Upper('&xlap'(1,1))
&xlap    setc  '&xlap'(3,&xlan)
&$$lalen setc '&xlan'
         aif   ('&xlapu' eq 'F').xlaflf
         aif   ('&xlapu' eq 'H').xlaflh
         aif   ('&xlapu' eq 'B' or '&xlapu' eq 'C').xlaflb
         mnote 8,'* Invalid load parm'
         mexit
.xlaflf  anop
&mlbl    l     &xlar,&xlap
         mexit
.xlaflh  anop
&mlbl    lh    &xlar,&xlap
         mexit
.xlaflb  anop
&mlbl    llc   &xlar,&xlap
         mexit
.*-
.* Macro end
.*-
.nodcba  mnote 8,'**Missing DCBA'
.x       MEND
.* ADD NAME=STRCOPY
         Macro
.*-
.* Copy string
.*
.* The generated code determines if the length is le or gt 255
.* and does MVC or MVCL accordingly.
.*
.* Syntax
.*  STRCOPY FROM=(addr,len),TO=(addr,len) Ý,LENREG=lr¨
.*        addr     label, (reg), F.label
.*        len      value, (reg), F.label, default is len of addr
.*        lr       register to save the length.
.*
.* len values are optional, thet defaults to the with of addr.
.* FROM-len will be adjusted if gt than TO-len.
.*
.* Registers 14, 15, 0 and 1 are all used internally.
.*
.* Uses macro $LA to set values.
.*
.* Samples
.*     STRCOPY  from=target,to=(source,(r3))
.*-
&mlbl    StrCopy  &from=,&to=,&lenreg=
         lclc  &l,&s
         gblc  &$lalenc
&l       setc  'zsc&sysndx'
.* setup address and length info
&mlbl    $la   r14,&from(1)
         $la   r15,&from(2),&$lalenc
         $la   r0,&to(1)
         $la   r1,&to(2),&$lalenc
.* beware of overflow
         cr    r1,r15               check target big enough
         jh    *+6                  target size ok
         lr    r15,r1               overflow, use target length
.* copy length
         aif   (k'&lenreg eq 0).cplrn
         lr    &lenreg,r15
.cplrn   anop
.* select method
         clfi  r15,255              if source length
         jh    &l.ml                  gt 255 then use movelong
         bctr  r15,0
         lr    r1,r0                copy target address
         ex    r15,&l.ms
         j     &l.x
&l.ms    mvc   0(*-*,r1),0(r14)
&l.ml    lr    r1,r15               copy length
         mvcl  r0,r14
&l.x     ds    0h
         Mend
.* ADD NAME=STRC2D
         Macro
.*-
.* STRC2D - convert hex value to readable (decimal)
.*
.* Syntax
.*  STRC2D FROM=(addr,len),TO=(addr,len)
.*        addr      label, (reg), F.label
.*        from-len  value 1-4, can be in (reg) or f.label
.*        to-len    value, (reg) or f.label. Default is from-len*3
.*
.* The  macro calls  an internally  generated subroutine.  This
.* shortens the code length  for multiple executions of STRC2D,
.* though adds a bit to the program complexity.
.*
.* Returns
.*  r0  = length of output if r15=0
.*  r15 = 0 if all ok, else 4
.*
.* Notes
.*  registes 0,1,14,15 are used by the macro
.*
.* Author
.*     Willy Jensen
.*     mail: willy@harders-jensen.com
.*     web : http://harders-jensen.com/wjtech
.*-
&mlbl    StrC2d &from=,&to=,&print=nogen
         gblb  &$strc2d
         gblc  &$lalenc
         lclc  &s,&l,&froml,&tol
&l       setc  'CD&sysndx'
.* call
         $la   r15,&from(1)
&froml   setc  '&$lalenc'
         $la   r0,&to(1)
&tol     setc  '&$lalenc'
         $la   r1,&from(2),&froml
         $la   r14,&to(2),0
         sll   r1,16
         ar    r1,r14
         l     r14,=v(zstrc2d)
         basr  r14,r14
         aif   (&$strc2d).x
&$strc2d setb  1
* module
         push  print
         print &print
&s       setc  '&sysloc'
ZSTRC2D  Amode 31
ZSTRC2D  Rmode any
ZSTRC2D  Csect
         stm   r14,r2,12(r13)
         basr  r2,0
         ahi   r2,-6
         push  using
         using zstrc2d,r2
.* get length mask
         l     r14,16(,r13)            from addr
         lh    r15,24(,r13)            from len
         cfi   r15,4
         jh    &l.e1
         sr    r1,r1                   not really necessary, but...
         ic    r1,&l.m-1(r15)          load mask
.* load source
         sr    r15,r15
         ex    r1,&l.i
         cvd   r15,60(,r13)
.* make decimal
         l     r14,20(,r13)            to addr
         lh    r15,26(,r13)            to len
         ltr   r15,r15                 to-len given?
         jnz   &l.b                    yes
         lh    r15,24(,r13)            use from-length
         mhi   r15,3                   *3
&l.b     lr    r0,r15                  save target size
         bctr  r15,0
         sll   r15,4
         ex    r15,&l.u
         srl   r15,4
         la    r15,0(r14,r15)
         oi    0(r15),x'f0'
         j     &l.x0
&l.m     dc    x'0103070F'             length masks
&l.i     icm   r15,0,0(r14)
&l.u     unpk  0(*-*,r14),60(8,r13)
&l.x0    sr    r15,r15
&l.x1    l     r14,12(,r13)
         l     r2,28(,r13)
         bsm   0,r14
&l.e1    la    r15,4
         j     &l.x1
         drop  r2
         pop   using
         pop   print
.* resume main
&s       Loctr                         resume main
.x       Mend
.* ADD NAME=STRPARSE
         Macro
&lbl     StrParse &value=,&init=N,&link=CALL,&trace=,&msg=0,           c
               &v=Z,&c=Z,&l=N,&i=,&q=z,&pp=--,&area=N,&build=N,&align=
.*----------------------------------------------
.*
.*  Really just a copy of PARMSCN2 of 2018/12/05
.*
.*  Syntax
.*    StrParse (stringaddr,stringlength),
.*             (keyword,area,F=format-verify,C=convert,A=abbrev,
.*             I=init-value,q=quote),
.*             INIT=i,PP=pp,LINK=llll
.*          keyword: verb, will be capped internally
.*          area   : address of a StrParse DC/DS macro
.*          verify : A alphanum, letters and numbers
.*                   C char, only letters
.*                   N only numbers
.*          format : B convert to binary, forces length=4
.*                   P packed binary
.*                   U uppercase string
.*          'verify' and 'format' can be entered in any case
.*          'verify' and 'format' are only honored if INIT=Y
.*          quote    K keep. default is to drop quotes.
.*      . . .
.*      BUILD=Y      Stack internal list for 'AREA' call.
.*      INIT=Y       Initialize area covered by a
.*                   StrParse DC/DS macro. only the first byte
.*                   of the area is initialized.
.*      PP=cc        positional value prefix
.*      link=CALL|link   'call' generates internal
.*      AREA         Build 'DS' list from internal stack.
.*                   Must be the only parameter, otherwise assumed
.*                   to be string name.
.*
.* Define area
.* areaname StrParse DC|ds,size,format=.convert=
.*          verify and format see above. Only honored for DC.
.*          if size F then force full-word, format N and convert B
.*
.*          StrParse area expansion:
.*             areaname_fl ds  al1  field length
.*             areaname_dl ds  al1  data length
.*             areaname dc|ds  &type&value
.*
.* Notes:
.*  If the same parameter is entered multiple times then the last
.*  entry is use.
.*  An entry can be use multiple times, i.e.:
.*               StrParse (workrec,l'workrec),
.*    -  -  -  -  -  -  -  -  -  -  -  -  -  -
.*                   (msg,msg1),
.*                   (msg,msg2),
.*    -  -  -  -  -  -  -  -  -  -  -  -  -  -
.*    msg1     StrParse dc,12,v=z,c=z
.*    msg2     StrParse dc,12,v=z,c=z
.*  if msg(something) is entered more than twice, then the 'msg2'
.*  field is overwritten.
.*
.* Updates
.* 2019-09-05 Add Q= option, include XLA subroutine
.* 2019-09-30 Add amode and rmode to all internal csects
.*
.*----------------------------------------------
         gblb  &strparsmodule,&strparsdsect
         gbla  &strparsn
         gblc  &strparsl(100),&strparsk(100),&strparst(100)
         gblc  &strparsf(100),&strparsc(100),&strparsq(100)
         gblc  &strparsalign
         lcla  &n,&l1,&l2,&flgs,&sln,&ofs,&oln,&setinil
         lclc  &name,&data,&type,&req,&opt,&optu,&optd,&lb1
         lclc  &thissect,&sect,&s,&s1,&s2,&s3
         lclc  &pl,&pvfy,&pcnv,&pabr,&plst
         lclc  &plen,&pinit,&trn,&setini,&palign,&pqopt
.* xla sub
         gblc  &xlalen
&s       setc  Upper('&syslist(1)')
         aif   ('&s' eq 'XLA').xla
.*
         aif   (k'&align eq 0).palignn
&strparsalign  setc  (UPPER '&align')
.palignn anop
.*       mnote *,'align=&strparsalign'

&pinit   setc  (UPPER '&init')
&s3      setc  (UPPER '&build')
         aif   ('&s3' ne 'Y').pbuildn
&pinit   setc  'Y'
.pbuildn anop
&s3      setc  (UPPER '&syslist(1)')
         aif   ('&s3' eq 'AREA' and n'&syslist eq 1).area
         aif   ('&s3' eq 'DS').ds
         aif   ('&s3' eq 'DC').dc
&thissect setc '&sysect'
.*       mnote *,'thissect: &thissect'
.* preserve ltorg'd fields
&lb1     setc  'zps&sysndx.a'
         b     &lb1
         ltorg
&lb1     ds    0h
         call  ZPS&sysndx.M
.*
*----------- build keyword table --------------
         aif   (&strparsdsect ne 0).dsectn
*PS2D1 keyword list area
PS2D1    Dsect
PS2D1eye ds    cl8                    eyecatcher
PS2D1siz ds    a                      total size of obtained area
PS2D1sa1 ds    18a                    save area
PS2D1sa2 ds    18a                    save area
PS2D1bln ds    cl120                  blank area
PS2D1fw  ds    f                      work area
PS2D1dw  ds    d                      work area
PS2D1wrk ds    xl256                  work area
PS2D1sta ds    a                      string address
PS2D1stl ds    a                      string length
PS2D1stp ds    a                      string position
PS2D1vpb ds    a                      verb portion begin
PS2D1vpe ds    a                      verb portion end
PS2D1dpb ds    a                      data portion begin
PS2D1dpe ds    a                      data portion end
PS2D1msg ds    a                      -> message buffer (cl100)
PS2D1num ds    a                      number of named operands in list
PS2D1d2a ds    a                      -> data (work)
PS2D1pp  ds    cl2                    Positional prefix
PS2D1pn  ds    al1                    Positional count
         ds    xl1                    future use
PS2D1lst ds    0x                     start of named operand list
PS2D1pfl equ   *-PS2D1                size of area prefix
.*
*PS2D2 keyword list entry
PS2D2    Dsect ,                      keyword list
PS2D2nam ds    a                      address of name
PS2D2opt ds    x                      options
PS2D2use equ   x'80'                  in use
         ds    x                      future
PS2D2len ds    al1                    verb length
PS2D2abr ds    al1                    verb abbreviation
PS2D2d3a ds    a                      address of data definition
PS2D2nxt ds    0x                     next entry
.*
*PS2D3 data entry
PS2D3    Dsect ,                      data entry
PS2D3opt ds    x                      future
.*2D3use equ   x'80'                  in use
PS2D3vfc equ   128                    verify is char
PS2D3vfn equ   64                     verify is num
PS2D3vfa equ   128+64                 verify is alpha-num
PS2D3vfz equ   0                      null
PS2D3qok equ   32                     quote opt - keep quotes
PS2D3qoz equ   0                                - drop quotes
PS2D3cvu equ   8                      convert to upcase chars
PS2D3cvp equ   4                      convert to packed decimal
PS2D3cvb equ   2                      convert to binary
PS2D3lst equ   1                      data is a list
PS2D3cvz equ   0                      null
PS2D3fl  ds    x                      field length
PS2D3dl  ds    x                      data length
PS2D3dat ds    0c                     data
.dsectn  anop
&sect    setc  'ZPS&sysndx.M'
.* &sect $$modes
&sect    amode 31
&sect    rmode any
&sect    csect
         bakr  14,0
         lr    r5,r15
         using &sect,r5
         using PS2D1,r6
&sln     seta  12*n'&syslist
 mnote *,'storage obtain sz &sln'
         STORAGE OBTAIN,LENGTH=PS2D1pfl+&sln,LOC=31
         lr    r6,r1
         mvc   PS2D1eye,=cl8'&sect'    eyecatcher
         mvc   PS2D1siz,=a(PS2D1pfl+&sln) obtained area size
         STRPARSE XLA,r1,&msg
         st    r1,PS2D1msg
.*       STRPARSE XLA,r1,&unsol
.*       st    r1,PS2D1uos
&s       setc  (Upper '&pp')
         mvc   PS2D1pp,=cl2'&s'        positional var prefix
         mvi   PS2D1pn,0               positional number
         aif   (n'&syslist(1) ne 2).strerr1
         STRPARSE XLA,r14,&syslist(1,1) string address
         STRPARSE XLA,r15,&syslist(1,2) string length
         stm   r14,r15,PS2D1sta
         st    r14,PS2D1stp            save start pos
&sln     seta  n'&syslist-1
         mvc   PS2D1num,=a(&sln)       number of named operands
.*
&sln     seta 2
         la    r7,PS2D1lst
         la    r13,PS2D1sa1
.*--
.pars100 anop
&name    setc  Upper('&syslist(&sln,1)')
&data    setc  'name'
         aif   (n'&syslist(&sln) eq 1).pars200
&data    setc  '&syslist(&sln,2)'
.pars200 anop
&trn     setc  'CALL'
&oln     seta  2                     past name and dataaddres
         ago   .opt2
.callopt anop
&l1      seta  k'&name
         la    r2,=c'&name'
         lh    r3,=y((256*&l1)+&pabr) verb length, abbrev
         la    r4,&data._op
         stm   r2,r4,0(r7)
         aif   ('&pinit' ne 'Y').pars300
         mnote *,'do init'
         aif   ('&plst' eq 'Y').pars220
         aif   ('&plen' eq '?').pars210
&s3      setc  '&plen'
         aif   ('&plen' eq 'F').pars205
&s1      setc  'PS2D3vf&pvfy+PS2D3cv&pcnv+PS2D3qo&pqopt'
         mvc   &data._op(4),=al1(&s1,&s3,0,c' ')
         ago   .pars206
.pars205 mvc   &data._op(4),=al1(PS2D3vf&pvfy+PS2D3cv&pcnv,4,0,0)
.pars206 anop
&strparsn seta &strparsn+1
&strparsl(&strparsn) setc '&data'
&strparst(&strparsn) setc 'C'
&strparsk(&strparsn) setc '&plen'
&strparsf(&strparsn) setc '&pvfy'
&strparsc(&strparsn) setc '&pcnv'
&strparsq(&strparsn) setc '&pqopt'
         ago   .pars300
.pars210 anop
&s1      setc  'PS2D3vf&pvfy+PS2D3cv&pcnv+PS2D3qo&pqopt'
         mvc   &data._op(4),=al1(&s1,l'&data,0,c' ')
         ago   .pars300
.pars220 anop  ,                       list
&s1      setc  'PS2D3vf&pvfy+PS2D3cv&pcnv+PS2D3lst+PS2D3qo&pqopt'
         mvc   &data._op(4),=al1(&s1,0),y(l'&data)
.pars300 anop
         aif   (&setinil eq 0).pars400
         aif   ('&pcnv' eq 'P').pars310
         aif   ('&pcnv' eq 'B').pars320
&setinil seta  &setinil-2
         mvi   &data._dl,&setinil
         mvc   &data.(&setinil),=c&setini
         ago   .pars400
.pars310 anop  ,                       packed dec
         mvi   &data._dl,l'&data       full field
         zap   &data,=p'&setini'       set value
         ago   .pars400
.pars320 anop  ,                       binary
         mvi   &data._dl,4
         mvc   &data,=al4(&setini)
.pars400 anop
         la    r7,PS2D2nxt-PS2D2(,r7)
&sln     seta  &sln+1
         aif   (&sln le n'&syslist).pars100
* Call parser
         lr    r1,r6
         Call  STRPARS2
         lr    r2,r15                 save rc
         l     r3,PS2D1siz
         STORAGE RELEASE,LENGTH=(3),ADDR=(6)
         lr    r15,r2
         pr
         ltorg
         drop  r5,r6
.*-
         aif   (&strparsmodule).modulen
         push  using
.*-
.*       Module
.*-
&strparsmodule setb 1
*
*-
*        Parser
*-
         USING PS2D1,r10
         USING STRPARS2,r11        ESTABLISH ADDRESSABILITY
 aif ('&trace' eq '').trc0n
         USING &thissect,r12
.trc0n anop
.* SCN02 $$modes
STRPARS2 amode 31
STRPARS2 rmode any
STRPARS2 Csect
         save  (14,12)             save caller's status on stack
         lr    r11,r15             set up a base register
         lr    r10,r1              -> Keylist setup dynamic area
         la    r14,PS2D1sa2
         st    r14,8(,r13)
         st    r13,4(,r14)
         lr    r13,r14
         l     r7,PS2D1sta         string address
         l     r6,PS2D1stl         string length
         xc    PS2D1wrk,PS2D1wrk
         clear PS2D1bln
         ar    r6,r7               -> 1 past string
         bctr  r6,0                -> last byte of string
         la    r9,PS2D1lst         -> keyword table

 aif ('&trace' eq '').trc1n
      lr    r14,r6
      sr    r14,r7
      bctr  r14,0
      sh    r14,=h'18'
      mvc   logr+18(*-*),0(r7)
      ex    r14,*-6
      la    r14,1(,r14)
      $cvd  r14,logr+12,len=4
      log   'str:'
.trc1n anop

*locate start of kw (1st non-blank)
ps2slkw0 equ   *
         l     r7,PS2D1stp           load position
ps2slkw1 equ   *
         cr    r7,r6                 end of string?
         bh    ps2send               yes, end
         cli   0(r7),c' '            look for non-blank
         bne   ps2slkw2              got it
         la    r7,1(,r7)
         b     ps2slkw1
*locate end of keyword
ps2slkw2 equ   *
         st    r7,PS2D1vpb           save verb start
         la    r4,1(r7)
ps2slkw3 equ   *                     look for '('
         cli   0(r4),c'('            look for '('
         be    ps2slkwend            got it
         cli   0(r4),c' '            positional
         be    ps2slkwend            got it
         la    r4,1(,r4)
         cr    r4,r6                 end of string?
         bnh   ps2slkw3
ps2slkwend equ *                     start and end of kw found
         st    r4,PS2D1vpe           save verb end
         st    r4,PS2D1stp           update position
         sr    r4,r7                 length of keyword
.*       lr    r15,r5                copy length dropped 2017-02-25
         lr    r15,r4                copy length
         bctr  r15,0                 mch length
         mvc   PS2D1wrk+2(*-*),0(r7)   copy verb
         ex    r15,*-6
         oc    PS2D1wrk+2(l'PS2D1bln),PS2D1bln  uppercase
         xc    PS2D1d2a,PS2D1d2a
 aif ('&trace' eq '').trc2n
      mvlit logr,'kw:'
      lr    r14,r4
      bctr  r14,0
      mvc   logr+12(*-*),0(r7)
      ex    r14,*-6
      log
.trc2n anop

*find the entry in the keyword table
*r7 ->start of keyword, r4=length
         Using PS2D2,r5
         la    r5,PS2D1lst           ->table
         l     r8,PS2D1num           number of entries
         sr    r2,r2
ps2slkwt1 equ *
         lb    r2,PS2D2len           load length
         l     r3,PS2D2nam           ->keyword
 aif ('&trace' eq '').trc3n
     lb    r14,PS2D2len
     bctr  r14,0
     mvc   logr+12(*-*),0(r3)
     ex    r14,*-6
     log   'kwt entry:'
.trc3n anop
         cli   PS2D2abr,0            abbreviation allowed?
         be    ps2snabr              nope
 aif ('&trace' eq '').trc31n
     log   'test abr'
.trc31n anop
         clm   r4,1,PS2D2len         check length
         bh    ps2slkwt2             verb len gt max
         clm   r4,1,PS2D2abr         check abbrev length
         bl    ps2slkwt2             verb len lt abbrev
         lr    r2,r4                 copy verb
ps2snabr equ   *
         cr    r4,r2                 check length
         bne   ps2slkwt2             no, try next
ps2stvrb equ   *
         bctr  r2,0
.*       clc   0(*-*,r7),0(r3)
         clc   PS2D1wrk+2(*-*),0(r3)
         ex    r2,*-6
         be    ps2slkwt3             gotit
ps2slkwt2 equ *
         la    r5,PS2D2nxt           ->next entry
         bct   r8,ps2slkwt1          if any left
         icm   r14,15,PS2D1d2a       is
         bz    ps2slkwt2a              there
         lr    r5,r14                    a previous
         b     ps2slkwt3a                  entry we can use?
ps2slkwt2a equ *
         l     r1,PS2D1vpe
         cli   0(r1),c'('            has data?
         be    ps2serr2              yup, not positional
         cli   PS2D1pp,c'-'          positional ?
         bne   ps2spp                yes, go check
         b     ps2serr2              else not found
ps2slkwt3 equ *
         st    r5,PS2D1d2a           save
.* if entry has been used already then ignore
         l     r14,PS2D2d3a          -> data
         cli   PS2D3dl-PS2D3(r14),0  test data length
         bne   ps2slkwt2             not zero, then already used
.* -
ps2slkwt3a equ *
 aif ('&trace' eq '').trc4n
     mvc   logr+12(*-*),0(r3)
     ex    r2,*-6
     log   'kw valid:'
.trc4n anop
.*       oi    PS2D2opt,PS2D2use     set 'keyword found'
.*       l     r15,PS2D2d3a          ->data section
.*       using PS2D3,r15
.*       tm    PS2D3opt,PS2D3use     already used?
.*       bo    ps2serr3              yep, error
.*       oi    PS2D3opt,PS2D3use     mark it in use
.*       drop  r15

*-------------describe parmdata---------------------------
         la    r7,0(r4,r7)           -> past kw
         cli   0(r7),c'('            type of delimiter
         be    ps2sld1               go get data
 aif ('&trace' eq '').trc51n
      log   'no data'
.trc51n anop
         l     r14,PS2D2d3a          -> data
         mvi   PS2D3dl-PS2D3(r14),1  set data length
         mvi   PS2D3dat-PS2D3(r14),c'Y' default value
         b     ps2slkw0              next
ps2sld1  equ    *
         sr    r8,r8                 keep count of sub-parms
*find start of data
.*       cli   pskdmaxl,0            keyword only?
.*       be    ps2serr4              then error
 aif ('&trace' eq '').trc5n
      log   'has data'
.trc5n anop
         la    r7,1(,r7)             bump ptr
         cr    r7,r6                 past end of string?
         bh    ps2serr1              end-of-data missing
         cli   0(r7),c' '
         be    ps2sld1
         st    r7,PS2D1dpb           save address of data

*find end of data
 aif ('&trace' eq '').trc6n
      mvc   logr+12(8),0(r7)
      log   'data start:'
.trc6n anop
         lr    r4,r7                 ->data
ps2sld2 equ    *
         cr    r4,r6                 past end of string?
         bh    ps2serr1              error
         cli   0(r4),c')'            end of parm?
         be    ps2sld3
         cli   0(r4),c'('            start of sub-parm?
         bne   *+8                   nope
         la    r8,1(,r8)             indicate
         la    r4,1(,r4)
         b     ps2sld2
ps2sld3 equ    *
         ltr   r8,r8                 end of all (sub-)parms?
         bz    ps2sld3a              yes
         bctr  r8,0                  else subtract one
         la    r4,1(,r4)
         b     ps2sld2               and continue
ps2sld3a equ   *
         st    r4,PS2D1dpe           save address of data end
 aif ('&trace' eq '').trc7n
      mvc   logr+12(8),0(r4)
      log   'data end:'
.trc7n anop
         la    r14,1(,r4)
         st    r14,PS2D1stp          update position
*locate last non-blank of data
         lr    r2,r4
ps2sld4 equ    *
         bctr  r2,0
         cli   0(r2),c' '
         be    ps2sld4
ps2sld5  equ    *
         cr    r2,r7                null string?
         bl    ps2sldend            yes
         la    r2,1(,r2)            past end
         sr    r2,r7                length of data
 aif ('&trace' eq '').trc81n
      mvlit logr,'datalen:'
      $cvd  r2,logr+12,len=4
      mvlit logr+18,'fldl'
      l     r14,PS2D2d3a         -> data structure
      sr    r14,r14
      ic    r14,PS2D3fl-PS2D3(,r14) field length
      $cvd  r14,logr+24,len=4
      log   ,
.trc81n anop
         l     r14,PS2D2d3a         -> data
         tm    PS2D3opt-PS2D3(r14),PS2D3cvb  if convert to bin
         bo    ps2scfl9             then bypass this check
         lr    r1,r14
         sr    r14,r14
         ic    r14,PS2D3fl-PS2D3(,r1)  load field length
         cr    r2,r14               test size, r2=dl r14=fl
         bnh   ps2scfl9             ok
* error 5 : data too wide
* dc h'0'
         la    r15,5                set rc
         icm   r1,15,PS2D1msg
         bz    ps2sendx             no message area
*                             ----+----1----+----2----+----3----+----4
         mvc   0(20,r1),=cl20'0005 Datalength at'
         mvc   20(8,r1),0(r7)
         la    r1,30(,r1)
.*       $cvd  r2,19(r1),len=4
         mvc   0(2,r1),=c'dl'
         cvd   r2,PS2D1dw
         unpk  3(8,r1),PS2D1dw+4(4)
         oi    3+8-1(r1),x'f0'
         la    r1,12(,r1)
.*       $cvd  r14,27(r1),len=4
         mvc   0(2,r1),=c'fl'
         cvd   r14,PS2D1dw
         unpk  3(8,r1),PS2D1dw+4(4)
         oi    3+8-1(r1),x'f0'
         b     ps2sendx             too big
ps2scfl9 equ   *
         l     r4,PS2D2d3a
         using PS2D3,r4
         stc   r2,PS2D3dl           save data length
         bctr  r2,0
* verify data contents ?
         tm    PS2D3opt,x'f0'      test format?
         bz    ps2svf9             nope
         tm    PS2D3opt,PS2D3vfa   test for alphanum?
         bz    ps2svfa9            else go check next
         la    r3,=c'A'
         ex    r2,ps2svfax
         bz    ps2svf9             ok
         b     ps2serr6
ps2svfax trt   0(*-*,r7),ps2svfat
ps2svfa9 equ   *
         tm    PS2D3opt,PS2D3vfc   test for char
         bz    ps2svfc9            else go check num
         la    r3,=c'C'
         ex    r2,ps2svfcx
         bz    ps2svf9             ok
         b     ps2serr6
ps2svfcx trt   0(*-*,r7),ps2svfct
ps2svfc9 equ   *
         tm    PS2D3opt,PS2D3vfn   test for numerics
         bz    ps2svfn9            nope
         la    r3,=c'N'
         ex    r2,ps2svfnx
         bz    ps2svfn9             ok
         b     ps2serr6
ps2svfnx trt   0(*-*,r7),ps2svfnt
ps2svfn9 equ   *
ps2svf9  equ   *
* convert data ?
         lm    r14,r15,PS2D1dpb    start and end of data
         sr    r15,r14             length
         bctr  r15,0               machine length
         l     r2,PS2D2d3a         -> target structure
         tm    PS2D3opt,PS2D3cvp   packed decimal ?
         bo    ps2scvp             go do
         tm    PS2D3opt,PS2D3cvb   binary ?
         bo    ps2scvb             go do
.* convert: move
         tm    PS2D3opt,PS2D3qok   keep quotes?
         jo    ps2scpy             yes
         cli   0(r14),c''''        quoted??
         bne   ps2scpy
         llc   r0,PS2D3dl          adjust
         ahi   r0,-2                 data
         stc   r0,PS2D3dl              length
         la    r14,1(,r14)
         bctr  r15,0
         bctr  r15,0
ps2scpy  ex    r15,ps2scvmx        else just move
         tm    PS2D3opt,PS2D3cvu   uppercase?
         bz    ps2scv9             nope
         ex    r15,ps2scvux        then upcase
         b     ps2scv9             and exit
ps2scvmx mvc   PS2D3dat(*-*),0(r14)
ps2scvux oc    PS2D3dat(*-*),PS2D1bln
ps2scvm9 equ   *
.* convert: binary
ps2scvb  cli   PS2D3fl,4           target better be ge 4
         bl    ps2serr7
         ex    r15,ps2scvbx        pack to work area
         cvb   r1,PS2D1dw          to binary
         stcm  r1,15,PS2D3dat      and store
         mvi   PS2D3dl,4           force length 4
 aif ('&trace' eq '').trccvbn
         mvc   PS2D1wrk(4),PS2D3dat
         cvxd  in=PS2D1wrk,out=logr+12,len=4
         log   'bindata:'
.trccvbn anop
         b     ps2scv9
ps2scvbx pack  PS2D1dw,0(*-*,r14)
.* convert: packed decimal
ps2scvp  lr    r3,r15              copy mch length
         sll   r3,4                move up one nibble
         or    r3,r15              copy mch length to low nibble
         ex    r3,ps2scvpx         pack to work area
         b     ps2scv9
ps2scvpx pack  PS2D3dat(*-*),0(*-*,r14)
ps2scvp9 equ   *
.*
ps2scv9  equ   *
ps2svcn  equ   *
 aif ('&trace' eq '').trc8n
      tm    PS2D3opt,PS2D3cvb   binary ?
      bo    trc8n               already done
      mvc   logr+18(*-*),PS2D3dat
      ex    r2,*-6
      la    r15,1(,r2)
      $cvd  r15,logr+12,len=4
      log   'data:'
trc8n equ   *
.trc8n anop
         drop  r4

ps2sldend equ *
         l     r1,PS2D1stp          load last pos
         la    r1,1(,r1)            bump ')'
         l     r1,PS2D1stp          update last pos
         b     ps2slkw0             get next
*-
* positional value support
*-
ps2spp   cnop  0,4
 aif ('&trace' eq '').trcpp1n
      mvlit logr,'positional value support'
      lr    r14,r4
      bctr  r14,0
      mvc   logr+26(2),PS2D1pp
      mvc   logr+30(*-*),0(r7)
      ex    r14,*-6
      log   ,
.trcpp1n anop
*find the entry in the keyword table
*r7 ->start of keyword, r4=length
         la    r5,PS2D1lst           ->table
         l     r8,PS2D1num           number of entries
ps2spptn equ   *
         l     r3,PS2D2nam           -> name
 aif ('&trace' eq '').trcpp2n
      mvlit logr,'name'
      lb    r14,PS2D2len
      bctr  r14,0
      mvc   logr+6(*-*),0(r3)
      ex    r14,*-6
      log   ,
.trcpp2n anop
         clc   PS2D1pp,0(r3)
         bne   ps2sppnx              not positional
         l     r14,PS2D2d3a          -> data area
         Using PS2D3,r14
         cli   PS2D3dl,0
         bne   ps2sppnx              occupied
         sr    r2,r2
         ic    r2,PS2D3fl
         cr    r4,r2
         bh    ps2spper
         stc   r4,PS2D3dl            save length
         bctr  r4,0
         mvc   PS2D3dat(*-*),0(r7)
         ex    r4,*-6
.* upcase positional parm
         tm    PS2D3opt,PS2D3cvu     uppercase?
         bz    *+14                  nope
         oc    PS2D3dat(*-*),PS2D1bln
         ex    r4,*-6                then upcase
 aif ('&trace' eq '').trcpp3n
      log   'positional value added'
.trcpp3n anop
         la    r7,2(r4,r7)
         st    r7,PS2D1stp           save position
         b     ps2slkw0
         drop  r14
ps2sppnx la    r5,PS2D2nxt           -> next entry
         bct   r8,ps2spptn           if any left
.* no free entries
ps2spper la    r15,8
         icm   r14,15,PS2D1msg
         bz    ps2sendx             no message area
         mvc   0(30,r14),=cl30'Positional values exhausted'
         b     ps2sendx             get back

         Macro
&lbl     PS2MSG &rc,&txt
         lcla  &l
&l       seta  (k'&txt)-2
&lbl     la    r15,&rc
         icm   r14,15,PS2D1msg
         bz    ps2sendx             no message area
         mvc   0(&l,r14),=c&txt
         b     ps2sendx             get back
         Mend

         Macro
         ISMSG &rc
         la    r15,&rc
         icm   r14,15,PS2D1msg
         bz    ps2sendx             no message area
         Mend

         Macro
&lbl     PS2MSGKW &rc,&txt
         lcla  &l
&l       seta  (k'&txt)-2
&lbl     la    r15,&rc
         icm   r14,15,PS2D1msg
         bz    ps2sendx             no message area
         mvc   0(&l,r14),=c&txt
         bctr  r4,0
         mvc   &l+1(*-*,r14),0(r7)
         ex    r4,*-6
         b     ps2sendx             get back
         Mend

ps2serr1 ds    0h
 aif ('&trace' eq '').trc9n
        log   'missing end-of-data'
.trc9n anop
         PS2MSG 1,'missing end-of-data'
ps2serr2 ds    0h
 aif ('&trace' eq '').trc10n
        log   'kw not in table'
.trc10n anop
         PS2MSGKW 2,'Keyword not in table:'
ps2serr3 ds    0h
 aif ('&trace' eq '').trc11n
        log   'keyword already found'
.trc11n anop
         PS2MSGKW 3,'Keyword already used:'
ps2serr4 ds    0h
 aif ('&trace' eq '').trc12n
        log   'keyword already found'
.trc12n anop
         PS2MSGKW 4,'Keyword cant have data'
ps2serr6 ds    0h
         icm   r14,15,PS2D1msg
         bz    ps2sendx             no message area
         mvc   0(12,r14),=c'Format error'
         mvc   13(1,r14),0(r3)
         mvc   15(8,r14),0(r7)
         la    r15,6
         b     ps2sendx             get back
ps2serr7 ds    0h
         icm   r1,15,PS2D1msg
         bz    ps2sendx             no message area
         mvc   0(20,r1),=cl20'Field length error'
         lm    r14,r15,PS2D1vpb
         sr    r15,r14
         bctr  r15,0
         mvc   21(*-*,r1),0(r14)
         ex    r15,*-6
         la    r15,7
         b     ps2sendx             get back
.*
ps2send ds     0h
 aif ('&trace' eq '').trc14n
        log   'string end'
.trc14n anop
         sr    r15,r15
         b     ps2sendx
         drop  r5
ps2send8 equ   *
         lr    r0,r7
         la    r15,8
ps2sendx equ   *
         l     r13,4(,r13)
         l     r14,12(,r13)
         lm    r2,r12,28(r13)
         br    r14
         ltorg
ps2svfat dc    256al1(*-ps2svfat)     verify alpha-num
         org   ps2svfat+c'A'
         dc    9x'00'                 ABCDEFGHI
         org   ps2svfat+c'J'
         dc    9x'00'                 JKLMNOPQR
         org   ps2svfat+c'S'
         dc    8x'00'                 STUVWXYZ
         org   ps2svfat+c'a'
         dc    9x'00'                 abcdefghi
         org   ps2svfat+c'j'
         dc    9x'00'                 jklmnopqr
         org   ps2svfat+c's'
         dc    8x'00'                 stuvwxyz
         org   ps2svfat+c'$'
         dc    x'00'
         org   ps2svfat+c'.'
         dc    x'00'
         org   ps2svfat+c'@'
         dc    x'00'
         org   ps2svfat+c'#'
         dc    x'00'
         org   ps2svfat+c'0'
         dc    10x'00'                0123456789
         org
ps2svfct dc    256al1(*-ps2svfct)     verify char
         org   ps2svfat+c'A'
         dc    9x'00'                 ABCDEFGHI
         org   ps2svfat+c'J'
         dc    9x'00'                 JKLMNOPQR
         org   ps2svfat+c'S'
         dc    8x'00'                 STUVWXYZ
         org   ps2svfat+c'a'
         dc    9x'00'                 abcdefghi
         org   ps2svfat+c'j'
         dc    9x'00'                 jklmnopqr
         org   ps2svfat+c'$'
         dc    x'00'
         org   ps2svfat+c'@'
         dc    x'00'
         org   ps2svfat+c'#'
         dc    x'00'
         org
ps2svfnt dc    256al1(*-ps2svfnt)     verify numerics
         org   ps2svfnt+c'0'
         dc    10x'00'
         org
         drop  r10,r11
         pop   using
.modulen anop
         mnote *,'#parm: &strparsn'
&thissect csect
.*-
.*       inline area
.*-
&s3      setc  (Upper '&area')
         aif   ('&s3' ne 'Y').x
* inline area
&s3      setc  'p&sysndx.arean'
         b     &s3
         mnote *,'StrParse Inline area'
         mnote *,'#parm: &strparsn'
         StrParse AREA
&s3      ds    0a
.*
         Mexit
.*-
.*       area definitions
.*- ds
.ds      anop
&s2      setc  (Upper '&syslist(2)')
         aif   ('&s2' eq 'F').dsf
         aif   ('&strparsalign' ne 'F').ds1an
&lbl._pfx  ds    0f                      align=F
&lbl._z  ds    x
.ds1an   anop
&plst    setc  (Upper '&l')
         aif   ('&plst' eq 'Z').dsl
&lbl._op ds    x
&lbl._fl ds    x
&lbl._dl ds    x
&lbl        ds    cl&s2
         mexit
.dsf     ds    0a,1x
&lbl._op ds    x
&lbl._fl ds    x
&lbl._dl ds    x
&lbl        ds    f
         mexit
.dsl     anop
&lbl._op ds    al1                    options
&lbl._cn ds    al1                    count
&lbl._fl ds    al2                    field length
&lbl        ds    0x                     start of list
         mexit
.*- dc
.dc      anop
         aif   ('&SYSSTYP' eq 'CSECT').dcopt
         mnote 4,'Section type should be CSECT, not &sysstyp'
.*       mexit
.*   &sln     seta  3                      past 'dc,len,'
.*   &oln     seta  0                      first inside
.*   &rtn     setc  'DC'
.*            ago   .opt2
.dcopt   anop
&qopt    setc  (Upper '&q')
&pvfy    setc  (Upper '&v')
&pcnv    setc  (Upper '&c')
         aif   ('&pcnv' ne 'P').dcoptpn   if packed
&pvfy    setc  'N'                        then must be numeric
.dcoptpn anop
&plst    setc  (Upper '&l')
         aif   ('&plst' eq 'Y').dc2l
&s2      setc  (Upper '&syslist(2)')  length
         aif   ('&s2' eq 'F').dc2f    full-word
         aif   ('&strparsalign' ne 'F').dc1an
&lbl._pfx  ds    0f                      align=F
&lbl._z  ds    x
.dc1an   anop
&lbl._op dc    al1(PS2D3vf&pvfy+PS2D3cv&pcnv+PS2D3qo&pqopt)
&lbl._fl dc    al1(&s2)
&lbl._dl dc    al1(0)
&lbl        dc    cl&s2.' '
         Mexit
.dc2f    ds    0a,1x
&lbl._op dc    al1(PS2D3vfN+PS2D3cvB)
&lbl._fl dc    al1(4)
&lbl._dl dc    al1(0)
&lbl        dc    f'0'
         Mexit
.dc2l    ds    0a
&lbl._op dc    al1(PS2D3vf&pvfy+PS2D3cv&pcnv+PS2D3lst+PS2D3qo&pqopt)
&lbl._cn dc    al1(0)                 count
&lbl._fl dc    al2(&syslist(2))
&lbl        ds    0x                     start of list
         Mexit
.*
.strerr1 mnote 8,'Number of string parms ne 2'
         Mexit
.*== do over optlist
.opt2    anop
&pvfy    setc  'Z'
&pcnv    setc  'Z'
&pqopt   setc  'Z'
&plst    setc  'N'
&pabr    setc  '0'
&plen    setc  '?'
&setini  setc  '?'
&setinil seta  0
.optnext anop  , next
&oln     seta  &oln+1
         aif   (&oln gt n'&syslist(&sln)).opt2x
&opt     setc  '&syslist(&sln,&oln)'
&optl    seta  k'&opt
         aif   (&optl ge 3).optl9
         mnote 8,'*Length error: &opt'
         mexit
.optl9   anop
&optu    setc  (Upper '&opt')
&optd    setc  '&optu'(3,&optl-2)
.*       mnote *,'sln: &sln, iln: &oln opt: &opt / &optu, optd: &optd'
         aif   ('&optu'(1,2) eq 'V=').optfmt
         aif   ('&optu'(1,2) eq 'C=').optcnv
         aif   ('&optu'(1,2) eq 'A=').optabr
         aif   ('&optu'(1,2) eq 'I=').optini
         aif   ('&optu'(1,2) eq 'L=').optlen
         aif   ('&optu'(1,2) eq 'Q=').optqt
         aif   ('&optu'      eq 'L=Y').optlst
         mnote 8,'*Invalid option &opt in &sln,&oln'
         mexit
.optabr  anop
&pabr    setc  '&optd'
         ago   .optnext
.optlen  anop
&plen    setc  '&optd'
         ago   .optnext
.optqt   anop
&pqopt   setc  '&optd'
         ago   .optnext
.optfmt  anop
&pvfy    setc  '&optd'
         ago   .optnext
.optfmtn anop
&pvfy    setc  'N'
         ago   .optnext
.optcnv  anop
&pcnv    setc  '&optd'
         aif   ('&optd' eq 'B' or '&optd' eq 'P').optfmtn
         ago   .optnext
.optlst  anop
&plst    setc  'Y'
         ago   .optnext
.optini  anop
&setinil seta  k'&opt-2
&setini  setc  '&opt'(3,&optl-2)
         ago   .optnext
.opt2x   anop
         aif   ('&trn' eq 'CALL').callopt
.*       aif   ('&trn' eq 'DC').dcopt
         mnote 8,'*Invalid opt2 return: &rtn'
         Mexit
.*== optlist end
.*== build remote data list
.area    anop
         mnote *,'#parm: &strparsn'
&n       seta    0
.area100 anop
         aif   (&n ge &strparsn).area999
&n       seta  &n+1
&name    setc  '&strparsl(&n)'
&pvfy    setc  '&strparsf(&n)'
&pcnv    setc  '&strparsc(&n)'
&qopt    setc  '&strparsq(&n)'
&plen    setc  '&strparsk(&n)'
&name    StrParse ds,&plen,v=&pvfy,c=&pcnv,q=&pqopt
         ago   .area100
.area999 Mexit
.*-
.* XLA - subroutine, generate Lx instruction
.*-
.xla     anop
         lclc  &xlar,&xlap,&xla
         lcla  &xlapn,&xlan
&xlalen  setc   ''
&xlar    setc  '&syslist(2)'
&xlapn   seta  2
.xlanext anop
&xlapn   seta  &xlapn+1
         aif   (&xlapn gt n'&syslist).xlax
&xlap    setc  '&syslist(&xlapn)'
         aif   (k'&xlap eq 0).xlanext
         aif   ('&xlap '(1,1) eq '(').xlareg
         aif   ('&xlap '(1,1) eq '''').xlalit
         aif   ('&xlap '(2,1) eq '.').xlafld
&xla     setc  t'&xlap
         aif   ('&xla' eq 'N').xlanum
&lbl     la    &xlar,&xlap
         aif   ('&xlap  '(1,2) eq 'l''').xlax
&xlalen  setc   'l''&xlap'
         mexit
.xlanum  anop
&lbl     lgfi  &xlar,&xlap
         mexit
.xlafld  anop
&xlan    seta  k'&xlap-2
&xla     setc  '&xlap'(1,1)
&xlap    setc  '&xlap'(3,&xlan)
&xla     setc  lower('&xla')
         aif   ('&xla' ne 'c').xlafld1
&lbl     sr    &xlar,&xlar
         ic    &xlar,&xlap
         mexit
.xlafld1 aif   ('&xla' ne 'f').xlafld2
&xla     setc  ''
.xlafld2 anop
&lbl     l&xla &xlar,&xlap
         mexit
.xlareg  anop
&xlan    seta  k'&xlap-2
&xlap    setc  '&xlap'(2,&xlan)
&lbl     lr    &xlar,&xlap
         mexit
.xlalit  anop
&lbl     la    &xlar,=c&xlap
&xlan    seta  k'&xlap-2
&xlalen  setc  '&xlan'
.xlax    mexit
.x       Mend
.* ADD NAME=STRPATRN
         Macro
.*-
.* Test string against a pattern/mask.
.*
.* Syntax
.*  STRPATRN DATA=data-addr,MASK=mask-addr,WC=ao|*%
.*
.*   'addr' is either a label, or (label,len) or 'literal'. 'label'
.*   and 'len' may be a register like (rn) or f/h/b/c.label to load
.*   from a fullword, halfword, byte or char field. See .XLA below.
.*   The mask may contain wildcards % for a single char and * for
.*   multiple or no chars.
.*   'ao' mask chars for all or none, or any one char. default is *%.
.*   STR= can be used instead of DATA=. This will probably be removed
.*   in a later version, so please use DATA=.
.*
.* Returns result in r15:
.*   0  Data matches mask
.*  >1  Data does not match mask, code indicates where in STRPATRN
.*      the check failed. Additional info is returned as follows:
.*        r0 -> data addr when check failed
.*        r1 -> mask addr when check failed
.*
.* Operation
.*   First time the macro is invoked an internal CSECT is generated,
.*   further macro invocations call the same CSECT.
.*   The save area pointed to by r13 is used as work area both for
.*   the call parameters and for saving registers. Registers 4-12 are
.*   restore when the program returns, registers 2 and 3 are not used
.*   so need not be preserved. Registers 0, 1, 14 and 15 are changed
.*   by the macro.
.*
.* Samples
.*    STRPATRN data=text1,mask=mask1
.*    STRPATRN data='ABCDE',mask='A%C*'
.*    STRPATRN data=((r2),(r3)),mask=(f.maskaddr,b.masklen)
.*    STRPATRN data=text1,mask='Doc*Brit*'
.*    . .
.*  text1    dc    c'Doctor Who is a British sci-fi TV series'
.*  mask1    dc    c'*Who*Brit*'
.*  maskaddr ds    a       contains address of mask
.*  masklen  ds    al1     max len 128 as field is signed
.*
.* Note that IBM supplies a similar function in macro ASAXWC in
.* SYS1.MODGEN. STRPATRN, however, is simpler to use and test has
.* shown it to be up to 4 times as fast as ASAXWC.
.*
.* History
.*  2019-12-01  Total rewrite, so is now new base
.*  2020-07-21  Fix false negative with equal mask- and string length
.*
.* Author
.*     Willy Jensen
.*     mail: willy@harders-jensen.com
.*     web : http://harders-jensen.com/wjtech
.*-
&ml      STRPATRN &str=,&data=,&mask=,&wc='*%'
         lclc  &l,&s,&c
         lcla  &qn
&l       setc  'sp&sysndx'
         gblb  &$STRPATRN
.* xla sub
         gblc  &xlalen
&s       setc  Upper('&syslist(1)')
         aif   ('&s' eq 'XLA').xla
.* call
&ml      la    r1,8(,r13)
         STRPATRN XLA,r14,&data(1),&str(1)
         STRPATRN XLA,r15,&data(2),&str(2),&xlalen,1
         stm   r14,r15,0(r1)
         STRPATRN XLA,r14,&mask(1)
         STRPATRN XLA,r15,&mask(2),&xlalen,1
         stm   r14,r15,8(r1)
         STRPATRN XLA,r14,&wc
         mvc   16(2,r1),0(r14)
         mvc   18(2,r1),=x'0000'
         l     r15,=v(ZTRPATRN)
         basr  r14,r15
         aif   (&$STRPATRN).x
&$STRPATRN setb 1
         j     &l.ltn
         ltorg
&l.ltn   ds    0a
* STRPATRN module
* r14  return address
* r12  basereg
* r11  -> string
* r10  -> mask
* r9   -> string end
* r8   -> mask end
* r7   wildcards : byte0 is 'all', byte1 = one
* r6   -> save mask ptr
* r5   -> last '*'
* r2-r4 are not used, they are not saved and restored as that space in
* the save area is used for the parm block.
&s       setc  '&sysect'
ZTRPATRN Amode 31
ZTRPATRN Rmode any
ZTRPATRN Csect
         save  (4,12)
         push  using
         lr    r12,r15
         using ZTRPATRN,r12
* set up registers
         using zptrnblk,r1
         l     r11,zptrnsa            -> string
         l     r9,zptrnsl             string length
         ar    r9,r11                 -> past string
         ahi   r9,-1                  -> end of string
         l     r10,zptrnma            -> mask
         l     r8,zptrnml             mask length
         ar    r8,r10                 -> past mask
         ahi   r8,-1                  -> end of mask
         l     r7,zptrnwc             wild cards and opts
* special case, mask='*' (fix 2020-07-21)
         la    r15,1
         c     r15,zptrnml            masklen=1 ?
         jne   &l.f001                no
         clm   r7,8,0(r10)            mask = '*' ?
         je    &l.q0                  yes
&l.f001  equ   *
*-
* Frontend - till '*' or end of mask or end of string
*-
         drop  r1
&l.f100  equ   *
         clm   r7,8,0(r10)            '*' ?
         je    &l.f400                then go handle block

* test char
&l.f200  equ   *
         clm   r7,4,0(r10)            '%' ?
         je    &l.f300                yes
         clc   0(1,r10),0(r11)        same char in string and mask?
         jne   &l.fe01                no, abort

* char ok, check/bump pointers
&l.f300  equ   *
         sr    r1,r1                  mask must also not be at end
         cr    r10,r8                 end of mask?
.*       jnh   &l.f302                nope        (fix 2020-07-21)
         jne   &l.f302                nope
         ahi   r1,1                   mask
&l.f302  cr    r11,r9                 end of data?
.*       jnh   &l.f304                nope        (fix 2020-07-21)
         jne   &l.f304                nope
         ahi   r1,1                   mark
&l.f304  ltr   r1,r1                  both before end?
         jz    &l.f310                good
         clfi  r1,2                   both are at the end
         je    &l.q0                  good
         cr    r10,r8                 end of mask?
         je    &l.fe03                mask end before string end

* string end before mask end, check if mask+1='*' and end of mask
         ahi   r10,1                  -> past '*'
         cr    r10,r8                 now end of mask?
         jne   &l.fe04                sadly not
         clm   r7,8,0(r10)            '*' ?
         je    &l.q0                  ok
         j     &l.fe05                bad

* both mask and string within bounds, bump and try next
&l.f310  equ   *
         ahi   r10,1                  bump mask ptr
         ahi   r11,1                  bump string ptr
         j     &l.f100                continue frontend processing

* mask (r10->) chr is '*'
&l.f400  equ   *
         cr    r10,r8                 end of mask?
         je    &l.q0                  yup, all is well

* handle multiple consequitive '*'
&l.f410  equ   *
         ahi   r10,1                  -> past '*'
         cr    r10,r8                 end of mask?
         je    &l.f430
         clm   r7,8,0(r10)            mask is * ?
         je    &l.f410                yes

* not end of mask, not '*'
&l.f420  equ   *
         ahi   r10,-1                 -> * ?
         j     &l.f500                go prep for mid- and backend

* end of mask
&l.f430  equ   *
         clm   r7,8,0(r10)            mask is * ?
         je    &l.q0                  yes
* small backend of one char
         clm   r7,4,0(r10)            mask is % ?
         je    &l.q0                  yes
         clc   0(1,r10),0(r11)        char match ?
         je    &l.q0                  yes
         j     &l.fe06

* mask chr (r10->) is '*', locate last '*' in mask
* if this '*' is also last '*' in mask then just do backend
&l.f500  equ   *
         lr    r5,r8                  -> mask end
&l.f510  equ   *
         cr    r5,r10                 test against located '*'
         je    &l.f520                reached that
         clm   r7,8,0(r5)             is mask '*' ?
         je    &l.f530                yes
         bct   r5,&l.f510             else go test next

* last '*' = first '*' then no mid section, go do backend
&l.f520  equ   *
         j     &l.bep

* last '*' <> first '*' then there is a mid section
&l.f530  equ   *
         j     &l.msp

* Set return codes
&l.fe01  la    r15,101
         j     &l.qx
&l.fe02  la    r15,102
         j     &l.qx
&l.fe03  la    r15,103
         j     &l.qx
&l.fe04  la    r15,104
         j     &l.qx
&l.fe05  la    r15,105
         j     &l.qx
&l.fe06  la    r15,106
         j     &l.qx

*-
* mid section processing, find matching block in string.
* at entry: r10 -> position in mask, r11 -> position in text
* r6  -> save mask ptr
* r5  -> last '*'
*-
&l.msp   equ   *

* handle multiple '*'
&l.m010  equ   *
         ahi   r10,1                  -> past '*'
         clm   r7,8,0(r10)            mask is * ?
         jne   &l.m100                init properly
         cr    r10,r5                 = last '*' ?
         je    &l.m020                yes
         cr    r10,r8                 end of mask?
         je    &l.q0
         j     &l.bep                 else go do backend

* r10 -> last '*', also mask end?
&l.m020  equ   *
         cr    r10,r8                 mask end too?
         je    &l.q0                  then all is good
         j     &l.bep                 else do backend

* (re)start at submask
&l.m100  equ   *
         lr    r6,r10                 work mask ptr -> past '*'

&l.m200  equ   *
         cr    r6,r5                  mask work ptr gt subend?
         jh    &l.m100                then iterate
&l.m210  equ   *
         cr    r11,r9                 string gt end?
         jh    &l.me01                then error

* test match
&l.m300  equ   *
         clm   r7,4,0(r6)             mask is % ?
         je    &l.m310
         clc   0(1,r6),0(r11)         mask matches string?
         jne   &l.m400                nope, try next
* char match
&l.m310  equ   *
         ahi   r6,1                   bump maskworkptr
         cr    r6,r5                  last submsk done?
         je    &l.m600                yes, do backend
         clm   r7,8,0(r6)             mask is * ?  (submask end)
         je    &l.m500                nope
         ahi   r11,1                  bump strptr
         j     &l.m210                cont with test

* char don't match
&l.m400  equ   *
         cr    r6,r10                 past 1st char?
         jh    &l.m410                yes
         ahi   r11,1                  bump strptr
         j     &l.m100                restart submask
&l.m410  equ   *
         j     &l.m100                restart submask

* submask end
&l.m500  equ   *
         la    r10,1(,r6)             -> past '*'
         ahi   r11,1                  bump strptr
         j     &l.m100                restart submask

* work ptr -> last '*'
&l.m600  equ   *
         cr    r6,r8                  also end of mask?
         je    &l.q0
         lr    r10,r6
         j     &l.bep

* Set return code
&l.me01  la    r15,201
         j     &l.qx
&l.me02  la    r15,202
         j     &l.qx
&l.me03  la    r15,203
         j     &l.qx
&l.me04  la    r15,204
         j     &l.qx
&l.me05  la    r15,205
         j     &l.qx
&l.me06  la    r15,206
         j     &l.qx

*-
* backend procesing, scan backwards till '*'
* r11 -> string pos
* r10 -> last '*'
* r9  -> last byte of pos
* r8  -> last byte of mask
*-
&l.bep   equ   *
         ahi   r10,1
         lr    r4,r8
         sr    r4,r10                 length of backend
         lr    r5,r9
         sr    r5,r11                 length of str remainder
         cr    r5,r4
         jl    &l.be01

&l.b100  equ   *
         clm   r7,4,0(r8)             mask is % ?
         je    &l.b200                bad if not
         clc   0(1,r8),0(r9)          mask = text?
         jne   &l.be03                bad if not
&l.b200  equ   *
         cr    r8,r10                 locate last mask?
         jnh   &l.q0                  then all ok

&l.b300  equ   *
         ahi   r9,-1                  decr string ptr
         bct   r8,&l.b100             decr mask ptr

&l.be01  equ   *
         la    r15,301
         j     &l.be99
&l.be02  equ   *
         la    r15,302
         j     &l.be99
&l.be03  equ   *
         la    r15,303
         j     &l.be99
&l.be99  equ   *
         lr    r0,r9                  copy string addr for reporting
         lr    r1,r8                  copy mask addr for reporting
         j     &l.qx

*-
* return
*-
&l.q0    equ   *                      set good rc
         sr    r15,r15                set good rc
&l.qx    lr    r0,r11                 updated str addr for reporting
         lr    r1,r10                 updated mask addr for reporting
         return (4,12)
         ltorg
         pop   using

zptrnblk dsect
zptrnsa  ds    a                      string address
zptrnsl  ds    a                      string length
zptrnma  ds    a                      mask address
zptrnml  ds    a                      mask length
zptrnwc  ds    a                      wild cards etc
zptrnblkl equ  *-zptrnblk
.* resume main
&s       Csect                        resume main
         Mexit
.*-
.* $$LA - subroutine, generate Lx instruction (shortened $LA)
.* Syntax: $$LA  reg,what1,what2,,whatn
.*         what: label or (reg) or 'literal' or f/h/b/c.label
.*               c.label -> reg is cleared and the entire byte loaded
.*               1st non-null what is used
.*-
.xla     anop
         lclc  &xlar,&xlap,&xla
         lcla  &xlapn,&xlan
&xlalen  setc   ''
&xlar    setc  '&syslist(2)'
&xlapn   seta  2
.xlanext anop
&xlapn   seta  &xlapn+1
         aif   (&xlapn gt n'&syslist).xlax
&xlap    setc  '&syslist(&xlapn)'
         aif   (k'&xlap eq 0).xlanext
         aif   ('&xlap '(1,1) eq '(').xlareg
         aif   ('&xlap '(1,1) eq '''').xlalit
         aif   ('&xlap '(2,1) eq '.').xlafld
&xla     setc  t'&xlap
         aif   ('&xla' eq 'N').xlanum
&ml      la    &xlar,&xlap
         aif   ('&xlap  '(1,2) eq 'l''').xlax
&xlalen  setc   'l''&xlap'
         mexit
.xlanum  anop
&ml      lgfi  &xlar,&xlap
         mexit
.xlafld  anop
&xlan    seta  k'&xlap-2
&xla     setc  '&xlap'(1,1)
&xlap    setc  '&xlap'(3,&xlan)
&xla     setc  lower('&xla')
         aif   ('&xla' ne 'c').xlafld1
&ml      sr    &xlar,&xlar
         ic    &xlar,&xlap
         mexit
.xlafld1 aif   ('&xla' ne 'f').xlafld2
&xla     setc  ''
.xlafld2 anop
&ml      l&xla &xlar,&xlap
         mexit
.xlareg  anop
&xlan    seta  k'&xlap-2
&xlap    setc  '&xlap'(2,&xlan)
&ml      lr    &xlar,&xlap
         mexit
.xlalit  anop
&ml      la    &xlar,=c&xlap
&xlan    seta  k'&xlap-2
&xlalen  setc  '&xlan'
.xlax    mexit
.x       Mend
.* ADD NAME=STRP2D
         Macro
.*-
.* STRP2D - String convert packed decimal to zoned decimal
.*
.* Syntax
.*  STRP2D FROM=(addr,len),TO=(addr,len)
.*        addr      label, (reg), F.label
.*        from-len  1-4
.*        to-len    default is from-len*3
.*
.* The  macro calls  an internally  generated subroutine.  This
.* shortens the code length  for multiple executions of STRC2B,
.* though adds a bit to the program complexity.
.*
.* Returns
.*  r0  = length of output
.*
.* Notes
.*  registes 0,1,14,15 are used by the macro
.*-
&ml      StrP2D &from=,&to=
         lclc  &l,&s,&froml,&tol
         gblb  &$STRP2D
         gblc  &$lalenc
&l       setc  'PD&sysndx'
&ml      $la   r15,&from(1)
&froml   setc  '&$lalenc'
         $la   r0,&to(1)
&tol     setc  '&$lalenc'
         $la   r1,&from(2),&froml
         $la   r14,&to(2),0
         sll   r1,16
         ar    r1,r14
         l     r14,=v(ZSTRP2D)
         basr  r14,r14
.* module
         aif   (&$STRP2D).x            already done
&$STRP2D setb  1
&s       setc  '&sysloc'
ZSTRP2D  Amode 31
ZSTRP2D  Rmode any
ZSTRP2D  CSECT
         stm   r14,r2,12(r13)
         basr  r2,0
         ahi   r2,-6
         push  using
         using ZSTRP2D,r2
.* setup source length
         lh    r14,24(,r13)
.* setup target length
         lh    r15,26(,r13)
         ltr   r15,r15
         jnz   *+10
         lr    r15,r14                  use source
         sll   r15,1                    length*2
         lr    r0,r15                   save target length
.* compute and run
         bctr  r14,0
         bctr  r15,0
         sll   r15,4
         ar    r15,r14
         l     r14,16(,r13)            from
         l     r1,20(,r13)             to
         ex    r15,&l.a
         j     &l.a+6
&l.a     unpk  0(*-*,r1),0(*-*,r14)
         srl   r15,4                   leave mch tgt len
         ar    r1,r15
         oi    0(r1),x'F0'
.* back
         l     r14,12(r13)
         l     r2,28(r13)
         bsm   0,r14
         drop  r2
         pop   using
&s       Loctr                         resume main
.x       MEND
.* ADD NAME=OPCOMM
         MACRO
.*
.* Get modify/stop console response
.* format of 'marea':
.*   pos  len  desc
.*    1    2   length of text
.*    3    n   text
.*
.* Call type
.*   INIT    setup control clocks
.*   GET     test for command, r15=4 if no command waiting
.*   WAIT    wait for a command
.*
.* Sample
.*           OPCOMM INIT
.*           OPCOMM GET,MAREA=comresp
.*           OPCOMM WAIT,MAREA=comresp
.*  comresp  ds    0CL100
.*  comlen   dc    al2(0)
.*  comtext  dc    cl98' '
.*
&NAME    OPCOMM &FUNC,&NUM=1,&MAREA=,&STOP=STOP,&COMBLK=OPCOMM
         LCLA  &N,&M
         LCLC  &L,&C,&s
&L       SETC  'OP&SYSNDX'
.*
&S       SETC  Upper('&func')
         AIF   ('&s' EQ 'INIT').INIT
         AIF   ('&s' EQ 'WAIT').WAIT
         AIF   ('&s' EQ 'GET').GET
         AIF   ('&s' EQ 'DS').DS
         AIF   ('&s' EQ 'DSECT').DSECT
         MNOTE 8,'*** ERROR - INVALID FUNCTION - &FUNC'
         Mexit
.*
.*--------------------------------------------------------------------*
.INIT    ANOP
** Init
** obtain address of cib
&NAME    CNOP  0,4
         xc    &comblk.(&comblk.bl),&comblk
         la    r1,&comblk
         LA    R14,&comblk.ra          -> REPLY AREA
         EXTRACT (R14),FIELDS=COMM,MF=(E,&comblk)
.*--------------------------------------------------------------------*
**   FREE START CIB
         L     R14,&comblk.ra          -> COMM AREA
         USING iezcom,R14              COVER
         L     R15,COMCIBPT            -> CIB
         USING iezcib,R15              COVER
         CLI   CIBVERB,CIBSTART        START CIB ??
         BNE   &L.LM                   NOPE - GO SET LIMIT
         QEDIT ORIGIN=COMCIBPT,BLOCK=(R15)
         DROP  R14,R15
         LTR   R15,R15                 OK ??
         BNZ   &L.X4                   ELSE GET OUT NOW
.*--------------------------------------------------------------------*
**   SET LIMIT OF OUTSTANDING MODIFYES
&L.LM    L     R14,&comblk.ra          -> COMM AREA
         LA    R14,COMCIBPT-iezcom(,R14)  -> COM CIBP
         QEDIT ORIGIN=(R14),CIBCTR=&NUM
&L.X4    CNOP  0,4
         LTR   R15,R15                 SET RETURN CODE
         mexit
.*
.*--------------------------------------------------------------------*
.WAIT    ANOP
**   WAIT FOR OPERATOR
         AIF   (K'&MAREA(1) GT 0).WAI0100
         MNOTE 8,'*** ERROR - MISSING OPERAND - MAREA'
         mexit
.WAI0100 ANOP
         xc    &marea.(2),&marea       reset length field
         mvi   &marea+2,c' '           reset 1st text byte
         L     R2,&comblk.ra           -> COMM AREA
         USING iezcom,R2               COVER
         L     R1,COMECBPT             -> ECB
         WAIT  ECB=(R1)
         ago   .GetRply
.*
.*--------------------------------------------------------------------*
.GET     ANOP
**   get reply if ecb is posted
         AIF   (K'&MAREA(1) GT 0).GET0100
         MNOTE 8,'*** ERROR - MISSING OPERAND - MAREA'
         MEXIT
.GET0100 ANOP
         xc    &marea.(2),&marea       reset length field
         mvi   &marea+2,c' '           reset 1st text byte
         L     R2,&comblk.ra           -> COMM AREA
         USING iezcom,R2               COVER
         L     R1,COMECBPT             -> ECB
         tm    0(r1),x'40'             (ECBPOST)  Posted?
         jo    *+12                    yup
         la    r15,4
         j     &l.x
         ago   .GetRply
.*
.*--------------------------------------------------------------------*
.GetRply ANOP
**  GET REPLY FROM OPERATOR
         L     R3,COMCIBPT             -> CIB
         USING iezcib,R3               COVER CIB
         LA    R1,CIBDATLN             -> DATA IN CIB
         CLI   CIBVERB,CIBMODFY        MODIFY ??
         BE    &L.M1                   YES - MOVE IN REPLY
         CLI   CIBVERB,CIBSTOP         STOP ??
         BNE   &L.E2                   NOPE - ERROR
         LA    R1,&L.stop              -> STOP VALUE
         B     &L.M1                   AND MOVE IN AS REPLY
&L.E2    LA    R15,8                   SET BAD ID
         j     &L.X6
&L.M1    LH    R15,0(,R1)              GET LENGTH OF DATA
         la    r14,2(,r1)              -> data
         cli   0(r14),c''''            quoted?
         jne   &l.m2
         la    r14,1(,r14)             bump ptr
         ahi   r15,-2                  adjust length
&l.m2    LA    R0,l'&marea.-2          SET MAX LENGTH
         CR    R15,R0                  CHECK MAX LENGTH
         BNH   &l.m3                   OK THEN BUMP
         LR    R15,R0                  ELSE SET MAX
&l.m3    STCM  R15,3,&marea            SAVE IN RECEIVING AREA
         BCTR  R15,0                   GET MCH LEN
         EX    R15,&L.TX               COPY TEXT
         SLR   R15,R15                 SET GOOD RC
         j     &L.X6                   AND GET OUT
&N       SETA  K'&STOP
&L.STOP  DC    al2(&N),C'&STOP'        STOP VALUE
&l.tx    mvc   &marea.+2(*-*),0(r14)   get text
&L.X6    CNOP  0,4
.*--------------------------------------------------------------------*
**  FREE CIB
         QEDIT ORIGIN=COMCIBPT,BLOCK=(R3)
         DROP  R2,R3
         ago   .x
.*
.*--------------------------------------------------------------------*
**  Data map
.ds      ANOP  ,                       BUILD RPL LIST
&s       setc  '&name'
         aif   ('&s' ne '').ds0100
&s       setc  'OPCOMM'
.ds0100  anop
&s       ds    0a
&s.xf    EXTRACT FIELDS=COMM,MF=L
&s.ra    ds    a                       -> QEDIT RESPONSE AREA
&s.bl    equ   *-&s
         Mexit
.*--------------------------------------------------------------------*
.dsect   ANOP  ,                       BUILD RPL LIST
**   dsects
         PRINT NOGEN
IEZCOM   DSECT
         IEZCOM
IEZCIB   DSECT
         IEZCIB
         Mexit
.*
.*-- END OF MACRO ----------------------------------------------------*
.x       anop
&l.x     cnop  0,4
         MEND
.* ADD NAME=SLNKLST
         MACRO
.*-
.* Single-linked list
.* Syntax:
.*   label  SLNKLST ADD,SIZE=n,ADDR=addr|0
.*   label  SLNKLST NEXT,ADDR=addr
.*   label  SLNKLST DROP,ADDR=addr,PREV=addr|0
.*   label  SLNKLST DROPALL,ADDR=addr-of-first
.*   label  SLNKLST ANCHOR
.*          n        Value, (reg) or f.label
.*          addr     Label, (reg) or f.label
.*                   Can be '0' for ADD, in which case neither
.*                   forward nor backward pointers are updated -
.*                   note that '0' may be a register with zeroes.
.*                   f.label => l  reg,label
.*   registers after ADD and NEXT:
.*     r1 -> block, r0 -> data section. r1 is 0 if no next.
.*
.* Samples
.*
.* add first
.*           SLNKLST add,size=textl,addr=0
.*           st    r1,SLNKlsta
.*
.* add 2 entries (first and second)
.*           la    r8,SLNKLSTA
.*           SLNKLST add,size=textl,addr=(r8)
.*           lr    r8,r1
.*           SLNKLST add,size=textl,addr=(r8)
.*           st    r8,SLNKLSTE               save address of last
.* add 1 after last
.*           l     r8,SLNKLSTE
.*           SLNKLST add,size=textl,addr=(r8)
.* drop one
.*           SLNKLST drop,addr=(r2),prev=(r3)
.* drop all
.*           SLNKLST dropall,addr=f.SLNKLSTA
.* scan list
.*           l     r2,SLNKLSTA             -> first
.*  SCAN     equ   *
.*        .. do something ..
.*           SLNKLST next,addr=(r2)
.*           ltr   r2,r1
.*           jnz   SCAN
.*
.*  SLNKLSTA dc   a(0)
.*  SLNKLSTE dc   a(0)
.*
.* Changelog
.*  2019-01-05  Expand dsect at first call, unless DSECT=N
.*
.* By
.*  Willy Jensen
.*     mail: willy@harders-jensen.com
.*  web : http://harders-jensen.com/wjtech/index.html
.*-
&ml      SLNKLST &addr=,&prev=,&clear=,&size=,&sp=0,&data=,&trace=,    c
               &dsect=Y
         lclc  &que,&s,&l
         lcla  &nexto,&sizeo,&datao,&poolo,&pfxl
         gblc  $xlalen
&nexto   seta  0
&sizeo   seta  4
&poolo   seta  8
&datao   seta  12
&pfxl    seta  12
&l       setc  'SLL&sysndx'
         gblb  @SLNKlst
&que     setc  Upper('&syslist(1)')
         aif   ('&que' eq 'XLA').xla
         aif   ('&que' eq 'DSECT').dsect
         aif   ('&que' eq 'ANCHOR').anchr
         aif   (k'&addr eq 0).err2      ADDR= required for rest
.*
         aif   ('&dsect' ne 'Y' or &@SLNKlst).dsct1n
&s       setc  '&sysect'
         SLNKLST DSECT
&s       Csect
.dsct1n  anop
.*
         aif   ('&que' eq 'ADD').add
         aif   ('&que' eq 'NEXT').next
         aif   ('&que' eq 'DROP').drop
         aif   ('&que' eq 'DROPALL').dropa
err1     mnote 8,'***Error invalid option'
         mexit
err2     mnote 8,'***Error ADDR parm is required'
         mexit
err3     mnote 8,'***Error PREV parm is required'
         mexit
.*-
.* add new entry
.*-
.ADD     ANOP
&ml      SLNKLST XLA,r0,&sp
*getmain
         SLNKLST XLA,r14,&size
         la    r14,&pfxl.(,r14)        add prefix
         Getmain R,lv=(14),bndry=DBLWD,sp=&sp
         xc    0(&pfxl,r1),0(r1)
         st    r14,&sizeo.(,r1)        save size
         aif   ('&sp' eq '0').sp0
         SLNKLST XLA,r0,&sp
         stc   r0,&poolo.(,r1)         save subpool
.sp0     anop
.* chain
*chain
         SLNKLST XLA,r15,&addr
         ltr   r15,r15                 any current
         jz    &l.b                    else bypass chaining
         l     r14,&nexto.(r15)        -> next
         st    r1,&nexto.(r15)         set next in current
         st    r14,&nexto.(,r1)        set next in new
&l.b     equ   *
.* clear
&s       setc  Upper('&clear')
         aif   ('&s '(1,1) ne 'Y').addcn
*clear
         st    r1,24(,r13)
         la    r0,&datao.(,r1)         set target addr
         SLNKLST XLA,r1,&size
         sr    r14,r14
         sr    r15,r15
         mvcl  r0,r14
         l     r1,24(,r13)
.addcn   anop
         aif   (n'&data eq 0).adddn
*get data
         SLNKLST XLA,r14,&data(1)
         SLNKLST XLA,r15,&data(2),&$xlalen
         st    r1,24(,r13)
         la    r0,&datao.(,r1)
         SLNKLST XLA,r1,&size
         cr    r1,r15                  test l'target gt l'data
         jh    *+6
         lr    r15,r1                  else use l'target
         mvcl  r0,r14
         l     r1,24(,r13)
.adddn   anop
.* setup pointers for caller
*data ptr
         la    r0,&datao.(r1)          -> data section
*end
         mexit
.*-
.* address next entry
.*-
.NEXT    ANOP
&ml      SLNKLST XLA,r1,&addr
         ltr   r1,r1
         jz    &l.x                    no current
         l     r1,&nexto.(,r1)         -> next
         la    r0,&datao.(r1)          -> data section
&l.x     equ   *
         mexit
.*-
.* drop one
.*-
.DROP    ANOP
         aif   (k'&prev eq 0).err3     PREV= required for rest
*unchain
&ml      SLNKLST XLA,r1,&addr
         SLNKLST XLA,r14,&prev         -> previous
         ltr   r14,r14
         jz    &l.a
         l     r15,&nexto.(,r1)        -> next
         st    r15,&nexto.(,r14)       update next in prev
*free
&l.a     l     r15,&sizeo.(,r1)        size
         lb    r0,&poolo.(,r1)
         Freemain R,lv=(15),a=(1),sp=(0)
*end
         mexit
.*-
.* drop all
.*-
.DROPA   ANOP
&ml      SLNKLST XLA,r14,&addr         -> starting point
&l.a     ltr   r14,r14                 test for block
         jz    &l.x                    no queue
         l     r15,&sizeo.(,r14)       size
         lr    r1,r14                  copy address
         lb    r0,&poolo.(,r1)         sp
         l     r14,&nexto.(,r14)       -> next
         aif   (k'&trace eq 0).dropatn
         &trace
.dropatn anop
         Freemain R,lv=(15),a=(1),sp=(0)
         j     &l.a
&l.x     equ   *
         mexit
.*-
.* anchor
.*-
.anchr   anop
&ml      dc    a(0)
         mexit
.*-
.* dsect
.*-
.dsect   anop
         aif   (&@SLNKlst).mend
&@SLNKlst    setb 1
SLNKLSTBLOK  dsect
SLNKlstnexto equ   &nexto
SLNKlstnext  ds    a                   -> next in queue
SLNKlstsizeo equ   &sizeo
SLNKlstsize  ds    a                   size of block incl pfx
SLNKlstpoolo equ   &poolo
SLNKlstpool  ds    x                   subpool #
             ds    3x                  future
SLNKlstpfxl  equ   &datao              prefix size
SLNKlstdatao equ   &datao
SLNKlstdata  ds    0a
         mexit
.*-
.* XLA - subroutine, generate Lx instruction
.* Syntax: macname XLA,reg,ahat
.*                 what: label, (reg), 'literal', f/h/b.label
.*-
.XLA     anop
         lclc  &xlar,&xlap,&xla
         lcla  &xlapn,&xlan
&$xlalen setc  ''
&xlar    setc  '&syslist(2)'
&xlapn   seta  2
.xlanext anop
&xlapn   seta  &xlapn+1
         aif   (&xlapn gt n'&syslist).xlan
&xlap    setc  '&syslist(&xlapn)'
         aif   (k'&xlap eq 0).xlanext
         aif   ('&xlap '(1,1) eq '(').xlareg
         aif   ('&xlap '(1,1) eq '''').xlalit
         aif   ('&xlap  '(2,1) eq '.').xlafld
&xla     setc  t'&xlap
         aif   ('&xla' eq 'N').xlanum
         la    &xlar,&xlap
&$xlalen setc 'l''&xlap'
         mexit
.xlanum  anop
         lgfi  &xlar,&xlap
         mexit
.xlafld  anop
&xlan    seta  k'&xlap-2
&xla     setc  '&xlap'(1,1)
&xla     setc  Upper('&xla')
         aif   ('&xla' ne 'F').xlafld2
&xla     setc  ''
.xlafld2 anop
&xlap    setc  '&xlap'(3,&xlan)
         l&xla &xlar,&xlap
         mexit
.xlareg  anop
&xlan    seta  k'&xlap-2
&xlap    setc  '&xlap'(2,&xlan)
         lr    &xlar,&xlap
         mexit
.xlalit  anop
         la    &xlar,=c&xlap
&xlan    seta k'&xlap-2
&$xlalen setc '&xlan'
.xlan    mexit
.mend    MEND
.* ADD NAME=STRLEN
         Macro
.* return length of string in r15
.* data=(addr,len) or label
&ml      StrLen &data=,&pad=c' '
         gblc  &$lalenc
         $la   r14,&data(1)
         $la   r15,&data(2),&$lalenc
         ar    r15,r14
         bctr  r15,0
         cli   0(r15),&pad
         je    *-6
         cr    r15,r14
.*       jh    *+10
         jnl   *+10
         sr    r15,r15                 null string
         j     *+10
         sr    r15,r14
         la    r15,1(,r15)
         ltr   r15,r15
         Mend
.* ADD NAME=STRPOS
         Macro
.*-
.* Find position of argument in string.
.*
.* Parameters
.*  arg       address and optionally length of argument
.*  str       address and optionally length of string
.*  default length for both is the first operand length
.*
.* Registers used
.*  r0, r1, r14, r15
.*
.* Registers at exit
.*  r1  -> argument in string if found
.*  r1  = 0 if argument is not found, or string is not big enough
.*
.* Samples
.*
.*         StrPos arg=arg1,str=str1    sets r1 = 7
.*         ltr   r1,r1
.*         bz    notfound
.*  arg1   dc    c'was'
.*  str1   dc    c'Kilroy was here'
.*
.*         StrPos arg=((r2),(r3)),str=((r4,r5)))
.*
.* yeah I know I really should use the SRST instruction, but that
.* requires more registers, and end-of-string handling is weird.
.*
.* Author
.*     Willy Jensen
.*     mail: willy@harders-jensen.com
.*     web : http://harders-jensen.com/wjtech/index.html
.*-
&ml      StrPos  &arg=,&str=
         gbla  &$lalen
         lclc  &l,&s
&l       setc  'zsp&sysndx'
&ml      $la   r1,&str(1)            -> string begin
         $la   r0,&str(2),l'&str(1)  string length
         $la   r14,&arg(1)           arg
         $la   r15,&arg(2),l'&arg(1) arg length
.*
         cr    r0,r15                is string as wide
         jl    &l.n                    as arg?
         sr    r0,r15                length to scan
         ar    r0,r1                 last pos to scan
         bctr  r15,0                 arg mch length
         icm   r15,2,0(r14)          1st char of arg to 3rd byte of reg
&l.a     clm   r15,2,0(r1)           compare 1st char
         jne   &l.b
         ex    r15,&l.t              compare
         je    &l.x
&l.b     la    r1,1(,r1)             bump string ptr
         cr    r1,r0                 test end of string
         jnh   &l.a                  try next
&l.n     sr    r1,r1                 set not found
         j     &l.x
&l.t     clc   0(*-*,r1),0(r14)
&l.x     ltr   r1,r1
         Mend
.* ADD NAME=STRTEST
          Macro
.*
.* Test string for contents
.* Contents types: NUMeric
.*
&mlbl    StrTest &str=,&test=
         lclc  &s,&t,&l
         gblc  &$lalenc
&l       setc  'st&sysndx'
&mlbl    $la   r14,&str(1)
         $la   r15,&str(2),&$lalenc
&t       setc  Upper('&test')
         aif   ('&t' eq 'NUM').num
         mnote 8,'Invalid test type'
         mexit
.num     anop
&l.a     cli   0(r14),c'0'
         jl    &l.x
         cli   0(r14),c'9'
         jh    &l.x
         la    r14,1(,r14)
         bct   r15,&l.a
&l.x     ltr   r15,r15          zero => ok
         mexit
         Mend
.* ADD NAME=STRR2D
         Macro
.*-
.* STRR2D - convert hex value in register to readable (decimal)
.*
.* Syntax
.*  STRR2D ÝCALL,¨REG=register,TO=(addr,len)
.*        addr      label, (reg), F.label
.*        from-len  1-4
.*        to-len    default is from-len*3
.*        CALL      generates call to an internally created csect
.*
.* Returns
.*  r0  = length of output
.*
.* The  macro calls  an internally  generated subroutine.  This
.* shortens the code length  for multiple executions of STRC2B,
.* though adds a bit to the program complexity.
.*
.* Notes
.*  registers 0,1,14,15 are used by the macro
.*
.* Author
.*     Willy Jensen
.*     mail: willy@harders-jensen.com
.*     web : http://harders-jensen.com/wjtech
.*-
&mlbl    STRR2D &reg=,&to=
         lclc  &s,&l
         gblb  &$strr2d
&l       setc  'RD&sysndx'
.* call
         lr    r15,&reg
         $la   r0,&to(1)
         $la   r1,&to(2),0
         l     r14,=v(zstrr2d)
         basr  r14,r14
         aif   (&$strr2d).x
&$strr2d setb  1
.* module
&s       setc  '&sysloc'
ZSTRR2D  Amode 31
ZSTRR2D  Rmode any
ZSTRR2D  CSECT
         stm   r14,r2,12(r13)
         basr  r2,0
         ahi   r2,-6
         push  using
         using zstrr2d,r2
.* process
         l     r14,16(,r13)
         cvd   r14,60(,r13)
         lm    r14,r15,20(r13)         to addr and len
         ltr   r15,r15                 to-len given?
         jnz   *+8                     yes
         la    r15,12                  set default length
         lr    r0,r15                  save target size
         bctr  r15,0
         sll   r15,4
         ex    r15,&l.u
         srl   r15,4
         la    r15,0(r14,r15)
         oi    0(r15),x'f0'
.* return
         l     r14,12(,r13)
         l     r2,28(,r13)
         sr    r15,r15
         bsm   0,r14
&l.u     unpk  0(*-*,r14),60(8,r13)
         drop  r2
         pop   using
&s       Loctr                         resume main
.x       MEND
.* ADD NAME=EQUATE
         MACRO
&NAME    EQUATE &PRINT=
.*--------------------------------------------------------------------*
.*                                                                    *
.*   LIB : SYS2.MACLIB(EQUATE)                                        *
.*   DOC : GENERATE EQUATES FOR SYMBOLS                               *
.*   REF : CCS/CS - WJ                                                *
.*                                                                    *
.*   SYNTAX :                                                         *
.*     LABEL  EQUATE GR     => GR0 -> GR15                            *
.*     LABEL  EQUATE GR,CR  => GR0 -> GR15 AND CR0 -> CR15            *
.*     LABEL  EQUATE        => R0 -> R15 AND BIT0 -> BIT7 (DEFAULT)   *
.*     LABEL  SA/SAVEAREA   => SAR0 -> SAR15                          *
.*     LABEL  EQUATE PRINT=NOGEN => DON'T SHOW MACRO EXPANSION        *
.*                                                                    *
.*--------------------------------------------------------------------*
         LCLA  &INDX,&INCR,&HIGH
         LCLC  &P
         GBLA  &IEZBITS
         GBLB  &EQUATEREGS,&EQUATEBITS,&EQUATESA
.*
         AIF   (K'&NAME EQ 0).LBL099
&NAME    CNOP  0,4
.LBL099  ANOP
         MPRINT PUSH,&PRINT
         AIF   (N'&SYSLIST GT 0).INIT
         MNOTE *,'*** DEFAULT EQUATES REGS, BITS ASSUMED'
         EQUATE R,B                    EQUATE REGS AND BITS
         AGO    .END                   AND TERMINATE
.*
.INIT    ANOP
&INDX    SETA  1
&HIGH    SETA  15
&INCR    SETA  0                       INIT COUNTER
.*
.SETC    ANOP
&P       SETC  UPPER('&SYSLIST(&INDX)')
         AIF   ('&P' EQ 'SA' OR '&P' EQ 'SAVE').SA
         AIF   ('&P' EQ 'B' OR '&P' EQ 'BITS' ).BITS
.*
         AIF   (&EQUATEREGS NE 0).REGS99  BITS ALLREADY SET
&EQUATEREGS SETB 1
.EQU     ANOP
&P.&INCR EQU   &INCR
         AIF   (&INCR GE &HIGH).NEXT
&INCR    SETA  &INCR+1
         AGO   .EQU
.REGS99  ANOP
.*
.NEXT    ANOP
         AIF   (&INDX GE N'&SYSLIST).END
&INCR    SETA  0                       INIT COUNTER
&HIGH    SETA  15                      DEFAULT HIGH-RANGE
&INDX    SETA  &INDX+1
         AGO  .SETC
.*
.*----
.BITS    ANOP
         AIF   (&EQUATEBITS NE 0).BITS99  BITS ALLREADY SET
&EQUATEBITS SETB 1
         AIF   (&IEZBITS NE 0).BITS99  BITS ALLREADY SET
         IEZBITS
.BITS99  AGO   .NEXT
.*----
.SA      ANOP
         AIF   (&EQUATESA NE 0).SA99   ALREDY DONE?
&EQUATESA SETB 1
&P.WD1   EQU   0                       PL/1 ONLY
&P.HSA   EQU   4                       BACK CHAIN
&P.LSA   EQU   8                       FWD    -
&P.RET   EQU   12                      RETURN ADDRESS (R14)
&P.R14   EQU   SARET
&P.EPA   EQU   16                      ENTRY POINT ADDRESS (R15)
&P.R15   EQU   SAEPA
&P.R0    EQU   20                      REGISTER 0
&P.R1    EQU   24                      REGISTER 1
&P.R2    EQU   28                      REGISTER 2
&P.R3    EQU   32                      REGISTER 3
&P.R4    EQU   36                      REGISTER 4
&P.R5    EQU   40                      REGISTER 5
&P.R6    EQU   44                      REGISTER 6
&P.R7    EQU   48                      REGISTER 7
&P.R8    EQU   52                      REGISTER 8
&P.R9    EQU   56                      REGISTER 9
&P.R10   EQU   60                      REGISTER 10
&P.R11   EQU   64                      REGISTER 11
&P.R12   EQU   68                      REGISTER 12
         AGO   .NEXT
.*----
.END     ANOP
         MPRINT POP
         MEND
.* ADD NAME=MPRINT
         MACRO
         MPRINT
         GBLA  &MPRINTN
         GBLC  &MPRINT
.*
         AIF   ('&SYSLIST(1)' EQ 'PUSH' OR                             +
               '&SYSLIST(1)'(1,2) EQ 'SA').SA
         AIF   ('&SYSLIST(1)' EQ 'POP' OR                              +
               '&SYSLIST(1)'(1,2) EQ 'RE').RS
         MNOTE 12,'***ERROR - INVALID FUNCTION &SYSLIST(1)'
         MEXIT
.*
.SA      ANOP
&MPRINT  SETC  '&SYSLIST(2)'           USE IF SPECIFIED
         AIF   (K'&SYSLIST(2) EQ 0 AND K'&SYSLIST(3) EQ 0).SA900
         AIF   (K'&SYSLIST(2) EQ 0).SA030
.SA020   ANOP
&MPRINT  SETC  '&SYSLIST(2)'           USE SPECIFIED
         AGO   .SA100
.SA030   ANOP
&MPRINT  SETC  '&SYSLIST(3)'           USE DEFAULT
.*
.SA100   PUSH  PRINT
&MPRINTN SETA  &MPRINTN+1
         PRINT &MPRINT
.SA900   ANOP
         MEXIT
.*
.RS      ANOP
         AIF   (K'&MPRINT EQ 0).RS999
         AIF   (&MPRINTN EQ 0).RS0800
         AIF   (N'&SYSLIST EQ 1).RS0100
         AGO   .RS0200
.*--------------------------------------------------------------------*
.*  POP SINGLE STACK                                                  *
.*--------------------------------------------------------------------*
.RS0100  ANOP
         POP   PRINT
&MPRINTN SETA  &MPRINTN-1
         MEXIT
.*--------------------------------------------------------------------*
.*  POP ENTIRE STACK                                                  *
.*--------------------------------------------------------------------*
.RS0200  ANOP
         AIF   ('&SYSLIST(2)' NE 'ALL').RS02E1
.RS0210  ANOP
         POP   PRINT
&MPRINTN SETA  &MPRINTN-1
         AIF   (&MPRINTN GT 0).RS0210
         MNOTE *,'*** ENTIRE STACK CLEARED'
         MEXIT
.RS02E1  ANOP
         MNOTE 8,'*** ERROR - INVALID SECOND OPERAND - &SYSLIST(2)'
         MEXIT
.*--------------------------------------------------------------------*
.*  EMPTY STACK                                                       *
.*--------------------------------------------------------------------*
.RS0800  ANOP
         MNOTE *,'*** PUSH STACK EMPTY'
.RS999   MEXIT
         MEND
.* ADD NAME=$LOCATE
         MACRO
.*
.* LOCATE VARIOUS CONTROL BLOCKS
.*
&LBL     $LOCATE &QCB,&TYPE,&REG=R15,&USING=NO,&DCB=,&NAME=,           +
               &DDNAME=,&ERROR=,&PRINT=,&ECB=,&TIOTA=,                 +
               &DSECTS=
.*--
         LCLA  &N,&M
         LCLC  &L,&C,&O,&CB,&USNG
&CB      SETC  UPPER('&QCB')
&USNG    SETC  UPPER('&USING')
&L       SETC  'Z'.'&SYSNDX'
.*--
         AIF   (K'&PRINT EQ 0).PRINTIN
         PUSH  PRINT
         PRINT &PRINT
.PRINTIN ANOP
         AIF   (K'&LBL EQ 0).LBL099
&LBL     CNOP  0,4
.LBL099  ANOP
.*--
         AIF   ('&CB' EQ 'TCB').TCB
         AIF   ('&CB' EQ 'JSTCB').JSTCB
         AIF   ('&CB' EQ 'JSCB').JSCB
         AIF   ('&CB' EQ 'JCT').JCT
         AIF   ('&CB' EQ 'ASCB').ASCB
         AIF   ('&CB' EQ 'TIOT').TIOT
         AIF   ('&CB' EQ 'JOBNAME' OR '&CB' EQ 'JBN').JBN
         AIF   ('&CB' EQ 'DDENTRY' OR '&CB' EQ 'DD').DDENT
         AIF   ('&CB' EQ 'DDNAME' OR '&CB' EQ 'DDN'                    +
               OR K'&DDNAME GT 0).DDN
         AIF   ('&CB' EQ 'SUBSYS').SSYS
         AIF   ('&CB' EQ 'JESCOMCHAR').JCOM
         AIF   ('&CB' EQ 'SMFID').SMFID
         AIF   ('&CB' EQ 'PGMNAME').PGMN
         AIF   ('&CB' EQ 'PGM').PGMN
         AIF   ('&CB' EQ 'ECT').ECT
         MNOTE 8,'*** ERROR - INVALID BLOCK - &CB'
         MEXIT
.*--
.* TCB - REQUIRED MAPPING MACRO: IKJTCB
.TCB     ANOP
         L     &REG,16                 -> CVT
         L     &REG,0(,&REG)           -> TCBWORDS
         L     &REG,4(,&REG)           -> CURRENT TCB
         AIF   ('&USING' NE 'YES').MEXIT
         USING TCB,&REG
         AGO   .MEXIT
.*--
.* JSTCB - REQUIRED MAPPING MACRO: IKJTCB
.JSTCB   ANOP
         $LOCATE TCB,REG=&REG
         L     &REG,TCBJSTCB-TCB(,&REG)  -> JOBSTEP TCB
         AIF   ('&USING' NE 'YES').MEXIT
         USING TCB,&REG
         AGO   .MEXIT
.*--
.* JSCB - REQUIRED MAPPING MACRO: IEZJSCB
.JSCB    ANOP
         $LOCATE JSTCB,REG=&REG
         L     &REG,TCBJSCB-TCB(,&REG)   -> JSCB
         AIF   ('&USING' NE 'YES').MEXIT
         USING IEZJSCBG,&REG
         AGO   .MEXIT
.*--
.* JCT  - REQUIRED MAPPING MACRO: IEFAJCTB
.JCT     ANOP
         $LOCATE JSCB,REG=&REG
         ICM   &REG,7,JSCBJCTA-IEZJSCB(&REG) -> JCT
         SLL   &REG,4                    CLEAR
         SRL   &REG,4                      HI-ORDER BYTE
         LA    &REG,16(,&REG)            FOUND BY TESTING
         AIF   ('&USING' NE 'YES').MEXIT
         USING INJMJCT,&REG
         AGO   .MEXIT
.*--
.* ASCB - REQUIRED MAPPING MACRO: IHAASCB
.ASCB    ANOP
         L     &REG,16                 -> CVT
         L     &REG,0(,&REG)           -> TCBWORDS
         L     &REG,12(,&REG)          -> CURRENT ASCB
         AIF   ('&USING' NE 'YES').MEXIT
         USING ASCB,&REG
         AGO   .MEXIT
.*--
.TIOT    ANOP
.JBN     ANOP
         $LOCATE TCB,USING=NO,REG=&REG
         L     &REG,12(,&REG)          -> TIOT
         AIF   (K'&TIOTA EQ 0).TIOTAN
         ST    &REG,&TIOTA             SAVE ADDRESS
.TIOTAN  ANOP
         AIF   ('&CB' NE 'JOBNAME' AND '&CB' NE 'JBN').MEXIT
         MNOTE *,'* &REG -> DC CL8''JOBNAME'' '
         AGO   .MEXIT
.*--
.* ECT  - REQUIRED MAPPING MACROS:
.*       IHAPSA,IKJTCB,IEZJSCB,IKJPSCB,IKJRLGB,IKJECT
.ECT     ANOP
         L     &reg,PSATOLD-PSA     -> TCB
         L     &reg,TCBJSCB-TCB(,&reg) -> JSCB
         L     &reg,JSCBPSCB-IEZJSCB(,&reg) -> PSCB
         L     &reg,PSCBRLGB-PSCB(,&reg) -> RELOGON BUFFER
         L     &reg,RLGBECT-RLGB(,&reg) -> ECT
         AIF   ('&USING' EQ 'NO').MEXIT
         USING ECT,&REG
         AGO   .MEXIT
.*--
.DDENT   ANOP
         $LOCATE TIOT,REG=&REG
         AH    &REG,&DCB+DCBTIOT-IHADCB  ADD OFFSET INTO TIOT
         MNOTE *,'* &REG + 4 -> DC CL8''DDNAME'' '
         AGO   .MEXIT
.*--
.DDN     ANOP
.*--------------------------------------------------------------------*
.*    LOCATE DDNAME THROUGH TIOT                                      *
.*    IF DDNAME = '*', THEN LOCATE NEXT OR FIRST IF ECB IS ZERO.      *
.*    ALSO SCAN IF &TYPE EQ '*'                                       *
.*    BYPASS USE OF ECB IF DDNAME IF NOT NULL.                        *
.*--------------------------------------------------------------------*
         LCLC  &DDNECB
.*--
         AIF   ('&TYPE' EQ '*' OR '&DDNAME' EQ '*').DDN10
         AGO   .DDN50                  ELSE TRY SPECIFIC DDNAME
.*--
.DDN10   ANOP
.*--
&DDNECB  SETC  '&ECB'                  SET ADDRESS
         AIF   (K'&DDNECB GT 0).DDNECB2
&DDNECB  SETC  '&L.ECB'                SET ADDRESS
         B     &DDNECB+4               JUMP AROUND ECB
&DDNECB  DC    A(0)
.DDNECB2 ANOP
.*--
         $LA   R14,&DDNECB             -> ECB
         ICM   R15,15,0(R14)           LOAD AND TEST
         BNZ   &L.N1                   IF ZERO, THEN NOT FIRST TRY
         $LOCATE  TIOT                 FIND TIOT, SET ADDRESS IN GR15
         LA    R15,24(,R15)            JUMP TO 1ST DD ENTRY
         B     &L.N3                   PROCESS 1ST ENTRY
&L.N1    SLR   R0,R0
         ICM   R0,B'0001',0(R15)       GET  LENGTH OF DD-ENTRY
         BNZ   &L.N2                   GOODBYE IF LAST DD-ENTRY
         LA    R15,4                   SET RC FOR LAST DD-ENTRY
         B     &L.X                    AND SAY GOODBYE
&L.N2    AR    R15,R0                  CHAIN TO NEXT DD ENTRY
&L.N3    LA    R1,4(,R15)              -> DDNAME
         ST    R15,0(R14)              SAVE ADDRESS IN ECB
         SLR   R15,R15                 SET GOOD RC
&L.X     LTR   R15,R15                 AND SET FOR BRANCH
         AGO   .MEXIT
.*--
.DDN50   ANOP
         $LOCATE  TIOT                 FIND TIOT, SET ADDRESS IN GR15
         LA    R15,24(,R15)            JUMP TO 1ST DD ENTRY
         SLR   R0,R0                   LOCATE DD ENTRY IN TIOT
         AIF   ('&DDNAME'(1,1) NE '''').DDNLA
         LA    R1,=CL8&DDNAME
         AGO   .DDNLN
.DDNLA   $LA   R1,&DDNAME              -> DDNANE
.DDNLN   ANOP
&L.L     ICM   R0,B'0001',0(R15)       GET  LENGTH OF DD-ENTRY
         BZ    &L.X4                   GOODBYE IF LAST DD-ENTRY
         CLC   4(8,R15),0(R1)          COMPARE AGAINST TARGET
         BE    &L.X0
         AR    R15,R0                  CHAIN TO NEXT DD ENTRY
         B     &L.L
&L.X0    SLR   R15,R15                 SET GOOD RETURN
         B     &L.N                    AND CONTINUE MAINLINE
.DDNX4   ANOP
&L.X4    LA    R15,4                   DD ENTRY NOT FOUND
&L.N     LTR   R15,R15                 SET RETURN CODE
         AIF   (K'&ERROR EQ 0).MEXIT
         BNZ   &ERROR
*-
         AGO   .MEXIT
.*--------------------------------------------------------------------*
.*   LOCATE SUBSYSTEM CONTROL BLOCK                                   *
.*--------------------------------------------------------------------*
.SSYS    ANOP
         AIF   ('&REG' EQ 'R1').SSYS901
.*--------------------------------------------------------------------*
.*   GENERATE DSECTS                                                  *
.*--------------------------------------------------------------------*
         GBLB  &DSCTCVT,&DSCTTCB,&DSCTJES,&DSCTSSV,&DSCTSCV
         AIF   (N'&DSECTS EQ 0).DSCT090
         PUSH  PRINT
         PRINT NOGEN
&C       SETC  '&SYSECT'
&N       SETA  0
.DSCT010 ANOP
         AIF   (&N EQ N'&DSECTS).DSCT090
&N       SETA  &N+1
&O       SETC  '&DSECTS(&N)'
         AIF   ('&O' EQ 'CVT').DSCTCVT
         AIF   ('&O' EQ 'TCB').DSCTTCB
         AIF   ('&O' EQ 'JESCT').DSCTJES
         AIF   ('&O' EQ 'SSVT').DSCTSSV
         AIF   ('&O' EQ 'SCVT').DSCTSCV
         MNOTE  8,'*** INVALID DSECTNAME - &O'
         MEXIT
.DSCTCVT AIF   (&DSCTCVT).DSCT010
&DSCTCVT SETB  1
         CVT   DSECT=YES,PREFIX=NO
         AGO   .DSCT010
.DSCTTCB AIF   (&DSCTTCB).DSCT010
&DSCTTCB SETB  1
         IKJTCB
         AGO   .DSCT010
.DSCTJES AIF   (&DSCTJES).DSCT010
&DSCTJES SETB  1
         IEFJESCT
         AGO   .DSCT010
.DSCTSCV AIF   (&DSCTSCV).DSCT010
&DSCTSCV SETB  1
         IEFJSCVT
         AGO   .DSCT010
.DSCTSSV AIF   (&DSCTSSV).DSCT010
&DSCTSSV SETB  1
         IEFJSSVT
         AGO   .DSCT010
.DSCT090 ANOP
         POP   PRINT
&C       CSECT
.*--------------------------------------------------------------------*
.*   LOCATE SUBSYSTEM VECTOR TABLE                                    *
.*--------------------------------------------------------------------*
.SSYS100 ANOP
         L     R1,16                   -> CVT
         LA    R14,255                 LOOP PROTECTION
         L     R1,CVTJESCT-CVT(R1)
         L     &REG,JESSSCT-JESCT(R1)  POINT TO SUBSYS CVT
&L.A     CLC   =CL4'&NAME',SSCTSNAM-SSCT(&REG) CHECK NAME
         BE    &L.X0
         CLC   =XL4'00',SSCTSCTA-SSCT(&REG)  END OF SUBSYS CHAIN
         BE    &L.X4
         L     &REG,SSCTSCTA-SSCT(&REG)  GET NEXT SUBSYS CVT
         BCT   R14,&L.A
&L.X4    EQU   *
         SLR   &REG,&REG               NOT FOUND
&L.X0    EQU   *
         LTR   &REG,&REG
         AGO   .MEXIT
.SSYS901 ANOP
         MNOTE 8,'*** ERROR - REGISTERS 1 AND/OR 14 ARE USED INSIDE THE+
                MACRO AND CANNOT BE USED FOR THE REG OPERAND'
         AGO   .MEXIT
.*--------------------------------------------------------------------*
.*   LOCATE JES2 COMMAND CHAR                                         *
.*--------------------------------------------------------------------*
.JCOM    ANOP
         GBLB  &$LOCDSC2
         AIF   ('&DSECTS' EQ 'NO' OR &$LOCDSC2).JCOM100
         PUSH  PRINT
         PRINT NOGEN
&C       SETC  '&SYSECT'
         CVT   DSECT=YES,PREFIX=NO
         IEFJESCT
         IEFJSCVT
*        IEFJSSVT
         $XECB
         $SCAT
         $SVT
         POP   PRINT
&C       CSECT
&$LOCDSC2 SETB 1
.JCOM100 ANOP
&C       SETC  'JES2'
         AIF   (K'&NAME EQ 0).JCOM101
&C       SETC  '&NAME'
.JCOM101 ANOP
         $LOCATE SUBSYS,NAME=&C,REG=&REG,DSECTS=NO
         BZ    &L.X                    SUBSYSTEM NOT FOUND IF ZERO
         L     &REG,SSCTSSVT-SSCT(&REG) -> SUBSYSTEM VECTOR TABLE
         LA    &REG,$SVCOMCH-SSVT(&REG) -> COMMAND CHAR
&L.X     EQU   *
.*
.*--------------------------------------------------------------------*
.*   LOCATE SMFID - REDQ DSECTS : SMCA, CVT                           *
.*--------------------------------------------------------------------*
.SMFID  ANOP
         L     &REG,16                        -> CVT
         L     &REG,CVTSMCA-CVTMAP(&REG)      -> IEESMCA
         LA    &REG,SMCASID-SMCABASE(&REG)    SMFID
         MEXIT
.*--------------------------------------------------------------------*
.*   LOCATE PROGRAM NAME IN THE CDE                                   *
.*--------------------------------------------------------------------*
.PGMN    ANOP
         $LOCATE TCB,REG=&REG
         L     &REG,TCBRBP-TCB(&REG)          -> CURRENT RB
         LA    &REG,0(,&REG)
         L     &REG,RBCDE-RBBASIC(&REG)       -> CDE
         LA    &REG,8(,&REG)                  ->  PROGRAMNAME
         MEXIT
.*--------------------------------------------------------------------*
.MEXIT   ANOP
         AIF   (K'&PRINT EQ 0).PRINTTN
         POP   PRINT
.PRINTTN ANOP
         MEND
.* ADD NAME=GETPARM
         MACRO
&LBL     GETPARM &AREADEF=,&MAXLEN=,&NOPARM=,&REG=R1,&CLEAR=YES,       +
               &TSO=YES,               BEWARE OF TSO CALL              +
               &PRINT=GEN
.*
.*  MOVE PARAMETER FIELD FROM THE 'EXEC' JCL STATEMENT TO AN
.*  INTERNAL AREA.
.*
.*  OPERANDS :
.*      AREADEF A-TYPE ADDRESS OF RECEIVING AREA.
.*              MAY ALSO BE SYSLIST(1).
.*      MAXLEN  MAXIMUM LENGTH OF PARAMETER. DEFAULT IS LENGTH
.*              OF RECEIVING FIELD.
.*      NOPARM  A-TYPE ADDRESS. CONTINUE HERE IF THERE ARE
.*              NO PARAMETER FIELD SPECIFIED.
.*      REG     DEFINES TO WHICH R1 HAS BEEN COPIED.
.*      CLEAR   SET RECEIVE AREA TO BALNKS BEFORE RETREIVE.
.*      PRINT   GEN/NOGEN - USED TO SUPPRESS PRINT OF MACRO
.*              EXPANSION.
.*
.*   THE MACRO USES R0 AND R15 AS WORK REGISTERS.
.*
.*
         LCLA  &N,&M
         LCLC  &L,&NOPA,&AL
         LCLC  &AREA
&AREA    SETC  '&AREADEF&SYSLIST(1)'
.*
&L       SETC  'Z&SYSNDX'
&NOPA    SETC  '&L.X'                  DEFAULT
         AIF   (K'&NOPARM EQ 0).ZP99
&NOPA    SETC  '&NOPARM'               ADDRESS WHEN NO PARMS
.ZP99    ANOP
&AL      SETC  'L''&AREA'
         AIF   (K'&MAXLEN EQ 0).MAXL99
&AL      SETC  '&MAXLEN'
.MAXL99  ANOP
         PUSH  PRINT
         PRINT &PRINT
*---------------------------------------------------------------------*
*   OBTAIN PARAMETER STRING IF PRESENT                                *
*---------------------------------------------------------------------*
         AIF   ('&CLEAR' NE 'YES').CLRN
&N       SETA  (L'&AREA)-1
         AIF   (&N LT 254).CLR200
&N       SETA  254
.CLR200  ANOP
         MVI   &AREA,C' '              INITIALIZE FIRST BYTE
         MVC   &AREA+1(&N),&AREA       FORCE THROUGH REST
.CLRN    ANOP
         SR    R15,R15                 INITIAL LENGTH = 0
         ICM   &REG,15,0(&REG)
         BZ    &NOPA                   NO PARMS IF ZERO
         SLR   R15,R15
         ICM   R15,3,0(&REG)           LOAD LENGTH
         BZ    &NOPA                   NO PARMS IF ZERO
         LA    R0,&AL
         CR    R15,R0                  CHECK MAX LENGTH
         BNH   *+6
         LR    R15,R0                  TRUNCATE
.*--------------------------------------------------------------------*
.*   TSO PARM : BEWARE OF PREFIX AND SUFFIX                           *
.*--------------------------------------------------------------------*
.TSO     AIF   ('&TSO' NE 'YES').TSON
         CLI   2(&REG),X'00'           INDICATE TSO ??
         BNE   &L.TN                   NOPE
         SH    R15,2(,&REG)            SUBTRACT PREFIX LENGTH
         BCTR  R15,0                   SUBTRACT PREFIX 1ST BYTE
         BCTR  R15,0                               -   2ND BYTE
         BCTR  R15,0                   SUBTRACT SUFFIX 1ST BYTE
         BCTR  R15,0                               -   2ND BYTE
         AH    &REG,2(&REG)            BUMP POINTER
         LA    &REG,2(,&REG)                -
&L.TN    EQU   *
.TSON    ANOP
.*--------------------------------------------------------------------*
.*   MOVE TO RECEIVING AREA                                           *
.*--------------------------------------------------------------------*
         BCTR  R15,0                   GET MACHINE LENGTH
         EX    R15,*+8
         B     *+10
         MVC   &AREA.(*-*),2(&REG)     COPY TO OWN AREA
         LA    R15,1(,R15)             REINSTATE REAL LENGTH
&L.X     EQU   *
.MEXIT   ANOP
         POP   PRINT
         MEND
