.*-
.* REXXMACS - Interface macros for REXX
.*-
.* This is assembler copybook, use as follows:
.*         Print off
.*         Copy RexxMacs
.*         Print on
.*-
.* Sample
.*       ereg  0,1
.*       RxInit parmlist=((prm1,8),(prm2,8),(prm3,8))
.*       ltr   r0,r0
.*       jnz   *not REXX*
.*       RxSay Welcomemsg,l'Welcomemsg
.*       mvc   rc,=c'04'
.*       RxRetval rc,l'rc
.*       . . .
.*       RexxMacs ds
.*  rc   dc    c'00'
.*       . . .
.*       RexxMacs dsect
.*-
.* History
.* 2017-09-28   enhance parm handling for RXSAY
.* 2018-06-16   new macro RXSTACK
.*              new macro REXXMACSMODS
.* 2018-10-29   small fix to RXINIT test for REXX
.* 2019-06-17   add TDL=reg to RxVNext stats
.* 2019-09-01   add 1 as default 2nd parm for RXINIT PARMVECT
.* 2019-09-12   new internal macro RXLA, change all '$LA' to 'RXLA'
.* 2019-10-03   fix default data length in RXVACC
.* 2019-10-25   fix RXSAY literal length
.*-

         Macro
.*-
.* RxInit - initialise interface
.*
.* Parameters
.*
.*  first positional
.*   DS               Generate data section
.*   DSECT            Generate data- and dummy sections
.*   null             Generate standard initialization
.*  keywords
.*   PARMAREA=address Copy 1st or only parm to 'address'. R15 will
.*                    retain length of the data copied.
.*   PARMLIST=addr1,..,adrn  Copy arguments to local storage with
.*                    length prefix. Each addrx must include a field
.*                    length if not implied like (address,length).
.*                    'length' may be a value, (register), f.addr or
.*                    A for storing the address instead of the value.
.*                    For each argument a structure is build:
.*                      arg1_fs ds x  field length
.*                      arg1_ds ds x  data length
.*                      arg1    ds c  data
.*                    Samples
.*                      RxInit parmlist=string,pattern
.*                      RxInit parmlist=((string,A),(pattern,A))
.*   PARMVECT=(addr,count)   Copy argument address ad length as
.*                    fullword pairs.
.*                    Sample
.*                         RxInit parmvect=(pl,4)
.*                         lm    r2,r3,pl   addr,length of 1st parm
.*                         lm    r4,r5,pl+8 addr,length of 2nd parm
.*                      pl  dc  (4*2)a(0)
.*
.*   NOPARM=address   Jump to 'address' it no parameter is supplied.
.*   NOREXX=address   Jump to 'address' it no REXX environment is
.*   DS=N             Do not generate internal data section. Assume
.*                    that a RXINIT DS, a RXINIT DSECT and a RXVACC PL
.*                    are done elsewhere.
.*-
         RxInit &parmlist=,&parmarea=,&norexx=,&noparm=,&parmvect=
         gbla  &RXPIC
         gblc  &RXPIN(20),&RXPIL(20)
         lclc  &q,&l,&s,&wl,&name,&len,&pa,&pl,&norexxa
         lcla  &n,&p,&ofs,&fl
&l       setc  'rxi&sysndx'
&norexxa setc  '&norexx'
         aif   (k'&norexx gt 0).nrx1n
&norexxa setc  '&l.n'
.nrx1n   anop
&l.a     cnop  0,4
         xc    zrx_area(zrx_areal),zrx_area
.* note that r0 and r1 must contain the original values.
.* data block must be generated using RxInit DB macro call.
         stm   r0,r1,zrx_r0            save entry r0,r1
* test for REXX envblock
         lr    r14,r0                  -> envblock (hopefully)
         clc   &l.eb,0(r14)
         je    &l.b
         xc    zrx_r0,zrx_r0
         j     &norexxa                no REXX
&l.eb    dc    cl8'ENVBLOCK'
&l.b     equ   *
* end test
         using efpl,r1                 point to parmlist
         mvc   zrx_ebp,efpleval        -> evaluation block pointer
         drop  r1
.*
         RxComBlk init                 GET/PUT comblk
.*
         lr    r15,r0
* get interface routine addresses
         using envblock,r15
         l     r15,envblock_irxexte    rexx vector of external entries
         using irxexte,r15
         mvc   zrx_coma,irxexcom       address of module irxexcom
         mvc   zrx_SayA,irxsay         address of module irxsay
         drop  r15
         aif   (k'&parmlist gt 0).prminit
         aif   (k'&parmvect gt 0).prmvect
         aif   (k'&parmarea gt 0).prmarea
&l.n     l     r0,zrx_r0               nz if REXX, z if not REXX
         Mexit
.* Copy parm to area
.prmarea anop
         l     r2,zrx_r1               old r1
         using efpl,r2                 point to parmlist
         l     r2,efplarg              -> arguments table
         drop  r2
         ltr   r2,r2                   test no
         jz    &l.n                      input
         cli   0(r2),x'FF'             end of source list?
         lm    r14,r15,0(r2)           source address and length
         ltr   r15,r15                 zero length?
         jnz   &l.c                    ok, go copy
         sr    r15,r15                 just in case
         j     &l.n
&l.c     bctr  r15,0                   mch length
         mvc   &parmarea.(*-*),0(r14)
         ex    r15,*-6
         la    r15,1(,r15)             reinstate length
&l.n     l     r0,zrx_r0               nz if REXX, z if not REXX
         Mexit
.*
.* Get positional parameters
.*
.PrmInit Anop
.*
*- init parameter address list --------------------------------
.*
         aif   (n'&parmlist eq 0).noparm
&RXPIC   seta  n'&parmlist
&n       seta  1
&ofs     seta  0
         la    r1,zrx_parmarea
.prmi010 anop
&name    setc  '&parmlist(&n,1)'
         la    r14,&name._fs
         st    r14,&ofs.(,r1)
&ofs     seta  &ofs+4
&len     setc  '&parmlist(&n,2)'
&RXPIN(&n) setc  '&name'
&RXPIL(&n) setc  '&len'
         aif   ('&len' ne 'A').prmi110
         xc    &name._fs(10),&name._fs
         ago   .prmi200
.prmi110 anop
         mvi   &name._fs,&len
         mvi   &name._ds,0
         mvi   &name,c' '
         aif   ('&len' eq '1').prmi200
         mvc   &name.+1(&len-1),&name
.prmi200 anop
&n       seta  &n+1
         aif   (&n le n'&parmlist).prmi010
&ofs     seta  &ofs-4
         oi    &ofs.(r1),x'80'
.*
*- obtain parameters ------------------------------------------
.*
.PrmGet  Anop
         l     r2,zrx_r1               old r1
         using efpl,r2                 point to parmlist
         l     r2,efplarg              -> arguments table
         drop  r2
         la    r3,zrx_parmarea
         ltr   r2,r2                   test no
         jz    &l.n0                     input
&l.1     equ   *
         cli   0(r2),x'FF'             end of source list?
         je    &l.n0
         l     r1,0(,r3)               output area
         la    r1,0(,r1)               clear vl bit
         lm    r14,r15,0(r2)           source address and length
         ltr   r14,r14                 check zero address
         jz    &l.3                    then go get next
         ltr   r15,r15                 zero length
         jz    &l.3                    then go get next
.* r1 -> al1(field length,data length),c'data'
         ic    r1,0(,r1)               load target field length
         sll   r1,24                   drop upper
         srl   r1,24                     3 bytes
.* store address/length pair
         ltr   r1,r1                   field len=0 => store addresses
         jnz   &l.2
         l     r1,0(,r3)               output area
         la    r1,0(,r1)               clear vl bit
         stm   r14,r15,2(r1)
         mvi   1(r1),8                 set data length
         j     &l.3
.* get text data
&l.2     cr    r15,r1
         bnh   *+6
         lr    r15,r1                  reset to max
         l     r1,0(,r3)               output area
         stc   r15,1(,r1)              save data length
         bctr  r15,0
         mvc   2(*-*,r1),0(r14)
         ex    r15,*-6
&l.3     tm    0(r3),x'80'             end of target list?
         jo    &l.n0                   yes
.*       jo    &l.n4                   not so good
         la    r2,8(,r2)
         la    r3,4(,r3)
         j     &l.1
&l.n0    sr    r15,r15
         j     &l.n
&l.n4    la    r15,4
&l.n     l     r0,zrx_r0               nz if REXX, z if not REXX
         Mexit
.*
.* Copy parameter address / length pairs
.*
.PrmVect Anop
         l     r1,zrx_r1               old r1
         using efpl,r1                 point to parmlist
         l     r1,efplarg              -> arguments table
         drop  r1
         RxLa  r14,&parmvect(1)        -> output area
         RxLa  r15,&parmvect(2),1      max number of pairs
&l.pv1   tm    0(r1),x'80'             end of source list?
         jo    &l.pv0
         mvc   0(8,r14),0(r1)          copy address and length
         la    r1,8(,r1)
         la    r14,8(,r14)
         bct   r15,&l.pv1              get next
         la    r15,1                   set 'overflow'
         j     &l.n
&l.pv0   sr    r15,r15
&l.n     l     r0,zrx_r0               nz if REXX, z if not REXX
.*-
.noparm  anop
.x       Mend

*--------------------------------------------------------------

         Macro
.*-
.* Comm-block for VGET / VPUT
.* Internal macro called by RXINIT and REXXMACS respectively
.*-
         RxComBlk &what,&stat,&prefix=zrx_
         lclc  &pf,&s
&pf      setc  '&prefix'
&s       setc  Upper('&what')
         aif   ('&s' eq 'DS' or k'&what eq 0).ds
         aif   ('&s' eq 'DSECT').dsect
         aif   ('&s' eq 'INIT').init
         aif   ('&s' eq 'TEST').test
         mnote 'RXCOMBLK Invalid call: &s'
         mexit
.init    anop
* init VGET / VPUT comblk begin
         la    r14,=cl8'IRXEXCOM'
         st    r14,&pf.ComBlkp1
         la    r14,=a(0)
         st    r14,&pf.ComBlkp2
         st    r14,&pf.ComBlkp3
         st    r14,&pf.ComBlkp5
         la    r14,&pf.ShVb
         st    r14,&pf.ComBlkp4
         la    r14,&pf.XComRc
         st    r14,&pf.ComBlkp6
         oi    &pf.ComBlkP6,x'80'
* init VGET / VPUT comblk end
         Mexit
.dsect   anop
RxComBlK DSECT
.ds      anop
&pf.ComBlk   ds    0x
&pf.ComBlkp1 ds    a                   -> EXCOM eyecatcher
&pf.ComBlkp2 ds    a                   Reserved
&pf.ComBlkp3 ds    a                   Reserved
&pf.ComBlkp4 ds    a                   -> 1st SVHB
&pf.ComBlkp5 ds    a                   -> Env-block or zero
&pf.ComBlkp6 ds    a                   -> Return code field
*-
&pf.XComRc   ds    a
&pf.StAdjCnt ds    a                   storage adjustment count
&pf.NextCnt  ds    a                   'next' counter
*-
&pf.ShVb     ds    0d
&pf.ShVbNext ds    a                   -> next  ShVb
&pf.ShVUser  ds    f                   Used by 'next' function
&pf.ShVCode  ds    0c                  F=Fetch, S=Set (put)
&pf.ShVbFunc ds    c                   F=Fetch, S=Set (put)
&pf.ShVRet   ds    0x                  Return code area
&pf.ShVbRc   ds    x                   Return code area
&pf.last     equ   x'02'               'last-var' flag
&pf.trunc    equ   x'04'               'truncated' flag
             ds    h                   Reserved
&pf.ShVbFbl  ds    a                   Length of fetch buffer
&pf.ShVbVna  ds    a                   -> variable name
&pf.ShVbVnl  ds    a                   length of variable name
&pf.ShVbVba  ds    a                   -> value buffer
&pf.ShVbVbl  ds    a                   Length of fetched value
&pf.namea    equ   &pf.ShVbVna,4
&pf.namel    equ   &pf.ShVbVnl,4
&pf.dataa    equ   &pf.ShVbVba,4
&pf.datal    equ   &pf.ShVbVbl,4
&pf.ShVbl    equ   *-&pf.ShVb
&pf.ComBlkl  equ   *-&pf.ComBlk
.* names from the manual
&pf.ShvBufl  equ   &pf.ShVbFbl,4
&pf.ShvNama  equ   &pf.ShVbVna,4
&pf.ShvNaml  equ   &pf.ShVbVnl,4
&pf.ShvVala  equ   &pf.ShVbVba,4
&pf.ShvVall  equ   &pf.ShVbVbl,4
         Mexit
.TEST    anop
.* Test return code flags stored in SHVRET:
.*  SHVCLEAN EQU X'00' Execution was OK
.*  SHVNEWV  EQU X'01' Variable did not exist
.*  SHVLVAR  EQU X'02' Last variable transferred (for "N")
.*  SHVTRUNC EQU X'04' Truncation occurred during "Fetch"
.*  SHVBADN  EQU X'08' Invalid variable name
.*  SHVBADV  EQU X'10' Value too long
.*  SHVBADF  EQU X'80' Invalid function code (SHVCODE)
.* Special flags: LAST
&s       setc  Upper('&stat')
         aif   ('&s' ne 'EOF').test999
         tm    &prefix.SHVRET,SHVLVAR  last??
         mexit
.test999 tm    &prefix.SHVRET,&s
         mexit
.x       Mend

*--------------------------------------------------------------

         Macro
.*-
.* Generate data areas
.* Usage:
.*       RexxMacs dsect
.*-
         REXXMACS &what,&comblk=Y,&cbpfx=zrx_
         lcla  &sln,&n,&l
         lclc  &sl,&c,&name,&len,&s,&cbp
         gbla  &RXPIC
         gblc  &RXPIN(20),&RXPIL(20),&RXCBPFX
.* select action
         aif   (k'&what eq 0).defsect
&s       setc  Upper('&what')
         aif   ('&s' eq 'DS').DefSect
         aif   ('&s' eq 'DSECT').DefSect
         aif   ('&s' eq 'SET').set
         mnote 8,'** Invalid p1'
         mexit
.* set global settings - under construction
.SET     anop
         aif   (k'&cbpfx eq 0).cbpfxn
&rxcbpfx setc  '&cbpfx'
.cbpfxn  anop
         mexit
.*-
.* Datablock and dummy sects common to the macro seet
.*-
.DEFSECT anop
&sln     seta  &sln+1
         aif   (&sln gt N'&syslist).x
&sl      setc  Upper('&syslist(&sln)')
         aif   ('&sl' eq 'DS').ds
         aif   ('&sl' eq 'DSECT').dsect
&sl      setc  'syslist(&sln)'
         mnote 8,'*** Invalid option: &sl'
         mexit
.DS      anop
*-
* Data areas for the REXXMACS set
*-
*
*- global area
zrx_area     ds    0a
zrx_envba    ds    0a
zrx_r0       ds    a
zrx_r1       ds    a
zrx_Excoma   ds    0a
zrx_coma     ds    a
zrx_saya     ds    a
zrx_EnvBlka  ds    0a
zrx_ebp      ds    a
zrx_fw       ds    f
zrx_dw       ds    0d
zrx_wrk      ds    6a
zrx_wrkp1    equ   zrx_wrk,4
zrx_wrkp2    equ   zrx_wrk+4,4
zrx_wrkp3    equ   zrx_wrk+8,4
zrx_wrkp4    equ   zrx_wrk+12,4
zrx_wrkp5    equ   zrx_wrk+16,4
zrx_wrkp6    equ   zrx_wrk+20,4
*-Comm-block
         aif   ('&comblk' ne 'y' and '&comblk' ne 'Y').comblkn
             RxComBlk
.comblkn anop
*-end of area
zrx_areal    equ   *-zrx_area
*- parameter area, &rxpic parameters handled
zrx_parmarea ds    0a
         aif   (&RXPIC eq 0).DefSect
          ds    &RXPIC.a       parm vector
&n       seta  1
.parmdef aif   (&n gt &RXPIC).DefSect
&name    setc  '&RXPIN(&n)'
&len     setc  '&RXPIL(&n)'
         aif   ('&len' ne 'A').mpa010
         ds     0a                    align data
         ds     h                       on fullword
&len     setc  '8'                    room for 2 adress fields
.mpa010  anop
&name._fs ds    al1
&name._ds ds    al1
&name     ds    cl(&len)
&n       seta  &n+1
         ago   .parmdef
*-
.Dsect   anop
*-
* Dsects for the REXXMACS set
*-
         Print  nogen
         Dsect
         IRXEFPL                      REXX EXTERNAL FUNCTION
         IRXEVALB                     REXX EVALUATION BLOCK
         IRXENVB                      REXX ENVIRONMENT BLOCK
         IRXARGTB DECLARE=YES         REXX ARGUMENT TABLE
         IRXEXTE
         IRXSHVB
         Print  gen
*-
         ago   .DefSect
.X       Mend

         Macro
.*-
.* REXX interface macro - terminate with return code
.* Parms
.*   EXIT=N      do not terminate program, allow for freemains etc
.*   RC=         number or (register)
.*   RCH=address address of halfword containing the rc
.*   RCF=address address of fullword containing the rc
.* Default rc=0
.*-
&mlbl    RxTerm &rc=,&data=,&exit=Y
         lclc  &data1,&data2,&l
&l       setc  'z&sysndx'
&data1   setc  '&data(1)'
&data2   setc  '&data(2)'
&mlbl    cnop  0,4
         l     r14,zrx_ebp             -> evaluation block pointer
         l     r14,0(r14)              point to evalblock
         using evalblock,r14
         aif   (k'&rc gt 0).rc
         aif   (k'&data gt 0).data
&data1   setc  '=c''0000'''
&data2   setc  '4'
         ago   .data
.rc      RxLa  r15,&rc                 rc
         cvd   r15,evalblock_evdata+8
         unpk  evalblock_evdata(8),evalblock_evdata+8
         oi    evalblock_evdata+7,x'F0'
         mvc   evalblock_evlen,=a(8)
         ago   .b
.data    anop
         la    r2,&data2             length
         l     r15,EVALBLOCK_EVSIZE   for data size check
         sll   r15,3                  doublewords to bytes
         cr    r2,r15
         jnh   &l.b
         lr    r2,r15               use max
&l.b     st    r2,evalblock_evlen   store reply length
         ltr   r2,r2
         jz    &l.c
         bctr  r2,0
         mvc   evalblock_evdata(*-*),&data1
         ex    r2,*-6
&l.c     equ   *
.b       drop  r14
&q       setc  Upper('&exit')
         aif   ('&q' eq 'N').x
         sr    r15,r15                 caller must use the RC value
         pr
.x       Mend

         Macro
.*-
.* REXX interface macro - store return value
.* Parms
.*   data        address of the data to return
.*   size        size of the data to return
.*-
&mlbl    RxRetVal &data,&size,&wto=N
         lclc  &l
&l       setc  'zrx&sysndx'
&mlbl    cnop  0,4
         RxLa  r0,&size
         l     r14,zrx_ebp             -> evironment block pointer
         l     r14,0(r14)              point to evalblock
         using evalblock,r14
         l     r1,evalblock_evsize    for data size check
         drop  r14
         sll   r1,3                   doublewords to bytes
         ahi   r1,-16                 minus header
         cr    r0,r1                  fits in current buffer ?
         jnh   &l.c                   yes, go copy
.*-
* get a bigger buffer
.*-
         aif   ('&wto' ne 'Y').wton
         wto   'RxRetval expand'
.wton    anop
         la    r14,=cl8'GETBLOCK'
         la    r15,zrx_wrkp5          new evaluation block addr
         stm   r14,r15,zrx_wrkp1
         st    r0,zrx_wrkp4           store length
         la    r14,zrx_wrkp4          -> length
         st    r14,zrx_wrkp3          save
         oi    zrx_wrkp3,x'80'        end-of-parm flag
.*
         load  EP=IRXRLT
         lr    r15,r0                 copy module address
         l     r0,zrx_envba           envbp (optional)
         la    r1,zrx_wrkp1           -> start of parmlist
         basr  r14,r15
         st    r15,zrx_wrkp6          save rc
.*
         delete EP=IRXRLT
         icm   r15,15,zrx_wrkp6       reload rc, test cond
         jnz   &l.x                   nope
.*-
* copy data to buffer
.*-
&l.c     l     r14,zrx_ebp             -> evironment block pointer
         l     r14,0(r14)              point to evalblock
         using evalblock,r14
.* just use copy-long, simpler and dont happen that often
         RxLa  r0,&data
         RxLa  r1,&size
         st    r1,evalblock_evlen     store length
         la    r14,evalblock_evdata
         drop  r14
         lr    r15,r1                 copy size
         mvcl  r14,r0
         sr    r15,r15
&l.x     equ   *
.x       Mend


         Macro
         RxStemName &base=,&stema=,&num=,&pnum=,&clear=n
.*-
.* Build a rexx stemname composed by a base, including the dot,
.* concatenated with the number.
.*   base=(address,length)
.*   name=address
.*   num=binary number
.*   pnum=packed-decimal number - note must be pl4'n'
.*   clear=Y   clear varname before build-up
.* Sample:
.*     RxStemName base=(stemname,7),stema=varname,num=f.seqnr
.*-
         lcla  &n
         lclc  &base1,&base2
&base1   setc  '&base(1)'
&base2   setc  '&base(2)'
         aif   ('&base1 '(1,1) ne '''').b1litn
&n       seta  k'&base1-2
&base2   setc  '&n'
         ago   .basen
.b1litn  anop
         aif   (k'&base2 ne 0).b2nuln
&n       seta  l'&base1
&base2   setc  '&n'
.b2nuln  anop
.basen   anop
.*       aif   (n'&base ne 2 or k'&stema eq 0).err1
         aif   ('&clear' ne 'Y' and '&clear' ne 'y').clrn
         mvi   &stema,c' '
         mvc   &stema.+1(l'&stema.-1),&stema
.clrn    anop
         RxLa  r14,&base1              addr
         RxLa  r15,&base2              length
         bctr  r15,0                   mch length
         mvc   &stema.(*-*),0(r14)     get stem base
         ex    r15,*-6
         RxLa  r14,&stema+1(r15)       -> number area
         RxStemNum (r14),bin=&num,dec=&pnum
         RxLa  r14,&base2              stem base length
         ar    r15,r14                 plus number length
         lr    r0,r15                  copy length
         mexit
.err1    mnote 8,'**STEMNAME Missing base or name'
         Mend

         Macro
.*-
.* Build a rexx stemnumber
.* Parameters
.*   addr      build-up area, must be large enough to hold the result
.*   bin       value, (reg) or f.addr
.*   dec       value address
.* Samples
.*         RxStemNum value,bin=f.xval
.*         lr    r2,r15        copy length
.*         RxStemNum value,dec=pval
.*         lr    r2,r15        copy length
.*  value  dc    cl8' '
.*  xval   dc    a(123)
.*  pval   dc    p'456'
.*-
         RxStemNum &addr,&dec=,&bin=
         lclc  &l
&l       setc  'R&sysndx'
         mvc   40(8,r13),=x'4020202020202020'
         aif   (k'&bin eq 0 and k'&dec eq 0).err1
         aif   (k'&dec gt 0).dec
         RxLa  r15,&bin                seqnr
         cvd   r15,24(r13)
         edmk  40(8,r13),28(r13)       unpack
         ago   .nlen
.dec     edmk  40(8,r13),&dec          unpack
.nlen    anop
         bnz   &l.cl                   nonzero value
         la    r1,=c'0'                -> c'0'
         sr    r15,r15                 mchlen=0
         b     &l.m
.* r1 -> 1st non-zero byte
&l.cl    la    r15,48(,r13)            calc
         sr    r15,r1                    length
         bctr  r15,0                   mch length
&l.M     RxLa  r14,&addr               -> target area
         mvc   0(*-*,r14),0(r1)        append seq number
         ex    r15,*-6
         la    r15,1(,r15)             reinstate length
         mexit
.err1    mnote 8,'**STEMNUM Missing number parm'
         Mend

         Macro
.*-
.* Say
.*
.* Parameters
.*   1  address    label, (reg) or 'literal'
.*   2  length     value, (reg) or null if address is literal
.*
.* sets up 5 fullword work area
.*   1  -> 'WRITE'
.*   2  -> address of dataaddress field
.*   3  -> address of length field
.*   4  dataaddress field
.*   5  length field
.*-
&mlbl    RXSAY &adr,&len,&wrk=zrx_wrk
         gblc  &rxlalen
&mlbl    la    r14,=cl8'WRITE'         -> operation
         rxla  r15,&adr                -> data
         rxla  r0,&len,&rxlalen,l'&adr length
         stm   r15,r0,&wrk+12
         la    r15,&wrk+12
         la    r0,&wrk+16
         stm   r14,r0,&wrk
         oi    &wrk+8,x'80'            set end of list
         sr    r0,r0
         La    R1,&wrk
         L     R15,zrx_SayA            address of module
         Basr  R14,R15
         Mend

         MACRO
.*-
.* REXX get or put variable
.*
.* Can be used directly, but should really be used through the
.* RXVGET, RXVPUT and RXSTEMPUT macros.
.*
.* Required dsects: IRXENVB IRXEXTE
.* you must use the PL expansion for either GET or PUT
.* The INIT call is done in RXINIT.
.*
.* Parameters, see the RXVGET, RXVPUT and RXVNECT macros later.
.*
.* Sample:
.*           RxVacc init,enva=zrx_envba,pl=vapl
.*
.*           RxVacc get,name=('TESTVAR1',8),data=(value,l'value)
.*           l     r2,vaplShVbVbl       actual data length
.*
.*           mvlit value,'finally weekend'
.*           la    r2,15
.*           RxVacc put,name=('TESTVAR1',8),data=(value,(r2))
.*
.*  vapl     RxVacc pl
.*  value    dc    cl100' '
.*-
&mlbl    RXVACC &what,&name=,&data=,&envptr=,&st=,&sth=,&src=,         c
               &reg=r14,&enva=zrx_envba,&comblk=zrx_
         lclc  &que,&lbl,&c,&lsrc,&lpl,&l,&s,&cb
         lcla  &m,&n,&i,&ln,&p
         gblc  &rxlalen
&l       setc  'z&sysndx'
&cb      setc  '&comblk'
&que     setc  Upper('&what')
&lbl     setc  'RXV&sysndx'
&mlbl    ds    0h
         aif   ('&que' eq 'GET').get
         aif   ('&que' eq 'PUT').put
         aif   ('&que' eq 'NEXT').next
         aif   ('&que' eq 'RESET').reset
         Mnote 8,'*** invalid parm: &what'
         Mexit
.*-get
.Get     Anop
         mvi   &cb.ShVbFunc,C'F'           fetch
         ago   .call
.*-getnext prep
.Next    Anop
         mvi   &cb.ShVbFunc,C'N'           fetch
         ago   .call
.*-put
.Put     Anop
         mvi   &cb.ShVbFunc,C'S'           set
.call    Anop
         aif   (k'&data(1) eq 0).call2     no data
*setup for data
         RxLa  r14,&data(1)
         RxLa  r15,&data(2),&rxlalen
         stm   r14,r15,&cb.ShVbVba
         st    r15,&cb.ShVbFbl
.call2   anop
*setup for name
&s       setc  Upper('&name(1)')           ensure literal is ucase
         RxLa  r14,&s
         aif   ('&name(1) '(1,1) eq '''' and k'&name(2) eq 0).call2nl
         RxLa  r15,&name(2),l'&name(1)
         ago   .call2nn
.call2nl anop
&n       seta  k'&name(1)-2
         la    r15,&n
.call2nn anop
         stm   r14,r15,&cb.ShVbVna
*setup for call
         mvc   &cb.ShVUser,&cb.ShVbVnl for 'next'
         l     r15,zrx_coma                address of module irxexcom
         l     r0,zrx_envba
         la    r1,&cb.Comblk
         Basr  r14,r15
.* load data- and name length
         l     r0,&cb.ShVbVbl
         l     r1,&cb.ShVbVnl
.*-getnext post, check for end of list
         aif   ('&que' ne 'NEXT').X
         if    (tm,&cb.SHVRET,SHVLVAR,o)     end of list set
           la    r15,1
         endif
         if    (tm,&cb.SHVRET,SHVTRUNC,o)    truncation occurred
           la    r15,2
         endif
         ltr    r15,r15                      set cc
         Mexit
.* reset the interface block
.RESET   Anop
         xc    &comblk.ShVb(&comblk.ShVbl),&comblk.ShVb
         xc    &comblk.StAdjCnt,&comblk.StAdjCnt
         xc    &comblk.NextCnt,&comblk.NextCnt
         Mexit
.*
.x       MEND

         Macro
.*-
.* Get a REXX variable to local storage
.*
.* Parameters;
.*   DATA=(address,length)  Address is the address of the buffer which
.*                          will receive the data.
.*                          Length is the length of the buffer
.*   NAME=(address,length)  Address is the variable name.
.*                          The name may a literal in quotes.
.*                          Length will default to the length of a
.*                          literal of the generated length of a field.
.*                          Note, the name in a field must be in ucase,
.*                          a literal is ucased internally.
.*   STOR=length            Size of dynamic data area. The area will be
.*                          automatically reallocated if too small. You
.*                          must use the STOR=DROP option when finished
.*                          to release the storage.
.*
.*   address can be a label or a (register).
.*   length can be a numbeer or a (register).
.*
.* Registers after call
.* r15  return code
.* r0   data length
.*
.* Sample
.*   RxVGet name='TESTVAR1',data=(value,(r2))
.*   RxVGet name=(varname,(r3)),data=(value,(r2))
.*   RxVGet name='longvar',stor=200
.*   lr    r2,r0         copy data length
.*   RxVGet stor=drop
.*-
&mlbl    RXvGet &name=,&data=,&comblk=zrx_,&stor=,&acc=GET
         lclc  &l,&q,&ac
&l       setc  'RG&sysndx'
&q       setc  Upper('&syslist(1)')
&ac      setc  Upper('&acc')
         aif   ('&q' eq 'RESET').reset
         aif   (k'&stor ne 0).stor
&mlbl    RxVacc &acc,name=&name,data=&data,comblk=&comblk
         Mexit
.* reset the interface block
.RESET   Anop
         xc    &comblk.ShVb(&comblk.ShVbl),&comblk.ShVb
         xc    &comblk.stadjcnt,&comblk.stadjcnt
         xc    &comblk.nextcnt,&comblk.nextcnt
         Mexit
.* use dynamic storage for data area
.STOR    Anop
&q       setc  Upper('&stor')
         aif   ('&q' eq 'DROP').stordrp
         RxLa  r14,&stor
&l.cs    c     r14,&comblk.ShVbFbl
         jnh   &l.cl                   ok, go call
*-freemain
         l     r0,&comblk.ShVbFbl      size
         icm   r1,15,&comblk.ShVbVba   if null address
         jz    &l.gm                   then no previous storage
         Freemain R,lv=(0),a=(1)
*-getmain
&l.gm    st    r14,&comblk.ShVbFbl     save as buffer length
         Getmain R,lv=(14),loc=31
         st    r1,&comblk.ShVbVba      save address
*-call
&l.cl    xc    &comblk.ShVbVbl,&comblk.ShVbVbl
         RxVacc &acc,name=&name,comblk=&comblk
         tm    &comblk.ShVRet,SHVTRUNC
         jz    &l.sl
         l     r14,&comblk.stadjcnt
         la    r14,1(,r14)
         st    r14,&comblk.stadjcnt
         l     r14,&comblk.ShVbVbl
         j     &l.cs
&l.sl    l     r0,&comblk.ShVbVbl      size of retrieved
         l     r1,&comblk.ShVbVba      addr of retrieved
         Mexit
.STORDRP Anop
         l     r0,&comblk.ShVbFbl      size
         l     r1,&comblk.ShVbVba      address
         Freemain R,lv=(0),a=(1)
         Mexit
.x       MEND

         Macro
.*-
.* Create or update a REXX variable from local storage
.*
.* Parameters;
.*   DATA and NAME same as for the RxVGet macro.
.*
.* Registers after call
.* r15  return code
.*
.* Sample
.*   RxVPut name=('TESTVAR1',8),data=(value,(r2))
.*-
&mlbl    RXvPut &name=,&data=,&comblk=zrx_
.* bl    RxVacc put,name=(&name(1),&name(2)),data=(&data(1),&data(2)),
&mlbl    RxVacc put,name=&name,data=&data,comblk=&comblk
.x       MEND

         Macro
.*-
.* Retrieve all REXX variable from current environment, or information
.* about variables.
.*
.* Parameters;
.*   DATA and NAME same as for the RxVGet macro.
.*  If p1 = 'STATS' then the following parameters are used:
.*   NL     register to receive name length
.*   DL     register to receive data length
.*   TDL    register to add data length (must be 0 before first call).
.*   COUNT  register to hold count
.*
.* Both the NAME and the DATA fields will be filled in by the function.
.*
.* Registers after call
.* r15  return code
.*      special code 1 means that the variable retrieved is the last.
.*      special code 2 means that the name or the data was truncated.
.* r0   data length
.* r1   name length
.*
.* Sample
.*   RxVNext name=(namebfr,l'namebfr),data=(databfr,l'databfr)
.*   lr    r2,r0         copy data length
.*   lr    r3,r1         copy name length
.*-
&mlbl    RxVNext &name=,&data=,&nl=,&dl=,&tdl=,&count=,                c
               &comblk=zrx_
         lclc  &l,&q
&l       setc  'RN&sysndx'
&q       setc  Upper('&syslist(1)')
         aif   ('&q' eq 'STATS').stats
&mlbl    RxVacc next,name=&name,data=&data,comblk=&comblk
         mexit
.STATS   ANOP
&mlbl    RxVacc reset
         sr    &nl,&nl                 name length
         sr    &dl,&dl                 data length
         sr    &count,&count           count
&l.a     RxVacc next,name=(0,0),data=(0,0)
         tm    zrx_SHVRET,SHVLVAR
         jo    &l.x
         cr    r1,&nl
         jnh   *+6
         lr    &nl,r1
         cr    r0,&dl
         jnh   *+6
         lr    &dl,r0
         aif   (k'&tdl eq 0).count
         ar    &tdl,r0
.count   la    &count,1(,&count)
         j     &l.a
&l.x     RxVacc reset
         mexit
.x       MEND

         Macro
.*-
.* Read or write a stemvar, combining the basename and the number.
.* Parameters are a combination of those for RXSTEMNAME
.* and RXVGET/VPUT
.*-
         RxStemAcc &name=,&stema=,&base=,&num=,&pnum=,&data=,          c
               &comblk=zrx_,&acc=???,&namelenr=r1
         lclc  &vn
&vn      setc  '&name'
         aif   (k'&name ne 0).vnok
&vn      setc  '&stema'
.vnok    anop
 mnote *,'-RxStemname'
         RxStemname stema=&vn,base=&base,num=&num,pnum=&pnum
         lr    &namelenr,r15
 mnote *,'-RxV&acc'
         RxV&acc name=(&vn,(&namelenr)),data=&data,&comblk=&comblk
         Mend

         Macro
         RxStemGet &name=,&stema=,&base=,&num=,&pnum=,&data=,          c
               &comblk=zrx_
.* call common access macro
         RxStemAcc acc=GET,name=&name,stema=&stema,                    c
               base=&base,num=&num,pnum=&pnum,data=&data,comblk=&comblk
         Mend

         Macro
         RxStemPut &name=,&stema=,&base=,&num=,&pnum=,&data=,          c
               &comblk=zrx_,&namelenr=r1
.* call common access macro
         RxStemAcc acc=PUT,name=&name,stema=&stema,                    c
               namelenr=&namelenr,                                     c
               base=&base,num=&num,pnum=&pnum,data=&data,comblk=&comblk
         Mend

         Macro
.*-
.* Acces the REXX data stack
.*
.* Parameters;
.*   what  function - PUSH, QUEUE, QUEUED ...
.*   data  address or (address,length) for functions PULL, QUEUE,
.*         PUSH and QUEUED. Must be a fullword if QUEUED.
.*
.* Registers after call
.* r15  return code
.* r0   data length if function is PULL
.* r1   data address if function is PULL
.*      value if function is QUEUED
.*
.* Sample
.*   RxStack pull,data=buffer
.*   RxStack queued
.*-
         RxStack &what,&data=,&mode=,&wrka=,&lenreg=
         lclc  &que,&l,&s
&func    setc  Upper('&what')
&l       setc  'zrx&sysndx'
         la    r14,=cl8'&func'         function
&s       setc  Upper('&mode')
         aif   ('&mode' eq 'CALL').call
         xc    zrx_datal,zrx_datal
         xc    zrx_xComRc,zrx_xComRc
         aif   ('&func' ne 'QUEUE' and '&func' ne 'PUSH').quefn
         aif   (n'&data eq 0).datafn
         RxLa  r15,&data(1),0
         st    r15,zrx_dataa           address of data
         RxLa  r15,&data(2),l'&data,0
         st    r15,zrx_datal           save data length
.datafn  anop
.quefn   anop
         la    r15,zrx_dataa           address of data returned
         la    r0,zrx_datal            length of data returned
         la    r1,zrx_xComRc           value returned by irxstk
         stm   r14,r1,zrx_wrk
         oi    zrx_wrk+12,x'80'        set VL bit
         l     r15,zrx_envba
         l     r15,envblock_irxexte-envblock(,r15) a(irxexte)
         l     r15,irxstk-irxexte(,r15) stack manager
         la    r1,zrx_wrk              parm list
         basr  r14,r15                 call irxstk
         aif   ('&func' eq 'PULL').pullbe
         aif   ('&func' eq 'QUEUED').quedbe
         ago   .other
.quedbe  anop                          QUEUED back end
         l     r1,zrx_xComRc           value
         aif   (k'&data eq 0).quedb2
         st    r1,&data
.quedb2  ltr   r15,r15                 set rc
         mexit
.pullbe  anop                          PULL back end
         ltr   r15,r15                 test rc
         aif   (n'&data eq 0).pullb2
         jnz   &l.b2                   exit if bad rc
         StrCopy  from=(f.zrx_dataa,f.zrx_datal),                      c
               to=(&data(1),&data(2)),lenreg=&lenreg
         sr    r15,r15
         ltr   r15,r15
&l.b2    equ   *
         mexit
.pullb2  anop                          PULL back end
         l     r0,zrx_datal
         l     r1,zrx_dataa
         mexit
.other   ltr   r15,r15
         ago   .x
.*- call
         l     r15,zrx_envba
         RxLa  r0,&data(1)
         RxLa  r1,&data(2),l'&data(1)
         stm   r14,r1,zrx_wrk
         RxLa  r1,&wrka,0
         st    r1,zrx_wrk+16
         la    r1,zrx_wrk
         Call  ZRXSTACK
         ltr   r15,r15
.*- end
.x       anop
&l.x     equ   *
         Mend

         Macro
*-
* ZRXSTACK - stack interface
* At entry
*  r1 -> ZRXSTACK_prm
* At exit
*  r15  0  all ok, though the string may have been truncated
*      >0  return code from IRXSTK
*-
         RexxMacsMods
         using ZRXSTACK,r12
         using ZRXSTACK_PRM,r9
         using ZRXSTACK_WRK,r10
*-
*  initialize module
*-
ZRXSTACK Csect
         save  (14,12)
         lr    r12,r15
         lr    r9,r1
         icm   r10,r15,ZRXSTACK_prmwa
         jnz   ZRXSTACK_ini1n
         Getmain R,lv=ZRXSTACK_wrkl,loc=31
         lr    r10,r1
ZRXSTACK_ini1n equ   *
         la    r14,ZRXSTACK_sa1
         st    r14,8(,r13)
         st    r13,4(,r14)
         lr    r13,r14
         xc    ZRXSTACK_pl(ZRXSTACK_wrkn-ZRXSTACK_pl),ZRXSTACK_pl
*-
*  setup and call service
*-
         l     r14,ZRXSTACK_prmfa      -> function
         la    r15,ZRXSTACK_dataa      address of data returned
         la    r0,ZRXSTACK_datal       length of data returned
         la    r1,ZRXSTACK_val         value returned by irxstk
         stm   r14,r1,ZRXSTACK_pl
         oi    ZRXSTACK_pl+12,x'80'    set VL bit
         l     r15,ZRXSTACK_prmea
         l     r15,envblock_irxexte-envblock(,r15) a(irxexte)
         l     r15,irxstk-irxexte(,r15) stack manager
         la    r1,ZRXSTACK_pl          parm list
         l     r0,ZRXSTACK_prmea
         basr  r14,r15                 call irxstk
         ltr   r15,r15                 quit now
         jnz   ZRXSTACK_rtn              if bad rc
         l     r2,ZRXSTACK_prmfa       -> function
*be aware of special cases
         clc   =c'QUEUED',0(r2)        special case 'queued'
         je    ZRXSTACK_qed
         j     ZRXSTACK_norm
*-
*  handle special case QUEUED
*-
ZRXSTACK_qed   equ *
         l     r2,ZRXSTACK_prmda       address of data returned
         mvc   0(4,r2),ZRXSTACK_val
         j     ZRXSTACK_rtn
*-
*  return data for normal cases
*-
ZRXSTACK_norm  equ *
         lr    r5,r15                     save rc
         StrCopy from=(f.ZRXSTACK_dataa,f.ZRXSTACK_datal),             c
               to=(f.ZRXSTACK_prmda,f.ZRXSTACK_prmdl)
         lr    r15,r5                     restore rc
*-
*  return
*-
ZRXSTACK_rtn   equ  *
         lr    r5,r15
         clc   ZRXSTACK_prmwa,=a(0)       work area supplied??
         jne   ZRXSTACK_rtn2              yes
         Freemain R,lv=ZRXSTACK_wrkl,a=(10)
ZRXSTACK_rtn2  equ  *
         lr    r15,r5
         l     r13,4(,r13)
         l     r14,12(,r13)
         Return (2,12)

         ltorg
         drop

*-
*  parm area  4x6=16 bytes
*-
ZRXSTACK_prm   dsect
ZRXSTACK_prmfa ds    a                 address
ZRXSTACK_prmea ds    a                 address
ZRXSTACK_prmda ds    a                 address
ZRXSTACK_prmdl ds    a                 address
ZRXSTACK_prmwa ds    a                 address or 0

*-
*  work area  28x4=112 bytes
*-
ZRXSTACK_wrk   dsect
ZRXSTACK_sa1   ds    18a
ZRXSTACK_pl    ds    6a
ZRXSTACK_rc    ds    a
ZRXSTACK_val   ds    a
ZRXSTACK_dataa ds    a                 address
ZRXSTACK_datal ds    a                 value
ZRXSTACK_wrkn  equ   *
ZRXSTACK_wrkl  equ   *-ZRXSTACK_wrk
         Mend

         MACRO
.*-
.* Subroutine, generate Lx instruction
.* Syntax: RXLA  reg,what1,what2,,whatn
.*         what: label or (reg) or 'literal' or f/h/b/c.label
.*               b/c.label -> reg is cleared and the entire byte loaded
.*               1st non-null 'what' is used
.*-
&ml      RXLA
         lclc  &xlar,&xlap,&xla
         lcla  &xlapn,&xlan
         gblc  &rxlalen
&rxlalen setc ''
&xlar    setc  '&syslist(1)'
&xlapn   seta  1
.xlanext anop
&xlapn   seta  &xlapn+1
         aif   (&xlapn gt n'&syslist).x
&xlap    setc  '&syslist(&xlapn)'
         aif   (k'&xlap eq 0 or '&xlap' eq '''''').xlanext
         aif   ('&xlap '(1,1) eq '(').xlareg
         aif   ('&xlap '(1,1) eq '''').xlalit
         aif   ('&xlap '(2,1) eq '.').xlafld
&xla     setc  t'&xlap
         aif   ('&xla' eq 'N').xlanum
&ml      la    &xlar,&xlap
         aif   ('&xlap  '(1,2) eq 'l''').x
&rxlalen setc 'l''&xlap'
         mexit
.xlanum  anop
&ml      lgfi  &xlar,&xlap
         mexit
.xlafld  anop
&xlan    seta  k'&xlap-2
&xla     setc  '&xlap'(1,1)
&xlap    setc  '&xlap'(3,&xlan)
&xla     setc  lower('&xla')
         aif   ('&xla' eq 'b').xlaopb
         aif   ('&xla' eq 'c').xlaopb
         aif   ('&xla' eq 'h').xlaoph
         aif   ('&xla' eq 'f').xlaopf
         mnote 8,'Invalid argument &xla'
         mexit
.xlaopb  anop
&ml      llc   &xlar,&xlap
         mexit
.xlaoph  anop
&ml      lh    &xlar,&xlap
         mexit
.xlaopf  anop
&ml      l     &xlar,&xlap
         mexit
.xlareg  anop
&xlan    seta  k'&xlap-2
&xlap    setc  '&xlap'(2,&xlan)
&ml      lr    &xlar,&xlap
         mexit
.xlalit  anop
&ml      la    &xlar,=c&xlap
&xlan    seta k'&xlap-2
&rxlalen setc '&xlan'
         mexit
.x       MEND

*-RXMACS end
