//ISX1003  JOB (1),'ispf-pnl-exit',CLASS=A,REGION=32M,COND=(0,LT)
//*
//* ?? ISPDPX01 - Panel exit 01 - Use REXX stem as panel part ? e ?
//*
//C        EXEC ASMACL,PARM.C='TERM',  compile-link-go
//             PARM.L='AMODE=31,RMODE=24,LIST,XREF'
//C.SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR
//           DD  DSN=SYS1.MODGEN,DISP=SHR
//           DD  DISP=SHR,DSN=CBT669.LIB
//C.SYSTERM  DD  SYSOUT=*
//C.SYSIN    DD *
**asma syslib *
**asma opt    term
*Process compat(macrocase)
*
* This ISPF panel exit is used to insert records into an ISPF panel.
* It can replace the entire panel, or one or more sections
* with data in REXX stem variable(s).
* Note that the )END statement must still be present in the panel.
*
* The exit looks for a line starting with '*ISPDPX01 vname' in the
* panel, then inserts the entire stem vname there.
* The vname must include the trailing dot, max width incl the dot
* is 5 characters.
*
* Multiple occurences of '*ISPDPX01 vname' is allowed, see member
* ISX1PNL2 for a sample.
*
* Sample panel, named TESTX001:
*
*  )INEXIT LOAD,ISPDPX01
*  *ISPDPX01 pl.
*  )END
*
* Sample REXX code for using the above panel:
*
*  pl.1 = ')ATTR'
*  pl.2 = ')BODY expand(\\)'
*  pl.3 = '%Test panel exit 1'
*  pl.4 = '%Cmd =>_zcmd  \ \ +'
*  pl.5 = '+'
*  pl.6 = 'Just some text'
*  pl.7 = '+'
*  pl.8 = ')INIT'
*  pl.9 = ')PROC'
*  pl.0 = 9
*  address ispexec "display panel(TESTX001)"
*
* The program is written using my structured assembly macro set WSAM.
* These macros are similar but not identical to IBM's structured
* assembly macros.
*
*
         lclc  &module,&forcewto
&module   setc  'ISPDPX01'
&forcewto setc  'N'
*
         print off
         COPY  SYSMACS
         COPY  WSAMMACS           allow structured asembly language
         COPY  REXXMACS           REXX i/f
         COPY  ISPXMACS           ISPF i/f
         COPY  ISX1MACS           local combined macros
         print on
*        COPY  Z10MACS

* -------------initialization------------------------------------------

         Using $wrk,r10
         using pnlparm,r9
&module  #module base=r12,amode=31,rmode=24
         lr    r9,r1
*
* if first time then get some storage
*
         l      r2,pnldataa
         if    (icm,r10,15,0(r2),z)
           Getmain R,lv=$wrkl,loc=31
           lr    r10,r1
           st    r10,0(r2)
           clear vdata,l=256
           mvc   vname,vdata
           zap   vnum,=p'0'
           mvi   action,0
         endif
         la    r13,sa1
*
* Process according to action code
*  0  scan for the insertion point
*  1  insert next record
*     the insertion point record is deleted by end of insert
*  2  process complete, cleanup
*

*
* Action 0 : locate insertion point
*
         if    (cli,action,eq,0)
           l     r6,pnlbfra             -> buffer address
           l     r6,0(r6)               -> buffer
           clear wtot
           mvc   wtot(30),0(r6)
           mvc   wtox,=al2(40,0)
           xwto  l=40,force=&forcewto
           if    (tm,pnlflgs,x'80',o)  end of file?
             Terminate
           endif
           if    (clc,=c'*&module',ne,0(r6))
             #module exit,rc=0
           endif
* insertion point found, locate variable name
           la    r1,10(,r6)             bump label
           la    r2,5                   max length
           do    over(r2)
             if    (cli,0(r1),ne,c' ')  find start of data
               leave
             endif
             la    r1,1(,r1)            bump ptr
           enddo
           if    (clfi,r2,gt,5)         too wide?
             wto   'vname is too wide'
             Terminate
           endif
           mvc   vname,0(r1)            copy to name field
           oc    vname,blank
           la    r1,vname               bump label
           do    inf
             if    (cli,0(r1),eq,c' ')  find end of name
               leave
             endif
             la    r1,1(,r1)            bump ptr
           enddo
           st    r1,vnump
           lr    r15,r1
           la    r14,vname
           sr    r15,r14
           st    r15,vnamel
* get count
           l     r1,vnump
           mvi   0(r1),c'0'
           IspxVget vname,(vdata,8),pl=ispxpl
           if    (ltr,r15,r15,nz)
             zap   vmax,=p'0'        no records to process
* get stem max
           else
             st    r0,vlen
             lr    r2,r0
             strmake wtot,vname,+1,(r2,,cvdr,4),+1,(vdata,8),          c
               lenreg=r3
             xwto  l=(r3),force=&forcewto
             bctr  r2,0
             j     *+10
             pack  vmax,vdata(*-*)
             ex    r2,*-6
             strmake wtot,vname,' count ',(vmax,4,c2x),lenreg=r3
             xwto  l=(r3),force=&forcewto
           endif
           mvi   action,1
         endif
*
* Action 1 : insert next record
*
         if    (cli,action,eq,1)
           ap    vnum,=p'1'
           if    (cp,vnum,gt,vmax)  all done?
             mvi   action,0         0 = scan for further insertions
* reset fields
             clear vname
             zap   vnum,=p'0'
             #module exit,rc=4      delete record
           endif
* construct varname for vget
           RxStemName base=(vname,f.vnamel),stema=vname,pnum=vnum
           l     r2,=a(vdatal)
           IspxVget vname,(vdata,(r2)),pl=ispxpl
           st    r0,vlen
* replace screen buffer
           lm    r2,r3,pnlbfra
           l     r2,0(r2)           -> buffer
           l     r3,0(r3)           -> buffer sz
           st    r3,fw
           StrMake  wtot,'insert in bfr ',(fw,4,cvxd),' ',((2),30)
           xwto  l=60,force=&forcewto

           bctr  r3,0               mch len of buffer
           bctr  r3,0               minus char 1
           mvi   0(r2),c' '
           mvc   1(*-*,r2),0(r2)
           ex    r3,*-6             clear buffer

           la    r3,2(,r3)          reinstate buffer length
           l     r4,vlen            variable width
           if    (cr,r4,gt,r3)      longer than buffer?
             lr    r4,r3            use buffer length
             ahi   r4,-2
             StrMake  wtot,'vl gt bl ',(vdata,40)
             xwto  l=60,force=&forcewto
           endif                    else use buffer width
           bctr  r4,0               mch len of buffer
           mvc   0(*-*,r2),vdata
           ex    r4,*-6             copy data
           #module exit,rc=2        2 = insert
         endif
*
* Action 2 : cleanup and terminate
*
         if    (cli,action,eq,2)
           Terminate
         endif
*
* Action ?
*
         StrMake wtot,'internal error ',(action,1,cvxd),lenreg=r3
         xwto  l=(r3),force=Y
         Terminate

*
* local data
*
zero     dc    a(0)
blank    dc    cl140' '
         ltorg
*
* Map panel parm
*
pnlparm  dsect
pnlnamea ds   a
pnlbfra  ds   a
pnlbfrl  ds   a
pnlrecl  ds   a
pnlflgs  ds   a
pnldataa ds   a
*
* Own dsect
*
$wrk     dsect
sa1      ds    18a
sa2      ds    18a
action   ds    x
logr     ds    cl120
VGetsa   ds    a
vlen     ds    a
vnamel   ds    a
vname    ds    cl8
vnum     ds    pl4                 current stem num
vnump    ds    a                   address of number in name
vmax     ds    pl4                 max stem num
fw       ds    f
dw       ds    d
callpm   ds    8a
wtox     ds    a
wtot     ds    cl80
ispxpl   ds    8a
wrk      ds    xl512
vdata    ds    xl(1024*4)
vdatal   equ   *-vdata
$wrkl    equ   *-$wrk
         END
//*
//* prod version goes to linklib
//*
//L.SYSLMOD  DD DISP=SHR,DSN=CBT669.LINKLIB(ISPDPX01)
//L.SYSLIB   DD DISP=SHR,DSN=ISP.SISPLOAD
//*
//* production version is in linklib
//*
//IVP      EXEC PGM=IKJEFT1B,
//             PARM='ISPSTART CMD(ISX1IVP1)'
//STEPLIB  DD DISP=SHR,DSN=CBT669.LINKLIB
//SYSEXEC  DD DISP=SHR,DSN=CBT669.LIB
//SYSTSPRT DD SYSOUT=*
//SYSTSIN  DD DUMMY
//ISPMLIB  DD DISP=SHR,DSN=ISP.SISPMENU
//ISPPLIB  DD DISP=SHR,DSN=ISP.SISPPENU
//ISPSLIB  DD DISP=SHR,DSN=ISP.SISPSENU
//ISPTLIB  DD DISP=SHR,DSN=ISP.SISPTENU
//ISPPROF  DD UNIT=SYSDA,SPACE=(TRK,(5,5,4)),RECFM=FB,LRECL=80
//ISPLOG   DD SYSOUT=*,RECFM=VA,LRECL=125,BLKSIZE=129
//ISPFILE  DD SYSOUT=*,RECFM=FB,LRECL=80,BLKSIZE=6240
