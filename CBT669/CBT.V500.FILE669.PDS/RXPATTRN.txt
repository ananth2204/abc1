//RXPN003  JOB (1),'RXPATTRN-V003',
//*  RESTART=IVP1,
//         CLASS=A,COND=(0,LT)
//*
//* REXX function, Test a string against a pattern
//  SET IVP=1
//*
//A  EXEC ASMACL,PARM.C='TERM,RENT',
//          PARM.L='RENT,REUS,LIST,MAP,XREF,RMODE(ANY),AMODE(31)'
//C.SYSLIB  DD DISP=SHR,DSN=CBT669.LIB
//          DD DISP=SHR,DSN=SYS1.MACLIB
//          DD DISP=SHR,DSN=SYS1.MODGEN
//C.SYSTERM DD SYSOUT=*
//C.SYSIN   DD *
**asma syslib *
**asma opt term
*Process compat(macrocase)
*
* Test a string against a pattern
*
* Build: 003, 2020-07-21
*
*  Fixes in this build
*  - Possible false negative when mask and string has same length.
*    This is really a fix to the STRPATRN macro.
*
*  Changes in this build
*  - 4th parameter change to T for trace, better info for tracing.
*
* Syntax
*
*  rc = RxPattrn(string,pattern,wildcard,options)
*
* Parameters
*  string    just a string
*  pattern   the pattern to test against, or preprocess
*  wildcard  2 chars for one-char and zero-or-none test.
*            Optional, default is '%*'.
*  options   T for tracing
*
*  Return
*    0   ok
*    1   pattern not match
*    2   missing string
*    3   missing pattern
*    4   invalid wildcard length
*
* Installation notes
*
*  The  program will  by default  reload itself  thus retaining  the
* module in the  JPAQ. This improves performance  for multiple calls
* significantly. This load will not be  done if the program is added
* to the LPA, which is the recommended placement.
*  You can disable  the self-load option by  removing the 'CDEUCTZ2'
* statement.
*

         lclc  &name,&build
&name    setc  'RXPATTRN'
&build   setc  '003.1'
*-
         print off
         Copy  SYSMACS
         Copy  WSAMMACS
         Copy  REXXMACS
         print on
*- Reason
         Macro
         Reason &t,&c,&p3
         lcla  &l
&l       seta  k'&t-2
         mvc   reason(&l),=c&t
         mvc   reasonl,=a(&l)
         aif   (k'&c eq 0).x
         mvc   rc,=a(&c)
         aif   ('&p3' ne 'T' and '&p3' ne 't').x
         mvc   logr,reason
         trclog ,
.x       Mend

*- Trclog
         Macro
&ml      TrcLog &t,&k
         lclc  &l
&l       setc  'TL&sysndx'
&ml      ds    0h
         cli   trace,c'Y'
         jne   &l.x
         mvlit logr,&t
         aif   (k'&k eq 0).k0
         RxSay logr,&k
         ago   .b
.k0      RxSay logr
.b       anop
         clear logr
&l.x     equ   *
         Mend
*-
* Start module
*-
&name    #module base=r11,sa=sa1,work=(lclstorl,lclstor,r10,C),        c
               text='&build',epilog=epilog
         clear blank
         mvc   logr,blank
         mvc   reason,blank
         xc    rc,rc

*-
* Make sure module stays in memory
*-
         CDEUCTZ2 wto=N

*-
* init REXX interface
*-
         ereg  0,1
         RxInit parmlist=((string,A),(mask,A),       pointers          c
               (wildcd,2),(opt,1))                   data
         oc    opt,blank
         if    (cli,opt,eq,c'T'),then=(mvi,trace,c'Y')
         if    (cli,wildcd_ds,eq,0)
           mvc   wildcd(2),=c'*%'
           mvi   wildcd_ds,2
         endif

*-
* return version
*-
         if    (=a(7),eq,string+4),and,(zero,eq,mask+4) lengths
           l     r1,string
           mvc   dw(7),0(r1)                 copy text
           oc    dw,blank
           if    (=c'VERSION',eq,dw)
             la    r1,=cl6'&build'
             la    r2,6
             stm   r1,r2,retval
             #module end
           endif
         endif

*-
* list parameters if tracing
*-
         if    (cli,trace,eq,c'Y')
           print nogen
           trclog 'version &build'
           StrMake logr,'text    ',                                    c
               (string+0,4,cvxd),+1,         address                   c
               (string+4,4,cvxd),+1,         length                    c
               (string+6,2,cvd,3),+1,(f.string,f.string+4,,60)
           trclog
           StrMake logr,'mask    ',                                    c
               (mask+0,4,cvxd),+1,           address                   c
               (mask+4,4,cvxd),+1,           length                    c
               (mask+6,2,cvd,3),+1,(f.mask,f.mask+4)
           trclog
           StrMake logr,'wildcds ',                                    c
               (wildcd_ds,1,cvd,3),' "',wildcd,'"'
           trclog
           print gen
         endif

*-
* check parameters
*-
         if    (cli,string_ds,eq,0)
           Reason 'Missing string',2,t
           #module end
         endif
         if    (cli,mask_ds,eq,0)
           Reason 'Missing mask',3,t
           #module end
         endif
         if    (cli,wildcd_ds,ne,2)
           Reason 'Invalid wildcard',4,t
           #module end
         endif

*-
* Do pattern check
*-
         StrPatrn str=(f.string,f.string+4),                           c
               mask=(f.mask,f.mask+4),                                 c
               wc=wildcd
         st    r15,rc

         if    (cli,trace,eq,c'Y')
           lr    r2,r0            string addr
           la    r2,1(,r2)
           s     r2,string        pos -> offset
           lr    r3,r1            mask addr
           la    r3,1(,r3)
           s     r3,mask          pos -> offset
           strmake logr,'Result  x',(rc,4,cvxd),+1,(rc+2,2,cvd),       c
               ' strpos ',(r2,,cvdr,4),                                c
               ' maskpos ',(r3,,cvdr,4)
           TrcLog   ,
         endif

         if    (rc,ne,zero)
           strmake reason,'x',(rc,4,cvxd),lr=r2
           st    r2,reasonl
           mvc   rc,=a(1)
         endif
         #module end

*-
* Backend
*-

Epilog   #subr label

         if    (icm,r5,15,reasonl,nz)
           la    r4,reason
         else
           la    r4,=c' '
           la    r5,1
         endif
         RxVput name='RXPATTRN_RS',data=((r4),(r5))

         if     (icm,r4,15,retval,nz)        -> text
           l     r5,retval+4                 text length
         else
           l     r15,rc
           StrR2D reg=r15,to=(dw,8)
           la    r4,dw                       -> text
           la    r5,8                        text length
         endif
         if    (cli,trace,eq,c'Y')
           strmake logr,'rc ',((r4),(r5)),lenreg=r3
           trclog
         endif
         RxRetval (r4),(r5)

         #subr exit,rc=0

*-
* Inline data
*-

zero     dc    a(0)
         ltorg

*-
* Dynamic area
*-

LclStor  Dsect
sa1      ds    (2*18)f                 save areas
*-
blank    ds    cl150
reasonl  ds    a
reason   ds    cl100
fw       ds    f
dw       ds    d
rc       ds    a
retval   ds    2a(0)
*-
         RexxMacs ds
*-
         ds    0d
trace    ds    c
logrl    ds    a
logr     ds    cl130
         ds    0d
wrk256   ds    xl256
*-
LclStorL equ   *-LclStor

         Dsect
         RexxMacs dsect

         End
//*
//L.SYSLMOD DD DISP=SHR,DSN=CBT669.LPALIB(RXPATTRN)
//*
//* Production version is in LPALIB
//*
//* activate dynamic:
//*   SETPROG LPA,ADD,MODNAME=RXPATTRN,DSNAME=CBT669.LPALIB
//*
//IVP1     EXEC PGM=IKJEFT1B,PARM='%RXPNIVP&IVP'
//STEPLIB  DD DISP=SHR,DSN=CBT669.LPALIB
//SYSEXEC  DD DISP=SHR,DSN=CBT669.LIB
//SYSTSPRT DD SYSOUT=*,OUTLIM=(5000)
//SYSTSIN  DD DUMMY
//*
