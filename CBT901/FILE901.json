{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220013352000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 7054320, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 8, "INMDSNAM": "CBT.V500.FILE901.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 7054320, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 7054320, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE901.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00l\\x05'", "DS1TRBAL": "b'\\x90<'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xb0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xb0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x08\\xd4\\x00\\x01\\x08\\xdb\\x00\\x04\\x00m'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04X\\x00\\x01\\x01\\x132?\\x01\\x132?\\x139\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf8@@@'", "ispf": {"version": "04.88", "flags": 0, "createdate": "2013-11-19T00:00:00", "modifydate": "2013-11-19T13:39:01", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-488"}, "text": "REGULAR CBT TAPE - VERSION 488    FILE:  901\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT488.FILE901\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 16 MEMBERS COUNTED; CUMULATIVE SIZE IS 66,603 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   11/19/13    13:39:01    UTC-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$ASSIST": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x132?\\x01\\x132?\\x010\\x00r\\x00r\\x00\\x00\\xc1\\xe2\\xe2\\xc9\\xe2\\xe3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-11-19T00:00:00", "modifydate": "2013-11-19T01:30:00", "lines": 114, "newlines": 114, "modlines": 0, "user": "ASSIST"}, "text": "ASSIST - Assembler System for Student Instruction & Systems Teaching\n\nASSIST is a small, high-speed, low-overhead assembler/interpreter\nsystem especially designed for use by students learning assembler\nlanguage.  The assembler program accepts a large subset of the\nstandard Assembler Language under OS/360, and includes most\ncommon features.  The execution-time interpreter simulates the\nfull 360 instruction set, with complete checking for errors,\nmeaningful diagnostics, and completion dumps of much smaller size\nthan the normal system dumps.\n\nThe ASSIST package has been available from several Internet sites\nfor some time.  In fact, I had acquired an AWS tape image\ncontaining the package sometime in 2001, but my pursuit of\ninstalling it was interrupted by a hard drive crash and I just\ndid not get back to it until recently.  The package, as found on\nthe CBT tape (file #085 on the overflow tape) and at least a\ncouple of other locations I checked, seems to have been last\nupdated in March, 1975.  Part of the struggle in getting ASSIST\ninto an easily installable package for Hercules/MVS 3.8 was\ndealing with some strange spurious hex characters appearing in\nsome of the distribution members where only display characters\nshould have been.  I am extremely grateful for the help of Mike\nStack at NIU in attempting to help me track down the source of\nthese errors.  Eventually, I scrapped the CBT tape copy and used\nthe source from Mike's site at NIU, as well as using his\ninstallation jobstream as the model for what I built for\nHercules/MVS 3.8.  [Mike subsequently moved his ASSIST material\nto his personal site: http://kcats.org/]  Following this route\ngreatly reduced the problems with the source and, with a single\nexception, the source is exactly what is contained on Mike's\nsite.  By building SYSIN jobstreams for the installation reduced\nthe size of the files to download and hopefully prevents\nintroduction of further errors by translation of compressed data\nfrom ASCII/EBCIDIC and back repeatedly.\n\nThe installation archive - assist.tgz\n[MD5: 79D3361EF4ADAAD1FC1284C144E98C32] - contains six jobstreams:\n\n    assist$.jcl         This large jobstream installs the ASSIST\n                        load module, the macros ASSIST needs\n                        during execution, and a procedure to\n                        execute ASSIST.\n    astest00.jcl\n    astest01.jcl\n    astest02.jcl\n    astest03.jcl\n    astest04.jcl\n    astest05.jcl        These six jobs may be submitted to verify\n                        successful installation of ASSIST.  They\n                        contain many actual programs submitted by\n                        students, some with errors still intact.\n\nFollowing Mike's example, the assist$.jcl. jobstream copies all\nthe original source statements from SYSIN statements in the\njobstream to two temporary datasets.  Updates are then applied to\nthe datasets using statements also read from SYSIN.  All of\nASSISTs default options are controlled by settings of symbolic\nvariables in the ASSYSGEN macro.  As supplied, pretty much\neverything is \"turned on\" and it should be suitable for most\nfolks, as is.  If you want to make changes, you should make them\nin the update statements, not in the original.  With a little\nrearranging, IFOX00 is suitable for assembling ASSIST, so after\nthe updates are made to the temporary datasets, ASSIST is\nassembled and link-edited to SYS2.LINKLIB.  As always, if you\ndon't use SYS2.LINKLIB, simply change the DSN for the target\nlibrary.  The last two steps of the jobstream add the ASSIST\nmacros to SYS1.MACLIB and the catalogued procedure to\nSYS2.PROCLIB.  Again, change as required for your system.  The\ncompletion codes for all steps of this job should be 0000.\n\nSubmit one or all of the test jobs to verify successful\ninstallation.  Completion codes for all of these jobs should be\n0000, even though there will be errors listed for some of the\nprograms in the SYSOUT.\n\nThe ASSIST documentation included formatting control characters\nand were best when processed with the included copyed program\n(which I have not included here).  I have processed the members\nwith the program and subsequently placed the output into PDF\nfiles.  PDF compression greatly reduces the size of the files and\nthe text in the PDF is 100% searchable.  You may chose which, if\nany, of the documentation members to download and use:\n\n PDF File (Original Member)  Pages / Download Size   Contents\n asmintro (ASASSIGN)           247 / 660kb     Pennsylvania State\n                                               University introductory\n                                               information for beginning\n                                               students of assembler\n logic (ASPLMXXX)              181 / 403kb     ASSIST System Program\n                                               Logic Manual\n usergd (ASUSERGD)             72 / 205kb      ASSIST User's Guide\n xmsysgen (XMSYSGEN)            7 / 24kb       Summary of the XMacro\n                                               package\n xmwrites (XMWRITES)           22 / 61.2kb     XMacro Usage\n\nThe first document - asmintro - contains actual assignments given\nto students and a fair amount of basic information about OS and\ngood assembler programming methods.  Likewise, the ASSIST User's\nGuide - usergd - includes much basic assembler information.  The\nxmsysgen document will probably only be of interest to someone\nseeking to write additional X macros for the ASSIST system.\n\nA good textbook that incorporates the use of ASSIST in learning\n370 Assembler is IBM Assembly Language with ASSIST; Structured\nConcepts and Advanced Topics by Charles J. Kacmar.  As I write\nthis, there are 4 copies listed for sale at www.abebooks.com.\n\nI hope this has provided you with the information you need to get\nstarted assembling, compiling, link-editing, and executing\nprograms on your own.  If I can answer any questions about using\ncatalogued procedures for the compilers or if you find errors in\nthese instructions, please don't hesitate to send them to me:\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$MANUAL": {"ttr": 521, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x132?\\x01\\x132?\\x010\\x0ce\\x0ce\\x00\\x00\\xc1\\xe2\\xe2\\xc9\\xe2\\xe3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-11-19T00:00:00", "modifydate": "2013-11-19T01:30:00", "lines": 3173, "newlines": 3173, "modlines": 0, "user": "ASSIST"}, "text": "\n\n\n\n                                                       ASSIST1-1\n                                                       3.0/B\n                         ASSIST                        MARCH 1974\n               INTRODUCTORY ASSEMBLER USER'S MANUAL\n\n               Program&Documentation: John R. Mashey\n               Project Supervision  : Graham Campbell\n     Computer Science Department - Pennsylvania State University\n\n\nPREFACE\n\n     This manual is the  basic  reference  for  the  programmer  writing\nin the Assembler Language for the IBM S/360 computer, using  the  ASSIST\nassembler-interpreter system.   ASSIST  (Assembler  System  for  Student\nInstruction and Systems Teaching) is a small,  high-speed,  low-overhead\nassembler/interpreter system especially designed  for  use  by  students\nlearning assembler language.  The  assembler  program  accepts  a  large\nsubset of the standard Assembler Language  under  OS/360,  and  includes\nmost  common  features.  The execution-time  interpreter  simulates  the\nfull 360 instruction set, with complete checking  for  errors,  meaning-\nful diagnostics, and completion dumps of  much  smaller  size  than  the\nnormal system dumps.\n\n     The first part of  this  manual  describes  the  assembly  language\ncommands permitted by  the  ASSIST  assembler.   In  essence,  it  is  a\ncomparison with the standard  Assembly  Language,  and  generally  notes\nonly the omissions or differences from the standard.  The reader  should\nrefer to one of the following publications, which the first part of this\nmanual closely follows (depending on operating system used):\n\nC28-6514  IBM SYSTEM/360 OPERATING SYSTEM ASSEMBLER LANGUAGE\n\nC24-3414  IBM SYSTEM/360 DISK AND TAPE OPERATING SYSTEM ASSEMBLER LANG.\n\n     The second  section  describes  input/output,  decimal  conversion,\nhexadecimal conversions, and debugging  facilities available to the user\nat execution time.\n\n     The third part of  the  manual  describes  the  control  cards  and\nJob  Control  Language  required  to  assemble  and  execute  a  program\nunder  ASSIST.   It  also  notes  the  various  options  from  the  PARM\nfield which are accepted by the system.\n\n     The  fourth  section  gives  information  concerning   the   output\nfrom  ASSIST,  including  the  assembly  listing,  the  format  of   the\ncompletion  dump  produced  by  an  error  in  program  execution,   and\na list of all error messages  produced  during  assembly  or  execution.\nIt also describes the object decks produced/accepted by ASSIST.\n\n               Note:  this document is NOT copyrighted.\n\n               Note: only major change in documentation from version 2.1\n                     is the inclusion of cross-reference material(XREF)\n                     and the inclusion of the extended interpreter\n                     material.\n\n\n                                                      ASSIST1-2\n                    TABLE OF CONTENTS\n\nPART I. THE ASSEMBLY LANGUAGE UNDER ASSIST................. 1-4\n     The sections flagged * note that the given language features\n     are not accepted by ASSIST.\n\nSECTION I: INTRODUCTION.................................... 1-4\n     Compatibility......................................... 1-4\n     Macro Instructions.................................... 1-4\n     The Assembler Program................................. 1-5\n\nSECTION 2: GENERAL INFORMATION............................. 1-5\n     Symbols............................................... 1-5\n     General Restrictions on Symbols....................... 1-5\n     Location Counter References........................... 1-5\n     Literals.............................................. 1-5\n     Literal Pool.......................................... 1-5\n     Expressions........................................... 1-5\n\nSECTION 3: ADDRESSING -- PROGRAM SECTIONING AND LINKING.... 1-6\n     USING -- Use Base Register............................ 1-6\n     CONTROL SECTIONS...................................... 1-6\n     Control Section Location Assignment................... 1-6\n     FIRST CONTROL SECTION................................. 1-6\n     START -- Start Assembly............................... 1-6\n     CSECT -- Identify Control Section..................... 1-6\n     DSECT -- Identify Dummy Section....................... 1-6\n    *EXTERNAL DUMMY SECTIONS (ASSEMBLER F ONLY)............ 1-6\n    *COM -- DEFINE BLANK COMMON CONTROL SECTION............ 1-6\n\nSECTION 4: MACHINE INSTRUCTIONS............................ 1-7\n     Instruction Alignment and Checking.................... 1-7\n     OPERAND FIELDS AND SUBFIELDS.......................... 1-7\n\nSECTION 5: ASSEMBLER LANGUAGE STATEMENTS................... 1-7\n    *OPSYN -- EQUATE OPERATION CODE........................ 1-7\n     DC -- DEFINE CONSTANT................................. 1-7\n     Operand Subfield 3: Modifiers......................... 1-7\n     Operand Subfield 4: Constant.......................... 1-7\n     CCW -- DEFINE CHANNEL COMMAND WORD.................... 1-8\n     Listing Control Instructions.......................... 1-8\n     TITLE -- IDENTIFY ASSEMBLY OUTPUT..................... 1-8\n     PRINT -- PRINT OPTIONAL DATA.......................... 1-8\n     PROGRAM CONTROL INSTRUCTIONS.......................... 1-8\n    *ICTL, ISEQ, PUNCH, REPRO.............................. 1-8\n     LTORG -- BEGIN LITERAL POOL........................... 1-8\n     Special Addressing Considerations..................... 1-8\n     Duplicate Literals.................................... 1-8\n    *COPY -- COPY PREDEFINED SOURCE CODING................. 1-8\n\nSECTION 6: INTRODUCTION TO THE MACRO LANGUAGE ............. 1-9\nSECTION 7: HOW TO PREPARE MACRO DEFINITIONS ............... 1-10\nSECTION 8: HOW TO WRITE MACRO-INSTRUCTIONS ................ 1-10\nSECTION 9: HOW TO WRITE CONDITIONAL ASSEMBLY INSTRUCTIONS . 1-11\nSECTION 10: EXTENDED FEATURES OF THE MACRO LANGUAGE ....... 1-12\n\n\n                                                      ASSIST1-3\n\nPART I. (CONTINUED)\nAPPENDIX K: USE OF LIBRARY MACROS.......................... 1-12\n\nPART II. INPUT/OUTPUT AND DEBUGGING INSTRUCTIONS........... 2-1\n\nINPUT/OUTPUT INSTRUCTIONS - XREAD, XPRNT, XPNCH............ 2-1\n     CONDITION CODE........................................ 2-1\n     CARRIAGE CONTROL...................................... 2-1\n     EXAMPLES OF XREAD, XPRNT, XPNCH USAGE................. 2-2\n\nDEBUGGING INSTRUCTION - XDUMP.............................. 2-3\n     GENERAL PURPOSE REGISTER DUMP......................... 2-3\n     STORAGE DUMP.......................................... 2-3\n     EXAMPLES OF XDUMP USAGE............................... 2-3\n\nDECIMAL CONVERSION INSTRUCTIONS - XDECI, XDECO............. 2-4\n     XDECI................................................. 2-4\n     XDECO................................................. 2-4\n     SAMPLE USAGE OF XDECI................................. 2-5\n     SAMPLE USAGE OF XDECO................................. 2-5\n\nHEXADECIMAL CONVERSION INSTRUCTIONS - XHEXI, XHEXO......... 2-6\n     XHEXI................................................. 2-6\n     XHEXO................................................. 2-6\n     SAMPLE USAGE OF XHEXI AND XHEXO....................... 2-7\n\nLIMIT DUMP INSTRUCTION - XLIMD............................. 2-8\n     SAMPLE USAGE OF XLIMD................................. 2-8\n\nOPTIONAL INPUT/OUTPUT INSTRUCTIONS - XGET, XPUT............ 2-9\n     CONDITION CODE........................................ 2-9\n     CARRIAGE CONTROL...................................... 2-9\n     EXAMPLES OF XGET AND XPUT USAGE....................... 2-10\n\n\n\n\nPART III. ASSIST CONTROL CARDS AND DECK SETUP.............. 3-1\n\nA. JOB CONTROL LANGUAGE.................................... 3-1\n\nB. OPTIONAL PARAMETERS FOR ASSIST.......................... 3-2\n\nC. DESCRIPTION OF INDIVIDUAL OPTIONS....................... 3-4\n\nPART IV. ASSIST OPTIONAL EXTENDED INTERPRETER.............. 4-1\n\nA. GENERAL DESCRIPTION OF NEW FEATURES..................... 4-1\n\nB. THE XOPC (Assist OPtions Call) DEBUGGING INSTRUCTION.... 4-2\n\nPART V.  OUTPUT AND ERROR MESSAGES......................... 5-1\n\nA. ASSEMBLY LISTING........................................ 5-1\n     1. ASSEMBLY LISTING FORMAT............................ 5-1\n     2. ASSEMBLER ERROR MESSAGES........................... 5-1\n     3. LIST OF ASSEMBLER ERROR MESSAGES................... 5-2\n     4. ASSEMBLER STATISTICS SUMMARY....................... 5-10\n\nB. ASSIST MONITOR MESSAGES................................. 5-11\n     1. HEADING AND STATISTICAL MESSAGES................... 5-11\n     2. ASSIST MONITOR ERROR MESSAGES...................... 5-12\n\nC. ASSIST COMPLETION DUMP.................................. 5-13\n\nD. COMPLETION CODES........................................ 5-14\n\nE. OBJECT DECKS AND LOADER MESSAGES........................ 5-15\n     1. OBJECT DECK FORMAT................................. 5-15\n     2. ASSIST LOADER USAGE AND MESSAGES................... 5-16\n\n\n\nPART I. THE ASSEMBLY LANGUAGE UNDER ASSIST\n\n     This  section  deals  with  the  subset  of  the  standard   OS/360\nAssembler  Language  accepted  be  the  ASSIST  assembler.   Because  it\nfollows  the  standard  very  closely,  the  following  describes   only\nthose language  features  which  ASSIST  omits  or  treats  differently.\nThe user should generally consult the  previously-mentioned  publication\nfor most of the information on  the  assembler  language.   The  section\nheadings and sub-headings  in  this  manual  are  taken  from  the   IBM\npublication, and any sections omitted may be assumed to be the  same  as\nthe corresponding sections in the IBM manual.\n\nSECTION 1: INTRODUCTION\n\nCompatibility\n     With  a  few  possible  exceptions,  any  program  which  assembles\nand executes correctly under ASSIST should  do  so  using  the  standard\nOS/360 software, and should produce the same  output  as  under  ASSIST.\nAt most, a change of Job Control Language might be necessary.\n\n\n\nThe Assembler Program\n     The assembler program produces a listing of the source program, and\nnormally creates an object program directly in main memory, while  using\nno secondary storage, unless requested.  An object deck can be  punched.\n\nSECTION 2: GENERAL INFORMATION\n\nGeneral Restrictions on Symbols\n     A symbol may be defined only once in  an  assembly,  i.e.,  it  may\nappear in  the  name  field  of  no  more  than  one  instruction.   The\nsame symbol may not  be  used  as  a  label  in  two  different  control\nsections, and control  sections  may  not  be  resumed,  the  only  case\nin the standard language allowing the  same  symbol  on  more  than  one\nstatement.\n\nLocation Counter Reference\n     ASSIST allows  full  use  of  the  location  counter  *,  with  the\nfollowing exceptions:\n\n     1. The programmer may not refer  to  the  location  counter  inside\na  literal  address  constant.   Thus,  the  following  statement   will\nproduce incorrect results:\n\n          L    1,=A(*+20)\n\n     2. The  programmer  may  not  refer  to  the  location  counter  in\nan  A-type  address  constant  having  a  duplication   factor   greater\nthan one, if the reference is made  in  such  a  way  that  the  various\nduplications  of  the  specified   constant   have   different   values.\nFor instance,  under  OS/360,  the  following  statement  would  produce\nthe  values  0,1,...,255,  but  ASSIST  would  produce  256   bytes   of\nzero:\n\nNAME      DC    256AL1(*-NAME)\n\nLiterals\n     Literal  constants  may  not  contain  more  than  112  characters,\ncounting the beginning = and ending  delimiter,  i.e.  may  not  require\nmore than two cards when placed in the literal pool.\n\nLiteral Pool\n     Unless otherwise specified by the use  of  the  LTORG  instruction,\nthe literal pool is placed after the program's  END  card,  rather  than\nat the end of the first control section in the program.\n\nExpressions\n     Use of  general  expressions  is  permitted  for  most  statements.\nAny restrictions are noted under the individual statements.\n\n\n                                                      ASSIST1-6\n\nSECTION 3: ADDRESSING -- PROGRAM SECTIONING AND LINKING\n\nUSING -- Use Base Register\n     The first  expression  (address)  in  a  USING  statement  must  be\nrelocatable.\n\nCONTROL SECTIONS\n     Multiple control sections are  allowed.   A  program  must  contain\nat least one  control  section.\n\nControl Section Location Assignment\n     Control  sections  may  not  be  intermixed  under  ASSIST,   i.e.,\nall  the  statements  of  one  control  section  must  be  coded  before\nanother is begun.\n\nFIRST CONTROL SECTION\n     Under  ASSIST,  the  first  control  section  has   no   properties\ndifferent  from  the  other  sections,  i.e.,   its   initial   location\ncounter value must be relocatable, and  it  does  not  normally  contain\nunassigned literal constants unless it  is  the  only  control  section.\n\nSTART -- Start Assembly\n     The  START  instruction  may  be  preceded   by   listing   control\ninstructions and comments cards.  The same label may not be  used  on  a\nSTART statement and a later CSECT statement.\n\nCSECT -- Identify Control Section\n     No more  than  one  CSECT  may  use  a  given  symbol  as  a  name,\nand  statements  from  different  CSECT's  may  not   be   interspersed.\n\nDSECT -- Identify Dummy Section\n     No more than one DSECT may use  a  given  symbol  as  a  name,  and\nstatements from different DSECT's may not be interspersed.\n\nEXTERNAL DUMMY SECTIONS (ASSEMBLER F ONLY)\n     External  dummy  sections  are  not  supported,  so  the   commands\nCXD and DXD are not recognized.\n\nCOM -- DEFINE BLANK COMMON CONTROL SECTION\n     COM is not allowed.\n\n\n                                                      ASSIST1-7\n\nSECTION 4: MACHINE-INSTRUCTIONS\n\nInstruction Alignment and Checking\n     If  any  statement  requires  alignment  and  causes  bytes  to  be\nskipped, the bytes skipped are NOT necessarily set to hexadecimal zeros.\n\nOPERAND FIELDS AND SUBFIELDS\n     ASSIST permits the same use of expressions  in  machine-instruction\noperand fields as does the standard assembler.\n\n\nSECTION 5: ASSEMBLER LANGUAGE STATEMENTS\n\nOPSYN -- EQUATE OPERATION CODE is not accepted.\n\nDC -- DEFINE CONSTANT\n     Multiple operands (up to 10 operands  in  a  single  DC  statement)\nand multiple  constants  within  operands  are  both  permitted.   Bytes\nskipped to align a DC statement are NOT zeroed.\n\nOperand Subfield 3: Modifiers\n     The following modifiers are not permitted by ASSIST:\nBit-Length  Specification,  Scale  Modifier,  and   Exponent   Modifier.\n\nOperand Subfield 4: Constant\nFixed-Point Constants -- F and H:\n     Fixed-point constants may not contain decimal points  or  exponents\nWhile lengths may range from one to eight bytes, the minimum and maximum\nvalues permitted are those for length 4.\n\nFloating-Point Constants -- E and D:\n     No scale or exponent  modifiers  are  allowed,  but  exponents  are\naccepted within each constant.\n\nDecimal Constants -- P and Z:\n     If no  explicit  length  is  supplied  for  an  operand  containing\nmultiple constants, each of the operands  is  assembled  to  the  length\nof the last  constant  in  the  operand,  even  if  truncation  is  thus\nrequired.  For example, under  the  standard  assembler,  the  following\nneeds four bytes.  Under  ASSIST  it  is  assembled  into  three  bytes,\nwith the second constant truncated:\n          DC    P'0,20,1'\n\nAddress  Constants:  only  A  and  V  address  constants  are   allowed.\n\nComplex Relocatable Expressions: are not allowed.\n\nA-type  Address  Constant:  may  not  be  used  in  a  literal  constant\nif it refers to the location counter.  It will be  assembled  improperly\nif it does so.\n\nY-Type,  S-Type,  and  Q-Type  Address  Constants:   are  not   allowed.\n\n\n                                                      ASSIST1-8\n\nCCW -- DEFINE CHANNEL COMMAND WORD\n     The CCW is recognized and allocated storage, but is  not  otherwise\nassembled.  It will be flagged 'NOT CURRENTLY IMPLEMENTED'.\n\nListing Control Instructions\n\nTITLE -- IDENTIFY ASSEMBLY OUTPUT\n     No title may have a symbol in the name field.\n\nPRINT -- PRINT OPTIONAL DATA\n     All operands are accepted, but DATA and NODATA have no effect, i.e.\nno more than eight bytes  of  data  are  ever  printed.   Any  statement\nflagged with an  error  or  warning  is  always  printed,  even  if  the\nprint control is OFF, or NOGEN for generated statements.\n\nPROGRAM CONTROL INSTRUCTIONS\n\nICTL  --  INPUT  FORMAT  CONTROL,  ISEQ  --  INPUT  SEQUENCE   CHECKING,\nPUNCH --  PUNCH  A  CARD,  and  REPRO  --  REPRODUCE  FOLLOWING  CARD  :\nare not accepted by ASSIST.\n\nLTORG -- BEGIN LITERAL POOL\n\n     Any literals used  after  the  last  LTORG  are  placed  after  the\nEND  card,  instead  of  at  the  end  of  the  first  control  section.\n\nDuplicate Literals:\n     Duplicate literals are  never  stored,  since  the  programmer  may\nnot  refer  to  the  location  counter  in  a  literal  A-type   address\nconstant,  the  only  case  under  the  regular  system  requiring   the\nstoring of duplicate literals.\n\nCOPY -- COPY PREDEFINED SOURCE CODING: is not allowed.\n\n\n                                                       ASSIST1-9\n\nSECTION 6: INTRODUCTION TO THE MACRO LANGUAGE\n\n     The macro language is a facility which may or may not be   included\nin a particular version of ASSIST.  Also, various levels of the   ASSIST\nmacro processor can be generated, so that the user should check  to  see\nwhich  one(s)  are  available  at  his  installation.    The   following\nfacilities may be available:\n\nBASIC (F) MACRO FACILITY:  allows programmer-written macros,  compatible\nwith Assembler(F), but without macro library or  open  code  conditional\nassembly.\n\nEXTENDED (G&H) MACRO FACILITY:  like BASIC  above,  but  allows  certain\nfeatures not supported by Assembler F, but allowed by Assemblers G or H.\n\nMACRO LIBRARY:  some versions of ASSIST permit system macros to be  used\nin addition to programmer-written macros.  This  facility  requires  the\nuse of a special comment card (*SYSLIB), as described later.\n\nOPEN CODE CONDITIONAL ASSEMBLY:  system assemblers  allow  the  user  to\nuse conditional assembly statements and SET  variables  outside  macros,\ni.e., in the open code, or main  body  of  the  program.   With  certain\nrestrictions as noted, this facility can be supplied if desired.\n\n     Finally, in order to use macros at all, the user  must  supply  the\nparameter  MACRO= , as described in Part III.\n\n\nTHE MACRO DEFINITION\n\n     COPY statements are not allowed.\n\nTHE MACRO LIBRARY\n\n     Certain restrictions exist in ASSIST's processing of system macros.\nOne or more *SYSLIB  cards  must  follow  any  programmer-defined  macro\ndefinitions.  These cards indicate that library search is required,  and\nmust name any macros which are called from the open code later, but have\nnot been previously mentioned in  the  programmer-written  macros.   The\nuser should consult the appendix USE OF LIBRARY  MACROS  in  this  PART.\n\nSYSTEM AND PROGRAMMER MACRO DEFINITIONS\n\n     Since ASSIST reads in system macros and edits them upon command  of\n*SYSLIB cards immediately following  programmer macros, they are treated\nexactly the same as programmer macros, except that they are not  printed\nunless requested by the LIBMC option.  Errors are  attached  to  correct\nstatements.\n\n\n                                                       ASSIST1-10\n\nSECTION 7: HOW TO PREPARE MACRO DEFINITIONS\n\n\nMACRO INSTRUCTION PROTOTYPE\n\n     Two formats are allowed for statements, the normal one used by  all\nother statements, and the alternate one allowed only for macro prototype\nand macro call statements.  ASSIST does allow macro prototypes and macro\ncalls to be continued on an indefinite number of cards.  When there  are\nno more than 2 continuation cards, ASSIST is completely compatible  with\nother assemblers.  If the total number of cards in a  statement  exceeds\n3, the following restriction must be followed:  every third card in  the\nstatement must use the alternate format, unless  it  is  the  last  one.\n(This is done because ASSIST processes cards in groups of 3).   The  two\nprototypes below illustrate this restriction:\n\nPROTOTYPE ACCEPTED BY ASSEMBLERS F,G, H, VS, BUT NOT ASSIST:\n&LABEL   LONGPROT   &PARM1,&PARM2,      PARMS,ALTERNATE FORMAT         X\n               &PARM3,&PARM4,&PARM5,    PARMS,ALTERNATE FORMAT         X\n               &PARM6,&PARM7=XXXXXXXX,&PARM8=YYYYYYYY,&PARM9=ZZZZZZZZ,&X\n               PARM9=A                  LAST LINE\n\nEQUIVALENT PROTOTYPE, ACCEPTED BY ASSIST:\n&LABEL   LONGPROT   &PARM1,&PARM2,      PARMS,ALTERNATE FORMAT         X\n               &PARM3,&PARM4,&PARM5,    PARMS,ALTERNATE FORMAT         X\n               &PARM6,&PARM7=XXXXXXXX,&PARM8=YYYYYYYY,&PARM9=ZZZZZZZZ, X\n               &PARM9=A                 LAST LINE\n\n     Given this restriction, it is best to place  any  positional  parms\nearly in the list if they may require long values needing  continuation.\n\nMODEL STATEMENTS\n\n     Variable symbols MAY be used to generate PRINT and END operations .\nIf the open code feature is allowed, they may also be used  to  generate\ncalls to macros at the outer level, but not inside macros.\n\nCOPY STATEMENTS\n\n     COPY statements are not allowed.\n\nSECTION 8: HOW TO WRITE MACRO-INSTRUCTIONS\n\n     There are no changes from the IBM standard.\n\n\n                                                       ASSIST1-11\n\nSECTION 9: HOW TO WRITE CONDITIONAL ASSEMBLY INSTRUCTIONS\n\n     All of the conditional assembly instructions  may  be  used  inside\nmacros.  They may only be used outside if the version  of  ASSIST  being\nused supports it, and there are restrictions in that use  in  any  case.\n\nATTRIBUTES\n\n     ASSIST is a two-pass assembler, performing macro-processing 'on the\nfly' during pass 1.  As such, it is impossible for it  to  usually  know\nthe attributes of a symbol, so  there  are  definite  restrictions.   In\neffect, the only attributes are those which can be found by looking just\nat a macro call  statement  by  itself.   The  attributes  allowed  are:\n\nAttribute      Notation\nType           T'        only values N, O, and U possible\nCount          K'\nNumber         N'\n\n     Thus, Length (L'), Scaling (S'), and Integer  (I')  attributes  are\nnot supported.  The only values for Type are N (Numeric),  O  (Omitted),\nand U (undefined), so that the value is U under  ASSIST  in  many  cases\nwhere it would be something else under IBM assemblers.\n\nAIF -- CONDITIONAL BRANCH\n\n     IBM assemblers normally assign 4096 as the usual limit  for  number\nof AIF and AGO branches.  See ACTR for  the  way  ASSIST  handles  this.\n\n     The sequence symbol named in the AIF  may  precede  or  follow  the\nAIF statement inside macros.  Outside macros, it  may  only  follow  the\nAIF, i.e., only forward branches are allowed.  If a branch is  taken  to\na previously-defined sequence symbol in open code, ASSIST  produces   an\nan error message and ignores the AIF/AGO.\n\nAGO -- UNCONDITIONAL BRANCH\n\n     AGO follows the same restriction as AIF:   backwards  branches  are\nallowed in macros, but not in open code.\n\nACTR -- CONDITIONAL ASSEMBLY LOOP COUNTER\n\n     ASSIST supports the standard ACTR.  However, the default  value  of\nthe ACTR counter is set differently, via the MACTR= option  supplied  by\nthe user.  This has a default value as  given  in  PART  III,  which  is\nnormally smaller than the IBM value 4096.  The MACTR= value is used  for\nall macro definitions, unless explicitly overridden via ACTR statements.\n\nCONDITIONAL ASSEMBLY ELEMENTS\n\n     There are no changes, except that attributes L', S', and I' are not\nsupported.\n\n\n                                                       ASSIST1-12\n\nSECTION 10: EXTENDED FEATURES OF THE MACRO LANGUAGE\n\nMNOTE -- REQUEST FOR ERROR MESSAGE\n\n     The MNOTE statements accepted by ASSIST follow  the  standard,  but\nASSIST effectively ignores  the  use  of  severity  codes,  except  that\nMNOTE'S with numerical severity codes are printed as errors  while  ones\nwith * are printed in another format.\n\n&SYSECT -- Current Control Section\n\n     CSECT or DSECT statements processed in a macro  definition  do  NOT\naffect the value for &SYSECT for any subsequent  inner  macros  in  that\ndefinition.\n\nMACRO DEFINITION COMPATIBILITY\n\n     ASSIST does not accept AGOB or AIFB.\n\n\nAPPENDIX K: USE OF LIBRARY MACROS\n\n     This section describes the deck layout and  use  of  *SYSLIB  cards\nwhen the user desires to use macros from a system library.  Brief  notes\nare given regarding internal workings of macro processing, in  order  to\nhelp the requirements be more meaningful.\n\n     ASSIST performs all macro-processing during the first pass  of  its\ntotal of two passes across the source program.  Macro processing  itself\nhas two stages.  During the EDIT  stage,  macro  definitions  are  read,\nscanned, and printed, while tables are built in memory describing  them.\nThe EXPANSION stage is part of the  normal  first  pass  of  a  two-pass\nassembler, so that every time a macro call  is  encountered,  the  macro\nprocessor expands the call into 0 or more statements, which then act  as\nthough they had been read in the normal way.\n\n     For best use of limited memory, ASSIST requires  that  ALL  EDITING\nbe done before ANY EXPANSION.   During  editing  of  programmer  macros,\na list is kept of opcodes not yet defined, and  these  are  presumed  to\nbe system macros.  Any system macros called  by  programmer  macros  are\ntherefore known to ASSIST, and so it can fetch them  from  the  library.\nHowever, if a system macro is only called at in the open code, there  is\nno way for ASSIST to know that it will be needed  later.   Also,  it  is\ndesirable that the user specify whether  the  macro  library  should  be\nsearched at all, in order to avoid searching the library for a mispelled\nopcode name automatically.  Thus, a special comments card,  *SYSLIB,  is\nused to inform assist that it should actually  perform  library  search.\nThe format of the *SYSLIB card is either of the following:\n\n*SYSLIB     name1,name2,......           comments\n*SYSLIB\n\n     The first form gives a list of 1 or more macro names,  seprated  by\ncommas, free format.  The second  form  contains  no  operands  at  all.\n\n\n                                                       ASSIST1-13\n\nThe second form may be used only when all library macros  appear in  the\nuser's macro definitions.\n\n     The *SYSLIB card should follow all programmer macros (if any),  and\nmust precede any of the statements of the open code, except for  comment\nand listing control  (PRINT, TITLE, EJECT, SPACE) statements.  The  user\nmay supply 1 or more *SYSLIB cards, as  long  as  these  conditions  are\nfulfilled, thus allowing some convenience.\n\n     When finding any *SYSLIB card in a  proper  location,  ASSIST  does\nthe following:\n\n1.   Scans the card, adding any name found there to the  list  of  macro\nnames.  If the name is already in  the  list,  it  is  totally  ignored.\n\n2.   Scans the list of macro names.  If  a  macro  is  not  defined,  it\nsearches the macro library for it.  If the  macro  cannot  be  obtained,\nit marks the macro  'searched  for',  and  never  looks  for  it  again.\n\n3.   If the macro is found during 2, the print control  is  turned  OFF,\nunless the user specified LIBMC, in which  case  the  print  control  is\nunchanged.  The macro is then read and edited, like a programmer  macro.\n\n4.   During step 3, the macro being read may refer to other  macros  not\nyet defined, and these are added to the macro list also.   The  loop  of\nsteps 2,3,4 continues until all macros in  the  list  have  either  been\nfound or searched for.  Thus, it is possible  for  a  reference  to  one\nmacro to cause a number of macros to be fetched from  the  library.   At\nthis point, print control is restored to its original value, and a  list\nof undefined macros is produced.\n\n     The following gives the overall layout of a program:\n\n.....     0 or more programmer macro  definitions,  with  print  control\n          statements interspersed if desired.\n.....     1 or more *SYSLIB cards\n.....     0 or more GBLx  declarations  (if open code cond. asm allowed)\n.....     0 or more LCLx  declarations      \"\n.....     ACTR                              \"\n.....     open code (main body of program)\n\n     The following shows appropriate *SYSLIB use, although  the  program\nitself should not be expected to make sense:\n\n          MACRO\n          PRGMAC1 &ARG\n          CALL  X\n          MEND\n*SYSLIB   SAVE           WE WILL NEED SAVE MACRO\n*SYSLIB   RETURN,EQUREGS     OTHER MACROS NEEDED\n*         CALL (USED IN PRGMAC1), IS NOT NEEDED (BUT  COULD  BE)  ABOVE.\n         USING *,15\n         SAVE (14,12)\n         PRGMAC1\n         RETURN (14,12)\n         EQUREGS\n\n\n                                                       ASSIST1-14\n\nHINTS ON OPTIMAL USE OF  MACRO LIBRARY\n\n     The user should be aware of the  following  when  using  the  macro\nlibrary facility:\n\n1.   The macro processor  is  mainly  intended  to  process  programmer-\nwritten macros.  Among other things, all macro dictionaries  and  tables\nare kept in memory for the sake of speed.\n\n2.   Most IBM macros, and many XMACROS, call inner  macros,  which  call\nother inner macros, which call others,  etc,  etc.   Thus,  calling  one\nmacro from the library may cause many  others  to  be  brought  in.   In\nparticular, almost every IBM macro calls the  macro  IHBERMAC  to  issue\nMNOTE statements for any error messages.   IHBERMAC  contains  over  400\nstatements, with many memory-consuming MNOTEs included.\n\n3.   If a macro is referenced, it is fetched from the  library,  whether\nit is actually ever called or not.  For example, IHBERMAC is only called\nwhen there is an error, but is always fetched.\n\n4.   Given the combination of 1,2,3 above,  it  is  easily  possible  to\nuse macros like CALL, SAVE, RETURN, XSAVE,  XRETURN,  which  do  not  in\nthemselves seem large, but exceed memory quickly.  (CALL,  SAVE,  RETURN\nall use IHBERMAC; XSAVE and XRETURN  contain  GETMAIN  and  FREEMAIN  to\nsupport the REEN= option,  and  GETMAIN/FREEMAIN  both  call  IHBERMAC).\nAnother example is using ASSIST to check out a QSAM  program:   ask  for\nOPEN, CLOSE, GET, PUT, and DCB:  ASSIST processes these  correctly,  but\n2700 statements are added to the program by the macros and  all  of  the\ninner macros.  A simple program can easily require 250K bytes of  memory\nfor assembly, given such macros.\n\n     Given the above circumstances, care must be taken with the  library\nfacility in order to make efficeient use of it.  Given such care, ASSIST\nis fast and small enough  to  check  out  fairly  large  programs  in  a\n'reasonable' amount of memory and time.  The following are useful tricks\nfor saving time and space:\n\n1.   WRITE REDUCED VERSIONS OF  COMMON  MACROS,  AND  PLACE  THEM  IN  A\nSPECIAL LIBRARY, TO BE ACCESSED FIRST BY ASSIST. For example, remove the\nREEN option from XSAVE/XRETURN, replace  IHBERMAC  calls  by  MNOTEs  in\nCALL, SAVE, RETURN, etc.\n\n2.   USE LIBMC OPTION TO EXAMINE LIBRARY MACROS.  WRITE DUMMY MACROS  TO\nKEEP UNUSED ONES FROM BEING FETCHED.  For example, if you  know  that  a\ngiven  macro  will  NOT  actually  be  called,  write  a  dummy,   like:\n\n     MACRO\n     IHBERMAC  &A,&B,&D,&E,&F,&H\n     MNOTE 4,'PSEUDO IHBERMAC CALLED: &A,&B,&D,&E,&F,&H'\n     MEND\n\n3.   IF NECESSARY, USE THE DISKU OPTION, IF AVAILABLE.  The intermediate\ntext saved between the two passes can  be  spilled  to  disk/drum,  thus\nallowing  more  space  for  macro  dictionaries,  symbol   table,   etc.\n\n\n                                                      ASSIST2-1\n\nPART II. INPUT/OUTPUT AND DEBUGGING INSTRUCTIONS\n     ASSIST  accepts  as  special  machine  instructions  some  commands\nwhich are handled by OS/360  as  macro-instructions.   They  essentially\npermit the user to read and punch  cards,  print  lines,  and  dump  the\ncontents  of  his  registers  and  storage  areas.   They  also  provide\neasy input/output conversions for decimal numbers.\n\n     The following table gives the encodings of the special  commands of\nASSIST, which use currently undefined opcodes, and ARE SUBJECT TO CHANGE\nAT ANY TIME.  In some cases, a Mask field is used to differentiate among\ndifferent commands using the same opcode.  The notation RX-SS under  the\ncolumns for OPERAND FORMAT implies that the  first  four  bytes  of  the\ninstruction follow standard RX format, with the Mask field   giving  the\nspecific type of operation.  The third halfword specifies  the   length,\nwhich is encoded in the same way as are lengths in  Shift  instructions,\nexcept the length is taken from register 0 if the halfword is all zero .\nEXAMPLES:  XREAD 0(1,2),100            ==>   X'E00120000064'\n           XPRNT 2(3,4),(1)            ==>   X'E02340021000'\nCOMMAND OPCODE MASK LENGTH    OPERAND FORMAT\nXDECI   X'53'   -   4 bytes   normal RX\nXDECO   X'52'   -   4 bytes   normal RX\nXDUMP   X'E1'   -   6 bytes   (register form - no operands) -  last\n                              five bytes totally ignored.\nXDUMP   X'E0'   6   6 bytes   (storage form) - RX-SS\nXGET    X'E0'   A   6 BYTES   RX-SS\nXHEXI   X'61'   -   4 bytes   normal RX\nXHEXO   X'62'   -   4 bytes   normal RX\nXLIMD   X'E0'   8   6 bytes   RX-SS\nXPNCH   X'E0'   4   6 bytes   RX-SS\nXPRNT   X'E0'   2   6 bytes   RX-SS\nXPUT    X'E0'   C   6 bytes   RX-SS\nXREAD   X'E0'   0   6 bytes   RX-SS\nXREPL   X'A0'   -   4 bytes   SI - immediate field gives operation\n\nINPUT/OUTPUT INSTRUCTIONS - XREAD, XPRNT, XPNCH\n\n     Basic input/output facilities are provided by XREAD (card  READer),\nXPRNT (line PRiNTer), and XPNCH (card PuNCH).  They  are  written  using\nthe following format:\n\nlabel     XMACRO area,length\n\nlabel     is an optional statement label\nXMACRO    is XREAD, XPRNT, XPNCH\narea      is the address in memory to be read or written.\n     This area may be specified by an RX-type  address,  i.e.,  anything\nlegal as the second operand of a LA instruction, such as:\n\n0(1,2), AREA2+10, CARD+1(3), or =CL30'0 MESSAGE'  .\n\nlength     specifies  the  number  of  bytes  to  be  read  or  written.\n     This length can  range  from  1  to  the  maximum  length  for  the\nappropriate device (80 for XREAD,XPNCH,  133  for  XPRNT).   The  length\nfield may be omitted, in which  case  the  maximum  length  is  used  by\ndefault.  It may also be specified as  a  register  enclosed  in  paren-\ntheses, indicating  that  the  length  will  be  supplied  at  execution\ntime from the designated register.\n\n\n                                                      ASSIST2-2\n\nCONDITION CODE\n\n     XPRNT and XPNCH do not change the condition code.  XREAD  sets  the\ncondition code to indicate normal processing or end-of-file as  follows:\n\nCC = 0 - a card was read, and length characters placed  in  user's  area\n\nCC = 1 - end-of-file encountered, no more cards can be read (/*  found).\n\n\nCARRIAGE CONTROL\n\n     XPRNT requires that the first character of  the  area  be  a  valid\ncarriage control character, such as blank (single  space),  '0'  (double\nspace,  and  '1'  (new  page),  or  any  others  which  are   available.\n\nEXAMPLES OF XREAD, XPRNT, XPNCH USAGE\n\n     The following section of  a  program  reads  in  a  deck  of  cards\nuntil   an   end-of-file  (/*  card)  is  found,  punches  the  last  70\ncharacters of  each  card  into  the  first  70  columns  of  each  card\npunched,  and  prints  some  number  of  characters  from   each   card,\nwhere  the  number  +  1  had  been  previously  loaded  into   register\n5  (the  +  1  is  for  the  carriage  control  character).   The  cards\nare double-spaced on the printer.\n\nREADLOOP  XREAD CARD                read card, using omitted length\n          BNZ   NOMORE              if CC=1, branch out.  BC 4,NOMORE\n                                    or BM NOMORE would also work\n          XPNCH CARD+10,70          punch 70 bytes, explicit length\n          XPRNT CARD-1,(5)          print number of bytes, using\n                                    carriage control\n          B     READLOOP            go back for next card to be read\nNOMORE    EQU   *                   branch here when no more cards\n..........more program statements..................\n          DC    C'0'                carriage control for printing\n                                    card, right before CARD\nCARD      DS    CL80                space for card to be read in\n\n     The  following  statements  show  how  the  programmer  may  easily\nproduce  messages  and  headings  for  his  output,  using  XPRNT   with\nliteral character constants or related methods:\n\n          XPRNT =CL30'1 A HEADING FOR NEW PAGE',30\n          XPRNT =CL50' SECOND HEADING IMMEDIATELY UNDER FIRST',50\n          XPRNT MSG,L'MSG          LET ASSEMBLER COMPUTE LENGTH\n          XPRNT MSGX,MSGXL         ASSEMBLER COMPUTES LENGTH WITH EQU\nMSG       DC   C'0 THIRD MESSAGE, SINGLE CONSTANT WITH LENGTH'\nMSGX      DC   C' FOURTH MESSAGE, WHICH INCLUDES A SECTION FILLED IN'\n          DC   C' DURING EXECUTION '\nMSGNMBR   DS   CL12                SPACE FOR DECIMAL NUMBER-XDECO\n          DC   C' END OF IT'\nMSGXL     EQU  *-MSGX              MSGXL IS SET TO LENGTH OF MESSAGE\n\n\n                                                      ASSIST2-3\n\nDEBUGGING INSTRUCTION - XDUMP\n\n     One basic debugging command is  provided,  called  XDUMP.   It  can\nbe used in two different ways, to  print  either  registers  or  storage\nareas:\n\nGENERAL PURPOSE REGISTER DUMP\n\n          XDUMP\n\n     Coding XDUMP with no operands prints the  contents  of  the  user's\ngeneral purpose  registers,  in  hexadecimal  notation.   The  registers\nare preceded by a header line like the following:\n\nBEGIN XSNAP - CALL    # AT CCAAAAAA USER REGISTERS\n\n#    is the number of calls made to XDUMP so  far,  for  identification.\n\nCCAAAAAA shows the last 32 bits  of  the  user's  PSW,  in  hexadecimal.\n\nCC   gives the ILC, CC, and Program Mask  at  the  time  of  the  XDUMP.\n\nAAAAAA gives the address of the instruction  following  the  XDUMP,  and\nthus can be  used  to  distinguish   between  the  output  of  different\nXDUMP statements.  *NOTE* XDUMP ,  is the same as XDUMP with no operand.\n\n\nSTORAGE DUMP\n\n          XDUMP area,length\n\n     Coding XDUMP with an address  and  length  produces  a  dump  of  a\nuser  storage  area,  beginning  at  the  address  given  by  area,  and\nending at the address area+length.   The  operands  are  specified  like\nthose of  XREAD,  XPRNT,  XPNCH,  except  the  length  may  not  specify\na register, but must be an explicit length.\n     The resulting  output  includes  a  header  line  like  the  above,\nfollowed  by  a  hexadecimal  and  alphanumeric  dump  of  the  selected\nstorage area.  The storage  is  printed  in  lines  showing  two  groups\nof  four  fullwords,  preceded  by  the  memory  address  of  the  first\nword in each line,  and  followed  by  the  alphanumeric  representation\nof the  32  bytes  on  the  line,  with  letters,  numbers,  and  blanks\nprinted directly,  and  all  other  characters  translated  to  periods.\nThe storage printed is also  preceded  by  a  line  giving  the  address\nlimits specified in the XDUMP.\n     If the length is omitted,  the  value  4  is  used  as  a  default.\n\nEXAMPLES OF XDUMP USAGE\n\n     XDUMP AREA+10,80\n     XDUMP 8(1,4),100\n     XDUMP FULLWORD           use default value of 4\n     XDUMP TABL(3),12\n\n\n                                                      ASSIST2-4\n\nDECIMAL CONVERSION INSTRUCTIONS - XDECI, XDECO\n\n     To facilitate numeric input/output,  ASSIST  accepts  the  commands\nXDECI (eXtended DECimal Input), and  XDECO  (eXtended  DECimal  Output).\nXDECI can be used to scan input cards for  signed  or  unsigned  decimal\nnumbers and convert them to binary form in a general  purpose  register,\nalso providing a scan pointer in register 1 to the end  of  the  decimal\nnumber.  XDECO converts the contents of a given register to  an  edited,\nprintable, decimal character string.\n     Both instructions follow  the  RX  instruction  format,  as  shown:\n\n     XDEC#  REG,ADDRESS\nwhere REG is any general purpose register, and  ADDRESS  is  an  RX-type\naddress, such as LABEL,  0(R4,R5), LABEL+3(2).\n\nXDECI\n\n     XDECI is generally used to scan a data card  read  by  XREAD.   The\nsequence of actions performed by XDECI is as follows:\n\n     1. Beginning at the location given by ADDRESS,  memory  is  scanned\nfor the first character which is not a blank.\n\n     2.  If  the  first  character  found  is  anything  but  a  decimal\ndigit or  plus  or  minus  sign,  register  1  is  set  to  the  address\nof that character, and  the  condition  code  is  set  to  3  (overflow)\nto show that  no  decimal  number  could  be  converted.   The  contents\nof REG are not changed, and nothing more is done.\n\n     3. From one to nine decimal digits  are  scanned,  and  the  number\nconverted to binary and  placed  in  REG,  with  the  appropriate  sign.\nThe condition code is  set  to  0  (0),  1  (-),  or  2  (+),  depending\non the value just placed in REG.\n\n     4. Register 1 is set to the address of the  first  non-digit  after\nthe string of decimal  digits.   Thus  REG  should  not  usually  be  1.\nThis permits the user to  scan  across  a  card  image  for  any  number\nof decimal values.  The values should  be  separated  by  blanks,  since\notherwise the scanner could hang up  on  a  string  like  -123*,  unless\nthe user checks for this himself. I.e. XDECI will  skip  leading  blanks\nbut will not itself skip over any other characters.\n\n     5. During step  3,  if  ten  or  more  decimal  digits  are  found,\nregister  1  is  set  to  the  address  of  the  first  character  found\nwhich is not a decimal digit, the  condition  code  is  set  to  3,  and\nREG is left unchanged.  A plus or minus  sign  alone  causes  a similiar\naction,  with  R1  set  to  the  address  of  the  character   following\nthe sign character.\n\nXDECO\n\n     XDECO converts the  value  from  REG  to  printable  decimal,  with\nleading zeroes removed, and  a  minus  sign  prefixed  if  needed.   The\nresulting character  string  is  placed  right-justified  in  a  12-byte\nfield beginning at  ADDRESS.   It  can  then  easily  be  printed  using\nan XPRNT instruction. The XDECO instruction modifies NO registers.\n\n\n                                                      ASSIST2-5\n\nSAMPLE USAGE OF XDECI\n\n     The following program  segment  reads  a  card,  and  converts  one\ndecimal value of 1-9  digits  punched  anywhere  on  the  card,  placing\nthis value in general register R0.\n\n          XREAD  CARD         read card into a workarea\n          XDECI  R0,CARD      scan and convert the number\n\n     XDECI  can  be  used  to  convert  an  unknown  number  of  decimal\nvalues from a card.  This can be done by punching  the  values  anywhere\non the  card,  separated  by  one  or  more  blanks.   The  last  number\non the card is then  followed  by  a  $,  which  indicates  the  end  of\nthe data values to the program.  The  following  program  reads  a  card\nand converts numbers,  storing  their  values  in  an  array  for  later\nuse, and stopping when the $ is found.\n\n          SR    2,2           zero for index to first word of NUMBERS\n          XREAD CARD          read cardimage into input area\n          LA    1,CARD        intialize R1 as scan pointer register\nLOOP      XDECI 0,0(,1)       scan and convert next number\n          BO    OVER          skip if bad number of $ (BC 1,OVER)\n          ST    0,NUMBERS(2)  store legal value into array\n          LA    2,4(2)        increment index value 1 fullword\n          B     LOOP          go back for next number\nOVER      CLI   0(1),C'$'     was this delimiter $\n          BE    DONE          yes, so branch out\n          XPRNT =CL30'0*** BAD INPUT ***STOP',30\nDONE      ...... more instructions ........\nNUMBERS   DS    20F           space for 20 values to be stored\nCARD      DS    CL80          input workarea\n\n\nSAMPLE USAGE OF XDECO\n\n     The following  converts  register  4  to  decimal  and  prints  it.\nIt assumes a reasonable  value  in  R4,  so  that  the  first  character\nof OUT is a blank for carriage control.\n\n          XDECO 4,OUT         convert the number\n          XPRNT OUT,12        print value\n          ..... other assembler statments .....\nOUT       DS   CL12                typical output area\n\n\n\n                                                       ASSIST2-6\n\nHEXADECIMAL CONVERSION INSTRUCTIONS-XHEXI, XHEXO\n(NOTE:  Some versions of ASSIST may not provide these instructions)\n\n       XHEXI and XHEXO provide easy conversion  of  hexadecimal  numbers\nfor  input  and  output.   The value  of  a hexadecimal  number  can  be\nread  from  a  card  using  XREAD, converted  from  character  mode to a\nhexadecimal  number, and the converted number is placed in the specified\ngeneral purpose  register  with  XHEXI.   XHEXO  provides  an  easy  way\nto  convert  internal  hexadecimal  to  an  output  form  that  can   be\nprinted using XPRNT.\n       XHEXI also  places  the  address  of  the  first  non-hexadecimal\nnumber in register one, but if  more  than  eight  digits  are  scanned,\nthe address of the ninth is placed in register 1.\n\nXHEXI\n\n                    XHEXI   REGISTER,ADDRESS\n\n    XHEXI, in the general form shown above where REGISTER is any general\npurpose register and ADDRESS is anything  legal in an RX instruction, is\nused to do the following:\n\n   1.  Beginning at the location ADDRESS, memory is  scanned  until  the\nfirst non-blank character is found.\n\n   2.  If the first character  found  is  anything  but  a  legal  hexa-\ndecimal character(0-9,A-F),  the  condition  code  is  set  to  overflow\nand  this  address  is  placed  in  register  1.   If  the  REGISTER  is\nanything but register 1, its contents remain unchanged.\n\n   3.  One to eight  hexadecimal  characters  are  scanned,  the  number\nconverted  to  hexadecimal,  and  the  result  is  placed  in  REGISTER.\nThe  value  placed  in  the  register  is  internal   hexadecimal   with\nleading zeros included and the number is right justified.\n\n   4.  Register one is set to  the address of the first  non-hexadecimal\ncharacter.  With this in mind, the user  should not code register one as\nREGISTER.  This  allows  you  to scan  across the card for any number of\ncharacter strings.  The  strings should be separated by blanks.  The end\nof the string could be flagged with any non-hexadecimal  character and a\ntest could be made after a Branch Overflow (see sample program).\n\n\n   5.  If more than eight hex digits are found, register one is  set  to\nthe  address  of  the ninth.  This  allows the user to scan  across long\nstrings of numbers.\n\nXHEXO\n\n                      XHEXO   REGISTER,ADDRESS\n\n\n       XHEXO  in  the  general  form  shown  above  converts  the  value\nin REGISTER and places it in a right-justified 8-byte field beginning at\nADDRESS. It can be easily printed using an XPRNT instruction.  The XHEXO\ninstruction modifies NO registers.\n\n\n                                                       ASSIST2-7\n\n\nSAMPLE PROGRAM USING XHEXI AND XHEXO\n\n       This  program  reads a data  card with an unknown number of hexa-\ndecimal  numbers on it.  The end of the data is denoted by a '%' punched\nafter the last  number.  The  numbers are stored  after being  converted\nusing XHEXI, and then converted for output using XHEXO.\n\n         LA    3,STORAGE           WHERE NUMBERS STORED\n         XREAD CARD,80             READ IN CARD\n         XPRNT CARD,80             ECHO PRINT\n         LA    1,CARD              ADDRESS OF CARD FOR SCANNING\nLOOP     XHEXI 2,0(1)              CONVERT NUMBER PUT IN 2\n         BO    ILLEGAL             CHECK FOR END\n         XHEXO 2,AREA              PUT NUMBER IN OUTPUT AREA\n         XPRNT REP,28              PRINT CARD AND MESSAGE\n         ST    2,0(3)              STORE NUMBER\n         LA    3,4(3)              INCREASE INDEX\n         B     LOOP                GET NEXT NUMBER\nILLEGAL  CLI   0(1),C'%'           SEE IF END OF STRING\n         BE    DONE                YES DONE\n         XPRNT =CL50' ILLEGAL CHARACTER STOP',50\nDONE     ....MORE INSTRUCTIONS.....\nCARD     DC    81C' '              STORAGE FOR CARD\nSTORAGE  DS    20F                 STORAGE FOR NUMBERS\nREP      DC    C' THE NUMBER IN R2 IS'\nAREA     DC    CL8' '             STORAGE FOR OUTPUT NUMBER\n\n\n                                                       ASSIST2-8\n\nLIMIT DUMP INSTRUCTION - XLIMD\n\n     In order to conserve output records when necessary  (for  instance,\nwhen ASSIST is being used from a  remote  terminal  of  any  sort),  the\nXLIMD instruction is provided to enable the user to limit  the  size  of\nhis completion dump and choose the area  to  be  printed.   In  general,\nit is used to eliminate  the  user's  program  code,  leaving  only  his\ndata areas in the completion dump.\n\n     The instruction is coded as follows:\n\n          XLIMD area,length\n\narea is the beginning address where the completion  dump  should  start.\n     The area address is specified  by  an  RX-type  address,  and  must\nbe within the user program area.\n\nlength    is the length in bytes of the  area  the  user  wishes  to  be\n     printed if a completion dump occurs.\n\n     Note that the XLIMD instruction format is exactly the same as  that\nfor the instructions XREAD,  XPRNT,  XPNCH.   Thus  the  length  may  be\ngiven as a register number, enclosed in parentheses, or may be  omitted,\nin which case a length of 1 is assumed.  If the  combined  area  address\nplus the  length  yields  an  address  greater  than  the  highest  user\naddress, or if the length  is  1,  the  highest  user  address  is  used\nas an upper limit instead.  Thus, storage will be  printed  to  the  end\nof the user program.\n\n     The suggested method of using XLIMD is to place  all  variables  at\nthe end of the program, then execute  an  XLIMD  with  an  area  address\nspecifying the first variable desired, and omitting  the  length.   This\nwill cause the storage to be printed starting at  the  specfied  address\nand going to the end of the program.\n\nSAMPLE USAGE OF XLIMD\n     The  following  program  gives  a  typical  way  of  using   XLIMD.\n\nDUMPTEST  CSECT\n          USING *,15\n          XLIMD VARIABL1           set dump limit right away\n          ..........\n          large number of machine instructions\n          ..........\nVARIABL1  DS    D                  first variable area\n          ..........\n          variable areas likely to be required for debugging\n          ..........\n          END\n     XLIMD may be executed any number of times  during  a  program,  but\nit is suggested that it be called early in any large program,  if  there\nis any possiblity that record limits could be exceeded.\n\n\n                                                      ASSIST2-9\n\n\nOPTIONAL INPUT/OUTPUT INSTRUCTIONS - XGET AND XPUT\n\n     These instructions are similar to XREAD/XPRNT/XPNCH,\nbut are more general, allowing the user to specify any\nfilename to be read or written. WARNING: not all versions\nof ASSIST support these instructions.  Also, a particular\nversion may only support a specific set of file names,\nwhich can differ from installation to installation. It is\nadvisable to check on local procedures.  The instructions\nare coded as follows:\n\n   label   xmacro    area,length\n\nlabel is an optional statement label\n\nxmacro is  either XGET or XPUT\n\narea is the address in memory to be read or written.\n     This area may be specified by an RX-type address, i.e., anything\nlegal as the second operand of a LA instruction, such as:\n   0(1,2),AREA2+10,card+1(3), or =CL30'0    MESSAGE'   .\n\nlength specifies the number of bytes to be read or written.\n     This length can range from 1 to the maximum length for the\nappropriate device (80 for cards, 133 for printer, etc.).  The length\nfield must not be omitted. it may also be specified as a register\nenclosed in parentheses, indicating that the length will be supplied\nat execution time from the designated register.\n\n     If during execution, the length has a value of zero, the\nfile will be closed.\n\nNOTE: During execution, register 1 must point to an eight byte\ncharacter string which is the name of the file to be manipulated.\n\nCONDITION CODE\n\n     XGET and XPUT both change the condition code as follows:\u00e0\n         CC=0  - normal input/output occurred\n         CC=1  - XGET ONLY - end of file occurred\n         CC=2 shows an error (like invalid data address)  which  causes\n              individual operation to be ignored.\n         CC=3 shows that the file could not be  opened (because  it  is\n              wrong direction,or DD card missing, or not enough room in\n              tables, etc.).\nCARRIAGE CONTROL\n\n     XPUT only requires the first character of the area to be a\nvalid carriage control character, if the output device is the printer.\n\nCLOSING OF FILE\n     Performing an XGET or XPUT with a length of zero supplied in any GP\nregister  causes the designated file to  be closed, so that it may  then\nbe reread; I.e.  LA 1,=CL8'ddname'  SR 0,0   XGET area,(0)  does close.\n\n\n                                                       ASSIST2-10\nEXAMPLE OF XGET AND XPUT USAGE\n\n     The following program will read and write a few files\nin parallel.\n\n\n\nTEST1     CSECT\n          BALR  12,0\n          USING   *,12\n          SR    0,0\n*\n*    THIS PROGRAM WILL PROCESS A FEW FILES IN PARALLEL:\n*\nLOOP      LA    1,=CL8'CARD'       point to an input file\n          XGET  AREA,80            do the input\n          BNE   DONE               branch on endfile,\n*                                  file automatically closed\n          XREAD AREA2,80           do normal input\n          LA    1,=CL8'PAPER'      point to a printer file\n          XPUT AREA-1,81           do output, note carriage control\n          LA    1,=CL8'PAPER2'     point to other printer file\n          XPUT  AREA2-1,81         do output on other file\n          B     LOOP                try again\nDONE      BR    14   RETURN, IMPLICITLY CLOSE OTHER FILES\n           DC    CL1' '\nAREA      DS    CL80\n          DC    CL1' '\nAREA2     DS    CL80\n          END\n\n\nThe extra JCL for the above is as follows:\n\n //DATA.PAPER DD SYSOUT=A,DCB=(RECFM=FA,LRECL=133,BLKSIZE=133)\n //DATA.PAPER2 DD SYSOUT=A,DCB=(RECFM=FA,LRECL=133,BLKSIZE=133)\n //DATA.CARD DD *\n THIS STUFF IS READ\n   AT THE SAME TIME AS ANOTHER\n  FILE IS READ\n ******  THE LAST CARD *******\n //DATA.INPUT DD *\nTHIS IS THE NORMAL INPUT FILE\n AND IS READ AT THE SAME TIME AS ANOTHER FILE\n  IS READ\n   ********* THE LAST CARD *********\n\nNOTE: a common usage for XGET might be to access files of test\ndata.\n\n\n\n                                                       ASSIST3-1\n\nPART III. ASSIST CONTROL CARDS AND DECK SETUP\n\nA. JOB CONTROL LANGUAGE\n\n     Depending on the type of ASSIST desired at  a  given  installation,\none or two different types of deck setup can be used.\n\nSINGLE RUN DECK SETUP - NOBATCH\n     This setup is suitable for individually-submitted jobs, and  allows\nthe most flexibility in job handling.  It is as follows:\n\n1)        //        a JOB card - installation dependent\n2)        // EXEC ASACG\n3)        //SYSIN DD *\n4)        .....  360  assembler  source  deck,  or  ASSIST  object  deck\n5)        /*\n6)        //DATA.INPUT DD *\n7)        ..... data cards to be read by user program\n8)        /*\n\n     If the programmer has no data to be read,  items  6),  7),  and  8)\nshould be omitted.  The  programmer  specifies  optional  parameters  by\nadding   ,PARM='option,option....'   after  ASACG  on  the  EXEC   card.\n\nBATCH RUN DECK SETUP\n     This type of run is recommended if a number of jobs is to be  given\nas a batch to ASSIST, and is  best  for  low  overhead.   Each  separate\nprogram in the batch must be set up as follows:\n\n          Col 1  Col 8   Columns 16-80 of card\n          '      '       '\n1)        $JOB   ASSIST  list of options, separated by commas. The first\n                         of these may be an account number, which is\n                         ignored by ASSIST. All others are optional.\n2)        .....  360  assembler  source  deck,  or  ASSIST  object  deck\n3)        $ENTRY         (this card must be present if user execution is\n                         to occur, regardless of existence of data.)\n4)        ..... data  cards  to  be  read  by  user  program  (optional)\n\n     If the user desires only an assembly of  his  program,  the  $ENTRY\ncard should be omitted.  As many of the above can  be  included  in  one\nbatch submitted to ASSIST, with BATCH and other  appropriate  parameters\nsupplied to ASSIST in the invoking PARM field.  The batch can  be  ended\nin one of two ways: either an end-of-file  indicator,  or  a  card  with\nthe following in columns 1-5:  $STOP   .\n\n     The entire batch  of  runs  is  run  with  whatever  enclosing  Job\nControl Language is required for  a  given  installation  by  specifying\nBATCH in the invoking PARM field.  All versions of ASSIST can run  BATCH\nprograms, but not all can run them  with  the  SINGLE  RUN  DECK  SETUP.\nA sample BATCH run is given below:\n\n          //        a JOB card\n          // EXEC ASACG,PARM='BATCH,other options, if any'\n          //SYSIN DD *\n          $JOB   ASSIST  ACCT1,options\n          ....... more jobs, each beginning with $JOB cards\n          /*              (or a $STOP card)\n\n\n                                                       ASSIST3-2\n\nB. OPTIONAL PARAMETERS FOR ASSIST\n\n     ASSIST provides a large number of options to  control  the  actions\nit performs.  These options are of two types: the first kind show yes/no\nvalues and are coded as a specific name, with or without a preceding NO.\nEvery option has a default value, and some of the  numerical  ones  have\nupper limits which can never be exceeded.\n\n     Each parameter can possibly be  given  values  from  at  most  four\ndifferent sources, which are as follows:\n\n  1. LIMIT/DEFAULT - absolute upper limits on  some  numerical  options,\n     and  default  values  for  some  others.  (defined  inside  ASSIST)\n  2. INVOKING PARM - values for any of  the  options.  (EXEC  CARD  PARM\n     field,  or  PARM  supplied  by  another  program  calling   ASSIST)\n     **NOTE** this is not available under DOS/360.\n  3. $JOB CARD PARM - values  for  some  of  the  options,  if  desired,\n     only possible if LIMIT/DEFAULT or INVOKING  PARM  specified  BATCH.\n  4. DEFAULT - default values for the numerical parameters having  upper\n     limits, only used if values not specified  in  2.  or  3.  (defined\n     inside ASSIST)\n\n     For any assembly-execution-dump cycle of ASSIST (i.e., one program)\nthe above sources of information are processed in the order given above,\nsubject to the following rules:\n\n  1. Some options can be supplied  values  only  from  certain  sources.\n  2. Certain numerical parameters can  never  be  increased  beyond  any\n     previous setting from any source.   This  particularly  applies  to\n     time, records, and pages limits.\n  3. In most cases, if the same option is coded  several  times  in  the\n     same information source, the last value is used, subject to rule 2.\n     It is possible that some values cannot be reset once set  anywhere.\n  4. DEFAULT values are used only if they are not coded  in  either  the\n     INVOKING PARM or $JOB cards, i.e., they override only LIMIT/DEFAULT\n     values.  This construct allows for both limit  and  default  values\n     for the numerical options.\n\nSAMPLE USAGE OF OPTIONAL PARAMETERS\n\n1)        // EXEC ASACG,PARM='T=3.5,R=200,NERR=10,RELOC,CMPRS'\n\n2)        // EXEC ASACG,PARM='BATCH,CPAGE,T=5,TX=2,P=20,PX=5,RX=315,SSD'\n          //SYSIN DD *\n          $JOB   ASSIST  ACCT#,PD=1,TD=0.05,CMPRS,SS,SSX\n                    (this job crams output onto fewest possible pages)\n          .............\n          $JOB   ASSIST  ACCT#,PD=0,TD=0,RD=0\n                    (this is a debugged program-saves no pages,time,\n                    or records for the dump-gets maximum output).\n          .............\n          $JOB   ASSIST  ACCT#,OBJIN\n          ............. (object deck)\n\n     The above examples show a typical single  job  run  and  a  typical\nbatch of jobs.\n\n\n                                                       ASSIST3-3\n\nCHARACTERISTICS OF PARAMETERS\n\n     The following lists the available options,  including  the  default\nvalues, sources from which each can be specified,  and  brief  notes  on\nthe purpose of each.  Each option is described in  detail  in  the  next\nsection.  ASSIST can be generated not  to  allow  certain  options,  and\nthese  are  flagged  to  show  whether  they  can  be  omitted  or  not.\n\nKEY\n#    under FROM column notes that the option CAN be set from the source,\n     i.e., 1=LIMIT/DEFAULT, 2=INVOKING  PARM,  3=$JOB  PARM,  4=DEFAULT.\nN    under N column indicates a numerical parameter  which  cannot  ever\n     be increased from any previously set value.\nO    under O column indicates an option which  can  be  omitted  from  a\n     particular generation of ASSIST  (to  save  space,  for  instance).\nPARM      FROM N O  DEFAULT        PURPOSE\nNAME      1234      VALUE          AND USAGE\n------------------------------------------------------------------------\nALGN      1234   O  ALGN           suppress alignment specification errs\nBATCH     12        NOBATCH        indicate a batched-type run\nCMPRS     1234   O  NOCMPRS        compressed  source  list,2  cols/page\nCOMNT     12     O  NOCOMNT        require percentage of commented cards\nCPAGE     12     O  NOCPAGE        control   paging  and  page  counting\nDECK      1234   O  NODECK         punch object deck\nDISKU     123    O  NODISKU        intermediate disk storage used\nDUMP=     1234      0              controls type and size of dump\nFREE=     12        4096           bytes returned to system for  buffers\nI=        1234      150000         maximum # instructions for user  prog\nKP=       1234   O  029            type of keypunch used (026 or 029)\nL=        1234 N O  63             maximum lines/page if CPAGE on\nLIBMC     1234   O  NOLIBMC        allow library macros to be printed\nLIST      1234        LIST         produce source  listing  of  assembly\nLOAD      1234        LOAD         produce object  program  and  run  it\nMACRO=    1234   O  N              allows use and types of macros\nMACTR=    1234 N O  200            default value of MACRO ACTR\nMNEST=    1234 N O  15             maximum nest level for macro calls\nMSTMG=    1234 N O  4000           maximum total macro stmts processed\nNERR=     1234      0              maximum # errors permitting execute\nOBJIN     1234   O  NOOBJIN        object deck input rather than  source\nP=        1234 N O  10             total run page limit if CPAGE on\nPD=       1234 N O  1              page limit for dump if CPAGE on\nPUNCH     12     O    PUNCH        select real punch, or print simulated\nPX=       1234 N O  5              execution+dump page limit, if CPAGE\nR=        1234 N    10000          output   record  limit  (lines+cards)\nRD=       1234 N    25             records saved for dump\nRELOC     1234   O  NORELOC        relocate to real address,store-protec\nREPL      1234   O  NOREPL         assembler replacement run\nRFLAG=    1234   O  0              replace option flag (only if REPL on)\nRX=       1234 N    10000          execution+dump record limit\nSS        1234   O  NOSS           single space assembly (only if CPAGE)\nSSD       1234   O  NOSSD          single space dump     (only if CPAGE)\nSSX       1234   O  NOSSX          single space execution(only if CPAGE)\nT=        1234 N O  100            total run time, seconds\nTD=       1234 N O  .1             time in seconds saved for dump\nTX=       1234 N O  100            time in seconds for execution+dump\nXREF=     1234   O  (0,3,3)        requests cross-reference\n\n\n                                                       ASSIST3-4\nC. DESCRIPTION OF INDIVIDUAL OPTIONS\n\n     This section describes each of the options which may  be  available\nunder ASSIST.  Refer to the previous  section  for  default  values  and\nother information regarding the usage of these options.\n\nALGN/NOALGN\n     Use of the NOALGN option allows the user to suppress  specification\ninterrupts caused by improper alignment of operands.    This  is  useful\nwhen using a S/360 computer to simulate a S/370, which may of course use\ndata on any boundaries for many opcodes.  Not every ASSIST allows  this.\n\nBATCH/NOBATCH\n     The BATCH option allows multiple jobs to be run in  one  invocation\nof ASSIST.  It is described in Part III.A. of this manual.\n\nCMPRS/NOCMPRS\n     The CMPRS option (CoMPReSsed output) produces an  assembly  listing\nwhich is approximately half as long as  a  standard  listing.   This  is\ndone by removing the ADDR1 - ADDR2  fields  and  printing  only  columns\n1-40 of each statement.  While the listing produced is not  as  readable\nas the standard one, this option is particularly recommended for  remote\nterminal usage, since programs are printed nearly  twice  as  fast.   It\ndoes, however, increase the amount of dynamic storage required  to  run.\n\nCOMNT/NOCOMNT\n     The COMNT option causes the machine instructions of the program  to\nbe checked for the presence of comments (4 or more  nonblank  characters\nin the comment field).  If less than 80 percent of those statements have\ncomments, a message is printed and the program  is  not  executed.  Some\ninstructors may require this option on programs to be handed in, and  it\nis possible that some account numbers may imply this option whether  the\nprogrammer codes it or not.\n\nCPAGE/NOCPAGE\n     If NOCPAGE is used, no limits exist on the number of pages printed,\nand lines are printed with whatever  carriage  controls  are  specified.\nCoding CPAGE enables the usa of the following options: L=, P=, PD=, PX=,\nSS, SSD, and SSX, all of which are totally ignored otherwise.   Briefly,\na page may be declared to have a  maximum  number  of  lines  (L=),  and\nlimits given for the pages printed during various stages of a  run.  The\nSS options then allow the maximum number of lines to  be  printed  in  a\ngiven number of pages by removing some carriage control characters  from\nthe printed output (such as page and multiple line skips).\n\n\nDECK/NODECK\n     Coding DECK causes ASSIST to punch  an  object  deck  of  the  user\nprogram, assuming that the number of errors did  not  exceed  the  NERR=\noption, that the version of ASSIST in use has a  card  punch,  and  that\nnone of the following options were specified also: NOLOAD,NOPUNCH,OBJIN,\nor REPL.  The deck punched is described in PART IV.E.1 of  this  manual.\n     Note that this option should not be used for large programs,  since\nevery byte of storage of the user program is punched, 56 bytes per card,\neven if the storage was reserved by DS or ORG commands.  Note  that  the\ndeck, while resembling standard S/360 object  decks,  cannot  really  be\nused for any purpose but to read back into ASSIST later.   The  user  is\nalso cautioned to be careful about using DECK  with  the  RELOC  option.\n\n\n                                                       ASSIST3-5\n\nDISKU/NODISKU\n      Coding DISKU causes the ASSIST assembler to place the pass1 output\non intermediate disk storage.  Pass2 then recovers the pass1 information\nfrom disk to use in the production of object code into ASSIST's  dynamic\nwork area.  Assuming ASSIST is generated with the user controlled  DISKU\n/NODISKU option,  it  is possible to assemble much larger programs  with\nASSIST using the DISKU option. DISKU has no effect when coded with OBJIN\nand is compatible with any other combination of parameters.\n\nDUMP=\n     This option controls the size of the  dump  printed  on  any  error\ntermination during program execution.  If  DUMP=0, a full dump is given.\nThis includes a PSW, completion code, instruction trace, general-purpose\nand floating-point registers, and all contents  of  the  user  program's\nstorage area.  If  DUMP=1, ASSIST omits the contents  of  user  storage.\n\nFREE=\n     ASSIST  normally  acquires  the  largest  single  block  of   space\nin its region  for  a  dynamic  workarea,  then  releases part  of  that\narea  back  to  the  operating  system  for  buffers  and  other   uses.\nThe  default  is  4096  bytes  returned,  but  the  value  of  FREE=  is\nused if  supplied,  in  case  tape  input  or  output  is  required,  or\nif extra  space  is  required  for  the  user  program.   If  the  value\nof FREE= is  greater  than  the  total  obtained,  it  is  ignored,  and\nno space is returned.  ****NOTE*** THIS OPTION WILL PROBABLY  BE  NEEDED\nBY ANYONE USING BLOCKED INPUT FROM TAPE OR DISK.\n\nI=\n     This parameter provides a limit on the number of instructions which\nwhich can be executed by the user program during its execution.  If this\nlimit  is  exceeded  during  execution,  a  message  and  a   completion\ndump  are  printed.   This  is  the  recommended  and  most   economical\nway to prevent infinite loops during user  program  execution.  A  limit\nfor  execution  time  may  also  be  used  to  terminate  loops   (TX=).\n\nKP=\n     KP=26 specifies that an 026 keypunch was used to prepare  the  job,\nwhile 29 specifies an 029 keypunch.  Leading zeroes are  permitted,  and\nany value except 26 implies an 029 keypunch.\n\nL=\n     This is used to specify the maximum lines per  page,  and  is  only\nenabled if the CPAGE option is turned on.\n\nLIBMC/NOLIBMC\n     Coding  LIBMC  permits macros fetched from libraries  to be printed\nif desired.  Only effecitve when MACRO= is supplied to an ASSIST   which\nsupports macro libraries.  See also MACRO=, and APPENDIX K  of   PART I.\n\nLIST/NOLIST\n     Coding NOLIST suppresses the printing of the assembly listing,  and\ncan be used for relatively bug-free programs. However, regardless of the\ncurrent print status, any statement flagged with  an  error  or  warning\nmessage is always printed.\n\n\n                                                       ASSIST3-6\nLOAD/NOLOAD\n     Under most circumstances, a programmer usually wants to execute his\nassembler program.  If he  just  wants  to  check  it  for  errors,  but\nnot execute it, the NOLOAD  option  can  be  coded.   This  will  result\nin slightly  faster  assembly  times.   In  addition,  it  will  require\nless space in memory, and it may  be  possible  to  assemble  a  program\nunder NOLOAD that cannot be assembled with the LOAD option.\n\nMACRO=\n     This option notes whether macro processing is to be  done,  and  if\nso, what language facilities are to be allowed.  The values allowed are:\nMACRO=N        NO macro processing: used if error in option\nMACRO=F        F-level Assembler compatibility  (basic facility)\nMACRO=G        G-level Assembler features added, if available\nMACRO=H        H-level Assembler features added, if available\nIf macros or conditional assembly are to be used, the user MUST  specify\nsomething other than MACRO=N.  See also APPENDIX K of PART I.\n\nMACTR=\n     This provides a default value for the starting ACTR counters in all\nmacros used.  It can be overridden by explicit ACTR statements.\n\nMNEST=\n     This gives a limit on the maximum level of nested macro calls, thus\nallowing prevention of unwanted recursion in macros.\n\nMSTMG=\n     This provides a global limit on the total statements processed   in\nall macro expansions.  It is like ACTR, but counts all statements in all\nmacros, rather than being local to a macro.  It can be used to   prevent\nmacro looping which causes storage to be exceeded.\n\nNERR=\n     This option is used to allow  a  program  to  execute  even  though\nthere are errors in it.  If omitted, the value is assumed  to  be  zero,\ni.e., the program is not executed if there are any errors at all in  it.\nIf NERR=10 is used, the program runs if it has 10 errors, but  does  not\nrun if there are 11.  Note that warning messages  are  not  included  in\nthis count, only actual error messages.\n\nOBJIN/NOOBJIN\n     Coding OBJIN informs ASSIST that an object deck is  being  supplied\nto it in place of the usual assembler source deck.  This is  allowed  in\nevery case, unless REPL is coded, in which case OBJIN is  ignored.   The\nformat required of the object deck is given in PART IV.E.1.\n     The ASSIST loader reads the object deck  until  an  end-of-file  or\nASSIST control card is found, producing  an  object  program  in  memory\nwhich is then treated exactly as though  the  source  program  had  been\njust assembled there.  The loader also issues various  messages  of  the\nform AL###, which are explained in PART IV.E.2.  The  user  should  read\nall of PART IV.E. before using the  OBJIN  option,  since  there  are  a\nnumber of restrictions which must be noted  before  using  object  decks\nas input to ASSIST.  In general, a single  ASSIST-produced  deck  should\nalmost always be workable,  a  single  deck  produced  by  the  standard\nsystem assembler, or multiple decks of any sort may be  usable  if  they\nwere created following certain conventions.   Decks  requiring  symbolic\nlinkage among  control  sections  will  definitely  NOT  run  correctly.\n\n\n                                                       ASSIST3-7\n\nP=\n     This gives the maximum number of pages (with  L=  lines  per  page)\nwhich are permitted for a complete job (or from one  $JOB  card  to  the\nnext, if BATCH is used).  It is only meaningful if  CPAGE  is  on.   The\nentire process of page counting (which also involves values of  PD=  and\nPX= ) is summarized as follows:\n  1. As described in PART III.B, the value of P=  is  calculated  before\nASSIST prints anything for the job.  ASSIST prints the beginning of  the\nheader line, followed by the PARM field, or  the  $JOB  card,  and  then\nassembly begins.  If the p= value is exceeded during assembly,  the  job\nis halted at that point.\n  2. If the user program assembles successfully and is to  be  executed,\na page limit is calculated for execution plus dump.  The total for these\ntwo phases is set to the minimum of the PX= option  and  the  number  of\npages remaining from before.\n  3. A temporary limit for user program execution  alone  is  calculated\nby subtracting the value of the PD= option, thus reserving  that  number\nof pages for  a  dump.   User  program  execution  occurs,  and  may  be\nterminated if the temporary page limit is exceeded.\n  4. After execution, the PD=  value  is  added  to  the  current  pages\nremaining counter, and the dump begun.   The  dump continues until it is\ncompleted or it runs out of pages.\n  Note A. At steps 3 and 4 the lines remaining  count  is  just  carried\nforward, so that the  user  gets  the  benefit  of  any  partial  pages.\n  Note B. For REPL runs (assembler replacement), step three is performed\ntwice, once for the replacement program, and once  for  the  program  it\nassembles  (if execution is desired  for  it).   Since  a  dump  of  the\nreplacement program does not occur during the user  dump  phase,  it  is\nrecommended that no pages be saved for it (i.e., PD=0).\n  Note C. Any process which can be halted by exceeding  page  count  can\nalso be halted by exceeding record limits (see R=), or time limits  (see\nT=), and for user program execution, exceeding instruction  count  limit\n(see I=).\n\n\nPD=\n     This option specifies the number of pages which should be  reserved\nfor the user completion dump phase.  It is effective only  if  CPAGE  is\non, and is used in conjunction with P= and PX= ( see  explanation  under\nP=).  Typical values are as follows:\n  PD=0     saves  no  pages  for  dump.   Good  for  debugged  programs.\n  PD=1    even  if  the  program  loops  printing,  this  allows  enough\n          information to determine what the program was doing.  If SSD\n          is coded, about 1K of storage can also be seen.\n     Note that the PD= value does not restrict  a  dump  to  that  size,\nso that the user also gets up to the PX= value for execution  plus  dump\ntogether, even if the  entire  amount  is  used  to  provide  the  dump.\n\nPUNCH/NOPUNCH\n     Use of the NOPUNCH parameter causes the system to print any  output\nfrom XPNCH instructions, rather than punching them.  Each  cardimage  is\npreceded with the characters ' CARD-->' to  distinguish  it  from  other\nprinted output.  This option is useful for  testing  punching  programs.\nVersions of ASSIST with no punch treat all attempted punching this  way.\n\n\n                                                       ASSIST3-8\nPX=\n     This gives the maximum  number  of  pages  for  both  user  program\nexecution and completion dump phases together.  It is effective only  if\nCPAGE is on.  See description under P=.\n\nR=\n     This value specifies the maximum number of  output  records  (lines\nprinted + cards punched) allowed for the entire  run.   Record  counting\nis always performed, and the  entire  process  resembles  that  of  page\ncounting (see P=), and occurs in parallel with any page  counting.   The\nparameters R=, and RX= are used just as  are  P=,  PX=,  and  PD=,  with\nrecords substituted for pages.  One possible  difference  is  in  ASSIST\nsystems with special record control type 2  (see  header  description  -\nPART IV.B.1.a.).  In this case, the initial record  remaining  count  is\nalso determined by the number of records actually left  (if  this  value\ncan be obtained from the operating system).  This value is  used  rather\nthan the default value if the user did not specify R= on the  EXEC  card\nor $JOB card.  As in Note B. under P=, use RD=0  for  replacement  runs.\n\n\nRD=\n    RD= the number of output records reserved for a user completion dump\nIt is used in conjunction with R= and RX= in the same way  that  PD=  is\nused with P= and PX=.  RD=0 is appropriate for  well-debugged  programs,\nand RD=25 is probably the most reasonable value for  most  runs,  as  it\nsaves enough for a partial dump under all conditions.\n\n\nRELOC/NORELOC\n     Under NORELOC a user program is assembled with a  location  counter\nbeginning either at 0 or the value on a start card, and the  program  is\nexecuted as though it were actually loaded  at  whatever  addresses  are\ngiven on the assembly listing.  Maximum debugging checking  is  provided\nby this mode, as the user may not branch, store, or  fetch  outside  the\narea of his program.\n     RELOC in effect inserts a start card at the beginning of the source\nprogram which specifies the actual location in memory at which the  user\nprogram  will  be  assembled.   When  the  program  is  executed,  fetch\nprotection is eliminated,  which  the  execution-time  relocation  value\nof zero, allows the user program to examine any areas of storage in  the\ncomputer (for example, to trace system control blocks).  RELOC  mode  is\nimplied if REPL is coded.\n\nREPL/NOREPL\n     REPL notes that the user supplies two source programs, of which the\nfirst is a replacement for one of the modules of the  ASSIST  assembler,\nand the second is a test program, to be assembled using the  replacement\nprogram.  This optional feature is described in  detail  in  the  ASSIST\nASSEMBLER REPLACEMENT USER'S GUIDE.\n\nRFLAG\n     This option specifies an initial  value  for  the  replace  control\nflag, it is meaningful only if REPL is coded, and is  described  in  the\nASSIST ASSEMBLER REPLACEMENT USER'S GUIDE.\n\n\n                                                       ASSIST3-9\n\nRX=\n     This gives the total number of  output  records  for  user  program\nexecution and dump together (see R=).  It corresponds to  PX=  for  page\ncontrol, and is used in the same way.\n\nSS/NOSS\n     This option is effective only if CPAGE is on,  and  is  useful  for\nreducing the number of pages printed for a given number of lines output.\nUsing SS essentially converts all  carriage  controls  to  single  space\ncommands, except for page skips, which  become  double  spaces,  and  no\nspaces, which are unchanged. SS is effective during the assembly  phase,\nSSX during user program execution, and SSD during a completion dump. The\ncarriage control conversions are as follows:\n  '1' (page skip)     becomes '0'      '+' (overprinting)   remains  '+'\n  '-' (triple space)  becomes ' '      ' ' (single space)  remains  '  '\n  '0' (double space)  becomes ' '      any other character becomes  '  '\n\nSSD/NOSSD\n     SSD is the SS option during completion dump (see SS above).   Using\nSSD allows a partial dump plus 1K of storage to be printed  on  1  page.\n\nSSX/NOSSX\n     SSX is  the  SS  option  during  user  execution  (see  SS  above).\n\n\nT=\n     This gives a limit in seconds on the total time allowed for a  run.\nThe handling of the three time limits (T=,  TX=,  and  TD=)  is  exactly\nanalogous to that for pages (see P=) and  records  limits.   The  values\nare coded as integer values of seconds, or with fractional values up  to\nthree digits, thus allowing for millisecond  specifications.   As  shown\nin Note B. under P=, TD=0 should be  used  for  replacement  runs.   The\nappropriate times used depend on the model of machine being  used,  with\nthe following times being appropriate for  student  runs  on  a  360/65:\n  T=5,TX=5,TD=1.\n     Some versions of ASSIST may contain NO timing  code at all  (option\n0), and some may contain special option 2.  In the latter  case,  ASSIST\nobtains a time remaining estimate from the operating system and uses  it\nrather than the default if the user specifies  no  time  limit  himself.\nThe user may examine the ASSIST header to determine which type of ASSIST\nis being used (see PART IV.B.1.a).\n\n\nTD=\n     This supplies the time remaining for a user  completion  dump,  and\nshould generally be set to a large enough value to  permit  at  least  a\npartial dump to be given, thus showing the user the  instructions  being\nexecuted, especially if a loop is occurring.  TD=0 is   appropriate  for\ndebugged programs, which can then use all possible time  for  execution.\n\n\nTX=\n     This value is the total time in seconds for user program  execution\nand dump together.  It controls time in the same way that  PX=  controls\npages and RX=  controls  output  records  (see  P=  for  description  of\nthe process of control values computation).\n\n\n                                                       ASSIST3-11\n\nXREF=\n\n     This option  provides  a  short,  but  informative  cross-reference\nlisting following the assembly listing.   Among other  things,  it  does\ndistinguish between two types of references.  A MODIFY reference is  any\none in which a symbol is used in a machine instruction field denoting an\noperand to be modified:     ST  0,X  for example.  All other  references\nare considered FETCH references:   B   X  ,    L  0,X  ,  DC  A(X) . The\ncross-reference output shows a symbol, its value, and statement  numbers\nof referencing statements, with MODIFY references  flagged  as  negative\nstatement numbers.  Conrol of the output is obtained both by  the  XREF=\noption, and by *XREF cards inserted in the source  program  as  desired.\nThe latter permit  explict  control  of  how  references  are  gathered.\n\n     A brief note on the XREF mechanism is necessary to make use of  the\nflexible control provided.  During Pass 1 of an assembly, the SD (symbol\nDefinition) flag is attached to each symbol as it is defined.  The  flag\nconsists of two bits (M for Modify and F for Fetch, in that order),  and\nshows for each symbol what kinds of references may  possibly  collected.\nFor example,  SD=10  indicates that no Fetch references are ever  to  be\nprinted for a specific symbol.   The SD flag may  be  changed  during  a\nprogram by *XREF cards, so that symbols in  different  sections  of  the\nprogram can be treated differently:  SD=00 will eliminate all  following\nsymbols completely, until it is changed again.\n\n     During Pass 2, a Symbol Reference (SR) flag is  used  to  determine\nwhat types of references are being collected from the code.  A reference\nto a symbol is logged if and only if the SD bit and the SR bit  for  the\ngiven type of reference are both on.  I.e., if SD=10 for a symbol, SR=11\nat the current time, and a fetch reference is made, no reference will be\nlogged, since the SD Fetch bit is 0.   Note  that  references  are  only\nlogged during Pass 2: some symbol references occur only during  Pass  1,\nand these are ignored, such as  sumbols in  EQU,  ORG,  and  DC  and  DS\nlength modifiers or duplication factors.\n\n     The XREF parameter requests a cross-reference, indicates  the  type\nof output produced, and possibly gives initial values to the SD  and  SR\nflags.  Two forms are permitted as follows:\n\n     XREF=a         OR        XREF=(a,b,c)          WHERE\n\na:   indicates overall control and output format:\n =0  no cross-reference is generated.\n =2  cross reference is  printed,  with  one  symbol  per  output  line.\n =3  cross reference is printed, but with minimal  output  wasted  (more\n     than one symbol may appear on a line- this  form  is  recommended).\nb:   initial value of SD flag, in decimal corresponding to binary,  i.e.\n     0: 00,  1: 01, 2: 10,  3: 11.\nc:   initial value of SR flag, same format as b.\n\n     Illegal values are ignored, and it is allowable to  omit  items  as\ndesired, showing this by comma usage:   XREF=(2,,2)  for  example.   The\ndefault value is  XREF=(0,3,3)  so that all that is needed to  obtain  a\ncomplete listing is to code   XREF=2  or XREF=3, as the other values are\nnot changed or zeroed.\n\n\n                                                       ASSIST3-12\n\n     The SR and SD flags may be changed at any time during the  program,\nby placing *XREF comment cards anywhere in the source program  following\nthe first machine instruction or assembler opcode used (SD options  used\nbefore these will work, but SR's  will  be  ignored).   The  format  is:\n\n*XREF    one   or   more   blanks    OPTION1=value1,OPTION2=value2,.....\n\n     The operand(s) may be specified in  any  order,  and  if  the  same\noption is used several times, requested actions are performed in  order.\nThe options are:\n\nSD=<M><F>       give  the  modify  and  fetch  bits  for  the  SD  flag.\nSR=<M><F>       give  the  modify  and  fetch  bits  for  the  SR  flag.\n\n     Possible values for <M> and <F> are:\n\n0:   turn bit off.\n1:   turn bit on.\n*:   leave bit in previous state.\n\n     If an <F> specification is omitted, this  is  equivalent  to  a  *.\n\n     It is suggested that the user begin by just specifying XREF=2 or  3\nand then cutting out unnecessary references  later.   Although  complex,\nthe facilities allow unwanted  output  to  easily  be  eliminated.   The\nfollowing gives as example (assumed to be a large program):\n\n*XREF   SD=10            following symbols will have only modify refs.\n.....  large number of DS and DC statements (global table, for example).\n*XREF  SD=*1             add modify and fetch references both.\n.....   more symbols in DSECTS, tables, etc.\n*XREF  SD=00,SR=10       collect no references to symbols  defined  from\n                         here on, collect modify references created.\n.....   section of code referencing tables above.\n*XREF  SD=11,SR=11       collect all references from following  code  to\n                         2nd part of table, modify references to first\n                         part, and all references to itself.\n.....   section of code referencing tables.\n\n\n                                                      ASSIST4-1\n\nPART IV.  ASSIST OPTIONAL EXTENDED INTERPRETER\n\nA.  DESCRITPION OF NEW FEATURES\n\n     The ASSIST Optional Extended  Interpreter  is  a  seperate  control\nsection which can replace the original  ASSIST  interpreter  if  certain\nadditional program  debugging  features  are  desired.   These  features\ninclude  additional  pseudo  instructions,  extra  program   statistics,\nextra abnormal termination completion information, a  facility  allowing\nthe  programmer  to  change  machine  emulation  during  execution,   an\ninstruction trace facility,  an  instruction  counting  facility  and  a\nlarger subset of S360/S370  instructions.   The  ASSIST  interface  with\nthe  interpreter  (Econtrol  Block)  has  been  extended   but   upwards\ncompatibility with the entire assist system is maintained.\n     The  ASSIST   Optional  Extended  Interpreter  is  somewhat  larger\nand executes slightly  slower  than  the  original  Assist  interpreter.\nThis is caused by the extensively table-driven nature  of  the  extended\ninterpreter and the addition of all of the new features.\n\n\n                                                      ASSIST4-2\n\nB.    THE  XOPC  (OPTIONS  CALL)  DEBUGGING  AND  ANALYSIS   INSTRUCTION\n\n         The OPtions Call pseudo-instruction can provide the user\nprogrammer  with  several  functions:  1).  Set  a  type  of  'SPIE'  in\nASSIST, giving the user the capability to  process  specified  execution\ntime interrupts, 2). Trace instructions as they are executed, 3).  Check\nwhich areas of storage are being modified  by  which  instructions,  4).\nPurposely cause an execution time interrupt when  a  certain  number  of\ninstructions  have  been  executed,  5).   Control  Boundary   Alignment\nChecking - Turn off and on the allowance of S0C6  alignment  interrupts,\nand 6). Count  and  print  statistics  of  the  number  of  instructions\nexecuted between two  specified  addresses.   The  flexibility  of  this\ninstruction is brought about by its similarity in format  to  the  s360-\ns370 Supervisor Call Instruction (SVC).\n         The XOPC instruction is of the RR type.  Its general format\nis as follows:\n\n                    --------------------\n                    |   01   |   I1    |\n                    --------------------\n                    0        8        15\n\n\n         The number residing in the second byte of the instruction\ncontrols which specific XOPC instruction will be executed.   Up  to  256\n(0-255) different instructions can be  executed  using  XOPC.   However,\nat present only 23 XOPC instructions are implemented.\n         There is very little error checking involved with the inter-\npretation of the XOPC instruction.  The condition code is used  to  tell\nthe user programmer about XOPC instruction  errors  and  is  set  during\nexecution of the instruction as follows:\n\n                    CC = 0  Instruction is valid\n                    CC = 1  Illegal or Incorrect Argument(s) used.\n                    CC = 3  Specified code number is not implemented.\n\nWhen a specified XOPC instruction is found to be in error, the condition\ncode is set  as  described  above,  and  the  instruction  execution  is\nignored.  No other error checking is provided.  It should be noted  that\nXOPC  instruction  errors  cannot  cause   execution   time   interrupts\n(ABENDS).\n         Below is a description of the 23 XOPC instructions presently\nimplemented.\n\n\n                                                      ASSIST4-3\n\n    XOPC 0   -   SET PSEUDO - SPIE EXIT ADDRESS\n\n         This instruction allows the user to set a type of 'SPIE'.\nThe  user  specifies  an  address  and  the  interrupts  he  wishes   to\nprocess in a coded form.  When this instruction is  executed,  Registers\n0 and 1 are assumed to  contain  certain  arguments.   Register  1  must\ncontain a user program address (Exit Address) to which control is passed\nif any of the specified program interrupts  occur.   The  last  15  bits\n(bits 17-31)  of  Register  0  must  contain  a  code  specifying  which\ninterrupts the user wishes to intercept.  The first 17 bits of  register\n0 are ignored.  Each of the  bit  positions  17  to  31  of  register  0\ncorrespond to  one  of  the  15  execution  time  interrupts.   A  1  in\none of the bit positions specifies  a  spie-exit  on  the  corresponding\nprogram interrupt.  For example, Bit (17) = 1 specifies a  spie-exit  on\nS0C1,   Bit (18) = 1 specifies a spie-exit on S0C2,  .......,  Bit  (31)\n= 1 specifies a spie-exit on S0CF.  A zero in any of the  bit  positions\nallows the corresponding execution time interrupt  to  occur  as  if  no\nspie had been set.\n\n         Example:  If register 0 contains the following;\n\n         0000 0000 0000 0000 0111 0000 0000 0001\n\nAfter an XOPC 0 instruction has been executed with register 0 as  above,\ncontrol will be passed to the address found in register 1 if any of  the\nfollowing interrupts occur;  S0C1, S0C2, S0C3 and S0CF.\n         If a spie exit address has been given (i.e. This instruction\nhas been executed) and one  of  the  specified  interrupts  occurs,  the\nfollowing actions take place:\n\n         1).  The current values of user register 0 and 1 are saved.\n\n         2).  The PSW at interrupt is loaded into registers 0 and 1.\n\n         3).  The proper interrupt code is inserted into user register\n               0 (bits 17 thru 31 of the PSW).\n\n         4).  ASSIST now considers the user in the interrupt processing\n              state.\n\n         5).  Control in the user program is passed to the given\n              interrupt exit address.\n\n         It should be noted that when the user is in the Interrupt\nProcessing State any further interrupt will cause  abnormal  termination\nof the user program.  The user will remain in this state until the exec-\nution of an XOPC 21 instruction.\n         XOPC 0 can be executed an unlimited number of times during\nthe execution of a program to change the specified exit  address  or  to\nchange the interrupts to be intercepted.  Note, however, that  the  most\nrecent execution of XOPC 0  is  the  one  in  effect,  and  cancels  all\nprevious executions.\n\n\n                                                      ASSIST4-4\n\n     XOPC 1   -   SET  ADDRESSES  FOR  THE  INSTRUCTION  TRACE  FACILITY\n\n          This instruction specifies boundary addresses used by the\ntrace facility.  Once enabled the trace facility will give  the  user  a\nprinted trace of all instructions executed  within  these  two  boundary\naddresses.  When this instruction is executed the lower and upper  trace\naddress limits are assumed to be in registers  0  and  1,  respectively.\n\n\n     XOPC 2   -   TURN ON THE INSTRUCTION TRACE FACILITY\n\n         This instruction enables the trace facility.  Prior to the\nexecution of this instruction the user should have specified  two  limit\naddresses.  However, if no limit addresses have been  specified,  ASSIST\nwill use the highest  and  lowest  program  addresses  for  the  limits.\nBelow is an example of the  trace  line  printed  for  each  instruction\nexecuted.  Assume this instruction is  executed  causing  the  following\ntrace message to be printed:\n\n      ADDR                INSTRUCTION\n     00EBE0          STM  R0,R10,SAVEAREA\n\nHere is the trace message printed:\n\nTRACE-->   INSTR ADDR:  00EBE0   INSTR:  980A 6020\n\n\n     XOPC 3   -    SET  ADDRESSES  (as  in  XOPC  1)  and  TURN  ON  THE\n                  INSTRUCTION TRACE FACILITY\n\n         This instruction combines the actions of XOPC instructions 1\nand 2.  It assumes register usage the same as in XOPC 1.\n\n\n     XOPC 4   -   TURN OFF THE INSTRUCTION TRACE FACILITY\n\n         This instruction disables the Instruction Trace.\n\n\n     XOPC 5   -   SET ADDRESSES FOR THE  STORAGE  MODIFICATION  CHECKING\n                  FACILITY\n\n         This instruction specifies address boundaries (high and low)\ninside which the Storage Modification Checking  Facility  will  operate.\nOnce  enabled,  this  facility  causes  storage  between  the   boundary\naddresses to be monitored.  If any of  this  storage  is  modified,  the\nlength of storage modified and the  instruction  modifying  the  storage\nwill be printed for the user.  The  register  usage  upon  execution  of\nthis instruction is the same as in XOPC 1 above.\n\n\n                                                      ASSIST4-5\n\n     XOPC 6   -   TURN ON THE  STORAGE  MODIFICATION  CHECKING  FACILITY\n\n         This instruction enables the Storage Modification Checking\nFacility.  Before the execution of  this  instruction  the  user  should\nhave specified two boundary addresses.  However, if no  limit  addresses\nare specified ASSIST will use the highest and lowest  program  addresses\n(outer limits) for the limit addresses.  Below  is  an  example  of  the\nStorage Modification Checking line printed when an instruction  modifies\nstorage.  Assume the instruction listed below is executed:\n\n      ADDR                 INSTRUCTION\n     0001C0               ST   R1,SAVE\n\nHere is the line printed assuming the label SAVE has a  displacement  of\n0002C0.\n\nCHECK-->   INSTR ADDR:  0001C0   INSTR:  5010 C2C0\nMODIFICATION LIMIT ADDRS-->  LOW:  0002C0   HIGH:  0002C3\n\n\n     XOPC 7   -    SET  ADDRESSES  (as  in  XOPC  5)  and  TURN  ON  THE\n                  STORAGE MODIFICATION CHECKING FACILITY\n\n         This instruction combines the actions of the XOPC 5 and\nXOPC 6 instructions above.\n\n\n     XOPC 8    -    TURN  OFF  STORAGE  MODIFICATION  CHECKING  FACILITY\n\n         This instruction disables the Storage Modification\nChecking Facility.\n\n\n     XOPC  9    -    TURN  ON  BOUNDARY  ALIGNMENT   CHECKING   FACILITY\n\n         This instruction turns on boundary alignment checking in\nASSIST.  This implies that S0C6  alignment interrupts will  be  allowed.\nThe default condition  within  ASSIST  allows  Alignment  Interrupts  to\noccur.  Thus, this instruction need be  executed  only  after  execution\nof  an  XOPC  10  instruction  has  shut  off  (disabled)  the  Boundary\nAlignment Checking Facility (see XOPC 10).\n\n\n     XOPC  10    -    TURN  OFF  BOUNDARY  ALIGNMENT  CHECKING  FACILITY\n\n         This instruction disables Boundary Alignment checking in\nASSIST.  This implies that S0C6  Alignment  Interrupts  will  no  longer\nbe allowed after the execution of this instruction.  Thus, the  user  is\nno longer restricted by storage alignments and can fetch and store  data\non odd word boundaries.\n\n\n                                                      ASSIST4-6\n\n     XOPC 11   -   FETCH ASSIST INSTRUCTION COUNTER\n\n         The current value of the ASSIST Instruction Counter is put\nin user register 0.  This instruction should be used in conjunction with\nthe XOPC  14  instruction  described  below.   The  instruction  counter\nis put into the register in hexidecimal form.\n\n\n     XOPC 12   -   EMULATE SYSTEM 360\n\n          This instruction causes ASSIST to emulate a system 360.  That\nis, ASSIST will act as if it is  running  on  an  S360  no  matter  what\nmachine (S360 or S370) it is really running  on.   It  should  be  noted\nthat emulation in ASSIST defaults to S370  (S370  instructions  will  be\ninterpreted).  After the execution of  this  instruction  however,  ONLY\nS360 instructions will be interpreted.   S370  instructions  will  cause\nuser program termination (S0C1).\n\n\n     XOPC 13   -   EMULATE SYSTEM 370\n\n          This instruction causes ASSIST to emulate a system 370.  That\nis, ASSIST will act as if it is  running  on  an  S370  no  matter  what\nmachine (S360 or S370)  it  is  really  running  on.   This  instruction\nshould only be used after the execution of an  XOPC  12  instruction  as\nmachine emulation in ASSIST  defaults  to  S370  (i.e.S370  instructions\nwill be interpreted).\n\n\n     XOPC 14   -   SET INTERRUPT COUNT\n\n         This instruction allows the user to halt program execution\nwhen the ASSIST instruction counter and the value found  in  register  0\nbecome equal (i.e. cause a COUNT INTERRUPT). This instruction should  be\nused in conjunction with the XOPC 11 instruction.   Any  negative  value\nfound in user register 0 when this instruction is executed  will  disarm\nthe count interrupt facility.\n          Example of Use:  The user desires a count interrupt to occur\nif 200 instructions are executed from this point on  (Note:  The  ASSIST\ninstruction counter counts down):\n\n         XOPC  11      Load register 0 with current instruction counter\n         S     R0,=F'200'   decrement counter by 200\n         XOPC  14       Set interrupt count 200 instructions from now.\n\n\n                                                      ASSIST4-7\n\n     XOPC 15   -   SET COUNT EXIT ADDRESS\n\n         The value found in user register 0 when this instruction is\nexecuted will be used as an exit address if  a  count  interrupt  occurs\n(i.e.  when  the  instruction  counter  becomes  equal  to   the   clock\ncomparator - see XOPC 14).  If  a  count  interrupt  occurs  after  this\ninstruction has been executed, the  psw  at  interrupt  will  be  loaded\ninto user registers 0 and 1.  Execution  will  then  continue  beginning\nat the given exit address.  If no exit address has  been  specified  and\na  count  interrupt  occurs,  the  program  abnormally  terminates  with\nthe  standard  ASSIST  instruction   limit   exceeded   error   printed.\n\n\n     XOPC 16   -   TURN ON  THE  INSTRUCTION  EXECUTION  COUNT  FACILITY\n\n         This instruction enables the INSTRUCTION EXECUTION COUNT\nFACILITY.  This facility counts each instruction  executed  between  two\nlimit  addresses.   It  should  be  realized  that  upon   its   initial\nexecution this instruction will cause ASSIST to allocate  a  section  of\nmain memory equal in size to that of the user program.   If  this  space\nis found to be unavailable, the condition code of the  user  program  is\nset to one and the  count  facility  remains  disabled.   Prior  to  the\nexecution of this  instruction,  the  user  should  have  specified  two\nlimit addresses for the count facility (See XOPC  17  below).   However,\nif two limit addresses were not specified, ASSIST will use  the  highest\nand lowest program addresses  for  the  limit  addresses.   Note:   This\ninstruction does not clear the  instruction  counting  area.   See  XOPC\n20 for clearing the count area.\n\n\n      XOPC  17    -    SET  ADDRESSES  FOR  THE  INSTRUCTION   EXECUTION\n                    COUNT FACILITY (IECF)\n\n          This instruction specifies boundary limit addresses used by\nIECF.  Once enabled this facility will count the  number  of  executions\nof each instruction between the two limit addresses  specified  by  this\ninstruction.  When  this  instruction  is  executed  the  low  and  high\nIECF limit addresses are assumed to be in registers 0 and 1,\nrespectively.\n\n\n      XOPC 18   -   SET ADDRESSES AND TURN ON THE IECF\n\n          This instruction combines the actions of XOPC instructions\n16 and 17.  Register usage is assumed to be the  same  as  in  XOPC  17.\n\n\n      XOPC 19   -   TURN OFF THE INSTRUCTION  EXECUTION  COUNT  FACILITY\n\n          This instruction disables the IECF.  This instruction will\nnot have any effect on the IECF counting area.\n\n\n                                                      ASSIST4-8\n\n     XOPC 20    -    CLEAR  THE  INSTRUCTION  EXECUTION  COUNT  FACILITY\n                   COUNTING AREA\n\n          This instruction resets the Instruction Execution Count\nFacility Counting area to zero.  If the IECF has never been  enabled  in\nthe user program (i.e.  no  counting  space  has  been  allocated),  the\ncondition code of the user program is set to 1 and this  instruction  is\nignored.  This instruction can be executed an unlimited number of  times\nto insure accurate instruction counting.  Please note that  the  counter\nfor each instruction is only a halfword (2 bytes) in length.   Executing\none instruction many times could overflow  that  counter  and  reset  it\nto zero.\n\n\n     XOPC 21   -   RETURN FROM INTERRUPT PROCESSING CODE\n\n         This instruction tells ASSIST that the User Program has com-\npleted any interrupt processing routine  (s)  and  is  ready  to  resume\nnormal execution of the user program.  It causes the  following  actions\nto occur:\n\n         1).  If the user is not in the interrupt processing state the\n            condition code is set to 1 and nothing more is done.\n\n         2).  The address in register 1 is used as the address where\n            normal  execution of the user program will resume.  If\n            register 1 is not modified in the interrupt processing code,\n            execution of the user program will continue with the\n            instruction immediately following the instruction that\n            caused the initial interrupt.  Otherwise, the user will be\n            expected to load register 1 with an appropriate address.\n\n         3).  User registers 0 and 1 are reloaded with the values they\n            had when the initial interrupt occurred.\n\n         4).  Normal execution of the user program is resumed with the\n            user no longer in the INTERRUPT PROCESSING STATE.\n\n\n     XOPC  22    -    DUMP  THE  INSTRUCTION  EXECUTION  COUNT  FACILITY\n                   STATISTICS\n\n          This instruction prints out a statistical report according to\naddress of the number of  instructions  counted  (within  the  specified\nlimit addresses)  by  the  Instruction  Execution  Count  Facility.   An\ninstruction executed 0 times  will  cause  no  statistical  line  to  be\nprinted.  Groups of instructions executed the same number of times  will\nproduce one statistical line.  This  shows  the  user  where  his  major\nloops are and where most of his execution time is being spent.  If  this\ninstruction is executed and the count facility has not yet been  enabled\nat least once in  the  user  program  (i.e.  no  count  space  has  been\nallocated), the condition code of the user program is  set  to  one  and\nthis instruction is ignored.  As an example consider the following  test\nprogram:\n\n\n                                                      ASSIST4-9\n\n    ADDR          INSTRUCTION          COMMENTS\n                   ...\n                   ...\n                   ...\n   000010  LOWADDR EQU   *\n   000010           LA     0,LOWADDR        GET  LOW  COUNTING   ADDRESS\n   000014           LA     1,HIGHADDR       GET  HIGH  COUNTING  ADDRESS\n   000018          XOPC  18              ENABLE THE COUNT FACILITY\n   00001A          XOPC  20              CLEAR THE COUNT AREA\n   00001E          LA    10,50           GET LOOP VALUE\n   000022  LOOP    LR    1,3             DO GARBAGE FOR COUNTING\n   000024          AR    4,1             MORE GARBAGE\n   000028          BCT   10,LOOP         LOOP 50 TIMES\n   00002C          XOPC  19              TURN OFF THE COUNTING\n   00002E          XOPC  22              DUMP STATISTICS\n   000030 HIGHADDR EQU   *\n                   ...\n                   ...\n                   ...\nThe XOPC 22 instruction above would print out the following  statistical\nreport:\n\nSTATS--> BEGIN ADDR: 00001E  END ADDR:  00001E  INSTRUCTION COUNT:  0001\nSTATS--> BEGIN ADDR: 000022  END ADDR:  000028  INSTRUCTION COUNT:  0050\nSTATS--> BEGIN ADDR: 00002C  END ADDR:  00002C  INSTRUCTION COUNT:  0001\n\n\nA FEW EXTRA NOTES:\n\n          It should be noted when using the XOPC instructions that they\nare expensive instructions with  regard  to  overhead  space  and  time.\nThey should be used sparingly and preferably one facility at a time  for\nbest results.\n\n\n                                                       ASSIST5-1\n\nPART V.  OUTPUT AND ERROR MESSAGES\n\nA. ASSEMBLY LISTING\n\n  1. ASSEMBLY LISTING FORMAT\n\n     The assembly listing produced by the  ASSIST  assembler  is  essen-\ntially the same as that produced  by  the  standard  OS/360  assemblers,\nwith the following minor differences:\n\n       a. Error messages are not printed at  the  end  of  the  assembly\nlisting, but are printed after the each statement causing the  messages.\nA scan pointer '$' indicates the column where the error was  discovered.\n\n       b. No more than four messages are printed for any  single  source\nstatement.  Some errors cause termination of statement scan, and  errors\nfollowing in the same statement may  not  be  discovered.   However,  an\nerror in a statement does not normally prevent its statement label  from\nbeing defined, which is usually the case with  the  standard  assembler.\n\n       c. As noted under PRINT in PART I and under NOLIST in  PART  III,\nstatements flagged are printed regardless of print status at  the  time.\n\n       d. As noted under PRINT in PART I, no more than  eight  bytes  of\ndata  are  printed  for  a  statement,  even  if  PRINT  DATA  is  used.\n\n  2. ASSEMBLER ERROR MESSAGES\n\n     The assembler produces error messages consisting of an  error  code\nfollowed by an error description.  The code is of the form  AS###,  with\nthe value of ### indicating one of three types of errors:\n\n       a. Warnings - ### is in range 000-099.  These never  prevent  the\nexecution of the program, correspond to OS severity code 4,   and e have\nmessages beginning with characters 'W-'.\n\n       b. Errors - ### is in range 100-899. Execution is deleted if  the\ntotal number of errors exceeds the NERR parameter, as described in  PART\nIII.  These correspond to OS severity codes of 8 and 12.\n\n     c. Disastrous errors - ### is  in  range  900-999.  Some  condition\nprevents successful completion of the assembly  process.   Execution  of\nthe user program may or may not be permitted.\n\n\n                                                      ASSIST5-2\n\n  3. LIST OF ASSEMBLER ERROR MESSAGES\n\n     The following lists the codes and messages  issued  by  the  ASSIST\nassembler, with further explanations following each message.\n\nAS000 W-ALIGNMENT ERROR-IMPROPER BOUNDARY\n     The address used in a machine instruction is  not  aligned  to  the\n     correct  boundary  required  by  the  type  of  instruction   used.\n\nAS001 W-ENTRY ERROR-CONFLICT OR UNDEFINED\n     A symbol named in an ENTRY statement is  either  undefined,  or  is\n     also named in either a DSECT or EXTRN statement.\n\nAS002 W-EXTERNAL NAME ERROR OR CONFLICT\n     A symbol named in an EXTRN  statement  is  either  defined  in  the\n     program or is named in an ENTRY statement.\n\nAS003 W-REGISTER NOT USED\n     The register flagged in a DROP statement is not available  for  use\n     as a base register at this point  in  the  program.   This  may  be\n     caused by an error  in  a  USING  statement  naming  the  register.\n\nAS004 W-ODD REGISTER USED-EVEN REQUIRED\n     An odd register is coded in a machine  instruction  requiring  the\u00e0\n     use of an even  register  for  a  specific  operand.   Instructions\n     which may flagged are Multiply,  Divide,  Double  Shifts,  and  all\n     floating point instructions.\n\nAS005 W-END CARD MISSING-SUPPLIED\n     The assembler creates an END card because  the  user  has  supplied\n     none before an end-file marker.\n\n\n                                                      ASSIST5-3\n\nAS100 ADDRESSIBILITY ERROR\n     An implied address is used which  cannot  be  resolved  into  base-\n     displacement form.   No  base  register  is  available  having  the\n     same relocatability attribute and a value from 0 to 4095 less  than\n     the value of the implied address.\n\nAS101 CONSTANT TOO LONG\n     Too many characters are coded for the type of  constant  specified.\n     This message appears if a literal constant contains more  than  112\n     characters, including the equals sign and delimiters.\n\nAS102 ILLEGAL CONSTANT TYPE\n     An unrecognizable type of constant is specified.\n\nAS103 CONTINUATION CARD COLS. 1-15 NONBLANK\n     A continuation card contains nonblank characters in  columns  1-15.\n     This may be caused by an accidental  punch  in  column  72  of  the\n     preceding card.\n\nAS104 MORE THAN 2 CONTINUATION CARDS\n     Three or more  continuation  cards  are  used,  which  is  illegal,\n     except on macro prototype statements and macro calls.\n\nAS105 COMPLEX RELOCATABILITY ILLEGAL\n     ASSIST does not permit complex relocatible expressions.\n\nAS106 TOO MANY OPERANDS IN DC\n     ASSIST allows  no  more  than  ten  operands  in  a  DC  statement.\n\nAS107 MAY NOT RESUME SECTION CODING\n     The assembler requires that any section  be  coded  in  one  piece.\n     The label flagged  has  already  appeared  on  a  CSECT  or  DSECT.\n\nAS108 ILLEGAL DUPLICATION FACTOR\n     A duplication factor either exceeds the maximum  value  of  32,767,\n     or a duplication factor in a literal constant is not  specified  by\n     a decimal term or else has the value zero.\n\nAS109 EXPRESSION TOO LARGE\n     The value of the flagged expression or term is too  large  for  the\n     given usage, such as a constant length  greater  than  the  maximum\n     permissible for the type of constant.\n\nAS110 EXPRESSION TOO SMALL\n     The value of the flagged expression or term is too  small  for  the\n     given usage, or has a negative value.   Coding  a  V-type  constant\n     with a length of two would generate this message.\n\n\n                                                      ASSIST5-4\n\nAS111 INVALID CNOP OPERAND(S)\n     The operands of a CNOP have  values  which  are  anything  but  the\n     legal combinations of values for a CNOP, such as  a  first  operand\n     greater than the second, an odd value, etc.  The only  legal  value\n     combinations are  0,4  2,4 0,8  2,8  4,8  6,8  .\n\nAS112 LABEL NOT ALLOWED\n     A label is used on a  statement  not  permitting  one,  such  as  a\n     CNOP or USING statement.\n\nAS113 ORG VALUE IN WRONG SECTION OR TOO LOW\u00e0\n     The expression in an ORG statement either has a value smaller  than\n     the  initial  location  counter  value  for  the  current   control\n     section, or has a  relocatibility  attribute  different  from  that\n     of the current control section.\n\nAS114 INVALID CONSTANT\n     A  constant  contains  invalid  characters  for  its  type,  or  is\n     specified improperly in some other way.\n\nAS115 INVALID DELIMITER\n     The character flagged cannot appear in the statement where it does.\n     This message is used whenever the scanner expects a certain kind of\n     delimiter to be used, and it is not there.\n\nAS116 INVALID FIELD\n     The field flagged has an  unrecognizable  value,  or  is  otherwise\n     incorrectly coded.  PRINT OF  is flagged this way.\n\nAS117 INVALID SYMBOL\n     The symbol flagged either contains nine or more characters or  does\n     not begin with an alphabetic character as is required.\n\nAS118 INVALID OP-CODE\n     The statement contains an unrecognizable mnemonic  op-code, or none\n     at all.  Note that different versions of ASSIST may not accept some\n     of  the  possible  op-codes.   The  first  heading   described   in\n     PART IV.B.1.a describes which op-codes are allowed.\n\nAS119 PREVIOUSLY DEFINED SYMBOL\n     The symbol in the label field has been previously used as a  label,\n     or a SET variable has been previously declared.\n\nAS120 ABSOLUTE EXPRESSION REQUIRED\n     A relocatable expression is used where an absolute one is required,\n     such  as  in   constant  duplication  factor  or  for  a  register.\n\n\n\n                                                      ASSIST5-5\n\nAS121 MISSING DELIMITER\n     A delimiter is expected but not  found.   For  instance,  a  C-type\n     constant coded with no ending ' is flagged this way.\n\nAS122 FEATURE NOT CURRENTLY IMPLEMENTED\n     The version of ASSIST being used  does  not  support  the  language\n     feature used.\n\nAS123 MISSING OPERAND\n     The instruction requires an  operand,  but  it  is  not  specified.\n\nAS124 LABEL REQUIRED\n     An instruction requiring  a  label,  such  as  a  DSECT,  is  coded\n     without one.\n\nAS126 RELOCATABLE EXPRESSION REQUIRED\n     An absolute expression or term is used where a relocatable  one  is\n     required by ASSIST, such as  in  the  first  operand  of  a  USING.\n     Also, this message may appear if the final relocatiblity  attribute\n     of the value in an address constant is that of a symbol in a DSECT.\n\nAS127 INVALID SELF-DEFINING TERM\n     The self-defining term flagged contains an  illegal  character  for\n     its type, has a value too large for  24  bits  to  contain,  or  is\n     otherwise incorrectly specified.\n\nAS128 ILLEGAL START CARD\n     The START card flagged is coded with one or more  statements  other\n     than listing controls or comments appearing before it.\n\nAS129 ILLEGAL USE OF LITERAL\n     The  literal  constant  appears  in  the  receiving  field  of   an\n     instruction which modifies storage.  e.g.,  ST  0,=F'1'\n\nAS130 UNDEFINED SYMBOL\n     The symbol shown is either completely undefined, or  has  not  been\n     already defined when it is required to be.   Symbols  used  in  ORG\n     instructions or in constant lengths or duplication factors must  be\n     defined before they are used.\n\n\n                                                      ASSIST5-6\n\nAS131 UNRESOLVED EXTERNAL REFERENCE\n     The symbol used  in  a  V-type  constant  is  not  defined  in  the\n     assembly, or is defined but not declared a CSECT or ENTRY.   ASSIST\n     does not link multiple assemblies, so this is an error.\n\nAS132 ILLEGAL CHARACTER\n     The character flagged is  either  not  in  the  set  of  acceptable\n     characters, or is used in an illegal way.\n\nAS133 TOO MANY PARENTHESIS LEVELS\n     Parentheses are nested  more  than  five  deep  in  an  expression.\n\nAS134 RELOCATABLE EXPRESSION USED WITH * OR /\n     RElocatable terms or expressions may not be  used  with  either  of\n     these operators.\n\nAS135 SYNTAX\n     The character flagged is improperly used.   This  catchall  message\n     is given by the general expression evaluator when it does not  find\n     what is expected during a scan.\n\nAS136 TOO MANY TERMS IN EXPRESSION\n     The expression contains more than the legal maximum  of  16  terms.\n\nAS137 UNEXPECTED END OF EXPRESSION\n     The expression terminates without having enough closing parentheses\n     to balance the opening ones used.\n\n\nTHE FOLLOWING MESSAGES ARE ONLY ISSUED DURING MACRO PROCESSING.\n\nAS201 OPERAND NOT ALLOWED\n     During macro expansion, an extra operand was found, i.e.,  an extra\n     positional beyond those given in the prototype.\n\n\nAS202 STATEMENT OUT OF ORDER\n     The statement flagged is in an incorrect place in the deck.     For\n     example:  LCLx before GBLx, ACTR not after both; GBLx, LCLx,   ACTR\n     in middle of macro definition or open code.  *SYSLIB  card  out  of\n     order, etc.  May often be caused by missing MEND card.\n\n\nAS203 SET SYMBOL DIMENSION ERROR\n     A dimensioned set symbol was used without a dimension, or one which\n     was not dimensioned was written with one.\n\n\nAS204 INVALID NBR OF SUBSCRIPTS\n     There was an error in specifying substring notation, sublists,   or\n     set symbol dimension.\n\n\n                                                       ASSIST5-7\n\nAS205 ILLEGAL CONVERSION\n     During macro editing, a SET instruction was found with an obviously\n     Incorrect conversion, as in  &I   SETA  C  .\n\n\nAS206 MISSING QUOTES IN CHAR EXPR\n     Quotes (apostrophes) are required in character expressions and must\n     always be supplied, but were not.\n\n\nAS207 ILLEGAL OR DUP MACRO NAME\n     A macro prototype name is either completely illegal, such as having\n     too many characters, or duplicates the name of a previously   given\n     macro, machine instruction, or assembler instruction.\n\n\nAS208 OPRND NOT COMPATIBLE WITH OPRTR\n     An operand is used with an incompatible operator.  For example,  if\n     &C is LCLC, &B LCLB :   &B    SETB (NOT &C)     .\n\n\nAS209 UNDFND OR DUPLICATE KEYWORD\n     In calling a macro, a keyword is used which does not appear in  the\n     macro prototype. In either defining or calling a macro,  a  keyword\n     operand appears twice or more in the list of operands.\n\n\nAS210 MNEST LIMIT EXCEEDED\n     The MNEST option provides a maximum limit to the nested  depth   of\n     macro calls.  This limit has been exceeded.  Note that   after  the\n     MSTMG limit has been exceeded, the MNEST limit  is  effectively 0 .\n\n\nAS211 ILLEGAL ATTRIBUTE USE\n     ASSIST does not support S', I', or L' for macro operands.\n\n\nAS212 GENERATED STATEMENT TOO LONG\n     A STATEMENT WAS GENERATED HAVING MORE THAN TWO CONTINUATION CARDS .\n\nAS217 STMT NOT PROCESSED: PREVIOUS ERROR: STMT/MACRO #####/name\n     During expansion of macro 'name', the statement numbered #####  was\n     encountered, but  not expanded because it had already been flagged.\n\nAS218 STORAGE EXCEEDED BY FOLLOWING MACRO EXPANSION\n     The following call to the macro listed caused overflow of storage ,\n     probably due to looping.  Use ACTR, MACTR=, or MSTMG= .\n\n\nAS220 UNDEFINED SEQUENCE SYMBOL IN STATEMENT #####\n     This may appear following an entire macro definition, and gives the\n     number of a statement referencing a sequence symbol never defined .\n\n\n                                                       ASSIST5-8\n\n     Any of the following messages describes an error found during   the\nexpansion of statement ##### of macro 'name' .  Some messages also   add\na descriptive 'value', such as an offending subscript.   Note  that  the\nmessages below use ## as an abbreviation for the actual output (which is\nactually printed by ASSIST in the form  STMT/MACRO #####/name).\n\n\nAS221 ACTR COUNTER EXCEEDED: ##\n     The ACTR count has been exceeded.  The ACTR is set  by  the   MACTR\n     option, or by an ACTR statement.  This indicates a looping macro  .\n\n\nAS222 INVALID SYM PAR OR SET SYMBOL SUBSCRIPT: ##  --> value\n     A  subscript is out of range.  The offending value is given.\n\nAS223 SUBSTRING EXPRESSION OUT OF RANGE: ##  --> value\n     This is most often caused by the first subscript  in  a   substring\n     expression having a nonpositive value, or one larger than the  size\n     of the string.\n\n\nAS224 INVALID CONVERSION, CHAR TO ARITH: ##  --> value\n     The value could not be converted to arithmetic form.\n\nAS225 INVALID CONVERSION, ARITH TO BOOLEAN: ##  --> value\n     The value was not 0 or 1.\n\nAS226 INVALID CONVERSION, CHAR TO BOOLEAN: ##  --> value\n     The value was not '0' or '1', so it could not be converted.\n\n\nAS227 ILLEGAL ATTRIBUTE USE: ##\n     An attribute was used incorrectly.\n\nAS228 &SYSLIST SUBSCRIPT OUT OF RANGE: ##\n     The subscript has a value greater than the maximum number of fields\n     which can be supplied.\n\nAS229 CALL FRIENDLY ASSIST REPAIRMAN: ##\n     An internal error has occurred inside ASSIST.  Please send a  deck.\n\nAS230 INTERNAL CHAR BUFFER EXCEEDED: ##\n     Too much concatenation was done in the statement.  Remedy:   reduce\n     the complexity of the statement.\n\nAS231 MSTMG LIMIT EXCEEDED: ##\n     The MSTMG limit (total number of statements processed during  macro\n     expansion) has been exceeded.  Use MSTMG= to increase this.\n\nAS232 ZERO DIVIDE OR FIXED POINT OVERFLOW: ##\n     One of these interrupts was caused by the statement given.\n\n\n                                                       ASSIST5-9\n\nAS241 SEQUENCE SYMBOL NOT FOUND\n     This message immediately follows an AGO or successful AIF in   open\n     code whose sequence symbol could not be found before the END  card.\n     As a result, all of the program between the AIF/AGO and END card is\n     skipped over.\n\n\nAS242 BACKWARDS AIF/AGO ILLEGAL\n     This message appears following an AGO or successful AIF in the open\n     code which references a previously defined sequence symbol.  ASSIST\n     allows backwards branches only in macros, not in open code.\n\n\nAS288 MACRO xxxxxxxx COULD NOT BE FOUND\n     This is issued by the macro library processor when it tries to get\n     a macro and cannot find it in the library.  The macro may be  named\n     on a *SYSLIB card, or referenced by another macro.\n\nAS289 UNABLE TO OPEN MACRO LIBRARY: OPTION CANCELED\n     This is issued after a *SYSLIB card is encountered, but the   macro\n     library cannot be opened.  A SYSLIB DD card is missing or in error.\n\n\nAS298 GENERATED STMTS OVERWRITTEN\n     During macro expansion, one or more generated statments  were  lost\n     due to internal table management, probably because a statement near\n     the beginning of a macro generated a long literal constant.     One\n     solution is to insert several comments cards at the beginning    of\n     the macro definition.\n\n\n\nAS999 DYNAMIC STORAGE EXCEEDED\n     ASSIST requires more storage than is available, so  the assembly is\n     halted.  This can occur for many reasons.  REMEDIES:  use the DISKU\n     option if available, remove comments cards from your program,   cut\n     down on array sizes, etc.\n\n\n                                                      ASSIST5-10\n\n  4. ASSEMBLER STATISTICS SUMMARY\n\n     Following the assembly listing, the assembler prints three or  four\nlines of statistical information, as follows:\n\n     a.\n*** ##### STATEMENTS FLAGGED - ##### WARNINGS, ##### ERRORS\n     This  notes  the  total  numbers  of  statements  flagged,  warning\n     messages, and error messages given during the assembly.\n\n     b.\n***** NUMBER OF ERRORS EXCEEDS LIMIT OF ##### ERRORS - PROGRAM EXECUTION\nDELETED *****\n     This notes the maximum number of errors permitting  execution,  and\n     that the user program will not be executed because the  NERR  limit\n     value has been overrun (see PART III regarding NERR).\n\n     c.\n*** DYNAMIC CORE AREA USED:  LOW:  ###### HIGH:  ######  LEAVING: ######\nFREE BYTES. AVERAGE:  ###### BYTES/STMT ***\n     The ASSIST assembler uses memory from the opposite ends of one area\nof storage acquired at execution time.  The  LOW  area  contains  source\nstatements and generated object code,the HIGH area contains  the  symbol\nand literal tables, and the space  remaining  indicates  how  close  the\nuser is to causing a storage overflow.  The average core  usage  printed\nincludes that used in both LOW and HIGH areas.\n\n     d.\n*** ASSEMBLY TIME = #.### SECS,   ##### STATEMENTS/SEC ***\n     This notes the total time used by the  assembler,  along  with  the\n     rate of assembly.  At PSU, this time includes  both  CPU  time  and\n     I/O charges.\n\n     e.\n***** EXECUTION DELETED - LESS THAN ## PER CENT OF MACHINE INSTRUCTIONS\nHAVE COMMENTS *****\n     The above message may appear before the core area message,  if  the\n     ASSIST has the comment-checking option, and either COMNT was coded,\n     or was invoked by account number, and the user did not put comments\n     on the given percentage of machine instruction statements.\n\n\n                                                      ASSIST5-11\n\nB. ASSIST MONITOR MESSAGES\n\n  1. HEADINGS AND STATISTICAL MESSAGES\n\n     The  main  control  program  of  ASSIST  may  issue  the  following\nheadings and messages during execution:\n\n     a.\n*** ASSIST version OF date INSTS/DFP/=### CHECK/TRP/=### OPTS/CCKMR/=###\n### PENN STATE UNIV.   model - system ***\n     This heading is the  first  line  printed,  and  it  describes  the\nfacilities in the version of ASSIST being used, as follows:\n\nversion,date   - version number of this ASSIST, and date it was created.\nINS/DFPS/=     - describes instruction sets accepted. The digits are 0's\n                 or 1's showing lack  or  presence of decimal,  floating\n                 point, privileged operations, and some S/370 operations\nCHECK/TRP/=    - describes time, records, and pages checking modes.  a 2\n                 for T or R indicates ASSIST can obtain time or  records\n                 remaining from system, 0 for T indicates no  timing,  0\n                 for P indicates no page checking possible.\nOPTS/CCKMR/=   - describes availability of major optional  features,  in\n                 order CMPRS, COMNT, KP=26, MACRO, and REPL.  Values  of\n                 0 indicate the feature is unavailable.   If  value  for\n                 COMNT is nonzero, it is two digits long and  gives  the\n                 percentage of comments required.  A value of  1  for  R\n                 denotes  a partial  version  of  the  Replace  Monitor,\n                 while 2 denotes a complete version with all  features .\nmodel          - lists the  model  number of  the computer  being  used.\nsystem         - describes operating system being used (such as OS-MVT).\n\n     b.\n     Following  the  above  heading,  the  ASSIST  monitor  prints   the\ncontents  of  the  user's  EXEC  card  PARM  field,  or his $JOB   CARD.\n\n     c.\n*** PROGRAM EXECUTION BEGINNING  -  ANY  OUTPUT  BEFORE  EXECUTION  TIME\nMESSAGE IS PRODUCED BY USER PROGRAM ***\n     This message is issued  immediately  before  the  user  program  is\nexecuted, and serves to delimit user output.\n\n     d.\n*** EXECUTION TIME =  #.###  SECONDS    #####  INSTRUCTIONS  EXECUTED  -\n##### INSTRUCTIONS/SEC ***\n*** FIRST CARD NOT READ:  card image\n     This message is issued  immediately  after  the  user  program  has\nbeen executed, and supplies statistics regarding the execution time  and\nrate of execution of the user program.  The time shown may  be  slightly\nsmaller than the actual time, if the completion code given in  the  dump\nis  ASSIST = 223 TIME LIMIT EXCEEDED.  The second part appears if one or\nmore data cards were not read by the user program.\n     e.\n*** TOTAL RUN TIME UNDER ASSIST = #.### SECS ***\n     This is the last  line  printed  by  ASSIST,  and  the  time  given\nincludes  time  for  the entire  run.   Printed only if CHECK/TRP/=2## .\n\n\n                                                      ASSIST5-12\n\n  2. ASSIST MONITOR ERROR MESSAGES\n\n     The ASSIST monitor may also issue any of  the  following  messages,\nwhich are of the form AM###, and usually indicate errors:\n\nAM001 ASSIST COULD NOT OPEN PRINTER FT06F001:ABORT\n     This message appears in the system  message  class  data   set   if\n     ASSIST is unable to open the DCB  for  its  printer,  using  DDNAME\n     FT06F001.  This is probably caused by lack of a DD card, or  by  an\n     incorrect override  of  this  DDNAME  in  a  catalogued  procedure.\n\nAM002 ASSIST COULD NOT OPEN READER SYSIN:ABORT\n     This message appears in the  system  message  class  data  set   if\n     ASSIST is unable to open the DCB for the source card  reader.   The\n     SYSIN DD * card  is  probably  omitted  or  mispunched,  making  an\n     assembly and execution impossible.\n\nAM003 - STORAGE OVERFLOW BEFORE EXECUTION, EXECUTION DELETED\n     The user program assembled  properly,  but  there  is  insufficient\n     memory remaining to set up control blocks required  for  execution.\n     The user should attempt to reduce the amount  of  storage  used  by\n     his program.  This message should occur very seldom.\n\nAM004 - NORMAL USER TERMINATION BY RETURN\n     This message is issued if the user program branches to the  address\n     originally supplied to it as a return address in register  14.   If\n     this message appears, no completion dump is printed.\n\nAM005 - TIME OR RECORDS HAVE BEEN EXCEEDED\n     This message is printed if the time  or  record  limits  have  been\n     exceeded at any time during a job.  This message  appears  after  a\n     completion dump, if there is one.\n\n\n                                                      ASSIST5-13\n\nC. ASSIST COMPLETION DUMP\n\n     When a user program terminates abnormally,  a  completion  dump  is\nprovided for debugging  purposes,  and  contains  the  following  items:\n  1.\nASSIST COMPLETION DUMP\n     The above header begins the dump.\n  2.\nPSW AT ABEND xxxxxxxx xxxxxxxx  COMPLETION CODE   type  =  code  message\n     This line gives the user's Program  Status  Word,  in  hexadecimal,\nfollowed by further information concerning the reason  for  termination.\nThe type given is one of the following:\n     a. SYSTEM, indicating that the code given is the same as that given\n       by OS/360, such as for program interrupts.\n     b. ASSIST, indicating a completion code which does not  necessarily\n       correspond directly to a code used by OS/360.\nThe three-digit hexadecimal code is followed by a  descriptive  message.\nPART IV.D provides a list of the messages and codes.\n\n  3.\n***** TRACE OF INSTRUCTIONS JUST BEFORE TERMINATION: PSW BITS SHOWN  ARE\nTHOSE JUST BEFORE CORRESPONDING INSTRUCTIONS DECODED *****\n\n  IM LOCATION    INSTRUCTION :  IM = PSW BITS 32-39(ILC,CC,MASK)  BEFORE\nINSTRUCTION EXECUTED AT PROGRAM LOCATION SHOWN\n  aa  bbbbbb      cccc  cccc  cccc     (1-10  lines  in   this   format)\n\n     The above section in a dump lists up to the last  ten  instructions\nexecuted before termination, with the  last  instruction  shown  usually\ncausing the termination.  Parts aa and bbbbbb make  up  a  user  PSW  in\neach  line,  and  are  followed  by  from  one  to  three  halfwords  of\ninstruction, represented by cccc.\n\n  4.\n** TRACE OF LAST 10 BRANCH INSTRUCTIONS EXECUTED BEFORE TERMINATION: PSW\nBITS SHOWN ARE THOSE JUST BEFORE CORRESPONDING INSTRUCTION DECODED **\n\n  IM LOCATION    INSTRUCTION:  IM = PSW BITS 32-39(ILC,CC,MASK) BEFORE\nINSTRUCTION EXECUTED AT PROGRAM LOCATION SHOWN\n  AA BBBBBB       CCCC  CCCC  CCCC     (1-10 lines in this format)\n\n     The above section of the Assist Completion Dump is only given when\nASSIST Optional Extended Interpreter is in use by the installation. This\nsection in a dump lists up to the last 10 successful branch instructions\nexecuted before termination.\n  5.\nGP  REGISTERS     0/8         1/9         2/10         3/11         4/12\n        5/13       6/14       7/15\n\nREGS 0-7        (8 groups of 8 hexadecimal digits each)\nREGS 8-15       (8 groups of 8 hexadecimal digits each)\n\nFLTR 0-6        (4 groups of 16 hexadecimal digits each)\n\n     The above section in a dump displays the  contents  of  the  user's\ngeneral purpose and floating point registers at the time of termination.\n\n\n                                                       ASSIST5-14\n\n  6.\nUSER STORAGE\n\n                    CORE ADDRESSES SPECIFIED-   xxxxxx TO yyyyyy\nzzzzzz    (8 groups of 8 hexadecimal digits each)    * (32 characters) *\n\n     The above section shows the format of a  user  storage  dump.   The\nbeginning and ending addresses are given by  xxxxxx  and  yyyyyy.   Each\nline shows 32 bytes, beginning at location zzzzzz,  grouped  into  eight\nfullwords.  Each area is also shown in alphameric  form  at  the  right,\nwith blanks,  letters,  and  digits  printed  directly,  and  all  other\ncharacters translated to periods.\n\nD. COMPLETION CODES\n\nSYSTEM = 0Cx\n     This  code  is  given  for  program  interrupts,  where  x  is  the\n     hexadecimal interrupt code.  The message given is as shown on  page\n     6 of the IBM System/360 Reference Data card,  for  interrupts  0-F.\n\nASSIST = xxx message\n     This type is given for special ASSIST  completions.   The  possible\n     codes and messages are as follows:\n\n220 ATTEMPTED READ PAST ENDFILE\n     After performing an XREAD instruction and receiving an  end-of-file\n     indication, the user has attempted another  XREAD,  i.e.  tried  to\n     read more data cards than existed.\n\n221 INSTRUCTION LIMIT EXCEEDED\n     The user specified an I= limit on his EXEC card, and this number of\n     instructions has been exceeded.  The program was probably  looping.\n\n222 RECORD LIMIT EXCEEDED\n     The user attempted to print or punch more records than was given by\n     combination of R, RD, and RX option values.    Execution  has  been\n     terminated, and at least a partial dump given.\n\n223 TIME LIMIT EXCEEDED\n     The user program has consumed more execution time than specified by\n     the values of the T, TD, and TX option  values.      Execution  was\n     terminated and at least a partial dump given.\n\n224 BRANCH OUT OF PROGRAM AREA\n     The user program attempted to branch  outside  of  its  area.   The\n     only branch outside not flagged this way is a branch to the  return\n     address originally supplied to the user  program  in  register  14.\n\n\n                                                       ASSIST5-15\nE. OBJECT DECKS AND LOADER MESSAGES\n\n  1. OBJECT DECK FORMAT\n     ASSIST provides basic facilties for reading  (OBJIN)  and  punching\n(DECK) object decks which whose format is a compatible subset of  normal\nS/360 decks.  However, ASSIST does not punch External Symbol  Dictionary\n(ESD) or Relocation Dictionary (RLD) cards, and ignores them if  reading\na deck.  Thus, it cannot perform symbolic  linkage  between  modules  or\nrelocate individual address constants.  The facility can be  useful  for\nsaving assembler utility programs, or for  providing  efficient  running\nand good diagnostics for object  code  from  student-written  compilers.\n     Two types of cards are punched and recognized:  text  cards  (TXT),\nwhich supply actual object code, and end cards (END),  which  supply  an\noptional entry point address for beginning of  execution.   The  formats\nof these cards are described below.  ALWAYS lists the  characters  which\nare defintely present, DECK notes those which  are  punched,  and  OBJIN\nthose required for input.  The notation IGNORED  means  that  the  given\ncard columns  are  completely  ignored  when  loading  an  object  deck.\n\nCARD/COLUMNS   ALWAYS    DECK           OBJIN\n\nEND CARD\n  1                      ' '            IGNORED\n 2-4           END       -              -\n  5                      X'00'          IGNORED\n 6-8                     entry address  entry address or blanks\n 9-72                    blank          IGNORED\n73-80                    sequence #     IGNORED\n\nTEXT CARD\n  1                      ' '            IGNORED\n 2-4           TXT       -              -\n  5                      X'00'          IGNORED\n 6-8           beginning address of text code  which  is  on  this  card\n 9-10                    blanks         IGNORED\n 11                      X'00'          IGNORED\n 12            length of object code on card, from X'00' to X'38'\n               (i.e. 0 to 56 decimal bytes of code).\n13-16                    blanks         IGNORED\n17-72          up to 56 bytes of code, to be loaded  at  given  address.\n73-80                    sequence #     IGNORED\n\n     Note that the format above resembles the standard, given in:\nIBM S/360 OS Assembler (F) Programmer's Guide GC26-3756, Appendix B.\n\n     When ASSIST punches an object deck, it punches the  entire  program\nstorage, including character 5's which fill any DS or  other  areas  not\nhaving specified code values.  Unlike the  standard  system  assemblers,\nASSIST always punches an END card with an entry  point  address  on  it,\nwhether the user specifies an entry point on the source END card or not.\n\n     Although it is not possible to perform symbolic linkage of multiple\ndecks, it is possible to link multiple decks if the user assembles  each\nof several programs at particular locations known to each  other,  using\nSTART cards.  Deck linkage can then be accomplished by locating a vector\nof address constants at the beginning of each assembly, which  can  then\nbe used to reference any required areas or modules within that assembly.\nNote that this type of  procedure  will  not  work  if  RELOC  is  used.\n\n\n                                                       ASSIST5-16\n\n  2. ASSIST LOADER USAGE AND MESSAGES\n\n     The ASSIST loader is called by use  of  the  OBJIN  parameter,  and\nloads object deck cards having the format given on  the  previous  page,\nignoring all cards having neither TXT nor END in columns 2-4.  The usual\nuse for this option is to load a deck previously produced by  ASSIST  or\npossibly by some student-written compiler being tested.  However, it  is\npossible to link decks produced by the standard system assemblers if the\nguidelines below are followed:\n     a. Use no V-type adcons.\n     b. Any command listed in PART II of this manual (XREAD, XDUMP, etc)\n       is handled inside ASSIST as a special instruction, using  one  or\n       more of the opcodes not already used.  If any of  these  commands\n       is to be used, equivalent code must be generated.\n     c. If multiple assemblies are used, the  only  way  to  communicate\n       among them is to assemble each at some fixed  location  known  to\n       any of the others which reference it in any way.\n\n     Regardless of the method used to create the input deck, the  entire\nobject deck must follow the rules below:\n     a. The address on the first TXT card must be less than or equal  to\n       all other TXT card addresses received.  The object code for  this\n       address is placed starting at the first byte of available memory.\n     b. The difference between the highest address  of  received  object\n       code and the lowest address cannot exceed the available  storage.\n     c. The entry point address is either the address from the first END\n       card specifying one (i.e., not blank), or if no such  address  is\n       found, then the address found on the first TXT card.\n     d. The user program cannot modify  storage  beyond  the  last  code\n       address, so if it requires more work space, it can specify a  TXT\n       card with zero length and a high enough address to reserve space.\n     Within the limits above, TXT addresses can occur in any order,  and\nEND cards can appear anywhere (including the first card  of  the  deck).\n\n     The user is cautioned to be careful in using the RELOC option  with\nOBJIN.  ASSIST normally computes a relocation factor used  to  load  the\ncode, which is equal to the lowest actual memory address minus the first\nTXT address.  After loading the code, if RELOC is used,  the  relocation\nis set to 0, since RELOC-type programs must be run  with  no  execution-\ntime relocation (so they can reference low-core addresses for instance).\nThus, any deck to be run under RELOC should contain no  relocatable-type\naddress constants of any type, or else should use a START card to create\nthe same addresses as where the program will be run (which may  be  hard\nto do under general OS-MFT and MVT systems).\n\n\n\n\n                                                       ASSIST5-17\n\n     Messages produced by the ASSIST  loader  are  of  the  form  AL###,\nand include the following messages:\n\n     a.\n*** AL000 - ASSIST LOADER BEGINS LOAD AT xxxxxx  ,USABLE  CORE  ENDS  AT\nxxxxxx ***\n     This message is printed before loading  is  begun,  and  gives  the\nbeginning real address at which code can be loaded, and the  address  of\nthe first byte beyond the usable area.  The  entire  area  mentioned  is\nfilled with character 5's before loading is begun.\n\n*** AL100 - LOAD COMPLETED, USER ADDRESSES: LOW xxxxxx  ,HIGH  xxxxxx  ,\nENTRY xxxxxx , RUN-TIME RELOCATION xxxxxx ***\n     This message is printed at the end of a successful load.  It  gives\nthe low and high addresses in user-relative values (as found in incoming\nTXT cards), the entry point address where execution is to begin  (again,\nin user-relative terms), and the run-time relocation factor.  This  last\nvalue is used during interpretive  execution,  and  is  added  to  every\nprogram-defined address to obtain an actual address in  memory, i.e., as\nfar as the user program is concerned, it is actually located between the\nLOW and HIGH addresses given.  If RELOC is used, the  relocation  factor\nwill be set to zero, regardless of the relocation  factor  actually used\nto load the program.\n\n\n     The following messages indicate a error in the input deck.  Loading\nis terminated, and user program execution does not occur.   **NOTE**  if\neither message AL997 or AL998 appears, it will be followed by  an  XSNAP\nlabeled  'IMAGE OF INCORRECT OBJECT CARD'   ,  and  the  offending  card\ndisplayed beginning at the first address given by the XSNAP.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE901": {"ttr": 1798, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04X\\x00I\\x01\\x132?\\x01\\x132?\\x138\\x00\\x06\\x00\\x06\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf8@@@'", "ispf": {"version": "04.88", "flags": 0, "createdate": "2013-11-19T00:00:00", "modifydate": "2013-11-19T13:38:49", "lines": 6, "newlines": 6, "modlines": 0, "user": "CBT-488"}, "text": "//***FILE 901 is the ASSIST assembler for OS/360 and for similar    *   FILE 901\n//*           operating systems, presented here courtesy of Jay     *   FILE 901\n//*           Moseley.                                              *   FILE 901\n//*                                                                 *   FILE 901\n//*           email:  dino@jaymoseley.com                           *   FILE 901\n//*                                                                 *   FILE 901\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ASMINTRO": {"ttr": 1800, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x132?\\x01\\x132?\\x130!\\x0c!\\x0c\\x00\\x00\\xd7\\xc4\\xc6@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-11-19T00:00:00", "modifydate": "2013-11-19T13:30:00", "lines": 8460, "newlines": 8460, "modlines": 0, "user": "PDF"}, "mimetype": "application/pdf", "datatype": "binary", "extension": ".pdf"}, "ASSIST$": {"ttr": 5130, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x132?\\x01\\x132?\\x010wewe\\x00\\x00\\xc1\\xe2\\xe2\\xc9\\xe2\\xe3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-11-19T00:00:00", "modifydate": "2013-11-19T01:30:00", "lines": 30565, "newlines": 30565, "modlines": 0, "user": "ASSIST"}, "text": "//ASSIST$  JOB (SYS),'INSTALL ASSIST',\n//             CLASS=A,MSGCLASS=X,COND=(0,NE)\n//*\n//*  ! ! ! DO NOT RENUMBER THIS JOBSTREAM ! ! !\n//*\n//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n//* THIS JOB INSTALLS THE ASSIST LOAD MODULE.\n//* STEP 1: THE SOURCE IS COPIED FROM INSTREAM STATEMENTS TO TWO\n//*         TEMPORARY DATASETS.\n//* STEP 2: UPDATES ARE APPLIED TO THOSE DATASETS USING ADDITIONAL\n//*         INSTREAM STATEMENTS.  IF YOU WISH TO MAKE CHANGES TO THE\n//*         INSTALLATION DEFAULTS, MAKE THEM TO THE STATEMENTS\n//*         FOLLOWING THE UPDATEA.SYSIN STATEMENT BELOW AND RE-SUBMIT\n//*         THE JOB.  (THE SECOND SET OF UPDATES CORRECTS SOME\n//*         PROBLEMS WITH THE ORIGINAL SOURCE THAT SEEMS TO HAVE\n//*         ORIGINATED DURING TRANSMISSION AND/OR TRANSLATION.\n//* STEP 3: THE UPDATED SOURCE IS ASSEMBLED AND LINK-EDITED INTO\n//*         SYS2.LINKLIB.  IF YOU WISH TO USE A DIFFERENT LIBRARY,\n//*         CHANGE THE SINGLE INSTANCE WHERE SYS2.LINKLIB IS CODED\n//*         BELOW.\n//* STEP 4: A SET OF MACROS IS ADDED TO SYS1.MACLIB THAT ARE REQUIRED\n//*         TO EXECUTE ASSIST.\n//* STEP 5: A PROCEDURE TO INVOKE ASSIST IS ADDED TO SYS2.PROCLIB.  IF\n//*         YOU WISH TO USE A DIFFERENT LIBRAYR, CHANGE THE SINGLE\n//*         INSTANCE WHERE SYS2.PROCLIB IS CODED BELOW.\n//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n//*\n//ASOURCE  PROC\n//*\n//CREATEA  EXEC PGM=IEBUPDTE,PARM=NEW\n//SYSPRINT DD  SYSOUT=*\n//SYSUT2   DD  DSN=&&ASSRCO1,UNIT=SYSDA,DISP=(,PASS),\n//             DCB=(DSORG=PS,RECFM=FB,LRECL=80,BLKSIZE=5600),\n//             SPACE=(TRK,(10,10))\n//*\n//CREATEB  EXEC PGM=IEBUPDTE,PARM=NEW\n//SYSPRINT DD  SYSOUT=*\n//SYSUT2   DD  DSN=&&ASSRCO2,UNIT=SYSDA,DISP=(,PASS),\n//             DCB=(DSORG=PS,RECFM=FB,LRECL=80,BLKSIZE=5600),\n//             SPACE=(TRK,(300,100))\n//*\n//UPDATEA  EXEC PGM=IEBUPDTE\n//SYSPRINT DD  SYSOUT=*\n//SYSUT1   DD  DSN=&&ASSRCO1,DISP=(OLD,DELETE)\n//SYSUT2   DD  DSN=&&ASSRCM1,UNIT=SYSDA,DISP=(,PASS),\n//             DCB=(DSORG=PS,RECFM=FB,LRECL=80,BLKSIZE=5600),\n//             SPACE=(TRK,(10,10))\n//*\n//UPDATEB  EXEC PGM=IEBUPDTE\n//SYSPRINT DD  SYSOUT=*\n//SYSUT1   DD  DSN=&&ASSRCO2,DISP=(OLD,DELETE)\n//SYSUT2   DD  DSN=&&ASSRCM2,UNIT=SYSDA,DISP=(,PASS),\n//             DCB=(DSORG=PS,RECFM=FB,LRECL=80,BLKSIZE=5600),\n//             SPACE=(TRK,(300,100))\n//         PEND\n//*\n//         EXEC ASOURCE\n//*\n//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n//* STEP 1 - COPY SOURCE TO TEMPORARY DATASETS FOR SUBSEQUENT INSTALL.\n//*          (DO NOT MAKE CHANGES TO THE STATEMENTS BELOW!)\n//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n//*\n//CREATEA.SYSIN DD *\n./ ADD LIST=ALL\n         MACRO\n         ASSYSGEN\n*\n*        THIS IS THE FULL VERSION WITH EVERYTHING\n*\n         GBLB  &$ACCT              =1 => ACCOUNT DISCRIMINATION POSSIBL\n         GBLB  &$ALIGN             =0 -> NO BOUNDRY CHECK,=1 -> CHECKS\n*                     ==0: 360 ONLY(USED FOR 360 ONLY)\n*                     ==1:370 OR 360 ACTING AS 370'S\n         GBLB  &$ASMLVL            =0==>DOS,=1==>OS\n         GBLC  &$BATCH             LIMIT/DFLT: BATCH(DOS) - NOBATCH(OS)\n         GBLA  &$BLEN              SET TO BUFFER LENGTH IN BYTES\n         GBLC  &$BTCC(4)      BATCH CONTROL CARD ITEMS: SEE SETC'S    J\n         GBLA  &$BUFNO             THE NUMBER OF BUFFERS\n         GBLB  &$CMPRS             =0 NO CMPRS CODE, =1 CMPRS OPTION\n         GBLA  &$COMNT             >0 COMMENT CHECK (&$COMNT % REQ)\n         GBLB  &$DATARD            =0 SOURCE,DATA THRU SYSIN ONLY(WATFV\n*                                  =1 DATA MAY BE READ FROM FT05F001\n*                                  (I.E.- SINGLE JOB PROCESSING-PSU)\n         GBLB  &$DEBUG             0==>DEBUG MODE, 1==> PRODUCTION MODE\n         GBLB  &$DECSA             SHOULD ASSEMBLER PERMIT DECIMALS\n         GBLB  &$DECSM             DOES MACHINE HAVE DECIMALS\n         GBLB  &$DECK              =0 NO OBJ DECKS PUNCHED. =1 CAN DO\n         GBLA  &$DISKU             0 FOR NO DISK UTILITY\n*                                      1 FOR USER OPTION\n*                                      2 FOR ALWAYS DISK\n         GBLB  &$DMPAG             =1 BEGIN DUMP ON NEW PAGE, 0=> NO  J\n         GBLC  &$DSKUDV            FOR DOS DISKU ONLY\n         GBLA  &$ERNUM             # DIFFERENT ERROR MESSAGES\n         GBLB  &$EXINT             EXTENDED INTERPRETER 1 = YES 0 = NO\n         GBLB  &$FLOTA             SHOULD ASSEMBLER ALLOW FLOATING PT\n         GBLB  &$FLOTAX            SHOULD ASSEMBLER ALLOW EXTENDED FP'S\n         GBLB  &$FLOTE             =1==> WILL INTERPRET FLT,0==> (3\n         GBLB  &$FLOTEX            =1==> WILL INTERPRET EX FP'S,0==> NO\n         GBLB  &$FLOTM             =1==> MACHINE HAS FLTING PT,0==>NO\n         GBLB  &$FLOTMX            =1==> MACHINE HAS FX FP'S,0==> NO\n         GBLA  &$FREE,&$FREEMN     DEFAULT FREE=, MINIMUM FREE= (80A) J\n         GBLC  &$GENDAT            GENERATATION DATE FOR THIS ASSIST\n         GBLB  &$HASPBT            =1 HASP AUTOBATCH CODE SUPPORTED   J\n         GBLB  &$HEXO                  =0=> NO HEXO =1=> XHEXO ALLOWED\n         GBLB  &$HEXI                  =0=> NO HEXI =1=> XHEXI ALLOWED\n         GBLA  &$IDF,&$IMX         DRFAULT,MAXIMUM I=\n         GBLC  &$IOUNIT(8)         DIFFERENT DDNAMES USED IN ASSIST\n         GBLB  &$JRM               =1 FOR PSU LOCAL SPECIAL CODE: JRM\n         GBLB  &$KP26              =1 ALLOW KP=26 OR K&=29 OPTION\n*                                  =0 ALLOW ONLY 029 KEYPUNCH CARDS\n         GBLA  &$LDF,&$LMX         DEFAULT,MAX L= # LINES/PAGE\n         GBLB  &$MACOPC            =1 => ALLOW OPEN CODE COND ASMBL\n         GBLB  &$MACROG            =1 ==> ADD ASM G FEATURES TO ASM F\n         GBLB  &$MACROH            =1 ==> ADD SOME ASM H FEATURES TO F\n         GBLB  &$MACROV            OS/VS SUPPORT\n         GBLB  &$MACROS            MACRO/CONDITIONAL ASSEMBLY ALLOWED\n*              **NOTE** BASIC MACRO FACILITY IS ASSEMBLER F COMPATIBLE.\n         GBLB  &$MACSLB            =1 ==> MACRO LIBRARY ALLOWED\n         GBLC  &$MCHNE             SO CAN CHANGE SYSTEM TYPE\n         GBLA  &$MMACTR            LOCAL ACTR INITIAL VALUE DEFAULT\n         GBLA  &$MMNEST            MACRO NEST LIMIT DEFAULT\n         GBLA  &$MMSTMG            GLOBAL MACRO STMT LIMIT DEFAULT\n         GBLA  &$MODEL             MODEL NUMBER OF 360 BEING RUN ON\n         GBLB  &$OBJIN             =0 CANNOT READ OBJECT DECK. =1 CAN\n         GBLA  &$OPTMS             OPTIMIZE - 0==> MEMORY, 9==> SPEED\n         GBLB  &$PAGE              =0 NO PAGE COINT/CONTROL CODE EXISTS\n*                                  =1 PAGE CONTROL&OPTIONS ALLOWED\n         GBLA  &$PDF,&$PMX         DEFAULT,MAX P= # PAGES LIMIT\n         GBLA  &$PDDF,&$PDMX       DEFAULT,MAX PD= # PAGES SAVED FOR DP\n         GBLB  &$PRIVOP            =0==>NO PRIV OPS, =1==> PRIV OPS OK\n         GBLA  &$PRTSIZ            MAX # CHARS IN PRINT LINE FOR ASM  J\n         GBLB  &$PUNCH             =0 WE DON'T ACTUALLY HAVE CARD PUNCH\n*                                  =1 REAL PUNCH EXISTS, POSSIBLE USED\n         GBLA  &$PXDF,&$PXMX       DEFAULT,MAX PX= PAGES FOR EXECUTION\n         GBLB  &$P370              =1 WILL INTERPRET PRIVELEGED S/370\n         GBLB  &$P370A             SHOULD ASSEMBLER PERMIT PRIV S/370'S\n         GBLA  &$RDF,&$RMX         DEFAULT,MAX R= TOTAL # RECORDS\n         GBLA  &$RDDF,&$RDMX       DEFAULT,MAX RD= RECORDS FOR DUMP\n         GBLA  &$RECORD            =0,1=> NO $TIRC RECREM, =2=> $TIRC\n         GBLB  &$RECOVR            (ONLY USED FOR &$RECORD=2).\n*              =0 => R= DOES NOT OVERRIDE $TIRC VALUE, =1 => IT DOES.\n*              (AT PSU, OUTPUT CAN GO TO BAT FILES - DON'T COUNT).\n         GBLB  &$RELOC             =0==> NO RELOCATION CODE GENERATED\n         GBLA  &$REPL              0=> NO REPL,1=> LIMITED,2=> FULL\n         GBLA  &$RXDF,&$RXMX       DEFAULT,MAX RD= RECORDS FOR EXECUTE\n         GBLB  &$SPECIO            SPECIAL ROUTINES EXIST(TYPE=$IS+)\n         GBLA  &$SYHASH            SIZE OF INITIAL PTR TABLE FOR SYMOPS\n         GBLC  &$SYSTEM            SYSTEM BEGIN RUN - DOS,PCP,MFT,MVT\n         GBLA  &$S370              =0==> NO S/370 INSTR INTERPRETED\n*                                  =1==> S/370 INSTR INTERPRETED ON 370\n*                                  =2==> S/370 INSTR INTERPRETED ON 360\n         GBLB  &$S370A             SHOULD ASSEMBLER PERMIT SYSTEM 370'S\n         GBLC  &$TDF,&$TMX         DEFAULT,MAX T= TOTAL TIME FOR RUN\n         GBLC  &$TDDF,&$TDMX       DEFAULT,MAX TD= TIME FOR DUMP\n         GBLA  &$TIMER             0==> NO TIMING AT ALL\n*              1==> STIMER/TTIMER ONLY. =2==> LOCAL TIMER FOR TIMREM\n         GBLC  &$TXDF,&$TXMX       DEFAULT,MAX TX= TIME FOR EXECUTION\n         GBLC  &$VERSLV            VERSION #.LEVEL #\n         GBLB  &$XIOS              =0==>NO XIO MACROS,=1==>XIO MACROS\n         GBLB  &$XREF              CONTROL GENERATION OF XREF FACILITYA\n*        =1 FULL XREF, =0 NO XREF AT ALL                              A\n         GBLA  &$XREFDF(3)         DEFAULT VALUES FOR FLAGS           A\n*        &$XREFDF(1)=0       NO XREF(OTHERS =3MEANS COMPRESSED LISTINGA\n*        &$XREFDF(2)=3       COLLECT MODIFY AND FETCH DEFN            A\n*        &$XREFDF(3)=3       COLLECT REFERENCES MODIFY/FETCH          A\n         GBLA  &$XREF#B            NUMBER OF SLOTS FOR XREF BLKS      A\n         GBLB  &$XXIOS             =0 ALLOWS XGET AND XPUT\n         GBLB  &X$DDMOR            =0 ALLOWS USER OWN DDNAMES\n**       GLOBAL SET VARIABLES - INTERNAL TYPE -                       *\n         GBLC  &DEBUG              DEBUG NUMBER FOR TESTING AVDEBUG\n         GBLC  &ID                 IDENT GENERATION CONTROL\n         GBLC  &TRACE              SPECIFIES FORM OF TRACE-SNAP,*,NO\n         SPACE 1\n&$ALIGN  SETB  1                   NEED BOUNDRY CHECKING\n&$BATCH  SETC  'BATCH'             DEFAULT VALUE IS BATCH RUNS\n&$BLEN   SETA  3520                SET FOR HALF TRACK BUFFERS\n&$BLEN   SETA  4*(&$BLEN/4)        ROUND BLEN DOWN TO FULLWORD MULTIPLE\n&$BTCC(1) SETC '$'            CONTROL CHARACTER FOR BATCH CARDS       J\n&$BTCC(2) SETC 'JOB'          JOB BEGINNING INDICATOR                 J\n&$BTCC(3) SETC 'ENTRY'        BEGIN DATA CARD: SET = '' IF NONE NEEDEDJ\n&$BTCC(4) SETC 'STOP'         TERMINATOR CARD: SET = '' IF NONE       J\n&$BUFNO  SETA  2                   SET FOR 4 BUFFERS\n&$CMPRS  SETB  (1)                 ALLOW CMPRS OPTION\n&$COMNT  SETA  80                  REQUIRE 80% COMMENTS, IF COMNT OPT\n&$DATARD SETB  (1)                 ALLOW SINGLE JOB/TWO RDRS\n&$DEBUG  SETB  (1)                 FOR QUICK RUN, KILL GENERATION\n&$DECK   SETB  (1)                 ALLOW OBJECT DECKS TO BE PUNCHED\n&$DECSA  SETB  (1)                 ASSEMBLER WILL ACCEPT DECIMAL INSTS\n&$DECSM  SETB  (1)                 PSU 360/67 HAS DECIMAL INSTRUCTIONS\n&$DISKU  SETA  1                   SET FOR USER OPTION ON DISK UTILITY\n&$DMPAG  SETB  1                   ASSUME COMPLETION DUMP ON NEW PAGE J\n&$DSKUDV SETC  '2314'              SET DEVICE FOR DOS DISKU CODE\n&$EXINT  SETB  1                   BIG OS GETS NEW INTERPRETER ***\n&$FLOTA  SETB  (1)                 ASSEMBLER ALLOWS FLOATING POINT\n&$FLOTAX SETB  (1)                 ASSEMBLER ALLOWS EXTENDED F. P.\n&$FLOTE  SETB  (1)                 WE WILL EXECUTE FLTINGS,IF POSSIBLE\n&$FLOTEX SETB  (1)                 WILL EXECUTE EXTENDED F. P., IF POSS\n&$FLOTM  SETB  (1)                 PSU 360/67 HAS FLOATING POINT\n&$FLOTMX SETB  (1)                 PSU 360/67 HASN'T GOT EXTENDED F. P.\n&$FREE   SETA  4096                NORMALLY RETURN 4K TO OS/360\n&$FREEMN SETA  2048                MINIMUM ALLOWED FREE=;  *****NOTE  J\n*              IF YOU HAVE 80A ABEND'S OFTEN, RAISE THIS AS NEEDED*** J\n&$GENDAT SETC  '04/28/75'          CURRENT GENERATION DATE            J\n&$HASPBT SETB  1                   HASP BATCH ON\n&$HEXI   SETB  (1)                     XHEXI ALLOWED THIS ASSEMBLY\n&$HEXO   SETB  (1)                     XHEXO ALLOWED\n&$IDF    SETA  150000              100 SECS ON /67\n&$IMX    SETA  150000              100 SECS ON /67\n&$KP26   SETB  (1)                 ALLOW 026 KEYPUNCH\n&$LDF    SETA  63                  DEFAULT 63 LINES/PAGE\n&$LMX    SETA  63                  MAXIMUM OF 63 LINES/PAGE\n*              MACRO SETS: ONLY SIGNIFICANT IF &$MACROS=1.\n&$MACOPC SETB  1                   OPEN CODE, COND ASSMBL WORKS\n&$MACROS SETB  1                   ALLOW MACROS TO BE PROC ESSED\n&$MACROG SETB  0                   NO ASM G CODE ***NOT SUPPORTED YET**\n&$MACROH SETB  0                   NO ASM H CODE ***NOT SUPPORTED YET**\n&$MACROV SETB  0                   NO OS/VS ASSEMBLER SUPPORT YET\n&$MACSLB SETB  1                   ALLOW MACRO LIBRARY\n&$MCHNE  SETC  '370'               MACHINE GENERATED ON\n&$MMACTR SETA  200                 DEFAULT ACTR VALUE = 200\n&$MMNEST SETA  15                  DEFAULT LIMIT OF 15 DEEP IN MACS\n&$MMSTMG SETA  4000                DEFAULT MAXIMUM TOTAL 4000 MAC STMTS\n         SPACE 1\n&$MODEL  SETA  65                  DEFAULT MODEL NUMBER\n&$OBJIN  SETB  (1)                 ALLOW OBJECT DECKS TO BE READ\n&$OPTMS  SETA  9                   WE WANT SPEED OPTIMIZATION\n&$PAGE   SETB  (1)                 ALLOW ALL PAGE CONTROL OPTIONS\n&$PDF    SETA  10                  TEN TOTAL PAGES\n&$PMX    SETA  25                  MAXIMUM POSSIBLE OF 25 TOTAL\n&$PDDF   SETA  1                   NORMAL DUMP-JUST FIRST PAGE\n&$PDMX   SETA  5                   MAXIMUM OF 5 PAGES FOR THE DUMP\n&$PRIVOP SETB  1                   ALLOW ALL PRIVILEGED OPERATIONS\n&$PRTSIZ SETA  121                 LIMIT TO 121 CHARS AS DEFAULT LIM  J\n&$PUNCH  SETB  (1)                 A REAL PUNCH EXISTS\n&$PXDF   SETA  5                   MAXIMUM PAGES FOR EXECUTION\n&$PXMX   SETA  5                   MAXIMUM MAXIMUM FOR EXECUTION\n&$RDF    SETA  100000              DEFAULT RECORDS FOR EXEC\n&$RMX    SETA  100000              MAX EXECUTION RECORDS\n&$RDDF   SETA  25                  DEFAULT RECORDS FOR A DUMP\n&$RDMX   SETA  5000                MAXIMUM RECORDS FOR DUMP\n&$RECORD SETA  1                   SHOW $TIRC RECREM CAN'T BE USED\n&$RELOC  SETB  (1)                 NEED RELOC SINCE WE HAVE REPL\n&$REPL   SETA  2                   COMPLETE REPLACEMENT ALLOWED\n&$RXDF   SETA  10000               EXECUTION RECORDS\n&$RXMX   SETA  10000               EXECUTION RECORDS\n&$SYSTEM SETC  'OS-MVT'            SYSTEM IS OS OPTION MVT\n&$S370   SETA  2                   PSY WANTS S/370'S ON 360/67\n&$S370A  SETB  (1)                 ASSEMBLER ALLOWS S/370'S\n&$TDDF   SETC  '.1'                DEFAULT TIME FOR DUMP\n&$TDF    SETC  '100'               SECONDS FOR EXECUTION\n&$TMX    SETC  '200'               MAX POSSIBLE SECONDS FOR EXECUTION\n&$TDMX   SETC  '10'                MAXIMUM TIME FOR A DUMP\n&$TIMER  SETA  1                   SHOW WE WANT OVERALL TIMING DONE\n&$TXDF   SETC  '100'               MAX TIME FOR EXECUTION\n&$TXMX   SETC  '200'               MAXIMUM MAXIMUM FOR EXECUTION\n&$VERSLV SETC  '4.0/A'             CURRENT ASSIST VERSION             J\n&$XIOS   SETB  (1)                 WE'RE ALLOWING XIO MACROS\n&$XREF   SETB  1                   ALLOW CROSS REFERENCE\n&$XREFDF(1) SETA  0                NO XREF                            A\n&$XREFDF(2) SETA  3                COLLECT ALL MOD/FETCH DEFN         A\n&$XREFDF(3) SETA  3                COLLECT ALL MOD/FETCH REFERENCES   A\n&$XREF#B SETA  10                  ALLOCATE 10 SLOTS/BLOCK            A\n&$ASMLVL SETB  ('&$SYSTEM'(1,2) EQ 'OS')     SET LEVEL OF ASSEMBLER\n&$FLOTE  SETB  (&$FLOTE AND &$FLOTM)         KILL GEN IF NO FLOATS\n&$FLOTEX SETB  (&$FLOTEX AND &$FLOTMX) KILL GEN IF NO EXTENDED FLOATS\n&$HASPBT SETB  (&$HASPBT AND &$ASMLVL)  ELIM HASP IF NOT OS SYSTEM    J\n&$MACSLB SETB  (&$MACSLB AND &$MACROS)  REMOVE LIBRARY IF NO MACROS   J\n&$RELOC  SETB  (&$RELOC OR (&$REPL NE 0))  IF REPL, MAKE SURE RELOC   J\n&ID      SETC  'NO'                SET NO ID FOR TIME BEING\n         AIF   (&$DEBUG).EQU1      LEAVE NO ID IF PRODUCTION PROG\n&ID      SETC  '*'                 DEBUG==> GENERATE ID'S AT ENTRIES\n.EQU1    ANOP\n         AIF   (&$ASMLVL).OSGEN    SKIP IF OS GENERATION\n&$BATCH  SETC  'BATCH'             DEFAULT FOR DOS IS BATCH\n&$IOUNIT(1) SETC  'SYSIPT'         SET DOS MAIN INPUT\n&$IOUNIT(2)  SETC  'SYSRDR'        SET DOS SECONDARY INPUT\n&$IOUNIT(3)  SETC  'SYSLST'        SET DOS PRINTER\n&$IOUNIT(4) SETC 'SYSPCH'          SET DOS PUNCH\n&$IOUNIT(5) SETC 'SYS001'          SET TO 'HRB' SCRATCH DEVICE\n&$BUFNO  SETA  2                   FOR DOS GEN INSURE ONLY 2 BUFFERS\n&$DSKUDV SETC  '2314'              SET DOS DISK DRIVE TYPE\n         AGO   .OSGEN1\n.OSGEN   ANOP\n&$BATCH  SETC  'NOBATCH'           DEFAULT FOR OS IS NOBATCH\n&$IOUNIT(1)  SETC  'SYSIN'         SET OS PRIMARY INPUT\n&$IOUNIT(2)  SETC  'FT05F001'      SET OS SECONDARY INPUT\n&$IOUNIT(3)  SETC  'FT06F001'      SET OS PRINTER\n&$IOUNIT(4)  SETC  'FT07F001'      SET OS PUNCH\n&$IOUNIT(5)  SETC  'FT08F001'      SET OS DISK INTERMEDIATE\n&$IOUNIT(6)  SETC  'SYSLIB'        SET OS MACRO LIBRARY\n.OSGEN1  ANOP\n         MEND\n//CREATEB.SYSIN DD *\n./ ADD\n         PRINT ON,NOGEN\n         TITLE 'ASSIST VERSION 4.0/A - MARCH 1975'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*        PENNSYLVANIA STATE UNIVERSITY COMPUTER SCIENCE DEPARTMENT    *\n*        PROJECT SUPERVISION: GRAHAM CAMPBELL                         *\n*        PROGRAM DESIGN, CODING, DOCUMENTATION: JOHN R. MASHEY.       *\n*        DOS/360 CONVERSION, $SPIE, XXXXSPIE: SCOTT A. SMITH.         *\n*                                                                     *\n*        PROGRAM WRITTEN BEGINNING SUMMER 1969.                       *\n*        FIRST BATCH USAGE:  SPRING TERM, 1970.                       *\n*        FIRST USAGE ON STUDENT REMOTE TERMINALS: FALL TERM, 1970.    *\n*        FIRST DISTRIBUTION TO OTHER INSTALLATIONS: SUMMER 1971.      *\n*        FIRST DISTRIBUTION (DOS/360 VERSION) : FALL 1971.            *\n*                                                                     *\n*        DISK UTILITY (DISKU) FACILITY (XXXXDK##, UTOPRS CHANGES):    *\n*              RICHARD FORD, PAUL WEISSER - SPRING 1972.              *\n*        XHEXI, XHEXO ADDITIONS: ALAN ARTZ - SPRING 1972.             *\n*        S/370 INSTRUCTIONS: CHARLES JOHNSON - SPRING 1972.           *\n*        MACRO PROCESSOR - GRAHAM CAMPBELL - SPRING, SUMMER 1972.     *\n*        LIBRARY MACRO FETCH AND PROCESSING: RICHARD FORD, SUMMER 1972*\n*        IMPROVED MACRO PROCESSOR, OPEN CODE ALAN ARTZ,               *\n*              JOHN STERNBERGH - FALL,WINTER 1972 - 73                *\n*        DOS DISK UTILITY - RICHARD FORD - WINTER 1973                *\n*        EXTENDED I/O PACKAGE, XGET - XPUT - RICHARD FOWLER -         *\n*              FALL 1972                                              *\n*        CROSS-REFERENCE- ALAN ARTZ, ALICE FELTE, RICH LONG -         *\n*              SPRING, SUMMER 1973.                                   *\n*        EXTENDED INTERPRETER- MARK DALTON, JOHN STERNBERGH, RICH     *\n*              LONG - SPRING, SUMMER, FALL 1973.                      *\n*        DOCUMENTATION UPDATE- GLENN FADNER - FALL 1973, WINTER 1974. *\n*                                                                     *\n*         MANY THANKS TO SHELLY GEARHART FOR HELP WITH DISTRIBUTION   *\n*         MATERIALS.  SPECIAL THANKS TO KAREN HOERTER (PSU CC PROGRAM *\n*         LIBRARIAN)FOR HANDLING OF ASSIST TAPE DISTRIBUTION, AND FOR *\n*         FACING MASSIVE PILE OF TAPES WITHOUT MOANING (TOO MUCH).    *\n* * * * * NOTES ON DISTRIBUTION VERSIONS OF ASSIST  * * * * * * * * * *\n*                                                                     *\n*        VERSION   DATE AVAIL.     COMMENTS                           *\n*                                                                     *\n*        1.2/A1    09/01/71        ORIGINAL DISTRIBUTION VERSION      *\n*                                                                     *\n*        1.3/A     04/01/72        CONTAINS DOS/360 CODE, FIXES BUGS  *\n*                                                                     *\n*        2.0/A     08/72(APPROX)   MACRO PROCESSOR, S/370, DISK OPTION*\n*                                  FOR INTERMEDIATE STORAGE IF NEEDED.*\n*              PREPARED BY: RICHARD FORD + JRM                        *\n*                                                                     *\n*        2.1/A     02/01/73        OPEN CODE, DOS DISKU, XGET - XPUT  *\n*              PREPARED BY: ALAN ARTZ, ALICE FELTE + JRM              *\n*                                                                     *\n*        3.0/A     08/01/73        XREF, HASP AUTOBATCH, OVERLAYS     *\n*              PREPARED BY: RICH LONG + JRM                           *\n*                                                                     *\n*        3.0/B     03/01/74        EXTENDED INTERPRETER,DOCUMENTATION *\n*                                    UPDATES.                         *\n*              PREPARED BY: MARK DALTON, GLENN FADNER, RICH LONG      *\n*                                                                     *\n*        4.0/A     3/01/75         CLEANS UP 3.0/B                    *\n*                                  EXTENDED INTERP., ETC              *\n*           PREPARED BY THOMAS MINSKER                                *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         TITLE '*** XCHAR MACRO - SAFE RIGHT-END SUBSTRING MACRO ***'\n         MACRO\n         XCHAR &STRING,&NUM\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: XCHAR      RETURN SAFE RIGHT-END SUBSTRING OF A STRING.  *\n.*                                     JOHN R. MASHEY-JULY 1969-360/67*\n.*       THIS MACRO RETURNS IN &XXCHAR THE &NUM CHARACTERS TAKEN FROM *\n.*       THE RIGHT END OF THE CHARACTER STRING &STRING, WITHOUT       *\n.*       BLOWING UP IF THERE ARE LESS THAN &NUM CHARS IN &STRING.     *\n.*       THIS MACRO IS USED BY XSAVE,XRETURN, AND XSRNR               *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         GBLC  &XXCHAR             RETURN RESULT IN THIS\n         AIF   (&NUM GT K'&STRING).XGA       SKIP IF HE WANTS MORE\n&XXCHAR  SETC  '&STRING'(K'&STRING+1-&NUM,&NUM)        SCOOP RIGHT AMT\n         MEXIT\n.XGA     ANOP\n&XXCHAR  SETC  '&STRING'           STRING SMALLER-USE WHOLE THING\n         MEND\n         TITLE 'XDECI MACRO - EXTENDED DECIMAL INPUT CONVERSION'\n         MACRO\n&LABEL   XDECI &REG,&ADDRESS\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*-->MACRO: XDECI      EXTENDED DECIMAL INPUT CONVERSION              *\n.*--> MACRO: XDECI      EXTENDED DECIMAL INPUT CONVERSION * * * * * * *\n.*             EXTENDED DECIMAL INPUT MACRO - ENABLES PROGRAMS        *\n.*       WRITTEN FOR ASSIST TO BE RUN UNDER OS/360 DIRECTLY.          *\n.*       USES MODULE XXXXDECI TO SCAN DECIMAL STRING BEGINNING AT     *\n.*       &ADDRESS, CONVERT ITS VALUE INTO REGISTER &REG, AND SET      *\n.*       REGISTER R1 AS A SCAN POINTER TO THE DELIMITER FOLLOWING THE *\n.*       STRING OF DECIMAL DIGITS.  THE CONDITION CODE IS SET BY THE  *\n.*       VALUE IN &REG, UNLESS AN ERROR OCCURRS, IN WHICH CASE CC=3.  *\n.*       SEE ASSIST USER MANUAL FOR USAGE INSTRUCTIONS.               *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         LCLC  &XLABL              FOR CREATION OF LABEL\n&XLABL   SETC  'XX&SYSNDX.E'       CREATE UNIQUE LABEL\n         CNOP  2,4  .              LINE UP ON BOUNDARY\n&LABEL   STM   14,1,&XLABL  .      SAVE LINKAGE REGS\n         LA    0,&ADDRESS .        BEGINNING @ FOR SCANNING\n         L     15,&XLABL-4  .      GET ADCON FOR CONVERSION\n         BALR  14,15 .             CALL ROUTINE, PT WITH R14\n         DC    V(XXXXDECI) .       ADCON FOR CONVERSION ROUTINE\n&XLABL   DS    5F .                REGS 14,15,0,1, VALUE FOR &REG\n         LM    14,1,4(14) .        RELOAD REGS\n         BO    *+8 .               BRANCH IF &REG SHOULDN'T CHANGE\n         L     &REG,&XLABL+16  .   GET VALUE FOR &REG\n         AIF   (T'&REG EQ 'N' AND '&REG' NE '1').XXEXIT SKIP IF SAFE\n         L     1,&XLABL+12  .      USER MAY HAVE REG=1, LOAD FOR SAFE\n.XXEXIT  MEND\n         TITLE 'XDECO MACRO - EXTENDED DECIMAL OUTPUT CONVERSION'\n         MACRO\n&LABEL   XDECO &REG,&ADDRESS\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: XDECO      EXTENDED DECIMAL OUTPUT CONVERSION            *\n.*       USES MODULE XXXXDECO TO CONVERT VALUE IN REGISTER &REG TO    *\n.*       AN EDITED 12-BYTE FIELD, WITH SIGN, AT LOCATION &ADDRESS.    *\n.*             EXTENDED DECIMAL OUTPUT MACRO - ENABLES PROGRAMS       *\n.*       WRITTEN FOR ASSIST TO BE RUN UNDER OS/360 DIRECTLY.          *\n.*       SEE ASSIST USER MANUAL FOR USAGE INSTRUCTIONS.               *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         LCLC  &XLABL              FOR CREATION OF UNIQUE LABEL\n&XLABL   SETC  'XX&SYSNDX.D'       CREATE UNIQUE LABEL\n         CNOP  2,4 .               LINE UP ON RIGHT BOUNDARY\n&LABEL   STM   14,0,&XLABL  .      STORE LINKAGE REGS\n         ST    &REG,&XLABL+12  .   SAVE VALUE TO BE CONVERTED\n         LA    0,&ADDRESS .        OBTAIN @ OPERAND FILED\n         L     15,&XLABL-4  .      GET ADCON FOR CONVERSION PROG\n         BALR  14,15 .             CALL XXXXDECO, PT R14\n         DC    V(XXXXDECO) .       ADCON FOR CONVERSION PROG\n&XLABL   DS    4F .                REGS 14,15,0, REG TO BE CONVERTED\n         LM    14,0,4(14) .        RELOAD LINKAGE REGISTERS\n         MEND\n         TITLE 'MACRO-->XHEXI EXTENDED HEXADECIMAL CONVERSION'\n         MACRO\n&NAME    XHEXI &REG,&ADDR\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*-->MACRO: XHEXI  HEXADECIMAL INPUT CONVERSION MACRO.                *\n.*                                WRITTEN BY ALAN ARTZ 4/17/72        *\n.*       THIS MACRO TAKES THE VALUE STARTING AT THE ADDRESS GIVEN BY  *\n.*  &ADDR AND CONVERTS IT AND PUTS THE HEXADECIMAL VALUE IN &REG.     *\n.*  IF THERE ARE MORE THAN 8 DIGITS, R1 POINTS TO THE 9TH AND THE     *\n.*  FIRST 8 ARE CONVERTED.  IF THERE IS A NON-BLANK, NON-HEX DIGIT    *\n.*  FOUND, R1 POINTS TO THAT CHARACTER AND THE CC=3, OTHERWISE CC SET *\n.*  BY VALUE IN REG.                                                  *\n.*                                                                    *\n.*       CALLS MODULE XXXXHEXI TO DO THE ACTUAL CONVERSIONS           *\n.*                                                                    *\n.*       SEE ASSIST USER MANUAL FOR USAGE INSTRUCTIONS.               *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         LCLC  &LABEL\n&LABEL   SETC  'XX&SYSNDX.H'      UNIQUE LABEL\n&NAME    STM   14,0,&LABEL  .     SAVE REGISTERS\n         ST    &REG,&LABEL+12  .  REGISTER STORE INCASE OF OVERFLOW CND\n         LA    0,&ADDR  .         GET STRING TO BE CONVERTED\n         CNOP  2,4  .             GET PROPER ALIGNMENT\n         L     15,&LABEL-4  .     ADDRESS OF XXXXHEXI\n         BALR  14,15  .           GO TO APPROPRIATE PLACE\n         DC    V(XXXXHEXI)  .     VCON OF ROUTINE\n&LABEL   DS    4F  .              STORAGE FOR REGISTERS\n         LM    14,0,4(14)  .      RESTORE REGISTERS\n         L     &REG,&LABEL+12  .  GET CONVERTED NUMBER\n         MEND\n         TITLE 'MACRO-->XHEXO EXTENDED HEXADECIMAL CONVERSION'\n         MACRO\n&NAME    XHEXO &REG,&ADDR\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*-->MACRO: XHEXO  HEXADECIMAL OUTPUT CONVERSION MACRO                *\n.*                                WRITTEN BY ALAN ARTZ 4/17/72        *\n.*       THIS MACRO TAKES THE VALUE IN &REG AND CONVERTS IT TO        *\n.*  PRINTABLE FORM.                                                   *\n.*       IT PUTS THE CONVERTED VALUE IN AN EIGHT BYTE AREA STARTING AT*\n.* THE ADDRESS GIVEN IN &ADDR.                                        *\n.*       THE CC AND REGISTERS ARE LEFT UNCHANGED.                     *\n.*                                                                    *\n.*       CALLS MODULE XXXXHEXO TO DO THE ACTUAL CONVERSIONS.          *\n.*                                                                    *\n.*       SEE ASSIST USER MANUAL FOR USAGE INSTRUCTIONS.               *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         LCLC  &LABEL\n&LABEL   SETC  'XX&SYSNDX.H'      UNIQUE LABEL\n&NAME    DS    0H\n         STM   14,0,&LABEL  .     SAVE REGISTERS\n         ST    &REG,&LABEL+12  .  SAVE &REG\n         LA    0,&ADDR   .        PASS REGISTER TO XXXXHEXO\n         CNOP  2,4  .             GET PROPER ALIGNMENT\n         L     15,&LABEL-4  .     ADDRESS OF XXXXHEXO\n         BALR  14,15  .           CALL XXXXHEXO\n         DC    V(XXXXHEXO)\n&LABEL   DS    4F  .              STORAGE FOR REGISTERS\n         LM    14,0,&LABEL  .     RESTORE REGISTERS\n         MEND\n         TITLE '*** XIDENT MACRO - CREATE ID FOR XSAVE MACRO ***'\n         MACRO\n         XIDENT &ID,&LABEL,&XCSECT,&PRIVATE\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: XIDENT     IDENTIFY ENTRY POINT FOR XSAVE,$SAVE.         *\n.*       MACRO USED BY XSAVE TO PRODUCE ID AT AN ENTRY POINT.  WILL   *\n.*       USE THE FIRST NON-NULL OPERAND PASSED TO IT AS THE ID.       *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         LCLA  &I,&J                LOCAL COUNTERS\n&I       SETA  1                    INITIALIZE\n         AIF   ('&ID' NE '*').XIDINC         SKIP IF EXPLICIT ID FIELD\n.XILOOP  ANOP\n&I       SETA  &I+1                 INCREMENT TO NEXT ONE\n         AIF   ('&SYSLIST(&I)' EQ '').XILOOP SKIP BACK IF THIS IS NULL\n.XIDINC  ANOP\n&J       SETA  6+((K'&SYSLIST(&I)+1)/2)*2   GET BRANCH LENGTH\n         B     &J.(,15) .           BRANCH AROUND ID\n&J       SETA  &J-5                 GET ACTUAL LENGTH OF ID\n         DC    AL1(&J),CL&J'&SYSLIST(&I)'\n         MEND\n         TITLE ' *** XIONR-INNER MACRO FOR XREAD,XPRNT,XPNCH ***'\n         MACRO\n&XLABEL  XIONR &XNAME,&XNUM,&XAREA,&XDEFT\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: XIONR      INNER MACRO-$READ,$PNCH,$PRNT,$SORC           *\n.*                                 ALSO XGET,XPUT,$GET,AND$PUT        *\n.*                                 JOHN R. MASHEY - FEB 1970 - V.4.0  *\n.*       XIONR IS USED BY XIOPAK MACROS XREAD,XPRNT,XPNCH TO SET UP   *\n.*       THE REQUIRED CODE FOR CALLING THEIR RESPECTIVE SUBROUTINES.  *\n.*       *** ARGUMENTS ***                                            *\n.*       XNAME     THE NAME OF THE I/O ROUTINE TO BE CALLED.          *\n.*       XNUM      THE LENGTH OF XAREA TO BE PRINTED,PUNCHED,ETC.     *\n.*       XAREA     THE AREA ON WHICH I/O OPERATION TO BE PERFORMED.   *\n.*             MAY BE SPECIFIED BY (0) OR (R0).                       *\n.*       XDEFT     DEFAULT VALUE OF XNUM TO BE USED, IF IT IS OMITTED *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         AIF   (T'&XAREA EQ 'O').XERR1       PRODUCE MNOTE\n&XLABEL  STM   14,0,XX&SYSNDX.R+4 .    SAVE REGS WHICH WILL BE CHANGED\n         AIF   (T'&XNUM EQ 'O').XN1    SKIP NEXT CHECK IF OMITTED\n         AIF   ('&XNUM'(1,1) NE '(' OR '&XNUM'(K'&XNUM,1) NE ')').XN1\n         STH   &XNUM,XX&SYSNDX.R+16 .       STORE LENGTH\n.XN1     AIF   ('&XAREA' EQ '(0)' OR '&XAREA' EQ '(R0)').XNOLA\n.XN2     LA    0,&XAREA\n.XNOLA   L     15,XX&SYSNDX.R  .   GET BRANCH ADDRESS\n         CNOP  2,4  .              ADJUST FOR RIGHT ALIGNEMNT\n         BALR  14,15 .             CALL ROUTINE, R14==> CONTROL BLOCK\nXX&SYSNDX.R DC V(&XNAME)  .        ROUTINE ADDRESS\n         DS    3F .                SAVE SPACE FOR REGS 14-0\n         AIF   ('&XNUM' EQ '').XDFT         SKIP IF DEFAULT SHOULD BE\n         DC    AL2(&XNUM) .        LENGTH OF AREA\n         AGO   .XDS                SKIP\n.XDFT    DC    AL2(&XDEFT) .       DEFAULT LENGTH USED\n.XDS     LM    14,0,4(14) .        RESTORE REGS. CON CODE ALREADY DONE\n         MEXIT\n.XERR1   MNOTE 0,'**XIONR- AREA ADDRESS OMITTED-GENERATION CANCELLED'\n         MEND\n         TITLE '*** XLOOK MACRO - LOOK UP ELEMENT IN LIST ***'\n         MACRO\n         XLOOK &ARG1,&ARGL\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: XLOOK      FIND POSITION OF ELEMENT IN LIST.             *\n.*                                 JOHN R. MASHEY - FEB 1970 - V.4.0  *\n.*       MACRO TO FIND AND RETURN POSTION OF ARGUMENT IN A SUBLIST.   *\n.*       &ARG1 ARGUMENT TO BE SEARCHED FOR                            *\n.*       &ARGL LIST OF ARGUMENTS FOR &ARG1 TO BE CHECKED FOR IN       *\n.*       &XXLOOK   THE FIRST POSITION IN &ARGL IN WHICH &ARG1 IS      *\n.*       FOUND, IF ANY.  IF &ARG1 IS NOT IN &ARGL, &XXLOOK = 0.       *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         GBLA  &XXLOOK             FOR RETURN OF INDEX VALUE\n&XXLOOK  SETA  1                   INITIALIZE THE COUNTER\n.XLA     AIF   (&XXLOOK GT N'&ARGL).XLB     IF GT,QUIT,NOT FOUND\n         AIF   ('&ARG1' EQ '&ARGL(&XXLOOK)').XXEXIT   IF FOUND,RETURN\n&XXLOOK  SETA  &XXLOOK+1           INCREMENT COUNTER\n         AGO   .XLA                GO BACK FOR NEXT CHECK\n.XLB     ANOP\n&XXLOOK  SETA  0                   NOT FOUND, SET TO 0 TO SHOW THIS\n.XXEXIT  MEND\n         TITLE ' *** XMUSE - INNER MACRO FOR XSAVE-MULTIPLE USING ***'\n         MACRO\n         XMUSE &BR,&AD\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: XMUSE      BASE REGISTER SETUP MACRO FOR XSAVE           *\n.*                                 JOHN R. MASHEY - FEB 1970 - V.4.0  *\n.*       THIS MACRO IS CALLED BY XSAVE TO HANDLE BR AND AD OPERANDS,  *\n.*       AND PRODUCE APPROPRIATE USINGS.  &BR AND &AD ARE FROM XSAVE. *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         LCLA  &I,&N               LOCAL COUNTERS\n         LCLC  &B(4),&V            BASE REGS, USING NAME\n&N       SETA  N'&BR               GET NUMBER WHERE HANDY\n&V       SETC  '*'                 NORMAL USE\n         AIF   (&N LE 4).XNOKA     MAKE SURE NOT TOO MANY BASES\n&N       SETA  4                   IDIOT USER HAD >4 BASES, IGNORE EXTR\n         MNOTE 4,'**XMUSE- MORE THAN 4 BASE REGS-EXTRAS IGNORED'\n.XNOKA   AIF   ('&AD' EQ '').X1LOOP         SKIP IF NORMAL SITUATION\n.*             USED IF AD PARAMATER WAS SPECIFIED IN XSAVE MACRO.     *\n         CNOP 0,4\n         B     *+8 .               SKIP AROUND ADDRESS CONSTANT\n         DC    A(&AD)       .      ADDRESS CONSTANT FOR AD=PARAMETER\n         L     &BR(1),*-4 .        LOAD ADCON INTO RIGHT REGISTER\n&V       SETC  '&AD'               CHANGE NAME FOR USING 1ST OPERND\n.*             NORMAL SECTION OF CODE FOR GENERATING USING.           *\n.X1LOOP  ANOP\n&I       SETA  &I+1      INCREMENT COUNTER TO BASE REG\n&B(&I)   SETC  ',&BR(&I)'          GET I'TH BASE REGISTER\n         AIF   (&I LT &N).X1LOOP   CONTINUE UNTIL ALL BASE REGS DONE\n         DROP  15 .                CLEAN UP USING SITUATION\n         USING &V&B(1)&B(2)&B(3)&B(4)\n         MEND\n         TITLE '*** XRETURN MACRO - EXTENDED RETURN MACRO ***'\n         MACRO\n&LABEL   XRETURN &RGS=(14-12),&SA=,&RC=,&RP=,&T=,&TR=*,&REEN=\n.** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: XRETURN    GENERAL RETURN MACRO, OS LINKAGE              *\n.*                                 JOHN R. MASHEY - FEB 1970 - V.4.0  *\n.*       EXTENDED RETURN MACRO - SEE PSU CC WRITEUP - XSAVE/XRETURN   *\n.*       FOR EXPLANATION AND USE OF OPERANDS.                         *\n.*       USES MACROS: FREEMAIN,XCHAR,XSRNR                            *\n.** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         GBLB  &XRETUST            =0 TRACE GENERATION OK, =1 NO TRACE\n         GBLC  &XSAVE,&XXCHAR      STD SAVE AREA NAME, XCHAR VARIABLE\n         LCLA  &I                  LOCAL COUNTER\n         LCLB  &RCA,&RCB           FOR CONTROL OF RETURN CODE GENER\n.*                                                                    *\n.*       GENERATE LABEL IF THERE IS ONE, GENERATE TRACE CODE IF IT    *\n.*       IF DESIRED, AND SET UP LCLB VARIABLES TO DESCRIBE RETURN     *\n.*       CODE CONDITIONS. GENERATE LR IF NEEDED FOR RC OPTION.        *\n.*                                                                    *\n         SPACE 1\n         AIF   (T'&LABEL EQ 'O').XNOLB       SKIP IF NO LABEL USED\n&LABEL   DS    0H .                DEFINE LABEL\n.XNOLB   AIF   ('&TR' EQ 'NO' OR &XRETUST).XNORT       SKIP IF NO TRACE\n         XSRTR &TR,&LABEL,EXITED   GET TRACE GENERATED\n.XNORT   ANOP\n&RCA     SETB  (T'&RC EQ 'O')      TRUE IF WHOLE THING OMITTED\n&RCB     SETB  (1)                 SET THIS WAY FOR NEXT TEST\n         AIF   (&RCA).XNRCB        SKIP IMMEDIATELY IF OMITTED\n&RCB     SETB  ('&RC'(1,1) NE '(' OR '&RC'(K'&RC,1) NE ')')  NOT RG TYP\n         AIF   (&RCB).XNRCB       SKIP IF NOT REGISTER TYPE\n         XCHAR &RC,3               GET LAST 3 CHARS\n         AIF   ('&XXCHAR' EQ '15)').XNRCB    SKIP IF ALREADY IN 15\n         LR    15,&RC .            LOAD RETURN CODE FROM DESIRED REG\n.XNRCB   AIF   (T'&REEN EQ 'O').XNORM        SKIP IF NOT REENTRANT\n.*                                                                    *\n.*       REENTRANT RETURN CODE GENERATION - OBTAIN ADDRESS AND LENGTH *\n.*       OF AREA FROM WHERE XSAVE PUT THEM,DO FREEMAIN,FIXUP REGS.    *\n.*                                                                    *\n         AIF   ('&TR' EQ 'NO' OR &XRETUST).XGOK        MAKE SURE REENT\n         MNOTE 0,'**XRETURN- TR OPTION IMPLIES NON-REENTRANT CODE'\n.XGOK    L     13,4(13) .          GET OLD SA POINTER BACK\n         STM   15,1,16(13) .       SAVE REGS FROM FREEMAIN CRUNCHING\n         L     1,8(13) .           GET ADDRESS OF AREA BACK\n*        FREEMAIN R,LV=8*((&REEN+79)/8),A=(1)          FREE STORAGE\n         FREEMAIN R,LV=8*((&REEN+79)/8),A=(1)          FREE STORAGE\n         LM    15,1,16(13) .       RESTORE THE REGS\n         AGO   .XNORM1             GO TO PROCESS REGISTER RESTORATION\n.XNORM   AIF   ('&SA' EQ 'NO').XNORM1        SKIP RESTORATION IF UNUSED\n.*                                                                    *\n.*       REGISTER RESTORATION CODE - RESTORE REGS FROM CALLER'S       *\n.*       SAVE AREA,DEPENDING ON RETURN CODE AND FUNCTION OPTIONS.     *\n.*                                                                    *\n         L     13,4(13) .          RESTORE PREVIOUS SAVE AREA POINT\n.XNORM1  AIF   ('&RGS' EQ 'NO').XNORM2A     SKIP IF NO REGS NEEDED\n         AIF   ('&RGS' NE '(14-12)' OR NOT &RCB).XNORM2\n         LM    14,12,12(13) .      STANDARD REGISTER RESTORATION\n         AGO   .XNORM2A            CONTINUE\n.XNORM2  ANOP\n&I       SETA  &I+1                INCREMENT COUNTER\n         XSRNR L,&RGS(&I),&RCB     HAVE RESTORE CODE GENRATED\n         AIF   (&I LT N'&RGS).XNORM2        LOOP UNTIL DONE\n.*                                                                    *\n.*       RETURN CODE(15) AND RETURN PAST(14) CODE GENERATION.         *\n.*                                                                    *\n.XNORM2A AIF   (&RCA OR NOT &RCB).XNORM3    SKIP IF NOT LA TYPE RC=\n         LA    15,&RC .            PUT RETURN CODE IN 15\n.XNORM3  AIF   ('&T' NE '*').XNORM4          SEE IF MVI WANTED\n         MVI   12(13),X'FF' .      SHOW WE HAVE RETURNED\n.XNORM4  AIF   (T'&RP EQ 'O').XNORP          SKIP IF RP NOT USED\n         B     &RP.(14) .          RETURN GIVEN NUMBER PAST 14\n         AGO   .XNORM5\n.XNORP   BR    14 .                RETURN NORMALLY TO CALLER\n.*                                                                    *\n.*       SAVE AREA GENERATION - IF A SAVE AREA SHOULD BE CREATED,     *\n.*       USE EITHER ONE SPECIFIED BY MACRO,OR ELSE STANDARD ONE.      *\n.*                                                                    *\n.XNORM5  AIF   (T'&SA EQ 'O' OR '&SA' EQ 'NO').XEXIT   SKIP IF NO SAV5\n         AIF   ('&SA' EQ '*').XSASTD         IF *,USE STANDARD SAVE\n&SA      DC    18F'0' .            SAVE AREA,NAMED BY MACRO\n         AGO   .XEXIT\n.XSASTD  ANOP\n&XSAVE   DC    18F'0' .            SAVE AREA,USING GENERATED NAME\n.XEXIT   SPACE 1\n         MEND\n         TITLE '*** XSAVE - EXTENDED SAVE MACRO ***'\n         MACRO\n&LABEL   XSAVE &RGS=(14-12),&BR=12,&SA=*,&ID=*,&TR=*,&REEN=,&OPT=,&AD=\n.** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: XSAVE      EXTENDED SAVE MACRO - OS LINKAGE.             *\n.*                                 JOHN R. MASHEY - FEB 1970 - V.4.0  *\n.*       EXTENDED SAVE MACRO - SEE PSU CC WRITEUP - XSAVE/XRETURN     *\n.*       FOR DESCRIPTION OF ARGUMENTS FOR THIS MACRO                  *\n.*       USES MACROS: GETMAIN,XCHAR,XIDENT,XLOOK,XMUSE,XSRNT,XSRTR    *\n.** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         GBLA  &XXLOOK             RETURN VARIABLE FROM XLOOK MACRO\n         GBLB  &XSAVEST            =0 TRACE GEN OK, =1 NO TRACE DONE\n         GBLC  &XSAVE,&XCSECT,&XXCHAR  STD NAME,CSECT NAME,XCHAR VAR\n         LCLA  &I                  LOCAL COUNTER\n         LCLB  &XNSECT             FLAG FOR NEW CSECT\n         LCLC  &B1,&BT             1ST BASE,LAST 2 CHARS OF 1ST BASE\n&B1      SETC  '&BR(1)'            GET FIRST OR ONLY BASE IN EASIER NAM\n         XCHAR &B1,2               GET LAST 2 CHARS OF BASE REG\n&BT      SETC  '&XXCHAR'           GET LAST 2 CHARACTERS\n&XNSECT  SETB  ('&SYSECT' NE '&XCSECT')      NOTE IF NEW CSECT NEEDED\n&XCSECT  SETC  '&SYSECT'           SET TO SYSECT, FOR NORMAL USE\n.*                                                                    *\n.*       CHECK OPT FIELD - GENERATE TITLE AND/OR ENTRY OR CSECT       *\n.*       STATEMENTS, DEPENDING ON CONTENTS OF OPT FIELD, IF USED.     *\n.*                                                                    *\n         AIF   (T'&OPT EQ 'O').XNOPS         SKIP IF OPT UNUSED\n         XLOOK TITLE,&OPT           WAS TITLE OPTION USED\n         AIF   (&XXLOOK EQ 0).XNTITL         SKIP IF TITLE NOT USED\n         AIF   (N'&OPT EQ 1).XNOPS SKIP IF TITLE ONLY\n         TITLE '*** &LABEL ***'\n.XNTITL  XLOOK ENTRY,&OPT           WAS ENTRY USED\n         AIF   (&XXLOOK EQ 0).XTRCS         SKIP IF NOT USED\n         AIF   ('&LABEL' EQ '').XENTE        SKIP TO ERR IF NO LABEL\n         ENTRY &LABEL  .            NOTE XSAVE ENTRY OPTION\n         AGO   .XNOPS\n.XENTE   MNOTE 4,'**XSAVE- OPT=ENTRY USED WITHOUT LABEL-OPTION IGNORED'\n         AGO   .XNOPS\n.XTRCS   XLOOK CSECT,&OPT           CHECK FOR CSECT OPTION\n         AIF   (&XXLOOK EQ 0).XTRCS1        SKIP IF OPTION NOT THERE\n&LABEL   CSECT\n&XCSECT  SETC  '&LABEL'            SET THIS TO SHOW NEW CSECT\n&XNSECT  SETB  (1)                  NOTE THAT NEW CSECT IS NEEDED\n         AGO   .XENT1               SKIP OVER &LABEL DEFN\n.XTRCS1  MNOTE 0,'**XSAVE- UNKNOWN OPT=&OPT- IGNORED'\n.*                                                                    *\n.*       CREATE STATMENT LABEL IF ANY. IF IDENTIFIER REQUESTED,USE    *\n.*       SPECIFIED IDENTIFIER,STATEMENT LABEL,OR CSECT NAME IN XIDENT *\n.*       TO GENERATE CORRECT IDENTIFIER WITH BRANCH AROUND IT.        *\n.*                                                                    *\n.XNOPS   SPACE 2\n&LABEL   DS    0H .                DEFINE LABEL,MAKE SURE ALIGNED\n.XENT1   USING *,15 .              FOR TEMPORARY ADDRESSIBILITY\n         AIF   ('&SA' EQ '*' OR '&SA' EQ 'NO').XCHKS1 SKIP IF NO CHANGE\n&XSAVE   SETC  '&SA'                EXPLICIT NEW SAVE AREA NAME\n         AGO   .XSAOK\n.XCHKS1  AIF   ('&XSAVE' NE '').XCHKS2       SKIP IF NOT NULL\n&XSAVE   SETC  '$PR#&SYSNDX'        SET UP DEFAULT SAVE AREA NAME\n         AGO   .XSAOK\n.XCHKS2  AIF   (NOT &XNSECT).XSAOK SKIP IF NEW SAVE NOT NEEDED\n&XSAVE   SETC  '&XCSECT'(1,3).'#&SYSNDX'     DEFAULT SAVE AREA NAME\n.*                                                                    *\n.XSAOK   AIF   ('&ID' EQ 'NO').XID3 SKIP IF NO ID WANTED\n         XIDENT &ID,&LABEL,&XCSECT,$PRIVATE CALL TO SET UP IDENT\n.*                                                                    *\n.*       IF TR OPTION IN EFFECT, CALL XSRTR TO GENERATE RIGHT CODE,   *\n.*       THEN HAVE XSRNR GENERATE CODE TO SAVE RANGES OF REGISTERS    *\n.*                                                                    *\n.XID3    AIF   (&XSAVEST OR '&TR' EQ 'NO').XNOTR       SKIP IF NO TRACE\n         XSRTR &TR,&LABEL,ENTERED  GET TRACE GENERATED\n.XNOTR   AIF   ('&RGS' NE '(14-12)').XSRCAL SKIP IF NOT STANDARD\n         STM   14,12,12(13) .      SAVE STANDARD REGISTER SET\n         AGO   .XCHK13\n.XSRCAL  AIF   ('&RGS' EQ 'NO').XCHK13       SKIP IF NO REGS SAVED\n&I       SETA  1                   INITIALIZE COUNTER\n.XSETUP  XSRNR ST,&RGS(&I)         CALL XSRNR WITH EACH REG SET\n&I       SETA  &I+1                INCREMENT TO NEXT REGS SET\n         AIF   (&I LE N'&RGS).XSETUP         CONTINUE PROCESSING RGS\n.XCHK13  AIF   ('&BT' NE '13').XNORM1       NOT REG 13,DO NORMALLY\n.*                                                                    *\n.*       REGISTER 13 DOUBLE USAGE - THIS SECTION GENERATES CODE TO    *\n.*       USE REGISTER 13 BOTH AS A BASE AND AS THE SAVE AREA POINTER. *\n.*                                                                    *\n         AIF   (T'&AD EQ 'O').XU2  SKIP TO NORMAL IF &AD OMITTED\n         LR    14,13 .             SAVE @ OLD SAVE AREA BEFORE SETTING\n         XMUSE &BR,&AD             HAVE ADCON SET UP\n         ST    13,8(14) .          SAVE NEW POINTER INTO OLD SAVEAREA\n         ST    14,4(13) .          SAVE OLD POINTER INTO NEW AREA\n         AGO   .XEND1              GO FINISH UP\n.XU2     CNOP  0,4\n         ST    13,&XSAVE+4 .       SAVE OLD SA POINTER INTO NEW AREA\n         BAL   13,&XSAVE+72 .      SET UP 13, BRANCH AROUND SA\n         XMUSE &BR                 SET UP WHATEVER USING REQUIRED\n&XSAVE   DC    18F'0'  .           SAVE A\u00a2EA\n.XU3     L     15,&XSAVE+4 .       GET OLD SA POINTER BACK TO SET LINKS\n         ST    13,8(15) .          STORE NEW POINTER IN OLD AREA\n         AGO   .XEND1              CHECK NUMBER OF BR'S,GET LA'S SET UP\n.*                                                                    *\n.XNORM1  AIF   (T'&REEN EQ 'O').XNORM2       SKIP OVER REENTRANT\n.*                                                                    *\n.*       REENTRANT ENTRY CODE GENERATION - THIS GENERATES CODE TO     *\n.*       ACQUIRE SPACE FOR SAVEAREA(72 BYTES) + AS MUCH MORE SPACE    *\n.*       AS IS SPECIFIED IN REEN PARAMATER, IF USED.                  *\n.*                                                                    *\n         AIF   ('&TR' EQ 'NO' OR &XSAVEST).XGOK        MAKE SURE REENT\n         MNOTE 0,'**XSAVE- USE OF TR OPTION IMPLIES NON-REENTRANT CODE'\n.XGOK    ANOP\n         GETMAIN R,LV=8*((&REEN+79)/8) .GET CORE ROUNDED TO DBLWRD\n         ST    13,4(1) .           STORE OLD POINTER IN NEW AREA\n         ST    1,8(13) .           STORE (EW POINTER IN OLD AREA\n         LR    &B1,1 .             SAVE VALUE OF NEW SAVE POINTER\n         LM    0,1,20(13) .        RESTORE PREVIOUS VALUES OF REGS\n         LR    13,&B1 .            POINT 13 TO NEW SAVE AREA\n         AGO   .XNEWBS             GO GENERATE NEW BALR,USING\n.*                                                                    *\n.*       NORMAL,NON-REENTRANT ENTRY CODE SECTION.                     *\n.*                                                                    *\n.XNORM2  AIF   ('&SA' EQ 'NO').XNEWBS        SKIP IF NO SAVE AREA\n         ST    13,&XSAVE+4 .       SAVE OLD POINTER IN NEW AREA\n         AIF   ('&BT' NE '15').XSN15         SKIP IF NOT 15\n         LA    13,&XSAVE .         GET ADDRESS OF NEW SAVE AREA\n         L     &B1,&XSAVE+4 .      GET OLD SAVE POINTER BACK\n         AGO   .XSOLD              GO SAVE NEW POINTER\n.XSN15   LR    &B1,13 .            MOVE OLD POINTER OVER\n         LA    13,&XSAVE    .      ADDRESS OF NEW SAVE AREA\n.XSOLD   ST    13,8(&B1) .         SAVE NEW POINTER IN OLD AREA\n.*             SET UP BALR, LA'S IF REQUIRED, AND USING STATEMENT.    *\n.XNEWBS  AIF   ('&BT' NE '15' OR N'&BR GT 1).XSET2  SKIP IF 15\n         AIF   ('&REEN' EQ '' AND '&SA' EQ 'NO' AND '&AD' EQ '').XEND2\n.XSET2   AIF   (T'&AD NE 'O').XSET3          SKIP BALR IF ADCON USED\n         BALR  &B1,0 .             SET UP NEW BASE REGISTER\n.XSET3   XMUSE &BR,&AD             SET UP USINGS, ADCON IF NEEDED\n.XEND1   AIF   (N'&BR EQ 1).XEND2  IF ONLY 1 BASE,DON'T CALL XMUSE\n&I       SETA  2                    INITIALIZE\n.XA2A    LA    &BR(&I),4095 .       LOAD IN ADDRESS\n         LA    &BR(&I),1(&BR(&I),&BR(&I-1))  .   SET USING VALUES\n&I       SETA  &I+1                 INCREMENT TO NEXT BASE\n         AIF   (&I LE N'&BR AND &I LE 4).XA2A         LOOP FOR # BASES\n.XEND2   SPACE 1\n         MEND\n         TITLE '*** XSNAP MACRO DEFINITION ***'\n         MACRO\n&XLABEL  XSNAP &T=PR,&LABEL=,&STORAGE=,&IF=\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: XSNAP      EXTENDED SNAP MACRO-DEBUGGING-DUMPING.        *\n.*                                 JOHN R. MASHEY - FEB 1970 - V.4.0  *\n.*       XSNAP     IS USED FOR STORING,PRINTING OF REGISTERS AND ANY  *\n.*       OTHER ADDRESSABLE AREAS. XSNAP HARMS NO REGISTERS,CAN BE USED*\n.*       IN ANY NUMBER OF CSECTS IN 1 ASSEMBLY,AND PRINTS REGISTERS   *\n.*       EXACTLY AS THEY ARE WHEN THE XSNAP IS CALLED.  XSNAP         *\n.*       ACTION MAY BE MADE CONDITIONAL EITHER AT ASSEMBLY TIME OR    *\n.*       DURING EXECUTE TIME.  SEE WRITEUP FOR OPERAND DESCRIPTION.   *\n.*       USES MACROS: XLOOK                                           *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         GBLA  &XXLOOK             XLOOK RETURN VALUE\n         GBLB  &XSNAPST            GENERATION STATUS,ON=0,OFF=1\n         LCLA  &I,&K,&L,&N         LOCAL COUNTERS\n         LCLB  &XP,&XF             PRINT REGS AND PRINT FLOATING REGS\n         LCLC  &NAM,&INST,&A(5)\n.*                                                                    *\n.*       CHECK FOR XSNAPS BEING CANCELLED. CREATE LABEL IF NEEDED.    *\n.*                                                                    *\n         AIF   ('&T(3)' NE '').XGOGEN  SKIP  SKIP IF NONCANCELLABLE\n         AIF   (NOT &XSNAPST).XGOGEN   GENERATE IF STATUS=ON\n         AIF   (T'&XLABEL EQ 'O').XXEXIT    SKIP IF NOTHING TO GEN\n&XLABEL  DS    0H  .               LABEL USED ON NULLIFIED XSNAP\n         MEXIT\n.XGOGEN  SPACE 1\n&NAM     SETC  'XX&SYSNDX'         SET UP MOST OF NAME FOR LABELS\n&N       SETA  (N'&STORAGE/2)*2    GET ROUNDED NUMBER OF OPERANDS\n&XLABEL  STM   0,15,&NAM.B  .      SAVE ALL REGISTERS\n.*                                                                    *\n.*       IF OPTION - IF IF OPTION IS USED AND HAS CORRECT ARGUMENTS,  *\n.*       GENERATE A CLI, C, OR CR INSTRUCTION TO PERFORM APPROPRIATE  *\n.*       TEST,DEPENDING ON THE KIND OF IF ARGUMENTS . NEGATE THE      *\n.*       CONDITION AND CREATE THE RIGHT EXTENDED MNEMONIC BRANCH      *\n.*       SO THAT THE XSNAP WILL BE SKIPPED IF THE STATED CONDTION IS  *\n.*       NOT MET.  GENERATE USER'S OWN OPCODE IF HE SUPPLIED ONE.     *\n.*                                                                    *\n         AIF   (T'&IF EQ 'O').XNOIF          SKIP IF IF NOT REQUESTED\n         AIF   (N'&IF GE 3).XOKIF  SKIP IF ENOUGH ARGUMENTS\n         MNOTE 0,'**XSNAP- IF=&IF:IGNORED, LACKS REQUIRED 3-4 OPERANDS'\n         AGO   .XNOIF              CANCEL IF OPTION\n.XOKIF   XLOOK &IF(2),(H,L,E,O,P,M,Z,NH,NL,NE,NO,NP,NM,NZ)\n         AIF   (&XXLOOK GT 0).XOKIF1        SKIP IF OK RELATION\n         MNOTE 0,'**XSNAP- IF=&IF(2) UNKNOWN-CANCELLED'\n         AGO   .XNOIF              SKIP GENERATION OF THIS OPTION\n.XOKIF1  ANOP\n&INST    SETC  '&IF(4)'            GET INSTRUCTION\n         AIF   (N'&IF EQ 4).X      IF OPCODE SUPPLIED,SKIP CHECKING\n&INST    SETC  'CLI'               MAKE TENTATIVE INSTRUCTION SETUP\n         AIF   ('&IF(1)'(1,1) NE '(' OR '&IF(1)'(K'&IF(1),1) NE ')').X\n&INST    SETC  'C'                 PROBABLY WANTS RX TYPE\n         AIF   ('&IF(3)'(1,1) NE '(' OR '&IF(3)'(K'&IF(3),1) NE ')').X\n&INST    SETC  'CR'                2 REGS-USER WANTS RR TYPE\n.X       ANOP\n         &INST &IF(1),&IF(3) .     TEST\n&INST    SETC  'BN&IF(2)'          NEGATE COND, HOPE FOR 1 OF 1ST SET\n         AIF   (&XXLOOK LE 7).XOKIF2        SKIP IF NOW SET UP RIGHT\n&INST    SETC  'B'.'&IF(2)'(2,2)   REMOVE N FROM COND\n.XOKIF2  &INST &NAM.C\n.*                                                                    *\n.*             CREATE BRANCH AROUND THE SAVE AREA, FLAGS, ETC.        *\n.*                                                                    *\n.XNOIF   XLOOK &T(1),(PR,PRINT,FL,FLOAT,NO,NOREGS,ST,STORE)\n&I       SETA  72+4*&N             LENGTH FOR T=PRINT,NOREGS\n         AIF   (&XXLOOK LE 6).XBRNCH        SKIP IF ILLEGAL, OR PR,NO\n&I       SETA  68                  LENGTH FOR T=STORE\n.XBRNCH  B     &NAM.B+&I  .        BRANCH AROUND CONSTANTS\n.*                                                                    *\n.*       CREATE FRONT BRACKET CHARACTER STRING FOR REGISTER AREA      *\n.*                                                                    *\n         DS    0F  .               ALIGN LABEL ON FULLWORD\n&L       SETA  8                   SET &L FOR NO LABEL= LENGTH\n         AIF   (T'&LABEL EQ 'O').XNOLAB    IF NO LABEL,SKIP GENERATION\n&L       SETA  ((K'&LABEL+1)/4)*4  ROUND LENGTH UP TO FULLWORD\n         AIF   (&L LE 92).XLAB1    SKIP IF LABEL SMALL ENOUGH\n         MNOTE 0,'**XSNAP- LABEL= OPERAND TRUNCATED TO 92 CHARACTERS'\n&L       SETA  92                  TRUNCATE\n.XLAB1   DC    CL&L&LABEL\n         AGO   .XCHK1              SKIP GENRATION OF 1ST DELIMETER\n.XNOLAB  DC    CL8'&NAM.B'   .     FRONT BRACKET FOR REGISTER AREA\n.*                                                                    *\n.*             CREATE REGISTER AREA, BRACKETS, FLAG VALUES, AS NEEDED *\n.XCHK1   AIF   (&XXLOOK LT 7).XPRINT        SKIP IF PRINTED OUTPUT\n&NAM.B   DC    16F'-1',4C'X' .     REGISTER SAVE AREA, BRACKET X'S\n         AGO   .XIFLB              SKIP TO CHECK FOR IF LABEL\n.XPRINT  AIF   (&XXLOOK GT 0).XPRINT1       SKIP IF LEGAL T=\n         MNOTE 0,'**XSNAP- UNKNOWN T=&T: T=PR ASSUMED'\n.XPRINT1 ANOP\n&XP      SETB  (&XXLOOK LT 5)      SET TO 1 IF GP REGS NEEDED\n&XF      SETB  (&XXLOOK GT 2 AND &XP)       SET TO 1 IF T=FL OR T=FLOAT\n&XF      SETB  (&XF OR '&T(2)' EQ 'FL' OR '&T(2)' EQ 'FLOAT')\n&NAM.B   DC    16F'-1',B'&T(3)00&XF&XP',AL1(0,&L,&N/2),V(XXXXSNAP)\n.*                                                                    *\n.*       GENERATE ADDRESS LIST FOR STORAGE=, WITH EITHER WORDS FOR    *\n.*       STORING ADDRESSES OR A-TYPE ADDRESS CONSTANTS.               *\n.*                                                                    *\n         AIF   (T'&STORAGE EQ 'O').OKN      SKIP IF STORAGE= NOT USED\n&I       SETA  1                   INITIALIZE AS COUNTER\n         AIF   (&N EQ N'&STORAGE).LOOP1               SKIP IF LEGAL\n         MNOTE 0,'**XSNAP- ODD OPERAND IGNORED: STORAGE=&STORAGE(&N)'\n         AIF   (&N EQ 0).OKN\n.LOOP1   AIF   ('&STORAGE(&I)'(1,1) NE '*').LOOP1E\n&K       SETA  1                   INITIALIZE COUNTER\n.*             PROCESS ADDRESS REQUIRING LA - ST COMBINATION          *\n.LOOP1A  AIF   (&I+&K GT &N).LOOP1C         SKIP IF WE'RE AT END\n         AIF   ('&STORAGE(&I+&K)'(1,1) NE '*').LOOP1C SKIP IF NOT *\n&K       SETA  &K+1                INCREM # CONSECUTIVE * FORMS\n         AGO   .LOOP1A             GO CHECK NEXT\n.LOOP1C  DS    &K.A .              WORDS WHERE ADDRESSES WILL BE STORED\n&I       SETA  &I+&K               INCREMENT\n         AGO   .LOOP1G             GO FOR NEXT CHECK\n.*             PROCESS ADDRESS CONSTANT TYPE OF OPERAND               *\n.LOOP1E  DC    A(&STORAGE(&I))\n&I       SETA  &I+1                INCREMENT # OPERANDS DONE\n.LOOP1G  AIF   (&I LE &N).LOOP1    CONTINUE IF ANY MORE\n.*                                                                    *\n.*       CREATE LOAD ADDRESS - STORE PAIRS FOR EXPRESSION ADDRESSES   *\n.*                                                                    *\n&I       SETA  1\n.LOOP2   AIF   ('&STORAGE(&I)'(1,1) NE '*').LOOP2E    SKIP IF NOT *\n&L       SETA  K'&STORAGE(&I)-1    GET # CHARS IN EXPRESSION\n&K       SETA  1                   INIT COUNTER\n         AIF   (&L LE 40).LOOP2A   SKIP IF SMALL ENOUGH\n         MNOTE 8,'**XSNAP- STORAGE(&I) LONGER THAN 40 CHARACTERS'\n&L       SETA  40                  TRUNCATE AND HOPE IT GOES\n.*       BREAK EXPRESSION INTO 8 CHARACTER SECTIONS.                  *\n.LOOP2A  ANOP\n&A(&K)   SETC  '&STORAGE(&I)'(8*&K-6,8)      GET UP TO 8 NEXT CHARS\n&K       SETA  &K+1                INCRMENT COUNTER\n         AIF   (8*&K-8 LT &L).LOOP2A        LOOP UNTIL HAVE WHOLE OPR\n         LA    0,&A(1)&A(2)&A(3)&A(4)&A(5)\n         ST    0,&NAM.B+4*&I+68    STORE ADDRESS IN LIST\n.LOOP2C  ANOP\n&K       SETA  &K-1                DECRMENT SECTION TO NULL\n&A(&K)   SETC  ''                  NULL FOR NEXT USE\n         AIF   (&K GT 2).LOOP2C    CONTINUE UNTIL ALL BUT &A(1) NULL\n.LOOP2E  ANOP\n&I       SETA  &I+1                INCREMENT POSITION IN LIST\n         AIF   (&I LE &N).LOOP2    CONTINUE WITH LIST\n.*                                                                    *\n.*       CREATE CODE TO SET UP REGISTERS FOR XXXXSNAP,CALL IT,AND     *\n.*       RESTORE REGS ON RETURN.  XXXXSNAP RESTORES THE CONDTION CODE.*\n.*                                                                    *\n.OKN     LA    10,&NAM.B  .        GET ADDRESS OF REGISTER BLOCK\n         L     15,68(10) .         GET V(XXXXSNAP) FOR BRANCH\n         BALR  14,15 .             CALL XXXXSNAP,POINT 14 AT NEXT INST\n         LM    0,15,0(10) .        RELOAD THE REGISTERS\n.*             CREATE LABEL FOR IF OPTION, IF IT WAS USED.            *\n.XIFLB   AIF   ('&INST' EQ '').XEXIT         SKIP GEN OF IF LABEL\n&NAM.C   EQU   * .                 DEFINE LABEL FOR IF= BRANCH\n.XEXIT   SPACE 2\n.XXEXIT  MEND\n         SPACE 2\n         MACRO\n         XSET &XSNAP=\n         GBLB  &XSNAPST            =0 ==> XSNAPS, =1 ==> NONE\n.*             SIMPLE XSET, JUST FOR XSNAPS.\n&XSNAPST SETB  ('&XSNAP' EQ 'OFF')           1==> NO XSNAPS\n         MEND\n         TITLE '*** XSRNR - REGISTER LOAD-STORE FOR XRETURN-XSAVE ***'\n         MACRO\n         XSRNR &OP,&RG,&NO15\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: XSRNR      SAVE/RESTORE REGISTERS FOR XSAVE/XRETURN      *\n.*                                 JOHN R. MASHEY- FEB 1970 - V.4.0   *\n.*             THIS MACRO IS USED BY XSAVE AND XRETURN TO SET UP      *\n.*       REGISTER SAVING AND RESTORATION.                             *\n.*       &OP IS THE OPCODE TO BE USED.  I.E.  EITHER L  OR ST.        *\n.*       &RG  IS 1 OPERAND FROM THE &RGS OPERAND USED BY XSAVE AND    *\n.*             XRETURN.  IT IS EITHER 1 REGISTER, OR A PAIR OF REGS   *\n.*             SEPARATED BY A DASH.                                   *\n.*       &NO15   =0  STATES THAT A RETURN CODE IS CURRENTLY IN REG 15 *\n.*             AND SHOULD NOT BE DISTURBED, REGARDLESS OF HOW THE REGS*\n.*             ARE SPECIFIED.                                         *\n.*       USES MACROS: XCHAR                                           *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         GBLC  &XXCHAR             FOR COMMUNICATION WITH XCHAR\n         LCLA  &I\n         LCLC  &R1,&R2             1ST REG, 2ND REG, TEMPORARY\n         AIF   ('&RG' EQ 'NO').XXEXIT        DON'T GEN ANYTHING\n.*             SCAN FOR DASH-MEANING 2 REGISTERS.                     *\n.XSL1    ANOP\n&I       SETA  &I+1                INCREMENT FOR NEXT CHARACTER\n         AIF   ('&RG'(&I,1) EQ '-').XDASH    JUMP IF DASH FOUND\n         AIF   (&I LT K'&RG).XSL1  CONTINUE TO END OF OPERAND\n&R1      SETC  '&RG'               &RG IS 1 REGISTER BY ITSELF\n         AGO   .XSAA               GO TO NEXT DECISION POINT\n.*             FOUND DASH-NOW SEPARATE THE REGISTERS.                 *\n.XDASH   ANOP\n&R1      SETC  '&RG'(1,&I-1)       GET FIRST REGISTER\n         AIF   (&I EQ K'&RG).XSAA  DUMB USER - 1 REG FOLLOWED BY -\n&R2      SETC  '&RG'(&I+1,K'&RG-&I)         GET 2ND REGISTER\n.XSAA    XCHAR &R1,2               GET UP TO LAST 2 CHARS OF 1ST REG\n         AIF   ('&XXCHAR' NE '14' AND '&XXCHAR' NE '15').XNO1415\n&I       SETA  4*&XXCHAR-44         OFFSET FOR 14 OR 15\n         AIF   ('&R2' NE '').XS2RG SKIP IF 2 REGISTERS SPECIFIED\n         AIF   ('&XXCHAR' EQ '15' AND '&NO15' EQ '0').XXEXIT\n         &OP   &R1,&I.(13)  .       SAVE/RESTORE 1 REG\n         MEXIT\n.XS2RG   AIF   ('&NO15' EQ '0').XSN15        SKIP IF 15 SHOULDN'T BE\n         &OP.M &R1,&R2,&I.(13)  .  SAVE/RESTORE RANGE OF REGS\n         MEXIT\n.XSN15   AIF   ('&XXCHAR' EQ '15').XSN15A    SKIP IF 15 SPECIFIED\n         L     &R1,12(13)  .        RELOAD REG 14\n         XCHAR &R2,2                GET 2ND REG\n         AIF   ('&XXCHAR' EQ '15').XXEXIT    SKIP IF 15 SPECIFIED\n.XSN15A  LM    0,&R2,20(13)  .     RELOAD REST OF REGS\n         MEXIT\n.*             RESTORE 1 REG OR RANGE (NOT STARTING WITH 14 OR 15).   *\n.XNO1415 AIF   ('&R2' NE '').XLMSTM          JUMP IF MULTIPLE REGS\n         &OP   &R1,&R1*4+20(13)\n         MEXIT\n.XLMSTM  &OP.M &R1,&R2,&R1*4+20(13)\n.XXEXIT  MEND\n         TITLE 'DISK UTILITY I/O DOS/OS MACROS'\n         MACRO\n&LA      XDKCHK    &P1,&P2,&P3\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*-->MACRO: XDKCHK                                                    *\n.*       THIS MACRO WILL PRODUCE EITHER A DOS CHECK MACRO OR A        *\n.*       OS VERSION OF THE CHECK MACRO                                *\n.*                                                                    *\n.*       &P1 IS THE OS CHECK MACRO PARAMETER                          *\n.*       &P2 IS THE DOS CHECK MACRO PARAMETER                         *\n.*       &P3   IF 'DOS' AND &$ASMLVL IS DOS GEN DOS CHECK             *\n.*             OTHERWISE GEN &$ASMLVL TYPE CHECK                      *\n.*       USES INNER MACROS: CHECK (OS OR DOS VERSION)                 *\n.*                                                                    *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         GBLB  &$ASMLVL            OS/DOS LEVEL SWITCH\n&LA      DS    0H .                GEN LABEL AND BOUNDRY\n         AIF   (&$ASMLVL).XOSGEN   DETERMINE LEVEL\n         CHECK &P2 .               GEN DOS CHECK\n.XEND    MEXIT                     ALL DONE\n.XOSGEN  AIF   ('&P3' EQ 'DOS').XEND   IF NOT DEFAULT QUIT\n         CHECK &P1 .               GEN OS TYPE CHECK\n         MEND\n         SPACE 10\n         MACRO\n&LA      XDKPT &P1,&P2\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*-->MACRO: XDKPT                                                     *\n.*       THIS MACRO GENERATES EITHER A DOS POINTS MACRO CALL OR AN    *\n.*       OS POINT MACRO CALL                                          *\n.*                                                                    *\n.*       &P1 IS THE DCB OR DTF NAME                                   *\n.*       &P2 IS THE POINT WORD ADDRESS (OS ONLY)                      *\n.*                                                                    *\n.*       USES INNER MACROS: POINT (OS), POINTS (DOS)                  *\n.*                                                                    *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         GBLB  &$ASMLVL            GLOBAL ASMBLY LEVEL SWITCH\n         AIF   (&$ASMLVL).XDKP1    GENERATE CORRECT MACRO VERSION\n&LA      POINTS  &P1 .             DOS POINTS MACRO\n         MEXIT\n.XDKP1   ANOP\n&LA      POINT &P1,&P2 .           OS POINT MACRO\n         MEND\n         SPACE 10\n         MACRO\n&LA      XDKWT &P1,&P2,&P3\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*-->MACRO:XDKWT                                                      *\n.*       THIS MACRO WILL GENERATE A CORRECT WRITE MACRO CALL FOR      *\n.*       EITHER ASSEMBLY UNDER OS OR DOS.                             *\n.*                                                                    *\n.*       &P1 IS THE DECB NAME                                         *\n.*       &P2 IS THE FILE NAME UNDER DOS GEN AND THE DCB NAME FOR OS   *\n.*       &P3 IS THE AREA ADDRESS FOR BOTH LEVELS OF GENERATION        *\n.*                                                                    *\n.*       THIS MACRO GENERATES AN EXECUTE FORM MACRO FOR OS            *\n.*       ALL OPERANDS ARE ASSUMED CORRECT AS NO ERROR CHECKING        *\n.*       IS PERFORMED                                                 *\n.*                                                                    *\n.*       USES INNER MACROS: WRITE (OS FORM OR DOS FORM)               *\n.*                                                                    *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         GBLB  &$ASMLVL            GLOBAL SWITCH FOR ASSEMBLY LEVEL\n         AIF (NOT &$ASMLVL).XWT1   GEN CORRECT CALL BY LEVEL SWTCH\n&LA      WRITE &P1,SF,&P2,&P3,MF=E .        GENERATE AN OS MACRO CALL\n         MEXIT\n.XWT1    ANOP\n&LA      WRITE &P2,SQ,&P3 .        GENERATE A DOS MACRO CALL\n         MEND\n         SPACE 10\n         MACRO\n&LA      XDKRD &P1,&P2,&P3\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*-->MACRO: XDKRD                                                     *\n.*       THIS MACRO WILL GENERATE A CORRECT READ MACRO CALL FOR       *\n.*       EITHER ASSEMBLY UNDER OS OR DOS.                             *\n.*                                                                    *\n.*       &P1 IS THE DECB NAME                                         *\n.*       &P2 IS THE DCB ADDRESS FOR OS AND THE FILENAME UNDER DOS     *\n.*       &P3 IS THE AREA ADDRESS FOR BOTH LEVELS OF ASSEMBLY          *\n.*                                                                    *\n.*       THIS MACRO GENERATES AN EXECUTE FORM MACRO FOR OS            *\n.*       ALL OPERANDS ARE ASSUMED CORRECT AS NO ERROR CHECKING        *\n.*       IS PERFORMED                                                 *\n.*                                                                    *\n.*       USES INNER MACROS: READ (OS FORM OR DOS FORM)                *\n.*                                                                    *\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         GBLB  &$ASMLVL            GLOBAL SWITCH FOR ASSEMBLY LEVEL\n         AIF   (NOT &$ASMLVL).XRE1  GEN CORRECT CALL BY LEVEL SWTCH\n&LA      READ &P1,SF,&P2,&P3,MF=E .         GENERATE AN OS MACRO CALL\n         MEXIT\n.XRE1    ANOP\n&LA      READ  &P2,SQ,&P3 .                 GENERATE A DOS MACRO CALL\n         MEND\n         SPACE 10\n         TITLE 'XXDKDECB MACRO DEFINE CONTROL BLOCKS FOR DISK UTILITY'\n         MACRO\n&LABEL   XXDKDECB   &II\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: XXDKEDCB GENERATE TABLE OF DECBS FOR DISK UTILITY        *\n.*       THIS MACRO GENERATES A LINKED TABLE OF DECBS.                *\n.*       THE BUFFER ADDRESSES ARE PLACED IN THE DECB BY XXXXDKOP      *\n.*       USES MACRO: WRITE                                            *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         GBLB  &$ASMLVL            LEVEL OF ASSEMBLY SWITCH\n         LCLA  &I,&XXLNK           LCL COUNTER AND LINK FACTOR(OS/DOS)\n&I       SETA  &II                 INITIALIZE FOR UNIQUE NAMES\n         AIF   (&$ASMLVL).OS1      GENERATE CORRECT LINK FACTOR(OS/DOS)\n&XXLNK   SETA  8                   DOS LEVEL LINK FACTOR\n         AGO   .OS2\n.OS1     ANOP\n&XXLNK   SETA  24                  OS LEVEL LINK FACTOR\n.OS2     ANOP\n         SPACE 2\n&LABEL   DS    0F .                DEFINE LABEL, ALIGN TO FULLWORD\n         AIF   (&I EQ 1).DESTOP    BRANCH IF LAST ENTRY\n.DENEXT  DC    A(*+&XXLNK) .       LINK TO NEXT ENTRY\n         AIF   (&$ASMLVL).XXDK1    LEVEL DEPENDENT CODE GENERATION\n         DC    F'0'                FULLWORD FOR FAKE DECB\n         AGO   .XXDK2\n.XXDK1   WRITE XXDECB&I,SF,XXDKUDCB,0,MF=L    GENERATE A DECB\n.XXDK2   SPACE 2\n&I       SETA  &I-1                DECREMENT COUNTER\n         AIF   (&I GT 1).DENEXT    LOOP IF NOT LAST ENTRY\n.DESTOP  DC    A(&LABEL) .         LAST ENTRY, LINK TO TOP OF TABLE\n         AIF   (&$ASMLVL).XXDK3    LEVEL OF ASSEMBLY\n         DC    F'0'                FULLWORD FOR FAKE DECB\n         AGO   .XXDK4\n.XXDK3   WRITE XXDECB&I,SF,XXDKUDCB,0,MF=L    GENERATE A DECB\n.XXDK4   SPACE 5\n         MEND\n         SPACE 3\n         MACRO\n&L       $DISK &TYPE\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: $DISK     CALL DISK UTILITY                              *\n.*       $DISK CALLS MACRO XIONR TO SET UP A BRANCH TO A DISK         *\n.*       UTILITY ROUTINE.                                             *\n.*       USES MACRO: XIONR                                            *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n&L       XIONR XXXXDK&TYPE,0,(0)   CALL DISK UTILITY\n         MEND\n         TITLE '$ERCGN MACRO - GENERATE COMPLETION CODE BLOCK '\n         MACRO\n&LABEL   $ERCGN &CODE,&MSSG,&TYPE=SYSTEM\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: $ERCGN     GENERATE COMPLETION CODE BLOCK FOR XXXXSNAP   *\n.*       EACH CALL CREATES 1 ENTRY DESCRIBED BY DSECT ERCOMPCD.       *\n.*                                                                    *\n.*       &CODE     CHARACTER VALUE OF ERROR CODE NUMBER.              *\n.*       &MSSG     ERROR MESSAGE TO BE PRINTED                        *\n.*       &TYPE     TYPE OF COMPLETION CODE - SYSTEM, ASSIST, OR USER. *\n.*                                                                    *\n.*       *NOTE* IF &$OPTMS = 0, NO MESSAGE WILL BE GENED, ONLY CODE.  *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         GBLA  &$OPTMS             MEMORY OPTIMIZATION(0=SMALL)\n         LCLA  &I                  FOR LENGTH\n         LCLC  &T                  FOR TYPE\n&T       SETC  'ERC&TYPE'(1,7)     GET EQU FOR TYPE\n&I       SETA  K'&CODE+K'&MSSG-2   GET LENGTH OF TOTAL MESSAGE\n         AIF   (&$OPTMS GT 0).ERCA     SKIP IF NOT MINIMAL MEMORY\n&I       SETA  K'&CODE-1           GET LENGTH - 1 OF ERROR CODE\n&LABEL   DC    AL2(256*&I+&T),C'&CODE'\n         AGO   .XXEXIT             QUIT\n.ERCA    ANOP\n&LABEL   DC    AL2(256*&I+&T),C'&CODE ',C&MSSG\n.XXEXIT  MEND\n         SPACE 2                                                      S\n         MACRO                                                        A\n&LABEL   $MSG  &NMBR,&MSG,&FLAG=0                                     A\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: $MSG                  USED TO GENERATE LINE IN MSG TABLE *\n.*       &NMBR IS MESSAGE #   (3 DIGITS)                              *\n.*       &MSG IS QUOTED STRING OF MESSAGE                             *\n.*       &FLAG IS FLAG BYTE                                           *\n.* GENERATES:(LENGTH-1 OF MSG): #BYTES +3 FOR LENGTH OF MSG           *\n.*       (FLAG BYTE): 1 BYTE                                          *\n.*       (CHAR FORM OF NMBR): 3 BYTES                                 *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         GBLA  &$OPTMS             MEMORY OPTIMIZATION(0=SMALL)       S\n         LCLA  &K                  FOR K'&MSG                         S\n         AIF   (&$OPTMS EQ 0).SMALL   SKIP FOR MIMIMAL MEMORY         S\n&K       SETA  K'&MSG-2-1+3   MSG-QUOTES-1+LENGTH OF NMBR             S\n&LABEL   DC    AL1(&K,&FLAG),CL3'&NMBR',C&MSG                         S\n         MEXIT                                                        S\n.SMALL   ANOP                                                         S\n&LABEL   DC    AL1(2,&FLAG),CL3'&NMBR'                                S\n         MEND                                                         S\n         TITLE '*** CARD-PUNCH, LINE-PRINT MACROS - $PNCH,$PRNT ***'\n         MACRO\n&LABEL   $PNCH &XAREA,&XNUM,&OVER\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: $PNCH      PUNCH A CARD, BRANCH IF RECORD OVERFLOW       *\n.*       &XAREA,&XNUM-SEE XIONR MACRO FOR EXPLANATION, OR XPNCH WRTUP *\n.*       &OVER IS LABEL TO BE BRANCHED TO IF RECORDS EXCEED LIMIT.    *\n.*       USES MACROS: XIONR                                           *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n&LABEL   XIONR XXXXPNCH,&XNUM,&XAREA,80     HAVE CONTROL BLOCK SET\n         AIF   ('&OVER' EQ '').XXEXIT       SKIP IF OVER NOT SPEC\n         BL    &OVER   .           BRANCH IF EXCEEEDED RECORD COUNT\n.XXEXIT  MEND\n         SPACE 4\n         MACRO\n&LABEL   $PRNT &XAREA,&XNUM,&OVER\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: $PRNT      PRINT A LINE, BRANCH IF RECORD OVERFLOW.      *\n.*       &XAREA,&XNUM-SEE XIONR MACRO FOR EXPLANATION, OR XPRNT WRITUP*\n.*       &OVER IS LABEL TO BE BRANCHED TO IF RECORDS EXCEED LIMIT.    *\n.*       USES MACROS: XIONR                                           *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n&LABEL   XIONR XXXXPRNT,&XNUM,&XAREA,133    HAVE BLOCK SETUP\n         AIF   ('&OVER' EQ '').XXEXIT       SKIP IF NO LABEL\n         BL    &OVER    .          BRANCH IF EXCEEDED RECORDS\n.XXEXIT  MEND\n         TITLE '*** CARD-READ MACROS - $READ,$SORC ***'\n         MACRO\n&LABEL   $READ &XAREA,&XNUM,&EOF\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: $READ      READ CARD DURING EXECUTION, BRANCH IF EOF.    *\n.*       &XAREA,&XNUM-SEE XIONR MACRO FOR EXPLANATION, OR XREAD WRITUP*\n.*       &EOF      LABEL TO BE BRANCHED TO IF END-FILE OCCURS.        *\n.*       USES MACROS: XIONR                                           *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n&LABEL   XIONR XXXXREAD,&XNUM,&XAREA,80   SET UP CONTROL BLOCK\n         AIF   (T'&EOF EQ 'O').XXEXIT       SKIP IF NO LABEL\n         BL    &EOF   .            TAKE BRANCH IF END OF FILE\n.XXEXIT  MEND\n         SPACE 4\n         MACRO\n&LABEL   $SORC &XAREA,&XNUM,&EOF\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: $SORC      READ ASSEMBLER SOURCE CARD, BRANCH IF EOF.    *\n.*       &XAREA,&XNUM-SEE XIONR MACRO FOR EXPLANATION, OR XREAD WRITUP*\n.*       &EOF      LABEL TO BE BRANCHED TO IF END-FILE OCCURS.        *\n.*       USES MACROS: XIONR                                           *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n&LABEL   XIONR XXXXSORC,&XNUM,&XAREA,80  SET UP CONTROL BLOCK         *\n         AIF   (T'&EOF EQ 'O').XXEXIT       SKIP IF NO LABEL\n         BL    &EOF   .            BRANCH IF END-FILE\n.XXEXIT  MEND\n         TITLE 'SPECIAL XGET AND XPUT MACROES FOR ASSIST'\n         MACRO\n&XLABEL  $GET  &XAREA,&XNUM\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: $GET  INTERNAL XGET MACRO FOR ASSIST.                    *\n.*                                      RICHARD FOWLER NOV, 1972 V.5.0*\n.*       LIKE XGET BUT CONVERTS USER REG1 AND SETS ACTUAL R1 TO       *\n.*       ACTUAL ADDRESS.  ALSO CALLS XDDGET.                          *\n.*                                                                    *\n.*       EXECUTION ASSUMES USER REGISTER POINTS TO DDNAME.            *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n&XLABEL  L     R1,ECREG1           GET USER @ DDNAME\n         AR    R1,RMEM             GET REAL ADDRESS\n         XIONR XDDGET,&XNUM,&XAREA,80\n.XMEND   MEND\n         SPACE 5\n         MACRO\n&XLEBEL  $PUT  &XAREA,&XNUM\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: $PUT                                                     *\n.*       LIKE $GET, BUT CALLS XDDPUT.                                 *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n&XLEBEL  L     R1,ECREG1           GET USER @ DDNAME\n         AR    R1,RMEM             GET REAL ADDRESS\n         XIONR XDDPUT,&XNUM,&XAREA,133\n.XMEND   MEND\n         TITLE 'EXTENDED I/O MACROES XGET AND XPUT'\n         MACRO\n&XLABEL  XGET  &XAREA,&XNUM\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: XGET    GET RECORD OFF OF &DDNAME FILE                   *\n.*                                 RICHARD FOWLER AUG, 1972 V.5.0     *\n.*       MACRO FOR EASY READING OFF OF ANY DD FILE, READS &XNUM       *\n.*       CHARACTERS. CONDITION CODE SET TO 0 NORMALLY, OR TO 1 ON     *\n.*       END OF FILE. GENERATION CONTROLLED BY &XGETST.               *\n.*       EXECUTION ASSUMES REG 1 POINTS TO DD NAME                    *\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **\n         GBLB  &XGETST             GENERATION STATUS- 0=YES, 1=NO\n         AIF   (&XGETST).XNOGEN    IF SHOULDN'T GENERATE-SKIP CALL\n&XLABEL  XIONR XXXXGET,&XNUM,&XAREA,80   SET UP CONTROL BLOCK\n         MEXIT\n.XNOGEN  AIF   (T'&XLABEL EQ 'O').XXEXIT     GEN LABEL ONLY IF NEEDED\n&XLABEL  DS    0H .                LABEL FOR CANCELLED XGET\n.XXEXIT  MEND\n         SPACE 5\n         MACRO\n&XLABEL  XPUT  &XAREA,&XNUM\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: XPUT           PUT A RECORD ONTO FILE &DDNAME            *\n.*                                 RICHARD FOWLER AUG 1972 V.5.0      *\n.*       MACRO FOR EASY PRINTING ONTO ANY DD FILE. RECORD LENGTH=&XNUM*\n.*       IF PRINT FILE, FIRST CHARACTER IS USED AS CARRIAGE CONTROL   *\n.*       GENERATION CONTROLLED BY &XPUST                              *\n.*       EXECUTION ASSUMES REG 1 POINTS TO DD NAME                    *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         GBLB  &XPUTST             GENERATION STATUS- 0=YES, 1=NO\n         AIF   (&XPUTST).XNOGEN    IF SHOULDN'T GENERATE, SKIP CALL\n&XLABEL  XIONR XXXXPUT,&XNUM,&XAREA,133   SET UP CONTROL BLOCK\n         MEXIT\n.XNOGEN  AIF   (T'&XLABEL EQ 'O').XXEXIT     GEN LABEL ONLY IF NEEDED\n&XLABEL  DS    0H .                LABEL FOR CANCELLED XPUT\n.XXEXIT  MEND\n         TITLE 'MACRO---XGPSRCH--- INNER MACRO FOR XGPGN MACRO'\n         MACRO\n        XXGPSRCH &DIREC,&TIME\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*-->MACRO: XXGPSRCH  INNER MACRO FOR XGPGEN                          *\n.*     ARGUMENTS:                                                     *\n.*       &DIREC= G--> INPUT                                           *\n.*               P--> OUTPUT                                          *\n.*       &TIME=1 --> FIRST CALL, SETS UP EXTRA CODE AND ACTS AS &SYSND*\n.*             2--> SECOND CALL                                       *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         L     R3,X&DIREC.ELEM .   GET # LAST POINTER TO OPEN FILES\n         LA    R1,X&DIREC.PNTSRT . GET @ OF FIRST POINTER\n         LTR   R3,R3 .             ARE THERE ANY ELEMENTS?\n         BE    X&DIREC.MAKE&TIME   NO - GO CREATE ONE\n         LA    R2,12 .             SET UP INCREMENT SIZE\nX&DIREC.LOOP&TIME CLC 0(8,R1),X&DIREC.CURENT COMPARE DD NAMES\n         BE    X&DIREC.CONT&TIME   IF EQUAL, GO TO I/O\n         BXLE  R1,R2,X&DIREC.LOOP&TIME ^EQUAL, SEARCH TILL END OF TABLE\n         SPACE 2\n         MEND\n         TITLE 'MACRO---XGPGEN--- GENERATE GENERAL I/O MODULES'\n         MACRO\n&LABEL   XGPGEN &DIREC=G,&FETCH=NOT,&DDNUM=20\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: XGPGEN  GENERATE GENERAL I/O MODULES                     *\n.*                                    RICHARD FOWLER NOV, 1972 V.5.0  *\n.*                                                                    *\n.*       ARGUMENTS:                                                   *\n.*             &DIREC = P --> OUTPUT                                  *\n.*                   ^= P --> INPUT                                   *\n.*             &FETCH  =NOT --> NO FETCH PROTECTION                   *\n.*                    =PROTECT -->    FETCH PROTECTION                *\n.*             &DDNUM = MAXIMUM NUMBER OF DD NAMES ALLOWED AT ONCE    *\n.*     (**EACH DD FILE REQUIRES 3F TABLE ENTRY PLUS DCB AND BUFFER**) *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         TITLE ' &LABEL - MODULE CREATED BY XGPGEN'\n&LABEL   CSECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> CSECT: EXTENDED I/O MODULE FOR GENERAL I/O                       *\n*        THIS MODULE IS CALLED TO DO GENERAL I/O WORK ON A FILE       *\n*              SIMILAR IN OPERATION TO XIO ROUTINES, BUT CAN HANDLE   *\n*              MANY FILES AT ONCE.                                    *\n*        ENTRY CONDITIONS:                                            *\n*          R14 = @ OF CONTROL BLOCK                                   *\n*          R15  = ENTRY POINT ADDRESS                                 *\n*          R0  = ADDRESS OF AREA TO MOVE DATA INTO                    *\n*          R1  = ADDRESS OF DD NAME TO BE USED                        *\n*        CONTROL BLOCK:                                               *\n*      OFFSET  LENGTH        WHAT                                     *\n*        0       1F        ENTRY POINT ADDRESS                        *\n*        4       3F          SAVE AREA                                *\n*        16      2           LENGTH OF AREA                           *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         USING *,15 .              NOTE TEMPORARY ADDRESSABILITY\n         USING XIOBLOCK,R14\n         STM   R13,R7,X&DIREC.SAV1 SAVE REGISTERS TO BE USED          A\n         CNOP  0,4 .               GET ON FULLWORD\n         BAL   R13,*+76            SET UP FAKE AREA PNTR - BASE\n         USING *,R13 .             NOTE NEW USING/SAVE AREA POINTER\n         DS    18F .               FAKE SAVE AREA\n         DROP  R15 .               KILL OLD ADDRESSING\n         SPACE 2\n         USING IHADCB,R1 .         SET UP ADDRESSIBILITY TO DCB S\n         MVC   X&DIREC.CURENT(8),0(R1) . GET CURRENT DD NAME\n*   CHECK FOR CLOSE\n         SR    R1,R1               GET ZERO LENGTH INDICATOR\n         CH    R1,XIOLENG          ARE THEY EQUAL?\n         BE    X&DIREC.EOF .       YES-GO CLOSE AND FORGET FILE\n         XXGPSRCH &DIREC\n*  THE FOLLOWING CODE, IF EXECUTED, GENERATES A DCB AND TRIES AN OPEN\n*\nX&DIREC.MAKE C R1,=A(X&DIREC.FULL) CHECK FOR TABLE OVERFLOW\n         BNL   X&DIREC.CC3         NO SPACE, DON'T TRY OPEN-RETURN    J\n         ST    R1,X&DIREC.ELEM .   SAVE NEW ADDRESS, R1 ALREADY POINTIN\n         MVC   0(8,R1),X&DIREC.CURENT  SAVE DD NAME FOR FUTURE CALLS\n         L     0,X&DIREC.LONG      LOAD R2 WITH LENGTH OF DCB\n         GETMAIN R,LV=(0) .        GET SPACE FROM OS\n         L     R2,X&DIREC.ELEM .   GET ADDRESS OF POINTER\n         ST    R1,8(R2) .          SAVE @ OF DCB\n*\n         ST    R1,X&DIREC.FULL     KLUDGE TO GET AROUND ADDRESSIBILITY\n         MVC   X&DIREC.OPEN+1(3),X&DIREC.FULL+1  COPY OVER DCB @ INTO J\n*\n         MVC   0(X&DIREC.ELEM-X&DIREC.DCB,R1),X&DIREC.DCB BUILD DCB\n         MVC   DCBDDNAM,X&DIREC.CURENT MOVE DD NAME INTO DCB\n         OPEN  MF=(E,X&DIREC.DCBPTR)  DO REMOTE OPEN\n         L     R1,X&DIREC.FULL .   FIX R1, DESTROYED IN OPEN\n         TM    DCBOFLGS,X'10' .    DID OPEN GO?\n         BO    X&DIREC.CONT4       YES, DO I/O\n*              OPEN DIDN'T GO - CLEAN UP SO DOESN'T BOMB LATER        J\n         L     R0,X&DIREC.LONG     GET LENGTH OF DCB FOR FREEMAIN     J\n         FREEMAIN R,LV=(0),A=(1)   GIVE THE SPACE BACK TO OS          J\n         XC    0(12,R2),0(R2)      CLEAR OUT SO WON'T THINK IT'S OPEN J\nX&DIREC.CC3 TM *+1,X'FF'           SET CC=3  ==> OPEN IMPOSSIBLE      J\n         B     X&DIREC.RET         RETURN TO USER\n         SPACE 2\nX&DIREC.CONT L R1,8(R1) .          GET DCB ADDRESS\nX&DIREC.CONT4 LH R5,XIOLENG        GET LENGTH OF AREA\n         AIF   ('&FETCH' EQ 'PROTECT').SKPFTCH\n         L     R2,X&DIREC.SAV1+12  GET @ I/O AREA\n* THE FOLLOWING CODE IS USED FOR ADDRESS ILLEGAL     ******************\n*****  THIS CODE WILL NOT WORK IF MACHINE HAS FETCH PROTECT ***********\n         SPACE 2\n         L     R4,16 .             GET CVT PNTR FROM LOC 16\n         LA    R0,0(R2,R5) .       GET ENDING ADDRESS OF I/O AREA\n         C     R0,164(R4) .        COMPARE TO CVTMZ00 - HIGHEST ADDRESS\n         BNL   X&DIREC.ABD3 .      GO ABEND IF HIGHER\n.SKPFTCH ANOP\n         AIF   ('&DIREC' EQ 'P').XOUT  SKIP IF OUTPUT\n         LH    R7,DCBLRECL         GET LRECL FROM DCB                 J\n         GET   IHADCB .            GET # BUFFER\n         CLR   R5,R7               COMPARE REQUEST LENGTH TO LRECL    J\n         BNH   *+6                 SKIP AROUND IF OK                  J\n         LR    R5,R7               TOO BIG, USE LRECL INSTEAD         J\n         LR    R4,R5 .             SET UP FOR SHIFT\n         SRDL  R4,8 .              PUT RIGHTMOST BYTE IN R5\n         SRL   R5,24 .             RIGHT JUSTIFY FOR MOVE\n         LTR   R4,R4 .             ANYTHING LEFT IN R4?\n         BE    *+22 .              NO - DO NORMAL MOVE\n         MVC   0(256,R2),0(R1) .   GIVE USER 256 BYTES OF DATA\n         LA    R2,256(R2) .        GO TO NEXT BLOCK\n         LA    R1,256(R1) .        GO TO NEXT BLOCK\n         BCT   R4,*-14 .           IF ANYTHING LEFT IN R4, DO ANOTHER\n*              NORMAL MOVE FOLLOWS\n         LTR   R5,R5 .             IS ANYTHING IN R5?\n         BE    *+10 .              NO - DONT MOVE LEFTOVER BYTES\n         BCTR  R5,0 .              DECREMENT LENGTH BY 1\n         EX    R5,X&DIREC.MOV .    MOVE INTO RIGHT PLACE\n.XCLOSE  ANOP\n         SR    R0,R0 .             SET COND CODE TO 0, USER OK\n         B     X&DIREC.RET .       GO TO RETURN                       B\nX&DIREC.EOF EQU *                  CLOSE IHADCB\n         XXGPSRCH &DIREC,2\nX&DIREC.MAKE2 B X&DIREC.RET .      GO RETURN\nX&DIREC.CONT2 LR R4,R1 .           SAVE THE ADDRESS\n         MVC   X&DIREC.PTR+1(3),9(R1)\n         LA    R1,X&DIREC.PTR\n         CLOSE MF=(E,(1))          DO REMOTE CLOSE\n         L     R1,8(R4) .          POINT TO DCB TO FREE\n         FREEPOOL (1)              FREE THE BUFFERS\n         L     R1,8(R4)            RESET R1 IN CASE DESTROYED\n         L     R0,X&DIREC.LONG     GET AMOUNT TO FREE\n         FREEMAIN R,LV=(0),A=(1)\n*\n*   DCB NO LONGER EXISTS,  REMOVE CORRESPONDING ELEMENT FROM LIST\n*\n         LA    R3,X&DIREC.FULL .    GET UPPER ADDRESS OF TABLE\n         SR    R3,R4   .           FIND LENGTH OF REST OF TABLE\n         EX    R3,X&DIREC.WIPOUT   WIPE OUT 12 BYTES OF MEMORY\n*\n*      IF NO POINTERS REMAIN, SET POINTER TO LAST = ZERO\n*\n         LA    R3,12\n         L     R2,X&DIREC.ELEM\n         SR    R2,R3\n         LA    R1,X&DIREC.PNTSRT\n         CR    R1,R2\n         BNH   *+8\n         LA    R2,0 .              SET POINTER TO ZERO\n         ST    R2,X&DIREC.ELEM     SAVE POINTER\n         AIF   ('&DIREC' EQ 'P').XRET\n         OI    *+1,1 .             SET COND CODE FOR END OF FILE\n.*       SHOULD REMOVE DCB FROM LIST NOW\n         AGO   .XRET .             HAVE RETURN CODE GENERATED\n.*\n.XOUT    ANOP\n         LH    R7,82(R1) .         GET LRECL\n         PUT   IHADCB .            PRINT THE STUFF\n         CLR   R5,R7               COMPARE REQUEST LENGTH TO LRECL    J\n         BNH   *+6                 SKIP AROUND IF OK LENGTH           J\n         LR    R5,R7               TOO BIG- USE LRECL INSTEAD         J\n         LR    R4,R5 .             SET UP FOR SHIFT\n         LR    R6,R5               SAVE FOR LATER\n         SRDL  R4,8 .              PUT RIGHTMOST BYTE IN R5\n         SRL   R5,24 .             RIGTH JUSTIFY FOR MOVE\n         LTR   R4,R4 .             ANYTHING LEFT IN R4?\n         BE    *+22 .              NO - DO NORMAL MOVE\n         MVC   0(256,R1),0(R2) .   PUT STUFF INTO BUFFER\n         LA    R2,256(R2) .        GO TO NEXT BLOCK\n         LA    R1,256(R1) .        GO TO NEXT BLOCK\n         BCT   R4,*-14 .           IF ANYTHING LEFT IN R4, DO ANOTHER\n*              NORMAL MOVE FOLLOWS\n         LTR   R5,R5 .             IS ANYTHING IN R5?\n         BE    *+12\n         BCTR  R5,0 .              DECREMENT LENGTH BY 1\n         EX    R5,X&DIREC.MOV .    MOVE INTO RIGHT PLACE\n         AR    R1,R5               GET BEGINNING @ TO BLANK\n         SR    R7,R6               GET DIFFERENCE BETWEEN USER AND DCB\n         BZ    *+12                NO DIFFERENCE, DO NOTHING          A\n         MVI   1(R1),C' '\n         EX    R7,X&DIREC.MOV2     CLEAR REST\n*  ****NOTE THAT THIS ONLY WORKS FOR DIFFERENCES < 256\n         AGO   .XCLOSE\n.*\n.XRET    ANOP\n         SPACE 2\nX&DIREC.RET LM R13,R7,X&DIREC.SAV1 RESTORE REGS                       A\n         B     XIORETRN            RETURN\n         DROP  R14\nX&DIREC.ABD3 CLI  *,0              SET CC=2, SHOW EXECUTE ERROR       J\n         B     X&DIREC.RET         GO RETURN, SHOWING ERROR           J\n.*\n         SPACE 2\nX&DIREC.PTR CLOSE (X&DIREC.CONT),MF=L    GENERAL PURPOSE CLOSE\nX&DIREC.WIPOUT MVC 0(1,R4),12(R4)\nX&DIREC.CURENT DS  CL8  .          AREA TO HOLD CURRENT DD NAME\nX&DIREC.SAV1 DS 11F                SAVE AREA FOR REGS USED            A\nX&DIREC.PNTSRT DS (&DDNUM*3)F .    AREA FOR DDNUM DD NAMES & POINTERS\nX&DIREC.FULL DS F\nX&DIREC.OPEN DS 0F                 EXTRA LABEL\n         AIF   ('&DIREC' EQ 'P').XDEFSR  SKIP IF OUTPUT\nX&DIREC.DCBPTR OPEN (X&DIREC.CONT,(INPUT)),MF=L  OPEN CONTROL WORD    J\nX&DIREC.DCB DCB DSORG=PS,MACRF=GL,EODAD=X&DIREC.EOF\nX&DIREC.ELEM DC  F'0' .            INITIAL # OF ELEMENTS\nXX&DIREC.LONG EQU X&DIREC.ELEM-X&DIREC.DCB   GET DCB LENGTH\nX&DIREC.LONG DC A(XX&DIREC.LONG)   SAVE LENGTH OF DCB\nX&DIREC.MOV MVC 0(1,R2),0(R1) .    GIVES USER THE DATA\n         LTORG\n         DROP  R13\n         MEXIT                     DONE\n.XDEFSR  ANOP\nX&DIREC.DCBPTR OPEN (X&DIREC.CONT,(OUTPUT)),MF=L OPEN CONTROL WORD    J\nX&DIREC.DCB DCB DSORG=PS,MACRF=PL\nX&DIREC.ELEM DC F'0' .             INITIAL # OF ELEMENTS\nXX&DIREC.LONG EQU X&DIREC.ELEM-X&DIREC.DCB   GET DCB LENGTH\nX&DIREC.LONG DC A(XX&DIREC.LONG)   SAVE LENGTH OF DCB\nX&DIREC.MOV MVC 0(1,R1),0(R2) .    MOVE INTO LINE\nX&DIREC.MOV2 MVC 2(1,R1),1(R1)     CLEAR OUT REST OF BUFFER\n         LTORG\n         DROP  R13\n         MEND\n         TITLE '***MACRO*** XDDSLOT  GENERATES XGET-XPUT CONTROL TABLE'\n         MACRO\n&LABEL   XDDSLOT &NAME,&WHICH,&POSIN=0,&POSOUT=0,&PERM=1,&REST1=00,    X\n               &REST2=0\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: XDDSLOT CREATE TABLE ENTRY FOR XGET-XPUT                 *\n.*                                    RICHARD FOWLER OCT. 1972. V.5.0 *\n.*                                                                    *\n.*       THIS MACRO GENERATES AN ELEMENT TO HELP ASSIST KEEP          *\n.*             CONTROL OF THINGS WHILE EXECUTING XGET-XPUT.           *\n.*             &NAME CHAR STRING OF RESERVED DD NAME                  *\n.*             &WHICH  MISSING OR IN ERROR, USER MAY XGET-XPUT IT     *\n.*                 =XREAD   USER CAN XREAD ONLY                       *\n.*                 =XPRNT   USER CAN XPRNT ONLY                       *\n.*                 =XPNCH   USER CAN XPNCH ONLY                       *\n.*                                                                    *\n.*             &POSIN = 1 CAN INPUT                                   *\n.*                    = 0 CANNOT INPUT                                *\n.*                                                                    *\n.*             &POSOUT = 1 CAN OUTPUT                                 *\n.*                     = 0 CANNOT OUTPUT                              *\n.*             &PERM = 1 ON REENTERING, &NAME WILL STILL EXIST        *\n.*                   =0  &NAME WILL NOT EXIST ON REENTERING           *\n.*                                                                    *\n.*             &REST 1,2  NOT USED                                    *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         AIF   (T'&NAME EQ 'O').DDEMPTY   CREATE AN EMPTY SLOT\n&LABEL   DC    CL8'&NAME' .        NO, SHOVE IN DDNAME\n.*             SET BITS, NOTE NOT CURRENTLY OPEN\n         DC    B'00&REST1&POSOUT&POSIN&REST2&PERM'\n         AIF   (T'&WHICH NE 'O').DDSK1      WAS &WHICH OMITTED\n.DDSK4   DC    XL1'00' .           YES ASSUME XGET-XPUT\n         MEXIT\n.DDSK1   AIF   ('&WHICH' NE 'XREAD').DDSK2   READ ONLY?\n         DC    XL1'04' .           YES,  FIX INDEX\n         MEXIT\n.DDSK2   AIF   ('&WHICH' NE 'XPRNT').DDSK3  DO WRITES ONLY?\n         DC    XL1'08' .           YES,   FIX INDEX\n         MEXIT\n.DDSK3   AIF   ('&WHICH' NE 'XPNCH').DDSK4 IF INVALID, ASSUM XGET-XPUT\n         DC    XL1'0C' .           VALID,  SET INDEX\n         MEXIT\n.DDEMPTY ANOP\n&LABEL   DC    CL8' ' .            BLANK DDNAME\n         DC    XL2'0C00' .         BLANK EVERYTHING, XGET-XPUT ALLOWED\n         MEND\n         TITLE '*** LINKAGE MACROS - $CALL,$RETURN,$SAVE ***'\n         MACRO\n&LABEL   $CALL &ENTRY\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: $CALL      SUBROUTINE CALL INSIDE ASSIST ASSEMBLER.      *\n.*       &ENTRY    ENTRY POINT NAME TO BE CALLED, OS LINKAGE.         *\n.*       **NOTE** GENERATES NAME WITH AX PREFIX, SO CAN ONLY BE USED  *\n.*       INSIDE ASSEMBLER WHERE AVWXTABL USING HOLDS.                 *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n&LABEL   L     REP,AX&ENTRY .      GET ADCON FROM THE TABLE\n         BALR  RET,REP .           CALL THE DESIRED ROUTINE\n         MEND\n         SPACE 2\n         MACRO\n&LABEL   $RETURN &RGS=NO,&SA=\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: $RETURN    RETURN FROM SUBROUTINE, OS LINKAGE.           *\n.*       SUPPLIES EXTRA DEBUGGING CONTROL AND DEFAULTS TO XRETURN.    *\n.*       USES MACROS: XRETURN                                         *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         GBLC  &TRACE              SPECIFIES FORM OF TRACE-SNAP,*,NO\n&LABEL   XRETURN RGS=&RGS,SA=&SA,TR=&TRACE\n         MEND\n         SPACE 2\n         MACRO\n&LABEL   $SAVE &RGS=NO,&BR=15,&SA=\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: $SAVE      SUBROUTINE ENTRY SETUP, OS LINKAGE.           *\n.*       SUPPLIES EXTRA DEBUGGING CONTROL AND DEFAULTS TO XSAVE MACRO.*\n.*       USES MACROS: XSAVE                                           *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         GBLC  &TRACE,&ID          TRACE FORM, IDENT\n&LABEL   XSAVE RGS=&RGS,BR=&BR,SA=&SA,TR=&TRACE,ID=&ID\n         MEND\n         SPACE 2\n         MACRO\n         $DBG  &D,&T\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: $DBG       SET TRACE, DEBUGGING SET VARIABLES FOR ASM.   *\n.*       &D        HEX FLAG BYTE FOR USE IN TM INSTRUCTION.           *\n.*       &T        IS TRACE MODE FOR AN XSNAP = NO,*,SNAP.            *\n.*       SEE MACROS $RETURN,$SAVE,XSRTR FOR GENERATION OF TRACE CODE  *\n.*       ON ROUTINE ENTRY/EXIT. SEE ALSO ASSIST PROGRAM LOGIC MANUAL. *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         GBLC  &DEBUG,&TRACE       DEBUG FLAG BYTE,TRACE MODE\n         AIF   ('&D' EQ '').D1     SKIP IF OMITTED,DON'T CHANGE\n&DEBUG   SETC  'X''&D'''           SET FLAG BYTE FOR MASK\n.D1      AIF   ('&T' EQ '').D2     SKIP IF NOTRACE,DON'T CHANGE\n&TRACE   SETC  '&T'                SET UP TRACE MODE,IF ANY\n.D2      MEND\n         TITLE '*** $AL2 MACRO - CREATE AL2 JUMP INDEX CONSTANTS ***'\n         MACRO\n&LABEL   $AL2  &BASE,&LIST,&OFSET,&L\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: $AL2       CREATE HALFWORD ADDRESS OFFSET TABLE.         *\n.*       USED TO GENERATE LIST OF AL2 ADDRESS CONSTANTS WHICH         *\n.*       CONTAIN THE RELATIVE ADDRESS OF EACH ITEM IN &LIST FROM &BASE*\n.*       &OFSET GIVES A NUMBER TO BE ADDED OR SUBTRACTED WHEN SETTING *\n.*       UP THE EQU FOR THE LABEL,SO THAT INDEXING MAY START ANYWHERE *\n.*       &L IS CODED IF THE OFFSET LIST SHOULD BE PRECEDED BY LENGTH  *\n.*       SET UP FOR BXLE .                                            *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         LCLA  &I                  LOCAL COUNTER\n         DS    0H                  ALIGN\n         AIF   (T'&LABEL EQ 'O').XCHKL       SKIP IF NO LABEL\n&LABEL   EQU   *&OFSET\n.XCHKL   AIF   (T'&L EQ 'O').XNOFS1          SKIP IF LENGTH OMITTED\n&I       SETA  N'&LIST*2-2         SET UP FOR BXLE-# OF OPS\n         DC    H'&I'\n&I       SETA  0                   RESET COUNTER\n.XNOFS1  ANOP\n&I       SETA  &I+1\n         DC    AL2(&LIST(&I)-&BASE)\n         AIF   (&I LT N'&LIST).XNOFS1        KEEP LOOPING UNTIL DONE\n         MEND\n         TITLE '*** $SPIE - EXTENDED INTERRUPT COMMUNICATIONS ***'\n         MACRO\n&LABEL   $SPIE &EXIT,&TYPES,&CE=0,&ACTION=INIT\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: $SPIE        INTERRUPT COMMUNICATIONS                    *\n.*                                 SCOTT A. SMITH - FALL 1971.        *\n.*       MAY BE USED BY OS OR DOS SYSTEMS TO SPECIFY THE ADDRESS      *\n.*       OF AN INTERRUPTION EXIT ROUTINE AND TO SPECIFY THE PROGRAM   *\n.*       INTERRUPT TYPES THAT ARE TO CAUSE THE EXIT ROUTINE TO BE     *\n.*       GIVEN CONTROL.                                               *\n.*       &EXIT     LABEL TO BE BRANCHED TO FOR THE INTERRUPTION       *\n.*                 EXIT.  ADDRESS MAY BE IN A REGISTER.               *\n.*       &TYPES    A LIST OF INTERRUPTION TYPES TO CATCH.  IF THIS    *\n.*                 IS NOT SPECIFIED, A DEFAULT VALUE OF  ((1,15))     *\n.*                 IS ASSUMED.  THE FORM OF THIS OPERAND IS A LIST    *\n.*                 OF OPERANDS SEPARATED BY COMMAS.  THE LIST ITSELF  *\n.*                 IS ENCLOSED IN PARENTHESES WITH EACH OPERAND       *\n.*                 SPECIFYING A GROUP OF INTERRUPT TYPES TO CATCH.    *\n.*                 EACH OF THESE IS EITHER A SINGLE INTEGER BETWEEN   *\n.*                 1 AND 15, OR A PAIR OF INTEGERS BETWEEN 1 & 15     *\n.*                 REPRESENTING AN INCLUSIVE RANGE OF INTERRUPTS.     *\n.*                 EACH PAIR IS ENCLOSED IN PARENTHESES.              *\n.*       &ACTION=  SPECIFIES THE ACTION THIS MACRO IS TO TAKE.        *\n.*             -->INIT: IDENTIFIES THIS AS AN INITIAL $SPIE CALL      *\n.*                 AND INITIALIZATION IS TO BE PERFORMED.             *\n.*             -->CR: CREATE A NEW $SPIE COMMUNICATION, BUT DO        *\n.*                 NOT REINITIALIZE.                                  *\n.*             -->(RS,(REG)) RESTORE A PREVIOUS $SPIE COMMUNICATION   *\n.*                 LINK USING THE XSPIEBLK AT THE ADDRESS IN THE      *\n.*                 REGISTER.  ALL OTHER PARAMETERS ARE IGNORED        *\n.*            ***DEFAULT***INIT                                       *\n.*       &CE=      THIS SPECIFIES AN OPTIONAL CALLABLE EXIT WHICH     *\n.*                 MAY RECEIVE TEMPORARY CONTROL IMMEDIATELY FOLLOW-  *\n.*                 ING AN INTERRUPT.  THIS EXIT MUST RETURN.          *\n.*       *REGISTERS 14,15,0,1 ARE DESTROYED BY THIS MACRO*            *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         LCLA  &I,&PTRVAL,&ENDVAL\n         LCLB  &BIT(15),&J,&K\n         LCLC  &STR,&PTR,&END,&NAME\n         SPACE 1 .                 SEPARATE FROM MAIN LINE CODE\n         AIF   ('&LABEL' EQ '').NOLAB  DO NOT GENERATE A LABEL IF NONE\n&LABEL   DS    0H .                GENERATE USER LABEL\n.NOLAB   AIF   ('&ACTION(1)' NE 'INIT').NOINT   NO INITIALIZATION\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*       PERFORM CALL TO XXXXSPIN FOR INITIALIZATION                  *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.INITIAL CNOP  0,4 .               ALIGNMENT FOR ADCON\n         BAL   R14,*+8 .           SKIP AROUND ADCON FOR XXXXSPIN\n         DC    V(XXXXSPIN) .       INITIALIZATION ADCON\n         L     R15,0(R14) .        LOAD INITIALIZATION ROUTINE ADDRESS\n         BALR  R14,R15 .           GO INITIALIZE, RETURN FOR XXXXSPIE\n         AGO   .CREATE             SKIP ACTION CHECK, ALREADY KNOW\n.NOINT   AIF   ('&ACTION(1)' EQ 'RS').RSTR    RESTORE OLD XSPIEBLK\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*       INITIALIZE A BIT STRING TO REPRESENT THE INTERRUPT TYPES     *\n.*       TO CATCH FOR THIS PARTICULAR $SPIE                           *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.CREATE  AIF   ('&TYPES' NE '').LIST   IF OMMITED, GET ALL INTERRUPTS\n&PTRVAL  SETA  1                   SET POINTER TO START AT SOC #1\n&ENDVAL  SETA  15                  FLAG ALL INTERRUPTS UP TO SOC #15\n         AGO   .NEXT               MAKE APPROPRIATE BIT MARKS\n.LIST    ANOP\n&I       SETA  1                   START SCAN OF TYPES FIELD AT LOC9 1\n.TOP     AIF   ('&TYPES(&I)' EQ ' ').SKIP   TO SKIP EMBEDDED BLANKS\n&STR     SETC  '&TYPES(&I)'        SAVE NEXT CHAR IN TYPES STRING\n         AIF   ('&STR'(1,1) NE '(').SINGLE   FOR NON-PAIRS OF TYPES\n&PTR     SETC  '&STR'(2,1)         ASSUME ONE DIGIT LONG\n         AIF   ('&STR'(3,1) EQ ',').OKLOOK   IT WAS ONE DIGIT, GET #2OP\n&PTR     SETC  '&STR'(2,2)         FIRST TYPE: 2 DIGITS LONG\n&END     SETC  '&STR'(5,2)         SHOULD BE LEN=2; IF NOT, CAUGHT LATR\n         AGO   .SETOK              HAVE CHAR STRINGS OF TWO TYPE LIMITS\n.OKLOOK  ANOP                      FIND TYPE LIM #2 DIGIT LENGTH\n&END     SETC  '&STR'(4,1)         ASSUME OF LENGTH 1, SINCE FIRST WAS\n         AIF   ('&STR'(5,1) EQ ')').SETOK   IT IS OF LENGTH 1, SO IS OK\n&END     SETC  '&STR'(4,2)         SECOND LIMIT IS A 2 DIGIT #\n.SETOK   ANOP\n&PTRVAL  SETA  &PTR                GET INTEGER VALUE FOR BIT MARKING\n&ENDVAL  SETA  &END                INTEGER ENDING VALUE\n         AIF   (&PTRVAL GT &ENDVAL OR &PTRVAL LT 1 OR &ENDVAL GT 15).ER\n.NEXT    ANOP                      LOOP TO SET UP BIT MARKERS FOR TYPES\n&BIT(&PTRVAL)  SETB  1             MARK THIS INTERRUPT TO BE CAUGHT\n         AIF   (&PTRVAL EQ &ENDVAL).SKIP   ALL DONE, SEE IF MORE INTRPS\n&PTRVAL  SETA  &PTRVAL+1           FLAG NEXT INTERRUPT TYPE TO CATCH\n         AGO   .NEXT               MARK IT IN BIT FLAG FIELD\n.SINGLE  AIF   (&TYPES(&I) LT 1 OR &TYPES(&I) GT 15).ER  OUT OF RANGE\n&BIT(&STR)     SETB  1             CATCH THIS INTERRUPT TYPE (BIT MARK)\n.SKIP    ANOP                      GET NEXT OPERAND FROM &CATCH\n&I       SETA  &I+1                UP SCAN POINTER TO NEXT LOC.\n         AIF   (&I LE N'&TYPES).TOP    GET NEXT MASK SPEC., IF IT EXIST\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*       WE HAVE THE BIT STRING INITIALIZED, NOW WE MUST BUILD UP     *\n.*       THE NEW XSPIEBLK FOR NEW INTERRUPTS AND EXIT ADDRESSES.      *\n.*       DETERMINE THE PRESENCE & NATURE OF INTERRUPT EXIT ROUTINE    *\n.*       ADDRESS AND THE CALLABLE EXIT ADDRESS, AND PUT IN XSPIEBLK   *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         CNOP  2,4 .               ALIGNMENT FOR ADCONS\n         LA    R1,*+18 .           ADDRESS FOR BRANCH AROUND XSPIEBLK\n         BALR  R1,R1 .             BR AROUND BLK; R1 <= @ XSPIEBLK\n         AIF   ('&EXIT' EQ '').NOEXIT  NO EXIT RTN @ SUPPLIED\n         AIF   ('&EXIT'(1,1) EQ '(').INREG  EXIT RTN @ IS IN A REGISTER\n         DC    AL4(&EXIT) .        # OF EXIT RTN\n.CONT    AIF   ('&CE'(1,1) EQ '(').CEREG    @ IS IN A REGISTER\n         DC    AL4(&CE) .          CALLABLE EXIT ROUTINE ADDRESS\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*       EXPAND BIT PATTERN FOR INTERRUPT TYPES TO CATCH.  EXPANDED   *\n.*       TO A FULLWORD FOR EASIER MANIPULATION                        *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.INT     DC    B'0&BIT(1)&BIT(2)&BIT(3)&BIT(4)&BIT(5)&BIT(6)&BIT(7)&BITX\n               (8)&BIT(9)&BIT(10)&BIT(11)&BIT(12)&BIT(13)&BIT(14)&BIT(1X\n               5)',BL2'0' .    BIT PATTERN WITH PADDED ZEROS\n         AIF   (NOT &J).KEF        SKIP IF &EXIT NOT IN REGISTER\n         ST    &EXIT(1),0(0,R1) .  STORE REG VALUE FOR &EXIT @\n.KEF     AIF   ('&CE'(1,1) NE '(').XSPYCAL .    SKIP IF &CE NOT IN REG.\n         ST    &CE(1),4(0,R1) .    STORE CALLABLE EXIT @ IN XSPIEBLK\n         AGO   .XSPYCAL            GO FOR A CALL TO XXXXSPIE TO CHNG PT\n.INREG   ANOP                      &EXIT IS IN A REGISTER\n&J       SETB  1                   FLAG THIS CONDITION SO WE STORE @\n.NOEXIT  DC    AL4(0) .            SET ASIDE LOCATION FOR EXIT @\n         AGO   .CONT               SEE ABOUT SECOND ADDRESS\n.CEREG   DC    AL4(0) .            @ FOR RESERVING LOC. FOR CALLABLE EX\n         AGO   .INT                GENERATE BIT PATTERN FOR INTERRUPTS\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*       HERE WE ARE INTERESTED IN RESTORING AN OLD XSPIEBLK.  GET    *\n.*       XSPIEBLK ADDRESS IN R1.                                      *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.RSTR    ANOP\n&PTR     SETC  '&ACTION(2)'        GET SECOND ARGUMENT: REG. IN PARENS\n&END     SETC  '&PTR'(2,1)         ASSUME ONLY A ONE DIGIT NUMBER\n&I       SETA  &END                CONVERT CHARACTER # TO ACTUAL #\n         AIF   ('&PTR'(3,1) EQ ')').CHKR1  ASSUMPTION WAS RIGHT\n&END     SETC  '&PTR'(2,2)         GET THE TWO DIGIT NUMBER\n&I       SETA  &END                CONVERT CHARACTER # TO ACTUAL #\n.CHKR1   AIF   (&I EQ 1).XSPYCAL   DON'T DO A :  LR 1,1\n         LR    R1,&I .             GET @ OF OLD XSPIEBLK IN REG #1\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*       PREPARE CALL TO XXXXSPIE AND THEN CALL IT.  R1 SHOULD BE     *\n.*       POINTING TO THE NEW (OR OLD, IN CASE OF ACTION=(RS)) SPYBLK  *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.XSPYCAL CNOP  0,4 .               ALIGNMENT FOR UPCOMING ADCON\n         B     *+8 .               SKIP AROUND XXXXSPIE ADCON\n         DC    V(XXXXSPIE) .       ENTRY POINT @ FOR ACTION EXECUTION\n         L     R15,*-4 .           R15 <- @ OF XXXXSPIE FOR CALL\n         BALR  R14,R15 .           CHANGE XSPIEBLK POINTERS--RETURN OL@\n         AGO   .XXIT               RETURN\n.ER      MNOTE 4,'**ERROR--INVALID SEQUENCE OF INTERRUPT TYPES--$SPIE CX\n               ANCELLED'\n.XXIT    SPACE 1\n         MEND\n         TITLE '*** XSRTR-XSAVE/XRETURN TRACE-ASSIST VERSION ***'\n         MACRO\n         XSRTR &TR,&LABEL,&MSG\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: XSRTR      CREATE SPECIAL ASSIST ENTRY/EXIT TRACE CODE.  *\n.*                                     JOHN R. MASHEY-JULY 1969-360/67*\n.*       THIS MACRO IS USED BY XSAVE AND XRETURN TO GENERATE THE      *\n.*       TRACE CODE CALLS TO XPRNT OR XSNAP, IF THE TR OPERAND IS USED*\n.*       *NOTE* THIS IS MODIFIED VERSION FOR USE IN ASSIST ONLY.      *\n.*       USES MACROS: XSNAP                                           *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         GBLB  &XSNAPST            XSNAP STATUS;0==>ON,1==>OFF\n         GBLB  &$DEBUG             DEBUG MODE FLAG,0==>YES,1==>NO\n         GBLC  &DEBUG              DEBUG FLAG BITS FOR TESTING\n         LCLB  &XSTSAV             FOR SAVING STATUS VARIABLES\n         LCLC  &NAME               FOR EITHER LABEL OR CSECT\n         LCLC  &T                  FOR TYPE\n         AIF   (&$DEBUG).XXEXIT    SKIP WHOLE THING IF NO DEBUG\n&NAME    SETC  '&LABEL'            ASSUME NAME IS LABEL\n         AIF   (T'&LABEL NE 'O').XNOK1       SKIP IF LABEL EXISTS\n&NAME    SETC  '&SYSECT'           USE CSECT NAME INSTEAD\n         AIF   ('&SYSECT' NE '').XNOK1       SKIP IF CSECT NOT PC\n&NAME    SETC  '$PRIVATE'          USE NAME FOR PRIVATE CODE (PC)\n.XNOK1   ANOP\n&XSTSAV  SETB  (&XSNAPST)          SAVE XSNAP STATUS, IN CASE OFF\n&XSNAPST SETB  (0)                 MAKE SURE XSNAP WILL GENERATE\n*        XSNAP LABEL='  MESSAGE '\n&T       SETC  'PR'                FOR NORMAL PRINTING OF REGS\n         AIF   ('&TR(1)' NE '*').XDFTB       SKIP AND PRINT REGS\n&T       SETC  'NO'                DO NOT PRINT REGISTERS\n.XDFTB   XSNAP LABEL='*** &NAME &MSG ***',T=&T,IF=(AVDEBUG,O,&DEBUG,TM)\n&XSNAPST SETB  (&XSTSAV)           RESTORE STATUS,IN CASE IT WAS OFF\n.XXEXIT  MEND\n         TITLE '*** ALIGN LOCATION COUNTER MACROS - $ALIGN,$ALIGR ***'\n         MACRO\n&LABEL   $ALIGN &R,&A,&TAG\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: $ALIGN     GET,ALIGN, RESTORE UPDATED LOCATION COUNTER.  *\n.*       USED TO ALIGN LOCATION COUNTER TO H, F, OR D BOUNDARIES.     *\n.*       &R WILL CONTAIN ALIGNED VALUE OF LOCATION COUNTER            *\n.*       &A GIVES ALIGNMENT REQUIRED , IF IN PARENTHESES, GIVES REG,  *\n.*       IF NOT, GIVES DECIMAL NUMBER 1-3-7 FOR H,F,D ALIGN           *\n.*       &TAG  IF CODED-MEANS THAT LOCATION COUNTER IS ALREADY IN &R. *\n.*       USES MACROS: $ALIGR,$GLOC,$SLOC                              *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         AIF   (T'&TAG EQ 'O').XNORM         NORMAL USE\n         AIF   (T'&LABEL EQ 'O').XC          SKIP IF NOT NEEDED\n&LABEL   DS    0H\n         AGO   .XC                 SKIP TO DECIDE\n.XNORM   ANOP\n&LABEL   $GLOC &R .                GET THE LOCATION COUNTER\n.XC      AIF   ('&A'(1,1) EQ '(').XREG       SKIP IF REGISTER FORM\n         LA    &R,&A.(&R) .        INCREMENT THE LOCATION COUNTER\n         O     &R,AWF&A .          MAKE LAST BITS ALL 1'S\n         S     &R,AWF&A .          SUBTRACT,GETTING RIGHT ALIGNMENT\n         AGO   .XST                GO STORE IT BACK\n.XREG    $ALIGR &R,&A\n.XST     $SLOC &R .                STORE LOCATION COUNTER BACK\n         MEND\n         SPACE 2\n         MACRO\n&LABEL   $ALIGR &R,&A\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: $ALIGR     ALIGN VALUE IN REGISTER (USUALLY LOCCNTR).    *\n.*        ALIGN REGISTER MACRO-ALIGN REGISTER &R TO BOUNDARY GIVEN    *\n.*       BY VALUE IN REG &A, WHICH HAS 1,3,7 ETC IN IT.               *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n&LABEL   AR    &R,&A .             ADD LENGTH-1 TO LOCATION COUNTER\n         OR    &R,&A .             MAKE LAST 1-3 BITS ALL 1'S\n         SR    &R,&A .             ALIGN VALUE APPROPRIATELY\n         MEND\n         TITLE '*** MISC LOC-COUNTER MACROS-$CKALN,$GLOC,$SLOC ***'\n         MACRO\n&LABEL   $CKALN &MASK,&B\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: $CKALN     CHECK LOC-COUNTER ALIGNMENT, BRANCH IF OK.    *\n.*       USED TO CHECK ALIGNMENT - &MASK IS 1-3-7, &B IS BRANCH LOC   *\n.*       IF LOCATION COUNTER IS PROPERLY ALIGNED.                     *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n&LABEL   TM    AVLOCNTR+3,&MASK .  CHECK FOR RIGHT ALIGNMENT\n         BZ    &B .                TAKE BRANCH IF WAS ALIGNED\n         MEND\n         SPACE 2\n         MACRO\n&LABEL   $GLOC &RG\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: $GLOC      GET LOCATION COUNTER INTO REGISTER.           *\n.*       GET LOCATION COUNTER MACRO-PUTS LOCCNTR VALUE IN &RG         *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n&LABEL   L     &RG,AVLOCNTR        GET LOCATION COUNTER\n         MEND\n         SPACE 2\n         MACRO\n&LABEL   $SLOC &RG\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: $SLOC      SET LOCATION COUNTER TO REGISTER VALUE.       *\n.*       SET LOCATION COUNTER MACRO - SETS &RG AS LOCCNTR VALUE       *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n&LABEL   ST    &RG,AVLOCNTR        SET LOCATION COUNTER\n         MEND\n         TITLE '*** SCAN POINTER MACROS - $SCOF, $SCPT ***'\n         MACRO\n&LABEL   $SCOF &RG,&SCP,&BYTE,&AD=AVRSBPT\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: $SCOF      CONVERT REGISTER SCAN POINTER TO OFFSET VALUE.*\n.*       SCAN POINTER OFFSET MACRO - PLACE SCAN POINTER REGISTER &SCP *\n.*       INTO WORK REGISTER &RG. FIND OFFSET, AND STORE IT INTO &BYTE *\n.*       IF &BYTE SPECIFIED.  &AD= WORD GIVING BEGINNING @ FOR OFFSET.*\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n&LABEL   LR    &RG,&SCP .          MOVE SCAN POINTER ADDRESS OVER\n         S     &RG,&AD .           SUBTRACT STARTING ADDR\n         AIF   (T'&BYTE EQ 'O').XEXIT        SKIP IF NO STORE WANTED\n         STC   &RG,&BYTE .         SAVE OFFSET INTO BYTE\n.XEXIT   MEND\n         SPACE 2\n         MACRO\n&LABEL   $SCPT &RG,&BYTE,&AD=AVRSBPT\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: $SCPT      CONVERT OFFSET TO A SCAN POINTER @ INTO REG.  *\n.*       GET SCAN POINTER ADDRESS FROM OFFSET-OFFSET IS IN &BYTE,ADDR *\n.*       IS CREATED IN &RG.  &AD GIVES BEGINNING @ OF FIELD.          *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n&LABEL   SR    &RG,&RG .           CLEAR FOR INSERTION\n         IC    &RG,&BYTE .         GET THE OFFSET VALUE\n         A     &RG,&AD .           ADD START ADDR TO GET REAL ADDR\n         MEND\n         TITLE '*** STORAGE ALLOCATION MACROS - $ALLOCH,$ALLOCL ***'\n         MACRO\n&LABEL   $ALLOCH &R,&L,&OVRFL\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: $ALLOCH    GET CORE IN FREEAREA HIGH END (ASSEMLBER).    *\n.*       &R  GIVES REGISTER WHERE ADDRESS OF NEW USABLE AREA APPEARS  *\n.*       &L  GIVES REGISTER CONTAINING THE LENGTH DESIRED             *\n.*       &OVRFL IS ADDRESS TO BE BRANCHED TO IF OVERFLOW OCCURS.      *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n&LABEL   L     &R,AVADDHIH .       GET CURRENT HIGH END POINTER\n         SR    &R,&L .             GET NEW HIGH END POINTER\n         C     &R,AVADDLOW .       MAKE SURE NO OVERFLOW\n         BL    &OVRFL .            TAKE BRANCH IF OVERFLOW\n         ST    &R,AVADDHIH .       RESTORE UPDATED POINTER\n         MEND\n         SPACE 2\n         MACRO\n&LABEL   $ALLOCL &R,&L,&OVRFL\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: $ALLOCL    GET CORE IN LOW FREEAREA (IN ASSEMBLER).      *\n.*       &R  GIVES REGISTER WHERE ADDRESS OF NEW USABLE AREA APPEARS  *\n.*       &L  GIVES REGISTER CONTAINING THE LENGTH DESIRED.            *\n.*       &OVRFL  IS ADDRESS TO BE BRANCHED TO IF OVERFLOW OCCURS.     *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n&LABEL   L     &R,AVADDLOW .       LOAD CURRENT LOW END POINTER\n         AR    &R,&L .             ADD REQUESTED LENGTH TO POINTER\n         C     &R,AVADDHIH .       MAKE SURE NO OVERFLOW\n         BH    &OVRFL .            TAKE BRANCH IF OVERFLOW\n         ST    &R,AVADDLOW .       REPLACE UPDATED POINTER\n         SR    &R,&L .             RESTORE POINTER\n         MEND\n         TITLE '*** STORAGE ALLOCATION MACROS - $MALLOCL,$MALLOCH ***'\n         MACRO\n&LABEL   $MALLOCL  &R,&L,&OVRFL=MXPNDOVR,&LENG=                       S\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*-->  MACRO:  &MALLOCL    GET CORE IN LOW FREEAREA.  SAME AS &ALLOCL *\n.*        EXCEPT USES AVGEN2CD AS POINTER TO FREE HIGH AREA.  USED IN *\n.*        MEXPND                                                      *\n.*                                                                    *\n.*     &R  GIVES REGISTER WHERE ADDRESS OF NEW USEABLE AREA APPEARS   *\n.*     &L  GIVES REGISTER CONTAINING LENGTH DESIRED                   *\n.*     &OVRFL IS @ TO BE BRANCHED TO IF OVERFLOW                      *\n.*     &LENG IS THE LENGTH TO BE ALLOCATED                            *\n.*                                                                    *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n&LABEL   DS    0H                  DEFINE LABEL                       S\n         AIF   ('&LENG' EQ '').X                                      S\n         LA    &L,&LENG            LOAD LENGTH TO ALLOCATE            S\n.X       L     &R,AVADDLOW         LOAD CURRENT LOW END PTR           S\n         AR    &R,&L               ADD REQUESTED LENGTH\n         C     &R,AVGEN2CD         MAKE SURE NO OVERFLOW\n         BH    &OVRFL              BRANCH IF OVERFLOW\n         ST    &R,AVADDLOW         REPLACE UPDATED POINTER\n         SR    &R,&L               RESTORE POINTER\n         MEND\n         SPACE 2\n         MACRO\n&LABEL   $MALLOCH  &R,&L,&OVRFL=MXPNDOVR\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*-->  MACRO:  &MALLOCH   GET CORE IN HIGH FREEAREA.  SAME AS &ALLOCH *\n.*        EXCEPT USES AVGEN2CD AS HIGH END POINTER.  USED IN MEXPND   *\n.*     &R  IS REG NEW USEABLE @ APPEARS IN                            *\n.*     &L  GIVES REGISTER DESIRED LENGTH IS IN                        *\n.*     &OVRFL  IS BRANCH @ IF OVERFLOW OCCURS                         *\n.*                                                                    *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n&LABEL   L     &R,AVGEN2CD         LOAD CURRENT HIGH END POINTER\n         SR    &R,&L               GET NEW HIGH END POINTER\n         C     &R,AVADDLOW         MAKE SURE NO OVERFLOW\n         BL    &OVRFL              BRANCH IF OVERFLOW\n         ST    &R,AVGEN2CD         RESTORE UPDATED POINTER\n         MEND\n         TITLE '*** STORAGE DEALLOCATION MACRO - $DALLOCH ***'\n         MACRO\n&LABEL   $DALLOCH &R,&L\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: $DALLOCH   RETURN CORE-HIGH FREEAREA (IN ASSEMBLER)      *\n.*       &R IS A WORK REGISTER, WHICH WILL BE DESTROYED               *\n.*       &L REPRESENTS THE LENGTH. IF 1ST CHAR IS '(', WILL BE        *\n.*       TAKEN AS REGISTER CONTAINING THE LENGTH, OTHER WISE TO       *\n.*       BE AN ACTUAL LENGTH TO BE ADDED.                             *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n&LABEL   L     &R,AVADDHIH .       GET CURRENT HIGH END POINTER\n         AIF   ('&L'(1,1) NE '(').XLENG      IF NOT REG FORM,SKIP\n         AR    &R,&L .             ADD THE LENGTH BACK\n         AGO   .XST                GO RESTORE\n.XLENG   LA    &R,&L.(&R) .        INCREMENT REGISTER\n.XST     ST    &R,AVADDHIH .       RESTORE UPDATED POINTER\n         MEND\n         TITLE '*** ASSEMBLER SYMBOL DEFINIITON MACRO - $SDEF ***'\n         MACRO\n&LABEL   $SDEF &RVAL,&RESD,&RLENG\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: $SDEF      STORE VALUES IN SYMBOL TABLE ENTRY, FLAG DEFN.*\n.*       &RVAL     REGISTER CONTAINING SYMBOL VALUE.                  *\n.*       &RESD     REGISTER CONTAINING SECTION ID OF SYMBOL.          *\n.*       &RLENG    REGISTER CONTAINING LENGTH ATTRIBUTE-1 FOR SYMBOL. *\n.*       *NOTE* SYMSECT DSECT MUST HAVE VALID USING AT TIME OF CALL.  *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n&LABEL   ST    &RVAL,SYVALUE .     DEFINE VALUE\n         STC   &RESD,SYESDID .     NOTE ESDID OF SYMBOL\n         STC   &RLENG,SYLENG .     NOTE LENGTH ATTRIBUTE\n         OI    SYFLAGS,$SYDEF .    NOTE SYMBOL NOW DEFINED\n         MEND\n         TITLE '*** $SERR - SET ERROR CODE EQUS AND MESSAGES'\n         MACRO\n&ERR     $SERR &MSG,&NM\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: $SERR      SET ERROR CODE MESSAGES AND EQU SYMBOLS.      *\n.*       CALLED 2 TIMES FOR EACH ERROR EQU, 1 TIME TO SET UP EQU, 1   *\n.*       TIME TO CREATE ERROR MESSAGE DC'S IN CSECT OUTPUT OF ASMBLER.*\n.*       &ERR      IS LAST 5 CHARACTERS OF ERROR MESSAGE EQU SYMBOL.  *\n.*       &MSG      IS THE ERROR MESSAGE ASSOCIATED WITH THE EQU.      *\n.*       &NM       IS THE ERROR CODE FOR EXTERNAL USE - AS###.        *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         GBLA  &$ERNUM,&$ERFA      # ERRORS, ADDRESS OFFSET VALUE\n         GBLA  &$OPTMS             MEMORY OPTIMIZATION\n         LCLA  &I                  LOCAL COUNTER\n         AIF   ('&SYSECT' EQ 'OUTPUT').SGEN GO TO GEN IF IN OUTPUT\n.*             GENERATE THE EQU                                       *\n&$ERNUM  SETA  &$ERNUM+2           INCREMENT # ERRORS, EQU VALUE\n$ER&ERR  EQU   &$ERNUM\n         MEXIT\n.SGEN    AIF   (&$OPTMS GT 2).SGEN1    SKIP UNLESS VERY SMALL SYSTEM\n.*             SMALL MEMORY - GEN JUST ERROR #, DON'T USE POINTERS\n.*             OR LENGTHS, SINCE LENGTHS WILL BE CONSTANT = 3.\n         DC    C'&NM'\n         AGO   .XXEXIT\n.*             GENERATE POINTER TO LENGTH-1 AND ERROR MESSAGE         *\n.SGEN1   ORG   OUERRPT+$ER&ERR\n         DC    H'&$ERFA'\n         ORG\n&I       SETA  K'&MSG+K'&NM-2      LENGTH-1 OF ERROR MESSAGE\n.SENORM  DC    AL1(&I),C'&NM ',C&MSG\n&$ERFA   SETA  &$ERFA+&I+2         INCREMENT THE OFFSET POINTER\n.XXEXIT  MEND\n         TITLE '*** $SETRT MACRO - BUILD TRT TABLE FOR SCANNING ***'\n         MACRO\n&LABEL   $SETRT &LIST\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: $SETRT     SET UP TRT TABLE FOR SCANNING IN ASSEMBLER.   *\n.*       USED INSIDE ASSIST ASSEMBLER TO CREATE TEMPORARY TRT TABLE IN*\n.*       COMMON AREA AWTZTAB (WHICH CONTAINS 256 HEX 0'S).            *\n.*       &LIST IS LIST OF CHARACTER/VALUE PAIRS, WITH CHARACTERS      *\n.*       ENCLOSED IN QUOTES.  CORRESPONDONG VALUES ARE MOVED INTO     *\n.*       CORRESPONDING LOCATIONS IN 256-BYTE TABLE OF ZEROS.          *\n.*       IF VALUE IS OMITTED, ZERO IS ASSUMED.                        *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         LCLA  &I\n         LCLC  &CH1,&CH2\n&I       SETA  1\n         AIF   (T'&LABEL EQ 'O').XNOLB\n&LABEL   DS    0H\n.XNOLB   ANOP\n&CH1     SETC  '&LIST(&I)'         GET NEXT LIST VALUE\n&CH2     SETC  '&CH1'(1,2)         GET UP TO 2 CHARS\n         AIF   ('&CH2' EQ 'X''' OR '&CH2' EQ 'C''').XGEN\n         AIF   ('&CH2'(1,1) EQ '''').XC\n&CH1     SETC  'C''&CH1'''         ADD C' ' TO ELEMENT\n         AGO   .XGEN\n.XC      ANOP\n&CH1     SETC  'C&CH1'             ADD C TO ELEMENT\n.XGEN    ANOP\n&CH2     SETC  '&LIST(&I+1)'       GET VALUE OP\n         AIF   ('&CH2' NE '').XGEN1\n&CH2     SETC  '0'                 SET TO ZERO\n.XGEN1   MVI   AWTZTAB+&CH1,&CH2\n&I       SETA  &I+2                INCREMENT\n         AIF   (&I LT N'&LIST).XNOLB         CONTINUE LOOPING\n         MEND\n         TITLE '*** MISC. UTILITY MACROS - $GTAD,$LV,$STV ***'\n         MACRO\n&LABEL   $GTAD &RG,&ENTRY\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: $GTAD      LOAD ADCON INTO REGISTER FORM AVWXTABL.       *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n&LABEL   L     &RG,AX&ENTRY\n         MEND\n         SPACE 2\n         MACRO\n&LABEL   $LV   &RG,&AD,&L=3\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: $LV        LOAD VARIABLE LENGTH VALUE INTO REGISTER(ASMB)*\n.*       LOAD VARIABLE - PLACES &L BYTES IN &RG FROM &AD              *\n.*       HIGH ORDER BYTES ARE ZEROED, USES AVFWORK1                   *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         AIF   (&L NE 3).XNO3      SKIP IF NOT 3\n&LABEL   MVI   AVFWORK1,0\n         AGO   .XMVC2              SKIP TO MOVE OVER\n.XNO3    ANOP\n&LABEL   SR    &RG,&RG .           CLEAR REG FOR ZEROS\n         ST    &RG,AVFWORK1 .      ZERO WORK WORD OUT\n.XMVC2   MVC   AVFWORK1-&L+4(&L),&AD .       MOVE BYTES OVER\n         L     &RG,AVFWORK1 .      LOAD THE REGISTER\n         MEND\n         SPACE 2\n         MACRO\n&LABEL   $STV  &RG,&AD,&L=3\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: $STV       STORE VARIABLE LENGTH VALUE FROM REGISTER (AS)*\n.*       STORE VARIABLE MACRO-STORES &L BYTES FROM LOW ORDER END OF   *\n.*       REGISTER &RG INTO ADDRESS &AD.                               *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n&LABEL   ST    &RG,AVFWORK1 .      STORE REG INTO WORK WORD\n         MVC   &AD.(&L),AVFWORK1+4-&L\n         MEND\n         TITLE '*** CONG MACRO - GEN CONSTATNT CODE TABLES(CODTL1)***'\n         MACRO\n         CONG  &C,&TYP,&LEN,&LD='''',&RD='''',&LW=1,&HI=8,&E=$CNERR\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: CONG       GENERATE CONSTANT CODE TABLE (CSECT CODTL1).  *\n.*       USED IN CODTL1 OF ASSEMBLER TO PRODUCE 1 ENTRY IN            *\n.*       CONSTANT DESCRIPTION BLOCK.  SEE CONBLK DSECT IN CODTL1.     *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         ORG   CODINXO+C'&C'       ORG INTO RIGHT SPOT IN TABLE\n         DC    AL1(CODT&C-CONTAB1) DEFINE OFFSET VALUE\n         ORG\nCODT&C   DC    AL1(&TYP+$CN&C+&E,&LEN-1,C&LD,C&RD,&LW-1,&HI-1)\n         MEND\n         TITLE '*** MACROS USED BY THE EXTENDED INTERPRETER ONLY'\n         MACRO\n&LABEL   EITAB &INS,&SYS,&IL,&CL,&TYPE,&OPC,&MODCHK,&OP1,&OP2,&D2B,    X\n               &D2H,&ALN,&R1,&R2,&ROUTINE\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: EITAB       INTERPRETER CONTROL TABLE MACRO              *\n.*                                                                    *\n.*       THIS MACRO IS USED BY THE EXTENDED INTERPRETER TO CONSTRUCT  *\n.*       A SINGLE CONTROL TABLE ENTRY.  EACH TABLE ENTRY DEFINES THE  *\n.*       DECODING NECESSARY FOR ITS CORRESPONDING INSTRUCTION(S).     *\n.*                                                                    *\n.*       IT SHOULD BE NOTED THAT:                                     *\n.*         (1)     IT IS SUGGESTED THAT ASTERISKS BE PLACED IN        *\n.*                 ARGUMENT FIELDS NOT APPLICABLE TO A PARTICULAR     *\n.*                 INSTRUCTION DECODING FORMAT.  IF THIS IS DONE,     *\n.*                 THE ARGUMENT FIELDS WILL FORM ALIGNED COLUMNS      *\n.*                 IN THE SOURCE LISTING, MAKING READING AND DE-      *\n.*                 BUGGING EASIER.                                    *\n.*         (2)     ONLY TWO ARGUMENTS ARE REQUIRED FOR EXTENDED       *\n.*                 OPCODE INSTRUCTIONS IN THE MAIN TABLE.  THESE      *\n.*                 ARE &OPC AND &ROUTINE.  THE LATTER SHOULD BE       *\n.*                 THE LABEL OF THE APPROPRIATE EXTENDED OPCODE       *\n.*                 SECONDARY TABLE (NOT THE USUAL ROUTINE LABEL).     *\n.*                 IT IS SUGGESTED THAT ALL OTHER FIELDS CONTAIN      *\n.*                 ASTERISKS.                                         *\n.*                                                                    *\n.*       ***** ARGUMENTS *****                                        *\n.*                                                                    *\n.*       &INS      = THE MNEMONIC INSTRUCTION CODE (LA,BCT,SR,ETC.)   *\n.*       &SYS      = 360 IF THE INSTR IS GOOD ON 360'S & 370'S        *\n.*                 = 370 IF THE INSTR IS GOOD ONLY ON 370'S           *\n.*       &IL       = INSTRUCTION LENGTH IN BYTES (2, 4 OR 6)          *\n.*       &CL       = AN INTEGER (1 <= &CL <= 8) SPECIFYING THE LENGTH *\n.*                   OF STORAGE MODIFIED OR FETCHED BY THIS INSTR     *\n.*                 = 0   IF THE LENGTH IS CONTAINED IN THE INST ITSELF*\n.*                   (SS INSTRUCTIONS)                                *\n.*                 = *   IF NOT APPLICABLE                            *\n.*       &TYPE     = NO  IF THIS IS NOT A PRIVILEGED INSTR            *\n.*                 = PR  IF THIS IS A PRIVILEGED INSTRUCTION          *\n.*       &OPC      = NM  IF THIS INSTR'S OPCODE IS NORMAL (8 BITS)    *\n.*                 = EX  IF THIS INSTR'S OPCODE IS EXTENDED (> 8 BITS)*\n.*       &MODCHK   = CK  IF THE STORAGE ACCESS @ AND LENGTH ARE TO BE *\n.*                   RANGE CHECKED IN THE MAIN DECODING LOOP (NEAR    *\n.*                   STMT LABEL -> EINOCHK)                           *\n.*                 = NO  IF CHECKING SHOULD NOT BE DONE IN THE MAIN   *\n.*                   DECODING LOOP                                    *\n.*                 = **  IF NOT APPLICABLE                            *\n.*       &OP1      = F   IF OPRND #1 SHOULD BE FETCH CHECKED          *\n.*                 = S   IF OPRND #1 SHOULD BE STORE CHECKED          *\n.*                 = N   IF NO CHECKING IS REQUIRED FOR OPRND #1      *\n.*                 = *   IF NOT APPLICABLE                            *\n.*       &OP2      = SAME AS &OP1, BUT FOR OPRND #2                   *\n.*       &D2B      = RR4 IF 2ND BYTE TO BE DECODED AS 2 REGS (X 4)    *\n.*                 = LL1 IF 2ND BYTE TO BE DECODED AS 2 FIELDS (X 1)  *\n.*                 = IOL IF 2ND BYTE TO BE DECODED AS 1 FIELD (X 1)   *\n.*       &D2H      = BD  IF 2ND HALFWORD @ IS ONLY BASE+DISPL         *\n.*                 = IX  IF 2ND HALFWORD @ IS BASE+DISPL+INDEX        *\n.*                 = **  IF NOT APPLICABLE                            *\n.*       &ALN      = DBL IF OPRND ALIGNMENT MUST BE DOUBLEWORD        *\n.*                 = FUL IF OPRND ALIGNMENT MUST BE AT LEAST FULLWORD *\n.*                 = HAF IF OPRND ALIGNMENT MUST BE AT LEAST HALFWORD *\n.*                 = NON IF NO ALIGNMENT NEEDED                       *\n.*                 = *** IF NOT APPLICABLE                            *\n.*       &R1       = E   IF THE R1 FIELD MUST SPECIFY AN EVEN REG     *\n.*                 = O   IF THE R1 FIELD CAN SPECIFY AN ODD REG       *\n.*                 = *   IF NOT APPLICABLE  (IF &D2B ^= RR4)          *\n.*       &R2       = SAME AS &R1, BUT FOR R2 FIELD                    *\n.*       &ROUTINE  = A STMT LABEL SPECIFYING A ROUTINE TO WHICH       *\n.*                   CONTROL IS PASSED FOLLOWING PRIMARY DECODING     *\n.*                   (E.G. - EIBAL, EILA, EINORMRR, ETC.)             *\n.*                 = A STMT LABEL OF THE SECONDARY CONTROL TABLE      *\n.*                   APPROPRIATE FOR AN EXTENDED OPCODE INSTRUCTION   *\n.*                   (SEE NOTES ABOVE ARGUMENT LISTING)               *\n.*                                                                    *\n.** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         LCLC  &BYTE               BYTES ARE BUILT WITH THIS VAR\n         SPACE 1\nEIT&INS  EQU   *                   LABEL FOR EIXTAB MACRO\n.*\n.*             CHECK IF THIS ENTRY IS FOR AN EXTENDED OPCODE INSTR --\n.*             BRANCH IF IT IS\n.*\n         AIF   ('&OPC' EQ 'EX').OPEXTD\n.*\n.*             ASSEMBLE AND GENERATE THE 1ST AND 2ND BYTES OF THIS\n.*             TABLE ENTRY  --  INCLUDING LABEL IF ANY\n.*\n&BYTE    SETC  '00001000'          INITIAL BYTE SET-UP\n         AIF   (&SYS EQ 370).OPB1A SKIP IF 370-ONLY INSTR\n&BYTE    SETC  '00001100'          ADD BIT IF 360/370 INSTR\n.OPB1A   AIF   ('&TYPE' NE 'PR').OPB1B  SKIP IF NOT A PRIV INSTR\n&BYTE    SETC  '01'.'&BYTE'(3,6)   ADD BIT IF PRIV INSTR\n.OPB1B   AIF   (&IL NE 2).OPB1C    SKIP IF NOT AN RR INSTR\n&BYTE    SETC  '&BYTE'(1,2).'1'.'&BYTE'(4,5)  ADD BIT IF RR INSTR\n         AGO   .OPB1D              NO CHECKING IF RR INSTR\n.OPB1C   AIF   (('&MODCHK' EQ '') OR ('&MODCHK' EQ '**') OR ('&MODCHK' X\n               EQ 'NO')).OPB1D     SKIP IF NO CHECKING TO BE DONE\n&BYTE    SETC  '&BYTE'(1,3).'1'.'&BYTE'(5,4)  ADD BIT IF CHECKING\n.OPB1D   ANOP\n&LABEL   DC    B'&BYTE',HL1'&IL'                                      L\n.*\n.*             1ST & 2ND BYTES GENERATED  --  NOW ASSEMBLE AND\n.*             GENERATE BYTE # 3\n.*\n&BYTE    SETC  '00000000'          INITIAL BYTE SET-UP\n.*             SET OPERAND #1 CHECKING BITS\n         AIF   (('&OP1' EQ 'N') OR ('&OP1' EQ '*')).OPB3A  SKIP IF NOCK\n&BYTE    SETC  '01000000'          AT LEAST THIS BIT IS ON\n         AIF   ('&OP1' EQ 'F').OPB3A  SKIP IF FETCH CHECKING\n&BYTE    SETC  '11000000'          SET STORE CHECK BITS ON\n.*             SET OPERAND #2 CHECKING BITS\n.OPB3A   AIF   (('&OP2' EQ 'N') OR ('&OP2' EQ '*')).OPB3B\n&BYTE    SETC  '&BYTE'(1,2).'010000'  AT LEAST FETCH BIT IS ON\n         AIF   ('&OP2' EQ 'F').OPB3B  SKIP IF FETCH CHECKING\n&BYTE    SETC  '&BYTE'(1,2).'110000'  SET STORE CHECK BITS ON\n.*             SET BIT IF THIS IS A NON-RR BRANCH INSTR\n.OPB3B   AIF   ((&IL EQ 2) AND ('&INS' NE 'XOPC')).OPB3E  SKIP IF RR\n         AIF   (('&INS' NE 'BAL') AND ('&INS' NE 'BC') AND ('&INS' NE 'X\n               BCT') AND ('&INS' NE 'BXH') AND ('&INS' NE 'BXLE')).OPB3X\n               C                   SKIP IF NOT A NON-RR BRANCH\n&BYTE    SETC  '&BYTE'(1,4).'1000' SET NON-RR BRANCH INSTR BIT ON\n.*             SET BIT FOR 2ND HALFWORD DECODING\n.OPB3C   AIF   (('&D2H' EQ '**') OR ('&D2H' EQ 'IX')).OPB3D  NOT = B+D\n&BYTE    SETC  '&BYTE'(1,5).'100'  SET BASE+DISP BIT ON\n.OPB3D   ANOP\n.*             SET BITS FOR 2ND BYTE DECODING (NOT HERE IF AN RR INSTR)\n         AIF   ('&D2B' EQ 'RR4').OPB3E     SKIP IF RR4                L\n&BYTE    SETC  '&BYTE'(1,6).'01'   ASSUME LLX1\n         AIF   ('&D2B' EQ 'LL1').OPB3E  SKIP IF LLX1\n&BYTE    SETC  '&BYTE'(1,6).'11'   SET BITS FOR IOL\n.OPB3E   ANOP\n         DC    B'&BYTE.'\n.*\n.*             1ST 3 BYTES GENERATED  --  NOW DO BYTE 4\n.*\n&BYTE    SETC  '00000000'          INITIAL BYTE SET-UP\n         AIF   (('&ALN' EQ '') OR ('&ALN' EQ 'NON') OR ('&ALN' EQ '***'X\n               )).OPB4A\n&BYTE    SETC  '00000001'          SET HALFWORD ALIGN\n         AIF   ('&ALN' EQ 'HAF').OPB4A JUMP IF NOW OK\n&BYTE    SETC  '00000011'          SET FULL WORD ALIGN\n         AIF   ('&ALN' EQ 'FUL').OPB4A JUMP IF NOW OK\n&BYTE    SETC  '00000111'          SET DOUBLEWORD ALIGN\n.OPB4A   ANOP\n         DC    B'&BYTE.'\n.*\n.*             1ST 4 BYTES GENERATED  --  NOW DO BYTE 5\n.*\n&BYTE    SETC  '00000000'          INITIAL BYTE SET-UP\n         AIF   ('&D2B' NE 'RR4').OPB5B  SKIP IF NO REGS TO CHK\n         AIF   ('&R1' NE 'E').OPB5A  SKIP IF R1 CAN BE ODD\n&BYTE    SETC  '00010000'          SET BIT FOR R1 EVEN\n.OPB5A   AIF   ('&R2' NE 'E').OPB5B  SKIP IF R2 CAN BE ODD\n&BYTE    SETC  '&BYTE'(1,4).'0001' SET BIT FOR R2 EVEN\n.OPB5B   ANOP\n         DC    B'&BYTE.'\n.*\n.*             1ST 5 BYTES GENERATED  --  NOW DO BYTE 6\n.*             AND THE HALFWORD DISPL TO THE ROUTINE\n.*\n&BYTE    SETC  '0'                 INITIAL BYTE SET-UP\n         AIF   (('&CL' EQ '*') OR ('&CL' EQ '') OR ('&CL' EQ '0')).OPB6X\n               A\n&BYTE    SETC  '&CL'\n.OPB6A   ANOP\n         DC    HL1'&BYTE.',AL2(&ROUTINE.-EISPEJMP)\n         SPACE 1\n         MEXIT\n.*\n.*             EXTENDED OPCODE IF HERE -- GENERATE TABLE ENTRY\n.*\n.OPEXTD  ANOP\n&LABEL   DC    B'10000000',XL3'0',A(&ROUTINE)                         L\n         SPACE 1\n         MEND\n         EJECT\n         MACRO\n&LABEL   EIXTAB  &L1,&L2,&L3,&L4,&L5,&L6,&L7,&L8\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO:  EIXTAB       INTERPRETER SECONDARY CONTROL TABLE MACRO  *\n.*                                                                    *\n.*             THIS MACRO IS USED BY THE EXTENDED INTERPRETER TO      *\n.*             GENERATE THE 256 BYTE SECONDARY TABLE.  THIS TABLE IS  *\n.*             INDEXED INTO BY THE OPCODE OF THE INSTRUCTION BEING    *\n.*             EXECUTED.  EACH TABLE ENTRY CONTAINS A DISPLACEMENT    *\n.*             INTO THE MAIN DECODING TABLE.  INVALID OPCODES ALSO    *\n.*             ARE GIVEN DISPLACEMENTS INTO THE TABLE.  THESE         *\n.*             POINT TO ZERO ENTRIES IN THE MAIN TABLE NOTING THE     *\n.*             THE OPCODES AS BEING INVALID.  THE NUMBER OF           *\n.*             PARAMETERS USED FOR A CALL TO THIS MACRO IS 8.  IF     *\n.*             8 ARE NOT USED AN MNOTE IS GIVEN AND THE GENERATION    *\n.*             FOR THAT MACRO CALL IS TERMINATED.  THE PARAMETERS     *\n.*             SHOULD EACH BE THE MNEMONIC OF THE INSTRUCTION OR      *\n.*             THE NAME OF THE GROUP OF INSTRUCTIONS REPRESENTED.     *\n.*             THESE NAMES MUST CORRESPOND TO NAMES IN THE MAIN       *\n.*             TABLE.  NUMERIC PARAMETERS SHOULD BE USED FOR ALL      *\n.*             ILLEGAL OPCODES.  THESE SHOULD BE A 2, 4 OR 6          *\n.*             DEPENDING ON THE LENGTH OF THE ZERO MAIN TABLE ENTRY   *\n.*             BEING INDEXED.                                         *\n.*                                                                    *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         LCLA  &L\n&LABEL   DC    0C' '\n         AIF   (N'&SYSLIST EQ 8).EILOOP\n         MNOTE 30,'***** EIGHT INSTRUCTIONS NOT SPECIFIED - ERROR ****'\n         MEXIT\n.EILOOP  ANOP\n&L       SETA  &L+1\n         AIF   (T'&SYSLIST(&L) NE 'N').EINONUM\n         AIF   ((&SYSLIST(&L) EQ 2) OR (&SYSLIST(&L) EQ 4) OR (&SYSLISTX\n               (&L) EQ 6)).EINONUM\n         MNOTE 30,'*** NUMERIC VALUE SPECIFIED NOT EQUAL 2, 4, 6 ***'\n         MEXIT\n.EINONUM ANOP\n         DC    AL1((EIT&SYSLIST(&L).-EICONTAB)/8)\n         AIF   (&L LT 8).EILOOP\n         MEND\n         TITLE '*** EVCG TABLE - GENERATE ROW OF EVALUT TRANSITION TAB'\n         MACRO\n         CROSSET  &NUM\n         GBLB  &$XREF              CONTROLS GENERATION OF MACRO\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: CROSSET               MACRO TO SET FLAGS FOR XREF        *\n.*  THIS MACRO IS USED IN THE ICMOP2 CSECT AND IS CALLED EVERY TIME   *\n.*  A NEW OPERAND IS SCANNED.  IT SETS THE INSTRUCTION TYPE           *\n.*  AND THE FLAG AVXRTYPE.                                            *\n.*    &NUM ==>  # OF OPERAND BEING SCANNED.  CONTROLS TESTING         *\n.*              OF CORRECT FLAG.                                      *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         AIF   (NOT &$XREF).NOXREF SKIP IF NOT CROSS REFERENCE\n         OI    AVXRTYPE,AVXRFTCH .  SET BIT ON\n         TM    AVXRMDFT,AVXRMOD&NUM  .  SEE IF MODIFY REFERENCE\n         BZ    *+8                 NO SKIP RESETING\n         NI    AVXRTYPE,X'FF'-AVXRFTCH  .  TURN OFF FLAG\n.NOXREF  MEND\n         SPACE 5\n         MACRO\n&LABEL   EVCG  &L\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: EVCG       CREATE ROW OF TRANSITION TABLE (CSECT EVALUT) *\n.*       &L        LIST OF PAIRS- JUMP LABEL,(ERROR CODE OR STATE #). *\n.*       CREATES 1 ROW OF TABLE EVCTAB IN GENERAL EXPRESSION EVALUATOR*\n.*       CSECT EVALUT.  SEE EVCTDSCT DSECT FOR ENTRIES IN EACH ROW.   *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         LCLA  &I                  LOCAL COUNTER\n&I       SETA  1                   INIT\n&LABEL   DS    0H\n.EVCA    AIF   (T'&L(&I+1) EQ 'N').EVCC     JUMP IF IT IS STATE #\n         DC    AL1(EV&L(&I)-EVDJUMP,$ERV&L(&I+1)) .   OFFSET,ERROR\n         AGO   .EVCE\n.EVCC    DC    AL1(EV&L(&I)-EVDJUMP,EVCT&L(&I+1)-EVCTAB)\n.EVCE    ANOP\n&I       SETA  &I+2                INCREMENT BY 2 FOR NEXT PAIR\n         AIF   (&I LT N'&L).EVCA   GO BACK IF THERE'S MORE\n         MEND\n         TITLE '*** TABLE GENERATION MACROS -IBPRTAB, ICT ***'\n         MACRO\n&LABEL   IBPRTAB &OP,&VO,&VX\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: IBPRTAB    GENERATE 1 BLOCK FOR PRINT SCAN LIST          *\n.*.      USED ONLY IN IBASM1. CREATES 1 BLOCK: DSECT IBPSCECT         *\n.*.      &OP       OPERAND NAME (ON, OFF, ETC).                       *\n.*.      &VO       VALUE TO BE OR'D INTO PRINT BYTE: BIT TO SET ON/OFF*\n.*.      &VX       VALUE TO BE XOR'D INTO PRINT CONTROL: EITHER 0     *\n.*.                IF BIT ON (&VX OMITTED), OR SAME AS &VO IF * CODED.*\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         LCLA  &K                  FOR COUNT\n         LCLC  &C                  FOR &VX VALUE\n&K       SETA  K'&OP-1             GET #-1 OF CHARS IN OPERAND\n&C       SETC  '0'                 ASSUME &VX OMITTED\n         AIF   ('&VX' EQ '').IB1   SKIP IF WAS OMITTED\n&C       SETC  '&VO'               DUPLICATE VALUE OF EQUATE\n.IB1     ANOP\n&LABEL   DC    AL1(&K,&VO,&C),C'&OP'\n         MEND\n         SPACE 4\n         MACRO\n&LABEL   ICT   &TYPE,&VALUE\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: ICT        CREATE CONTROL CODES(ICYFLAG) VALUES(ICMOP2). *\n.*       &TYPE     TYPE OF INSTRUCTION FORMAT ($RR,$RX,ETC).          *\n.*       &VALUE    VALUE OF CODE REQUIRED FOR TABLE.                  *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         ORG   ICTTAB+&TYPE/2\n&LABEL   DC    AL1(&VALUE)\n         MEND\n         TITLE '*** OPG MACRO - GENERATE OPCODTB ENTRY FOR OPCOD1 ***'\n         MACRO\n         OPG   &MNEM,&TYPE,&HEX,&MASK,&CODE\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: OPG        CREATE 1 ENTRY IN ASM OPCODE TABLE (OPCOD1).  *\n.*       THE GENERATED ENTRY IS DESCRIBED BY DSECT OPCODTB.           *\n.*       GENERATES THE 4 FIELDS OF AN OPCODTB ENTRY - OPCTYPE,OPCHEX, *\n.*       OPCMASK, AND OPCMNEM.  IF &HEX OR &MASK ARE OMITTED,THEY     *\n.*       ARE ASSUMED TO BE 0.   &CODE IS USED FOR INSTRUCTIONS WHICH  *\n.*       MAY NOT BE GENERATED. IF USED , IT IS 'D' FOR DECIMAL INSTS, *\n.*       'F' FOR FLOATING POINT INSTRUCTIONS, AND 'P' FOR PRIVILEGED  *\n.*       OPERATIONS.  IF THE SPECIFIED TYPE IS NOT TO BE GENERATED,   *\n.*       THE APPROPRIATE GLOBAL VARIABLE WILL HAVE BEEN SET, AND THE  *\n.*       OPCODTB ENTRY WILL NOT BE CREATED.                           *\n.*       &CODE = 'M' FOR MACRO OPCODES.                               *\n.*       &CODE = 'FX' FOR EXTENDED FLOATING POINT OPCODES.            *\n.*       &CODE = 'S370' FOR NON-PRIVILEGED S/370 OPCODES.             *\n.*       &CODE = 'P370' FOR PRIVILEGED S/370 OPCODES.                 *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         GBLB  &OPNGN(8)           USED TO KNOW IF LENGTH HAS BEEN USED\n         GBLB  &$DECSA,&$FLOTA,&$PRIVOP      GENERATION STATUS VARS\n         GBLB  &$MACROS            =1 GEN MACRO OPCODES\n         GBLB  &$FLOTAX            =1 GEN EXTENDED FP OPCODES\n         GBLB  &$S370A             =1 GEN NON-PRIVILEGED S/370 OPCODES\n         GBLB  &$P370A             =1 GEN PRIVILEGED S/370 OPCODES\n         AIF   (T'&CODE EQ 'O').XNOC         SKIP IF NO CODE USED\n         AIF   ('&CODE' EQ 'F' AND NOT &$FLOTA).XEXIT  SKIP IF NOTFLOAT\n         AIF   ('&CODE' EQ 'FX' AND NOT &$FLOTAX).XEXIT SKIP IF NO EXFP\n         AIF   ('&CODE' EQ 'D' AND NOT &$DECSA).XEXIT  SKIP IF NO DECS\n         AIF   ('&CODE' EQ 'P' AND NOT &$PRIVOP).XEXIT SKIP IF NO PRIVS\n         AIF   ('&CODE' EQ 'M' AND NOT &$MACROS).XEXIT SKIP IF NO MACRS\n         AIF   ('&CODE' EQ 'S370' AND NOT &$S370A).XEXIT SKIP IF NO 370\n         AIF   ('&CODE' EQ 'P370' AND NOT &$P370A).XEXIT SKIP IF NO PRV\n.XNOC    ANOP\n&OPNGN(K'&MNEM) SETB 1       NOTE THAT ONE OF THIS LENGTH HAS BEEN USED\n         AIF   ('&HEX' EQ '' OR '&MASK' EQ '').XNOQ    SKIP IF OMITTED\n         DC    AL1(&TYPE,&HEX,&MASK),C'&MNEM'\n         MEXIT\n.XNOQ    AIF   (T'&HEX EQ 'O').XNOX    SKIP IF HEX OMITTED.\n         DC    AL1(&TYPE,&HEX,0),C'&MNEM'\n         MEXIT\n.XNOX    AIF   (T'&MASK EQ 'O').XNOMSK SKIP IF MASK FIELD OMITTED\n         DC    AL1(&TYPE,0,&MASK),C'&MNEM'\n         MEXIT\n.XNOMSK  DC    AL1(&TYPE,0,0),C'&MNEM'\n.XEXIT   MEND\n         TITLE '*** OPGT MACRO - GENERATE OPCOD1 POINTER TABLES ***'\n         MACRO\n         OPGT\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: OPGT       CREATE 2ND LEVEL OPCODE PTR TABLES (OPCOD1).  *\n.*       USES MACROS: $AL2                                            *\n.*       NOTE &OPNGN VALUES WERE SET BY OPG MACRO. CALLED 1 TIME ONLY.*\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         GBLB  &OPNGN(8)           LENGTH TAGS\n         LCLC  &O                  PREFIX CHARACTERS\n         LCLA  &I                  LOOP COUNTER\n.OPLOOP  ANOP\n&I       SETA  &I+1                INCREMENT TO NEXT LENGTH\n         AIF   (&OPNGN(&I)).OPGEN1 GENERATE, IF ANY WERE USED\nOPF&I    EQU   OPADS .             NAME FOR UNUSED # OF LETTERS\n         AGO   .OPBOT              GO TO BOTTOM OF LOOP\n.OPGEN1  ANOP\n&O       SETC  'OP&I'              GET PREFIX CHRACTERS\nOPF&I    $AL2  OPFIND,                                                 X\n               (&O.A,&O.B,&O.C,&O.D,&O.L,&O.M,&O.N,&O.S,&O.T,&O.END)\n.OPBOT   AIF   (&I LT 8).OPLOOP    CONTINUE LOOPING\n         MEND\n         TITLE 'REPRNT MACRO - PRINT MACRO FOR REMONI INTERNAL USE'\n         MACRO\n&LABEL   REPRNT &MSG,&MSGL\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: REPRNT     PRINT MESSAGE MACRO FOR REMONI USE            *\n.*       &MSG  GIVES RX-TYPE ADDRESS OF MESSAGE TO BE PRINTED.        *\n.*       &MSGL GIVES LENGTH OF THE MESSAGE TO BE PRINTED.             *\n.*       MODIFIES REGISTERS  R7, R8, R14.                             *\n.*       CALLS INSUB, REXPRINT.                                       *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n&LABEL   LA    R7,&MSG   .         SHOW @ MESSAGE\n         LA    R8,&MSGL   .        SHOW LENGTH OF MESSAGE\n         BAL   R14,REXPRINT .      CALL THE INSUB\n         MEND\n         TITLE 'RFSGN MACRO - GENERATES 1 ENTRY IN TABLE CSECT RFSYMS'\n         MACRO\n&LABEL   RFSGN &CSECT,&ENTRY,&TYPE=0\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: RFSGN      GENERATE 1 ENTRY OF REPLACE NAME TABLE(RFSYMS)*\n.*             RFSGN MACRO IS USED TO GENERATE THE PRIMARY TABLE      *\n.*       OF CSECT NAMES AND THEIR ENTRY POINT NAMES, WHICH IS USED TO *\n.*       DO REPLACEMENT AND CHECKING OF STUDENT-WRITTEN CSECTS.       *\n.*             IF &$REPL=2 AND TYPE=2, RFSGN CREATES AN ELEMENT IN    *\n.*       THE SECOND SECTION OF RFSYMS, WHICH DESCRIBES A CALLABLE     *\n.*       ENTRYPOINT IN REAL ASSIST ROUTINES.                          *\n.*       &CSECT    NAMES A CSECT WHICH CAN BE REPLACED.               *\n.*             IF TYPE=2, NAMES A CALLABLE ENTRY FOR 2ND SECTION.     *\n.*       &ENTRY    IS A LIST OF 1 OR MORE ENTRY POINT NAMES IN &CSECT.*\n.*             IF TYPE=2, THIS ONE IS OMITTED.                        *\n.*       &TYPE     = 1 IF &CSECT MAY CALL OTHER CSECTS, OMITTED IF NOT*\n.*             =2 IF CALL IS TO CREATE CALLABLE ENTRY ELEMENT.        *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         GBLA  &$REPL              REPLACE VAR. 0=NONE, 1=LIMITED\n         LCLA  &I,&N               INDEX, L'&ENTRY\n         LCLC  &EN                 TEMPORARY ENTRY NAME FOR CONVENINCE\n         AIF   ('&TYPE' NE '0' AND &$REPL NE 2).RFSB  SKIP IF NOT LIM R\n         AIF   ('&TYPE' EQ '2').RFSA2       SKIP IF TYPE 2 ELEMENT\n&N       SETA  N'&ENTRY            GET # ENTRIES, >= 1\n.*             RFSYMB,RFSENTN,RFSENTL,RFSTYPE.\n&LABEL   DC    CL6'&CSECT',AL1(&N,RFS$LEN*(&N+1))\n         AIF   ('&TYPE' EQ '0').RFSA1       SKIP IF CAN'T CALL OTHER\n         DC    AL2(RI&CSECT-RFSYMS)    REPLACE CSECT WHICH CAN CALL\n         AGO   .RFSA               GO BACK FOR NEXT\n.RFSA1   DC    AL2(0)\n.RFSA    AIF   (&I GE &N).RFSB     JUMP OUT IF NO MORE ENTRIES\n&I       SETA  &I+1                INCREMENT INDEX TO ENTRIES\n.*             RFSYMB,RFSAXPT,RFSRGPT,RFSRHPT.\n&EN      SETC  '&ENTRY(&I)'        GET ENTRY, FOR CONVENIENCE\n         DC    CL6'&EN',AL2(AX&EN-AX$BASE,RG&EN-RG$BASE)\n         AGO   .RFSA\n.RFSA2   ANOP\nRF&CSECT DC    CL6'&CSECT',AL2(AX&CSECT-AX$BASE,RH&CSECT-RH$BASE)\n.RFSB    SPACE 1\n         MEND\n         TITLE '*** WCONG MACRO - GENERATE CONST.ADDR OFFSET TABLE ***'\n         MACRO\n         WCONG &C\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: WCONG      CREATE OFFSETS TO CONSTANT SUBR ADCONS-VWXTABL*\n.*       CREATE WCONADS TABLE IN VWXTABL FOR USE OF CODTL1 AND CNDTL2 *\n.*       IN DOING TABLE-DRIVEN CONSTANT PROCESSING. CALLED 1 TIME ONLY*\n.*       &C        LIST OF CONSTANT TYPES ALLOWED.    (A,B,C, ETC).   *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         LCLA  &I                  COUNTER\n         AIF   ('&SYSECT' NE 'VWXTABL').XXEXIT         SKIP IF NOT VWXT\n.LOOP    ANOP\n&I       SETA  &I+1                INCREMENT TO NEXT 1\n         ORG   WCONADS+$CN&C(&I)   ORG TO ADCON SPOT\n         DC    AL1(AXC&C(&I).CON1-AXC$BASE)\n         AIF   (&I LT N'&C).LOOP   LOOP UNTIL DONE\n         ORG\n.XXEXIT  MEND\n         TITLE '$TIRC MACRO - TIME OR RECORS -USED OR REMAINING(PSU)'\n         MACRO\n&LABEL   $TIRC &TYPE\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: $TIRC      GET TIME/RECORDS DATA FROM OPERATING SYSTEM.  *\n.*             THIS MACRO USES PSU SVC CALL 250 TO OBTAIN TIME OR     *\n.*       RECORDS INFORMATION.  &TYPE IS TIMREM,TIMUSE,RECREM,RECUSE.  *\n.*       RESULT IS RETURNED IN R0, IN EITHER RECORDS, OR IN TIMER     *\n.*       UNITS OF 26.04 MICROSECOND.  DESTROYS R0,R1,R15.             *\n.*       *NOTE* MAY HAVE TO BE REWRITTEN FOR LOCAL CONDITONS.         *\n.*       &TYPE CAN ALSO BE OF FORM  (NAME,ADDR)  WHERE ADDR IS AN     *\n.*       RX-TYPE ADDRESS, AT WHICH THE MACRO PLACES THE FOLLOWING:    *\n.*       BYTES  0-4  : ACCOUNT NUMBER       .... INFORMATION FROM     *\n.*       BYTES  5-12 : JOB NAME             .... FROM                 *\n.*       BYTES 13-32 : PROGRAMMER NAME      .... JOB CARD             *\n.*       THIS FORM NEEDED ONLY IF &$ACCT=1,  AND IS COMPLETELY LOCAL  *\n.*       TO PSU CC, THUS MUST BE REWRITTEN IF USED ELSEWHERE.         *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         AIF   ('&TYPE(1)' NE 'NAME').TIMREC          SKIP IF NOT NAME\n         CNOP  0,4                 ALIGN FOR LATER ADCON\n&LABEL   LA    R1,&TYPE(2)  .      GET @ WHERE INFO TO BE PUT\n         ST    R1,*+8 .            STORE INTO PARAMATER LIST\n         BAL   R1,*+8 .            SET R1==> ADCON, SKIP AROUND\n         DS    A .                 FOR @ AREA FOR INFORMATION\n         SR    R15,R15             R15 = 0 PART OF CONVENTION\n         SR    R0,R0 .             SET R0 TO 0 FOR NAME CALL\n         BCTR  R0,0 .              SET R0 TO -1==> WANT NAME\n         SVC   250 .               GET ACCOUNTING INFO****PSU CC*******\n         AGO   .XXEXIT             QUIT GENERATING\n.TIMREC  ANOP\n         AIF   ('&TYPE'(1,3) EQ 'TIM').TIM  SKIP IF TIME DESITRED\n&LABEL   SR    R0,R0\n         SR    R15,R15\n         SVC   250 .               MAKE RECORD CALL\n         AIF   ('&TYPE'(4,3) EQ 'USE').XXEXIT         SKIP IF DONE\n         LR    R0,R1 .             MOVE RECORDS REMAINING OVER\n         MEXIT\n.TIM     ANOP\n&LABEL   LA    R0,1\n         SR    R15,R15\n         SVC   250 .               MAKE CALL FOR TIME INFO\n         AIF   ('&TYPE'(4,3) EQ 'USE').TIM2 SKIP IF IN RIGHT REG\n         LR    R0,R1 .             MOVE TIME REMAINING OVER\n.TIM2    SLL   R0,2 .              *4 FOR # 26.04 MIC TIMER UNITS\n.XXEXIT  MEND\n         TITLE 'APCGN MACRO - GENERATE APCBLK IN CSECT APARMS'\n         MACRO\n&LABEL   APCGN &PARM,&AJOFS,&BITS,&C=0,&N=0,&D=0,&I1=0,&Y=0,&G=1,&GC=0,#\n               &LK=111\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: APCGN      GENERATE 1 APCBLK ELEMENT IN APARMS           *\n.*       GENERATES BLOCK FOR PARM OPTION SCANNING CONTROL, DEPENDING  *\n.*       ON DESIRED CHARACTERISTICS OF THE PARM. MAY SKIP GENERATION  *\n.*       IF THE REQUIRED OPTION DOES NOT EXIST IN PARTICULAR SYSTEM.  *\n.*       ***SEE DSECT APCBLK AND CSECT APARMS (FROM LABEL APFOUND)    *\n.*       FOR FURTHER INFORMATION ON HANDLING OF BLOCK CREATED BY THIS.*\n.*  &PARM      NAME OF THE PARM OPTION.                               *\n.*  &AJOFS     NAME OF VARIABLE IN AJOBCON TO BE SET BY THIS PARM     *\n.*  &BITS      VALUE USED TO SET FLAG FOR YES/NO TYPE PARMS.          *\n.*       IF =PARM AND NOT CALL TYPE, SHOULD BE GIVEN VALUE 0.         *\n.*  &G,&GC     USED TO CONTROL GENERATION.  GENERATION IS SKIPPED     *\n.*       IF &G EQ &GC, THUS ALLOWING CONDITIONAL ASSEMBLY OF PARMS.   *\n.*       &C THRU &Y GIVE TYPE BITS TO BE PLACED INTO APCFLAG.  EACH   *\n.*       CORRESPONDS TO 1 OR MORE EQU SYMBOLS, AS LISTED.             *\n.*  &C         =1 IF PARM IS NONSTANDARD AND A ROUTINE MUST BE CALLED.*\n.*       APPLIES ONLY TO =VALUE TYPE PARMS.  THE ROUTINE CALLED MUST  *\n.*       BE NAMED APA&PARM.                           (APCCALL)       *\n.*  &N         =1 IF VALUE CANNOT BE GIVEN ANOTHER VALUE ONCE IT HAS  *\n.*       BEEN SET ONCE.  MAY BE USED BY ANY PARM TYPE.(APCNRSET)      *\n.*  &D         =1 IF PARM IS PARM=DECIMAL VALUE.  IF THIS IS CODED    *\n.*       AND PARM IS NOT A SPECIAL CALL TYPE, THEN IT IS ASSUMED THAT *\n.*       THE VALUE CONVERTED IS TO BE STORED AS A FULLWORD AT THE     *\n.*       GIVEN VARIABLE LOCATION IN AJOBCON.          (APCD)          *\n.*  &I1        =1 IF PARM IS A YES/NO TYPE AND  1BIT ON CORRESPONDS   *\n.*       TO A YES VALUE (1BIT MEANS NO OTHERWISE).    (APCYES1B)      *\n.*             =1 IF PARM IS =DECIMAL # PARM, AND MAY NEVER BE        *\n.*       INCREMENTED AFTER IT HAS BEEN SET (BUT MAY BE DECREASED).    *\n.*       USED PARTICULARLY FOR TIME/RECORDS LIMITS.   (APCNINCR)      *\n.*  &Y         =1 IF THE PARM IS A YES/NO TYPE.  OTHERWISE, IT IS     *\n.*       AN =PARM OF SOME SORT.                       (APCYESNO)      *\n.*  &LK        DENOTES WHICH OF THE POSSIBLE CALLS IS ALLOWED TO SET  *\n.*       A VALUE FOR THE GIVEN PARM.  CONSISTS OF 3 BITS: ###, WITH   *\n.*       MEANINGS AS FOLLOW:                                          *\n.*       100   CAN BE SET BY LIMIT OR DEFAULT VALUE  (APCSETLD)       *\n.*       010   CAN BE SET FROM THE PARM FIELD         (APCSETP)       *\n.*       001   CAN BE SET BY USER FROM $JOB CARD      (APCSETU)       *\n.*             THIS MACRO USED ONLY IN APARMS CSECT.                  *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         AIF   ('&G' EQ '&GC').XXEXIT       SKIP IF FLAGGED THAT WAY\n&LABEL   DC    CL(APCP$L)'&PARM',B'&LK&C&N&D&I1&Y',AL1(&AJOFS-AJO$APC)\n         DC    B'0'\n         AIF   (&C EQ 1).APCC      SKIP IF CALL TYPE\n         DC    AL1(&BITS)\n         MEXIT\n.APCC    DC    AL1(APA&PARM-APAJUMP)\n.XXEXIT  MEND\n         TITLE '*** ASSIST CSECT MACROS: ASPRNT,ASTIME ***'\n         MACRO\n&LABEL   ASPRNT &XAREA,&XNUM\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: ASPRNT     PRINT LINE INSIDE MAIN PROG ASSIST.           *\n.*       ASPRNT SETS UP R0=@ LINE, R1=LENG, CALLS INSUB ASASPRNT OF   *\n.*       ASSIST.  MODIFIES REGS R0,R1,R14.                            *\n.*       &XAREA,&XNUM SAME AS THOSE FOR $PRNT = @, LENGTH TO PRINT.   *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n&LABEL   LA    R0,&XAREA  .        SHOW @ PRINT AREA\n         AIF   ('&XNUM'(1,1) EQ '(').ASREG  SKIP IF REGISTER FORM\n         LA    R1,&XNUM  .         SHOW LENGTH\n         AGO   .ASBAL\n.ASREG   LR    R1,&XNUM  .         MOVE LENGTH REGISTER VALUE OVER\n.ASBAL   BAL   R14,ASASPRNT .      CALL INSUB ASPRNT\n         MEND\n         SPACE 2\n         MACRO\n&LABEL   ASTIME &ASH,&VALUE\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: ASTIME     UPDATE TIMER,PRINT TIMING MESSAGES(ASSIST).   *\n.*       &ASH      NAME OF MESSAGE, IF OMITTED UPDATE TIMER ONLY.     *\n.*       &VALUE    NAME OF VALUE TO BE CONVERTED, OMITTED-NO 2ND PART *\n.*       *NOTE* ONLY USABLE INSIDE MAIN PROGRAM ASSIST.               *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         AIF   (T'&ASH NE 'O').ASCALL1       SKIP IF OPERAND USED\n&LABEL   SR    R2,R2 .             SHOW ASTIMER JUST UPDATE TIMER\n         AGO   .ASCALL2            GO HAVE BAL GENREATED\n.ASCALL1 ANOP\n&LABEL   LA    R2,&ASH .           ENTER @ AREA TO BE PRINTED\n         LA    R3,&ASH.P\n         LA    R4,&ASH.L  .        LENGTH OF MESSAGE TO BE PRINTED\n         AIF   ('&VALUE' EQ '').ASCNV       SKIP IF NO VALUE\n         LA    R6,&ASH.N .         SHOW @ WHERE STMT/SEC GOES\n         AIF   ('&VALUE' EQ '*').ASCALL2    SKIP IF VALUE ALREADY IN\n         L     R7,&VALUE .         GET VALUE TO BE CONVERTED\n         AGO   .ASCALL2\n.ASCNV   SR    R6,R6 .             SHOW THERE IS NO 2ND PART MESSAGE\n.ASCALL2 BAL   R14,ASTIMER .       CALL TEST TIMER ROUTINE\n         MEND\n         TITLE '*** ASSIST MACROS: ASPAGE,ASRECL,ASTIMR ***'\n         MACRO\n         ASPAGE &CODE\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: ASPAGE     LINK TO SECTION OF PAGE CONTROL CODE          *\n.*       &CODE IS TWO-DIGIT # GIVING DESIRED SECTION OF PAGE CONTROL  *\n.*       CALL IS GENERATED ONLY IF &$PAGE = 1.                        *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         GBLB  &$PAGE              =1 PAGE CONTROL CODE EXISTS\n         AIF   (NOT &$PAGE).XXEXIT SKIP IF NO PAGE CODE EXISTS\n         BAL   R9,ASPAGE&CODE .    CALL SECTION OF ASPAGE##\n.XXEXIT  MEND\n         SPACE 2\n         MACRO\n         ASRECL &CODE\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: ASRECL     LINK TO RECORD LIMIT CONTROL CODE             *\n.*       &CODE IS TWO DIGIT NUMBER GIVING SECTION OF ASRECL## CALLED  *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         BAL   R9,ASRECL&CODE .    CALL SECTION OF ASRECL##\n         MEND\n         SPACE 2\n         MACRO\n&LABEL   ASTIMR &CODE,&TLEVEL\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: ASTIMR     LINK TO TIMER ROUTINES IN MAIN PROGRAM ASSIST *\n.*       ASTIMR ALLOWS FOR CONDITIONAL GENERATION OF CALLS TO         *\n.*       VARIOUS TIMING MODULES INSIDE ASSIST MAIN PROGRAM, DEPENDING *\n.*       ON THE DESIRED TIMING METHOD BEING USED.                     *\n.*       &CODE  IS 2-DIGIT CODE, GIVING SECTION OF ASTIMR TO BE CALLED*\n.*       &TLEVEL IS 0,1,2.  NO CODE IS CREATED IF &$TIMER<&TLEVEL.    *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         GBLA  &$TIMER             TIMER LEVEL BEING USED\n&LABEL   DS    0H\n         AIF   (&$TIMER LT &TLEVEL).XXEXIT  SKIP IF NOT IN USE\n         BAL   R9,ASTIMR&CODE .    CALL ENTRY OF ASTIMR## CODE\n.XXEXIT  MEND\n         TITLE '*** XCALL - OS LINKAGE, LITERAL VCON ***'\n         MACRO\n&LABEL   XCALL &ENTRY\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: XCALL      SUBROUTINE CALL, OS LINKAGE, LITERAL FORM.    *\n.*       &ENTRY    NAME OF ENTRYPOINT TO BE CALLED.                   *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n&LABEL   L     REP,=V(&ENTRY) .    GET @ ENTRY POINT\n         BALR  RET,REP .           CALL THE ROUTINE\n         MEND\n         TITLE '*** GLOBAL SET SYMBOLS AND EQUATES ***'\n**       GLOBAL SET VARIABLES - SYSGEN TYPE - &$------                *\n         GBLB  &$ACCT              =1 => ACCOUNT DISCRIMINATION POSSIBL\n         GBLB  &$ALIGN             =0 ==> MODEL REQUIRES DATA ALIGNED\n*                                  =1 ==> MODEL DOES NOT REQUIRE ALIGN\n         GBLB  &$ASMLVL            =0==>DOS,=1==>OS\n         GBLC  &$BATCH             LIMIT/DFLT: BATCH(DOS) - NOBATCH(OS)\n         GBLC  &$BTCC(4)           BATCH CONTROL CARD ITEMS: SEE SETC'S\n         GBLA  &$BLEN              SET TO BUFFER LENGTH IN BYTES\n         GBLA  &$BUFNO             THE NUMBER OF BUFFERS\n         GBLB  &$CMPRS             =0 NO CMPRS CODE, =1 CMPRS OPTION\n         GBLA  &$COMNT             >0 COMMENT CHECK (&$COMNT % REQ)\n         GBLB  &$DATARD            =0 SOURCE,DATA THRU SYSIN ONLY(WATFV\n*                                  =1 DATA MAY BE READ FROM FT05F001\n*                                  (I.E.- SINGLE JOB PROCESSING-PSU)\n         GBLB  &$DECSA             SHOULD ASSEMBLER PERMIT DECIMALS\n         GBLB  &$DECSM             DOES MACHINE HAVE DECIMALS\n         GBLB  &$DECK              =0 NO OBJ DECKS PUNCHED. =1 CAN DO\n         GBLB  &$DMPAG             =1 BEGIN DUMP ON NEW PAGE, 0=> NO  J\n         GBLC  &$DSKUDV            DEVICE TYPE FOR DISK DEFAULT TO\n*                                  2314 DISK DRIVE\n         GBLA  &$DISKU             0 FOR NO DISK UTILITY\n*                                      1 FOR USER OPTION\n*                                      2 FOR ALWAYS DISK\n         GBLB  &$FLOTA             SHOULD ASSEMBLER ALLOW FLOATING PT\n         GBLB  &$FLOTAX            SHOULD ASSEMBLER ALLOW EXTENDED FP'S\n         GBLB  &$DEBUG             0==>DEBUG MODE, 1==> PRODUCTION MODE\n         GBLA  &$ERNUM             # DIFFERENT ERROR MESSAGES\n         GBLB  &$EXINT             = 0 REGULAR INTERPRETER\n*                                  = 1 EXTENDED INTERPRETER\n         GBLB  &$FLOTE             =1==> WILL INTERPRET FLT,0==> NO\n         GBLB  &$FLOTEX            =1==> WILL INTERPRET EX FP'S,0==> NO\n         GBLB  &$FLOTM             =1==> MACHINE HAS FLTING PT,0==> NO\n         GBLB  &$FLOTMX            =1==> MACHINE HAS EX FP'S,0==> NO\n         GBLA  &$FREE,&$FREEMN     DEFAULT FREE=, MINIMUM FREE= (80A) J\n         GBLC  &$GENDAT            GENERATATION DATE FOR THIS ASSIST\n         GBLB  &$HASPBT            =1 HASP AUTOBATCH CODE SUPPORTED   J\n         GBLB  &$HEXO              =1==> HEXO ALLOWED,=0==> NOT ALLOWED\n         GBLB  &$HEXI              =1==> HEXI ALLOWED,=0==> NOT ALLOWED\n         GBLA  &$IDF,&$IMX         DEFAULT,MAXIMUM I= # INSTRUCTIONS\n         GBLC  &$IOUNIT(8)         GLOBAL SUBLISTED VARIABLE FOR\n*                                  DDNAMES IN DCB'S AND DTF'S\n*\n*        &$IOUNIT(1)= PRIMARY INPUT, OS=> SYSIN, DOS=> SYSIPT\n*        &$IOUNIT(2)= SECONDARY INPUT, OS=> FT05F001, DOS=> SYSRDR\n*        &$IOUNIT(3)= PRINTER, OS=>FT06F001, DOS=> SYSLST\n*        &$IOUNIT(4)= PUNCH, OS=> FT07F001, DOS=> SYSPCH\n*        &$IOUNIT(5)= DISK INTERMEDIATE, OS=>FT08F001, DOS=> IJSYS01\n*        &$IOUNIT(6)= MACRO LIBRARY, OS=> SYSLIB, DOS=> N/A\n*        &$IOUNIT(7)= FUTURE USE\n*        &$IOUNIT(8)= FUTURE USE\n*\n         GBLB  &$JRM               =1 FOR PSU LOCAL SPECIAL CODE: JRM\n         GBLB  &$KP26              =1 ALLOW KP=26 OR KP=29 OPTION\n*                                  =0 ALLOW ONLY 029 KEYPUNCH CARDS\n         GBLA  &$LDF,&$LMX         DEFAULT,MAX L= # LINES/PAGE\n         GBLB  &$MACOPC            =1 ==> ALLOW OPEN CODE COND ASMBL\n         GBLB  &$MACROG            =1 ==> ADD ASM G FEATURES TO ASM F\n         GBLB  &$MACROH            =1 ==> ADD SOME ASM H FEATURES TO F\n         GBLB  &$MACROV            OS/VS SUPPORT\n         GBLB  &$MACROS            MACRO/CONDITIONAL ASSEMBLY ALLOWED\n*              **NOTE** BASIC MACRO FACILITY IS ASSEMBLER F COMPATIBLE.\n         GBLB  &$MACSLB            =1 ==> MACRO LIBRARY ALLOWED\n         GBLC  &$MCHNE             MACHINE GENERATION OF EQUIPMENT\n         GBLA  &$MMACTR            LOCAL ACTR INITIAL VALUE DEFAULT\n         GBLA  &$MMNEST            MACRO NEST LIMIT DEFAULT\n         GBLA  &$MMSTMG            GLOBAL MACRO STMT LIMIT DEFAULT\n         GBLA  &$MODEL             MODEL NUMBER OF 360/370 BEING RUN ON\n         GBLB  &$OBJIN             =0 CANNOT READ OBJECT DECK. =1 CAN\n         GBLA  &$OPTMS             OPTIMIZE - 0==> MEMORY, 9==> SPEED\n         GBLB  &$PAGE              =0 NO PAGE COUNT/CONTROL CODE EXISTS\n*                                  =1 PAGE CONTROL &OPTIONS ALLOWED\n         GBLA  &$PDF,&$PMX         DEFAULT,MAX P= # PAGES LIMIT\n         GBLA  &$PDDF,&$PDMX       DEFAULT,MAX PD= # PAGES FOR DUMP\n         GBLB  &$PRIVOP            =0==>NO PRIV OPS, =1==> PRIV OPS OK\n         GBLA  &$PRTSIZ            MAX # CHARS IN PRINT LINE FOR ASM\n         GBLB  &$PUNCH             =0 WE DON'T ACTUALLY HAVE CARD PUNCH\n*                                  =1 REAL PUNCH EXISTS, POSSIBLE USE\n         GBLA  &$PXDF,&$PXMX       DEFAULT,MAX PX= PAGES FOR EXECUTION\n         GBLB  &$P370              =1 WILL INTERPRET PRIVELEGED S/370\n         GBLB  &$P370A             SHOULD ASSEMBLER PERMIT PRIV S/370'S\n         GBLA  &$RDF,&$RMX         DEFAULT,MAX R= TOTAL # RECORDS\n         GBLA  &$RDDF,&$RDMX       DEFAULT,MAX RD= RECORDS FOR DUMP\n         GBLA  &$RECORD            =0,1=> NO $TIRC RECREM, =2=> $TIRC\n         GBLB  &$RECOVR            (ONLY USED FOR &$RECORD=2).\n*              =0 => R= DOES NOT OVERRIDE $TIRC VALUE, =1 => IT DOES.\n*              (AT PSU, OUTPUT CAN GO TO BAT FILES - DOESN'T COUNT).\n         GBLB  &$RELOC             =0==> NO RELOCATION CODE GENERATED\n         GBLA  &$REPL              0=> NO REPL,1=> LIMITED,2=> FULL\n         GBLA  &$RXDF,&$RXMX       DEFAULT,MAX RD= RECORDS FOR EXECUTE\n         GBLB  &$SPECIO            SPECIAL ROUTINES EXIST(TYPE=$IS+)\n         GBLA  &$SYHASH            SIZE OF INITIAL PTR TABLE FOR SYMOPS\n         GBLC  &$SYSTEM            SYSTEM BEGIN RUN - DOS,PCP,MFT,MVT\n         GBLA  &$S370              =0==> NO S/370 INSTR INTERPRETED\n*                                  =1==> S/370 INSTR INTERPRETED ON 370\n*                                  =2==> S/370 INSTR INTERPRETED ON 360\n         GBLB  &$S370A             SHOULD ASSEMBLER PERMIT SYSTEM 370'S\n         GBLC  &$TDF,&$TMX         DEFAULT,MAX T= TOTAL TIME FOR RUN\n         GBLC  &$TDDF,&$TDMX       DEFAULT,MAX TD= TIME FOR DUMP\n         GBLA  &$TIMER             0==> NO TIMING AT ALL\n*              1==> STIMER/TTIMER ONLY. =2==> LOCAL TIMER FOR TIMREM\n         GBLC  &$TXDF,&$TXMX       DEFAULT,MAX TX= TIME FOR EXECUTION\n         GBLC  &$VERSLV            VERSION #.LEVEL #\n         GBLB  &$XIOS              =0==>NO XIO MACROS,=1==>XIO MACROS\n         GBLB  &$XREF              CONTROL GENERATION OF XREF FACILITY\n*        =1 FULL XREF, =0 NO XREF AT ALL                              A\n         GBLA  &$XREFDF(3)         DEFAULT VALUES FOR FLAGS           A\n*        &$XREFDF(1)=0       NO XREF(OTHERS =3MEANS COMPRESSED LISTING\n*        &$XREFDF(2)=3       COLLECT MODIFY AND FETCH DEFN            A\n*        &$XREFDF(3)=3       COLLECT REFERENCES MODIFY/FETCH          A\n         GBLA  &$XREF#B            NUMBER OF SLOTS FOR XREF BLKS      A\n         GBLB  &$XXIOS             =0==>XGET-XPUT MACROS,=1==> NO\n         GBLB  &X$DDMOR          ALLOW USER OWN DDNAMES:=1==>YES,0==>NO\n**       GLOBAL SET VARIABLES - INTERNAL TYPE -                       *\n         GBLC  &DEBUG              DEBUG NUMBER FOR TESTING AVDEBUG\n         GBLC  &ID                 IDENT GENERATION CONTROL\n         GBLC  &TRACE              SPECIFIES FORM OF TRACE-SNAP,*,NO\n&$BTCC(1) SETC '$'            CONTROL CHARACTER FOR BATCH CARDS       J\n&$BTCC(2)  SETC  'JOB'            JOB BEGINNING INDICATOR       CPP\n&$BTCC(3) SETC 'ENTRY'        BEGIN DATA CARD: SET = '' IF NONE NEEDED\n&$BTCC(4)  SETC  'STOP'           TERMINATOR INDICATOR          CPP\n         SPACE 1\n*********  NOTE  ********  SHOULD THE VALUE OF &$BLEN BE CHANGED\n*        AND THE VERSION OF ASSIST TO BE GENERATED IS A DOS SYSTEM\n*        THEN BE SURE TO CHANGE THE VALUE OF THE BLKSIZE PARAMETER\n*        ON THE DTFSD DEFINITION IN CSECT XXXIOCO\n&$BLEN   SETA  3520                HALF-TRACK SIZE FOR IBM 2316 PACK\n&$BLEN   SETA  4*(&$BLEN/4)        ROUND BLEN DOWN TO FULLWORD MULTIPLE\n&$BUFNO  SETA  2                   SET FOR 4 BUFFERS\n&$CMPRS  SETB  (1)                ALLOW 'CMPRS' OPTION          CPP\n&$COMNT  SETA  80                  REQUIRE 80% COMMENTS, IF COMNT OPT\n&$DATARD SETB  (1)                 ALLOW SINGLE JOB/TWO RDRS\n&$DEBUG  SETB  (1)                 FOR QUICK RUN, KILL GENERATION\n&$DECK   SETB  (1)                 ALLOW OBJECT DECKS TO BE PUNCHED\n&$DECSA  SETB  (1)                 ASSEMBLER WILL ACCEPT DECIMAL INSTS\n&$DECSM  SETB  (1)                 PSU 360/67 HAS DECIMAL INSTRUCTIONS\n&$DISKU  SETA  1                   SET FOR USER OPTION ON DISK UTILITY\n&$DMPAG  SETB  1                   ASSUME COMPLETION DUMP ON NEW PAGE J\n&$EXINT  SETB  1                   USE EXTENDED INTERPRETER           L\n&$FLOTA  SETB  (1)                 ASSEMBLER ALLOWS FLOATING POINT\n&$FLOTAX SETB  (1)                 ASSEMBLER ALLOWS EXTENDED F. P.\n&$FLOTE  SETB  (1)                 WE WILL EXECUTE FLTINGS,IF POSSIBLE\n&$FLOTEX SETB  (1)                 WILL EXECUTE EXTENDED F. P., IF POSS\n&$FLOTM  SETB  (1)                 PSU 360/67 HAS FLOATING POINT\n&$FLOTMX SETB  (0)                 PSU 360/67 HASN'T GOT EXTENDED F. P.\n&$FREE   SETA  30720               RETURN 30K TO OS/360               L\n&$FREEMN SETA  2048                MINIMUM ALLOWED FREE=;  *****NOTE  J\n*              IF YOU HAVE 80A ABEND'S OFTEN, RAISE THIS AS NEEDED*** J\n&$GENDAT SETC  '12/02/75'          CURRENT GENERATION DATE\n&$IDF    SETA  150000              100 SECS ON /67\n&$IMX    SETA  150000              100 SECS ON /67\n&$KP26   SETB  (1)                 ALLOW 026 KEYPUNCH\n&$LDF    SETA  63                  DEFAULT 63 LINES/PAGE\n&$LMX    SETA  63                  MAXIMUM OF 63 LINES/PAGE\n*              MACRO SETS: ONLY SIGNIFICANT IF &$MACROS=1.\n&$MACOPC SETB  1                   ALLOW OPEN CODE, AT LEAST FOR TEST\n&$MACROS SETB  1                   ALLOW MACROS TO BE PROC ESSED\n&$MACROG SETB  0                   NO ASM G CODE ***NOT SUPPORTED YET**\n&$MACROH SETB  0                   NO ASM H CODE ***NOT SUPPORTED YET**\n&$MACROV SETB  0                   NO OS/VS ASSEMBLER SUPPORT YET\n&$MACSLB SETB  1                   ALLOW MACRO LIBRARY FETCH\n&$MCHNE  SETC  '370'               PSU RUNS SYSTEM 370\n&$MMACTR SETA  200                 DEFAULT ACTR VALUE = 200\n&$MMNEST SETA  15                  DEFAULT LIMIT OF 15 DEEP IN MACS\n&$MMSTMG SETA  4000                DEFAULT MAXIMUM TOTAL 4000 MAC STMTS\n         SPACE 1\n&$MODEL  SETA  65                  DEFAULT MODEL NUMBER\n&$OBJIN  SETB  (1)                 ALLOW OBJECT DECKS TO BE READ\n&$OPTMS  SETA  4                   MEDIUM OPTIMIZATION\n&$PAGE   SETB  (1)                 ALLOW ALL PAGE CONTROL OPTIONS\n&$PDF    SETA  10                  TEN TOTAL PAGES\n&$PMX    SETA  25                  MAXIMUM POSSIBLE OF 25 TOTAL\n&$PDDF   SETA  1                   NORMAL DUMP-JUST FIRST PAGE\n&$PDMX   SETA  5                   MAXIMUM OF 5 PAGES FOR THE DUMP\n&$PRIVOP SETB  1                   ALLOW ALL PRIVILEGED OPERATIONS\n&$PRTSIZ SETA  121                 LIMIT TO 121 CHARS AS DEFAULT LIM  J\n&$PUNCH  SETB  (1)                 A REAL PUNCH EXISTS\n&$PXDF   SETA  5                   DEFAULT PAGES FOR EXECUTION\n&$PXMX   SETA  5                   MAXIMUM PAGES FOR EXECUTION\n&$RDF    SETA  100000              DEFAULT RECORDS FOR EXEC\n&$RMX    SETA  100000              MAX EXECUTION RECORDS\n&$RDDF   SETA  25                  DEFAULT RECORDS FOR A DUMP\n&$RDMX   SETA  5000                MAXIMUM RECORDS FOR DUMP\n&$RECORD SETA  1                   SHOW $TIRC RECREM CAN'T BE USED\n&$RELOC  SETB  (1)                 NEED RELOC SINCE WE HAVE REPL\n&$REPL   SETA  2                  ALLOW FULL REPL. OPTIONS      CEH\n&$RXDF   SETA  10000               DEFAULT EXECUTION RECORDS\n&$RXMX   SETA  10000               MAXIMUM EXECUTION RECORDS\n&$SYSTEM SETC  'OS-MVT'            SYSTEM IS OS OPTION MVT\n&$S370   SETA  2                   PSU WANTS S/370'S ON 360/67\n&$S370A  SETB  (1)                 ASSEMBLER ALLOWS S/370'S\n&$XIOS   SETB  (1)                 WE'RE ALLOWING XIO MACROS\n&$XXIOS  SETB  0                   ALLOW XGET - XPUT\n&X$DDMOR SETB  0                   ALLOW USER OWN DD NAMES\n&$HEXI   SETB  (1)                 XHEXI ALLOWED THIS ASSEMBLY\n&$HEXO   SETB  (1)                 XHEXO ALLOWED\n&$TDF    SETC  '100'               DEFAULT SECONDS FOR RUN\n&$TMX    SETC  '200'               MAX POSSIBLE SECONDS FOR RUN\n&$TDDF   SETC  '.1'                DEFAULT TIME FOR DUMP\n&$TDMX   SETC  '10'                MAXIMUM TIME FOR A DUMP\n&$TIMER  SETA  1                   SHOW WE WANT OVERALL TIMING DONE\n&$TXDF   SETC  '100'               DEFAULT TIME FOR EXECUTION\n&$TXMX   SETC  '200'               MAXIMUM TIME FOR EXECUTION\n&$VERSLV SETC  '4.0/A2'            VERSION LEVEL (CEH,CPP,TXM 12/02/75)\n&$XREF   SETB  1                   ALLOW CROSS REFERENCE\n&$XREFDF(1) SETA  3                PSU TESTING                        L\n&$XREFDF(2) SETA  3                COLLECT ALL MOD/FETCH DEFN         A\n&$XREFDF(3) SETA  3                COLLECT ALL MOD/FETCH REFERENCES   A\n&$XREF#B SETA  10                  ALLOCATE 10 SLOTS/BLOCK            A\n&$ASMLVL SETB  ('&$SYSTEM'(1,2) EQ 'OS')     SET LEVEL OF ASSEMBLER\n&$FLOTE  SETB  (&$FLOTE AND &$FLOTM)         KILL GEN IF NO FLOATS\n&$FLOTEX SETB  (&$FLOTEX AND &$FLOTMX) KILL GEN IF NO EXTENDED FLOATS\n         AIF   (&$ASMLVL).OSGEN    SKIP IF OS GENERATION\n&$BATCH  SETC  'BATCH'            DEFAULT OF DOS IS BATCH       CEH\n&$IOUNIT(1) SETC  'SYSIPT'         SET DOS MAIN INPUT\n&$IOUNIT(2)  SETC  'SYSRDR'        SET DOS SECONDARY INPUT\n&$IOUNIT(3)  SETC  'SYSLST'        SET DOS PRINTER\n&$IOUNIT(4) SETC 'SYSPCH'          SET DOS PUNCH\n&$IOUNIT(5)    SETC 'SYS001'       SET DOS DISK INTERMEDIATE\n&$BUFNO  SETA  2                   FOR DOS GEN INSURE ONLY 2 BUFFERS\n&$DSKUDV SETC  '2314'              SET DOS DISK DRIVE TYPE\n         AGO   .OSGEN1\n.OSGEN   ANOP\n&$BATCH  SETC  'NOBATCH'          DEFAULT FOR OS IS NOBATCH     CEH\n&$IOUNIT(1)  SETC  'SYSIN'         SET OS PRIMARY INPUT\n&$IOUNIT(2)  SETC  'FT05F001'      SET OS SECONDARY INPUT\n&$IOUNIT(3)  SETC  'FT06F001'      SET OS PRINTER\n&$IOUNIT(4)  SETC  'FT07F001'      SET OS PUNCH\n&$IOUNIT(5)  SETC  'FT08F001'      SET OS DISK INTERMEDIATE\n&$IOUNIT(6)  SETC  'SYSLIB'        SET OS MACRO LIBRARY\n.OSGEN1  ANOP\n&ID      SETC  'NO'                SET NO ID FOR TIME BEING\n         AIF   (&$DEBUG).EQU1      LEAVE NO ID IF PRODUCTION PROG\n&ID      SETC  '*'                 DEBUG==> GENERATE ID'S AT ENTRIES\n.EQU1    ANOP\n         ASSYSGEN ,                CALL TO POSSIBLY RESET SET VARIABLES\n&$P370   SETB  (&$PRIVOP AND (&$S370 NE 2)) KILL GEN IF NO PRIV OR S370\n&$P370A  SETB  (&$PRIVOP AND &$S370A) NO PRIV 370'S IF NO PRIV OR S370\n&$ALIGN  SETB  (&$ALIGN OR (&$S370 EQ 1 OR &$MODEL EQ 85)) FORCE VALUE\n&$MACSLB SETB  (&$MACSLB AND &$MACROS)  REMOVE LIBRARY IF NO MACROS   J\n&$RELOC  SETB  (&$RELOC OR (&$REPL NE 0))  IF REPL, MAKE SURE RELOC   J\n&$HASPBT SETB  (&$HASPBT AND &$ASMLVL)  ELIM HASP IF NOT OS SYSTEM    J\n         SPACE 2\n         TITLE '*** OPCODTB DSECT - OPCODE CONTROL TABLE ENTRY ***'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> DSECT: OPCODTB    DESCRIBES 1 ENTRY IN OPOCDE TABLE              *\n*        LOCATION: ELEMENTS OF TABLE IN CSECT OPCOD1 OF ASSEMLBER.    *\n*        GENERATION: 1 CALL TO MACRO OPG CREATES AN ELEMENT.          *\n*        SECTIONS OPCTYPE,OPCHEX,OPCMASK CORRESPOND TO SIMILARLY-NAMED*\n*        SECTIONS OF DUMMY SECTION RCODBLK. SEE CSECT OPCOD1.         *\n*        NAMES: OPC-----                                              *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nOPCODTB  DSECT\nOPCTYPE  DS    C                   TYPE BYTE FOR MNEMONIC\nOPCHEX   DS    C                   HEX CODE FOR MACHINE OPS/SUBCODE\nOPCMASK  DS    C                   MASK/ALIGNMENT(MACHINE) / SUBCODE\nOPCMNEM  DS    CL8                 MNEMONIC- FROM 1 TO 8 CHARACTERS\n         SPACE 4\n* * * * * EQUATES USED FOR BCR INSTRUCTIONS * * * * * * * * * * * * * *\nH        EQU   2                   HIGH\nL        EQU   4                   LOW\nE        EQU   8                   EQUAL\nNH       EQU   13                  NOT HIGH\nNL       EQU   11                  NOT LOW\nNE       EQU   7                   NOT EQUAL\nO        EQU   1                   ONES OR OVERFLOW\nP        EQU   2                   POSITIVE\nM        EQU   4                   MINUS\nZ        EQU   8                   ZERO\nNP       EQU   13                  NOT POSITIVE\nNM       EQU   11                  NOT MINUS\nNZ       EQU   7                   NOT ZERO\nNO       EQU   14                  NOT ONES OR NOT OVERFLOW\n         SPACE 1\n$CHN     EQU   0                   FOR ANY FIELD CHANGED DURING EXECUT\n$        EQU   0                   FOR ANY FIELD CHANGED DURING EXECUT\n         SPACE 1\n$PRGFILC EQU   C'5'                CHAR USED TO FILL UNUSED PROG CORE\n$PRGFILR EQU   C'4'                CHAR USED TO FILL USER REGS AT FIRST\n         TITLE 'DSECT***X$SLOT*** FORMAT OF AN ENTRY FOR XGET-XPUT MON'\nX$SLOT   DSECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*-->DSECT: X$SLOT FORMAT FOR XGET-XPUT MONITOR TABLE                  *\n*        USED IN XDDGET AND XDDPUT TO CONTROL USE OF CERTAIN          *\n*           DD NAMES BY USER WITH XGET-XPUT PERMITTED.                *\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nX$SLNAME DS    CL8                 DDNAME\nX$SLFLAG DS    CL1                 FLAG BITS\nX$SLWAY  DS    CL1\nX$SLLONG EQU   *-X$SLNAME          GET LENGTH OF ENTRY\nX$SLOPEN EQU   X'C0'               THESE BITS OFF IF FILE NOT OPEN\nX$SLXGET EQU   X'40'               INPUT FILE\nX$SLXPUT EQU   X'80'               OUTPUT FILE\nX$SLPERM EQU   X'01'               PERMANENT FILE NAME\nX$SLCLOS EQU   X'3F'               OPPOSITE OF X$SLOPEN\nX$SLPOIN EQU   X'0C'               ON FOR POSSIBLE INPUT OR OUTPUT\nX$SLXGPT EQU   X'00'               BITS OFF MEAN USE XGET-XPUT\n         TITLE '*** REGISTER EQUATES AND CONVENTIONS ***'\n*        *** ABSOLUTE REGISTER EQUATES ***                            *\nF0       EQU   0                   FLOATING POINT REGISTER 0          *\nF2       EQU   2                   FLOATING POINT REGISTER 2          *\nF4       EQU   4                   FLOATING POINT REGISTER 4          *\nF6       EQU   6                   FLOATING POINT REGISTER 6          *\n         SPACE 1\nR0       EQU   0                   SPECIAL WORK REGISTER 0            *\nR1       EQU   1                   SPECIAL WORK REGISTER 1            *\nR2       EQU   2                   SPECIAL WORK REGISTER 2            *\nR3       EQU   3                   GENERAL WORK REGISTER 1            *\nR4       EQU   4                   GENERAL WORK REGISTER 2            *\nR5       EQU   5                   GENERAL WORK REGISTER 3            *\nR6       EQU   6                   GENERAL WORK REGISTER 4            *\nR7       EQU   7                   PARAMETER REGISTER 1               *\nR8       EQU   8                   PARAMETER REGISTER 2               *\nR9       EQU   9                   PARAMETER REGISTER 3               *\nR10      EQU   10                  PARAMETER REGISTER 4               *\nR11      EQU   11                  PARAMETER REGISTER 5               *\nR12      EQU   12                  ASSEMBLER TABLE POINTER-READ ONLY  *\nR13      EQU   13                  SAVE AREA POINTER/BASE REG FOR SOME*\nR14      EQU   14                  RETURN ADDRESS USED IN CALLS       *\nR15      EQU   15                  ENTRY POINT ADDRESS/OFTEN USED BASE*\n         SPACE 1\n*        *** SYMBOLIC REGISTER EQUATES ***                            *\nRW       EQU   R3                  GENERAL WORK REGISTER 1            *\nRX       EQU   R4                  GENERAL WORK REGISTER 2            *\nRY       EQU   R5                  GENERAL WORK REGISTER 3            *\nRZ       EQU   R6                  GENERAL WORK REGISTER 4            *\nRA       EQU   R7                  PARAMETER REGISTER 1               *\nRB       EQU   R8                  PARAMETER REGISTER 2               *\nRC       EQU   R9                  PARAMETER REGISTER 3               *\nRD       EQU   R10                 PARAMETER REGISTER 4               *\nRE       EQU   R11                 PARAMETER REGISTER 5               *\nRAT      EQU   R12                 ASSEMBLER TABLE POINTER-READ ONLY  *\nRSA      EQU   R13                 SAVE AREA POINTER/BASE REG FOR SOME*\nRET      EQU   R14                 RETURN ADDRESS USED IN CALLS       *\nREP      EQU   R15                 ENTRY POINT ADDRESS/OFTEN USED BASE*\n         SPACE 1\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*        *** REGISTER CONVENTIONS ***                                 *\n*        A. REGISTERS R0-R6 ARE PROTECTED ACROSS CALLS.               *\n*        B. REGISTER RAT(R12) MAY NOT BE CHANGED BY ANY ROUTINE.      *\n*        C.REGISTERS R7-R11 (RA-RE) ARE COMPLETELY UNPROTECTED ACROSS *\n*         CALLS, AND MAY BE USED BY ANY ROUTINE .  PARAMATERS WILL    *\n*         NORMALLY BE PLACED TO USE FIRST RA, THEN RB, ETC.  IF MORE  *\n*         THAN 5 PARAMATERS ARE REQUIRED, REGISTER RE WILL POINT TO   *\n*         AN OS TYPE PARAMATER LIST.                                  *\n*        D. EXCEPT FOR THE ABOVE, THE CONVENTIONS ARE EXACTLY THE     *\n*         SAME AS STANDARD IBM CONVENTIONS WITH REGARD TO LINKAGE,    *\n*         SAVE AREA STRUCTURE, REQUIREMENTS, ETC.                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         TITLE '*** ERROR CODE EQUATE SYMBOLS - $ER----- ***'\nALIGN    $SERR 'W-ALIGNMENT ERROR-IMPROPER BOUNDARY',000\nENTRY    $SERR 'W-ENTRY ERROR-CONFLICT OR UNDEFINED',001\nEXTRN    $SERR 'W-EXTERNAL NAME ERROR OR CONFLICT',002\nRGNUS    $SERR 'W-REGISTER NOT USED',003\nODDRG    $SERR 'W-ODD REGISTER USED-EVEN REQUIRED',004\nNOEND    $SERR 'W-END CARD MISSING-SUPPLIED',005\nADDR     $SERR 'ADDRESSIBILITY ERROR',100\nCNLNG    $SERR 'CONSTANT TOO LONG',101\nCNTYP    $SERR 'ILLEGAL CONSTANT TYPE',102\nCONT     $SERR 'CONTINUATION CARD COLS. 1-15 NONBLANK',103\nCONTX    $SERR 'MORE THAN 2 CONTINUATION CARDS',104\nCXREL    $SERR 'COMPLEX RELOCATABILITY ILLEGAL',105\nDCEXT    $SERR 'TOO MANY OPERANDS IN DC',106\nDPCSE    $SERR 'MAY NOT RESUME SECTION CODING',107\nDUPLF    $SERR 'ILLEGAL DUPLICATION FACTOR',108\nEXGTA    $SERR 'EXPRESSION TOO LARGE',109\nEXLTA    $SERR 'EXPRESSION TOO SMALL',110\nICNOP    $SERR 'INVALID CNOP OPERAND(S)',111\nILLAB    $SERR 'LABEL NOT ALLOWED',112\nILORG    $SERR 'ORG VALUE IN WRONG SECTION OR TOO LOW',113\nINVCN    $SERR 'INVALID CONSTANT',114\nINVDM    $SERR 'INVALID DELIMITER',115\nINVF     $SERR 'INVALID FIELD',116\nINVSY    $SERR 'INVALID SYMBOL',117\nIVOPC    $SERR 'INVALID OP-CODE',118\nMULDF    $SERR 'PREVIOUSLY DEFINED SYMBOL',119\nNEABS    $SERR 'ABSOLUTE EXPRESSION REQUIRED',120\nNODLM    $SERR 'MISSING DELIMITER',121\nNOIMP    $SERR 'FEATURE NOT CURRENTLY IMPLEMENTED',122\nNOOPR    $SERR 'MISSING OPERAND',123\nNONAM    $SERR 'LABEL REQUIRED',124\nRELOC    $SERR 'RELOCATABLE EXPRESSION REQUIRED',126\nSDINV    $SERR 'INVALID SELF-DEFINING TERM',127\nSTART    $SERR 'ILLEGAL START CARD',128\nTLIT     $SERR 'ILLEGAL USE OF LITERAL',129\nUNDEF    $SERR 'UNDEFINED SYMBOL',130\nUNRV     $SERR 'UNRESOLVED EXTERNAL REFERENCE',131\nVILCH    $SERR 'ILLEGAL CHARACTER',132\nVPARN    $SERR 'TOO MANY PARENTHESIS LEVELS',133\nVRELO    $SERR 'RELOCATABLE VALUE USED WITH * OR /',134\nVSYNT    $SERR 'SYNTAX',135\nVTMTR    $SERR 'TOO MANY TERMS IN EXPRESSION',136\nVUNEX    $SERR 'UNEXPECTED END OF EXPRESSION',137\nINTPT    $SERR 'STATEMENT CAUSED INTERRUPT',138\n         SPACE 1\n         AIF   (NOT &$MACROS).SERR1         SKIP IF NO MACROS\nILOPR    $SERR 'OPERAND NOT ALLOWED',201\nSTMNA    $SERR 'STATEMENT OUT OF ORDER',202\nSSDIM    $SERR 'SET SYMBOL DIMENSION ERROR',203\nINSBV    $SERR 'INVALID NBR OF SUBSCRIPTS',204\nILCNV    $SERR 'ILLEGAL CONVERSION',205\nMISQU    $SERR 'MISSING QUOTES IN CHAR EXPR',206\nILMNM    $SERR 'ILLEGAL OR DUP MACRO NAME',207\nMXDMD    $SERR 'OPRND NOT COMPATIBLE WITH OPRTR',208\nUNDKW    $SERR 'UNDFND OR DUP KEYWORD',209\nEXMAC    $SERR 'MNEST LIMIT EXCEEDED',210\nILAT     $SERR 'ILLEGAL ATTRIBUTE USE',211\nMEXST    $SERR 'GENERATED STMT TOO LONG',212\nOVRGN    $SERR 'GENERATED STMTS OVERWRITTEN',298\n.SERR1   ANOP\n         TITLE '*** INSTRUCTION TYPES AND CODES ***'\n* * * * * INSTRUCTION TYPES FOR MACHINE INSTRUCTIONS(OPCTYPE FIELD)   *\n$IA      EQU   X'00'               (OPCHEX)==> PREFIX FOR MACHINE OPS\n$RRM     EQU   2                   RR EXTENDED MNEMONICS -R2\n$RXM     EQU   4                   RX EXTENDED MNEMONICS - D2(X2,B2)\n$RR      EQU   6                   NORMAL RR - R1,R2\n$RX      EQU   8                   NORMAL RX - R1,D2(X2,B2)\n$RS      EQU   10                  RS(LM,STM,BXH,BXLE)-R1,R3,D2(B2)\n$RSH     EQU   12                  RS(SHIFTS) - R1,D2(B2)\n$SI      EQU   14                  SI NORMAL - D1(B1),I2\n$SS      EQU   16                  SS-1 LENGTH- D1(L,B1),D2(B2)\n$SS2     EQU   18                  SS-2 LENGTHS - D1(L1,B1),D2(L2,B2)\n$RSO     EQU   20                  ODD RR-SI'S (SPM,SVC,LPSW,SSM,TS,IO)\n$SPC     EQU   22                  SPECIAL(FAKE) INSTRUCTIONS-XREAD,ETC\n$ICTMX   EQU   11                  MAXIMUM IC TYPE / 2\n         SPACE 1\nIAA      EQU   X'10'               (RCMASK) - R1 REQUIRED TO BE EVEN\nIAL1     EQU   X'00'               (RCMASK) - LITERAL OK-OP1==>NEVER!\nIAL2     EQU   X'08'               (RCMASK) - LITERAL PERMITTED-OP2\nIAB      EQU   X'20'               (RCMASK) - R2 REQUIRED TO BE EVEN\n         SPACE 1\n* * * * * ASSEMBLER INSTRUCTION TYPES - $I------ (OPCTYPE FIELD)  * * *\n$IB      EQU   X'C0'               OPCODTB ENTRY TAG BITS FOR AM INST\n*              *NOTE* SECTIONS MO, MT DEPEND ON $IB HAVING THIS VALUE *\n$IUSING  EQU   2                   USING INSTRUCTION\n$IDROP   EQU   4                   DROP INSTRUCTION\n$ISTART  EQU   6                   START INSTRUCTION\n$ICSECT  EQU   8                   CSECT INSTRUCTION\n$IDSECT  EQU   10                  DSECT INSTRUCTION\n$IENTRY  EQU   12                  ENTRY INSTRUCTION\n$IEXTRN  EQU   14                  EXTRN INSTRUCTION\n$IEQU    EQU   16                  EQU INSTRUCTION\n$IDC     EQU   18                  DC INSTRUCTION\n$IDS     EQU   20                  DS INSTRUCTION\n$ICCW    EQU   22                  CCW INSTRUCTION\n$ITITLE  EQU   24                  TITLE INSTRUCTION\n$IEJECT  EQU   26                  EJECT INSTRUCTION\n$ISPACE  EQU   28                  SPACE INSTRUCTION\n$IPRINT  EQU   30                  PRINT INSTRUCTION\n$IORG    EQU   32                  ORG INSTRUCTION\n$ILTORG  EQU   34                  LTORG INSTRUCTION\n$ICNOP   EQU   36                  CNOP INSTRUCTION\n$IEND    EQU   38                  END INSTRUCTION\n$IDEBUG  EQU   40                  DEBUG FLAG SETTING ROUTINE\n         SPACE 1\nIBNONAM  EQU   X'40'               (OPCHEX)==> LABEL NOT PERMITTED\nIBNENAM  EQU   X'20'               (OPCHEX)==> LABEL IS REQUIRED\nIBOMOP   EQU   X'10'               (OPCHEX)==> OPERAND MAY BE OMITTED\nIBMOSPEC EQU   X'08'               (OPCHEX,RCHEX)==> REQUIRES SPECIAL\n*              HANDLING OF SOME KIND IN MOCON1 (END, ALL PRINT CTRL).\nIBMOPRCT EQU   X'04'               (OPCHEX,RCHEX)==> IS SOME KIND OF\n*              PRINT CNTRL, SO REQUIRES SPEC HANDLING BY MOCON1.\nIBMOPRCX EQU   IBMOSPEC+IBMOPRCT   (OPCHEX,RCHEX)==> PRT CNTRL\n         TITLE '*** MISCELLANEOUS EQUATE SYMBOLS ***'\n$ESDSECT EQU   1                   (AVCESDID)-IN DSECT, EVEN=>CSECT\n$IS      EQU   X'40'               OPCTYPE CODE FOR SPECIALS\n$IM      EQU   X'80'               OPCTYPE CODE FOR MACROS\n         SPACE 1\n$IBPON   EQU   X'80'               (AVPRINT,AVPRINT1)-PRINT ON\n$IBPGEN  EQU   X'40'               (AVPRINT,AVPRINT1)- PRINT GEN\n$IBPDAT  EQU   X'20'               (AVPRINT,AVPRINT1)- PRINT DATA\n*                                  PRINT DATA, NODATA ONLY FOR COMPATIB\n$IBPLIST EQU   X'02'               (AVPRINT)==> LIST IS ON\n         SPACE 1\n$IBSTAR1 EQU   X'80'               (AVTAGS1)==> START NO LONGER ALLOWED\n$IBDSEC1 EQU   X'40'               (AVTAGS1)==> PROCESSING DSECT NOW\n*              IF THIS FLAG IS NOT SET, CURRENT SECTION IS A CSECT.   *\n$IBPRCD1 EQU   X'20'               (AVTAGS1) - PRIVATE CODE HAS OCCURRD\n         SPACE 1\n$INEND2  EQU   B'10000000'         (AVTAGS2)==> ENDFILE ON SYSIN-INCARD\n         SPACE 1\n$OUMACH  EQU   0                   CODE FOR MACHINE INSTRUCTIONS\n$OUCONS  EQU   2                   CODE FOR CONSTANTS\n$OULIST  EQU   4                   LISTING CONTROL INSTRUCTONS\n$OUCOMM  EQU   6                   COMMENTS,ETC WITHOUT LOCATION COUNTE\n         AIF   (NOT &$MACROS).NOMMMMM  SKIP IF NO MACROS\n* * * * * * * * EQUATES FOR MACRO-TYPE OPCODES* * * * * * * * * * * * *\n         SPACE 2\n$MACRO   EQU   2                   MACRO DECLARATION\n$GBLA    EQU   4                   GLOBAL ARITHMETIC DECLARATION\n$GBLB    EQU   6                   GLOBAL BINARY DECLARATION\n$GBLC    EQU   8                   GLOBAL CHARACTER DECLARATION\n$LCLA    EQU   10                  LOCAL ARITHMETIC DECLARATION\n$LCLB    EQU   12                  LOCAL BINARY DECLARATION\n$LCLC    EQU   14                  LOCAL CHARACTER DECLARATION\n$ACTR    EQU   16                  ACTR INSTRUCTION\n$SETA    EQU   18                  SET ARITHMETIC INSTRUCTION\n$SETB    EQU   20                  SET BINARY INSTRUCTION\n$SETC    EQU   22                  SET CHARACTER INSTRUCTION\n$AIF     EQU   24                  AIF INSTRUCTION\n$AGO     EQU   26                  AGO INSTRUCTION\n$ANOP    EQU   28                  ANOP INSTRUCTION\n$MNOTE   EQU   30                  MNOTE INSTRUCTION\n$MEXIT   EQU   32                  MEXIT INSTRUCTION\n$MEND    EQU   34                  MEND INST\n         SPACE 1\n$ARITH   EQU   4                   ARITHMETIC VLAUE\n$BOOL    EQU   8                   LOGICAL VALUE\n$CHAR    EQU   12                  CHARACTER VALUE\n.NOMMMMM ANOP\n         SPACE 1\n         TITLE '*** ICBLOCK - MACHINE INSTRUCTION CODE BLOCK ***'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> DSECT: ICBLOCK    MACHINE INSTRUCTION OBJECT CODE BLOCK.         *\n*        THIS DSECT IS USED TO TRANSMIT DATA FROM ICMOP2 CSECT TO     *\n*        OUTPT2 FOR PRINTING MACHINE INSTRUCTIONS.                    *\n*        LOCATION: TABLE ICYBLOCK IN CSECT ICMOP2 OF ASSEMBLER.       *\n*        NAMES: ICB-----                                              *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nICBLOCK  DSECT\n$ICBEA1  EQU   X'40'               (ICBFLAG) ==> EA1 EXISTS\n$ICBEA2  EQU   X'20'               (ICBFLAG) ==> EA2 EXISTS\n         SPACE 1\nICBEA1   DS    F                   1ST ADDRESS\nICBEA2   DS    F                   2ND ADDRESS\nICBOPR1R DS    0H                  OPCODE - R1 - R2\nICBOP    DS    C                   HEX OPCODE\nICBR1R2  DS    C                   REGISTERS OR LENGTHS OR IMMED.FIELD\nICBOPN1  DS    H                   1ST BASE DISPLACEMENT IN INSTRUCTION\nICBOPN2  DS    H                   2ND BASE DISPLACEMENT IN INSTRUCTION\nICBFLAG  DS    C                   FLAG BYTE FOR EXISTENCE OF EAU,EA2\n         TITLE '*** SYMSECT DSECT - SYMBOL TABLE ENTRIES ***'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> DSECT: SYMSECT    ASSEMBLER SYMBOL TABLE ENTRY.                  *\n*        CREATED BY ENTRY SYENT1 OF CSECT SYMOPS, AND HAS VALUES ADDED*\n*        BY MOCON1,IBASM1, FOR VALUE, SECTION ID, LENGTH ATTRIBUTE,   *\n*        AND BY ESDOPRS FOR SPECIAL ATTRIBUTES(CSECT,ETC).            *\n*        LOCATION:  FREEAREA HIGH END ($ALLOCH'D).                    *\n*        NAMES: SY------                                              *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nSYMSECT  DSECT\n$SYDEF   EQU   X'80'               (SYFLAGS) - SYMBOL HAS BEEN DEFINED\n$SYENT   EQU   X'40'               (SYFLAGS) - DECLARED AN ENTRY\n$SYCSE   EQU   X'20'               (SYFLAGS) - DECLARED A CSECT\n$SYDSE   EQU   X'10'               (SYFLAGS) - DECLARED A DSECT\n$SYEXT   EQU   X'08'               (SYFLAGS) - DECLARED EXTRN\n$SYXRMD  EQU   X'02'               (SYFLAGS) - XREF HAS MODIFY REFERS A\n$SYXRFT  EQU   X'01'               (SYFLAGS) - XREF HAS FETCH REF     A\n         SPACE 1\nSYLINK   DS    0F                  ADDRESS OF NEXT SYMBOL IN CHAIN\nSYHASH2  DS    C                   SECONDARY HASH CODE OF NEXT SYMBOL\nSYLINKA  DS    CL3                 ADDRESS REFERRED TO BY SYLINK\nSYVALUE  DS    F                   VALUE OF THE SYMBOL\nSYESDID  DS    C                   ESDID OF THE SYMBOL\nSYLENG   DS    C                   LENGTH ATTRIBUTE OF THE SYMBOL\nSYFLAGS  DS    C                   FLAG BYTE\nSYCHARS  DS    C                   #-1 OF BYTES IN SYMBOL (RANGE:0-7)\nSYMBOL   DS    CL8                4-8 CHARS OF SYMBOL,R-PADDED WITH BLK\n         TITLE '*** CNCBLOCK DSECT - CONSTANT CODE BLOCK ***'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> DSECT: CNCBLOCK   CONSTANT CODE BLOCK-DC'S, LITERALS.            *\n*        LOCATION: EACH CNCBLOCK IS CREATED IN AREA COBLK OF CODTL1.  *\n*        1 OR MORE CNCBLOCKS MAY BECOME PART OF THE RCODBLK CREATED   *\n*        IN AREA IBRCB BY IBASM1, AND 1 CNCBLOCK BECOMES PART OF THE  *\n*        ENTRY FOR EACH DISTINCT LITERAL(SEE LTLENTRY DSECT, LTOPRS   *\n*        CSECT.)                                                      *\n*        NAMES: CNC-----                                              *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nCNCBLOCK DSECT\n* * * * * CONSTANT TYPE,DESCRIPTOR CODES-USED IN CNCBLOCK AREAS * * * *\n$CNA     EQU   0                   A-TYPE CONSTANT TYPE CODE\n$CNB     EQU   1                   B-TYPE CONSTANT TYPE CODE\n$CNC     EQU   2                   C-TYPE CONSTANT TYPE CODE\n$CND     EQU   3                   D-TYPE CONSTANT TYPE CODE\n$CNE     EQU   4                   E-TYPE CONSTANT TYPE CODE\n$CNF     EQU   5                   F-TYPE CONSTANT TYPE CODE\n$CNH     EQU   6                   H-TYPE CONSTANT TYPE CODE\n$CNP     EQU   7                   P-TYPE CONSTANT TYPE CODE\n$CNV     EQU   8                   V-TYPE CONSTANT TYPE CODE\n$CNX     EQU   9                   X-TYPE CONSTANT TYPE CODE\n$CNZ     EQU   10                  Z-TYPE CONSTANT TYPE CODE\n$CNT$N   EQU   11                  1 MORE THAN MAX $CN# CODE=# TYPES\n$CNALN   EQU   X'80'               (CNCTYP)==> ALIGNMENT REQUIRED\n$CNVLN   EQU   X'40'               (CNCTYP)==> VARIABLE LENGTH (LIKE C)\n$CNMUL   EQU   X'20'               (CNCTYP)==> MULTIPLE CONSTANTS OK\n$CNERR   EQU   X'10'               (CNCTYP)==> RB HAS ERR CODE-PASS 2\n         SPACE 1\nCNCTYP   DS    C                   FLAGS AND TYPE CODE\nCNCLEN   DS    C                   LENGTH-1 OF CONSTANT\nCNCSCAN  DS    C                   SCAN POINTER TO 1ST CHAR OF 1ST CONS\nCNCNUM   DS    C                   NUMBER OF CONSTANTS IN OPERAND\nCNCDUP   DS    H                   DUPLICATION FACTOR\nCNCTOT   DS    H                   TOTAL LENGTH OF OPERAND(<=65K)\nCNC$LEN  EQU   *-CNCBLOCK          LENGTH OF CONSTANT CODE BLOCK\n         TITLE '*** RECORD BLOCKS - RCODBLK, REBLK ***'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> DSECT: RCODBLK    RECORD CODE BLOCK - VARIABLE DATA FOR STMT.    *\n*        AN RCODBLK IS CREATED BY EITHER IAMOP1 OR IBASM1 DURING      *\n*        ASSEMBLER PASS 1 FOR EVERY STATEMENT WITH AN ACCEPTABLE      *\n*        OPERATION CODE.  IT CONTAINS VARIABLE INFORMATION WHICH      *\n*        DEPENDS ON THE TYPE OF INSTRUCTION, AND MAY INCLUDE HEX      *\n*        MACHINE CODES AND MASKS, ALIGNMENT INFORMATION, LITERAL      *\n*        ADDRESSES, EQU SYMBOL ADDRESSES, AND 1 -10 CNCBLOCKS FOR DC  *\n*        COMMANDS.  THE MOST COMMON LENGTHS ARE 8 AND 12.             *\n*        LOCATION: CREATED IN AREA IARCB(IN IAMOP1) OR IBRCB(IN       *\n*        IBASM1). STORED IN LOW AREA AFTER ITS RSBLOCK BY UTPUT1.     *\n*        FOR MACHINE INSTRUCTIONS, MOVED TO ICRCB(IN ICMOP2) IN PASS 2*\n*        NAMES: RC------                                              *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nRCODBLK  DSECT\nRCLENG   DS    C                   LENGTH OF RCB\nRCLOC    DS    AL3                 LOCATION COUNTER VALUE\nRCTYPE   DS    C                   PRIMARY INSTRUCTION TYPE\nRCHEX    DS    C                   HEX CODE FOR MACH OPS, 2ND CODE OTHR\nRCMASK   DS    C                   MASK-ALIGNMENT FOR MACH OPS\nRCLQ     DS    C                   SLOT FOR LENGTH ATTRIBUTE L'*\nRC$LEN   EQU   *-RCODBLK-1         NORMAL LENGTH,WITHOUT LITERAL/EQU\nRCLITEQ  DS    A                   LITERAL/EQU ADDRESS\nRC$LEN2  EQU   *-RCODBLK-1         LENGTH-1 INCLUDING EQU OR LITERAL\n         SPACE 2\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> DSECT: REBLK      SCAN POINTER/ERROR CODE PAIR BLOCK.            *\n*        LOCATION: AVREBLK(AVWXTABL DSECT), CREATED BY ERRTAG SUBR.   *\n*        MOVED INTO LOW AREA FOLLOWING CORRESPONDING RCODBLK. MOVED   *\n*        BY UTGET2 BACK INTO AVREBLK AREA IN AVWXTABL DURING PASS 2.  *\n*        *NOTE* ONLY EXISTS FOR STATEMENTS HAVING 1 OR MORE ERROR OR  *\n*        WARNING MESSAGES ATTACHED TO IT.                             *\n*        NAMES: REB-----                                              *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nREBLK    DSECT\nREBLN    DS    C                   LENGTH-1 OF ERROR BLOCK\n$ERREBMX EQU   4                   MAX # ERROR MESSAGES KEPT PER STMT\n*              THERE IS 1 REBLN, UP TO $ERREBMX REBSCN-REBERR PAIRS.\nREBSCN   DS    C                   SCAN OFFSET POINTER TO ERROR\nREBERR   DS    C                   ERROR CODE\n         TITLE '*** RECORD BLOCKS - RSBLOCK,RSCBLK,RSOURCE ***'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> DSECT: RSBLOCK    RECORD SOURCE BLOCK-SOURCE CODE, FLAGS.        *\n*        AN RSBLOCK IS CREATED FOR EVERY SOURCE STATEMENT BY INCARD   *\n*        AND CONTAINS DATA COMMON TO EVERY STATEMENT, SUCH AS 1-3     *\n*        SOURCE CARD IMAGES, FLAGS FOR EXISTENCE OF OTHER RECORD      *\n*        BLOCKS.  ONLY RECORD BLOCK NECESSARY FOR A SOURCE STATEMENT. *\n*        LOCATION: CREATED IN AVRSBLOC (AVWXTABL DSECT) BY INCARD,    *\n*        WITH MODIFICATION BY ERRTAG AND MOCON1. MOVED TO LOW  END    *\n*        OF FREEAREA BY UTPUT1, AND REMAINS THERE.                    *\n*        NAMES: RSB-----                                              *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nRSBLOCK  DSECT\n$RSMXCRD EQU   3                   MAXIMUM # OF CARDS IN 1 STATEMENT\n$RCBX    EQU   X'80'               (RSBFLAG)==>RECORD CODE BLOCK EXISTS\n$REBX    EQU   X'40'               (RSBFLAG)==>RECORD ERROR BLOCK EXIST\n$RSCX    EQU   X'20'               (RSBFLAG)==>RECORD SOURCE CODE BLOCK\n*              FOLLOWING MAINLY INVOLVED WITH MACRO PROC.\n$RSBGENR EQU   X'08'               (RSBFLAG)==> GENERATED STMT\n*              I.E., SHOULD BE PRINTED WITH + BEFORE STMT.\n$RSBNP## EQU   X'04'               (RSBFLAG)==> DO NOT PROCESS FURTHER,\n*              EXCEPT TO PRINT.  HAS STMT #. (COMMENTS, OUTER MACROS).\n$RSBNPNN EQU   X'02'               (RSBFLAG)==> DO NOT PROCESS FURTHER,\n*              EXCEPT PRINT.  NO STMT #.  (INNER MACROS, SPEC ERRORS).\n$RSBMERR EQU   X'01'               (RSBFLAG)==> ERROR RECORD, GIVEN\n*              SPECIAL TREATMENT IN OUTPT2, COUNTS AS ERROR.  NOTE:\n*              IF THIS FLAG ON, $RSBNPNN SHOULD BE ALSO.\n         SPACE 1\nRSBLENG  DS    C                   LENGTH-1 OF THIS RSB(0-216)\nRSBFLAG  DS    C                   FLAG BITS FOR THIS RSB\nRSBNUM   DS    C                   NUMBER OF CARDS USED IN RSB\nRSBSCAN  DS    C                   SCAN POINTER OFFSET TO OPERAND FLD\nRSB$L    EQU   *-RSBLOCK           LENGTH OF STANDARD PART OF RSBLOCK\nRSBSOURC DS    0CL71               SPACE FOR 3 CARD IMAGES\nRSBLOPC  DS    CL71                1ST CARD IMAGE\nRSB$LN1  EQU   *-RSBLOCK-1         LENGTH-1 DEFAULT VALUE\n         DS    2CL71               0-2 MORE CARD IMAGES\n         SPACE 2\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> DSECT: RSCBLK     RECORD SOURCE-CONTINUATIONS, SEQUENCE #'S      *\n*        CREATED BY INCARD FOR ANY STATEMENT HAVING EITHER SEQUENCE   *\n*        NUMBERS OR CONTINUATION PUNCHES.                             *\n*        LOCATION: CREATED BY INCARD IN AVRSCBLK(AVWXTABL) DURING     *\n*        ASSEMBLY PASS 1. MOVED TO LOW END OF DYNAMIC AREA BY UTPUT1, *\n*        FOLLOWING CORRESPONDING REBLK(IF ONE EXISTS).  REMAINS IN    *\n*        THAT AREA FOR REST OF PROCESSING.                            *\n*        NAMES: RSC-----                                              *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nRSCBLK   DSECT\nRSCLENG  DS    C                   LENGTH-1 OF THIS RSCBLK\n* * * * * THE PREVIOUS ENTRIES ARE FIXED,THERE MAY BE UP TO 3 OF REST *\nRSCILEN  DS    C                   LENGTH OF INDIVIDUAL CARD IMAGE\nRSCONSQ  DS    CL9                 CONTINUATION-SEQUENCE NUMBER COLUMNS\nRSC$LEN  EQU   *-RSCILEN           LENGTH OF 1 ENTRY OF VARIABLE PART\n         SPACE 2\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> DSECT: RSOURCE    DESCRIPTION OF A SINGLE SOURCE CARD            *\n*        USED FOR INPUT PROCESSING BY SUBROUTINE INCARD.              *\n*        LOCATION: AVRSBLOC(AVWXTABL) DURING CREATION OF RSBLOCK.     *\n*        NAMES: RSO-----                                              *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nRSOURCE  DSECT\nRSOLOPC  DS    CL15                LABEL+OPCODE,NORMAL\nRSOOPRCM DS    CL56                OPERAND+COMMENTS FIELD\nRSOL1    EQU   *-RSOLOPC           LENGTH OF 1ST OR ONLY SOURCE CARD\nRSOLC    EQU   *-RSOOPRCM          LENGTH OF SOURCE CONTINUATION CARD\nRSOCONT  DS    C                   CONTINUATION COLUMN\nRSOSEQN  DS    CL8                 SEQUENCE NUMBERS,IF ANY\n         AIF   (NOT &$MACROS).AVNMCCC           SKIP IF NO MACROS\n         TITLE 'MACLIB DSECT AND EQUS'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> DSECT:  MACLIB   THIS DSECT GIVES THE FORMAT OF A MACRO          *\n*         LIBRARY ENTRY.                                              *\n*        NOTE: THIS IS ONLY MACRO DSECT NEEDED OUTSIDE MACRO PROCESSOR*\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE\nMACLIB   DSECT\nMCLIBNXT DS    F                   POINTER TO NEXT ENTRY\nMCLBNMLN DS    C                   LENGTH OF MACRO LIB ENTRY NAME\nMCLBNAM  DS    CL8                 MACRO LIBRARY ENTRY NAME\nMCLBFLGS DS    0C                  MACRO LIBRARY ENTRY FLAGS\nMCLBTAGS DS    C                   MACLIB ENTRY FLAG BYTE\nMCLBFLG2 DS    C                   MACRO LIBRARY ENTRY FLAGS\nMCLBFLG3 DS    C                   MACRO LIBRARY ENTRY FLAGS\nMCPOPRNB DS    H                   NUMBER OF OPERANDS (NOT LABEL FLD)\nMCKOPRNB DS    H                   NUMBER OF KEYWORD OPERANDS\nMCDDVPNT DS    F                   LINK TO LOCAL DICT DOPE VECTORS\nMCLOCDLN DS    F                   LENGTH OF LOCAL DICTIONARY\nMCLDNBRE DS    F                   # OF LOCAL DICT. ENTRIES\nMCPARPNT DS    F                   POINTER TO PARAMETER DOPE VECTORS\nMCCODLNK DS    F                   POINTER TO DEFINITION CODE\n$LMACLIB EQU   *-MACLIB            LENGTH OF MACLIB ENTRY\n         SPACE 5                                                      S\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> DSECT: MSGBLOCK        ERROR MESSAGE BLOCK                       *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nMSGBLOCK DSECT                                                        S\nMSGLENM1 DS    AL1                 L-1 OF NUMBR+MSG                   S\nMSGFLAG  DS    AL1                 MISC FLAG BYTE                     S\nMSGNMBR  DS    CL3                 ERROR #                            S\nMSGMSG   DS    0C                  VARYING LEN MSG                    S\n         SPACE 5                                                      S\nAVMCLBDF EQU   X'80'               MCLBTAGS - MACRO DEFINED FLAG\nAVMCLBNF EQU   X'40'               MCLBTAGS - MACRO SEARCHED FOR/LIBRY\n.AVNMCCC ANOP\n         TITLE '*** AVWXTABL DSECT - MAIN ASSEMBLER TABLE ***'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> DSECT: AVWXTABL   MAIN CONTROL TABLE FOR THE ASSEMBLER.          *\n*        THIS DSECT IS USED BY ALMOST ALL SUBROUTINES OF THE ASSEMBLER*\n*        FOR COMMUNICATION, COMMON CONSTANTS, AND WORKAREAS, AND IS   *\n*        ALSO USED SOMEWHAT BY THE MAIN PROGRAM ASSIST AND THE        *\n*        REPLACE MONITOR REMONI.                                      *\n*        LOCATION: CSECT VWXTABL, WITH SAME NAMES PREFIXED WITH 'A'.  *\n*        NAMES: AX------,AW------,AV------  (DEPENDS ON SECTION)      *\n*        THIS DSECT CONTAINS THE FOLLOWING SECTIONS:                  *\n*                                                                     *\n*              1. ADDRESS CONSTANTS(NAMES: AX, FOLLOWED BY ENTRY NAME)*\n*        THIS SECTION CONTAINS 1 ADDRESS CONSTANT FOR EVERY CALLABLE  *\n*        ENTRY POINT IN THE ASSIST ASSEMBLER.  THESE ARE READ-ONLY,   *\n*        EXCEPT DURING A REPLACE RUN, IN WHICH THE ADCONS FOR A       *\n*        SINGLE CSECT ARE TEMPORARILY MODIFIED.  THE LABEL AX$BASE IS *\n*        USED AS A BASE ADDRESS FOR THE CALCULATION OF OFFSETS TO     *\n*        INDIVIDUAL ADCONS, FOR THOSE ROUTINES REQUIRING TABLE-DRIVEN *\n*        CALLING SEQUENCES (CNDTL2,CODTL1,MPCON0,REMONI).  NOTE THAT  *\n*        ALL ENTRY POINTS HAVE 6-CHARACTER NAMES.  THE MACRO $CALL    *\n*        IS USED IN CONJUNCTION WITH THIS PART OF AVWXTABL.           *\n*                                                                     *\n*              2. CONSTANT VALUES (NAMES: AW------)                   *\n*        THIS SECTION CONTAINS USEFUL CONSTANT VALUES, SUCH AS        *\n*        ZEROES, BLANKS, MASK VALUES, TRANSLATE TABLES, EDIT PATTERNS.*\n*        ALL VALUES ARE READ-ONLY, EXCEPT THAT ANY ROUTINE MAY        *\n*        MODIFY PART OF THIS SECTION IF IT RESTORES IT BEFORE         *\n*        ALLOWING ANOTHER SUBROUTINE TO GAIN CONTROL.  TRANSLATE      *\n*        TABLES INCLUDE ONES FOR SCANNING DECIMAL NUMBERS AND MACHINE *\n*        INPUT CONVERSION - HEX TO BINARY, SCANNING SYMBOLS AND       *\n*        INSTRUCTION OPERANDS, SCANNING HEXADECIMAL CONSTANTS, DOING  *\n*        GENERAL EXPRESSIONS, CONVERTING BINARY TO OUPUT HEXADECIMAL. *\n*        GENERATION: SECTION AWCONADS IS CREATED BY MACRO WCONG.      *\n*                                                                     *\n*              3. VARIABLES (NAMES: AV------)                         *\n*        THIS SECTION CONTAINS ALL VARIABLE AREAS USED FOR            *\n*        COMMUNICATION INSIDE THE ASSIST ASSEMBLER, IN ADDITION TO    *\n*        VARIOUS WORKAREAS, WHICH MAY BE OVERLAPPED TO SAVE SPACE.    *\n*        THE AREAS PROVIDED INCLUDE THE RECORD BLOCKS, LOCATION       *\n*        COUNTER VALUES, CURRENT SECTION ID, CURRENT DYNAMIC STORAGE  *\n*        AREA LIMITS, AND VARIOUS FLAGS.  TEMPORARY WORKAREAS ARE     *\n*        SUPPLIED, ALL WITH 'WORK' INCLUDED IN THEIR NAMES, WHICH     *\n*        CAN BE USED BY ANY ROUTINE , BUT ARE NOT SAFE ACROSS A       *\n*        SUBROUTINE CALL.  NOTE THAT THIS SECTION REQUIRES EQU SYMBOLS*\n*        FROM CNCBLOCK AND THE RECORD BLOCKS TO ASSEMBLE CORRECTLY.   *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\nAVWXTABL DSECT\n         SPACE 1\n* * * * * NAMES IN AVWXTABL DSECT ARE SAME, EXCEPT WITH A'S PREFIXED  *\n* * * * * AVWXTABL SECTION X - ADDRESS CONSTANTS  * * * * * * * * * * *\nAX$BASE  DS    0A                  BASE ADDRESS FOR OFFSETS TO ROUTINES\n*              *** BROPS2 ENTRY POINTS ***                            *\nAXBRINIT DS    V(BRINIT)           BASE-REG INITIALIZATION\nAXBRUSIN DS    V(BRUSIN)           BASE-REG SET UP USING VALUE\nAXBRDROP DS    V(BRDROP)           BASE REG DROP A REGISTER\nAXBRDISP DS    V(BRDISP)           BASE REG GET BASE-DISPLACEMENT\nAXC$BASE DS    0F                  BASE ADDRESS FOR CONSTANT ADDR OFFSE\n*              *** CACONS ENTRY POINTS ***                            *\nAXCACON1 DS    V(CACON1)           SCAN A-TYPE CONST\nAXCACON2 DS    V(CACON2)           ASSEMBLE A-TYPE CONSTANT\n*              *** CBCONS ENTRY POINTS ***                            *\nAXCBCON1 DS    V(CBCON1)           SCAN BINARY CONSTANT\nAXCBCON2 DS    V(CBCON2)           ASSEMBLE BINARY CONSTANT\n*              *** CCCONS ENTRY POINTS ***                            *\nAXCCCON1 DS    V(CCCON1)           SCAN CHARACTER CONSTANT\nAXCCCON2 DS    V(CCCON2)           ASSEMBLE CHARACTER CONSTANT\n*              *** CDECNS ENTRY POINTS ***                            *\nAXCDECN1 DS    V(CDECN1)           SCAN FLOATING PT CONST\nAXCDECN2 DS    V(CDECN2)           ASSEMBLE FLOATING PT CONSTANT\nAXCDCON1 EQU   AXCDECN1            MAKE EQUATE FOR STANDARD NAMES\nAXCECON1 EQU   AXCDECN1            MAKE EQUATE FOR STANDARD NAMES\n*              *** CFHCNS ENTRY POINTS ***                            *\nAXCFHCN1 DS    V(CFHCN1)           SCAN FIXED POINT CONSTANT\nAXCFHCN2 DS    V(CFHCN2)           ASSEMBLE FIXED POINT CONSTANT\nAXCFCON1 EQU   AXCFHCN1            MAKE EQUATE FOR STANDARD NAMES\nAXCHCON1 EQU   AXCFHCN1            MAKE EQUATE FOR STANDARD NAMES\n*              *** CONSTANT PROCESSOR CONTROL ROUTINES ***            *\nAXCNDTL2 DS    V(CNDTL2)           PASS 2 CONSTANT PROCESSING\nAXCODTL1 DS    V(CODTL1)           DUPLICATION FACTOR-TYPE-LENGTH PROC\n*              *** CPCONS ENTRY POINTS ***                            *\nAXCPCON1 DS    V(CPCON1)           SCAN PACKED CONSTANT\nAXCPCON2 DS    V(CPCON2)           ASSEMBLE PACKED CONSTANT\n*              *** CVCONS ENTRY POINTS ***                            *\nAXCVCON1 DS    V(CVCON1)           SCAN V-TYPE CONSTANTS\nAXCVCON2 DS    V(CVCON2)           ASSEMBLE V-TYPE ADDRESS CONSTANTS\n*              *** CXCONS ENTRY POINTS ***                            *\nAXCXCON1 DS    V(CXCON1)           SCAN HEXADECIMAL CONSTANTS\nAXCXCON2 DS    V(CXCON2)           ASSEMBLE HEXADECIMAL CONSTANTS\n*              *** CZCONS ENTRY POINTS ***                            *\nAXCZCON1 DS    V(CZCON1)           SCAN ZONED CONSTANTS\nAXCZCON2 DS    V(CZCON2)           ASSEMBLE ZONED CONSTANTS\n*              *** ERRORS ENTRY POINTS ***                            *\nAXERRTAG DS    V(ERRTAG)           FLAG ERROR\nAXERRLAB DS    V(ERRLAB)           ERROR FLAG FOR A LABEL\n*              *** ESDOPRS ENTRY POINTS ***                           *\nAXESINT1 DS    V(ESINT1)           ESD ROUTINE INITIALIZATION\nAXESCSEC DS    V(ESCSEC)           CSECT,START, OR DSECT\nAXESENX1 DS    V(ESENX1)           ENTRY OR EXTRN - PASS 1\nAXESENX2 DS    V(ESENX2)           PASS 2 ENTRY AND EXTRN\n*              *** EVALUT - EXPRESSION EVALUATOR ***                  *\nAXEVALUT DS    V(EVALUT)           GENERAL EXPRESSION EVALUATION ROUT\n*              *** 2ND LEVEL PROCESSOR CSECTS ***                     *\nAXIAMOP1 DS    V(IAMOP1)           MACHINE OPCODES-PASS 1\nAXIBASM1 DS    V(IBASM1)           ASSEMBLER OPCODES - PASS 1\nAXICMOP2 DS    V(ICMOP2)           MACHINE OPCODES - PASS 2\nAXIDASM2 DS    V(IDASM2)           ASSEMBLER OPCODES - PASS 2\n*              *** INPUT1 ENTRY POINTS ***                            *\nAXINCARD DS    V(INCARD)           INPUT CARD PROCESSOR\n*              *** LTOPRS ENTRY POINTS ***                            *\nAXLTINT1 DS    V(LTINT1)           LITERAL TABLE INITIALIZATION\nAXLTENT1 DS    V(LTENT1)           ENTER A LITERAL INTO POOL\nAXLTDMP1 DS    V(LTDMP1)           RETURN LITERAL LENGTH-PASS 1\nAXLTEND1 DS    V(LTEND1)           END PASS 1 FOR LITERAL TABLE\nAXLTGET2 DS    V(LTGET2)           GET ADDRESS OF LITERAL\nAXLTDMP2 DS    V(LTDMP2)           PRODUCE LITERAL RECORDS-PASS 2\n         AIF   (NOT &$MACROS).AXNOMAC       SKIP IF NO MACROS\n*              ** MACROS ENTRY POINTS **                              *\nAXMACINT DS    V(MACINT)           MACRO INITIALIZATION ENTRY\nAXMACRO1 DS    V(MACRO1)           BUILD MACRO DEFINITION TABLES\nAXMEXPND DS    V(MEXPND)           MACRO EXPANSION ENTRY\nAXMCBODY DS    V(MCBODY)           PROCESS MACRO DEFINITION BODY\nAXMACSCN DS    V(MACSCN)           SCAN MACRO STATEMENT\nAXMACFND DS    V(MACFND)           SEARCH MACRO LIBRARY\nAXMCVSCN DS    V(MCVSCN)           SCAN VARIABLE SYMBOL\nAXMCSCOP DS    V(MCSCOP)           SCAN STANDARD OPERAND\nAXMCGTST DS    V(MCGTST)           MOVE STRING TO LOW CORE\nAXMCSYSR DS    V(MCSYSR)           SEARCH MACRO LIBRARIES FOR VAR SYMBL\nAXMACLEX DS    V(MACLEX)           MACRO STMT LEX ANALYSIS\nAXMCGNCD DS    V(MCGNCD)           MACRO DEFINITION CODE GENERATION\nAXMXMVSR DS    V(MXMVSR)           MOVE GENERATED STMT TO HIGH CORE\nAXMXERRM DS    V(MXERRM)           GENERATE ERROR MESSAGE\nAXMCDTRM DS    V(MCDTRM)           CHAR TO BINARY CONVERSION\nAXMCATRM DS    V(MCATRM)           TEST FOR ATTRIBUTE\n         DS    2V                  SPACE FOR MACRO ENTRY POINTS\n.AXNOMAC ANOP\n*              ***  MAIN PROGRAMS - PASS 1&2 ***                      *\nAXMOCON1 DS    V(MOCON1)           MAIN CONTROL - PASS 1\nAXMOSTOP DS    V(MOSTOP)           DISASTER EXIT-PASS 1\nAXMTCON2 DS    V(MTCON2)           MAIN CONTROL - PASS 2\n*              *** OPCOD1 ENTRY POINTS ***                            *\nAXOPINIT DS    V(OPINIT)           INITIALIZATION,IF ANY\nAXOPFIND DS    V(OPFIND)           LOOKUP OPCODE\n*              *** OUTPUT ENTRY POINTS ***                            *\nAXOUINT1 DS    V(OUINT1)           INITIALIZATION ENTRY FOR OUTPUT\nAXOUTPT2 DS    V(OUTPT2)           OUTPUT LINE PRINTER\nAXOUEND2 DS    V(OUEND2)           FINISH UP LAST PRINTING\n*              *** SCANRS ENTRY POINTS ***                            *\nAXSCANBL DS    V(SCANBL)           SCAN TO FIRST BLANK OUTSIDE OF C'\nAXSCANCO DS    V(SCANCO)           SCAN TO COMMA OR BLANK\nAXSCANEQ DS    V(SCANEQ)           SCAN TO = OR BLANK\n*              *** SDTERM ENTRY POINTS ***                            *\nAXSDBCDX DS    V(SDBCDX)           SELF DEFINING TERM-ALL 4 KINDS     *\nAXSDBTRM DS    V(SDBTRM)           BINARY SELF-DEFINING TERM\nAXSDCTRM DS    V(SDCTRM)           CHARACTER SELF-DEFINING TERM\nAXSDDTRM DS    V(SDDTRM)           DECIMAL SELF-DEFINING TERM\nAXSDXTRM DS    V(SDXTRM)           HEXADECIMAL SLEF-DEFINING TERM\n*              *** SYMOPS ENTRY POINTS ***                            *\nAXSYINT1 DS    V(SYINT1)           SYMBOL TABLE INITIALIZATION\nAXSYENT1 DS    V(SYENT1)           ENTER A SYMBOL INTO SYMBOL TABLE\nAXSYFIND DS    V(SYFIND)           LOOK UP A SYMBOL IN SYMBOL TABLE\nAXSYEND2 DS    V(SYEND2)           CLEANUP/STATISTICS AT END OF SYM TAB\n*              *** UTOPRS ENTRY POINTS ***                            *\nAXUTINT1 DS    V(UTINT1)           UTILITIES INITIALIZATION\nAXUTPUT1 DS    V(UTPUT1)           PASS 1 OUTPUT OF EXPANDED RECORDS\nAXUTEND1 DS    V(UTEND1)           END PASS 1-INIT FOR PASS 2\nAXUTGET2 DS    V(UTGET2)           GET ADDR'S OF EXPANDED RECRDS-PASS 2\nAXUTPUT2 DS    V(UTPUT2)           OBJECT CODE CREATION-PASS 2\nAXUTEND2 DS    V(UTEND2)           FINISH UP PASS 2\n         AIF   (NOT &$XREF).NOXREF2  SKIP IF NO CROSS REFERENCE       A\n*    CROSS REFERENCE ENTRY POINTS                                     A\nAXXRINT1 DS    V(XRINT1)           1ST PASS INIT ROUTINE              A\nAXXRINT2 DS    V(XRINT2)           2ND PASS INIT ROUTINE              A\nAXXRCOLL DS    V(XRCOLL)           COLLECTION ROUTINE                 A\nAXXRPRNT DS    V(XRPRNT)           PRINT ROUTINE                      A\nAXXRSCAN DS    V(XRSCAN)           CONTROL CARD SCANNING ROUTINE      A\n.NOXREF2 ANOP\nAXSPECAD DS    A                   BASE ADDRESS FOR SPECIAL ROUTINES\nAXSPECA2 DS    A                   BASE @ LEV2-PASS 2 - 'SPECIALS'\n         EJECT\n* * * * * AVWXTABL SECTION W - CONSTANTS  * * * * * * * * * * * * * * *\nAWD0     DS    0D                  FLOATING POINT 0 FOR CDE\nAWZEROS  DS    32D'0'              256 BYTES OF BINARY ZEROS\nAWD10    DS    D'10'               DOUBLEWORD CONSTANT 10\nAWF1     DS    F'1'                FULLWORD 1 CONSTANT\nAWH1     EQU   AWF1+2              HALFWORD 1 CONSTANT\nAWB1     EQU   AWF1+3              BYTE 1 CONSTANT\nAWF3     DS    F'3'                FULLWORD 3 CONSTANT\nAWH3     EQU   AWF3+2              HALFWORD 3 CONSTANT\nAWB3     EQU   AWF3+3              BYTE 3 CONSTANT\nAWF4     DS    F'4'                FULLWORD CONSTANT 4\nAWF7     DS    F'7'                FULLWORD 7 CONSTANT\nAWH7     EQU   AWF7+2              HALFWORD 7 CONSTANT\nAWB7     EQU   AWF7+3              BYTE 7 CONSTANT\nAWF10    DS    F'10'               FULLWORD CONSTANT 10\nAWH10    EQU   AWF10+2             HALFWORD CONSTANT 10\nAWF12    DS    F'12'               FULLWORD CONSTANT 12\nAWF15    DS    F'15'               FULLWORD CONSTANT 15 (4 1 BITS)\nAWFXF    EQU   AWF15               FULLWORD CONSTANT,4 1-BITS\nAWFXFF   DS    F'255'              FULLWORD CONSTANT 255\nAWF4095  DS    F'4095'             FULLWORD 4095 CONSTANT\nAWFXFFF  EQU   AWF4095             XL4'FFF'      ON F BOUNDARY\nAWHXFFF  EQU   AWFXFFF+2           XL2'0FFF'  ON H BOUNDARY\nAWFX7FFF DS    X'00007FFF'         MAXIMUM SIZE, MASK VALUE\nAWFXFFFF DS    X'0000FFFF'         65K DECIMAL NUMBER\nAWFX6F   DS    XL4'FFFFFF'         FULLWORD 24-BIT MASK\nAWFM4    DS    F'-4'               FULLWORD -4 CONSTANT\nAWFM1    DS    F'-1'               FULLWORD -1 CONSTANT\nAWHM1    EQU   AWFM1+2             HALFWORD -1 CONSTANT\n         EJECT\n*        TABLE USED TO SCAN DECIMAL NUMBERS                           *\n*        CHARACTERS 0-9 HAVE ZERO VALUES,ALL OTHERS NONZERO           *\n*        ALSO USED IN ICMOP2 FOR GENERAL SCANNING.                    *\n*   TR TABLE      0 1 2 3 4 5 6 7 8 9 A B C D E F                     *\nAWTDECT  DS    X'02020202020202020202020202020202'    0\n         DS    X'02020202020202020202020202020202'    1\n         DS    X'02020202020202020202020202020202'    2\n         DS    X'02020202020202020202020202020202'    3\n         DS    X'100202020202020202020202020C0202'    4 BLANK (\n         DS    X'02020202020202020202020608020202'    5  $ *\n         DS    X'02020202020202020202020E02020202'    6  ,\n         DS    X'02020202020202020202020606020A02'    7 # @ =\n         DS    X'02020202020202020202020202020202'    8\n         DS    X'02020202020202020202020202020202'    9\n         DS    X'02020202020202020202020202020202'    A\n         DS    X'02020202020202020202020202020202'    B\n         DS    X'02060404060606060606020202020202'    C B-C(4) ALPHS-6\n         DS    X'02060604060606060606020202020202'    D L-(4) ALPHS-6\n         DS    X'02020606060606040606020202020202'    E X-(4) ALPHS - 6\n         DS    X'00000000000000000000020202020202'    F\n         SPACE 1\n*        TABLE USED TO SCAN HEXADECIMAL CONSTANTS FOR CORRECTNESS     *\n*        CHARACTERS A-F,0-9 ARE ZERO,ALL OTHERS ARE NON-ZERO          *\nAWTHEXT  DS    X'02020202020202020202020202020202'    0\n         DS    X'02020202020202020202020202020202'    1\n         DS    X'02020202020202020202020202020202'    2\n         DS    X'02020202020202020202020202020202'    3\n         DS    X'02020202020202020202020202020202'    4\n         DS    X'02020202020202020202020202020202'    5\n         DS    X'02020202020202020202020202020202'    6\n         DS    X'02020202020202020202020202020202'    7\n         DS    X'02020202020202020202020202020202'    8\n         DS    X'02020202020202020202020202020202'    9\n         DS    X'02020202020202020202020202020202'    A\n         DS    X'02020202020202020202020202020202'    B\n         DS    X'02000000000000020202020202020202'    C\n         DS    X'02020202020202020202020202020202'    D\n         DS    X'02020202020202020202020202020202'    E\n         DS    X'00000000000000000000020202020202'    F\n         SPACE 1\n*        TABLE USED TO CONVERT HEXADECIMAL CONSTANTS                  *\nAWTHEX2  EQU   *-C'A'              OFFSET SYMBOL FROM TABLE CORRECTLY\n*   TR TABLE      0 1 2 3 4 5 6 7 8 9 A B C D E F                     *\n         DS      X'0A0B0C0D0E0F000000000000000000'    C\n         DS    X'00000000000000000000000000000000'    D\n         DS    X'00000000000000000000000000000000'    E\n         DS    X'00010203040506070809'                F\n         EJECT\n*        USED TO SCAN ACROSS SYMBOLS,STOP ON DELIMITERS               *\n*        CHARACTERS $,#,@,A-Z,0-9 ARE ZERO. ALL OTHERS ARE NONZERO    *\n*        ALSO USED IN EVALUT FOR OPERATOR CODES- (+*)-/,              *\n*   TR TABLE      0 1 2 3 4 5 6 7 8 9 A B C D E F                     *\nAWTSYMT  DS    X'01010101010101010101010101010101'     0\n         DS    X'01010101010101010101010101010101'     1\n         DS    X'01010101010101010101010101010101'     2\n         DS    X'01010101010101010101010101010101'     3\n         DS    X'04010101010101010101010101020501'     4 BLANK (+\n         DS    X'01010101010101010101010007030101'     5 $*)\n         DS    X'06080101010101010101010401010101'     6 -/,\n         DS    X'01010101010101010101010000010101'     7  #@\n         DS    X'01010101010101010101010101010101'     8\n         DS    X'01010101010101010101010101010101'     9\n         DS    X'01010101010101010101010101010101'     A\n         DS    X'01010101010101010101010101010101'     B\n         DS    X'01000000000000000000010101010101'     C  A-I\n         DS    X'01000000000000000000010101010101'     D  J-S\n         DS    X'01010000000000000000010101010101'     E  S-Z\n         DS    X'00000000000000000000010101010101'     F  0-9\n         SPACE 1\nAWTZTAB  EQU   AWZEROS             SPACE FOR 256-BYTE ZEROED TRT TABLE\n         DS    0D                  LINE UP BLANKS ON D BOUNDARY\nAWBLANK  DS    CL132' '            BLANKS\n         ORG   AWBLANK+16          MAXIMUM OVERLAP OF AWBLANK&AWTHEX3\n*        TABLE USED TO CONVERT INTERNAL BINARY TO EXTERNAL HEX.       *\n*   TR TABLE     0123456789ABCDEF0123456789ABCDEF                     *\nAWTHEX3  DS    C'                                '    0-1\n         DS    C'                                '    2-3\n         DS    C'                                '    4-5\n         DS    C'                                '    6-7\n         DS    C'                                '    8-9\n         DS    C'                                '    A-B\n         DS    C'                                '    C-D\n         DS    C'                0123456789ABCDEF'    E-F\nAWEP4    DS    X'40202120'         4-BYTE DECIMAL EDIT PATTERN\nAWEP6    DS    X'402020202120'     6-BYTE EDIT PATTERN FOR DEC #\nAWP0     DS    PL1'0'              FOR ZEROING DECIMAL COUNTERS\nAWP1     DS    P'1'                DECIMAL CONSTANT 1\nAWCONADS DS    ($CNT$N)AL1         OFFSETS TO CONSTANT PROG ADCONS\n         EJECT\nAVOENTR  EQU   B'00000010'         (AVTAGS1)<AOBJIN> ENTRY @ FROM END\nAVO1TXT  EQU   B'00000100'         (AVTAGS1)<AOBJIN> >=1 TXT CARDS FND\n         SPACE 1\n* * * * * AVWXTABL SECTION V - VARIABLES  * * * * * * * * * * * * * * *\n         DS    0D                  GET ALIGNMENT\n*        **NOTE  VARIABLES FROM HERE THRU AVAJL ARE GIVEN INITIAL     *\n*        VALUES BY CALLING PROGRAM BEFORE CALLING MPCON0.             *\nAVADDLOW DS    F                   POINTER TO HIGH END OF LOW AREA\n*                        GIVES FIRST FREE LOCATION AT LOW END.        *\nAVADDHIH DS    F                   POINTER TO LOW ADDR OF HIGH END\n*                        GIVES LOWEST ADDR OF ALREADY USED SPACE      *\nAVECONPT DS    A                   @ ECONTROL, IF NEEDED (REPLMON)\nAVAJOBPT DS    A                   @ AJOBCON TABLE, IN CASE EVER NEEDED\n         SPACE 1\n*              VARIABLES FROM HERE TO AVAJL CORRESPOND TO AJOBOCN\n*              SECTION AJONERR - AJOAVL, AND CANNOT BE CHANGED WITHOUT\n*              EXTREME CARE.  AJOAVL MUST = AVAJL.\n         CNOP  2,4                 ALIGN AVNERR LIKE AJONERR\nAVNERR   DS    H                   MAX # ACTUAL ERRORS ALLOWED\n         SPACE 1\n         AIF   (NOT &$MACROS).AVMXX1        SKIP IF NO MACROS AT ALL\n         SPACE 1\n*        AVMMACTR-AVMMSTMG MUST BE IN SAME ORDER AS AJOMACTR-AJOMSTMG.\nAVMMACTR DS    F                   DEFAULT INITIAL VALUE OF MACRO ACTR\nAVMMNEST DS    F                   ABSOLUTE LIMIT ON MACRO NEST LEVEL\nAVMMSTMG DS    F                   GLOBAL LIMIT ON MACRO STMTS PROCESSD\nAVTAGSM  DS    B                   MACRO OPTIONS BITS (FROM AJOASMFM)\n*   BIT7=0 => NO MACROS ALLOWED.   =1(AJOMACRO) => MACROS ALLOWED\n*   BIT6=0 => NO ASM G FEATURES.   =1(AJOMACRG) => ADD MACRO G TO ABOVE\n*   BIT5=0 => NO ASM H FEATURES    =1(AJOMACRH) => ADD MACRO H TO F\n*   REMAINING BITS RESERVED FOR FUTURE USE WITH MACRO PROCESSING.     *\n.AVMXX1  ANOP\nAVTAGS0  DS    B                   FLAG- FUTURE USE FROM AJOBCON\n         SPACE 1\nAVTAGS1  DS    B                   1ST BYTE OF FLAG BITS\n*   BIT0=0 => START ALLOWED, =1($IBSTAR1)=> START NO LONGER ALLOWED.  *\n*   BIT1=0 => CURRENT SECTION IS CSECT, =1($IBDSEC1)=> IN DSECT NOW   *\n*   BIT2=0 => NO PRIVATE CODE, =1($IBPRCD1)=> PRIV CODE HAS OCCURREC  *\n*   BIT3=0 => NORMAL LOAD, =1(AJORELOC)=> LOAD RELOCATED TO REAL @'S  *\n*   BIT4=0 => ALL IN CORE, =1(AJODISKU) => USE DISK INTERMEDIATE.     *\n*   BIT5=0 => NORMAL PROGRAM, =1(AJOLARGE)=> PROG LARGE, CRUNCH MUCH  *\n*   BIT6=0 => LIST SOURCE, =1(AJNLIST)=> NOLIST (EXCEPT ERRORS)       *\n*   BIT7=0 => LOAD OBJECT CODE, =1(AJNLOAD)=> CREATE NO OBJECT CODE   *\n*        *NOTE* BITS 3-7 ARE SET FROM AJOASMF, BITS 0-2 INIT  = 0.    *\n*              AVTAGS1 BITS ALSO USED BY OBJECT CODE LOADER AOBJIN.\n*   BIT0=0 => NO TXT CARDS FOUND YET. =1(AVO1TXT) => >= 1 CARD FOUND. *\n*   BIT1=0 => NO ENTRY @ FND ON END CARD YET. =1(AVOENTR) => FOUND.   *\n         SPACE 1\nAVTAGS2  DS    B                   2ND BYTE OF FLAG BITS\n*   BIT0=0 => NO EOF FOUND, =1($INEND2)=> EOF, CREATE END CARD\n*   BIT1=0 => CONTINUE ASSEMBLY. =1(AJOASTOP) ==> STOP ASSEMBLY.\n*   BIT0=0 => NODECK. =1(AJODECK) => OBJECT DECK(USES <AODECK>).      *\n*   BIT6=0 => NO COMMENT CHECK. =1 REQUIRES &$COMNT % OF MACH INSTS\n*   BIT7=0=> NORMAL LISTING. =1 => CMPRS LISTING (2 STMTS/LINE)\n*   OTHER BITS FOR FUTURE USE, SET FROM AJOASMF2 IN AJOBCON.          *\n         AIF   (NOT &$XREF).NOXREF1 SKIP IF NO XREF                   A\nAVXRFLAG DS    C                   FLAG BYTE FOR CROSS REFERENCE      A\n          SPACE 2\n* THE FOLLOWING FLAGS USED IN TESTING THE ABOVE FLAG                  A\n         SPACE\nAVXRON   EQU   B'00100000'         XREF FACILITY ON                   A\nAVXRCOMP EQU   B'00110000'         COMPRESSED LISTING                 A\nAVXRSDMD EQU   B'00001000'         SD OPERAND MOD REFERENCE           A\nAVXRSDFT EQU   B'00000100'         SD OPERAND FETCH REFERENCE         A\nAVXRSRMD EQU   B'00000010'         SR OPERAND MOD                     A\nAVXRSRFT EQU   B'00000001'         SR OPERAND FETCH                   A\n.NOXREF1 ANOP\nAVAJL    EQU   *-AVNERR            LENGTH OF BLOCK FROM AJOBCON\n*              VRADL,VRADH,VRELOC,VFENTER,VLOCLOW,VLOCHIH MUST BE IN  *\n*        THE ORDER WHICH IS GIVEN.  THEY ARE USED IN LM-STM GROUPS    *\nAVRADL   DS    A                   LOWEST REAL ADDRESS OF USER PROGRAM\nAVRADH   DS    A                   HIGHEST REAL ADDRESS OF USER PROGRAM\nAVRELOC  DS    F                   RELOCATION FACTOR FOR OBJECT CODE\nAVZAREA1 DS    0F                  VARIABLE AREA TO BE ZEROED-BEGINNING\nAVFENTER DS    A                   PROGRAM ENTRY POINT ADDRESS\n*              AVLOCLOW,AVLOCHIH,AVLOCNTR,AVCSLOW,AVCSHIH-REQUIRED ORDR\nAVLOCLOW DS    F                   LOWEST LOCATION COUNTER(START OR 0)\nAVLOCHIH DS    F                   HIGHEST VALUE OF AVLOCCNTR\nAVLOCNTR DS    F                   LOCATION COUNTER\nAVCSLOW  DS    F                   CURRENT CSECT LOW LOCCNTR VALUE\nAVCSHIH  DS    F                   CURRENT CSECT HIGH VALUE\n         SPACE 1\nAVSTMTNO DS    H                   TOTAL # OF STATEMENTS\nAVSTMTER DS    H                   TOTAL # STMTS FLAGGED\nAVNERRA  DS    H                   # FATAL ERROR MESSAGES\nAVNWARN  DS    H                   # WARNING MESSAGES\nAVOUCOUN DS    H                   WITHIN PAGE LINE COUNT (OUTPUT)\nAVOULNCN DS    PL3                 STATEMENT NUMBER CURRENT\nAVOUPGCN DS    PL2                 NUMBER OF PAGES (OUTPUT)\n         AIF   (NOT &$XREF).NOXREF4  SKIP IF NO XREF\nAVXRLAVS DS    F                   LIST OF AVAIL SPACE FOR XREF       A\nAVXRHEAD DS    F                   HEADER POINTER FOR XREF TREE       A\nAVXRCNT  DS    H                   COUNTER FOR NUMBER OF REFERENCES   A\nAVXRLNCN DS    PL3                 ADDITIONAL LINE COUNTER FOR XREF   A\nAVXRMDFT DS    C                   ADDITIONAL FLAG FOR XREF           A\n* FLAG TO BE TESTED WITH THE FOLLOWING                                A\nAVXRMOD1 EQU   B'10000000'         MODIFY FIRST OPERAND               A\nAVXRMOD2 EQU   B'01000000'         MODIFY SECOND OPERAND              A\nAVXRMOD3 EQU   B'00100000'         MODIFY THIRD OPERAND               A\nAVXRMOD4 EQU   B'00010000'         MODIFY FIRST THRU SECOND OPERAND   A\nAVXRFET1 EQU   B'00001000'         FETCH FIEST OPERAND                A\nAVXRFET2 EQU   B'00000100'         FETCH SECOND OPERAND               A\nAVXRFET3 EQU   B'00000010'         FETCH THIRD OPERAND                A\nAVXRFET4 EQU   B'00000001'         FETCH FIRST THRU SECOND OPERAND    A\nAVXRTYPE DS    C                   USED TO TEST M/F REFERENCE         A\nAVXRFTCH EQU   X'08'               USED TO TEST ABOVE FLAG            A\n* IF NOT TYPE , MUST BE MODIFY REFERNCE                               A\n.NOXREF4 ANOP\n         SPACE\nAVCESDID DS    C                   CURRENT CSECT ESDID\n*              EVEN VALUE=> CSECT, ODD VALUE=> DSECT ($ESDSECT FLAG).\nAVPRINT  DS    C                   LISTING CONTROL FLAG BYTE\nAVPRINT1 DS    C                   LISTING CONTROL: 1ST PASS ONLY\nAVPRSAVE EQU   B'00000001'         (AVPRINT1,AVPRINT)==> SAVE IN 1ST PS\nAVDEBUG  DS    C                   DEBUGGING FLAG TESTED BY XSNAPS\nAVTAGS3  DS    B                   VARIOUS FLAGS\n*  BIT0=0 => NO STORAGE OVERFLOW. =1(AVOVERFL) => STORAGE EXCEEDED.\nAVOVERFL EQU   B'10000000'         (AVTAGS3) => STORAGE OVERFLW OCCRD\nAVMTAG00 DS    B                   MISC FLAG BYTE, MACRO COMMUNICATION\nAVMOPENC EQU   B'00000001'         (AVMTAG00)==> GBLX,LCLX IN OPEN COD\nAVMNOMAC EQU   B'00000010'         (AVMTAG00) => NO MORE MACROS       S\n*                                  BECAUSE GBLX, LCLX, ETC. FOUND     S\nAVMOPDIC EQU   B'00000100'         (AVMTAG00) => OPEN CODE LOCAL      S\n*                                  DICTIONARY HAS BEEN ALLOCATED      S\nAVMOPGO  EQU   B'00001000'         (AVMTAG00) => SUCCESSFUL AIF/AGO   S\nAVMOPMIN EQU   B'00010000'         (AVMTAG00) - OPEN CODE MACLIB ENTRY X\n                                   IS PROPERLY ZEROED & @ OF LOCAL    SX\n                                   DUMMY HAS BEEN ENTERED             S\nAVMISC00 DS    B                   MISC FLAG BYTE, FUTURE USE\nAVMISC01 DS    B                   MISC FLAG BYTE, FUTURE USE\nAVMISC02 DS    B                   MISC FLAG BYTE, FUTURE USE\nAVZAREA2 DS    0D                  VARIABLE AREA TO BE ZEROED - END\n         EJECT\nAVECONTR DS    0D                  ECONTROL DSECT WILL BE LOCATED HERE\nAVCONCAT DS    CL256               SPACE FOR CONSTANT BUILDING(CNDTL2)\nAVCONBLD DS    CL256               CONSTANT/CODE BUILDING AREA\nAVRSBLOC DS    CL(RSB$L+RSOL1+80+RSOLC*($RSMXCRD-2)) RSBLOCK AREA\nAVRSCBLK DS    (RSCONSQ-RSCBLK+$RSMXCRD*RSC$LEN)C AREA FOR RSCBLK\nAVREBLK  DS    0C                  BEGINNING OF RECORD ERROR BLOCK\nAVREBLN  DS    C                   RECORD ERROR BLOCK LENGTH-1\nAVREBES  DS    ($ERREBMX)CL2       ERROR CODE AREAS\nAVREBSCN EQU   AVREBES             BYTE FOR SCAN OFFSET\nAVREBERR EQU   AVREBES+1           BYTE FOR ERROR CODE\n         ORG   ,                   MAKE SURE BACK FAR ENOUGH\n         SPACE 1\nAVDWORK1 DS    D                   1ST DOUBLE WORD WORK AREA\nAVDWORK2 DS    D                   2ND DOUBLE WORD WORK AREA\nAVRCBPT  DS    A                   ADDRESS OF RECORD CODE BLOCK\nAVREBPT  DS    A                   ADDRESS OF RECORD ERROR BLOCK\nAVRSBPT  DS    A                   ADDRESS OF RECORD SOURCE BLOCK\nAVRSCPT  DS    A                   RECORD SOURCE CODE BLOCK POINTER\nAVLABPT  DS    F                   ADDRESS OF LABEL ENTRY,=0 IF NO LAB\nAVFWORK1 DS    F                   1ST FULLWORD WORKAREA\nAVMPSPIE DS    A                   @ SPIE BLOCK WHEN ENTERED ASSEMBLER\nAVSOLAST DS    A                   @ BLANK BEFORE ' AFTER SOURCE STMT\n         AIF   (&$COMNT EQ 0).AVNOCOM       SKIP IF NO COMMENT CHECKING\n*              FOLLOWING 2 VARIABLES MUST BE IN GIVEN ORDER.\nAVMACHIN DS    H                   # MACHINE INSTS, SET BY IAMOP1\nAVCOMNTN DS    H                   # MACHINE INSTS WITH COMMENTS\n.AVNOCOM ANOP\n         AIF   (&$DISKU EQ 0).AVDKTA        SKIP IF NO DISK AT ALL\n*\n*        BUFFER CONTROL BLOCK FOR DISK UTILITY I/O SYNCHRONIZATION\n*\nAVBCB    DS    0F                  BUFFER CONTROL BLOCK\nAVDECB   DS    A(0)                ADDRESS OF CURRENT DECB\nAVBUFF@  DS    A(0)                ADDRESS OF CURRENT BUFFER\nAVBUFINC DS    A(0)                POINTER TO 1ST UNUSED BYTE IN BUFFER\nAVBUFEND DS    A(0)                POINTER TO END OF BUFFER\n         AIF   (&$BUFNO EQ 1).AVDKTA        SKIP IF ONLY 1 BUFFER\nAVDECBNX DS    A(0)                ADDRESS OF NEXT DECB\nAVDECBLT DS    A(0)                POINTER TO LAST DECB\n.AVDKTA  ANOP\n         AIF   (NOT &$MACROS).AVNOMAC       SKIP IF NO MACROS\n         SPACE 2\n*              VARIABLES USED IN MACRO PROCESSING.                    *\nAVSYSECT DS    D                   CURRENT CSECT/DSECT NAME\nAVGEN1CD DS    A                   @ 1ST BYTE BEYOND 1ST GEN'D CARD-\n*              SET BY MEXPND.  THEN USED AS PTR BY INCARD.\nAVGEN2CD DS    A                   USED AS PTR BY INCARD. HAS @ LAST\n*              CARD GENERATED BY MEXPND (ORIG SETTING OF AVADDHIH).\nAVMACSPC EQU   *                   LABEL FOR SPACE FOR MACRO AVM'S\n*\n.AVNOMAC ANOP\n         AIF   (NOT &$MACROS).AVNLIB         SKIP IF NO MACROS\nAVMFLD1  DS    F                   POINTER TO CURRENT LABEL FIELD\nAVMFLDL1 DS    C                   LENGTH OF LABEL\nAVMFLDT1 DS    C                   TYPE OF LABEL - SEQ, VAR OR OTHER\nAVMFLD1H DS    H                   NOT CURRENTLY USED\nAVMFLD2  DS    F                   POINTER TO OPCODE FIELD\nAVMFLDL2 DS    C                   LENGTH OF OPCODE FIELD\nAVMFLDT2 DS    C                   TYPE OF OPCODE - ASM, MACR OR MAC IN\nAVMFLD2H DS    H                   NOT CURRENTLY USED\nAVMFLD3  DS    F                   POINTER TO OPERAND FIELD\nAVMFLDL3 DS    C                   LENGTH OF OPERAND FIELD\nAVMFLDT3 DS    C                   TYPE OF OPERAND FIELD\nAVMFLD3H DS    H                   NOT CURRENTLY USED\nAVMFLD4  DS    F                   POINTER TO COMMENT FIELD\nAVMFLDL4 DS    C                   LENGTH OF COMMENT FIELD\nAVMFLDT4 DS    C                   TYPE OF COMMENT FIELD - NOT USED\nAVMFLD4H DS    H                   NOT CURRENTLY USED\nAVMFLD5  DS    F                   2ND CARD NON STND OPRND\nAVMFLDL5 DS    C                   2ND CARD NON STND OPRND LENGTH\nAVMFLDT5 DS    C                   2ND CARD NON STND OPRND TYPE\nAVMFLD5H DS    H                   NOT CURRENTLY USED\nAVMFLD6  DS    F                   2ND NON STND CARD COMMENT\nAVMFLDL6 DS    C                   2ND NON STND CARD COMMENT LENGTH\nAVMFLDT6 DS    C                   2ND NON STND CARD COMMENT TYPE\nAVMFLD6H DS    H                   NOT CURRENTLY USED\nAVMFLD7  DS    F                   3RD NON STND CARD OPRND\nAVMFLDL7 DS    C                   3RD NON STND CARD OPRND LENGTH\nAVMFLDT7 DS    C                   3RD NON STND CARD OPRND TYPE\nAVMFLD7H DS    H                   NOT CURRENTLY USED\nAVMFLD8  DS    F                   3RD NON STND CARD COMMENT\nAVMFLDL8 DS    C                   3RD NON STND CARD COMMENT 6ENGTH\nAVMFLDT8 DS    C                   3RD NON STND CARD COMMENT TYPE\nAVMFLD8H DS    H                   NOT CURRENTLY USED\n$LAVMFLD EQU   *-AVMFLD1           LENGTH OF FIELD INFO POINTERS\n         SPACE 1\nAVMBYTE1 DS    C                   1ST MACRO FLAG BYTE\nAVMBYTE2 DS    C                   2ND MACRO FLAG BYTE\nAVMBYTE3 DS    C                   3RD MACRO FLAG BYTE\nAVMBYTE4 DS    C                   FLAG BYTE\nAVMBYTE5 DS    C                   FLAG BYTE\n         SPACE 1\nAVMSYMLN DS    C                   LENGTH OF CURRENT SYMBOL\nAVMSYMBL DS    CL8                 GLOBAL AREA FOR CURRENT SYMBOL\nAVMSYSDX DS    PL2                 CURRENT &SYSNDX COUNT\n         SPACE 1\nAVMSEQPT DS    F                   POINTER TO SEQ SYMBOL TABLE\nAVMCRINS DS    F                   CURRENT GENERATED INSTRUCTION @\nAVMMACID DS    F                   CONTAINS ID NUMBER OF CURRENT MACRO\nAVMACNST DS    F                   CURRENT MACRO NESTING COUNT\nAVMLDICT DS    F                   POINTER TO OPEN LOCAL DICTIONARY\nAVMGDICT DS    F                   POINTER TO GLOBAL DICTIONARY\nAVMACLIB DS    F                   POINTER TO MACRO LIBRARY\nAVMOVRFL DS    A                   @ OVERFLOW EXIT ROUTINE\nAVMTSCNP DS    F                   TEMP STORAGE FOR SCAN POINTER\n         SPACE 1\nAVMBSPIE DS    F                   TEMP STORAGE FOR MCBODY $SPIE INT @\n         ORG   AVMBSPIE            PUT AVMXSPIE IN SAME PLACE**********\nAVMXSPIE DS    F                   TEMP STORAGE FOR MXPEND SPIE INT @\n         SPACE 1\nAVMCHSTR DS    F                   @ OF CHARACTER WORK AREA\nAVMCHLIM DS    F                   LAST AVAILABLE BYTE OF CHAR WORK\nAVMWRKL1 DS    F                   @ OF LAST BYTE OF AVMWRK1\nAVMWRKL2 DS    F                   @ OF LAST BYTE OF AVMWRK2\n         SPACE 1\nAVMWRK1  DS    CL256               MACRO WORK AREA 1\nAVMWRK2  EQU   AVCONCAT            USE CONCAT FOR WORK AREA 2\n         SPACE 1\nAVMDWRK1 DS    D                   1ST DOUBLE WORD WORK AREA\nAVMDWRK2 DS    D                   2ND DOUBLE WORD WORK AREA\nAVMDWRK3 DS    D                   3RD DOUBLE WORD WORK AREA\nAVMDWRK4 DS    D                   4TH DOUBLE WORD WORK AREA\n         SPACE 1\nAVMFWRK1 DS    F                   1ST FULL WORD WORK AREA\nAVMFWRK2 DS    F                   2ND FULL WORD WORK AREA\nAVMFWRK3 DS    F                   3RD FULL WORD WORK AREA\nAVMFWRK4 DS    F                   4TH FULL WORD WORK AREA\n         SPACE 1\nAVMHWRK1 DS    H                   1ST HALFWORD WORK AREA\nAVMHWRK2 DS    H                   2ND HALFWORD WORK AREA\nAVMHWRK3 DS    H                   3RD HALFWORD WORK AREA\nAVMHWRK4 DS    H                   4TH HALFWORD WORK AREA\n         SPACE 1\nAVMSNBY1 DS    C                   CONTAINS FLAGS TO CONTROL SNAPS\nAVMSNBY2 DS    C                   CONTAINS FLAGS TO CONTROL SNAPS\n         AIF   (NOT &$MACSLB).AVNLIB         SKIP IF NO LIBRARY FETCH\nAVLIBBUF DS    F                   POINTER TO LIBRARY BUFFER SPACE\n.AVNLIB  ANOP\nAVWXEND  DS    0D                  ENDING @ AVWXTABL\n         TITLE 'ERCOMPCD DSECT - COMPLETION CODE MESSAGE BLOCK'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> DSECT: ERCOMPCD   COMPLETION CODE/ERROR MESSAGE BLOCK            *\n*        THIS GIVES FORMAT OF 1 COMPLETION CODE/MESSAGE BLOCK FOR     *\n*        USE IN A USER COMPLETION DUMP BY SUBROUTINE XXXXSNAP.  THE   *\n*        ADDRESS OF THE APPROPRIATE BLOCK IS PLACED INTO WORD ECERRAD *\n*        IN DSECT ECONTROL, AND IS USED THEN BY XXXXSNAP TO PRINT THE *\n*        INFORMATION IN THE ERCOMPCD BLOCK.                           *\n*        LOCATION: INSIDE EXECUT, WILL BE ELSEWHERE(FUTURE).          *\n*        GENERATION: 1 BLOCK CREATED BY 1 CALL TO $ERCGN MACRO.       *\n*        NAMES: ERC-----                                              *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nERCOMPCD DSECT\nERCSYST  EQU   0                   (ERCTYPE)==> SYSTEM COMPLETION CODE\nERCASSI  EQU   1                   (ERCTYPE)==> ASSIST SPECIAL MESSAGE\nERCUSER  EQU   2                   (ERCTYPE)==> USER ABEND COMPLETION\nERCLENG  DS    C                   LENGTH-1 OF ERCMSSG\nERCTYPE  DS    C                   CODE OF COMPLETION TYPE\nERCMSSG  DS    0C                  COMPLETION MESSAGE(VARIABLE LENGTH)\n         TITLE 'AJOBCON - MAIN JOB CONTROL TABLE DSECT'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> DSECT: AJOBCON    MAIN JOB CONTROL TABLE                         *\n*        THIS DSECT PROVIDES THE PRIMARY COMMUNICATION TABLE USED     *\n*        BY THE MAIN PROGRAM ASSIST, THE I/O ROUTINES(XXXXIOCO), THE  *\n*        PARM FIELD ANALYZER (APARMS), THE MAIN PROGRAM OF THE        *\n*        ASSEMBLER (MPCON0), AND THE REPLACE MONITOR (REMONI).  IT    *\n*        PROVIDES FOR GLOBAL FLAG VALUES DEALING WITH THE OVERALL     *\n*        JOB IN PROGRESS, PARM FIELD VALUES, USEFUL CONSTANTS, BLANKS,*\n*        ZEROES, WORKAREAS, AND DYNAMIC STORAGE AREA LIMITS.          *\n*        LOCATION: IN TABLE ASJOBCON OF CSECT ASSIST.                 *\n*        NAMES: AJ------                                              *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nAJOBCON  DSECT\n*              FOLLOWING EQU'S USED FOR COMMUNICATION BETWEEN ASSIST  J\n*              AND XXXXSORC DURING CONTROL CARD CHECKING. VALUES ARE  J\n*              PLACED INTO AJOBTRQ AND ATOBTYP.                       J\nAJO$D    EQU   0                   (AJOBTRQ)- DATA READ (NORMAL CASE) J\nAJO$J    EQU   1                   (AJOBTRQ)- LOOKING FOR $JOB CARD   J\nAJO$E    EQU   2                   (AJOBTRQ)- LOOKING FOR $ENTRY      J\nAJOAPRSE EQU   B'00000001'         (AJOAPMOD)- ZERO ALL APCFLAG SET\n*                                  BITS BEFORE SCANNING PARM OPTIONS\nAJOAPDEF EQU   B'00000010'         (AJOAPMOD)- DEFAULT CALL TO APARMS-\n*                                  OVERRIDE NO VALUE ALREADY SET ANY WY\nAJOAPFIN EQU   B'00000100'         (AJOAPMOD)- FINAL CALL TO APARMS-\n*                                  SET ANY FINAL FLAGS NEEDED.\nAJOAPMOV EQU   B'00001000'         (AJOAPMOD)- MOVE PARM FIELD INTO\n*              AJOPARM, WITH BLANK PADDING.  IF NOT SET, APARMS WILL\n*              LEAVE PARM WHERE IT IS, AND ASSUME THAT ITS LENGTH\n*              INCLUDES AT LEAST ONE BLANK FOLLOWING ACTUAL PARM.\n         SPACE 1\n*        ----- NEXT 2 BITS POSSIBLY SET ONLY WHEN &$TIMER=2,&$RECORD=2\nAJOAPUSR EQU   B'01000000'         (AJOAPMOD)- SET IF USER SUPPLIED R=\nAJOAPUST EQU   B'10000000'         (AJOAPMOD)- SET IF USER SUPPLIED T=\nAJOBATCH EQU   B'00000001'         (AJOMODE)==> BATCH MODE,DON'T CLOSE\n         SPACE 1\nAJOREPLF EQU   B'00000010'         (AJOMODE)==> REPLACE MODE RUN\nAJOMONIT EQU   B'00000100'         (AJOMODE)==> RUNNING UNDER WATFR MON\nAJNSYSIN EQU   B'00001000'         (AJOMODE)==> NO SYSIN, ABORT RUN\nAJOSRECX EQU   B'00100000'         (AJOMODE)==> RECORD OVERRUN OCCURRED\nAJOSOVRT EQU   B'00010000'         (AJOMODE)==> TIME OVERRUN OCCURRED\nAJOREPHB EQU   B'01000000'         (AJOMODE)==>REPLACEMENT PHASE B\n         SPACE 1\nAJOMSINT EQU   B'00000001'         (AJOSTEP)- MAIN STORAGE INIT DONE\nAJOSDUMP EQU   B'00100000'         (AJOSTEP)- PROGRAM IN DUMPING PHS\nAJOSEXEC EQU   B'01000000'         (AJOSTEP)==> PROGR IN EXECUTION\nAJOSASM  EQU   B'10000000'         (AJOSTEP)==> PROG IN ASSEMBLY PHASE\n         SPACE 1\nAJNLOAD  EQU   B'00000001'         (AJOASMF)==> CHECK ONLY, NO OBJCT CD\nAJNLIST  EQU   B'00000010'         (AJOASMF)==> NO LISTING DESIRED\nAJOLARGE EQU   B'00000100'         (AJOASMF)==> PROGRAM IS LARGE,OPTIM\nAJODISKU EQU   B'00001000'         (AJOASMF,AVTAGS1) => DISK OPTION\nAJORELOC EQU   B'00010000'         (AJOASMF)==> RELOC CODE TO REAL @'S\n         SPACE 1\nAJOCMPRS EQU   B'00000001'         (AJOASMF2,AVTAGS2)-COMPRESSD LISTING\nAJOCOMNT EQU   B'00000010'         (AJOASMF2-AVTAGS2)- COMMENT CHECK\nAJODECK  EQU   B'00000100'         (AJOASMF2-AVTAGS2)- PUNCH OBJ DECK\nAJOASTOP EQU   B'01000000'         (AJOASMF2-AVATGS2)- STOP ASSEMBLY\n         SPACE 1\nAJOMACRO EQU   B'00000001'         (AJOASMFM,AVMTAGSM)=> MACROS(F) OK\nAJOMACRG EQU   B'00000010'         (AJOASMFM,AVMTAGSM)=> ASM G MACROS\nAJOMACRH EQU   B'00000100'         (AJOASMFM,AVMTAGSM)=> ASM H MACROS\nAJOMACRV EQU   B'00001000'         (AJOASMFM,AVTAGSM)=> OS/VS ASM\n         SPACE 1\nAJOLIBMC EQU   B'10000000'         (AJOASMFM,AVMTAGSM)=>PRT LIB MACROS\nAJOSUPER EQU   B'00000010'         (AJOEXEF)==> INIT USER IN SUPERVISOR\nAJONALGN EQU   B'00000100'         (AJOEXEF-ECFLAG4)==>NO ALIGNMENT 0C6\n         SPACE 1\nAJIOPEN  EQU   B'00000001'         (AJIO-SO-RE-PR-PN)==> DCB OPEN\nAJIOEOF  EQU   B'00000010'         (AJIO-SO-RE)==> END-FILE ENCOUNTERED\nAJIODEOF EQU   B'00000100'         DISK END-OF-FILE FLAG\nAJIOSYND EQU   B'00010000'         DISK SYNAD ERROR FLAG\nAJIOSOHS EQU   B'00010000'         (AJIOSO)- OUTPUT BUFFER FLUSH      J\nAJIOPSEO EQU   B'00000100'         (AJIO-SO-RE)=> PSEUDO ENDFILE(JCL)\nAJIOPAGE EQU   B'01000000'         (AJIOPR)- PAGE CONTROL MODE ON\nAJIOSORR EQU   B'01000000'         (AJIOSO)- REREAD LAST CARD READ    J\nAJIODKNO EQU   B'10000000'         DISK DCB COULD NOT BE OPENED\nAJIOKP26 EQU   B'10000000'         (AJIOSO) - KP=26 -TRANSLATE TO 029\nAJIOSING EQU   B'10000000'         (AJIOPR)-SINGLE SPACE CARRIAGE CONT\n*                                  EXCEPT  NEW PAGE==> DOUBLESPACE\nAJIODFLT EQU   B'10000000'         (AJIO-RE,PN)==> USING SO OR PR DEFLT\n         SPACE 1\nAJOOBJIN EQU   B'00000001'         (AJODECKF) - OBJECT INPUT DECK\n         SPACE 1\nAJOZEROS DC    16F'0'              FOR USE IN ZEROING THINGS\nAJ1000   DS    F'1000'             FOR CONVERSIONS\nAJ2604   DC    F'2604'             FOR USE IN TIME CONVERSIONS\nAJ100000 DC    F'100000'           FOR USE IN TIME CONVERSIONS\nAJ100M   DC    F'100000000'        FOR USE IN SECS==>TIMER UNITS\nAJOVWXPT DS    V(VWXTABL)          @ MAIN ASSEMBLER TABLE\nAJOEXECU DS    V(EXECUT)           ADCON FOR INTERPRETER CODE\n         DS    0D\n         AIF   (NOT &$KP26).AJNKP26         SKIP IF NO KP=26 OPT ALLWS\nAJTRTB26 DS    XL256               026-->029 KEYPUNCH TRANSLATE TABLE\n.AJNKP26 ANOP\nAJOBLANK DC    CL136' '            FOR GENERAL SUPERVISOR BLANKING\nAJOPARMA DS    C                   FOR CARRIAGE CONTROL\nAJOP$L   EQU   100                 MAXIMUM LENGTH OF PARM FIELD\nAJOPNDFT DS    0CL88               CARD IMAGE HERE IF NOPUNCH USED.\nAJOPARM  DS    CL(AJOP$L+2)        SPACE FOR PARM,2 TRAILING BLANKS\nAJOCP$L  EQU   5                   MAX # CHARACTERS IN EACH PARM\n         DS    0D                  MAKE AJOCOMP PART OF AJODWORK\nAJOCOMP  DS    0CL(AJOCP$L)        SPACE FOR COMPARE DURING PARM SCAN\n         SPACE 1\nAJODWORK DS    D                   GENERAL DOUBLEWORD WORKAREA\nAJOPADL  DS    A                   PERMANENT LOW @ WORKAREA\nAJOPADH  DS    A                   PERMANENT HIGH @ WORKAREA\nAJOTADL  DS    A                   TEMPORARY LOW @ WORKAREA\nAJOTADH  DS    A                   TEMPORARY HIGH @ WORKAREA\nAJOECOPT DS    A                   @ ECONTROL, EXECUTION CONTROL BLK\n         SPACE 1\nAJO$APC  EQU   *                   BASE @ FOR OFFSETS TO PARM VARIABLES\nAJOZER1  EQU   *                   PLACE TO BEGIN ZEROING ON INIT\n         AIF   (&$REPL EQ 0).AJNREPL        SKIP GEN IF NO REPL\nAJORFLAF DS    0F,H                DUMMY RFLAG INTO FULLWORD-MAKES\n*                                  CODE IN APARMS CSECT EASIER\nAJORFLAG DS    H                   REPLACE FLAG FROM RFLAG=\n.AJNREPL ANOP\n         AIF   (NOT &$PAGE).AJNPAGE         SKIP IF NO PAGE CONTROL\nAJOL     DS    F                   LINES/PAGE FROM PARM FIELDS\nAJOP     DS    F                   TOTAL PAGES FROM PARM FIELDS\nAJOPX    DS    F                   PAGES FOR EXECUTION TIME,PARM FIELD\nAJOPD    DS    F                   PAGES FOR DUMP IF RECORDS EXCEEDED\n*              AJOLREM-AJOPREM MUST BE IN ORDER GIVEN TOGETHER\nAJOLREM  DS    F                   LINES REMAINING IN PAGE AT ANY TIME\nAJOPREM  DS    F                   PAGES REMAINING AT ANY TIME\n*              FOLLOWING VARIABLES MAY BE SET WITH AJIOSING FLAG TO\n*              SHOW SINGLE SPACE CRUNCHING DURING NOTED PROG PHASE.\n*              SINGLE SPACE ACTION TAKEN ONLY IF PAGE CONTROL OPT USED\nAJIOSS   DS    B                   SET==> SINGLE SPACE DURING ASSEMBLY\nAJIOSSD  DS    B                   SET==> SINGLE SPACE DURING DUMP\nAJIOSSX  DS    B                   SET==> SINGLE SPACE DURING EXECUT\n.AJNPAGE ANOP\nAJORD    DS    F                   # RECORDS MINIMUM ALLLOWED FOR DUMP\nAJORX    DS    F                   RECORDS FOR EXECUTION TIME\nAJOTD    DS    F                   MINIMUM TIME SAVED FOR DUMP\nAJOTX    DS    F                   TIME(SECS) FOR EECUTION TIME\nAJOTIML  DS    F                   TIME LIMIT FOR JOB, FROM T=\nAJORECNT DS    F                   # RECORDS REMAINING(DECREMENTED)\nAJORECL  DS    F                   RECORD LIMIT, FROM R=\nAJOINSL  DS    F                   # EXECUTED INST LJMIT, FROM I=\nAJONERRF DS    0F,H                DUMMY AJONERR INTO FULLWORD.\n*                                  SIMPLIFIES CODE IN APARMS\n*        **NOTE** SECTION FROM AJONERR - AJOAVL MUST CORRESPOND       *\n*        EXACTLY TO SECTION AVNERR - AVAJL, INC ALIGNMENT.            *\n*        THIS SECTION MOVED TO CORRESPONDING SECTION IN AVWXTABL.     *\nAJONERR  DS    H                   MAXIMUM # ERRORS TO STILL OK EXECUT\n         SPACE 1\n         AIF   (NOT &$MACROS).AJNMACX       SKIP IF NO MACROS\n*              MACRO  OPTIONS AND FLAG BYTES.\nAJOMAC01 DS    0F                  START OF MACRO PARAMETER OPTIONS\nAJOMACTR DS    F                   INITIAL ACTR VALUE FOR MACROS/MAIN\nAJOMNEST DS    F                   MAXIMUM NEST LEVEL FOR MACROS\nAJOMSTMG DS    F                   GLOBAL LIMIT: MACRO STMTS PROCESSED\nAJOASMFM DS    B                   MACRO FLAGS (SETS AVTAGSM)\n.AJNMACX ANOP\nAJOASMF0 DS    B                   ASSEMBLER FLAG **FUTURE USE*********\nAJOASMF  DS    C                   FLAG BYTE FOR ASSEMBLER SECTION\nAJOASMF2 DS    B                   2ND BYTE OF FLAG BITS(FUTR USE)\n         AIF   (NOT &$XREF).NOXREF3                                   A\n*  CROSS REFERENCE FLAG BYTE                                          A\nAJOXREF  DS    C                   FLAG FOR XREF FACILITY             A\n.NOXREF3 ANOP                                                         A\nAJOAVL   EQU   *-AJONERR           LENGTH OF SECTION MOVED TO AVWXTABL\n         SPACE 2\nAJOMODE  DS    B                   MODE FLAG, MISC FLAGS.\nAJOSTEP  DS    B                   FLAG SHOWING CURRENT STEP\n*              EXECUTION CONTROL FLAGS, MUST BE IN GIVEN ORDER. SECTION\n*        AJOEC - AJOECL MUST CORRESPOND WITH ECAJ - ECAJL.            *\nAJOEC    DS    0F                  BEGIN AREA  --  ALIGNMENT\nAJOIECF  DS    F                   IECF=  (ONLY NEEDED FOR &$EXINT=1)\nAJODMPF  DS    B                   DUMP FLAGS (SETS ECFLAG3)\nAJOEXEF  DS    B                   GENRAL EXECUTION MODE FLAGS(ECFLAG4)\nAJOEXEFA DS    B                   EXECUTION FLAGS (ECFLAG5) **FUTURE**\nAJOECL   EQU   *-AJOEC             LENGTH OF FLAG BYTES\n         SPACE 1\nAJOAPMOD DS    B                   FLAG BYTE FOR RUNNING MODE OF APARMS\nAJOAPSET DS    B                   SET BYTE - OR'D BY APARMS WHEN IT\n*              SETS APCFLAG TO SHOW VALUE SET. SEE APCSET,SETLD,SETU\n         SPACE 1\nAJIOFLAG DS    0BL4                AREA OF FLAGS FOR DCB'S\nAJIORE   DS    B                   FLAG BYTE FOR DATA READER(XXXXREAD)\nAJIOSO   DS    B                   FLAG BYTE FOR SOURCE RDR (XXXXSORC)\nAJIOPR   DS    B                   FLAG BYTE FOR PRINTER(XXXXPRNT)\nAJIOPN   DS    B                   FLAG BYTE FOR PUNCH (XXXXPNCH)\nAJIODSK  DS    B                   FLAG BYTE FOR RUNNING MODE DISKU\nAJIOWRKB DS    B                   WORK BYTE FOR USE OF XXXXIOCO\n         SPACE 1\nAJODEBUG DS    B                   DEBUG FLAG BYTE\nAJODECKF DS    B                   OBJECT DECK CONTROL FLAG\nAJOBTRQ  DS    C                   ASSIST SETS FOR XXXXSORC USE       J\nAJOBTYP  DS    C                   XXXXSORC SETS FOR ASSIST           J\nAJOTIMR  DS    F                   TEMPORARY TIME WORK AREA\nAJOFREE  DS    F                   MEMORY TO BE FREED TO OPERATING SYST\nAJOZER$L EQU   *-AJOZER1           LENGTH OF AREA TO BE ZEROED\n         DS    0D\nAJOJCLCD DS    CL80                ASSIST JCL STORED HERE BY READ ROUTN\nAJOJCLPM EQU   AJOJCLCD+15         LOCATION OF $JOB PARM FIELD\n         AIF   (NOT &$ACCT).AJONACC         SKIP IF NO ACCT INFO\n         SPACE 1\n*              ACCOUNT # CHECKING DATA - FROM $TIRC (NAME,AJOACCT)\nAJOACCT  DS    CL5                 ACCOUNT #\nAJOJOBNM DS    CL8                 JOB NAME\nAJOPRGNM DS    CL20                PROGRAMMER'S NAME\n.AJONACC ANOP\nAJOB$L   EQU   *-AJOBCON           GET LENGTH OF AJOBCON\n         TITLE '*** ECONTROL DSECT - EXECUTION CONTROL BLOCK ***'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> DSECT: ECONTROL   EXECUTION CONTROL BLOCK                        *\n*        THIS BLOCK CONTAINS ALL DATA REQUIRED TO DESCRIBE A USER     *\n*        PROGRAM TO BE EXECUTED BY THE ASSIST INTERPRETER (EXECUT).   *\n*        IT CONTAINS SIMULATED USER REGISTERS AND PROGRAM STATUS WORD,*\n*        AN INSTRUCTION STACK, POINTERS TO THE USER PROGRAM CODE,     *\n*        AND VARIOUS FLAGS DESCRIBING THE RUNNING MODE AND OPTIONS    *\n*        ALLOWED TO THE USER PROGRAM.  IT IS CREATED FROM INFORMATION *\n*        FROM THE ASSEMBLER, THE USER PARM FIELD, AND FROM THE        *\n*        OPTIONS IN ASSIST, AND IS MODIFIED BY EXECUT.  IT ALSO       *\n*        PROVIDES ALL DATA NEEDED BY XXXXSNAP TO DO A USER DUMP.      *\n*        LOCATION: IN HIGH END OF DYNAMIC CORE AREA.                  *\n*        NAMES: EC------                                              *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nECONTROL DSECT\nEC$STACK EQU   10                  MAX # OF INSTS KEPT IN STACK\n         SPACE 1\n$ECCONT  EQU   X'80'               (ECFLAG0)==>CONTINUE,DO NOT INIT\n$ECADSOK EQU   X'40'               (ECFLAG0)==>RELOCATION&LIMIT @'S OK\n$ECEOF   EQU   X'20'               (ECFLAG0)==>EOF ON CARD READER\n$ECPROT  EQU   X'10'               (ECFLAG0)==> ABSOLUTE PROTECT MODE\n*              I.E. THIS FLAG MEANS FETCH PROTECT IN ADDITION TO STORE*\n$ECSPIEA EQU   X'08'               (ECFLAG0)==> EXECUT SPIE IN EFFECT\n$ECSPIEB EQU   X'04'               (ECFLAG0)==> REMOVE SPIE BEFORE EXIT\n         SPACE 1\n$ECBROUT EQU   2                   (ECFLAG1)==> BRANCH OUT OF RANGE\n$ECTIMEX EQU   4                   (ECFLAG1)==> TIME COUNT EXCEEDED\n$ECREADR EQU   6                   (ECFLAG1)==> ATTEMPT READ PAST EOF\n$ECRECEX EQU   8                   (ECFLAG1)==> RECORDS EXCEEDED\n$ECABEND EQU   10                  (ECFLAG1)==> USER REQUESTED ABEND\n$ECBRN14 EQU   12                  (ECFLAG1)==> NORMAL RETURN (R14)\n         SPACE 1\n$ECREGS  EQU   B'00000001'         (ECFLAG3)==>PRINT REGS IN DUMP\n$ECDINST EQU   B'00000010'         (ECFLAG3)==>PRINT INST TRACE IN DUMP\n$ECSTORG EQU   B'00000100'         (ECFLAG3)==> PRINT USER STORAGE\n$EC$JRM  EQU   B'10000000'         (ECFLAG3)==> SPECIAL JRM DEBUG\n         SPACE 1\n$ECPRBST EQU   X'01'               (ECKYAMWP) ==> PROBLEM STATE PROG\n         SPACE 1\n*              REPLACE MONITOR FLAGS, SET BY RFLAG= AND XREPL INSTR.\nECR$CARD EQU   B'00000001'         (ECRFLAG+1)PRINT CARDIMAGE\nECR$REGA EQU   B'00000010'         (ECRFLAG+1)PRINT REGS BEFORE ENTRY\nECR$REGB EQU   B'00000100'         (ECRFLAG+1)PRINT RESULTS FROM REAL P\nECR$REGC EQU   B'00001000'         (ECRFLAG+1)PRINT RESULTS OF USER PRG\nECR$REGD EQU   B'00010000'         (ECRFLAG+1) PRT IF USER CALLS\nECR$ERRC EQU   B'10000000'         (ECRFLAG+1)=> ERROR FOUND IN REGS\n         SPACE 1\n*              FLOATING POINT REGISTER SAVE AREA                      *\nECFPREGS DS    4D                  DUMMY FLOATING POINT REGS\nECDWORK  EQU   ECFPREGS            WE CAN USE FP REGS AS WORK AREA\n         SPACE 1\n*              SIMULATED GENERAL PURPOSE REGISTERS                    *\nECREGS   DS    16F                 FAKE REGISTERS FOR INTERPRETER\nECREG1   EQU   ECREGS+4            FAKE R1\nECREGRA  EQU   ECREGS+4*RA         FAKE RA\nECREG12  EQU   ECREGS+48           FAKE R12(RAT)\nECREG13  EQU   ECREGS+52           FAKE R13\nECREG14  EQU   ECREGS+56           FAKE R14, RETURN @ REG\nECREG15  EQU   ECREGS+60           FAKE R15, ENTRY PT REG\n         DS    F                   DUMMY REG, SIMPLIFIES SINGLE SHIFTS\n*              NECESSARY TO USE CURRENT CODE FOR SLL 15,1, FOR EXAMPLE\nECR14SAV DS    A                   ORIGINAL RETURN @ FOR COMPARISON\nECZER1   EQU   *                   BEGINNING FOR BLOCK ZEROING\n         SPACE 1\n*              SIMULATED PROGRAM STATUS WORD                          *\nECPSW    DS    0D                  PSW FOR PROG\nECSYSMSK DS    C                   SYSTEM MASK\nECKYAMWP DS    C                   PROT KEY, AMWP FIELD\nECINTCOD DS    H                   INTERRRUPT CODE\nECILCMSK DS    C                   ILC-CC-PROGRAM MASK\nECPSWIAD DS    CL3                 INSTRUCTION ADDRESS\n         SPACE 1\n*              CONTROL FLAGS                                          *\nECFLAGS  DS    0F                  A FULLWORD FOR FLAGS\nECFLAG0  DS    C                   MAJOR CONTROL BITS\nECFLAG1  DS    C                   USED TO RETURN SPECIAL ERROR CODES\nECFLAG2  DS    C                   CONTROLS DEBUG MODE SNAPS\nECAJ     DS    0F                  BEGIN AJOBCON FLAGS, ALIGN\nECOIECF  DS    F                   ORIGINAL IECF (&$EXINT ONLY)\nECFLAG3  DS    B                   DUMP CONTROL FLAG (AJODMPF)\nECFLAG4  DS    B                   MISC. EXEC FLAGS (AJOEXEC)\nECFLAG5  DS    B                   MISC EXEC FLAGS (AJOEXEFA)*FUTURE***\nECAJL    EQU   *-ECAJ              LENGTH OF FLAGS GROUP MUST = AJECL\nECRFLAG  DS    H                   REPLACE MONITOR FLAG\n         SPACE 1\nECERRAD  DS    A                   @ SPECIAL ASSIST COMPLETION MESSAGE\nECSVCADS DS    A                   @ ADDRESS LIST OF SVC'S,=0 IF NONE\nECZER$L  EQU   *-ECZER1            LENGTH OF AREA FOR BLOCK ZEROING\nECFADHC  DS    A                   HIGH @ PROG + SAVE = ECFADH-256\n*              ECILIMT-ECILIMP MUST BE IN ORDER GIVEN, USED IN LM     *\nECILIMT  DS    F                   INST COUNT LIMIT (DECREMENTED)\nECILIMP  DS    F                   PERMANENT INSTRUCTION COUNT LIMIT\n         SPACE 1\n*              ECRDLIML-ECRDLIMH GIVE DUMP LIMTS. MUST BE IN GIVEN ORDR\nECRDLIML DS    A                   REAL DUMP LIMIT LOW(INIT=ECRADL)\nECRDLIMH DS    A                   REAL DUMP LIMIT HIH(INIT=ECRADH)\n         SPACE 1\n*              ADDRESS VALUES DESCRIBING LIMITS OF USER PROGRAM.      *\n*              **NOTE** THEY MUST BE IN THE ORDER GIVEN BELOW.        *\nECRADL   DS    F                   REAL LOWEST ADDRESS OF PROGRAM\nECRADH   DS    F                   REAL HIGHEST ADDRESS\nECRELOC  DS    F                   RELOCATION CONTINUALLY APPLIED\nECFENTER DS    A                   USER PROGRAM FAKE ENTRY POINT @\nECFADL   DS    F                   FAKE LOWEST ADDRESS OF PROGRAM\nECFADH   DS    F                   FAKE HIGHEST ADDRESS OF PROGRAM\n         SPACE 1\nECINSTAC DS    (EC$STACK)CL16      INSTRUCTION STACK\nECRSTK   DS    F                   SAVE WORD FOR RSTK POINTER\nECSAVE1  DS    A                   @ FAKE SAVE AREA FOR USER PROG\nECPICA   DS    F                   SAVE WORD FOR PREVIOUS PICA\nECTSAVE  DS    16F                 FOR SAVING REGS WHEN DOING CALLS\n         AIF   (NOT &$EXINT).ECOVER\n         SPACE 2\nEC$BRSTC EQU   10                  SIZE OF BRANCH STACK (# OF SLOTS)\nECBRSTAC DS    (EC$BRSTC)CL16      BRANCH STACK\nECBSTK   DS    F                   SAVE WORD FOR BSTK POINTER\nECBCUR   DS    F                   CURRENT STACK PTR SAVED HERE\n         AIF   (&$EXINT EQ 0).ECNOEXT   SKIP IF NO EXTENDED INTERPRETER\n         SPACE 5\n* * * * * * * * * * * * * * ##### EXTENSION ##### * * * * * * * * * * *\n*                                                                     *\n*        IMPORTANT-->  THIS SECTION IS AN EXTENSION TO THE            *\n*        ECONTROL DSECT AND IS USED BY THE OPTIONAL ASSIST            *\n*        INTERPRETER.  IT CONTAINS FLAGS, EQUATES, AND                *\n*        ADDRESSES FOR USER INTERRUPT HANDLING AND OTHER              *\n*        USER OPTIONS.  SEE PSEUDO-INSTRUCTION XOPC.                  *\n*                                                                     *\n*        NOTE:  DATA IN THIS AREA IS ACCESSABLE TO THE USER           *\n*        PROGRAMMER BY MEANS OF VARIOUS XOPC INSTRUCTION              *\n*        CODES, AND IN GENERAL BY XOPC 12 & 13.                       *\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 2\nECPRCB   EQU   *\n*              FLAGS USED BY THE OPTIONAL INTERPRETER\n*\n*              FLAGS FOR OPTIONS-IN-EFFECT CHECKING\n*              NOTE: ECPRCBF1 WILL NOT BE USED FOR ANY OTHER\n*                    FLAG TYPES.\nECPRTRCE EQU   B'00000001'         (ECPRFLG1)==> TRACE = ON\nECPRMODC EQU   B'00001000'         (ECPRFLG1)==> MODIFICATION CHECKING X\n                                                 = ON\nECPRIECF EQU   B'00000010'         (ECPRFLG1)==> COUNT FACILITY ON\nECPRCTON EQU   B'00000100'         (ECPRFLG1)==> HAS COUNT ON BEFORE?\nECPRCTOF EQU   B'00000000'         (ECPRFLG1)==> COUNT FACILITY OFF\nECPRNOSP EQU   B'00001000'         (ECPRFLG1)==> NO SPACE FOR COUNT FAC\n*\n*              FLAGS FOR MACHINE EMULATION (ECPRCBF2 LOW ORDER NIBBLE)\n*              AND OTHER DATA.\n*\n*              NOTE: THE FLAGS FOR MACHINE EMULATION CAN BE CHANGED\n*              DYNAMICALLY BY THE USER PROGRAMMER BY WAY OF THE XOPC\n*              INSTRUCTION.  THIS ALLOWS RUN-TIME CONTROL OF EMULATION\n*              OPTIONS, SINCE THESE FLAGS ARE CHECKED BEFORE THE\n*              INTERPRETATION OF EACH USER INSTRUCTION.  IF THE USER\n*              PROGRAM SCREWS UP THESE FLAGS, IT MAY BE\n*              TERMINATED 'CONFUSINGLY' WITH AN OC-1 ON A VALID\n*              INSTRUCTION.\nECEM360  EQU   B'00000100'         (ECPRFLG2)==>  MACHINE = 360\nECEM370  EQU   B'00001000'         (ECPRFLG2)==>  MACHINE = 370\nECSUPRST EQU   B'01000000'         (ECPRFLG2)==> IN SUPERVISOR STATE\nECALNCHK EQU   B'10000000'         (ECPRFLG2)==> ALIGNMENT CHECKING=ON\nECSPISET EQU   B'10000000'         (ECPRFLG3)==> A PSEUDO SPIE IS SET\nECINHDST EQU   B'01000000'         (ECPRFLG3)==> INTERRUPT HANDLING ST\nECNOSPI  EQU   B'00000000'         (ECPRFLG3)==> NO SPIE INTERRUPT SET\nECLKADR  EQU   B'00000001'         (ECPRFLG4)==> CLOCK EXIT ADDR SET\n*              PRCB STORAGE BEGINS HERE\nECPRFLG1 DS    B\nECPRFLG2 DS    B\nECPRFLG3 DS    B\nECPRFLG4 DS    B\nECPRFLG5 DS    B\nECPRFLG6 DS    B\nECPRFLG7 DS    B\nECPRFLG8 DS    B\n*              INSTRUCTION TRACE AND MONITOR ADDRESSES\n*              ***** NOTE: DO NOT CHANGE THE ORDER OF THESE SOURCE\n*                          RECORDS\nECPRTRAL DS    A                   BEGINNING (LOW) @ OF TRACE         M\nECPRTRAH DS    A                   ENDING (HIGH) @ OF TRACE           M\nECPRMODL DS    A                   BEGINNING (LOW) @ OF CHECK FACILITY\nECPRMODH DS    A                   ENDING (HIGH) @ OF CHECK FACILITY\n*              INSTRUCTION COUNTER (PSEUDO-CLOCK) INFORMATION\nECPRCLOK DS    F                   CLOCK (DECMTD BY 1 FOR EACH INSTR)\nECPRCMPR DS    F                   COMPARATOR (CHECKED AGAINST CLOCK   X\n                                   FOR INTERRUPT TEST)\nECPRCLEA DS    A                   USER SPECIFIED CLOCK EXIT ADDRESS\n*              EXIT ADDRESS FOR USER SPECIFIED PSUEDO-SPIE HANDLING\n*              (IF NOT SPECIFIED, THIS ADDRESS WILL BE ZERO.)\nECPRSCDE DS    F                   USER SPECIFIED SPIE CODE MASK\nECPRSPIE DS    A                   EXIT ADDRESS FOR PSUEDO-SPIE XOPC 0\n*              2 WORD SAVE AREA FOR INTERRUPT (REGS 0 - 1)\nECPRIRGS DS    2F                  DEFINE 2 WORD SAVE AREA\n*              STORAGE FOR IECF (BY ADDRESS) INFORMATION\nECPRICA  DS    A                   BEGIN @ OF IECF (BY ADDR) COUNTERS\nECPRICAL DS    F                   LENGTH OF COUNTING AREA\nECPRICL  DS    A                   IECF LOW @ COMPARATOR (BEGINNING)  M\nECPRICH  DS    A                   IECF HIGH @ COMPARATOR (ENDING)    M\n*              MISCELLANEOUS EQUATES FOR THE OPTIONAL INTERPRETER\nEISSINST EQU   B'11000000'         IDENTIFIES SS INSTRUCTIONS\nECPROPON EQU   ECPRTRCE+ECPRIECF\nEC#XOPC  EQU   22                  # OF THE MAX LEGAL XOPC CODE\nECREG0   EQU   ECREGS              FAKE REG 0\nECREG2   EQU   ECREGS+8            FAKE REG 2\n         SPACE 1\nECPRWORK DS    8F                  WORK AREA FOR FUTURE GENERAL USE\n         SPACE 1\nECPRCB$L EQU   *-ECPRCB            LENGTH OF PRCB\n.ECNOEXT  ANOP\n.ECOVER  ANOP\n         DS    0D\nEC$LEN   EQU   *-ECONTROL          LENGTH OF ECONTROL DSECT\n         TITLE '*** ECSTACKD DSECT - ECONTROL INSTRUCTION STACK ***'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> DSECT: ECSTACKD   SINGLE ENTRY IN ECONTROL INSTRUCTION STACK     *\n*        THE ECONTROL INSTRUCTION STACK IS A CIRCULAR LINKED LIST     *\n*        WHICH ALWAYS CONTAINS DATA ON UP TO THE LAST 10 INSTRUCTIONS *\n*        INTERPRETED DURING EXECUTION.  IT IS FILLED IN BY EXECUT, AND*\n*        IS USED BY XXXXSNAP TO PROVIDE THE INSTRUCTION TRACE PART    *\n*        OF A USER COMPLETION DUMP.                                   *\n*        LOCATION: INSIDE AREA ECINSTAC IN DSECT ECONTROL.            *\n*        NAMES: EC------     (SAME AS ECONTROL NAME CHARACTERS)       *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nECSTACKD DSECT\nECSTENT  DS    0CL16               INST STACK ENTRY\nECSTLINK DS    F                   ADDRESS OF NEXT STACK ENTRY\nECSTIADD DS    F                   INSTRUCTION ADDRESS\nECSTCCPM DS    H                   CON-CODE & PROGRAM MASK\n         SPACE 1\nECSTINST DS    0CL6                UP TO 6 BYTES OF INSTRUCTION\nECOP     DS    C                   OPCODE\nECM1R2   DS    0C                  M1,R2 FIELD FOR BC'S\nECR1R2   DS    0C                  R1,R2 FIELD FOR RR INSTRUCTIONS\nECR1X2   DS    0C                  FIELD FOR RX INSTRUCTIONS\nECR1R3   DS    0C                  FIELD FOR RS INSTRUCTIONS\nECR1M3   DS    0C                  FIELD FOR RS INSTRUCTIONS\nECI2     DS    0C                  FIELD FOR SI INSTRUCTIONS\nECL1I3   DS    0C                  FIELD FOR SRP INSTRUCTION\nECOPEX   DS    0C                  2ND BYTE OF EXTENDED OP CODE\nECL1L2   DS    C                   FIELD FOR ALL SS INSTRUCTIONS\nECBD     DS    H                   1ST OR ONLY BASE-DISPLACEMENT FIELD\nECB2D2   DS    H                   2ND BASE-DISP(SS & SPECIALS ONLY)\n         TITLE '*** ASSIST - MAIN CONTROL - OVERALL ***'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> CSECT: ASSIST     MONITOR CONTROL PROGRAM FOR THE ASSIST SYSTEM  *\n*        ENTRY CONDITIONS                                             *\n*   R1= @ POINTER TO OS LENGTH/PARM FIELD AREA.                       *\n*        CALLS AOBJIN,AODECK,APARMS,EXECUT,MPCON0,REENDA,REINTA       *\n*        CALLS XXXXFINI,XXXXINIT                                      *\n*        USES DSECTS: AJOBCON,AVWXTABL,ECONTROL                       *\n*        USES MACROS: $DBG,$PRNT,$RETURN,$SAVE,$SORC,$TIRC            *\n*        USES MACROS: ASPAGE,ASPRNT,ASRECL,ASTIME,ASTIMR              *\n*        USES MACROS: FREEMAIN,GETMAIN,STIMER,TTIMER,XCALL,XSNAP,WTL  *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nASSIST   CSECT\n* * * * * * * * REGISTER USAGE IN ASSIST MAIN PROGRAM * * * * * * * * *\n*   R0,R1,R15  USUALLY LOCAL WORK REGISTERS. PARAMETER REGS FOR SOME. *\n*   R9 = INTERNAL LINK REGISTER FOR TIME/RECORDS/PAGES CONTROL .      *\n*   R10= ADDRESS OF EXECUTION CONTROL BLOCK ECONTROL (PART OF TIME).  *\n*   R11= ADDRESS OF JOB CONTROL TABLE AJOBCON(ALWAYS).                *\n*   R12= ADDRESS OF ASSEMBLER CONTROL TABLE AVWXTABL(PART OF TIME).   *\n*   R13= SAVE AREA PTR AND BASE REGISTER ALSO.                        *\n*   R14= EXTERNAL LINK REGISTER.  INTERNAL LINK REGISTER FOR LOWEST   *\n*              LEVEL INTERNAL SUBROUTINES.                            *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         $DBG  ,NO                 NO DEBUG,SINCE NO AVWXTABL\n         AIF   (&$ASMLVL).ASXSAVE  SKIP FOR OS $SAVE\n         BALR  R15,0               SET UP TEMPORARY ADDRESSABILITY(DOS)\n         USING *,R15               INFORM ASSEMBLER OF R15 USING\n         CNOP  0,4                 FULLWORD ALIGNMENT FOR FUTURE SAVE\n         BAL   R13,ASSAVE+72       BR AROUND SAVE,SET R13 = @ SAVEAREA\n         USING *,R13               SHOW R13 AS ASSIST BASE REGISTER\n         DROP  R15                 KILL USING\nASSAVE   DC    18F'0'              SAVEAREA FOR CSECT ASSIST\n.ASXSAVE AIF   (NOT &$ASMLVL).ASNXSAV  SKIP IF UNDER DOS GENERATION\n         $SAVE RGS=(R14-R12),BR=R13,SA=ASSAVE\n.ASNXSAV ANOP\n         MVC   ASPARMSV,0(R1)      MOVE @ LENGTH/PARM FIELD OVER\n         ASTIMR 00,2               INITIALIZE TIMER IF &$TIMER=2\n         XCALL XXXXSPIN            INITIALIZE PROGRAM INTERRUPT CODE\n         LA    R11,ASJOBCON        GET @ FOR AJOBCON\n         USING AJOBCON,R11         NOTE MAIN TABLE USING\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*              INITIALIZE AJOBCON.  CALL XXXXINIT TO INITIALIZE       *\n*        INPUT/OUTPUT PROCESSORS.  (I.E. DO OPENS, SET FLAGS.  )      *\n*        MAKE SURE BOTH LINE PRINTER (PR) AND SOURCE CARD READER (SO) *\n*        OPENED SUCCESSFULLY.  QUIT IMMEDIATELY IF THEY DIDN'T.       *\n*        CALL APARMS TO ANALYZE PARM FIELD IF ANY,SET FLAGS IN AJOBCON*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nASJINIT  EQU   *                   SECTION TO INIT AJOBCON\n         XC    AJOZER1(AJOZER$L),AJOZER1    ZERO OUT WHOLE SECTION\n         SPACE 1\nASJOBINT EQU   *                    ENTRY FOR BEGINNING OF NEW $JOB\n*              CALL PARM FIELD ANALYSIS ROUTINE TO SET FLAGS.         *\nASJPARMS EQU   *\n*              ***** LIMIT PARMS & RESETABLE DEFAULTS *****\n         LA    R9,ASPARLIM         SHOW @ PARM FIELD\n         LA    R10,ASPARL$L        SHOW LENGTH OF PARM FIELD\n         MVI   AJOAPMOD,AJOAPRSE   SHOW THIS IS RESET CALL\n         MVI   AJOAPSET,APCSETLD   SHOW LIMIT/DEFAULT CALL TYPE\n         XCALL APARMS              CALL PARM FIELD SCANNER\n         AIF   (NOT &$ASMLVL).ASPARMC  NO // EXEC PARM FIELD\n         SPACE 1\n*              ***** REAL PARM FIELD ANALYSIS *****\n         L     R9,ASPARMSV         GET PTR TO LENGTH-PARM FOR APARMS\n         LH    R10,0(R9)           GET LENGTH OF THE REAL PARM\n         LA    R9,2(R9)            GET @ ACTUAL PARM FIELD\n         MVI   AJOAPMOD,AJOAPMOV   SHOW PARM SHOULD BE MOVED OVER\n         MVI   AJOAPSET,APCSETP    SHOW THIS IS THE REAL PARM FIELD NOW\n         XCALL APARMS              CALL SCANNER PROGRAM\n.ASPARMC ANOP\n         SPACE 1\n         TM    AJOSTEP,AJOMSINT    HAVE GONE THRU 1-TIME INIT ALREADY\n         BO    ASNOT1T             YES, SO DON'T DO IT AGAIN.\n         SPACE 1\n*              ***** ONE-TIME-PER-BATCH INITIALIZATION *****\n         BAL   R14,ASMSINIT        MAIN STORAGE INITIALIZATION\n         TM    AJOMODE,AJNSYSIN    WAS NOSYSIN SPECIFIED\n         BO    ASZERR2             NOSYSIN, SO QUIT NOW. NO SOURCE CRDS\n         SPACE 1\n*              HAVE DCB'S OPEND FOR PRINTER, SOURCE RDR. CHECK FOR OK.\n         XCALL XXXXINIT            CALL I/O INITIALIZER\n         TM    AJIOPR,AJIOPEN      DID PRINTER OPEN RIGHT\n         BZ    ASZERR1             NO,GO DO MESSAGE AND QUIT\n         TM    AJIOSO,AJIOPEN      DID SOURCE CARD RDR OPEN RIGHT\n         BZ    ASZERR2             NO, BRANCH AND QUIT IMMEDIATELY\nASNOT1T  EQU   *                   ENTER FOR EVERY-TIME PROCESSING\n         TM    AJOMODE,AJOBATCH    WAS THIS BATCH RUN\n         BZ    ASPARFIN            NO, SKIP TO PUT IN FINAL DEFAULTS\n         AIF   (NOT &$DATARD).ASNRDX   SKIP IF NO DATA RDR EXISTS\n         OI    AJIORE,AJIODFLT     SINCE BATCH, MAKE SURE  NO DATA RDR\n.ASNRDX  ANOP\n         SPACE 1\n*              ***** BATCH MODE - GET $JOB CARD AND ITS PARMS *****\n         AIF   (NOT &$MACSLB).ASSNOMC\n         XCALL XXXXLBED         MAKE SURE THAT XXXXSORC GETS CARD RIGHT\n.ASSNOMC ANOP\n         MVI   AJOBTRQ,AJO$J       SHOW THAT $JOB CARD IS DESIRED     J\n         BAL   R14,ASFLUSH         GO GET IT; RETURN ONLY IF FOUND    J\n*              ***** $JOB CARD OR EQUIV FOUND. PROCESS PARM.\n         MVI   AJOAPMOD,AJOAPMOV   SHOW PARM SHOULD BE MOVED OVER\n         MVI   AJOAPSET,APCSETU    SHOW USER SETTING THIS TIME\n         LA    R9,AJOJCLPM         SHOW @ PARM FIELD ON $JOB CARD\n         LA    R10,80-(AJOJCLPM-AJOJCLCD)   LENGTH OF PARM FIELD(MAX)\n         XCALL APARMS              CALL PARM ANALYSIS ROUTINE\n         MVC   AJOPARM(80),AJOJCLCD         MOVE WHOLE JCL CARD IN INST\n         SPACE 1\n*              ***** DEFAULT PARM FIELDS - DON'T OVERRRIDE SET *****\nASPARFIN EQU   *                   SKIP HERE IF NOBATCH\n         MVI   AJOAPMOD,AJOAPDEF+AJOAPFIN   DEFAULT CALL, ALSO LAST 1\n         MVI   AJOAPSET,APCSETLD   SHOW LIMIT/DEFAULT TYPE SETTING\n         LA    R9,ASPARDF          SHOW DEFAULT PARMS\n         LA    R10,ASPARD$L        SHOW LENGTH OF DEFAULT PARM LIST\n         XCALL APARMS              MAKE FINAL CALL TO PARM ROUTINE\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*              TIME,RECORDS,PAGES INITIALIZATION FOR ASSEMBLY.        *\n*              PRINT ASSIST HEADER + 1 PARM FIELD.                    *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n         ASRECL 04                 CALL RECORD INIT CODE\n         ASPAGE 04                 CALL PAGE HANDLING, IF EXISTS\n         ASTIMR  04,1              SET UP TIME/INST COUNT LIMITS\n         SPACE 1\n*              PRINT HEADER.  PRINT REAL PARM OR $JOB PARM AREA\nASPRHEAD EQU   *                   ENTRY FOR MULTIPLE ASSEMBLYS/EXEC\n         ASPRNT ASH1HD,ASH1H$L     PRINT BEGINNING HEADER\n         ASPRNT AJOPARMA,AJOP$L+1  PRINT THE PARM FIELD\n         AIF   (&$DEBUG).ASDA      SKIP IF PRODUCTION\n         XSNAP LABEL='AFTER TIME/RECORDS SET',IF=(AJODEBUG,O,8,TM),    X\n               STORAGE=(*AJOPARMA,*AJOBCON+AJOB$L)\n.ASDA    ANOP\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*              SET UP ADDRESSES FOR CALL TO THE ASSIST ASSEMBLER.     *\n*        ALSO SET UP TIME,SO CAN DO TIMING FOR THE ASSEMBLER          *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nASASMCL  EQU   *                   SECTION TO CALL ASSEMBLER\n         MVC   AJOTADL(8),AJOPADL  REINITIALIZE TEMP TO PERMANENTS\n         SPACE 1\nASASMCLR EQU   *                   ENTRY LABEL FOR REPLACE PHAS B\n         L     RAT,AJOVWXPT        INIT ADCON FOR ASSEMBLER TABLE\n         USING AVWXTABL,RAT        NOTR POINTER IN R12\n         ST    R11,AVAJOBPT        INIT POINTER TO AJOBCON.\n         MVC   AVADDLOW(8),AJOTADL MOVE CURRENT CORE LIMITS OVER\n         MVC   AVNERR(AJOAVL),AJONERR       GIVE FLAGS TO ASSEMBLER\n         AIF   (NOT &$OBJIN).ASNOBJ1        SKIP IF NO OBJECT DECK IN\n         SPACE 1\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*              OBJECT DECK INPUT CODE                                 *\n*        IF PARM=OBJIN, CALL AOBJIN TO LOAD DECK, SKIPPING EXECUTION  *\n*        IF THERE IS NOT ENOUGH ROOM FOR IT.  AOBJIN SETS UP VALUES   *\n*        IN AVWXTABL JUST AS THOUGH THERE HAD BEEN AN ASSEMBLY.       *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         TM    AJODECKF,AJOOBJIN   WAS THERE OBJECT DECK,INSTD OF SOURC\n         BZ    ASOBJINN            NO, NO OBJECT DECK-SKIP TO ASSEMBLE\n         AIF   (&$REPL EQ 0).ASNRPX    SKIP IF NO REPLACEMENT\n         TM    AJOMODE,AJOREPLF    REPLACE RUN\n         BO    ASOBJINN            YES, SO DON'T LET HIM READ DECK IN\n.ASNRPX  ANOP\n         XCALL AOBJIN              CALL OBJECT INPUT ROUTINE\n         TM    AVTAGS1,AJNLOAD     NOLOAD SET IF SOMETHING WRONG\n         BO    ASNOEXEC            BAD DECK - SKIP EXECUTION\n         B     ASOBJINX            OK, SKIP OVER ASSEMBLY AND CONTINUE\nASOBJINN EQU   *                   SKIP HERE IF NO OBJECT INPUT\n.ASNOBJ1 ANOP\n         AIF   (&$REPL EQ 0).ASNREP1        SKIP IF NO REPLACEMENT\n*              IF REPLACEMENT POSSIBLE, CALL REINTA TO SET FLAGS,ADCONS\n         XCALL REINTA              CALL REPLACE PRE-ASSEMBLY INIT\n.ASNREP1 SPACE 1\n         SPACE 1\n*              FLAG ASSEMBLY, CALL ASSEMBLER, UNFLAG ASSEMBLY.\n         OI    AJOSTEP,AJOSASM     SHOW WE'RE IN ASSEMBLER NOW\n         XCALL MPCON0              CALL THE ASSEMBLER\n         NI    AJOSTEP,255-AJOSASM SHOW WE FINISHED ASSEMBLER\n         SPACE 1\n         ASTIMR 12,1               CALL FOR ASSEMBLY TIME,RATE PRINTING\n         SPACE 1\n         AIF   (&$REPL EQ 0).ASNREP2        SKIP IF NO REPLACEMENT\n*              IF REPLACEMENT POSSIBLE, CALL REENDA TO CHANGE ADCONS\n         XCALL REENDA              POST-ASSEMBLY PROCESSOR\n.ASNREP2 SPACE 1\n         TM    AVTAGS1,AJNLOAD     WAS NO LOAD FLAG SET\n         BO    ASNOEXEC            EITHER USER DIDN'T WANT, OR ERRS\nASOBJINX EQU   *                   EXIT HERE IF OBJECT INPUT\n         AIF   (NOT &$DECK).ASNDECK         SKIP IF NO DECKS PUNCHED\n         SPACE 1\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*              OBJECT DECK PUNCH CODE                                 *\n*        IF PARM=DECK, PUNCH THE CURRENT USER PROGRAM OUT, AS LONG    *\n*        AS IT WASN'T ONE JUST READ IN FOR PARM=OBJIN.                *\n*        ALSO, DON'T PUNCH IF IN REPLACE RUN.                         *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         TM    AJOASMF2,AJODECK    DID USER WANT AN OBJECT DECK\n         BZ    ASDECKN             NO, SKIP\n         TM    AJODECKF,AJOOBJIN   DID HE JUST READ IT IN\n         BO    ASDECKN             YES, IDIOT USER-DON'T PUNCH IT\n         AIF   (&$REPL EQ 0).ASNREDK        SKIP IF NO REPLACEMENT\n         TM    AJOMODE,AJOREPLF    ARE WE IN REPLACE RUN\n         BO    ASDECKN             YES, DON'T ALLOW DECK PUNCHED\n.ASNREDK ANOP\n         XCALL AODECK              CALL TO PUNCH OBJECT DECK\nASDECKN  EQU   *                   SKIP LABEL OVER OBJECT DECK PUNCH\n.ASNDECK ANOP\n         SPACE 2\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*              PRE-EXECUTION CONTROL CARD CHECKING                    *\n*        IF IN BATCH MODE, FLUSH CARDS UNTIL A $ENTRY CARD FOUND,     *\n*        AND POSSIBLY ALLOW EXECUTION, OR A $JOB CARD FOUND, IN       *\n*        WHICH CASE GO BACK FOR NEXT JOB.  $STOP CARD FOUND WILL NOT  *\n*        RETURN HERE ANYWAY.    NOTE THAT EXECUTION IN BATCH MODE     *\n*        CURRENTLY REQUIRES A $ENTRY CARD.                            *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n         TM    AJOMODE,AJOBATCH    ARE WE IN MIDDLE OF BATCH RUN\n         BZ    ASEXNBAT            NO, NO BATCH, DON'T READ ANY CARDS\n         SPACE 1\n         AIF   ('&$BTCC(3)' EQ '').ASBTCC1  SKIP IF NO $ENTRY NEEDED  J\n         MVI   AJOBTRQ,AJO$E       SHOW THAT $ENTRY IS WHAT WE WANT   J\n         BAL   R14,ASFLUSH         GO GET; IF RETURN, IT EXISTS       J\n         CLI   AJOBTYP,AJO$E       WAS IT ACTUALLY $ENTRY             J\n         BE    ASEXNBAT            YES, CONTINUE                      J\n         OI    AJIOSO,AJIOSORR     $JOB- SET FOR REREAD, FINISH JOB   J\n         B     ASNOEXEC            GO TO END THIS JOB, PICK UP $JOB   J\n.ASBTCC1 ANOP\nASEXNBAT EQU   *\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*              PREPARE ADDRESSES AND ECONTROL BLOCK FOR EXECUTION     *\n*        OF USER PROGRAM BY EXECUT.  SET UP ECONTROL APPROPRIATELY.   *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nASEXECAL EQU   *\n         LM    R0,R5,AVRADL        GET THE 6 @ WORDS FROM AVWXTABL\n         LA    R10,AVECONTR        OVERLAP ECONTROL&UNNEEDED AV SECT\n         DROP  RAT                 REMOVE USING FOR TIME BEING\n         AIF   (&$REPL EQ 0).ASNRP1E        SKIP IF NO REPLACE\n         SPACE 1\n*              IF IN REPLACE MODE A, THE ECONTROL BLOCK CANNOT BE\n*              LOCATED IN MIDDLE OF AVWXTABL, SO ALLOCATE SPACE FOR\n*              IT AT HIGH END OF DYNAMIC AREA INSTEAD.\n         TM    AJOMODE,AJOREPLF+AJOREPHB    ARE WE IN REPL, OR PHASE B\n         BNM   ASREPLBM            BRANCH-NOT PHASE A IN ANY CASE\n         SPACE 1\n         L     R10,AJOTADH         GET CURRENT HIGH POINTER\n         SH    R10,=AL2(EC$LEN)    SPACE FOR ECONTROL\n         ST    R10,AJOTADH         SAVE BACK, ALSO LEAVE IN R10\nASREPLBM EQU   *                   BRANCH HERE IF NOT REPL PHASE A\n.ASNRP1E SPACE 1\n         USING ECONTROL,R10        NOTE EXECUTION TIME USING\n         XC    ECZER1(ECZER$L),ECZER1       ZERO OUT AREA IN ECONTROL\n         LR    R1,R5               MOVE HIGHEST FAKE @ OVER\n         SR    R1,R4               GET LENGTH OF PROGRAM\n         AR    R1,R0               GET UPPER @ LIMIT FOR PROGRAM\n         LR    R6,R1               SAVE ENDING @ OF PROGRAM\n         LA    R1,72+256(R1)       INCREMENT ENDING @,SAVAR+BUFFER\n         C     R1,AJOTADH          IS THERE ENOUGH ROOM FOR SAVA,BUFFR\n         BH    ASEXOVSP            NO,BRANCH OUT, ABORT EXECUTION\n         SPACE 1\n         MVI   0(R6),$PRGFILC      PUT IN FILL CORE CHARACTER\n         MVC   1(71,R6),0(R6)      PROPAGATE FILL THRU 1ST SAVE AREA\n         MVC   72(256,R6),64(R6)   FILL DUMMY 256 BYTES ALSO\n         XC    4(4,R6),4(R6)       ZERO INITIAL BACKWARDS SA PTR (HSA)\n         STM   R0,R5,ECRADL        SAVE ALL THE @ POINTERS IN ECONTROL\n         STM   R0,R1,ECRDLIML      STORE ECRADL-ECRADH==> ECRDLIML-H\n         SPACE 1\n         ST    R1,AJOTADL          STORE BACK UPDATED LOWER LIMIT\n         ST    R6,ECSAVE1          SAVE @ DUMMY SAVE AREA,FOR DUMPS\n         SPACE 1\n         S     R6,ECRELOC          SUBTRACT THE RELOCATION FACTOR\n         L     R7,=F'-100000'      SET UP FOR WEIRD RETURN @\n         LR    R8,R3               MOVE TO STORE IN FAKE R15- EPA\n         STM   R6,R8,ECREG13       STORE FAKE R13-R14-R15 INTO FAKE RGS\n         MVI   ECREGS,$PRGFILR     PUT FILL REGISTER CHAR INTO 1ST BYTE\n         MVC   ECREGS+1(51),ECREGS PROPAGATE 4'S THROUGH REGS 0-12\n         MVC   ECFPREGS(32),ECREGS PUT 4'S IN FP REGS ALSO\n         MVC   ECILIMP,AJOINSL     MOVE INSTRUCTION LIMIT OVER\n         MVC   ECAJ(ECAJL),AJOEC   MOVE EXECUTION FLAGS OVER\n         MVI   ECSYSMSK,X'FF'      SET CHANNEL MASKS TO INTERRUPT CEH\n         MVI   ECKYAMWP,X'C5'      SET KEY-C, AMWP=0101           CEH\n         SPACE 1\n         OI    ECFLAG0,$ECSPIEB    NOTE WE WANT SPIE REMOVED AT END\n*              IF 'RELOC' OPTION USED, ALLOW STORE-ONLY PROTECT\n         AIF   (NOT &$RELOC).ASNRELC        SKIP IF NO RELOC MODE AVAIL\n         TM    AJOASMF,AJORELOC    DID USER ASK FOR RELOC MODE\n         BO    *+8                 YES, SKIP, DON'T SET FETCH PROTECT\n.ASNRELC ANOP\n         OI    ECFLAG0,$ECPROT     SHOW BOTH FETCH/STORE PROTECT\n         SPACE 1\n         XCALL XXXXSNIN            HAVE XXXXSNAP INIT CALL #\n         ST    R10,AJOECOPT        SAVE @ ECONTROL, IN CASE TIMER\n         AIF   (&$DEBUG).ASXS1     SKIP XSNAP IF NOT DEBUG MODE\n         XSNAP LABEL='ECONTROL BEFORE EXECUT',IF=(AJODEBUG,O,2,TM),    #\n               STORAGE=(*ECONTROL,*ECONTROL+EC$LEN)\n         LM    R14,R15,ECRADL      GET STORAGE LIMITS\n         XSNAP T=(NO,,1),LABEL='USER STORAGE BEFORE EXEC(FAKE ADDR)',  #\n               STORAGE=(*0(R14),*0(R15)),IF=(AJODEBUG,O,4,TM)\n.ASXS1   ANOP\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*        EXECUTION CONTROL BLOCK PREPARATION COMPLETED.  MAKE SURE    *\n*        THAT TIME OR RECORDS LIMITS HAVE NOT BEEN OVERRUN ALREADY.   *\n*        IF NOT, THEN PRINT HEADER, SET TIMER, AND EXECUTE PROGRAM.   *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n         TM    AJOMODE,AJOSOVRT+AJOSRECX    HAS ANY OVERRUN OCCURRED\n         BNZ   ASNOEXEC            SKIP IF OVERRUN ALREADY. DON'T EXEC\n         AIF   (&$REPL EQ 0).ASNREP3        SKIP IF NO REPLACEMENT\n         TM    AJOMODE,AJOREPLF+AJOREPHB     TEST REPLACE STATUS\n         BNM   ASREPLBZ            BR-EITHER NO REPLACE(Z) OR PHS B(O)\n         OI    AJOMODE,AJOREPHB    WAS IN PHASE A, SET NOW TO B\n         MVC   ECRFLAG,AJORFLAG    INITIALIZE THE FLAG VALUE\n         ASPAGE 14                 GET PAGE CONTROL SET\n         ASRECL 14                 GET RECORDS SET (LIKE EXEC)\n         ASTIMR 14,1               SET TIMER, AS FOR NORMAL EXEC.\n         B     ASASMCLR            RETURN TO RUN A REPLACED CSECT\nASREPLBZ EQU   *                   EXIT LABEL- NO REPLACE, PHASE B\n.ASNREP3 SPACE 2\n         ASPRNT ASHEXGO,L'ASHEXGO  PRINT PRE-EXECUTION HEADING\n         SPACE 1\n         ASPAGE 16                 SET PAGE LIMITS FOR EXECUTION\n         ASRECL 16                 SET UP RECORD LIMITS FOR EXECUTION\n         SPACE 1\n*              FLAG EXECUTION, CALL EXECUT, UNFLAG EXECUTION.\n         OI    AJOSTEP,AJOSEXEC    FLAG TO SHOW WE'RE IN INTERPRETER\n         ASTIMR 16,1               SET TIMER, AFTER SHOWN IN EXEC PHASE\n         XCALL EXECUT              CALL THE INTERPRETER\n         NI    AJOSTEP,255-AJOSEXEC         SHOW FINISHED EXECUTION\n         SPACE 1                                                      J\n*              POST-EXECUTION PHASE - USE ALL DUMP LIMITS IN ORDER TO J\n*              PREVENT UNNECESSARY LOSS OF MESSAGES.                  J\n         OI    AJOSTEP,AJOSDUMP    SHOW NOW IN DUMP STEP              J\n         ASRECL 20                 RECORD LIMIT; CLEAR AJOSRECX FLAG  J\n         ASPAGE 20                 PAGE LIMIT, IF USED                J\n         ASTIMR 18,0               PRINT INSTRUCTION COUNT/RATE\n         ASTIMR 20,1               RESET TIMER FOR DUMP PROCESSING    J\n*              IF 1 OR MORE DATA CARDS WAS NOT READ DURING EXECUTION, J\n*              READ IT AND PRINT WITH MESSAGE TO THAT EFFECT.         J\n         AIF   (NOT &$DATARD).ASNDRZZ  SKIP IF NO DATA RDR            J\n         TM    AJIORE,AJIOPEN+AJIODFLT  WAS RDR OPEN, OR DEFAULT USED J\n         BNZ   ASCARDRR            YES, SAFE TO DO $READ NOW          J\n         MVC   AJOPARM(80+L'ASCARDMS),AJOBLANK   BLANK OUT WHOLE AREA J\n         MVC   AJOPARM+L'ASCARDMS(27),=C'NO CARDS READ:FILE UNOPENED' J\n         B     ASCARDMM\n.ASNDRZZ ANOP\nASCARDRR $READ AJOPARM+L'ASCARDMS,80,ASNOMORC    READ, SKIP IF EOF    J\nASCARDMM MVC   AJOPARM(L'ASCARDMS),ASCARDMS  COPY MESSAGE OVER        J\n         ASPRNT AJOPARMA,81+L'ASCARDMS  PRINT THE ASSEMBLED LINE      J\n*              NOTE: ABOVE MESSAGE MAY OVERLAP INTO AJODWORK.  BUT OK.J\nASNOMORC EQU   *                   COME HERE IF NO CARDS UNREAD       J\n         SPACE 2\n*              DETERMINE WHETHER PROGRAM ENDED WITH A NORMAL RETURN OR*\n*        AN ERROR. PRINT NORMAL MESSAGE IF IT WAS FLAGGED AS NORMAL.  *\n         CLI   ECFLAG1,$ECBRN14    WAS RETURN NORMAL\n         BNE   ASDUMPCL            NO, SO CALL DUMP ROUTINE\n         ASPRNT ASNORMAL,L'ASNORMAL    PRINT NORMAL COMPLETION BY RET\n         B     ASNOEXEC\n         SPACE 1\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*              USER PROGRAM DUMP PHASE                                *\n*        SET UP CORRECT LIMITS FOR DUMP, THEN MAKE SPECIAL XSNAP      *\n*        CALL WHICH PRODUCES THE FINAL DUMP, USING APPROPRIATE LIMITS.*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nASDUMPCL EQU   *\n         LM    R14,R15,ECRDLIML    ECRDLIML-ECRDLIMH - DUMP LIMITS\n         XSNAP T=(PR,FL,10),STORAGE=(*0(R14),*0(R15))      FINAL DUMP\n         B     ASNOEXEC            GO TO MAKE BATCH CHECK\n         EJECT\n*              ASEXOVSP - ENTERED IF STORAGE OVERFLOW.                *\nASEXOVSP ASPRNT ASEMSG,L'ASEMSG    PRINT STORAGE OVERFLOW MESSAGE\n         SPACE 1\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*              MAIN END-OF-$JOB EXIT - ASNOEXEC                       *\n*        IF TIME AND RECORDS OVERRUN OCCURRED, PRINT MESSAGE.         *\n*        THEN TEST FOR BATCH RUN, IF SO REUTURN FOR NEXT $JOB CARD.   *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*              ASNOEXEC - PRINT OVERRUN MESSAGE IF ONE HAS OCCURRED.  *\nASNOEXEC EQU   *\n         TM    AJOMODE,AJOSRECX+AJOSOVRT    TEST FOR OVERRUN\n         BZ    ASTSTBAT            NO OVERRUN, TEST FOR BATCH\n         NI    AJOMODE,255-AJOSRECX    IF SPURIOUS ON, REMOVE SO FLAG\n         MVI   AJORECNT+3,1        ALLOW ONE PRINT LINE FOR AM005 CEH\n         ASPRNT ASRTOVR,L'ASRTOVR  OVERFLOW- NOTE OCCURRENCE\n         SPACE 1\n*              ASTSTBAT - TEST FOR BATCH RUN, CONTINUE IF SO.         *\nASTSTBAT EQU   *\n         AIF   (&$XXIOS).ASFIN     SKIP IF NO EXTENDED I/O            J\n         XCALL XXDDFINI            CALL TO CLOSE EVERYTHING UP        J\n.ASFIN   ANOP\n         TM    AJOMODE,AJOBATCH    WAS RUN A BATCH ONE\n         BZ    ASFINIS             NO, SO WE'RE DONE. QUIT NOW\n         SPACE 1\n*              FOR BATCH RUN, MAKE SURE MODE/STEP BITS RESET RIGHT.\n         NI    AJOMODE,255-(AJOREPLF+AJOSRECX+AJOSOVRT+AJOREPHB)\n         NI    AJOSTEP,255-(AJOSASM+AJOSEXEC+AJOSDUMP)     RESET PHASE\n         B     ASJPARMS            GO BACK, SEARCH FOR NEXT $JOB\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> INSUB: ASFLUSH    FLUSH CARD RDR UNTIL NEXT COMMAND CARD         *\n*        FLUSH UNTIL ASSIST JCL CARD FOUND, PLACING SUCH CARD INTO    *\n*        AJOJCLCD (XXXXSORC DOES IT AUTOMATICALLY WHEN FOUND).        *\n*        IF END-FILE FOUND, TERMINATE RUN.  NOTE $STOP == EOF.        *\n*        ENTRY CONDITIONS                                             *\n*   R14= RETURN ADDRESS TO CALLING CODE.                              *\n*        EXIT CONDITIONS                                              *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nASFLUSH  $SORC AJOJCLCD,80,ASFINIS IF END-FILE, ALL DONE-QUIT         J\n         MVI   AJOBTRQ,AJO$D       SET TO BE DATA AGAIN               J\n         BR    R14                 RETURN TO CALLER                   J\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> INSUB: ASTIMR##   TIMING SERVICES IN ASSIST MAIN PROGRAM.        *\n*        THIS SECTION CONSISTS OF A NUMBER OF ENTRIES CALLED FROM     *\n*        POINTS IN THE ASSIST MAIN PROGRAM, USING THE MACRO ASTIMR    *\n*        AND A TWO-DIGIT CODE AS ONE OPERAND.  EACH ENTRY PERFORMS A  *\n*        SPECIFIC TIMING FUNCTION. AS OF 10/20/70, NO ENTRY IS CALLED *\n*        FROM MORE THAN ONE POINT IN ASSIST, SO ACTUALLY, THE CODE FOR*\n*        EACH ONE COULD BE INSERTED INLINE, SAVING SOME SPACE.  THE   *\n*        SECTIONS ARE GROUPED THIS WAY FOR EASE OF MODIFICATION, AND  *\n*        EASE OF GENERATION, SINCE NOT ALL ENTRIES EXIST FOR ALL      *\n*        GENERATION OPTIONS (CONTROLLED BY &$TIMER).  THE ASTIMR MACRO*\n*        GENERATES CALLS ONLY TO THE EXISTING SECTIONS.               *\n*        ENTRY CONDITIONS (FOR ALL ASTIMR## ENTRIES)                  *\n*   R9 = RETURN @ TO CALLING SECTION IN ASSIST.                       *\n*        EXIT CONDITIONS                                              *\n*   R0,R1,R14,R15  MAY BE DESTROYED.                                  *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n         AIF   (&$TIMER LT 2).AST00A        SKIP IF NO $TIRC USABLE\n*              ASTIMR00 - &$TIMER=2 - INITIALIZE OVERALL TIMER        *\nASTIMR00 EQU   *\n         $TIRC TIMREM              GET REMAINING TIME, TIMER UNITS\n         ST    R0,ASTBEGIN         SAVE THIS INITIAL TIME\n         BR    R9                  RETURN TO CALLER\n         SPACE 1\n.AST00A  AIF   (&$TIMER GT 0).AST04A        SKIP IF ANY TIMER AT ALL\n         SPACE 1\n*              ASTIMR18 - &$TIMER=0 - PRINT INSTRUCTION COUNT.        *\nASTIMR18 EQU   *\n         LM    R0,R1,ECILIMT       GET ECILIMT-ECILIMP FOR COMPUTE\n         SR    R1,R0               GET DIFFERENCE = # EXECUTED\n         CVD   R1,AJODWORK         CONVERT # EXECUTED\n         MVC   ASHEXP2,ASPATB      MOVE EDIT PATTERN OVER\n         ED    ASHEXP2,AJODWORK+8-ASPBL/2   EDIT # INSTRS DONE\n         SPACE 1\n         ASPRNT ASHEX,ASHEXL       PRINT EXECUTION MESSAGE\n         BR    R9                  RETURN TO CALLER\n         SPACE 1\n         AGO   .AST24A             SKIP OVER REST OF CODE\n.AST04A  AIF   (&$TIMER GT 1).AST04B        SKIP IF NOT =1\n*              ASTIMR04 - &$TIMER=1 - FIND TIME FOR STIMER SETTING.   *\nASTIMR04 EQU   *\n         L     R0,AJOTIML          LOAD TOTAL TIME LIMIT INTO PARM REG\n         BAL   R14,ASTIMSET        GO SET TIMER TO VALUE IN R0(TU)\n         BR    R9                  RETURN TO CALLER\n         SPACE 1\n         AGO   .AST08A             SKIP OVER CODE\n.AST04B  ANOP\n*              ASTIMR04 - &$TIMER=2 - GET TIME LEFT FOR STIMER        *\nASTIMR04 EQU   *\n         L     R0,AJOTIML          TOTAL TIME LIMIT (TIMER UNITS)\n         TM    AJOAPMOD,AJOAPUST   DID USER ACTUALLY SUPPLY T= VALUE\n         BO    AST04A              YES, SO LEAVE IT ALONE-OK\n*              USER DID NO SUPPLY T=, USE TIMREM TO GET ACTUAL LEFT.\n         $TIRC TIMREM              GET ACTUAL TIME REMAINING\n         SH    R0,=AL2(5000/26)    5 MILLISEC FUDGE FACTOR FOR SAFETY\nAST04A   BAL   R14,ASTIMSET        GO SET TIMER TO DESIRED VALUE\n         BR    R9                  RETURN TO CALLER\n.AST08A  SPACE 2\n         SPACE 1\n*              ASTIMR12 - &$TIMER=1,2 - PRINT ASSEMBLY STATISTICS.    *\n*        ENTRY CONDITIONS                                             *\n*   R12(RAT) = @ AVWXTABL DUMMY SECTION                               *\nASTIMR12 EQU   *\n         USING AVWXTABL,RAT        NOTE THE POINTER\n         LH    R7,AVSTMTNO         GET # STATEMENTS FOR ASTIMER\n         DROP  RAT                 ERASE THE USING\n         ASTIME ASHASM,*           CALL TIMER TO PRINT MSG\n         BR    R9                  RETURN TO CALLER\n         SPACE 1\n*              ASTIMR14 - SET UP FOR REPLACEMENT PHASE B EXEC.        *\nASTIMR14 EQU   *                   (SAME AS -16, I.E., EXECUTION)\n*              ASTIMR16 - &$TIMER=1,2 - SET TIMER FOR EXECUTION TIMING*\nASTIMR16 EQU   *\n         L     R0,AJOTIMR          GET CURRETN TIME REMAINING FOR T=\n         L     R1,AJOTX            GET DESIRED TX= LIMIT\n         LA    R15,AJOTD           ADDRESS OF TIME TO BE SAVED FOR DUMP\n         BAL   R14,ASTRP16         CALL ROUTINE TO CALCULATE TIME\n         BAL   R14,ASTIMSET        CALL STIMER CODE\n         BR    R9                  RETURN TO CALLING SECTION OF CODE\n         SPACE 1\n*              ASTIMR18 - &$TIMER=1,2  CALC,PRINT EXEC TIME,RATE      *\nASTIMR18 EQU   *\n         LM    R6,R7,ECILIMT       GET ECILIMT/ECLIMP FROM ECONTROL\n         SR    R7,R6               GET # INSTRUCTIONS ACTUALLY DONE\n         CVD   R7,AJODWORK         CONVERT # INSTRS DONE\n         MVC   ASHEXP2,ASPATB      MOVE EDIT PATTERN OVER\n         ED    ASHEXP2,AJODWORK+8-ASPBL/2   EDIT # INSTRUCTIONS DONE\n         ASTIME ASHEX,*            GO TO DO TIMING\n         BR    R9                  RETURN TO CALLING SECTION\n         SPACE 1\n*              ASTIMR20 - &$TIMER=1,2. SET UP FOR DUMP\nASTIMR20 EQU   *\n         L     R0,AJOTIMR          GET CURRENT TIMER SETTING\n         A     R0,AJOTD            ADD IN TIME FOR DUMP\n         BAL   R14,ASTIMSET        CALL STIMER ROUTINE\n         BR    R9                  RETURN TO CALLER\n         SPACE 1\n         AIF   (&$TIMER LT 2).AST24A        SKIP IF NO ENDING TIME\n*              ASTIMR24 - &$TIMER=2 - COMPUTE,PRINT TOTAL ASSIST TIME *\nASTIMR24 EQU   *\n         $TIRC TIMREM              GET TIME REMAINING INTO R0\n         L     R1,ASTBEGIN         PLACE BEGINNING TIME FOR ASTIMER\n         LA    R2,ASHEND           SHOW @ OF MESSAGE\n         LA    R3,ASHENDP          SHOW @ NUMBER AREA\n         LA    R4,ASHENDL          SHOW LENGTH OF MESSAGE\n         SR    R6,R6               SHOW NO RATE (2ND PART OF MESSAGE)\n         BAL   R14,ASTIMERE        ENTER MIDDLE SECTION OF TIME PRINTER\n         BR    R9                  RETURN TO CALLER\n.AST24A  ANOP\n         EJECT\n         AIF   (&$TIMER LT 1).AST60A        SKIP CODE IF UNNEEDED\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> INSUB: ASTIMSET   SET INTERVAL TIMER ROUTINE                     *\n*        CALLED BY ASTIMR## SECTIONS TO SET TIMER FOR GIVEN INTERVAL. *\n*        **NOTE** THIS IS ONLY USE OF IBM STIMER MACRO IN ASSIST.     *\n*        ALSO, UNDER DOS, ONLY USE OF STXIT MACRO.                    *\n*        ENTRY CONDITIONS                                             *\n*   R0 = VALUE OF TIMER INTERVAL TO BE SET (TIMER UNITS = 26.04 MICS) *\n*   R14= RETURN ADDRESS TO CALLING SECTION IN ASTIMR##                *\n*        EXIT CONDITIONS                                              *\n*   R0,R1,R15  MAY BE MODIFIED.                                       *\n*   AJOMODE IS SET TO SHOW NO TIME OVERRRUNS EXIST AT MOMENT.         *\n*        USES MACROS:  STIMER(OS) ; STXIT,SETIME, GETIME(DOS)         *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nASTIMSET EQU   *\n         ST    R0,AJOTIMR          STORE VALUE AS CURRENT LAST TIMER\n         NI    AJOMODE,255-AJOSOVRT         MAKE SURE FLAG SET OFF\n         AIF   (&$ASMLVL).ASTDOST  SKIP OVER DOS TIMING OPTIONS\n         LR    R1,R0               GET VALUE OF TIMER INTERVAL IN R1\n         M     R0,AJ2604           MULT BY MICROSEC/TU\n         D     R0,AJ100M           CONVERT TO SEC IN R1\n         SETIME  (R1)              SET INTERVAL TIMER\n         GETIME  TU                R1 <= TIME OF DAY IN TIMER UNITS\n         A     R1,AJOTIML          R1 <= TIME OF DAY FOR TIMER INTERRPT\n         ST    R1,ASTMRMDS         SAVE TIME FOR TIMREM OPTION\n         STXIT IT,ASTEXIT,ASTSAVAD ALLOW TIMER INTERRUPTION\n.ASTDOST AIF   (NOT &$ASMLVL).ASTOSTM  SKIP OS STIMER\n         STIMER TASK,ASTEXIT,TUINTVL=AJOTIMR\n.ASTOSTM ANOP\n         BR    R14                 RETURN TO CALLER\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> INSUB: ASTIMER    UPDATE TIMER,PRINT ELAPSED TIME,MESSAGE        *\n*        **NOTE** THIS IS ONLY USE OF IBM TTIMER MACRO IN ASSIST.     *\n*        ENTRY CONDITIONS                                             *\n*   R2 = @ MESSAGE TO BE PRINTED OUT                                  *\n*      = 0 ==> UPDATE TIMER ONLY, DO NOT PRINT MESSAGE OUT            *\n*   R3 = @ AREA WHERE TIME INCREMENT SHOULD BE PLACED                 *\n*   R4 = LENGTH OF MESSAGE TO BE PRINTED                              *\n*   R6 = @ WHERE SECOND PART OF MESSAGE TO GO (INSTS/SEC, ETC)        *\n*      = 0 ==> THERE IS NO 2ND PART OF MESSAGE                        *\n*   R7 = VALUE TO BE USED IN 2ND PART OF MESSAGE, IF ANY              *\n*   R14= RETURN @ TO CALLING SECTION OF PROGRAM.                      *\n*        USES MACROS:  TTIMER(OS) ; GETIME(DOS)                       *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nASTIMER  EQU   *                   ENTRY FOR TIMING PRINTING MODULE\n         AIF   (&$ASMLVL).ASTOSGT  SKIP IF OS TTIMER DESIRED\n         GETIME  TU                R1 <= TIME OF DAY IN TIMER UNITS\n         L     R0,ASTMRMDS         GET TIME OF DAY FOR INTERRUPT(TIME)\n         SR    R0,R1               YIELDS TIME (TU) LEFT IN INTERVAL\n.ASTOSGT AIF   (NOT &$ASMLVL).ASTDSGT  SKIP IF DOS GETIME IN EFFECT\n         TTIMER ,                  GET TIME LEFT IN INTERVAL\n.ASTDSGT ANOP\n         L     R1,AJOTIMR          GET CURRENT TIME REMAINING\n         ST    R0,AJOTIMR          STORE NEW TIME REMINAING\n         LTR   R2,R2               IS THERE A MESSAGE TO BE PRINTED\n         BCR   Z,R14               RETURN TO CALLER, JUST RESET TIMER\n         SPACE 1\n*              ASTIMERE ENTRY ONLY ENTERED FROM SECTION ASTIMR24,IF GEN\nASTIMERE EQU   *                   ENTRY WITH NO TIMER UPDATE.\n         SR    R1,R0               GET TIME DIFFERENCE\n         M     R0,AJ2604           MULT BY 26.04 MICROSEC/TU\n         D     R0,AJ100000         CONVERT TO MILLISEC IN R1\n         CVD   R1,AJODWORK         CONVERT ELAPSED TIME\n         MVC   0(ASPAL,R3),ASPATA  MOVE THE EDIT PATTERN IN\n         ED    0(ASPAL,R3),AJODWORK+8-ASPAL/2         EDIT VALUE OVER\n         LTR   R3,R6               TEST CODE AND MOVE OVER\n         BZ    ASTPRINT            SKIP REST IF ZERO,GO PRINT\n         SPACE 1\n         M     R6,AJ1000           MULT # STMTS, GET STMTS/SEC\n         LTR   R1,R1               MAKE SURE TIME >= 1MILLISEC\n         BZ    *+6                 SKIP DIVIDE IF 0\n         DR    R6,R1               DIVIDE TO GET STMTS OR INSTS/SEC\n         CVD   R7,AJODWORK         CONVERT RESULT TO DECIMAL\n         MVC   0(ASPBL,R3),ASPATB  MOVE EDIT PATTERN OVER\n         ED    0(ASPBL,R3),AJODWORK+8-ASPBL/2         EDIT VALUE ACCROS\nASTPRINT LR    R0,R2               MOVE @ MESSAGE OVER FOR ASASPRINT\n         LR    R1,R4               MOVE LENGTH OVER FOR ASASPRNT\n*              FALL THRU INTO ASASPRNT\n.AST60A  ANOP\n         SPACE 1\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> INSUB: ASASPRNT   CALLED BY ASPRNT MACRO TO PRINT A LINE.        *\n*        THIS INSUB IS USED INSTEAD OF MANY $PRNTS TO SAVE SPACE.     *\n*        *** MUST IMMEDIATELY FOLLOW ASTIMER SECT., IF IT EXISTS.     *\n*        ENTRY CONDITIONS                                             *\n*   R0 = @ LINE TO BE PRINTED                                         *\n*   R1 = LENGTH OF LINE TO BE PRINTED.                                *\n*   R14= RETURN @ TO CALLING CODE INSIDE MAIN PROG ASSIST.            *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nASASPRNT $PRNT (R0),(R1)           PRINT THE LINE DESIRED\n         BR    R14                 RETURN TO CALLER\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*              MAIN STORAGE MANAGEMENT CODE SECTIONS.                 *\n*        THE FOLLOWING SECTIONS OF CODE CONTAIN THE INTERFACE         *\n*        BETWEEN ASSIST AND THE OPERATING SYSTEM WITH RESPECT TO      *\n*        DYNAMIC MEMORY MANAGEMENT.  IF ASSIST MUST BE RUN UNDER      *\n*        A SYSTEM WITHOUT SUCH FACILITIES, THIS CODE CAN BE MODIFIED  *\n*        TO JUST SUPPLY ADDRESSES OF A FIXED STORAGE AREA.            *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 2\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> INSUB: ASMSINIT   MAIN STORAGE INITIALIZATION                    *\n*              ASMSINIT IS CALLED TO OBTAIN THE LARGEST POSSIBLE      *\n*        BLOCK OF MAIN STORAGE >= 8K BYTES, FREE BACK THE AMOUNT      *\n*        GIVEN BY ASLENOS (OR FREE= PARM, IF USED), AND SET VALUES    *\n*        DESCRIBING THE STORAGE AREA LEFT, WHICH IS USED AS THE       *\n*        SINGLE DYNAMIC STORAGE AREA FOR THE ENTIRE RUN.              *\n*        STORAGE ALLOCATION IS DONE 1 TIME ONLY FOR WHOLE BATCH.      *\n*        ENTRY CONDITIONS                                             *\n*   R14= RETURN @ TO CALLING SECTION OF CODE.                         *\n*        EXIT CONDITIONS                                              *\n*   R0,R1,R2,R15   ARE MODIFIED BY THIS SECTION.                      *\n*   AJOPADL,AJOPADH HAVE BEEN SET(LOWER, UPPER LIMITS OF CORE AREA).  *\n*        AJOSTEP SET WITH FLAG AJOMSINT TO SHOW DONE.                 *\n*        USES MACROS: GETMAIN (ONLY USE OF GETMAIN IN ASSIST).        *\n*                     COMRG-(DOS)                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nASMSINIT EQU   *\n         OI    AJOSTEP,AJOMSINT    SHOW MAIN CORE OBTAINED. HALT FREE=\n         LA    R2,AJOPADL          GET @ WHERE @'S TO BE PUT\n         AIF   (&$ASMLVL).ASGETMN  FOR THE OS GETMAIN\n         SPACE\n         COMRG                     GET @ OF OUR COMMUNICATIONS REGION\n         LM    R0,R1,32(R1)        R0 <- HIGHEST PARTITION ADDRESS\n*                                  R1 <- END @ OF LAST PHASE LOADED\n         LA    R1,3(R1)            GET @ OF AT LEAST NEXT FULLWORD\n         N     R1,=X'FFFFFFFC'     INSURE FULLWORD BOUNDARY\n         N     R0,=X'FFFFFFFC'     MAKE SURE ON FULLWORD BOUNDARY\n         SR    R0,R1               GET LENGTH OF FREE STORAGE LEFT\n         ST    R1,0(R2)            SAVE @ OF FREE BLOCK\n         ST    R0,4(R2)            SAVE LENGTH OF FREE BLOCK\n.ASGETMN AIF   (NOT &$ASMLVL).ASNGTMN  IN CASE OF STATIC ALLOCATION\n         GETMAIN VU,LA=ASSPACE,A=(2),SP=1    GET AT LEAST 8K\n.ASNGTMN ANOP\n*              AT THIS PT AJOPADL=@ AREA, AJOPADH=LENGTH OF IT\n         SPACE 1\n         AIF   (&$DEBUG).ASZX1     SKIP IF NOT DEBUG MODE\n*              ZERO ENTIRE DYNAMIC MEMORY AREA FOR DEBUGGING.\n         LH    R0,=H'-256'         FOR BXH DECREMENT\n         L     R15,AJOPADH         GET LENGTH OF AREA\n         L     R1,AJOPADL          GET @ AREA\n         AR    R15,R1              ADD BEGIN TO LENGTH TO GET END@\n         AR    R15,R0              ADD -256 TO ENDING @\n         SPACE 1\n         XC    0(256,R15),0(R15)   ZERO A BLOCK OF MEMORY\n         BXH   R15,R0,*-6          LOOP BACKWARDS, ZEROING\n         XC    0(256,R1),0(R1)     ZERO 1ST 256 TO MAKE SURE\n.ASZX1   ANOP\n         SPACE 1\n         LM    R0,R1,AJOPADL       AJOPADL,H= AREA @, LENGTH\n         LR    R15,R1              SAVE THE LENGTH OF THE AREA\n         AR    R1,R0               GET UPPER @ LIMIT\n         ST    R1,AJOPADH          SAVE AS PERMANENT UPPER LIMIT\n         SPACE 1\n*              CHECK FREE VALUE, FREE SPACE AS REQUESTED.\n         L     R0,AJOFREE          GET FREE VALUE (INIT TO ASLENOS)\n         CR    R0,R15              COMPARE FREE LENGTH TO OBTAINED ONE\n         BNH   *+6                 SKIP IF OK, FREE <= GOTTEN         J\n         LR    R0,R15              FREE WHOLE THING (LOOK FOR AS999)  J\n         AIF   (&$FREEMN EQ 0).ASZQQQ  SKIP IF NO LOWER LIMIT ON FREE J\n         CH    R0,=H'&$FREEMN'     COMPARE AGAINST MINIMUM ALLOWED    J\n         BNL   *+8                 SKIP IF >= MINIMUM ALLOWED         J\n         LH    R0,=H'&$FREEMN'     PROBABLY ERROR, USE MINIMUM ALLOWED\n.ASZQQQ  ANOP                                                         J\n         SRL   R0,3                SHIFT, REMOVE 3 BITS\n         SLA   R0,3                SHIFT, ALIGNED ON DOUBLEWORD\n         BCR   Z,R14               RETURN, FREE=0, SO FREE NONE\n         SR    R1,R0               SUBTRACT FROM UPPER LIMIT\n         ST    R1,AJOPADH          NEW UPPER LIMIT\n         B     ASMSFREE            GO FREE THE SPACE REQUESTED\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> INSUB: ASMSFINI FREE CURRENT DYNAMIC STORAGE AREA                *\n*        CALLED TO FREE SPACE DESCRIBED BY AJOPADL-AJOPADH PTRS.      *\n*        SINCE DOS USER MUST ALLOCATE OWN DYNAMIC AREA FOR THE USERS  *\n*        PROGRAMS, THERE IS NO NEED TO FREE THIS BLOCK.               *\n*        ENTRY CONDITIONS                                             *\n*   R14= RETURN @ TO CALLING SECTION OF CODE.                         *\n*        EXIT CONDITIONS                                              *\n*   R0,R1,R15  ARE MODIFIED.                                          *\n*   STORAGE FROM (AJOPADL) TO (AJOPADH) HAS BEEN FREEMAIN'ED.         *\n*        USES MACROS: FREEMAIN   (ONLY USE OF FREEMAIN IN ASSIST).    *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nASMSFINI EQU   *\n         LM    R15,R0,AJOPADL      GET AJOPADL-AJOPADH\n         LR    R1,R15              MOVE LOWER @ OVER\n         SR    R0,R15              LENGTH = (AJOPADH) - (AJOPADL).\n         SPACE 1\nASMSFREE EQU   *                   ENTRY POINT FROM ASMSINIT TO FREE\n         AIF   (NOT &$ASMLVL).ASNFRMN   SKIP IF DOS DYNAMIC STORAGE USE\n         AL    R0,=XL4'01000000'   SHOW SP=1\n         FREEMAIN R,LV=(0),A=(1)   FREE THE SPACE TO OS\n.ASNFRMN ANOP\n         BR    R14                 RETURN TO CALLER\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> INSUB: ASRECL##   RECORD LIMIT CONTROL                           *\n*        VARIOUS ENTRIES IN THIS SECTION ARE CALLED TO MANIPULATE     *\n*        RECORD CONTROL VARIABLES.  EACH SECTION IS NORMALLY CALLED   *\n*        ONLY ONE PLACE, BUT ARE GROUPED HERE FOR EASE OF CHANGE, AND *\n*        SETUP FOR DIFFERING OPTIONS.                                 *\n*        ENTRY CONDTIONS                                              *\n*   R9 = RETURN ADDRESSS OF CALLING CODE                              *\n*        EXIT CONDITIONS                                              *\n*   R0,R1,R14,R15  MAY BE DESTROYED.                                  *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n*              ASRECL04 - INITIALIZE TOTAL RECORD COUNT               *\nASRECL04 EQU   *\n         AIF   (&$RECORD EQ 2).ASR04A       SKIP IF  $TIRC EXISTS\n         MVC   AJORECNT,AJORECL    MOVE USER VALUE OVER\n         BR    R9                  RETURN TO CALLER\n.ASR04A  AIF   (&$RECORD LT 2).ASR04B       SKIP IF NO $TIRC\n*              CALCULATED RECORD LIMIT: =RECREM (IF USER SUPPLIED NO\n*              R= PARM.   OR  MIN(RECREM, USER R= PARM)).\n         $TIRC RECREM              GET # LEFT SAID BY SYSTEM\n         TM    AJOAPMOD,AJOAPUSR   DID USER ACTUALLY SPECIFY\n         BZ    ASR04A              NO, SO JUST USE RECREM\n         AIF   (&$RECOVR).ASRPSU1  SKIP IF R= SHOULD BE USED-PSU BATS\n         C     R0,AJORECL          CHECK AGIANST USER R=\n         BNH   *+8                 SKIP IF MINIMUM THERE ALREADY\n.ASRPSU1 L     R0,AJORECL          GET USER SPECIFIED R= RECORD LIMIT\nASR04A   ST    R0,AJORECNT         STORE THE COUNT THERE\n         BR    R9                  RETURN TO CALLER\n.ASR04B  ANOP\n         SPACE 1\n*              ASRECL14 - SET RECORD COUNT BEFORE REPL PHASE B.\nASRECL14 EQU   *                   JUST SAME AS FOR EXECUTE TIME\n         SPACE 1\n*              ASRECL16 - RECORD CONTROL JUST BEFORE USER EXECUTION.\n*              AJORECNT = MIN(AJORECNT, RX=) - RD=  .\n*              THIS METHOD ALLOWS FOR DUMP IF DESIRED.\nASRECL16 EQU   *\n         L     R0,AJORECNT         GET CURRENT LINES LEFT-TOTAL\n         L     R1,AJORX            GET DESIRED TOTAL FOR EXEC+DUMP\n         LA    R15,AJORD           @ RECORDS SAVED FOR DUMP\n         BAL   R14,ASTRP16         CALL COMPUTING ROUTINE\n         ST    R0,AJORECNT         STORE THE VALUE COMPUTED\n         NI    AJOMODE,255-AJOSRECX    REMOVE POSSIBLE OVERRUN FLAG\n         BR    R9                  RETURN TO CALLER\n         SPACE 1\n*        ASRECL20 - RESET RECORD CONTROL JUST BEFORE USER DUMP DONE.\nASRECL20 EQU   *\n         L     R0,AJORECNT         GET # LEFT FROM EXECUTION\n         A     R0,AJORD            ADD THOSE SAVED FOR DUMP\n         ST    R0,AJORECNT         STORE CORRECT NEW VALUE\n         NI    AJOMODE,255-AJOSRECX         REMOV OVERRRUN FLAG IF ON\n         BR    R9                  RETURN TO CALLER\n         SPACE 2\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> INSUB: ASTRP16    COMPUTE VALUES FOR BEFORE EXECUTION            *\n*        USED BY (ASTIMR,ASRECL,ASPAGE)16 TO COMPUTE THE VALUE FOR    *\n*        CONTROL FOR USER EXECUTION.  THE VALUE IS THE MINIMUM OF     *\n*        REMAINING VALUE AND THE USER EXECUTION VALUE.  THEN SUBTRACT *\n*        AMOUNT TO BE SAVED FOR A DUMP.                               *\n*        ENTRY CONDITIONS                                             *\n*   R0 = CURRENT VALUE OF COUNTER  (AJOTIMR,AJORECNT,AJOPREM)         *\n*   R1 = EXECUTION VALUE           (AJOTX,  AJORX,  AJOPX)            *\n*   R15= @ DUMP VALUE              (AJOTD,  AJORD,  AJOPD)            *\n*        EXIT CONDITIONS                                              *\n*   R0 = MIN ((R0), (R1)) - 0(R15).  IF <0, = 0(R15) & 0(R15) = 0.    *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nASTRP16  EQU   *\n         CR    R0,R1               WAS REMAINING LESS THAN EXEC SPECFD\n         BL    *+6                 YES, USE IT SINCE MIN\n         LR    R0,R1               NO, USE EXECUTION TIME SPECIFIED VAL\n         S     R0,0(,R15)          SUBTRACT VALUE SAVED FOR DUMP\n         BCR   P,R14               RETURN IF OK\n         A     R0,0(,R15)          ADD THE VALUE BACK TO 0 OR ABOVE\n         SR    R1,R1               GET A 0\n         ST    R1,0(,R15)          ZERO OUT-SO WE DON'T GIVE HIM MORE\n         BR    R14                 RETURN TO CALLING SECTION\n         EJECT\n         AIF   (NOT &$PAGE).ASPG100         SKIP IF NO PAGE CONTROL\n**--> INSUB: ASPAGE##   PAGE CONTROL CODE FOR PAGE MODE LIMITS  + + + +\n*+       THESE SECTIONS CALLED TO SET LINE AND PAGE LIMITS.  NOTE THAT+\n*+       THEY DO NOT BOTHER TO CHECK WHETHER PAGE CONTROL MODE IS     +\n*+       ON OR NOT.  THIS IS SAFE BECAUSE THESE ACTIONS HAVE NO       +\n*+       EFFECT WHATSOEVER IF PAGE CONTROL NOT ON, SINCE XXXXIOCO     +\n*+       SECTIONS DO NO CHECKING UNLESS IT IS.                        +\n*+       NOTE THAT SECTIONS OF ASTIMR##, ASRECL##, AND ASPAGE## HAVING+\n*+       SAME TWO-DIGIT CODE FOR END GENERALLY ARE CALLED TOGETHER.   +\n*+       ENTRY CONDITIONS                                             +\n*+  R9 = RETURN ADDRESS TO CALLING SECTION OF CODE.                   +\n*+       EXIT CONDITIONS                                              +\n*+  R0,R1,R14,R15  MAY BE DESTROYED.                                  +\n*+  + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +\n         SPACE 1\n*+             ASPAGE04 - INITIALIZE FOR WHOLE RUN.  SET UP FOR       +\n*+             DEFINITE NEW PAGE SKIP, SINGLE SPACE IF REQUESTED.     +\nASPAGE04 EQU   *\n         MVC   AJOPREM,AJOP        SET FROM WHATEVER VALUE OF P=\n         SR    R0,R0               ZERO REGISTER\n         ST    R0,AJOLREM          LINES LEFT = 0, CREATE NEW PAGE\n         NI    AJIOPR,255-AJIOSING REMOVE POSSIBLE SINGLE SPACE FLAG\n         OC    AJIOPR,AJIOSS       ENTER SINGLE SPACE FLAG IF REQUIRED.\n         BR    R9                  RETURN\n         SPACE 1\n         AIF   (&$REPL EQ 0).ASPNR SKIP IF NO REPL\n*+             ASPAGE14 - PAGE CONTROL BEFORE REPLACE PHASE B.\nASPAGE14 EQU   *\n         SR    R0,R0               ZERO REGISTER\n         ST    R0,AJOLREM          SAME AS ASPAGE16, BUT ****NEW PAGE**\n*              FALL THRU INTO ASPAGE16.\n.ASPNR   ANOP\n         SPACE 1\n*              ASPAGE16 - PAGE LIMIT SET BEFORE USER PROGRAM EXECUTE.\nASPAGE16 EQU   *\n         L     R0,AJOPREM          GET CURRENT # PAGES LEFT\n         L     R1,AJOPX            GET NUMBER FOR EXEC+DUMP\n         LA    R15,AJOPD           GET VALUE FOR DUMP\n         BAL   R14,ASTRP16         CALL GENERAL COMPUTE FOR EXEC\n         ST    R0,AJOPREM          STORE COMPUTED VALUE BACK\n         NI    AJIOPR,255-AJIOSING REMOVE POSSIBLE SINGLESPACE FLAG\n         OC    AJIOPR,AJIOSSX      FLAG SINGLE SPACE IF DESIRED\n         BR    R9                  RETURN TO CALLER\n         SPACE 1\n*+             ASPAGE20 - SET UP PAGE LIMIT FOR DUMP.                 +\nASPAGE20 EQU   *\n         L     R0,AJOPREM          GET CURRENT PAGES LEFT\n         A     R0,AJOPD            ADD IN DUMP PAGES\n         ST    R0,AJOPREM          STORE BACK\n         NI    AJIOPR,255-AJIOSING REMOVE POSSIBLE SINGLE SPACE FLAG\n         OC    AJIOPR,AJIOSSD      PUT IN SSD FLAG IF EXISTS\n         BR    R9                  RETURN\n.ASPG100 ANOP\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*              DISASTROUS TERMINATIONS.                               *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n*              ASZERR1 - COULD NOT OPEN PRINTER - ABORT               *\n         AIF   (&$ASMLVL).ASOSWTL      SKIP $PRNT IF UNDER OS GENERATN\nASZERR1  $PRNT =CL50' AM001 - ASSIST COULD NOT OPEN PRINTER - ABORT',50\n.ASOSWTL AIF   (NOT &$ASMLVL).ASDSPNT  SKIP IF DOS GENERATED $PRNT\nASZERR1  WTO   'AM001 ASSIST COULD NOT OPEN PRINTER FT06F001:ABORT',   #\n               ROUTCDE=11          WRITE-TO-PROGRAMMER NOW\n.ASDSPNT ANOP\n         TM    AJIOSO,AJIOPEN      COULD READER BE OPENED FOR SOURCE\n         BO    ASZERRXI            SKIP IF RDR DID OPEN OK\n         SPACE 1\n*              ASZERR2 - COULDN'T OPEN SOURC RDR - ABORT              *\n         AIF   (&$ASMLVL).ASRDRNO      SKIP FOR OS WTL & ABORT\nASZERR2  $PRNT =CL50' AM002 - ASSIST COULD NOT OPEN READER - ABORT',50\n.ASRDRNO AIF   (NOT &$ASMLVL).ASNOWTL  SKIP IF NO OS WTL ALLOWED\nASZERR2  WTO   'AM002 ASSIST COULD NOT OPEN READER SYSIN:ABORT',       #\n               ROUTCDE=11          WRITE-TO-PROGRAMMER RATHER THAN WTL\n.ASNOWTL ANOP\n         SPACE 1\nASZERRXI LA    R2,16               SET RETURN CODE TO DISASTER\n         B     ASFINISZ            TAKE ERROR EXIT\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                       FINISH AND EXIT SECTION                       *\n*        HAVE TOTAL RUN TIME COMPUTED AND PRINTED.                    *\n*        CLOSE ALL DCB'S WHICH ARE CURRENTLY OPEN (XXXXFINI).         *\n*        FREE ALL THE STORAGE OBTAINED BY GETMAIN AT BEGINNING.       *\n*        STORE VALUE IN R2 AS RETURN CODE.                            *\n*        RETURN TO CALLING PROGRAM.                                   *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nASFINIS  EQU   *                   NORMAL TERMINATION LABEL\n         ASTIMR 24,2               PRINT END MESSAGE IF REQUIRED\n         SPACE 1\n         XCALL XXXXFINI            HAVE ALL DCB'S CLOSED\n         SR    R2,R2               SET RETURN CODE TO 0\n         SPACE 1\n*              ASFINISZ ENTERED IF COULDN'T OPEN RDR OR PRINTER       *\n*              RETURN ALL GETMAIN'ED STORAGE TO THE SYSTEM.           *\nASFINISZ EQU   *\n         BAL   R14,ASMSFINI        GO RETURN ALL SPACE USED TO OS\n         SPACE 1\n         AIF   (&$ASMLVL).ASNOEOJ      SKIP FOR OS RETURN\n         EOJ                       SVC RETURN TO SUPERVISOR IF DOS\n.ASNOEOJ AIF   (NOT &$ASMLVL).ASDSEOJ  SKIP IF DOS EOJ IN EFFECT\n         L     R1,4(R13)           GET PREVIOUS SAVE AREA PTR\n         ST    R2,16(R1)           STORE VALUE IN R2 AS RETURN CODE\n         $RETURN RGS=(R14-R12)     RETURN TO CALLER\n.ASDSEOJ ANOP\n         SPACE 1\n         AIF   (&$TIMER LT 1).AST65A       SKIP STIMER EXIT IF NON REQR\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                       TIMER EXIT ROUTINE                            *\n*        THIS SECTION IS CALLED IF A TIMER INTERRUPT OCCURS DURING    *\n*        AN ASSIST RUN.  IT FLAGS AJOSOVRT BIT IN AJOMODE TO NOTE THE *\n*        OVERRUN, THEN EXAMINES AJOSTEP TO DETERMINE WHAT STEP ASSIST *\n*        IS IN.  DEPENDING ON THE STEP, IT TAKES ACTION TO ENSURE     *\n*        THAT THE PARTICULAR PHASE WILL BE TERMINATED FAIRLY QUICKLY. *\n*        PHASES CAN BE ASSEMBLY, EXECUTION, DUMP, OR ASSEMBLY+EXEC    *\n*        (THE LAST CASE BEING DURING A REPLACE PHASE B, IF ANY).      *\n*        **NOTE** UNDER DOS USE, ANY MODIFIED REGS MUST BE PLACED IN  *\n*        THE INTERRUPT SAVE AREA BEFORE EXITING                       *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n         AIF   (&$ASMLVL).ASTEXIN  SKIP IF UNDER OS GENERATION\nASTEXIT  BALR  R15,0               ESTABLISH ADDRESSABILITY\n         USING *,R15               INFORM OF BASE REG R15 USING\n.ASTEXIN AIF   (NOT &$ASMLVL).ASTEXDS  SKIP IF UNDER DOS GENERATION\n         USING ASTEXIT,R15         NOTE TEMPORARY USING\nASTEXIT  STM   R14,R12,12(R13)     SAVE ALL , FOR SAFETY\n.ASTEXDS ANOP\n         LA    R11,ASJOBCON        GET @ MAIN TABLE BACK\n         OI    AJOMODE,AJOSOVRT    SHOW REAL TIME OVERRUN\n         TM    AJOSTEP,AJOSEXEC    WAS INTERPRETER BEING USED\n         BZ    ASTEXASM            NO, GO TO CHECK ASM FLAG\n         L     R10,AJOECOPT        GET @ ECONTROL BLOCK\n         MVI   ECFLAG1,$ECTIMEX    TELL EXECUT TO QUIT NEXT BRANCH\n         SPACE 1\nASTEXASM EQU   *\n*              **NOTE** THE MAIN PROGRAMS FOR BOTH PASSES OF THE\n*              ASSEMBLER TEST AVTAGS2 1 TIME FOR EACH STATEMENT.\n*              **NOTE** IT IS ALWAYS SAFE TO SET THE BIT THIS WAY.\n         L     RAT,AJOVWXPT        GET @ VWXTABL\n         USING AVWXTABL,RAT        NOTE PTR THERE\n         OI    AVTAGS2,AJOASTOP    SET BIT-ASSEMBLER WILL STOP\n         DROP  RAT                 ZAP USING\n*              WE MAY BE IN DUMP STEP (AJOSDUMP IN AJOSTEP).  IN\n*              IN ANY CASE, SET AJOSRECX , WHICH WILL STOP ANY\n*              ASSIST MODULE, THE NEXT TIME ANY OUTPUT IS DONE.\n         TM    AJOSTEP,AJOSDUMP    ARE WE IN DUMP STEP                J\n         BZ    *+8                 NO, SKIP OVER OVERRUN SET\n         OI    AJOMODE,AJOSRECX    SHOW RECORDS EXCEEDED(PSEUDO)\nASTEXIZ  EQU   *\n         AIF   (&$ASMLVL).ASTEXEX  SKIP IF UNDER OS GENERATION\n         EXIT  IT                  RETURN TO DOS SUPERVISOR\nASTSAVAD DC    18F'-1'             DOS -IT- INTERRUPT SAVE AREA\nASTMRMDS DS    F                   TIME OF DAY FOR TIMER INTERRUPT\n.ASTEXEX AIF   (NOT &$ASMLVL).ASTEX2   SKIP IF UNDER DOS GENERATION\n         LM    R14,R12,12(R13)     RELOAD REGS\n         BR    R14                 RETURN TO OS/360\n.ASTEX2  ANOP\n         DROP  R15                 KILL THE USING\n.AST65A  ANOP\n         EJECT\n*              PRIMARY SPACE ALLOCATION CONTROL WORDS                 *\nASSPACE  DC    A(8192,524288)      GET ALL WE CAN, UP TO 512 K\nASTBEGIN DS    F                   FOR TIME LEFT AT BEGINNING\nASFWORK  DS    F                   TEMPORARY WORKAREA\nASPARMSV DS    A                   SAVE WORD FOR @ PARM FILED,ETC\n         SPACE 1\n*                  *** HEADER FOR BEGINNING OF EACH JOB ***\nASH1HD   DC    C'1*** ASSIST &$VERSLV-&$GENDAT'                 CPP\n         DC    C'  &$MCHNE/&$MODEL:&$SYSTEM'                    CPP\n*                                  INSTRUCTION SET-DECIMAL,FLOAT,PRIVIL\n         DC    C'  INS=S',(&$DECSA)C'D',(&$FLOTA)C'F',(&$PRIVOP)C'P'\n         DC    (&$S370A)C'7'       SUPPORT DEC. FLOAT, PRIV, 370 CPP\n         DC    C'/X=',(&$XIOS)C'B',(1-&$XXIOS)C'G',(&$HEXI*&$HEXO)C'H'\n         DC    (&$EXINT)C'O'       SUPPORT BASIC,XGET,HEXS,XOPC CPP\n         DC    ((1-(&$HEXI+&$HEXO+&$XIOS+&$EXINT+3)/4)*&$XXIOS)C'NONE'\n*                                  TIME,RECORDS,PAGE CHECKING/CONTROL\n         DC    C', CHECK/TRC/=&$TIMER&$RECORD&$COMNT'           CPP\n*                                  MAJOR OPTIONALS-CMPRS,COMNT,\n*                                  026 KEYPUNCH, MACRO, REPLACE MONITOR\n         DC    C', OPTS=',(&$CMPRS)C'C',((&$DISKU+1)/2)C'D'     CPP\n         DC    (&$KP26)C'K',(&$MACROS)C'M',(&$PAGE)C'P'         CPP\n         DC    ((&$REPL+1)/2)C'R',(&$XREF)C'X'                  CPP\n         DC    C'  PENN STATE UNIV ***'                         CPP\nASH1H$L  EQU   *-ASH1HD            LENGTH OF THIS HEADER\n         SPACE 1\n*              EDIT PATTERN, OUTPUT HEADINGS                          *\n         AIF   (&$TIMER LT 1).AST70A        SKIP EDIT PATTERN\nASPATA   DC    X'40202021204B202020'         EDIT PATTERN FOR TIMING\nASPAL    EQU   L'ASPATA            LENGTH ATTRIB OF EDIT TIME PATTERN\n.AST70A  ANOP\nASPATB   DC    X'4020202020202120' EDIT PATTERN FOR # INSTRUCTIONS DONE\nASPBL    EQU   L'ASPATB            LENGTH ATTRIB OF STMT EDIT PATTERN\n         SPACE 1\n         AIF   (&$TIMER GT 0).AST75A        SKIP IF NOT =0\n*              EXECUTION STATISTICS MESSAGE FOR &$TIMER=0 ONLY.\nASHEX    DC    C'0*** EXECUTION:'\nASHEXP2  DC    ZL(ASPBL)'0',C' INSTRUCTIONS EXECUTED ***'\nASHEXL   EQU   *-ASHEX             LENGTH OF MESSAGE\n.AST75A  AIF   (&$TIMER EQ 0).AST80A        SKIP MESSAGES IF UNNEEDED\nASHASM   DC    C'0*** ASSEMBLY TIME ='\nASHASMP  DS    CL(ASPAL)\n         DC    C' SECS, '\nASHASMN  DC    ZL(ASPBL)'0',C' STATEMENTS/SEC ***'\nASHASML  EQU   *-ASHASM            DEFINE LENGTH OF MESSAGE\n         SPACE 1\nASHEX    DC    C'0*** EXECUTION TIME ='\nASHEXP   DS    CL(ASPAL)\n         DC    C' SECS.  '\nASHEXP2  DC    ZL(ASPBL)'0',C' INSTRUCTIONS EXECUTED - '\nASHEXN   DC    ZL(ASPBL)'0',C' INSTRUCTIONS/SEC ***'\nASHEXL   EQU   *-ASHEX             DEFINE TOTAL LENGTH OF MESSAGE\n.AST80A  ANOP\nASCARDMS DC     C'*** FIRST CARD NOT READ: '   CARD MESSAGE           J\n         SPACE 1\nASEMSG   DC    C'0*** AM003 - STORAGE OVERFLOW BEFORE EXECUTION, EXECUTX\n               TION DELETED ***'\n         SPACE 1\nASNORMAL DC    C'0*** AM004 - NORMAL USER TERMINATION BY RETURN ***'\n         SPACE 1\nASRTOVR  DC    C'0*** AM005 - TIME OR RECORDS HAVE BEEN EXCEEDED'\n         SPACE 1\n         AIF   (&$TIMER LT 2).AST90A        SKIP END MESSAGE IF ^NEED\nASHEND   DC    C'0*** TOTAL RUN TIME UNDER ASSIST = '\nASHENDP  DC    ZL(ASPAL)'0',C' SECS ***'\nASHENDL  EQU   *-ASHEND            LENGTH OF MESSAGE\n         SPACE 1\n.AST90A  ANOP\nASHEXGO  DC    C'0*** PROGRAM EXECUTION BEGINNING - ANY OUTPUT BEFORE EX\n               XECUTION TIME MESSAGE IS PRODUCED BY USER PROGRAM ***'\n         SPACE 2\n*              ***** PARM FIELD OPTION LISTS *****\n         SPACE 1\n*              ASPARLIM - SUPPLIES LIMIT VALUES FOR NUMERICAL PARMS,\n*              PLUS DEFAULT VALUES FOR ANY OVERRIDABLE VALUES.\n*              **NOTE** MOST OF OVERRIDABLE ONES COULD BE SUPPLIED\n*              IN DEFAULT PARM FIELD BELOW ALSO.\nASPARLIM DS    0D                  ALIGN\n*              UPPER LIMIT VALUES-CANNOT BE INCREASED BEYOND THESE.\n         DC    C'I=&$IMX'          MAXIMUM INSTRUCTION COUNT\n         AIF   (NOT &$PAGE).ASPL10 SKIP IF NO PAGE CONTROL\n         DC    C',L=&$LMX,P=&$PMX,PD=&$PDMX,PX=&$PXMX'  PAGE LIMITS\n.ASPL10  ANOP\n         DC    C',R=&$RMX,RD=&$RDMX,RX=&$RXMX'        RECORD LIMITS\n         AIF   (&$TIMER EQ 0).ASPL20        SKIP IF NO TIMING\n         DC    C',T=&$TMX,TD=&$TDMX,TX=&$TXMX'        TIME LIMITS\n.ASPL20  ANOP\n         SPACE 1\n*              OVERRIDABLE DEFAULT VALUES FOR RESETTABLE PARM OPTIONS.\n         DC    C',&$BATCH,NOCMPRS,NOCOMNT,DUMP=0,FREE=&$FREE'\n         DC    C',LIST,LOAD,NOMONIT,NERR=0'  (LARGE NO LONGER EXISTS) J\n         AIF   (NOT &$DATARD).ASPL25        SKIP IF NO DATA RDR\n         DC    C',DATA,SYSIN'      DEFAULT - THEY BOTH EXIST\n.ASPL25  ANOP\n         AIF   (&$DEBUG).ASPL30    SKIP IF NO DEBUG\n         DC    C',DEBUG=0'         NO VALUE FOR DEBUG\n.ASPL30  ANOP\n*********AIF   (NOT &$EXINT).ASPL35    **********NEW INTERPRETER******\n         DC    C',IECF=0'          DEFAULT: NO STATISTICS\n.ASPL35  ANOP\n         AIF   (NOT &$KP26).ASPL40 SKIP IF NO ALTERNATE KEYPINCH\n         DC    C',KP=29'           DEFAULT IS 029\n.ASPL40  ANOP\n         AIF   (NOT &$PAGE).ASPL50 SKIP IF NO PAGE CONTROL\n*              CHANGE BELOW TO ---CPAGE TO PAGE CONTROL DEFAULT.\n         DC    C',NOSS,NOSSX,NOSSD,CPAGE'   MAKE CPAGE DEFAULT IF GEN J\n.ASPL50  ANOP\n         AIF   (&$DISKU NE 1).ASPL60                   SKIP\n         DC    C',NODISKU'         NORMAL - DO INCORE\n.ASPL60  ANOP\n         AIF   (NOT &$PUNCH).ASPL70         SKIP IF NOPUNCH\n         DC    C',PUNCH'           REAL PUNCH EXISTS\n.ASPL70  ANOP\n         AIF   (&$REPL EQ 0).ASPL90         SKIP IF NO REPLACE\n         DC    C',NOREPL,RFLAG=0'\n.ASPL90  ANOP\n         AIF   (NOT &$PRIVOP).ASPL100       SKIP IF NO PRIVILEGED OPS\n         DC    C',NOSUPER'\n.ASPL100 ANOP\n         AIF   (NOT (&$DECK OR &$OBJIN)).ASPL110      SKIP IF NO DECKS\n         DC    C',NODECK,NOOBJIN'\n.ASPL110 ANOP\n         AIF   (NOT &$RELOC).ASPL120   SKIP IF NO RELOC MODE\n         DC    C',NORELOC'         MAKE NON RELOCATED NORMAL MODE\n.ASPL120 ANOP\n         AIF   (&$S370 NE 2).ASPL130 SKIP IF NOT SIMULATING S/370\n         DC    C',ALGN'            MAKE DEFAULT ALGN (ALIGNMENT NEEDED)\n.ASPL130 ANOP\n         AIF   (NOT &$MACROS).ASPL140       SKIP IF NO MACROS\n         DC    C',MACRO=N,MACTR=&$MMACTR,MNEST=&$MMNEST,MSTMG=&$MMSTMG'\n         AIF   (NOT &$MACSLB).ASPL135        SKIP IF NO LIBRARY MACS\n         DC    C',NOLIBMC'                   DEFAULT = NO CALL LIBR MCS\n.ASPL135 ANOP\n.ASPL140 ANOP\n         AIF   (NOT &$XREF).NOXREF6  SKIP IF NO XREF                  A\n         DC    C',XREF=(&$XREFDF(1),&$XREFDF(2),&$XREFDF(3))'  DEFAULTA\n.NOXREF6 ANOP                                                         A\n         DC    C' '                PUT IN BLANK AT END*****MUST HAVE***\nASPARL$L EQU   *-ASPARLIM          LENGTH OF ENTIRE FIELD\n         SPACE 2\n*              DEFAULT VALUES FOR LIMIT VALUES AND NONRESETTABLE PARMS.\nASPARDF  DS    0D                  ALIGN\n         AIF   (NOT &$PAGE).ASPD10 SKIP IF NO PAGE CONTROL\n         DC    C'L=&$LDF,P=&$PDF,PD=&$PDDF,PX=&$PXDF,'\n.ASPD10  ANOP\n         DC    C'R=&$RDF,RD=&$RDDF,RX=&$RXDF'         RECORD DEFAULTS\n         AIF   (&$TIMER EQ 0).ASPD20        SKIP IF NO TIMER\n         DC    C',T=&$TDF,TD=&$TDDF,TX=&$TXDF'\n.ASPD20  ANOP\n         DC    C' '                PUT IN BLANK AT END*****MUST HAVE***\nASPARD$L EQU   *-ASPARDF           LENGTH OF THIS PARM FIELD\n         SPACE 1\n         LTORG\n         SPACE 1\n*              FOLLOWING SECTION CORRESPONDS TO AJOBCON DSECT.        *\nASJOBCON DS 0D\n         DC    16F'0'              FOR ZEROING\n         DC    F'1000'             FOR CONVERSION, AJ1000\n         AIF   (&$ASMLVL).ASJOSTU      SKIP TO SET OS TIMER UNIT=26.04\n         DC    F'333334'           DOS TIMER UNITS(USEC) * 100\n.ASJOSTU AIF   (NOT &$ASMLVL).ASJDSTU  SKIP IF DOS TU OF 1/300 SEC\n         DC    F'2604'             FOR TIME CONVERSIONS\n.ASJDSTU ANOP\n         DC    F'100000'           FOR TIME CONVERSIONS\n         DC    F'100000000'        100 MILLION, TIME CONVERSIONS\n         DC    V(VWXTABL)          @ MAIN ASSEMBLER TABLE\n         DC    V(EXECUT)           ADCON FOR INTERPRETER CODE\n         DS    0D\n         AIF   (NOT &$KP26).ASNKP26         SKIP IF NO 026 KEYPUNCH ALL\n         SPACE 1\n*              TRANSLATE TABLE - 026-->029 KEYPUNCH.  ALLOWS KP=26.\n*                 0 1 2 3 4 5 6 7 8 9 A B C D E F   SAME EXCEPT )+(='\n         DC    X'000102030405060708090A0B0C0D0E0F'    0X\n         DC    X'101112131415161718191A1B1C1D1E1F'    1X\n         DC    X'202122232425262728292A2B2C2D2E2F'    2X\n         DC    X'303132333435363738393A3B3C3D3E3F'    3?\n         DC    X'404142434445464748494A4B5D4D4E4F'    4X   ) 4C\n         DC    X'4E5152535455565758595A5B5C5D5E5F'    5X  + 50\n         DC    X'606162636465666768696A6B4D6D6E6F'    6X  ( 6C\n         DC    X'707172737475767778797A7E7D7D7E7F'    7X  = 7B  ' 7C\n         DC    X'808182838485868788898A8B8C8D8E8F'    8X\n         DC    X'909192939495969798999A9B9C9D9E9F'    9X\n         DC    X'A0A1A2A3A4A5A6A7A8A9AAABACADAEAF'    AX\n         DC    X'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF'    BX\n         DC    X'C0C1C2C3C4C5C6C7C8C9CACBCCCDCECF'    CX\n         DC    X'D0D1D2D3D4D5D6D7D8D9DADBDCDDDEDF'    DX\n         DC    X'E0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF'    EX\n         DC    X'F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF'    FX\n         SPACE 1\n.ASNKP26 ANOP\n         DC    CL136' '            FOR BLANKING\n         DC    C'0'                FOR CARRIAGE ONTROL\n         ORG   ASJOBCON+AJOB$L     GET REMAINING LENGTH FOR SECTION\n         DS    0D                  SEE WHAT LENGTH IS\n         DROP  R10,R11,R13         KILL LEFTOVER USINGS\n         TITLE '*** APCBLK DSECT - APARMS PARM CODE BLOCK ***'\n**--> DSECT: APCBLK     APARMS PARM CODE BLOCK. . . . . . . . . . . . .\n*.       THIS BLOCK DESCRIBES A PARM OPTION TABLE, GIVING THE NAME OF .\n*.       THE PARM, A FLAG BYTE, AND AN OFFSET ADDRESS TO A PROCESSING .\n*.       SECTION OF CODE IN CSECT APARMS.  IT IS USED ONLY IN APARMS. .\n*.       LOCATION:  INSIDE TABLE APBPARMA IN CSECT APARMS.            .\n*.       GENERATION: EACH APCBLK IS CREATED BY 1 CALL TO APCGN MACRO. .\n*.       NAMES: APC-----                                              .\n*.  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n         SPACE 1\nAPCBLK   DSECT\n*              EQU FLAG LIST FOR APCFLAG) - GIVE HANDLING TYPES.\nAPCYESNO EQU   B'00000001'         (APCFLAG)- YES/NO PARM;ELSE =PARM\nAPCYES1B EQU   B'00000010'         (APCFLAG)- FOR YES/NO TYPE PARMS\n*                                  ON=> 1BIT=>YES;OFF=> 1BIT=> NO\nAPCNINCR EQU   B'00000010'         (APCFLAG)- IF =PARM DECIMAL VALUE\n*                                  IF VALUE SET, DO NOT INCREMENT\nAPCD     EQU   B'00000100'         (APCFLAG)- PARM=DECIMAL # VALUE\nAPCNRSET EQU   B'00001000'         (APCFLAG)- ONCE SET, DO NOT RESET\nAPCCALL  EQU   B'00010000'         (APCFLAG)- CALL ROUTINE -APCADDR @\nAPCSETU  EQU   B'00100000'         (APCFLAG)-VALUE SET BY USER-$JOB CRD\nAPCSETP  EQU   B'01000000'         (APCFLAG)-VALUE SET FROM REAL PARM\nAPCSETLD EQU   B'10000000'         (APCFLAG)- VALUE WAS SET BY LIMIT\n*                                  OR DEFAULT VALUE.\nAPCSET   EQU   APCSETLD+APCSETU+APCSETP     VALUE SET BY ANYBODY\nAPCP$L   EQU   AJOCP$L             LENGTH OF MAXIMUM # CHARS IN PARM\n         SPACE 1\n*              VARIABLES IN APCBLK - GIVE PARM NAME AND FLAGS\nAPCPARM  DS    CL(APCP$L)          EBCDIC FORM OF PARM, R-PADDED BLANKS\nAPCFLAG  DS    B                   FLAGS- DESCRIBE TYPE OF HANDLING\nAPCAJOFS DS    AL1                 OFFSET OF VARIABLE FROM AJO$PARM\nAPCLKSET DS    B                   FLAG SHOWING WHICH CALL SET/IF SET\nAPCBITS  DS    B                   FLAG USED TO SET FOR YES OPT OF Y/N\n         ORG   APCBITS             BACK UP TO OVERLAY FOR =PARM\nAPCADDR  DS    AL1                 OFFSET FROM APAJUMP TO ROUTINE\nAPC$L    EQU   *-APCBLK            LENGTH OF 1 APCBLK\n         TITLE '*** APARMS - USER PARM FIELD PROCESSING CSECT ***'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> CSECT: APARMS     USER PARM FIELD PROCESSING CSECT               *\n*        SCANS USER PARM FIELD, SETS VALUES IN AJOBCON DSECT.         *\n*        ENTRY CONDITIONS                                             *\n*   R9 = @ OF ACTUAL PARM FIELD CHARACTER STRING.                     *\n*   R10= LENGTH OF PARM FIELD AT 0(R9).                               *\n*   R11= ADDRESS OF AJOBCON DUMMY SECTION AREA.                       *\n*        EXIT CONDITIONS                                              *\n*   AJOPARM IN AJOBCON NOW HAS USER PARM FIELD, RIGHT-PADDED WITH ' '.*\n*   VARIOUS FLAGS IN AJOBCON ARE NOW SET(SEE CODE STARTING AT APAJUMP)*\n*        USES DSECTS: AJOBCON,APCBLK                                  *\n*        USES MACROS: $DBG,$RETURN,$SAVE,$TIRC,APCGN,XDECI            *\n*        *NOTE* AS OF 8/12/70, THIS PROGRAM IS MORE GENERAL THAN      *\n*        CURRENTLY NEEDED, TO ALLOW FOR FUTURE NEW PARM OPTIONS.      *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nAPARMS   CSECT\n         $DBG  ,NO                 SHOW NO DEBUG CODE FROM $SAVE/RETURN\n         SPACE 1\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*         REGISTER USAGE AND CONVENTIONS IN APARMS CSECT              *\n*   R0,R1,R2 = TEMPORARY WORK REGISTERS                               *\n*   R3   ADDRESS OF CURRENT APCBLK WHEN LOOKING DOWN PARM LIST        *\n*   R4 = APCP$L = LENGTH OF 1 APCBLK.  USED AS INCREMENT IN BXLE'S.   *\n*   R5 = @ LAST APCBLK IN TABLE OR PART OF TABLE SEARCHED, BXLE LIMIT.*\n*   R6 = SCAN POINTER TO NEXT CHARACTER TO BE PROCESSED IN PARM FIELD *\n*   R7 = 1    CONSTANT FOR USE IN BXH'S AND  INCREMENTING,DECREMENTING*\n*   R8 = BASE REGISTER                                                *\n*   R9 = @ PARM FIELD ON INPUT.  USED AS BYTE REGISTER THEREAFTER.    *\n*   R10= LENGTH OF PARM FIELD ON INPUT. @ LAST BYTE OF PARM AS LIMIT @*\n*   R11= @ AJOBCON BLOCK, ON INPUT AND UNCHANGED                      *\n*   R12  (UNUSED)                                                     *\n*   R13= @ CALLING PROGRAM'S SAVE AREA, UNCHANGED                     *\n*   R14= INTERNAL LINK REGISTER, WORK REGISTER                        *\n*   R15= TEMPORARY WORK REGISTER                                      *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n         USING AJOBCON,R11         NOTE POINTER TO JOB TABLE\n         $SAVE RGS=(R14-R12),SA=NO,BR=R8\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                       INITIALIZATION SECTION                        *\n*              INITIALIZE FLAGS IN LEADING NIBBLES OF APCFLAG BYTES.  *\n*        CHECK TO SEE IF A PARM FIELD WAS USED. IF SO, MOVE IT OVER   *\n*        TO INTERNAL AREA, WITH BLANKS FOLLOWING, TO MAKE SCANNING    *\n*        EASIER AND USE LESS REGISTERS. SET UP FOR DOING ANALYSIS.    *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n         LA    R4,APC$L            FOR INCREMENT ON MANY BXLE'S\n         USING APCBLK,R3           NOTE USING, WILL USE R3 ALWAYS\n         SPACE 1\n*              ***** TEST FOR FLAG RESET REQUIRED. DO SO IF NEEDED ****\n         TM    AJOAPMOD,AJOAPRSE   WAS THIS CALL A RESET CALL\n         BZ    APNOTRSE            NO, SO SKIP RESET THIS TIME\n         LA    R3,APBPARMA         @ BEGINNING OF TABLE\n         LA    R5,APBPARMB-APC$L   @ LAST ELEMENT IN TABLE\n         SPACE 1\n         NI    APCLKSET,255-APCSET REMOVE ALL SET FLAGS\n         BXLE  R3,R4,*-4           LOOP THRU TABLE\n         SPACE 1\nAPNOTRSE EQU   *                   EXIT HERE IF NOT A RESET CALL\n         LA    R7,1                USEFUL CONSTANT\n         LR    R6,R10              MOVE LENGTH OF PARM OVER\n*              IF AJOAPMOV SET, LEAVE PARM WHERE IT IS (MUST BE LIMIT\n*              OR DEFAULT, WHICH HAVE BLANK AFTER PARM.)\n         TM    AJOAPMOD,AJOAPMOV   SHOULD IT BE MOVED\n         BO    *+12                YES, GO TO MOVE AND PAD CODE\n         LR    R6,R9               MOVE BEGINNING ADDRESS OVER TO INIT\n         AR    R10,R9              ADD BEGIN TO LENGTH GIVING END IN 10\n         B     APMINIT             SKIP OVER TO INIT CODE\n         MVC   AJOPARM,AJOBLANK+1  BLANK OUT ENTIRE PARM AREA\n         SR    R6,R7               DECREMENT FOR MVC,CHECK FOR SIGN\n         BM    APFINE              THERE WAS NO PARM FIELD,BRANCH\n         LA    R0,AJOP$L-1         LENGTH-1 OF MAXIMUM PARM FIELD\n         CR    R6,R0               IS LENGTH SMALL ENOUGH\n         BNH   *+6                 SKIP IF LEGAL\n         LR    R6,R0               TOO BIG,USE MAXIMUM\n         STC   R6,*+5              STORE THIS LENGTH INTO MVC\n         MVC   AJOPARM($),0(R9)    MOVE PARM FIELD OVER, R-PAD WITH BL\n         AIF   (NOT &$KP26).APNKP2T         SKIP IF NO 026 KEYPUNCH\n         STC   R6,*+5              PUT LENGTH INTO TR\n         TR    AJOPARM($),AJTRTB26 TRANSLATE SO WILL PRINT RIGHT\n.APNKP2T ANOP\n         LA    R10,AJOPARM(R6)     SET LIMIT @ FOR SCANNING\n         LA    R6,AJOPARM          INIT SCAN POINTER TO BEGINNING\nAPMINIT  EQU   *                   ENTRY TO BEGIN INIT FOR SCANNING\n         SR    R9,R9               CLEAR FOR USE AS BYTE REG AFTER NOW\n         MVC   APFLOCKT+1(1),AJOAPSET  MOVE INTO TM INSTR TO TEST LOCK\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                       PARAMETER FIELD SCAN SECTION                  *\n*              CHECK FOR PARM BEGINNING WITH 'NO', AND SET FLAGS IF   *\n*        FOUND.  SCAN FOR , = OR BLANK TERMINATING PARM, SAVING UP TO *\n*        FIVE CHARS OF PARM, RIGHT-PADDED WITH BLANKS, FOR LOOKUP.    *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nAPMSCAN  EQU   *                   BEGINNING OF SCAN FOR 1 PARM OPTION\n         CLI   0(R6),C' '          SEARCH FOR NONBLANK\n         BNE   *+8                 FOUND NONBLANK, EXIT LOOP\nAPMSCANX BXH   R6,R7,APFINC        BUMP SCAN PTR, GO TO CHECK FOR END\n         SPACE 1\n         SR    R2,R2               SHOW EXPECTED POSTIVE PARM\n         AIF   (&$DEBUG).APND1     SKIP IF PRODUCTION\n         XSNAP STORAGE=(*AJOPARMA,*AJIOFLAG),LABEL='APMSCAN',          X\n               IF=(AJODEBUG,O,1,TM)         SNAP IF DEBUG ON\n.APND1   ANOP\n         CLC   0(2,R6),=C'NO'      IS PARM PRECEDED BY NO\n         BNE   APMSCA              NO,SO SKIP,LEAVING R2 SET\n         LA    R2,2                SET TO SHOW NO VALUE\n         AR    R6,R2               ADD 2 TO SCAN PTR, BEYOND 'NO'\n         SPACE 1\n*              SEARCH FOR A POSSIBLE DELIMITER CHARACTRER (^ALPHABETIC)\nAPMSCA   EQU   *\n         LR    R15,R6              SAVE @ OF BEGINNING OF PARM\n         CLI   0(R6),C'A'          IS IT A DELIMITER\n         BL    *+8                 PROBABLY-BRANCH OUT\n         BXH   R6,R7,*-8           LOOP UNTIL FIND (NOT BLANKS END PRM)\n         SPACE 1\n         LR    R1,R6               @ DELIMITER\n         SR    R1,R15              R1 = LENGTH OF PARM\n         BNP   APMSCANX            EXTRA DELIMITER-GO TO IGNORE IT\n         SR    R1,R7               R1= LENGTH(PARM OPTION) - 1\n         LA    R0,APCP$L-1         MAXIMUM POSSIBLE LENGTH-1 OF PARM\n         CR    R1,R0               WAS PARM TOO LONG TO BE LEGAL ONE\n         BH    APMSCANX            YES, SO IGNORE IT\n*              **NOTE** COULD CHANGE ABOVE TO ALLOW TRUNC OF LONG PARMS\n         STC   R1,APMSCMVC+1       STORE LENGTH-1 INTO MVC\n         MVC   AJOCOMP,AJOBLANK    FILL PARM WITH BLANKS\nAPMSCMVC MVC   AJOCOMP($),0(R15)   MOVE OPTION IN, PAD WITH BLANKS\n         AR    R6,R7               POSITION SCAN PTR BEYOND DELIMITER\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                       PARAMETER LOOKUP AND FLAGGING                 *\n*        USING 1ST LETTER OF OPTION AS TABLE INDEX, SEARCH SECTION    *\n*        OF LOOKUP TABLE FOR IT. IF NOT FOUND, IGNORE IT. IF FOUND,   *\n*        USE BITS OF ITS APCFLAG TO DETERMINE HANDLING. IF THIS CALL  *\n*        ACTUALLY SETS A VARIABLE, OR INTO ITS APCFLAG BIT(S) SHOWING *\n*        WHAT TYPE CALL PRODUCED THIS VALUE, FOR LATER CHECKING.      *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n         CLI   AJOCOMP,C'Z'        MAKE SURE CHARACTER OK (NOT DIGIT)\n         BH    APFINC              BAD OPTION NAME-IGNORE IT\n         IC    R9,AJOCOMP          GET FIRST LETTER OF OPTION\n         LA    R5,B'00111100'      MASK FOR MIDDLE 4 BITS OF OPTION\n         NR    R9,R5               MASK OUT ALL BUT MIDDLE BITS\n         SRL   R9,1                SHIFT FOR HALFWORD INDEX VALUES\n         LA    R3,APBPARMA         BEGINNING OF TABLE @\n         AH    R3,APLNDX(R9)       = @ BEGINNING OF TABLE SECTION\n         LA    R5,APBPARMA-APC$L   @ BEGINNING - 1 ELEMENT LENGTH\n         AH    R5,APLNDX+2(R9)     = @ LAST POSSIBLE ELEMENT IN SECTION\n*              AT THIS PT, R3 IS INDEX, AND R5 LIMIT FOR ENSUING BXLE\n         SPACE 2\nAPLOOK   CLC   AJOCOMP,APCPARM     COMPARE NEW PARM WITH TABLE ENTRY\n         BE    APFOUND             SKIP OUT IF FOUND\n         BXLE  R3,R4,APLOOK        LOOP THRU TABLE\n         B     APFINC              FELL THRU, NOT IN TABLE, IGNORE IT\n         SPACE 1\nAPFOUND  EQU   *                   EXIT HERE WHEN PARM IDENTIFIED\n         AIF   (&$DEBUG).APND2     SKIP IF PRODUCTION\n         XSNAP LABEL='APFOUND',STORAGE=(*APCBLK,*APCBLK+8),            #\n               IF=(AJODEBUG,O,1,TM)         SNAP FOUND BLOCK,IF DEBUG\n.APND2   ANOP\nAPFLOCKT TM    APCFLAG,$           CAN THIS PARM BE SET BY CURRENT CALL\n         BNO   APFNOSET            NO,SO IGNORE HIM\n         IC    R9,APCAJOFS         GET OFFSET IN AJOBCON TO VARIABLE\n*              IF PARM=DECIMAL #, CONVERT THE VALUE INTO R0.\n         TM    APCFLAG,APCD        WAS THIS DECIMAL CONVERT\n         BZ    *+8                 NO, SKIP CONVERT\n         BAL   R14,APDECON         CALL ROUTINE TO SCAN, PUT VALU IN R0\n*              IF VALUE NOT SET PREVIOUSLY, SKIP TO TEST FOR TYPE\n         TM    APCLKSET,APCSET     HAS IT BEEN SET ALREADY BY ANYBODY\n         BZ    APFTYPE             NO, SO SAFE TO DO IT THIS TIME\n*              HAS ALREADY BEEN SET-CHECK IF CAN DO IT AGAIN.\n         TM    APCFLAG,APCNRSET    IS IT ALLOWED TO BE RESET\n         BO    APFNOSET            NOT ALLOWED TO RESET-SKIP OUT\n         TM    APCLKSET,APCSETU+APCSETP     WAS IT SET BY $JOB\n         BZ    APFDFSK             NO, SKIP CHECK FOR DEFAULT-OK TO SET\n         TM    AJOAPMOD,AJOAPDEF   IS THIS DEFAULT TYPE CALL\n         BO    APFNOSET            YES, JUMP OUT-DON'T OVERRIDE VALUE\nAPFDFSK  EQU   *\n*              IF PARM IS YES/NO TYPE, GO TO RESET ITS VALUE\n         TM    APCFLAG,APCYESNO    WAS IT YES/NO TYPE\n         BO    APFYESNO            YES, SO GO PROCESS IT\n         SPACE 1\n*              ***** PARM=VALUE PROCESSING *****\n         TM    APCFLAG,APCNINCR    SEE IF DECIMAL# AND CAN'T INCR\n         BZ    APFCALL             ALLOWABLE TO CHANGE-GO SEE IF CALL\n*              VARIABLE ALREADY SET AND NEW VALUE SUPPLIED.  VALUE\n*              CAN BE RESET IF IT IS LESS THAN OR EQUAL OLD ONE.\n         C     R0,AJO$APC(R9)      COMPARE (ASSUMES FULLWORD VALUE)\n         BH    APFNOSET            TOO HIGH-IGNORE HIM\n*              IF FLAGGED, CALL INDIVIDUAL PROCESSING ROUTINE.\n*              THIS TAKES CARE OF SPECIAL CASES.\nAPFCALL  TM    APCFLAG,APCCALL     DOES PARM REQUIRE CALL\n         BZ    APFSTORE            NO, SO JUST STORE VALUE(ASSUMED F)\n         IC    R2,APCADDR          GET OFFSET @ OF ROUTINE\n         LA    R14,APFSET          RETURN @ TO SHOW VALUE SET\n         B     APAJUMP(R2)         GO TO THE ROUTINE INDICATED\n*              **NOTE- ROUTINE WILL EXIT TO R14(SET) OR APFNOSET.\nAPFSTORE ST    R0,AJO$APC(R9)      STORE THE COMPUTED VALUE\n         B     APFSET              GO TO FLAG THAT VALUE HAS BEEN SET\n*              TYPE TEST - DEFINITELY LEGAL TO SET NEW VALUE.\nAPFTYPE  TM    APCFLAG,APCYESNO    WAS IT YES/NO TYPE PARM\n         BZ    APFCALL             NO WAS = PARM OR SPECIAL-GO DO IT\n*              ***** YES/NO PARM PROCESSING *****\n*              AT THIS POINT R2=0 => YES VALUE, R2=2 => NO VALUE.\n*              R9 = OFFSET FROM AJO$APC TO BYTE TO BE FLAGGED.\n*              DETERMINE POLARITY OF FLAG BYTE AND SET ACCORDINGLY.\nAPFYESNO TM    APCFLAG,APCYES1B    DOES A YES VALUE => A BIT ON\n         BO    *+6                 YES, SO LEAVE R2 AS IS/SKIP\n         AR    R2,R7               NO. YES VALUE=> BIT OFF-INCREM R2\n         LA    R14,AJO$APC(R9)     GET ACTUAL @ BYTE TO BE SET\n         OC    0(1,R14),APCBITS    SET BIT(S) DEFINITELY ON\n         IC    R2,APFYNTAB(R2)     GET THE BYTE FROM CONTROL TABLE\n         LTR   R2,R2               MUST WE NOW RESET GIVEN BIT TO 0\n         BNZ   *+10                NO, SKIP SINCE BIT SET TO 1 OK\n         XC    0(1,R14),APCBITS    YES, MUST TURN BIT OFF TO BE RIGHT\n         SPACE 1\n*              ***** COMMON PARM VALUE SETTING EXITS *****\nAPFSET   EQU   *                   VALUE WAS ACTUALLY SET THIS TIME\n         OC    APCLKSET,AJOAPSET   OR IN TO SHOW WHO ACTUALLY SET VALUE\nAPFNOSET EQU   *                   EXIT HERE IF NOT SET THIS TIME\nAPFINC   CR    R6,R10              HAVE WE REACHED END YET(R10=LIMIT @)\n         BL    APMSCAN             NO,RETURN FOR NEXT PARM\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                       COMPLETION SECTION                            *\n*        IF AJOAPMOD WAS FLAGGED WITH AJOAPFIN, THE CURRENT CALL TO   *\n*        APARMS IS THE LAST BEFORE ASSEMBLY BEGINS. ANY OPTION NEEDING*\n*        IT MAY THEN TEST THE SET BITS IN ITS APCFLAG TO DETERMINE    *\n*        WHERE THE PARM CAME FROM WHICH ACTUALLY SET ITS VALUE.       *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nAPFINE   EQU   *                   EXIT HERE AT END OF 1 COMPLETE SCAN\n         TM    AJOAPMOD,AJOAPFIN   WAS THIS LAST CALL\n         BZ    APNOTLST            NO, SO DON'T MAKE CHECKS\n         AIF   (&$TIMER LT 2).APFNNT        SKIP IF NOT SPECIAL TIMER\n         SPACE 1\n*              FLAG AJOAPMOD IF USER ACTUALLY SUPPLIED T=.  IF HE DID\n*              NOT, ASSIST WE USE TIMREM VALUE INSTEAD OF DEFAULT,\n*              THUS ALLOWING MORE PRECISE CONTROL OVER TIME.\n         TM    APBT+(APCLKSET-APCBLK),APCSETU+APCSETP VALUE FROM $J,PAR\n         BZ    *+8                 NO,DON'T SET THE FLAG\n         OI    AJOAPMOD,AJOAPUST   YES, USER ACTUALLY GAVE VALUE-NOTE\n         SPACE 1\n.APFNNT  AIF   (&$RECORD LT 2).APFNNR       SKIP IF NO SPECIAL RECORDS\n         SPACE 1\n*              FLAG AJOAPMOD IF USER ACTUALLY SUPPLIED R=. IF HE DID\n*              NOT, WILL USE $TIRC RECREM FOR PRECISE RECORD COUNT.\n         TM    APBR+(APCLKSET-APCBLK),APCSETU+APCSETP DID HE SET VALUE\n         BZ    *+8                 NO, SKIP OVER\n         OI    AJOAPMOD,AJOAPUSR   SHOW USER SET R= HIMSELF\n.APFNNR  ANOP\n         SPACE 2\n         AIF   (NOT &$ACCT).APNCOM1         SKIP IF NO ACCOUNT DISCRIM\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*              ACCOUNT NUMBER CHECKING                                *\n*        THE FOLLOWING CODE CAN BE USED TO SET DIFFERENT OPTIONS      *\n*   DEPENDING ON THE ACCOUNT NUMBER OF THE JOB.  AS OF 03/01/71,      *\n*   THE ONLY DISCRIMINATION PRESENT IS TO REQUIRE COMMENT CHECKING    *\n*   CERTAIN ACCOUNTS, I.E., INTRODUCTORY COURSES.                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n         $TIRC (NAME,AJOACCT)      GET ACCOUNTING INFO\n         LA    R0,L'AJOACCT        INCREMENT FOR BXLE\n         LA    R1,APXCOMLB         @ LAST ENTRY IN TABLE FOR LIMIT BXLE\n         LA    R2,APXCOMLA         START OF ACCT# TABLE FOR INDEX BXLE\n         SPACE 1\n*              SEARCH TABLE FOR ACCOUNT NUMBER.\n         CLC   AJOACCT,0(R2)       IS THIS THE ONE\n         BE    APXCOMFN            YES, JUMP OUT OF LOOP\n         BXLE  R2,R0,*-10          LOOP UNTIL END OF TABLE\n         B     APXCOMXT            NOT FOUND - IGNORE IT\nAPXCOMFN OI    AJOASMF2,AJOCOMNT   COMMENT CHECKING NOW IN EFFECT\n         SPACE 1\nAPXCOMXT EQU   *                   EXIT POINT FROM ACCT# CHECKING\n*              CHECK FOR CERTAIN NAME TO ALLOW SPECIAL DEBUGGING.\n         AIF   (NOT &$JRM).APNCOM1 SKIP IF NOT ANY SPECIAL JRM CODE\n         CLC   =C'MASHEY J ',AJOPRGNM       CHECK FOR NAME, SPECIAL OPT\n         BNE   APNOTJRM            NO, NOT NAME, SO SKIP\n         CLC   AJOACCT,APACCJRM    IS ACCOUNT CURRENT ONE\n         BNE   APNOTJRM            NO, IT ISN'T, SKIP\n         OI    AJODMPF,$EC$JRM     SET FLAG TO MAKE EXECUT DO EXTRA\nAPNOTJRM EQU   *                   SKIP HERE IF NOT SPECIAL DEBUG\n.APNCOM1 ANOP\nAPNOTLST EQU   *                   EXIT HERE UNLESS LAST CALL TO AP\nAPRET    $RETURN RGS=(R14-R12),SA=NO\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> INSUB: APDECON    CONVERT DECIMAL PARM VALUE                     *\n*        ENTRY CONDITIONS                                             *\n*   R6 = SCAN PTR TO 1ST CHARACTER OF DECIMAL #                       *\n*   R14= RETURN @ TO CALLING SECTION OF APARMS                        *\n*        EXIT CONDITIONS                                              *\n*   R0 = CONVERTED RESULT OF DECIMAL #, =0 IF THERE WERE NO NUMBERS   *\n*   R6 = SCAN POINTER TO 1ST NON-DECIMAL DIGIT FOUND                  *\n*        THIS ROUTINE MODIFIES REGS R0,R1,R6                          *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nAPDECON  LR    R1,R6               SAVE INIT SCAN POINTER\n         SR    R0,R0               SET DEFAULT AMOUNT\n         XDECI R0,0(R6)            SCAN AND CONVERT VALUE\n         LR    R6,R1               MOVE SCAN PTR @ OVER INTO PTR REG\n         BR    R14                 RETURN TO CALLING SECTION OF CODE\n         EJECT\n* * * * * INDIVIDUAL PARAMETER FIELD ANALYSIS SECTIONS.               *\n*        ALL LABELS ARE OF FORM APA$$$$$ WHERE $$$$$ IS PARAMETER NAME*\nAPAJUMP  EQU   *                   BASE @ FOR PARM ROUTINES\n         SPACE 3\n*              PARM=VALUE TYPE PARAMETERS                             *\n         SPACE 1\n         AIF   (NOT &$ACCT).APNACCT         SKIP IF NO ACCT DISCRIMINAT\nAPAACCT  BR    R14                 ACCT NUMBER OPTION *****FUTURE USE**\n.APNACCT ANOP\n         SPACE 1\nAPADUMP  MVI   AJODMPF,$ECREGS+$ECDINST+$ECSTORG DEFAULT DUMP FLAGS\n         LTR   R0,R0               WAS VALUE 0 (LEAVE DEFAULT OK)\n         BCR   Z,R14               YES, SO LEAVE FLAG THERE\n         NI    AJODMPF,255-$ECSTORG         JUST SMALL DUMP,REMV FLAG\n         BR    R14                 RETURN\n         SPACE 1\n         AIF   (&$DEBUG).APNDEBG   SKIP IF DEBUG NOT MODE\nAPADEBUG STC   R0,AJODEBUG         STORE VALUE IN DEBUG FLAG\n         BR    R14                 RETURN\n         SPACE 1\n.APNDEBG ANOP\n         SPACE 2\n         AIF   (NOT &$MACROS).APNMAC        SKIP IF NO MACRO STUFF\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*              *** SCANNING CODE FOR MACRO=  PARM.                    *\n*        POSSIBLE OPTIONS ARE AS FOLLOWS:                             *\n*        MACRO=N                   NO MACROS (ASSUMED IF IN ERROR)    *\n*        MACRO=F                   F-LEVEL MACRO (BASIC REQUEST)      *\n*        MACRO=G                   ADD G-LEVEL FEATURES               *\n*        MACRO=H                   ADD H-LEVEL FEATURES               *\n*        **NOTE** THE BASIC FACILITY IS THE F-LEVEL COMPATIBLE ONE.   *\n*        SOME OF THESE OPTIONS MAY NOT BE SUPPORTED, AND IN ANY CASE, *\n*        CODE FOR THEM IS ALL CONDITIONAL.                            *\n*        SEE SET VARIABLES BEGINNING &$MACRO- .                       *\n*        ** SETS BITS IN AJOASMFM, SEE FLAGS AT BEGINNING OF AJOBCON. *\n         SPACE 1\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nAPAMACRO EQU   *                   CODE FOR MACRO=\n*              FOLLOWING STMT MAKES ASSUMPTION OF  MACRO=N.\n         NI    AJOASMFM,(255-AJOMACRO-AJOMACRG-AJOMACRH) SET MACRO=N\n         SR    R2,R2               CLEAR, WILL BE INDEX TO TABLE\n         CLI   0(R6),C'F'          WAS IT MACRO=F\n         BE    APAMACR1            YES, SKIP, LEAVE R2=0\n         AR    R2,R7               SET R2=1\n         CLI   0(R6),C'G'          WAS IT G\n         BE    APAMACR1            YES, BRANCH, LEAVE R2=1\n         AR    R2,R7               SET R2=2\n         CLI   0(R6),C'H'          WAS IT MACRO = H\n         BNE   APAMACRZ            NO, MUST BE MACRO=N, OR ERROR-SKIP\nAPAMACR1 LA    R2,APAMACRT(R2)     GET @ FLAG BYTE FOR ACTUAL LEVEL\n         OC    AJOASMFM(1),0(R2)   OR APPRORPIATE BITS INTO FLAG\nAPAMACRZ BXH   R6,R7,APFSET        BUMPSCAN PTR, GO TO SHOW SET\n*              AJOASMFM FLAG BYTES FOR MACRO= F, G, H .\nAPAMACRT DC    AL1(AJOMACRO,AJOMACRO+AJOMACRG,AJOMACRO+AJOMACRH,0)\n         DS    0H                  MUST BE HALF ALIGNED (NOTE 0 ABOVE)\n.APNMAC  ANOP\n         SPACE 1\n         AIF   (NOT &$KP26).APKP29X         SKIP IF NO 026 KEYPUNCH\nAPAKP    EQU   *                   KP=26 OR KP=29.  29 DEFAULT\n*              ANYTHING BUT KP=26 TREATED AS KP=29.\n         NI    AJIOSO,255-AJIOKP26 RESET TO DEFAULT KP=029\n         LA    R1,26               VALUE FOR COMPARE\n         CR    R0,R1               WAS KP=26 SPECIFIED\n         BCR   NE,R14              NO, VALUE SET RIGHT, RETURN\n         OI    AJIOSO,AJIOKP26     SHOW 026 KEYPUNCH\n         BR    R14                 RETURN, GO TO APFSET\n.APKP29X ANOP\n         SPACE 1\n         AIF   (&$TIMER EQ 0).APNOT         SKIP IF NO TIMING\n*              ***** SCANNING/CONVERSION FOR T=, TD=, TX= *****       *\n*              THE FOLLOWING CODE ALLOWS THESE PARMS TO SPECIFY       *\n*        FRACTIONAL PARTS OF A SECOND.  IT SCANS THE FRACTIONAL PART  *\n*        IF ANY AND CONVERTS THE VALUE INTO TIMER UNITS (26.04 MICSEC *\n*        AND STORES IT IN APPROPRIATE LOCATION.  IT ACCEPTS UP TO 3   *\n*        FRACTIONAL DIGITS (I.E., MILLISECONDS).                      *\n         SPACE 1\nAPAT     EQU   *\nAPATD    EQU   *\nAPATX    EQU   *\n         LR    R1,R0               MOVE # SECONDS ON PARM OVER\n         M     R0,AJ1000           *1000 = # MILLISECONDS\n         CLI   0(R6),C'.'          DID HE SPECIFY FRACTION\n         BNE   APTINT              NO,JUST INTERGER-SKIP\n         LR    R2,R1               MOVE MILLISEC # OVER FOR SAFETY\n         AR    R6,R7               BUMP SCAN PTR BEYOND .\n         LR    R5,R6               SAVE @ 1ST FRAFTION DIGIT\n         BAL   R14,APDECON         CALL CONVERTER FOR SCANNING\n         SR    R5,R6               GET # DIGITS\n         AH    R5,=H'4'            ADD LIMIT+1 TO GET 3-1 OF MULTS\n         BNP   APTIGNOR            IF MORE THAN 3 DIGITS-IGNORE IT\n         SPACE 1\n         LR    R1,R0               MOVE VALUE OF FRACTION\n         LA    R15,10              VALUE FOR MULTIPLY\n         BAL   R14,*+6             SET REG,SKIP OVER MULT & INTO LOOP\n         MR    R0,R15              CONVERT*10\n         BCTR  R5,R14              LOOP.    END WITH # MILLISEC IN R1\n         AR    R2,R1               ADD TO PREVIOUSLY SAVED # MILLISEC\nAPTIGNOR LR    R1,R2               MOVE VALUE BACK TO R1\n         SPACE 1\n*              AT THIS PT, R1=# MILLISECONDS SPECIFIED\nAPTINT   EQU   *\n         M     R0,AJ100000         GET 100*# MICROSECONDS\n         D     R0,AJ2604           / BY 100# MICRO SEC IN A TIMER UNIT\n*              AT THIS PT R1 = # TIMER UNITS IN INTERVAL\n         LR    R0,R1               MOVE OVER FOR LATER STORE\n         TM    APCLKSET,APCSET     HAS IT BEEN SET BY ANYONE\n         BZ    APFSTORE            NO, DEFINITELY SAFE TO STORE-GO\n         TM    APCLKSET,APCSETU+APCSETP     SET BY USER\n         BZ    *+12                NO, SKIP DEFAUL TEST\n         TM    AJOAPMOD,AJOAPDEF   IS IT DEFAUL T CALL\n         BO    APFNOSET            YES, ALREADY SET-DON'T OVERRRIDE\n         SPACE 1\n         C     R0,AJO$APC(R9)      COMPARE TO PREVIOUS VALUE\n         BH    APFNOSET            TOO-HIGH-IGNORE HIM\n         B     APFSTORE            OK-GOTO STORE VALUE\n.APNOT   ANOP\n           AIF   (NOT &$XREF).NOXREF5                                 A\n        SPACE 3\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n* THIS ROUTINE IS THE CROSS REFERENCE OPTION SCANNING ROUTINE         *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nAPAXREF  EQU   *\n         IC    R0,AJOXREF         GET FLAG IN                         A\n         LR    R2,R0              MOVE FLAG TO R0,R1,R2               A\n         LR    R1,R2\n         N     R0,APXRB3          GET RIGHT BITS SET                  A\n         N     R1,APXRB2\n         N     R2,APXRB1                                              A\n         LR    R12,R6             GET POINTER TO PARM FIELD           A\n         CLI   0(R12),C'('        SEE IF LIST OF VALUES               A\n         BNE   APXRXRO            PROCESS FIRST ONLY                  A\n         AR    R12,R7             BUMP PAST \"(\"                       A\n         CNOP  0,4                MAKE SURE OF PROPER ALIGNMENT       A\n         BAL   R14,APXRCHK        CHECK FOR PROPER DELIMETER          A\n         DC    A(APXRSD)          WHERE TO GO IF OMITTED              A\n         BAL   R14,APXRSET        SET  VALUE INTO PROPER REGISTER     A\n         SLL   R15,4              MOVE TO RIGHT POSITION              A\n         LR    R0,R15             MOVE TO CORRECT REGISTER\n         AR    R12,R7             BUMP TO NEXT CHARACTER              A\nAPXRSD   EQU   *                  CHECK FOR VALUES IN SD=\n         AR    R12,R7             BUMP PAST VALUE                     A\n         CNOP  0,4                MAKE SURE OF ALIGNMENT              A\n         BAL   R14,APXRCHK        CHECK PROPER DELIMITER              A\n         DC    A(APXRSR)          ADDRESS TO GO TO IF USING DEFAULTS\n         BAL   R14,APXRSET        SET CORRECT VALUE                   A\n         SLL   R15,2              MOVE TO CORRECT POSITION            A\n         LR    R1,R15             MOVE TO RIGHT REG                   A\n         AR    R12,R7             BUMP TO NEXT CHARACTER              A\nAPXRSR   EQU   *                  DO SR= DEFAULT                      A\n         AR    R12,R7             BUMP POINTER                        A\n         CLI   0(R12),C')'        WAS IT OMITTED                      A\n         BE    APXRADD            YES, DO ADD                         A\n         CLI   1(R12),C')'        PROPER DELIMITER                    A\n         BNE   APXRFIN            NO, BAG IT                          A\n         BAL   R14,APXRSET        GET NUMBER IN REG                   A\n         LR    R2,R15             MOVE TO RIGHT REG                   A\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n* THIS SECTION ADDS THE REGISTERS R0,R1,R2.  THESE REGISTERS HAVE THE *\n* CORRECT VALUES IN THEM EITHER BY THE DEFAULT VALUES OR BY SETTING   *\n* A FLAG WITH THE XREF= OPTION.                                       *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nAPXRADD  EQU   *                                                      A\n         AR    R1,R0              COLLECT XREF AND SD VALUES          A\n         AR    R2,R1              COLLECT ALL                         A\n         STC   R2,AJOXREF         SET ACTUAL FLAG                     A\nAPXRRET  EQU   *                                                      A\n         LA    R6,1(R12)          SET PROPER DELIMITER                A\n         B     APFSET             SHOW VALUE SET                      A\nAPXRXRO  BAL   R14,APXRSET        GET NUMBER                          A\n         SLL   R15,4              MOVE TO RIGHT POSITION              A\n         LR    R0,R15             MOVE TO RIGHT REGS                  A\n         B     APXRADD            SET ACTUAL XREF FLAG                A\n         SPACE 2\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*-->INSUB: APXRSET   CONVERT NUMBER TO INTERNAL FORM                  *\n*     CONVERTS XREF PARM NUMBERS AND CHECKS TO SEE IF THEY'RE IN THE  *\n*     RANGE 0-3.                                                      *\n*     ENTRY CONDITIONS                                                *\n*   R12= POINTER TO NUMBER TO BE CONVERTED                            *\n*     EXIT CONDITIONS                                                 *\n*   R15= CONVERTED NUMBER                                             *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nAPXRSET  EQU   *                  INSUB TO SET VALUE IN REGISTER 15   A\n         MVC   APXRWORK+7(1),0(R12)    MOVE NUMBER TO WORK AREA       A\n         PACK  APXRWORK(8),APXRWORK                                   A\n         CVB   R15,APXRWORK       CONVERT NUMBER TO INTERNAL FORM     A\n         C     R15,=X'00000003'   SEE IF TOO BIG                      A\n         BH    APXRFIN            DENOTE ERROR                        A\n         BR    R14                RETURN                              A\n         SPACE 2\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*-->INSUB: APXRCHK   CKECK FOR VALID DELIMITER                        *\n*     CHECKS FOR ',' IN XREF=(A,B,C) PARM FIELD.  SPECIAL RETURN      *\n*     FOR XREF=(A).                                                   *\n*     ENTRY CONDITIONS                                                *\n*   R12= POINTER OF NEXT CHARACTER                                    *\n*     EXIT CONDITIONS                                                 *\n*   R14= @ OF ROUTINE TO BRANCH TO                                    *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nAPXRCHK  EQU   *                                                      A\n         CLI   0(R12),C','        WAS NEXT OPERAND OMITTED?           A\n         BE    APXRNXT            YES: DO NEXT SECTION\n         CLI   1(R12),C','        PROPER DELIMITER?                   A\n         BNE   APXRFIN            NO: GO TO ERROR                     A\n         B     4(R14) GO BAVK                                         A\nAPXRNXT  L     R14,0(R14)         GET ADDRESS\n         BR    R14                GO TO ROUTINE\nAPXRFIN  EQU   *\n         LR    R6,R12             GET @ BACK IN R6\n         B     APFNOSET           ERROR FOUND: SHOW NOT SET           A\nAPXRB1   DC    A(3)               MASK OUT ALL BUT LOWER BITS         A\nAPXRB2   DC    A(12)              MIDDLE BITS                         A\nAPXRB3   DC    A(48)              TOP BITS                            A\nAPXRWORK DC    D'0'               WORK AREA                           A\n.NOXREF5 ANOP\n*              TABLE OF APCBLKS FOR PARM FIELD ANALYSIS               *\nAPBPARMA DS    0D                  DEFINE BEGINNING SYMBOL, ALIGN\nAPLAC    EQU   *                   PARMS A-C\n         APCGN ACCT,AJOACCT,0,C=1,G=&$ACCT\n         AIF   (&$S370 NE 2).APNALGN    SKIP IF NO S/370 SIMULATION\n         APCGN ALGN,AJOEXEF,AJONALGN,Y=1\n.APNALGN ANOP\n         APCGN BATCH,AJOMODE,AJOBATCH,I1=1,Y=1,LK=110\n         APCGN CMPRS,AJOASMF2,AJOCMPRS,I1=1,Y=1,G=&$CMPRS\n         APCGN COMNT,AJOASMF2,AJOCOMNT,I1=1,Y=1,G=&$COMNT,LK=110\n         APCGN CPAGE,AJIOPR,AJIOPAGE,I1=1,Y=1,G=&$PAGE,LK=110\nAPLDG    EQU   *                   PARMS D-G\n         APCGN DATA,AJIORE,AJIODFLT,Y=1,G=&$DATARD,LK=110\n         APCGN DEBUG,AJODEBUG,C=1,D=1,G=&$DEBUG,GC=1\n         APCGN DECK,AJOASMF2,AJODECK,Y=1,I1=1,G=&$DECK\n         APCGN DISKU,AJOASMF,AJODISKU,G=&$DISKU,Y=1,I1=1\n         APCGN DUMP,AJODMPF,C=1,D=1\n         APCGN FREE,AJOFREE,0,D=1,LK=110\nAPLHI    EQU   *                   PARMS H-I\n         APCGN I,AJOINSL,0,D=1,I1=1\n         APCGN IECF,AJOIECF,0,D=1,G=&$EXINT   IECF OF EXT'D INTPRTR\nAPLJL    EQU   *                   PARMS J-L, GAP\n         APCGN KP,AJIOSO,C=1,D=1,G=&$KP26\n         APCGN L,AJOL,0,D=1,I1=1,G=&$PAGE\n         APCGN LIBMC,AJOASMFM,AJOLIBMC,I1=1,Y=1,G=&$MACROS  PRT LIB MCS\n         APCGN LIST,AJOASMF,AJNLIST,Y=1\n         APCGN LOAD,AJOASMF,AJNLOAD,Y=1\nAPLMP    EQU   *                   PARMS M-P\n         APCGN MACRO,AJOASMFM,C=1,G=&$MACROS          MACRO LEVEL\n         APCGN MACTR,AJOMACTR,0,D=1,G=&$MACROS        MACRO ACTR\n         APCGN MNEST,AJOMNEST,0,D=1,G=&$MACROS        MACRO NEST LIMIT\n         APCGN MSTMG,AJOMSTMG,0,D=1,G=&$MACROS        MACRO STMT LIMIT\n         APCGN MONIT,AJOMODE,AJOMONIT,I1=1,Y=1,LK=110\n         APCGN NERR,AJONERRF,0,D=1\n         APCGN OBJIN,AJODECKF,AJOOBJIN,Y=1,I1=1,G=&$OBJIN\n         APCGN P,AJOP,0,D=1,I1=1,G=&$PAGE\nAPBPD    APCGN PD,AJOPD,0,D=1,I1=1,G=&$PAGE\n         APCGN PUNCH,AJIOPN,AJIODFLT,Y=1,G=&$PUNCH,LK=110\nAPBPX    APCGN PX,AJOPX,0,D=1,I1=1,G=&$PAGE\nAPLQR    EQU   *                   PARMS Q-R, GAP\nAPBR     APCGN R,AJORECL,0,D=1,I1=1\nAPBRD    APCGN RD,AJORD,0,D=1,I1=1\n         APCGN RELOC,AJOASMF,AJORELOC,I1=1,Y=1,G=&$RELOC\n         APCGN REPL,AJOMODE,AJOREPLF,I1=1,Y=1,G=&$REPL\n         APCGN RFLAG,AJORFLAF,0,D=1,G=&$REPL\nAPBRX    APCGN RX,AJORX,0,D=1,I1=1\nAPLST    EQU   *                   PARMS S-T\n         APCGN SS,AJIOSS,AJIOSING,I1=1,Y=1,G=&$PAGE\n         APCGN SSD,AJIOSSD,AJIOSING,I1=1,Y=1,G=&$PAGE\n         APCGN SSX,AJIOSSX,AJIOSING,I1=1,Y=1,G=&$PAGE\n         APCGN SUPER,AJOEXEF,AJOSUPER,I1=1,Y=1,G=&$PRIVOP\n         APCGN SYSIN,AJOMODE,AJNSYSIN,Y=1,G=&$DATARD,LK=110\nAPBT     APCGN T,AJOTIML,D=1,I1=1,G=&$TIMER,C=1\n         APCGN TD,AJOTD,D=1,I1=1,G=&$TIMER,C=1\nAPBTX    APCGN TX,AJOTX,D=1,I1=1,G=&$TIMER,C=1\nAPLUX    EQU   *                   PARMS U-X\n         APCGN XREF,AJOXREF,C=1,G=&$XREF                              A\nAPLYZ    EQU   *                   PARMS Y-Z\nAPBPARMB EQU   *                   LIMIT OF APCGN'D TABLE\n         SPACE 2\n*              PARM TABLE LOOKUP INDEX - APLNDX\n*              GIVES OFFSETS TO BEGINNING OF EACH SECTION OF TABLE,\n*              DETERMINED BY INITIAL LETTER\n*              DETERMINED BY MIDDLE 4 BITS OF 1ST BYTE OF OPTION NAME.\nAPLNDX   $AL2  APBPARMA,(APLAC,APLDG,APLHI,APLJL,APLJL,APLMP,APLQR,    #\n               APLST,APLST,APLUX,APLYZ,APBPARMB)\n         AIF   (NOT &$ACCT).APNCOM2         SKIP IF NO ACCT# CHECKING\n         SPACE 1\n*              TABLE OF ACCOUNT NUMBERS RECEIVING SPECIAL TREATMENT.\nAPXCOMLA EQU   *                   BEGINNING OF TABLE\n         DC    5CL5'ACCT#'         DUMMIES, TO BE FIXED IN OBJ DECK\nAPACCJRM DC    C'C3338'            CURRENT ACCT# FOR TESTING PURPOSES\nAPXCOMLB EQU   *-L'AJOACCT         @ LAST 1 IN TABLE\n         SPACE 1\n.APNCOM2 ANOP\n         SPACE 1\n*              TABLE TO DETERMINE WHETHER YES/NO PARM SHOULD HAVE ITS\n*              VARIABLE BYTE BITS SET TO 1'S OR 0'S.\nAPFYNTAB DS    0BL4                YES/NO BIT SETTING CONTROL TABLE\n         DC    B'1'                YES PARM,YES1B ==> BIT = 1\n         DC    B'0'                YES PARM, ^YES1B ==> BIT  = 0\n         DC    B'0'                NO PARM, YES1B ==> BIT = 0\n         DC    B'1'                NO PARM, ^YES1B ==> BIT = 1\n         LTORG\n         DROP  R3,R8,R11           KILL ALL USINGS\n         AIF   (NOT (&$DECK OR &$OBJIN)).AOBNONE      SKIP IF NO DECKS\n         TITLE 'AOBJCARD DSECT : OBJECT DECK CARDIMAGE'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> DSECT: AOBJCARD   IMAGE OF OBJECT DECK CARD                      *\n*        THIS DSECT DESCRIBES 1 CARD OF AN ASSIST OBJECT DECK.  THE   *\n*   DECK FORMAT IS COMPATIBLE WITH NORMAL S/360 OBJECT DECKS, SO THAT *\n*   THEY CAN BE USED UNDER SOME CIRCUMSTANCES.    THEY ARE HOWEVER    *\n*   SIMPLER, IN ORDER TO ALLOW FOR PRODUCTION OF THEM FROM STUDENT-   *\n*   COMPILERS, I.E. XPL.  LATER VERSIONS OF THE LOADER MAY PERMIT     *\n*   MORE COMPLEX OBJECT DECKS, BUT AS OF 9/01/71, THE ONLY TYPES OF   *\n*   OBJECT DECK CARDS RECOGNIZED ARE TXT AND END CARDS.               *\n*        NAMES: AO------                                              *\n*        REFERENCE: ASSEMBLER(F) PROGRAMMER'S GUIDE - GC26-3756-4     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nAOBJCARD DSECT\n         SPACE 1\n*              ***** COMMON BASE BEGINNING *****\n         DS    X'02'               1     (S/360) - ASSIST IGNORES\nAOBJTYPE DS    CL3                 2-4   TYPE OF CARD\n         SPACE 1\n*              ***** ESD CARD LAYOUT *****\n********************    NOT CURRENTLY IMPLEMENTED   *******************\n         SPACE 1\n*              ***** TXT CARD LAYOUT *****\n         ORG   AOBJTYPE            BACK UP TO SHOW LAYOUT\n         DS    CL3'TXT'            2-4   TEXT CARD IDENTIFIACTION\nAOTADDR  DS    0A,C' '             5     ASSIST IGNORES 1ST BYTE\nAOTADDRT DS    AL3                 6-8   @ WHERE OBJECT CODE GOES\n         DS    CL2' '              9-10  ASSIST IGNORES THESE COLS\nAOTLENG  DS    0H,C                11-12 LENGTH OF CODE ON CARD\nAOTLENG2 DS    AL1                 12    LENGTH USED BY ASSIST 0-56\n         DS    CL4' '              13-16 IGNORED *****FUTURE USE ******\nAOTCODE  DS    CL56                17-72 OBJECT CODE 0-56 BYTES OF IT\nAOTSEQN  DS    CL8                 73-78 SEQUENCE NUMBER, IGNORED\n         SPACE 1\n*              ***** RLD CARD LAYOUT *****\n********************    NOT CURRENTLY IMPLEMENTED   *******************\n         SPACE 1\n*              ***** END CARD LAYOUT *****\n         ORG   AOBJTYPE            BACK TO SHOW TYPE\n         DS    CL3'END'            2-4   END CARD FLAG\nAOEBLNK  EQU   *                   BEGINNING OF BLANK AREA\nAOENTRY  DS    0A,C' '             5     ASSIST IGNORES LEADING BLANK\nAOENTRY2 DS    AL3                 6-8   GIVES ENTRY @, UNLESS BLANK\nAOEBLNKL EQU   72-(*-AOBJCARD)     LENGTH TO BE BLANKED\n         TITLE 'AOBJDK CSECT - OBJECT DECK PUNCH/LOAD'\nAOBJDK   CSECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> CSECT: AOBJDK     OBJECT DECK HANDLING MODULE                    *\n*                                  JOHN R. MASHEY - 09/01/71          *\n*        THE TWO ENTRIES OF AOBJDK ARE USED TO LOAD OR PUNCH OBJECT   *\n*   DECKS WHICH ARE SUBSETS OF NORMAL S/360 DECKS.   THE TWO ENTRIES  *\n*   MAY OR MAY NOT EXIST, DEPENDING ON FLAGS &$DECK AND &$OBJIN.      *\n*        USES DSECTS: AOBJCARD,AVWXTABL                               *\n*        USES MACROS: $RETURN,$SAVE                                   *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         $DBG  ,NO                 NO DEBUG IN $SAVE,$RETURN\n         EJECT\n         AIF   (NOT &$OBJIN).AOBJN1         SKIP IF NO OBJECT INPUT\n         ENTRY AOBJIN\nAOBJIN   $SAVE RGS=(R14-R12),SA=NO,BR=R6\n         USING AVWXTABL,RAT        NOTE ASSEMBLER CONTROL TABLE\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> ENTRY: AOBJIN     LOAD OBJECT DECK                               *\n*        ENTRY CONDITIONS                                             *\n*   R12(RAT) = @ ASSEMBLER CONTROL TABLE (AVWXTABL).                  *\n*        EXIT CONDITIONS                                              *\n*   AVRADL,AVRADH,AVRELOC,AVFENTER,AVLOCLOW,AVLOCHIH  ARE SET UP      *\n*   AS THEY WOULD HAVE BEEN HAD THE PROGRAM BEEN ASSEMBLED.           *\n*   AVTAGS1    IS FLAGGED WITH AJNLOAD IF SOME ERROR OCCURRED.        *\n*        NAMES: AOB-----                                              *\n*        USES MACROS: $PRNT,$RETURN,$SAVE,$SORC,XSNAP                 *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n* * * * * * * * REGISTER USAGE FOR AOBJIN * * * * * * * * * * * * * * *\n*   R0,R1      WORK REGISTERS.  R1 USED FOR ADDRESS CALCULATIONS.     *\n*   R2 = LOWEST REAL @ LOADED CODE. INIT=AVADDLOW. INTO AVRADL.       *\n*   R3 = @+1 OF HIGHEST LOADED CODE. INIT=AVADDLOW.  INTO AVRADH.     *\n*   R4 = LOAD RELOCATION FACTOR. = AVADDLOW - (1ST TXT @ FOUND).      *\n*   R5 = USER ENTRYPOINT @ (FAKE).  TO BE STORED INTO AVFENTER.       *\n*   R6 = BASE REGISTER                                                *\n*   R7 = ADDRESS OF OBJECT CARD IMAGE (AOBJCARD DSECT).               *\n*   R8 = BYTE REGISTER (USED FOR INSERT OF LENGTH FROM AOTLENG2)      *\n*   R9 = @+1 OF HIGHEST USABLE BYTE FOR PROGRAM.  = AVADDHIH.         *\n*   R10,R11    UNUSED                                                 *\n*   R12(RAT)= @ AVWXTABL CONTROL BLOCK                                *\n*   R13= @ CALLING PROGRAM'S SAVE AREA.                               *\n*   R14= INTERNAL LINK REGISTER, WORK REGISTER.                       *\n*   R15= WORK REGISTER                                                *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*              OBJECT LOAD INITIALIZATION.                            *\n*        1. FILL OBJECT AREA (AVADDLOW-AVADDHIH) WITH FILL CHARS.     *\n*        2. SET UP INITIAL VALUES FOR @'S IN REGISTERS.               *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         LM    R8,R9,AVADDLOW      AVADDLOW-AVADDHIH - CORE LIMITS\n         LA    R7,31(,R8)          * ALIGN ACTUAL BEGINNING @\n         SRL   R7,5                * TO MULTIPLE OF 32.\n         SLL   R7,5                * THIS IS REQUIRED BY XXXXSNAP\n         ST    R7,AVADDLOW         * STORE ALIGNED VALUE BACK\n         LA    R8,32               # BYTES TO BE FILLED WITH 1 STM\n         SR    R9,R8               SUBTRACT 32 FOR BXLE USE\n         SR    R9,R8               -32 MORE FOR COMPLETE SAFETY\n         BXH   R7,R8,AOBINTA       MAKE SURE AT LEAST 32 BYTES\n         SPACE 1\n         SR    R7,R8               BACK UP TO  BEGINNING FOR SAFETY\n         MVI   0(R7),$PRGFILC      PUT IN FILL CHARACTER\n         MVC   1(31,R7),0(R7)      PROPAGATE FILL CHARACTER\n         LM    R14,R5,0(R7)        GET 8 REGS WORTH OF FILL CHARACTER\n         SPACE 1\n         STM   R14,R5,0(R7)        STORE 32 BYTES OF FILL CHARACTER\n         BXLE  R7,R8,*-4           LOOP TO FILL WHOLE AREA\n         SPACE 1\nAOBINTA  LM    R8,R9,AVADDLOW      AVADDLOW-AVADDHIH - LIMIT @'S\n         LR    R2,R8               R2= INIT VALUE LOWEST REAL(AVRADL)\n         LR    R3,R2               R3= INIT VALUE HIGHEST LIMIT(RADH)\n         SR    R5,R5               INIT ENTRY @ TO 0 (BEGINNING OF CD)\n         NI    AVTAGS1,255-AVOENTR-AVO1TXT  SHOW NO TXT, ENTRY @ FOUND\n         LA    R7,AVCONCAT         USE THIS AS WORKAREA FOR AOBJCARD\n         USING AOBJCARD,R7         NOTE DSECT\n         SR    R8,R8               CLEAR R8 AS BYTE REGISTER FOR INSERT\n         SPACE 1\n*              PRINT HEADER MESSAGE AL000.\n         BAL   R14,AOBHEXCO        CONVERT VALUES TO HEX FOR PRINT\n         DC    H'2'                # ITEMS IN FOLLOWING LIST\n         DC    AL2(AVADDLOW-AVWXTABL,AOB000A-AOB)     REAL @ START\n         DC    AL2(AVADDHIH-AVWXTABL,AOB000B-AOB)     REAL LIMIT\n         BAL   R14,AOBPRINT        GO PRINT COMPLETED MESSAGE\n         DC    AL2(AOB000-AOB,AOB000L)      @ OFFSET, LENGTH\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*              READ OBJECT DECK AND LOAD LOOP HEAD                    *\n*        READ 1 CARD OF OBJECT DECK, UNTIL EOF FOUND. DETERMINE TYPE  *\n*   OF CARD, BRANCH TO PROCESSING SECTION, RETURN FOR NEXT CARD.      *\n*   **NOTE** AS OF 9/01/71, WILL PROCESS ONLY TXT AND END CARDS, THUS *\n*   SECTIONS OF CODE COMMENTED OUT ARE TO INDICATE POSSIBLE EXTENSIONS*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nAOBREAD  EQU   *                   ENTRY LABEL FOR 1 CARD PROCESS\n         $SORC AOBJCARD,80,AOBJEOF READ UNTIL END-FILE\n         CLC   AOBJTYPE,=C'TXT'    WAS IT TEXT CARD (MOST LIKELY)\n         BE    AOBTXT              YES (NOTE WE IGNORE COL 1 OF CARD)\n         CLC   AOBJTYPE,=C'END'    WAS IT END CARD\n         BE    AOBEND              YES, GO THERE TO PROCESS IT\n*****    CLC   AOBJTYPE,=C'RLD'    WAS IT RLD\n*****    BE    AOBRLD              YES, GO THERE\n*****    CLC   AOBJTYPE,=C'ESD'    WAS IT ESD CARD\n*****    BE    AOBESD              YES, GO THERE\n*****    IF DESIRED, INSERT COUNTER HERE FOR UNKNOWN TYPES OF CARDS.\n         B     AOBREAD             UNKNOWN TYPE OF CARD-IGNORE IT\n         SPACE 1\n*        ***** PROCESSING CODE FOR INDIVIDUAL TYPES OF CARDS *****\n         SPACE 2\n*              ***** END CARD(S) *****\n*              SETS R5 = ENTRY @, IF:  1) A PREVIOUS END CARD HAS     *\n*              NOT ALREADY SPECIFIED ONE, AND 2) ONE IS GIVEN ON THIS *\n*              END CARD.                                              *\nAOBEND   EQU   *\n         TM    AVTAGS1,AVOENTR     HAS ONE BEEN SPECIFIED ALREADY\n         BO    AOBREAD             YES, SO DON'T DO IT AGAIN\n         CLC   AOENTRY2,AWBLANK+1  WAS ENTRY POINT BLANK\n         BE    AOBREAD             YES, SO IGNORE IT\n         L     R5,AOENTRY          GET FULLWORD CONTAINING ENTRY @\n         LA    R5,0(,R5)           REMOVE LEADING BYTE\n         OI    AVTAGS1,AVOENTR     SHOW ENTRY @  FOUND, SO WONT DO AGAN\n         B     AOBREAD             GO BACK FOR MORE (IF ANY)\n         SPACE 2\n*              ***** ESD CARD(S) *****                                *\n*AOBESD  EQU   *                   EXTERNAL SYMBOL DICTIONARY\n         SPACE 2\n*              ***** RLD CARD(S) *****                                *\n*AOBRLD  EQU   *                   RELOCATION DICTIONARY\n         EJECT\n*              ***** TXT CARD(S) *****                                *\n*              MOVE TEXT CODE FROM CARDIMAGE INTO MEMORY.             *\n*              COMPUTE RELOCATION FACTOR FROM FIRST TEXT CARD FOUND.  *\n*              MAINTAIN HIGH LIMIT FOR ACTUAL OBJECT CODE, AND MAKE   *\n*              SURE CODE DOES NOT EXCEED HIGH LIMIT, OR GO BELOW      *\n*              THE LOW LIMIT (AFTER FIRST TEXT CARD).                 *\nAOBTXT   EQU   *                   ENTRY LABEL FOR TEXT CARD\n         L     R1,AOTADDR          GET @ CODE (USER PROG RELATIVE)\n         LA    R1,0(,R1)           REMOVE HI-ORDER BYTE\n         TM    AVTAGS1,AVO1TXT     HAVE WE GOTTEN AT LEAST 1 TXT CARD\n         BO    AOBTXT1             YES, SO SKIP\n*              FIRST TEXT CARD - COMPUTE RELOCATION FACTOR\n         LR    R4,R2               MOVE REAL BEGINNING @ OVER\n         SR    R4,R1               SUBTRACT USER LOW @ FROM REAL= RELOC\n         OI    AVTAGS1,AVO1TXT     FLAG SO WE DON'T COMPUTE IT AGAIN\n         BZ    AOBTXT1             NO, LEAVE ENTRY PT REG AS IS\n         TM    AVTAGS1,AVOENTR     HAS ENTRY PT BEEN RECEIVED ALREADY\n         BO    AOBTXT1             YES, SO DON'T CHANGE R5\n         LR    R5,R1               MAKE DEFAULT ENTRY PT THE FIRST BYTE\nAOBTXT1  AR    R1,R4               RELOC USER @ TO REAL ONE\n         CR    R1,R2               WAS IT LOWER THAN REAL LIMIT\n         BL    AOBTXTIL            YES, GO TO FLAG OR PRINT MESSAGE\n         IC    R8,AOTLENG2         GET LENGTH FROM CARD OF CODE\n         LA    R0,0(R8,R1)         GET REAL @+1 OF LAST BYTE OF CODE\n         CR    R0,R9               WAS IT HIGHER THAN ACTUAL SPACE\n         BH    AOBTXTIH            YES, TOO MUCH CODE-EXIT\n         CR    R0,R3               WAS IT HIGHER THAN PREVIOUS HIGH\n         BNH   *+6                 NO, SKIP\n         LR    R3,R0               YES, SET NEW HIGH LIMIT\n         SPACE 1\n         LTR   R8,R8               WAS LENGTH=0 (POSSIBLE FOR DS'S)\n         BZ    AOBREAD             YES, SO DON'T DO ANYTHING\n         BCTR  R8,0                DECREMENT LENGTH TO LENGTH-1 FOR MVC\n         EX    R8,AOBTXTMV         MOVE TEXT CODE OVER\n         B     AOBREAD             RETURN FOR NEXT CARD\nAOBTXTMV MVC   0($,R1),AOTCODE     MOVE CODE TO MEMORY **MODIFIED**\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*              EXIT CODE - CHECK AND STORE FINAL ADDRESSES            *\n*        MAKE SURE WE RECIEVED AT LEAST 1 TEXT CARD, ASSURE *8        *\n*   LENGTH MULTIPLE, AND STORE BLOCK OF 6 ADDRESSES APPROPRIATELY.    *\n*   NOTE THAT ALTERATIONS MUST BE MADE IF THE USER CODED RELOC, IN    *\n*   WHICH CASE HIS PROGRAM MUST EITHER BE LOADED FROM WHERE IT WAS    *\n*   ASSEMBLED ORIGINALLY, OR MUST CONTAIN NO ADDRESS CONSTANTS AT ALL.*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nAOBJEOF  EQU   *\n         TM    AVTAGS1,AVO1TXT     DID WE GET AT LEAST 1 TXT CARD\n         BZ    AOBNOTXT            NO, QUIT NOW WITH ERROR\n         LA    R3,7(,R3)           ROUND UPPER REAL @ UP\n         SRL   R3,3                SHIFT TO REMOVE 3 BITS\n         SLL   R3,3                SHIFT BACK, NOW ALIGNED\n         TM    AVTAGS1,AJORELOC    WAS THIS TO BE RELOACTED MODE\n         BZ    AOBJNORM            NO, NORMAL-SKIP\n         AR    R5,R4               RELOCATE USER LOCATION TO REAL\n         SR    R4,R4               MAKE EXECUTION RELOC FACTOR = 0\nAOBJNORM EQU   *                   FINAL STORE OF @'S\n         STM   R2,R5,AVRADL        AV(RADL-RADH-RELOC-FENTER)\n         SR    R2,R4               RADL-RELOC = FAKE LOW @ FOR USER\n         SR    R3,R4               RADH-RELOC = FAKE HIGH LIMIT @\n         STM   R2,R3,AVLOCLOW      AV(LOCLOW-LOCHIH) -USER RELATIVE LIM\n         SPACE 1\n*              SUCCESFFUL COMPLETION MESSAGE AL100.\n         BAL   R14,AOBHEXCO        GO CONVERT VALUES TO HEX\n         DC    H'4'                # ITEMS IN LIST\n         DC    AL2(AVLOCLOW-AVWXTABL,AOB100A-AOB)     LOWEST USER @\n         DC    AL2(AVLOCHIH-AVWXTABL,AOB100B-AOB)     HIGH USER @\n         DC    AL2(AVFENTER-AVWXTABL,AOB100C-AOB)     FAKE ENTRY @\n         DC    AL2(AVRELOC-AVWXTABL,AOB100D-AOB)      RUN TIME RELOC\n         BAL   R14,AOBPRINT        PRINT COMPLETED MESSAGE\n         DC    AL2(AOB100-AOB,AOB100L)      MESSG OFFSET, LENGTH\n         SPACE 1\nAOBJEXIT $RETURN RGS=(R14-R12),SA=NO        RETURN TO CALLER\n         SPACE 1\n*              ***** ERROR EXITS *****\nAOBNOTXT BAL   R14,AOBPRINT        PRINT AL996 - NO TEXT CARDS FOUND\n         DC    AL2(AOB996-AOB,AOB996L)      OFFSET, LENGTH\n         B     AOBJBAD             GO TO SHOW ABORT\nAOBTXTIL BAL   R14,AOBPRINT        AL997 - TXT @ TOO LOW\n         DC    AL2(AOB997-AOB,AOB997L)      OFFSET,LENGTH\n         B     AOBTXTID            GO TO DUMP STMT FOR USER\nAOBTXTIH BAL   R14,AOBPRINT        AOB998 - OVERFLOW OF AREA\n         DC    AL2(AOB998-AOB,AOB998L)      OFFSET, LENGTH\nAOBTXTID BAL   R14,AOBDUMP         DUMP USER CARDIMAGE, FALL TO AOBJBAD\nAOBJBAD  BAL   R14,AOBPRINT        GO PRINT AL999 - LOAD ABORT\n         DC    AL2(AOB999-AOB,AOB999L)      OFFSET, LENGTH\n         OI    AVTAGS1,AJNLOAD     FLAG NOLOAD\n         B     AOBJEXIT            RETURN SHOWING ERROR\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> INSUB: AOBDUMP    DUMP CURRENT USER CARDIMAGE                    *\n*        ENTRY CONDITIONS                                             *\n*   R14= RETURN ADDRESS TO CALLING CODE                               *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nAOBDUMP  EQU   *\n         XSNAP T=(NO,,0),LABEL='IMAGE OF INCORRECT OBJECT CARD',       X\n               STORAGE=(*AOBJCARD,*AOBJCARD+80)\n         BR    R14\n         SPACE 2\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> INSUB: AOBHEXCO   CONVERT VALUES TO EDITED HEXADECIMAL           *\n*        ENTRY CONDITIONS                                             *\n*   R14= @ PARAMETER LIST.  LIST CONSISTS OF THE FOLLOWING:           *\n*        1) HALFWORD GIVING # ITEMS IN LIST TO BE CONVERTED.          *\n*        2) 1 OR MORE PAIRS OF OFFSET VALUES GIVING DISPLACEMENT      *\n*        FROM AVWXTABL TO FULLWORD VARIABLE TO BE CONVERTED, AND      *\n*        OFFSET FROM LABEL AOB TO 6-BYTE FIELD WHERE EDITED HEX       *\n*        SHOULD BE PLACED. REQUIRES FREE BYTE AFTER THIS FIELD.       *\n*        EXIT CONDITIONS                                              *\n*   R0,R1,R14,R15  ARE ALL MODIFIED.                                  *\n*   CONTROL RETURNED TO LOCATION AFTER PARAMETER LIST.                *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nAOBHEXCO LH    R0,0(,R14)          GET # ENTRIES IN FOLLOWING LIST\nAOBHEX2  LH    R1,2(,R14)          GET OFFSET OF FULLWORD TO CONVERT\n         LA    R1,AVWXTABL(R1)     GET ACTUAL @ OF VARIABLE\n         LH    R15,4(,R14)         GET OFFSET TO OUTPUT FIELD\n         LA    R15,AOB(R15)        GET ACTUAL @ OUTPUT FIELD\n         UNPK  0(7,R15),1(4,R1)    UNPACK 3 BYTES, WITH EXTRA FOR EASE\n         TR    0(6,R15),AWTHEX3    TRANSLATE TO PRINTABLE\n         MVI   6(R15),C' '         PUT IN BLANK AFTER TO WIPE EXTRA OUT\n         LA    R14,4(,R14)         BUMP PTR TO NEXT PAIR\n         BCT   R0,AOBHEX2          LOOP THORUGH LIST\n         B     2(,R14)             RETURN TO CALLER\n         SPACE 2\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> INSUB: AOBPRINT   PRINT 1 LINE OF OUTPUT MESSAGE                 *\n*        ENTRY CONDITIONS                                             *\n*   R14= @ PARAMETER LIST, WHICH HAS OFFSET @ OF MESSAGE FROM AOB,    *\n*        FOLLOWED BY LENGTH OF MESSAGE, BOTH IN HALFWORDS.            *\n*        EXIT CONDITIONS                                              *\n*   R0,R1      ARE MODIFIED.                                          *\n*   CONTROL RETURNED TO LOCATION AFTER PARAMETER LIST.                *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nAOBPRINT LA    R0,AOB              BASE @ FOR MESSAGE\n         AH    R0,0(,R14)          ADD IN OFFSET @\n         LH    R15,2(,R14)         LENGTH OF MESSAGE\n         $PRNT (R0),(R15)          PRINT THE MESSAGE\n         B     4(,R14)             RETURN TO CALLER\n         EJECT\n*              AOBJIN LOADER MESSAGES - AL###                         *\n*              AL000 - BEGINNIG HEADER LABEL.                         *\n*              AL100 - SUCCESSFUL COMPLETION.                         *\n*              AL996 - NO TEXT CARDS RECEIVED.                        *\n*              AL997 - TXT CARD @ TOO LOW                             *\n*              AL998 - TXT CARD @ TOO HIGH - OVERFLOW OF AREA         *\n*              AL999 - LOAD ABORTED MESSAGE                           *\nAOB      EQU   *                   BASE FOR OFFSET @'S IN PARM LISTS\n         SPACE 1\nAOB000   DC    C'0*** AL000 - ASSIST LOADER BEGINS LOAD AT '\nAOB000A  DC    XL6'0'              LOWEST @ = AVADDLOW\n         DC    C' ,USABLE CORE ENDS AT '\nAOB000B  DC    XL6'0',C' ***'      HIGH LIMIT = AVADDHIH\nAOB000L  EQU   *-AOB000            LENGTH OF THIS MESSAGE\n         SPACE 1\nAOB100   DC    C'0*** AL100 - LOAD COMPLETED, USER ADDRESSES: LOW '\nAOB100A  DC    XL6'0',C' ,HIGH '   AVLOCLOW - LOW USER LIMT\nAOB100B  DC    XL6'0',C' ,ENTRY '  HIGH LIMIT  AVLOCHIH\nAOB100C  DC    XL6'0',C' . RUN-TIME RELOCATION '      USER ENTRY @\nAOB100D  DC    XL6'0',C' ***'      AVRELOC - RUN-TIME RELOCATION\nAOB100L  EQU   *-AOB100            LENGTH OF THIS MESSAGE\n         SPACE 1\nAOB996   DC    C'0*** AL996 - NO TXT CARD RECEIVED ***'\nAOB996L  EQU   *-AOB996            LENGTH OF MESSAGE\n         SPACE 1\nAOB997   DC    C'0*** AL997 - TXT CARD ADDRESS BELOW 1ST TXT CARD ***'\nAOB997L  EQU   *-AOB997            LENGTH OF MESSAGE\n         SPACE 1\nAOB998   DC    C'0*** AL998 - TXT CARD ADDRESS EXCEEDED STORAGE ***'\nAOB998L  EQU   *-AOB998            LENGTH OF MESSAGE\n         SPACE 1\nAOB999   DC    C' *** AL999 - LOAD ABORTED ***'\nAOB999L  EQU   *-AOB999            LENGTH OF MESSAGE\n         DROP  R6,R7,RAT           REMV USINGS: BASE,AOBJCARD,AVWXTABL\n.AOBJN1  AIF   (NOT &$DECK).AOBNONE    SKIP IF NO DECK\n         EJECT\n         ENTRY AODECK\nAODECK   $SAVE RGS=(R14-R12),SA=NO,BR=R6\n         USING AVWXTABL,RAT        NOTE ASSEMBLER CONTROL TABLE\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> ENTRY: AODECK     PUNCH OBJECT DECK FOLLOWING ASSEMBLY           *\n*        IF THE DECK OPTION IS SPECIFIED, AODECK IS CALLED FOLLOWING  *\n*   A SUCCESSFULL ASSEMBLY TO PUNCH THE USER PROGRAM OUT IN OBJECT    *\n*   DECK FORM.  THE DECK PUNCHED CONTAINS 1 OR MORE TXT CARDS AND     *\n*   1 END CARD, AND FOLLOWS S/360 DECK FORMAT FAIRLY CLOSELY.         *\n*        **NOTE** THIS FACILITY IS VERY PRIMITIVE, AND THE DECKS      *\n*   PRODUCED CANNOT REALLY BE USED FOR ANYTHING BUT INPUT TO ASSIST,  *\n*   SINCE THERE IS NEITHER EXTERNAL SYMBOL DICTIONARY NOR RELOCATION  *\n*   DICTIONARY PRODUCED.  ALSO, SINCE THE ENTIRE USER PROGRAM IS      *\n*   PUNCHED, OBJECT CARDS ARE PRODUCED FOR SPACE CONTAINING ONLY DS   *\n*   LOCATIONS.  IN SOME CASES, THIS COULD CAUSE HUGE DECKS TO BE      *\n*   PUNCHED.   IF A BETTER SETUP IS DESIRED, ASSEMBLER MODULE UTOPRS  *\n*   COULD BE CHANGED TO PRODUCE SMALLER DECKS, ALTHOUGH RLD ENTRIES   *\n*   WOULD STILL BE DIFFICULT TO PRODUCE.                              *\n*        **NOTE** THE MOST LIKELY USE FOR THIS OPTION IS TO PRODUCE   *\n*   OBJECT DECKS TO BE USED AS UTILITY PROGRAMS FROM RJE TERMINALS.   *\n*        ENTRY CONDITIONS                                             *\n*   R12(RAT) = @ ASSEMBLER CONTROL TABLE (AVWXTABL).                  *\n*        USES MACROS: $PNCH,$RETURN,$SAVE                             *\n*        NAMES: AOD-----                                              *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n* * * * * * * * REGISTER USAGE FOR AODECK * * * * * * * * * * * * * * *\n*   R4 = @ CURRENT BLOCK OF CODE TO BE PUNCHED (INIT = AVRADL).       *\n*   R5 = CURRENT LENGTH OF CODE REMAINING (INIT =AVRADH-AVRADL)       *\n*   R6 = BASE REGISTER                                                *\n*   R7 = @ AOBJCARD : OBJECT CARD OUTPUT IMAGE                        *\n*   R8 = CURRENT @ OF CODE TO PUNCHED (USER PROGRAM RELATIVE).        *\n*   R9 = L'AOTCODE = LENGTH OF NORMAL(ALL BUT LAST) CODE ON CARD      *\n*   R12(RAT)= @ ASSEMBLER CONTROL TABLE (AVWXTABL).                   *\n*   R13= @ CALLING PROGRAM'S SAVE AREA, UNCHANGED                     *\n*   R14= INTERNAL LINK REGISTER                                       *\n*   ALL OTHERS ARE UNUSED                                             *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*              INITIALIZATION FOR OBJECT PUNCH                        *\n*        INITIALIZE REGISTERS, SEQUENCE #, AND TXT CARDIMAGE.         *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         LM    R4,R5,AVRADL        AV(RADL-RADH) LOWER/UPPER REAL @'S\n         SR    R5,R4               SIZE OF CODE = UPPER-LOWER LIMIT\n         BNP   AODEXIT             NO MORE, QUIT\n         LA    R7,AVCONCAT         WE WILL USE THIS AS WORKAREA\n         USING AOBJCARD,R7         NOTE PTR THERE\n         L     R8,AVLOCLOW         GET LOWEST USER PROGRAM @\n         MVC   AOBJCARD(72),AWBLANK    BLANK OUT CARD, EXCEPT SEQUENCE\n         MVC   AOBJTYPE,=C'TXT'    FLAG AS TXT CARD\n*****    MVI   AOBJCARD,X'02'      NORMAL S/360 FLAG\n         LA    R9,L'AOTCODE        LENGTH OF NORMAL OBJECT CODE\n         STH   R9,AOTLENG          STORE FOR NORMAL LENGTH\n         ZAP   AVDWORK1(5),AWP0    ZERO WORKAREA FOR SEQUENCE#\n         UNPK  AOTSEQN(8),AVDWORK1(5)       MOVE SEQUENCE # OVER\n         OI    AOTSEQN+7,X'F0'     MAKE PRINTABLE\n         MVI   AODTXTMV+1,L'AOTCODE-1       NORMAL LENGTH-1 OF OBJCODE\n         SPACE 1\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*              LOOP FOR PUNCHING OBJECT DECK                          *\n*        PUNCH FULL OBJECT CARD FOR (ALL BUT POSSIBLY LAST BLOCK)     *\n*   OF CODE IN USER PROGRAM.                                          *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nAODTXT   EQU   *\n         ST    R8,AOTADDR          STORE USER CODE FAKE @ INTO CARD\n*****    MVI   AOTADDR,C' '        BLANK OUT FOR S/360 NORMAL\n         CR    R5,R9               HOW MUCH IS LEFT TO BE PUNCHED\n         BNL   AODTNORM            STILL ENOUGH FOR FULL CARD-BRANCH\n         SPACE 1\n         BCTR  R5,0                LENGTH-1 FOR MVC\n         STC   R5,AODTXTMV+1       STORE INTO MVC FOR LAST PUNCH\n         MVC   AOTCODE,AWBLANK     BLANK OUT WHOLE CARD, SINCE PART NOT\nAODTNORM EQU   *\nAODTXTMV MVC   AOTCODE($),0(R4)    MOVE CODE FROM MEMORY\n         BAL   R14,AODPUNCH        GO PUNCH THE CARD\n         AP    AVDWORK1(5),AWP1    INCREMENT THE CARD COUNTER\n         UNPK  AOTSEQN(8),AVDWORK1(5)       UNPACK FOR NEXT CARD\n         OI    AOTSEQN+7,X'F0'     MAKE SURE PRINTABLE\n         AR    R8,R9               INCREMENT USER CODE @\n         AR    R4,R9               INCREMENT REAL @ IN MEMORY PTR\n         SR    R5,R9               DECREMENT LENGTH PUNCHED LAST TIME\n         BP    AODTXT              IF MORE TO DO, RETURN FOR NEXT CARD\n         SPACE 1\n*              ***** COMPLETION - PUNCH END CARD\n         MVC   AOBJTYPE,=C'END'    MAKE CARD AN END CARD\n         MVC   AOEBLNK(AOEBLNKL),AWBLANK    BLANK OUT CARD(CEPT SEQN#)\n         MVC   AOENTRY2,AVFENTER+1 MOVE ENTRY @ IN\n         BAL   R14,AODPUNCH        PUNCH THE ASSEMBLED END CARD\nAODEXIT  $RETURN RGS=(R14-R12),SA=NO\n         SPACE 1\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> INSUB: AODPUNCH   PUNCH 1 OBJECT CARD FOR AODECK                 *\n*        ENTRY CONDITIONS                                             *\n*   R14= RETURN @ TO CALLING SECTION OF CODE                          *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nAODPUNCH EQU   *\n         $PNCH AOBJCARD,80,AODEXIT PUNCH, QUIT IF OVERRUN\n         BR    R14                 RETURN TO CALLING SECTION\n         LTORG\n         DROP  R6,R7,RAT           REMV USINGS: BASE,AOBJCARD,AVWXTABL\n.AOBNONE ANOP\n         AIF   (&$EXINT).EXYZ      SKIP IF USING EXTENDED INTERPRETER\n         TITLE '*** EXECUT - ASSIST INTERPRETER SECTION ***'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> CSECT: EXECUT       INTERPRETER SECTION                          *\n*              EXECUT PERFORMS ALL 360 INSTRUCTION SIMULATION DURING  *\n*        INTERPRETIVE EXECUTION OF THE USER PROGRAM.  ALL CONTROL     *\n*        VALUES FOR THIS MODULE ARE CONTAINED IN DSECT ECONTROL, WHICH*\n*        IS PASSED TO EXECUT BY THE CALLING PROGRAM.  THE INSTRUCTION.*\n*        SET SIMULATED INCLUDES THE FOLLOWING:                        *\n*              1. STANDARD INSTRUCTION SET (INCL. 370'S IF ALLOWED)   *\n*              2. DECIMAL INSTRUCTION SET (IF PRESENT ON MACHINE).    *\n*              3. FLOATING POINT INSTRUCTIONS (OPTIONAL).             *\n*              4. X-MACRO PSEUDO INSTRUCTIONS - XDUMP, XLIMD,         *\n*                XPNCH, XPRNT, XREAD.                                 *\n*        THE PRIVILEGED OPERATIONS MAY BE DECODED TO THE POINT OF     *\n*        BRANCHING TO INDIVIDUAL INSTRUCTION HANDLERS, BUT THEY ARE   *\n*        ARE FLAGGED WITH AN 0C2 INTERRUPT AT PRESENT, AND ARE NOT    *\n*        INTERPRETED FURTHER.  THE CODE PRESENT IS FOR FUTURE USE.    *\n*              THE SVC INSTRUCTION IS CURRENTLY FLAGGED WITH AN 0C2 IF*\n*        USED, BUT CODE EXISTS TO HANDLE ALL SVC CALLS IN A TABLE-    *\n*        DRIVEN WAY, USING THE @ OF AN SVC CONTROL TABLE PASSED IN THE*\n*        WORD ECSVCADS IN ECONTROL.  AS OF 8/2/70, THERE ARE NOT SVC  *\n*        ROUTINES, BUT THE CODE EXISTS FOR FUTURE USE.                *\n*              GENERAL CODE IS ALSO PROVIDED FOR ANY ADDITIONAL NEW   *\n*        INSTRUCTIONS OR I/O SIMULATORS BY THE SECTION EXCALL, WHICH  *\n*        ALLOWS CALLS TO EXTERNAL ROUTINES (WHICH WOULD BE USED BY    *\n*        ANY SVC CALLS, IF THERE ARE ANY).                            *\n*        ENTRY CONDITIONS                                             *\n*   R10= @ ECONTROL - EXECUTION CONTROL BLOCK.                        *\n*   ECONTROL CONTAINS ALL INITIAL VALUES FOR REGS,LIMITS,ETC.         *\n*        EXIT CONDITIONS                                              *\n*   ECINTCOD   CONTAINS INTERRRUPT CODE, IF PROGRAM INTERRUPT.        *\n*   ECFLAG1    CONTAINS SPECIAL COMPLETION CODE, IF ANY.              *\n*   ECERRAD  = ADDRESS OF AN ERCOMPCD ERROR COMPLETION CODE BLOCK     *\n*   ECONTROL   CONTAINS ALL OTHER VALUES NEEDED FOR A COMPLETION DUMP.*\n*        USES DSECTS: ECONTROL,ECSTACKD                               *\n*        USES MACROS: $AL2,$ERCGN,$PNCH,$PRNT,$READ,$RETURN,$SAVE     *\n*        USES MACROS: $SPIE, XDECI, XDECO, XSNAP                      *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nEXECUT   CSECT\n         $DBG  ,NO                 KILL TRACE CODE HERE\n         SPACE 1\nEXPRFETC EQU   B'10000000'         (EXIPROT) - INST ACCESSES STORAGE\nEXPRSTOR EQU   B'01000000'         (EXIPROT) - INST MODIFIES STORAGE\nEXPRFET2 EQU   B'00100000'         (EXIPROT) - SS INST ACCESSES CORE\nEXPRSTO2 EQU   B'00010000'         (EXIPROT) - SS INST MODS CORE(2ND @)\n         SPACE 1\n*        *** SYMBOLIC REGISTER EQUATES ***                            *\nRSTK     EQU   R3                  ADDR OF CURRENT INST. STACK ENTRY\nRIA      EQU   R4                  INSTRUCTION ADDRESS REGISTER\nRCC      EQU   R5                  CONDITION CODE REGISTER\nREC      EQU   R6                  POINTER TO ECONTROL BLOCK\nRWK      EQU   R7                  WORK REGISTER\nRR1      EQU   R8                  DECODING REGISTER FOR R1 FIELD\nRR2      EQU   R9                  REGISTER 2 (WHEN USED IN RR'S)\nRX2      EQU   RR2                 INDEX REGISTER(FOR RX'S)\nRR3      EQU   RR2                 RO OPERAND(FOR RS INST)\nRB1      EQU   R10                 1ST BASE-DISPLACEMENT-(B1-D1)\nRB2      EQU   R11                 2ND BASE-DISPLACEMENT-(B2-D2)\nRMEM     EQU   R12                 CONTAINS RELOCATION VALUE\nRLINK    EQU   R14                 INTERNAL LINAKGE REGISTER-RETURN ADD\nROP      EQU   R15                 USED TO HOLD OPCODE BYTE\n*        **NOTE** DURING MAIN EXECUTION REGS R2,ROP ARE BYTE REGS.    *\n         SPACE 1\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*              ORGANIZATION OF THE ASSIST INTERPRETER                 *\n*                                                                     *\n*        1.    INITIALIZATION CODE                                    *\n*        2.    INTERRUPT-HANDLING AND EXIT CODE                       *\n*        3.    OCCASIONAL INTERNAL SUBROUTINE CODE                    *\n*        4.    PRIMARY INSTRUCTION FETCH AND COMMON DECODING          *\n*        5.    1ST-LEVEL DECODING, IN GROUPS :  RR, RX, SI-RS, AND SS *\n*        6.    2ND-LEVEL SECTIONS-PERFORM INDIVIDUAL INSTRUCTIONS,    *\n*              IN GROUPS:  RR, RR-RX OVERLAP, RX, SI, RS, SS,SPECIAL  *\n*        7.    3RD-LEVEL INTERNAL SUBROUTINES (DECODERS,RANGE CHECK)  *\n*        8.    DATA AREAS, OPCODE BRANCH AND PROTECTION TABLES        *\n*                                                                     *\n*        **WARNING** ADDRESSIBILITY IS NOW TIGHT IN EXECUT.           *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*        INITIALIZATION PHASE - OBTAIN PARAMATER ADDRESSES FROM CALLER*\n*   PERFORM CALCULATIONS TO GET THEM INTO NEEDED FORM. ZERO OUT THE   *\n*   INSTRUCTION STACK FINSTACK,AND INITIALIZE ANY REQUIRED REGISTER   *\n*   VALUES FOR THE EXECUTION. ALSO SAVE INSTRUCTION LIMIT VALUE.      *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n         $SAVE RGS=(R14-R12),BR=R8,SA=EXECSAVE\n         LR    REC,R10             MOVE ECONTROL BLOCK POINTER OVER\n         USING ECONTROL,REC        NOTE USAGE\n         TM    ECFLAG0,$ECCONT     IS THIS A CONTINUE OR A NEW\n         BO    EXCONTIN            INIT ALREADY DONE-KEEP GOING\n         OI    ECFLAG0,$ECCONT     NOTE THAT ANY OTHERS WILL BE CONTINU\n         SPACE 1\n*              INSTRUCTION STACK ZEROING AND CHAINING.                *\n         SR    R1,R1               CLEAR FOR ZEROING USE\n         SR    R2,R2               CLEAR FOR ZEROING\n         SR    R3,R3               CLEAR FOR ZEROING\n         LA    R4,L'ECSTENT        VALUE OF SINGLE ENTRY\n         LA    R5,ECINSTAC+L'ECINSTAC*(EC$STACK-1)     GET ENDING LIMIT\n         LA    R7,ECINSTAC         GET BEGINNING ADDRESS OF STACK AREA\n         USING ECSTACKD,R7         SET UP TEMPORARY USING\n         LA    R0,ECINSTAC+L'ECINSTAC        GET @ 2ND ELEMENT\n         SPACE 1\nEXINITST STM   R0,R3,ECSTENT       ZERO 1 TABLE ENTRY\n         LR    R7,R0               UPDATE POINTER TO STACK ENTRY\n         BXLE  R0,R4,EXINITST      CONTINUE LOOPING\n         SPACE 1\n         LA    R0,ECINSTAC         ADDRESS FOR WRAPAROUND\n         STM   R0,R3,ECSTENT       STORE IN LAST ENTRY\n         ST    R7,ECRSTK           SAVE WHERE CAN BE PICKED UP\n         DROP  R7        DROP TEMPORARY REG TO KEEP USING STRAIGHT\n         MVC   ECILIMT,ECILIMP     MOVE PERMANENT TO TEMPORARY\n         MVC   ECILCMSK(4),ECFENTER          MAKE ENTRY POINT THE PSW\n         MVC   ECR14SAV,ECREG14    SAVE FOR ORIGINAL RETURN @\n         SPACE 1\nEXCONTIN BAL   RLINK,EXADCALC      GO TO RECALCULATE ADDRESSES IF NEED\n         SPACE 1\nEXSPIEGO EQU   *\n         TM    ECFLAG0,$ECSPIEA    IS OUR SPIE ALREADY IN EFFECT\n         BO    EXSPIEA             YES,WE DON'T HAVE TO RE-SPIE\n         $SPIE EXSPIERT,((1,15)),CE=EXSPIEXT,ACTION=CR  CATCH ALL INTRP\n         ST    R1,ECPICA           SAVE PREVIOUS PICA, IF ANY\n         OI    ECFLAG0,$ECSPIEA    SHOW OUR SPIE IS IN CONTROL\nEXSPIEA  L     RSTK,ECRSTK         GET POINTER TO NEXT SLOT FOR STACK\n         USING ECSTACKD,RSTK       SET UP STACK USING FROM NOW ON\n         L     RMEM,ECRELOC        GET RELOCATION VALUE IN REGISTER\n         SR    R2,R2               CLEAR REG FOR CONSTANT INSERTS\n         STH   R2,ECINTCOD         SET THE INTERRUPT CODE TO 0\n         SR    ROP,ROP             CLEAR OPCODE REG FOR CONSTANT IC'S\n         L     RB2,ECILCMSK        LOAD INST ADDR WHERE EXFINB EXPECTS\n         LR    RCC,RB2             PLACE CC AND MASK OVER\n         SPM   RCC                 INITIALIZE REAL CC TO FAKE ONE\n         AIF   (NOT &$FLOTE).EXNOFL1         SKIP IF NOT GOING TO DO FP\n         LD    F0,ECFPREGS         GET FP REG\n         LD    F2,ECFPREGS+8       GET 2ND FP REG\n         LD    F4,ECFPREGS+16      LOAD 3RD FP REG\n         LD    F6,ECFPREGS+24      GET 4TH FP REG\n.EXNOFL1 ANOP\n         B     EXFINB              SKIP TO START RUN\nEXECSAVE DC    18F'0'              SAVE AREA, ALSO BASE REGISTER HERE\n         DROP  R8                  KILL TEMPORARY USING\n         USING EXECSAVE,R13        USE R13 AS BASE/SAVEAREA POINTER\nEXJUMP   DS    0H                  BASE FOR 2ND LEVEL INDEX JUMPS\n         SPACE 1\n* * * * * 0CX INTERRUPT EXITS   * * * * * * * * * * * * * * * * * * * *\n*              THE LABELS ARE HERE SO THAT OTHERS MAY BE EQU'D TO THEM*\nEX0C1    LA    R0,1                SHOW OPERATION INTERRUPT\n         AIF   (&$DEBUG).EX0C1A    SKIP DEBUG CODE IF PRODUCTION\n         CLI   ECOP,X'83'          IS CODE THE PSEUDO DIAGNOSE\n         BE    EXDIAG              YES,GO THERE FOR OUR PSEUDO DIAGNOSE\n.EX0C1A  ANOP\n         B     EXEXITI             EXIT POINT FOR INTERRUPTS\nEX0C2C   EQU   *                   CHECK FOR PRIVILEGED OPERATION\n         TM    ECKYAMWP,$ECPRBST   ARE WE IN PROBLEM STATE\n         BCR   Z,RLINK             NO,SUPERVISOR STATE,SO OK-RETURN\nEX0C2    LA    R0,2                PRIVILEGED OPERATION\n         B     EXEXITI             EXIT POINT FOR INTERRUPTS\nEX0C3    LA    R0,3                EXECUTE INTERRUPT\n         B     EXEXITI             EXIT POINT FOR INTERRUPTS\nEX0C4    LA    R0,4                PROTECTION INTERRUPT\n         B     EXEXITI             EXIT POINT FOR INTERRUPTS\n*EX0C5   LA    R0,5                ADDRESSING INTERRUPT\n*        B     EXEXITI             QUIT\nEX0C6    LA    R0,6                SPECIFICATION INTERRUPT\n         B     EXEXITI             EXIT POINT FOR INTERRUPTS\n*EX0C7   LA    R0,7                DATA EXCEPTION\n*        B     EXITI               QUIT\nEX0CA    LA    R0,10               DECIMAL OVERFLOW\n         B     EXEXITI             QUIT\n         SPACE 2\n*              ENTERED WHEN PROGRAM BRANCHES OUT OF RANGE             *\nEXIAOUT  MVI   ECFLAG1,$ECBRN14    HOPE FOR NORMAL RETURN\n         L     R14,ECR14SAV        GET RETURN @, ORIGINAL\n         LA    R14,0(R14)          REMOVE LEADING BYTE\n         CR    RIA,R14             WAS BRANCH TO THIS @\n         BE    EXITA               RETURN\n         MVI   ECFLAG1,$ECBROUT    WAS ACTUAL BRANCH OUT OF PROG,RET\n         LA    R1,EXCCBROU         SHOW @ BRANCH OUT\n         B     EXITIA              GO HAVE @ STORED, QUIT\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*              INTERRUPT HANDLER - THIS SECTION IS ENTERED FOR ANY    *\n*        REAL INTERRUPT, SUCH AS 0C7,0C6,ETC.  THE REAL INTERRUPT     *\n*        IS SAVED AS THE PSEUDO INTERRUPT, SINCE THEY MUST BE THE     *\n*        SAME. THE ADDRESS IN THE PSW PART OF THE PIE IS MODIFIED SO  *\n*        THAT OS WILL RETURN CONTROL TO EXSPIERT INSTEAD OF TO THE    *\n*        INTERRUPTED CODE, AND THEN CONTROL IS GIVEN TO OS. WHEN THE  *\n*        INTERPRETER REGAINS CONTROL, IT EXITS, SHOWING AN INTERRUPT. *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n         USING *,R15\nEXSPIEXT LH    RB1,2(R1)           GET INTERRUPT CODE FROM PIE\n         AIF   (&$DEBUG).EXXNSP    SKIP IF PRODUCTION\n         XSNAP LABEL='SPIE',STORAGE=(*0(R1),*32(R1)),                  X\n               IF=(ECFLAG2,O,X'20',TM)      XSNAP PIE\n.EXXNSP  ANOP\n         BR    R14                 RETURN TO OS CONTROL\n         DROP  R15                 DROP USING TO KEEP STRAIGHT\n         SPACE 1\nEXSPIERT LR    R0,RB1              MOVE INTERRUPT CODE OVER WHERE NEED\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*              EXIT AND RETURN CODE - SAVE EVERYTHING REQUIRED,       *\n*        REMOVE $SPIE IF NECESSARY, AND RETURN TO CALLER.             *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nEXEXITI  STH   R0,ECINTCOD         SAVE INTO INTERRUPT CODE\n         MVI   ECFLAG1,0           RESET, NEEDED BY REPLACE MONITOR\n*              FOLLOWING FINDS MESSAGE FOR 0CX COMPLETION CODES.      *\n         ALR   R0,R0               SLL R0,1,DOUBLE CODE FOR INDEX\n         LR    R1,R0               MOVE WHERE WE CAN USE FOR INDEX\n         LH    R1,EXCOFFS(R1)      GET OFFSET TO MESSAGE BLOCK\n         LA    R1,EXCC0(R1)        GET @ MESSAGE BLOCK\nEXITIA   ST    R1,ECERRAD          STORE THIS @ IN ECONTROL\n         SPACE 1\nEXITA    ST    RSTK,ECRSTK         SAVE THE STACK POINTER\n         N     RCC,=XL4'3F000000'  REMOVE @, ILC(WHICH IS WRONG)\n         ALR   RCC,RIA             PUT THE ADDRESS AND CONCODE TOGETHER\n         ST    RCC,ECILCMSK        SAVE INTO THE PSW\n         OI    ECILCMSK,X'40'      SET ILC TO =1\n         CLI   ECOP,X'40'          WAS LAST INSTRUCTION RR\n         BL    EXITAILC            YES, SO ILC IS SET RIGHT,BRANCH\n         XI    ECILCMSK,X'C0'      SET ILC TO 2 FOR RX-SI-RS\n         CLI   ECOP,X'C0'          WAS INST AN SS\n         BL    EXITAILC            NO, IT WAS SI-RX-RS, BRANCH, ILC=2\n         OI    ECILCMSK,X'40'      SET ILC=3 FOR SS INSTS\nEXITAILC EQU   *\n         AIF   (NOT &$FLOTE).EXNOFL3         SKIP IF NOT FLOATINGS\n         STD   F0,ECFPREGS         STORE FIRST FP REG\n         STD   F2,ECFPREGS+8       STORE 2ND FP REG\n         STD   F4,ECFPREGS+16      SAVE THE THIRD FP REG\n         STD   F6,ECFPREGS+24      SAVE 4TH FP REG\n.EXNOFL3 ANOP\n         TM    ECFLAG0,$ECSPIEB    DO WE NEED TO UNDO SPIE\n         BZ    EXECRET             NO WE DON'T,SO DON'T SPIE\n         L     R1,ECPICA           GET PICA ADDRESS BACK\n         $SPIE ACTION=(RS,(1))     RESTORE PREVIOUS XSPIEBLK\n         NI    ECFLAG0,255-$ECSPIEA          WE WILL HAVE TO RESPIES\nEXECRET  $RETURN RGS=(R14-R12)\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*        SPECIAL ROUTINES - THE FOLLOWING ROUTINES ARE USED AT MOST   *\n*        OCCASIONALLY, AND ARE NOT DIRECTLY PARTS OF THE INTERPRETER. *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*              EXTERNAL CALL ROUTINE - THIS SECTION PREPARES ALL OF   *\n*        THE DUMMY MACHINE AREAS, AND CALLS THE ROUTINE WHOSE ADDRESS *\n*        IS IN RWK.  IT CHECKS FOR AN INTERRUPT CONDITION,RESTORES    *\n*        ALL THE REGISTERS, AND RETURNS CONTROL TO NORMAL EXECUTION.  *\n*        ***NOTE*** THIS ROUTINE IS MAINLY FOR FUTURE USE, I.E. FOR   *\n*        IMPLEMENTATION OF CERTAIN SVC'S, MACHINE LEVEL I/O, OR       *\n*        ANY ADDITIONAL PSEUDO MACHINE OPCODES WHICH ARE REQUIRED.    *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nEXCALL   STM   R0,R15,ECTSAVE      SAVE THE REGS TO BE SAFE\n         ST    RSTK,ECRSTK         SAVE POINTER IN CONTROL BLOCK\n         N     RCC,=XL4'3F000000'  REMOVE EXTRA BITS IN CC REG\n         ALR   RCC,RIA             PUT THE ADDRESS AND CONCODE TOGETHER\n         ST    RCC,ECILCMSK        SAVE INTO THE PSW\n         LR    R15,RWK             PLACE ADDRESS IN R15 FOR CALL\n         BALR  RLINK,R15           CALL THE ROUTINE\n         LM    R0,R15,ECTSAVE      RESTORE THE REGS\n         SR    R0,R0     CLEAR THIS OUT\n         CH    R0,ECINTCOD         SEE IF INTERRUPT CODE\n         BNE   EXITA               IF THERE WAS CODE-RETURN\n         CLI   ECFLAG1,0           WAS SPECIAL CODE STILL 0\n         BNE   EXITA               NO,SO EXIT WITH ERROR FLAG\n         BAL   RLINK,EXADCALC      HAVE ADDRESS RECALCULATED IF NEEDED\n         L     RB2,ECILCMSK        GET PSW BACK\n         LR    RCC,RB2             GET CC AND MASK BACK\n         B     EXFINB              BRANCH THERE, IN CASE PSW CHANGED\n         SPACE 1\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*              ADDRESS CALCULATION SECTION - IF THE ADDRESS VALUES    *\n*        MAY HAVE BEEN CHANGED, OR ARE NOT ALREADY COMPUTED,THIS      *\n*        SECTION FINDS THE USER HIGH ADDRESS AND RELOCATION FACTOR    *\n*        GIVEN REAL LOW AND HIGH ADDRESSES, AND USER LOW ADDRESS.     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nEXADCALC TM    ECFLAG0,$ECADSOK    SEE IF THE ADDR'S NEED FIXING\n         BCR   O,RLINK             RETURN IF CALCULATIONS UNNEEDED\n         OI    ECFLAG0,$ECADSOK    FLAG ADDRS OK, WHICH THEY WILL BE\n         L     R0,ECRADH           GET REAL HIGH ADDRESS LIMIT\n         S     R0,ECRADL           GET LENGTH OF PROGRAM\n         A     R0,ECFADL           ADD TO FAKE LOW ADDRESS\n         ST    R0,ECFADH           STORE THIS IN FAKE HIGHEST\n         SH    R0,=H'256'          FOR @ CHECKING DIFFERENCE\n         ST    R0,ECFADHC          SAVE FOR @ CHECKING EXRANGE\n         L     R0,ECRADL           GET REAL LOWEST ADDRESS\n         S     R0,ECFADL           SUBTRACT TO GET RELOCATION EXEC\n         ST    R0,ECRELOC          SAVE THIS FOR EXECUTION TIME RELOCAT\n         BR    RLINK               RETURN TO CALLING SECTION\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*        MAIN INTERPRETER LOOP HEAD. ALL SUCCESSFUL BRANCHES PASS     *\n*   THROUGH EFINB, WHICH CHECKS FOR ILLEGAL BRANCHES. CONTROL THEN    *\n*   PASSES THROUGH EFIN,WHICH CHECKS FOR LOOPING BEYOND INSTRUCTION   *\n*   COUNT LIMIT.  ALL OTHER INSTRUCTIONS SKIP EFINB AND RETURN        *\n*   DIRECTLY TO EFIN.   THE NEXT INSTRUCTION IS THEN ACCESSED,DECODED *\n*   PARTIALLY FOR 4-WAY BRANCH (RR,RX,SI&RS,SS),AND VARIOUS           *\n*   BOOKKEEPING DETAILS DONE (UPDATING INSTRUCTION ADDRESS,MOVING     *\n*   INSTRUCTION INTO NEXT STACK LOCATION,ETC. )                       *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nEXFINB   LA    RIA,0(RB2)          MOVE BRANCH ADDRESS OVER,REM 1ST BYT\n         C     RIA,ECFADL          COMPARE FOR BELOW LOWEST FAKE\n         BL    EXIAOUT             BRANCHED OUT OF RANGE\n         C     RIA,ECFADH          COMPARE TO NEXT ADDRESS BEYOND AREA\n         BNL   EXIAOUT             ADDRESS OUT OF RANGE-ERROR\n         AIF   (NOT &$ALIGN).EXFT1 SKIP IF MACHINE REQUIRES ALIGN\n         ST    RB2,ECTSAVE         SAVE ADDR: MUST DO CHECK SLOW WAY\n         TM    ECTSAVE+3,X'01'     WAS ADDR ODD\n         BO    EX0C6               YES-BAD PROGRAMMER-JUMP\n.EXFT1   AIF   (&$ALIGN).EXFT2     SKIP IF ALIGN NOT NEEDED\n         LH    R0,0(RB2,RMEM)      QUICK ALIGNEMNT CHECK\n.EXFT2   ANOP\n*              IF TIMER RUNOUT OCCURS, ASSIST SETS ECFLAG1=$ECTIMEX.\n*              EXECUT DISCOVERS THIS NEXT TIME BRANCH IS SUCCESSFUL.\n         AIF   (&$TIMER EQ 0).EXNOTOA       SKIP IF NO TIMER AT ALL\n         CLI   ECFLAG1,$ECTIMEX    HAS FLAG BEEN SET BY TIMER EXIT\n         BE    EXOVRTIM            YES, SO GO THERE, TIME RAN OUT\n.EXNOTOA ANOP\n         SPACE 2\n*              CHECK FOR EXCEEDING TOTAL INSTRUCTION COUNT            *\n*              ALL INSTRUCTIONS BUT SUCCESSFUL BRANCHES ENTER HERE    *\nEXFIN    L     R0,ECILIMT          GET THE COUNTER\nEXTIMDEC BCT   R0,EXGO             DECREMENT COUNTER, BRANCH IF OK\n         ST    R0,ECILIMT          RESTORE INST COUNT FOR STATS(0)\n         MVI   ECFLAG1,$ECTIMEX    SHOW TIME EXCEEDED(INSTR LIMIT)\n         LA    R1,EXCCTIME         SHOW @ TIME MESSAGE\n         B     EXITIA              GO TO FINISH AND EXIT\n         AIF   (&$TIMER EQ 0).EXNOTOB       SKIP IF NO TIMER AT ALL\nEXOVRTIM LA    R1,EXCCTIMB         SHOW TIMER OVER. ECFLAG1 ALREADY SET\n         B     EXITIA              SKIP TO EXIT SECTION\n.EXNOTOB ANOP\nEXGO     ST    R0,ECILIMT          STORE THIS BACK IN LIMIT\n         SPACE 1\n*              INSTRUCTION FETCH AND PRIMARY DECODING SECTION.        *\n         SPACE 1\n         LA    RWK,0(RIA,RMEM)     OBTAIN PHYSICAL REAL ADDRESS\nEXFEXENT L     RSTK,ECSTLINK       OBTAIN ADDRESS OF NEXT STACK SLOT\n         STM   RIA,RCC,ECSTIADD    SAVE INSTRUCTION ADDRESS,CC,MASK\n         MVC   ECSTINST,0(RWK)     MOVE 6 BYTES INTO NEXT SLOT\n         IC    ROP,ECOP            GET OPCODE INTO REGISTER\n         IC    R2,EXOPTAB1(ROP)    GET SECONDARY CODE FOR OPCODES\n         LR    R1,ROP              GET OPCODE WHERE CAN BE CHANGED\n         SRL   R1,6                REMOVE ALL BUT 1ST 2 BITS\n         SLL   R1,2                SHIFT BACK = MULT*4 FOR INDEX\n         AIF   (&$DEBUG).EXSNAP1   SKIP XSNAPS GENERATION IF NOT DEBUG\n         XSNAP LABEL='PRIMARY FETCH',IF=(ECFLAG2,O,X'80',TM),          #\n               STORAGE=(*ECSTENT,*ECB2D2+2,*ECFPREGS,*ECILIMP)\n         LM    RB1,RB2,ECRADL      GET LOW AND HIGH @ POINTERS\n         XSNAP T=NO,LABEL='USER AREA',STORAGE=(*0(RB1),*0(RB2)),IF=(ECF#\n               LAG2,O,X'40',TM)\n.EXSNAP1 ANOP\n         SPACE 1\n*              UPDATE INSTRUCTION COUNTER RIA TO NEXT INSTRUCTION,    *\n*        TAKE 4-WAY BRANCH TO PRIMARY TYPE DECODING SECTIONS.         *\nEXEXLEN  A     $CHN+RIA,EXILENG(R1)    UPDATE RIA**CHANGED BY EXEX*****\nEXPRIME  B     *+4(R1)             TAKE BRANCH FOR PRIMARY PROCESSING\n         B     EXTRR               R1=0 ==> RR INSTRUCTION\n         B     EXTRX               R1=4 ==> RX INSTRUCTION\n         B     EXTSIRS             R1=8 ==> SI OR RS INSTRUCTION\n         B     EXTSS               R1=12 ==> SS INSTRUCTION\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*        RR PRIMARY DECODING - DECODE R1-R2 FIELDS,THEN MAKE          *\n*   SECOND LEVEL BRANCH TO INDIVIDUAL INSTRUCTION PROCESSORS.         *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nEXTRR    BAL   RLINK,EXR1R2        GET R1,R2 FIELDS SEPARATED\n         LH    R1,EXSECRR(R2)      GET SECOND LEVEL BRANCH INDEX VALUE\n         B     EXJUMP(R1)          TAKE BRANCH TO INDIVIUDAL ROUTINES\n         SPACE 4\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*        RX PRIMARY DECODING - DECODE B2-D2 FIELDS,R1-X2 FIELDS,      *\n*   YIELDING 2ND OPERAND ADDRESS IN REGISTER RB2. IF INSTRUCTION IS   *\n*   ONE OF THOSE NOT REQUIRING ADDRESS RELOCATION(I.E. BRANCHES OF    *\n*   SOME TYPE,LOAD ADDRESS) TAKE SECOND LEVEL BRANCH IMMEDIATELY.     *\n*   FOR OTHER INSTRUCTIONS,THE 2ND OPERAND ADDRESS IS CHECKED FOR     *\n*   WITHIN THE PERMITTED RANGE BY EXRANGE, AND THEN THE ADDRESS IS    *\n*   RELOCATED TO THE ACTUAL CORE ADDRESS.  THEN THE SECOND-LEVEL      *\n*   CHOICE IS MADE FOR THE INDIVIDUAL PROCESSORS.                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nEXTRX    BAL   RLINK,EXABD         PERFORM B2-D2 ADDRESS CALCULATION\n         BAL   RLINK,EXR1R2        OBTAIN R1,X2 FIELDS\n         BZ    EXRXNOX             IF X2=0,NO INDEXING NEED BE DONE\n         AL    RB2,ECREGS(RX2)     PERFORM INDEXING OPERATION\n         LA    RB2,0(RB2)          ZAP POSSIBLE 1ST BYTE FROM X2 FIELD\nEXRXNOX  LH    R1,EXSECRX(R2)      GET BRANCH INDEX ADDRESS\n         CH    R2,EXNORNG          COMPARE WITH HIGHEST FOR NO RANGECK\n         BNH   EXJUMP(R1)          TAKE BRANCH TO ROUTINES\n         BAL   RLINK,EXRANGE       HAVE THE RANGE CHECKED FOR THE INST\n         AR    RB2,RMEM            RELOCATE FAKE @ TO REAL @\n         AIF   (&$S370 NE 2).EXTRX SKIP IF NOT SIMULATING S/370'S\n         TM    ECFLAG4,AJONALGN    MUST WE FAKE ALIGNMENT\n         BZ    EXJUMP(R1)          NO--> BRANCH\n         CH    R2,EXALIGN          DOES INSTRUCTION REQUIRE ALIGNMENT\n         BH    EXJUMP(R1)          NO--> BRANCH\n         LTR   RB1,RB2             SAVE FOR LATER, SET CC TO ^=\n         MVC   EXDUBLWD(8),0(RB2)  MOVE MAXIMUM OF 8 BYTES OVER\n         LA    RB2,EXDUBLWD        LOAD ADDRESS OF ALIGNED FIELD\n.EXTRX   ANOP\n         B     EXJUMP(R1)          TAKE BRANCH TO APPROPRIATE ROUTINE\n         SPACE 4\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*        SI-RS PRIMARY DECODING - DECODE B1-D1 FIELD,WITH RESULTING   *\n*   ADDRESS APPEARING IN REGISTER RB2. THEN MAKE SECOND-LEVEL CHOICE  *\n*   TO THE VARIOUS INDIVIDUAL PROCESSORS.                             *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nEXTSIRS  BAL   RLINK,EXABD         ADDRESSING FOR B1-D1 FIELD\n         LH    R1,EXSECSI(R2)      GET SECOND LEVEL JUMP INDEX\n         B     EXJUMP(R1)          TAKE BRANCH TO INDIVIUAL ROUTINE\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*        SS PRIMARY DECODING - DECODE AND CHECK 1ST AND 2ND OPERAND   *\n*   ADDRESSES FOR WITHIN RANGE,USING DECODED VALUES OF L OR L1 AND L2 *\n*   FIELDS AS REQUIRED. AFTER RELOCATING TO ACTUAL MACHINE ADDRESSES, *\n*   MAKE SECOND-LEVEL BRANCH TO INDIVIDUAL PROCESSOR SEGMENTS.        *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nEXTSS    BAL   RLINK,EXABD         HAVE 1ST @ DECODED\n         BAL   RLINK,EXRANGE       CHECK 1ST @ FOR WITHIN RANGE\n         LA    RB1,0(RB2,RMEM)     RELOCATE THE 1ST @ TO REAL @\n         LH    RB2,ECB2D2          GET THE BASE-DISP FOR 2ND @\n         BAL   RLINK,EXABD1        HAVE 2ND @ DECODED\n         SPACE 1\n*              NOTE THAT THE FOLLOWING SEQUENCE IS ESSENTIALLY LIKE   *\n*        THE SECTION EXRANGE.  THIS IS REQUIRED BECAUSE THE 1ST AND   *\n*        2ND OPERANDS OF SS INSTRUCTIONS DO NOT NECESSARILY HAVE THE  *\n*        SAME PROTECTION ATTRIBUTES, I.E. 1ST OPERANDS ARE SOMETIMES  *\n*        STORE PROTECTION VIOLATION CAUSES, WHILE 2ND OPERANDS USUALLY*\n*        CAUSE ONLY FETCH PROTECTION VIOLATIONS, IF ANY.              *\n         C     RB2,ECFADL          IS @ LOWER THAN LOWEST ALLOWED\n         BL    EXSSL               TOO LOW,GO SEE IF REALLY ILLEGAL\n         C     RB2,ECFADHC         COMP WITH ACTUAL HI LIM(ECFADH-256)\n         BL    EXSSL2              @ ACCEPTABLE,GO RELOCATE AND EXECUTE\n         SPACE 1\n*              ADDRESS OUT OF RANGE-CHECK INST TYPE/PROTECTION MODE.  *\nEXSSL    LA    RWK,EXIPROT-64(ROP) GET @ PROTECTION CONTROL BYTE\n         TM    0(RWK),EXPRSTO2+EXPRFET2     ANY CORE ACCESS AT ALL?\n         BO    EXRANOUT            YES,AND @ OUT OF RANGE-GO TO FLAG\n         SPACE 1\n         BZ    EXSSL2              NO IT ISN'T,SO ITS OK ANYWAY\n         TM    ECFLAG0,$ECPROT     OUT OF RANGE,FETCH PROT,IF MODE ON\n         BNZ   EXRANOUT            ABSOLUTE PROTECT MODE-SO PROTECT ERR\n         SPACE 1\nEXSSL2   AR    RB2,RMEM            RELOCATE THE 2ND OP ADDRESS\n         MVC   EXQSS(2),ECOP       MOVE THE OPCODE AND LENGTH(S) OVER\n         LH    R1,EXSECSS(R2)      GET SECOND LEVEL BRANCH INDEX\n         B     EXJUMP(R1)          TAKE BRANCH\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*        SECOND-LEVEL PROCESSOR SECTIONS - THESE SECTIONS PERFORM     *\n*   ALL REQUIRED COMPUTING AFTER INITIAL DECODING HAS BEEN DONE IN    *\n*   RESPECTIVE PRIMARY SECTIONS.                                      *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 4\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*              RR SECOND-LEVEL PROCESSOR SECTION.                     *\n*              TO CONDENSE CODE IN  RR SECTION, REMOVE THE CODE       *\n*        SECTIONS BELONGING TO EXLR AND EXFPRR AND EQU THOSE SYMBOLS  *\n*        TO EXNORMRR INSTEAD                                          *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n*              SET PROGRAM MASK                                       *\nEXSPM    L     RCC,ECREGS(RR1)     PLACE SPECIFIED REG INTO CC REGISTER\n         SPM   RCC                 SET REAL CC-PM TO FAKE CC-PM\n         B     EXFIN               RETURN FOR NEXT INSTRUCTION\n         SPACE 1\n         AIF   (&$PRIVOP).EXSSK    SKIP AND GENERATE RITH CODE-PRIVS OK\nEXSSK    EQU   EX0C2               PRIVILEGEDS NOT ALLOWED-FLAG\nEXISK    EQU   EX0C2               PRIVILEGEDS NOT ALLOWED-FLAG\n         AGO   .EXSVC              SKIP OVER GENERATION OF CODE\n.EXSSK   ANOP\nEXSSK    BAL   RLINK,EX0C2C        GO CHECK FOR SUPERVISOR STATE\nEXISK    BAL   RLINK,EX0C2C        GO CHECK FOR SUPERVISOR STATE\n.EXSVC   ANOP\n         SPACE 1\nEXSVC    L     RWK,ECSVCADS        GET @ SVC CONTROL TABLE,IF EXISTS\n         LTR   RWK,RWK             ARE SVC'S ALLOWED\n         BZ    EX0C2               NO SVC'S AT ALL,SO ERROR\n         IC    RR1,ECI2            GET IMMEDIATE FIELD\n         IC    RR1,0(RR1,RWK)      GET SVC OFFSET BYTE TO @ ROUTINE\n         SLA   RR1,2               MULT*4 FOR INDEX TO FULLWORDS\n         BZ    EX0C2               IF =0,MAKE IT PRIVILEGED OPERATION\n         L     RWK,256(RWK)        GET @ SVC ROUTINE @ TABLE\n         L     RWK,0(RR1,RWK)      PICK UP ACTUAL @ SVC ROUTINE\n         B     EXCALL              GO TO CALL ROUTINE\n*        **NOTE** AN SVC CONTROL TABLE IS 260 BYTES LONG, CONTAINING  *\n*        256 BYTES OF INDIVIUDAL SVC INDICATORS, AND 1 FULLWORD PTR.  *\n         EJECT\n*              REGULAR RR INSTRUCTIONS - 3 ENTRIES TO SEQUENCE -      *\n*              LR        (SEPARATE SINCE CURRENT CC IS NOT CHANGED)   *\n*              NR,CLR,OR,XR,CR,AR,SR,ALR,SLR -   NORMALS              *\n*              LPR,LNR,LTR,LCR     (DO NOT NEED R1 LOADED)            *\nEXLR     L     RWK,ECREGS(RR2)     GET SECOND OPERAND\n         ST    RWK,ECREGS(RR1)     PLACE INTO FIRST OPERAND\n         B     EXFIN               RETURN FOR NEXT INSTRUCTION\n         SPACE 1\nEXNORMRR L     RWK,ECREGS(RR1)     OBTAIN 1ST OPERAND\nEXLPNTR  L     RR2,ECREGS(RR2)     OBTAIN 2ND OPERAND\n         STC   ROP,EXQRR           PLACE ACTUAL OPCODE INTO INST\nEXQRR    LR    $CHN+RWK,RR2        **RIGHT OPCODE IS ENTERED IN *******\n         ST    RWK,ECREGS(RR1)     SAVE IN FAKE 1ST OPERAND LOCATION\n         BAL   RCC,EXFIN           GET CC, RETURN FOR NEXT INST\n         SPACE 1\n         AIF   (&$FLOTEX).EXXFPRR  GO GENERATE CODE IF XFP OK\nEXXFPRR  EQU   EX0C1               NOTE XFP NOT ALLOWED\n         AIF   (&$FLOTE).EXFPRR    GO GENERATE IF FLOATINGS OK\nEXFPRR   EQU   EX0C1               NOTE WE DO NOT ALLOW FLOATINGS\n         AGO   .EXFPRR2\n.EXXFPRR ANOP\nEXXFPRR  EQU   *                   CODE FOR XFP SAME AS REGULAR FP\n.EXFPRR  ANOP\n         SPACE 2\n*              RR FLOATING POINT INSTRUCTIONS.                        *\nEXFPRR   SPM   RCC                 SET THE CONDITION CODE\n         EX    0,ECOP              EXECUTE THE ACTUAL INSTRUCTION\n         BAL   RCC,EXFIN           GET CC, RETURN FOR NEXT INST\n.EXFPRR2 ANOP\n         SPACE 2\n         AIF   (&$S370 NE 0).EXLONG1 SKIP IF GENERATING S/370'S\nEXLONG   EQU   EX0C1               NOTE S/370 RR'S NOT ALLOWED\n         AGO   .EXLONG3            SKIP OVER CODE GENERATION\n.EXLONG1 ANOP\n*        ADDRESS CHECKING CODE FOR CLCL, AND MVCL\nEXLONG   EQU   *                   COMMON CODE FOR MVCL, CLCL CHECKING\n         TM    ECR1R2,X'11'        DID HE SPECIFY EVEN REGS?\n         BNZ   EX0C6               NO--> SPECIFICATION ERROR\n         L     R0,EXLONGMK         LOAD MASK TO ZAP TOP OF REGS\n         LA    R1,ECREGS(RR1)      GET ADDRESS OF FIRST REGISTER PAIR\n         LM    RB1,RB2,0(R1)       LOAD FIRST SET OF REGISTERS\n         NR    RB1,R0              GET RID OF UPPER BYTE OF ADDRESS\n         NR    RB2,R0              GET RID OF UPPER BYTE OF LENGTH\n         BZ    EXLONG2             IF LENGTH = 0, DON'T CHECK ADDRESS\n         C     RB1,ECFADL          IS ADDRESS TOO LOW?\n         BL    EXLONG1             YES - BRANCH TO CHECK PROTECTION\n         LR    RWK,RB1             COPY ADDRESS TO WORK REGISTER\n         AR    RWK,RB2             COMPUTE HIGHEST ADDRESS\n         C     RWK,ECFADH          IS IT ABOVE MAXIMUM FOR USER?\n         BL    EXLONG2             NO - BRANCH AROUND PROTECTION CHECK\nEXLONG1  CLI   ECOP,14             IS THIS A MVCL INSTRUCTION\n         BE    EX0C4               YES - PROTECTION ERROR\n         TM    ECFLAG0,$ECPROT     IS FETCH PROTECT ON?\n         BNZ   EX0C4               YES - PROTECTION ERROR\n         SPACE 2\n*        FIRST ADDRESS OK - CHECK SECOND\nEXLONG2  LA    R2,ECREGS(RR2)      GET ADDRESS OF SECOND REG. PAIR\n         LM    RR1,RR2,0(R2)       LOAD SECOND SET OF REGISTERS\n         NR    RR1,R0              GET RID OF UPPER BYTE AF ADDRESS\n         NR    RR2,R0              GET RID OF UPPER BYTE OF LENGTH\n         BZ    EXLONG4             IF LENGTH = 0, DON'T CHECK ADDRESS\n         C     RR1,ECFADL          IS ADDRESS TOO LOW?\n         BL    EXLONG3             YES - BRANCH TO CHECK FOR PROTECTION\n         LR    RWK,RR1             COPY ADDRESS INTO WORK REGISTER\n         AR    RWK,RR2             COMPUTE HIGHEST ADDRESS\n         C     RWK,ECFADH          IS IT ABOVE USER MAXIMUM\n         BL    EXLONG4             NO - BRANCH AROUND ERROR CHECK\nEXLONG3  TM    ECFLAG0,$ECPROT     IS ABSOLUTE PROTECT ON\n         BNZ   EX0C4               YES - PROTECTION ERROR\n         SPACE 2\n*        BOTH ADDRESSES ARE OK - RELOCATE THEM AND PERFORM COMMAND\nEXLONG4  ALR   RB1,RMEM            RE-LOCATE ADDRESS TO ACTUAL\n         ALR   RR1,RMEM            RE-LOCATE ADDRESS TO ACTUAL\n         SPACE 2\n         AIF   (&$S370 NE 1).EXLONG2 SKIP IF NOT ON REAL 370\n         L     RB2,4(,R1)          RESTORE UPPER BYTES IN LENGTH REGS\n         L     RR2,4(,R2)          RESTORE UPPER BYTES IN LENGTH REGS\n         STC   ROP,EXQLONG         STORE IN OPCODE\nEXQLONG  CLCL  RB1,RR1             *** OPCODE STORED IN ***\n         BALR  RCC,0               CAPTURE COND CODE\n         AGO   .EXLONG4\n.EXLONG2 ANOP\n         CLI   ECOP,14             IS THIS A MVCL COMMAND?\n         BE    EXMVCL              YES - BRANCH\n         SPACE 2\n*        CODE FOR CLCL COMMAND\n         LTR   RR2,RR2             SECOND LENGTH = 0?\n         BZ    EXCLCL6             YES - BRANCH TO CHECK FIRST LENGTH\n         LTR   RB2,RB2             FIRST LENGTH = 0?\n         BZ    EXCLCL2             YES - BRANCH TO USE PAD & OPND 2\nEXCLCL1  CLC   0(1,RB1),0(RR1)     COMPARE A CHARACTER FROM EACH FIELD\n         BNE   EXCLCL5             IF NOT EQUAL, WE ARE DONE - BRANCH\n         LA    RB1,1(,RB1)         INCREMENT POINTERS\n         LA    RR1,1(,RR1)         INCREMENT POINTERS\n         BCT   RB2,EXCLCL3         DECREMENT FIRST LENGTH, BRANCH ^= 0\n         B     EXCLCL7             LENGTH = 0 - BRANCH INTO PAD LOOP\nEXCLCL2  CLC   4(1,R2),0(RR1)      COMPARE PAD TO OPND 2\n         BNE   EXCLCL5             IF NOT EQUAL, WE ARE DONE - BRANCH\n         LA    RR1,1(,RR1)         INCREMENT POINTER\nEXCLCL7  BCT   RR2,EXCLCL2         DECREMENT SECOND COUNT - BRANCH ^= 0\n         B     EXCLCL5             IF LENGTH = 0, OPNDS = - WE'RE DONE\nEXCLCL3  BCT   RR2,EXCLCL1         DECREMENT SECOND LENGTH, BRANCH ^= 0\nEXCLCL4  CLC   0(1,RB1),4(R2)      COMPARE FIRST OPND & PAD\n         BNE   EXCLCL5             IF NOT EQUAL, WE ARE DONE - BRANCH\n         LA    RB1,1(,RB1)         INCREMENT POINTER\n         BCT   RB2,EXCLCL4         DECREMENT LENGTH, BRANCH ^= 0\nEXCLCL5  BAL   RCC,EXLONG5         CAPTURE CON CODE AND RETURN\nEXCLCL6  LTR   RB2,RB2             FIRST LENGTH = 0?\n         BNZ   EXCLCL4             NO, USE 1ST OPND AND PAD\n         BAL   RCC,EXLONG5         GET COND CODE (=0) AND RETURN\n         SPACE 2\n*        CODE FOR MVCL COMMAND\nEXMVCL   EQU   *                   CODE FOR MVCL COMMAND\n         LR    R0,RB2              ASSUME FIRST LENGTH SMALLEST\n         CR    RB2,RR2             COMPARE THE LENGTHS\n         BALR  RCC,0               CAPTURE CON CODE\n         BL    *+6                 IF FIRST LOWER, BRANCH\n         LR    R0,RR2              SECOND LENGTH MUST BE THE SMALLER\n         LTR   R0,R0               IS SMALLEST LENGTH = 0?\n         BZ    EXMVCL3             IF SMALLER = 0, BRANCH\n         SPACE 2\n*        FOLLOWING CODE CHECKS FOR DESTRUCTIVE OVERLAP\n         CR    RB1,RR1             IS 1ST FIELD AFTER SECOND?\n         BNH   EXMVCL1             NO - NO OVERLAP - BRANCH\n         AR    RWK,RMEM            RE-LOCATE HIGH OPND 2 ADDRESS\n         CR    RB1,RWK             IS 1ST FIELD AFTER END OF 2ND\n         BNL   EXMVCL1             YES - NO OVERLAP - BRANCH\n         TM    *+1,1               SET CON CODE TO OVERFLOW (3)\n         BAL   RCC,EXLONG5         CAPTURE CON CODE AND RETURN\n         SPACE 2\nEXMVCL1  SR    RB2,R0              DECREMENT LENGTHS BY THE SMALLER\n         SR    RR2,R0              DECREMENT LENGTHS BY THE SMALLER\nEXMVCL2  MVC   0(1,RB1),0(RR1)     MOVE A BYTE\n         LA    RB1,1(,RB1)         INCREMENT POINTERS\n         LA    RR1,1(,RR1)         INCREMENT POINTERS\n         BCT   R0,EXMVCL2          DECREMENT LENGTH, IF ^= 0, BRANCH\nEXMVCL3  LTR   RB2,RB2             DO WE NEED PADDING?\n         BZ    EXLONG5             NO - WE ARE DONE - BRANCH\n         MVC   *+7(1),4(R2)        MOVE PAD CHAR INTO MVI INSTRUCTION\nEXMVCL4  MVI   0(RB1),$CHN         MOVE PAD TO FIRST OPRND\n         LA    RB1,1(,RB1)         INCREMENT POINTER\n         BCT   RB2,EXMVCL4         DECREMENT LENGTH - IF ^= 0, BRANCH\n         SPACE 2\n*        COMMON CLCL, MVCL EXIT CODE\nEXLONG5  XC    5(3,R1),5(R1)       ZAP LOWER PART OF LENGTH IN CORE\n         XC    5(3,R2),5(R2)       ZAP LOWER PART OF LENGTH IN CORE\n         O     RB2,4(,R1)          PUT UPPER BYTE BACK INTO REG\n         O     RR2,4(,R2)          PUT UPPER BYTE BACK INTO REG\n         L     R0,EXLONGMK         GET MASK TO ZAP UPPER BYTE OF REGS\n.EXLONG4 ANOP\n         SPACE 2\n*        OPERATION COMPLETE - RESTORE REGISTERS AND RETURN\n         SLR   RB1,RMEM            DE-RELOCATE FINAL ADDRESSES\n         SLR   RR1,RMEM            DE-RELOCATE FINAL ADDRESSES\n         NR    RB1,R0              ZAP UPPER BYTES OF ADDRESS REGS\n         NR    RR1,R0              ZAP UPPER BYTES OF ADDRESS REGS\n         STM   RB1,RB2,0(R1)       PUT REGISTERS BACK INTO CORE\n         STM   RR1,RR2,0(R2)       PUT REGISTERS BACK INTO CORE\n         SR    R2,R2               RESTORE R2 AS BYTE REGISTER\n         B     EXFIN               RETURN\n.EXLONG3 ANOP\n         EJECT\n*              RR-RX OVERLAP SECOND-LEVEL PROCESSOR SECTION.          *\n         SPACE 1\n*              BRANCH AND LINK  (BALR,BAL)                            *\nEXBALR   MVI   EXILC,X'40'         SET ILC RIGHT\n         LR    RB2,RIA             NO BRANCH WILL OCCUR-SET UP FOR REST\n         BZ    EXBAL1              IF R2=0, NO BRANCH WILL OCCUR\n         L     RB2,ECREGS(RR2)     BRANCH DOES OCCUR-LOAD ADDR IN\n         B     EXBAL1              SKIP CODE TO SET FILC\nEXBAL    MVI   EXILC,X'80'         SET ILC UP RIGHT\nEXBAL1   N     RCC,=XL4'3F000000'  LEAVE ONLY CC-PM IN REGISTER RCC\n         AL    RCC,EXILC           ADD ILC INTO PSW BEING BUILT\n         ALR   RIA,RCC             NOW HAVE ILC-CC-PM-IA FILEDS\n         ST    RIA,ECREGS(RR1)     PLACE BUILT PSW INTO FAKE REG\n         B     EXFINB              BRANCH TAKEN-RETURN\n         SPACE 1\n*              BRANCH ON COUNT  (BCTR,BCT)                            *\nEXBCTR   BNZ   EXBCTR1             IF R2=0,NO BRANCH WILL OCCUR\n         L     RWK,ECREGS(RR1)     OBTAIN VALUE OF REGISTER\n         BCTR  RWK,0               DECREMENT THE VALUE\n         ST    RWK,ECREGS(RR1)     RESTORE IT TO FAKE REGISTER\n         B     EXFIN               RETURN FOR NEXT INSTRUCTION\n         SPACE 1\nEXBCTR1  L     RB2,ECREGS(RR2)     GET BRANCH ADDRESS IN SAME AS BCT\nEXBCT    L     RWK,=F'-1'          PUT -1 IN\n         A     RWK,ECREGS(RR1)               ADD VALUE IN (DOING BCT)\n         ST    RWK,ECREGS(RR1)     RESTORE DECREMENTED VALUE TO FAKE RG\n         BNZ   EXFINB              IF NOT=0, BRANCH IS TAKEN\n         B     EXFIN               BRANCH FAILED\n         SPACE 1\n*              BRANCH ON CONDITION  (BCR,BC)                          *\nEXBCR    BZ    EXFIN               IF R2 IS 0, NO BRANCH OCCURS\n         L     RB2,ECREGS(RR2)     BRANCH ADDRESS TO FIT WITH BC\nEXBC     SLL   RR1,2               GET MASK BACK IN RIGHT SPOT\n         SPM   RCC                 SET REAL CC = FAKE CC\n         STC   RR1,EXQBC+1         STORE INTO MASK FIELD\nEXQBC    BC    $CHN,EXFINB         **MASK STORED IN**\n         B     EXFIN               BRANCH FIALED\n         SPACE 1\n*              MULTIPLY AND DIVIDE  (MR,DR,M,D)                       *\nEXMRDR   LA    RB2,ECREGS(RR2)     MAKE ADDRESS COMPATIBLE WITH M-D\nEXMD     TM    ECR1R2,X'10'        MAKE SURE R1 IS EVEN SPECIFICATION\n         BO    EX0C6               SPECIFICATION ERROR-ODD REGISTER\n         LA    RR1,ECREGS(RR1)     OBTAIN ACTUAL ADDRESS OF FAKE R1\n         LM    R0,R1,0(RR1)        OBTAIN 2 FAKE REGISTER VALUES\n         MVN   EXQMD(1),ECOP       MOVE CODE - SAYS M OR D\nEXQMD    M     $CHN+R0,0(RB2)      **CHANGED TO M OR D DURING EXEC*****\n         STM   R0,R1,0(RR1)        RESTORE THE REGISTERS TO THE FAKES\n         B     EXFIN               RETURN FOR NEXT INSTRUCTION\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*              RX SECOND-LEVEL PROCESSOR SECTION.                     *\n*              TO CONDENSE CODE IN RX SECTION, THE CODE BELONGING     *\n*        TO THE SECTIONS BEGINNING EXLOADS,EXSTORS,EXLA, AND EXFPRX   *\n*        SHOULD BE EQU'D TO EXNORMRX, AND THE ACTUAL CODE OF THOSE    *\n*        SECTIONS REMOVED.                                            *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n*              RX NORMAL (IC,CH,AH,SH,MH,N,CL,O,X,C,A,S,AL,SL)        *\nEXNORMRX L     RWK,ECREGS(RR1)     OBTAIN 1ST OPERAND\n         STC   ROP,EXQNORMR        STORE OPCODE IN\n         SPM   RCC                 SET REAL CC = FAKE CC\nEXQNORMR IC    $CHN+RWK,0(RB2)     **WILL BE CHANGED TO RIGHT OPCODE***\n         ST    RWK,ECREGS(RR1)     PLACE RESULT INTO FAKE REGISTER\n         BAL   RCC,EXFIN           GET CC, RETURN FOR NEXT INST\n         SPACE 1\n*              EXECUTE -USES SECTION OF PRIMARY DECODING SECTION      *\nEXEX     LH    RWK,0(RB2)          QUICK CHECK FOR ALIGNMENT ERROR\n         CLI   0(RB2),X'44'        MAKE SURE NOT AN EXECUTE\n         BE    EX0C3               EXECUTE INTERRUPT\n         LR    RWK,RB2             PUT ADDRESS WHERE EXPECTED\n         MVC   EXEXLEN(2),EXEXBRNC REPLACE ADD BY BR RLINK\n         BAL   RLINK,EXFEXENT      GO BACK AND DO COMMON SECTION\n         SPACE 1\n*              THE FOLLOWING EXECUTED AFTER PRIMARY DECODING DONE     *\n         SR    RB2,RMEM            DE-RELOCATE INSTR @\n         ST    RB2,ECSTIADD        STORE INTO INSTR STACK FOR DUMP\nEXEXOR   MVC   EXEXLEN(2),EXEXLEN2 FIX UP A TO BE ONE AGAIN\n         LTR   RR1,RR1             CHECK FOR R1 OPERAND BEING USED\n         BZ    EXPRIME+4(R1)       NOTHING TO OR IN-BRANCH\n         LA    RB2,ECREGS+3(RR1)   ADDRESS OF LAST BYTE OF GIVEN REG\n         OC    ECR1R2,0(RB2)       OR BYTE INTO INSTRUCTION\n         B     EXPRIME+4(R1)       TAKE PRIMARY BRANCH\nEXEXLEN2 A     RIA,EXILENG(R1)     INST TO REPLACE MODIFIED ONE\n         ORG   *-2                 WE ONLY NEED 1ST 2 BYTES OF LAST INS\nEXEXBRNC BR    RLINK               WILL BE MOVED IN FOR EXECUTE\n         SPACE 1\n*              RX LOAD OPERATIONS(NO CC SETTING)  (LH,CVB,L)          *\nEXLOADS  STC   ROP,EXQLOAD         STORE OPCODE IN\nEXQLOAD  L     $CHN+RWK,0(RB2)     ** OPCODE WILL BE MOVED IN *********\n         ST    RWK,ECREGS(RR1)     PLACE RESULT INTO FAKE REG\n         B     EXFIN               RETURN FOR NEXT INSTRUCTION\n         SPACE 1\n*              RX STORE OPERATIONS  (NO CC SETTING)  (STH,CVD,STC,ST) *\nEXSTORS  L     RWK,ECREGS(RR1)     OBTAIN 1ST OPERAND\n         STC   ROP,EXQSTORS        STORE OPCODE INTO INST\nEXQSTORS ST    RWK,0(RB2)          ** OPCODE WILL BE CHANGED***********\n         AIF   (&$S370 NE 2).EXSTORS SKIP IF NOT SIMULATING S/370\n         BZ    EXFIN               IF CHECKING ALIGNMENT, RETURN\n         MVC   0(8,RB1),EXDUBLWD   PUT ALTERED CORE BACK IN RIGHT PLACE\n.EXSTORS ANOP\n         B     EXFIN               RETURN FOR NEXT INSTRUCTION\n         SPACE 1\n*        LOAD ADDRESS  LA                                             *\nEXLA     ST    RB2,ECREGS(RR1)     PUT RESULT IN DESIRED FAKE REGISTER\n         B     EXFIN               RETURN FOR NEXT INSTRUCTION\n         AIF   (&$FLOTEX).EXXFPRX  SKIP IF WE HAVE EXTENDED FP\nEXXFPRX  EQU   EX0C1               NOTE INSTRUCTIONS NOT ALLOWED\n         AIF   (&$FLOTE).EXFPRX    GO GEN IF FLOATINGS ALLOWED\nEXFPRX   EQU   EX0C1               NOTE FLOATINGS NOT ALLOWED\nEXFPRXST EQU   EX0C1               NOTE FLOATINGS NOT ALLOWED\n         AGO   .EXFPRX2            SKIP OVER GENERATION\n.EXXFPRX ANOP\nEXXFPRX  EQU   *                   CODE FOR EXTENDED FLOATINGS\n.EXFPRX  ANOP\n         SPACE 1\n*        FLOATING POINT RX INSTRUCTIONS.                              *\nEXFPRX   EQU   *                   ODD REG CHECK DONE WITH SPIE\n         STC   ROP,EXQFPRX         STORE OPCODE IN\n         SLL   RR1,2               GET R1 FIELD BACK INTO PLACE\n         STC   RR1,EXQFPRX+1       STORE R1 FIELD INTO INST ALSO\n         SPM   RCC                 SET THE CONDITION CODE\nEXQFPRX  STD   $,0(,RB2)           **OPCODE AND R1 FIELDS STORED IN****\n         BAL   RCC,EXFIN           GET CC, RETURN FOR NEXT INST\n         AIF   (&$S370 EQ 2).EXFPRX1 SKIP IF SIMULATING S/370\nEXFPRXST EQU   EXFPRX              CODE FOR STORES SAME AS OTHERS\n         AGO   .EXFPRX2            SKIP AROUND CODE GENERATION\n.EXFPRX1 ANOP\n         SPACE 2\n*        CODE FOR FLOATING POINT STORES WHEN FAKING ALIGNMENT\nEXFPRXST EQU   *                   CODE FOR FLOATING POINT STORES\n         STC   ROP,EXQFPRXS        STORE OPCODE IN\n         SLL   RR1,2               GET R1 FIELD BACK INTO PLACE\n         STC   RR1,EXQFPRXS+1      STORE R1 FIELD INTO INST ALSO\nEXQFPRXS STD   $,0(,RB2)           **OPCODE AND R1 FIELDS STORED IN****\n         BZ    EXFIN               IF ALIGNMENT CHECKING, RETURN\n         MVC   0(8,RB1),EXDUBLWD   PUT ALTERED CORE BACK IN RIGHT PLACE\n         B     EXFIN               RETURN\n.EXFPRX2 ANOP\n         SPACE 2\n         AIF   (NOT &$XIOS).EXCONT SKIP IF NO XMACROS\n*              XDECO - EXTENDED DECIMAL OUTPUT INSTRUCTION.           *\n*        SPECIAL RX INSTRUCTION CONVERTS REGISTER VALUE TO EDITED     *\n*        12-BYTE DECIMAL FIELD.  (X'52' OPCODE).                      *\nEXXDECO  L     R0,ECREGS(RR1)      GET VALUE OF THE REGISTER\n         XDECO R0,0(RB2)           CONVERT THE VALUE\n         B     EXFIN               GO FOR NEXT INSTRUCTION\n         SPACE 1\n*              XDECI - EXTENDED DECIMAL INPUT INSTRUCTION.            *\n*        SPECIAL INPUT CONVERTER, SCANS 1-9 DIGIT, SIGNED/UNSIGNED    *\n*        DECIMAL NUMBERS WITH ANY # PRECEDING BLANKS. SETS CC TO 0,1,2*\n*        ACCORDING TO VALUE OF RESULT.  CC=3 IF >9 DIGITS, OR 1ST     *\n*        CHARACTER NOT +, -, DIGIT, OR + OR - WITHOUT DIGIT FOLLOWING.*\n*        OPCODE IS HEX '53'  (RX FORMAT).                             *\nEXXDECI  XDECI R0,0(RB2)           CONVERT AND SCAN VALUE\n         BALR  RCC,0               SAVE THE CC\n         BO    *+8                 SKIP STORE IF VALUE WAS BAD\n         ST    R0,ECREGS(RR1)      SAVE THE CONVERTED VALUE IF OK\n         SR    R1,RMEM             DE-RELOCATE THE SCAN PTR VALUE\n         ST    R1,ECREG1           SAVE SCAN PTR IN USER REG 1\n         B     EXFIN               GO BACK FOR NEXT INSTR\n         SPACE 1\n         AIF   (NOT &$HEXI).EXNOHXI    SKIP OF NO XHEXI\n*              XHEXI-EXTENDED HEXADECIMAL INPUT INSTRUCTION           *\n*        SPECIAL INPUT MACRO, SCANS 1-8 DIGITS.     SKIPS LEADING     *\n*        BLANKS. SETS CONDITION CODE TO 3 IF ILLEGAL HEX CHARACTER    *\n*        FOUND.  IF GREATER THAN 8 DIGITS FOUND R1 POINTS TO 9TH ELSE *\n*        R1 POINTS TO FIRST NON-HEX CHARACTER IN STRING               *\n*        (X'61' OPCODE)                                               *\nEXXHEXI  XHEXI R0,0(RB2)               CONVERT AND SCAN VALUE\n         BALR  RCC,0                   SAVE THE CC\n         BO    *+8                     SKIP STORE IF VALUE WAS BAD\n         ST    R0,ECREGS(RR1)          STORE CONVERTED VALUE IF OK\n         SR    R1,RMEM                 DE-RELOCATE SCAN POINTER VALUE\n         ST    R1,ECREG1               SAVE SCAN POINTER IN USER R1\n         B     EXFIN                   GO FOR NEXT INSTRUCTION\n         AGO   .EXCKHXO                CHECK IF XHEXO ALLOWED\n.EXNOHXI ANOP\nEXXHEXI  EQU   EX0C1                   INVALID OP-CODE\n.EXCKHXO AIF   (NOT &$HEXO).EXNOHXO    SKIP IF NOT XHEXO ALLOWED\n*              XHEXO-EXTENDED HEXADECIMAL OUTPUT MACRO                *\n*        SPECIAL RX INSTRUCTION CONVERTS REGISTER VALUE TO OUTPUT     *\n*        8 BYTE FORM.  (X'62' OPCODE).                                *\nEXXHEXO  L     R0,ECREGS(RR1)          GET VALUE OF THE REGISYER\n         XHEXO R0,0(RB2)               CONVERT VALUE\n         B     EXFIN                   GET NEXT INSTRUCTION\n         AGO   .EXCONT\n.EXNOHXO ANOP\nEXXHEXO  EQU   EX0C1                   INVALID OP CODE\n.EXCONT  ANOP\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*              SI SECOND-LEVEL PROCESSOR SECTION                      *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n*              ALL NORMAL SI'S - OP  D(B),I2                          *\nEXSI     BAL   RLINK,EXRANGE       CHECK ADDRESS FOR IN RANGE\n         AR    RB2,RMEM            RELOCATE TO REAL @\n         MVC   EXQSI(2),ECOP       MOVE OPCODE AND I2 FIELD IN\n         SPM   RCC                 SET REAL CON-CODE= FAKE ONE\nEXQSI    TM    0(RB2),$CHN         ** OP AND I2 WILL BE MOVED IN*******\n         BAL   RCC,EXFIN           GET CC, RETURN FOR NEXT INST\n         SPACE 1\n         AIF   (&$DEBUG).EXDIAG1   SKIP IF NOT  DEBUG MODE\n*              DIAG-PSEUDO SI INSTRUCTION USED FOR DEBUGGING PURPOSES *\nEXDIAG   MVC   ECFLAG2,ECI2        SUPPLY CONTROL FLAG TO BYTE\n         B     EXFIN               GO BACK FOR NEXT INSTRUCTION\n.EXDIAG1 ANOP\n         SPACE 1\n         AIF   (&$P370).EXLCTL     SKIP IF PRIVILEGED 370'S ALLOWED\nEXLCTL   EQU   EX0C2               NO PRIVILEGED 370 OPS ALLOWED\nEXSTCTL  EQU   EX0C2               NO PRIVILEGED 370 OPS ALLOWED\nEXP370   EQU   EX0C2               NO PRIVILEGED 370 OPS ALLOWED\n         AGO   .EXNP370            SKIP OVER CODE GENERATION\n.EXLCTL  ANOP\nEXLCTL   BAL   RLINK,EX0C2C        GO CHECK FOR SUPERVISOR STATE\nEXSTCTL  BAL   RLINK,EX0C2C        GO CHECK FOR SUPERVISOR STATE\nEXP370   BAL   RLINK,EX0C2C        GO CHECK FOR SUPERVISOR STATE\n.EXNP370 ANOP\n         AIF   (&$PRIVOP).EXSIO    GENERATE CODE,IF PRIVILEGEDS EXIST\nEXSIO    EQU   EX0C2               NO PRIVILEGED OPS ALLOWED\nEXTIO    EQU   EX0C2               NO PRIVILEGED OPS ALLOWED\nEXHIO    EQU   EX0C2               NO PRIVILEGED OPS ALLOWED\nEXSSM    EQU   EX0C2               NO PRIVILEGED OPS ALLOWED\nEXTCH    EQU   EX0C2               NO PRIVILEGED OPS ALLOWED\nEXLPSW   EQU   EX0C2               NO PRIVILEGED OPS ALLOWED\nEXWRD    EQU   EX0C2               NO PRIVILEGED OPS ALLOWED\nEXRDD    EQU   EX0C2               NO PRIVILEGED OPS ALLOWED\n         AGO   .EXNOPRV            SKIP OVER CODE GENERATION\n.EXSIO   ANOP\nEXSIO    BAL   RLINK,EX0C2C        GO CHECK FOR SUPERVISOR STATE\nEXTIO    BAL   RLINK,EX0C2C        GO CHECK FOR SUPERVISOR STATE\nEXHIO    BAL   RLINK,EX0C2C        GO CHECK FOR SUPERVISOR STATE\nEXTCH    BAL   RLINK,EX0C2C        GO CHECK FOR SUPERVISOR STATE\nEXSSM    BAL   RLINK,EX0C2C        GO CHECK FOR SUPERVISOR STATE\nEXLPSW   BAL   RLINK,EX0C2C        GO CHECK FOR SUPERVISOR STATE\nEXWRD    BAL   RLINK,EX0C2C        GO CHECK FOR SUPERVISOR STATE\nEXRDD    BAL   RLINK,EX0C2C        GO CHECK FOR SUPERVISOR STATE\n.EXNOPRV ANOP\n         AIF   (&$REPL GT 0).EXNREP0    SKIP IF REPL OPTION ALLOWED\nEXXREPL  EQU   EX0C1               NO REPLACEMENT: MAKE ILLEGAL OP\n.EXNREP0 AIF   (&$REPL EQ 0).EXNREPL    SKIP IF NO REPLACEMENT\n         SPACE 2\nEXXREPL  EQU   *                   CODE FOR XREPL COMMAND -REPLACE\n         BAL   RLINK,EXRANGE       HAVE @ CHECKED FOR RANGE\n         AR    RB2,RMEM            RELOCATE TO REAL @\n         SPACE 1\n         CLI   ECI2,0              WAS IT SET RFLAG TYPE XREPL\n         BH    EXXREPL1            NO, SKIP TO NEXT TYPE\n         MVC   ECRFLAG,0(RB2)      SET RFLAG FROM USER LOCATION\n         B     EXFIN               GO FOR NEXT INSTR\n         SPACE 1\nEXXREPL1 CLI   ECI2,1              WAS IT FETCH RFLAG TYPE\n         BH    EXXREPL2            NO, SKIP TO NEXT TYPE\n         MVC   0(L'ECRFLAG,RB2),ECRFLAG     FETCH THE FLAG TO USER AREA\n         B     EXFIN               GO FOR NEXT INSTR\n         SPACE 1\nEXXREPL2 CLI   ECI2,2              WAS IT INSTRUCTION COUNT\n         BH    EXXREPL3            NO, GO ON TO NEXT\n         MVC   0(4,RB2),ECILIMT    MOVE TEMPORARY INSTRUCTION COUNT OVE\n         B     EXFIN               GO FOR NEXT INSR\nEXXREPL3 EQU   EXFIN               ILLEGAL I2 FIELD, IGNORE.\n.EXNREPL ANOP\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*              RS SECOND-LEVEL PROCESSOR SECTION.                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n*              BRANCH ON INDEX  (BXH,BXLE)                            *\nEXRSBX   BAL   RLINK,EXR1R2        GO DECODE R1-R3 FIELDS\n         L     R0,ECREGS(RR3)      OBTAIN REGISTER SPECIFIED BY R3 FLD\n         L     R1,ECREGS+4(RR3)    GET NEXT REGISTER BEYOND\n         TM    ECR1R3,X'1'         WAS REGISTER ODD\n         BZ    *+6                 IF EVEN REG,SET UP OK,SKIP NEXT INST\n         LR    R1,R0               R3 WAS ODD-SO USE SAME VALUE\n         STC   ROP,EXQRSBX         STORE OPCODE INTO INSTRUCTION\n         L     RWK,ECREGS(RR1)     OBTAIN R1 FIELD VALUE\nEXQRSBX  BXH   $CHN+RWK,R0,EXRSBX1 ** CHANGED TO EITHER BXH-BXLE*******\n         ST    RWK,ECREGS(RR1)     BRANCH FAILED-BUT STORE REG BACK\n         B     EXFIN               RETURN FOR NEXT INSTRUCTION\nEXRSBX1  ST    RWK,ECREGS(RR1)     RESTORE UPDATED REGISTER\n         B     EXFINB              GO TO FINISH-SUCC BRANCH\n         SPACE 1\n*              LOAD/STORE MULTIPLE (LM,STM) *CODE MAY NOT BE OBVIOUS* *\nEXLMSTM  BAL   RLINK,EXR1R2        GET R1 AND R3 FIELDS\n         AIF   (&$S370 NE 2).EXLMSTM SKIP IF NOT SIMULATING S/370\n         TM    ECFLAG4,AJONALGN    SHOULD ALIGNMENT BE CHECKED\n         BO    *+8                 NO - BRANCH AROUND CHECK\n.EXLMSTM ANOP\n         L     R0,0(RB2,RMEM)      QUICK CHECK FOR FULLWORD ALIGNMENT\n         LA    R1,4(RR3)           OBTAIN  1 PART OF LENGTH VALUE\n         CR    RR1,RR3             IS R1 FIELD <= R3 FIELD\n         BNH   EXLMSTM1            SKIP OVER IF EASY CASE(R1<R3)\n         SPACE 1\n         LR    R2,R1               R2 NOW = (RR3)+4\n         LA    R1,64               OBTAIN VALUE\n         SR    R1,RR1              R1 = 64-(RR1)\n         B     EXLMSTM2            PROPER LENGTHS SET UP IN R1,R2\n         SPACE 1\nEXLMSTM1 SR    R1,RR1              R1 = (RR3)-(RR1)+4 - 1ST,ONLY LENGTH\n         SR    R2,R2               CLEAR 2ND LENGTH,SINCE ONLY 1 USED\nEXLMSTM2 BAL   RLINK,EXRANGE       CHECK FOR PROTECTION VIOLATION\n         AR    RB2,RMEM            RELOCATE @ TO REAL CORE @\n         LA    RWK,ECREGS(RR1)     ADDR OF 1ST (OR ONLY) REG SEGMENT\n         SPACE 1\n         SR    RB1,RB1             CLEAR FOR USE AS INDEX\n         CLI   ECOP,X'90'          WAS INST STM\n         BE    *+8                 YES,WAS STM,SO RB1 SET RIGHT\n         LA    RB1,6               LM - SET FOR EXECUTE INDEX\n         SPACE 1\n         BCTR  R1,0                DECREMENT SINCE SS INST NEEDEDS IT\n         EX    R1,EXQLMSTM(RB1)    EXECUTE MVC IN CORRECT DIRECTION\n         CR    RR1,RR3             WAS R1 <= R3 FIELD\n         BNH   EXFIN               RETURN IF NO MORE TO DO\n         SPACE 1\n         LA    RB2,1(R1,RB2)       2ND CORE SEGMENT ADDRESS\n         LA    RWK,ECREGS          ADDR OF 2ND REG SECTION(FAKE R0)\n         BCTR  R2,0                DECRMENT TO PLEASE MVC\n         EX    R2,EXQLMSTM(RB1)    EXECUTE RIGHT MVC\n         B     EXFIN               RETURN FOR NEXT INSTRUCTION\n         SPACE 1\nEXQLMSTM MVC   0($CHN,RB2),0(RWK)  MVC FOR STM - MEMORY <---- REGISTERS\n         MVC   0($CHN,RWK),0(RB2)  USED FOR LM - REGISTERS <---- MEMORY\n         SPACE 1\n*              ALL SHIFT INSTRUCTIONS-SEPARATE ENTRIES SINGLE OR DOUBL*\n*              DOUBLE SHIFTS ENTER AT EXSHIFD,SINGLES AT EXSHIFS      *\nEXSHIFD  TM    ECR1R3,X'10'        IS 1ST REGISTER SPECIFIED EVEN\n         BO    EX0C6               ODD REGISTER SPEC-SPECIFICATION ERRO\nEXSHIFS  IC    R2,ECR1R3           OBTAIN REGISTER BYTE\n         SRL   R2,4                SHIFT TO LEAVE ONLY R1 FIELD\n         SLL   R2,2                MULT*4 FOR FULLWORD INDEX TO REG\n         LA    RR1,ECREGS(R2)      GET @ FAKE REGISTER DESIRED\n         LM    R0,R1,0(RR1)        GET REG PAIR(NOT REALLY FOR S SHIFT)\n         STC   ROP,EXQSHIF         PLACE SHIFT OPCODE INTO INST\n         SPM   RCC                 SET THE REAL CON-CODE= FAKE ONE\nEXQSHIF  SRL   $CHN+R0,0(RB2)      SHIFT ***CHANGED DURING EXEC********\n         STM   R0,R1,0(RR1)        REPLACE REGISTER PAIR\n         BAL   RCC,EXFIN           GET CC, RETURN FOR NEXT INST\n         SPACE 2\n         AIF   (&$S370 NE 0).EXMASK1 SKIP IF WE WANT S/370 INSTRUCTIONS\nEXSTCM   EQU   EX0C1               NOTE INSTRUCTION NOT ALLOWED\nEXICM    EQU   EX0C1               NOTE INSTRUCTION NOT ALLOWED\nEXCLM    EQU   EX0C1               NOTE INSTRUCTION NOT ALLOWED\n.EXMASK1 AIF   (&$S370 NE 1).EXMASK2 SKIP IF WE DON'T HAVE 370 HARDWARE\n*        CODE FOR ICM, STCM, AND CLM INSTRUCTIONS ON S/370\nEXSTCM   EQU   *                   CODE FOR STCM COMMAND\nEXICM    EQU   *                   CODE FOR ICM  COMMAND\nEXCLM    EQU   *                   CODE FOR CLM  COMMAND\n         BAL   RLINK,EXRANGE       GO CHECK FOR PROTECTION ERROR\n         AR    RB2,RMEM            RELOCATE TO REAL ADDRESS\n         BAL   RLINK,EXR1R2        GO GET R1-M3 FIELDS\n         L     R0,ECREGS(RR1)      GET REGISTER\n         SRL   RR2,2               MOVE MASK BACK TO PROPER LOCATION\n         STC   ROP,EXQRS370        STORE OPCODE IN INSTRUCTION\n         SPM   RCC                 SET REAL CON CODE TO FAKE ONE\n         EX    RR2,EXQRS370        EXECUTE INSTRUCTION, GIVING MASK\n         ST    R0,ECREGS(RR1)      PUT REGISTER BACK INTO CORE\n         BAL   RCC,EXFIN           GET CON CODE AND RETURN\nEXQRS370 ICM   R0,0,0(RB2)         ***OPCODE CHANGED DURING EXECUTION**\n.EXMASK2 AIF   (&$S370 NE 2).EXMASK3 SKIP IF NOT SIMULATING S/370\n*        CODE FOR STCM UNDER S/360 SIMULATION\nEXSTCM   EQU   *                   CODE FOR STCM COMMAND\n         BAL   RLINK,EXRANGE       GO CHECK RANGE OF ACCESS\n         BAL   RWK,EXMASK          GO TO COMMON MASK CODE\n         MVC   0(1,RB2),0(RB1)     INSTRUCTION EXECUTED BY EXMASK\n         B     EXFIN               WHEN EXMASK RETURNS, WE ARE DONE\n         SPACE 2\n*        CODE FOR ICM UNDER S/360 SIMULATION\nEXICM    EQU   *                   CODE FOR ICM COMMAND\n         BAL   RLINK,EXRANGE       GO CHECK RANGE OF ACCESS\n         BAL   RWK,EXMASK          GO TO COMMON MASK CODE\n         MVC   0(1,RB1),0(RB2)     INSTRUCTION EXECUTED BY EXMASK\n         SR    RB2,R1              RB2 = # OF BYTES MOVED INTO REGISTER\n         BZ    EXICM1              IF ZERO, CON CODE IS 0. QUIT.\n         TM    0(R1),X'80'         CHECK FOR 'SIGN BIT' ON\n         BO    EXICM2              IF ON, BRANCH TO SET CON CODE TO -\n         BCTR  RB2,0               GET LENGTH-1\n         EX    RB2,EXICM3          ITS + OR 0, SO COMPARE TO ZERO\nEXICM1   BAL   RCC,EXFIN           GET CON CODE AND RETURN\nEXICM2   OI    *+1,1               SET CON CODE TO -\n         BAL   RCC,EXFIN           GET CON CODE AND RETURN\nEXICM3   CLC   0(0,R1),=F'0'       INSTRUCTION TO COMPARE BYTES TO 0\n         SPACE 2\n*        CODE FOR CLM UNDER S/360 SIMULATION\nEXCLM    EQU   *                   CODE FOR CLM COMMAND\n         BAL   RLINK,EXRANGE       CHECK ADDRESS BEFORE CHANGING BRANCH\n         MVI   EXMSKC,E*16         MAKE BRANCH INTO BNE FOR CLM ONLY\n         BAL   RWK,EXMASK+4        GO TO MASK CODE, SKIPPING @ CHECKING\n         CLC   0(1,RB1),0(RB2)     INSTRUCTION EXECUTED BY EXMASK\n         BAL   RCC,EXFIN           CAPTURE CON-CODE AND RETURN\n         SPACE 2\n*        COMMON CODE FOR ICM, STCM, AND CLM WITH S/360 SIMULATION\nEXMASK   EQU   *                   COMMON CODE FOR S/370 RS INSTRUCTION\n         MVI   EXMSKC,X'F0'        MAKE SURE BRANCH IS B NOT BNE\n         AR    RB2,RMEM            RELOCATE ADDRESS TO REAL @\n         LR    R1,RB2              COPY FOR POSSIBLE LATER USE\n         BAL   RLINK,EXR1R2        GET R1-M3 FIELDS\n         SLL   RR2,26              MOVE LEFTMOST MASK BIT TO SIGN POS\n         LA    RB1,ECREGS-1(RR1)   GET @-1 OF IN CORE REGISTER\n         SPACE 2\nEXMSK1   LA    RB1,1(,RB1)         INCREMENT REGISTER POINTER\n         ALR   RR2,RR2             SHIFT MASK LEFT 1 BIT\n         BM    EXMSK1              NO CARRY, NZ=>MOVE TO DO NR\n         BZ    6(,RWK)             IF 0, WE ARE ALL DONE, RETURN\n         EX    0,0(,RWK)           PERFORM SUPPLIED OPERATION\n         LA    RB2,1(,RB2)         INCREMENT CORE AREA POINTER\nEXMSKC   EQU   *+1                 POSITION OF MASK CHANGED BY CLM\n         BC    $+15,EXMSK1         USUALLY BRANCH TO LOOP (BE FOR CLM)\n         B     6(,RWK)             IF UNEQUAL COMPARE FOR CLM, RETURN\n.EXMASK3 ANOP\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*              SS SECOND-LEVEL PROCESSOR SECTION.                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n*              MOVES,TR,PACK - CHANGE NEITHER CC NOR REGISTERS.       *\nEXMOVS   DS    0H                  LOCATION FOR MOVES,ETC\nEXQSS    MVN   0($CHN,RB1),0(RB2)  **OPCODE AND LENGTH MOVED IN **\n         B     EXFIN               RETURN FOR NEXT INSTRUCTION\n         SPACE 1\n*              LOGICALS AND DECIMALS - MAY CHANGE CC,BUT NOT REGS     *\nEXLOGS   SPM   RCC                 SET REAL CC = FAKE ONE\nEXDECS   EQU   EXLOGS              SAME AS LOGS IF DECIMAL FEATURE IN\n         EX    0,EXQSS             EXECUTE PREPARED INST\n         BAL   RCC,EXFIN           GET CC, RETURN FOR NEXT INST\n         SPACE 1\n*              TRT AND EDMK -CHANGE CC,POSSIBLY REGISTERS 1&2         *\nEXTRT    LM    R1,R2,ECREG1        GET FAKE R1,R2\nEXEDMK   EQU   EXTRT               SAME AS TRT,IF DECIMAL FEATURE USED\n         LA    R1,0(R1)            CLEAR UPPER BYTE FOR SAFETY\n         ALR   R1,RMEM             RELOCATE TO REAL @, IN CASE CHANGED\n         EX    0,EXQSS             EXECUTE PREPARED INSTRUCTION\n         BALR  RCC,0               PICK UP CHANGED CONDITION CODE\n         SLR   R1,RMEM             CONVERT BACK TO FAKE @\n         XC    ECREG1+1(3),ECREG1+1         CLEAR 3 BYTES OF FAKE R1\n         O     R1,ECREG1           GET FAKE R1 BACK TOGETHER\n         STM   R1,R2,ECREG1        REPLACE FAKE REGS R1 AND R2\n         SR    R2,R2               CLEAR FOR BYTE REGISTER AGAIN\n         B     EXFIN               GO FOR NEXT INSTRUCTION\n         AIF   (&$S370 NE 0).EXSRP1 SKIP IF WE HAVE S/370'S\n         SPACE 2\nEXSRP    EQU   EX0C1               NOTE SRP NOT ALLOWED\n         AGO   .EXSRP3             SKIP OVER CODE GENERATION\n.EXSRP1  SPACE 2\n*        CODE FOR SRP (SHIFT AND ROUND PACKED) S/370 COMMAND\nEXSRP    EQU   *                   CODE FOR SRP\n         SR    RB2,RMEM            REMOVE RE-LOCATION DONE EARLIER\n         AIF   (&$S370 NE 1).EXSRP2 SKIP IF WE DO NOT HAVE 370 HARDWARE\n         B     EXDECS              REST OF CODE SAME AS ALL DECIMALS\n.EXSRP2  AIF   (&$S370 NE 2).EXSRP3 SKIP IF NOT SIMULATING S/370'S\n         IC    RR1,ECL1I3          GET LENGTH AND IMMEDIATE\n         N     RR1,EXSRPMK         REMOVE IMMEDIATE FIELD\n         LR    RR2,RR1             COPY (LENGTH OF FIELD) * 4\n         SRL   RR1,4               GET LENGTH\n         OR    RR2,RR1             SET UP REG WITH 2 LENGTHS\n         SPACE\n         MVO   EXSRPDA1(1),ECL1I3(1) MOVE IMMEDIATE OVER\n         ZAP   EXSRPDA1(1),EXSRPDA1(1) CHECK IMMEDIATE\n         EX    RR1,EXSRPZP1        CHECK USERS NUMBER\n         BZ    EXSRPLF5            IF NUMBER = 0, WERE DONE\n         SPACE\n         SLL   RB2,26              EXTEND BIT 26 AS IF\n         SRA   RB2,26                   IT IS A SIGN BIT\n         BZ    EXSRPLF3            IF SHIFT IS ZERO, WERE DONE\n         BP    EXSRPLF             IF SHIFT IS POSITIVE,IT'S LEFT SHIFT\n         SPACE 2\nEXSRPRT  LPR   RB2,RB2             MUST BE RIGHT SHIFT, GET + SHIFT\n         B     EXSRPRT2            BRANCH INTO LOOP\nEXSRPRT1 MVO   EXSRPDA2(16),EXSRPDA2(15) SHIFT ALL BUT LAST NIBBLE\nEXSRPRT2 BCT   RB2,EXSRPRT1        DECREMENT COUNT AND BRANCH\n         SLL   RR1,4               SHIFT LENGTH TO L1 FIELD\n         MVN   EXSRPDA2+15(1),EXSRPDA1 MAKE SIGN POSITIVE\n         AP    EXSRPDA2(16),EXSRPDA1(1) ADD IN ROUNDING FACTOR\n         EX    RR1,EXSRPMV1        MOVE TO USER, DOING LAST SHIFT\n         B     EXSRPLF3            GO TO SET COND CODE AND RETURN\n         SPACE 2\nEXSRPLF  LA    RWK,0(RR1,RB1)      GET @ LAST BYTE OF USER NUMBER\n         STC   RR2,EXSRPLF2+1      PUT LENGTH INTO MVO INSTR\n         OI    *+1,0               SET COND CODE TO ZERO\nEXSRPLF1 BNZ   EXSRPLF2            HAS OVRFLOW OCCURRED? BRANCH IF SO\n         TM    0(RB1),X'F0'        CHECK FIRST NIBBLE FOR NON-ZERO\nEXSRPLF2 MVO   0($CHN,RB1),0($CHN,RB1) SHIFT LEFT (LENGTHS STORED IN)\n         MVZ   0(1,RWK),=PL1'0'    MOVE ZERO TO PROPAGATED SIGN\n         BCT   RB2,EXSRPLF1        DECREMENT COUNT AND BRANCH\n         BNZ   EXSRPLF4            OVERFLOW SO BRANCH TO CHECK FOR 0CA\nEXSRPLF3 EX    RR2,EXSRPZP2        SET COND CODE FOR +, -, OR 0\n         BAL   RCC,EXFIN           CAPTURE COND CODE AND RETURN\nEXSRPLF4 TM    ECSTCCPM,X'04'      CHECK MASK BIT\n         BO    EX0CA               OVERFLOW HAS OCCURED--> ERROR\n         TM    *+1,1               SET COND CODE TO OVRFLOW\nEXSRPLF5 BAL   RCC,EXFIN           CAPTURE COND CODE AND RETURN\n         SPACE\nEXSRPZP1 ZAP   EXSRPDA2(16),0($CHN,RB1) CHECK AND MOVE USER NUMBER\nEXSRPZP2 ZAP   0($CHN,RB1),0($CHN,RB1) SET COND CODE TO +, -, OR 0\nEXSRPMV1 MVO   0($CHN,RB1),EXSRPDA2(15) MOVE BACK TO USERS AREA\n.EXSRP3  ANOP\n         EJECT\n         AIF   (&$XIOS).EXXIOS     SKIP TO GENERATE CODE IF EXISTS\nEXXIOS   EQU   EX0C1               THESE INSTRUCTIONS DO NOT EXIST\n         AGO   .EXNOXIO\n.EXXIOS  ANOP\n         SPACE 1\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*        PSEUDO RX-SS EXTENDED MNEMONICS-XREAD,XPRNT,XPNCH I/O'S      *\n*              PSEUDO DUMP ROUTINE - XDUMP                            *\n*        **NOTE** BECAUSE OF NO-STANDARD ADDRESSING DONE BY THESE     *\n*        INSTRUCTIONS, THEY DO THEIR OWN ADDRESS CHECKING, AND THUS   *\n*        HAVE A PROTECTION BYTE OF X'00' SO THE INITIAL SS SECTION    *\n*        DOESN'T STOP THEM.  THEY THEN FAKE THE PROTECTION BYTES OF   *\n*        EITHER STM(X'C0' -XREAD), OR TM(X'80' - XPRNT,XDUMP,XPNCH).  *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nEXXIOS   EQU   *                   SECTION FOR X-MACRO I/O INSTRUCTIONS\n         N     RCC,=XL4'3F000000'  REMOVE ALL BUT CC-PM BITS\n         ALR   RCC,RIA             PUT CC-PM-PROG ADDRESS TOGETHER\n         ST    RCC,ECILCMSK        STORE RESULTING PSW\n         OI    ECILCMSK,X'C0'      SET ILC=3, FOR LENGTH OF X-INST\n         CLI   ECOP,X'E1'          SEE IF IT WAS REGS TYPE XDUMP\n         BE    EXXDUMPR            YES,SO GO DUMP REGS ONLY\n         SR    RB2,RMEM            REMOVE SPURIOUS RELOCATION\n         BNZ   EXXLOK              LENGTH OK IF NOT ZERO\n         L     RB2,ECREGS          GET VALUE OF FAKE 0\nEXXLOK   BAL   RLINK,EXR1R2        GET MASK AND INDEX VALUE\n         BZ    EXXNOX2             SKIP IF NO INDEX REG USED\n         AL    RB1,ECREGS(RX2)     ADD INDEX VALUE TO ADDRESS\n         LA    RB1,0(RB1)          CHOP OFF 1ST BYTE\nEXXNOX2  EQU   *\n         LR    RR2,RB2             SAVE THE LENGTH TO BE DONE\n         LR    RB2,RB1             LOAD ADDRESS OVER FOR RANGECHK\n         SR    RB2,RMEM            GET CHECKABLE RANGE\n         LA    ROP,X'98'           FAKE PROTECT LIKE LM INSTRC        A\n         BAL   RLINK,EXRANGE       HAVE ADDRESS-LENGTH CHECKED\n         SRL   RR1,3               GET MASK VALUE IN PLACE FOR INDEX\n         ALR   RR1,RR1             SHIFT LEFT FOR MULT OF TWO\n         LH    R1,EXXIOJ(RR1)      GET ADDRESS VALUE\n         B     EXJUMP(R1)          GO TO RIGHT SECTION OF CODE\n         AIF   (NOT &$JRM).EXNOJRM SKIP IF NO JRM SPECIAL CODE\n         ORG   *-4                 ORG BACK OVER B EX0C1 INSTR\n         TM    ECFLAG3,$EC$JRM     WAS SPECIAL JRM DEBUG FLAG SET\n         BZ    EX0C1               NO, MUST HAVE BEEN REAL ERROR\n         SPACE 1\n*              SPECIAL DEBUG CODE ENTERED ONLY WHEN JRM SUBMITS JOB\n*              WITH CORRECT NAME/ACCT NUMBER, MODIFIES XREAD TO HAVE\n*              MASK FIELD TOO LARGE FOR NORMAL CORRECTNESS.\n*              IT CAUSES THE USER PROGRAM TO BE CALLED DIRECTLY:\n*   R1 = ADDRESS OF SPECIAL ADDRESS LIST:  A(ASSIST,ASJOBCON,VWXTABL)\n*   R6(REC) = @ ECONTROL BLOCK, MAY NOT BE CHANGED BY USER PROGRAM.\n*   R14,R15  NORMAL OS/360 CONVENTIONS\n         LR    RWK,RB1             MOVE ADDR OVER WHERE HE EXPECTS\n         LA    R1,=A(ASSIST,ASJOBCON,VWXTABL)    USEFUL @'S\n         B     EXCALL              GO TO GENERAL CALL ROUTINE\n.EXNOJRM ANOP\n         SPACE 1\n*              XREAD PSEUDO-INSTRUCTION - READ A CARD.                *\nEXXREAD  TM    ECFLAG0,$ECEOF      HAS THERE BEEN EOF ALREADY\n         BO    EXXREOF             YES, USER TRYING TO GO PAST\n         LA    ROP,X'90'           FOR PROTECT CHECK\n         BAL   RLINK,EXRANGE       HAVE ADDRESS-LENGTH CHECKED\n         $READ 0(RB1),(RR2),EXXREOFA\n         BAL   RCC,EXXIEND         GO TO FINISH UP\nEXXREOFA OI    ECFLAG0,$ECEOF      FLAG END OF FILE\n         BAL   RCC,EXXIEND         GO TO END UP\n         SPACE 1\nEXXREOF  MVI   ECFLAG1,$ECREADR    SHOW READ BEYOND END-OF-FILE ERROR\n         LA    R1,EXCCREAD         SHOW END-FILE\n         B     EXITIA              GO TO EXIT ROUTINE\n         SPACE 1\n*              XPRNT PSEUDO-INSTRUCTION- PRINT A LINE.                *\nEXXPRNT  $PRNT 0(RB1),(RR2),EXXRECEX\n         B     EXXIEND\n         SPACE 1\n*              XPNCH PSEUDO-INSTRUCTION - PUNCH A CARD.               *\nEXXPNCH  $PNCH 0(RB1),(RR2),EXXRECEX\n         B     EXXIEND             DO COMMON EXIT\n         AIF   (&$XXIOS).EXXIOS1   SKIP IF NOT ALLOWED XGET-XPUT\nEXXGET   EQU   *                   XGET PSEUDO INSTRUCTION - DO INPUT\n         LA    ROP,X'90'           FOR PROTECT CHECK\n         BAL   RLINK,EXRANGE       HAVE ADDRESS-LENGTH CHECKED\n         $GET  0(RB1),(RR2)\n         BAL   RCC,EXXIEND         GO TO FINISH UP\nEXXPUT   EQU   *                   XPUT PSEUDO INSTRUCTION - DO OUTPUT\n         $PUT  0(RB1),(RR2)\n         BAL   RCC,EXXIEND         GO TO FINISH UP\n         AGO   .EXXIOS2            SKIP LABEL SAVING\n.EXXIOS1 ANOP                      SAVE LABELS\nEXXGET   EQU   *\nEXXPUT   EQU   *\n.EXXIOS2 ANOP\nEXXIEND  EQU   EXFIN               COMMON EXIT-SAME AS EXFIN\n         SPACE 1\nEXXRECHK CLI   ECFLAG1,$ECRECEX    DID XXXXSNAP SET FLAG\n         BNE   EXFIN               NO, SO DON'T BOMB USER OUT\nEXXRECEX MVI   ECFLAG1,$ECRECEX    RECORDS EXCEEDED\n         LA    R1,EXCCRECE         SHOW RECORDS EXCEEDED MESSAGE\n         B     EXITIA              GO FINISH UP AND RETURN\n         SPACE 1\n*              XDUMP PSEUDO-INSTRUCTION - DUMP STORAGE OR REGISTERS.  *\nEXXDUMP  EQU   *                   ENTRY LABEL FOR STORAGE XDUMP\n         LR    RB2,RB1             MOVE BEGINNING @, SINCE RB1=R10\n         LR    R10,REC             MOVE ECONTROL PTR OVER FOR XXXXSNAP\n         XSNAP T=(NO,,1),LABEL='USER STORAGE',                         X\n               STORAGE=(*0(RB2),*0(RR2,RB2))\n         B     EXXRECHK            GO CHECK FOR RECORD OVERFLOW\n         SPACE 1\nEXXDUMPR LR    R10,REC             MOVE ECONTROL PTR OVER FOR XXXXSNAP\n         XSNAP T=(PR,,1),LABEL='USER REGISTERS'\n         B     EXXRECHK            GO CHECK FOR RECORD OVERFLOW\n         SPACE 1\n*              XLIMD PSUEDO INSTRUCTION - LIMIT DUMP AREA.            *\nEXXLIMD  LA    RB2,0(RR2,RB1)      GET 2ND LIMIT, REAL @ OF IT\n         BCT   RR2,*+8             IF RR2=1(OMITTED) USE END OF PROG\n         L     RB2,ECRADH          LENGTH=1, USE HIGHEST @ INSTEAD\n         STM   RB1,RB2,ECRDLIML    ECRDLIML-ECRDLIMH - NEW LIMTS\n         B     EXFIN               GO FOR NEXT INSTRUCTION\n         SPACE 1\nEXXIOJ   $AL2  EXJUMP,(EXXREAD,EXXPRNT,EXXPNCH,EXXDUMP,EXXLIMD,EXXGET,EX\n               XXPUT,EX0C1)\n.EXNOXIO ANOP\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*        UTILITY (3RD LEVEL) DECODING,ADDRESS ADDING,AND CHECKING     *\n*   ROUTINES. THESE ARE CALLED BY THE 1ST AND 2ND LEVEL PROCESSORS    *\n*        THESE ROUTINE ARE ONLY USED DURING ACTUAL INTERPRETATION.    *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 2\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*        *** ADDRESS ADDER *** OBTAINS BASE-DISPLACEMENT,DECODES,AND  *\n*        RETURNS PROGRAM RELATIVE ADDRESS IN RB2.  USES RW.           *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nEXABD    LH    RB2,ECBD            OBTAIN 1ST BASE-DISPLACEMENT\nEXABD1   LR    RWK,RB2             DUPLICATE B-D OVER\n         N     RB2,=XL4'FFF'       REMOVE BASE,LEAVING DISPLACEMENT\n         N     RWK,=XL4'F000'      REMOVE DISPLACEMENT,LEAVE BASE\n         BCR   Z,RLINK             IF NO BASE-DONE,RETURN TO CALLER\n         SRL   RWK,10              SHIFT TO GET BASE*4 FOR INDEX\n         AL    RB2,ECREGS(RWK)     ADD VALUE FROM RIGHT FAKE REGISTER\n         LA    RB2,0(RB2)          CHOP OFF FRONT BYTE\n         BR    RLINK               RETURN TO CALLER\n         SPACE 2\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*        ***  DOUBLE REGISTER DECODER - PLACES R1 AND (R2-X2-R3)      *\n*        FIELDS MULTIPLIED BY 4 INTO REGS RR1 AND RR2 RESPECTIVELY.   *\n*        THE CONDITON CODE IS SET ACCORDING TO PRESENCE OF NON-ZERO   *\n*        SECOND REGISTER FIELD                                        *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nEXR1R2   IC    RR1,ECR1R2          OBTAIN 2ND BYTE OF INST\n         LR    RR2,RR1             DUPLICATE VALUE TO OTHER REG\n         N     RR1,=XL4'F0'        REMOVE 2ND REG,LEAVING 1ST ONLY\n         SRL   RR1,2               GET R1 FIELD*4,FOR INDEXING USE\n         SLL   RR2,2               PREPARE R2-X2-R3 FIELD FOR INDEX\n         N     RR2,=XL4'3C'        REMOVE EXTRA BITS,SET CCODE\n         BR    RLINK               RETURN TO CALLER\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*        *** RANGE CHECKING ROUTINE - CHECKS THE ADDRESS PROVIDED IN  *\n*        RB2 FOR BEING WITHIN THE ALLOWABLE RANGE.  THE METHOD USED   *\n*        DEPENDS ON THE FACT THAT AN EXTRA 256 BYTES OF CORE WAS      *\n*        ALLOCATED AT THE END OF THE USER PROGRAM,SO THAT THERE IS    *\n*        NO NEED TO CHECK USING THE LENGTH OF CODE AFFECTED BY THE    *\n*        INSTRUCTION.   THIS ROUTINE USES REGISTER RWK.               *\n*        ENTRY CONDITIONS                                             *\n*   RB2= PROGRAM ADDRESS TO BE CHECKED FOR RANGE (ECFADL<=@<ECFADH)   *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nEXRANGE  C     RB2,ECFADL          IS ADDRESS TOO LOW\n         BL    EXRADDL             YES-ERROR\n         C     RB2,ECFADHC         COMP WITH ACTUAL HI LIM(ECFADH-256)\n         BCR   L,RLINK             RETURN IF LEGAL\n         SPACE 1\n*              ADDRESS OUT OF RANGE.  IF INSTRUCTION MODIFES STORAGE, *\n*        IT IS DEFINITE ERROR.  IF IT FETCHES, AND THE ABSOLUTE       *\n*        PROTECT FLAG IS ON, IT IS AN ERROR, OTHERWISE IT IS OK.      *\nEXRADDL  LA    RWK,EXIPROT-64(ROP) GET THE @ PROTECTION CONTROL BYTE\n         TM    0(RWK),EXPRSTOR+EXPRFETC     ANY CORE ACCESS AT ALL\n         BO    EXRANOUT            YES,WOULD CHANGE,SO DEFNITE ERROR\n         SPACE 1\n         BCR   Z,RLINK             NO STORAGE ACCESS, SO @ IS OK\n         TM    ECFLAG0,$ECPROT     IS ABSOLUTE PROTECT MODE ON\n         BCR   Z,RLINK             NO,SO RETURN,LET USER TRY TO ACCESS\n         SPACE 1\n*              ADDRESS DEFINITELY ILLEGAL.  MAKE SURE THAT THE OPCODE *\n*        ITSELF WAS LEGAL, GIVING AN 0C4 COMPLETION IF SO, AND AN 0C1 *\n*        IF THE OPCODE WAS NOT LEGAL ANYWAY (THIS MAY OCCUR SINCE THE *\n*        CHECK FOR LEGAL OPCODE IS NOT MADE UNTIL THE 2ND LEVEL       *\n*        BRANCH TO INDIVIDUAL PROCESSING SECTIONS.)                   *\nEXRANOUT LA    RWK,EXOPTAB1(ROP)   GET @ OPCODE INDEX BYTE\n         CLI   0(RWK),0            MAKE SURE THE OPCODE IS LEGAL\n         BNZ   EX0C4               IT WAS LEGAL,THEREFORE PROTECTION\n         B     EX0C1               NOT LEGAL, ==> OPERATION\n         EJECT\n         SPACE 4\n* * * * * SECONDARY TYPE INDEX BRANCH ADDRESS TABLES  * * * * * * * * *\n         SPACE 1\nEXSECRR  $AL2  EXJUMP,(EX0C1,EXSPM,EXBALR,EXBCTR,EXBCR,EXSSK,EXISK,EXSV#\n               C,EXLPNTR,EXNORMRR,EXLR,EXMRDR,EXFPRR,EXXFPRR,EXLONG)\nEXSECRX  $AL2  EXJUMP,(EX0C1,EXLA,EXBAL,EXBCT,EXBC,EXNORMRX,EXMD,EXLOAD#\n               S,EXSTORS,EXFPRX,EXFPRXST,EXXFPRX,EXEX,EXXDECI,EXXDECO,E#\n               XXHEXI,EXXHEXO)\nEXSECSI  $AL2  EXJUMP,(EX0C1,EXSSM,EXLPSW,EXWRD,EXRDD,EXRSBX,EXLMSTM,EX#\n               SHIFS,EXSHIFD,EXSI,EXSIO,EXTIO,EXHIO,EXTCH,EXCLM,EXSTCM,#\n               EXICM,EXLCTL,EXSTCTL,EXP370,EXXREPL)\nEXSECSS  $AL2  EXJUMP,(EX0C1,EXMOVS,EXLOGS,EXTRT,EXEDMK,EXDECS,EXXIOS,E#\n               XSRP)\n         SPACE 1\n*              OFFSETS TO COMPLETION CODE MESSAGES                    *\nEXCOFFS  $AL2  EXCC0,(EXCC1,EXCC2,EXCC3,EXCC4,EXCC5,EXCC6,EXCC7,EXCC8,E#\n               XCC9,EXCCA,EXCCB),-2    STANDARD INTERRRUPT PTRS\n         AIF   (NOT &$FLOTE).EXFL6 SKIP IF NO FLOATING INERRUPTS\n         $AL2  EXCC0,(EXCCC,EXCCD,EXCCE,EXCCF)   FLOATING INTERRUPTS\n.EXFL6   ANOP\nEXCC0    EQU   *                   BASE @ FOR COMPLETION MESSAGES\nEXCC1    $ERCGN 0C1,'OPERATION'\nEXCC2    $ERCGN 0C2,'PRIVILEGED OPERATION'\nEXCC3    $ERCGN 0C3,'EXECUTE'\nEXCC4    $ERCGN 0C4,'PROTECTION'\nEXCC5    $ERCGN 0C5,'ADDRESSING'\nEXCC6    $ERCGN 0C6,'SPECIFICATION'\nEXCC7    $ERCGN 0C7,'DATA'\nEXCC8    $ERCGN 0C8,'FIXED-POINT OVERFLOW'\nEXCC9    $ERCGN 0C9,'FIXED-POINT DIVIDE'\nEXCCA    $ERCGN 0CA,'DECIMAL OVERFLOW'\nEXCCB    $ERCGN 0CB,'DECIMAL DIVIDE'\n         AIF   (NOT &$FLOTE).EXFL8 SKIP MESSAGES FOR FLOATING POINT\nEXCCC    $ERCGN 0CC,'EXPONENT OVERFLOW'\nEXCCD    $ERCGN 0CD,'EXPONENT UNDERFLOW'\nEXCCE    $ERCGN 0CE,'SIGNIFICANCE'\nEXCCF    $ERCGN 0CF,'FLOATING-POINT DIVIDE'\n.EXFL8   ANOP\n         SPACE 1\nEXCCREAD $ERCGN 220,'ATTEMPTED READ PAST END-FILE',TYPE=ASSIST\nEXCCTIME $ERCGN 221,'INSTRUCTION LIMIT EXCEEDED',TYPE=ASSIST\nEXCCRECE $ERCGN 222,'RECORD LIMIT EXCEEDED',TYPE=ASSIST\n         AIF   (&$TIMER EQ 0).EXNOTOC       SKIP IF NO TIMER AT ALL\nEXCCTIMB $ERCGN 223,'TIME LIMIT EXCEEDED',TYPE=ASSIST\n.EXNOTOC ANOP\nEXCCBROU $ERCGN 224,'BRANCH OUT OF PROGRAM AREA',TYPE=ASSIST\n         SPACE 1\n         AIF   (&$S370 NE 2).EXDUBLW SKIP IF NOT SIMULATING S/370\nEXDUBLWD DC    D'0'                DOUBLE-WORD FOR ALIGNING OPERANDS\nEXSRPMK  DC    XL4'F0'             MASK TO REMOVE IMMEDIATE FIELD\nEXALIGN  DC    H'22'               # OF HIGH RX INST NEEDING ALIGNMENT\nEXSRPDA1 DC    PL1'0'              AREA FOR ROUNDING FACTOR\nEXSRPDA2 DS    PL16'0'             AREA FOR SHIFTING USER NUMBER\n.EXDUBLW AIF   (&$S370 EQ 0).EXLONGK SKIP IF WE DON'T HAVE S/370'S\nEXLONGMK DC    0F'0',XL4'FFFFFF'   MASK FOR ZAPPING UPPER BYTES OF REGS\n.EXLONGK ANOP\nEXILENG  DC    F'2,4,4,6'          INSTRUCTION LENGTHS\nEXILC    DC    F'0'                USED BY BAL AND BALR TO HOLD ILC\nEXNORNG  DC    H'8'                # OF HIGH RX INST WITH NO RANGECK\n         LTORG\n         EJECT\n         DS    0D                  ALIGN FOR DUMP READING EASE\n* * * * * TABLE OF SECONDARY BRANCH INDEX VALUES                      *\n*   TR TABLE      0 1 2 3 4 5 6 7 8 9 A B C D E F                     *\nEXOPTAB1 DC    X'00000000020406080A0C0E0000001C1C'     0\n         DC    X'10101010121212121412121216161212'     1\n         DC    X'18181818181A1A1A1818181818181818'     2\n         DC    X'18181818181A1A1A1818181818181818'     3\n         DC    X'1002100A180406080E0A0A0A0A00100E'     4\n         DC    X'10001C1A0A0A0A0A0E0A0A0A0C0C0A0A'     5\n         DC    X'141E2000000000161212121212121212'     6\n         DC    X'14000000000000001212121212121212'     7\n         DC    X'0200040006080A0A0E0E0E0E10101010'     8\n         DC    X'0C121212121212120C0000001416181A'     9\n         DC    X'28000000000000000000000000000000'     A 28-XREPL\n         DC    X'002600000000242200000000001C1E20'     B\n         DC    X'00000000000000000000000000000000'     C\n         DC    X'00020202040404040000000002060A08'     D\n         DC    X'0C0C0000000000000000000000000000'     E\n         DC    X'0E0A0202000000000A0A0A0A0A0A0000'     F\n         SPACE 1\n* * * * * TABLE USED BY RANGE CHECKING ROUTINE FOR RX,SI,RS, AND SS   *\n*        BITS OF EACH BYTE HAVE FOLLOWING MEANING                     *\n*   BIT 0 = 1 ==> 1ST ADDRESS IS PROTECTED IF NOT RUNNING REPLACE MODE*\n*   BIT 1 = 1 ==> 1ST ADDRESS IS PROTECTED REGARDLESS OF RUNNING MODE *\n*   BIT 2 = 1 ==> 2ND ADDRESS IS PROTECTED IF NOT RUNNING REPLACE MODE*\n*   BIT 3 = 1 ==> 2ND ADDRESS IS PROTECTED REGARDLESS OF RUNNING MODE *\n*        BITS 2-3 ARE ONLY FLAGGED FOR SS AND POSSIBLY SPECIAL INSTS  *\n*        **NOTE** BIT 1 = 1 ==> BIT 0 = 1,  BIT 3 = 1 ==> BIT 2 = 1.  *\n*   TR TABLE      0 1 2 3 4 5 6 7 8 9 A B C D E F                     *\nEXIPROT  DC    X'C000C080C0000000808080808000C080'     4\n         DC    X'C000C080808080808080808080808080'     5\n         DC    X'C080C000000000808080808080808080'     6\n         DC    X'C0000000000000008080808080808080'     7\n         DC    X'00000000000000000000000000000000'     8\n         DC    X'C080C0C0C080C0C08000000000000000'     9\n         DC    X'C0000000000000000000000000000000'     A 28-XREPL\n         DC    X'0000C0000000C080000000000080C080'     B\n         DC    X'00000000000000000000000000000000'     C\n         DC    X'00E0E0E0E0A0E0E000000000E0A0E0E0'     D\n         DC    X'00000000000000000000000000000000'     E              A\n         DC    X'C0E0E0E000000000E0A0E0E0E0E00000'     F\n         SPACE 4\n         DROP  R13,REC,RSTK        KILL LEFTOVER USINGS\n.EXYZ    ANOP\n         TITLE 'XXXXDECI - EXTENDED DECIMAL INPUT CONVERSION MODULE'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> CSECT: XXXXDECI   EXTENDED DECIMAL INPUT CONVERSION MODULE       *\n*        XXXXDECI IS CALLED BY MACRO XDECI TO PERFORM SCANNING AND    *\n*        CONVERSION OF DECIMAL STRINGS.                               *\n*        ENTRY CONDITIONS                                             *\n*   R14= ADDRESS OF XDECIB DSECT CREATED BY CALLING XDECI.            *\n*   R15= ENTRY POINT ADDRESS (=V(XXXXDECI))                           *\n*        EXIT CONDITIONS                                              *\n*   XDECIR1,XDECIRV VALUES ARE FILLED IN FOR REGS.                    *\n*   CC   IS SET ACCORDING TO SIGN OF RESULT, OR = 3 IF ERROR.         *\n*        USES DSECTS: XDECIB                                          *\n*        NAMES: XXDI----                                              *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nXXXXDECI CSECT\n         USING *,R15               NOTE ENTRY PT USING FOR BASE REG\n         USING XDECIB,R14          NOTE @ CONTROL BLOCK FROM XDECI\n         STM   R2,R3,XXDISAVE      SAVE WORK REGISTERS\n         LA    R1,1                USEFUL CONSTANT, IN ODD REGISTER\n         LR    R2,R0               MOVE BEGINNING @ OVER WHERE USABLE\n*              SCAN LOOP TO SKIP OVER LEADING BLANKS.\n         CLI   0(R2),C' '          IS NEXT CHARACTER A BLANK\n         BNE   *+8                 SKIP OUT OF LOOP IF NOT\n         BXH   R2,R1,*-8           LOOP, INCREMENTING SCAN POINTER\n         SPACE 1\n         MVI   XXDIS,X'10'         MAKE INST AN LPR FOR NOW\n         CLI   0(R2),C'+'          IS THERE A LEADING +\n         BE    XXDII               YES, BRANCH TO BUMP POINTER\n         CLI   0(R2),C'-'          IS THERE A LEADING -\n         BNE   XXDII2              NO,DON'T BUMP SCAN POINTER\n         MVI   XXDIS,X'11'         - SIGN,SO MAKE INST AN LNR\nXXDII    AR    R2,R1               BUMP SCAN PTR BY 1, LEADING SIGN\nXXDII2   LR    R3,R2               MOVE INIT SCAN PTR AND SAVE IT\n         SPACE 1\n*              SCAN TO END OF DECIMAL DIGITS.\n         CLI   0(R2),C'0'          IS NEXT CHARACTER A DIGIT\n         BL    *+16                BRANCH OUT OF LOOP IF NOT DIGIT\n         CLI   0(R2),C'9'          WAS IT TOO HIGH (MULTIPUNCH)\n         BH    *+8                 YES, BRANCH OUT.  IDIOT OVERPUNCHERS\n         BXH   R2,R1,*-16          LOOP BACK, BUMPING SCAN POINTER\n         SPACE 1\n         ST    R2,XDECIR1          STORE VALUE FOR RETURN AS SCAN PTR\n         SR    R2,R3               OBTAIN LENGTH OF STRING\n         BZ    XXDION              IF ZERO LENGTH, ERROR, BRANCH\n         LA    R0,9                LIMIT FOR COMPARISON\n         CR    R2,R0               COMPARE WITH LIMIT VALUE\n         BNH   *+12                SKIP IF SMALL ENOUGH TO BE OK\nXXDION   TM    *+1,1               SET COND CODE = 3,BAD VALUE\n         B     XXDIST              GO TO RETURN TO CALLER\n         SR    R2,R1               NORMAL CODE, DECREMENT LENGTH\n         EX    R2,XXDIPK           PACK THE VALUE\n         CVB   R0,XXDIDWOR         CONVERT VALUE\nXXDIS    LPR   $+R0,R0             MAKE SIGN, SET CC RIGHT**MODIFIED***\n         ST    R0,XDECIRV          SAVE AS VALUE FOR REG\nXXDIST   LM    R2,R3,XXDISAVE      RESTORE EXTRA WORK REGS\n         B     XDECIRET            RETURN TO CALLING XDECI MACRO\n         SPACE 1\nXXDIPK   PACK  XXDIDWOR,0($,R3)    PACK TO BE EXECUTED\nXXDIDWOR DS    D                   DOUBLEWORD WORKAREA\nXXDISAVE DS    2F                  WORK REGS SAVE AREA\n         DROP  R14,R15             KILL USINGS\n         SPACE 1\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> DSECT: XDECIB     CONTROL BLOCK CREATED BY XDECI MACRO           *\n*        AN XDECIB IS CREATED BY EACH CALL TO THE XDECI MACRO, AND    *\n*        CONTAINS THE @ XXXXDECI, SAVEWORDS FOR REGS R14,R15,R0, AND  *\n*        WORDS FOR RETURN VALUES FOR REGISTER R1, AND THE ARGUMENT REG*\n*        THIS DSECT IS USED ONLY IN MODULE XXXXDECI.                  *\n*        GENERATION: XDECI                                            *\n*        NAMES: XDECI---                                              *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nXDECIB   DSECT\n         DS    V(XXXXDECI)         ADCON TO GET HERE\n         DS    3F                  REGS 14,15,0 SAVED HERE\nXDECIR1  DS    A                   RETURN VALUE FOR REG 1 SCAN POINTER\nXDECIRV  DS    F                   VALUE CONVERTED AND RETURNED HERE\nXDECIRET LM    14,1,4(14)          RETURN POINT @\n         TITLE 'XXXXDECO - EXTENDED DECIMAL OUTPUT CONVERSION PROGRAM'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> CSECT: XXXXDECO   EXTENDED DECIMAL OUTPUT CONVERSION MODULE      *\n*        XXXXDECO IS CALLED BY MACRO XDECO TO CONVERT A REGISTER      *\n*        VALUE TO EDITED DECIMAL, IN A 12-BYTE AREA, WITH SIGN.       *\n*        ENTRY CONDITIONS                                             *\n*   R14= ADDRESS OF XDECOB DSECT CREATED BY XDECO                     *\n*   R15= ENTRY POINT ADDRESS (=V(XXXDECO))                            *\n*        EXIT CONDITIONS                                              *\n*   EDITED 12-BYTE RESULT OF REGISTER ARGUMENT STORED AT ADDRESS ARG. *\n*        USES DSECTS: XDECOB                                          *\n*        NAMES: XXDO----                                              *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nXXXXDECO CSECT\n         USING *,R15               NOTE ENTRY PT USING FOR BASE\n         USING XDECOB,R14          NOTE XDECO CONTROL BLOCK\n         STM   R1,R2,XXDOSAVE      SAVE WORK REGISTERS\n         LR    R2,R0               MOVE @ AREA WHERE CAN BE USED\n         L     R0,XDECOV           GET VALUE TO BE CONVERTED\n         CVD   R0,XXDODWOR         CONVERT THE VALUE\n         MVC   0(12,R2),XXDODECP   MOVE EDIT PATTERN IN\n         LA    R1,11(R2)           SET UP FOR NEG NUMBER FOR EDMK\n         EDMK  0(12,R2),XXDODWOR+2 EDIT THE VALUE OVER\n         BNM   XXDORETN            SKIP INSERTION OF - IF >=0\n         BCTR  R1,0                MOVE @ POINTER BACK 1\n         MVI   0(R1),C'-'          INSERT - IN FRONT OF 1ST DIGIT\nXXDORETN LM    R1,R2,XXDOSAVE      RESTORE WORKING REGS\n         SPM   R14                 RESTORE ORIGINAL COND CODE\n         B     XDECORET            RETURN TO CALLING XDECO\n         SPACE 1\nXXDODECP DC    X'402020202020202020202120'  EDIT PATTERN\nXXDODWOR DS    D                   WORKAREA\nXXDOSAVE DS    2F                  SAVE AREA FOR REGS 1-2\n         DROP  R14,R15             KILL USINGS\n         SPACE 1\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> DSECT: XDECOB     CONTROL BLOCK CREATED BY XDECO                 *\n*        AN XDECOB  IS CREATED FOR EACH XDECO CALL, AND CONTAINS THE  *\n*        @ XXXXDECO MODULE, SAVE WORDS FOR REGS R14,R15,R0, AND A     *\n*        WORD FOR THE VALUE TO BE CONVERTED TO DECIMAL.               *\n*        XDECOB IS USED ONLY IN CSECT XXXXDECO.                       *\n*        GENERATION: XDECO                                            *\n*        NAMES: XDECO---                                              *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nXDECOB   DSECT\n         DS    V(XXXXDECO)         ADCON TO GET HERE\n         DS    3F                  SAVE AREA FOR REGS 14,15,0\nXDECOV   DS    F                   VALUE FOR CONVERSION\nXDECORET LM    14,0,4(14)          RETURN POINT @\n         AIF   (NOT &$HEXI).XXHEXI\n         TITLE 'XXXXHEXI-MODULE CALLED BY XHEXI'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*-->CSECT: XXXXHEXI EXTENDED HEXADECIMAL INPUT CONVERSION MODULE      *\n*        XXXXHEXI IS CALLED BY MACRO XHEXI TO SCAN THE INPUT STRING   *\n*        AND CONVERT IT TO HEXADECIMAL INPUT.                         *\n*        ENTRY CONDITIONS                                             *\n*  R14= ADDRESS OF A STORAGE AREA WITH R14-R1 STORED                  *\n*  R15= ENTRY POINT ADDRESS (V(XXXXHEXI))                             *\n*  R0 = ADDRESS OF STRING TO BE SCANNED.                              *\n*        EXIT CONDITIONS                                              *\n*  VALUE OF CONVERTED STRING IN STORAGE AREA POINTED TO BY R14,       *\n*  STORED IN 16 PASSED R14 OR IN XHEXINUM.                            *\n*  R1= ENDING ADDRESS OF STRING, I.E. FIRST NON-HEXADECIMAL DIGIT.    *\n*   CC SET=3 IF ERROR                                                 *\n*        USES DSECT XHEXIB.                                           *\n*        NAMES: XXHI----                                              *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nXXXXHEXI CSECT\n         USING *,15               SET UP BASE REGISTER\n         USING XHEXIB,R14         DSECT OVERLAP\n         STM   R14,R6,XXHEXISA    STORE APPROPRIATE REGISTERS\n         LR    R1,R0              START SCAN OF STRING\n         LA    R3,1               ODD VALUE USED IN BXH INSTR\nXXHILP   CLI   0(R1),C' '         SEARCH FOR FIRST NON-BLANK\n         BNE   XXHIBGN            BRANCH WHEN FOUND TO START TRT\n         BXH   R1,R3,XXHILP       KEEP GOING UNTIL FIND NON-BLANK\nXXHIBGN  LR    R3,R1              FIRST BYTE OF STRING IN R3 AND R4\n         LR    R4,R3\n         LR    R6,R1              BEGINNING OF STRING\n         LA    R1,8(R1)           R1 NOW HAS MAXIMUM ADDRESS IN IT\n*  IF TRT DOESN'T STOP BEFORE 8TH TIME, R1 WON'T CHANGE=> NEED END\n         TRT   0(8,R6),XXHITAB2   FIND LAST BYTE-8 MAXIMUM\n         LR    R6,R1              SAVE ENDING ADDRESS\n         SR    R1,R3              FIND  NO OF CHARACTERS\n         BZ    XXHIERR            IF LENGTH ZERO SET CC TO 3\n         LR    R3,R1\n         MVC   XXHIDOUB(8),=12C'0'  MOVE ZEROS IN AREA TO BE CONVERTED\n         LA    R5,8\n         SR    R5,R3              # OF PADDED BLANKS\n         LA    R5,XXHIDOUB(R5)    R5 NOW ADDRESS OF CONVERTED STRING\n         BCTR  R3,0\n         EX    R3,XXHIMOVE        EX USED TO MOVE CONVERTED STRING IN\n         TR    XXHIDOUB(8),XXHITAB3 CONVERT C1-C6 TO FA-FF\n         PACK  XXHIOUT(5),XXHIDOUB(9)  DO FUNNY PACK TO MAKE RIGHT LETS\n         L     R0,XXHIOUT         CONVERTED NUMBER IN R0\n         ST    R0,XHEXINUM        STORE CONVERTED NUMBER\n         B     XXHIARND           BRANCH AROUND CONSTANTS\n         LTORG\nXXHIMOVE MVC   0(0,R5),0(R4)      MOVE FOR STRING TO BE CONVRTED\nXXHIDOUB DS    D,C                STORAGE AREA\nXXHIOUT  DS    F,C                STORAGE AREA\n         SPACE 1\n** TAB2 STOPS ON ANYTHING BUT VALID HEX DIGITS\nXXHITAB2 DC    256X'01'\n         ORG   XXHITAB2+C'A'      STOPS ON ANYTHING BUT A-F\n         DC    6X'00'\n         ORG   XXHITAB2+C'0'      STOP ONLY ON 0-9\n         DC    10X'00'\n         ORG\n         SPACE 1\n*  TAB3 USED IN TR CONVERTS TO FA-FF FROM C1-C6\nXXHITAB3 EQU   *-C'A'             CONVERT FA-FF FROM C1-C6\n         DC     X'FAFBFCFDFEFF'\n         ORG   XXHITAB3+C'0'\n         DC    X'F0F1F2F3F4F5F6F7F8F9'\n         ORG\nXXHIERR  TM    *+1,1              SET CONDITION CODE\nXXHIARND LM    14,15,XXHEXISA     RESTORE REGISTERS\n         LR    R1,R6              ENDING ADRESS IN SRTING\n         LM    R2,R6,XXHEXISA+16\n         B     XHEXIRET           RETURN TO CALLING PROG\nXXHEXISA DS    9F                 SAVE AREA FOR REGISTERS\n         DROP  R14,R15            CLEAN UP USINGS\n         SPACE 5\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> DSECT: XHEXIB   CONTROL BLOCK CREATED BY XHEXI                   *\n*        AN XHEXIB IS CREATED FOR EACH XHEXI CALL, AND CONTAINS THE   *\n*  @ XXXXHEXI MODULE, SAVE WORDS R14,R15,R0, AND A WORD VALUE THAT HAS*\n*  BEEN CONVERTED                                                     *\n*        XHEXI IS USED ONLY IN CSECT XXXXHEXI                         *\n*        GENERATION XHEXI                                             *\n*        NAMES XHEXI---                                               *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nXHEXIB   DSECT\n         DS    V(XXXXHEXI)        ADCON TO GET HERE\n         DS    3F                 STORAGE FOR REGISTERS\nXHEXINUM DS    F                  STORAGE FOR CONVERTED NUMBER\nXHEXIRET LM    R14,0,4(R14)       RESTORE REGISTERS\n.XXHEXI  AIF   (NOT &$HEXO).XXHEXO\n         TITLE 'XXXXHEXO - MODULE TO SUPPORT XHEXO PSEUDO-OP'   CPP\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*-->CSECT: XXXXHEXO EXTENDED HEXADECIMAL OUTPUT CONVERSION MODULE     *\n*        XXXXHEXO IS CALLED BY MACRO XHEXO TO CONVERT A REGISTER VALUE*\n*        TO EDITED HEXADECIMAL IN AN 8-BYTE AREA.                     *\n*        ENTRY CONDITIONS:                                            *\n*   R14= ADDRESS OF SAVEAREA FOR CALLING MACRO                        *\n*   R15= ENTRY POINT ADDRESS                                          *\n*   R0 = ADDRESS OF AREA WHERE CONVERTED STRING GOES                  *\n*   # OF REGISTER CONTAINING VALUE TO BE CONVERTED IN XHEXOREG        *\n*        EXIT CONDITIONS:                                             *\n*   8-BYTE CONVERTED VALUE FROM REGISTER ARGUMENT STORED AT ADDRESS   *\n*   POINTED TO BY LOCATION ARGUMENT                                   *\n*        USES DSECT XHEXOB.                                           *\n*        NAMES:XXHO----                                               *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nXXXXHEXO CSECT\n         USING *,15               BASE REGISTER\n         USING XHEXOB,R14         DSECT OVERLAP\n         STM   R14,R1,XXHEXOSA    STORE REGISTERS\n         L     R1,XHEXOREG        REGISTER TO BE CONVERTED\n         ST    R1,XXHOAREA        STORE NUMBER TO BE CONVERTED\n         LR    R1,R0             VALUE OF ADDRESS TO BE MOVED TO IN R1\n         L     R14,=A(XXHOTAB3-C'0')   FOR CONVERSION\n         UNPK  XXHODOUB(9),XXHOAREA(5)  CONVERT NUMBER\n         TR    XXHODOUB,0(R14)    MAKE PRINTABLE\n         MVC   0(8,R1),XXHODOUB   MOVE NUMBER INTO RIGHT AREA\nXXHOBACK LM    R14,R1,XXHEXOSA    RESTORE REGISTERS\n         B     XHEXORET           RETURN TO CALLING PROG\nXXHOTAB3 DC    C'0123456789ABCDEF'\nXXHOAREA DS    F,C                STORAGE AREA\nXXHODOUB DS    D,C                STORAGE\nXXHEXOSA DS    4F\n         LTORG\n         DROP  R14,R15            CLEAN UP USINGS\n         SPACE 5\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> DSECT: XHEXOB   CONTROL BLOCK CREATED BY XHEXO                   *\n*        AN XHEXOB IS CREATED FOR XHEXO CALL, AND CONTAINS THE @      *\n*   XXXXHEXO MODULE, SAVE WORDS FOR R14-R2 AND THE PLACE TO RETURN    *\n*        XHEXOB IS USED ONLY IN CSECT XXXXHEXO.                       *\n*        GENERATION: XXXXHEXO                                         *\n*        NAMES: XHEXO----                                             *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nXHEXOB   DSECT\n         DS    V(XXXXHEXO)        STORAGE OF VCON\n         DS    3F\nXHEXOREG DS    F                  REGISTER STORAGE\nXHEXORET LM    R14,R2,4(R14)      RESTORE REGISTERS\n.XXHEXO  ANOP\n         AIF   (&$XXIOS).XGPSKIP   SKIP IF XGET/XPUT NOT ALLOWED\n         TITLE 'CSECT***XDDTABLE*** CONTROL TABLE FOR XGET-XPUT MONIT'\nXDDTABLE CSECT\n**-->CSECT: XDDTABLE* * * * * * * * * * * * * * * * * * * * * * * * * *\n*       CONTAINS INFORMATION ON EACH FILE FOR THE MONITOR             *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n        XDDSLOT SYSIN,XREAD,POSIN=1       XREAD ONLY\n        XDDSLOT FT05F001,XREAD,POSIN=1    XREAD ONLY\n        XDDSLOT XREAD,XREAD,POSIN=1       XREAD ONLY\n        XDDSLOT INPUT,XREAD,POSIN=1       XREAD ONLY\n        XDDSLOT XPRNT,XPRNT,POSOUT=1      XPRNT ONLY\n        XDDSLOT FT06F001,XPRNT,POSOUT=1   XPRNT ONLY\n        XDDSLOT XPNCH,XPNCH,POSOUT=1      XPNCH ONLY\n        XDDSLOT FT07F001,XPNCH,POSOUT=1   XPNCH ONLY\n        XDDSLOT XSNAPOUT                  USER CAN'T TOUCH XSNAPOUT\n        XDDSLOT SYSPRINT                  USER CAN'T TOUCH SYSPRINT\n        XDDSLOT SYSLIB                    USER CAN'T TOUCH SYSLIB\n        XDDSLOT FT08F001                  USER CAN'T TOUCH FT08F001\n        XDDSLOT FT16F001,POSOUT=1    USER CAN OUTPUT\n        XDDSLOT FT17F001,POSOUT=1    USER CAN OUTPUT\n        XDDSLOT\n        XDDSLOT\n        XDDSLOT\n        XDDSLOT\n        XDDSLOT\n        XDDSLOT\nX$DDLONG EQU   *-XDDTABLE          BYTE LENGTH OF TABLE\nX$DDNUM  EQU   X$DDLONG/X$SLLONG   WILL BE SET TO # OF SLOTS\n         TITLE 'CSECT***XDDGET*** XGET-XPUT MONITOR'\nXDDGET   CSECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*-->CSECT: XDDGET (ENTRY XDDPUT)                                      *\n*        XGET - XPUT MONITOR.  USES TABLE XDDTABDE TO CONTROL         *\n*        I/O THROUGH USER CALLS TO XGET & XPUT.                       *\n*        CALLS $READ,$PRNT,$PNCH,XGET,XPUT MACROS.                    *\n*    E.X.                                                             *\n*        THE MONITOR WILL NOT PERMIT A USER TO XGET A $READ FILE,     *\n*        INSTEAD, THE MONITOR WILL CALL $READ AND THE USER WILL       *\n*        NOT KNOW ABOUT IT.                                           *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         USING XIOBLOCK,R14\n         USING *,R15\n         MVI   XDDIOBIT,X$SLXGET   SET FOR INPUT\n         LA    R15,XDDPUT          RESET ADDRESSING\n         USING XDDPUT,R15\n         B     XDDPUT+4            CONTINUE PROCESSING, KEEP INPUT FLAG\n         ENTRY XDDPUT\nXDDPUT   MVI   XDDIOBIT,X$SLXPUT   SET FOR OUTPUT\n*              COMMON FROM NOW ON\n         STM   R14,R12,XDDSAVE     SAVE REGS\n         USING XDDPUT,12           SET NORMAL ADDRESSING\n         LR    R12,R15\n         DROP  R15                 KILL R15\n         L     R3,=V(XDDTABLE)     GET THE @ OF THE TABLE\n         USING X$SLOT,R3\n         LA    R4,X$SLLONG         GET LENGTH/INCR OF ENTRY\n         LA    R5,X$SLOT+X$DDLONG-1\nXDDLOOP1 CLC   X$SLNAME(8),0(R1)   ARE NAMES SAME?\n         BE    XDDFOUND            YES, CHECK OUT REST OF ENTRY\n         BXLE  R3,R4,XDDLOOP1\n*              NOT FOUND\n         AIF   (&X$DDMOR).XDDSK1   ALLOWED OWN DDNAMES?\n*              YES                 TRY TO FIND SPACE\n         L     R3,=A(XDDTABLE)     RESET BEGINNING ADDRESS\nXDDLOOP  TM    X$SLFLAG,X$SLPERM   ENTRY TEMPORARY?\n         BZ    XDDMAKE             YES\nXDDLPBOT BXLE  R3,R4,XDDLOOP\n.XDDSK1  ANOP\n*                                  SIGNAL ERROR\nXDDFBAD  EQU   *\n         TM    *+1,X'FF'           SET COND CODE\nXDDFGOOD EQU   *\n         LM    R14,R12,XDDSAVE     RESTORE REQS\n         B     XIORETRN            RETURN\n         AIF   (&X$DDMOR).XDDSK2\n*                                  PUT DDNAME IN\nXDDMAKE  TM    X$SLFLAG,X$SLOPEN   FILE OPEN?\n         BM    XDDLPBOT            YES, TRY AGAIN\n         MVC   X$SLNAME(8),0(R1)\n         MVI   X$SLFLAG,X$SLPOIN   SET FOR POSSIBLE IN OR OUT\n         B     XDDAAAA\n.XDDSK2  ANOP\nXDDFOUND TM    X$SLFLAG,X$SLOPEN   IS IT OPEN?\n         BZ    XDDNOPEN            NO,  GO FIX UP\n         TM    X$SLFLAG,$          *****CHANGES-  GOING THE RIGHT WAY?\nXDDIOBIT EQU   *-3                 LABEL FOR IMMEDIATE BYTE\n         BO    XDDECIDE            GOING RIGHT WAY --- BRANCH\n         B     XDDFBAD             TAKE BAD BRANCH\nXDDNOPEN SR    R2,R2               EMPTY R2\n         IC    R2,XDDIOBIT\n         SRL   R2,4                MOVE BITS OVER\n         STC   R2,*+5              PUT IN TM INST BELOW\n         TM    X$SLFLAG,$ ****CHANGES*****  USER ALLOWED TO GO THIS WAY\n         BZ    XDDFBAD             NO, GO RETURN\nXDDAAAA  OC    X$SLFLAG,XDDIOBIT   SET TEMP DIRECTION BIT\nXDDECIDE SR    R2,R2               CLEAR R2\n         IC    R2,X$SLWAY\n         LH    R8,XIOLENG          SET UP LENGTH\n         B     *+4(R2)             BRANCH INTO BRANCH TABLE\n         B     XDD$GPIO            DO XGET-XPUT\n         B     XDD$READ            DO NORMAL READ\n         B     XDD$PRNT            DO NORMAL PRINT\n         B     XDD$PNCH            DO NORMAL PUNCH\nXDD$READ EQU   *\n         $READ  (R0),(R8)\n         B     XDDFGOOD            GO RETURN\nXDD$PRNT EQU   *\n         $PRNT  (R0),(R8)\n         B     XDDFGOOD            GO RETURN\nXDD$PNCH EQU   *\n         $PNCH (R0),(R8)\n         B     XDDFGOOD            GO RETURN\nXDD$GPIO EQU   *\n         LTR    R8,R8              IS LENGTH ZERO?\n         BNE   *+8                 NO, DON'T FORGET ELEMENT\n         NI     X$SLFLAG,X$SLCLOS  EMPTY ELEMENT\n         CLI   XDDIOBIT,X$SLXPUT   WAS IT OUTPUT?\n         BE    XDD$PUT             YES, DO OUTPUT\n*                                  NO,  DO INPUT\n         XGET  (R0),(R8)\n         B     XDDCLEAN\nXDD$PUT  EQU   *\n         XPUT  (R0),(R8)\nXDDCLEAN EQU   *\n*        IF COND CODE IS BAD, WIPE OUT FLAG\n         BE    XDDFGOOD            GO RETURN\n         BALR  R2,0                SAVE COND CODE FOR AFTER NI\n         NI    X$SLFLAG,X$SLCLOS   WIPE OUT FLAG\n         SPM   R2                  RESTORE COND CODE TO BEFORE NI\n         B     XDDFGOOD            GO RETURN\nXDDSAVE  DS    15F                 SAVE AREA FOR REGISTERS\n         LTORG\n         DROP  R14,R3,R12          CLEAN UP USINGS\n         TITLE 'CSECT***XXDDFINI*** CLOSE XGET-XPUT HANDLED FILES'\nXXDDFINI CSECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*-->CSECT: XXDDFINI  CLOSES XGET-XPUT FILES                           *\n*    LIKE XXXXFINI, CALLED AT SAME TIME.                              *\n*    BUT CLOSES ONLY THE FILES HANDLED BY XGET-XPUT                   *\n*                                                                     *\n*    SEARCHS TABLE XDDTABLE FOR FILES THAT ARE OPEN AND ARE HANDLED   *\n*              BY XGET-XPUT.                                          *\n*    WHEN FOUND, CLOSES THEM THROUGH XGET-XPUT. BLANKS OUT FIRST BYTE *\n*              OF NAME IN TABLE.  IF NOT PERMANENT, AND NOT OPEN,     *\n*              JUST WIPES OUT FIRST BYTE.                             *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         USING XIOBLOCK,R14        ADDRESSABILITY INTO XIOBLOCK\n         USING *,R15               TEMPORARY ADDRESSABILITY\n         STM   R14,R12,XDDFSAVE    SAVE REGISTERS\n         BALR  R12,0               SET R12\n         USING *,R12               PERMANENT ADDRESSABILITY\n         DROP  R15                 KILL R15\n         L     R3,=V(XDDTABLE)     GET THE @ OF THE TABLE\n         USING X$SLOT,R3 .         SET UP FOR TABLE\n         LA    R4,X$SLLONG         GET INCREMENT SIZE\n         LA    R5,X$SLOT+X$DDLONG-1     GET UPPER BOUNDARY\nXXDDFLOP TM    X$SLFLAG,X$SLOPEN   IS FILE OPEN\n         BZ    XXDDFCHK            NO, GO SEE IF IT IS PERMANENT\n         CLI   X$SLWAY,X$SLXGPT    IS FILE HANDLED BY XGET-XPUT?\n         BNE   XXDDFBOT            NO, CLOSED BY XXXXFINI\n         LR    R1,R3               POINT TO DD NAME\n         TM    X$SLFLAG,X$SLXGET   HANDLED BY XGET?\n         BO    XXDDFGET            YES CLOSE BY XGET\n*                                  NO, CLOSE BY XPUT\n         XPUT  XDDFSAVE,0          CLOSE, USE DUMMY OUTPUT AREA\n         B     XXDDFCHK\nXXDDFGET EQU   *\n         XGET  XDDFSAVE,0          CLOSE, USE DUMMY INPUT AREA\nXXDDFCHK NI    X$SLFLAG,X$SLCLOS   REMOVE OPEN BITS\n         TM    X$SLFLAG,X$SLPERM   IS FILE PERMANENT\n         BO    XXDDFBOT            YES, LEAVE ALONE\n         MVI   X$SLNAME,C' '       NO, BLANK OUT\nXXDDFBOT BXLE  R3,R4,XXDDFLOP      TRY NEXT ENTRY\n*                                  RAN OUT OF ENTRIES, DONE\n         LM    R14,R12,XDDFSAVE    RESTORE REGISTERS\n         BR    R14                 RETURN\nXDDFSAVE DS    15F                 SAVE AREA FOR REGISTERS\n         LTORG\n         DROP  R14,R3,R12          KILL USINGS\n         PRINT GEN\nXXXXGET  XGPGEN\nXXXXPUT  XGPGEN DIREC=P\n         PRINT NOGEN               TURN OFF AFTER\n.XGPSKIP ANOP\n         TITLE 'CSECT XXXXXIOCO  ASSIST I/O PROCESSOR'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> CSECT: XXXXIOCO   ASSIST INPUT/OUTPUT CONTROL PROCESSING         *\n*              XXXXIOCO CONTAINS ALL ACTUAL INPUT/OUTPUT OPERATIONS.  *\n*        XXXXINIT AND XXXXFINI ARE USUALLY CALLED ONCE EACH, TO       *\n*        PERFORM INITIALIZATION AND TERMINATION RESPECTIVELY.         *\n*        THE ENTRIES XXXXSORC,XXXXREAD,XXXXPNCH,XXXXPRNT ARE CALLED   *\n*        TO READ SOURCE CARDS,READ DATA CARDS, PUNCH CARDS, OR PRINT  *\n*        LINES DURING EXECUTION.  THE DCB'S FOR READ AND PNCH ARE NOT *\n*        OPENED UNLESS THEY ARE USED, AND IF USED WITHOUT WORKABLE    *\n*        OPEN'S, THEY DEFAULT BACK TO SORC AND PRNT, RESPECTIVELY.    *\n*        THESE 4 ENTIRES SHARE A COMMON BASE REGISTER (R13,ALSO @ SAVE*\n*        AREA), COMMON VALUES OF R11 (@ AJOBCON) AND R12 ( CONSTANT 1)*\n*        COMMON EXIT CODE.  SORC AND READ SHARE SOME COMMON CODE (GET)*\n*        AND PNCH AND PRNT SHARE SOME COMMON CODE (PUT).              *\n*        THESE ROUTINES ARE DESIGNED TO ACCEPT THE XIOBLOCK SET UP BY *\n*        THE XIONR MACRO($READ,$PRNT,$PNCH,$SORC). LOCATE MODE IS     *\n*        USED TO MINIMIZE MOVEMENT OF CARD AND LINE IMAGES.           *\n*        *NOTE* REMOTE OPEN/CLOSE PARM LISTS ARE USED TO SAVE SPACE.  *\n*        UNDER A DOS SYSTEM, NO SUCH LIST EXISTS DUE TO THE NON-      *\n*        EXISTENCE OF MACRO EXECUTE FORMS FOR THE CLOSING OF DTF'S    *\n*        USES MACROS:  DCB,DCBD(OS) OR DTF(DOS)   (OVERALL USE)       *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nXXXXIOCO CSECT\n         $DBG  ,NO                 SHOW NO DEBUG CODE-$SAVE/$RETURN\n         ENTRY XXXXINIT,XXXXFINI,XXXXREAD,XXXXSORC,XXXXPNCH,XXXXPRNT\n         AIF   (&$DISKU EQ 0).XXNOENT  SKIP ENTRY DEFINITION IF NODSK\n         AIF   (&$ASMLVL).XXBOS1   GEN. CORRECT DISK I/O EQUATES\nXXDECBE  EQU   4 .                 DOS 'DECB' OFFSET\nXXDECBIN EQU   0 .                 OFFSET INTO FAKE DECB - XXFIXUP\nXXDKOFFL EQU   8 .                 DOS BUFFER OFFSET, NEEDS 8 BYTES\nXXDKOPEN EQU   X'15'               DTF OFFSET FOR OPEN TEST\nXXMASK   EQU   X'04'               DOS OPEN TEST MASK\n         AGO   .XXBOS2\n.XXBOS1  ANOP\nXXDECBE  EQU   16 .                OS DECB OFFSET\nXXDECBIN EQU   12 .                OFFSET INTO OS DECB - XXFIXUP\nXXDKOFFL EQU   0 .                 OS BUFFER OFFSET, NONE NEEDED\nXXDKOPEN EQU   48 .                OS DCB DISP. FOR OPEN TEST\nXXMASK   EQU   X'10' .             OS OPEN TEST MASK.\n.XXBOS2  ANOP\n         ENTRY XXXXDKOP,XXXXDKRD,XXXXDKE1,XXXXDKWT\n.XXNOENT ANOP\n         AIF   (NOT &$MACSLB).XXNOMET    SKIP ENTRIES IF NO MACSLB\n         ENTRY XXXXLBOP,XXXXLBRD,XXXXFIND,XXXXLBED\n.XXNOMET ANOP\n         USING AJOBCON,R11         NOTE GLOBAL USING FOR WHOLE CSECT\n         SPACE 1\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> ENTRY: XXXXINIT   INITIAL OPEN FOR READER/PRINTER                *\n*        OPENS PRINTER,SOURCE CARD RDR.  INITIALIZES XXIOCPTR, WHICH  *\n*        ALWAYS HAS BEGINNING @ OF OPEN/CLOSE PARM LIST (OS GEN. ONLY)*\n*        ENTRY CONDITIONS                                             *\n*   R11= @ AJOBCON DUMMY SECTION                                      *\n*   AJIO-- FLAGS IN AJOBCON ARE ALL ZEROS.                            *\n*        EXIT CONDITIONS                                              *\n*   AJIOSO,AJIOPR FLAGGED WITH AJIOPEN IF DCB'S OPENED PROPERLY.      *\n*        USES MACROS: $RETURN,$SAVE,OPEN                              *\n*        USES DSECT: AJOBCON                                          *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nXXXXINIT $SAVE RGS=(R14-R12),SA=XXIOSAVE,BR=R6\n         ST    R11,XXIOAJOB        SAVE @ OF MAIN TABLE\n         AIF   (NOT &$MACSLB).XXINNOM  SKIP WHEN NO MACSLB ABILITY\n         MVI   XXLBFLG,X'00'       SHOW NO BUFFER(MACSLB) AT THIS POINT\n.XXINNOM ANOP\n         AIF   (&$ASMLVL).XXOSOPN  SKIP FOR OS GENERATION OPEN\n         OPEN  XXSODCB,XXPRDCB     OPEN XXSODCB, XXPRDCB RIGHT NOW\n         TM    XXSODCB+15,X'20'    DID SOURCE READER OPEN?\n         BO    *+8                 SKIP FLAGGING IF IT DIDN'T OPEN\n         OI    AJIOSO,AJIOPEN      SHOW SOURCE READER OPEN\n         TM    XXPRDCB+15,X'20'    DID LINE PRINTER OPEN?\n         BO    *+8                 SKIP FLAGGING IF IT DIDN'T OPEN\n.XXOSOPN AIF   (NOT &$ASMLVL).XXDOSOP        SKIP IF A DOS OPEN\n         LA    R1,XXIOCSP          INIT VALUE OF OPEN/CLOSE PTR\n         ST    R1,XXIOCPTR         STORE INIT VALUE OF PTR\n         OPEN  MF=(E,(1))          OPEN XXSODCB,XXPRDCB RIGHT NOW\n         TM    XXSODCB+48,X'10'    DID SOURCE READER OPEN?\n         BZ    *+8                 SKIP FLAGGING IT OPEN IF DIDN'T\n         OI    AJIOSO,AJIOPEN      SHOW SOURCE READER OPEN\n         TM    XXPRDCB+48,X'10'    DID PRINTER OPEN?\n         BZ    *+8                 SKIP FLAGGING IT OPEN IF DIDN'T\n.XXDOSOP ANOP\n         OI    AJIOPR,AJIOPEN      SHOW PRINTER OPEN\nXXIOOPRT $RETURN RGS=(R14-R12)\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> ENTRY: XXXXFINI   CLOSE ALL DCB'S WHICH ARE OPEN                 *\n*        XXXXFINI USES THE OPEN/CLOSE PARM LIST BUILT DURING EXECUTION*\n*        TO CLOSE ALL DCB'S CURRENTLY OPEN.  USES 1 EXECUTE TYPE OPEN.*\n*        DOS GENERATIONS HAVE NO OPEN/CLOSE LIST, SO A CHECK MUST BE  *\n*        MADE TO SEE WHICH DCB'S MUST BE CLOSED.                      *\n*        ENTRY CONDITIONS                                             *\n*   R11= @ AJOBCON DUMMY SECTION                                      *\n*        EXIT CONDITIONS                                              *\n*   AJIO-- FLAGS ARE ALL ZEROED OUT.                                  *\n*        USES DSECTS: AJOBCON                                         *\n*        USES MACROS: $RETURN,$SAVE,CLOSE                             *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nXXXXFINI $SAVE RGS=(R14-R12),BR=R6,SA=XXIOSAVE\n         AIF   (&$ASMLVL).XXOSCLS  SKIP FOR OS GENERATION CLOSE\n         PUT   XXPRDCB             OUTPUT LAST DOS RECORD\n         CLOSE XXSODCB,XXPRDCB     CLOSE SOURCE READER AND PRINTER\n         AIF   (NOT &$DATARD).XXNORDR     SKIP IF NO //DATA.INPUT RDR\n         TM    AJIORE,AJIOPEN      WAS OTHER READER OPENED\n         BNO   XXFIPNCH            IF NOT, THEN DON'T CLOSE IT\n         CLOSE XXREDCB             CLOSE DATA CARD READER\n.XXNORDR AIF   (NOT &$PUNCH).XXNOPNC         SKIP IF NO REAL CARD PUNCH\nXXFIPNCH TM    AJIOPN,AJIOPEN      WAS THE PUNCH OPENED\n         BNO   XXFIEXIT            IF NOT, THEN DON'T CLOSE IT\n         PUT   XXPNDCB             OUTPUT LAST PUNCHED DOS CARD\n         CLOSE XXPNDCB             CLOSE CARD PUNCH FILE\n.XXNOPNC AIF   (&$PUNCH).XXOSCLS   SKIP IF CARD PUNCH EXISTS\nXXFIPNCH EQU   *                   EQU TO EXIT, SINCE NO REAL PUNCH\n         TM    AJIODSK,AJIOPEN     IS DISK DTF OPEN\n         BO    XXFIOUT             NO - SO GO RETURN\n         CLOSE XXDKUDCB            YES - SO CLOSE DTF\nXXFIOUT  EQU   *\n.XXOSCLS AIF   (NOT &$ASMLVL).XXDOSCL     SKIP IF DOS CLOSE IN EFFECT\n         L     R1,XXIOCPTR         GET PTR TO BUILT UP OPEN/CLOSE LIST\n         CLOSE MF=(E,(1))          REMOTE CLOSE ON ALL OPEN DCB'S\n.XXDOSCL ANOP\nXXFIEXIT XC    AJIOFLAG,AJIOFLAG   CLEAR ALL FLAGS OUT\n         AIF   (NOT &$ASMLVL).XXFIF1   SKIP IF NOT OS/360\n*              FOLLOWING CODE REQUIRED FOR PROPER REUSABILITY.\n         L     R2,XXIOCPTR         GET @ BEGINNING OF DCB @ LIST\n         SPACE 1\nXXFIFREE L     R1,0(,R2)           GET @ NEXT DCB\n         AIF   ((&$DISKU EQ 0) AND (NOT &$MACSLB)).XXFINA\n         USING IHADCB,R1           NOTE USING ON R1\n         TM    DCBBUFCB+3,1        DOES DCB OWN A BUFFER POOL OR NOT\n         BO    XXDCBLST            SINCE ODD @, NO BUFFER POOL - BRANCH\nXXFRPOOL FREEPOOL (1)              DO THE FREEPOOL TO GET RID OF BUFS\nXXDCBLST TM    0(R2),X'80'         WAS THAT THE LAST?\n         AGO   .XXFINB\n.XXFINA  ANOP\n         FREEPOOL (1)              DO THE FREEPOOL TO GET RID OF BUFS\n         TM    0(R2),X'80'         WAS THAT ONE THE LAST ONE?\n.XXFINB  ANOP\n         LA    R2,4(R2)            INCREMENT TO NEXT DCB @\n         BNO   XXFIFREE            NOT LAST, GO BACK FOR NEXT ONE\n         SPACE 1\n.XXFIF1  ANOP\n         $RETURN RGS=(R14-R12),SA=XXIOSAVE\n         DROP  R6                  KILL USING\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*         REGISTER USAGE FOR SECTIONS SORC,READ,PNCH,PRNT             *\n*   R0 = @ I/O AREA WHERE USER DESIRES DATA MOVED TO/FROM             *\n*   R1 = @ DCB FOR OPERATION (SET BEFORE ENTRY TO SECTIONS GET, PUT   *\n*   R2 = @ CONTROL BYTE FOR READER SECTIONS, SET BEFORE ENTRY TO GET  *\n*   R3,R4 WORK REGISTERS                                              *\n*   R5 = DOS IOREG FOR BOTH GET & PUT OPERATIONS                      *\n*   R6,R7,R8,R9,R10  ARE NOT MODIFIED OR USED                         *\n*   R11= @ AJOBCON, MAIN CONTROL DUMMY SECTION                        *\n*   R12= 1, USEFUL CONSTANT                                           *\n*   R13= @ SAVE AREA XXIOSAVE, ALSO COMMON BASE REGISTER              *\n*   R14= @ XIOBLOCK, CONTAINING LENGTH OF I/O REQUEST                 *\n*   R15= LOCAL WORK REGISTER, TEMPORARY SINCE I/O OPRS MODIFY.        *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n         USING XXIOSAVE,R13        NOTE GLOBAL USING\n         USING XIOBLOCK,R14        NOTE PTR TO XIOBLOCK, GLOBAL\n         AIF   (NOT &$DATARD).XXNDAT0       SKIP IF NO //DATA.INPUT RDR\n         SPACE 2\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> ENTRY: XXXXREAD   READ 1 CARD AT USER EXECUTION TIME             *\n*        OPENS CARD READER(DDNAME FT05F001) IF NOT ALREADY OPEN, OR   *\n*        USES OPEN READER (DDNAME FT00F001) TO GET 1 CARD, USING THE  *\n*        COMMON CODE SECTION XXIOGET.  IF NODATA WAS SPECIFIED IN THE *\n*        USER PARM FIELD, NO OPEN WILL BE DONE FOR  FT05F001, BUT     *\n*        SYSIN WILL BE USED INSTEAD.  CALLED BY $READ MACRO.          *\n*        ENTRY CONDITIONS                                             *\n*   R0 = @ I/O AREA WHERE DATA TO BE READ/WRITTEN                     *\n*   R14= @ XIOBLOCK CREATED BY THE CALLING XIONR MACRO.               *\n*   R15= ENTRY POINT ADDRESS                                          *\n*        EXIT CONDITIONS                                              *\n*   CC=  0     NORMAL RETURN, CARD WAS READ AND TRANSFERRED TO USER   *\n*   CC=  1     ENDFILE ON READER.  IF ASSIST JCL, SAVED IN AJOBCON.   *\n*        USES MACROS:   GET,OPEN                                      *\n*        USES DSECTS: AJOBCON,XIOBLOCK                                *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n         USING XXXXREAD,REP        NOTE TEMPORARY USING\nXXXXREAD STM   R11,R5,XXIOSAVT     STORE REGS TO BE CHANGED\n         LM    R11,R13,XXIOAJOB    LOAD NEEDED VALUES\n         DROP  REP                 KILL TEMPORARY USING\n         TM    AJIORE,AJIOPEN      WAS IT ALREADY OPEN?\n         BO    XXREC               YES,GO DO GET\n         TM    AJIORE,AJIODFLT     ARE WE USING SOURCE RDR INSTEAD?\n         BO    XXSORE              YES, SO USE SORC READER INSTEAD\n*              CALL OPTIONAL USING OPEN ROUTINE TO OPEN RDR IF IT CAN.\n         LA    R2,AJIORE           SHOW @ RDR CONTROL BYTE\n         AIF   (&$ASMLVL).XXNDTF   SKIP IF UNDER OS GENERATION\n         LA    R1,XXREDCB          SHOW @ OF DOS DCB\n.XXNDTF  AIF   (NOT &$ASMLVL).XXNIOCR  SKIP IF UNDER DOS GENERATION\n         LA    R3,XXIOCRE          SHOW @ OF OPEN/CLOSE PARM VALUE\n.XXNIOCR ANOP\n         BAL   R4,XXIOPENO         CALL OPEN/FLAGGING SECTION\n         BZ    XXIOGET             IF OK, ALL SET UP-GO READ\n         B     XXSORE              OPEN DIDN'T GO, USE SOURCE RDR\n         SPACE 1\nXXREC    LA    R1,XXREDCB          SHOW @ DCB\n         LA    R2,AJIORE           SHOW @ CONTROL BYTE\n         B     XXIOGET             GO TO COMMON GET ROUTINE\n.XXNDAT0 AIF   (&$DATARD).XXNDAT2  SKIP IF DATA RDR EXISTS\nXXXXREAD EQU   *                   EQU TO XXXXSORC-DATA RDR ^EXIST\n.XXNDAT2 ANOP\n         SPACE 2\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> ENTRY: XXXXSORC   READ A CARD DURING ASSEMBLY TIME               *\n*        CALLED BY MACRO $SORC TO READ CARD FOR ASSEMBLER, USING      *\n*        ALREADY OPEN DCB (DDNAME SYSIN).                             *\n*        ENTRY CONDITIONS - SAME AS THOSE FOR ENTRY XXXXREAD.         *\n*        EXIT CONDITIONS  - SAME AS THOSE FOR ENTRY XXXXREAD.         *\n*        USES DSECTS: AJOBCON,XIOBLOCK                                *\n*        USES MACROS: GET                                             *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n         USING XXXXSORC,REP        NOTE TEMPORARY USING\nXXXXSORC STM   R11,R5,XXIOSAVT     STORE REGS TO BE CHANGED\n         LM    R11,R13,XXIOAJOB    LOAD NEEDED VALUES\n         DROP  REP                 KILL TEMPORARY USING\n         AIF   (NOT &$MACSLB).XXNOSOC  SKIP IF NO MACRO LIBRARY\nXXSWTCH  BC    $,XXXXLBRD          GET A CARD FROM LIBRARY-MAYBE\n.XXNOSOC  ANOP\n         CLI   AJOBTRQ,AJO$D       REQUEST FOR DATA?                  J\n         BE    XXIOBTAA            YES, NO NEED FRO SPECIAL CHECKS    J\n*              AT THIS POINT, ASSIST IS ASKING FOR A $JOB/$ENTRY CARD J\n         NI    AJIOSO,255-AJIOPSEO MAKE SURE NO PSEUD-END-FILE ON     J\n         AIF   (NOT &$HASPBT).XXIOBTA   SKIP IF NO HASP AUTOBATCH     J\n         TM    AJIOSO,AJIOSOHS     DO WE NEED BUFFER FLUSH?           J\n         BZ    XXIOBTAA            NO,SKIP OVER IT                    J\n         NI    AJIOSO,255-AJIOSOHS REMOVE FLAG SO WON'T DO AGAIN      J\n*              JUST PREVIOUSLY, TWO OS NULL CARDS HAD BEEN FOUND, AND J\n*              ASSIST WANTS TO READ FOR THE NEXT $JOB CARD, IN WHICH  J\n*              CASE HASP MAY WANT TO PERFORM TERMINATION.  IT IS USED J\n*              THUSLY.   IF USING MULTIPLE BUFFERS, CONSIDER CHANGING J\n*              THIS TO CLOSE/OPEN ON XXPRDCB.                         J\n*              IT IS NECESSARY TO PUT A BLANK LINE (SINCE LOCATE MODE)J\nXXSORD   PUT   XXPRDCB             DO PUT LOCATE\n         LH    R2,XXPRDCB+DCBLRECL-IHADCB   GET ACTUAL RECORD LENGTH  J\n         BCTR  R2,0                GET LENGTH-1 FOR MVC               J\n         STC   R2,*+5              PUT LENGTH-1 INTO MVC              J\n         MVC   0($,R1),AJOBLANK    PUT OUT A BLANK LINE TO FLUSH      J\n.XXIOBTA ANOP                                                         J\nXXIOBTAA EQU   *                   BRANCH IF DATA OR NO BUFFER FLUSH  J\nXXSORE   LA    R1,XXSODCB          SHOW @ DCB\n         LA    R2,AJIOSO           SHOW @ CONTROL BYTE\n         SPACE 2\n* * * * * XXIOGET - COMMON GET CODE FOR XXXXSORC AND XXXXREAD         *\nXXIOGET  TM    0(R2),AJIOEOF+AJIOPSEO    WAS EITHER EOF FLAG ALREADY ON\n         BNZ   XXIORETA            YES, REFUSE TO READ A CARD NOW\n         LM    R14,R0,XXIOSAVT+12  RELOAD ORIG VALUES, IN CASE CHANGED\n         LH    R3,XIOLENG          GET THE LENGTH OF OPERATION FROM XIO\n         LR    R4,R0               MOVE @ AREA OVER FOR SAFEKEEPING\n         TM    AJIOSO,AJIOSORR     WAS REREAD REQUIRED?               J\n         BZ    *+16                NO, BRANCH AND READ NEXT CARD      J\n         L     R1,XXIOLSTC         REREAD- GET @ OF LAST BUFFER       J\n         NI    AJIOSO,255-AJIOSORR CLEAR FLAG SO DON'T REREAD AGAIN   J\n         B     XXIOBTBB            BRANCH AROUND READ                 J\n         GET   (1)                 DO GET LOCATE ON DCB @\n         AIF   (&$ASMLVL).XXNIORG      SKIP IF OS & HAVE NO IOREG (PUT)\n*        WHEN DOS ISSUES A GET, R5 IS USED AS ITS IOREG (SINCE R1     *\n*        IS ILLEGAL) TO POINT TO INPUT BUFFER. MUST LOAD R1 NOW.      *\n         LR    R1,R5               GET @ OF INPUT RECORD\n.XXNIORG ANOP\n         ST    R1,XXIOLSTC         SAVE ADDRESS OF THIS BUFFER        J\nXXIOBTBB EQU   *                   BRANCH HERE IF DOING REREAD        J\n         SPACE 1\n*              ***** BATCH CONTROL CARD PROCESSING *****\n*              IF NOT RUNNING BATCH MODE, ANYTHING GOES; ELSE $JOB &\n*              $ENTRY CARDS CREATE PSEUDO EOF AND ARE SAVED. $STOP\n*              SETS REAL EOF FLAG TO TERMINATE PROCESSING\n         TM    AJOMODE,AJOBATCH    ARE WE IN BATCH MODE\n         BNZ   XXIOBTCC            YES, GO LOOK FOR CONTROL CARDS     J\n         SPACE 1\n*              THRU HERE ==> NORMAL CARD-SIMULATE READ\nXXIONORM EQU   *                   ENTER HERE FOR NORMAL CARD\n         SR    R3,R12              SUBTRACT 1 FROM LENGTH\n         BM    XXIORETB            0 LENGTH READ(MUST BE FLUSHING)\n         STC   R3,*+5              STORE LENGTH - 1 INTO MOVE\n         MVC   0($CHN,R4),0(R1)    MOVE DESIRED PART OF CARD OVER\n         AIF   (NOT &$KP26).XXNKP26         SKIP IF NO 026 KEYPUNCH\n         SPACE 1\n*              IF KP=26 OPTION USED, TRSANSLATE CARD TO EBCDIC.\n         TM    AJIOSO,AJIOKP26     WAS KP=26 OPTION SPECIFIED\n         BZ    XXIOKP29            NO, DON'T TRANSLATE, ALREADY -29\n         STC   R3,*+5              STORE LENGTH-1 INTO TR\n         TR    0($,R4),AJTRTB26    TRANSLATE AMOUNT READ BY RDR TO 029\nXXIOKP29 EQU   *                   SKIP HERE IF NO TRANSLATE NEEDED\n.XXNKP26 ANOP\n         B     XXIORETB            RETURN, SHOWING NORMAL RETURN      P\n         SPACE 1                                                      J\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *J*\n*         BATCH CONTROL CARD SCANNING PROCESS -  NEW FOR VERSION 3.0 J*\n*         THIS VERSION INCORPORATES MORE FLEXIBILITY, AND ALSO       J*\n*         SUPPORTS HASP AUTOBATCH CODE AS AN OPTION.  MODULE ASSIST  J*\n*         SETS FLAG AJOBTRQ TO SHOW THE TYPE OF CONTROL CARD THAT IT J*\n*         IS REQUESTING (AJOBTRQ=0 OTHERWISE).  ACTIONS THEN DEPEND  J*\n*         ON THE TYPE REQUESTED AND THE INPUT FOUND.  NOTE THAT THIS J*\n*         CODE NOW PERFORMS THE FLUSH TO CONTROL CARD, RATHER THAN   J*\n*         HAVING ASSIST LOOP LOOKING FOR ONE.                        J*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *J*\nXXIOBTCC CLI   0(R1),C'&$BTCC(1)'  DOES CARD HAVE CONTROL CHARACTER?  J\n         BNE   XXIOBTEE            NO, CAN'T BE CONTROL CARD, BRANCH  J\n         CLC   =C'&$BTCC(2)',1(R1) IS IT JOB BEGINNER?                J\n         LA    R15,AJO$J           SHOW CODE FOR JOB BEGINNER         J\n         BE    XXIOBTFF            YES, GO HANDLE IT                  J\n         AIF   ('&$BTCC(3)' EQ '').XXIOBT3   SKIP IF NO $ENTRY WANTED J\n         CLC   =C'&$BTCC(3)',1(R1) WAS IT $ENTRY OR EQUIVALENT?       J\n         LA    R15,AJO$E           SHOW CODE FOR $ENTRY               J\n         BE    XXIOBTFF            YES, GO TO PROCESS IT              J\n.XXIOBT3 AIF   ('&$BTCC(4)' EQ '').XXIOBT4  SKIP IF $STOP NOT ALLOWED J\n         CLC   =C'&$BTCC(4)',1(R1) IS THIS A $STOP CARD OR EQUIV?     J\n         BE    XXIOEOF             YES, TREAT AS REAL EOF             J\n.XXIOBT4 ANOP                                                         J\nXXIOBTEE SR    R15,R15             SET = AJOB$D, NOT A CONTROL CARD   J\nXXIOBTFF EQU   *                   COME HERE TO MAKE PROCESS DECISION J\n         SPACE 1                                                      J\n         AIF   (NOT &$HASPBT).XXIOBT6  SKIP IF NOT HASP AUTOBATCH     J\n*              HASP AUTOBATCH CODE FOLLOWS: SET UP TO READ OVER OS    J\n*              JOB CARDS, HANDLE TWO NULLS AS REQUIRED, ALLOW READING J\n*              OF SINGLE NULL, AND MAKE UP DUMMY $JOB CARD IF OMITTED J\n*              FOLLOWING OS JOB CARD.                                 J\n         CLC   0(2,R1),=C'//'      WAS THIS CARD // CARD?             J\n         BNE   XXIOBTSS            NO, GO TO DETERMINE ACTION         J\n         CLC   2(70,R1),AJOBLANK+2       WAS IT NULL CARD (COLS 3-72)?\n         BNE   XXIOBTNN            NO, NOT A NULL CARD AT ALL-BRANCH  J\n*              AT THIS POINT, WE HAVE 1 NULL.  NOW CHECK FOR 2ND.     J\n         GET   XXSODCB             READ CARD, SET R1 => CARD          J\n         ST    R1,XXIOLSTC         MAKE SURE @ CARD SAVED FOR LATER   J\n         CLC   0(2,R1),=C'//'      COULD IT BE NULL?                  J\n         BNE   XXIOBTHH            NO, GO TO HANDLE SINGLE NULL(GAH)  J\n         CLC   2(70,R1),AJOBLANK+2       WAS IT NULL CARD (COLS 3-72)?\n         BNE   XXIOBTHH            NOT NULL- BRANCH                   J\n*              TWO NULL CARDS FOUND - ACTION DEPENDS ON REQUEST TYPE. J\n         CLI   AJOBTRQ,AJO$J       WAS $JOB CARD ASKED FOR?           J\n         BE    XXSORD              YES, GO BUFFER FLUSH AND DO GET    J\n         OI    AJIOSO,AJIOSOHS     NEXT TIME-SHOW WILL NEED BUFFER FLSH\n         AIF   ('&$BTCC(3)' EQ '').XXIOBT5 SKIP IF NO $ENTRY          J\n         MVI   AJOBTYP,AJO$J       FAKE TO MAKE $ENTRY REQ QUIT       J\n         CLI   AJOBTRQ,AJO$E       WAS IT ACTUALLY $ENTRY?            J\n         BE    XXIORETB            RETURN NORMAL, WILL CALL FOR $JOB  J\n.XXIOBT5 B     XXIOASJC            GO SHOW PSEUDO-END-FILE            J\n*              FOLLOWING CODE FOR SINGLE NULL BY ITSELF IN JOB(?)     J\nXXIOBTHH MVC   AJOJCLCD,AJOBLANK   BLANK OUT WORK AREA                J\n         MVC   AJOJCLCD(2),=C'//'  CREATE DUMMY NULL CARD             J\n         LA    R1,AJOJCLCD         SHOW @ NULL CARD                   J\nXXIOBTJJ OI    AJIOSO,AJIOSORR     REREAD,DON'T LOSE LAST CARD        J\n         SR    R15,R15             SHOW AJO$D => NON-CONTROL CARD     J\n         B     XXIOBTSS            GO TO DETERMINE ACTION NEEDED      4\n*              FOLLOWING CODE IF // CARD, BUT NOT NULL CARD           J\nXXIOBTNN CLI   AJOBTRQ,AJO$J      SHOULD WE BE SCANNING FOR $JOB      J\n         BNE   XXIOBTSS            NO, SO TREAT AS NORMAL DATA CARD   J\n*              WE ASSUME THAT WE'RE ACTUALLY LOOKING AT OS JOB CARD   J\n*              NOW: HERE IS PLACE FOR ACCOUNTING IF YOU WANT IT.      J\n         GET   XXSODCB             SKIP OVER THE CARD                 J\n         ST    R1,XXIOLSTC         SAVE @, IN CASE NEEDED LATER       J\n         CLC   =C'&$BTCC(1)&$BTCC(2)',0(R1)  WAS IT A $JOB NEXT       J\n         BE    XXIOBTOO            YES, THIS IS WHAT WE WANTED        J\n*              NO $JOB CARD AFTER OS JOB: BE NICE AND FAKE ONE.       J\n*              FOLLOWING STATEMENT CAN BE USED TO SUPPLY PARMS, SINCE J\n*              ASSIST THINKS IT'S A $JOB CARD.  CHANGE AS DESIRED.    J\n         MVC   AJOJCLCD,AJOBLANK   BLANK OUT CARD WORKAREA            J\n         MVC   AJOJCLCD(15),=CL15'&$BTCC(1)&$BTCC(2) ASSUMED'         J\n         LA    R1,AJOJCLCD         SHOW ADDRESS OF ASSEMBLED FAKE CARDJ\n         OI    AJIOSO,AJIOSORR     MARK, SO DON'T LOSE LOOKAHEAD      J\nXXIOBTOO LA    R15,AJO$J           FAKE CODE OF $JOB CARD             J\n.XXIOBT6 ANOP\n*              FOLLOWING CODE EXPECTS R15=0,1,2 TO INDICATE TYPE OF   J\n*              CARD FOUND (DATA, $JOB, $ENTRY(MAYBE)).  USE TABLE TO  J\n*              DETERMINE ACTION: FUNCTION OF TYPE REQESTED&THAT FOUND.J\nXXIOBTSS STC   R15,AJOBTYP         SHOW THE TYPE ACTUALLY FOUND       J\n         MH    R15,=H'3'           MULTIPLY TO GET OFFSET OF TABLE ROW\n         SR    R14,R14             CLEAR FOR INSERT                   J\n         IC    R14,AJOBTRQ         GET COLUMN SELECTOR: TYPE REQUEST  J\n         AR    R15,R14             GET OFFSET OF CODE BYTE IN TABLE   J\n         IC    R15,XXIOBTAB(R15)   GET CODE BYTE TO DETERMINE ACTION  J\n*              ACTIONS:  0: LOOP (SEARCHING FOR $JOB/$ENTRY CARD);    J\n*              4: RETURN NORMAL, COPYING CARD TO REQUESTED AREA;      J\n*              8:  EXIT WITH END-FILE (CONTROL CARD FOUND IN DATA)    J\n         B     *+4(R15)            TAKE INDEXED BRANCH                J\n         B     XXSORE              0: LOOP, HUNTING CONTROL CARD      J\n         B     XXIONORM            4: NORMAL RETURN, COPY CARD        J\n*                                  8: FALL THRU INTO XXIOASJC         J\nXXIOASJC OI    AJIOSO,AJIOPSEO+AJIOSORR PSEUDO-EOF, REREAD TO SAVE CARD\n         B     XXIORETA            SHOW A PSEUDO END-FILE\nXXIOEOF  OI    0(R2),AJIOEOF       SHOW END-FILE HAS OCCURRED\n         B     XXIORETA            RETURN SHOWING END-FILE\n*              ACTION CONTROL TABLE: USED IN XXIOBTSS CODE.  CHANGE   J\n*              AS NEEDED IF DIFFERENT ACTIONS DESIRED.                J\n*  AJOBTRQ=        DATA,$JOB,$ENTRY   (REQUEST).  ACTUAL FOUND BELOW  J\nXXIOBTAB DC    AL1(0004,0000,0000)    DATA FOUND- NORMAL, LOOP, LOOP  J\n         DC    AL1(0008,0004,0004)    $JOB FOUND- EOF, NORMAL, NORMAL J\n         DC    AL1(0008,0000,0004) $ENTRY FOUND- EOF,LOOP,NORMAL      J\nXXIOLSTC DS    A                   @ LAST CARD READ, FOR REREAD USE   J\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> ENTRY: XXXXPNCH   PUNCH A CARD, OPENING IF REQUIRED              *\n*        CALLED BY $PNCH MACRO TO PUNCH A CARD (DDNAME FT07F001).  IF *\n*        THE DCB XXPNDCB CANNOT BE OPENED, OR IF NOPUNCH WAS USED IN  *\n*        THE USER PARM FIELD, THE CARD IS PRINTED (DDNAME FT06F001)   *\n*        WITH ' CARD-->' PRECEDING IT TO NOTE USAGE.                  *\n*        ENTRY CONDITIONS - SAME AS ENTRY XXXXREAD                    *\n*        EXIT CONDITIONS                                              *\n*   CC=  0     NORMAL RETURN, CARD WAS PUNCHED OR PRINTED             *\n*   CC=  1     RECORD LIMIT HAS BEEN EXCEEDED, CARD PUNCHED ANYWAY    *\n*        USES DSECTS: AJOBCON,IHADCB,XIOBLOCK                         *\n*        USES MACROS: OPEN,PUT                                        *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n         USING XXXXPNCH,REP        NOTE TEMPORARY USING\nXXXXPNCH STM   R11,R5,XXIOSAVT     SAVE REGS TO BE CHANGED\n         LM    R11,R13,XXIOAJOB    LOAD NEEDED VALUES\n         DROP  REP                 KILL TEMPORARY USING\n         AIF   (NOT &$PUNCH).XXNPN0    SKIP IF NO REAL PUNCH\n         LA    R2,AJIOPN           SHOW @ CONTROL BYTE\n         TM    AJIOPN,AJIOPEN      HAS PUNCH BEEN OPENED?\n         BO    XXPNC               YES, SO GO DO IT\n         TM    AJIOPN,AJIODFLT     ARE WE ALREADY USING PRINTER?\n         BO    XXPNNOPN            YES, SO GO FIX UP\n         SPACE 1\n*              CALL OPTIONAL UNIT OPEN ROUTINE TO OPEN PUNCH IF IT CAN.\n         AIF   (&$ASMLVL).XXYIOCR  SKIP IF UNDER OS GENERATION\n         LA    R1,XXPNDCB          SHOW @ OF DOS PUNCH DCB\n.XXYIOCR AIF   (NOT &$ASMLVL).XXYSDTF  SKIP IF UNDER DOS GENERATION\n         LA    R3,XXIOCPN          SHOW @ OPEN/CLOSE PARM VALUE\n.XXYSDTF ANOP\n         BAL   R4,XXIOPENO         CALL OPEN/FLAGGING ROUTINE, SETS CC\n         BZ    XXIOPUT             IF OK, ALL SET UP, SO GO PUNCH\nXXPNNOPN EQU   *                   SECTION TO USE PRINTER FOR PUNCH\n.XXNPN0  ANOP\n         LR    R2,R0               SAVE @ I/O AREA\n         MVC   AJOPNDFT(8),=C' CARD-->'     ENTER CARD FLAG\n         MVC   AJOPNDFT+8(80),0(R2)         MOVE POSSIBLE CARD OVER\n         LA    R0,AJOPNDFT         FAKE I/O @ TO BE THIS AREA\n         LH    R3,XIOLENG          GET LENGTH DESIRED TO PUNCH\n         LA    R3,8(R3)            ADD EXTRA LENGTH OF ' CARD-->'\n         LA    R1,XXPRDCB          SHOW @ OF PRINTER INSTEAD\n         LA    R2,AJIOPR           SHOW @ CONTROL BYTE(IN CASE PAGE)\n         B     XXPRPN              PRINT CARD INSTEAD OF PUNCHING\n         AIF   (NOT &$PUNCH).XXNPN1         SKIP IF NOPUNCH\n         SPACE 1\nXXPNC    LA    R1,XXPNDCB          SHOW @ DCB\n         B     XXIOPUT             GO TO COMMON PUT SECTION\n.XXNPN1  ANOP\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> ENTRY: XXXXPRNT   PRINT ONE LINE OF OUTPUT                       *\n*        CALLED BY $PRNT MACRO TO PRINT 1 LINE, USING DDNAME FT06F001.*\n*        ENTRY CONDITIONS - SAME AS ENTRY XXXXREAD                    *\n*        EXIT CONDITIONS - SAME AS XXXXPNCH                           *\n*        USES DSECTS: AJOBCON,IHADCB,XIOBLOCK                         *\n*        USES MACROS: PUT                                             *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n         USING XXXXPRNT,REP        NOTE TEMPORARY BASE\nXXXXPRNT STM   R11,R5,XXIOSAVT     SAVE REGS TO BE CHANGED\n         LM    R11,R13,XXIOAJOB    LOAD NEEDED VALUES\n         DROP  REP                 KILL TEMPORARY USING\n         LA    R1,XXPRDCB          SHOW @ PRINTER DCB\n         LA    R2,AJIOPR           SHOW @ PRINTER CONTROL BYTE\n         SPACE 1\n* * * * * XXIOPUT - COMMON PUT ROUTINE FOR PNCH, PRNT                 *\nXXIOPUT  TM    AJOMODE,AJOSRECX    ARE RECORDS ALREADY EXCEEDED\n         BO    XXIORETA            YES, IGNORE THIS GUY\n         SPACE 1\n         LH    R3,XIOLENG          GET LENGTH OF REQUEST\n*              ***** OUTPUT RECORD COUNT AND TESTING *****\nXXPRPN   EQU   *                   ENTRY POINT IF FAKING PUNCH ON PRNTR\n         L     R15,AJORECNT        GET CURRENT RECORDS REMAINING\n         SR    R15,R12             DECREMENT\n         BM    XXIOVERP            SKIP OUT, NO MORE-DON'T WRITE\n         ST    R15,AJORECNT        STORE UPDATED COUNTER BACK\n         SPACE 1\n         AIF   (NOT &$PAGE).XXNPAG2         SKIP WHOLE SECT IF NO PAGE\n         LR    R15,R0              MOVE @ USER AREA WHERE CAN USE IT\n         MVC   AJIOWRKB,0(R15)     SAVE 1ST BYTE WHERE WE CAN GET IT\n         TM    0(R2),AJIOPAGE      ARE WE 1)PRINTING AND 2)IN PAGE CONT\n         BZ    XXNPAGEC            NO, WE AREN'T IN PAGE CONTROL MODE-B\n         SPACE 1\n*              ***** PAGE CONTROL MODE - PERFORM COINT,CHECK *****\n         MVC   XXIOPCLI+1(1),0(R15)    MOVE CARRIAGE CONTROL IN FOR CLI\n         LA    R2,XXIOPGTA         BEGINNING @ LEGAL CAR CON BYTE TABLE\n         LA    R14,4               INCREMENT FOR BXLE SEARCH\n         LA    R15,XXIOPGTZ        @ LAST ELEMNT IN TABLE,BXLE LIMIT\n         SPACE 1\nXXIOPCLI CLI   0(R2),$             COMPARE TABLE ELEMENT TO USER CARCON\n         BE    XXIOPFND            FOUND WHAT HE USED-BRANCH\n         BXLE  R2,R14,XXIOPCLI     LOOP UNTIL FIND IT OR RUN OUT\n         SPACE 1\n         LA    R2,XXIOPGTB         @ BLANK CARRAGE CONTROL TABLE ELEM.\nXXIOPFND EQU   *                   CHARACTER FOUND\n         TM    AJIOPR,AJIOSING     ARE WE IN CRUNCHED SINGLESPACE MODE?\n         BZ    XXIONSIN            NO, NOT SINGLE SPACE MODE\n*              FOLLOWING IMPLEMENTS SINGLE SPACE MODE, WHICH SINGLE\n*              SPACES ANY CARRIAGE CONTROL EXCEPT '1', WHICH IS JUST\n*              DOUBLE SPACED INSTEAD OF NEW PAGED.  THIS MAY BE USEFUL\n*              FOR CRAMMING AS MUCH OUTPUT AS POSSIBLE IN GIVEN #\n*              OF PAGES, OR OBTAINING AS MUCH OF A DUMP AS POSSIBLE.\n         IC    R14,1(,R2)          GET OFFSET TO WORD FOR REPLACEMENT\n         LA    R2,XXIOPGTA(R14)    GET @ REPLACEMENT CARRIAGE CONTROL\nXXIONSIN EQU   *                   SKIP HERE IF NO SINGLE SPACE\n         MVC   AJIOWRKB,0(R2)      PICK UP CORRECT BYTE FOR CC\n         SPACE 1\n         LM    R14,R15,AJOLREM     GET AJOLREM-AJOPREM FOR TESTING\n         SH    R14,2(R2)           LINES REMAINING-LINES FOR GIVEN CCON\n         BP    XXIOPSTL            STILL MORE-JUMP-NO OVERFLOW\n         SPACE 1\n*              OVERFLOW TO NEXT PAGE- COUNT <= 0\n         MVI   AJIOWRKB,C'1'       SHOW NEW PAGE CARRAGE CONTROL\n         L     R14,AJOL            RESET # LEFT ON PAGE TO LIMIT\n         SR    R15,R12             # PAGES LEFT = # PAGES LEFT -1\n         ST    R15,AJOPREM         STORE UPDATED PAGES REMAINING\n         BM    XXIOVERP            PAGE COUNT EXCEEDED-SHOW OVERFLOW\nXXIOPSTL ST    R14,AJOLREM         STORE BACK COMPLETED LINES LEFT\nXXNPAGEC EQU   *                   BRANCH HERE IF NO PAGE CONTROL ON\n.XXNPAG2 ANOP\n         SPACE 1\n         LR    R2,R0               MOVE @ DATA AREA OVER WHERE SAFE\n         AIF   (&$ASMLVL).XXOSREC  SKIP IF UNDER OS GENERATION\n         L     R4,8(R1)            @ OF DTF CCW (CONTAINS LRECL-1)\n         LH    R4,6(R4)            ORIGINAL DTF LRECL FIELD - 1\n         LA    R4,1(R4)            +1 => ORIGINAL DTF LRECL\n         PUT   (1)                 DO DOS PUT, WITH IOREG AS SPECIFIED\n*        WHEN DOS ISSUES A PUT, R5 IS USED AS THE IOREG (SINCE R1 IS  *\n*        ILLEGAL) TO POINT TO NEXT OUTPUT BUFFER.  GET @ INTO R1.     *\n         LR    R1,R5               @ OF DOS DTF OUTPUT BUFFER\n.XXOSREC AIF   (NOT &$ASMLVL).XXDSREC  SKIP IF UNDER DOS GENERATION\n         USING IHADCB,R1           USING FOR DCB DUMMY SECTION\n         LH    R4,DCBLRECL         GET LRECL FIELD FROM DCB\n         DROP  R1                  KILL USING\n         PUT   (1)                 DO PUT LOCATE\n.XXDSREC ANOP\n*              NEXT 3 STMTS GUARD AGAINST I/O OF LENGTH > REAL LENGTH.\n         CLR   R3,R4               IS I/O <= LRECL (CLR RATHER THAN CR)\n         BNH   *+6                 YES, GOOD PERSON, SKIP OVER\n         LR    R3,R4               NO, BAD PERSON, USE LRECL\n         SR    R3,R12              DECREMENT LENGTH TO L-1\n         BM    XXIOPUTA            SKIP IF 0 LENGTH\n         STC   R3,*+5              STORE LENGTH-1 FOR MOVE\n         MVC   0($CHN,R1),0(R2)    MOVE DATA OVER\nXXIOPUTA SR    R4,R12              DECREMENT REG -LRECL FIELD\n         AIF   (NOT &$PAGE).XXNPAG4         SKIP IF NO PAGE CONTROL\n         MVC   0(1,R1),AJIOWRKB    PUT IN POSSIBLY-CHANGED CAR CON BYTE\n.XXNPAG4 ANOP\n         AR    R1,R3               GET @-1 OF 1ST BYTE FOR BLANK PAD\n         SR    R4,R3               GET # BLANKS REQUIRED FOR PAD\n         BZ    XXIOPUTC            SKIP IF NO BLANK PAD\n         SR    R4,R12              DECREMENT TO L-1 FOR PAD\n         STC   R4,*+5              STORE L-1 INTO MOVE\n         MVC   1($CHN,R1),AJOBLANK BLANK PAD AT END OF RECORD\nXXIOPUTC EQU   *                   EXIT HERE FOR NORMAL RETURN\n         SPACE 1\n* * * * * COMMON EXIT CODE FOR SORC,READ,PNCH,PRNT                    *\n*        THIS SECTION MUST IMMEDIATELY FOLLOW XXIOPUT SECTION.        *\n*        XXIORETA SETS CONDITION CODE TO 1, SHOWING EITHER END-FILE   *\n*        ON INPUT DEVICE, OR RECORD OVERFLOW ON OUTPUT DEVICE.        *\n*        XXIORETB SETS CC = 0 TO SHOW NO SPECIAL CONDITION.           *\nXXIORETB SR    R0,R0               SET CC TO 0\nXXIORETC LM    R11,R5,XXIOSAVT     RELOAD CHANGED REGS\n         B     XIORETRN            RETURN APPROPRIATELY\nXXIOVERP OI    AJOMODE,AJOSRECX    SHOW PAGES/RECORDS EXCEEDED\nXXIORETA OI    *+1,1               SET CC TO 1\n         B     XXIORETC            GO TO RELOAD AND RETURN\n         AIF   (&$DISKU EQ 0).XNODISK  SKIP DISK UTILITY WHEN NODISK\n         USING AVWXTABL,R7         NOTE MAIN TABLE USING\n         USING XIOBLOCK,R14\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> ENTRY:  XXXXDKOP    INITIALIZES FOR DISK UTILITY RUN             *\n*              ALL XXXXDK ENTRIES BY RICHARD FORD, PAUL WEISSER.      *\n*        XXXXDKOP IS CALLED FROM UTINT1 IF THE DISK UTILITY OPTION    *\n*        IS ENABLED.  IT PERFORMS A STANDARD FORM OPEN ON THE DISK    *\n*        UTILITY DCB,  INITIALIZES ANY VARIABLES USED BY THE DISK     *\n*        UTILITY ROUTINES. XXXXDKOP ALSO COMPLETES THE DECB'S CREATED *\n*        FOR BUFFER POOL MANAGEMENT BY FILLING IN THE RESPECTIVE      *\n*        BUFFER ADDRESS. IN BATCH MODE XXXXDKOP RESETS THE DISK DATA  *\n*        SET WITH A POINT MACRO INSTRUCTION.                          *\n*                                                                     *\n*                                                                     *\n*        REGISTER ASSIGNMENTS                                         *\n*              R13-> SAVE AREA POINTER                                *\n*              R14-> XIOBLOCK POINTER REGISTER                        *\n*              R15-> TEMP. BASE REGISTER                              *\n*              R0 -> HOLDS LOW END ROINTER TO BUFFER AREA             *\n*              R1 -> WORK REGISTER                                    *\n*              R3 -> HOLDS NUMBER OF BUFFERS FOR LOOP CONTROL         *\n*              R7 -> BASE REGISTER FOR AVWXTABL                       *\n*                                                                     *\n*        USES MACROS: POINT (OS), POINTS (DOS)                        *\n*        USES DSECTS: AVWXTABL, XXIOBLOCK                             *\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         USING XXXXDKOP,R15        NOTE TEMPORARY USING\nXXXXDKOP STM   R11,R8,XXIOSAVT     SAVE REGISTERS IN LOCAL AREA\n         LM    R11,R13,XXIOAJOB    LOAD BASE REGISTERS AND CONSTANT 1\n         USING XXIOSAVE,R13        NOTE MAIN USING\n         DROP  R15                 KILL R15\n         L     R7,AJOVWXPT         GET ADDRESS OF MAIN TABLE\n         NI    AJIODSK,255-AJIOEOF CLEAR EOF FLAG FOR BATCH RUN\n         LA    R8,4+XXDKOFFL       GET OFFSET INTO BUFFER IN R8\n         TM    XXDKUDCB+XXDKOPEN,XXMASK     IS DISK DCB/DTF OPEN\n         BO    XXOPNPT             IF SO, GO ISSUE POINT MACRO\n         AIF   (NOT &$ASMLVL).XXDR01  SKIP IF DOS GENERATION\n         XC    XXDKBLKS(2),XXDKBLKS    CLEAR BLKSIZE FOR JCL\n.XXDR01  LA    R2,AJIODSK          GET ADDRESS OF CONTROL BYTE\n         AIF   (&$ASMLVL).XXDR1    SKIP IF OS GENERATION\n         LA    R1,XXDKUDCB         GET ADDR OF DTF FOR OPEN\n         AGO   .XXDR2\n.XXDR1   LA    R3,XXIODSKU         R3 <-- ADDR OF REMOTE CLOSE WORD\n.XXDR2   BAL   R4,XXIOPENO         OPEN DCB/DTF\n         BM    XXEXIT              DID NOT OPEN---DISASTER\n         OI    AJIODSK,AJIOPEN     SHOW DCB OPEN\nXXOPNPT  L     R0,AVADDHIH         GET CURRENT HIGH CORE POINTER\n         S     R0,XXDKLN           GET SPACE FOR FIRST BUFFER\n         SR    R0,R8               BUMP PAST LENGTH USED WORD\n         AIF   (&$BUFNO EQ 1).XXDKOPC  SKIP IF ONLY ONE BUFFER\n         LA    R3,&$BUFNO-1        GET # OF BUFFERS - 1 FOR LOOP\n.XXDKOPC ANOP\n         LA    R1,XXDECB+4         GET ADDR OF 1ST DECB\n         ST    R1,AVDECB           PUT ADDR OF DECB IN BCB\n         LR    R1,R0               DUPLICATE BUFFER ADDR\n         AR    R1,R8               BUMP PAST LENGTH USED WORD\n         STM   R0,R1,AVBUFF@       INITIALIZE AVBCB\n         A     R1,XXDKLN           COMPUTE ENDING BUFFER @\n         ST    R1,AVBUFEND         PUT VALUE IN BCB\n         AIF   (&$BUFNO EQ 1).XXDKOPA  SKIP IF ONLY ONE BUFFER\n         L     R1,XXDECB           GET LINK IN R1\n         ST    R1,AVDECBNX         PUT THIS IN BCB\n.XXDKOPA ANOP\n         LA    R1,XXDECB           GET DECB BLOCK ADDRESS\n         ST    R0,XXDECBE(R1)      STORE 1ST BUFF @ IN DECB 1\n         AIF   (&$BUFNO EQ 1 ).XXDKOPB  SKIP IF ONLY 1 BUFFER\n         A     R8,XXDKLN           GET FULL BUFF LENGTH IN R8\n         SR    R0,R8               GET NEXT BUFF @\n         L     R1,0(R1)            GET LINK TO NEXT DECB\n         ST    R0,XXDECBE(R1)      STORE NEW BUFF @ AT NEW DECB\n         BCT   R3,*-10             LOOP FOR ALL DECBS\n.XXDKOPB ANOP\n         ST    R0,AVADDHIH         STORE UPDATED LOW END POINTER\n         XDKPT XXDKUDCB,XXXPOINT   REPOSITION THE DISK\n         SR    R2,R2               CLEAR R2 TO INITIALIZE COUNT\n         B     XXXXDKRT            RETURN TO CALLER\nXXEXIT   XI    AVTAGS1,AJODISKU    CANCEL DISK OPTION\n         OI    *+1,1               SET CC TO MINUS TO FLAG UTINIT1\n         B     XXXDKRTB            RETURN\n         SPACE 2\nXXDKEOF  EQU   *                   EOF EXIT ( FUTURE USE )\nXXDKSYND OI    AJIODSK,AJIOEOF+AJIOSYND MARK END-FILE, ALSO SYNAD\n         B     XXXDKRTB            RETURN\n         SPACE 2\n         AIF   (NOT &$ASMLVL).XXEX1    SKIP IF OS GENERATION\n*              XXDKUDCB DCB EXIT - USE BLKSIZE FROM JCL IF GIVEN, ELSE\n*              USE DEFAULT &$BLEN.\n*              THIS CODE ONLY USEFUL IN OS/360 SYSTEM.\n         USING XXDKEXCD,R15        LOCAL USING\n         USING IHADCB,R1           @ DCB, SUPPLIED BY OPEN\nXXDKEXCD LH    R0,DCBBLKSI         GET BLKSIZE FROM THE DCB\n         SRA   R0,2                DIVIDE BY 4, TEST FOR ZERO\n         SLL   R0,2                ALIGN TO FULLWORD MULTIPLE\n         BNZ   *+8                 SKIP IF BLKSIZE FROM JCL\n         LH    R0,=AL2(&$BLEN)     USE DEFAULT BUFFER LENGTH INSTEAD\n         STH   R0,DCBBLKSI         STORE ACTUAL BLKSIZE TO BE USED\n         SH    R0,=H'4'            WANT BLKSIZE-4 FOR LATER USE\n         ST    R0,XXDKLN           SAVE IT WHERE EXPECTED\n         BR    R14                 RETURN TO OPEN EXECUTOR\n         DROP  R1,R15              REMOVE DCB, LOCAL USINGS\n.XXEX1   ANOP\n         TITLE 'DISK UTILITY READ'\n         USING XXXXDKRD,REP        NOTE TEMPORARY USING\n         USING XIOBLOCK,R14        FORMAT FOR CONTROL BLOCK\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*-->ENTRY XXXXDKRD   RETURN A SET OF RECORD BLOCKS TO UTGET2          *\n*        XXXXDKRD IS CALLED BY UTGET2 WHEN IT HAS COMPLETED           *\n*        PROCESSING A SET OF RECORD BLOCKS. XXXXDKRD RETURNS THE      *\n*        ADDRESS OF THE NEXT BUFFER TO BE PROCESSD VIA THE BUFFER     *\n*        CONTROL BLOCK AND RE-FILLS THE BUFFER WHICH WAS JUST         *\n*        PROCESSED. WHEN ALL BLOCKS HAVE BEEN READ, XXXXDKRD CON-     *\n*        TINUES TO ACCEPT CALLS UNTIL ALL BUFFERS HAVE BEEN           *\n*        PROCESSED, AT WHICH TIME AN END-OF-FILE INDICATION           *\n*        (CC=1) IS RETURNED.                                          *\n*                                                                     *\n*        REGISTER ASSIGNMENTS                                         *\n*              R13-> BASE REGISTER AND SAVE AREA POINTER              *\n*              R14-> XIOBLOCK POINTER REGISTER                        *\n*              R15-> TEMP. BASE REGISTER                              *\n*              R2 -> WORK REGISTER FOR COUNTER                        *\n*              R3 -> DECB POINTER                                     *\n*              R4 -> BUFFER POINTER                                   *\n*                                                                     *\n*        USES MACROS: READ, CHECK                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nXXXXDKRD STM   R11,R8,XXIOSAVT     SAVE REGISTERS IN LOCAL AREA\n         LM    R11,R13,XXIOAJOB    LOAD BASE REGISTERS AND CONSTANT 1\n         USING XXIOSAVE,R13        GLOBAL USING\n         DROP  REP                 DROP R15\n         L     R7,AJOVWXPT         GET ADDRESS OF MAIN TABLE\n         LM    R3,R4,AVBCB         GET BCB INFO\n         TM    AJIODSK,AJIOEOF     TEST IF LAST BLOCK READ\n         AIF   (&$BUFNO NE 1).XXDKRDA   SKIP IF MORE THAN 1 BUFFER\n         BO    XXCCSET             BRANCH TO SET CONDITION CODE\n.XXDKRDA ANOP\n         LH    R2,XXBLKCNT         SET R2 TO COUNTER VALUE\n         BCT   R2,XXDKNZ           IF COUNT ^=0 TAKE BRANCH\n         AIF   (&$BUFNO EQ 1).XXDKRDB   SKIP IF ONLY ONE BUFFER\n         SPACE 2\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*        LAST REAL READ HAS BEEN PERFORMED---RESET COUNTER TO         *\n*        EMPTY ALL BUFFERS; SET FLAG TO SHOW END-OF-FILE              *\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         BO    XXCCSET             IF LAST BLK PASSED, SET CC\n.XXDKRDB ANOP\n         OI    AJIODSK,AJIOEOF     SET END-OF-FILE FLAG\n         AIF   (&$BUFNO EQ 1).XXDKRDC   SKIP IF ONLY ONE BUFFER\n         LA    R2,&$BUFNO          GET COUNT OF BUFFERS\n         B     XXDKREAD            GO AND READ LAST BLOCK\n         SPACE 2\n.XXDKRDC ANOP\nXXDKNZ   EQU   *\n         AIF   (&$BUFNO EQ 1).XXDKRDE   SKIP IF ONLY ONE BUFFER\n         BO    XXDKNM               IF END FLAG SET, SKIP READ\n.XXDKRDE ANOP\nXXDKREAD XDKCHK    (R3),XXDKUDCB,DOS   CHECK BEFORE GIVING OUT BLOCK\n         XDKRD (R3),XXDKUDCB,(R4)  READ A BLOCK\n         AIF   (&$BUFNO EQ 1).XXRDD    SKIP IF ONLY 1 BUFFER\nXXDKNM   BAL   R14,XXFIXUP         GO UPDATE POINTERS\n.XXRDD   AIF   (&$ASMLVL).XXRDD1       SKIP IF OS GEN\n         TM    AJIODSK,AJIOEOF     IF EOF IS SET,\n         BZ    XXXXDKRT            DO NOT CHECK LAST BLOCK\n.XXRDD1  XDKCHK    (R3),XXDKUDCB   CHECK BEFORE GIVING OUT BLOCK\n         SR    R0,R0               SET CC TO NOT NEGATIVE\n         B     XXXXDKRT            RETURN TO CALLER\n         SPACE 5\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*        LAST BLOCK HAS ALREADY BEEN PASSED--- SET CC & RETURN        *\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nXXCCSET  OI    *+1,1               SET CC TO MINUS\n         B     XXXDKRTB            RETURN TO CALLER\n         TITLE 'END PASS1 INITIALIZE FOR PASS2'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> ENTRY: XXXXDKE1    COMPLETE PASS1 PROCESSING, SET UP FOR PASS 2  *\n*        XXXXDKE1 IS CALLED FROM UTEND1.  XXXXDKE1 WRITES LAST BUFFER *\n*        OR IF NO PREVIOUS WRITES WERE PERFORMED,  PASSES UTGET2 THE  *\n*        INITIAL ADDRESS OF THE ONLY BUFFER USED.  IF AT LEAST 1      *\n*        WRITE TO DISK WAS DONE,  XXXXDKE1 POINTS THE DISK TO START   *\n*        AND READS N-1 BUFFERS FROM THE DISK AND SETS UP FOR          *\n*        PASS 2 OF THE ASSIST ASSEMBLER.                              *\n*                                                                     *\n*        REGISTER ASSIGNMENTS                                         *\n*              R14-> XIOBLOCK POINTER REGISTER                        *\n*              R15-> TEMP. BASE REGISTER                              *\n*              R2 -> COUNTER WORK REGISTER                            *\n*              R3 -> DECB POINTER                                     *\n*              R4 -> BUFFER POINTER                                   *\n*              R8 -> WORK REGISTER                                    *\n*                                                                     *\n*        USES DSECTS: XXIOBLOCK, AVWXTABL                             *\n*        USES MACROS: READ, WRITE, POINT, CHECK                       *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         USING XXXXDKE1,REP        TEMPORARY USING\nXXXXDKE1 STM   R11,R8,XXIOSAVT     SAVE REGISTERS IN LOCAL AREA\n         LM    R11,R13,XXIOAJOB    LOAD BASE REGISTERS AND CONSTANT 1\n         USING XXIOSAVE,R13        NOTE GLOBAL USING\n         DROP  REP                 DROP TEMPORARY USING\n         L     R7,AJOVWXPT         GET ADDRESS OF MAIN TABLE\n         LH    R2,XXBLKCNT         GET # OF BLOCKS TO BE READ\n         AIF   (&$BUFNO EQ 1).XXDKEA   SKIP IF JUST 1 BUFFER\n         LTR   R2,R2               IS IT 0?\n         BNP   XXONEBLK            TAKE BRANCH TO ONE BLK WRITTEN\n         L     R6,AVDECBLT         GET POINTER TO LAST DECB\n         XDKCHK  (R6),XXDKUDCB     ISSUE CHECK\n.XXDKEA  ANOP\nXXONEBLK LM    R3,R5,AVBCB         OBTAIN NEEDED VALUES\n         SR    R5,R4               GET BUFFER USED LENGTH\n         ST    R5,XXDKOFFL(,R4)    STORE LENGTH IN BUFFER\n         XDKWT (R3),XXDKUDCB,(R4)  WRITE THE BLOCK\n         XDKCHK  (R3),XXDKUDCB     CHECK COMPLETION OF LAST WRITE\n         XDKPT XXDKUDCB,XXXPOINT   POINT TO THE FIRST RECORD\n         AIF   (&$BUFNO NE 1).XXDK1    SKIP IF MORE THAN 1 BUFFER\n         ST    R4,AVBUFINC         RESET LENGTH WORD\n         AR    R2,R12              INCREMENT COUNTER\n         B     XXXXDKRT            GO RETURN\n.XXDK1   AIF   (&$BUFNO EQ 1).XXDEC    SKIP IF 1 BUFFER\n         AR    R2,R12              INCREMENT THE COUNTER\n         LA    R8,&$BUFNO-1        GET # OF BUFFERS LESS 1\n         LR    R6,R12              INITIALIZE TO GET ALL INFO\nXXEPRD1  XDKRD (R3),XXDKUDCB,(R4)  READ FIRST BLOCK\n         AR    R6,R12              INCREMENT READ COUNTER\n         SR    R2,R12              DECREMENT BLOCK COUNTER\n         BZ    XXFEWER             IF ZERO GO TO XXFEWER\n         BAL   R14,XXFIXUP         ELSE MOVE POINTERS TO NEXT BLOCK\n         BCT   R8,XXEPRD1          LOOP TO CONTINUE READING\n         B     XXXXDKRT            RETURN TO CALLER\nXXFEWER  OI    AJIODSK,AJIOEOF     SET LAST-BLOCK-READ FLAG\n         STH    R6,XXBLKCNT        STORE # OF FULL BUFFERS\n         BAL   R14,XXFIXUP         BRANCH TO UPDATE POINTERS\n         BCT   R8,XXFIXUP          LOOP TO POSITION DECB POINTERS\n         B     XXXDKRTB            RETURN TO CALLER\n.XXDEC   ANOP\n         TITLE 'DISK UTILITY WRITE'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> ENTRY: XXXXDKWT     WRITE A FULL BUFFER TO DISK                  *\n*        XXXXDKWT IS CALLED FROM UTPUT1 WHEN PASS1 HAS FILLED A       *\n*        BUFFER.  XXXXDKWT WRITES THE BUFFER TO DISK AND UPDATES      *\n*        THE BUFFER MANAGEMENT TABLE WHICH RETURNS THE ADDRESS OF     *\n*        THE NEXT AVAILABLE BUFFER TO UTPUT1.                         *\n*                                                                     *\n*        REGISTER ASSIGNMENTS                                         *\n*              R13-> BASE REGISTER AND SAVE AREA POINTER              *\n*              R14-> XIOBLOCK POINTER REGISTER                        *\n*              R15-> TEMP. BASE REGISTER                              *\n*              R3 -> POINTER TO CURRENT DECB                          *\n*              R4 -> BUFFER POINTER                                   *\n*              R5 -> BUFFER LENGTH USED ACCUMULATOR                   *\n*              R6 -> POINTER TO OLD DECB                              *\n*                                                                     *\n*        USES DSECTS: AVWXTABL, XXIOBLOCK                             *\n*        USES MACROS: WRITE, CHECK                                    *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         USING XXXXDKWT,REP        NOTE TEMP USING\nXXXXDKWT STM   R11,R8,XXIOSAVT     SAVE REGISTERS IN LOCAL AREA\n         LM    R11,R13,XXIOAJOB    LOAD BASE REGISTERS AND CONSTANT 1\n         USING XXIOSAVE,R13        NOTE GLOBAL USING\n         DROP  REP                 KILL TEMP USING\n         L     R7,AJOVWXPT         GET ADDRESS OF MAIN TABLE\n         LH     R2,XXBLKCNT        GET CURRENT COUNTER VALUE\n         AIF   (&$BUFNO EQ 1).XXWTA    SKIP IF ONLY 1 BUFFER\n         LTR   R2,R2               IS THIS FIRST CALL TO THIS ENTRY\n         BZ    XXXX1ST             IF IT IS, SKIP CHECK\n         L     R6,AVDECBLT         GET POINTER TO LAST DECB\n         XDKCHK  (R6),XXDKUDCB     ISSUE CHECK\n.XXWTA   ANOP\nXXXX1ST  LM    R3,R5,AVBCB         OBTAIN NEEDED VALUES\n         SR    R5,R4               SUBTRACT TO GET LENGTH OF INFO\n         ST    R5,XXDKOFFL(,R4)    STORE LENGTH IN BUFFER\n         XDKWT (R3),XXDKUDCB,(R4)  WRITE THE RECORD(BLOCK)\n         AIF   (&$BUFNO NE 1).XXWTB   SKIP IF > 1 BUFFER\n         XDKCHK  (R3),XXDKUDCB     CHECK LAST WRITE\n.XXWTB   ANOP\n         AR    R2,R12              INCREMENT COUNTER\n         AIF   (&$BUFNO EQ 1).XXWTC    SKIP IF ONLY 1 BUFFER\n         BAL   R14,XXFIXUP         GO TO FIXUP ROUTINE\n.XXWTC   AIF   (&$BUFNO NE 1).XXWTD    SKIP IF BUFNO > 1\n         LA    R4,4(R4)            INCREMENT POINTER PAST LENGTH WORD\n         ST    R4,AVBUFINC         STORE AVBUFINC BACK INTO BCB\n.XXWTD   ANOP\n         SPACE 2\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*        COMMON RETURN CODE FOR DISK ROUTINES                         *\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nXXXXDKRT STH   R2,XXBLKCNT         STORE UPDATED COUNTER\nXXXDKRTB LM    R11,R8,XXIOSAVT     RESTORE REGISTERS\n         B     XIORETRN            RETURN TO CALLER\n         AIF   (&$BUFNO EQ 1).XXFXA    SKIP WHOLE SECTION IF 1 BUFFER\n         TITLE 'DISK UTILITY BCB UPDATE ROUTINE'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> INSUB: XXFIXUP     UPDATE BCB POINTERS TO NEXT BUFFER            *\n*                                                                     *\n*        XXFIXUP UPDATES THE POINTERS IN THE BCB, MOVING THE NEXT     *\n*        I/O OPERATION TO THE NEXT BUFFER.                            *\n*                                                                     *\n*        ENTRY CONDITIONS:   R3-> ADDRESS OF CURRENT DECB.            *\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nXXFIXUP  ST    R3,AVDECBLT         STORE ADDR FOR BACKWARD REFERENC\n         L     R3,AVDECBNX         LINK TO NEXT DECB BLOCK\n         MVC   AVDECBNX(4),0(R3)   MOVE LINK TO AVBCB\n         LA    R3,4(R3)            GET DECB @ FOR NEXT BUFFER\n         L     R4,XXDECBIN(R3)     GET BUFFER ADDRESS\n         LA    R5,4+XXDKOFFL(R4)   BUMP PAST LENGTH USED WORD\n         STM   R3,R5,AVDECB        FILL PART OF THE BCB\n         A     R5,XXDKLN           GET BUFFER ENDING ADDRESS\n         ST    R5,AVBUFEND         COMPLETE BCB BLOCK\n         BR    R14                 RETURN TO CALLER\n.XXFXA   ANOP\nXXDKLN   DC    A(&$BLEN-4)         BUFFER LENGTH FOR HIGH END POINT\nXXXPOINT DC    X'00000100'         POINT CONTROL WORD\nXXBLKCNT DS    H                   COUNTER HALF-WORD\nXXDECB   XXDKDECB  &$BUFNO         DEFINE DECB TABLE\n         DROP  R7                  DELETE AVWXTABL USING\n.XNODISK ANOP\n         EJECT\n         AIF   (NOT (&$PUNCH OR &$DATARD OR (&$DISKU NE 0) OR &$MACSLB)#\n               ).XXNRP4            SKIP IF NO SPECIAL OPEN NEEDED\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> INSUB: XXIOPENO   OPEN OPTIONAL DATA SET, FIX FLAGS              *\n*        XXIOPENO IS CALLED FROM ENTRIES XXXXREAD OR XXXXPNCH TO      *\n*        OPEN A DCB, FLAG ITS AJIO-- BYTE AJIODFLT IF OPEN FAILS,     *\n*        OR AJIOPEN IF IT GOES.  IF OPEN OK, THE OPEN/CLOSE PARM WORD *\n*        ADDED TO THE FRONT OF CURRENT LIST BEING BUILT FOR CLOSING.  *\n*        UNDER DOS GENERATIONS, NO OPEN/CLOSE PARM WORD IS PRESENT,   *\n*        SO JUST OPEN AND SET RETURN CODE.                            *\n*        ENTRY CONDITIONS                                             *\n*   R1 = @ OF DCB (XXREDCB, XXPNDCB) UNDER DOS GENERATIONS ONLY       *\n*   R2 = @ AJIO-- CONTROL BYTE (AJIORE, AJIOPN)                       *\n*   R3 = @ OPEN/CLOSE PARM WORD (XXIOCRE, XXIOCPN)                    *\n*   R4 = RETURN @ TO CALLING SECTION OF CODE                          *\n*        EXIT CONDITIONS                                              *\n*   R1 = @ OF DCB (XXREDCB, XXPNDCB)                                  *\n*   R2 = @ AJIO-- FLAG BYTE (SAME AS ON ENTRY)                        *\n*   R0,R14 ARE PRESERVED FROM EFFECTS OF OPEN                         *\n*   CC = 0 ==> OPEN WENT.  AJIO-- FLAG FLAGGED WITH AJIOPEN.          *\n*   CC = 1 ==> OPEN FAILED.  AJIO-- BYTE FLAGGED WITH AJIODFLT.       *\n*   XXIOCPTR=XXIOCPTR-4 IF OPEN OK, OPEN/CLOSE WORD MOVE ALSO.        *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n         AIF   (&$ASMLVL).XXNIHA   SKIP IF UNDER OS GENERATION\nXXIOPENO OPEN  (1)                 OPEN OPTIONAL DATA SET\n         LM    R14,R0,XXIOSAVT+12  RELOAD MESSED UP REGISTERS\n         TM    15(R1),X'20'        DID THE OPEN GO\n         BZ    XXIOPENQ            YES, OPEN WENT\n.XXNIHA  AIF   (NOT &$ASMLVL).XXYIHA   SKIP IF UNDER DOS GENERATION\nXXIOPENO LR    R1,R3               MOVE PTR TO OPEN/CLOSE WORD OVER\n         OPEN  MF=(E,(1))          DO REMOTE OPEN\n         LM    R14,R0,XXIOSAVT+12  RELOAD MESSED-UP REGISTERS\n         L     R1,0(R3)            GET @ DCB FROM OPEN/CLOSE PARM\n         USING IHADCB,R1           NOTE DCB DSECT USING\n         TM    DCBOFLGS,X'10'      DID THE OPEN GO?\n         BO    XXIOPENQ            YES, OPEN WENT\n         DROP  R1                  KILL USING\n.XXYIHA  ANOP\n         SPACE 1\n         OI    0(R2),AJIODFLT      OPEN FAILED, USE DEFAULT DATA SET\n         BR    R4                  RETURN TO CALLER, CC=1 AT MOMENT\n         SPACE 1\n*        OPEN SUCCEEDED. MARK DATA SET OPEN. ADD ITS OPEN/CLOSE PARM  *\n*        WORD TO FRONT OF LIST SO IT WILL BE CLOSED LATER (OS ONLY).  *\nXXIOPENQ OI    0(R2),AJIOPEN       SHOW OPEN OK\n         AIF   (NOT &$ASMLVL).XXNPRMW  NO DOS PARM WORD LIST\n         L     R15,XXIOCPTR        GET CURRENT PTR TO OPEN/CLOSE LIST\n         SH    R15,=H'4'           SUBTRACT TO GET NEXT POSITION\n         ST    R15,XXIOCPTR        STORE UPDATED VALUE\n         MVC   0(4,R15),0(R3)      MOVE NEW OPEN/CLOSE PARM IN\n         NI    0(R15),X'7F'        REMOVE LEADING BIT, SINCE NOT LAST\n.XXNPRMW ANOP\n         SR    R15,R15             SET CC=0 TO SHOW SUCCESSFUL\n         BR    R4                  RETURN TO CALLING CODE\n         SPACE 1\n.XXNRP4  AIF   (NOT &$ASMLVL).XXNPN2   NO LIST FORMS UNDER DOS\nXXIOCPTR DS    A                   @ 1ST VALID OPEN/CLOSE PARM IN LIST\n*              OPEN/CLOSE PARM VALUES.  ORDER REQUIRED NEXT 2 CARDS.\n         DS    2F                  FOR RE, PN OPEN/CLOSE PARMS\n         AIF   (&$DISKU LT 1).XXNDKOP\n         DS    F                   ROOM FOR DISK UTILITY PARM WORD\n.XXNDKOP AIF   (NOT &$MACSLB).XXNMCLB  SKIP WORD IF NOT NEEDED\n         DS    A                   SPACE FOR ANOTHER PTR WORD\n.XXNMCLB ANOP\nXXIOCSP  OPEN  (XXSODCB,INPUT,XXPRDCB,OUTPUT),MF=L    SET UP VALUES\n         SPACE 1\n         AIF   (NOT &$DATARD).XXNRE2        SKIP IF NO DATA RDR\nXXIOCRE  OPEN  (XXREDCB,INPUT),MF=L         SET UP VALUE HERE\n.XXNRE2  AIF   (NOT &$PUNCH).XXNPN2         SKIP IF NO REAL PUNCH\nXXIOCPN  OPEN  (XXPNDCB,OUTPUT),MF=L        SET UP VALUE HERE\n.XXNPN2  ANOP\n         AIF   (&$DISKU EQ 0).XXNDOPN  SKIP IF NO DISK OPTION\n         AIF   (NOT &$ASMLVL).XXNDOPN  SKIP IF OS GENERATION\nXXIODSKU OPEN  (XXDKUDCB,(OUTIN)),MF=L\n.XXNDOPN ANOP\n         EJECT\n         AIF   (NOT &$MACSLB).XXNMCOP\nXXLIBCLS OPEN  (XXLIBDCB,INPUT),MF=L   LIST FORM FOR MACRO LIBRARY OPEN\n         EJECT\n         SPACE 10\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*-> ENTRY: XXXXLBOP                                                   *\n*              XXXXLBOP INITIALIZES FOR A MACRO LIBRARY RUN.  XXXXLBOP*\n*        IS CALLED BY MOCOMSYS IN MCON1.  IT OPENS THE SYSTEM LIBRARY *\n*        DCB IF NECESSARY, ALLOCATES BUFFER SPACE IN HIGH CORE, AND   *\n*        SETS SWITCH IN XXXXSORC SUCH THAT XXXXSORC PROVIDES INCARD   *\n*        THE ADDRESS OF A CARD IMAGE FROM THE SYSTEM LIBRARY BUFFER   *\n*        INSTEAD OF FROM THE NORMAL SYSIN DATA SET.  ALSO SETS THE    *\n*        ADDRESS INTO THE GLOBAL TABLE NEEDED BY THE SUPPORTING       *\n*        ROUTINES.                                                    *\n*                                                                     *\n*        REGISTER ASSIGNMENTS:                                        *\n*              PSEUDO-STANDARD OS LINKAGE (SAVING ONLY NEEDED REG)    *\n*              R1=> BASE FOR IHADCB DSECT                             *\n*              R4=> BASE FOR XLBDSECT DSECT                           *\n*              R7=> AVWXTABL BASE REGISTER                            *\n*              R13=> SAVE AREA POINTER AND MAIN BASE REGISTER         *\n*              R15=> TEMP BASE REGISTER                               *\n*                                                                     *\n*        USES MACROS:                                                 *\n*              $ALLOCH                                                *\n*                                                                     *\n*        USES DSECTS:                                                 *\n*              AVWXTABL, XLBDSECT, IHADCB                             *\n*                                                                     *\n*        EXIT CONDITIONS:                                             *\n*              CC = 1 (MINUS) IF OPEN DID NOT GO                      *\n*              AND ZERO (0) IF OPEN WENT                              *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 5\n         USING AVWXTABL,R7         NOTE MAIN TABLE USING\n         USING XXXXLBOP,R15        TEMP BASE REGISTER\nXXXXLBOP STM   R11,R8,XXLBSAVT     SAVE REGISTERS TO BE CHANGED\n         LM    R11,R13,XXIOAJOB    LOAD NEEDED VALUES\n         USING XXIOSAVE,R13        NOTE MAIN USING\n         DROP  R15                 CLEAN UP USINGS\n         L     R7,AJOVWXPT         GET MAIN TABLE ADDRESS\n         MVC   AVLIBBUF,AWZEROS    ZERO THE GLOBAL WORD\n         TM    XXLIBDCB+48,X'10'   IS THE LIBRARY DCB ALREADY OPEN\n         BO    XXLBALOP            YES-- GO TO ALREADY OPEN\n         LA    R2,XXLBFLG          R2 <-- ADDRESS OF CONTROL BYTE\n         LA    R3,XXLIBCLS         R3 <-- DDDRESS OF REMOTE CLOSE WORD\n         BAL   R4,XXIOPENO         GO DO OPEN\n         BM    XXLBOVR             OPEN DID NOT GO -- HURT\n         SPACE 2\n*        OPEN WENT SO COMPLETE LIBRARY RUN SET UP\n         SPACE 2\nXXLBALOP LA    R1,XXLIBDCB         GET ADDRESS OF LIBRARY DCB\n         USING IHADCB,R1           SET USING FOR DCB DSECT\n         LH    R2,DCBBLKSI         GET BLOCK SIZE FROM THE DCB\n         SPACE 2\n*        ROUND UP TO A D-WORD MULTIPLE TO BE SURE\n         SPACE 2\n         LA    R2,7+XLBUFCNT(R2)   ADD 7 PLUS LENGTH OF CONTROL AREA\n         SRL   R2,3                DIVIDE BY 8\n         SLL   R2,3                MULTIPLY BY 8\n         SPACE 2\n*        GET THE SPACE FOR THE BUFFER AND CONTROL WORDS IN HIGH CORE\n         SPACE 2\n         USING XLBDSECT,R4         NOTE LIBRARY DSECT\n         $ALLOCH R4,R2,XXLBOVR     GET THE SPACE IN HIGH CORE\n         MVI   XXLBFLG,X'FF'       SET FLAG TO SHOW BUFFER ALLOCATED\n         SPACE 2\n*        INITIALIZE GLOBAL CONTROL WORD\n         ST    R4,AVLIBBUF         STORE BUFFER AND CONTROL BLOCK\n*                                  ADDRESS IN THE GLOBAL TABLE\n         SPACE 2\n*        INITIALIZE THE BUFFER CONTROL WORDS\n         SPACE 2\n         ST    R2,XLBUFLNG         STORE TOTAL LENGTH IN CONTROL WORD 1\n         AR    R2,R4               GET START PLUS LENGTH IN R2\n         ST    R2,XLBUFEND         STORE IN CONTROL WORD 2\n         SR    R2,R4               REMOVE STARTING ADDRESS\n         LA    R2,XLBUFCNT(R4)     GET REAL BUFFER START ADDRESS\n         LR    R3,R2               DUPLICATE FOR MUTIPLE STORE\n         STM   R2,R3,XLBUFSTR      STORE IN CONTROL WORDS 2 & 3\n         DROP  R4,R1               CLEAN UP USINGS\n         SPACE 2\n*        SET XXXXSORC SWITCH TO ALWAYS BRANCH\n         SPACE 2\n         MVI   XXSWTCH+1,X'F0'     SET SWITCH TO BRANCH\n         SPACE 2\n         SR    R0,R0               MAKE CC NOT MINUS\nXXLBOUTA LM    R11,R8,XXLBSAVT     RESTORE REGISTERS\n         BR    R14                 RETURN TO CALLER\n         SPACE 2\n*        STORAGE OVERFLOW EXIT\n         SPACE 2\nXXLBOVR  OI    *+1,1               SET CC TO MINUS\n         B     XXLBOUTA            RETURN\n         DROP  R7,R13              CLEAN UP USINGS\n         SPACE 5\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*-> ENTRY: XXXXFIND                                                   *\n*              XXXXFIND DOES A D-TYPE FIND ON EACH MACRO THAT IS      *\n*        REQUIRED BY THE USER PROGRAM AS DEFINED ON THE SYSLIB CARD.  *\n*        CALLED FROM MOCOMSYS IN THE MCON1 CSECT.                     *\n*                                                                     *\n*        REGISTER ASSIGNMENTS:                                        *\n*              R12 => AVWXTABL BASE REGISTER                          *\n*              R13 => SAVE AREA  POINTER AND MAIN BASE REGISTER       *\n*              R14 => DCB ADDRESS                                     *\n*                                                                     *\n*        ENTRY CONDITIONS:                                            *\n*              MEMBER NAME IS IN AVMSYMBL                             *\n*                                                                     *\n*        EXIT CONDITIONS:                                             *\n*              CC SET TO ZERO IF ALL WENT WELL                        *\n*              CC SET TO MINUS IF NAME COULD NOT BE FOUND             *\n*                                                                     *\n*        USES MACROS:                                                 *\n*              FIND                                                   *\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 5\n         USING AVWXTABL,R12        NOTE MAIN TABLE USING\n         USING XXXXFIND,R15\nXXXXFIND STM   R11,R1,XXLBSAVT     SAVE REGISTERS THAT MIGHT CHANGE\n         L     R13,XXIOAJOB+8      GET BASE REGISTER SET UP\n         USING XXIOSAVE,R13        NOTE MAIN USING\n         DROP  R15                 CLEAN UP USING SITUATION\n         SPACE 2\n         MVC   XXFNDDW,AVMSYMBL    PUT NAME ON A D-WORD BOUNDRY\n         SPACE 2\n         FIND  XXLIBDCB,XXFNDDW,D  DO THE FIND\n         LTR   R15,R15             TEST RETURN CODE FROM FIND ROUTINE\n         BNZ   XXFNDERR            COULDNOT FIND NAME--SET UP BAD RTN\n         SPACE 2\n         SR    R0,R0               MAKE CC NOT MINUS\nXXXXFDOT LM    R11,R1,XXLBSAVT     RESTORE REGISTERS\n         BR    R14                 RETURN TO CALLER\n         SPACE 2\nXXFNDDW  DS    D                   D-WORD ALIGNED PLACE FOR MEMBER NAME\nXXFNDERR OI    *+1,1               SET CC TO MINUS FOR RETURN\n         B     XXXXFDOT            RETURN\n         DROP  R12,R13             CLEAN UP USINGS\n         SPACE 5\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*-> ENTRY: XXXXLBRD                                                   *\n*                                                                     *\n*              CALLED BY INCARD VIA XXXXSORC TO PROVIDE THE MACRO     *\n*        PROCESSOR WITH DEBLOCKED RECORDS FROM THE SYSTEM MACRO       *\n*        LIBRARIES.  FUNCTIONS AS AN INSUB TO ENTRY XXXXSORC.         *\n*                                                                     *\n*        REGISTER ASSIGNMENTS:                                        *\n*              SAME AS XXXXSORC: EXCEPT R12 IS BASE FOR AVWXTABL      *\n*                                                                     *\n*        ENTRY CONDITIONS:                                            *\n*              SAME AS XXXXSORC                                       *\n*              ADDITIONALLY -- INCARDS DATA AREA COMES OVER IN        *\n*              REGISTER R0 AND MUST BE PROTECTED FROM SYSTEM ACTIONS  *\n*                                                                     *\n*        USES DSECTS:                                                 *\n*              XLBDSECT, IHADCB                                       *\n*                                                                     *\n*        USES MACROS:                                                 *\n*              READ, CHECK                                            *\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 5\n         USING XXIOSAVE,R13        NOTE MAIN USING\n         USING IHADCB,XXXLBDCB\nXXXXLBRD STM   R6,R7,XXLBSAVT      SAVE SOME WORK REGISTERS\n         L     R12,AJOVWXPT        GET AVWXTABL BASE ADDRESS\n         USING AVWXTABL,R12        NOTE MAIN TABLE USING\n         L     R3,AVLIBBUF         GET ADDRESS OF BUFFER SPACE\n         USING XLBDSECT,R3         NOTE LIBRARY DSECT USING\n         LR    R4,R0               MOVE DATA AREA ADDRESS OVER\n         SPACE 2\nXXXLBDCB EQU   R5                  HOLDS THE LIBRARY DCB ADDRESS\nXXRECPT  EQU   R6                  HOLDS ADDRESS OF CARD IMAGE\nXXBUFEND EQU   R7                  POINTER TO THE END OF THE BUFFER\n         SPACE 2\n         LM    XXRECPT,XXBUFEND,XLBUFSTR   GET CONTROL INFORMATION\n         CR    XXRECPT,XXBUFEND    IS BUFFER EMPTY\n         BNL   XXXLIBRD            YES--GO READ A NEW BUFFER FULL\n         SPACE 2\nXXLBRCPT MVC   0(80,R4),0(XXRECPT) MOVE CARD WHERE INCARD EXPECTS\n         LA    XXRECPT,80(XXRECPT) INCREMENT TO NEW RECORD\n         SPACE 2\n*        SET UP FOR RETURN\n         SPACE 2\n         ST    XXRECPT,XLBUFSTR    SAVE UPDATED RECORD POINTER\nXXLBRDRT LM    R6,R7,XXLBSAVT      RESTORE REGISTERS\n         B     XXIORETB            RETURN TO CALLER (INCARD)\nXXXLIBRD LA    XXXLBDCB,XXLIBDCB   GET DCB ADDRESS IN A REG\n         LA    XXRECPT,XLIBBUF     GET AREA ADDRESS INTO XXRECPT REG\n         READ  XXLBDECB,SF,(XXXLBDCB),(XXRECPT),'S'   READ A BLOCK\n         CHECK XXLBDECB            CHECK FOR I/O COMPLETION\n         SPACE 2\n         LH    XXBUFEND,DCBBLKSI   GET BLOCKSIZE FROM DCB\n         L     R2,XXLBDECB+16      GET IOB ADDRESS\n         SH    XXBUFEND,14(R2)     GET RELATIVE END OF NEW BLOCK\n         LA    XXBUFEND,XLBUFCNT(R3,XXBUFEND)  GET ABSOULUTE END OF NEW\n*                                  BLOCK\n         ST    XXBUFEND,XLBUFCED   SET CONTROL WORD 4, CURRENT END\n         B     XXLBRCPT            GO TO DEBLOCK\nXXMCEODD MVC   0(80,R4),AWBLANK    BLANK OUT AREA FOR CARD\n         MVC   10(4,R4),=C'MEND'   PUT MEND CARD IMAGE THERE\n         B     XXLBRDRT            RETURN VIA XXXXSORC, INCARD\n         SPACE 5\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         DROP  R3,R5,R12,R13       CLEAN UP USINGS\n*-> ENTRY: XXXXLBED                                                   *\n*                                                                     *\n*              CALLED 1 TIME BY THE MAIN PROGRAM MCON1 TO INSURE      *\n*        THAT THE XXXXSORC SWITCH BRANCH IS SET FOR NORMAL PROCESSING.*\n*        ALSO CALLED BY MOCOMSYS IN MCON1 TO DEALLOCATE THE BUFFER    *\n*        AND CONTROL WORD SPACE AND TO RESET THE XXXXSORC SWITCH      *\n*        BRANCH TO THE NORMAL CONDITION.                              *\n*                                                                     *\n*        REGISTER ASSIGNMENTS:                                        *\n*              R2=> AVWXTABL BASE REGISTER                            *\n*              R13 => SAVE AREA POINTER AND MAIN BASE REGISTER        *\n*              R15 => TEMP BASE REGISTER                              *\n*                                                                     *\n*        USES DSECTS:                                                 *\n*              XLBDSECT                                               *\n*                                                                     *\n*        USES MACROS:                                                 *\n*              $DALLOCH                                               *\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 5\n         USING AVWXTABL,R2         NOTE TABLE USING\n         USING XXXXLBED,R15        TEMP USING\nXXXXLBED STM   R11,R2,XXLBSAVT     SAVE SOME WORK REGISTERS\n         LM    R11,R13,XXIOAJOB    GET NEEDED VALUES\n         L     R2,AJOVWXPT         GET BASE VALUE FOR MAIN TABLE\n         USING XXIOSAVE,R13        NOTE MAIN USING\n         DROP  R15                 CLEAN UP USING SITUATION\n         TM    XXLBFLG,X'FF'       IS THERE A BUFFER AROUND?\n         BZ    XXEDSET             NO -- DO NOT DE-ALLOCATE THE BUFFER\n         SPACE 2\n*        DEALLOCATE BUFFER SPACE IN HIGH FREEAREA\n         SPACE 2\n         L     R15,AVLIBBUF        GET ADDRESS OF BUFFER AREA\n         USING XLBDSECT,R15        NOTE LIBRARY DSECT USING\n         L     R15,XLBUFLNG        GET TOTAL LENGTH OF SPACE TO BE\n*                                  FREED\n         $DALLOCH R1,(R15)         DEALLOCATE THE AREA\n         DROP  R15                 CLEAN UP USING SITUATION\n         SPACE 2\n*        SET XXXXSORC SWITCH BRANCH TO NORMAL NON-BRANCH\n         SPACE 2\nXXEDSET  MVI   XXLBFLG,X'00'       MARK BUFFER AS GONE\n         MVI   XXSWTCH+1,X'00'     SET TO NEVER BRANCH IN XXXXSORC\n         LM    R11,R2,XXLBSAVT     RESTORE REGISTERS\n         BR    R14                 RETURN TO CALLER\n         DROP  R2                  CLEAN UP USING SITUATION\n         SPACE 2\nXXLBSAVT DS    14F                 SPACE FOR TEMP STORAGE OF REGISTERS\nXXLBFLG  DS    B                   DUMMY FLAG BYTE FOR REMOTE OPEN\n         SPACE 5\n.XXNMCOP ANOP\nXXIOAJOB DS    A                   SPACE FOR @ AJOBCON BLOCK\n         DC    A(1,XXIOSAVE)       FOR REGS R12-R13-FOLLOW XXIOAJOB\nXXIOSAVT DS    14F                 SAVE AREA FOR I/O ROUTINES\n         AIF   (NOT &$PAGE).XXNPAG8         SKIP IF NO PAGE CONTROL\n*              LEGAL CARRIAGE CONTROL CHARACTERS.  ITEMS ARE THE\n*              CHARACTER, AN OFFSET TO ITS REPLACEMENT CHARCATER\n*              WORD IF IN MODE SINGL, AND DECREMENT FOR LINE COUNTER.\nXXIOPGTA DS    0H                  ORIGIN OF TABLE, ALIGN\nXXIOPB   EQU   *-XXIOPGTA          OFFSET FROM TABLE TO BLANK'S BLOCK\nXXIOPGTB DC    C' ',AL1(XXIOPB),H'1'        SINGLE SPACE, SINGLE SPACE\nXXIOPD   EQU   *-XXIOPGTA          OFFSET TO DOUBLE SPACE\n         DC    C'0',AL1(XXIOPB),H'2'        DOUBLE SPACE,SINGLE SPACE\n         DC    C'1',AL1(XXIOPD),H'32000'    NEW PAGE, DOUBLESPACE\n         DC    C'-',AL1(XXIOPB),H'3'        TRIPLE SPACE,SINGLE SPACE\n         DC    C'+',AL1(*-1-XXIOPGTA),H'0'  NO SPACE, NOSPACE\nXXIOPGTZ EQU   *-4                 @ LAST ELEMENT IN TABLE\n.XXNPAG8 ANOP\n         LTORG\n         SPACE 1\n*              DCB'S FOR THE SOURCE AND DATA CARD READERS.\n         AIF   (NOT &$ASMLVL).XXNPN4   SKIP IF UNDER DOS GENERATION\nXXSODCB  DCB   DDNAME=&$IOUNIT(1),DSORG=PS,MACRF=GL,EODAD=XXIOEOF\n         AIF   (NOT &$DATARD).XXNRE4        SKIP IF NO DATA RDR\nXXREDCB  DCB   DDNAME=&$IOUNIT(2),DSORG=PS,MACRF=GL,EODAD=XXIOEOF\n.XXNRE4  ANOP\n         SPACE 1\n*              DCB'S FOR THE LINE PRINTER AND CARD PUNCH.\nXXPRDCB  DCB   DDNAME=&$IOUNIT(3),DSORG=PS,MACRF=PL,                   #\n               RECFM=FA,LRECL=133,BLKSIZE=133,BUFNO=1\n         AIF   (NOT &$PUNCH).XXNPN4        SKIP IF NO REAL PUNCH EXISTS\nXXPNDCB  DCB   DDNAME=&$IOUNIT(4),DSORG=PS,MACRF=PL,                   #\n               RECFM=F,LRECL=80,BLKSIZE=80,BUFNO=1\n.XXNPN4  ANOP\n         AIF   (&$ASMLVL).XXNPN8   SKIP IF UNDER OS GENERATION\nXXSODCB  DTFCD DEVADDR=&$IOUNIT(1),EOFADDR=XXIOEOF,IOREG=(5),          X\n               IOAREA1=XXIOLOCP,IOAREA2=XXIOLOCS,TYPEFLE=INPUT\nXXIOLOCP DC    80C' '              DOS IOAREA1\nXXIOLOCS DC    80C' '              DOS IOAREA2\n         AIF   (NOT &$DATARD).XXNRE8   SKIP IF NO DATA CARD READER\nXXREDCB  DTFCD DEVADDR=&$IOUNIT(2),EOFADDR=XXIOEOF,IOREG=(5),          X\n               IOAREA1=XXIOLOCP,IOAREA2=XXIOLOCS,TYPEFLE=INPUT\n.XXNRE8  ANOP\n         SPACE 1\n*        DCB'S FOR THE LINE PRINTER AND CARD PUNCH                    *\nXXPRDCB  DTFPR DEVADDR=&$IOUNIT(3),BLKSIZE=133,IOREG=(5),CTLCHR=ASA,   X\n               IOAREA1=XXIOFILP,IOAREA2=XXIOFILS\nXXIOFILP DC    133C' '             PRINTER IOAREA1\nXXIOFILS DC    133C' '             PRINTER IOAREA2\n         AIF   (NOT &$PUNCH).XXNPN8    SKIP IF NO REAL CARD PUNCH\nXXPNDCB  DTFCD DEVADDR=&$IOUNIT(4),CRDERR=RETRY,IOREG=(5),CTLCHR=ASA,  X\n               IOAREA1=XXIOPNCP,IOAREA2=XXIOPNCS,TYPEFLE=OUTPUT\nXXIOPNCP DC    80C' '              PUNCH IOAREA1\nXXIOPNCS DC    80C' '              PUNCH IOAREA2\n.XXNPN8  ANOP\n         AIF   (&$DISKU EQ 0).XXNDDCB  SKIP IF NO DISK OPTION\n         AIF   (&$ASMLVL).XXDDCB1  SKIP IF OS GENERATION\nXXDKUDC  DTFSD DEVADDR=&$IOUNIT(5),EOFADDR=XXDKEOF,TYPEFLE=WORK,       X\n               BLKSIZE=3520,NOTEPNT=YES,DEVICE=&$DSKUDV\nXXDKUDCB EQU   XXDKUDC             ATTACH 7-CHAR DTFSD LABEL TO EXPECTD\n         AGO   .XXNDDCB\n.XXDDCB1 ANOP\nXXDKUDCB DCB  DDNAME=&$IOUNIT(5),EODAD=XXDKEOF,RECFM=FB,EXLST=XXDKEXLS,#\n               SYNAD=XXDKSYND,DSORG=PS,NCP=&$BUFNO,MACRF=(RP,W)\nXXDKBLKS EQU   XXDKUDCB+X'3E'      BLKSIZE FIELD (DCBBLKSI) ADDRESS\nXXDKEXLS DC    0F'0',X'85',AL3(XXDKEXCD)  DCB EXIT, FILL IN BLKSIZE\n.XXNDDCB ANOP\n         EJECT\n         AIF   (NOT &$MACSLB).XXNMDCB\n*        DCB FOR THE MACRO LIBRARY FETCH OPTION\nXXLIBDCB DCB   DSORG=PO,DDNAME=&$IOUNIT(6),MACRF=R,EODAD=XXMCEODD\n.XXNMDCB ANOP\n         SPACE 1\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> DSECT: XIOBLOCK   CONTROL BLOCK FOR INPUT/OUTPUT MACROS          *\n*        THIS BLOCK IS CREATED FOR ANY I/O MACRO BY THE INNER MACRO   *\n*        XIONR, AND CONTAINS THE ADCON FOR THE DESIRED I/O ENTRYPOINT,*\n*        SAVE WORDS FOR MODFIED REGS R14,R15,R0, AND THE LENGTH FOR   *\n*        THE I/O AREA TO BE READ OR WRITTEN.                          *\n*        THIS DSECT IS ONLY USED IN CSECT XXXXIOCO.                   *\n*        GENERATION: BY MACRO XIONR (FOR $READ,$SORC,$PRNT,$PNCH).    *\n*        NAMES: XIO-----                                              *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nXIOBLOCK DSECT\n         DS    V .                 @ I/O ROUTINE\n         DS    3F                  AREA FOR REGS 15-0 TO BE SAVED\nXIOLENG  DS    AL2 .               LENGTH OF RECORD, (CODES-FUTURE USE)\nXIORETRN LM    14,0,4(14)          RETURN CODE FOR RESTORING REGISTERS\n         AIF   (NOT &$ASMLVL).XXNDCBD  NO IHADCB UNDER DOS\n         SPACE 1\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> DSECT: IHADCB     DATA CONTROL BLOCK DSECT                       *\n*        DCB DSECT USED BY PARTS OF XXXXIOCO.                         *\n*        GENERATION: DCBD MACRO                                       *\n*        LOCATION: XXSODCB,XXREDCB,XXPNDCB,XXPRDCB                    *\n*        NAMES: DCB-----                                              *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n         DCBD  DSORG=QS\n.XXNDCBD ANOP\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*-> LIBRARY DSECT -- XLBDSECT                                         *\n*                                                                     *\n*              DESCRIBES LIBRARY BUFFER SPACE AND CONTROL WORDS       *\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nXLBDSECT DSECT\nXLBUFLNG DS    F                   CONTROL WORD 1 => TOTAL LENGTH\nXLBUFEND DS    F                   CONTROL WORD 2 => PERMENENT BUFFER\n*                                     END\nXLBUFSTR DS    F                   CONTROL WORD 3 => START OF BUFFER\nXLBUFCED DS    F                   CONTROL WORD 4 => END OF BLOCK\nXLBUFCNT EQU   *-XLBUFLNG          LENGTH OF CONTROL SECTION OF BUFFER\nXLIBBUF  DS    F                   ACTUAL BUFFER STARTS HERE\n         SPACE 5\n         DROP  R11,R13,R14         AJOBCON,BASE REG, XIOBLOCK\n         TITLE '*** XXSNAPC DSECT - XSNAP CONTROL BLOCK ***'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> DSECT: XXSNAPC    CONTROL BLOCK USED BY THE XSNAP MACRO          *\n*        THIS BLOCK IS CREATED BY EVERY PRINTING XSNAP MACRO.  IT     *\n*        CONTAINS THE  EXACT CONTENTS OF THE GP REGISTERS BEFORE THE  *\n*        XSNAP WAS CALLED, A FLAG BYTE INDICATING DESIRED OUTPUT AND  *\n*        SPECIAL OPTIONS, THE NUMBER OF ADDRESS PAIRS USED IN THE     *\n*        XSNAP STORAGE= OPERAND, THE ADDRESS PAIRS THEMSELVES, AND    *\n*        THE ADDRESS CONSTANT FOR XXXXSNAP.  THE BYTE XXSFLAGS MAY    *\n*        HAVE SEVERAL BITS TURNED ON REQUESTING SPECIAL ASSIST        *\n*        SERVICES, SUCH AS USER DEBUGGING OUTPUT AND USER DUMP.  THE  *\n*        BITS ARE SUPPLIED BY XSNAP OPERAND T(3), AND HAVE            *\n*        MEANING ONLY WHEN USED INSIDE ASSIST WITH THE SPECIAL ASSIST *\n*        VERSION OF THE CSECT XXXXSNAP.                               *\n*        GENERATION: XSNAP MACRO, WITH T= ANY TYPE BUT ST OR STORE.   *\n*        NAMES: XXS-----                                              *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nXXSNAPC  DSECT\nXXSGPRG  EQU   B'00000001'         (XXSFLAGS)=> PRINT GP REGS\nXXSFLRG  EQU   B'00000010'         (XXSFLAGS)=> PRINT FL REGS\nXXSAVTR  EQU   B'00000100'         (XXSFLAGS)=> SAVE AREA TRACE(FUTURE)\nXXSASNAP EQU   B'00010000'         (XXSFLAGS)=> ASSIST EXECUTE SNAP\nXXSASDMP EQU   B'00100000'         (XXSFLAGS)=> ASSIST FINAL DUMP\n         SPACE 1\nXXSRGSAV DS    16F                 REGISTER AREA, REGS SAVED BY XSNAP\nXXSFLAGS DS    B                   OPTION BYTE FLAG\n         DS    AL1                 **** UNUSED AS OF VERSION 4.0***\nXXSLABLN DS    AL1                 LENGTH OF THE LABEL FIELD\nXXSNMSTR DS    AL1                 NUMBER OF @ PAIRS IN STORAGE= LIST\n         DS    V(XXXXSNAP)         ADCON FOR CALL TO XXXXSNAP ROUTINE\nXXSADSTR DS    0A                  STORAGE = ADDRESS LIST(OPTIONAL)\n         TITLE '*** XXXXSNAP-DEBUGGIN,DUMPING MODULE- V.4.0.AS ***'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                       JOHN R. MASHEY - MAY 1969     *\n*                                       VERSION 4.0 - FEBRUARY 1970   *\n*                                       VERSION 4.0.AS(SIST) FEB 1970 *\n*                                       IBM 360/67 ASSEMBLER 'G'      *\n*                                       PENNSYLVANIA STATE UNIVERSITY *\n*        ABSOLUTE REGISTER EQUATES AND USAGE                          *\n*              EQU'S HAVE BEEN CHANGED TO COMMENTS TO PREVENT MULTIPLE*\n*        DEFINITION WHEN ASSEMBLING AS PART OF ASSIST.                *\n*R0      EQU   0                   WORK REGISTER                      *\n*R1      EQU   1                   USED AS WORK REGISTER              *\n*R2      EQU   2                   USED TO HOLD 1ST ADDRESS OF PAIR   *\n*R3      EQU   3                   USED TO HOLD SECOND ADDRESS OF PAIR*\n*R4      EQU   4                   USED AS INCREMENT FOR BXLE'S       *\n*R5      EQU   5                   LIMIT ADDRESS IN VARIOUS BXLE'S    *\n*R6      EQU   6                   WILL CONTAIN CVTMZ00(HIGHEST ADDR) *\n*R7      EQU   7                   OLD ADDRESS IN SAME LINE CHECK     *\n*R8      EQU   8                   INTERNAL LINKAGE REGISTER          *\n*R9      EQU   9                   ADDRESS OF CURRENT ADDRESS PAIR    *\n*R10     EQU   10                  POINTS TO XSNAP LABEL,REGISTER AREA*\n*R11     EQU   11                  @ ECONTROL BLOCK, RELOCATION VALUE *\n*        THIS VALUE IN R11 ONLY IF XXSFLAGS HAS XXASNAP OR XXASDMP ON.*\n*R12     EQU   12                  # STORAGE= ADDRESS PAIRS TO DO     *\n*R13     EQU   13                  BASE REGISTER/@ DUMMY SAVE AREA    *\n*R14     EQU   14                  RETURN ADDR,POINTER TO LABEL LENGTH*\n*R15     EQU   15                  ENTRY POINT REGISTER               *\n*        EQUREGS L=F,DO=(0,6,2)    SET UP FLOATING EQU'S              *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*        XSNAP CONTROL BLOCK AND POINTERS ON ENTRY TO XXXXSNAP.       *\n*        FIELD     LENGTH(BYTES)   DESCRIPTION/PURPOSE                *\n*        LABEL      LABLN          LABEL=, PADDED TO FULLWORD WITH ' '*\n* R10===>RGSAV      64             16 FULLWORDS, WHERE REGS WERE SAVED*\n*        FLAGS      1              BYTE FOR OPTION BITS               *\n*              BIT 2 = 1 ==>       ASSIST COMPLETION FINAL DUMP       *\n*              BIT 3 = 1 ==>       XSNAP USER DEBUGGING DUMP(XDUMP)   *\n*              BIT 6 = 1 ==>       PRINT FP REGISTERS. IF =0, DO NOT  *\n*              BIT 7 = 1 ==>       PRINT GP REGISTERS. IF =0, DO NOT  *\n*        UNUSED     1              FOR FUTURE USE, NOT USED IN V.4.0  *\n*        LABLN      1              LENGTH OF THE LABEL FIELD          *\n*        NMSTR      1              # 8-BYTE @ PAIRS IN STORAGE= LIST  *\n*        ADCON      4              V(XXXXSNAP) FOR CALL               *\n*        ADSTR      NMSTR*8        STORAGE= @ LIST, IF PRESENT        *\n*        INSTRUCTS  10       3 INSTRUCTIONS - LA, L, BALR             *\n* R14===>LM    0,15,0(10)          RETURN POINT, RELOADS REGISTERS    *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> CSECT: XXXXSNAP   DEBUGGING OUTPUT, COMPLETION DUMP              *\n*        THIS MODULE PROVIDES ALL REGISTER AND STORAGE DUMPING FOR    *\n*        DEBUGGING PURPOSES, BOTH FOR INTERNAL ASSIST DEBUGGING, AND  *\n*        FOR USER PROGRAMS DURING EXECUTION.  IT IS CALLED BY THE     *\n*        MACRO XSNAP (XDUMP PSEUDO-INSTRUCTION FOR USER PROGRAMS),    *\n*        AND PRODUCES A USER DUMP OR DEBUGGING OUPUT IF THE CALLING   *\n*        XSNAP SPECIFIED A BINARY VALUE FOR OPERAND T(3).             *\n*        ENTRY CONDITIONS                                             *\n*   SEE XSNAP CONTROL BLOCK AND POINTERS ON ENTRY TO XSNAP COMMENTS.  *\n*   ALSO, IF SPECIAL ASSIST OUTPUT IS DESIRED I.E. T(3) IS USED, THE  *\n*   WORD IN XXSRGSAV WHERE REGISTER R10 WAS SAVED MUST CONTAIN THE    *\n*   ADDRESS OF THE ECONTROL DUMMY SECTION, WHICH SUPPLIES VALUES      *\n*        EXIT CONDITIONS                                              *\n*   ALL REGISTERS AND CONDITION CODE ARE RESTORED TO ORIGINAL VALUES  *\n*   AFTER EXECUTION OF THE INSTRUCTION AT THE RETURN POINT.           *\n*        USES DSECTS: ECONTROL,XXSNAPC                                *\n*        USES MACROS: $PRNT(IF &$DEBUG=1), OPEN,PUT(IF&$DEBUG=0)      *\n*        NAMES: XX------ , ALL NAMES ADDED FOR ASSIST: XXAS----       *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nXXXXSNAP CSECT\n         USING XXXXSNAP,R15        NOTE TEMPORARY ENTRY USING\n         USING XXSNAPC,R10         NOTE POINTER TO BLOCK\n         CNOP  0,4                 MAKE SURE ALIGNED ON FULLWORD\n         BAL   R13,*+76            SET UP BASE AND SAVE AREA @\n         USING *,R13               NOTE USING FOR BASE/SAVE AREA\nXXSSAVE  DS    18F                 FAKE SAVE AREA FOR OS TO SAVE INTO\n         ORG   XXSSAVE             ORG BACK\nXXDWORK  DS    4D                  OVERLAP FLT WORK AREAS INTO FAKE SAV\n         ORG\n         DROP  R15                 CLEAR TEMPORARY USING\n         ST    R14,XXSAVE14        SAVE RETURN ADDRESS,CC PROG MAKS\n         L     R11,XXSRGSAV+4*R10  GET PTR (WAS IN R10)\n         USING ECONTROL,R11        NOTE POINTER TO ECONTROL BLOCK\n         SPACE 2\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*        GET ADDRESS OF LABEL FROM FIRST POSITION IN ADDRESS LIST,    *\n*   AND USING REGISTER 10(THE ADDRESS OF THE REGISTER SAVE AREA)      *\n*   FIND THE LENGTH OF THE LABEL AND PRINT THE LABEL & HEADER LINE.   *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 2\nXXOPENOK SR    R2,R2               CLEAR FOR INSERTION\n         BAL   R8,XXSNBLNC         MAKE SURE XXLABEL BLANK, CC = 0\n         TM    XXSFLAGS,XXSASDMP   ARE WE IN ASSIST FINAL DUMP\n         BZ    XXASNDMP            NO, SO SKIP NEXT SECTION OF CODE ***\n         EJECT\n*              FOLLOWING SECTION PRINTS HEADER,COMPLETION CODE,PSW,   *\n*        AND INSTRUCTION TRACE(OPTIONAL) FOR AN ASSIST FINAL DUMP     *\n         SPACE 1\n         MVC   XXLABEL(L'XXAS1HD),XXAS1HD   MOVE FIRST HDR, 1 CC IN\n         BAL   R8,XXPRINTP         GO TO PRINT AS DESIRED             J\n         BAL   R8,XXSNBLNC         REBLANK XXLABEL, MAKE CC = 0 AGAIN\n         SPACE 1\n         MVC   XXAS2HD,=C'PSW AT ABEND'     MOVE HDR IN\n         MVC   XXAS2CC,=C'COMPLETION CODE'  MOVE HDR IN\n         UNPK  XXAS2P1,ECPSW(5)    FIRST HALF OF PSW\n         UNPK  XXAS2P2,ECILCMSK(5) 2ND HALF OF PSW\n         TR    XXAS2P1(2*L'XXAS2P1-1),XXTAB1         FIND CONVERSION\n         MVI   XXAS2P1+8,C' '      BLANK BETWEEN PARTS OF PSW\n         MVI   XXAS2P2+8,C' '      BLANK AFTER 2ND PART OF PSW\n         SPACE 1\n         L     R1,ECERRAD          GET @ ERROR BLOCK\n         USING ERCOMPCD,R1         NOTE THE POINTER\n         MVC   *+7(1),ERCLENG      MOVE LENGTH-1 OVER\n         MVC   XXAS2MS($CHN),ERCMSSG        MOVE MESSAGE OVER\n         SPACE 1\n         IC    R2,ERCTYPE          GET TYPE OF COMPLETION\n         SLL   R2,3                MULT * 8 FOR INDEX TO TABLE\n         DROP  R1                  NOTE NO LONGER USING BLOCK PTR\n         LA    R1,XXAS2TPM(R2)     GET @ COMPLETION TYPE\n         MVC   XXAS2TP,0(R1)       MOVE THE TYPE INTO MESSAGE\n         BAL   R8,XXPRINTL         PRINT ASSEMBLED XXLABEL\n         BAL   R8,XXSNBLNK         REBLANK XXLABEL\n         SPACE 1\n         TM    ECFLAG3,$ECDINST    SHOULD THERE BE INSTRUCTION TRACE\n         BZ    XXASREGS            NO,SO DON'T PRINT INSTRUCTIONS\n         LA    R0,XXAS3HD          SHOW @ THIS HEADER\n         BAL   R8,XXPRINT          PRINT MESSAGE\n         SPACE 1\n         LA    R0,XXAS4HD          SHOW @ OF THIS LABEL\n         BAL   R8,XXPRINT          PRINT (R0=@ XXLABEL STILL)\n         SPACE 1\n         L     R9,ECRSTK           GET @ CURRENT INSTRUCTION STACK\n         LR    R12,R9              SAVE @ FOR COMPARISON IN LOOP\n         USING ECSTACKD,R9         NOTE DSECT FOR EACH STACK ENTRY\n         SPACE 1\n*              FIRST LOOP SEARCHES FOR 1ST ACTUAL INSTRUCTION IN THE  *\n*        INSTRUCTION STACK.  CHECK REQUIRED IN CASE OF PROGRAM WHICH  *\n*        BOMBS ON 1ST INSTRUCTION, SUCH AS BEGINNING WITH DC H'0'.    *\nXXASINA  L     R9,ECSTLINK         GET @ NEXT INSTRUCTION ENTRY\n         CLI   ECOP,0              WAS THIS AN INSTRUCTION\n         BNE   XXASINB             YES,SKIP TO BEGIN PRINTING\n         CR    R9,R12              CHECK FOR COMPLETE CYCLE\n         BNE   XXASINA             NOT CYCLE,LOOP UNTIL 1ST INST\n         SPACE 1\n*              HAVING FOUND 1ST ACTUAL INSTRUCTION, OR SINGLE OPCODE  *\n*        OF 0 IN INSTRUCTION CYCLE, PRINT 1 OR MORE INSTRUCTIONS.     *\nXXASINB  NI    ECSTCCPM,X'3F'      ZERO OUT ILC(NOT ALREADY SAVED)\nXXASINB1 OI    ECSTCCPM,$CHN       OR BUILT-UP ILC FROM LAST INST\n         MVI   *-3,0               ZERO OUT BYTE FOR ILC\n         MVC   XXAS5I2(10),XXBLANKS         BLANK HALFWORDS 2-3\n         SPACE 1\n         UNPK  XXAS5I1(5),ECOP(3)  CONVERT OPCODE REGS/LENGTH (ALWAYS)\n         MVI   XXAS5I1+4,C' '      BLANK TRAILING BYTE\n         CLI   ECOP,X'40'          WAS INSTRUCTION RR\n         BL    XXASINC             YES,SO DO NO MORE ON INST\n         SPACE 1\n         UNPK  XXAS5I2(5),ECBD(3)  UNPACK FIRST BASE-DISPLACEMENT\n         OI    XXASINB1+1,X'80'    SET ILC FOR NEXT INST TO 2\n         MVI   XXAS5I2+4,C' '      BLANK TRAILING BYTE\n         CLI   ECOP,X'C0'          WAS INST RX,RS,SI\n         BL    XXASIND             YES,SO NO MORE CONVERT NEEDED\n         SPACE 1\n         UNPK  XXAS5I3(5),ECB2D2(3) UNPACK 3RD HALFWORD- 2ND BASE-DISP\n         MVI   XXAS5I3+4,C' '      BLANK TRAILING BYTE\nXXASINC  OI    XXASINB1+1,X'40'    SET NEXT ILC TO 1(RR), OR 3(SS)\nXXASIND  UNPK  XXAS5CC(3),ECSTCCPM CONVERT ILC(NOW RIGHT) CC PM OF PSW\n         MVI   XXAS5CC+2,C' '      BLANK TRAILING BYTE\n         SPACE 1\n         UNPK  XXAS5AD(7),ECSTIADD+1(4)     CONVERT INST ADDRESS\n         MVI   XXAS5AD+6,C' '      BLANK TRAILING BYTE\n         TR    XXAS5CC(XXAS5$L-2),XXTAB1    FINISH HEX CONVERT\n         SPACE 1\n         CR    R9,R12              WAS THIS LAST ONE\n         BNE   *+10                BRANCH OVER MVC IF NOT LAST ONE\n         MVC   XXLABEL+2+XXAS5$L(L'XXAS5P),XXAS5P     MOVE ERR PTR\n         BAL   R8,XXPRINTL         PRINT ASSEMBLED XXLABEL\n         CR    R9,R12              WAS THIS THE LAST 1(ABENDING INSTR)\n         L     R9,ECSTLINK         GET @ NEXT ENTRY IN TABLE\n         BNE   XXASINB             GOBACK FOR NEXT ENTRY IN TABLE\n         SPACE 1\nXXASINE  MVC   XXLABEL+1(XXAS5$L+2+L'XXAS5P),XXBLANKS REBLANK\n         BAL   R8,XXPRINTL         PRINT ASSEMBLED XXLABEL\n         DROP  R9                  DROP LEFTOVER USING          CPP\n         AIF   (NOT &$EXINT).NOXXINT\n         SPACE 3\n         SPACE 2\n         LA    R0,XXAS7HD          GET ADDR 1ST BRANCH TRACE HEADER\n         BAL   R8,XXPRINT          BRANCH, AND PRINT THES HEADER\n         SPACE 2\n         LA    R0,XXAS4HD          GET ADDR 2ND BRANCH TREE HEADER\n         BAL   R8,XXPRINT          PRINT THIS HEADER\n         SPACE 2\n*              GET BRANCH STACK ADDRESSIBILITY\n         L     R1,ECBSTK           GET @ CURRENT BRANCH INSTR STACK\n         LR    R12,R1              SAVE ADDRESS FOR COMPARISON IN LOOP\n         USING ECSTACKD,R1         NOTE DSECT FOR EACH BSTACK ENTRY CEH\n         SPACE 2\n*              FIRST LOOP SEARCHES FOR 1ST ACTUAL BRANCH INSTRUCTION IN\n*              THE BRANCH INSTRUCTION STACK.  CHECK REQUIRED IN CASE OF\n*              PROGRAM BOMB HAVING EXECUTED NO BRANCHES.\nXXASBINA EQU   *\n         L     R1,ECSTLINK         GET @ NEXT BRANCH ENTRY      CEH\n         CLI   ECOP,0              WAS THIS ENTRY AN INSTR.     CEH\n         BNE   XXASBINB            YES, SKIP TO BEGIN PRINTING\n         CR    R1,R12              CHECK FOR A COMPLETE CYCLE\n         BNE   XXASBINA            NOT CYCLE, LOOP UNTIL 1ST BRANCH\n         SPACE 2\n*              HAVE FOUND 1ST ACTUAL !RANCH INSTRUCTION, OR A SINGLE  *\n*              OPCODE IN BRANCH INSTRUCTION CYCLE. PRINT 1 OR MORE    *\n*              INSTRUCTIONS                                           *\nXXASBINB EQU   *\n         NI    ECSTCCPM,X'3F'      ZERO OUT ILC(NOT ALREADY SAVED) CEH\nXXASBIN1 OI    ECSTCCPM,$CHN       OR BUILT-UP ILC FROM LAST INSTR CEH\n         MVI   *-3,0               ZERO OUT BYTE FOR ILC\n         MVC   XXAS5I2(10),XXBLANKS     BLANK OUT HALFWORDS 2 AND 3\n         SPACE 2\n         UNPK  XXAS5I1(5),ECOP(3)  CONVERT OPCODE, REGS. & LEN  CEH\n         MVI   XXAS5I1+4,C' '      BLANK OUT TRAILING BYTE\n         CLI   ECOP,X'40'          WAS THIS AN RR INSTR.       CEH\n         BL    XXASBINC            YES WE ARE FINISHED WITH THIS INSTR\n         SPACE 2\n         UNPK  XXAS5I2(5),ECBD(3)   UNPACK ONLY BASE-DISPL.      CEH\n         OI    XXASBIN1+1,X'80'    SET ILC NEXT INSTR TO 2\n         MVI   XXAS5I2+4,C' '      BLANK OUT TRAILING BYTE\n         B     XXASBIND            NO MORE CONVERSION NEEDED\n         SPACE 2\nXXASBINC EQU   *\n         OI    XXASBIN1+1,X'40'    SET NEXT ILC TO 1 FOR RR INSTR\nXXASBIND EQU   *\n         UNPK  XXAS5CC(3),ECSTCCPM CONVERT GOOD ILC-CC PM OF PSW CEH\n         MVI   XXAS5CC+2,C' '      BLANK OUT TRAILING BYTE\n         SPACE 2\n         UNPK  XXAS5AD(7),ECSTIADD+1(4)    CONVERT BR INST. ADDR. CEH\n         MVI   XXAS5AD+6,C' '      BLANK OUT TRAILING BYTE\n         TR    XXAS5CC(XXAS5$L-2),XXTAB1   FINISH HEX CONVERT\n         SPACE 2\n         BAL   R8,XXPRINTL         PRINT ASSEMBLED XXLABEL\n         CR    R1,R12              WAS THIS THE FINAL BRANCH INSTR\n         L     R1,ECSTLINK         GET NEXT ENTRY IN TABLE      CEH\n         BNE   XXASBINB            GO BACK FOR NEXT ENTRY IN TABLE\n         BAL   R8,XXSNBLNC         CLEAR XXLABEL OF GARBAGE\n         DROP  R1                  CLEAR AWAY BASE REGISTER\n.NOXXINT ANOP\n         SPACE 1\n*              FINAL DUMP==> EITHER PRINT ALL REGS OR NONE            *\nXXASREGS TM    ECFLAG3,$ECREGS     SHOULD WE GIVE REGS\n         BO    XXASREG1            YES,SO GO DO IT\n         B     XXCHKST             NO REGS AT ALL\n         EJECT\nXXASNDMP EQU   *                   ENTRY LABEL FOR NORMAL XSNAP\n         IC    R2,XXSLABLN         GET LENGTH OF LABEL FIELD\n         LR    R1,R10              GET DUPLICATE OF XXSNAPC PTR\n         SR    R1,R2               SUBTRACT TO GET START @ FOR LABEL\n         BCTR  R2,0                DECREMENT TO LENGTH-1 FOR MVC\n         STC   R2,*+5              STORE INTO MVC\n         MVC   XXLABEL+38($CHN),0(R1)       MOVE LABEL TO PRINT AREA\n         ST    R1,XXWORK1          SAVE THIS @ FOR CONVERSION\n         MVC   XXWORK1(1),XXSAVE14 MOVE CCMASK OVER FOR CONVERSION\n         SPACE 1\n         TM    XXSFLAGS,XXSASNAP   IS THIS A USER SNAP\n         BZ    *+10                NO,SO DON'T CHANGE PSW\n         MVC   XXWORK1(4),ECILCMSK MOVE USER PSW OVER\n         MVC   XXLABEL+1(XXSN1B),XXSNP1ST    MOVE HEADER,PATTERN,MSG\n         ED    XXLABEL+L'XXSNP1ST+1(6),XXCOUNT         EDIT CALL NUMBER\n         UNPK  XXLABEL+1+XXSN1B(9),XXWORK1(5)       CONVERT CCPM,LOCN\n         TR    XXLABEL+1+XXSN1B(8),XXTAB1  FINISH HEX CONVERSION\n         AP    XXCOUNT,=P'1'       INCREMENT # CALLS\n         BAL   R8,XXPRINTL         PRINT ASSEMBLED XXLABEL\n         BAL   R8,XXSNBLNK         REBLANK XXLABEL\n         SPACE 2\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*        CHECK TO SEE IF THE REGISTERS SHOULD BE PRINTED.             *\n*        PRINT THE HEADING FOR THE REGISTER DUMP.  CONVERT AND PRINT  *\n*   THE REGISTERS IN 2 LINES. CHECK TO SEE IF ONLY THE REGISTERS      *\n*   WERE DESIRED. FINISH UP AND RETURN TO CALLING XSNAP IF SO.        *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 2\n         TM    XXSFLAGS,XXSGPRG    DOES HE WANT GP REGS PRINTED\n         BZ    XXCHKFP             NO, SO DONT PRINT THEM\n         LR    R2,R10              DUPLICATE @ RGSAV OVER\n         TM    XXSFLAGS,XXSASNAP   WAS THIS USER XSNAP\n         BZ    XXGOREG             NO,NORMAL XSNAP,SKIP\nXXASREG1 LA    R2,ECREGS           SHOW @ FAKE REGS INSTEAD\nXXGOREG  EQU   *                   ***WE HAVE DELETED REG HEADER**    J\n         SPACE 1\n         MVC   XXREGOUT(12),=CL12'0 REGS 0-7'          LABEL-1ST REGS\n         BAL   R8,XXREGS1          CONVERT 1>T REGS BLOCK,PRINT LINE\n         BAL   R8,XXPRINT          HAVE LINE PRINTED\n         SPACE 1\n         MVC   XXREGOUT(12),=CL12'  REGS 8-15'   2ND LINE LABEL\n         BAL   R8,XXREGS2          GET 2ND GROUP CONVERTED,PRINTED\n         BAL   R8,XXPRINT          HAVE LINE PRINTED\n         SPACE 1\nXXCHKFP  EQU   *\n         AIF   (NOT &$FLOTM).XXS2  SKIP IF MACHINE DOEN'T HAVE FLOT\n         TM    XXSFLAGS,XXSFLRG    DOES HE WANT FLOATING PT REGS PRINT\n         BZ    XXCHKST             NO,SO GO CHECK FOR STORAGE=\n         SPACE 1\n*              FOLLOWING SECTION PRINTS FLOATING POINT REGISTERS      *\n         MVC   XXREGOUT(12),=CL12'0 FLTR 0-6'         MOVE LABEL IN\n         LA    R2,ECFPREGS         SHOW @ FAKE REGS\n         TM    XXSFLAGS,XXSASDMP+XXSASNAP   WAS THIS ASSIST SNAP/DUMP\n         BNZ   XXFPCONV            GO CONVERT THEM\n         STD   F0,XXDWORK          SAVE REG F0\n         STD   F2,XXDWORK+8        SAVE F2\n         STD   F4,XXDWORK+16       SAVE F4\n         STD   F6,XXDWORK+24       SAVE F6\n         LA    R2,XXDWORK          SET UP @ WORKAREA FOR XXREGS1\nXXFPCONV EQU   *\n         BAL   R8,XXREGS1          CALL GP REG CONVERTER\n         MVC   XXREGOUT+24(12),XXREGOUT+28           PUT F0 TOGETHER\n         MVC   XXREGOUT+48(12),XXREGOUT+52           PUT F2 TOGETHER\n         MVC   XXREGOUT+72(12),XXREGOUT+76           PUT F4 TOGETHER\n         MVC   XXREGOUT+96(12),XXREGOUT+100          PUT F6 TOGETHER\n         BAL   R8,XXPRINT          PRINT THE ASSEMBLED LINE\n         MVC   XXREGOUT,XXBLANKS   REBLANK LINE LIKE ITS SUPPOSED TO BE\n.XXS2    ANOP\n         SPACE 1\nXXCHKST  EQU   *\n         SR    R12,R12             CLEAR FOR INSERTION\n         IC    R12,XXSNMSTR        GET # OF ADDRESS PAIRS\n         LTR   R12,R12             ARE THERE ANY @ PAIRS\n         BZ    XXEXIT1             NO STORAGE=, SO QUIT\n         LA    R9,XXSADSTR         INIT R9 TO @ FIRST ADDRESS PAIR\n         LA    R4,4                SET UP BXLE INDEX FOR REST OF PROG\n         SPACE 1\n         TM    XXSFLAGS,XXSASNAP+XXSASDMP   ARE SPECIAL @ GAMES NEEDED\n         BZ    XXASTA              SKIP IF NOT (I.E. NORMAL XSNAP)\n         TM    XXSFLAGS,XXSASDMP   WAS THIS A DUMP?\n         BZ    XXAST               SKIP IF JUST SNAP\n         TM    ECFLAG3,$ECSTORG    SHOULD STORAGE BE DUMPED\n         BZ    XXEXIT3             NO STORAGE,SO QUIT\n         MVC   XXLABEL(L'XXAS6HD),XXAS6HD   MOVE IN STORAGE DUMP HEADER\n         BAL   R8,XXPRINTP         GO PRINT AS DESIRED                J\n         BAL   R8,XXSNBLNC         REBLANK XXLABEL, MAKE SURE CC = 0\n         SPACE 1\nXXAST    L     R6,ECRADH           GET REAL HIGH LIMIT @\n         TM    ECFLAG0,$ECPROT     WAS ABSOLUTE PROTECT MODE ON\n         L     R11,ECRELOC         GET EXECUTION TIME RELOCATION FACTOR\n         BZ    XXASTB              NO, SKIP, RESET TO NORMAL LIMIT\n         DROP  R11                 NOTE NO LONGER USING WITH ECONTROL\n         LCR   R11,R11             MAKE NEGATIVE,SO CAN USE IN LA'S\n         B     XXASTC              SKIP TO BEGIN PROCESSING\n*              NOTE ASSIST DUMP REQUIRES USER CORE TO BEGIN ON REAL   *\n*        ADDRESS DIVISIBLE BY 32,TO GET REASONABLE OUTPUT.            *\n         SPACE 1\n*              THE FOLLOWING 2 LINES HELP US PREVENT 0C5'S            *\nXXASTA   SR    R11,R11             SET RELOCATION TO 0 (NORMAL XSNAP)\n         AIF   (NOT &$ASMLVL).XXASDOS   SKIP IF OTHER THAN OS/360\nXXASTB   L     R6,16               CVT PTR **********OS/360 ONLY ******\n         L     R6,164(R6)          GET CVTMZ000 - HIGHEST CORE @\n.XXASDOS AIF   (&$ASMLVL).XXASNOS  SKIP IF OS/360, CAN GET SIZ FROM CVT\nXXASTB   COMRG                     R1 <- @ OF COMMUNICATIONS REGION\n         L     R6,48(R1)           GET @ OF END OF MACHINE (DOS)\n         LA    R6,1(R6)            GET @ ON NEXT NON-AVAIL BYTE\n.XXASNOS ANOP\nXXASTC   SH    R6,=H'32'           REDUCE SO WILL NOT 0C5\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*        SECTIONS XXMEMA - XXMEME SERVE TO PROCESS 1 ADDRESS PAIR     *\n*   FROM THE LIST OF ADDRESS PAIRS SPECIFYING STORAGE TO BE DUMPED.   *\n*   AT XXMEMF,THE 2ND ADDRESS IS TESTED TO SEE IF IT IS THE LAST ONE  *\n*   AND  THE DUMP COMPLETED IF SO. OTHERWISE,A BRANCH IS TAKEN BACK   *\n*   TO XXMEMA TO PROCESS THE NEXT ADDRESS PAIR.                       *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 2\nXXMEMA   LM    R2,R3,0(R9)         OBTAIN NEXT ADDRESS PAIR\n         LA    R0,0(R11,R2)        RELOCATE ADDRESS IF NEEDED\n         ST    R0,XXWORK1          SAVE FOR CONVERSION\n         UNPK  XXCOREL,XXWORK1+1(4)         CONVERT WITH TRAILING BLANK\n         LA    R0,0(R11,R3)        GET HIGH ADDRESS,RELOCATE\n         ST    R0,XXWORK1          SAVE FOR CONVERT\n         UNPK  XXCOREH,XXWORK1+1(4)         CONVERT WITH TRAILING BLANK\n         TR    XXCOREL(17),XXTAB1  TRANSLATE TO COMPLETE HEX CONVERT\n         MVC   XXCOREL+7(2),=C'TO' PUT REST OF MSG IN\n         MVC   XXCORETL,=C'CORE ADDRESSES SPECIFIED-' PUT IN MSG\n         BAL   R8,XXPRINTL         PRINT XXLABEL\n         MVC   XXCORETL(XXCORE$L),XXBLANKS+30         REBLANK THE AREA\n         SPACE 1\n         CR    R3,R6               MAKE SURE HIGH ADDR ISN'T TOO HIGH\n         BNH   *+6                 SKIP OVER IF NOT TOO HIGH\n         LR    R3,R6               @ WOULD 0C5-USE HIGHEST INSTEAD\n         LA    R3,31(R3)           PREPARE TO ROUND 2ND ADDR UPWARD\n         SRDL  R2,5                ROUND BOTH ADDRESSES\n         SLL   R2,5                NOW HAVE 1ST ADDR IN R2,ROUNDED DOWN\n         SLL   R3,5                NOW HAVE HIGH ADDR IN R3,ROUNDED UP\n         CR    R2,R3               WAS USER IN ERROR: LOW ADDR>HIGH ADD\n         BH    XXMEMF              ADDR ERROR-PRINT NOTHING,GO TO NEXT\n         CR    R2,R6               MAKE SURE IF 1ST=2ND>MEMORY SIZE\n         BH    XXMEMF              PRINT NOTHING IF SO\n         SPACE 2\nXXMEMB   EQU   *\n         AR    R2,R11              RELOCATE IF NEEDED\n         ST    R2,XXWORK1          STORE BEGINNING ADDR FOR CONVERT\n         SR    R2,R11              CONVERT BACK TO REAL @\n         LR    R7,R2               SAVE BEGINNING ADDRESS FOR SAME CHK\n         UNPK  XXCORADD+1(7),XXWORK1+1(4)    GET BEGINNING ADDRESS\n         MVC   XXCORE3,0(R2)       MOVE 32 BYTES OVER FOR ALPHMERIC TR\n         TR    XXCORE3,XXTAB2      PERFORM ALPHAMERIC CONVERSION\n         SPACE 1\n         LA    R1,XXCORE1          ADDRESS FOR 1ST BLOCK CONVERSION\n         BAL   R8,XXMEMP1          GET 1ST BLOCK OF 4 WORDS CONVERTED\n         LA    R1,XXCORE2          ADDRESS FOR 2ND BLOCK CONVERSION\n         BAL   R8,XXMEMP1          GET 2ND BLOCK CONVERTED\n         SPACE 1\n         TR    XXCORADD+1(84),XXTAB1         FINISH HEX CONVERSION\n         LA    R0,XXCORADD         ADDRESS OF CORE OUTPUT LINE\n         BAL   R8,XXPRINT          GET 1 CORE LINE PRINTED\n         EJECT\n*        XXMEMC-XXMEME CHECK FOR DUPLICATE LINES. HAVING FOUND 1 OR   *\n*   MORE DUPLICATE LINES,CORE IS SCANNED UNTIL A DIFFERENT LINE IS    *\n*   FOUND,OR THE BLOCK FINISHED,AND THEN PRINTS SAME LINES MESSAGE.   *\n         SPACE 2\nXXMEMC   CR    R2,R3               R2 HAS BEEN INCREMENTED-ARE WE DONE\n         BNL   XXMEMF              YES WE'RE DONE WITH THIS SECTION\n         CLC   0(32,R7),0(R2)      COMPARE PREVIOUS SECTION WITH NEXT\n         BNE   XXMEMB              NOT THE SAME-WILL HAVE TO PRINT LINE\n         LA    R7,32(R11,R7)       INCREMENT TO MAKE RIGHT @,RELOCATE\n         ST    R7,XXWORK1          SAVE 1ST LINE ADDRESS OF SAME AREAS\n         SR    R7,R11              CONVERT BACK TO REAL @\n         UNPK  XXSAML,XXWORK1+1    1ST STEP TO CONVERT\n         SPACE 1\nXXMEMD   LA    R2,32(R2)           INCREMENT TO LOOK AT NEXT SECTION\n         CR    R2,R3               ARE WE DONE\n         BNL   XXMEME              YES,WE'RE DONE-SAME LINES MESSAGE\n         CLC   0(32,R7),0(R2)      CHECK NEXT SECTION WITH 1ST OF SAMES\n         BE    XXMEMD              SAME-KEEP LOOPING UNTIL DIFFERENT\n         SPACE 1\nXXMEME   LA    R1,0(R11,R2)        GET END @,RELOCATE,WHERE CAN DESTROY\n         SH    R1,=H'32'           DECRMENT SO LINE ADDR RIGHT\n         ST    R1,XXWORK1          SAVE FOR HEX CONVERSION\n         UNPK  XXSAMH,XXWORK1+1    CONVERT-FIRST STEP\n         TR    XXSAML(13),XXTAB1   FINISH HEX CONVERSION OF SAME LINES\n         MVI   XXSAML+6,C'-'       PLACE DASH BETWEEN ADDRESSES\n         MVC   XXLABEL+1+3(XXSAM$L),XXSAME  MOVE SAME LINES MSG OVER\n         LA    R0,XXLABEL+1        SHOW @ 1 BEYOND CARRIAGE CONTROL\n         BAL   R8,XXPRINT          PRINT THE SAME LINE MESSAGE\n         CR    R2,R3               HAVE WE MEANWHILE FINISHED BLOCK\n         BL    XXMEMB              NO-KEEP GOING UNTIL BLOCK DONE\n         SPACE 1\nXXMEMF   LA    R9,8(R9)            INCREM R9 TO @ NEXT @ PAIR\n         MVC   XXLABEL+1+3(XXSAM$L),XXBLANKS+1+3      REBLANK AREA\n         BCT   R12,XXMEMA          GO BACK FOR NEXT BLOCK\n         B     XXEXIT2             ALL STORAGE= DONE, GO RETURN\n         EJECT\n*        XXEXIT - PRINT ENDING LINE,THEN RETURN TO CALLING XSNAP.     *\n         SPACE 2\nXXEXIT1  TM    XXSFLAGS,XXSGPRG+XXSFLRG     WERE EITHER REGS PRINTED\n         BZ    XXEXIT3             NO OPTIONS, JUST LEAVE SINGLE LINE\nXXEXIT2  EQU   *                   DON'T HAVE TO SET R0, USE XXPRINTL\n         BAL   R8,XXPRINTL         PRINT XXLABEL FOR A BLNKA LINE\nXXEXIT3  L     R14,XXSAVE14        RELOAD RETURN @, CC\n         SPM   R14                 RESTORE CONDITION CODE\n         BR    R14                 RETURN TO CALLING XSNAP\n         EJECT\n*        ***  INTERNAL SUBROUTINE AREA ***                            *\n         SPACE 1\n*              XXSNBLNC BLANKS XXLABEL, SETS CARRIAGE CONTROL = 0.\n*              XXSNBLNK JUST BLANKS XXLABEL, NOT CHANGING CC.\nXXSNBLNC MVI   XXLABEL,C'0'        MAKE NORMAL DOUBLE SPACE CC\nXXSNBLNK MVC   XXLABEL+1(L'XXLABEL-1),XXBLANKS+1 REBLANK ENTIRE AREA\n         BR    R8                  RETURN TO CALLER\n         SPACE 2\n*              XXREGS1 CONVERTS AND PRINTS 1 LINE OF 8 REGISTERS      *\n         SPACE 1\nXXREGS1  LA    R4,12               INCREMENT FOR BXLE\n         LA    R5,XXREGOUT+16+7*12 LIMIT ADDRESS FOR BXLE\nXXREGS2  LA    R3,XXREGOUT+16      START POINT,INDEX FOR COMING BXLE\nXXREGS3  UNPK  0(9,R3),0(5,R2)     CONVERT 1 REGISTER VALUE\n         MVI   8(R3),C' '          BLANK OUT EXTRA BYTE USED IN CONVERT\n         LA    R2,4(R2)            INCREMENT POINTER TO REGISTER\n         BXLE  R3,R4,XXREGS3       LOOP-DO 1 LINE OF 8 REGISTER VALUES\n         TR    XXREGOUT+16(92),XXTAB1        FOR REST OF HEX CONVERT\n         LA    R0,XXREGOUT         ADDRESS OF OUTPUT LINE\n         BR    R8                  RETURN TO CALLER\n         SPACE 2\n*              XXMEMP1 CONVERTS 1 BLOCK OF 16 BYTES TO HEX.           *\n         SPACE 1\nXXMEMP1  LA    R5,12(R2)           SET UP LIMIT FOR BXLE\nXXMEMP2  UNPK  0(9,R1),0(5,R2)     UNPACK 1 WORD OF MEMORY\n         MVI   8(R1),C' '          BLANK OUT EXTRA BYTE UNPACKED\n         LA    R1,9(R1)            INCREMENT POINTER TO OUTPUT AREA\n         BXLE  R2,R4,XXMEMP2       CONTINUE,CONVERTING 16 BYTES\n         BR    R8                  RETURN TO CALLER\n         SPACE 2\n*              XXPRINTL PRINTS 121 CHARACTERS STARTING AT XXLABEL.    *\n*              XXPRINT  PRINTS 121 CHARACTERS STARTING AT @ IN R0.    *\n         SPACE 1\nXXPRINTP EQU   *    ***COME HERE IF MIGHT BE PAGE SKIP POSSIBLE***    J\n         AIF   (&$DMPAG).XXNPQQQ   SKIP IF PAGE EJECTS ALLOWED AT ALL J\n         MVI   XXLABEL,C'0'        USE DOUBLE SPACE RATHER THAN EJECT J\n.XXNPQQQ ANOP                                                         J\nXXPRINTL LA    R0,XXLABEL          SHOW @ XXLABEL\nXXPRINT  EQU   *\n         AIF   (&$DEBUG).XXS50     SKIP IF PRODUCTION\n         PUT   XXSNDCB,(0)\n         AGO   .XXS60              SKIP\n.XXS50   $PRNT (0),121,XXSNPROV    PRINT OUTPUT,GO TO LABEL IF OVERFLOW\n.XXS60   ANOP\n         BR    R8                  RETURN TO CALLER\n         EJECT\n*              EXIT TAKEN IF RECORD LIMIT OVERRUN.  THIS CHECKS TO    *\n*        SEE IF OUTPUT IS FOR AN EXECUTION-TIME XDUMP, IN WHICH CASE  *\n*        EXECUTION IS STOPPED, SINCE USER IS OVERRUNNING HIS LIMIT.   *\nXXSNPROV EQU   *\n         TM    XXSFLAGS,XXSASNAP   WAS THIS A USER SNAP (XDUMP)\n         BZ    XXEXIT3             NO, FINAL DUMP-WE'RE DONE\n         SPACE 1\n*              OVERFLOW OCCURED.  QUIT, FLAGGING ECONTROL.\n         L     R11,XXSRGSAV+4*R10  GET PTR TO ECONTROL, WAS IN R10\n         USING ECONTROL,R11        NOTE POINTER\n         MVI   ECFLAG1,$ECRECEX    SHOW EXECUT THAT RECORD OVERFLOWED\n         B     XXEXIT3             GO RETURN CONTROL\n         DROP  R11                 NOT NEEDED ANYMORE\n         SPACE 5\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> ENTRY: XXXXSNIN   XXXXSNAP INITIALIZATION ENTRY                  *\n*        CALLED TO INITIALIZE 'XSNAP - CALL' NUMBER TO 1 (IN CASE     *\n*        BATCHED RUNS ARE USED).                                      *\n*        ENTRY CONDITIONS                                             *\n*   R14= RETURN ADDRESS                                               *\n*   R15= @ XXXXSNIN                                                   *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         ENTRY XXXXSNIN            INITIALIZATION ENTRY FOR ASSIST\n         USING XXXXSNIN,R15        NOTE USING\nXXXXSNIN ZAP   XXCOUNT,=P'1'       INITILZE COUNTER TO 1\n         BR    R14                 RETURN TO CALLER\n         SPACE\n         EJECT\n*        *** OUTPUT LINE,CONSTANT, AND TRANSLATE TABLE AREA ***       *\n         SPACE 2\nXXSAVE14 DS    A                   SAVE WORD FOR RETURN @, CC,MASK\nXXWORK1  DC    F'0',X'04'          FIELD + REVERSED BLANK FOR HEX CONVT\nXXCOUNT  DC    PL3'1'              COUNTER FOR NUMBER OF CALLS\n         AIF   (&$DEBUG).XXS70     SKIP IF PRODUCTION VERSION\n         PRINT NOGEN\n         ENTRY XXSNDCB             SO PEOPLE CAN CHANGE,IF THEY WISH\n         AIF   (&$ASMLVL).XXSNDTF  SKIP IF UNDER OS GENERATION\nXXSNDCB  DTFPR DEVADDR=SYSLST,BLKSIZE=121,CTLCHR=YES,IOAREA1=XXSNIOAR, X\n               WORKA=YES\nXXSNIOAR DC    121C' '             DOS XSNAP IOAREA\n.XXSNDTF AIF   (NOT &$ASMLVL).XXS70    SKIP IF UNDER DOS GENERATION\nXXSNDCB  DCB   DSORG=PS,MACRF=PM,RECFM=FA,LRECL=121,BLKSIZE=121,       #\n               DDNAME=XSNAPOUT,BUFNO=1\n.XXS70   ANOP\n         SPACE 1\n         DS    0D                  ALIGN FOR SPEED\nXXSNP1ST DC    C'BEGIN XSNAP - CALL'         HEADER TITLE\n         DC    X'402020202021'     EDIT PATTERN FOR CALL NUMBER\n         DC    C' AT '             FOR XSNAP LOCATION MESSAGE\nXXSN1B   EQU   *-XXSNP1ST          LENGTH OF HEADER,NUMBER,LOCATION\n         SPACE 1\n         DS    0D                  ALIGN FOR SPEED\nXXSAME   DC    CL9'LINES'          BEGINNING OF SAME LINE MSG\nXXSAML   DC    CL7' '              LOWEST ADDRESS AREA\nXXSAMH   DC    CL7' ',C'   SAME AS ABOVE'   END OF SAME LINES MSG\nXXSAM$L  EQU   *-XXSAME            LENGTH OF MESSAGE\n         SPACE 1\n         DS    0D                  ALIGN FOR SPEED\nXXLABEL  DC    CL121'0'            MAIN PRINTING AREA, WITH SKIP CARCON\n         DC    CL7' '              PAD TO DOUBLEWORD BOUNDARY\n         SPACE 1\n         DS    0D                  ALIGN FOR SPEED\nXXBLANKS DC    CL121' ',CL7' '     BLANKS, ALSO FOR XXREGLAB PRINTING\n         DS    0D                  ALIGN FOR SPEED\nXXREGOUT DC    CL121' '            REGISTER PRINTING AREA\n         SPACE 1\n         DS    0D                  ALIGN FOR SPEED\nXXTAB    DC    C'0123456789ABCDEF' TR TABLE FOR HEX CONVERT\nXXTAB1   EQU   XXTAB-240           TO MAKE CONSTANT TR'S EASIER FOR HEX\n         SPACE 1\n         DS    0D                  ALIGN FOR SPEED\nXXTAB2   DC    64C'.',C' ',128C'.',C'ABCDEFGHI',7C'.',C'JKLMNOPQR'\n         DC    8C'.',C'STUVWXYZ',6C'.',C'0123456789',6C'.'  ALPH TR TAB\n         SPACE 1\n         DS    0D                  ALIGN FOR SPEED\nXXCORADD DC    CL7' ',CL3' '       10 BYTES - LINE ADDRESS\nXXCORE1  DC    4CL9' ',CL3' '      39 BYTES - SPACE FOR 4 WORDS\nXXCORE2  DC    4CL9' ',CL3'  *'    39 BYTES - SPACE FOR 2ND BLOCK\nXXCORE3  DC    CL32' ',C'*'        33 BYTES - ALPHAMERICS +   *\n         SPACE 1\n         ORG   XXLABEL+30          ORG BACK TO MAIN LABEL AREA\nXXCORETL DS    C'CORE ADDRESSES SPECIFIED-'   SPACE FPR HDR\n         ORG   XXCORETL+30         SPACE UPWARD\nXXCOREL  DS    CL7,CL3             SPACE FOR LOW ADDR, 'TO '\nXXCOREH  DS    CL7' '              SPACE FOR 2ND @\nXXCORE$L EQU   *-XXCORETL          GET LENGTH OF HDR\n         ORG   ,                   RESTORE NORMAL LOCATION CTR\n         EJECT\n         DS    0D                  ALIGN FOR SPEED\nXXAS1HD  DC    C'1 ASSIST COMPLETION DUMP'  HEADER 1ST PAGE OF DUMP\n         SPACE 1\n         ORG    XXLABEL+1          ORG BACK TO LABEL PRINTING AREA+1\nXXAS2HD  DS    C'PSW AT ABEND'     SPACE FOR HDR, L' ATTRIBUTE SET\n         DS    C                   SPACING BYTE\nXXAS2P1  DS    CL9                 1ST HALF OF PSW\nXXAS2P2  DS    CL9                 2ND HALF OF PSW\n         DS    CL6' '\nXXAS2CC  DS    C'COMPLETION CODE',CL3' '    SPACE, L'\nXXAS2TP  DS    CL8                 SPACE FOR TYPE-SYTEM,ASSIST,USER =\n         DS    C' '\nXXAS2MS  EQU   *                   FOR MESSAGE\n         ORG   ,                   ORG BACK TO NORMAL LOCATION CTR\n         SPACE 1\nXXAS2TPM DC    CL8'SYSTEM =',CL8'ASSIST =',CL8' USER  ='\n         SPACE 1\nXXAS3HD  DC    CL121'0** TRACE OF INSTRUCTIONS JUST BEFORE TERMINATION:#\n                PSW BITS SHOWN ARE THOSE BEFORE CORRESPONDING INSTRUCTI#\n               ON DECODED ***'\n         SPACE 1\nXXAS4HD  DC    CL121'0  IM LOCATION    INSTRUCTION :  IM = PSW BITS 32-#\n               39(ILC,CC,MASK) BEFORE INSTRUCTION EXECUTED AT PROGRAM L#\n               OCATION SHOWN'\n         SPACE 1\n         ORG   XXLABEL+1           ORG BACK INTO MAIN LABEL\nXXAS5HD  DS    C'  '               SPACING\nXXAS5CC  DS    XL2                 ILC-CC-PM\n         DS    C'  '               SPACING\nXXAS5AD  DS    XL6                 PSW ADDRESS\n         DS    CL5' '\nXXAS5I1  DS    XL5                 1ST HALFWORD OF INSTRUCTION\nXXAS5I2  DS    XL5                 2ND HALFWORD OF INSTRUCTION\nXXAS5I3  DS    XL5                 3RD HALFWORD OF INSTRUCTION\nXXAS5$L  EQU   *-XXAS5HD           DEFINE LENGTH OF THIS MESSAGE\n         ORG   ,                   RESTORE NORMAL LOCATION CTR\nXXAS5P   DC    C'<-- LAST INSTRUCTION DONE - PROBABLE CAUSE OF TERMINAT#\n               ION'                BOMB POINTER MSG\n         SPACE 1\nXXAS6HD  DC    C'1 USER STORAGE'   HEADER 2ND PAGE OF DUMP\n         LTORG\n         AIF   (NOT &$EXINT).XXASNXT\n         SPACE 3\n*              THESE LABELS ARE ONLY USED IN THE LAST 10 BRANCH       *\n*              INSTRUCTION COMPLETION MESSAGE                         *\n         SPACE 2\nXXAS7HD  DC    CL121'-** TRACE OF LAST 10 BRANCH INSTRUCTIONS EXECUTED:X\n                PSW BITS SHOWN ARE THOSE BEFORE CORRESPONDING INSTRUCTIX\n               ON DECODED ***'\n.XXASNXT ANOP\n         DROP  R10,R13             DROP REGISTERS NO LONGER USED CPP\n         TITLE '*** XXXXSPIE  ASSIST INTERRUPTS COMMUNICATIONS ***'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> CSECT: XXXXSPIE       INTERRUPT CONTROL & COMMUNICATIONS         *\n*                                  SCOTT A SMITH - FALL 1971.         *\n*        THIS IS CALLED ONLY FROM THE MACRO EXPANSION OF $SPIE.  IT   *\n*        CONTAINS THE ONLY MACROS THAT CAUSE LINKAGE TO BE SET UP     *\n*        BETWEEN THE SUPERVISOR AND THE EXIT ROUTINE FOR INTERRUPT    *\n*        HANDLING.  THE INITIAL COMMUNICATIONS ARE NEVER MADE UNLESS  *\n*        AT LEAST ONE $SPIE IS EXPANDED.  ONLY ONE ACTUAL SUPERVISOR  *\n*        CALL IS NECESSARY.  ALL OTHER $SPIE EXPANSIONS JUST MANI-    *\n*        PULATE THE CONTROL BLOCKS GENERATED BY THAT EXPANSION.       *\n*        **NOTE**  XXXXSPIE CONTAINS THE ONLY OCCURENCES OF THE       *\n*        MACROS  SPIE (OS) OR STXIT (DOS)                             *\n*        NAMES:  XSP-----                                             *\n*                                                                     *\n*        THIS ENTRY HANDLES THE UPDATING OF THE POINTER TO THE        *\n*        ACTIVE XSPIEBLK .                                            *\n*        ENTRY CONDITIONS                                             *\n*   R1 = @ NEWLY CREATED ACTIVE XSPIEBLK (OR RESTORED XSPIEBLK)       *\n*   R14= RETURN ADDRESS                                               *\n*   R15= @ ENTRY POINT                                                *\n*        EXIT CONDITIONS                                              *\n*   R1 = @ LAST PREVIOUS ACTIVE XSPIEBLK                              *\n*      = 0 , IF NO PREVIOUS XSPIEBLK'S EXISTED                        *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nXXXXSPIE CSECT\n         $DBG  ,NO                 SHOW NO DEBUG CODE - $SAVE/$RETURN\n         USING XXXXSPIE,REP        SHOW OF ENTRY POINT REGISTER USING\n         L     R0,XSPACBLK         GET CURRENT XSPIEBLK @\n         ST    R1,XSPACBLK         SAVE THE NEW ACTIVE XSPIEBLK @\n         LR    R1,R0               RETURN PREVIOUS XSPIEBLK @\n         BR    RET                 ACTIVE XSPIEBLK PTRS CHANGED, RETURN\n         DROP  REP                 INFORM ASSEMBLER NO LONGER USING R15\n         SPACE 2\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> ENTRY: XXXXSPIN     INITIALIZATION OF INTERRUPT COMMUNICATIONS   *\n*        THE ONLY NECESSARY SPIE(OS) OR STXIT(DOS) IS EXECUTED HERE   *\n*        TO CATCH ALL INTERRUPTS AND TO REQUEST THE RETURN OF CONTROL *\n*        TO THE SAME EXIT ROUTINE HANDLER.  AS SUBSEQUENT $SPIE'S     *\n*        ARE ISSUED, NO SVC IS NEEDED; JUST AN ANALYSIS OF THE        *\n*        STATUS OF THE ACTIVE CONTROL BLOCK(XSPIEBLK) BY THE COMMON   *\n*        INTERRUPT EXIT ROUTINE.                                      *\n*        USES MACROS: SPIE(OS) OR STXIT(DOS),$SAVE,$RETURN            *\n*        ENTRY CONDITIONS                                             *\n*   R14= RETURN ADDRESS                                               *\n*   R15= @ ENTRY POINT                                                *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n         ENTRY XXXXSPIN\nXXXXSPIN $SAVE RGS=(R14-R12),SA=XSPYSAVE\n         XC    XSPACBLK,XSPACBLK   SET PREVIOUS XSPIEBLK PTR TO ZERO\n         AIF   (&$ASMLVL).XSPOS    SKIP IF WE ARE IN OS GENERATION\n         STXIT PC,XXXXSPEX,XSPYSAVE    CATCH ALL PROGRAM CHECKS\n.XSPOS   AIF   (NOT &$ASMLVL).XSPDOS   SKIP IF SET BY DOS GENERATION\n         SPIE  XXXXSPEX,((1,15))   CATCH ALL PROGRAM EXCEPTIONS\n.XSPDOS  ANOP\n         $RETURN RGS=(R14-R12)     RETURN AFTER ESTABLISHING COMMUNCTS\n         SPACE 2\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> INSUB: XXXXSPEX              INTERRUPT EXIT ROUTINE              *\n*        RECEIVES CONTROL FOR ALL INTERRUPTS, REGARDLESS OF @ ON      *\n*        MOST PREVIOUS $SPIE CALL.  XXXXSPEX MONITORS THE INTERRUPT   *\n*        HANDLING.  IT FIRST DETERMINES IF THIS PARTICULAR INTERRUPT  *\n*        WAS TO BE CAUGHT, SINCE ALL REAL INTERRUPTS WILL EFFEC-      *\n*        TIVELY BE NAILED.  IF IT WAS NOT TO BE CAUGHT, THEN CONTROL  *\n*        IS RETURNED TO THE SUPERVISOR TO REINITIALIZE EXECUTION      *\n*        WHERE IT WAS LEFT OFF.   ***NOTE***   IT MIGHT BE DESIRABLE  *\n*        TO INSERT CODE IN THIS CASE TO EITHER PRINT OUT A MESSAGE    *\n*        OR TO TAKE SOME OTHER ACTION.  THE CALLABLE EXIT(IF ANY) IS  *\n*        GIVEN CONTROL , BUT IT MUST RETURN CONTROL.  UPON RETURN     *\n*        THE PSW IS CHANGED (IF EXIT @ GIVEN) AND SUPERVISOR GETS CNTL*\n*        USES DSECTS: XSPIEBLK                                        *\n*        THIS ROUTINE PRESERVES THE CONTENTS OF R2-R12 FOR THE        *\n*        INSPECTION BY THE CALLABLE EXIT ROUTINE.                     *\n*        ENTRY CONDITIONS                                             *\n*   R1 = @ OF OS PIE BLOCK (*DOS*MOST LOAD @ INTRPT SAVEAREA(PSW)     *\n*   R14= RETURN ADDRESS                                               *\n*   R15= @ ENTRY POINT                                                *\n*        EXIT CONDITIONS                                              *\n*   R1 = @ OF OS PIE BLOCK OR @ OF DOS PSW & SAVE.  **NOTE** CALLABLE *\n*        EXIT ROUTINE MUST NOT CHANGE THE CONTENTS OF REGISTER #1     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n         AIF   (&$ASMLVL).XSPNBAL  SKIP IF UNDER OS GENERATION\nXXXXSPEX BALR  R15,0               ESTABLISH TEMP DOS ADDRESSABILITY\n         USING *,R15               INFORM OF USING\n         LA    R1,XSPYSAVE         GET DOS @ OF PSW & SAVE AREA\n.XSPNBAL AIF   (NOT &$ASMLVL).XSPADDR  SKIP IF UNDER DOS GENERATION\n         USING *,R15               SHOW OF ENTRY POINT REG USING\nXXXXSPEX LA    R1,4(R1)            GET R1 <- OS PSW IN PIEBLOCK\n.XSPADDR ANOP\n         STM   R13,R15,XSPSVRES    STORE THE REGISTERS\n         LA    R13,XSPYSAVE        @ OUR SAVE AREA, FOR SAFETY\n         L     R14,XSPACBLK        LOADS @ OF ACTIVE XSPIEBLK\n         USING XSPIEBLK,R14        DSECT USING FOR CONTROL BLOCK\n         LTR   R14,R14             SEE IF A $SPIE IS IN EFFECT\n         BZ    XSPNOSPY            NO SPIE WAS IN EFFECT AT PRESENT\n         L     R0,=X'80000000'     LOAD 1 BIT IN HIGH ORDER END\n         MVC   *+8(2),2(R1)        PLACE INT. # INTO L' NEXT INSTRUCTN\n         SRL   R0,$                GET BIT TO MASKABLE POSITION\n         N     R0,XSPINTRP         AND WITH INTERRUPT TYPES TO BE CAUGT\n         BZ    XSPNTCTH            THIS INTERRUPT WAS NOT TO BE CAUGHT\n         L     R0,XSPEXRTN         GET CALLABLE EXIT @\n         LTR   R0,R0               WAS ONE ACTUALLY SUPPLIED?\n         BZ    XSPNOCLX            IF NONE, THEN DON'T TRY TO CALL\n         LR    R15,R0              MOVE @ TO R15 FOR BALR, WATCH ADDRES\n         BALR  R14,R15             GO TO CALLABLE EXIT: MUST RETURN\n         USING *,R14               NOTE TEMP USING FOR REGAIN OF R15\n         L     R15,XSPSVRET+4      GET ORIGINAL ENTRY POINT ADDRESS\n         USING XSPIEBLK,R14        INFORM OF DSECT USING AGAIN\n         AIF   (&$ASMLVL).XSPNRES  SKIP REGISTER SAVE IF UNDER OS\n         SPACE\n*        UNDER DOS, REGS THAT WERE CHANGED BY CALLABLE EXIT MUST BE   *\n*        UPDATED IN SAVE AREA TO SHOW NEW VALUES OVER IN EXIT ROUTINE *\n         STM   R2,R12,XSPYSAVE+16  SAVE NEW VALUES FROM CALLABLE EXIT\n.XSPNRES ANOP\n         L     R14,XSPACBLK        REGAIN POINTER TO XSPIEBLK\nXSPNOCLX L     R0,XSPCLBEX         GET @ OF EXIT ROUTINE\n         LTR   R0,R0               WAS IT EVER SUPPLIED?\n         BZ    XSPIERTN            DON'T CALL, JUST RETURN\n         MVC   5(3,R1),XSPCLBAD    CHANGE THE PSW ADDRESS FIELD\n         B     XSPIERTN            GO TO RETURN TO SUPERVISOR\nXSPNTCTH EQU   *                   COME HERE IF NO SPIE SET\n******** AIF   (&$DEBUG).XXSPNBG   SKIP IF NOT DEBUG MODE\n         L     R14,=V(VWXTABL)     GET @ ASSEMBLER TABLE\n         USING AVWXTABL,R14        NOTE PTR THERE\n         XSNAP LABEL='ASSIST ABEND-SEND DECK TO SYSTEMS: 3-12; PSW,14-2#\n               ; AVTAB',STORAGE=(*0(R1),*28(R1),*AVADDLOW,*AVWXEND) CPP\n         DROP  R14                 ZAP TEMPORARY USING\n.XXSPNBG DC    H'0'                BOMB HERE WITH S0C1\nXSPNOSPY EQU   *                   MAY WISH TO PRINT A MSG.\nXSPIERTN DS    0H\n         L     R13,XSPSVRES        RELOAD CORRECT R13\n         AIF   (NOT &$ASMLVL).XSPRST        DON'T RESTORE R1 IF NOT OS\n         S     R1,=F'4'            RESTORE OS R1 TO POINT TO PIE BLOCK\n         L     R14,XSPSVRET        GET RETURN ADDRESS\n         BR    R14                 RETURN CONTROL TO SUPERVISOR\n.XSPRST  AIF   (&$ASMLVL).XSPNEXT  SKIP IF OS, SINCE NO EXIT PC\n         EXIT  PC                  RETURN CONTROL TO SUPERVISOR\n.XSPNEXT ANOP\nXSPACBLK DC    F'-1'               ACTIVE XSPIEBLK POINTER\nXSPYSAVE DC    18F'-1'             SAVEAREA FOR REGS & DOS INTERRUPTS\nXSPSVRES DC    F'-1'               FOR REG 13\nXSPSVRET DC    2F'-1'              FOR TEMP LOC. OF RET & REP REGS\n         LTORG\n         SPACE 2\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*--> DSECT: XSPIEBLK    INTERRUPT COMMUNICATIONS CONTROL BLOCK        *\n*        THIS BLOCK CONTAINS EXIT ADDRESSES AND INTERRUPT MASKS FOR   *\n*        USE IN HANDLING THE 15 PROGRAM EXCEPTIONS.  THE INTERRUPT    *\n*        MASK IS EXTENDED TO A FULLWORD FOR EASE OF TESTING AGAINST   *\n*        THE INTERRUPTS THAT WERE DESIRED TO BE TRAPPED.  THE EXIT    *\n*        ADDRESS IS OF LENGTH 3 FOR CHANGING THE PSW(ONLY 3 BYTE @    *\n*        LOCATION:  INSIDE $SPIE MACRO EXPANSION                      *\n*        GENERATION:  ONE XSPIEBLK IS GENERATED FOR EVERY $SPIE       *\n*            EXPANSION EXCEPT LINKAGE TERMINATION & RESTORATION       *\n*        NAMES:  XSP-----                                             *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nXSPIEBLK DSECT\nXSPCLBEX DS    C                   ALIGNMENT FOR VL3 PSW (@ PORTION)\nXSPCLBAD DS    VL3                 @ OF INTERRUPT EXIT ROUTINE\nXSPEXRTN DS    VL4                 @ OF CALLABLE EXIT ROUTINE\nXSPINTRP DS    BL2                 POSSIBLE INTERRUPT MASK BITS\n         DS    BL2'0'              TRAILING ZEROES FOR EASY TESTING\n         TITLE '*** BROPS2 - BASE REGISTER OPERATIONS - PASS 2 ***'\n**--> CSECT: BROPS2   2   ALL BASE REGISTER OPERATIONS - ALL PASS 2 . .\n*.       USES DSECTS: AVWXTABL                                        .\n*.       USES MACROS: $RETURN,$SAVE                                   .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nBROPS2   CSECT\n         $DBG  A0,SNAP\n         ENTRY BRINIT,BRUSIN,BRDROP,BRDISP\n         USING AVWXTABL,RAT        NOTE MAIN USING\n         SPACE 2\n**--> ENTRY: BRINIT   2   INITIALIZE BASE REGISTER TABLES . . . . . . .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nBRINIT   $SAVE SA=NO\n         MVC   BRVALS(4*16),AWZEROS         ZERO OUT VALUE /ID TABLE\n         $RETURN SA=NO\n         SPACE 2\n**--> ENTRY: BRUSIN   2   ENTER A REGISTER-VALUE PAIR . . . . . . . . .\n*.       ENTRY CONDITIONS                                             .\n*.  RA = NUMBER OF REGISTER FOR WHICH USING TO BE SET UP = 0-15       .\n*.  RB = ADDRESS DECLARED IN USING FOR GIVEN REGISTER = 0-2**24-1     .\n*.  RC = ESDID OF THE USING VALUE, IN LOW ORDER BYTE = 1-255          .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nBRUSIN   $SAVE SA=NO\n         SLL   RA,2                REG #*4 FOR FULLWORD INDEXING\n         ST    RB,BRVALS(RA)       STORE VALUE OF REG IN RIGHT SLOT\n         STC   RC,BRVALS(RA)       STORE ID IN HI-ORDER BYTE\n         $RETURN SA=NO\n         SPACE 2\n**--> ENTRY: BRDROP   2   DROP A REGISTER FROM USING. . . . . . . . . .\n*.       ENTRY CONDITIONS                                             .\n*.  RA = NUMBER OF REGISTER TO BE DROPPED FROM USING - = 0-15         .\n*.       EXIT CONDITIONS                                              .\n*.  RB = 0    THE REGISTER WAS CURRENTLY USABLE                       .\n*.  RB = ^0   THE REGISTER WAS NOT CURRENTLY IN USE                   .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nBRDROP   $SAVE SA=NO\n         SLL   RA,2                REG# * 4 FOR INDEX TO TABLE\n         LA    RB,BRVALS(RA)       SET RB^=0, @ WORD FOR DESIRED REG\n         CLI   0(RB),0             WAS THE REG IN USE\n         BE    BRDRRET             NO,BRANCH,LEAVING RB^=0-ERROR\n         MVI   0(RB),0             SET ID = 0, DEFINITELY DROPPING REG\n         SR    RB,RB               SET RB=0 TO SHOW OK\nBRDRRET  $RETURN SA=NO\n         EJECT\n**--> ENTRY: BRDISP   2   GIVEN VALUE&ESDID, RETURN BASE-DISPLACEMENT .\n*.       ENTRY CONDITIONS                                             .\n*.  RA = ADDRESS VALUE TO BE DECOMPOSED TO BASE-DISPLACEMENT (24 BITS).\n*.  RB = ESDID OF ADDRESS TO BE DECOMPOSED - LOW ORDER BYTE           .\n*.       VALUE IS FROM 1-255. 0 CAN BE USED TO MARK NONUSABLE.        .\n*.       EXIT CONDITIONS                                              .\n*.  RA = BASE-DISPLACEMENT FORM OF ADDRESS, IF ADDRESSABLE            .\n*.  RB = 0    NORMAL RETURN - ADDRESS WAS DECOMPOSABLE                .\n*.     = ^0   ADDRESSIBILITY ERROR(NO REG,OR DISP TOO LARGE)          .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nBRDISP   $SAVE RGS=R14,SA=NO\n         STC   RB,BRCESD+1         PLACE ESDID INTO CLI INSTRUCTION\n         SLL   RB,24               SHIFT ID TO HI-ORDER BYTE OF RB\n         ALR   RA,RB               PUT SECITON ID IN WITH VALUE\n         LM    RC,RE,BRRGSCDE      GET INITIAL VALUES FOR RC,RD,RE\n         SR    R14,R14             R14 = 0 ==> NO REGISTER FOUND YET\n         SPACE 1\n*              THE FOLLOWING LOOP EXECUTED 16 TIMES, CHECK EACH REG   *\nBRCESD   CLI   0(RC),$CHN          COMPARE INCOMING ESDID WITH 1 OLD\n         BNE   BRLOOP              IF NOT EQUAL,GO TO NEXT\n         CL    RA,0(,RC)           COMP INCOMING VALUE TO ONE IN USE RG\n         BL    BRLOOP              REGISTER HIGHER THAN ADDRESS-NO USE\n         CL    RB,0(,RC)           COMP PREVIOUS BEST REG TO NEXT ONE\n         BH    BRLOOP              IF PREVIOUS BEST > NEW, SKIP\n         L     RB,0(,RC)           GET NEW BEST ID/VALUE\n         LR    R14,RC              SAVE FOR INDEX TO BEST REG\nBRLOOP   BXLE  RC,RD,BRCESD        BUMP TO NEXT REG, GO BACK TO CHK\n         SPACE 1\n         S     R14,BRRGSCDE        S R14,=A(BRVALS) = 4* REG #, IF OK\n         BM    BRNOGOOD            IF R14 WAS =0, NO USABLE REG, BRANCH\n         SLR   RA,RB               COMPUTE DISPLACEMENT FOUND\n         C     RA,AWF4095          C RA,=F'4095' -MAKE SURE NOT BOG\n         BH    BRNOGOOD            JUMP IF ILLEGALLY BIG\n         SLL   R14,10              SHIFT REG NUMBER TO RIGHT SPOT\n         AR    RA,R14              PUT BASE AND SIP TOGETHER\n         SR    RB,RB               ZERO TO SHOW SUCCESSFUL COMPLETE\nBRRET    $RETURN RGS=R14,SA=NO\nBRNOGOOD LR    RB,RD               RB = 4 ==> ADDRESSIBLITY ERROR\n         B     BRRET               GO RETURN TO CALLER\n         SPACE 1\nBRRGSCDE DC    A(BRVALS,4,BRVALS+60)   2NDEX,INCREM,LIMIT-REGS RC,RD,RE\n* * * * * INTERNAL VARIABLES                                          *\n         DS    0D                  FOR ALIGNEMENT\nBRVALS   DS    16F                 TABLE OF USABLE VALUES IN REGS\n*              1ST BYTE OF EACH HAS ID, RESTS HAVE ADDRESS.\n         DROP  RAT,REP             CLEAN UP USING\n         TITLE '*** CACONS - A-TYPE CONSTANT PROCESSING ***'\n**--> CSECT: CACONS   1-2 PROCESS A-TYPE ADDRESS CONSTANTS. . . . . . .\n*.       USES DSECTS: AVWXTABL                                        .\n*.       USES MACROS: $CALL,$RETURN,$SAVE                             .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nCACONS   CSECT\n         $DBG  A0,SNAP\n         ENTRY CACON1,CACON2\n         USING AVWXTABL,RAT        NOTE MAIN USING\n         SPACE 2\n**--> ENTRY: CACON1     SCAN ACON, BUT DO NOT ASSEMBLE VALUE. . . . . .\n*.       ENTRY CONDITIONS                                             .\n*.  RA = SCAN POINTER (ADDRESS OF 1ST CHAR AFTER PREVIOUS DELIMETER)  .\n*.       EXIT CONDITIONS                                              .\n*.  RA = SCAN POINTER (ADDRESS OF DELIMITER STOPPING SCAN, OR ERROR)  .\n*.  RB = 0    CONSTANT WAS LEGAL, NO ERRORS                           .\n*.  RB = NONZERO  ==> ILLEGAL CONSTANT ($ERINVCN)                     .\n*.       CALLS SCANCO                                                 .\n*.       **NOTE** EXPRESSION ENDING IN  )  INSIDE MULTIPLE CONSTANT   .\n*.       WILL BE PROCESSED IMPROPERLY, SUCH AS  DC  A(B+(C),D)  .     .\n*.       THE CHARACTERS  C)  ARE TREATED AS END OF THE ACON.          .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nCACON1   $SAVE RGS=(R14-R1),BR=R1,SA=CACOSAVE\n         LR    R0,RA               SAVE ORIG SCAN POINTER\n         $CALL SCANCO              SCAN TO COMMA OR BLANK\n         LTR   RB,RB               WAS THERE ERROR\n         BNZ   CAC1RET             YES-ERROR-RETURN WITH IT\n         CR    R0,RA               WAS THERE A NULL CONSTANT\n         BE    CAC1ERR             YES-ERROR-BRANCH\n         SPACE 1\n         BCTR  RA,0                BACK UP SCAN PTR 1 BYTE\n         CLI   1(RA),C','          WAS SCAN STOPPER A COMMA\n         BNE   CAC1RET             NO, MUST BE END OF CONST: EXPR)\n         SPACE 1\n         CLI   0(RA),C')'          MAKE SURE THS IS RIGHT PAREN\n         BE    CAC1RET             SKIP IF SO\n         LA    RA,1(RA)            CONST ENDED WITH EXPR, RESET PTR=>,\n         B     CAC1RET             GO EXIT\nCAC1ERR LA     RB,$ERINVCN         NULL CONSTANT\nCAC1RET  $RETURN RGS=(R14-R1)\n         EJECT\n**--> ENTRY: CACON2   1-2 SCAN ACON, ASSEMBLE VALUE . . . . . . . . . .\n*.  RA = SCAN POINTER (ADDRESS OF 1ST CHAR AFTER PREVIOUS DELIMETER)  .\n*.  RB = LENGTH-1 OF 1 CONSTANT OF 1 OPERAND TO BE ASSEMBLED          .\n*.       EXIT CONDITIONS                                              .\n*.  RA = SCAN POINTER (ADDRESS OF DELIMITER STOPPING SCAN, OR ERROR)  .\n*.  RB = 0    CONSTANT WAS LEGAL, NO ERRORS                           .\n*.  RB = NONZERO VALUE - ERROR CODE (FROM EVALUT)                     .\n*.     = $ERRELOC  IF SECTION ID IS A DSECT, WHICH IS NOT ALLOWED.    .\n*.  RC = ADDRESS OF PROPERLY ASSEMBLED CONSTANT                       .\n*.  RD = ESDID OF CONSTANT, IF =0 ==> ABSOLUTE EXPRESSION             .\n*.       CALLS EVALUT                                                 .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nCACON2   $SAVE RGS=(R14-R0),BR=R13,SA=CACOSAVE\n         LR    R0,RB               SAVE THE LENGTH-1 FOR ASSEMBLY\n         $CALL EVALUT              CALL EXPRESSION EVALUATOR\n         LTR   RB,RB               WAS THERE ERROR\n         BNZ   CAC2RET             ERROR-RETURN\n*              CHECK TO MAKE SURE DON'T DC  A(DSECT SYMBOL)\n         STC   RD,AVFWORK1         STORE FOR TEST OF EVEN/ODD\n         TM    AVFWORK1,$ESDSECT   TEST FOR ODD\n         BZ    *+8                 NO, EVEN=> CSECT TYPE OR ABS TERM-OK\n         LA    RB,$ERRELOC         NO GOOD- FLAG ERROR-DSECT RELOC\n         ST    RC,AVCONBLD         STORE THE VALUE\n         LCR   RE,R0               GET NEGATIVE OF LENGTH-1 FOR ASSMBLY\n         LA    RC,AVCONBLD+3(RE)   GET REAL STARTING ADDRESS\nCAC2RET  $RETURN RGS=(R14-R0)\n         DROP  RAT,R1,R13\n         TITLE '*** CBCONS - SCAN AND/OR ASSEMBLE BINARY CONSTANTS ***'\n**--> CSECT: CBCONS   1-2 PROCESS BINARY CONSTANTS. . . . . . . . . . .\n*.       USES DSECTS: AVWXTABL                                        .\n*.       USES MACROS: $RETURN,$SAVE                                   .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nCBCONS   CSECT\n         $DBG  A0,SNAP\n         ENTRY CBCON1,CBCON2\n         USING AVWXTABL,RAT        NOTE MAIN TABLE USING\n         SPACE 2\n**--> ENTRY: CBCON1   1   SCAN B CONSTANT, DO NOT ASSEMBLE. . . . . . .\n*.       ENTRY CONDITIONS                                             .\n*.  RA = SCAN POINTER (ADDRESS OF 1ST CHAR AFTER PREVIOUS DELIMETER)  .\n*.       EXIT CONDITIONS                                              .\n*.  RA = SCAN POINTER (ADDRESS OF DELIMITER STOPPING SCAN, OR ERROR)  .\n*.  RB = 0    CONSTANT WAS LEGAL, NO ERRORS                           .\n*.  RB = NONZERO VALUE FOR ERROR CODE - INVALID CONSTANT - ($ERINVCN) .\n*.  RC = NUMBER OF BYTES REQUIRED FOR CONSTANT                        .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nCBCON1   $SAVE RGS=(R1-R2),SA=NO\n         MVC   AWTDECT+C'2'(8),AWBLANK      CAUSE 2-9 TO BE ^=0\n         SR    R1,R1               CLEAR SO TRT WORKSA RIGHT\n         TRT   0(256,RA),AWTDECT   MUST ENCOUNTER DELIMITER (3CRD LIM)\n         MVC   AWTDECT+C'2'(8),AWZEROS+C'2' REZERO TRT TABLE\n         LA    RC,7(R1)            MOVE ENDING PTR,ROUND UP\n         SR    RC,RA               GET # 0'S & 1'S,ROUNDED UP TO 8\n         LR    RA,R1               MOVE ENDING POINTER FOR RETURN\n         CLI   0(RA),C''''         WAS DELIMIER ' LIKE SUPPOSED TO\n         BNE   CB1ERR              NO, ERROR, INVALID DELIMITER\n         SRA   RC,3                DIVIDE BY 8, GET # BUTES REQUIRED\n         BZ    CB1ERR              IF 0, CONST WAS B'', ERROR,BRANCH\n         SR    RB,RB               SHOW NO ERROR\nCB1RET   $RETURN RGS=(R1-R2),SA=NO\n         SPACE 1\nCB1ERR   LA    RB,$ERINVCN         INVALID CONSTANT -SET FLAG FOR RETUR\n         B     CB1RET              GO RETURN, SHOWING ERROR\n         EJECT\n**--> ENTRY: CBCON2   1-2 ASSEMBLE BINARY CONSTANT. . . . . . . . . . .\n*.       ENTRY CONDITIONS                                             .\n*.  RA = SCAN POINTER (ADDRESS OF 1ST CHAR AFTER PREVIOUS DELIMETER)  .\n*.  RB = LENGTH-1 OF 1 CONSTANT OF 1 OPERAND TO BE ASSEMBLED          .\n*.       EXIT CONDITIONS                                              .\n*.  RA = SCAN POINTER (ADDRESS OF DELIMITER STOPPING SCAN, OR ERROR)  .\n*.  RC = ADDRESS OF PROPERLY ASSEMBLED CONSTANT                       .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nCBCON2   $SAVE RGS=(R0-R2),SA=NO\n         STC   RB,*+5              STORE LENGTH-1 INTO NEXT MVC\n         MVC   AVCONBLD($CHN),AWZEROS       ZERO OUT WHOLE AREA\n         SR    R1,R1               CLEAR FOR COMING TRT\n         L     RD,AWFM1            =F'-1' FOR DECREMENTING LATER\n         TRT   0(256,RA),AWTDECT   WE CHECKED IN PASS 1, LOOK FOR DLM\n         LA    RE,0(RD,RA)         GET LIMIT FOR BXH, @ 1ST ' OF CONST\n         LR    RA,R1               GET @  OF ENDING '\n         BXH   R1,RD,CB2L2         DECREM LAST PTR, ENTER LOOP RIGHT\n         SPACE 1\nCB2L1    BCT   R2,CB2L3            DECREMENT BIT POSITION POINTER,BRNCH\n         STC   R0,AVCONBLD(RB)     STORE ASSEMBLED BYTE INTO POSITION\n         AR    RB,RD               SUBTRACT 1 FROM BYTE COUNT\n         BM    CB2RETA             IF <0, WE ARE DONE, QUIT\n         SPACE 1\n*              INITIALIZATION - 1 TIME FOR EACH BYTE REQUIRED         *\nCB2L2    SR    R0,R0               CLEAR FOR BUILDING UP BYTE\n         LA    R2,8                # BITS IN 1 BYTE\n         LCR   RC,RD               RC = 1, FOR SHIFTING BIT TO ADD\n         SPACE 1\nCB2L3    CLI   0(R1),C'0'          IS NEXT CHAR A 0\n         BE    *+6                 SKIP ADDING BIT IN, IF SO\n         ALR   R0,RC               ADD 1 BIT IN IN RIGHT BIT POSITION\n         ALR   RC,RC               == SLL RC,1 - SHIFT 1 BIT OVER FOR N\n         BXH   R1,RD,CB2L1         DECREMENT POINTER, JUMP TO CHECK\n         SPACE 1\n         STC   R0,AVCONBLD(RB)     RAN OUT OF DIGITS, STORE THE BYTE\nCB2RETA  LA    RC,AVCONBLD         GET @ BEGINNING OF ASSEMBLED CONST\nCB2RET   $RETURN RGS=(R0-R2),SA=NO\n         DROP  RAT,REP             KILL USINGS\n         TITLE '*** CCCONS - SCAN AND/OR ASSEMBLE C-TYPE CONSTANTS ***'\n**--> CSECT: CCCONS   1-2 PROCESS CHARACTER TYPE CONSTANTS. . . . . . .\n*.       USES DSECTS: AVWXTABL                                        .\n*.       USES MACROS: $RETURN,$SAVE                                   .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nCCCONS   CSECT\n         $DBG  A0,SNAP\n         ENTRY CCCON1,CCCON2\n         USING AVWXTABL,RAT        NOTE MAIN TABLE USING\n         SPACE 2\n**--> ENTRY: CCCON1   1   SCAN,RETURN LENGTH,DO NOT ASSEMBLE. . . . . .\n*.       ENTRY CONDITIONS                                             .\n*.  RA = SCAN POINTER (ADDRESS OF 1ST CHAR AFTER PREVIOUS DELIMETER)  .\n*.       EXIT CONDITIONS                                              .\n*.  RA = SCAN POINTER (ADDRESS OF DELIMITER STOPPING SCAN, OR ERROR)  .\n*.  RB = 0    CONSTANT WAS LEGAL, NO ERRORS                           .\n*.  RB = NONZERO VALUE FOR ERROR CODE - INVALID CONSTANT - ($ERINVCN) .\n*.  RC = NUMBER OF BYTES REQUIRED FOR CONSTANT                        .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nCCCON1   $SAVE SA=NO\n         SR    RC,RC               INDEX FOR BXLE, WILL GO FROM 0==>255\n         LA    RD,1                INCREMENT FOR BXLE FOR LOOP\n         LA    RE,255              LIMIT=LENGTH OF MAXIMUM CONSTANT\n         SPACE 1\n*              INITIALIZATION DONE, NOW DO CHECKING LOOP              *\nCC1LOOP  CLI   0(RA),C''''         IS THE NEXT CHAR A '\n         BNE   CC1CHK2             NO, GO CHECK FOR & OR OTHER\n         CLI   1(RA),C''''         IS NEXT CHARACTER & '\n         BNE   CC1OUT              NO IT ISNT, MUST BE END OF CONSTANT\n         BXH   RA,RD,CC1LOOPA      BUMP SCAN POINTER 1 AND BRANCH\n         SPACE 1\nCC1CHK2  CLI   0(RA),C'&&'         IS CHAR AN &\n         BNE   CC1LOOPA            BRANCH IF NOT==> NORMAL CHARACTER\n         AR    RA,RD               INCREMENT TO 2ND &,HOPEFULLY\n         CLI   0(RA),C'&&'         MAKE SURE 2ND & IS THERE TOO\n         BNE   CC1ERR              ERROR IF IT ISNT-BRANCH\n         SPACE 1\nCC1LOOPA AR    RA,RD               INCREMENT POINTER TO NEXT CHAR\n         BXLE  RC,RD,CC1LOOP       CONTINUE LOOPING\n         SPACE 1\nCC1ERR   LA    RB,$ERINVCN         NOTE THIS IS AN INVALID CONSTANT\n         B     CC1RET              RETURN, WITH ERROR\n         SPACE 1\nCC1OUT   LTR   RC,RC               MAKE SURE LENGTH OF CONST>0\n         BZ    CC1ERR              NULL CONSTANT==>ERROR\n         SR    RB,RB               CLEAR TO SHOW LEGAL CONSTANT\nCC1RET   $RETURN SA=NO\n         EJECT\n**--> ENTRY: CCCON2   2   SCAN, ASSEMBLE. . . . . . . . . . . . . . . .\n*.       ENTRY CONDITIONS                                             .\n*.  RA = SCAN POINTER (ADDRESS OF 1ST CHAR AFTER PREVIOUS DELIMETER)  .\n*.  RB = LENGTH-1 OF 1 CONSTANT OF 1 OPERAND TO BE ASSEMBLED          .\n*.       EXIT CONDITIONS                                              .\n*.  RA = SCAN POINTER (ADDRESS OF DELIMITER STOPPING SCAN, OR ERROR)  .\n*.  RC = ADDRESS OF PROPERLY ASSEMBLED CONSTANT                       .\n*.  RD = LENGTH-1 OF CONSTANT (WAS IN RB ON ENTRY)              CPP\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nCCCON2   $SAVE SA=NO\n         LA    RD,1                FOR INCREMENT AND USEFUL CONST\n         SR    RE,RE               CLEAR FOR COUNTER\n*              **NOTE** BXH'S WORK OK SINCE RA>256 ALWAYS.\n         SPACE 1\nCC2LOOP  CLI   0(RA),C''''         IS CHAR A '\n         BNE   CC2CHK2             BRANCH IF IT ISN'T\n         CLI   1(RA),C''''         SEE IF NEXT 1 IS '\n         BNE   CC2PAD              BRANCH==>HIT END OF CONST,PAD NEEDED\n         BXH   RA,RD,CC2MOV        INCREMENT POINT TO 2ND '&JUMP\n         SPACE 1\nCC2CHK2  CLI   0(RA),C'&&'         IS CHAR AN &\n         BNE   CC2MOV              JUMP IF IT IS NORMAL CHARACTER\n         AR    RA,RD               INCREMENT TO POINT AT 2ND &\nCC2MOV   IC    RC,0(RA)            GET THE CHARACTER\n         STC   RC,AVCONBLD(RE)     SAVE THIS IN THE RIGHT PLACE IN CONS\n         AR    RE,RD               INCREMENT NUMBER OF BYTES DONE\n         BXH   RA,RD,CC2LOOP       INCREMENT AND JUMP BACK FOR NEXT\n         SPACE 1\nCC2PAD   LR    RD,RB               SAVE LENGTH-1 OF CONSTANT    CPP\n         SR    RB,RE               RE=LENGTH-1 OF PAD, IF ANY   CPP\n         BM    CC2RETA             IF <0, NO PAD REQUIRED, QUIT\n         LA    RE,AVCONBLD(RE)     RE=@ OF FIRST BYTE TO BLANK  CPP\n         STC   RB,*+5              STORE LENGTH INTO MVC\n         MVC   0($CHN,RE),AWBLANK  PAD--BLANK OUT ENOUGH        CPP\n         SPACE 1\nCC2RETA  LA    RC,AVCONBLD         POINT TO BEGINNING OF ASSEMBLED CONS\nCC2RET   $RETURN SA=NO\n         DROP  RAT,REP             CLEAN UP USING\n         TITLE '*** CDECNS - D AND E TYPE CONSTANT PROCESSING ***'\n**--> CSECT: CDECNS   1-2 PROCESS D&E TYPE CONSTS . . . . . . . . . . .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nCDECNS   CSECT\n         $DBG  A0,SNAP\n         USING AVWXTABL,RAT        NOTE MAIN TABLE USING\n         ENTRY CDECN1,CDECN2\n         SPACE 2\n**--> ENTRY: CDECN1   1   SCAN, BUT DO NOT ASSEMBLE D OR E TYPE CONSTS.\n*.       ENTRY CONDITIONS                                             .\n*.  RA = SCAN POINTER (ADDRESS OF 1ST CHAR AFTER PREVIOUS DELIMETER)  .\n*.       EXIT CONDITIONS                                              .\n*.  RA = SCAN POINTER (ADDRESS OF DELIMITER STOPPING SCAN, OR ERROR)  .\n*.  RB = 0    CONSTANT WAS LEGAL, NO ERRORS                           .\n*.  RB = NONZERO VALUE FOR ERROR CODE - INVALID CONSTANT - ($ERINVCN) .\n*.       CALLS CDECN2                                                 .\n*.       USES DSECTS: AVWXTABL                                        .\n*.       USES MACROS: $RETURN,$SAVE                                   .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nCDECN1   EQU   *                   USE SAMEENTRY AS CDECN2 FOR THIS\n         EJECT\n**--> ENTRY: CDECN2   1-2 SCAN,ASSEMBLE D&E TYPE CONSTANTS. . . . . . .\n*.       ENTRY CONDITIONS                                             .\n*.  RA = SCAN POINTER (ADDRESS OF 1ST CHAR AFTER PREVIOUS DELIMETER)  .\n*.  RB = LENGTH-1 OF 1 CONSTANT OF 1 OPERAND TO BE ASSEMBLED          .\n*.       EXIT CONDITIONS                                              .\n*.  RA = SCAN POINTER (ADDRESS OF DELIMITER STOPPING SCAN, OR ERROR)  .\n*.  RB = 0    CONSTANT WAS LEGAL, NO ERRORS                           .\n*.  RB = NONZERO VALUE FOR ERROR CODE - INVALID CONSTANT - ($ERINVCN) .\n*.  RC = ADDRESS OF PROPERLY ASSEMBLED CONSTANT                       .\n*.       CALLS SDDTRM                                                 .\n*.       USES DSECTS: AVWXTABL                                        .\n*.       USES MACROS: $CALL,$RETURN,$SAVE                             .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n         SPACE 1\n* * * * * REGISTER ALLOCATION - CDECN2  * * * * * * * * * * * * * * * *\n*   F0 = ACCUMULATOR FOR VALUE BUILT UP FOR CONSTANT                  *\n*   F2 = FLOATING POINT 10.0                                          *\n*   F4 = INITIALLY FLOATING POINT 10.0. MULTIPLIED BY 10 FOR FRACTION *\n*   F6 = FLOATING POINT WORK REGISTER                                 *\n*   RA = SCAN POINTER ADDRESS REGISTER, ADVANCED DURING SCAN          *\n*   RC = UNUSED CURRENTLY                                             *\n*   RD = UNUSED CURRENTLY                                             *\n*   RE = 1  USEFUL CONSTANT IN ODD REGISTER, USED FOR BXH'ING.        *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         AIF   (&$FLOTA AND &$FLOTM).CD2FULL  SKIP IF OK TO HAVE D&E\n*              RESTRICTED VERSION - IF NOT ACCEPTING FLOATING PT, OR\n*              NOT ON MACHINE, ASSEMBLE ONLY D'0'  OR E'0'.\nCDECN2   $SAVE SA=NO\n         CLI   0(RA),C'0'          WAS IT LEGAL ZERO\n         BNE   CD2INVCN            NO, BAD, WE ONLY ACCEPT 0\n         LA    RA,1(RA)            BUMP SCAN PTR 1\n         LA    RC,AWZEROS          SHOW @ 8 BYTES OF ZERO\n         SR    RB,RB               SHOW ACCEPTABLE\nCD2RET   $RETURN SA=NO             RETURN FROM SMALL MODULE\nCD2INVCN LA    RB,$ERINVCN         SHOW INVALID, WASN'T 0\n         B     CD2RET              RETURN WITH RROR\n         DROP  RAT,REP             AVWXTABL,ENTRY BASE\n         AGO   .CD2MINI            SKIP OVER REGULAR CODE\n.CD2FULL ANOP\n         SPACE 1\nCDECN2   $SAVE SA=CDE2SAVE,RGS=(R14-R15),BR=R13\n         MVI   CD2CON+1,X'F0'      MAKE NOOP TO BRANCH,INIT\n         MVI   CD2FTEST+1,0        INIT THIS TEST TO NOOP\n         LD    F0,AWD0             GET CONSTANT 0\n         LD    F2,AWD10            GET USEFUL CONSTANT 10\n         STD   F2,AVDWORK1         STORE VALUE WITH X'41' EXPONENT\n         MVI   CD2PERI+1,0         INIT . BRANCH TO NOOP\n         LDR   F4,F2               INIT F4 TO FLOATING PT 10 FOR DIVIDE\n         LA    RE,1                FOR BXHING AND OTHER INCREMNTING\n         MVI   CD2SIGN,X'20'       MAKE INST A LPDR-ASSUME + #\n         CLI   0(RA),C'0'          DO WE START WITH DIGIT\n         BNL   CD2DIG              YES,GO PROCESSES\n         CLI   0(RA),C'.'          DO WE HAVE . AT BEGINNING\n         BE    CD2PERI             GO THERE IF SO\n         CLI   0(RA),C'+'          DO WE HAVE +\n         BE    CD2INCA             YES,BUMP SCAN PTR,LEAVE SIGN OK\n         CLI   0(RA),C'-'          DO WE HAVE -\n         BNE   CD2INVCN            NO,MUST BE ERROR\n         MVI   CD2SIGN,X'21'       MAKE INST LNDR SINCE NEGATIVE SIGN\nCD2INCA  AR    RA,RE               BUMP SCAN PTR BEYOND SIGN\n         EJECT\n*              LOOP HEAD FOR SCANNING FOLLOWS.                        *\nCD2LOOP  CLI   0(RA),C'0'          DO WE HAVE DIGIT\n         BL    CD2NDIG             NO,BRANCH OUT\nCD2DIG   MVI   CD2CON+1,0          MAKE BRANCH NOOP,SHOW 1 DIGIT,AT LEA\n         UNPK  AVDWORK1+1(1),0(1,RA)   MOVE SWITCHED NIBBLES TO WORK\n         NI    AVDWORK1+1,X'F0'    REMOVE EXTRA NIBBLE AT END, LEAVE #\nCD2FTEST BC    $CHN,CD2LDIV        BRANCH OUT IF IN FRACTIONAL PART\n         MDR   F0,F2               MULT ACCUMULATED VALUE BY 10\n         AD    F0,AVDWORK1         ADD NEW VALUE INTO ACCUMUALTOR\n         BXH   RA,RE,CD2LOOP       BUMP SCAN POINTER, GO FOR NEXT\n         SPACE 1\nCD2LDIV  LD    F6,AVDWORK1         GET VALUE OF NEXT DIGIT\n         DDR   F6,F4               DIVIDE BY CURRENT POWER OF 10\n         MDR   F4,F2               RAISE POWER OF 10 IN F4 BY ANOTHER\n         ADR   F0,F6               ADD NEW VALUE IN\n         BXH   RA,RE,CD2LOOP       BUMP SCAN PTR, GET NEXT\n         SPACE 1\nCD2NDIG  CLI   0(RA),C'.'          IS IT PERIOD\n         BNE   CD2NOPR             NEITHER DIG NOR PERIOD\nCD2PERI  BC    $CHN,CD2INVCN       IF WE COME HERE 2 TIMES-GO TO ERROR\n         MVI   CD2PERI+1,X'F0'     MAKE NOOP A BRANCH TO ERROR\n         MVI   CD2FTEST+1,X'F0'    MAKE BRANCH-SHOW FRACTION NOW\n         BXH   RA,RE,CD2LOOP       BUMP SCAN PTR,GET NEXT\n         EJECT\n*              FOLLOWING SECTION SCANS FOR AN EXPONENT E AND SIGN\nCD2NOPR  CLI   0(RA),C'E'          WAS THIS EXPONENT INDICATOR\n         BNE   CD2DLM              NO,MUST BE DELIMITER\n         AR    RA,RE               BUMP SCAN PTR BEYOND E\n         MVI   CD2SIGNE,X'2C'      MAKE EXPONENT SIGN + (MDR INST)\n         CLI   0(RA),C'0'          IS NUMBER THERE\n         BNL   CD2EVAL             IF DECIMAL,GO EVALUATE\n         CLI   0(RA),C'+'          WAS THERE A + SIGN\n         BE    CD2INCB             YES,JUST BUMP SCAN PTR\n         CLI   0(RA),C'-'          WAS THERE - SIGN\n         BNE   CD2INVCN            NO,ERROR\n         MVI   CD2SIGNE,X'2D'      -EXPONENT, MAKE INST A DDR\nCD2INCB  AR    RA,RE               BUMP SCAN PTR BY 1\n         SPACE 1\n*              HAVE EXPONENT VALUE CONVERTED. ADJUST FRACTION BY IT.\nCD2EVAL  $CALL SDDTRM\n         LTR   RB,RB               WAS IT OK\n         BNZ   CD2INVCN            NO,ERROR\n         LTR   RC,RC               WAS EXPONENT 0\n         BZ    CD2CON              YES,DON'T DO ANYTHING\n*              THERE SHOULD BE SOME MAGNITUDE CHECKING HERE\nCD2SIGNE MDR   $CHN+F0,F2          **MODIFIED** MUL OR DIV,DEP ON SIGN\n         BCT   RC,CD2SIGNE         LOOP FOR REQUIRED AMOUNT\n         SPACE 1\n*              MAKE ENDING CHECKS, THEN RETURN TO CALLER.\nCD2DLM   CLI   0(RA),C''''         WAS THIS ' DELIMITER\n         BE    CD2CON              YES,OK\n         CLI   0(RA),C','          WAS IT , DELIM\n         BNE   CD2INVCN            INVALID DELIMITER\nCD2CON   BC    $CHN,CD2INVCN       BRANCH OUT IF NO FRACTIO ANYWHERE\nCD2SIGN  LPDR  $CHN+F0,F0          **MODIFIED** GET RIGHT SIGN\n         STD   F0,CD2CONB          SAVE THIS VALUE\n         LA    RC,CD2CONB          POINT TO THIS @\n         SR    RB,RB               SHOW OK\nCD2RET   $RETURN RGS=(R14-R15)\nCD2INVCN LA    RB,$ERINVCN         SHOW ERROR\n         B     CD2RET              RETURN\nCD2CONB  DS    D                   SPACE FOR SAVING CONSTANT\n         DROP  RAT,R13             KILL USINGS\n.CD2MINI ANOP\n         TITLE '*** CFHCNS - FULLWORD-HALFWORD FIXED CONSTANTS ***'\n**--> CSECT: CFHCNS   1-2 PROCESS FULLWORD-HALFWORD CONSTANTS . . . . .\n*.       USES DSECTS: AVWXTABL                                        .\n*.       USES MACROS: $RETURN,$SAVE                                   .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nCFHCNS   CSECT\n         $DBG  A0,SNAP\n         USING AVWXTABL,RAT        NOTE MAIN USING\n         ENTRY CFHCN1,CFHCN2\n         SPACE 2\n**--> ENTRY: CFHCN1   1   SCAN CONST, DO NOT ASSEMBLE . . . . . . . . .\n*.       ENTRY CONDITIONS                                             .\n*.  RA = SCAN POINTER (ADDRESS OF 1ST CHAR AFTER PREVIOUS DELIMETER)  .\n*.       EXIT CONDITIONS                                              .\n*.  RA = SCAN POINTER (ADDRESS OF DELIMITER STOPPING SCAN, OR ERROR)  .\n*.  RB = 0    CONSTANT WAS LEGAL, NO ERRORS                           .\n*.  RB = NONZERO VALUE FOR ERROR CODE - INVALID CONSTANT - ($ERINVCN) .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nCFHCN1   $SAVE RGS=(R1-R2),SA=NO\n         SPACE 1\n*              INITIALIZE, CHECK FOR LEADING SIGN.  **NOTE** THIS     *\n*        ROUTINE DOES NOT PERMIT DECIMAL POINTS INSIDE CONSTANTS.     *\n         SR    R1,R1               CLEAR FOR ADDRESS INSERT\n         CLI   0(RA),C'+'          PLUS SIGN CHECK\n         BE    CFH1INC             GO BUMP SCAN POINTER IF SO\n         CLI   0(RA),C'-'          MUST BE MINUS SIGN\n         BNE   CF1TRT              SKIP IF NOT ASIGN\nCFH1INC  LA    RA,1(RA)            INCR SCAN POINTER PAST + OR -\n         SPACE 1\n*              SCAN DECIMAL DIGITS, MAKE SURE THERE'S AT LEAST 1.\nCF1TRT   TRT   0(11,RA),AWTDECT    SCAN FOR DELIMITER\n         BZ    CFH1BIG             BRANCH IF TOO BIG\n         SR    R1,RA               GET NUMBER OF CHARS\n         BZ    CFH1INVC            NO DIGITS, SO INVLAID, LIKE F''\n         SPACE 1\n         AR    RA,R1               GET POINTER BACK\n         SR    RB,RB               CLEAR TO SHOW OK\nCFH1RET  $RETURN RGS=(R1-R2),SA=NO\n         SPACE 1\nCFH1INVC LA    RB,$ERINVCN         INVALID CONSTANT ERROR\n         B     CFH1RET             GO RETUN\nCFH1BIG  EQU   CFH1INVC            TOO BIG, USE JUST INVALID MESSAGE\n         EJECT\n**--> ENTRY: CFHCN2   2   ASSEMBLE F OR H CONST . . . . . . . . . . . .\n*.       ENTRY CONDITIONS                                             .\n*.  RA = SCAN POINTER (ADDRESS OF 1ST CHAR AFTER PREVIOUS DELIMETER)  .\n*.  RB = LENGTH-1 OF 1 CONSTANT OF 1 OPERAND TO BE ASSEMBLED          .\n*.       EXIT CONDITIONS                                              .\n*.  RA = SCAN POINTER (ADDRESS OF DELIMITER STOPPING SCAN, OR ERROR)  .\n*.  RB = 0    CONSTANT WAS LEGAL, NO ERRORS                           .\n*.  RB = NONZERO VALUE FOR ERROR CODE - INVALID CONSTANT - ($ERINVCN) .\n*.  RC = ADDRESS OF PROPERLY ASSEMBLED CONSTANT                       .\n*.       **NOTE** - THIS ROUTINE WILL ASSEMBLE VALUES INTO F OR H     *\n*.       CONSTANTS OF LENGTH 1-8, BUT THE VALUE OF ANY CONSTANT MUST  *\n*.       BE OF SIZE TO FIT INTO 1 FULLWORD, I.E. THE OTHER FULLWORD   *\n*.       MUST EITHER BE ALL 0'S OR ALL 1'S (BINARY).  .               *\n*.       **NOTE** IT IS POSSIBLE FOR THIS ROUTINE TO CAUSE A FIXED PT *\n*.       OVERFLOW, WHICH WILL CAUGHT AND LAGGED BY SPIE MONITOR IN    *\n*.       MAIN PROGRAM MPCON0.                                         *\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nCFHCN2   $SAVE RGS=(R1-R2),SA=NO\n         SPACE 1\n*              INITIALIZE.  CHECK SIGN, KAE CFH2SIG EITHR LR OR LCR.\n         SR    R1,R1               CLEAR FOR ADDRESS INSERTION\n         MVI   CFH2SIG+1,X'FF'     ASSUME + SIGN WILL OCCUR\n         CLI   0(RA),C'0'          IS THERE NO SIGN\n         BNL   CFH2TRT             NO SIGN-BRANCH\n         CLI   0(RA),C'+'          PLUS SIGN CHECK\n         BE    CFH2INC             BRANCH IF SO\n         MVI   CFH2SIG+1,X'FD'     SET TO SHOW MINUS\nCFH2INC  LA    RA,1(RA)            BUMP PAST SIGN\n         SPACE 1\n*              SCAN CONSTANT, CONVERT TO BIANRY FORM.\nCFH2TRT  TRT   0(11,RA),AWTDECT    GO FOR DELIMITER\n         SR    R1,RA               GET DIFFERENCE=#OF DIGITS\n         BCTR  R1,0                DECREMENT FOR LENGTH-1\n         EX    R1,CFH2PACK         PACK THE NUMBER\nCFH2SIG  NI    AVDWORK1+7,$        CHANGE SIGN TO SHOW + (F) OR - (D)\n         CVB   RD,AVDWORK1         CONVERT THE VALUE\n         SPACE 1\n*              GIVE CONSTANT RIGHT SIGN, STORE IT, POINT TO IT.\n         SRDA  RD,32               MAKE CONSTANT A DOUBLE WORD-\n         STM   RD,RE,AVCONBLD      STORE IN BUILDING AREA\n         LCR   RB,RB               MAKE LENGTH-1 NEGATIVE-GET OFFSET\n         LA    RC,AVCONBLD+7(RB)   GET START ADDR OF DESIRED CONST\n         SR    RB,RB               SHOW THE CONSTANT IS OK\n         LA    RA,1(R1,RA)         GET SCAN POINTER TO ENDING ' ,\nCFH2RET  $RETURN RGS=(R1-R2),SA=NO\n         SPACE 1\nCFH2PACK PACK  AVDWORK1,0(0,RA)    PACK DECIMAL STRING\n         DROP  RAT,REP             CLEAN UP USING\n         TITLE '*** CNDTL2 - CONSTANT PROCESSOR CONTROL - PASS 2 ***'\n**--> CSECT: CNDTL2   2   CONSTANT PROCESSOR CONTROL - PASS 2 . . . . .\n*.       ENTRY CONDITIONS                                             .\n*.  RB = NUMBER OF CONSTANT CONTROL BLOCKS TO BE PROCESSED            .\n*.  RC = ADDRESS OF FIRST OR ONLY CNCBLOCK TO BE DONE                 .\n*.       CALLS CACON2,CBCON2,CCCON2,CDECN2,CFHCN2,CPCON2,CVCON2,CXCON2.\n*.       CALLS CZCON2,ERRTAG,OUTPT2,UTPUT2                            .\n*.       USES DSECTS: AVWXTABL,CNCBLOCK                               .\n*.       USES MACROS: $ALIGR,$CALL,$GLOC,$GTAD,$RETURN,$SAVE          .\n*.       USES MACROS: $SCPT,$SLOC                                     .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nCNDTL2   CSECT\n         $DBG  A0,SNAP\n* * * * * REGISTER ALLOCATION AND USAGE FOR CNDTL2  * * * * * * * * * *\n*   R0 = # CONSTANTS REMAINING TO BE DONE IN CURRENT CNCBLOCK(CNCNUM) *\n*   R1 = LENGTH-1 OF CONSTANT(S) IN INDIVIDUAL OPERAND, (FROM CNCLEN) *\n*              ALSO USED AS BYTE REGISTER, 3 HI-ORD* BYTES=0          *\n*   R2 = DUPLICATION FACTOR FOR CONSTANT OPERAND ( FROM CNCDUP)       *\n*   RW = @ CURRENT CNCBLOCK BEING PROCESSED.                          *\n*   RX = @ AREA FOR BUILDING UP MULTIPLE CONSTANTS (AVCONBL2)         *\n*   RY = @ SPECIFIC CONSTANT PASS 2 ROUTINE                           *\n*   RZ = CURRENT TOTAL LENGTH OF ASSEMBLED CONSTANTS (MULTIPLE OPRNDS)*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n         USING AVWXTABL,RAT\n         $SAVE RGS=(R14-R6),BR=R13,SA=CNDTSAVE\n         SPACE 1\n*              INITIALIZEREGISTERS, COUNTERS.  ENTER CODE LOOP.\n         SR    R0,R0               CLEAR FOR INSERIONS\n         SR    R1,R1               CLEAR FOR INSERTIONS\n         LR    RW,RC               MOVE @ 1ST OR ONLY CNCBLOCK OVER\n         USING CNCBLOCK,RW         NOTE POINTER\n         MVC   CNDOCNT,AWHM1       =H'-1' = 6-1 OF BYTES FOR PRINTING\n         B     CNDAA1              ENTR RIGHT SPOT TO BEGIN\n         SPACE 1\n*              CNDA IS ENTERED 1 TIME FOR EACH OPERAND AFTER FIRST    *\nCNDA     LH    R15,CNCTOT          GET TOTAL LENGTH OF LAST CONSTANT\n         A     R15,AVLOCNTR        ADD LOCATION COUNTER\n         LA    RW,CNC$LEN(RW)      INCREMENT CNCBLOCK POINTER TO NEXT\n         TM    CNCTYP,$CNALN       DOES NEW OPERAND REQUIRE ALIGNMENT\n         BZ    CNDNOLN             NO,SKIP ALIGNING THE LOCCNTR\n         IC    R1,CNCLEN           GET L-1 OF CONST(NOTE R1 BYTE REG)\n         $ALIGR R15,(R1)           ALIGN LOCATION COUNTER\nCNDNOLN  $SLOC R15                 RESET LOCATION COUNTER\n         SPACE 1\n*              CNDAA1 IS ENTERED 1 TIME FOR EACH CNCBLOCK PROCESSED.  *\nCNDAA1   STH   RB,CND#CNCS         SAVE CURRENT # CNCBLOCKS TO BE DONE\nCNDAA    $SCPT RA,CNCSCAN          CONVERT OFFSET TO ACTUAL @ PTR\n         IC    R1,CNCTYP           GET TYPE BYTE\n         N     R1,AWF15            REMOVE LEADING BITS\n         IC    R1,AWCONADS(R1)     GET OFFSET TO PASS 1 CONSTANT SUBR\n         $GTAD RY,C$BASE+4(R1)     GET @ PASS 2 CONSTANT ROUTINE\n         IC    R0,CNCNUM           GET # OF CONSTANTS IN THIS OPERAND\n         IC    R1,CNCLEN           GET THE LENGTH-1 OF EACH CONSTANT\n         LA    RX,AVCONCAT         SET UP @ OF BUILDING AREA\n         SR    RZ,RZ               CLEAR THE TOTAL LENGTH BUILT UP\n         EJECT\n*              CNDBB ENTERED ONCE FOR EACH CONSTANT IN EACH OPERAND   *\nCNDBB    LR    RB,R1               MOVE LENGTH-1 OVER FOR CALL TO ROUTI\n         LR    REP,RY              MOVE @ ROUTINE OVER\n         BALR  RET,REP             CALL THE ROUTINE\n         TM    CNCTYP,$CNERR       SHOULD WE TEST RB FOR ERRORS\n         BZ    CNDNERR             SKIP IF NO TEST NEEDED\n         LTR   RB,RB               WAS THERE AN ERROR\n         BZ    CNDNERR             SKIP IF NO ERROR\n         SPACE 1\n*              ERROR FOUND IN PASS 2. FLAG IT,PRINT STMT, AND QUIT.   *\n         $CALL ERRTAG              HAVE ERROR FLAGGED\n         B     CNDRETA             RETURN TO CALLER\n         SPACE 1\nCNDNERR  EQU   *\n         LA    RE,0(RX,RZ)         GET @ WHERE NEXT CODE TO GO\n         LA    RZ,1(R1,RZ)         INCREM TOTAL LENGTH BY NEW AMOUNT\n         CLI   CNCNUM,1            WAS THERE ONLY 1 CONSTANT(LIKELY)\n         BE    CNDPRNT1            SKIP TO SIMPLE CASE IF SO\n         STC   R1,*+5              STORE L-1 INTO NEXT INST\n         MVC   0($CHN,RE),0(RC)    MOVE CODE OVER\n         LA    RA,1(RA)            BUMP THE SCAN POINTER TO NEXT OPERAN\n         BCT   R0,CNDBB            GO BACK FOR NEXT CONSTANT IN OPERAND\n         SPACE 1\n*              FALL THRU AFTER ASSEMBLING 2 OR MORE CONSTS IN 1 OPRND.*\n         LR    RC,RX               MOVE @ ASSEMBLED CONSTANT OVER\nCNDPRNT1 BCTR  RZ,0                DECREMENT TOTAL LENGTH TO L-1\n         LH    R2,CNCDUP           GET DUPLICATION FACTOR\n         LTR   R2,R2               TEST (MAX VAL FOR DUPL=X'7FFF')\n         BZ    CNDLOOP2            SKIP REST IF ZERO DUPLICATION FACTOR\n         SPACE 1\n*              ACCUMULATE ENOUGH BYTES FOR PRINTING, IF NOT ALREADY.  *\n         LH    RA,CNDOCNT          GET LENGTH-1 CUR\u00a2ENTLY READY\n         LA    R15,6               FOR COMPARISON A(D LIMIT VALUE\n         CR    RA,R15              IS THERE ENOUGH  ALREADY\n         BH    CNDUTPUT            BRANCH OUT IF ALREADY ENOUGH\n         SPACE 1\n         LA    R14,1               FOR BXLE INCREME(T\n         SR    RD,RD               INIT FOR INDEX I(TO ASSEMBLED CONT\n         LR    RE,R2               DUPLICATE DUPLIC\"ATION FACTOR,>0\n         B     CNDLC               ENTER LOOP APPRO&RIATELY\n         SPACE 1\n*              LOOP TO ACCUMULATE PRINTING CODE, 1 BYTE AT TIME.\nCNDLA    AR    RD,R14              INCREMENT WITHIN CONSTANT PTR TO NXT\n         CR    RD,RZ               HAVE WE REACHED END OF CONST\n         BNH   CNDLC               NO,KEEP GOING\n         SR    RD,RD               END OF CONST,CLEAR TO BEGIN AGAIN\n         SR    RE,R14              DECREMENT TEMPORARY DUPLICATION FAC\n         BNP   CNDLE               QUIT IF RUN OUT OF DUPLFAC\n         SPACE 1\nCNDLC    IC    RB,0(RD,RC)         GET 1 BYTE OF CONSTANT OPERAND\n         STC   RB,CNDOCOD+1(RA)    STORE FOR PRINTING\n         BXLE  RA,R14,CNDLA        LOOP UNTIL HAVE 8 BYTES OR RUN OUT\n         SPACE 1\nCNDLE    STH   RA,CNDOCNT          STORE BACK THE UPDATED PR COUNT\n         EJECT\n*              CALL UTPUT2 TO DUPLICATE AND LOAD OBJECT CODE          *\nCNDUTPUT EQU   *\n         LR    RE,R2               MOVE DUPLICATION FACTOR OVER\n         $GLOC RA                  GET LOCATION COUNTER FOR CODE\n         LR    RD,RZ               TOTAL L-1 OF CODE(NOT CNTING DUPL)\n         $CALL UTPUT2              HAVE OBJECT CODE LOADED,DUPLICATED\n         SPACE 1\n*              LOOP BACK FOR NEXT OPERAND, IF >1 WAS USED.\nCNDLOOP2 LH    RB,CND#CNCS         GET # CNCBLOCKS LEFT TO DO\n         BCT   RB,CNDA             GET NEXT OPERAND (UNLIKELY)\n         SPACE 1\nCNDRETA  EQU   *                   INSERT $DALLOCH CODE LATER\n         LA    RB,$OUCONS          SHOW WE WANT LOCATION COUNTER\n         LA    RC,CNDOCOD          GET @ OF CODE TO BE PRINTED\n         LH    RD,CNDOCNT          GET LENGTH-1 OF CONST TO PRINT\n         $CALL OUTPT2              HAVE STMT PRINTED\nCNDRET   $RETURN RGS=(R14-R6)\n         SPACE 1\n* * * * * INTERNAL VARIABLES                                          *\nCND#CNCS DS    H                   # CNCBLOCKS TO BE PROCESSED (U=1)\nCNDOCNT  DS    H                   FOR LENGTH-1 OF CODE TO PRINT\nCNDOCOD  DS    D                   AREA TO BUILD UP PRINTED CODE\n         DROP  RAT,R13,RW          KILL USINGS\n         TITLE '*** CODTL1 - SCAN DUPL FAC,TYPE,LENGTH,CONST-PASS1 ***'\n**--> CSECT: CODTL1   1   SCAN DUPFAC,TYPE,LENGTH-CALL C ROUTINES . . .\n*.       ENTRY CONDITIONS                                             .\n*.  RA = SCAN POINTER TO DUPLICATION FACTOR OR CONSTANT TYPE          .\n*.  RB = 0    CONSTANT IS IN A DEFINE STORAGE STMT                    .\n*.  RB = 4     CONSTANT IS IN A DC STATEMENT                          .\n*.  RB = 8     CONSTANT IS A LITERAL - (I.E. DUPLFAC ^= 0, DECIMALS)  .\n*.       EXIT CONDITIONS                                              .\n*.  RA = SCAN POINTER TO DELIMITER FOLLOWING CONSTANT                 .\n*.  RB = 0    LEGAL SPECIFICATION OF CONSTANT                         .\n*.  RB = NONZERO VALUE - ERROR CODE - ILLEGAL                         .\n*.  RC = ADDRESS OF A CONSTANT CONTROL BLOCK                          .\n*.  RE = TOTAL LENGTH OF OPERAND,INCLUDING MULTIPLE OPERANDS,IF ANY   .\n*.       CALLS CACON1,CBCON1,CCCON1,CDECN1,CFHCN1,CPCON1,CVCON1,CXCON1.\n*.       CALLS CZCON1,EVALUT,SDDTRM                                   .\n*.       USES DSECTS: AVWXTABL,CONBLK                                 .\n*.       USES MACROS: $CALL,$GTAD,$RETURN,$SAVE,$SCOF,CONG\n*        NOTE RESTRICTIONS - DUPLICATION FACTOR AND TOTAL LENGTH MUST *\n*        BOTH BE ABLE TO FIT IN HALFWORD EACH. LENGTH MAY BE GREATER  *\n*        THAN 256 FOR A DS,BUT LENGTH ATTRIBUTE WILL NOT BE CORRECT   *\n*.  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n         SPACE 1\nCODTL1   CSECT\n         $DBG  A0,SNAP\n* * * * * REGISTER ALLOCATION FOR CODTL1  * * * * * * * * * * * * * * *\n*   R0 = 0 ==> PROCESSING DS,  = 4 ==> PROCESSING DC STATEMENT.       *\n*      = 8 ==> LITERAL CONSTANT, I.E. REQUIRE DECIMAL MODIFIERS.      *\n*   R1 = 1         USED TO BUMP SCAN POINTER IN BXH'S,ETC.            *\n*   R2 = ADDRESS OF CONSTANT BLOCK ENTRY (CONBLK),AFTER TYPE FOUND    *\n*   RW = LENGTH-1 OF OPERAND BEING PROCESSED.IMPLIED OR SPECIFIED.    *\n*   RX = NUMBER OF CONSTANTS IN THE OPERAND                           *\n*   RY = DUPLICATION FACTOR OF THE OPERAND                            *\n*   RZ   USED AS LINK OR WORK REGISTER                                *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n         USING AVWXTABL,RAT        NOTE MAIN USING\n         $SAVE RGS=(R14-R6),BR=R13,SA=COSAVE\n         SPACE 1\n*              INITIALIZATION OF REGISTERS, CONSTANT BLOCK, FLAGS.\n         LR    R0,RB               SAVE R0=0==>DS,R0=4==>DC\n         SR    RB,RB               SHOW NO ERRORS AT BEGINNING\n         LA    R1,1                HANDY CONSTANT\n         LR    RY,R1               SET DEFAULT DUPLICATION FACTOR=1\n         LM    R2,R4,AWZEROS       ZERO POINTER REG,LENGTH,#OF CONSTS\n         STM   R2,R3,COBLK         ZERO OUT BLOCK\n         MVI   CODXLEN+1,0         INITIALIZE TO NO EXPLICIT LENGTH\n         SPACE 1\n*              BEGIN PROCESSING OF DUPLICATION FACTOR, IF PRESENT.\n         BAL   R14,CODNUM          GO GET DUPLICATION FACTOR\n         B     CODLOOK             NO DUPLICATION FACTOR,SKIP\n         SPACE 1\n*              DUPLICATION FACTOR EXPLICIT-CHECK IT,MOVE TO RY.       *\n         C     RC,AWFX7FFF         =XL4'7FFF' COMPARE TO MAX SIZE LEGAL\n         BH    CODEDUPL            BRANCH IF TOO BIG\n         LTR   RY,RC               MOVE FACTOR OVER AND TEST\n         BNZ   CODLOOK             BRANCH IF DEFINITELY LEGAL\n         C     R0,AWF7             0 DUPLICATION FACTOR, IS IT LITERL\n         BNL   CODEDUPL            BRANCH - 0 DUPLFAC IN LITERAL -ERROR\n         SPACE 1\n*              CHECK TYPE FOR LEGALITY. GET ADDR OF CONBLK ENTRY.     *\nCODLOOK  CLI   0(RA),C'A'          MAKE SURE LEGITAMATE\n         BL    CODERTYP            NO,IT IS AN ERROR\n         IC    R2,0(RA)            GET THE TYPE CODE\n         IC    R2,CODINXO(R2)      GET OFFSET INTO CONTABL ENTRIES\n         LTR   R2,R2               IS THE TYPE LEGAL\n         BZ    CODERTYP            NO,ERROR\n         SPACE 1\n         LA    R2,CONTAB1(R2)      GET ACTUAL ADDRESS OF RIGHT ENTRY\n         USING CONBLK,R2           NOTE DUMMY SECT FOR CONTABL ENTRY\n         MVC   COTYP,CONTYP        MOVE TYPE+FLAGS OVER\n         AR    RA,R1               INCREMENT SCAN POINT BEYOND TYPE\n         SPACE 1\n*              CHECK FOR EXPLICIT LENGTH SPECIFICATION,EVAL IT IF SO. *\n         CLI   0(RA),C'L'          IS THERE A LENGTH SPECIFICATION\n         BNE   CODEFAL             NO,USE DEFAULT LENGTH\n         EJECT\n*              LENGTH EXPLICITLY SUPPLIED - PROCESS IT,NOTE NO ALIGN. *\n         AR    RA,R1               INCREMENT SCAN POINTER TO BEYOND L\n         BAL   R14,CODNUM          GO GET LENGTH\n         B     CODINVD             INVALID DELIMITER OR SOMETHING\nCODEDL   LR    RW,RC               MOVE LENGTH OVER\n         SR    RW,R1               DECREMENT TO LENGTH-1\n         NI    COTYP,255-$CNALN    WIPE OUT ALIGNMENT FLAG,IF ANY\n         MVI   CODXLEN+1,X'F0'     MAKE NOP A BRANCH-EXPLICIT LENGTH\n         SPACE 1\n*              CHECK EXPLICIT LENGTH FOR BEEING IN RIGHT RANGE.\n         SR    RD,RD               CLEAR REG FOR INSERT\n         IC    RD,CONLLW           GET LOWEST LIMIT VALUE\n         CR    RW,RD               IS LENGTH TOO LOW\n         BL    CODLBAD             ILLEGAL LENGTH\n         IC    RD,CONLHI           GET HIGH LIMIT ON LENGTH-1\n         CR    RW,RD               COMPARE TO SEE IF HIGH\n         BNH   CODCONGO            THE LENGTH IS IN RANGE\n         LTR   R0,R0               IS THIS IN A DS\n         BNZ   CODEBIG             NO,IT IS DC, THEREFORE ILLEGAL\n         SPACE 1\n*              NOTE C & X DC'S MAY EXCEED NORMAL 256 LENGTH LIMIT.\n         CLI   CONTYP,$CNVLN+$CNC  IS IT C TYPE\n         BE    CODCONGO            YES,SO IT IS OK\n         CLI   CONTYP,$CNVLN+$CNX  IS IT HEX CONST\n         BE    CODCONGO            YES,SO ITS OK\n         B     CODEBIG             NO,IT IS TOO LARGE,SINCE NOT X OR C\n         SPACE 1\nCODEFAL  IC    RW,CONLEN           GET DEFALUT LENGTH-1\n*              HAVE GOTTEN DUPFAC-TYPE-LENGTH,NOW SCAN FOR CONSTANT.  *\nCODCONGO CLI   0(RA),C' '          CHECK,IS THIS THE END\n         BE    *+12                SKIP NEXT 2 INSTS==> NO OPERAND\n         CLI   0(RA),C','          CHECK FOR , AFTER LENGTH\n         BNE   CODOPR              NO,THERE'S STILL MORE\n         LTR   R0,R0               IF FIELD OMITTED,MUST BE DS\n         BNZ   CODEOMOP            OMITTED OPERAND IN DC==>ERROR\n         BXLE  RX,R1,CODFIN        SET # OEPRANDS = 1 AND BRANCH\n         SPACE 1\n*              GET ADDRESS OF APPROPRIATE PASS 1 CONSTANT SUB&CALL IT *\nCODOPR   CLC   0(1,RA),CONLD       IS THE LEFT DELIMITER OK\n         BNE   CODINVD             NO IT ISNT-BRANCH TO ERROR\n         AR    RA,R1               BUMP SCAN POINTER TO 1ST CHAR OF CON\n         IC    RD,CONTYP           GET TYPE VALUE\n         N     RD,AWFXF            =XL4'F' WIPE OUT FLAG BITS FROM NIBL\n         IC    RD,AWCONADS(RD)     GET OFFSET TO ADDR OF TYPE\n         $GTAD R0,C$BASE(RD)       GET @ PASS 1 ROUTINE - C#CON1\n         $SCOF R15,RA,COSCAN       GET THE OFFSET AND SAVE IT\n         EJECT\n*              CONSTANT TYPE KNOWN. CALL ROUTINE TO PROCESS IT.       *\nCODCALL  LR    REP,R0              MOVE ADDRESS OV ROUTIN OVER\n         BALR  RET,REP             CALL THE ROUTINE\n         LTR   RB,RB               WAS THERE AN ERROR\n         BNZ   CODRETA             YES,RETURN WITH THE RROR\n         AR    RX,R1               INCREMENT THE # OF OPERANDS\n         CLC   0(1,RA),CONRD       IS DELIM THE RIGHT DELIM\n         BE    CODCONA             YES,THIS IS END OF OPERAND\n*              THE FOLLOWING TAKES CARE OF MULTIPLE OPERANDS WHERE OK *\n         CLI   0(RA),C','          IS DELIMITER RIGHT\n         BNE   CODINVD             NO,IT IS BAD DELIMITER\n         TM    COTYP,$CNMUL        ARE MULTIPLE DELIMS ALLOWED\n         BZ    CODINVD             SKIP IF THEY AREN'T ERROR\n         BXH   RA,R1,CODCALL       BUMP SCAN POINTER AND CALL ROUTINE\n         SPACE 1\n*              HAVE PROCESSED WHOLE OPERAND. CHECK FOR OVERRIDE LENGTH*\nCODCONA  AR    RA,R1               INCREMENT SCAN POINTER\nCODXLEN  BC    $CHN,CODFIN         BRANCH IF LENGTH EXPLICIT,NOP IFNOT\n         TM    COTYP,$CNVLN        WAS LENGTH VARIABLE,ALLOWING OVERD\n         BZ    CODFIN              NO,LEAVE THE LENGTH ALONE\n         LR    RW,RC               MOVE THE RETURNED LENGTH OVER\n         SR    RW,R1               DECREMENT BY 1 TO GET CONSISTENT\n         SPACE 1\n*              STORE FLAGS INTO COBLK. COMPUTE TOTAL LENGTH INTO RE   *\nCODFIN   STC   RX,CONUM            STORE NUMBER OF OPERANDS\n         STC   RW,COLEN            SAVE THE LENGTH-1 OF OPERAND\n         LTR   RE,RY               MOVE OVER AND TEST DUPL FACTOR\n         BZ    CODRETA             YES,0 DUP FACTOR-0 EVERYTHING\n         STH   RY,CODUP            STORE A NONZERO DUPLICATION FACTOR\n         BAL   R14,*+6             SKIP 1ST AR AND GO TO BCTR\n         AR    RE,RY               ADD DUPLFAC TO SLEF\n         BCTR  RX,R14              LOOP ON NUMBER OF CONSTANTS IN OPRND\n*              DUPLICATION FACTOR * NUMBER OF OPERANDS IS IN RE       *\n         CR    RE,R1               IS DUP FAC*#OPERANDS =1\n         BNE   CODMULT             IF NOT,GIVE UP AND MULTIPLY\n         LA    RE,1(RW)            MOVE THE LENGTH OVER&ADD 1\n         B     CODSTOR             HAVE LENGTH SAVED AND QUIT\nCODMULT  AR    RW,R1               INCREMENT LENGTH-1 TO LENGTH\n         MR    RD,RW               MULTIPLY TO GET TOTL LENGTH\nCODSTOR  STH   RE,COTOT            SAVE THE TOTAL LENGTH\n         CL    RE,AWFX7FFF         MAKE SURE WHOLE LENGTH NOT TOO BIG\n         BH    CODEBIG             TOTAL LENGTH IS TOO BIG\n*              POINT AT THE COBLK AND RETURN                          *\nCODRETA  LA    RC,COBLK            SHOW ADDRESS OF OUR CODE BLOCK\nCODRET   $RETURN RGS=(R14-R6)\n         EJECT\n* * * * * CODNUM - CALLED TO EVALUATE DUPLICATION FACTOR OR LENGTH -  *\n*        RETURNS 0(R14) IF EXPRESSION OMITTED. RETURNS TO 4(R14) IF OK*\n*        RC HAS VALUE OF EXPRESSION                                   *\nCODNUM   LA    RZ,4(R14)           SET UP GOOD RETURN FOR SECTIONS\n         CLI   0(RA),C'0'          DO WE HAVE DECIMAL NUMBER\n         BNL   CODECAL             YES,DECIMAL NUMBER,GO CONVERT\n         CLI   0(RA),C'('          EITHER EXPRESSION,OR OMITTED\n         BCR   NE,R14              RETURN IF IT WAS OMITTED\n         SPACE 1\n*              IF FALLS THRU==>EXPRESSION,ENCLOSED IN PARENS. EVALUATE*\n         C     R0,AWF7             ARE WE IN LITERAL\n         BH    CODESYNT            YES, ILLEGAL DUPLFAC OR LENGTH\n         AR    RA,R1               BUMP SCAN POINTER PAST 1ST (\n         $CALL EVALUT\n         LTR   RB,RB               CHECK FOR ERROR\n         BNZ   CODRET              RETURN WITH ERROR CODE IF SO\n         LTR   RD,RD               WAS IT RELOCATABLE\n         BNZ   CODNEABS            RELOCATABLE RELOCATION FACTOR,ERROR\n         CLI   0(RA),C')'          SEE IF THIS WAS END\n         BNE   CODINVD             INVALID DELIMITER IF NOT\n         BXH   RA,R1,0(RZ)         INCREMENT SCAN POINTER PAST ) AND BR\n         SPACE 1\n*              DUPLFAC OR LENGTH WAS DECIMAL NUMBER. GET ITS VALUE    *\nCODECAL  $CALL SDDTRM              GET DECIMAL SELF-DEFINING TERM\n         LTR   RB,RB               WAS THERE AN ERROR\n         BCR   Z,RZ                RETURN IF THE NUM WAS OK\n         B     CODRET              RETURN WITH ERROR CODE IN RB\n         SPACE 1\n* * * * * INDIVIDUAL ERROR CODE SECTIONS                              *\nCODERTYP LA    RB,$ERCNTYP         UNKNOWN TYPE OF CONSTANT\n         B     CODRET              RETURN SHOWING ERROR\nCODEOMOP LA    RB,$ERNOOPR         MISSING OPERAND(CONSTANT)\n         B     CODRET              RETURN SHOWING ERROR\nCODEBIG  LA    RB,$EREXGTA         NUMBER OR EXPRESSION TOO LARGE\n         B     CODRET              RETURN SHOWING ERROR\nCODLBAD  LA    RB,$EREXLTA         NUMBER OR EXPRESSION TOO SMALL     P\n         B     CODRET              RETURN SHOWING ERROR\nCODINVD  LA    RB,$ERINVDM         INVALID DELIMITER\n         B     CODRET              RETURN,SHOWING ERROR CODE\nCODNEABS LA    RB,$ERNEABS         ABSOLUTE EXPRESSION REQUIRED\n         B     CODRET              RETURN\nCODESYNT LA    RB,$ERVSYNT         SYNTAX - ILLEGAL () IN LITERAL\n         B     CODRET              RETURN\nCODEDUPL LA    RB,$ERDUPLF         ILLEGAL DUPLICATION FACTOROR\n         B     CODRET              RETURN\n         EJECT\n* * * * * INTERNAL CONSTANTS                                          *\nCODINX   DC    XL(256-C'A')'0'     CONSTANT INDEX TABLE\nCODINXO  EQU   CODINX-C'A'            GET SYMBOL WITH OFFSET\nCONTABL  EQU   *                   BEGINNING OF CONSTANT DESCRIPTOR TAB\nCONTAB1  EQU   CONTABL-1           GET OFFSET SYMBOL SO OFFSETS NOT ZER\n         CONG  A,$CNALN+$CNMUL,4,LD='(',RD=')',HI=4\n         CONG  B,$CNVLN,1,HI=256,E=0\n         CONG  C,$CNVLN,1,HI=256,E=0\n         CONG  D,$CNALN+$CNMUL,8\n         CONG  E,$CNALN+$CNMUL,4\n         CONG  F,$CNALN+$CNMUL,4\n         CONG  H,$CNALN+$CNMUL,2\n         CONG  P,$CNVLN+$CNMUL,1,HI=16,E=0\n         CONG  V,$CNALN+$CNMUL,4,LD='(',RD=')',LW=3,HI=4\n         CONG  X,$CNVLN,1,HI=256,E=0\n         CONG  Z,$CNVLN+$CNMUL,1,HI=16,E=0\n         LTORG\n         SPACE 1\n* * * * * INTERNAL VARIABLES                                          *\n* * * * * COBLK AREA - SET UP LIKE CNCBLOCK FOR CONSTANT CODES        *\nCOBLK    DS    0D                  INTERNAL CONSTANT BLOCK LIKE CNCBLK\nCOTYP    DS    C                   TYPE + FLAGS\nCOLEN    DS    C                   LENGTH-1 OF CONSTANT OPERAND\nCOSCAN   DS    C                   SCAN POINTER OFFSET TO START OF CONS\nCONUM    DS    C                   NUMBER OF OPERANDS IN CONSTANT\nCODUP    DS    H                   DUPLICATION FACTOR\nCOTOT    DS    H                   TOTAL LENGTH OF CONSTANT\n         SPACE 1\n**--> DSECT: CONBLK     CONSTANT DESCRIPTOR CODES BLOCK(CODTL1) . . . .\n*.       THIS BLOCK CONTAINS DATA FOR A GIVEN CONSTANT TYPE, AND IS   .\n*.       USED BY ASSEMBLER SUBR. CODTL1 IN SCANNING CONSTANTS AND     .\n*.       BUILDING CNCBLOCKS DURING ASSEMBLY PASS 1.  THE DATA         .\n*.       GIVEN INCLUDES A FLAG BYTE, DEFAULT LENGTH-1, LEFT AND       .\n*.       RIGHT DELIMITER CHARACTERS REQUIRED FOR THE CONSTANT, AND    .\n*.       MINIMUM AND MAXIMUM VALUES FOR THE LENGTH-1 OF THE CONSTANT. .\n*.       THE FLAG BYTE, WITH MODIFICATIONS, BECOMES THE CNCTYPE BYTE  .\n*.       OF THE CNCBLOCK CREATED FOR EACH CONSTANT OPERAND.           .\n*.       LOCATION: TABLE CONTABL OF CSECT CODTL1                      .\n*.       GENERATION: 1 CALL TO MACRO CONG CREATES A CONBLK ENTRY.     .\n*.  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n         SPACE 1\nCONBLK   DSECT\nCONTYP   DS    C                   CONSTANT TYPE+ FLAGS\nCONLEN   DS    C                   DEFAULT LENGTH\nCONLD    DS    C                   LEFT DELIMITER\nCONRD    DS    C                   RIGHT DELIMITER\nCONLLW   DS    C                   LOWEST VALUE OF LENGTH-1\nCONLHI   DS    C                   HIGHEST VALUE OF LENGTH-1\n         DROP  RAT,R13,R2          CLEAN UP USING\n         TITLE '*** CPCONS - PACKED DECIMAL CONSTANTS ***'\n**--> CSECT: CPCONS   1-2 PROCESS PACKED CONSTANTS. . . . . . . . . . .\n*.       USES DSECTS: AVWXTABL                                        .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nCPCONS   CSECT\n         $DBG  A0,SNAP\n         ENTRY CPCON1,CPCON2       PASS 1 AND 2 ENTRIES\n         USING AVWXTABL,RAT        NOTE MAIN TABLE USING\n         SPACE 2\n**--> ENTRY: CPCON1   1   SCAN,DO NOT ASSEMBLE PACKED CONSTATNT . . . .\n*.       ENTRY CONDITIONS                                             .\n*.  RA = SCAN POINTER (ADDRESS OF 1ST CHAR AFTER PREVIOUS DELIMETER)  .\n*.       EXIT CONDITIONS                                              .\n*.  RA = SCAN POINTER (ADDRESS OF DELIMITER STOPPING SCAN, OR ERROR)  .\n*.  RB = 0    CONSTANT WAS LEGAL, NO ERRORS                           .\n*.  RB = NONZERO VALUE FOR ERROR CODE - INVALID CONSTANT - ($ERINVCN) .\n*.  RC = NUMBER OF BYTES REQUIRED FOR CONSTANT                        .\n*.       USES MACROS: $RETURN,$SAVE                                   .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nCPCON1   $SAVE SA=NO\n         SR    RC,RC               CLEAR FOR USE AS FLAG\n         LA    RD,32               (MAX # DIGITS IN CONST) + 1 AS LIMIT\n         LA    RE,1                FOR INCREMENTING AND DECREMENTING\n         CLI   0(RA),C'+'          IS THERE A + SIGN NEXT\n         BE    CP1LOOP             YES,BRANCH TO INCREMENT SCAN PTR\n         CLI   0(RA),C'-'          IS IT - SIGN\n         BNE   *+6                 SKIP BUMPING SCAN PTR IF SO\n         SPACE 1\nCP1LOOP  AR    RA,RE               BUMP SCAN POINTER BY 1\n         CLI   0(RA),C'0'          IS NEXT CHAR A DIGIT\n         BL    CP1NODIG            BRANCH IF NOT - SOME PUNCTUATION\n         BCT   RD,CP1LOOP          DIGIT-DECREMENT LIMIT COUNTER,BRANCH\n         B     CP1INVCN            INVALID (TOO LONG)\n         SPACE 1\nCP1NODIG CLI   0(RA),C'.'          WAS NON-DIGIT A PERIOD\n         BNE   CP1QUOT             NO,MUST BE ENDING ' OR ,\n         BXLE  RC,RE,CP1LOOP       SET RC=1, BRANCH BACK IF 1ST TIME\nCP1INVCN LA    RB,$ERINVCN         2 PERIODS, OR OTHER ERROR\n         B     CP1RET              GO RETURN WITH ERROR MESSAGE\n         SPACE 1\nCP1QUOT  CLI   0(RA),C''''         WAS ENDING MARK A QUOT\n         BE    CP1DONE             YES,OK,BRANCH\n         CLI   0(RA),C','          WERE MULTIPLE OPS USED\n         BNE   CP1INVCN            INVALID (PROBABLY DELIMITER)\n         SPACE 1\nCP1DONE  SR    RB,RB               SHOW NO ERRRORS\n         LA    RC,32               (MAX # DIGITS + 1) FOR SUBTRCT\n         SR    RC,RD               SUBTRACT COUNTER = ACTUAL # DIGITS\n         BZ    CP1INVCN            IF 0 DIGITS, QUIT - NULL CONTSNAT\n         SRA   RC,1                SHIFT TO GET # OF BYTES REQUIRED\n         AR    RC,RE               HAD # BYTES - 1, NOW GET # BYTES\nCP1RET   $RETURN SA=NO\n         EJECT\n**--> ENTRY: CPCON2   1-2 SCAN AND ASSEMBLE P TYPE CONSTANT . . . . . .\n*.       ENTRY CONDITIONS                                             .\n*.  RA = SCAN POINTER (ADDRESS OF 1ST CHAR AFTER PREVIOUS DELIMETER)  .\n*.  RB = LENGTH-1 OF 1 CONSTANT OF 1 OPERAND TO BE ASSEMBLED          .\n*.       EXIT CONDITIONS                                              .\n*.  RA = SCAN POINTER TO DELIMITER ENDING SCAN                        .\n*.  RC = ADDRESS OF PROPERLY ASSEMBLED CONSTANT                       .\n*.       USES MACROS: $RETURN,$SAVE,$SETRT                            .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nCPCON2   $SAVE RGS=(R1-R2),SA=NO\n         MVC   AVCONBLD(16),AWZEROS         ZERO OUT WORK AREA\n         LA    RC,AVCONBLD(RB)     @ LAST BYTE OF ASSEMBLED CONSTANT\n         LA    RE,1                FOR INCREMENTING,DECREMENTING\n         AR    RB,RE               RB = ACTUAL # OF BYTES DESIRED\n         SR    R1,R1               CLEAR FOR INSERTION OF ADDRESS\n         $SETRT ('''',1,',',1)     SET UP TABLE FOR SCANNING\n         TRT   1(32,RA),AWTZTAB    SIGN+PERIOD+31 DIGS-1 = 32 MAX LEN\n         $SETRT ('''',0,',',0)     RESET TABLE TO ZEROS\n         MVI   CP2BRNCH+1,0        MAKE BRANCH A NOOP INITIALLY\n         LA    RD,X'F0'            MASK FOR REMOVING ZONE NIBBLES\n         MVI   0(RC),X'C'          INIT SIGN TO A PLUS SIGN\n         CLI   0(RA),C'+'          WAS PLUS THERE\n         BE    CP2LOAD             YES,SKIP\n         CLI   0(RA),C'-'          WAS MINUS THERE\n         BNE   CP2LOAD             NO,MUST BE DIGIT OR PERIOD\n         MVI   0(RC),X'D'          PLACE DECIMAL MINUS SIGN IN CONST\nCP2LOAD  LR    RA,R1               DUPLICATE @ ENDING PUNCTUATION\n         SR    R1,RE               BACK POINTER UP TO LAST DIG IN CONST\n         SPACE 1\nCP2NUMBR CLI   0(R1),C'0'          ARE WE LOOKING AT DIGIT\n         BL    CP2NODIG            NOT DIGIT-BRANCH\n         IC    R2,0(R1)            GET THE DIGIT\nCP2BRNCH BC    $CHN,CP2EVEN        COMMUTATOR - B(EVEN) NOOP(ODD)\n         SLL   R2,4                ODD DIGIT - GET INTO LEFT NIBBLE\n         STC   R2,*+5              PLACE INTO OI INSTRUCTION FOLLOWING\n         OI    0(RC),$CHN          WILL OR IN 1 NIBBLE TO CONSTANT\n         SR    RC,RE               BACK POINTER UP,HAVE FINISHED THIS 1\n         BCT   RB,CP2FLIP          DECREMENT COUNTER,BRANCH IF MORE\n         B     CP2RETA             HAVE DONE REQUIRED # - NOW RETURN\n         SPACE 1\nCP2EVEN  SLR   R2,RD               REMOVE THE ZONE NIBBLE FROM DIGIT\n         STC   R2,0(RC)            STORE THE NUMERIC INTO CONSTNT\nCP2FLIP  XI    CP2BRNCH+1,X'F0'    FLIP COMMUTATOR SWITCH/EVEN/ODD\nCP2DECR  BCT   R1,CP2NUMBR         DECREM SCN PTR, BRANCH ALWAYS\n         SPACE 1\nCP2NODIG CLI   0(R1),C'.'          WAS NON-DGIT THE PERIOD\n         BE    CP2DECR             YES,DECREM SCAN PTR AND GET NEXT\n         SPACE 1\nCP2RETA  LA    RC,AVCONBLD         SHOW @ OF CONSTT,WITH L-PAD ZEROS\nCP2RET   $RETURN SA=NO,RGS=(R1-R2)\n         DROP  RAT,REP             KILL USINGS\n         TITLE '*** CVCONS - V-TYPE ADDRESS CONSTANT PROCESSING ***'\n**--> CSECT: CVCONS   1-2 PROCESS V-TYPE ADCONS . . . . . . . . . . . .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nCVCONS   CSECT\n         $DBG  A0,SNAP\n         USING AVWXTABL,RAT        NOTE MAIN USING\n         ENTRY CVCON1,CVCON2\n         SPACE 2\n**--> ENTRY: CVCON1   1   SCAN V-TYPE CONST, NO ASSEMBLE. . . . . . . .\n*.       ENTRY CONDITIONS                                             .\n*.  RA = SCAN POINTER (ADDRESS OF 1ST CHAR AFTER PREVIOUS DELIMETER)  .\n*.       EXIT CONDITIONS                                              .\n*.  RA = SCAN POINTER (ADDRESS OF 1ST CHAR AFTER PREVIOUS DELIMETER)  .\n*.  RB = 0    CONSTANT WAS LEGAL, NO ERRORS                           .\n*.  RB = NONZERO VALUE - ILLEGAL SYMBOL ($ERINVSY)                    .\n*.       USES DSECTS: AVWXTABL                                        .\n*.       USES MACROS: $RETURN,$SAVE                                   .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nCVCON1   $SAVE RGS=(R1-R2),SA=NO\n         SR    R1,R1               CLEAR FOR ADDRESS INSERT\n         TRT   0(9,RA),AWTSYMT     SCAN FOR SYMBOL DELIMITER\n         BZ    CVC1ERR             ERROR IF NOT FOUND\n         CLI   0(RA),C'0'          IS 1ST CHAR LETTER\n         BNL   CVC1ERR             NO-ERROR BRANCH\n         CR    R1,RA               MAKE SURE NOT NULL\n         BE    CVC1ERR             NULL ERROR-BRANCH\n         SR    RB,RB               SHOW OK\n         LR    RA,R1               MOVE SCAN POINTER OVER\nCVC1RET  $RETURN RGS=(R1-R2),SA=NO\nCVC1ERR LA     RB,$ERINVSY         INVALID SYMBOL\n         B     CVC1RET             RETURN\n         EJECT\n**--> ENTRY: CVCON2   2   SCAN&ASSEMBLE VCON. . . . . . . . . . . . . .\n*.       ENTRY CONDITIONS                                             .\n*.  RA = SCAN POINTER TO FIRST CHARACTER OF VCON.                     .\n*.       EXIT CONDITIONS                                              .\n*.  RA = SCAN POINTER (ADDRESS OF DELIMITER STOPPING SCAN, OR ERROR)  .\n*.  RB = 0 ==> NO ERRORS, NONZERO ==> ERROR CODE                      .\n*.     = NONZERO ERROR CODE ($ERUNRV  OR  $ERRELOC).                  .\n*.  RC = ADDRESS OF PROPERLY ASSEMBLED CONSTANT                       .\n*.       CALLS SYFIND                                                 .\n*.       CALLS RESYMB (ONLY IF &$REPL=2 AND EXTRN SYMBOL USED).       .\n*.       USES DSECTS: AVWXTABL,SYMSECT                                .\n*.       USES MACROS: $CALL,$RETURN,$SAVE                             .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nCVCON2   $SAVE RGS=(R14-R2),BR=R13,SA=CVCOSAVE\n         LR    R0,RB               SAVE LENGTH-1 OF SSEMBLY\n         SR    R1,R1               CLEAR FOR ADDRESS INSERT\n         TRT   0(9,RA),AWTSYMT     SCAN SYMBOL\n         LR    RB,R1               MOVE SCAN POINTER TO END BACK\n         SR    RB,RA               GET LENGTH OF SYMBOL\n         $CALL SYFIND              LOOK UP SYMBOL\n         LTR   RB,RB               WAS IT FOUND\n         BNZ   CVCONUNR            UNRESOLVED REFERENCE\n         SPACE 1\n         USING SYMSECT,RA          NOTE USING\n         AIF   (&$REPL LT 2).CVNREPL        SKIP IF NO REPL CALLS\n         TM    SYFLAGS,$SYEXT      WAS IT FLAGGED EXTRN\n         BZ    CVC2NOEX            NO, SO SKIP CALLING CODE\n         L     R15,CVRESYMB        GET  =V(RESYMB)\n         BALR  R14,R15             CALL HIM\n         LTR   RB,RB               WAS NAME LEGITAMATE\n         BZ    CVC2VAL             YES, RESYMB PUT VALUE INTO TABLE\n         B     CVCONUNR            NO, SO EXTRN, THUS UNRESOLVED\nCVRESYMB DC    V(RESYMB)           SYMBOL CHECKING MODULE\nCVC2NOEX EQU   *                   BRANCH HERE IF NOT EXTRN SYMBOL\n.CVNREPL ANOP\n         SPACE 1\n         TM    SYFLAGS,$SYDEF      IS IT DEFINED\n         BZ    CVCONUNR            NO, UNDEFINED, UNRESOLVED\n         TM    SYFLAGS,$SYENT+$SYCSE         IS IT EITHER CSECT OR ENTR\n         BZ    CVCONUNR            NO-ERROR\n*              CHECK TO SEE IF SYMBOL WAS A DSECT SYMBOL.\n         TM    SYESDID,$ESDSECT    WAS IT A DSECT\n         BZ    CVC2VAL             NO, OK, BRANCH\n         LA    RB,$ERRELOC         SHOW ERROR NOT ALLOWED\n         B     CVC2RETA            EXIT WITH ERROR\nCVC2VAL  LCR   RE,R0               NEGATIVE OF LENGTH-1 FOR OFFSET\n         LA    RC,SYVALUE+3(RE)    GET ACTUAL STARTIN @ OF CONSTANT\n         SPACE 1\nCVC2RETA LR    RA,R1               MOVE SCAN POINTER BACK\nCVC2RET  $RETURN RGS=(R14-R2)\nCVCONUNR LA    RB,$ERUNRV          UNRESOLVED EXTERNAL REFERENCE\n         B     CVC2RETA            RETURN\n         DROP  RAT,RA,R13                   REMOVE USINGS\n         TITLE '*** CXCONS - SCAN AND/OR ASSEMBLE HEX CONSTANTS ***'\n**--> CSECT: CXCONS   1-2 PROCESS HEXADECIMAL CONSTANTS . . . . . . . .\n*.       USES DSECTS: AVWXTABL                                        .\n*.       USES MACROS: $RETURN,$SAVE                                   .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nCXCONS   CSECT\n         $DBG  A0,SNAP\n         ENTRY CXCON1,CXCON2\n         USING AVWXTABL,RAT        NOTE MAIN TABLE USING\n         SPACE 2\n**--> ENTRY: CXCON1   1   SCAN HEX CONST, DO NOT ASSEMBLE . . . . . . .\n*.       ENTRY CONDITIONS                                             .\n*.  RA = SCAN POINTER (ADDRESS OF 1ST CHAR AFTER PREVIOUS DELIMETER)  .\n*.       EXIT CONDITIONS                                              .\n*.  RA = SCAN POINTER (ADDRESS OF DELIMITER STOPPING SCAN, OR ERROR)  .\n*.  RB = 0    CONSTANT WAS LEGAL, NO ERRORS                           .\n*.  RB = NONZERO VALUE FOR ERROR CODE - INVALID CONSTANT - ($ERINVCN) .\n*.  RC = NUMBER OF BYTES REQUIRED FOR CONSTANT                        .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nCXCON1   $SAVE RGS=(R1-R2),SA=NO\n         SR    R1,R1               CLEAR FOR INSERTION OF ADDRESS HERE\n         TRT   0(256,RA),AWTHEXT   SCAN AND CHECL CHARACTERS\n         CLI   0(R1),C''''         DELIMITER MUST BE A '\n         BNE   CX1ERR              IF NOT,IT IS ERROR\n         LA    RC,1(R1)            GET END POINTER +1\n         SR    RC,RA               GET # OF HEX DIGITS+1\n         SRA   RC,1                DIVIDE BY 2 FOR NUMBER OF BYTES\n         BZ    CX1ERR              NULL CONST==> ERROR BRANCH\n         SR    RB,RB               CLEAR REG TO SHOW A LEGAL CONST\nCX1RETA  LR    RA,R1               GET SCAN POINTER OVER\nCX1RET   $RETURN RGS=(R1-R2),SA=NO\nCX1ERR   LA    RB,$ERINVCN         INVALID CONST (OR ILLEGAL DELIM)\n         B     CX1RETA             GO RETURN\n         EJECT\n**--> ENTRY: CXCON2   1-2 ASSEMBLE HEX CONSTANT . . . . . . . . . . . .\n*.       ENTRY CONDITIONS                                             .\n*.  RA = SCAN POINTER (ADDRESS OF 1ST CHAR AFTER PREVIOUS DELIMETER)  .\n*.  RB = LENGTH-1 OF 1 CONSTANT OF 1 OPERAND TO BE ASSEMBLED          .\n*.       EXIT CONDITIONS                                              .\n*.  RA = SCAN POINTER (ADDRESS OF DELIMITER STOPPING SCAN, OR ERROR)  .\n*.  RC = ADDRESS OF PROPERLY ASSEMBLED CONSTANT                       .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nCXCON2   $SAVE RGS=(R0-R2),SA=NO\n         SR    R1,R1               CLEAR FOR TRT\n         SR    R2,R2               CLEAR FOR LATER INSERTS\n         STC   RB,*+5              STORE LENGTH-1 INTO MVC\n         MVC   AVCONBLD($CHN),AWZEROS       ZERO, IN CASE PADDING\n         L     RC,AWFM1            GET =F'-1' FOR DECREMENT\n         TRT   0(256,RA),AWTHEXT   SCAN FOR ENDING '\n         MVI   CX2EVOD+1,X'F0'     SET UP BRANCH FOR ODD 1ST TIME\n         LA    RD,0(RC,R1)         GET @ LAST DIGIT OF CONST\n         SR    RD,RA               GET NUMBER OF HEX DIGITS IN CONST\n         SPACE 1\nCX2HGET  IC    R2,0(RD,RA)         GET THE NEXT HEX DIGIT\nCX2EVOD  BC    $CHN,CX2ODD         BRANCH IF ODD (FROM RIGHT END)\n         IC    RE,AWTHEX2(R2)      GET VALUE OF THE BYTE\n         SLL   RE,4                SHIFT IT OVER\n         ALR   RE,R0               ADD ODD BYTE TO THE EVEN ONE\n         STC   RE,AVCONBLD(RB)     STORE COMPLETED BYTE IN PLACE\n         BXH   RB,RC,CX2FLIP       DECREMENT REMAIN COUNT\n         B     CX2RETA             BRANCH IF EXACT OR TRUNCATION      P\n         SPACE\nCX2ODD   IC    R0,AWTHEX2(R2)      GET THE VALUE OF THE DIGIT\nCX2FLIP  XI    CX2EVOD+1,X'F0'     SWITH B ODD, NOOP EVEN & VICE VRSA\n         BXH   RD,RC,CX2HGET       DECREMENT DIGITS REAMINING,LOOP\n         SPACE 1\n*              FALLS THRU ==> MAY BE ODD # DIGITS,STORE LAST IF SO    *\n         CLI   CX2EVOD+1,X'F0'     WAS LAST DIGIT DONE AN EVEN ONE\n         BE    *+8                 YES,SO DON'T STORE ODD ONE\n         STC   R0,AVCONBLD(RB)     STORE INTO POSITION\nCX2RETA  LA    RC,AVCONBLD         SHOW @ CONSTANT\n         LR    RA,R1               SHOW SCAN PTR TO DELIMITING '\nCX2RET   $RETURN RGS=(R0-R2),SA=NO\n         DROP  RAT,REP             CLEAN UP USING\n         LTORG\n         TITLE '*** CZCONS - ZONED DECIMAL CONSTANTS ***'\n**--> CSECT: CZCONS   1-2 PROCESS ZONED CONSTS. . . . . . . . . . . . .\n*.       USES DSECTS: AVWXTABL                                        .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nCZCONS   CSECT\n         $DBG A0,SNAP\n         ENTRY CZCON1,CZCON2\n         USING AVWXTABL,RAT        NOTE MAIN TABLE USING\n         SPACE 2\n**--> ENTRY: CZCON1   1   SCAN, BUT DO NOT ASSEMBLE . . . . . . . . . .\n*.       ENTRY CONDITIONS                                             .\n*.  RA = SCAN POINTER (ADDRESS OF 1ST CHAR AFTER PREVIOUS DELIMETER)  .\n*.       EXIT CONDITIONS                                              .\n*.  RA = SCAN POINTER (ADDRESS OF DELIMITER STOPPING SCAN, OR ERROR)  .\n*.  RB = 0    CONSTANT WAS LEGAL, NO ERRORS                           .\n*.  RB = NONZERO VALUE FOR ERROR CODE - INVALID CONSTANT - ($ERINVCN) .\n*.  RC = NUMBER OF BYTES REQUIRED FOR CONSTANT                        .\n*.       USES MACROS: $RETURN,$SAVE                                   .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nCZCON1   $SAVE SA=NO\n         SR    RC,RC               CLEAR FLAG FOR # OF PERIODS\n         LA    RD,17               (MAX @ DIGITS) +1\n         LA    RE,1                FOR INCREMENTING AND DECREMENTING\n         CLI   0(RA),C'+'          IS THERE PLUS SIGN\n         BE    CZ1LOOP             YES,GO BUMP SCAN PTR\n         CLI   0(RA),C'-'          IS THERE MINUS\n         BNE   *+6                 SKIP IF NOT\n         SPACE 1\nCZ1LOOP  AR    RA,RE               BUMP SCAN PTR BY 1\n         CLI   0(RA),C'0'          IS NEXT CHAR A DIGIT\n         BL    CZ1NODIG            BRANCH IF NO DIGIT\n         BCT   RD,CZ1LOOP          DECREMENT LIMIT,BRANCH IF OK\n         B     CZ1INVCN            GO FLAG (TOO MANY DIGITS)\n         SPACE 1\nCZ1NODIG CLI   0(RA),C'.'          WAS NONDIGIT A PERIOD\n         BNE   CZ1QUOT             NO,MUST BE ' OR ,\n         BXLE  RC,RE,CZ1LOOP       SET RC=1,BRANCH IF FIRST TIME\n         B     CZ1INVCN            2 PERIODS - ERROR - BRANCH\n         SPACE 1\nCZ1QUOT  CLI   0(RA),C''''         WAS DELIMITER '\n         BE    CZ1DONE             YES,QUIT\n         CLI   0(RA),C','          WAS DELIMITER ,\n         BNE   CZ1INVCN            INVALID CONSTANT\n         SPACE 1\nCZ1DONE  SR    RB,RB               SHOW NO ERROR\n         LA    RC,17               (MAX @ DIGITS+1)\n         SR    RC,RD               GET ACTUAL # BYTES REQUIRED\n         BNZ   CZ1RET              BRANCH IF LEGAL (NONZERO) LENGTH\nCZ1INVCN LA    RB,$ERINVCN         SHOW INVALID CONSTANT\nCZ1RET   $RETURN SA=NO\n         EJECT\n**--> ENTRY: CZCON2   1-2 SCAN AND ASSEMBLE Z-TYPE CONSTANT . . . . . .\n*.       ENTRY CONDITIONS                                             .\n*.  RA = SCAN POINTER (ADDRESS OF 1ST CHAR AFTER PREVIOUS DELIMETER)  .\n*.  RB = LENGTH-1 OF 1 CONSTANT OF 1 OPERAND TO BE ASSEMBLED          .\n*.       EXIT CONDITIONS                                              .\n*.  RA = SCAN POINTER (ADDRESS OF DELIMITER STOPPING SCAN, OR ERROR)  .\n*.  RC = ADDRESS OF PROPERLY ASSEMBLED CONSTANT                       .\n*.       USES MACROS: $RETURN,$SAVE,$SETRT                            .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nCZCON2   $SAVE SA=NO,RGS=(R1-R2)\n         MVI   AVCONBLD,C'0'       SET UP FOR PUTTING ZEROES\n         MVC   AVCONBLD+1(14),AVCONBLD      PROPAGATE DECIMAL 0'S\n         LA    RC,AVCONBLD(RB)     @ LAST BYTE OF CONSTANT\n         LA    RE,1                HANDY CONST FOR INCREM-DECREM\n         AR    RB,RE               RB = # OF BYTES REQUIRED\n         LR    RD,RC               SAVE @ LAST BYTE FOR SIGN LATER\n         SR    R1,R1               CLEAR FOR @ INSERTION\n         $SETRT ('''',1,',',1)     SET UP TABLE FOR SCAN\n         TRT   1(17,RA),AWTZTAB    SCAN TO ENDING DELIMITER\n         $SETRT ('''',0,',',0)     ZERO TABLE OUT AGAIN\n         MVI   CZ2SIGN+1,255-X'CF' SET UP FOR + SIGN\n         CLI   0(RA),C'+'          IS THERRE A PLUS SIGN\n         BE    CZ2LOAD             YES,BRANCH\n         CLI   0(RA),C'-'          IS THERE MINUS\n         BNE   CZ2LOAD             NO,BRANCH\n         MVI   CZ2SIGN+1,255-X'DF' SET UP FOR MINUS SIGN\nCZ2LOAD  LR    RA,R1               DUPLICATE PTR TO ENDING PUNCTUATION\n         SR    R1,RE               BACK UP PTR TO LAST DIGIT\n         SPACE 1\nCZ2NUMBR CLI   0(R1),C'0'          ARE WE LOOKING  AT DIGIT\n         BL    CZ2NODIG            BRANCH IF NOT DIGIT\n         MVC   0(1,RC),0(R1)       MOVE DIGIT TO CONSTANT\n         SR    RC,RE               DECREMENT CONSTANT POINTER\n         SR    R1,RE               DECREMENT SCAN POINTER\n         BCT   RB,CZ2NUMBR         DECREMENT,BRANCH IF MORE NEEDED\n         B     CZ2RETA             BRANCH TO RETURN\n         SPACE 1\nCZ2NODIG CLI   0(R1),C'.'          WAS THIS PERIOD\n         BNE   CZ2RETA             NO,SO MUST BE ENDING ' OR , - BRANCH\n         BCT   R1,CZ2NUMBR         DECREM SCAN PTR,BACK FOR NEXT DIGIT\n         SPACE 1\nCZ2RETA  LA    RC,AVCONBLD         SHOW @ OF ASSEMBLEE CONSTANT\nCZ2SIGN  XI    0(RD),$CHN          CREAT RIGHT SIGN IN ZONE OF LAST BYT\nCZ2RET   $RETURN SA=NO,RGS=(R1-R2)\n         DROP  RAT,REP             KILL USINGS\n         TITLE '*** ERRORS - ERROR FLAGGING AND POINTER SETUP ***'\n**--> CSECT: ERRORS   1-2 ERROR FLAGGING ROUTINES . . . . . . . . . . .\n*.       ENTRY CONDITIONS                                             .\n*.  RA = SCAN POINTER TO CAUSE OF ERROR                               .\n*.  RB = ERROR CODE                                                   .\n*.       EXIT CONDITIONS                                              .\n*.  RA,RB ARE UNCHANGED BY ERRTAG OR ERRLAB                           .\n*.       USES DSECTS: AVWXTABL,RSBLOCK                                .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nERRORS   CSECT\n         $DBG  80,SNAP             NOTE WE WANT TO SEE ALL ERRS\n         ENTRY ERRTAG,ERRLAB\n         USING AVWXTABL,RAT        NOTE MAIN TABLE USING\n         SPACE 2\n**--> ENTRY: ERRTAG       FLAG ERROR AT SCAN POINTER POSITION . . . . .\n*.       ENTRY CONDITIONS-EXIT CONDITIONS - SEE CSECT ERRORS          .\n*.       USES MACROS: $RETURN,$SAVE,$SCOF                             .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nERRTAG   $SAVE SA=NO\n         L     RE,AVRSBPT          GET ADDR OV RECORD SOURCE BLOCK\n         USING RSBLOCK,RE          NOTE USING\n         TM    RSBFLAG,$REBX       DOES A RECORD ERROR BLOCK EXIST\n         BO    ERREBEX             REB ALREADY EXISTS\n         OI    RSBFLAG,$REBX       FLAG==>REB EXISTS,THERE ARE ERROR(S)\n         DROP  RE                  NO LONGET USING\n         MVI   AVREBLN,0           INITIALIZE TO LENGTH-1 OF 0\nERREBEX  CLI   AVREBLN,$ERREBMX*L'AVREBES    CHECK IF MORE ROOM\n         BNL   ERRTRET             NO MORE ROOM-RETURN\n         SR    RD,RD               CLEAR FOR INSERT TO FOLLOW\n         IC    RD,AVREBLN          GET THE CURRENT LENGTH-1 OF REB\n         $SCOF RE,RA,AVREBSCN(RD)\n         STC   RB,AVREBERR(RD)     PLACE ERROR CODE IN ALSO\n         LA    RD,L'AVREBES(RD)    INCREMENT COUNTER\n         STC   RD,AVREBLN          PLACE NEW VALUE INTO COUNTER AREA\n         $DBG  ,NO                 DON'T NEED TO SEE GOING OUT\nERRTRET  $RETURN SA=NO\n         SPACE 2\n**--> ENTRY: ERRLAB       FLAG ERROR FOR A LABEL. . . . . . . . . . . .\n*.       ENTRY CONDITIONS-EXIT CONDITIONS - SEE CSECT ERRORS          .\n*.       CALLS ERRTAG                                                 .\n*.       USES MACROS: $CALL,$RETURN,$SAVE                             .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nERRLAB   $SAVE RGS=(R14-R0),SA=NO\n         LR    R0,RA               SAVE THE REAL SCAN POINTER\n         L     RE,AVRSBPT          GET POINTER TO RECORD SOURCE BLOCK\n         USING RSBLOCK,RE          NOTE THE USING\n         LA    RA,RSBSOURC         MAKE A FAKE POINTER TO LABEL\n         DROP  RE                  NOTE NO LONGER USING\n         $CALL ERRTAG              CALL FLAGGING SECTION\n         USING ERRTAG,REP          NOTE CHANGED USING\n         LR    RA,R0               RETURN REAL SCAN POINTER\nERRLRET  $RETURN RGS=(R14-R0),SA=NO\n         DROP  RAT,REP             CLEAN UP USING\n         TITLE  '*** ESDOPR - EXTERNAL SYMBOL DICTIONARY ***'\n**--> CSECT: ESDOPRS  1-2 EXTERNAL SYMBOL DICTIONARY&ESDID OPERATIONS .\n*.       THIS MODULE HANDLES ALL FLAGGING AND CHECKING OF SECTION     .\n*.       AND EXTERNAL ATTRIBUTES, INCLUDING FLAGGING SYMBOL TABLE     .\n*.       ENTRIES AND MANIPULATING LOCATION COUNTERS AND SECTION IDS.  .\n*.       USES DSECTS: AVWXTABL,SYSMSECT                               .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nESDOPR   CSECT\n         $DBG  90,*\n         ENTRY ESINT1,ESCSEC,ESENX1,ESENX2\n         USING AVWXTABL,RAT        NOTE MAIN TABLE USING\n         SPACE 1\n**--> ENTRY: ESINT1       INITIALIZATION . PASS 1 . . . . . . . . . . .\n*.       THIS SECTION FOR COMPLETENESS, FUTURE USE. DOES NOTHING 8/70..\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nESINT1   $SAVE SA=NO\n*        ***** FUTURE USE - DOES NOTHING AT PRESENT TIME.**************\nESINRET  $RETURN SA=NO\n         SPACE 1\n**--> ENTRY: ESCSEC       DECLARE A CONTROL SECTION OR DUMMY SECTION. .\n*.       ENTRY CONDITIONS                                             .\n*.  RB = 0 ==> CSECT                                                  .\n*.     = 2 ==> DSECT                                                  .\n*.     = 4 ==> START                                                  .\n*.  RC = VALUE TO BE USED TO SET LOCATION COUNTER(START ONLY,RB=4)    .\n*.       EXIT CONDITIONS                                              .\n*.  RB = 0 ==> NO ERRORS.  ^=0 ==> AN ERROR CODE TO BE SET            .\n*.  RB = NONZERO VALUE - ERROR CODE - ($ERDPCSE)                      .\n*.  AVCESDID  IS INCREMENTED BY 1 OR 2 FOR NEXT VALUE OF REQUIRED TYPE.\n*.       I.E. CSECTS HAVE EVEN VALUES, DSECTS ODD ONES.               .\n*.  LOCATION COUNTERS ARE MODIFIED (AVLOCHIH,AVLOCNTR).               .\n*.       USES MACROS: $ALIGR,$AL2,$GLOC,$RETURN,$SAVE,$SLOC           .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nESCSEC   $SAVE SA=NO\n         L     RE,AVLABPT          GET POINTER TO LABEL ENTRY\n         LTR   RE,RE               WAS THER A STMT LABEL\n         BNZ   ESCSLAB             RE = @ SYMBOL TABLE ENTRY,BRANCH\n         TM    AVTAGS1,$IBPRCD1    HAS PRIVATE CODE OCCURRED\n         BO    ESCSERPC            ERROR-RESUMPTION OF PRIVATE CODE\n         OI    AVTAGS1,$IBPRCD1    FLAG THAT PRIVATE CODE HAS NOW OCCUR\n         AIF   (NOT &$MACROS).ESNOMA1       SKIP IF NO MACROS\n         MVC   AVSYSECT,AWBLANK    SET &SYSECT FOR USE OF MEXPND\n.ESNOMA1 ANOP\n         B     ESCSINCR            GO BUMP ESDID\n         SPACE 1\n         USING SYMSECT,RE          NOTE SYMBOL TABLE USING\nESCSLAB  TM    SYFLAGS,$SYDEF      HAS SYMBOL BEEN DEFINED ALREADU\n         BO    ESCSERPC            ERROR-RESUMPTION OF CONTROL SECT\n         AIF   (NOT &$MACROS).ESNOMA2       SKIP IF NO MACRO EXPANDSER\n*              SET UP &SYSECT FOR MACRO EXAPNDER MEXPND.\n         MVC   AVSYSECT,AWBLANK    BLANK OUT SECTION NAME\n         MVC   *+7(1),SYCHARS      MOVE LEN-1 INTO NEXT INSTR\n         MVC   AVSYSECT($),SYMBOL  MOVE SYMBOL OVER, NOW RIGHT-PADDED\n.ESNOMA2 ANOP\nESCSINCR SR    RD,RD               CLEAR FOR INSERTION\n         IC    RD,AVCESDID         GET CURRENT ESDID\n         LA    RD,2(RD)            INITIALLY INCREMENT BY 2 FOR NEXT\n         STC   RD,AVCESDID         REPLACE UPDATED SECTION ID\n         LH    RB,ESCSJUMP(RB)     GET OFFSET TO ROUTINE\nESCSJ    B     ESCSJ(RB)           TAKE BRANCH TO RIGHT SECTION\n         SPACE 1\n* * * * * PROCESS CSECT STATEMENT                                     *\nESCSECT  TM    AVTAGS1,$IBDSEC1    ARE WE IN DSECT CURRENTLY\n         BZ    ESCSCS              NO WE AREN'T,SKIP\n         NI    AVTAGS1,255-$IBDSEC1          REMOVE DSECT FLAG\n         L     RC,AVLOCHIH         GET HIGHEST LOCATION COUNTER VALUE\n         B     ESCSTAG             GO TO FLAG SYMBOL TABLE ENTRY\n         SPACE 1\nESCSCS   $GLOC RC                  GET CURRENT LOCATION COUNTER\n         C     RC,AVCSHIH          COMPARE TO HIGHEST IN CSECT\n         BNL   ESCSTAG             GO TO TAG IF HIGHEST VALUE IN RC\n         L     RC,AVCSHIH          ORG *-X MUST HAVE OCCURED-GET HIGHES\n         EJECT\n* * * * * COMMON CODE FOR START AND CSECT                             *\nESCSTART EQU   *\nESCSTAG  LTR   RE,RE               WAS THERE A SYMBOL\n         BZ    ESCSDBL             SKIP TO ALIGN IF NO SYMBOL\n         OI    SYFLAGS,$SYCSE      NOTE SYMBOL IS A CSECT\nESCSDBL  LA    RD,7                SET UP FOR D ALIGNING\n         $ALIGR RC,RD              ALIGN VALUE TO DOUBLEWORD\n         NI    AVCESDID,255-$ESDSECT        FLAG AS A CSECT, EVEN VALUE\n         B     ESCSETL             GO SET LOCATION COUNTER,ETC.\n         SPACE 1\n* * * * * ESCSDSEC - PROCESS DSECT                                    *\nESCSDSEC SR    RC,RC               CLEAR FOR VALUE TO SET LOCATION COUN\n         OI    SYFLAGS,$SYDSE      FLAG SYMBOL WITH DSECT\n         OI    AVCESDID,$ESDSECT   MAKE SURE ODD, I.E. DSECT\n         TM    AVTAGS1,$IBDSEC1    ARE WE ALREADY IN DSECT\n         BO    ESCSETL             GO SET LOCCNTR IF ALREADY IN DSECT\n         L     RD,AVCSHIH          GET HIGH IN CURRENT CSECT\n         C     RD,AVLOCNTR         IS IT HIGHER THAN LOCATION COUNTER\n         BNL   *+8                 SKIP IF VALUE IN RD IS HIGH\n         L     RD,AVLOCNTR         GET LOCATION COUNTER-IT IS HIGH\n         ST    RD,AVLOCHIH         SAVE THIS AS HIGHEST VALUE YET ENCOU\n         OI    AVTAGS1,$IBDSEC1    NOTE THAT WE ARE NO WIN DSECT\n         SPACE 1\nESCSETL  $SLOC RC                  SET NEW LOCATON COUNTER VALUE\n         LR    RD,RC               DUPLICATE VALUE OVER FOR SETTING UP\n         STM   RC,RD,AVCSLOW       STORE VALUE INTO AVCSLOW-AVCSHIH\n         SR    RB,RB               SHOW NO ERRORS\nESCSRET  $RETURN SA=NO\nESCSERPC LA    RB,$ERDPCSE         ILLEGAL CSECT RESUMPTION\n         B     ESCSRET             RETURN\n         SPACE 1\n*              JUMP OFFSET TABLE FOR 3 TYPES OF CALLS TO ESCSEC       *\nESCSJUMP $AL2  ESCSJ,(ESCSECT,ESCSTART,ESCSDSEC)\n         DROP  RE                  CLEAR USING\n         EJECT\n**--> ENTRY: ESENX1       ENTRY AND EXTRN STATEMENTS- PASS 1. . . . . .\n*.       ENTRY CONDITIONS                                             .\n*.  RA = SCAN POINTER                                                 .\n*.  RB = 0 ==> ENTRY                                                  .\n*.     = 2 ==> EXTRN                                                  .\n*.       EXIT CONDITIONS                                              .\n*.  RA = SCAN POINTER TO BLANK FOLLOWING OPERAND FIELD, OR ERROR      .\n*.  RB = 0 ==> NO ERRORS.  ^= 0 ==> ERROR CODE TO BE SET              .\n*.  RB = NONZERO VALUE - ERROR CODE - ($ERINVDM,$ERINVSY)             .\n*.  ALL LABEL'S IN STMT HAVE SYMSECTS FLAGGED APPROPRIATELY.          .\n*.       CALLS SYENT1                                                 .\n*.       USES MACROS: $CALL,$GTAD,$RETURN,$SAVE                       .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nESENX1   $SAVE SA=ESDOSAVE,RGS=(R14-R6),BR=RW\n         LA    RZ,ESNX1RET         SHOW @ FOR RETURN FROM ERROR\n         MVI   ESENXF+1,$SYENT     PLACE THIS INTO FLAGGING INST\n         LTR   RB,RB               WAS THIS CALL FOR ENTRY\n         BZ    *+8                 SKIP IF SO\n         MVI   ESENXF+1,$SYEXT     WAS EXTRN-PUT FLAG BYTE IN\n         LA    RY,1                ST UP USEFUL 1 IN ODDREG\n         SPACE 1\nESENX1A  BAL   RX,ESSYMBOL         GO HAVE SYMBOL SCANNED AND ENTERED\n         USING SYMSECT,RC          NOTE USING(SET UP BY ESSYMBOL)\nESENXF   OI    SYFLAGS,$CHN        WILL HAVE FLAG BYTE PLACED IN\n         CLI   0(RA),C' '          WAS THIS LAST ONE\n         BE    ESN1RETA            GO RETURN WITH NO ERRORS\n         CLI   0(RA),C','          IS DELIMITER RIGHT ONE\n         BNE   ESERIND             NO,ERROR\n         BXH   RA,RY,ESENX1A       BUMP SCAN PTR, GO FOR NEXT NAME\n         SPACE 1\nESN1RETA SR    RB,RB               SHOW NO ERRORS\nESNX1RET $RETURN RGS=(R14-R6)\n         EJECT\n**--> ENTRY: ESENX2       ENTRY AND EXTRN STATEMENTS - PASS 2 . . . . .\n*.       CHECKS ENTRY/EXTRN STATEMENTS FOR CONFLICTS, ERRORS.         .\n*.       ENTRY AND EXIT CONDITIONS EXACTLY SAME AS ESENX1             .\n*.             EXCEPT EXIT VALUE OF RB MEANS NOTHING.                 .\n*.       CALLS ERRTAG,SYENT1                                          .\n*.       USES MACROS: $CALL,$GTAD,$RETURN,$SAVE                       .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nESENX2   $SAVE SA=ESDOSAVE,RGS=(R14-R6),BR=RW\n         LA    RZ,ESNX2RET         SHOW @ FOR ERROR RETURN, IF ANY\n         LR    R0,RB               SAVE CODE, =0 ==> ENTRY, =2==>EXTRN\n         LA    RY,1                FOR BXH'ING CONSTANT IN ODD REG\n         SPACE 1\nESNX2L   BAL   RX,ESSYMBOL         CALL SYMBOL LOOKUP ROUTINE\n         LTR   R0,R0               ENTRY OR EXTRN\n         BNZ   ESNX2EXT            EXTRN-BRANCH\n         SPACE 1\n         TM    SYFLAGS,$SYDEF      WAS ENTRY DEFINED\n         BZ    ESNX2ERA            NO IT WASNT, ERROR BRANCH\n         TM    SYFLAGS,$SYDSE+$SYEXT        WAS IT ALSO MARKED DSECT/EX\n         BZ    ESNX2M              NO, IT WAS LEGAL, BRANCH\nESNX2ERA LA    RB,$ERENTRY         ENTRY ERROR\n         B     ESNX2ERR            GO HAVE IT FLAGGED\n         SPACE 1\nESNX2EXT TM    SYFLAGS,$SYDEF+$SYENT+$SYCSE+$SYDSE    IS EXTRN OK\n         BZ    ESNX2M              YES, BRANCH, LEGAL\n         LA    RB,$EREXTRN         EXTERNAL NAME ERROR\nESNX2ERR SR    RA,RY               BACK SCAN PTR UP 1\n         $CALL ERRTAG              HAVE THERROR FLAGGED\n         AR    RA,RY               INCREMENT BACK TO DELIMITER\n         SPACE 1\nESNX2M   CLI   0(RA),C' '          WAS ENDING DELIMITER BLANK\n         BCR   E,RZ                B ESNX2RET - QUIT\n         BXH   RA,RY,ESNX2L        BUMP SCAN PTR AND CONTINUE\n         SPACE 1\nESNX2RET $RETURN RGS=(R14-R6),SA=ESDOSAVE\n         EJECT\n         USING ESDOSAVE,R13        GIVE SUBR COMMON BASE FROM 1-2\n*              INDIVIUDAL ERROR EXITS AND FLAGGING                    *\nESERIND  LA    RB,$ERINVDM         INVALID DELIMITER\n         BR    RZ                  RETURN TO REQUIRED LOCATION\nESERSYM  LA    RB,$ERINVSY         INVALID SYMBOL\n         BR    RZ                  RETURN TO REQUIRED LOCATION\n         SPACE 1\n* * * * * ESSYMBOL - SCAN SYMBOL,HAVE IT ENTERED IN TABLE,RETURN @    *\nESSYMBOL SR    R1,R1               CLEAR SO TRT'S WORK\n         TRT   0(9,RA),AWTSYMT     SCAN FOR DELIMITER\n         BZ    ESERIND             FLAG ERROR, IF SYMBOL TOO LONG\n         CLI   0(RA),C'0'          MAKE SURE NOT LEADING DIGTI\n         BNL   ESERSYM             LEADING DIGIT-ILLEGAL\n         LR    RB,R1               MOVE END SCAN POINTER OVER\n         SR    RB,RA               GET LENGTH OF SYMBOL\n         BZ    ESERIND             ZWRO LENGTH SYMBOL -DELIMITER\n         $CALL SYENT1              HAVE SYMBOL ENTRED IN TABLE\n         LR    RC,RA               MOVE POINTER TO SYMBOL ENTRY OVER\n         LR    RA,R1               UPDATE  SCAN POINTER\n         BR    RX                  RETURN TO CALLER\n         DROP  RC,RW,R13           SYMSECT, REGUALR BASE, 2ND BASE\n         TITLE '*** EVALUT - EXPRESSION EVALUATOR ***'\n**--> DSECT: EVCTDSCT   EVALUT TRANSITION TABLE ENTRY . . . . . . . . .\n*.       THIS DESCRIBES 1 ENTRY IN 1 ROW OF THE GENERAL EXPRESSION    .\n*.       EVALUATOR EVALUT, AND GIVES A SECTION OFFSET @ TO USE, AND   .\n*.       EITHER A NEXT STATE(ROW) IN TABLE OR AN ERROR CODE FOR AN    .\n*.       ILLEGAL CURRENT STATE/CURRENT VALUE COMBINATION.             .\n*.       LOCATION: TABLE EVCTAB IN CSECT EVALUT.                      .\n*.       GENERATION: 1 ROW OF EVCTDSCTS IS GENERATED BY 1 EVCG MACRO. .\n*.       NAMES: EVCT----                                              .\n*.  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n         SPACE 1\nEVCTDSCT DSECT\nEVCTADR  DS    AL1                 JUMP OFFSET INDEX FOR ROUTINES\nEVCTCOD  DS    AL1                 NEXT ROW OFFSET OR ERROR CODE\nEVCTL    EQU   *-EVCTDSCT          LENGTH OF SINGLE TABLE ENTRY\n*              EQU'S DEFINING OFFSETS ALONG ROWS IN EVCTAB            *\nEVCLP    EQU   0                   (\nEVCRP    EQU   EVCTL               )\nEVCPL    EQU   2*EVCTL             + -\nEVCMU    EQU   3*EVCTL             *\nEVCDI    EQU   4*EVCTL             /\nEVCAB    EQU   5*EVCTL             ABSOLUTE TERM\nEVCRE    EQU   6*EVCTL             RELOCATABLE TERM\nEVCBL    EQU   7*EVCTL             BLANK OR ,\n         SPACE 2\n**--> CSECT: EVALUT   1-2 GENERAL EXPRESSION EVALUATION ROUTINE . . . .\n*.       ENTRY CONDITIONS                                             .\n*.  RA = SCAN POINTER (ADDRESS OF 1ST CHARACTER OF EXPRESSION)        .\n*.       EXIT CONDITIONS                                              .\n*.  RA = SCAN POINTER TO DELIMITER STOPPING SCAN, OR ERROR            .\n*.  RB = 0 ==> EXPRESSION GOOD, = NONZERO VALUE==>ERROR CODE          .\n*.  RC = VALUE OF EXPRESSION, IF IT WAS GOOD                          .\n*.  RD = 0 ==> EXPRESSION WAS AN ABSOLUTE EXPRESSION                  .\n*.     = ESDID FOR A RELOCATABLE EXPRESSION (1-255)                   .\n*.  RE = LENGTH ATTRIBUTE - 1 OF EXPRESSION.                          .\n*.       CALLS SDBCDX,SYFIND                                          .\n*.       USES DSECTS: AVWXTABL,EVCTDSCT,RCODBLK,RSBLOCK,SYMSECT       .\n*.       USES MACROS: $CALL,$GLOC,$RETURN,$SAVE,EVCG                  .\n*.                                                                    .\n*.       **NOTE** SEE IBM PLM Y26-3700-0, PP. 45-47. EVALUT SOMEWHAT  .\n*.       RESEMBLES IEUF7V-EXPRESSION EVALUATION ROUTINE.  NOTE EVALUT .\n*.       HAS 1 LESS STATE SETTING, SINCE IEUF7V COND=0 IS UNNEEDED.   .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n         EJECT\nEVALUT   CSECT\n         $DBG  B0,SNAP\n* * * * * REGISTER ALLOCATION AND USAGE FOR EVALUT* * * * * * * * * * *\n*   R0   UNRESTRICTED WORK REGISTER                                   *\n*   R1   ADDRESS WORK REGISTER - HIGH-ORDER BYTE =0 ALWAYS            *\n*   R2   BYTE WORK REGISTER - HIGH-ORDER 3 BYTES = 0 ALWAYS           *\n*   RW   TERM /SIGN/ID STACK INDEX = INDEX OF NEXT EMPTY H IN EVTRID  *\n*   RX   OPERATOR STACK POINTER = @ LAST OPERATOR CODE IN EVOPRS      *\n*   RY = 1     USEFUL CONSTANT IN ODD REGISTER, CAN BE USED FOR BSH'S *\n*   RZ   STATE REGISTER = @ ROW IN EVCTAB OR @ ENTRY IN EVCTAB        *\n*   RA   SCAN POINTER TO NEXT CHARACTER TO BE EXAMINED                *\n*   RB-RE      GENERAL WORK REGISTERS AND PARAMETER REGISTERS         *\n*   R13  BASE REGISTER AND SAVE AREA POINTER                          *\n*   R14  INTERNAL AND EXTERNAL LINK REGISTER                          *\n*   R15  UNRESTRICTED WORK REGISTER                                   *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         USING AVWXTABL,RAT        NOTE MAIN TABLE USING\n         $SAVE RGS=(R14-R6),BR=R13,SA=EVALSAVE\nEVLPC    EQU   2                   AWTSYMT CODE FOR LEFT PAREN\n         SPACE 1\n*              INITIALIZATION SECTION                                 *\n         NI    EVFLENG+1,X'0F'     MAKE SURE BRANCH IS A NOPR\n         LA    R0,16               FOR INIT OF EVPCNT-EVTRNM\n         STH   R0,EVPCNT           STORE EVPCNT=0, EVTRNM=16\n         LM    R1,RW,AWZEROS       ZERO OUT\n         LA    RX,EVOPRS           INIT TO BEFINNING OF STACK\n         LA    RY,1                HANDY CONSTANT IN ODD REGISTER\n         USING EVCTDSCT,RZ         NOTE TRANSITION TABLE ENTRY USING\n         B     EVCNEXTA            ENTER AT RIGHT PLACE TO START\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*              MAIN CONTROL POINT - PICK UP CODE FROM PREVIOUS ENTRY  *\n*        IN TRANSITION TABLE, TO MAKE IT THE CURRENT STATE. FIND FROM *\n*        THIS THE @ NEW ROW INT ABLE (NEW STATE).  GET THE NEXT CHAR  *\n*        TO BE SCANNED, GET CODE FORM AWTSYMT WHICH DESCRIBES IT. IF  *\n*        THE CHAR IS A DELIMITER, SKIP TO EVCOPRT.  FOR A CHARACTER   *\n*        WHICH MIGHT BEGIN A TERM (ALPHANUMERIC), SCAN AND EVALUATE   *\n*        THE TERM, DETERMINING ITS RELOCATIBILITY ATTRIBUTE FOR LATER *\n*        IN REGS RC & RD FOR USE BY EVTERM, IF LEGAL.                 *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nEVCNEXT  IC    R2,EVCTCOD          GET CODE FROM PREVIOUS ENTRY\nEVCNEXTA LA    RZ,EVCTAB(R2)       GET @ REQUIRED ROW IN EVCTAB\n         AIF   (&$DEBUG).EVCX0     SKIP IF PRODUCTION MODE\n         XSNAP IF=(AVDEBUG,O,X'B0',TM),STORAGE=(EVOPRS,EVALQ),         #\n               LABEL='EVCNEXTA'\n.EVCX0   ANOP\n         IC    R2,0(RA)             GET THE NEXT SOURCE BYTE\n         IC    R2,AWTSYMT(R2)       GET THE CODE FROM THE TABLE\n         CR    R2,RY                COMPARE TO 1 FOR TYPE\n         BH    EVCOPRT              IF >1, CHARACTER WAS OPERATOR\n         BE    EVZILCH              ILLEGAL CHARACTER, IF =1\n         SPACE 1\n*              TERM-PROCESSING SECTION - CODE IN R2 = 0               *\n         CLI   0(RA),C'0'           WAS IT A DIGIT\n         BNL   EVCSDT2             SKIP TO SELF-DEFINING TERM SECTION\n         CLI   1(RA),C''''          IS NEXT CHAR A '\n         BE    EVCSDT1              SKIP IF SO, I.E. L' B' C' OR X'\n         SPACE 1\n*              SYMBOL FOUND - HAVE IT SCANNED. GET VALUE,SECTION ID.\n         BAL   R14,EVSYMB           CALL SYMBOL ROUTINE\n         USING SYMSECT,RB           NOTE POINTER\n         L     RC,SYVALUE           GET VALUE OF SYMBOL INTO RC\n         IC    R2,SYLENG            GET LENGTH-1\n         BAL   R14,EVFLENG          CALL LENGTH ATTRIB SAVER\n         IC    R2,SYESDID           GET SECTION ID\n         LTR   RD,R2                MOVE SECTION ID AND TEST IT\n         BZ    EVCABSA              SKIP IF0, I.E. ABSOLUTE SYMBOL\n         LA    R2,EVCRE            SHOW OFFSET FOR RELOCATABLE TERM\n         B     EVCJUMPA             GO TO MAKE CHOICE\n         EJECT\n*              ABSOLUTE TERM - SELF-DEFINING OR LENGTH ATTRIBUTE      *\nEVCSDT1  CLI   0(RA),C'L'           WAS IT L'\n         BNE   EVCSDT2              NO, MUST BE X' B' OR C'\n*              TERM IS A LENGTH ATTRIBUTE - L'SYMBOL OR L'*.\n         LA    RA,2(RA)             BUMP SCAN PTR PAST L'\n         CLI   0(RA),C'*'          IS IT L'*\n         BNE   EVCSDT2A            SKIP IF NOT (BRANCH PROBABLE)\n         BAL   R14,EVFLQAS         CALL L'* ROUTINE\n         BXH   RA,RY,EVCSDT2B      BRANCH, INCREM SCAN PTR BEYOND *\n         SPACE 1\n*              PROCESS SELF-DEFINING TERM                             *\nEVCSDT2  $CALL SDBCDX              CALL SELF-DEF TERM PROCESSOR\n         LTR   RB,RB                WAS RESULT OK\n         BZ    EVCSDT3              YES,OK,RESULT IN RC\n         BP    EVZERROR             ERROR,BRANCH\n         BXH   RA,RY,EVZSYNT       ' BAD, LETTER NOT B,C,X-ERROR\n         SPACE 1\nEVCSDT2A BAL   R14,EVSYMB          CALL SYMBOL LOOKUP\n         IC    R2,SYLENG           GET LENGTH-1\n         DROP  RB                  REMOVE SYMSECT USING\nEVCSDT2B LA    RC,1(R2)            MOVE, CONVERT LENGTH-1 TO LENGTH\n         BAL   R14,EVFLENG         HAVE LENGTH ATTRIB SAVED,IF NEEDED\n*              IF EVCSDT3 ENTERED THRU EVCSDT1, R2 STILL =0 (L' =1)\nEVCSDT3  BAL   R14,EVFLENG         HAVE LENGTH-1 SAVED, IF NOT ALREADY\n         SR    RD,RD                SHOW ABSOLUTE TERM\nEVCABSA  LA    R2,EVCAB            SHOW OFFSET FOR ABSOLUTE TERM\n         B     EVCJUMPA             GO TO MAKE BRANCH\n         EJECT\n* * * * * EVFLQAS - OBTAIN L'*-1, RETURN IT IN R2, IF IT EXISTS       *\n*        THIS ROUTINE CALLED ONLY BY TERM PROCESSING SECTION          *\n*        EXIT CONDITIONS                                              *\n*   R2 = L'* - 1, FOR USE AS EXPLICIT LENGTH ATTRIBUTE, OR IMPLIED L  *\n         SPACE 1\nEVFLQAS  L     R15,AVRSBPT         GET RSB POINTER\n         USING RSBLOCK,R15         NOTE USING FOR RSBLOCK\n         SR    R2,R2               SET R2=0, I.E. L'* = 1\n         TM    RSBFLAG,$RCBX       IS THERE AN RCB\n         BCR   Z,R14               RETURN IF THERE ISN'T ANY,USE 1\n         L     R15,AVRCBPT         RCB EXISTS, GET THE @ OF IT\n         USING RCODBLK,R15         NOTE NEW USING\n         IC    R2,RCLQ             GET THE L'* VALUE\n*        BR R14 FALL THRU INTO EVFLENG, SET LENGTH-1 OR JUST RETURN.\n         DROP  R15                 KILL RCODBLK USING\n         SPACE 1\n* * * * * EVFLENG - STORE LENGTH ATTRIBUTE-1, IF 1ST TIME             *\n*        THIS ROUTINE CALLED ONLY FROM TERM PROCESSING SECTION.       *\n*        MUST IMMEDIATELY FOLLOW SECTION EVFLQAS.                     *\n*        ENTRY CONDITIONS                                             *\n*   R2 = LENGTH ATTRIVUTE-1                                           *\n         SPACE 1\nEVFLENG  BCR   $CHN,R14             RETURN TO CALLER IF NOT 1ST TIME\n         OI    EVFLENG+1,X'F0'      CHANGE NOPR TO BR\n         STC   R2,EVALQ             SAVE LENGTH ATTRIBUTE - 1\n         BR    R14                  RETURN TO CALLER\n         SPACE 1\n* * * * * EVSYMB - SCAN SYMBOL AND HAVE IT LOOKED UP BY SYFIND        *\n*        THIS SECTION CALLED ONLY FROM TERM PROCESSING SECTION.       *\n*        ENTRY CONDITIONS                                             *\n*   RA = SCAN POINTER TO 1ST CHARACTER OF SYMBOL                      *\n*        EXIT CONDITIONS                                              *\n*   RA = SCAN POINTER TO DELIMITER FOLLOWING SYMBOL                   *\n*   RB = @ SYMSECT ENTRY IN SYMBOL TABLE OF THE SYMBOL                *\n         SPACE 1\nEVSYMB   TRT   0(9,RA),AWTSYMT      SCAN FOR DELIMITER\n         BZ    EVZINVSY             IF NOT FOUND,SYMBOL TOO LONG-ERROR\n         LR    RB,R1               GET PTR TO DELIMITER INTO RB\n         SR    RB,RA                GET LENGTH OF SYMBOL\n         BZ    EVZILCH              ILLEGAL CHARACTER\n         LR    R0,R14               SAVE RETURN @\n         SPACE 1\n         $CALL SYFIND              CALL LOOKUP ROUTINE\n         LTR   RB,RB                WAS THE SYMBOL UNDEFINED\n         BNZ   EVZUNDEF             UNDEFINED SYMBOL,ERROR\n         LR    RB,RA                MOVE POINTER TO SYMBOL OVER\n         USING SYMSECT,RB           NOTE SYMBOL POINTE\n         TM    SYFLAGS,$SYDEF       WAS SYMBOL DEFINED\n         BZ    EVZUNDEF             NO,UNDEFINED-BRANCH\n         LR    RA,R1                GET SCAN PTR TO DELIMITER\n         LR    R14,R0               RESTORE RETURN @\n         BR    R14                  RETURN TO CALLING SECTION\n         DROP  RB                   KILL USING\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*              BRANCH ACCORDING TO CURRENT STATE (GIVEN BY RZ) AND    *\n*        TYPE OF TERM OR DELIMITER.  USE VALUES IN EVCTAB, WHICH      *\n*        CONTAIN OFFSET JUMP VALUES, AND EITHER A NEXT STATE VALUE,   *\n*        OR AN ERROR CODE IF A BRANCH TAKEN DIRECTLY TO EVCERR.       *\n*        THE LABELS EVERR, EVLOCNT, EVTERM, EVPCHIH, EVPCTES, EVPCZER,*\n*        AND EVOPCHK MUST ALL BE WITHIN 256 BYTES OF EVDJUMP.         *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nEVCOPRT  LR    R1,R2               SAVE OPERATOR CODE FROM AWTSYMT\n         IC    R2,EVCOFFS(R2)      GET OFFSET FOR TRANSITION TABLE\nEVCJUMPA LA    RZ,EVCTDSCT(R2)     GET @ INDIVIDUAL ENTRY INTABLE\n         IC    R2,EVCTADR          GET JUMP INDEX VALUE FROM TABLE\n         AIF   (&$DEBUG).EVCX1     SKIP IF PRODUCTION MODE\n         XSNAP IF=(AVDEBUG,O,X'B0',TM),                                #\n               STORAGE=(*EVDJUMP(R2),*EVDJUMP+4(R2)),LABEL='EVDJUMP'\n.EVCX1   ANOP\n         B     EVDJUMP(R2)         TAKE BRANCH TO PARTICULAR ROUTINE\nEVDJUMP  EQU   *                   BASE FOR RPUTINE JUMPS\n         SPACE 1\n* * * * * EVERR - OBTAIN ERROR CODE FROM TRANSITION TABLE, EXIT.      *\nEVERR    IC    R2,EVCTCOD          GET ERROR CODE\n         LR    RB,R2                MOVE TO EXPECTED LOCATION\n         B     EVZERROR             GO TO FINISH\n         SPACE 1\n* * * * * EVLOCNT - PROCESS LOCATION COUNTER REFERENCE                *\nEVLOCNT  $GLOC RC                   GET LOCATION COUNTER\n         IC    R2,AVCESDID          GET SECTION ID CURRENT\n         LR    RD,R2               MOVE OVER WHERE EXPECTED\n         BAL   R14,EVFLQAS         CALL L'* ROUTINE, SAVE LENGTH-1 ATT\n         AR    RA,RY               BUMP SCAN PTR 1, FALL THRU TO EVTERM\n         SPACE 1\n* * * * * EVTERM - ENTER TERM VALUE AND ID INTO EVTRMS/EVTRID         *\n*        THIS SECTION MUST IMMEDIATELY FOLLOW EVLOCNT.                *\n*        ENTRY CONDITIONS                                             *\n*   RC = VALUE OF TERM TO BE ENTERED                                  *\n*   RD = SECTION ID (1-255) FOR RELOCATABLE, 0 FOR ABSOLUTE TERM      *\n*   RW = INDEX OF NEXT EMPTY SLOT IN EVTRID                           *\n*        EXIT CONDITIONS                                              *\n*   RW = RW+2  (I.E. ONE ENTRY HAS BEEN PUSHED INTO STACK)            *\n         SPACE 1\nEVTERM   IC    R2,EVTRNM           GET # TERMS LEFT TO GO\n         SR    R2,RY               DECREMENT\n         BM    EVZTMTR             TOO MANY TERMS IN EXPRESSION\n         STC   R2,EVTRNM           STORE BACK UPDATED VALUE\n         STH   RD,EVTRID(RW)       STORE SECTION ID\n         LA    R15,0(RW,RW)        GET INDEX FOR EVTRMS ENTRY\n         ST    RC,EVTRMS(R15)      STORE  THE VALUE OF TERM\n         LA    RW,2(RW)            INCREMENT THE OFFSET INDEX\n         B     EVCNEXT             GO BACK FOR NEXT ONE\n         EJECT\n* * * * * EVPCHIH - ( FOUND, INCREMENT AND TEST PAREN COUNT           *\nEVPCHIH  CLI   EVPCNT,4             CHECK PAREN COUNT\n         BH    EVZPARN              TOO MANY PARENS-BRANCH\n         IC    R2,EVPCNT            GET PAREN COUNT\n         AR    R2,RY               INCREMENT BY 1\n         STC   R2,EVPCNT            STORE BACK\n         B     EVOPENT             GO ENTER OPERATOR\n         SPACE 1\n* * * * * EVPCTES - , OR BLANK FOUND, MAKE SURE PAREN COUNT = 0       *\nEVPCTES  CLI   EVPCNT,0             IS PAREN COUNT 0 LIKE IT SHOULD BE\n         BE    EVFRCA              YES, GO FORCEBACK ALL OPERATORS\n         B     EVERR               ERR-UNEXPECTED END OF EXPRESSION\n         SPACE 1\n* * * * * EVPCZER - ) FOUND, TEST AND DECREMENT PAREN COUNT, FORCEBACK*\nEVPCZER  IC    R2,EVPCNT            GET PAREN COUNT\n         SR    R2,RY                DECREMENT PAREN COUNT\n         BNM   *+8                 IF WAS NOT PREVIOUSLY ZERO, JUMP\n         BXLE  R2,RY,EVFRCA        SET R2=0, BRANCH TO FINISH UP\n         STC   R2,EVPCNT            STORE BACK\n         SPACE 1\n* * * * * EVFRCP - FORCE EVALUATION BACK TO LAST LEFT PAREN           *\n*              LOOP UNTIL LEFT PAREN CODE FOUND IN OPERATOR STACK     *\nEVFRCP   BALR  R14,0               SET R14 = @ NEXT INSTRUCTION, LOOP\n         CLI   0(RX),EVLPC         IS CURRENT CODE THAT OF LEFT PAREN\n         BNE   EVFRCO              NO, SO EVALUATE UNTIL WE FIND (\n         SPACE 1\n         SR    RX,RY               DECREMENT OPERATOR STACK POINTER\n         AR    RA,RY               BUMP SCAN POINTER PAST )\n         LH    R15,EVTRID-2(RW)    GET CURRENT SIGN/ID\n         LTR   R15,R15             IS IT ABSOLUTE\n         BZ    EVCNEXT             ABSOLUTE, SO USE NEXT STATE FROM TAB\n         LA    R2,EVCT4-EVCTAB     OFFSET FOR RELOCATABLE\n         B     EVCNEXTA            GO FOR NEXT\n         SPACE 1\n* * * * * EVOPCHK - CHECK OPERATOR PRECEDENCE, EVALUATE IF NEEDED     *\n*        ENTRY CONDITIONS                                             *\n*   R1 = OPERATOR CODE OF CURRENT OPERATOR, FROM AWTSYMT              *\nEVOPCHK  IC    R2,0(RX)            GET CODE OF PREVIOUS OPERATOR\n         IC    R2,EVOPREC(R2)      PRECEDENCE OF PREV OP +- = 0\n         SR    R15,R15             CLEAR FOR INSERT\n         IC    R15,EVOPREC(R1)     GET PRECEDENCE OF NEW OPERATOR\n         CR    R15,R2              IF NEW PREC > OLD, SKIP EVALUATRE\n         BH    *+8                 IF NEW CODE> OLD CODE, SKIP EVAL\n         BAL   R14,EVFRCO          FORCE 1 OPERATOR EVALUATION\n         SPACE 1\nEVOPENT  AR    RX,RY               INCREMENT POINTER TO EMPTY SLOT\n         STC   R1,0(RX)            STORE CODE OF NEW OPERATOR\n         BXH   RA,RY,EVCNEXT       BUMP SCAN POINTER, GET NEXT CODE\n         SPACE 1\n         EJECT\n* * * * * EVFRCO - EVALUATE 1 OPERATOR AND 2 TERMS IN STACKS          *\n*        ENTRY CONDITIONS                                             *\n*   RW = INDEX OF NEXT EMPTY HALFWORD IN EVTRID STACK                 *\n*   RX = @ LAST OPERATOR CODE ENTERED IN OPERATOR STACK EVOPRS        *\n*   R14= RETURN ADDRESS TO CALLING SECTION OF CODE.                   *\n*        EXIT CONDITONS                                               *\n*   RC = COMPUTED RESULT OF OPERATION                                 *\n*   RW = RW-2  (I.E. 1 ENTRY OF EVTRID&EVTRMS WAS POPPED)             *\n*   RX = RX-1  (I.E. ONE ENTRY FROM OPERATOR STACK WAS POPPED)        *\nEVFRCO   SR    RW,RY               SUBTRACT 1 FROM INDEX\n         SR    RW,RY               SUBTRACT ANOTHER 1, MAKING -2\n         LH    RE,EVTRID(RW)       GET PREVIOUS SIGN CODE/SECTION ID\n         LA    R15,0(RW,RW)        GET 2* RW FOR INDEX INTO EVTRMS\n         LA    R15,EVTRMS-4(R15)   GET @ 2ND PREVIOUS ENTRY\n         LM    RC,RD,0(R15)        GET 2ND PREVIOUS,PREVIOUS EVTRMS\n         IC    R2,0(RX)            GET CURRENT OPERAOTR CODE\n         IC    R2,EVFRCT-5(R2)     GET OFFSET VALUE FOR TYPE JUMP\n         B     EVFRJ(R2)           TAKE BRANCH TO SECTION\nEVFRJ    EQU   *                   BASE FOR OPERATOR JUMPS\n         SPACE 1\n*        - OPERATOR                                                   *\nEVFRMI   SR    RC,RD               PERFORM OPERATION\n         LCR   RE,RE               COMPLEMENT SIGN CODE/SECTION ID\n         B     EVFRPLA             CONTINUE WITH COMMON +- CODE\n         SPACE 1\n*        + OPERATOR                                                   *\nEVFRPL   AR    RC,RD               PERFORM OPERATION\n         LTR   RE,RE               WAS PREVIOUS AN ABS TERM(RE=0 IF SO)\nEVFRPLA  BZ    EVFRCOEX            YES, SO LEAVE 2ND PREV CODE AS IS\n         LH    RB,EVTRID-2(RW)     GET 2ND PREVIOUS SIGN CODE/ID\n         LTR   RB,RB               WAS 2ND PREV TETRM ABSOLUTE\n         BZ    EVFRPLB             YES, SO USE PREV CODE UNCHANGED-BRAN\n         AR    RE,RB               2 RELOCATABLE TERMS, ADD SIGN/ID\n         BNZ   EVZCXREL            IF NO 0, COMPLEX RELOCATIBILITY\nEVFRPLB  STH   RE,EVTRID-2(RW)     SAVE COMPUTED SIGN/ID INTO RESULT\n         B     EVFRCOEX            HAVE RESULT SAVED AND EXIT\n         SPACE 1\n*        * OPERATOR                                                   *\nEVFRMU   MR    RB,RD               1ST OP IN RC, RESULT VALUE ALSO\n         B     EVFRCOEX            GO HAVE RESULT STORED\n         SPACE 1\n*        / OPERATOR                                                   *\nEVFRDI   LR    RB,RC               MOVE 2ND PREVIOUS VALUE OVER\n         LTR   RC,RD               MOVE AND TEST DIVISOR OVER\n         BZ    EVFRCOEX            IF DIVISOR =0, LEAVE RC=0,BRANCH\n         SRDA  RB,32               PROPAGATE SIGN,MOVE DIVIDEND BACK\n         DR    RB,RD               PERFORM OPEATION ,HAVING CHECKED 0\n         SPACE 1\nEVFRCOEX ST    RC,0(R15)           STORE RESULT INTO EVTRMS STACK\n         AIF   (&$DEBUG).EVCX2     SKIP IF PRODUCTION MODE\n         XSNAP IF=(AVDEBUG,O,X'B0',TM),LABEL='EVFRCOEX'\n.EVCX2   ANOP\n         BCTR  RX,R14              BACK UP OPERATOR POINTER 1, RETURN\n         EJECT\n* * * * * EVFRCA - FORCE EVALUATION OF ALL VALUES, RETURN TO CALLER   *\n*        LOOP CALLING EVFRCO UNTIL LEFT PAREN CODE FOUND              *\n*        NOTE THAT EVFRCO LEAVE RESULT IN RC, SO NEED NOT BE FETCHED. *\nEVFRCA   BALR  R14,0               SET R14 = @ NEXT INSTRUCTION\n         CLI   0(RX),EVLPC         IS CURRENT OP CODE LEFT PAREN\n         BNE   EVFRCO              IF NOT, CALL FORCE 1 OPERATOR SECTIO\n         SPACE 1\n         LH    RD,EVTRID           GET 1ST RELOCATE ID HALFWORD\n         LTR   RD,RD               IS IT ACCEPTABLE (0 OR +)\n         BM    EVZCXREL            IF <0, NEGATIVE RELOCATABLE TERM\n         CL    RC,AWFX6F           IS VALUE WITHIN 24 BITS\n         BH    EVZEXGTA            NO,ERROR BRANCH\n         IC    R2,EVALQ            GET LENGTH ATTRIBUTE - 1\n         LR    RE,R2               MOVE LENGTH ATTRIBUTE - 1 OVER\n         SR    RB,RB               SHOW THE EXPRESSION WAS OK\nEVZERROR EQU   *                   DEFINE LABEL FOR ERROR EXIT\nEVRET    $RETURN RGS=(R14-R6)\n         SPACE 1\n* * * * * ERROR EXIT SECTION                                          *\nEVZCXREL LA    RB,$ERCXREL         COMPLEX RELOCATIBILITY ILLEGAL\n         B     EVZERROR            EXIT, WITH ERROR CODE\nEVZEXGTA LA    RB,$EREXGTA         SHOW LARGER THAN 24 BITS\n         LTR   RC,RC               WAS VALUE POSITIVE\n         BP    EVZERROR            BRANCH IF SO, FALL THRU IS NOT\nEVZEXLTA LA    RB,$EREXLTA         SHOW EXPRESSION NEGATIVE\n         B     EVZERROR            GO RETURN WITH ERROR\nEVZILCH  LA    RB,$ERVILCH         ILLEGAL CHARACTER\n         B     EVZERROR            EXIT, WITH ERROR CODE\nEVZINVSY LA    RB,$ERINVSY          SHOW INVALID SYMBOL\n         B     EVZERROR             GO TO SHOW ERROR\nEVZPARN  LA    RB,$ERVPARN         TOO MANY PARENS\n         B     EVZERROR            EXIT, WITH ERROR CODE\nEVZSYNT  LA    RB,$ERVSYNT         SYNTAX\n         B     EVZERROR            EXIT, WITH ERROR CODE\nEVZTMTR  LA    RB,$ERVTMTR         TOO MANY TERMS IN EXPRESSION\n         B     EVZERROR            GO RETURN WITH ERROR\nEVZUNDEF LR    RA,R1                MOVE SCAN POINTER BACK\n         SR    RA,RY               DECREMNT BY 1 FOR BETTER POINTER\n         LA    RB,$ERUNDEF          SHOW UNDEFINED\n         B     EVZERROR             GO TO ERROR SECTION\n         EJECT\n* * * * * INTERNAL CONSTANTS                                          *\nEVCOFFS  EQU   *-2                 OFFSET BACKWARDS SMALLEST INDEX\n*              OFFSETS OBTAINED USING INDEX VALUE FROM AWTSYMT        *\n         DC    AL1(EVCLP,EVCRP,EVCBL,EVCPL,EVCPL,EVCMU,EVCDI)\n*        JUMP OFFSET TABLE FOR EVFRCO - FOR + - * / OPERATORS         *\nEVFRCT   DC    AL1(EVFRPL-EVFRJ,EVFRMI-EVFRJ,EVFRMU-EVFRJ,EVFRDI-EVFRJ)\nEVOPREC  EQU   *-2                 ORIGIN RIGHT FOR INDICES 2 UP\n         DC    AL1(0,0,0,1,1,2,2)  PRECEDENCES: ( X X + - * / (2-8)\n         SPACE 1\nEVCTAB   DS    0H                  TRANSITION TABLE\nEVCT1    EVCG  (PCHIH,1,ERR,SYNT,ERR,SYNT,LOCNT,4,ERR,SYNT,TERM,3,TERM,#\n               4,ERR,UNEX)         BEGINNING ( + - LAST FOUND\nEVCT2    EVCG  (PCHIH,1,ERR,SYNT,ERR,SYNT,ERR,SYNT,ERR,SYNT,TERM,3,ERR,#\n               RELO,ERR,UNEX)      * / OPERATORS LAST ENCOUNTERD\nEVCT3    EVCG  (PCTES,SYNT,PCZER,3,OPCHK,1,OPCHK,2,OPCHK,2,ERR,SYNT,ERR#\n               ,SYNT,PCTES,UNEX)   ABSOLUTE TERM WAS LAST\nEVCT4    EVCG  (PCTES,SYNT,PCZER,3,OPCHK,1,ERR,RELO,ERR,RELO,ERR,SYNT,E#\n               RR,SYNT,PCTES,UNEX) RELOCATABLE TERM LAST PREVIOUS\n         SPACE 1\n*              OPERATOR STACK - 1ST ENTRY IS CODE FOR (               *\nEVOPRS   DC    AL1(EVLPC)          BEGINNING OF OPERATOR STACK,LEFT PRN\n         DS    21C                 REMAINING SECTION OF EVOPRS\n         SPACE 1\n*              TERM STACK - COMPUTED VALUES KEPT TO 32 BITS.          *\nEVTRMS   DS    16F                 TERM STACK\n         SPACE 1\n*              SIGN CODE/ID STACK. EACH HALFWORD IS ASSOCIATED WITH   *\n*        CORRESPONDING FULLWORD IN EVTRMS.   FOR ABSOLUTE VALUES, THE *\n*        EVTRID ENTRY = 0, FOR RELOCATABLE VALUES, THE SECTION ID IS  *\n*        ENTERED IN THE 2ND BYTE OF A HALFWORD, WITH ZEROS IN THE 1ST *\n*        BYTE.  IF THE VALUE IS NEGATIVE, THE HALFWORD IS COMPLEMENTED*\nEVTRID   DS    16H                 SIGN CODE/ID STACK\n*              EVPCNT AND EVTRNM MUST BE IN ORDER, ON H BOUNDARY      *\nEVPCNT   DS    C                   PAREN COUNT - 0<=EVPCNT<=5\nEVTRNM   DS    C                   # TERMS LEFT (INIT TO 16\nEVALQ    DS    C                   LENGTH ATTRIVUTE - 1 OF EXPRESSION\n         DROP  RAT,R13,RZ          KILL USINGS\n         TITLE '*** IAMOP1 - MACHINE OPCODES - PASS 1 ***'\n**--> CSECT: IAMOP1   1   MACHINE OPERATIONS - PASS 1 . . . . . . . . .\n*.       THIS IS 1 OF 2 PASS 1,LEVEL 2 PROGRAMS.  IT PERFORMS ALL     .\n*.       PASS 1 MACHINE INSTRUCTION PROCESSING, INCLUDING ALIGNMENT   .\n*.       OF THE LOCATION COUNTER, SCANNING FOR LITERAL CONSTANTS,     .\n*.       AND BUILDING AN RCODBLK FOR THE STATEMENT.  THE RCODBLK      .\n*.       INCLUDES THE INSTRUCTION FORMAT TYPE, THE MACHINE CODE FOR   .\n*.       THE GIVEN INSTRUCTION, MASK (EXTENDED MNEMONICS), FLAGS      .\n*.       AND ALIGNMENT VALUES NEEDED, THE LENGTH ATTRIBUTE-1 FOR THE  .\n*.       INSTRUCTION, AND THE ADDRESS OF A LITERAL CONSTANT IN THE    .\n*.       LITERAL TABLE, IF THERE IS ONE USED.                         .\n*.       ENTRY CONDITIONS                                             .\n*.  RA = SCAN POINTER (ADDRESS OF 1ST CHARACTER OF OPERAND FIELD)     .\n*.  RC = ADDRESS OF OPCODE CONTROL TABLE ENTRY FOR OPCODE USED        .\n*.       EXIT CONDITIONS                                              .\n*.  RB = 0    NO ERRORS WERE ENCOUNTERED                              .\n*.     = >0   ERRORS WERE FOUND IN STATEMENT                          .\n*.  RC = @ RECORD CODE BLOCK(RCODBLK) FOR THE STATEMENT.              .\n*.       THE RCODBLK HAS ALL VALUES FILLED IN EXCEPT RCLOC(IARCLOC).  .\n*.  RD = LENGTH OF CODE - TO BE ADDED AFTER ALIGNMENT DONE            .\n*.       CALLS ERRTAG,LTENT1,SCANEQ                                   .\n*.       USES DSECTS: AVWXTABL,OPCODTB                                .\n*.       USES MACROS: $CALL,$CKALN,$GLOC,$LTENT1,$RETURN,$SAVE,$SLOC  .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nIAMOP1   CSECT\n         $DBG  90,*\n         USING AVWXTABL,RAT        NOTE MAIN TABLE USING\n         $SAVE RGS=(R14-R3),BR=R13,SA=IAMOSAVE\n         USING OPCODTB,RC          NOTE TABLE POINTER\n         MVC   IARCTYPE(3),OPCTYPE MOVE CODE BYTES OVER\n         DROP  RC                  NO LONGER NEED POINTER HERE\n         MVI   IARCLENG,RC$LEN     PUT IN NORMAL LENGTH-1\n         LM    R1,R3,AWZEROS       GET HANDY ZEROS\n         IC    R1,IARCHEX          GET HEX OPCODE\n         SRL   R1,6                SHIFT TO GET INDEX\n         IC    R3,IALENGS(R1)      GET LENGTH-1 FOR LENGTH ATTRIBUTE\n         STC   R3,IARCLQ           SAVE FOR L' ATTRIBUTE\n         SPACE 1\n         CLI   AVCESDID,0          WAS CODE PRECEDED BY A CSECT\n         BNE   IALICHK             CSECT OR DSECT BEFORE-BRANCH\n         SPACE 1\n         MVI   AVCESDID,2          NO, UNITIATED PRIVAT  CODE\n         OI    AVTAGS1,$IBSTAR1+$IBPRCD1    SHOW NO START, PRIV CODE IN\n         SPACE 1\nIALICHK  $CKALN 1,IALNOK           CHECK ALIGNMENT AND BRANCH OK\n         $GLOC R1                  GET LOCATION COUNTER VALUE\n         LA    R1,1(R1)            INCREMENT TO HALFWORD BOUNDARY\n         $SLOC R1                  SET NEW LOCATION COUNTE VALUE\n         EJECT\n*              SCAN FOR LITERAL OR END OF OPERAND FIELD               *\nIALNOK   EQU   *\n         $CALL SCANEQ              SCAN TO = OR LBANK\n         CLI   0(RA),C' '          ARE WE TO END OF STATEMENT\n         BE    IARETA              YES,WE'RE DONE\n         CLI   0(RA),C'='          MAKE SURE IT IS =\n         BNE   IARETA              IF NOT, ERROR, BUT DON'T FLAG NOW\n         SPACE 1\n*              LITERAL FOUND- HAVE IT SAVED, WITH POINTER VALUES.\n         $CALL LTENT1              CALL TO ENTER LITERAL\n         LTR   RB,RB               WAS LITERAL OK\n         BNZ   IAERROR             NO IT WASN'T,BRANCH\n         MVI   IARCLENG,RC$LEN2    SET LENGTH TO LENGTH WITH LITERAL\n         ST    RC,IARCLITA         SAVE ADDRESS OF LITERAL\n         SPACE 1\nIARETA   EQU   *                   EXIT LABEL\n         AIF   (&$COMNT EQ 0).IANOCOM       SKIP IF NO COMMENT CHEK\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*              MACHINE INSTRUCTION COMMENT COUNTING ROUTINE.          *\n*        IF THE COMMENT CHECK OPTION IS SPECIFIED, EITHER BY THE      *\n*   COMNT PARM OPTION, OR BY ACCOUNT NUMBER SETTING,  THIS CODE       *\n*   COUNTS THE NUMBER OF MACHINE INSTRUCTIONS, AND ALSO COUNTS THE    *\n*   APPROXIMATE NUMBER OF THEM WHICH HAVE A COMMENT OF 4 OR MORE      *\n*   NONBLANK CHARACTERS.  (SEE VARIABLES AVMACHIN  AND  AVCOMNTN).    *\n*   THESE VALUES ARE INITIALIZED TO ZERO IN OUINT1, AND ARE USED IN   *\n*   OUEND2 TO MAKE SURE THAT STUDENT PROGRAMMERS PUT A GIVEN AMOUNT   *\n*   OF COMMENTS ON THEIR INSTRUCTIONS (I.E. &$COMNT PER CENT OF THE   *\n*   MACHINE INSTRUCTIONS MUST HAVE COMMENTS ARE ELSE THE PROGRAM WILL *\n*   NOT BE EXECUTED.).                                                *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n         TM    AVTAGS2,AJOCOMNT    IS COMMENT CHK IN EFFECT\n         BZ    IARETA2             NO, SO DON'T CHECK THEM\n         SPACE 1\n         LA    R1,1                SET R1 FOR USEFUL VALUE, BXHING\n         AR    RA,R1               BUMP SCAN PTR BEYOND POSSIBLE '(LIT)\n         LH    RE,AVMACHIN         GET CURRENT # MACHINE INSTS\n         AR    RE,R1               INCREMENT FOR THIS INSTRUCTION\n         STH   RE,AVMACHIN         STORE UPDATED COUNTER BACK\n         SPACE 1\n*              SCAN TO FIND THE COMMENT FIELD, IF ANY.\n         CLI   0(RA),C' '          IS NEXT CHAR BLANK\n         BNE   *+8                 NO-JUMP OUT, COMMENT BEGUN\n         BXH   RA,R1,*-8           BUMP SCAN PTR BY 1, LOOP\n         SPACE 1\n         L     RE,AVSOLAST         GET @ BLANK BEFORE AFTER QUOTE\n         LR    RD,R1               MOVE A 1 TO REG RD FOR BXLE INCREM\n         LA    R1,4                ***** # NONBLANKS REQUIRED *********\n         SPACE 1\n*              LOOP UNTIL EITHER AFTERQUOTE FOUND OR 4 NONBLANKS.\n         CLI   0(RA),C' '          IS THIS A BLANK\n         BNE   *+12                NO, SKIP TO BCT TO COUNT IT\n         BXLE  RA,RD,*-8           INCREMENT SCN PTR, LOOP BACK\n         B     IARETA2             FELL THRU - SHORT COMMENT-DON'T COUN\n         BCT   R1,*-8              COUNT # CHARS, LOOP TO BXLE\n         SPACE 1\n*              LEGITAMATE COMMENT FILED-GIVE PROGRAMMER CREDIT FOR IT.\n         LH    RE,AVCOMNTN         GET ACCUMULATD # COMMENTS\n         AR    RE,RD               INCREMENT BY 1 FROM RD\n         STH   RE,AVCOMNTN         RESTORE UPDATED # COMMENTS\n         SPACE 1\n.IANOCOM ANOP\n*              POINT TO OUR RCB AND RETURN TO MAIN CONTROL.\nIARETA2  LA    RC,IARCB            SHOW @ OF OUR RCB FOR MAINPROG\n         LA    RD,1(R3)            GET TOTAL LENGTH IN RD FOR RETURN\nIARET    $RETURN RGS=(R14-R3)      RETURN TO CALLER\n         SPACE 1\n* * * * * INDIVIDUAL ERROR SECTIONS\nIAERROR  $CALL ERRTAG              CALL ERROR FLAGGING ROUTINE\n         B     IARETA              GO RETURN\n         EJECT\n* * * * * INTERNAL CONSTANTS                                          *\nIALENGS  DC    HL1'1,3,3,5'        LENGTH-1 BYTES FOR EACH INST TYPE\n         SPACE 1\n* * * * * INTERNAL VARIABLES                                          *\n*        RCB ENTRIES FOR IAMOP1                                       *\nIARCB    DS    0D                  RECORD CODE BLOCK\nIARCLENG DS    C                   LENGTH OF RCB\nIARCLOC  DS    AL3                 LOCATION COUNTER VALUE (BY MOCON1)\nIARCTYPE DS    C                   PRIMARY TYPE BYTE\nIARCHEX  DS    C                   HEX OPCODE FOR MACH INSTS\nIARCMASK DS    C                   MASK/LITERAL TAGS/ALIGNMENT\nIARCLQ   DS    C                   FOR L'*\nIARCLITA DS    A                   ADDRESS OF A LITERAL,IF EXISTS\nIARCEND  DS    0C                  END OF RCB ENTRY\n         DROP  RAT,R13             CLEAR USING\n         TITLE '*** IBASM1 - ASSEMBLER OPCODES - PASS 1 ***'\n**--> CSECT: IBASM1   1   ASSEMBLER INSTRUCTIONS - PASS 1 . . . . . . .\n*.       THIS MODULE IS 1 OF THE 2 PASS 1,LEVEL 2 ROUTINES OF THE     .\n*.       ASSIST ASSEMBLER.  IT PERFORMS ALL PROCESSING FOR ASSEMBLER  .\n*.       INSTRUCTIONS DURING PASS 1, INCLUDING SCANNING, MODIFYING    .\n*        LOCATION COUNTERS, AND BUILDING AN RCODBLK FOR THE STMT.     .\n*.       ENTRY CONDITIONS                                             .\n*.  RA = SCAN POINTER (ADDRESS OF 1ST CHARACTER OF OPERAND FIELD)     .\n*.  RC = ADDRESS OF OPCODE CONTROL TABLE ENTRY FOR OPCODE USED        .\n*.       EXIT CONDITIONS                                              .\n*.  RB = 0    NO ERRORS WERE ENCOUNTERED                              .\n*.     = >0   ERRORS WERE FOUND IN STATEMENT                          .\n*.  RC = ADDRESS OF RECORD CODE BLOCK (RCB)                           .\n*.  RD = LENGTH OF CODE - TO BE ADDED AFTER ALIGNMENT DONE            .\n*.       CALLS CCCON1,CODTL1,ERRLAB,ERRTAG,ESCSEC,ESENX1              .\n*.       CALLS EVALUT,LTDMP1,SDBCDX,SDDTRM                            .\n*.       USES DSECTS: AVWXTABL,CNCBLOCK,IBPSECT,OPCODTB,SYMSECT       .\n*.       USES MACROS: $AL2,$ALIGR,$CALL,$CKALN,$GLOC,$RETURN,$SAVE    .\n*.       USES MACROS: $SDEF,$SLOC,IBPRTAB                             .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n         SPACE 1\nIBASM1   CSECT\n         $DBG  90,*\n         SPACE 1\n* * * * * REGISTER ALLOCATION AND USAGE IN IBASM1 * * * * * * * * * * *\n*   R0 = WORK REGISTER. SCAN POINTER SAVED HERE BY SOME INTERNAL SUBRS*\n*   R1 = 1     USEFUL VALUE, IN ODD REG FOR BXH'ING SCAN POINTER.     *\n*   R2 = BYTE REGISTER (HI-ORDER 3 BYTES = 0).                        *\n*   R3(IBLN)   LENGTH TO BE ADDED TO LOCATION COUNTER (INIT = 0).     *\n*   R4(IBLB)   @ IN SYMBOL TABLE OF LABEL.  IF NO LABEL, = 0.         *\n*   R5(IBLR)   INTERNAL LINKAGE REGISTER.                             *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nIBLN     EQU   R3                  LENGTH REGISTER\nIBLB     EQU   R4                  LABEL POINTER,IF EXISTS\nIBLR     EQU   R5                  LINKAGE REGISTER\nIBMAXCON EQU   10                  MAXIMUM NUMBER OF CONSTANTS\n         SPACE 1\n         USING AVWXTABL,RAT        NOTE MAIN TABLE USING\n         $SAVE RGS=(R14-R6),BR=R13,SA=IBSAVE\n         SPACE 1\n*              INITIALIZATION - SET UP REGISTERS,GET OPCODTB CODES    *\n         LA    R1,1                SET UP USEFUL VALUE IN R1\n         SR    R2,R2               CLEAR REGISTER\n         SR    IBLN,IBLN           SET LENGTH TO 0\n         STM   R2,IBLN,IBRCB       ZERO OUT RCB\n         USING OPCODTB,RC          NOTE OPCODE TABLE\n         MVC   IBRCTYPE(3),OPCTYPE MOVE CODE BYRS OVER\n         MVC   IBRCLQ,OPCMASK      PLACE DEFAULT LENGTH ATTRIBUTE IN\n         DROP  RC                  NO LONGER NEEDED\n         MVI   IBRCLENG,RC$LEN     MOVE IN NORMAL LENGTH-1 OF RCB\n         SR    RB,RB               CLEAR, TYPICAL NO ERROR SETTING\n         SPACE 1\n*              TEST FOR LEGALITY/FLAG START INSTRUCTION               *\n         TM    AVTAGS1,$IBSTAR1+$IBDSEC1     CHECK TAGS1 SETTING\n         BNZ   IBALAB              ALREADY SET OR SHOUDLN'T-SKIP\n         TM    IBRCHEX,$IBSTAR1    IS THIS A START PREVENTER\n         BZ    IBALAB              NO IT ISN'T,DON'T FLAG\n         OI    AVTAGS1,$IBSTAR1    FLAG THE START NO LONGER GOOD\n         CLI   AVCESDID,0          DOES A CSECT EXIST\n         BNE   IBALAB              SOMETHING EXIST-BRANCH\n         MVI   AVCESDID,2          UNITIATED PRIV CODE STARTS NOW\n         OI    AVTAGS1,$IBPRCD1    SHOW PRIV CODE EXISTS NOW\n         SPACE 1\n*              CHECK FOR LABEL WHERE NONE ALLOWED,OR MISSING WHERE REQ*\nIBALAB   L     IBLB,AVLABPT        GET ADDRESS OF LABEL,IF EXISTS\n         LTR   IBLB,IBLB           SEE IF A LABEL EXISTS\n         BNZ   IBANOLB             SKIP IF LABEL EXISTS\n         TM    IBRCHEX,IBNENAM     NO NAME EXISTS,SEE IF IT IS REQUIRED\n         BZ    IBAOPTST            NO NAME NEEDED,SKIP TO CHEK OPERAND\n         LA    RB,$ERNONAM         NAME IS NEEDED,DOESN'T EXIST-ERR\n         B     IBERLAB             GO FLAG ERROR-NO LABEL\n         SPACE 1\nIBANOLB  TM    IBRCHEX,IBNONAM     IT HAS A LABEL,SEE IF IT IS ALLOWED\n         BZ    IBAOPTST            NAME IS ALLOWED,GO CHK OPERAND\n         LA    RB,$ERILLAB         LABEL NOT PERMITTED\n         $CALL ERRLAB              FLAG ERROR AT LABEL FIELD\n         SPACE 1\n*              IF OPERAND IS OMITTED, CHECK THAT ITS NOT ILLEGALLY SO *\nIBAOPTST CLI   0(RA),C' '          SEE IF OPERAND EXISTS\n         BNE   IBALEV2             OPERAND EXISTS-JUMP\n         TM    IBRCHEX,IBOMOP      MAKE SURE OPERAND MAY BE OMITTED\n         BZ    IBERNOPR            MISSING OPERAND-ILLEGAL\n         SPACE 1\nIBALEV2  IC    R2,IBRCTYPE         GET TYPE BYTE FOR TABLE\n         LH    R14,IBAJUMP-$IB(R2) GET OFFSET TO INDIVIDUAL SECTION\nIBASMJ   B     IBASMJ(R14)         BRANCH TO INDIVIDUAL SECTION\n         SPACE 1\nIBARBZER SR    RB,RB               CLEAR RB TO SHOW NO ERRORS\nIBASCAN  EQU   *                   NO LONGER NEED SCAN TO END OF FIELDS\n* * * * * EXIT CODE                                                   *\nIBRETA   LR    RD,IBLN             PLACE LENGTH TO BE ADDED TO LOCCNTR\n         LA    RC,IBRCB            PLACE ADDRESS FOR MAIN PROG\nIBRET    $RETURN RGS=(R14-R6)\n         SPACE 2\n* * * * * CCW * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nIBCCW    EQU   *\n         LA    RB,$ERNOIMP         NOT CURRENTLY IMPLEMENTED\n         B     IBERRORA            HAVE THIS FLAGGED FOR NOW\n         EJECT\n* * * * * CNOP  * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*        SETS RCMASK = # BYTES TO BE GENERATED (=0,2,4,6).            *\nIBCNOP   $GLOC IBLB                GET VALUE OF LOCATION COUNTER\n         $CKALN 1,IBCNOL           CHECK HALFWORD ALIGNMENT\n         AR    IBLB,R1             INCREMENT LOCCNTR BY 1 TO ALIGN\n         $SLOC IBLB                SET LOCCNTR VALUE\n         SPACE 1\nIBCNOL   BAL   IBLR,IBCNEV         CALL EXPRESSION EVAL, CHECK ROUTINE\n         STC   RC,AVFWORK1         STORE VALUE,SO CAN TEST FOR ODD\n         TM    AVFWORK1,1          WAS THE VALUE ODD\n         BZ    *+8                 SKIP AND CONTINUE IF EVEN-OK\n         BCT   RA,IBERICNO         MOVE SCAN PTR BACK, GO FLAG ERROR\n         CLI   0(RA),C','          IS DELIM COMMA\n         BNE   IBERIND             NO,ERROR\n         AR    RA,R1               ADD 1 TO SCAN POINTER\n         LR    IBLN,RC             SAVE 1ST OPERAND HERE\n         SPACE 1\n         BAL   IBLR,IBCNEV         CALL EXPRESSION EVAL, CHECK\n         SR    RC,R1               GET 2ND OPERAND - 1\n         C     RC,AWF3             WAS 2ND OPERAND ORIGINALLY 4\n         BE    *+12                YES, SKIPP IF OK\n         C     RC,AWF7             WAS 2ND OPERAND ORIGINALLY 8\n         BNE   IBERICNO            NO, SO ERROR\n         NR    IBLB,RC             GET LAST 2-3 BITS OF LOCCNTR\n         LA    IBLN,1(IBLN,RC)     GET 1ST OPERAND + 4 OR 8\n         SR    IBLN,IBLB           GET (1ST OPRND + 4 OR 8) - LOCNTR\n         NR    IBLN,RC             GET LAST 2-3 BITS OF RESULT = LENGTH\n         STC   IBLN,IBRCMASK       STORE RESULTING LENGTH FOR PASS 2\n         CLI   0(RA),C' '          WAS THIS ALL\n         BE    IBRETA              YES, SO DONE\n         B     IBERIND             NO, INVALID DELIMIETER\n         SPACE 1\nIBCNEV   $CALL EVALUT              CALL EXPRESSION EVALUATOR\n         LTR   RB,RB               WAS EXPRESSION OK\n         BNZ   IBERRORA            NO ,ERROR, FLAG IT\n         LTR   RD,RD               WAS EXPRESSION ABSOLUTE\n         BCR   Z,IBLR              YES, RETURN TO CALLING SECTION\n         B     IBERICNO            NO, CNOP ERROR\n         SPACE 2\n* * * * * CSECT * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nIBCSECT  SR    RB,RB               SHOW THIS IS A CSECT CALL\n         B     IBESCALL            GO TO COMMON CODE SECTION\n         SPACE 2\n* * * * * DROP  * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nIBDROP   EQU   IBASCAN             NOTHING TO DO THIS PASS\n         AIF   (&$DEBUG).IBNOD1    SKIP IF NOT DEBUG MODE\n         SPACE 1\n* * * * * DEBUG * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nIBDEBUG  MVC   IBRCHEX,0(RA)       GET 1ST CHAR,EITHER 1 OR 2\n         LA    RA,2(RA)            BUMP SCAN POINTER PAST 1, OR 2,\n         BAL   IBLR,IBEVCALL       CALL EXPRESSION EVALUATOR FOR VALUE\n         STC   RC,IBRCMASK         SAVE THE BYTE CODE\n         CLI   IBRCHEX,C'2'        WAS THIS PASS 2 ONLY\n         BE    IBRETA              YES,DON'T CHANGE AVDEBUG\n         STC   RC,AVDEBUG          SAVE THE NEW FLAG INTO DEBUG\n         B     IBRETA              GO RETURN\n.IBNOD1  ANOP\n         EJECT\n* * * * * DC - DS * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*        SETS RCMASK = # OPERANDS IN DC STMT (= 1 TO IBMAXCON).       *\n*        ADDS TO RCODBLK 1 CNCBLOCK FOR EACH OPERAND.                 *\n*        SETS RCLQ = LENGTH ATTRIBUTE - 1 OF 1ST OPERAND.             *\n*        **NOTE** MUST CHECK FOR MISSING QUOTE, ELSE ABEND MAY OCCUR. *\n         SPACE 1\n* * * * * REGISTER ALLOCATION FOR DC-DS PROCESSING  * * * * * * * * * *\n*   R0 = CURRENT NUMBER OF OPERANDS PROCESSED                         *\n*   R1 = 1                         CONSTANT FOR BXHING                *\n*   R2 = CURRENT LENGTH-1 OF IBRCB,WILL BE INCREMENTED BY DC'S        *\n*   RW(IBLN) = LOCATION COUNTER FOR BEGINNING OF STATEMENT            *\n*   RX = 0 ==> DS, 4 ==> DC STATEMENT.                                *\n*   RY = MAXIMUM # OPERANDS ALLOWED(= IBMAXCON IF DC, = 4095 IF DS).  *\n*   RZ = ADDRESS OF CURRENT CNCBLOCK PART OF IBRCB BEING FILLED(DC'S) *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nIBDC     LA    RX,4                SHOW THIS IS A DC\n         LA    RZ,IBRCONS          ADDRESS OF 1ST CONST BLOCK\n         LA    RY,IBMAXCON         MAXIMUM NUMBER OF CONSTANTS ALOOWED\n         B     IBDCDS              BRANCH TO COMMON CODE\n         SPACE 1\nIBDS     SR    RX,RX               CLEAR TO SHOW CODTL1 THIS IS DS\n         LA    RY,4095             PUT HUGE NUMBER SO WON'T FLAG EXCED\nIBDCDS   SR    R0,R0               CLEAR TO SHOW NO OPERANDS RIGHT NOW\n         IC    R2,IBRCLENG         GET CURRENT LENGTH OF IBRCB\n         $GLOC IBLN                GET THE LOCATION COUNTER\n         SPACE 1\n*              LOOP FOR 1 OR MORE OPERANDS.                           *\nIBDSCAL  LR    RB,RX               SHOW CODTL1 WHETHER DC OR DS\n         $CALL CODTL1              CALL THE OPERAND PROCESSOR\n         LTR   RB,RB               WAS THERE AND ERROR\n         BNZ   IBDCENDA            IF RB^=0, ==> ERROR\n         SPACE 1\n         USING CNCBLOCK,RC         RC POINTS AT CODTL1'S CNCBLOCK\n         IC    RB,CNCLEN           GET LENGTH-1 OF CONSTANT\n         TM    CNCTYP,$CNALN       IS ALIGNMENT REQUIRED\n         BZ    IBDSLQ              DO NOT ALIGN UNLESS NEEDED\n         $ALIGR IBLN,RB\nIBDSLQ   BXH   R0,R1,IBDSADD       SKIP FOLLOWING 2 STMTS IF NOT 1ST\n         $SLOC IBLN                SET LOCATION COUNTER FOR STMT START\n         STC   RB,IBRCLQ           SAVE THE LENGTH ATTRIBUTE\nIBDSADD  AR    IBLN,RE             ADD THE TOTAL LENGTH OVER\n         LTR   RX,RX               IS THIS A DS OR A DC\n         BZ    IBDSOPA             IT IS A DS, BRANCH\n         CR    R0,RY               COMPARE # OF OPS TO MAXIMUM ALLOWED\n         BH    IBDCEXT             IF EXCEEDS, FLAG ERROR\n         SPACE 1\nIBDCMOV  MVC   0(CNC$LEN,RZ),CNCBLOCK        MOVE BLOCK OVER(DC ONLY)\n         LA    R2,CNC$LEN(R2)      INCREMENT THE LENGTH\n         LA    RZ,CNC$LEN(RZ)      BUMP POINTER OF NEXT EMPTY SPACE\nIBDSOPA  CLI   0(RA),C' '          IS THIS THE END\n         BE    IBDCHEKA            GO TO CHECK FOR MISSING DELIMT\n         CLI   0(RA),C','          IS DELIM ACTUALLY A COMMA\n         BNE   IBDCINDL            NO, BAD USER, GET HIM\n         BXH   RA,R1,IBDSCAL       BUMP SCAN POINT AND GET NEXT OPERAND\n         SPACE 1\nIBDCHEKA C     RA,AVSOLAST         COMPARE TO @ BLANK BEFORE AFTER '\n         BL    IBDCEND             LOW, THEREFOR NO MISSING '\n         LA    RB,$ERNODLM         MISSING ', ERROR-SHOW IT\n         B     IBDCENDA            HAVE IT FLAGGED, , NO ASMBLY\n         SPACE 1\nIBDCINDL LA    RB,$ERINVDM         INVALID DELIMITER-SHOW IT\n         B     IBDCENDA            GO FLAG ERROR\nIBDCEXT  LA    RB,$ERDCEXT         TOO MANY CONSTANT OPERANDS IN DC\nIBDCENDA $CALL ERRTAG              HAVE THE ERROR FLAGGED\n         LA    R2,RC$LEN           GET REGULAR LENGTH-1 BACK\nIBDCEND  S     IBLN,AVLOCNTR       GET DIFFERENCE, TO BE ADDED TO LOCCN\n         STC   R0,IBRCMASK         SAVE NUMBER OF OPERANDS\n         STC   R2,IBRCLENG         PLACE THE LENGTH-1 BACK INTO RCB\n         B     IBRETA              RETURN\n         DROP  RC\n         SPACE 2\n* * * * * DSECT * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nIBDSECT  LA    RB,4                SHOW ESD ROUTINE THIS IS DSECT\n         B     IBESCALL            GO CALL ROUTINE\n         SPACE 2\n* * * * * EJECT * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nIBEJECT  EQU   IBRETA              NOTHING TO DO\n         SPACE 2\n* * * * * END PLUS COMMON END-LTORG CODE* * * * * * * * * * * * * * * *\nIBEND    LR    R0,RA               SAVE SCAN POINTER\n         $CALL LTDMP1              CALL LITERAL DUMP\n         LR    IBLN,RA             MOVE LENGTH REQUIRED OVER\n         TM    AVTAGS1,$IBDSEC1    ARE WE IN A DSECT RIGHT NOW\n         BO    IBEND1              SKIP OVER IF SO,AVLOCHIH IS OK\n         SPACE 1\n         A     RA,AVLOCNTR         ADD LOCATION COUNTER TO INCREMENT\n         C     RA,AVCSHIH          IS THIS LARGE THAN PREVIOUS LARGEST\n         BNL   *+8                 YES,SO USE JUST COMPUTED VALUE\n         L     RA,AVCSHIH          BACKWARDS ORG,USE PREVIOUS HIGHEST\n         ST    RA,AVLOCHIH         SAVE HIGHEST VALUE OF CODE,USE IT\nIBEND1   LR    RA,R0               RESTORE THE SCAN POINTER\n         B     IBARBZER            GO ZERO RB TO SHOW OK\n         SPACE 2\n* * * * * ENTRY * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nIBENTRY  SR    RB,RB               SHOW ESENX1 THIS IS ENTRY\n         B     IBENEXCL            GO CALL ROUTINE\n         SPACE 2\n* * * * * EQU * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*        SETS RCEQU = VALUE OF SYMBOL (IF EVALUATION COMPLETE).       *\n*        ALSO ZEROS AVLABPT SO THAT MPCON0 DOESNT REDEFINE SYMBOL.    *\nIBEQU    EQU   *                   SHOW LENGTH 4> THAN USUAL\n         MVC   AVLABPT,AWZEROS     ZERO IT, MOCON1 WILL THINK NO LABEL\n         BAL   IBLR,IBEVCALL       CALL GEN EXPRESSION EVALUTAR\n         BNZ   IBERRORA            NOGOOD, QUIT,FLAG ERROR.\n         SPACE 1\n         USING SYMSECT,IBLB        NOT SYMBOL TABLE USING\n         CLI   0(RA),C' '          RIGHT DELIMITER\n         BNE   IBERIND             NO,ERROR\n         $SDEF RC,RD,RE            DEFINE THE SYMBOL\n         DROP  IBLB                ERASE USING\n         ST    RC,IBRCEQU          PLACE VALUE FOR LATER USE\n         MVI   IBRCLENG,RC$LEN2    SHOW LENGTH 4> THAN USUAL\n         B     IBRETA              GO RETURN\n         SPACE 2\n* * * * * EXTRN * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nIBEXTRN  LA    RB,2                SHOW ESENX1 THIS IS EXTRN CALL\nIBENEXCL $CALL ESENX1              CALL EXTRN-ENTRY ROUTINE\n         LTR   RB,RB               WERE THERE ERRORS\n         BZ    IBRETA              NO ERRORS-QUIT\n         B     IBERRORA            GO HAVE ERROR FLAGGED AND QUIT\n         SPACE 2\n* * * * * LTORG * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nIBLTORG  EQU   IBEND               USE SAME CODE. LTDMP1 ALIGNS LOCNTR.\n         SPACE 2\n* * * * * ORG * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nIBORG    CLI   0(RA),C' '          WAS OPERAND OMITTED\n         BE    IBORGOM             YES,OMITTED\n         BAL   IBLR,IBEVCALL       GET EXPRESSION EVALUATED\n         BNZ   IBERRORA            IF ERROR,RETURN\n         CLI   0(RA),C' '          MAKE SURE ENDS WITH ' '\n         BNE   IBERIND             INVALID DELIM\n         IC    R2,AVCESDID         GET ESDID\n         CR    R2,RD               MAKE SURE THEY ARE SAME            7\n         BNE   IBERORG             WRONG SECTION - BAD ORG\n         C     RC,AVCSLOW          IS IT LOWER THAN LOWEST LEGAL VALUE\n         BL    IBERORG             LOWERR THAN LOWEST LEGAL, ERROR\n         SPACE 1\n         L     R0,AVCSHIH          GET HIGHEST VALUE\n         C     R0,AVLOCNTR         IS HIGHEST NOT HIGHER THAN LOCCNTR\n         BNL   IBORGH1             SKIP IF HIGH VALUE>=LOCCNTR\n         $GLOC R0                  GET CURRENT LOCCNTR\nIBORGH1  CR    R0,RC               IS HIGHEST VALUE LESS THAN NEW\n         BNL   IBORGH2             NO IT ISNT,BRANCH\n         LR    R0,RC               NEW HIGHEST VALUE\nIBORGH2  ST    R0,AVCSHIH          STORE NEW HIGH VALUE\n         $SLOC RC                  SET LOCATION COUNTER\n         B     IBRETA              GO RETURN\n         SPACE 1\n*              OMITTED OPERAND IN ORG==>SET TO HIGHEST UNUSED VALUE   *\nIBORGOM  $GLOC R0                  GET LOCCNTR\n         C     R0,AVCSHIH          COMPARE TO HIGHEST VALUE\n         BNL   IBORGO1             SKIP IF LOCCNTR HIGH\n         L     R0,AVCSHIH          USE HIGHEST VALUE\nIBORGO1  ST    R0,AVCSHIH          SET POSSIBLY NEW HIGHEST LOCCNTR VAL\n         $SLOC R0                  SET NEW LOCCNTR VALUE\n         B     IBRETA              GO RETURN\n         EJECT\n* * * * * PRINT * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*        SETS RCMASK = VALUE OF PRINT CODE TO BE SET BY PRINT.        *\n*        ALSO IMMEDIATELY SETS AVPRINT1 TO CORECT PRINT CONTROL.      *\nIBPRINT  LA    RE,IBPLAST          ADDRSS OF LAST IN TABLE\n         SR    RD,RD               CLEAR FOR INSERTIONS\n         MVI   AVFWORK1,0          INIT=0 FOR CORRECTNESS TESTS\n         MVC   IBRCMASK,AVPRINT1   COPY CURRENT PRINT STATUS\n         SPACE 1\n*              LOOP TO LOOK UP NEXT OPERAND IN LEGAL PRINT LIST       *\nIBPLOOP  LA    R14,IBPTAB          @ BEGINNING OF TABLE\n         USING IBPSECT,R14         NOTE THE TABLE\n         SPACE 1\nIBPLOOPA IC    RD,IBPLENG          GET LENGTH-1 OF ENTRY\n         STC   RD,*+5              STORE L-1 INTO CLC INST\n         CLC   0($CHN,RA),IBPOPR   COMPARE INCOMING OPERAND\n         BNE   IBPLOOPB            GO TO BOTTOM IF NOT\n         SPACE 1\n         MVC   *+7(1),IBPVO        COPY BIT TO CHECK INTO TM NEXT\n         TM    AVFWORK1,$          TEST: SEE IF 2 OF SAME OR CONTRADCT\n         BNZ   IBERINVF            INVALID\n         OC    AVFWORK1(1),IBPVO   OR IN: RECORD FOR COMPATIBLITY TST\n         OC    IBRCMASK,IBPVO      SET DESIRED BIT DEFINITELY = 1\n         XC    IBRCMASK,IBPVX      XOR: SET BIT OFF IF REQUIRED OFF\n         MVC   AVPRINT1,IBRCMASK   KEEP AVPRINT1 SAME VALUE AS RCMASK\n         LA    RA,1(RD,RA)         BUMP SCP TO DELIMITER\n         CLI   0(RA),C' '          IS THIS THE END\n         BE    IBRETA              YES,RETURN\n         CLI   0(RA),C','          CHECK DELIMITER\n         BNE   IBERIND             ERROR IF NOT\n         BXH   RA,R1,IBPLOOP       GO BACK FOR NEXT OP,BUMP SCPTR\n         SPACE 1\nIBPLOOPB LA    R14,IBPOPR-IBPSECT+1(R14)     INCREMENT BY RITHT OFFSET\n         BXLE  R14,RD,IBPLOOPA     INCREMENT WITH VARIABLE LENGTH\n         B     IBERINVF            IF FALSS THRU==>UNRECOGNIZABLE\n         DROP  R14                 CLEAR USING\n         SPACE 2\n* * * * * SPACE * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*        SETS RCMASK = # LINES TO BE SPACED. OMITTED OPERAND ==> 1.   *\nIBSPACE  CLI   0(RA),C' '          IS OPERAND OMITTED\n         BE    IBRETA              SKIP CALL,LEAVE IBRCMASK=1\n         $CALL SDDTRM              GET VALUE FOR SPACING\n         LTR   RB,RB               WAS VALUE OK\n         BNZ   IBERRORA            BRANCH IF ERROR\n         LTR   RC,RC               WAS VALUE ^=0\n         BZ    IBRETA              RETURN IF =0,LEAVE 1 AS SPACE VALUE\n         STC   RC,IBRCMASK         STORE VALUE FOR PASS 2.\n         B     IBRETA              RETURN\n         EJECT\n* * * * * START PLUS COMMON START,DSECT,CSECT CODE  * * * * * * * * * *\n*        SETS RCMASK = NEW CURRENT ESDID NUMBER.                      *\n*        START SETS ITS VALUE INTO AVLOCLOW&AVFENTER FOR INIT.        *\nIBSTART  TM    AVTAGS1,$IBSTAR1    IS START NO LONGER ALLOWED\n         BO    IBSTERR             BRANCH-ERROR\n         SR    RC,RC               CLEAR FOR VALUE IF OMITTED\n         CLI   0(RA),C' '          WAS OPERAND OMITTED.\n         BE    IBESCALA            YES,GO CALL SED ROUTINE\n         $CALL SDBCDX              GET SELF-DEFINING TERM\n         LTR   RB,RB               WAS VALUE OK\n         BP    IBERRORA            BRANCH, ERROR CODE IN RB\n         BM    IBERINVF            RB=-4, NOT SELF-DEFTERM, ERROR\n         CLI   0(RA),C' '          MAKE SURE DELIMITER OK\n         BNE   IBERIND             INVALID DELIMITER\n         LA    RB,7                FOR DBLWD ALIGNMENT\n         $ALIGR RC,RB              ALIGN STARTING VALUE TO *8\n         ST    RC,AVLOCLOW         THIS IS NOW LOWEST LOC(UT WANTS IT)\n         ST    RC,AVFENTER         STORE FOR BEGINNING @\nIBESCALA LA    RB,2                SHOW ESD ROUTINE THIS IS A START\n         SPACE 1\n*              COMMON CODE - START, DSECT, CSECT.\nIBESCALL LR    R0,RA               SAVE SCAN POINTER\n         $CALL ESCSEC              CALL FOR CSECT,DSECT,OR START\n         OI    AVTAGS1,$IBSTAR1    FLAG NO MORE STARTS\n         LR    RA,R0               RESTORE SCAN POINTER\n         LTR   RB,RB               CHECK FOR ERRPRS\n         BNZ   IBERLAB             GO HAVE ERRORS FLAGGED IF NEEDED\n         MVC   IBRCMASK,AVCESDID   KEEP NEW ESDID VALUE\n         B     IBRETA              RETURN\n         SPACE 2\n* * * * * TITLE * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*        SETS RCMASK = LENGTH OF TITLE OPERAND FIELD.                 *\nIBTITLE  CLI   0(RA),C''''         MAKE SURE DELIM OK\n         BNE   IBERIND             ERROR IF NOT\n         AR    RA,R1               BUMP SCAN POINTER BY 1\n         $CALL CCCON1              HAVE THE TITLE CHECKED\n         LTR   RB,RB               WAS THERE ERROR\n         BNZ   IBERRORA            YES,GO FLAG IT\n         CLI   1(RA),C' '          MAKE SURE ENDS WITH QUOTE BLANK\n         BNE   IBERIND             BRANCH IF ERROR\n         C     RA,AVSOLAST         WAS IT >= @ BLANK BEFORE AFERQUOTE\n         BNL   IBERNODL            TOO LONG, MISSING DELIMITER\n         SR    RC,R1               S RC,=F'1' GET LENGTH-1 AS NEEDED\n         STC   RC,IBRCMASK         SAVE THE LEGNTH REQUIRED\n         BXH   RA,R1,IBRETA        BUMP SCAN POINTER AND RETURN\n         SPACE 2\n* * * * * USING * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nIBUSING  EQU   IBASCAN             NOTHING TO DO THIS PASS\n         EJECT\n* * * * * INDIVIDUAL ERROR EXITS                                      *\nIBERNODL LA    RB,$ERNODLM         MISSING DELIMITER ERROR\n         B     IBERRORA            GO FLAG AND EXIT\nIBERICNO LA    RB,$ERICNOP         ILLEGAL CNOP OPERAND COMBINATION\n         B     IBERRORA            GO TO FLAG\nIBERIND  LA    RB,$ERINVDM         INVALID DELIMITER\n         B     IBERRORA            SET ERROR CODE AND RETUN\nIBERINVF LA    RB,$ERINVF          ILLEGAL FIELD OF SOME SORT\n         B     IBERRORA            GO FLAG IT\nIBERNOPR LA    RB,$ERNOOPR         MISSING OPERAND\n         B     IBERRORA            GO PUT OUT ERROR CODE\nIBERORG  LA    RB,$ERILORG         ILLEGAL ORG\n         B     IBERRORA            GO FLAG IT\nIBSTERR  LA    RB,$ERSTART         SHOW BAD START, FALL THRU-IBERRORA\n         SPACE 2\n* * * * * ALL ERRORS EXCEPT LABEL ERRORS                              *\nIBERRORA $CALL ERRTAG              HAVE LABEL FLAGGED\n         B     IBRETA              RETURN TO CALLER\n         SPACE 2\n* * * * * LABEL ERRORS                                                *\nIBERLAB  $CALL ERRLAB              CALL LABEL ERROR\n         B     IBRETA              RETURN TO CALLER\n         SPACE 2\n*              INTERNAL SUBROUTINES.\n         SPACE 2\n* * * * * EXPRESSION EVALUATION - CALL TO EVALUT                      *\nIBEVCALL $CALL EVALUT              CALL EXPRESSION EVALUATOR\n         LTR   RB,RB               SET THE CONDTION CODE\n         BR    IBLR                RETURN TO CALLER\n         EJECT\n* * * * * INTERNAL CONSTANTS                                          *\n* * * * * 2ND LEVEL JUMP TABLE FOR IBASM1                             *\nIBAJUMP  $AL2  IBASMJ,(IBUSING,IBDROP,IBSTART,IBCSECT,IBDSECT,IBENTRY,I#\n               BEXTRN,IBEQU,IBDC,IBDS,IBCCW,IBTITLE,IBEJECT,IBSPACE,IBP#\n               RINT,IBORG,IBLTORG,IBCNOP,IBEND),-2\n         AIF   (&$DEBUG).IBNOD2    SKIP IF NOT DEBUG MODE\n         DC    AL2(IBDEBUG-IBASMJ)           OFFSET TO DEBUG ROUTINE\n.IBNOD2  ANOP\n         SPACE 1\n* * * * * PRINT OPERAND TABLE                                         *\nIBPTAB   IBPRTAB ON,$IBPON         SET BIT ON\n         IBPRTAB OFF,$IBPON,*      SET 'ON' BIT OFF\n         IBPRTAB GEN,$IBPGEN       SERT GEN BIT ON\n         IBPRTAB NOGEN,$IBPGEN,*   SET 'GEN' BIT OFF\n         IBPRTAB DATA,$IBPDAT      SET DATA BIT ON (ONLY COMPATIBLITY)\n         IBPRTAB NODATA,$IBPDAT,*  SET 'DATA' BIT OFF\nIBPLAST  EQU   *-1                 @ LAST BYTE FOR LIMIT\n         SPACE 1\n         LTORG\n         SPACE 1\n* * * * * INTERNAL VARIABLES                                          *\n* * * * * RCB AREA FOR IBASM1                                         *\nIBRCB    DS    0D                  RECORD CODE BLOCK\nIBRCLENG DS    C                   LENGTH OF RCB\nIBRCLOC  DS    AL3                 LOCATION COUNTER VALUE\nIBRCTYPE DS    C                   OPCODE TYPE\nIBRCHEX  DS    C                   2ND LEVEL TAGS-LABLE&OPERAND\nIBRCMASK DS    C                   FROM OPCTYPE=LENGTH ATTRIBUTE\nIBRCLQ   DS    C                   BYTE FOR LENGTH ATTRIBUTE L'*\nIBRCEQU  DS    0F                  VALUE OF AN EQUATE SYMBOL\nIBRCONS  DS    (IBMAXCON)CL(CNC$LEN)         CONSTANT CODE BLOCKS\n         SPACE 1\n* * * * * DSECT USED BY PRINT ROUTINE FOR TABLE LOOKUP  * * * * * * * *\nIBPSECT  DSECT\nIBPLENG  DS    C                   NUMBER OF CHARACTERS IN CODE\nIBPVO    DS    B                   BIT TO BE OR'D IN: BIT TO TEST\nIBPVX    DS    B                   BIT TO BE XOR'D IN, RESET =0 IF NEED\nIBPOPR   DS    C                   OPERAND CHARACTERS(ON,OFF,ETC)\n         DROP  RAT,R13             CLEAN UP USING SIUTATION\n         TITLE '*** ICMOP2 - MACHINE INSTRUCTIONS - PASS 2 ***'\n**--> CSECT: ICMOP2   2   MACHINE OPERATIONS - PASS 2 . . . . . . . . .\n*.       THIS MODULE IS 1 OF THE 2 PASS 2,LEVEL 2 ROUTINES IN THE     .\n*.       ASSIST ASSEMBLER.  IT PROCESSES ALL MACHINE INSTRUCTIONS IN  .\n*.       THE SECOND PASS, SCANNING ALL THE OPERAND FIELDS AND CREATING.\n*.       THE OBJECT CODE FOR THEM.  IT ALSO DOES THE SETUP REQUIREED  .\n*.       FOR OUTPT2 TO PRODUCE THE PRINTED LISTING. THIS ROUTINE HAS  .\n*.       MANY SPECIAL-CASE SECTIONS WHICH ARE USED FOR SPEED, AND     .\n*.       WHICH COULD USE LESS SPACE IF CALLS TO THE GENERAL EXPRESSION.\n*.       EVALUATOR EVALUT WERE USED INSTEAD.                          .\n*.       ENTRY CONDITIONS                                             .\n*.  RA = SCAN POINTER (ADDRESS OF 1ST CHARACTER OF OPERAND FIELD)     .\n*.  RC = ADDRESS OF RECORD CODE BLOCK(RCODBLK) FOR STATEMENT          .\n*.  RE = ADDRESS OF RECORD SOURCE BLOCK(RSBLOCK) FOR STATEMENT        .\n*.       CALLS BRDISP,ERRTAG,EVALUT,LTGET2,SDBCDX,SDDTRM              .\n*.       CALLS SDBCDX,SYFIND,OUTPT2,UTPT2                             .\n*.       USES MACROS: $AL2,$CALL,$GLOC,$RETURN,$SAVE,ICT              .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n         SPACE 1\nICMOP2   CSECT\n         $DBG  90,*\nICB1D1   EQU   X'10'               (ICYFLAG) - ==> B(D) OPERAND FORMAT\nICBX2    EQU   X'08'               (ICYFLAG) ==> D(X,B) FORMAT,NOT L\nICBSOPN2 EQU   X'04'               (ICYFLAG) ==> B(D) STORED INTO OPN2\nICBSEA2  EQU   X'02'               (ICYFLAG) ==> @ GOES TO ICYEA2\nICYXLFN  EQU   X'80'               (ICYF2) ==> X OR L FIELD PRESENT\n         USING AVWXTABL,RAT        NOTE MAIN TABLE USING\n         USING RCODBLK,RC          NOTE POINTER TO CODE BLOCK\n         EJECT\n* * * * * OVERALL REGISTER USAGE FOR ICMOP2 * * * * * * * * * * * * * *\n*   R1 = @ REGISTER-HI-ORDER BYTE =0. OFTEN USED TO SAVE SCAN PTR RA  *\n*   R2 = BYTE REGISTER - HI-ORDER 3 BYTES = 0. USED FOR INSERTIONS,ETC*\n*   RW = LEVEL 1 LINK REGISTER                                        *\n*   RX = LEVEL 3 LINK REGISTER                                        *\n*   RY = 1    USED FOR INCREMENTING,DECREMENTING REGS,BXH'ING SCAN PTR*\n*   RZ = LEVEL 2 LINK REGISTER                                        *\n*   RA = SCAN POINTER REGISTER - @ NEXT CHARACTER TO BE EXAMINED      *\n*   RB = USUAL PLACE FOR AN ESDID TO BE KEPT,IF THERE IS ONE          *\n*   RC = NORMAL PARAMATER REGISTER FOR RETURN OF A CONVERTED VALUE    *\n*   R13= @ SAVEAREA AND BASE REGISTER                                 *\n*   R14-R15   LOCAL WORK REGISTERS, EXTERNAL LINK REGISTERS           *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n         $SAVE RGS=(R14-R6),BR=R13,SA=ICMOSAVE\n         MVC   ICRCB(RCLITEQ-RCODBLK+4),RCODBLK        MOVE TO FREE RC\n         DROP  RC                  NO LONGER USING,WILL NEED EVERY REG\n         LM    R0,R3,AWZEROS       ZERO OUT THESE REGS\n         STM   R0,R3,ICYBLOCK      ZERO OUT BLOCK FOR OBJ CODE\n         LA    RY,1                INITIALIZE REGISTER\n         MVC   ICYOP(2),ICRCHEX    MOVE OPCODE-MASK OVER\n         AIF   (NOT &$XREF).NOXRF15                                   A\n         IC    R2,ICYOP            GET OPCODE                         A\n         IC    R2,ICXRTAB(R2)      GET FLAG BYTE FROM TABLE           A\n         STC   R2,AVXRMDFT         STORE FLAG BYTE IN FLAG            A\n.NOXRF15 ANOP\n         NI    ICYR1R2,X'F0'       REMOVE 2ND NIBBLE,LEAVING MASK ONLY\n         SPACE 1\n*              OBTAIN TYPE INFORMATION,INSTRUCTION SECTION @. TAKE\n*              BRANCH TO ONE OF LEVEL 0 INSTRUCTION PROCESSORS.\n         IC    R2,ICRCTYPE         GET TYPE BYTE\n         LH    R14,ICOJUMP(R2)     GET OFFSET @ FOR LEVEL 0 ROUTINE\n         SRL   R2,1                DIVIDE BY 2 FOR BYTE INDEX\n         IC    R2,ICTTAB(R2)       GET FLAG BYTE BELONGING TO TYPE\n         STC   R2,ICYFLAG          STORE FLAG BYTE FOR LATER USE\nICMOJ    B     ICMOJ(R14)          TAKE BRANCH TO INSTRUCTION TYPE SUBR\n* * * * * JUMP OFFSET TABLE FOR INSTRUCTION TYPE PROCESSORS (LEVEL 0) *\nICOJUMP  $AL2  ICMOJ,(ICRRM,ICRXM,ICRR,ICRX,ICRS,ICRSH,ICSI,ICSS,ICSS2,#\n               ICRSO,ICSPC),-2\n         EJECT\n* * * * * INDIVIDUAL ERROR EXITS                                      *\nICNUNDEF LA    RB,$ERUNDEF         UNDEFINED SYMBOL\n         LR    RA,R1               GET A SCAN POINTER BACK\n         BCT   RA,ICNERROR         MOVE SCAN PTR BACK,GO FLAG ERR\nICNEABS  LA    RB,$ERNEABS         AN ABSOLUTE TERM OR EXPRESSION NEEDD\n         B     ICNERROR            GO FLAG ERROR\nICNBADSY LA    RB,$ERINVSY         INVALID SYMBOL\n         BCT   RA,ICNERROR         MOVE SCAN PTR BACK,GO FLAG ERR\nICNLITER LA    RB,$ERTLIT          ILLEGAL USE OF LITERAL\n         B     ICNERROR            GO FLAG ERROR\nICNRELC  LA    RB,$ERRELOC         RELOCATABILITY ERROR\n         BCT   RA,ICNERROR         MOVE SCAN PTR BACK,GO FLAG ERR\nICNEXGTB AR    RA,RY               BUMP SCAN PTR TO ALLOW FOR BCT\nICNEXGTA LA    RB,$EREXGTA         EXPRESSION TOO LARGE\n         BCT   RA,ICNERROR         MOVE SCAN PTR BACK,GO FLAG ERR\nICNADDR  LA    RB,$ERADDR          ADDRESSIBILITY ERROR\n         BCT   RA,ICNERROR         MOVE SCAN PTR BACK,GO FLAG ERR\nICNILLEG CLI   0(RA),C' '          WAS ILLEGAL A BLANK (MISSING)\n         BNE   ICNINVDM            NO,SOMETHING ELSE ILLEFAL\nICNNOOPR LA    RB,$ERNOOPR         MISSING OPERAND\n         B     ICNERROR            GO HAVE IT FLAGGED\nICBLANK  CLI   0(RA),C' '          FINAL CHECK FOR BLANK\n         BE    ICOUTPT             BRANCH OUT IF OK\nICNINVDM LA    RB,$ERINVDM         INVALID DELIMITER (MOST COMMON)\nICNERROR $CALL ERRTAG              HAVE ERROR FLAGGED\nICNERRF  MVC   ICYEA1(14),AWZEROS  ZERO THE INSTRUCTION OUT\n         SPACE 1\n* * * * * ICOUTPT - COMMON EXIT - PRODUCE OBJECT CODE,PRINT STMT      *\nICOUTPT  $GLOC RA                  GET LOCATION COUNTER FOR UTPUT2\n         LA    RC,ICYOP            @ OBJECT CODE FOR UTPUT2\n         IC    R2,ICRCLQ           GET LENGTH-1 OF STATEMENT CODE\n         LR    RD,R2               MOVE OVER FOR LENGTH-1 FOR UTPUT2\n         LR    RE,RY               SET RE = 1 ==> PRODUCE 1 OF OBJECT\n         $CALL UTPUT2              HAVE OBJECT CODE LOADED\n         SPACE 1\n*              SET UP AND CALL PRINTER ROUTINE                        *\n         LA    RB,$OUMACH          SHOW THIS IS A MACHINE INSTRUCTION\n         LA    RC,ICYBLOCK         GET @ BLOCK\n         LR    RD,R2               MOVE LENGTH-1 WHERE OUTPT2 WANTS IT\n         $CALL OUTPT2              CALL OUTPUT ROUTINE\n         AIF   (NOT &$XREF).ICNXRF1  SKIP IF NO CROSS-REF OPTION      J\n         MVI   AVXRTYPE,AVXRFTCH   MAKE FETCH TYPE NORMAL FOR REST    J\n.ICNXRF1 ANOP\nICRET    $RETURN RGS=(R14-R6)\n         EJECT\n* * * * * ICRR - NORMAL RR INSTRUCTIONS,EXTENDED MNEM RR'S - LEVEL - 0*\nICRRM    BAL   RZ,ICREG            GO GET REG 2 FIELD\n         EX    RC,ICOIR            HAVE IT ORED IN\n         B     ICBLANK             GO CHECK FOR BLANK\nICRR     EQU   *                                                      A\n         CROSSET   1               SET FLAG M/F FIRST OPRND           A\n         BAL   RW,ICWREG1          GO GET FIRST REGISTER              A\n         CROSSET   2               SET FLAG M/F 2ND OPERAND           A\n         BAL   RZ,ICREG            GO GET 2ND REGISTER\n         EX    RC,ICOIR            HAVE IT OR'D INTO R2 FIELD\n         AIF   (NOT(&$FLOTA OR &$FLOTAX OR &$S370A)).ICRRNF\n         TM    ICRCMASK,IAB        SHOULD R2 BE EVEN?\n         BNO   ICBLANK             NO, SO BRANCH TO CHECK FOR BLANK\n         TM    ICYR1R2,X'01'       WAS THRE AN ODD REG IN 2ND POSITION\n         BZ    ICBLANK             NO, SO OK -BRANCH\n         BAL   RZ,ICWODDR          HAVE ODD REG FLAGGED\n.ICRRNF  B     ICBLANK             GO TO CHECK FOR BLANK AND QUIT\n         SPACE 2\n* * * * * ICRX - NORMAL RX AND RX EXTENDED MNEMONICS - LEVEL - 0      *\nICRX     EQU   *                                                      A\n         CROSSET  1                SET FLAG FOR 1ST OPERAND           A\n         BAL   RW,ICWREG1          CALL FOR 1ST REG                   A\nICRXM    EQU   *                   ENTRY FOR RX EXTENDED MNEMONICS\n         CROSSET  2                SET FLAG 2ND OPERAND               A\n         BAL   RW,ICXBD            GO GET THE OPERAND\n         TM    ICYF2,ICYXLFN       WAS INDEX SPECIFIED\n         BZ    *+10                SKIP OVER IF SO\n         OC    ICYR1R2,ICYXL       PLACE X2 FIELD IN,IF IT WAS SPECIFIE\n         B     ICBLANK             GO CHECK FOR BLANK\n         SPACE 2\n* * * * * ICRS - REGULAR NON-SHIFT RS INSTRUCTIONS - LEVEL - 0        *\nICRS     EQU   *                                                      A\n         CROSSET  1                SET 1ST OPERAND FLAG               A\n         BAL   RW,ICWREG1          GET 1ST REGISTER                   A\n         CROSSET 2 SET SECOND OPERAND                                 A\n         BAL   RZ,ICREG            GET 2ND REG\n         EX    RC,ICOIR            HAVE 2ND REG PLACED ALSO\n         CLI   0(RA),C','          IS DELIM WHAT IT SHOULD BE\n         BNE   ICNINVDM            NO-ERROR\n         CROSSET 3                 SET 3RD OPERAND                    A\n         BXH   RA,RY,ICRSH1        BUMP PAST , AND GO GET D2-B2\n         SPACE 2\n* * * * * ICRSH - RS SHIFT INSTRUCTIONS - LEVEL - 0                   *\nICRSH    EQU   *                                                      A\n         CROSSET  1                SET FLAG                           A\n         BAL   RW,ICWREG1          GET 1ST REGISTER                   A\n         CROSSET  2                SET SECOND OPERAND                 A\nICRSH1   BAL   RW,ICXBD            GET BASE-DISP (COMMON RS CODE)\n         B     ICBLANK             GO TEST FR BLANK AND QUIT\n         EJECT\n* * * * * ICSI - NORMAL SI INSTRUCTIONS - OP D1(B1),I2 - LEVEL - 0    *\nICSI     EQU   *                                                      A\n         CROSSET  1                1ST OPERAND                        A\n         BAL   RW,ICXBD            GET B(D) FIELD                     A\n         CLI   0(RA),C','          CHECK FOR COMMA\n         BNE   ICNINVDM            BRANCH IF NOT-ILLEGAL\n         AR    RA,RY               BUMP SCAN POINTER PAST ,\n         SPACE 1\nICSI1    LR    R1,RA               SAVE SCAN PTR, IN CASE NOT JUST SDT\n         BAL   RX,ICSDTRM          GO GET SDT IF IT IS ONE\n         BM    ICSI2               NO IT WAN'T-GIVE UP AND USE EXPRESSI\n         CLI   0(RA),C' '          WAS THIS ALL (WE HOPE SO)\n         BE    ICSI3               YES,WE GOT BY WITH SIMPLE CASE\n         LR    RA,R1               NOT SD TERM BY SELF-RESTORE SCP\n         SPACE 1\nICSI2    BAL   RX,ICEXP            GO GET EXPRESSION\n         BP    ICNEABS             EXPRESSION HAD TO BE ABSOLUTE-ERROR\nICSI3    CL    RC,AWFXFF           WAS EXPRESSION SMALL ENOUGH\n         BH    ICNEXGTA            NO-TOO BIG\n         STC   RC,ICYR1R2          SAVE I2 FIELD\n         B     ICBLANK             GO CHECK FOR BLANK AND FINISH UP\n         SPACE 1\nICSS     EQU   *                                                      A\n* * * * * ICSS - SS INSTRUCTIONS WITH 1 LENGTH - LEVEL - 0            *\n         CROSSET  1                1ST OPERAND FLAG SET               A\n         BAL   RW,ICXBD            GET 1ST BASE DISPLACEMENT          A\n         BAL   RX,ICULEN           PICK UP LENGTH IN R2\n         STC   R2,ICYR1R2          SAVE INTO INSTRUCTION\n         CLI   0(RA),C','          IS DELIMITER OK\n         BNE   ICNINVDM            NO,ERROR\n         AR    RA,RY               BUMP SCAN POINTER PAST ,\n         SPACE 1\n         OI    ICYFLAG,ICB1D1+ICBSOPN2+ICBSEA2         SET FOR 2ND OP\n         CROSSET 2                 2ND OPERAND                        A\n         BAL   RW,ICXBD            GO PROCESS 2ND OPERAND\n         B     ICBLANK             GO CHECK FOR BLANK AND QUIT\n         SPACE 1\n* * * * * ICSS2 - SS INSTRUCTIONS WITH 2 LENGTHS - LEVEL - 0          *\nICSS2    EQU   *                                                      A\n         CROSSET 1                 SET 1ST OPERAND FLAG               A\n         BAL   RW,ICXBD            GET 1ST BASE DISPLACEMNT           J\n         BAL   RX,ICULEN           GO GET LENGTH\n         C     R2,AWF15            MAKE SURE LEGAL SIZE\n         BH    ICNEXGTA            TOO BIG-BRANCH\n         SLL   R2,4                SHIFT OVER FOR L1 POSITION\n         STC   R2,ICYR1R2          SAVE THE LENGTH\n         CLI   0(RA),C','          CHECK DELIMITER\n         BNE   ICNINVDM            ERROR IF NOT\n         AR    RA,RY               BUMP SCAN POINTER\n         SPACE 1\n         AIF   (NOT &$S370A).ICSS2 SKIP IF NOT ASSEMBLING S/370'S\n         CLI   ICYOP,240           IS THIS A SRP INSTRUCTION?\n         BE    ICSS2A              YES - BRANCH\n         SPACE 2\n.ICSS2   ANOP\n         OI    ICYFLAG,ICBSOPN2+ICBSEA2      RESET FLAGS FOR 2ND OPRND\n         MVI   ICYF2,0             REZERO RETURN CODES FLAG\n         CROSSET 2                 SET FLAGS                          A\n         BAL   RW,ICXBD            GET 2ND LENGTH-BASE-DISP\n         BAL   RX,ICULEN           GO PICK UP LENGTH IN R2\n         C     R2,AWF15            MAKE SURE LEGAL SIZE\n         BH    ICNEXGTA            NO-TOO BIG-ERROR\n         EX    R2,ICOIR            HAVE THE LENGTH OR'D IN\n         B     ICBLANK             GO CHECK FOR BLANK AND QUIT\n         AIF   (NOT &$S370A).ICSS2A SKIP IF NOT ASSEMBLIN& S/3 0'S\n         SPACE 2\n* * * * * ICSS2A - SPECIAL CODE FOR SRP (S/370) INSTRUCTION\nICSS2A   OI    ICYFLAG,ICB1D1+ICBSOPN2+ICBSEA2       SET FOR 2ND OPND\n         CROSSET 2                 SET 2ND OPERAND FLAG               A\n         BAL   RW,ICXBD            GO PROCESS 2ND OPERAND\n         CLI   0(RA),C','          CHECK DELIMITER\n         BNE   ICNINVDM            ERROR IF NOT\n         AR    RA,RY               BUMP SCAN POINTER\n         BAL   RZ,ICREG            GO GET IMMEDIATE FIELD\n         CH    RC,AWH10            IS IMMEDIATE TO LARGE?\n         BNL   ICNEXGTA            YES - ERROR\n         EX    RC,ICOIR            HAVE IMMEDIATE OR'ED IN\n         B     ICBLANK             GO CHECK FOR BLANK AND QUIT\n.ICSS2A  ANOP\n         EJECT\n* * * * * ICRSO - SPM,SVC, AND IO-TYPE SI'S - LEVEL - 0               *\nICRSO    EQU   *\n         CLI   ICYOP,X'0A'         IS IT SVC\n         BE    ICSI1               YES, USE IMMEDIATE FIELD PART OF SI\n         CLI   ICYOP,X'01'         IS THIS AN XOPC INSTRUCTION        M\n         BE    ICSI1               YES, USE IMMEDIATE FIELD PART OF SIM\n         CLI   ICYOP,X'04'         IS IT  SPM\n         BE    ICRSO1              YES,GO PROCESS\n*              FALL THRU ==> ODD SI INSTRS (TS, SIO, TCH, ETC)\n         MVI   ICYFLAG,$ICBEA1+ICB1D1        CHANGE FLAG FOR SEMI-SI\n         AIF   (NOT &$P370A).ICRSO IF NO PRIVELEGED S/370'S, BRANCH\n         MVO   ICYR1R2(2),ICRCMASK MOVE IN MASK DIGIT FOR S/370\n.ICRSO   ANOP\n         BAL   RW,ICXBD            GET BASE-DISPLACEMENT\n         B     ICBLANK             GO FOR BLANK AND QUIT\n         SPACE 1\nICRSO1   BAL   RZ,ICREG            SPM HAS 1 REG,GO GET IT\n         SLL   RC,4                SHIFT OVER FOR RIGHT POSITION\n         STC   RC,ICYR1R2          STORE R1 FIELD\n         B     ICBLANK             LOOK FOR BLANK AND QUIT\n         SPACE 1\n* * * * * ICSPC - SPECIAL INSTRUCTIONS - XREAD,XPRNT,XPNCH - LEVEL - 0*\nICSPC    EQU   *                   FOR SPECIAL IO INSTRUCTIONS\n         AIF   (NOT &$XIOS).ICXIO  SKIP IF THESE SPECIALS NOT ALLOWED\n         MVI   ICSPCDUM+1,0        MAKE A NOOP\n         CLI   ICYR1R2,X'60'       WAS IT XDUMP\n         BNE   ICSPCO              SKIP IF NOT XDUMP IN 1ST PLACE\n         MVI   ICSPCDUM+1,X'F0'    SHOW XDUMP WITH ARGUMENTS\n         CLI   0(RA),C' '          ARE THERE ANY OPERANDS\n         BNE   ICSPCO              YES, ALREADY SET RIGHT, CONTINUE\n         MVI   ICYOP,X'E1'         CHANGE OPCODE E0 TO E1-REGS XDUMP\n         B     ICOUTPT             GO OUTPUT CODE\n         SPACE 1\nICSPCO   BAL   RW,ICXBD            GET ADDRESS OPERAND\n         TM    ICYF2,ICYXLFN       WAS INDEX REG USED\n         BZ    *+10                NO,SKIP IT\n         OC    ICYR1R2,ICYXL       PUT LENGTH IN\n         CLI   0(RA),C' '          WAS THIS ALL\n         BNE   ICSPC1              SKIP IF LENGTH FOLLOWS\n         IC    R2,ICYR1R2          GET MASK VALUE\n         SRL   R2,5                SHIFT OVER FOR BYTE INDEXING\n         IC    R2,ICSPCDLT(R2)     GET DEFAULT LENGTH VALUE\n         STH   R2,ICYOPN2          SAVE THE VALUE IN D(B) FIELD\n         B     ICOUTPT             GO HAVE PRINTED AND RETURN\n         SPACE 1\nICSPC1   CLI   0(RA),C','          MAKE SURE DELIM WHAT IT'S SUPPOSED T\n         BNE   ICNINVDM            ERROR - BRANCH\n         AR    RA,RY               BUMP SCAN POINTER\n         CLI   0(RA),C'('          IS THIS REGISTER FORM\n         BNE   ICSPC2              NO,MUST BE SPECIFIED LENGTH\nICSPCDUM BC    $CHN,ICNINVDM       XDUMP WITH ARGS DOESN'T ALLOW (R) FM\n         AR    RA,RY               BUMP SCAN POINTER PAST (\n         BAL   RZ,ICREG            GET REGISTER VALUE\n         SLL   RC,4                SHIFT FOR POSITION\n         STC   RC,ICYOPN2          SAVE INTO B POSTION\n         CLI   0(RA),C')'          IS DELIMITER RIGHT\n         BNE   ICNINVDM            NO-ERROR-BRANCH\n         BXH   RA,RY,ICBLANK       BUMP SCP AND GO CHK BLANK          P\n         SPACE 1\nICSPC2   BAL   RX,ICEXP            GO GET EXPRESSION\n         BNZ   ICNEABS             SHOULD BE ABSOLUTE-ERR IF NOT\n         STH   RC,ICYOPN2          SAVE THE VALUE\n         B     ICBLANK             GO CHK BLANK AND FINISH UP\nICSPCDLT DC    AL1(80,133,80,4,1)  DFLT L'S-READ,PRNT,PUNCH,DUMP,LIMD\n.ICXIO   ANOP\n         EJECT\n* * * * * ICWREG1 - PROCESS 1ST REGISTER OR MASK - LEVEL - 1          *\n*        ENTRY CONDITIONS                                             *\n*   RA = SCAN POINTER TO 1ST CHAR OF 1ST REGISTER                     *\n*   RW = RETURN ADDRESS OF CALLING SECTION                            *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nICWREG1  BAL   RZ,ICREG            GET 1ST REG CONVERTED\n         SLL   RC,4                SHIFT OVER\n         STC   RC,ICYR1R2          STORE INTO AREA\n         TM    ICRCMASK,IAA        MUST THE REGISTER BE EVEN\n         BZ    ICWR1               NO,GO FINISH UP\n         TM    ICYR1R2,X'10'       MAKE SURE REG IS EVEN\n         BZ    ICWR1               REG IS OK,SKIP\n         LA    RZ,ICWR1            SET UP RETURN @ TO CONTINUE\n         SPACE 1\n*              ICWODDR MAY BE CALLED TO FLAG ODD FLT-PT REG - LEVEL-2 *\nICWODDR  SR    RA,RY               DECREMENT SCAN PTR BY 1 TO REG\n         LA    RB,$ERODDRG         REGISTER IS ODD-FLAG IT\n         $CALL ERRTAG              FLAG ERROR\n         BXH   RA,RY,0(RZ)         PUT SCAN PTR FORWARD 1, RETURN TO CL\n         SPACE 1\nICWR1    CLI   0(RA),C','          IS REG FOLLOWED BY ,\n         BNE   ICNINVDM            NO-ERROR\n         BXH   RA,RY,0(RW)         BUMP PAST , AND RETURN\n         EJECT\n* * * * * ICXBD - PROCESS 1 OPERAND - D(B) OR D(X-L,B) - LEVEL - 1    *\n*        ENTRY CONDITIONS                                             *\n*   RW = RETURN ADDRESS OF CALLING SECTION                            *\n*        EXIT CONDITIONS                                              *\n*        ICYEA1 OR ICYEA2 WILL BE FILLED IN. ICYOPN1 OR ICYOPN2 WIIL  *\n*        BE FILLED IN AND A LENGTH OR INDEX REGISTER WILL BE STORED   *\n*        INTO ICYFL, IF PRESENT.                                      *\n*        **NOTE** MOST OF THE CODE IN THIS SECTION IS DESIGNED TO     *\n*   MAKE NORMAL CASE PROCESSING AS FAST AS POSSIBLE. THE PROGRAM      *\n*   ATTEMPTS TO FIND ONE OF SEVERAL TYPICAL OPERAND FORMATS, AND IF   *\n*   SUCCESSFULL, PROCESSES THEM QUICKLY. IF NOT, IT GIVES UP AND      *\n*   USES THE EXPRESSION EVALUATOR EVALUT INSTEAD. THE ROUTINE WILL    *\n*   CONVERT ANY OF THE FOLLOWING SORTS OF OPERANDS WITHOUT CALLING    *\n*   THE EVALUT ROUTINE :                                              *\n*   1. FOR OPERANDS OF FORM S OR D(B) - IF D IS A DECIMAL # OR        *\n*        SELF-DEFINING TERM BY ITSELF, AND (B) IS PRESENT OR NOT, OR  *\n*   IF S IS EITHER A SYMBOL BY ITSELF, OR SYMBOL+# OR SYMBOL-#, WHERE *\n*        SYMBOL IS EITHER AN ORDINARY SYMBOL OR LOCATION COUNTER REF  *\n*   2. FOR OPERANDS OF FORM S(XL) OR D(XL,B) OR D(XL) OR D(,B)        *\n*        SYMBOL IS EITHER AN ORDNIARY SYMBOL OR LOCATION COUNTER REFE *\n*        IF S OR D ARE AS DESCRIBED BY 1., AND IF XL DESIGNATES A     *\n*   LENGTH, IT IS GIVEN BY A DECIMAL #.                               *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         AIF   (&$OPTMS LT 2).ICX2 SKIP IF MEMORY TIGHT\nICXBD    ST    RA,ICZ1RA           SAVE THE SCAN POINTER IF BACK-UP NEE\n         IC    R2,0(RA)            GET THE FIRST CHARACTER OF OPERAND\n         IC    R2,AWTDECT(R2)      GET INDEX VALUE FROM TABLE\n         C     R2,AWF12            MAKE SURE NOT ILLEGAL\n         BH    ICNILLEG            ILLEGAL CHAR-BRANCH\n         LH    R14,ICXJUMP(R2)     GET THE OFFSET @\nICXBDJ   B     ICXBDJ(R14)         JUMP TO RIGHT BEGINNING SECTION\n* * * * * JUMP OFFSET TABLE FOR 1ST CHARACTER FOR ICXBD ROUTINE       *\nICXJUMP  $AL2  ICXBDJ,(ICXDEC,ICNINVDM,ICXSDT,ICXSYM,ICXLOC,ICXLIT,ICXL#\n               PARN)\n.ICX2    AIF   (&$OPTMS GE 2).ICX3 SKIP IF NOT GREAT MEMORY OPT\nICXBD    CLI   0(RA),C'='          CHECK FOR LITERAL (MEMORY OPT CODE)\n         BNE   ICXDEXP2            NOT LITERAL, GO CALL EXPRESSION EVAL\n.ICX3    ANOP\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*        THE FOLLOWING CODE SECTIONS PROCESS AN OPERAND SPECIFIED AS  *\n*   A LITERAL, A RELOCATABLE SYMBOL OR EXPRESSION, OR AN EXPLICIT     *\n*   DISPLACEMENT.  EXPLICIT BASES,LENGTHS, OR INDEX REGISTERS ARE     *\n*   PROCESSED BY ICXABS-ICXRELOC                                      *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n* * * * * ICXLIT - PROCESS A LITERAL OPERAND - 1ST CHAR WAS =         *\nICXLIT   TM    ICRCMASK,IAL2       IS LITERAL ALLOWED\n         BZ    ICNLITER            NO,GO FLAG IT\n         CLI   ICRCLENG,RC$LEN2    DOES A LITERAL @ EXIST\n         BNE   ICNERRF             NO,BUT IT WAS ALREADY FLAGGED-QUIT\n         L     RC,ICRCLITA         GET @ LITERAL IN LITERAL TABLE\n         $CALL LTGET2              GET THE PROGRAM @ LITERAL(IN RC)\n         STC   RD,ICYLQT           STORE LENGTH-1 ATTRIBUTE\n         NI    ICYF2,255-ICYXLFN   ZERO TO SHOW NO EXPLICIT LENGTH\n         BAL   RZ,ICGBD            HAVE IT CONVERTED TO B-D FORM\n         BR    RW                  RETURN TO CALLER OF ICXBD\n         AIF   (&$OPTMS LT 2).ICX4 SKIP IF MEMORY OPTMIZED\n         SPACE 1\n* * * * * ICXSDT - CHECK SELF-DEFING TERM OR L' - 1ST CHAR WAS BCLX   *\nICXSDT   CLI   1(RA),C''''         IS ' 2ND CHAR OF OPERAND\n         BNE   ICXSYM              NO,SO GO PROCESS SYMBOL\n         BAL   RX,ICSDTRM          GO GET SELF-DEFINING TERM\n         BZ    ICXDEC1             IF WAS SDTERM-ENTER DEC ROUTINE\n         B     ICXDEXP2            IF NOT,MUST HAVE BEEN L'-GO EVAL EXP\n         SPACE 1\n* * * * * ICXLOC - PROCESS LOCATION COUNTER REFERENCE - 1ST CHAR WAS **\nICXLOC   $GLOC RC                  GET CURRENT LOCATION COUNTER VALUE\n         SR    RB,RB               CLEAR FOR INSERTION\n         IC    RB,AVCESDID         GET CURRENT ESDID\n         IC    RE,ICRCLQ           GET LENGTH ATTRIBUTE,IF NEEDED\n         BXH   RA,RY,ICXSYM1       BUMP SCAN POINTER AND CONTINUE\n         EJECT\n* * * * * ICXSYM - PROCESS SYMBOL REFERENCE - 1ST CHARACTER WAS ALPH  *\nICXSYM   BAL   RX,ICSYM            GO GET SYMBOL VALUE,ETNRY\n         USING SYMSECT,RA          NOTE USING, RC=VALUE,RB=ESDID\n         IC    RE,SYLENG           GET LENGTH ATTRIBUTE\n         DROP  RA                  NO LONGER USING\n         LR    RA,R1               RESTORE SCAN POINTER\n         SPACE 1\n*              COMMON CODE - SYMBOL AND LOCATION COUNTER REFERENCE.\nICXSYM1  STC   RE,ICYLQT           SAVE LENGTH ATTRIBUTE IN CASE NEEDED\n         IC    R2,0(RA)            GET NEXT CHARACTER\n         IC    R2,AWTDECT(R2)      GET INDEX VALUE OF CHARACTER\n         C     R2,AWF12            COMPARE TO VALUE FOR (\n         BNL   ICXSTEST            SKIP IF ( COMMA OR BLANK-DONE\n         SPACE 1\n         MVI   ICXSUBAD,X'1A'      MAKE INSTRUCTION AN AR\n         CLI   0(RA),C'+'          IS IT PLUS LIKE WE HOPE\n         BE    ICXSINC             YES,GO HAVE# CONVERTED\n         CLI   0(RA),C'-'          IS IT -\n         BE    ICXSUB              YES,GO SET INSTRUCTION\n         LTR   RB,RB               WAS THE SYMBOL ABSOLUTE\n         BZ    ICXDEXP1            YES,SO GO EVALUATE WHOLE EXPRESSION\n         B     ICNRELC             NO,RELOCATABLE TERM IN * OR /\n         SPACE 1\nICXSUB   MVI   ICXSUBAD,X'1B'      MAKE INSTRUCTION SUBTRACT TEMPORARIL\nICXSINC  AR    RA,RY               BUMP THE SCAN POINTER\n         CLI   0(RA),C'0'          ARE WE LOOKING AT DECIMAL #\n         BL    ICXDEXP1            IF NOT,GIVE UP AND USE EXPRESION EVA\n         STM   RB,RC,ICZ1A         SAVE THES REGS\n         BAL   RX,ICDNUM           GET # CONVERTED\n         IC    R2,0(RA)            GET NEXT CHAR\n         IC    R2,AWTDECT(R2)      GET INDEX VALUE\n         C     R2,AWF12            IS IT ( COMMA OR BLANK\n         BL    ICXDEXP1            NO,SO MUST BE MORE COMPLEX EXPR-JUMP\n         SPACE 1\n         LR    RD,RC               SAVE VALUE OF DECIMAL #\n         LM    RB,RC,ICZ1A         GET SYMBOL VALUE-ESDID BACK\nICXSUBAD AR    $CHN+RC,RD          ADD OR SUBTRACT VALUE(OPCODE CHNG)\nICXSTEST LTR   RB,RB               WAS SYMBOL ABSOLUTE OR RELOCATABLE\n         BZ    ICXABS              SKIP IF ABSOLUTE(UNLIKELY)\n.ICX4    ANOP\n         SPACE 2\n* * * * * ICXRELOC - RELOCATABLE OPERAND- CONVERT TO D(B) FORM        *\n*        ON ENTRY TO ICXRELOC, RC = ADDRESS, RB = ESDID OF ADDRESS    *\nICXRELOC BAL   RZ,ICGBD            GET BASE-DISPLACEMENT FORM\n         TM    ICYFLAG,ICB1D1      WAS THERE ONLY BASE-DISPLACEMENT\n         BCR   O,RW                YES RETURN TO CALLER\n         CLI   0(RA),C'('          WAS INDEX OR LENGTH SPECIFIED\n         BCR   NE,RW               NO,SO JUST RETURN TO CALLER\n         AR    RA,RY               BUMP SCAN POINTER PAST (\n         BAL   RZ,ICX2L12          GO GET INDEX OR LENGTH AS NEEDED\n         STC   RC,ICYXL            SAVE THIS VALUE FOR LATER\n         CLI   0(RA),C')'          IS ) THERE LIKE IT SHOULD BE\n         BNE   ICNINVDM            NO-ERROR\n         BXH   RA,RY,0(RW)         BUMP SCAN POINTER AND RETURN\n         EJECT\n         AIF   (&$OPTMS LT 2).ICX6 SKIP IF MEMORY OPT\n* * * * * ICXDEC - PROCESS DECIMAL DISPLACEMENT - 1ST CHAR WAS DEC #  *\nICXDEC   BAL   RX,ICDNUM           GO GET DECIMAL #\nICXDEC1  CLI   0(RA),C'('          IS NEXT (\n         BE    ICXABSA             YES,BASE-X-L FOLLOW\n         CLI   0(RA),C' '          IS BLANK NEXT\n         BE    ICXABSB             YES,GO INTO ABS SECTION\n         CLI   0(RA),C','          IS THIS FIRST OPERAND OF SEVERAL\n         BE    ICXABSB             YES,GO FINISH OFF\n         SPACE 1\n*        FALLS THRU==> NOT SIMPL,HOPED-FOR DECIMAL #-USE EXPRESSION EV*\nICXDEXP1 L     RA,ICZ1RA           GET THE ORIGINAL SCAN POINTER BACK\nICXLPARN EQU   *                   1ST CHAR WAS ( ==> PROCESS EXPRESSN\n.ICX6    ANOP\nICXDEXP2 BAL   RX,ICEXP            GO GET EXPRESSION EVALUATED\n         STC   RE,ICYLQT           SAVE THIS AS LENGTH ATTRIBUTE\n         BNZ   ICXRELOC            CC SET BY ESDID TEST-GO TO RELOC IF\n         SPACE 2\n* * * * * ICXABS - OPERAND DISPLACEMENT EXPLICIT - GET X,L,B,ETC      *\n*        ON ENTRY TO ICXABS,ICXABSA,ICXABSB, RC = DISPLACEMENT VALUE  *\nICXABS   CLI   0(RA),C'('          WAS DISPLACEMENT ALONE(PROB SHIFT)\n         BNE   ICXABSB             YES,GO FINISH UP\nICXABSA  CL    RC,AWFXFFF          IS DISPLACEMENT > 4095\n         BH    ICNEXGTA            DISPLACEMENT TOO LARGE\n         ST    RC,ICZ1A            SAVE THE DISPLACEMENT VALUE\n         AR    RA,RY               BUMP SCAN POINTER PAST (\n         TM    ICYFLAG,ICB1D1      IS THER LENGTH OR INDEX\n         BO    ICXABSN             NO-BASE-DISPLACEMENT ONLY\n         SPACE 1\n         CLI   0(RA),C','          IS L OR X FIELD OMITTED\n         BNE   *+8                 SKIP IF NOT OMITTED\n         BXH   RA,RY,ICXABSN       BUMP PAST , AND JUMP-OMITTED X OR L\n         BAL   RZ,ICX2L12          GET LENGTH OR INDEX\n         STC   RC,ICYXL            SAVE LENGTH OR INDEX\n         SPACE 1\n         SR    RC,RC               CLEAR FOR OMITTED BASE,INCASE IT IS\n         CLI   0(RA),C','          IS BASE SPECIFIED\n         BNE   ICXABSP             NO,MUST BE OMITTED\n         AR    RA,RY               BUMP SCAN POINTER BY 1\nICXABSN  BAL   RZ,ICREG            GET BASE REGISTER\nICXABSP  CLI   0(RA),C')'          IS THE DELIMITER AN ENDING )\n         BNE   ICNINVDM            NO-EEROR\n         LR    RD,RC               MOVE VALUE OF REGISTER OVER\n         SLL   RD,12               SHIFT INTO RIGHT POSITOON\n         L     RC,ICZ1A            GET DISPLACEMENT BACK\n         AR    RD,RC               PUT BAS AND DISPLACEMENT TOGETHER\n         BXH   RA,RY,ICXABSB2      BUMP SCAN PTR PAST ) AND BRANCH\n         EJECT\n*              ICXABSB ENTERED IF DISPLACEMENT ALONE,NO X,L,B         *\nICXABSB  CL    RC,AWFXFFF          IS DISPLACEMENT > 4095\n         BH    ICNEXGTA            NO-ERROR -DISPLACEMNT >4095\n         LR    RD,RC               DUPLICATE VALUE OF ADDRESS AS B-D\n         SPACE 1\n*              ICXABSB2 ENTERED AS COMMON EXIT FROM ICXABS.           *\nICXABSB2 BAL   RX,ICPEA            HAVE ADDRESS CHECKED AND STORED\n         BAL   RZ,ICQOPN           HAVE BASE-DISPLACEMENT STORED\n         BR    RW                  RETURN TO CALLER\n         EJECT\n* * * * * ICGBD - GET AND STORE BASE-DISP OF @ - LEVEL - 2  * * * * * *\n*   RB = ESDID OF THE @                                               *\n*   RC = @ FOR WHICH BASE-DISPLACEMENT IS TO BE FOUND                 *\n*   RZ = RETURN ADDRESS OF CALLING ROUTINE                            *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nICGBD    BAL   RX,ICPEA            HAVE ACTUAL ADDRESS CHECKED AND SAVE\n         LR    R1,RA               SAVE THE SCAN POINTER\n         LR    RA,RC               MOVE @ OVER FOR BRDISP CALL\n         $CALL BRDISP              GO HAVE BASE-DISPLACEMENT FOUND\n         LR    RD,RA               MOVE VALUE OVER TO FALL INTO ICQOPN\n         LR    RA,R1               RESTORE THE SCAN POINTER\n         LTR   RB,RB               WAS BASE-DISP OK\n         BNZ   ICNADDR             NO,ADDRESSIBILITY ERROR\n         SPACE 2\n* * * * * ICQOPN - STORE BASE-DISPLACEMENT INTO OPN1-OPN2 - LEVEL - 2 *\n*        ENTRY CONDITIONS                                             *\n*   RD = VALUE TO BE STORED INTO ICYOPN1-OPN2 FIELD\n*   RZ = RETURN ADDRESS OF CALLING ROUTINE                            *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nICQOPN   TM    ICYFLAG,ICBSOPN2    SHOULD IT GO INTO OPN2\n         BO    *+10                YES,SKIP OVER IF OPN2\n         STH   RD,ICYOPN1          STORE INTO 1ST OPERAND D(B) FIELD\n         BR    RZ                  RETURN TO CALLER\n         STH   RD,ICYOPN2          STORE INTO 2ND FIELD (SS INSTS ONLY)\n         BR    RZ                  RETURN TO CALLER\n         EJECT\n* * * * * ICREG - SCAN AND CONVERT A REGISTER VALUE. - LEVEL - 2.     *\n*        AS OF VERSION 3.0/A, ANY ABSOLUTE EXPRESSION <= 15 IS       J*\n*        ALLOWED FOR REGISTER.  CODE IS ORIENTED TOWARDS NORMAL CASE.J*\n*        ENTRY CONDTIONS                                              *\n*   RA = @ FIRST CHARACTER OF REGISTER.                               *\n*   RZ = RETURN ADDRESS.                                              *\n*        EXIT CONDITIONS                                              *\n*   RA = SCAN POINTER TO CHARACTER FOLLOWING REGISTER                 *\n*   RC = VALUE OF REGISTER,RIGHT JUSTIFIED.  0 <= RC <= 15            *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nICREG    LR    R0,RA               SAVE @ OF 1ST CHAR OF EXPRESSION   J\n         BAL   RX,ICSDTRM          NOW GO TRY FOR SELF-DEFINING TERM  J\n         BZ    ICREGSYC            IF OK, BRANCH TO CHECK DELIM AFTER J\n*              NOT SELF-DEF TERM, TRY EXPRESSION OR SYMBOL.           J\n         CLI   0(RA),C'('          MAKE SURE NOT EXPRESSION IN PARENS J\n         BE    ICREGSYE            WAS EXPRESS IN PARENS-BRANCH OUT   J\n         BAL   RX,ICSYM            SYMBOL, GO TO EVALUATE IT          J\n         LR    RA,R1               MOVE SCAN POINTER BACK RIGHT\n         BNZ   ICNEABS             BRANCH ==> RELOCATABLE REGISTER-ERR\n*              MAKE SURE ACTUALLY IS END OF REGISTER FIELD            J\nICREGSYC CLI   0(RA),C','          MOST COMMON ENDING DELIMITER       J\n         BE    ICREGSYO            YES, WAS COMMA, DONE, BRANCH OUT   J\n         CLI   0(RA),C' '          NEXT COMMON DELIMITER              J\n         BE    ICREGSYO            YES, IT WAS BLANK, BRANCH OUT      J\n         CLI   0(RA),C')'          LAST CAHNCE, RIGHT PAREN           J\n         BE    ICREGSYO            BRANCH OUT, WAS END OF EXPRESSION  J\n*              WAS MORE COMPLEX EXPRESSSION, PROCESS IT (R), R+1, ETC.J\nICREGSYE LR    RA,R0               RESTORE ORIGINAL PTR, FROM ICREG.  J\n         BAL   RX,ICEXP            CALL GENERAL EXPRESSION EVAL (SLOW)J\n         BNZ   ICNEABS             MUST BE ABSOLUTE EXPRESS-BR IF NOT J\nICREGSYO C     RC,AWF15            WAS IT LEGAL SIZE\n         BCR   NH,RZ               RETURN TO CALLER IF SMALL ENOUGH\n         B     ICNEXGTA            TOO BIG-ERROR-FLAG IT\n         EJECT\n* * * * * ICX2L12 - FLAG X-L FOUND, MAKE CHOICE OF ROUTINE - LEVEL - 2*\n*        ENTRY CONDITIONS                                             *\n*   RA = SCAN POINTER TO 1ST CHAR OF LENGTH OR INDEX                  *\n*   RZ = RETURN ADDRESS OF CALLING ROUTINE                            *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nICX2L12  OI    ICYF2,ICYXLFN       NOTE THAT LENGTH OR INDEX FOUND\n         TM    ICYFLAG,ICBX2       ARE WE LOOKING FOR AN INDEX REG\n         BO    ICREG               SKIP IF REG,FLL THRU TO LENGTH IF NT\n         SPACE 2\n* * * * * ICLENG - SCAN AND CONVERT A LENGTH.   LEVEL - 2             *\n*        ENTRY CONDITIONS                                             *\n*   RA = SCAN POINTER TO 1ST CHARACTER OF LENGTH.                     *\n*   RZ = RETURN ADDRESS TO CALLING ROUTINE                            *\n*        EXIT CONDITIONS                                              *\n*   RA = SCAN POINTER TO DELIMITER FOLLOWING LENGTH, EITHER , OR )    *\n*   RC = LENGTH FOR ASSEMBLY(I.E. L-1,EXCEPT L=0).  0 <= RC <= 255    *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n         AIF   (&$OPTMS LT 2).ICX10         SKIP IF MEMORY OPT\nICLENG   CLI   0(RA),C'0'          DO WE HAVE DECIMAL # (WE HOPE SO!)\n         BL    ICLEXP              NO WE DON'T - USE EXPRESSION EVAL\n         ST    RA,ICZ2A            SAVE THE SCAN POINTER\n         BAL   RX,ICDNUM           GO GET DECIMAL #\n         CLI   0(RA),C','          IS IT FOLLOWED BY COMMA\n         BE    ICLSIZE             YES- LENGTH WAS JUST DECIMAL #\n         CLI   0(RA),C')'          IS DELIM  )\n         BE    ICLSIZE             YES,GO CHECK FOR SIZE\n         SPACE 1\n         L     RA,ICZ2A            GET SCAN POINTER BACK-MORE THAN #\n.ICX10   AIF   (&$OPTMS GE 2).ICX11         SKIP IF NOT EMMORY OPT\nICLENG   EQU   *\n.ICX11   ANOP\nICLEXP   BAL   RX,ICEXP            GO GET EXPRESSION EVALUATED\n         BNZ   ICNEABS             BRANCH==> RELOCATABLE EXP-ERR\nICLSIZE  SR    RC,RY               DECREMENT LENGTH TO LENGTH-1\n         BNM   *+6                 SKIP IF ORIG LENGTH ^= 0\n         SR    RC,RC               MAKE LENGTH ZERO\n         C     RC,AWFXFF           IS THE VALUE <= 255\n         BCR   NH,RZ               RETURN IF VALUE OK\n         B     ICNEXGTA            LENGTH > 255-DEFINITELY BAD\n         EJECT\n* * * * * ICPEA - CHECK @ ALIGNMENT, SET UP EA1 OR EA2 - LEVEL - 3    *\n*        **NOTE** REGS RA-RD ARE SAFE ACROSS CALL TO ICPEA            *\n*        ENTRY CONDITIONS                                             *\n*   RC = ADDRESS VALUE TO BE STORED INTO ICYEA1 OR ICYEA2             *\n*   RX = RETURN ADDRESS TO CALLING SECTION                            *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nICPEA    ST    RC,ICYEA2           STORE VALUE IN 2ND SLOT ALWAYS\n         TM    ICYFLAG,ICBSEA2     DID VALUE ACTUALLY BELONG IN 2ND POS\n         BO    *+8                 BRANCH IF WAS 2ND OPERAND\n         ST    RC,ICYEA1           STORE VALUE IN FIRST SLOT\n         IC    R14,ICRCMASK        GET MAK FOR ALIGNMENT\n         N     R14,AWF7            REMOVE ALL BUT LAST 3 BITS\n         NR    R14,RC              TEST FOR RIGHT ALIGNMENT\n         BCR   Z,RX                IF ZERO==> ALIGNMENT OK\n         SPACE 1\n*              FALLS THRU ==> ALIGNMENT ERROR MESSAGE                 *\n         STM   RB,RD,ICZ3A         SAVE THE VALUES OF REGS\n         LA    RB,$ERALIGN         NOTE ALIGNMENT ERROR\n         SR    RA,RY               MOVE SCAN PTR BACK 1\n         $CALL ERRTAG              HAVE IT FLAGGED\n         AR    RA,RY               PUT SCAN PTR BACK WHERE BELONGS\n         LM    RB,RD,ICZ3A         RESTORE REGS\n         BR    RX                  RETURN TO CALLER\n         SPACE 2\n* * * * * ICDNUM - SCAN AND CONVERT DECIMAL #.   LEVEL - 3            *\n*        ENTRY CONDITIONS                                             *\n*   RA = SCAN POINTER TO 1ST DIGIT OF DECIMAL #                       *\n*   RX = RETURN ADDRESS OF CALLING SECTION                            *\n*        EXIT CONDITIONS                                              *\n*   RA = @ DELIMITER BEYOND #                                         *\n*   RC = VALUE OF #, RIGHT JUSTIFIED.                                 *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nICDNUM   EQU   *\n         $CALL SDDTRM              CALL DECIMAL CONVERTER\n         LTR   RB,RB               WAS THERE ERROR\n         BCR   Z,RX                NO ERRORS,RETURN\n         B     ICNERROR            ERROR-GO HAVE IT FLAGGED\n         EJECT\n* * * * * ICEXP - SCAN AND EVALUATE EXPRESSION - LEVEL - 3            *\n*        ENTRY CONDITIONS                                             *\n*   RA = SCAN POINTER TO 1ST CHARACTER OF EXPRESSION                  *\n*   RX = RETURN ADDRESS OF CALLING SECTION                            *\n*        EXIT CONDITIONS                                              *\n*   RA = SCAN POINTER TO DELIMITER FOLLOWING EXPRESSION               *\n*   RB = ESDID OF EXPRESSION, =0 FOR ABSOLUTE EXPRESSION              *\n*   RC = VALUE OF EXPRESSION                                          *\n*   RE = LENGTH ATTRIBUTE - 1 OF EXPRESSION                           *\n*   CC = SET BY TESTING ESDID                                         *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nICEXP    $CALL EVALUT              EVALUATE EXPRESSION\n         LTR   RB,RB               WAS IT LEGAL\n         BNZ   ICNERROR            NO-GO FLAG AND QUIT\n         LTR   RB,RD               MOVE ESDID OVER AND SET CC\n         BR    RX                  RETURN TO CALLER\n         SPACE 2\n* * * * * ICSDTRM - GET SELF-DEFINING TERM VALUE - LEVEL - 3          *\n*        ENTRY CONDITIONS                                             *\n*   RA = SCAN POINTER TO 1ST CHARACTER                                *\n*   RX = RETURN ADDRESS OF CALLING SECTION                            *\n*        EXIT CONDITIONS                                              *\n*   RA = UNCHANGED IF NOT SD TERM, SCAN PTR TO DELIMITER IF WAS SDTERM*\n*   RC = VALUE OF SELF-DEFING TERM, IF IT WAS ONE                     *\n*   CC   SET BY TESTING RB ON RETURN (<0 ==> NOT SD TERM)             *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nICSDTRM  EQU   *                   DON'T NEED TO SET RB ANYMORE\n         $CALL SDBCDX              CALL GENERAL SD TERM PROCESSOR\n         LTR   RB,RB               TEST CONDITON\n         BCR   NP,RX               RETURN IF EITHER GOOD, OR NOT SD TER\n         B     ICNERROR            IT WAS SD TERM, BUT ILLEGAL ONE\n         EJECT\n* * * * * ICSYM - SCAN AND LOOK UP SYMBOL,RETURN VALUES. LEVEL - 3    *\n*        ENTRY CONDITIONS                                             *\n*   RA = SCAN POINTER TO 1ST CHARACTER OF SYMBOL                      *\n*   RX = RETURN ADDRESS OF CALLING SECTION                            *\n*        EXIT CONDTIONS                                               *\n*   R1 = SCAN POINTER TO DELIMITER FOLLOWING SYMBOL                   *\n*   RA = @ SYMSECT ENTRY FOR THE SYMBOL                               *\n*   RB = ESDID OF THE SYMBOL                                          *\n*   RC = VALUE OF THE SYMBOL                                          *\n*   CC = SET BY TESTING THE ESDID OF THE SYMBOL                       *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nICSYM    TRT   0(9,RA),AWTSYMT     SCAN FOR END OF SYMBOL\n         BZ    ICNBADSY            BAS SYMBOL - TOO LONG\n         LR    RB,R1               MOVE ENDING POINTER OVER\n         SR    RB,RA               GET LENGTH OF SYMBOL\n         BZ    ICNBADSY            SYMBOL OF 0 LENGTH -ERROR\n         $CALL SYFIND              HAVE IT LOOKED UP IN TABLE\n         LTR   RB,RB               WAS IT ALREADY THERE\n         BNZ   ICNUNDEF            UNDEFINED-NOT IN TABLE\n         SPACE 1\n         USING SYMSECT,RA          NOTE SYMBOL TABLE USING\n         TM    SYFLAGS,$SYDEF      IS SYMBOL DEFINED\n         BZ    ICNUNDEF            NOT FLAGGED DEFINED - ERROR\n         IC    RB,SYESDID          GET ESDID OF THE SYMBOL\n         L     RC,SYVALUE          GET VALUE OF THE SYMBOL\n         LTR   RB,RB               SRT CC HERE\n         BR    RX                  RETURN TO CALLER\n         DROP  RA                  KILL USING FOR SYMSECT\n         SPACE 2\n* * * * * ICULEN - GET SPECIFIED LENGTH, OR IMPLIED LENGTH - LEVEL - 3*\n*        ENTRY CONDITIONS                                             *\n*   RX = RETURN ADDRESS OF CALLING SECTION                            *\n*        EXIT CONDITIONS                                              *\n*   R2 = LENGTH-1,SUITABLE FOR USE IN SS INSTRUCTION                  *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nICULEN   IC    R2,ICYXL             GET LENGTH (IF SPECIFIED)\n         TM    ICYF2,ICYXLFN       WAS A LENGTH EXPLICITYLY SPECIFIED\n         BCR   O,RX                YES,RETUNR NOW\n         IC    R2,ICYLQT           NO, IMPLIED LENGTH, GET THE LENGTH-1\n         BR    RX                  RETUNR TO CALLER\n         SPACE 1\nICOIR    OI    ICYR1R2,$CHN        REG OR LENGTH SUPPLIED BY EXECUTE\n         EJECT\n* * * * * INTERNAL CONSTANTS                                          *\n* * * * * TABLE OF ICYFLAG VALUES FOR VARIOUS INSTRUCTION TYPES.      *\n*        A MACRO IS USED TO KEEP INDEPENDENCE ON ACTUAL EQUATE VALUES *\nICTTAB   EQU   *-1                 OFFSET SYMBOL\n         DS    ($ICTMX)C           DEFINE ENOUGH STORAGE FOR MAX TYPES\n         ICT   $RRM,0\n         ICT   $RXM,$ICBEA2+ICBX2+ICBSEA2\n         ICT   $RR,0\n         ICT   $RX,$ICBEA2+ICBX2+ICBSEA2\n         ICT   $RS,$ICBEA2+ICB1D1+ICBSEA2\n         ICT   $RSH,$ICBEA2+ICB1D1+ICBSEA2\n         ICT   $SI,$ICBEA1+ICB1D1\n         ICT   $SS,$ICBEA1+$ICBEA2 WILL BE CHANGED AFTER 1ST OP DONE\n         ICT   $SS2,$ICBEA1+$ICBEA2 ILL BE CHANGED AFTER 1ST OP DONE\n         ICT   $RSO,0              FOR SPM,SVC. OTHERS WILL CHANGE\n         ICT   $SPC,$ICBEA1+ICBX2\n         ORG\n         SPACE 1\n* * * * * INTERNAL VARIABLES                                          *\n         AIF   (&$OPTMS LT 2).ICX12         SKIP IF MEMORY OPT\nICZ1A    DS    2F                  USED BY LEVEL 1 ROUTINES AS SAVE\nICZ1RA   DS    F                   FOR SAVING SCAN POINTER IN ICXBD\nICZ2A    DS    F                   SAVE WORD FOR LEVEL 2 ROUTINES\n.ICX12   AIF   (&$OPTMS GE 2).ICX13         SKIP IF MEMORY NO OPT\nICZ1A    DS    F                   LEVEL 1 SAVE WORD (MEMORY OPTMZ)\n.ICX13   ANOP\nICZ3A    DS    3F                  USED BY LEVEL 3 ROUTINES AS SAVE\n         SPACE 1\n*              INTERNAL LOCATION FOR RCODBLK VARIABLES                *\nICRCB    DS    0F                  ALIGN ON FULLWORD\nICRCLENG DS    C                   LENGTH - 1 OF ICRCB\n         DS    AL3                 ICRCLOC\nICRCTYPE DS    C                   INSTRUCTION TYPE\nICRCHEX  DS    C                   HEX OPCODE\nICRCMASK DS    C                   MASK AND FLAG BITS\nICRCLQ   DS    C                   LENGTH-1 ATTRIBUTE OF INSTRUCTION\nICRCLITA DS    A                   @ LITERAL IN LITERAL TABLE,IF EXISTS\n         SPACE 1\n*              INTERNAL LOCATION FOR OBJECT CODE BLOCK-ICBLOCK        *\nICYBLOCK DS    0F                  ALIGN ON F\nICYEA1   DS    F                   INSTRUCTION @ 1 FOR OUTPT2\nICYEA2   DS    F                   INSTRUCTION @ 2 FOR OUTPT2\nICYOP    DS    C                   OPCODE\nICYR1R2  DS    C                   REGISTERS,MASK,LENGTHS\nICYOPN1  DS    H                   1ST BASE DISPLACEMENT\nICYOPN2  DS    H                   2ND BASE-DISPLACEMENT\nICYFLAG  DS    C                   CONTROLS PROCESSING&PRINTING OF OPRD\n*              THE ABOVE VARS ARE USED BY OUTPT2                      *\nICYF2    DS    C                   BYTE FOR ICXBD TO RETURN STATUS\nICYXL    DS    C                   INDEX OR LENGTH STORED HERE -ICXBD\nICYLQT   DS    C                   FOR IMPLIED LENGTH - LENGTH-1 HERE\n         AIF   (NOT &$XREF).NOXRF16\n*                 0 1 2 3 4 5 6 7 8 9 A B C D E F                     A\nICXRTAB  DC    X'000000000884840C0C0C080000000C0C'         0          A\n         DC    X'84848484840C8484840C848484848484'         1          A\n         DC    X'84848484848484840C84848484848484'         2          A\n         DC    X'8484848484848484840C848484848484'         3          A\n         DC    X'488448840C84840C840C848484004884'         4          A\n         DC    X'48004884840C8484840C848484848484'         5          A\n         DC    X'4884480000000084840C848484848484'         6          A\n         DC    X'4800000000000000840C848484848484'         7          A\n         DC    X'08000800000086868484848484848484'         8          A\n         DC    X'2C00840C840C8484C200000000000000'         9          A\n         DC    X'00000000000000000000000000000000'         A          A\n         DC    X'00000000000000000000000000882C86'         B          A\n         DC    X'06000000000000000000000000000000'         C          A\n         DC    X'00848484840C84840000000084848484'         D          A\n         DC    X'00000000000000000000000000000000'         E          A\n         DC    X'84848484000000008484848484840000'         F          A\n.NOXRF16 ANOP                                                         A\n         DROP  RAT,R13             KILL USINGS\n         TITLE '*** IDASM2 - ASSEMBLER INSTRUCTIONS - PASS 2 ***'\n**--> CSECT: IDASM2   2   ASSEMBLER INSTRUCTIONS - PASS 2 . . . . . . .\n*.       THIS MODULE IS 1 OF THE 2 PASS 2,LEVEL 2 ROUTINES IN THE     .\n*.       ASSIST ASSEMBLER.  IT PERFORMS ALL PROCESSING OF ASSEMBLER   .\n*.       INSTRUCTIONS IN THE SECOND PASS.  IT PRODUCES SOME OBJECT    .\n*.       CODE, AND DOES SETUP FOR PRINTING.  MOST OF THE WORK HAS     .\n*.       ALREADY BEEN DONE IN THE CORREPONDING PASS 1 MODULE, IBASM1. .\n*.       ENTRY CONDITIONS                                             .\n*.  RA = SCAN POINTER (ADDRESS OF 1ST CHARACTER OF OPERAND FIELD)     .\n*.  RC = ADDRESS OF RECORD CODE BLOCK(RCODBLK) FOR STATEMENT          .\n*.  RE = ADDRESS OF RECORD SOURCE BLOCK(RSBLOCK) FOR STATEMENT        .\n*.       CALLS BRDROP,BRUSIN,CCCON2,CNDTL2,ERRTAG,ESENX2,EVALUT,LTDMP2.\n*.       CALLS OUTPT2,UTPUT2                                          .\n*.       USES DSECTS: AVWXTABL,RCODBLK,RSBLOCK,SYMSECT                .\n*.       USES MACROS: $AL2,$CALL,$GLOC,$RETURN,$SAVE,$SDEF,$STV       .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n         SPACE 1\nIDASM2   CSECT\n         $DBG  90,*\n         USING AVWXTABL,RAT        NOTE MAIN TABLE USING\n         USING RCODBLK,RC          RC HAS POINTER ON ENTRY\n         USING RSBLOCK,RE          NOTE ADDRESSIBILITY\n         SPACE 1\n* * * * * REGISTER USAGE FOR IDASM2 * * * * * * * * * * * * * * * * * *\n*   R2 = BYTE REGISTER (HI-ORDER 3 BYTES = 0).                        *\n*   RW = INTERNAL LINK REGISTER - LEVEL - 1 (IDREGET,IDEVAL)          *\n*   RY = 1     USEFUL CONSTANT IN ODD REGISTER.                       *\n*   RC = @ RCODBLK FOR STMT (= AVRCBPT).                              *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n         $SAVE RGS=(R14-R6),SA=IDSAVE,BR=R13\n         LA    RY,1                SET UP HANDY CONSTANT FOR MANY SECTS\n         SR    R2,R2               CLEAR FOR INSERTIONS\n         IC    R2,RCTYPE           GET TYPE BYTE\n         LH    R14,IDAJUMP-$IB(R2) GET OFFSET @ TO RIGHT SECTION\n         TM    RSBFLAG,$REBX       DO ERRORS EXIST ALREADY\n         DROP  RE                  REMOVE RSBLOCK USING NOW\nIDASMJ   BZ    IDASMJ(R14)         GO IF NO ERRORS\n*              ERRORS EXIST - CURRENTLY, PROCESS END CARDS ONLY\n         CLI   RCTYPE,$IB+$IEND    WAS IT AN END CARD\n         BNE   IDOUT2              ANYTHING ELSE - FORGET IT\n         B     IDEND               PROCESS END WHETHER ERRS OR NOT\n         EJECT\n* * * * * INDIVIDUAL ERROR EXITS                                      *\nIDERELOC LA    RB,$ERRELOC         NEED RELOCATABLE VALUE\n         B     IDERROR             GO HAVE ERROR FLAGGED\nIDERELC  LA    RB,$ERNEABS         ABSOLUTE VALUE REQUIRED\n         B     IDERROR             GO HAVE ERROR FLAGGED\nIDREGBIG LA    RB,$EREXGTA         REGISTER OR OTHER VALUE TOO LARGE\n         B     IDERROR             GO HAVE ERROR FLAGGED\nIDERIND  LA    RB,$ERINVDM         INVALID DELIMITER\nIDERROR  $CALL ERRTAG              FLAG IT\n         SPACE 1\n* * * * * PRINT STATEMENT AND RETURN TO CALLER.                       *\nIDOUT2   L     RD,AWFM4            PUT NEG # TO SHOW NO CODE PRINTED\nIDOUT2A  LA    RB,$OUCONS          SHOW TYPE OF CALL TO OUTPT2\nIDOUT    $CALL OUTPT2              HAVE LINE PRINTED\nIDRET    $RETURN RGS=(R14-R6)\n         EJECT\n* * * * * CCW * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nIDCCW    EQU   IDOUT2              **UNTIL CCW CODE WRITTEN           *\n         SPACE 1\n* * * * * CNOP  * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nIDCNOP   IC    R2,RCMASK           GET LENGTH 0-2-4-6\n         SR    R2,RY               DECREMENT LENGTH TO LENGTH - 1\n         BM    IDOUT2              IF L<0,NO OBJECT CODE NEEDED-SKIP\n         LR    RD,R2               MOVE LEN-1 OVER FOR UTPUT2\n         LR    RE,RY               PLACE A 1 IN REG RE-DUPFAC OF 1\n         LA    RC,=3X'0700'        GET @ 3 NOPRS\n         $GLOC RA                  GET LOCATION COUNTER FOR UTPUT2\n         $CALL UTPUT2              CALL OBJECT CODE ROUTINE\n         LA    RC,=3X'0700'        GET @ 3 NOPRS\n         LR    RD,R2               MOVE LENGTH-1 OVER FOR OUTPT2\n         B     IDOUT2A             GO HAVE CODE PRINTED\n         SPACE 1\n* * * * * CSECT * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nIDCSECT  NI    AVTAGS1,255-$IBDSEC1          MAKE SURE FLAGGED CSECT\n         B     IDESCH              GO CHANGE ESDID\n         SPACE 1\n* * * * * DC  * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nIDDC     SR    RB,RB               CLEAR FOR INSERT\n         IC    RB,RCMASK           GET THE NUMBER OF OPERANDS IN DC\n         LA    RC,RCLITEQ          GET @ FIRST OR ONLY CNCBLOCK\n         $CALL CNDTL2              CALL 2ND PASS CONSTANT PROCESSOR\n         B     IDRET               RETURN(CNDTL2 PRINTED LINE)\n         SPACE 1\n         AIF   (&$DEBUG).IDNOD1    SKIP OVER IF NOT DEBUG MODE\n         SPACE 1\n* * * * * DEBUG * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nIDDEBUG  CLI   RCHEX,C'2'          WAS THIS FOR PASS 2\n         BNE   IDOUT2              QUIT IF WASN'T FOR 2\n         MVC   AVDEBUG,RCMASK      MOVE BYTE INTO DEBUG FIELD\n         B     IDOUT2              GO HAVE PRINTED OUT\n.IDNOD1  ANOP\n         SPACE 1\n* * * * * DS  * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nIDDS     EQU   IDOUT2              EVERYTHING DONE IN PASS 1\n         SPACE 1\n* * * * * DROP  * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nIDDROP   BAL   RW,IDREGET          GET THE REGISTER VALUE\n         $CALL BRDROP              HAVE REG DROPPED\n         LR    RA,R1               RESTORE SCAN POINTER\n         LTR   RB,RB               WAS THERE AN ERROR\n         BZ    IDDROK              NO ERROR CONTINUE\n         SR    RA,RY               BACK UP SCAN POINTER BY 1\n         LA    RB,$ERRGNUS         REGISTER NOT USED-ONLY ERROR POSSIBL\n         $CALL ERRTAG              HAVE THE ERROR TAGGED\n         AR    RA,RY               BUMP SCAN POINTER TO NEXT CHAR\n         SPACE 1\nIDDROK   CLI   0(RA),C' '          WAS THIS LAST REGISTER\n         BE    IDOUT2              YES-QUIT\n         CLI   0(RA),C','          IS DELIMITER OK\n         BNE   IDERIND             INVALID DELIMITER-NO COMMA\n         BXH   RA,RY,IDDROP        BUMP SCAN POINTER AND GO BACK\n         EJECT\n* * * * * DSECT * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nIDDSECT  OI    AVTAGS1,$IBDSEC1    FLAG DSECT NOW\nIDESCH   MVC   AVCESDID,RCMASK     MOVE NEW ESDID OVER\n         B     IDOUT2              GO HAVE STATEMENT PRINTED\n         SPACE 1\n* * * * * ENTRY * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nIDENTRY  SR    RB,RB               SHOW THIS IS ENTRY CALL\n         B     IDENEXCL            GO CALL ESENX2 ROUTINE\n         SPACE 1\n* * * * * EJECT * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nIDEJECT  SR    RE,RE               SHOW THIS IS SPACE OR EJECT\n         B     IDPRIN2             GO TO CALL PRINTOUT ROUTINE\n         SPACE 1\n* * * * * END * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*        SETS AVFENTER=ENTRY @, LEAVES = START VALUE OR 0 IF NO END SY*\nIDEND    CLI   0(RA),C' '          WAS THERE A SYMBOL ON THE END CARD\n         BE    IDLTORG             GO HANDLE AS LTORG\n         BAL   RW,IDEVAL           HAVE EXPRESSION EVALUATED\n         ST    RC,AVFENTER         SAVE THIS ENTRY POINT VALUE\n         B     IDLTORG             GO HANDLE AS LTORG NOW\n         SPACE 1\n* * * * * EQU * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*        SETS RCLOC = VALUE OF EQU SYMBOL FOR LISTING.                *\nIDEQU    MVC   RCLOC,RCLITEQ+1     MOVE VALUE OF SYMBOL OVER FOR PRINT\n         B     IDOUT2              GO PRINT STMT\n         SPACE 1\n* * * * * EXTRN * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nIDEXTRN  LA    RB,2                SHOW ESENX2 THIS IS EXTRN\nIDENEXCL $CALL ESENX2              CALL ROUTINE\n         B     IDOUT2              PRINT STATEMENT AND RETURN\n         SPACE 1\n* * * * * LTORG * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*              END CARD PROCESSING ALSO USES THIS CODE                *\nIDLTORG  LA    RB,$OUCOMM          SHOW NO LOCATION COUNTER-END-LTORG\n         L     RD,AWFM4            SHOW THERE IS NO CODE TO BE PRINTED\n         $CALL OUTPT2\n         $CALL LTDMP2              HAVE LITERALS DUMPED AND PRINTED\n         B     IDRET               RETURN\n         SPACE 1\n* * * * * ORG * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nIDORG    EQU   IDOUT2              EVERYTHING ALREADY DONE IN PASS 1\n         EJECT\n* * * * * PRINT * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nIDPRINT  LA    RE,2                SHOW THIS IS A PRINT COMMAND\nIDPRIN2  LA    RC,RCMASK           @ TAG BITS(PRINT) OR # (SPACE,EJECT)\n         B     IDLIST              GO TO CALL ROUTINE\n         SPACE 1\n* * * * * SPACE * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nIDSPACE  EQU   IDEJECT             HANDLED SAME AS EJECT\n         SPACE 1\n* * * * * START * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nIDSTART  EQU   IDCSECT             HANDLE SAME AS CSECT\n         SPACE 1\n* * * * * TITLE * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nIDTITLE  EQU   *                   PROCESS TITLE STATEMENT       CPP\n         LA    RA,1(RA)            RA=>1ST BYTE OF TITLE (AFTER ') CPP\n         SR    RB,RB               CLEAR FOR INSERT            CPP\n         IC    RB,RCMASK           GET LENGTH-1 OF TITLE       CPP\n         $CALL CCCON2              EVALUATE OPD. (SAME AS C-TYPE DC) CP\n         LA    RE,4                SHOW THIS IS A TITLE\n*              COMMON CODE - EJECT,PRINT,SPACE,TITLE.\nIDLIST   LA    RB,$OULIST          SHOW LISTING CONTROL\n         B     IDOUT               GO FINALLY TO CALL OUTPT2\n         SPACE 1\n* * * * * USING * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nIDUSING  BAL   RW,IDEVAL           CALL EXPRESSION EVALUATORE\n         SPACE 1\n*              INITIALIZES FOR POSSIBLE MULTIPLE USING, LOOP IF SO.\nIDUSB    LR    RX,RC               MOVE LOCATION COUNTER VALUE OVER\n         L     RC,AVRCBPT          GET RCODBLK POINTER BACK,USING THER\n         $STV  RX,RCLOC            SAVE LOCATION FOR PRINTING\n         SPACE 1\nIDUSC    CLI   0(RA),C','          MAKE SURE COMMA IS THERE\n         BNE   IDERIND             BRANCH IF NOT-INVALIDDELIM\n         AR    RA,RY               BUMP SCAN POINTER BEYOND ,\n         BAL   RW,IDREGET          GO GET 1ST OR AFTER REGISTER VALUE\n         LR    RB,RX               PUT CURRENT USING VALUE IN REG\n         LR    RC,RZ               MOVE THE ESDID OVER FOR THE CALL\n         $CALL BRUSIN              HAVE USING ENTERED\n         SPACE 1\n         CLI   0(R1),C' '          SCAN PT IN R1,CHECK FOR LAST\n         BE    IDOUT2              QUIT IF DONE\n         LA    RX,4095(RY,RX)      BUMP CURRENT USING 4096\n         LR    RA,R1               MOVE SCAN POINTER BACK OVER\n         B     IDUSC               BUMP SCAN POINTER AND CONTINUE\n         EJECT\n**--> INSUB: IDREGET    CONVERT REGISTER, CHECK VALIDITY  + + + + + + +\n*+       ENTRY CONDITIONS                                             +\n*+  RA = SCAN POINTER TO 1ST CHARACTER OF REGISTER                    +\n*+  RW = RETURN @ TO CALLING SECTION OF CODE                          +\n*+       EXIT CONDITIONS                                              +\n*+  R1 = SCAN PTR TO @ DELIMITER FOLLOWING SCAN (IF REGISTER GOOD).   +\n*+  RA = VALUE OF REGISTER IF GOOD, = SCAN PTR TO ERROR IF BAD.       +\n*+  RC = VALUE OF REGISTER IF GOOD.                                   +\n*+  + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +\n         SPACE 1\nIDREGET  $CALL EVALUT              USE EXP EVAL (LOW PROB USAGE)\n         LR    R1,RA               SAVE SCAN PTR\n         LTR   RB,RB               WAS REGISTER OK\n         BNZ   IDERROR             NO, BRANCH AND FLAG IT\n         LTR   RD,RD               CHECK FOR ABSOLUTE VALUE, NOT RELOC\n         BNZ   IDERELC             ^=0 ==> RELOCATABLE==> ERROR\n         SPACE 1\nIDREGCHK C     RC,AWF15            MAKE SURE REG NOT TOOT LARGE\n         BH    IDREGBIG            NO,REGISTER TOO LARGE\n         LR    RA,RC               PUT REGISTER WHERE DESIRED\n         BR    RW                  RETURN TO CALLER,READY FOR DROP,USIN\n         SPACE 1\n**--> INSUB: IDEVAL     EVALUATE RELOCATABLE EXPRESSION + + + + + + + +\n*+       ENTRY CONDITIONS                                             +\n*+  RA = SCAN PTR TO 1ST CHARACTER OF EXPRESSION                      +\n*+  RW = RETURN @ TO CALLING SECTION IN IDASM2                        +\n*+       EXIT CONDITIONS                                              +\n*+  RZ = SECTION ID OFTHE EXPRESSION  (SAME AS VALUE IN RD)           +\n*+  RA = SCAN PTR @ TO DELIMITER IF GOOD, TO ERROR IF NOT.            +\n*+  RC = VALUE OF THE EXPRESSION                                      +\n*+  + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +\nIDEVAL   $CALL EVALUT\n         LTR   RB,RB               WAS EXPRESSION OK\n         BNZ   IDERROR             NO, ERROR\n         LTR   RZ,RD               DUPLICATE ESDID, TEST FOR RELOCATBL\n         BCR   NZ,RW               RETURN IF RELOCATABLE (RD ^= 0)\n         B     IDERELOC            ERROR, NEED RELOCATABLE EXPRESSION\n         SPACE 1\n* * * * * INTERNAL CONSTANTS                                          *\n* * * * * BRANCH OFFSET TABLE FOR INDIVIDUAL INSTRUCTIONS             *\nIDAJUMP $AL2   IDASMJ,(IDUSING,IDDROP,IDSTART,IDCSECT,IDDSECT,IDENTRY,I#\n               DEXTRN,IDEQU,IDDC,IDDS,IDCCW,IDTITLE,IDEJECT,IDSPACE,IDP#\n               RINT,IDORG,IDLTORG,IDCNOP,IDEND),-2\n         AIF   (&$DEBUG).IDNOD2    SKIP IF NOT DEBUG MODE\n         DC    AL2(IDDEBUG-IDASMJ)           OFFSET TO DEBUG ROUTINE\n.IDNOD2  ANOP\n         LTORG\n         DROP  RAT,R13,RC          KILL USINGS\n         TITLE '*** INPUT1 - INPUT CARDIMAGE READER/PROCESSORS ***'\n**--> CSECT: INPUT1   1   INPUT AND MANIPULATION OF SOURCE CARDS. . . .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nINPUT1   CSECT\n         $DBG  90,*\n         USING AVWXTABL,RAT        MAIN TABLE USING\n         ENTRY INCARD\n         SPACE 2\n**--> ENTRY: INCARD       CALLED TO GET CARD AND CREATE RSBLOCK . . . .\n*.       THIS ENTRY READS 1 STATEMENT (1-3 CARDS), AND SETS UP THE    .\n*.       RECORD BLOCKS RSBLOCK, AND RSCBLK (IF CONTINUATIONS OR       .\n*.       SEQUENCE NUMBERS ARE USED).  IT IS CALLED DURING PASS 1 OF   .\n*.       THE ASSEMBLY.  IF AN ENDFILE INDICATION IS ENCOUNTERED, IT   .\n*.       CREATES A PSEUDO ENDCARD, SINCE THE MAIN PROGRAM OF PASS 1   .\n*.       MOCON1 ONLY STOPS AFTER AN END CARD IS FOUND.  AS OF 8/17/70,.\n*.       INCARD IS THE ONLY ASSEMBLER ENTRY DOING CARD READING.       .\n*.       IN SETTING UP THE RSBLOCK, INCARD CONCATENATES THE SECTIONS  .\n*.       OF A CONTINUED STATEMENT, AND REMOVES BLANKS TO SOME DEGREE  .\n*.       FROM THE TRAILING EDGE OF THE STATEMENT.  IT ALSO INSERTS    .\n*.       THE 3 CHARACTERS BLANK,APOSTROPHE,BLANK AFTER THE LAST       .\n*.       NONBLANK CHARACTER IN THE SOURCE STATEMENT.  THIS IS CRUCIAL .\n*.       TO THE PROPER SCANNING OF THE SOURCE STATEMENT WITHOUT       .\n*.       REQUIRING LENGTHS TO BE CARRIED FROM ROUTINE TO ROUTINE.     .\n*.                                                                    .\n*.             IF THE MACRO PROCESSOR EXISTS (&$MACROS=1), INCARD     .\n*.       ALSO HANDLES RECOVERY OF GENERATED STMTS (CREATED BY MEXPND ..\n*.       IN THE DYNAMIC-HIGH AREA).                                   .\n*.             IF A MACRO LIBRARY FACILITY EXISTS (&$MACSLB=1),       .\n*.       INCARD CAN BE SWITCHED TO READ FROM IT, INSTEAD OF $SORC.    .\n*.       EXIT CONDITIONS                                              .\n*.  RA = SCAN PTR TO ERROR, ONLY IF RB ^= 0.  NO MEANING IF RB = 0.   .\n*.  RB = 0     NO ERRORS FOUND IN STATEMENT BY INCARD                 .\n*.  RB = ERROR CODE (NONZERO) OF ERROR.  RA HAS SCAN PTR OF IT.       .\n*.  AVSOLAST = @ BLANK IMMEDIATELY BEFORE ' IN THE 4-BYTE FIELDWHICH  .\n*.       INCARD PLACES AFTER THE SOURCE STMT TO STOP SCANNING OVERRUN..\n*.       USES DSECTS: AVWXTABL,RSBLOCK,RSCBLK,RSOURCE                 .\n*.       USES MACROS: $RETURN,$SAVE,$SORC                             .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n         SPACE 1\n* * * * * REGISTER ALLOCATION FOR INCARD  * * * * * * * * * * * * * * *\n*   R1 = NUMBER OF CARDS INCLUDED IN CURRENT RSBLOCK (FROM 1-3)       *\n*   R2 = 0 (INITIALLY) - BYTE REGISTER FOR INSERTION                  *\n*   RW = ADDRESS OF RSBLOCK BEING BUILT                               *\n*   RX = ADDRESS OF RSCBLK BEING BUILT(IF ANY)                        *\n*   RY = ADDRESS WHERE NEXT SOURCE SHOULD BE READ(RSOURCE)            *\n*   RZ = CURRENT LENGTH-1 OF RSBLOCK BEING BUILT                      *\n*   R14= INTERNAL LINK REGISTER (FOR INCRSMV).                        *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\nINCARD   $SAVE RGS=(R14-R6),SA=NO\n         AIF   (&$DEBUG).INNZ      SKIP IF NOT DEBUGGIN MODE\n         MVC   AVRSBLOC(256),AWTZTAB         ZERO OUT ***DEBUGGING ***\n.INNZ    LA    R1,1                INIT # CARDS TO 1\n         LM    RW,RX,AVRSBPT       VRSBPT,VRSCPT POINTERS\n         USING RSBLOCK,RW          NOTE RSBLOCK USING SETUP\n         USING RSCBLK,RX           NOTE RSCBLK USING SETUP\n         LA    RY,RSBSOURC         INIT POINTER TO NEXT INPUT AREA\n         USING RSOURCE,RY          NOTE CARDIMAGE USING\n         LA    RZ,RSB$LN1          INIT LENGTH-1 OF RSBLOCK\n         SR    R2,R2               CLEAR FOR ZERO VALUE\n         ST    R2,RSBLENG          ZERO OUT WHOLE CODES SECTION\n         SR    RB,RB               CLEAR INITIALLLY==> NO ERRORS\n         TM    AVTAGS2,$INEND2     HAS THERE BEEN EOF, END CARD NEEDED\n         BO    INCREOF             END CARD NEEDED-GO CREATE IT\n         SPACE 1\n         AIF   (NOT &$MACROS).INNOMA        SKIP IF NO MACROS\n*              SEE IF EXPANDED STMTS EXIST. IF SO, PROCESS NEXT ONE.\n         L     RC,AVGEN1CD         @ 1ST BYTE BEYOND NEXT GEN'D STMT\n         C     RC,AVGEN2CD         CHECK AGAINST LOWER LIMIT\n         BNH   INNOTGEN            SKIP IF THERE ARE NO MORE CARDS\n         SPACE 1\n         C     RC,AVADDHIH         MAKE SURE AVGEN1CD <= AVADDHIH\n         BH    INMOVRGN            RAN OVER GENERATED CODE FROM TOP\n         CLC   AVGEN2CD,AVADDLOW   CHECK FOR OVERRUN FROM BOTTO4\n         BNH   INMOVRGN            YES IT DID (MORE LIKELY) - GO\n         SPACE 1\n*              MOVE NEXT EXPANDED STMT OVER TO RSBLOCK AREA.\n         LA    RD,RSB$L            = LENGTH OF CONSTANT PART OF RSBLOCK\n         SR    RC,RD               DECREMENT GEN PTR\n         MVC   RSBLOCK(RSB$L),0(RC)         COPY CONSTANT PART\n         IC    RZ,RSBLENG          GET L-1 OF GEN'D STMT\n         STC   RZ,INMMOVE+1        PUT L-1 INTO MVC INSTR\n         SR    RC,RZ               GET @ 2ND BYTE OF GEN'D STMT (L-1)\n         SR    RC,R1               GET @ 1ST BYTE OF GEN'D STMT\nINMMOVE  MVC   RSBSOURC($),0(RC)   MOVE WHOLE STMT OVER\n         SPACE 1\n*              IF THERE ARE ALREADY ERRORS IN THE STMT, MOVE THE\n*              RESULTING REBLK OVER TO NORMAL LOCATION.\n         TM    RSBFLAG,$REBX       DOES THE STMT HAVE ERRORS\n         BZ    INMNOREB            NO, JUMP (NORMAL CASE)\n         IC    R2,RSBNUM           GET REBLN FROM TEMPORARY LOCATION\n         STC   R2,AVREBLN          STORE THE LENGTH-1 OF ERROR BLOCK\n         SR    RC,R2               RC = @ OF REST OF REBLK (NOT REBLN)\n         SR    R2,R1               GET L-1 OF PART OF REBLK LEFT\n         STC   R2,*+5              PLACE L-1 INTO MVC INSTR\n         MVC   AVREBES($),0(RC)    MOVE REST OF ERROR BLOCK OVER\n         SPACE 1\nINMNOREB ST    RC,AVGEN1CD         UPDATE PTR TO NEXT GEN'D STMT\n         SPACE 1\n*              STMT FROM MACRO PROCESSOR MAY HAVE 1-2 EXTRA BLANKS AT\n*              END: REMOVE THEM SO DON'T CAUSE UNNECESSARY CONT CARDS.\n         LA    RC,RSBSOURC-1(RZ)   @ NEXT TO LAST CHAR OF STMT\n         CLI   1(RC),C' '          WAS LAST BYTE A BLANK\n         BNE   INMOBLN             NO, SKIP, DON'T REMOVE\n         CLI   0(RC),C' '          WAS NEXT TO LAST A BLANK\n         BNE   *+6                 NO, REMOVE ONLY 1 - BRANCH\n         SR    RZ,R1               YES, REMOVE 2 BLANKS FROM COUNT\n         SR    RZ,R1               REMOVE OTHER BLANK\n*              NOW CONSTRUCT RSCBLK, IF STMT REQUIRES IT BY BEING TOO *\n*        LARGE TO FIT ON 1 CARD.  AT THIS PT, RZ = LENGTH-1 OF STMT.  *\n*        (RZ) <=  70 ==> 1 CARD,  NO RSCBLK.                          *\n*        (RZ) <= 126 ==> 2 CARDS, RSCBLK, 21 BYTES LONG               *\n*              RSCLENG = 2*RSC$LEN; RSCILEN(1) = RSOL1;               *\n*              RSCILEN(2) = (RC) - (RSOL1-1) .\n*        (RZ) <= 182 ==> 3 CARDS, RSCBLK, 31 BYTES LONG.              *\n*              RSCLEN = 3*RSC$LEN; RSCILEN(1) = RSOL1;\n*              RSCILEN(2) = RSOLC; RSCILEN(3) = (RC) -(RSOL1-1)-RSOLC.\n         SPACE 1\nINMOBLN  LR    RC,RZ               GET L-1 TO BE DESTROYED\n         AR    RZ,RD               GET L-1 OF ENTIRE RSBLOCK, AS NEEDED\n         SPACE 1\n         SH    RC,=AL2(RSOL1-1)    GET # BYTES IN GEN'D CARDS 2,3\n         BNP   INCNORM             <=0, SO ONLY 1 CARD- BRANCH(NORMAL)\n         TM    RSBFLAG,$RSBMERR    MACRO ERROR?                       J\n         BO    INCNORM             YES, CAN'T BE CONTINUED ANYWAY     J\n         SPACE 1\n*              CONTINUATION CARDS NEEDED, LIKEWISE RSCBLK (MOAN).\n         LA    RY,AWBLANK          FAKE BLANK CARDIMAGE FOR INCRSMV\n         LA    RE,RSOLC            GET LENGTH OF CONTINUED CARDIMAGE\n         AR    R1,R1               SET # CARDS SO FAR = 2 (AT LEAST)\n         BAL   R14,INCRSMV1        HAVE 1ST SECTION OF RSCBLK SET UP\n         MVI   RSCONSQ-RSCILEN(RD),C'X'      INDICATE CONTINUED CARD\n         BAL   R14,INCMOV          MOVE SECOND CARD SEQNO/SET CODES\n         SPACE 1\n         CR    RC,RE               ARE THERE 2 CARDS OR 3\n         BNH   INMCONT2            <= RSOLC ==> ONLY 2 CARDS TOTAL - GO\n         SPACE 1\n         SR    RC,RE               GET LENGTH OF 3RD CARD IMAGE\n         MVI   RSCONSQ-RSCILEN(RD),C'X'   SHOW 2ND CARD CONINUED\n         BAL   R14,INCMOV          SAVE 3RD AND LAST SECTION OF RSCBLK\n         LA    R1,1(,R1)           SET  TOTAL # CARDS = 3.\n*              IT IS ASSUMED THAT MEXPND NEVER CREATES STMTS HAVING   *\n*              MORE THAN 193 (RSOL1+2*RSOLC) BYTES OF SOURCE DATA.    *\n*              OTHERWISE, IT WOULD BE NECESSARY TO CHECK (RC) <= RSOLC*\nINMCONT2 STC   RC,RSCILEN-RSCILEN(,RD)  SAVE LENGTH OF LAST PART <=56.\n         B     INCNORM             ALL SET, NO GO PROCESS NORMALLY\n         SPACE 1\nINMOVRGN EQU   *                   COME HERE IF OVERRUN OCCURS\n         MVC   AVGEN1CD,AVGEN2CD   COPY, SO THINKS NO MORE GEN'D STMTS\n         MVC   0(80,RY),AWBLANK    FAKE A BLANK CARD\n         OI    RSBFLAG,$RSBNPNN    DON'T PROCESS FURHTER\n         LA    RB,$EROVRGN         FLAG ERROR: GEN'D STMTS OVERRUN\n         B     INCHECK             SKIP OVER CARD READ AND GO ON\n         EJECT\n         SPACE 1\nINNOTGEN EQU   *                   ENTERED IF NOT GENRTED STMT\n.INNOMA  ANOP\n         $SORC 0(RY),80,INCREOF    READ FIRST,HOPEFULLY ONLY,CARD\nINCHECK  CLI   RSOCONT,C' '        CHECK FOR CONTINUATION CAHR\n         BNE   INCCONT             CARD MUST BE CONTINUED-BRANCH\n         CLC   RSOSEQN,AWBLANK     IS THERE SEQUENCE INFO\n         BE    INCNORM             NO SEQNO-BRANCH NORMAL\nINCHC    BAL   R14,INCRSMV         CALL CONTINUATION/SENO SAVER\n         EJECT\n*              ENTIRE STATEMENT READ-FINISH UP AND RETURN             *\nINCNORM  STC   R1,RSBNUM           SAVE # CARDS(HOPEFULLY 1)\n         LA    RE,RSBLOCK(RZ)      GET @ LAST ACTUAL SOURCE BYTE\n*              FOLLOWING SECTION REMOVES BLANKS FROM END OF CARD.     *\n         BCT   R1,INCBLC           SKIP BLANK-CRUNCH IF >1 CARD\n*              REMOVE 36 BLANKS QUICKLY, IF POSSIBLE\n         LH    R2,=H'-36'          GET VALUE TO BACK UP @ PTR\n         AR    R2,RE               GET @ BEGINNING OF COMMENTS FIELD\n         CLC   1(36,R2),AWBLANK    IS HALF OF CARD ALL BLANK\n         BE    INCBL               YES,SO LEAVE R2 WHERE IT IS, BLANKS\n         LR    R2,RE               WASN'T BLANK, DO WHOLE THING\nINCBL    LA    R1,RSBSOURC+9       LIMIT @, INCLUDING POSSIBLE LABEL\n         LH    R0,=H'-8'           DECREMENT: 8 BLANKS PER CHUNK\n         BXLE  R2,R0,INCBLN        DECREMENT/TEST, SKIP IF TERHE ALREAD\n         SPACE 1\n         CLC   1(8,R2),AWBLANK     CHOP OFF 8 BLANKS IF POSSIBLE\n         BNE   INCBLN              NOT BLANKS, TOO BAD, SKIP OUT\n         BXH   R2,R0,*-10          LOOP UNTIL LIMIT REACHED\nINCBLN   SR    R2,R0               SUBTRCT DECREMNT, PUT PTR BACK OK\n         SPACE 1\n         L     R0,AWFM1            GET NEW DECREMENT FOR 1 AT A TIME\n         SPACE 1\n*              LOOP TO REMOVE BLANKS FROM END OF STMT, 1 AT A TIME.   *\nINCBLA   CLI   0(R2),C' '          IS THIS A BLANK\n         BNE   INCBLB              NO IT ISNT, SO QUIT REMOVING-BRANCH\n         BXH   R2,R0,INCBLA        LOOP UNTIL LIMIT @ REACHED\n         SPACE 1\n         SR    R2,R0               SUBTRCT -1,PUT POINTER BACK RIGHT\nINCBLB   SR    R2,RE               GET # BLANKS REMOVED\n         AR    RZ,R2               ADD DECREMENT TO LENGTH VALUE IN RZ\n         AR    RE,R2               OBTAIN @ LAST BYTE(NEW)\n         SPACE 1\n*              CONCATENATE ENDING FIELD \"  ' \" TO SOURCE STMT TO      *\n*              PREVENT SCANNING BEYOND END OF STMT. SAVE LIMIT @ IN   *\n*              AVSOLAST, SAVE FINAL LENGTH-1 OF RSBLOCK. RETURN.      *\nINCBLC   EQU   *                   FOR SKIP IF >1 CARD, NO CRUNCH\n         MVC   1(4,RE),INCBQB      MOVE IN DELIMITER  VALUE\n         LA    RC,2(RE)            GET @ OF BLANK BEFORE ENDING '\n         ST    RC,AVSOLAST         STORE THIS FOR OTHER'S USE\n         LA    RZ,2(RZ)            INCREMENT RZ BY 1 TO GET >=2BLANKS\n         STC   RZ,RSBLENG          SAVE L-1 OF RSBLOCK\nINCRET   $RETURN RGS=(R14-R6),SA=NO\n         EJECT\n*              FOLLOWING SECTION ENTERED FOR CONTINUATION CARD        *\nINCCONT  BAL   R14,INCRSMV         HAVE CONTINUATION FIELD-SEQNO SAVED\n         C     R1,AWF3             IS # OF CARDS<3(MAXIMUM)\n         BNL   INCERR1             NO,WE HAVE TOO MANY CONTS(3 OR MORE)\n         LA    RY,RSBLOCK+1(RZ)    GET NEXT ADDRESS TO BE INPUT\n         $SORC 0(RY),80,INCREOFA   GET NEXT CARD\n         CLC   RSOLOPC,AWBLANK     ARE 1ST 15 COLUMNS BLANK\n         BE    INCCOK              BRANCH IF IT IS BLANK(OK)\n         LR    RA,RY               ERROR-MOVE  ADDRESS OVER\n         LA    RB,$ERCONT          ILLEGAL CONTINUATION-ERROR\n         SPACE 1\nINCCOK   MVC   RSOURCE(L'RSOOPRCM),RSOOPRCM  MOVE CARD IMAGE OVER\n         LA    RZ,L'RSOOPRCM(RZ)   INCREMENT LENGTH-1 OD RSBLOCK\n         LA    R1,1(R1)            INCRMENT NUMBER OF CARDS\n         CLI   RSOCONT,C' '        IS CONTINUATION CARD CONINUED ALSO\n         BE    INCHC               NO IT ISNT,HAVE LAST CONT/SEN SAVED\n         B     INCCONT             CONINUED AGAIN-KEEP GOING\nINCREOF  MVC   RSBSOURC(71),AWBLANK         BLANK OUT SOURCE AREA\n         SPACE 1\n         MVC   RSBSOURC+9(3),=C'END'        MAKE UP END CARD\n         LA    RA,RSBSOURC+10      SET PTR TO END FOR WARNING\n         LA    RB,$ERNOEND         WARNING-MESSAGE CODE-NO END CARD\nINCREOFA OI    AVTAGS2,$INEND2     EOF==> CREATE END CARD NEXT TIME\n         B     INCNORM             GO SET FLAGS AND RETURN\nINCERR1  LA    RB,$ERCONTX         TOO MANY CONTINUATIONS(>2)\n         LA    RA,RSOCONT-1        GET THE POINTER\n         LA    R14,INCNORM         SET RETURN ADDR OF INCRSMV\n*              FALL THRU INTO INCRSMV (WHICH MUST FOLLOW).\n         SPACE 1\n**--> INSUB: INCRSMV    SAVE CON/SEQNO INTO RSCBLK  + + + + + + + + + +\n*+       ENTRY CONDITIONS                                             +\n*+  RY = @ CARDIMAGE FROM WHICH CON/SEQNO TAKEN (RSOURCE DSECT)       +\n*+       EXIT CONDITIONS                                              +\n*+  RD = @ VARIABLE PART OF RSCBLK JUST CREATED (I.E. NEWEST RSCILEN) +\n*+  R14= RETURN @ TO CALLING SECTION OF CODE IN INCARD.               +\n*+  R2   IS DESTROYED.                                                +\n*++ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +\n         SPACE 1\nINCRSMV  TM    RSBFLAG,$RSCX       HAVE THERE BEEN PREVIOUS CONT/SEQS\n         BO    INCMOV              YES THERE HAVE,BRANCH\nINCRSMV1 OI    RSBFLAG,$RSCX       SHOW 1ST ONE - RSC EXISTS\n         MVI   RSCLENG,0           ZERO OUT LENGTH AT FIRST\n         MVI   RSCILEN,RSOCONT-RSOURCE      LENGTH FOR 1ST CRD(71)\nINCMOV   IC    R2,RSCLENG          GET CURRENT L-1 OF BYTES\n         LA    RD,RSCILEN(R2)      GET ADDR OF NEXT SLOT\n         LTR   R2,R2               WAS THIS 1ST CARD\n         BZ    *+8                 SKIP MVI IF IT WAS 1ST\n         MVI   0(RD),L'RSOOPRCM    MOVE IN LENGTH FOR CONT CARD (56,\n         MVC   RSCONSQ-RSCILEN(9,RD),RSOCONT MOVE CONT/SEQ OVER\n         LA    R2,RSC$LEN(R2)      INCREMENT LENGTH-1\n         STC   R2,RSCLENG          UPDATE LENGTH-1\n         BR    R14                 RETURN TO CALLING SECTION\n         SPACE 1\n* * * * * INTERNAL CONSTANTS                                          *\nINCBQB   DC    C'  '' '            DELIMITER FIELD FOR END OF SOURCE\n         LTORG\n         DROP  RAT,REP,RW,RX,RY    REMOVE ALL USINGS\n         TITLE '*** LTOPRS - LITERAL OPERATIONS ***'\n**--> CSECT: LTOPRS   1-2 ALL LITERAL TABLE OPERATIONS. . . . . . . . .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nLTOPRS   CSECT\n         $DBG  A0,*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*              NOTE RESTRICTION - A-TYPE ADCONS IN LITERALS MAY NOT   *\n*              MAKE REFERENCES TO THE LOCATION COUNTER.   A WARNING   *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         USING AVWXTABL,RAT        NOTE MAIN TABLE USING\n         ENTRY LTINT1,LTENT1,LTDMP1,LTEND1,LTGET2,LTDMP2\n         SPACE 2\n**--> ENTRY: LTINT1   1   INITIALIZE LITERAL TABLE IF NEEDED. . . . . .\n*.  ALLOCATES AND ZEROS 1ST LITERAL POOL BASE TABLE. INITS 1ST AND    *\n*.  CURRENT BLOCK POINTERS TO 1ST LTBASETB.                           *\n*.       CALLS MOSTOP                                                 .\n*.       USES DSECTS: AVWXTABL,LTBASETB                               .\n*.       USES MACROS: $ALLOCH,$RETURN,$SAVE                           .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nLTINT1   $SAVE SA=NO\n         LA    RB,LTB$LEN          GET LENGTH OF 1 LTBASETB ENTRY\n         $ALLOCH RA,RB,LTZOVER     GET NEEDED SPACE\n         LR    RB,RA               DUPLICATE THIS VALUE\n         STM   RA,RB,LTBFIRST      LTBFIRST-LTBNOW - SET POINTERS\n         USING LTBASETB,RA         NOTE USING\n         MVC   LTBASETB(LTB$LEN),AWZEROS     ZERO OUT THE TABLE\n         DROP  RA                  CLEAN UP USING\n         $RETURN SA=NO\n         EJECT\n**--> ENTRY: LTENT1   1   ENTER A LITERAL INTO THE TABLE. . . . . . . .\n*.       THIS ENTRY IS CALLED DURING PASS 1 TO SCAN A LITERAL BY      .\n*.       IAMOP1.  THE LITERAL IS SCANNED BY CODTL1, AND IT IS ENTERED .\n*.       IF IT IS NOT ALREADY PRESENT.  NOTE THAT NO DUPLICATES       .\n*.       ARE EVER KEPT IN THE SAME POOL, EVEN FOR A-TYPE CONSTANTS    .\n*.       WITH LOCATION COUNTER REFERENCES.                            .\n*.       ENTRY CONDITIONS                                             .\n*.  RA = SCAN POINTER (ADDRESS OF = IN LITERAL)                       .\n*.       EXIT CONDITIONS                                              .\n*.  RA = SCAN POINTER (ADDRESS OF ERROR OR DELIMETER)                 .\n*.  RB = 0 IF LITERAL LEGAL, ERROR CODE OTHER WISE                    .\n*.  RC = ADDRESS OF LITERAL TABLE ENTRY                               .\n*.       CALLS CODTL1,MOSTOP                                          .\n*.       USES DSECTS: AVWXTABL,CNCBLOCK,LTBASETB,LTLENTRY,RSBLOCK     .\n*.       USES MACROS: $ALLOCH,$CALL,$RETURN,$SAVE,$SCPT               .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n         SPACE 1\n* * * * * REGISTER ALLOCATION FOR LTENT1  * * * * * * * * * * * * * * *\n*   R1 = #-1 OF CHARACTERS IN THE LITERAL BEING PROCESSED             *\n*   R2 = # OF CHARACTERS IN LITERAL,ROUNDED TO FULLWORD, THEN -1      *\n*   RW = BASE REGISTER                                                *\n*   RX = INITIAL SCAN POINTER TO = OF LITERAL                         *\n*   RC = @ CNCBLOCK PROVIDED BY CODTL1                                *\n*   RD = TOTAL LENGTH OF NEW LTENTRY BLOCK                            *\n*   RE = @ LTENTRY BLOCK FOR A NEW LITERAL                            *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nLTENT1   $SAVE RGS=(R14-R6),SA=LTOPSAVE,BR=R3\n         SPACE 1\n*              INITIALIZES, CALL 1ST-PASS CONSTANT PROCESSOR.\n         LR    RX,RA               SAVE SCAN POINTER\n         LA    RA,1(RA)            INCREMENT POINTER PAST =\n         LA    RB,8                SHOW CODTL1 WE ARE IN LITERAL\n         $CALL CODTL1              CALL DUPLFAC-TYPE-LENGTH PROCESSOR\n         LTR   RB,RB               WAS THERE AN ERROR\n         BNZ   LTE1RET             IF SO,RETURN SHOWING ERROR\n         SPACE 1\n*              CHECK TO MAKE SURE NO MISSING DELIMITER.\n         C     RA,AVSOLAST         COMPARE TO @ BLANK BEFORE '\n         BNL   LTE1ERR3            MISSING QUOTE ON C-CON-ERROR\n         USING CNCBLOCK,RC         CODTL1 HAS SET UP A CNCBLOCK\n         SPACE 1\n*              SET UP FOR LOOKING FOR A DUPLICATE LITERAL             *\n         LR    R1,RA               MOVE NEW SCAN POINTER OVER\n         SR    R1,RX               GET LENGTH OF LITERAL-# OF CHARS\n         LA    R15,112             GET LENGTH FOR COMPARISON\n         CR    R1,R15              MAKE SURE NO MORE THAN 2 CARDS\n         BH    LTE1ERR4            BRANCH IF TOO LONG\n         BCTR  R1,0                GET # CHARS - 1 IN LITERAL\n         BCTR  RE,0                GET TOTAL LENGTH-1 OF LITERAL DC\n         N     RE,AWF7             REMOVE ALL BUT LAST 3 BITS OF LENGTH\n         IC    R15,LTEB1248(RE)    GET THE OFFSET TO POINTER -LTBASETB\n         L     R14,LTBNOW          GET @ CURRENT LTBASETB\n         USING LTBASETB,R14        NOTE TABLE USING\n         LA    RE,LTBCH1(R15)      GET @ ACTUAL POINTER -LTBCH1-2-4-8\n         DROP  R14                 NO LONGER NEEDED\n         USING LTLENTRY,RE         WILL POINT AT 1ST ENTRY,IF ^=0\n         STC   R1,LTE1CLI+1        SAVE #-1 OF CHARS INTO CLI\n         STC   R1,LTE1CLC+1        SAVE #-1 OF CHARS INTO CLC ALSO\n         BAL   R15,LTE1L           BEGIN SEARCH,SETTING REG FOR BCR TOO\n         SPACE 1\n*              SEARCH FOR LITERAL IN CHAIN OF RIGHT LENGTH.           *\nLTE1CLI  CLI   LTLCHARS,$CHN       CHECK 1ST FOR SAME # OF CHARS\n         BNE   LTE1L               IF NOT,LOOP TO NEXT ON CHAIN\nLTE1CLC  CLC   LTLITRAL($CHN),0(RX)          IS LITERAL THE SAME\n         BE    LTE1OLD             BRANCH OUT IF SAME LITERAL\n         SPACE 1\nLTE1L    LR    RD,RE               SAVE @ OLD LTLENTRY\n         L     RE,LTLINK           GET @ NEXT LTLENTRY FROM OLD ONE\n         LA    RE,0(RE)            REMOVE 1ST BYTE\n         LTR   RE,RE               IS THE LINK = 0\n         BCR   NZ,R15              BNZ LTE1CLI - GO BACK FOR NEXT TEST\n         SPACE 1\n*              FALL THRU==> THIS IS A NEW LITERAL-GET SPACE&ENTER IT  *\n         LA    R14,LTL$LEN+4(R1)   GET TOTAL LENGTH,ROUNDED OVER FULL\n         O     R14,AWF3            MAKE LAST 2 BITS 1'S\n         S     R14,AWF3            ALIGN TO FULLWORD AMOINT\n         $ALLOCH RE,R14,LTZOVER    GET SPACE FOR NEW ENTRY\n         STC   R1,*+5              PUT LENGTH-1 INTO MVC\n         MVC   LTLITRAL($CHN),0(RX)          MOVE LITERAL OVER\n         LR    R15,RE              MOVE POINTER OVER\n         AL    R15,0(RD)           ADD LTLCHARS OF PREVIOUS ENTRY\n         ST    R15,0(RD)           STORE LTLCHARS-LTLINKA BACK\n         MVC   LTLTYP(CNC$LEN),CNCBLOCK      MOVE ALL THE CODES OVER\n         DROP  RC                  HAVE GOTTEN CODES,NO MORE USING\n         SLL   R1,24               SHIFT LENGTH-1 FOR POSITION TO STORE\n         ST    R1,LTLINK           STORE LTLCHARS FIELD, WITH 0 LTLINKA\n         $SCPT R15,LTLSCAN         GET SCAN POINTER ADDRESS\n         SR    R15,RX              GET OFFSET FROM = SIGN\n         STC   R15,LTLSCAN         SAVE THIS SCAN POINTER INSTEAD\nLTE1OLD  LR    RC,RE               MOVE @ LITERAL ENTRY FOR RETURN\nLTE1RET  $RETURN RGS=(R14-R6)\n         SPACE 1\n*              INDIVIDUAL ERROR EXITS.                                *\nLTE1ERR3 LA    RB,$ERNODLM         MISSING DELIMITER\n         B     LTE1RET             RETURN\nLTE1ERR4 LA    RB,$ERCNLNG         CONSTANT TOO LONG FOR LITERAL\n         B     LTE1RET             GO RETURN\n         EJECT\n**--> ENTRY: LTDMP1   1   DUMP LITERALS ON FINDING LTORG AND END. . . .\n*.       LTDMP1 IS CALLED BY IBASM1 TO FIND LENGTH OF THE CURRENT     .\n*.       LITERRAL POOL, AND AVANCE THE CURRENT POOL PTR TO THE NEXT 1..\n*.       EXIT CONDITIONS                                              .\n*.  RA = TOTAL LENGTH REQUIRED FOR THE LITERAL BLOCK                  .\n*.       CALLS MOSTOP                                                 .\n*.       USES DSECTS: AVWXTABL,LTBASETB,LTLENTRY                      .\n*.       USES MACROS: $ALIGN,$ALLOCH,$CALL,$GLOC,$RETURN,$SAVE        .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nLTDMP1   $SAVE RGS=(R14-R0),SA=NO\n         SPACE 1\n*              INITIALIZE PROCESSING FOR 1 LITERAL POOL.\n         SR    RA,RA               CLEAR TOTAL LENGTH\n         L     RB,LTBNOW           GET POINTER TO CURRENT LTBASETB\n         USING LTBASETB,RB         TELL ASSEMBLER\n         $GLOC RE                  GET LOCATION COUNTER\n         $ALIGN RE,7,*             ALIGN TO DOUBLEWORD\n         ST    RE,LTBVALUE         SAVE THIS VALUE IN LTBLOCK\n         LA    RC,4                # OF LITERAL CHAINS - LTBCH1-2-4-8\n         LA    RD,LTBCH8           @ FIRST CHAING POINTER TO BE DONE\n         SPACE 1\n*              OUTSIDE LOOP - GET NEXT CHAIN OF LITERALS - 8-4-2-1.\nLTD1L    L     RE,0(RD)            GET NEXT POINTER FORM LTBCH1-2-4-8\n         USING LTLENTRY,RE         NOTE ENTRY POINTER(@ SET LOWER DOWN)\n         A     RD,AWFM4            SUBTRACT 4 TO GET NEXT ONE NEXT TIME\n         BAL   R14,LTD1LTR         GO TEST LINK PTR,ALSO SETING R14\n         SPACE 1\n*              LOOP ALONG LITERAL CHAINS,ADDING LENGTHS,GETTING OFSETS*\nLTD1E    STH   RA,LTLOFSET         SAVE OFFSET OF LITERAL\n         AH    RA,LTLTOT           ADD THE TOTAL LENGTH OF LITERAL IN\n         AIF   (&$DEBUG).LTXS1     SKIP IF PRODUCTION\n         XSNAP STORAGE=(*LTLENTRY,*LTLITRAL),IF=(AVDEBUG,O,X'84',TM)\n.LTXS1   ANOP\n         L     RE,LTLINK           GET @ NEXT LITERAL ON CHAIN\n         LA    RE,0(RE)            REMOVE FIRST BYTE(LTLCHARS)\nLTD1LTR  LTR   RE,RE               IS POINTER 0. IF SO==> LAST ON CHAIN\n         BCR   NZ,R14              BNZ LTD1E - KEEP GOING IF MORE\n         SPACE 1\n         BCT   RC,LTD1L            LOOP TO GET ALL LITERALS - 8-4-2-1\n         DROP  RE                  NO LONGER NEEDED\n         SPACE 1\n         LA    RD,LTB$LEN          GET LENGTH FOR NEXT LTBASETB\n         $ALLOCH RE,RD,LTZOVER     GET THE SPACE\n         ST    RE,LTBLINK          SAVE POINTER TO NEW LTBASETB IN OLD\n         MVC   LTBESDID,AVCESDID   MOVE CURRENT ESDID OVER\n         DROP  RB                  NO MORE REFS TO OLD LTBASETB\n         USING LTBASETB,RE         USING FOR JUST CREATED LTBASETB\n         MVC   LTBASETB(LTB$LEN),AWZEROS     ZERO IT OUT\n         ST    RE,LTBNOW           SAVE NEW POINTER\nLTD1RET  $RETURN RGS=(R14-R0),SA=NO\n         DROP  RE                  NO LONGER USING\n         EJECT\n* * * * * LTZOVER IS ENTERED IF STORAGE OVERFLOW OCCURS, PASS 1       *\nLTZOVER  $GTAD REP,MOSTOP          GET ADDR OF OVERFLOW ERROR EXIT\n         BR    REP                 GO THERE, WILL EVENTAULLY PRINT 999\n         SPACE 1\n**--> ENTRY: LTEND1   1   CLEANUP AFTER PHASE 1 PREPARE FOR PHASE 2 . .\n*.       THIS ENTRY SETS UP FOR ASSEMBLER PASS 2 LITERAL PROCESSING.  .\n*.       USES MACROS: $RETURN,$SAVE                                   .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nLTEND1   $SAVE SA=NO\n         MVC   LTBNOW,LTBFIRST     RESET ORIG POINTER TO CURRENT ONE\n         $RETURN SA=NO\n         SPACE 2\n**--> ENTRY: LTGET2   2   GET ADDRESS OF LITERAL IN ASSEMBLY. . . . . .\n*.       LTGET2 IS CALLED BY ICMOP2 EACH TIME A LITERAL IS FOUND IN   .\n*.       SCANNING MACHINE INST OPERANDS DURING PASS 2. IT RETURNS THE .\n*.       ATTRIBUTES OF THE LITERAL, INCLUDING THE USER PROGRAM @ FOR  .\n*.       THE LITERAL, THE SECTION ID OF THE LITERAL, AND THE LENGTH   .\n*.       ATTRIBUTE OF THE LITERAL. ICMOP2 SUPPLIES A POINTER TO THE   .\n*.       LTLENTRY OF THE LITERAL, WHICH HAD BEEN SAVED IN THE         .\n*.       STATEMENT'S RCODBLK .                                        .\n*.       ENTRY CONDITIONS                                             .\n*.  RA = SCAN POINTER TO 1ST CHAR OF LITERAL =                        .\n*.  RC = @ LITERAL TABLE ENTRY IN LITERAL TABLE(WAS SAVED IN RCB)     .\n*.       EXIT CONDITIONS                                              .\n*.  RA = SCAN POINTER TO CHARACTER AFTER LITERAL                      .\n*.  RB = ESDID OF CSECT IN WHICH LITERAL EXISTS                       .\n*.  RC = ADDRESS OF LITERAL (PROGRAM ADDRESS-FOR LISTING,ETC)         .\n*.  RD = IMPLIED LENGTH-1 OF THE LITERAL(LOW ORDER BYTE, OTHERS INDTR).\n*.       USES DSECTS: AVWXTABL,LTBASETB,LTLENTRY                      .\n*.       USES MACROS: $RETURN,$SAVE                                   .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n         USING LTLENTRY,RC         NOTE USING,ON ENTRANCE\nLTGET2   $SAVE SA=NO\n         L     RE,LTBNOW           GET POINTER TO CURRENT LTBASETB\n         USING LTBASETB,RE         NOTE THE USING HERE\n         SR    RB,RB               CLEAR FOR INSERT OF ESDID\n         IC    RB,LTLCHARS         GET LENGTH-1 OF LITERAL STRING\n         LA    RA,1(RA,RB)         BUMP SCAN POINTER PAST LITERAL\n         IC    RB,LTBESDID         GET THE ESDID OF LITERAL POOL\n         AIF   (&$DEBUG).LTXS2     SKIP IF PRODUCTION\n         XSNAP STORAGE=(*LTLENTRY,*LTLITRAL),IF=(AVDEBUG,O,X'84',TM)\n.LTXS2   ANOP\n         IC    RD,LTLLEN           GET LENGTH-1 BEFORE RC ERASED\n         LH    RC,LTLOFSET         GET OFFSET FROM LITERAL POOL BASE\n         A     RC,LTBVALUE         GET ACTUAL ADDRESS\nLTG2RET $RETURN SA=NO\n         DROP  RC,RE               REMOVE THE USINGS\n         EJECT\n**--> ENTRY: LTDMP2   2   DUMP LITERALS IN PASS 2 . . . . . . . . . . .\n*.       LTDMP2 IS CALLED BY IDASM2 DURING PASS 2, WHENEVER A LTORG   .\n*.       OR END STMT IS FOUND, TO PRODUCE THE OBJECT CODE AND LISTING .\n*.       OF ANY LITERALS IN THE CURRENT LITERAL POOL.  THE CURRENT    .\n*.       POOL BASE POINTER IS ADVANCED TO THE NEXT LTBASETB.          .\n*.       CALLS CNDTL2                                                 .\n*.       USES DSECTS: AVWXTABL,LTBASETB,LTLENTRY                      .\n*.       USES MACROS: $CALL,$GLOC,$RETURN,$SAVE,$SLOC                 .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nLTDMP2   $SAVE RGS=(R14-R6),SA=LTOPSAVE,BR=R13\n         SPACE 1\n* * * * * REGISTER ALLOCATION AND USAGE FOR LTDMP2  * * * * * * * * * *\n*   R1 = @ CURRENT LTBASETB BEING PROCESSED. 1 IS DONE FOR EACH CALL. *\n*   R2 = BYTE REGISTER FOR INSERTIONS.                                *\n*   RW = @ LOOP HEAD FOR 1 LINK OF 1 LITERAL CHAIN.                   *\n*   RX = @ CURRENT LTLENTRY BLOCK BEING PROCESSED.                    *\n*   RY = -4   FOR BXH INDEX AND LIMIT VALUE.                          *\n*   RZ = OFFSET(0-4-8-12) TO LTBCH# POINTER OF LENGTH BEGIN DONE      *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n*              INITIALIZATION - SET UP FAKE RECORD PTRS,ETC.          *\n         LA    RA,LTRCODBL         GET @ FAKE RCODBLK SET UP\n         ST    RA,AVRCBPT          SAVE THIS ADDRESS\n         LA    RA,LTRSBLOC         GET @ FAKE RSBLOCK\n         LA    RB,LTRSCBLK         GET @ FAKE RSCBLOCK\n         STM   RA,RB,AVRSBPT       STORE PTRS IN AVRSBPT-AVRSCPT\n         $GLOC R0                  GET LOCATION COUNTER\n         L     R1,LTBNOW           GET @ NEXT LTBASETB\n         USING LTBASETB,R1         NOTE THE POINTER\n         SR    R2,R2               BYTE REGISTER-CLEAR FOR INSERTS\n         L     RY,AWFM4            GET -4 FOR BXH'ING\n         LA    RZ,LTBCH8-LTBCH1    GET OFFSET FROM LTBCH1-DO LENGTH 8\n         EJECT\n*              PROCESS CHAINS OF LITERALS, IN ORDER OF LENGTH 8-4-2-1.*\n*              LTD2LRX ENTERD 4 TIMES,1 FOR EACH CHAIN OF LITERALS.   *\nLTD2LRX  L     RX,LTBCH1(RZ)       GET NEXT POINTER FROM LTBASETB\n         USING LTLENTRY,RX         NOTE POINTER\n         BAL   RW,LTD2LTR          GO CHECK FOR LITERALS OF THIS LENGTH\n         SPACE 1\n*              FOLLOWING CODE EXECUTED 1 TIME FOR EACH LITERAL IN POOL*\n*              PLACE LITERAL FOR PASS 2 SCAN AND PRINTING.            *\nLTD2LTL  IC    R2,LTLSCAN          GET SCAN POINTER OFFSET FROM = TO CN\n         LA    R2,LTRSBOPR-LTRSBLOC(R2)      GET CORRECT OFFSET\n         STC   R2,LTLSCAN          SAVE WHERE CNDTL2 WILL EXPECT IT\n         IC    R2,LTLCHARS         GET #-1 OF CHARS IN LITERAL\n         MVC   LTRSBLOC(3),LTRSBCO1          GET CODES FOR 1 CARD LITER\n         CLI   LTLCHARS,55         ARE THERETOO MANY CHARS FOR 1 CARD\n         BNH   *+10                SKIP IF ONLY 1 CARD NEEDED\n         MVC   LTRSBLOC(3),LTRSBCO2          GET CODES FOR 2 CARDS\n         SPACE 1\n         STC   R2,*+5              STORE LENGTH-1 INTO MVC\n         MVC   LTRSBOPR($CHN),LTLITRAL       MOVE LITERAL FROM TABLE\n         $SLOC R0                  SET LOCATION COUNTER\n         MVC   LTRCLOC,AVLOCNTR+1  MOVE LOCATION COUNTER INTO FK RCB\n         AH    R0,LTLTOT           ADD TOTAL LENGTH OF LITERAL TO LOC\n         SPACE 1\n         LA    RB,1                SHOW CNDTL2 WE HAVE 1 OPERAND\n         LA    RC,LTLTYP           GET @ CNCBLOCK PART OF LTLENTRY\n         $CALL CNDTL2              HAVE CONSTANT PROCESSED,PRINTED\n         STC   R2,*+5              SAVE LENGTH-1 INTP BLANKING MVC\n         MVC   LTRSBOPR($CHN),AWBLANK+15+RSB$L         BLANK,KEEPING BD\n         L     RX,LTLINK           GET @ NEXT LTLENTRY ON CHAIN\n         LA    RX,0(RX)            REMOVE 1ST BYTE IF ANY\n         SPACE 1\n*              CONTINUE LOOPING UNTIL LAST LITERAL FOUND ON CHAIN.    *\n*              THEN DECREMENT TO NEXT CHAIN BEGINNING AND PROCESS IT. *\nLTD2LTR  LTR   RX,RX               WAS THIS LAST ONE ON CHAIN\n         BCR   NZ,RW               BNZ LTD2LTL - GO BACK FOR NEXT\n         BXH   RZ,RY,LTD2LRX       DONE WITH 1 CHAIN,GO ON TO NEXT\n         SPACE 1\n         MVC   LTBNOW,LTBLINK      MOVE POINTER TO NEXT LTBASETB OVER\nLTD2RET  $RETURN RGS=(R14-R6)      RETURN TO CALLER\n         DROP  R1,RX               KILL USINGS\n         EJECT\n* * * * * INTERNAL CONSTANTS                                          *\nLTEB1248 DC    X'000400080004000C' OFFSETS TO LTBCH1-2-4-8 FOR LENGTHS\nLTRSBCO1 DC    AL1(RSB$LN1,$RCBX,1)          CODES FOR FAKE RSBLOCK-1CD\nLTRSBCO2 DC    AL1(RSB$LN1+56,$RCBX+$RSCX,2) CODES FOR RSBLOCK-2 CARDS\n         SPACE 1\n*              FAKE RSCBLK, USED IF MORE THAN 1 CARD REQUIRED FOR LIT.*\nLTRSCBLK DC    AL1(1+2*RSC$LEN,71) RSCLEN,1ST RSCILEN FOR CONT/SEQ\n         DC    CL9'X'              CONTINUATION FLAG,SEQNO\n         DC    AL1(56)             LENGTH OF 2ND CARD IMAGE\n         DC    CL9' '              SEQNO OF 2ND CARD IMAGE\n         SPACE 1\n* * * * * INTERNAL VARIABLES                                          *\nLTBFIRST DS    A                   @ FIRST LTBASETB IN EXISTENCE\nLTBNOW   DS    A                   @ CURRENT LTBASETB BEING PROCESSED\n         SPACE 1\n*              FAKE RCODBLK-RCLOC WILL BE USED AS LOCATION COUNTER.   *\nLTRCODBL DS    0F                  LINE UP ON RIGHT BOUNDARY\n         DC    X'7'                RCLENG - LENGTH-1 OF BLOCK\nLTRCLOC  DS    AL3                 LOCATION COUNTER WILL BE PLACE HERE\n         DC    F'0'                FILL OUT BLOCK\n         SPACE 1\n*              FAKE RSBLOCK - WILL BE USED TO ASSEMBLE AND PRINT.     *\nLTRSBLOC DS    0D                  LINE UP\n         DS    CL4                 RSBLEN-RSBFLAG,RSBNUM,RSBSCAN BYTES\nLTRSBSOU DC    CL15' '             15 BLANKS IN FRONT OF =\nLTRSBOPR DC    CL56' '             OPERAND FIELD, IF ONLY 1 CARD USED\n         DC    CL56' '             CONTINUATION OF OPERAND FIELD\n         EJECT\n**--> DSECT: LTBASETB   LITERAL POOL BASE TABLE - 1 FOR EACH POOL . . .\n*.       ONE LTBASETB IS CREATED FOR EACH LITERAL POOL, BY LTINT1 OR  .\n*.       LTDMP1.  THE TOTAL # CREATED = # LTORGS + 2, WHICH INCLUDES  .\n*.       1 FOR THE END STMT, AND 1 EXTRA 1 FOR CODE SIMPLIFICATION.   .\n*.       WHEN LTDMP1 IS CALLED, IT FILLS IN THE SECTION ID OF THE     .\n*.       SECTION WHERE THE POOL WILL BE ASSEMBLED, THE BEGINNING @ OF .\n*.       THE POOL, AND THE OFFSET @ VALUES FROM THE BEGINNING @ TO    .\n*.       EACH LITERAL IN THE POOL.  IN ADDITION TO ADDRESS AND SECTION.\n*.       ID, THE LTBASETB ALSO CONTAINS THE LIST HEADS FOR 4 LISTS    .\n*.       OF LITERAL ENTRIES (LTLENTRY BLOCKS). USED ONLY IN LTOPRS.   .\n*.       LOCATION: HIGH END OF DYNAMIC AREA ($ALLOCH MACRO).          .\n*.       NAMES: LTB-----                                              .\n*.  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n         SPACE 1\nLTBASETB DSECT\nLTBLINK  DS    0F                  ADDRESS OF NEXT LTB, =0 IF LAS\nLTBESDID DS    C                   ESDID OF CSECT IN WHICH OCCURS\nLTBLINKA DS    AL3                 ACTUAL LINKA ADDRESS\nLTBVALUE DS    F                   ADDRESS OF LTORG OR END,D BOUNDARY\nLTBCH1   DS    A                   ADDRESS OF 1ST LTENRY FOR LENGTH 1\nLTBCH2   DS    A                   ADDRESS OF 1ST ENTRY FOR LENGTH 2\nLTBCH4   DS    A                   ADDRESS OF 1ST ENTRY FOR LENGTH 4\nLTBCH8   DS    A                   ADDRESS OF 1ST ENTRY FOR LENGTH 8\nLTB$LEN  EQU   *-LTBASETB          LENGTH OF 1 LITERAL BASE TABLE\n         EJECT\n**--> DSECT: LTLENTRY   LITERAL TABLE ENTRY FOR EACH LITERAL. . . . . .\n*.       1 LTLENTRY BLOCK IS CREATED BY LTENT1 FOR EACH UNIQUE        .\n*.       LITERAL IN A GIVEN LITERAL POOL.  THE LTLENTRY BLOCKS ARE    .\n*.       ORGANIZED IN 4 LINKED LISTS, WITH LIST HEADS IN THE CURRENT  .\n*.       LTBASETB BLOCK.  EACH LTLENTRY INCLUDES THE OFFSET FROM THE  .\n*.       BEGINNING OF THE CURRENT LITERAL POOL @ (ENTERED BY LTDMP1), .\n*.       A COMPLETE CNCBLOCK DESCRIBING THE LITERAL CONSTANT, AND THE .\n*.       CONSTANT IN CHARACTER FORM.  LTGET2 USES THESE BLOCKS TO     .\n*.       DETERMINE THE USER PROGRAM ADDRESS FOR ANY DESIRED LITERAL,  .\n*.       AND LTDMP2 USES THEM TO PRINT LITERAL POOL LISTING AND       .\n*.       HAVE THE CODE ASSEMBLED FOR THE POOL.   USED ONLY IN LTOPRS. .\n*.       LOCATION: HIGH END OF DYNAMIC AREA ($ALLOCH MACRO).          .\n*.       NAMES: LTL-----                                              .\n*.  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n         SPACE 1\nLTLENTRY DSECT\nLTLINK   DS    0F                  ADDRESS OF NEXT ENTRY ON CHAIN\nLTLCHARS DS    C                   #-1 OF CHARACTERS IN LITERAL\nLTLINKA  DS    AL3                 ACTUAL POINTER TO NEXT LTLENTRY\nLTLOFSET DS    H                   OFFSET OF THIS LITERAL FROM BASE\n         SPACE 1\n*              FOLLOWING SECTION (INCLD LTLTOT) = 1 CNCBLOCK DSECT.\nLTLTYP   DS    C                   CONSTANT TYPE+ FLAGS\nLTLLEN   DS    C                   LENGTH-1 OF OPERAND\nLTLSCAN  DS    C                   SCAN POINTER TO 1ST CONSTANT\nLTLNUM   DS    C                   NUMBER OF CONSTANTS IN OPERAND\nLTLDUP   DS    H                   DUPLICATION FACTOR\nLTLTOT   DS    H                   TOTAL LENGTH OF OPERAND\nLTL$LEN  EQU   *-LTLENTRY          LENGTH OF CONSTANT SECTION\nLTLITRAL DS    C                   LITERAL, LENGTH ROUNDED UP TO F\n         DROP  RAT,R13             KILL USINGS\n         TITLE '*** MOCON1 - MAIN CONTROL - ASSEMBLER PASS ONE ***'\n**--> CSECT: MOCON1   1   MAIN CONTROL - ASSEMBLER PASS 1 . . . . . . .\n*.       MOCON1 PROVIDES OVERALL CONTROL FOR PASS 1 OF THE ASSIST     .\n*.       ASSEMBLER, AND SUPERVISES OR PERFORMS THE FOLLOWING:         .\n*.        1. READING INPUT CARDS, CREATING RECORD BLOCKS (INCARD).    .\n*.        2. SCANNING LABELS, ENTERING THEM IN SYMBOL TABLE(SYENT1).  .\n*.        3. SCANNING CARD FOR THE OPCODE, IF ANY.                    .\n*.        4. FINDING OPCODE IN OPCODE TABLE (OPFIND).                 .\n*.        5. SCANNING FOR OPERAND FIELD, SAVING SCAN POINTER.         .\n*.        6. 2ND LEVEL INSTRUCTION PROCESSING (IAMOP1,IBASM1).        .\n*.        7. DEFINING ATTRIBUTES, VALUE OF LABEL, IF REQUIRED.        .\n*.        8. UPDATING LOCATION COUNTER TO NEXT LOCATION.              .\n*.        9. STORING RECORD BLOCKS FOR STMT (UTPUT1).                 .\n*.                                                                    .\n*.       NOTE: PRINT CONTROL/COMMENTS STMTS ARE PROCESSED COMPLETELY  .\n*.       DURING PASS 1 AND NOT SAVED, IF POSSIBLE.                    .\n*.                                                                    .\n*.       CALLS ERRLAB,ERRTAG,IAMOP1,IBASM1,INCARD,OPFIND,SYENT1,UTPUT1.\n*.       CALLS OUTPT2                                                 .\n*.       USES DSECTS: AVWXTABL,OPCODTB,RCODBLK,RSBLOCK                .\n*.       USES MACROS: $CALL,$GLOC,$GTAD,$PRNT,$RETURN,$SAVE           .\n*.       USES MACROS: $SCOF,$SDEF,$SLOC                               .\n*.       CALLS ERRLAB,ERRTAG,IAMOP1,IBASM1,INCARD,OPFIND,SYENT1       .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n         SPACE 1\nMOCON1   CSECT\n         $DBG  90,*\n         ENTRY MOSTOP              NOTE DISASTER ENTRY POINT\n* * * * * REGISTER USAGE IN MOCON1  * * * * * * * * * * * * * * * * * *\n*   R0   CURRENTLY UNUSED.                                            *\n*   R2 = BYTE REGISTER, USED FOR INSERTIONS                           *\n*   RW = ADDRESS OF RSBLOCK(NORMALLY IN AVWXTABL)                     *\n*   RX = ADDRESS OF SYMBOL TABLE ENTRY,IF ANY,SAME AS AVLABPT.        *\n*   R5 = 1, USED FOR BXH'S,ETC.                                       *\n*   RA = SCAN POINTER ADDRESS REGISTER                                *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n         USING AVWXTABL,RAT        NOTE MAIN TABLE USING\n         $SAVE RGS=(R14-R6),BR=R13,SA=MOCOSAVE\n         LA    R2,AVREBLK          RECORD ERROR BLOCK\n         LA    RW,AVRSBLOC         RECORD SOURCE BLOCK\n         USING RSBLOCK,RW          RECORD SOURCE BLOCK\n         LA    RX,AVRSCBLK         RECORD SOURCE CODE BLOCK\n         STM   R2,RX,AVREBPT       SORE THE ADDRESSES IN TABLE\n         SR    R1,R1               CLEAR,SO TRT'S WILL WORK\n         LR    R2,R1               CLEAR THIS FOR INSERTS\n         LA    R5,1                INIT FOR BXH'S,ETC\n         MVI   MOBACK+1,X'F0'      MAKE THE BC A BRANCH,UNTIL END FOUND\n         AIF   (NOT &$MACSLB).MONOMC1\n         XCALL XXXXLBED         MAKE SURE XXXXSORC SWITCH SET NORMALLY\n.MONOMC1 ANOP\n         EJECT\n*              MAIN LOOP - PASS 1. THRU MOSTINIT 1 TIME FOR EACH STMT.*\nMOSTINIT EQU   *                   LOOP HEAD FOR ALL STATEMENTS\n         SPACE 1\n*              IF TIME/RECORDS EXCEEDED, HALT PROCESSING NOW.\n         TM    AVTAGS2,AJOASTOP    WAS STOP BIT SET BY TIMER EXIT\n         BO    MORET               YES, QUIT\n         SPACE 1\n         $CALL INCARD              GET NEXT SOURCE CARD\n         LTR   RB,RB               DID INCARD FIND AN ERROR\n         BZ    MOSTINIV            NO, SO DON'T FLAG IT\n         $CALL ERRTAG              FLAG ERROR FOUND BY INCARD\n         SPACE 1\nMOSTINIV EQU   *\n         AIF   (NOT &$MACROS).MONMC1   SKIP IF NO MACROS\n         TM    RSBFLAG,$RSBNPNN+$RSBNP##    DOES STMT NEED NO PROCESS\n         BNZ   MOUTOUCK            NO PROC - SKIP TO SAVE OR PRINT NOW\n.MONMC1  ANOP\n         SR    RX,RX               CLEAR TO SHOW NO LABEL YET ENCOUNTER\n         LA    RA,RSBSOURC         SET UP ADDRESS FOR START SCAN\n         SPACE 1\n*              CHECK FOR COMMENT OR LACK OF LABEL ON STMT.\n         CLI   RSBSOURC,C' '       IS THIS NORMAL SOURCE,NO LABEL\n         BE    MONOLB              YES,BRANCH TO HANDLE IT\n         CLI   RSBSOURC,C'*'       IS IT  A COMMENT\n         BE    MOCMSYSC            SKIP TO CHK *SYSLIB POSSIBILITY\n         SPACE 1\n*              STATEMENT HAS A LABEL IF FALLS THRU HERE.              *\n         CLI   RSBSOURC,C'0'       MAKE SURE BEGINNING OF SYMBOL<C'0'\n         BNL   MOLABR1             NO IT ISN'T,STARTS WITH #==>ILLEGAL\n         TRT   RSBSOURC(9),AWTSYMT           SCAN A SYMBOL\n         BZ    MOLABR1             SYMBOL 9+ CHARACTERS LONG-ERROR\n         CLI   0(R1),C' '          IS DELIMITER BLANK LIKE SUPPOSED TO\n         BNE   MOLABR2             NO IT ISNT==> ERROR-BRANCH\n         SPACE 1\n*              LEGAL LABEL FOUND. ENTER IN SYMBOL TABLE. CHECK FOR\n*              MULTIPLE DEFINITION, FLAG STMT IF SO.\n         LR    RB,R1               MOVE POINTER TO BLANK OVER\n         SR    RB,RA               GET LENGTH OF SYMBOL\n         $CALL SYENT1              HAVE SYMBOL ENTERED OR LOOKED UP\n         LR    RX,RA               MOVE POINTER TO SYMBOL BACK OVER\n         USING SYMSECT,RX          NOTE SYMBOL TABLE USING\n         TM    SYFLAGS,$SYDEF      WAS SYMBOL ALREADY DEFINED\n         BZ    MOLABGO             NO IT WASNHT-OK\nMOLABMUL EQU   *                   ENTER HERE IF MULTIPLE DEFINED LABEL\n         LA    RB,$ERMULDF         MULTUPLY-DEFINED SYMBOL\n         $CALL ERRLAB              LABEL ERROR\nMOLABGO  LR    RA,R1               MOVE POINTER TO BLANK AFTER LABEL\n         BXH   RA,R5,MOOPC         BUMP SCAN POINTER 1 AND BRANCH\n         SPACE 1\n*              THE FOLLOWING IS ENTERED IF THERE WAS NO LABEL         *\nMONOLB   CLC   RSBSOURC+1(8),AWBLANK         HOPE THAT THESE COLS BLANK\n         BNE   MOOPC               NO THEY WERE'T,SKIP AND DO GENERALLY\n         LA    RA,RSBSOURC+9       HAPPINESS-1ST 9 COLS BLANK\nMOOPC    ST    RX,AVLABPT          SAVE POINTER(IF LABEL) OR 0(IF NOT)\n         EJECT\n*              SCAN LOOP TO FIND OPCODE                               *\nMOOPCA   CLI   0(RA),C' '          IS THIS ANOTHER BLANK\n         BNE   MOOPCB              NO IT ISNT BLANK-BRANCH OUT\n         BXH   RA,R5,MOOPCA        BUMP SCAN POINTER AND CONTINUE\n         SPACE 1\n*              OPCODE IS FOUND-RA POINTS THERE. IF OMITTED,RA==> '    *\nMOOPCB   C     RA,AVSOLAST         COMPAE TO @ BLANK BEFORE ' AFTER\n         BNL   MOOPNONE            BRANCH OUT - - MISSING OPCODE\n         $CALL OPFIND              LOOK UP TYPE OF OPCODE\n         LTR   RB,RB               WAS IT LEGAL\n         BNZ   MOMACHK             GO TO ERROR OR MACRO CHECK\n         USING OPCODTB,RC          NOTE OPCODE TABLE POINTER\n         AR    RA,R5               INCREMENT SCAN POINTER BY 1\n         LR    RE,RA               SAVE SCAN POINTER FOR LATER\n         SPACE 1\n*              SEARCH FOR OPERAND FIELD.                              *\nMOOPRA   CLI   0(RA),C' '          IS THIS STILL BLANK FIELD\n         BNE   MOOPRB              NO-BRANCH OUT-WE HAVE OPERAND FIELD\n         BXH   RA,R5,MOOPRA        BUMP SCAN POINT AND CONTINUE\n         SPACE 1\n*              FOUND FIRST NONBLANK CHAR IN OPERAND FIELD. TEST FOR\n*              OMITTED OPERAND, EITHER COMPLETELY OR SHOWN BY ,.\nMOOPRB   CLC   0(2,RA),=C', '      DOES HE SHOW OMITTED OPERAND\n         BNE   MOOPRB2             NO,SO SKIP TO CHK FOR TOTAL OMIT\n         BXH   RA,R5,MOOPRC        BUMP SCAN PTR TO SHOW BLANK,FAKE OMI\n         SPACE 1\nMOOPRB2  C     RA,AVSOLAST         CHK WITH @ BLANK BEFORE AFTERQUOTE\n         BL    MOOPRC              OPERAND EXISTS, BRANCH\n         LR    RA,RE               OMITTED,SO REPLACE ADDR OF 1ST BLNK\nMOOPRC   $SCOF RE,RA,RSBSCAN       PLACE SCAN POINTER\n         SPACE 1\n*              MAKE TYPE TEST TO DETERMINE WHICH 2ND LEVEL PROCESSOR.\n         TM    OPCTYPE,$IB         MAKE TEST FOR TUPE OF OPCODE\n         BZ    MOCALLIA            BRANCH TO CALL MACHINE INSTRUCTIONS\n         BO    MOCALLIB            CALL ASSEMBLER INSTS\n         AIF   (NOT &$SPECIO).MONS SKIP IF NO SPECIALS\n         AIF   (NOT &$MACROS).MOSPNM        SKIP IF SPECIALS,NO MACROS\n         TM    OPCTYPE,$IS         WAS INSTRUCTION A SPECIAL\n         BZ    MOCALLMA            BRANCH TO CALL MACRO1\n.MOSPNM  IC    R2,OPCTYPE          GET TYPE OF OPCODE\n         SLL   R2,2                MULT BY 4 FOR ADDRESS\n         $GTAD REP,SPECAD-4*$IS(R2)         GET RIGHT ADDRESS\n         B     MOCALLXX            GO TO CALL SECTION\n.MONS    AIF   (NOT &$MACROS).MONSM         SKIP IF NO MACROS\nMOCALLMA TM    AVTAGSM,AJOMACRO    ARE WE IN MACRO MODE\n         BZ    MOOPNONE            NO, FALG AS UNDERINFED OPCODE\nMOCALLMC EQU   *                   ENTRY FROM OPEN CODE CHECK         J\n         $CALL MACRO1              CALL THE MACRO DEFINITOON PROCESSOR\n         B     *+4(RB)             TAKE INDEXED BRANCH ACCORDINGLY\n         B     MOSTINIT            NORMAL RETURN - GO BACK FOR NEXT CRD\n         B     MOSTINIV            NO, PROB AIF-AGO - CARD ALREADY EXIS\n         B     MOPUT               ERROR ALREADY FLAGGED, GO TO SAVE\n.MONSM   ANOP\n         SPACE 1\nMOCMSYSC EQU   *                   COME HWERE FOR ALL COMMENT CARDS\n         AIF   (NOT &$MACSLB).MONSYS1       SKIP IF NO MACRO LIBRARY\n         CLC   RSBSOURC+1(6),=C'SYSLIB'     WAS THIS *SYSLIB CARD\n         BE    MOCOMSYS            GO TO CHECK AND PROCESS IT\n.MONSYS1 ANOP\n         AIF   (NOT &$XREF).NOXRF12                                   A\n*  CHECK FOR *XREF CARD                                               A\n         CLC   RSBSOURC+1(4),=C'XREF'  IS IT XERF                     A\n         BNE   MOUTOUCK            NO GO ON                           A\n         LA    RA,RSBSOURC+5       FOR ENTRY TO XRSCAN (@ TO BEGIN)   L\n         SR    RD,RD               CLEAR FOR PROPER ENTRY CONT        L\n         $CALL XRSCAN              CALL SCANNING ROUTINE              A\n.NOXRF12 ANOP                                                         A\n         SPACE 1\n*              BRANCH HERE TO DETERMINE WTHER STMT SHOULD BE SAVED VIA\n*              UTPUT1, OR PRINTED IMMEDIATELY AS A COMMENT TYPE.\nMOUTOUCK TM    AVPRINT1,AVPRSAVE   MUST WE SAVE THE CARD\n         BO    MOPUT               YES, SO GO DO IT\nMOOUCOMM LA    RB,$OUCOMM          SHOW COMMENT TYPE ( NO LC CTR)\n         B     MOIBOUTA            GO TO PUT IT OUT TO LISTING\n*              ASSEMBLER INSTRUCTIONS                                 *\nMOCALLIB EQU   *                   PROCESSING FOR ASSEMBLER OPS FOLLOWS\n         AIF   (NOT &$MACOPC).MOIBA      SKIP ID NO OPEN CODE         J\n         BAL   R14,MOOPAMPC        GO CHECK FOR SUBSTITUTE OF EVAR    J\n.MOIBA   ANOP                                                         J\n         $CALL IBASM1              CALL ASSEMBLER OPS PROCESSOR\n         USING RCODBLK,RC          IBASM1 RETURNED PTR TO BLK IN RC\n         L     RX,AVLABPT          RELOAD PTR: IF EQU, MAY NOW BE = 0\n         TM    RCHEX,IBMOSPEC+IBMOPRCT WAS SPECIAL OF ANY KIND\n         BZ    MOCALLXX            NO, SO SKIP TO COMPLETE PROCESSING\n*              FALL THRU ==> SOME SPECIAL KIND OF HANDLING NEEDED.\n         BM    MOCASEND            AT PRSENT, THIS COND ==> END CARD-B\n         SPACE 2\n*              SPECIAL HANDLING: BYPASS PASS 2 PROCESSING.            *\n*        DURING PASS 1, IT IS POSSIBLE TO PROCESS A STMT COMPLETELY,  *\n*   INCLUDING PRINTING IT, UNTIL ANY STMT EXCEPT ONE OF THE FOLLOWING *\n*   IS FOUND IN THE INPUT STREAM:                                     *\n*   COMMENT CARD, PRINT, SPACE, EJECT, TITLE.                         *\n*   MACRO DEFINITIONS, GBL OR LCL IN OPEN CODE.                       *\n*        THESE STMTS CAN BE COMPLETELY PROCESSED, THUS SAVING SPACE   *\n*   AND TIME.   THE SECTIONS OF CODE BELOW HANDLE THIS.               *\n         SPACE 1\n         TM    AVPRINT1,AVPRSAVE   MUST WE SAVE RATHER THAN FINISH\n         BO    MOCALLXY            YES, BRANCH, MUST SAVE IT\n         SPACE 1\n*              PROCESS PRINT CONTROL STMTS: SEE CORRESPOND IDASM2 CODE.\n*              NOTE: SOME ERROS IN PRINT WILL CAUSE PRINT ON,NOGEN.\n         CLI   RCTYPE,$IB+$ITITLE  IS THIS ACTUALLY TITLE STMT\n         BNE   MOIBPR1             NO, BRANCH FOR NEXT CHECK\n         SR    RB,RB               YES, WAS TITLE; CLEAR FOR INSERT CP\n         IC    RB,RCMASK           GET LENGTH-1 OF TITLE        CPP\n         $SCPT RA,RSBSCAN          GET SCAN POINTER BACK       CPP\n         AR    RA,R5               (R5=1) RA=>1ST BYTE TITLE   CPP\n         $CALL CCCON2              ASSEMBLE AS IF C-TYPE CONST. CPP\n*              RETURNS: RC=> ASSEMBLED TITLE, RD=LEN-1 OF TITLE CPP\n         LA    RE,4                SHOW THIS WAS A TITLE        CPP\n         B     MOIBOUTL            BRANCH TO PRINT OR STORE TITLE CPP\n         SPACE 1\nMOIBPR1  CLI   RCTYPE,$IB+$IPRINT  WAS IT ACTUALLY PRINT STMT\n         LA    RC,RCMASK           @ CONTROL BYTE(PRINT,SPACE,EJECT)\n         LA    RE,2                SHOW THIS WAS A PRINT STMT.  CPP\n         BE    MOIBOUTL            WAS PRINT; ALL REGS SET, PRINT CPP\n         SR    RE,RE               FALL THRU==> SPACE OR EJCT, RESET =0\nMOIBOUTL LA    RB,$OULIST          SHOW THIS WAS A LISTING CTRL CPP\n         SPACE 1\n*              IMMEDIATE PRINT CONTROL: CALL PRINT ROUTINE.\nMOIBOUTA $CALL OUTPT2              REGS RB,RC,RD,RE ALREADY SET UP\n         B     MOSTINIT            GO BACK, PICK UP NEXT STMT\n         SPACE 1\nMOCASEND EQU   *                   COME HERE FOR END CARD\n         MVI   MOBACK+1,0          MAKE BRANCH A NOOP SO WE FALL THROUG\n         B     MOCALLXX            GO CALL ROUTINE\n         DROP  RC                  NOTE NO LONGER USING RC BLOCK\n         SPACE 1\n*              MACHINE OPCODES                                        *\nMOCALLIA EQU   *                   COME HERE FOR MACHINE OPS          J\n         AIF   (NOT &$MACOPC).MOIAA                                   J\n         BAL   R14,MOOPAMPC        GO CHECK FOR SUBSTITUTEION OF &VAR J\n.MOIAA   ANOP                                                         J\n         $CALL IAMOP1              CALL MACHINE OP PROCESSOR          J\n         EJECT\n*              CALL THE 2ND LEVEL PROCESSOR ROUTINE REQUIRED.         *\nMOCALLXX EQU   *\nMOCALLXY EQU   *                   SKIP HERE IF AVPRINT1 SET ALREADY\n         USING RCODBLK,RC          RC--> RCB OF 2ND LEVEL ROUTINE\n         SPACE 1\n*              FINISH CREATION OF RCODBLK,ADDING LOC.COUNTER VALUE.\n         OI    RSBFLAG,$RCBX       NOTE THAT AN RCB EXISTS NOW\n         $GLOC RE                  GET LOCATION COUNTER\n         MVC   RCLOC,AVLOCNTR+1    MOVE THE LOCATION COUNTER IN\n         SPACE 1\n*              DEFINE STMT LABEL, IF ANY, IF NOT ALREADY DEFINED.\n         LTR   RX,RX               IS THERE A LABEL ON STATMENT\n         BZ    MONOLB2             NO,SKIP DEFINING IT\n         TM    SYFLAGS,$SYDEF      HAS THIS BEEN DEFINED YET\n         BO    MONOLB2             YES,DON'T REDEFINE IF ALREADY\n         IC    R14,AVCESDID        GET ESDID\n         IC    RB,RCLQ             GET LENGTH ATTRIBUTE\n         $SDEF RE,R14,RB           DEFINE THE SYMBOL\n         SPACE 1\n*              INCREMENT LOCATION COUNTER BY LENGTH OF THIS STMT.\nMONOLB2  AR    RE,RD               ADD INCREMENT TO LOCATION COUNTER\n         $SLOC RE\n         ST    RC,AVRCBPT          SAVE ADDR OF RCB\n         AIF   (&$DEBUG).MONOXS    SKIP IF PRODUCION\n         XSNAP STORAGE=(*0(RC),*12(RC),*AVLOCNTR,*AVDWORK1-1),T=NO,    #\n               IF=(AVDEBUG,O,X'88',TM)\n.MONOXS  ANOP\n         SPACE 1\nMOPUT    $CALL UTPUT1              OUTPUT THE EXPANDED RECORDS\nMOBACK   BC    $CHN,MOSTINIT       B MOSTINIT UNTIL END-BECOMES NOOP\n         SPACE 1\nMORET    $RETURN RGS=(R14-R6)\n         EJECT\n**--> ENTRY: MOSTOP     CALLED IF DISASTROUS ERROR OCCURS IN PASS 1 . .\n*.       RESTORES CONDITIONS FOR MOCON1, NOTE OVERFLOW OCCURRENCE.    .\n*.  ENDS EXECUTION FOR PASS 1, FLAGGING PROGRAM NONEXECUTABLE.        .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n         USING MOSTOP,REP          NOTE TEMPORARY USING\nMOSTOP   L     R13,=A(MOCOSAVE)    GET @ SAVE AREA,BAS REG\n         DROP  REP                 KILL TEMPORARY USING,BACK TO NORMAL\n         OI    AVTAGS3,AVOVERFL    SHOW OVERFLOW OCCURRED.\n         B     MORET               RETURN TO MAIN CONTROL\n         AIF   (NOT &$MACOPC).MOAMP1                                  J\n         SPACE 1                                                      J\n**--> INSUB: MOOPAMPC CHECK STATEMENT FOR SET VARIABLE SUBSTITUTION  *J\n*+       ENTRY CONDITIONS:                                           +J\n*+  RA= @ OPERAND FIELD / UNCHENGED ON EXP                           +J\n*+  R14 = RETURN ADDRESS                                             +J\n*+       EXIT CONDITIONS                                             +J\n*+  RETURN IF NO POSSIBLE SUBSTITUTION                               +J\n*+  -->MOCALLMC IF SUBSTITUTION POSSIBLE                             +J\n*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +J\nMOOPAMPC TM    AVMTAG00,AVMOPENC   HAVE SET VARS FOUND ALRESDY        J\n         BCR   Z,RET               NO, NO SUBSTITUTION POSSIBLE       J\n         TM    RSBFLAG,$RSBGENR    GENERATE STATMENT                  J\n         BCR   O,RET               YES, CAN'T SUBSTITUTE AGAIN        J\n         IC    R2,RSBLENG          GET LENGTH-1 OF WHOLE STMT         J\n         SH    R2,=AL2(RSB$L)      GET LENGTH-1 OF STMT               J\n         STC   R2,MOOPAMPT+1       PUT L-1 INTO TRT                   J\n         $SETRT ('&&',4)           FLAG TO STOP ONE                   J\nMOOPAMPT TRT   RSBSOURC($),AWTZTAB SCAN FOR &                         J\n         $SETRT ('&&',0)           REZERO                             J\n         BCR   Z,RET               NO SUBSTITUTION-RET                J\n         LA    RC,AWZEROS          SHOW @ ZEROS: MACRO WANTS THIS     J\n         B     MOCALLMC            GO TO CALL MACRO1 TO SCAN          J 1665432-\n.MOAMP1  ANOP                                                         J\n         SPACE 1\n* * * * * OUT-OF-LINE ERROR PROCESSING SECTIONS * * * * * * * * * * * *\n         SPACE 2\n*              ERROR IN LABEL - FLAG, MOVE SCAN PTR TO 1ST BLANK.\n         SPACE 1\nMOLABR2  EQU   *\n         AIF   (NOT &$MACOPC).MOLABR                                  J\n*              IF MACROS MAY BE PRESENT, CHECK FOR SEQUENCE SYMBOL.\n         TM    AVTAGSM,AJOMACRO    ARE WE IN MACRO RUN                A\n         BZ    MOLABR2B            NO, SO ERROR FOR SURE\n         TRT   RSBSOURC+1(8),AWTSYMT        SCAN SYMBOL\n         BZ    MOLABR1             TOO LONG, ERROR\n         CLI   0(R1),C' '          TERMINATE PROPERLY\n         BNE   MOLABR2B            NO ERROR FLAG IT                   J\n         TM    RSBFLAG,$RSBGENR    WAS IT GENERATED                   J\n         BO    MOLABGO             YES,SO IGNOR LABEL                 J\n         CLI   0(RA),C'&&'         SET VARIABLE                       J\n         BE    MOLABGO             YES,CONTINUE                       J\n         CLI   0(RA),C'.'          SEQUENCE SYMBOL?                   A\n         BNE   MOLABR2B            NO ERROR                           J\n         CLI   1(RA),C'0'          CHECK FOR LEGALITY                 J\n         BNL   MOLABR2B            BAD-1ST CHAR IS DIGIT              J\n* LEGAL SET SYMBOL-PLACE IT IN SYMBOL TABLE                           J\n         LR    RB,R1               @ TERMINATOR BLANK                 J\n         SR    RB,RA               GET LENGTH                         J\n         $CALL SYENT1              HAVE SYMBOL LOOKED UP              J\n         USING SYMSECT,RA          NOT PTR                            J\n         TM    SYFLAGS,$SYDEF      YES ERROR                          J\n         BO    MOLABMUL            YES ERROR                          J\n         OI    SYFLAGS,$SYDEF      SHOW DEFINED NOW                   J\n         B     MOLABGO             CONTINUE AS USUAL                  J\n         DROP  RA                  ZAP USING                          J\n         SPACE 1\n*              DEFINITE ILLEGAL LABEL FIELD.\n.MOLABR  ANOP\nMOLABR2B LR    RA,R1               INVALID CHARACTER, SHOW SCAN PTR\nMOLABR1  LA    RB,$ERINVSY         INVALID SYMBOL\n         $CALL ERRTAG              FALG IT\nMOLABLP  CLI   0(RA),C' '          SEARCH FOR BLANK\n         BE    MOOPC               FOUND BLANK AFTER SYMBOL-BRANCH\n         BXH   RA,R5,MOLABLP       BUMP SCAN POINTER AND CONTINUE\n         SPACE 1\n*              MISSING OPERATION CODE ERROR.\nMOOPNONE LA    RA,RSBSOURC+9       POINT WHERE OPCODE SHOULD BE\n         LA    RB,$ERIVOPC         OMITTED OPCODE\n         B     MOERRORA            GO HAVE IT FLAGGED\n         SPACE 1\nMOMACHK  EQU   *                   DEFINE LABEL, EITHER MACRO CHECK, ER\n         AIF   (NOT &$MACROS).MONMAC        SKIP IF NO MACROS\n*              THIS CODE ENTERED IF UNRECOGNIZED OPCODE.  AT THIS PT,\n*              RB = $ERIVOPC, SET BY OPFIND.  MAKE SURE STMT WAS NOT\n*              ALREADY A GENERATED ONE.  CALL MEXPND TO SEE IF MACRO.\n         TM    AVTAGSM,AJOMACRO    ARE WE IN MACRO MODE\n         BZ    MOERRORA            NO, FLAG AS UNDEFINED OPCODE\n         BAL   R14,MOOPAMPC        CHECK FOR SUBSTITUTION OF &VAR     S\n         $CALL MEXPND              CALL TO EXPAND MACROS\n*********CODE MAY BE REQUIRED TO SHOW WE ARE IN EXPANSION MODE        *\n         LTR   RB,RB               WAS THE MACRO KNOWN\n         BZ    MOSTINIT            OK,BRANCH IF OS\n.MONMAC  ANOP\n         SPACE 1\n*              GENERAL 1-STMT UNRECOVERABLE ERROR SECTION.\nMOERRORA $CALL ERRTAG              HAVE ERROR FLAGGED\n         B     MOUTOUCK            GO TO CHK PRINT/SAVE OPTION\n         SPACE 1\n         EJECT\n         AIF   (NOT &$MACSLB).MONOMC2\n* . . . .   MOCOMSYS  SECTION . . . . . . . . . . . . . . . . . . . . .\n*                                                                     .\n*        THIS SECTION OF MOCON1 IS CALLED WHENEVER A '*SYSLIB CARD    .\n*        HAS BEEN FOUND.  IT COORDINATES THE ACTIVITIES OF MACRO      .\n*        LIBRARY PROCESSING AND THE MACRO PROCESSOR                   .\n*                                                                     .\n*        ENTRY CONDITIONS:                                            .\n*              REGISTER RA --> SCAN POINTER TO SYSLIB CARD            .\n*                                                                     .\n*        EXIT CONDITIONS:                                             .\n*              REGISTERS UNCHANGED                                    .\n*                                                                     .\n*        USES MACROS:                                                 .\n*              $CALL, $ALLOCL                                         .\n* . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n         SPACE 2\nMOCOMSYS STM   RA,RE,MOCOMSVE      SAVE CONDITION OF WORK REGISTERS\n         MVC   MOCPRTSV,AVPRINT    SAVE CURRENT PRINT STATUS\n         TM    AVTAGSM,AJOMACRO    RETURN IF MACRO DISENABLED\n         BZ    MOUTOUCK            NOT MACRO MODE GO TO PRINT CARD\n         TM    AVPRINT1,AVPRSAVE   IS SYSLIB CARD IN LEGAL POSITION\n         BO    MOCLBER1            IN ERROR--GO THERE TO FINISH\n         AIF   (NOT &$MACOPC).MOMXX1         SKIP IF NO OPEN CODE\n         TM    AVMTAG00,AVMOPENC   HAVE GBLX, LCLX BEEN FOUND\n         BO    MOCLBER1            YES, ERROR - FLAG IT\n.MOMXX1  ANOP\n         LA    RA,7(RA)            SYSLIB LEGAL-INCREMENT POINTER PAST\n*                                  SYSLIB TO THE FOLLOWING BLANK\n         SPACE 1\n*        SCAN AND SKIP BLANKS TILL FIRXT SYMBOL OF NAME FOUND\nMOCBLNK  CLI   0(RA),C' '          IS THIS A BLANK\n         BNE   MOCLBSC             NO BRANCH OUT TO CONTINUE\n         BXH   RA,R5,MOCBLNK       BUMP SCAN POINTER AND CONTINUE\n         SPACE 1\nMOCBUMP  LA    RA,1(R1)            KICK PAST A LEGAL DELIMITER\nMOCLBSC  LR    R1,RA               MOVE POINTER OVER FOR ERROR FLUSH\n         C     RA,AVSOLAST         IS SYSLIB CARD BLANK\n         BNL   MOCNLSYS            YES--> SO SKIP NAME SCAN CODE\n         CLI   0(RA),C'0'          DOES NAME START WITH LEGAL CHARACTE\n         BNL   MOCLBER2            NOT LEGAL STARTING CHARACTER\n         TRT   0(9,RA),AWTSYMT     SCAN THE NAME\n         BZ    MOCLBER2            NAME TOO LONG--ERROR\n         LR    RB,R1               MOVE BLANK POINTER OVER\n         SR    RB,RA               GET LENGTH OF NAME\n         SR    RB,R5               DECREMENT FOR LENGTH-1 OF NAME\n         MVC   AVMSYMBL,AWBLANK    BLANK OUT SEARCH AREA\n         EX    RB,MOCMVEL          MOVE NAME INTO SEARCH AREA\n         L     RC,AVMACLIB         SET UP TO SEARCH LIST WITH MACFND\n         BAL   RD,MOCLOOK          SEARCH LIST FOR NEW NAME\n         LTR   RB,RB               SET CC ON RETURNED MAGNITUDE OF RB\n         BNZ   MOCNMADD            NOT FOUND- PUT NAME IN THE LIST\nMOCNAMNT CLI   0(R1),C','          IF LEGAL NAME DELIMITER LOOP FOR ALL\n*                                  NAMES\n         BE    MOCBUMP             LOOP FOR ALL NAMES\n         CLI   0(R1),C' '          IS SCAN CHARACTER A BLANK\n         BNE   MOCLBER3            NOT BLANK OR COMMA--ERROR INVALID\n*                                  DELIMITER\nMOCNLSYS LA    RB,$OUCOMM          SET TO PRINT A COMMNNT\n         $CALL OUTPT2              PRINT STATEMENT AND ANY ERRORS\n         L     RC,AVMACLIB         GET BEGIN ADDRESS OF MACRO LIST    M\n         USING MACLIB,RC           NOTE USING ON MACRO LIST DSECT     M\n         SR    RB,RB               ZERO FOR SEARCH END LIST           M\n         CL    RB,MCLIBNXT         IF LIST HEADER IS NULL             M\n         BE    MOCLBOUT            THEN NO OPEN - JUST QUIT           M\n         DROP  RC                  CLEAR USING                        M\n         XCALL XXXXLBOP            CALL TO OPEN LIBRARY DCB           M\n         BM    MOCLBER4            NO--SET UP ERROR\n         SPACE 2\n         TM    AVTAGSM,AJOLIBMC    SHOULD WE PRINT MACRO DEFINITIONS\n         BO    *+8                 NO -- PROCESS NORMALLY\n         NI    AVPRINT,255-$IBPON  TURN PRINT STATUS OFF\n         SPACE 1\nMOCLBMOR L     RC,AVMACLIB         GET BEGIN ADDRESS OF MACRO LIST\n         USING MACLIB,RC           NOTE USING ON MACRO LIST DSECT\n         SR    RB,RB               ZERO FOR SEARCH END TEST\n         CL    RB,MCLIBNXT         IF LIST HEADER IS NULL\n         BE    MOCLBOUT            THEN NOTHING TO DO -- GO HOME\n         L     RC,MCLIBNXT         ELSE START LIST SCAN\n         B     MOCLBFD2            SKIP TO LOOK AT FIRST ENTRY\nMOCLBFD1 L     RC,MCLIBNXT         GET @ OF NEXT ENTRY\nMOCLBFD2 TM    MCLBTAGS,AVMCLBDF   PREVIOUSLY DEFINED?\n         BO    MOCLBFD5            DEFINED -- GO LOOK AT NEXT ENTRY\n         TM    MCLBTAGS,AVMCLBNF   PREVIOUSLY SEARCHED FOR\n         BNO   MOCLBFND            N/- GO DO FIND AND MACRO DEFINITION\nMOCLBFD5 CL    RB,MCLIBNXT         IS THIS FINAL ENTRY\n         BNE   MOCLBFD1            NO--LOOK AT NEXT\n         SPACE 5\nMOCLBSP  XCALL XXXXLBED            CALL LIBRARY ENDUP ROUTINE\n         L     RC,AVMACLIB         GET BEGIN @ OF MACRO LIST\n         SR    RB,RB               ZERO FOR SEARCH EBD TEST\n         B     MOCLBFD4            SKIP TO LOOK AT FIRST ENTRY\nMOCLBFD3 L     RC,MCLIBNXT         GET @ OF NECT ENTRY\nMOCLBFD4 TM    MCLBTAGS,AVMCLBDF   HAS THIS MACRO BEEN DEFINED\n         BO    MOCLBMR1            DEFINED -- SKIP ERROR SET\n         MVC   MOCER7MS+10(8),MCLBNAM       MOVE BAD NAME INTO MESS\n         BAL   RE,MOCLBER7         GO TO MARK NAME AS ERROR\nMOCLBMR1 CL    RB,MCLIBNXT         IS THIS FINAL ENTRY\n         BNE   MOCLBFD3            NO--CONTINUE SEARCH\n         SPACE 2\nMOCLBOUT MVC   AVPRINT,MOCPRTSV    RESTORE THE PRINT STATUS\n         LM    RA,RE,MOCOMSVE      RESTORE REGISTER TO PREVIOUS CONDIT\n         SPACE 2\n         B     MOSTINIT            RETURN FOR NEXT SOURCE CARD\n         SPACE 2\nMOCLBFND MVC   AVMSYMBL,MCLBNAM    MOVE NAME INTO WORK AREA FOR FIND\n         OI    MCLBTAGS,AVMCLBNF   MARK NAME AS SEARCHED FOR\n         XCALL XXXXFIND            CALL FIND ROUTINE\n         BM    MOCLBMOR            ERROR NOT FOUND -- MESSAGE WILL\n*                                  COME OUT LATER\n         DROP  RC                  KILL USING\nMOCLIBNI $CALL INCARD              CALL INCARD TO READ FROM MACRO\n*                                  LIBRARY\n         LTR   RB,RB               TEST MAGNITUDE OF RETURN REGISTER\n         BNZ   MOCLBER5            ERROR ON NON-ZERO VALUE\n         LA    RC,MOCMAC           GET OPCODTB ENTRY FOR MACRO\n         $CALL MACRO1              START MACRO DEFINITION PHASE\n         B     MOCLBMOR            GO BACK TO PICK UP REST OF NAMES\n         SPACE 2\n*        ERROR ROUTINES FOLLOW\n         SPACE 2\nMOCLBER1 LA    RB,$ERSTMNA         SET ERROR-SYSLIB OUT OF ORDER\n         $CALL ERRTAG              CALL TO SET ERROR FLAG BIT\n         $CALL UTPUT1              SEND ILLEGAL CARD OUT\n         B     MOCLBOUT            RETURN\n         SPACE 2\nMOCLBER2 BAL   RB,MOCERALL         GO FOR COMMON ERROR CODE\n         DC    AL2($ERINVSY)       DEFINE ERROR--INVALID SYMBOL\n         SPACE 2\nMOCLBER3 BAL   RB,MOCERALL         GO FOR COMMON ERROR CODE\n         DC    AL2($ERINVDM)       DEFINE ERROR--INVALID DELIMITER\n         SPACE 2\nMOCLBER4 MVC   RSBLENG(RSB$L+MOCER4LN+1),MOCER4ST  MOVE ERROR IN\n         LA    RB,$OUCOMM          SET COMMENT FLAG                   A\n         $CALL OUTPT2              PRINT ALLREADY DEFINED ERROR\n         B     MOCLBOUT            RETURN\n         SPACE 2\nMOCLBER5 $CALL ERRTAG              SET ERROR BIT-DEFINED BY INCARD\n         B     MOCCOM              GO FOR COMMON RETURN CODE\n         SPACE 2\nMOCLBER7 MVC   RSBLENG(RSB$L+MOCER7LN+1),MOCER7ST  MOVE THE ERROR IN\nMOCCOM   LA    RB,$OUCOMM          SET TO PRINT A COMMENT\n         $CALL OUTPT2              PRINT THE MESSAGE\n         SR    RB,RB               ER-ZERO RG TO CONTINUE\n         BR    RE                  RETURN TO CALLER\nMOCERALL LH    RB,0(,RB)           GET THE ERROR FLAG FOR ERRTAG\n         LR    RA,R1               MOVE BAD CHAR POINTER OVER\n         $CALL ERRTAG              CALL TO SET ERROR BIT\n         B     MOCNLSYS            ON BAD CHAR -- PROCESS  WHAT THERE\n*                                  IS UP TO THIS POINT\n         SPACE 5\n         USING MACLIB,RC           NOTE USING ON MACRO LIST\nMOCLOOK  SR    RB,RB               ZERO WORK REG FOR END TEST\n         B     MOCLOOK2            SKIP FIRST LINK JUMP\nMOCLOOK1 L     RC,MCLIBNXT         LINK TO NEXT ENTRY\nMOCLOOK2 CLC   AVMSYMBL,MCLBNAM    IS THIS THE ONE WE ARE LOOKING FOR\n         BE    MOCLKRT             YESYES -- GO BACK TO PRCESS\n         CL    RB,MCLIBNXT         IS THIS THE LAST ENTRY\n         BNE   MOCLOOK1            NO -- LINK TO THE NEXT ENTRY\n         LA    RB,$ERUNDEF         NAME NOT IN LIST INDICATE THIS\nMOCLKRT  BR    RD                  RETURN TO CONTINUE\n         SPACE 2\nMOCNMADD LA    RE,$LMACLIB         GET LIST ENTRY LENGTH\n         $ALLOCL RB,RE,MOCLBOUT    GET LIST SPACE\n         ST    RB,MCLIBNXT         LINK LIST TO NEW ENTRY\n         DROP  RC                  CLEAR USING\n         USING MACLIB,RB           NOTE USING ON MACLIB DSECT\n         MVC   MACLIB($LMACLIB),AWZEROS     ZERO NEW ENTRY\n         MVC   MCLBNAM,AVMSYMBL    MOVE NAME INTO LIST\n         DROP  RB                  KILL USING\n         SR    RB,RB               REZERO REGISTER TO CONTINUE\n         B     MOCNAMNT            CONTINUE SCAN FOR NEW NAMES\n         SPACE 2\nMOCOMSVE DS    5F                  TEMP REGISTER SAVE AREA\nMOCPRTSV DS    C                   SAVE BYTE FOR PRINT STATUS\nMOCMVEL  MVC   AVMSYMBL($),0(RA)   VARIABLE LENGTH NAME MOVE\nMOCMAC   DC    AL1($IM,$MACRO,0)   SEE OPG CALL TO MACRO\nMOCER4ST DC    AL1(RSB$L+MOCER4LN,$RSBMERR,1,0)  DEFINE THIS ERROR\nMOCER4MS DC    C'289 UNABLE TO OPEN MACRO LIBRARY: OPTION CANCELED'\nMOCER4LN EQU   *-MOCER4MS          LENGTH OF THE MESSAGE\nMOCER7ST DC    AL1(RSB$L+MOCER7LN,$RSBMERR,1,0)  DEFINE THIS ERROR\nMOCER7MS DC    C'288 MACRO          COULD NOT BE FOUND'\nMOCER7LN EQU   *-MOCER7MS          GET LENGTH OF THE MESSAGE\n.MONOMC2 ANOP\n         LTORG\n         DROP  RAT,R13,RW,RX       CLEAN UP USINGS\n         TITLE '*** MPCON0 - ASSIST ASSEMBLER MAIN CONTROL PROGRAM ***'\n**--> CSECT: MPCON0   0   MAIN PROGRAM CONTROL-INIT,SET UP TABLES,ETC..\n*.       MPCON0 INITIALIZES AVWXTABL DSECT VALUES FOR WHOLE ASSEMBLY, .\n*.       SETS A $SPIE TO INTERCEPT SOME TYPES OF INTERRUPTS, SETS THE .\n*.       PROGRAM AMSK TO ONLY HAVE FIXED-OVERFLOW INTRPTS, AND CALLS  .\n*.       ALL THE SUBROUTINES REQUIRED FOR AN ASSEMBLY IN A TABLE-     .\n*.       DRIVEN MANNER, USING A LIST OF POINTERS TO ADDRESS CONSTNATS..\n*.       AFTER THE ASSEMBLY IS COMPLETED, IT PRINTS VARIOUS STATISTICS.\n*.       AND THEN RETURNS CONTROL TO THE ASSIST MONITOR.  NOTE THAT   .\n*.       MPCON0 IS THE ONLY CSECT IN THE ASSEMBLER WHICH ACTUALLY     .\n*.       REFERS TO AJOBCON, ALTHOUGH OTHERS USE EQU FLAGS FROM IT.    .\n*.       ENTRY CONDITIONS                                             .\n*   R12(RAT)= @ VWXTABL CSECT, INITIALIZED BY ASSIST CONTROL PROG.    .\n*   AVAJOBPT,AVECONPT HAVE BEEN INITIALIZED IF NEEDED BY ASSIST.      .\n*.       CALLS ESINT1,LTINT1,OPINIT,SYINT1,UTINT1,OUINT1,MOCON1       .\n*.       CALLS LTEND1,UTEND1,BRINIT,MTCON2                            .\n*.       CALLS OUEND2,SYEND2,UTEND2                                   .\n*.       USES DSECTS: AVWXTABL                                        .\n*.       USES MACROS: $AL2, $CALL, $PRNT, $RETURN, $SAVE, $SPIE       .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nMPCON0   CSECT\n         $DBG  ,NO\n         $SAVE RGS=(R14-R12),BR=R13,SA=MPSAVE\n         SPACE 1\n*              INITIALIZATION FOR ASSEMBLY - OBTAIN VARIOUS VALUES    *\n*              FROM AJOBCON. ZERO FLAGS. SET SPIE,PROGRAM MASK.       *\n         SPACE 1\n         USING AVWXTABL,RAT        NOTE MAIN USING FROM NOW ON\n         LM    R2,R3,AVADDLOW      GET ORIG CORE LIMITS FOR STATS LATER\n         MVC   AWZEROS+C' '(64),AWZEROS     MAKE SURE ZERO(SEE SCANRS)\n         MVC   AVZAREA1(AVZAREA2-AVZAREA1),AWZEROS     ZERO OUT AREA\n         MVC   AVRCBPT(7*4),AWZEROS         ZERO AVRCBPT---AVSOLAST\n*                                  REQUIRED FOR REPLACE, GOOD DEBUG\n         NI    AVTAGS1,255-$IBSTAR1-$IBDSEC1-$IBPRCD1  INIT VALUES\n         NI    AVTAGS2,255-$INEND2     CLEAR EOF FLAG\n         SPACE 1\n         $SPIE ,((7,15)),ACTION=CR,CE=MPSPIEXT   GET CONTROL FOR ERRS\n         ST    R1,AVMPSPIE         SAVE @ PREVIOUS SPIE CONTROL BLOCK\n         L     R0,=XL4'08000000'   GET MASK FOR SPM (FIXED OVER ONLY)\n         SPM   R0                  SET TO STOP ANY FP INTERRUPTS\n         SPACE 1\n*              SET UP VALUES FOR CALLS TO ALL SUBROUTINES             *\n         LA    RZ,MPCALL1          INIT INDEX FOR BXLE CALL LOOP\n         LA    RX,2                INCREMENT FOR BXLE\n         LA    RY,MPCALL2-2        LIMIT ADDRESS FOR BXLE\n         SPACE 1\n*              FOLLOWING LOOP PERFORMS ENTIRE ASSEMBLY PROCESS.\nMPCALLR  LH    REP,0(,RZ)          GET OFFSET @ FROM OFFSET LIST\n         $CALL $BASE(REP)          CALL THE RIGHT ROUTINE\n         BXLE  RZ,RX,MPCALLR       LOOP THRU CALL LIST\n         EJECT\n*              IF 'STOP' BIT SET, FLAG NOLOAD ALSO\n         TM    AVTAGS2,AJOASTOP    HAS STOP BIT BEEN SET FOR ANY REASON\n         BZ    *+8                 NO, CONTINUE\n         OI    AVTAGS1,AJNLOAD     SHOW NO LOAD CAN BE DONE\n         SPACE 1\n*              CONVERT AND PRINT STORAGE USAGE. NOTE THAT THIS CODE,  *\n*              MPCONV, AND DATA MPAT-MPHLEN ARE NOT REQUIRED FOR      *\n*              ACTUAL WORKING OF THE PROGRAM, AND COULD BE REMOVED.   *\n         LM    R0,R1,AVADDLOW      GET CURRENT FREE AREA POINTERS\n         SPACE 1\n         SR    R3,R1               AJOTADH -AVADDHIH = HIGH CORE USED\n         SR    R0,R2               AVADDLOW-AJOTADL = LOW CORE USED\n         LR    R5,R0               SAVE TO CALCULATE TOTAL SPACE.\n         S     R1,AVADDLOW         AVADDHIH-AVADDLOW = REMAINING AREA\n         LA    R2,MPARL            @ FIRST AREA FOR LOW STORAGE\n         BAL   RZ,MPCONV           HAVE LOW VALUE(R0) CONVERTED\n         LA    R2,MPARH            ADDRESS OF HIGH AREA USED\n         LR    R0,R3               MOVE DIFFERENCE OVER WHERE EXPECTED\n         SPACE 1\n         BAL   RZ,MPCONV           CALL CONVERTER ROUTINE\n         LA    R2,MPREM            @ REMAINING AREA TO BE PRINTED\n         LR    R0,R1               MOVE VALUE OVER FOR CONVERTER\n         BAL   RZ,MPCONV           CALL CONVERTER\n         SPACE 1\n*              COMPUTE AVERGAE # BYTES PER STATEMENT USED.\n         AR    R5,R3               ADD HIGH USED (R5) TO LOW USED(R3)\n         SR    R4,R4               CLEAR SO DIVIDE WORKS OK\n         LH    R0,AVSTMTNO         GET # STATEMENTS\n         DR    R4,R0               DIVIDE TO GET BYTES/STATEMENT\n         LR    R0,R5               MOVE QUOTIENT OVER\n         LA    R2,MPBYSTMT         FOR # BYTES/STMT\n         BAL   RZ,MPCONV           CALL CONVERTER\n         SPACE 1\n         $PRNT MPHEAD,MPHLEN       PRINT THE ASSEMBLED LINE\n         AIF   (NOT &$XREF).NOXREF9  SKIP IF NO XREF                  A\n         TM    AVXRFLAG,AVXRON     DO WE WANT A CROSS REFERENCE       A\n         BZ    MPRETA              NO SKIP CALL                       A\n         $CALL XRPRNT              CALL CROSS REF PRINT ROUTINE       A\n.NOXREF9 ANOP                                                         A\nMPRETA   EQU   *\n         L     R1,AVMPSPIE         GET @ PREVIOUS SPIE BLOCK BACK\n         $SPIE ACTION=(RS,(1))     RESTORE PREVIOUS SPIE BLOCK\nMPRET    $RETURN RGS=(R14-R12)\n         EJECT\n*              SPIE EXIT ROUTINE - FLAGS INTERRUPTS 0C7-0CF.          *\n         USING MPSPIEXT,R15        NOTE ENTRY PT AT SPIE\nMPSPIEXT STM   R14,R12,12(R13)     SAVE ALL THE REGS\n         LA    RB,$ERINTPT         SHOW INTERRUPT MESSAGE\n         $CALL ERRTAG              CALL ERROR FLAGGING\n         LM    R14,R12,12(R13)     RELOAD REGS\n         BR    R14                 RETURN TO SUPERVISOR\n         DROP  R15                 KILL TEMPORARY USING\n         SPACE 1\n         SPACE 2\n* * * * * MPCONV - CONVERT 1 ADDRESS DIFERENCE  AND EDIT IT           *\n*        ENTRY CONDITIONS                                             *\n*   R0 = ADDRESS DIFFERENCE TO BE CONVERTED                           *\n*   R2 = ADDRESS OF AREA WHERE EDITED VALUE TO BE PUT                 *\n*   RZ = RETURN ADDRESS TO CALLING CODE                               *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nMPCONV   CVD   R0,AVDWORK1         CONVERT DIFFERENCE TO DECIMAL\n         MVC   0(L'MPAT,R2),MPAT   MOVE THE PATTERN IN\n         ED    0(L'MPAT,R2),AVDWORK1+8-L'MPAT/2       EDIT VALUE OVER\n         BR    RZ                  RETURN TO CALLER\n         SPACE 1\n* * * * * INTERNAL CONSTANTS                                          *\n*              OFFSETS TO ADCONS FOR ROUTINES TO BE CALLED            *\nMPCALL1  DS    0H\n         $AL2  AX$BASE,(AXESINT1,AXLTINT1,AXOPINIT,AXSYINT1,AXUTINT1)\n         AIF   (NOT &$MACROS).MPNOMA1       SKIP IF NO MACRO MODS\n         $AL2  AX$BASE,(AXMACINT)      OPCODE INITIALIZATION\n.MPNOMA1 ANOP\n         AIF   (NOT &$XREF).NOXREF8                                   A\n         $AL2  AX$BASE,(AXXRINT1)  XREF INTIALIZATION PASS 1          A\n.NOXREF8 ANOP                                                         A\n         $AL2  AX$BASE,(AXOUINT1,AXMOCON1)\nMPCALL1A $AL2  AX$BASE,(AXLTEND1,AXUTEND1,AXBRINIT)                   A\n         AIF   (NOT &$XREF).NOXRF70   SKIP IF NO XREF\n         $AL2  AX$BASE,(AXXRINT2)   XREF INITIALIZATION 2ND PASS      1\n.NOXRF70 ANOP\n         $AL2  AX$BASE,(AXMTCON2)\n         $AL2  AX$BASE,(AXOUEND2,AXSYEND2,AXUTEND2)\nMPCALL2  EQU   *\n         SPACE 1\n*              STORAGE USAGE OUTPUT HEADING,EDIT PATTERN              *\nMPAT     DC    X'4020202020202120' EDIT PATTERN FOR ADDRESSES\nMPHEAD   DC    C'0*** DYNAMIC CORE AREA USED:  LOW:'\nMPARL    DS    CL(L'MPAT)          FOR LOW AREA USAGE\n         DC    C' HIGH:'\nMPARH    DS    CL(L'MPAT)          FOR HIGH AREA USAGE(SYMBOL TABLE)\n         DC    C' LEAVING:'\nMPREM    DS    CL(L'MPAT)          FOR REMAINING STORAGE\n         DC    C' FREE BYTES. AVERAGE: '\nMPBYSTMT DS    CL(L'MPAT)          FOR AVERAGE BYTES/STMT\n         DC    C' BYTES/STMT ***'\nMPHLEN   EQU   *-MPHEAD            DEFINE LENGTH OF AREA\n         LTORG\n         DROP  RAT,R13             CLEAR UP USING\n         TITLE '*** MTCON2 - MAIN CONTROL - PASS 2 ***'\n**--> CSECT: MTCON2   2   MAIN CONTROL - ASSEMBLER PASS 2 . . . . . . .\n*.       MTCON2 IS THE CONTROL PROGRAM FOR THE 2ND PASS OF THE ASSIST .\n*.       OF THE ASSIST ASSEMBLER.  IT IS RELATIVELY SMALL, SINCE      .\n*.       MOST OF THE WORK HAS BEEN DONE IN PASS 1.   IT PERFORMS OR   .\n*.       SUPERVISES THE FOLLOWING ACTIONS, FOR EACH SOURCE STMT:      .\n*.        1. RETRIEVES POINTERS TO THE RECORD BLOCKS (UTGET2).        .\n*.        2. SETS UP THE LOCATION COUNTER AND OPERAND SCAN POINTER.   .\n*.        3. CALLS 2ND LEVEL INSTRUCTION PROCESSORS(ICMOP2,IDASM2).   .\n*.        4. PRINTS ANY STATEMENT WITH NO RCODBLK (OUTPT2).           .\n*.       FINISH BY ROUNDING UP LENGTH OF PROG TO DOUBLEWORD BOUNDARY. .\n*.       CALLS ICMOP2,IDASM2,OUTPT2,UTGET2                            .\n*.       USES DSECTS: AVWXTABL,RCODBLK,RSBLOCK                        .\n*.       USES MACROS: $CALL,$RETURN,$SAVE,$SLOC                       .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nMTCON2   CSECT\n         $DBG  90,*\n         USING AVWXTABL,RAT        NOTE MAIN USING\n         $SAVE RGS=(R14-R6),SA=MTCOSAVE,BR=R13\n         SR    R2,R2               CLEAR FOR INSERTIONS\n         MVI   AVCESDID,2          INIT TO VALUE IN CASEE UNIT PRIV CD\n         SPACE 1\n*              MTGET2 ENTERED 1 TIME FOR EACH STATEMENT. CALLS UTGET2 *\n*        TO GET @'S OF RECORD BLOCKS.  @ RSBLOCK IS RETURNED IN RC,   *\n*        AND ALL EXISTING VALUES HAVE BEEN FILLED IN FOR RECORD PTRS. *\n         SPACE 1\nMTGET2   EQU   *                   ENTRY FOR LOOP HEAD FOR 1 STMT\n*              IF 'STOP' BIT SET BY ANYONE, QUIT NOW.\n         TM    AVTAGS2,AJOASTOP    HAS IT BEEN SET\n         BO    MTRET               YES, QUIT\n         SPACE 1\n         $CALL UTGET2              CALL TO OBTAIN NEXT BLOCKS\n         LTR   RE,RE               WAS THIS THE END\n         BNZ   MTENDOF             YES,NO MORE TO DO-QUIT\n         LR    RE,RC               MOVE @ RSBLOCK OVER\n         USING RSBLOCK,RE          NOTE POINTER\n         TM    RSBFLAG,$RCBX       DOES A RCB EXIST\n         BZ    MTPRINT             NO IT DOESN'T,EITHER ERROR OR COMM\n         SPACE 1\n*              GET INFORMATION FROM RCODBLK. SRT UP FOR LEVEL 2 SUBRS.\n         L     RC,AVRCBPT          GET @ RCODBLK BACK INTO REG\n         USING RCODBLK,RC          NOTE THIS USING\n         IC    R2,RSBSCAN          GET SCAN POINTER TO BEGINNING OF OPE\n         LA    RA,RSBLOCK(R2)      GET @ OPERAND FIELD\n         L     RD,RCLOC-1          GET THE LOCATION COUNTER FOR STMT\n         LA    RD,0(RD)            REMOVE 1ST BYTE\n         $SLOC RD                  SET THE LOCATION COUNTER\n         SPACE 1\n*              CHOOSE CORRECT 2ND-LEVEL PROCESSOR.\n         TM    RCTYPE,$IB          MAKE TYPE TEST\n         BO    MTCID               BRANCH TO CALL ASSEMBLER ROUTINE\n         AIF   (NOT &$SPECIO).MTNOSPC       SKIP IF NO SPECIALS\n         BZ    MTCID               BRANCH IF ASSEMBLER INSTRUCTIONS\n*              FALLS THRU ==> SPECIAL INST                            *\n         IC    R2,RCTYPE           GET TYPE BYTE\n         SLL   R2,2                *4 FOR FULLWORD @ INDEXING\n         $CALL SPECA2-4*$IS(R2)    GET 2ND PASS SPECIAL ROUTINES\n         B     MTGET2              GO GET NEXT RECORD\n.MTNOSPC ANOP\nMTCIC    $CALL ICMOP2              PASS 2 MACHINE INSTRUCTIONS\n         B     MTGET2              GO GET NEXT ONE\n         SPACE 1\nMTCID    $CALL IDASM2              ASSEMBLER INSTRUCTIONS\n         B     MTGET2              GO GET NEXT ONE\n         SPACE 1\nMTPRINT  LA    RB,$OUCOMM          SHOW OUTPT2 NO LOCCNTR OR CODE\n         $CALL OUTPT2              CALL PRINTER ROUTINE\n         AIF   (NOT &$XREF).NOXRF13                                   A\n*   CHECK FOR THE * XREF CARD                                         A\n         CLI   RSBSOURC,C'*'       IS IT A COMMENT CARD               A\n         BNE   MTNXREFF            NO, CAN'T BE * XREF CARD           A\n         CLC   RSBSOURC+1(4),=C'XREF'  IS IT XREF                     A\n         BNE   MTNXREFF            NO, GO ON                          A\n         LA    RA,RSBSOURC+5       FOR ENTRY TO XRSCAN (@ TO BEGIN)   L\n         LA    RD,8                SET ENTRY CONDITIONS TO XRSCAN     L\n         $CALL XRSCAN              CALL SCANNING ROUTINE              A\nMTNXREFF EQU   *                                                      A\n.NOXRF13 ANOP                                                         A\n         B     MTGET2              GO GET NEXT ONE\nMTENDOF  EQU   *\n*              ALIGN LENGTH OF PROG TO MULTIPLE OF 8.\n         L     R0,AVLOCHIH         GET HIGHEST LOCATION COUNTER  VALUE\n         LA    R1,7                GET VALUE FOR DOUBLEWORD ALIGN\n         $ALIGR R0,R1              ALIGN UP TO DOUBLEWORD BOUNDARY\n         ST    R0,AVLOCHIH         RESTORE UPDATED,ALIGNED VALUE\n         S     R0,AVLOCLOW         LENGTH= HIGH LOCATION-LOW LOCATION\n         A     R0,AVRADL           + LOWEST REAL LOCATION\n         ST    R0,AVRADH           = HIGH LIMIT FOR REAL @'S\nMTRET    $RETURN RGS=(R14-R6)\n         DROP  RAT,RC,RE,R13       CLEAR USINGS\n         LTORG                                                        A\n         TITLE '*** OPCOD1 - IDENTIFY MNEMONIC OPERATION CODES ***'\n**--> CSECT: OPCOD1   1   OPCODE TABLES AND LOOKUP CODE . . . . . . . .\n*.       THIS MODULE CONTAINS THE CODE,TABLES TO IDENTIFY OPCODES.    .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nOPCOD1   CSECT\n         $DBG  90,*\n         USING AVWXTABL,RAT        NOTE MAIN TABLE USING\nOP1      EQU   IAL2+1              COMMON MASK FIELD==>LIT ALLOWED,H AL\nOP3      EQU   IAL2+3              MASK FIELD==>LIT ALLOWED, FULL ALIG\nOP7      EQU   IAL2+7              MASK FIELD==>LIT ALLOWED,D ALIGN\nIAR      EQU   IAA+IAB             MASK FIELD==>R1 AND R2 MUST BE EVEN\n         ENTRY OPINIT,OPFIND\n         SPACE 2\n**--> ENTRY: OPINIT   1   INITILIAZE OPCODE ROUTINE IF NEEDED . . . . .\n*.       AS OF 8/17/70, THIS ENTRY DOES NOTHING. IT IS INCLUDED FOR   .\n*.       COMPLETENESS, POSSIBLE MODIFICATION REQUIRING INITIALIZATION..\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nOPINIT   BR    R14                 RETURN-NOTHING TO DO NOW\n         SPACE 2\n**--> ENTRY: OPFIND   1   LOOK UP AN OPCODE . . . . . . . . . . . . . .\n*.       ENTRY CONDITIONS                                             .\n*.  RA = SCAN POINTER TO 1ST CHARACTER OF OPCODE                      .\n*.       EXIT CONDITIONS                                              .\n*.  RA = SCAN POINTER TO 1ST BLANK FOLLOWING LEGAL OPCODE,OR SAME AS O.\n*.       ENTRY IF OPCODE WAS NOT RECOGNIZED.                          .\n*.  RB = 0 IF THE OPCODE WAS FOUND IN OPCODE TABLE                    .\n*.  RB = NONZERO VALUE - ERROR CODE FOR ILLEGAL OPCODE ($ERIVOPC)     .\n*.  RC = ADDRESS OF OPCODTB ENTRY FOR THE OPCODE, IF IT WAS FOUND     .\n*.       USES DSECTS: AVWXTABL,OPCODTB                                .\n*.       USES MACROS: $RETURN,$SAVE,OPG,OPGT                          .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nOPFIND   $SAVE RGS=(R1-R2),SA=NO\n         CLI   0(RA),C'A'          MAKE SURE NO ILLEGAL\n         BL    OPFERR              ILLEGAL,NOTE ERROR\n         LR    R1,RA               DUPLICATE THE SCAN POINTER\n         LA    RE,6(R1)            GET THE LIMIT FOR THE BXLE\n         LA    RD,1                GET INCREMENT FOR BXLE\n         SPACE 1\n*              SCAN LOOP TO FIND END OF MNEMONIC                      *\nOPFLOOP  CLI   1(R1),C' '          LOOK FOR BLANK\n         BE    OPFLNG              BLANK FOUND-END OF OPCODE\n         BXLE  R1,RD,OPFLOOP       CONTINUE SEARCHING\n         B     OPFERR              ERROR- NOT RIGHT SIZE\n         SPACE 1\n*              END OF MNEMONIC FOUND, GET POINTERS ET UP FOR LOOKUP   *\nOPFLNG   LR    R2,R1               DUPLICATE PT TO LAST CHAR OF OPCODE\n         SR    R2,RA               GET LENGTH-1 OF OPCODE = 0-7\n         STC   R2,OPFCOMP+1        PLACE INTO CLC INSTRUCTION\n         LA    RD,OPCMNEM-OPCODTB+1(R2)      GET TOTAL LENGTH OF ENTRY\n         IC    R2,OPFL1(R2)        GET 1ST OFFSET VALUE,DEPNDING ON LEN\n         LTR   R2,R2               MAKE SURE THERE ARE SOME OF THIS LEN\n         BZ    OPFERR              NO THERE AREN'T-ERROR\n         SPACE 1\n         LA    RE,OPADS(R2)        ADDR OF RIGHT TABLE SET\n         IC    R2,0(RA)            GET THE 1ST CHAR OF OPCODE\n         IC    R2,OPFCH1-C'A'(R2)  GET 2ND OFFSET VALUE FOR LETTERS\n         LH    RC,0(R2,RE)         GET THE CORRECT POINTER\n         AR    RC,R15              ADD ADDRESS OF OPFIND TO GET REAL AD\n         USING OPCODTB,RC          NOTE DSECT FOR TABLE ENTRY\n         LH    RE,2(R2,RE)         GET THE LIMIT ADDRESS IN TABLE\n         AR    RE,R15              ADD TO GET REAL ADDRESS\n         SPACE 1\n*              SEARCH LOOP TO LOOK UP MNEMONIC                        *\nOPFCOMP  CLC   0($CHN,RA),OPCMNEM  COMPARE MNEMONIC WITH TABLE ENTRY\n         BNH   OPFCHK              IF NOT HIGH, EITHER SAME, OR NO GOOD\n         BXLE  RC,RD,OPFCOMP       CONTINUE LOOPING\nOPFCHK   BNE   OPFERR              NE==>ERROR(GET LOOP FALL THRU TOO)\n         SPACE 1\n         SR    RB,RB               CLEAR RB TO SHOW OK.\n         LA    RA,1(R1)            UPDATE SCAN POINTER TO BLANK\nOPFRET   $RETURN RGS=(R1-R2),SA=NO\nOPFERR   LA    RB,$ERIVOPC         INVALID OPCODE\n         B     OPFRET              RETURN\n         EJECT\n* * * * * INTERNAL CONSTANTS                                          *\n*        1ST LEVEL POINTER TABLE-HAS OFFSET ADDRESSES OF POINTER SETS *\n*        BELONGING TO EACH USABLE OPCODE LENGTH FROM 1 TO 8.          *\nOPFL1    DC    AL1(OPF1-OPADS,OPF2-OPADS,OPF3-OPADS,OPF4-OPADS,OPF5-OPA#\n               DS,OPF6-OPADS,OPF7-OPADS,OPF8-OPADS)\n         SPACE 2\n*        INDIVIDUAL OPCODTB ENTRY TABLES, IN ORDER BY LENGTH, THEN    *\n*        ALPHABETICALLY WITHIN LENGTH                                 *\n         SPACE 1\n*              1-CHARACTER INSTRUCTIONS                               *\nOP1A     EQU   *\n         OPG   A,$RX,90,OP3        ADD\nOP1B     EQU   *\n         OPG   B,$RXM,71,X'F0'+1   BRANCH\nOP1C     EQU   *\n         OPG   C,$RX,89,OP3        COMPARE\nOP1D     EQU   *\n         OPG   D,$RX,93,OP3+IAA    DIVIDE\nOP1L     EQU   *\n         OPG   L,$RX,88,OP3        LOAD\nOP1M     EQU   *\n         OPG   M,$RX,92,OP3+IAA    MULTIPLY\nOP1N     EQU   *\n         OPG   N,$RX,84,OP3        AND\n         OPG   O,$RX,86,OP3        OR\nOP1S     EQU   *\n         OPG   S,$RX,91,OP3        SUBTRACT\nOP1T     EQU   *\n         OPG   X,$RX,87,OP3        EXCLUSIVE OR\nOP1END   EQU   *\n         EJECT\n*              2-CHARACTER INSTRUCTIONS                               *\nOP2A     EQU   *\n         OPG   AD,$RX,106,OP7+IAA,F    ADD NORM LONG\n         OPG   AE,$RX,122,OP3+IAA,F    ADD NORM SHORT\n         OPG   AH,$RX,74,OP1       ADD HALFWORD\n         OPG   AL,$RX,94,OP3       ADD LOGICAL\n         OPG   AP,$SS2,250,IAL2,D  ADD DECIMAL\n         OPG   AR,$RR,26           ADD REGISTER\n         OPG   AU,$RX,126,OP3+IAA,F    ADD UNNORM SHORT\n         OPG   AW,$RX,110,OP7+IAA,F    ADD UNNORM LONG\nOP2B     EQU   *\n         OPG   BC,$RX,71,1         BRANCH ON CONDITION\n         OPG   BE,$RXM,71,X'80'+1  BRANCH ON EQUAL\n         OPG   BH,$RXM,71,X'20'+1  BRANCH ON HIGH\n         OPG   BL,$RXM,71,X'40'+1  BRANCH ON LOW\n         OPG   BM,$RXM,71,X'40'+1  BRANHC ON MINUS\n         OPG   BO,$RXM,71,X'10'+1  BRANCH ON ONES\n         OPG   BP,$RXM,71,X'20'+1  BRANCH ON PLUS\n         OPG   BR,$RRM,7,X'F0'     BRANCH REGISTER\n         OPG   BZ,$RXM,71,X'80'+1  BRANCH ON ZERO\nOP2C     EQU   *\n         OPG   CD,$RX,105,OP7+IAA,F    COMPARE LONG\n         OPG   CE,$RX,121,OP3+IAA,F    COMPARE SHORT\n         OPG   CH,$RX,73,OP1       COMPARE HALFWORD\n         OPG   CL,$RX,85,OP3       COMPARE LOGICAL\n         OPG   CP,$SS2,249,IAL1+IAL2,D       COMPARE DECIMAL\n         OPG   CR,$RR,25           COMPARE REGISTER\nOP2D     EQU   *\n         OPG   DC,$IDC+$IB,$IBSTAR1          DEFINE CONSTANT\n         OPG   DD,$RX,109,OP7+IAA,F    DIVIDE LONG\n         OPG   DE,$RX,125,OP3+IAA,F    DIVIDE SHORT\n         OPG   DP,$SS2,253,IAL2,D  DIVIDE DECIMAL\n         OPG   DR,$RR,29,IAA       DIVIDE REGISTER\n         OPG   DS,$IDS+$IB,$IBSTAR1          DEFINE STORAGE\n         OPG   ED,$SS,222,IAL2,D   EDIT\n         OPG   EX,$RX,68,OP1       EXECUTE\n         OPG   IC,$RX,67,IAL2      INSERT CHARACTER\nOP2L     EQU   *\n         OPG   LA,$RX,65,IAL2      LOAD ADDRESS\n         OPG   LD,$RX,104,OP7+IAA,F    LOAD LONG\n         OPG   LE,$RX,120,OP3+IAA,F    LOAD SHORT\n         OPG   LH,$RX,72,OP1       LOAD HALFWORD\n         OPG   LM,$RS,152,OP3      LOAD MULTIPLE\n         OPG   LR,$RR,24           LOAD REGISTER\n         EJECT\nOP2M     EQU   *\n         OPG   MD,$RX,108,OP7+IAA,F    MULTIPLY LONG\n         OPG   ME,$RX,124,OP3+IAA,F    MULTIPLY SHORT\n         OPG   MH,$RX,76,OP1       MULTIPLY HALFWORD\n         OPG   MP,$SS2,252,IAL2,D  MULTIPLY DECIMAL\n         OPG   MR,$RR,28,IAA       MULTIPLY REGISTER\nOP2N     EQU   *\n         OPG   NC,$SS,212,IAL2     AND CHARACTER\n         OPG   NI,$SI,148          AND IMMEDIATE\n         OPG   NR,$RR,20           AND REGISTER\n         OPG   OC,$SS,214,IAL2     OR CHARACTER\n         OPG   OI,$SI,150          OR IMMEDIATE\n         OPG   OR,$RR,22           OR REGISTER\nOP2S     EQU   *\n         OPG   SD,$RX,107,OP7+IAA,F    SUBTRACT NORM LONG\n         OPG   SE,$RX,123,OP3+IAA,F    SUBTRACT NORM SHORT\n         OPG   SH,$RX,75,OP1       SUBTRACT HALFWORD\n         OPG   SL,$RX,95,OP3       SUBTRACT LOGICAL\n         OPG   SP,$SS2,251,IAL2,D  SUBTRACT DECIMAL\n         OPG   SR,$RR,27           SUBTRACT REGISTER\n         OPG   ST,$RX,80,3         STORE\n         OPG   SU,$RX,127,OP3+IAA,F    SUBTRACT UNNORM SHORT\n         OPG   SW,$RX,111,OP7+IAA,F    SUBTRACT UNNORM LONG\nOP2T     EQU   *\n         OPG   TM,$SI,145,IAL1     TEST UNDER MASK\n         OPG   TR,$SS,220,IAL2     TRANSLATE\n         OPG   TS,$RSO,147         TEST AND SET (ONLY NON-PRIV TYPE)\n         OPG   XC,$SS,215,IAL2     EXCLUSIVE OR CHARACTER\n         OPG   XI,$SI,151          EXCLUSIVE OR IMMEDIATE\n         OPG   XR,$RR,23           EXCLUSIVE OR REGISTER\nOP2END   EQU   *\n         EJECT\n*              3-CHARACTER INSTRUCTIONS                               *\nOP3A     EQU   *\n         OPG   ADR,$RR,42,IAR,F       ADD NORM LONG REGISTER\n         OPG   AER,$RR,58,IAR,F       ADD NORM SHORT REGISTER\n         OPG   AGO,$IM,$AGO,,M\n         OPG   AIF,$IM,$AIF,,M\n         OPG   ALR,$RR,30          ADD LOGICAL REGISTER\n         OPG   AUR,$RR,62,IAR,F       ADD UNNORM SHORT REGISTER\n         OPG   AWR,$RR,46,IAR,F       ADD UNNORM LONG REGISTER\n         OPG   AXR,$RR,54,IAR,FX        ADD EXTENDED REGISTER\nOP3B     EQU   *\n         OPG   BAL,$RX,69,1        BRANCH AND LINK\n         OPG   BCR,$RR,7           BRANCH ON CONDITION REGISTER\n         OPG   BCT,$RX,70,1        BRANCH ON COUNT\n         OPG   BER,$RRM,7,X'80'    **EXTENDED BRANCH MNEMONIC**       J\n         OPG   BHR,$RRM,7,X'20'    **EXTENDED BRANCH MNEMONIC**       J\n         OPG   BLR,$RRM,7,X'40'    **EXTENDED BRANCH MNEMONIC**       J\n         OPG   BMR,$RRM,7,X'40'    **EXTENDED BRANCH MNEMONIC**       J\n         OPG   BNE,$RXM,71,X'70'+1 BRANCH ON NOT EQUAL\n         OPG   BNH,$RXM,71,X'D0'+1 BRANCH ON NOT HIGH\n         OPG   BNL,$RXM,71,X'B0'+1 BRANCH ON NOT LOW\n         OPG   BNM,$RXM,71,X'B0'+1 BRANCH ON NOT MINUS\n         OPG   BNO,$RXM,71,X'E0'+1 BRANCH ON NOT ONES\n         OPG   BNP,$RXM,71,X'D0'+1 BRANCH ON NOT PLUS\n         OPG   BNZ,$RXM,71,X'70'+1 BRANCH ON NOT ZERO\n         OPG   BOR,$RRM,7,X'10'    **EXTENDED BRANCH MNEMONIC**       J\n         OPG   BPR,$RRM,7,X'20'    **EXTENDED BRANCH MNEMONIC**       J\n         OPG   BXH,$RS,134,1       BRANCH ON INDEX HIGH\n         OPG   BZR,$RRM,7,X'80'    **EXTENDED BRANCH MNEMONIC**       J\nOP3C     EQU   *\n         OPG   CCW,$ICCW+$IB,$IBSTAR1,7,P    CHANNEL COMMAND WORD\n         OPG   CDR,$RR,41,IAR,F       COMPARE LONG REGISTER\n         OPG   CER,$RR,57,IAR,F       COMAPRE SHORT REGISTER\n         OPG   CLC,$SS,213,IAL1+IAL2         COMPARE LOGICAL CHARACTER\n         OPG   CLI,$SI,149,IAL1    COMPARE LOGICAL IMMEDIATE\n         OPG   CLM,$RS,189,IAL2,S370    COMPARE LOGICAL UNDER MASK\n         OPG   CLR,$RR,21          COMPARE LOGICAL REGISTER\n         OPG   CVB,$RX,79,OP7      CONVERT TO BINARY\n         OPG   CVD,$RX,78,7        CONVERT TO DECIMAL\nOP3D     EQU   *\n         OPG   DDR,$RR,45,IAR,F       DIVIDE LONG REGISTER\n         OPG   DER,$RR,61,IAR,F       DIVIDE SHORT REGISTER\n         OPG   END,$IEND+$IB,IBOMOP+IBNONAM+IBMOSPEC  END\n         OPG   EQU,$IEQU+$IB,IBNENAM+$IBSTAR1,1        EQUATE\n         OPG   HDR,$RR,36,IAR,F       HALVE LONG\n         OPG   HER,$RR,52,IAR,F       HALVE SHORT\n         OPG   HIO,$RSO,158,,P     HALT I/O\n         OPG   ICM,$RS,191,IAL2,S370    INSERT CHARACTERS UNDER MASK\n         OPG   ISK,$RR,9,,P        INSERT STORAGE KEY\nOP3L     EQU   *\n         OPG   LCR,$RR,19          LOAD COMPLEMENT REGISTER\n         OPG   LDR,$RR,40,IAR,F       LOAD LONG REGISTER\n         OPG   LER,$RR,56,IAR,F       LOAD SHORT REGISTER\n         OPG   LNR,$RR,17          LOAD NEGATIVE REGISTER\n         OPG   LPR,$RR,16          LOAD POSITIVE REGISTER\n         OPG   LTR,$RR,18          LOAD AND TEST REGISTER\n         EJECT\nOP3M     EQU   *\n         OPG   MDR,$RR,44,IAR,F       MULTIPLY LONG REGISTR\n         OPG   MER,$RR,60,IAR,F       MULTIPLY SHORT REGISTER\n         OPG   MVC,$SS,210,IAL2    MOVE CHARACTER\n         OPG   MVI,$SI,146         MOVE IMMEDIATE\n         OPG   MVN,$SS,209,IAL2    MOVE NUMERICS\n         OPG   MVO,$SS2,241,IAL2   MOVE WITH OFFSET (2 LENGTHS)\n         OPG   MVZ,$SS,211,IAL2    MOVE ZONES\n         OPG   MXD,$RX,103,IAA+OP7,FX   MULTIPLY EXTENDED/LONG\n         OPG   MXR,$RR,38,IAR,FX        MULTIPLY EXTENDED REGISTER\nOP3N     EQU   *\n         OPG   NOP,$RXM,71,X'00'+1 NO OPERATION\n         OPG   ORG,$IORG+$IB,IBNONAM+IBOMOP+$IBSTAR1   ORIGIN\n         OPG   RDD,$SI,133,,P      READ DIRECT\nOP3S     EQU   *\n         OPG   SCK,$RSO,178,X'40'+OP7,P370   SET CLOCK\n         OPG   SDR,$RR,43,IAR,F       SUBTRACT NORM LONG REGISTER\n         OPG   SER,$RR,59,IAR,F       SUBTRACT NORM SHORT REGISTER\n         OPG   SIO,$RSO,156,,P     START I/O\n         OPG   SLA,$RSH,139,IAL2   SHIFT LEFT ALGEBRAIC\n         OPG   SLL,$RSH,137,IAL2   SHIFT LEFT LOGICAL\n         OPG   SLR,$RR,31          SUBTRACT LOGICAL REGISTER\n         OPG   SPM,$RSO,4\n         OPG   SRA,$RSH,138,IAL2   SHIFT RIGHT ALGEBRAIC\n         OPG   SRL,$RSH,136,IAL2   SHIFT RIGHT LOGICAL\n         OPG   SRP,$SS2,240,,S370   SHIFT AND ROUND PACKED\n         OPG   SSK,$RR,8,,P        SET STORAGE KEY\n         OPG   SSM,$RSO,128,,P     SET SYSTEM MASK\n         OPG   STC,$RX,66          STORE CHARACTER\n         OPG   STD,$RX,96,7+IAA,F      STORE LONG\n         OPG   STE,$RX,112,3+IAA,F     STORE SHORT\n         OPG   STH,$RX,64,1        STORE HALFWORD\n         OPG   STM,$RS,144,3       STORE MULTIPLE\n         OPG   SUR,$RR,63,IAR,F       SUBTRACT UNNORM SHORT REGISTER\n         OPG   SVC,$RSO,10         SUPERVISOR CALL\n         OPG   SWR,$RR,47,IAR,F       SUBTRACT UNNORM LONG REGISTER\n         OPG   SXR,$RR,55,IAR,FX        SUBTRACT EXTENDED REGISTER\nOP3T     EQU   *\n         OPG   TCH,$RSO,159,,P     TEST CHANNEL\n         OPG   TIO,$RSO,157,,P     TEST I/O\n         OPG   TRT,$SS,221,IAL1+IAL2         TRANSLATE AND TEST\n         OPG   WRD,$SI,132,,P      WRITE DIRECT\n         OPG   ZAP,$SS2,248,IAL2,D ZERO AND ADD DECIMAL\nOP3END   EQU   *\n         EJECT\n*              4-CHARACTER INSTRUCTIONS                               *\nOP4A     EQU   *\n         OPG   ACTR,$IM,$ACTR,,M\n         OPG   ANOP,$IM,$ANOP,,M\nOP4B     EQU   *\n         OPG   BALR,$RR,5          BRANCH AND LINK REGISTER\n         OPG   BCTR,$RR,6          BRANCH ON COUNT REGISTER\n         OPG   BNER,$RRM,7,X'70'   **EXTENDED BRANCH MNEMONIC**       J\n         OPG   BNHR,$RRM,7,X'D0'   **EXTENDED BRANCH MNEMONIC**       J\n         OPG   BNLR,$RRM,7,X'B0'   **EXTENDED BRANCH MNEMONIC**       J\n         OPG   BNMR,$RRM,7,X'B0'   **EXTENDED BRANCH MNEMONIC**       J\n         OPG   BNOR,$RRM,7,X'E0'   **EXTENDED BRANCH MNEMONIC**       J\n         OPG   BNPR,$RRM,7,X'D0'   **EXTENDED BRANCH MNEMONIC**       J\n         OPG   BNZR,$RRM,7,X'70'   **EXTENDED BRANCH MNEMONIC**       J\n         OPG   BXLE,$RS,135,1      BRANCH INDEX LOW OR EQUAL          J\nOP4C     EQU   *\n         OPG   CLCL,$RR,15,IAR,S370     COMPARE LOGICAL CHARACTERS LONG\n         OPG   CNOP,$ICNOP+$IB,IBNONAM+$IBSTAR1        CONDITIONAL NOP\nOP4D     EQU   *\n         AIF   (&$DEBUG).OPDIAG    SKIP DIAGNOSE IF NOT DEBUG MODE\n         OPG   DIAG,$SI,131        DIAGNOSE(EXECUT EQUIV OF DEBUG)\n.OPDIAG  ANOP\n         OPG   DROP,$IDROP+$IB,IBNONAM       DROP REGISTER\n         OPG   EDMK,$SS,223,IAL2,D EDIT AND MARK\n         OPG   GBLA,$IM,$GBLA,$ARITH,M\n         OPG   GBLB,$IM,$GBLB,$BOOL,M\n         OPG   GBLC,$IM,$GBLC,$CHAR,M\nOP4L     EQU   *\n         OPG   LCDR,$RR,35,IAR,F      LOAD COMPLEMENT LONG REGISTER\n         OPG   LCER,$RR,51,IAR,F      LOAD COMPLEMENT SHORT REGISTER\n         OPG   LCLA,$IM,$LCLA,$ARITH,M\n         OPG   LCLB,$IM,$LCLB,$BOOL,M\n         OPG   LCLC,$IM,$LCLC,$CHAR,M\n         OPG   LCTL,$RS,183,OP3,P370    LOAD CONTROL\n         OPG   LNDR,$RR,33,IAR,F      LOAD NEGATIVE LONG REGISTER\n         OPG   LNER,$RR,49,IAR,F      LOAD NEGATIVE SHORT REGISTER\n         OPG   LPDR,$RR,32,IAR,F      LOAD POSITIVE LONG REGISTER\n         OPG   LPER,$RR,48,IAR,F      LOAD POSITIVE SHORT REGISTER\n         OPG   LPSW,$RSO,130,7,P   LOAD PROGRAM STATUS WORD\n         OPG   LRDR,$RR,37,IAR,FX       LOAD ROUNDED EXTENDED ==> LONG\n         OPG   LRER,$RR,53,IAR,FX     LOAD ROUNDED LONG ==> SHORT\n         OPG   LTDR,$RR,34,IAR,F      LOAD AND TEST LONG REGISTER\n         OPG   LTER,$RR,50,IAR,F      LOAD AND TEST SHORT REGISTER\nOP4M     EQU   *\n         OPG   MEND,$IM,$MEND,,M\n         OPG   MVCL,$RR,14,IAR,S370     MOVE CHARACTERS LONG\n         OPG   MXDR,$RR,39,IAR,FX       MULTIPLY EXTENDED / LONG REG\nOP4N     EQU   *\n         OPG   NOPR,$RRM,7,X'00'   NO OPERATION\n         OPG   PACK,$SS2,242,IAL2  PACK\nOP4S     EQU   *\n         OPG   SETA,$IM,$SETA,$ARITH,M\n         OPG   SETB,$IM,$SETB,$BOOL,M\n         OPG   SETC,$IM,$SETC,$CHAR,M\n         OPG   SIOF,$RSO,156,X'10',P370      START I/O FAST\n         OPG   SLDA,$RSH,143,IAL2+IAA        SHIFT LEFT DOUBLE ALGEBRAI\n         OPG   SLDL,$RSH,141,IAL2+IAA        SHIFT LEFT DOUBLE LOGICAL\n         OPG   SRDA,$RSH,142,IAL2+IAA        SHIFT RIGHT DOUBLE ALGEBRA\n         OPG   SRDL,$RSH,140,IAL2+IAA        SHIFT RIGHT DOUBLE LOGICAL\n         OPG   STCK,$RSO,178,X'50',P370      STORE CLOCK\n         OPG   STCM,$RS,190,,S370       STORE CHARACTERS UNDER MASK\nOP4T     EQU   *\n         OPG   UNPK,$SS2,243,IAL2  UNPACK\n         AIF   (&$XXIOS).OP4TSK1   SKIP IF NO XGETS ALLOWED     CPP\n         OPG   XGET,$SPC,224,X'A0'  GENERAL INPUT              D\n.OP4TSK1 AIF   (NOT &$EXINT).OP4TSK2  SKIP IF NO XOPC'S         CPP\n         OPG   XOPC,$RSO,1         EXTENDED USER DEBUG CONTROL INSTR\n.OP4TSK2 AIF   (&$XXIOS).OP4TSK    SKIP IF NO XPUTS ALLOWED     CPP\n         OPG    XPUT,$SPC,224,X'C0'+IAL2  GENERAL OUTPUT OP           J\n.OP4TSK  ANOP\nOP4END   EQU   *\n         EJECT\n*              5-CHARACTER INSTRUCTIONS                               *\nOP5A     EQU   *\nOP5B     EQU   *\nOP5C     EQU   *\n         OPG   CSECT,$ICSECT+$IB,IBOMOP      CSECT\nOP5D     EQU   *\n         AIF   (&$DEBUG).OPNOD1    SKIP IF NOT DEBUG MODE\n         OPG   DEBUG,$IDEBUG+$IB   DEBUG FLAG SETTING OPCODE\n.OPNOD1  ANOP\n         OPG   DSECT,$IDSECT+$IB,IBOMOP+IBNENAM        DUMMY SECTION\n         OPG   EJECT,$IEJECT+$IB,IBNONAM+IBOMOP+IBMOPRCX,255 EJECT\n         OPG   ENTRY,$IENTRY+$IB,IBNONAM     ENTRY DECLARATION\n         OPG   EXTRN,$IEXTRN+$IB,IBNONAM     EXTERNAL DECLARATION\nOP5L     EQU   *\n         OPG   LTORG,$ILTORG+$IB,IBOMOP+$IBSTAR1       LTORG\nOP5M     EQU   *\n         OPG   MACRO,$IM,$MACRO,,M\n         OPG   MEXIT,$IM,$MEXIT,,M\n         OPG   MNOTE,$IM,$MNOTE,,M\nOP5N     EQU   *\n         OPG   PRINT,$IPRINT+$IB,IBNONAM+IBMOPRCX,$IBPON+$IBPGEN\nOP5S     EQU   *\n         OPG   SPACE,$ISPACE+$IB,IBNONAM+IBOMOP+IBMOPRCX,1 SPACE\n         OPG   START,$ISTART+$IB,IBOMOP      START\n         OPG   STCTL,$RS,182,3,P370    STORE CONTROL\n         OPG   STIDC,$RSO,178,X'30',P370     STORE CHANNEL ID\n         OPG   STIDP,$RSO,178,X'20',P370     STORE CPU ID\nOP5T     EQU   *\n         OPG   TITLE,$ITITLE+$IB,IBNONAM+IBMOPRCX,0   TITLE\n         OPG   USING,$IUSING+$IB,IBNONAM+$IBSTAR1      USING\n         AIF   (NOT &$XIOS).OPNOXIO          SKIP IF NO XIOS WANTED\n         OPG   XDECI,$RX,83        DECIMAL INPUT\n         OPG   XDECO,$RX,82        DECIMAL OUTPUT\n         OPG   XDUMP,$SPC,224,X'60'+IAL2     DUMP\n         AIF   (NOT &$HEXI).OPNOHXI    SKIP IF NO XHEXI\n         OPG   XHEXI,$RX,97            OP CODE FOR XHEXI\n.OPNOHXI ANOP\n         AIF   (NOT &$HEXO).OPNOHXO    SKIP IF NO XHEXO\n         OPG   XHEXO,$RX,98            OP CODE FOR XHEXO\n.OPNOHXO ANOP\n         AIF   (NOT &$XIOS).OPNOXIO  SKIP IF NO X-I/O PSEUDOS   CPP\n         OPG   XLIMD,$SPC,224,X'80'    LIMIT AREA (COMPLETION DUMP)\n         OPG   XPNCH,$SPC,224,X'40'+IAL2     PUNCH\n         OPG   XPRNT,$SPC,224,X'20'+IAL2     PRINT\n         OPG   XREAD,$SPC,224,X'00'          READ\n.OPNOXIO ANOP\n         AIF   (&$REPL EQ 0).OPNREPL        SKIP IF NOT REPLACE\n         OPG   XREPL,$SI,160       XREPL SPECIAL COMMAND\n.OPNREPL ANOP\nOP5END   EQU   *\n         SPACE 2\n*        SECOND LEVEL OFFSET TABLE - HAS POINTERS FOR EACH BEGINNING  *\n*        CHARACTER, IN TABLE DETERMINED BY LENGTH.                    *\n*   TR TABLE      0 1 2 3 4 5 6 7 8 9 A B C D E F                     *\nOPFCH1   DC      X'000204060606060606060606060606'     C\n         DC    X'060606080A0C0C0C0C0C0C0C0C0C0C0C'     D\n         DC    X'0C0C0E10101010101010101010101010'     E\n         DC    X'10101010101010101010101010101010'     F\n         SPACE 2\n*        OFFSET VALUES INTO OPCODTB ENTRY AREA                        *\nOPADS    DS    H                   BASE ADDRESS OF 2ND LEVEL OFFSET TAB\n         OPGT\n         DROP  REP,RC              CLEAN UP USINGS\n         TITLE '*** OUTPUT - SOURCE AND OBJECT LISTING ***'\n**--> CSECT: OUTPUT       PRINTED LISTING ROUTINE . . . . . . . . . . .\n*.       OUTPUT HANDLES THE FORMATTING AND PRINTING OF THE ASSEMBLY   .\n*.       LISTING FOR THE ASSIST ASSEMBLER.                            .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nOUTPUT   CSECT\n         $DBG  C0,SNAP\n         ENTRY OUINT1,OUTPT2,OUEND2\n         USING AVWXTABL,RAT        NOTE MAIN TABLE USING\n         SPACE 1\n*              LIST OF LINE/PAGE CONTROL EQUATE VALUES FOLLOWS.\n$OU#LNS  EQU   60                  MAXIMUM PRINTED LINES/PAGE\nOUH#     EQU   3                   # LINES USED BY STANDARD HEADING\n$OU#NORM EQU   $OU#LNS-OUH#        NORMAL LINES/PAGE FOR ACTIAL STMTS\n$OU#PAG1 EQU   $OU#NORM-5          # LINES FOR STMTS ON 1ST PAGE ONLY\n         SPACE 1\n**--> ENTRY: OUINT1   1   INITIALIZATION ENTRY - CALLED BEFORE PASS 1 .\n*.       OUINT1 IS CALLED TO INITIALIZE FLAG VALUES AND COUNTERS      .\n*.       USED IN OUTPUT, INCLUDING LISTING CONTROL, STATEMENT #,      .\n*.       PAGE COUNT, WITHIN-PAGE LINE COUNT, AND TITLE AREA.          .\n*.       USES DSECTS: AVWXTABL                                        .\n*.       USES MACROS: $RETURN,$SAVE                                   .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n         SPACE 1\nOUINT1   $SAVE SA=NO\n         AIF   (&$COMNT EQ 0).OUNCOM1       SKIP IF NO COMMENT CHK\n         MVC   AVMACHIN(4),AWZEROS ZERO VARIABLES(SEE IAMOP1 CSECT)\n.OUNCOM1 ANOP\n         MVI   AVPRINT,$IBPON+$IBPGEN       PRINT ON,GEN,NODATA\n         TM    AVTAGS1,AJNLIST     IS LIST ON         OR OFF\n         BO    *+8                 SKIP IF LIST IS OFF\n         OI    AVPRINT,$IBPLIST    SHOW LIST IS ON FOR LATER TEST\n         MVC   AVPRINT1,AVPRINT    COPY VALUE FOR USE DURING PASS 1\n         ZAP   OULNCNT,AWP1        SET CURRENT STMT # = 1\n         ZAP   OUPGCNT,AWP0        SET PAGE COUNT TO ZERO LASO\n         MVC   OUCOUNT,AWH1        INIT WITHIN PAGE COUNT TO 1\n         MVC   OUHEADNG,AWBLANK    BLANK OUT SPOT FOR HEADING\n*              FOLLOWING STMTS HELP AVOID WASTED 1ST PAGE LISTING.\n         LA    RE,$OU#PAG1         # LINES FOR STMTS ON 1ST PAGE ONLY\n         STH   RE,OUH#LINE         SET COUNTERSETTER TO INITIAL VALUE\n         MVI   OUHEAD1,C'0'        JUST DO DOUBLESPACE 1ST TIME\n         AIF   (NOT &$CMPRS).OUINCM         SKIP IF NO COMPRESS CODE\n         SPACE 2\n*              CMPRS OPTION INITIALIZATION&TESTING - IF ON, GET\n*              SPACE FOR OUCMPRSD BLOCK, INIT VARIABLES.\n         SPACE 1\n         TM    AVTAGS2,AJOCMPRS    IS CMPRS OPTION USED\n         BZ    OUINOCMP            NO, SO DON'T GET SPACE\n         SPACE 1\n         LA    RA,OUCMPR$L         TOTAL LENGTH OF OUCMPRSD BLOCK\n         $ALLOCH RB,RA,OUINCMOV    ACQUIRE AREA\n         USING OUCMPRSD,RB         NOTE PTR THERE\n         ST    RB,OUCMPRAD         STORE @ BLOCK FOR OUTPT2 USE\n         LA    RE,$OU#PAG1+OUH#    TOTAL # LINES FOR PAGE 1\n         STH   RE,OUCMOPAG         SET # LINES ON FIRST PAGE ONLY\n         STH   RE,OUCMLEFT         SET # LINES LEFT IN OUCMSAVE,PAGE1\n         SPACE 1\n         LA    RC,OUCMSAVE         @ 1ST BYTE OF STORAGE AREA\n         ST    RC,OUCMSTMT         SET @ SO 1ST STMT WILL BE THERE\n         NI    OUCMPHAS,255-OUCMPHSB        SHOW OUTPT2 IN PHASE 'A'\n         MVI   OUCMCCIN,C'0'       MAKE INITIAL CARRIAGE CONT D SPACE\n         MVC   OUCMBREK,=C'. '     INITIALZE SEPARATER FIELD\n         B     OUINOCMP            SKIP OVER RESET CODE\n         DROP  RB                  KILL USING\n         SPACE 1\n*              INSUFFICIENT SPACE - CANCEL CMPRS OPTION NOW.\nOUINCMOV NI    AVTAGS2,255-AJOCMPRS         REMOVE CMPRS FLAG\nOUINOCMP EQU   *\n         SPACE 1\n.OUINCM  ANOP\nOUINRET  $RETURN SA=NO\n         EJECT\n**--> ENTRY: OUTPUT2      PRINT 1 STATEMENT,WITH CODE AS NEEDED,ERROR .\n*.       OUTPT2 PRINTS 1 STATEMENT, WITH ANY ERROR MESSAGES NEEDED,   .\n*.       PRINTS TITLES AND HEADINGS WHEN REQUIRED, PERFORMS PAGE AND  .\n*.       LINE COUNTING, MAINTAINS LISTING CONTROL STATUS, AND KEEPS   .\n*.       COUNTS OF NUMBER OF STATEMENTS FLAGGED, TOTAL # ERRORS,      .\n*.       TOTAL # WARNING MESSAGES.                                    .\n*.       ENTRY CONDITIONS                                             .\n*.  RB = PRIMARY CALL TYPE CODE                                       .\n*.     = 0    ($OUMACH) MACHINE INSTRUCTIONS                          .\n*.     = 2    ($OUCONS) CONSTANTS,CNOPS,ETC. PRINT LOCATION COUNTER,CO.\n*.     = 4    ($OULIST) - LISTING CONTROL - EJECT,SPACE,PRINT,TITLE   .\n*.     = 6    ($OUCOMM) - COMMENTS,ETC.-DO NOT HAVE LOCATION COUNTER  .\n*.  RC = AN INFORMATION ADDRESS OF SOME TYPE                          .\n*.     = @ OBJECT CODE (RB=0,2)                                       .\n*.     = @ # LINES TO SPACE (RB=4,RE=0)                               .\n*.     = @ PRINT CONTROL CODE BYTE (RB=4,RE=2) I.E. PRINT             .\n*.     = @ TITLE CODE (RB=4,RE=4)                                     .\n*.  RD = #-1 OF BYTES OF OBJECT CODE OR TITLE                         .\n*.  RE = SECONDARY CODE OR ADDRESS                                    .\n*.     = SECONDARY CODE FOR LISTING CONTROL OPERATIONS                .\n*.     = 0    SPACE OR EJECT                                          .\n*.     = 2    PRINT                                                   .\n*.     = 4    TITLE                                                   .\n*.       USES DSECTS: AVWXTABL,ICBLOCK,RCODBLK,RSBLOCK,RSCBLK,REBLK   .\n*.       USES MACROS: $AL2,$PRNT,$RETURN,$SAVE,$SERR                  .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n         EJECT\n* * * * * REGISTER USAGE FOR OUTPT2 * * * * * * * * * * * * * * * * * *\n*   RW = CURRENT VALUE OF OUCOUNT. IF =1,NEW HEADING NEEDED           *\n*   RX = BASE REGISTER                                                *\n*   RY = UNUSED AT PRESENT                                            *\n*   RZ = @ RSBLOCK BELONGING TO STATEMENT BEING PROCESSED.            *\n*   R14= INTERNAL LINK REGISTER.  LOCAL WORK REGISTRE.                *\n*   R15= LOCAL WORK REGISTER.                                         *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nOUTPT2   $SAVE RGS=(R14-R6),SA=NO           LEAVE R15 AS IS\n         LR    RX,R15              MOVE @ OUTPT2 OVER FOR NEW BASE\n         DROP  R15                 REMOVE OLD USING\n         USING OUTPT2,RX           NOTE NEW USING\n         SPACE 1\n*              COMMON INITIALIZATION. MAKE PROCESSOR CHOICE, BASED    *\n*        ON CONTENTS OF REG RB. PRINT IF PRINT ON, OR INSTRUCTION IS  *\n*        A LISTING CONTROL, OR ANY STMT WITH AN ERROR IN IT.          *\n         SPACE 1\n         L     RZ,AVRSBPT          GET POINTER TO RSBLOCK\n         USING RSBLOCK,RZ          NOTE POINTER\n         LH    RW,OUCOUNT          GET WITHIN PAGE COUNT\n         MVC   OUTLINE(OUTLEN),AWBLANK       BLANK OUT LEFT HAND SIDE\n         AIF   (NOT &$MACROS).OUNGEN        SKIP IF NO MACRO CODE\n         SPACE 1\n         TM    RSBFLAG,$RSBGENR    WAS THIS GENERATED STMT\n         BZ    OUNGEN              NO, NORMAL, SKIP\n         MVI   OUSOURC-1,C'+'      MARK OUTPUT AS GENERATED\n         TM    AVPRINT,$IBPGEN     IS PRINT GEN: SHOULD WE PRINT\n         BO    OUNGEN              PRINT GEN-DEFINITELY PRINT\n*              FOLLOWING STMTS ALLOW GENERATED PRINT STMTS TO BE USED.\n*        WARNING: EXTENSION FROM ASMBLER F.\n         CH    RB,=AL2($OULIST)    IS IT LISTING CONTROL STMT\n         BNE   OUTRETE             NO, NOT LISTING CONTROL - GO CHK\n         CH    RE,=H'2'            WS IT ACTUALLY  PRINT\n         BNE   OUTRETE             NO, SO IGNORE IT\n*              YES, FALL THRU AND DO IT\nOUNGEN   EQU   *                   SKIP HERE IF NOT GEN'D STMT\n         SPACE 1\n.OUNGEN  ANOP\n         LH    R14,OUJUMP1(RB)     GET PRIMARY TUPE OF STATEMENT\n         TM    AVPRINT,$IBPON+$IBPLIST SET CC=3 IF PRINT ON AND LIST\nOUTJ1    BAL   R14,OUTJ1(R14)      GO TO RIGHT CODE, WITH CC SET\n*              IF SPECIFIC STMT TYPE CODE DOESN'T WANT TO PROCESS IT,\n*              IT CAN RETURN HERE VIA A BCR NO,R14, AND STMT WON'T BE\n*              PRINTED UNLESS IT HAS ERRORS IN IT.\n         SPACE 1\nOUTRETE  TM    RSBFLAG,$REBX+$RSBMERR  ARE THERE ANY ERRORS/ERR RECRD\n         BZ    OUTRETA             XKIP IF NONE,PRINT STMT IF SO\n         EJECT\n*              OUTSTMT - FORMAT AND PRINT STATEMENT,WITH ERRORS       *\n*              NORMALLY ENTERED AFTER INDIVIUDAL TYPE PROCESSING.\nOUTSTMT  EQU   *                   COME HERE IF STMT SHOULD BE PRINTED\n         AIF   (NOT &$MACROS).OUNMAC1       SKIP IF NO MACROS ALLOWED\n         TM    RSBFLAG,$RSBNPNN    WAS THIS NOT TO BE NUMBERED\n         BO    OUTSTMTN            NO NUMBER - SKIP EDITING\n.OUNMAC1 ANOP\n         SPACE 2\n         MVC   OUDSTMNT-1(6),AWEP6     COPY THE EDIT PATTERN\n         ED    OUDSTMNT-1(6),OULNCNT         FORMAT STATEMENT #\n*              GET 1ST(OR ONLY) CARD-IMAGE IN PLACE FOR PRINTING      *\n*              NEXT STMT ASSUMES 1ST CARD OF SEVERAL IS 71 BYTES LONG.\nOUTSTMTN LA    R1,RSOL1-1          NORMAL LENGTH-1, CLEAR FOR INSERT\n         L     R2,AVRSCPT          GET @ RSCBLK,IF IT EXISTS\n         USING RSCBLK,R2           NOTE USING,FOR ANY SECTION REQUIRING\n         CLI   RSBNUM,1            WAS THERE ONLY 1 CARD\n         BNE   OUTC1B              NO, SKIP, R1 ALREADY SET OK\nOUTC1A   IC    R1,RSBLENG          GET THE LENGTH OF RSBLOCK, 1 SOURCE\n         LA    R1,(255-RSB$L)(R1)  SUBTRACT LENGTH, LOW-ORDER BYTE-WISE\n         MVC   OUSOURCE,AWBLANK+9           BLANK STMT, CONT/SEQNO\n         SPACE 1\n         AIF   (NOT &$MACROS).OUNMAC2  SKIP IF NO MACRO\n         TM    RSBFLAG,$RSBMERR    SPECIAL ERROR FORMT STMT\n         BZ    OUTC1B              NO, SO SKIP SPECIAL FORMATTING\n         SPACE 1\n*              SPECIAL ERROR MESSAGE - ISSUED BY MACRO PROCESSOR -\n*              STMT IMAGE IS CONSTRUCTED TEXT OF ERROR MESSAGE.\n*              **NOTE** THESE ARE NOT CURRENTLY COUNTED AS ERRORS\n         STC   R1,OURSBMOV+1       PUT L-1 INTO MOVE FOR MESSAGE\n         MVC   OUTLINE+1(L'OUTERRAS-1),OUTERRAS+1  ERROR PTR ON LEFT\n         MVC   OUCONSQ+1(8),OUTEREND+1 ERROR PTE ON RIGHT\nOURSBMOV MVC   OUTLINE+L'OUTERRAS($),RSBSOURC   MOVE MESSAGE IN\n         B     OUTSPRNT            GO PRINT WITHOUT FURHTER ADO\n.OUNMAC2 ANOP\n         SPACE 1\nOUTC1B   STC   R1,*+5              STORE LENGTH-1 INTO NEXT INSTR\n         MVC   OUSOURC($CHN),RSBSOURC        MOVE VARIABLE LENGTH OVER\n         SPACE 1\n*              PLACE CONTINUATION SEQNO IN IF NEEDED                  *\n         TM    RSBFLAG,$RSCX       DO WE HAVE CONT/SEQN\n         BZ    OUTSPRNT            NO,DON'T NEED CONT/SEQN\n         MVC   OUCONSQ,RSCONSQ     MOVE FIELD IN\n         SPACE 1\nOUTSPRNT EQU   *                   POINT FOR PRINTING 1ST /ONLY CARD\nOUTSPRNU BAL   R14,OUTLNSA         HAVE THE STMT PRINTED\n         CLI   RSBNUM,1            WAS THERE ONLY 1 CARD(HOPE)\n         BNE   OUTSCON             NO(GROAN)-MULTIPLE CARDS IN STMT\n         TM    RSBFLAG,$REBX       WERE THERE ERRORS\n         BNZ   OUTERR              BRANCH IF ERRORS(UNFORTUNATE)\n         SPACE 1\nOUTRETA  STH   RW,OUCOUNT          SAVE WITHIN PAGE COUNT\n         AIF   (NOT &$MACROS).OUNMAC3       SKIP IF NO MACROS\n         TM    RSBFLAG,$RSBNPNN    SEE IF SHOULDN'T INCRE STMT #\n         BO    OUTRETAA            SKIP OVER STMT# ADD INSTR(S)       J\n.OUNMAC3 AP    OULNCNT,AWP1        BUMP STMT # TO # OF NEXT ONE\n         AIF   (NOT &$XREF).NOXRF10                                   A\n         AP    AVXRLNCN,AWP1       INCREMENT ADDITIONAL LINE COUNTER  A\n.NOXRF10 ANOP                                                         A\nOUTRETAA EQU   *                   BRANCH HERE BEFORE EXIT            J\n         $DBG  C0,*                JUST TRACE ON EXIT\nOUTRET   $RETURN RGS=(R14-R6),SA=NO\n         EJECT\n* * * * * OUTSCON - HANDLE PRINTING OF CONTINUATION CARDS.SET UP OFFSE*\n* * * * * REGISTER USAGE                                              *\n*   R1 = CURRENT COUNT OF # CARDS REMAINING TO BE PRINTED(INIT-RSBNUM)*\n*   R2 = @ CURRENT RSCBLK SECTION BEING PROCESSED                     *\n*   RD = CURRENT TOTAL OFFSET. USED TO EXTRACT CARDS,SET ERROR MESSGS *\n*              INIT.  LOOP THOURHG OUTSCON2 FOR EACH CONT/CARD. SET   *\n*              UP OFFSETS IN OUTOFFS FOR USE IN ERROR POINTERS.       *\n         SPACE 1\nOUTSCON  SR    R1,R1               CLEAR FOR INSERTION\n         IC    R1,RSBNUM           GET TOTAL # OF CARDS\n         LA    RC,OUTOFFS(R1)      GET @ LAST BYTE FOR OFFSETS\n         MVI   0(RC),RSB$L         MOVE BEGINNING OFFSET IN\n         SR    RD,RD               CLEAR FOR INSERT\n         IC    RD,RSCILEN          GET LENGTH OF 1ST CARDIMAGE\n         LA    RD,RSB$L(RD)        INCREMENT LENGTH BY 1ST OFFSET\n         STC   RD,OUTOFFS-1(R1)    STORE IN APPROPRAITE PART OF OUTOFFS\n         BCTR  R1,0                DECREMENT # CARDS LEFT TO DO\n         MVC   OUTLINE,AWBLANK     BLANK WHOLE LINE\n         SPACE 1\nOUTSCON2 LA    R2,RSC$LEN(R2)      BUMP RSCB POINTER TO NEXT FIELD\n         LA    RC,RSBLOCK(RD)      GET @ NEXT SOURCE CARD ELEMENT\n         SR    RB,RB               CLEAR FOR INSERT\n         IC    RB,RSCILEN          GET LENGTH OF NEXT CARD\n         AR    RD,RB               ADD TO TOAL OFFSET LENGTH\n         STC   RD,OUTOFFS-1(R1)    STORE NEXT OFFSET INTO LIST\n         BCTR  RB,0                DECREMENT FOR LENGTH-1\n         STC   RB,*+5              SAVE INTO MVC\n         MVC   OUSOURC+15($CHN),0(RC)        MOVE CARD IMAGE OVER\n         MVC   OUCONSQ,RSCONSQ     MOVE CONT/SEQNO OVER\n         BAL   R14,OUTLNSA         HAVE STMT PRINTED\n         STC   RB,*+5              PUT LENGTH-1 INTO NEXT MVC\n         MVC   OUSOURC+15($CHN),AWBLANK      BLANK OUT PART OF LINE USE\n         BCT   R1,OUTSCON2         LOOP UNTIL WHOLE STATEMENT FINISHED\n         SPACE 1\n         TM    RSBFLAG,$REBX       DO ERRORS EXIST\n         BZ    OUTRETA             NO ERRORS - QUIT\n         EJECT\n* * * * * OUTERR - PRINT ERROR MESSAGES AND SCAN POINTERS             *\n*   R2 = # ERROR CODE/SCAN POINTER PAIRS (= 1 TO $ERREBMX).           *\n*   RE = CUMULATIVE COUNT OF ERRORS(NOT WARNINGS) THOURGHOUT SECTION. *\nOUTERR   L     RD,AVREBPT          GET POINTER TO ERRORS\n         USING REBLK,RD            NOTE USING\n         LH    RE,AVNERRA          GET ACTUAL # ERRORS\n         LH    R14,AVSTMTER        GET TOTAL # STMT ERRORS\n         LA    R14,1(R14)          INCREMENT TO SHOW 1 MORE STMT FLAGD\n         STH   R14,AVSTMTER        STORE BACK UPDATED POINTER\n         SR    R2,R2               CLEAR FOR INSERTION\n         IC    R2,REBLN            GET TOTAL ELNGTH OF ERROR BLOCK\n         SRL   R2,1                DIVIDE BY TO=#ERRORS\n         SR    R1,R1               CLEAR FOR CONSTANT INSERTS\n         SPACE 1\nOUTERR1  IC    R1,REBSCN           GET SCAN POINTER\n         CLI   RSBNUM,1            WAS THERE ONLY 1 STATEMENT\n         BE    OUTERR5             SKIP OVER MULTIPLE SECTION IF SO\n         SPACE 1\n*              SECTION FROM HERE TO OUTERR5 REQUIRED FOR MULT CARDS.  *\n         SR    RC,RC               CLEAR FOR INSERT\n         IC    RC,RSBNUM           GET NUMBER OF CARDS\n         SR    R0,R0               CLEAR FOR INSERTS\nOUTERR3  IC    R0,OUTOFFS-1(RC)    GET LIMIT SCAN POINTER FOR CARD\n         CR    R0,R1               COMPARE WITH ERROR POINTER\n         BH    OUTERR4             BRANCH OUT IF CORRECT SPOT FOUND\n         BCT   RC,OUTERR3          LOOP FOR # OF CARDS\n         B     OUTERR5             NOT FOUND-WILL BE TOO HIGH\nOUTERR4  IC    R0,OUTOFFS(RC)      GET BEGINNING SCAN POINTER\n         SR    R1,R0               GET OFFSET FROM CARD BEGINNING\n         LA    R1,RSB$L(R1)        ADD SCAN OFFSET FROM RSBLOCK\n         IC    R0,RSBNUM           GET # OF CARDS\n         CR    R0,RC               SEE IF SAME,I.E. IN 1ST CARDIMAGE\n         BE    OUTERR5             SKIP OVER-ITS IN 1ST CARD,SO OK\n         LA    R1,15(R1)           CONTINUATION CARD-BUMP POINTER\n         SPACE 1\n*              FOLLOWING CONCLUDES PROCESSING FOR SINGLE CARD STMTS   *\nOUTERR5  LA    RC,OUTEOFF(R1)      GET @ WHERE $ SHOULD GO\n         LA    R0,OUTEREND         GERT LAST POSSIBLE SCAN POINTER\n         CR    R0,RC               MAKE SURE POINTER NOT BEYOND END\n         BNL   *+6                 SKIP IF OK\n         LR    RC,R0               USE LAST POSSIBLE OFFSET @\n*              RC = @ FOR $ SCAN POINTER AT THIS POINT.               *\n         IC    R1,REBERR           GET THE ERROR CODE\n         AIF   (&$OPTMS GT 2).OUOP1         SKIP IF BIG MEMORY\n*              SMALL SPACE==> NO PTRS, JUST MULT CODE BY 3/2.\n         LR    RB,R1               MOVE ERROR CODE OVER\n         SRL   RB,1                ITS EVEN NUMBER, SO DIVIDE BY 2\n         AR    R1,RB               = 3/2 CODE, DESIRED NUMBER\n         LA    RB,OUERRMS-3-1(R1)  @-1 OF 3BYTE ERROR NUMBER\n         AGO   .OUOP2\n.OUOP1   ANOP\n         LH    RB,OUERRPT(R1)      GET OFFSET TO ERROR MESSAGE\n         LA    RB,OUERRMS(RB)      GET ACTUAL @ ERROR MESSAGE\n.OUOP2   ANOP\n*              INCREMENT ERROR OR WARNING MESSAGE TOTAL COUNT.\n         LA    R15,1               SET UP FOR ERROR-WARNING INC\n         CLI   1(RB),C'0'          WAS ERR # FROM 000-099 (WARNING)\n         BE    *+10                YES, BRANCH IF IT IS A WARNING\n         AR    RE,R15              INCREMENT # ERRORS (AVNERRA)\n         B     *+12                BRANCH OVER WARNING CODE\n         AH    R15,AVNWARN         INCREMENT # WARNING MESSAGES\n         STH   R15,AVNWARN         PUT # WARNINGS BACK\n         SPACE 1\n*              SET UP MESSAGE, SCAN POINTER. PRINT MESSAGE.\n         AIF   (&$OPTMS GT 2).OUOP3         SKIP IF LARGE MEMORY\n         MVC   OUTERMS(3),1(RB)    MOVE ERROR # INTO MSG\n         AGO   .OUOP4              SKIP REGUALR CODE\n.OUOP3   ANOP\n         IC    R1,0(RB)            GET LENGTH-1 OF ERROR MESSAGE\n         STC   R1,OUTERR6+1        SAVE INTO BLANKING MVC\n         STC   R1,*+5              STORE TO MOVE MESSAGE INTO BUFFER\n         MVC   OUTERMS($CHN),1(RB) MOVE ERROR MESSAGE INTO BUFFER\n.OUOP4   ANOP\n         MVI   0(RC),C'$'          PLACE SCAN POINTER IN\n         LA    RA,OUTERROR         SET UP @ ERROR LINE\n         BAL   R14,OUTLNS          HAVE ERROR MESSAGE PRINTED\n         SPACE 1\n         AIF   (&$OPTMS LE 2).OUOP5         SKIP IF SMALL MEMORY\nOUTERR6  MVC   OUTERMS($CHN),OUBLDASH       RESTORE BLANKS-DASHES\n.OUOP5   ANOP\n         MVI   0(RC),C'-'          FILL IN DASH WIPED BY $\n         LA    RD,2(RD)            INCREMENT ERROR BLOCK PTR\n         BCT   R2,OUTERR1          LOOP FOR NUMBER OF ERRORS\n         SPACE 1\n*              UPDATE ERROR COUNT & CHECK FOR EXCEEDING LIMIT.\n         STH   RE,AVNERRA          STORE UPDATED ERROR COUNT\n         CH    RE,AVNERR           COMPARE TO ERROR LIMIT\n         BNH   OUTRETA             IF STILL OK,BRANCH\n         OI    AVTAGS1,AJNLOAD     FLAG NOLOAD,NO MORE OBJECT CODE\n         B     OUTRETA             GO RETURN\n         EJECT\n* * * * * RB=$OUMACH - FORMAT LEFT-SIDE FOR MACHINE INSTRUCTIONS  * * *\nOUMACH   EQU   *\n         BCR   NO,R14              RETURN UNLESS PRINT ON AND LIST\n         L     R14,AVRCBPT         GET # RCB TO PICK UP INFO\n         USING RCODBLK,R14         NOTE USING\n         UNPK  OULOC(7),RCLOC(4)   UNPACK LOCATION COUNTER\n         MVI   OULOC+6,C' '        BLANK OT EXTRA BYE\n         DROP  R14                 LOCATION COUNTER ALL THAT WAS NEEDED\n         USING ICBLOCK,RC          NOTE INSTRUCTION CODE BLOCK\n*              RD = LENGTH-1 OF INSTRUCTION = 1,3,5.                  *\n         UNPK  OUOPR1R2(5),ICBOPR1R(3)       GET OPCODE-R1-R2 FIELD\n         MVI   OUOPR1R2+4,C' '     BLANK OUT EXTRA BYTE\n         C     RD,AWF3             CHECK LENGTH-1 AND SET CC\n         BL    OUMACH1             ONLY 2 BYTE INSTRUCTION-QUIT\n         UNPK  OUOPN1(5),ICBOPN1(3)          UNPACK 1ST BASE-DISP\n         MVI   OUOPN1+4,C' '       BLANK OUT END BYTE\n         BE    OUMACH1             IF RD=3,==> 4 BYTE INST-QUIT\n         UNPK  OUOPN2(5),ICBOPN2(3)          6-BYTE INST.UNPK 2ND B-D\n         MVI   OUOPN2+4,C' '       BLANK OUT END BYTE\n         SPACE 1\n*              OBJECT CODE ALL UNPACKED - NOW CHECK FOR INSTRUCT ADDRS*\nOUMACH1  TM    ICBFLAG,$ICBEA1     WAS THERE A 1ST INST ADDR\n         BZ    OUMACH2             NO,DON'T LOOK FOR ONE\n         UNPK  OUEA1+1(6),ICBEA1+1(4)        GET 5 BYTES OF ADDRESS OVE\nOUMACH2  TM    ICBFLAG,$ICBEA2     WAS THERE A 2ND ADDRESS TO BE PRINTE\n         BZ    OUMACH3             NO THERE WASN'T,BRANCH\n         UNPK  OUEA2+1(6),ICBEA2+1(4)        GET 5 BYTES OF ADDR\nOUMACH3  TR    OUTLINE+1(OUTLENM),AWTHEX3    TRANSLATE TO FINISH\n         B     OUTSTMT             GO HAVE STATEMENT PRINTED OUT\n         SPACE 1\n* * * * * RB=$OUCONS - FORMAT LEFT-SIDE WITH LOC,CONSTANT IF NEEDED * *\nOUCONS   EQU   *\n         BCR   NO,R14              RETURN IF NOT PRINT ON, LIST\n         L     R14,AVRCBPT         GET @ RCB FOR INFO THERE\n         USING RCODBLK,R14         NOTE POINTER\n         UNPK  OULOC(7),RCLOC(4)   CONVERT THE LOCATION COUNTER\n         MVI   OULOC+6,C' '        BLANK OT EXTRA BYE\n         DROP  R14\n         LTR   RD,RD               IS LENGTH-1 <0,WHICH ==> NO CONSTANT\n         BM    OUCONS2             NO CONSTANT - TRANSLATE LOCCNTR&QUIT\n         C     RD,AWF7             IS LENGTH-1 > 7\n         BNH   *+8                 SKIP NEXT IF WITHIN RANGE\n         LA    RD,7                USE ONLY 1ST 8 BYTES OF CONSTANT\n         SPACE 1\n         LA    R14,0(RD,RD)        GET 2*(L-1 OF CODE) FOR UNPACK LENGT\n         LA    R15,OUCONST(R14)    SAVE @ LAST UNPACKED BYTE\n         SLL   R14,4               SHIFT OVER INTO 1ST NIBBLE OF LOW BT\n         AR    RD,R14              PUT LENGTHS INTO LOW-ORDER BYTE\n         STC   RD,*+5              STORE INTO UNPK INSTRUCTION\n         UNPK  OUCONST($CHN),0($CHN,RC)      CONVERT CONST CODE\n         UNPK  1(1,R15),0(1,R15)   DUPLICATE AND REVERSE NIBBLES\n         OI    0(R15),X'F0'        MAKE DIGIT PRINTABLE\n         OI    1(R15),X'F0'        FIX UP LAST BYTE\nOUCONS2  TR    OUTLINE+1(24),AWTHEX3         CONVERT OT HEX OUTPUT\n         B     OUTSTMT             GO PRINT PUT STATEMENT\n         EJECT\n* * * * * RB=$OULIST - LISTING CONTROL - SPACE,EJECT,PRINT,TITLE  * * *\nOULIST   EQU   *                   \"\"=3 IF PRINT ON, LIST OPTION\n         LH    R15,OUJUMP2(RE)     GET SECONDARY BRANCH CODE\nOUTJ2    B     OUTJ2(R15)          BRANCH TO STMT TYPE, DON'T CHANGE CC\n         SPACE 1\n* * * * * OUSPEJ - PROCESS SPACE OR EJECT,USING # OF LINES TO BE SPACD*\n*              AT THIS PT, CC MUST =3, ELSE NO SPACING DONE.\nOUSPEJ   BCR   NO,R14              QUIT, (RETURN TO OUTRETE\n         LA    RD,1                SET COUNTER CLEAR\n         LA    RA,AWBLANK          @ BLANK LINE\n         CLI   0(RC),255           REAL EJECT ?\n         BE    OUSPEJ1A            YES, GO DO THE EJECT\n         IC    RD,0(RC)            GET # OF LINES TO BE PSACED\nOUSPEJ1  SR    RW,RD               GET # LINES LEFT ON THIS PAGE\n         BP    OUSPEJ2             SKIP SOME LEFT - PRINT BLANK LINES\n         LCR   RD,RW               # BLANKS TO BE PRINTED AFTER TITIL\n         BZ    OUTITL2             IF NO BLANK LINES, JUST RESET TITLE\nOUSPEJ1A BAL   R14,OUTLNSTI        HAVE TITLE LINES PRINTED\n         B     OUSPEJ1             LOOP-BE SAFE FOR PRINT 200 ETC\nOUSPEJ2  BAL   R14,OUXPRNT         PRINT 1 BLANK LINE\n         BCT   RD,OUXPRNT          GO PRINT BLANK LINES\n         B     OUTRETA             GO RETURN\n         SPACE 1\n* * * * * OUPRINT - PROCESS PRINT INSTRUCTION. RC = @ CONTROL BYTE    *\nOUPRINT  MVC   AVPRINT,0(RC)       MOVE PRINT CONTROL BYTE OVER\n         B     OUTRETE             NOT ON,GO CHECK FOR ERRORS\n         SPACE 1\n* * * * * OUTITLE - BRING IN NEW TITLE,FLAG TITLE EXISTS,PRINT IF ON. *\nOUTITLE  MVC   OUHEADNG,AWBLANK    BLANK THE HEADING OUT\n         STC   RD,*+5              STORE LENGTH-1 OF NEW TITLE INTO MVC\n         MVC   OUHEADNG($CHN),0(RC)          MOVE NEW HEADING INTO FIEL\nOUTITL2  LA    RW,1                SET COUNT SO WILL CREATER HEADER NXT\n         B     OUTRETE             GO MAKE SURE THERE WAS NO ERROR\n         SPACE 2\nOUCOMM   EQU   *                   COME HERE FOR COMMENTS, SPEC ERRS\n         BCR   NO,R14              PRINT OFF/NOLIST - RETURN\n         B     OUTSTMT             PRINT LIST AND ON - GO PRINT STMT\n         EJECT\n**--> INSUB: OUTLNSA/OUTLNS  PRINT 1 LINE (WITH HEADING IF NEEDED)+ + +\n*+       PRINTS A 121 BYTE LINE, DECREMENTS REMAINING LINE COUNT.     +\n*+       ENTRY CONDITIONS                                             +\n*+  RA = @ 121-BYTE LINE TO BE PRINTED (OUTLNS ONLY).                 +\n*+  RW = LINE COUNT REMAINING.  IF = 1, WILL PRODUCE HEADING.         +\n*+  R14= RETURN @ TO CALLING SECTION OF CODE.                         +\n*+  + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +\n         SPACE 1\nOUTLNSA  LA    RA,OUTLINE          ENTRY FOR MOST COMMON @\nOUTLNS   BCT   RW,OUXPRNT          DECREMENT REMAINING, BRANCH IF OK\n         SPACE 1\n*              A HEADING AND PAGE SKIP ARE REQUIRED IF FALLS THRU HERE.\nOUTLNSTI LR    RW,RA               SAVE ORIG LINE @ PTR INTO RW\n         LR    R15,R14             SAVE THE ORIGIANL RETURN @ IN R15\n         SPACE 1\n         AP    OUPGCNT,AWP1        INCREMENT PAGE COUNT\n         MVC   OUPCNT,AWEP4        MOVE EDIT PATTERN OVER\n         ED    OUPCNT,OUPGCNT      EDIT PAGE COUNT OVER\n         LA    RA,OUHEAD1          SHOW @ 1ST HEADING (TITLE)\n         BAL   R14,OUXPRNT         PRINT IT\n         LA    RA,OUHEAD2          SHOW @ 2ND HEADNING\n         BAL   R14,OUXPRNT         HAVE IT PRINTED\n         SPACE 1\n         LR    RA,RW               RESTORE OLD LINE @\n         LR    R14,R15             RESTORE OLD RETURN @\n         SPACE 1\n         LH    RW,OUH#LINE         GET # LINES LEFT TO DO\n         MVI   OUHEAD1,C'1'        MAKE SURE SET FOR PAGE SKIP\n         MVC   OUH#LINE,=AL2($OU#NORM)      SET COUNTERSETTER NORMAL\n*              FALL THRU INTO OUXPRNT TP PRINT STMT ITSELF.\n         SPACE 1\n**--> INSUB: OUXPRNT    LOW-LEVEL PRINT ROUTINE- 121-BYTE LINE  + + + +\n*+       ROUTINE PRINTS 1 LINE (NORMAL), OR ELSE BRANCHS TO CMPRS     +\n*+       OPTION CODE TO SAVE/PRINT 2 STMTS PER LINE, IF CMPRS CODE    +\n*+       EXISTS AND USER SPECIFIES THE OPTION.                        +\n*+       ENTRY CONDITIONS                                             +\n*+  RA = @ 121-CHARACTER LINE TO BE PRINTED                           +\n*+  R14= RETURN @ TO CALLING SECTION OF CODE.                         +\n*++ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +\n         SPACE 1\nOUXPRNT  EQU   *                   ENTRY FOR PRINTING OR SAVING\n         AIF   (NOT &$CMPRS).OUXCM1         SKIP IF NO CMPRS CODE\n         TM    AVTAGS2,AJOCMPRS    IS CMPRS OPTION IN EFFECT\n         BO    OUXCMINT            YES, GO TO PROCESS NEW STMT\n         SPACE 1\n.OUXCM1  ANOP\n         $PRNT 0(RA),121           PRINT 1 NORMAL LINE\n         BCR   Z,R14               RETURN IF NO OVERFLOW\n         OI    AVTAGS2,AJOASTOP    RECORDS OVER-SHOW FLAG FOR STOPPING\n         BR    R14                 RETURN TO CALLING SECTION.\n         AIF   (NOT &$CMPRS).OUXCM2         SKIP IF NO CMPRS OPTION\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*              CMPRS OPTION PROCESSING - 2 STMTS/LINE                 *\n*   THIS SECTION PERFORMS ALL MANIPULATION AND PRINTING REQUIRED TO   *\n*   PRODUCE A LISTING IN WHICH THE FIRST HALF OF APPROX. 120 STMTS    *\n*   IS PRINTED ON THE LEFT SIDE OF A PAGE, AND THE OTHER HALF ON THE  *\n*   OTHER SIDE, THUS REDUCING THE LINES PRINTED BY THE ASSEMBLER BY   *\n*   APPROXIMATELY 1/2.  IT CONSISTS OF THE FOLLOWING STEPS:           *\n*   INITIALIZATION CODE: OUXCMINT : CONVERTS NONBLANK CARRIAGE        *\n*        CONTROL LINES TO BLANK LINES FOLLOWED BY ACTUAL LINES.       *\n*        ALSO SAVES REGISTERS WHICH WILL BE MODIFIED BY THIS SECTION. *\n*   PHASE 'A' CODE :  ENTERED FOR EACH LINE UNTIL ENTIRE LHS OF PAGE  *\n*        IS STORED, THEN SETS FLAGS FOR PHASE 'B'.                    *\n*   PHASE 'B' CODE : OUXCMB : BUILD AND PRINT LINE CONSISTING OF      *\n*        ONE STMT SAVED DURING PHASE 'A' AND THE LINE JUST GIVEN.     *\n*        WHEN ALL SAVED STMTS HAVE BEEN PRINTED, RESET TO PHASE 'A'.  *\n*        **NOTE** THIS SECTION IS ALSO USED FROM OUEND2 ENTRY.        *\n*              REGISTER USAGE IN THIS SECTION                         *\n*   RA = @ INCOMING LINE TO BE PRINTED.                               *\n*   RB = @ CMPRS WORKAREA (OUCMPRSD DSECT)                            *\n*   RC = @ NEXT EMPTY STMT SLOT, NEXT TO BE PRINTED / WORK REG.       *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n**--> INSUB: OUXCMINT   ENTRY POINT FOR CMPRS HANDLING  + + + + + + + +\n*        INITIAL SECTION - CHECK FOR NONBLANK CARRIAGE CONTROL.       +\n*        ENTRY CONDTIONS           (ENTIRE SECTION)                   +\n*   RA = @ 121-BYTE LINE IMAGE FOR OUTPUT  (OUSTMTIM DSECT)           +\n*   R14= RETURN @ TO CALLING SECTION OF CODE                          +\n*        *NOTE* MODIFIES NO REGISTERS, DOES USE AVDWORK1&AVDWORK2.    +\n*        NAMES: OUXCM---                                              +\n*+  + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +\n         SPACE 1\n         USING OUSTMTIM,RA         NOTE DSECT FOR CONVENIENCE\nOUXCMINT STM   RA,RC,AVDWORK1      INTO AVDWORK1,AVDWORK2 D'S\n         CLI   OUSTCC,C' '         WAS CARRIAGE CONTROL NORMAL ' '\n         BE    OUXCMPRT            YES, DON'T NEED DO FIXUP-BRANHC\n         SPACE 1\n*              NONBLANK CC - INSERT BLANK LINE, SAVING/RESTORING REGS.\n         ST    R14,AVDWORK2+4      SAVE INTO TEMPORARY AREA\n         LA    RA,AWBLANK          SHOW @ BLANK LINE\n         BAL   R14,OUXCMPRT        CALL INTERIOR SECTION\n         L     RA,AVDWORK1         RESTORE ORIG LINE @\n         L     R14,AVDWORK2+4      RESTORE REAL RETURN @\n         SPACE 1\n*              OUXCMPRT - GET WORKAREA @, CHOOSE CURRENT PHASE A,B\nOUXCMPRT L     RB,OUCMPRAD         GET @ CMPRS CONTROL BLOCK\n         USING OUCMPRSD,RB         NOTE THE POINTER\n         TM    OUCMPHAS,OUCMPHSB   IS IT PHASE B (PRINTOUT)\n         BO    OUXCMB              YES, SO GO TO PRINT OUT 2 STMTS\n         EJECT\n*              PHASE 'A' - SAVE STMT IMAGES UNTIL AREA FULL.\n         L     RC,OUCMSTMT         GET @ NEXT SLOT FOR STMT SEGMENT\n         MVC   0(OUCM$L1,RC),OUSTP1         GET 1ST SECTION OF STMT\n         MVC   OUCM$L1(OUCM$L2,RC),OUSTP2   2ND STMT SECTION (SOURCE)\n         LA    RC,OUCM$LT(RC)      INCREMENT SLOT PTR TO NEXT ONE\n         ST    RC,OUCMSTMT         STORE UPDATED SLOT PROINTER BACK\n         SPACE 1\n         LH    RC,OUCMLEFT         GET # EMPTRY SLOTS LEFT THIS TIME\n         S     RC,AWF1             DECREMENT # EMPTRY SLOTX\n         STH   RC,OUCMLEFT         RESTORE UPDATED # SLOTS\n         BP    OUXCMRET            IF SLOTS LEFT, GO TO EXIT CODE\n         SPACE 1\n*              NO EMPTY SLOTS LEFT FOR STMTS.  RESET VARIABLES AND\n*              FLAG SO ENTERS PHASE 'B' OF CMPRS PROCESSING NEXT TIME.\nOUXCMA1  LA    RC,OUCMSAVE         INIT @ TO 1ST SAVED STMT\n         ST    RC,OUCMSTMT         INIT PTR TO 1ST SAVED STMT\n         MVC   OUCMLICC,OUCMCCIN   INIT CARRIAGE CONTROL 1ST STMT\n         MVI   OUCMCCIN,C'1'       MAKE SURE NEW PAGE FOR PAGES 2-\n         OI    OUCMPHAS,OUCMPHSB   SHOW NOW PHASE 'B'\n         B     OUXCMRET            GO TO RETURN CODE\n         SPACE 2\n*              PHASE 'B' - RETIRIEVE AND PRINT SAVED STMT WITH NEW 1.\nOUXCMB   L     RC,OUCMSTMT         GET @ NEXT STMT TO PRINT\n         MVC   OUCMSTMA,0(RC)      MOVE THE STMTS TO PRINT AREA\n         MVC   OUCMSTMB(OUCM$L1),OUSTP1     GET 1ST SECTION OF NEW 1\n         MVC   OUCMSTMB+OUCM$L1(OUCM$L2),OUSTP2       2ND SECT OF NEW\n         $PRNT OUCMLINE,133        PRINT THE ENTIRE LINE, 2 STMTS\n         BM    OUXCMOVR            OVER NOW ON PRINTER-STOP\n         SPACE 1\n         MVI   OUCMLICC,C' '       MAKE SURE CC IS ' ' FOR REST OF PAGE\n         LA    RC,OUCM$LT(RC)      INCREMENT PTR TO NEXT SAVED STMT\n         ST    RC,OUCMSTMT         STORE BACK UPDATE PTR @\n         SPACE 1\n         LH    RC,OUCMLEFT         GET # EMPTY SLOTS LEFT\n         LA    RC,1(RC)            INCREMNT # EMPTY (JUST PRINTED 1)\n         STH   RC,OUCMLEFT         RESTORE UPDATED # EMPTRY SLOTS\n         CH    RC,OUCMOPAG         IS EMPTY # = # ON PAGE\n         BL    OUXCMRET            NO, STILL MORE TO DO, RETURN\n         SPACE 1\n*              HAVE PRINTED ALL SAVED STMTS, RETURN TO PHASE 'A'\n         LA    RC,OUCMSAVE         GET @ FIRST SLOT\n         ST    RC,OUCMSTMT         RE-INIT TO @ FIRST SLOT\n         LA    RC,$OU#LNS          NORMAL # LINES PER PAGE\n         STH   RC,OUCMOPAG         SET # ON PAGE TO NORMAL # FOR SURE\n         STH   RC,OUCMLEFT         SET COUNTER VALUE NORMAL TOO\n         NI    OUCMPHAS,255-OUCMPHSB        REST TO PHASE 'A'\n         SPACE 1\n*              OUXCMRET - EXIT CODE - RESTORE REGS,RETURN\nOUXCMRET LM    RA,RC,AVDWORK1      RESTORE REGS FROM SAVED WORDS\n         BR    R14                 RETURN TO CALLING SECTION OF CODE\nOUXCMOVR OI    AVTAGS2,AJOASTOP    FLAG OVERRRUN\n         B     OUXCMRET            GO TO EXIT FROM CMPRS SECTION\n         DROP  RA,RB               REMOVE USINGS\n.OUXCM2  ANOP\n         EJECT\n**--> ENTRY: OUEND2   2   PRINT ENDING STATISTICS FOR ASSMBLY . . . . .\n*.       OUEND2 IS CALLED AT THE END OF THE ASSEMBLY TO PRINT SUMMARY .\n*.       OF ERRORS AND WARNINGS ISSUED.  FIRST LINE PRINTED GIVES     .\n*.       TOTAL # OF STMTS FLAGGED, TOTAL # ERRORS, TOTAL # WARNINGS.  .\n*.       IF MAXIMUM # ERRORS IS EXCEEDED, ANOTHER LINE IS PRINTED.    .\n*.       USES DSECTS: AVWXTABL                                        .\n*.       USES MACROS: $PRNT,$RETURN,$SAVE                             .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nOUEND2   $SAVE SA=NO\n         AIF   (NOT &$CMPRS).OUENC1         SKIP IF NO COMPRS CODE\n         SPACE 1\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*              CMPRS OPTION COMPLETION CODE                           *\n*              SET UP COMMON USING CONDITIONS WITH OUTPT2, AND TEST   *\n*        FOR CMPRS OPTION IN EFFECT.  IF IT IS, THEN HAVE ANY         *\n*        STATEMENTS PRINTED WHICH HAD BEEN SAVED, BUT NOT YET         *\n*        PRINTED.                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n         TM    AVTAGS2,AJOCMPRS    DID USER SPECIFY CMPRS OPTION\n         BZ    OUENCMNO            NO HE DIDNT, SKIP\n         SPACE 1\n         STM   R14,RX,12(R13)      STORE REGS, ESPEC RX,R14\n         L     RX,=A(OUTPT2)       GET ADDR (SAFE IN OVERLAY)         J\n         DROP  R15                 REMOVE OLD USING\n         USING OUTPT2,RX           NOTE COMMON USING WITH OUTPT2\n         SPACE 1\n*              TEST PHASE OF CMPRS HANDLING.  IF STMTS LEFT, SET TO\n*              PHASE B TO DUMP THOSE LEFT, IF NOT ALREADY PHASE B.\n         L     RB,OUCMPRAD         GET @ CONTROL BLOCK FOR CMPRS\n         USING OUCMPRSD,RB         NOTE CONTROL BLOCK USING\n         TM    OUCMPHAS,OUCMPHSB   ARE WE IN PHASE B ALREADY\n         BO    OUENPHSB            YES, JUMP TO FINISH\n         BAL   R14,OUXCMA1         IN PHASE A, CALL THIS TO SET TO B\n         L     RB,OUCMPRAD         RELOAD RB, WHICH WAS ERASED\n         SPACE 1\n*              CMPRS HANDLER IN PHASE 'B' - PRINT ANY REMAINING STMTS\nOUENPHSB LH    RD,OUCMOPAG         GET # ON PAGE\n         SH    RD,OUCMLEFT         DIFFERENCE = # LEFT TO DO\n         BNP   OUENCMDN            NO STMTS LEFT, NO PRINTING NEEDED\n         LA    RA,AWBLANK          SHOW @ FAKE BLANK LINE\n         SPACE 1\n         BAL   R14,OUXCMINT        GO TO PRINT 1 MORE STMT/BLANK LINE\n         BCT   RD,*-4              LOOP UNTIL ALL LINES LEFT PRINTED\n         SPACE 1\nOUENCMDN LM    R14,RX,12(R13)      RESTORE REGS, ESP RX,R14\n         DROP  RB                  REMOVE USING\n         USING OUEND2,R15          RESTORE REGULAR USING\n         EJECT\nOUENCMNO EQU   *                   NORMAL OUEND2 PROCESSING\n.OUENC1  ANOP\n         SPACE 1\n         TM    AVTAGS3,AVOVERFL    DID OVERFLOW OF STORAGE OCCUR\n         BZ    OUNOVRFL            NO, DON'T PRINT MSG\n         $PRNT OUAS999,OUAS999L    PRINT THE MESSAGE\nOUNOVRFL EQU   *                   BRANCH HERE IF STORAGE OK\n         SPACE 1\n         ZAP   AVDWORK1,OULNCNT    MOVE LINE COUNT OVER FOR CONVERT\n         CVB   RE,AVDWORK1         CONVERT THE LINE COUNT TO BINARY\n         STH   RE,AVSTMTNO         SAVE AS NUMBER OF STATEMENTS\n         SPACE 1\n         LH    RE,AVSTMTER         GET # STATEMENTS FLAGGED\n         LA    RD,OUSTMTER         GET @ TO PUT RESULT\n         BAL   RC,OUENCONV         GO CONVERT VALUE\n         SPACE 1\n         LH    RE,AVNWARN          # WARNINGS ISSUED\n         LA    RD,OUNWARN          @ FOR RESULT\n         BAL   RC,OUENCONV         GO CONVERT VALUE\n         SPACE 1\n         LH    RE,AVNERRA          ACTUAL # ERRORS\n         LA    RD,OUNERRA          @ FOR RESULT\n         BAL   RC,OUENCONV         CONVERT VALUE\n         $PRNT OUEND2M,OUEND2ML    PRINT 1ST MESSAGE\n         SPACE 1\n         LH    RE,AVNERR           GET LIMIT # ERRORS\n         CH    RE,AVNERRA          COMPARE TO ACTUAL\n         BNL   OUENDREA            SKIP TO EXIT CODE IF OK\n         SPACE 1\n         LA    RD,OUNERR           GET @ FOR CONVERTED RESULT\n         BAL   RC,OUENCONV         GO CONVERT ACTUAL #\n         $PRNT OUEND2N,OUEND2NL    PRINT 2ND MESSAGE\n         SPACE 1\nOUENDREA EQU   *                   EXIT CODE LABEL\n         AIF   (&$COMNT EQ 0).OUNCOM2       SKIP IF NO COMMENT CHEKCING\n         EJECT\n*              FINAL CHECK - IF COMMENT CHECK OPTION IN EFFECT,\n*              MAKE SURE PROGRAMMER HAS SUPPLIED COMMENTS ON AT LEAST\n*              &$COMNT PER CENT OF MACHINE INSTRUCTIONS. IF NOT,\n*              DELETE HIS EXECUTION.  SEE OUINT1 AND IAMOP1 FOR CODE.\n         SPACE 1\n         TM    AVTAGS2,AJOCOMNT    IS COMMENT OPTION IN EFFECT\n         BZ    OUENDRET            NO, SO SKIP\n         SPACE 1\n         LH    RE,AVMACHIN         # MACHINE INSTRUCTIONS\n         MH    RE,=H'&$COMNT'      * PERCENT REQUIRED TO HAVE COMMENTS\n         LH    RD,AVCOMNTN         # COMMENTS ON THE MACH INSTRS\n         MH    RD,=H'100'          BY 100 FOR COMPARISON\n         CR    RD,RE               IS COMNTN>= MACHIN*&$COMNT/100\n         BNL   OUENDRET            YES, SO HE HAD ENOUGH COMMENTS-OK\n         SPACE 1\n*              INSUFFICIENT COMMENTS - ZAP USER WITH MESSAGE.\n         OI    AVTAGS1,AJNLOAD     NO EXECUTION\n         $PRNT OUEND2P,OUEND2PL    PRINT THE MESSAGE\n         SPACE 1\n.OUNCOM2 ANOP\nOUENDRET $RETURN SA=NO             RETURN TO CALLER\n         SPACE 1\n* * * * * OUENCONV - CONVERT AND EDIT INTEGER TO 6 BYTE FIELD         *\n*        ENTRY CONDTIONS                                              *\n*   RC = RETURN @ TO CALLING SECTION                                  *\n*   RD = @ 6-BYTE FIELD WHERE CONVERTED AND EDITED RESULT TO BE PLACED*\n*   RE = VALUE TO BE CONVERTED TO DECIMAL                             *\n*        EXIT CONDTIONS                                               *\n*        6-BYTE FIELD AT 0(RD) HAS EDITED RESULT, WITH 'NO' IF RE=0.  *\nOUENCONV LTR   RE,RE               IS RESULT 0\n         BZ    OUENCONO            YES, SO PU 'NO' IN\n         CVD   RE,AVDWORK1         CONVERT VALUE TO DECIMAL\n         MVC   0(6,RD),AWEP6       MOVE 6-BYTE EDIT PATTERN IN\n         ED    0(6,RD),AVDWORK1+5  EDIT THE FIELD\n         BR    RC                  RETURN TO CALLER\nOUENCONO MVC   0(6,RD),=CL6'  NO  '         VALUE = 0, USE 'NO' INSTEAD\n         BR    RC                  RETURN TO CALLER\n         EJECT\n* * * * * INTERNAL CONSTANTS                                          *\n*              PRIMARY TYPE BRANCH OFFSETS                            *\nOUJUMP1  $AL2  OUTJ1,(OUMACH,OUCONS,OULIST,OUCOMM)\n*              SECONDARY BRANCH OFFSETS FOR LISTING CONTROL.          *\nOUJUMP2  $AL2  OUTJ2,(OUSPEJ,OUPRINT,OUTITLE)\n         SPACE 1\n* * * * * INTERNAL VARIABLES                                          *\nOUCOUNT  EQU   AVOUCOUN            H, WITHIN-PAGE LINES REMAINING\nOULNCNT  EQU   AVOULNCN            PL3 - STATEMENT #\nOUPGCNT  EQU   AVOUPGCN            PL2 - # PAGES\nOUTOFFS  DS    ($RSMXCRD+1)C       SPACE FOR SAVING OFFSETS FOR CARDS\nOUH#LINE DS    H                   # LINES PER PAGE, EXCEPT HEADING\n         AIF   (NOT &$CMPRS).OUECMPA        SKIP IF NO CMPRS MODE\nOUCMPRAD DS    A                   @ OUCMPRSD AREA, IF CMPRS OPT USED\n.OUECMPA ANOP\n         SPACE 1\n*              PAGE HEADING 1 - TITLE FIELD,IF ANY, PAGE NUMBER       *\n         DS    0D                  ALIGNMENT FOR MODEL 65+\nOUHEAD1  DS    0CL121\n         DC    CL8'1'              CARRIAGE CONTROL\nOUHEADNG DS    CL100               SPACE FOR TITLE FIELD\n         DC    CL9'    PAGE '\nOUPCNT   DS    ZL4                 PAGE NUMBER\n         SPACE 1\n*              PAGE HEADING 2 - COLUMN HEADINGS AND DATE              *\n         DS    0D                  ALIGNMENT FOR MODEL 65+\nOUHEAD2  DS    0CL121\n         DC    C'0  LOC  '         CARRIAGE CONTROL, LOCATION COUNTER\n         DC    C'OBJECT CODE    ADDR1 ADDR2  STMT   SOURCE STATEMENT'\n         DC    CL54' '\nOUDATE   DC    CL8' '              DATE (IF AVAILABLE)\n         EJECT\n*              OUTPUT BUFFER SETUP FOR ALL STATEMENTS                 *\n         DS    0D                  ALIGNMENT FOR SPEED IN MODELS 65+\nOUTLINE  DS    0CL121\n         DS    C                   CARRIAGE CONTROL\nOULOC    DS    XL6                 SPACE FORLOCATION COUNTER\n         DS    C\nOUCONST  DS    0XL16               SPACE FOR UP TO 8 BYTES CONVERTED\nOUOPR1R2 DS    XL4                 SPACE FOR CONVERTED OPCODE-R1-R2\n         DS    C\nOUOPN1   DS    XL4                 CONVERTED 1ST BASE-DISPLACEMENT\n         DS    C\nOUOPN2   DS    XL4                 CONVERTED 2ND BASE DISPLACEMENT\nOUEA1    DS    XL6                 CONVERTED 1ST INSTRUCTION ADDRESS\nOUEA2    DS    XL6                 CONVERTED 2ND INSTRUCTION ADDRESS\n         DS    C\nOUTLENM  EQU   *-OULOC             LENGTH FOR TRANSLATE: MACHINE OPS\n         SPACE 1\nOUDSTMNT DS    ZL5                 STATEMENT NUMBER\n         DS    C                   BLANK OR PLUS\nOUTLEN   EQU   *-OUTLINE           LENGTH FOR BLANKING ORIGINAL\nOUSOURCE DS    0CL80               SOURCE STATEMENT\nOUSOURC  DS    CL71                SOURCE CARD,WITHOUT CONT/SEQNO\nOUCONSQ  DS    CL9                 CONTINUATION/SEQUENCE # FIELD\n         SPACE 1\n*              OUTPUT BUFFER SETUP FOR ERROR MESSAGES                 *\n         DS    0D\nOUTERROR DS    0CL121              ERROR LINE\nOUTERRAS DC    CL9' ----->AS'      ERROR FLAG - LEFT\nOUTERMS  DC    CL32' '             SPACE FOR ERROR MESSAGE\nOUTEOFF  EQU   *-RSB$L             OFFSET FROM SOURCE IMAGE\n         DC    72C'-',CL8' <-ERROR'         SPACE FOR $, END FLAG\nOUTEREND EQU   *-9                 @ LAST POSSIBLE SCAN POINTER\n         AIF   (&$OPTMS LE 2).OUOP5A   SKIP IF SMALL MEMORY\nOUBLDASH DC    CL(L'OUTERMS)' ',18C'-'      FOR REBLANKING ERROR FIELD\n.OUOP5A  ANOP\n         SPACE 1\n*              FINAL MESSAGE(S) ON STATEMENTS FLAGGED,WARNINGS,ETC.   *\n*              THIS SECTION USED BY ENTRYPT OUEND2.\nOUEND2M  DC    C'0***'\nOUSTMTER DC    ZL6'0',C' STATEMENTS FLAGGED -'\nOUNWARN  DC    ZL6'0',C' WARNINGS,'         # WARNINGS ISSUED\nOUNERRA  DC    ZL6'0',C' ERRORS'   # ERRORS\nOUEND2ML EQU   *-OUEND2M           LENGTH OF THIS MESSAGE\n         SPACE 1\nOUEND2N  DC    C'0***** NUMBER OF ERRORS EXCEEDS LIMIT OF'\nOUNERR   DC    ZL6'0',C' ERRORS - PROGRAM EXECUTION DELETED *****'\nOUEND2NL EQU   *-OUEND2N           LENGTH OF THIS ERROR MESSAGE\n         AIF   (&$COMNT EQ 0).OUNCOM3       SKIP IF NO COMMENT CHEK\nOUEND2P  DC    C'0***** EXECUTION DELETED - LESS THAN &$COMNT '\n         DC    C'PER CENT OF MACHINE INSTRUCTIONS HAVE COMMENTS *****'\nOUEND2PL EQU   *-OUEND2P           GET LENGTH OF WHOLE MESSAGE\n         SPACE 1\n.OUNCOM3 ANOP\n         SPACE 1\nOUAS999  DC    C'0AS999'           MESSAGE NUMBER\n         AIF   (&$OPTMS LE 2).OUAS999  SKIP IF LOW CORE USAGE\n         DC    C' DYNAMIC STORAGE EXCEEDED'\n.OUAS999 ANOP\nOUAS999L EQU   *-OUAS999           LENGTH OF MESSAGE\n         LTORG\n         EJECT\n*              ERROR POINTERS AND ERROR MESSAGES                      *\n*              FOR ADDRESSIBILITY, THIS SECTION SHOULD BE LAST.       *\n*        **NOTE** FOR SMALL COMPUTERS, THIS CODE CAN BE GREATLY       *\n*        BY MODIFYING MACRO $SERR TO GENERATE ONLY THE ERROR NUMBERS. *\n         AIF   (&$OPTMS LE 2).OUOP6         SKIP IF SMALL MEMORY\n*        THE PROGRAM LOGIC REMIANS UNCHNAGED, BUT 1100 BYTES CAN BE   *\n*        SAVED WHICH ARE CURRENTLY TAKEN BY THE ERROR MESSAGES.       *\n*              THE TABLE CONSISTS OF 2 SECTIONS: A HALFWORD OFFSET    *\n*              @ LIST, AND A LIST OF MESSAGES CREATED BY $SERR'S,     *\n*              WHICH ARE POINTED TO BY THE OFFSET @'S.                *\n         SPACE 1\n         DS    0H                  ALIGN ON HALF WORD BPUNDARY\nOUERRPT   EQU  *-2 .               OFFSET TO 1 ' BACKWARDS\n         DS    (&$ERNUM/2)H .      SPACE FOR HALFWORD ERROR POINTERS\n.OUOP6   ANOP\n         EJECT\nOUERRMS  EQU   *                   BASE ADDRESS FOR ERROR MESSAGES\nALIGN    $SERR 'W-ALIGNMENT ERROR-IMPROPER BOUNDARY',000\nENTRY    $SERR 'W-ENTRY ERROR-CONFLICT OR UNDEFINED',001\nEXTRN    $SERR 'W-EXTERNAL NAME ERROR OR CONFLICT',002\nRGNUS    $SERR 'W-REGISTER NOT USED',003\nODDRG    $SERR 'W-ODD REGISTER USED-EVEN REQUIRED',004\nNOEND    $SERR 'W-END CARD MISSING-SUPPLIED',005\nADDR     $SERR 'ADDRESSIBILITY ERROR',100\nCNLNG    $SERR 'CONSTANT TOO LONG',101\nCNTYP    $SERR 'ILLEGAL CONSTANT TYPE',102\nCONT     $SERR 'CONTINUATION CARD COLS. 1-15 NONBLANK',103\nCONTX    $SERR 'MORE THAN 2 CONTINUATION CARDS',104\nCXREL    $SERR 'COMPLEX RELOCATABILITY ILLEGAL',105\nDCEXT    $SERR 'TOO MANY OPERANDS IN DC',106\nDPCSE    $SERR 'MAY NOT RESUME SECTION CODING',107\nDUPLF    $SERR 'ILLEGAL DUPLICATION FACTOR',108\nEXGTA    $SERR 'EXPRESSION TOO LARGE',109\nEXLTA    $SERR 'EXPRESSION TOO SMALL',110\nICNOP    $SERR 'INVALID CNOP OPERAND(S)',111\nILLAB    $SERR 'LABEL NOT ALLOWED',112\nILORG    $SERR 'ORG VALUE IN WRONG SECTION OR TOO LOW',113\nINVCN    $SERR 'INVALID CONSTANT',114\nINVDM    $SERR 'INVALID DELIMITER',115\nINVF     $SERR 'INVALID FIELD',116\nINVSY    $SERR 'INVALID SYMBOL',117\nIVOPC    $SERR 'INVALID OP-CODE',118\nMULDF    $SERR 'PREVIOUSLY DEFINED SYMBOL',119\nNEABS    $SERR 'ABSOLUTE EXPRESSION REQUIRED',120\nNODLM    $SERR 'MISSING DELIMITER',121\nNOIMP    $SERR 'FEATURE NOT CURRENTLY IMPLEMENTED',122\nNOOPR    $SERR 'MISSING OPERAND',123\nNONAM    $SERR 'LABEL REQUIRED',124\nRELOC    $SERR 'RELOCATABLE EXPRESSION REQUIRED',126\nSDINV    $SERR 'INVALID SELF-DEFINING TERM',127\nSTART    $SERR 'ILLEGAL START CARD',128\nTLIT     $SERR 'ILLEGAL USE OF LITERAL',129\nUNDEF    $SERR 'UNDEFINED SYMBOL',130\nUNRV     $SERR 'UNRESOLVED EXTERNAL REFERENCE',131\nVILCH    $SERR 'ILLEGAL CHARACTER',132\nVPARN    $SERR 'TOO MANY PARENTHESIS LEVELS',133\nVRELO    $SERR 'RELOCATABLE VALUE USED WITH * OR /',134\nVSYNT    $SERR 'SYNTAX',135\nVTMTR    $SERR 'TOO MANY TERMS IN EXPRESSION',136\nVUNEX    $SERR 'UNEXPECTED END OF EXPRESSION',137\nINTPT    $SERR 'STATEMENT CAUSED INTERRUPT',138\n         AIF   (NOT &$MACROS).OUSERR1       SKIP IF NO MACROS\nILOPR    $SERR 'OPERAND NOT ALLOWED',201\nSTMNA    $SERR 'STATEMENT OUT OF ORDER',202\nSSDIM    $SERR 'SET SYMBOL DIMENSION ERROR',203\nINSBV    $SERR 'INVALID NBR OF SUBSCRIPTS',204\nILCNV    $SERR 'ILLEGAL CONVERSION',205\nMISQU    $SERR 'MISSING QUOTES IN CHAR EXPR',206\nILMNM    $SERR 'ILLEGAL OR DUP MACRO NAME',207\nMXDMD    $SERR 'OPRND NOT COMPATIBLE WITH OPRTR',208\nUNDKW    $SERR 'UNDFND OR DUP KEYWORD',209\nEXMAC    $SERR 'MNEST LIMIT EXCEEDED',210\nILAT     $SERR 'ILLEGAL ATTRIBUTE USE',211\nMEXST    $SERR 'GENERATED STMT TOO LONG',212\nOVRGN    $SERR 'GENERATED STMTS OVERWRITTEN',298\n.OUSERR1 SPACE 1\n         DROP  RAT,R2,RC,RD,RX,RZ  REMV USINGS\n         AIF   (NOT &$CMPRS).OUCMDSE        SKIP IF NO CMPRS CODE\n         EJECT\n**--> DSECT: OUCMPRSD   CONTROL BLOCK FOR OUTPUT CMPRS OPTION . . . . .\n*.       THIS BLOCK DESCRIBES AREA USED BY OUTPT2 WHEN DOING THE      .\n*.       CMPRS LISTING OPTION (2 STMTS/LINE).  IT CONTAINS VARIABLES, .\n*.       FLAGS, AND SPACE FOR $OU#NORM PARTIAL CARD IMAGES, WHICH     .\n*.       ARE SAVED AND USED FOR THE LEFT-HAND-SIDE OF THE PAGE.       .\n*.       THIS BLOCK IS ALLOCATED SPACE ONLY IF THE CMPRS PARM IS      .\n*.       USED.  THE @ OUCMPRSD IS STORED IN OUCMPRAD VARIABLE.        .\n*.       LOCATION: IN DYNAMIC AREA, ACQUIRED BY $ALLOCH IN OUINT1.    .\n*.       NAMES: OUCM----                                              .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n         SPACE 1\nOUCMPRSD DSECT\n*              LENGTH EQUS FOR PARTS OF STMT ACTUALLY PRINTED/SAVED.\nOUCM$LT  EQU   (&$PRTSIZ-3)/2      TOTAL # BYTES SAVED PER CMPRS STMT\nOUCM$L1  EQU   OUEA1-OULOC         # BYTES IN FIRST PART OF STMT\nOUCM$L2  EQU   OUCM$LT-OUCM$L1     # BYTES SAVED, FROM OUDSTMT-1\n         SPACE 1\n*              CMPRS OPTION PHASE EQUATE FLAGS.\nOUCMPHSB EQU   B'00000001'         (OUCMPHAS)- PHASE B - PRINTING CARDS\n         SPACE 1\n*              CMPRS PROCESSING VARIABLES.\nOUCMSTMT DS    A                   @ SLOT FOR NEXT CARD SAVED/PRINTED\nOUCMOPAG DS    H                   # STMTS TOTAL ON CURRENT PAGE\nOUCMLEFT DS    H                   # SLOTS LEFT/ # ALREADY PRINTED\nOUCMPHAS DS    B                   PHASE FLAG - A OR B.\nOUCMCCIN DS    C                   CARRIAGE CONTROL INIT - '0' OR '1'\n         SPACE 1\n*              STATEMENT ASSEMBLY AREA - HOLDS BOTH HALVES OF A\n*              LINE FOR PRINTING, DURING PHASE B OF PROCESSING.\n         DS    0F                  ALIGN FOR POSSIBLE SPEED\nOUCMLINE DS    0CL133\nOUCMLICC DS    C                   CARRIAGE CONTROL BYTE\nOUCMSTMA DS    CL(OUCM$LT)         SPACE FOR CARD SAVED IN PHASE A\nOUCMBREK DS    CL2' '              BREAK - MUST INIT TO C'  '\nOUCMSTMB DS    CL(OUCM$LT)         SPACE FOR CARD FROM PHASE B\n         SPACE 1\n*              CARD SEGMENT SAVE AREA - DURING PHASE A, ENOUGH CARDS\n*              ARE SAVED HERE FOR LEFT-HAND-SIDE OF PAGE.\nOUCMSAVE DS    ($OU#LNS)CL(OUCM$LT)         1 PAGE OF STMT SEGMENTS\n         SPACE 1\nOUCMPR$L EQU   ((*-OUCMPRSD+3)/4)*4         DSECT TOTAL LENGTH, ROUNDED\n         SPACE 2\n**--> DSECT: OUSTMTIM   STATEMENT IMAGE USED IN OUTPUT  . . . . . . . .\n*.       USED IN CMPRS OPTION HANDLER OF OUTPT2 TO ACCESS PORTIONS    .\n*.       OF INCOMING STATEMENTS TO BE SAVED.                          .\n*.       NAMES: OUST----                                              .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n         SPACE 1\nOUSTMTIM DSECT\nOUSTCC   DS    C                   CARRIAGE CONTROL\nOUSTP1   DS    CL(OUCM$L1)         FIRST PART - LOC, OBJ CODE\n         DS    2XL6                SKIP ADDR1-ADDR2, DON'T SAVE\nOUSTP2   DS    CL(OUCM$L2)         2ND PART - STMT #, PART OF CARD\n.OUCMDSE ANOP\n         TITLE '*** SCANRS - SCANNING ROUTINES -SCAN-BL,CO,EQ ***'\n**--> CSECT: SCANRS   1-2 SCANNING ROUTINES . . . . . . . . . . . . . .\n*.       SCANRS CONTAINS VARIOUS UTILITY SCANNING ROUTINES. ALL 3     .\n*.       ENTRIES TERMINATE SCANNING ON FINDING A BLANK. 1 ENTRY ALSO  .\n*.       STOPS FOR A COMMA, AND THE OTHER STOPS FOR AN EQUALS SIGN.   .\n*.       ****NOTE**** THIS ROUTINE MODIFIES TABLE AWTZTAB IN AVWXTABL..\n*.       IT MAY THEN CALL SDBCDX WITHOUT RESETTING THE TABLE. THIS    .\n*.       IS AN EXCEPTION TO THE RULE OF NOT PERMITTING MODIFICATION   .\n*.       TO AV------ SECTIONS WHEN CALLING ANOTHER MODULE.            .\n*.       CALLS SDBCDX                                                 .\n*.       USES DSECTS: AVWXTABL                                        .\n*.       USES MACROS: $CALL,$RETURN,$SAVE,$SETRT                      .\n*.       NAMES: SCAN----                                              .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nSCANRS   CSECT\n         $DBG  90,*\n         USING AVWXTABL,RAT        NOTE MAIN USING\n         ENTRY SCANBL,SCANCO,SCANEQ\n         SPACE 2\n**--> ENTRY: SCANEQ       SCAN TO = OR BLANK(USED BY IAMOP1 FOR LITERA.\n*.       ENTRY CONDITIONS                                             .\n*.  RA = SCAN POINTER                                                 .\n*.       EXIT CONDITIONS                                              .\n*.  RA = SCAN POINTER TO = OR BLANK, OR ERROR IF ANY                  .\n*.  RB = 0    IF SCAN OK, = ERROR CODE IF ERROR FOUND(IN SELF-DEF TRM).\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nSCANEQ   $SAVE RGS=(R14-R2),SA=SCANSAVE     SAVE REGS,SET UP SA @\n         $SETRT ('=',4)            SET UP CODE FOR =\n         B     SCANGO              GO TO COMMON SECTION OF CODE\n         SPACE 2\n**--> ENTRY: SCANCO       SCAN TO COMMA OR BLANK (USED BY A-TYPE ADCON.\n*.       ENTRY AND EXIT CONDITIONS SAME AS SCANEQ                     .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nSCANCO   $SAVE RGS=(R14-R2),SA=SCANSAVE     SAVE REGS,SET UP SA @\n         $SETRT (',',4)            SET THE SCAN CODE FOR ,\n         B     SCANGO              GO TO COMMON SECTION OF CODE\n         SPACE 2\n**--> ENTRY: SCANBL       SCAN TO BLANK ONLY. . . . . . . . . . . . . .\n*.       ENTRY AND EXIT CONDITIONS SAME AS SCANEQ                     .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nSCANBL   $SAVE RGS=(R14-R2),SA=SCANSAVE,BR=R13   SAVE REGS, SET UP SA @\n*              FALL THRU INTO COMMON SECTION OF CODE, SCANGO.\n         EJECT\n* * * * * COMMON CODE SECTION FOR SCANNING AND RESETTING TRT TABLE    *\nSCANGO   $SETRT (' ',4,'''',8)     SET FOR QUOTE AND BLANK\n         SR    R1,R1               CLEAR FOR INSERTING ADDRESS\n         SR    R2,R2               CLEAR CODE INSERTION\n         SR    RB,RB               CLEAR TO SHOW OK\n*              INITIALIZATION DONE. REMAINDER IS SCAN LOOP            *\nSCANTRT  TRT   0(256,RA),AWTZTAB   SCAN FOR ',BLANK OR EITHER = OR ,\n         LR    RA,R1               MOVE THE SCAN POINTER OVER\n         B     *(R2)               BRANCH APPROPRAITELY(CC=0 IMPOSSIB)\n         B     SCANRETA            CHAR WAS =, OR BLANK-RETURN\n         BCTR  R1,0                CHAR WAS QUOTE-BACK UP TO SEE BEFORE\n         CLI   0(R1),C'L'          WAS THIS LENGTH ATTRIBUTE\n         BNE   SCANSDT             NO-MUST BE SELF-DEFINING TERM-BRANCH\n         LA    RA,2(R1)            INCREMENT SCAN POINTER PAST L'\n         B     SCANTRT             GO BACK FOR NEXT SCAN\n*              SELF-DEFINING TERM TENTATIVELY FOUND-CHECK             *\nSCANSDT  LR    RA,R1               MOVE THE SCAN POINTER OVER\n         $CALL SDBCDX              CALL ROUTINE(RB=0==>SCAN ONLY)\n         LTR   RB,RB               DETERMINE RESULT\n         BP    SCANRETA            ERROR FOUND,RETURN WITH IT\n         BM    *+12                INVALID, ' BUT NOT X' B' C' L'\n         CLI   0(RA),C''''         CHECK FOR CL21' ' TYPE ERROR IN OPRN\n         BNE   SCANTRT             IF NOT,OK, CONTINUE, ELSE ERROR\n         LA    RB,$ERINVDM         WE HAVE ',BUT NOTSDTRM-ERROR\nSCANRETA $SETRT (' ',0,'''',0,'=',0,',',0)  REZERO ALL BYTES USED\n         SPACE 1\nSCANRET  $RETURN RGS=(R14-R2)      RETURN   TO CALLER\n         DROP  RAT,R13             CLEAN UP USING SITUATION\n         TITLE '*** SDTERM - SELF-DEFINING TERM PROCESSORS ***'\n**--> CSECT: SDTERM     SELF-DEFINING TERM CONVERSIONS. . . . . . . . .\n*.       SDTERM INCLUDES AN ENTRY POINT FOR CONVERTING EACH TYPE OF   .\n*.       SELF-DEFINING TERM, AND AN ENTRY POINT WHICH FIRST DECIDES   .\n*.       WHICH TYPE(IF ANY) THE SCAN POINTER IS POINTING AT, THEN     .\n*.       BRANCHES TO THE CORRECT SECTION TO CONVERT THE TERM.         .\n*.       USES DSECTS: AVWXTABL                                        .\n*.       USES MACROS: $RETURN,$SAVE                                   .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nSDTERM   CSECT\n         $DBG  90,SNAP\n         ENTRY SDBCDX,SDBTRM,SDCTRM,SDDTRM,SDXTRM\n         USING AVWXTABL,RAT        NOTE MAIN USING\n         SPACE 2\n**--> ENTRY: SDBCDX   1-2 DETERMINE TYPE OF SELF-DEFINING TERM-CHECK. .\n*.       DECIDE TYPE OF SELF-DEFINING TERM, BRANCH TO RIGHT SECTION.  .\n*.       ENTRY CONDITIONS                                             .\n*.  RA = SCAN POINTER TO BEGINNING OF TERM- TO C,B,X, OR 1ST DIGIT    .\n*.       EXIT CONDITIONS                                              .\n*.  RA = SCAN POINTER TO DELIMITER BEYOND TERM,(NOT ' ENDING B,C,X)   .\n*.  RB = 0    SELF DEFINING TERM WAS LEGAL                            .\n*.  EB = >0 - ERROR CODE - ILLEGAL TERM ($ERSDINV)                    .\n*.  RB = -4 ==> SCAN POINTER DID NOT POINT AT SELF-DEFINING TERM      .\n*.  RC = VALUE OF SELF-DEFINING TERM, FROM 0 TO 2**24-1               .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nSDBCDX   $SAVE SA=NO\n         CLI   0(RA),C'0'          CHECK FOR DIGITS\n         BNL   SDDTRM1             GO PROCESS DECIMAL FIELD\n         CLI   1(RA),C''''         IS 2ND CAHR A '\n         BNE   SDBCDX1             NO, SO RETURN SHOWING NO SELF-DEF TR\n         CLI   0(RA),C'C'          CHARACTER TYPE\n         BH    SDTX                HIGHER THAN C,TRY X\n         BE    SDCTRM1             PROCESS C'----\n         CLI   0(RA),C'B'          BINARY TYPE\n         BE    SDBTRM1             PROCESS BINARY TERM\n         B     SDBCDX1             EROR, NOT ONE OF THESE\nSDTX     CLI   0(RA),C'X'          HEXADECIMAL TYPE\n         BE    SDXTRM1             PROCESS HEX TERM\nSDBCDX1  L     RB,AWFM4            PUT NEGATIVE 4 IN FOR RETURN CODE\n         $RETURN SA=NO\n         EJECT\n**--> ENTRY: SDBTRM   1-2 SCAN, COMPUTE BINARY SELF-DEFINING TERM . . .\n*.       ENTRY,EXIT CONDITONS SAME AS SDBCDX, EXCEPT RB >= 0 ON EXIT. .\n*.       NAMES: SDB-----                                              .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nSDBTRM1  BALR  R15,0               SET UP ADDRESS AS EXPECTED ON ENTRY\nSDBTRM   $SAVE RGS=NO,SA=NO\n         LA    RA,2(RA)            INCREMENT BEYOND B'\n         CLI   0(RA),C''''         MAKE SURE NOT NULL CONST\n         BE    SDBINVCN            NULL CONSTANT-ILLEGAL\n         SR    RC,RC               CLEAR REGISTER RESULT APPEARS IN\n         LA    RD,1                FOR LOOP INCREMENT\n         LA    RE,24(RA)           FOR LIMIT ADDRESS\n         SPACE 1\nSDBLOOP  CLI   0(RA),C'0'          CHECK FOR 0\n         BE    SDBLOOPB            IF SO, JUST SHIFT RESULT\n         CLI   0(RA),C'1'          CHECK FOR  A 1\n         BNE   SDBOUT              BRANCH IF NOT, SHOULD BE '\n         AR    RC,RD               ADD A 1 INTO REGISTER\nSDBLOOPB AR    RC,RC               = SLL RC,1 - SHIFT TO NEXT\n         BXLE  RA,RD,SDBLOOP       CONTINUE LOOPING\n         BCT   RA,SDBINVCN         TOO LARGE, BACK UP AND FLAG\n         SPACE 1\nSDBOUT   CLI   0(RA),C''''         MAKE SURE DELIMETER IS '\n         BNE   SDBINVCN            IF NOT , ILLEGAL\n         AR    RA,RD               POINT TO NEXT BEYOND\n         SRL   RC,1                SHIFT BACK FOR CORRECT RESULT\n         SR    RB,RB               SHOW NO ERRORS\nSDBRET   $RETURN SA=NO,RGS=NO\nSDBINVCN LA    RB,$ERSDINV         SHOW ILLEGAL\n         B     SDBRET              RETURN\n         EJECT\n**--> ENTRY: SDCTRM   1-2 SCAN, COMPUTE CHARACTER SELF-DEFINING TERM. .\n*.       ENTRY,EXIT CONDITONS SAME AS SDBCDX, EXCEPT RB >= 0 ON EXIT. .\n*.       NAMES: SDC-----                                              .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nSDCTRM1  BALR  R15,0               SET UP ADDRESS AS EXPECTED ON ENTRY\nSDCTRM   $SAVE RGS=NO,SA=NO\n         SR    RC,RC               CLEAR REGISTER FOR RESULT\n         LA    RD,1                FOR USEFUL CONTANT\n         AR    RA,RD               INCREMENT FOR  C TO '\n         LA    RE,4                LIMIT = MAX CHARS(3)+1\n         SPACE 1\n*              SCAN LOOP - CHECK FOR 'S AND &S AND LENGTH <4 BYTES.\nSDCLOOP  AR    RA,RD               INCREMENT TO LOOK AT NEXT SLOT\n         CLI   0(RA),C''''         IS IT A QUOTE\n         BE    SDCQUOT             YES-BRANCH\n         CLI   0(RA),C'&&'         IS IT AN &\n         BNE   SDCNORM             NO, GO DO NORMAL CASE\n         AR    RA,RD               INCREMENT TO NEXT SLOT\n         CLI   0(RA),C'&&'         IS THIS ONE & ALSO\n         BE    SDCNORM             2 &&'S TOGETHER-OK\n         B     SDCINVCN            INVALID - SINGLE & BY ITSELF\n         SPACE 1\nSDCQUOT  AR    RA,RD               LOOK AT NEXT CHAR\n         CLI   0(RA),C''''         IS IS FOLLOWED BY '\n         BNE   SDCOUT              NO, IT IS END OF CONST\nSDCNORM  SLL   RC,8                SHIFT 1 CHRACTER WORTH\n         IC    RC,0(RA)            GET THE CHARACTER\n         BCT   RE,SDCLOOP          KEEP GOING-UP TO 24 BITS WORTH\n         SPACE 1\n         B     SDCINVCN            FELL THRU-MORE THAN 3 CHARS-ILLEGAL\nSDCOUT   C     RE,AWF3             WAS THERE A NULL CONSTANT\n         BH    SDCINVCA            RE = 4 ==> NULL CONST,ILLEGAL\n         SR    RB,RB               SHOW NO ERRORS\nSDCRET   $RETURN RGS=NO,SA=NO\nSDCINVCA SR    RA,RD               NULL CONST-BACK UP SCAN PTR 1\nSDCINVCN LA    RB,$ERSDINV         SHOW INVALID\n         B     SDCRET              GO RETURN\n         EJECT\n**--> ENTRY: SDDTRM   1-2 CHECK OR CONVERT DECIMAL SELF-DEFINING TERM .\n*.       ENTRY,EXIT CONDITONS SAME AS SDBCDX, EXCEPT RB >= 0 ON EXIT. .\n*.       NAMES: SDD-----                                              .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nSDDTRM1  BALR  R15,0               SET UP ADDRESS AS EXPECTED ON ENTRY\nSDDTRM   $SAVE RGS=(R1-R2),SA=NO\n         LR    RD,RA               DUPLICATE SCAN POINTER\n         SR    R1,R1               CLEAR FOR USE WITH TRT\n         TRT   0(9,RD),AWTDECT     TRANSLATE WITH DECIMAL TABLE\n         BZ    SDDINVCN            MORE THAN 9 DIGITS, ERROR\n         LR    RA,R1               MAKE R1 NEW SCAN POINTER\n         SR    R1,RD               SUBTRACT TO GET LENGTH\n         BZ    SDDINVCN            IF ZERO LENGTH,ILLEGAL\n         SPACE 1\n         BCTR  R1,0                GET LENGTH-1 FOR EXECUTE\n         EX    R1,SDDPACK          PACK THE CHARS IN\n         CVB   RC,AVDWORK1         CONVERT THE NUMBER\n         C     RC,AWFX6F           COMPARE TO HIGHEST VALUE\n         BH    SDDINVCM            IF TOO BIG, BACK UP SCAN PTR,RETURN\n         SPACE 1\n         SR    RB,RB               SHOW NO ERRORS EXIST\nSDDRET   $RETURN RGS=(R1-R2),SA=NO\nSDDINVCM BCTR  RA,0                DECREMENT SCAN POINTER BY 1\nSDDINVCN LA    RB,$ERSDINV         SHOW INVALID SD TERM\n         B     SDDRET              GO RETURN WITH ERROR\n         SPACE 1\nSDDPACK  PACK  AVDWORK1(8),0($CHN,RD)        PACK A DECIMAL FIELD\n         EJECT\n**--> ENTRY: SDXTRM   1-2 SCAN, COMPUTE HEXADECIMAL SELF-DEFINING TERM.\n*.       ENTRY,EXIT CONDITONS SAME AS SDBCDX, EXCEPT RB >= 0 ON EXIT. .\n*.       NAMES: SDX-----                                              .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nSDXTRM1  BALR  R15,0               SET UP ADDRESS AS EXPECTED ON ENTRY\nSDXTRM   $SAVE RGS=(R1-R2),SA=NO\n         LA    RA,2(RA)            INCREMENT PAST X'\n         SR    R1,R1               CLEAR FOR TRT\n         TRT   0(7,RA),AWTHEXT               CHECK FOR LEGALITY\n         BZ    SDXINVCX            TOO LARGE, GO FLAG IT\n         CLI   0(R1),C''''         CHECK FOR PROPER DELIMIETER\n         BNE   SDXINVCY            INVALID CHARACTER,ERROR\n         SPACE 1\n         LR    RD,RA               SAVE THE SCAN POINTER\n         LA    RA,1(R1)            INCREMENT THE SCAN POINTER\n         SR    R1,RD               GET THE LENGTH\n         BZ    SDXINVCW            NULL CONSTANT-BRANCH ERROR\n         SPACE 1\n         EX    R1,SDXMOVE          MOVE THE CONST+1 EXTRA BYTE OVER\n         EX    R1,SDXTRAN          TRANSLATE THE BYTES APPROPRIATELY\n         EX    R1,SDXPACK          PACK THEM TOGETHER\n         L     RC,AVDWORK1         LOAD FULLWORD VALUE INTO REG\n         SR    RB,RB               SHOW LEGAL VALUE\nSDXRET   $RETURN RGS=(R1-R2),SA=NO\n         SPACE 1\nSDXINVCW BCT   RA,SDXINVCN         BACK UP SCAN PTR,GO RETURN ERR\nSDXINVCX LA    R1,6(RA)            TOO LONG-PLACE SCAN PTR RIGHT\nSDXINVCY LR    RA,R1               MOVE SCAN POINTER OVER\nSDXINVCN LA    RB,$ERSDINV         INVALID SELF-DEFINING TERM\n         B     SDXRET              GO RETURN\n         SPACE 1\nSDXMOVE  MVC   AVDWORK2($CHN),0(RD)          MOVE HEX TERM TO WORKAREA\nSDXTRAN  TR    AVDWORK2($CHN),AWTHEX2        CONVERT HEX TO BINARY\nSDXPACK  PACK  AVDWORK1(5),AVDWORK2($CHN)    DO CORRECT PACK-INTERNAL\n         DROP  RAT,REP             CLEAN UP USING\n         TITLE '*** SYMOPS - ASSIST SYMBOL TABLE OPERATIONS ***'\n**--> CSECT: SYMOPS   1-2 ALL NORMAL SYMBOL TABLE OPERATIONS. . . . . .\n*.       SYMOPS BUILDS, MAINTAINS, AND RETRIEVES FROM THE SYMBOL      .\n*.       TABLE OF THE ASSIST ASSEMBLER.  THE SYMBOL TABLE IS A VIRUTAL.\n*.       SCATTER TABLE, WITH CHAIN ORDERING BY A SECONDARY HASH CODE. .\n*.       ALL SYMBOLS ARE HASHED INTO A SMALL PRIMARY POINTER TABLE.   .\n*.       EACH WORD IN THE PRIMARY TABLE POINTS TO A LINKED LIST OF    .\n*.       SYMBOLS HASHING TO THAT LOCATION IN THE PRIMARY TABLE. THE   .\n*.       SYMBOLS ARE ORDERED ON THE LIST IN DESCENDING ORDER BY THE   .\n*.       VALUE OF A SECOND HASH CODE, WHICH IS KEPT IN THE LINK       .\n*.       POINTER POINTING TO THE SYMBOL TO WHICH IT BELONGS.  THIS    .\n*.       METHOD IS USED BECAUSE MAKES NO ASSUMPTIONS ABOUT THE FINAL  .\n*.       SIZE OF THE FINAL SYMBOL TABLE, PERMITTING ALLOCATION OF     .\n*.       ENTRIES FROM THE DYNAMIC AREA.  IT ALSO PERMITS A VERY FAST  .\n*.       (3 FAST INSTRUCTIONS) MAJOR SEARCH LOOP, WHICH STILL GIVES   .\n*.       GOOD PERFORMACNE EVEN WITH A SMALL INITIAL POINTER TABLE     .\n*.       AND LONG LISTS OF SYMBOLS.                                   .\n*.       CALLS MOSTOP                                                 .\n*.       USES DSECTS: AVWXTABL,SYMSECT                                .\n*.       USES MACROS: $ALLOCH,$CALL,$RETURN,$SAVE                     .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n         SPACE 1\nSYMOPS   CSECT\n         $DBG  90,*\n&$SYHASH SETA  8                   SET UP 1ST VALUE\n         AIF   (&$OPTMS EQ 0).SYHA\n&$SYHASH SETA  16                  TRY ALRGER VALUE\n         AIF   (&$OPTMS LE 3).SYHA SKIP IF NOW HAVE RIGHT VALUE\n&$SYHASH SETA  32                  LARGER VALUE\n         AIF   (&$OPTMS LE 6).SYHA          SKIP IF NOW HAVE VALUE\n&$SYHASH SETA  64                  LARGEST VALUE CURRENTLY\n.SYHA    ANOP\n*              USING VALUE OF &$OPTMS, DETERMINE SIZE OF INITIAL POINT*\n*        HASH TABLE.  VALUES ARE (&$OPTMS)-&$SYHASH -                 *\n*        (0)-8, (1-3)-16, (4-6)-32, (7-9)-64.   THE RELATIVELY SMALL  *\n*        SIZES CAN BE TOLERATED BECAUSE OF THE SECONDARY KEY ORDERING.*\n         SPACE 1\n         ENTRY SYINT1,SYENT1,SYFIND,SYEND2\n         USING AVWXTABL,RAT        NOTE MAIN USING\n         EJECT\n**--> ENTRY: SYINT1   1   INITIALIZE SYMBOL TABLE . . . . . . . . . . .\n*.       OBTAINS SPACE FOR INITIAL POINTER TABLE, ZEROES IT.          .\n*.       ALSO SAVES THE ADDRESS OF THE INITIAL POINTER TABLE.         .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nSYINT1   $SAVE RGS=(R14-R6),SA=NO\n         LM    R0,R7,AWZEROS       GET ZEROS FOR ZEROING HASH TABLE\n         LA    R10,32              # BYTES ZEROED BY EACH STM\n         LA    R11,4*&$SYHASH      GET LENGTH OF INITIAL PTR TABLE\n         $ALLOCH R9,R11,SYOVER     ALLOCATE THE REQUIRED SPACE\n         AR    R11,R9              END TABLE @ = BEGIN TABLE @ + LENGTH\n         SPACE 1\n         SR    R11,R10             BXLE LIMIT = END @ - LOOP INCREMENT\n         ST    R9,SYRA             SAVE THE BEGIN TABLE @ FOR LATER\nSYIZERO  STM   R0,R7,0(R9)         ZERO 32 BYTES OF INDEX TABLE\n         BXLE R9,R10,SYIZERO       CONTINUE ZEROING\n         $RETURN RGS=(R14-R6),SA=NO\n         EJECT\n**--> ENTRY: SYENT1   1   ENTER A SYMBOL INTO TABLE,RETURN ADDRESS. . .\n*.       ENTRY CONDITIONS                                             .\n*.  RA = SCAN POINTER TO FIRST CHARACTER OF THE SYMBOL                .\n*.  RB = NUMBER OF CHARACTERS IN THE SYMBOL  =  1 - 8                 .\n*.       EXIT CONDITIONS                                              .\n*.  RA = ADDRESS IN THE SYMBOL TABLE WHERE SYMBOL IS                  .\n*.  RB = 0    THE SYMBOL WAS ALREADY PRESENT IN THE TABLE             .\n*.     = 4    THE SYMBOL WAS NOT ALREADY PRESENT IN THE TABLE         .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n         AIF   (NOT &$XREF).NOXRF19\nSYENT1   $SAVE RGS=(R14-R6),SA=SYXRSA,BR=R2  **NOTE ODD BASE REG***\n         AGO   .NOXRF20            SKIP OLD SAVE MACRO\n.NOXRF19 ANOP\nSYENT1   $SAVE RGS=(R3-R6),SA=NO\n.NOXRF20 ANOP                                                         A\n         LA    RC,SYENTER          SET UP FOR BRANCH LATER ON\n         LA    RW,SYRETB           SET UP FOR BRANCH LATER            L\n         AIF   (NOT &$XREF).NOXRF22  SKIP IF NO XREF                  A\n         B     SYXFINDX            GO TO ROUTINE                      A\n         AGO   .NOXRF23            SKIP OLD CODE IF XREF              A\n.NOXRF22 ANOP                                                         A\n         LA    REP,SYFIND          SET UP FOR NEW USING\n         USING SYFIND,REP          SET SO BRANCH WILL WORK\n         B     SYFINDA             GO TO COMMON CODE SECTION\n.NOXRF23 ANOP                                                         A\n         SPACE 2\n**--> ENTRY: SYFIND   1-2 LOOK UP SYMBOL,REPORT PRESENCE/ADDRESS. . . .\n*.       ENTRY CONDITIONS                                             .\n*.  RA = SCAN POINTER TO FIRST CHARACTER OF THE SYMBOL                .\n*.  RB = NUMBER OF CHARACTERS IN THE SYMBOL  =  1 - 8                 .\n*.       EXIT CONDITIONS                                              .\n*.  RA = ADDRESS OF THE SYMBOL IN THE SYMBOL TABLE, IF IT IS THERE    .\n*.  RB = 0    THE SYMBOL IS IN THE TABLE                              .\n*.     = 4    THE SYMBOL IS NOT IN THE TABLE                          .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n         AIF   (NOT &$XREF).NOXRF24                                   A\nSYFIND   $SAVE RGS=(R14-R6),SA=SYXRSA,BR=R2     ***NOTE ODD BASE REG  A\n         AGO   .NOXRF25                                               A\n.NOXRF24 ANOP                                                         A\nSYFIND   $SAVE RGS=(R3-R6),SA=NO\n.NOXRF25 ANOP                                                         A\n         LA    RC,SYRETA           SET ADDRESS FOR LATER\n         LA    RW,SYRET            SET UP FOR BRANCH LATER            L\n         AIF   (NOT &$XREF).NOXRF88    SKIP IF NO XREF                A\nSYXFINDX BALR  R2,0                SET UP BASE REG                    A\n         USING *,R2                                                   A\n.NOXRF88 ANOP                                                         A\n         SPACE 1\n*              GET SYMBOL, PAD WITH BLANKS, GET LENGTH OF SYMBOL      *\n*              THE FOLLOWING CODE IS COMMON TO BOTH SYFIND AND SYENT1 *\nSYFINDA  STC   RB,SYCOMP2+1        SAVE THE LENGTH INTO CLC\n         BCTR  RB,0                DECRMENT LENGTH FOR MOVE\n         MVC   SYMTEMP,AWBLANK     FILL WITH BLANKS FOR PADDING\n         STC   RB,SYMTEMPC         SAVE VALUE IN FRONT OF SYMBOL\n         STC   RB,*+5              PUT LENGTH INTO MVC INSTRUCTION\n         MVC   SYMTEMP($CHN),0(RA)           MOVE AND PAD SYMBOL\n         EJECT\n*              HASH SYMBOL, GET ADDRESS OF 1ST POINTER, GET 2ND HASH  *\n         LM    RD,RE,SYMTEMP       GET HALVES OF SYMBOL FOR HASHING\n         MR    RD,RD               MULT 1ST HALF * 2ND HALF OF SYMBOL\n         LM    RX,RB,SYREGS        GET WHOLE BLOCK OF REGS            L\n         NR    RD,RZ               COMPUTE PRIMARY HASH CODE\n         AR    RA,RD               GET ADDRESS OF  1ST HASHTAB ENTRY\n         USING SYMSECT,RA          NOTE USAGE OF DSECT FROM NOW ON\n*              FIRST HASH CODE COMPLETE. NOW GET SECONDARY HASH CODE. *\n         SR    RD,RD               CLEAR REG OUT BEFORE SHIFTING CODE\n         SLDL  RD,8                MOVE  8 BITS FOR SECONDARY CODE\n         LTR   RD,RD               IS SECONDARY CODE ZERO\n         BNZ   SYKEY2A             IF NOT ZERO,OK\n         LA    RD,255              PUT THIS VALUE FOR SECONDARY KEY\nSYKEY2A  STC   RD,SYCOMP1+1        PLACE SECONDARY KEY INTO CLI INST\n         BAL   RE,SYCOMP1          SKIP L 1ST TIME,SET UP ADDR IN REG\n         SPACE 1\n*              FOLLOWING THREE INSTRUCTIONS - MAIN SEARCH LOOP        *\n*              EACH LOOP CHECKS SECONDARY CODE OF NEXT SYMBOL IN LIST.*\nSYLOOP1  L     RA,SYLINK           GET NEXT POINTER\nSYCOMP1  CLI   SYHASH2,$CHN        COMPARE SECONDARY CODES\n         BCR   H,RE                BH SYLOOP1 - CONTINUE IF HIGH\n         BCR   L,RC                BL SYENTER OR SYRETA IF NOT PRESENT\n         SPACE 1\n*              SEARCH LOOP FOR ACTUAL SYMBOL COMPARISON               *\n*              THIS IS ONLY ENTERED FOR SYMBOLS WITH IDENTICAL CODES  *\nSYLOOP2  LR    RE,RA               DUPLICATE OLD POINTER VALUE\n         L     RA,SYLINK           GET @ NEXT POINTER ON CHAIN\nSYCOMP2  CLC   SYMTEMPC($CHN),SYCHARS        COMPARE # OF CHARS,SYMBOLS\n         BCR   E,RW                BE->SYRETB(PASS1),SYRET(PASS2)     L\n         EX    0,SYCOMP1          MAKE SURE SECONDARY IS SAME\n         BCR   E,RX                BE SYLOOP2 - KEEP CHECKING\n         LR    RA,RE               RESTORE REG POINTER FOR ENTRY\n         BR    RC                  B SYENTER OR SYRETA,DEPENDING\n         SPACE 1\n         SPACE 1                                                      L\n*        ENTERS PASS 2 WHEN SYMBOL IS IN SMBL TABLE (RB=0)            L\nSYRET    EQU   *                   ENTER WHEN SYMBOL PRESENT          L\n         AIF   (NOT &$XREF).NOXRF17                                   L\n         TM    AVXRFLAG,AVXRON     FLAG MAY HAVE BEEN DISARMED(XRCOLL)L\n         BZ    SYRETB              RETURN IF NOT ON (=0)              L\n         MVC   AVFWORK1(1),AVXRFLAG SET UP FOR REF COLLECT TESTING    L\n         NC    AVFWORK1(1),SYFLAGS  AND WITH SD= BITS                 L\n*  SEE IF MODIFY OR FETCH                                             L\n         TM    AVXRTYPE,AVXRFTCH   FETCH REFERENCE                    L\n         BZ    SYCKMOD             NO,MODIFY REF                      L\n         TM    AVFWORK1,AVXRSRFT   FETCH REFS?                        L\n         BZ    SYRETB              NO, RETURN                         L\n         B     SYXRCALL            GO COLLECTBREFS                    L\nSYCKMOD  TM    AVFWORK1,AVXRSRMD   COLLECT MOD REFS?                  L\n         BZ    SYRETB              NO,RETURN                          L\nSYXRCALL EQU   *                   CALLING XRCOLL TO COLLECT REFERENCEL\n         $CALL XRCOLL              CALL COLLECTIMG ROUTINE            L\n         SR    RB,RB               SET RETURN CODE                    L\n.NOXRF17 ANOP                                                         F\n         B     SYRETB              GO RETURN                          L\n*              ENTER NEW SYMBOL-MUST HAVE BEEN CALLED AT SYENT1       *\nSYENTER  CLI   SYMTEMPC,4          CHECK FOR LENGTH\n         BL    *+8                 L<=4==> LEAVE 4 IN RW-PREV LOADED\n         LA    RY,8                WILL NEED 8 BYTES                  L\n         LA    RC,SYMBOL-SYMSECT(RY)  GET LENGTH OF ENTRY             L\n         $ALLOCH RE,RC,SYOVER      GET NEEDED SPACE\n         L     RC,SYLINK           GET THE OLD SYLINK-SYHASH2 FIELD\n         ST    RE,SYLINK           SAVE THE POINTER INTO OLD POINTER\n         STC   RD,SYHASH2          SAVE 2ND HASH CODE IN THERE TOO\n         LR    RA,RE               MAKE DSECT LOCATED AT NEW AREA\n         ST    RC,SYLINK           STORE OLD SYLINK-SYHASH2 INTO NEW\n         MVC   SYVALUE(SYCHARS-SYVALUE),AWZEROS        ZERO FLAGS,ETC\n         STC   RY,*+5              MOVE LENGTH INTO MVC               L\n         MVC   SYCHARS($CHN),SYMTEMPC        MOVE LENGTH&SYMBOL OVER\n         SPACE  5                                                     A\n         AIF   (NOT &$XREF).NOXRF55  SKIP ID NO CROSS REF             A\n*  THE FOLLWING SECTION OF CODE IS USED FOR THE CROSS REFERENCE       A\n*   FACILITY.  THE BYTE SYFLAGS IS SET BY THE BITS IN AVXRFLAG, THIS  A\n*   ARE LATER TESTED TO SEE WHICH REFERENCES WE ARE COLLOECTING       A\n*                                                                     A\n         TM    AVXRFLAG,AVXRSDFT+AVXRSDMD   ARE WE COLLECTIOG DEFS    A\n         BZ    SYRETA              NO, RETURN                         A\n         LH    RB,AVXRCNT          GET # OF REFS COLLECTED            A\n         LA    RB,1(RB)            INCREASE BY ONE                    A\n         STH   RB,AVXRCNT          RESTORE IT                         A\n         IC    RB,AVXRFLAG         GET FLAG IN REG TO SET BITS        A\n         N     RB,=A(AVXRSDFT+AVXRSDMD)     FOR SETTING SYFLAGS       L\n         SRL   RB,2                MOVE TO RIGHT POSITION             A\n         IC    RY,SYFLAGS          PREPARE TO OR FLAGS                L\n         OR    RB,RY               SET PROPER BITS IN SYFLAGS         L\n         STC   RB,SYFLAGS          STORE IT IN FLAG                   A\n.NOXRF55 ANOP                                                         A\n         SPACE 1\n*              RETURN,SHOWING SYMBOL PRESENT/NOT PRESENT/OVERFLOW     *\nSYRETA   LA    RB,4                SHPW THE SYMBOL WAS NEW\nSYRETB   EQU   *                                                      A\n         AIF (NOT &$XREF).NOXRF18                                     F 1944322\n         $RETURN RGS=(R14-R6),SA=*     RETURN IF XREF IS ON           F\n         AGO   .NOXRF99                                               F\n.NOXRF18 ANOP                                                         F\n         $RETURN RGS=(R3-R6),SA=NO     RETURN IF XREF IS OFF          F\n.NOXRF99 ANOP                                                         F\n         EJECT\n*              EXIT FOR STORAGE EXCEEDED.  AS 999 MESSAGE.\nSYOVER   $GTAD REP,MOSTOP          GET ADDR OF EXIT\n         BR    REP                 GO THERE, NVER TO RETURN\n         SPACE 2\n**--> ENTRY: SYEND2   2   CLEANUP AT END OF PASS 2. . . . . . . . . . .\n*.       *** FUTURE USE - WILL COMPUTE SYMBOL TABLE STATISTICS.       .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nSYEND2   BR    RET                 RETURN,NOTHING EXISTS RIGHT NOW\n         SPACE 2\n* * * * * INTERNAL CONSTANTS                                          *\nSYREGS   DS    0F                  FOLLOWING IS REGISTER BLOCK FOR LM\nSYRX     DC    A(SYLOOP2)          ADCON FOR BRANCHES\nSYRY     DC    F'4'                FIRST GUESS FOR ROUNDED SYMBL LEN  L\nSYRZ     DC    A(4*(&$SYHASH-1))   SHIFTED MASK FOR 1ST HASH CODE\nSYRA     DS    A                   BEGINNING @ HASH INDEX TABLE\nSYRB     DC    F'0'               RETURN CODE= SYMBOL ALREADY PRESENT\n         SPACE 1\n* * * * * INTERNAL VARIABLES                                          *\nSYMTEMP  EQU   AVDWORK2            DS D, SPACE FOR SYMBOL\nSYMTEMPC EQU   SYMTEMP-1           FOR # CHARACTERS IN SYMBOL\n         AIF   (NOT &$XREF).NOXRF50                                   A\n         DROP  RAT,R2,RA           CLEAN UP USINGS                    A\n         LTORG                                                        A\n         AGO   .NOXRF51                                               A\n.NOXRF50 ANOP                                                         A\n         DROP  RAT,REP,RA          CLEAN UP USING SITUATION\n.NOXRF51 ANOP                                                         A\n         TITLE '*** UTOPRS - INCORE DISK UTILITY OPERATIONS ***'\n**--> CSECT: UTOPRS   1-2 UTILITY DATA SET ROUTINES . . . . . . . . . .\n*.             THIS MODULE PERFORMS ALL THE HANDLING WHICH WOULD      .\n*.       NORMALLY BE DONE USING SECONDARY STORAGE FOR INTERMEDIATE    .\n*.       SOURCE RECORDS AND FOR OBJECT CODE.  IT USES THE LOWER END   .\n*.       OF THE DYNAMIC CORE AREA TO STORE THE RECORD BLOCKS (RSBLOCK,.\n*.       RSCBLK,REBLK) RESULTING FROM THE SOURCE PROGRAM, AND PLACING .\n*.       THEM DURING PASS 1 SO THAT THE OBJECT CODE CAN BE OVERLAID   .\n*.       INTO THE SAME AREA.  I.E. IN NO CASE WILL THE RECORDS BLOCKS .\n*.       FOR A SOURCE STATEMENT BE PLACED NEARER THE BEGINNING OF THE .\n*.       AREA THAN THE OBJECT CODE RESULTING FROM THE STATEMENT.      .\n*.                                                                    .\n*.       CODE FOR THIS MODULE DEPENDS HEAVILY ON &$DISKU, WHICH       .\n*.       CAN ALLOW UTOPRS TO USE DISK FOR INTERMEDIATE STORAGE.       .\n*.       &$DISKU = 0 ==> EVERYTHING IN CORE (NORMAL ASSIST).          .\n*.       &$DISKU = 1 ==> USER HAS INCROEE/DISK OPTION (DISKU,NODISKU) .\n*.       &$DISKU = 2 ==> ALWAYS GO TO DISK, NO INCORE CODE EXISTS.    .\n*.                                                                    .\n*.       USES MACROS: $DISK,$RETURN,$SAVE                             .\n*.       CALLS XXXXDKOP,XXXXDKRD,XXXXDKE1,XXXXDKWT                    .\n*.       USES DSECTS: AVWXTABL                                        .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nUTOPRS   CSECT\n         $DBG  C0,*\n         ENTRY UTINT1,UTPUT1,UTEND1,UTGET2,UTPUT2,UTEND2\n         USING AVWXTABL,RAT        NOTE MAIN TABLE USING\n         SPACE 2\n**--> ENTRY: UTINT1   1   INITIALIZE UTILITY ROUTINES . . . . . . . . .\n*.       INITIALIZES UT POINTER TO BEGINNING OF RECORD BLOCK AREA.    .\n*.       USES DSECTS: AVWXTABL                                        .\n*.       USES MACROS: $RETURN,$SAVE                                   .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nUTINT1   $SAVE SA=NO\n         AIF   (&$DISKU NE 1).UTINADK  SKIP UNLESS DISKU OPTIONAL\n         TM    AVTAGS1,AJODISKU    IS DISK UTILITY ON?\n         BNO   UTINODSK            N/--NODISK--CONTINUE NORMALLY\n.UTINADK AIF   (&$DISKU LT 1).UTINODK        SKIP IF NO DISK\n         $DISK OP                  INITIALIZE DISK UTILITY\n         BM    UTINODSK            DISK DCB NOT OPEN-CANCEL DISK OPTION\n         LA    RE,AVBUFINC         GET @ OF BUFFE @\n         ST    RE,UTCONTRL         SAVE IN UTOPS CONTROL WORD\n         AIF   (&$DISKU EQ 2).UTINODK        SKIP UNNEC CODE FOR 2\n         MVI   UTBRCHNG+1,X'F0'    SET UTPUT1 TO ALWAYS BRANCH\n         B     UTDISKON            DISK IS ON--SKIP NEXT CODE\nUTINODSK EQU   *                   ESTABLISH DESTINATION LABEL\n         LA    RE,AVADDLOW         INITIALIZE UTCONTROL WORD\n         ST    RE,UTCONTRL         WITH @ OF AVADDLOW\n         MVI   UTBRCHNG+1,X'00'    SET BRANCH MASK TO 0\n.UTINODK AIF   (&$DISKU EQ 2).UTINODL        SKIP UNNNEC CODE FOR 2\n         MVI   UTP1RSB1+1,X'00'    MAKE INCORE CODE NOP FIRST TIME\n.UTINODL ANOP\n*              FOLLOWING CODE MAKES SURE REAL LOWEST @ OF USER PROGRAM\n*              IS MULTIPLE OF 32.  XXXXSNAP REQUIRES THIS TO GET\n*              REASONABLE COMPLETION DUMPS AND XDUMPS.\n*              OTHERWISE, CODE  MVC UTSTART,AVADDLOW WOULD SUFFICE.\nUTDISKON L     RE,AVADDLOW         GET LOWEST LIMIT VALUE\n         LA    RD,31               SET UPF ALIGNMENT VALUE\n         $ALIGR RE,RD              ALIGN TO 32-MULTIPLE\n         ST    RE,AVADDLOW         STORE BACK, NOW ALIGNED\n         ST    RE,AVRADL           STORE BACK, ALIGNED OK\n         AIF   (NOT &$RELOC).UTINREL        SKIP IF NO RELOCATION\n         TM    AVTAGS1,AJORELOC    SHOULD CODE BE RELOCATED\n         BZ    UTINTRET            NO,DON'T FIXUP ADDRESSES\n*              FOLLOWING CODE SIMULATES A USER START CARD WITH VALUE\n*        OF ACTUAL LOAD POINT IN MEMORY. RELOCATION IS THUS AUTOMATIC.\n         MVC   AVFENTER,AVADDLOW   MOVE IN LOWEST ADDR AS DEFAULT ENTRY\n         MVC   AVLOCLOW(20),AVFENTER   FILL IN @'S INSTEAD OF ZEROES\n         OI    AVTAGS1,$IBSTAR1    FLAG A START, FINISH FAKERY\n.UTINREL ANOP\nUTINTRET $RETURN SA=NO\n         AIF   (&$DISKU NE 2).UTINODM        SKIP IF NOT DISK ONLY\nUTINODSK $GTAD REP,MOSTOP          GET ADDR OF EXIT/OVERFL\n         BR    REP                 GO TO FLAG, END PASS 1\n.UTINODM ANOP\n         EJECT\n**--> ENTRY: UTPUT1   1   WRITE TO UTILITY DURING PASS 1. . . . . . . .\n*.       UTPUT1 MOVES ALL EXISISTING RECORD BLOCKS FOR A STATEMENT    .\n*.       INTO THE LOW END OF THE DYNAMIC CORE AREA, AT THE END OF     .\n*.       PROCESSING EACH STATEMENT DURING PASS 1.  THE BLOCKS ARE     .\n*.       NEVER PLACED CLOSER TO THE BEGINNING OF THE RECORD BLOCK     .\n*.       AREA THAN ANY OBJECT CODE WHICH COULD BE PRODUCED BY THE     .\n*.       STATEMENT.  THIS MAKES IT SAFE IN PASS 2 TO JUST MOVE        .\n*.       OBJECT CODE INTO THE SAME OVERALL AREA, WITH NO FEAR OF      .\n*.       OVERWRITING RECORD BLOCKS STILL NEEDED FOR THE SAME OR       .\n*.       LATER STATEMENTS.  THE BLOCKS ARE PLACED IN THIS ORDER:      .\n*.       RSBLOCK, (RCODBLK), (REBLK), (RSCBLK)   WITH THE BLOCKS      .\n*.       IN ( ) PLACED IF THEY EXIST.  **NOTE** BLOCKS RSBLOCK AND    .\n*.       RCODBLK ARE ALWAYS ALIGNED TO FULLWORD BOUNDARY.             .\n*.       CALLS MOSTOP                                                 .\n*.       USES DSECTS: AVWXTABL,RSBLOCK                                .\n*.       USES MACROS: $ALIGR,$CALL,$GLOC,$RETURN,$SAVE                .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n         SPACE 1\n* * * * * REGISTER ALLOCATION FOR UTPUT1  * * * * * * * * * * * * * * *\n*   RX = INTERNAL LINK REGISTER (FOR CALLING UTPMOVE).                *\n*   RY = CURRENT FREEAEA POINTER (AVADDLOW)                           *\n*   RZ = CURRENT HIGH END POINTER (AVADDHIH)                          *\n*   RA = 3     USED TO ALIGN LOCATIONS TO FULLWORD BOUNDARY($ALIGR)   *\n*   RB = BYTE REGISTER FOR INSERTS(HI-ORDRR 3 BYTES = 0).             *\n*   RC = VRSBPT    (FROM AVWXTABL)                                    *\n*   RD = PARAMATER REGISTER FOR UTPMOVE INTERNAL SUBR (@ BLOCK).      *\n*   RE = WORK REGISTER                                                *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nUTPUT1   $SAVE RGS=(R3-R6),SA=NO   RW-RZ, USE AS FEW REGS AS CAN\n         OI    AVPRINT1,AVPRSAVE   MAKE SURE SAVED FROM NOW ON\n         LA    RA,3                SET UP ALIGNMENT VALUE\n         SR    RB,RB               CLEAR FOR INSERTIONS\n         AIF   (&$DISKU NE 1).UTPT1A   NO USER OPTION ON DISK UTILITY\n         L     RW,UTCONTRL         SET UP CONTROL WITH USER OPTION\n         LM    RY,RZ,0(RW)         LOAD FROM EITHER AVADDLOW OR\n*                                      AVBUFINC\nUTBRCHNG BC     $,UTPNOFF           ALWAYS/NEVER BRANCH-DISK/NODISK\n*                                      AROUND NORMALL PROCESSING IF DKU\n*                                      NO BRANCH IF NOT DISK\n.UTPT1A  AIF   (&$DISKU NE 2).UTPT1B   NO DISK AT ALL\n         LM    RY,RZ,AVBUFINC      ALWAYS DISK, GET BUFFER PARMS\n         AGO   .UTPT1DK            SKIP ALL INCORE ONLY CODE\n.UTPT1B  AIF   (&$DISKU NE 0).UTPT1X   SKIP WHEN DISK UTILITY ON\n         LM    RY,RZ,AVADDLOW      GET LOW-HIGH CORE POINTERS\n.UTPT1X  ANOP\n         $GLOC RE                  GET LOCATION COUNTER VALUE\n         S     RE,AVLOCLOW         GET OFFSET\nUTP1RSB1 BC    $,UTP1RSBX          SKIP IF NOT 1ST INCORE RSBLOCK SAVED\n         MVI   UTP1RSB1+1,X'F0'    MAKE NOP A BRANCH AFTER 1ST TIME\n         MVC   UTG2PT,AVADDLOW     INIT @ 1ST RSBLOCK, IF  ANY INCORE\nUTP1RSBX EQU   *                   BRANCH HERE AFTER 1ST TIME THRU\n         A     RE,AVRADL           ADD BASE @ OF UT CORE AREA\n         SR    RE,RY               GET OFFSET REQUIRED,IF ANY\n         BNP   UTPNOFF             BRANCH IF NO FURTHER OFFSET NEEDED\n         TM    AVTAGS1,$IBDSEC1+AJNLOAD     IS EITHER DSECT OR NOLOAD\n         BNZ   UTPNOFF             DSECT OR NOLAD, SO NO OFFSET REQUIRD\n         SPACE 1\n*              IF FALLS THRU-MUST OFFSET NEXT ENTRY BEYOND LOCCNTR    *\n         $ALIGR RE,RA              ROUND OFFSET TO FULLWORD MULTIPLE\n         AR    RE,RY               GET BACK ACTUAL @ FOR NEXT RSB TO GO\n         CR    RE,RZ               MAKE SURE WE HAVE ROOM\n         BNL   UTPOVER             DISASTER EXIT-OVERFLOW\n         ST    RE,0(RY)            SAVE ADDRESS OF NEXT BLOCK\n         LR    RY,RE               MOVE NEW POINTER OVER\n.UTPT1DK ANOP\n         SPACE 1\n*              GET ALL THE RECORD POINTERS AND MOVE EXISTING ONES.    *\nUTPNOFF  L     RC,AVRSBPT          GET ONLY DEFINITE EXISTING BLOCK\n         USING RSBLOCK,RC          NOTE RECORD SOURCE BLOCK USING\n         AIF   (NOT &$XREF).NOXRF11  SKII IF NO XREF                  A\n         TM    RSBFLAG,$RSBNPNN    IS STMT TO BE NUMBERED             A\n         BZ    UTPTNPRC            NO, DON'T INCREMENT                A\n         AP    AVXRLNCN,AWP1       APP 1 TO LINE COUNTER(CROSS REF)   A\nUTPTNPRC EQU   *                                                      A\n.NOXRF11 ANOP                                                         A\n         LR    RD,RC               MOVE PTR OVER FOR UTPMOVE\n         BAL   RX,UTPMOVE          CALL MOVER SUBROUTINE\n         SPACE 1\n         $ALIGR RY,RA              GET FULLWORD ALIGNMENT\n         TM    RSBFLAG,$RCBX       DO WE HAVE A RCB WITH THIS\n         BZ    UTPREB              NO RCB-TRY FOR REB\n         L     RD,AVRCBPT          GET @ RCODBLK\n         BAL   RX,UTPMOVE          CALL MOVER ROUTINE\n         SPACE 1\nUTPREB   TM    RSBFLAG,$REBX       DO WE HAVE A REB\n         BZ    UTPRSC              NO REB,LOOK FOR  RSCB\n         L     RD,AVREBPT          GET @ REBLK (AVREBLK)\n         BAL   RX,UTPMOVE          CALL MOVER ROUTINE\n         SPACE 1\nUTPRSC   TM    RSBFLAG,$RSCX       TEST FOR RSC\n         BZ    UTPEND1             NO RSC-SKIP TO END\n         L     RD,AVRSCPT          GET @ RSCBLK\n         BAL   RX,UTPMOVE          CALL MOVER ROUTINE\n         DROP  RC                  NO LONGER NEEDED FOR RSB\n         SPACE 1\nUTPEND1  $ALIGR RY,RA              ALIGN POINTER TO FULLWORD\n         AIF   (&$DISKU NE 0).UTPT1D\n         ST    RY,AVADDLOW         STORE POINTER BACK\n         AGO   .UTPT1F\n.UTPT1D  AIF   (&$DISKU NE 1).UTPT1E   GO TO ALWAYS DISK CODE\n         ST    RY,0(RW)            STORE POINTER BACK\n         AGO   .UTPT1F\n.UTPT1E  ST    RY,AVBUFINC         STORE POINTER BACK\n.UTPT1F  ANOP\nUTPRET   $RETURN RGS=(R3-R6),SA=NO       RETURN\n         SPACE 2\n**--> INSUB: UTPMOVE    MOVE 1 RECORD BLOCK INTO DYNAMIC AREA + + + + +\n*+       ENTRY CONDITIONS                                             +\n*+  RD = ADDRESS OF THE BLOCK TO BE MOVED. ITS FIRST BYTE GIVES LEN-1 +\n*+  RY = ADDRESS WHERE BLOCK SHOULD BE PLACED                         +\n*+       EXIT CONDITIONS                                              +\n*+  RY = ADDRESS OF NEXT FREE SPACE FOR BLOCKS.                       +\n*+  + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +\nUTPMOVE  IC    RB,0(,RD)           GET LENGTH-1 OF BLOCK\n         LA    RE,1(RB,RY)         INCREMENT @ PTR BY WHOLE LENGTH\n         CR    RE,RZ               MAKE SURE WE HAVE ROOM\n         BNL   UTPOVER             NO MORE ROOM-DISASTER\n         STC   RB,*+5              STORE LENGTH-1 INTO MVC INSTUCTION\n         MVC   0($,RY),0(RD)       MOVE BLOCK INTO DYNAMIC AREA\n         LR    RY,RE               MOVE UPDATED LOW END POINTER BACK\n         BR    RX                  RETURN TO CALLING SECTION OF UTPUT1\n         SPACE 1\n         AIF   (&$DISKU NE 0).UTPOVRA\nUTPOVER  $GTAD REP,MOSTOP          GET ADDR OF EXIT - AS999 MESSAGE\n         BR    REP                 GO THERE, ENDING PASS 1\n         AGO   .UTPOVRB\n.UTPOVRA AIF   (&$DISKU EQ 1).UTPOVRC  SKIP IF DISK UTILITY OPTIONAL\nUTPOVER  $DISK WT                  CALL DISK UTILITY TO WRITE A BLOCK\n         LM    RY,RZ,AVBUFINC      GET PARMS FROM CONTROL BLOCK\n         B     UTPNOFF             PROCESS AT UTPNOFF\n         AGO   .UTPOVRB\n.UTPOVRC ANOP\nUTPOVER  TM    AVTAGS1,AJODISKU    IS DISK ENABLED?\n         BNO   UTPEXIT             NOT ENABLED  TAKE EXIT\n         $DISK WT                  DISK ENABLED  WRITE A BLOCK TO DISK\n         LM    RY,RZ,AVBUFINC      GRAB SOME CONTROL INFORMATION\n*                                  ADDRESS OF NEXT BUFFER TO BE FILLED\n         B     UTPNOFF             PROCEES AT UTPNOFF\nUTPEXIT  $GTAD REP,MOSTOP          GET ADDRESS OF EXIT--AS999 MESSAGE\n         BR    REP                 TAKE EXIT NOW\n.UTPOVRB ANOP\n         EJECT\n**--> ENTRY: UTEND1   1   END PASS 1, PREPARE FOR PASS 2 OF ASSEMBLER .\n*.       UTEND1 RESETS CORE POINTERS AND CALCULATES RELOCATION FACTOR..\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nUTEND1   $SAVE SA=NO\n         L     RD,AVRADL           GET @ 1ST BYTE WHERE OBJ CODE GOES\n         AIF   (&$DISKU EQ 2).UTE1A1  SKIP IF NO INCORE CODE AT ALL\n         L     RE,AVADDLOW         CURRENT ENDING POINTER\n         ST    RE,UTG2END          PTR TO END OF CORE USED (IF INCORE)\n*              FOLLOWING STMT ONLY NEEDED IF UNUSED CORE FILL DONE.\n         ST    RD,UTP2LAST         SAVE AVRADL AS INIT @ LAST CODE LOAD\n         S     RD,AVLOCLOW         GET RELOCATION FACTOR\n         ST    RD,AVRELOC          SAVE THE RELOCATION FACTOR\n         AIF   (&$DISKU EQ 0).UTRET    SKIP WHEN NO DISK AT ALL\n         AIF   (&$DISKU EQ 2).UTALW    SKIP WHEN ALWAYS DISK\n         TM    AVTAGS1,AJODISKU    IS DISK UTILITY ON?\n         BNO   UTRETE1             NO  RETURN AFTER THIS CODE\n         SPACE 1\n*        IF DISKU OPTION ON, MAKE SURE OBJECT CODE FITS INTO THE      *\n*        ALLOWED AREA.  (THIS CHECK IS MADE CONSTANTLY DURING UTPUT1  *\n*        FOR THE INCORE VERSION).  THIS ASSUMES AVADDHIH WILL REMAIN  *\n*        CONSTANT FROM THIS POINT ON.  IF AVADDHIH MAY BE CHANGED,    *\n*        IT WILL BE NECESSARY TO CHECK DURING UTPUT2 .                *\n         SPACE 1\n         A     RD,AVLOCHIH         RD = REAL @ OF END OF OBJ CODE\n         C     RD,AVADDHIH         CHECK AGAINST LOWER LIMIT OF UPPER\n         BNH   *+12                IF NEEDED <= AVAIL, SKIP, OK\n         OI    AVTAGS3,AVOVERFL    SHOW STORAGE EXCEEDED\n         OI    AVTAGS1,AJNLOAD     KILL OBJECT CODE GENERATION\n         SPACE 1\n.UTALW   $DISK E1                  CALL END-PASS-1 FIX ROUTINE\n         LR    RD,RE               DUPLICATE RE\n         STM   RD,RE,UTG2PT        SET POINTERS TO FORCE CALL TO DISKU\n.UTRET   ANOP\nUTRETE1  $RETURN SA=NO             RETURN TO MASTER CONTROL\n         EJECT\n**--> ENTRY: UTGET2   2   GET FROM UTILITY DUIRNG PASS 2. . . . . . . .\n*.       UTGET2 IS CALLED DURING PASS 2 TO RETRIEVE THE ADDRESSES OF  .\n*.       THE SET OF RECORD BLOCKS BELONGING TO THE NEXT STATEMENT. A  .\n*.       CHECK IS REQUIRED FOR ANY OFFSET ADJUSTMENT MADE BY UTPUT1,  .\n*.       WHICH MADE SURE THAT NO RECORD BLOCK COULD BE OVERLAID BY    .\n*.       ITS OWN CODE.\n*.       EXIT CONDITIONS                                              .\n*.  RC = @ RSBLOCK (THE ONLY BLOCK DEFINITELY PRESENT).               .\n*.  RE = 0    NORMAL RETURN.      RE = 4 ==> END-FO-FILE-QUIT         .\n*.  AVRSBPT,AVRCBPT,AVRSCPT NOW POINT TO THEIR BLOCKS, IF THEY EXIST. .\n*.  AVREBLK HAS HAD THE REBLK MOVED INTO IT, IF THERE WAS ONE.        .\n*.  AVREBPT IS NOT CHANGED, STILL POINTS AT AVREBLK, AS ALWAYS.       .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n         SPACE 1\n* * * * * REGISTER ALLOCATION FOR UTGET2  * * * * * * * * * * * * * * *\n*   RA = 3     MASK FOR DOING FULLWORD ALIGNMENT.                     *\n*   RB = BYTE REGISTER FOR INSERTIONS (HI-ORDER 3 BYTES = 0).         *\n*   RC = @ RSBLOCK, USED TO TEST FOR EXISTENCE OF OTHERS.             *\n*   RD = CURRENT @ NEXT BLOCK, INITIALIZED = UTG2PT                   *\n*   RE = UTG2END-LIMIT @, USED TO DETERMINE END OF RECORDS.           *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n         AIF   (&$ASMLVL).UTOS     SKIP FOR OS GENERATION\nUTDKDISP EQU   8                   GEN DOS BUFFER DISP\n         AGO   .UTGLVL\n.UTOS    ANOP\nUTDKDISP EQU   0                   GEN OS BUFFER DISP\n.UTGLVL  SPACE 1\nUTGET2   $SAVE RGS=NO,SA=NO        USE ONLY TEMP REGS\n         LA    RA,3                SET UP FOR FULLWORD ALIGNMENT\n         SR    RB,RB               CLEAR FOR INSERTIONS\n         LM    RC,RD,UTG2PT        UTG2PT-UTG2END VALUES FOR COMPARE\n         CR    RC,RD               COMPARE CURRENT POINTER TO END @\n         BNL   UTG2DONE            NO MORE RECORDS-BRANCH-DONE\n         SPACE 1\n*        THE FOLLOWING CHECKS FOR AN OFFSET ADJUSTMENT @ FOLLWING THE *\n*        LAST RSB, INSTEAD OF ANOTHER RSB.  THE 1ST BYTE FOR AN OFFSET*\n*        WILL =0, BUT AN RSBLENG NEVER = 0.\n         CLI   0(RC),0             IS NEXT BYTE 0, IF SO RC==> OFFSET@\n         BNE   *+8                 BRANCH IF NORMAL RSB FOLLOWS\n         L     RC,0(RC)            OFFSET @ ==> NEXT RSBLOCK, LOAD IT\nUTG2DKCT ST    RC,AVRSBPT          STORE THE @ OF THE RSBLOCK\n         USING RSBLOCK,RC          NOTE ADDRESS\n         SPACE 1\n         IC    RB,RSBLENG          GET THELENGTH-1 OF BLOCK\n         LA    RD,4(RB,RC)         MOVE @ OVER, ADD LENGTH+ALIGN\n         OR    RD,RA               MAKE LAST 2 BITS 1'S\n         SR    RD,RA               HAVE ROUNDED UP TO NEXT FULLWORD B\n         SPACE 1\n         TM    RSBFLAG,$RCBX       DO WE HAVE RCB\n         BZ    UTG2REB             NO RCB-SKIP\n         ST    RD,AVRCBPT          STORE @ RCODBLK\n         USING RCODBLK,RD          NOTE POINTER\n         IC    RB,RCLENG           GET LENGTH-1 OF RCODBLK\n         LA    RD,1(RB,RD)         INCREMENT POINTER BY FULL LENGTH\n         SPACE 1\nUTG2REB  TM    RSBFLAG,$REBX       DOES REB EXIST\n         BZ    UTG2RSC             NO IT DOESN'T - SKIP\n         USING REBLK,RD            NOTE PTR TO ERROR BLOCK\n         IC    RB,REBLN            GET LENGTH-1 OF THE BLOCK\n         STC   RB,*+5              STORE LENGTH-1 INTO NEXT INSTR\n         MVC   AVREBLK($),REBLK    MOVE THE ERROR BLOCK OVER\n         LA    RD,1(RB,RD)         INCREMENT POINTER TO NEXT POSITION\n         SPACE 1\nUTG2RSC  TM    RSBFLAG,$RSCX       DOES RECORD SOURCE CODE BLOCK EXIST\n         BZ    UTG2EXIT            NO,SKIP OVER\n         ST    RD,AVRSCPT          STORE @ RSCBLK WHERE NEEDED\n         USING RSCBLK,RD           NOTE POINTER\n         IC    RB,RSCLENG          GET LENGTH-1 OF RSCBLK\n         LA    RD,1(RB,RD)         INCREMENT BY LENGTH TO NEXT POSITION\n         SPACE 1\nUTG2EXIT $ALIGR RD,RA              ALIGN TO FULLWORD FOR NEXT RSBLOCK\n         ST    RD,UTG2PT           STORE THE POINTER BACK, NEXT RSBLOCK\n         SR    RE,RE               CLEAR TO SHOW NORMAL\n         $DBG  C0,SNAP\nUTG2RET  $RETURN RGS=NO,SA=NO      RETURN\nUTG2DONE EQU   *                   ESTABLISH LABEL\n         AIF   (&$DISKU GT 1).UTG2DA   DISK ONLY\n         AIF   (&$DISKU LT 1).UTG2DB   USER OPTION--DISK OR NO DISK\n         TM    AVTAGS1,AJODISKU    IS DISK ON?\n         BNO   UTG2EOF             NO--SET E-O-F FLAG\n.UTG2DA  ANOP\n         $DISK RD                  GET NEXT BUFFER OF INFO\n         BM    UTG2EOF             ON REAL EOF--SET FLAG AND RTURN\n         L     RC,AVBUFF@          GET BUFFER ADDRESS\n         LR    RD,RC               DUPLICATE FOR BUFFER LENGTH\n         A     RD,0+UTDKDISP(RC)   ADD IN BUFFER USED LENGTH\n         LA    RC,4+UTDKDISP(RC)   BUMP PAST LENGTH USED WORD\n         ST    RD,UTG2END          STORE ENDING ADDRESS\n         B     UTG2DKCT            GO BACK AND PROCESS\n.UTG2DB  ANOP\nUTG2EOF  LA    RE,4                SHOW E-O-F  NO MORE SOURCE\n         B     UTG2RET\n         DROP  RC,RD               KILL THESE USINGS\n         EJECT\n**--> ENTRY: UTPUT2       PRODUCES AND RELOCATES OBJECT CODE. . . . . .\n*.       UTPUT2 MOVES OBJECT CODE PRODUCED BY THE ASSEMBLER INTO IT   .\n*.       PROPER LOCATION IN THE OBJECT PROGRAM, APPLYING DUPLICATION  .\n*.       FACTOR AT THIS TIME, IF NECESSARY.  BECAUSE OF THE WAY THE   .\n*.       ASSIST INTERPRETER EXECUT WORKS, AND BECAUSE OF THE PSEUDO   .\n*.       START CARD USED BY THE REPLACE MONITOR, NO RELOCATION NEED   .\n*.       EVER BE DONE BY THIS PROGRAM, MAKING IT FAST AND SMALL.  THE .\n*.       MODULE ALSO FILLS IN  AREAS OF THE OBJECT PROGRAM HAVING NO  .\n*.       CODE WITH CHARACTER 5'S, WHICH HELP REDUCE THE SIZE OF ANY   .\n*.       COMPLETION DUMPS, AND AID DEBUGGING  (X'F5F5F5' SHOWS UP     .\n*        DISTINCTIVELY IN A DUMP, AND IS NOT A LEGAL INSTRUCTION).    .\n*.       ENTRY CONDITIONS                                             .\n*.  RA = PROGRAM LOCATION COUNTER OF THE OBJECT CODE                  .\n*.  RC = @ ASSEMBLED CODE IN MEMORY                                   .\n*.  RD = LENGTH-1 OF OBJECT CODE                                      .\n*.  RE = DUPLICATION FACTOR FOR THE CODE - 1 OR GREATER               .\n*.       USES DSECTS: AVWXTABL                                        .\n*.       USES MACROS: $RETURN,$SAVE                                   .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nUTPUT2   $SAVE RGS=NO,SA=NO        NO REGS NEEDED\n         SPACE 1\n         TM    AVTAGS1,$IBDSEC1+AJNLOAD     DSECT OR NOLOAD\n         BNZ   UTP2RET             RETURN IF SO, DON'T LOAD ANY CODE\n         A     RA,AVRELOC          ADD RELOCATION FACTOR TO ADDRESS\n         STC   RD,UTP2MOVE+1       STORE LENGTH-1 INTO MVC IMMEDIATLY\n         SPACE 1\n*              FOLLOWING SECTION PLACES CHARACTER 5'S IN ANY UNUSED   *\n*        LOCATIONS OF MEMORY, EXCEPT POSSIBLY A BLOCK OF DS AREAS     *\n*        ENDING PROGRAM, WITH NO FOLLOWING LITERALS, DC'S.            *\n*        SECTION NOT REALLY NECESSARY, COULD BE REMOVED WITH NO HARM. *\n         LR    RB,RA               DUPLICATE VALUE OF CODE @\n         S     RB,UTP2LAST         SUB @ LAST CODE, GET # FILLED\n         BNP   UTP2MOVE            SKIP, NO PADDING NEED BE DONE\n         SPACE 1\n         STM   R1,R2,24(R13)       SAVE WORK REGISTERS\n         L     R2,UTP2LAST         GET STARTING @ AREA TO BE TWOED\n         MVI   0(R2),$PRGFILC      PUT IN CORE FILL CHARACTER\n         LA    R1,256              SET UP FOR LENG FILL IF NEEDED\n         BCT   RB,UTP2ZB           DECREMENT COUNT 1, BRANCH >1 ORIG\n         B     UTP2NT              1 BYTE ONLY, ALREADY DONE,QUIT\n         SPACE 1\nUTP2ZA   MVC   1(256,R2),0(R2)     PROPAGATE 5'S FOR 256 BYTES\n         AR    R2,R1               ADD 256 TO BEGINNING @ OF CODE\n         SR    RB,R1               DECREMENT COUNT REMAINING BY 256\n         BZ    UTP2NT              BRANCH IF NOTHING LEFT TO DO\n         SPACE 1\nUTP2ZB   CR    RB,R1               COMPARE COUNT REMAINING TO 256\n         BH    UTP2ZA              IF STILL HIGH, FILL ANOTHER 256\n         BCTR  RB,0                DECREMENT COUNT TO LENGTH-1 FOR MVC\n         STC   RB,*+5              STORE LENGTH-1 INTO MVC\n         MVC   1($,R2),0(R2)       PROPAGATE 5'S FOR LAST TIME\nUTP2NT   LM    R1,R2,24(R13)       RELOAD DESTOYED WORK REGS\n*              END OF CORE-FILLING SEGMENT.                           *\n         EJECT\n*              FOLLOWING 3 STMTS DO ACTUAL CODE LOAD/DUPLICATION.\nUTP2MOVE MVC   0($CHN,RA),0(RC)    MOVE OBJECT CODE OVER\n         LA    RA,1(RD,RA)         BUMP ADDRESS TO NEXT LOCATION\n         BCT   RE,UTP2MOVE         DUPLICATE AS MANY TIMES AS NEEDED\n         SPACE 1\n*              FOLLOWING 3 STMTS USED ONLY FOR CORE-FILL ACTIONS.     *\n         C     RA,UTP2LAST         WAS END @ OF CODE HIGHEST SO FAR\n         BNH   *+8                 SKIP  IF NOT SO\n         ST    RA,UTP2LAST         STORE NEW HIGHEST CODE @\n         SPACE 1\n         $DBG  C0,*\nUTP2RET  $RETURN SA=NO\n         SPACE 2\n**--> ENTRY: UTEND2   2   CLEANUP AFTER PHASE 2 DONE. . . . . . . . . .\n*.       UTEND2 IS CALLED AT THE END OF ASSEMBLY PASS 2.  IT ASSURES  .\n*.       THAT ANY DS STATEMENTS ENDING THE PROGRAM WILL BE FILLED IN  .\n*.       WITH 5'S, LIKE ANY OTHER DS'S FOLLOWED BY CODE (THE VERY LAST.\n*.       STRING OF DS'S MAY NOT BE CAUGHT BY UTPUT2).  IT DOES THIS BY.\n*.       CALLING UTPUT2 WITH SOME NONEXISTENT OBJECT CODE.            .\n*.       CALLS UTPUT2                                                 .\n*.       USES DSECTS: AVWXTABL                                        .\n*.       USES MACROS: $SAVE                                           .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n         SPACE 1\nUTEND2   $SAVE RGS=NO,SA=NO        NO REGS NEED BE SAVED\n         NI    AVTAGS1,255-$IBDSEC1         MAKE SURE DSECT FLAG OFF\n         L     RA,AVLOCHIH         GET @ 1 BYTE BEYOND HIGHEST LOCNTR\n         LA    RC,=AL1($PRGFILC)   SET @ 1 BYTE CORE FILL CHARACTER\n         SR    RD,RD               SHOW LENGTH-1 OF 0 FOR FAKE CODE\n         LA    RE,1                SHOW DUPLICATION FACTOR OF 1\n         $GTAD REP,UTPUT2          GET ADCON FOR OTHER SECTION\n         BR    REP                 GO TO UTPUT2, IT WILL FILL IF NEEDED\n         LTORG\n         SPACE 2\n* * * * * INTERNAL VARIABLES                                          *\n*              USED BY PASS 1                                         *\n         AIF   (&$DISKU NE 1).UTCNTRL  SKIP UNLESS DISK IS OPTION\nUTCONTRL DS    F                   @ AVBUFINC/AVADDLOW-DEPENDS ON DISKU\n.UTCNTRL ANOP\n*              USED BY PASS 2                                         *\nUTG2PT   DS    A                   POINTER TO NEXT RSBLOCK TO BE GOTTEN\nUTG2END  DS    A                   POINTER TO END OF CORE AREA USED\nUTP2LAST DS    A                   @ HIGHEST CODE LOADED,**FILL USE****\n         DROP  RAT,REP\n         TITLE '*** VWXTABL - MAIN ASSEMBLER CONTROL TABLE ***'\n**--> CSECT: VWXTABL    MAIN ASSEMBLER COMMUNICATION TABLE. . . . . . .\n*.       THIS IS ACTUAL TABLE THAT AVWXTABL DSECT CORREPSONDS TO.     .\n*.       SEE AVWXTABL COMMENTS FOR DESCRIPTION.                       .\n*.       USES MACROS: WCONG                                           .\n*.       NAMES: X------, W------, V------                             .\n*.  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n         SPACE 1\nVWXTABL  CSECT\n         SPACE 1\n* * * * * NAMES IN AVWXTABL DSECT ARE SAME, EXCEPT WITH A'S PREFIXED  *\n* * * * * AVWXTABL SECTION X - ADDRESS CONSTANTS  * * * * * * * * * * *\nX$BASE   DS    0A                  BASE ADDRESS FOR OFFSETS TO ROUTINES\n*              *** BROPS2 ENTRY POINTS ***                            *\nXBRINIT  DC    V(BRINIT)           BASE-REG INITIALIZATION\nXBRUSIN  DC    V(BRUSIN)           BASE-REG SET UP USING VALUE\nXBRDROP  DC    V(BRDROP)           BASE REG DROP A REGISTER\nXBRDISP  DC    V(BRDISP)           BASE REG GET BASE-DISPLACEMENT\nXC$BASE  DS    0F                  BASE ADDRESS FOR CONSTANT ADDR OFFSE\n*              *** CACONS ENTRY POINTS ***                            *\nXCACON1  DC    V(CACON1)           SCAN A-TYPE CONST\nXCACON2  DC    V(CACON2)           ASSEMBLE A-TYPE CONSTANT\n*              *** CBCONS ENTRY POINTS ***                            *\nXCBCON1  DC    V(CBCON1)           SCAN BINARY CONSTANT\nXCBCON2  DC    V(CBCON2)           ASSEMBLE BINARY CONSTANT\n*              *** CCCONS ENTRY POINTS ***                            *\nXCCCON1  DC    V(CCCON1)           SCAN CHARACTER CONSTANT\nXCCCON2  DC    V(CCCON2)           ASSEMBLE CHARACTER CONSTANT\n*              *** CDECNS ENTRY POINTS ***                            *\nXCDECN1  DC    V(CDECN1)           SCAN FLOATING PT CONST\nXCDECN2  DC    V(CDECN2)           ASSEMBLE FLOATING PT CONSTANT\nXCDCON1  EQU   XCDECN1             MAKE EQUATE FOR STANDARD NAMES\nXCECON1  EQU   XCDECN1             MAKE EQUATE FOR STANDARD NAMES\n*              *** CFHCNS ENTRY POINTS ***                            *\nXCFHCN1  DC    V(CFHCN1)           SCAN FIXED POINT CONSTANT\nXCFHCN2  DC    V(CFHCN2)           ASSEMBLE FIXED POINT CONSTANT\nXCFCON1  EQU   XCFHCN1             MAKE EQUATE FOR STANDARD NAMES\nXCHCON1  EQU   XCFHCN1             MAKE EQUATE FOR STANDARD NAMES\n*              *** CONSTANT PROCESSOR CONTROL ROUTINES ***            *\nXCNDTL2  DC    V(CNDTL2)           PASS 2 CONSTANT PROCESSING\nXCODTL1  DC    V(CODTL1)           DUPLICATION FACTOR-TYPE-LENGTH PROC\n*              *** CPCONS ENTRY POINTS ***                            *\nXCPCON1  DC    V(CPCON1)           SCAN PACKED CONSTANT\nXCPCON2  DC    V(CPCON2)           ASSEMBLE PACKED CONSTANT\n*              *** CVCONS ENTRY POINTS ***                            *\nXCVCON1  DC    V(CVCON1)           SCAN V-TYPE CONSTANTS\nXCVCON2  DC    V(CVCON2)           ASSEMBLE V-TYPE ADDRESS CONSTANTS\n*              *** CXCONS ENTRY POINTS ***                            *\nXCXCON1  DC    V(CXCON1)           SCAN HEXADECIMAL CONSTANTS\nXCXCON2  DC    V(CXCON2)           ASSEMBLE HEXADECIMAL CONSTANTS\n*              *** CZCONS ENTRY POINTS ***                            *\nXCZCON1  DC    V(CZCON1)           SCAN ZONED CONSTANTS\nXCZCON2  DC    V(CZCON2)           ASSEMBLE ZONED CONSTANTS\n*              *** ERRORS ENTRY POINTS ***                            *\nXERRTAG  DC    V(ERRTAG)           FLAG ERROR\nXERRLAB  DC    V(ERRLAB)           ERROR FLAG FOR A LABEL\n*              *** ESDOPRS ENTRY POINTS ***                           *\nXESINT1  DC    V(ESINT1)           ESD ROUTINE INITIALIZATION\nXESCSEC  DC    V(ESCSEC)           CSECT,START, OR DSECT\nXESENX1  DC    V(ESENX1)           ENTRY OR EXTRN - PASS 1\nXESENX2  DC    V(ESENX2)           PASS 2 ENTRY AND EXTRN\n*              *** EVALUT - EXPRESSION EVALUATOR ***                  *\nXEVALUT  DC    V(EVALUT)           GENERAL EXPRESSION EVALUATION ROUT\n*              *** 2ND LEVEL PROCESSOR CSECTS ***                     *\nXIAMOP1  DC    V(IAMOP1)           MACHINE OPCODES-PASS 1\nXIBASM1  DC    V(IBASM1)           ASSEMBLER OPCODES - PASS 1\nXICMOP2  DC    V(ICMOP2)           MACHINE OPCODES - PASS 2\nXIDASM2  DC    V(IDASM2)           ASSEMBLER OPCODES - PASS 2\n*              *** INPUT1 ENTRY POINTS ***                            *\nXINCARD  DC    V(INCARD)           INPUT CARD PROCESSOR\n*              *** LTOPRS ENTRY POINTS ***                            *\nXLTINT1  DC    V(LTINT1)           LITERAL TABLE INITIALIZATION\nXLTENT1  DC    V(LTENT1)           ENTER A LITERAL INTO POOL\nXLTDMP1  DC    V(LTDMP1)           RETURN LITERAL LENGTH-PASS 1\nXLTEND1  DC    V(LTEND1)           END PASS 1 FOR LITERAL TABLE\nXLTGET2  DC    V(LTGET2)           GET ADDRESS OF LITERAL\nXLTDMP2  DC    V(LTDMP2)           PRODUCE LITERAL RECORDS-PASS 2\n         AIF   (NOT &$MACROS).XNOMAC        SKIP IF NO MACROS\n*              ** MACROS ENTRY POINTS **                              *\nXMACINT  DC    V(MACINT)           MACRO INITIALIZATION ENTRY\nXMACRO1  DC    V(MACRO1)           BUILD MACRO DEFINITION TABLES\nXMEXPND  DC    V(MEXPND)           MACRO EXPANSION ENTRY\nXMCBODY  DC    V(MCBODY)           PROCESS MACRO DEFINITION BODY\nXMACSCN  DC    V(MACSCN)           SCAN MACRO STATEMENT\nXMACFND  DC    V(MACFND)           SEARCH MACRO LIBRARY\nXMCVSCN  DC    V(MCVSCN)           SCAN VARIABLE SYMBOL\nXMCSCOP  DC    V(MCSCOP)           SCAN STANDARD OPERAND\nXMCGTST  DC    V(MCGTST)           MOVE STRING TO LOW CORE\nXMCSYSR  DC    V(MCSYSR)           SEARCH MACRO LIBRARIES FOR VAR SYMB\nXMACLEX  DC    V(MACLEX)           MACRO STMT LEX ANALYSIS\nXMCGNCD  DC    V(MCGNCD)           MACRO DEFINITION CODE GENERATION\nXMXMVSR  DC    V(MXMVSR)           MOVE GENERATED STMT TO HIGH CORE\nXMXERRM  DC    V(MXERRM)           GENERATE ERROR MESSAGE\nXMCDTRM  DC    V(MCDTRM)           CHAR TO BINARY CONVERSION\nXMCATRM  DC    V(MCATRM)           TEST FOR ATTRIBUTE\n         DS    2V                  SPACE FOR MACRO ENTRY POINTS\n.XNOMAC  ANOP\n*              ***  MAIN PROGRAMS - PASS 1&2 ***                      *\nXMOCON1  DC    V(MOCON1)           MAIN CONTROL - PASS 1\nXMOSTOP  DC    V(MOSTOP)           DISASTER EXIT-PASS 1\nXMTCON2  DC    V(MTCON2)           MAIN CONTROL - PASS 2\n*              *** OPCOD1 ENTRY POINTS ***                            *\nXOPINIT  DC    V(OPINIT)           INITIALIZATION,IF ANY\nXOPFIND  DC    V(OPFIND)           LOOKUP OPCODE\n*              *** OUTPUT ENTRY POINTS ***                            *\nXOUINT1  DC    V(OUINT1)           INITIALIZATION ENTRY FOR OUTPUT\nXOUTPT2  DC    V(OUTPT2)           OUTPUT LINE PRINTER\nXOUEND2  DC    V(OUEND2)           FINISH UP LAST PRINTING\n*              *** SCANRS ENTRY POINTS ***                            *\nXSCANBL  DC    V(SCANBL)           SCAN TO FIRST BLANK OUTSIDE OF C'\nXSCANCO  DC    V(SCANCO)           SCAN TO COMMA OR BLANK\nXSCANEQ  DC    V(SCANEQ)           SCAN TO = OR BLANK\n*              *** SDTERM ENTRY POINTS ***                            *\nXSDBCDX  DC    V(SDBCDX)           SLEF DEFINING TERM-ALL 4 KINDS     *\nXSDBTRM  DC    V(SDBTRM)           BINARY SELF-DEFINING TERM\nXSDCTRM  DC    V(SDCTRM)           CHARACTER SELF-DEFINING TERM\nXSDDTRM  DC    V(SDDTRM)           DECIMAL SELF-DEFINING TERM\nXSDXTRM  DC    V(SDXTRM)           HEXADECIMAL SLEF-DEFINING TERM\n*              *** SYMOPS ENTRY POINTS ***                            *\nXSYINT1  DC    V(SYINT1)           SYMBOL TABLE INITIALIZATION\nXSYENT1  DC    V(SYENT1)           ENTER A SYMBOL INTO SYMBOL TABLE\nXSYFIND  DC    V(SYFIND)           LOOK UP A SYMBOL IN SYMBOL TABLE\nXSYEND2  DC    V(SYEND2)           CLEANUP/STATISTICS AT END OF SYM TAB\n*              *** UTOPRS ENTRY POINTS ***                            *\nXUTINT1  DC    V(UTINT1)           UTILITIES INITIALIZATION\nXUTPUT1  DC    V(UTPUT1)           PASS 1 OUTPUT OF EXPANDED RECORDS\nXUTEND1  DC    V(UTEND1)           END PASS 1-INIT FOR PASS 2\nXUTGET2  DC    V(UTGET2)           GET ADDR'S OF EXPANDED RECRDS-PASS 2\nXUTPUT2  DC    V(UTPUT2)           OBJECT CODE CREATION-PASS 2\nXUTEND2  DC    V(UTEND2)           FINISH UP PASS 2\n         AIF   (NOT &$XREF).NOXREF7  SKIP ID NO XREF                  A\n*              ***  CROSS REFERENCE ENTRY POINTES ***                 A\nXXRINT1  DC    V(XRINT1)           1ST PASS INIT ROUTINE              A\nXXRINT2  DC    V(XRINT2)           2ND PASS INIT ROUTINE              A\nXXRCOLL  DC    V(XRCOLL)           COLLECTION ROUTINE                 A\nXXRPRNT  DC    V(XRPRNT)           PRINT ROUTINE                      A\nXXRSCAN  DC    V(XRSCAN)           SCANNING ROUTINE                   A\n.NOXREF7 ANOP                                                         A\nXSPECAD  DS    A                   BASE ADDRESS FOR SPECIAL ROUTINES\nXSPECA2  DS    A                   BASE @ LEV2-PASS 2 - 'SPECIALS'\n         EJECT\n* * * * * AVWXTABL SECTION W - CONSTANTS  * * * * * * * * * * * * * * *\nWD0      DS    0D                  FLOATING POINT 0 FOR CDE\nWZEROS   DC    32D'0'              256 BYTES OF BINARY ZEROS\nWD10     DC    D'10'               DOUBLEWORD FLOATING CONSTANT 10\nWF1      DC    F'1'                FULLWORD 1 CONSTANT\nWH1      EQU   WF1+2               HALFWORD 1 CONSTANT\nWB1      EQU   WF1+3               BYTE 1 CONSTANT\nWF3      DC    F'3'                FULLWORD 3 CONSTANT\nWH3      EQU   WF3+2               HALFWORD 3 CONSTANT\nWB3      EQU   WF3+3               BYTE 3 CONSTANT\nWF4      DC    F'4'                FULLWORD CONSTANT 4\nWF7      DC    F'7'                FULLWORD 1\nWH7      EQU   WF7+2               HALFWORD 7 CONSTANT\nWB7      EQU   WF7+3               BYTE 7 CONSTANT\nWF10     DC    F'10'               FULLWORD CONSTANT 10\nWH10     EQU   WF10+2              HALFWORD CONSTANT 10\nWF12     DC    F'12'               FULLWORD CONSTANT 12\nWF15     DC    F'15'               FULLWORD CONSTANT 15 (4 1 BITS)\nWFXF     EQU   WF15                FULLWORD CONSTANT,4 1-BITS\nWFXFF    DC    F'255'              FULLWORD CONSATNT 255\nWF4095   DC    F'4095'             FULLWORD 4095 CONSTANT\nWFXFFF   EQU   WF4095              XL4'FFF'      ON F BOUNDARY\nWHXFFF   EQU   WFXFFF+2            XL2'0FFF'  ON H BOUNDARY\nWFX7FFFF DC    X'00007FFF'         MAXIMUM SIZE, MASK VALUE\nWFXFFFF  DC    X'0000FFFF'         65K DECIMAL NUMBER\nWFX6F    DC    XL4'FFFFFF'         FULLWORD 24-BIT MASK\nWFM4     DC    F'-4'               FULLWORD -4 CONSTANT\nWFM1     DC    F'-1'               FULLWORD -1 CONSTANT\nWHM1     EQU   WFM1+2              HALWORD -1 CONSTANT\n         EJECT\n*        TABLE USED TO SCAN DECIMAL NUMBERS                           *\n*        CHARACTERS 0-9 HAVE ZERO VALUES,ALL OTHERS NONZERO           *\n*        ALSO USED IN ICMOP2 FOR GENERAL SCANNING.                    *\n*   TR TABLE      0 1 2 3 4 5 6 7 8 9 A B C D E F                     *\nWTDECT   DC    X'02020202020202020202020202020202'    0\n         DC    X'02020202020202020202020202020202'    1\n         DC    X'02020202020202020202020202020202'    2\n         DC    X'02020202020202020202020202020202'    3\n         DC    X'100202020202020202020202020C0202'    4 BLANK (\n         DC    X'02020202020202020202020608020202'    5  $ *\n         DC    X'02020202020202020202020E02020202'    6  ,\n         DC    X'02020202020202020202020606020A02'    7 # @ =\n         DC    X'02020202020202020202020202020202'    8\n         DC    X'02020202020202020202020202020202'    9\n         DC    X'02020202020202020202020202020202'    A\n         DC    X'02020202020202020202020202020202'    B\n         DC    X'02060404060606060606020202020202'    C B-C(4) ALPHS-6\n         DC    X'02060604060606060606020202020202'    D L-(4) ALPHS-6\n         DC    X'02020606060606040606020202020202'    E X-(4) ALPHS - 6\n         DC    X'00000000000000000000020202020202'    F\n*        TABLE USED TO SCAN HEXADECIMAL CONSTANTS FOR CORRECTNESS     *\n*        CHARACTERS A-F,0-9 ARE ZERO,ALL OTHERS ARE NON-ZERO          *\nWTHEXT   DC    X'02020202020202020202020202020202'    0\n         DC    X'02020202020202020202020202020202'    1\n         DC    X'02020202020202020202020202020202'    2\n         DC    X'02020202020202020202020202020202'    3\n         DC    X'02020202020202020202020202020202'    4\n         DC    X'02020202020202020202020202020202'    5\n         DC    X'02020202020202020202020202020202'    6\n         DC    X'02020202020202020202020202020202'    7\n         DC    X'02020202020202020202020202020202'    8\n         DC    X'02020202020202020202020202020202'    9\n         DC    X'02020202020202020202020202020202'    A\n         DC    X'02020202020202020202020202020202'    B\n         DC    X'02000000000000020202020202020202'    C\n         DC    X'02020202020202020202020202020202'    D\n         DC    X'02020202020202020202020202020202'    E\n         DC    X'00000000000000000000020202020202'    F\n*              TABLE FOR HEXADECIMAL INPUT CONVERSIONS.               *\nWTHEX2   EQU   *-C'A'              OFFSET SYMBOL FROM TABLE CORRECTLY\n*   TR TABLE      0 1 2 3 4 5 6 7 8 9 A B C D E F                     *\n         DC      X'0A0B0C0D0E0F000000000000000000'    C\n         DC    X'00000000000000000000000000000000'    D\n         DC    X'00000000000000000000000000000000'    E\n         DC    X'00010203040506070809'                F\n         EJECT\n*        USED TO SCAN ACROSS SYMBOLS,STOP ON DELIMITERS               *\n*        CHARACTERS $,#,@,A-Z,0-9 ARE ZERO. ALL OTHERS ARE NONZERO    *\n*        ALSO USED IN EVALUT FOR OPERATOR CODES- (+*)-/,              *\n*   TR TABLE      0 1 2 3 4 5 6 7 8 9 A B C D E F                     *\nWTSYMT   DC    X'01010101010101010101010101010101'     0\n         DC    X'01010101010101010101010101010101'     1\n         DC    X'01010101010101010101010101010101'     2\n         DC    X'01010101010101010101010101010101'     3\n         DC    X'04010101010101010101010101020501'     4 BLANK (+\n         DC    X'01010101010101010101010007030101'     5 $*)\n         DC    X'06080101010101010101010401010101'     6 -/,\n         DC    X'01010101010101010101010000010101'     7  #@\n         DC    X'01010101010101010101010101010101'     8\n         DC    X'01010101010101010101010101010101'     9\n         DC    X'01010101010101010101010101010101'     A\n         DC    X'01010101010101010101010101010101'     B\n         DC    X'01000000000000000000010101010101'     C  A-I\n         DC    X'01000000000000000000010101010101'     D  J-S\n         DC    X'01010000000000000000010101010101'     E  S-Z\n         DC    X'00000000000000000000010101010101'     F  0-9\nWTZTAB   EQU   WZEROS              SPACE FOR 256-BYTE ZEROED TRT TABLE\n         DS    0D                  LINE UP BLANKS ON D BOUNDARY\nWBLANK   DC    CL132' '            BLANKS\n         ORG   WBLANK+16           OVERLAP WBLANK&WTHEX3\n         SPACE 1\n*        TABLE USED TO CONVERT INTERNAL BINARY TO EXTERNAL HEX.       *\n*   TR TABLE     0123456789ABCDEF0123456789ABCDEF                     *\nWTHEX3   DC    C'                                '    0-1\n         DC    C'                                '    2-3\n         DC    C'                                '    4-5\n         DC    C'                                '    6-7\n         DC    C'                                '    8-9\n         DC    C'                                '    A-B\n         DC    C'                                '    C-D\n         DC    C'                0123456789ABCDEF'    E-F\n         SPACE 1\nWEP4     DC    X'40202120'         4-BYTE DECIMAL EDIT PATTERN\nWEP6     DC    X'402020202120'     6-BYTE EDIT PATTERN FOR DEC #\nWP0      DC    PL1'0'              FOR ZEROING DECIMAL COUNTERS\nWP1      DC    P'1'                DECIMAL CONSTANT 1\nWCONADS  DS    ($CNT$N)AL1         SPACE FOR CONSTANT OFFSET TABLE\n         WCONG (A,B,C,D,E,F,H,P,V,X,Z)       GENERATE OFFSETS IN WCONAD\n         EJECT\n* * * * * AVWXTABL SECTION V - VARIABLES  * * * * * * * * * * * * * * *\n         DS    0D                  GET ALIGNEMENT\n*        **NOTE** FOLLOWING SECTION SHOULD MIRROR AV- SECTION OF      *\n*        AVWXTABL DSECT, BUT HAS BEEN REMOVED, BECAUSE NO CODE IS     *\n*        ACTUALLY GENERATED, AND FINAL ORG TAKES CARE OF LENGTH.      *\n         ORG   VWXTABL+AVWXEND-AVWXTABL     MAKE SURE AS BIG AS AVWXTB\n         AIF   (NOT &$XREF).XXNOXRF                                   J\nXREFTAB  DSECT\nXREFSYM  DS    F                   @ OF SYMBOL'S SYMSECT ENTRY\nXREFLLNK DS    H                   LEFT LINK TO NEXT SYMBOL IN TREE\nXREFRLNK DS    H                   RIGHT LINK TO NEXT SYMBOL IN TREE\nXREFBLCK DS    F                   @ OF BLOCK WITH STATEMENT NUMBERS\nXREFTLGN EQU   *-XREFTAB           LENGTH OF XREF TABLE ENTRY\nXREFBLK  DSECT\nXRBLKNUM DS    F                   NEG # OF SLOTS LEFT IN BLOCK OR\n*                                  POINTER TO NEXT BLOCK OF REFERENCES\n         DS    &$XREF#B.H          SLOTS FOR STMT NUMBERS\nXREFBLGN EQU   *-XREFBLK           LENGTH OF BLOCK OF STMT #\nXRPL     EQU   &$PRTSIZ            SET UP XREF LINE LENGTH = MAX LENG J\nXRPLAST  EQU   XRPL-18             OFFSET: LAST PLACE TO START        L\n         TITLE 'XREFA - CROSS REFERENCE FACILITY'\n**--> CSECT: XREFA   CROSS REFERENCE CONTROL SECTION...................\n*.         WRITTEN BY ALICE FELTE,ALAN ARTZ, AND RICH LONG            .\n*.                                           ---SPRING/SUMMER 1973    .\n*.                                                                    .\n*.  THIS CSECT IS THE MAIN CONTROL SECTION FOR THE CROSS REFERENCE    .\n*. FOR ASSIST. IT HAS THREE ENTRY POINTS WHICH WILL BE DESCRIBED LATER.\n*. THIS ROUTINE CONTROLS ALL THE CROSS-REFERENCE FACILITY IF IT IS TO .\n*. BE GENERATED.  THE FIRST PASS THE FLAGS AND LOCATION COUNTER ARE   .\n*. INITIALIZED--XRINT1.  SPACE IS ALLOCATED FOR THE CROSS-REFERENCE   .\n*. ENTRIES AND NECESSARY FLAGS ARE SET FOR THE SECOND PASS--XRINT2.   .\n*. THE *XREF CARD WILL BE SCANNED BY XRSCAN.                          .\n*.                                                                    .\n*.  XRINT1: PASS ONE INITIALIZATION                                   .\n*.         CALLED FROM MPCON0.                                        .\n*.         1)  INITIALIZE THE ADDITIONAL LOCATION COUNTER,            .\n*.             AVXRLNCN, TO 1.                                        .\n*.         2)  INITIALIZE THE COUNTER, AVXRCNT, FOR THE NUMBER OF     .\n*.             REFERENCES TO 0.                                       .\n*.                                                                    .\n*.  XRINT2: PASS TWO INITIALIZATION                                   .\n*.         CALLED FROM MTCON2.                                        .\n*.         1)  ALLOCATE SPACE USING THE MACRO $ALLOCH TO THE          .\n*.             DSECT, XREFTAB, SIZE * THE NUMBER OF REFERENCES        .\n*.             TO BE COLLECTED AND INITIALIZE ALL SPACE TO 0.         .\n*.         2)  SET AVXRLAVS TO FIRST FREE NODE.                       .\n*.         3)  SET HEADER NODE FOR THE TREE STRUCTRUE EQUAL TO 0.     .\n*.                                                                    .\n*.  XRSCAN:  CARD SCANNING ROUTINE.                                   .\n*.             A FLAG IS PASSED IN A REGISTER TO DETERMINE WHICH      .\n*.         PASS IS BEING PROCESSED.  FOR THE FIRST PASS, SCAN THE     .\n*.         CARD AND SET THE SD FLAG ACCORDINGLY.  FOR THE SECOND      .\n*.         PASS, SCAN THE CARD AND SET THE SR FLAG ACCORDINGLY.       .\n*.                                                                    .\n*......................................................................\nXREFA    CSECT\n         ENTRY XRINT1,XRINT2,XRSCAN\n         EJECT\n**--> ENTRY: XRINT1     PASS ONE INITIALIZATION........................\n*.       THIS IS CALLED FROM MPCON0 ONLY ONCE                         .\n*.       MODULE DESCRIPTION--                                         .\n*.            INITIALIZES AVXRLNCT, THE ADDITIONAL LINE COUNTER, TO 1 .\n*.       AND AVXRCNT, COUNTER FOR THE NUMBER OF REFERENCES FOUND, TO 0.\n*.                                                                    .\n*......................................................................\n         SPACE 2\nXRINT1   EQU   *                   ENTRY INITIALIZATION FIRST PASS\n         USING *,R15\n         USING AVWXTABL,RAT        MAIN TABLE USING\n         ZAP   AVXRLNCN(3),AWP1    INITIALIZE ADDITIONAL LINE COUNTER\n         MVC   AVXRCNT(2),AWZEROS  INITIALIZE # OF REFERENCES TO 0\n         MVI   XRSDORSR,C'D'       FOR SD= SCAN ON *XREF CARDS        L\n         MVC   XRFLAGSV,AVXRFLAG   SAVE FLAG\n         NI    AVXRFLAG,X'FF'-AVXRSRFT-AVXRSRMD  ZAP, NO PASS 1 REFS\nXRI1RET  BR    R14                 RETURN\n         DROP  R15,RAT\n         SPACE 3\n**--> ENTRY: XRINT2     PASS TWO INITIALIZATION........................\n*.       THIS IS CALLED FROM MPCON0 ONLY ONCE.                        .\n*.       MODULE DESCRIPTION--                                         .\n*.            ALLOCATES A BLOCK OF SPACE USING $ALLOCH WHERE THE SIZE .\n*.       IS AVXRCNT * XRSIZE.  IT SET AVXRLAVS TO THE ADDRESS OF THE  .\n*.       BEGINNING OF THE BLOCK OR FIRST FREE NODE AS RETURNED BY     .\n*.       $ALLOCH.  IT ALSO SETS AVXRHEAD, THE HEADER POINTING TO THE  .\n*.       FIRST ENTRY IN THE TREE, EQUAL TO 0.                         .\n*.                                                                    .\n*......................................................................\n         SPACE 2\nXRINT2   EQU   *                   ENTRY INITIALIZATION SECOND PASS\n         USING *,R15\n         USING AVWXTABL,RAT        MAIN TABLE USING\n         USING XREFTAB,RB          CROSS REFERENCE TABLE\n         TM    AVXRFLAG,AVXRON     IS XREF WANTED\n         BZ    XRI2RET             NO, RETURN\n         MVI   XRSDORSR,C'R'       FOR SR= SCAN ON *XREF CARDS        L\n         MVC   AVXRFLAG,XRFLAGSV   RESTORE FOR REF COLL BITS\n         LA    RC,XREFTLGN         GET LENGTH OF XREF TABLE ENTRY\n         MH    RC,AVXRCNT          GET AMOUNT OF SPACE TO BE ALLOCATED\nXRI2ALLO $ALLOCH RB,RC,XRI2OVFL    ALLOCATE SPACE FOR TABLE\n         MVC   AVXRHEAD(4),AWZEROS HEADER WILL BE NULL\n         ST    RB,AVXRLAVS         PUT @ OF SPACE IN FREE SPACE LIST\n         MVI   AVXRTYPE,AVXRFTCH   MAKE SURE FETCH TYPE REF NORMAL    J\n         MVC   AVXRLNCN(3),AVOULNCN  INITIALIZE LINE COUNTER\n         BR    R14                 RETURN\n*     CANCEL XREF OPTION AND SET OVERFLOW FLAG\nXRI2OVFL NI    AVXRFLAG,X'FF'-AVXRON  TURN XREF OFF\n         OI    AVTAGS3,AVOVERFL    SHOW OVERFLOW OCCURRED\nXRI2RET  BR    R14                 RETURN\nXRFLAGSV DC    AL1($),X'0'         SAVE WORD,  PAD\n         DROP  RAT,RB\n         EJECT\n**--> ENTRY: XRSCAN     CARD SCANNING ROUTINE..........................\n*.       THIS IS CALLED FROM MOCON1 AND MTCON2 TO SCANN THE *XREF CARD.\n*.                                                                    .\n*.       ENTRY CONDITIONS--  RA  @ TO BEGIN *XREF PARM SCAN           .\n*.                           RD  IDX TO SET FLAGS(0=PASS 1,8=PASS 2)  .\n*.                                                                    .\n*.       MODULE DESCRIPTION--                                         .\n*.            CHECK TO SEE WHICH PASS IT IS IN.  DEPENDING ON WHICH   .\n*.       PASS IT IS, THE *XREF CARD IS SCANNED AND THE FLAGS SET.     .\n*.            IF IT IS PASS ONE, THE CARD IS SCANNED FOR SD=.  IF IT  .\n*.       NOT THERE, AVXRFLAG IS NOT CHANGED.  IF IT IS, CHECK FOR     .\n*.       LEGAL VALUES OF *, 0, OR 1.  IF IT IS NONE OF THESE THREE,   .\n*.       THE STATEMENT IS FLAGGED WITH A SYNTAX ERROR.  IF IT IS A    .\n*.       LEGAL VALUE, THE AVXRFLAG IS SET ACCORDINGLY.                .\n*.            IF IT IS PASS TWO, THE CARD IS SCANNED SR= AND IS       .\n*.       PROCESSED SIMILARLY TO SD= ABOVE.                            .\n*.                                                                    .\n*......................................................................\n         SPACE 2\nXRSCAN   $SAVE RGS=(R14-R6),SA=NO   SAVE REGISTERS TO BE USED\n         USING AVWXTABL,RAT        MAIN TABLE USING\n         TM    AVXRFLAG,AVXRON     IS XREF ON?\n         BZ    XRRETURN            NO, RETURN\n         LA    RC,1                USEFUL CONSTANT\n         $SETRT ('S',1)            SET UP AWTZTAB TO STOP ON S        L\n         LA    RE,65(RA)           LAST @ TO CHECK FOR 'S'            L\n*\n*  PASS 1 -- SCAN FOR SD= AND SET AVWXFLAG ACCORDINGLY                F\n* PASS 2 -- SCAN FOR SR= AND SET AVWXFLAG ACCORDINGLY                 L\n*\nXRSTRT   LR    RB,RE               RB=END OF SCAN                     L\n         SR    RB,RA               DETERMINE MACHINE LENGTH FOR EX INST\n         EX    RB,XRSEXTRT         SCAN FOR 'S'                       L\n         BZ    XRRETURN            IF NOT FOUND,RETURN                F\n         CLC   1(2,R1),XRSDORSR    CHK FOR D= (PASS1),R= (PASS2)      L\n         BE    *+8                 YES, CHECK FOR LEGAL NUMBER        L\n         BXH   RA,RC,XRSTRT        INCR & CHECK FOR ANOTHER S         L\n*\n*  CHECK MODIFY CHAR FOR '*', '0', OR '1'. ANYTHING ELSE IS ILLEGAL   F\n*\n         LA    RA,3(R1)            GET @ OF MODIFY CHAR               L\n         CLI 0(RA),C'0'            IS IT 0                            F\n         BE    XRM0(RD)            YES, SET FLAG                      L\n         CLI 0(RA),C'1'            IS IT 1                            F\n         BE    XRM1(RD)            YES SET FLAG                       L\n         CLI   0(RA),C'*'          IS IT *                            L\n         BNE   XRSDSRER            ERROR IF NOT                       L\n*                                                                     F\n*     CHECK FETCH CHAR FOR '*', '0', '1', ',', OR ' '.  ANYTHING ELSE F\n*     IS AN ERROR.  MARK IT SYNTAX ERROR                              F\n*                                                                     F\nXRNUM2   AR    RA,RC               GET @ OF FETCH CHAR                L\n         CLI   0(RA),C'0'          IS IT 0                            F\n         BE    XRF0(RD)            YES, SET AVXRFLAG                  L\n         CLI   0(RA),C'1'          IS IT 1                            F\n         BE    XRF1(RD)            YES, SET AVXRFLAG                  L\n         CLI   0(RA),C'*'           IS IT *\n         BNE   *+6                 NO, CHECK FOR ',' OR ' '           L\n*                                                                     F\n*     CHECK FOR A BLANK OR COMMA.    IF IT IS BLANK, RETURN           F\n*                                  IF IT IS COMMA, SCAN REST OF CARD  F\n*                                                                     F\nXRBLNK   AR    RA,RC               NO CHANGE NECESSARY  CHECK FOR ',' L\n         CLI   0(RA),C' '          IS IT BLANK                        L\n         BE    XRRETURN            YES, RETURN                        F\n         CLI   0(RA),C','          IS IT A COMMA                      F\n         BE    XRSTRT              GO TO SCAN REST OF THE CARD        L\nXRSDSRER LA    RB,$ERVSYNT         SET ERROR CODE\n         $CALL ERRTAG              CALL ERROR ROUTINE\n*\n*     RETURN TO CALLING ROUTINE\nXRRETURN $SETRT ('S',0)            RESET AWTZTAB TO ZERO\n         $RETURN RGS=(R14-R6),SA=NO\n*        SET AVXRFLAG APPROPRIATELY                                   L\nXRM0     NI    AVXRFLAG,X'FF'-AVXRSDMD SET SD MODIFY OFF              L\n         B     XRNUM2              GET 2ND #                          L\n         NI    AVXRFLAG,X'FF'-AVXRSRMD  SET SR MODIFY OFF             L\n         B     XRNUM2              GET 2ND #                          L\nXRM1     OI    AVXRFLAG,AVXRSDMD   SET SD MODIFY ON                   L\n         B     XRNUM2              GET 2ND #                          L\n         OI    AVXRFLAG,AVXRSRMD   SET SR MODIFY                      L\n         B     XRNUM2              GET 2ND #                          L\nXRF0     NI    AVXRFLAG,X'FF'-AVXRSDFT  SET SD FETCH OFF              L\n         B     XRBLNK              GO CHECK FOR ',' OR ' '            L\n         NI    AVXRFLAG,X'FF'-AVXRSRFT  SET SR FETCH FLAG OFF         L\n         B     XRBLNK              GO CHECK FOR ',' OR ' '            L\nXRF1     OI    AVXRFLAG,AVXRSDFT   SET SD FETCH ON                    L\n         B     XRBLNK              GO CHECK FOR ',' OR ' '            L\n         OI    AVXRFLAG,AVXRSRFT   SET SR FETCH FLAG ON               L\n         B     XRBLNK              GO CHECK FOR ',' OR ' '            L\nXRSEXTRT TRT   0($,RA),AWTZTAB     SEARCH FOR AN S                    L\n         DROP  RAT                                                    L\nXRSDORSR DC    C'$='               $ REPLACED BY D(PASS 1) OR R(PASS2)\n         LTORG\n         TITLE 'XRCOLL - CROSS REFERENCE COLLECTION ROUTINE'\n**--> CSECT: XRCOLL     COLLECTION ROUTINE.............................\n*.       THIS IS CALLED BY SYFIND AFTER IT IS FOUND THAT THE SYMBOL   .\n*.       IS DEFINED AND THE REFERENCE IS TO BE COLLECTED.             .\n*.                                                                    .\n*.       ENTRY CONDITIONS--  RA  HAS THE ADDRESS OF THE SYMBOL IN THE .\n*.                                SYMBOL TABLE.                       .\n*.                                                                    .\n*.       MODULE DESCRIPTION--                                         .\n*.          AVXRHEAD HAS THE ADDRESS OF THE FIRST NODE IN THE TREE.   .\n*.          AVXRLAVS HAS THE ADDRESS OF THE FIRST AVAILABEL FREE NODE .\n*.                                                                    .\n*.            THE FOLLOWING ALGORITHM IS FROM \"THE ART OF COMPUTER    .\n*.       PROGRAMMING\" VOL. 1  'FUNDAMENTAL ALGORITHMS' BY DONALD KNUTH.\n*.            CHECK HEADER 'AVXRHEAD' FOR EMPTY TREE(= 0).  IF EMPTY, .\n*.       EXECUTE INSUB 'XRCLAVS' TO GET FREE NODE FOR PROCESSING.     .\n*.       'XRCLAVS' INSERTS SYMBOL AND INITIALIZES LINKS IN NODES---   .\n*.       LEFT LINK=0,RIGHT KINK=-1 (ODD DISPLACEMENT IMPOSSIBLE, NEGA-.\n*.       TIVE TO SIMPLIFY CHECKS IN XRPRNT ROUTINE).  IF NOT EMPTY,   .\n*.       DETERMINE WHETHER OR NOT A NODE HAS ALREADY BEEN CREATED FOR .\n*.       THE PRESENT SYMBOL BY COMPARING THE ADDRESS OF THE SYMBOL    .\n*.       IN REG RA TO THE ADDRESSES OF SYMBOLS ALREADY IN THE TREE    .\n*.       NODES.  IF EQUAL, PROCESS THE REFERENCE (DESCRIBED LATER).   .\n*.       OTHERWISE, COMPARE ACTUAL SYMBOLS TO DETERMINE WHERE IN THE  .\n*.       TREE THE NEWLY CREATED NODE SHOULD BE INSERTED.  IF THE NEW  .\n*.       SYMBOL IS SMALLER IN VALUE THAN THAT OF A NODE IN TREE, THE  .\n*.       COMPARISON CONTINUES WITH IT'S LEFT SUBTREE.  IF LARGER, COM-.\n*.       PARISON CONTINUES WITH RIGHT SUBTREE.  WHEN A ZERO LEFT LINK .\n*.       IS FOUND, OR NEGATIVE RIGHT LINK, THE LINK IS CHANGED TO     .\n*.       POINT TO THE NODE WHICH WILL CONTAIN THE INFO FOR THE NEW    .\n*.       SYMBOL(NODE FETCHED AND INITIALIZED BY 'XRCLAVS'.            .\n*.                                                                    .\n*.       PROCESSING THE REFERENCES:                                   .\n*.            ONCE THE SYMBOL IS PLACED IN THE TREE, THE REFERENCE    .\n*.       MUST BE ENTERED IN A BLOCK OF REFERENCES.  THIS IS DONE IN   .\n*.       THE FOLLOWING MANNER:                                        .\n*.            1)  IF THE PTR TO THE BLOCK OF REFERENCES IS NULL       .\n*.                (I.E. FIRST REFERENCE), A BLOCK MUST BE             .\n*.                ALLOCATED AND THE ADDRESS PLACED IN THE POINTER     .\n*.                OF THE XREFTAB.                                     .\n*.            2)  IF IT IS NOT NULL, THE POINTER IS AN ADDRESS AND    .\n*.                THE BLOCK CAN BE LOCATED.                           .\n*.                                                                    .\n*.            3)  THE FIRST FULLWORD OF THE REFERENCE-BLOCK           .\n*.                CONTAINS EITHER:                                    .\n*.                A)  THE NUMBER OF SLOTS LEFT IN THE BLOCK.          .\n*.                    THE REFERENCE MAY BE ENTERED IN THE BLOCK, THE  .\n*.                    NUMBER OF SLOTS IS DECREMENTED BY 1.            .\n*.                B)  NEGATIVE ADDRESS OF AN ADDITIONAL BLOCK         .\n*.                C)  ZERO, MEANING A NEW BLOCK MUST BE ALLOCATED.    .\n*.                    ALLOCATE A NEW BLOCK AND SET THE POINTER IN     .\n*.                    PRECEDING BLOCK TO IT (NEGATIVE ADDRESS). THEN  .\n*.                    A) MAY BE FOLLOWED.                             .\n*......................................................................\n         SPACE 2\n* * * *  REGISTER USAGE: XRCOLL * * * * * * * * * * * * * * * * * * * *\n*   R0=  X'0000FFFF'               USED TO INITIALIZE NODE LINKS      *\n*   RW=  @ NODE IN XREF LIST BEING CHECKED  (@ XREFTAB)               *\n*   RX=  @ SYMSECT OF SYMBOL ALREADY IN XREF TABLE                    *\n*   RA=  @ SYMSECT OF SYMBOL TO BE CHECKED IN XREFTAB                 *\n*   RB=  @  BEGIN OF XREF TABLE (FROM WHICH OFFSETS COMPUTED)         *\n*   RC,RD,RE,RY,RZ   WORK REGISTERS                                   *\n*   R14= INTERNAL LINKAGE                                             *\n*   R15= BASE REGISTER                                                *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 2\nXRCOLL   CSECT\n         $SAVE RGS=(R14-R6),SA=NO\n         USING AVWXTABL,RAT        NOTE MAIN TABLE USING\n         USING XREFTAB,RW          CROSS TABLE (POINTERS)\n         L     R0,AWFXFFFF         =X'0000FFFF'  USED TO INIT PTRS    J\n         MVC   AVDWORK2,AWBLANK    PREPARE FOR SYMBOL TO BE CHECKED\n         USING SYMSECT,RA\n         IC    RD,SYCHARS          GET LENGTH OF LABEL\n         EX    RD,XRCSYMO          MOVE SYMBOL TO PADDED AREA FOR COMP\n         DROP  RA                  DROP SO USING ON RX OK\n         L     RW,AVXRHEAD         GET HEADER POINTER TO FIRST NODE\n         LTR   RB,RW               IS IT ZERO, NO NODES ALLOCATED\n         BNZ   XRCSYMCK            SYMBOLS IN TABLE - BRANCH\n         SPACE 1\n*              FIRST SYMBOL - ALLOC SPACE,SET AVXRHEAD\n         BAL   R14,XRCLAVS         CALL ALLOCATE ROURINE\n         ST    RW,AVXRHEAD         POINTER TO 1ST ENTRY\n         LR    RB,RW               RB--> TOP OF TREE\n         B     XRCNUENT            GO TO FILL IN\n         SPACE 1\nXRCSYMCL LA    RW,0(RY,RB)         GET @ NEXT NODE\n         USING SYMSECT,RX          SYMBOL TABLE USING\nXRCSYMCK L     RX,XREFSYM          GET @ OF SYMSECT ENTRY FOR SYMBOL\n         MVC   AVDWORK1(8),AWBLANK INITIALIZE WORK AREA TO BLANKS\n         IC    RD,SYCHARS          GET LENGTH OF LABEL\n         EX    RD,XRCSYMN          MOVE SYMBOL TO PADDED FIELD\n         DROP  RX\n         CLC   AVDWORK2(8),AVDWORK1  COMPARE SYMBOLS TO SEE IF WANTED\n         BE    XRCENTER            IF EQUAL, HAVE TO ENTER STMT # INTO\n         BH    XRCRIGHT            IF> GO TO RIGHT LINK AND CHECK AGAIN\n*   IF < GO TO LEFT LINK AND CHECK AGAIN\n         LH    RY,XREFLLNK         GET DISP OF LINK IN TABLE\n         LTR   RY,RY               IS IT THE END OF TREE\n         BNZ   XRCSYMCL            NO, LOOP\n*\n*           ENTER NEW NODE INTO TREE - LEFT LINKED\n*\nXRCNULEF BAL   R14,XRCLAVS         GET A NEW NODE\n         LR    RZ,RB               TO SAVE @ OF OLD NODE\n         SR    RZ,RX               COMPUTE DISPLACEMENT OF OLD NODE\n         STH   RZ,XREFRLNK         STORE THREAD TO PREVIOUS NODE\n         USING XREFTAB,RX\n         LR    RZ,RW               TO SAVE @ OF NEW NODE\n         SR    RZ,RB               COMPUTE DISP OF NEW NODE\n         STH   RZ,XREFLLNK         STORE INTO LEFT LINK OF PREV NODE\n         DROP  RX\n         B     XRCNUENT            NOW READY TO ENTER STMT NUMBER\n         SPACE 1\nXRCRIGHT LH    RY,XREFRLNK         DET DISP OF LINK IN TABLE\n         LTR   RY,RY               IS IT THE END OF THE LIST\n         BP    XRCSYMCL            NO,LOOP\n*\n*           ENTER NEW NODE INTO TREE - RIGHT LINKED\n*\nXRCNURIT BAL   R14,XRCLAVS         GET A NEW NODE\n         LR    RZ,RW               TO SAVE @ OF NEW NODE\n         SR    RZ,RB               GET DISP OF NEW NODE\n         USING XREFTAB,RX\n         LH    RY,XREFRLNK         GET RIGHT LINK OF OLD NODE\n         STH   RZ,XREFRLNK         STORE DISP OF NEW NODE IN RLINK OF L\n         DROP  RX\n         STH   RY,XREFRLNK         STORE RLINK OF OLD NODE IN NEW\n*\n*  ALLOCATE NEW BLOCK FOR REFERENCES\n*\nXRCNUENT LA    RY,XREFBLGN         GET LENGTH OF BLOCK TO BE ALLOCATED\n         $ALLOCH RX,RY,XRCOVFLW    ALLOCATE A BLOCK FOR REFERENCE\n         USING XREFBLK,RX          XREF BLOCK OF STMT NUMBERS\n         ST    RX,XREFBLCK         STORE POINTER TO BLK OF REFERENCES\n         USING SYMSECT,RA\n         B     XRCLBLK             GO INSERT STATEMENT NUMBER\n*        ENTER HERE IF OLD SYMBOL\nXRCENTER L     RX,XREFBLCK         GET ADDRESS OF REFERENCE BLOCK\nXRCNXBLK L     RY,XRBLKNUM         GET NUB OF SPACES LEFT OR @ NEXT BLK\n         LTR   RY,RY               IS IT ZERO\n         BP    XRCSTMT#            POSITIVE, PUT STMT # INTO BLOCK\n         BZ    XRCALLOC            ALLOCATE NEW BLOCK IF 0\n         LPR   RX,RY               RX--> NEXT REFERENCE BLOCK\n         B     XRCNXBLK            GO SEE IF THIS BLOCK HAS ROOM\n*              ALLOCATE ADDITIONAL REFERENCE BLOCK\nXRCALLOC LA    RY,XREFBLGN         GET LENGTH TO BE ALLOCATED\n         LR    RZ,RX               SAVE @ OF FILLER REFERENCE BLOCK\n         $ALLOCH RX,RY,XRCOVFLW    ALLOCATE NEW BLOCK OF REFERENCES\n         LNR   RY,RX               ADDITIONAL BLK @ IS NEGATIVE\n         ST    RY,0(RZ)            STORE @ OF NEW BLOCK INTO FILLED BLK\nXRCLBLK  LA    RY,&$XREF#B         GET MAX AVAIL STMT SLOTS,IDX TO 1ST\n*\n*  INSERT STATEMENT NUMBER INTO REFERENCE BLOCK (- IF MODIFY)\n*\nXRCSTMT# LA    RC,2(RY,RY)         GET DISPLACEMENT OF OPEN SLOT\n         ZAP   AVDWORK1(8),AVXRLNCN GET STMT # OF REFERENCE\n         CVB   RZ,AVDWORK1          GET STMT # OF REFERENCE\n         TM    AVXRTYPE,AVXRFTCH   IS IT A FETCH REF\n         BNZ   *+6                 NO, MUST BE A MODIFY REFERENCE\n         LNR   RZ,RZ               GET NEGATIVE STMT # INTO REF BLOCK\n         STH   RZ,0(RC,RX)         STORE STMT # OF REFERENCE\n         BCTR  RY,0                DECREMENT # OF SLOTS\n         ST    RY,XRBLKNUM         STORE REMAINING # OF SLOTS\nXRCRET   $RETURN RGS=(R14-R6),SA=NO\n         DROP  RX\n         SPACE 3\n*.-->  INSUB: XRCLAVS . . . . . . . . . . . . . . . . . . . . . . . . .\n*.            GET THE FIRST FREE NODE FROM THE LIST OF AVAILABLE      .\n*.       SPACE, AVXRLAVS.  SETS AVXRLAVS TO POINT TO THE NEW FIRST    .\n*.       FREE NODE.  STORES THE ADDRESS OF THE SUMBOL'S SYMSECT ENTRY .\n*.       IN THE NEW NODE.                                             .\n*.       RW  HAS THE ADDRESS OF THE NEW NODE                          .\n*.       RX  HAS ADDRESS OF OLD NODE                                  .\n*.       LEFT LINK INITIALIZED TO ZERO; RIGHT LINK TO -1              .\n*.       NOTE: IT IS POSSIBLE TO HAVE THREAD OF A NODE POINT BACK TO  .\n*.       ROOT NODE WHICH HAS INDEX DISPLACEMENT OF ZERO.  SINCE -0 IS .\n*.       NOT DISTINGUISHABLE FROM +0, THE END OF THE TREE IS DENOTED  .\n*.       BY -1 VICE 0                                                 .\n*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  .\n         SPACE 2\nXRCLAVS  LR    RX,RW               SAVE ADDRESS OF OLD NODE\n         L     RW,AVXRLAVS         ADDRESS OF FIRST FREE NODE\n         LA    RZ,XREFTLGN(RW)     GET @ OF NEXT FREE NODE\n         ST    RZ,AVXRLAVS         SAVE @ OF NEW FIRST FREE NODE\n         ST    RA,XREFSYM          STORE @ OF SYMBOLS' SYMSECT ENTRY IN\n         ST    R0,XREFLLNK         ZERO BOTH LINKS\n         BR    R14                 RETURN\n         SPACE 3\n*\n*     COMES HERE WHEN IT DOES NOT HAVE ENOUGH SPACE TO ALLOCATE A NEW\n*      REFERENCE BLOCK\n*\nXRCOVFLW OI    AVTAGS3,AVOVERFL    SET OVERFLOW FLAG ON\n         MVI   AVXRFLAG,X'00'      DISARM FLAG NEVER TO RETURN        L\n         B     XRCRET              RETURN\nXRCSYMN  MVC   AVDWORK1($),SYMBOL-SYMSECT(RX)  MOVE SYMBOL ALREADY IN\n*                                              TREE TO WORK AREA\nXRCSYMO  MVC   AVDWORK2($),SYMBOL  MOVE NEW SYMBOL TO WORK AREA\n         DROP  RW,RA,RAT\n         LTORG\n         TITLE 'XRPRNT - CROSS REFERENCE PRINT ROUTINE'\n**--> CSECT: XRPRNT     PRINT ROUTINE..................................\n*.       CALLED FROM MPCON0 TO PRINT OUT THE CROSS REFERENCE.         .\n*.            THE COMPRESS BIT OF AVXRFLAG IS TESTED BY AVXRCOMP TO   .\n*.       DETERMINE WHICH FORMAT TO USE FOR PRINTING.  IF IT IS OFF,   .\n*.       EACH REFERENCE SYMBOL IS PRINTED ON A NEW LINE.  IF IT IS ON,.\n*.       THE REFERENCED LABELS ARE PRINTED MORE THAN ONE PER LINE IF  .\n*.       THERE IS ROOM.                                               .\n*.            THE FOLLOWING ALGORITHM IS FROM \"THE ART OF COMPUTER    .\n*.       PROGRAMMING\" VOL. 1  'FUNDAMENTAL ALGORITHMS' BY DONALD KNUTH.\n*.            THE TREE IS THEN TRAVERSED IN POSTORDER.                .\n*.                GET THE ADDRESS OF THE FIRST NODE IN THE TREE FROM  .\n*.            AVXRHEAD.  IF IT IS 0, PRINT A MESSAGE THAT NO SYMBOLS  .\n*.            HAVE BEEN REFERENCED.  IF IT IS NOT 0, FOLLOW THE LEFT  .\n*.            LINKS UNTIL IT IS 0.  THEN PRINT THE SYMBOL FROM THE    .\n*.            NODE AND ALL ITS REFERENCES.  NOTE: A NEGATIVE          .\n*.            REFERENCE IS A MODIFY AND A POSITIVE REFERENCE IS A     .\n*.            FETCH.  IT IS PRINTED ACCORDING TO THE FORMAT DESCRIBED .\n*.            ABOVE.                                                  .\n*.                THEN THE RIGHT LINK IS CHECKED.  IF IT IS -1,WE ARE .\n*.            AT THE END OF THE TREE AND RETURN TO ASSIST.            .\n*.            IF IT IS LESS THAN -1,IT IS A THREAD BACK TO A NODE.    .\n*.            GET THE POSITIVE ADDRESS OF THE NODE, PRINT THE SYMBOL  .\n*.            AND ITS REFERENCES.  CHECK THE RIGHT LINK AGAIN.        .\n*.            IF IT IS POSITIVE, IT IS THE ADDRESS OF THE NEXT NODE.  .\n*.            GO TO THAT NODE AND CHECK ITS LEFT LINK AS ABOVE.       .\n*.                                                                    .\n*......................................................................\n         SPACE 2\n* * * *  REGISTER USAGE: XRPRNT * * * * * * * * * * * * * * * * * * * *\n*   RW=  @ CURRENT XREFTAB ENTRY PROCESSED                            *\n*   R0=  LAST @ TO START STMT # (COMPRESSED OUTPUT)                   *\n*   R2=  -1  DENOTES END OF TREE                                      *\n*   RA=  LAST @ TO START A SYMBOL (COMPRESSED OUTPUT)                 *\n*   RB= @ XREFBLK BEING PROCESSED                                     *\n*   RC,RD,RZ   WORK REGISTERS                                         *\n*   RE=  @ OF 1ST ELEMENT (BASE FROM WHICH OFFSETS GIVEN)             *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 2\nXRPRNT   CSECT\n         $SAVE RGS=(R14-R6),SA=NO\n         USING AVWXTABL,RAT        MAIN TABLE USING\n         USING XREFTAB,RW          SET UP USINGS ON POINTER TABLE\n*\n*     PRINT CROSS REFERENCE HEADERS\n*\n         L     RW,AVXRHEAD         GET @ OF FIRST NODE IN TREE\n         LTR   RE,RW               IS THERE AN @ THERE?\n         BZ    XRPRRET             NO,RETURN\n         $PRNT XREFTTL1,L'XREFTTL1 FIRST LINE OF HEADER\n         LA    RZ,XRPOUTPT+1       GET ADDRESS OF OUTPUT LINE\n         LA    RA,XRPOUTPT+XRPLAST LAST @ TO START SYMBOL\n         LA    R0,11(RA)           LAST @ TO START STMT #\n         SR    R2,R2               SET UP REG TO FIND END OF TREE\n         BCTR  R2,0                -1 DENOTES END OF TREE\n         MVC   XRPOUTPT(XRPL),AWBLANK  BLANK OUT OUTPUT LINE\n         MVI   XRPOUTPT,C'0'       CC FOR 1ST LINE\nXRPLLNK  LH    RX,XREFLLNK         GET LEFT LINK\n         LTR   RX,RX               IS IT THE NODE TO BE PRINTED\n         BZ    XRPRNODE            YES,PRINT NODE\n         LA    RW,0(RX,RE)         @ OF NODE IN RW\n         B     XRPLLNK             IS IT THE LAST NODE\nXRPRLNK  LH    RX,XREFRLNK         GET RIGHT LINK\n         CR    RX,R2               END OF TREE?\n         BE    XRPRRETP            -1, END OF TREE\n         TM    AVXRFLAG,AVXRCOMP   IS IT TO BE COMPRESSED OUTPUT\n         BNO   XRPSYMBL            NO,GO PRINT LINE\n*        OUTPUT IS TO BE COMPRESSED\n         LA    RZ,3(RZ)            SKIP 3 SPACES BEFORE NEXT SYMBOL\n         CR    RZ,RA               IS PTR TO OR PAST THAT POINT?\n         BL    *+8                 NO,MOVE CHARACTERS INTO LINE\nXRPSYMBL BAL   R14,XRPRLINE        PRINT OUTPUT LINE\n         LTR   RX,RX               THREAD OR NODE?\n         BNP   *+12                A THREAD, PRINT NODE\n         LA    RW,0(RX,RE)         @ OF NODE IN RW\n         B     XRPLLNK             CHECK FOR LEFT\n         LPR   RW,RX               @ OF NODE TO PRINTED\n         LA    RW,0(RW,RE)         @ OF NODE TO BE PRINTED\n         SPACE 1\n*        OBTAIN AND PRINT SYMBOL\nXRPRNODE L     RY,XREFSYM          GET @ OF SYMBOL'S SYMSECT ENTRY\n         USING SYMSECT,RY          DO USING\n         IC    RD,SYCHARS          GET LENGTH OF SYMBOL\n         EX    RD,XRPMOVE          MOVE SYMBOL TO OUTPUT LINE\n         LA    RZ,9(RZ)            INVREMENT PTR TO POSITION IN OUTPUT\n         L     RB,XREFBLCK         GET @ OF REFERENCE BLOCK\n         USING XREFBLK,RB          SET UP REFERENCE BLOCK DSECT\n         UNPK  0(7,RZ),SYVALUE+1(4) UNPACK\n         MVI   6(RZ),C' '          MAKE BLANK\n         TR    0(6,RZ),AWTHEX3     FINISH HEX CONVERT\n         LA    RZ,6(RZ)            INCR PTR TO POSITION IN OUTPUT LINE\n         BAL   R14,XRPNUMSL        GET NUM OF SLOTS USED AND TIMES LOOP\nXRPNEXT# CR    RZ,R0               IS IT THE END OF THE LINE?\n         BL    *+8                 NO GET STMT NO.\n         BAL   R14,XRPRLINE        YES PRINT LINE\n         LA    RC,2(RX,RX)         SAVE NUMBER TO BE PRINTED\n         LH    RC,0(RC,RB)         PUT STM # IN REG\n         CVD   RC,AVDWORK2         PACKED DECIMAL VALUE OF STMT #\n         MVC   0(6,RZ),AWEP6       MOVE EDIT PATTERN IN\n         LA    R1,5(RZ) DO NOT REMOVE..A MUST FOR 1 DIGIT,NEGATIVE    L\n*                       STATEMENT NUMBERS..EDMK NEEDS THIS @          L\n         EDMK  0(6,RZ),AVDWORK2+5  EDIT STMT # TO PRINTABLE FORM\n         BNM   *+10                POSITIVE STMT # (MOD REF)\n         BCTR  R1,0                GET @ TO INSERT -\n         MVI   0(R1),C'-'          INSERT MINUS SIGN TO SHOW MODIFY\n         LA    RZ,6(RZ)            INREMENT PTR TO  POS IN OUTPUT LINE\n         BCTR  RX,0                DECREMENT TIMES THRU LOOP\n         CR    RD,RX               HAVE ALL REFS IN BLK BEEN COLLECTED?\n         BL    XRPNEXT#            NO,IF LOW\n         SPACE 1\n         LTR   RY,RY               IS THERE ANOTHER BLOCK OF REFERENCES\n         BNM   XRPRLNK             NO GET NEXT SYMBOL IN TREE\n         LPR   RB,RY               PUT @ OF NEXT BLOCK IN RB\n         BAL   R14,XRPNUMSL        GET NUMBER OF SLOTS USED; TIMES THRU\n         B     XRPNEXT#            PRINT NEXT REFERENCE\nXRPMOVE  MVC   0($,RZ),SYMBOL      MOVE SYMBOL TO OUTPUT LINE  EXECUTED\n         SPACE 3\n*.--> INSUB: XRPRLINE       PRINTS A LINE OF REFERENCES . . . . . . . .\n*.       SETS RZ TO POINT TO THE BEGINNING OF THE LINE. CLEAR         .\n*.       OUTPUT LINE TO ALL BLANKS.                                   .\n*.  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ..\n         SPACE 2\nXRPRLINE $PRNT XRPOUTPT,XRPL,XRPMSG PRINT OUT THE LINE OF REFERENCES\n         LA    RZ,XRPOUTPT+1       GET ADDRESS OF OUTPUT LINE\n         MVC   XRPOUTPT(XRPL),AWBLANK   CLEARS OUTPUT LINE\n         BR    R14                 RETURN\n         SPACE 3\n*.--> INSUB: XRPNUMSL . . . . . . . . . . . . . . . . . . . . . . . . .\n*.       GETS INDEX TO 1ST REFERENCE OF BLOCK, INDEX TO LAST REFERENCE.\n*.       TO PRINT, AND VALUE FROM XRBLKNUM TO USE AS FLAG FOR TEST FOR.\n*.       ADDITIONAL BLOCKS LATER IN MAIN SECTION OF CODE.             .\n*.         RX=  INDEX TO 1ST REFERENCE TO BE PRINTED                  .\n*.         RD=  INDEX TO LAST REFERENCE TO BE PRINTED                 .\n*.         RY=  FLAG USED LATER(IF - THERE IS AN ADDITIONAL BLOCK)    .\n*......................................................................\n         SPACE 2\nXRPNUMSL LA    RX,&$XREF#B         RX=POSS # REFS(ASSUME 1ST BLOCK\n         L     RY,XRBLKNUM         GET # OF UNUSED SLOTS\n         LTR   RD,RY               IS IT AN @ OR # OF SLOTS\n         BCR   NM,R14              RD=LAST REFERENCE\n         SR    RD,RD               RD=LAST REFERENCE\n         BR    R14                 RETURN\n         SPACE 3\n* XRPMSG EQU   XRPRRET  *****      RETURN ON RECORDS EXCEEDED  CEH\nXRPRRETP $PRNT XRPOUTPT,XRPL,XRPMSG        PRINT LAST LINE\nXRPRRET  $RETURN RGS=(R14-R6),SA=NO\nXRPMSG   EQU   XRPRRET             RETURN ON RECORDS EXCEEDED  CEH\nXRPOUTPT EQU   AVCONCAT            WORK AREA\nXREFTTL1 DC    C'0*** CROSS-REFERENCE:  VALUE(HEX) LOCATION REF REF ...X\n                (- SHOWS MODIFY) ***'\n         DROP  RW,RY,RB,RAT\n.XXNOXRF ANOP\n         AIF   (&$REPL EQ 0).RENREPL        SKIP IF NO REPLACE AT ALL\n         TITLE 'RECORBLK DSECT - REPLACE CORRESPONDENCE TABLE'\n**--> DSECT: RECORBLK   REPLACE MODULE-DESCRIBES 1 REAL-REPLACE PAIR. .\n*.             THIS DSECT DESCRIBES 1 ENTRY IN THE TABLE RECORRAD.    .\n*.       WHEN AN ENTRY POINT IS REPLACED, A RECORBLK IS CREATED FOR   .\n*.       IT AND FILLED WITH VALUES FROM THE ENTRY POINT'S RFSYMBLK.   .\n*.       THE ENTRY ADDRESS OF THE NEW ENTRY IS FOUND FROM THE SYMBOL  .\n*.       TABLE (WHICH STILL EXISTS), AND IS SAVED INTO THE RECFPSW    .\n*.       FIELD (OR A -1 PLACED HERE TO SHOW THE ENTRY COULD NOT BE    .\n*.       FOUND IN THE USER PROGRAM).  USING THE RECAXAD FIELD, WHICH  .\n*.       POINTS TO THE ADCON IN AVWXTABL OF THE REAL ROUTINE, THE REAL.\n*.       ADCON IS SAVED IN RECADRE, AND IT IS REPLACED BY THE ADDRESS .\n*.       OF REFAKE.  A CODE IS PLACED INTO THE HI-ORDER BYTE OF THE   .\n*.       WORD IN AVWXTABL, WHICH IS USED BY REFAKE TO IDENTIFY WHICH  .\n*.       ENTRY IS CALLED.                                             .\n*.             AT THE END OF A REPLACE RUN, THE REAL ADCONS ARE MOVED .\n*.       BACK TO THEIR PROPER PLACES IN AVWXTABL, USING THE RECAXAD   .\n*.       FIELD OF EACH RECORBLK ELEMENT IN THE RECORRAD TABLE.        .\n*.       **NOTE** FIRST SECTION OF DSECT SAME AS DSECT RFSYMBLK.      .\n*.       LOCATION: CSECT REMONI, TABLE RECORRAD.                      .\n*.       NAMES: REC-----                                              .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n         SPACE 1\nRECORBLK DSECT\n*              DATA TRANSFERRED FROM RFSYMS CSECT TABLES.\nRECSYMB  DS    CL6                 ENTRY POINT NAME\nRECAXAD  DS    H                   OFFSET IN AVWXTABL=AX#-AX$BASE\nRECRGAD  DS    H                   OFFSET FOR CHECK CODE=RG#-RGENTS\n         SPACE 1\nRECADRE  DS    V                   SPACE TO SAVE REAL ADDRESS CONSTNAT\nRECFPSW  DS    0F                  BEGINNING PSW FOR ONE ENTRY POINT\nRECFPCC  DS    C                   ILC-CC-PM, ALSO USED AS FLAG\nRECFPAD  DS    AL3                 BEGINNING @ FOR ENTRY POINT IN FAKE\n         SPACE 1\n*              RUN STATISTICS VARIABLES\nRECINSTS DS    F                   CUMULATIVE # INSTRUCTIONS DONE\nRECCALLS DS    H                   CUMULATIVE # TIMES ENTRY CALLED\nRECWRONG DS    H                   CUMULATIVE # TIMES PROG WRONG VALUES\nRECZ$L   EQU   *-RECINSTS          LENGTH TO BE ZEROED-COUNTERS\nREC$LEN  EQU   ((*-RECORBLK+3)/4)*4         LENGTH, RNDED TO FULLWRD\n         TITLE 'RFSYMBLK DSECT - REPLACE ENTRY INFORMATION TABLE'\n**--> DSECT: RFSYMBLK   REPLACE MODULE: 1 ENTRY IN TABLE CSECT RFSYMS .\n*.             EACH SECTION OF RFSYMS GIVES EITHER A REPLACABLE       .\n*.       CSECT NAME OR ONE OF ITS ENTRY POINT NAMES.   THE ENTRY      .\n*.       POINT ELEMENTS CONTAIN VARIOUS POINTERS WHICH ARE USED TO    .\n*.       GIVE OFFSET ADDRESSES FOR REAL ENTRY ADDRESS CONSTANTS OR    .\n*.       FOR VARIOUS CHECKING CODE IN THE REPLACE MONITOR.            .\n*.       **NOTE** THIS DSECT IS SAME AS FIRST PART OF RECORBLK DSECT. .\n*.       GENERATION: 1 CALL TO RFSGN MACRO CREATS 1 CSECT ELEMENT     .\n*.             AND 1 TO REC$MAX  ENTRY ELEMENTS.                      .\n*.       LOCATION: CSECT RFSYMS.                                      .\n*.       NAMES: RFS-----                                              .\n*.  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n         SPACE 1\nRFSYMBLK DSECT\nRFSYMB   DS    CL6                 CSECT/ENTRY NAME, ALPHAMERIC\nRFSENTN  DS    AL1                 CSECT: NUMBER OF ENTRY POINTS\nRFSENTL  DS    AL1                 CSECT: LENGTH OF CSECT+ENTRY BLKS\nRFSRIAD  DS    H                   OFFSET TO RI&CSECT-PTRS TO CALLABLES\n         SPACE 1\n         ORG   RFSENTN             ORG BACK . DEFINE ENTRY FIELDS\nRFSAXAD  DS    H                   OFFSET TO ENTRY ADCON IN AVWXTABL\n*                                  = AXENTRY - AX$BASE\nRFSRGAD  DS    H                   OFFSET TO REG CHECKING CODE FOR\n*                                  RETURN VALUES. = RGENTRY-RGENTS\n         ORG   RFSRGAD             BACK OVER, REALLY FOR RFSYMS PART 2\nRFSRHAD  DS    H                   OFFSET TO CODE TO CHECK REGS FOR\n*                                  CALLING OTHER PROGS.=RHENTRY-RHENTS\nRFS$LEN  EQU   ((*-RFSYMBLK+1)/2)*2         LENGTH OF BLOCK,RD FULLWORD\n         TITLE 'REMONI - REPLACE MONITOR CONTROL PROGRAM'\n         PRINT NOGEN\nREMONI   CSECT\n**--> CSECT: REMONI     REPLACE MONITOR CONTROL PROGRAM . . . . . . . .\n*.       REMONI HANDLES MOST OF THE DETIALS REQUIRED FOR A STUDENT TO .\n*.  WRITE AN ASSIST CSECT, HAVE IT ASSEMBLED BY ASSIST, AND THEN RUN  .\n*.  A TEST PROGRAM.  THE ENTRYPOINTS OF HIS PROGRAM ARE CALLED ALONG  .\n*.  WITH THE ORIGINALS, AND HIS RESULTS CHECKED FOR ACCURACY.  WHILE  .\n*.  ADDRESS CONSTANT MODIFCATION IS PERFORMED, THE ENTIRE PROCESS IS  .\n*.  STILL A SERIALLY RESUABLE PROGRAM.  SEE THE ASSIST REPLACE USER'S .\n*.  GUIDE   FOR DETAILS ON USING THE REPLACE MONITOR.                 .\n*.       NAMES: RE------           MAIN CODE BODY AND INSUBS.         .\n*.       NAMES: RG------           CHECKING CODE FOR RETURN VALUES.   .\n*.       NAMES: RH------           EXTERNAL CALL CHECKING (&$REPL=2)  .\n*.       CALLS SYFIND                                                 .\n*.       USES DSECTS: AJOBCON,AVWXTABL,ECONTROL,RECORBLK,RFSYMBLK     .\n*.       USES MACROS: $CALL,$PRNT,$RETURN,$SAVE,REPRNT,XDECO,XSNAP    .\n*.                                                                    .\n*.       OVERALL REGISTER CONVENTIONS AND USAGE.                      .\n*.  R0,R1,R2,R3,R4,R15  WORK REGISTERS                                .\n*.  R5 = @ RECORBLK ELEMENT FOR CURRENT ENTRY BEING PROCESSED.        .\n*.  R6 = BASE REGISTER FOR MAIN CODE OF EACH REMONI ENTRY POINT.      .\n*.  R7,R8      USUAL PARAMETER REGS FOR INTERNAL SUBROUTINES.         .\n*.  R9 = LINK REGISTER FOR INSUBS WHICH MUST CALL OTHERS WITH R14.    .\n*.  R10= @ ECONTROL (EXECUTION CONTROL BLOCK, USER PSEUDO REGISTERS.  .\n*.  R11= @ AJOBCON DSECT (MAIN JOB CONTROL TABLE)                     .\n*.  R12(RAT)= @ VWXTABL CSECT (AVWXTABL DSECT).                       .\n*.  R13= SAVE AREA ADDRESS, BASE REGISTER FOR DATA, INTERNAL SUBRS.   .\n*.  R14= INTERNAL LINK REGISTER. LOCAL WORK REGISTER.                 .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n         SPACE 1\n         $DBG  ,NO                 NO DEBUG\n         ENTRY REINTA,REENDA,REFAKE    ENTRIES ALWAYS PRESENT\n         SPACE 1\n*              REMONI FLAG EQUATES\nREADMOD  EQU   B'00000001'         (REFLAGS)=>ADCONS IN AX ARE MODIFID\nREFPRT   EQU   B'00000010'         (REFLAGS)=> REFAKE PRTED >=1 MSG,SKP\n         SPACE 1\nREC$MAX  EQU   5                   MAXIMUM # ENTRIES TO BE REPLACED\n         EJECT\n**--> ENTRY: REINTA     INITIALZE BEFORE ASSEMBLER CALLED . . . . . . .\n*.       THIS ENTRY IS CALLED 1 TIME BEFORE ASSIST ASSEMBLER IS CALLED.\n*.  IT CHECKS FOR PRESENCE OF REAL ADDRESS CONSTANTS IN VWXTABL, AND  .\n*.  REPLACES THEM IF THEY HAVE BEEN MODIFIED IN PREVIOUS REPLACE RUN. .\n*.       IT ALSO MAY SET FLAGS IN AVWXTABL IF THE SYSTEM IS IN        .\n*.       REPLACE PHASE A (ASSEMBLE REPLACEMENT PROGRAM AND LINK IT).  .\n*.       ENTRY CONDITIONS                                             .\n*.  R11= @ AJOBCON (MAIN JOB CONTROL BLOCK).                          .\n*.  R12(RAT)= @ VWXTABL CSECT (AVWXTABL DSECT).                       .\n*.                                                                    .\n*.  AVWXTABL: HAS BEEN COMPLETELY INITIALIZED BY MAIN PROGRAM ASSIST. .\n*.       THIS PERMITS REINTA TO MODIFY ASSEMBLER CONTROL FLAGS IF     .\n*.       NEEDED TO MAKE ASSEMBLER PERFORM REQUIRED ACTIONS.           .\n*.       USES DSECTS: AJOBCON,AVWXTABL                                .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nREINTA   $SAVE RGS=(R14-R12),BR=R6,SA=RESAVE\n         USING RESAVE,R13          NOTE AVAIL AS BASE\n         USING AVWXTABL,RAT        NOTE ASSEMBLER TABLE USING\n         USING AJOBCON,R11         NOTE MAIN JOB CONTROL TABLE\n         TM    AJOMODE,AJOREPLF+AJOREPHB    TEST REPLACE STATUS\n         BZ    REINREAL            NOT REPLACE AT ALL, RESTORE ADCONS\n         BM    REINPHSA            AJOREPLF ONLY==> REPLACE PHASE A-BR\n         SPACE 2\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*              PRE-ASSEMBLY -- REPLACEMENT PHASE B                    *\n*        THIS ACTION OCCURS JUST BEFORE THE ASSEMBLER IS CALLED WITH  *\n*        MODIFIED ADCON TABLE FOR THE TEST RUN OF USER-WRITTEN CSECT. *\n*        DON'T MODIFY ADCONS AGAIN, BUT FIX AVWXTABL FLAGS SO RUN     *\n*        WILL BE NORMAL.                                              *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         OI    AJOSTEP,AJOSEXEC    SHOW MAY BE IN INTERP FROM NOW ON\n         NI    AVTAGS1,255-AJORELOC         SHOW NO RELOCATION\n         B     REINRETA            BRANCH TO EXIT CODE\n         SPACE 2\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*              PRE-ASSEMBLY -- REPLACEMENT PHASE A                    *\n*        THIS SECTION IS ENTERED JUST BEFORE A USER-WRITTEN REPLACE   *\n*        CSECT IS ASSEMBLED.  MAKE SURE THAT THE REAL ADCONS ARE IN   *\n*        AVWXTABL (MAY HAVE BEEN CHANGED BY PREVIOUS REPLACE RUN),    *\n*        AND SET FLAGS REQUIRED FOR REPLACEMENT. THIS INCLUDES        *\n*        MAKING THE ASSEMBLER RELOACTE THE OBJECT CODE TO ITS         *\n*        ACTUAL LOCATION IN MEMORY, SIMPLIFYING DUMP PRINTING AND     *\n*        DATA TRANSFERS.                                              *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nREINPHSA EQU   *                   ENTRY LABEL: REPLACE PHASE A\n         OI    AVTAGS1,AJORELOC    WE WANT USER PROGR AT REAL ADDRESS\n*              FALL THRU, HAVE ANY MODIFIED ADCONS RESTORED IF NEEDED.\n         SPACE 1\nREINREAL BAL   R14,REREAL          HAVE REAL ADCONS REPLACED, IF NEED\nREINRETA EQU   *                   EXIT LABEL\nREINRET  $RETURN RGS=(R14-R12)\n         DROP  R6,R11,RAT,R13      REMV USINGS\n         AIF   (&$REPL LT 2).RESY1     SKIP IF NO CALLING ALLOWED\n         EJECT\n**--> ENTRY: RESYMB     ENTER CODE IN SYMBOL TABLE OF CALLABLE ENTRY. .\n*.       RESYMB IS CALLED FROM CVCON2 IF A SYMBOL FLAGGED EXTRN IS    .\n*.  USED IN A VCON.  IT PLACES A CODE INTO THE SYVALUE ENTRY OF THE   .\n*.  SYMBOLS SYMSECT.  THIS CODE (THE OFFSET TO A CALLABLE ENTRY       .\n*.  ELEMENT IN THE SECOND SECTION OF RFSYMS), IS USED FOR CHECKING    .\n*.  WHEN THE USER PROGRAM ACTUALLY CALLS THE ROUTINE.                 .\n*.       ENTRY CONDITIONS                                             .\n*.  RA = @ SYMSECT FOR THE EXTRN SYMBOL.                              .\n*.  ALL OTHER REGS: SAME AS ASSEMBLER REGISTER CONVENTIONS.           .\n*.       EXIT CONDITIONS                                              .\n*.  RA = @ SAME SYMSECT, BUT CODE HAS BEEN ENTERED IN SYVALUE.        .\n*.  RB = 0     IF SYMBOL WAS LEGITAMATE.                              .\n*.     = 4     IF SYMBOL WAS NOT LEGITAMETE ENTRY TO BE CALLED.       .\n*.       NAMES: RES-----                                              .\n*.       USES DSECTS: RFSYMBLK,SYMSECT                                .\n*.  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n         SPACE 1\n         ENTRY RESYMB              DECLARE HERE, SINCE MAY NOT EXIST\nRESYMB   $SAVE RGS=(R14-R6),SA=RESAVE,BR=R6\n         USING RESAVE,R13          NOTE FOR SAFETY\n         USING SYMSECT,RA          NOTE SYMBOL TABLE PTR\n         L     R3,RERFSYMS         =V(RFSYMS)\n         USING RFSYMS,R3           NOTE PTR TO TABLE CSECT\n         LA    R0,RFS$LEN          INCREMENT FOR BXLE SEARCH\n         LA    R1,RFSCALLZ-RFS$LEN LIMIT @ FOR BXLE\n         LA    R2,RFSCALLA         INDEX FOR BXLE\n         USING RFSYMBLK,R2         NOTE BLOCK PTR\n         SPACE 1\n*              SEARCH CALLABLE ENTRY TABLE FOR THE GIVEN ENTRY.\n         CLC   RFSYMB,SYMBOL       IS IT? (IGNORE 7-8 CHAR SYMBOLS)\n         BE    RESFOUND            YES, SKIP OUT\n         BXLE  R2,R0,*-10          LOOP THROUTHE TABLE\n         SPACE 1\n         LA    RB,4                COULDNT FIND IT, FLAG SO ANDRETRN\nRESRETA  EQU   *                   EXIT LABEL\n         $RETURN RGS=(R14-R6)      RTURN, RESTORE ALL BUT PARM REGS\n         SPACE 1\n*              SYMBOL FOUND - PUT OFFSET TO TABLE ELEMENT IN SYMTAB.\nRESFOUND SR    R2,R3               GET OFFSET FROM RFSYMS TO ELEMENT\n         ST    R2,SYVALUE          SAVE THIS AS SYMBOL VALUE\n         SR    RB,RB               CLEAR TO SHOW OK\n         B     RESRETA             GO RETURN\n         DROP  R2,R3,R6,RA,R13     RFSYMBLK,RFSYMS,BASE1,SYMSECT,BASE2\n.RESY1   ANOP\n         EJECT\n**--> ENTRY: REENDA     REPLACE MODULE: POST-ASSEMBLY PROCESSING  . . .\n*.       REENDA IS CALLED JUST AFTER AN ASSEMBLY IS COMPLETED.        .\n*.       IF THE RUN IS NOT A REPLACE RUN, NOTHING IS DONE.            .\n*.       IF IT IS REPLACE PHASE A, THE ASSEMBLED PROGRAM WAS A REPLACE.\n*.  VERSION OF AN ASSIST MODULE, SO CHECK AND MODIFY ASSEMBLER ADCONS..\n*.       IF THE RUN IS IN PHASE B, THE ASSEMBLY JUST FINISHED WAS     .\n*.  A TEST PROGRAM, SO PRINT PERFORMANCE STATISTICS FOR THE MODULE.   .\n*.       ENTRY CONDITIONS                                             .\n*.  R11= @ AJOBCON (MAIN JOB CONTROL BLOCK).                          .\n*.  R12(RAT)= @ VWXTABL CSECT (AVWXTABL DSECT).                       .\n*.       CALLS SYFIND                                                 .\n*.       USES DSECTS: AJOBCON,AVWXTABL,RECORBLK,RFSYMBLK,SYMSECT      .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nREENDA   $SAVE RGS=(R14-R12),BR=R6,SA=RESAVE\n         USING RESAVE,R13          NOTE 2ND BASE REGISTER\n         USING AVWXTABL,RAT        NOTE MAIN ASSEMBLER TABLE USING\n         USING AJOBCON,R11         NOTE POINTER THERE\n         SPACE 1\n*              DETERMINE REPLACE PHASE (IF ANY). IF PHASE A, LINK\n*              REPLACEMENT PROGRAM.  IF PHASE B, PRINT STATISTICS.\n         TM    AJOMODE,AJOREPLF+AJOREPHB    REPLACE STATUS\n         BZ    REENRET             NO REPLACE, DON'T DO ANYTHING\n         BO    REEPHSB             BOTH FLAGS==> PHASE B-BRANCH\n         SPACE 1\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*              POST-ASSEMBLY -- REPLACEMENT PHASE A                   *\n*        FIND CSECT NAME IN RFSYMS TABLE.  CREATE A RECORBLK BLOCK    *\n*        FOR EACH ENTRY POINT, FILLING IN VALUES.  MODIFY THE ADCONS  *\n*        IN AVWXTABL WHICH BELONG TO ENTRYPOINTS OF THE CSECT.        *\n*        PRINT ERROR MESSAGES FOR ANY MISSING NAMES.                  *\n*              ***** PHASE A REGISTER USAGE *****                     *\n*   R1 = @ RFSYMBLK OF CSECT, THEN ENTRY POINT BEING PROCESSED        *\n*   R2 = INCREMENT FROM EACH CSECT ELEMENT TO THE NEXT DURING SEARCH. *\n*   R3 = OFFSET VALUE OF RECORBLK FROM BEGINNING OF RECORRAD          *\n*      = NUMBER OF ENTRY ELEMENTS LEFT TO PROCESS FOR GIVEN CSECT     *\n*   R4 = @ SYFIND. MUST BE SAVED HERE BECUASE IT IS LEGAL TO REPLACE  *\n*        SYFIND, THUS LEADING TO INTERCEPTED CALL WHEN SYFIND IS      *\n*        CALLED TO LOOKUP SYEND2, WITH ADCON ALREADY MODIFIED.        *\n*   R5 = @ RECORBLK ELEMENT IN RECORRAD OF ENTRY BEING PROCESSED      *\n*   R7(RA)= @ ENTRYPOINT SYMSECT, THEN ADDRESS OF THAT ENTRY          *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n*              INITIALIZE FOR SEARCH FOR AJOREPL IN RFSYMS LIST.\n         L     R1,RERFSYMS         GET ADCON FOR RFSYMS\n         SR    R2,R2               CLEAR FOR INSERTIONS\n         LA    R3,RFSYMS$L-RFS$LEN(R1) ADEQUATE LIMIT FOR BXLE\n         USING RFSYMBLK,R1         OVERLAY DSECT ON 1ST SECTION RFSYMS\n         L     R4,AXSYFIND         =V(SYFIND), GET IT NOW, SO SAFE\n         EJECT\n*              SEARCH FOR CSECT NAME TO BE REPLACED.\n*              LOOK AT EACH CSECT NAME IN RFSYMS, UNTIL ONE IS FOUND\n*              WHICH IS IN THE SYMBOL TABLE AND DECLARED CSECT.\nREESEARC LA    RA,RFSYMB           SHOW @ OF CSECT NAME\n         LA    RB,L'RFSYMB         SHOW LENGTH OF IT (ALWAYS 6)\n         LR    REP,R4              REP= =V(SYFIND). MOVE OVER FOR CALL\n         BALR  RET,REP             CALL SYFIND TO LOOKUP THE SYMBOL\n         L     R11,AVAJOBPT        RESTORE THE PTR IN CASE NEEDED\n         SPACE 1\n         LTR   RB,RB               WAS THE SYMBOL IN THE SYMBOL TABLE\n         BNZ   REESEARE            NO, SO SKIP TO LOOK AT NEXT ONE\n         USING SYMSECT,RA          NOTE SYMBOL TABLE PTR, IT WAS IN\n         TM    SYFLAGS,$SYCSE      WAS IT FLAGGED A CSECT (A MUST)\n         BO    REEFOUND            YES, THIS IS ONE WE'RE LOOKING FOR\n         DROP  RA                  REMOVE SYMSECT USING\n         SPACE 1\nREESEARE IC    R2,RFSENTL          GET LENGTH OF CSECT+ENTRY ENTIRES\n         BXLE  R1,R2,REESEARC      ADD INCREM TO NEXT CSECT, LOOP OK\n         SPACE 1\n*              FALLS THRU==> CSECT NAME TO BE REPLACED NOT FOUND.\n*              FLAG PROGRAM UNEXECUTABLE, NEVER ENTER PHASE B.\n         OI    AVTAGS1,AJNLOAD     SHOW THE REPLACE PROG NOGOOD,NO EXEC\n         REPRNT REZAR100,L'REZAR100    MISSING NAME MESSAGE\n         B     REENRET             RETURN, NO ADCONS CHANGED\n         SPACE 1\n*              CSECT NAME FOUND, NOW LINK ITS ENTRY POINTS IN VWXTABL.\nREEFOUND MVC   REZCSECT,RFSYMB     MOVE REPLACED CSECT NAME OVER\n         REPRNT REZAR000,REZ000L   PRINT MESSAGE WITH CSECT NAME\n         SPACE 1\n         IC    R2,RFSENTN          GET # ENTRIES BELONGING TO CSECT\n         STH   R2,RECORNUM         STORE COUNT INTO CORRESPONDENCE #\n         MVC   REFRIAD,RFSRIAD     SAVE @ OFFSET TO CALL LIST CHK VALS\n         LA    R1,RFS$LEN(R1)      SET RFSYMBLK TO 1ST ENTRY-TYPE ENTRY\n         LA    R5,RECORRAD         INIT TO BEGINNING @ OF CORRES TABLE\n         USING RECORBLK,R5         NOTE DSECT PTR\n         SR    R3,R3               CLEAR, WILL BE INDEX TO RECORRAD\n         SPACE 1\n*              LOOP THRU ENTRY LIST.  LOOK EACH ONE UP IN SYMBOL\n*              TABLE. OBTAIN EACH ENTRY POINT @ AND CREATE A RECORBLK\n*              ELEMENT FOR IT.  MODIFY ADCON IN AVWXTABL.\nREESYCAL LA    RA,RFSYMB           @ SYMBOLIC ENTRYPT NAME\n         LA    RB,L'RFSYMB         LENGTH OF NAME(ALWAYS 6)\n*              SYFIND MAY ERASE REGISTERS RA-RE (R7-R11).\n         LR    REP,R4              REP= =V(SYFIND). MOVE OVER FOR CALL\n         BALR  RET,REP             CALL SYFIND TO LOOKUP THE SYMBOL\n         L     R11,AVAJOBPT        RESTORE R11 IN CASE WE NEED IT\n         LTR   RB,RB               WAS IT THERE\n         BNZ   REENOENT            NO, UNDEFINED, NOT IN TABLE AT ALL\n         USING SYMSECT,RA          NOTE SYMBOL TABLE POINTER\n         TM    SYFLAGS,$SYDEF      WAS SYMBOL DEFINED\n         BZ    REENOENT            NO,FLAG IT\n         TM    SYFLAGS,$SYENT+$SYCSE   WAS IT EITHER CSECT OR ENTRY\n         BZ    REENOENT            NO, SO FLAG IT\n         L     R7,SYVALUE          GET VALUE OF SYMBOL, FOR ENTRY\n         DROP  RA                  NO MORE SYMBOL DSECT\n         B     REENLINK            BRANCH TO LINKAGE SEGMENT\n         EJECT\n*              ENTRY NOT FOUND OR UNDEFINED - PRINT MESSAGE, FLAG.\nREENOENT MVC   REZEN002,RFSYMB     MOVE THE ENTRY NAME OVER\n         REPRNT REZAR002,REZ002L   MESSAGE SHOWING ENTRY NOT FOUND\n         L     R7,AWFM1            TO GO INTO RECFPSW, SHOW NOGOOD\n         SPACE 1\n*              LINK NEEDED POINTERS AND CORRESPONDENCE TABLE RECORRAD.\nREENLINK MVC   RECSYMB(RFS$LEN),RFSYMB      MOVE RFSYMBLK OVER\n         ST    R7,RECFPSW          SAVE ENTRYPT IN USER PROGRAM\n         LH    R14,RECAXAD         GET OFFSET INTO AVWXTABL FOR ADCON\n         LA    R14,AX$BASE(R14)    GET ACTUAL @ OF THE ADCON\n         MVC   RECADRE,0(R14)      SAVE THE REAL ADCON\n         MVC   RECINSTS(RECZ$L),AWZEROS     ZERO STATS COUNTERS\n*              FILL IN AVWXTABL WORD- @ REFAKE, OFFSET ID OF ENTRYPT\n         MVC   0(4,R14),REREFAKE   PUT IN @ FAKE/CHECK ROUTINE\n         STC   R3,0(,R14)          STORE RECORBLK OFFSET INTO ADCON BYT\n         SPACE 1\n*              CHECK IF ENTRY OK, PRINT MESSAGE IF SO.\n         LTR   R7,R7               WAS ENTRY @ < 0 (I.E. NOT FOUND)\n         BM    REENOENS            NO, MESSAGE ALREADY PRINTED\n         LA    R8,REZLOCAT         SHOW @ FOR HEX CONVERSION\n         BAL   R14,REXCON3         CONVERT TO HEX\n         MVC   REZEN001,RFSYMB     MOVE SYMBOL IN FOR ENTRY NAME\n         REPRNT REZAR001,REZ001L   MESSAGE DESCRIBNG OK ENTRY\n         SPACE 1\nREENOENS LA    R1,RFS$LEN(R1)      BUMP PTR TO NEXT RFSYMBLK ENTRY\n         LA    R3,REC$LEN(R3)      INCREMENT OFFSET VALUE IN RECORRAD\n         LA    R5,REC$LEN(R5)      BUMP PTR TO NEXT RECORBLK ELEMENT\n         BCT   R2,REESYCAL         GO BACK FOR NEXT ENTRY. LOOP ON #\n         DROP  R1,R5               REMV RFSYMBLK,RECORBLK\n         SPACE 1\n         OI    REFLAGS,READMOD     SHOW WE'VE MODIFIED ADCONS\n         B     REENRET             RETURN TO CALLING PROGRAM\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*              POST-ASSEMBLY -- REPLACEMENT PHASE B                   *\n*        PRINT STATISTICS OF USER-PROGRAM PERFORMANCE.                *\n*              ***** PHASE B REGISTER USAGE *****                     *\n*   R0,R1,R2,R8,R9      WORK REGISTERS                                *\n*   R4 = NUMBER OF RECORBLK ENTRIES LEFT TO PROCESS                   *\n*   R5 = @ RECORBLK OF ENTRY WHOSE STATISTICS ARE BEING CALCULATED.   *\n*   R7 = @ 12-BYTE FIELD WHERE NEXT OUTPUT NUMBER TO BE PLACED        *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nREEPHSB  REPRNT REZAR003,REZ003L   PRINT HEADER LINE\n         LH    R4,RECORNUM         # ENTRY POINTS FOR LOOP COINTER\n         LA    R5,RECORRAD         INIT @ TO BEGINNING OF TABLE\n         USING RECORBLK,R5         NOTE POINTER\n         SPACE 1\nREESTATS MVC   REZ004EN,RECSYMB    MOVE ENTRYPOINT NAME OVER\n         LA    R7,REZ004NS         @ 1ST OUTPUT NUMBER, INCRD BY DECO\n         SPACE 1\n         L     R8,RECINSTS         # INSTRUCTIONS DONE\n         BAL   R14,REEXDECO        PRINT IT, ADVANCE R7 PTR\n         SPACE 1\n         LR    R1,R8               SAVE # INSTRUCTIONS DONE FOR LATER\n         LH    R8,RECCALLS         # CALLS TO ROUTINE\n         BAL   R14,REEXDECO        CONVERT # CALLS, ADVANCE R7\n         SPACE 1\n         LR    R2,R8               SAVE # CALLS FOR LATER DIVIDESX\n         LH    R8,RECWRONG         GET # WRONG RETURN TIMES\n         BAL   R14,REEXDECO        CONVERT # WRONG, ADVANCE R7\n         SPACE 1\n         LR    R9,R8               SAVE # WRONG\n         LTR   R2,R2               WAS # CALLS ZERO\n         BNZ   *+8                 NO, SO LEAVE AS IS\n         LA    R2,1                YES, =0, SO MAKE =1 FOR SAFE DIVIDES\n         SR    R0,R0               CLEAR FOR DIVIDE SETUP\n         DR    R0,R2               AVG # INSTRS/CALL\n         LR    R8,R1               MOVE QUOTIENT OVER FOR CONVERT\n         BAL   R14,REEXDECO        CALL CONVERT ROUTINE, ADVANCE R7\n         SPACE 1\n         LA    R8,100              VALUE FOR PERCENT CONVERT\n         MR    R8,R8               # WRONG * 100, RESULT IN R9\n         DR    R8,R2               #WRONG*100/#CALLS = PERCENT\n         LR    R8,R9               MOVE QUOTIENT FOR CONVERT\n         BAL   R14,REEXDECO        CONVERT, ADVANCE R7\n         SPACE 1\n         REPRNT REZAR004,REZ004L   PRINT MESSAGE FOR THIS ENTRY\n         LA    R5,REC$LEN(R5)      INCREMENT THE RECORBLK PTR\n         BCT   R4,REESTATS         LOOP BACK FOR NEXT RECORBLK VALS\n         DROP  R5                  DON'T NEED RECORBLK ANYMORE\n         SPACE 1\nREENRET  $RETURN RGS=(R14-R12)\n         DROP  R6,R11,RAT,R13      DROP TABLE USINGS, BASE REGS\n         EJECT\n**--> ENTRY: REFAKE     INTERCEPT REPLACED CALLS, CHECK REAL/USER . . .\n*.       ENTRY CONDITIONS                                             .\n*.  R15(BITS 0-7)= OFFSET CODE # FOR SPECIFIC ENTRY BEING CALLED.     .\n*.  R0-R14     ARE AS DESCRIBED IN ASSEMBLER CALLING CONVENTIONS.     .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n         SPACE 1\n* * * * * REFAKE ENTRY REGISTER USAGE * * * * * * * * * * * * * * * * *\n*   R0,R1,R2,R3,R4,R15  WORK REGISTERS                                *\n*   R5 = @ RECORBLK ELEMENT FOR THE ENTRY POINT BEING CALLED.         *\n*   R6 = FIRST BASE REGISTER, USED FOR MAIN CODE.                     *\n*   R9 = LINK REGISTER FOR INSUBS WHICH MUST CALL OTHERS WITH R14.    *\n*   R10= @ ECONTROL (EXECUTION CONTROL BLOCK, USER PSEUDO REGISTERS.  *\n*   R13= SAVE AREA @, ALSO SECOND BASE REGISTER, FOR INSUBS.          *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nREFAKE   $SAVE RGS=(R14-R6),BR=R6,SA=RESAVE      SAVE ALL BUT PARM RGS\n         USING AVWXTABL,RAT        NOTE MAIN ASM TABLE USING\n         USING RESAVE,R13          NOTE SECONDARY BASE REG USING\n         SPACE 1\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*        REFAKE IS ENTERED VIA A MODIFIED ADCON IN AVWXTABL, WHICH    *\n*   ALSO CONTAINS THE OFFSET IN RECORRAD OF THE RECORBLK FOR THE      *\n*   REPLACED ENTRY BEING CALLED.  SET R5 TO THE @ THIS RECORBLK, TO BE*\n*   USED THROUGHOUT THIS CODE.  CALL THE CORRESPONDING REAL ASSIST    *\n*   ROUTINE.  SAVE INITIAL PARM REGISTER VALUES AND THOSE RETURNED    *\n*   BY REAL ROUTINE FOR TESTING, OR PRINTING.  ALSO PRINT VARIOUS     *\n*   REGISTER SETS OR THE CURRENT STATEMENT, IF REQUIRED BY SETTING    *\n*   OF VARIOUS BITS IN ECRFLAG OF THE ECONTROL BLOCK.                 *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n         STM   RA,RE,REGSAVA       SAVE ORIGINAL PARM REG VALUES\n         SRL   R15,24              GET HI-ORDER BYTE BY ITSELF\n         LA    R5,RECORRAD(R15)    ADD OFFSET TO TABLE @==>@RECORBLK\n         USING RECORBLK,R5         NOTE @ TABLE ELEMENT\n*              INCREMENT TOTAL NUMBER OF TIMES CALLED.\n         LH    R15,RECCALLS        CURRENT TOTAL NUMBER OF CALLS\n         LA    R15,1(R15)          +1 FOR THIS TIME\n         STH   R15,RECCALLS        = NEW CURRENT TOTAL # CALLS\n         SPACE 1\n*              CALL THE REAL ASSIST ROUTINE FIRST.  SAVE THE VALUES\n*              IT RETURNS IN REGISTERS RA-RE FOR LATER USE.\n         SPACE 1\n         L     R15,RECADRE         GET REAL ENTRY POINT @\n         BALR  RET,REP             CALL THE REAL ROUTINE\n         STM   RA,RE,REGSAVB       SAVE THE RETURNED PARAMETERS\n         SPACE 2\n*              ENTRY ACCEPTED, SET UP FOR INTERPRETATION\n         L     R11,AVAJOBPT        GET PTR TO ,AIN CONTROL BLOCK\n         USING AJOBCON,R11         NOTE PTR\n         L     R10,AJOECOPT        GET PTR TO PARTIALLY-FILLED ECONTROL\n         USING ECONTROL,R10        NOTE PTR\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*        DEPENDING ON ECRFLAG (WHICH CAN BE CHANGED BY THE USER PROG  *\n*   DURING EXECUTION), PRINT THE CURRENT CARDIMAGE (IF ANY), THE 5    *\n*   PARAMETER REGISTERS ON ENTRY, AND/OR THE PARAMETER REGISTERS      *\n*   RETURNED BY THE REAL ASSIST ROUTINE.                              *\n*        THEN FLIP THESE BIT FLAGS, SO THAT IF AN ERROR OCCURS, WE    *\n*   CAN PRINT ANYTHING WE DIDN'T ALREADY PRINT .                      *\n*              INIT REFPRT BIT IN REFLAGS OFF.  USE OF REXPRINT INSUB *\n*        SETS THIS BIT ON.  IF IT IS ON WHEN REFAKE EXITS, 2 LINES ARE*\n*        SKIPPED TO SEPARATE OUR MESSAGES FROM FOLLOWING LISTING. THE *\n*        LISTING IS VERY HARD TO FOLLOW IF THIS IS NOT DONE.          *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         NI    REFLAGS,255-REFPRT      INIT FLAG TO SHOW NO MSGS PRT YT\n         MVC   REFRFLAG,ECRFLAG    SAVE THE BYTES FOR LATER\n         BAL   R9,REFRFC           CALL INSUB FOR 3 CHECKS/PRINTS\n         XI    REFRFLG1,ECR$REGB+ECR$REGA+ECR$CARD    FLIP BITS\n         SPACE 2\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*        FINISH CONSTRUCTION OF ECONTROL FOR INTERPRETIVE CALL TO     *\n*   USER-WRITTEN REPLACEMENT PROGRAM.  CALL THE INTERPRETER, WITH THE *\n*   USER PROGRAM AS ARGUMENT. INCREMENT STATISTICS, AND BRANCH TO     *\n*   PROCESS POSSIBLE ERROR IF ANY BUT NORMAL RETURN INDICATED.        *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n*              TEST USER ENTRYPT TO MAKE SURE HAS BEEN FOUND.\n         CLI   RECFPCC,0           WAS BYTE 0, I.E. LEGAL @\n         BNE   REFNOCAL            NO, SO QUIT NOW, CAN'T EXECUT\n         SPACE 1\n         MVC   ECFENTER,RECFPSW    INIT ENTRY POINT TO RIGHT @\n         MVI   ECFLAG0,$ECSPIEB+$ECEOF      SET FLAG PROPERLY\n         SPACE 1\n*              INITIALIZE REGISTER CONTENTS FOR USER PROGRAM.\n         MVC   ECREGS(7*4),REFILLRG         PUT IN REGISTER FILLER\n         MVC   ECREGRA(5*4),REGSAVA         MOVE ORIG PARM REGS TO FAKE\n         MVC   ECFPREGS(32),ECREGS PUT 4'S OVER HERE ALSO\n         ST    RAT,ECREG12         SAVE AVWXTABL PTR HERE\n         MVC   ECREG13,ECSAVE1     MOVE @ DUMMY SAVEAREA INTO FAKE 13\n         MVC   ECREG14,RERFSYMS    PUT DISTINCT, EASY-TO-CHECK RET @\n         MVC   ECREG15,ECFENTER    PUT ENTRY PT @ IN FAKE R15\n         SPACE 1\nREEXECUT EQU   *                   ENTER HERE AFTER USER CALLED AN\n*                                  ASSIST MODULE AND IT REURNED OK\n         L     REP,AJOEXECU        =V(EXECUT)         PUT IN ADCON\n         BALR  RET,REP             CALL THE INTERPRETER\n         SPACE 1\n*              UPDATE TOTAL NUMBER OF INSTRUCTIONS PERFORMED.\n         LM    R14,R15,ECILIMT     GET ECILIMT-ECILIMP\n         SR    R15,R14             # INSTRUCTIONS EXECUTED THIS TIME\n         A     R15,RECINSTS        +  CUMULATIVE TOTAL FROM BEFORE\n         ST    R15,RECINSTS        =  NEW CUMULATIVE TOTAL INSTRUCTIONS\n         SPACE 1\n         MVI   RERGEFLG,0          ZERO OUT RETURN CODE FLAG\n         MVC   REZ059MS(REZ059ML),AWBLANK   BLANK OUT MESSAGE AREA\n         SPACE 1\n         CLI   ECFLAG1,$ECBRN14    WAS A PROPER RETURN DONE\n         BNE   REFNORET            NO GOOD RETURN-BRANCH\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*              CHECKING SECTION FOR USER-RETURNED REGISTERS           *\n*        1. CALL INSUB RGENTS TO CHECK REGS RA-RE FOR INDIVIDUAL CASES*\n*        2. MAKE COMMON CHECK FOR MODIFIED REGS - R0-R6, R12, R13.    *\n*        3. SET ECRFLAG IF NEEDED AND PRINT MESSAGE AR059 AND OTHER   *\n*        MESSAGES, IF THERE WERE ONE OR MORE ERRORS.                  *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         LH    R15,RECRGAD         GET OFFSET FOR SPECIFIC ERROR\n         BAL   R14,RGENTS          CALL CHECKING ROUTINE.INITS RERGEFLG\n         SPACE 1\n         NI    ECRFLAG+1,255-ECR$ERRC       INIT TO SHOW NO ERRORS\n         SPACE 1\n         CLC   ECREGS(7*4),REFILLRG         MAKE SURE DIDN'T MESS UP\n         BE    *+14                OK, SKIP ERROR\n         OI    RERGEFLG,RGE06      FLAG THIS ERROR\n         MVC   REZ059R0,=C'R0-R6'  MOVE MESSAGE IN\n         SPACE 1\n         BAL   R14,REGC1213        CALL R1K R13 CHECKER\n         SPACE 1\n         TM    RERGEFLG,X'FF'      WERE THERE ANY ERRORS AT ALL\n         BZ    REFNOERR            NO, SO SKIP PRINTING\n         SPACE 1\n         OI    ECRFLAG+1,ECR$ERRC  SET ERROR FLAG FOR THE USER\n         BAL   R9,REFRFC           PRINT OUT ANYTHING NOT ALREADY DONE\n         B     REF059PR            SKIP TEST, GO PRINT AR058-AR059\n         SPACE 1\n*              TEST FOR PRINTING REGS RETURNED BY USER PROGRAM.\nREFNOERR TM    ECRFLAG+1,ECR$REGC  DID HE WANT TO SEE RETURN REGS\n         BZ    REFRFZ08            NO, SKIP\n         SPACE 1\nREF059PR MVI   REZ05XN,C'8'        SHOW AR058 MESSAGE\n         BAL   R14,REREGSRA        CALL REREGS, PRINT ECREGSRA-\nREFRFZ08 EQU   *                   BRANCH LABEL IF PREVIOUS CODE SKIPPE\n         SPACE 1\n         TM    RERGEFLG,X'FF'      WERE THERE ANY ERRORS\n         BZ    REFNOERS            NO ERRORS, BRANCH OUT AGAIN\n         SPACE 1\n*              AR058 MESSAGE JUST PRINTED. ADD AR059 WITH ERROR FLAGS.\n         BAL   R9,REGCRARE         CALL TO CHK BITS, FLAG, PRINT AR059\n         SPACE 1\n         LH    R1,RECWRONG         GET CURRENT # WRONG\n         LA    R1,1(R1)            +1 FOR THIS TIME\n         STH   R1,RECWRONG         = NEW TOTAL # WRONG\n         B     REFARETA            GO RESTORE PARM REGS, RETURN\n         EJECT\n*              EXIT TAKEN IF UNFOUND ENTRY POINT CALLED DURING EXEC.\nREFNOCAL EQU   *                   CALLED ENTRY NOT FOUND EXIT\n         MVC   REZEN101,RECSYMB    MOVE NAME OF ENTRY OVER-ERROR\n         REPRNT REZAR101,REZ101L   PRINT UNFOUND ENTRY CALLED DURING EX\n         LM    R14,R15,ECRDLIML    ECRDLIML-H - DUMP LIMITS\n         XSNAP T=(PR,FL,1),STORAGE=(*0(R14),*0(R15)),                  #\n               LABEL='REPLACE MONITOR AR101 DUMP'\n         B     REFAREAL            GO RESTORE ADCONS\n         SPACE 2\nREFNORET EQU   *                   BRANCH HERE IF NOT RIGHT RETURN\n         AIF   (&$REPL LT 2).REFNOBR        SKIP IF CAN'T CALL OTEHRS\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*              CHECK USER FOR CALLING ASSIST ROUTINE PROPERLY         *\n*        CHECK USER ROUTINE FOR BRANCHING OUT IF ITSELF, USING A LEGAL*\n*        OFFSET CODE GIVEN TO IT BY RESYMB.                           *\n*              REGISTER USAGE IN CALL CHECKING SECTION                *\n*   R4 = @ RFSYMBLK OF CALLED ROUTINE (SECTION 2 OR RFYSMS).          *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n         CLI   ECFLAG1,$ECBROUT    WAS ERROR BRANCH OUT OF RANGE\n         BNE   REFABEND            NO, SO MUST BE ACTUAL ERROR\n         SPACE 1\n         LH    R15,REFRIAD         GET OFFSET TO RI&CSECT IF ANY\n         LTR   R15,R15             IS THIS CSECT ALLOWED TO CALL\n         BZ    REFABEND            =0 ==> CAN'T CALL-BRANCH -ERROR\n         SPACE 1\n         L     R1,RERFSYMS         =V(RFYSMS), @ CONTROL TABLE\n         LH    R0,0(R15,R1)        GET # ENTRY PTS CALLABLE FROM CSECT\n         L     R4,ECREG15          GET USER REGISTER 15\n         LA    R4,0(R4)            REMOVE ANY GARBAGE FROM FRONT\n         SPACE 1\n*              SEE IF USER BRANCHED TO LEGAL OFFSET GIVEN HIM BY RESYMB\nREHSEARC LA    R15,2(R15)          INCREMENT COUNTER TO NEXT HALF\n         LH    R2,0(R15,R1)        GET NEXT VALUE, EXPAND\n         CR    R4,R2               WAS VALUE THE SAME\n         BE    *+12                YES, ITS OK, SO JUMP OUT OF LOOP\n         BCT   R0,REHSEARC         LOOP BACK FOR LIST OF CALLABLES\n         B     REFABEND            VALUE WASN'T ONE OF OURS-QUIT\n         SPACE 1\n*              OFFSET INTO SECTION 2 OF RFSYMS CHECKED AND OK.\n         AR    R4,R1               ADD =V(RFYSMS), GET @ ELEMENT\n         DROP  R5                  TEMPORARILY REMOVE USING FOR USER\n         USING RFSYMBLK,R4         NOTE PTR TO CALLED ASSIST PROG\n         LH    R15,RFSRHAD         GET OFFSET OF CHECKING CODE\n         BAL   R14,RHENTS          CALL CHECKER, NOTE RERGEFLG =0 ALRED\n         SPACE 1\n         BAL   R14,REGC1213        GET R12 CHECKED, R13 PARTIALLY\n         TM    RERGEFLG,RGE13      WAS R13 FLAGGED\n         BZ    REHN13              NO, SO IT WAS OLD SA PTR, OK\n         SPACE 1\n         TM    ECREG13+3,3         AS IT ON F BOUNDARY\n         BNZ   REHN13              NO, ERROR, LEAVE IT FLAGGED\n         L     R15,ECREG13         GET USER R13\n         LA    R15,0(R15)          REMOVE LEADING BYTE\n         C     R15,ECFADL          LOWER THAN LOWEST USER @\n         BL    REHN13              OUT OF AREA, ALREADY MARKED,BR\n         C     R15,ECFADHC         COMPARE TO HIGH LIMIT FOR USER\n         BH    REHN13              OUTSIDE, NOGOOD, LAREADY FLAGGED\n         NI    RERGEFLG,255-RGE13  IN USER AREA, OS OK, REMOVE FLAG\n         MVC   REZ05913,AWBLANK    REMOVE R13 MESSAGE TOO\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*              IF USER WANTS TO SEE THEM, OR IF THERE IS AN ERROR,    *\n*        PRINT PARAMETER REGISTERS PASSED BY USER PROGRAM.  IF IN     *\n*        ERROR, PRINT ERROR MESSAGE AND ABEND THE USER.  IF CORRECT,  *\n*        CALL THE ASSIST ROUTINE, AND PASS ITS ANSWERS BACK TO THE    *\n*        USER PROGRAM.  THE INTERPRETR CONTINUES FROM WHERE IT LEFT   *\n*        OFF, WITHOUT REINITIALIZING INSTRUCTION STACK.               *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nREHN13   TM    ECRFLAG+1,ECR$REGD  DID USER WANT REGS PRINTED ON CALL\n         BO    REF050PR            YES, OS GO PRINT\n         SPACE 1\n         TM    RERGEFLG,X'FF'      WAS NAYTHING WRONG WITH HIS REGS\n         BZ    REHNOERS            NO, SO LEGIT CALL, GO DO IT\n         SPACE 1\nREF050PR MVI   REZ05XN,C'0'        SHOW AR050 MESSAGE\n         MVC   REZ05XMS,=CL9'CALL TO'       MOVE IN MESSAGE\n         MVC   REZ05XEN,RFSYMB     MOVE IN SYMBOL OF ENTRY CALLED\n         BAL   R14,REREGSRA        GO PRINT USER REGS OUT\n         SPACE 1\n         TM    RERGEFLG,X'FF'      WERE THER ANY ERRORS\n         BZ    REHNOERS            NO, USER JUST WANTED TO SEE, SKIP\n         SPACE 1\n         BAL   R9,REGCRARE         HAVE REGS RA-RE FLAGGED IF NEED,PRT\n         B     REFABEND            USER MADE HIS MISTAKE-ABEND\n         SPACE 1\nREHNOERS LH    R15,RFSAXAD         OFFSET IN AVWXTABL OF V(REAL ROUT)\n         DROP  R4                  DON'T NEED CALLED RFSYMBLK ANYMORE\n         USING RFSYMBLK,R5         RESTORE NOREMAL USING FOR ELSEWHERE\n         L     R15,AX$BASE(R15)    GET ACTUAL @ CALLED ROUTINE\n         SPACE 1\n         LR    R1,R10              SAVE @ ECONTROL\n         LM    RA,R13,ECREGRA      GET USER REGS RA-RE,R12,R13\n         USING ECONTROL,R1         TEMPORARY USING\n         DROP  R10                 REMOVE USING SO WE CAN USE R1 TEMPRL\n         DROP  R13                 WIPED OUT REG, SO ERASE USING\n         BALR  R14,R15             CALL REAL ASSIST ROUTINE\n         SPACE 1\n         STM   RA,RE,ECREGRA       SAVE THE PARM REGS\n         LR    R10,R1              GET @ ECONTROL BACK IN USUAL REG\n         DROP  R1                  REMOVE TGEMP USING\n         USING ECONTROL,R10        RESTORE NORMAL USING\n         L     R11,AVAJOBPT        GET @ AJOBCON BACK\n         LA    R13,RESAVE          GET @ OF OUR SAVE AREA BACK\n         USING RESAVE,R13          RESOTRE NORMAL USING HERE\n         SPACE 1\n         MVC   ECPSWIAD,ECREG14+1  MOVE TO PSW @ SO STARTS THERE\n         B     REEXECUT            GO TO START INTEPRETER UP AGAIN\n         EJECT\n.REFNOBR ANOP\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*              REFAKE EXIT CODE SECTIONS                              *\n*        IF USER ABENDED FOR ANY REASON, GIVE HIM A DUMP AND          *\n*        HAVE ALL ADCONS REPLACED, THUS TERMINATING REPLACEMENT.      *\n*        IN ANY CASE, PLACE THE CORRECT RETURN VALUES IN PARAMETER    *\n*        REGISTERS RA-RE.  THEN RETURN TO THE ASSIST ASSEMBLER        *\n*        ROUTINE WHICH UNWITTINGLY CALLED REFAKE.                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nREFABEND EQU   *                   USER PROGRAM ABEND EXIT\n         REPRNT REZAR102,REZ102L   ABEND MESSAGE\n         BAL   R9,REFRFC           PRINT ANYTHING NOT ALREADY PRINTED\nREFADUMP EQU   *                   ENTER HERE TO DUMP USER AND RESTORE\n         LM    R14,R15,ECRDLIML    GET DUMP LIMITS\n         XSNAP T=(PR,FL,10),STORAGE=(*0(R14),*0(R15)) GIVE DUMP\nREFAREAL EQU   *                   ENTER HERE IF CANNOT USE DUMP ABOVE\n         BAL   R14,REREAL          CANCEL REPLACEMENT\n         SPACE 1\nREFNOERS EQU   *                   BRANCH HERE IF NO ERRORS IN REG CHEC\nREFARETA EQU   *                   EXIT LABEL FOR ENTIRE REFAKE\n         TM    REFLAGS,REFPRT      HAVE WE PRINTED ANY MESSAGE\n         BZ    REFARETE            NO, SO DON'T DO ANYTHING\n         REPRNT  REZAR000,1        =C'0'.  SKIP 2 LINES FOR READABLE\nREFARETE EQU   *                   BRANCH HERE IF DON'T HAVE TO SKIP\n         LM    RA,RE,REGSAVB       RELOAD REAL SUBR'S RIGHT PARM RGS\nREFARET  $RETURN RGS=(R14-R6)      RESTORE ALL BUT PARM REGS\n         DROP  R5,R6,R10,R11,RAT,R13        ERASE ALL USINGS\n         TITLE 'REPLACE MONITOR - INTERNAL DATA AREAS - BASE R13'\nRESAVE   DS    18F                 SAVE AREA, SECONDARY BASE REG\n         SPACE 1\nREREFAKE DC    A(REFAKE)           ADCON TO PLACE INTO AVWXTABL\nRERFSYMS DC    V(RFSYMS)           SYMBOLIC ENTRY TABLE CSECT\nREFILLRG DC    (7*4)AL1($PRGFILR)  FILL CHARS FOR REGISTERS\nREGSAVA  DS    5F                  REGS RA-RE BEFORE REAL PROG CALLED\nREGSAVB  DS    5F                  REGS RA-RE AFTER CALL TO REAL SUBR\nRECORRAD DS    0F,(REC$MAX)CL(REC$LEN)      ADCON CORRESPONDENCE TABLE\nREXFWORK DC    F'0',X'04'          WORKAREA, WITH REVERSED ' ' FOR HEX\nREFLAGS  DC    B'0'                FLAG BYTE\nRECORNUM DC    H'0'                CURRENT # ENTRIES IN RECORRAD\nREFRFLAG DS    H                   SAVE AREA FOR ECRFLAG OVER CALL\nREFRFLG1 EQU   *-1                 @ 2ND BYTE REFRFLAG, WHERE BITS ARE\nREFRIAD  DS    H                   OFFSET @ FROM RFSYMS TO COUNT, THEN\n*              LIST OF OFFSETS TO RFSYMBLK ELEMENTS FOR CALLABLE SUBS\n*              FOR REPLACED CSECT.  ONLY USED IF &$REPL=2.\nRERGEFLG DS    B                   FLAG FOR ERROR CONDTIONS IN USER RGS\n         SPACE 2\n*              INFORMATION, WARNING MESSAGES - AR00# MESSAGES.        *\n*        ///AR000 - LIST NAME OF CSECT BEING REPLACED.                *\n*        ///AR001 - LIST NAME AND LOCATION OF EACH ENTRY BEING REPPD. *\n*        ///AR002 - LIST NAME OF ENTRY REQUIRED BUT NOT FOUND.        *\n*        ///AR003 - OUTPUT HEADER FOR PERFORMANCE STATISTICS          *\n*        ///AR004 - LIST PERFORMANCE STATISTICS FOR SINGLE ENTRY.     *\n         SPACE 1\nREZAR000 DC    C'0///AR000 REPLACE CSECT: '\nREZCSECT DC    CL6' ',C' ///'\nREZ000L  EQU   *-REZAR000          LENGTH OF MESSAGE\n         SPACE 1\nREZAR001 DC    C'0///AR001 REPLACE ENTRY: '\nREZEN001 DC    CL6' ',C' AT LOCATION: '\nREZLOCAT DC    XL6'0',C' ///'\nREZ001L  EQU   *-REZAR001          LENGTH OF MESSAGE\n         SPACE 1\nREZAR002 DC    C'0///AR002 REPLACE ENTRY: '\nREZEN002 DC    CL6' ',C' NOT FOUND AS CSECT OR ENTRY ///'\nREZ002L  EQU   *-REZAR002          LENGTH OF MESSAGE\n         SPACE 1\nREZAR003 DC    C'0///AR003 STATISTICS :  # INSTRUCTIONS    # CALLS    '\n         DC    C'# WRONG    INSTRS/CALL   % WRONG'\nREZ003L  EQU   *-REZAR003          LENGTH OF MESSAGE\n         SPACE 1\nREZAR004 DC    C' ///AR004     '\nREZ004EN DC    CL6' ',C' : '       SPACE OFR ENTRY NAME\nREZ004NS DS    5ZL12               5 SLOTS FOR OUTPUT NUMBERS\n         DC    C' %'\nREZ004L  EQU   *-REZAR004          LENGTH OF MESSAGE\n         EJECT\n*              DEBUG SERVICE MESSAGES - AR05# MESSAGES AND ITEMS.\n*        ///AR050 - PARM REGISTERS ON CALL TO ANOTHER ROUTINE.        *\n*        ///AR051 - CARDIMAGE BEFORE ENTRY TO ROUTINE.                *\n*        ///AR052 - PARM REGISTERS BEFORE ENTRY TO ROUTINE.           *\n*        ///AR054 - PARM REGISTERS RETURNED BY REAL ROUTINE.          *\n*        ///AR058 - PARM REGISTERS RETURNED BY USER ROUTINE.          *\n*        ///AR059 - REGISTER ERROR MESSAGE, SHOWING ONES IN ERROR     *\n         SPACE 1\nREZAR051 DC    C'0///AR051 ON ENTRY TO  '\nREZ051EN DC    CL6' ',C' STMT ADDR: '       ENTRY NAME\nREZ051AD DC    XL6'0',C' ->'       @ CARDIMAGE, PTR TO IT\nREZ051CD DS    CL71                SPACE FOR MOST OF CARD\nREZ051L  EQU   *-REZAR051          LENGTH OF MESSAGE\n         SPACE 2\nREZ05ENT DC    C'ENTRY TO '        ... THESE TWO CONSTANTS MUST\nREZ05EXT DC    C'EXIT FROM'        ... BE OF THE SAME LENGTH.\n         SPACE 1\nREZAR05X DC    C'0///AR05'         HEADER BEGINNING\nREZ05XN  DC    X'0',C' ON '        LAST DIGIT OF MESSAGE NUMBER\nREZ05XMS DC    CL(L'REZ05ENT)' ',C' '       'ENTRY TO' OR 'EXIT FROM'\nREZ05XEN DC    CL6' ',C' REGISTERS RA-RE: '           ENTRY NAME\n         DC    C'RA/7/: '\nREZ05XRG DC    XL8'0',C' RB/8/: ',XL8'0',C' RC/9/: ',XL8'0',C' RD/A/: '\n         DC    XL8'0',C' RE/B/: ',XL8'0',C' '\nREZ05XL  EQU   *-REZAR05X          LENGTH OF MESSAGE AREA\n         SPACE 1\nREZAR059 DC    C' ///AR059 WARNING: ERROR IN USER REGS: '\nREZ059MS EQU   *                   BEGINNING OF AREA TO BE BLANKED\nREZ059R0 DS    C'R0-R6',C' '       ERR IN ANY OF THESE\nREZ05912 DS    C'R12',C' '         ASM TABLE REG-CAN'T CHANGE\nREZ05913 DS    C'R13',C' '         SAVE AREA PTR\n         ORG   REZAR059+(REZ05XRG-REZAR05X) ORG TO SIMILAR OFFSET\nREZ059RG EQU   *                   BEGINNING OF MESSAGES FOR REGS\n         ORG   REZAR059+REZ05XL    LEAVE SAME AMOUNT OF SPACE\nREZ059ML EQU   *-REZ059MS          LENGTH TO BLANK OUT\nREZ059L  EQU   *-REZAR059          LENGTH OF MESSAGE\n         SPACE 2\n*              SEVERE ERROR MESSAGES  - AR10# MESSAGES.               *\n*              THESE ERRORS TERMINATE REPLACEMENT IMMEDIATELY.        *\n*        ///AR100 - REPL= NAME COULD NOT BE FOUND.                    *\n*        ///AR101 - UNFINDABLE ENTRY NAME CALLED DURING EXECUTION.    *\n*        ///AR102 - USER PROGRAM ABENDED.                             *\n         SPACE 1\nREZAR100 DC    C'0///AR100 REPLACE CSECT NOT FOUND - REPLACE ABORT ///'\n         SPACE 1\nREZAR101 DC    C'0///AR101 INVALID ENTRYPOINT NAME: '\nREZEN101 DC    CL6' ',C' CALLED. REPLACE ACTION ABORTED ///'\nREZ101L  EQU   *-REZAR101          LENGTH OF MESSAGE\n         SPACE 1\nREZAR102 DC    C'0///AR102 USER PROGRAM ABENDED DURING REPLACEMENT ///'\nREZ102L  EQU   *-REZAR102\n         TITLE 'REPLACE MONITOR INTERNAL SUBROUTINES - BASE R13'\n         SPACE 1\n*              ***NOTE*** THE FOLLOWING USINGS ARE ASSUMED WHEN\n*        NECESSARY BY ANY OF THE INSUBS WHICH NEED THEM.\n         USING RECORBLK,R5         INDIVIDUAL ENTRY INFORMATION\n         USING ECONTROL,R10        EXECUTION CONTROL TABLE\n         USING AJOBCON,R11         JOB CONTROL TABLE PTR\n         USING AVWXTABL,RAT        NOTE FOR REST OF CODE\n         USING RESAVE,R13          NOTE SECONDARY BASE REGISTER\n         SPACE 2\n*              *****   LIST OF INSUBS *****                           *\n*        REEXDECO  -   CONVERT NUMBER FROM BINARY TO EDITED DECIMAL   *\n*        REFRFC    - PRINT REGISTER SETS DETERMINED BY USER           *\n*        REGC1213  - CHECK USER REGS  12 AND 13, SET FLAGS            *\n*        REGCRARE  - TEST FLAGS FOR REGS RA-RE. FORMAT AND PRINT MSG  *\n*        REREAL    - RESTORE NORMAL ADDRESS CONSTANTS IN AVWXTABL     *\n*        REREGS    - FORMAT,PRINT PARM REGS. REREGSRA PRINTS ECREGRA- *\n*        REXCON3   - CONVERT REGISTER VALUE TO 3 BYTES OF HEXADECIMAL *\n*        REXPRINT  - PRINT A LINE (CALLED BY REPRNT MACRO)            *\n*                                                                     *\n*        RGENTS    - RETURN VALUE CHECKING SECTION                    *\n*        RGRAADDR  - (RGENTS INTERNAL) - CHECK RA FOR LEGAL SCAN PTR  *\n*        RGRCADDR  - (RGENTS INTERNAL) - CHECK RC FOR @ IN USER PROGR *\n*                                                                     *\n*        RHENTS    - CHECK PARM REGS USER PASSED TO ASSIST SUBR.      *\n*        RHRAADDR  - (RHENTS INTERNAL) CHECK RA FOR LEGALITY          *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 4\n**--> INSUB: REEXDECO   CONVERT NUMBER TO DECIMAL   + + + + + + + + + +\n*+       CALLED FROM REENDA, PHASE B, CONVERT NUMBER, ADVANCE PTR.    +\n*+       ENTRY CONDITIONS                                             +\n*+  R7 = @ 12-BYTE FIELD WHERE NUMBER SHOULD BE PLACED.               +\n*+  R8 = NUMBER TO BE CONVERTED TO DECIMAL AND PLACED AT 0(R7).       +\n*+  R14= RETURN @ TO CALLING CODE IN REENDA.                          +\n*+       EXIT CONDITIONS                                              +\n*+  R7 = INPUT VALUE OF R7 + 12, I.E., ADVANCED 1 POSITION.           +\n*+  + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +\n         SPACE 1\nREEXDECO XDECO R8,0(R7)            CONVERT NUMBER\n         LA    R7,12(R7)           INCREMENT FIELD POINTER\n         BR    R14                 RETURN\n         EJECT\n**--> INSUB: REFRFC     TEST ECRFLAG AND PRINT NEEDED INFOR + + + + + +\n*+       ENTERED BEFORE USER PROGRAM EXECUTION (AND POSSIBLY AFTER,   +\n*+       IF IT ABENDED), TO PRINT STATEMENT/AND/OR REGISTERS.         +\n*+       ENTRY CONDITIONS                                             +\n*+  R9 = RETURN @ TO CALLING CODE.                                    +\n*+  R10= @ ECONTROL                                                   +\n*+       EXIT CONDITIONS                                              +\n*+  R7,R8,R14,R15  MAY BE CHANGED.                                    +\n*+       MESSAGES AR051, AR052, AND/OR AR054 MAY BE PRINTED.          +\n*+       MAY CALL INSUBS  REREGS,REXCON3,REXPRINT.                    +\n*+  + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +\n         SPACE 1\n*              TEST FOR CARDIMAGE PRINTING AND DO IT IF NEEDED.\n*              **NOTE** REQUIRES AVRSBPT=0 IF NO CARD YET PROCESSED.\nREFRFC   TM    REFRFLG1,ECR$CARD   DOES HE WANT CARDIMAGE\n         BZ    REFRFZ01            NO, SO SKIP ENTIRELY\n         L     R8,AVRSBPT          GET @ RSBLOCK, IF ANY\n         LTR   R8,R8               =0 IF THERE ISN'T ANY CARD YET\n         BZ    REFRFZ01            NO CARDIMAGE, CAN'T PRINT-BRANCH\n         USING RSBLOCK,R8          NOTE POINTER TO RSBLOCK\n         SPACE 1\n         MVC   REZ051EN,RECSYMB    MOVE ENTRY NAME INTO MESSAGE\n         SR    R7,R7               CLEAR FOR INSERTION\n         IC    R7,RSBLENG          GET LENGTH-1 OF ENTRIE BLOCK\n         SH    R7,=AL2(RSB$L)      - LENGTH BEFORE CARDIMAGE STARTS\n         LA    R15,RSOL1-1         LENGTH-1 OF SINGLE CARD (MAX ALLWD)\n         CR    R7,R15              WAS ACTUAL L-1 > MAX\n         BNH   *+6                 NO, SKIP, USE ACTUAL L-1\n         LR    R7,R15              YES, USE JUST 1 CARD OF SEVERAL\n         SPACE 1\n         MVC   REZ051CD,AWBLANK    BLANK PUT THE CARDIMAGE\n         STC   R7,*+5              STORE LENGTH-1 INTO NEXT MVC\n         MVC   REZ051CD($),RSBSOURC         MOVE VARIABLE SIZE CARD OVR\nREFRFX01 LA    R7,RSBSOURC         PUT @ IN REG FOR CONVERSION\n         DROP  R8                  DON'T NEED RSBLOCK USING ANY MORE\n         LA    R8,REZ051AD         SHOW @ WHERE CONVERTED VALUE GOES\n         BAL   R14,REXCON3         CALL CONVERT ROUTINE\n         REPRNT REZAR051,REZ051L   PRINT CARDIMAGE, MESSAGE\nREFRFZ01 EQU   *                   BRANCH LABEL, PREVIOUS CODE SKIPPED\n         EJECT\n*              TEST FOR INITIAL REGISTER VALUE PRINTING.\n         MVC   REZ05XEN,RECSYMB    MOVE ENTRY NAME NOW. CAN USE # TIMES\n         TM    REFRFLG1,ECR$REGA   DOES HE WANT INPUT REGISTERS\n         BZ    REFRFZ02            NO, SO DON'T DO IT, BRANCH\n         SPACE 1\n         MVC   REZ05XMS,REZ05ENT   MV ENTRY TO MESSAGE IN\n         MVI   REZ05XN,C'2'        MAKE MESSAGE ***AR052\n         LA    R7,REGSAVA          SHOW @ BLOCK OF 5 ORIGINAL REGS\n         BAL   R14,REREGS          CALL REGISTER CONVERT AND PRINT CODE\nREFRFZ02 EQU   *                   BRANCH LABEL FOR SKIP PREVIOUS CODE\n         SPACE 1\n*              TEST FOR PRINTING OF REGS RETURNED BY REAL PROGRAM.\n         MVC   REZ05XMS,REZ05EXT   PUT  'EXIT FROM' IN NOW\n         TM    REFRFLG1,ECR$REGB   DOES HE WANT RETURNED VALUES\n         BCR   Z,R9                NO RETURN TO CALLER\n         SPACE 1\n         MVI   REZ05XN,C'4'        MESSAGE IS ***AR054\n         LA    R7,REGSAVB          SHOW @ 5 REGISTERS\n         BAL   R14,REREGS          CALL REG CONVERT AND PRINT\n         BR    R9                  RETURN TO CALLER\n         EJECT\n**--> INSUB: REGCRARE   USING RERGEFLG, FLAG AND PRINT REG MSG  + + + +\n*+       **NOTE** SEE SECTION RGENTS FOR RGE-- FLAGS, AS FOLLOWING    +\n*+       CODE MAY NOT BE OBVIOUS WITHOUT THEM.                        +\n*+       ENTRY CONDITIONS                                             +\n*+  R9 = RETURN @ TO CALLING CODE                                     +\n*+  RERGEFLG IS NONZERO, I.E. AT LEAST 1 ERROR EXISTS.                +\n*+       EXIT CONDITIONS                                              +\n*+  REZAR059 MESSAGE IS COMPLETED AND PRINTED.                        +\nREGCRARE IC    R0,RERGEFLG         GET THE FLAG, WITHS BITS POSS IN 3-7\n         SLL   R0,32-5             SHIFT SO 5 BITS AT LEFT END OF REG\n         LA    R1,REZ059RG         @ 1ST SLOT FOR FLAGGING\n         SPACE 1\nREFRAREF ALR   R0,R0               SET CC BY 1ST BIT, REST OF REG\n         BC    Z+M,*+10            SKIP IF 1ST BIT=0, NOT ERROR\n         MVC   0(8,R1),=8C'$'      FLAG THIS REG\n         LA    R1,8+8(R1)          INCREMENT POINTER TO NEXT AREA\n         BC    M+O,REFRAREF        LOOP BACK IF ANY MORE TO DO\n         SPACE 1\n         REPRNT REZAR059,REZ059L   PRINT ERROR FLAG LINE\n         BR    R9                  RETURN TO CALLER\n         SPACE 4\n**--> INSUB: REGC1213   CHECK USER REGS 12-13,FLAG RERGEFLG + + + + + +\n*+       ENTRY CONDITIONS                                             +\n*+  R14= RETURN @ TO CALLING CODE                                     +\n*+  REZAR059MS  IS ASSUMED TO BE BLANKED OUT                          +\n*+       EXIT CONDITIONS                                              +\n*+  RERGEFLG   MAY BE FLAGGED WITH RGE12 OR RGE13 OR BOTH             +\n*+  REZ059MS   MAY CONTAIN REGISTER FLAGS  R12  OR R13                +\n*++ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +\n         SPACE 1\nREGC1213 C     RAT,ECREG12         DID HE LEAVE R12 ALONE\n         BE    *+14                YES, SKIP\n         OI    RERGEFLG,RGE12      SHOW R12 IN ERROR\n         MVC   REZ05912,=C'R12'    SHOW ERROR MESSAGE\n         SPACE 1\n         CLC   ECREG13,ECSAVE1     DID HE SAVE SA PTR OK\n         BCR   E,R14               YES, OK, RETURN\n         OI    RERGEFLG,RGE13      NO, MODIFIED R13 ERROR\n         MVC   REZ05913,=C'R13'    SHOW ERROR MESSAGE\n         BR    R14                 RETURN TO CALLER\n         EJECT\n*+--> INSUB: REREAL     REPLACE REAL ADCONS IN VWXTABL IF NOT THERE.  +\n*+       ENTRY CONDITIONS                                             +\n*+  R11= @ AJOBCON JOB CONTROL TABLE.                                 +\n*+  R12(RAT)= ADDRESS OF VWXTABL CSECT (FOR DSECT AVWXTABL)           +\n*+  R14= RETURN ADDRESS TO CALLING CODE IN REMONI                     +\n*+       EXIT CONDITIONS                                              +\n*+  ALL ADCONS IN VWXTABL ARE CORRECT, REFLAGS IS MARKED UNMODIFIED.  +\n*+  AJOSTEP IS FLAGGED TO SHOW NOT IN EXECUTION PHASE FOR SURE.       +\n*+       USES REGS: R0,R1,R2,R15                                      +\n*+       USES  DSECTS: AVWXTABL,RECORBLK                              +\n*++ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +\nREREAL   EQU   *                   ENTRY FOR RESTORATION\n         NI    AJOSTEP,255-AJOSEXEC         REMOVE INTERP FLAG FOR SURE\n         TM    REFLAGS,READMOD     HAVE ADCONS BEEN MODIFIED\n         BCR   Z,R14               NO,JUST RETURN TO CALLER\n*              INITIALIZE FOR LOOP TO RESTORE ADCONS.\n         LH    R0,RECORNUM         GET # ENTRIES IN RECORRAD\n         LA    R1,RECORRAD         GET @ 1ST ENTRY IN RECORRAD\n         USING RECORBLK,R1         NOTE DSECT POINTER\n         DROP  R5                  ZAP NORMAL USING SO WE CAN USE R1\n         SPACE 1\n*              LOOP, RESTORING ADCONS FROM RECORRAD BACK TO VWXTABL.\nREREALA  LH    R2,RECAXAD          GET ADCON OFFSET VALUE\n         L     R15,RECADRE         GET ADCON FROM TABLE\n         ST    R15,AX$BASE(R2)     STORE ADCON BACK IN ORIGINAL LOCAT\n         LA    R1,REC$LEN(R1)      BUMP DSECT POINTER TO NEXT ONE\n         BCT   R0,REREALA          LOOP ON # ENTRIES IN RECORRAD TABLE\n         SPACE 1\n         NI    REFLAGS,255-READMOD SHOW VWXTABL NOW IN UNMODIFIED STATE\n         BR    R14                 RETURN TO CALLING SECTION\n         DROP  R1                  KILL USING\n         USING RECORBLK,R5         RESORE NORMAL USING FOR REST OF INSU\n         EJECT\n**--> INSUB: REREGS     FORMAT PARAMETER REGS AND PRINT THEM  + + + + +\n*+       CONVERTS BLOCK OF 5 REGISTERS TO HEXADECIMAL, PLACES THEM    +\n*+       IN LOCATIONS IN MESSAGE AREA REZAR05X, AND PRINTS MESSAGE.   +\n*+       ENTRY CONDITIONS                                             +\n*+  R7 = @ 5-WORD BLOCK OF REGISTERS TO BE PRINTED                    +\n*+  R14= RETURN @ TO CALLING CODE                                     +\n*+       EXIT CONDITIONS                                              +\n*+  R7 = @ REZAR05X MESSAGE, WITH REGS FILLED IN, USED TO PRINT IT.   +\n*+  R8 = LENGTH OF REZAR05X MESSAGE AREA, FOR PRINTING ALSO.          +\n*+  R15  IS USED AS WORK REGISTER AND MODIFIED                        +\n*+  + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +\n         SPACE 1\nREREGSRA LA    R7,ECREGRA          @ 5 REGS IN ECONTROL BLOCK\n         SPACE 1\nREREGS   LA    R15,5               LOOP COUNTER = # REGS TO BE DONE\n         LA    R8,REZ05XRG         INIT TO @ FIRST SLOT FOR HEX REG\n         SPACE 1\nREREGSA  UNPK  0(9,R8),0(5,R7)     UNPK 1 REGISTER VALUE, EXTRA BYTE\n         TR    0(8,R8),AWTHEX3     TRANSLATE PROPERLY\n         MVI   8(R8),C' '          ADD BLANK AFTERWARD\n         LA    R7,4(R7)            ADVANCE REG PTR TO NEXT REGISTER\n         LA    R8,8+8(R8)          ADVANCE HEX PTR TO NEXT SLOT\n         BCT   R15,REREGSA         LOOP FOR 5 REGS TO BE DONE\n         SPACE 1\n         LA    R7,REZAR05X         SHOW @ MESSAGE AREA\n         LA    R8,REZ05XL          SHOW LENGTH\n         B     REXPRINT            BRANCH TO PRINT ROUTINE\n         EJECT\n**--> INSUB: REXCON3    CONVERT 3 BYTES OF REGISTER R7 TO HEX.  + + + +\n*+       ENTRY CONDITIONS                                             +\n*+  R7 = VALUE TO BE CONVERTED ( IN 3 LOW-ORDER BYTES )               +\n*+  R8 = ADDRESS OF 7 BYTE AREA FOR FIELD TO BE PLACED (WITH TRL ' ') +\n*+  RAT(R12)= ADDRESS OV VWXTABL CSECT, NEEDED FOR TRANSLATE TABL     +\n*+  R14= RETURN @ TO CALLING SECTION IN REMONI                        +\n*+       USES  DSECTS: AVWXTABL                                       +\n*++ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +\n         SPACE 1\nREXCON3  ST    R7,REXFWORK         SAVE THE WORD FOR UNPK\n         UNPK  0(7,R8),REXFWORK+1(4)        UNPK WITH TRAILING ' '\n         TR    0(6,R8),AWTHEX3     TRANSLATE TO PRINTABLE HEX\n         BR    R14                 RETURN TO CALLER\n         SPACE 4\n**--> INSUB: REXPRINT   PRINT MESSAGE + + + + + + + + + + + + + + + + +\n*+       PRINT MESSAGE AND FLAG REFLAGS WITH REFPRT TO SHOW PRINTED.  +\n*+       ENTRY CONDITIONS                                             +\n*+  R7 = ADDRESS OF MESSAGE TO BE PRINTED                             +\n*+  R8 = LENGTH OF MESSAGE TO BE PRINTED                              +\n*+  R14= RETURN ADDRESS TO CALLING SECTION OF REMONI                  +\n*++ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +\n         SPACE 1\nREXPRINT $PRNT 0(R7),(R8)          PRINT MESSAGE\n         OI    REFLAGS,REFPRT      SHOW SOMETHING PRTED DURING REFAKE\n         BR    R14                 RETURN TO CALLING CODE\n         TITLE 'REMONI: INSUB RGENTS: PARAMETER REGISTER CHECKING'\n**--> INSUB: RGENTS     CHECK USER VALUES IN PARAMETER REGISTERS+ + + +\n*+       THIS CODE CHECKS THE VALUES RETUNRED IN USER REGISTERS RA-RE +\n*+  AGAINST THE VALUES RETURNED BY THE REAL ASSIST ROUTINE.  THE      +\n*+  BYTE FLAG RERGEFLG IS SET ACCORDINGLY, FOR ANY OF THE REGISTERS   +\n*+  WHICH MAY HAVE INCORRECT VALUES.  NOTE THAT THE REGISTERS CAN'T   +\n*+  JUST BE COMPARED DIRECTLY, SINCE SOME REGISTERS MAY BE IGNORED,   +\n*+  DEPENDING ON THE CONTENTS OF OTHERS (FOR INSTANCE, IF RB HAS AN   +\n*+  ERROR CODE, RA AND RC ARE INDETERMINATE FOR MANY ENTRIES.)        +\n*+       ENTRY CONDITIONS                                             +\n*+  R5 = @ RECORBLK ELEMENT FOR THE ENTRYPOINT CALLED.                +\n*+  R6,R13 = FIRST AND SECOND BASE REGISTERS FOR REMONI(REFAKE).      +\n*+  R10= @ ECONTROL BLOCK (WHICH CONTAINS USER RETURN REGS)           +\n*+  R12(RAT) = @ AVWXTABL CONTROL BLOCK                               +\n*+  R14= RETURN @ TO CALLING SECTION OF REMONI.                       +\n*+  R15= OFFSET FROM RG$BASE TO CODE FOR CHECKING ENTRYPOINT CALLED.  +\n*+             = 0 IF NO CHECKS ARE REQUIRED.                         +\n*+       EXIT CONDITIONS                                              +\n*+  R5,R6,R10,R11,R12,R13,R14,R15  ARE PRESERVED ACROSS THIS CODE.    +\n*+  RERGEFLG   CONTAINS BITS SHOWING ERROR FLAGS, REGS RA-RE.         +\n*+       NAMES: RG------                                              +\n*+  + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +\n         SPACE 2\n* * * * * * * * RGENTS  REGISTER ALLOCATION * * * * * * * * * * * * * *\n*   R0 = WORK REGISTER                                                *\n*   R1 = LINK REGISTER FOR INTERNAL SUBROUTINES (INTERNAL TO RGENTS)  *\n*   R2,R3,R4 (RGRA,RGRB,RGRC) HAVE REAL ROUTINES RETURN VALUES.       *\n*  R7,R8,R9 (RA,RB,RC) HAVE USER RETURN VALUES OF THESE REGS.         *\n*              (NOTE MOST PROGS RETURN VALUES IN NOR MORE THAN THESE. *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n*              LOCAL REGISTER EQUATES FOR RGENTS.  THESE ARE USED FOR\n*              EASE OF PROGRAMMING, AND MAY BE READ AS: RGRA:\n*              REGISTER(GOOD) VALUE OF RA.\nRGRA     EQU   R2                  GOOD VALUE OF RETURNED RA\nRGRB     EQU   R3                  GOOD VALUE OF RETURNED RB\nRGRC     EQU   R4                  GOOD VALUE OF RETURNED RC\n         SPACE 1\n*              ERROR EQUS USED IN USER-RETURN REGISTER CHECKING.\nRGERE    EQU   B'00000001'         (RERGEFLG)- RE FOUND IN ERROR\nRGERD    EQU   B'00000010'         (RERGEFLG)- RD FOUND IN ERROR\nRGERC    EQU   B'00000100'         (RERGEFLG)- RC FOUND IN ERROR\nRGERB    EQU   B'00001000'         (RERGEFLG)- RB FOUND IN ERROR\nRGERA    EQU   B'00010000'         (RERGEFLG)- RA FOUND IN ERROR\nRGE13    EQU   B'00100000'         (RERGEFLG)- R13 MODFIED\nRGE12    EQU   B'01000000'         (RERGEFLG)- R12 MODIFIED\nRGE06    EQU   B'10000000'         (RERGEFLG)- >=1 OF R0-R6 MODIFIED\n         SPACE 1\nRGENTS   EQU   *                   ENTRY FOR CHECKING CODE\n         LM    RGRA,RGRC,REGSAVB   GET THE CORRECT VALUES RETURNED\n         LM    RA,RC,ECREGRA       GET THE USER'S REGS\n         B     RG$BASE(R15)        BRANCH TO CORRECT CODE\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*              INDIVIDUAL ROUTINE REGISTER CHECKING CODE              *\n*        THE OFFSET VALUES STORED IN RFSYMS WERE CALCULATED RELATIVE  *\n*        TO LABEL RG$BASE, WITH AN OFFSET OF 0 MEANING THAT NO        *\n*        REGISTER CHECKING IS REQUIRED.  THE ENTRY LABELS IN THIS     *\n*        SECTION ARE ALL OF THE FORM  'RG' FOLLOWED BY THE NAME OF    *\n*        THE DESIRED ENTRY POINT.  NOTE THAT MANY OF THEM ARE EQU'D   *\n*        TOGETHER AND USE EXACTLY THE SAME CODE FOR CHECKING.         *\n*              THE ENTRY LABELS ARE IN ORDER FIRST BY WHETHER THEY    *\n*        MAY CALL OTHER MODULES OR NOT, AND THEN ALPHABETICALLY.      *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nRG$BASE  EQU   *                   BASE LABEL FOR OFFSETS\n         BR    R14                 RETURN, NO CHECKING\n         SPACE 2\nRGBRUSIN EQU   RG$BASE             NO CHECKING\n         SPACE 1\nRGBRINIT EQU   RG$BASE             NO CHECKING\n         SPACE 1\nRGBRDROP EQU   *                   RB AND GRB BOTH =0 OR ^=0\n         LTR   RGRB,RGRB           WAS REAL RETURN CODE 0\n         BNZ   RGBR10              NO, BRANCH\n         LTR   RB,RB               WAS USER RETURN CODE ALSO ZERO\n         BCR   Z,R14               YES, NO MORE, QUIT\n         B     RGRBERR             RGRB=0, RB^=08 ERROR\n         SPACE 1\nRGBRDISP EQU   *                   GRB=0==>RB=0 AND RA=GRA.\n*                                  GRB^=0 ==> RB^=0\n         LTR   RGRB,RGRB           WAS REAL RB =0\n         BNZ   RGBR10              ^=0, GO CHECK USER RB\n         LTR   RB,RB               RB MUST =0 ALSO\n         BNZ   RGRBERR             IT DOESN'T, SO WORNG\n         CR    RA,RGRA             RB=GRB=0, SO CHECK RA TOO\n         BCR   E,R14               SAME, OK, RETURN\n         B     RGRAERR             NO, ERRO, GO FLAG IT\nRGBR10   LTR   RB,RB               WAS USER RB ALSO NOT ZERO\n         BCR   NZ,R14              YES, OK, QUIT\n         B     RGRBERR             NO, RGRB^=0, RB=0, ERROR\n         SPACE 2\nRGCBCON1 EQU   *                   GRB=$ERINVCN==> RB=$ERINVCN, RA OK\n*                                  GRB=0 ==> RA=GRA, RC=GRC\n         CR    RB,RGRB             ARE THEY SAME\n         BNE   RGRBERR             NO, GO FLAG, DON'T DO MORE\n         LTR   RGRB,RGRB           WAS CONSTNAT GOOD\n         BZ    RGCB10              YES, GO CONTINUE CHECK\n         BAL   R1,RGRAADDR         BAD CONSTANT, BUT CHECK SCAN PTR\n         BR    R14                 IF RETURNED HERE, OK\nRGCB10   CR    RC,RGRC             SAME VALUE OF RC\n         BE    RGCB20              YES, SKIP, OK\n         OI    RERGEFLG,RGERC      NO, ERROR, FLAG IT\nRGCB20   CR    RA,RGRA             WAS RA SAME\n         BNE   RGRAERR             NO, ERROR, GO FLAG IT\n         BR    R14                 RETURN, OK\n         EJECT\nRGCBCON2 EQU   *                   RA=GRA. CODE AT @RC = CODE @GRC.\n*                                  LENGTH-1 FOR CLC FROM ORIG. RB\n         CR    RA,RGRA             MAKE SURE SAME SCAN PTR\n         BE    *+8                 SKIP IF OK\n         OI    RERGEFLG,RGERA      FLAG SCAN PTR ERR  7\n         BAL   R1,RGRCADDR         MAKE SURE RC HAS OK @, SO DON'T 0C5\n         L     RB,REGSAVA+4        GET ORIGINAL INPUT VALUE OF RB\n         EX    RB,RGCBCLC          SUPPY LENGTH-1 TO THE CLC\n         BCR   E,R14               SAME, SO OK, RETURN\n         B     RGRCERR             BAD, GO FLAG IT\nRGCBCLC  CLC   0($,RC),0(RGRC)     COMPARE VALUE, EX SUPPLIES LENGTH\n         SPACE 2\nRGCCCON1 EQU   RGCBCON1            SAME CODE AS ABOVE\n         SPACE 1\nRGCCCON2 EQU   RGCBCON2            SAME CODE AS ABOVE\n         SPACE 2\nRGCDECN1 EQU   *                   RB=GRB. GRB=0==> RA=GRA.\n         LR    RC,RGRC             DUPLICATE VALUE SO CHECK OK\n         B     RGCBCON1            BRANCH BACK TO USE SAME CODE\n         SPACE 1\nRGCDECN2 EQU   *                   RB=GRB. OTHERWISE, SAME AS CBCON2\n         CR    RB,RGRB             WAS IT SAME\n         BE    RGCBCON2            YES  SO GO CONTIUE CHECK\n         B     RGRBERR             NO, GO FLAG AS ERROR\n         SPACE 2\nRGCFHCN1 EQU   RGCDECN1            SAME AS DE CONSTANTS\n         SPACE 1\nRGCFHCN2 EQU   RGCDECN2            SAME AS DE CONSTANTS\n         SPACE 2\nRGCPCON1 EQU   RGCBCON1            SAME AS ABOVE\n         SPACE 1\nRGCPCON2 EQU   RGCBCON2            SAME AS ABOVE\n         SPACE 2\nRGCXCON1 EQU   RGCBCON1            SAME CODE AS ABOVE\n         SPACE 1\nRGCXCON2 EQU   RGCBCON2            SAME CODE AS ABOVE\n         SPACE 2\nRGCZCON1 EQU   RGCBCON1            SAME CODE AS ABOVE\n         SPACE 1\nRGCZCON2 EQU   RGCBCON2            SAME CODE AS ABOVE\n         EJECT\nRGOPINIT EQU   RG$BASE             NO CHECKING REQUIRED\n         SPACE 1\nRGOPFIND EQU   *                   RA=GRA. RG=GRB. RGRB=0 ==> RC OK\n         CR    RA,RGRA             IS IT OK\n         BE    *+8                 YES, SKIP\n         OI    RERGEFLG,RGERA      NO, FLAG RA ERROR\n         CR    RB,RGRB             WAS RETURN CODE OK\n         BNE   RGRBERR             NO, GO FLAG IT AND QUIT\n         LTR   RGRB,RGRB           WSS RETURN CODE ZERO\n         BCR   NZ,R14              NO, QUIT NOW, OK\n         BAL   R1,RGRCADDR         MAKE SURE OPCODTB PTR IN LEGAL AREA\n         S     RA,REGSAVA          GET LENGTH OF OPCODE\n         BCTR  RA,0                GET LENGTH-1\n         USING OPCODTB,RC          NOTE PTR THERE\n         EX    RA,RGOPCLC          IS SYMBOL THE SAME\n         BCR   E,R14               YES, OK RETURN\n         B     RGRCERR             NO, GO FLAG ERROR\nRGOPCLC  CLC   OPCMNEM($),OPCMNEM-OPCODTB(RGRC)       COMPARE OPCODES\n         DROP  RC                  REMOVE OPCODTB USING\n         BR    R14                 RETURN , OK\n         SPACE 2\nRGSDBCDX EQU   *                   RB=GRB. GRB=0 OR -4 ==> RA=GRA,RC=\n         CR    RB,RGRB             SAME\n         BNE   RGRBERR             NO, QUIT NOW, ERROR\n         LTR   RGRB,RGRB           WAS RETURN CODE 0 OR -4\n         BNP   RGCB10              YES, SO GO TO COMMON CHECKING CODE\n         BAL   R1,RGRAADDR         CHECK SCAN PTR FOR LEGALITY\n         BR    R14                 RETURN, OK\n         SPACE 1\nRGSDBTRM EQU   RGSDBCDX            SAME CODE\n         SPACE 1\nRGSDCTRM EQU   RGSDBCDX            SAME CODE AS ABOVE\n         SPACE 1\nRGSDDTRM EQU   RGSDBCDX            SAME CODE AS ABOVE\n         SPACE 1\nRGSDXTRM EQU   RGSDBCDX            SAME CODE AS ABOVE\n         EJECT\nRGSYINT1 EQU   RG$BASE             NO CHECKING\n         SPACE 1\nRGSYENT1 EQU   *                   RB=GRB. (RA==> SYMBOL)=(GRA=>SYM)\n         CR    RB,RGRB             SAME OR NOT\n         BE    RGSY10              YES, OK\n         OI    RERGEFLG,RGERB      NO, ERROR\n         B     RGSY10              GO CONTINUE CHECKING\n         SPACE 1\nRGSYFIND EQU   *                   RG=GRB. GRB=0 ==> SYMBOLS SAME\n         CR    RB,RGRB             RETURN CODE SAME\n         BNE   RGRBERR             NO, ERROR RIGHT OFF\n         LTR   RGRB,RGRB           WAS SYMBOL IN TABLE(RGRB=4)\n         BCR   NZ,R14              NO, SO DON'T LOOK, RETURN\nRGSY10   C     RA,ECFADL           BEGIN CHECK FOR WITHIN USER PROG\n         BL    RGRAERR             RA TOO LOW-ERROR\n         C     RA,ECFADHC          COMPARE WITH HIGH CHECK LIMIT\n         BH    RGRAERR             TOO HIGH-BRANCH-ERROR\n         L     RB,REGSAVA+4        GET ORIGINAL LENGTH OF SYMBOL 1-8.\n         BCTR  RB,0                OBTAIN LENGTH-1 FOR EXECUTE MVC\n         USING SYMSECT,RA          NOTE SYMBOL TABLE DSECT\n         EX    RB,RGSYCLC          COMPARE THE SYMBOLS\n         BNE   RGRAERR             NOT SAME SYMBOL, ERROR\n         BR    R14                 OK, RETURN\nRGSYCLC  CLC   SYMBOL($),SYMBOL-SYMSECT(RGRA)         COMPARE SYMBOLS\n         DROP  RA                  REMOVE SYMSECT USING\n         SPACE 1\nRGSYEND2 EQU   RG$BASE             NO CHECKING\n         SPACE 2\n         AIF   (&$REPL LT 2).RGNERE2 SKIP IF REPL ENTRIES MAY NOT CALL\n*                                     ASSIST SUBROUTINES\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*              CHECKING CODE - ENTRIES WHICH MAY CALL OTHERS.         *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 2\nRGEVALUT EQU   *                   GRB^=0 ==> RB^=0. GRB=0 ==> RA=GRA.\n*                                  GRB=0 ==> RC=GRC, RD=GRD, RE=GRE.\n         LTR   RGRB,RGRB           WAS REAL RETURN CODE ZERO\n         BZ    RGEV10              YES, SKIP\n         LTR   RB,RB               WAS USER CODE NO TZERO\n         BZ    RGRBERR             DIDN'T MATCH, ERROR BRANCH\n         BAL   R1,RGRAADDR         ERROR IN EXP-GO CHECK FOR OK SCAN PT\n         BR    R14                 RETURN, SCAN PTR OK\nRGEV10   LTR   RB,RB               WAS FAKE USER RB ZERO ALSO\n         BNZ   RGRBERR             NO, ERROR, QUIT\n         LM    R0,R1,ECREGRA+12    GET USER REGS RD-RE\n         C     R0,REGSAVB+12       COMPARE WITH REAL RD\n         BE    *+8                 SKIP IF OK\n         OI    RERGEFLG,RGERD      FLAG RD WRONG\n         C     R1,REGSAVB+16       COMPARE WITH REAL RE RETURNED\n         BE    RGCB10              OK, GO CONTINUE CHK FOR RC,RA\n         OI    RERGEFLG,RGERE      FLAG RE IN ERROR\n         B     RGCB10              GO TO CHECK RC,RA\n.RGNERE2 ANOP\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*              MISC. CHECKING AND EXIT CODE SECTIONS.                 *\n*        THESE SECTIONS OF CODE CAN BE CALLED OR BRANCHED TO BY ANY   *\n*        OF THE INDIVIDUAL SECTIONS ABOVE.                            *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 2\n**--> INSUB: RGRAADDR   CHECK LEGITAMACY OF SCAN PTR RA + + + + + + + +\n*+       ENTRY CONDITIONS                                             +\n*+  R1 = RETURN @ OF CALLING PROGRAM CODE.                            +\n*+  RA = VALUE OF SCAN POINTER TO BE CHECKED.                         +\n*+  R14= RETURN @ TO BE TAKEN IF RA IS IN ERROR.                      +\n*+       EXIT CONDITIONS                                              +\n*+  RB,RC ARE DESTROYED.  MUST BE RELOADED IF CALLER NEEDS THEM.      +\n*+  RERGEFLG IS MARKED WITH RGERA IF RA IS INCORRECT.                 +\n*+  + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +\nRGRAADDR C     RA,REGSAVA          COMPARE TO ORIGINAL SCAN PTR\n         BL    RGRAERR             ROUTINE BACKED UP SCAN PTR-ERROR\n         LA    R0,200              MAXIMUM POSSIBLE DIF IN SCAN PTRS\n         A     R0,REGSAVA          ADD ORIG RA TO MAX DIFFERENCE\n         CR    RA,R0               CHECK GAINST THIS LIMIT\n         BCR   L,R1                YES, OK, NO ERROR\n         SPACE 1\n*              EXIT POINT - FLAG RA IN ERROR, QUIT CHECKING.\nRGRAERR  OI    RERGEFLG,RGERA      SHOW RA WRONG\n         BR    R14                 RETURN, QUIT CHECKING\n         SPACE 2\n*              EXIT POINT - FLAG RB IN ERROR, QUIT CHECKING.\nRGRBERR  OI    RERGEFLG,RGERB      FLAG RB IN ERROR\n         BR    R14                 RETURN, NO MORE CHECKING\n         SPACE 2\n**--> INSUB: RGRCADDR   CHECK RC FOR @ INSIDE USER PROG.+ + + + + + + +\n*+       ENTRY CONDITIONS                                             +\n*+  R1 = RETURN @ TO CALLING CODE IN RGENTS                           +\n*+  RC = VALUE TO BE CHECKED                                          +\n*+  R14= RETURN @ TO BE TAKEN IF RC HAS INCORRECT VALUE.              +\n*+  + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +\nRGRCADDR C     RC,ECFADL           MUST BE >= LOWER FAKE LIMIT\n         BL    RGRCERR             IT WASNT, SO ERROR-BRANCH\n         C     RC,ECFADHC          MUST BE <= HIGH LIMIT FOR CHECKING\n         BCR   NH,R1               NOT HIGH, SO OK, RETURN TO CALLER\n         SPACE 1\n*              EXIT POINT - FLAG RC IN ERROR, QUIT CHECKING\nRGRCERR  OI    RERGEFLG,RGRC       FLAG ERROR IN RC\n         BR    R14                 RETURN TO REGULAR PROG. QUIT CHECK\n         AIF   (&$REPL LT 2).RHNREP         SKIP IF NO REPL CALLS\n         TITLE 'REMONI - RHENTS SECTION - CHECK CALLING VALUES'\n**--> INSUB: RHENTS     CHECK PARM REGS PASSED TO CALLED PROGRAM+ + + +\n*+       RHENTS IS CALLED ONLY WHEN A CALL TO A REAL ASSIST MODULE    +\n*+  IS MADE BY A REPLACABLE MODULE PERMITTED TO CALL OTHERS.  ITS     +\n*+  PURPOSE IS TO PROTECT ASSIST FROM ABENDS CAUSED BY IMPROPER VALUES+\n*+  BEING PASSED TO REAL ASSIST ROUTINES, WHICH EXECUTE DIRECTLY.     +\n*+       ENTRY CONDITIONS                                             +\n*+  R14= RETURN @ TO CALLLING CODE IN MAIN SECTION OF REFAKE.         +\n*+  R15= OFFSET @ FROM RH$BASE TO INDIVIDUAL CODE CHECKING SECTION.   +\n*+  RERGEFLG   BITS FOR RGERA-RGERE   ARE ZEROED.                     +\n*+       EXIT CONDITIONS                                              +\n*+  R0,R1,RA,RB,RC      MAY BE MODIFED.                               +\n*+  R4-R6,R10-R15  ARE PRESERVED ACROSS CALLS TO RHENTS.              +\n*+  RERGEFLG  BITS ARE SET AS NEEDED.                                 +\n*+       NAMES: RH------                                              +\n*+  + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +\n         SPACE 1\n* * * * * * * * RHENTS REGISTER ALLOCATION  * * * * * * * * * * * * * *\n*   R0 = WORK REGISTER                                                *\n*   R1 = INTERNAL LINK REGISTER FOR CHECKING ROUTINES.                *\n*   R2,R3      UNUSED AT PRESENT, MAY BE USED IF REQUIRED IN FUTURE.  *\n*   RA,RB,RC   HOLD VALUES OF CORRESPONDING USER REGISTERS.           *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nRHENTS   EQU   *\n         LM    RA,RC,ECREGRA       GET PARM REGS, MOST USUAL ONES\n         B     RH$BASE(R15)        BRANCH TO RIGHT SECTION OF CODE\n         SPACE 1\nRH$BASE  EQU   *                   BASE LABEL FOR CALL CHECKING SECTS\n         BR    R14                 IF COMES HERE, NO CHECKING\n         SPACE 2\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*              INDIVIDUAL ROUTINE REGISTER CHECKING CODE SECTIONS     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 2\nRHSDBCDX EQU   *                   RA IN MACHINE REASONABLY\n         BAL   R1,RHRAADDR         CALL CHECKING ROUTINE\n         BR    R14                 RETURN\n         SPACE 1\nRHSDBTRM EQU   RHSDBCDX            SAME CODE\nRHSDCTRM EQU   RHSDBCDX            SAME CODE\nRHSDDTRM EQU   RHSDBCDX            SAME CODE\nRHSDXTRM EQU   RHSDBCDX            SAME CODE\n         SPACE 2\nRHSYFIND EQU   *                   RA REASONBALE, 1<= RB <= 7\n         BAL   R1,RHRAADDR         CHECK RA FOR REAONABLENESS\n         C     RB,AWF1             TEST\n         LTR   RB,RB               WAS RB<=0\n         BNP   RHRBERR             YES, ILLEGAL-BRANCH\n         C     RB,AWF7             WAS IT TOO BIG\n         BCR   NH,R14              NO,OK,RETURN\nRHRBERR  OI    RERGEFLG,RGERB      RB IN ERROR\n         BR    R14                 RETURN\n         EJECT\n*              RHENTS INTERNAL SUBROUTINES                            *\n         SPACE 2\n**--> INSUB: RHRAADDR   CHECK RA FOR REASONABLE @ + + + + + + + + + + +\n*+       ENTRY CONDITIONS                                             +\n*+  R1 = RETURN @ TO CALLING CODE                                     +\n*+  RA = VALUE TO BE CHECKED FOR LEGALITY.                            +\n*+  + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +\n         SPACE 1\nRHRAADDR EQU   *\n*              CHECK FOR @ IN USER PROGRAM.\n         C     RA,ECFADL           LOWER LIMIT OF USER\n         BL    RHRA2               NO, NOT IN USER PROG\n         C     RA,ECFADHC          HIGH CHECKING LIMIT\n         BCR   NH,R1               INSIDE USER, OK, RETURN\n         SPACE 1\n*              CHECK FOR IN AVWXTABL\nRHRA2    EQU   *\n         CR    RA,RAT              LOWER TAHN PTR\n         BL    RHRA3               YES, NOT THERE EIEHRE\n         LA    R0,AVWXEND-8        HIGHEST @ IN TABLE\n         CR    RA,R0               COMPARE TO UPPER LIMIT POSSIBLE\n         BCR   NH,R1               IN THERE, OK RETURN\n         SPACE 1\n*              CHECK FOR @ IN DYNAMIC AREA.\nRHRA3    EQU   *\n         C     RA,AJOTADL          LOWER THAN LOWEST\n         BL    RHRA4               YES\n         C     RA,AJOTADH          HIGHER THAN HIGHEST\n         BCR   NH,R1               NO, SO OK, RETURN\n         SPACE 1\nRHRA4    EQU   *\nRHRAERR  OI    RERGEFLG,RGERA      FLAG RA WORNG\n         BR    R1                  RETURN TO CALLER\n.RHNREP  ANOP\n         LTORG\n         DROP  R5,R10,R11,RAT,R13  REMOVE ALL USINGS\n         TITLE 'RFSYMS - REPLACE TABLE CSECT - CSECT,ENTRY NAMES'\n         PRINT GEN\n**--> CSECT: RFSYSMS    TABLE OF CSECT-ENTRY NAMES-REPLACE  . . . . . .\n*.             RFYSMS (SECT.1) HAS AN ELEMENT FOR EACH CSECT WHICH CAN.\n*.       BE DYNAMMICALLY REPLACED BY A USER-WRITTEN ROUTINE. EACH     .\n*.       ELEMENT CONTAINS THE NAME OF THE CSECT, THE NUMBER OF        .\n*.       ENTRY POINTS IN IT, AND A LIST OF ENTRY POINT NAMES AND      .\n*.       OFFSETS TO THEIR ADCONS IN AVWXTABL, SO THEY CAN BE CHANGED. .\n*.             THE 2ND SECTION IS PRESENT IF &$REPL=2.  IT LISTS ALL  .\n*.       ENTRYPOINTS WHICH CAN BE CALLED FROMA USER PROGRAM, WITH     .\n*.       OFFSET @ PTRS TO THEIR ADCONS IN AVWXTABL, AND TO CODE IN    .\n*.       SECTION RHENTS OF REMONI.  THIS CODE IS USED TO CHECK THE    .\n*.       REGISTERS PASSED BY THE USER TO THE CALLED PROGRAM.          .\n*.             THE 3RD SECTION IS ALSO PRESENT ONLY IF &$REPL=2. IT   .\n*.       HAS LABELS OF THE FORM RI&CSECT, WITH &CSECT BEING ONE WHICH .\n*.       NOT ONLY CAN BE REPLACED, BUT CAN ALSO CALL OTHER ROUTINES.  .\n*.       EACH ELEMNT CONTAINS A HALFWORD WITH THE NUMBER OF DIFFERENT .\n*.       SUBROUTINE ENTRIES WHICH THIS CSECT IS PERMITTED TO CALL,    .\n*.       FOLOWED BY THAT # OFFSET VALUES TO THE ELEMENTS IN THE 2ND   .\n*.       SECTION OF THOSE ENTRIES IT CAN CALL.  REMONI OBTAINS AN     .\n*.       OFFSET FROM RFSYMS TO RI&CSECT FROM THE RFSYMBLK BELONGING   .\n*.       TO THAT CSECT.  NOTE, IF A CSECT CAN CALL NO OTHER, THE      .\n*.       VALUE SAVED IS = 0.                                          .\n*.       NAMES: RF------                                              .\n*.       NAMES: RI------           (IN SECTION 3, IF &$REPL=2)\n*.       DSECT RFSYMBLK IS USED TO DESCRIBE EACH ENTRY IN SECTS.1&2.  .\n*.       USES MACROS: $AL2,RFSGN                                      .\n*.  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n         SPACE 1\nRFSYMS   CSECT\n*        **NOTE** COMMENTED ENTRIES ARE NOT CURRENTLY AVAILABLE.\n         RFSGN BROPS2,(BRINIT,BRUSIN,BRDROP,BRDISP)\n*        RFSGN CACONS,(CACON1,CACON2),TYPE=1\n         RFSGN CBCONS,(CBCON1,CBCON2)\n         RFSGN CCCONS,(CCCON1,CCCON2)\n         RFSGN CDECNS,(CDECN1,CDECN2)\n         RFSGN CFHCNS,(CFHCN1,CFHCN2)\n*        RFSGN CODTL1,CODTL1,TYPE=1\n         RFSGN CPCONS,(CPCON1,CPCON2)\n*        RFSGN CVCONS,(CVCON1,CVCON2),TYPE=1\n         RFSGN CXCONS,(CXCON1,CXCON2)\n         RFSGN CZCONS,(CZCON1,CZCON2)\n         RFSGN EVALUT,EVALUT,TYPE=1\n         RFSGN OPCOD1,(OPINIT,OPFIND)\n*        RFSGN SCANRS,(SCANBL,SCANCO,SCANEQ),TYPE=1\n         RFSGN SDTERM,(SDBCDX,SDBTRM,SDCTRM,SDDTRM,SDXTRM)\n         RFSGN SYMOPS,(SYINT1,SYENT1,SYFIND,SYEND2)\nRFSYMS$L EQU   *-RFSYMS            LENGTH OF SEARCH IN RFSYMS CSECT\n         SPACE 1\n         AIF   (&$REPL LT 2).RENREPA        SKIP IF NO SECTS 2 & 3\n         SPACE 2\n*              SECTION 2 - CALLABLE ENTRY POINT INFORMATION.\nRFSCALLA DS    0H                  BEGINNING OF LIST\n         RFSGN SDBCDX,TYPE=2\n         RFSGN SDBTRM,TYPE=2\n         RFSGN SDCTRM,TYPE=2\n         RFSGN SDDTRM,TYPE=2\n         RFSGN SDXTRM,TYPE=2\n         RFSGN SYFIND,TYPE=2\nRFSCALLZ EQU   *-RFS$LEN           END @ - LENGTH FOR BXLE LIMIT\n         SPACE 2\n*              SECTION 3 - OFFSETS TO CALLABLES FROM EACH REPLACABLE.\n*              ALTHOUGH EVALUT IS ONLY ONE NOW, OTHERS COULD BE ADDED.\n         SPACE 1\nRIEVALUT DC    H'6'                EVALUT CAN CALL 6 ENTRIES IF IT WANT\n         $AL2  RFSYMS,(RFSDBCDX,RFSDBTRM,RFSDCTRM,RFSDDTRM,RFSDXTRM,RFS#\n               YFIND)              OFFSETS TO SECTION 2 BLOCKS ABOVE\n         SPACE 2\n         PRINT NOGEN               TURN OFF GENERATION IN REST  CPP\n.RENREPA ANOP\n.RENREPL ANOP\n         TITLE  '***  EQU''S FOR MACRO ROUTINES '\n         AIF   (NOT &$MACROS).MAXXXX   SKIP MACROS                    J\n*   FOLLOWING EQU'S HANDLE ERROR MESSAGES IN MEXPND NOT TAKEN CAREOF\n*     BY ERRTAG\n$ER#ACTR EQU   2                   ACTR EXCEEDED                      S\n$ER#DMER EQU   4                   SET SYMBOL SUBSCRIPT               S\n$ER#SBST EQU   6                   SUBSTRING EXPRESSION               S\n$ER#CVCA EQU   8                   CHAR TO ARITH CONV ERR             S\n$ER#CVAB EQU   10                  ARITH TO BOOL CONV ERR             S\n$ER#CVCB EQU   12                  CHAR TO BOOL CONV ERR              S\n$ER#ATER EQU   14                  ATTRIBUTE USE ERR                  S\n$ER#SYSL EQU   16                  &SYSLIST ERR                       S\n$ER#SYER EQU   18                  SYSTEM ERR                         S\n$ER#EXBF EQU   20                  CHAR BUFFER EXCEEDED               S\n$ER#MXST EQU   22                  MAX # OF STMTS EXCEEDED            S\n$ER#ZDIV EQU   24                  FIXED PT OVERFLOW OR ZERO DIVIDE   S\n$ER#PRVR EQU   26                                                     A\n         SPACE 2\n*   FOLLOWING FLAGS SET IN AVMSNBY1 WILL TURN ON RESPECTIVE SNAPS\n$MSNP01  EQU   X'80'               MACINT SNAP FLAG\n$MSNP02  EQU   X'40'               MACRO1 SNAP FLAG\n$MSNP03  EQU   X'20'               MACSCN SNAP FLAG\n$MSNP04  EQU   X'10'               MCSCOP SNAP FLAG\n$MSNP05  EQU   X'08'               MACFND,MCVSCN SNAP FLAG\n$MSNP06  EQU   X'04'          MCSYSR, DECTRM, MCGTST, ATTERM SNAP FLAG\n$MSNP07  EQU   X'02'               MCBODY SNAP FLAG\n$MSNP08  EQU   X'01'               BSU'S SNAP FLAG\n         SPACE\n*   FOLLOWING FLAGS SET IN AVMSNBY2 WILL TURN ON RESPECTIVE SNAPS\n$MSNP09  EQU   X'80'               MACLEX SNAP FLAG\n$MSNP10  EQU   X'40'               MCGNCD SNAP FLAG - ONE OPS\n$MSNP11  EQU   X'20'               MEXPND SNAP - INIT AND INTERPRET\n$MSNP12  EQU   X'10'               MEXPND SNAP - INTERNAL ROUTINES\n$MSNP13  EQU   X'08'               MXERRM, MXMVSR SNAP CONTROL\n$MSNP14  EQU   X'04'               SET MEXPND ENTER EXIT SNAPS\n         SPACE\n$MINDEF  EQU   X'80'               AVMBYTE1 - IN MACRO DEFINITION\n$MINEXP  EQU   X'40'               AVMBYTE1 - IN MACRO EXPANSION\n$MGBLFLG EQU   X'80'               MCLBFLG2 - GLOBALS NO LONGER OK    S\n$MLCLFLG EQU   X'40'+$MGBLFLG      MCLBFLG2 - LOCALS NO LONGER OK     S\n$MACTFLG EQU   X'20'+$MLCLFLG      MCLBFLG2 - ACTR NO LONGER OK       S\n$MCOCFL1 EQU   B'00000001'         (MCLBFLG2) - OPEN CODE - DECLARE   S#\n                                   TYPES ALLOWED                      S\n$MCOCFL2 EQU   B'00000011'         (MCLBFLG2) - OPEN CODE - DECLARE   S#\n                                   TYPES NOT ALLOWED                  S\n$MC1DCL  EQU   B'10000000'         DECLARE TYPE                       S\n$MC1ERR  EQU   B'01000000'         ORDER ERROR                        S\n$MC1SKIP EQU   B'00100000'         DON'T CALL MXINST                  S\n$MC1RET  EQU   B'00010000'         RETURN AFTER MXINST                S\n$MSBLIST EQU   X'04'               AVMBYTE1 - PROCESSING OPERAND SUBLST\n$MINQUOT EQU   X'02'               AVMBYTE1 - INSIDE QUOTED STRING\n$MKEYOPR EQU   X'01'               KEYWORD OPRND PROCESSSED, POSIT NOGO\n         SPACE 1\n$MOPRTR  EQU   X'80'               AVMBYTE2 - PREV SYMBOL = OPRTR\n$MTERM   EQU   X'40'               AVMBYTE2 - PREV SYMBOL = TERM\n$MINARIT EQU   X'20'               AVMBYTE2 - IN ARITHMETIC EXPRESSION\n$MINBOOL EQU   X'10'               AVMBYTE2 - IN BOOLEAN EXPRESSION\n$MINCHAR EQU   X'08'               AVMBYTE2 - IN CHARACTER EXPRESSION\n$MDIMVAR EQU   X'04'               AVMBYTE2 - PREV SYMBOL = DIMEN SYMB\n$MINAPAR EQU   X'02'               AVMBYTE2 - IN ARITH SUBSCR EXPRESS\n$MINPEXP EQU   X'01'               AVMBYTE2 - DO EXPRES IN PARENS ONLY\n         SPACE 1\n$MRPARST EQU   X'80'               AVMBYTE4 - RIGHT PAREN IN INPUT\n$MINSTRN EQU   X'40'               AVMBYTE4 - PROC VAR SYMB IN STRING\n$MCOMST  EQU   X'20'               AVMBYTE4 - COMMA IN BSU INPUT STRM\n$MGENSTP EQU   X'10'               AVMBYTE4 - STOP MACRO GENERATION\n$MXJMPFL EQU   X'08'               AVMBYTE4 - AGO OR SUCCESSFUL AIF SWT\n$MSTOPEX EQU   X'04'               AVMBYTE4 - DON'T EXPAND CRRNT MACRO\n         SPACE 2\n$GLOBAL  EQU   4\n$LOCAL   EQU   8\n$SYMPAR  EQU   12\n$SYSVAR  EQU   16                  SYSTEM VARIABLE INDEX\n         SPACE 2\n$LCHWRK  EQU   1024\n$LSUBENT EQU   12                  LENGTH OF SUB-OPERAND ENTRY\n$LMSRCMX EQU   (RSOL1+2*RSOLC)-1   MAXIMUM LENGTH-1 OF GEN'D STMT\n         SPACE 2\n$BSAR    EQU   X'20'               MCBSFLGS, ARITHMETIC TYPE\n$BSBOOL  EQU   X'10'               MCBSFLGS, BOOLEAN TYPE\n$BSCHAR  EQU   X'08'               MCBSFLGS, CHARACTER TYPE\n         SPACE 2\n*  EQUATES FOR INDEX VALUES FOR OPERATOR BSU'S\n$BSPLUS  EQU   2\n$BSMIN   EQU   4\n$BSMULT  EQU   6\n$BSDIV   EQU   8\n$BSOR    EQU   10\n$BSAND   EQU   12\n$BSNOT   EQU   14\n$BSNE    EQU   16\n$BSGE    EQU   18\n$BSLE    EQU   20\n$BSLT    EQU   22\n$BSEQ    EQU   24\n$BSGT    EQU   26\n$BSCAT   EQU   28\n$BSAGO   EQU   30\n$BSAIF   EQU   32\n$BSETA   EQU   34\n$BSETB   EQU   36\n$BSETC   EQU   38\n$BSRPAR  EQU   40\n$BSLPAR  EQU   42\n$BSBSCRP EQU   44\n$BSBSTR  EQU   46\n$BSBSYL  EQU   48\n$BSCOMMA EQU   50                  HIERARCHY = ZERO\n$BSPRINT EQU   52                  HIERARCHY = 2\n$BSMEXIT EQU   54                  HIERARCHY = 2\n$BSMEND  EQU   56                  HIERARCHY = 2\n$BSANOP  EQU   58                  HIERARCHY = 2\n$BSERR01 EQU   60                  HIERARCHY = 2\n$BSINMAC EQU   62                  SET INNER MACRO CALL CODE HIER = 2\n$BSMVSTM EQU   64                  BSU INDEX FOR MOVE STMT\n$BSMNTER EQU   X'80'               FLAG TO FORCE ERR MSSGE ON MNOTE\n$BSRLCHR EQU   X'80'               FLAG FOR CHAR TYPE RELATIONAL OPRTR\n$MPRCOM  EQU   1                   (MCBSFLGS)=> SPECIAL PRINT         A\n         SPACE 2\n*   EQUATES FOR OPERATOR HIERARCHIES\n$MCOMMHR EQU   0\n$MPARHR  EQU   0\n$MPRNTHR EQU   2\n$MSETHR  EQU   2\n$MORHR   EQU   4\n$MANDHR  EQU   6\n$MRELHR  EQU   8\n$MCATHR  EQU   10\n$MPLUSHR EQU   12\n$MMULTHR EQU   14\n$MNOTHR  EQU   16\n$MAGOHR  EQU   16\n$MAIFHR  EQU   16\n         SPACE 2\n*  EQUATES FOR TERM BSU INDEXES\n$BSTSYAG EQU   2                   GLOBAL ARITH SET SYMBOL\n$BSTSYBG EQU   4                   GLOBAL BOOLEAN SET SYMBOL\n$BSTSYCG EQU   6                   GLOBAL CHAR SET SYMBOL\n$BSTSYAL EQU   8                   LOCAL ARITH SET SYMBOL\n$BSTSYBL EQU   10                  LOCAL BOOL SET SYMBOL\n$BSTSYCL EQU   12                  LOCAL CHAR SET SYMBOL\n$BSYMPAR EQU   14                  SYMBOLIC PARAMETER\n$BSIMMA  EQU   16                  ARITH IMMEDIATE BALUE\n$BSIMMB  EQU   18                  BOOLEAN IMMEDIATE VALUE\n$BSTRING EQU   20                  STRING VALUE\n$BSYSNDX EQU   22                  &SYSNDX SYSTEM VARIABLE\n$BSYSLST EQU   24                  &SYSLIST SYSTEM VARIABLE\n$BSYSECT EQU   26                  &SYSECT SYSTEM VARIABLE\n$BSLABEL EQU   28\n$BSTEMP  EQU   30\n$BSATI   EQU   34                  BSU NBR FOR I' ATTRIBUTE\n$BSATK   EQU   36                  BSU NBR FOR K' ATTRIBUTE\n$BSATL   EQU   38                  BSU NBR FRR L' ATTRIBUTE\n$BSATN   EQU   40                  BSU NBR FOR N' ATTRIBUTE\n$BSATS   EQU   42                  BSU NBR FOR S' ATTRIBUTE\n$BSATT   EQU   44                  BSU NBR FOR T' ATTRIBUTE\n$BSADDRA EQU   46                  BSU NBR FOR ARITH TYPE @\n$BSADDRB EQU   48                  BSU NBR FOR BOOL @\n$BSADDRC EQU   50                  BSU NBR FOR CHAR TYPE @\n         SPACE 2\n*  EQUATES FOR VARIOUS LEFT PAREN TYPES\n$MINLPAR EQU   X'80'               ARITH LEFT PAREN\n$MINSBST EQU   X'40'               SUBSTRING LEFT PAREN\n$MINSBSC EQU   X'20'               SUBSCRIPT LEFT PAREN\n$MINSYSL EQU   X'10'               &SYSLIST LEFT PAREN\n         TITLE '*** DSECTS FOR MACRO CAPABILITY IN ASSIST***'\n**-->  DSECT: MCGLBDCT    FORMAT FOR GLOBAL DICTIONARY ENTRY          *\n*.                                                                    *\n*.*********************************************************************\n         SPACE\nMCGLBDCT DSECT\nMCGLBNXT DS    F                   LINK TO NEXT GLOBAL ENTRY\nMCGLBLEN DS    C                   LENGTH OF GLOBAL NAME\nMCGLBNAM DS    CL8                 GLOBAL DICT ENTRY NAME\nMCGLBTYP DS    C                   ENTRY TYPE, ARITH, BOOL OR CHAR\nMCGLBDIM DS    H                   DIMENSION OF SET VARIABLE\nMGLCLPNT DS    0F                  POINTER OFFSET FOR LOCAL VALUE\nMCGLBDEF DS    F                   COUNT # OF MACRO DEFINITION\n$LGLBENT EQU   *-MCGLBDCT          LEN OF GLOBAL DICT ENTRY STND PART\nMCGBAVAL DS    0F                  GLOBAL ARITH VALUE\nMCGBBVAL DS    0F                  GLOBAL BOOL VALUE\nMCGBCLEN DS    F                   GOBAL CHAR VALUE LENGTH\nMCGBCVAL DS    CL8                 GLOBAL CHAR VALUE\n         EJECT\n**--> DSECT:  MCLCLDPV   FORMAT FOR LOCAL DICTIONARY DOPE VECTOR      *\n*.                                                                    *\n*.*********************************************************************\n         SPACE\nMCLCLDPV DSECT\nMCLOCNXT DS    F                   POINTER TO NEXT ENTRY\nMCLCLLEN DS    C                   LOCAL ENTRY NAME LENGTH\nMCLCLNAM DS    CL8                 LOCAL ENTRY NAME\nMCLCLTYP DS    C                   TYPE, IE ARITH, BOOL OR CHAR\nMCLCLDIM DS    H                   DIMENSION OF LOCAL ENTRY\nMCLCLPNT DS    F                   OFFSET POINTER FOR VALUE\n$LLCLDV  EQU   *-MCLCLDPV          LEN OF LOCAL DICT D.V.\n         SPACE 2\n**--> DSECT: MCPARENT   FORMAT FOR SYMBOLIC PARAMETER ENTRY           *\n*.                                                                    *\n*.*********************************************************************\n         SPACE\nMCPARENT DSECT\nMCPARNXT DS    F                   POINTER TO NEXT ENTRY\n*              NOTE: NEXT 3 ENTRIES MUST BE IN ORDER GIVEN.  JRM.     J\nMCPARNLN DS    C                   PARAM ENTRY NAME LENGTH\nMCPARNAM DS    CL8                 SYMBOLIC PARAM NAME\nMCPARTYP DS    C                   PARAMETER TYPE, POSIT OR KEYWORD\nMCPARNTL EQU   *-MCPARNLN          LENGTH MOVED TOGETHER              J\nMCPARNDX DS    H                   PARAMETER POSITION IN LIST\nMCPROPLN DS    C                   LENGTH OF OPERAND\nMCPRATYP DS    C                   ATTRIBUTE TYPE, IE 'N', 'O'\nMCPARNB  DS    C                   UNUSED AT PRESENT                  J\nMCPARFIL DS    C                   UNUSED AT MOMENT                 JRM\nMCPROPRN DS    F                   OPERAND STANDARD VALUE POINTER\n$LPARENT EQU   *-MCPARENT          LEN OF SYM PARAM ENTRY\n         SPACE 2\n**-->  DSECT:  MCBSU   FORMAT OF BASIC SYNTACTIC UNIT                 *\n*.                                                                    *\n*.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE\nMCBSU    DSECT\nMCBSFLGS DS    C                   INDICATES OPRTR, TERM ETC\nMCBSINDX DS    C                   BSU INDEX OF SYMBOL\nMCBSOFST DS    C                   SYMBOL OFFSET RELATIVE TO SOURCE\nMCBSTRLN DS    0C                  STRING LENGTH\nMCBSHIER DS    C                   HIERARCHY OF OPERATOR, IF OPRTR\nMCBSVALU DS    0F                  ARITH OR BOOL IMMEDIATE VALUE\nMCBSLOC  DS    F                   LOCATION OF TERM VALUE\n$LMCBSU  EQU   *-MCBSU            LENGTH OF BSU ENTRY\n         SPACE 2\n**-->  DSECT:  MCSEQ   FORMAT OF SEQUENCE SYMBOL ENTRY                *\n*.                                                                    *\n*.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE\nMCSEQ    DSECT\nMCSEQNXT DS    F                   POINTER TO NEXT ENTRY\nMCSEQNLN DS    C                   LENGTH OF NAME\nMCSEQNAM DS    CL8                 NAME OF SEQ SYMBOL\nMCSEQFLG DS    C                   ENTRY FLAG BYTE\nMCSEQDUM DS    H                   UNUSED\nMCSEQVAL DS    F                   POINTER TO SEQ SYMBOL LOCATION     *\n$LMCSEQ  EQU   *-MCSEQ             LENGTH OF SEQ SYMBOL ENTRY\n         SPACE 2\n**-->  DSECT:  MCOPQUAD  FORMAT OF ONE OP ENTRY.  MACRO DEFINITIONS   *\n*.        ARE TRANSLATED INTO ONE OPS FOR SUBSEQUENT INTERPRETATION   *\n*.                                                                    *\n*.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE\nMCOPQUAD DSECT\n*        EACH STATEMENT BEGINS WITH A PARTIAL ONE OP GIVEN FIRST,     A\n*        FOLLOWED BY 0 OR MORE NORMAL-SIZE ONE-OPS                    A\nMCQUDNXT DS    A                   ADDRESS OF NEXT STMT'S CODE        A\nMCQSTMNO DS    PL3                 STATEMENT NUMBER                   A\nMCQS1FLG DS    C                   FLAGE BYTE OR UNUSED               A\n$LMCOPL1 EQU   *-MCOPQUAD          LENGTH OF 1ST ONE-OP IN STMY       A\n         SPACE 1                                                      A\n*        FORMAT OF NORMAL ONE-OPS IN STATEMENT FOLLOWS                A\n         ORG   MCOPQUAD            BACK TO BEGINNING                  A\nMCBOPRTR DS    C                   OP CODE\nMCARG1DX DS    C                   ARG #1 BSU INDEX\nMCARG2DX DS    C                   ARG #2 BSU INDEX\nMCRSLTYP DS    C                   RESULT TYPE\nMCARG1LC DS    F                   ARG #1 LOCATION\nMCARG2LC DS    A                   ADDRESS OF ARGUMENT #1             A\nMCRESULT DS    F                   RESULT\n$LMCQUAD EQU   *-MCOPQUAD          LENGHT OF ONE-OP\n         SPACE 2\n**-->  DSECT:  MCBSTRMS   FORMAT OF TWO BSU'S FOR EASE                *\n*.        OF MANIPULATION IN TERM STACK                               *\n*.                                                                    *\n*.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE\nMCBSTRMS DSECT\nMCBSFLG1 DS    C                   TERM #1 FLAG BYTE\nMCBSNDX1 DS    C                   TERM #1 BSU INDEX\nMCBOFST1 DS    C                   TERM #1 OFFSET\nMCBLN1   DS    C                   TERM #1 LENGTH\nMCBSLOC1 DS    F                   TERM #1 LOCATION OR VALUE\nMCBSFLG2 DS    C                   TERM#2 FLAG BYTE\nMCBSNDX2 DS    C                   TERM #2 BSU INDEX\nMCBOFST2 DS    C                   TERM #2 OFFSET\nMCBLN2   DS    C                   TERM #2 LENGTH\nMCBSLOC2 DS    F                   TERM #2 LOCATION OR VALUE\n         SPACE 2\n*.-->  DSECT:  MCBOPRST    FORMAT OF OPERATOR STACK ENTRY             *\n*.                                                                    *\n*.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nMCBOPRST DSECT\nMCBOPFL  DS    C                   OPERATOR FLAGS\nMCBSOPST DS    C                   OPERATOR BSU INDEX\nMCBOPOF  DS    C                   OFFSET\nMCBOPHR  DS    C                   OPRTR HIERARCHY\nMCBOPVAL DS    F                   NOT USED\n         SPACE 2\n**--> DSECT: MXPNTSAV       CONTROL FOR LEVEL OF MACRO EXPANSION * *  S\n*.       ONE IS ALLOCATED FOR EACH LEVEL OF MACRO CALL                A\n*.       NAMES:MXP_____                                               A\n*.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE\nMXPNTSAV DSECT\nMXPNLINK DS    A                   @ LAST PREVIOUS MXPNTSAV           A\nMXPLSYPT DS    F                   PNTR TO SYM PARAM D.V.'S\nMXPSYSDX DS    PL3                 CURRENT SYSNDX VALUE\nMXPNFLG1 DS    C                   FLAG BYTE\nMXPCHRBF DS    F                   PNTR TO CHAR BUFFER FOR CATEN OPRTNS\nMXPNMCLB DS    F                   PNTR TO MAC LIB ENTRY\nMXPNKYPT DS    F                   PNTR TO 1ST KEYWORD SYM PAR DV\nMXPNKLPT DS    F                   PNTR TO 1ST KEYWORD DICT ENTRY\nMXPNLDBS DS    F                   PNTR TO SET SYMB LOCAL DICT\nMXPNCDPT DS    F                   PNTR TO 1ST INSTRUCTION\nMXPNCRCD DS    F                   PNTR TO CURRENT INST\nMXPNBOPS DS    F                   NBR OF POSITIONAL OPRNDS\nMXPNLSPT DS    F                   PNTR TO SYM PAR DICT ENTRIES\n$LMXPTSV EQU *-MXPNTSAV            LEN OF DYNAMIC WORK AREA IN MEXPND\n         SPACE 2\n**-->  DSECT:  MCPAROPR  FORMAT FOR SYMBOLIC PARAMETER DICTIONARY     *\n*.        ENTRY.  ONE ENTRY FOR EACH SYM PARAM ON ENTRY TO MEXPND     *\n*.                                                                    *\n*.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE\nMCPAROPR DSECT\nMCPAROFL DS    C                   OPRNDS FLAGS\nMCPAROLN DS    C                   OPRND LENGTH, IE K'\nMCPARONB DS    C                   # OF SUBOPRNDS IE N'\nMCPAROTP DS    C                   OPRND TYPE, IE N, O OR U\nMCPAROPT DS    F                   POINTER TO OPRND\nMCPRSBPT DS    F                   POINTER TO LSUB OPRND LIST\n$LMPAROP EQU   *-MCPAROPR          LEN OF SYM PAR DICT ENTRY\n         SPACE 2\n**-->  DSECT:  MCPARSUB   FORMAT FOR DICT ENTRY FOR SUBLIST OPRNDS    *\n*.        ONE ENTRY FOR EACH ELEMENT OF SUBLIST OF SYM PARAM ENTRY    *\n*.                                                                    *\n*.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE\nMCPARSUB DSECT\nMCPARSFL DS    C                   SUBOPRND FLAGS\nMCPARSNU DS    C                   NOT USED\nMCPARSTP DS    C                   SUB OPRND TYPE\nMCPARSLN DS    C                   SUB OPRND LENGTH\nMCPARSPT DS    F                   PNTR TO SUB OPRND\n$LMPARSB EQU   *-MCPARSUB          LEN OF SUBLIST OPRND ENTRY\n         AIF   (NOT &$DEBUG).MACDBG          SKIP IF DEBUG\n         XSET  XSNAP=OFF           KILL REMAINING XSANPS\n.MACDBG  ANOP\n         PRINT ON,NOGEN\n         TITLE '*** MACINT - MACRO INITIALIZATION ROUTINE'            S\n**--> CSECT:  MACINT    THIS ROUTINE IS CALLED IN INITIALIZATION      *\n*.       PHASE OF ASSIST.  IT PERFORMS CERTAIN REQUIRED STORAGE       *\n*.       ALLOCATION AND SETS POINTERS AVGEN1CD AND AVGEN2CD.          *\n*.       OVERFLOW MESSAGE FOR GENERAL USE IS ALSO CREATED.            *\n*.                                 G.M.CAMPBELL - SUMMER - 1972       *\n*.                                                                    *\n*.       USES MACROS:  $ALLOCL, $SAVE, $RETURN, $CALL                 *\n*.        USES DSECTS: AVWXTABL                                       *\n*.                                                                    *\n*.       REGISTER USAGE:                                              S\n*.             WORK REGS:  RA,RB                                      S\n*.                                                                    *\n*.*********************************************************************\n         SPACE\nMACINT   CSECT\n         $DBG  ,NO\n          $SAVE                    SA=NO\n         USING AVWXTABL,RAT        NOTE MAIN TABLE USING\n         MVI   AVMSNBY1,X'FF'      TURN OFF SNAPS                     S\n         MVI   AVMSNBY2,X'FF'      TURN OFF SNAPS                     S\n         AIF   (&$DEBUG).MACINT1   SKIP IF  IF NOT DEBUG\n         MVI   AVMSNBY1,X'00'      CLEAR SNAP BYTE 1\n         MVI   AVMSNBY2,X'00'      CLEAR SNAP BYTE 2\n         XSNAP LABEL='***MACINT ENTERED***',IF=(AVMSNBY1,O,$MSNP01,TM)\n.MACINT1 ANOP\n         MVC   AVMBYTE1(4),AWZEROS   CLEAR FLAGS\n         LA    RA,AVMWRK1+255      GET UPPER LIMIT OF WORK AREA1\n         ST    RA,AVMWRKL1         SAVE IN MAIN CONTROL AREA\n         LA    RA,AVMWRK2+255      GET WORK AREA2 LIMIT\n         ST    RA,AVMWRKL2         SAVE IN MAIN CONTROL AREA\n         SPACE 2\n         XC    AWZEROS(256),AWZEROS    ZERO TABLE                     S\n         TM    AVTAGSM,AJOMACRO    MACRO OPTION USED?\n         BZ    MACINTRT            RETURN IF NOT\n         SPACE 1\n*        CONSIDER MODIFYING CODE FOR LIST HANDLING ********************\n         LA    RB,$LMACLIB+$LGLBENT+$LCHWRK   TOTAL WORKAREA LENGTH   J\n         $ALLOCL  RA,RB,MCINITOV   GET DUMMY AREA FOR MACLIB\n         ST    RA,AVMACLIB         STORE @ IN MAIN TABLE\n         MVC   0($LMACLIB+$LGLBENT,RA),AWZEROS  ZERO MAC,GBLX TABLES  A\n         USING MACLIB,RA           NOTE USING ON MACLIB ENTRY\n         OI    MCLBTAGS,AVMCLBDF   SET DEFINED FLAG ON DUMMY\n         DROP  RA\n*              SPACE FOR 1 DUMMY MCGLBDCT.                            J\n         LA    RA,$LMACLIB(,RA)    BUMP PTR BEYOND MACRO ENTRY        J\n         ST    RA,AVMGDICT         STORE @ IN MAIN TABLE\n         SPACE 1                   REMV OLD MVC                       J\n*              BUMP, POINT AT $LCHWORK BYTES FOR CHARACTER WORKAREA.  J\n         LA    RA,$LGLBENT(,RA)    BUMP PTR BEYOND GBLX ENTRY         J\n         ST    RA,AVMCHSTR         SAVE @ IN AVWXTABL\n         LA    RA,$LCHWRK-1(RA)    GET @ OF LAST BYTE\n         ST    RA,AVMCHLIM         SAVE @ IN AVWXTABL\n         LA    RA,MCINITOV         GET @ OF OVRFLW ROUTINE\n         ST    RA,AVMOVRFL         SAVE IN AVWXTABL\n         MVC   AVMACNST,AWZEROS    INIT NEXTING COUNT TO ZERO\n         MVC   AVMMACID,AWZEROS    INITIALIZE MACRO ID TO ZERO\n         ZAP   AVMSYSDX,AWP0       INIT SYSNDX TO ZERO\nMACINTRT EQU   *\n         MVC   AVGEN1CD,AVADDHIH   INIT EXPANSION POINTER 1\n         MVC   AVGEN2CD,AVADDHIH   INIT EXPANSION POINTER 2\n         XSNAP LABEL='***MACINT EXITED*** ',IF=(AVMSNBY1,O,$MSNP01,TM)\n         $RETURN  SA=NO\n         SPACE 2                                                      S\n**--> INSUB: MCINITOV       OVERFLOW ROUTINE + + + + + + + + + + + + +S\n*+       CALLED BY ANY ROUTINE WHEN STORAGE OVERFLOW OCCURS.         +S\n*+       -- TERMINATES SECOND PASS                                   +S\n*+                                                                   +S\n*+       USES MACROS:  $SPIE,$CALL                                   +S\n*+       EXIT CONDITIONS:  PROGRAM MARKED NON-EXECUTABLE             +S\n*+       CALLED BY:  MACRO1,MCGTEST,MCBODY, AND MCGNCD               +S\n*+                                                                   +S\n*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +S\n         SPACE 2                                                      S\nMCINITOV EQU   *                   PROGRAM EXITS TO HERE IF OVERFLOW\n         BALR  R15,0               **KLUDGE** NONSTANDRD BR'S *********\n         USING *,R15               SHOULD HAVE THIS USING\n*        **WARNING** MACRO1 & MEXPND CANNOT BOTHE BE ACTIVE FOR THIS.\n         L     R1,AVMBSPIE         GET @ LAST PREVIOUS SPIE BLK\n         OI    AVTAGS2,AJOASTOP    STOP 2ND PASS PROCESSING\n         $SPIE ACTION=(RS,(1))     RESTORE PREVIOUS PTR\n         $CALL MOSTOP              GO TO MOSTOP TO QUIT\n         LTORG\n         DROP  RAT,R15\n         TITLE '***  MACRO1 - MAIN ROUTINE FOR MACRO DEFINITION'\n**-->  CSECT:  MACRO1   CALLED BY MAIN CONTROL WHEN MACRO OPCODE      *\n*.        ENCOUNTERED.  AT PRESENT (DEC 31, 1971) ONLY MACRO          *\n*.        DEFINITIONS ARE ALLOWED, NO CONDITIONAL ASSEMBLY.  MACRO1   *\n*.        CREATES ENTRY IN MACLIB FOR FUTURE EXPANSION BY MEXPND      *\n*.        ENTRY CONDITIONS                                            *\n*.     RA = SCAN POINTER @ OF OPERAND                                 *\n*.     RC = @ OPCODTB ENTRY FOR OPERATION                             *\n*.                                                                    *\n*.        CALLS MACSCN,OUTPT2,MACFND,ERRTAG,ERRLAB,MCVSCN,MCSCOP,     *\n*.              MCBODY                                                *\n*.        USES MACROS: $SAVE,$RETURN,$CALL,$ALLOCL                    *\n*.        USES DSECTS: RSBLOCK,OPCODTB,AVWXTABL,MACLIB,MCPARENT       *\n*.                                                                    *\n*.       REGISTER USAGE:                                              S\n*.             WORK REGS: R0,R1,R2,RA,RB,RD,RE                        S\n*.             BASE REGS: RAT,RW,RX,RY,R13,RC                         S\n*.             UNUSED: RZ                                             S\n*.                                                                    S\n*.*********************************************************************\n         XSET  XSNAP=OFF                                              A\n         SPACE\nMACRO1   CSECT\n         $SAVE RGS=(R14-R6),SA=*,BR=13\n         USING AVWXTABL,RAT        NOT MAIN TABLE USING\n         XSNAP LABEL='***MACRO1 ENTERED***',IF=(AVMSNBY1,O,$MSNP02,TM)\n         L     RW,AVRSBPT          GET @ OF SOURCE STATEMENT\n         USING RSBLOCK,RW          ESTAB BASE FOR SOURCE\n         USING OPCODTB,RC          ESTAB BASE FOR OPCODE ENTRY\n         AIF   (&$DEBUG).MACQQ00   SKIP IF NO DEBUF\n         $SPIE ,,ACTION=CR,CE=MCBSPIEP\n         ST    R1,AVMBSPIE         SAVE PREV INT @\n.MACQQ00 ANOP\n         LA    RA,RSBSOURC         SET SCAN POINTER\n         LR    R0,RC               SAVE RC ACROSS MACSCN CALL         A\n         $CALL MACSCN              SCAN SOURCE STATEMENT FOR FIELDS\n         LR    RC,R0               RESTORE RC                         A\n         L     RA,AVMFLD2          GET OPCODE ADDRESS\n         CLI   OPCHEX,$MACRO       OPCODE=MACRO?\n         BNE   MACR1R01            ERROR IF NOT\n         TM    AVPRINT1,AVPRSAVE   AFTER START STMNT OR EQUIV?\n         BO    MACR1R01            ERROR IF YES\n         AIF   (NOT &$MACOPC).MAC1A  BRANCH IF NO OPEN CODE           S\n         TM    AVMTAG00,AVMNOMAC   MACROS ALLOWED?                    S\n         BO    MACR1R01            MACROS NOT ALLOWED                 S\n.MAC1A   ANOP                                                         S\n         CLI   AVMFLDT1,X'00'      LABEL PRESENT?\n         BE    MACRO101            OK IF NOT\n         LA    RB,$ERILLAB         SET ERROR FLAG IF YES\n         $CALL ERRLAB              MARK STATEMENT\nMACRO101 EQU   *\nMCR1PRNT EQU   *\n         LA    RB,$OUCOMM          SET PRINT FLAG\n         $CALL OUTPT2              PRINT STATEMENT\n         MVC   AVMBYTE1(3),AWZEROS CLEAR ALL FLAGS\n         L     RA,AVMMACID         GET PREV MACRO ID\n         LA    RA,1(RA)            INCREMENT BY ONE\n         ST    RA,AVMMACID         RESTORE CURRENT ID\n*\n*  NEXT SECTION READS AND PROCESSES THE PROTOTYPE STATEMENT\n*\n         BAL   RET,MACRORD         READ PROTOTYPE STMT\n         LA    RA,RSBSOURC         SET SCAN POINTER TO ASTART\nMACPROT1 EQU   *\n         $CALL  MACSCN              SCAN SOURCE FOR FIELDS\n         CLI   AVMFLDT2,C'I'       OPCODE = MACRO INSTRUCTION?\n         BNE   MACR1DUM            IF ERR-BRANCH-BAD PROTOTYPE        S\n*                                                                     S\n*        IMPROPER PROTOTYPE STMT FOUND OR PREVIOUSLY DEFINED MACRO-   S\n*        ERROR FLAGS SET AND UNIQUE NAME INSERTED.                    S\n*                                                                     S\n*                                                                     S\n*        SCAN MACRO LIBRARY FOR MACRO NAME --                         S\n*              PREVIOUSLY DEFINED FLAGGED AS ERROR                    S\n*              NOT PREVIOUSLY DEFINED ==> OK                          S\n*                                                                     S\nMACPROT2    EQU   *\n         SR    RE,RE               ZERO RE FOR EX USE\n         IC    RE,AVMFLDL2         GET LENGTH OF SYMBOL\n         BCTR  RE,0                DECR LENGTH FOR EX INST\n         MVC   AVMSYMBL,AWBLANK    BLANK OUT COMMON SYMBOL FIELD\n         L     RA,AVMFLD2          MOVE @ OPCODE TO SCAN PNTR\n         EX    RE,MCMVSYM          MOVE SYMBOL INTO AVMSYMBL FOR SEARCH\n         MVC   AVMSYMLN(1),AVMFLDL2 MOVE SYMBOL LENGTH INTO COMMON AREA\n         L     RC,AVMACLIB         GET @ OF MACRO LIBRARY\n         USING MACLIB,RX           SET USING FOR MACLIB ENTRY\n         $CALL MACFND              SEARCH MACRO LIBRARY FOR SYMBOL\n         LTR   RB,RB               ALREADY THERE?\n         BNZ   MACPROT3            IF NOT, ENTER\n         LR    RX,RC               MOVE BASE TO RX\n         TM    MCLBTAGS,AVMCLBDF   PREVIOUSLY DEFINED?\n         BNO   MACPROT4            NO, JUST MARK DEFINED NOW          S\n         SPACE 1                                                      S\n*              EITHER INCORRECT OR DUPLICATE MACRO NAME - GET @       S\n*              OF DUMMY MACLIB HAVING X'00' AS MACRO NAME (ALWAYS     S\n*              POINTED TO BY AVMACLIB - THIS DUMMY IS REUSED FOR ALL  S\n*              SUCH ERRONEOUS MACROS.  ALSO FLAG ERROR.               S\nMACR1DUM LA    RB,$ERILMNM         DUPLICATE/BAD MACRO NAME           S\n         L     RA,AVMFLD2          GET @ OF OPCODE                    S\n         $CALL ERRTAG              CALL ERROR FLAGGING                S\n         L     RX,AVMACLIB         GET @ OF DUMMY ELEMENT             S\n         MVC   MCLBFLG2($LMACLIB-(MCLBFLG2-MACLIB)),AWZEROS   RECLEAR S\n         B     MACPROT4            AND PROCEED\n*                                                                     S\n*        MACRO NAME DEFINED AND ENTERED IN LIBRARY, SPACE ALLOCATED   S\n*                                                                     S\nMACPROT3 EQU   *\n         LR    RX,RC               MOVE LIB ENTRY PNTR TO RX\n         LA    RE,$LMACLIB         GET LENGTH OF MACRO LIN ENTRY\n         $ALLOCL RD,RE,MCOVRPR     GET AREA FOR NEW ENTRY\n         ST    RD,MCLIBNXT         SAVE @ OF NEW ENTRY IN PREV ENTRY\n         LR    RX,RD               MOVE BASE TO RD\n         MVC   MACLIB($LMACLIB),AWZEROS   ZERO NEW ENTRY\n         MVC   MCLBNMLN(9),AVMSYMLN  MOVE NAME INTO LIBRARY\n         SPACE\n*   MACLIB ENTRY ESTABLISHED.  &SYSECT, &SYSNDX AND &SYSLIST ARE NEXT\n*   ENTERED IN PARAMETER LIST\n         SPACE\nMACPROT4 EQU   *\n         OI    MCLBTAGS,AVMCLBDF   SET DEFINED FLAG\n         USING MCPARENT,RY         SET USING FOR PARAM ENTRY\n         LA    RE,(MACSVAR#+1)*$LPARENT   GET SLOTS FOR SYSTEM        A\n         $ALLOCL  RY,RE,MCOVRPR     GET SPACE FOR ENTRY\n         MVC   MCPARNLN(MCPARNTL),MACSVAR1   MOVE &SYSECT ENTRIES     J\n         LA    R1,AVSYSECT         GET @ OF CURRENT CSECT NAME\n         ST    R1,MCPROPRN         SAVE IN ENTRY\n         ST    RY,MCPARPNT         SAVE POINTER IN MACLIB ENTRY\n         LA    RC,$LPARENT(,RY)    @ OF NEXT ENTRY                    A\n         ST    RC,MCPARNXT         SAVE POINTER IN PREV ENTRY\n         LR    RY,RC               MOVE BASE TO NEW ENTRY\n         MVC   MCPARNLN(MCPARNTL),MACSVAR2   MOVE &SYSNDX ENTY        J\n         MVC   MCPROPRN,AWZEROS    SET POINTER TO ZERO\n         LA    RC,$LPARENT(,RC)    @ OF NEXT ENTRY                    A\n         ST    RC,MCPARNXT         SAVE POINTER IN PREV ENTRY\n         LR    RY,RC               MOVE AASE TO NEW ENTRY\n         MVC   MCPARNLN(MCPARNTL),MACSVAR3   MOVE &SYSLIST ENTRY      J\n         SPACE\n*    SYSTEM VARIABLES ENTERED IN PARAM LEST.  NEXT GET LABEL IF ANY\n         SPACE\n         LA    RC,$LPARENT(,RC)    @ OF NEXT ENTRY\n         ST    RC,MCPARNXT         SAVE LINK IN PREV ENTRY\n         LR    RY,RC               MOVE BASE TO NEW ENTRY\n         MVC   MCPARENT($LPARENT),AWZEROS ZERO OUT ENTRY\n         L     RA,AVMFLD1          GET @ OF LABEL, IF ANY\n         LTR   RA,RA               IS THERE A LABEL\n         BZ    MCPARSCN            IF NOT, PROCEED WITH OPERAND SCAN\n         $CALL MCVSCN              ELSE SCAN LABEL FIELD\n         LTR   RB,RB               VARIABLE SYMBOL?\n         BZ    MCLAB01             OKAY IF RB = 0\n         LA    RB,$ERINVSY         ELSE FLAG INVALID SYMBOL\nMACLABER EQU   *\n         $CALL ERRLAB              FLAG ERROR\n         B     MCPARSCN            RESUME SCAN AFTER FLAGGING ERROR\n         SPACE\nMCMVSYM  MVC   AVMSYMBL($),0(RA)   DUMMY FOR EX INST TO MOVE SYMBOL\n         SPACE\n*                                                                     S\n*        SCAN FOR &LABEL -- IF NOT MULTIPLY DEFINED ENTER IN          S\n*        PARAMETER LIST                                               S\n*                                                                     S\nMCLAB01  EQU   *\n         L     RC,MCPARPNT         GET @ OF PARAM LIST\n         $CALL MACFND              SCAN LIST\n         LTR   RB,RB               NAME ALREADY PRESENT\n         BNZ   MCLAB02             OKAY IF NONZERO\n         LA    RB,$ERMULDF         ELSE SET MULTIPLE DEF FLAG\n         B     MACLABER            BRANCH AND FLAG ERROR\nMCLAB02   EQU  *\n         MVC   MCPARNLN(9),AVMSYMLN       MOVE LABEL NAME INTO ENTRY\n         MVI   MCPARTYP,C'P'       SET ENTRY TYPE TO POSITIONAL\n         SPACE\n*  START SCAN OF PARAMETER OPERAND FIELD\n         SPACE\nMCPARSCN CLI   AVMFLDL3,X'00'      OPERAND PRESENT?\n         BE    MACRO1RT            IF NOT, FINI\n         L     RA,AVMFLD3          ELSE GET @ OF OPERAND IN SCAN PNTR\n         SPACE 2                                                      S\n*        BEGIN LOOP TO SCAN MACRO PARAMETER LIST                      S\n         SPACE 1                                                      S\nMCPARST  EQU   *\n         LR    R0,RA               COPY SCAN POINTER TEMPORRARILY\n         $CALL MCVSCN              SCAN NEXT SYMBOL\n         LTR   RB,RB               VAR SYMBOL OK?\n         BZ    MCPRSC01            IF YES, PROCEED\n         LA    RB,$ERINVSY         IF RB ^= 0, ILLEGAL                S\n         B     MACR1TG1            FLAG STNT\n         SPACE\n*        HAVE LEGAL PARAMETER -- SCAN, DETERMINE TYP) AND INSERT      S\n*                                                                     S\nMCPRSC01 EQU   *\n         CLI   0(RA),C'='          KEYWORD PARAMETER?\n         BE    MCPRSC11            IF YES, OKAY\n         TM    AVMBYTE1,$MKEYOPR   KEYWORD ALREADY PROCESSED?\n         BO    MACR1R03            ERROR IF YES\n***************  POSSIBLE CHANGE FOR ASM H OR VS  ***************     S\n*                                                                     S\n*        LEGAL PARM FOUND -- INSERT IF NOT DUPLICATE                  S\n*                                                                     S\nMCPRSC11 EQU   *\n         ST    RA,AVMTSCNP         SAVE SCAN POINTER TEMPORARILY\n         L     RC,MCPARPNT         GET @ OF PAR LIST\n         $CALL MACFND              SEARCH PARAMETER LIST\n         LTR   RB,RB               SYMBOL ALREADY PRESENT?\n         BNZ   MCPRSC02            IF NOT, OKAY\n         LR    RA,R0               RESTORE SCAN POINTER FOR ERROR MSG\nMCPRSCMD LA    RB,$ERMULDF         SET MULT DEF FLAG\n         B     MACR1TG1            BRANCH AND FLAG STMT\n*\n*        ALLOCATE SPACE FOR PARM ENTRY, CHACK TYPE AND BUMP COUNTERS  S\n*                                                                     S\nMCPRSC02 LA    RE,$LPARENT         GET LENGTH OF PAR ENTRY\n         $ALLOCL R1,RE,MCOVRPR     GET AREA FOR NEW ENTRY\n         ST    R1,MCPARNXT         PUT POINTER IN PREV ENTRY\n         LH    R2,MCPARNDX         GET CURRENT OPERAND COUNT\n         LR    RY,R1               MOVE BASE TO NEW ENTRY\n         MVC   MCPARENT($LPARENT),AWZEROS   CLEAR ENTRY\n         MVC   MCPARNLN(9),AVMSYMLN     MOVE SYMBOL INTO NIE ENTRY\n         LA    R1,1(R2)            BUMP OPERAND COUNT BY ONE\n         STH   R1,MCPARNDX         RESTORE NEW COUNT\n         STH   R1,MCPOPRNB         UPDATE TOTAL NBR OF OPRNDS\n         L     RA,AVMTSCNP         RESTORE SCAN POINTER\n         CLI   0(RA),C'='          KEYWORD PARAMETER?\n         MVI   MCPARTYP,C'P'       ELSE SET TYPE = POSITIONAL\n         BNE   MCPRSC06            JUMP OUT IF POSITIONAL             A\n         SPACE\n*        KEYWORD PARM FOUND -- PROCESS ACCORDINGLY                    S\n*                                                                     S\nMCPRSCK  LA    RA,1(RA)            BUMP SCAN PNTR PAST '='\n         MVI   MCPARTYP,C'K'       IDENTIFY AS KEYWORD OPERAND\n         ST    RA,AVMTSCNP         SAVE SCAN PNTR TEMPORARILY\n         NI    AVMBYTE1,X'FF'-$MSBLIST  TURN OFF SUBLIST FLAG\n         OI    AVMBYTE1,$MKEYOPR   SET KEYWORD OPRND FLAG\n         $CALL MCSCOP              SCAN OPERAND\n         LTR   RB,RB               OPERAND OK?\n         BNZ   MACR1TG1            IF NOT, BRANCH AND FLAG\n         STC   RD,MCPRATYP         SAVE ATTRIBUTE TYPE\n         STC   RC,MCPROPLN         STORE LENGTH\n         LH    RE,MCKOPRNB         GET KEYWORD COUNT\n         LA    RE,1(RE)            BUMP KEYWORD COUNT\n         STH   RE,MCKOPRNB         RESTORE NEW COUNT\n         LTR   RC,RC               CHECK FOR NULL STRING\n         BZ    MCPRSC03            IF YES, GO TO NEXT OPERAND\n         LA    RE,3+1(,RC)         ROUND TO FULLWORD+1 FOR DELIM AFTERJ\n         SRL   RE,2                SHIFT RIGHT TO TRUNCATE 2 BITS\n         SLL   RE,2                SHIFT LEFT TO RESTORE\n         $ALLOCL RB,RE,MCOVRPR     GET AREA FOR KEYWORD VALUE\n         ST    RB,MCPROPRN         SAVE STND VALUE @ IN ENTRY\n*              OMIT  BCTR RC,0 : USE LENG RATHER THAN LENG-1, SO WILL J\n*              PICK UP DELIMITER AFTER VALUE.  HELPS MEXPND SCAN OK   J\n         L     RE,AVMTSCNP         RESTORE SCAN POINTER FOR OPRND MOVE\n         EX    RC,MCMVOPRN         MOVE KEYWORD VALUE INTO ENTRY\n*                                                                     S\n*        PROCESS SUBLISTED PARAMETERS                                 S\n*                                                                     S\nMCPRSC03 EQU   *\n         CLI   MCPRATYP,C'S'       SUBLIST?\n         BNE   MCPRSC06            PROCEED IF NOT\n         LR    R0,RA               COPY SCAN PNTR\n         L     RA,AVMTSCNP         GET ORIGINAL SCAN PNTR\n         LA    RA,1(RA)            BUMP PAST '('\n         OI    AVMBYTE1,$MSBLIST   SET SUBLIST FLAG\n*                                                                     S\n*        BEGIN LOOP TO PROCESS SUBOPERANDS                            S\n*                                                                     S\nMCPRSC05 EQU   *\n         $CALL MCSCOP              SCAN SUBOPRND\n         LTR   RB,RB               OKAY?\n         BNZ   MACR1TG1            IF NOT, BRANCH AND FLAG\n         CLI   0(RA),C')'          END OF SUBLIST?\n         LA    RA,1(RA)            BUMP PAST DELIM\n         BNE   MCPRSC05            RESUME SCAN IF NOT END\n         LR    RA,R0               ELSE RESTORE SCAN PNTR\n*                                                                     S\n*        DELIMETER CHECK                                              S\n*                                                                     S\nMCPRSC06 EQU   *\n         CLI   0(RA),C' '          END OF OPERAND?\n         BE    MACRO1RT            BRANCH AND PRINT IF YES\n         CLI   0(RA),C','          DELIM = ','?\n         BE    MCPRBMP             OK IF YES\n         LA    RB,$ERINVDM         ELSE SET BAD DELIM FLAG\n         B     MACR1TG1            BRANCH AND FLAG\nMCPRBMP  EQU   *\n         LA    RA,1(RA)            BUMP SCAN POINTER\n         CLI   0(RA),C' '          BLANK AFTER ','?\n         BNE   MCPARST             RESUME SCAN IF NOT\n         SPACE 1\n*        POSSIBLE NON-STD CONT CARDS -- MACROS ONLY                   S\n         CLI   RSBNUM,1            ONLY 1 CARD?\n         BE    MCPARST             RESUME SCAN IF YES\n         LA    RB,RSBLOCK+RSB$L+RSOL1  POINT TO 1ST BYTE, 2ND CARD\n         CR    RA,RB               POINTING AT WHICH CARD?\n         BNH   MCPRCO#2            PROCESS 2ND CARD IF LOW\n         CLI   RSBNUM,3            TWO CONT CARDS?\n         BNE   MCPARST             RESUME SCAN IF NOT\n         LA    RB,RSOLC(RB)        POINT TO 1ST BYTE, 3RD CARD\n         CR    RA,RB               WHERE IS SCAN POINTER?\n         BH    MCPRCO#3            CHECK FOR 4TH CARD\nMCPRCO#2 EQU   *\n         LR    RA,RB               MOVE SCAN POINTER TO CONT CARD\n         B     MCPARST             GO BACK FOR NEXT OPRND\n         SPACE 2\nMCPRCO#3 EQU   *\n         CLI   AVMBYTE5,$ERCONTX   MORE THAN THREE CARDS?\n         BNE   MCPARST             RESUME SCAN IF NOT\n         LA    RB,$OUCOMM          SET PRINT FLAG\n         $CALL OUTPT2              PRINT STMT\n         BAL   RET,MACRORD         GET NEXT STMT\n         OI    RSBFLAG,$RSBNPNN    SET NO ACTION FLAG\n         LA    RA,RSBSOURC         POINT TO START OF STMT\n         CLC   0(15,RA),AWBLANK    ALL BLANKS IN COL 1-15?\n         BE    MCPRCO#4            OKAY IF YES\n         LA    RB,$ERCONT          ELSE SET ERROR FLAG\n         $CALL ERRTAG              FLAG STMT\nMCPRCO#4 EQU   *\n         LA    RA,15(RA)           BUMP SCN PNTR TO COL 16\n         B     MCPARST             AND RESUME SCAN\nMCMVOPRN MVC   0($,RB),0(RE)       DUMMY FOR EX INSTR TO MOVE OPRND   S\n         SPACE 2\n**--> INSUB: MACRORD       MACRO READER  + + + + + + + + + + + + + + +S\n*+       CALLED BY MACRO1 THREE PLACES:                              +S\n*+             1ST TO READ PROTOTYPE STMT                            +S\n*+             2ND TO CHECK FOR CONT CARDS (MACRO)                   +S\n*+             3RD TO GET NEXT CONT CARD (NON-MACRO)                 +S\n*+       ENTRY CONDS:                                                +S\n*+             RETURN POINT = RET                                    +S\n*+       EXIT CONDS:                                                 +S\n*+             AVMBYTE5 (ERROR FLAG) SET IF MORE THAN ALLOWED        +S\n*+             CONTINUATION CARDS  (LIMIT = 3)                       +S\n*+       CALLS:  INCARD TO ACTUALLY READ CARDS                       +S\n*+               ERRTAG FOR ERROR PROCESSING                         +S\n*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +S\n         SPACE 2                                                      S\nMACRORD  EQU   *\n         ST    RET,MACRDSAV        SAVE RETURN @\n         $CALL INCARD              READ NEXT STMT\n         STC   RB,AVMBYTE5         SAVE ERROR FLAG\n         CLI   AVMBYTE5,$ERCONTX   MORE THAN THREE CARDS?\n         BE    MACRDRTN            PROCEED IF YES\n         LTR   RB,RB               ELSE TEST FOR OTHER ERROR\n         BZ    MACRDRTN            RETURN IF NONE\n         $CALL ERRTAG              ELSE FLAG STMT\n         TM    AVTAGS2,$INEND2     END OF FILE ERROR?\n         BO    MACRO1RT            RETURN IF YES\nMACRDRTN EQU   *\n         L     RET,MACRDSAV        RESTORE RETURN @\n         BR    RET                 AND RETURN\nMACRDSAV DS    F                   SPACE FOR RETURN @\n         SPACE 4\n*        ERROR ROUTINE CALLED WHEN ERROR FOUND IN MAC DEF             S\n*                                                                     S\nMACR1R01 EQU   *\n         AIF   (NOT &$MACOPC).MAC1B  BRANCH IF NO OPEN CODE           S\n         EJECT                                                        S\n*        MAIN CONTROL BLOCK FOR OPEN CODE CONDITIONAL ASSEMBLY        S\n*                                                                     S\n*              REGISTER USAGE FOR THIS SECTION:                       S\n*                                                                     S\n*              R0  - WORK REG                                         S\n*              R1  - PTR TO CONTROL TABLE AND TRT REG                 S\n*              R2  - PTR TO CONTROL TABLE                             S\n*              RW  - BASE FOR RSBLOCK                                 S\n*              RX  - BASE FOR MACLIB                                  S\n*              RY  - UNUSED (BUT --> BASE FOR MCPARENT IN MACRO1)     S\n*              RZ  - BASE FOR MXPNTSAV AND WORK REG                   S\n*              RA  - WORK REG                                         S\n*              RB  - BASE FOR MCLCLDPV AND WORK REG                   S\n*              RC  - BASE FOR OPCODTB AND WORK REG                    S\n*              RD  - UNUSED                                           S\n*              RE  - UNUSED                                           S\n*              RAT - BASE FOR AVWXTABL                                S\n*              R13 - BASE FOR THIS CSECT --> MACRO1                   S\n*                                                                     S\n         OI    AVMTAG00,AVMNOMAC   FLAG => NO MORE MACROS             S\n         SR    R1,R1               CLEAR FOR TABLE INDEX              S\n         IC    R1,OPCHEX           GET OPCODE INDEX                   S\n         LA    R1,MC1CONTB(R1)     LOAD @ OF TABLE ENTRY              S\n         L     RX,AVMACLIB         GET @ OF OPEN CODE MACLIB          S\n*        SET UP MACLIB ENTRY AND LOCAL DICTIONARY DUMMY ENTRY,        S\n*        IF NOT ALREADY DONE                                          S\n         TM    AVMTAG00,AVMOPMIN   IS LOCAL DUMMY BUILT ?             S\n         BO    MC1CLMCB            BRANCH IF YES                      S\n         L     RD,AVMMACID         INCRESE MACID                      A\n         LA    RD,1(RD)            INCREASE BY ONE                    A\n         ST    RD,AVMMACID         STORE IT BACK                      A\n         MVC   MACLIB+4($LMACLIB-4),AWZEROS  ZERO OUT MACLIB ENTRY    S\n         MVC   MCLBNMLN(9),MC1OPNCD  ENTER NAME AND LENGTH INTO MACLIBS\n*        ALLOCATE CORE FOR LOCAL DUMMY ENTRY (SEE MCBODY START)       S\n         LA    RA,$LLCLDV+$LGLBENT GET LENGTH OF DICTS                A\n         USING MCLCLDPV,RB         NOTE USING ON LOCAL DICT DOPE VECT S\n         $ALLOCH  RB,RA,MC1OVRFL   GET AREA FOR ENTRY                 S\n         ST    RB,MCDDVPNT         SAVE @ IN MACLIB                   S\n         MVC   0($LLCLDV+$LGLBENT,RB),AWZEROS   CLEAR ENTRY           A\n         MVI   MCLCLTYP,$ARITH     SET TYPE = ARITH FOR LENGTH        S\n         MVI   MCLCLDIM+1,1        SET DIMENSION TO 1                 S\n         DROP  RB                                                     S\n         MVI   MCLOCDLN+3,4        INIT LENGTH OF DICT TO 4           S\n         OI    AVMTAG00,AVMOPMIN+AVMNOMAC   SET FLAGS                 A\n         OI    MCLBFLG2,$MCOCFL1   SHOW OPEN CODE                     A\n         XSNAP LABEL='AFTER OPEN MACLIB',STORAGE=(*MACLIB,*MACLIB+100),X\n               IF=(AVTAGSM,O,AJOMACRH,TM)                             A\nMC1CLMCB EQU   *                                                      S\n         XSNAP LABEL='MCICLMB,R1 TABLE ENTRY'                         A\n         TM    0(R1),$MC1DCL       DECLARE TYPE OPCODE ?              S\n         BNO   MC1ACTON            NO, ACTION TYPE                    S\n         TM    AVPRINT1,AVPRSAVE   LISTING CONTROL = SAVE ?           S\n         BO    MC1NORM             BRANCH IF YES                      S\n         TM    MCLBFLG2,$MCOCFL2   DECLARE TYPE ALLOWED ?             S\n         BO    MC1NORM             NO, OUT OF ORDER                   S\n         OI    AVMTAG00,AVMOPENC   SET FLAG TO SHOW IN OPEN           A\n         LR    RC,RX               COPY @ MACLIB WHERE EXPECTED       J\n         $CALL MCBODY              PROCESS STATEMENT                  S\n         B     MC1RTN0             RETURN, RB=0                       S\n*        ACTION TYPE MACRO OPCODE PROCESSED BELOW                     S\nMC1ACTON EQU   *                                                      S\n         XSNAP LABEL='ACTION TYPE FOUND'                              A\n         TM    0(R1),$MC1ERR       ERROR FLAG ON ?                    S\n         BO    MC1NORM             BRANCH IF YES                      S\n         OI    MCLBFLG2,$MCOCFL2   DECLARE TYPES NO LONGER ALLOWED    S\n         TM    AVMTAG00,AVMOPDIC   HAS OPEN CODE LOCAL DICT BEEN      S#\n                                   ALLOCATED ?                        S\n         BO    MC1SAVLO            BRANCH IF YES                      S\n*        ALLOCATE SPACE FOR OPEN CODE LOCAL DICTIONARY AND MXPNTSAV   S\n         L     RA,MCLOCDLN         GET LENGTH OF LOCAL DICT           S\n         LA    RA,$LMXPTSV(RA)     ADD LENGTH OF MXPNTSAV             S\n         $ALLOCH RB,RA,MC1OVRFL    GET CORE FOR LOCAL DICT            S\n*        INITIALIZE LOCAL DICTIONARY AND MXPNTSAV TO ZEROS            S\n         ST    RB,MC1PTSAV         SAVE POINTER TO ALLOCATED CORE     S\n         LR    R0,RA               COPY OVER LENGTH FOR LATER USE     J\n         BCTR  RA,0                DECR COUNT                         S\n         EX    RA,MC1MOVZR         CLEAR LENGTH MOD 256               S\n         SRA   RA,8                SHIFT TO GET # 256 BYTE BLOCKS LEFTS\n         BNP   MC1DNZER            SKIP IF NO MORE TO DO              S\n         N     R0,AWFXFF      REMOVE ALL BUT LAST BYTE OF LENGTH      J\n         AR    RB,R0               ADD LENGTH, GET @ FIRST BYTE TO 0  J\n         MVC   0(256,RB),AWZEROS   CLEAR 256 BYTES AT A TIME          S\n         LA    RB,256(,RB)         INCMT TO NEXT BLOCK                S\n         BCT   RA,*-10             LOOP, CLEAR TILL DONE              S\n*        SET UP MXPNTSAV AND SET ACTR LIMIT                           S\nMC1DNZER EQU   *                                                      S\n         USING MXPNTSAV,RZ         BASE REG FOR MXPNTSAV              S\n         L     RZ,MC1PTSAV         BASE REG FOR MXPNTSAV              S\n         ST    RX,MXPNMCLB         STORE @ OF MACLIB ENTRY            A\n         LA    RB,$LMXPTSV(RZ)     GET ADDR OF LOCAL DICTIONARY       S\n         ST    RB,MXPNLDBS         SAVE @ IN MXPNTSAV                 S\n         MVC   0(4,RB),AVMMACTR    SET ACTR LIMIT                     S\n         OI    AVMTAG00,AVMOPDIC   FLAG => DICT ALLOCATED             S\n*        CALL MCBODY TO CREATE ONE-OPS.  IF NO ERROR ON RETURN,       S\n*        CALL MXINST TO INTERPRET THE ONE-OPS.  OTHERWISE RETURN.     S\nMC1SAVLO EQU   *                                                      S\n         MVC   MC1LOPTR(4),AVADDLOW  SAVE CURRENT LO PTR              S\n         LR    RC,RX               COPY @ MACLIB WHERE EXPECTED       J\n         XSNAP LABEL='BEFORE CALL MCBODY OC',                          X\n               IF=(AVTAGSM,O,AJOMACRH,TM)                             A\n         L     RD,AVADDHIH         GET HIGH PTR                       A\n         LR    RE,RD               COPY INTO RE                       A\n         STM   RD,RE,AVGEN1CD      STORE INTO AVGEN1DC,AVGEN2DC       A\n         $CALL MCBODY              PROCESS STATEMENT                  S\n         L     RA,MCCODLNK         GET # FIRST INSTRUCTION            A\n         USING MCOPQUAD,RA         NOTE ONE/OP PTR                    A\n         CLI   MCQS1FLG,$BSERR01   WAS IT IN ERROR                    A\n         BNE   *+8                 SKIP AROUND RESET IF O.K.          A\n         LA    R1,=AL1($MC1SKIP,$MC1RET)  FAKE NO MORE ACTION         A\n         NI    AVMTAG00,255-AVMOPGO  TURN OFF AIF/AGO FLAG (AVMOPGO)  S\n         TM    0(R1),$MC1SKIP      IS SKIP BIT ON ? (SKIP MXINST)     S\n         BO    MC1RSTLO            IF YES, SKIP CALL TO MXINST        S\n         L     RC,MC1PTSAV         LOAD @ OF MXPNTSAV                 S\n         USING MXPNTSAV,RC          SET UP ANOTHER USING              Z\n         MVC   MXPNCRCD(4),MCCODLNK  LOAD @ OF UST INSTR              A\n         DROP  RZ,RC,RA                                               A\n         XSNAP LABEL='BEFORE CALL TO MXINST'                          A\n         XCALL MXINST              CALL TO INTERPRET ONE-OPS          S\n         L     RD,AVGEN1CD                                            A\n         L     RE,AVADDHIH                                            A\n         XSNAP LABEL='AFTER MXINST',STORAGE=(*0(RD),*4(RD),*0(RE),*4(REX\n               ))                                                     A\n*        WIPE OUT ONE-OPS AND RETURN IF DONE                          S\nMC1RSTLO EQU   *                                                      S\n         MVC   AVADDLOW(4),MC1LOPTR  RESTORE AVADDLOW                 S\n*              IF ORIGINAL STATEMENT NOT ALREADY PRINTED, GET IT      A\n*              BACK FROM HIGH AREA AND SAVE IT VIA UTPUT1             A\n         TM    AVPRINT1,AVPRSAVE   ALREADY IN SAVE MODE               A\n         BZ    MC1ALPRT            NO, SO PRINTED STMT ALREADY        A\n         $CALL INCARD              GET STMT BACK                      A\n         OI    RSBFLAG,$RSBNP##    SHOW NO MORE PROCESSING            A\n         $CALL UTPUT1              HAVE IT SAVED                      A\nMC1ALPRT TM    0(R1),$MC1RET       IS RETURN BIT ON ?                 S\n         BO    MC1RTN0             BRANCH IF YES                      S\n*        PROCESS AIF, AGO AND ANYTHING ELSE NEEDING ACTION            S\n         SR    R2,R2               CLEAR R2 FOR INDEX                 S\n         IC    R2,1(R1)            LOAD JUMP CODE FROM CONTROL TABLE  S\n         B     *+4(R2)             BRANCH ON INDEX                    S\n         B     MC1AGO              BRANCH TO PROCESS AGO              S\n         TM    AVMTAG00,AVMOPGO    WAS AIF SUCCESSFUL ?               S\n         BNO   MC1RTN0             NOT SUCCESSFUL SO RETURN           S\n*        AGO OR SUCCESSFUL AIF -- CHECK FOR ILLEGAL BACKWARD REFERENCES\nMC1AGO   EQU   *                                                      S\n         LA    RA,AVMSYMBL         LOAD @ OF SEQ SYMBOL               S\n         SR    RB,RB               CLEAR RB FOR LENGTH-1 IF SYMBOL    S\n         IC    RB,AVMSYMLN         LOAD LENGTH-1                      S\n         STC   RB,MC1CLC1+1        STORE LENGTH IN CLC INSTR          S\n         LA    RB,1(RB)            ADD 1 TO GET LENGTH                S\n         LR    RZ,RB               COPY LENGTH FOR LATER              S\n         $CALL SYFIND              LOOK UP SEQ SYMBOL                 S\n         B     *+4(RB)             BRANCH ON RETURNED INDEX           S\n         B     MC1SEQDF            BRANCH IF PREVIOUSLY DEFINED       S\n*        SEQ SYMBOL NOT PREVIOUSLY DEFINED -->                        S\n*        READ CARDS UNTIL SEQ SYMBOL OR END-OF-FILE FOUND             S\nMC1READ  EQU   *                                                      S\n         $CALL INCARD              READ NEXT SOURCE CARD              S\n         TM    AVTAGS2,$INEND2     END-OF-FILE ?                      S\n         BO    MC1EOF              BRANCH IF YES                      S\n         CLI   RSBLOPC,C'.'        IS THIS A SEQ SYMBOL?              S\n         BNE   MC1READ             IF NOT, READ NEXT CARD             S\n         LA    RA,RSBSOURC         @ 1ST BYTE OF CARD                 S\n         $SETRT  (' ',4)           STOP TRT ON BLANK                  S\n         TRT   1(8,RA),AWTZTAB     SCAN FOR BLANK                     S\n         $SETRT  (' ',0)           REZERO TABLE                       S\n         BZ    MC1READ             INVALID SEQ SYM -- IGNORE          S\n         LR    RB,R1               @ OF BLANK                         S\n         SR    RB,RA               GET LENGTH                         S\n         CR    RB,RZ               IS IT = ONE WE WANT ?              S\n         BNE   MC1AGOSY            NO, BUT SHOW DEFINED               S\nMC1CLC1  CLC   AVMSYMBL($),0(RA)   COMPARE SYMBOLS                    S\n         BE    MC1RTN4             SEQ SYM FOUND -- RETURN            S\nMC1AGOSY $CALL SYENT1              ENTER SEQ SYM IN TABLE             S\n*        IF WANTED, COULD SEE IF PREVIOUSLY DEFINED - WE IGNORE IT    S\n         B     MC1READ             GO FOR NEXT CARD                   S\n*        SEQUENCE SYMBOL PREVIOUSLY DEFINED -->                       S\n*        (AS242 -- BACKWARDS AIF/AGO IN OPEN CODE)                    S\nMC1SEQDF EQU   *                                                      S\n         MVC   AVRSBLOC(MC1MSEQU),MC1MSSG   MOVE ERROR MSG INTO       S#\n                                   RSBLOCK  (AS242)                   S\n         B     MC1RTN4             RETURN                             A\n*        END-OF-FILE ENCOUNTERED BEFORE SEQ SYMBOL FOUND -->          S\n*        (AS241 - SEQUENCE SYMBOL NOT FOUND)                          S\nMC1EOF   EQU   *                                                      S\n         MVC   AVRSBLOC(MC1MSEQ2),MC1MSSG2  MOVE ERROR MSG INTO RSB   S\n*        RETURN SHOWING NEXT SOURCE ALREADY IN RSBLOCK                S\nMC1RTN4  EQU   *                                                      S\n         LA    RB,4                SET RETURN CODE                    S\n         B     MACRO1FN            RETURN                             S\n*        RETURN SHOWING NEXT SOURCE NOT IN RSBLOCK                    S\nMC1RTN0  EQU   *                                                      S\n         SR    RB,RB               CLEAR FLAG REGISTER                S\n         B     MACRO1FN            BRANCH TO RETURN                   S\n*                                                                     S\n*        OVERFLOW EXIT  --  HALT ASSEMBLY                             S\n*                                                                     S\nMC1OVRFL EQU   *                                                      S\n         OI    AVTAGS2,AJOASTOP    STOP 2ND PASS PROCESSING           S\n         $CALL MOSTOP              GO TO MOSTOP TO QUIT               S\n*                                                                     S\n*        MACRO1 DC/DS/DUMMYS FOR OPEN CODE                            S\nMC1MOVZR MVC   0($,RB),AWZEROS     DUMMY INSTR                        S\nMC1LOPTR DC    F'0'                WORD TO SAVE CURRENT AVADDLOW      S\nMC1PTSAV DC    F'0'                WORD TO SAVE PTR TO MXPNTSAV       S\nMC1MSSG  DC    AL1(MC1MSEQU,$RSBNPNN+$RSBMERR,1,0)                    A\n         DC    C'242 BACKWARDS AIF/AGO ILLEGAL'                       S\nMC1MSEQU EQU   *-MC1MSSG                                              S\nMC1MSSG2 DC    AL1(MC1MSEQ2,$RSBNPNN+$RSBMERR,1,0)                    A\n         DC    C'241 SEQUENCE SYMBOL NOT FOUND'                       S\nMC1MSEQ2 EQU   *-MC1MSSG2                                             S\nMC1OPNCD DC    X'08',CL8'OPEN-CDE'                                    S\n         EJECT                                                        S\n*        MACRO1 CONTROL TABLE FOR OPEN CODE CONDITIONAL ASSEMBLY      S\n*                                                                     S\n*              THE FIRST BYTE CONTAINS FLAG BITS;                     S\n*              BYTE 2 CONTAINS JUMP CODES                             S\n         SPACE 2                                                      S\nMC1CONTB EQU   *                                                      S\n         DC    AL1($MC1RET,0)          NON-MACRO STMT                 S\n         DC    AL1($MC1ERR,0)          MACRO                          S\n         DC    AL1($MC1DCL,0)          GBLA                           S\n         DC    AL1($MC1DCL,0)          GBLB                           S\n         DC    AL1($MC1DCL,0)          GBLC                           S\n         DC    AL1($MC1DCL,0)          LCLA                           S\n         DC    AL1($MC1DCL,0)          LCLB                           S\n         DC    AL1($MC1DCL,0)          LCLC                           S\n         DC    AL1($MC1RET,0)          ACTR                           S\n         DC    AL1($MC1RET,0)          SETA                           S\n         DC    AL1($MC1RET,0)          SETB                           S\n         DC    AL1($MC1RET,0)          SETC                           S\n         DC    AL1(0,4)                AIF                            S\n         DC    AL1($MC1SKIP,0)         AGO                            S\n         DC    AL1($MC1SKIP+$MC1RET,0) ANOP                           S\n         DC    AL1($MC1RET,0)          MNOTE                          S\n         DC    AL1($MC1ERR,0)          MEXIT                          S\n         DC    AL1($MC1ERR,0)          MEND                           S\n         DS    0H                  ALIGN IF NECESSARY                 S\n         EJECT                                                        S\nMC1NORM  EQU   *                                                      S\n.MAC1B   ANOP                                                         S\n         L     RA,AVMFLD2          GET @ OF OPCODE                    S\nMACR1LAB LA    RB,$ERSTMNA         SET CODE / USE WHATEVER @ IN RA    S\nMACR1TAG $CALL ERRTAG              SET FLAG\n         LA    RB,8                SET PROPER RETURN CODE\n         B     MACRO1FN\n*        ERROR ROUTINE CALLED WHEN POSITIONAL PARAM FOUND AFTER       S\n*        KEYWORD PARAM                                                S\n***************  POSSIBLE CHANGES WITH ASM H OR VS  ***************   S\n*                                                                     S\nMACR1R03 EQU   *\n         LA    RB,$ERVSYNT         SE T SYNTAX ERROR FLAG\n         B     MACR1TG1            FLAG STMT\nMCOVRPR  L     RE,AVMOVRFL         GET @ OF OVERFLOW ROUTINE\n         BR    RE                  BRANCH THERE\n         SPACE 4\n*        GENERAL ROUTINE TO FLAG INCORRECT PARAM FIELDS               S\n*                                                                     S\nMACR1TG1 EQU   *\n         $CALL ERRTAG              FLAG STMT\n         SPACE 2\n*        CHECK FOR END OF PROTOTYPE AND CALL ROUTINE TO PROCESS       S\n*        BODY OF MACRO  (MCBODY)                                      S\n*                                                                     S\nMACRO1RT EQU   *\n         LA    RB,$OUCOMM\n         $CALL OUTPT2\n         CLI   AVMBYTE5,$ERCONTX   MORE THAN THREE CARDS?\n         BNE   MACRO1RU            PROCEED IF NOT\n         BAL   RET,MACRORD         ELSE GET NEXT STMT\n         OI    RSBFLAG,$RSBNPNN    SET NO ACTION FLAG\n         B     MACRO1RT            AND PRINT LINES\nMACRO1RU EQU   *\n         LR    RC,RX\n         SR    RB,RB\n         TM    AVTAGS2,$INEND2     END OF FILE?\n         BO    MACRO1FN            RETURN IF YES\n         $CALL MCBODY              PROCESS BODY OF DEFINIETION\nMACRO1FN EQU   *\n         AIF   (&$DEBUG).MACROFN   SKIP OVER DEBUG CODE IF NOT NEEDED J\n         L     R1,AVMBSPIE\n         $SPIE ,,ACTION=(RS,(1))   TURN OFF SPIE\n         L     R1,AVADDLOW         GET @ OF START OF DYNAMIC AREA\n         XSNAP LABEL='DYNAMIC AREA',STORAGE=(*0(RX),*0(R1),*AVADDLOW,*AX\n               VWXEND),IF=(AVMSNBY1,O,$MSNP02,TM)\n.MACROFN ANOP\n         $RETURN  RGS=(R14-R6)\n         AIF   (&$DEBUG).MACQQ01   SKIP IF NO DEBUG\n         USING MCBSPIEP,R15\nMCBSPIEP EQU   *\n         L     RC,AVMACLIB         GET PONTR TO LOW ENDOF LOW CORE\n         L     RD,AVADDLOW        GET HIGH END OFLOW CORE\n         XSNAP LABEL='*** INTERRUPT IN MACRO DEFINITION PHASE ***',    #\n               STORAGE=(*0(R1),*16(R1),*0(RC),*0(RD),*AVADDLOW,*AVWXEND#\n               )\n         DC    H'1'                FORCE INTERRUPT\n         DROP  R15\n.MACQQ01 ANOP\n         DROP  RAT,RW,RX,RY,R13                                       A\n         LTORG\nMACSVAR# EQU   3                   ACTUAL # SYSTEM VARIABLES          J\n*              SYSTEM VARIABLES - VALUES FOR MCPAR- NLN,NAM,TYP.      J\nMACSVAR1 DC    AL1(7),CL8'&&SYSECT ',C'S'                             J\nMACSVAR2 DC    AL1(7),CL8'&&SYSNDX ',C'S'                             J\nMACSVAR3 DC    AL1(8),CL8'&&SYSLIST',C'S'                             J\n         TITLE '*** MACSCN - MACRO STATEMENT SCAN ***'\n**-->  CSECT: MACSCN   SCANS MACRO INSTRUCTION STATEMENT. IDENTIFIES  *\n*.        LABEL, OPCODE, OPERAND AND COMMENT (IF ANY) FIELDS.         *\n*.        LOCATION OF EACH FIELD STORED IN AVMFLD_.  LENGTH OF EACH   *\n*.        FIELD STORED IN AVMFLDL_.  TYPE OF EACH FIELD PLACED IN     *\n*.        AVMFLDT_.  FIELDS ARE SET TO ZERO IF NOT PRESENT.           *\n*.        AVMFLDT1 CONTAINS '&' IF VARIABLE SYMBOL AND '.' IF SEQUENCE*\n*.        SYMBOL ELSE ZERO.  AVMFLDT2 CONTAINS 'I' IF OPCODE IS       *\n*.        SUSPECTED MACRO INSTRUCTION, 'M' IF MACRO OPCODE (AIF,      *\n*.        AGO, SETA, ETC), 'O' IF OPCODE IS REGULAR ASSEMBLER OR      *\n*.        MACHINE INSTRUCION AND X'00' IF ANYTHING ELSE.              *\n*.        SCANS NON STND CONTINUATION FILDS AND PLACES VALUES IN      *\n*.        AVMFLD5 THRU AVMFLD8                                        *\n*.                                                                    *\n*.        ENTRY CONDITIONS                                            *\n*.     RA = @ OF FIRST CAHARACTER OF STATEMENT                        *\n*.        EXIT CONDITIONS                                             *\n*.     RA = SAME AS ENTRY CONDITIONS                                  *\n*.     RB = 4 IF COMMENT STATEMENT, 8 IF MACRO COMMENT, ELSE ZERO     *\n*.     RC = @ OF OPCODTB ENTRY IF OPCODE = M OR O                     *\n*.                                                                    *\n*.        USES MACROS: $CALL, $SAVE, $RETURN, $SETRT                  *\n*.        USES DSECTS: AVWXTABL, OPCODTB                              *\n*.       CALLS ERRTAG,MCATRM,OPFIND                                   S\n*.   NAMES: MAC----- OR MC------                                      S\n*.             BASE REGS:  R13,RAT,RX,RC                             S*\n*.             WORK REGS:  R1,R2,RA,RB,RW,RZ                         S*\n*.*********************************************************************\n         SPACE 2\n* * * * * REGISTER USAGE IN MACSCN  * * * * * * * * * * * * * * * * * S\n*   R0 = SAVE REGISTER FOR RETURN @ IN MACSCSTR  *2ND MINIMAL USED*  J*\n*   R1 = TRT USAGE; ADDRESS REGISTER (HI-ORDER BYTE = 0).            J*\n*   R2 = BYTE REGISTER (HI-ORDER 3 BYTES = 0); TRT USAGE.            J*\n*   RW = PARENTHESES LEVEL COUNT IN SECTION MACSCSTR                 J*\n*   RX = @ RSBLOCK BEGIN SCANNED                                     J*\n*   RY = 1 FOR SCANNING USAGE (BXH, ETC)                             J*\n*   RZ = SAVE REG FOR OPCODTB PTR  * MINIMAL-USED REGISTER           J*\n*   RA = SCAN POINTER                                                J*\n*   RB = RETURN CODE USAGE                                           J*\n*   RC,RD,RE  = PARAMETER REGISTERS FOR EXTERNAL ROUTINES.           J*\n*   R13 = SAVE AREA PTR; BASE REGISTER                               J*\n*   R13= BASE REGISTER, SAVE AREA PTR.                               J*\n*   RET,REP=  USUAL LINKAGE, INCLUDING INTERNAL LINKAGE              J*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * S\n         EJECT                                                        S\nMACSCN   CSECT\n         $SAVE RGS=(R14-R6),SA=*,BR=13\n         USING AVWXTABL,RAT        SET MAIN CONTROL TABLE USING\n         XSNAP LABEL='***MACSCN ENTERED***',IF=(AVMSNBY1,O,$MSNP03,TM)\n         MVC   AVMFLD1($LAVMFLD),AWZEROS  CLEAR FIELD POINTERS\n         SR    RB,RB\n         LM    R1,R2,AWZEROS       CLEAR R1 AND R2 FOR TRT INST\n         ST    RA,AVMTSCNP         SAVE SCAN POINTER TEMPORARILY\n*\n         LA    RY,1                SET UP USEFUL VALUE FOR SCANNING   J\n*   CHECK FOR PRESENCE OF COMMENT STATEMENT\n*\n         CLI   0(RA),C'*'          REGULAR COMMENT?\n         BNE   MCMNT01             IF NOT, JUMP\n         LA    RB,4                ELSE SET COMMENT STMNT FLAG\n         B     MCSCNRT             AND RETURN\nMCMNT01  CLC   0(2,RA),=C'.*'      MACRO COMMENT?\n         BNE   MACLABSC            IF NOT, JUMP AND START SCAN\n         LA    RB,8                ELSE SET MACRO COMMENT FLAG\n         B     MCSCNRT             AND RETURN\n*\n*   SET UP TRT TABLE TO SCAN FOR DELIMITERS\n*\nMACLABSC $SETRT  (' ',4,'(',8,')',12,'''',16)\n         SPACE 2\n*        START SCAN FOR LABEL -- DETERMINE TYPE (VAR,SEQ OR NORMAL)   S\n*        AND PROCESS ACCORDINGLY                                      S\n*                                                                     S\n         CLI   0(RA),C' '          LABEL PRESENT?\n         BE    MACOPCSC            IF BLANK, JUMP AND SCAN OPCODE\n         ST    RA,AVMFLD1          ELSE SAVE LABEL @\n         CLI   0(RA),C'&&'         VAR SYMBOL?\n         BE    MACSCN02            IF YES, SCAN REST OF SYMBOL\n         CLI   0(RA),C'.'          SEQ SYMBOL?\n         BE    MACSCN02            IF YES, JUMP AND SCAN REST OF SYMBOL\n         SPACE 2\nMACSCN01 BAL   RET,MACSCSTR        BRANCH AND SCAN STRING\n         B     MACSCN03\n         SPACE 2\n*        SCAN VAR OR SEQ SYMBOL -- SETS AVMFLDT1 TO PROPER TYPE       S\n*                                                                     S\nMACSCN02 CLI   1(RA),C'0'          FIRST CHAR IS A LETTER?\n         BNL   MACSCN01            NOT ORD. SYMBOL IF NOT\n         TRT   1(8,RA),AWTSYMT     SCAN SYMBOL\n         BZ    MACSCN01            NOT SYMBOL, 9+ CHARS, RESUME SCAN\n         CLI   0(R1),C' '          DELIM = BLANK?\n         BNE   MACSCN01            NO SYMBOL IF NOT\n         MVC   AVMFLDT1(1),0(RA)   SAVE TYPE\n         LR    RA,R1               UPDATE SCAN POINTER\n         SPACE 2\n*        COMPUTE AND STORE CHARACTER LENGTH                           S\n*                                                                     S\nMACSCN03 S     RA,AVMFLD1          GET LENGTH OF FIELD\n         STC   RA,AVMFLDL1         SAVE LENGTH\n         A     RA,AVMFLD1          RESTORE SCAN POINTER\n*\n*    SCAN FOR START OF OPCODE\n*\nMACOPCSC BAL   RET,MACSCBLN        SCAN FOR NON BLANK\n         ST    RA,AVMFLD2          SAVE @ OF OPCODE\n         USING OPCODTB,RC          ESTAB BASE FOR OPCODE ENTRY\n         $CALL OPFIND              LEGAL OPCODE?\n         LTR   RB,RB               YES IF RB = 0\n         BNZ   MACSCN04            IF NOT TREAT AS STRING\n         LR    RZ,RC               COPY OPCODTB @ TEMPORARILY\n         IC    R2,OPCTYPE          GET TYPE                           J\n         SRL   R2,6                REMOVE ALL BUT 1ST 2 BITS          J\n         IC    R2,MACSTAB1(R2)     GET TYPE: 'O' OR 'M' OF OPCODE     J\n         STC   R2,AVMFLDT2         SAVE THE TYPE VALUE FOR LATER USE  J\n         B     MACSCN06\nMACSTAB1 DC    AL1(C'O',C'O',C'M',C'O')  OPCODE TYPE TABLES           J\n         ORG   *+0*($IA+$IS+$IM+$IB)  REFER TO TYPES FOR XREF         J\n         SPACE 2\nMACSCN04 CLI   0(RA),C'0'          FIRST CHAR < 0?\n         BNL   MACSCN07            NO SYMBOL IF NOT\n         TRT   0(9,RA),AWTSYMT     SCAN SYMBOL\n         BZ    MACSCN07            9+ CHARS IF ZERO\n         CLI   0(R1),C' '          DELIM = BLANK?\n         BNE   MACSCN07            NO SYMBOL IF NOT\n         MVI   AVMFLDT2,C'I'       SET MACRO INSTRUCTION FLAG\n         LR    RA,R1               MOVE SCAN POINTER\n         B     MACSCN06            BRANCH TO GET LENGTH\n         SPACE 2\nMACSCN07 BAL   RET,MACSCSTR        SCAN OPCODE STRING\nMACSCN06 S     RA,AVMFLD2          GET LENGTH OF OPCODE\n         STC   RA,AVMFLDL2         SAVE LENGTH\n         A     RA,AVMFLD2          RESTORE SCAN POINTER\n*\n*   NEXT SECTION FINDS AND SCANS OPERAND FIELD\n*\n         L     RX,AVRSBPT          POINT TO RSBLOCK\n         USING RSBLOCK,RX          SET USING ON RSBLOCK\n         BAL   RET,MACSCOPR        SCAN OPRND FIELD\n         MVC   AVMFLD3(5),MACSCNFD MOVE DATA TO FIELD PNTRS\n         BAL   RET,MACSCHEK        CHECK FOR NON STND CONT CARD\n         BAL   RET,MACSCMMT        SCAN COMMENT FIELD\n         MVC   AVMFLD4(5),MACSCNFD MOVE DATE TO FIELD PNTRS\n         BAL   RET,MACSCOPR        SCAN NEXT OPRND(IF PRESENT)\n         MVC   AVMFLD5(5),MACSCNFD MOVE DATA TO FIELD PNTRS\n         BAL   RET,MACSCHEK        CHECK FOR 1 MORE NON STND CARD\n         BAL   RET,MACSCMMT        SCAN COMMENT\n         MVC   AVMFLD6(5),MACSCNFD   MOVE DATA TO FIELD PNTRS\n         BAL   RET,MACSCOPR        SCAN 3RD OPRND(IF ANY)\n         MVC   AVMFLD7(5),MACSCNFD   MOVE DATA TO FIELD PNTRS\n         L     RB,AVSOLAST         SET EOR @ FOR LAST COMMENT\n         BCTR  RB,0                DECR FOR TRUE LENGTH\n         BAL   RET,MACSCMMT        SCAN COMMENT\n         MVC   AVMFLD8(5),MACSCNFD  MOVE DATA TO FIELD PNTRS\n         B     MCSCNFT             AND FINI\n         SPACE 2\n**--> INSUB: MACSCOPR       FIND AND SCAN OPERAND + + + + + + + + + ++S\n*+       THIS ROUTINE FINDS, SCANS, GETS ADDR AND LENGTH OF THE      +S\n*+       OPERAND FIELD                                               +S\n*+                                                                   +S\n*+       EXIT CONDS:  ADDR & LENGTH ARE PLACED IN APPROPRIATE        +S\n*+                    PLACES IN TABLE.                               +S\n*+                                                                   +S\n*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +S\n         SPACE 2                                                      S\nMACSCOPR EQU   *\n         ST    RET,MACSCSAV        SAVE RETURN @\n         BAL   RET,MACSCBLN        SCAN FOR NONBLANK\n         ST    RA,MACSCNFD         SAVE @ OF OPRND\n         BAL   RET,MACSCSTR        SCAN OPRND\n         S     RA,MACSCNFD         SUBTRACT START @\n         STC   RA,MACSCNFL         SAVE LENGTH\n         A     RA,MACSCNFD         RESTORE POINTER\n         L     RET,MACSCSAV        RESTORE RETURN @\n         BR    RET                 AND RETURN\n         SPACE 2\n**--> INSUB: MACSCMMT       SCAN COMMENT FIELD + + + + + + + + + + + +S\n*+       THIS ROUTINE SCANS FOR NON-BLANK, CHECKS FOR CARD           +S\n*+       OVERRUN.  IF OK, SAVES @ AND LENGTH OF FIELD.               +S\n*+                                                                   +S\n*+       EXIT CONDS:  ADDR & LENGTH ARE PLACED IN APPROPRIATE        +S\n*+                    PLACES IN TABLE.                               +S\n*+                                                                   +S\n*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +S\n         SPACE 2                                                      S\nMACSCMMT EQU   *\n         ST    RET,MACSCSAV        SAVE RETURN @\n         MVC   MACSCNFD(6),AWZEROS   ZERO POINTER STORAGE\n         BAL   RET,MACSCBLN        SCAN FOR NON BLANK\n         CR    RA,RB               COMPARE WITH END OF RECORD\n         BNL   MACSCMRT            RETURN IF IN NEXT CARD IMAGE\n         ST    RA,MACSCNFD         ELSE SAVE @\n         SR    RB,RA               GET LENGTH\n         STC   RB,MACSCNFL         SAVE LENGTH\n         AR    RA,RB               BUMP SCN PNTR TO BLNK BEYOND CMMT\nMACSCMRT EQU   *\n         L     RET,MACSCSAV        GERT RETRUN @\n         BR    RET                 AND RETURN\nMACSCSAV DS    F                   STORAGE FOR RETURN @\nMACSCNFD DS    F                   TEMP STRORAE FOR LOCATION PNTR\nMACSCNFL DS    C                   TEMP STROAGE FOR FIELD LENGTH\nMACSCNTY DS    C                   TEMP STRGE FOR FIELD TYPE\n         SPACE 2\n**--> INSUB: MACSCHEK       CHECK FOR NON-STD COND CARD  + + + + + + +S\n*+       CHECKS FOR MACRO PROTOTYPE CONTINUATION CARDS (UP TO 3)     +S\n*+                                                                   +S\n*+       EXIT CONDS:  RB = PTR SET TO:                               +S\n*+             1.  LAST CHAR ON ORIGINAL CARD (NOT CONTINUATION)     +S\n*+             2.  1ST BYTE ON 2ND OR 3RD CARD (NON-STD CONT)        +S\n*+                                                                   +S\n*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +S\n         SPACE 2                                                      S\nMACSCHEK EQU   *\n         L     RB,AVSOLAST         GET EOR @\n         BCTR  RB,0                DECR TO BLANK PAST LAST CHAR\n         BCTR  RA,0                DECR SCAN POINTER\n         CLI   0(RA),C','          STOP ON ','?\n         LA    RA,1(RA)            RESTORE SCAN POINTER\n         BCR   NE,RET              NOT NON-STND IF NO COMMA\n         CLI   AVMFLDT2,C'I'       POSSIBLE MACRO CALL?\n         BCR   NE,RET              ALSO RETURN IF NOT\n         LA    RB,RSBLOCK+RSB$L+RSOL1  POINT TO 1ST BYTE, 2ND CARD\n         CR    RA,RB               COMPARE WITH SCAN POINTER\n         BCR   NH,RET              RETURN IF NOT HIGH\n         LA    RB,RSOLC(RB)        ELSE BYMP RB TO 3RD CARD\n         CR    RA,RB               COMPARE SCAN PONTR AGAIN\n         BCR   NH,RET              RETURN IF NOT HIGH\n         L     RB,AVSOLAST         ELSE LOAD EOR @\n         BCTR  RB,RET              DECREM TO 1ST BLANK, BRANCH ALWAYS J\n         DROP  RX\n         SPACE 2\n**--> INSUB: MACSCBLN       SCAN FOR NON-BLANK CHAR  + + + + + + + + +S\n*+       SCANS FOR NON-BLANK CHAR WITHOUT CARD OVERRUN               +S\n*+                                                                   +S\n*+       ENTRY COND:  RA = @ WHERE SCAN TO BEGIN                     +S\n*+       EXIT COND:  RA = @ OF 1ST NON-BLANK OR                      +S\n*+                        @ OF END OF RECORD                         +S\n*+                                                                   +S\n*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +S\n         SPACE 2                                                      S\nMACSCBLN EQU   *                   SCAN FOR NON-BLANK                 S\nMACBLN01 CLI   0(RA),C' '          BLANK?\n         BNE   MACBLN02            IF NOT, NON BLANK FOUND\n         BXH   RA,RY,MACBLN01      ELSE TRY AGAIN                     J\nMACBLN02 C     RA,AVSOLAST         END OF RECORD?\n         BNL   MCSCNFT             IF YES, SCAN FINI, RETURN\n         BR    RET                 ELSE RESUME STMNT SCAN\n         EJECT                                                        S\n**--> INSUB: MACSCSTR       SCAN ARBITRARY STRING  + + + + + + + + + +S\n*+       THIS SECTION IS A ROUTINE TO SCAN AN ARBITRARY              +S\n*+       STRING AND RETURN THE LENGTH.  SCAN PTR IS LEFT             +S\n*+       AT BLANK FOLLOWING STRING.                                  +S\n*+                                                                   +S\n*+       ENTRY COND:  RA = @ OF BEGINNING OF STRING                  +S\n*+                                                                   +S\n*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +S\n         SPACE 2                                                      S\nMACSCSTR EQU   *\n         LR    R0,RET              COPYRETURN @\n         SR    RW,RW               CLEAR RW FOR PAREN COUNT\n         NI    AVMBYTE1,X'FF'-$MINQUOT   CLEAR QUOTE FLAG\n         SPACE 2\nMACSTRT  EQU   *\n         TRT   0(200,RA),AWTZTAB   SCAN STRING\n         B     *(R2)               BRANCH INTO TABLE FOR ROUTINE\n         B     MCSCBLNK\n         B     MCSCLPAR\n         B     MCSCRPAR\n         B     MCSCQUOT\n         SPACE 2\nMCSCBLNK TM    AVMBYTE1,$MINQUOT   INSIDE QUOTE?\n         BO    MCSCBLOK            IF YES, PROCEED\n         LTR   RW,RW               INSIDE PARENS?\n         BP    MCSCBLOK            IF YES, PROCEED\n         LR    RA,R1               ELSE UPDATE SCAN POINTER\n         LR    RET,R0              RESTORE RETURN @\n         BR    RET                 AND RETURN TO STMNT SCAN\n         SPACE 2\nMCSCLPAR AR    RW,RY               = LA RW,1(RW) BUMP PAREN COUNTER   J\n         B     MCSCBLOK            GO TO BUMP SCAN PTR & CONTINUE     S\n         SPACE 2\nMCSCRPAR EQU   *\n         BCTR  RW,0\nMCSCBLOK LA    RA,1(,R1)           BUMP SCAN PTR TO NEXT CHAR         S\n         B     MACSTRT             RESUME SCAN\n         SPACE 2\nMCSCQUOT C     R1,AVSOLAST         END OF RECORD?\n         BNL   MCSCQU01            BRANCH AND PROCESS ERROR IF YES\n         CLI   1(R1),C''''         TWO QUOTES?\n         BE    MCSCQTWO            IF YES, JUMP AND PROCEED\n         LR    RA,R1               MOVE SCAN POINTER\n         TM    AVMBYTE1,$MINQUOT    ARE WE IN SIDE QUOTED STRING?\n         BO    MCSCQTRT            IF YES, DON'T LOOK FOR ATTRIBUTE\n         BCTR  RA,0                DEC POINTER FOR ATTERM\n         TRT   0(1,RA),AWTSYMT     IS PREV CHAR ALPHA?\n         BNZ   MCSCNOAT            IF NOT CAN'T BE ATTRIBUTE\n         $CALL MCATRM              IS IT AN ATTRIBUTE?\n         LTR   RB,RB               ATTRIBUTE IF RB=0\n         BZ    MACSTRT             IF YES THEN RESUME SCAN\n         BP    MCSCQTWO            IF ATTRIB NOT IMPLEMENTED RESUME SCA\nMCSCNOAT AR    RA,RY               = LA RA,1(RA) RESTORE POINTER      J\n         TM    AVMBYTE1,$MINQUOT   ARE WE INSIDE QUOTES?\n         BO    MCSCQTRT            IF YES RESET TRT TABLE\n         $SETRT ('(',0,')',0,' ',0)  ELSE TURN OFF TRT FOR QUOTE STRNG\n         B     MCSCQUFT\nMCSCQTRT $SETRT (' ',4,'(',8,')',12)  RESET TRT FOR END OF QUOTE STRNG\nMCSCQUFT XI    AVMBYTE1,$MINQUOT   FLIP QUOTE FLAG\n         BXH   RA,RY,MACSTRT       BUMP SCAN PTR, BRANCH ALWAYS       J\nMCSCQTWO LA    RA,2(R1)            BUMP SCAN POINTER PAST DOUBLE '\n         B     MACSTRT             RESUME SCAN\n         SPACE 2\nMCSCQU01 EQU   *\n         NI    AVMBYTE1,X'FF'-$MINQUOT   TURN OFF QUOTE FLAG\n         BCTR  R1,0                DEC R1\n         LR    RA,R1               COPY R1 INTO SCAN POINTER\n         LA    RB,$ERNODLM         SET NO DELIM FLAG\n         $CALL ERRTAG              FLAG STATEMENT\n         LA    RB,8                INDICATE MACRO COMMENT\n         B     MCSCNERR            AND RETURN\n         SPACE 4\n*        RETURN SEQUENCE FOR MACSCN -- SETS RETURN CODES              S\n*        AND RESETS TABLES, ETC.                                      S\n*                                                                     S\nMCSCNFT  EQU   *\n         SR    RB,RB               CLEAR RB FOR NORMAL RETURN\nMCSCNERR EQU   *\n         $SETRT  (' ',0,'(',0,')',0,'''',0)    CLEAR TRT TABLE\nMCSCNRT  EQU   *\n         LR    RC,RZ               RESTORE OPCODTB @ TO RC FOR RETURN\n         L     RA,AVMTSCNP         RESTORE SCAN POINTER\n         XSNAP LABEL='***MACSCN EXITED***',IF=(AVMSNBY1,O,$MSNP03,TM), #\n               STORAGE=(*AVMFLD1,*AVMBYTE5)\n         $RETURN  RGS=(R14-R6)\n         DROP  RAT,RC,R13\n         LTORG\n         TITLE '*** MCSCOP - STANDARD VALUE SCANNER ***'\n**-->  CSECT:  MCSCOP   THIS ROUTINE SCANS A MACRO INSTRUCTION        *\n*.        OPERAND.  THE OPERAND MUST CONFORM TO A STANDARD VALUE AS   *\n*.        LAID DOWN IN SECTION 8 OF IBM GC28-2514                     *\n*.                                                                    *\n*.        ENTRY CONDITIONS                                            *\n*.       AVMBYTE1: FLAG $MSBLIST EXPECTED SET IF ALREADY INSIDE SUBLISS\n*.                                                                    *\n*.        EXIT CONDITIONS                                             *\n*.     RA = DELIM PAST OPRND IF STND VALUE ELSE POINTS AT ERROR       *\n*.     RB = 0 IF STANDARD VALUE ELSE $ER MESSAGE                      *\n*.     RC = LENGTH OF OPERAND IF OKAY                                 *\n*.     RD = TYPE OF OPERAND.  IN THIS CASE TYPE WILL BE ONE OF        *\n*.          'O' (NULL), 'N' (SELF-DEFINING TERM) OR 'U' (ALL OTHERS)  *\n*.             CAN BE 'S' AFTER SCANNING   (1ST SUBPOPERAND           S\n*.     RE = VALUE OF SELF DEFINING TERM                               *\n*.       AVMBYTE1: FLAG $MINQUOT HAS INDETERMINATE VALUE.             S\n*.        USES MACROS: $SAVE, $RETURN, $SETRT, $CALL                  *\n*.        USES DSECTS: AVWXTABL                                       *\n*.        CALLS SDBCDX                                                *\n*.                                                                    *\n*.*********************************************************************\n         SPACE 4\n* * * * * * * * * * REGISTER USAGE IN MCSCOP  * * * * * * * * * * * * S\n*   R0 = TEMPORARY SAVE REGISTER FOR SCAN POINTER.                    S\n*   R1 = SCAN POINTER FROM TRT INSTRUCTIONS.                          S\n*   R2 = BYTE REGISTER, TRT USAGE.                                    S\n*   RA = NORMAL SCAN POINTER.                                         S\n*   RB = RETURN CODE REGISTER.                                        S\n*   RC = RETURN LENGTH REGISTER.                                      S\n*   RD = FLAG REGISTER FOR TYPE:  'U', 'N', 'O', OR 'S' .             S\n*   RE = PARENTHESES NEST LEVEL COUNTER;  SELF-DEF TERM VALUE RETURN. S\n*   R13= BASE REGISTER.                                               S\n*   R14= INTERNAL LINK REGISTER.                                      S\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * S\n         SPACE 2                                                      S\nMCSCOP   CSECT\n         $SAVE RGS=(R14-R2),SA=*,BR=13\n         USING AVWXTABL,RAT\n         XSNAP LABEL='***MCSCOP ENTERED***',IF=(AVMSNBY1,O,$MSNP04,TM)\n         NI    AVMBYTE1,X'FF'-$MINQUOT  TURN OFF QUOTE FLAG\n         LA    RD,C'U'             SET UNDEFINED FLAG FOR STARTS\n         BAL   R14,MCSET1          SET TRT TABLE FOR CORRECT SCANNING J\n         SR    RE,RE               USE RE AS PAREN COUNTER\n         SR    R1,R1                                                  A\n         SR    R2,R2               CLEAR R2 FOR TRT USE\n         LR    R0,RA               COPY SCAN POINTER\n         TRT   0(1,RA),AWTDECT     POSSIBLE SDTERM?\n         BZ    MCOPSDTM            DECIMAL TERM IF CC = 0\n         C     R2,AWF4             IS IT B, C OR X?\n         BE    MCOPSDTM            POSSIBLE IF EQUAL TO 4\n         B     MCOPSTRT            SKIP AROUND SCAN POINTER BUMP FIRSTJ\nMCOPSTRS LA    RA,1(,R1)           SET SCAN PTR 1 BEYOND LAST TRT END J\nMCOPSTRT EQU   *\n         TRT   0(200,RA),AWTZTAB   START SCAN\n         B     *(R2)               JUMP TO TABLE OF BRANCHES\n         B     MCOPQUOT\n         B     MCOPLPAR\n         B     MCOPRPAR\n         B     MCOPEQUL\n         B     MCOPAMPR\n         B     MCOPSCFT\n         B     MCOPBLNK\n         SPACE 2\nMCOPQUOT EQU   *                   COME HERE FOR '                    A\n         CLI   1(R1),C''''         TWO QUOTES IN ROW?\n         BE    MCOPQTWO            IF YES, JUMP AN  PROCESS\n         TM    AVMBYTE1,$MINQUOT\n         BO    MCOPINQU\n         LA    R2,2                                                   A\n         SR    R1,R2                                                  A\n         CLI   1(R1),C'L'                                             A\n         BNE   MCOPQU11                                               A\n         TRT   0(1,R1),AWTSYMT     CHACK CHARACTER\n         BZ    MCOPQU11            IF LETTER THEN IS NOT L'\n         TRT   3(1,R1),AWTSYMT     CHAR AFTER L' = ALPHA?\n         BNZ   MCOPQU11            IF NOT, JUMP OUT\n         CLI   3(R1),C'Z'          CHAR GREATER THAN Z?\n         BH    MCOPQU11            IF YES, CANT BE ALPAH\n         CLI   0(R1),C'&&'         IS IT AN AMPERSAND?\n         BE    MCOPQU11            IF YES, NOT L'\n         LA    RA,3(R1)            BUMP SCAN POINTER\n         B     MCOPSTRT            RESUME SCAN\n         SPACE 2\nMCOPQTWO LA    RA,2(R1)            BUMP SCAN POINTER PAST ''\n         B     MCOPSTRT\n         SPACE 2\nMCOPQU11 AR    R1,R2               RESTORE SCAN PTR TO ' FOUND        A\n*   THE $SETRT MACRO IS USED TO CLEAR THE AWTZTAB TABLE FOR SCAN OF\n*   A QUOTED STRING\n         IC    RB,AWTZTAB+C','     SAVE CURRENT COMMA STATUS ACRS '   J\n         BAL   R14,MCSET2A         SET FOR INSIDE QUOTED STRING -ZERO J\n         B     MCOPQU02\n*     WHEN END OF QUOTED STRING HAS BEEN REACHED, AWTZTAB IS RESTORED\n*    SO THAT NORMAL SCAN CAN CONTINUE\nMCOPINQU BAL   R14,MCSET1A         RESET, NO LONGER INSIDE QUOTED STRNJ\n         STC   RB,AWTZTAB+C','     RESTORE ORIGINAL COMMA STATUS      J\nMCOPQU02 XI    AVMBYTE1,$MINQUOT   FLIP QUOTE FLAG\n         B     MCOPSTRS            GO BACK TO INCREMENT PTR AND SCAN  J\n         SPACE 2\nMCOPLPAR CR    R1,R0               BEGINNING OF OPERAND?\n         BNE   MCOPLP01            IF NOT, PROCEED\n         L     RD,=C'   S'         ELSE SET SUBLIST FLAG\nMCOPLP01 LA    RE,1(RE)            BUMP PAREN COUNTER\n         $SETRT (',',0)            COMMAS OK INSIDE PARENS\n         B     MCOPSTRS            GO AND BUMP SCAN PTR BY 1          A\n         SPACE 2\nMCOPRPAR BCT   RE,MCOPRP01         DECR PAREN COUNTER\n         $SETRT (',',24)           RESET TRT TABLE IF ZERO\n         B     MCOPRP02\nMCOPRP01 LTR   RE,RE               TEST PAREN COUNT\n         BNM   MCOPRPFT            IF NOT MINUS, OKAY\n         TM    AVMBYTE1,$MSBLIST   ARE WE IN SUBLIST\n         BO    MCOPSCFT            IF YES, OKAY. END OF SUBLIST\nMCOPRER1 LA    RB,$ERVSYNT        SET SYNTAX ERROR\n         LR    RA,R1               SET SCAN POINTER\n         B     MCOPSCRT\nMCOPRPFT EQU   MCOPSTRS            SAME AS PREVIOUS LABEL: BUMP PTR   J\n         SPACE 2\nMCOPRP02 C     RD,=C'   S'         ARE WE IN SUBLIST?\n         BNE   MCOPRPFT            IF NOT, PROCEED\n         CLI   1(R1),C','          END OF OPERAND?\n         BE    MCOPRPFT            IF YES, PROCEED\n         CLI   1(R1),C' '          END OF OPERAND?\n         BE    MCOPRPFT\n         LA    RD,C'U'             INSERT UNDEFINED FLAG\n         B     MCOPRPFT            CONTINUE SCAN\n         SPACE 4\nMCOPEQUL CR    R1,R0               AT START OF OPERAND?\n         BE    MCOPEQ01            IF YES, OKAY\n         LTR   RE,RE               ELSE ARE WEIN PARENS?\n         BZ    MCOPRER1            ERROR IF NOT\nMCOPEQ01 EQU   MCOPSTRS            SAME AS PREVIOUS LABEL, SKIP THERE J\n         B     MCOPSTRS            BRANCH THERE, IF FLLA THRU HERE    J\n         SPACE 4\nMCOPAMPR CLI   1(R1),C'&&'         TWO AMPERSANDS?\n         BE    MCOPQTWO            IF YES USE DOUBLE QUOTE CODE\n         CR    R0,R1               BEGINNING OF OPERAND?\n         BE    MCOPEQ01            IF YES USE = CODE\n         B     MCOPRER1            ELSE ERROR, USE RPAR CODE\n         SPACE 2\nMCOPSDTM EQU   *\n         $CALL SDBCDX              CALL SELF-DEFINING TERM ROUTINE\n         LTR   RB,RB               WAS IT SD TERM\n         BNZ   MCOPSTRT            JUMP IF NOT REALY SELF-DEF TERM  JRM\n         CLI   0(RA),C','          NORMAL DELIM AFTER SDTERM?\n         BE    MCOPSDT1            PROCEED IF YES\n         CLI   0(RA),C' '          DELIM = ' '?\n         BE    MCOPSDT1            PROCEED IF YES\n         CLI   0(RA),C')'          DELIM IS A ')'?\n         BNE   MCOPSDT2            IF NOT, START SCAN OVER\n         TM    AVMBYTE1,$MSBLIST   SCANNING SUBLIST?\n         BO    MCOPSDT1            RIGHT PAREN OKAY  IF SO\nMCOPSDT2 EQU   *\n         LM    RC,RD,AWZEROS       CLEAR RC, RD AFTER SDDTERM\n         LR    RA,R0               RESTORE SCAN POINTER TO RESUME SCAN\n         B     MCOPSTRT\nMCOPSDT1 EQU   *\n         LR    R1,RA               MOVE SCAN POINTER INTO R1\n         LA    RD,C'N'             SET SELF DEF TERM FLG\n         LR    RE,RC               MOVE VALUE OF SDTERM INTO RE\n         B     MCOPSCFT\n         SPACE 2\nMCOPBLNK EQU   *\n         LTR   RE,RE               ARE WE IN PARENS\n         BZ    MCOPSCFT            IF NOT, FINI\n         LA    RB,$ERNODLM         ELSE SET WRONG DELIM FLAG\n         B     MCOPSCRT            AND RETURN\n         SPACE 4\nMCOPSCFT LR    RA,R1               MOVE SCAN POINTER\n         LR    RC,R1               COPPY POINTER\n         SR    RB,RB               CLEAR RB FOR FLAG USE\n         C     RD,=C'   S'         SUBLIST?\n         BNE   MCOPSCF1            SKIP IF NOT\n         TM    AVMBYTE1,$MSBLIST   IN SUBLIST FLAG ON?\n         BNO   MCOPSCF1            SKIP IF NOT\n         LA    RD,C'U'             ELSE SET UNEFINED FLAG\nMCOPSCF1 EQU   *\n         SR    RC,R0               GET LENGTH OF OPERAND\n         BNZ   MCOPSCRT            JUMP AROUND IN NOT ZERO\n         LA    RD,C'O'             ELSE SET NULL FLAG\nMCOPSCRT BAL   R14,MCSET2          RESET ALL VALUES CHANGED IN TRT TB J\n         XSNAP LABEL='***MCSCOP EXITED*** ',IF=(AVMSNBY1,O,$MSNP04,TM)\n         $RETURN  RGS=(R14-R2)\n         SPACE 2                                                      J\n**--> INSUB: MCSET#     MODIFY TRT TABLE AWTZTAB  + + + + + + + + + + S\nMCSET1   $SETRT ('''',4)       SET TO CATCH ' ,  AND THEN OTHER CHARS J\nMCSET1A  $SETRT ('(',8,')',12,'=',16,'&&',20,',',24,' ',28) OTHER CHRSJ\n         BR    R14                 RETURN TO CALLER                   J\n         SPACE 1                                                      J\nMCSET2   $SETRT ('''',0)           RESET ' TO 0, THEN OTHERS          J\nMCSET2A  $SETRT ('(',0,')',0,'=',0,'&&',0,',',0,' ',0) RESET OTHERS   J\n         BR    R14                 RETURN TO CALLER                   J\n         DROP  RAT,R13\n         LTORG\n         TITLE '*** MACFND - SEARCHES DICTIONARIES FOR VARIABLE ***'\n**-->  CSECT:  MACFND    THIS ROUTINE IS GENERAL SEARCH PROCEDURE     *\n*.        WHICH CAN SCAN THE MACRO LIBRARY, GLOBAL AND LOCAL          *\n*.        DICTIONARIES AND THE SYMBOLIC PARAMETER LIST.  THE CALLING  *\n*.        ROUTINE DETERMINES WHICH LIBRARY BY PLACING THE APPROPRIATE *\n*.        POINTER IN RC.                                              *\n*.                                                                    *\n*.        ENTRY CONDITIONS                                            *\n*.     RC = @ OF FIRST ENTRY OF LIST TO BE SEARCHED                   *\n*.                                                                    *\n*.        EXIT CONDITIONS                                             *\n*.     RB = 0 IF ENTRY IS FOUND                                       *\n*.        = $ERUNDEF IF ENTRY IS NOT FOUND                            *\n*.     RC = @ OF ENTRY IF FOUND ELSE @ OF FINAL ENTRY IF NOT FOUND    *\n*.        USES MACROS: $SAVE, $RETURN                                 *\n*.        USES DSECTS: MACLIB, AVWXTABL                               *\n*.                                                                    *\n*.REGISTER USAGE                                                      A\n*.RC-MACLIB BASE REGISTER, LIST TO BE SEARCHED                        A\n*.RAT- MAIN TABLE DSECT USING                                         A\n*.RB-RETURN REGISTER                                                  A\n*.                                                                    A\n*. NAMES=MACFN___                                                     A\n*.                                                                    A\n*.                                                                    *\n*.*********************************************************************\n         SPACE 2\nMACFND   CSECT\n         $SAVE SA=NO\n         USING AVWXTABL,RAT\n         XSNAP LABEL='***MACFND ENTERED***',T=NO,IF=(AVMSNBY1,O,$MSNP05X\n               ,TM)\n         USING MACLIB,RC           USE MACLIB AS REPRESENTATIVE DSECT\n         LTR   RC,RC               CHECK FOR NULL (MAYBE OPEN CDE)    J\n         BZ    MACFNDRU            SKIP IF NULL LIST                  J\n         SR    RB,RB\n         B     MACFND02            JUMP TO COMPARE FIRST ENTRY\nMACFND01 L     RC,MCLIBNXT         GET @ OF NEST ENTRY\nMACFND02 CLC   AVMSYMBL,MCLBNAM   COMPARE NAME WITH GLOBAL SYMBOL\n         XSNAP LABEL='IN MACFND LOOP RC # LIB',STORAGE=(*0(RC),*30(RC))\n         BE    MACFNDRT            IF EQUAL RETURN\n         CL    RB,MCLIBNXT         FINAL ENTRY?\n         BNE   MACFND01            IF NOT, TRY AGAIN\nMACFNDRU LA    RB,$ERUNDEF         SHOW UNDEFINED SYMBOL              J\nMACFNDRT EQU   *\n         XSNAP LABEL='***MACFND EXITED***',IF=(AVMSNBY1,O,$MSNP05,TM)\n         $RETURN   SA=NO\n         DROP  RAT,RC,REP\n         LTORG\n         TITLE '***MCVSCN - VARIABLE SYMBOL SCANNER ***'\n**-->  CSECT:  MCVSCN   THIS ROUTINE SCANS A STRING AND CHECKS        *\n*.        FOR A LEGAL VARIABLE SYMBOL.  IF OKAY, SYMBOL IS MOVED INTO *\n*.        AVMSYMBL IN AVWXTABL WHERE IT WILL BE UTILIZED IN SEARCHES. *\n*.                                                                    *\n*.        ENTRY CONDITIONS                                            *\n*.     RA = @ OF FIRST CHARACTER OF STRING                            *\n*.                                                                    *\n*.        EXIT CONDITIONS                                             *\n*.     RA = @ OF DELIMITER PAST SYMBOL IF LEGAL                       *\n*.        = SAME AS ENTRY IF NOT VARIABLE SYMBOL                      *\n*.     RB = 0 IF OKAY, <0 IF NOT VARIABLE SYMBOL,                     *\n*.        = $ER MESSAGE IF ILLEGAL SYMBOL                             *\n*.        USES MACROS: $SAVE, $RETURN                                 *\n*.        USES DSECTS: AVWXTABL                                       *\n*.                                                                    *\n*.REGISTER USAGE                                                      A\n*.RAT- MAIN TABLE DSECT USING                                         A\n*.R1,R2 USED IN TRT'S                                                 A\n*.RB- SET AS IN EXIT CONDITIONS ABOVE                                 A\n*.                                                                    A\n*.NAMES=MCVS____                                                      A\n*.                                                                    A\n*.*********************************************************************\n         SPACE 2\nMCVSCN   CSECT\n         $SAVE RGS=(R0-R2),SA=NO\n         USING AVWXTABL,RAT\n         XSNAP LABEL='***MCVSCN ENTERED***',T=NO,STORAGE=(*AVMSYMBL,*AVX\n               MSYMBL+10),IF=(AVMSNBY1,O,$MSNP05,TM)\n         LM    R1,R2,AWZEROS       ZERO R1, R2, FOR TRT USE\n         LR    R0,RA               COPY SCAN POINTER\n         CLI   0(RA),C'&&'         STARTS WITH '&'?\n         BNE   MCVSCNOT             IF NOT, NO VAR SYMBOL\n         CLI   1(RA),C'0'          2ND CHAR = ALAPHA?\n         BNL   MCVSCNER             IF NOT, ERROR\n         TRT   1(8,RA),AWTSYMT     SCAN RMNDER OF SYMBOL\n         BZ    MCVSCNER             IF ZERO, 9+ CHARS LONG, ERROR\n         SR    R1,R0               GET LENGTH OF SYMBOL\n         AR    R0,R1               BUMP SCAN &\n         STC   R1,AVMSYMLN         SAVE LENGTH IN GLOBAL AREA\n         BCT   R1,MCVSCN01          DECR FOR EX BUT FALL THROUGH IF ZER\n         B     MCVSCNER             ERROR IF LENGTH = 1\nMCVSCN01 MVC   AVMSYMBL,AWBLANK    BLANK GLOBAL AREA\n         EX    R1,MCVSMOVE         MOVE SYMBOL INTO GLOBAL AREA\n         LR    RA,R0               BUMP SCAN POINTER\n         SR    RB,RB\n         B     MCVSCNRT\nMCVSCNOT L     RB,AWFM4            SET NO SYMBOL FLAG\n         B     MCVSCNRT\nMCVSCNER LA    RB,$ERINVSY         SET INVALID SYMBOL FLAG\nMCVSCNRT EQU   *\n         XSNAP LABEL='***MCVSCN EXITED***',IF=(AVMSNBY1,O,$MSNP05,TM)\n         $RETURN  RGS=(R0-R2),SA=NO\nMCVSMOVE MVC   AVMSYMBL(0),0(RA)   DUMMY TO MOVE SYMBOL IN EX INST\n         DROP  RAT,REP\n         LTORG\n         TITLE '***MCSYSR - DICTIONARY SEARCH ROUTINE***'\n**-->  CSECT:  MCSYSR  SCANS SUSPECTED VARIABLE SYMBOL FOR LEGALITY.  *\n*.        IF VARIABLE SYMBOL THEN PLACES IN AVMSYMBL.  THEN SEARCHES  *\n*.        GLOBAL, LOCAL AND SYMBOLIC PARAMETER DICTIONARIES FOR SYMBOL*\n*.                                                                    *\n*.        ENTRY CONDITIONS                                            *\n*.     RA = @ OF FIRST CHARACTER OF SYMBOL                            *\n*.                                                                    *\n*.        EXIT CONDITIONS                                             *\n*.     RA = @ OF DELIMITER PAST VARIABLE SYMBOL IF OKAY               *\n*.        = SAME AS ENTRY IF NOT VARIABLE SYMBOL OR IF NOT FOUND      *\n*.     RB = $ERUNDEF  IF SYMBOL IS NOT FOUND                          *\n*.     RB = 0 IF SYMBOL IS FOUND IN ONE OF THE DICTIONARIES           *\n*.        = SET TO -4 IF RA DOES NOT POINT AT VARIABLE SYMBOL         *\n*.     RC = POINTER TO SYMBOL ENTRY IF FOUND                          *\n*.     RD = $GLOBAL IF SYMBOL PRESENT IN GLOBAL DICTIONARY            *\n*.        = $LOCAL IF SYMBOL FOUND IN LOCAL DICTIONARY                *\n*.        = $SYMPAR IF SYMBOL IS SYMBOLIC PARAMETER                   *\n*.        = $SYSTEM IF SYMBOL IS SYTEM VARIABLE                       *\n*.                                                                    *\n*.        USES MACROS: $CALL, $SAVE, $RETURN                          *\n*.        USES DSECTS: MCGLBDCT, MACLIB,AVWXTABL                      *\n*.        CALLS MCVSCN, MACFND                                        *\n*.                                                                    A\n*.REGISTER USAGE ***************                                      A\n*.R13 -BASE REGISTER AND SAVEAREA POINTER                             A\n*.RC- BASE REGISTER FOR GLOBAL DSECT                                  A\n*.RX- BASE REGISER FOR MACRO DICTIONARY                               A\n*.                                                                    A\n*.NAMES=MCSY____                                                      A\n*.                                                                    A\n*.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 2\nMCSYSR   CSECT\n         $SAVE RGS=(R14-R0),SA=*,BR=13\n         USING AVWXTABL,RAT        SET MAIN TABLE USING\n         XSNAP LABEL='***MCSYSR ENTERED***',T=NO,IF=(AVMSNBY1,O,$MSNP06X\n               ,TM)\n         USING MCGLBDCT,RC         USE GLOBAL DSCT AS DUMMY FOR SEARCH\n         USING MACLIB,RX           RX POINTS TO CURRENT MACLIB ENTRY\n         LR    R0,RA               COPY SCAN POINTER\n         SR    RD,RD               CLEAR RD FOR RETURN CODE\n         $CALL MCVSCN              SCAN SYMBOL\n         LTR   RB,RB               VAR SYMBOL?\n         BZ    MCSY01              PROCEED IF YES\n         L     RB,AWFM4            ELSE SET NO SYMBOL FLAG\n         B     MCSYFT              AND RETURN\n         SPACE\n*.VARIABLE SYMBOL FOUND SEARCH PARAM DICTIONAY                        A\n*.                                                                    A\nMCSY01   EQU   *\n         L     RC,MCPARPNT         GET PNTR TO PARAM LIST\n         $CALL MACFND              SCAN PARAM DICT.\n         LTR   RB,RB               SYMBOL F6UND?\n         BNZ   MCSY02              IF NOT PROCEED WITH  GLOBAL SEARCH\n         LA    RD,$SYMPAR          ELSE SET PARAMETER FLAG\n         CLI   MCGLBTYP,C'S'       CHECK IF SYSTEM VARIABLE\n         BNE   MCSYFT              RETURN IF NOT\n         LA    RD,$SYSVAR          ELSE SET SYSTEM FLAG\n         B     MCSYFT              AND RETURN\n         SPACE\n*.NOT IN PARM DICTIONARY, SEARCH GLOBAL DICTIONARY                    A\n*.                                                                    A\nMCSY02   EQU   *\n         L     RC,AVMGDICT         GET PNTR TO GLOBAL DICTIONARY\n         $CALL MACFND              SEARCH DICTIONARY\n         LTR   RB,RB               SYMBOL FOUND?\n         BNZ   MCSY03              PROCEED WITH PARAM SEARCH IF NOT\n         CLC   MCGLBDEF,AVMMACID   GLOBAL DECLARED THIS DEFINITION?\n         BNE   MCSY03              IF NOT, PROCEED AND SEARCH LOCAL DIC\n         LA    RD,$GLOBAL          SET GLOBAL TYPE FLAG\n         B     MCSYFT              AND RETURN\n         SPACE\n*.NOW CHECK LOCAL DICTIONARY                                          A\n*.                                                                    A\nMCSY03   EQU   *\n         LA    RD,$LOCAL           SET LOCAL FLAG\n         L     RC,MCDDVPNT         GET LOCAL DICT @\n         $CALL MACFND              SEARCH LOCAL DICTIONARY\n         LTR   RB,RB               SYMBOL FOUND?\n         BZ    MCSYFT              IF YES, RETURN\n         LR    RA,R0               ELSE RESTORE SCAN POINTER FIRST\nMCSYFT   EQU   *\n         XSNAP LABEL='***MCSYSR EXITED***',IF=(AVMSNBY1,O,$MSNP06,TM)\n         $RETURN  RGS=(R14-R0)\n         DROP  RAT,RC,RX,R13\n         LTORG\n         TITLE '***MCDTRM - CONVERTS DECIMAL TO BINARY***'\n**-->  CSECT:  MCDTRM   DECIMAL CONSTANT CONVERSION.  MCDTRM DECIDES  *\n*.        SCAN POINTER IS POINTING AT LEGAL DECIAMAL TERM AND IF SO,  *\n*.        CONVERTS TO BINARY FORM. HANDLES VALUES UP TO 2**31-1       *\n*.                                                                    *\n*.        ENTRY CONDITIONS                                            *\n*.     RA = @ OF FIRST CHAR OF TERM                                   *\n*.                                                                    *\n*.        EXIT CONDITIONS                                             *\n*.     RA = @ OF DELIMITER BEYOND CONSTANT                            *\n*.        = SAME AS ENTRY IF ERROR                                    *\n*.     RB = 0 IF CONSTANT WAS LEGAL                                   *\n*.        = $ER MSSGE IF ILLEGAL TERM                                 *\n*.     RC = VALUE OF CONSTANT, 0 TO 2**31-1                           *\n*.                                                                    *\n*.        USES DSECTS: AVWXTABL                                       *\n*.        USES MACROS: $SAVE, $RETURN                                 *\n*.REGISTER USAGE                                                      A\n*.R12 -BASE REG                                                       A\n*.RAT-MAIN TABLE DSECT USING                                          A\n*.RD- SCAN POINTER                                                    A\n*.                                                                    A\n*.NAMES=MCD_____                                                      A\n*.                                                                    A\n*** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 4\nMCDTRM   CSECT\n         $SAVE RGS=(R0-R2),SA=NO\n         USING AVWXTABL,RAT        NOTE MAIN TABLE USING\n         XSNAP LABEL='***MCDTRM ENTERED***',T=NO,IF=(AVMSNBY1,O,$MSNP06X\n               ,TM)\n         LR    RD,RA               COPY SCAN POINTER\n         SR    R1,R1               USE IN TRT INST\n         TRT   0(11,RD),AWTDECT    TRANSLATE WITH DEC TABLE\n         BZ    MCDTRMR1            ERROR IF MORE THAN 10 DIGITS\n         BM    MCDTRM01            < 10 DIGITS, PROCEED\n         CLC   0(10,RA),=C'2147483647'  10 DIGIT NUMBER WITHIN RANGE?\n         BH    MCDTRMR1            ERROR IF GREATER\nMCDTRM01 EQU   *\n         LR    RA,R1               UPDATE SCAN POINTER\n         SR    R1,RD               GET LENGTH\n         BZ    MCDTRMR1            ILLEGAL IF ZERO LENGTH\n         BCTR  R1,0                GET LENGTH-1 FOR EX INST\n         EX    R1,MCDECPAK         PACK CHARS\n         CVB   RC,AVDWORK1         CONVERT THE NIMBER\n         SR    RB,RB               SHOW NO ERRORS\nMCDTRMRT EQU   *\n         XSNAP LABEL='***MCDTRM EXITED***',IF=(AVMSNBY1,O,$MSNP06,TM)\n         $RETURN  RGS=(R0-R2),SA=NO\nMCDTRMR1 LA    RB,$ERSDINV         SET ILLEGAL NUMBER FLAG\n         B     MCDTRMRT            AND RETURN\nMCDECPAK PACK  AVDWORK1(8),0(0,RD)  PACK DEC CHARS\n         LTORG\n         DROP  RAT\n         TITLE '***MCGTST - CHARSTRING STORE ROUTINE***'\n**-->  CSECT:  MCGTST  THIS ROUTINE TAKES A STRING AS DELINEATED BY   *\n*.        BEGINNING AND END POINTERS, OBTAINS STORAGE DYNAMICALLY AND *\n*.        MOVES THE STING.  IF INSIDE QUOTES DOUBLE QUOTES WILL BE    *\n*.        CRUNCHED TO ONE QUOTE                                       *\n*.                                                                    *\n*.        ENTRY CONDITIONS                                            *\n*.     RA = @ OF FIRST CAHRACTER OF STRING                            *\n*.     RB = @ OF DELIMITER PAST STRING                                *\n*.                                                                    *\n*.        EXIT CONDITIONS                                             *\n*.     RA = @ OF DELIMITER PAST STRING                                *\n*.     RC = @ OF STRING IN NEW STORAGE                                *\n*.     RD = LENGTH OF STRING                                          *\n*.                                                                    *\n*.        USES MACROS: $SAVE, $RETURN, $ALLOCL                        *\n*.        USES DSECTS: AVWXTABL                                       *\n*.                                                                    *\n*.   REGISTER USAGE                                                   A\n*.       RAT-MAIN TABLE USING                                         A\n*.       RA,RB,RC,RD-AS IN ENTR/EXIT CONDITIONS                       A\n*.       RE,R1,R3-WORK REGISTERS                                      A\n*** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 2\nMCGTST   CSECT\n         $SAVE RGS=(R0-R3),SA=NO\n         USING AVWXTABL,RAT\n         XSNAP LABEL='***MCGTST ENTERED***',IF=(AVMSNBY1,O,$MSNP06,TM)\n         CR    RA,RB               NULL STRING?\n         BE    MCGTSTF             SKIP OUT IF NULL STRING            S\n         LR    RE,RB               COPY END DELIM\n         SR    RE,RA               GET LENGTH\n         LR    RD,RE               COPY LENGTH\n         LA    RE,3(RE)            GET NEXT FULL WORD PLUS            A\n         SRL   RE,2\n         SLL   RE,2                TRUNCATE TO FULL WORD\n         $ALLOCL  RC,RE,MCGTOVR    OBTAIN STORAGE FOR STRING\n         LR    RE,RD               COPY ORIGINAL LENGTH\n         BCTR  RE,0                DECR FOR EX INST\n         EX    RE,MCGTMV           MOVE STRING INTO STORAGE\n         TM    AVMBYTE1,$MINQUOT   INSIDE QUOTES?\n         BNO   MCGTSTFT            IF NOT, RETURN\n         LR    R1,RC               GET @ OF STIRNG START\n         LR    R3,R1\n         AR    R3,RE               GET @ OF END OF STRING\n         BCTR  R3,0                DECR TO SECOND LAST CHAR\n         LA    R2,1                USE R2 AS INDEX\nMCGTST02 EQU   *\n         CLI   0(R1),C''''         QUOTE?\n         BCTR  RE,0                REDUCE RMNDR COUNT\n         BE    MCGTST03            SQUEEZE QUOTE IF YES\n         BXLE  R1,R2,MCGTST02      ELSE BUMP INDEX AND RESUME SCAN\n          B    MCGTSTFT            ELSE RETURN IF SCAN FINISHED\nMCGTST03 EQU   *\n         EX    RE,MCGTMVC                                             A\n         MVI   1(R3),C' '          INSERT BLANK AT END OF SQUZD STRNG\n         BCTR  R3,0                DECR END OF STRING POINTER\n         BCTR  RE,0                DECR REMAINING LENGTH\n         BCTR  RD,0                REDUCE OVERALL LENGTH\n         AR    R1,R2               BUMP SCAN POINTER                  A\n         B     MCGTST02            RESUME SCAN\nMCGTMVC  MVC   0($,R1),1(R1)       SQUEEZE OUT QUOTE                  A\n         SPACE 2\nMCGTSTF  LM    RC,RD,AWZEROS       ZERO OUT- NULL STRING              S\nMCGTSTFT EQU   *\n         LR    RA,RB               MOVE SCAN POINTER\n         XSNAP LABEL='***MCGTST EXITED***',IF=(AVMSNBY1,O,$MSNP06,TM)\n         $RETURN RGS=(R0-R3),SA=NO\n         SPACE\nMCGTOVR  L     R15,AVMOVRFL        GET @ OF OVERFLOW ROUTINE\n         BR    REP                 BRANCH THERE\nMCGTMV   MVC   0($,RC),0(RA)       MOVE STRING INTO STORAGE           A\n         DROP  RAT\n         LTORG\n         TITLE '*** MCATRM - ATTRIBUTE PROCESSOR ***'\n**-->  CSECT: MCATRM       THIS ROUTINE SCANS A TERM AND DETERMINES   *\n*.        WHETHER IT IS A VALID ATTRIBUTE, IE I', K', L', N', S' OR T'*\n*.        THE LENGTH (L'), SCALE (S') AND INTEGER (I') ATTRIBUTES ARE *\n*.        NOT IMPLEMENTED AND ARE SO FLAGGED.                         *\n*.                                                                    *\n*.        ENTRY CONDITIONS                                            *\n*.     RA = @ OF FIRST CHAR OF TERM                                   *\n*.                                                                    *\n*.        EXIT CONDITIONS                                             *\n*.     RA = @ OF DELIM PAST QUOTE IF VALID ATTRIBUTE ELSE SAME AS     *\n*.          ENTRY.                                                    *\n*.     RB = 0 IF ATTRIBUTE                                            *\n*.        = -4 IF NOT ATTRIBUTE                                       *\n*.        = $ERMESSAGE IF NOT IMPLEMENTED                             *\n*.     RC = TYPE OF ATTRIBUTE                                         *\n*.                                                                    *\n*.        USES MACROS: $SAVE, $RETURN                                 *\n*.        USES DSECTS: AVWXTABL                                       *\n*.                                                                    *\n*.*********************************************************************\n         SPACE 2\nMCATRM   CSECT\n         $SAVE RGS=(R14-R2),SA=NO\n         USING AVWXTABL,RAT        NOTE MAIN TABLE USING\n         XSNAP LABEL='***MCATRM ENTERED***',T=NO,IF=(AVMSNBY1,O,$MSNP06X\n               ,TM)\n         LM    RB,RC,AWZEROS       ZERO RB AND RC\n*                                                                     A\n         BCTR  RA,0                DECR POINTER\n         TRT   0(1,RA),AWTSYMT     TEST PREV CHAR\n         LA    RA,1(RA)            RESTORE POINTER\n         BZ    MCATRMR1            NOT ATTRIBUTE IF PREV CHAR = ALPHA\n         LA    RD,MCATTABL         GET @ OF ATTRIBUTE TABLE\nMCATRMSC CLC   0(2,RA),0(RD)       COMPARE NEXT ENTRY\n         BL    MCATRMR1            IF LOW, NOT FOUND, RETURN\n         BE    MCATRMYS            IF EQUAL, FOUND\n         LA    RD,4(RD)            ELSE BUMP TABLE POINTER\n         B     MCATRMSC            TRY AGAIN\n         SPACE\nMCATRMYS IC    RB,3(RD)            SET PRESENCE FLAG\n         IC    RC,2(RD)            SET TYPE\n         CLI   3(RD),$ERNOIMP      IMPLEMENTED?\n         BE    MCATRMRT            IF NOT, DON'T MOVE POINTER\n         LA    RA,2(RA)            BUMP POINTER\n         B     MCATRMRT\nMCATRMR1 EQU   *\n         L     RB,AWFM4            SET -4 FOR NO ATTIB\nMCATRMRT EQU   *\n         XSNAP LABEL='***MCATRM EXITED***',IF=(AVMSNBY1,O,$MSNP06,TM)\n         $RETURN  RGS=(R14-R2),SA=NO\n         SPACE 2\nMCATTABL DC    C'I''',AL1($BSATI,$ERNOIMP),C'K''',AL1($BSATK,X'00')\n         DC    C'L''',AL1($BSATL,$ERNOIMP),C'N''',AL1($BSATN,X'00')\n         DC    C'S''',AL1($BSATS,$ERNOIMP),C'T''',AL1($BSATT,X'00')\n         DC    X'FFFF'                                                A\n         LTORG\n         DROP  RAT,REP\n         TITLE '***MCBODY - PROCESSES BODY OF MACRO DEFINITION***'\n**-->  CSECT:  MCBODY   PROCESSES THE BODY OF MACRO DEFINITION.       *\n*.        CALLED FORM MACRO1 AFTRR PROTOTYPE STATEMENT PROCESSED.     *\n*.        INITIALIZES LOCAL DICTIONARY FOR CURRENT DEFINITION.        *\n*.        PROCESSES EACH STATEMENT TILL MEND STATEMENT ENCOUNTERED.   *\n*.        TERMINATES AND RETURNS AT THAT POINT                        *\n*.                                                                    *\n*.       IN OPEN-CODE MODE, ($MCOCFL1 ON IN MCLBFLG2),                *\n*.       MCBODY ONLY PROCESSES STMT IN RSBLOCK                        *\n*.       IF AVPRSAVE IS SET IN AVPRINT1, IT CALL MXMVSR               *\n*.       TO SAVE STMT IN HIGH AREA, ELSE IT PRINTS IT IMMEDIATELY     *\n*.        ENTRY CONDITIONS                                            *\n*.     RC = @ OF MACLIB ENTRY OF CURRENT MACRO DEFINITION             *\n*.                                                                    *\n*.        USES MACROS: $SAVE,$RETURN,$CALL,$ALLOCL,$ALLOCH,$SCOF,     *\n*.                     $SETRT                                         *\n*.        USES DSECTS: AVWXTABL,MACLIB,MCLCLDPV,OPCODTB,RSBLOCK,MCBSU,*\n*.                     MCSEQ,MCGLBDCT,MCOPQUAD                        *\n*.        CALLS INCARD,ERRTAG,MACSCN,ERRLAB,MCVSCN,MACFND,SDDTRM,     *\n*.              MCSYSR,MACLEX,MCGTST,OUTPT2,MCGNCD                    *\n*.                                                                    *\n*.  REGISTER USAGE *************************                          A\n*.R13- BASE REGISTER AND SAVEAREA POINTER                             A\n*.RAT-MAIN TABLE DSECT USING                                          A\n*.RX- MACLIB DSECT USING                                              A\n*.RY- LOCAL DICTIONARY DSECT UING                                     A\n*.RZ-OPCODE TABLE DSECT USING                                         A\n*.RB,RE,RA- WORK REGISTERS                                            A\n*.R1,R2 USED IN TRT'S                                                 A\n*.RET- RETURN REGISTER USED FOR INSUBS                                A\n*.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 2\nMCBODY   CSECT\n         $SAVE RGS=(R14-R6),SA=*,BR=13\n         USING AVWXTABL,RAT\n         XSNAP LABEL='***MCBODY ENTERED***',IF=(AVMSNBY1,O,$MSNP07,TM)\n         USING MACLIB,RX           SET USING FOR MACRO LIBRARY ENTRY\n         LR    RX,RC               COPY @ OF MACLIB ENTRY\n         USING MCLCLDPV,RY         SET USING FOR LOCAL DV ENTRY\n         USING OPCODTB,RZ          SET USING FOR OPCODE TABLE ENTRY\n         NI    AVMBYTE1,$MINDEF    CLEAR AVMBYTE1\n         LM    R1,R2,AWZEROS       CLEAR R1 AND R2\n         MVC   AVMCRINS,AWZEROS    ZERO PTR TO 1ST ONE-OP             J\n         AIF   (NOT &$MACOPC).MCBODYA   SKIP IF NOT OPEN CODE         S\n         TM    MCLBFLG2,$MCOCFL1   IN OPEN CODE ?                     S\n         BO    MCBOD02             IF YES, SKIP DUMMY ENTRIES         S\n.MCBODYA ANOP                                                         S\n         LA    RB,$LLCLDV          GET LENGTH OF LOCAL DOPE VECTOR\n         SPACE\n*    THIS DUMMY ENTRY IN LOCAL DICT WILL BE USED FOR ACTR AND &SYSNDX\n         $ALLOCL  RY,RB,MCBODOVR   GET AREA FOR ENTRY\n         ST    RY,MCDDVPNT         SAVE @ IN MACLIB\n         MVC   0($LLCLDV,RY),AWZEROS   CLEAR ENTRY\n         MVI   MCLCLTYP,$ARITH     SET TYPE EQUAL TO ARITH FOR LENGTH\n         MVI   MCLCLDIM+1,1        SET DIMENSION TO 1\n         MVI   MCLOCDLN+3,4        INIT LENGTH OF DICT TO 4\n         SPACE\n*    DUMMY ENTRY FOR SEQUENCE SYMBOL TABLE\n         USING MCSEQ,RE            SET USING FOR SEQ SYMBOL ENTRY\n         LA    RB,$LMCSEQ          GET LENGTH OF ENTRY\n         $ALLOCH RE,RB,MCBODOVR    OBTAIN AREA FOR ENTRY\n         ST    RE,AVMSEQPT         SAVE @ IN MAIN TABLE\n         MVC   0($LMCSEQ,RE),AWZEROS   ZERO ENTRY\n         MVI   MCSEQFLG,X'FF'      SET DEFINED FLAG\n         DROP  RE        CLEAR USING\n         EJECT                                                        A\n         USING RSBLOCK,RW          SET USING FOR SOURCE STMNT\nMCBOD01  EQU   *\n         AIF   (NOT &$MACOPC).MCBODYB   SKIP IF NOT OPEN CODE         S\n         TM    MCLBFLG2,$MCOCFL1   IN OPEN CODE ?                     S\n         BO    MACBODRT            RETURN IF YES                      S\n.MCBODYB ANOP                                                         S\n         L     RW,AVRSBPT          GET @ OF SOURCE STMNT\n         $CALL INCARD              READ NEXT STATEMNT\n         LTR   RB,RB               ERROR ON INPUT\n         BZ    MCBOD02             JUMP ND PROCESS IF NOT\n         $CALL ERRTAG              ELSE FLAG STMNT\n         TM    AVTAGS2,$INEND2     END OF FILE?\n         BO    MACBODRT            RETURN IF YES\nMCBOD02  EQU   *\n         LA    RA,RSBSOURC         SET SCAN POINTER\n         ST    RA,MCBDSRPT         SAVE RSBSOURC @ FOR $SCOF USE\n         MVI  AVMBYTE2,X'00'       ZERO FLAG BYTE 2\n         MVI   AVMBYTE4,X'00'      CLEAR AVMBYTE4\n         $CALL MACSCN              SCAN STMT\n         C     RB,=F'8'            MACRO COMMENT?\n         BE    MCBODPR1            JUMP AND PRINT IF YES\n         LR    RZ,RC               COPY OPCODTB ENTRY @ INTO RZ\n         DROP  RW                  DROP USING ON SOURCE IMAGE\n         USING MCBSU,RW            SET UP USING ON BSU\n         L     RW,AVMCHSTR         SET BASE FOR BSU WORKAREA\n         MVC   MCBSU(8),AWZEROS    CLEAR FIRST BSU\n         CLI   AVMFLDT2,C'M'       MACRO OPCODE?\n         BE    MCBODJMP            IF YES, JUMP AND FIND WHICH OPCODE\n         CLI   AVMFLDT2,C'I'       INNER MACRO INSTRUCTION?\n         BNE   MCBODSTR            PROCESS MODEL STMT IF NOT          S\n         AIF   (NOT &$MACOPC).MCBODYE   SKIP IF NOT OPEN CODE         S\n         TM    MCLBFLG2,$MCOCFL1   IN OPEN CODE ?                     S\n         BO    MCBODSTQ            PROCESS MODEL STMT (NO INNER MACS) A\n.MCBODYE ANOP                                                         S\n         B     MCBDINMC            PROCESS INNER MACRO                S\n*  THIS SECTION GETS THE TYPE OF OPERATION AND BRANCHES TO THE        A\n*  CODE TO PROCESS IT                                                 A\nMCBODBAS DS    0H\nMCBODJMP EQU   *\n         SR    R2,R2               C3EAR R2 FOR INDEX ACTION\n         IC    R2,OPCHEX           GET OPCODE INDEX\n         LA    R1,MCFLGTAB(R2)     LOAD @ OF TABLE ENTRY              S\n         MVC   *+7(1),1(R1)        MOVE MASK INTO NEXT TM INSTR       S\n*              NOTE:  THE NEXT INST IS MODIFIED BY THE PREVIOUS INST  S\n         TM    MCLBFLG2,$          TEST IF CARD OUT OF ORDER          S\n         BO    MACMACRO            BRANCH IF CARD OUT OF ORDER        S\n         OC    MCLBFLG2(1),0(R1)   SET CURRENT OPCODE FLAG            S\n         LH    R1,MACBINDX(R2)     GET REL @ FROM TABLE\n         B     MCBODBAS(R1)        JUMP TO ROUTINE\n         SPACE 2\nMACBINDX $AL2  MCBODBAS,(MACMACRO,MACGBLA,MACGBLB,MACGBLC,MACLCLA,MACLCX\n               LB,MACLCLC,MACACTR,MACSETA,MACSETB,MACSETC,MACAIF,MACAGOX\n               ,MACANOP,MACMNOTE,MACMEXIT,MACMEND),-2\n         EJECT                                                        S\n*        THIS MACRO FLAG TABLE IS USED TO EITHER SET OR TEST A FLAG   S\n*        TO CHECK IF A MACRO OPCODE IS OUT OF ORDER.                  S\n*        ......THE FIRST BYTE OF EACH TWO BYTE ENTRY CONTAINS THE     S\n*              FLAG TO BE SET INTO MCLBFLG2 WHEN THE OPCODE IS        S\n*              ENCOUNTERED.  THE SECOND BYTE IS USED TO TEST AGAINST  S\n*              MCLBFLG2 TO SEE IF THE CURRENT OPCODE IS OUT OF ORDER. S\n*                                                                     S\n*                  SET , TEST          OPCODE                         S\n*                  ---   ----          ------                         S\n*                                                                     S\nMCFLGTAB EQU   *-2                 ORIGIN OF HALF-WORD TABLE          A\n         DC    AL1(0,$MGBLFLG)     MACRO                              A\n         DC    AL1(0,$MGBLFLG)         GBLA                           S\n         DC    AL1(0,$MGBLFLG)         GBLB                           S\n         DC    AL1(0,$MGBLFLG)         GBLC                           S\n         DC    AL1($MGBLFLG,$MLCLFLG)  LCLA                           S\n         DC    AL1($MGBLFLG,$MLCLFLG)  LCLB                           S\n         DC    AL1($MGBLFLG,$MLCLFLG)  LCLC                           S\n         DC    AL1($MACTFLG,$MACTFLG)  ACTR                           S\n         DC    AL1($MACTFLG,0)         SETA                           S\n         DC    AL1($MACTFLG,0)         SETB                           S\n         DC    AL1($MACTFLG,0)         SETC                           S\n         DC    AL1($MACTFLG,0)         AIF                            S\n         DC    AL1($MACTFLG,0)         AGO                            S\n         DC    AL1($MACTFLG,0)         ANOP                           S\n         DC    AL1($MACTFLG,0)         MNOTE                          S\n         DC    AL1($MACTFLG,0)         MEXIT                          S\n         DC    AL1($MACTFLG,0)         MEND                           S\n         DROP  RY                  CLEAR TEMP USING OF RY\n         SPACE 2\n         TITLE '***MCBODY - GBLX ROUTINES***'\n         USING MCGLBDCT,RY         ESTAB USING FOR GLOBAL ENTRY\nMACGBLA  EQU   *\nMACGBLB  EQU   *\nMACGBLC  EQU   *\n         BAL   RET,MCB01           CHECK FOR LABEL & OPERAND          J\nMCGB04   EQU   *\n         ST    RA,AVMTSCNP         COPY SCAN POINTER TEMPRORARILY\n         $CALL MCVSCN              SCAN SYMBOL\n         LTR   RB,RB               VARIABLE SYMBOL?\n         BZ    MCGB05              PROCESS IF OKAY\n*                                                                    AS\n         LA    RB,$ERINVSY         SET ERROR FLAG IF RB^=0            A\n         B     MCBDPRER            AND JUMP AN4 FLAG\n*   AT THIS POINT LEGAL SET SYMBOL                                    A\nMCGB05   EQU   *\n         L     RC,MCPARPNT         GET PARAM LIST START @\n         $CALL MACFND              SCAN PARAM LIST\n         LTR   RB,RB               SYMBOL PRESENT\n         BZ    MCGBMD              ERROR IF YES-QUIT                  A\n*  LEGAL GLOBAL DECLARATION                                           A\n         L     RC,AVMGDICT         GET GLOBAL DICT POINTER\n         $CALL MACFND              SCAN GLOBAL DICT\n         LR    RY,RC               MOVE DICT ENTRY TO REGULAR BASE\n         LTR   RB,RB               SYMBOL PRESENT?\n         BNZ   MCGB07              JUMP AND PROCESS IF NOT PRESENT\n         CLC   MCGLBDEF,AVMMACID   ELSE IS IT PREV DEFINED THIS DEF?\n         BE    MCGBMD              MULT DEF IF YES\n         CLC   MCGLBTYP,AVMBYTE3   DO TYPES MATCH?\n         BNE   MCGBMD              IF NOT, THEN ERROR\n         LA    RC,1                SET DIMENSION=1 FOR NO DIMEN       A\n         CLI   0(RA),C'('          SYMBOL DIMENSIONED?\n         BNE   MCGB08              IF NOT, PROCEED\n         BAL   RET,MCB02           GET DIMENSION                      J\nMCGB08   EQU   *                   COME HERE TO CHECK SIZES=          A\n         CH    RC,MCGLBDIM         DIMENSIONS M1TCH?\n         BE    MCGB10              PROCEED IF YES\n         B     MCGBMD              AND JUMP AND FLAG MULT DEF ERROR\n         SPACE\nMCGB07   EQU   *\n         LA    RC,1                SET DIMENSION TO 1\n         CLI   0(RA),C'('          DIMENSIONED?\n         BNE   MCGB11              PROCEED WITH SINGLE DIM IF NOT\n         BAL   RET,MCB02           GET DIMENSION                      J\n         BAL   RET,MCB03           CHECK SIZE                         J\nMCGB11   EQU   *\n         LA    RB,$LGLBENT         GET LENGTH OF GLOBAL ENTRY\n         $ALLOCL  RE,RB,MCBODOVR   GET AREA FOR ENTRY\n         ST    RE,MCGLBNXT         SAVE POINTER IN PREV ENTRY\n         LR    RY,RE               MOVE BASE TO NEW ENTRY\n         MVC   MCGLBNXT($LGLBENT),AWZEROS   CLEAR NEW ENTRY\n         MVC   MCGLBLEN(9),AVMSYMLN  MOVE SYMABOL INTO ENTRY\n         MVC   MCGLBTYP,AVMBYTE3   SAVE TYPE IN ENTRY\n         STH   RC,MCGLBDIM         SAVE DIMENSI6N IN ENTRY\n         SR    RE,RE               CLEAR RE\n         IC    RE,AVMBYTE3         PLACE TYPE LENGTH IN RE\n         CLI   AVMBYTE3,$CHAR      WAS IT CHARACTER?\n         BE    MCGB12              IF YES , PROCEED WITH LENGTH OF 12\n         LA    RE,4                ELSE USE LNG OF 4 FOR BOOL & ARITH A\nMCGB12   LH    RD,MCGLBDIM         GET DIMENSION OF ARRAY\n         SR    R0,R0               CL1R R0 FOR USE IN LOOP\nMCGB13   EQU   *\n         $ALLOCL  RB,RE,MCBODOVR   GET AREA FOR ELEMENT\n         ST    R0,0(RB)            INITIALIZE TO ZERO\n         BCT   RD,MCGB13           LOOP BACK IF NOT FINISHED\n         SPACE 2\nMCGB10   EQU   *\n         MVC   MCGLBDEF,AVMMACID   SAVE CURRENT DEF ID\n         CLI   0(RA),C' '          END OF OPRND LIST?\n         BE    MCBODPR             JUMP AND PRINT IF YES\n         CLI   0(RA),C','          PROPER DELIMITER?\n         BNE   MCGBINVD            INVALID DELIM-GO FLAG              A\n         LA    RA,1(RA)            BUMP SCAN POINTER PAST ','\n         B     MCGB04              AND RESUME SCAN\n         DROP  RY                  CLEAR RY USING AFTER GLOBAL USE\n         TITLE '***MCBODY - LCLX ROUTINES***'\n         USING MCLCLDPV,RY         USE RY AS BASE FOR LOCAL ENTRIES\nMACLCLA  EQU   *\nMACLCLB  EQU   *\nMACLCLC  EQU   *\n         BAL   RET,MCB01           CHECK FOR LABEL & OPERAND          J\nMCLC04   EQU   *\n         ST    RA,AVMTSCNP         COPY SCAN POINTER\n         $CALL MCVSCN              SCAN FOR LEGAL VAR SYMBOL\n         LTR   RB,RB               OKAY?\n         BNZ   MCBDPRER            IF NOT, JUMP AND FLAG\n         LR    R0,RA               COPY NEW SCAN POINTER VALUE TEMP\n         L     RA,AVMTSCNP         GET ORIGINAL SCAN POINTER\n         $CALL MCSYSR              SEARCH ALL DICTS FOR SYMBOL\n         LTR   RB,RB               PRESENT ALREADY?\n         BZ    MCGBMD              GO FLAG MULTIPLE DEFINITION        A\n         LR    RA,R0               RESTORE SCAN POINTER\n         LR    RY,RC               MOVE BASE TO USING REG RY\n         LA    RB,$LLCLDV          GET LENGTH OF LCAL DV\n         $ALLOCL  RE,RB,MCBODOVR   GET AREA FOR ENTRY\n         MVC   0($LLCLDV,RE),AWZEROS   ZERO OUT ENTRY\n         ST    RE,MCLOCNXT         SAVE POINTER IN PREV ENTRY\n         LR    RY,RE               MOVE BASE TO NEW ENTRY\n         MVC   MCLCLLEN(9),AVMSYMLN  MOVE NAME INTO NEW ENTRY\n         MVC   MCLCLTYP,AVMBYTE3   ESTABLISH TYPE OF SET SYMBOL ENTRY\n         MVC   MCLCLDIM,AWH1       SET DIM = 1 FOR PRESENT\n         CLI   0(RA),C'('          DIMENSIONED?\n         BNE   MCLCFT              IF NOT, PROCEED\n         BAL   RET,MCB02           GET DIMENSION                      J\n         SPACE\nMCLC07   EQU   *\n         BAL   RET,MCB03           CHECK DIMENSION SIZE               J\nMCLC08   EQU   *\n         STH   RC,MCLCLDIM         SET DIMENSION IN ENTRY\nMCLCFT   EQU   *\n         LA    R1,4                ASSUME LENGTH = 4\n         TM    MCLCLTYP,$CHAR      TEST FOR TYPE\n         BNO   MCLC11              SKIP IF NOT CHAR\n*        ASSEMBLER G CAHRACTER DECL WILL CHANGE FOLLOWING.\n         LA    R1,12               ELSE USE CHAR LENGTH OF ENTRY\nMCLC11   EQU   *\n         MH    R1,MCLCLDIM         GET TOTAL SIZE OF ARRAY\n         L     RE,MCLOCDLN         GET CURRENT OFFSET/LENGTH          A\n         ST    RE,MCLCLPNT         STORE AS OFFSET TO THIS VAR        A\n         AR    R1,RE               UPDATE TOTAL DICT LENGTH           A\n         ST    R1,MCLOCDLN         SAVE LENGTH OF LOCAL DICT IN MACLIB\n         SPACE 1                                                      A\n         CLI   0(RA),C' '          WAS THIS LAST ONE?                 A\n         BE    MCBODPR             YES QUIT AND PRINT                 A\n         CLI   0(RA),C','          OK DLM                             A\n         BNE   MCGBINVD            NO, ERROR KILL IT                  A\n         LA    RA,1(,RA)           BUMP SCAN PTR TO NEXT OPRND        A\n         B     MCLC04              RETURN FOR NEXT OPRND              A\n         DROP  RY                  DROP TEMP USING OF RY FOR LOCALS\n         EJECT                                                        A\n**--> INSUB: MCB01      CHECK LCLX,BLX FOR LABEL, OPCODE  + + + + + + J\n*+                                                                   +A\n*+    THIS IS CALLED TO CHECK FOR AN ERROR IN THE GBLX OR             A\n*+       GBLX INSTRUCTION. IF AN ERROR OCCURES WHEN A LABEL IS PRESENTA\n*+       AND/OR THERE IS NO OPERANDS.                                 A\n*+                                                                    A\n*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +A\n         SPACE 2                                                      A\nMCB01    EQU   *                                                      J\n         MVC   AVMBYTE3,OPCMASK    GET TYPE OF SET SYMBOL             A\n         CLI   AVMFLDL1,0          CHECK IF LABEL PRESENT(L^=0)       A\n         BE    MCB001              IF NOT PROCEED                     J\n         ST    RET,MCB##SAV        SAVE THE RETURN @                  J\n         LA    RB,$ERILLAB         ELSE SET ERROR FLAG                A\n         $CALL ERRLAB              AND FLAG STMT                      A\n         L     RET,MCB##SAV        RESTORE RETURN @                   J\nMCB001   EQU   *                                                      J\n         L     RA,AVMFLD3          GET @ OPERAND; =0 IF NONE          A\n         LTR   RA,RA               DID ONE EXISTS                     A\n         BCR   NZ,RET              YES-RET, NORMAL CASE               A\n         B     MCBDOPER            NO-ERROR-MISSING OPERAND           A\n         SPACE 5                                                      A\n**--> INSUB: MCB02      OBTAIN DIMENSION OF GBLX OR LCLX STMT + + + + J\n*+       BUNPS POINTER GETS DIMENSION AND FLAGS ERROR IF NOT CONST   QA\n*+ RA= @ '(' ON ENTRY; @ BEYOND '(' ON EXIT IF GOOD                   A\n*+  RC=VALUE OF SUBSCRIPT IF GOOD                                     A\n*+ + + + + + + + + + ++  + + + + + + + + + + + + + + + + + + + + + + +A\n         SPACE 5                                                      A\nMCB02    ST    RET,MCB##SAV        SAVE RETURN @                      J\n         LA    RA,1(RA)            BUMP PTR PAST )                    J\n         $CALL SDDTRM              AND GET DIMENSION                  A\n         LTR   RB,RB               DIMENSION=CONSTANT?                A\n         BNZ   MCBDPRER            FLAG ERROR IF NOT                  A\n         CLI   0(RA),C')'          CURRENT ENDING DLM                 A\n         BNE   MCGBINVD            NO ERROR                           A\n         LA    RA,1(,RA)           YES BUMP BEYOND )                  A\n         L     RET,MCB##SAV        RESTORE RETURN @                   J\n         BR    RET                 RETURN                             A\n         SPACE 5                                                      A\n**--> INSUB: MCB03: CHECK DIMENSION SIZE FOR GBLX,LCLX+ + + + + + + + J\n*+       CHECKS TO MAKE SURE DIMENSION OF                           + A\n*+       GBLX AND/OR LCLX IS WITHIN RANGE                           + A\n*+       FLAGS ERROR IF NOTS WITHIN RANGE                           + A\n*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +  A\n         SPACE 2                                                      A\nMCB03    C     RC,=F'2500'         DIMENSION WITHIN RANGE?            J\n         BCR   NH,RET              RETURN IF NOT                      J\n         LA    RB,$EREXGTA         ELSE SET ERROR FLAG                A\n         B     MCBDPRER            AND FLAG STMT                      A\n         TITLE '***MCBODY - SET INSTRUCTION ROUTINES***'\n*                                                                     A\n* SETX SYMBOLS FOUND, SET FLAG FOR TYPE & CONTINUE SCAN OF EXPRESSION A\n*                                                                     A\nMACSETA  EQU   *\n         MVI   AVMBYTE3,$ARITH      SET ARITH TYPE FLAG\n         B     MACSET\nMACSETB  EQU   *\n         MVI   AVMBYTE3,$BOOL       SET BOOLEAN FLAG\n         B     MACSET\nMACSETC  EQU   *\n         MVI   AVMBYTE3,$CHAR       SET CHARACTER TYPE FLAG\n*                                                                     A\n*  CKECK FOR LEGAL SETUP IE, NO OPERAND ERRORS, NO LABEL              A\n* ON STATEMENT, ERROR IF LOOKS LEGAL, GO ON ELSE FLAG ERROR           A\n*                                                                     A\nMACSET   EQU   *\n         BAL   RET,MCB001          CHECK FOR OPERND,GET@              A\n         L     RA,AVRSBPT          GET SOURCE BLOCK ADDRESS\n         LA    RA,4(RA)            BUMP TO SOURCE STMNT\n         CLI   AVMFLDL1,X'00'      LABEL PRESENT?\n         BNE   MCBDST03            PROCEED IF YES\n         LA    RB,$ERNONAM         SET MISSING LA&EL FLAG\n         B     MCBDPRER            JUMP AND FLAG ERROR\n* GET THE BSU ADDRESS SET TYPE & IF NEITHER OF THE SET TYPES-ERROR    A\n*                                                                     A\nMCBDST03 EQU   *\n         LR    RC,RW               SET POINTER TO BSU\n         $CALL MACLEX              SCAN LABEL FIELD\n         LTR   RB,RB               ERROR?\n         BNZ   MCBDPRER            JUMP OUT IF YES\n         LR    RW,RC               RESTORE BSU POINTER\n         L     RE,AVMCHSTR         GET @ OF BSU WORKAREA\n         CLI   AVMBYTE3,$BOOL      IS SET A, B, OR C\n         BH    MCSETCHR            CHR IF HIGHER\n         BE    MCSETBOL            BOOLEAN IF EQUAL\n         OI    AVMBYTE2,$MINARIT   ELSE IS ARITHMETIC\n         MVI   MCBSINDX,$BSETA     SET BSU INDEX FOR SETA\n         CLI   1(RE),$BSTSYAG      IS IT GLOBAL ARITH SET SYSMB?\n         BE    MCBDST01            IF YES, OKAY\n         CLI   1(RE),$BSTSYAL      ELSE IS IT LOACAL ARITH SET SYMBOL?\n         BE    MCBDST01            IF YES, OKAY\n         B     MCLMXDER            ELSE FLAG ERROR\n*                                                                     A\n*  CHECKS THE FORMAT OF SETB-MAKE SURE ITS 0 OR 1, PARENS LEGAL       A\n*   THEN CHECKS FOR GLOBAL OR LOCALS                                  A\n*                                                                     A\nMCSETBOL EQU   *\n         L     RA,AVMFLD3          GET OPERAND @\n         CLI   0(RA),C'('          STARTS WITH LEFT PAREN?\n         BE    MCSETB01            OKAY IF YES\n         CLI   0(RA),C'1'          OPERAND = 1?\n         BE    MCSETB01            OKAY IF YES\n         CLI   0(RA),C'0'          OPERAND = 0?\n         BE    MCSETB01            OKAY IF YES\n         LA    RB,$ERINVF          ELSE SET INVALID FIELD FLAG\n         B     MCBDPRER            JUMP AND FLAG STMTN\nMCSETB01 EQU   *\n         OI    AVMBYTE2,$MINBOOL   SET BOOLEAN FLAG\n         MVI   MCBSINDX,$BSETB     SET BSU INDEX\n         CLI   1(RE),$BSTSYBG      IS IT BOOLEAN GLOBAL SET?\n         BE    MCBDST01            OKAY IF YES\n         CLI   1(RE),$BSTSYBL      ELSE IS IT BOOLEAN LOCAL SET?\n         BE    MCBDST01            OKAY IF YEW\n         B     MCLMXDER            ELSE FLAG EROR\n*                                                                     A\n* CHECK FOR LEGAL SETC SYMBOL                                         A\n*                                                                     A\nMCSETCHR EQU  *\n         MVI   MCBSINDX,$BSETC     SET BSU INDEX\n         OI    AVMBYTE2,$MINCHAR   SET CHAR FLAG\n         CLI   1(RE),$BSTSYCG      IS IT CHAR GLOBAL SET SYMBOL?\n         BE    MCBDST01            OKAY IF YES\n         CLI   1(RE),$BSTSYCL      ELSE IS IT CHAR LOCAL SET?\n         BNE   MCLMXDER            ERROR IF NOT\nMCBDST01 EQU  *\n*                                                                     A\n* SETS HIERARCHY OF BSU, SETS FLAGA & MOVES ADRESS THEN SCANS         A\n*  THE OPERAND, IF IN ERROR, FLAGS IT                                 A\n*                                                                     A\n         MVI   MCBSHIER,$MSETHR    SET HEERARCHY\n         OI    MCBSFLGS,$MOPRTR    SET OPERATOR FLAG IN BSU\n         L     RA,AVMFLD2          GET @ OF OPCODE\n         $SCOF  RB,RA,MCBSOFST     GET OPCODE @ INTO BSU\n         BAL   RE,MCBDBMP          BUMP BSU POINTER\n         LR    RC,RW               MOVE BSU POINTER TO RC\n         L     RA,AVMFLD3          GET ADDRESS OF OPERAND\n         $CALL MACLEX      SCAN OPERAND\n         LTR  RB,RB                ERROR\n         BNZ  MCBDPRER             FLAG STMNT IF YES\n         B     MCBODPR             JUMP TO FOOT\n         TITLE '***MCBODY - AGO,AIF, MNOTE ETC ROUTINES***'\n*  WHEN AN ACTR STATEMENT FOUND, SETS FLAG FOR NO MORE GLOBALS OR     A\n*  LOCALS. SEES IF ACTR STMT OK, THEN CHECKS IF LABEL PRESENT(ERROR)  A\n* CHECKS FOR OPERANDS(ERROR IF NOT THERE) SETS INDEX(COUNTER) & SETS  A\n* UP THE BSU.                                                         A\n*                                                                     A\nMACACTR  EQU   *\n         BAL   RET,MCB01           CHECK OPRND @ EXISTENCE            A\n         MVI   MCBSFLGS,$MTERM+$BSAR    SET BSU FLAGS\n         MVI   MCBSINDX,$BSTSYAL   SET LOCAL ARITH SET INDEX\n         MVC   MCBSLOC,MCDDVPNT    MOVE @ OF ACTR TO BSU\n         BAL   RE,MCBDBMP          BUMP BSU\n         L     RD,MCBDSET          CREATE BSU                         S\n         BAL   RE,MCBDBMP0         BUMP BSU POINTER                   S\n         OI    AVMBYTE2,$MINARIT   SET ARITH EXPRESSION FLAG\n         LR    RC,RW               GET BSU POINTER\n         $CALL MACLEX              SCAN EXPRESSION\n         LTR   RB,RB               ERROR?\n         BNZ   MCBDPRER            FLAG IF YES\n         LR    RW,RC               RESTORE BSU POINTER\n         B     MCBODPR             JUMP AND PRINT STMNT\n         SPACE 2\n* AIF FOUND, CHECK FOR LEGAL SEQUENCE, NO LCLX OR GBLX, AND SYNTAX    A\n*  MUST START WITH ( AND HAVE SEQ SYMB FOLLOWING, THEN SETS UP THE    A\n*  BSU WITH THE ADDRESSES.                                            A\n*                                                                     A\nMACAIF   EQU   *\n         BAL   RET,MCBDCHLB        CHECK FOR LEGAL LABEL\n         BAL   RET,MCB001          CHECK OPRND @ EXISTENCE            A\n         CLI   0(RA),C'('          FIRST CHAR = '('?\n         BE    MACAIF01            PROCEED IF YES\n         LA    RB,$ERVSYNT         SET SYNTAX FLAG\n         B     MCBDPRER            AND FLAG ERROR\nMACAIF01 EQU   *\n         OI    AVMBYTE2,$MINPEXP+$MINBOOL  SET FLGS FOR PAREN SCAN\n         LR    RC,RW               GET BSU POINTER\n         $CALL MACLEX              SCAN OPERAND\n         LR    RW,RC               RESTORE BSU POINTER\n         LTR   RB,RB               ERROR?\n         BNZ   MCBDPRER            FLAG IF YES\n         CLI   0(RA),C'.'          SEQ SYMBOL AFTER EXPRESSION?\n         BNE   MCBDISER            ERROR IF NOT\n         MVC   MCBSFLGS(4),MCBDAIF                                    A\n         L     R2,AVMFLD2          GET OFFSET OF OPCODE\n         $SCOF R1,R2,MCBSOFST      INSERT OFFSET IN BSU\n         BAL   RE,MCBDBMP          BUMP BSU\n         L     RD,MCBDLABL         GET FIRST HALF OF BSU              A\n*                                                                     A\n         B     MACAGO03                                               S\n         SPACE 2\n* SAME THING WITH AGO, CKS SYNTAX, LEGAL SEQ, ETC AND SETS UP         A\n* THE BSU                                                             A\n*                                                                     A\nMACAGO   EQU   *\n         BAL   RET,MCBDCHLB        CHECK FOR LEGAL CLABEL\n         BAL   RET,MCB001          CHECK OPRND GET @                  A\n         CLI   0(RA),C'.'          POSSIBLE SEQ SYMBOL?\n         BE    MACAGO02            PROCEED IF YES\n         LA    RB,$ERINVSY         ELSE SET BAD SYMBOL FLAG\n         B     MCBDPRER            AND FLAG STATEMNT\nMACAGO02 EQU   *\n         L     RD,MCBDAGO          CREATE BSU                         S\nMACAGO03 ST    RA,MCBSLOC          SAVE @ OF LABEL                    S\n         B     MCBODPR0            PRINT STATEMENT                    S\n         SPACE 2\nMACANOP  EQU   *\n         MVI   MCBSINDX,$BSANOP    INSERT BSU ANOP INDEX\n         B     MACAMM\nMACMEXIT EQU   *\n         MVI   MCBSINDX,$BSMEXIT   SET MEXIT BSU\n         B     MACAMM\nMACMEND  EQU   *\n         MVI   MCBSINDX,$BSMEND    SET MEND BSU INDEX\nMACAMM   EQU   *\n         BAL   RET,MCBDCHLB        CHECK FOR LEGAL LABEL\n         MVI   MCBSFLGS,$MOPRTR    SET OPRTR FLAG\n         MVI   MCBSHIER,$MPRNTHR   SET PRINT HIERARCHY\n         L     RA,AVMFLD2          GET OPCODE @\n         $SCOF RB,RA,MCBSOFST      PUT OFFSET IN BSU\n         BAL   RE,MCBDBMP          BUMP BSU POINTER                   A\n         B     MCBODPR                                                A\n         SPACE 2\n* MNOTE STMT FOUND, CKS FOR VALID SYNTAX, CREATES BSU. SCANS STRING   A\n*  FOR MESSAGE, ALSO CHECKING SYNTAX(INVALID DELIM ETC) CONCATS IFL   A\n* NECESSARY                                                           A\n*                                                                     A\nMACMNOTE EQU   *\n         BAL   RET,MCBDCHLB        CHECK FOR LABEL\n         CLI   AVMFLDL3,X'00'      OPRND PRESENT?\n         BE    MCBDOPER            ERROR IF NOT\n         BAL   RET,MCBDPFLC        CREATE PRINT BSU AND BUMP PTR      F\n         MVC   MCBSU(8),MCBDSTG1   COPY WHOLE BSU FROM TABLE          J\n         BAL   RE,MCBDBMP          BUMP BSU POINTER\n         L     RA,AVMFLD3          GET OPRND @\n         BAL   RET,MCBDPFLC        CREATE PRINT BSU AND BUMP PTR      F\n         CLI   0(RA),C''''         QUOTED STRING?\n         BNE   MCMNOT01\n         MVC   MCBSU(8),MCBDSTG2   COPY WHOLE BSU= '1,' BSU           J\n         BAL   RE,MCBDBMP\n         NI    AVMBYTE2,255-($MTERM+$MOPRTR)  TURN OFF PREV IND FLAG\n         OI    AVMBYTE2,$MTERM     SET TERM PREV FLAG\n         B     MCMNOT04\nMCMNOT01 EQU   *\n         $SETRT  (',',4,'''',8)    SET TABLE FOR SCAN\n         SR    RE,RE\n         IC    RE,AVRSBLOC         GET LENGTH-1\n         S     RA,AVRSBPT           GET OFFSET OF RA\n         SR    RE,RA               SUBTRACT OVERALL LENGTH\n         A     RA,AVRSBPT          RESTORE RA\n         EX    RE,MCMNOTSC\n         $SETRT  (',',0,'''',0)    RESTORE TABLE\n         BNZ   MCMNOT02            PROCEED IF SCAN STOPPED ON CHAR\nMCMNOTER EQU   *\n         LA    RB,$ERNODLM         ELSE SET BAD DELIM FLAG\n         B     MCBDPRER            AND FLAG STMT\nMCMNOT02 EQU   *\n         CLI   0(R1),C','          STOP ON COMMA?\n         BNE   MCMNOTER            ERROR IF NO\n         LA    RB,1(R1)            GET DELIM @\n         SR    RB,RA               GET LENGTH IN RB\n         BAL   RET,MCBDSCAN        SCAN SEVERITY EXPRESSION\nMCMNOT04 EQU   *\n         CLI   0(RA),C''''         QUOTE?\n         BNE   MCMNOTER            ERROR IF NOT\n         BAL   RET,MCBDCATI        INSERT CAT OPRTR\n         OI    AVMBYTE2,$MINCHAR   SET CHAR STRING FALG\n         LR    RC,RW               GET BSU PNTR\n         $CALL MACLEX              SCAN STRING\n         LR    RW,RC               BUMP BSU PNTR\n         LTR   RB,RB               ERROR\n         BNZ   MCBDPRER            FLAG IF YES\n         MVI   AVMFLDT2,X'00'      ZERO TYPE BYTE\n         L     RD,MCBDPR2          CREATE BSU                         S\n         L     RA,AVMFLD3          GET OPRND @\n         CLI   0(RA),C'*'          COMMNET?\n         BE    MCBODPR0            SKIP IF YES                        S\n         L     RD,MCBDPR3          MNOTE BSU                          A\n         B     MCBODPR0            PRINT STATEMENT                    S\nMCMNOTMS DC    CL12'***MNOTE***'\nMCMNOT1C DC    C'1,'               DEFAULT MNOTE SEVERITY             J\nMCMNOTSC TRT   0($,RA),AWTZTAB     DUMMY FOR COMMA QUOTE SCAN\n         SPACE 2\nMACMACRO EQU   *\n         L     RA,AVMFLD2          GET OPCODE @ IN RA\n         LA    RB,$ERSTMNA         SET STMNT NO GOOD FLAG\n         B     MCBDPRER            JUMP AND FLAG ERROR\n         TITLE '***MCBODY - STRING, INNER MACRO AND OPCODE ROUTINES***'\n* CHECKS COMMENT, SETS PRINT BSU IF STMT SHOULD BE PRINTED AND/OR     A\n*        DOESN'T PRINT SEQ SYMBOLS IN MACRO, OR MACRO COMMENTS. ALSO  A\n* MOVES OPCODE DATA IN IF PRESENT                                     A\n*                                                                     A\nMCBODSTQ EQU   *                                                      A\n         MVI   AVMFLDT2,0          OPEN CODE FAKE FOR MODEL STMT      A\nMCBODSTR EQU   *\n         C     RB,AWF4             COMMENT?\n         BE    MCBODCOM            ORDINARY COMMENT IF EQUAL\n         OI    MCLBFLG2,$MACTFLG   GLBL'S, ETC. NO LONGER OK          S\nMCBDSTIN EQU   *\n         CLI   AVMFLDT1,C'.'       SEQ SYMBOL?\n         BE    MCBDOPCD            PROCESS OPCODE IF YES\n         L     RA,AVMFLD1          ELSE GET PNTR TO LABEL FIELD\n         LTR   RA,RA               LABEL PRESENT\n         BZ    MCBDOPCD            PROCESS OPCODE IF NOT\n         BAL   RET,MCBDPFLC        CREATE PRINT BSU, NON COMMENT TYPE A\n         IC    RB,AVMFLDL1         GET LENGTH OFLABEL FIELD\n         SR    RC,RC               SET TERMINAL CHAR INDICATOR        S\n         BAL   RET,MCBDSCAN        SCAN LABEL FIELD\nMCBDOPCD EQU   *\n         CLI   AVMFLDL2,X'00'      OPCODE EXISTS?\n         BE    MCBDSFIN            FINI IF NOT\n         MVC   MCBDFLDS(5),AVMFLD2 ELSE MOVE OPCODE FIELD DATA\n         SR    RC,RC               INDICATE VAR SYMBOLS PRESENT\n         BAL RET,MCBDSCFD          SCAN OPCODE FIELD\n*                                                                     A\n* SCANS OPERAND FIELD ALLOWING FOR NON-STANDARD CONTINUATIONS         A\n* THAT IS RUNNINF ACROSS UP TO 3 CARDS, BALS TO MCBDSCFD TO TEST FOR  A\n*THE DIFFERENT FIELDS.                                                A\n*                                                                     A\nMCBDOPRN EQU   *\n         MVC   MCBDFLDS(5),AVMFLD3   GET DATA FOR OPRND FILED\n         SR    RC,RC               CLEAR RC FOR VAR SYMBOLS\n         BAL   RET,MCBDSCFD        SCAN OPRND FILED\n         MVC   MCBDFLDS(5),AVMFLD4  GET DATA FOR COMMENT FIELD\n         LA    RC,4                INDICATE NO VAR SYMBOLS\n         BAL   RET,MCBDSCFD        SCAN COMMNET FIELD\n         CLI   AVMFLDL5,0          2ND NON STND CARD?\n         BE    MCBDSFIN            FINI IF NOT\n         MVC   MCBDFLDS(5),AVMFLD5   GET DATA ON 2ND CARD OPRND\n         SR    RC,RC               INCICATE VAR SYMBOLS\n         BAL   RET,MCBDSCFD        SCAN OPNRD ON 2ND CARD\n         MVC   MCBDFLDS(5),AVMFLD6   GET DATA ON COMMNET FIELD( IF ANY)\n         LA    RC,4                INDICATE NO VAR SYMBOLS\n         BAL   RET,MCBDSCFD        SCAN COMMNET FIELD\n         CLI   AVMFLDL7,0          3RD NON STND CARD?\n         BE    MCBDSFIN            FINI IF NOT\n         MVC   MCBDFLDS(5),AVMFLD7   GET DATA ON OPRND\n         SR    RC,RC               INDICATE VAR SYMBOLS\n         BAL   RET,MCBDSCFD        SCAN OPRND\n         LA    RC,4                INDICATE NO VAR CYMBOLS\n         BAL   RET,MCBDSCFD        SCAN 3RD CARD COMMENT(IF ANY)\n*                                                                     A\n*  END OF STATEMENT  TEST FOR POSSIBLE INNER MACRO CALL, PROCESS      A\n*   ELSE, BUMP BSU POINTER, PRINT LINE, AND CONTINUE                  A\n*                                                                     A\nMCBDSFIN EQU   *\n         L     RD,MCBDPR2          CREATE BSU                         A\n         CLI   AVMFLDT2,C'I'       INNER MACRO CALL\n         BNE   MCBODPR0            SKIP OUT IF NOT INNER MACRO CALL   A\n         L     RD,MCBDINMA         GET INNER MACRO BSU                A\n         B     MCBODPR0            PRINT STATEMENT                    S\n         SPACE 2\n**--> INSUB:MCBDFLD   CREATES A PRINT BSU+ + + + + + + + + + + + + + +A\n*+                                                                   +A\n*+  CALLED TO CREATE A BSU SO STMT WILL BE PRINTED. IT ALSO          +A\n*+  BUMPS THE BSU POINTER                                            +A\n*+                                                                   +A\n*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +A\n         SPACE 2                                                      A\nMCBDPFLC SR    RC,RC               ENTRY NON COMMENT TYPE PRINT BSU   A\nMCBDPFLD EQU   *\n         LR    RD,RA               COMPUT OFFSET                      A\n         S     RD,MCBDSRPT                                            A\n         SLL   RD,8                MOVE TO RIGHT BYTE                 A\n         AL    RD,MCBPRBSU(RC)     GET PRINT BSU OR PRINT/COMMENT BSU A\n         NI    AVMBYTE2,255-($MTERM+$MOPRTR)  TURN OFF PREV IND FLAG\n         OI    AVMBYTE2,$MOPRTR    SET PREV INDICATOR TO OPRTR\n         BAL   RE,MCBDBMP0         BUMP BSU POINTER                   A\n         BR    RET\n         SPACE 2\n**--> INSUB:MCBDSCFN     LOOKS FOR FIELDS  + + + + + + + + + + + + + +A\n*+                                                                   +A\n*+  SCAN FIELDS IN STMT, CREATES BSU'S, IF ONE EXISTS.  RETURNS       S\n*+  THE LENGTH AND ENDING ADDRESS.                                   +A\n*+                                                                   +A\n*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +A\n         SPACE 2                                                      A\nMCBDSCFD EQU   *\n         ST    RET,MCBDSAVE        SAVE RETURN @\n         L     RA,MCBDFLD          GET POINTER TO FIELD\n         LTR   RA,RA               FIELD EXISTS?\n         BZ    MCBDSCFN            FINI IF NOT\n         SR    RB,RB               CLEAR RB TO CARRY LENGTH\n         IC    RB,MCBDFLDL         GET LENGTH OF FIELD\n         BAL   RET,MCBDPFLD        CREATE BSU\n         BAL   RET,MCBDSCAN        SCAN FIELD\nMCBDSCFN EQU   *\n         L     RET,MCBDSAVE        RESTORE RETURN @\n         BR    RET                AND RETURN\nMCBDSAVE DS    F                   CORE FOR RETURN @\nMCBDFLDS DS    0F                  TEMP STORAGE FOR FIELD INFO\nMCBDFLD  DS    F                   POINTER TO FILED\nMCBDFLDL DS    C                   LENGTH OF FIELD\nMCBDFLDT DS    C                   TYPE OF FIELD\n         SPACE 2\n*                                                                     A\n* PROCESSES INNER MACRO CALLS  MOVES OPCODE IN FIELD, SEARCHES        A\n*  FOR NAME IF LIBRARY, IF NOT THERE, MAKES NOTE OF REFERENCE FOR LATEA\n*  SEARCH OR POSSIBLE ERROR                                           A\nMCBDINMC EQU   *\n         OI    MCLBFLG2,$MACTFLG   GLBL'S, ETC. NO LONGER OK          S\n         SR    R2,R2               CLEAR R2 FOR EX INST\n         L     R1,AVMFLD2          GET OPCODE @\n         IC    R2,AVMFLDL2         GET LENGTH OF OPCODE\n         BCTR  R2,0                DECR BY ONE FOR EX INST\n         MVC   AVMSYMBL,AWBLANK    CLEAR PREVIOUS NAME\n         EX    R2,MCBDINM1         MOVE OPCODE TO AVMBL               A\n         MVC   AVMSYMLN,AVMFLDL2   MOEE LENGTH\n         USING MACLIB,RC\n         L     RC,AVMACLIB         GET @ OF MACLIB\n         $CALL MACFND              SEARCH MACRO LIBRARY\n         LTR   RB,RB               SYMBOL FOUND?\n         BZ    MCBDSTIN            PROCESS IF YES IN STRING CODE\n         LA    RE,$LMACLIB         GET LENGTH OF MACLIB ENTRY\n         $ALLOCL RD,RE,MCBODOVR    GET SPACE FOR ENTRY\n         ST    RD,MCLIBNXT         SAVE LINK IN PREV ENTRY\n         LR    RC,RD               MOVE BASE TO RC\n         MVC   MACLIB($LMACLIB),AWZEROS ZERO NEW ENTRY\n         MVC   MCLBNMLN(9),AVMSYMLN     MOVE NAME INTO LIB ENTRY\n         B     MCBDSTIN\nMCBDINM1 MVC   AVMSYMBL($),0(R1)   DUMMY FOR EXECUTE INSTRUCTION      A\n         DROP  RC                  CLEAR USING\n         SPACE 2\nMCBDSCAN EQU   *\n**--> INSUB:MCBDSCAN  SCANS STATEMENTS IN A MOCOR DEFINITION + + + + +A\n*+                                                                   +A\n*+  SETS DIFFERENT TRT TABLES UP DEPENDING ON WHERE CALLED FORM      +A\n*+   IN ROUTINE                                                      +A\n*+  CHECKS BSU LIST AS TO WHICH VARIABLES NEED CONCATINATION         +A\n*+  CREATES BSU & SETS FLAGS AS THE CONDITIONS WARRENT               +A\n*+  SCANS STRINGS AND PROCESSES EXPRESSIONS WITH & VARIABLES         +A\n*+                                                                   +A\n*+       NOTE: WE ASSUME THAT A PERIOD SHOWS CONCATENATION ONLY IF   +J\n*&       USED IMMEDIATELY AFTER A SET VAR/PARAMETER.                 +J\n*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +A\n         SPACE 2                                                      A\n         ST    RET,MCBDSAV         SAVE RETURN @\n         LA    RY,0(RB,RA)         GET DELIM @\n         LTR   RC,RC               LOOK FOR &'S?\n         BNZ   MCBDSC01            SKIP IF NO\nMCBDSC00 $SETRT ('&&',4)           SET TO STOP ONLY ON &              J\nMCBDSC01 EQU   *\n         LR    R0,RA               COPY SCAN POINTER\nMCBDSC0A EQU   *\n         XSNAP T=NO,STORAGE=(*AVRSBLOC,*AVRSBLOC+80,*0(RW),*8(RW)),   S#\n               LABEL=' MCBDSC0A ',IF=(AVTAGSM,O,AJOMACRH,TM)          S\n         LR    RB,RY               GET FINAL @ IN RB\n         SR    RB,RA               GET LENGTH IN RB\n         LR    R1,RY               COPY DELIM @ IN R1 FOR TRT\n         SR    R2,R2               CLEAR R2\n         IC    R2,0(RA)            GET 1ST CHAR\n         LA    RE,AWTZTAB(R2)      USE AS PNTR TO TRT TABLE\n         CLI   0(RE),X'04'         '&', '.' OR BLANK?\n         BE    MCBDSCMP            '&&' IF EQUAL\nMCBDSC02 EQU   *                   FALL THRU MEANS NONTERMIANL\n         TM    AVMBYTE2,$MOPRTR    PREV BSU = OPRTR?\n         BO    MCBDSC03            PROCEED IF YES\n         BAL   RET,MCBDCATI        ELSE INSERT CAT OPRTR\nMCBDSC03 EQU   *\n         EX    RB,MCBDTRSC         SCAN STRING\n         CLC   0(2,R1),=C'&&&&'    STOP ON DOUBLE &?\n         BNE   MCBDSC04\n         LA    RA,2(R1)            BUMP PAST &'S\n         B     MCBDSC0A            AND RESUME SCAN\nMCBDSC04 EQU   *\n         LR    RA,R0               ELSE GET START @\n         LR    RB,R1               MOVE DELIM@ TO RB\n         $CALL MCGTST              MOVE STRING TO LOW CORE\n         OI    MCBSFLGS,$MTERM+$BSCHAR  SET BSU FLAGS\n         MVI   MCBSINDX,$BSTRING   SET BSU INDEX\n         STC   RD,MCBSTRLN         STORE LEN IN BSU\n         ST    RC,MCBSLOC          SAVE @ OF STING IN BSU\n         NI    AVMBYTE2,255-($MTERM+$MOPRTR)  TURN OFF PREV IND FLAG\n         OI    AVMBYTE2,$MTERM     SET PREV FLAG TO TERM\n         BAL   RE,MCBDBMP          BUMP BSU OINTER\n         CR    RA,RY               END OF STRING?\n         BNL   MCBDSCFT            JUMP TO FOOT IF YES\n         B     MCBDSC01            ELSE RESUME SCAN\nMCBDSCMP EQU   *\n         CLI   1(RA),C'&&'         TWO '&&'S?\n         BNE   MCBDSCM1            CONTINUE IF NOT\n         LA    RA,2(RA)            BUMP SCN PNTR PAST &&'S\n         B     MCBDSC0A            AND RESUME SCAN\nMCBDSCM1 EQU   *\n         TM    AVMBYTE2,$MOPRTR    PREV BSU = OPRTR?\n         BO    MCBDSCM2            PROCEED IF YES\n         BAL   RET,MCBDCATI        ELSE INSERT CATEN OPRTR\nMCBDSCM2 EQU   *\n         OI    AVMBYTE4,$MINSTRN   SET IN STRING FLAG\n         LR    RC,RW               MOVE BSU PNTR TO RC\n          $SETRT ('&&',0)          CLEAR TRT TABLE FOR MACLEX         J\n         XSNAP T=NO,STORAGE=(*0(RW),*8(RW)),LABEL='MCBDSCAN -- BSU     #\n               BEFORE CALL TO MACLEX',IF=(AVTAGSM,O,AJOMACRH,TM)\n         $CALL MACLEX\n         LR    RW,RC               RESTORE BSU POINTER\n         LTR   RB,RB               ERROR?\n         BNZ   MCBDPRER            JUMP OUT IF YES\n         CR    RA,RY               SCAN FINI?\n         BNL   MCBDSCFT            JUMP OUT IF YES\n*              CHECK FOR . AFTER &VARIABLE - ONLY CASE IN WHICH .     J\n*              IS NOT AN ORDINARY CHARACTER.                          J\n         CLI   0(RA),C'.'          . AFTER &VARIABLE ?                J\n         BNE   MCBDSC00            NO, GO BACK FOR NEXT SCAN          J\n         LA    RA,1(,RA)      YES, BUMP OVER = CONCATENATION          J\n         B     MCBDSC00            GO BACK FOR NEXT CHARACTER         J\nMCBDSCFT EQU   *\n         $SETRT ('&&',0)      MAKE SURE TRT TABLE CLEARED             J\n         XSNAP T=NO,STORAGE=(*0(RW),*8(RW)),LABEL='MCBDSCAN -- BSU     #\n               BEFORE RETURN        ',IF=(AVTAGSM,O,AJOMACRH,TM)\n         L     RET,MCBDSAV         RESTORE RETURN @\n         BR    RET                 AND RETURN\nMCBDSAV  DS    F                   CORE FOR RETURN @\nMCBDTRSC TRT   0(0,RA),AWTZTAB     DUMMY TO SCAN STRING\n         SPACE 2\n*  ORDINARY COMMENT, SET UP BSU AND CRETE CODE                        A\n*                                                                     A\nMCBODCOM EQU   *\n         L     RD,MCBPRBSU         CREATE BSU                         A\n         OI    AVMBYTE2,$MOPRTR    SET PREV FLAG TO OPERTR\n         BAL   RE,MCBDBMP0         BUMP BSU POINTER                   A\n         SR    RB,RB\n         IC    RB,AVRSBLOC         GET LENGTH-1 OF STMT\n         S     RB,AWF3             DECR FOR STND PART\n         L     RA,MCBDSRPT         GET PNTR TO SOURCE\n         LA    RC,4                INDICATE NO TERMINAL CHARS\n         BAL   RET,MCBDSCAN        SCAN COMMENT STMT\n         L     RD,MCBDPR2          CREATE BSU                         A\n         BAL   RE,MCBDBMP0         BUMP BSU POINTER                   A\n         B     MCBODPRC            JUMP AND GENRATE CODE\n         TITLE '***MCBODY - MEND, PRINT, ERROR ETC. ROUTINES***'\n**--> INSUB:MCBDCATI    CREATE CONCOT BSU+ + + + + + + + + + + + + + +A\n*+                                                                   +A\n*+   CONCATENATION OPERATION NEEDED. IN CASE OF VARIABLES THAT       +A\n*+  HAVE TO BE COMBINED (IE IN SETC STMT)                            +A\n*+                                                                   +A\n*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +A\n         SPACE 2                                                      A\nMCBDCATI EQU   *                   ROUTINE TO INSERT CATEN OPRTR\n         L     RD,MCBDCAT          CREATE BSU                         A\n         NI    AVMBYTE2,X'FF'-($MTERM+$MOPRTR)  TURN OFF PREV BSU FLAG\n         OI    AVMBYTE2,$MOPRTR    SET PREV BSU FLAG\n         LR    RE,R14              COPY RETURN @ TO MCBDBMP0 REG      S\n*        *** FALL THRU INTO MCBDBMP0  --  MUST IMMEDIATELY FOLLOW *** S\n         SPACE 2\n**--> INSUB: MCBDBMP       BUMPS BSU POINTER + + + + + + + + + + + + +A\n*+                                                                   +A\n*+   CALLED WHENEVER BSU ADDED & NEED POINTER MOVED                  +A\n*+                                                                   +A\n*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +A\n         SPACE 2                                                      A\nMCBDBMP0 ST    RD,MCBSU            FILL IN BSU                        A\nMCBDBMP  EQU  *\n         XSNAP T=NO,STORAGE=(*0(RW),*8(RW)),LABEL='BSU - MCBDBMP',     #\n               IF=(AVTAGSM,O,AJOMACRH,TM)\n         LA    RW,8(RW)            BUMP BSU POINTER\n         C     RW,AVMCHLIM         WORK AREA EXCEEDED?\n         BL    MCBDBMP1            OK IF NOT\n         LA    RB,$ERVTMTR         ELSE SET TOO MANY TERMS FLAG\n         B     MCBDPRER            AND FLAG STATEMNT\nMCBDBMP1 EQU   *\n         MVC   MCBSU(8),AWZEROS    ZERO NEW BSU\n         BR    RE                  AND RETURN\n         SPACE  2\n*  OVERFLOW CALL EXIR ROUTINE                                         A\nMCBODOVR EQU   *\n         L     REP,AVMOVRFL        GET @ OF OVERFLOW ROUTINE\n         BR    REP                 BRANCH THERE\n         SPACE 2\nMCLMXDER EQU   *\n         L     RA,AVRSBPT          GET SOURCE BLOCK @\n         LA    RA,RSB$L(RA)        BUMP TO GET SOURCE STMT\n         LA    RB,$ERILCNV         SET ILLEGAL CONVERSION ERROR FLAG\n         B     MCBDPRER\n         EJECT                                                        S\n**--> INSUB:MCBDPR      PRINT STATEMENTS + + + + + + + + + + + + + + +A\n*+                                                                   +A\n*+  CALLED EACH TIME STATEMENTS NEEDS TO BE PRINTED. TEST FOR SEQ    +A\n*+  SYMBOL, IF PRESENT TEST FOR ALREADY DEFINED, IF NOT ENTER INTO   +A\n*+   LIST OF SYMBOLS & THEN PRINT, CONTINUES ' READING' STMTS        +A\n*+  AND STOPS WHEN MEND FLAG SET.                                    +A\n*+                                                                   +A\n*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +A\n         SPACE 2                                                      A\nMCBODPR0 BAL   RE,MCBDBMP0         BUMP BSU POINTER                   A\nMCBODPR  EQU   *\n         AIF   (&$DEBUG).MCBODPR\n         L     R1,AVMCHSTR         GET @ OF BSU WORKAREA\n         XSNAP LABEL='***BSU''S***',STORAGE=(*0(R1),*170(R1)),IF=(AVMSNX\n               BY1,O,$MSNP08,TM)\n.MCBODPR ANOP\n         USING MCSEQ,RC            SET USING FOR SEQ SYMBOL ENTRY\n         TM    MCLBFLG2,$MLCLFLG   DEFINITION TYPE STMT?              S\n         BC    12,MCBODPR1         IF YES, JUMP AND PRINT\nMCBODPRC EQU   *\n         LR    RC,RX               COPY MACLIB POINTER\n         $CALL MCGNCD              ELSE GENERATE CODE\n         AIF   (NOT &$MACOPC).MCBODYC   SKIP IF NOT OPEN CODE         S\n         TM    MCLBFLG2,$MCOCFL1   IN OPEN CODE ?                     S\n         BO    MCBODPR1            IF YES, SKIP PROCESSING            S\n.MCBODYC ANOP                                                         S\n         CLI   AVMFLDT1,C'.'       SEQ SYMBOL PRESENT?\n         BNE   MCBODPR1            JUMP AND PRINT IF NOT\n         SR    RE,RE\n         IC    RE,AVMFLDL1         GET LENGTH OF SYMBOL\n         BCTR  RE,0                REDUCE FOR EX INSTRUCTION\n         L     RA,AVMFLD1          GET @ OF SEQ LABEL\n         MVC   AVMSYMBL,AWBLANK    BLANK OUT COMMON AREA\n         EX    RE,MCBDPR1          EX MOVE INSTRUCTION                A\n         L     RC,AVMSEQPT         GET POINTER TO SEQ SYM ENTRIES\n         $CALL MACFND              SEARCH SYMBOL DICT\n         LTR   RB,RB               PRESENT?\n         BZ    MCBODPR2            JUMP IF YES\n         LA    RB,$LMCSEQ          ELSE GET LENGTH OF ENTRY\n         $ALLOCH R1,RB,MCBODOVR    GET SPACE FOR ENTRY\n         ST    R1,MCSEQNXT         STORE POINTER IN PREV ENTRY\n         LR    RC,R1               MOVE BASE TO NEW ENTRY\n         MVC   MCSEQNAM,AVMSYMBL   MOVE NAME INTO ENTRY\n         OI    MCSEQFLG,X'FF'      SET DEFINED FLAG\n         MVC   MCSEQNXT,AWZEROS    ZERO LINK POINTER\n         MVC   MCSEQVAL,AVMCRINS   MOVE INST @ INTO ENTRY\n         B     MCBODPR1            JUMP AND PRINT\nMCBODPR2 EQU   *\n         CLI   MCSEQFLG,X'FF'      ALREADY DEFINED?\n         BNE   MCBODPR3            JUMP AND PROCESS IF NOT\n         LA    RB,$ERMULDF         ELSE SET MULT DEF FLAG\n         $CALL ERRLAB              AND FLAG STATEMENT\n         B     MCBODPR1            PRINT STMNT\nMCBODPR3 EQU   *\n         L     RE,MCSEQVAL         GET @ OF INST\n         USING MCOPQUAD,RE         SET USING FOR ONE OP ENTRY\nMCBODPR4 EQU   *\n         MVC   MCARG2LC,AVMCRINS   MOVE INST @ INTO ONE OP ENTRY\n         L     RE,MCRESULT         GET NEXT POINTER\n         LTR   RE,RE               POINTER PRESENT?\n         BNZ   MCBODPR4            IF YES, UPDATE NEXT ENTRY IN LIST\n         MVI   MCSEQFLG,X'FF'      ELSE SET DEFINED FLAG IN ENTRY\n         MVC   MCSEQVAL,AVMCRINS   SET VALUE IN ENTRY\n         DROP  RE\n         SPACE\nMCBODPR1 EQU   *\n         AIF   (NOT &$MACOPC).MCBODYD   SKIP IF NOT OPEN CODE         S\n         TM    AVPRINT1,AVPRSAVE   LISTING CONTROL = SAVE ?           S\n         BNO   MCBODP1A            BRANCH IF NOT                      S\n         SR    RE,RE               ZERO  FOR BYTE REGS USE            A\n         IC    RE,AVRSBLOC         GET LENGTH-1                       A\n         SH    RE,=AL2(RSB$L)      DECREMENT LENGTH FOR MXMVSR        A\n         STC   RE,AVRSBLOC         RESTORE IT                         A\n         $CALL MXMVSR              SAVE STATEMENT                     A\n         B     MACBODRT            RETURN                             S\nMCBODP1A EQU   *                                                      S\n.MCBODYD ANOP                                                         S\n         LA    RB,$OUCOMM\n         $CALL OUTPT2              PRINT STATEEMNT\n         CLI   OPCHEX,$MEND        MEND STATEMENT?\n         BE    MACMEND1            CLEAN UP IF YES\n         B     MCBOD01             ELSE READ NEXT STMNT\n         DROP  RC\n         SPACE 2\nMCBDCHLB EQU   *\n         ST    RET,MCBDCHSV        SAVE RETURN ADDRESS\n         CLI   AVMFLDT1,C'.'       SEQ SYMBOL?\n         BE    MCBDCHFT            OKAY IF YES\n         CLI   AVMFLDL1,X'00'      NO LABEL?\n         BE    MCBDCHFT            OKAY ALSO\n         LA    RB,$ERILLAB         ELSE SET BAD LABEL FLAG\n         $CALL ERRLAB              AND FLAG STMT\nMCBDCHFT EQU   *\n         L     RET,MCBDCHSV        RESTORE RETURN @\n         BR    RET                 AND RETURN\nMCBDCHSV DS    F                   CORE FOR RETURN @\nMCBDPR1  MVC   AVMSYMBL($),0(RA)   DUMMY MOVE FOR LABEL               A\n         SPACE 2\nMCGBINVD LA    RB,$ERINVDM         INVALID DLM                        A\n         B     MCBDPRER            GO FLAG ERROR                      A\n         SPACE 1                                                      A\nMCGBMD   L     RA,AVMTSCNP         GET @ OF 1ST CHAR OF VAR NAME      A\n         LA    RB,$ERMULDF         SHOW MULTIPLR DEFN                 A\n         B     MCBDPRER            GO FLAG                            A\n         SPACE 1                                                      A\nMCBDOPER EQU   *\n         LA    RA,AVRSBLOC+RSB$L+20 GUESS AT OPRND ADDRESS            A\n         LA    RB,$ERNOOPR         SET NO OPRND FLAG\n         SPACE 2\n*                                                                     S\n*  PRINTS AN APPROPRIATE MESSAGE & SETS ERR INDX IN BSU               A\n*                                                                     A\nMCBDPRER EQU   *\n         L     RW,AVMCHSTR         SET BSU PNTR TO START OF WORK AREA\n         LR    RD,RA               COMPUT OFFSET                      A\n         S     RD,AVRSBPT                                             A\n         SLL   RD,8                MOVE TO RIGHT BYTE                 A\n         AL    RD,MCBDERR                                             A\n         BAL   RE,MCBDBMP0         BUMP BSU POINTER                   A\n         $CALL ERRTAG              FLAG STMNT\n         B     MCBODPR             JUMP AND PRINT STATEMENT\n         SPACE 2\nMCBDISER EQU   *\n         LA    RB,$ERINVSY         SET INVALID SYMBOL FLAG\n         B     MCBDPRER            AND FLAG STATEMENT\n         SPACE 2\n*                                                                     A\n*        END OF ROUTINE, SET OP POINTERS TO ONE-OP ENTRIES PRINTS     A\n*    OUT ERROR MESSAGES & DEBUG ADDRESS FOUND & STORED                A\n*                                                                     A\nMACMEND1 EQU   *\n         USING MCOPQUAD,RE\n         USING MCSEQ,RC\n         L     RC,AVMSEQPT         GET @ OF SEQ SYM LIST\n         USING RSBLOCK,RZ          NOTE USING FOR OUTPPUT RECORD\n         L     RZ,AVRSBPT          SET BASE FOR OUTPUT RECORD\n         MVC   RSBLOCK(RSB$L+L'MCMNERMS),MCMNERMF   SET FLAGS         S\nMACMEND2 EQU   *\n         CLI   MCSEQFLG,X'FF'      SYMBOL DEFINED?\n         BNE   MACMEND3            PROCESS IF NOT\nMACMENDN EQU   *\n         L     RC,MCSEQNXT         SET BASE TO NEXT ENTRY\n         LTR   RC,RC               LAST ENTRY?\n         BNZ   MACMEND2            IF NOT, RESUME SEARCH\n         B     MACMEND5            ELSE JUMP TO FOOT\nMACMEND3 EQU   *\n         L     RE,MCSEQVAL         GET @ OF ONE OP ENTRY\nMACMEND4 EQU   *\n         MVC   RSBSOURC+L'MCMNERMS(6),AWEP6   PUT EDIT MASK IN OUTPUT\n         L     R1,MCRESULT         COPY LINK TO NXT SEQ ERROR TEMP\n         L     RE,MCARG2LC         MOVE BASE TO 1ST ONE-OP\n         ED    RSBSOURC+L'MCMNERMS(6),MCQSTMNO    EDIT STMT NBR TO FLD\n         MVI   MCQS1FLG,$BSERR01   SET ERROR MSG OPCODE               A\n         LA    RB,$OUCOMM          SET PRINT FLAG\n         LR    R0,RC               COPY RC TEMPORARILY\n         $CALL OUTPT2              PRINT ERROR MESSAGE\n         LR    RC,R0               RESTORE RC\n         LTR   RE,R1               SET BASE TO NEXT SEQ ERR ENTRY     S\n         BNZ   MACMEND4            PRINT NEXT MESSAGE IF NOYT\n         B     MACMENDN            RESUME SCAN OF SEQ SYMBOL DICT\nMACMEND5 EQU   *\n         LA    RC,$LMCSEQ           GET LENGTH OF SEQ ENTRY\n         L     R1,AVADDHIH         GET PNTR FOR DEBUG STMNT\n         A     RC,AVMSEQPT         ADD ORIGINAL POINTER\n         ST    RC,AVADDHIH         RELEASE STORAGE IN HIGH END\n         SPACE 2\nMACBODRT EQU   *\n         AIF   (&$DEBUG).MACBODR\n         L     R2,AVMSEQPT         GET @ OF SEQ SYM TABLE FOR DEBUG\n         XSNAP LABEL='***MCBODY EXITED***',STORAGE=(*0(R1),*0(R2)),IF=(X\n               AVMSNBY1,O,$MSNP07,TM)\n.MACBODR ANOP\n         SR   RB,RB                CLEAR RB FOR RETURN\n         $RETURN  RGS=(R14-R6)\nMCBDSRPT DS    F                   WORD FOR RSBSOURC @\nMCB##SAV DS    F                   RETURN @ FROM MCB## ROUTINES       J\nMCBPRBSU DC    AL1($MOPRTR,$BSPRINT,0,$MPRNTHR)    PRINT BSU\nMCBPRBSV DC    AL1($MOPRTR+$MPRCOM,$BSPRINT,0,$MPRNTHR) COMMENT PRM   A\n*        ***** BSU TABLE - FIRST FULLWORDS OF MANY BSU'S. *****       J\nMCBDERR  DC    AL1($MOPRTR,$BSERR01,0,$MPRNTHR)                       A\nMCBDSET  DC    AL1($MOPRTR,$BSETA,0,$MSETHR)                          A\nMCBDAGO  DC    AL1($MOPRTR,$BSAGO,0,$MAGOHR)                          A\nMCBDSTG1 DC    AL1($MTERM+$BSCHAR,$BSTRING,0,11),A(MCMNOTMS) WHOLE BS J\nMCBDSTG2 DC    AL1($MTERM+$BSCHAR,$BSTRING,0,2),A(MCMNOT1C) WHOLE BSU J\nMCBDPR2  DC    AL1($MOPRTR,$BSMVSTM,0,$MPRNTHR)                       A\nMCBDPR3  DC    AL1($MOPRTR,$BSMVSTM+$BSMNTER,0,$MPRNTHR)              A\nMCBDAIF  DC    AL1($MOPRTR,$BSAIF,0,$MAIFHR)                          A\nMCBDCAT  DC    AL1($MOPRTR,$BSCAT,0,$MCATHR)                          A\nMCBDINMA DC    AL1($MOPRTR,$BSINMAC,0,$MPRNTHR)  INNER MACRO BSU      A\nMCBDLABL DC    AL1($MTERM,$BSLABEL,0,0)                               A\nMCMNERMF DC    AL1(L'MCMNERMS+RSB$L+6,$RSBNPNN+$RSBMERR,1,0)          A\nMCMNERMS DC    C'220  UNDEFINED SEQUENCE SYMBOL IN STATEMENT'\n         LTORG\n         DROP  RAT,RW,RX,R13,RC,RZ,RE\n         TITLE '***MACLEX - LEXICAL SCAN OF EXPRESSIONS***'\n**-->  CSECT:  MACLEX   THIS PROCEDURE SCANS A MCRO STATEMENT AND     *\n*.        CONVERTS IT INTO BSU'S.  ALSO CHECKS FOR SUCH ERRORS AS TWO *\n*.        TERMS OR TWO OPERATORS IN A ROW.  WHERE NECESSARY IT INSERTS*\n*.        CATENATION OPERATORS WHERE CATENATION IS IMPLICIT           *\n*.                                                                    *\n*.        ENTRY CONDITIONS                                            *\n*.     RA = @ OF FIRST CHARACTER OF EXPRESSION                        *\n*.     RC = @ ON NEXT AVAILABLE BSU IN WORKSPACE                      *\n*.                                                                    *\n*.        EXIT CONDITIONS                                             *\n*.     RA = @ OF DELIM PAST EXPRESSION IF NO ERROR                    *\n*.        = @ OF ERROR IF ERROR PRESENT                               *\n*.     RB = 0 IF OKAY                                                 *\n*.        = $ERMSSGE IF ERROR                                         *\n*.     RC = @ OF NEXT AVAILABLE SPACE FOR BSU                         *\n*.                                                                    *\n*.        CALLS MCGTST,MCDTRM,SDBCDX,MCSYSR,MCATRM,MCGTST             *\n*.        USES DSECTS: AVWXTABL,MCBSU,MCPARENT,MCGLBDCT,MCLCLDPV      *\n*.        USES MACROS: $SAVE,$RETURN,$ALLOCL,$SCOF,$SCPT,$CALL,$SETRT *\n*.                                                                    *\n*.       REGISTER USAGE                                               A\n*.        WORK REGS: R0,R1,R2,RY,RZ,RB,RC,RE                          A\n*.        USED FOR TRT: R1,R2                                         A\n*.        RW-BASE REG FOR BSU                                         A\n*.        R13 BASE REG FOR THIS CSECT                                 A\n*.        RAT- BASE REGISTER FOR MAIN TABLE                           A\n*.       RX-UNUSED                                                    A\n*.       RD-?                                                         A\n*.                                                                    A\n*** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 2\nMACLEX   CSECT\n         $SAVE RGS=(R14-R6),SA=*,BR=13\n         USING AVWXTABL,RAT        NOTE MAIN TABLE USING\n         XSNAP LABEL='***MACLEX ENTERED***',T=NO,IF=(AVMSNBY2,O,$MSNP09X\n               ,TM)\n         USING MCBSU,RW            SET USING FOR BSU ENTRY\n         LR    RY,RC               COPY ADDR OF NEXT BSU              A\n         S     RY,=F'8'            GET ADDR OF PRECIOUS POINTER       A\n         MVC   MCBSFLGP(4),0(RY)   MOVE PREV BSU INTO WORK AREA       A\n         SR    RY,RY               USE RY FOR PAREN COUNT\n         LR    RW,RC               GET @ OF SPACE FOR BSU\n         MVI   AVMDWRK4,X'00'      CLEAR PAREN INFO BYTE\n         MVC   MCBSU(8),AWZEROS    BLANK OUT ENTRY\n         NI    AVMBYTE1,X'FF'-$MINQUOT   CLEAR QUOTE FLAG\n         NI    AVMBYTE2,X'FF'-$MTERM    MAKE SURE TERM FLG IS OFF\n         OI    AVMBYTE2,$MOPRTR    SET OPERATOR FLAG FOR START\n         $SETRT ('''',26,'&&',28,'.',30)  SET TRT TABLE FOR QUOTE SCAN\n         MVI   AWTDECT+C'+',18\n         MVI   AWTDECT+C'-',20\n         MVI   AWTDECT+C'/',22     MODIFY AWTDECT TABLE FOR TEMPORARY\n         MVI   AWTDECT+C')',24     USE IN LEXICAL SCAN.  THIS SAVES\n         MVI   AWTDECT+C'''',26    CREATING A NEW TABLE.\n         MVI   AWTDECT+C'&&',28\n         MVI   AWTDECT+C'.',30\n         B     MCLXSTR0            JUMP TO LOOKUP CHAR ROUTINE        A\nMCLEXBAS DS    0H\n         SPACE 2\nMACLINDX $AL2  MCLEXBAS,(MCLDIGIT,MCLEXERR,MCLSDTRM,MCLALPHA,MCLMULT,MCX\n               LEQUAL,MCLXLPAR,MCLCOMMA,MCLBLANK,MCLPLUS,MCLMINUS,MCLDIX\n               VID,MCLXRPAR,MCLQUOTE,MCLAMPRS,MCLPEROD)\n         SPACE 2\n*  TRT  TABLE SET-UP, LOOK UP CHARACTER OF EXPRESSIO AND GO TO THE    A\n* ROUTINE TO PROCESS THE EXPRESSION.                                  A\nMCLXSTRS EQU   *                                                      S\n         LA    RA,1(R1)            BUMP SCAN POINTER                  S\nMCLXSTRT EQU   *\nMCLXSTR0 EQU   *                                                      A\n         LR    R0,RA               COPY SCAN POINTER\nMCLXSCAN EQU   *\n         SR    R1,R1               ZERO R1 FOR TRT USE\n         SR    R2,R2               USE R2 IN TRT INST\n         TM    AVMBYTE1,$MINQUOT   INSIDE QUOTES?\n         BO    MCLX01              USE LIMITEE TRT IF YES\nMCLX03   EQU   *\n         TRT   0(1,RA),AWTDECT     LOOKUP NEXT CHAR\n         B     MCLX02              AND JUMP TO GET ROUTINE\nMCLX01   EQU   *\n         TM    AVMBYTE2,$MINAPAR+$MDIMVAR  PAREN EXPRESSSION EXPECTED?\n         BC    5,MCLX03            IF YES, USE REGULAR TRT\n         TRT   0(200,RA),AWTZTAB\nMCLX02   EQU   *\n         LH    RE,MACLINDX(R2)     GET HALFWORD OFFSET FROM TABLE\n         B     MCLEXBAS(RE)        ADD TO BASE AND JUMP TO ROUTINE\n         SPACE 2\n* DIGIT FOUND, CHECK TO SEE IF PROPER CONST, CONVERT IT, SET UP       A\n*  BSU WITH CONSTANT VALUE, DECREMENT # BSU COUNTER & PROCESS         A\nMCLDIGIT EQU   *\n         TM    AVMBYTE2,$MINARIT+$MINAPAR+$MINBOOL CONSTANT OKAY?\n         BZ    MCLXSYER            IF NOT, JUMP AND FLAG\n         $CALL MCDTRM              CONVERT CONSTANT\n         LTR   RB,RB               OK?\n         BNZ   MCLXERTN             RETURN IF NOT\n         MVI   MCBSINDX,$BSIMMA    SET IMMED ARITH INDEX\n         OI    MCBSFLGS,$BSAR      INDICATE ARITH IN BSU\n         ST    RC,MCBSVALU         STORE VALUE IN BSU\n         S     RC,AWF1             DECR BY 1\n         BH    MCLXTRMF            IF > 1 THEN FINI\n         OI    MCBSFLGS,$BSBOOL    ELSE FLAG AS BOOLEAN CONSTANT ALSO\n         B     MCLXTRMF            JUMP TO TERM FOOT\n         SPACE 2\n*  POSSIBLE SELF DEFINING TERM, CHECK NEXT CHAR, IF QUOTE, ALPHA,     A\n*  ELSE CHECK FOR OK SDT.-SETS FLAGS ETC.                             A\nMCLSDTRM EQU   *\n         CLI   1(R1),C''''         NEXT CHAR = '?\n         BNE   MCLALPHA            PROCESS ALPHA IF NOT\n         $CALL SDBCDX              CHECK FOR SELF DEFINING TERM\n         LTR   RB,RB               OKAY?\n         BM    MCLALPHA            MAY BE L', BRANCH                  A\n         BP    MCLXERTN            BAD SDTERM IF RB > 0               A\n         TM    AVMBYTE2,$MINARIT+$MINAPAR+$MINBOOL  IN OKAY EXPRESSION?\n         BZ    MCLXSYER            ERROR IF NOT\n         OI    MCBSFLGS,$BSAR+$MTERM  SET TYPE TO ARITH TERM\n         MVI   MCBSINDX,$BSIMMA    SET TO ARITH IMMED TYPE INDEX\n         ST    RC,MCBSVALU         STORE VALUE IN BSU\n         B     MCLXTRMF            JUMP TO TERM FOOT\n         SPACE 2\n*  ALPHA CHAR FOUND, CK ARITH EXPRESSION, PROCESS  IF IS, NEXT        A\n*  CK  TYPE ATTR, ERROR  IF NOT FIRST CHAR OF OPRND  ALSO IF  (       A\n*  SETS SYSLIST FLAG  SEARCHES ATTRIBUTES IN DICTIONARY               A\nMCLALPHA EQU   *\n         TM    AVMBYTE2,$MINARIT+$MINBOOL+$MINAPAR   IN ARITH EXPRES?\n         BM    MCLALPH0            PROCEED IF YES\n         C     R1,AVMFLD3          BEGINNING OF OPRND?\n         BNE   MCLXSYER            ERROR IF NOT\n         CLC   0(2,R1),=C'T'''     T' ATTIBUTE?\n         BNE   MCLXSYER            ERROR IF NOT\nMCLALPH0 EQU   *\n         CLI   1(R1),C''''         NEXT CHAR = QUOTE?\n         BNE   MCLRELOP            IF NOT TEST FOR RELOP\n         $CALL MCATRM              IS IT AN ATTRIBUTE?\n         LTR   RB,RB\n         BM    MCLXSYER            IF NOT, SET SYNTAX EROR FLAG\n         BP    MCLXERTN           NOT IMPLEMENTED\n         STC   RC,MCBSINDX         STORE TYPE OF ATTRIB IN BSU\n         $CALL MCSYSR              SEARCH DICTIONARIES\n         LTR   RB,RB\n         BM    MCLXISER            INVALID SYMBOL IF MINAS\n         BP    MCLXERTN            NOT DEFINED IF RB > 0\n         LA    RB,$SYMPAR          LOAD SYMBOLIC PARAM FLAG\n         CR    RD,RB               IS IT SYM PAR?\n         BE    MCLA01              IF YES PROCEED\n         USING MCPARENT,RC         NOTE USING FOR ENTRY\n         LA    RB,$SYSVAR          NEXT CHECK FOR SYSTEM VARIABLE\n         CR    RB,RD\n         BNE   MCLXISER            IF NOT, FLAG ERROR\n         CLI   MCPARNLN,8          MUST BE &SYSLIST WITH LENGTH 8\n         BNE   MCLXISER            ERROR IF NOT\n         MVC   MCBSVALU,AWFM1      INDICATE &SYSLIST WITH -1\n*   N'&SYSLIST CAN STAND ALONE SO CHECK FOR LEFT PAREN\n         CLI   MCBSINDX,$BSATN     ATTRIB = N'?\n         BNE   MCLALPH2            PROCEED IF NOT\n         CLI   0(RA),C'('          NEXT CHAR = '('?\n         BNE   MCLXTRMF            PROCESS IF NOT\nMCLALPH1 EQU   *\n         MVI   AVMDWRK4,$MINSYSL   SET &SYSLIST FLAG IF PAREN\n         B     MCLXTRMF\nMCLALPH2 EQU   *\n         CLI   0(RA),C'('          NEXT CHAR = LEFT PAREN?\n         BE    MCLALPH1            T' OR K' REQUIRE PAREN\n         B     MCL$ERI                                                S\n         SPACE\n*  SYMBOLIC PARAMETER FOUND  SET UP BSU, AND CHK LEGALITY             A\nMCLA01   EQU   *\n         LH    R2,MCPARNDX         GET SYMBOLIC PARAM ID\n         ST    R2,MCBSVALU         STORE IN BSU\n         CLI   0(RA),C'('          NEXT CHAR  IS '('?\n         BNE   MCLXTRMF            JUMP TO FOOT IF NOT\n         OI    AVMBYTE2,$MDIMVAR   ELSE SET DIM VAR FLAG\n         CLI   MCBSINDX,$BSATN     N' ATTRIB?\n         BNE   MCLXTRMF            OKAY IF NOT\nMCL$ERI  LA    RB,$ERILAT          SET BAD ATTRIB FLAG                S\n         B     MCLXERTN            AND RETURN\n      SPACE 2                                                         A\n*   RELATIONAL OPERATOR FOUND, IF ^BOOL ERROR, ELSE GET OPERAND LENGTHA\n*   AND LOOK UP IN TABLE FOR OPERATION WHEN LEGAL OPERATOR  FOUND,    A\n*   SET UP BSU                                                        A\nMCLRELOP EQU   *\n         TM    AVMBYTE2,$MINBOOL   IN BOOLEAN EXPRESSION?\n         BNO   MCLXSYER            IF NOT, REL OPCODE NOT ALLOWED\n         TRT   0(4,RA),AWTSYMT     SCAN STRING FOR DELIM\n         BZ    MCLXSYER            ERROR IF > 3 CHARS\n         LR    R2,R1               COPY DEIIM @\n         SR    R2,RA               GET LENGTH OF STRING\n         BCT   R2,MCLARL01         DECR FOR EX INST\n         B     MCLXSYER            ERROR IF ONE CHAR\nMCLARL01 EQU   *\n         LA    RE,MCRLOPTB         GET @ OF CONSTANT TABEL\nMCLARL02 EQU   *\n         EX    R2,MCLACMPR         COMPARE WITH NEXT ENTRY\n         BE    MCLARL03            FOUND IF EQUAL\n         BL    MCLXSYER            NOT PRESENT IF <\n         LA    RE,5(RE)            BUMP TABLE POINTER\n         B     MCLARL02            RESUME SEARCH OF TABEL\n         SPACE\nMCLARL03 EQU   *\n         MVC   MCBSINDX,3(RE)      SET INDEX\n         MVC   MCBSHIER,4(RE)      SET HIERARCHY IN BSU\n         LR    RA,R1               BUMP SCAN POINTER\n         B     MCLXOPRF            JUMP TO OPRTR FOOT\n         SPACE 2\nMCLACMPR CLC   0(0,RA),0(RE)       COMPARE STRING WITH TABLE ENTRY\nMCRLOPTB DC    C'AND',AL1($BSAND,$MANDHR),C'EQ ',AL1($BSEQ,$MRELHR)\n         DC    C'GE ',AL1($BSGE,$MRELHR),C'GT ',AL1($BSGT,$MRELHR)\n         DC    C'LE ',AL1($BSLE,$MRELHR),C'LT ',AL1($BSLT,$MRELHR)\n         DC    C'NE ',AL1($BSNE,$MRELHR),C'NOT',AL1($BSNOT,$MNOTHR)\n         DC    C'OR ',AL1($BSOR,$MORHR),C'999'\n         DROP RC\n         SPACE 2\n*   NEXT BLOCKS WHEN  +,-,/,OR * FOUND, SETS HIERARCHY AND SETS UP    A\n*   THE BSU'S                                                         A\nMCLMULT  EQU   *\n         MVI   MCBSINDX,$BSMULT    SET INDEX TYPE IN BSU\nMCLMHIER EQU   *\n         MVI   MCBSHIER,$MMULTHR   SET MULT/DIVID HIERARCHY\n         B     MCLXARFT            JUMP TO ARITH OPRTR FOOT\n         SPACE 2\nMCLDIVID EQU   *\n         MVI   MCBSINDX,$BSDIV     SET BSU INDEX FOR DIVIDE\n         B     MCLMHIER            JUMP AND SET HIERARCHY\n         SPACE 2\nMCLPLUS  EQU   *\n         MVI   MCBSINDX,$BSPLUS    SET ADDITION INDIX IN BSU\nMCLPHIER EQU   *\n         MVI   MCBSHIER,$MPLUSHR    SET HIERARCHY OF OPRTR\n         B     MCLXARFT            JUMP TO ARITH FOOT\n         SPACE 2\nMCLMINUS EQU   *\n         MVI   MCBSINDX,$BSMIN     SET MINUS INDEX IN BSU\n         B     MCLPHIER            JUMP AND SET SAME HIERARCHY AS PLUS\n         SPACE 2\n*   CK  IF ARITH EXPRESSION, ERROR IF NOT                             A\nMCLXARFT EQU   *\n         TM    AVMBYTE2,$MINARIT+$MINAPAR+$MINBOOL  IN ARITH EXPRESSION\n         BZ    MCLXSYER            ERROR IF NOT\n         LA    RA,1(R1)            BUMP SCAN POINTER\n         B     MCLXOPRF            JUMP TO OPERATOR FOOT\n         SPACE 2\n         SPACE 2\n*   LEFT  PAREN FOUND CHECK IF NESTING LEVEL OK, , CHKS & BRANCHES TO A\n*   SEE IF 1)SUBSCRIPTED VAR,2)IN SUBSTRING,3)OR SYSLIST              A\nMCLXLPAR EQU   *\n         LA    RY,1(RY)            BUMP PAREN COUNT\n         C     RY,=F'6'            CHECK NEXTING LEVEL\n         BL    MCLXLP01            OKAY IF < 6\n         LA    RB,$ERVPARN         ELSE SET TOO MANY PAREN FLAG\n         B     MCLXERTN            AND RETURN\nMCLXLP01 EQU   *\n         LA    RZ,AVMDWRK4(RY)     USE RZ AS PNTR TO CURRENT PAREN\n         TM    AVMDWRK4,$MINSYSL   IS &SYSLIST FLAG ON?\n         BO    MCLXSBSL            IF YES MUST BE &SYSLIST PAREN\n         TM    AVMBYTE2,$MDIMVAR   PREV BSU = DIMEN VARIABLE?\n         BO    MCLXSBSC            IF YES, MUST BE SUBSCRIPT LP\n         BCTR  R1,0                DECR POINTER\n         CLI   0(R1),C''''         PREV CHAR = QUOTE?\n         LA    R1,1(R1)            RESTORE POINTER BEFORE TEST\n         BE    MCLXSBST            IF YES MUST BE SUBSTRING LP\n         TM    AVMBYTE2,$MOPRTR    PREV BSU = OPRTR?\n         BNO   MCLXSYER            ERROR IF NOT\n         MVI   0(RZ),X'00'         CLEAR FIRST BYTE OF PAREN INFO\n         MVI   MCBSINDX,$BSLPAR    ELSE MUST BE LEFT PAREN\n         B     MCLXPARF            JUMP TO L PAREN FOOT\n         SPACE\n*   SUBSCRIPT  CHECK                                                  A\nMCLXSBSC EQU   *\n         MVI   0(RZ),$MINSBSC      IDENTIFY PAREN LEVEL\n         MVI   MCBSINDX,$BSBSCRP   SET BSU INDEX\n         OI    AVMBYTE2,$MINAPAR   INDICATE INSIDE ARITH PARENS\n         B     MCLXPARF            JUMP TO PAREN FOOT\n         SPACE\n*   SYSLIST CHECK                                                     A\nMCLXSBSL EQU   *\n         MVI   0(RZ),$MINSYSL      SET PAREN ID TO SYSLIST\n         MVI   MCBSINDX,$BSBSYL    SET BSU INDEX ALSO\n         OI    AVMBYTE2,$MINAPAR   INDICATE INSIDE ARITH PARENS\n         CLI   MCBSINDP,$BSATN     IS IT THE N'                       A\n         BNE   MCLXPARF            PROCEED IF NOT\n         MVI   0(RZ),$MINSBSC      ELSE SET FLAG TO STOP 2 SUBSCRIPTS\n         B     MCLXPARF            JUMP TO L PAREN FOOT\n         SPACE\n*   SUBSTRING CHECK                                                   A\nMCLXSBST EQU   *\n         MVI   0(RZ),$MINSBST      INDICATE PAREN IS SUBSTRING START\n         MVI   MCBSINDX,$BSBSTR    SET BSU INDEX ALSO\n         OI    AVMBYTE2,$MINAPAR   ALSO INDICATE INSIDE ARITH PARENS\n         B     MCLXPARF            JUMP TO L PAREN FOOT\n         SPACE\n*   FOOT FOR LEFT PAREN                                               A\nMCLXPARF EQU   *\n         LA    RA,1(R1)            BUMP SCAN POINTER PAST (\n         MVI   MCBSHIER,$MPARHR    SET PAREN HIERARCHY\n         NI    AVMBYTE2,X'FF'-$MDIMVAR   TURN OFF DIMVAR FLAG\n         MVI   AVMDWRK4,X'00'      TURN OFF SYSLIST FLAG\n         B     MCLXDLMF            JUMP TO DELIM/OPRTR FOOT\n         SPACE 4\n* RIGHT PAREN FOUND CHECKS FOR RIGHT NUMBER AF ARGUMENTS, SEES IF     A\n* CORRECT NESTING MOVES SUBSCIPTS INTO BSU, ALWAYS PROCESSED INFO     A\n* AND CHECKS FOR MATCHED PARENS(N'LPREN=N'RPAREN)                     A\n*                                                                     A\nMCLXRPAR EQU   *\n         LA    RZ,AVMDWRK4(RY)     GET @ CURRENT PAREN INFORMATION    J\n         TM    0(RZ),$MINSBST      IN SUBSTRING?\n         BNO   MCLXRP01            PROCEED IF NOT\n         TM    0(RZ),$MINSBST+X'01'     TWO ARGUMENTS?\n         BNO   MCLCOMR1                                               S\nMCLXRP01 EQU   *\n         TM    AVMBYTE2,$MTERM     PREV BSU = TERM?\n         BO    MCLXRP02            OKAY IF YES\n         CLI   MCBSINDP,$BSRPAR    MUST BE RIGHT RAREN                A\n         BNE   MCLXSYER            ERROR IF NOT )\nMCLXRP02 EQU   *\n         MVC   MCBSLOC+3(1),0(RZ)  MOVE NBR OF SUBSCRIPTS INTO BSU\n         S     RY,AWF1             DECR PAREN COUNT\n         BP    MCLXRP03            OKAY IF STILL POSITIVE\n         BM    MCLXSYER            ERROR IF NEGATIVE\n         NI    AVMBYTE2,X'FF'-$MINAPAR  TURN OFF ARITH EXPRESSION FLAG\n         TM    AVMBYTE2,$MINPEXP   END OF EXPRESSI6N?\n         BO    MCLXRP04            IF YES RETURN\n         B     MCLXRP06            RETURN IF PAREN COUNT IS ZERO\nMCLXRP03 EQU   *\n         BCTR  RZ,0                DECR POINTER TO PAREN INFO\n         LR    RE,RY               COPY PAREN COUNT INTO RE\nMCLXRP05 EQU   *\n         TM    0(RZ),$MINSBST+$MINSBSC+$MINSYSL  IN ARITH EXPRESSION?\n         BM    MCLXRP06            IF YES RETURN\n         BCTR  RZ,0                ELLE DECR POINTER AGAIN\n         BCT   RE,MCLXRP05         DECR PAREN COUNT\n         NI    AVMBYTE2,X'FF'-$MINAPAR  TURN OFF ARITH FLAG IF ZERO\nMCLXRP06 EQU   *\n         MVI   MCBSINDX,$BSRPAR    SET RIGHT PAREN INDEX IN BSU\n         LA    RA,1(RA)            BUMP POINTER PAST PAREN\n         B     MCLXDLMF\n         SPACE\nMCLXRP04 EQU   *\n         MVI   MCBSINDX,$BSRPAR    SET INDEX IN BSU\n         MVI   MCBSHIER,$MPARHR    SET HIERARCHY\n         OI    MCBSFLGS,$MOPRTR    SET OPRTR FLAG IN BSU\n         $SCOF RB,RA,MCBSOFST      GET OFFSET IN BSU\n         LA    RA,1(R1)            BUMP SCAN POINTER\n         BAL   RE,MCLXBMP          BUMP BSU\n         NI    AVMBYTE2,X'FF'-$MINPEXP  TURN OFF PAREN EXPR FLAG\n         B     MCLXFOOT            RETURN\n         SPACE 2\n* COMMA FOUND, CHECKS VALIDITY AND FLAGS ERRORS                       A\n*                                                                     A\nMCLCOMMA EQU   *\n         LTR   RY,RY               ARE WE IN PARENS?\n         BZ    MCLXSYER            ERROR IF NOT\n         LA    RZ,AVMDWRK4(RY)     GET PTR TO PAREN INFO              A\n         TM    0(RZ),$MINSBST+$MINSYSL  IN SUBSTR OR SYSLIST?\n         BM    MCLCOM01            OKAY IF YES\nMCLCOMR1 EQU   *\n         LA    RB,$ERINSBV        ELSE SET WRONG NBR ARGS FLAG\n         B     MCLXERTN            AND RETURN\nMCLCOM01 EQU   *\n         TM    0(RZ),X'01'         ONE ARG ALREADY PROCESSED?\n         BO    MCLCOMR1            ERROR IF YES\n         OI    0(RZ),X'01'         INDICATE ONE ARG PROCESSED\n         MVI   MCBSINDX,$BSCOMMA   SET BSU INDEX\n         MVI   MCBSHIER,$MCOMMHR   SET HIERARCHY\n         LA    RA,1(R1)            BUMP SCAN POINTER\n         B     MCLXDLMF            JUMP TO DILIM/OPRTR FOOT\n         SPACE 4\n* AMPERSANDS FOUND, PROCESS IT. C HECKS FOR VARIABLES, FOR INSIDE     A\n* QUOTES, ADDS CONCATINATION OPERATOR WHEN NEEDED, SYBOL PARMS, ETC   A\n* ALSO SEARCHES DICTIONARIES AND PROCESS GLOBAL, LOCAL & SYMBOLIC     A\n* VARIABLES                                                           A\n*                                                                     A\nMCLAMPRS EQU   *\n         TM    AVMBYTE2,$MINCHAR   IN CHAR EXPRESSION?\n         BNO   MCLAMP00            PROCEED IF NOT\n         TM    AVMBYTE1,$MINQUOT   SHOULD BE IN QUOTES\n         BO    MCLAMP00            OKAY IF YES\n         TM    AVMBYTE2,$MINAPAR   IN SUBSCRIPT?\n         BO    MCLAMP00            THIS EXCUSSES ALL\n         LA    RB,$ERMISQU         ELSE SETT MISSING QUOTES FLAG\n         B     MCLXERTN            AND RETURN\nMCLAMP00 EQU   *\n         TM    AVMBYTE1,$MINQUOT   INSIDE QUOTES?\n         BNO   MCLAMPR1            IF NOT, PROCEED\n         CLI   1(R1),C'&&'         NEXT CAR = &?\n         BNE   MCLAMP01            PROCEED IF NOT\n         LA    RA,2(R1)            ELSE BUMP SCAN POINTER PAST &&\n         B     MCLXSCAN            AND RESUME SCAN\nMCLAMP01 EQU   *\n         CR    R0,R1               STRING PRECEEDING &?\n         BE    MCLAMPRT            PROCESS VAR SYMB IF NOT\n         TM    AVMBYTE2,$MOPRTR    PREV BSU = OPRTR?\n         BO    MCLAMP02            PROCEED IF YES\n         BAL   RET,MCLXCATI        ELSE INSERT CAT OPRTR\nMCLAMP02 EQU   *\n         LR    RB,R1               ELSSE COPY END OF STRING+1\n         LR    RA,R0               GET START OF STRING\n         $CALL MCGTST              GET STRING\n         STC   RD,MCBSTRLN         SAVE STRING LENGTH IN BSU\n         ST    RC,MCBSLOC          SAVE LOCATION IN BSU\n         MVI   MCBSINDX,$BSTRING   IDENTIFY BSU\n         OI    MCBSFLGS,$MINQUOT+$MTERM+$MINCHAR  SET FLAGS IN BSU\n         $SCOF RB,R0,MCBSOFST      PUT OFFSET IN BSU\n         LR    R0,RA               BUMP START POINTER\n         BAL   RE,MCLXBMP          BUMP BSU\n         B     MCLAMPR0            PROCEED                            A\nMCLAMPRT EQU   *\n         TM    AVMBYTE2,$MOPRTR    PREV BSU = OPRTR?\n         BO    MCLAMPR1            PROCEED IF YES\n         SPACE 2\nMCLAMPR0 BAL   RET,MCLXCATI        INSERT CONCAT OPR                  A\nMCLAMPR1 EQU   *\n         TM    AVMBYTE1,$MINQUOT   INSIDE QUOTES?\n         BNO   MCLAMPR2            PROCEED IF NOT\n         OI    MCBSFLGS,$MINQUOT   ELSE SET QUOTR FLAG IN BSU\nMCLAMPR2 EQU   *\n         $CALL MCSYSR              FIND SYMBOL IN DICTIONARIES\n         LTR   RB,RB               OKAY?\n         BP    MCLXERTN            UNDEFINED IF RB > 0\n         BM    MCLXISER            INVALID SYMBOL IF RB < 0\n         B     *(RD)               JUMP TO ROUTINE\n         B     MCLAGLOB            GLOBAL SYMBOL?\n         B     MCLALOCL            LOCAL SYMBOL?\n         B     MCLASYPR            SYMBOLIC PARAMETER?\n         USING MCPARENT,RC         SET USING FOR PARAMETER\nMCLASYSV EQU   *                   SYTEM VARIABLE IF BRANCH HERE\n         CLI   MCPARNLN,X'08'      COMPARE LENGTH\n         BE    MCLASYLS            IF 8, MUST BE SYSLIST\n         CLI   MCPARNAM+6,C'X'     IS IT &SYSNDX\n         BE    MCLASYDX            PROCESS IF YES\n         MVI   MCBSINDX,$BSYSECT   MUST BE &SYSSECT\n         B     MCLXTRMF\nMCLASYLS EQU   *\n         MVI   MCBSINDX,$BSYSLST   SET &SYSLST INDEX IN BSU\n         OI    AVMDWRK4,$MINSYSL   SET SYSLIST FLAG IN PAREN BYTE\n         B     MCLAGSYL            GO TO MAKE SURE ( THERE AND FLAG   J\nMCLASYDX EQU   *\n         MVI   MCBSINDX,$BSYSNDX   SET &SYSNDX FLAG IN BSU\n         B     MCLXTRMF\n* SYMBOLIC PARAMETER FOUND                                            A\nMCLASYPR EQU   *\n         MVI   MCBSINDX,$BSYMPAR   SET SYMBOLIC PARAM BSU INDEX\n         LH    R2,MCPARNDX         GET SYM PAR POSITION\n         ST    R2,MCBSLOC          STORE IN BSU\n         CLI   0(RA),C'('          NEXT CHAR = '('?\n         BNE   MCLXTRMF            PROCEED TO FOOT IF NOT\n         OI    AVMBYTE2,$MDIMVAR    ELSE SET DIM VARIABLE FLAG\n         B     MCLXTRMF\n         DROP  RC\n         SPACE 2\n* GLOBAL SYMBOL FOUND                                                 A\n         USING MCGLBDCT,RC\nMCLAGLOB EQU   *\n         ST    RC,MCBSLOC          STORE ENTRY @ IN BSU\n         CLI   MCGLBTYP,X'08'      WHAT TYPE OF GLOBAL SYMBOL?\n         BH    MCLASY01\n         BL    MCLASY02            ARITH IF LOW\n         MVI   MCBSINDX,$BSTSYBG   MUST BE BOOL IF FALLS THROUGH\n         OI    MCBSFLGS,$BSBOOL    SET BOOLEAN FLAG\n         B     MCLAGLFT\nMCLASY01 EQU   *\n         MVI   MCBSINDX,$BSTSYCG   SET CHAR BSU INDEX\n         OI    MCBSFLGS,$BSCHAR    SET CHAR FLAG\n         B     MCLAGLFT\nMCLASY02 EQU   *\n         MVI   MCBSINDX,$BSTSYAG   SET ARITH BSU INDEX\n         OI    MCBSFLGS,$BSAR      SET ARITH FLAG\n         B     MCLAGLFT\n         DROP  RC\n         SPACE 2\n* LOCAL SYMBOL FOUND                                                  A\n         USING MCLCLDPV,RC\nMCLALOCL EQU   *                   ROUTINE FOR LOCAL SYMBOLS\n         ST    RC,MCBSLOC          SAVE ENTRY @ IN BSU\n         CLI   MCLCLTYP,X'08'      WHAT TYPE LOCAL SYMBOL?\n         BH    MCLASY03            CHAR IF HIGH\n         BL    MCLASY04            ARITH IF LOW\n         MVI   MCBSINDX,$BSTSYBL   SET LOCAL INDEX IF FALLS THROUGH\n         OI    MCBSFLGS,$BSBOOL    SET BOOLEAN TYPE FLAG\n         B     MCLAGLFT\nMCLASY03 EQU   *\n         MVI   MCBSINDX,$BSTSYCL   SET LOCAL CHAR SYMBOL INDEX\n         OI    MCBSFLGS,$BSCHAR    SET CHAT TYPE FLAG\n         B     MCLAGLFT\nMCLASY04 EQU   *\n         MVI   MCBSINDX,$BSTSYAL   SET LOCAL ARTITH INDEX\n         OI    MCBSFLGS,$BSAR      SET ARITH TYPE FLAG\nMCLAGLFT EQU   *\n         CLC   MCLCLDIM,AWH1       SET SYMBOL DIMENSIONED?\n         BE    MCLASY06            IF NOT, JUMP\nMCLAGSYL OI    AVMBYTE2,$MDIMVAR   SHOW DIMENSIONED                   J\n         CLI   0(RA),C'('          MUST BE LEFT PAREN\n         BE    MCLXTRMF            OK IF YES\nMCLASY05 EQU   *\n         LA    RB,$ERSSDIM         ELSE SET SUBSCRIPT ERROR FLAG\n         B     MCLXERTN            AND RETURN\nMCLASY06 EQU   *\n         CLI   0(RA),C'('          NEXT CHAR = (?\n         BNE   MCLXTRMF            OKAY IF NOT\n         TM    AVMBYTE1,$MINQUOT   INSIDE QUOTES?\n         BO    MCLXTRMF            PAREN OKAY IF YES\n         B     MCLASY05            ELSE FLAG BAD PAREN\n         DROP  RC\n         SPACE 2\n* PERIOD FOUND, LEGAL IF IN CHAR EXP & IF NOT, CONCATINATION OPERATOR A\n* NEEDED AND BSU INSERTED                                             A\nMCLPEROD EQU   *\n         TM    AVMBYTE2,$MINCHAR   IN CHAR EXPRESSION?\n         BNO   MCLXSYER            ERROR IF NOT\n         TM    AVMBYTE1,$MINQUOT   ARE WE IN QUOTES?\n         BNO   MCLPER01            PROCEED IF NO\n         CR    R0,R1               POINTER MOVED?\n         BE    MCLPER02            PROCEED IF NOT\nMCLPER00 EQU   *\n         LA    RA,1(R1)            ELSE BUMP PNTR PAST '.' AND RESUME\n         B     MCLXSCAN            SCAN\nMCLPER02 EQU   *\n         CLI   1(R1),C'&&'         POSSIBLE VAR SYMBOL?\n         BNE   MCLPER0A            PROCEED IF NOT\n         CLI   2(R1),C'&&'         DOUBLE '&&'?\n         BNE   MCLPER0B            CAT OPRTR IF NOT\nMCLPER0A EQU   *\n         IC    R2,1(R1)            GET NEXT CHARACTER\n         LA    R2,AWTSYMT(R2)      USE AS POINTER INTO TABLE\n         CLI   0(R2),X'00'         NEXT CHAR IS ALPHANUM?\n         BNE   MCLPER00            TREAT PERIOD AS CHAR IF NOT\nMCLPER0B EQU   *\n         CLI   MCBSINDP,$BSCAT     PREV SYM= COCAT?                   A\n         BE    MCLPER00            TREAT AS CHAR IF YES\nMCLPER01 EQU   *\n         $SCOF RB,R1,MCBSOFST      GET OFFSET OF CAT OPRTR\n         BAL   RET,MCLXCATI        ELSE INSERT CAT OPRTR\n         B     MCLXSTRS            RESUME SCAN                        S\n         SPACE 4\n* QUOTE FOUND, PROCESS FOR CHAR END, NULL STRING SYMBOL(DOUBLE QUOTES)A\n* ALSO ERROR CHECKING DONE                                            A\nMCLQUOTE EQU   *\n         C     R1,AVSOLAST         END OF RECORD?\n         BNL   MCLQUER1            ERROR IF YES\n         TM    AVMBYTE1,$MINQUOT   ARE WE IN QUOTES?\n         BNO   MCLQ02              IF NOT, SET FLAGS AND PROCEED\n         CLI   1(R1),C''''         DOUBLE QUOTE?\n         BNE   MCLQTF              IF NOT, GET STRING\n         LA    RA,2(R1)            ELSE BUMP POINTER AND RESUME SCAN\n         B     MCLXSCAN\nMCLQ01   EQU   *\n         LR    RB,R1               COPY END OF STRING + 1\n         LR    RA,R0               COPY START OF STING\n         $CALL MCGTST              GET STRING\n         ST    RC,MCBSLOC          SAVE LOCATION IN BSU\n         STC   RD,MCBSTRLN         SAVE STRING LENGTH IN BSU\n         MVI   MCBSINDX,$BSTRING   IDENT BSU\n         OI    MCBSFLGS,$MINQUOT   FLAG BSU AS IN QUOTE\n         LA    RA,1(R1)            BUMP SCAN POINTER PAST QUOTE\n         XI    AVMBYTE1,$MINQUOT   TURN QUOTE FLAG ON/OFF\n         B     MCLXTRMF\nMCLQ02   EQU   *\n         TM    AVMBYTE2,$MINARIT   IN ARITH EXPRESSION?\n         BO    MCLXISER            ERROR IF YES\n         XI    AVMBYTE1,$MINQUOT   TURN ON QUOTE FLAG\n         B     MCLXSTRS            RESUME SCAN                        S\nMCLQTF EQU *\n         CR    R0,R1               STRING PRESENT?\n         BNE   MCLQTF01            IF YES, PROCEED\n         BCTR  R1,0                ELSE DECR POINTER\n         CLI   0(R1),C''''         PREV CHAR = QUOTE?\n         LA    R1,1(R1)            RESTORE POINTER BEFORE TEST\n         BE    MCLQ01              IF YES, PROCESS NULL STRING\n         B     MCLQ02              ELSE TURN OFF FLAG AND RESUME SCAN\nMCLQTF01 EQU   *\n         TM    AVMBYTE2,$MTERM     PREV BSU = TERM?\n         BNO   MCLQ01              PROCEED IF NOT\n         BAL   R14,MCLXCATI        ELSE INSERT CATEN OPRTR\n         B     MCLQ01              AND THEN PROCEED\n         SPACE 2\n         SPACE\nMCLQUER1 EQU   *\n         LR    RA,R1               GET @ OF RECORD ENDING QUOTE\n         S     RA,=F'2'            DECR TO END OF OPERAND\n         B     MCL$ERV                                                S\n         SPACE 2\nMCLBLANK EQU   *\n         LTR   RY,RY               STILL IN PARENS?\n         BZ    MCLXFOOT            RETURN IF NOT\n         TM    AVMBYTE2,$MINBOOL   IN BOOLEAN EXPRESSION\n         BO    MCLXSTRS            OK IF YES, RESUME SCAN             S\nMCL$ERV  LA    RB,$ERVUNEX         ELSE SET ERROR FLAG                S\n         B     MCLXERTN            AND RETURN\n         SPACE 4\nMCLXOPRF EQU   *\n         TM    AVMBYTE2,$MOPRTR    PREV BSU = OPRTR?\n         BNO   MCLXDLMF            OKAY IF NOT\n         CLI   MCBSINDX,$BSNOT     IS CURRENT SYMBOL = NOT ?          S\n         BNE   MCLXOPER            ERROR IF NOT\n         CLI   MCBSINDP,$BSLPAR    IS IT LEFT PAREN                   A\n         BE    MCLXOP01            OKAY IF YES\n         CLI   MCBSINDP,$BSAND     IS IT AN AND?                      A\n         BE    MCLXOP01            OKAY IF YES\n         CLI   MCBSINDP,$BSOR      IT IS OR?                          A\nMCLXOP01 EQU   *\n         BE    MCLXDLMF            RESUME SCAN IF ONE OF (, AND OR\n         B     MCLXSYER            ELSE FLAG ERROR\nMCLXOPER EQU   *\n         CLI   MCBSINDP,$BSRPAR    PREV SYMBOL = RIGHT PAREN ?        S\n         BE    MCLXOP01            OKAY IF YES\n         B     MCLXSYER            ELSE FLAG ERROR\n         SPACE 4\nMCLXTRMF EQU   *\n         TM    AVMBYTE2,$MTERM     PREV BSU = TERM?\n         BO    MCLXSYER            ERROR IF YES\n         OI    MCBSFLGS,$MTERM     SET FLAG IN BSU\n         XI    AVMBYTE2,$MOPRTR+$MTERM  TURN ON TERM FLAG\n         B     MCLXF09             JUMP TO FOOT\n         SPACE 4\nMCLXDLMF EQU   *\n         OI    MCBSFLGS,$MOPRTR    TURN ON OPRTR FLG IN BSU\n         NI    AVMBYTE2,X'FF'-$MDIMVAR-$MTERM  TERM,DIMVAR FLAGS      A\n         OI    AVMBYTE2,$MOPRTR    TURN ON OPRTR FLAG\n         B     MCLXF09\n         SPACE 4\n**--> INSUB: MCLXCATI    ROUTINE TO INSERT CONCATINATION + + + + + + +A\n*+                                                                    A\n*+ CALLED WHEN CONCATINATION OPERATION NEEDED, INSERTR BSU            A\n*+                                                                    A\n*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +A\n         SPACE 2                                                      A\nMCLXCATI EQU   *\n         MVI   MCBSINDX,$BSCAT     SET CATEN INDEX\n         MVI   MCBSHIER,$MCATHR    SET HEERARCHY\n         TM    AVMBYTE1,$MINQUOT   INSIDE QUOTES?\n         BNO   MCLXCAT1            SKIP IF NOT\n         OI    MCBSFLGS,$MINQUOT   SET IN QUOTE FLAG IN BSU\nMCLXCAT1 EQU   *\n         OI    MCBSFLGS,$MOPRTR    SET OPRTR FLAG IN BSU\n         BAL   RE,MCLXBMP          BUMP BSU\n         NI    AVMBYTE2,X'FF'-($MOPRTR+$MTERM)  TURN OFF FLAGS\n         OI    AVMBYTE2,$MOPRTR    SET PREV SYMBOL = OPRTR FLAG\n         BR    R14                 RETURN\n         SPACE 4\n**--> INSUB: MCLXBMP       BUMP POINTER  + + + + + + + + + + + + + + +S\n*+       SAVE PREVIOUS BSU AND BUMP POINTER                          +S\n*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +S\n         SPACE 2                                                      S\nMCLXBMP  EQU   *\n         MVC   MCBSFLGP(4),0(RW)   MOVE PREV BSU INTO WRK AREA        A\n         XSNAP T=NO,STORAGE=(*0(RW),*8(RW)),LABEL='BSU - MACLEXP',     #\n               IF=(AVTAGSM,O,AJOMACRH,TM)\n         LA    RW,$LMCBSU(RW)      BUMP BSI POINTER                   A\n         C     RW,AVMCHLIM         WORK AREA EXCEEDED?\n         BL    MCLXBMP1            OK IF NOT\n         LA    RB,$ERVTMTR         ELSE FLAG TOO MANY TERMS\n         B     MCLXERTN            AND RETURN\nMCLXBMP1 EQU   *\n         MVC   MCBSU(8),AWZEROS    ZERO NEW BSU\n         BR    RE                  AND RETURN\nMCBSFLGP DS    C                   PREVIOS                            A\nMCBSINDP DS    C                   BSU                                A\nMCBSOFSP DS    C                   WORK                               A\nMCBSHIEP DS    C                   AREA                               A\n         SPACE 2\nMCLXF09  EQU   *\n         $SCOF RB,R0,MCBSOFST      GET OFFSET INTO BSU\n         BAL   RE,MCLXBMP          BUMP BSU\n         TM    AVMBYTE4,$MINSTRN   PROCESSING OUTSIDE VAR SYMBOL?\n         BNO   MCLXSTRT            IF NOT, RESUME SCAN\n         NI    AVMBYTE4,X'FF'-$MINSTRN  ELSE TURN OFF FLAG\n         CLI   0(RA),C'('          PAREN FOLLOWING?\n         BNE   MCLXFOOT            RETURN IF NOT\n         OI    AVMBYTE2,$MINPEXP   ELSE SET PARENS ONLY FLAG\n         B     MCLXSTRT            AND RESUME SCAN\n         SPACE 2\nMCLXISER EQU   *\n         LR    RA,R0               RESTORE SCAN POINTER\n         LA    RB,$ERINVSY         SET INVALID SYMBOL FLAG\n         B     MCLXERTN            AND RETURN\n         SPACE 2\nMCLEXERR EQU   *\nMCLXSYER EQU   *\n         LR    RA,R0               RESTORE SCAN POINTER\n         LA    RB,$ERVSYNT         SET SYNTAX ERROR FLAG\n         B     MCLXERTN            AND RETURN\n         SPACE 2\nMCLXFOOT EQU   *\n         SR    RB,RB\n         TM    AVMBYTE2,$MOPRTR    LAST BSU = OPRTR?\n         BNO   MCLXERTN            RETURN NORMALLY IF NOT\n         CLI   MCBSINDP,$BSRPAR    IT IS RIGHT PAREN?                 A\n         BE    MCLXERTN            RETURN                             S\nMCLXFTER EQU   *\n         $SCPT RA,MCBSOFST         GET POINTER TO ERROR\n         LA    RB,$ERVSYNT         SET ERROR FLAG\nMCLXERTN EQU   *\nMCLEQUAL EQU   MCLXERTN            ERROR IF '==' TURNS UP             S\n         $SETRT ('''',0,'&&',0,'.',0)   RESTORE TRT TABLE\n         MVI   AWTDECT+C'+',2\n         MVI   AWTDECT+C'-',2\n         MVI   AWTDECT+C'/',2      RESTORE AWTDEDT TABLE TO ORIGINAL\n         MVI   AWTDECT+C')',2      CONDITIONS BEFORE RETURNING\n         MVI   AWTDECT+C'''',2\n         MVI   AWTDECT+C'&&',2\n         MVI   AWTDECT+C'.',2\n         XSNAP LABEL='***MACLEX EXITED***',IF=(AVMSNBY2,O,$MSNP09,TM)\n         LR    RC,RW               SET BSU POINTER\n         $RETURN  RGS=(R14-R6)\n         LTORG\n         DROP  RAT,RW\n         TITLE '***  MCGNCD - GENERATE INTERNAL CODE FOR MACRO S'\n**-->  CSECT:  MCGNCD  CONVERTS STRING OF BSU'S TO INTERNAL CODE      *\n*.        IN ONE-OP FORM.  ONE-OPS ARE QUADRUPLES WITH OPRTR, TWO     *\n*.        OPRNDS AND RESULT FIELD.   ADDRESS OF CURRENT GENERATED INST*\n*.        IS IN AVMCRINS.  GEERATED CODE IS POINTED TO BY MCCODLNK    *\n*.        FIELD IN MACLIB.  BSU STRING LOCATED IN AVMWRK1             *\n*.                                                                    *\n*.        ENTRY CONDITIONS                                            *\n*.     RC = @ OF CURRENT MACLIB ENTRY                                 *\n*.                                                                    *\n*.        USES MACROS: $CALL,$SAVE,$RETURN,$SCOF,$SCPT,$ALLOCL,$ALLOCH*\n*.        USES DSECTS: AVWXTABL,MCBSU,MCBSTRMS,MCBOPRST,MCOPQUAD,     *\n*.                     MACLIB,MCSEQ                                   *\n*.        CALLS MACFND, ERRTAG,                                       *\n*.                                                                    *\n*.        REGISTER USAGE:                                             S\n*.             WORK REGS:  R0,R1,RA,RB,RC,RE                          S\n*.             TRT BYTE REG:  R2                                      S\n*.             RW  - BASE REG FOR BSU                                 S\n*.             RX  - BASE REG FOR OPRND STACK                         S\n*.             RY  - BASE REG FOR OPRTR STACK                         S\n*.             RZ  - BASE REG FOR ONE-OP ENTRY                        S\n*.             RAT - BASE REG FOR MAIN TABLE                          S\n*.             R1  - BASE REG FOR MACLIB                              S\n*.             RD  - UNUSED                                           S\n*.                                                                    S\n*.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 2\nMCGNCD   CSECT\n         $SAVE RGS=(R14-R6),BR=13,SA=*\n         USING AVWXTABL,RAT        NOTE MAIN TABLE USING\n         XSNAP LABEL='***MCGNCD ENTERED***',IF=(AVMSNBY2,O,$MSNP10,TM)\n         USING MCBSU,RW            NOTE USING FOR BSU INPUT STRING\n         USING MCBSTRMS,RX         USING FOR OPRND STACK\n         USING MCBOPRST,RY         USING FOR OPRTR STACK\n         USING MCOPQUAD,RZ         USING FOR ONE-OP ENTRY\n         USING MACLIB,RC           USING FOR MACLIB ENTRY\n         NI    AVMBYTE4,X'FF'-($MCOMST+$MRPARST)   CLEAR COMMA, RP FLAG\n         LA    R0,$LMCBSU          LENGTH OF BSU FOR BUMPING          A\n         SR    R2,R2               CLEAR BYTE REGISTER                A\n         LA    RB,$LMCOPL1         GET LENGTH OF PREFIX SECTION       A\n         $ALLOCL RE,RB,MCGNCDOV    GET SPACE FOR IT                   A\n         MVC   0($LMCOPL1,RE),AWZEROS CLEAR OUT ONE-OP PREFIX         A\n         L     RZ,AVMCRINS         GET PREV INST @\n         LTR   RZ,RZ               1ST INSTRUCTION?\n         BNZ   MCGNCD00            IF NOT, PROCEED\n         LA    RZ,MCCODLNK         FAKE POINTER AS 1ST ONE            A\nMCGNCD00 EQU   *\n         ST    RE,MCQUDNXT         SAVE LINK IN PREV INSTRUCTION\n* CREATE STACK OF ONE OPS                                             A\nMCGNCD01 EQU   *\n         LR    RZ,RE               SET BASE TO NEW ENTRY\n         ST    RZ,AVMCRINS         SAVE CURRENT INST @\n         ZAP   MCQSTMNO,AVOULNCN   STORE CURRENT PACKED DEC STMT NBR\n         L     RW,AVMCHSTR         GET @ OF BSU INPUT STRING\n         XSNAP LABEL='BEGIN MCGENCD',STORAGE=(*0(RW),*100(RW)),        X\n               IF=(AVTAGSM,O,AJOMACRH,TM)                             A\n         LA    RX,AVMWRK2          USE AVMWRK2 FOR OPRND STACK\n         LA    RY,AVMWRK1          USE QVMWRK1 FOR OPRTR STACK\n         MVC   MCBSTRMS($LMCBSU),AWZEROS  CLEAR OPRND STACK\n         MVC   MCBOPRST($LMCBSU),AWZEROS   CLEAR OPRTR STACK\n         SR    RX,R0               DECR APRND PTR FOR STMT            A\n*  POP BSU, SET PRIORITIES AND PUSH ON APPROPRIATE STACK              A\nMCGNCDSC EQU   *\n         CLI   MCBSINDX,X'00'      END OF BSU'S?\n         BE    MCGENCD             IF YES , POP INSTRUCTIONS\n         TM    AVMBYTE4,$MRPARST+$MCOMST  PAREN OR COMMA FLAG ON?\n         BM    MCGENCD             IF YES, POP INSTRUCTION\n         TM    MCBSFLGS,$MTERM     TERM?\n         BNO   MCGNCD02            IF NOT, PROCESS OPRTR\n         AR    RX,R0               ELSE BUMP OPRND STACK PTR          A\n         MVC   MCBSFLG2($LMCBSU),MCBSU  ELSE PUSH TERM ON OPRND STACK\n         B     MCGNCD06\nMCGNCD02 EQU   *\n         CLI   MCBSINDX,$BSCOMMA   COMMA?\n         BNE   MCGNCD03            TEST FOR PAREN IF NOT\n         OI    AVMBYTE4,$MCOMST    ELSE SET FLAG\n         B     MCGNCD06            AND JUMP TO FOOT\nMCGNCD03 EQU   *\n         CLI   MCBSINDX,$BSRPAR    REGHT PAREN?\n         BNE   MCGNCD04            PROCEED IF NOT\n         OI    AVMBYTE4,$MRPARST   ELSE SET FLAG\n         B     MCGNCD06            AND JUMP TO FOOT\nMCGNCD04 EQU   *\n         CLI   MCBSHIER,$MPARHR    PAREN?\n         BNE   MCGNCD05            PROCEED IF NOT\n         CLI   MCBSINDX,$BSBSTR    SUBSTRING?\n         BNE   MCGNPUSH            IF NOT, PUSH ONTO OPRTR STACK\n         CLI   MCBSOPST,$BSCAT     CAT OPRTR IN STACK?\n         BNE   MCGNPUSH            PUSH OPRTR IF NOT\n         TM    MCBOPFL,$MINQUOT    CAT OPRTR IN QUOTES?\n         BO    MCGENCD             POP OPRTR IF YES\nMCGNPUSH EQU   *\n         AR    RY,R0               BUMP STACK POINTER                 A\n         MVC   MCBOPRST($LMCBSU),MCBSU  PUSH OPRTR ONTO STACK\n         B     MCGNCD06            JUMP TO FOOT\nMCGNCD05 EQU   *\n         CLI   MCBSINDX,$BSCAT     CAT OPRTR?\n         BNE   MCGNCD07            PROCESS NORMALLY IF NOT\n         TM    MCBSFLGS,$MINQUOT   CAT OPRTR IN QOTES?\n         BNO   MCGNCD07            PROCESS NORMAL IF NOT\n         CLC   MCBSHIER,MCBOPHR    COMPARE HIERARCHIES\n         BNL   MCGNPUSH            H(OPRRTR) >=H(STACK) THEN PUSH\n         B     MCGENCD             ELSE POP OPRTR\nMCGNCD07 EQU   *\n         CLC   MCBSHIER,MCBOPHR    COMPARE HIERARCHIES\n         BH    MCGNPUSH            PUSH OPRTR ONLY IF HIGH\n         B     MCGENCD             ELSE POP OPRTR\nMCGNCD06 EQU   *\n         AR    RW,R0               POP INPUT BSU STACK                A\n         B     MCGNCDSC            AND RESUME SCAN OF INPUT\nMCOPRBAS DS    0H\n         EJECT                                                        A\nMCGENCD  EQU   *\n         NI    AVMBYTE1,X'FF'-$MINQUOT   TURN OFF QUOTE FLAG\n         TM    MCBSFLG1,$MINQUOT     FIRST TERM IN QUOTES?\n         BZ    MCGENCD0            PROCEED IF NOT\n         OI    AVMBYTE1,$MINQUOT   ELSE SET QUOTE FLAG\nMCGENCD0 EQU   *\n         CLI   MCBOPHR,$MPARHR     LEFT PAREN?\n         BNE   MCGENCD2            PROCEED IF NOT\n         TM    AVMBYTE4,$MCOMST    WORKING ON COMMA?\n         BNO   MCGENCD1            PROCEED IF NOT\n         XI    AVMBYTE4,$MCOMST    ELLE TURN OFF COMMA FLAG\n         B     MCGNCDSC            AND RESUME SCAN\nMCGENCD1 EQU   *\n         NI    AVMBYTE4,X'FF'-$MRPARST   ELSE TURN OFF PAREN FLAG\n         CLI   MCBSOPST,$BSLPAR     ORDINARY LEFT PAREN?\n         BE    MCGENRT             IF YES POP OPRTR AND RESUME SCAN\n*                                                                     A\n*  ALLOCATE SPACE FOR ONE OP ENTRIES                                  A\n*  HIERARCHY AND JUMP ON INDEX TO PROCESS                             A\n*                                                                     A\nMCGENCD2 EQU   *\n         CLI   MCBSOPST,X'00'      OPRTR STACK EMPTY?\n         BE    MCGNCDRT            RETURN IF YES\n         BAL   RET,MCGNALLO        ALLOCATE SP FOR 1 OP ENTRY         S\n         IC    R2,MCBOPHR          GET HIERARCHY\n         LH    R1,MCOPRNDX(R2)     GET OFFSET\n         B     MCOPRBAS(R1)        JUMP TO ROUTINE\n         SPACE\nMCOPRNDX $AL2  MCOPRBAS,(MCPARGEN,MCHRTW,MCORGEN,MCANDGEN,MCRELGEN,MCCAX\n               TGEN,MCPLSGEN,MCMULGEN,MCNOTGEN)\n         SPACE\n*  PAREN BSU FOUND PUT ONE-OP ON STACK                                A\n*                                                                     A\nMCPARGEN EQU   *                   HIER = 0 ROUTINES\n         BAL   RE,MCMVTRMS         MOVE ARGS TO ONE-OP\n         CLI   MCBOPRTR,$BSBSTR    SUBSTRING PAFEN?\n         BE    MCPARG0Q            PROCEED IF NOT                     S\nMCPARG02 EQU   *\n         CLI   MCARG1DX,$BSATT     1ST ARG IS T'?\n         BE    MCPARG0Q            TREAT AS QUOTED STRING IF YES\n         TM    AVMBYTE1,$MINQUOT   FIRST TERM INSIDE QUOTES?\n         BZ    MCPARG03            PROCEED IF NOT\nMCPARG0Q EQU   *\n         OI    MCBSFLG2,$MINQUOT   SET QUOTE FLAG IN OPRND STACK\nMCPARG03 EQU   *\n         SR    RW,R0               DECR PTR TO CHECK PREV ENTRY       S\n         TM    MCBSLOC+3,X'01'     TWO ARG'S IN PARENS?\n         LA    RW,$LMCBSU(RW)      RESTORE POINTER\n         BNO   MCGENRT             PROCEED IF NOT\n         BAL   RET,MCGNALLO        ALLOCATE SP FOR 1 OP ENTRY         S\n         MVC   MCARG1DX,MCBSNDX1   MOVE IDENT OF ARG INTO ONE-OP\n         MVC   MCARG1LC,MCBSLOC1   MOVE LOCATION OF OPRND INTO ONE-OP\n         CLI   MCARG1DX,$BSTRING   STRING TERM?\n         BNE   MCPARG04            PROCEED IF NOT\n         MVC   MCARG1LC(1),MCBLN1   MOVE LENGTH OF STRING INTO ONE-OP\nMCPARG04 EQU   *\n         MVC   MCBSFLG1($LMCBSU),MCBSFLG2 PUSH DOWN OPRND STACK\n         B     MCTWODEC            DECR OPRND STACK\n         SPACE\n*  HEIR=2, PUT ONE-OP ON STACK                                        A\n*                                                                     A\nMCHRTW   EQU   *\n         MVC   MCBOPRTR,MCBSOPST   MOVE OPRTR FROM STACK TO ONE-OP\n         CLI   MCBSOPST,$BSPRINT   WHICH BSU OF HIER = 2?\n         BL    MCTWOSET            IF LOW, MUST BE SETX\n         BE    MCTWOPRA            IF EQUAL MUST BE PRINT             A\n         CLI   MCBSOPST,$BSINMAC   ELSE IS IT INNER MACRO CALL?\n         BNL   MCTWOPR             INNER IF EQUAL, MVSTR IF HIGH\n*        NOTE: THESE JUST USE ONE-OP PREFIX BY THEMSELVES             A\n         L     RZ,AVMCRINS         GET # PREFIX ONE-OP                A\n         MVC   MCQS1FLG,MCBSOPST   COPY OPERATOR OVER                 A\n         B     MCPREFIX            GO TO PREFIX-ONLY EXIT             A\nMCTWOSET EQU   *\n         BAL   RE,MCMVTRMS         MOVE OPRNDS INTO ONE-OP\n         B     MCTWODEC\nMCTWOPRA TM    MCBOPFL,$MPRCOM     WAS THIS SPECIAL PRINT COMMENT UP  A\n         BZ    *+8                 NO, SKIP                           A\n         OI    MCBOPRTR,$MPRCOM    YES, MAKE PRINT OPRTR ODD, SO KNOW A\nMCTWOPR  EQU   *\n         MVC   MCARG2LC+3(1),MCBOPOF   MOVE OFFSET INTO INTO ARG2LC\n         MVC   MCARG1DX,MCBSNDX2   MOVE TYPE INTO ARG1DX\n         MVC   MCARG1LC,MCBSLOC2   MOVE LOCATION OF STRING INTO ONE-OP\n         CLI   MCBSNDX2,$BSTRING   INDEX BSU IS CHAR STRING?\n         BNE   MCTWODEC            SKIP MOVE LEN IF NOT\n         MVC   MCARG1LC(1),MCBLN2  MOVE LENGTH INTO LOC FIELD\n         B     MCTWODEC            DECR OPRND STACK\n*                                                                     A\n* PLUS OR MULTIPLY BSU FOUND PUT ONE-OP ON STACK                      A\n*                                                                     A\nMCPLSGEN EQU   *\nMCMULGEN EQU   *\n         BAL   RE,MCMVTRMS         MOV& OPRNDS INTO ONE-OP\n         MVI   MCBSFLG2,$MTERM+$BSAR  IDENT OPRND STACK TOP AS ARITH TR\n         B     MCGENRT             JUMP TO FOOT\n         SPACE\n*                                                                     A\n* AND | OR BSU FOUND, PUT ONE OP ONTO STACK                           A\n*                                                                     A\nMCORGEN  EQU   *\nMCANDGEN EQU   *\n         TM    MCBSFLG1,$BSBOOL    1ST OPRND = BOOL?\n         BNO   MCMXDR1             ERROR IF NOT\n         TM    MCBSFLG2,$BSBOOL    2ND OPRND = BOOL?\n         BNO   MCMXDR1             ERROR IF NOT\n         BAL   RE,MCMVTRMS         MOVE OPRNSD INTO ONE-OP\n         MVI   MCBSFLG2,$MTERM+$BSBOOL  IDENTIFY AS BOOLEAN TERM\n         B     MCGENRT             JUMP TO FOOT\n         SPACE\n* RELATIONAL OPERATOR FOUND PUT ONE-OP ONTO STACK                     A\n*                                                                     A\nMCRELGEN EQU   *\n         MVI   AVMBYTE3,X'00'      CLEAR AVMBYTE3 FOR FLAG USE\n         TM    MCBSFLG1,$MINQUOT   1ST TERM IN QUOTES?\n         BO    MCRELG02\n         TM    MCBSFLG2,$MINQUOT   2ND TERM IN QUOTES?\n         BO    MCRELG03\n         B     MCRELG01            ELSE PROCEED\nMCRELG02 EQU   *\n         OI    AVMBYTE3,$BSRLCHR   SET CHAR RELTN FLAG\n         TM    MCBSFLG2,$MINQUOT   2ND TERM IN QUOTES?\n         BO    MCRELG01            OKAY IF YES\n         CLI   MCBSNDX2,$BSATT    ELSE IS IT T'?\n         BE    MCRELG01            OKAY IF YES\n         B     MCMXDR2             ELSE ERROR\nMCRELG03 EQU   *\n         OI    AVMBYTE3,$BSRLCHR   SET CHAR RELTN FLAG\n         CLI   MCBSNDX1,$BSATT     1ST TERM = T'?\n         BNE   MCMXDR2             ELSE ERROR                         S\nMCRELG01 EQU   *\n         BAL   RE,MCMVTRMS         MOVE TERMS INTO ONE-OP\n         OC    MCBOPRTR,AVMBYTE3   SET CHR OR ARIT FLAG IN OPRTR\n         MVI   MCBSFLG2,$MTERM+$BSBOOL   IDENTIFY AS BOOLEAN TERM\n         B     MCGENRT             JUMP TO FOOT\n         SPACE\n*  CATENATION BSU FOUND PUT ONE-OP ON STACK                           A\n*                                                                     A\nMCCATGEN EQU   *\n         CLI   AVMFLDT2,C'M'       MACRO OPCODE?\n         BNE   MCCATG01            JUMP PAST QUOTE TEST IF NOT\n         TM    MCBSFLG1,$MTERM+$MINQUOT  1ST TERM IN QUOTES?\n         BNO   MCMXDR1             ERROR IF NOT\n         TM    MCBSFLG2,$MTERM+$MINQUOT     2ND TERM IN QUOTES?\n         BNO   MCMXDR1             ERROR IF NOT\nMCCATG01 EQU   *\n         BAL   RE,MCMVTRMS         MOVE OPRNDS INTO ONE-OP\n         MVI   MCBSFLG2,$MTERM+$BSCHAR+$MINQUOT   IDENTIFY TEMP OPRND\n         B     MCGENRT             JUMP TO FOOT\n         SPACE\n* 'NOT' BSU FOUND PUT IN OP-OP STACK                                  A\n* ALSO CHECK FOR AGO AND AIF, AND PROCESS IF FOUND                    A\n*                                                                     A\nMCNOTGEN EQU   *\n         CLI   MCBSOPST,$BSAGO     AGO OPRTR?\n         BH    MCAIFGEN            IF HIGH MUST BE AIF\n         BE    MCAGOGEN            IF EQUAL MUST BE AGO\n         TM    MCBSFLG2,$MTERM+$BSBOOL  BOOLEAN TERM?\n         BNO   MCMXDR2             ERROR IF NOT\n         MVC   MCARG1DX,MCBSNDX2   MOVE INDEX INTO ONE-OP\n         MVC   MCBOPRTR,MCBSOPST   MOVE OPRTR INTO ONE-OP\n         MVC   MCARG1LC,MCBSLOC2   MOVE OPRND LOC INTO ONE-OP\n         ST    RZ,MCBSLOC2         PUT @ OF ONE-OP IN OPRND STACK\n         MVI   MCBSNDX2,$BSTEMP    IDENTIFY STACK AS TEMP\n         B     MCGENRT             JUMP TO FOOT\n         SPACE\n* AGO OR AIF FOUND, PUT ON OP ON STACK                                A\n*                                                                     A\nMCAGOGEN EQU   *\n         L     RA,MCBOPVAL         GET @ OF SEQ SYMBOL\n         BAL   RE,MCSEQSCN         JUMP  TO SCAN SEQ SYM DICT\n         MVC   MCBOPRTR,MCBSOPST   MOVE OPRTR INTO ONE-OP\n         B     MCGENRT             JUMP TO FOOT\n         SPACE\nMCAIFGEN EQU   *\n         L     RA,MCBSLOC2         GET ADDRESS OF SEQ SYMBOL\n         TM    MCBSFLG1,$BSBOOL    BOOLEAN TERM?\n         BNO   MCMXDR1             ERROR IF NOT\n         BAL   RE,MCSEQSCN         SEQRCH SEQ SYMBOL DICT             A\n         MVC   MCARG1DX,MCBSNDX1   MOVE TERM ID TO ONE-OP\n         MVC   MCARG1LC,MCBSLOC1   MOVE LOCATION OF TERM TO ONE-OP\n         MVC   MCBOPRTR,MCBSOPST   MOVE OPRTR INTO ONE-OP\n         MVC   MCARG2DX,MCBSNDX2   MOVE BSU TERM OF ARG INTO ONE-OP\n         B     MCTWODEC            DECR OPRND STACK\n         EJECT                                                        S\n**--> INSUB: MCSEQSCN       ENTER SEQ SYMBOL IN DICT + + + + + + + + +S\n*+       SCAN FOR ERRORS & PUT SEQ SYMBOL IN DICT                    +S\n*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +S\n         SPACE 2                                                      S\nMCSEQSCN EQU   *                   ROUTINE TO ENTER SEQ SYMBOL IN DICT\n         DROP  RC\n         USING MCSEQ,RC            SET USING FOR SEQ SYM ENTRY\n         CLI   1(RA),C'0'          FIRST CHAR  IS LETTER?\n         BNL   MCSEQR1             ERROR IF DIGIT\n         TRT   1(8,RA),AWTSYMT     SCAN SYMBOL\n         BZ    MCSEQR1             SYMBOL 8+ CHARS, TOO LONG\n         CLI   0(R1),C' '          DELIM = BLANK?\n         BNE   MCSEQR1             ERROR IF NOT\n         SR    R1,RA               GET LENGTH\n         BCT   R1,MCSEQS01         DECR LENGTH FOR EX INST\n         B     MCSEQR1             BUT FALL THRU IF LENGHT = 1\nMCSEQS01 EQU   *\n         MVC   AVMSYMBL,AWBLANK    BLANK GLOBAL NAME AREA\n         STC   R1,AVMSYMLN         STORE LENGTH\n         EX    R1,MCGMVC           MOVE SYMBOL                        S\n         AIF   (NOT &$MACOPC).MCGNCDA  SKIP IF NOT OPEN CODE          S\n         L     R1,AVMACLIB         LOAD @ OF MACLIB ENTRY             S\n         USING MACLIB,R1           NOTE USING ON MACLIB               S\n         TM    MCLBFLG2,$MCOCFL1   IN OPEN CODE ?                     S\n         BCR   O,RE                IF YES, SKIP SEQ SYM MANAGEMENT    S\n         DROP  R1                                                     S\n.MCGNCDA ANOP                                                         S\n         L     RC,AVMSEQPT         GET SEQ SYM POINTER\n         LA    R1,0(RE)            SAVE RETURN @ TEMP                 S\n         $CALL MACFND              SEARCH SEQ SYMBOL DICT\n         LR    RE,R1               RESTORE RETURN @                   S\n         LTR   RB,RB               SYMBOL PRESENT IN DECT?\n         BZ    MCSEQS02            PROCEED IF YES\n         LA    RB,$LMCSEQ          ELSE GET LENGTH OF ENTRY\n         $ALLOCH  R1,RB,MCGNCDOV   GET SPACE FOR NEW ENTRY\n         ST    R1,MCSEQNXT         SAVE LINK IN PREV ENTRY\n         LR    RC,R1               MOVE BASE TO NEW ENTRY\n         MVC   MCSEQ($LMCSEQ),AWZEROS  CLEAR NEW ENTRY\n         MVC   MCSEQNAM,AVMSYMBL   MOVE NEW NAME INTO ENTRY\n         MVC   MCARG2LC,AVMCRINS   STORE STMT @ IN ARG2\n         ST    RZ,MCSEQVAL         SAVE LINK TO INST\n         BR    RE                  RETURN\nMCGMVC   MVC   AVMSYMBL($),0(RA)   DUMMY INSTR                        S\nMCSEQS02 EQU   *\n         CLI   MCSEQFLG,X'FF'      SYMBOL DEFINED?\n         BNE   MCSEQS03            IF NOT, JUMP AND PROCESS\n         MVC   MCARG2LC,MCSEQVAL   ELSE PUT VALUE IN ONE-OP\n         BR    RE                  AND RETURN\nMCSEQS03 EQU   *\n         LR    R1,RZ               COPY INST @ TEMPORARILY\n         L     RZ,MCSEQVAL         GET POINTER FROM ENTRY\nMCSEQS04 EQU   *\n         CLC   MCRESULT,AWZEROS    END OF CHAIN?\n         BE    MCSEQS05            IF YES, ENTERLINK IN LAST ENTRY\n         L     RZ,MCRESULT         ELSE GET POINTER TO NEXT LINK\n         B     MCSEQS04            AND TRY AGAIN\nMCSEQS05 EQU   *\n         ST    R1,MCRESULT         PUT CURRENT @ IN LAST LINK\n         LR    RZ,R1               RESTORE BSE OF ONE-OP\n         MVC   MCARG2LC,AVMCRINS   STORE STMT @ IN ARG2\n         BR    RE                  AND RETURN\n         DROP  RC\n         SPACE\nMCTWODEC EQU   *\n         SR    RX,R0               POP OPRND STACK                    S\nMCGENRT  EQU   *\n         SR    RY,R0               POP OPERATOR STACK                 S\n         B     MCGNCDSC            RESUME SCAN\n         SPACE 5                                                      S\n**--> INSUB: MCMVTRMS       CREATE ONE BINARY ONE-OP + + + + + + + + +S\n*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +S\n         SPACE 2                                                      S\nMCMVTRMS EQU   *                   ROUTINE TO CREATE ONE BINARY ONE OP\n         MVC   MCARG1DX,MCBSNDX1   MOVE 1ST TERM ID INTO ONE OP\n         MVC   MCARG2DX,MCBSNDX2   MOVE 2ND TERM ID INTO ONE OP\n         MVC   MCARG1LC,MCBSLOC1   MOVE 1ST TERM LOCATION INTO ONE-OP\n         MVC   MCARG2LC,MCBSLOC2   MOVE 2ND TERM LOCATION INTO ONE-OP\n         CLI   MCBSNDX1,$BSTRING   BSU IS A STRING?\n         BNE   MCMVTRM1            JUMP IF NOT\n         MVC   MCARG1LC(1),MCBLN1    MOVE STRING LENGTH INTO ONE OP\nMCMVTRM1 EQU   *\n         CLI   MCBSNDX2,$BSTRING   2ND TERM IS STRING?\n         BNE   MCMVTRM2            JUMP AROUND IF NOT\n         MVC   MCARG2LC(1),MCBLN2  ELSE MOVE STRING LENGTH INTO ONE-OP\nMCMVTRM2 EQU   *\n         SR    RX,R0               POP OPRND STACK                    S\n         MVI   MCBSNDX2,$BSTEMP    IDENTIFY OPRND STACK TOP AS TEMP\n         MVC   MCBOPRTR,MCBSOPST   MOVE OPRTR FROM STACK TO ONE-OP\n         ST    RZ,MCBSLOC2         PUT TESULST LOCATION IN OPRND STACK\n         BR    RE                  RETURN\n         SPACE\n*        THE FOLLOWING SECTIONS ARE EXIT ROUTINES                     S\n*                                                                     S\nMCMXDR1  EQU   *\n         LA    RB,$ERVSYNT         SETT ERROR TYPE\nMCMXDFLG EQU   *\n         $CALL ERRTAG              FLAG STMNT\n         L     RZ,AVMCRINS         MOVE BASE TO 1ST ONE-OP\n         MVI   MCQS1FLG,$BSERR01   SHOW ERRIR BSU                     A\nMCPREFIX EQU   *                   ENTER FOR PREFIX/ONLY(NEND,MEXIT,ETA\n         LA    RZ,$LMCOPL1(,RZ)    SHOW @ END OF PREFIX               A\n         ST    RZ,AVADDLOW         RESTORE  LOW STORAGE\n         B     MCGNCDRT            AND RETURN\n         SPACE\nMCMXDR2  EQU   *\n         LA    RB,$ERMXDMD         SET MIXED MODE ERROR\n         B     MCMXDFLG            JUMP AND FLAG STMNT\n         SPACE\nMCSEQR1  EQU   *\n         LA    RB,$ERINVSY         SET BAD SYMBOL FLAG\n         XSNAP LABEL='BAD SYBOL FLAGGED',                              X\n               IF=(AVTAGSM,O,AJOMACRH,TM)                             A\n         B     MCMXDFLG            JUMP AND FLAG STMNT\n         SPACE\nMCGNCDOV EQU   *\n         L     REP,AVMOVRFL\n         BR    REP\n         SPACE\n**--> INSUB: MCGNALLO       ALLOCATE LOW CORE  + + + + + + + + + + + +S\n*+                                                                   +S\n*+       ALLOCATES SPACE FOR OPERAND ENTRIES                         +S\n*+                                                                   +S\n*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +S\n         SPACE 2                                                      S\nMCGNALLO EQU   *                                                      S\n         LA    RB,$LMCQUAD         LOAD LENGTH OF AREA NEEDED         S\n         $ALLOCL RZ,RB,MCGNCDOV    GET AREA FOR ONE OP                S\n         MVC   0($LMCQUAD,RZ),AWZEROS  ZERO ENTRY                     S\n         BR    RET                 RETURN                             S\n         SPACE 2                                                      S\nMCGNCDRT EQU   *\n         XSNAP LABEL='MCGENCD EXITED',                                 X\n               IF=(AVTAGSM,O,AJOMACRH,TM)                             A\n         AIF   (&$DEBUG).MCGNCDR\n         L     R1,AVMCRINS         GET @ OF ONE-OPS\n         XSNAP LABEL='***ONE-OP''S***',STORAGE=(*0(R1),*200(R1),*AVMWRK1\n               1,*AVMWRK1+64,*AVMWRK2,*AVMWRK2+64),IF=(AVMSNBY2,O,$MSNPX\n               10,TM)\n         XSNAP LABEL='***MCGNCD EXITED ***',IF=(AVMSNBY2,O,$MSNP10,TM)\n.MCGNCDR ANOP\n         $RETURN  RGS=(R14-R6)\n         LTORG\n         DROP  RAT,RW,RX,RY,RZ\n         TITLE 'MEXPND - MACRO EXPANSION'\n**-->  CSECT: MEXPND  EXPANDS MACRO DEFINITION. RECURSIVE. ACQUIRES   *\n*.        STORAGE FROM LOW DYNAMIC AREA FOR STANDARD SAVE AREA AND    *\n*.        LOCAL VARIABLES.  RELEASES STORAGE ON EXIT.  PUTS GENERATED *\n*.        STATEMENTS IN HIGH STORAGE.  AVGEN1CD POINTS TO FIRST BYTE  *\n*.        AFTER FIRST STATEMENT.  AVGEN1CD POINTS TO 1ST BYTE OF LAST *\n*.        STATEMENT GENERATED                                         *\n*.                                                                    *\n*.        USES MACROS:  $MALLOCL, $MALLOCH, $CALL, $SAVE, $RETURN,    *\n*.                      $AL2                                          *\n*.        USES DSECTS: MACLIB, MCGLBDCT, MCOPQUAD, MCPAROPR, MCPARSUB *\n*.                     AVWXTABL, MXPNTSAV, MCPARENT, RSBLOCK          *\n*.        CALLS ERRTAG, MCSCOP,MXMVSR,MACSCN,MACFND,MXMVSR,MXERRM,    *\n*.              ERRTAG,MEXPND,DECTRM                                  *\n*.                                                                    *\n*.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE\nMEXPND   CSECT\n         $SAVE RGS=(R14-R6),BR=13,SA=*                                A\n         USING AVWXTABL,RAT        NOTE MAIN TABLE USING\n         MVC   MXADDLOW(4),AVADDLOW SAVE ADDR OF LOW STORAGE          A\n         MVC   AVMACNST,AWZEROS    NEST LEVEL = 0                     A\n         MVI   AVMBYTE5,0          CLEAR CONT CARD INDICATOR\n         L     RC,AVRSBPT          SET BASE FOR SOURCE BLOCK\n         USING RSBLOCK,RC          SET USING FOR SOURCE\n         CLI   RSBNUM,3            WERE THERE ACTUALLY 3 CARDS IN STMTJ\n         BL    MEXPND0A            NO, SKIP CONTINUED-FURTHER TEST    J\n         L     RB,AVRSCPT          POINT TO CONT BLOCK\n         USING RSCBLK,RB           ESTAB USING ON CONT BLOCK\n         CLI   RSCONSQ+2*RSC$LEN,C' '   MORE THAN TWO CARDS?\n         BE    MEXPND0A            PROCEED IF NOT\n         NI    RSBFLAG,255-$REBX   TURN OFF ERROR FLAG\n         MVI   AVMBYTE5,$ERCONTX   ELSE SET CONT CARD INDICATR\n         DROP  RB,RC\nMEXPND0A EQU   *\n         OI    AVRSBLOC+1,$RSBNP##  TURN ON OUTER FLAG\n         L     RB,AVADDHIH         GET HIGH PNTR\n         LR    RC,RB               COPY INTO RC\n         STM   RB,RC,AVGEN1CD      MOVE INTO AVGEN1CD,AVGEN2CD\n         ST    RB,MEXGN2OV         SAVE ORIG VALUE, IN CASE OVERFLW JRM\n         LA    RB,L'MXPOVRMS+RSB$L   GET LENGTH OF MSSGE\n         $MALLOCH  R1,RB           GET STORAGE FOR ERROR MSSGE\n         ST    R1,MEXGN2OV         SAVE @, IN CASE OVERFLOW NPW     JRM\n         MVC   0(L'MXPOVRMS+RSB$L,R1),MXPOVRMS   MOVE ERROR MSSGE\n         LA    RE,RSB$L            GET LENGTH OF SNDRD PART OF RSBLOCK\n         IC    RB,AVRSBLOC         GET LENGTH-1 OF RSBLOCK\n         SR    RB,RE               DECR BY RSB$L\n         STC   RB,AVRSBLOC         RESTORE\n         MVC   AVGEN1CD,AVGEN2CD   DECR HIGH PNTR AWAY FROM MSSGE\n         EJECT                                                        S\nMEXPND01 EQU   *\n* EVERY NEST LEVEL                                                    A\n         L     RC,AVMACNST                                            A\n         LA    RC,1(,RC)           INCREASE BY ONE                    A\n         C     RC,AVMMNEST         TEST FOR OVER                      A\n         BH    MEXPMNES            OVER THE LIMIT                     A\n* FALLS THROUGH IF OK                                                 A\n         ST    RC,AVMACNST         STORE NEW LEVEL                    S\n         LR    R1,RZ               SAVE PREVIOUS @ MXPNTSAV           S\n         $MALLOCL RZ,RB,LENG=$LMXPTSV  GET SPACE FOR NEXT ONE         S\n         USING MXPNTSAV,RZ                                            A\n         ST    R1,MXPNLINK         STORE PREVIOUS RZ                  S\n         L     RA,AVRSBPT          LOAD SCAN POINTER                  S\n         LA    RA,RSB$L(RA)        GET @ OF SOURCE IMAGE              S\n         SPACE\n*  NEXT SECTION CHECKS NAME FOR VALIDITY\n         SPACE\n         $CALL MACSCN              SCAN SOURCE FOR FIELDS\n         L     RA,AVMFLD2          GET OPCODE @\n         CLI   AVMFLDT2,X'00'      UNIDENTIFIED OPCODE?\n         BE    MEXPND03            ERROR IF YES\n         MVC   AVMSYMBL,AWBLANK    ELSE CLEAR GLOBAL NAME AREA\n         MVC   AVMSYMLN,AVMFLDL2   MOVE LENGTH OF OPCODE\n         SR    R1,R1               CLEAR R1 FOR EX\n         IC    R1,AVMFLDL2         GET OPCODE LEN\n         BCTR  R1,0                DECR FOR EX INST\n         EX    R1,MXPNMVC          MOVE OPCODE NAME TO GLOBAL DICT    S\n         L     RC,AVMACLIB         GET MACLIB @\n         $CALL MACFND              SEARCH MACLIB\n         LTR   RB,RB               FOUND?\n         BZ    MEXPND04            IF YES, PROCEED\nMEXPND03 EQU   *\n         LA    RB,$ERIVOPC         ELSE SET BAD OPCODE FLAG\n         B     MXPNDERT            AND RETURN\nMEXPND04 EQU   *\n         USING MACLIB,RW           NOTE USING ON MACLIB\n         LR    RW,RC               SET MACLIB BASE\n         TM    MCLBTAGS,AVMCLBDF   PREVIOUSLY DEFINED MACRO?\n         BNO   MEXPND03            ERROR IF NOT\n         ST    RW,MXPNMCLB         SAVE MACLIB PNTR IN LOCAL AREA\n         LH    RA,MCPOPRNB          GET NBR OF OPRNDS\n         LA    RA,1(RA)            BUMP FOR LABEL FIELD\n         LA    RC,$LMPAROP         GET LEN OF SYM PAR DICT ENTRY\n         MR    RB,RA               GET LEN REQ'D\n         $MALLOCL  RY,RC           GET CORE FOR SYM PAR DICTIONARY\n         ST    RY,MXPNLSPT         COPPY PNTR TO SYM PAR DICT\n         SPACE\n*  NEXT SECTION ZEROS SYM PAR DICTIONARY AND INITIALIZES ENTRIESTO TYPE\n*  'O'.  ALSO FINDS FIRST KEYWORD D.V. IF ANY.\n         SPACE\n         USING MCPARENT,RX         SET USING FOR SYM PAR D.V.\n         USING MCPAROPR,RY         SET USING FOR SYM PAR DICT ENTRIES\n         L     RX,MCPARPNT         SET BASE FOR D.V.'S\n         MVC   MXPNKYPT(8),AWZEROS  CLEAR KEYWORD PNTRS\n         NI    AVMBYTE1,255-$MKEYOPR SHOW NO KEYWORDS YET             S\nMEXPND05 EQU   *\n         CLI   MCPARTYP,C'S'       SYSTEM VAR?\n         BNE   MEXPND06            IF NOT, PROCEED\n         L     RX,MCPARNXT         ELSE POINT TO NEXT ENTRY\n         B     MEXPND05            AND TRY AGIAN\nMEXPND06 EQU   *\n         ST    RX,MXPLSYPT         SET PNTR TO SYM PAR D.V.'S\nMEXPND07 EQU   *\n         MVC   MCPAROPR($LMPAROP),AWZEROS  CLEAR NEXT ENTRY\n         MVI   MCPAROTP,C'O'       SET TYPE TO NULL\n         CLI   MCPARTYP,C'K'       KEYWORD?\n         BNE   MEXPND08            JUMP TO FOOT IF NOT\n         TM    AVMBYTE1,$MKEYOPR   1ST KEYWRD DV FOUND?\n         BO    MEXPND08            JUMP TO FOOT IF YES\n         ST    RY,MXPNKLPT         SAVE @ OF 1ST KEYWRD DICT ENTRY\n         ST    RX,MXPNKYPT         SAVE @ OF 1ST KEYWRD D.V.\n         OI    AVMBYTE1,$MKEYOPR   TURN ON KEYWRD FOUND FLAG\nMEXPND08 EQU   *\n         L     RX,MCPARNXT         GET NEXT ENTRY PNTR\n         LTR   RX,RX               LAST ENTRY IN D.V.'S\n         BZ    MXPLAB01            PROCESS LABEL IF YES\n         LA    RY,$LMPAROP(RY)     ELSE BUMP DICT POINTER\n         B     MEXPND07            AND INITIALIZE NEXT ENTRY\n         SPACE 2\n*   NEXT SECTION PROCESS LABEL FIELD OF MACRO CALL\nMXPLAB01 EQU   *\n         NI    AVMBYTE1,X'FF'-$MKEYOPR  TURN OFF KEYWORD FLAG\n         L     RX,MXPLSYPT         SET BASE TO 1ST SYM PAR DV\n         L     RY,MXPNLSPT         POINT TO SYM PAR DICTIONARY\n         L     RA,AVMFLD1          GET @ OF LABEL\n         CLI   AVMFLDL1,X'00'      LABEL PRESENT?\n         BE    MXPOPR01            IF NOT, PROCESS OPRND FIELD\n         CLI   MCPARNLN,X'00'      LABEL OPRND DEFINED?\n         BNE   MXPLAB03            PROCESS IF YES\n         LA    RB,$ERILLAB         ELSE SET ILLEGAL LABEL FLAG\n         $CALL ERRTAG              FLAG STMNT\n         B     MXPOPR01            PROCESS OPRND\nMXPLAB03 EQU   *\n         SR    R2,R2               CLEAR R2\n         IC    R2,AVMFLDL1         GET LABEL LENGTH\n         LA    R2,3(,R2)           BUMP FOR ROUND/4                 JRM\n         SRL   R2,2                DIVIDE BY 4                      JRM\n         SLL   R2,2                MULT BY 4, ROUNDED UP            JRM\n         $MALLOCL   RB,R2          GET STORAGE\n         IC    R2,AVMFLDL1         GET LENGTH\n         STC   R2,MCPAROLN         SAVE LEN IN DICT ENTRY\n         BCTR  R2,0                DECR FOR EX INST\n         EX    R2,MXPNMVOP         MOVE LABEL TO STORAGE\n         MVI   MCPAROFL,X'FF'      SET DEFINED FLAG\n         MVI   MCPAROTP,C'U'       SET TYPR TO UNDEFINED\n         ST    RB,MCPAROPT         STORE OPRND LOC IN DICTIONARY\n         SPACE 2\n*   START PROCESSING OPRND FIELD.  IS THERE AN OPRND?\nMXPOPR01 EQU   *\n         MVC   MXPNBOPS,AWZEROS    INIT OPRND COUNT TO ZERO\n         CLC   MCPARNXT,AWZEROS    SYM PAR DV'S?\n         BE    MXPNOPFN            IF NOT, MOVE STMT TOHIG CORE\n         L     RA,AVMFLD3          GET OPRND @\n         LTR   RA,RA               OPRND PRESENT?\n         BNZ   MXPOPR03            PROCESS IF YES\n         IC    RA,AVMFLDL2         ELSE GET LEN OF OPCODE\n         A     RA,AVMFLD2          ADD OPCODE @ TO SCAN POINTER\n         DROP  RW                  DROP MACLIB USING\nMXPOPR03 EQU   *\n         ST    RA,AVMTSCNP         SAVE PNTR TEMP\n         TM    AVMBYTE1,$MKEYOPR   KEYWORD PROCESSED?\n         BO    MXPOPK01            JUMP IF YES\n         LA    RY,$LMPAROP(RY)     ELSE BYMP DICT PNTR\n         L     RX,MCPARNXT         AND GET NEXT DV ENTRY\n         LTR   RX,RX               FINAL ENTRY?\n         BNZ   MXPOPR04            PROCESS IF NOT\n         CLI   0(RA),C' '          OPRND PRESENT?\n         BE    MXPNOPFN            FINISHED IF NOT\n         LA    RB,$ERILOPR         ELSE SET NO OPRND ALLWD FLAG\n         $CALL ERRTAG              FLAG STMT\n         B     MXPNOPFN            AND JUMP TO FOOT\nMXPNMVOP MVC   0($,RB),0(RA)       DUMMY TO MOVE OPRND TO STORAGE\nMXPOPR04 EQU   *\n         CLI   MCPARTYP,C'K'       SYM PAR DV = KEYWORD?\n         BE    MXPOPK00            PROCESS KEYWORD                    S\nMXPOPR05 EQU   *\n         CLI   0(RA),C' '          OPRND PRESENT?\n         BE    MXPOPR07            CLEAN UP KEY WORDS IF NOT\n         CLI   0(RA),C','          COMMA INIDICATES NULL\n         BE    MXPOPR0C            BUMP OPRND COUNT IF YES\n         BAL   RET,MXPNOSY7        ORDINARY SYMBOL ?                  S\n         LTR   RB,RB               RB TELLS ALL\n         BNZ   MXPOPR06            JUMP AND SCAN OPRND IF NOT\n         CLI   0(RC),C'='          KEYWORD ?\n         BNE   MXPOPR06            PROCESS IF NOT\n         OI    AVMBYTE1,$MKEYOPR   SET KEYWORD FLAG\n         B     MXPOPK02            PROCESS KEYWRD OPRND\nMXPOPR06 EQU   *\n         BAL   RET,MXPOPSCN        SCAN OPRND, SAVE IN DICT\nMXPOPR0C EQU   *\n         L     R1,MXPNBOPS         GET OPRND COUNT\n         LA    R1,1(R1)            BUMP BY 1\n         ST    R1,MXPNBOPS         RESTORE\n         B     MXPOPRFT            JUMP TO FOOT\nMXPOPR07 EQU   *\n         BCTR  RA,0                DECR SCN PNTR TO CHECK FOR ','\n         CLI   0(RA),C','          COMMA PRESENT\n         LA    RA,1(RA)            RESTORE SCAN POINTER\n         BNE   MXPOPKFN            IF NOT, JUMP AND CLEAN UP\n         L     R1,MXPNBOPS         ELSE GET N' COUNT\n         LA    R1,1(R1)            BUMP\n         ST    R1,MXPNBOPS         RESTORE\n         B     MXPOPKFN            AND JUMP TO CLEAN UP\n         SPACE 2\nMXPOPK00 OI    AVMBYTE1,$MKEYOPR   SET KEYWORD FLAG                   S\nMXPOPK01 EQU   *                   PROCESS KEYWORD OPRNDS\n         CLI   0(RA),C' '          BLANK?\n         BE    MXPOPKFN            IF YES, FINISH KEYWORD PROTOTYEP\n         BAL   RET,MXPNOSY7        ORDINARY SYMBOL ?                  S\n         LTR   RB,RB               RB TELLS ALL\n         BNZ   MXPOPKFR            ERROR IF NONZERO, JUMP OUT\n         CLI   0(RC),C'='          KEYWORD ID?\n         BNE   MXPOPKFQ            FLAG ERROR IF NOT '='\nMXPOPK02 EQU   *\n         LA    RC,1(RC)            BUMP PAST '='\n         ST    RC,AVMTSCNP         SAVE ADDRESS OF DELIM\n         MVC   AVMSYMBL,AWBLANK    CLEAR GLOBAL AREA\n         STC   R1,AVMSYMLN         SAVE LENGHT\n         BCTR  R1,0                DECR FOR EX INST\n         MVI   AVMSYMBL,C'&&'      SET AMPERSAND IN GLOBAL FILED\n         EX    R1,MXPNMVC2                                            A\n         L     RC,MXPNKYPT         GET @ OF FIRST KEYWORD DV\n         $CALL MACFND              SEARCH SYM PAR LIST\n         LTR   RB,RB               SYMBOL FOUND?\n         BNZ   MXPOPKFQ            FLAG ERROR IF NOT FOUND\n         LR    RX,RC               MOVE BASE TO NEW ENTRY\nMXPOPK03 EQU   *\n         LA    RY,$LMPAROP         GET LENGTH OF ENTRY\n         MH    RY,MCPARNDX         MULT BY POSIT OF OPRND IN LIST\n         A     RY,MXPNLSPT         ADD BASE @ OF SYM PAR DICT\n         L     RA,AVMTSCNP         GET @ OF KEYWORD VALUE\n         CLI   MCPAROFL,X'FF'      PREVIOUSLY DEFINED?\n         BE    MXPOPK06            SET ERROR FLAG IF SO\n         CLI   0(RA),C' '          OPRND PRESENT?\n         BE    MXPOPK05            IF NOT, NULL OPRND\n         CLI   0(RA),C','          COMMA?\n         BE    MXPOPK05            ALSO NULL IF YES\n         B     MXPOPK04            ELSE PROCEED\nMXPOPK06 EQU   *\n         IC    R1,AVMSYMLN         GET LEN OF KEYWORD NAME\n         LA    R1,1(R1)            BUMP FOR '='\n         SR    RA,R1               RESTORE SCAN POINTER\n         B     MXPOPKFQ            JUMP AND FLAG ERROR\nMXPOPK04 EQU   *\n         BAL   RET,MXPOPSCN        SCAN OPRND AND SAVE IN TEMP STORGE\n         B     MXPOPRFT            JUMP TO FOOT\nMXPOPK05 EQU   *\n         MVI   MCPAROFL,X'FF'      NULL OPRND, SET DEFINED FLAG\n         B     MXPOPRFT            JUMP TO FOOT\n         SPACE\n*   NEXT ROUTINE CLEANS UP DEFAULTS FOR KEYWORD OPRNDS\nMXPOPKFQ EQU   *\n         LA    RB,$ERUNDKW         SET BAD KEYWORD FLAG\nMXPOPKFR EQU   *\n         $CALL ERRTAG              FLAG STMT\nMXPOPKFN EQU   *\n         L     RX,MXPNKYPT         POINT AT 1ST SYM PARDV KEYWORD\n         LTR   RX,RX               PRESENT?\n         BZ    MXPNOPFN            FINISHED IF ZERO\n         L     RY,MXPNKLPT         POINT TO 1ST KEYWORD DICT ENTRY\nMXPOPKF1 EQU   *\n         CLI   MCPAROFL,X'FF'      DEFINED?\n         BE    MXPOPKFB            JUMP TO FOOT IF YES\n         BAL   RET,MXPOPKPR        ELSE LOOK AT PROTOTYPE\nMXPOPKFB EQU   *\n         L     RX,MCPARNXT         GET NEXT KEYWORD OPRND\n         LTR   RX,RX               FINAL OPRND?\n         BZ    MXPNOPFN            FINI IF YES\n         LA    RY,$LMPAROP(RY)     BUMP DICTIONARY POINTER\n         B     MXPOPKF1            AND RESUME SCAN\n         EJECT                                                        S\n**--> INSUB: MXPOPKPR  + + + + + + + + + + + + + + + + + + + + + + + +S\n*+                                                                   +S\n*+       SCAN PROTOTYPE OPRND AND SAVE IN LOCAL DICTIONARY           +S\n*+                                                                   +S\n*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +S\n         SPACE 2                                                      S\nMXPOPKPR EQU   *\n         ST    RET,MXPKPRSV        SAVE RETURN @\n         MVC   MCPAROTP,MCPRATYP   COPY TYPE ATTRIB INTO DICTIONARY   J\n         CLI   MCPRATYP,C'O'       NULL OPRND?\n         BE    MXPPRKFT            FINI IF YES\n         L     RA,MCPROPRN         GET POINTER TO PROTOTYP OPRND\n         MVI   MCPARONB,1          ASSUME N' = 1 TEMPORARILY          J\n         MVC   MCPAROLN,MCPROPLN   COPY LENGTH\n         MVC   MCPAROPT,MCPROPRN   COPY POINTER\n         MVI   MCPAROFL,X'FF'      SET DEFINED FLAG\n         CLI   MCPAROTP,C'S'       SUB LIST?\n         BNE   MXPPRKFT            FIISHED IF NOT\n         MVI   MCPARONB,0          ZERO, SO WILL ACCUMULATE N' OK     J\n         BAL   RET,MXPNSBSC        SCAN OPRND SUB LIST\nMXPPRKFT EQU   *\n         L     RET,MXPKPRSV        RESTORE RETURN @\n         BR    RET                 AND RETURN\nMXPKPRSV DS    F                   STORAGE FOR RETURN @\n         EJECT                                                        S\n**--> INSUB: MXPOPSCN  + + + + + + + + + + + + + + + + + + + + + + + +S\n*+                                                                   +S\n*+       SCAN STD OPRND AND STORE IN LOW STORAGE                     +S\n*+                                                                   +S\n*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +S\n         SPACE 2                                                      S\nMXPOPSCN EQU   *\n         ST    RET,MXPPSCSV        SAVE RETURN @\n         ST    RA,AVMTSCNP         SAVE SCAN POINTER\n         NI    AVMBYTE1,X'FF'-$MSBLIST  TURN OFF SUBLIST FLAG\n         $CALL MCSCOP              SCAN OPRND\n         LTR   RB,RB               OKAY?\n         BNZ   MXPOPKFR            AND LEAVE OPRNDS\n         STC   RC,MCPAROLN         PUT OPRND LEN IN DICT\n         STC   RD,MCPAROTP         STORE TYPE\n         MVI   MCPAROFL,X'FF'      SET OPRND FLAG\n         LA    RC,3+1(,RC)         ROUND + 1 BYTE FOR DELIMITER AFTER J\n         SRL   RC,2                TRUNCATE\n         SLL   RC,2                BY SHIFITING\n         $MALLOCL  RB,RC           GET STORAGE\n         IC    RC,MCPAROLN         GET ORIGINAL LENGTH\n*              USE LENGTH RATHER THAN L-1: COPY DELIMITER AFTER ARG,  J\n*              HELPS MEXPND SCAN RIGHT FOR &I SETA &ARG OPERATION.    J\n         LR    R0,RA               COPY SCAN POINTER\n         L     RA,AVMTSCNP         GET ORIGINAL POINTER\n         ST    R0,AVMTSCNP         SAVE SCAN POINTER\n         EX    RC,MXPNMVOP         MOVE OPRND TO LOW STORAGE\n         ST    RB,MCPAROPT         SAVE OPRND @ IN DICTIONARY\n         CLI   MCPAROTP,C'S'       SUB LIST?\n         BE    MXPOPSBS            PROCESS SUBLIST IF YES\n         MVI   MCPARONB,1          ELSE SET OPRND COUNT TO 1\n         B     MXPOPSCF\nMXPOPSBS EQU   *\n         LR    RA,RB               SCAN PNTR TO OPRND\n         BAL   RET,MXPNSBSC        SCAN SUB OPRNDS\nMXPOPSCF EQU   *\n         L     RA,AVMTSCNP         RESTORE SCAN POINTER\n         L     RET,MXPPSCSV        RESTORE RETURN @\n         BR    RET                 AND RETURN\nMXPPSCSV DS    F                   STORAGE FOR RETURN @\n         EJECT                                                        S\n**--> INSUB: MXPNSBSC  + + + + + + + + + + + + + + + + + + + + + + + +S\n*+                                                                   +S\n*+     SCAN OPRND SUBLIST, CREATE ENTRY IN DICTIONARY                +S\n*+                                                                   +S\n*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +S\n         SPACE 2                                                      S\nMXPNSBSC EQU   *\n         ST    RET,MXPNSBSV        SAVE RETURN @\n         USING MCPARSUB,RW         NOTE USING ON SUBOPRND ENTRY\n         LA    RA,1(RA)            BUMP PAAST '('\n         OI    AVMBYTE1,$MSBLIST   SET SUBLIST FLAG\nMXPNSB01 EQU   *\n         LA    RB,$LMPARSB         GET LENGTH OF SUB ENTRY\n         $MALLOCL  RW,RB           GET STORAGE\n         MVC   0($LMPARSB,RW),AWZEROS  CLEAR ENTRY\n         ST    RA,MCPARSPT         SAVE POINTER TO SUB ENTRY STRNG\n         $CALL MCSCOP              SCAN SUB OPRND\n         LTR   RB,RB               ERROR?\n         BZ    MXPNSB02            PROCEED IF NOT\n         S     RA,MCPAROPT         GET OFFSET OF POINTER\n         LR    RE,RA               COPY TEMPORARILY\n         IC    RA,MCPAROLN         GET LENGTHOF OPRND\n         S     RA,AVMTSCNP         SUBTRACT CURRENT PNTR\n         LPR   RA,RA               GET POS VALUE\n         AR    RA,RE               ADD OFFSET OF ERROR\n         B     MXPOPKFR            FORGET ABOUT REST OF OPRNDS\nMXPNSB02 EQU   *\n         CLI   MCPARONB,X'00'      1ST SUB OPRND?\n         BNE   MXPNSB03\n         STC   RD,MCPAROTP         MAIN OP TYPE = 1ST SUB TYPE\n         ST    RW,MCPRSBPT         SAVE PNTR TO SUB ENTRIES\nMXPNSB03 EQU   *\n         STC   RC,MCPARSLN         SAVE LEN IN DV\n         STC   RD,MCPARSTP         SAVE TYPE\n         IC    RD,MCPARONB         GET SUB OPRND COUNT\n         LA    RD,1(RD)            BUMP BY ONE\n         STC   RD,MCPARONB         RESOTRE\n         CLI   0(RA),C')'          END OF LIST?\n         LA    RA,1(RA)            BUMP PAST DELIM\n         BNE   MXPNSB01            RESUME SCAN IF NO ')'\n         L     RET,MXPNSBSV        GET RETURN @\n         BR    RET                 AND RETURN\nMXPNSBSV DS    F                   SPACE FOR RETURN @\n         DROP  RW\n         EJECT                                                        S\n**--> INSUB: MXPNOSYM       DETERMINS IF STRING IS ORDINARY  + + + + +S\n*+           SYMBOL OF EITHER LENGTH 7 OR 8 (MAX)                    +S\n*+           MXPNOSY7:  SETS RB = 7                                  +S\n*+                                                                   +S\n*+             ENTRY CONDITIONS:                                     +S\n*+       RA = 1ST CHAR OF SYMBOL                                     +S\n*+       RB = ALLOWABLE LENGTH (7 OR 8)                              +S\n*+                                                                   +S\n*+             EXIT CONDITIONS:                                      +S\n*+       RA = SAME AS ENTRY                                          +S\n*+       RB = ERROR INDICATION  (0 --> OK)                           +S\n*+       RC = @ OF DELIM PAST SYMBOL                                 +S\n*+       R1 = LENGTH OF SYMBOL                                       +S\n*+                                                                   +S\n*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +S\n         SPACE 2                                                      S\nMXPNOSY7 LA    RB,7                SET MAX LENGTH OF KEYWORD          S\nMXPNOSYM EQU   *\n         CLI   0(RA),C'0'          FIRST CHAR = DIGIT?\n         BNL   MXPSYMR1            ERROR IF YES\n         EX    RB,MXPNOSSC         SCAN SYMBOL\n         BZ    MXPSYMR2            ZERO MEANS TOO LONG\n         LR    RC,R1               ELSE MOVE DELIM TO RC\n         SR    R1,RA               GET LENGTH IN R1\n         BZ    MXPSYMR2            NO SYMBOL IF ZERO LENGTH\n         SR    RB,RB               CLAR RB FOR RETURN\n         BR    RET\nMXPSYMR1 EQU   *\nMXPSYMR2 EQU   *\n         LA    RB,$ERINVSY         SET BAD SYMBOL FALG\n         BR    RET                 AND RETURN\nMXPNOSSC TRT   0($,RA),AWTSYMT     DUMMY FOR SCAN\n         EJECT                                                        S\nMXPOPRFT EQU   *\n         CLI   0(RA),C' '          BLANK?\n         BE    MXPOPR03            RESUME SCAN IF YES\n         LA    RA,1(RA)            ELSE BUMP PAST DELIM\n         CLI   0(RA),C' '          BLANK AFTER ','?\n         BNE   MXPOPR03            RESUME SCAN IF NOT\n         SPACE 1\n         L     RC,AVRSBPT          SET BASE OF RSBLOCK\n         USING RSBLOCK,RC          NOTE USING ON RSBLOCK\n*              POSSIBLE NON-STND CONT CARD\n         CLI   RSBNUM,1            ONLY 1 CARD?\n         BE    MXPOPR03            RESUME SCAN IF YES\n         LA    RB,RSBLOCK+RSB$L+RSOL1  POINT TO 1ST BYTE, 2ND CARD\n         CR    RA,RB               POINTING AT WHICH CARD?\n         BNH   MXPOPC#2            PROCESS 2ND CARD IF LOW\n         CLI   RSBNUM,3            TWO CONT CARDS?\n         BNE   MXPOPR03            RESUME SCAN IF NOT\n         LA    RB,RSOLC(RB)        POINT TO 1ST BYTE, 3RD CARD\n         CR    RA,RB               WHERE IS SCAN POINTER?\n         BH    MXPOPC#3            CHECK FOR 4TH CARD\nMXPOPC#2 EQU   *\n         LR    RA,RB               MOVE SCAN POINTER TO CONT CARD\n         CLI   0(RA),C' '          CONT CARD IS NON BLANK?\n         BNE   MXPOPR03            PROCEED IF YES\n         LA    RB,$ERVILCH         SET BAD CONT CARD ERROR FLAG\n         B     MXPOPKFR            AND JUMP TO FOOT\n         SPACE 2\nMXPOPC#3 EQU   *\n         CLI   AVMBYTE5,$ERCONTX  MORE THAN TREE CARDS?\n         BNE   MXPOPR03            PROCEED WITH SCAN IF NOT\n         $CALL MXMVSR              ELSE MOVE CARDS TO HIGH CORE\n         LTR   RB,RB               CORE EXCEEDED?\n         BNZ   MXPNDOVR            JUMP OUT IF YES\n         BAL   RET,MXPNRDR         ELSE READ CONT CARDS\n         L     RC,AVRSBPT          ESTAB BASE ON RSBLOCK\n         LA    RA,RSBSOURC         POINT TO STMT START\n         CLC   0(15,RA),AWBLANK    COLS 1-15 BLANK?\n         BE    MXPOPC#4            OKAY IF YES\n         LA    RB,$ERCONT          ELSE SET ERROR FLAG\n         $CALL ERRTAG              AND FLAG STMT\nMXPOPC#4 EQU   *\n         LA    RA,15(RA)           POINT TO COL 16\n         B     MXPOPR03            AND RESUME SCAN\n         EJECT                                                        S\n**--> INSUB: MXPNRDR   + + + + + + + + + + + + + + + + + + + + + + + +S\n*+                                                                   +S\n*+             CARD READER FOR ROUTINE MEXPND                        +S\n*+                                                                   +S\n*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +S\n         SPACE 2                                                      S\nMXPNRDR  EQU   *                                                      S\n         ST    RET,MXPNRDSV        SAVE RETURN @\n         MVC   MXPGENCD,AVGEN1CD   COPY AVGEN1CD\n         MVC   AVGEN1CD,AVGEN2CD   MAKE PNTRS EQUAL FOR INCARD\n         $CALL INCARD              READ NEXT STMT\n         OI    AVRSBLOC+1,$RSBNPNN SET NO PROCESS FLAG                S\n         SR    RE,RE              CLEAR RE\n         IC    RE,AVRSBLOC        GET LENG-1 OF STMT\n         LA    RD,RSB$L           GET LENGTH OF STND PART\n         SR    RE,RD              SUBTRACT FROM OVERALL LENGTH\n         STC   RE,AVRSBLOC        RESTORE REDUCED LENGTH\n         MVC   AVGEN1CD,MXPGENCD   RESTORE AVGEN1CD POINTER\n         STC   RB,AVMBYTE5         SAVE ERROR FLAG\n         CLI   AVMBYTE5,$ERCONTX   MORE THAN THREE CARDS?\n         BE    MXPNRDRT            PROCEED IF YES\n         LTR   RB,RB               ELSE TEST FOR ERROR\n         BZ    MXPNRDRT            PROCEED IF NONE\n         $CALL ERRTAG              ELSE FLAG STMT\n         TM    AVTAGS2,$INEND2     END OF FILE ERROR?\n         BO    MXPNDERT            JUMP OUT IF YES\nMXPNRDRT EQU   *\n         L     RET,MXPNRDSV        RESTORE RETURN @\n         BR    RET                 AND RETURN\nMXPNRDSV DS    F                   SPACE FOR RETURN @\nMXPGENCD DS    F                   TEMP STORAGE FOR AVGEN1CD\n         EJECT                                                        S\n*        NORMAL EXIT CODE                                             S\n         SPACE 1                                                      S\nMXPNOPFN EQU   *\n         $CALL MXMVSR              MOVE SOURCE TO HIGH AREA\n         CLI   AVMBYTE5,$ERCONTX   4 CARDS?\n         BNE   MXPNOPFP            PROCEED IF NOT\n         BAL   RET,MXPNRDR         ELSE READ NEXT CARD\n         L     RC,AVRSBPT          SET BASE FOR RSBSOURC\n         OI    RSBFLAG,$RSBNPNN    SET NO ACTION FLAG\n         B     MXPNOPFN            AND PTINT CARDS\n         DROP  RC\nMXPNOPFP EQU   *\n         CLC   AVMACNST,AWF1       WAS THIS ACTUALLY OUTER MACRO CL JRM\n         BNE   *+10                NO, SO SKIP RESET OF PTR         JRM\n         MVC   MEXGN2OV,AVGEN2CD   THUS SAVE CURRENT PTR FOR OVRFL  JRM\n         LTR   RB,RB               OVERFLOW?\n         BZ    MXPNLOCD            PROCEED IF NOT\n         SPACE 3                                                      S\n*        OVERFLOW EXIT                                                S\n         SPACE 1                                                      S\nMXPNDOVR EQU   *\n         MVC   AVGEN1CD,AVADDHIH   SET PNTR TO OVRFLW MESSAGE\n         MVC   AVGEN2CD,MEXGN2OV   RESET OVERFLO PTR, SHOW @ EITHER OF #\n               AS218 MESSAGE OR OF OUTER MACRO CALL.                JRM\n         B     MXNORML                                                A\n         SPACE 1                                                      A\n         SPACE\nMEXGN2OV DC    F'0'                @ LAST STMT, IF OVERFL**MOVE***  JRM\nMXPOVRMS DC    C'218 STORAGE EXCEEDED BY FOLLOWING MACRO EXPANSION'\n         DC    AL1(L'MXPOVRMS-1,$RSBNPNN+$RSBMERR,$,$)\n         SPACE\n         DS    0H                                                     A\nMEXPMNES EQU   *                   ERROR EXIT MNEST LIMIT             A\n         LA    RB,$EREXMAC                                            A\n         L     RA,AVRSBPT                                             A\n         LA    RA,RSB$L+10(RA)     POINT TO OPCODE                    A\nMXPNDERT DS    0H\n         $CALL ERRTAG\n         $CALL MXMVSR              MOVE SOURCE TO HIGH AREA IF INNER\n         LTR   RB,RB               OVERFLOW?\n         BNZ   MXPNDOVR            JUMPP AND FLAG IF YES\n*                                                                     S\n*        NORMAL RETURN SEQUENCE FOR MEXPND                            S\n*         -- ALSO SET PTR TO RELEASE LOW STORAGE AREA                 S\n*                                                                     S\nMXNORML  EQU   *                   NORMAL RETURN                      A\n         MVC   AVADDLOW,MXADDLOW   RESTOR PTR                         A\n         SR    RB,RB               SHOW NORMAL RETURN ALWAYS          J\n         $RETURN RGS=(R14-R6)                                         A\n         SPACE 4\n*   NEXT SECTION ALLOCATES AND INITIALIZES STORAGE FORLOCAL SET SYMBOL*\n*    DICTIONARY\nMXPNLOCD EQU   *\n         SPACE\n         AIF   (&$DEBUG).MXPNLDB\n         L     RA,MXPNLSPT         GET PNTR TO SYM PAR DICT\n         L     R1,AVGEN2CD         GET PNTR TO HIGH AREA\n         L     R2,AVADDHIH         GET PNTR TO BEGINNING OF HIGH AREA\n         XSNAP LABEL='***SYM PAR DICT INITIALIZED***',                 X\n               IF=(AVMSNBY2,O,$MSNP11,TM),                             X\n               STORAGE=(*0(R1),*0(R2),*0(R13),*124(R13),*0(RA),*128(RA)X\n               )\n.MXPNLDB ANOP\n         SPACE\n         AP    AVMSYSDX,AWP1       BUMP SYSNDX COUNTER\n         ZAP   MXPSYSDX,AVMSYSDX   COPY INTO LOCAL AREA\n         L     RW,MXPNMCLB         GET POINTER TO MACLIB\n         USING MACLIB,RW           SET USING\n         MVC   MXPNCDPT,MCCODLNK  SAVE PNTR TO CODE\n         L     R1,MCLOCDLN         GET LEN OF LOCAL DICTIONARY\n         $MALLOCL  R2,R1           GET CORE FOR SET SYMBOL DICT\n         ST    R2,MXPNLDBS         SAVE BASE IN LOCAL AREA\n*  INITIALIZE DICTIONARY TO ZEROS\n         LR    R0,R1               SAVE COMPLETE LENGTH FOR LATER     J\n         BCTR  R1,0                DECR COUNT\n         EX    R1,MXPNMVZR         CLEAR LENGTH MOD 256\n         SRA   R1,8                SHIFT TO GET # 256 BYTE BLOCKS LEFT\n         BNP   MXPNLOC2            SKIP IF NO MORE TO DO\n         N     R0,AWFXFF      GET LAST BYTE OF LENGTH                 J\n         AR    R2,R0               GET @ FIRST BYTE TO ZERO           J\n         SPACE 1\n         MVC   0(256,R2),AWZEROS   CLEAR 256 BYTES AT A TIME\n         LA    R2,256(,R2)         INCREMENT TO NEXT\n         BCT   R1,*-10             LOOP, CLEARING UNTIL DONE\n         SPACE\nMXPNLOC2 EQU   *\n         L     R2,MXPNLDBS         GET BASE OF SET SYMB LOCAL DICT\n         MVC   0(4,R2),AVMMACTR    SET ACTR LIMIT\n         TM    AVMBYTE4,$MGENSTP   ARE MACROS KILLED ?                S\n         BO    MXNORML             IF YES, RETURN                     S\n         MVC   MXPNCRCD,MXPNCDPT   SET PTR TO 1ST INSTR               S\n         SPACE 2                                                      S\n*        THIS NEXT SECTION OF CODE SETS CALLING                       S\n*        ARGUMENTS AND CALLS MXINST TO                                S\n*        INTERPRET DICTIONARY ONE-OPS AND                             S\n*        CREATE GENERATED CODE -----                                  S\n*        THEN USE RETURNED CODE TO BRANCH ON INDEX                    S\n*        FOR FURTHER PROCESSING                                       S\n         SPACE 2                                                      S\nMXPNCALL EQU   *                                                      S\n         LR    RC,RZ               SET CALLING CONVENTION             S\n         XCALL MXINST              CALL ROUTINE                       A\n         B     *+4(RB)             BRANCH ON RETURNED INDEX           S\n         B     MXPNDX0             RB=0 MEND,MEXIT                    A\n         B     MEXPND01            RB=4 INNER MACRO CALL              A\n         B     MXNORML             RB=8   KILL THIS NEST              S\n         B     MXKILMAC            RB=12  KILL ALL MACROS             S\n         B     MXPNDOVR            RB=16  STORAGE OVERFLOW            S\n         SPACE 2                                                      S\n*        SET FLAG TO KILL ALL MACROS                                  S\n*                                                                     S\nMXKILMAC EQU   *                   KILL ALL MACROS                    A\n         OI    AVMBYTE4,$MGENSTP   LILL                               A\n         B     MXNORML                                                A\n*                                                                     S\n*        BACK UP NEST DEPTH COUNTER AND CALL MXINST                   S\n*        AGAIN IF NOT DONE WITH NEST                                  S\n*                                                                     S\nMXPNDX0  EQU   *                                                      S\n         ST    RZ,AVADDLOW         STORE CURRENT RZ                   S\n         L     R0,AVMACNST         GET NEST LEVEL                     S\n         BCTR  R0,0                DECR BY 1                          S\n         ST    R0,AVMACNST         STORE NEW DEPTH LEVEL              S\n         LTR   R0,R0               LEVEL = 0 ?                        S\n         L     RZ,MXPNLINK         GET NEXT LINK                      S\n         BZ    MXNORML             NO MORE, RETURN                    S\n         L     RE,MXPNCRCD         GET @ OF LAST INSTR PROC (CALL)    S\n         USING MCOPQUAD,RE         NOTE ONE-OP PTR                    S\n         MVC   MXPNCRCD,MCQUDNXT   GET @ OF NEXT INSTR (AFTER CALL)   S\n         DROP  RE                  REMOVE USING                       S\n         B     MXPNCALL            CALL MXINST TO GENERATE CODE       S\n         SPACE 2                                                      S\n*        DEFINED CONSTANTS/STORAGE & DUMMY INSTRS                     S\nMXADDLOW DS    F                   FULL WORD TO SAVE AVADDLOW         S\nMXPNMVZR MVC   0($,R2),AWZEROS     DUMMY INSTR                        S\nMXPNMVC2 MVC   AVMSYMBL+1($),0(RA) DUMMY INSTR                        S\nMXPNMVC  MVC   AVMSYMBL($),0(RA)   DUMMY INSTR                        S\n         LTORG                                                        S\n         DROP  RW,RX,RY,RZ                                            S\n         TITLE 'MXINST -- INTERPRETATION PHASE'                       S\n**--> CSECT: MXINST       EXECUTE INSTRUCTIONS IN MACRO DEF          *S\n*.             ENTRY CONDITIONS:                                     *S\n*.       RC = @ MXPNTSAV                                             *S\n*.             EXIT CONDITIONS:                                      *S\n*.       RB = 0                    MEND OR MEXIT FOUND               *S\n*.            4                    INNER MACRO CALL                  *S\n*.            8                    KILL THIS MACRO NEST              *S\n*.           12                    KILL ALL MACROS                   *S\n*.           16                    STORAGE OVERFLOW                  *S\n*.                                                                   *S\n*.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **S\n         SPACE 2                                                      S\nMXINST   CSECT                                                        A\n         $SAVE RGS=(R14-R6),BR=13,SA=*                                A\n         USING AVWXTABL,RAT        NOTE MAIN TABLE USING              S\n         USING MCOPQUAD,RW         NOTE USING ON ONE-OP\n         MVC   AVRSBLOC(RSB$L),AWZEROS   ZERO STND PART OF RSBLOC\n         MVC   AVRSBLOC+4($LMSRCMX),AWBLANK   BLANK REMAINDER\n         LR    RZ,RC                                                  A\n         USING MXPNTSAV,RZ                                            A\n         L     RW,MXPNCRCD                                            A\n         XSNAP LABEL='MXINST INIT',STORAGE=(*MXPNTSAV,*MXPNLSPT+4,*AVADX\n               DLOW,*AVWXEND),IF=(AVTAGSM,O,AJOMACRG,TM)              S\n         $SPIE MXPNINJE,((8,9)),ACTION=CR,CE=MXPNZDIV  PRODUCTION TYPE\n         ST    R1,AVMXSPIE         SAVE PREV INT BLOCK @\n         B     MXPNIN01            SKIP, BEGIN AT 1ST ONE-OP\n         SPACE\nMXPNEXBS DS    0H                  ESTAB BASE FOR INDEX TABLE\nMXPNINJE EQU   *                   ENTER HERE TO FLAG ERROR AND GO ON\n*              TO NEXT ONE OP.  EXPECTS RB = ERROR CODE.\n         BAL   R1,MXINERRM         GENERATE ERROR MESG                A\n         SPACE 1\nMXPNINJP EQU   *                   COME HERE FOR EACH NON-BRANCH STMT\n*                                  AFTER VERY FIRST ONE.\n         L     RW,MXPNCRCD         RESTORE BASE TO 1ST ONE-OP\n         L     RW,MCQUDNXT         GET @ NEXT SEQUENTIAL INSTRUCTION\n         SPACE 1\nMXPNINJQ EQU   *                   COME HERE FOR AGO/GOOD AIF. RW= @\n         AIF   (NOT &$MACOPC).MXINSTA  SKIP IF NOT OPEN CODE          S\n*        ALLOW ONLY ONE STATEMENT DONE IF IN OPEN CODE                S\n         L     RX,MXPNMCLB         LOAD @ OF MACLIB ENRTY             A\n         USING MACLIB,RX           NOTE USING ON MACLIB               S\n         TM    MCLBFLG2,$MCOCFL1   IN OPEN CODE ?                     S\n         BO    MXMEND              RETURN IF YES                      S\n         DROP  RX                                                     S\n.MXINSTA ANOP                                                         S\n         SPACE\n         AIF   (&$DEBUG).MXPNNDB\n         L     R1,MXPNCRCD         GET @ OF CURRENT INST\n         L     R2,AVMCHSTR         GET POINTER TO CHAR WORK AREA\n         XSNAP LABEL='***INSTRUCTION EXECUTED***',                     X\n               IF=(AVMSNBY2,O,$MSNP11,TM),                             X\n               STORAGE=(*0(R1),*128(R1),*0(R2),*128(R2))\n.MXPNNDB ANOP\n         SPACE\n         L     R1,AVMMSTMG         GET GLOBAL LIMIT ON ISNTRUCTIONS\n         S     R1,AWF1             DECR COUNT\n         ST    R1,AVMMSTMG         RESTORE\n         BNP   MXMENDER            GO TO FLAG ERROR AND STOP\n         SPACE\nMXPNIN01 EQU   *\n         MVC   MXPCHRBF,AVMCHSTR   INIT BUFFER POINTER\n         ST    RW,MXPNCRCD         UPDATE CURRENT INST POINTER\n*        EACH STMT CONSISTS OF ONE-OP PREFIX(PTR,STMT#,STC),          A\n*        FOLLOWED BY 0-MORE REGULAR ONE-OPS(MXOPQUAD DSECT)L          A\n*        FOR ANOP,MEND,MEXIT,$BSERR01(ERROR), THE OPERATOR            A\n*        CODE IS IN PREFIX (MCQS1FLG). FOR OTHERS, IT =0              A\n         CLI   MCQS1FLG,0          WAS IT NORMAL PREFIX WITH ONE-OPS  A\n         BE    MXPNIN03            YES SKIP SPECIAL CODE              A\n         IC    R2,MCQS1FLG         GET OPERATOR TYPE                  A\n         B     MXPNPREF            GO TO PREFIX ONLY CODE             A\nMXPNIN03 SH    RW,=AL2($LMCQUAD-$LMCOPL1) BACK UP,SO WILL BUMP RIGHT  A\n*        FALL THRU, START DOING ONE-OPS                               A\n         EJECT\n*   NEXT SECTION PROCESSES A SINGLE ONE-OP\nMXPNONJP EQU   *\n         LA    RW,$LMCQUAD(RW)     BUMP PAST CURRENT ONE-OP\n         SR    RA,RA               CLEAR FOR INSERTS****************JRM\n         MVI   AVMBYTE2,X'00'      CLEAR FLAG BYTE FOR TYPE USE       A\n         IC    RA,MCARG1DX         GET INDEX OF 1ST ARG\n         L     RB,MCARG1LC         GET LOC OF 1ST ARG\n         IC    R2,MCBOPRTR         GET OPCODE\nMXPNPREF EQU   *                   ENTER HERE FOR PREFIX ONLY ONES    A\n         N     R2,=X'0000007E'     MASK OUT CHAR REL BIT, SPECIAL PRINA\n         LH    R1,MXPNINDX(R2)     GET OFFSET\n         XSNAP LABEL='MXPNONJP',STORAGE=(*0(RW),*16(RW)),              X\n               IF=(AVTAGSM,O,AJOMACRH,TM)\n         B     MXPNEXBS(R1)        JUMP TO ROUTINE\n               SPACE\nMXPNINDX $AL2  MXPNEXBS,(MXFIN,MXPLUS,MXMIN,MXMULT,MXDIV,MXOR,MXAND,MXN#\n               OT,MXNE,MXGE,MXLE,MXLT,MXEQ,MXGT,MXCAT,MXAGO,MXAIF,MXSET#\n               A,MXSETB,MXSETC,MXINV,MXINV,MXSBSCRP,MXSBST,MXSYSL,MXINV#\n               ,MXPRNT,MXMEXIT,MXMEND,MXANOP,MXERRMS,MXINMAC,MXMVSTMT)\n         SPACE\n*   ENTRY POINT FOR SPIE ACTION\nMXPNZDIV EQU   *\n         USING MXPNZDIV,REP\n         LA    RB,$ER#ZDIV         SET ERROR FLAG\n         BR    RET                 RETURN NOW, RB SET\n         AIF   (&$DEBUG).MACQQ04   SKIP IF NO DEBUG\n         ORG   *-2                 GET BACK OVER NON-DEBUG CODE\n         CLI   3(R1),8             FIXED POINT OVERFLOW?\n         BCR   E,RET               RETURN IF YES FOR MORE SPIE ACTION\n         CLI   3(R1),9             ZERO DIVIDE?\n         BCR   E,RET               RETURN IF YES FOR MORE SPIE ACTION\n         L     RA,AVGEN2CD         ELSE POINT TO LOW END OF HIGH CORE\n         L     RB,AVADDHIH         POINT TO HIGH END OF HIGH CORE\n         L     RC,AVMACLIB         POINT TO START OF LOW CORE\n         L     RD,AVADDLOW         POINT TO HIGH END OF LOW CORE\n         XSNAP LABEL='*** INTERRUPT IN MACRO EXPANSION ***',           X\n               STORAGE=(*0(R1),*20(R1),*0(RA),*0(RB),*0(RC),*0(RD),*AVA#\n               DDLOW,*AVWXEND,*0(R13),*130(R13))\n         DC    X'00FF'             FORCE INTERRUPT\n.MACQQ04 ANOP\n         DROP  REP\n         SPACE\n*                                                                     A\nMXPLUS   EQU   *\nMXMIN    EQU   *\n*        ARITHMETIC OPERATIONS HERE                                   A\nMXMULT   EQU   *\nMXDIV    EQU   *\n         BAL   RET,MXARITH         CVRT 1ST ARG TO ARITH VLUE\n         ST    RC,MXARG1           SAVE TEMPORRAILY\n         IC    RA,MCARG2DX         GET 2ND ARG TYPE\n         L     RB,MCARG2LC         GET LOCATION OF 2ND ARG\n         BAL   RET,MXARITH         GET ARITH VALUE\n         LR    RD,RC               COPY INTO RD\n         L     RB,MXARG1           RELOAD 1ST ARGUMENT**************JRM\n         SRDA  RB,32               MOVE OVER TO RC, WITH SIGN RIGHT\n         IC    RA,MCBOPRTR         GET OPCODE\n         EX    0,MXARITOP-2(RA)    EXECUTE CORRECT OPERATION\n         ST    RC,MCRESULT         PUT RESULT IN ONE-OP\n         MVI   MCRSLTYP,$BSIMMA    SET TYPE\n         B     MXPNONJP            GET NEXT ONE-OP\n         SPACE 1\nMXARITOP DS    0H                  TABLE OF INSTRS TO BE EXECUTED\n         AR    RC,RD               ADD\n         SR    RC,RD               SUBTRACT\n         MR    RB,RD               MULTIPLY\n         DR    RB,RD               DIVIDE\n         EJECT                                                        A\n* LOGICAL OPERATORS                                                   A\n*                                                                     A\nMXOR     EQU   *\nMXAND    EQU   *\n         BAL   RET,MXBOOL          GET 1ST ARG VALUE\n         ST    RC,MXARG1           SAVE TEMPORARILY\n         IC    RA,MCARG2DX         GET 2ND ARG TYPE\n         L     RB,MCARG2LC         GET 2ND ARG LOC'N\n         BAL   RET,MXBOOL          GET 2ND ARG VALUE\n         L     RD,MXARG1           RESTORE 1ST ARG VALUE\n         CLI   MCBOPRTR,$BSOR      OR OPRND?\n         BE    MXOR01              JUMP TO OR IF YES\n         NR    RC,RD               ELSE CARRY OUT AND OPERATION\n         B     MXOR02              JUMP TO FOOT\nMXOR01   EQU   *\n         OR    RC,RD               CARRY OUT OR OPERATION\nMXOR02   EQU   *\n         ST    RC,MCRESULT         STORE RESULT IN ONE-OP\n         MVI   MCRSLTYP,$BSIMMB    SET TYPE\n         B     MXPNONJP            GET NEXT ONE-OP\n         SPACE\nMXNOT    EQU   *\n         BAL   RET,MXBOOL          CONVERT TO BOOL VALUE\n         X     RC,AWF1             DO EXCLUSINVE OPERATION\n         B     MXOR02              SAVE RESULT IN ONE-OP\n         EJECT\nMXNE     EQU   *\nMXGE     EQU   *\nMXLE     EQU   *\nMXLT     EQU   *\nMXEQ     EQU   *\nMXGT     EQU   *\n         LA    R1,$BSNE            GET $BSNE VALUE IN R1\n         SRL   R2,1                DIVIDE OPCADE BU 2                 A\n         IC    R2,MXRELOPS-($BSNE/2)(R2)                              A\n         STC   R2,MXRELCH2+1       SAVE IT                            A\n         MVI   MCRSLTYP,$BSIMMB    SET RESULT TYPE\n         MVC   MCRESULT,AWZEROS    ASSUME FALSE FOR START\n         TM    MCBOPRTR,$BSRLCHR   CHAR RELATION?\n         BO    MXRELCHR            PROCESS CHAR REL IF YES\nMXRELAR  EQU   *                   ELSE PROCESS ARITH RELATION\n         BAL   RET,MXARITH         GET 1ST VALUE\n         ST    RC,MXARG1           STORE TEMP\n         IC    RA,MCARG2DX         GET ARG2 INDEX\n         L     RB,MCARG2LC         GET ARG2 LOCATION\n         BAL   RET,MXARITH         GET ARITH VALUE\n         L     RB,MXARG1           GET 1ST ARG\n         CR    RB,RC               COMPARE OPRNDS\n         B     MXRELCH2            FALL THROUGH MEANS FALSE           A\nMXRLATRU EQU   *                   TARGET FOR TRUE CONDITION\n         MVI   MCRESULT+3,X'01'    SET RESULT TO TRUE\n         B     MXPNONJP            GET NEXT ONE-OP\nMXRELCHR EQU   *\n         BAL   RET,MXCHAR          GET ARG1 CHAR VLAUE\n         STM   RB,RC,MXARG1LN      SAVE LEN AND TYPE TEMP\n         IC    RA,MCARG2DX         GET ARG2 TYPE\n*                                                                     A\n         L     RB,MCARG2LC         GET ARG2 LOC\n         BAL   RET,MXCHAR          GET CHAR VALUE\n         LR    RD,RB               MOVE 2ND ARG LEN TO RD\n         LR    RE,RC               MOVE 2ND ARG LOC TO RE\n         LM    RB,RC,MXARG1LN      RESTORE LEN AND TYPE\n         CR    RB,RD               COMPARE LENGTHS\n         BNE   MXRELCH2            UNEQUAL ==> COMPARE LENGHTS INSTD\n         LTR   RB,RB               ZERO LENGTH?\n         BZ    MXRELCH2            IF YES USE LEN COMPARE\nMXRELCH1 EQU   *\n         BCTR  RB,0                DECR LEN FOR EX INST\n         EX    RB,MXCHCOMP         COMPARE STRINGS\nMXRELCH2 BC    $,MXRLATRU                                             A\n         B     MXPNONJP            FALL THRU MEANS FALSE\nMXCHCOMP CLC   0($,RC),0(RE)       DUMMY FOR CHAR COMPARE\nMXRELOPS DC    XL6'70B0D0408020'   MASKS FOR DIFFERENT RELATIONS\n         EJECT\n*                                                                     A\n*        CONCATENATION PROCESSED                                      A\nMXCAT    EQU   *\n         MVI   MCRSLTYP,$BSTRING   SET TYPE TO CHAR\n         BAL   RET,MXCHAR          GET CHAR VALUE OF ARG1\n         STM   RB,RC,MXARG1LN      SAVE LEN & LOC TEMP\n         IC    RA,MCARG2DX         GET ARG2 INDEX\n         SPACE 1                                                      A\n         L     RB,MCARG2LC         GET ARG2 LOC\n         BAL   RET,MXCHAR          GET CHAR VALUE OF ARG2\n         LM    RD,RE,MXARG1LN      GET ARGU VALUE\n         LR    RA,RB               GET LEN OF ARG2\n         AR    RA,RD               GET TOTAL LEN OF ARGS\n         LA    R1,AVMWRK1          GET @ OF WORK AREA\n         S     RD,AWF1             DECR LEN OF ARG1 FOR EX INST\n         BM    MXCAT02             IF ZERO LEN, JUMP\n         EX    RD,MXMVWRK1         MOVE ARGU TO WORKAREA\n         LA    RD,1(RD)            RESTORE ARG1 LEN\n         AR    R1,RD               BUMP WORKAREA POINTER\n         C     RA,AWFXFF           COMPARE TO MAX LENGTH\n         BNH   MXCAT02             IF NOT HIGH, OKAY\n         LR    RB,RA               ELSE MOVE TOTAL TO RB\n         LA    RA,255              GET MAXIMUM ALLOWED LENGTH\n         SR    RB,RA               GET ALLOWABLE REMADR IN RB\nMXCAT02  EQU   *\n         S     RB,AWF1             DECR BY 1 FOR EX INST\n         BM    MXCAT03             IF ZERO LEN ON ARG2, JUMP\n         LR    RE,RC               MOE PNTR TO FOR EX\n         EX    RB,MXMVWRK1         ADD ARG2 TO STRING\nMXCAT03  EQU   *\n         LA    RE,AVMWRK1          GET STRING @ IN RE\n         S     RA,AWF1             DECR FOR EX INST\n         BM    MXCAT04             IF ZERO JUMP\n         L     R1,MXPCHRBF         GET CURRENT @ OF STRING BUFFER\n         AR    R1,RA               GET FINAL @\n         C     R1,AVMCHLIM         EXCEED BUFFER?\n         BH    MXCAT05             IF HIGH, JUMP FOR ERROR\n         SR    R1,RA              RESTORE POINTER\n         EX    RA,MXMVWRK1         MOVE TO BUFFER\n         ST    R1,MCRESULT         SAVE @ IN ONE-OP\nMXCAT04  EQU   *\n         LA    RA,1(,RA)           BUMP TO RESTORE CAT STRING LEN\n         STC   RA,MCRESULT         SAVE LEN IN ONE-OP\n         AR    R1,RA               GET FINAL DELIM @\n         ST R1,MXPCHRBF            STORE @ IN TABLE\n         B     MXPNONJP            GET NEXT ONE-OP\n         SPACE\nMXMVWRK1 MVC   0($,R1),0(RE)       MOVE ARG TO WORK AREA BUFFERER\n         SPACE\nMXCAT05  EQU   *\n         LA    RB,$ER#EXBF         SET EXCEEDED BUFFER FLAG\n         B     MXPNINJE            GO FLAG ERROR AND CONTINUE\n         EJECT\n*                                                                     A\n*        AGO AMD AIF CODE PROCESSED                                   A\n*                                                                     A\nMXAIF    EQU   *\n         BAL   RET,MXBOOL          GET BOOL VALUE\n         LTR   RC,RC               TRUE OR FLSE?\n         BZ    MXPNINJP            NO JUMP, CONTINUE SEQUENTAILLY\n         AIF   (NOT &$MACOPC).MXINSTB  SKIP IF NOT OPEN CODE          S\n         OI    AVMTAG00,AVMOPGO    SHOW AIF WAS SUCCESSFUL            S\n.MXINSTB ANOP                                                         S\n*              FALL THRU, PROCESS LIKE AGO.\n         SPACE\nMXAGO    EQU   *\n         L     R1,MXPNLDBS         GET SET SYMB DICT BASE(LOCAL)\n         L     R0,0(R1)            GET ACTR ALUE\n         BCT   R0,MXAGO01          DECR COUNT\n         LA    RB,$ER#ACTR         SET ACTR ERROR FLAG IF FALL THRU\n         B     MXINKIL1            GENERAL ERROR MSG & SET FLAG       A\nMXAGO01  EQU   *\n         ST    R0,0(R1)            RESTORE DECREMENTED ACTR\n         L     RW,MCARG2LC         GET @ OF BRANCH INTO RW, WHERE EXPCT\n         B     MXPNINJQ            GO TO HAVE BRANCH DONE\n         SPACE\nMXSETA   EQU   *\nMXSETB   EQU   *\nMXSETC   EQU   *\n         BAL   RET,MXADDR          GET @ OF TARGET\n         ST    RC,MXARG1           SAVE TEMP\n         IC    RA,MCARG2DX         GET ARG2 INDEX\n         L     RB,MCARG2LC         GET 2ND RG LOC\n         CLI   MCBOPRTR,$BSETB     ARITH, BOOL OR CHAR?\n         BH    MXSETC01            CHAR IF HIGH\n         BE    MXSETB01            BOOL IF EQUAL\n         BAL   RET,MXARITH         ARITH IF FALL THRU\n         B     MXSETB02            USE BOOL CODE TO STORE\n         SPACE 1\nMXSETB01 EQU   *\n         BAL   RET,MXBOOL          GET BOOL VALUE\nMXSETB02 EQU   *\n         L     R1,MXARG1           GET TARGET @\n         ST    RC,0(R1)            STORE RESULT\n         B     MXPNINJP            GET NEXT INST\n         SPACE 1\nMXSETC01 EQU   *\n         BAL   RET,MXCHAR          GET CHAR VALUE\n         L     R1,MXARG1           GET TARGET @\n*************** POSSIBLE CHANGE WITH ASM H OR VS *********************S\n         C     RB,=F'8'            LEN > 8\n         BNH   MXSETC02            PROCEED IF NOT\n         LA    RB,8                ELSE SET LEN TO MAX\nMXSETC02 EQU   *\n         ST    RB,0(R1)            SAVE LENGTH\n         S     RB,AWF1             DECR FOR EX\n         BM    MXPNINJP            IF ZERO, GET NEXT INST\n         EX    RB,MXPMVSET         MOVE STRING TO SET SYMBOL\n         B     MXPNINJP            GET NEXT INST\n         SPACE\nMXPMVSET MVC   4($,R1),0(RC)       DUMMY TO MOVE STRING\n         EJECT\n*   NEXT SECTION HANDLES SUBSCRIPTED SET SYMBOLS AND SYMBOLIC PRAMS\n         SPACE\nMXSBSCRP EQU   *\n         CLI   MCARG1DX,$BSYMPAR   SYMPAR, K' OR T'?\n         BNL   MXSCRP01            JUMP AND PROCESS IF YES\n         BAL   RET,MXADDR          ELSE GET @ OF SET SYMBOL\n         LA    R1,$BSATT          GET $BSADDRA-2\n         SRL   RE,1                DIVIDE $ARITH, ETC TO GET 2, 4 OR 6\n         AR    R1,RE               GET $BSADDRA, B ORC\n         STC   R1,MCRSLTYP         SAVE TYPE  IN ONE-OP\n         ALR   RE,RE               RESTORE TYPE(4,8,12)\n         STM   RC,RE,MXARG1LN      SAVE @, LEN AND TYPE TEMP\nMXSCRP01 EQU   *\n         IC    RA,MCARG2DX         GET ARG2 INDEX\n         L     RB,MCARG2LC         GET ARG2 LOC\n         BAL   RET,MXARITH         GET ARITH VALUE\n         LTR   RC,RC               TEST VALUE OF INDEX\n         BP    MXSCRP02            PROCEED IF > 0\nMXSCRPDR EQU   *\n         LA    RB,$ER#DMER         ELSE SET DIMENON ERROR FLAG\n         B     MXPNINJE            GO FLAG ERROR AND CONTINUE\nMXSCRP02 EQU   *\n         CLI   MCARG1DX,$BSYMPAR   SYM PAR, K' OR T'?\n         BNL   MXSBSCSP            JUMP IF YES\n         C     RC,MXARG1           COMPARE WITH SET SYMB DIM\n         BH    MXSCRPDR            ERROR IF HIGH\n         BCTR  RC,0                DECR TO GET OFFSET\n         CLI   MCRSLTYP,$BSADDRB   BOOL TYPE?\n         BNE   MXSCRP03            SKIP IF NOT\n         MVI   MXARG2+3,4          ELSE SET LEN TO 4\nMXSCRP03 EQU   *\n         MH    RC,MXARG2+2         MULT TO GET OFFSET\n         A     RC,MXARG1LN         ADD BASE @\n         ST    RC,MCRESULT         PUT RESULT IN ONE-OP\n         B     MXPNONJP            GET NEXT ONE-OP\n         SPACE\nMXSBSCSP EQU   *                   PROCESS SYMBOLIC PARAMETER SUBSCRIPT\n         MVI   MCRSLTYP,$BSTRING   SET TO CHAR FOR OPERNERS\n         MVC   MCRESULT,AWZEROS    INIT REULST TO ZERO\n         LA    R1,$LMPAROP         GET LEN OF SYM PAR DICT ENTRY\n         MH    R1,MCARG1LC+2       MULST BY SYM PAR SUBSCRIPT\n         A     R1,MXPNLSPT         ADD SYM PAR BASE @ OF DICT\n         USING MCPAROPR,R1         SET USING FOR DICT ENTRY\n         SR    RB,RB               CLEAR RB FOROPRND COUNT\n         IC    RB,MCPARONB         GET NBR OF SUBOPRNDS\n         CR    RB,RC               COMPARE WITH SUBSCRIPT\n         BNL   MXSCSP03            PROCEED IF WITHIN RANGE\nMXSCSP00 EQU   *\n         CLI   MCARG1DX,$BSATK     K' ATRIB?\n         BE    MXSCSP01            K' IF EQUAL\n         BH    MXSCSP02            T' IF HIGH\n         C     RC,AWF1             1ST SUBSCRIPT WANTED?\n         BNE   MXPNONJP            FINI IF NOT\n         MVC   MCRESULT+1(3),MCPAROPT+1      ELSE IS SYMPAR, COPY RESUL\n         MVC   MCRESULT(1),MCPAROLN\n         B     MXPNONJP            SYM PAR IF FALL THRU, DEFAULT VALUE\nMXSCSP01 EQU   *                   PROCESS K' OUT OF RANGE\n         MVI   MCRSLTYP,$BSIMMA    SET TYPE TO ARITH\n         C     RC,AWF1             1ST SUBSCRIPT WANTED?\n         BNE   MXPNONJP            FINI IF NOT\n         MVC   MCRESULT+3(1),MCPAROLN  MOVE K' OF MAIN OPRND TO RESULT\n         B     MXPNONJP            AND GET NEXT ONE-OP\nMXSCSP02 EQU   *                   PROCESS  T' OUT OF RANGE\n         C     RC,AWF1             1ST SUBSCRIPT WANTED?\n         BNE   MXSCSP21            USE NULL TYPE IF NOT\n         LA    RA,MCPAROTP         ELSE POINT AT OPRND TYPE\n         B     MXSCSP22\nMXSCSP21 EQU   *\n         LA    RA,=C'O'            POINT AT NULL TYPE\nMXSCSP22 EQU   *\n         ST    RA,MCRESULT         STORE IN ONE-OP\n         MVI   MCRESULT,1          ST LENGTH TO 1\n         B     MXPNONJP            GET NEXT ONE-OP\nMXSCSP03 EQU   *                   PRROCESS SUBSCRIPTS IN RANG\n         L     R2,MCPRSBPT         GET POINTER TO SUBLIST ENTRIES\n         LTR   R2,R2               SUBLIST EXISTS?\n         BZ    MXSCSP00            PROCESS AS OUT OF RANGE IF NOT\n         BCTR  RC,0                DECR INDEX\n         SLL   RC,3                MULT BY 8 TO GET OFFSET\n         AR    R2,RC               POINT TO SUBENTRY\n         USING MCPARSUB,R2         SET USING ON SUB ENTRY\n         CLI   MCARG1DX,$BSATK     K' ATTRIB?\n         BE    MXSCSP04            YES IF EQUAL\n         BH    MXSCSP05            T' IF HIGH\n         MVC   MCRESULT+1(3),MCPARSPT+1      ELSE IS SYMPAR, COPY POINT\n         MVC   MCRESULT(1),MCPARSLN   GET LEN OF STRING\n         B     MXPNONJP            AND GET NEXT ONE-OP\nMXSCSP04 EQU   *                   PROCESS K' IN RANGE\n         MVC   MCRESULT+3(1),MCPARSLN   MOVE K' TO RESULT\n         MVI   MCRSLTYP,$BSIMMA    SET TYPE TO ARITH\n         B     MXPNONJP            GET NEXT ONE-OP\nMXSCSP05 EQU   *                   PROCESS T' IN RANGE\n         LA    RB,MCPARSTP         GET @ OF TYPE\n         ST    RB,MCRESULT         PLACE IN RESULT\n         MVI   MCRESULT,1          SET LEN TO 1\n         B     MXPNONJP            GET NEXT ONE-OP\n         DROP  R1,R2               DROP USING ON MCPAROPR,MCPARSUB\n         SPACE\n         EJECT\n*   NEXT SECTION PROCESSES SUBSTRING ACTION\n         SPACE\nMXSBST   EQU   *\n         MVI   MCRSLTYP,$BSTRING   INIT TYPE TO STRING\n         MVC   MCRESULT,AWZEROS    INIT LEN TO ZERO\n         BAL   RET,MXARITH         GET 1ST ARG VALUE\n         LTR   RC,RC               WAS 1ST EXP <= 0\n         BNP   MXSBSTER            ERROR IF INDEX <=0\n         ST    RC,MXARG1           SAVE VALUE TEMP\n         IC    RA,MCARG2DX         GET ARG2 INDEX\n         L     RB,MCARG2LC         GET ARG2 LOC\n         BAL   RET,MXARITH         GET ARITH VALUE\n         LTR   RC,RC               WAS VALUE <= 0\n         BNP   MXSBSTER            ERROR IF SO\n*        **NOTE** MAY CHANGE THIS FOR G-LEVEL COMPATIBLE CODE\n         C     RC,=F'8'            LEN > 8?\n         BH    MXSBSTER            ERROR IF YES\n         ST    RC,MXARG2           SAVE ARG2 TEMP\n         IC    RA,MCARG1DX+$LMCQUAD  GET TYPE OF OPRND\n         L     RB,MCARG1LC+$LMCQUAD  GET LOC OF OPERAND\n         BAL   RET,MXCHAR          CONVERT TO CHAR\n         C     RB,MXARG1           LEN < STARTING CHAR?\n         BNL   MXSBST01            OKAY IF NO LOW\n         L     RC,MXARG1           ELSE PUT BAD VALUE IN RC\n         B     MXSBSTER            AND JUMP TO FLAG ERROR\nMXSBST01 EQU   *\n         LM    RD,RE,MXARG1        GET START NBR AND LEN\n         AR    RD,RC               GET NEW START @ + 1\n         BCTR  RD,0                DECR @\n         ST    RD,MCRESULT         SAVE START @ OF SUBSTING\n         AR    RC,RB               GET PNTR TO END OF STRING + 1\n         AR    RD,RE               GET PNTR TO SUBSTR END PLUS 1\n         CR    RC,RD               SUBSTRING OKAY?\n         BNL   MXSBST03            JUMP IF OKAY\n         S     RC,MCRESULT         ELSE GET LEN OF RMNDR OF STRING\n         STC   RC,MCRESULT         SAVE LEN OF SUBST\n         B     MXSBSTFT            JUMP TO FOOT\nMXSBST03 EQU   *\n         S     RD,MCRESULT         GET LENGTH OF SUBSTR\n         STC   RD,MCRESULT         SVE LEN OF SUBSTR IN ONE-OP\nMXSBSTFT EQU   *\n         LA    RW,$LMCQUAD(RW)     BUMP PNTR PAST DUMMY ONE-OP\n         B     MXPNONJP            GET NEXT ONE-OP\n         SPACE 1\nMXSBSTER EQU   *\n         LA    RB,$ER#SBST         SET SUBSTR ERROR FLAG\n         B     MXPNINJE            GO FLAG ERROR AND CONTINUE\n         EJECT\n*    NEXT SECTION PROCESSES SYSLIST SUBSCRIPTED VARIABLE\n         SPACE\nMXSYSL   EQU   *\n         MVI   MCRSLTYP,$BSTRING   INIT TO CHAR TYPE\n         MVC   MCRESULT,AWZEROS    INIST RESULT TO ZERO\n         CLI   MCBOPRTR+$LMCQUAD,X'00'    DOUBLE SUBSCRIPT?\n         BNE   MXSYSL01            SINGLE ONE-OP IF NOT\n         BAL   RET,MXARITH         ELSE GET VALUE OF 1ST SUBSCRIPT\n         ST    RC,MXARG1           STORE TEMP\nMXSYSL01 EQU   *\n         IC    RA,MCARG2DX         GET 2ND ARG\n         L     RB,MCARG2LC         GET LOC\n         BAL   RET,MXARITH         CONVERT TO ARITH\n         ST    RC,MXARG2           SAVE TEMP(1ST SUB OF SINGLE)\n         CLI   MCBOPRTR+$LMCQUAD,X'00'   2 OPRNDS\n         BNE   MXSYSL02            JUMP IF NOT\n         L     RC,MXARG1           ELSE RESTORE 1ST ARG VALUE         A\nMXSYSL02 EQU   *\n         LTR   RC,RC               VALUE > 0\n         BNL   MXSYSL03            IF >= 0, OKAY\nMXSYSLR1 EQU   *\n         LA    RB,$ER#SYSL         SET SYSLIST DIM ERROR\n         B     MXPNINJE            GO FLAG ERROR AND CONTINUE\nMXSYSL03 EQU   *\n         C     RC,MXPNBOPS         COMPARE WITH NBR OF POSIT OPRNDS\n         BH    MXSYSLHI            JUMP IF HIGH\n*   PROCESS &SYSLIST(A), N', K', T' WITHIN RANGE\n         LA    RB,$LMPAROP         GET LEN OF SY PAR DICT ENTRY\n         MR    RB,RB               MULT BY SUBSCRIPT TO GET OFFSET\n         A     RC,MXPNLSPT         ADD BASE @ OF SYM PAR DICT\n         USING MCPAROPR,RC         SET USING FOR DICT ENTRY\n         CLI   MCBOPRTR+$LMCQUAD,X'00'   DOUBLE SUBSCRIPT?\n         BE    MXSYLDBL            PROCESS IF YES\n         CLI   MCARG1DX,$BSYSLST   &SYSLIST?\n         BNE   MXSYSL04            IF NOT MUST BE ATTRIB\n         MVC   MCRESULT+1(3),MCPAROPT+1  MOVE OPRND PNTR TO ONE-OP\n         MVC   MCRESULT(1),MCPAROLN   MOVE LENGTH OF OPNRD TO ONE-OP\n         B     MXPNONJP            GET NEXT OPCODE\nMXSYSL04 EQU   *\n         SR    R1,R1\n         CLI   MCARG1DX,$BSATN     WHICH ATTRIB?\n         BH    MXSYSLTP            T' IF HIGH\n         BE    MXSYSLNP            N' IF EQUAL\n         MVC   MCRESULT+3(1),MCPAROLN   K' IF FALL THRU\n         MVI   MCRSLTYP,$BSIMMA    SET TYPE TO ARITH\n         B     MXPNONJP            GET NEXT ONE-OP\nMXSYSLNP EQU   *\n         MVI   MCRSLTYP,$BSIMMA    SET TYPE TO ARITH\n         MVC   MCRESULT+3(1),MCPARONB   GET NBR OF SUB OPRNDS\n         CLI   MCPARONB,X'00'      ZERO SUBOPRNDS?\n         BNE   MXPNONJP            IF > 0, GET NEXT ONE-OP\n         CLI   MCPAROTP,C'O'       NULL OPRND?\n         BE    MXPNONJP            IF YES, GET NEXT ONE-OP\n         MVI   MCRESULT+3,1        ELSE SET NBR TO 1\n         B     MXPNONJP            AND GET NEXT ONE-OP\nMXSYSLTP EQU   *                   PROCESS T' IN RANGE\n         LA    R1,MCPAROTP         GET @ OF TYPE\n         ST    R1,MCRESULT         STORE RESULT IN ONE-OP\n         MVI   MCRESULT,1          SET LEN=1\n         B     MXPNONJP            GET NEXT ONE-OP\nMXSYLDBL EQU   *                   PROCESS DOUBLE SUBSCRIPTE\n         L     R1,MXARG2           GET 2ND VALUE\n         LTR   R1,R1               POSITIVE?\n         BH    MXSYLDB1            OKAY IF YES\n         LR    RC,R1               ELSE MOVE BAD VALUE TO RC\n         LA    RW,$LMCQUAD(RW)     BUMP ONE-OP PNTR PAST DUMMY\n         B     MXSYSLR1            JUMP TO FLAG ERROR\nMXSYLDB1 EQU   *\n         SR    RE,RE\n         IC    RE,MCPARONB         GET SUBOPRND COUNT\n         CR    R1,RE               SUBS > NBR SUBOPRNDS?\n         BNH   MXSYLDB2            PROCEED IFLOW\n         CLI   MCARG1DX+$LMCQUAD,$BSYSLST  $BSYSLIST?\n         BE    MXSYSDFT            JUMP TO FOOT IF YES\n         MVI   MCRSLTYP,$BSIMMA    SET TYPE = ARITH\n         CLI   MCARG1DX+$LMCQUAD,$BSATK   K'&SYSLIST?\n         BE    MXSYSDFT            FINI IF YES\n         MVI   MCRSLTYP,$BSTRING   ELSE SET TYPE TO CHAR\n         LA    R1,=C'O'            ELSE GET @ OF NULL TYPE\n         B     MXSYLDB5            SKIP TO SAVE @, SET LEN=1\nMXSYLDB2 EQU   *                   PROCESS &SYSLIST(A,B) IN RANGE\n         L     RC,MCPRSBPT         GET @ OF SUBOPRNDS\n         USING MCPARSUB,RC         SET USING FOR SUB E TRY\n         BCTR  R1,0                DECR INDEX FOR MULT\n         SLL   R1,3                MULT BY 8 FOR OFFSET\n         AR    RC,R1               MOVE BASE TO RIGHT ENTRY\n         CLI   MCARG1DX+$LMCQUAD,$BSYSLST   &SYSLIST?\n         BNE   MXSYSDB3            IF NOT, PROCESS T' OR K'\n         MVC   MCRESULT,MCPARSPT   ELSE MOVE @ OF SUBOPRND TO ONE-OP\n         MVC   MCRESULT(1),MCPARSLN    MOVE LEN TO ONE-OP\n         B     MXSYSDFT            JUMP TO FOOT\nMXSYSDB3 EQU   *                   PROCESS K'&SYSLIST OR T'&SYSLIST\n         CLI   MCARG1DX+$LMCQUAD,$BSATT     T'&SYSLIST?\n         BE    MXSYLDB4            JUMP IF YES\n         MVC   MCRESULT+3(1),MCPARSLN    ELSE MUST BE K'&SYSLIST\n         MVI   MCRSLTYP,$BSIMMA    SET TYPE TO ARITH\n         B     MXSYSDFT            JUMP TO FOOT\nMXSYLDB4 EQU   *\n         LA    R1,MCPARSTP         GET @ OF TYPE\nMXSYLDB5 ST    R1,MCRESULT         STORE IN ONE-OP\n         MVI   MCRESULT,1          SET LEN TO 1\n*              FALL THRU INTO MXSYSDFT\nMXSYSDFT EQU   *\n         LA    RW,$LMCQUAD(RW)     BUMP PNTR PAST DUMMT ONE-OP\n         B     MXPNONJP            GET NEXT ONE-OP\n         DROP  RC\n         SPACE\n*  PROCESS &SYSLIST(A), T' OR K' WHERE A > NBR OPRNDS\n         SPACE\nMXSYSLHI EQU   *\n         CLI   MCBOPRTR+$LMCQUAD,X'00'     DOUBLE SUBS?\n         BE    MXSYSLHD            PROCESS IF YES\n         CLI   MCARG1DX,$BSYSLST   $&SYSLIST?\n         BE    MXPNONJP            GET NEXT ONE OP IF YES\n         CLI   MCARG1DX,$BSATN      N'?\n         BNH   MXSYSLHK            K' OR N' IF LOW OR EQUAL\n         B     MXSYSLHT            T' IF HIGH\nMXSYSLHD EQU   *                   PROCESS DUBLE SUBSCRIPT\n         CLI   MCARG1DX+$LMCQUAD,$BSYSLST     &SYSLIST?\n         BE    MXSYSDFT            FINI IF YES\n         CLI   MCARG1DX+$LMCQUAD,$BSATN     N'?\n         BH    MXSYSLHT            ELSE IS T'&SYSLIST\n*              FALL THRU ==> K', IF LOW\nMXSYSLHK EQU   *\n         MVI   MCRSLTYP,$BSIMMA     SET TYPE TO ARITH\nMXSYSTSD EQU   *\n         CLI   MCBOPRTR+$LMCQUAD,X'00'    DOUBLE SUBS?\n         BE    MXSYSDFT            FINI IF YES, JUMP TO DOUBLE FOOT\n         B     MXPNONJP            ELSE GET NEXT ONE-OP\nMXSYSLHT EQU   *\n         LA    R1,=C'O'            GET @ OF NULL TYPE\n         ST    R1,MCRESULT         STORE @ IN ONE-OP\n         MVI   MCRESULT,1          SET LEN TO 1\n         B     MXSYSTSD            TEST FOR DOUBLE SUBS\n         EJECT\n* SECTION TO ADD CHARS TO OUTPUT                                      A\n*                                                                     A\nMXPRNT   EQU   *\n         USING RSBLOCK,RY          NOTE USING ON SOURCE\n         L     RY,AVRSBPT          SET BASE ON SOURCE\n         BAL   RET,MXCHAR          CONVERT ARG TO STRING\n         LA    RA,RSBSOURC         SET SCAN POINTER\n         LA    RE,$LMSRCMX(RA)     SET UPPER LIMIT POINTER\n         A     RA,MCARG2LC         ADD OFFSET\n         CLI   RSBLENG,X'00'       1ST MOVE?\n         BE    MXPRNT01\n         SR    R1,R1\n         IC    R1,RSBLENG          GET PREV LEN-1\n         LA    R1,RSB$L+1(R1,RY)   POINT TO AVAILABLE BYTE\n         CR    RA,R1               COMPARE WITH TARGET\n*          FOLLOWING CHECKS SPECIAL CASE OF OPRND MEETING COMMENT     A\n         BH    MXPRNT01            OKAY IF NEXT PTR > OLD END         A\n         BL    MXPRNT00            IF LOW, MUST INCREM BEYOND ANYWAY  A\n         TM    MCBOPRTR,$MPRCOM    IF EQUAL, CHECK FOR SPECIAL COMPR  A\n         BZ    MXPRNT01            NOT COMMENT,CONCAT IF COM,MOVE OVERA\nMXPRNT00 LA    RA,1(,R1)           SKIP BLANK B                       A\nMXPRNT01 EQU   *\n         S     RB,AWF1             DECR RB\n         BM    MXPNONJP            IF NULL, GET NEXT ONE-OP\n         LA    R2,0(RA,RB)         POINT TO FINAL BYTE\n         CR    R2,RE               EXCEED LIMIT?\n         BNH   MXPRNT02            PROCEED IF OKAY\n         LA    RB,$ERMEXST         ELSE SET ERROR FLAG\n         $CALL ERRTAG              FLAG STMT\n         B     MXPNONJP            GET NEXT ONE-OP\nMXPRNT02 EQU   *\n         EX    RB,MXPMVSRC         MOVE STRING TO SOURCE BLOCK\n         LA    RA,RSBSOURC         GET START @\n         SR    R2,RA               GET LEN-1 IN R2\n         STC   R2,RSBLENG          STORE LEN-1\n         B     MXPNONJP            GET NEXT ONE-OP\nMXPMVSRC MVC   0($,RA),0(RC)       DUMMY TO MOVE STRING\n         DROP  RY\n         EJECT\n         SPACE 2\n*        INNER MACRO CALL                                             A\n*                                                                     A\nMXINMAC  EQU   *\n         USING RSBLOCK,RY          NOTE USING\n         L     RY,AVRSBPT          SET BASE\n         SR    R1,R1               USE R1 FOR LENGTH\n         IC    R1,RSBLENG          GET LENGTH IN R1\n         LA    R1,RSB$L+1(RY,R1)   POINT TO NEXT AVAILABLE BYTE\n         MVC   0(4,R1),=C'  '' '   MOVE END OF RECORD INDICATROR\n         LA    R1,1(R1)            BUMP R1\n         ST    R1,AVSOLAST         SAVE END OF RECORD @\n         MVI   RSBNUM,1            SET NBR CARDS TO 1\n         LA    RB,RSBLOCK+RSB$L+RSOL1  POINT TO 1ST BYTE, 2ND CARD\n         CR    R1,RB               COMPARE WITH AVSOLAST\n         BL    MXINMAC1            AVSOLAST LOW, ONE CARD\n         MVI   RSBNUM,2            SET COUNT TO 2 CARDS\n         LA    RB,RSOLC(RB)        BUMP RB TO 1ST BYTE, 3RD CARD\n         CR    R1,RB               COMPARE WITH AVSOLAST\n         BL    MXINMAC1            IF LOW, 2 CARDS\n         MVI   RSBNUM,3            ELSE IS 3 CARDS\nMXINMAC1 EQU   *\n         OI    RSBFLAG,$RSBGENR+$RSBNPNN  SET GEN & NO ACTION FLAGS\n         TM    RSBFLAG,$REBX       ERROR BLOCK EXISTS?\n         BNO   MXINCALL                                               A\n         SPACE 4\nMXMVSTMT EQU   *\n         USING RSBLOCK,RY\n         L     RY,AVRSBPT          SET BASE\n         OI    RSBFLAG,$RSBGENR    SET GEN FLAG\n         TM    MCBOPRTR,$BSMNTER   MNOTE ERROR?\n         BNO   MXMVSTMU            SKIP IF NOT\n         OI    RSBFLAG,$RSBMERR    SET ERROR FLAG\nMXMVSTMU EQU   *\n         $CALL MXMVSR              MOVE SOURCE TO HIGH\n         LTR   RB,RB               OVERFLOW?\n         BNZ   MXEXECOV            FLAG IF YES\n         B     MXPNINJP            GET NEXT INST\nMXERRMS  EQU   *\n         LA    RB,$ER#PRVR         SHOW PREVIOUS ERROR                S\n         DROP  RY                                                     S\n         BAL   R1,MXINERRM         CALL ERROR FLAG ROUTINE            S\n         B     MXPNINJP            ELSE GET NEXT INST\n         SPACE\nMXANOP   EQU   MXPNINJP            NO CODE NEEDED, GO FOR NEXT\nMXFIN    EQU   MXPNINJP            NO CODE NEEDED, GO FOR NEXT\n         EJECT                                                        S\n*              *** ERROR EXITS: TERMINATE PROCESSING *****\nMXINV    EQU   *\n         LA    RB,$ER#SYER         SET SYSTEM ERR FLAG\n         B     MXMENDEC            STOP PROCESSING AND RETURN\nMXMENDER LA    RB,$ER#MXST         SET EXCEED STMTS FLAG\nMXMENDEC EQU   *                   CALL MXERRM AND QUIT-TYPE EXIT LABEL\n         BAL   R1,MXINERRM         GENERATE ERROR MESSAGE             A\nMXENDEF  LA    RB,12               RB SET TO KILL MACROS              A\n         B     MXINRTN             RETURN                             A\n*              FALL THRU, HANDLE AS MEND OR MEXIT.\n         SPACE\nMXMEND   EQU   *\nMXMEXIT  EQU   *\n         SR    RB,RB               RB SET FOR MEND OR MEXIT           S\nMXINRTN  EQU   *                                                      A\n         L     R1,AVMXSPIE         RELOAD R1 FROM SPIE PTR            A\n         LM    RC,RD,AVGEN1CD                                         A\n         XSNAP LABEL='AT MXINST RET',STORAGE=(*0(RD),*0(RC),*AVADDLOW,*X\n               AVWXEND),IF=(AVTAGSM,O,AJOMACRH,TM)\n         $SPIE ,,,ACTION=(RS,(1))                                     A\n         $RETURN RGS=(R14-R6)                                         A\n         SPACE\nMXARG1LN DS    F                   TEMP STORAGE FOR ARG1 LENGTH\nMXARG1   DS    F                   TEMP STORAGE FOR ARG1\nMXARG2   DS    F                   TEMP STORAGE FOR ARG2\n*                                                                     S\n*        SET RB TO RETURN CONDITION                                   S\n*                                                                     S\nMXINKIL1 EQU   *                                                      S\n         BAL   R1,MXINERRM         CALL ERR MSG ROUTINE               S\n         LA    RB,8                SET KILL MACRO NEST FLAG           S\n         B     MXINRTN             NORMAL RETURN                      S\nMXINCALL EQU   *                                                      A\n         LA    RB,4                SET RETURN CODE                    A\n         B     MXINRTN             RETURN                             A\n         LTORG                                                        S\n         DS    0H                  FORCE ALIGNMENT                    S\n         EJECT                                                        A\n**--> INSUB: MXINERRM       CALLS MXERRM TO HANDLE ERROR MESSAGES  + +S\n*+                                                                   +S\n*+             ENTRY CONDITIONS:                                     +S\n*+       RB = ERROR CODE                                             +S\n*+       RC = VALUE IF ANY                                           +S\n*+       RD = LENGTH                                                 +S\n*+       R1 = LINK REG                                               +S\n*+                                                                   +S\n*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +S\n         SPACE 2                                                      S\nMXINERRM EQU   *                                                      S\n         LR    RE,RZ               COPY @ OF MXPNTSAV                 A\n         $CALL MXERRM              CALL ERROR ROUTINE                 S\n         LTR   RB,RB               TEST RB FOR OVERFLOW               S\n         BCR   Z,R1                RETURN ON NOT OVERFLOW             S\n*        SET RB TO OVERFLOW VALUE AND RETURN                          S\nMXEXECOV EQU   *                                                      S\n         LA    RB,16               SET OVERFLOW FLAG                  S\n         B     MXINRTN             NORMAL RETURN                      S\n         SPACE 5                                                      S\n**--> INSUB: MXARITH MXARITH PRODUCES ARITH ONE-OP                    A\n*+                                 MXBOOL PRODUCES BOOLEAN ONE-OP     A\n*+                                 MXCHAR PRODUCES CHAR ONE-OP        A\n*         TYPE.                                                       *\n*                                                                     *\n*         ENTRY CONDITIONS                                            *\n*      RA = TYPE OF OPRND                                             *\n*      RB = @ OF OPRND (OR VALUE IF IMMEDIATE TYPE)                   *\n*                                                                     *\n*         EXIT CONDITIONS                                             *\n*+       RA=BYTE REG                                                  A\n*+       R1=WIPED OUT                                                 A\n*+       RE=WIPED OUT                                                 A\n*      RB = LENGTH OF CHAR STRING IF CHAR VALUE                       *\n*      RC = VALUE IF ARITH OR BOOL, @ OF STRING IF CHAR               *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE\nMXARITH  DS    0F\n         OI    AVMBYTE2,$MINARIT   SET ARITH FLAG\n         B     MXSCCV\nMXBOOL   EQU   *\n         OI    AVMBYTE2,$MINBOOL   SET BOOL REQ'D FLAG\n         B     MXSCCV\nMXCHAR   EQU   *\n         OI    AVMBYTE2,$MINCHAR   SET CHAR REQ'D FLAG\nMXCONVBS DS    0H                  BASE FOR JUMP TABLE\nMXSCCV   EQU   *\n         ST    RET,MXSCCVSV        SAVE RETURN @\n         SPACE\nMXCONJMP EQU   *\n         N     RA,AWFXFF           MASK OUT ALL EXCEPT INDEX\n         LH    R1,MXCONNDX(RA)     GET OFFSET OF ROUTINE\n         XSNAP LABEL='***MXARITH ENTERED***',                          X\n               IF=(AVMSNBY2,O,$MSNP12,TM)\n         B     MXCONVBS(R1)        JUMP TO ROUTINE\n         SPACE\nMXCONNDX $AL2  MXCONVBS,(MXCNGLA,MXCNGLB,MXCNGLC,MXCNLCA,MXCNLCB,MXCNLC#\n               C,MXCNSYPR,MXCNIMMA,MXCNIMMB,MXCNIMMC,MXCNSYSX,MXCNUND,M#\n               XCNCSCT,MXCNUND,MXCNTEMP,MXCNUND,MXCNUND,MXCNATTK,      #\n               MXCNUND,MXCNATTN,MXCNUND,MXCNATTT,MXCNADDA,MXCNADDB,    #\n               MXCNADDC),-2\n         SPACE\n*        PROCESS GLOBALS                                              A\n*                                                                     A\n         USING MCGLBDCT,RB         NOTE USING FOR GLOBAL SET SYMB DV\nMXCNGLA  EQU   *\n         L     RC,MCGBAVAL         GET ARITH VALUE\n         B     MXCONV0A\n         SPACE\nMXCNGLB  EQU   *\n         L     RC,MCGBAVAL         GET BOOL VALUE\n         B     MXCONV0B\nMXCNGLC  EQU   *\n         LA    RC,MCGBCVAL         GET @ OF CHAR VALUE\n         L     RB,MCGBCLEN         GET LENGTH OFSTRING\n         B     MXCONV0C\n         EJECT\nMXCNLCA  EQU   *\nMXCNLCB  EQU   *\nMXCNLCC  EQU   *\n         L     RC,MGLCLPNT         GET OFFSET\n         A     RC,MXPNLDBS         ADD BASE @ OF LOCAL SET SYM DICT\n         CLI   MCGLBTYP,$BOOL      WHAT TYPE                          A\n         BH    MXCNLCA1            CHAR IF HIGH\n         L     RC,0(RC)            ELSE GET ARITH OR BOOL VALUE\n         BL    MXCONV0A            ARITH IF LOW\n         B     MXCONV0B            ELSE IS BOOL\nMXCNLCA1 EQU   *\n         L     RB,0(RC)            GET LEN OF CHAR\n         LA    RC,4(RC)            BUMP POINTER TO STRING\n         B     MXCONV0C\n         DROP  RB                  DROP USING ON SET SYMB DV\n         SPACE\nMXCNSYPR EQU   *\n         USING MCPAROPR,RE         NOTE USING ON SYM PAR DICT ENTRY\n         LA    RE,$LMPAROP         GET LEN OF ENTRY\n         MR    RD,RB               CALCULATE OFFSET\n         A     RE,MXPNLSPT         ADD SYM PAR DICT BASE\n         L     RC,MCPAROPT         GET POINTER TO STRING\n         IC    RB,MCPAROLN         GET LEN OF STRING\n         TM    AVMBYTE2,$MINCHAR+$MINBOOL                             A\n         BNZ   MXCONV0C                                               S\n         CLI   MCPAROTP,C'N'       FALL THRU MEANS ARITH REQ'D\n         BE    MXCNSYP1            IF SELF DEF TERM, OK\nMXCNSYER EQU   *\n         LR    RD,RB               ELSE MOVE LEN TO RD\n         LA    RB,$ER#CVCA         SET CONVERSION ERROR\n         B     MXPNINJE            GO FLAG ERROR AND CONTINUE\nMXCNSYP1 EQU   *\n         LR    RA,RC               MOVE POINTER TO RA\n         $CALL SDBCDX              CHECK FOR SELF DEF TERM\n         LTR   RB,RB               OKAY?\n         BZ    MXCONRTN            RETURN IF YES\n         SR    RB,RB               ELSE CLEAR RB\n         IC    RB,MCPAROLN         INSERT STRING LENGTH\n         L     RC,MCPAROPT         POINT TO STRING\n         B     MXCNSYER            AND FLAG ERROR\n         SPACE\nMXCNIMMA EQU   *\n         LR    RC,RB               MOVE VALUE TO RC\n         B     MXCONV0A            CONVERT IF NECESSARY\nMXCNIMMB EQU   *\n         LR    RC,RB               MOVE IMM VALUE TO RC\n         B     MXCONV0B            CONVERT IF NECESSARY\nMXCNIMMC EQU   *\n         SRDL  RB,24               MOVE @ TO RC, LEAVE LEN IN RB\n         SRL   RC,8                FINISH SHIFT IN RC\n         B     MXCONV0C            CONVERT IF NECESSARY\n*                                                                     A\n*  PROCESS SYSNDX                                                     A\nMXCNSYSX EQU   *                   GET SYSYNX VALUE\n         TM    AVMBYTE2,$MINCHAR   CHAR REQ'D?\n         BO    MXCNSX01            PROCESS CHAR IF YES\n         ZAP   AVDWORK1,MXPSYSDX   MOVE SYSNDX TO DOUBLE WORD\n         CVB   RC,AVDWORK1         CONVERT TO BINARY\n         TM    AVMBYTE2,$MINBOOL   BOOL REQ'D?\n         BNO   MXCONRTN            RETURN IF NOT\nMXCNSX03 EQU   *\n         LA    RB,$ER#CVAB         SET ARITH - BOOL ERROR\n         B     MXCONVAR                                               A\n         EJECT\n*                                                                     A\n*  CONVERT SYSNDX TO CHAR                                             A\n*                                                                     A\nMXCNSX01 EQU   *\n         L     RE,MXPCHRBF         GET POINTER TO WORK AREA\n         LA    RE,4(RE)            BUMP TO TEST END\n         C     RE,AVMCHLIM         TEST AGAINST LIMIT\n         BNH   MXCNSX02            PROCEED IF OKAY\n         LA    RB,$ER#EXBF         SET ERROR FLAG\n         B     MXPNINJE            GO FLAG ERROR AND CONTINUE\nMXCNSX02 EQU   *\n         LA    RB,4                PUT USEFUL VALUE IN RB\n         SR    RE,RB               RESTORE THE POINTER\n         UNPK  0(4,RE),MXPSYSDX    UNPACK &SYSNDX\n         OI    3(RE),X'F0'         CHANGE LAST ZONE TO F\n         LR    RC,RE               POINT RC AT STRING\n         AR    RE,RB               BUMP RE TO END OF BUFFER\n         ST    RE,MXPCHRBF         RESOTRE BUFFER POINTER\n         B     MXCONRTN            AND RETURN\n         SPACE\nMXCNCSCT EQU   *\n         LA    RC,AVSYSECT         GET @ OF CSECT NAME\n         TRT   0(9,RC),AWTSYMT     SCAN NAME FOR LENGTH\n         SR    R1,RC               GET LENGTH\n         LR    RB,R1               MOVE LENGTH TO RB\n         TM    AVMBYTE2,$MINCHAR   CHAR REQ'D?\n         BO    MXCONRTN            RETURN IF YES\n         B     MXCONCAR                                               A\n         SPACE\nMXCNTEMP EQU   *\n         USING MCOPQUAD,RB         SET USING ON ONE-OP\n         IC    RA,MCRSLTYP         GET INDEX\n         L     RB,MCRESULT         GET LOCATION\n         B     MXCONJMP            EVALUATE\n         DROP  RB\n         EJECT\nMXCNATTK EQU   *\nMXCNATTN EQU   *\n         LTR   RB,RB               &SYSLIST?\n         BNL   MXCNAT01            NO IF NOT LOW\n         L     RC,MXPNBOPS         ELSE GET NBR OF OPRNDS\n         B     MXCONV0A            AND CONVERT IF NECESSARY\nMXCNATTT EQU   *\nMXCNAT01 EQU   *\n         TM    AVMBYTE2,$MINBOOL   BOOLEAN VALUE REQUIRED             J\n         BZ    MXCNAT02            IF NOT OKAY\n         LA    RB,$ER#ATER         ELSE SET ATTRIB USE ERR\n         B     MXPNINJE            GO FLAG ERROR AND CONTINUE\nMXCNAT02 EQU   *\n         USING MCPAROPR,RE         SET USING ON SYM PAR DICT ENTRY\n         SR    RC,RC\n         LA    RE,$LMPAROP         GET LENGTH OF ENTRY\n         MR    RD,RB               GET OFFSET\n         A     RE,MXPNLSPT         ADD SYM PAR DICT BASE\n         LA    R1,$BSATN           GET N' INDEX\n         CR    RA,R1               COMPARE WITH OPRND INDEX\n         BH    MXCNATTP            T' IF HIGH\n         BE    MXCNATNP            N' IF EQUAL\n         IC    RC,MCPAROLN         K' IF FALL THRU\n         B     MXCONV0A            RETRN\nMXCNATNP EQU   *\n         IC    RC,MCPARONB         GET N'\n         B     MXCONV0A            JUMP TO CONVERT\nMXCNATTP EQU   *\n         LA    RB,1                GET LENGTH OF TYPE\n         LA    RC,MCPAROTP         GET POINTER TO TYPE\n         B     MXCONV0C            CONVERT IF NECESSARY\n         DROP  RE\n         SPACE\nMXCNADDA EQU   *\n         L     RC,0(RB)            GET ARITH VALUE\n         B     MXCONV0A            CONVERT IF NECESSARY\nMXCNADDB EQU   *\n         L     RC,0(RB)            GET VALUE\n         B     MXCONV0B            CONVERT IF NECESSARY\nMXCNADDC EQU   *\n         LA    RC,4(RB)            GET @ OF STRING\n         L      RB,0(RB)           GET LENGTH OF STRING\n         B     MXCONV0C            CONVERT IF NECESSARY\n         SPACE\nMXCNUND  EQU   *\n         LA    RB,$ER#SYER         SET SYSTEM ERROR FALG\n         B     MXPNINJE            GO FLAG ERROR AND CONTINUE\n         EJECT\n*                                                                     A\n*        CONVERT TO ARITH                                             A\n*                                                                     A\nMXCONV0A EQU   *\n         TM    AVMBYTE2,$MINARIT   ARITH REQ'D?\n         BO    MXCONRTN            RETURN IF YES\n         B     MXCONVAR            ELSE CONVERT\n*                                                                     A\n*        CONVERT TO BOOLEAN                                           A\n*                                                                     A\nMXCONV0B EQU   *\n         TM    AVMBYTE2,$MINBOOL+$MINARIT   ARITH OR BOOL REQ'D?\n         BM    MXCONRTN            RETURN IF YES\n         B     MXCONVBL            ELSE CONVERT\n*                                                                     A\n*        CONVERT TO CHAR                                              A\n*                                                                     A\nMXCONV0C EQU   *\n         TM    AVMBYTE2,$MINCHAR   CHAR REQ'D?\n         BO    MXCONRTN            RETURN IF YES\n         B     MXCONVCH            ELSE CONVERT\nMXCONVAR EQU   *\n         TM    AVMBYTE2,$MINCHAR   CHAR REQ'D?\n         BO    MXCONVAC            CONVERT IF YES\n         C     RC,AWF1             BOOL VALUE?\n         BE    MXCONRTN            RETURN IF YES\n         LTR   RC,RC               ZERO VALUE?\n         BE    MXCONRTN            OKAY IF YES\nMXCONVAB LA RB,$ER#CVAB            ELSE SET ERROR FLAG                A\n         B     MXPNINJE            GO FLAG ERROR AND CONTINUE\nMXCONVAC EQU   *\n         LPR   RC,RC               GET POS VALUE\n         CVD   RC,AVDWORK1         CONVERT TO PACKED DEC\n         LA    RB,12               GET MAX LENGTH OF DEC NUMBER+1\n         $MALLOCL  RE,RB,OVRFL=MXEXECOV   GET STORAGE FOR NBR\n         MVC   0(12,RE),MXCEP12    MOVE EDIT MASK FOR MAX NBR\n         LA    R1,11(RE)           POINT TO LAST CHAR\n         LA    RB,1(R1)            GET @ OF DELIM IN RB\n         EDMK  0(12,RE),AVDWORK1+2 EDIT DEC FIELD\n         LR    RC,R1               MOVE POINTER TO RC\n         SR    RB,R1               PUT LENGTHIN RB\n         B     MXCONRTN            AND RETURN\n         EJECT\nMXCONVBL EQU   *\n*                                                                     A\n* CONVERT BOOLEAN --> CHAR                                            A\n*                                                                     A\n         LA    RB,1                SET LEN TO 1\n         LA    RC,MXCONBLT(RC)     GET @ OF '0' OR '1' AS APPROPRIATE\n         B     MXCONRTN            AND RETURN\nMXCONBLT DC    C'01'               CONVERT BOOLEAN TO CHARACTER\n         SPACE\nMXCONVCH EQU   *\n         TM    AVMBYTE2,$MINBOOL   BOOL REQ'D?\n         BO    MXCONVCB            CONVERT IF YES\n*                                                                     A\n* CONVERT CHAR --> ARITH                                              A\n*                                                                     A\nMXCONVCA EQU   *                   CONVERT TO ARITH\n         SR    R2,R2\n         SR    R1,R1\n         LTR   RB,RB               TEST LENGTH OF CHAR\n         BNZ   MXCONCA1            PROCEED IF NONZERO\nMXCONCAR EQU   *                   PROCESS ZERO STRING\n         LR    RD,RB               MOVE LENGTH TO RD\n         LA    RB,$ER#CVCA         SET CONVERSION ERROR FLAG\n         B     MXPNINJE            GO FLAG ERROR AND CONTINUE\nMXCONCA1 EQU   *                   CONVERT TO ARITH\n         TRT   0(1,RC),AWTDECT     POSSIBLE SELF DEF TERM?\n         BNZ   MXCONCA4            CKECK FOR C,B OR X IF NOT\n         C     RB,AWF10            TEST LENGTH\n         BH    MXCONCAR            ERROR IF > 10\n         BL    MXCONCA2            IF < 10, OKAY\n         CLC   0(10,RC),=C'2147483647'  ELSE COMPARE AGAINST LIMIT\n         BH    MXCONCAR            ERROR IF HIGH\nMXCONCA2 EQU   *\n         BCTR  RB,0                DECR LEN FOR TRT\n         EX    RB,MXPSCDEC         SCAN FOR DEC NBRS\n         BZ    MXCONCA3            OKAY IF ALL DEC\n         LA    RB,1(RB)            ELSE RESTORE RB\n         B     MXCONCAR            AND FLAG ERROR\nMXCONCA3 EQU   *\n         EX    RB,MXPMVDEC         MOVE DEC STRING TO WORK AREA PACKED\n         CVB   RC,AVDWORK1         CONVERT TO BIN\n         B     MXCONRTN            AND RETURN\nMXCONCA4 EQU   *\n         C     R2,AWF4             B, C OR X?\n         BNE   MXCONCAR            ERROR IF NOT\n         LR    R1,RB               SAVE LENGTH\n         LR    RA,RC               MOVE POINTER TO RA\n         $CALL SDBCDX              CHECK FOR SELF DEF AND CONVERT\n         LTR   RB,RB               OKAY?\n         BZ    MXCONRTN            RETURN IF OKAY\n         LR    RB,R1               RESTORE LENGTH TO RB\n         LR    RC,RA               PUT POINTER IN RC\n         B     MXCONCAR            AND FLAG ERROR\n         SPACE\nMXPMVDEC PACK  AVDWORK1,0($,RC)    DUMMY TO PACK STRING\nMXPSCDEC TRT   0($,RC),AWTDECT     DUMMY TO SCAN FOR DEC CHARS\n         SPACE 10                                                     S\nMXCONVCB EQU   *                   CONVERT CHAR TO BOOL\n         C     RB,AWF1             LEN = 1?\n         BE    MXCONCB1            OKAY IF 1\nMXCONCBR EQU   *                   ELSE IS ERROR\n         LR    RD,RB               MOVE LEN TO RD\n         LA    RB,$ER#CVCB         SET CHAR->BOOL ERROR\n         B     MXPNINJE            GO FLAG ERROR AND CONTINUE\nMXCONCB1 EQU   *\n         CLI   0(RC),C'1'          CHAR = 1?\n         BNE   MXCONCB2            PROCEED IF NOT 1\n         LA    RC,1                SET BOOL VALUE\n         B     MXCONRTN            AND RETURN\nMXCONCB2 EQU   *\n         CLI   0(RC),C'0'          DID CHAR = '0' (ZERO)              J\n         BNE   MXCONCBR            ERROR IF NOT\n         SR    RC,RC               SET FALSE BOOL FALUE\n*                                                                     A\nMXCONRTN EQU   *\n         XSNAP LABEL='***MXARITH EXITED***',                           X\n               IF=(AVMSNBY2,O,$MSNP12,TM)\n         SR    RA,RA               ZERO RA FOR BYTE USE               A\n         L     RET,MXSCCVSV        RESTORE RETURN @\n         BR    RET                 AND RETURN\nMXSCCVSV DS    F                   SPACE FOR RETURN ADDRESS\nMXCEP12  DC    X'402020202020202020202120'    12 BYTE DEC MASK\n         LTORG\n         TITLE ' MXINST-INTERNAL ROUTINES'                            A\n**--> INSUB: MXADDR       THIS ROUTINE ACCEPTS A ONE-OP  + + + + + + +S\n*+       OPRND AND RETURNS THE @ OF THE SYMBOL.  OPRND MUST BE       +S\n*+       A SET SYMBOL OR TEMP VALUE POINTING TO AN ADDRESS.          +S\n*+                                                                   +S\n*+             ENTRY CONDITIONS:                                      S\n*+       RA = INDEX OF OPRND                                         +S\n*+       RB = @ OF OPRND                                             +S\n*+                                                                   +S\n*+             EXIT CONDITIONS:                                      +S\n*+       RC = @ OF VALUE                                             +S\n*+       RD = DIMENSION OF SET SYMBOL                                +S\n*+       RE = TYPE OF SYMBOL (IE -  $ARIT, $BOOL OR $CHAR)           +S\n*+                                                                   +S\n*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +S\n         SPACE\nMXADDR   DS    0F                  ENTRY PT FOR INTERNAL SUB\n         XSNAP LABEL='***MXADDR ENTERED***',                           X\n               IF=(AVMSNBY2,O,$MSNP12,TM)\n         USING MCGLBDCT,RB         NOT USING ON SET SYMB DV\n         SR    RE,RE\n         SR    RD,RD\n         LA    R1,$BSYMPAR         GET SYM PAR BSU VALUE\n         CR    RA,R1               COMPRE WITH OPNRD\n         BNL   MXADDR01            NOT SET SYM IF NOT LOW\n         SRL   R1,1                DIVIDE SYM PAR BSU BY 2\n         CR    RA,R1               COMPARE WITH OPRND\n         BNL   MXADDRLC            SET SYM LOCAL IF NOT LOW\n         LA    RC,MCGBAVAL         GET @ OF VALUE\n         LH    RD,MCGLBDIM         GET DIMENSION\n         IC    RE,MCGLBTYP         GET TYPE IN RE\n         B     MXADDRET            JUMP TO FOOT\nMXADDRLC EQU   *                   TREAT LOCAL SET SYMBOLS\n         LH    RD,MCGLBDIM         GET DIMENSION\n         IC    RE,MCGLBTYP         GET TYPE\n         L     RC,MGLCLPNT         GET OFFSET\n         A     RC,MXPNLDBS         ADD BASE @ OF SET SYM DICT\n         B     MXADDRET            JUMP TO FOOT\nMXADDR01 EQU   *\n         USING MCOPQUAD,RB         NOTE USING ON ONE-OP\n         LA    R1,$BSTEMP          GET TEMP BSU\n         CR    R1,RA               MUST BE $BSTEMP\n         BNE   MXADDRR1            ERROR IF NOT\n         L     RC,MCRESULT         GET @ OF DESIRED VALUE\n         CLI   MCRSLTYP,$BSADDRA   COMPARE WITH ARITH @\n         BL    MXADDRR1            ERROR IF LOW\n         BE    MXADDR02\n         CLI   MCRSLTYP,$BSADDRC   CHECKFOR CHAR @\n         BH    MXADDRR1            ERROR IF HIGH\n         BE    MXADDR03            ARITH IF EQUAL\n         LA    RE,$BOOL            FALL THRU MEANS BOOLEAN\n         B     MXADDRET            JUMP TO FOOT\nMXADDR02 EQU   *\n         LA    RE,$ARITH           SET ARITH TYPE\n         B     MXADDRET            JUMP TO FOOT\nMXADDR03 EQU   *\n         LA    RE,$CHAR            SET CHAR TYPE\n         B     MXADDRET            JUMP TO FOOT\nMXADDRR1 EQU   *\n         LA    RB,$ER#SYER         SET SYSTEM ERROR\n         B     MXPNINJE            GO FLAG ERROR AND CONTINUE\nMXADDRET EQU   *\n         XSNAP LABEL='*** MXADDR EXITED ***',                          #\n               IF=(AVMSNBY2,O,$MSNP12,TM)\n         BR    RET                 AND RETURN\n         LTORG\n         DROP  RB,RZ,RAT                                              S\n         TITLE '***MXERRM  GENERATES ERROR MSSGS IN MEXPND***'\n**-->  CSECT:  MXERRM  CALLED DURING MACRO GENERATION TO GENERATE     *\n*.        ERROR MESSAGES NOT HANDLED BY ERRTAG                        *\n*.                                                                    *\n*.        ENTRY CONDITIONS                                            *\n*.       RA-SCAN PTR                                                  A\n*.     RB = ERROR TYPE                                                *\n*.     RC = OPERAND VALUE OR LOCATION                                 *\n*.     RD = LENGTH OF STRING IF CHAR VALUE                            *\n*.       RE-@ MXPNTSACV                                               A\n*.                                                                    *\n*.       EXIT CONDITIONS                                              A\n*.       RB=0 ==> OK                                                  A\n*.       RB=4 ==> STORAGE OVERFLOW CAUSED MESSAGE SELECTED IS PLACED  A\n*.       IN RSBLOCK, THEN MOVED OUT TO HIGH AREA BY MXMVSR            A\n*.                                                                    A\n*.        USES MACROS: $CALL, $AL2, $SAVE, $RETURN                    *\n*.        CALLS MXMVSR                                                *\n*.        USES DSECTS: RSBLOCK, MXPNTSAV, MCOPQUAD, AVWXTABL          *\n*.                                                                    *\n*.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE\nMXERRM   CSECT\n         $SAVE RGS=(R14-R6),BR=R13,SA=*\n         USING AVWXTABL,RAT        NOTE MAIN TABLE USING\n         XSNAP LABEL='***MXERRM ENTERED***',T=NO,                      X\n               IF=(AVMSNBY2,O,$MSNP13,TM)\n         USING RSBLOCK,RW          NOTE USING FOR SOURCE BLOCK\n         L     RW,AVRSBPT          SET BASE FOR SOURCE\n         USING MXPNTSAV,RE         MACRO BLOCK                        A\n         L     RY,MXPNCRCD         CURRENT INSTRUCTION                A\n         USING MCOPQUAD,RY         NOTE USING                         S\n         MVC   RSBLOCK(RSB$L),=AL1(0,$RSBNPNN+$RSBMERR,1,0)           S\n         LA    R1,MXMSSGS          ADDRESS OF MESSAGES                A\n         AH    R1,MXERRPTR(RB)     @ SPECIFIC MSG                     A\n         USING MSGBLOCK,R1                                            A\n         SR    R2,R2               CLEAR R2                           A\n         IC    R2,MSGLENM1         GET LENGTH-1 OF MSG & NUMBER       A\n         EX    R2,MXERRMVC         MOVE IT IN                         A\n*  1ST PART (MSG) NOW DONE                                            A\n*  NOW FILL IN STM NUMBER, OTHER DATA                                 A\n*  R2 WILL BE ACCUMUALTION OF L-1                                     A\n         LA    RA,RSBSOURC+1(R2)   @ NEXT BYTE                        A\n         MVC   0(MXERRS$L,RA),MXERRSTN  STMT NUMBER EDIT PATTERN      A\n         ED    L'MXERRSTN(6,RA),MCQSTMNO                              A\n         L     RY,MXPNMCLB         GET MACRO PTR                      A\n         USING MACLIB,RY                                              A\n         MVC   MXERRS$L(L'MCLBNAM,RA),MCLBNAM                         A\n         LA    RB,MXMSSGS(RB)      ADD @ BEGINNING OF TABLE\n         LA    R2,MXERRS$L+L'MCLBNAM(R2)  BUMP L-1                    A\n         DROP  RE,RY                                                  A\n         LA    RA,RSBSOURC+1(R2)   BUMP PTR FOR MSG OUTPUT            A\n*        MSGFLAG = 0               MSG #                              S\n*                  4               NUMERICAL                          S\n*                  8               CHAR VALUE                         S\n*                                                                     S\n         CLI   MSGFLAG,X'04'       COMPARE VALUE                      S\n         BL    MXERFOOT            IF LOW, DONE.\n         MVC   0(3,RA),=C'-->'     MOVE POINTER TO RSBSOURC\n         LA    RA,3(RA)            BUMP SCAN POINTER\n         LA    R2,3(R2)            BUMP LEN-1\n         BH    MXERRM0C            CHAR STRING IF HIGH\n         SPACE\nMXERRM0A EQU   *                   FALL THRU FOR ARITH TYPR\n         LA    R1,AVMWRK1+11       POINT TO END OF EDIT MASK\n         LA    RE,1(R1)            POINT RE TO DELIMMPAST MASK\n         CVD   RC,AVDWORK1         CONVERT VALUE TO PACKED DEC\n         MVC   AVMWRK1(12),MXEEP12  MOVE EDIT MASK TO WORK AREA\n         EDMK  AVMWRK1(12),AVDWORK1+2  EDIT AND MARK VALUE\n         SR    RE,R1               GET LENGTH OF STRING\n         BCTR  R1,0                DECR POINTER TO SIGN POSIT\n         EX    RE,MXMVSTRN         MOVE CHAR VALUE TO OUTPUT\n         LTR   RC,RC               NEG VALUE?\n         BNL   MXERRMA1            SKIP IF NOT\n         MVI   1(RA),C'-'          ELSE INSERT MINUS SIGN\nMXERRMA1 EQU   *\n         LA    R2,2(RE,R2)        BUMP LENGTH\n         B     MXERFOOT            JUMP TO FOOT\nMXERRM0C EQU   *\n         LR    R1,RC               MOVE @ OF STRING TO R1\n         LA    RE,RSOL1-2                                             A\n         SR    RE,R2               SUBTRACT CURRENT L-1               A\n         CR    RD,RE               VALUE LEN OK?\n         BNH   MXERRMC1            PROCEED IF OKAY\n         LR    RD,RE               ELSE SUB OKAY LENGTH\nMXERRMC1 EQU   *\n         LA    R2,1(RD,R2)         GET TOTAL L-1                      A\n         LTR   RD,RD               NULL STRING?\n         BZ    MXERFOOT            FINI IF YES\n         EX    RD,MXMVSTRN         MOVE STRING TO OUTPUP\n*              FALL THRU INTO MXERFOOT.\nMXERFOOT EQU   *\n         STC   R2,RSBLENG          PUT LEN-1 IN OUTPUT\n         $CALL MXMVSR              MOVE STMT TO HIGH AREA\n         SPACE\n         XSNAP LABEL='***MXERRM EXITED***',T=NO,                       X\n               IF=(AVMSNBY2,O,$MSNP13,TM)\n         SPACE\n         $RETURN  RGS=(R14-R6)\n         SPACE\nMXERRMVC MVC   RSBSOURC($),MSGNMBR                                    A\nMXMVSTRN MVC   1($,RA),0(R1)       DUMMY TO MOVE STRING\nMXEEP12  DC    X'402020202020202020202120'    12 BYTE DEC MASK\nMXMSSGS  EQU   *\nMXACTRMS $MSG  221,' ACTR COUNTER EXCEEDED'                           A\nMXDMSNMS $MSG  222,' INVALID SYM PAR OR SET SYMBL SUBSCRIPT',FLAG=4   A\nMXSBSTMS $MSG  223,' SUBSTRING EXPRESSION OUT OF RANGE',FLAG=4        A\nMXCVCAMS $MSG  224,' INVALID CONVERSION, CHAR TO ARITH',FLAG=8        A\nMXCVABMS $MSG  225,' INVALID CONVERSION, ARITH TO BOOLEAN',FLAG=4     A\nMXCVCBMS $MSG  226,' INVALID CONVERSION, CHAR TO BOOLEAN',FLAG=8      A\nMXATTRMS $MSG  227,' ILLEGAL ATTRIBUTE LIST'                          A\nMXSYSLMS $MSG  228,' &&SYSLIST SUBSCRIPT OUT OF RANGE',FLAG=4         A\nMXSYERMS $MSG  229,' ASSIST CANNOT EXPAND--SIMPLIFY STMT OR USE .' CPP\nMXERBFM  $MSG  230,' INTERNAL CHAR BUFFER EXCEEDED'                   A\nMXEXSTMS $MSG  231,' MSTMG LIMIT EXCEEDED'                            A\nMXZDIVMS $MSG  232,' ZERO DIVIDE OR FIXED POINT OVERFLOW'             A\nMXPRVR   $MSG  217,' STMT NOT PROCESSED: PREVIOUS ERROR'              A\nMXERRSTN DC    C': STMT/MACRO',X'402020202120',C'/'                   S\nMXERRS$L EQU   *-MXERRSTN                                             A\nMXERRPTR $AL2  MXMSSGS,(MXACTRMS,MXDMSNMS,MXSBSTMS,MXCVCAMS,MXCVABMS,MXX\n               CVCBMS,MXATTRMS,MXSYSLMS,MXSYERMS,MXERBFM,MXEXSTMS,MXZDIX\n               VMS,MXPRVR),-2                                         A\n         LTORG\n         DROP  RAT,RW                                                 A\n         TITLE '***MXMVSR - MOVES GENERATED STMT TO HIGH CORE***'\n**-->  CSECT:  MXMVSR  MOVES GENERATED STMT FROM RSBLOCK TO HIGH FREE *\n*.        AREA. AVGEN2CD POINTS TO BEGINNING OF STMT                  *\n*.                                                                    *\n*.        EXIT CONDITIONS                                             *\n*.     RB = ZERO IF OKAY ELSE 4 IF OVERFLOW                           *\n*.                                                                    *\n*.        USES MACROS: $SAVE, $RETURN, $MALLOCH                       *\n*.       USES DSECTS RSBLOCK,REBLK,AVGEN1CD,AVGEN2CD                  A\n*.                                                                    *\n*.       REGISTER USAGES                                              A\n*.       RAT-MAIN TABLE USING                                         A\n*.       RW-SOURCE BLK USING                                          A\n*.       RX-ERROR BLK USING                                           A\n*.       R1,RB-BYTE REGISTERS                                         A\n*.       RA-WORK REGISTER                                             A\n*.                                                                    A\n*.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE\nMXMVSR   CSECT\n         $SAVE RGS=(R14-R4),SA=NO                                     A\n         USING AVWXTABL,RAT        NOTE MAIN TABLE USING\n         XSNAP LABEL='***MXMVSR ENTERED***',T=NO,                      X\n               IF=(AVMSNBY2,O,$MSNP13,TM)\n         USING RSBLOCK,RW          NOTE SOURCE USING\n         L     RW,AVRSBPT          SET BASE FOR RSBLOCK\n         USING REBLK,RX            SET USING FOR ERROR BLOCK\n         LA    RX,AVREBLK          SET BASE FOR ERROR BLOCK\n         SR    R1,R1\n         SR    RB,RB\n         TM    RSBFLAG,$REBX       EROOR BLOCK EXISTS?\n         BZ    MXMVSR01            JUMP AROUND IF NO\n         IC    RB,REBLN            GET LEN-1 OF ERR BLOCK\n         STC   RB,RSBNUM           PUT ERR BLOCK LEN IN RSB\n*              REBLN IS ACTUAL LENGTH OF PART OF REBLK TO BE MOVED,\n*              SINCE IT IS L-1 OF WHOLE THING (COUNTING REBLN)\nMXMVSR01 EQU   *\n         IC    R1,RSBLENG          GET LEN-1 OF STMT\n         LA    RB,RSB$L+1(RB,R1)   GET TOTAL LENGTH FOR ENTIRE SECT\n         $MALLOCH RA,RB,OVRFL=MXMVOVR    GET STORAGE FOR STMT\n         TM    RSBFLAG,$REBX       ERROR BLOCK?\n         BZ    MXMVSR02            SKIP IF NO\n         IC    RB,REBLN            GET LEN-1 OF ERR BLOCK\n         BCTR  RB,0                GET LENGTH-1 OF PART TO BE MOVED\n         LA    RX,1(RX)            BUMP REBLK PTR TO PART BEING MOVED\n         EX    RB,MXMVSRCE         MOVE ERRBLOCK TO HIGH STORAGE\n         LA    RA,1(RA,RB)         GET ACTUAL LENGTH MOVED\nMXMVSR02 EQU   *\n         LA    RX,RSBSOURC         PUT @ OF SOURCE IN RX FOR EX INST\n         EX    R1,MXMVSRCE         MOVE STMT TO HIGH CORE\n         AR    RA,R1               BUMP PTR TO LAST CHAR              A\n         MVC   1(RSB$L,RA),RSBLOCK MOVE FLAG BYTE ETC                 A\n         SR    RB,RB               CLEAR RB FOR RETURN\nMXMVRTN  EQU   *\n         MVC   RSBLOCK(RSB$L),AWZEROS   ZERO STANDARD PART OF RSBLOCK\n         MVC   RSBSOURC($LMSRCMX),AWBLANK   BLANK REMAINDER OF RECORD\n         SPACE\n         AIF   (&$DEBUG).MACQQ09   SKIP IF NO DEBUG\n         L     R1,AVGEN2CD         GET POINTER TO NEW STMT\n         XSNAP LABEL='***MXMVSR EXITED***',STORAGE=(*0(R1),*128(R1)),  X\n               IF=(AVMSNBY2,O,$MSNP13,TM)\n.MACQQ09 ANOP\n         SPACE\n         $RETURN RGS=(R14-R4),SA=NO                                   A\n         SPACE\nMXMVOVR  EQU   *\n         LA    RB,4                SET OVERFLOW FLAG\n         B     MXMVRTN             RETURN\nMXMVSRCE MVC   0($,RA),0(RX)       DUMMY TO MOVE STIRNG TO HIGH\n         LTORG\n         DROP  RAT,RW,RX,REP\n.MAXXXX  ANOP\n         PRINT ON,NOGEN\n         AIF   (NOT &$EXINT).EINONE                                   L\n         TITLE '*** ECBRSTKD - DSECT FOR THE EXT'D INT BRANCH STACK'\n**--> DSECT: ECBRSTKD       SINGLE ENTRY FOR THE BRANCH STACK . . . . .\n*.                                                                    .\n*.       THIS DSECT MIRRORS THE ECSTACKD DSECT BUT IS                 .\n*.       USED BY THE EXTENDED INTERPRETER FOR THE                     .\n*.       SUCCESSFUL-BRANCH STACK.                                     .\n*.                                                                    .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n         SPACE 2\nECBRSTKD DSECT\nECBSTENT DS    0CL16               BRANCH STACK ENTRY\nECBSLINK DS    F                   @ OF THE NEXT STACK ENTRY (LINK)\nECBSIADD DS    F                   BRANCH INSTRUCTION ADDRESS\nECBSCCPM DS    H                   CC AND PM\n         SPACE\nECBSINST DS    0CL6                UP TO 6 BYTES OF INSTRUCTION\nECBSOP   DS    C                   OPCODE\nECBSB2   DS    C                   2ND BYTE OF INSTRUCTION\nECBSBD   DS    H                   1ST OR ONLY BASE/DISPLACEMENT\nECBSB2D2 DS    H                   2ND BASE/DISPLACEMENT\n         TITLE '*** EXECUT- EXTENDED INTERPRETER SECTION'\n**--> CSECT: EXECUT       EXTENDED INTERPRETER SECTION  . . . . . . . .\n*.                                                                    .\n*.             EXTENDED INTERPRETER FOR ASSIST                        .\n*.                                                                    .\n*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n         SPACE 5\n******************   REGISTER USAGE IN EXECUT   ***********************\n*                                                                     *\n*        REG #                     USAGE IN EXECUT                    *\n*        -----                     ---------------                    *\n*                                                                     *\n*        R0             GENERAL WORK REG                              *\n*        R1             TEMPORARY BASE / GENERAL WORK REG             *\n*        R2             BYTE REG / TEMPORARY WORK REG                 *\n*        R3             BASE REG FOR THE INSTRUCTION STACK            *\n*        R4             INSTRUCTION ADDRESS REGISTER & OPERAND        *\n*                       ADDRESS REGISTER                              *\n*        R5             CONDITION CODE REG                            *\n*        R6             BASE REGISTER FOR DSECT -> ECONTROL           *\n*        R7-R9          DECODING AND GENERAL WORK REGS                *\n*        R10            DECODING REG & OPERAND ADDRESS REGISTER       *\n*        R11            CONTAINS RELOCATION VALUE (RARELY USED AS     *\n*                       A WORK REG - BUT ALWAYS RESTORED)             *\n*        R12 & R13      BASE REGISTERS FOR EXECUT                     *\n*        R14            WORK REG / INTERNAL LINKAGE REG               *\n*        R15            CONTAINS OPCODE OF CURRENT INSTRUCTION        *\n*                                                                     *\n***********************************************************************\nEXECUT CSECT\nRWK0     EQU   R0\nRWK1     EQU   R1\nRSTK     EQU   R3\nRIA      EQU   R4\nRAD1     EQU   RIA\nRAD2     EQU   R10\nRCC      EQU   R5\nREC      EQU   R6\nRMEM     EQU   R11\nRLINK    EQU   R14\nRWK14    EQU   R14\nROP      EQU   R15\n         TITLE '*** EXECUT - INITIALIZATION PHASE'\n***********************************************************************\n*                                                                     *\n*              INITIALIZATION CODE FOR EXECUT                         *\n*                                                                     *\n***********************************************************************\n         SPACE 5\n         $SAVE RGS=(R14-R12),BR=(R13,R12),SA=EIECSAVE\n         LR    REC,R10             MOVE ECONTROL POINTER OVER\n         USING ECONTROL,REC        NOTE ECONTROL USAGE\n         SPACE 2\n*              INSTRUCTION STACK ZEROING AND CHAINING\n         SR    R1,R1               CLEAR FOR ZEROING\n         SR    R2,R2               DITTO\n         SR    R3,R3               DITTO\n         LA    R4,L'ECSTENT        VAL OF SINGLE STACK ENTRY\n         LA    R5,ECINSTAC+L'ECINSTAC*(EC$STACK-1)  GET ENDING LIMIT\n         LA    R7,ECINSTAC         GET BEGINNING @ OF STACK AREA\n         USING ECSTACKD,R7         SET UP TEMPORARY USING\n         LA    R0,ECINSTAC+L'ECINSTAC  GET @ OF THE 2ND ELEMENT\nEINITIST EQU   *\n         STM   R0,R3,ECSTENT       ZERO ONE TABLE ENTRY\n         LR    R7,R0               UPDATE POINTER TO STACK ENTRY\n         BXLE  R0,R4,EINITIST      CONTINUE LOOPING\n         SPACE\n         LA    R0,ECINSTAC         ADDRESS FOR WRAP-AROUND\n         STM   R0,R3,ECSTENT       STORE IN LAST ENTRY\n         ST    R7,ECRSTK           SAVE WHERE CAN BE PICKED UP\n         DROP  R7                  DROP TEMP REG\n         SPACE 2\n*              BRANCH STACK ZEROING AND CHAINING\n         LA    R4,L'ECBSTENT       VAL OF SINGLE BRANCH STACK ENTRY\n         LA    R5,ECBRSTAC+L'ECBRSTAC*(EC$BRSTC-1)  GET ENDING LIMIT\n         LA    R7,ECBRSTAC         GET BEGINNING @ OF STACK AREA\n         USING ECBRSTKD,R7         SET UP TEMPORARY USING\n         LA    R0,ECBRSTAC+L'ECBSTENT   GET @ OF 2ND ELEMENT\nEINITBST EQU   *\n         STM   R0,R3,ECBSTENT      ZERO ONE TABLE ENTRY\n         LR    R7,R0               UPDATE POINTER TO STACK ENTRY\n         BXLE  R0,R4,EINITBST      CONTINUE LOOPING\n         SPACE\n         LA    R0,ECBRSTAC         ADDRESS FOR WRAP-AROUND\n         STM   R0,R3,ECBSTENT      STORE IN LAST ENTRY\n         ST    R7,ECBSTK           SAVE WHERE CAN BE PICKED UP\n         ST    R7,ECBCUR           SAVE FOR EIFINB LIST MANIPULATION\n         DROP  R7                  DROP TEMP REG\n         SPACE 2\n*              MORE INITIALIZATION\n         MVC   ECILCMSK(4),ECFENTER MAKE ENTRY POINT THE PSW\n         MVC   ECR14SAV,ECREG14    SAVE FOR ORIGINAL RETURN @\n         MVC   ECILIMT,ECILIMP     MOVE PERMENANT TO TEMPORARY        L\n         SPACE 2\n*              ADDRESS CALCULATION SECTION\n*              THE BELOW FAKE HIGH ADDRESS CALCULATION IS A DUPLICATION\n*              OF THE ADDRESS CALCULATIONS DONE IN ASSIST MAIN CONTROL\n*              REMOVING THIS CODE HOWEVER CAUSES THE HIGH ADDRESS TO\n*              TO END UP VERY WRONG WHEN IT GETS TO THE INTERPRETER\nEICONTIN EQU   *\n         L     R0,ECRADH           GET REAL HIGH ADDRESS LIMIT\n         S     R0,ECRADL           GET LENGTH OF USER PROGRAM\n         A     R0,ECFADL           ADD TO FAKE LOW ADDRESS\n         ST    R0,ECFADH           STORE IN FAKE HIGHEST ADDR\n         SPACE 2\n*              SET UP SPIE CODE\nEISPIEGO EQU   *\n         TM    ECFLAG0,$ECSPIEA    IS OUR SPIE ALREADY IN EFFECT\n         BO    EISPIEA             YES, WE DON'T HAVE TO RE-SPIE\n         $SPIE EISPIERT,((1,15)),CE=EISPIEXT,ACTION=CR CATCH ALL INTRP\n         ST    R1,ECPICA           SAVE PREVIOUS PICA, IF ANY\n         OI    ECFLAG0,$ECSPIEA    SHOW OUR SPIE IS IN CONTROL\n         SPACE 2\nEISPIEA  EQU  *\n*        INITIALIZE THE PRCB FOR THIS RUN\n*        (ALL DEFAULT ADDRESSES, FLAGS, ETC SET)\n         MVC   ECPRFLG1(8),EIDFAULT  MOVE DEFAULT VALS TO PRCB\n         MVC   ECPRWORK(4),ECFADL  SET UP HIGH AND LOW DEFAULT        M\n         MVC   ECPRWORK+4(4),ECFADH    ADDRESSES IN WORK AREA         M\n         MVC   ECPRTRAL(8),ECPRWORK  SET TRACE LIMIT ADDRS            M\n         MVC   ECPRMODL(8),ECPRWORK  SET MOD CHK LIMIT ADDRS          M\n         MVC   ECPRICL(8),ECPRWORK   SET IECF LIMIT ADDRESSES         M\n         MVC   ECPRCLOK(4),ECILIMP   SET INSTR COUNTER (CLOCK)\n         MVC   ECPRCMPR(4),=F'-1'  DISARM INTERRUPT CLOCK\n         MVI   EITSTMSK+1,ECEM370  ITIALIZE INVALID OP CODE TEST\n         SPACE 2\n*              SET UP USINGS, REGS, ETC. FOR THIS RUN\n         L     RSTK,ECRSTK         GET PTR TO STACK FOR BASE\n         USING ECSTACKD,RSTK       SET UP PERMANENT USING\n         L     RMEM,ECRELOC        GET RELOCATION VAL IN REG\n         SR    R2,R2               CLEAR BYTE REG\n         STH   R2,ECINTCOD         SET THE INTERRUPT CODE TO 0\n         SR    ROP,ROP             CLEAR OPCODE REG FOR CONSTANT IC'S\n         L     RIA,ECILCMSK        LOAD INSTR @ REG FOR EIFINB\n         LR    RCC,RIA             PLACE CC AND MASK OVER\n         SPM   RCC                 INIT REAL CC = FAKE CC\n         AIF   (NOT &$FLOTE).EINOFL1  SKIP IF NOT DOING FL\n         LD    F0,ECFPREGS         GET FP REG\n         LD    F2,ECFPREGS+8       GET FP REG\n         LD    F4,ECFPREGS+16      GET FP REG\n         LD    F6,ECFPREGS+24 GET FP REG\n.EINOFL1 ANOP\n         B     EIFINB              BEGIN MAIN LOOP INTERPRETATION\n         SPACE 5\n*              DEFAULT PRCB FLAGS\nEIDFAULT DC    AL1(0)              ECPRFLG1 DEFAULT\n         DC    AL1(ECEM370+ECALNCHK)  ECPRFLG2 DEFAULT\n         DC    XL6'0'              ECPRFLG3-ECPRFLG8 DEFAULT\n         EJECT\n* * * * * * * * * * *  OCX  INTERRUPT  EXITS  * * * * * * * * * * * * *\n***********************************************************************\n         SPACE 2\nEIOC1    EQU   *\n         LA    R0,1                SHOW OPERATION INTERRUPT\n         B     EIEXITI             EXIT POINT FOR INTERRUPTS\nEIOC2    EQU   *\n         LA    R0,2                SHOW PRIVILEGED OPERATION\n         B     EIEXITI             EXIT POINT FOR INTERRUPTS\nEIOC3    EQU   *\n         LA    R0,3                EXECUTE INTERRUPT\n         B     EIEXITI             EXIT POINT FOR INTERRUPTS\nEIOC4    EQU   *\n         LA    R0,4                PROTECTION INTERRUPT\n         B     EIEXITI             EXIT POINT FOR INTERRUPTS\n*EIOC5   EQU   *\n*        LA    R0,5                ADDRESSING INTERRUPT\n*        B     EIEXITI             EXIT POINT FOR INTERRUPTS\nEIOC6A   EQU   *                  NO NEED FOR SEPARATE CASES    CEH\nEIOC6    EQU   *\n         LA    R0,6                SPECIFICATION INTERRUPT\n         B     EIEXITI             EXIT POINT FOR INTERRUPTS\n*EIOC7   EQU   *\n*        LA    R0,7                DATA EXCEPTION\n*        B     EIEXITI             EXIT POINT FOR INTERRUPTS\nEIOCA    EQU   *\n         LA    R0,10               DECIMAL OVERFLOW\n         B     EIEXITI             EXIT POINT FOR INTERRUPTS\n         SPACE 5\n*              ENTERED WHEN PROGRAM BRANCHES OUT OF RANGE\nEIIAOUT  EQU   *\n         MVI   ECFLAG1,$ECBRN14    HOPE FOR NORMAL RETURN\n         L     R14,ECR14SAV        GET RETURN @, ORIGINAL\n         LA    R14,0(R14)          REMOVE LEADING BYTE\n         CR    RIA,R14             WAS BRANCH TO THIS ADDR ?\n         BE    EIITAILC            YES, PERFORM A NORMAL RETURN       M\n         MVI   ECFLAG1,$ECBROUT    WAS ACTUAL BRANCH OUT OF PROG\n         LA    R1,EICCBROU         SHOW @ BRANCHED OUT\n         NI    ECPRFLG3,ECNOSPI    MAKE SURE SPIE IS OFF FOR SAFETY\n         B     EIITIA              GO, HAVE @ STORED, QUIT            M\n         EJECT\n***********************************************************************\n*                                                                     *\n*              INTERRUPT HANDLER                                      *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nEISPIEXT EQU   *\n         USING *,R15\n         MVC   ECINTCOD(2),2(R1)   SAVE INTERRUPT CODE\n         BR    R14                 RETURN TO OS CONTROL\n         DROP  R15                 DROP TEMP REG\n         SPACE\n         SPACE 5\n***********************************************************************\n*                   EXIT AND RETURN CODE                              *\n***********************************************************************\n         SPACE 2\nEIEXITI  EQU   *\n         STH   R0,ECINTCOD         SAVE INTO INTERRUPT CODE\nEISPIERT EQU   *\n         MVI   ECFLAG1,0           RESET, NEEDED BY REPLACE MONITOR\n         LH    R1,ECINTCOD  NOTE:NEED THIS WHEN ENTERED AT EISPIERT   L\n         ALR   R1,R1               DOUBLE FOR HALFWORD INDEX          L\n         LH    R1,EICOFFS(R1)      GET OFFSET TO MESSAGE BLOCK\n         LA    R1,EICC0(R1)        GET @ OF MESSAGE\nEIITIA   EQU   *\n         ST    R1,ECERRAD          STORE @ IN ECONTROL\n         MVC   ECBSTK(4),ECBCUR    SAVE THE CURRENT BR STK PNTR\n         ST    RSTK,ECRSTK         SAVE THE STACK POINTER\n        N      RCC,=XL4'3F000000'  REMOVE @ & ILC (WHICH IS WRONG)\n         L     RIA,EIRIA          RELOAD ADDR. OF NEXT INSTR.   CEH\n         ALR   RCC,RIA             PUT THE @ AND CC TOGETHER\n         IC    RIA,EICTB2          GET ILC FROM LAST INST             L\n         SLL   RIA,29              SHIFT ILC TO EXTREME LEFT          L\n         OR    RCC,RIA             COMPLETE PSW IN RCC                L\n         ST    RCC,ECILCMSK        SAVE INTO THE PSW\n         SPACE 5\n*              THIS SECTION TESTS FOR AN XOPC SPIE BEING SET\n*              IF AN INTERRUPT OCCURS AND AN XOPC SPIE HAS NOT BEEN\n*              SET ABNORMAL USER TERMINATION IS PERFORMED.  IF A SPIE\n*              HAS BEEN SET AND THE INTERPRETER IS NOT ALREADY CATCH-\n*              ING AN INTERRUPT, THE SPIE EXIT ADDRESS BECOMES THE\n*              ADDRESS OF THE NEXT INSTRUCTION AND EXECUTION CONTINUES\nEITSTST  EQU   *\n         TM    ECPRFLG3,ECINHDST   TEST IF ALREADY HANDLING AN INTERUPT\n         BO    EIITAILC            IF SO, GO AHEAD AND TERMINATE\n         TM    ECPRFLG3,ECSPISET   TEST IF CATCHING INTERRUPTS\n         BNO   EIITAILC            IF NO SPIE SET, TERMINATE\n         LH    R1,ECINTCOD         GET THE INTERRUPT CODE IN A REGISTER\n         LA    R1,16(R1)           SHIFT 16 MORE THAN INTRPT CODE\n         STC   R1,EISPISFT+3       STORE INTERRUPT CODE IN SHIFT INSTR\n         L     R1,ECPRSCDE         GET THE INT CODES TO BE CAUGHT\nEISPISFT SLL   R1,$                SHIFT TO SEE IF THIS INT CAUGHT\n         LTR   R1,R1               COMPARE SHIFTED REGISTER TO ITSELF\n         BNM   EIITAILC            IF RESULT NOT MINUS DO NOT CATCH\n         MVC   ECPRIRGS(8),ECREG0  SAVE USER REGS 0 AND 1\n         MVC   ECREG0(8),ECPSW     SAVE PSW IN USER REGS 0 AND 1\n         L     RIA,ECPRSPIE        PUT SPIE EXIT ADDR FOR BRANCH\n         OI    ECPRFLG3,B'01000000' NOW IN INTERRUPT HANDLING STATE\n         B     EIFINB              TREAT AS HAVING EXECUTED BRANCH INST\nEIITAILC EQU   *\n         AIF   (NOT &$FLOTE).EINOFL3  SKIP IF NO FLOATINGS\n         STD   F0,ECFPREGS         STORE FP REGS\n         STD   F2,ECFPREGS+8       STORE FP REGS\n         STD   F4,ECFPREGS+16      STORE FP REGS\n         STD   F6,ECFPREGS+24      STORE FP REGS\n.EINOFL3 ANOP\n         TM    ECFLAG0,$ECSPIEB    DO WE NEED TO UNDO SPIE\n         BZ    EIECRET             NO, RETURN\n         L     R1,ECPICA           GET PICA ADDR BACK\n         $SPIE ACTION=(RS,(1))     RESTORE PREVIOUS XSPIEBLK\n         NI    ECFLAG0,255-$ECSPIEA  WE WILL HAVE TO RESPIE\nEIECRET  EQU   *\n         $RETURN RGS=(R14-R12)\n         TITLE '*** EXECUT - MAIN INSTRUCTION FETCH AND DECODING LOOP'\n***********************************************************************\n*                                                                     *\n*                  MAIN INTERPRETER LOOP HEAD                         *\n*                                                                     *\n*        ALL SUCCESSFUL BRANCHES PASS THROUGH EIFINB, WHERE           *\n*        CHECKING FOR ILLEGAL BRANCHES IS DONE.  CHECKING IS          *\n*        ALSO DONE FOR TIMER RUNOUT.                                  *\n*                                                                     *\n*        OTHER INSTRUCTIONS (UNSUCCESSFUL BRANCHES INCLUDED)          *\n*        PASS THROUGH EIFIN OR EIFINRR AS APPROPRIATE.                *\n*                                                                     *\n***********************************************************************\n         SPACE 4\nEIFINB   EQU   *\n*              MOVE INSTRUCTION TO BRANCH STACK\n         L     R1,ECBCUR           GET POINTER TO PRES STK SLOT\n         USING ECBRSTKD,R1         SET UP TEMPORARY USING\n         L     R1,ECBSLINK         GET POINTER TO NEXT AVAILABLE SLOT\n         MVC   ECBSTENT+4(L'ECBSTENT-4),ECSTENT+4  MOVE ENTRY OVER\n         ST    R1,ECBCUR           SAVE ADDRESS OF THIS SLOT FOR LATER\n         DROP  R1                  DROP TEMP REG\n         SPACE\n*              CHECK IF BRANCH IS LEGAL\n         LA    RIA,0(RIA)          REMOVE 1ST BYTE OF BRANCH @\n         ST    RIA,EIRIA          SAVE CURRENT INSTR. ADDR.     CEH\n         C     RIA,ECFADL          CMPR FOR BELOW LOWEST FAKE\n         BL    EIIAOUT             BRANCH IF OUT OF RANGE - ERROR\n         C     RIA,ECFADH          CMPR FOR OVER HIGHEST FAKE\n         BNL   EIIAOUT             BRANCH IF OUT OF RANGE - ERROR\n         AIF   (NOT &$ALIGN).EIFT1 SKIP IF MACHINE REQUIRES ALIGNMENT\n         ST    RIA,ECTSAVE         SAVE @: MUST DO CHECK SLOW WAY\n         TM    ECTSAVE+3,EIALHALF  DO WE HAVE HALFWORD ALIGN ?\n         BO    EIOC6               NO - SPEC. ERROR\n         AGO   .EIFT2              SKIP OTHER ALIGN CODE\n.EIFT1   ANOP\n         LH    R0,0(RIA,RMEM)      QUICK ALIGN CHECK\n.EIFT2   ANOP\n         SPACE\n*              IF TIMER RUNOUT OCCURS, ASSIST SETS ECFLAG1=$ECTIMEX.\n*              EXECUT DISCOVERS THIS NEXT TIME BRANCH IS SUCCESSFUL.\n         AIF   (&$TIMER EQ 0).EINOTOA  SKIP IF NO TIMER AT ALL\n         CLI   ECFLAG1,$ECTIMEX    IS TIMER RUNOUT FLAG SET ?\n         BNE   EIFINRR             NO - FETCH AND PROCESS INSTR AT NEW X\n                                   BRANCH ADDRESS\n*              TIMER RUNOUT HAS OCCURRED - FLAG IT.  ECFLAG1\n*              ALREADY SET.\n         LA    R1,EICCTIMB         SHOW @ OF OVER TIME MESSAGE\n         B     EIITIA              JUMP TO EXIT SECTION               M\n         AGO   .EINOTOB\n.EINOTOA ANOP\n         B     EIFINRR             BRANCH TO FETCH AND PROCESS INSTR\n.EINOTOB ANOP\n         SPACE 4\n***********************************************************************\n*                                                                     *\n*              HERE BEGINS THE PRIMARY INSTR FETCH AND                *\n*              DECODING SECTION.                                      *\n*                                                                     *\n***********************************************************************\n         SPACE 3\n*              CHECK FOR EXCEEDING TOTAL INSTRUCTION COUNT --\n*\n*              CONTROL IS PASSED TO EIFIN AFTER INTERPRETATION OF\n*              ALL INSTRUCTIONS EXCEPT SUCCESSFUL BRANCHES AND RR\n*              INSTRUCTIONS.  CONTROL IS PASSED TO EIFINRR AFTER\n*              RR'S, AND TO EIFINB AFTER SUCCESSFUL BRANCHES.\nEIFIN    EQU   *\n         L     RIA,EIRIA           RESTORE INSTR @ REG\nEIFINRR  EQU   EIFIN              RR NOW MERGES WITH OTHER      CEH\n         L     R0,ECILIMT          GET INSTRUCTION COUNTER\n         BCT   R0,EIGO             DECREMENT COUNTER\n*              COUNTER LIMIT EXCEEDED -- BR TO INTERRUPT ROUTINE\nEICNTINT EQU   *\n         ST    R0,ECILIMT          RESTORE INSTR LIMIT FOR STATS\n         MVI   ECFLAG1,$ECTIMEX    SHOW INSTR LIMIT EXCEEDED\n         LA    R1,EICCTIME         GET @ OF TIME MESSAGE\n         NI    ECPRFLG3,ECNOSPI    MAKE SURE SPIE IS OFF FOR SAFETY\n         B     EIITIA              BR TO EXIT ROUTINE                 M\nEIGO     EQU   *\n         C     R0,ECPRCMPR         CMPR CLOCK AGAINST USER LIMIT\n         BNE   EICLKOK             CONTINUE ON IF NO COUNT LIMIT EXCEED\n         TM    ECPRFLG4,ECLKADR    TEST TO SEE IF CLOCK EXIT ADDR GIVEN\n         BNO   EICNTINT            IF NO ADDR GIVEN - DO TIMER EXIT\n         L     RIA,ECPRCLEA        PREPARE BRANCH TO GIVEN EXIT ADDR\n         MVC   ECPRCMPR(4),=F'-1'  DISARM THE CLOCK FROM FURTHER INTRPS\n         B     EIFINB              TREAT AS BR INST SINCE CAUSE OF INTR\nEICLKOK  EQU   *                   NO CLOCK INTERRUPT HAS OCCURED\n         ST    R0,ECILIMT          RESTORE COUNTER\n         SPACE 2\n*              PRIMARY INSTRUCTION FETCH\n         LA    RWK14,0(RIA,RMEM)   OBTAIN PHYSICAL REAL ADDRESS\n         L     RSTK,ECSTLINK       OBTAIN ADDRESS OF NEXT STACK SLOT\n         STM   RIA,RCC,ECSTIADD    SAVE INSTRUCTION ADDRESS, CC, MASK\n         MVC   ECSTINST,0(RWK14)   MOVE 6 BYTES INTO THE NEXT SLOT\n         IC    ROP,ECOP            GET OPCODE INTO A REGISTER\n         SPACE 2\n*              FETCH MAIN TABLE ENTRY BY OPCODE INDEXING\nEIEXPEN  EQU   *\n         SR    R1,R1               R1 IS ZERO FOR IC\n         IC    R1,EIOPCDTB(ROP)    FETCH POINTER TO MAIN TABLE\n         SLL   R1,3                MULTIPLY BY 8 FOR MAIN TAB INDEX\n         LA    R1,EICONTAB(R1)     GET @ OF CONTROL TABLE ENTRY\n         MVC   EICTNTRY(EICTE$L),0(R1)    MOVE TABLE ENTRY TO WORK AREA\n         TM    EICTB1,EIEXOPCD     DOES OPCODE TELL ALL ?\n         BZ    EICHKF$A            IF YES, BR TO CHK FACILITIES ON\n         SPACE 2\n*              OPCODE DOES NOT TELL ALL - - - GET TABLE ENTRY\n*              FOR EXTENDED OPCODE INSTRUCTION\n         L     R1,EIEXTTAB         GET ADDRESS OF TOP SEC TABLE\n         MVC   EISHFTIN+3(1),EI#SHIFT(R1) PUT SHIFT # INTO INST.      L\n         IC    R2,ECOPEX           GET OPCODE EXTENSION BYTE\n*              THE FOLLOWING SHIFT INSTRUCTION WILL BE MODIFIED DURING\n*              EXECUTION TO SHIFT THE CORRECT AMOUNT FOR EACH\n*              DIFFERENT EXTENDED OPCODE.\nEISHFTIN SRL   R2,$                SHIFT FOR INDEX INTO BYTE TABLE\n         C     R2,EIMAXIND(R1)     CMPR SHFT VALUE TO MAX\n         BH    EIOC1               BR IF OPCODE IS BAD\n         IC    R2,EICTE$L(R2,R1)   GET BYTE TABLE ENTRY\n         LTR   R2,R2               TEST FOR LEGAL EXTENDED OP CODE\n         BZ    EIOC1               BRANCH IF INVALID OPCODE\n         LA    R1,0(R2,R1)         GET ADDRESS OF TABLE ENTRY\n         MVC   EICTNTRY(EICTE$L),0(R1)  FETCH EXTENDED OPCD TAB ENTRY\n         SPACE 2\n*              CHECK FOR INSTRUCTION TRACE AND IECF\nEICHKF$A EQU   *\n         TM    ECPRFLG1,ECPROPON   CHECK IF ANY OPTIONS = ON\n         BNZ   EITRIC              BRANCH IF TRACE OR IECF ON\n         SPACE 2\n*              INCREMENT INSTRUCTION ADDRESS REGISTER\n*\n*              ** NOTE ** DO NOT CHANGE THE ORDER OF THE NEXT FEW\n*              INSTRUCTIONS WITHOUT FIRST SEEING AND MODIFYING THE\n*              EX INSTR CODE (EIEX)\nEIINCPSW EQU   *\n         SR    R2,R2               ZERO FOR IC INST                   L\n         IC    R2,EICTB2           GET THE LENGTH OF THE INSTRUCTION\n         AR    RIA,R2              INCREMENT INSTRUCTION ADDRESS REG\n         SPACE 2\n*              CHECK IF OPCODE IS LEGAL ON THE MACHINE\n*              PRESENTLY BEING EMULATED\n*              NOTE:  THE MASK FOR THE FOLLOWING TM INSTRUCTION WAS\n*              INSERTED EARLIER, EITHER AT INITIALIZATION (AS 370)\n*              OR WHEN EVER AN XOPC INSTRUCTION IS EXECUTED WHICH COULD\n*              CHANGE THE MACHINE EMULATION FLAGS IN THE PRCB\nEITSTMSK TM    EICTB1,$            TEST TAB ENTRY FOR VALID OP CODE\n         ST    RIA,EIRIA          SAVE FOR RESTORING LATER      CEH\n         BZ    EIOC1               BRANCH TO INTER ROUTINE IF INVALID\n         SPACE 2\n*              CHECK IF THIS IS A PRIVILEGED INSTRUCTION\nEIOPOK   EQU   *\n         TM    EICTB1,EIPRIVOP     IS THIS A PRIV INSTR ?\n         BO    EICHKST             IF YES, BRANCH TO CHECK STATE\n         SPACE 2\n*              THE FOLLOWING SECTION DECODES THE SECOND BYTE OF THE\n*              INSTRUCTION AND PERFORMS A MULTI-WAY BRANCH TO GET\n*              THE NEEDED INFORMATION IN THE PROPER PLACES\n*              EXPECTED LATER IN THE SPECIAL ROUTINES.\nEI2BDECD EQU   *\n         CLI   ECOP,X'E1'          CHECK FOR ONLY REGISTER XDUMP\n         BE    EIXIOSR             SKIP EXTRANEOUS DECODEING FOR XDUMPR\n         SR    R7,R7               CLEAR BYTE REGISTER\n         IC    R7,ECI2             GET 2ND BYTE OF INSTR\n         TM    EICTB3,EIB2IORL     TEST TO DETERMINE DECODING NEEDED\n         BZ    EIRRX4              2 REGS - MULT BY 4 FOR INDEX\n         BO    EI2BMERG            IF IMMED OR LENGTH, DONE\n         SPACE 2\n*              PROCESS 2ND BYTE AS LL X 1\n         LR    R9,R7               COPY 2ND BYTE OF INSTR\n         SRL   R7,4                R7 = L1\n         N     R9,=XL4'0F'         R9 = L2\n         B     EI2BMERG            BRANCH TO MERGE BACK\n         SPACE 2\n*              PROCESS 2ND BYTE AS RR X 4\n*              (EVEN/ODD REGISTER CHECKING DONE ALSO)\nEIRRX4   EQU   *\n         SPACE 2\n*              THIS SECTION TESTS FOR EVEN ODD REGISTERS WHEN\n*              THEY ARE NEEDED IN AN INSTRUCTION.\n         MVC   *+7(1),EICTB5       MOVE TABLE BYTE 5 INTO TM INST\n         TM    ECR1R2,$            TEST EVEN/ODD REG ** MASK MOVED IN**\n         BNZ   EIOC6               IF RESULT NOT ZERO SOC 6 INT\nEIRRX4A  EQU   *\n         LR    R9,R7               COPY 2ND BYTE OF INSTR\n         N     R9,=F'15'           REMOVE 1ST REG, LEAVING 2ND ONLY\n         SLL   R9,2                GET R2 FIELD*4 FOR INDEXING\n         SRL   R7,4                GET R1 FIELD*4\n         SLL   R7,2                FOR INDEXING\n         L     R8,ECREGS(R7)       GET VALUE IN USER REG (R1)\n         L     R10,ECREGS(R9)      GET VALUE IN USER REG (R2)\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*        AT THIS POINT IN THE DECODING, THE FOLLOWING INFORMATION     *\n*        IS CONTAINED IN REGISTERS R7 - R10:                          *\n*                                                                     *\n*      --2 REGS SPECIFIED IN INSTR+1                                  *\n*                                                                     *\n*              R7 = # OF THE 1ST REG MULT BY 4                        *\n*              R8 = CONTENTS OF THE 1ST REG                           *\n*              R9 = # OF THE 2ND REG MULT BY 4                        *\n*             R10 = CONTENTS OF THE 2ND REG                           *\n*                                                                     *\n*      --2 LENGTHS OR IMMED FIELDS SPEC IN INSTR+1                    *\n*                                                                     *\n*              R7 = THE 1ST LENGTH OR IMMED FIELD                     *\n*              R8 = UNUSED                                            *\n*              R9 = THE 2ND LENGTH OR IMMED FIELD                     *\n*             R10 = UNUSED                                            *\n*                                                                     *\n*      --1 LENGTH OR IMMED FIELD SPEC IN INSTR+1                      *\n*                                                                     *\n*              R7 = THE LENGTH OR IMMED FIELD                         *\n*              R8 = UNUSED                                            *\n*              R9 = UNUSED                                            *\n*             R10 = UNUSED                                            *\n*                                                                     *\n***********************************************************************\n         SPACE 2\n*              MERGE BACK AFTER 2ND BYTE DECODING -- CHECK IF\n*              THIS IS AN RR INSTR; IF SO, BRANCH TO PROCESS\nEI2BMERG EQU   *\n         TM    EICTB1,EIRR         IS THIS AN RR INSTR ?\n         BNO   EI2HDECD            IF NOT, BR TO DECODE 2ND HALFWORD\n         LH    R1,EICTDISP         GET DISP TO SPECIAL ROUTINE\n         B     EISPEJMP(R1)        BRANCH TO SPECIAL ROUTINE\n         SPACE 2\n*              DECODE 2ND HALFWORD OF THE INSTRUCTION.  INFORMATION\n*              IS PUT WHERE EXPECTED LATER.  ADDRESS IS CHECKED FOR\n*              ALIGNMENT ERROR.\nEI2HDECD EQU   *\n         LH    RWK0,ECBD           LOAD 1ST B1D1 IN WORK REG FOR INSUB\n         BAL   RLINK,EIBASDSP      HAVE INSUB EVALUATE B1D1\n         LR    RAD1,RWK0           COPY ADDR INTO 1ST ADDR REG\n         TM    EICTB3,EIH2NODX     CHECK IF INDEX REG NEEDED\n         BO    EINODX              BRANCH IF B/D ONLY\n         LTR   R9,R9               TEST IF INDEX REG = 0\n         BZ    EINODX              BRANCH IF ZERO\n         LA    RAD1,0(RAD1,R10)    ZERO OUT HIGH ORDER BYTE\n         SPACE 2\n*              THIS SECTION CHECKS FOR AND PERFORMS OPERAND ALIGNMENT\n*              CHECKING IF NEEDED\nEINODX   EQU   *\n         TM    ECPRFLG2,ECALNCHK   IS ALIGNMENT CHECKING = ON ?\n         BNO   EINOCHK             BRANCH IF NOT\n         MVC   EITSMK+1(1),EICTB4    MOVE MASK INTO TM INSTR\n         STC   RAD1,EIWORK         ST LOW ORDER BYTE OF @ IN WORK AREA\nEITSMK   TM    EIWORK,$            TEST FOR ALGN ERR **MASK MOVED IN**\n         BNZ   EIOC6A              BRANCH & RESET RIA ON ALGN ERROR   L\n         SPACE 2\n*              CHECK 1ST OPRND ADDR FOR PROPER RANGE AND\n*              STORAGE MODIFICATION.\nEINOCHK  EQU   *\n         MVC   EIWORK(1),EICTB3   STORE CONTROL BYTE IN WORK  CPP\n         TM    EICTB1,EINOCNOW     DO WE CHECK MOD STOR RANGE NOW\n         BNO   EI2HEND             BRANCH IF NOT\n         IC    R2,EICTB6           GET MOD STORE LENGTH BYTE\n         LTR   RWK0,R2             GET LENGTH IN RIGHT REG\n         BNZ   EIHAVLEN            BRANCH IF RWK0 HAS LENGTH\n         LA    RWK0,1(R7)          GET LENGTH FROM THE INSTR\nEIHAVLEN EQU   *\n         LR    RWK1,RAD1           COPY ADDR TO BE CHECKED\n         BAL   RLINK,EIMSFCHK      BR TO ADDR CHECKING ROUTINE\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*        AT THIS POINT IN THE DECODING PROCESS, THE FOLLOWING         *\n*        INFORMATION IS CONTAINED IN THE SPECIFIED REGISTERS:         *\n*                                                                     *\n*        (NOTE:  NO RR-TYPE INSTRS IF HERE)                           *\n*                                                                     *\n*          R7 - SAME AS IN COMMENT BLOCK ABOVE                        *\n*          R8 - SAME AS IN COMMENT BLOCK ABOVE                        *\n*          R9 - SAME AS IN COMMENT BLOCK ABOVE                        *\n*         R10 - SAME AS IN COMMENT BLOCK ABOVE                        *\n*        RAD1 - CONTAINS THE CALCULATED RELATIVE ADDRESS FROM THE     *\n*               2ND HALFWORD OF THE INSTR (B1-D1  OR  I1-B1-D1)       *\n*                                                                     *\n*        NOTE:  RAD1 IS RELOCATED TO REAL IFF THIS IS NOT A BRANCH    *\n*               INSTRUCTION.                          ---             *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nEI2HEND  EQU   *\n         TM    EICTB2,EILEN6       IS INSTR LENGTH = 6 ?\n         BO    EI3HDECD            BRANCH IF YES\n         TM    EICTB3,EIBRINST     IS THIS A BRANCH INSTRUCTION ?\n         BO    EI4JUMP             YES - DON'T RELOCATE RAD1\n         ALR   RAD1,RMEM           RELOCATE ADDRESS TO REAL\n         AIF   (&$S370 NE 2).EITRX SKIP IF ON A REAL 370\n*\n*              IF FAKING ALIGNMENT IS NECESSARY, DO IT !\n*\n         TM    ECPRFLG2,ECALNCHK   IS ALIGNMENT CHECKING ON ?\n         BZ    EI4JUMP             NO - SKIP FAKING CODE\n         TM    EICTB4,EIALDOBL     DOES THIS INSTR NEED ALIGN ?\n         BZ    EI4JUMP             NO - SKIP FAKING CODE\n         CLI   ECOP,X'90'         IS THIS A STM?                CPP\n         BE    EI4JUMP            IF YES SKIP FAKING CODE       CPP\n         CLI   ECOP,X'98'         IS THIS AN LM?                CPP\n         BE    EI4JUMP            IF YES, SKIP FAKING CODE      CPP\n         CLI   ECOP,X'44'         IS THIS AN EX?                CPP\n         BE    EI4JUMP            IF YES, SKIP FAKING CODE      CPP\n         LTR   RWK14,RAD1          SAVE FOR LATER, SET CC ^= 0\n         MVC   EIDUBLWD(8),0(RAD1) MOVE A MAX OF 8 BYTES OVER\n         LA    RAD1,EIDUBLWD       LOAD @ OF ALIGNED FIELD\n.EITRX   ANOP\nEI4JUMP  EQU   *\n         LH    RWK1,EICTDISP       GET DISP FOR BR TO SPECIAL ROUTINE\n         B     EISPEJMP(RWK1)      BRANCH TO SPECIAL ROUTINE\n         AIF   (&$S370 NE 2).EITRXA  SKIP IF ON A REAL 370\nEIDUBLWD DC    D'0'                USED FOR FAKING 360 ALIGNMENT\n.EITRXA  ANOP\n         SPACE 2\n*              THIS SECTION DECODES THE THIRD HALFWORD OF THE 6 BYTE\n*              SS-TYPE INSTRUCTION, AND THEN BRANCHES TO A SPECIAL\n*              ROUTINE TO COMPLETE PROCESSING.\nEI3HDECD EQU   *\n         LH    RWK0,ECB2D2         GET 3RD HALFWORD OF THE INSTR\n         BAL   RLINK,EIBASDSP      CALCULATE RELATIVE ADDR (B2D2)\n         LR    RAD2,RWK0           COPY ADDR INTO 2ND ADDR REG\n         SPACE 2\n*              CHECK 2ND OPRND ADDRESS FOR PROPER RANGE\n         TM    ECFLAG0,$ECPROT     IS ABSOLUTE PROTECT FLAG ON ?\n         BZ    EI3HEND             IF NOT, BRANCH AROUND INSUB CALL\n         CLI   ECOP,X'E0'          IS THIS AN X-PSEUDO INSTR ?\n         BE    EI3HEND             YES - DON'T CHECK THIS ADDRESS\n         LR    RWK1,RAD2           COPY ADDRESS FOR CHECKING\n         LR    RWK0,R7             ASSUME ONE LENGTH FOR OPERANDS\n         TM    EICTB3,EIB2IORL     TEST TO FIND LENGTH TYPE\n         BO    *+6                 IF ONE LENGTH BRANCH AROUND\n         LR    RWK0,R9             GET RIGHT LENGTH\n         ALR   RWK0,RWK1           GET @ OF HIGHEST BYTE ACCESSED\n         BAL   RLINK,EIFTHCHK      CHECK ADDR FOR FETCH RANGE\n***********************************************************************\n*                                                                     *\n*        REGISTER USAGE FOR SS-TYPE INSTRUCTIONS IS AS FOLLOWS:       *\n*                                                                     *\n*          R7 - CONTAINS EITHER:                                      *\n*              A.  THE LENGTH OR IMMED FIELD AS A FULL BYTE, OR       *\n*              B.  THE 1ST OF 2 LENGTHS OR IMMED FIELDS               *\n*          R8 - IS UNUSED                                             *\n*          R9 - IS EITHER UNUSED OR CONTAINS THE 2ND OF 2 LENGTHS OR  *\n*               IMMEDIATE FIELDS                                      *\n*        RAD1 - CONTAINS THE 1ST RELATIVE ADDRESS (B1D1)              *\n*        RAD2 - CONTAINS THE 2ND RELATIVE ADDRESS (B2D2)              *\n*                                                                     *\n*        NOTE: THE ADDRESSES IN RAD1 AND RAD2 ARE RELOCATED FOR       *\n*              ASSIST.                        ---                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nEI3HEND  EQU   *\n         AR    RAD1,RMEM           RELOCATE 1ST FAKE @ TO REAL\n         AR    RAD2,RMEM           RELOCATE 2ND FAKE @ TO REAL\n         MVC   EIQSS(2),ECOP       MOVE OPCODE & LENGTH(S) INTO INSTR\n         LH    RWK1,EICTDISP       GET DISP FOR BR TO SPECIAL ROUTINE\n         B     EISPEJMP(RWK1)      BRANCH TO SPECIAL ROUTINE\n         SPACE 1\nEIRIA    DC    F'0'                SAVE AREA FOR INSTRUCTION ADDR\n         SPACE 5\nEISPEJMP EQU   *                   USED TO CALCULATED JUMP ADDRESS\n*\n*------------> THIS MARKS THE END OF THE PRIMARY FETCH/DECODE LOOP\n         TITLE '*** EXECUT - CODE CALLED FROM MAIN FETCH/DECODE LOOP'\n*              THE FOLLOWING CODE COMPRISES SOME OUT-OF-LINE\n*              ROUTINES BRANCHED TO FROM THE ABOVE PRIMARY FETCH\n*              AND DECODING LOOP:\n         SPACE 2\n*              CHECK STATE  ----  PRIV OPCODE WAS ENCOUNTERED\nEICHKST  EQU   *\n         TM    ECPRFLG2,ECSUPRST   ARE WE IN SUPERVISOR STATE ?\n         BO    EI2BDECD            IF IN SUPER STATE BRANCH TO DECODE\n         B     EIOC2               IF NOT IN SUPER STATE SOC 2 FLAGGED\n         SPACE 2\n*              THIS SECTION PROCESSES INSTRUCTION TRACE AND\n*              COUNTING FACILITIES\n         SPACE 2\n*              INCREMENT THE INSTRUCTION EXECUTION COUNT FACILITY\n*              COUNTERS\nEITRIC   EQU   *\n         TM    ECPRFLG1,ECPRIECF   IS THE IECF ACTIVE NOW?\n         BNO   EITRICB             IF NOT ON GO SEE IF TRACE IS ON\n         C     RIA,ECPRICH         CMPR INSTR @ WITH HIGH ADDR LIMIT\n         BH    EITRICB             BRANCH IF OUT OF RANGE\n         C     RIA,ECPRICL         CMPR INSTR @ WITH LOW ADDR LIMIT\n         BL    EITRICB             BRANCH IF OUT OF RANGE\n         LR    RWK1,RIA            MOVE INSTR @ REG TO WORKABLE REG\n         S     RWK1,ECFADL         SUBTRACT FOR INSTRUCTION OFFSET\n         L     R7,ECPRICA          GET BEGINNING ADDRESS OF COUNT AREA\n         LH    RWK14,0(RWK1,R7)    LOAD THE PROPER HALFWORD COUNTER\n         LA    RWK14,1(RWK14)      INCREMENT THE INSTRUCTION COUNTER\n         STH   RWK14,0(RWK1,R7)    RESTORE THE INCREMENTED COUNTER\n*              PROCESS ---->  TRACE FACILITY\nEITRICB  EQU   *\n         TM    ECPRFLG1,ECPRTRCE   IS THE TRACE FACILITY ON\n         BNO   EIINCPSW            BRANCH IF FACILITY NOT ON\n         C     RIA,ECPRTRAH        COMPARE INSTR @ WITH HIGH LIMIT\n         BH    EIINCPSW            BRANCH IF OUT OF RANGE\n         C     RIA,ECPRTRAL        CMPR INSTR @ WITH LOW LIMIT\n         BL    EIINCPSW            BRANCH IF OUT OF RANGE\n         MVC   EITRMSIN+4(10),EIBLANKS   BLANK OUT INSTR AREA\n         XHEXO RIA,EITRMSAD        CONVERT INSTR @ TO HEX\n         MVC   EITRMSAD(2),EIBLANKS      BLANK OUT 1ST TWO BYTE OF @\n         LM    R0,R1,ECSTCCPM      FETCH INSTR FROM INSTR STACK\n         SLDL R0,16                RR AND RX CODE IN REG 0\n         XHEXO R0,EIWORK           CONVERT INSTR TO HEX (4 BYTES)\n         TM    ECSTINST,EISSINST   IS THIS AN SS INSTR ?\n         BNO   EINOTSS             BRANCH IF NOT\n         XHEXO R1,EIWORK+8         CONVERT INSTR TO HEX (LAST 2 BYTES)\nEINOTSS  EQU   *\n         LA    RWK1,EITRMSIN       GET @ OF HEX INSTR\n         BAL   R2,EIMOVINS         MOVE HEX INSTR INTO FORMAT\n         $PRNT EITRMSG,EITRMSGL,EICNTEXC  PRINT INSTR FOR TRACE AND BR X\n                                          OUT IF LINE COUNT EXCEEDED\n         B     EIINCPSW            RETURN TO MAIN PROGRAM LOOP\n*              WORK AREAS USED BY THE TRACE FACILITY\nEITRMSG  DC    C' TRACE-->   INSTR ADDR:'  TRACE MESSAGE\nEITRMSAD DC    8C' '               TRACE MESSAGE\n         DC    C'   INSTR:  '       TRACE MESSAGE\nEITRMSIN DC    14C' '              TRACE MESSAGE\nEITRMSGL EQU   *-EITRMSG           LENGTH OF THE TRACE MESSAGE\nEIWORK   DC    16C' '              WORK AREA\nEIBLANKS DC    10C' '              BLANKS USED IN TRACE\n         TITLE '*** EXECUT - RR PROCESSING ROUTINES'\n***********************************************************************\n*                                                                     *\n*              RR INSTRUCTION PROCESSING ROUTINES                     *\n*                                                                     *\n***********************************************************************\n         SPACE 5\n*        ********** NORMAL RR INSTRUCTION PROCESSING **********\n*\n*              2 ENTRIES TO SEQUENCE -->\n*              LR   SEPARATE SINCE CURRENT CC NOT CHANGED\n*              NR,CLR,OR,XR,CR,AR,SR,ALR,SLR,LPR,LNR,LCR,LTR    NORMAL\n         SPACE 1\nEILR     EQU   *                   LOAD REGISTER INST\n         ST    R10,ECREGS(R7)      LOAD R1 WITH VALUE FROM R2\n         B     EIFINRR             RETURN FOR NEXT INSTR\n         SPACE 1\nEINORMRR EQU   *                   NORMAL RR INSTRS\n         STC   ROP,EIQRR           PLACE ACTUAL OPCODE INTO INSTR\nEIQRR    LR    $+R8,R10            EXECUTE RIGHT INSTRUCTION           X\n                                   ***** OPCODE MOVED IN *****\n         ST    R8,ECREGS(R7)       SAVE RESULT IN OPERAND LOCATION\n         BAL   RCC,EIFINRR         GET CC, RETURN FOR NEXT INSTR\n         SPACE 2\n*              THIS SECTION PROCESSES THE BALR INSTRUCTION\nEIBALR   EQU   *\n         LR    RWK1,RIA            COPY ADDR NEXT INSTR OVER\n         N     RCC,=XL4'3F000000'  LEAVE ONLY CC-PM IN RCC\n         AL    RCC,=XL4'40000000'  ADD ILC INTO PSW BEING BUILT\n         ALR   RWK1,RCC            NOW HAVE ILC-CC-PM-IA FIELDS\n         ST    RWK1,ECREGS(R7)     FAKE REGISTER GETS BUILT PSW\n         LTR   R9,R9               TEST FOR NO BRANCHING R2 = 0\n         BZ    EIFINRR             NO BRANCH TREAT AS REG RR GET NEXT  X\n                                                 INSTRUCTION\n         LR    RIA,R10             PUT BRANCH ADDRESS IN PROPER REG\n         B     EIFINB              PROCESS SUCCESSFUL BRANCH\n         SPACE 2\n*              BRANCH ON COUNT REGISTER  (BCTR)\nEIBCTR   EQU   *\n         BCTR  R8,0                DECREMENT VALUE IN FAKE R1\n         ST    R8,ECREGS(R7)       RESTORE VALUE TO FAKE REG\n         LTR   R9,R9               IS R2 = 0 ?\n         BZ    EIFINRR             IF ZERO, NO BRANCH\n         LTR   R8,R8               IS DECREMENTED VALUE = 0 ?\n         BZ    EIFINRR             IF ZERO, NO BRANCH\n         LR    RIA,R10             PUT BRANCH @ IN RIGHT REG\n         B     EIFINB              PROCESS SUCCESSFUL BRANCH\n         SPACE 2\n*              BRANCH ON CONDITION REGISTER (BCR)\nEIBCR    EQU   *\n         LTR   R9,R9               IS R2 = 0 ?\n         BZ    EIFINRR             IF ZERO, NO BRANCH\n         SLL   R7,2                GET MASK IN RIGHT SPOT\n         STC   R7,EIQBCR+1         STORE MASK INTO INSTR\n         LR    RWK1,RIA            COPY @ OF NEXT SEQ INSTR\n         LR    RIA,R10             PUT BRANCH ADDR IN RIGHT REG\n         SPM   RCC                 SET REAL CC = FAKE CC\nEIQBCR   BC    $,EIFINB            *** MASK STORED IN ***\n         LR    RIA,RWK1            RESTORE INSTR @ REG\n         B     EIFINRR             BRANCH FAILED\n         SPACE 1\n*              CHECK FOR FLOATING-POINT INSTR OR EXT FLOATING POINT\n         AIF   (&$FLOTEX).EIXFPRR  GO GENER CODE IF XFP IS OK\nEIXFPRR  EQU   EIOC1               NOTE XFP INVAL OP IF NOT ALLOWED\n         AIF   (&$FLOTE).EIFPRR    GO GENERATE IF FLOAT PNT INST OK\nEIFPRR   EQU   EIOC1               NOTE NOT ALLOWING FLOATINGS\n         AGO   .EIFPRR2\n.EIXFPRR ANOP\nEIXFPRR  EQU   *                   CODE FOR XFP SAME AS FOR REGULAR FP\n.EIFPRR  ANOP\n         SPACE 2\n*              RR FLOATING POINT INSTRUCTIONS EXECUTED\nEIFPRR   EQU   *                   FLOATING-PNT RR'S ENTER HERE\n         SPM   RCC                 SET OUR CC SAME AS USER'S\n         EX    R0,ECOP             EXECUTE ACTUAL INSTR FROM THE STACK\n         BAL   RCC,EIFINRR         GET CC AND RETURN FOR NEXT INSTR\n.EIFPRR2 ANOP\n         SPACE 2\n*              THE FOLLOWING CODE PROCESSES THE CLCL, MVCL\n*              INSTRUCTIONS\n*\n*              ADDRESS CHECKING CODE FOR CLCL AND MVCL\nEILONG   EQU   *\n         L     RWK0,ECREGS+4(R7)   GET LENGTH VALUE OF REG 2 PAIR 1\n         N     R8,EILONGMK         ZAP OUT UPPER BYTE OF ADDRESS\n         N     RWK0,EILONGMK       ZAP OUT UPPER BYTE OF LENGTH\n         BZ    EILONG1             IF LENGTH = 0 DON'T CHECK ADDRESS\n         MVC   EIWORK(1),EICTB3    STORE CONTROL BYTE IN WORK AREA\n         LR    RWK1,R8             COPY ADDRESS TO BE CHECKED\n         BAL   RLINK,EIMSFCHK      BRANCH TO ROUTINE CHECK FIRST @\n         SPACE 2\n*              FIRST ADDRESS IS OKAY ---  CHECK THE SECOND\nEILONG1  EQU   *\n         L     RWK0,ECREGS+4(R9)   GET VALUE (LENGTH) OF 2ND REG PAIR 2\n         N     R10,EILONGMK        ZAP OUT UPPER BYTE OF SECOND ADDRESS\n         N     RWK0,EILONGMK       ZAP OUT UPPER BYTE OF SECONG LENGTH\n         BZ    EILONG2             IF LENGTH 0 DON'T CHECK ADDRESS\n         IC    RWK1,EICTB3         GET CONTROL BYTE\n         SLL   RWK1,2              SHIFT BECAUSE WOKING ON SECOND OPRND\n         STC   RWK1,EIWORK         PUT TAB ENTRY IN INSUB WORK AREA\n         LR    RWK1,R10            PUT ADDR WHERE INSUB EXPECTS IT\n         BAL   RLINK,EIMSFCHK      BRANCH TO INSUB CHECK 2ND ADDRESS\n         SPACE 2\n*              BOTH ADDRESSES ARE OK  --- RELOCATE THEM AND PERFORM\n*              THE APPROPRIATE COMMAND\nEILONG2  EQU   *\n         ALR   R8,RMEM             RELOCATE 1ST ADDRESS TO REAL ADDRESS\n         ALR   R10,RMEM            RELOCATE 2ND ADDRESS TO ACTUAL\n         SPACE 2\n         AIF   (&$S370 NE 1).EILONG1    SKIP IF NOT ON REAL 370\n         STC   ROP,EIQLONG         STORE OPCODE IN INSTRUCTION\n         LR    RWK1,R9             SAVE SECOND OPERAND REG NUMBER\n         LR    RWK0,RMEM           SAVE RELOCATION REGISTER\n         L     R9,ECREGS+4(R7)     GET LENGTH OF FIRST OPERAND\n         L     R11,ECREGS+4(RWK1)  GET LENGTH OF SECOND OPERAND\nEIQLONG  CLCL  R8,R10              **** OPCODE MOVED IN DURING EXEC***\n         BALR  RCC,0               PICK UP THE CONDITION CODE\n         SLR   R8,RWK0             DE-RELOCATE FINAL ADDRESSES\n*              *** THE INSTRUCTIONS ON EITHER SIDE OF THIS COMMENT\n*              *** BLOCK ARE USING RWK0 INSTEAD OF RMEM DUE TO\n*              *** TEMPORARY REGISTER SHIFTING *****\n         SLR   R10,RWK0            DE-RELOCATE FINAL ADDRESSES\n         N     R8,EILONGMK         ZAP UPPER BYTE OF ADDRESS REG\n         N     R10,EILONGMK        ZAP UPPER BYTE OF ADDRESS REGISTER\n         ST    R8,ECREGS(R7)       PUT REGISTERS BACK INTO CORE\n         ST    R9,ECREGS+4(R7)     PUT REGISTERS BACK INTO CORE\n         ST    R10,ECREGS(RWK1)    PUT REGISTERS BACK INTO CORE\n         ST    R11,ECREGS+4(RWK1)  PUT REGISTERS BACK INTO CORE\n         LR    RMEM,RWK0           RELOAD RELOCATION REGISTER\n         B     EIFINRR            GET NEXT INSTR                PSU.\n         AGO   .EILONG2\n.EILONG1 ANOP\n         SPACE 2\n*              CHECK WHICH INSTRUCTION TO SIMULATE (MVCL OR CLCL)\n         LA    RWK14,1             SET UP INCREMENT REGISTER\n         IC    RWK1,ECREGS+4(R9)   GET PAD BYTE FROM INSTR\n         STC   RWK1,EIPAD          STORE PAD BYTE IN WORK AREA\n         L     RWK1,ECREGS+4(R7)   GET 1ST OPERAND LENGTH\n         L     R2,ECREGS+4(R9)     GET SECOND OPERAND LENGTH\n         N     RWK1,EILONGMK       ZAP OUT HIGH ORDER BYTE LENGTH 1\n         N     R2,EILONGMK         ZAP OUT HIGH ORDER BYTE LENGTH 2\n         CLI   ECOP,X'0E'          IS THIS AN MVCL COMMAND\n         BE    EIMVCL              IF SO BRANCH TO ROUTINE\n         SPACE 2\n*              CODE FOR THE CLCL COMMAND\nEICLCL   EQU   *\n         LTR   R2,R2               TEST SECOND LENGTH = 0?\n         BZ    EICLCL6             BRANCH IF SECOND LENGTH 0\n         LTR   RWK1,RWK1           TEST 1ST LENGTH = 0 ?\n         BZ    EICLCL2             YES, BRANCH TO USE PAD AND OPRND 2\nEICLCL1  EQU   *\n         CLC   0(1,R8),0(R10)      COMPARE A CHARACTER FROM EACH FIELD\n         BNE   EICLCL5             IF NOT EQUAL WE ARE DONE BRANCH\n         AR    R10,RWK14           INCREMENT POINTERS\n         AR    R8,RWK14            INCREMENT POINTERS\n         BCT   RWK1,EICLCL3        DECREMENT 1ST LENGTH - BRANCH ^= 0\n         B     EICLCL7             LENGTH = 0, BRANCH INTO PAD LOOP\nEICLCL2  EQU   *\n         CLC   EIPAD(1),0(R10)     COMPARE PAD TO OPERAND 2\n         BNE   EICLCL5             IF NOT EQUAL WE ARE DONE -- BRANCH\n         AR    R10,RWK14           INCREMENT OPERAND 2 POINTER\nEICLCL7  EQU   *\n         BCT   R2,EICLCL2          DECREMENT 2ND COUNT BR IF ^= 0\n         B     EICLCL5             IF LENGTH = 0 OPRNDS = WE'RE DONE\nEICLCL3  EQU   *\n         BCT   R2,EICLCL1          DECREMENT 2ND LENGTH BR IF ^=0\nEICLCL4  EQU   *\n         CLC   0(1,R8),EIPAD       COMPARE FIRST OPERAND AND PAD CHAR\n         BNE   EICLCL5             IF NOT = WE ARE DONE BRANCH\n         AR    R8,RWK14            INCREMENT POINTER\n         BCT   RWK1,EICLCL4        DECREMENT LENGTH, BRANCH IF ^= 0\nEICLCL5  EQU   *\n         BAL   RCC,EILONG5         CAPTURE CONDITION CODE AND RETURN\nEICLCL6  EQU   *\n         LTR   RWK1,RWK1           FIRST LENGTH = 0?\n         BNZ   EICLCL4             NO, USE 1ST OPRND AND PAD\n         BAL   RCC,EILONG5         GET CC (=0) AND RETURN\n         SPACE 2\n*              CODE FOR THE MVCL COMMAND\nEIMVCL   EQU   *\n         LR    RWK0,RWK1           ASSUME FIRST LENGTH SMALLEST\n         CR    RWK1,R2             COMPARE THE LENGTHS\n         BALR  RCC,0               CAPTURE THE CC\n         BL    *+6                 IF 1ST LENGTH LOWER, BRANCH\n         LR    RWK0,R2             2ND LENGTH MUST BE SMALLER\n         LTR   RWK0,RWK0           IS SMALLEST LENGTH = 0?\n         BZ    EIMVCL3             IF SMALLER = 0, BRANCH\n         SPACE 2\n*              FOLLOWING CODE CHECKS FOR DESTRUCTIVE OVERLAP\n         CR    R8,R10              IS FIRST FIELD AFTER 2ND\n         BNH   EIMVCL1             IF NO OVERLAP, BRANCH\n         LR    RWK14,R10           COPY OVER 2ND ADDRESS\n         LA    RWK14,0(R2,RMEM)    COMPUTE HIGHEST @, RELOCATED + 1\n         BCTR  RWK14,0             COMPUTE HIGHEST ADDRESS\n         CR    R8,RWK14            IS 1ST FIELD AFTER END OF SECOND\n         BNL   EIMVCL1             YES -- NO OVERLAP, SO BRANCH\n         TM    *+1,1               SET CC = 3\n         BAL   RCC,EILONG5         GET CC AND RETURN\n         SPACE 2\nEIMVCL1  EQU   *\n         SR    RWK1,RWK0           DECREMENT LENGTH BY SMALLEST\n         SR    R2,RWK0             DECREMENT LENGTH BY SMALLEST\n         LA    RWK14,1             LOAD INCREMENT REGISTER\nEIMVCL2  EQU   *\n         MVC   0(1,R8),0(R10)      MOVE 1 BYTE !!!!!!\n         AR    R8,RWK14            INCREMENT POINTER BY 1\n         AR    R10,RWK14           INCREMENT POINTER BY 1\n         BCT   RWK0,EIMVCL2        DECREMENT LENGTH, ^= 0 BRANCH\nEIMVCL3  EQU   *\n         LTR   RWK1,RWK1           DO WE NEED PADDING\n         BZ    EILONG5             NO --- DONE, SO BRANCH\nEIMVCL4  MVI   0(R8),$             MOVE PAD TO FIRST OPERAND\n         AR    R8,RWK14            INCREMENT POINTER BY 1\n         BCT   RWK1,EIMVCL4        DECREMENT LENGTH, ^= 0 BRANCH\n         SPACE 2\nEILONG5  EQU   *\n         LA    RWK14,ECREGS(R7)    GET ADDRESS OF 1ST REG PAIR\n         XC    5(3,RWK14),5(RWK14) ZAP LOWER PART OF LENGTH IN CORE\n         O     RWK1,4(,RWK14)      PUT UPPER BYTE BACK INTO USER REG\n         LA    RWK14,ECREGS(R9)    GET ADDR OF SECOND REGISTER PAIR\n         XC    5(3,RWK14),5(RWK14) ZAP LOWER PART OF LENGTH IN CORE\n         O     R2,4(,R2)           PUT UPPER BYTE BACK INTO REGISTER\n*              OPERATION COMPLETE ----- RESTORE REGISTERS AND RETURN\n         SLR   R8,RMEM             DE-RELOCATE FINAL ADDRESSES\n         SLR   R10,RMEM            DE-RELOCATE FINAL ADDRESSES\n         N     R8,EILONGMK         ZAP UPPER BYTES OF ADDRESS REGS\n         N     R10,EILONGMK        ZAP UPPER BYTES OF ADDRESS REGS\n         ST    R8,ECREGS(R7)       PUT REGISTERS BACK INTO CORE\n         ST    RWK1,ECREGS+4(R7)   PUT REGISTERS BACK INTO CORE\n         ST    R10,ECREGS(R9)      PUT REGISTERS BACK INTO CORE\n         ST    R2,ECREGS+4(R9)     PUT REGISTERS BACK INTO CORE\n         SR    R2,R2               RESTORE R2 AS A BYTE REGISTER\n         B     EIFINRR            RETURN FOR NEXT INSTR.        CEH\nEIPAD    EQU   EIMVCL4+1           MVCL/CLCL PAD BYTE IS MOVED HERE\n.EILONG2 ANOP\nEILONGMK DC    0F'0',XL4'00FFFFFF' USED TO CLEAR UPPER BYTE OF REGS\n         SPACE 2\n*              THE FOLLOWING CODE PROCESSES SET PROGRAM MASK\nEISPM    EQU   *\n         L     RCC,ECREGS(R7)      PLACE SPECIFIED REG INTO CC REG\n         SPM   RCC                 SET REAL CC-PM TO FAKE CC-PM\n         B     EIFINRR             RETURN FOR NEXT INSTRUCTION\n         SPACE 1\n*              THESE TWO PRIVILEGED INSTRUCTIONS ARE NOT IMPLEMENTED\n*               AT THE PRESENT TIME.  THE HOOKS ARE PROVIDED HOWEVER,\n*              IF IT SHOULD BECOME POSSIBLE TO IMPLEMENT THEM IN THE\n*              FUTURE\nEISSK    EQU   EIOC2\nEIISK    EQU   EIOC2\n         SPACE 2\n*              THE FOLLOWING CODE PROCESSES THE SVC INSTRUCTION\n*              CONTROL IS PASSED HERE FROM THE MAIN DECODONG LOOP\n*              WHEN AN SVC OPCODE IS ENCOUNTERED.  AT THIS POINT\n*              REGISTER 7 CONTAINS THE SECOND BYTE OF THE INSTRUCTION\n*              AND REGISTER ROP CONTAINS THE INSTRUCTION OPCODE.  THIS\n*              INSTRUCTIONS IS PRESENTLY FLAGGED AS AN OC2 EXCEPTION.\n*                 IN THE FUTURE, CODE MAY BE PLACED HERE TO ACTUALLY\n*              PERFORM OR SIMULATE THE SCV.  IT SHOULD BE NOTED THAT\n*              REGISTERS RWK0, RWK1, R8, R9, R10 AND R14 ARE AVAILABLE\n*              FOR USE HERE.  R2 CAN ALSO BE USED AS A BYTE REGISTER OR\n*              RESTORED TO A BYTE REGISTER IF USED FOR ANOTHER PURPOSE.\n*              NO OTHER REGISTERS SHOULD BE USED HERE.\n*                FOLLOWING ANY FUTURE SVC PROCESSING, CONTROL MUST BE\n*              PASSED TO LABEL EIFINRR TO FETCH AND PROCESS THE NEXT\n*              INSTRUCTION.\n         SPACE 2\nEISVC    EQU   EIOC2\n         SPACE 2\n*              THIS CODE IS USED TO PERFORM THE MR AND DR INSTRS\nEIMRDR   EQU   *\n         STC   ROP,EIQMRDR         STORE PROPER OPCODE IN INSTRUCTION\n         LA    RWK1,ECREGS(R7)     GET ADDRESS OF FAKE REGISTER PAIR\n         L     R9,ECREGS+4(R7)     GET CONTENTS OF SECOND REG OF PAIR\nEIQMRDR  MR    $+R8,R10            ****OPCODE MOVED IN DURING EXEC****\n         STM   R8,R9,0(RWK1)       STORE CHANGED REGS INTO FAKE REGS\n         B     EIFINRR             BRANCH AND RETURN FOR NEXT INSTR\n         TITLE '*** EXECUT - RX PROCESSING ROUTINES'\n***********************************************************************\n*                                                                     *\n*              RX TYPE INSTRUCTION INTERPRETING SECTION               *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*              RX NORMAL PROCESSING                                   *\n*              (IC,CH,AH,SH,MH,N,CL,O,X,C,A,S,AL,SL,L,LH,CVB)         *\nEINORMRX EQU   *\n         STC   ROP,EINRMRX         MOVE PROPER OP CODE TO INSTRUCTION\n         SPM   RCC                 SET OUR CONDITION CODE TO USERS\nEINRMRX  IC    $+R8,0(RAD1)        ** PROPER OP CODE WILL BE MOVED IN**\n         ST    R8,ECREGS(R7)       STORE RESULT IN PROPER USER REGISTER\n         BAL   RCC,EIFIN           GET CC AND RETURN FOR NEXT INSTR\n         SPACE 2\n*              THIS SECTION PROCESSES THE BAL INSTRUCTION\nEIBAL    EQU   *\n         L     RWK1,EIRIA          GET @ OF NEXT SEQUENTIAL INSTR\n         N     RCC,=XL4'3F000000'  LEAVE ONLY CC-PM IN RCC\n         AL    RCC,=XL4'80000000'  ADD ILC TO PSW BEING BUILT\n         ALR   RWK1,RCC            NOW HAVE ILC-CC-PM-IA FIELDS\n         ST    RWK1,ECREGS(R7)     FAKE REGISTER GETS BUILT PSW\n*              ** NOTE ** RAD1 HAS BRANCH ADDRESS VALUE\n         B     EIFINB              PROCESS SUCCESSFUL BRANCH INSTRS\n         SPACE 2\n*              BRANCH ON COUNT (BCT)\nEIBCT    EQU   *\n         BCTR  R8,0                DECREMENT VALUE IN REG\n         ST    R8,ECREGS(R7)       STORE DECREMENTED VALUE IN FAKE REG\n         LTR   R8,R8               VALUE = 0 ?\n         BNZ   EIFINB              IF NOT ZERO, SUCCESSFUL BRANCH\n         B     EIFIN               BRANCH FAILED, GET NEXT INSTR\n         SPACE 2\n*              BRANCH ON CONDITION (BC)\nEIBC     EQU   *\n         SLL   R7,2                GET MASK IN RIGHT SPOT\n         STC   R7,EIQBC+1          STORE MASK INTO INSTR\n         SPM   RCC                 REAL CC = FAKE CC\nEIQBC    BC    $,EIFINB            *** MASK STORED IN ***\n         B     EIFIN               BRANCH FAILED\n         SPACE 2\n*              PROCESS THE LA INSTRUCTION (LOAD ADDRESS)\nEILA     EQU   *\n         SLR   RAD1,RMEM           DE-RELOCATE ADDRESS FOR USER\n         ST    RAD1,ECREGS(R7)     STORE RESULT IN FAKE REG\n         B     EIFIN               BRANCH TO GET NEXT INSTR\n         SPACE 2\n*              INTERPRETATION OF THE EXECUTE INSTRUCTION (EX)\nEIEX     EQU   *\n         CLI   0(RAD1),X'44'       MAKE SURE NOT AN EXECUTE\n         BE    EIOC3               EXECUTE INTERRUPT\n*              FETCH INSTRUCTION AND PUT IN STACK\n         L     RSTK,ECSTLINK       GET @ OF NEXT STACK SLOT\n         ST    RCC,ECSTCCPM        SAVE CC AND PROG MASK IN STACK\n         MVC   ECSTINST,0(RAD1)    GET UP TO 6 BYTES OF INSTR\n         IC    ROP,ECOP            GET OPCODE INTO REGISTER\n         SR    RAD1,RMEM           DE-RELOCATE INSTR ADDR\n         ST    RAD1,ECSTIADD       SAVE INSTR ADDR FOR DUMP\n         MVC   EIINCPSW+2(4),EIEXMBR  ** CHANGE INSTR IN MAIN LOOP TO  X\n                                   RETURN TO EXECUTE CODE **\n*              OR BYTE INTO INSTR AS NEEDED - THEN BRANCH TO PROCESS\n         LTR   R7,R7               CHECK IF BYTE SHOULD BE OR'ED IN\n         BZ    EIEXPEN             BRANCH TO PROCESS IF NOT\n         LA    R9,ECREGS+3(R7)     GET @ OF BYTE TO BE OR'ED IN\n         OC    ECR1R2(1),0(R9)     OR BYTE INTO INSTRUCTION (IN STACK)\n         B     EIEXPEN             BRANCH TO PROCESS INSTR\n*              ***** RETURNED HERE TO FIX UP THE ADDRESS OF THE NEXT\n*              ***** INSTRUCTION (AFTER THE THE INSTR EXECUTED BY THE\n*              ***** EX INSTR)\nEIEXRET  EQU   *\n         L     RIA,EIRIA           RELOAD CORRECT NEXT INSTR @\n         MVC   EIINCPSW+2(4),EIEXRSTR  RESTORE IC INSTR IN MAIN LOOP\n         B     EITSTMSK            BRANCH TO CONTINUE PROCESSING\n*              THE FOLLOWING INSTRUCTIONS ARE MOVED INTO THE MAIN LOOP\n*              TO MODIFY OR RESTORE CODE AS NEEDED BY THE EX INSTR\nEIEXMBR  B     EIEXRET\nEIEXRSTR IC    R2,EICTB2\n         SPACE 2\n*              THIS CODE IS USED TO PERFORM THE M AND D COMMANDS\nEIMD     EQU   *\n         STC   ROP,EIQMD           STORE PROPER OPCODE IN INSTRUCTION\n         LA    RWK1,ECREGS(R7)     GET ADDRESS OF FAKE REGISTER PAIR\n         L     R9,ECREGS+4(R7)     GET CONTENTS OF SECOND REG OF PAIR\nEIQMD    M     $+R8,0(RAD1)        ****OPCODE MOVED DURING EXEC ****\n         STM   R8,R9,0(RWK1)       RESTORE CHANGED REGS INTO FAKE REGS\n         B     EIFIN               BRANCH AND RETURN FOR NEXT INSTR\n         SPACE 2\n*              THIS SECTION PROCESSES RX STORE OPERATIONS\n*              (NO CC SETTING)   (STH,CVD,STC,ST)\nEISTORS  EQU   *\n         STC   ROP,EIQSTORS        STORE OPCODE IN INSTRUCTION\nEIQSTORS ST    $+R8,0(RAD1)        **** OPCODE CHANGED DURING EXEC ****\n         AIF   (&$S370 NE 2).EISTORS    SKIP IF ON S370\n         BZ    EIFIN               IF NOT FAKING ALIGNMENT RETURN\n         MVC   0(8,RWK14),EIDUBLWD PUT ALTERED CORE BACK IN PLACE\n.EISTORS ANOP\n         B     EIFIN               BRANCH BACK FOR NEXT INSTRUCTION\n         SPACE 2\n*              THIS CODE PROCESSES FLOATING POINT RX INSTRUCTIONS\n         AIF   (&$FLOTEX).EIXFPRX  SKIP IF WE HAVE EXTENDED FP\nEIXFPRX  EQU   EIOC1               NOTE XFP INSTRS NOT ALLOWED\n         AIF   (&$FLOTE).EIFPRX    GO GEN IF FLOATINGS ARE ALLOWED\nEIFPRX   EQU   EIOC1               NOTE FLOATINGS NOT ALLOWED\nEIFPRXST EQU   EIOC1               NOTE FLOATINGS NOT ALLOWED\n         AGO   .EIFPRX2            SKIP OVER GENERATION\n.EIXFPRX ANOP\nEIXFPRX  EQU   *\n.EIFPRX   ANOP\n         SPACE 1\n*              THE FLOATING POINT RX INSTRUCTIONS\nEIFPRX   EQU   *\n         STC   ROP,EIQFPRX         STORE OPCODE IN INSTRUCTION\n         SLL   R7,2                GET R1 FIELD BACK INTO PLACE\n         STC   R7,EIQFPRX+1        STORE R1 FIELD INTO INSTRUCTION ALSO\n         SPM   RCC                 SET THE CONDITION CODE\nEIQFPRX  STD   $,0(,RAD1)          ** OPCODE AND R1 FIELDS STORED IN **\n         BAL   RCC,EIFIN           GET CC AND RETURN FOR NEXT INSTR\n         SPACE 2\n*        CODE FOR FLOATING POINT STORES\n         AIF   (&$S370 EQ 2).EIFPRX1   SKIP IF ON A 360\nEIFPRXST EQU   EIFPRX              CODE FOR STORES SAME AS OTHERS\n         AGO   .EIFPRX2            SKIP AROUND CODE GENERATION\n.EIFPRX1 ANOP\n         SPACE 2\n*              CODE FOR FLOATING POINT STORES WHEN FAKING ALIGNMENT\nEIFPRXST EQU   *\n         STC   ROP,EIQFPRXS        STORE OPCODE INTO INSTRUCTION\n         SLL   R7,2                GET R1 FIELD BACK\n         STC   R7,EIQFPRXS+1       STORE R1 FIELD INTO INSTRUCTION ALSO\nEIQFPRXS STD   $,0(,RAD1)          **OPCODE AND R1 FIELDS STORED IN ***\n         BZ    EIFIN               IN NO ALIGNMENT CHECKING, RETURN\n         MVC   0(8,RWK14),EIDUBLWD PUT ALTERED CORE BACK IN PLACE\n         B     EIFIN               RETURN\n.EIFPRX2 ANOP\n         SPACE 2\n         AIF   (NOT &$XIOS).EINOXD SKIP IF NO XMACROS\n*                     XDECO - EXTENDED DECIMAL OUTPUT INSTRUCTION     *\n*              SPECIAL RX INSTRUCTION CONVERTS REGISTER VALUE TO      *\n*              EDITED 12 - BYTE DECIMAL FIELD.  (X'52' OPCODE)        *\n         SPACE 1\nEIXDECO  EQU   *\n         XDECO R8,0(RAD1)          CONVERT AND MOVE THE VALUE\n         B     EIFIN               RETURN FOR THE NEXT INSTR\n         SPACE 2\n*                  XDECI - EXTENDED DECIMAL INPUT INSTRUCTION         *\n*              SPECIAL INPUT CONVERTER, SCANS 1 - 9 DIGITS, SIGNED    *\n*              UNSIGNED DECIMAL NUMBERS WITH ANY # OF PRECEDING       *\n*              BLANKS.  SETS CC TO 0,1,2 ACCORDING TO VALUE OF        *\n*              RESULT.  CC = ; IF > 9 DIGITS OR 1ST CHARACTER         *\n*              NOT +, -, DIGIT, OR + OR - WITHOUT DIGIT FOLLOWING     *\n*              OPCODE IS X'53' WITH THE RX FORMAT                     *\n         SPACE 1\nEIXDECI  EQU   *\n         XDECI RWK0,0(RAD1)        CONVERT AND SCAN THE VALUE\n         BALR  RCC,0               SAVE THE CONDITION CODE\n         BO    *+8                 SKIP STORE IF VALUE WAS BAD\n         ST    RWK0,ECREGS(R7)     SAVE THE CONVERTED VALUE IF OK\n         SR    RWK1,RMEM           DE-RELOCATE THE SCAN PTR VALUE\n         ST    R1,ECREG1           PUT SCAN PTR IN USER REG 1\n         B     EIFIN               RETURN FOR THE NEXT INSTR\n.EINOXD  ANOP\n         AIF   (NOT &$XIOS).EICONT SKIP IF NO XMACROS\n         AIF   (NOT &$HEXI).EINOHXI   SKIP IF NO XHEXI\n         SPACE 2\n*                  XHEXI - EXTENDED HEXADECIMAL INPUT INSTRUCTION     *\n*              SPECIAL INPUT MACRO, SCANS 1-8 DIGITS . SKIPS LEADING  *\n*              BLANKS.  SETS CONDITION CODE TO 3 IF ILLEGAL HEX       *\n*              CHARACTER IS FOUND.  IF GREATER THAN 8 DIGITS FOUND R1 *\n*              POINTS TO THE 9TH ELSE R1 POINTS TO FIRST NON-HEX      *\n*              IN STRING.                                             *\n*              OPCODE IS X'61' IN THE RX FORMAT.                      *\n         SPACE 1\nEIXHEXI  EQU   *\n         XHEXI RWK0,0(RAD1)        CONVERT AND SCAN VALUE\n         BALR  RCC,0               SAVE THE CONDITION CODE\n         BO    *+8                 SKIP STORE IF VALUE WAS BAD\n         ST    RWK0,ECREGS(R7)     STORE CONVERTED VLUE IF OK\n         SR    RWK1,RMEM           DE-RELOCATE SCAN POINTER VALUE\n         ST    RWK1,ECREG1         SAVE SCAN POINTER IN USER REG 1\n         B     EIFIN               RETURN FOR THE NEXT INSTRUCTION\n         AGO   .EICKHXO            CHECK IF XHEXO ALLOWED\n.EINOHXI ANOP\nEIXHEXI  EQU   EIOC1               NOTE XHEXI NOT ALLOWED -- INVALID OP\n.EICKHXO AIF   (NOT &$HEXO).EINOHXO   SKIP IF XHEXO NOT ALLOWED\n         SPACE 2\n*                  XHEXO - EXTENDED HEXADECIMAL OUTPUT MACRO          *\n*              SPECIAL RX INSTRUCTION CONVERTS REGISTER VALUE TO      *\n*              OUTPUT 8 BYTE FORM.  OPCODE IS X'62'.                  *\n         SPACE 2\nEIXHEXO  EQU   *\n         XHEXO R8,0(RAD1)          CONVERT VALUE AND MOVE TO USER AREA\n         B     EIFIN               RETURN FOR THE NEXT INSTRUCTION\n         AGO   .EICONT\n.EINOHXO ANOP\nEIXHEXO  EQU   EIOC1               NOTE XHEXO INVALID OPCODE\n.EICONT  ANOP\n         TITLE '*** EXECUT - SI PROCESSING ROUTINES'\n***********************************************************************\n*                                                                     *\n*              SI  TYPE INSTRUCTION INTERPRETING SECTION              *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*              SI NORMAL PROCESSING                                   *\n*              (TM,MVI,NI,CLI,OI,XI  -  OP D(B),I2)                   *\n         SPACE 2\nEINORMSI EQU   *\n         STC   ROP,EIQSI           MOVE OPCODE INTO INSTRUCTION\n         STC   R7,EIQSI+1          MOVE I2 FIELD INTO INSTRUCTION\n         SPM   RCC                 SET REAL COND-CODE = TO FAKE ONE\nEIQSI    TM    0(RAD1),$           *** OPCODE AND I2 WILL BE MOVED IN**\n         BAL   RCC,EIFIN           CAPTURE CC, RETURN FOR NEXT INSTR\n         SPACE 1\n*              DIAG - PSEUDO SI INSTRUCTION USED FOR DEBUGGING PURPOSE\nEIDIAG   EQU   *\n         MVC   ECFLAG2,ECI2        SUPPLY CONTROL FLAG TO BYTE\n         B     EIFIN               RETURN FOR NEXT INSTRUCTION\n         SPACE 2\n*              THE FOLLOWING ARE THE GROUP OF S360 / S370 PRIVILEGED\n*              OPERATIONS.  CONTROL IS PASSED HERE FROM THE MAIN\n*              DECODING LOOP WITH ROP CONTAINING THE OPCODE AND R7\n*              CONTAINING THE FIRST REGISTER OR IMMEDIATE FIELD.  AT\n*              THE PRESENT TIME ALL OF THESE INSTRUCTIONS ARE FLAGGED\n*              WITH OC2 EXCEPTIONS.  THE HOOKS ARE ALL PROVIDED HOWEVER\n*              FOR THEIR FUTURE IMPLEMENTATION.\n         SPACE 2\nEILCTL   EQU   EIOC2               NO PRIVILEGED OPS ALLOWED AT PRESENT\nEISTCTL  EQU   EIOC2               NO PRIVILEGED OPS ALLOWED AT PRESENT\nEIP370   EQU   EIOC2               NO PRIVILEGED OPS ALLOWED AT PRESENT\nEISIO    EQU   EIOC2               NO PRIVILEGED OPS ALLOWED AT PRESENT\nEITIO    EQU   EIOC2               NO PRIVILEGED OPS ALLOWED AT PRESENT\nEIHIO    EQU   EIOC2               NO PRIVILEGED OPS ALLOWED AT PRESENT\nEISSM    EQU   EIOC2               NO PRIVILEGED OPS ALLOWED AT PRESENT\nEITCH    EQU   EIOC2               NO PRIVILEGED OPS ALLOWED AT PRESENT\nEILPSW   EQU   EIOC2               NO PRIVILEGED OPS ALLOWED AT PRESENT\nEIWRD    EQU   EIOC2               NO PRIVILEGED OPS ALLOWED AT PRESENT\nEIRDD    EQU   EIOC2               NO PRIVILEGED OPS ALLOWED AT PRESENT\n         SPACE 2\n         AIF   (&$REPL GT 0).EINREPO   SKIP IF REPL OPTION ALLOWED\nEIXREPL  EQU   EIOC1               NO REPLACEMENT:  MAKE ILLEGAL OP\n.EINREPO AIF   (&$REPL EQ 0).EINREPL   SKIP IF NO REPLACEMENT ALLOWED\n         SPACE 2\n*              CODE FOR THE XREPL COMMAND\nEIXREPL  EQU   *\n         CLI   ECI2,0              WAS IT A SET RFLAG TYPE XREPL\n         BH    EIXREPL1            NO, SKIP TO NEXT TYPE\n         MVC   ECRFLAG,0(RAD1)     SET RFLAG FROM USER LOCATION\n         B     EIFIN               RETURN FOR THE NEXT INSTRUCTION\n         SPACE 1\nEIXREPL1 CLI   ECI2,1              WAS IT A FETCH RFLAG TYPE\n         BH    EIXREPL2            O, SKIP TO NEXT TYPE\n         MVC   0(L'ECRFLAG,RAD1),ECRFLAG   FETCH THE FLAG TO USER AREA\n         B     EIFIN               RETURN FOR THE NEXT INSTR\n         SPACE 1\nEIXREPL2 CLI   ECI2,2              WAS IT INSTRUCTION COUNT\n         BH    EIXREPL3            NO, GO ON TO NEXT\n         MVC   0(4,RAD1),ECILIMT   MOVE TEMP INSTR COUNT OVER\n         B     EIFIN               RETURN FOR THE NEXT INSTRUCTION\nEIXREPL3 EQU   EIFIN               ILLEGAL I2 FIELD IGNORE AND RETURN\n.EINREPL ANOP\n         TITLE '*** EXECUT - RS PROCESSING ROUTINES'\n***********************************************************************\n*                                                                     *\n*              RS INSTRUCTION PROCESSING ROUTINES                     *\n*                                                                     *\n***********************************************************************\n         SPACE 5\n*              BRANCH ON INDEX (BXH,BXLE)\nEIRSBX   EQU   *\n         STC   ROP,EIQRSBX         STORE OPCODE INTO INSTRUCTION\n         L     RWK1,ECREGS+4(R9)   GET NEXT REGISTER BEYOND R3\n         LR    RWK0,R10            COPY R3 VALUE IN EXPECTED REGISTER\n         TM    ECR1R3,X'1'         WAS REGISTER ODD\n         BZ    EIQRSBX             IF EVEN REG,SET UP OK SKIP NEXT INST\n         LR    RWK1,RWK0           R3 WAS ODD SO USE SAME VALUE\nEIQRSBX  BXH   R8,RWK0,EIRSBX1     **CHANGED TO EITHER BXH-BXLE *******\n         ST    R8,ECREGS(R7)       BRANCH FAILED BUT STORE REG BACK\n         B     EIFIN               RETURN FOR NEXT INSTR\nEIRSBX1  ST    R8,ECREGS(R7)       BRANCH SUCCESSFULL BUT RESTORE REG\n         B     EIFINB              RETURN TO BR'D TO INSTR\n         SPACE 2\n*              LOAD & STORE MULTIPLE (LM,STM) *CODE MAY NOT BE OBVIOUS\nEILMSTM  EQU   *\n         AIF   (&$S370 NE 2).EILMSTM     CHECK IF NOT ON A 370\n         TM    ECPRFLG2,ECALNCHK   SHOULD ALIGNMENT BE CHECKED\n         BZ    *+8                 NO ALIGNMENT CHECK BRANCH AROUND\n         L     R0,0(RAD1)          QUICK CHECK FOR FULL WORD ALIGNMENT\n.EILMSTM ANOP\n         SLR   RAD1,RMEM           DE-RELOCATE THE ADDRESS\n         LA    RWK0,4(R9)          OBTAIN PART 1 OF LENGTH VALUE\n         LR    RWK1,RAD1           PUT ADDR TO BE CHECKED WHERE EXPECT\n         CR    R7,R9               IS R1 FIELD <= R3 FIELD\n         BNH   EILMSTM1            SKIP OVER IF EASY CASE (R1<R3)\n         SPACE 1\n         LR    R8,RWK0             R8 NOW = 2ND OPER REG VALUE +4\n         LA    RWK0,64             OBTAIN VALUE\n         SR    RWK0,R7             R0 = 64 - 1ST REG NUMBER\n         LR    R2,RWK0             SAVE LENGTH 2\n         AR    RWK0,R8             GET THE TOTAL LENGTH\n         B     EILMSTM2            HAVE LENGTHS IN PROPER PLACE\nEILMSTM1 EQU   *\n         SR    RWK0,R7             RWK0 =(2ND REG)-(1ST REG)+4 1ST ONLY\n         LR    R2,RWK0             PUT 1ST LENGTH WHERE EXPECTED\nEILMSTM2 BAL   RLINK,EIMSFCHK      CHECK FOR PROTECTION VIOLATION\n         ALR   RAD1,RMEM           RELOCATE ADDR TO REAL CORE ADDR\n         LA    R10,ECREGS(R7)      ADDR OF 1ST (OR ONLY) REG SEGMENT\n         SR    RWK1,RWK1           CLEAR FOR USE AS AN INDEX\n         CLI   ECOP,X'90'          WAS INSTRUCTION STM\n         BE    *+8                 YES WAS STM, SO RWK1 SET RIGHT\n         LA    RWK1,6              LM- SET FOR EXECUT INDEX\n         SPACE 1\n         BCTR  R2,0                DECREMENT LENGTH FOR SS MVC\n         EX    R2,EIQLMSTM(RWK1)   EXECUTE MVC IN CORRECT DIRECTION\n         CR    R7,R9               WAS R1 <= R3 FIELD\n         BNH   EIFIN               RETURN IF NO MORE TO DO\n         SPACE 1\n         LA    RAD1,1(R2,RAD1)     2ND CORE SEGMENT ADDRESS\n         LA    R10,ECREGS          ADDR OF 2ND REGISTER SECTION FAKE R0\n         BCTR  R8,0                DECREMENT TO PLEASE MVC\n         EX    R8,EIQLMSTM(RWK1)   EXECUTE PROPER MVC INSTR\n         B     EIFIN               RETURN FOR NEXT INSTR\n         SPACE 1\nEIQLMSTM MVC   0($,RAD1),0(R10)    MVC FOR STM - MEMORY <---- REGISTERS\n         MVC   0($,R10),0(RAD1)    USED FOR LM - REGISTERS <---- MEMORY\n         SPACE 2\n*              CODE FOR ALL SHIFT INSTRUCTIONS ALL ENTER AT SAME PLACE\n*              SHIFT DOUBLES ENTER SAME AS SHIFT SINGLES\nEISHIFT  EQU   *\n         STC   ROP,EIQSHIF         PLACE SHIFT OPCODEINTO INSTRUCTION\n         L     R9,ECREGS+4(R7)     GET SECOND REG IN CASE OF DOUBLE\n         LA    RWK1,ECREGS(R7)     GET USER REG ADDRESS FOR SHIFT INST\n         SPM   RCC                 SET REAL COND CODE = FAKE ONE\nEIQSHIF  SRL   $+R8,0(RAD1)        SHIFT ***CHANGED DURING EXEC****\n         STM   R8,R9,0(RWK1)       REPLACE THE REGISTER PAIR\n         BAL   RCC,EIFIN           CAPTURE CC, RETURN FOR NEXT INSTR\n         SPACE 2\n         AIF   (&$S370 NE 1).EIMASK2   SKIP IF DON'T HAVE S370 HARDWARE\n*              CODE FOR ICM, STCM, AND CLM INSTRUCTIONS ON S/370\nEIICM    EQU   *\nEISTCM   EQU   *\nEICLM    EQU   *\n         STC   ROP,EIQRS370        STORE OPCODE INTO INSTRUCTION\n         SRL   R9,2                TREATED AS RR X 4 MOVE MASK PROPER\n         SPM   RCC                 SET REAL CONDITION CODE TO FAKE ONE\n         EX    R9,EIQRS370         EXECUTE INSTR GIVING MASK\n         ST    R8,ECREGS(R7)       PUT REGISTER BACK IN CORE\n         BAL   RCC,EIFIN           GET COND CODE AND RETURN\nEIQRS370 ICM   R8,0,0(RAD1)        ***OPCODE CHANGED DURING EXECUTION**\n.EIMASK2 AIF   (&$S370 NE 2).EIMASK3   SKIP IF ON A 370\n*              CODE FOR STCM USING 360 HARDWARE\nEISTCM   EQU   *                   CODE FOR STCM COMMAND\n         BAL   RWK14,EIMASK        GO TO COMMON MASK CODE\n         MVC   0(1,RAD1),0(RWK1)   INSTRUCTION EXECUTED BY EXMASK\n         B     EIFIN               WHEN EIMASK RETURNS WE ARE DONE\n         SPACE 2\n*              CODE FOR ICM USING S/360 HARDWARE\nEIICM    EQU   *\n         BAL   RWK14,EIMASK        GO TO COMMON MASK CODE\n         MVC   0($,RWK1),0(RAD1)   INSTRUCTION EXECUTED BY EIMASK\n         SR    RAD1,R10            RAD1 = # OF BYTES MOVED INTO REG\n         BZ    EIICM               IF ZERO, CON CODE IS 0 QUIT\n         TM    0(R10),X'80'        CHECK FOR SIGN BIT ON\n         BO    EIICM2              IF ON, BRANCH TO SET CC TO -\n         BCTR  RAD1,0              GET LENGTH - 1\n         EX    RAD1,EIICM3         ITS + OR - SO COMARE TO ZERO\nEIICM1   BAL   RCC,EIFIN           GET COND CODE AND RETURN\nEIICM2   OI    *+1,1               SET COND COE TO -\n         BAL   RCC,EIFIN           GET COND CODE AND RETURN\nEIICM3   CLC   0(0,R10),=F'0'      INSTRUCTION TO COMPARE BYTES TO 0\n         SPACE 2\n*              CODE FOR CLM COMMAND UNDER S / 360 HARDWARE\nEICLM    EQU   *\n         MVI   EIMSKC,E*16         CHANGE BRANCH TO BE INSTR\n         BAL   RWK14,EIMASK        GO DO COMMON MASK CODE\n         CLC   0(1,RWK1),0(RAD1)   INSTRUCTION EXECUTED BY EIMASK\n         MVI   EIMSKC,X'F0'        RESTORE CHANGED BRANCH INSTRUCTION\n         BAL   RCC,EIFIN           CAPTURE CON CODE FROM EIMASK RETURN\n         SPACE 2\n*              COMMON CODE FOR ICM, STCM AND CLM ALL ON S/360 HARDWARE\nEIMASK   EQU   *\n         MVI   EIMSKC,X'F0'        MAKE SURE BRANCH IS B NOT BNE\n         LR    R10,RAD1            COPY ADDRESS FOR POSSIBLE LATER USE\n         SLL   R9,26               MOVE LEFT MOST MASK BIT TO SIGN POS\n         LA    RWK1,ECREGS-1(R7)   GET ADDRESS OF INCORE USER REGISTER\n         SPACE 2\nEIMSK1   LA    RWK1,1(,RWK1)       INCERMENT REGISTER POINTER\n         ALR   R9,R9               SHIFT MASK LEFT 1 BIT\n         BM    EIMSK1              NO CARRY NZ => MOVE TO DO NR\n         BZ    6(,RWK14)           IF 0, WE ARE ALL DONE RETURN\n         EX    0,0(,RWK14)         PERFORM SUPPLIED OPERATION\n         LA    RAD1,1(RAD1)        INCERMENT CORE AREA POINTER\nEIMSKC   EQU   *+1                 POSITION OF MASK CHANGED BY CLM\n         BC    $+15,EIMSK1         USUALLY BRANCH TO LOOP (BE FOR CLM)\n         B     6(,RWK14)           IF UNEQUAL COMPARE FOR CLM, RETURN\n.EIMASK3 ANOP\n         TITLE '*** EXECUT - SS PROCESSING ROUTINES'\n***********************************************************************\n*                                                                     *\n*              SS  TYPE  INTERPRETING  SECTION                        *\n*                                                                     *\n***********************************************************************\n         SPACE 5\n*              MOVES,TR,PACK,LOGICALS & DECIMALS  (DON'T CHANGE REGS)\nEIMOVES  EQU   *\nEILOGS   EQU   EIMOVES\nEIDECS   EQU   EIMOVES\n         SPM   RCC                 SET REAL CC = FAKE CC\nEIQSS    MVN   0($,RAD1),0(RAD2)   ** OPCODE & LENGTH(S) MOVED IN **\n         BAL   RCC,EIFIN           RETURN FOR NEXT INSTR\n         SPACE 2\n*              TRT AND EDMK - CHANGE CC & POSSIBLY REGS R1 & R2\nEITRT    EQU   *\nEIEDMK   EQU   EITRT\n         LM    R1,R2,ECREG1        GET FAKE R1 & R2\n         LA    R1,0(R1,RMEM)       CLEAR UPPER BYTE & RELOCATE\n         EX    0,EIQSS             EXECUTE TNE INSTRUCTION\n         BALR  RCC,0               SCOOP UP THE CC\n         SLR   R1,RMEM             CONVERT BACK TO FAKE ADDR\n         AIF   (&$S370 NE 1).EITRT1  SKIP IF NOT ON A REAL 370\n         ICM   R1,8,ECREG1         GET 1ST BYTE IF FAKE REG1\n         AGO   .EITRT2\n.EITRT1  ANOP\n         XC    ECREG1+1(3),ECREG1+1  CLEAR 3 BYTES OF FAKE REG1\n         O     R1,ECREG1           GET FAKE REG1 BACK TOGETHER\n.EITRT2  ANOP\n         STM   R1,R2,ECREG1        REPLACE FAKE REGS R1 & R2\n         SR    R2,R2               RECLEAR BYTE REG\n         B     EIFIN               RETURN FOR NEXT INSTR\n         SPACE 2\n*              CODE FOR THE SRP COMMAND (SHIFT AND ROUND)\nEISRP    EQU   *\n         SR    RAD2,RMEM           REMOVE RELOCATION DONE EARLIER\n         IC    R2,ECB2D2           GET B2 BASE REG\n         SRA   R2,4                REMOVE UNNEEDED BITS\n         AIF   (&$S370 NE 1).EISRP1  SKIP IF NOT ON A REAL 370\n         BZ    EIDECS              BRANCH TO EXECUTE THE INSTRUCTION\n         SLL   R2,2                B2 * 4 FOR INDEX\n         S     RAD2,ECREGS(R2)     DON'T WANT VALUE OF BASE REG\n         B     EIDECS              BRANCH TO EXECUTE THE INSTRUCTION\n         AGO   .EISRP2\n.EISRP1  ANOP\n         BZ    EISRPA              NO BASE REG ADDED IN, SKIP OVER\n         SLL   R2,2                B2 * 4 FOR INDEX\n         S     RAD2,ECREGS(R2)     DON'T WANT VALUE OF BASE REG\nEISRPA   EQU   *\n         LR    R8,R7               COPY LENGTH FIELD OVER\n         SLL   R8,4                GET LENGTH * 16\n         OR    R8,R7               SET UP REG WITH 2 LENGTHS\n         SPACE\n         MVO   EISRPRND(1),ECL1I3(1)  MOVE IMMEDIATE OVER\n         ZAP   EISRPRND(1),ECL1I3(1)  CHECK IMMEDIATE\n         EX    R7,EISRPZP1         CHECK USER NUMBER\n         BZ    EISRPLF5            IF NUMBER=0, WERE DONE\n         SPACE\n         SLL   RAD2,26             EXTEND BIT 26 AS IF\n         SRA   RAD2,26                 IT IS A SIGN BIT\n         BZ    EISRPLF3            IF SHIFT IS ZERO, WERE DONE\n         BP    EISRPLF             IF SHIFT IS POS, ITS LEFT\n         SPACE\n*              RIGHT SHIFT CODE\nEISRPRT  EQU   *\n         LPR   RAD2,RAD2           RIGHT SHIFT, GET POS SHIFT\n         B     EISRPRT2            BRANCH INTO LOOP\nEISRPRT1 EQU   *\n         MVO   EISRPSHF(16),EISRPSHF(15)  SHIFT ALL BUT LAST NIBBLE\nEISRPRT2 EQU   *\n         BCT   RAD2,EISRPRT1       CONTINUE LOOP (DECMT COUNT)\n         SLL   R7,4                SHIFT LENGTH TO L1 FIELD\n         MVN   EISRPSHF+15(1),EISRPRND  MAKE SIGN POSITIVE\n         AP    EISRPSHF(16),EISRPRND(1) ADD IN ROUNDING FACTOR\n         EX    R7,EISRPMV1         MOVE TO USER, DOING LAST SHIFT\n         B     EISRPLF3            GO TO SET CC AND RETURN\n         SPACE\n*              LEFT SHIFT CODE\nEISRPLF  EQU   *\n         STC   R8,EISRPLF2+1       PUT LEN INTO MVO INSTR\n         LA    RWK1,0(R7,RAD1)     GET @ OF LAST BYTE OF USER #\n         OI    *+1,0               SET CC = 0\nEISRPLF1 EQU   *\n         BNZ   EISRPLF2            IF OVERFLOW HAS OCCURRED, BRANCH\n         TM    0(RAD1),X'F0'       CHECK 1ST NIBBLE FOR NON ZERO\nEISRPLF2 EQU   *\n         MVO   0($,RAD1),0($,RAD1)    SHIFT LEFT ** LENGTHS STORED IN**\n         MVZ   0(1,RWK1),EISRPPK0  MOVE ZERO TO PROPAGATED SIGN\n         BCT   RAD2,EISRPLF1       DECREMENT COUNT AND BRANCH\n         BNZ   EISRPLF4            OVERFLOW, BRANCH TO CHECK FOR OCA\nEISRPLF3 EQU   *\n         EX    R8,EISRPZP2         SET CC FOR +, - OR 0\n         BAL   RCC,EIFIN           CAPTURE CC AND RETURN FOR NEXT INSTR\nEISRPLF4 EQU   *\n         TM    ECSTCCPM,X'04'      CAPTURE MASK BIT\n         BO    EIOCA               OVERFLOW HAS OCCURRED -- ERROR\n         TM    *+1,1               SET CC TO OVERFLOW\nEISRPLF5 EQU   *\n         BAL   RCC,EIFIN           CAPTURE CC AND RETURN FOR NEXT INSTR\n         SPACE 1\nEISRPZP1 ZAP   EISRPSHF(16),0($,RAD1)    CHECK AND MOVE USER #\nEISRPZP2 ZAP   0($,RAD1),0($,RAD1) SET CC TO +, -, OR 0\nEISRPMV1 MVO   0($,RAD1),EISRPSHF(15)  MOVE BACK TO USER AREA\n         SPACE 1\nEISRPRND DC    PL1'0'              AREA FOR SRP ROUNDING FACTOR\nEISRPSHF DC    PL16'0'             AREA FOR SHIFTING USER #\nEISRPPK0 DC    PL1'0'              USED TO SET SIGN\n.EISRP2  ANOP\n         SPACE 2\n*              CHECK IF GENERATION OF XIO'S IS ON\n         AIF   (&$XIOS).EIXIOS     SKIP TO GENERATE CODE IF EXISTS\nEIXIOS   EQU   EIOC1               THESE INSTRUCTIONS DO NOT EXIST\n         AGO   .EINOXIO\n.EIXIOS  ANOP\n         SPACE 2\n*        PSEUDO RX - SS EXTENDED MNEMONICS - XREAD, XPRNT, XPNCH, IO'S*\n*              PSEUDO DUMP ROUTINE  -  XDUMP                          *\n*        ** NOTE ** BECAUSE OF NO-STANDARD ADDRESSING DONE BY THESE   *\n*        INSTRUCTIONS, THEY DO THEIR OWN ADDRESS CHECKING AND THUS    *\n*        HAVE A PROTECTION BYTE OF X'00' SO THE INITIAL SS SECTION    *\n*        DOESN'T STOP THEM.  THEY THEN FAKE THE PROTECTION BYTES OF   *\n*        EITHER STM (X'C0'-XREAD),OR TM(X'80'-XPRNT,XDUMP,XPNCH).     *\n         SPACE 1\nEIXIOSR  ST    RIA,EIRIA           XDUMPR SHORT CUT                   L\nEIXIOS   EQU   *                   SECTION FOR X-MACRO I/O INSTRS\n         N     RCC,=XL4'3F000000'  REMOVE ALL BUT CC - PM BITS\n         AL    RCC,EIRIA           PUT CC - PM PROG ADDR TOGETHER\n         ST   RCC,ECILCMSK         STORE RESULTING PSW\n         OI    ECILCMSK,X'C0'      SET ILC = 3, FOR LENGTH OF X-INST\n         CLI   ECOP,X'E1'          SEE IF IT WAS A REGS TYPE XDUMP\n         BE    EIXDUMPR            YES, GO DUMP REGS ONLY\n         SR    RAD2,RMEM           REMOVE SPERIOUS RELOCATION\n         BNZ   EIXLOK              LENGTH OK IF NOT ZERO\n         L     RAD2,ECREGS         GET VALUE OF FAKE ZERO\nEIXLOK   EQU   *\n         LR    RWK1,RAD2           SAVE THE LENGTH TO BE DONE\n         SRL   R7,3                GET MASK VALUE IN PLACE FOR INDEX\n         ALR   R7,R7               SHIFT LEFT FOR MULTIPLE OF 2\n         LH    R9,EIXIOJ(R7)       GET ADDRESS VALUE\n         B     EISPEJMP(R9)        GO TO RIGHT SECTION OF CODE\n         SPACE 2\n*              XREAD PREUDO INSTRUCTION\nEIXREAD  EQU   *\n         TM    ECFLAG0,$ECEOF      HAS THERE BEEN AN EOF ALREADY\n         BO    EIXREOF             YES, USER TRYING TO GO PAST\n         $READ 0(RAD1),(RWK1),EIXREOFA   ACTUALLY READ A CARD\n         BAL   RCC,EIFIN           CAPTURE CC AND RETURN FOR NEXT INSTR\n         SPACE 1\nEIXREOFA OI    ECFLAG0,$ECEOF      FLAG END OF FILE\n         BAL   RCC,EIFIN           GET COND CODE AND RETURN\n         SPACE 1\nEIXREOF  MVI   ECFLAG1,$ECREADR    SHOW READ BEYOND END OF FILE\n         LA    R1,EICCREAD         SHOW EOF OCCURRED                  M\n         NI    ECPRFLG3,ECNOSPI    MAKE SURE SPIE IS OFF FOR SAFETY   M\n         B     EIITIA              GO TO EXIT ROUTINE                 M\n         SPACE 2\n*              XPRNT PSEUDO INSTRUCTION  -  PRINT A LINE\nEIXPRNT  EQU   *\n         $PRNT    0(RAD1),(RWK1),EIXRECEX   PRINT THE LINE\n         B      EIFIN              RETURN FOR THE NEXT INSTRUCTION\n         SPACE 2\n*              XPNCH PSEUDO INSTRUCTION  -  PUNCH A CARD\nEIXPNCH  EQU   *\n         $PNCH 0(RAD1),(RWK1),EIXRECEX   PUNCH THE CARD\n         B     EIFIN               RETURN FOR NEXT INST\n         SPACE 2\n         AIF   (&$XXIOS).EIXIOS1   SKIP IF NOT ALLOWED XGET , XP T\n*              XGET PSEUDO INSTRUCTION  INPUT\nEIXGET   EQU   *\n         $GET  0(RAD1),(RAD2)      DO GET INPUT                  CEH\n         BAL   RCC,EIFIN           GET CC AND RETURN\n         SPACE 2\n*              XPUT PSEUDO INSTRUCTION DO OUTPUT\nEIXPUT   EQU   *\n         $PUT  0(RAD1),(RAD2)      DO PUT OUTPUT         CEH\n         BAL   RCC,EIFIN           GET CC AND RETURN FOR NEXT INSTR\n         AGO   .EIXIOS2            SKIP LABEL SAVING\n.EIXIOS1 ANOP\nEIXGET   EQU   EIOC1               MAKE XGET AN ERROR           CPP\nEIXPUT   EQU   EIOC1               MAKE XPUT AN ERROR           CPP\n.EIXIOS2 ANOP\n         SPACE 2\nEIXRECHK CLI   ECFLAG1,$ECRECEX    DID XXXXSNAP SET FLAG?\n         BNE   EIFIN               NO,SO DON'T BOMB USER OUT\nEIXRECEX MVI   ECFLAG1,$ECRECEX    SET RECORDS EXCEEDED FLAG\nEICNTEXC LA    R1,EICCRECE         SHOW RECORDS EXCEEDED MESSAGE\n         NI    ECPRFLG3,ECNOSPI    MAKE SURE SPIE IS OFF FOR SAFETY   M\n         B     EIITIA              GO TO FINISH UP AND RETURN\n         SPACE 2\n*              XDUMP PSEUDO INSTRUCTION - DUMP STORAGE AND REGISTERS\nEIXDUMP  EQU   *                   ENTRY LABEL FOR STORAGE XDUMP\n         LR    R10,REC             MOVE ECONTROL POINTER FOR XXXXSNAP\n         XSNAP T=(NO,,1),LABEL='USER STORAGE',STORAGE=(*0(RAD1),*0(RWK1X\n               ,RAD1))\n         B     EIXRECHK            GO CHECK FOR RECORD OVERFLOW\n         SPACE 2\nEIXDUMPR EQU   *\n         LR    R10,REC             MOVE ECONTROL POINTER FOR XXXXSNAP\n         XSNAP T=(PR,,1),LABEL='USER REGISTERS'\n         B     EIXRECHK            GO CHECK FOR RECORD OVERFLOW\n         SPACE 2\n*              XLIMD PSEUDO INSTRUCTION -- LIMIT DUMP AREA\nEIXLIMD  EQU   *\n         LA    RAD2,0(RWK1,RAD1)   GET SECOND LIMIT REAL ADDRESS\n         BCT   RWK1,*+8            IF RWK1=1 (OMITTED) USE END OF PROG\n         L     RAD2,ECRADH         LENGTH=1 USE HIGHEST @ INSTEAD\n         ST    RAD1,ECRDLIML       ECRDLIML - ECRDLIMH - NEW LIMITS\n         ST    RAD2,ECRDLIML+4     STORE NEW LIMITS\n         B     EIFIN               RETURN FOR NEXT INSTRUCTION\n         EJECT\n*              THE FOLLOWING CODE INTERPRETS THE XOPC PSEUDO INSTRS\n         SPACE 5\n*              CHECK IF LEGAL CODE # IS SPECIFIED IN THE IMMED FIELD\n*              OF THE INSTR  --  IF OK, BRANCH TO INDIVIDUAL XOPC\n*              ROUTINES.\nEIXOPC   EQU   *\n         C     R7,=A(EC#XOPC)      IS CODE # LEGAL ?\n         BNH   EIXOPCOK            YES, BR AROUND ERROR CODE\n         TM    *+1,1               SET CC = 3 TO NOTE ERROR\n         BAL   RCC,EIFINRR         GET CC, FETCH NEXT INSTR\nEIXOPCOK EQU   *\n         LR    RWK1,R7             COPY CODE # FOR OFFSET INDEX\n         ALR   RWK1,RWK1           GET INDEX INTO OFFSET TABLE\n         LH    RWK1,EIOPCJMP(RWK1) GET BRANCH OFFSET TO ROUTINE\n         B     EIXOPC(RWK1)        BRANCH TO ROUTINE\n         SPACE 5\n*              THE FOLLOWING CODE PROCESSES THE INDIVIDUAL XOPC\n*              PSEUDO INSTRUCTIONS\n         SPACE 2\n*              XOPC 0  (SET UP PSEUDO SPIE)\nEIOPC0   EQU   *\n         L     RWK1,ECREG1         GET USER SPECIFIED EXIT @\n         LA    RWK0,1              ASSUME LENGTH-1 = 1\n         BAL   RLINK,EIXOPCHK      CHECK GIVEN ADDRESS FOR CORRECTNESS\n         ST    RWK1,ECPRSPIE       SET USER SPIE EXIT ADDR\n         MVC   ECPRSCDE(4),ECREG0  SET USER SPIE CODE MASK\n         OI    ECPRFLG3,B'10000000'  TURN ON FLAG NOTE SPIE IS SET\n         B     EIXOPCC0            BRANCH TO COMMON XOPC EXIT CODE\n         SPACE 2\n*              INSTRUCTION TRACE XOPC INSTRUCTIONS\n*\n*              CHECK AND SET LIMIT ADDRESSES FOR TRACE\nEIOPC1   EQU   *\nEIOPC3   EQU   EIOPC1\n         LM    RWK0,RWK1,ECREGS    GET LOW AND HIGH ADDRS FOR TRACE\n         CR    RWK0,RWK1           ARE ADDRESSES RELATIVELY CORRECT ?\n         BNL   EIXOPCC1            BRANCH IF NOT\n         BAL   RLINK,EIXOPCHA      CHECK ADDRESSES FOR LEGALITY\n         STM   RWK0,RWK1,ECPRTRAL  SET TRACE ADDRESS LIMITS IN PRCB\n         BCTR  R7,0                XOPC CODE# = CODE#-1\n         LTR   R7,R7               IS CODE = 1  (R7 = 0) ?\n         BZ    EIXOPCC0            YES, DOING XOPC 1 - FINISHED\n*        TURN ON INSTRUCTION TRACE FACILITY\nEIOPC2   EQU   *\n         OI    ECPRFLG1,ECPRTRCE   TURN ON TRACE FACILITY\n         B     EIXOPCC0            BRANCH TO COMMON XOPC EXIT CODE\n*              TURN OFF INSTRUCTION TRACE FACILITY\nEIOPC4   EQU   *\n         NI    ECPRFLG1,255-ECPRTRCE  TURN OFF TRACE FACILITY\n         B     EIXOPCC0            BRANCH TO COMMON XOPC EXIT CODE\n         SPACE 2\n*              STORAGE MODIFICATION CHECK XOPC INSTRUCTIONS\n*\n*              CHECK AND SET LIMIT ADDRESSES FOR MOD CHECK\nEIOPC5   EQU   *\nEIOPC7   EQU   EIOPC5\n         LM    RWK0,RWK1,ECREGS    GET LOW AND HIGH ADDRS FOR MOD CHK\n         CR    RWK0,RWK1           ARE ADDRS RELATIVELY CORRECT ?\n         BNL   EIXOPCC1            BRANCH IF NOT\n         BAL   RLINK,EIXOPCHA      CHECK IF ADDRESSES ARE LEGAL\n         STM   RWK0,RWK1,ECPRMODL  SET MOD CHECK ADDRESSES\n         LA    RWK1,5              LOAD CODE # COMPARATOR\n         CR    R7,RWK1             IS THIS AN XOPC 5 INSTR ?\n         BE    EIXOPCC0            YES - FINISHED\n*              TURN ON MODIFICATION CHECK FACILITY\nEIOPC6   EQU   *\n         OI    ECPRFLG1,ECPRMODC   TURN ON MOD CHECKING\n         B     EIXOPCC0            BRANCH TO COMMON XOPC EXIT CODE\n*              TURN OFF MODIFICATION CHECKING FACILITY\nEIOPC8   EQU   *\n         NI    ECPRFLG1,255-ECPRMODC  TURN OFF MOD CHECKING\n         B     EIXOPCC0            BRANCH TO COMMON XOPC EXIT CODE\n         SPACE 2\n*              TURN ON ALIGNMENT CHECKING  (360 STYLE)\n*              (OC-6 ALIGNMENT INTERRUPTS ALLOWED)\nEIOPC9   EQU   *\n         OI    ECPRFLG2,ECALNCHK   TURN ON CHECKING\n         B     EIXOPCC0            BRANCH TO COMMON XOPC EXIT CODE\n*              TURN OFF ALIGNMENT CHECKING   (370 STYLE)\n*              (OC-6 ALIGNMENT INTERRUPTS NOT ALLOWED)\nEIOPC10  EQU   *\n         NI    ECPRFLG2,255-ECALNCHK    TURN OFF CHECKING\n         B     EIXOPCC0            BRANCH TO COMMON XOPC EXIT CODE\n         SPACE 2\n*              XOPC 11  (FETCH INSTRUCTION COUNT)\nEIOPC11  EQU   *\n         MVC   ECREG0(4),ECILIMT   PUT COUNT IN USER REG 0\n         B     EIXOPCC0            BRANCH TO COMMON XOPC EXIT CODE\n         SPACE 2\n*              XOPC 12   -   EMULATE SYSTEM 360\nEIOPC12  EQU   *\n         NI    ECPRFLG2,B'11110011' SHUT OFF ALL EMULATION BITS\n         OI    ECPRFLG2,ECEM360    SHOW NOW EMULATING A 360\n         MVI   EITSTMSK+1,ECEM360  SET TM INSTR FOR NO 370 INSTRS\n         B     EIXOPCC0            BRANCH TO COMMON XOPC EXIT CODE\n         SPACE 2\n*              XOPC 13   -   EMULATE SYSTEM 370\nEIOPC13  EQU   *\n         NI    ECPRFLG2,B'11110011' SHUT OFF ALLL EMULATION BITS\n         OI    ECPRFLG2,ECEM370    SHOW NOW EMULATING A 370\n         MVI   EITSTMSK+1,ECEM370  SET TM INSTR FOR BOTH 370 AND 360\n         B     EIXOPCC0            BRANCH TO COMMON XOPC EXIT CODE\n         SPACE 2\n*              XOPC 14   -   SET INTERRUPT COUNT\nEIOPC14  EQU   *\n         MVC   ECPRCMPR(4),ECREG0  MOVE GIVEN VALUE TO PRCB\n         B     EIXOPCC0            BRANCH TO COMMON EXIT CODE\n         SPACE 2\n*              XOPC 15   -   SET COUNT EXIT ADDRESS\nEIOPC15  EQU   *\n         MVC   ECPRCLEA(4),ECREG0  MOVE GIVEN EXIT ADDRESS PRCB\n         OI    ECPRFLG4,ECLKADR    TURN ON FLAG TO NOTE CLOCK EXIT ADDR\n         B     EIXOPCC0            BRANCH TO COMMON EXIT CODE\n         SPACE 3\n*              INSTRUCTION EXECUTION COUNT FACILITY INSTRUCTIONS\n*\n*              XOPC 17 AND XOPC 18\n*              CHECK AND SET LIMIT ADDRESSES FOR COUNT FACILITY\nEIOPC17  EQU   *\nEIOPC18  EQU   *\n         LM    RWK0,RWK1,ECREGS    GET LOW AND HIGH ADDRS FOR COUNT\n         CR    RWK0,RWK1           ARE ADDRESSES RELATIVELY CORRECT ?\n         BNL   EIXOPCC1            BRANCH IF NOT SET CC = 1\n         BAL   RLINK,EIXOPCHA      CHECK ADDRESSES FOR LEGALITY\n         STM   RWK0,RWK1,ECPRICL   SET COUNT LIMIT ADDRESSES IN PRCB\n         CLI   R7,X'11'            IS XOPC CODE 17 OR 18?\n         BE    EIXOPCC0            IS 17, SO FINISHED\n         SPACE 3\n*              TURN ON THE INSTRUCTION EXECUTION COUNT FACILITY\nEIOPC16  EQU   *\n         TM    ECPRFLG1,ECPRNOSP   TEST PRCB FOR NO COUNTING SPACE AVAL\n         BO    EIXOPCC1            NO SPACE AVAILABLE, QUIT\n         TM    ECPRFLG1,ECPRCTON   HAS SPACE FOR COUNT ALREADY ALLOCED\n         BO    EINOALL             SPACE ALREADY ALLOCATED\n         L     RWK0,ECFADH         GET HIGH PROG ADDR IN REG 0\n         S     RWK0,ECFADL         SUBTRACT TO FIND CORE LENGTH NEEDED\n         LA    R9,ECPRICA          GET ADDR IECF AREAS IN ECONTROL\n         GETMAIN  EC,LV=(0),A=(R9),SP=1  TRY  GET LENGTH USER PROG\n         LTR   R15,R15             TEST TO SEE IF WE GOT WHAT WE NEEDED\n         BZ    EISPCOK             IF CC=0, WE GOT WHAT WE NEEDED\n         OI    ECPRFLG1,ECPRNOSP   IF NOT, NOT ENOUGH SPACE - SET FLAG.\n         B     EIXOPCC1            AND QUIT.\nEISPCOK  EQU   *\n         ST    RWK0,ECPRICAL       GOT AMOUNT NEEDED STORE LENGTH\n         OI    ECPRFLG1,ECPRCTON   NOTE ALLOCATION OF COUNTER SPACE\nEINOALL  EQU   *\n         OI    ECPRFLG1,ECPRIECF   NOTE THAT THE COUNT FACILITY IS ON\n         B     EIXOPCC0            BRANCH TO COMMON XOPC RETURN CODE\n         SPACE 3\n*              XOPC 19\n*              TURN OFF THE INSTRUCTION EXECUTION COUNT FACILITY\nEIOPC19  EQU   *\n         NI    ECPRFLG1,255-ECPRIECF  TURN OFF THE COUNT FACILITY FLAG\n         B     EIXOPCC0            BRANCH TO COMMON XOPC RETURN CODE\n         SPACE 3\n*              XOPC 20\n*              CLEAR INSTRUCTION EXECUTION COUNT FACILITY COUNT AREAS\nEIOPC20  EQU   *\n         TM    ECPRFLG1,ECPRCTON   TEST FOR COUNT SPACE ALLOCATION\n         BNO   EIXOPCC1            IF NOT ALLOCATED, CANNOT CLEAR IT\n         L     RWK1,ECPRICA        GET ADDRESS OF CORE TO BE CLEARED\n         L     R9,ECPRICAL         GET LENGTH OF CORE TO BE CLEARED\n         BCTR  R9,0                GET LENGTH IN WORKABLE FORM\n         C     R9,=XL4'000000FF'   IS LENGTH > 256 BYTES\n         BNH   EIREMAIN            IF NOT > 256 BYTES CLEAR USING EX\n         XR    R8,R8               ZERO OUT R8 FOR DIVIDE\n         D     R8,=XL4'00000100'   DIVIDE LEN BY 256 GIVING REMAINDER\nEIOPCLP  EQU   *\n         XC    0(256,RWK1),0(RWK1) ZERO OUT 256 BYTE AREA\n         LA    RWK1,256(RWK1)      MOVE ADDRESS POINTER OVER\n         BCT   R9,EIOPCLP          GO BACK AND GET NEXT 256 BYTE AREA\n         LTR   R9,R8               PUT REMNDR WHERE NEEDED BY EXECUTE\n         BZ    EIXOPCC0            IF REMAINDER IS 0 WE ARE DONE\nEIREMAIN EQU   *\n         EX    R9,EIXOPCXC         EXECUTE XC TO DO REMAINING BYTES\n         B     EIXOPCC0            BRANCH TO COMMON XOPC EXIT CODE\nEIXOPCXC XC    0(0,RWK1),0(RWK1)    ZERO OUT REMAINING BYTES IN COUNT\n         SPACE 3\n*              XOPC 21  (RETURN FROM INTERRUPT HANDLING STATE)\nEIOPC21  EQU   *\n         TM    ECPRFLG3,ECINHDST   TEST SEE IF IN INTERRUPT HANDLING\n         BO    EIOPC21A            IF WE ARE CONTINUE XOPC INSTR\n         TM    *,X'FF'             SET CC=1 TO DENOTE ERROR\n         BAL   RCC,EIFINRR         GET CC, FETCH NEXT INSTR\nEIOPC21A EQU   *\n         L     RIA,ECREG1          GET RESUMING ADDR FROM USER REG 1\n         MVC   ECREG0(8),ECPRIRGS  RELOAD USER REGISTERS 0 AND 1\n         NI    ECPRFLG3,B'10111111'  TURN OFF INTERRUPT HANDLING FLAG\n         SR    RWK1,RWK1           SET CC = 0 TO NOTE OKAY EXEC\n         BAL   RCC,EIFINB          GET NEXT INSTR TREAT XOPC 21 AS BR\n         SPACE 5\n*              XOPC 22 - DUMP INSTRUCTION EXECUTION COUNT STATISTICS\n         SPACE 2\n*              THIS SECTION PRINTS THE STATISTICAL REPORT FOR THE\n*              INSTRUCTION EXECUTION COUNT FACILITY.  DUE TO THE TABLE\n*              DESIGN OF IECF, MANY POINTERS ARE USED AND REGISTER\n*              USAGE DIFFERS A LITTLE FROM THAT IN THE REST OF THE\n*              EXTENDED INTERPRETER. REGISTER USAGE IN THIS SECTION IS\n*              AS FOLLOWS: RWK0  -  GENERAL WORK REGISTER\n*                          RWK1  -  OFFSET POINTER IN COUNT TABLE\n*                          R7    -  GENERAL WORK REGISTER\n*                          R8    -  THE CURRENT INSTRUCTION COUNT\n*                          R9    -  BASE ADDRESS OF COUNTING AREA\n*                          R10   -  BASE ADDRESS OF USER PROGRAM AREA\n*                          RWK14  -  CURRENT PROGRAM RELATIVE ADDRESS\n*                                BEING INSPECTED\n*              IT SHOULD BE NOTED THAT THIS SECTION IS VERY INSTRUCTION\n*              LENGTH DEPENDENT.  ANY NEW INSTRUCTION DIFFERING IN THE\n*              TRADITIONAL LENGTH CODES WILL DRASTICALLY EFFECT THIS\n*              SECTION.\n         SPACE 3\nEIOPC22  EQU   *\n         TM    ECPRFLG1,ECPRCTON   TEST COUNT SPACE ALLOCATION\n         BNO   EIXOPCC1            IF NEVER ALLOCATED CANNOT DUMP IT\n         L     RWK1,ECFADL         GET FAKE BEGIN INSTR ADDR\n         LA    R10,0(RMEM,RWK1)    GET PHYSICAL REAL STARTING INSTR ADR\n         L     RWK1,ECPRICL        GET BEGINNING COUNTABLE FAKE INSTR\n         ST    RWK1,EISAV22        SAVE FIST OFFSET AS BEG LOOP ADDR\n         LR    RWK14,RWK1          SAVE FIRST ADDR FOR LATER USE\n         S     RWK1,ECFADL         SET OFFSET POINTER AT BEG\n         SR    R8,R8               ZERO OUT COUNT SAVING REGISTER\n         L     R9,ECPRICA          GET STARTING ADDRESS OF COUNT SPACE\n         SPACE 2\nEILOP22  EQU   *\n         CH    R8,0(RWK1,R9)       IS THE NEW COUNT THE SAME AS OLD?\n         BE    EIMVPNTR            IF SAME, MOVE POINTER OVER\n         SPACE 2\n*              THIS SECTION ACTUALLY PRINTS THE STATISTICS LINE\n         LTR   R8,R8               WAS THE OLD COUNT ZERO?\n         BZ    EINEWCT             IF OLD WAS ZERO, JUST SAVE & RETURN\n         L     RWK0,EIEND22        GET ENDING ADDR OF THIS LOOP\n         XHEXO RWK0,EISTEND        CONVERT ENDING ADDR TO HEX\n         L     RWK0,EISAV22        SET BEGINNING ADDR OF THIS LOOP\n         XHEXO RWK0,EISTBEG        CONVERT BEGINNING ADDR TO HEX\n         XDECO R8,EISTCNT          CONVERT INSTR COUNT TO DECIMAL\n         MVC   EISTBEG(2),EISTBLK  BLANK OUT FIRST TWO BYTES OF ADDR\n         MVC   EISTEND(2),EISTBLK   BLANK OUT FIRST TWO BYTES OF ADDR\n         $PRNT EISTMSG,EISTMSGL,EICNTEXC    PRINT STATISTICAL LINE\n         SPACE 2\nEINEWCT  EQU   *\n         ST    RWK14,EISAV22       SAVE BEGINNING LOOP ADDRESS\n         LH    R8,0(RWK1,R9)       REPLACE OLD COUNT WITH NEW\n         SPACE 2\nEIMVPNTR EQU   *\n         ST    RWK14,EIEND22       SAVE ENDING LOOP ADDRESS\n         LTR   R8,R8               TEST FOR ZERO COUNT\n         BZ    EIRR22              ASSUME 2 BYTE LENGTH INSTRS ON H-WRD\n         LA    R7,0(RWK1,R10)      GET ADDRESS OPCODE OF PRES INSTR\n         TM    0(R7),X'C0'         TEST OPCODE FOR LENGTH\n         BM    EIRXSI22            BRANCH IF LENGTH EQUAL 4\n         BO    EISS22              BRANCH IF AN SS INSTR LENGTH = 6\n         SPACE 2\nEIRR22   EQU   *\n         LA    RWK1,2(RWK1)        LENGTH = 2 INCERMENT AND CHECK DONE\n         B     EICHK22             BRANCH CHECK IF DONE\n         SPACE 2\nEIRXSI22 EQU   *                   RX OR SI THEN LENGTH =4\n         LA    RWK1,4(RWK1)        LENGTH = 4 INCERMENT AND CHECK\n         B     EICHK22             CHECK FOR FINISHED\n         SPACE 2\nEISS22   EQU   *                   LENGTH = 6\n         LA    RWK1,6(RWK1)        INCERMENT OFFSET AND CHECK\nEICHK22  EQU   *\n         LR    RWK14,RWK1          MOVE OFFSET FOR ADDR CALCULATION\n         A     RWK14,ECFADL        ADD TO GET NEW USER PROGRAM ADDR\n         C     RWK14,ECPRICH       TEST TO SEE IF OUT OF COUNTING RANGE\n         BL    EILOP22             IF NOT OUT OF RANGE CONTINUE\n         LTR   R8,R8               IF FINISHED CHECK LAST COUNT\n         BZ    EIXOPCC0            IF ZERO, DONE, BRANCH COMMON CODE\n         L     RWK0,EIEND22        GET LAST ENDING ADDRESS\n         SPACE 2\n*              THIS SECTION PRINTS THE LAST STATISTICS LINE\n         XHEXO RWK0,EISTEND        CONVERT ENDING ADDRESS TO HEX\n         L     RWK0,EISAV22        SET BEGINNING ADDR OF THIS LOOP\n         XHEXO RWK0,EISTBEG        CONVERT BEGINNING ADDRESS TO HEX\n         XDECO R8,EISTCNT          CONVERT INSTR \"OUNT TO DECIMAL\n         MVC   EISTBEG(2),EISTBLK  BLANK OUT FORST TWO BYTES OF ADDR\n         MVC   EISTEND(2),EISTBLK  BLANK OUT FIRST TWO BYTES OF ADDR\n         $PRNT EISTMSG,EISTMSGL,EICNTEXC    PRINT STATISTICAL LINE\n         B     EIXOPCC0            BRANCH TO COMMON XOPC EXIT CODE\n         SPACE 2\nEISTMSG  DC    C' STATS-->   BEGIN ADDR:'   STATISTICS MESSAGE\nEISTBEG  DC    8C' '               STATS MESSAGE\n         DC    C'   END ADDR:'     STATS MESSAGE\nEISTEND  DC    8C' '               STATS MESSAGE\n         DC    C'   INSTRUCTION COUNT:'      STATS MESSAGE\nEISTCNT  DC    12C' '              STATS MESSAGE\nEISTMSGL EQU   *-EISTMSG           LENGTH OF STATISTICAL MESSAGE\nEISTBLK  DC    2C' '               BLANK AREA\nEIEND22  DS    F                   ENDING LOOP ADDRESS\nEISAV22  DS    F                   BEGINNING LOOP ADDRESS\n         SPACE 2\n*              THIS IS THE XOPC COMMON EXIT CODE\nEIXOPCC0 EQU   *\n         SR    RWK1,RWK1           SET CC=0 NOTE OK EXECUTION\n         BAL   RCC,EIFINRR         BRANCH BACK AND FETCH NEXT INSTR\n         SPACE 2\n*              THIS IS THE XOPC EXIT CODE FOR CC = 1\nEIXOPCC1 EQU   *\n         O     RWK1,=XL4'11'       SET CC=1 TO NOTE USER ERROR\n         BAL   RCC,EIFINRR         GET CC AND BRANCH TO FETCH NXT INSTR\n         SPACE 3\n**--> INSUB: EIBASDSP      CALCULATE BASE/DISPLACEMENT  + + + + + + + +\n*+                                                                    +\n*+       ENTRY CONDS:                                                 +\n*+             RWK0 - MUST CONTAIN THE APPROPRIATE HALFWORD OF THE    +\n*+                    INSTRUCTION                                     +\n*+       EXIT CONDS:                                                  +\n*+             RWK0 - CONTAINS THE CALCULATED RELATIVE ADDRESS        +\n*+                    (NOT RELOCATED FOR ASSIST)                      +\n*+             RWK1 - CONTENTS ARE DESTROYED                          +\n*+                                                                    +\n*++ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +\n         SPACE 2\nEIBASDSP EQU   *\n         LR    RWK1,RWK0           COPY B/D OVER\n         N     RWK0,=XL4'FFF'      REMOVE BASE, LEAVING DISP\n         N     RWK1,=XL4'F000'     REMOVE DISP, LEAVING BASE\n         BCR   Z,RLINK             IF NO BASE, RETURN\n         SRL   RWK1,10             MULT BASE REG BY 4 FOR INDEX\n         AL    RWK0,ECREGS(RWK1)   ADD IN BASE REG'S VALUE\n         N     RWK0,EILONGMK       ZERO OUT HIGH ORDER BYTE\n         BR    RLINK               RETURN TO CALLER\n         SPACE 5\n**--> INSUB: EIMSFCHK       MODIFICATION & RANGE CHECKING ROUTINE + + +\n*+                                                                    +\n*+       THIS ROUTINE CHECKS THE ADDRESS IN RWK1 FOR BEING WITHIN     +\n*+       THE ALLOWABLE RANGE.  MODIFICATION CHECKING IS ALSO          +\n*+       PERFORMED IF THE INSTRUCTION MODIFIES STORAGE.               +\n*+                                                                    +\n*+       ENTRY CONDS:                                                 +\n*+             RWK1 - CONTAINS THE ADDRESS TO BE CHECKED              +\n*+             RWK0 - CONTAINS THE LENGTH OF STORAGE AFFECTED         +\n*+            RLINK - CONTAINS THE RETURN ADDRESS                     +\n*+           EIWORK - IS A STORAGE AREA THAT MUST CONTAIN THE CONTROL +\n*+                    BYTE EICTB3  (SHIFTED LEFT 2 BITS IF 2ND OPRND) +\n*+       EXIT CONDS:                                                  +\n*+             RWK0 - IS DESTROYED                                    +\n*+             RWK1 - IS DESTROYED                                    +\n*+                                                                    +\n*++ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +\n         SPACE 2\nEIMSFCHK EQU   *\n*              DETERMINE WHAT CHECKING TO PERFORM\n         BCTR  RWK0,0              RWK0 CONTAINS LENGTH-1\n         ALR   RWK0,RWK1           GET @ OF HIGHEST BYTE ACCESSED\n         TM    EIWORK,EI1STORE     WHAT CHECKING IS TO BE DONE ?\n         BCR   Z,RLINK             RETURN IF NO CHECKING\n         BO    EISTRCHK            BRANCH TO DO STORE CHECKING\n*              PERFORM FETCH CHECKING\n         TM    ECFLAG0,$ECPROT     IS ABSOLUTE PROTECT MODE ON ?\n         BCR   Z,RLINK             RETURN IF NOT\nEIFTHCHK EQU   *\n         C     RWK1,ECFADL         IS BEGINNING @ TOO LOW ?\n         BL    EIOC4               YES, SO ERROR\n         C     RWK0,ECFADH         IS ENDING @ TOO HIGH ?\n         BCR   L,RLINK             RETURN IF NOT (ADDR IS OK)\n         B     EIOC4               @ IS TOO HIGH, SO ERROR\n*              PERFORM STORE CHECKING\nEISTRCHK EQU   *\n         C     RWK1,ECFADL         IS BEGINNING @ TOO LOW ?\n         BL    EIOC4               YES, SO ERROR\n         C     RWK0,ECFADH         IS ENDING @ TOO HIGH ?\n         BH    EIOC4               YES, SO ERROR\n*              PERFORM MODIFICATION CHECKING\n         TM    ECPRFLG1,ECPRMODC   IS MOD CHECK OPTION ON ?\n         BCR   Z,RLINK             NO, SO RETURN TO CALLER\n         C     RWK1,ECPRMODH       IS BEGINNING @ HIGHER THAN CHK AREA?\n         BCR   H,RLINK             RETURN IF YES\n         C     RWK0,ECPRMODL       IS ENDING @ LOWER THAN CHECK AREA ?\n         BCR   L,RLINK             RETURN IF YES\n*              IF HERE, THE INSTRUCTION MODIFIES STORAGE WITHIN THE\n*              CHECKING AREA.  PERTINENT INFORMATION IS PRINTED FOR THE\n*              USER PROGRAMMER.\n         XHEXO RWK0,EICKHIGH       CONVERT HIGH @ TO HEX FOR PRINTING\n         MVC   EICKHIGH(2),EIBLANKS  BLANK OUT 1ST 2 DIGITS\n         XHEXO RWK1,EICKLOW        CONVERT LOW @ TO HEX FOR PRINTING\n         MVC   EICKLOW(2),EIBLANKS   BLANK OUT 1ST 2 DIGITS\n         L     RWK1,ECSTIADD       GET INSTRUCTION ADDR\n         XHEXO RWK1,EICKINAD       CONVERT INSTR ADDR TO HEX FOR PRNT\n         MVC   EICKINAD(2),EIBLANKS  BLANK OUT 1ST 2 DIGITS\n         MVC   EICKINST+4(10),EIBLANKS  BLANK OUT INSTR AREA\n         LM    RWK0,RWK1,ECSTCCPM  FETCH INSTR FROM INSTR STACK\n         SLDL R0,16                RR AND RX CODE IN REG 0\n         XHEXO RWK0,EIWORK         CONVERT 1ST 4 BYTES TO HEX\n         TM    ECSTINST,EISSINST   IS THISAN SS INSTR ?\n         BNO   EINOTSSI            BRANCH IF NOT\n         XHEXO RWK1,EIWORK+8       CONVERT LAST 2 BYTES TO HEX\nEINOTSSI EQU   *\n         LA    RWK1,EICKINST       GET @ OF THE HEX INSTR\n         BAL   R2,EIMOVINS         MOVE HEX INSTR TO PRINT FORMAT\n         $PRNT EICHKMSG,EICHKMSL,EICNTEXC  PRINT INSTR FOR MOD CHK,    X\n                                           BR OUT IF COUNT EXCEEDED\n         BR    RLINK               RETURN TO CALLER\n*              THE FOLLOWING STORAGE IS USED AS A PRINT FORMAT AREA BY\n*              THE MODIFICATION CHECK FACILITY\nEICHKMSG DC    C' CHECK-->   INSTR ADDR:'\nEICKINAD DC    8C' '\n         DC    C'   INSTR:  '\nEICKINST DC    14C' '\n         DC    C'     MODIFICATION LIMIT ADDRS-->   LOW:'\nEICKLOW  DC    8C' '\n         DC    C'   HIGH:'\nEICKHIGH DC    8C' '\nEICHKMSL EQU   *-EICHKMSG          LENGTH OF PRINT MESSAGE\n         SPACE 5\n**--> INSUB: EIMOVINS     MOVE HEX INSTR TO PRINT FORMAT  + + + + + + +\n*+                                                                    +\n*+       THIS INSUB MOVES A HEXIDECIMAL INSTRUCTION TO A              +\n*+       SPECIFIED AREA WITH BLANKS INSERTED TO RESEMBLE              +\n*+       SOURCE CODE LISTING FORMAT.                                  +\n*+                                                                    +\n*+       ENTRY CONDS:                                                 +\n*+             RWK1  -  CONTAINS THE TARGET ADDRESS FOR THE MOVE      +\n*+             R2    -  USED AS THE BAL LINK REG                      +\n*+             EIWORK-  ASSUMED TO BE THE FETCH AREA FOR THE MOVE     +\n*+       EXIT CONDS:                                                  +\n*+             R2    -  IS RE-CLEARED AS A BYTE REG                   +\n*+             RWK0  &                                                +\n*+             RWK1  -  CONTENTS DESTROYED                            +\n*+                                                                    +\n*++ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +\n         SPACE 2\nEIMOVINS DS  0H\n         ST    R2,EIMOVSAV         SAVE RETURN ADDR\n         SR    RWK0,RWK0           CLEAR LOOP COUNTER REG\n         IC    RWK0,EICTB2         GET INSTR LEN FOR LOOP COUNT\n         SRL   RWK0,1              DIVIDE LENGTH BY 2 FOR LOOP CTR\n         LA    R2,EIWORK           GET @ OF FETCH AREA\nEIMOVEIN EQU   *\n         MVC   0(4,RWK1),0(R2)     MOVE 4 HEX BYTES\n         LA    RWK1,5(RWK1)        INCREMENT TARGET ADDRESS\n         LA    R2,4(R2)            INCREMENT FETCH ADDRESS\n         BCT   RWK0,EIMOVEIN       IF CTR ^= 0, CONTINUE LOOP\n         L     RWK1,EIMOVSAV       GET RETURN ADDRESS\n         SR    R2,R2               CLEAR BYTE REG\n         BR    RWK1                RETURN TO CALLER\nEIMOVSAV DC    F'0'                RET ADDR SAVED HERE\n         SPACE 5\n**--> INSUB: EIXOPCHK       CHECK ADDRESSES FOR XOPC INSTRUCTIONS + + +\n*+                                                                    +\n*+       ENTRY CONDITIONS:                                            +\n*+             RWK1  - CONTAINS THE ADDRESS TO BE CHECKED (LOW @)     +\n*+             RWK0  - CONTAINS LENGTH-1 OF STORAGE AFFECTED          +\n*+             RLINK - INTERNAL LINK REGISTER                         +\n*+       EXIT CONDITIONS:                                             +\n*+             RWK0  - CONTENTS (LENGTH) DESTROYED, UNLESS            +\n*+                     EIXOPCHA IS CALLED WITH RWK0 CONTAINING        +\n*+                     THE HIGH ADDRESS --> (LOW @ + LENGTH - 1)      +\n*+                                                                    +\n*++ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +\n         SPACE 2\nEIXOPCHK EQU   *\n         ALR   RWK0,RWK1           COMPUTE HIGH ADDRESS\nEIXOPCHA EQU   *\n         C     RWK1,ECFADL         IS LOW ADDRESS IN RANGE ?\n         BL    EIXOPCC1            NO, BRANCH TO NOTE ERROR\n         C     RWK0,ECFADH         IS HIGH ADDRESS IN RANGE ?\n         BCR   L,RLINK             YES, SO RETURN\n         B     EIXOPCC1            NO, BRANCH TO NOTE ERROR\n         LTORG\n         SPACE 2\n*        TABLE FOR THE XOPC INSTRUCTION DISPLACEMENTS\nEIOPCJMP $AL2  EIXOPC,(EIOPC0,EIOPC1,EIOPC2,EIOPC3,EIOPC4,EIOPC5,EIOPC6X\n               ,EIOPC7,EIOPC8,EIOPC9,EIOPC10,EIOPC11,EIOPC12,EIOPC13,EIX\n               OPC14,EIOPC15,EIOPC16,EIOPC17,EIOPC18,EIOPC19,EIOPC20,EIX\n               OPC21,EIOPC22)\n         SPACE 2\n*              TABLE FOR EXTENDED I/I INSTRUCTION DISPLACEME1T\nEIXIOJ   $AL2  EISPEJMP,(EIXREAD,EIXPRNT,EIXPNCH,EIXDUMP,EIXLIMD,EIXGETX\n               ,EIXPUT,EIOC1)\n.EINOXIO ANOP\n         SPACE 2\n*              OFF SETS TO COMPLETION CODE MESSAGES\nEICOFFS  $AL2  EICC0,(EICC1,EICC2,EICC3,EICC4,EICC5,EICC6,EICC7,EICC8,EX\n               ICC9,EICCA,EICCB),-2    STANDARD INTERRUPT POINTERS\n         AIF   (NOT &$FLOTE).EIFL6 SKI1IF NO FLOATING INTERRUPTS\n         $AL2  EICC0,(EICCC,EICCD,EICCE,EICCF)    FLOATING INTERS\n.EIFL6   ANOP\n         SPACE 2\n*              COMPLETION CODE MESSAGES\nEICC0    EQU   *\nEICC1    $ERCGN  0C1,'OPERATION'\nEICC2    $ERCGN  0C2,'PRIVILEGED OP)RATION'\nEICC3    $ERCGN  0C3,'EXECUTE'\nEICC4    $ERCGN  0C4,'PROTECTION'\nEICC5    $ERCGN  0C5,'ADDRESSING'\nEICC6    $ERCGN  0C6,'SPECIFICATION'\nEICC7    $ERCGN  0C7,'DATA'\nEICC8    $ERCGN  0C8,'FIXED-POINT OVERFLOW'\nEICC9    $ERCGN  0C9,'FIXED-POINT DIVIDE'\nEICCA    $ERCGN  0CA,'DECIMAL OVERFLOW'\nEICCB    $ERCGN  0CB,'DECIMAL DIVIDE'\n         AIF   (NOT &$FLOTE).EIFL8   SKIP MESSAGES FOR FLOATING PNT\nEICCC    $ERCGN  0CC,'EXPONENT OVERFLOW'\nEICCD    $ERCGN  0CD,'EXPONENT UNDERFLOW'\nEICCE    $ERCGN  0CE,'SIGNIFICANCE'\nEICCF    $ERCGN  0CF,'FLOATING-POINT DIVIDE'\n.EIFL8   ANOP\n         SPACE 1\nEICCREAD $ERCGN  220,'ATTEMPTED READ PAST END-FILE',TYPE=ASSIST\nEICCTIME $ERCGN  221,'INSTRUCTION LIMIT EXCEEDED',TYPE=ASSIST\nEICCRECE       $ERCGN  222,'RECORD LIMIT EXCEEDED',TYPE=ASSIST\n         AIF   (&$TIMER EQ 0).EINOTOC     SKIP IF NO TIMER AT ALL\nEICCTIMB $ERCGN  223,'TIME LIMIT EXCEEDED',TYPE=ASSIST\n.EINOTOC ANOP\nEICCBROU $ERCGN  224,'BRANCH OUT OF PROGRAM AREA',TYPE=ASSIST\n         SPACE 2\n*              THE FOLLOWING IS THE 256 SECONDARY CONTROL TABLE\n*              WHICH CONTAINS INDICES INTO THE MAIN CONTROL TABLE\nEIOPCDTB EQU   *\n         EIXTAB  2,XOPC,2,2,SPM,BALR,BCTR,BCR                         M\n         EIXTAB  PRIVH,PRIVH,PRIVH,2,2,2,MVCL,CLCL                    M\n         EIXTAB  NMRR,NMRR,NMRR,NMRR,NMRR,NMRR,NMRR,NMRR\n         EIXTAB  LR,NMRR,NMRR,NMRR,MRDR,MRDR,NMRR,NMRR\n         EIXTAB  FPRR,FPRR,FPRR,FPRR,FPRR,FPRR,FPRR,FPRR\n         EIXTAB  FPRR,FPRR,FPRR,FPRR,FPRR,FPRR,FPRR,FPRR\n         EIXTAB  FPRR,FPRR,FPRR,FPRR,FPRR,FPRR,FPRR,FPRR\n         EIXTAB  FPRR,FPRR,FPRR,FPRR,FPRR,FPRR,FPRR,FPRR\n         EIXTAB  STH,LA,STC,IC,EX,BAL,BCT,BC\n         EIXTAB  NMRXH,NMRXH,NMRXH,NMRXH,NMRXH,4,CVD,CVB\n         EIXTAB  ST,4,DECO,DECI,NMRXF,NMRXF,NMRXF,NMRXF\n         EIXTAB  NMRXF,NMRXF,NMRXF,NMRXF,MD,MD,NMRXF,NMRXF\n         EIXTAB  FPRS,HEXI,HEXO,4,4,4,4,XFPRF\n         EIXTAB  FPRF,FPRF,FPRF,FPRF,FPRF,FPRF,FPRF,FPRF\n         EIXTAB  FPRS,4,4,4,4,4,4,4\n         EIXTAB  FPRF,FPRF,FPRF,FPRF,FPRF,FPRF,FPRF,FPRF\n         EIXTAB  PRIVF,4,PRIVF,DIAG,PRIVF,PRIVF,BXH,BXLE              M\n         EIXTAB  SHFTS,SHFTS,SHFTS,SHFTS,SHFTD,SHFTD,SHFTD,SHFTD\n         EIXTAB STM,NMSIF,NMSIS,NMSIS,NMSIS,NMSIF,NMSIS,NMSIS\n         EIXTAB  LM,4,4,4,PRIVF,PRIVF,PRIVF,PRIVF                     M\n         EIXTAB  4,4,4,4,4,4,4,4\n         EIXTAB  4,4,4,4,PRIVF,PRIVF,4,PRIVF                          M\n         EIXTAB  4,PRIVF,PRIVF,4,4,4,PRIVF,PRIVF                      M\n         EIXTAB  4,4,4,4,4,CLM,STCM,ICM\n         EIXTAB  6,6,6,6,6,6,6,6\n         EIXTAB  6,6,6,6,6,6,6,6\n         EIXTAB 6,MOVES,MOVES,MOVES,LOGS,LOGFS,LOGS,LOGS\n         EIXTAB  6,6,6,6,TR,TRT,MOVES,EDMK\n         EIXTAB  XTND,DUMPR,6,6,6,6,6,6                               L\n         EIXTAB  6,6,6,6,6,6,6,6\n         EIXTAB  SRP,MVO,PACK,UNPK,6,6,6,6\n         EIXTAB  DECS,CP,DECS,DECS,DECS,DECS,6,6\n         TITLE '*** EXECUT - MAIN CONTROL TABLE'\n*              THE FOLLOWING IS THE MAIN CONTROL TABLE FOR THE\n*              EXTENDED INTERPRETER\nEICONTAB DS    0F                                                     L\nEIT2     DC    X'00020000',4X'00'                                     L\nEIT4     DC    X'00040000',4X'00'                                     L\nEIT6     DC    X'00060000',4X'00'                                     L\n         EITAB  NMRR,360,2,*,NO,NM,**,*,*,RR4,**,***,O,O,EINORMRR\n         EITAB    LR,360,2,*,NO,NM,**,*,*,RR4,**,***,O,O,EILR\n         EITAB  BALR,360,2,*,NO,NM,**,*,*,RR4,**,***,O,O,EIBALR\n         EITAB  BCTR,360,2,*,NO,NM,**,*,*,RR4,**,***,O,O,EIBCTR\n         EITAB   BCR,360,2,*,NO,NM,**,*,*,RR4,**,***,O,O,EIBCR\n         EITAB  FPRR,360,2,*,NO,NM,**,*,*,RR4,**,***,O,O,EIFPRR\n         EITAB  CLCL,370,2,*,NO,NM,NO,F,F,RR4,**,***,E,E,EILONG\n         EITAB  MVCL,370,2,*,NO,NM,NO,S,F,RR4,**,***,E,E,EILONG\n         EITAB   SPM,360,2,*,NO,NM,**,*,*,RR4,**,***,O,O,EISPM\n         EITAB  MRDR,360,2,*,NO,NM,**,*,*,RR4,**,***,E,O,EIMRDR\n         EITAB PRIVH,360,2,*,PR,NM,**,*,*,IOL,**,***,O,O,EILCTL       M\n         EITAB NMRXF,360,4,4,NO,NM,CK,F,*,RR4,IX,FUL,O,O,EINORMRX\n         EITAB    IC,360,4,1,NO,NM,CK,F,*,RR4,IX,NON,O,O,EINORMRX\n         EITAB NMRXH,360,4,2,NO,NM,CK,F,*,RR4,IX,HAF,O,O,EINORMRX\n         EITAB   CVB,360,4,8,NO,NM,CK,F,*,RR4,IX,DBL,O,O,EINORMRX\n         EITAB   BAL,360,4,*,NO,NM,NO,*,*,RR4,IX,NON,O,O,EIBAL\n         EITAB   BCT,360,4,*,NO,NM,NO,*,*,RR4,IX,NON,O,O,EIBCT\n         EITAB    BC,360,4,*,NO,NM,NO,*,*,RR4,IX,NON,O,O,EIBC\n         EITAB    LA,360,4,*,NO,NM,CK,*,*,RR4,IX,NON,O,O,EILA\n         EITAB    EX,360,4,*,NO,NM,CK,F,*,RR4,IX,HAF,O,O,EIEX\n         EITAB    MD,360,4,4,NO,NM,CK,F,*,RR4,IX,FUL,E,O,EIMD\n         EITAB   STH,360,4,2,NO,NM,CK,S,*,RR4,IX,HAF,O,O,EISTORS\n         EITAB   CVD,360,4,8,NO,NM,CK,S,*,RR4,IX,DBL,O,O,EISTORS\n         EITAB   STC,360,4,1,NO,NM,CK,S,*,RR4,IX,NON,O,O,EISTORS\n         EITAB    ST,360,4,4,NO,NM,CK,S,*,RR4,IX,FUL,O,O,EISTORS\n         EITAB  FPRF,360,4,4,NO,NM,CK,F,*,RR4,IX,FUL,E,O,EIFPRX\n         EITAB  FPRS,360,4,4,NO,NM,CK,S,*,RR4,IX,FUL,E,O,EIFPRXST CEH\n         EITAB XFPRF,360,4,8,NO,NM,CK,F,*,RR4,IX,DBL,E,O,EIFPRX\n         EITAB XFPRS,360,4,8,NO,NM,CK,S,*,RR4,IX,DBL,E,O,EIFPRXST CEH\n         EITAB NMSIS,360,4,1,NO,NM,CK,S,*,IOL,BD,NON,*,*,EINORMSI\n         EITAB NMSIF,360,4,1,NO,NM,CK,F,*,IOL,BD,NON,*,*,EINORMSI\n         EITAB  DIAG,360,4,1,NO,NM,NO,*,*,IOL,BD,NON,*,*,EIDIAG\n         EITAB   BXH,360,4,*,NO,NM,NO,N,*,RR4,BD,NON,O,O,EIRSBX\n         EITAB BXLE,360,4,*,NO,NM,NO,N,*,RR4,BD,NON,O,O,EIRSBX\n         EITAB    LM,360,4,*,NO,NM,NO,F,*,RR4,BD,FUL,O,O,EILMSTM\n         EITAB   STM,360,4,*,NO,NM,NO,S,*,RR4,BD,FUL,O,O,EILMSTM\n         EITAB SHFTS,360,4,*,NO,NM,NO,N,*,RR4,BD,NON,O,O,EISHIFT\n         EITAB SHFTD,360,4,*,NO,NM,NO,N,*,RR4,BD,NON,E,O,EISHIFT\n         EITAB   ICM,370,4,4,NO,NM,CK,F,*,RR4,BD,NON,O,O,EIICM\n         EITAB  STCM,370,4,4,NO,NM,CK,S,*,RR4,BD,NON,O,O,EISTCM\n         EITAB   CLM,370,4,4,NO,NM,CK,F,*,RR4,BD,NON,O,O,EICLM\n         EITAB PRIVF,360,4,*,PR,NM,**,*,*,IOL,**,***,O,O,EILCTL       M\n         EITAB MOVES,360,6,0,NO,NM,CK,S,F,IOL,BD,NON,*,*,EIMOVES\n         EITAB   MVO,360,6,0,NO,NM,CK,S,F,LL1,BD,NON,*,*,EIMOVES\n         EITAB  LOGS,360,6,0,NO,NM,CK,S,F,IOL,BD,NON,*,*,EILOGS\n         EITAB  LOGFS,360,6,0,NO,NM,CK,F,F,IOL,BD,NON,*,*,EILOGS\n         EITAB    TR,360,6,0,NO,NM,CK,S,F,IOL,BD,NON,*,*,EIMOVES\n         EITAB  PACK,360,6,0,NO,NM,CK,S,F,LL1,BD,NON,*,*,EIMOVES\n         EITAB  UNPK,360,6,0,NO,NM,CK,S,F,LL1,BD,NON,*,*,EIMOVES\n         EITAB  DECS,360,6,0,NO,NM,CK,S,F,LL1,BD,NON,*,*,EIDECS\n         EITAB    CP,360,6,0,NO,NM,CK,F,F,LL1,BD,NON,*,*,EIDECS\n         EITAB   TRT,360,6,0,NO,NM,CK,F,F,IOL,BD,NON,*,*,EITRT\n         EITAB  EDMK,360,6,0,NO,NM,CK,S,F,IOL,BD,NON,*,*,EIEDMK\n         EITAB   SRP,370,6,0,NO,NM,CK,S,N,LL1,BD,NON,*,*,EISRP\n         EITAB  XTND,*,*,*,*,EX,*,*,*,*,*,*,*,*,EI2EXTAB\n*        ONLY LENGTH AND OPCODE REQ FOR REGISTER XDUMP                L\n         EITAB DUMPR,360,6,*,NO,NM,**,*,*,*,*,*,*,*,EIXDUMPR          L\n         EITAB  HEXI,360,4,8,NO,NM,CK,F,*,RR4,IX,NON,O,O,EIXHEXI      M\n         EITAB  HEXO,360,4,8,NO,NM,CK,S,*,RR4,IX,NON,O,O,EIXHEXO      M\n         EITAB  DECI,360,4,8,NO,NM,CK,F,*,RR4,IX,NON,O,O,EIXDECI      M\n         EITAB  DECO,360,4,12,NO,NM,CK,S,*,RR4,IX,NON,O,O,EIXDECO     M\n         EITAB  XOPC,360,2,*,NO,NM,**,*,*,IOL,**,***,*,*,EIXOPC       M\n***********************************************************************\n*                                                                     *\n*        THE FOLLOWING BLOCK OF STMTS DESCRIBES A SINGLE ENTRY        *\n*        OF THE OPTIONAL INTERPRETER MAIN CONTROL TABLE               *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*        NOTES ON THE DESIGN OF THE MAIN INTERPRETER TABLE            *\n*        -------------------------------------------------            *\n*                       (AND SUB-TABLES)                              *\n*                                                                     *\n*     => IMPORTANT:  THIS SHOULD BE REQUIRED READING FOR ANYONE       *\n*        NEEDING TO UNDERSTAND AND/OR MODIFY THIS TABLE SCHEME.       *\n*                                                                     *\n*             A 256 BYTE TABLE (1 BYTE PER POSSIBLE OPCODE) OF        *\n*        POINTERS ALLOW EASY ACCESS TO INSTRUCTION DECODING           *\n*        INFORMATION BY INDEXING INTO A LARGER MAIN TABLE             *\n*        DESCRIBED BELOW.                                             *\n*             THE OPTIONAL ASSIST INTERPRETER'S MAIN CONTROL TABLE    *\n*        (NAMED: EICONTAB) CONTAINS ONE ENTRY FOR EACH POSSIBLE       *\n*        TYPE OF INSTRUCTION DECODING.  EACH 8 BYTE ENTRY CONTAINS    *\n*        APPROPRIATE FLAGS AND OTHER INFORMATION (AS DESCRIBED        *\n*        BELOW) TO CONTROL EACH STEP OF THE SPECIFIC INSTRUCTION      *\n*        DECODING PROCESS.                                            *\n*             THE FIRST THREE COMPLETE ENTRIES OF EICONTAB WILL       *\n*        BE ALL ZEROS EXCEPT THE INSTRUCTION LENGTH BITS.  THE        *\n*        FIRST ENTRY'S INSTRUCTION LENGTH WILL BE EQUAL TO TWO,       *\n*        THE SECOND'S WILL EQUAL FOUR AND THE THIRD'S WILL EQUAL      *\n*        SIX.  ALL ILLEGAL OPCODES (IN EIOPCDTB, THE 256 BYTE         *\n*        TABLE DESCRIBED ABOVE) WILL POINT TO THE ENTRY WHOSE         *\n*        INSTRUCTION LENGTH CORRESPONDS TO THE HIGH ORDER TWO BITS    *\n*        OF THE OPCODE ITSELF.                                        *\n*             FOR EXTENDED OPCODES (S-TYPE & PSEUDO-INSTRUCTIONS)     *\n*        THE ENTRY IN EICONTAB WILL BE MARKED 'OPCODE-DOES-NOT-       *\n*        TELL-ALL' AND WILL CONTAIN INFORMATION CONCERNING ACCESS     *\n*        TO A SUB-TABLE GIVING ALL NECESSARY INFORMATION ABOUT        *\n*        INSTRUCTION DECODING.  SEE EQUATES BELOW.                    *\n*                                                                     *\n***********************************************************************\n*\nEICTNTRY DS    0D                  MOVE CONTROL TABLE ENTRY HERE\n*              FLAG BYTES -- CONTAIN INSTR DECODING INFORMATION AS\n*              DESCRIBED BY EQUATES BELOW\nEICTB1   DS    B                   FLAG BYTE 1\nEICTB2   DS    B                   FLAG BYTE 2\nEICTB3   DS    B                   FLAG BYTE 3\nEICTB4   DS    B                   FLAG BYTE 4\nEICTB5   DS    B                   FLAG BYTE 5\nEICTB6   DS    B                   FLAG BYTE 6\nEICTDISP DS    H                   DISPLACEMENT FOR BRANCHING TO       X\n                                   SPECIAL ROUTINE\nEICTE$L  EQU   *-EICTNTRY          LENGTH OF A SINGLE TABLE ENTRY\n*              MISCELLANEOUS EQUATES\nEIEXTTAB EQU   EICTB5              ADDRESS OF EXTENDED OP CODE TABLE\nEI360PLS EQU   B'00001100'         (EICTB1)==> 360 & 370 INSTR\nEI370ONL EQU   B'00001000'         (EICTB1)==> 370 INSTR ONLY\nEIRR     EQU   B'00100000'         (EICTB1)==> THIS IS AN RR INSTR\nEIPRIVOP EQU   B'01000000'         (EICTB1)==>  THIS IS A PRIVILEGED   X\n                                                INSTRUCTION\nEIEXOPCD EQU   B'10000000'         (EICTB1)==>  OPCODE DOES NOT TELL   X\n                                                ALL (EXTENDED OPCODE)\nEINOCNOW EQU   B'00010000'         (EICTB1)==>  DO PERFORM MOD/ST/FTCH X\n                                                CHECKING AT EINOCHK\n*              EQUATES FOR INSTRUCTION LENGTH CODE\n*              **** NOTE ****  NO OTHER FLAGS CAN BE ADDED TO EICTB2\nEILEN2   EQU   B'00000010'         (EICTB2)==>  LENGTH=2 BYTES\nEILEN4   EQU   B'00000100'         (EICTB2)==>  LENGTH=4 BYTES\nEILEN6   EQU   B'00000110'         (EICTB2)==>  LENGTH=6 BYTES\n*              EQUATES FOR MODIFICATION OR FETCH CHECKING\n*              --- FOR FIRST OPERAND\nEI1NOCHK EQU   B'00000000'         (EICTB3)==>  NO CHECKING\nEI1FETCH EQU   B'01000000'         (EICTB3)==>  FETCH CHECKING\nEI1STORE EQU   B'11000000'         (EICTB3)==>  STORE CHECKING\n*              --- FOR SECOND OPERAND\nEI2NOCHK EQU   B'00000000'         (EICTB3)==>  NO CHECKING\nEI2FETCH EQU   B'00010000'         (EICTB3)==>  FETCH CHECKING\nEI2STORE EQU   B'00110000'         (EICTB3)==>  STORE CHECKING\n*              EQUATES FOR INSTR DECODING (2ND BYTE OF INSTR)\nEIB2RRX4 EQU   B'00000000'         (EICTB3)==>  2 REGS (MULT BY 4)\nEIB2LLX1 EQU   B'00000001'         (EICTB3)==>  2 LENGTHS (NO MULT)\nEIB2IORL EQU   B'00000011'         (EICTB3)==>  1 LENGTH OR IMMED FLD\n*              EQUATES FOR INSTR DECODING (2ND HALFWORD OF INSTR)\nEIH2NODX EQU   B'00000100'         (EICTB3)==>  BASE+DISP ONLY (OTHER- X\n                                   WISE INDEX+(BASE+DISP))\n*              NOTE IF THIS IS A BRANCH INSTRUCTION\nEIBRINST EQU   B'00001000'         (EICTB3)==> THIS IS A NON-RR BR INST\n*              EQUATES FOR OPERAND ALIGNMENT\n*              ***** NO OTHER FLAGS ALLOWED IN EICTB4 *****\nEIALNONE EQU   B'00000000'         (EICTB4)==>  NO ALIGNMENT NEEDED\nEIALHALF EQU   B'00000001'         (EICTB4)==>  HALFWORD ALIGNMENT\nEIALFULL EQU   B'00000011'         (EICTB4)==>  FULLWORD ALIGNMENT\nEIALDOBL EQU   B'00000111'         (EICTB4)==>  DOUBLE-WORD ALIGNMENT\n*              EQUATES FOR EVEN/ODD REGISTER CHECKING\n*              (THIS BYTE CAN NOT CONTAIN ANY OTHER FLAGS)\nEINEREG1 EQU   B'00000000'         (EICTB5)==> REG1 CAN BE ODD\nEIEVREG1 EQU   B'00010000'         (EICTB5)==> REG1 MUST BE EVEN\nEINEREG2 EQU   B'00000000'         (EICTB5)==> REG2 CAN BE ODD\nEIEVREG2 EQU   B'00000001'         (EICTB5)==> REG 2 MUST BE EVEN\n*              EQUATES FOR INSTR MOD/FETCH LENGTH\n*\n*              NOTE *****  THE UPPER NIBBLE OF THIS BYTE SHOULD ONLY\n*              BE USED WHEN ABSOLUTELY NECESSARY.  IF IT IS USED,\n*              THEN THE FOLLOWING INSTR MUST BE PLACED BETWEEN THE\n*              IC AND LTR INSTRS FOLLOWING LABEL => EINOCHK:\n*                   N     R2,=XL4'0F'\n*\nEIMFLENG EQU   B'00001111'        (EICTB6)==> LOWER NIBBLE HAS LENGTH\n*\n***********************************************************************\n*                                                                     *\n*        THE FOLLOWING EQUATES ARE USED FOR EXTENDED OPCODE           *\n*        TABLE ENTRY FETCHING:                                        *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n******** IMPORTANT NOTES FOR EXTENDED OPCODE INSTRUCTIONS *************\n*                                                                     *\n*        THE MAIN TABLE (EICONTAB) ENTRY FOR AN EXTENDED OPCODE       *\n*        WILL CONTAIN THE ACTUAL 4 BYTE ADDRESS OF THE SECONDARY      *\n*        TABLE CONTAINING DECODING ENTRIES FOR THE EXTENDED OPCODE    *\n*        INSTRUCTION.                                                 *\n*                                                                     *\n*        THE FIRST 8 BYTE ENTRY OF THE SECONDARY TABLE WILL           *\n*        CONTAIN A BYTE HAVING THE # OF BITS TO SHIFT THE 2ND         *\n*        BYTE OF THE INSTRUCTION TO OBTAIN AN INDEX INTO THE          *\n*        BYTE TABLE FOLLOWING THE 1ST ENTRY.  ALSO IN THE 1ST ENTRY   *\n*        WILL BE A FULLWORD COMPARATOR GIVING THE MAXIMUM INDEX       *\n*        VALUE THAT IS LEGAL.                                         *\n*                                                                     *\n*        THE BYTE TABLE FOLLOWING THE 1ST ENTRY WILL CONTAIN AS       *\n*        MANY SINGLE BYTE ENTRIES AS NECESSARY.  EACH ENTRY WILL BE   *\n*        A DISPLACEMENT FROM THE BEGINNING OF THE TABLE TO THE        *\n*        CORRECT TABLE ENTRY FOR THE PARTICULAR INSTRUCTION.  IF      *\n*        THE BYTE IS ZERO THEN THE INSTRUCTION IS NOT IMPLEMENTED     *\n*        AND AN OC-1 INTERRUPT WILL BE FLAGGED.                       *\n*                                                                     *\n***********************************************************************\n*\n*                   SECONDARY EXTENDED OPCODE TABLE                   *\n*  THIS TABLE IS AN EXTENSION OF THE MAIN DECODING TABLE AND IS       *\n*  STRICTLY RESERVED FOR THE EXTENDED OPCODE INSTRUCTIONS -- THOSE    *\n*  WITH AN OPCODE OF 'EO'.  BY SHIFTING THE SECOND BYTE OF THE        *\n*  INSTRUCTIONS 5 BITS TO THE RIGHT, AN INBEX TO BYTE TABLE -- SECOND *\n*  8 BYTES OF THIS TABLE -- IS ESTABLISHED WHERE A DISPLACEMENT TO    *\n*  THE PROPER INSTRUCTION DECODING ENTRY IS LOCATED. THE FIRST 8 BYTES*\n*  OF THE SECONDARY DECODING TABLE IS EXPLAINED ABOVE.                *\n         SPACE 2\nEI2EXTAB DS    0F                  SECONDARY EXTENDED DECODING TABLE\n*              EXTENDED OPCODE TABLE EQUATES\n*              --> 1ST 8 BYTE ENTRY\nEIMAXIND EQU   4                   POSITION OF MAX INDEX VALUE ALLOWED X\n                                   (THIS IS A FULLWORD)\nEI#SHIFT EQU   3                   POS OF SHIFT BYTE IN 1ST TAB ENTRY\n         DC    XL3'0',X'5'         BYTE 3 = # BITS TO SHIFT MASK\n         DC    F'8'                MAXIMUM INDEX LIMIT\n         DC    X'1018202830384000' DISPLACEMENTS FROM EI2EXTAB\n         EITAB READ,360,6,0,NO,NM,CK,S,*,RR4,IX,NON,O,O,EIXIOS\n         EITAB PRNT,360,6,0,NO,NM,CK,F,*,RR4,IX,NON,O,O,EIXIOS\n         EITAB PNCH,360,6,0,NO,NM,CK,F,*,RR4,IX,NON,O,O,EIXIOS\n         EITAB DUMP,360,6,0,NO,NM,CK,F,*,RR4,IX,NON,O,O,EIXIOS\n         EITAB LIMD,360,6,0,NO,NM,CK,*,*,RR4,IX,NON,O,O,EIXIOS\n         EITAB  GET,360,6,0,NO,NM,CK,S,*,RR4,IX,NON,O,O,EIXIOS\n         EITAB  PUT,360,6,0,NO,NM,CK,F,*,RR4,IX,NON,O,O,EIXIOS\n.EINONE  ANOP\n//*\n//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n//* STEP 2 - APPLY CHANGES TO SOURCE IN TEMPORARY DATASETS.\n//*          (MAKE ANY DESIRED CHANGES TO THE STATEMENTS BELOW.)\n//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n//*\n//UPDATEA.SYSIN DD *\n./ CHANGE\n&$GENDAT SETC  '&SYSDATE'          CURRENT GENERATION DATE            J\n&$IDF    SETA  20000000            LARGE VAL - USE TIMER INSTEAD\n&$IMX    SETA  20000000            LARGE VAL - USE TIMER INSTEAD\n&$SYSTEM SETC  'OS-MVS'            SYSTEM IS OS OPTION MVS\n&$S370   SETA  1                   S/370 INSTRUCTION SET\n&$VERSLV SETC  '4.0/A2'            CURRENT ASSIST VERSION             J\n&$IOUNIT(2)  SETC  'SYSIN2  '      SET OS SECONDARY INPUT\n&$IOUNIT(3)  SETC  'SYSPRINT'      SET OS PRINTER\n&$IOUNIT(4)  SETC  'SYSPUNCH'      SET OS PUNCH\n&$IOUNIT(5)  SETC  'SYSUT1  '      SET OS DISK INTERMEDIATE\n//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n//* THE CHANGES BELOW WERE REQUIRED TO CORRECT SOME PROBLEMS IN THE\n//* ORIGINAL SOURCE.  YOU SHOULD NOT MAKE CHANGES HERE YOURSELF.\n//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n//UPDATEB.SYSIN DD *\n./ CHANGE\n&XSAVE   DC    18F'0'  .           SAVE AREA\n         LH    RA,CNDOCNT          GET LENGTH-1 CURRENTLY READY\n.UTE1A1  ANOP\n         TITLE '*** ECBRSTKD - DSECT FOR THE EXT''D INT BRANCH STACK'\n         END\n//*\n//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n//* STEP 3 - ASSEMBLE AND LINK-EDIT ASSIST.\n//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n//*\n//ASM      EXEC ASMFCL,REGION.ASM=4096K,\n//             PARM.ASM='LOAD,NODECK,LIST,NOXREF',\n//             MAC1='SYS1.AMODGEN'\n//ASM.SYSUT1 DD UNIT=SYSDA,SPACE=(1700,(1500,500))\n//ASM.SYSUT2 DD UNIT=SYSDA,SPACE=(1700,(1500,500))\n//ASM.SYSUT3 DD UNIT=SYSDA,SPACE=(1700,(1500,500))\n//ASM.SYSPRINT DD SYSOUT=*\n//ASM.SYSGO DD UNIT=SYSDA,SPACE=(80,(1500,100))\n//ASM.SYSIN DD DSN=&&ASSRCM1,DISP=(OLD,DELETE)\n//          DD DSN=&&ASSRCM2,DISP=(OLD,DELETE)\n//LKED.SYSLMOD DD DSN=SYS2.LINKLIB,DISP=SHR      <== TARGET LIBRARY\n//LKED.SYSUT1 DD SPACE=(1024,(250,20))\n//LKED.SYSPRINT DD SYSOUT=*\n//LKED.SYSIN DD *\n  NAME ASSIST(R)\n//*\n//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n//* STEP 4 - ADD X??? MACROS TO SYS1.MACLIB.\n//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n//*\n//MACROS   EXEC PGM=IEBUPDTE,PARM=NEW\n//SYSPRINT DD  SYSOUT=*\n//SYSUT2   DD  DISP=SHR,DSN=SYS1.MACLIB          <== TARGET LIBRARY\n//SYSIN    DD  *\n./ ADD LEVEL=40,SOURCE=0,NAME=EQUREGS\n         MACRO\n&LABEL   EQUREGS &L=R,&DO=(0,15,1),&SYM=\n.*--> MACRO: EQUREGS    GENERATE SYMBOLIC REGISTER EQUATES  . . . . . .\n.*                                 JOHN R. MASHEY/JULY'69/PSU 360/67  *\n.*       MACRO FOR SETTING UP SETS OF REGISTER EQUATES.               *\n.*       *** ARGUMENTS ***                                            *\n.*       L=        SYMBOL USED TO BEGIN EQUATES, SUCH AS R, REG,ETC.  *\n.*       DO=       (INITIAL,LIMIT,INCREMENT) WILL SET UP REGISTERS    *\n.*             EQUATED TO THE VALUE AS CONTROLLED BY THE DO PARAMATER.*\n.*             BEHAVES LIKE FORTRAN DO, INCLUDING ABILITY TO LEAVE OUT*\n.*             INCREMENT.                                             *\n.*       SYM=      LIST OF SYMBOLS TO BE CONCATENATED TO L PARM.      *\n.*             LIST WILL SET UP EQUATES INCLUDING SYM VALUES, FOR     *\n.*             FIRST SET OF EQUATES IN LIST, AND WILL THEN SET UP     *\n.*             NUMERIC EQUATES IF DO VALUES EXCEED NUMBER OF ELEMENTS *\n.*             IN SYM OPERAND.  MAY BE OMITTED ENTIRELY.              *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         LCLA  &I,&J,&K            COUNTER,INCREMENT,SYM COUNTER\n         AIF   (N'&DO LT 2).XERROR           NOT ENOUGH ARGUMENTS-ERR\n&K       SETA  1                   INIT\n&I       SETA  &DO(1)              SET TO INITIAL VALUE\n&J       SETA  1                   SET TO DEFAULT VALUE\n         AIF   (N'&DO LT 3).XLOOP            DEFAULT VALUE IS OK\n&J       SETA  &DO(3)              USE VALUE PROVIDED\n.XLOOP   AIF   ('&SYM(&K)' EQ '').XLOOP1     USE NUMBER IF NO SYM VAL\n&L&SYM(&K) EQU &I\n&K       SETA  &K+1      INCREMENT TO GET NEXT SYM OPERAND\n         AGO   .XLOOP2             SKIP OVER NORMAL GENRATION\n.XLOOP1  ANOP\n&L&I     EQU   &I\n.XLOOP2  ANOP\n&I       SETA  &I+&J               ADD INCREMENT TO COUNTER\n         AIF   (&I LE &DO(2)).XLOOP          CONTINUE UNTIL DONE\n         MEXIT\n.XERROR  MNOTE 0,'** ERROR - EQUREGS REQUIRES AT LEAST 2 VALUES IN DO'\n         MEND\n./ ADD LEVEL=40,SOURCE=0,NAME=XCHAR\n         MACRO\n         XCHAR &STRING,&NUM\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: XCHAR      RETURN SAFE RIGHT-END SUBSTRING OF A STRING.  *\n.*                                     JOHN R. MASHEY-JULY 1969-360/67*\n.*       THIS MACRO RETURNS IN &XXCHAR THE &NUM CHARACTERS TAKEN FROM *\n.*       THE RIGHT END OF THE CHARACTER STRING &STRING, WITHOUT       *\n.*       BLOWING UP IF THERE ARE LESS THAN &NUM CHARS IN &STRING.     *\n.*       THIS MACRO IS USED BY XSAVE,XRETURN, AND XSRNR               *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         GBLC  &XXCHAR             RETURN RESULT IN THIS\n         AIF   (&NUM GT K'&STRING).XGA       SKIP IF HE WANTS MORE\n&XXCHAR  SETC  '&STRING'(K'&STRING+1-&NUM,&NUM)        SCOOP RIGHT AMT\n         MEXIT\n.XGA     ANOP\n&XXCHAR  SETC  '&STRING'           STRING SMALLER-USE WHOLE THING\n         MEND\n./ ADD LEVEL=40,SOURCE=0,NAME=XDECI\n         MACRO\n&LABEL   XDECI &REG,&ADDRESS\n.*--> MACRO: XDECI      EXTENDED DECIMAL INPUT CONVERSION * * * * * * *\n.*             EXTENDED DECIMAL INPUT MACRO - ENABLES PROGRAMS        *\n.*       WRITTEN FOR ASSIST TO BE RUN UNDER OS/360 DIRECTLY.          *\n.*       USES MODULE XXXXDECI TO SCAN DECIMAL STRING BEGINNING AT     *\n.*       &ADDRESS, CONVERT ITS VALUE INTO REGISTER &REG, AND SET      *\n.*       REGISTER R1 AS A SCAN POINTER TO THE DELIMITER FOLLOWING THE *\n.*       STRING OF DECIMAL DIGITS.  THE CONDITION CODE IS SET BY THE  *\n.*       VALUE IN &REG, UNLESS AN ERROR OCCURRS, IN WHICH CASE CC=3.  *\n.*       SEE ASSIST USER MANUAL FOR USAGE INSTRUCTIONS.               *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         LCLC  &XLABL              FOR CREATION OF LABEL\n&XLABL   SETC  'XX&SYSNDX.E'       CREATE UNIQUE LABEL\n         CNOP  2,4  .              LINE UP ON BOUNDARY\n&LABEL   STM   14,1,&XLABL  .      SAVE LINKAGE REGS\n         LA    0,&ADDRESS .        BEGINNING @ FOR SCANNING\n         L     15,&XLABL-4  .      GET ADCON FOR CONVERSION\n         BALR  14,15 .             CALL ROUTINE, PT WITH R14\n         DC    V(XXXXDECI) .       ADCON FOR CONVERSION ROUTINE\n&XLABL   DS    5F .                REGS 14,15,0,1, VALUE FOR &REG\n         LM    14,1,4(14) .        RELOAD REGS\n         BO    *+8 .               BRANCH IF &REG SHOULDN'T CHANGE\n         L     &REG,&XLABL+16  .   GET VALUE FOR &REG\n         AIF   (T'&REG EQ 'N' AND '&REG' NE '1').XXEXIT SKIP IF SAFE\n         L     1,&XLABL+12  .      USER MAY HAVE REG=1, LOAD FOR SAFE\n.XXEXIT  MEND\n./ ADD LEVEL=40,SOURCE=0,NAME=XDECO\n         MACRO\n&LABEL   XDECO &REG,&ADDRESS\n.*--> MACRO: XDECO      EXTENDED DECIMAL OUTPUT CONVERSION* * * * * * *\n.*       USES MODULE XXXXDECO TO CONVERT VALUE IN REGISTER &REG TO    *\n.*       AN EDITED 12-BYTE FIELD, WITH SIGN, AT LOCATION &ADDRESS.    *\n.*             EXTENDED DECIMAL OUTPUT MACRO - ENABLES PROGRAMS       *\n.*       WRITTEN FOR ASSIST TO BE RUN UNDER OS/360 DIRECTLY.          *\n.*       SEE ASSIST USER MANUAL FOR USAGE INSTRUCTIONS.               *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         LCLC  &XLABL              FOR CREATION OF UNIQUE LABEL\n&XLABL   SETC  'XX&SYSNDX.D'       CREATE UNIQUE LABEL\n         CNOP  2,4 .               LINE UP ON RIGHT BOUNDARY\n&LABEL   STM   14,0,&XLABL  .      STORE LINKAGE REGS\n         ST    &REG,&XLABL+12  .   SAVE VALUE TO BE CONVERTED\n         LA    0,&ADDRESS .        OBTAIN @ OPERAND FILED\n         L     15,&XLABL-4  .      GET ADCON FOR CONVERSION PROG\n         BALR  14,15 .             CALL XXXXDECO, PT R14\n         DC    V(XXXXDECO) .       ADCON FOR CONVERSION PROG\n&XLABL   DS    4F .                REGS 14,15,0, REG TO BE CONVERTED\n         LM    14,0,4(14) .        RELOAD LINKAGE REGISTERS\n         MEND\n./ ADD LEVEL=40,SOURCE=0,NAME=XDUMP\n         MACRO\n&LABEL   XDUMP &AREA,&LENGTH\n.*--> MACRO: XDUMP      ASSIST COMPATIBILITY DUMP MACRO . . . . . . . .\n.*             MACRO FOR STORAGE AND REGISTER DUMPING. ENABLES        *\n.*       PROGRAMS WRITTEN FOR ASSIST TO BE RUN DIRECTLY UNDER OS/360. *\n.*       SEE ASSIST USER MANUAL FOR USAGE *\n.*       *NOTE* USES XSNAP, SO REQUIRES XSNAPOUT DD SYOUT=A CARD.     *\n.*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n         AIF   (T'&AREA EQ 'O').XREGS   SKIP TO REGS IF NO OPS\n         AIF   (T'&LENGTH EQ 'O').XSTDF DEFAULT LENGTH IF NONE\n.*             DUMP STORAGE, USING SUPPLIED LENGTH &LENGTH.\n&LABEL   XSNAP T=NO,LABEL='USER STORAGE',                              #\n               STORAGE=(*&AREA,*&LENGTH+&AREA)\n         MEXIT\n.*             DUMP STORAGE, USING DEFAULT LENGTH OF 4.\n.XSTDF   ANOP\n&LABEL   XSNAP T=NO,LABEL='USER STORAGE',                              #\n               STORAGE=(*&AREA,*4+&AREA)\n         MEXIT\n.*             &AREA,&LENGTH OMITTED --> DUMP REGISTERS.\n.XREGS   ANOP\n&LABEL   XSNAP LABEL='USER REGISTERS'\n         MEND\n./ ADD LEVEL=40,SOURCE=0,NAME=XGET\n         MACRO\n&XLABEL  XGET  &XAREA,&XNUM\n.*--> MACRO: XGET    GET RECORD OFF OF &DDNAME FILE . . . . . . . . . *\n.*                                 RICHARD FOWLER AUG, 1972 V.5.0     *\n.*       MACRO FOR EASY READING OFF OF ANY DD FILE, READS &XNUM       *\n.*       CHARACTERS. CONDITION CODE SET TO 0 NORMALLY, OR TO 1 ON     *\n.*       END OF FILE. GENERATION CONTROLLED BY &XGETST.               *\n.*       EXECUTION ASSUMES REG 1 POINTS TO DD NAME                    *\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **\n         GBLB  &XGETST             GENERATION STATUS- 0=YES, 1=NO\n         AIF   (&XGETST).XNOGEN    IF SHOULDN'T GENERATE-SKIP CALL\n&XLABEL  XIONR XXXXGET,&XNUM,&XAREA,80\n         MEXIT\n.XNOGEN  AIF   (T'&XLABEL EQ 'O').XXEXIT     GEN LABEL ONLY IF NEEDED\n&XLABEL  DS    0H .                LABEL FOR CANCELLED XGET\n.XXEXIT  MEND\n./ ADD LEVEL=40,SOURCE=0,NAME=XGPGEN\n         MACRO\n&LABEL   XGPGEN &DIREC=G,&FETCH=NOT,&DDNUM=20\n.** --> MACRO: XGPGEN  GENERATE GENERAL I/O MODULES . . . . . . . . . .\n.*                                    RICHARD FOWLER NOV, 1972 V.5.0  .\n.*                                                                    .\n.*       ARGUMENTS:                                                   .\n.*             &DIREC = P --> OUTPUT                                  .\n.*                   ^= P --> INPUT                                   .\n.*             &FETCH  =NOT --> NO FETCH PROTECTION                   .\n.*                    ^=NOT -->    FETCH PROTECTION                   .\n.*             &DDNUM = MAXIMUM NUMBER OF DD NAMES ALLOWED AT ONCE    .\n.*     (**EACH DD FILE REQUIRES 3F TABLE ENTRY PLUS DCB AND BUFFER**) .\n.*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n         TITLE ' &LABEL - MODULE CREATED BY XGPGEN'\n         DCBD DSORG=QS\n* * * * * XIOBLOCK - CONTROL BLOCK SET UP BY XREAD/XPRNT/XPNCH  * * * *\nXIOBLOCK DSECT\n         DS    V .                 @ I/O ROUTINE\n         DS    3F                  AREA FOR REGS 15-0 TO BE SAVED\nXIOLENG  DS    AL2 .               LENGTH OF RECORD, (CODES-FUTURE USEQ\nXIORETRN LM    14,0,4(14)          RETURN CODE FOR RESTORING REGISTERS\n&LABEL   CSECT\n*--> CSECT: EXTENDED I/O MODULE FOR GENERAL I/O . . . . . . . . . . . .\n*        THIS MODULE IS CALLED TO DO GENERAL I/O WORK ON A FILE       .\n*              SIMILAR IN OPERATION TO THE XIO ROUTINES, BUT CAN HANDLE\n*              MANY FILES AT ONCE.                                    .\n*        ENTRY CONDITIONS:                                            .\n*          R14 = @ OF CONTROL BLOCK                                   .\n*          R15  = ENTRY POINT ADDRESS                                 .\n*          R0  = ADDRESS OF AREA TO MOVE DATA INTO                    .\n*          R1  = ADDRESS OF DD NAME TO BE USED                        .\n*        CONTROL BLOCK:                                               .\n*      OFFSET  LENGTH        WHAT                                     .\n*        0       1F        ENTRY POINT ADDRESS                        .\n*        4       3F          SAVE AREA                                .\n*        16      2           LENGTH OF AREA                           .\n* . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n         USING *,15 .              NOTE TEMPORARY ADDRESSABILITY\n         USING XIOBLOCK,R14\n         STM   R13,R7,X&DIREC.SAV1 SAVE REGISTERS TO BE USED          A\n         CNOP  0,4 .               GET ON FULLWORD\n         BAL   R13,*+76            SET UP FAKE AREA PNTR - BASE\n         USING *,R13 .             NOTE NEW USING/SAVE AREA POINTER\n         DS    18F .               FAKE SAVE AREA\n         DROP  R15 .               KILL OLD ADDRESSING\n         SPACE 2\n         USING IHADCB,R1 .         SET UP ADDRESSIBILITY TO DCB S\n         MVC   X&DIREC.CURENT(8),0(R1) . GET CURRENT DD NAME\n*   CHECK FOR CLOSE\n         SR    R1,R1               GET ZERO LENGTH INDICATOR\n         CH    R1,XIOLENG          ARE THEY EQUAL?\n         BE    X&DIREC.EOF .       YES-GO CLOSE AND FORGET FILE\n         XXGPSRCH &DIREC\n*  THE FOLLOWING CODE, IF EXECUTED, GENERATES A DCB AND TRIES AN OPEN\n*\nX&DIREC.MAKE C R1,=A(X&DIREC.FULL) CHECK FOR TABLE OVERFLOW\n         BNL   X&DIREC.CC3         NO SPACE, DON'T TRY OPEN-RETURN    J\n         ST    R1,X&DIREC.ELEM .   SAVE NEW ADDRESS, R1 ALREADY POINTIN\n         MVC   0(8,R1),X&DIREC.CURENT  SAVE DD NAME FOR FUTURE CALLS\n         L     0,X&DIREC.LONG\n         GETMAIN R,LV=(0) .        LOAD R1 WITH ADDR OF NEW DCB\n         L     R2,X&DIREC.ELEM .   GET ADDRESS OF POINTER\n         ST    R1,8(R2) .          SAVE @ OF DCB\n*\n         ST    R1,X&DIREC.FULL     KLUDGE TO GET AROUND ADDRESSIBILITY\n         MVC   X&DIREC.OPEN+1(3),X&DIREC.FULL+1  COPY OVER DCB @ INTO J\n*\n         MVC   0(X&DIREC.ELEM-X&DIREC.DCB,R1),X&DIREC.DCB BUILD DCB\n         MVC   DCBDDNAM,X&DIREC.CURENT MOVE DD NAME INTO DCB\n         OPEN  MF=(E,X&DIREC.DCBPTR)  DO REMOTE OPEN\n         L     R1,X&DIREC.FULL .   FIX R1, DESTROYED IN OPEN\n         TM    DCBOFLGS,X'10' .    DID OPEN GO?\n         BO    X&DIREC.CONT4       YES, DO I/O\n*              OPEN DIDN'T GO - CLEAN UP SO DOESN'T BOMB LATER        J\n         L     R0,X&DIREC.LONG     GET LENGTH OF DCB FOR FREEMAIN     J\n         FREEMAIN R,LV=(0),A=(1)   GIVE THE SPACE BACK TO OS          J\n         XC    0(12,R2),0(R2)      CLEAR OUT SO WON'T THINK IT'S OPEN J\nX&DIREC.CC3 TM *+1,X'FF'       SET CC=3  ==> OPEN IMPOSSIBLE          J\n         B     X&DIREC.RET         RETURN TO USER\n         SPACE 2\nX&DIREC.CONT L R1,8(R1) .          GET DCB ADDRESS\nX&DIREC.CONT4 LH R5,XIOLENG        GET LENGTH OF AREA\n         AIF   ('&FETCH' EQ 'PROTECT').SKPFTCH\n         L     R2,X&DIREC.SAV1+12  GET @ I/O AREA\n* THE FOLLOWING CODE IS USED FOR ADDRESS ILLEGAL     ******************\n*****  THIS CODE WILL NOT WORK IF MACHINE HAS FETCH PROTECT ***********\n         SPACE 2\n         L     R4,16 .             GET CVT PNTR FROM LOC 16\n         LA    R0,0(R2,R5) .       GET ENDING ADDRESS OF I/O AREA\n         C     R0,164(R4) .        COMPARE TO CVTMZ00 - HIGHEST ADDRESS\n         BNL   X&DIREC.ABD3 .      GO ABEND IF HIGHER\n.SKPFTCH ANOP\n         AIF   ('&DIREC' EQ 'P').XOUT  SKIP IF OUTPUT\n         LH    R7,DCBLRECL         GET LRECL FROM DCB                 J\n         GET   IHADCB .            GET # BUFFER\n         CLR   R5,R7               COMPARE REQUEST LENGTH TO LRECL    J\n         BNH   *+6                 SKIP AROUND IF OK                  J\n         LR    R5,R7               TOO BIG, USE LRECL INSTEAD         J\n         LR    R4,R5 .             SET UP FOR SHIFT\n         SRDL  R4,8 .              PUT RIGHTMOST BYTE IN R5\n         SRL   R5,24 .             RIGTH JUSTIFY FOR MOVE\n         LTR   R4,R4 .             ANYTHING LEFT IN R4?\n         BE    *+22 .              NO - DO NORMAL MOVE\n         MVC   0(256,R2),0(R1) .   GIVE USER 256 BYTES OF DATA\n         LA    R2,256(R2) .        GO TO NEXT BLOCK\n         LA    R1,256(R1) .        GO TO NEXT BLOCK\n         BCT   R4,*-14 .           IF ANYTHING LEFT IN R4, DO ANOTHER\n*              NORMAL MOVE FOLLOWS\n         LTR   R5,R5 .             IS ANYTHING IN R5?\n         BE    *+10 .              NO - DONT MOVE LEFTOVER BYTES\n         BCTR  R5,0 .              DECREMENT LENGTH BY 1\n         EX    R5,X&DIREC.MOV .    MOVE INTO RIGHT PLACE\n.XCLOSE  ANOP\n         SR    R0,R0 .             SET COND CODE TO 0, USER OK\n         B     X&DIREC.RET .       GO TO RETURNX&DIREC.EOF CLOSE IHADCB\nX&DIREC.EOF EQU *\n         XXGPSRCH &DIREC,2\nX&DIREC.MAKE2 B X&DIREC.RET .      GO RETURN\nX&DIREC.CONT2 LR R4,R1 .           SAVE THE ADDRESS\n         MVC   X&DIREC.PTR+1(3),9(R1)\n         LA    R1,X&DIREC.PTR\n         CLOSE MF=(E,(1))          DO REMOTE CLOSE\n         L     R1,8(R4) .          POINT TO DCB TO FREE\n         FREEPOOL (1)              FREE THE BUFFERS\n         L     R1,8(R4)            RESET R1 IN CASE DESTROYED\n         L     R0,X&DIREC.LONG     GET AMOUNT TO FREE\n         FREEMAIN R,LV=(0),A=(1)\n*\n*   DCB NO LONGER EXISTS,  REMOVE CORRESPONDING ELEMENT FROM LIST\n*\n         LA    R3,X&DIREC.FULL .    GET UPPER ADDRESS OF TABLE\n         SR    R3,R4   .           FIND LENGTH OF REST OF TABLE\n         EX    R3,X&DIREC.WIPOUT   WIPEOUT 12 BYTES OF MEMORY\n*\n*      IF NO POINTERS REMAIN, SET POINTER TO LAST TO ZERO\n*\n         LA    R3,12\n       L       R2,X&DIREC.ELEM\n         SR    R2,R3\n         LA    R1,X&DIREC.PNTSRT\n         CR    R1,R2\n         BNH   *+8\n         LA    R2,0 .              SET POINTER TO ZERO\n         ST    R2,X&DIREC.ELEM     SAVE POINTER\n         AIF   ('&DIREC' EQ 'P').XRET\n         OI    *+1,1 .             SET COND CODE FOR END OF FILE\n.*       SHOULD REMOVE DCB FROM LIST NOW\n         AGO   .XRET .             HAVE RETURN CODE GENERATED\n.*\n.XOUT    ANOP\n         LH    R7,82(R1) .         GET LRECL\n         PUT   IHADCB .            PRINT THE STUFF\n         CLR   R5,R7               COMPARE REQUEST LENGTH TO LRECL    J\n         BNH   *+6                 SKIP AROUND IF OK LENGTH           J\n         LR    R5,R7               TOO BIG- USE LRECL INSTEAD         J\n         LR    R4,R5 .             SET UP FOR SHIFT\n         LR    R6,R5               SAVE FOR LATER\n         SRDL  R4,8 .              PUT RIGHTMOST BYTE IN R5\n         SRL   R5,24 .             RIGTH JUSTIFY FOR MOVE\n         LTR   R4,R4 .             ANYTHING LEFT IN R4?\n         BE    *+22 .              NO - DO NORMAL MOVE\n         MVC   0(256,R1),0(R2) .   PUT STUFF INTO BUFFER\n         LA    R2,256(R2) .        GO TO NEXT BLOCK\n         LA    R1,256(R1) .        GO TO NEXT BLOCK\n         BCT   R4,*-14 .           IF ANYTHING LEFT IN R4, DO ANOTHER\n*              NORMAL MOVE FOLLOWS\n         LTR   R5,R5 .             IS ANYTHING IN R5?\n         BE    *+12\n         BCTR  R5,0 .              DECREMENT LENGTH BY 1\n         EX    R5,X&DIREC.MOV .    MOVE INTO RIGHT PLACE\n         AR    R1,R5               GET BEGINNING @ TO BLANK\n         SR    R7,R6               GET DIFFERENCE BETWEEN USER AND DCB\n         BZ    *+12                NO DIFFERENCE, DO NOTHING          A\n         MVI   1(R1),C' '\n         EX    R7,X&DIREC.MOV2     CLEAR REST\n*  ****NOTE THAT THIS ONLY WORKS FOR DIFFERENCES < 256\n         AGO   .XCLOSE\n.*\n.XRET    ANOP\n         SPACE 2\nX&DIREC.RET LM R13,R7,X&DIREC.SAV1 RESTORE REGS                       A\n         B     XIORETRN            RETURN\n         DROP  R14\nX&DIREC.ABD3 CLI  *,0              SET CC=2, SHOW EXECUTE ERROR       J\n         B     X&DIREC.RET         GO RETURN, SHOWING ERROR           J\n.*\n         SPACE 2\nX&DIREC.PTR CLOSE (X&DIREC.CONT),MF=L    GENERAL PURPOSE CLOSE\nX&DIREC.WIPOUT MVC 0(1,R4),12(R4)\nX&DIREC.CURENT DS  CL8  .          AREA TO HOLD CURRENT DD NAME\nX&DIREC.SAV1 DS 11F                SAVE AREA FOR REGS USED            A\nX&DIREC.PNTSRT DS (&DDNUM*3)F .    AREA FOR DDNUM DD NAMES & POINTERS\nX&DIREC.FULL DS F\nX&DIREC.OPEN DS 0F                 EXTRA LABEL\n         AIF   ('&DIREC' EQ 'P').XDEFSR  SKIP IF OUTPUT\nX&DIREC.DCBPTR OPEN (X&DIREC.CONT,(INPUT)),MF=L  OPEN CONTROL WORD    J\nX&DIREC.DCB DCB DSORG=PS,MACRF=GL,EODAD=X&DIREC.EOF\nX&DIREC.ELEM DC  F'0' .            INITIAL # OF ELEMENTS\nXX&DIREC.LONG EQU X&DIREC.ELEM-X&DIREC.DCB   GET DCB LENGTH\nX&DIREC.LONG DC A(XX&DIREC.LONG)   SAVE LENGTH OF DCB\nX&DIREC.MOV MVC 0(1,R2),0(R1) .    GIVES USER THE DATA\n         LTORG\n         DROP  R13\n         MEXIT                     DONE\n.XDEFSR  ANOP\nX&DIREC.DCBPTR OPEN (X&DIREC.CONT,(OUTPUT)),MF=L OPEN CONTROL WORD    J\nX&DIREC.DCB DCB DSORG=PS,MACRF=PL\nX&DIREC.ELEM DC F'0' .             INITIAL # OF ELEMENTS\nXX&DIREC.LONG EQU X&DIREC.ELEM-X&DIREC.DCB   GET DCB LENGTH\nX&DIREC.LONG DC A(XX&DIREC.LONG)   SAVE LENGTH OF DCB\nX&DIREC.MOV MVC 0(1,R1),0(R2) .    MOVE INTO LINE\nX&DIREC.MOV2 MVC 2(1,R1),1(R1)     CLEAR OUT REST OF BUFFER\n         LTORG\n         DROP  R13\n         MEND\n./ ADD LEVEL=41,SOURCE=0,NAME=XHEXI\n         MACRO\n&NAME    XHEXI &REG,&ADDR\n.*                                                                    *\n.*-->MACRO: XHEXI  HEXADECIMAL INPUT CONVERSION MACRO.                *\n.*                                WRITTEN BY ALAN ARTZ 4/17/72        *\n.*       THIS MACRO TAKES THE VALUE STARTING AT THE ADDRESS GIVEN BY  *\n.*  &ADDR AND CONVERTS IT AND PUTS THE HEXADECIMAL VALUE IN &REG.     *\n.*  IF THERE ARE MORE THAN 8 DIGITS, R1 POINTS TO THE 9TH AND THE     *\n.*  FIRST 8 ARE CONVERTED.  IF THERE IS A NON-BLANK, NON-HEX DIGIT    *\n.*  FOUND, R1 POINTS TO THAT CHARACTER AND THE CC=3, OTHERWISE CC SET *\n.*  BY VALUE IN REG.                                                  *\n.*                                                                    *\n.*       CALLS MODULE XXXXHEXI TO DO THE ACTUAL CONVERSIONS           *\n.*                                                                    *\n.**********************************************************************\n         LCLC  &LABEL\n&LABEL   SETC  'XX&SYSNDX.H'      UNIQUE LABEL\n&NAME    STM   14,0,&LABEL  .      SAVE REGISTERS\n         ST    &REG,&LABEL+12  .  REGISTER STORE INCASE OF OVERFLOW CND\n         LA    0,&ADDR  .         GET STRING TO BE CONVERTED\n         CNOP  2,4  .              GET PROPER ALIGNMENT\n         L     15,&LABEL-4  .     ADDRESS OF XXXXHEXI\n         BALR  14,15  .            GO TO APPROPRIATE PLACE\n         DC    V(XXXXHEXI)  .      VCON OF ROUTINE\n&LABEL   DS    4F  .              STORAGE FOR REGISTERS\n         LM    14,0,4(14)  .       RESTORE REGISTERS\n         L     &REG,&LABEL+12  .  GET CONVERTED NUMBER\n         MEND\n./ ADD LEVEL=41,SOURCE=0,NAME=XHEXO\n         MACRO\n&NAME    XHEXO &REG,&ADDR\n         LCLC  &LABEL\n.*                                                                    *\n.*-->MARCO: XHEXO  HEXADECIMAL OUTPUT CONVERSION MACRO                *\n.*                                WRITTEN BY ALAN ARTZ 4/17/72        *\n.*       THIS MACRO TAKES THE VALUE IN & REG AND CONVERTS IT TO       *\n.*  PRINTABLE FORM.                                                   *\n.*       IT PUTS THE CONVERTED VALUE IN AN EIGHT BYTE AREA STARTING AT*\n.* THE ADDRESS GIVEN IN &ADDR.                                        *\n.*      THE CONDITION CODE IS NOT CHANGED AND NETHER ARE THE REGISTERS*\n.*                                                                    *\n.*       CALLS MODULE XXXXHEXO TO DO THE ACTUAL CONVERSIONS.          *\n.*                                                                    *\n.**********************************************************************\n&LABEL   SETC  'XX&SYSNDX.H'      UNIQUE LABEL\n&NAME    DS    0H\n         STM   14,0,&LABEL  .      SAVE REGIST5RS\n         ST    &REG,&LABEL+12  .    SAVE REGISTER\n         LA    0,&ADDR   .        PASS REGISTER TO XXXXHEXO\n         CNOP  2,4  .              GDT PROPER ALIGNMENT\n         L     15,&LABEL-4  .     ADDRESS OF XXXXHEXO\n         BALR  14,15  .            CALL HEXO\n         DC    V(XXXXHEXO)\n&LABEL   DS    4F  .              STORAGE FOR REGISTERS\n         LM    14,0,&LABEL  .     RESTORE REGISTERS\n         MEND\n./ ADD LEVEL=40,SOURCE=0,NAME=XIDENT\n         MACRO\n         XIDENT &ID,&LABEL,&XCSECT,&PRIVATE\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: XIDENT     IDENTIFY ENTRY POINT FOR XSAVE,$SAVE.         *\n.*       MACRO USED BY XSAVE TO PRODUCE ID AT AN ENTRY POINT.  WILL   *\n.*       USE THE FIRST NON-NULL OPERAND PASSED TO IT AS THE ID.       *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         LCLA  &I,&J                LOCAL COUNTERS\n&I       SETA  1                    INITIALIZE\n         AIF   ('&ID' NE '*').XIDINC         SKIP IF EXPLICIT ID FIELD\n.XILOOP  ANOP\n&I       SETA  &I+1                 INCREMENT TO NEXT ONE\n         AIF   ('&SYSLIST(&I)' EQ '').XILOOP SKIP BACK IF THIS IS NULL\n.XIDINC  ANOP\n&J       SETA  6+((K'&SYSLIST(&I)+1)/2)*2   GET BRANCH LENGTH\n         B     &J.(,15) .           BRANCH AROUND ID\n&J       SETA  &J-5                 GET ACTUAL LENGTH OF ID\n         DC    AL1(&J),CL&J'&SYSLIST(&I)'\n         MEND\n./ ADD LEVEL=40,SOURCE=0,NAME=XIOGN\n         MACRO\n&XLABEL  XIOGN  &LRECL=80,&BLKSIZE=80,&XOP=OUTPUT,&RECFM=,&DDNAME=,    #\n               &BUFNO=1\n.*--> MACRO: XIOGN      I/O SUPPORT MODULE GENERATION . . . . . . . . .\n.*                                 JOHN R. MASHEY - FEB 1970 - V.5.0  *\n.*       MACRO USED TO GENERATE THE I/O CSECTS USED BY THE XIOPAK     *\n.*       MACROS XREAD,XPRNT,XPNCH.  THE CSECTS ARE CALLED EACH TIME   *\n.*       ONE OF THE MACROS IS CALLED, AND DOES REQUIRED OPN'S, GET'S, *\n.*       PUT'S, ETC .                                                 *\n.*       **ARGUMENTS**                                                *\n.*       BLKSIZE,BUFNO,LRECL,RECFM=    ARGUMENTS FOR CREATED DCB.     *\n.*             DEFAULTS: BLKSIZE=80,BUFNO=1,LRECL=80.                 *\n.*             IF MODULE DESIRED FOR USE WITH VARIABLE JCL VALUES,    *\n.*             CODE BLKSIZE=0,BUFNO=0,LRECL=0.                        *\n.*       XOP= EITHER INPUT OR OUTPUT, DENOTING DIRECTION OF I/O.      *\n.*             DEFAULT: OUTPUT.                                       *\n.*       DDNAME=   LIST OF DDNAMES WHICH MODULE CAN USE FOR I/O.      *\n.*             WILL ATTEMPT OPEN OF EACH ONE, IN ORDER GIVEN, UNTIL   *\n.*             ONE SUCCEEDS OR LIST IS EXHAUSTED.                     *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         GBLB  &XIOGNST            =0 ==> HAVEN'T GEND XIOBLOCK\n         LCLA  &XDD                COUNTER FOR # DDNAMES\n         LCLB  &XIO                OUTPUT=1,INPUT=0\n         LCLC  &X                  PREFIX OF ALL LABELS\n&XDD     SETA  N'&DDNAME           GET # OF DDNAMES TO BE TRIED\n&XIO     SETB  ('&XOP' EQ 'OUTPUT')          SET FOR INPUT OR OUTPUT\n&X       SETC  '&XLABEL'(3,4)      GET LABEL START\n        TITLE  ' *** &XLABEL *** I/O ROUTINE'\n&XLABEL  CSECT\n         ENTRY &X.DCB\n         USING XIOBLOCK,R14 .      NOTE POINTER TO CONTROL BLOCK\n         USING *,R15 .             NOTE TEMPORARY ADDRESSIBILITY\n         STM   R13,R5,&X.SAV1   .  SAVE REGS WHICH WILL BE USED\n         CNOP  0,4 .               MAKE SURE ALIGNED ON FULLWORD\n         BAL   R13,*+76 .          SET UP FAKE SAVE AREA PTR,BASE\n         USING *,R13 .             NOTE NEW USING/SAVE AREA POINTER\n         DS    18F .               FAKE SAVE AREA,FOR GET/PUT ETC\n         DROP  R15 .               KILL OLD ADDRESSING\n         SPACE 2\n.XASA1   AIF   (&XIO).XOUT         SKIP IF OUTPUT\n&X.EOFT  NOP   &X.ABD2  .          *** WILL BECOME A B AFTER EOF EXIT\n.XOUT    ANOP\n&X.TES1  NOP   &X.GO   .           *** WILL BE A BRANCH AFTER OPEN GOES\n         LR    R5,R14              SAVE R14 AROUND CALL TO XXXXOPEN\n         LA    1,&X.OPBK .         GET ADDRESS OF CONTROL TABLE\n         L     15,&X.OPAD .        GET BRANCH ADDRESS\n         BALR  14,15 .             CALL XXXXOPEN ROUTINE\n         LR    R14,R5              RESTORE R14\n&X.OPOK  MVI   &X.TES1+1,X'F0'  .  CHANGE NOP TO B-DONT OPEN AGAIN\n&X.GO    LH    R4,&X.DCB+82 .      GET DCB LRECL FOR COMPARISON\n         LH    R5,XIOLENG .        GET LENGTH FROM CONTROL BLOCK\n         BCTR  R5,0 .              DECREMENT TO LENGTH-1\n         CLR   R4,R5 .             COMPARE WITH LIMIT\n         BH    *+8 .               SKIP IF WITHIN RANGE\n         LR    R5,R4 .             MOVE DEFAULT VALUE OVER\n         BCTR  R5,0 .              DECREMENT DEFAULT TO LENGTH-1\n.XASB    SPACE 2\n         L     R2,&X.SAV1+12 .     GET ADDRESS OF I/O AREA (FROM R0)\n.*\n*        THE FOLLOWING CODE IS USED TO CHECK FOR ADDRESS ILLEGAL      *\n*        THIS CODE WILL NOT WORK IF MACHINE HAS FETCH PROTECT**********\n         L     R1,16 .             GET CVT POINTER FROM LOC 16\n         LA    R0,1(R2,R5) .       GET ENDING ADDRESS OF I/O AREA\n         C     R0,164(R1) .        COMPARE TO CVTMZ00-HGIHEST ADDRESS\n         BNL   &X.ABD3   .         GO ABEND IF HIGHER\n.*\n         AIF   (&XIO).XOUT1        SKIP IF OUTPUT MODE\n         GET   &X.DCB              OBTAIN @ BUFFER\n         EX    R5,&X.MOV  .        MOVE REQUESTED NUMBER OF BYTES\n         SR    R0,R0 .             SET CONDITION CODE=0, SHOW USER OK\n         B     &X.RET  .           GO TO RETURN TO CALLER\n&X.ABD2  WTO   ' &XLABEL ABEND 300 - ATTEMPT TO READ PAST END-OF-FILE',X\n               ROUTCDE=11\n         B     &X.ABD1  .          GO ABEND\n&X.EOF   CLOSE &X.DCB\n         LA    1,&X.DCB            POINT 1 TO DCB TO FREE BUFFER\n         FREEPOOL (1)              FREE THE BUFFERS\n         OI    *+1,1  .            SET CONDITON CODE TO 1\n         MVI   &X.EOFT+1,X'F0'  .  CHANGE NOP TO B-NO MORE READS\n         AGO   .XRET               HAVE RETURN CODE GENRATED\n.*\n.XOUT1   EX    R5,&X.MOV  .        MOVE NUMBER OF BYTES TO OUTPUT LINE\n         PUT   &X.DCB,&X.BUF\n         EX    R5,&X.MOV1  .       REBLANK OUTPUT LINE\n.*\n.XRET    ANOP\n         SPACE 2\n&X.RET   LM    R13,R5,&X.SAV1  .   RESTORE THE REGS WE CHANGED\n         AIF   (NOT &XIO).XOUT2    SKIP SPM IF THIS WAS AN INPUT\n         SPM   R14 .               RESTORE THE CONDITION CODE\n.XOUT2   B     XIORETRN .          RETURN TO CALLING XIOBLOCK\n&X.ABD3  WTO   ' &XLABEL ABEND 300-ILLEGAL ADDRESS-SEE REG 2',         X\n               ROUTCDE=11\n&X.ABD1  ABEND 300,DUMP\n.*\n         SPACE 2\n&X.SAV1  DS    9F .                AREA TO PRESERVE REGS IN\n&X.OPAD  DC    V(XXXXOPEN) .       ADDRESS OF SUPEROPEN ROUTINE\n&X.OPBK  XOPENBLK &X.DCB,&XLABEL,&DDNAME,RECFM=&RECFM,LRECL=&LRECL,    #\n               BLKSIZE=&BLKSIZE,BUFNO=&BUFNO,XOP=&XOP\n.XNODD   AIF   (&XIO).XOUT3        SKIP IF OUTPUT\n.*\n&X.MOV   MVC   0(0,R2),0(R1) .     R1==> BUFFER, EXECUTE SUPPLIES LENGT\n&X.DCB   DCB   DSORG=PS,MACRF=GL,EODAD=&X.EOF\n         AGO   .XEXIT\n.*\n.XOUT3   ANOP\n&X.BUF   DC    CL(&LRECL)' ' .     OUTPUT I/O BUFFER AREA\n&X.BLNK  DC    CL(&LRECL)' ' .     FOR REBLANKING OUTPUT BUFFER\n&X.MOV   MVC   &X.BUF(0),0(R2)  .  MOVE RIGHT NUMBER OF CHARS TO BUFFER\n&X.MOV1  MVC   &X.BUF(0),&X.BLNK   EXECUTED MOVE TO REBLANK BUFFER\n&X.DCB   DCB   DSORG=PS,MACRF=PM\n.XEXIT   DROP  R13,R14 .           KILL LEFTOVER ADDRESSING\n.*\n         AIF   (&XIOGNST).XXEXIT   SKIP IF ALREADY GEND XIOBLOCK\n&XIOGNST SETB  (1)                 SHOW WE'VE GENERATE XIOBLOCK\n         EJECT\n* * * * * XIOBLOCK - CONTROL BLOCK SET UP BY XREAD/XPRNT/XPNCH  * * * *\nXIOBLOCK DSECT\n         DS    V .                 @ I/O ROUTINE\n         DS    3F                  AREA FOR REGS 15-0 TO BE SAVED\nXIOLENG  DS    AL2 .               LENGTH OF RECORD, (CODES-FUTURE USEQ\nXIORETRN LM    14,0,4(14)          RETURN CODE FOR RESTORING REGISTERS\n.XXEXIT  MEND\n./ ADD LEVEL=40,SOURCE=0,NAME=XIONR\n         MACRO\n&XLABEL  XIONR &XNAME,&XNUM,&XAREA,&XDEFT\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: XIONR      INNER MACRO-$READ,$PNCH,$PRNT,$SORC           *\n.*                                 JOHN R. MASHEY - FEB 1970 - V.5.0  *\n.*       XIONR IS USED BY XIOPAK MACROS XREAD,XPRNT,XPNCH TO SET UP   *\n.*       THE REQUIRED CODE FOR CALLING THEIR RESPECTIVE SUBROUTINES.  *\n.*       *** ARGUMENTS ***                                            *\n.*       XNAME     THE NAME OF THE I/O ROUTINE TO BE CALLED.          *\n.*       XNUM      THE LENGTH OF XAREA TO BE PRINTED,PUNCHED,ETC.     *\n.*       XAREA     THE AREA ON WHICH I/O OPERATION TO BE PERFORMED.   *\n.*             MAY BE SPECIFIED BY (0) OR (R0).                       *\n.*       XDEFT     DEFAULT VALUE OF XNUM TO BE USED, IF IT IS OMITTED *\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **\n.*                                                                    *\n.*       AS OF AUG 1972, XGET AND XPUT ALSO USE THIS MACRO.           *\n.*                                     RICHARD FOWLER                 *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         AIF   (T'&XAREA EQ 'O').XERR1       PRODUCE MNOTE\n&XLABEL  STM   14,0,XX&SYSNDX.R+4 .    SAVE REGS WHICH WILL BE CHANGED\n         AIF   (T'&XNUM EQ 'O').XN1    SKIP NEXT CHECK IF OMITTED\n         AIF   ('&XNUM'(1,1) NE '(' OR '&XNUM'(K'&XNUM,1) NE ')').XN1\n         STH   &XNUM,XX&SYSNDX.R+16 .       STORE LENGTH\n.XN1     AIF   ('&XAREA' EQ '(0)' OR '&XAREA' EQ '(R0)').XNOLA\n.XN2     LA    0,&XAREA\n.XNOLA   L     15,XX&SYSNDX.R  .   GET BRANCH ADDRESS\n         CNOP  2,4  .              ADJUST FOR RIGHT ALIGNEMNT\n         BALR  14,15 .             CALL ROUTINE, R14==> CONTROL BLOCK\nXX&SYSNDX.R DC V(&XNAME)  .        ROUTINE ADDRESS\n         DS    3F .                SAVE SPACE FOR REGS 14-0\n         AIF   ('&XNUM' EQ '').XDFT         SKIP IF DEFAULT SHOULD BE\n         DC    AL2(&XNUM) .        LENGTH OF AREA\n         AGO   .XDS                SKIP\n.XDFT    DC    AL2(&XDEFT) .       DEFAULT LENGTH USED\n.XDS     LM    14,0,4(14) .        RESTORE REGS. CON CODE ALREADY DONE\n         MEXIT\n.XERR1   MNOTE 0,'**XIONR- AREA ADDRESS OMITTED-GENERATION CANCELLED'\n         MEND\n./ ADD LEVEL=40,SOURCE=0,NAME=XLIMD\n         MACRO\n&XLABEL  XLIMD &ADDR,&LENGTH\n.*--> MACRO: XLIMD      LIMIT DUMP-ASSIST COMPATIBILITY MACRO . . . . .\n.*.      MACRO PROVIDED ONLY FOR RUNNING ASSIST DECKS UNDER OS/360.   .\n.*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n&XLABEL  DS    0H .                XLIMD EXPANSION- NOTHING\n         MEND\n./ ADD LEVEL=40,SOURCE=0,NAME=XLOOK\n         MACRO\n         XLOOK &ARG1,&ARGL\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: XLOOK      FIND POSITION OF ELEMENT IN LIST.             *\n.*                                 JOHN R. MASHEY - FEB 1970 - V.4.0  *\n.*       MACRO TO FIND AND RETURN POSTION OF ARGUMENT IN A SUBLIST.   *\n.*       &ARG1 ARGUMENT TO BE SEARCHED FOR                            *\n.*       &ARGL LIST OF ARGUMENTS FOR &ARG1 TO BE CHECKED FOR IN       *\n.*       &XXLOOK   THE FIRST POSITION IN &ARGL IN WHICH &ARG1 IS      *\n.*       FOUND, IF ANY.  IF &ARG1 IS NOT IN &ARGL, &XXLOOK = 0.       *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         GBLA  &XXLOOK             FOR RETURN OF INDEX VALUE\n&XXLOOK  SETA  1                   INITIALIZE THE COUNTER\n.XLA     AIF   (&XXLOOK GT N'&ARGL).XLB     IF GT,QUIT,NOT FOUND\n         AIF   ('&ARG1' EQ '&ARGL(&XXLOOK)').XXEXIT   IF FOUND,RETURN\n&XXLOOK  SETA  &XXLOOK+1           INCREMENT COUNTER\n         AGO   .XLA                GO BACK FOR NEXT CHECK\n.XLB     ANOP\n&XXLOOK  SETA  0                   NOT FOUND, SET TO 0 TO SHOW THIS\n.XXEXIT  MEND\n./ ADD LEVEL=40,SOURCE=0,NAME=XMUSE\n         MACRO\n         XMUSE &BR,&AD\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: XMUSE      BASE REGISTER SETUP MACRO FOR XSAVE           *\n.*                                 JOHN R. MASHEY - FEB 1970 - V.4.0  *\n.*       THIS MACRO IS CALLED BY XSAVE TO HANDLE BR AND AD OPERANDS,  *\n.*       AND PRODUCE APPROPRIATE USINGS.  &BR AND &AD ARE FROM XSAVE. *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         LCLA  &I,&N               LOCAL COUNTERS\n         LCLC  &B(4),&V            BASE REGS, USING NAME\n&N       SETA  N'&BR               GET NUMBER WHERE HANDY\n&V       SETC  '*'                 NORMAL USE\n         AIF   (&N LE 4).XNOKA     MAKE SURE NOT TOO MANY BASES\n&N       SETA  4                   IDIOT USER HAD >4 BASES, IGNORE EXTR\n         MNOTE 4,'**XMUSE- MORE THAN 4 BASE REGS-EXTRAS IGNORED'\n.XNOKA   AIF   ('&AD' EQ '').X1LOOP         SKIP IF NORMAL SITUATION\n.*             USED IF AD PARAMATER WAS SPECIFIED IN XSAVE MACRO.     *\n         CNOP 0,4\n         B     *+8 .               SKIP AROUND ADDRESS CONSTANT\n         DC    A(&AD)       .      ADDRESS CONSTANT FOR AD=PARAMETER\n         L     &BR(1),*-4 .        LOAD ADCON INTO RIGHT REGISTER\n&V       SETC  '&AD'               CHANGE NAME FOR USING 1ST OPERND\n.*             NORMAL SECTION OF CODE FOR GENERATING USING.           *\n.X1LOOP  ANOP\n&I       SETA  &I+1      INCREMENT COUNTER TO BASE REG\n&B(&I)   SETC  ',&BR(&I)'          GET I'TH BASE REGISTER\n         AIF   (&I LT &N).X1LOOP   CONTINUE UNTIL ALL BASWE REGS DONE\n         DROP  15 .                CLEAN UP USING SITUATION\n         USING &V&B(1)&B(2)&B(3)&B(4)\n         MEND\n./ ADD LEVEL=40,SOURCE=0,NAME=XOPENBLK\n         MACRO\n&LABEL   XOPENBLK &DCB,&XNAME,&DDNAME,&RECFM=F,&LRECL=,&BLKSIZE=,      #\n               &BUFNO=1,&XOP=OUTPUT,&ABEND=YES,&WARN=NO\n.*--> MACRO: XOPENBLK   GENERATES 1 CONTROL BLOCK FOR XXXXOPEN  . . . .\n.*             SEE THE XOPENBLK DSECT.                                .\n.*       *** ARGUMENTS ***                                            .\n.*       &DCB                      NAME OF DCB TO BE OPENED           .\n.*       &XNAME                    NAME OF CALLING ROUTINE            .\n.*       &DDNAME                   LIST OF 1 OR MORE DDNAMES, IN ORDER.\n.*                                 DESIRED TO BE TRIED.               .\n.*             NEXT 4 ARGS GIVE DEFAULT VALUES USED TO FILL DCB       .\n.*             IF NEEDED DURING DCB EXIT PROCESSING.                  .\n.*       &RECFM=, &LRECL=, &BLKSIZE=, &BUFNO=     SAME NAMES AS DCB   .\n.*       &XOP=                     DIRECTION TO OPEN:  OUTPUT OR INPUT.\n.*       &ABEND=                   ABEND IF CAN'T OPEN: YES OR NO     .\n.*       &WARN=                    WARNING IF CAN'T OPEN FIRST CHOICE .\n.*                                 YES  OR  NO                        .\n.*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n         LCLA  &I                  COUNTER VARIABEL\n         LCLB  &B0,&B3,&B5         FOR RECFM BITS, XOPFLAG1 BITS\n&LABEL   OPEN  (&DCB,&XOP),MF=L .  LIST TO GEN CONTROL ELEMENT\n         DC    AL2(&LRECL,&BLKSIZE,&BUFNO)   LRECL,BLKSIZE,BUFNO\n.*\n&B0      SETB  ('&RECFM'(1,1) EQ 'F')  SHOULD BE SET\n&B3      SETB  ('&RECFM.X'(2,1) EQ 'B')          BLOCKED OR NOT\n&B5      SETB  ('&RECFM'(K'&RECFM,1) EQ 'A')     ASA CARRIAGE CONTROLS\n         DC    B'&B0.00&B3.0&B5.00' .       RECFM BYTE\n.*\n&B0      SETB  ('&ABEND' EQ 'YES') DOES HE WANT TO ABEND IF NO OPEN\n&B3      SETB  ('&WARN' EQ 'YES')  DOES HE WANT WARN IF NOT FIRST DDNA\n         DC    B'&B3&B0',CL8'&XNAME ' .  XOP-FLAG1,XNAME\n.*\n&I       SETA  8*(N'&DDNAME-1)     3 DDNAMES, CONVERT TO BXLE LMT\n         DC    H'&I' .             BXLE OFFSET FOR DD SEARCH\n&I       SETA  1                   RE INIT FOR LOOP TO GEN\n.XOPA    DC    CL8'&DDNAME(&I)'\n&I       SETA  &I+1                INCREMENT TO NEXT ONE\n         AIF   (&I LE N'&DDNAME).XOPA       LOOP UNTIL ALL DDNAMES GEND\n         MEND\n./ ADD LEVEL=40,SOURCE=0,NAME=XPNCH\n         MACRO\n&XLABEL  XPNCH &XAREA,&XNUM\n.*--> MACRO: XPNCH      PUNCH CARD MACRO  . . . . . . . . . . . . . . .\n.*                                 JOHN R. MASHEY - FEB 1970 - V.4.0  *\n.*       MACRO FOR EASY PUNCHING OF UP TO 80 BYTES OF XAREA. MACRO    *\n.*       GENERATION IS CONTROLLED BY &XPNCHST.                        *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         GBLB  &XPNCHST            STATUS VARIABLE- 0=ON, 1=OFF\n         AIF   (&XPNCHST).XNOGEN   SKIP GENRATION IF NOT WANTED\n&XLABEL  XIONR XXXXPNCH,&XNUM,&XAREA,80\n         MEXIT\n.XNOGEN  AIF   (T'&XLABEL EQ 'O').XXEXIT     GEN LABEL ONLY IF NEEDED\n&XLABEL  DS    0H .                LABEL FOR A CANCELLED  XPNCH\n.XXEXIT  MEND\n./ ADD LEVEL=40,SOURCE=0,NAME=XPRNT\n         MACRO\n&XLABEL  XPRNT &XAREA,&XNUM\n.*--> MACRO: XPRNT      PRINT LINE MACRO  . . . . . . . . . . . . . . .\n.*                                 JOHN R. MASHEY - FEB 1970 - V.4.0  *\n.*       MACRO FOR EASY PRINTING OF UP TO 133 CHARACTERS OF XAREA,    *\n.*       AS SPECIFIED BY XNUM.  FIRST CHARACTER IS USED AS CARRIAGE   *\n.*       CONTROL CHARACTER.  GENERATION IS CONTROLLED BY &XPRNTST.    *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         GBLB  &XPRNTST            GENERATION STATUS 0=YES, 1=NO\n         AIF   (&XPRNTST).XNOGEN   SKIP GENERATION IF STATUS=OFF\n&XLABEL  XIONR XXXXPRNT,&XNUM,&XAREA,133\n         MEXIT\n.XNOGEN  AIF   (T'&XLABEL EQ 'O').XXEXIT     GEN LABEL ONLY IF NEEDED\n&XLABEL  DS    0H .                LABEL FOR CANCELLED XPRNT\n.XXEXIT  MEND\n./ ADD LEVEL=40,SOURCE=0,NAME=XPUT\n         MACRO\n&XLABEL  XPUT  &XAREA,&XNUM\n.*--> MACRO: XPUT           PUT A RECORD ONTO FILE &DDNAME . . . . .  *\n.*                                 RICHARD FOWLER AUG 1972 V.5.0      *\n.*       MACRO FOR EASY PRINTING ONTO ANY DD FILE RECORD LENGTH=&XNUM *\n.*       IF PRINT FILE, THE FIRST CHARACTER IS USED AS CARRIAGE CONTROL\n.*       GENERATION CONTROLLED BY &XPUST                              *\n.*       EXECUTION ASSUMES REG 1 POINTS TO DD NAME                    *\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **\n         GBLB  &XPUTST             GENERATION STATUS- 0=YES, 1=NO\n         AIF   (&XPUTST).XNOGEN    IF SHOULDN'T GENERATE, SKIP CALL\n&XLABEL  XIONR XXXXPUT,&XNUM,&XAREA,133\n         MEXIT\n.XNOGEN  AIF   (T'&XLABEL EQ 'O').XXEXIT     GEN LABEL ONLY IF NEEDED\n&XLABEL  DS    0H .                LABEL FOR CANCELLED XPUT\n.XXEXIT  MEND\n./ ADD LEVEL=40,SOURCE=0,NAME=XREAD\n         MACRO\n&XLABEL  XREAD &XAREA,&XNUM\n.*--> MACRO: XREAD      READ CARD MACRO . . . . . . . . . . . . . . . .\n.*                                 JOHN R. MASHEY - FEB 1970 - V.4.0  *\n.*       MACRO FOR EASY CARD READING-READS UP TO 80 CHARACTERS INTO   *\n.*       XAREA OPERAND. CONDITION CODE SET TO 0 NORMALLY, OR TO 1 ON  *\n.*       END OF FILE.  GENERATION CONTROLLED BY &XREADST.             *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         GBLB  &XREADST            GENERATION STATUS- 0=YES, 1=NO\n         AIF   (&XREADST).XNOGEN   IF SHOULDN'T GENRATE-SKIP CALL\n&XLABEL  XIONR XXXXREAD,&XNUM,&XAREA,80\n         MEXIT\n.XNOGEN  AIF   (T'&XLABEL EQ 'O').XXEXIT     GEN LABEL ONLY IF NEEDED\n&XLABEL DS     0H .                LABEL FOR CANCELLED XREAD\n.XXEXIT  MEND\n./ ADD LEVEL=40,SOURCE=0,NAME=XRETURN\n         MACRO\n&LABEL   XRETURN &RGS=(14-12),&SA=,&RC=,&RP=,&T=,&TR=*,&REEN=\n.** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: XRETURN    GENERAL RETURN MACRO, OS LINKAGE              *\n.*                                 JOHN R. MASHEY - FEB 1970 - V.4.0  *\n.*       EXTENDED RETURN MACRO - SEE PSU CC WRITEUP - XSAVE/XRETURN   *\n.*       FOR EXPLANATION AND USE OF OPERANDS.                         *\n.*       USES MACROS: FREEMAIN,XCHAR,XSRNR                            *\n.** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         GBLB  &XRETUST            =0 TRACE GENERATION OK, =1 NO TRACE\n         GBLC  &XSAVE,&XXCHAR      STD SAVE AREA NAME, XCHAR VARIABLE\n         LCLA  &I                  LOCAL COUNTER\n         LCLB  &RCA,&RCB           FOR CONTROL OF RETURN CODE GENER\n.*                                                                    *\n.*       GENERATE LABEL IF THERE IS ONE, GENERATE TRACE CODE IF IT    *\n.*       IF DESIRED, AND SET UP LCLB VARIABLES TO DESCRIBE RETURN     *\n.*       CODE CONDITIONS. GENERATE LR IF NEEDED FOR RC OPTION.        *\n.*                                                                    *\n         SPACE 1\n         AIF   (T'&LABEL EQ 'O').XNOLB       SKIP IF NO LABEL USED\n&LABEL   DS    0H .                DEFINE LABEL\n.XNOLB   AIF   ('&TR' EQ 'NO' OR &XRETUST).XNORT       SKIP IF NO TRACE\n         XSRTR &TR,&LABEL,EXITED   GET TRACE GENERATED\n.XNORT   ANOP\n&RCA     SETB  (T'&RC EQ 'O')      TRUE IF WHOLE THING OMITTED\n&RCB     SETB  (1)                 SET THIS WAY FOR NEXT TEST\n         AIF   (&RCA).XNRCB        SKIP IMMEDIATELY IF OMITTED\n&RCB     SETB  ('&RC'(1,1) NE '(' OR '&RC'(K'&RC,1) NE ')')  NOT RG TYP\n         AIF   (&RCB).XNRCB       SKIP IF NOT REGISTER TYPE\n         XCHAR &RC,3               GET LAST 3 CHARS\n         AIF   ('&XXCHAR' EQ '15)').XNRCB    SKIP IF ALREADY IN 15\n         LR    15,&RC .            LOAD RETURN CODE FROM DESIRED REG\n.XNRCB   AIF   (T'&REEN EQ 'O').XNORM        SKIP IF NOT REENTRANT\n.*                                                                    *\n.*       REENTRANT RETURN CODE GENERATION - OBTAIN ADDRESS AND LENGTH *\n.*       OF AREA FROM WHERE XSAVE PUT THEM,DO FREEMAIN,FIXUP REGS.    *\n.*                                                                    *\n         AIF   ('&TR' EQ 'NO' OR &XRETUST).XGOK        MAKE SURE REENT\n         MNOTE 0,'**XRETURN- TR OPTION IMPLIES NON-REENTRANT CODE'\n.XGOK    L     13,4(13) .          GET OLD SA POINTER BACK\n         STM   15,1,16(13) .       SAVE REGS FROM FREEMAIN CRUNCHING\n         L     1,8(13) .           GET ADDRESS OF AREA BACK\n*        FREEMAIN R,LV=8*((&REEN+79)/8),A=(1)          FREE STORAGE\n         FREEMAIN R,LV=8*((&REEN+79)/8),A=(1)          FREE STORAGE\n         LM    15,1,16(13) .       RESTORE THE REGS\n         AGO   .XNORM1             GO TO PROCESS REGISTER RESTORATION\n.XNORM   AIF   ('&SA' EQ 'NO').XNORM1        SKIP RESTORATION IF UNUSED\n.*                                                                    *\n.*       REGISTER RESTORATION CODE - RESTORE REGS FROM CALLER'S       *\n.*       SAVE AREA,DEPENDING ON RETURN CODE AND FUNCTION OPTIONS.     *\n.*                                                                    *\n         L     13,4(13) .          RESTORE PREVIOUS SAVE AREA POINT\n.XNORM1  AIF   ('&RGS' EQ 'NO').XNORM2A     SKIP IF NO REGS NEEDED\n         AIF   ('&RGS' NE '(14-12)' OR NOT &RCB).XNORM2\n         LM    14,12,12(13) .      STANDARD REGISTER RESTORATION\n         AGO   .XNORM2A            CONTINUE\n.XNORM2  ANOP\n&I       SETA  &I+1                INCREMENT COUNTER\n         XSRNR L,&RGS(&I),&RCB     HAVE RESTORE CODE GENRATED\n         AIF   (&I LT N'&RGS).XNORM2        LOOP UNTIL DONE\n.*                                                                    *\n.*       RETURN CODE(15) AND RETURN PAST(14) CODE GENERATION.         *\n.*                                                                    *\n.XNORM2A AIF   (&RCA OR NOT &RCB).XNORM3    SKIP IF NOT LA TYPE RC=\n         LA    15,&RC .            PUT RETURN CODE IN 15\n.XNORM3  AIF   ('&T' NE '*').XNORM4          SEE IF MVI WANTED\n         MVI   12(13),X'FF' .      SHOW WE HAVE RETURNED\n.XNORM4  AIF   (T'&RP EQ 'O').XNORP          SKIP IF RP NOT USED\n         B     &RP.(14) .          RETURN GIVEN NUMBER PAST 14\n         AGO   .XNORM5\n.XNORP   BR    14 .                RETURN NORMALLY TO CALLER\n.*                                                                    *\n.*       SAVE AREA GENERATION - IF A SAVE AREA SHOULD BE CREATED,     *\n.*       USE EITHER ONE SPECIFIED BY MACRO,OR ELSE STANDARD ONE.      *\n.*                                                                    *\n.XNORM5  AIF   (T'&SA EQ 'O' OR '&SA' EQ 'NO').XEXIT   SKIP IF NO SAV5\n         AIF   ('&SA' EQ '*').XSASTD         IF *,USE STANDARD SAVE\n&SA      DC    18F'0' .            SAVE AREA,NAMED BY MACRO\n         AGO   .XEXIT\n.XSASTD  ANOP\n&XSAVE   DC    18F'0' .            SAVE AREA,USING GENERATED NAME\n.XEXIT   SPACE 1\n         MEND\n./ ADD LEVEL=40,SOURCE=0,NAME=XSAVE\n         MACRO\n&LABEL   XSAVE &RGS=(14-12),&BR=12,&SA=*,&ID=*,&TR=*,&REEN=,&OPT=,&AD=\n.** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: XSAVE      EXTENDED SAVE MACRO - OS LINKAGE.             *\n.*                                 JOHN R. MASHEY - FEB 1970 - V.4.0  *\n.*       EXTENDED SAVE MACRO - SEE PSU CC WRITEUP - XSAVE/XRETURN     *\n.*       FOR DESCRIPTION OF ARGUMENTS FOR THIS MACRO                  *\n.*       USES MACROS: GETMAIN,XCHAR,XIDENT,XLOOK,XMUSE,XSRNT,XSRTR    *\n.** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         GBLA  &XXLOOK             RETURN VARIABLE FROM XLOOK MACRO\n         GBLB  &XSAVEST            =0 TRACE GEN OK, =1 NO TRACE DONE\n         GBLC  &XSAVE,&XCSECT,&XXCHAR  STD NAME,CSECT NAME,XCHAR VAR\n         LCLA  &I                  LOCAL COUNTER\n         LCLB &XNSECT              FLAG FOR NEW CSECT\n         LCLC  &B1,&BT             1ST BASE,LAST 2 CHARS OF 1ST BASE\n&B1      SETC  '&BR(1)'            GET FIRST OR ONLY BASE IN EASIER NAM\n         XCHAR &B1,2               GET LAST 2 CHARS OF BASE REG\n&BT      SETC  '&XXCHAR'           GET LAST 2 CHARACTERS\n&XNSECT  SETB  ('&SYSECT' NE '&XCSECT')      NOTE IF NEW CSECT NEEDED\n&XCSECT  SETC  '&SYSECT'           SET TO SYSECT, FOR NORMAL USE\n.*                                                                    *\n.*       CHECK OPT FIELD - GENERATE TITLE AND/OR ENTRY OR CSECT       *\n.*       STATEMENTS, DEPENDING ON CONTENTS OF OPT FIELD, IF USED.     *\n.*                                                                    *\n         AIF   (T'&OPT EQ 'O').XNOPS         SKIP IF OPT UNUSED\n         XLOOK TITLE,&OPT           WAS TITLE OPTION USED\n         AIF   (&XXLOOK EQ 0).XNTITL         SKIP IF TITLE NOT USED\n         AIF   (N'&OPT EQ 1).XNOPS SKIP IF TITLE ONLY\n        TITLE  '*** &LABEL ***'\n.XNTITL  XLOOK ENTRY,&OPT           WAS ENTRY USED\n         AIF   (&XXLOOK EQ 0).XTRCS         SKIP IF NOT USED\n         AIF   ('&LABEL' EQ '').XENTE        SKIP TO ERR IF NO LABEL\n         ENTRY &LABEL  .            NOTE XSAVE ENTRY OPTION\n         AGO   .XNOPS\n.XENTE   MNOTE 4,'**XSAVE- OPT=ENTRY USED WITHOUT LABEL-OPTION IGNORED'\n         AGO   .XNOPS\n.XTRCS   XLOOK CSECT,&OPT           CHECK FOR CSECT OPTION\n         AIF   (&XXLOOK EQ 0).XTRCS1        SKIP IF OPTION NOT THERE\n&LABEL   CSECT\n&XCSECT  SETC  '&LABEL'            SET THIS TO SHOW NEW CSECT\n&XNSECT  SETB  (1)                  NOTE THAT NEW CSECT IS NEEDED\n         AGO   .XENT1               SKIP OVER &LABEL DEFN\n.XTRCS1  MNOTE 0,'**XSAVE- UNKNOWN OPT=&OPT- IGNORED'\n.*                                                                    *\n.*       CREATE STATMENT LABEL IF ANY. IF IDENTIFIER REQUESTED,USE    *\n.*       SPECIFIED IDENTIFIER,STATEMENT LABEL,OR CSECT NAME IN XIDENT *\n.*       TO GENERATE CORRECT IDENTIFIER WITH BRANCH AROUND IT.        *\n.*                                                                    *\n.XNOPS   SPACE 2\n&LABEL   DS    0H .                DEFINE LABEL,MAKE SUREE ALIGNED\n.XENT1   USING *,15 .              FOR TEMPORARY ADDRESSIBILITY\n         AIF   ('&SA' EQ '*' OR '&SA' EQ 'NO').XCHKS1 SKIP IF NO CHANGE\n&XSAVE   SETC  '&SA'                EXPLICIT NEW SAVE AREA NAME\n         AGO   .XSAOK\n.XCHKS1  AIF   ('&XSAVE' NE '').XCHKS2       SKIP IF NOT NULL\n&XSAVE   SETC  '$PR#&SYSNDX'        SET UP DEFAULT SAVE AREA NAME\n         AGO   .XSAOK\n.XCHKS2  AIF   (NOT &XNSECT).XSAOK SKIP IF NEW SAVE NOT NEEDED\n&XSAVE   SETC  '&XCSECT'(1,3).'#&SYSNDX'     DEFAULT SAVE AREA NAME\n.*                                                                    *\n.XSAOK   AIF   ('&ID' EQ 'NO').XID3 SKIP IF NO ID WANTED\n         XIDENT &ID,&LABEL,&XCSECT,$PRIVATE CALL TO SET UP IDENT\n.*                                                                    *\n.*       IF TR OPTION IN EFFECT, CALL XSRTR TO GENERATE RIGHT CODE,   *\n.*       THEN HAVE XSRNR GENERATE CODE TO SAVE RANGES OF REGISTERS    *\n.*                                                                    *\n.XID3    AIF   (&XSAVEST OR '&TR' EQ 'NO').XNOTR       SKIP IF NO TRACE\n         XSRTR &TR,&LABEL,ENTERED  GET TRACE GENERATED\n.XNOTR   AIF   ('&RGS' NE '(14-12)').XSRCAL SKIP IF NOT STANDARD\n         STM   14,12,12(13) .      SAVE STANDARD REGISTER SET\n         AGO   .XCHK13\n.XSRCAL  AIF   ('&RGS' EQ 'NO').XCHK13       SKIP IF NO REGS SAVED\n&I       SETA  1                   INITIALIZE COUNTER\n.XSETUP  XSRNR ST,&RGS(&I)         CALL XSRNR WITH EACH REG SET\n&I       SETA  &I+1                INCREMENT TO NEXT REGS SET\n         AIF   (&I LE N'&RGS).XSETUP         CONTINUE PROCESSING RGS\n.XCHK13  AIF   ('&BT' NE '13').XNORM1       NOT REG 13,DO NORMALLY\n.*                                                                    *\n.*       REGISTER 13 DOUBLE USAGE - THIS SECTION GENERATES CODE TO    *\n.*       USE REGISTER 13 BOTH AS A BASE AND AS THE SAVE AREA POINTER. *\n.*                                                                    *\n         AIF   (T'&AD EQ 'O').XU2  SKIP TO NORMAL IF &AD OMITTED\n         LR    14,13 .             SAVE @ OLD SAVE AREA BEFORE SETTING\n         XMUSE &BR,&AD             HAVE ADCON SET UP\n         ST    13,8(14) .          SAVE NEW POINTER INTO OLD SAVEAREA\n         ST    14,4(13) .          SAVE OLD POINTER INTO NEW AREA\n         AGO   .XEND1              GO FINISH UP\n.XU2     CNOP  0,4\n         ST    13,&XSAVE+4 .       SAVE OLD SA POINTER INTO NEW AREA\n         BAL   13,&XSAVE+72 .      SET UP 13, BRANCH AROUND SA\n         XMUSE &BR                 SET UP WHATEVER USING REQUIRED\n&XSAVE   DC    18F'0'  .           SAVE A\u00a2EA\n.XU3     L     15,&XSAVE+4 .       GET OLD SA POINTER BACK TO SET LINKS\n         ST    13,8(15) .          STORE NEW POINTER IN OLD AREA\n         AGO   .XEND1              CHECK NUMBER OF BR'S,GET LA'S SET UP\n.*                                                                    *\n.XNORM1  AIF   (T'&REEN EQ 'O').XNORM2       SKIP OVER REENTRANT\n.*                                                                    *\n.*       REENTRANT ENTRY CODE GENERATION - THIS GENERATES CODE TO     *\n.*       ACQUIRE SPACE FOR SAVEAREA(72 BYTES) + AS MUCH MORE SPACE    *\n.*       AS IS SPECIFIED IN REEN PARAMATER, IF USED.                  *\n.*                                                                    *\n         AIF   ('&TR' EQ 'NO' OR &XSAVEST).XGOK        MAKE SURE REENT\n         MNOTE 0,'**XSAVE- USE OF TR OPTION IMPLIES NON-REENTRANT CODE'\n.XGOK    ANOP\n*        GETMAIN R,LV=8*((&REEN+79)/8)       GET SPACE ROUNDED TO D\n         GETMAIN R,LV=8*((&REEN+79)/8) .GET CORE ROUNDED TO DBLWRD\n         ST    13,4(1) .           STORE OLD POINTER IN NEW AREA\n         ST    1,8(13) .           STORE (EW POINTER IN OLD AREA\n         LR    &B1,1 .             SAVE VALUE OF NEW SAVE POINTER\n         LM    0,1,20(13) .        RESTORE PREVIOUS VALUES OF REGS\n         LR    13,&B1 .            POINT 13 TO NEW SAVE AREA\n         AGO   .XNEWBS             GO GENERATE NEW BALR,USING\n.*                                                                    *\n.*       NORMAL,NON-REENTRANT ENTRY CODE SECTION.                     *\n.*                                                                    *\n.XNORM2  AIF   ('&SA' EQ 'NO').XNEWBS        SKIP IF NO SAVE AREA\n         ST    13,&XSAVE+4 .       SAVE OLD POINTER IN NEW AREA\n         AIF   ('&BT' NE '15').XSN15         SKIP IF NOT 15\n         LA    13,&XSAVE .         GET ADDRESS OF NEW SAVE AREA\n         L     &B1,&XSAVE+4 .      GET OLD SAVE POINTER BACK\n         AGO   .XSOLD              GO SAVE NEW POINTER\n.XSN15   LR    &B1,13 .            MOVE OLD POINTER OVER\n         LA    13,&XSAVE    .      ADDRES> OF NEW SAVE AREA\n.XSOLD   ST    13,8(&B1) .         SAVE NEW POINTER IN OLD AREA\n.*             SET UP BALR, LA'S IF REQUIRED, AND USING STATEMENT.    *\n.XNEWBS  AIF   ('&BT' NE '15' OR N'&BR GT 1).XSET2  SKIP IF 15\n         AIF   ('&REEN' EQ '' AND '&SA' EQ 'NO' AND '&AD' EQ '').XEND2\n.XSET2   AIF   (T'&AD NE 'O').XSET3          SKIP BALR IF ADCON USED\n         BALR  &B1,0 .             SET UP NEW BASE REGISTER\n.XSET3   XMUSE &BR,&AD             SET UP USINGS, ADCON IF NEEDED\n.XEND1   AIF   (N'&BR EQ 1).XEND2  IF ONLY 1 BASE,DON'T CALL XMUSE\n&I       SETA  2                    INITIALIZE\n.XA2A    LA    &BR(&I),4095 .       LOAD IN ADDRESS\n         LA    &BR(&I),1(&BR(&I),&BR(&I-1))  .   SET USING VALUES\n&I       SETA  &I+1                 INCREMENT TO NEXT BASE\n         AIF   (&I LE N'&BR AND &I LE 4).XA2A         LOOP FOR # BASES\n.XEND2   SPACE 1\n         MEND\n./ ADD LEVEL=40,SOURCE=0,NAME=XSET\n         MACRO\n&XLABEL  XSET  &XSNAP=,&XSTOP=,&XREAD=,&XPRNT=,&XPNCH=,&XTIME=,        X\n               &XSAVE=,&XRETURN=\n.*--> MACRO: XSET       CONTROL XMACRO GENERATION . . . . . . . . . . .\n.*                                 JOHN R. MASHEY - FEB 1970 - V.4.0  *\n.*       XSET IS USED TO CONTROL GENERATION OF X-MACROS OF THE NAMES  *\n.*       USED AS OPERANDS. NAME=OFF CANCELLS THE GIVEN MACRO UNTIL    *\n.*       NAME=ON IS CODED.  ALL NAMES ARE ON UNLESS CANCELLED. ALL    *\n.*       CODE MAY BE ELIMINATED FOR ANY MACROS EXCEPT XSAVE/XRETURN,  *\n.*       WHOSE TRACE CODE ONLY IS ELIMINATED.                         *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         GBLB  &XSNAPST,&XSTOPST,&XSAVEST,&XRETUST     STATUS VARS\n         GBLB  &XREADST,&XPRNTST,&XPNCHST,&XTIMEST\n         AIF   (T'&XLABEL EQ 'O').XNOLB  GEN LABEL ONLY IF NEEDED\n&XLABEL  DS    0H  .               LABEL APPEARED ON AN XSET\n.XNOLB   ANOP\n&XSNAPST SETB (('&XSNAP' EQ 'OFF') OR ((T'&XSNAP EQ 'O') AND &XSNAPST))\n&XSTOPST SETB (('&XSTOP' EQ 'OFF') OR ((T'&XSTOP EQ 'O') AND &XSTOPST))\n&XREADST SETB (('&XREAD' EQ 'OFF') OR ((T'&XREAD EQ 'O') AND &XREADST))\n&XPRNTST SETB (('&XPRNT' EQ 'OFF') OR ((T'&XPRNT EQ 'O') AND &XPRNTST))\n&XPNCHST SETB (('&XPNCH' EQ 'OFF') OR ((T'&XPNCH EQ 'O') AND &XPNCHST))\n&XTIMEST SETB (('&XTIME' EQ 'OFF') OR ((T'&XTIME EQ 'O') AND &XTIMEST))\n&XSAVEST SETB (('&XSAVE' EQ 'OFF') OR ((T'&XSAVE EQ 'O') AND &XSAVEST))\n&XRETUST SETB  (('&XRETURN' EQ 'OFF') OR ((T'&XRETURN EQ 'O') AND      X\n               &XRETUST))\n         MEND\n./ ADD LEVEL=40,SOURCE=0,NAME=XSNAP\n         MACRO\n&XLABEL  XSNAP &T=PR,&LABEL=,&STORAGE=,&IF=\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: XSNAP      EXTENDED SNAP MACRO-DEBUGGING-DUMPING.        *\n.*                                 JOHN R. MASHEY - FEB 1970 - V.4.0  *\n.*       XSNAP     IS USED FOR STORING,PRINTING OF REGISTERS AND ANY  *\n.*       OTHER ADDRESSIBLE AREAS. XSNAP HARMS NO REGISTERS,CAN BE USED*\n.*       IN ANY NUMBER OF CSECTS IN 1 ASSEMBLY,AND PRINTS REGISTERS   *\n.*       EXACTLY AS THEY ARE WHEN THE XSNAP IS CALLED.  XSNAP         *\n.*       ACTION MAY BE MADE CONDITIONAL EITHER AT ASSEMBLY TIME OR    *\n.*       DURING EXECUTE TIME.  SEE WRITEUP FOR OPERAND DESCRIPTION.   *\n.*       USES MACROS: XLOOK                                           *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         GBLA  &XXLOOK             XLOOK RETURN VALUE\n         GBLB  &XSNAPST            GENERATION STATUS,ON=0,OFF=1\n         LCLA  &I,&K,&L,&N         LOCAL COUNTERS\n         LCLB  &XP,&XF             PRINT REGS AND PRINT FLOATING REGS\n         LCLC  &NAM,&INST,&A(5)\n.*                                                                    *\n.*       CHECK FOR XSNAPS BEING CANCELLED. CREATE LABEL IF NEEDED.    *\n.*                                                                    *\n         AIF   (NOT &XSNAPST).XGOGEN   GENERATE IF STATUS=ON\n         AIF   (T'&XLABEL EQ 'O').XXEXIT    SKIP IF NOTHING TO GEN\n&XLABEL  DS    0H  .               LABEL USED ON NULLIFIED XSNAP\n         MEXIT\n.XGOGEN  SPACE 1\n&NAM     SETC  'XX&SYSNDX'         SET UP MOST OF NAME FOR LABELS\n&N       SETA  (N'&STORAGE/2)*2    GET ROUNDED NUMBER OF OPERANDS\n&XLABEL  STM   0,15,&NAM.B  .      SAVE ALL REGISTERS\n.*                                                                    *\n.*       IF OPTION - IF IF OPTION IS USED AND HAS CORRECT ARGUMENTS,  *\n.*       GENERATE A CLI, C, OR CR INSTRUCTION TO PERFORM APPROPRIATE  *\n.*       TEST,DEPENDING ON THE KIND OF IF ARGUMENTS . NEGATE THE      *\n.*       CONDITION AND CREATE THE RIGHT EXTENDED MNEMONIC BRANCH      *\n.*       SO THAT THE XSNAP WILL BE SKIPPED IF THE STATED CONDTION IS  *\n.*       NOT MET.  GENERATE USER'S OWN OPCODE IF HE SUPPLIED ONE.     *\n.*                                                                    *\n         AIF   (T'&IF EQ 'O').XNOIF          SKIP IF IF NOT REQUESTED\n         AIF   (N'&IF GE 3).XOKIF  SKIP IF ENOUGH ARGUMENTS\n         MNOTE 0,'**XSNAP- IF=&IF:IGNORED, LACKS REQUIRED 3-4 OPERANDS'\n         AGO   .XNOIF              CANCEL IF OPTION\n.XOKIF   XLOOK &IF(2),(H,L,E,O,P,M,Z,NH,NL,NE,NO,NP,NM,NZ)\n         AIF   (&XXLOOK GT 0).XOKIF1        SKIP IF OK RELATION\n         MNOTE 0,'**XSNAP- IF=&IF(2) UNKNOWN-CANCELLED'\n         AGO   .XNOIF              SKIP GENERATION OF THIS OPTION\n.XOKIF1  ANOP\n&INST    SETC  '&IF(4)'            GET INSTRUCTION\n         AIF   (N'&IF EQ 4).X      IF OPCODE SUPPLIED,SKIP CHECKING\n&INST    SETC  'CLI'               MAKE TENTATIVE INSTRUCTION SETUP\n         AIF   ('&IF(1)'(1,1) NE '(' OR '&IF(1)'(K'&IF(1),1) NE ')').X\n&INST    SETC  'C'                 PROBABLY WANTS RX TYPE\n         AIF   ('&IF(3)'(1,1) NE '(' OR '&IF(3)'(K'&IF(3),1) NE ')').X\n&INST    SETC  'CR'                2 REGS-USER WANTS RR TYPE\n.X       ANOP\n         &INST &IF(1),&IF(3) .     TEST\n&INST    SETC  'BN&IF(2)'          NEGATE COND, HOPE FOR 1 OF 1ST SET\n         AIF   (&XXLOOK LE 7).XOKIF2        SKIP IF NOW SET UP RIGHT\n&INST    SETC  'B'.'&IF(2)'(2,2)   REMOVE N FROM COND\n.XOKIF2  &INST &NAM.C\n.*                                                                    *\n.*             CREATE BRANCH AROUND THE SAVE AREA, FLAGS, ETC.        *\n.*                                                                    *\n.XNOIF   XLOOK &T(1),(PR,PRINT,FL,FLOAT,NO,NOREGS,ST,STORE)\n&I       SETA  72+4*&N             LENGTH FOR T=PRINT,NOREGS\n         AIF   (&XXLOOK LE 6).XBRNCH        SKIP IF ILLEGAL, OR PR,NO\n&I       SETA  68                  LENGTH FOR T=STORE\n.XBRNCH  B     &NAM.B+&I  .        BRANCH AROUND CONSTANTS\n.*                                                                    *\n.*       CREATE FRONT BRACKET CHARACTER STRING FOR REGISTER AREA      *\n.*                                                                    *\n         DS    0F  .               ALIGN LABEL ON FULLWORD\n&L       SETA  8                   SET &L FOR NO LABEL= LENGTH\n         AIF   (T'&LABEL EQ 'O').XNOLAB      IF NO LABEL,SKIP GENERATIO\n&L       SETA  ((K'&LABEL+1)/4)*4  ROUND LENGTH UP TO FULLWORD\n         AIF   (&L LE 92).XLAB1    SKIP IF LABEL SMALL ENOUGH\n         MNOTE 0,'**XSNAP- LABEL= OPERAND TRUNCATED TO 92 CHARACTERS'\n&L       SETA  92                  TRUNCATE\n.XLAB1   DC    CL&L&LABEL\n         AGO   .XCHK1              SKIP GENRATION OF 1ST DELIMETER\n.XNOLAB  DC    CL8'&NAM.B'   .     FRONT BRACKET FOR REGISTER AREA\n.*                                                                    *\n.*             CREATE REGISTER AREA, BRACKETS, FLAG VALUES, AS NEEDED *\n.XCHK1   AIF   (&XXLOOK LT 7).XPRINT        SKIP IF PRINTED OUTPUT\n&NAM.B   DC    16F'-1',4C'X' .     REGISTER SAVE AREA, BRACKET X'S\n         AGO   .XIFLB              SKIP TO CHECK FOR IF LABEL\n.XPRINT  AIF   (&XXLOOK GT 0).XPRINT1       SKIP IF LEGAL T=\n         MNOTE 0,'**XSNAP- UNKNOWN T=&T: T=PR ASSUMED'\n.XPRINT1 ANOP\n&XP      SETB  (&XXLOOK LT 5)      SET TO 1 IF GP REGS NEEDED\n&XF      SETB  (&XXLOOK GT 2 AND &XP)       SET TO 1 IF T=FL OR T=FLOAT\n&XF      SETB  (&XF OR '&T(2)' EQ 'FL' OR '&T(2)' EQ 'FLOAT')\n&NAM.B   DC    16F'-1',B'&T(3)00&XF&XP',AL1(0,&L,&N/2),V(XXXXSNAP)\n.*                                                                    *\n.*       GENERATE ADDRESS LIST FOR STORAGE=, WITH EITHER WORDS FOR    *\n.*       STORING ADDRESSES OR A-TYPE ADDRESS CONSTANTS.               *\n.*                                                                    *\n         AIF   (T'&STORAGE EQ 'O').OKN      SKIP IF STORAGE= NOT USED\n&I       SETA  1                   INITIALIZE AS COUNTER\n         AIF   (&N EQ N'&STORAGE).LOOP1               SKIP IF LEGAL\n         MNOTE 0,'**XSNAP- ODD OPERAND IGNORED: STORAGE=&STORAGE(&N)'\n         AIF   (&N EQ 0).OKN\n.LOOP1   AIF   ('&STORAGE(&I)'(1,1) NE '*').LOOP1E\n&K       SETA  1                   INITIALIZE COUNTER\n.*             PROCESS ADDRESS REQUIRING LA - ST COMBINATION          *\n.LOOP1A  AIF   (&I+&K GT &N).LOOP1C         SKIP IF WE'RE AT END\n         AIF   ('&STORAGE(&I+&K)'(1,1) NE '*').LOOP1C SKIP IF NOT *\n&K       SETA  &K+1                INCREM # CONSECUTIVE *FORMS\n         AGO   .LOOP1A             GO CHECK NEXT\n.LOOP1C  DS    &K.A .              WORDS WHERE ADDRESSES WILL BE STORED\n&I       SETA  &I+&K               INCREMENT\n         AGO   .LOOP1G             GO FOR NEXT CHECK\n.*             PROCESS ADDRESS CONSTANT TYPE OF OPERAND               *\n.LOOP1E  DC    A(&STORAGE(&I))\n&I       SETA  &I+1                INCREMENT # OPERANDS DONE\n.LOOP1G  AIF   (&I LE &N).LOOP1    CONTINUE IF ANY MORE\n.*                                                                    *\n.*       CREATE LOAD ADDRESS - STORE PAIRS FOR EXPRESSION ADDRESSES   *\n.*                                                                    *\n&I       SETA  1\n.LOOP2   AIF   ('&STORAGE(&I)'(1,1) NE '*').LOOP2E    SKIP IF NOT *\n&L       SETA  K'&STORAGE(&I)-1    GET # CHARAS IN EXPRESSION\n&K       SETA  1                   INIT COUNTER\n         AIF    (&L LE 40).LOOP2A  SKIP IF SMALL ENOUGH\n         MNOTE 8,'**XSNAP- STORAGE(&I) LONGER THAN 40 CHARACTERS'\n&L       SETA  40                  TRUNCATE AND HOPE IT GOES\n.*       BREAK EXPRESSION INTO 8 CHARACTER SECTIONS.                  *\n.LOOP2A  ANOP\n&A(&K)   SETC  '&STORAGE(&I)'(8*&K-6,8)      GET UP TO 8 NEXT CHARS\n&K       SETA  &K+1                INCRMENT COUNTER\n         AIF   (8*&K-8 LT &L).LOOP2A        LOOP UNTIL HAVE WHOLE OPR\n         LA    0,&A(1)&A(2)&A(3)&A(4)&A(5)\n         ST    0,&NAM.B+4*&I+68    STORE ADDRESS IN LIST\n.LOOP2C  ANOP\n&K       SETA  &K-1                DECRMENT SECTION TO NULL\n&A(&K)   SETC  ''                  NULL FOR NEXT USE\n         AIF   (&K GT 2).LOOP2C    CONTINUE UNTIL ALL BUT &A(1) NULL\n.LOOP2E  ANOP\n&I       SETA  &I+1                INCREMENT POSITION IN LIST\n         AIF   (&I LE &N).LOOP2    CONTINUE WITH LIST\n.*                                                                    *\n.*       CREATE CODE TO SET UP REGISTERS FOR XXXXSNAP,CALL IT,AND     *\n.*       RESTORE REGS ON RETURN.  XXXXSNAP RESTORES THE CONDTION CODE.*\n.*                                                                    *\n.OKN     LA    10,&NAM.B  .        GET ADDRESS OF REGISTER BLOCK\n         L     15,68(10) .         GET V(XXXXSNAP) FOR BRANCH\n         BALR  14,15 .             CALL XXXXSNAP,POINT 14 AT NEXT INST\n         LM    0,15,0(10) .        RELOAD THE REGISTERS\n.*             CREATE LABEL FOR IF OPTION, IF IT WAS USED.            *\n.XIFLB   AIF   ('&INST' EQ '').XEXIT         SKIP GEN OF IF LABEL\n&NAM.C   EQU   * .                 DEFINE LABEL FOR IF= BRANCH\n.XEXIT   SPACE 2\n.XXEXIT  MEND\n./ ADD LEVEL=40,SOURCE=0,NAME=XSRNR\n         MACRO\n         XSRNR &OP,&RG,&NO15\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*--> MACRO: XSRNR      SAVE/RESTORE REGISTERS FOR XSAVE/XRETURN      *\n.*                                 JOHN R. MASHEY- FEB 1970 - V.4.0   *\n.*             THIS MACRO IS USED BY XSAVE AND XRETURN TO SET UP      *\n.*       REGISTER SAVING AND RESTORATION.                             *\n.*       &OP IS THE OPCODE TO BE USED.  I.E.  EITHER L  OR ST.        *\n.*       &RG  IS 1 OPERAND FROM THE &RGS OPERAND USED BY XSAVE AND    *\n.*             XRETURN.  IT IS EITHER 1 REGISTER, OR A PAIR OF REGS   *\n.*             SEPARATED BY A DASH.                                   *\n.*       &NO15   =0  STATES THAT A RETURN CODE IS CURRENTLY IN REG 15 *\n.*             AND SHOULD NOT BE DISTURBED, REGARDLESS OF HOW THE REGS*\n.*             ARE SPECIFIED.                                         *\n.*       USES MACROS: XCHAR                                           *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         GBLC  &XXCHAR             FOR COMMUNICATION WITH XCHAR\n         LCLA  &I\n         LCLC  &R1,&R2             1ST REG, 2ND REG, TEMPORARY\n         AIF   ('&RG' EQ 'NO').XXEXIT        DON'T GEN ANYTHING\n.*             SCAN FOR DASH-MEANING 2 REGISTERS.                     *\n.XSL1    ANOP\n&I       SETA  &I+1                INCREMENT FOR NEXT CHARACTER\n         AIF   ('&RG'(&I,1) EQ '-').XDASH    JUMP IF DASH FOUND\n         AIF   (&I LT K'&RG).XSL1  CONTINUE TO END OF OPERAND\n&R1      SETC  '&RG'               &RG IS 1 REGISTER BY ITSELF\n         AGO   .XSAA               GO TO NEXT DECISION POINT\n.*             FOUND DASH-NOW SEPARATE THE REGISTERS.                 *\n.XDASH   ANOP\n&R1      SETC  '&RG'(1,&I-1)       GET FIRST REGISTER\n         AIF   (&I EQ K'&RG).XSAA  DUMB USER - 1 REG FOLLOWED BY -\n&R2      SETC  '&RG'(&I+1,K'&RG-&I)         GET 2ND REGISTER\n.XSAA    XCHAR &R1,2               GET UP TO LAST 2 CHARS OF 1ST REG\n         AIF   ('&XXCHAR' NE '14' AND '&XXCHAR' NE '15').XNO1415\n&I       SETA  4*&XXCHAR-44         OFFSET FOR 14 OR 15\n         AIF   ('&R2' NE '').XS2RG SKIP IF 2 REGISTERS SPECIFIED\n         AIF   ('&XXCHAR' EQ '15' AND '&NO15' EQ '0').XXEXIT\n         &OP   &R1,&I.(13)  .       SAVE/RESTORE 1 REG\n         MEXIT\n.XS2RG   AIF   ('&NO15' EQ '0').XSN15        SKIP IF 15 SHOULDN'T BE\n         &OP.M &R1,&R2,&I.(13)  .  SAVE/RESTORE RANGE OF REGS\n         MEXIT\n.XSN15   AIF   ('&XXCHAR' EQ '15').XSN15A    SKIP IF 15 SPECIFIED\n         L     &R1,12(13)  .        RELOAD REG 14\n         XCHAR &R2,2                GET 2ND REG\n         AIF   ('&XXCHAR' EQ '15').XXEXIT    SKIP IF 15 SPECIFIED\n.XSN15A  LM    0,&R2,20(13)  .     RELOAD REST OF REGS\n         MEXIT\n.*             RESTORE 1 REG OR RANGE (NOT STARTING WITH 14 OR 15).   *\n.XNO1415 AIF   ('&R2' NE '').XLMSTM          JUMP IF MULTIPLE REGS\n         &OP   &R1,&R1*4+20(13)\n         MEXIT\n.XLMSTM  &OP.M &R1,&R2,&R1*4+20(13)\n.XXEXIT  MEND\n./ ADD LEVEL=40,SOURCE=0,NAME=XSRTR\n         MACRO\n         XSRTR &TR,&LABEL,&MSG\n.*--> MACRO: XSRTR      GENERATE TRACE CODE FOR XSAVE/XRETURN . . . . .\n.*                                 JOHN R. MASHEY- FEB 1970 - V.4.0   *\n.*       THIS MACRO IS USED BY XSAVE AND XRETURN TO GENERATE THE      *\n.*       TRACE CODE CALLS TO XSNAP OR XPRNT, OR TIMING CALLS TO XTIME.*\n.*       MACROS CALLED BY THIS MACRO - XLLOK, XPRNT,XSNAP,XTIME       *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         GBLA  &XXLOOK             FOR COMMUNICATION 0WITH XLOOK\n         GBLB &XSNAPST,&XPRNTST    GLOBALS FOR OUTPUT MACROS\n         LCLA  &I                  FOR USE AS LENGTH SPECIIFICATION\n         LCLB  &XSTSAV             FOR SAVING STAUS VARIABLES\n         LCLC  &NAME               FOR EITHER LABEL OR CSECT\n         XLOOK &TR(1),(*,SNAP,TIME)         CHECK TYPE\n         AIF   (&XXLOOK LT 3).XPS  SKIP IF NOT TIME\n*        XTIME ,&TR(2)\n         XTIME ,&TR(2)\n         MEXIT\n.XPS     AIF   (&XXLOOK EQ 0 AND N'&TR GT 1 AND '&TR(2)' NE 'SNAP').XE\n&NAME    SETC  '&LABEL'            ASSUME NAME IS LABEL\n         AIF   (T'&LABEL NE 'O').XNOK1       SKIP IF LABEL EXISTS\n&NAME    SETC  '&SYSECT'           USE CSECT NAME INSTEAD\n         AIF   ('&SYSECT' NE '').XNOK1       SKIP IF CSECT NOT PC\n&NAME    SETC  '$PRIVATE'          USE NAME FOR PRIVATE CODE (PC)\n.XNOK1   AIF   (&XXLOOK EQ 2 OR '&TR(2)' EQ 'SNAP').XNSNAP\n&XSTSAV  SETB  (&XPRNTST)          SAVE STATUS VARIABLE\n&XPRNTST SETB  (0)                 MAKE SURE XPRNT WILL GENERATE\n         AIF   (&XXLOOK EQ 1).XDFTA         SKIP- TR=* - DEFAULT\n&I       SETA 2*((K'&TR)/2)        GET RIGHT TOTAL LENGTH FOR DC\n         B     *+4+&I .            BRANCH AROUND MESSAGE\nXX&SYSNDX.T DC C'0',CL(&I-1)&TR\n         AGO   .XPRB               SKIP OVER ALTERNATE\n.XDFTA   B     *+28 .              BRANCH AROUND MESSAGE\nXX&SYSNDX.T DC CL24'0*** &NAME &MSG ***'\n&I       SETA  24                  SET UP FOR XPRNT\n.XPRB    ANOP\n*        XPRNT XX&SYSNDX.T,&I      PRINT MESSAGE WITH GIVEN LENGTH\n         XPRNT XX&SYSNDX.T,&I\n&XPRNTST SETB  (&XSTSAV)           RESTORE PREVIOUS VALUE\n         MEXIT\n.XE      MNOTE 0,'**XSRTR- TR=&TR: UNKNOWN, IGNORED'\n         MEXIT\n.XNSNAP  ANOP\n&XSTSAV  SETB  (&XSNAPST)          SAVE XSNAP STATUS, IN CASE OFF\n&XSNAPST SETB  (0)                 MAKE SURE XSNAP WILL GENERATE\n*        XSNAP LABEL='  MESSAGE '\n         AIF   (&XXLOOK EQ 2).XDFTB         SKIP IF TR=SNAP\n         XSNAP LABEL=&TR(1)\n         AGO   .XSNB               SKIP OVER ALTERNATE\n.XDFTB   XSNAP LABEL='*** &NAME &MSG ***'\n.XSNB    ANOP\n&XSNAPST SETB  (&XSTSAV)           RESTORE STATUS,IN CASE IT WAS OFF\n         MEND\n./ ADD LEVEL=40,SOURCE=0,NAME=XSTOP\n         MACRO\n&LABEL   XSTOP &N=2,&ABEND=200,&GOTO=\n.*--> MACRO: XSTOP      CONTROL PROGRAM LOOPS . . . . . . . . . . . . .\n.*                                 JOHN R. MASHEY - FEB 1970 - V.4.0  *\n.*       XSTOP     IS USED TO STOP INFINITE LOOPS IN ASSEMBLER        *\n.*         N=NUMBER   WILL CAUSE THE PROGRAM TO ABEND THE NUMBER'TH   *\n.*             TIME THROUGH THE XSTOP.  DEFAULT IS N=2,               *\n.*             WHICH MEANS THE XSTOP CAN ONLY BE ENCOUNTERED ONCE     *\n.*             BEFORE IT ABENDS.                                      *\n.*         ABEND=K      K WILL BE THE COMPLETION CODE ISSUED BY THE   *\n.*             EMBEDDED ABEND MACRO.  DEFAULT IS 200.                 *\n.*         GOTO=LABEL   BRANCH TO LABEL INSTEAD OF ABENDING           *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         GBLB  &XSTOPST            XSTOP GENERATION STATUS,ON=0,OFF=1\n         LCLC  &XNAM               NAME FOR CONSTANTS\n         AIF   (&XSTOPST).XXNOG    SKIP IF NOGEN\n&XNAM    SETC  'XX&SYSNDX.V'       GET UNIQUE LABEL\n&LABEL   ST    0,&XNAM   .         SAVE WORK REGISTER\n         L     0,&XNAM+4   .       LOAD CURRENT COUNTER VALUE\n         BCT   0,&XNAM+8   .       BRANCH IF STILL OK,DECREMENT REG\n         L     0,&XNAM .           RESTORE WORK REGISTER\n         AIF   ('&GOTO' EQ '').XXAB         SKIP IF NO GOTO USED\n         B     &GOTO  .            TAKE DESIRED BRANCH\n         AGO   .XXDC               SKIP TO GENERATE DC'S\n.XXAB    ABEND &ABEND,DUMP\n.XXDC    ANOP\n&XNAM    DC    A(0,&N)    .        REGISTER SAVE AREA, COUNTER\n         ST    0,&XNAM+4   .       SAVE DECREMENTED COUNTER VALUE\n         L     0,&XNAM   .         RESTORE WORK REGISTER\n         SPACE 2\n         MEXIT\n.XXNOG   AIF   (T'&LABEL EQ 'O').XXEXIT     SKIP IF NO LABEL\n&LABEL   DS    0H\n.XXEXIT  MEND\n./ ADD LEVEL=40,SOURCE=0,NAME=XXGPSRCH\n         MACRO\n        XXGPSRCH &DIREC,&TIME\n.**-->MACRO: XXGPSRCH  INNER MACRO FOR XGPGEN . . . . . . . . . . . . .\n.*     ARGUMENTS:\n.*       &DIREC= G--> INPUT\n.*               P--> OUTPUT\n.*       &TIME=1 --> FIRST CALL, SETS UP EXTRA CODE AND ACTS AS &SYSNDX\n.*             2--> SECOND CALL\n.*. . . . . . . . . . . . .. .  . . . . . . . . . . . . . . . . . . . .\n         L     R3,X&DIREC.ELEM .   GET # LAST POINTER TO OPEN FILES\n         LA    R1,X&DIREC.PNTSRT . GET @ OF FIRST POINTER\n         LTR   R3,R3 .             ARE THERE ANY ELEMENTS?\n         BE    X&DIREC.MAKE&TIME   NO - GO CREATE ONE\n         LA    R2,12 .             SET UP INCREMENT SIZE\nX&DIREC.LOOP&TIME CLC 0(8,R1),X&DIREC.CURENT COMPARE DD NAMES\n         BE    X&DIREC.CONT&TIME   IF EQUAL, GO TO I/O\n         BXLE  R1,R2,X&DIREC.LOOP&TIME ^EQUAL, SEARCH TILL END OF TABLE\n         SPACE 2\n         MEND\n//*\n//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n//* STEP 5 - ADD ASSIST PROCEDURE TO SYS2.PROCLIB.\n//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n//*\n//PROC     EXEC PGM=IEBUPDTE,PARM=NEW\n//SYSPRINT DD  SYSOUT=*\n//SYSUT2   DD  DISP=SHR,DSN=SYS2.PROCLIB         <== TARGET LIBRARY\n//SYSIN    DD  DATA\n./ ADD NAME=ASSIST\n//ASSIST   PROC\n//DATA     EXEC PGM=ASSIST,REGION=4096K,PARM='BATCH,MACRO=H'\n//SYSPRINT DD  SYSOUT=*\n//SYSIN2   DD  DDNAME=SYSIN2  (ONLY NEEDED IF &$DATARD=1: 2 READERS)\n//SYSPRINT DD  SYSOUT=*,DCB=(RECFM=FA,LRECL=133,BLKSIZE=133) PRINTER\n//SYSPUNCH DD  SYSOUT=B,DCB=(RECFM=F,LRECL=80,BLKSIZE=80)    PUNCH\n//SYSUT1   DD  UNIT=SYSDA,DISP=(,DELETE),SPACE=(3520,(100,10)),\n//             DCB=(RECFM=F,BLKSIZE=3520)      DISK INTERMEDIATE\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR\n/*\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ASTEST00": {"ttr": 17670, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x132?\\x01\\x132?\\x010\\x00\\x94\\x00\\x94\\x00\\x00\\xc1\\xe2\\xe2\\xc9\\xe2\\xe3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-11-19T00:00:00", "modifydate": "2013-11-19T01:30:00", "lines": 148, "newlines": 148, "modlines": 0, "user": "ASSIST"}, "text": "//ASTEST00 JOB (SYS),'ASSIST IVP TEST #0',CLASS=S,MSGCLASS=X\n//*\n//TESTPROG EXEC ASSIST\n//SYSIN DD *\n$JOB   ASSIST  TESTCVB\n         MACRO\n         REGS  &SYM\n         LCLA  &N\n         LCLC  &R\n&R       SETC  'R'\n         AIF   ('&SYM' EQ '').NEXT\n&R       SETC  '&SYM'\n.NEXT    ANOP\n&N       SETA  0\n****\n*\n*     MACRO TO ESTABLISH REGISTER EQUATES\n*\n****\n         SPACE 2\n.LOOP    ANOP\n&R&N     EQU   &N\n&N       SETA  &N+1\n         AIF   (&N LT 16).LOOP\n         MEND\n         REGS\nTESTCVB  CSECT\n         USING *,15\nREADLOOP XREAD CARD\n         BNZ   EOF\n*\n* DERIVE TERMID FROM NETNAME\n*\n         LA    R8,NETNAME          ADDRESS NETNAME FIELD\n         LH    R6,NETNAMLN         PICK UP NETNAME LENGTH\n         LA    R7,4                SET LENGTH FOR COMPARE\n         CR    R6,R7               NETNAME LONGER THAN 4 CHARS?\n         BNH   NETNAMSL            ...NO, TAKE FIRST N CHARS\nNETSCAN1 DS    0H\n* SCAN TO FIND LAST 4 NON-BLANK CHARS\n         BCTR  R6,R0               DECREMENT FOR NEXT CHAR\n         LA    R7,0(R6,R8)         ADDRESS NEXT CHAR\n         CLI   0(R7),C' '          IS IT BLANK?\n         BE    NETSCAN1            ...YES, TRY NEXT CHARACTER\n         LA    R7,3                SET LENGTH FOR SUBTRACT\n         AR    R8,R6               ADDRESS END OF NETNAME\n         SR    R8,R7               ADDRESS LAST 4 NON-BLANK CHARS\n         LA    R6,4                SET LENGTH OF 4 FOR MOVE\nNETNAMSL DS    0H\n* MOVE DERIVED TERMID TO RETURN FIELD. R8==>START ADDR, R6=LENGTH\n         BCTR  R6,R0               SET LENGTH FOR EXECUTE\n         EX    R6,TERMIDMV         SELECT TERMID\n*\n* HANDLE OTHER CASES\n*\n         MVC   PORTNUM(2),TRMIDSEL+2 GET LAST 2 CHARS OF NET NAME\n         CLC   =C'ASC',NETNAME     ASCII (7171) TERMINAL?\n         BE    ASCTERM\n         CLC   =C'T',NETNAME       REMOTE (SNA) TERMINAL?\n         BE    GMURMT\n         CLC   =C'WRLC',NETNAME    EXTERNAL (WRLC) TERMINAL?\n         BE    WRLCTERM\n         B     TERMDONE\n*\nTERMIDMV MVC   TRMIDSEL(0),0(R8)   EXECUTED MOVE FOR TERMID SELECTION\n*\n*    ASCNNN\nASCTERM  DS    0H\n         MVC   TRMIDSEL(1),=C'A'   MAKE 1ST CHAR OF ASCII TERMS \"A\"\n         B     TERMDONE\n*    WRLCNNNN\nWRLCTERM DS    0H\n         MVC   TRMIDSEL(1),=C'W'   MAKE 1ST CHAR OF WRLC TERMS \"W\"\n         B     TERMDONE\n*    GMU REMOTE SNA TERMINALS\nGMURMT   DS    0H\n         MVC   LINENUM,NETNAME+1\n         MVC   CTRLNUM,NETNAME+3\n         CLC   PORT0,LINENUM       2 DIGIT LINE NUMBER?\n         BH    TERMDONE\n         CLC   PORT0,CTRLNUM       2 DIGIT CNTRL NUMBER?\n         BH    TERMDONE\n         CLC   PORT0,PORTNUM       2 DIGIT PORT NUMBER?\n         BH    TERMDONE\n         MVC   TRMIDSEL(1),=C'T'\n         MVC   DECNNUM,LINENUM\n         BAL   R12,CNVRT\n         MVC   TRMIDSEL+1(1),0(R7) EXTRACT BASE36 CHARACTER\n         MVC   DECNNUM,CTRLNUM\n         BAL   R12,CNVRT\n         MVC   TRMIDSEL+2(1),0(R7) EXTRACT BASE36 CHARACTER\n         MVC   DECNNUM,PORTNUM\n         BAL   R12,CNVRT\n         MVC   TRMIDSEL+3(1),0(R7) EXTRACT BASE36 CHARACTER\n         B     TERMDONE\n*    SUBROUTINE TO CONVERT 2 DIGIT VALUE TO BINARY VALUE\nCNVRT    DS    0H\n         PACK  PACKPORT,DECNNUM  UNZONE (PACK) PORT NUMBER\n         CVB   R8,PACKPORT       PUT BINARY VALUE IN R6\n         LA    R7,BASE36         POINT TO BASE36 TABLE\n         AR    R7,R8\n         BR    R12\n*\nBASE36M  DS    0H\n         DC    CL1'$'\nBASE36   DC    CL10'0123456789'\n         DC    CL10'ABCDEFGHIJ'\n         DC    CL10'KLMNOPQRST'\n         DC    CL6'UVWXYZ'\nPORT0    DC    CL2'00'\n*\n*    TERMINAL ID CREATION COMPLETED  ...\n*\nTERMDONE DS    0H\n         XPRNT CARD-1,81\n         B     READLOOP\nEOF      BR    14\n         DC    CL1' '\nCARD     DS    0CL80\nNETNAME  DS    CL8                 START OF NETNAME\n         DS    CL4\nLINENUM  DS    CL2'00'           HOLDS LAST 2 CHARS OF NETNAME\n         DS    CL4\nCTRLNUM  DS    CL2'00'           HOLDS LAST 2 CHARS OF NETNAME\n         DS    CL4\nPORTNUM  DS    CL2'00'           HOLDS LAST 2 CHARS OF NETNAME\n         DS    CL4\nDECNNUM  DS    CL2'00'           HOLDS LAST 2 CHARS OF NETNAME\n         DS    CL4\nTRMIDSEL DS    CL4                 TERMINAL ID SELECTED\n         DC    CL80' '\nPACKPORT DS    D                 HOLD'S PACKED VERSION OF PORTNUM\nNETNAMLN DC    XL2'07'             LENGTH OF NETNAME\n         END\n$ENTRY\nT030101\nT000000\nT010100\nT040122\nT020207\nT040115\nT050505\nT252423\nASC858\nL745\nWRLCGOR\nCOSMICX\nTABCDEF\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ASTEST01": {"ttr": 17674, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x132?\\x01\\x132?\\x010\\x08N\\x08N\\x00\\x00\\xc1\\xe2\\xe2\\xc9\\xe2\\xe3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-11-19T00:00:00", "modifydate": "2013-11-19T01:30:00", "lines": 2126, "newlines": 2126, "modlines": 0, "user": "ASSIST"}, "text": "//ASTEST01 JOB (SYS),'ASSIST IVP TEST #1',CLASS=S,MSGCLASS=X\n//*\n//TESTPROG EXEC ASSIST\n//SYSIN DD *\n$JOB   ASSIST  TEST01XX,NOLOAD     COMMENTS\n*        ========== CONTROL PROGRAM/PARM HANDLING TESTS ==========\n*        ========== CONTROL PROGRAM/PARM HANDLING TESTS ==========\n*        ========== CONTROL PROGRAM/PARM HANDLING TESTS ==========\n*        ========== CONTROL PROGRAM/PARM HANDLING TESTS ==========\n*        ========== CONTROL PROGRAM/PARM HANDLING TESTS ==========\n*\n*        A USEFUL SET OF PARM OPTIONS TO TRY THIS BATCH WITH IS:\n*        PARM='BATCH,CPAGE,SSX,PD=2,P=4,RD=50,T=3,R=190'  (360/67)\n*\n*        IT MAY BE INTERESTING TO COMPARE RESULTS WITH AND WITHOUT\n*        THE FOLLOWING OPTIONS:   NOLOAD,  CMPRS,  LARGE\n*        ========== CONTROL PROGRAM/PARM HANDLING TESTS ==========\n*        ========== CONTROL PROGRAM/PARM HANDLING TESTS ==========\n*        ========== CONTROL PROGRAM/PARM HANDLING TESTS ==========\n*        ========== CONTROL PROGRAM/PARM HANDLING TESTS ==========\n         END\n********* THESE CARDS SHOULD BE SKIPPED BY ASSIST\n$ENTRY                  THIS ENTRY CARD SHOULD BE IGNORED\n********** TEST0100 - TEST 026 KEYPUNCH CONVERSION\n$JOB   ASSIST  TEST0100,KP#26,SS,SSX,SSD\n         TITLE @TEST 026 KEYPUNCH OPTION@\n*ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789 &-@%*<#,$.\n*        LETTERS   ABCDEFGHIJKLMNOPQRSTUVWXYZ\n*        DIGITS    0123456789\n*        PLUS & MINUS - TIMES * DIVIDE / LEFT PAREN % RIGHT PAREN <\n*        QUOTE @ EQUALS # COMMA , DOLLAR $ PERIOD .\nTEST026  CSECT\n         USING *,15\nREADLOOP XREAD CARD\n         BNZ   EOF\n         XPRNT CARD-1,81\n         B     READLOOP\nEOF      BR    14\n         DC    C@0@\nCARD     DS    CL80\n         END\n$ENTRY\n*ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789 &-@%*<#,$.\n*        LETTERS   ABCDEFGHIJKLMNOPQRSTUVWXYZ\n*        DIGITS    0123456789\n*        PLUS & MINUS - TIMES * DIVIDE / LEFT PAREN % RIGHT PAREN <\n*        QUOTE @ EQUALS # COMMA , DOLLAR $ PERIOD .\n*********  TEST JOB 0101  - TEST PAGE CONTROL, RELOCATION MODE\n$JOB   ASSIST  TEST0101,PD=1,SSD,TD=0.05,DEBUG=8,RELOC\n         TITLE 'TEST RELOC MODE, RECORD OVERRRUN, DUMP SINGLE SPACE'\nTEST     CSECT\n         USING *,15\n         XDUMP ,                   MAKE SURE XDUMP WORKS OK RELOCATED\nLOOP     EQU   *\n         L     1,16                CVT POINTER\n         XDUMP 0(1),160            DUMP CVT\n         L     1,0(1)              TCB WORD\n         L     1,4(1)              CURRENT TCB\n         XDUMP 0(1),80             DUMP TCB\n         L     1,12(1)             TIOT\n         XDUMP 0(1),100            SHPW PIECE OF TIOT\n         B     LOOP                    LOOP WHILE PRINTING\n         END\n$ENTRY                             CARD REQUIRD FOR EXECUTION\n**********     TEST RUN 0102 - TEST FOR OVERRUN (RECORD) IN ASSEMBLY\n********* ALSO CHECK TO MAKE SURE CPAGE AND BATCH CAN'T BE OVERRIDEN\n$JOB   ASSIST  TEST0102,R=10,P=2,SS,NOCPAGE,NOBATCH\n         TITLE 'OVERRRUN RECORDS IN ASSEMBLY'\nTEST     CSECT\n*1\n*2\n*3\n*4\n*5\n*6\n*7\n*8\n*9\n         END\n$ENTRY         NO ERROR DURING EXEC, BUT SHOULD NOT EXEC ANYWAY.\n*********      TEST RUN 0103 - OVERRUN PAGE LIMIT IN ASSEMBLY\n$JOB   ASSIST  TEST0103,P=1,NOSS,R=100\n         TITLE 'OVERRRUN PAGE LIMIT DURING ASSEMBLY'\nTESTOVER CSECT\n         EJECT\nA        EQU   *                   SHOULD NOT PRINT-OVER***************\n         END\n$ENTRY                             SHOULD NOT EXECUTE\n**********     TEST RUN 0104 - TIME OVERRUN DURING ASSEMBLY\n$JOB   ASSIST  TEST0104,T=0.01\n         TITLE 'TIME OVERRUN DURING ASSEMBLY'\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n         END\n$ENTRY             SHOULD BE SKIPPED BY ASSIST\n**********     TEST RUN 0105 - TEST NULLING OF DUMP PARMS\n$JOB   ASSIST  TEST0105,TD=0,RD=0,PD=0,R=100,L=50,P=2\n         TITLE 'LOOP, SAVING NOTHING FOR DUMP'\nTEST     CSECT\n         BR    15                  LOOP, WAIT FOR DUMP\n         END\n$ENTRY                             THIS CARD REQUIRED\n**********     TEST RUN 0106 - MAKE SURE $ENTRY CARD REQUIRED\n$JOB   ASSIST  TEST0106,T=1,R=50,L=50,P=1,NOLIST\n         TITLE 'TEST TO MAKE SURE $ENTRY CARD REQUIRED'\nTEST     CSECT\n         BR    15                  LOOP, BUT SHOULD NEVER EXECUTE\n         END\n*********      THIS SHOULD BE $ENTRY CARD TO OBTAIN EXECUTION\n**********     TEST RUN 0107 - REPLACE MONITOR TEST\n$JOB   ASSIST  TEST0107,REPL\n         TITLE 'EVALUT REPLACEMENT TEST'\nEVALUT   CSECT\n         EXTRN SDBCDX              WILL USE THIS INSTEAD\n         USING *,15\n         ST    14,SAVE14           SAVE 14\n         CLC   0(5,7),=CL5'X+Y+Z'  ABEND CODE\n         BE    0                   YES, BRANCH OUT AND BLOW UP\n         L     15,=V(SDBCDX)       TREAT ALL AS SELF-DEF TERM\n         BALR  14,15               CALL IT\n         USING *,14                NOTE TEMP\n         L     14,SAVE14           RELOAD REG TO RETUNR\n         BR    14\nSAVE14   DS    F                   SAVE WORD FOR R14\n         END\n$ENTRY                             FIRST $ENTRY CARD, FOR REPLACE RUN\n         TITLE 'TEST PROGRAM FOR REPLACEA RUN'\nTESTREPL CSECT\n         USING *,15\nA        EQU   B+C+D               SHOULD GIVE WRONG ANSWER\nE        EQU   0                   SHOULD BE CORRECT\nF        EQU   X+Y+Z               SHOULD BLOW UP\nR        EQU   A+B+C+D             SHOULD NOT BE CALLED\n         END\n$ENTRY                             2ND $ENTRY, SHOULD GET NO EXEC\n********** TEST0109  - MAKE SURE XREAD STOPPED WHEN IN RELOC MODE\n$JOB   ASSIST  TEST0109,RELOC\n         TITLE 'TEST CONTROL OVER BAD XREAD IN RELOC MODE'\n         USING *,15\n         XREAD 0                   TRY TO READ CARD INTO LOW CORE\n$ENTRY\n********* THIS DATA CARD SHOULD NOT BE ALLOWED TO BE READ\n$JOB   ASSIST  TEST20XX,NOLOAD     COMMENTS\n*        ========== OBJECT DECK OUTPUT TESTS DEC\n*        ========== OBJECT DECK OUTPUT TEST DECKS ==========\n*        ========== OBJECT DECK OUTPUT TEST DECKS ==========\n*        ========== OBJECT DECK OUTPUT TEST DECKS ==========\n*        ========== OBJECT DECK OUTPUT TEST DECKS ==========\n*        ========== OBJECT DECK OUTPUT TEST DECKS ==========\n*        ========== OBJECT DECK OUTPUT TEST DECKS ==========\n*        ========== OBJECT DECK OUTPUT TEST DECKS ==========\n*        ========== OBJECT DECK OUTPUT TEST DECKS ==========\n*        ========== OBJECT DECK OUTPUT TEST DECKS ==========\n*        ========== OBJECT DECK OUTPUT TEST DECKS ==========\n*        ========== OBJECT DECK OUTPUT TEST DECKS ==========\n*        ========== OBJECT DECK OUTPUT TEST DECKS ==========\n*        ========== OBJECT DECK OUTPUT TEST DECKS ==========\n*        ========== OBJECT DECK OUTPUT TEST DECKS ==========\n         END\n**********     TEST20000 - TEST DECK FACILITY - NORMAL DECK\n$JOB   ASSIST  TEST2000,DECK\n         TITLE 'TEST NORMAL OBJECT DECK OUTPUT'\n*              **NOTE** SPECIFY NO $ENTRY CARD - JUST GET DECK.\n         CSECT\n         USING *,15                NORMAL NENTRY\n         B     BEGIN               GO AROUND CONSTANT\n         DC    C'NORMAL ENTRY POINT TEST'\n         DS    0H                  FIX TEMPORARY BUG\nBEGIN    XREAD CARD\n         BNZ   0(14)               RETURN WHEN EOF\n         XPRNT CARD-1,81           PRINT IT\n         B     BEGIN               LOOP\n         DC    C'0'\nCARD     DS    CL80                TEST FILL\n         END\n**********     TEST2010 TEST DECK FACILITY - ENTRY POINT NOT FIRST BYTE\n$JOB   ASSIST  TEST2010,DECK\n         TITLE 'TEST TO MAKE SURE CAN ENTER NOT AT BEGINNING'\n*              ALSO TEST FOR EXACT LENGTH 2*56\nTESTDECK CSECT\n         DC    C'// WILL BLOW UP IF ENTERS HERE //'\n         USING TESTE,15            NOTE USING\nTESTE    XPRNT =CL20'0*** GOOD DECK ***',20\n         BR    14                  QUIT\n         LTORG\n         ORG   TESTDECK+112        112 BYTES - EXACTLY TWO TXT CARDS\n         END TESTE                 ENTER NOT AT BEGINNING\n********* TEST2020 - GET DECK FOR PROGRAM REQUIRING RELOC MODE\n$JOB   ASSIST  TEST2020,DECK,RELOC,T=2,R=100\n         TITLE 'GET DECK FOR PROGRAM REQUIRING RELOC MODE'\nTEST     CSECT\n         USING *,15\n         XDUMP ,                   MAKE SURE XDUMP WORKS OK RELOCATED\nLOOP     EQU   *\n         L     1,16                CVT POINTER\n         XDUMP 0(1),160            DUMP CVT\n         L     1,0(1)              TCB WORD\n         L     1,4(1)              CURRENT TCB\n         XDUMP 0(1),80             DUMP TCB\n         L     1,12(1)             TIOT\n         XDUMP 0(1),100            SHPW PIECE OF TIOT\n         B     LOOP                    LOOP WHILE PRINTING\n         END\n$ENTRY\n**********     TEST2030 MAKE SURE DECK NOT PUNCHED IF TOO MANY ERRORS\n$JOB   ASSIST  TEST2030,DECK,NERR=0\n         TITLE 'MAKE SURE NO DECK PUNCHED IF TOO MANY ERRORS'\n         DC    C'THIS BETTER NOT BE PUNCHED INTO OBJECT DECK'\nTHIS IS A BAD CARD WITH ERRORS WHICH SHOULD STOP DECK\n         END\n**********     TEST2040 MAKE SURE NO DECK PUNCHED IF REPL MODE\n$JOB   ASSIST  TEST2040,REPL,DECK\n         TITLE 'TEST TO MAKE SURE NO DECK PUNCHED IF REPL RUN'\nEVALUT   CSECT\n         BR    14                  RETURN\n         END\n$ENTRY\n         TITLE 'TEST DECK PART 2 FOR NO DECK DURING REPL'\n*              DON'T USE ANY CALLS TO EVALUT, SO WILL BE OK\n         CSECT\n         DC    F'0'\n         END\n**********     TEST2050 PUNCH OBJECT DECK WHICH WILL BE TOO BIG\n$JOB   ASSIST  TEST2050,DECK\n         TITLE 'PUNCH OBJECT DECK NEEDING 5K-WILL BE TOO BIG'\nTESTBIG  CSECT\n         USING *,15\n         XPRNT =CL80' IF THIS MSG APPEARS, FREE= WAS TOO SMALL',80\n         BR    14                  RETURN IF EVER GET HER\n         LTORG\n         ORG   TESTBIG+5000\n         END\n$JOB   ASSIST  TEST30XX,NOLOAD     COMMENTS\n*        ========== OBJECT DECK INPUT TESTS ==========\n*        ========== OBJECT DECK INPUT TESTS ==========\n*        ========== OBJECT DECK INPUT TESTS ==========\n*        ========== OBJECT DECK INPUT TESTS ==========\n*        ========== OBJECT DECK INPUT TESTS ==========\n*\n*        ORIGINALLY TESTED WITH FOLLOWING PARM FIELD (ON 360/67):\n*        PARM='BATCH,CPAGE,T=2,R=60'\n*\n*        ========== OBJECT DECK INPUT TESTS ==========\n*        ========== OBJECT DECK INPUT TESTS ==========\n*        ========== OBJECT DECK INPUT TESTS ==========\n*        ========== OBJECT DECK INPUT TESTS ==========\n*        ========== OBJECT DECK INPUT TESTS ==========\n*        ========== OBJECT DECK INPUT TESTS ==========\n         END\n**********     TEST3000 - NORMAL OBJECT INPUT (FROM TEST2000)\n$JOB   ASSIST  TEST3000,OBJIN      (NORMAL OBJECT INPUT - FROM TEST2000)\n TXT             00 NORMAL ENTRY POINT TEST5\\ 0  & =  \\ 0    00 05555555\n TXT            55555555555555555555555555555555555555555555555555555555\n TXT            555555555555555555555555\n END\n$ENTRY                             TEST3000\n*********      ONLY DATA CARD TO BE PRINTED BY TEST3000 **********\n**********     TEST3010 - TEST ENTRY NOT AT BEGINNING (DECK:TEST2010\n$JOB   ASSIST  TEST3010,OBJIN\n TXT            // WILL BLOW UP IF ENTERS HERE //5\\ 0+    55555555555555\n TXT            55555555555555555555555555555555555555555555555555555555\n TXT            0*** GOOD DECK ***  5555\n END\n$ENTRY                             TEST3010\n**********     TEST3020 RELOC MODE TEST, DEC K FROM TEST2020\n$JOB   ASSIST  TEST3020,OBJIN,RELOC,T=2,R=200\n TXT  0          -        \\/            \\/   &    \\/     00 5555\n END  0\n$ENTRY                             TEST3020\n**********     TEST3030 MAKE SURE NO DECK PUNCHED IF OBJIN USED.\n**********     DECK USED IS FROM TEST2000\n$JOB   ASSIST  TEST3030,OBJIN,DECK\n TXT             00 NORMAL ENTRY POINT TEST5\\ 0  & =  \\ 0    00 05555555\n TXT            55555555555555555555555555555555555555555555555555555555\n TXT            555555555555555555555555\n END\n$ENTRY\n**********     TEST3050 - RUN OUT OF SPACE(DECKS TEST2050+2020 TOGETHR)\n*********      SHOULD PRODUCE MSSG AL998    + AL999\n$JOB   ASSIST  TEST3050,OBJIN\n TXT            \\ 0  &   IF THIS MSG APPEARS, FREE= WAS TOO SMALL\n TXT                                            555555555555555555555555\n TXT            55555555555555555555555555555555555555555555555555555555\n TXT   y        55555555555555555555555555555555555555555555555555555555\n TXT   \\        55555555555555555555555555555555555555555555555555555555\n TXT            55555555555555555555555555555555555555555555555555555555\n TXT   &        55555555555555555555555555555555555555555555555555555555\n TXT   h        55555555555555555555555555555555555555555555555555555555\n TXT   {        55555555555555555555555555555555555555555555555555555555\n TXT   8        55555555555555555555555555555555555555555555555555555555\n TXT            55555555555555555555555555555555555555555555555555555555\n TXT            55555555555555555555555555555555555555555555555555555555\n TXT            55555555555555555555555555555555555555555555555555555555\n TXT   Q        55555555555555555555555555555555555555555555555555555555\n TXT            55555555555555555555555555555555555555555555555555555555\n TXT            55555555555555555555555555555555555555555555555555555555\n TXT            55555555555555555555555555555555555555555555555555555555\n TXT            55555555555555555555555555555555555555555555555555555555\n TXT   0        55555555555555555555555555555555555555555555555555555555\n TXT            55555555555555555555555555555555555555555555555555555555\n TXT   -        55555555555555555555555555555555555555555555555555555555\n TXT   q        55555555555555555555555555555555555555555555555555555555\n TXT   }        55555555555555555555555555555555555555555555555555555555\n TXT            55555555555555555555555555555555555555555555555555555555\n TXT            55555555555555555555555555555555555555555555555555555555\n TXT            55555555555555555555555555555555555555555555555555555555\n TXT            55555555555555555555555555555555555555555555555555555555\n TXT   Y        55555555555555555555555555555555555555555555555555555555\n TXT            55555555555555555555555555555555555555555555555555555555\n TXT            55555555555555555555555555555555555555555555555555555555\n TXT            55555555555555555555555555555555555555555555555555555555\n TXT   H        55555555555555555555555555555555555555555555555555555555\n TXT            55555555555555555555555555555555555555555555555555555555\n TXT            55555555555555555555555555555555555555555555555555555555\n TXT            55555555555555555555555555555555555555555555555555555555\n TXT   y        55555555555555555555555555555555555555555555555555555555\n TXT   \\        55555555555555555555555555555555555555555555555555555555\n TXT            55555555555555555555555555555555555555555555555555555555\n TXT   &        55555555555555555555555555555555555555555555555555555555\n TXT   h        55555555555555555555555555555555555555555555555555555555\n TXT   {        55555555555555555555555555555555555555555555555555555555\n TXT   8        55555555555555555555555555555555555555555555555555555555\n TXT  0          -        \\/            \\/   &    \\/     00 5555\n END  0\n$ENTRY\n**********     TEST3060 NULL OBJECT DECK - SHOULD ABORT\n*********      SHOULD PRODUCE MSSG AL996    + AL999\n$JOB   ASSIST  TEST3060,OBJIN\n END\n$ENTRY\n**********     TEST3070 - BAD TXT ADDRESS ORDER. DECKS ARE 2020 + 2000\n*********      SHOULD PRODUCE MSSG AL997    + AL999\n$JOB   ASSIST  TEST3070,OBJIN\n TXT                                            555555555555555555555555\n TXT            \\ 0  &   IF THIS MSG APPEARS, FREE= WAS TOO SMALL\n$ENTRY\n$JOB   ASSIST  PROGTEST,NOLOAD   STUDENT-WRITTEN PROGRAMS BEGIN NOW\n*        ========== STUDENT-WRITTEN PROGRAM EXAMPLES ==========\n*        ========== STUDENT-WRITTEN PROGRAM EXAMPLES ==========\n*        ========== STUDENT-WRITTEN PROGRAM EXAMPLES ==========\n*        ========== STUDENT-WRITTEN PROGRAM EXAMPLES ==========\n*        ========== STUDENT-WRITTEN PROGRAM EXAMPLES ==========\n*        ========== STUDENT-WRITTEN PROGRAM EXAMPLES ==========\n*        ========== STUDENT-WRITTEN PROGRAM EXAMPLES ==========\n*        ========== STUDENT-WRITTEN PROGRAM EXAMPLES ==========\n*        ========== STUDENT-WRITTEN PROGRAM EXAMPLES ==========\n*        ========== STUDENT-WRITTEN PROGRAM EXAMPLES ==========\n*        ========== STUDENT-WRITTEN PROGRAM EXAMPLES ==========\n*        ========== STUDENT-WRITTEN PROGRAM EXAMPLES ==========\n*        ========== STUDENT-WRITTEN PROGRAM EXAMPLES ==========\n*        ========== STUDENT-WRITTEN PROGRAM EXAMPLES ==========\n*        ========== STUDENT-WRITTEN PROGRAM EXAMPLES ==========\n*        ========== STUDENT-WRITTEN PROGRAM EXAMPLES ==========\n*        ========== STUDENT-WRITTEN PROGRAM EXAMPLES ==========\n*        ========== STUDENT-WRITTEN PROGRAM EXAMPLES ==========\n*        ========== STUDENT-WRITTEN PROGRAM EXAMPLES ==========\n*        ========== STUDENT-WRITTEN PROGRAM EXAMPLES ==========\n*        ========== STUDENT-WRITTEN PROGRAM EXAMPLES ==========\n*        ========== STUDENT-WRITTEN PROGRAM EXAMPLES ==========\n*        ========== STUDENT-WRITTEN PROGRAM EXAMPLES ==========\n*        ========== STUDENT-WRITTEN PROGRAM EXAMPLES ==========\n*        ========== STUDENT-WRITTEN PROGRAM EXAMPLES ==========\n*        ========== STUDENT-WRITTEN PROGRAM EXAMPLES ==========\n*        ========== STUDENT-WRITTEN PROGRAM EXAMPLES ==========\n*        ========== STUDENT-WRITTEN PROGRAM EXAMPLES ==========\n*        ========== STUDENT-WRITTEN PROGRAM EXAMPLES ==========\n*        ========== STUDENT-WRITTEN PROGRAM EXAMPLES ==========\n*        ========== STUDENT-WRITTEN PROGRAM EXAMPLES ==========\n*        ========== STUDENT-WRITTEN PROGRAM EXAMPLES ==========\n*        ========== STUDENT-WRITTEN PROGRAM EXAMPLES ==========\n*        ========== STUDENT-WRITTEN PROGRAM EXAMPLES ==========\n*        ========== STUDENT-WRITTEN PROGRAM EXAMPLES ==========\n*        ========== STUDENT-WRITTEN PROGRAM EXAMPLES ==========\n*        ========== STUDENT-WRITTEN PROGRAM EXAMPLES ==========\n*        ========== STUDENT-WRITTEN PROGRAM EXAMPLES ==========\n*        ========== STUDENT-WRITTEN PROGRAM EXAMPLES ==========\n*        ========== STUDENT-WRITTEN PROGRAM EXAMPLES ==========\n         END\n$JOB   ASSIST  PROGTEST\n         TITLE 'MULTIPUNCHED DATA EXECUTION TEST'\n*/AUTUMN70 JOB 'I9477,T=0005,R=0600,Z1335','SPENCER WILLIAM III'        CS410.01\n**             THIS BUG CAUSED BY USER READING IN MULTIPUNCHED DATA\n*        AND SCANNING CHARACTERS OF VALUE > C'9'.\n*        0C7 INTERRUPT OCCURS IN XXXXDECI, 0C6 OR 0C4 IN XXXXSNAP.\n        CSECT\n         USING *,15\n        LA 10,1(0)\n        LR 11,10\nREAD    XREAD CARD1\n         BC 4,14\n         XPRNT CARD1-1,9\n        XDECI 6,CARD1\n        XDECI 7,CARD2\n        BCT 10,DATIN\n        BCT 11,M1IN\n        LA 11,1(0)\n         LR 10,11\n        AR 11,6\n        B READ\nM1IN     LA 10,1(0)\n        AR 10,6\n        XPRNT =C'0',1\n         B READ\nDATIN   LR 8,6\n        AR 8,7\n        ST 8,BUF\n        MVC  APB(4),BUF\n         XDECO 8,IAPB\n        LR 9,6\n        MR 8,7\n        ST 9,BUF\n        MVC  ATB(4),BUF\n         XDECO 9,IATB\n        LR 8,6\n        SRDA 8,32\n         DR 8,7\n        ST 9,BUF\n        MVC  ADB(4),BUF\n         XDECO 9,IADB\n        ST 6,BUF\n        MVC  A(4),BUF\n        ST 7,BUF\n        MVC  B(4),BUF\n        XDECO 6,IA\n        XDECO 7,IB\n        XPRNT CHAR,102\n        XPRNT IOUT,102\n         B READ\n         DS  F\n         DC 4C'    '\nCHAR    DC   C' CHARACTER/INPUT,A         '\nA       DS 4C\n        DC   C' ,B=         '\nB       DS 4C\n        DC   C' A+B=         '\nAPB     DS 4C\n        DC   C' A/B=         '\nADB     DS 4C\n         DC    C' A*B=         '\nATB     DS 4C\n         DS F\n         DC 4C'    '\nIOUT     DC   C'0INTEGER/          '\nIA      DS 12C\n        DC  C'      '\nIB      DS  12C\n        DC  C'      '\nIAPB    DS 12C\n         DC  C'     '\nIADB    DS 12C\n        DC  C'     '\nIATB    DS 12C\n        DC   C'            '\nBUF      DS F\n         DS  F\n         DC 4C'    '\nCARD1   DS F\nCARD2   DS F\n         DS   80C\n         END\n$ENTRY\n   2\n   2\n   9   9\n   6   7\n   2\nABCDEFGH\n\n$JOB   ASSIST  PROGTEST\n         TITLE 'OVERALL TEST - STUDENT-WRITTEN PROGRAM'\n*        *** SHOULD EXECUTE 370 INSTRUCTIONS, PRINT 2 LINES, THEN\n*        TERMINATE WITH 220 COMPLETION CODE (REWD PAS EOF).\n*              CMPSC 404 - FALL 1970 - INSTRUCTORE R. VARNEY\nMAIN     CSECT\n         ENTRY     IN,OUT,SUPERVR\n         STM       14,12,12(13)\n         BALR      12,0\n         USING     *,12\n         ST        13,MAINSAV\nSTART    LA        9,0\n         LA        6,0\n         LA        11,0\n         L         15,=V(COROUT2)\n         BR        15\nOUT      ST        14,BIN1\n         L         15,BOUT1\n         BR        15\nIN       ST        14,BOUT1\n         L         15,BIN1\nINX      BR        15\nSUPERVR  L         13,MAINSAV\n         LM        14,12,12(13)\n         BR        14\n         LTORG\n         DS        0F\nMAINSAV  DS        F\nBOUT1    DS        F\nBIN1     DC        V(COROUT1)\nCOROUT2  CSECT\n         ENTRY     STORE,STORE1\n         PRINT     NOGEN\n         BALR      13,0\n         USING     *,13\n         B         OUT1\n         DS        0F\nBLANK    DC        4C' '\nOUTPUT   DS        64C\nOUT1     LA        4,0\n         LA        1,OUTPUT\n         LA        5,BLANK\n         MVC       0(64,1),3(5)\n         LA        3,3\n         LTR       9,9\n         BH        STORE\nH1       L         15,=V(IN)\n         BALR      14,15\nSTORE    ST        10,OUTPUT(4)\n         LA        4,1(4)\n         CLI       10,C'.'\n         BE        H9\n         L         15,=V(IN)\n         BALR      14,15\nSTORE1   BCT       3,STORE\n         LA        3,3\n         LA        4,1(4)\n         C         4,=F'63'\n         BNE       STORE\nH9       LA        3,3\n         XPRNT     BLANK(3),65\n         CLI       OUTPUT+62,C'.'\n         BE        SUPER\n         LA        9,1\n         B         OUT1\nSUPER    L         15,=V(SUPERVR)\n         BR        15\n         LTORG\nCOROUT1  CSECT\n         BALR      8,0\n         USING     *,8\n         B         IN1\nH2       L         15,=V(OUT)\n         BALR      14,15\nIN1      L         15,=V(NEXTCHAR)\n         BALR      14,15\n         CLI       10,C'0'\n         BL        H2\n         ST        10,NUMBER\n         LA        5,NUMBER\n         PACK      DOUBLE(8),0(4,5)\n         CVB       5,DOUBLE\n         L         15,=V(BEGIN)\n         BALR      14,15\nREPEAT   L         15,=V(OUT)\n         BALR      14,15\n         S         5,=F'1'\n         BNM       REPEAT\n         B         IN1\n         LTORG\n         DS        0F\nNUMBER   DS        F\nDOUBLE   DS        D\nNEXTCHAR CSECT\n         ENTRY     BEGIN\n         PRINT     NOGEN\n         BALR      7,0\n         USING     *,7\n         B         BEGIN\n         DS        0F\nBLNK     DC        4C' '\nINPUT    DS        16F\nASTERICK DS        F\nBEGIN    ST        14,ASTERICK\nCHECK    LTR       11,11\n         BNE       F3\n         LTR       6,6\n         BE        READ\nF1       C         6,=F'16'\n         BNE       F2\n         LA        6,0\nREAD     XREAD     INPUT,64\n         LA        2,3\n         XPRNT     BLNK(2),65\nF2       L         11,INPUT(6)\nF3       IC        10,C' '\n         SLDA      10,8\n         LA        6,1(6)\n         CLI       10,C' '\n         BNE       ASTERICK\n         B         CHECK\n         LTORG\n         END\nA2B5E3426FG0ZYW3210PQ89R.\n$ENTRY\n$JOB   ASSIST  ICTEST,NOLOAD\n*        ==========  TEST DECKS FOR ASSEMBLER ==========\n*        ==========  TEST DECKS FOR ASSEMBLER ==========\n*        ==========  TEST DECKS FOR ASSEMBLER ==========\n*        ==========  TEST DECKS FOR ASSEMBLER ==========\n*        ==========  TEST DECKS FOR ASSEMBLER ==========\n*        ==========  TEST DECKS FOR ASSEMBLER ==========\n*        ==========  TEST DECKS FOR ASSEMBLER ==========\n*        ==========  TEST DECKS FOR ASSEMBLER ==========\n*        ==========  TEST DECKS FOR ASSEMBLER ==========\n*        ==========  TEST DECKS FOR ASSEMBLER ==========\n*        ==========  TEST DECKS FOR ASSEMBLER ==========\n*        ==========  TEST DECKS FOR ASSEMBLER ==========\n*        ==========  TEST DECKS FOR ASSEMBLER ==========\n*        ==========  TEST DECKS FOR ASSEMBLER ==========\n*        ==========  TEST DECKS FOR ASSEMBLER ==========\n         TITLE ' TEST DECK - IC - SS2 OPERAND FIELD BUG'\nICTESTAA CSECT\n         USING *,15\n*              ALL LENGTHS EXPLICIT.\n         AP    A(15),B(16)\n*              FIRST LENGTH EXPLICIT, 2ND IMPLIED.\n         AP    A(14),B\n         AP    A(14),=P'1'\n         AP    A(14),=C'1'\n         AP    A(14),=PL1'1'\n*              BOTH LENGTHS IMPLICIT.\n         AP    A,B\n         AP    A,=P'1'\n         AP    A,=PL1'1'\n         AP    A,=C'1'\n*              SECOND LENGTH EXPLICIT ONLY.\n         AP    A,B(4)\n*              ***** NEXT 5 STMTS MUST BE FLAGGED *****\nAL       EQU   L'A\nBL       EQU   L'B\nAL2      DC    A(AL,BL)\n         LA    0,AL\n         LA    0,BL\nA        DC    PL5'1'\nB        DC    PL3'1'\n         LA    0,L'A\n         LA    0,L'B\nC        DC    P'1'\n         LA    0,L'C\n         AP    A,C\n         END\n$JOB   ASSIST  ICTEST,NOLOAD\n         TITLE 'IC TEST - SS2 LENGTH PROBLEM - P CONSTANTS'\n*              ***** ALL STATEMENTS LEGAL\nICTESTAB CSECT\n         USING *,15\n         AP    A(14),=C'1'\n         AP    A(14),=C'1'\n         AP    A,=C'1'\n         AP    A(14),=B'1'\n         AP    A(14),=Z'1'\n         AP    A(14),=P'1'\n         AP    A(14),=H'1'\n         AP    A(14),=X'1'\n         AP    A(14),=PL1'1'\n         AP    A(14),=ZL1'1'\n         AP    A(14),=PL2'1'\n         AP    A,=PL2'1'\nA        DC    PL7'1'\n         END\n$JOB   ASSIST  ICTEST,NOLOAD\n         TITLE 'TEST FOR IC OR LT BUG - LITERAL OPERANDS IN SS2'\n*              ***** ALL STATEMENTS LEGAL *****\nIATESTAC CSECT\n         USING *,15\n         AP    0(2,3),0(4,5)\n         AP    0(2,3),=P'1'\n         AP    0(2,3),0(4,5)\n         AP    0(2,3),=PL2'1'\n         AP    A,0(4,5)\n         AP    A,=D'1'\n         AP    A(7),=D'1'\nA        DS    PL6\n         END\n$JOB   ASSIST  IBTEST,NOLOAD\n         TITLE 'IB TEST - MAKE SURE EQU'S PROPERLY UNDEFINED'\n*              ALL EQU'S SHOULD BE UNDEFINED\n  START\nAL EQU A\nAL1 EQU L'A\nAL2 EQU A+L'A\nA13 EQU L'A+A\nA   DS CL10\n   END\n$JOB   ASSIST  IBTEST,NOLOAD\n         TITLE 'MISSING DELIMITER BUG'\n*              *** TWO STATEMENTS SHOULD BE FLAGGED - NOT ABEND\n         START\n         DC    C'XXXXXXXXXX\n               WK SALARY\n         END\n         TITLE 'STORAGE ALLOCATION EXCESSION TEST-ASSEMBLER'\n         START\n*        THIS PROGRAM SHOULD CAUSE AN AS9## TERMINATION BECAUSE IT\n*        WILL CAUSE THE ASSEMBLER TO OVERRUN STORAGE LIMITS.\n*              CARDS ARE SUPPLIED UP TO 512K, ALTHOUGH A NUMBER OF\n*              THEM WILL NOT APPEAR IN THE LISTING\n*              ***NOTE *** THIS JOB WILL BE ACCEPTED IF NOLOAD USED.\n         DC    XL256'0',127XL256'0'    32K BYTES\n         DC    XL256'0',127XL256'0'    64K BYTES\n         DC    XL256'0',127XL256'0'    96K BYTES\n         DC    XL256'0',127XL256'0'   128K BYTES\n         DC    XL256'0',127XL256'0'   160K BYTES\n         DC    XL256'0',127XL256'0'   192K BYTES\n         DC    XL256'0',127XL256'0'   224K BYTES\n         DC    XL256'0',127XL256'0'   256K BYTES\n         DC    XL256'0',127XL256'0'   288K BYTES\n         DC    XL256'0',127XL256'0'   320K BYTES\n         DC    XL256'0',127XL256'0'   352K BYTES\n         DC    XL256'0',127XL256'0'   384K BYTES\n         DC    XL256'0',127XL256'0'   416K BYTES\n         DC    XL256'0',127XL256'0'   448K BYTES\n         DC    XL256'0',127XL256'0'   480K BYTES\n         DC    XL256'0',127XL256'0'   512K BYTES\n         END\n$JOB   ASSIST  IAOPTEST\n         TITLE 'IA-OP TEST - PASS 1 OPCODE RECOGNITION'\n*        *** IN A COMPLETE VERSION OF ASSIST, NO STMTS FLAGGED.\n         START\nRE       EQU   2                   EVEN FOR OK/ODD FOR TEST ODD REGS\nRG       EQU   4                   2ND REG- -EVEN TEST/ODD FOR REG TEST\nL        EQU   10                  LENGTH\n         USING *,15                HAVE SIMPLE USING SET UP\n         TITLE 'FIXED PT RR'\n         SPM   RE\n         BALR  RE,RG\n         BCTR  RE,RG\n         BCR   RE,RG\n         BCR   RE,RG\n         SSK   RE,RG               ***FLAGGED IF NO PRIVILEGED OPS ***\n         ISK   RE,RG               ***FLAGGED IF NO PRIVILEGED OPS ***\n         SVC   L                   ***FLAGGED IF NO PRIVILEGED OPS ***\n         LPR   RE,RG\n         LNR   RE,RG\n         LTR   RE,RG\n         LCR   RE,RG\n         NR    RE,RG\n         CLR   RE,RG\n         OR    RE,RG\n         XR    RE,RG\n         LR    RE,RG\n         CR    RE,RG\n         AR    RE,RG\n         SR    RE,RG\n         MR    RE,RG\n         DR    RE,RG\n         ALR   RE,RG\n         SLR   RE,RG\n         TITLE 'FLOATING POINT RR'\n*        *** ALL STMTS ON THIS PAGE MUST BE FLAGGED IF NO FLOATING PT.\n         LPDR  RE,RG\n         LNDR  RE,RG\n         LTDR  RE,RG\n         LCDR  RE,RG\n         HDR   RE,RG\n         LDR   RE,RG\n         ADR   RE,RG\n         SDR   RE,RG\n         MDR   RE,RG\n         DDR   RE,RG\n         AWR   RE,RG\n         SWR   RE,RG\n         LPER  RE,RG\n         LNER  RE,RG\n         LTER  RE,RG\n         LCER  RE,RG\n         HER   RE,RG\n         LER   RE,RG\n         CER   RE,RG\n         AER   RE,RG\n         SER   RE,RG\n         MER   RE,RG\n         DER   RE,RG\n         AUR   RE,RG\n         SUR   RE,RG\n         TITLE 'FIXED PT RX'\n         STH   RE,H1\n         LA    RE,C1\n         STC   RE,C1\n         IC    RE,C1\n         EX    RE,H1\n         BAL   RE,H1\n         BCT   RE,H1\n         BC    RE,H1\n         LH    RE,H1\n         CH    RE,H1\n         AH    RE,H1\n         SH    RE,H1\n         MH    RE,H1\n         CVD   RE,D1\n         CVB   RE,D1\n         ST    RE,F1\n         XDECO 5,C1+5              *** FLAGGED IF NO X-MACROS\n         XDECI 5,C1                *** FLAGGED IF NO X-MACROS\n         N     RE,F1\n         CL    RE,F1\n         O     RE,F1\n         X     RE,F1\n         L     RE,F1\n         C     RE,F1\n         A     RE,F1\n         S     RE,F1\n         M     RE,F1\n         D     RE,F1\n         AL    RE,F1\n         SL    RE,F1\n         TITLE 'FLOATING PT RX'\n*        *** ALL STMTS ON THIS PAGE MUST BE FLAGGED IF NO FLOATING PT.\n         STD   RE,D1\n         LD    RE,D1\n         CD    RE,D1\n         AD    RE,D1\n         SD    RE,D1\n         MD    RE,D1\n         DD    RE,D1\n         AW    RE,D1\n         SW    RE,D1\n         STE   RE,E1\n         LE    RE,E1\n         CE    RE,E1\n         AE    RE,E1\n         SE    RE,E1\n         ME    RE,E1\n         DE    RE,E1\n         AU    RE,E1\n         SU    RE,E1\n         TITLE 'RS AND SI FORMAT INSTRUCTIONS'\n         SSM   D1                  ***INVALID IF NO PRIVILEGED OPS\n         LPSW  D1                  ***INVALID IF NO PRIVILEGED OPS\n         DIAG  0,0                 **** INVALID IF NOT DEBUG\n         WRD   C1,1                ***INVALID IF NO PRIVILEGED OPS\n         RDD   C1,1                ***INVALID IF NO PRIVILEGED OPS\n         BXH   RE,RG,H1\n         BXLE  RE,RG,H1\n         SRL   RE,1\n         SLL   RE,2(2)\n         SRA   RE,64\n         SLA   RE,16\n         SRDL  RE,0(1)\n         SLDL  RE,4(2)\n         SRDA  RE,0(3)\n         SLDA  RE,0(0)\n         STM   RE,RG,F1\n         TM    C1,X'0'\n         MVI   C1,X'1'\n         TS    C1,X'1'\n         NI    C1,B'1'\n         CLI   C1,C'A'\n         OI    C1,C''''\n         XI    C1,C'&&'\n         LM    RE,RG,F1\n         SIO   D1                  *** INVALID IF NO PRIVILEGED OPS\n         TIO   D1                  *** INVALID IF NO PRIVILEGED OPS\n         HIO   D1                  *** INVALID IF NO PRIVILEGED OPS\n         TCH   D1                  *** INVALID IF NO PRIVILEGED OPS\n         XREPL H1,0                ** FLAGGED IF NO REPLACE FEATURE\n         TITLE 'SS INSTRUCTIONS'\n         MVN   C1,C2\n         MVC   C1,C2\n         MVZ   C1,C2\n         NC    C1,C2\n         CLC   C1,C2\n         OC    C1,C2\n         XC    C1,C2\n         TR    C1,C2\n         TRT   C1,C2\n         ED    C1,C2               *** INVALID IF NO DECIMAL FEATURE\n         EDMK  C1,C2               *** INVALID IF NO DECIMAL FEATURE\n         XREAD C1,L                *** FLAGGED IF NO X-MACROS\n         XPRNT C1,L                *** FLAGGED IF NO X-MACROS\n         XPNCH C1,L                *** FLAGGED IF NO X-MACROS\n         XDUMP D1,8                *** FLAGGED IF NO X-MACROS\n         XLIMD C1                  *** FLAGGED IF NO X-MACROS\n         XDUMP ,                   *** FLAGGED IF NO X-MACROS\n         MVO   C1,C2\n         PACK  C1,C2\n         UNPK  C1,C2\n         ZAP   P1,P2               *** INVALID IF NO DECIMAL FEATURE\n         CP    P1,P2               *** INVALID IF NO DECIMAL FEATURE\n         SP    P1,P2               *** INVALID IF NO DECIMAL FEATURE\n         MP    C1,C2               *** INVALID IF NO DECIMAL FEATURE\n         DP    C1,C2               *** INVALID IF NO DECIMAL FEATURE\n         SPACE 4\nD1       DS    D\nE1       DS    E\nF1       DS    F\nH1       DS    H\nC1       DS    C\nC2       DS    C\nP1       DS    P\nP2       DS    P\n         END\n$JOB   ASSIST  ICTEST\n         TITLE 'TEST ALIGNMENT AND ODD REGISTER CHECKING - IC'\n*        *** ALL STMTS USING H1,F1, OR D1 MUST BE FLAGGED .\n         START\nRE       EQU   1                   ODD REGISTER\nRG       EQU   3                   ODD REGISTER - BAD\nL        EQU   10                  LENGTH\n         USING *,15                HAVE SIMPLE USING SET UP\n         TITLE 'FIXED PT RR'\n         SPM   RE\n         BALR  RE,RG\n         BCTR  RE,RG\n         BCR   RE,RG\n         BCR   RE,RG\n         SSK   RE,RG               ***FLAGGED IF NO PRIVILEGED OPS ***\n         ISK   RE,RG               ***FLAGGED IF NO PRIVILEGED OPS ***\n         SVC   L                   ***FLAGGED IF NO PRIVILEGED OPS ***\n         LPR   RE,RG\n         LNR   RE,RG\n         LTR   RE,RG\n         LCR   RE,RG\n         NR    RE,RG\n         CLR   RE,RG\n         OR    RE,RG\n         XR    RE,RG\n         LR    RE,RG\n         CR    RE,RG\n         AR    RE,RG\n         SR    RE,RG\n         MR    RE,RG               ** ODD REGISTER ERROR\n         DR    RE,RG               ** ODD REGISTER ERROR\n         ALR   RE,RG\n         SLR   RE,RG\n         TITLE 'FLOATING POINT RR'\n*        *** ALL STMTS ON THIS PAGE MUST BE FLAGGED IF NO FLOATING PT.\n*        *** IF FLOATING PT EXISTS, ALL ON PAGE HAVE 2 ODD REG WARNS\n         LPDR  RE,RG\n         LNDR  RE,RG\n         LTDR  RE,RG\n         LCDR  RE,RG\n         HDR   RE,RG\n         LDR   RE,RG\n         ADR   RE,RG\n         SDR   RE,RG\n         MDR   RE,RG\n         DDR   RE,RG\n         AWR   RE,RG\n         SWR   RE,RG\n         LPER  RE,RG\n         LNER  RE,RG\n         LTER  RE,RG\n         LCER  RE,RG\n         HER   RE,RG\n         LER   RE,RG\n         CER   RE,RG\n         AER   RE,RG\n         SER   RE,RG\n         MER   RE,RG\n         DER   RE,RG\n         AUR   RE,RG\n         SUR   RE,RG\n         TITLE 'FIXED PT RX'\n         STH   RE,H1\n         LA    RE,C1\n         STC   RE,C1\n         IC    RE,C1\n         EX    RE,H1\n         BAL   RE,H1\n         BCT   RE,H1\n         BC    RE,H1\n         LH    RE,H1\n         CH    RE,H1\n         AH    RE,H1\n         SH    RE,H1\n         MH    RE,H1\n         CVD   RE,D1\n         CVB   RE,D1\n         ST    RE,F1\n         XDECO 5,C1+5              *** FLAGGED IF NO X-MACROS\n         XDECI 5,C1                *** FLAGGED IF NO X-MACROS\n         N     RE,F1\n         CL    RE,F1\n         O     RE,F1\n         X     RE,F1\n         L     RE,F1\n         C     RE,F1\n         A     RE,F1\n         S     RE,F1\n         M     RE,F1               *** ODD REGISTER WARNING ***\n         D     RE,F1               *** ODD REGISTER WARNING ***\n         AL    RE,F1\n         SL    RE,F1\n         TITLE 'FLOATING PT RX'\n*        *** ALL STMTS ON THIS PAGE MUST BE FLAGGED IF NO FLOATING PT.\n*        *** IF FLTING PT EXISTS, EACH ON PAGE HAS 1 ODD REG+1ALIGN WRN\n         STD   RE,D1\n         LD    RE,D1\n         CD    RE,D1\n         AD    RE,D1\n         SD    RE,D1\n         MD    RE,D1\n         DD    RE,D1\n         AW    RE,D1\n         SW    RE,D1\n         STE   RE,E1\n         LE    RE,E1\n         CE    RE,E1\n         AE    RE,E1\n         SE    RE,E1\n         ME    RE,E1\n         DE    RE,E1\n         AU    RE,E1\n         SU    RE,E1\n         TITLE 'RS AND SI FORMAT INSTRUCTIONS'\n         SSM   D1                  ***INVALID IF NO PRIVILEGED OPS\n         LPSW  D1                  ***INVALID IF NO PRIVILEGED OPS\n         DIAG  0,0                 **** INVALID IF NOT DEBUG\n         WRD   C1,1                ***INVALID IF NO PRIVILEGED OPS\n         RDD   C1,1                ***INVALID IF NO PRIVILEGED OPS\n         BXH   RE,RG,H1\n         BXLE  RE,RG,H1\n         SRL   RE,1\n         SLL   RE,2(2)\n         SRA   RE,64\n         SLA   RE,16\n         SRDL  RE,0(1)             *** ODD REG WARNING ****************\n         SLDL  RE,4(2)             *** ODD REG WARNING ****************\n         SRDA  RE,0(3)             *** ODD REG WARNING ****************\n         SLDA  RE,0(0)             *** ODD REG WARNING ***************\n         STM   RE,RG,F1\n         TM    C1,X'0'\n         MVI   C1,X'1'\n         TS    C1,X'1'\n         NI    C1,B'1'\n         CLI   C1,C'A'\n         OI    C1,C''''\n         XI    C1,C'&&'\n         LM    RE,RG,F1\n         SIO   D1                  *** INVALID IF NO PRIVILEGED OPS\n         TIO   D1                  *** INVALID IF NO PRIVILEGED OPS\n         HIO   D1                  *** INVALID IF NO PRIVILEGED OPS\n         TCH   D1                  *** INVALID IF NO PRIVILEGED OPS\n         XREPL C1,0                *** FLAGGED INVALID IF NO REPLACEMEN\\\n         TITLE 'SS INSTRUCTIONS'\n         MVN   C1,C2\n         MVC   C1,C2\n         MVZ   C1,C2\n         NC    C1,C2\n         CLC   C1,C2\n         OC    C1,C2\n         XC    C1,C2\n         TR    C1,C2\n         TRT   C1,C2\n         ED    C1,C2               *** INVALID IF NO DECIMAL FEATURE\n         EDMK  C1,C2               *** INVALID IF NO DECIMAL FEATURE\n         XREAD C1,L                *** FLAGGED IF NO X-MACROS\n         XPRNT C1,L                *** FLAGGED IF NO X-MACROS\n         XPNCH C1,L                *** FLAGGED IF NO X-MACROS\n         XDUMP C1,8                *** FLAGGED IF NO X-MACROS\n         XLIMD C1                  *** FLAGGED IF NO X-MACROS\n         XDUMP ,                   *** FLAGGED IF NO X-MACROS\n         MVO   C1,C2\n         PACK  C1,C2\n         UNPK  C1,C2\n         ZAP   P1,P2               *** INVALID IF NO DECIMAL FEATURE\n         CP    P1,P2               *** INVALID IF NO DECIMAL FEATURE\n         SP    P1,P2               *** INVALID IF NO DECIMAL FEATURE\n         MP    C1,C2               *** INVALID IF NO DECIMAL FEATURE\n         DP    C1,C2               *** INVALID IF NO DECIMAL FEATURE\n         SPACE 4\n         DS    0D,F\nD1       DS    F                   FULLWORD, BUT NO DOUBLEWORD\n         DS    0F,H\nE1       DS    H                   HALFWORD, BUT NO FULLWORD\n         DS    0F,H\nF1       DS    H                   HALFWORD, BUT NO FULLWORD\n         DS    0H,C\nH1       DS    C                   BYTE, BUT NOT HALFWORD\nC1       DS    C\nC2       DS    C\nP1       DS    P\nP2       DS    P\n         END\n$JOB   ASSIST  IBTEST\n         TITLE 'PASS 1 ASSEMBLER OPS TEST - (IB) '\n         START 100\n         DS    F\nIBTEST   CSECT\n         CCW   OP                  OK OPERAND-NOT IMPLEMENTED YET\nBAD      CCW\n         CNOP  0,8\n         CNOP  2,8\n         CNOP  4,8\n         CNOP  2,8\n         CNOP  6,8\n         CNOP  4,8\n         CNOP  2,4\n         CNOP  0,4\n         CNOP  0,4\nBAD1     CNOP\nBADL     CNOP  1,24\n         CNOP  2\n         CNOP  4,\n         CNOP  2,7\nCSECT1   CSECT\n         DS    F\n         CSECT                     BALNP\n         CSECT                     BLANK CSECT\n         DS    D\n         CSECT                     ILLEGAL RECODE OF CSECT\nCSECT1   CSECT                     ILLEGAL RECODE\n         DROP\nBAD3     DROP  10                  ILLEGAL LABEL\nBAD4     DROP\n         DROP  X\nDCA      DC    X'1',B'2',C'3'\n         DS    CL256,XL\n         DS    D,CL256\nDSA      DS    XL256,3D,4F,5C,10XL20\n         DS    CL200,BL20,\n         DC    X'1',X'2',\n         DC    C'1',C'2',C'3',C'4,\n         DC    C'1',C'2',C'3',C'4,\n         DC    C'1',C'2',C'3',C'4',C'5',C'6',C'7',C'8',C'9',C'A',C'B'\nBAD6     DS\n         DSECT                     MISSING LABEL ON DE\n         DSECT                     MISSING LABEL ON DSECT\nDUMMY    DSECT\n         DS    F\n         DC    C'A'\n         ENTRY BAD1,BAD2,DCA,DSA\n         ENTRY UNDEF,UNDEF2,BAD1\nILLEGAL  ENTRY BAD1\n         ENTRY\n         ORG   *+10\n         ORG   IBTEST              ILLEGAL\n         ORG   *-8\n         ORG\n         ORG   DUMMY\n         ORG   UNDEF\n         ORG   NOTYET\nNOTYET   DS    F\nILLNAME  ORG\n         PRINT OFF\n         PRINT ON\nPRINT    OFF,NOGEN,NODATA\n         PRINT ON,GEN,DATA\nNAME     PRINT OFF\n         PRINT\nNAME2    PRINT\n         PRINT ON\n         SPACE\nBAD      SPACE\n         SPACE 100\n         TITLE\nNAMER    TITLE\n\nLABELX\n         END   CSECT1\n$JOB   ASSIST  COCNTEST\n         TITLE 'CONSTANT RECOGNITION TEST (CO,CN)'\n*              THIS DECK TESTS SECTIONS CODTL1 AND CNDTL2 FOR         *\n*        BEING ABLE TO RECOGNIZE ALL LEGAL TYPES OF CONSTANTS, AND    *\n*        CALL THE APPROPRIATE PASS 1 AND 2 ROUTINES.                  *\nCSECT    START 0\nA        DC    A(1)\nB        DC    B'1'\nC        DC    C'1'\nD        DC    D'1'\nE        DC    E'1'\nF        DC    F'1'\nH        DC    H'1'\nP        DC    P'1'\nV        DC    V(CSECT)\nX        DC    X'1'\nZ        DC    Z'1'\n         END\n$JOB   ASSIST  EVTEST\n         TITLE 'EXPRESSION EVALUATOR TEST DECK #1 - (EV)'\nEVTEST1  CSECT\nEV1      BR    14                  JUST RETURN,NO EXECUTION\nABS      EQU   3                   ABSOLUTE TERM\nREL1     DS    D                   1ST RELOCATABLE TERM\nREL2     DS    D                   2ND RELOCATABLE TERM\n         ORG   *-2\n         ORG   *+5-*+5+*-*+*       ORG *+10\n         DC    CL(ABS+X'10')' '\n         USING EV1,15              NOTE USING\n         DC    A(REL1-2,REL1+8-REL2)        LEGAL\n         DC    A(REL2)\n         DC    A(REL2+4-REL1*ABS\n         DC    A\n         DC    A(REL2+ABS-REL1)\n         DC    A(0+1-2+3-4+5-\n         DC    A(0+1-2+3-4+5-6+7-8+9-10+11-12+13-14+15)        LEGAL\n         DC    A(0+1+2+3+4+5+6+7+8+9+10+11+12+13+14+15+16)  TOO MANY TM\n         LA    0,REL2-REL1         LEGAL\n         LA    0,(REL2-REL1)       LEGAL\n         LA    0,(REL2-REL1+4)(1)  LEGAL\n         DC    A((((((REL2-REL1)*8)/4)+3))) LEGAL\n         DC    A(REL2+8-REL1+ABS*3/4-5+6)   LEGAL\n         MVI   *+1,REL2-REL1+4*(REL2-REL1)  LEGAL\n         LA    0,REL2+4-REL1+REL2(1)        LEGAL\n         MVI   *+1,REL2            ILLEGAL,ABSOKUTE EXP REQUIRED\n         LA    0,ABS+ABS-4*ABS/2   LEGAL\n         LA    0,REL2+REL2         COMPLEX RELOCATABILITY\n         LA    0,REL1+REL2         COMPLEX RELOCATABILITY\n         DC    A(X'FFFFFF'+1)      EXPRESSION TOO LARGE\n         DC    A(3-4)              EXPRESSION TOO SMALL (NEGATIVE)\n         DC    A(1+%)              ILLEGAL CHARACTER\n         DC    A(TOOLONGSYM)       SYMBOL TOO LONG\n         DC    A(((((((((0)))))))) TOO MANY PAREN LEVELS\n         DC    A(1+,)              SYNTAX\n         DC    A(UNDEFSY)          UNDEFINED SYMBOL\n         END\n$JOB   ASSIST  ICTEST\n         TITLE 'TEST-PASS 2 MACHINE OPS(IC)-PART A-NORMAL OPERANDS'\nICTEST   CSECT\n         ENTRY ENTRY1\n         USING *,15\nRA       EQU   2\nRB       EQU   4\nL1       EQU   200\nL2       EQU   16\nABS1     EQU   8\n         LR\n         AR    0,1\n         AR    10,0\n         AR    12,12\n         AR    0,16                ILLEGAL - TOO BIG\n         AR    123,10                       ILLEGAL-TOO BIG\n         AR    1A                  ILLEGAL REGISTER/DELIMITE\n         MR    1,2                 WARNING - ODD REGISTER\n         AR    RA,RB\n         A     0,=F'1'\n*        *** NEXT 4 STMTS FLAGGED FOR ILLEGAL LITERAL USAGE.\n         CVD   0,=C'1'\n         STH   0,=F'1'\n         STC   0,=F'1'\n         STM   0,1,=F'1'\n         A     0,X'10'\n         A     0,B'1000'\n         A     0,C'0'\n         A     0,L'F1\n         A     0,X'10'+12\n         A     0,B'100'+8\n         A     0,C'0'+16\n         LA    0,*+10\n         A     0,F1\n         A     0,F1+4\n         A     0,F1-4\n         A     0,F1+4(RE)\n         A     0,F1+4(RA)\n         A     0,F1-4(2)\n         A     0,0(\n         A     0,4(8)\n         A     0,2000(RA)\n         A     0,ABS1\n         A     0,100\n         A     0,16(1)\n         A     0,16(,1)\n         A     0,16(1,2)\n         A     0,16(1,)\n         A     0,ABS1+4(1)\n         BNE   0(2)\n         LM    0,1,F1\n         LM    RE\n         LM    RA,RB,4(2)\n         STM   RA,RB,ABS1(RA)\n         SRDA  RA,1\n         SRDA  0,2(1)\n         SRDA  RA,ABS1\n         SRDA  RA,F1\n         MVI   C1,0\n         MVI   C1\n         MVI   C1,X'1'\n         MVI   C1,F1-30\n         LA    0,*-20\n         MVC   F1,F\n         MVC   F1,D1\n         MVC   F1(6)D1\n         MVC   F1(0),D1\n         MVC   2(3,4),2(5)\n         MVC   1(2),2(RA)\n         MVC   4(,6),C1\n         MVC   F1+4(5),F1+6(0)\n         UNPK  F1+4,C1+3\n         UNPK  F1-8(12),C1+6(0)\n         UNPK  F1(16),C1(16\n         UNPK  F1-4(16),C1(17)\n         SVC   L1\n         SVC   256\n         SVC   255\n         SPM   RA\n         SIO   D1+8\n         SIO   0(1)\n         XDECI 0,0(,1)\n         XDECO 0,4095(1,2)\n         XLIMD 0(1,2),20\n         XPRNT 0(1,2)\n         XPNCH F1(2)\n         XPRNT F1\n         XPRNT F1,(1)\n         XPRNT F1,120\n         CVB   0,C1(RA)            ICPEA\n         LA    0,126456789123\n         LA    0,C'1X'             ICSDTRM\n         LA    0,TOOLONGSYM        ICYSM\n         LA    0,123456789123456   ICDNUM\n         LA    0,UNDEFIN           ICSYM\n         LA    0,ENTRY1            ICSYM\n         MVC   C1(256),C2\n         MVC   C1(257),C2)\n         LTORG\nD1       DS    D\nF1       DS    F\nC1       DS    C\nC2       DS    C\n         END\n$JOB   ASSIST  BRTEST\n         TITLE 'BASE REGISTER/USING/DROP TEST PROGRAM #1'\nBASETEST CSECT\n         BALR  12,0\n         USING *,12\nA1       LA    11,BASETEST         ADDRESSIBILITY ERR\n         NOP   *-2\n         L     0,AA5\n         USING AA5,9\n         ST    1,AA5\n         USING AA5,10\n         AL    2,AA5\n         DROP  10\n         SL    3,AA5\n         USING DSECT,7\n         STH   4,DS1\n         LH    5,DS2\n         CVB   6,DS8\n         USING DSECT,10\n         CVD   7,DS8\n         USING DSECT2,10\n         M     8,DS4\n         D     8,DSEC2A\n         DROP  10\n         B     A1\n         IC    10,DSECT2A\n         LA    11,OUTRANGE\n         MH    15,*+6\n         DS    2000F\nOUTRANGE DS    C\nAA5      DS    F\nDSECT    DSECT\nDS1      DS    H\nDS2      DS    HL8\nDS4      DS    A\nDS8      DS    D\nDSECT2   DSECT\n         DS    CL80\nDSECT2A  DS    P\n         USING *,13,14,15\nBASET2   CSECT\n         LA    0,DSECT2A+5000\n         DROP  13,14,15\n         DROP  9,10,12\n         END\n$JOB   ASSIST  SDTEST\n         TITLE 'SELF-DEFINING TERM PROCESSORS TESTS - (SD)'\nSDTEST   START X'20000'\n*        TESTS FOR SBCDX ENTRY OF SDTERM                              *\nSDBCD    EQU   M'2'                UNRECOGNIZABLE\nSDBCD1   EQU   L'A\n*        TESTS FOR BINARY SELF-DEFINING TERMS                         *\nSDB1     EQU   B'1'\nSDBD7    EQU   B'0101010'\nSDB8     EQU   B'11111111'\nSDB16    EQU   B'0000111100001111'\nSDB24    EQU   B'111100001111000011110000'   LONGEST LEGAL STRING'\nSDB25    EQU   B'0000001111110000001111110'  TOO LARGE\nSDB0     EQU   B''                 NULL CONSTANT\nSDB      EQU   B'012               ILLEGAL CHARACTER\nSDBE2    EQU   B'000000001111111100000000    MISSING '\n*        TESTS FOR CHARACTER SELF-DEFINING TERM PROCESSOR             *\nSDC1     EQU   C'A'\nSDC1A    EQU   C'&&'\nSDC1B    EQU   C''''\nSDC2A    EQU   C'#@'\nSDC2     EQU   C''''''\nSDC2B    EQU   C'&&'''\nSDC3     EQU   C'012'\nSDC3A    EQU   C'''&&'''\nSDC4     EQU   C'ABCD'             TOO LARGE FOR SELF-DEFINING TERM\nSDCE1    EQU   C'ABC               MISSING DELIMIER\nSDCE2    EQU   C'&&&'              ODD # &'S - ILLEGAL\nSDCE3    EQU   C'''                ODD # OF '-S-MISSING '\nSDCE4    EQU   C'''''''''          ILLEGAL\nSDC0     EQU   C''                 NULL CONSTANT\n*        DECIMAL SELF-DEFINING TERM PROCESSOR TESTS                   *\n*        THERE APPEARS TO BE NO WAY TO GET A NULL DECIMAL SD TERM,    *\n*        SINCE SDDTRM IS NOT CALLED UNLESS 1ST CHAR IS DIGIT          *\nSDD1     EQU   1\nSDD2     EQU   16\nSDD3     EQU   256\nSDD4     EQU   4096\nSDD5     EQU   16384\nSDD6     EQU   131072\nSDD7     EQU   1048576\nSDD8     EQU   15728640\nSDD9     EQU   123456789\nSDD9A    EQU   999999999\nSDD10    EQU   1234567890          TOO BIG\n*        HEXADECIMAL SELF-DEFINING TERM PROCESSOR TESTS               *\nSDX1     EQU   X'1'\nSDX2     EQU   X'FF'\nSDX3     EQU   X'FAB'\nSDX4     EQU   X'4CDE'\nSDX5     EQU   X'12345'\nSDX5A    EQU   X'ABCDE'\nSDX5B    EQU   X'23456'\nSDX6     EQU   X'ABCDEF'\nSDX7     EQU   X'1234567'          TOO BIG\nSDX0     EQU   X''                 NULL CONSTANT\nSDXE1    EQU   X'02045             MISSING DELIMITER\n*              SEPARATE CHECK FOR CHECK ONLY PART-PASS 1              *\n*        LA    0,X'1'              LEGAL\n         LA    0,X'123             ILLEGAL\n         LA    0,X'1234567         TOOTLONG\n         END\n$JOB   ASSIST  ZTEST\n         TITLE 'GARBAGE TEST'\nTEST     START 16\nRHEX     EQU   8                   ACCUMULATOR FOR HEX NUMBERS          ASN20460\nCTAB2    DC    XL65'1'             TRANSLATE TABLE TO FIND BALNKS       ASN21360\n         ORG\n         ORG   *-20\n         DC    C'                                                 ',X'0#\n               000',C'                                             ',X'#\n               00'                 TEST FOR IN/OU\n         LTORG\nCHEAD1   DC    CL20'0  ** RESULTS',CL20' # OF CARDS',CL20' # OF DECIMAL#ASN21230\n               S',CL20' SUM OF DECIMALS',CL20' # OF HEXADECIMALS',CL30'#ASN21240\n                SUM OF HEXADECIMALS'                                    ASN21250\n         DC    C'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789ABCDEFGH#\n               #,$.@%*<#,$.@%*<#,$.@%*<#,$.@%*<#,$.@%*<#,$.@%*<#,$.@%*<#\n               +_)>:; ?\"=!(+_) >:; ?\"=!(+_) >:; ?\"=!('\nRXN      EQU   9                   COUNTER FOR NUMBER OF X #'S          ASN20470\n         PRINT ON\n         DSECT\nCPATTERN DC    X'402020202020202020212020'   EDIT PATTERN FOR OUTPUT    ASN21340\nRLINK    EQU   10                  INTRNAL LINKAGE REGISTER             ASN20480\nRCRD     EQU   5                   COUTNER FOR NUMBER OF CARDS          ASN20430\n         USING  *,10\nCARDIN   DS    CL80                AREA FOR INPUT OF CARD               ASN21300\nCHEAD0   DC    CL130'1      *** I/O CONVERSIONS - J.R.MASHEY'           ASN21210\nCWORK    DS    2D                  PRIMARY WORK AREA                    ASN21320\nRDN      EQU   7                   COUNTER FOR NUMBER OF DECIMALS       ASN20450\n         DC    C'\nCXTAB    DC    XL199'FAFBFCFDFEFF',41X'1',C'0123456789ABCDEF'           ASN21370\n         DC    C'&&''',X'A',F\n         CLI   1(RA),C''''         IS NEXT CHARACTER A '\n         BXH   RA,RD,CC1LOOPA      BUMP SCAN POINTER 1 AND BRANCH\n         CCW\n         CNOP  0,4\n         CNOP  2,8\n         CNOP  1,7\n         ENTRY X5\n         EXTRN X6\n         DC    X'\n         DC    X'01 '\n         DC    F'1,2,3,4,5'\nCPACK1   PACK  CWORK,0(0,R4)       FOR DECIMAL CONVERT,LENGTH SUPPLIED  ASN20740\n         CLI   CARDIN,C'$'         IS IT $ CARD                         ASN20590\n         CNOP  6,8\nCINIT1   LM    RCRD,RXN,=5F'0'     ZERO ALL COUNTER REGISTERS           ASN20540\n         BE    COUTPUT             YES-GO PRINT TOTALS                  ASN20600\nCHEXOUT  UNPK  CWORK(9),CWORK(5)     PERFORM OVERLAP UNPK               ASN21120\n         TR    CWORK,CXTAB         TRANSLATE FA TO A,FB TO B,ETC        ASN21130\n         XSAVE                                                          ASN20490\n         LA    RCRD,1(RCRD)        INCREMENT CARD COUNT                 ASN20610\n         LA    R3,CARDIN           STARTING ADDRESS FOR SCAN            ASN20620\n         SPACE 2                                                        ASN20630\n         L     10,=A(X)\n         ST    10,=A(X)\nRDEC     EQU   6                   ACCUMULATOR FOR DECIMAL SUM          ASN20440\n         IC    0,=C'1'\n         LH    2,=H'2'\n         DC    A(SYMBOL,1,2,3)\n         LTORG                                                          ASN21380\n         ALR   RDEC,R0             ADD TO ACCUMULATOR                   ASN20710\n         CSECT\n         DC    B'0101010101',B'01',B'1',B'01010101'\n         DROP  10\n         LA    3,=CL7'1'\n         LA    4,=CL8' '\nCONVIO   START X'22020'                                                 ASN20410\nCSCAN1   TRT   0(80,R3),CXTAB      SCAN FOR SOME NUMBER,IGNORE BLANKS   ASN20640\n         BZ    CARDGT              GO BACK AND GET NEXT CARD            ASN20650\n         PRINT NOGEN                                                    ASN20390\n         CLI   0(R1),C'X'          CHECK FOR X                          ASN20660\n         BE    CHEXIN              BRANCH TO CONVERT HEX CONSTANTS      ASN20670\nCDECIN   BAL   RLINK,CSCAN2        DO SECOND SCAN                       ASN20680\n         EX    R1,CPACK1           DO VARIABLE LENGTH PACK              ASN20690\n         CVB   R0,CWORK            PERFORM DEC-BIN CONVERSION           ASN20700\n         LA    RDN,1(RDN)          INCREMENT NUMBER OF DECIMALS         ASN20720\n         B     CSCAN1              GO BACK FOR NEXT VALUE               ASN20730\n         SPACE 2                                                        ASN20750\nCHEXIN   BAL   RLINK,CSCAN2        PERFORM SECOND SCAN                  ASN20760\n         EX    R1,CTRAN1           DO TRANSLATE                         ASN20770\n         EX    R1,CPACK2           PERFORM PACK,1 EXTRA BYTE            ASN20780\n         AL    RHEX,CWORK+4        ADD VALUE TO ACCUMULATOR             ASN20790\n         LA    RXN,1(RXN)          INCRMENT COUNTER                     ASN20800\n         B     CSCAN1              GO BACK FOR NEXT NUMBER              ASN20810\nCTRAN1   TR    0(0,R4),CXTAB       TRANSLATE FOR HEXIN,LENGTH SUPPLIED  ASN20820\nCPACK2   PACK  CWORK(9),1(0,R4)    FOR HEXIN CONVERSION,LENGTH SUPPLIED ASN20830\n         SPACE 2                                                        ASN20840\nCOUTPUT  CPRT  CHEAD1              PRINT HEADING                        ASN20850\n         CNVD  CLINE+20(12),RCRD   CONVERT NUMBER OF CARDS              ASN20860\n         CNVD  CLINE+40(12),RDN    CONVERT NUMBER OF DECIMALS           ASN20870\n         CNVD  CLINE+60(12),RDEC   GET DECIMAL SUM                      ASN20880\n         CNVX  CLINE+84(8),RXN     CONVERT NUMBER OF HEXES              ASN20890\n         CNVX  CLINE+104(8),RHEX   CONVERT HEX SUM                      ASN20900\n         CPRT  CLINE               PRINT ALL VALUES                     ASN20910\n         CPRT  =65CL2' *'          PUT IN LINE OF ASTERSIKS             ASN20920\n         CPRT  CBLANKS             PRINT BLANK LINE                     ASN20930\n         B     CINIT1              GO BACK AND RE INIT                  ASN20940\nCBLANKS  DC    CL130' '            FOR BLNK LINE                        ASN21310\n         SPACE 2                                                        ASN20950\nCALLDONE CALL  PTCLOSE             CLOSE PRINTER TO FLUSH BUFFER        ASN20960\n         XRETURN SA=*                                                   ASN20980\n         SPACE 2                                                        ASN20990\nCSCAN2   LR    R4,R1               SAVE POINTER                         ASN21000\n         TRT   0(80,R4),CTAB2      PERFORM TRANSLATE FOR BLANK          ASN21010\n         LR    R3,R1               SAVE POINTER TO BLANK                ASN21020\n         SR    R1,R4               FIND LENGTH OF FIELD                 ASN21030\n         BCTR  R1,0                DECREMENT LENGTH TO LENGTH-1         ASN21040\n         BR    RLINK               RETURN TO CALLER                     ASN21050\n         SPACE 2                                                        ASN21060\nCDECOUT  CVD   R0,CWORK2           PERFORM DECIMAL CONVERSION           ASN21070\n         MVC   CWORK(12),CPATTERN  MOVE EDITING PATTERN OVER            ASN21080\n         ED    CWORK(12),CWORK2+2  EDIT UP TO 11 DIGITS                 ASN21090\n         BR    RLINK               RETURN TO CALLER                     ASN21100\n         SPACE 2                                                        ASN21110\n         BR    RLINK               RETURN TO CALLER                     ASN21140\n         SPACE 2                                                        ASN21150\nCPRINT   CALL  PTPUT               CALL PRINTER ROUTINE                 ASN21160\n         BR    RLINK               RETURN TO CLLER                      ASN21170\n         SPACE 2                                                        ASN21180\nCLINE    DC    CL130' '                                                 ASN21270\n         DS    0D                  ALIGN FOR SPEED                      ASN21280\n         EQUREGS                                                        ASN20420\n         CALL PTOPEN               OPEN THE PRINTER                     ASN20500\n         CALL CROPEN               OPEN CARD READER                     ASN20510\n         CPRT  CHEAD0              PRINT HEADING                        ASN20520\n         SPACE 2                                                        ASN20530\n         EJECT                                                          ASN20400\n*              *** DATA AREAS AND TRANSLATE TABLES  ***               * ASN21190\n         DS    0D                  ALIGN FOR SPEED                      ASN21220\n         DS    0D                  ALIGN FOR SPEED                      ASN21260\nCARDGT   LA    R0,CARDIN           ADDRESS OF INPUTAREA                 ASN20550\n         CALL  CRGET               GET 1 CARD                           ASN20560\n         B     CALLDONE            BRANCH ON EOF                        ASN20570\n         CPRT  CARDIN-20           PRINT CARD                           ASN20580\nDUMMY    DSECT\n         DS    0D                  ALIGN FOR SPEED                      ASN21200\n         DEBUG 2,X'00'\n$JOB   ASSIST  EXTEST\n*        ========== TEST DECKS FOR INTERPRETER FEATURES ==========\n*        ========== TEST DECKS FOR INTERPRETER FEATURES ==========\n*        ========== TEST DECKS FOR INTERPRETER FEATURES ==========\n*        ========== TEST DECKS FOR INTERPRETER FEATURES ==========\n*        ========== TEST DECKS FOR INTERPRETER FEATURES ==========\n*        ========== TEST DECKS FOR INTERPRETER FEATURES ==========\n*        ========== TEST DECKS FOR INTERPRETER FEATURES ==========\n*        ========== TEST DECKS FOR INTERPRETER FEATURES ==========\n*        ========== TEST DECKS FOR INTERPRETER FEATURES ==========\n*        ========== TEST DECKS FOR INTERPRETER FEATURES ==========\n*        ========== TEST DECKS FOR INTERPRETER FEATURES ==========\n*        ========== TEST DECKS FOR INTERPRETER FEATURES ==========\n*        ========== TEST DECKS FOR INTERPRETER FEATURES ==========\n*        ========== TEST DECKS FOR INTERPRETER FEATURES ==========\n*        ========== TEST DECKS FOR INTERPRETER FEATURES ==========\n*        ========== TEST DECKS FOR INTERPRETER FEATURES ==========\n*        ========== TEST DECKS FOR INTERPRETER FEATURES ==========\n         TITLE 'X-MACRO TESTS - INTERPRETER'\nXMACTEST CSECT\n         USING *,15\n         SPACE 1\nXLOOP    XREAD CARD\n         BNZ   XDONE               QUIT IF NO MORE\n         XPRNT CARD,80             PRINT IT\n         XPNCH CARD                PUNCH IT\n         SPACE 1\n         LA    1,CARD              INIT SCAN PTR\nXDEC     XDECI 0,0(1)              SCAN NUMBER\n         BO    XLOOP               GO BACK IF BAD OR NO MORE\n         XDECO 0,AREA              CONVER T BACK\n         XPNCH AREA,12             PUNCH IT\n         B     XDEC                GO FOR NEXT NUMBER\nXDONE    XDUMP\n         XDUMP CARD,100\n         XLIMD XDONE\n         DC    H'0'                ABEND TO SEE XLIMD EFFECTS\nCARD     DC    CL80' ',C'$'        DELIMITER\nAREA     DS    CL12\n         END\n$ENTRY\n 1 2 3 4 5\n  -1 -2 -3\n$JOB   ASSIST  EXTEST\n         TITLE 'INTERPRETER TEST  1 - 0C1 - OPERATION'\nEXTEST1  CSECT\n         DC    H'0'                0C1 INTERRUPT\n         END\n$ENTRY\n$JOB   ASSIST  EXTEST\n         TITLE 'INTERPRETER TEST  2 - 0C2 - PRIVILEGED OPERATION'\n*        *** NOTE ONLY ASSEMBLES CORRECTLY IF PRIVILEGED OPS ALLOWED.\nEXTEST2  CSECT\n         TIO   0(1)                PRIVILEGED\n         END\n$ENTRY\n$JOB   ASSIST  EXTEST\n         TITLE 'INTERPRETER TEST 2A - 0C2 - PRIVILEGED OPER(SVC)'\n*        *** NOTE UNUSED SVC CODE CONSIDERED PRIVILEGED OPERATION.\nEXTEST2A CSECT\n         SVC   128                 SVC NOT IN CURRENT USE\n         END\n$ENTRY\n$JOB   ASSIST  EXTEST\n         TITLE 'INTERPRETER TEST 3 - 0C3 - EXECUTE'\nEXTEST3  CSECT\n         USING *,15                NOTE ENTRY USING\nEX2EX    EX    0,EX2EX             EXECUTE EXECUTE\n         END\n$ENTRY\n$JOB   ASSIST  EXTEST\n         TITLE 'INTERPRETER TEST 4 - 0C4 - PROTECTION'\nEXTEST4  CSECT\n         ST    0,4000(15)          STORE OUT OF RANGE\n         END\n$ENTRY\n$JOB   ASSIST  EXTEST,RELOC\n         TITLE 'INTERPRETER TEST 5 - 0C5 - ADDRESSING'\n*        *** NOTE THIS WILL GENERATE 0C4 IF RELOC OPTION NONEXISTNET,\n*        SINCE NORMALLY ALL ADDRESS-OUT-OF-RANGE CONDITIONS ARE\n*        TREATED AS 0C4'S RATHER THAN 0C5'S.\nEXTEST5  CSECT\n         USING *,15\n         L     1,=F'-1'            GET HUGE ADDRESS VALUE\n         IC    1,0(1)              SHOULD 0C5\n         BR    14                  -RETURN IF DOESNT WORK RIGHT\n         END\n$ENTRY\n$JOB   ASSIST  EXTEST\n         TITLE 'INTERPRETER TEST # 6 - 0C6 - ODD REG SPECIFICATION'\nEXTEST6  CSECT\n         MR    1,2                 ODD REG IN MR-DR - 0C6\n         END\n$ENTRY\n$JOB   ASSIST  EXTEST\n         TITLE 'INTERPRETER TEST 6A - 0C6 - ODD REG SPECIFICATION'\nEXTEST6A CSECT\n         SRDL  1,2                 ODD REG IN DOUBLE SHIFT 0C6\n         END\n$ENTRY         EXTEST\n$JOB   ASSIST  EXTEST\n         TITLE 'INTERPRETER TEST 6B - 0C6 - ODD REG SPEC(FLTING PT'\nEXTEST6B CSECT\n         AER   1,2                 ODD FLOATING PT REG - 0C6\n         END\n$ENTRY\n$JOB   ASSIST  EXTEST\n         TITLE 'INTERPRETER TEST 6C - 0C6 - MISSING HALFWORD ALIGN'\nEXTEST6C CSECT\n         USING *,15                NOTE ENTRY USING\n         STH   0,*+1               ODD BOUNDARY - 0C6\n         END\n$ENTRY\n$JOB   ASSIST  EXTEST\n         TITLE 'INTERPRETER TEST 6D - 0C6 - MISSING FULLWORD ALIGN'\nEXTEST6D CSECT\n         USING *,15                NOTE ENTRY USING\n         ST    0,*+2               MISSING F ALIGNMENT - 0C6\n         END\n$ENTRY\n$JOB   ASSIST  EXTEST\n         TITLE 'INTERPRETER TEST 6E - 0C6 - MISSING D ALIGNMENT'\nEXTEST6E CSECT\n         USING *,15                NOTE ENTRY USING\n         CVD   0,*+4               MISSING DOUBLEWORD ALIGN\n         END\n$ENTRY\n$JOB   ASSIST  EXTEST\n         TITLE 'INTERPRETER TEST # 7 - 0C7 -  INVALID CVB'\nEXTEST7  CSECT\n         USING *,15\n         CVB   0,EXT7D             CONVERT BASD VALUE - 0C7\nEXT7D    DS    0D\n         DC    2F'0'               INVALID VALUE FOR DECIMAL\n         END\n$ENTRY\n$JOB   ASSIST  EXTEST\n         TITLE 'INTERPRETER TEST 8 -  0C8 - FIXED PT OVERFLOW'\nEXTEST8  CSECT\n         USING *,15\n         LA    1,4000              S5T UP VALUE\n         SPM   1                   MASK OFF FOR NOW\n         SLA   1,31                SINCE MASKED, CAUSES NO INTERRUPT\n         LA    1,1                 GET SMALL VALUE\n         LCR   1,1                 GET NEG NUMBER TO SET SPM MASK\n         SPM   1                   SET TO ALLOW INTERRUPT\n         LA    1,4000              GET VALUE IN\n         AR    1,1                 DOUBLE\n         B     *-2                 LOOP UNTIL OVERFLOW\n         END\n$/             ASSIST INTERNAL DELIMITER CARD * * * * * * * * * * * * *\n         TITLE 'INTERPRETER TEST 9 - 0C9 - FIXED PT DIVIDE'\nEXTEST9  CSECT\n         LA    0,1                 SMALL NONZERO VALUE\n         SR    1,1                 CLEAR TO GET 0\n         DR    0,0                 DIVIDE 1 INTO 2-REG VALUE-OVERFLW\n         END\n$ENTRY\n$JOB   ASSIST  EXTEST\n         TITLE 'INTERPRETER TEST 10 - 0CA - DECIMAL OVERFLW'\nEXTEST10 CSECT\n         USING *,15\n         SR    0,0                 CLEAR FOR MASK\n         SPM   0                   MASK OFF INTERRUPT\n         AP    EXT10A1,EXT10B1     OVERFLOW IS MASKED OFF\n         L     0,EXT10M            GET MASK\n         SPM   0                   PERMIT INTTERRUOT\n         AP    EXT10A,EXT10B       CAUSE OVERFLOW\nEXT10A   DC    X'999999999F'\nEXT10A1  DC    X'999999999F'\nEXT10B   DC    X'9F'\nEXT10B1  DC    X'9F'\nEXT10M   DC    F'-1'               FOR USE AS SPM MASK\n         END\n$ENTRY\n$JOB   ASSIST  EXTEST\n         TITLE 'INTERPRETER TEST 11 - 0CB - DECIMAL DIVIDE'\nEXTEST11 CSECT\n         USING *,15\n         DP    EXT11A,EXT11B       CASUE 0CB\nEXT11A   DC    X'9999999F'\nEXT11B   DC    X'0F'\n         END\n$ENTRY\n$JOB   ASSIST  EXTEST\n         TITLE 'INTERPRETER TEST 16A - BRANCH OUT OF PROGRAM'\nEXTES16A CSECT\n         USING *,15\n         B     *+4000              BRANCH OUT OF RANGE\n         END\n$ENTRY\n$JOB   ASSIST  EXTEST\n         TITLE 'INTERPRETER TEST 16C - READ PAST END - OF - FILE'\nEXTES16C CSECT\n         USING *,15\nEXT16CA  XREAD EXT16CD             READ CARD IN\n         XPRNT EXT16CD-1           PRINT IT OUT\n         B     EXT16CA             LOOP,CAUSING END-OF-FILE\n         CNOP  6,8                 ALIGN TO PUT IN CARR CONT\n         DC    C' 0'\nEXT16CD  DS    10D                 SPACE FOR CARD\n         DC    CL60' '\n         END\n$ENTRY\n 1ST AND ONLY CARD FOR READ PAST EOF TEST\n$JOB   ASSIST  EXTEST,R=30\n         TITLE 'LOOP WHILE PRINTING-PRODUCE 222 COMPLETION CODE'\n         START\n         USING *,15\nLOOP     XPRNT =CL30' *** LOOPING DURING PRINTING ***',30\n         B     LOOP\n         END\n$ENTRY\n$JOB   ASSIST  EXTEST,I=100\n         TITLE 'INSTRUCTION COUNT LOOP - EXCEED - 221 COMPLETION'\n         START\n         BR    15                  TIGHT LOOP\n         END\n$ENTRY\n$JOB   ASSIST  EXTEST,R=40\n         TITLE 'STOP XDUMP DURING EXEC - RECORD LIMIT -222 COMPLETION'\n         START\n         USING *,15\nLOOP     XDUMP AREA,20\n         B     LOOP                LOOP FOREVER\nAREA     DC    5C'ABCD'\n         END\n$ENTRY\n$JOB   ASSIST  EXTEST,I=10000\n         TITLE 'EXECTUION TEST #0A - LOOP - COMPLETION 221'\n*        *** THIS PROGRAM USES TYPCIAL INSTRUCTION MIX  TO OBTAIN\n*        TIMING FOR PURE CPU PROGRAMS.\nEXTESTZ  CSECT\n         USING *,15\n         STM   14,12,12(13)\n         LR    12,13\n         LA    13,EXTZSAVE\n         ST    12,4(13)\n         ST    13,8(12)\n         BALR  12,0\n         USING *,12\n         LA    1,4000              SET UP FOR LOOP\n         SPACE 2\nEXTLOOP  L     0,EXTF1\n         A     0,EXTF2\n         ST    0,EXTF3\n         LA    0,2\n         SLL   3,1\n         AR    0,1\n         IC    0,EXTF1\n         MVC   EXTC1,EXTC2\n         CLC   EXTC1,EXTC3\n         BNE   *+4                 SUCCESSFUL BRANCH\n         LTR   0,0\n         SR    0,0\n         TM    EXTC4,X'FF'\n         BO    *+4                 SUCCESSFUL BRANCH\n         BZ    *+4                 UNSECCESSFUL BRANCH\n         BAL   14,*+4              SUCCESSFUL BAL\n         BCR   0,1\n         BCTR  0,0\n         BCT   1,EXTLOOP           CONTINUE LOOPING\n         SPACE 1\n         XPRNT EXTM1\n         XPRNT EXTM2\n         L     13,4(13)\n         LM    14,12,12(13)\n         BR    14\nEXTF1    DC    F'1'\nEXTF2    DC    F'2'\nEXTF3    DS    F\nEXTC1    DS    CL20\nEXTC2    DC    C'01234567890123456789'\nEXTC3    DC    C'0123456789ABCDEFGHIJ'\nEXTC4    DC    C'1'\nEXTM1    DC    CL132'0********** USER BEGINNING **********'\nEXTM2    DC    CL132'0********** USER ENDING    **********'\nEXTZSAVE DC    18F'1'              SAVE AREA\n         END\n$ENTRY\n$JOB   ASSIST  EXTEST,I=5000\n         TITLE 'EXECUTION TEST #0B - (EX)'\n*        *** USE TYPICAL INSTRUCTIONS TO OBTAIN CPU TIMING.\nEXTEST1  CSECT\n         USING *,15\n         STM   14,12,12(13)\n         LR    12,13               MOVE SA POINTER OVER\n         LA    13,EXSAVE1          @ OUR SAVE AREA\n         ST    12,EXSAVE1+4\n         ST    13,8(12)            BACK POINTER\n         BALR  12,0                NEW BASE\n         USING *,12                NOTE NEW BASE\n         DROP  15                  GET RID OF OLD ONE\n         LA    1,20                PUT IN LENGTH FOR XPRNT\n         XPRNT EXMESS,(1)          PRINT THIS MESSAGE\n         LA    4,4                 SET UP FOR INDEXING\n         LA    1,1500              FOR LOOP COUNT\n         SR    2,2                 CLEAR REG\n         BAL   3,*+8               BRANCH TO BCTR\n         L     0,EXAREA(4)         LOAD VALUE\n         ST    0,EXAREA(4)         STORE IT BACK\n         LA    2,1(2)              INCRMENT REG\n         LTR   0,2\n         BCTR  1,3                 LOOP THROUGH\n         ST    0,EXAREA            STORE REG\n         L     13,4(13)            PREV SAVE AREA\n         LM    14,12,12(13)        RESTORE REGS\n         BR    14                  RETURN\nEXAREA   DC    F'2'\nEXSAVE1  DC    18F'0'\nEXMESS   DC    C'0USER BEGINNING        '\n         END\n$ENTRY\n$JOB   ASSIST  EXTES,I=5000\n         TITLE 'INTERPRETER TEST #0C - TIMING TEST - (EX)'\n*        *** PROGRAM SHOULD COMPLETE 221.\nEXTESTZ  CSECT\n*        THIS PROGRAM USES TYPICAL INSTRUCTIONS TO OBTAIN TIMING.     *\n         USING *,15\n         STM   14,12,12(13)\n         LR    12,13\n         LA    13,EXTZSAVE\n         ST    12,4(13)\n         ST    13,8(12)\n         BALR  12,0\n         USING *,12\n         XLIMD EXTF1,200           LIMIT DUMP AREA\n         LA    1,4000              SET UP FOR LOOP\n         XPRNT EXTM1\n         SPACE 2\nEXTLOOP  L     0,EXTF1\n         A     0,EXTF2\n         ST    0,EXTF3\n         LA    0,2\n         SLL   3,1\n         AR    0,1\n         IC    0,EXTF1\n         MVC   EXTC1,EXTC2\n         CLC   EXTC1,EXTC3\n         BNE   *+4                 SUCCESSFUL BRANCH\n         LTR   0,0\n         SR    0,0\n         TM    EXTC4,X'FF'\n         BO    *+4                 SUCCESSFUL BRANCH\n         BZ    *+4                 UNSECCESSFUL BRANCH\n         BAL   14,*+4              SUCCESSFUL BAL\n         BCR   0,1\n         BCTR  0,0\n         BCT   1,EXTLOOP           CONTINUE LOOPING\n         XPRNT EXTM2\n         XDUMP EXTF1,300\n         XDUMP\n         DC    H'0'                TEMPORARY BOMB OUT***********\n         L     13,4(13)\n         LM    14,12,12(13)\n         BR    14\nEXTF1    DC    F'1'\nEXTF2    DC    F'2'\nEXTF3    DS    F\nEXTC1    DS    CL20\nEXTC2    DC    C'01234567890123456789'\nEXTC3    DC    C'0123456789ABCDEFGHIJ'\nEXTC4    DC    C'1'\nEXTM1    DC    CL132'0********** USER BEGINNING **********'\nEXTM2    DC    CL132'0********** USER ENDING    **********'\nEXTZSAVE DC    18F'1'              SAVE AREA\n         END\n$ENTRY\n$JOB   ASSIST  EXTEST\n         TITLE 'INTERPRETER TEST #0D - STANDARD INSTRUCTIONS - (EX)'\n*        *** SHOULD COMPLETE WITH 0C1.\nEXTEST2  CSECT\n         USING EXTEST2,15          NOTE INCOMING USING\n         STM   14,12,12(13)        SAVE REGS\n         LR    1,13                MOVE OVER\n         LA    13,EXSAVE2          @ SAVE AREA\n         ST    1,4(13)             LINK\n         ST    13,8(1)             LINK OTHER\n         BALR  12,0                SET UP NEW BASE\n         LA    2,16                PLACE VALUE\n         LA    3,7                 PLACE VALUE\n         SR    0,0                 CLEAR\n         SPM   0\n         LR    1,2\n         NR    1,0\n         CLR   1,2\n         OR    1,2\n         XR    1,2\n         CR    1,3\n         AR    1,3\n         SR    1,3\n         ALR   1,3\n         SLR   1,3\n         LPR   1,3\n         LNR   1,3\n         LTR   1,3\n         LCR   1,3\n         BALR  6,0\n         LA    7,*+10\n         BALR  5,7\n         NOPR  0\n         BCTR  3,0                 DECREMENT, NO BRANCH\n         LA    7,*+10              SET UP FOR BCTR\n         NOPR  0\n         SR    0,0\n         BNZ   *+8\n         NOPR  0\n         NOPR  0\n         LA    2,10\n         LA    1,5                 SET UP FOR MR\n         MR    0,2\n         LA    3,3\n         DR    0,3\n         IC    0,EXC10\n         CH    0,EXH5\n         AH    0,EXH5\n         SH    0,EXH5\n         MH    0,EXH5\n         N     0,EX7\n         CL    0,EX7\n         O     0,EX7\n         X     0,EX7\n         C     0,EX7\n         A     0,EX7\n         S     0,EX7\n         AL    0,EX7\n         SL    0,EX7\n         EX    0,*-4\n         LA    1,7\n         EX    1,EXLA\n         LH    0,EXH5\n         CVD   0,EXD\n         CVB   1,EXD\n         L     2,EXD\n         STH   2,EXH\n         STC   3,EXC\n         ST    4,EXF\n         LA    0,0(1,2)\nEXLA     LA    5,45\nEXH5     DC    H'5'\nEXC10    DC    C'1'\nEX7      DC    F'7'\nEXD      DS    D\nEXF      DS    F\nEXH      DC    H'35'\nEXC      DS    C\nEXSAVE2  DS    18F                 SAVE AREA\n         END\n$ENTRY\n$JOB   ASSIST  EXTEST\n         TITLE 'TESTPROG FOR FLOATING PT ERRORS'\n*        *** SHOULD 0C1 WITH CORRECT VALUES IN REGS.\nTESTD    CSECT\n         USING *,15\n         LD    0,ZERO\n         LE    2,ZERO\nZERO     DC    D'0'\n         END\n$ENTRY\n$JOB   ASSIST  EXTEST\n         TITLE 'CHECK FLOATING PT ASSEMBLY AND EXECUTION'\n*        *** ASSEMBLE PROPERLY, ABEND WITH RIGHT #'S IN REGS\nTESTCDE  CSECT\n         USING *,15\n         LD    0,CON10\n         AD    0,CONM9             GET FLOATING -1\n         LD    2,CON95\n         MD    2,CON2\n         LD    4,CON100A\n         DD    4,CON100MA          GET -1 FLOATING PT\n         LE    6,CONP1\n         AE    6,CONP1             GET FLOATING PT 2\n         AER   6,6                 GET FLOATING PT 4\n         DC    H'0'                DUMP\nCON10    DC    D'10.0'\nCONM9    DC    D'-9.E0'\nCON95    DC    D'.950'\nCON2     DC    D'+2.00000'\nCON100A  DC    D'1.01E+2'\nCON100MA DC    D'-1010E-1'         NEGAYIVE OF PRECEDING\nCONP1    DC    E'+1000E-3'         1\n         END\n$ENTRY\n$JOB   ASSIST  EXTEST\n         TITLE 'EXECUTION TEST - CHECK TRT BUG - SHOULD 0C1'\nTESTTRT  CSECT\n         USING *,15\n         TRT   A,B                 DO TEST,NOT FOUND\n         XDUMP\n         SR    1,1                 CLEAR FOR INSERTS\n         TRT   C,B                 TEST,FOUND,LAST BYTE\n         XDUMP\n         TRT   D,B                 TEST,FOUND IN MIDDLE\n         XDUMP\n         DC    H'0'                ABEND\nA        DC    X'0'                WILL NOT BE FOUND\nB        DC    X'0001'             TABLE\nC        DC    X'0001'             WILL BE FOUND, LAST BYTE\nD        DC    X'0100'             FOUND, NOT ON FIRST\n         END\n$ENTRY\n$JOB   ASSIST  EXTEST\n         TITLE 'EXECUTION TEST TO CHECK XDECI'\n*   THIS JOB ABENDED ASSIST 10/15/70 WITH SOC4 & 10/14/70 WITH SOC6\n*/AUTUMN70 JOB 'I9481,T=0005,R=0600,Z4868','STALTER IRA A JR   '        CS454.01\n**             THIS BUG CAUSED BY USER READING IN MULTIPUNCHED DATA\n*        AND SCANNING CHARACTERS OF VALUE > C'9'.\n*        0C7 INTERRUPT OCCURS IN XXXXDECI, 0C6 OR 0C4 IN XXXXSNAP.\n*        *** SHOULD EXECUTE 29 INSTRUCTIONS, THEN RETURN NOMRALLY.\n         CSECT\n         USING     *,15\n*  READ IN CHARACTER DATA\n         XREAD     CARD,8\n         XPRNT     CC,9\n         XDECI     3,CARD+4\n         XDECI     2,CARD\n         XDUMP\n*  REGISTER 4 IS SECTION NUMBER\n         LR        4,2\n         SRA       4,22\n*  REGISTER5 IS HOURS WORKED.\n         LR        5,2\n         SRA       5,15\n         XDUMP\n         N         5,X1\n         XDUMP\n*  REGISTER 7 IS SALARY TO DATE.\n         LR        6,2\n         LR        7,3\n         SRDA      6,25\n         N         7,X2\n         LR        6,3\n         SRA       6,13\n         N         6,X3\n*  REGISTER 8 IS BADGE NUMBERL\n         LR        8,3\n         N         8,X4\n         XDUMP\n         XDECO     4,CARD\n         XDECO     5,CARD+12\n         XDECO     7,CARD+24\n         XDECO     6,CARD+36\n         XDECO     8,CARD+48\n         XPRNT     CC,61\n         BR        14\n         DS        0F\nX1       DC        X'0000007F'\nX2       DC        X'003FFFFF'\nX3       DC        X'00000FFF'\nX4       DC        X'00001FFF'\n         DS        3C\nCC       DC        C'0'\nCARD     DS        60C\n         END\n$ENTRY\n\n$STOP          SAME AS END-OF-FILE\n**********     TEST RUN 0199 - APPEARS AFTER $STOP, SHOULD NOT BE READ AT ALL\n$JOB   ASSIST  TEST0199           ******ERROR IF THIS CARD APPEARS******\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ASTEST02": {"ttr": 18691, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x132?\\x01\\x132?\\x010\\x17\\xb4\\x17\\xb4\\x00\\x00\\xc1\\xe2\\xe2\\xc9\\xe2\\xe3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-11-19T00:00:00", "modifydate": "2013-11-19T01:30:00", "lines": 6068, "newlines": 6068, "modlines": 0, "user": "ASSIST"}, "text": "//ASTEST02 JOB (SYS),'ASSIST IVP TEST #2',CLASS=S,MSGCLASS=X\n//*\n//TESTPROG EXEC ASSIST\n//SYSIN DD *\n$JOB   ASSIST  PROGTEST,NOLOAD     COMMENTS\n*        ========== MEDIUM - LONG PROGRAM TESTS ==========\n*        ========== MEDIUM - LONG PROGRAM TESTS ==========\n*        ========== MEDIUM - LONG PROGRAM TESTS ==========\n*        ========== MEDIUM - LONG PROGRAM TESTS ==========\n*\n*        THESE PROGRAMS ARE STUDENT-WRITTEN PROJECTS FROM VARIOUS\n*        PROGRAMMING COURSES, ILLUSTRATING BOTH RUNNING PROGRAMS AND\n*        PROGRAMS WITH TYPICAL EXECUTION ERRORS.\n*        THEY ARE IN MORE-OR-LESS ASCENDING ORDER BY SIZE, RANGING\n*        FROM ABOUT 400 CARDS TO OVER 1000 CARDS.       A USEFUL PARM\n*        FIELD FOR THIS RUN MIGHT BE THE FOLLOWING:\n*        PARM='T=10,R=2000,RD=500,TD=1,TX=5,RX=2000'   (360/67)\n*        (BATCH MUST ALSO BE CODED OF COURSE)\n*        THE FOLLOWING OPTIONS MIGHT USEFULLY BE TRIED TO OBSERVE\n*        THEIR EFFECTS:    NOLIST   CMPRS    LARGE\n*        ========== MEDIUM - LONG PROGRAM TESTS ==========\n*        ========== MEDIUM - LONG PROGRAM TESTS ==========\n*        ========== MEDIUM - LONG PROGRAM TESTS ==========\n*        ========== MEDIUM - LONG PROGRAM TESTS ==========\n$JOB   ASSIST  PROGTEST,NERR=10\n*        *** SAMPLE PROGRAM FROM DATA STRUCTURES COURSE.  313 STMTS,\n*        WITH 8 ERRORS.\n*        CMPSC 404.1 - FALL 1970 - PSU - INSTRUCTOR - R.VARNEY.\n*        PROGRAM CAUSED ASSIST ABEND  10/29/70 - 0C2\n*  IN THIS CSECT THE FOLLOWING REGISTERS WERE USED AS FOLLOWS :\n*        REG 1   PASSES LOCATION OF LAVS TO MAIN CSECT\n*        REG 2   FIRST IT IS USED TO SET UP LINKS IN LAVS AND THEN IT IS THE\n*                   NUMBER OF ZIP CODES OFF EACH CARD\n*        REG 3   LOCATION OF ZIP CODES READ IN\n*        REG 4   USED TO SET THE LAST LINK IN ALIST TO ZERO\n*        REG 5    SAVES THE BASE REGISTER FROM MAIN CSECT\n*        REG 6    NUMBER OF ZIP CODES IN LIST\n*        REG 7 AND REG 8   USED TO PRINT LISTS\n*        REG 10   USED TO SET UP LINKS IN LAVS\n*        REG 11   LOCATION OF NEXT AVAILABLE SPACE\n*        REG 12   BASE REGISTER\n*        REG 13   LOCATION OF WHERE TO SAVE REGISTERS\n*        REG 14   LOCATION OF WHERE TO RETURN TO FROM MAIN CSECT\n*        REG 15   LOCATION OF WHERE TO BRANCH TO IN MAIN CSECT\n*\n*\n*\nINOUT    CSECT\n         BALR      12,0\n         USING     *,12\n         ST        14,SAV14\n* THE FOLLOWING CODE LINKS THE WORDS IN LAVS\n         LA        11,LAVS\n         L         2,=F'199'\nAPE      LR        10,11\n         A         11,=F'8'\n         STH       11,6(10)\n         S         2,=F'1'\n         BP        APE\n         STH       2,6(11)\n         A         11,=F'8'\n* STORES LOCATION OF NEXT AVAILABLE SPACE NOT IN LINKED LIST\n         ST     11,NLAVS\n         STH       2,LAVS+6\n         STH       2,LAVS+14\n*\n* READS IN ZIP CODES OF FIRST COMPANY, PRINTS THEM OUT AND STORES THEM IN\n*   LINKED LIST\n*\n         LA        11,LAVS+16\n         SR        4,4\n         SR        6,6\n         XPRNT     LL1,21\n         LA        10,LAVS\nREAD     XREAD     CARD,80\n         L         2,=F'16'\n         LA        3,CARD\nSTATE    CLC       0(5,3),BLANK\nCHANGE   BE        STOP\n         CH        11,=H'0'\n         BE        MORE\n         MVC       1(5,11),0(3)\n         XPRNT     0(11),6\n         A         6,=F'1'\n         STH       11,6(10)\n         MVC       LINK(2),6(11)\n         STH       4,6(11)\n         LR        10,11\n         LH        11,LINK\n         A         3,=F'5'\n         S         2,=F'1'\n         BZ        READ\n         B         STATE\n*\n* SENDS LIST TO MAIN CSECT TO BE SORTED IN ASCENDING ORDER\nSTOP     LA        10,LAVS+8\n         ST        6,LAVS\n         LA        1,LAVS\n         LA        13,SAVIO\n         L         15,=V(MAIN)\n         BALR      14,15\n*  MAIN CSECT RETURNS HERE AND PRINTS LIST IN ASCENDING ORDER WITHOUT\n*    ANY DUPLICATES\nUP       LA        7,LAVS\n         LH        8,6(7)\n         XPRNT     L1,55\nDOWN     XPRNT     0(8),6\n         LH        7,6(8)\n         LR        8,7\n         CH        7,=H'0'\n         BNE       DOWN\n*\n* READS IN SECOND LIST OF ZIP CO PRINTS THEM OUT AND PUTS THEM IN LINKED LIST\n         SR        6,6\n         XPRNT     LL2,21\nREAD1    XREAD     CARD,80\n         L         2,=F'16'\n         LA        3,CARD\nSTATE1   CLC       0(5,3),BLANK\n         BE        STOPS\n         CH        11,=H'0'\n         BE        MORE\n         MVC       1(5,11),0(3)\n         XPRNT     0(11),6\n         A         6,=F'1'\n         STH       11,6(10)\n         MVC       LINK(2),6(11)\n         STH       4,6(11)\n         LR        10,11\n         LH        11,LINK\n         A         3,=F'5'\n         S         2,=F'1'\n         BZ        READ1\n         B         STATE1\n*\n* SENDS LIST TO MAIN CSECT TO BE SORTED IN ASCENDING ORDER\nSTOPS    LA        1,LAVS+8\n         LA        13,SAVIO\n         L         15,=V(MAIN)\n         BALR      14,15\n*  MAIN CSECT RETURNS HERE AND PRINTS LIST IN ASCENDING ORDER WITHOUT\n* ANY DUPLICATES.\n         LA        7,LAVS+8\n         LH        8,6(7)\n         XPRNT     L2,55\nDOWN1    XPRNT     0(8),6\n         LH        7,6(8)\n         LR        8,7\n         CH        7,=H'0'\n         BNE       DOWN1\n*\n* SENDS TWO LISTS TO MAIN CSECT TO BE MERGED\nMEG      LA        1,LAVS\n         LA        13,SAVIO\n         L         15,=V(MERGE)\n         BALR      14,15\n*\n* RETURNS MERGED LIST AND PRINTS IT OUT\n         SR        7,7\n         LH        7,LAVS+6\n         XPRNT     LM,47\nAREA     XPRNT     0(7),6\n         LH        7,6(7)\n         CH        7,=H'0'\n         BNE       AREA\n* RETURNS LISTS TO AVAILABLE SPACE\nABCD     L         2,NLAVS\n         STH       2,6(7)\n         LA        3,LAVS\n         ST        3,NLAVS\nABC      L         14,SAV14\n         BR        14\nMORE     XPRNT     ERR,14\n         B         ABCD\nERR      DC          C' NO MORE SPACE'\nLL1   DC  C'1THE EASTERN COMPANY.'\nLL2   DC  C'1THE WESTERN COMPANY.'\nL1  DC  C'1THE FOLLOWING ZIP CODES ARE FROM THE EASTERN COMPANY: '\nL2  DC  C'1THE FOLLOWING ZIP CODES ARE FROM THE WESTERN COMPANY: '\nLM  DC  C'1THE FOLLOWING ZIP CODES ARE THE COMBINED LIST : '\n         LTORG\nCARD     DS        80C\nBLANK    DC        5C' '\nLINK     DS        H\nSAV14    DS        F\nSAVIO    DS        18F\nX        DS        F\nNLAVS    DS        F\nLAVS     DC        1600C' '\n*\n*\n*\n* THE FOLLOWING SECTION OF CODE USES THE REGISTERS AS FOLLOWS :\n*        REG  1    LOCATION OF LAVS\n*        REG  2    POINTER\n*        REG  3    NEXT LOCATION TO PUT IN ORDER\n*        REG   4   DUMMY\n*        REG  5    USED TO SAVE BASE REGISTER WHEN BRANCHING BACK\n*        REG  6    NUMBER OF ZIP CODES IN LIST\n*        REG 7 AND REG 8   DUMMY USED TO PUT LIST IN ORDER\n*        REG  9    DUMMY TO DECREASE LIST\n*        REG  10   LOCATION OF LAVS\n*\n*\nMAIN     CSECT\n         ENTRY     MERGE\n         STM       14,12,12(13)\n         BALR      12,0\n         USING     *,12\n         ST        13,SAVM\n* THE FOLLOWING SECTION OF CODE SORTS A LIST AND PUTS IT IN ASCENDING ORDER.\n         SR        4,4\n         SR        10,10\n         SR        2,2\n         SR        3,3\n         SR        7,7\n         SR        8,8\n         SR        9,9\n* IF ONLY ONE ZIP CODE IN LIST, YOU ARE FINISHED\n         C         6,=F'1'\n         BE        END\n*\n*\n* A LIST IS SET UP WITHIN THE LIST PASSED FROM INOUT CSECT.   THE FIRST\n* TWO NUMBERS IN THE ORGINAL LIST ARE PUT IN ASCENDING ORDER AND LINKED TOGETHER\n* AND ALSO LINKED TO THE HEADER CELL.   THE LAST ONE IS SET TO ZERO.\n* REGISTER 3 POINTS TO THE NEXT ZIP CODE IN THE ORGINAL LIST.   IT IS THEN\n* COMPARED TO EACH ZIP CODE IN THE NEW LIST AND IS PUT IN ITS PROPER PLACE\n* (ASCENDING ORDER) BY CHANGING THE LINKS.\n*\n*\n         LH        2,6(1)\n         LH        3,6(2)\n         LR        10,1\n         STH       4,6(2)\nON       CLC       1(5,2),1(3)\n         BH        KHANGE\n         CLC       1(5,2),1(3)\n         BE        EQUAL\n         CLC       6(2,2),=H'0'\n         BE        NEXT\n         LR        10,2\n         LH        2,6(10)\n         B         ON\n* END OF NEW LIST, SO ADD ZIP CODE AT END.\nNEXT     STH       3,6(2)\n         LH        7,6(3)\n         STH       4,6(3)\n         LR        3,7\n         B         MON\n* PUTS NUMBER IN LIST.\nKHANGE   LH        8,6(10)\n         STH       3,6(10)\n         LH        7,6(3)\n         STH       8,6(3)\n         LR        2,3\n         LR        3,7\n* IS IT THE END OF THE ORGINAL LIST?\nMON      CH        7,=H'0'\n         BE        END\n         CLC       1(5,2),1(3)\n         BNH       ON\n         LH        2,6(1)\n         LR        10,1\n         B         ON\n* ELEMINATES ANY DUPLICATES.\nEQUAL    LH        3,6(3)\n         L         9,0(1)\n         S         9,=F'1'\n         ST        9,0(1)\n         B         MON\n* RETURNS TO INOUT CSECT.\nEND      L         13,SAVM\n         ST        12,40(13)\n         LM        14,12,12(13)\n         BR        14\n*\n*\n* IN THE FOLLOWING SECTION THE REGISTERS ARE USED AS FOLLOWS:\n*        REG 2   LOCATION OF A ZIP CODE IN FIRST LIST\n*        REG 3   LOCATION OF A ZIP CODE IN SECOND LIST\n*        REG 4   LOCATION OF A ZIP CODE IN THE MERGED LIST.\n*        REG 11  NUMBER OF ZIP CODES IN MERGED LIST.\n*\n* THIS SECTION OF CODE MERGES THE TWO LISTS TOGETHER IN ASCENDING ORDER.\n* IT COMPARES THE FIRST ZIP CODE IN EACH LIST.   THE SMALLER IS LINKED TO\n* THE HEADER CELL.   IT THEN TAKES THE NEXT ZIP CODE IN THAT LIST AND COMPARES\n* IT TO THE OTHER'S FIRST ZIP CODE.   IT LINKS THE SMALLER ONE TO THE MERGED\n* LIST AND CONTINUES UNTIL ONE OF THE LISTS IS EXAUSTED.   THEN IT LINKS THE\n* ZIP CODE OF THE OTHER LIST TO THE MERGED LIST AND THEN YOU ARE FINISHED\n* SINCE THE REST OF THE OTHER LIST IS ALREADY LINKED TOGETHER IN ASCENDING ORDER\n*\n*\nMERGE    STM       14,12,12(13)\n         LR        12,5\n         ST        13,SAVM\n         SR        2,2\n         SR        3,3\n         SR        4,4\n         SR        11,11\n         L         11,0(1)\n         A         11,8(1)\n         ST        11,0(1)\n         LH        2,6(1)\n         LH        3,14(1)\n         LR        4,1\nGO       CLC       1(5,2),1(3)\n         BNL       LIST2\n         STH       2,6(4)\n         LR        4,2\n         CLC       6(2,4),=H'0'\n         BE        DONE1\n         LH        2,6(4)\n         B         GO\nLIST2    CLC       1(5,2),1(3)\n         BE        SAME\n         STH       3,6(4)\n         LR        4,3\n         CLC       6(2,4),=H'0'\n         BE        DONE2\n         LH        3,6(4)\n         B         GO\n* FIRST LIST RAN OUT\nDONE1    STH       3,6(4)\n         B         RETURN\n* SECOND LIST RAN OUT\nDONE2    STH       2,6(4)\n         B         RETURN\n* ELEMINATES ANY DUPLICATES\nSAME     L         11,0(1)\n         S         11,=F'1'\n         ST        11,0(1)\n         LH        2,6(2)\n         B         GO\n* RETURNS TO INOUT CSECT\nRETURN   L         13,SAVM\n         LM        14,12,12(13)\n         BR        14\nSAVM     DS        F\n         LTORG\n         END\n$ENTRY\n100221522261607070832370519112236071705519111068307520102110176041525216\n161421612717043179811790119112168231680116802606371795417815161423030208\n100362710219034454020215415230381010100120005253050702901601022101804306\n274011001002116941203183306830021731390230060019611850543215\n466246813154956731029863260637100178411463074441394901677027631245280179\n477216060144115631665030310005482263720363167441066252577002532025320148\n875441001863105940885240661607622029001791364915039472030309482047700160\n7522144501600625320460507\n$JOB   ASSIST  PROGTEST,\n         TITLE 'FINAL PROJECT - CMPSC 102 - WINTER 70 - MIKE HUNDLEY'\n*        *** THS PROGRAM SHOULD EXECUTE 3778 INSTRUCTIONS, PRINT ABOUT\n*        HALF A PAGE OF OUTPUT, THEN RETURN NORMALLY.\n*        *** IT IS A TYPICAL FINAL PROJECT FROM SEVERAL YEARS AGO.\n         PRINT NOGEN\nINPUT    CSECT\n         B     12(15)\n         DC    X'7'\n         DC    CL7'INPUT  '\n         BALR  12,0\n         USING *,12\n         ST    14,RETURN\n         LA    2,PROGRAM\n         XPRNT =CL40'1*** INPUT DATA CARDS ***',40\nREADIN   XREAD CARD\n         XPRNT CARD-4,84\n         MVC   0(80,2),CARD\n         CLC   10(3,2),=C'END'\n         BE    NOMORE\n         LA    2,80(2)\n         B     READIN\nNOMORE   LA    2,DATAAREA\nREADDATA XREAD BUFFER,4           READ DATA FOR PSEUDO PROGRAM\n         XPRNT BUFFER-1,5\n         MVC   0(4,2),BUFFER       MOVE DATUM TO DATAAREA\n         CLC   0(2,2),=C'**'\n         BE    ENTER\n         LA    2,4(2)\n         B     READDATA\nENTER    LA    1,PROGRAM\n         LA    0,DATAAREA\n         LA    13,SAVE\n         L     15,=V(PASS1)\n         BALR  14,15\n         LTR   0,0\n         BNM   DONE\n         XPRNT =CL40'3***OBJECT CODE***',40\nPRINT    MVC   BUFFER(4),0(1)     MOVE OBJECT CODE TO PRINT BUFFER\n         XPRNT BUFFER-4,8\n         LA    1,4(1)\n         CLC   0(4,1),=4C'*'\n         BNE   PRINT\nDONE     L     14,RETURN\n         BR    14\nRETURN   DS    F\nINPUTCC  DC    4C' '\nCARD     DS    20F\nSAVE     DS    18F\nOUTPUTCC DC    4C' '\nBUFFER   DS    F\nPROGRAM  DC    2000C' '\nDATAAREA DC    160C'0'\n         LTORG\nPASS1    CSECT\n         PRINT NOGEN\n         B     12(15)\n         DC    X'7'\n         DC    CL7'PASS1  '\n         STM   14,12,12(13)\n         BALR  12,0\n         USING *,12\nR10      EQU   10\n         ST    13,SAVE1+4\n         ST    1,PROGADD\n         SR    5,5\n         LR    7,1\n         LA    11,TABLE\n         LA    2,1\n         LA    R10,11\nNEXTCARD CLC   10(3,7),=C'END'\n         BE    LASTCARD\n         CLC   0(8,7),=8C' '\n         BE    NOLABEL\n         LA    3,7(7)\n         CLI   0(7),C'A'\n         BL    ERROR\n         CLI   0(7),C'Z'\n         BH    ERROR\n         SR    6,6\n         LA    4,1(7)\nBLANK    CLI   0(4),C' '\n         BE    FLAG\n         CLI   0(4),C'A'\n         BL    ERROR\n         CLI   0(4),C'9'\n         BH    ERROR\n         LTR   6,6\n         BNZ   ERROR\n         BXLE  4,2,BLANK\n         B     DOUBLEA\nFLAG     BCTR  6,0\n         BXLE  4,2,BLANK\nDOUBLEA  LA    9,TABLE\nCOMPARE  CLC   0(8,7),0(9)\n         BE    DUPLABEL\n         BXLE  9,R10,COMPARE\n         MVC   0(8,11),0(7)\nCVDEC    LA    14,PDECIMAL\n         CVD   5,PDECIMAL\n         UNPK  UNPACA(8),6(2,14)\n         OI    UNPACA+7,X'F0'\n         MVC   8(3,11),UNPACA+5\n         LA    11,11(11)\nERROR    NOP   NOLABEL\nDUPLABEL NOP   NOLABEL\nNOLABEL  CLC   10(2,7),=C'DS'\n         BE    CVBINARY\n         LA    5,4(5)\nDONEA    LA    7,80(7)\n         B     NEXTCARD\nCVBINARY MVC   PDECIMAL(8),13(7)\n         PACK  PDECIMAL(8),PDECIMAL\n         CVB   14,PDECIMAL\n         SLL   14,2\n         AR    5,14\n         B     DONEA\nLASTCARD MVC   0(8,11),=8C'*'\n         LA    1,=A(TABLE,PROGADD)\n         LA    13,SAVE1\n         L     15,=V(PASS2)\n         BALR  14,15\n         L     13,SAVE1+4\n         LM    2,12,28(13)\n         L     14,12(13)\n         BR    14\nPROGADD  DS    F\nPDECIMAL DS    D\nUNPACA   DS    D\nSAVE1    DS    18F\nTABLE    DC    2000C' '\n         LTORG\nPASS2    CSECT\n         PRINT NOGEN\n         B     12(15)\n         DC    X'7'\n         DC    CL7'PASS2  '\n         STM   14,12,12(13)\n         BALR  12,0\n         USING *,12\n         ST    13,SAVE2+4\n         ST    0,DATAADD\n         L     9,0(1)             LOAD ADDRESS OF TABLE\n         L     7,4(1)             LOAD ADDRESS OF PSEUDO PROGRAM\n         L     7,0(7)\n         S     7,=F'80'\n         LA    5,OBJECT-4\n         SR    0,0\nNEWLOOP  LA    5,4(5)\nNEWCARD  LA    7,80(7)\n         CLC   10(3,7),=C'END'\n         BE    ENDOFOPS\n         CLC   10(6,7),=C'BRANCH'\n         BE    BRANCH2\n         CLC   20(1,7),=C','\n         BE    BRANCH2\n         CLC   10(2,7),=C'DC'\n         BE    DC2\n         CLC   10(2,7),=C'DS'\n         BE    DS2\n         CLC   10(4,7),=C'HALT'\n         BE    HALTA\n         LA    2,OPSCONTS\n         LA    15,9\nSCANOPS  CLC   0(5,2),10(7)\n         BE    INSERTOP\n         LA    2,6(2)\n         BCT   15,SCANOPS\n         MVI   0(5),C'?'\n         BCTR  0,0\n         B     SCANLABS\nDS2      MVC   DOUBLE2(8),13(7)\n         PACK  DOUBLE2(8),DOUBLE2\n         CVB   14,DOUBLE2\n         SLL   14,2\n         AR    5,14\n         B     NEWCARD\nDC2      MVC   0(4,5),19(7)\n         B     NEWLOOP\nHALTA    MVI   0(5),C'H'\n         B     NEWLOOP\nBRANCH2  LA    10,3\n         LA    11,ZHL\nCHECK    CLC   0(1,11),19(7)\n         BE    INSERT\n         LA    11,1(11)\n         BCT   10,CHECK\n         LA    11,1(11)\n         BCTR  0,0\nINSERT   MVC   0(1,5),3(11)\nSHIFTLAB MVC   19(8,7),21(7)\n         B     SCANLABS\nINSERTOP MVC   0(1,5),5(2)\nSCANLABS LR    3,9\nCHECK2   CLC   0(8,3),19(7)\n         BE    CODE\n         LA    3,11(3)\n         CLC   0(8,3),=8C'*'\n         BNE   CHECK2\n         MVC   1(3,5),QUESTION\n         B     NEWLOOP\nCODE     MVC   1(3,5),8(3)\n         B     NEWLOOP\nENDOFOPS MVC   0(4,5),=4C'*'\n         LA    1,OBJECT\n         LTR   0,0\n         BNM   EXECUTE\n         B     RETURNA\nEXECUTE  L     15,=V(INTERP)\n         L     0,DATAADD\n         LA    13,SAVE2\n         BALR  14,15\nRETURNA  L     13,SAVE2+4\n         LM    2,12,28(13)\n         L     14,12(13)\n         BR    14\nDATAADD  DS    F\nSAVE2    DS    18F\nOPSCONTS DC    C'RD   R'\n         DC    C'ADD  A'\n         DC    C'SUB  S'\n         DC    C'LOAD L'\n         DC    C'STORET'\n         DC    C'WRT  W'\n         DC    C'MULT M'\n         DC    C'DIV  D'\n         DC    C'GOTO G'\nZHL      DC    C'ZHL'\nERROROP  DC    C'#+-?'\nQUESTION DC    C'???'\n         DS    0F\nOBJECT   DC    400C'0'\nDOUBLE2  DS    D\n         LTORG\nINTERP   CSECT\n         PRINT NOGEN\n         B     12(15)\n         DC    X'7'\n         DC    CL7'INTERP '\n         STM   14,12,12(13)\n         BALR  12,0\n         USING *,12\n         ST    13,SAVE3+4\n         LR    13,0\n         LR    10,1\nACC      EQU   3\n         S     10,=F'4'\nTOP      LA    10,4(10)\nTOP2     L     9,0(10)\n         SLDL  8,8\n         STC   8,OPCODE\n         ST    9,OPERAND\n         PACK  DOUBLE(8),OPERAND(3)\n         CVB   7,DOUBLE\n*********XSNAP LABEL='AFTER CVB         ',STORAGE=(OP,SAVE3)\n         L     5,=F'13'\n         LA    4,OPTAB\nUP       CLC   0(1,4),OPCODE\n         BE    DOWN\n         LA    4,1(4)\n         BCT   5,UP\n         XPRNT =CL40'0** INVALID OP CODE **',40\n         B     STOP\nDOWN     S     4,=A(OPTAB)\n         SLA   4,2\n         A     4,=A(CODEADD)\n         L     4,0(4)\n         BR    4\nCVTBIN   AR    7,1\n         CLI   0(7),C'-'\n         BE    MINUSNUM\n         PACK  DOUBLE(8),0(4,7)\n         CVB   6,DOUBLE\n*********XSNAP LABEL='AFTER CVTBIN'\n         BR    14\nMINUSNUM PACK  DOUBLE(8),1(3,7)\n         CVB   15,DOUBLE\n         LCR   6,15\n         BR    14\nSTORE    AR    7,1\n         CVD   ACC,DOUBLE\n         UNPK  UNPACK(8),DOUBLE+6(2)\n         OI    UNPACK+7,X'F0'\n         LTR   ACC,ACC\n         BNL   POSITIVE\n         MVI   UNPACK+4,C'-'\nPOSITIVE MVC   0(4,7),UNPACK+4\n*********XSNAP LABEL='AFTER STORE',STORAGE=(*0(1),*160(1))\n         B     TOP\nREAD     AR    7,1\n         MVC   0(4,7),0(13)\n         CLC   0(2,13),=C'**'\n         BE    NODATA\n         LA    13,4(13)\n         B     TOP\nNODATA   XPRNT =CL50'0** ATTEMPT TO READ BEYOND END OF FILE **',50\n         B     STOP\nGOTO     LA    10,0(7,1)\n         B     TOP2\nLOAD     BAL   14,CVTBIN\n         LR    ACC,6\n         B     TOP\nDIV      BAL   14,CVTBIN\n         LR    2,ACC\n         SRA   2,31\n         DR    2,6\n         B     TOP\nADD      BAL   14,CVTBIN\n         AR    ACC,6\n         B     TOP\nSUB      BAL   14,CVTBIN\n         SR    ACC,6\n         B     TOP\nZERO     LTR   ACC,ACC\n         BNE   TOP\n         LA    10,0(7,1)\n         B     TOP2\nHIGH     LTR   ACC,ACC\n         BNH   TOP\n         LA    10,0(7,1)\n         B     TOP2\nLOW      LTR   ACC,ACC\n         BNL   TOP\n         LA    10,0(7,1)\n         B     TOP2\nMULT     BAL   14,CVTBIN\n         MR    2,6\n         B     TOP\nWRITE    AR    7,1\n         CLI   0(7),C'-'\n         BE    NEGATIVE\n         MVC   PLUS+2(4),0(7)\n         XPRNT PLUS,6\n         B     TOP\nNEGATIVE MVC   MINUS+1(4),0(7)\n         XPRNT MINUS,5\n         B     TOP\nHALT     XPRNT =CL40'0**** EXECUTION COMPLETED ****',40\nSTOP     L     13,SAVE3+4\n         LM    2,12,28(13)\n         L     14,12(13)\n         BR    14\nPLUS     DC    C'0+0000'\nMINUS    DC    5C'0'\nOPTAB    DC    C'ASLTRWMD#+-GH'\nOP       DS    F\nOPCODE   DS    C\nOPERAND  DS    F\nDOUBLE   DS    D\nUNPACK   DS    D\nSAVE3    DS    18F\nCODEADD  DC    A(ADD,SUB,LOAD,STORE,READ,WRITE,MULT,DIV,ZERO,HIGH,LOW)\n         DC    A(GOTO,HALT)\n         LTORG\n         END\n$ENTRY\n          RD       HERE\nTHERE     LOAD     CNT\n          SUB      ONE\n          STORE    CNT\n          BRANCH   Z,DONE\n          RD       HERE1\n          LOAD     HERE\n          SUB      HERE1\n          BRANCH   L,SWITCH\n          GOTO     THERE\nSWITCH    LOAD     HERE1\n          STORE    HERE\n          GOTO     THERE\nDONE      WRT      HERE\n          HALT\nHERE      DS        1\nHERE1     DS        1\nCNT       DC          5\nONE       DC          1\n          END\n5249\n6521\n1234\n5340\n6845\n**\n$JOB   ASSIST  PROGTEST\n*        *** FIRST OF SERIES OF THREE RELATED PROGRAMS.\n*        PSU CMPSC 102 - SUMMER 1970 - FINAL PROJECT\n*        *** USER PROGRAM PRINTS TWO PAGES OF OUTPIT, EXECUTES\n*        19508 INSTRUCTIONS, THEN ABENDS WITH 0C4 ERROR AND DUMPS.\n*        *** EXAMPLE OF FINAL PROJECT WITH AN EXECUTION - TIME ERROR\nMAIN     CSECT\n         ENTRY     STORE\n         ENTRY     COUNTER\n         BALR      12,0\n         USING     *,12\n         ST        14,SAV14\n         SR        4,4            POINTER IN ARRAY OF INPUT\n         SR        5,5            COUNTER OF NUMBER OF CARDS READ.\n         XPRNT     CONT,56        PRINTS LABEL FOR INPUT\nTOP      XREAD     ARRAY,80       READS ALL OF INPUT CARDS\n         CLC       ARRAY(2),=C'##'     LOOKS FOR FLAG CARD\n         BE        BRPASS1\n         XPRNT     CC,81          ECHO CHECKS ALL OF THE INPUT CARDS\n         LA        3,STORE(4)     LOADS THE ADDRESS OF THE ARRAY\n*                                      CONTAINING THE FIRST 40 COLUMNS\n*                                      OF EACH INPUT CARD.\n         MVC       0(40,3),ARRAY  PUTS FIRST 40 COLUMNS INTO THE ARRAY\n         A         4,=F'40'       INCREASES POINTER IN THE ARRAY\n         A         5,=F'1'        INCREASES THE CARD COUNTER\n         B         TOP            RETURNS TO READ THE NEXT CARD\n*                                 COMES HERE IF FLAG CARD IS READ\nBRPASS1  ST        5,COUNTER      STORES THE CARD COUNTER\n         L         15,=V(PASS1A)  LOADS ADDRESS OF CSECT BEIBG CALLED\n         LA        13,SAVMAIN     LOADS REGISTER STORAGE LOCATION\n         BALR      14,15          BRANCHES TO CSECT PASS1A\n         L         14,SAV14\n         B         14\nSAV14    DS        F\nCONT     DC        C'1THIS IS THE PROGRAM READ INTO THE PASS1, PASS2'\n         DC        C'COMPILER'\nCC       DC        C' '\nARRAY    DS        80C\nCOUNTER  DS        F\nSAVMAIN  DS        18F\n         LTORG\nSTORE    DS        1000F\n         PRINT OFF\nPASS1A   CSECT\n         ENTRY     LEGAL\n         ENTRY     LOCTN\n         STM       14,12,12(13)\n         BALR      12,0\n         USING     *,12\n         ST        13,SAVPAS1A+4\n         L         2,=V(STORE)    LOADS ADDRESS OF STORAGE INTO\n         L         3,=V(STORE)    REGISTERS 2 AND 3\n         SR        4,4            FLAG REGISTER FOR ERRORS.\n         SR        7,7            POINTER IN LABEL TABLE.\n         SR        9,9            POINTER  IN LOCATION COUNTER TABLE.\n         SR        10,10          LOCATION COUNTER REGISTER\nTOP1A    CLC       0(1,2),=C' '   CHECKS FOR A LABEL.\n         BE        NOLABEL\n         SR        6,6\n         CLC       0(1,2),=C'A'   CHECKS FOR LEGALITY OF LABEL\n         BL        ILLEGAL        IF CONDITIONS ARE NOT MET, BRANCH TO\n         CLC       0(1,2),=C'Z'        PRINT ERROR STATEMENT\n         BH        ILLEGAL\n         CLC       1(1,2),=C'1'\n         BL        ILLEGAL\n         CLC       2(2,2),=C': '\n         BNE       ILLEGAL\n*                                 GET HERE IF LEGAL LABEL CONDITIONS A\n*                                      RE MET.\n         LA        8,LEGAL(7)     LOADS ADDRESS OF NEXT ENTRY POINT FO\n*                                      R A LEGAL LABEL.\nUP1A     LA        5,LEGAL(6)     LOADS ADDRESS OF LABEL TO BE COMPARE\n         CLC       0(2,2),0(5)    COMPARES INPUT LABEL TO LABEL TABLE\n         BE        DUPLAB         IF EQUAL, BRANCHES TO PRINT ERROR.\n         A         6,=F'2'        INCREASES POINTER TO NEXT LABEL.\n         CR        7,6            CHECKS FOR END OF LABEL TABLE.\n         BH        UP1A\n         MVC       0(2,8),0(2)    PUTS INPUT LABEL INTO TABLE.\n         SR        6,6\nREG6     C         6,=F'0'        CHECKS FLAG REGISTER\n         BE        RG6            BRANCHES IF EQUAL\n         LR        8,10           SAVE LOCATION COUNTER\n         CVD       10,AN          CHANGES LOC. CTR. TP DECIMAL\n         UNPK      ANY(8),AN+4(4) UNPACKS LOC. CTR.\n         L         10,ANY+4       PUTS LOC. CTR. IN REG. 10\n         A         10,=F'48'      CHANGES SIGN FROM A C TO A F\n         L         11,PTR         LOADS PTR. OF LOCATION TABLE\n*                                      CORRESPONDING TO THE INPUT\n         ST        10,LTN(11)     PUTS BASE 10 LOOKING LOC. CTR. IN TB\n         A         11,=F'4'       INCREASES PTR. IN TABLE\n         ST        11,PTR         SAVES POINTER\n         LR        10,8           RESTORES LOCATION COUNTER\n*                                 THIS SECTION CHECKS FLAG REGISTER\n*                                      AND RETURNS TO PROPER POINT.\n         C         6,=F'1'\n         BE        LL\n         C         6,=F'2'\n         BE        LL1\n         C         6,=F'3'\n         BE        LL2\n         C         6,=F'4'\n         BE         LL3\n         B         LL4\n*                  THIS PART INSERTS LOCATION COUNTER INTO TABLE\n*                                 CORRESPONDING TO LABEL INSERTED.\nRG6      LR        11,10\n         LR        8,10           SAVES LOCATION COUNTER\n         SR        10,10          CLEARS REG. SO THAT IT WILL CONTAIN\n*                                      REMAINDER AFTER DIVISION\n         D         10,=F'10'      DIVIDES LOC. CTR. BY 10\n         ST        10,LC1         SAVES THE REMAINDER\n         SR        10,10          CLEARS REG. 10 FOR NEXT REMAINDER\n         D         10,=F'10'      DIVIDES LOC. CTR. BY 10 AGAIN\n         ST        10,LC2         SAVES THE REMAINDER\n         SLL       11,8           MULTIPLIES VALUE IN 11 BY 256\n         ST        11,LC3         STORES RESULT IN LC3\n         L         11,LC2         PUTS SECOND REMAINDER IN REG. 11\n         SLL       11,4           MULTIPLIES IT BY 16\n         L         10,LC1         PUTS FIRST REMAINDER IN REG. 10\n         AR        10,11          ADDS PARTS OF NEW LOC.CTR.\n         A         10,LC3         ADDS REST OF NEW LOC. CTR.\nNO       ST        10,LOCTN(9)\n         LR        10,8           RESTORES LOC. CTR.\n         LA        7,2(7)         INCREASES LABEL TABLE POINTER.\n         LA        9,4(9)         INCREASES LOCATION COUNTR TABLE PTR.\n         LA        2,4(2)          INCREASE INPUT POINTER.\n*        COMES HERE IF THERE IS NO LABEL AND LOOKS FOR THE OPCODE.\nNOLABEL  CLC       0(1,2),=C' '   CHECKS FOR OPCODE\n         BNE       LOOK           BRANCHES WHEN FINDS OPCODE\n         LA        2,1(2)              INCREASES INPUT POINTER\n         B         NOLABEL        RETURNS AND CHECKS FOR OPCODE\n*                  COMES HERE IF OPCODE IS FOUND.\nLOOK     CLC       0(1,2),MCODE   CHECKS FOR A BRANCH STATEMENT\n         BNE       LOOK1          IF NOT BRANCHES AND CHECKS FOR YIELD\n         LA        6,1            SETS UP A FLAG REGISTER\n         B         REG6           BRANCHES TO CHANGE LOC. CTR.\nLL       A         10,=F'6'       ADDS 6 TO LOC. CTR. FOR BRANCH\n         B         CLEANUP        BRANCHES TO PREPARE FOR NEW INPUT\nLOOK1    CLC       0(1,2),MCODE+1 CHECKS FOR A YIELD STATEMENT\n         BNE       LOOK2          IF NOT, BRANCHES AND CHECKS FOR DC.\n         LA        6,2            SETS UP A FLAG REGISTER\n         B         REG6           BRANCHES TO CHANGE LOC. CTR.\nLL1      A         10,=F'2'       ADDS 2 TO LOC. CTR. FOR YIELD\n         B         CLEANUP        BRANCHES TO PREPARE FOR NEW INPUT\nLOOK2    CLC       0(2,2),MCODE+6 CHECKS FOR DC STATEMENT\n         BNE       LOOK3          IF NOT, BRANCHES AND LOOKS FOR DS\n         LA        2,2(2)         IF SO, INCREASES INPUT PTR. PAST OPC\nOUT1A    CLC       0(1,2),=C' '   CHECKS FOR OPERAND\n         BNE       OUT            BRANCHES WHEN FINDS OPEFAND\n         LA        2,1(2)         IF NOT, INCREASE INPUT PTR.\n         B         OUT1A          RETURNS AND CHECKS FOR OPERAND\n*                                 GETS HERE WHEN FINDS OPERAND\nOUT      CLC       0(1,2),=C'C'    LOOKS FOR A \"C\"\n         BNE       FULLWORD       IF NOT, ASSUMES A \"F\"\n         LA        2,2(2)         INCREASES INPUT POINTER PAST QUOTE\n         SR        5,5            SETS UP COUNTER OF NO. OF CHARACTERS\nOUTADD   CLC       0(1,2),=X'7D'  SEARCHES FOR SECOND QUOTE.\n         BE        ADD            IF FOUND, ADDS NUMBER TO LOC. CTR.\n         A         5,=F'1'        ADDS 1 TO CHARACTER COUNTER\n         LA        2,1(2)         INCREASES INPUT POINTER.\n         B         OUTADD         RETURNS AND LOOKS FOR QUOTE.\nADD      LA        6,3            SETS UP A FLAG REGISTER\n         B         REG6           BRANCHES TO CHANGE LOC. CTR.\nLL2      AR        10,5           ADDS VALUE CALCULATED IN REG 5 TO\n*                                      LOCATION COUNTER\n         B         CLEANUP         BRANCHES TO PREPARE FOR NEW INPUT.\nFULLWORD LR        11,10          SAVES LOCATION COUNTER.\n*                                 THIS PART IS FOR A DC FULLWORD.\nFULWD1A  SRL       10,2           CHECKS LOC. CTR. FOR FULLWORD\n         SLL       10,2           BOUNDARY\n         CR        11,10\n         BE        FULL1A         IF ON A FULLWORD, ADDS TO LOC. CTR.\n         A         10,=F'4'       PUTS LOC. CTR. ON A FULLWORD BNDARY.\nFULL1A   LA        6,4\n         B         REG6\nLL3      A         10,=F'4'       ADDS 4 TO LOC. CTR. FOR FULLWORD\n*                                      INSTRUCTION OR CONSTANT\n         B         CLEANUP        BRANCHES TO PREPARE FOR NEW INPUT\nLOOK3    CLC       0(2,2),MCODE+8 CHECKS FOR DS STATEMENT\n         BNE       LOOK4          IF NOT, CHECKS FOR END STATEMENT\n         LA        2,2(2)         IF SO, INCREASE INPUT PTR. PAST OPCO\nCHECK1A  CLC       0(1,2),=C' '   CHECKS FOR OPERAND\n         BNE       CHECK          BRANCHES WHEN FINDS OPERAND\n         LA        2,1(2)         IF NOT, INCREASES INPUT PTR.\n         B         CHECK1A        RETURNS TO CHECK FOR OPERAND\n*                                 GETS HERE WHEN FINDS OPERAND.\nCHECK    CLC       0(1,2),=C'C'   CHECKS FOR A \"C\"\n         BNE       MOVE            IF NOT, BRANCHES TO CHECK FOR A \"F\"\n         LA        6,5            SETS UP A FLAG REGISTER\n         B         REG6           BRANCHES TO CHANGE LOC. CTR.\nLL4      A         10,=F'1'       ADDS 1 TO LOC. CTR. FOR CONSTANT\n         B         CLEANUP        BRANCHES TO PREPARE FOR NEW INPUT.\nMOVE     CLC       0(1,2),=C'F'   LOOKS FOR A \"F\"\n         BNE       SEARCH         IF NOT, ASSUMES A NUMBER.\n         B         FULWD1A\nSEARCH   SR        5,5            REGISTER USED TO CONTAIN NUM BER\nSEARCH1   IC       5,0(2)         PUTS FIRST NUMBER INTO REGISTER\n         LA        2,1(2)         INCREASES INPUT COUNTER\n         CLI       0(2),C'Z'      CHECKS TO SEE IF NEXT COLUMN IS A NO\n         BNH       DETER          IF NOT, CHECKS FOR \"C\" OR \"F\"\n         SLL       5,8            IF SO, MAKES ROOM IN REGISTER FOR IT\n         B         SEARCH1         RETURNS TO INSERT THE NUMBER\nDETER    CLI       0(2),C'C'      CHECKS FOR A \"C\"\n         BNE       DETERF         IF NOT, ASSUMES A \"F\"\n         ST        5,AN+4         STORES THE NUMBER\n         PACK      ANY(8),AN+4(4) PACKES NUMBER\n          CVB       5,ANY         CHANGES THE NUMBER TO BINARY\n         B         ADD            BRANCHES TO PRINT SECTION\nDETERF   ST        5,AN+4         STORES THE NUMBER\n         PACK      ANY(8),AN+4(4) PACKES NUMBER\n         CVB       5,ANY          CHANGES THE NUMBER TO BINARY\n         SLL       5,2                 MULTIPLIES IT BY 4 SINCE IT IS\n*                                 THE NUMBER OF FULLWORDS\nDTRF     LR        11,10\n        SRL        10,2\n         SLL       10,2\n         CR        11,10\n         BE        ADD\n         A         10,=F'4'\n          B          ADD\nLOOK4    CLC       0(3,2),MCODE+10 CHECKS FOR END STATEMENT\n         BE        ENDF           IF SO BRANCHES TO COMPLETE PASS1\n         LR        11,10\n         SRL       10,1\n         SLL       10,1\n         CR        11,10\n         BE        FULL1A\n         A         10,=F'2'\n         B         FULL1A\nCLEANUP  LA        3,40(3)        MOVES POINTER OF INPUT TO NEXT CARD\n         LA        2,0(3)         PUTS THIS ADDRESS INTO REGISTER 2\n         B         TOP1A          RETURNS TO EVALUATED NEXT CARD\nILLEGAL  XPRNT     CCO,31         PRINTS ERROR STATEMENT FOR ILLEGAL\n*                                      LABEL\n         A         4,=F'1'        PUTS A VALUE INTO FLAG REGISTERSO\n*                                      THAT WHEN WE ARE DONE WITH PASS\n*                                      1 WE WILL RETURN TO MAIN PROGRA\n*                                      M INSTEAD OF GOING TO PASS2\n         B         NOLABEL        BRANCHES TO EVALUATE OPCODE FOR CARD\nDUPLAB   XPRNT     COC,33         PRINTS ERROR FOR DUPLICATE LAVEL\n         A         4,=F'1'        SAME AS ABOVE\n         B         NOLABEL        SAME AS ABOVE\nENDF     LA        7,TABLE        LOADS ADD. OF STORAGE THAT WILL CONT\n*                                      AIN LOCATION AND INPUT\n         L         2,=V(STORE)    LOADS ADDRESS OF INPUT\n         LA        3,LTN          LOADS ADD. OF LOCATION TABLE\n         L         5,=V(COUNTER)  LOADS ADD. OF NUMBER OF CARDS\n         L         6,0(5)         LOADS NUMBER OF CARDS\n         S         6,=F'1'        SUBTRACTS 1 CAUSE END STATEMENT IS\n*                                      NOT IN THIS PART.\n         XPRNT     CNT,20\n         XPRNT     CTN,32\nEN       MVC       0(4,7),0(3)    PUTS LOCATION INTO STORAGE\n         MVC       8(40,7),0(2)   PUTS INPUT CARD INTO STORAGE\n         XPRNT     TABLE-1,49     PRINTS LOCATION AND INPUT\n         LA        2,40(2)        INCREASES TO NEXT CARD\n         LA        3,4(3)         INCREASES TO NEXT LOCATION\n         BCT       6,EN           CHECKS NUMBER OF CARDS AND BRANCHES\n         LA        1,ADDPASS1     IF NO ERROR, WE LOAD THE ADRESSES OF\n*                                      OF THE LABEL TABLE AND THE LOC.\n*                                      CTR. TABLE\n         LA        13,SAVPAS1A    LOAD THE ADDRESS OF THE STORAGE LOC.\n*                                      FOR PASS1 REGISTERS.\n         L         15,=V(PASS2)   LOAD PASS2 CSECT\n         BALR      14,15          BRANCH TO PASS2\nRETURN   L         13,SAVPAS1A+4   LOADS ADDRESS OF MAIN PROGRAM REG.\n         LM        14,12,12(13)    RESTORES MAIN PROGRAM REGISTERS\n         BR        14             BRANCHES BACK TO MAIN PROGRAM\nLEGAL    DS        30H\nLOCTN    DS        30F\nMCODE    DC        C'BYIELDDCDSEND'\nNUMBER   DS        F\nAN       DS        D\nANY      DS        D\nCCO      DC        C'0***ERROR***   -  ILLEGAL LABEL'\nCOC      DC        C'0***ERROR***   -  DUPLICATE LABEL'\nSAVPAS1A DS        18F\nADDPASS1 DC        A(LEGAL)\n         DC        A(LOCTN)\nLC1      DS        F\nLC2      DS        F\nLC3      DS        F\nCNT      DC        C'1THIS IS A TABLE OF:'\nCTN      DC        C'0LOCATION                  INPUT'\n         DC        C'    '\nTABLE    DC        12F'0'\nPTR      DC        F'0'\nLTN      DS        500F\n         LTORG\nPASS2    CSECT\n         STM       14,12,12(13)\n         BALR      12,0\n         USING     *,12\n         ST        13,SAVPAS2+4\n         LM        3,4,0(1)       LOADS ADDRESS OF LABEL TABLE IN REG3\n*                                 PUT ADD. OF LOC. CTR. TABLE IN REG 4\n         L         2,=V(STORE)    PUTS ADDRESS OF INPUT IN REG. 2\n         LA        9,0(2)         PUTS ADDRESS OF INPUT IN REG. 9\n         SR        5,5            POINTER IN MEMORY FOR MACHINE CODE\nUP2      SR        10,10          CLEARED TO CONTAIN MACHINE CODE\n         CLC       0(1,2),=C' '   CHECKS FOR A LABEL\n         BE        OVERPAS2       IF NOT, BRANCHES TO CHECK FOR IPCODE\n         LA        2,3(2)         IF SO, BRANCHES OVER LABEL\nOVERPAS2 LA        2,1(2)         INCREASES INPUT POINTER\n         CLC       0(1,2),=C' '   CHECKS FOR OPCODE\n         BE        OVERPAS2       IF NOT, RETURN TO REPEAT SEARCH\n         CLC       0(2,2),R       IF SO CHECKS FOR LD STATEMENT\n         BNE       ST             IF NOT LD, CHECKS FOR ST STATEMENT\n         IC        10,S           IF LD, PUTS HEX OPCODE IN REG 10\nBEFORE1  LA        2,2(2)         INCREASES INPUT POINTER OVER OPCODE\n         B         LOOKOPR        RETURNS TO ASSEMBLE DISPLACEMENT\nST       CLC       0(2,2),R+2     CHECKS FOR ST STATEMENT\n         BNE       A              IF NOT, CHECKS FOR ADD STATEMENT\n         IC        10,S+1         IF SO, PUTS HEX OPCODE IN REG. 10\nL        B         BEFORE1        RETURNS TO ASSEMBLE DISPLACEMENT\nA        CLC       0(1,2),R+4     CHECKS FOR ADD STATEMENT\n         BNE       SUB            IF NOT, CHECKS FOR S STATEMENT\n         IC        10,S+2         IF SO, PUTS HEX OPCODE IN REG. 10\nBEFORE2  LA        2,1(2)         INCREASES INPUT POINTER OVER OPCODE\n         B         LOOKOPR        RETURNS TO ASSEMBLE DISPLACEMENT\nSUB      CLC       0(1,2),R+5     CHECKS FOR S STATEMENT\n         BNE       MT             IF NOT, CHECKS FOR MT STATEMENT\n         IC        10,S+3         IF SO, PUTS HEX OPCODE IN REG. 10\n         B         BEFORE2        RETURNS TO ASSEMBLE DISPLACEMENT\nMT       CLC       0(2,2),R+6     CHECKS FOR MT STATEMENT\n         BNE       DV             IF NOT, CHECKS FOR DV STATEMENT\n         IC        10,S+4         IF SO, PUTS HEX OPCODE IN REG. 10\n         B         BEFORE1        RETURNS TO ASSEMBLE DISPLACEMENT\nDV       CLC       0(2,2),R+8     CHECKS FOR DV STATEMENT\n         BNE       GO             IF NOT, CHECKS FOR GO STATEMENT\n         IC        10,S+5         IF SO, PUTS HEX OPCODE IN REG. 10\n         B         BEFORE1        RETURNS TO ASSEMBLE DISPLACEMENT\nGO       CLC       0(2,2),R+10    CHECK FOR GO STATEMENT\n         BNE       RD1            IF NOT, CHECKS FOR RD1 STATEMENT\n         IC        10,S+6         IF SO, PUTS HEX OPCODE IN REG. 10\n         B         BEFORE1        RETURNS TO ASSEMBLE DISPLACEMENT\nRD1      CLC       0(3,2),R+12    CHECKS FOR RD1 STATEMENT\n         BNE       RD             IF NOT, CHECKS FOR RD STATEMENT\n         IC        10,S+7         IF SO, PUTS HEX OPCODE IN REG. 10\n         LA        2,3(2)         INCREASES INPUT POINTER PAST OPCODE\n         B         LOOKOPR        RETURNS TO ASSEMBLE DISPLACEMENT\nRD       CLC       0(2,2),R+15    CHECKS FOR RD STATEMENT\n         BNE       WRT1           IF NOT, CHECKS FOR WRT1 STATEMENT\n         IC        10,S+8         IF SO, PUTS HEX OPCODE IN REG. 10\n         LA        2,2(2)         INCREASES INPUT POINTER PAST OPCODE\n         B         LKOPRND        RETURNS TO ASSEMBLE DISPLACEMENT\nWRT1     CLC       0(4,2),R+17    CHECKS FOR WRT1 STATEMENT\n         BNE       WRT            IF NOT, CHECKS FOR WRT STATEMENT\n         IC        10,S+9         IF SO, PUTS HEX OPCODE IN REG. 10\n         LA        2,4(2)         INCREASES INPUT POINTER PAST OPCODE\n         B         LOOKOPR        RETURNS TO ASSEMBLE DISPLACEMENT\nWRT      CLC       0(3,2),R+21    CHECKS FOR WRT STATEMENT\n         BNE       B              IF NOT, CHECKS FOR B STATEMENT\n         IC        10,S+10        IF SO, PUTS HEX OPCODE IN REG. 10\n         LA        2,3(2)         INCREASES INPUT POINTER PAST OPCODE\n         B         LKOPRND        RETURNS TO ASSEMBLE DISPLACEMENT\nB        CLC       0(1,2),R+24    CHECKS FOR B STATEMENT\n         BNE       YIELD          IF NOT, CHECKS FOR YIELD STATEMENT\nHIGH2    LA        2,1(2)         IF SO, INCR. INPUT PTR. PAST OPCODE\n         CLC       0(1,2),=C' '   CHECKS FOR OPERAND\n         BE        HIGH2          IF NOT, RETURNS TO CHECK NEXT COLUMN\n         LA        10,0(3)        IF SO, PUT ADD. OF LABEL TABLE IN 10\n         LA        6,3            COUNTER OF OPERANDS THAT WILL DECRES\n         LA        11,LA          ADD. OF STORAGE FOR L1 IN REG. 11\n         LA        8,0(4)         ADD. OF LOC. CTR. TABLE IN REG. 8\nHIGH4    CLC       0(2,2),0(3)    COMPARES L1 TO LABEL TABLE\n         BE        HIGH3          WHEN LABEL IS FOUND, BRANCH\n         LA        3,2(3)         IF NOT, INCREASE PTR. TO NEXT LABEL\n         LA        4,4(4)         INCREASE PTR. TO NEXT LOC. CTR.\n         B         HIGH4          RETURN FOR NEXT COMPAARISON\n*                                 COMES HERE WHEN FINDS LABEL\nHIGH3    MVC       0(2,11),2(4)   MOVES VALUE OF LOCATION INTO LA\n         LA        2,3(2)         IMCREASES INPUT POINTER TO NEXT OPER\n         LA        11,2(11)       ADD. OF STORAGE FOR L2 IN REG. 11\n         LA        3,0(10)        RESETS LABEL TABLE POINTER\n         LA        4,0(8)          RESETS LOC. CTR. TABLE POINTER\n         BCT       6,HIGH4        DECREASES COUNTER OF OPERANDS, CHECK\n*                                      S AND BRANCHES TO EVALUATE NEXT\n*                                      OPERAND.\n         LH        6,LB           PUTS SECOND OPERAND IN REG. 6\n         LH        7,LC           PUTS THIRD OPERAND IN REG. 7\n         SLL       7,20           MOVES THIRD OPERAND TO LEFT PART OF7\n         SLDL      6,12           MOVES SECOND AND THIRD INTO REG.6\n         ST        6,NUM\n         LA        10,BRNCH       LOADS REG. 10 WITH STORAGE FOR MACHI\n*                                      NE CODE OF B STATEMENT\n         MVC       0(1,10),S+11   PUTS HEX OPCODE INTO FIRST BYTE OF\n*                                      THE MACHINE CODE STORAGE LOCATI\n         MVC        3(3,10),NUM+1 STORES SECOND AND THIRD OPERAND LOCA\n*                                      TIONS STARTING AT FOURTH BYTE\n         MVC       1(2,10),LA     STORES FIRST OPRND. LOC. AT SECOND\n*                                      BYTE\n*                  THIS SECTION CHECKS LOC. CTR. FOR HALFWORD BOUNDARY\n         LR        6,5\n         SRL       5,1\n         SLL       5,1\n         CR        6,5\n         BE        HIGH5\n         A         5,=F'2'\n*                  GETS HERE WHEN LOCATION COUNTER IS SET\nHIGH5    LA        7,MEMORY(5)    LOADS REG. 7 WITH ADDRESS OF MEMORY\n*                                   WHERE MACHINE CODE WILL GO\n         MVC       0(6,7),0(10)   PUTS MACHINE CODE INTO MEMORY\n         A         5,=F'6'        INCREASES POINTER IN MEMORY\n         B         DONE           BRANCHES TO OUTPUT STATEMENTS\nYIELD    CLC       0(5,2),R+25    CHECKS FOR YIELD STATEMENT\n         BNE       DS             IF NOT. CHECKS FOR DS STATEMENT\n*                                 THIS SECTION MAKES SURE LOCATION COU\n*                                      NTER IS ON HALFWORD BOUNDARY\n         LR        6,5\n         SRL       5,1\n         SLL       5,1\n         CR        6,5\n         BE        HIGH6\n         A         5,=F'2'\n*                  GETS HERE WHEN LOCATION COUNTER IS SET\nHIGH6    LA        7,MEMORY(5)    LOADS REG. 7 WITH ADD. OF MEMORY WHE\n*                                      RE MACHINE CODE WILL GO\n         MVC       0(2,7),S+12    PUTS MACHINE CODE INTO MEMORY\n         A         5,=F'2'        INCREASES POINTER IN MEMORY\n         B         DONE           BRANCHES TO OUTPUT STATEMENTS\nDC       CLC       0(2,2),R+30    CHECKS FOR DC STATEMENT\n         BNE       DS             IF NOT, CHECKS FOR DS STATEMENT\n         LA        2,2(2)         OF SO INCREASES INPUT PTR. PAST OPCD\nDC2      CLC       0(1,2),=C' '   CHECKS FOR OPERAND\n         BNE       DC1            BRANCHES WHEN FINDS OPERAND\n         LA        2,1(2)         INCREASES INPUT PTR.\n         B         DC2            RETURNS TO CHECK FOR OPERAND\nDC1      CLC       0(1,2),=C'C'   CHECKS FOR A \"C\" IN OPERAND\n         BNE       DC3            IF NOT, CHECKS FOR A \"F\"\n         LA        2,1(2)         IOF SO, INCREASES PAST THE \"C\"\n         SR        6,6            CLEARS A REGISTER THAT WILL BE A POI\n*                                 NTER IN AN AREA OF STORAGE THAT WILL\n*                                 CONTAIN THE CHARACTERS WITHIN THE \"S\n         LA        2,1(2)         INCREASES INPUT PTR. PAST THE QUOTE\nDC5      LA        7,MEMORY(5)    LOADS REG. M WITH ADDRESS OF MEMORY\n*                                      WHERE MACHINE CODE WILL GO.\n         MVC       0(1,7),0(2)    PUTS FIRST CHARACTER IN MEMORY\n         LA        10,DFCNST(6)   LOADS REG. 10 WITH ADDRESS OF STORAG\n*                                      E WHERE CHARACTERS WILL BE STOR\n         MVC       0(1,10),0(2)   PUTS FIRST CHARACTER INTO STORAGE\n         A         6,=F'1'        INCREASES STORAGE POINTER\n         A         5,=F'1'        INCREASES MEMORY POINTER\n         LA        2,1(2)         INCREASES INPUT POINTER\n         CLC       0(1,2),=X'7D'  CHECKS FOR QUOTE\n         BNE       DC5            IF NOT, RETURNS TO INSERT CHARACTER\n         B         DONE           IF SO, BRANCHES TO OUTPUT\nDC3      CLC       0(1,2),=C'F'   CHECKS FOR A \"F\"\n         BNE       OUTDC          IF NOT, BRANCHES TO PRINT ERROR.\n         LA        2,2(2)         IF SO, INCREASES INPUT PTR. PAST QUO\nDC6      IC        10,0(2)        PUTS FIRST CHARACTER IN REG. 10\n         LA        2,1(2)         INCREASES TO NEXT INPUT CHARACTER\n         CLC       0(1,2),=X'7D'  CHECKS FOR A QUOTE\n         BE        DC8            IF SO, BRANCHES TO INSERT IN MEMORY\n         SLL       10,4           IF NOT, MOVES VALUE IN 10 TO THE LEF\n*                                      T TO MAKE ROOM FOR NEXT CHARATR\n         B         DC6            BRANCHES TO INSERT NEXT CHARACTER\n*        THIS SECTION MAKES SURE LOC. CTR. IS ON FULL WORD BOUNDARY\nDC8      LR        6,5\n         SRL       5,2\n         SLL       5,2\n         CR        6,5\n         BE        DC7\n         A         5,=F'4'\n*                  GETS HERE WHEN LOCATION COUNTER IS SET\nDC7      ST        10,MEMORY(5)   PITS FULLWORD CONSTANT IN MEMORY\n         A         5,=F'4'        INCREASES LOCATION COUNTER\n         B         DONE           BRANCHES TO OUTPUT\nDS       CLC       0(2,2),R+32    CHECKS FOR DS STATEMENT\n         BNE       END            IF NOT, CHECKS FOR END STATEMENT\n         LA        2,2(2)         IF SO, INCREASES PAST OPCODE\nDS1      CLC       0(1,2),=C' '   CHECKS FOR OPERAND\n         BNE       OPCODS         BRANCHES WHEN FINDS OPERAND\n         LA        2,1(2)         IF NOT, INCREASE INPUT POINTER\n         B         DS1            RETURN TO CHECK FOR OPERAND\nOPCODS   CLC       0(1,2),=C'C'   CHECKS FOR A \"C\"\n         BNE       DS2            IF NOT, CHECKS FOR A \"F\"\n         A         5,=F'1'        IF SO, INCREASES LOC. CTR. FOR TYE C\n         B         DONE           BRAN HES TO OUTPUT\nDS2      CLC       0(1,2),=C'F'   CHECKS FOR A \"F\"\n         BNE       DS3            IF NOT, ASSUMES A VALUE\n         LR        6,5            IF SO, CHECKS LOC. CTR. FOR FULLWORD\n         SRL       5,2                 BOUNDARY\n         SLL       5,2\n         CR        6,5\n         BE        DS4\n         A         5,=F'4'\nDS4      A         5,=F'4'        INCREASES LOC. CTR. FOR THE \"F\"\n         B         DONE           BRANCHES TO OUTPUT\nDS3      IC        10,0(2)        PUT FIRST VALUE IN REG 10\n         LA        2,1(2)         INCREASES INPUT POINTER\n         CLC       0(1,2),=C'Z'   CHECKS TO SEE IF INPUT IS ANOTHER NO\n         BNH       DS5            IF NOT, BRANCHES TO CHECK FOR C &F\n         SLL       10,8\n         B         DS3            RETURNS TO INSERT VALUE\nDS5      CLC       0(1,2),=C'C'   CHECKS FOR A \"C\"\n         BNE       DS6            IF NOT, ASSUMES A \"F\"\n         ST        10,CHANGE      IF SO, WE CHANGE THE VALUE TO\n         XDECI     10,CHANGE           HEX FOR ADDING TO LOC. CTR.\n         AR        5,10           ADDS VALUE TO LOC. CTR.\n         B         DONE           BRANCHES TO OUTPTU\nDS6      LR        6,5            MAKES SURE LOC. CTR. IS ON FULLWORD\n         SRL       5,2            BOUNDARY FOR THE \"F\"\n         SLL       5,2\n         CR        6,5\n         BE        DS7\n         A         5,=F'4'\nDS7      ST        10,CHANGE      CHANGES THE VALUE TO HEX\n         XDECI     10,CHANGE           FOR ADDING TO THE LOC. CTR.\n         SLL       10,2           MULTIPLIES VALUE BY 4 SINCE IT IS\n*                                      THE NUMBER OF FULLWORDS\n         AR        5,10           ADDS VALUE TO THE LOC. CTR.\n         B         DONE           BRANCHES TO THE OUTPUT\nEND      B         FINISH\n*                  THIS PART FINISHES MACHINE CODE FOR ALL OPCODES\n*                                 EXCEPT READS, WRITES, DS, DC, END, B\n*                                 , AND YIELD.\nLOOKOPR  CLC       0(1,2),=C' '   CHECKS FOR OPERAND\n         BNE       OPR1           BRANCHES WHEN FINDS OPERAND\n         LA        2,1(2)         IF NOT, INCREASES INPUT POINTER\n         B         LOOKOPR        RETURNS TO CHECK FOR OPERAND\nOPR1     L         3,=V(LEGAL)\n         L         4,=V(LOCTN)\nOPR3     CLC       0(2,2),0(3)    CHECKS OPERAND WITH LABEL TABLE\n         BE        OPR2           IF EQUAL, BRANCHES TO INSERT LOCATIO\n         LA        3,2(3)         IF NOT, INCREASES TO NEXT LABEL\n         LA        4,4(4)         INCREASES TO NEXT LOCATION\n         B         OPR3           RETURNS TO COMPARE OPERAND\nOPR2     SLL       10,24          MOVES HEXOPCODE TO PROPER POSITION\n         LA        7,MEMORY(5)\n         ST        10,NUM\n         MVC       0(1,7),NUM\n         MVC       2(2,7),2(4)\n         MVC       1(1,7),=X'00'\n         A         5,=F'4'        INCREASES LOC. CTR. BY 4\n         B         DONE           BRANCHES TO OUTPUT\n*                  THIS PART FINISHES MACHINE CODE FOR READS AND WRITE\nLKOPRND  CLC       0(1,2),=C' '   CHECKS FOR OPERAND\n         BNE       LK1            BRANCHES WHEN FINDS OPERAND\n         LA        2,1(2)         IF NOT, INCREASES INPUT POINTER\n         B         LKOPRND        RETURNS TO CHECK FOR OPERAND\nLK1      L         3,=V(LEGAL)\n         L         4,=V(LOCTN)\nLK3      CLC       0(2,2),0(3)    CHECKS OPERAND WITH LABEL TABLE\n         BE        LK2            IF EQUAL, BRANCHES TO CHECK LENGTH\n         LA        3,2(3)         IF NOT, INCREASES TO NEXT LABEL\n         LA        4,4(4)         INCREASES TO NEXT LOACTION\n         B         LK3            RETURNS TO COMPARE OPERAND\nLK2      LA        2,3(2)         INCREASE INPUT POINTER TO LENGTH\nLK4      IC        7,0(2)         PUTS A NUMBER OF LENGTH INTO REG. 7\n         LA        2,1(2)         INCREASES TO NEXT VALUE OF LENGTH\n         CLC       0(1,2),=C' '   CHECKS TO SEE THAT THERE IS A VALUE\n         BE        LK5            IF NOT, BRANCHES TO FINISH MACHINE C\n         SLL       7,8\n         B         LK4            RETURNS TO INSERT THE VALUE\nLK5      ST        7,NUM+4\n         PACK      NUM2(8),NUM1+4(4)\n         L         7,NUM2+4\n         SRL       7,4\n         SLL       10,8\n         AR        10,7           PUTS LENGTH IN REG. 10\n         SLL       10,16          MOVES HEX OPCODE AND LENGTH TO MAKE\n*                                      ROOM FOR DISPLACEMENT\n         ST        10,MEMORY(5)   STORES MACHINE CODE IN MEMORY\n         LA       7,MEMORY(5)\n         MVC       1(1,7),=X'00'\n         MVC       2(2,7),2(4)\n         A         5,=F'4'        INCREASES LOC. CTR. BY 4\nDONE     LA        9,40(9)        INCREASES INPUT PTR. TO NEXT CARD\n         LA        2,0(9)         RESETS INPUT POINTER\n         B         UP2            RETURNS TO DO PASS2 ON NEXT CARD\nFINISH   XPRNT     CCT,59\n         XDUMP     MEMORY,2000    PRINTS THE MACHINE CODE.\n         L         13,SAVPAS2+4\n         LM        14,12,12(13)\n         BR        14\nOUTDC    XPRNT     CCC,33\n         B         DONE\nERROR    XPRNT     OCO,32\n         B         DONE\n        PRINT      ON\nSAVPAS2  DS        18F\nLA       DS        H\nLB       DS        H\nLC       DS        H\nBRNCH    DS        3H\nDFCNST   DS        33C\nR        DC        C'LDSTASMTDVGORD1RDWRT1WRTBYIELDDCDSEND'\nS        DC        X'4142515253541122213231131500'\nNUM      DS        F\nCHANGE   DS        F\nNUM1     DS        D\nNUM2     DS        D\nCCC      DC        C'0***ERROR***   -  ILLEGAL OPERAND'\nOCO      DC        C'0***ERROR***   -  ILLEGAL OPCODE'\n         LTORG\nCCT      DC        C'1THIS IS THE STORAGE FOR THE PROGRAM READ INTO '\n         DC        C'THE COMPILER'\n         DS        0F\nMEMORY   DC        2000X'EE'\n         END\n$ENTRY\n    RD1    M1\n   RD1  N1\n    WRT1    M1\n     WRT1 N1\n  LD  M1\n     S         N1\n    B  B1,B1,A1\nA1: LD M1\n  ST       T1\n LD N1\n      ST    M1\n  LD       T1\n    ST  N1\nB1:     LD  N1\n   DV   M1\n     MT     M1\n   ST  Q2\n    LD     N1\n   S Q2\n   B        B2,D1,B2\nB2:     ST    T2\n   LD M1\n   ST   N1\n       LD   T2\n                ST        M1\n       GO       B1\nD1: WRT M5,31\n       WRT1  M1\n YIELD\nM1:   DS   1F\nN1:    DS    1F\nT1: DS 2F\nT2:     DS     10F\nM5:    DC  C'THE GREATEST COMMON'\n     DC   C' DIVISOR IS:'\nQ2:   DC    F'0'\n                          END\n##\n$JOB   ASSIST  PROGTEST\n*        *** SECOND IN SERIES OF RELATED PROGRAMS.\n*        *** SIMILAR TO PREVIOUS PROGRAM - NOTE INCREASED SPACE\n*        REQUIREMENTS DUE TO SEQUNCED CARD INPUT.\n*        PROGRAM PRINTS TWO PAGES, EXECUTES 19508 INSTRUCTIONS, ABENDS\n*        WITH 0C4 LIKE PREVIOUS PROGRAM.\n*        PSU CMPSC 102 - SUMMER 1970 - FINAL PROJECT\nMAIN     CSECT\n         ENTRY     STORE\n         ENTRY     COUNTER\n         BALR      12,0\n         USING     *,12\n         ST        14,SAV14\n         SR        4,4            POINTER IN ARRAY OF INPUT\n         SR        5,5            COUNTER OF NUMBER OF CARDS READ.\n         XPRNT     CONT,56        PRINTS LABEL FOR INPUT\nTOP      XREAD     ARRAY,80       READS ALL OF INPUT CARDS\n         CLC       ARRAY(2),=C'##'     LOOKS FOR FLAG CARD\n         BE        BRPASS1\n         XPRNT     CC,81          ECHO CHECKS ALL OF THE INPUT CARDS\n         LA        3,STORE(4)     LOADS THE ADDRESS OF THE ARRAY\n*                                      CONTAINING THE FIRST 40 COLUMNS\n*                                      OF EACH INPUT CARD.\n         MVC       0(40,3),ARRAY  PUTS FIRST 40 COLUMNS INTO THE ARRAY\n         A         4,=F'40'       INCREASES POINTER IN THE ARRAY\n         A         5,=F'1'        INCREASES THE CARD COUNTER\n         B         TOP            RETURNS TO READ THE NEXT CARD\n*                                 COMES HERE IF FLAG CARD IS READ\nBRPASS1  ST        5,COUNTER      STORES THE CARD COUNTER\n         L         15,=V(PASS1A)  LOADS ADDRESS OF CSECT BEIBG CALLED\n         LA        13,SAVMAIN     LOADS REGISTER STORAGE LOCATION\n         BALR      14,15          BRANCHES TO CSECT PASS1A\n         L         14,SAV14\n         B         14\nSAV14    DS        F\nCONT     DC        C'1THIS IS THE PROGRAM READ INTO THE PASS1, PASS2'\n         DC        C'COMPILER'\nCC       DC        C' '\nARRAY    DS        80C\nCOUNTER  DS        F\nSAVMAIN  DS        18F\n         LTORG\nSTORE    DS        1000F\nPASS1A   CSECT\n         ENTRY     LEGAL\n         ENTRY     LOCTN\n         STM       14,12,12(13)\n         BALR      12,0\n         USING     *,12\n         ST        13,SAVPAS1A+4\n         L         2,=V(STORE)    LOADS ADDRESS OF STORAGE INTO\n         L         3,=V(STORE)    REGISTERS 2 AND 3\n         SR        4,4            FLAG REGISTER FOR ERRORS.\n         SR        7,7            POINTER IN LABEL TABLE.\n         SR        9,9            POINTER  IN LOCATION COUNTER TABLE.\n         SR        10,10          LOCATION COUNTER REGISTER\nTOP1A    CLC       0(1,2),=C' '   CHECKS FOR A LABEL.\n         BE        NOLABEL\n         SR        6,6\n         CLC       0(1,2),=C'A'   CHECKS FOR LEGALITY OF LABEL\n         BL        ILLEGAL        IF CONDITIONS ARE NOT MET, BRANCH TO\n         CLC       0(1,2),=C'Z'        PRINT ERROR STATEMENT\n         BH        ILLEGAL\n         CLC       1(1,2),=C'1'\n         BL        ILLEGAL\n         CLC       2(2,2),=C': '\n         BNE       ILLEGAL\n*                                 GET HERE IF LEGAL LABEL CONDITIONS A\n*                                      RE MET.\n         LA        8,LEGAL(7)     LOADS ADDRESS OF NEXT ENTRY POINT FO\n*                                      R A LEGAL LABEL.\nUP1A     LA        5,LEGAL(6)     LOADS ADDRESS OF LABEL TO BE COMPARE\n         CLC       0(2,2),0(5)    COMPARES INPUT LABEL TO LABEL TABLE\n         BE        DUPLAB         IF EQUAL, BRANCHES TO PRINT ERROR.\n         A         6,=F'2'        INCREASES POINTER TO NEXT LABEL.\n         CR        7,6            CHECKS FOR END OF LABEL TABLE.\n         BH        UP1A\n         MVC       0(2,8),0(2)    PUTS INPUT LABEL INTO TABLE.\n         SR        6,6\nREG6     C         6,=F'0'        CHECKS FLAG REGISTER\n         BE        RG6            BRANCHES IF EQUAL\n         LR        8,10           SAVE LOCATION COUNTER\n         CVD       10,AN          CHANGES LOC. CTR. TP DECIMAL\n         UNPK      ANY(8),AN+4(4) UNPACKS LOC. CTR.\n         L         10,ANY+4       PUTS LOC. CTR. IN REG. 10\n         A         10,=F'48'      CHANGES SIGN FROM A C TO A F\n         L         11,PTR         LOADS PTR. OF LOCATION TABLE\n*                                      CORRESPONDING TO THE INPUT\n         ST        10,LTN(11)     PUTS BASE 10 LOOKING LOC. CTR. IN TB\n         A         11,=F'4'       INCREASES PTR. IN TABLE\n         ST        11,PTR         SAVES POINTER\n         LR        10,8           RESTORES LOCATION COUNTER\n*                                 THIS SECTION CHECKS FLAG REGISTER\n*                                      AND RETURNS TO PROPER POINT.\n         C         6,=F'1'\n         BE        LL\n         C         6,=F'2'\n         BE        LL1\n         C         6,=F'3'\n         BE        LL2\n         C         6,=F'4'\n         BE         LL3\n         B         LL4\n*                  THIS PART INSERTS LOCATION COUNTER INTO TABLE\n*                                 CORRESPONDING TO LABEL INSERTED.\nRG6      LR        11,10\n         LR        8,10           SAVES LOCATION COUNTER\n         SR        10,10          CLEARS REG. SO THAT IT WILL CONTAIN\n*                                      REMAINDER AFTER DIVISION\n         D         10,=F'10'      DIVIDES LOC. CTR. BY 10\n         ST        10,LC1         SAVES THE REMAINDER\n         SR        10,10          CLEARS REG. 10 FOR NEXT REMAINDER\n         D         10,=F'10'      DIVIDES LOC. CTR. BY 10 AGAIN\n         ST        10,LC2         SAVES THE REMAINDER\n         SLL       11,8           MULTIPLIES VALUE IN 11 BY 256\n         ST        11,LC3         STORES RESULT IN LC3\n         L         11,LC2         PUTS SECOND REMAINDER IN REG. 11\n         SLL       11,4           MULTIPLIES IT BY 16\n         L         10,LC1         PUTS FIRST REMAINDER IN REG. 10\n         AR        10,11          ADDS PARTS OF NEW LOC.CTR.\n         A         10,LC3         ADDS REST OF NEW LOC. CTR.\nNO       ST        10,LOCTN(9)\n         LR        10,8           RESTORES LOC. CTR.\n         LA        7,2(7)         INCREASES LABEL TABLE POINTER.\n         LA        9,4(9)         INCREASES LOCATION COUNTR TABLE PTR.\n         LA        2,4(2)          INCREASE INPUT POINTER.\n*        COMES HERE IF THERE IS NO LABEL AND LOOKS FOR THE OPCODE.\nNOLABEL  CLC       0(1,2),=C' '   CHECKS FOR OPCODE\n         BNE       LOOK           BRANCHES WHEN FINDS OPCODE\n         LA        2,1(2)              INCREASES INPUT POINTER\n         B         NOLABEL        RETURNS AND CHECKS FOR OPCODE\n*                  COMES HERE IF OPCODE IS FOUND.\nLOOK     CLC       0(1,2),MCODE   CHECKS FOR A BRANCH STATEMENT\n         BNE       LOOK1          IF NOT BRANCHES AND CHECKS FOR YIELD\n         LA        6,1            SETS UP A FLAG REGISTER\n         B         REG6           BRANCHES TO CHANGE LOC. CTR.\nLL       A         10,=F'6'       ADDS 6 TO LOC. CTR. FOR BRANCH\n         B         CLEANUP        BRANCHES TO PREPARE FOR NEW INPUT\nLOOK1    CLC       0(1,2),MCODE+1 CHECKS FOR A YIELD STATEMENT\n         BNE       LOOK2          IF NOT, BRANCHES AND CHECKS FOR DC.\n         LA        6,2            SETS UP A FLAG REGISTER\n         B         REG6           BRANCHES TO CHANGE LOC. CTR.\nLL1      A         10,=F'2'       ADDS 2 TO LOC. CTR. FOR YIELD\n         B         CLEANUP        BRANCHES TO PREPARE FOR NEW INPUT\nLOOK2    CLC       0(2,2),MCODE+6 CHECKS FOR DC STATEMENT\n         BNE       LOOK3          IF NOT, BRANCHES AND LOOKS FOR DS\n         LA        2,2(2)         IF SO, INCREASES INPUT PTR. PAST OPC\nOUT1A    CLC       0(1,2),=C' '   CHECKS FOR OPERAND\n         BNE       OUT            BRANCHES WHEN FINDS OPEFAND\n         LA        2,1(2)         IF NOT, INCREASE INPUT PTR.\n         B         OUT1A          RETURNS AND CHECKS FOR OPERAND\n*                                 GETS HERE WHEN FINDS OPERAND\nOUT      CLC       0(1,2),=C'C'    LOOKS FOR A \"C\"\n         BNE       FULLWORD       IF NOT, ASSUMES A \"F\"\n         LA        2,2(2)         INCREASES INPUT POINTER PAST QUOTE\n         SR        5,5            SETS UP COUNTER OF NO. OF CHARACTERS\nOUTADD   CLC       0(1,2),=X'7D'  SEARCHES FOR SECOND QUOTE.\n         BE        ADD            IF FOUND, ADDS NUMBER TO LOC. CTR.\n         A         5,=F'1'        ADDS 1 TO CHARACTER COUNTER\n         LA        2,1(2)         INCREASES INPUT POINTER.\n         B         OUTADD         RETURNS AND LOOKS FOR QUOTE.\nADD      LA        6,3            SETS UP A FLAG REGISTER\n         B         REG6           BRANCHES TO CHANGE LOC. CTR.\nLL2      AR        10,5           ADDS VALUE CALCULATED IN REG 5 TO\n*                                      LOCATION COUNTER\n         B         CLEANUP         BRANCHES TO PREPARE FOR NEW INPUT.\nFULLWORD LR        11,10          SAVES LOCATION COUNTER.\n*                                 THIS PART IS FOR A DC FULLWORD.\nFULWD1A  SRL       10,2           CHECKS LOC. CTR. FOR FULLWORD\n         SLL       10,2           BOUNDARY\n         CR        11,10\n         BE        FULL1A         IF ON A FULLWORD, ADDS TO LOC. CTR.\n         A         10,=F'4'       PUTS LOC. CTR. ON A FULLWORD BNDARY.\nFULL1A   LA        6,4\n         B         REG6\nLL3      A         10,=F'4'       ADDS 4 TO LOC. CTR. FOR FULLWORD\n*                                      INSTRUCTION OR CONSTANT\n         B         CLEANUP        BRANCHES TO PREPARE FOR NEW INPUT\nLOOK3    CLC       0(2,2),MCODE+8 CHECKS FOR DS STATEMENT\n         BNE       LOOK4          IF NOT, CHECKS FOR END STATEMENT\n         LA        2,2(2)         IF SO, INCREASE INPUT PTR. PAST OPCO\nCHECK1A  CLC       0(1,2),=C' '   CHECKS FOR OPERAND\n         BNE       CHECK          BRANCHES WHEN FINDS OPERAND\n         LA        2,1(2)         IF NOT, INCREASES INPUT PTR.\n         B         CHECK1A        RETURNS TO CHECK FOR OPERAND\n*                                 GETS HERE WHEN FINDS OPERAND.\nCHECK    CLC       0(1,2),=C'C'   CHECKS FOR A \"C\"\n         BNE       MOVE            IF NOT, BRANCHES TO CHECK FOR A \"F\"\n         LA        6,5            SETS UP A FLAG REGISTER\n         B         REG6           BRANCHES TO CHANGE LOC. CTR.\nLL4      A         10,=F'1'       ADDS 1 TO LOC. CTR. FOR CONSTANT\n         B         CLEANUP        BRANCHES TO PREPARE FOR NEW INPUT.\nMOVE     CLC       0(1,2),=C'F'   LOOKS FOR A \"F\"\n         BNE       SEARCH         IF NOT, ASSUMES A NUMBER.\n         B         FULWD1A\nSEARCH   SR        5,5            REGISTER USED TO CONTAIN NUM BER\nSEARCH1   IC       5,0(2)         PUTS FIRST NUMBER INTO REGISTER\n         LA        2,1(2)         INCREASES INPUT COUNTER\n         CLI       0(2),C'Z'      CHECKS TO SEE IF NEXT COLUMN IS A NO\n         BNH       DETER          IF NOT, CHECKS FOR \"C\" OR \"F\"\n         SLL       5,8            IF SO, MAKES ROOM IN REGISTER FOR IT\n         B         SEARCH1         RETURNS TO INSERT THE NUMBER\nDETER    CLI       0(2),C'C'      CHECKS FOR A \"C\"\n         BNE       DETERF         IF NOT, ASSUMES A \"F\"\n         ST        5,AN+4         STORES THE NUMBER\n         PACK      ANY(8),AN+4(4) PACKES NUMBER\n          CVB       5,ANY         CHANGES THE NUMBER TO BINARY\n         B         ADD            BRANCHES TO PRINT SECTION\nDETERF   ST        5,AN+4         STORES THE NUMBER\n         PACK      ANY(8),AN+4(4) PACKES NUMBER\n         CVB       5,ANY          CHANGES THE NUMBER TO BINARY\n         SLL       5,2                 MULTIPLIES IT BY 4 SINCE IT IS\n*                                 THE NUMBER OF FULLWORDS\nDTRF     LR        11,10\n        SRL        10,2\n         SLL       10,2\n         CR        11,10\n         BE        ADD\n         A         10,=F'4'\n          B          ADD\nLOOK4    CLC       0(3,2),MCODE+10 CHECKS FOR END STATEMENT\n         BE        ENDF           IF SO BRANCHES TO COMPLETE PASS1\n         LR        11,10\n         SRL       10,1\n         SLL       10,1\n         CR        11,10\n         BE        FULL1A\n         A         10,=F'2'\n         B         FULL1A\nCLEANUP  LA        3,40(3)        MOVES POINTER OF INPUT TO NEXT CARD\n         LA        2,0(3)         PUTS THIS ADDRESS INTO REGISTER 2\n         B         TOP1A          RETURNS TO EVALUATED NEXT CARD\nILLEGAL  XPRNT     CCO,31         PRINTS ERROR STATEMENT FOR ILLEGAL\n*                                      LABEL\n         A         4,=F'1'        PUTS A VALUE INTO FLAG REGISTERSO\n*                                      THAT WHEN WE ARE DONE WITH PASS\n*                                      1 WE WILL RETURN TO MAIN PROGRA\n*                                      M INSTEAD OF GOING TO PASS2\n         B         NOLABEL        BRANCHES TO EVALUATE OPCODE FOR CARD\nDUPLAB   XPRNT     COC,33         PRINTS ERROR FOR DUPLICATE LAVEL\n         A         4,=F'1'        SAME AS ABOVE\n         B         NOLABEL        SAME AS ABOVE\nENDF     LA        7,TABLE        LOADS ADD. OF STORAGE THAT WILL CONT\n*                                      AIN LOCATION AND INPUT\n         L         2,=V(STORE)    LOADS ADDRESS OF INPUT\n         LA        3,LTN          LOADS ADD. OF LOCATION TABLE\n         L         5,=V(COUNTER)  LOADS ADD. OF NUMBER OF CARDS\n         L         6,0(5)         LOADS NUMBER OF CARDS\n         S         6,=F'1'        SUBTRACTS 1 CAUSE END STATEMENT IS\n*                                      NOT IN THIS PART.\n         XPRNT     CNT,20\n         XPRNT     CTN,32\nEN       MVC       0(4,7),0(3)    PUTS LOCATION INTO STORAGE\n         MVC       8(40,7),0(2)   PUTS INPUT CARD INTO STORAGE\n         XPRNT     TABLE-1,49     PRINTS LOCATION AND INPUT\n         LA        2,40(2)        INCREASES TO NEXT CARD\n         LA        3,4(3)         INCREASES TO NEXT LOCATION\n         BCT       6,EN           CHECKS NUMBER OF CARDS AND BRANCHES\n         LA        1,ADDPASS1     IF NO ERROR, WE LOAD THE ADRESSES OF\n*                                      OF THE LABEL TABLE AND THE LOC.\n*                                      CTR. TABLE\n         LA        13,SAVPAS1A    LOAD THE ADDRESS OF THE STORAGE LOC.\n*                                      FOR PASS1 REGISTERS.\n         L         15,=V(PASS2)   LOAD PASS2 CSECT\n         BALR      14,15          BRANCH TO PASS2\nRETURN   L         13,SAVPAS1A+4   LOADS ADDRESS OF MAIN PROGRAM REG.\n         LM        14,12,12(13)    RESTORES MAIN PROGRAM REGISTERS\n         BR        14             BRANCHES BACK TO MAIN PROGRAM\nLEGAL    DS        30H\nLOCTN    DS        30F\nMCODE    DC        C'BYIELDDCDSEND'\nNUMBER   DS        F\nAN       DS        D\nANY      DS        D\nCCO      DC        C'0***ERROR***   -  ILLEGAL LABEL'\nCOC      DC        C'0***ERROR***   -  DUPLICATE LABEL'\nSAVPAS1A DS        18F\nADDPASS1 DC        A(LEGAL)\n         DC        A(LOCTN)\nLC1      DS        F\nLC2      DS        F\nLC3      DS        F\nCNT      DC        C'1THIS IS A TABLE OF:'\nCTN      DC        C'0LOCATION                  INPUT'\n         DC        C'    '\nTABLE    DC        12F'0'\nPTR      DC        F'0'\nLTN      DS        500F\n         LTORG\nPASS2    CSECT\n         STM       14,12,12(13)\n         BALR      12,0\n         USING     *,12\n         ST        13,SAVPAS2+4\n         LM        3,4,0(1)       LOADS ADDRESS OF LABEL TABLE IN REG3\n*                                 PUT ADD. OF LOC. CTR. TABLE IN REG 4\n         L         2,=V(STORE)    PUTS ADDRESS OF INPUT IN REG. 2\n         LA        9,0(2)         PUTS ADDRESS OF INPUT IN REG. 9\n         SR        5,5            POINTER IN MEMORY FOR MACHINE CODE\nUP2      SR        10,10          CLEARED TO CONTAIN MACHINE CODE\n         CLC       0(1,2),=C' '   CHECKS FOR A LABEL\n         BE        OVERPAS2       IF NOT, BRANCHES TO CHECK FOR IPCODE\n         LA        2,3(2)         IF SO, BRANCHES OVER LABEL\nOVERPAS2 LA        2,1(2)         INCREASES INPUT POINTER\n         CLC       0(1,2),=C' '   CHECKS FOR OPCODE\n         BE        OVERPAS2       IF NOT, RETURN TO REPEAT SEARCH\n         CLC       0(2,2),R       IF SO CHECKS FOR LD STATEMENT\n         BNE       ST             IF NOT LD, CHECKS FOR ST STATEMENT\n         IC        10,S           IF LD, PUTS HEX OPCODE IN REG 10\nBEFORE1  LA        2,2(2)         INCREASES INPUT POINTER OVER OPCODE\n         B         LOOKOPR        RETURNS TO ASSEMBLE DISPLACEMENT\nST       CLC       0(2,2),R+2     CHECKS FOR ST STATEMENT\n         BNE       A              IF NOT, CHECKS FOR ADD STATEMENT\n         IC        10,S+1         IF SO, PUTS HEX OPCODE IN REG. 10\nL        B         BEFORE1        RETURNS TO ASSEMBLE DISPLACEMENT\nA        CLC       0(1,2),R+4     CHECKS FOR ADD STATEMENT\n         BNE       SUB            IF NOT, CHECKS FOR S STATEMENT\n         IC        10,S+2         IF SO, PUTS HEX OPCODE IN REG. 10\nBEFORE2  LA        2,1(2)         INCREASES INPUT POINTER OVER OPCODE\n         B         LOOKOPR        RETURNS TO ASSEMBLE DISPLACEMENT\nSUB      CLC       0(1,2),R+5     CHECKS FOR S STATEMENT\n         BNE       MT             IF NOT, CHECKS FOR MT STATEMENT\n         IC        10,S+3         IF SO, PUTS HEX OPCODE IN REG. 10\n         B         BEFORE2        RETURNS TO ASSEMBLE DISPLACEMENT\nMT       CLC       0(2,2),R+6     CHECKS FOR MT STATEMENT\n         BNE       DV             IF NOT, CHECKS FOR DV STATEMENT\n         IC        10,S+4         IF SO, PUTS HEX OPCODE IN REG. 10\n         B         BEFORE1        RETURNS TO ASSEMBLE DISPLACEMENT\nDV       CLC       0(2,2),R+8     CHECKS FOR DV STATEMENT\n         BNE       GO             IF NOT, CHECKS FOR GO STATEMENT\n         IC        10,S+5         IF SO, PUTS HEX OPCODE IN REG. 10\n         B         BEFORE1        RETURNS TO ASSEMBLE DISPLACEMENT\nGO       CLC       0(2,2),R+10    CHECK FOR GO STATEMENT\n         BNE       RD1            IF NOT, CHECKS FOR RD1 STATEMENT\n         IC        10,S+6         IF SO, PUTS HEX OPCODE IN REG. 10\n         B         BEFORE1        RETURNS TO ASSEMBLE DISPLACEMENT\nRD1      CLC       0(3,2),R+12    CHECKS FOR RD1 STATEMENT\n         BNE       RD             IF NOT, CHECKS FOR RD STATEMENT\n         IC        10,S+7         IF SO, PUTS HEX OPCODE IN REG. 10\n         LA        2,3(2)         INCREASES INPUT POINTER PAST OPCODE\n         B         LOOKOPR        RETURNS TO ASSEMBLE DISPLACEMENT\nRD       CLC       0(2,2),R+15    CHECKS FOR RD STATEMENT\n         BNE       WRT1           IF NOT, CHECKS FOR WRT1 STATEMENT\n         IC        10,S+8         IF SO, PUTS HEX OPCODE IN REG. 10\n         LA        2,2(2)         INCREASES INPUT POINTER PAST OPCODE\n         B         LKOPRND        RETURNS TO ASSEMBLE DISPLACEMENT\nWRT1     CLC       0(4,2),R+17    CHECKS FOR WRT1 STATEMENT\n         BNE       WRT            IF NOT, CHECKS FOR WRT STATEMENT\n         IC        10,S+9         IF SO, PUTS HEX OPCODE IN REG. 10\n         LA        2,4(2)         INCREASES INPUT POINTER PAST OPCODE\n         B         LOOKOPR        RETURNS TO ASSEMBLE DISPLACEMENT\nWRT      CLC       0(3,2),R+21    CHECKS FOR WRT STATEMENT\n         BNE       B              IF NOT, CHECKS FOR B STATEMENT\n         IC        10,S+10        IF SO, PUTS HEX OPCODE IN REG. 10\n         LA        2,3(2)         INCREASES INPUT POINTER PAST OPCODE\n         B         LKOPRND        RETURNS TO ASSEMBLE DISPLACEMENT\nB        CLC       0(1,2),R+24    CHECKS FOR B STATEMENT\n         BNE       YIELD          IF NOT, CHECKS FOR YIELD STATEMENT\nHIGH2    LA        2,1(2)         IF SO, INCR. INPUT PTR. PAST OPCODE\n         CLC       0(1,2),=C' '   CHECKS FOR OPERAND\n         BE        HIGH2          IF NOT, RETURNS TO CHECK NEXT COLUMN\n         LA        10,0(3)        IF SO, PUT ADD. OF LABEL TABLE IN 10\n         LA        6,3            COUNTER OF OPERANDS THAT WILL DECRES\n         LA        11,LA          ADD. OF STORAGE FOR L1 IN REG. 11\n         LA        8,0(4)         ADD. OF LOC. CTR. TABLE IN REG. 8\nHIGH4    CLC       0(2,2),0(3)    COMPARES L1 TO LABEL TABLE\n         BE        HIGH3          WHEN LABEL IS FOUND, BRANCH\n         LA        3,2(3)         IF NOT, INCREASE PTR. TO NEXT LABEL\n         LA        4,4(4)         INCREASE PTR. TO NEXT LOC. CTR.\n         B         HIGH4          RETURN FOR NEXT COMPAARISON\n*                                 COMES HERE WHEN FINDS LABEL\nHIGH3    MVC       0(2,11),2(4)   MOVES VALUE OF LOCATION INTO LA\n         LA        2,3(2)         IMCREASES INPUT POINTER TO NEXT OPER\n         LA        11,2(11)       ADD. OF STORAGE FOR L2 IN REG. 11\n         LA        3,0(10)        RESETS LABEL TABLE POINTER\n         LA        4,0(8)          RESETS LOC. CTR. TABLE POINTER\n         BCT       6,HIGH4        DECREASES COUNTER OF OPERANDS, CHECK\n*                                      S AND BRANCHES TO EVALUATE NEXT\n*                                      OPERAND.\n         LH        6,LB           PUTS SECOND OPERAND IN REG. 6\n         LH        7,LC           PUTS THIRD OPERAND IN REG. 7\n         SLL       7,20           MOVES THIRD OPERAND TO LEFT PART OF7\n         SLDL      6,12           MOVES SECOND AND THIRD INTO REG.6\n         ST        6,NUM\n         LA        10,BRNCH       LOADS REG. 10 WITH STORAGE FOR MACHI\n*                                      NE CODE OF B STATEMENT\n         MVC       0(1,10),S+11   PUTS HEX OPCODE INTO FIRST BYTE OF\n*                                      THE MACHINE CODE STORAGE LOCATI\n         MVC        3(3,10),NUM+1 STORES SECOND AND THIRD OPERAND LOCA\n*                                      TIONS STARTING AT FOURTH BYTE\n         MVC       1(2,10),LA     STORES FIRST OPRND. LOC. AT SECOND\n*                                      BYTE\n*                  THIS SECTION CHECKS LOC. CTR. FOR HALFWORD BOUNDARY\n         LR        6,5\n         SRL       5,1\n         SLL       5,1\n         CR        6,5\n         BE        HIGH5\n         A         5,=F'2'\n*                  GETS HERE WHEN LOCATION COUNTER IS SET\nHIGH5    LA        7,MEMORY(5)    LOADS REG. 7 WITH ADDRESS OF MEMORY\n*                                   WHERE MACHINE CODE WILL GO\n         MVC       0(6,7),0(10)   PUTS MACHINE CODE INTO MEMORY\n         A         5,=F'6'        INCREASES POINTER IN MEMORY\n         B         DONE           BRANCHES TO OUTPUT STATEMENTS\nYIELD    CLC       0(5,2),R+25    CHECKS FOR YIELD STATEMENT\n         BNE       DS             IF NOT. CHECKS FOR DS STATEMENT\n*                                 THIS SECTION MAKES SURE LOCATION COU\n*                                      NTER IS ON HALFWORD BOUNDARY\n         LR        6,5\n         SRL       5,1\n         SLL       5,1\n         CR        6,5\n         BE        HIGH6\n         A         5,=F'2'\n*                  GETS HERE WHEN LOCATION COUNTER IS SET\nHIGH6    LA        7,MEMORY(5)    LOADS REG. 7 WITH ADD. OF MEMORY WHE\n*                                      RE MACHINE CODE WILL GO\n         MVC       0(2,7),S+12    PUTS MACHINE CODE INTO MEMORY\n         A         5,=F'2'        INCREASES POINTER IN MEMORY\n         B         DONE           BRANCHES TO OUTPUT STATEMENTS\nDC       CLC       0(2,2),R+30    CHECKS FOR DC STATEMENT\n         BNE       DS             IF NOT, CHECKS FOR DS STATEMENT\n         LA        2,2(2)         OF SO INCREASES INPUT PTR. PAST OPCD\nDC2      CLC       0(1,2),=C' '   CHECKS FOR OPERAND\n         BNE       DC1            BRANCHES WHEN FINDS OPERAND\n         LA        2,1(2)         INCREASES INPUT PTR.\n         B         DC2            RETURNS TO CHECK FOR OPERAND\nDC1      CLC       0(1,2),=C'C'   CHECKS FOR A \"C\" IN OPERAND\n         BNE       DC3            IF NOT, CHECKS FOR A \"F\"\n         LA        2,1(2)         IOF SO, INCREASES PAST THE \"C\"\n         SR        6,6            CLEARS A REGISTER THAT WILL BE A POI\n*                                 NTER IN AN AREA OF STORAGE THAT WILL\n*                                 CONTAIN THE CHARACTERS WITHIN THE \"S\n         LA        2,1(2)         INCREASES INPUT PTR. PAST THE QUOTE\nDC5      LA        7,MEMORY(5)    LOADS REG. M WITH ADDRESS OF MEMORY\n*                                      WHERE MACHINE CODE WILL GO.\n         MVC       0(1,7),0(2)    PUTS FIRST CHARACTER IN MEMORY\n         LA        10,DFCNST(6)   LOADS REG. 10 WITH ADDRESS OF STORAG\n*                                      E WHERE CHARACTERS WILL BE STOR\n         MVC       0(1,10),0(2)   PUTS FIRST CHARACTER INTO STORAGE\n         A         6,=F'1'        INCREASES STORAGE POINTER\n         A         5,=F'1'        INCREASES MEMORY POINTER\n         LA        2,1(2)         INCREASES INPUT POINTER\n         CLC       0(1,2),=X'7D'  CHECKS FOR QUOTE\n         BNE       DC5            IF NOT, RETURNS TO INSERT CHARACTER\n         B         DONE           IF SO, BRANCHES TO OUTPUT\nDC3      CLC       0(1,2),=C'F'   CHECKS FOR A \"F\"\n         BNE       OUTDC          IF NOT, BRANCHES TO PRINT ERROR.\n         LA        2,2(2)         IF SO, INCREASES INPUT PTR. PAST QUO\nDC6      IC        10,0(2)        PUTS FIRST CHARACTER IN REG. 10\n         LA        2,1(2)         INCREASES TO NEXT INPUT CHARACTER\n         CLC       0(1,2),=X'7D'  CHECKS FOR A QUOTE\n         BE        DC8            IF SO, BRANCHES TO INSERT IN MEMORY\n         SLL       10,4           IF NOT, MOVES VALUE IN 10 TO THE LEF\n*                                      T TO MAKE ROOM FOR NEXT CHARATR\n         B         DC6            BRANCHES TO INSERT NEXT CHARACTER\n*        THIS SECTION MAKES SURE LOC. CTR. IS ON FULL WORD BOUNDARY\nDC8      LR        6,5\n         SRL       5,2\n         SLL       5,2\n         CR        6,5\n         BE        DC7\n         A         5,=F'4'\n*                  GETS HERE WHEN LOCATION COUNTER IS SET\nDC7      ST        10,MEMORY(5)   PITS FULLWORD CONSTANT IN MEMORY\n         A         5,=F'4'        INCREASES LOCATION COUNTER\n         B         DONE           BRANCHES TO OUTPUT\nDS       CLC       0(2,2),R+32    CHECKS FOR DS STATEMENT\n         BNE       END            IF NOT, CHECKS FOR END STATEMENT\n         LA        2,2(2)         IF SO, INCREASES PAST OPCODE\nDS1      CLC       0(1,2),=C' '   CHECKS FOR OPERAND\n         BNE       OPCODS         BRANCHES WHEN FINDS OPERAND\n         LA        2,1(2)         IF NOT, INCREASE INPUT POINTER\n         B         DS1            RETURN TO CHECK FOR OPERAND\nOPCODS   CLC       0(1,2),=C'C'   CHECKS FOR A \"C\"\n         BNE       DS2            IF NOT, CHECKS FOR A \"F\"\n         A         5,=F'1'        IF SO, INCREASES LOC. CTR. FOR TYE C\n         B         DONE           BRAN HES TO OUTPUT\nDS2      CLC       0(1,2),=C'F'   CHECKS FOR A \"F\"\n         BNE       DS3            IF NOT, ASSUMES A VALUE\n         LR        6,5            IF SO, CHECKS LOC. CTR. FOR FULLWORD\n         SRL       5,2                 BOUNDARY\n         SLL       5,2\n         CR        6,5\n         BE        DS4\n         A         5,=F'4'\nDS4      A         5,=F'4'        INCREASES LOC. CTR. FOR THE \"F\"\n         B         DONE           BRANCHES TO OUTPUT\nDS3      IC        10,0(2)        PUT FIRST VALUE IN REG 10\n         LA        2,1(2)         INCREASES INPUT POINTER\n         CLC       0(1,2),=C'Z'   CHECKS TO SEE IF INPUT IS ANOTHER NO\n         BNH       DS5            IF NOT, BRANCHES TO CHECK FOR C &F\n         SLL       10,8\n         B         DS3            RETURNS TO INSERT VALUE\nDS5      CLC       0(1,2),=C'C'   CHECKS FOR A \"C\"\n         BNE       DS6            IF NOT, ASSUMES A \"F\"\n         ST        10,CHANGE      IF SO, WE CHANGE THE VALUE TO\n         XDECI     10,CHANGE           HEX FOR ADDING TO LOC. CTR.\n         AR        5,10           ADDS VALUE TO LOC. CTR.\n         B         DONE           BRANCHES TO OUTPTU\nDS6      LR        6,5            MAKES SURE LOC. CTR. IS ON FULLWORD\n         SRL       5,2            BOUNDARY FOR THE \"F\"\n         SLL       5,2\n         CR        6,5\n         BE        DS7\n         A         5,=F'4'\nDS7      ST        10,CHANGE      CHANGES THE VALUE TO HEX\n         XDECI     10,CHANGE           FOR ADDING TO THE LOC. CTR.\n         SLL       10,2           MULTIPLIES VALUE BY 4 SINCE IT IS\n*                                      THE NUMBER OF FULLWORDS\n         AR        5,10           ADDS VALUE TO THE LOC. CTR.\n         B         DONE           BRANCHES TO THE OUTPUT\nEND      B         FINISH\n*                  THIS PART FINISHES MACHINE CODE FOR ALL OPCODES\n*                                 EXCEPT READS, WRITES, DS, DC, END, B\n*                                 , AND YIELD.\nLOOKOPR  CLC       0(1,2),=C' '   CHECKS FOR OPERAND\n         BNE       OPR1           BRANCHES WHEN FINDS OPERAND\n         LA        2,1(2)         IF NOT, INCREASES INPUT POINTER\n         B         LOOKOPR        RETURNS TO CHECK FOR OPERAND\nOPR1     L         3,=V(LEGAL)\n         L         4,=V(LOCTN)\nOPR3     CLC       0(2,2),0(3)    CHECKS OPERAND WITH LABEL TABLE\n         BE        OPR2           IF EQUAL, BRANCHES TO INSERT LOCATIO\n         LA        3,2(3)         IF NOT, INCREASES TO NEXT LABEL\n         LA        4,4(4)         INCREASES TO NEXT LOCATION\n         B         OPR3           RETURNS TO COMPARE OPERAND\nOPR2     SLL       10,24          MOVES HEXOPCODE TO PROPER POSITION\n         LA        7,MEMORY(5)\n         ST        10,NUM\n         MVC       0(1,7),NUM\n         MVC       2(2,7),2(4)\n         MVC       1(1,7),=X'00'\n         A         5,=F'4'        INCREASES LOC. CTR. BY 4\n         B         DONE           BRANCHES TO OUTPUT\n*                  THIS PART FINISHES MACHINE CODE FOR READS AND WRITE\nLKOPRND  CLC       0(1,2),=C' '   CHECKS FOR OPERAND\n         BNE       LK1            BRANCHES WHEN FINDS OPERAND\n         LA        2,1(2)         IF NOT, INCREASES INPUT POINTER\n         B         LKOPRND        RETURNS TO CHECK FOR OPERAND\nLK1      L         3,=V(LEGAL)\n         L         4,=V(LOCTN)\nLK3      CLC       0(2,2),0(3)    CHECKS OPERAND WITH LABEL TABLE\n         BE        LK2            IF EQUAL, BRANCHES TO CHECK LENGTH\n         LA        3,2(3)         IF NOT, INCREASES TO NEXT LABEL\n         LA        4,4(4)         INCREASES TO NEXT LOACTION\n         B         LK3            RETURNS TO COMPARE OPERAND\nLK2      LA        2,3(2)         INCREASE INPUT POINTER TO LENGTH\nLK4      IC        7,0(2)         PUTS A NUMBER OF LENGTH INTO REG. 7\n         LA        2,1(2)         INCREASES TO NEXT VALUE OF LENGTH\n         CLC       0(1,2),=C' '   CHECKS TO SEE THAT THERE IS A VALUE\n         BE        LK5            IF NOT, BRANCHES TO FINISH MACHINE C\n         SLL       7,8\n         B         LK4            RETURNS TO INSERT THE VALUE\nLK5      ST        7,NUM+4\n         PACK      NUM2(8),NUM1+4(4)\n         L         7,NUM2+4\n         SRL       7,4\n         SLL       10,8\n         AR        10,7           PUTS LENGTH IN REG. 10\n         SLL       10,16          MOVES HEX OPCODE AND LENGTH TO MAKE\n*                                      ROOM FOR DISPLACEMENT\n         ST        10,MEMORY(5)   STORES MACHINE CODE IN MEMORY\n         LA       7,MEMORY(5)\n         MVC       1(1,7),=X'00'\n         MVC       2(2,7),2(4)\n         A         5,=F'4'        INCREASES LOC. CTR. BY 4\nDONE     LA        9,40(9)        INCREASES INPUT PTR. TO NEXT CARD\n         LA        2,0(9)         RESETS INPUT POINTER\n         B         UP2            RETURNS TO DO PASS2 ON NEXT CARD\nFINISH   XPRNT     CCT,59\n         XDUMP     MEMORY,2000    PRINTS THE MACHINE CODE.\n         L         13,SAVPAS2+4\n         LM        14,12,12(13)\n         BR        14\nOUTDC    XPRNT     CCC,33\n         B         DONE\nERROR    XPRNT     OCO,32\n         B         DONE\nSAVPAS2  DS        18F\nLA       DS        H\nLB       DS        H\nLC       DS        H\nBRNCH    DS        3H\nDFCNST   DS        33C\nR        DC        C'LDSTASMTDVGORD1RDWRT1WRTBYIELDDCDSEND'\nS        DC        X'4142515253541122213231131500'\nNUM      DS        F\nCHANGE   DS        F\nNUM1     DS        D\nNUM2     DS        D\nCCC      DC        C'0***ERROR***   -  ILLEGAL OPERAND'\nOCO      DC        C'0***ERROR***   -  ILLEGAL OPCODE'\n         LTORG\nCCT      DC        C'1THIS IS THE STORAGE FOR THE PROGRAM READ INTO '\n         DC        C'THE COMPILER'\n         DS        0F\nMEMORY   DC        2000X'EE'\n         END\n$ENTRY\n    RD1    M1\n   RD1  N1\n    WRT1    M1\n     WRT1 N1\n  LD  M1\n     S         N1\n    B  B1,B1,A1\nA1: LD M1\n  ST       T1\n LD N1\n      ST    M1\n  LD       T1\n    ST  N1\nB1:     LD  N1\n   DV   M1\n     MT     M1\n   ST  Q2\n    LD     N1\n   S Q2\n   B        B2,D1,B2\nB2:     ST    T2\n   LD M1\n   ST   N1\n       LD   T2\n                ST        M1\n       GO       B1\nD1: WRT M5,31\n       WRT1  M1\n YIELD\nM1:   DS   1F\nN1:    DS    1F\nT1: DS 2F\nT2:     DS     10F\nM5:    DC  C'THE GREATEST COMMON'\n     DC   C' DIVISOR IS:'\nQ2:   DC    F'0'\n                          END\n##\n$JOB   ASSIST  PROGTEST\n*        PSU CMPSC 102 - SUMMER 1970 - FINAL PROJECT\n*        *** THIRD IN SERIES OF RELATEC PROGRAMS.\n*        *** ILLUSTRATES SPEED DIFFERENCE IF PRINT TURNED OFF,\n*        *** COMPARE WITH PREVIOUS PROGRAM.\n*        *** ALSO ILLUSTRATES EXECUTION TIME ERROR.\n*        PRINTS ABOUT THREE PAGES OF OUPUT, EXECUTES 15394 INSTRU TS.\n*        THEN TERMINATES WITH 0C4 ERROR.\nMAIN     CSECT\n*      DOROTHY GRIFFITHS\n*    CS 102.1  TERM PROJECT\n         PRINT OFF\n         BALR      11,0\n         USING     BASE,11,12\nBASE     L         12,ADCON\n         ST        14,SAV14\n         SR        3,3\nRUN      XPRNT     =CL13'1THE INPUT IS',13\n         SR        2,2\nLOOP1    XREAD     INPUT1,80\n         XPRNT     CC1,81         PRINT OUT INPUT1\n         LA        9,INPUT1       PUT ADDRESS ON INPUT1 IN 9\n         LA        10,MEMO(2)     INPUT CONTAINS LABEL OF CARD READ\n         MVC       0(40,10),0(9)  MOVE THE INPUT INTO SRORAGE ARRAY\n         LA        2,40(2)        INCREASE INDEX TO MEMO\n         CLC       INPUT1(2),=C'##' TEST IF LAST CARD WAS READ\n         BNE       LOOP1          START READING A NEW DATA CARD\n         LA        1,JOBADD       PUT ADDRESS OF ARRAYS TO BE MOVED\n         L         15,=V(PASS1)   PUT ENTRANCE POINT IN 15\n         LA        13,SAVMAIN     PUT ADDRESS OF SAVE AREA IN 13\n         BALR      14,15          BRANCK\n         LA        1,JOBADD\n         L         15,=V(PASS2)\n         BALR      14,15\n         XDUMP     OPTAB,1000\n         LA        3,1(3)\n         C         3,=F'3'\n         BE        COMPLET\n         MVI       TABLE,X'00'\n         MVC       TABLE+1(200),TABLE\n         MVI       OPTAB,X'EE'\n         MVC       OPTAB+1(240),OPTAB\n         B         RUN\nCOMPLET  L         14,SAV14\n         BR        14\nSAV14    DS        F\nADCON    DC        A(BASE+4096)\nMEMO     DC        2000X'EE'\nTABLE    DC        100H'0'\nADTAB    DS        100F\n         DS        3C\nCC1      DC        C'0'\nINPUT1   DS        80C\nJOBADD   DC        A(MEMO)\n         DC        A(ADTAB)\n         DC        A(TABLE)\n         DC        A(OPTAB)\nOPTAB    DC        2000X'EE'\nSAVMAIN  DS        18F\n         LTORG\nPASS1    CSECT\n         STM       14,12,12(13)\n         BALR      11,0\n         USING     BASE1,11,12\nBASE1    L         12,ADCON1\n         ST        13,SAVPAS1+4\n         LM        2,5,0(1)\n        SR    9,9\n        ST    9,LOC\nTOP      MVC       INPUT(40),0(2) PUT MEMO IN HERE TO COMPARE IT\n         CLC       INPUT(2),=C'##' TEST IF PASS ONE IS FINISHES\n         BE        OUT            START PASS 2 IF 1 IS FINISHED\n         CLI       INPUT,C' '     CHECK IF THERE IS A LABEL\n         BE        OPER           IF NOT CHECK OPERATOR\n         CLI       INPUT,C'A'     CHECK IF FIRST VALUE IS LESS THANA\n         BL        ILABLE         IF SO GO TO ILLEGAL TABLE\n         CLI       INPUT,C'Z'     CHECK IF FIRST VALUE GREATER THAN Z\n         BH        ILABLE         IF SO GO TO ILT\n         CLI       INPUT+1,C'1'   CHECK SECOND CHARACTER IN STRING\n*                                 AGAINST 1\n         BL        ILABLE         IF LESS THAN 1 PUT IN ILT\n         CLI       INPUT+1,C'9'   CHECK SECOND CHARACTER IN STRING\n*                                 AGAINST 9\n         BH        ILABLE         IF GREATER PUT IN ILT\n         CLC       INPUT+2(2),CODE CHECK LAST 2 CHARACTERS AGAINST:\n*                                 AND A BLANK\n         BNE       ILABLE         IF NOT EQUAL PUT IN ILT\n*                                 BE MOVED TO THE TABLE\n         LR        6,4            PUT LOCATION OF TABLE IN REG 6\nLOOP2    CLC       INPUT(2),0(6)  SEE IF THE LABLE ON CARD IS IN TABLE\n         BE        ILABLE         IF IT IS IT IS AN ILLEGAL LABLE\n         CLC       0(2,6),=X'0000'  TEST IF THIS IS THE RIGHT SPOT\n         BE        RECORD         IF IT IS STORE IT\n         LA        6,2(6)         INCREASE TO NEXT SPOT ON TABLE\n         B         LOOP2          NOW GO THROUGH THE TEST AGAIN\nRECORD   MVC       0(2,6),INPUT\n         L         9,LOC          THIS STORES DEC NUM IN ADTAB\n         CVD       9,SPACE        CHANGE THE NUMBER TO  A DEC NUMBER\n         UNPK      DOUBLE(8),SPACE+4(4) TEMPERARY FOR PRINT OUT\n         OI        DOUBLE+7,X'F0' GET RID OF THE SIGN\n         XPRNT     CARG,41\n         XPRNT     DOUBLE,8\n         L         9,SPACE+4      PUT THE DEC VALUE IN REG 9\n         SRL       9,4            SHIFT OFF SIGN BITS\n         ST        9,SPACE        PUT JUST THE DEC NUM IN SPACE\n         MVC       0(4,3),SPACE\n         LA        3,4(3)         INCREASE TO NEXT SPOT IN ADTAB\nOPER     SR        10,10          REG 10 WILL BE USED AS A POINTER\n*                                 TO INPUT\nJUMP     LA        9,INPUT(10)\n         CLI       0(9),C' '   SEE WHERE ROW OF BLANKS END\n         BE        FOUND          IF SO GO TO FIND OPERATOR\n         LA        10,1(10)       INCREASE TO NEXT COLUMN\n         B         JUMP           TEST FOR SECOND BLANK\nFOUND    CLI       0(9),C' '      SEE IF FIRST BLANK HAS BEEN READ\n         BNE       OPERAND\n         LA        10,1(10)\n         LA        9,INPUT(10)    COMPARE NEXT COLUMN\n         B         FOUND          COMPARE NEXT COLUMN\nILABLE   XPRNT     CARG,40        PRINT IT OUT\n         XPRNT     =CL14' ILLEGAL LABEL',14\n         B         INC            EXIT ON THIS CARD\nOPERAND  CLI       0(9),C'B'\n         BNE       CON            IF NOT GO TO CONTINUE TO CHECK\n         L         8,LOC          INCREASE LOCATION COUNTER BY 6 IF IT\n         LA        8,6(8)         INCREASE LOC COUNTER BY 6\n         ST        8,LOC\n         B         INC            GO TO NEXT INPUT\nCON      CLC       0(5,9),=C'YIELD' SEE IF IT IS A YIELD STATEMENT\n         BNE       CON1           GO TO SEE IF IT IS A DS\n         L         8,LOC          ADD 2 TO LOCATION COUNTER FOR YIELD\n         LA        8,2(8)         INCREASE LOC COUNTER BY 2\n         ST        8,LOC\n         B         INC            GO TO NEXT INPUT\nCON1     CLC       0(2,9),=C'DS'  TEST IF  IT IS  A DS STATEMENT\n         BNE       CHAR           IF NOT GO TO SEE IF IT IS A DC\n         LA        10,2(10)       IF IT IS THEN INCREASE LOCATION\n*                                 COUNTER PAST DS\n         XDECI     7,INPUT(10)    CONVERT TO HEX THE DUP FACTOR\nCIRC     LA        9,INPUT(10)    PUT LOCATION ON CARD IN REG 9\n         CLI       0(9),C'F'      TEST IF IT IS A FULLWORD INST\n         BE        FULWORD        IF IT IS THEN THIS WAS A FULLWORD\n         CLI       0(9),C'C'\n         BE        SYMBOL         BRANCH TO CHARACTER LOOP\n         LA        10,1(10)       INCREASE TO NEXT COLUMN ON CARD\n         B         CIRC\nFULWORD  C         7,=F'0'        SEE IF THERE WAS NO DUP FACTOR\n         BNE       FIN            IF THERE WAS JUST BRANCH\n         LA        7,1(7)         ADD 1 TO REG 7 TO MULT IDENTITY\nFIN      L         8,LOC          THIS LOOP INCREASES LOCATION COUNTER\n*                                 BY 4 TIMES THE DUP FACTOR\n         LR        6,8            THIS TEST IF LOCATION IS ON A FULLWOR\n*                                 BOUNDARY\n         SRL       8,2            FILL IT WITH ZEROES\n         SLL       8,2            MOVE OFF LAST BYTE\n         CR        6,8            TEST IF THEY ARE THE SAME\n         BE        DIV\n         LA        8,4(8)         PUT IN NUMBER DIVISABLE BY FOUR\nDIV      SLA       7,2       MULTIPLY 7 BY FOUR\n         AR        8,7\n         ST        8,LOC\n         B         INC            GO ON TO NEXT INPUT\nSYMBOL   C         7,=F'0'        TEST IF THERE WAS A DUP FACTOR\n         BNE       MORE           IF SO JUST GO ON\n         LA        7,1(7)         ADD MULT IDENTITY TO REG 7\nMORE     L         8,LOC          THIS LOOP INCREASES LOCATION COUNTER\n*                                 BY DUP FACTOR FOR DS\n         AR        8,7\n         ST        8,LOC\n         B         INC            GO ON TO NEXT CARD\nCHAR     CLC       0(2,9),=C'DC'  TEST IF IT IS A DC STATEMENT\n         BE        CONST          BRANCH IF IT IS\n         L         8,LOC          THIS LOOP ADDS FOUR ON TO LOCATION\n*                                 FOR ALL OPERATORS EXCEPT THOSE ABOVE\n         LA        8,4(8)\n         ST        8,LOC\nINC      LA        2,40(2)        INCREASE TO NEXT LOCATION IN MEMO\n         B         TOP            GO DO THE NEXT ONE\nCONST    LA        10,2(10)       INCREASE LOCATION COUNTER\n         XDECI     7,INPUT(10)    PUT DUP FACTOR IN REG 10\nRETURN   LA        9,INPUT(10)    PUT NEW ADDRESS IN REG 9\n         CLI       0(9),C'F'      TEST FOR A FULL WORD\n         BE        FULWORD        BRANCH IF SO\n         CLI       0(9),C'C'      TEST FOR A CHARACTER\n         BE        LETTER         BRANCH IF SO\n         LA        10,1(10)       INCREASE TO NEXT COLUMN\n         B         RETURN         GO COMPARE NEW COLUMN\nLETTER   CLI       0(9),C''''\n         BE        COUNT\n         LA        10,1(10)       INCREASE TO NEXT COLUMN\n         LA        9,INPUT(10)    PUT NEW LOCATION IN 9\n         B         LETTER         GO TO TEST NEXT COLUMN\nCOUNT    SR        8,8            REG 8 WILL CONTAIN # OF BYTEX TO LEAV\nADD      LA        8,1(8)         INCREASE COUNTER\n         LA        10,1(10)       INCREASE TO NEXT POSITION ON CARD\n         LA        9,INPUT(10)    PUT NEW LOCATION IN 9\n         CLI       0(9),C''''\n         BNE       ADD            BRANCH TO FIND FAST '\n         SR        6,6            REG 6 USED IN MULTIPLICATION\n         MR        6,8            MULTIPLY REG 7 TIMES 8\n         A         7,LOC\n         ST        7,LOC\n         B         INC\nOUT      L         13,SAVPAS1+4\n         LM        14,12,12(13)\n         BR        14\nSAVPAS1  DS        18F\nADCON1   DC        A(BASE1+4096)\nCARG     DC        C'0'\nINPUT    DS        40C\nLOC      DC        F'0'\nSPACE    DS        D\nDOUBLE   DS        D\nCODE     DC        C': '\n         LTORG\nPASS2    CSECT\n         STM       14,12,12(13)\n         BALR      11,0\n         USING     BASE2,11,12\nBASE2    L         12,ADCON2\n         ST        13,SAVPAS2+4\n         LM        2,5,0(1)\n        SR    9,9\n         ST    9,COUNTER\nSTART    LR        7,2            REG 7 WILL BE POSITION IN MEMO\nWHERE    CLI       0(7),C' '\n         BE        FIND           IF FOUND GO TO CHECK NEXT ONE\n         LA        7,1(7)         IF NOT BLANK INCREASE POINTER\n         B         WHERE          BRANCH TO CHECK IT OUT\nFIND     CLI       0(7),C' '\n         BNE       OPC            IF NOT YOU ARE AT THE OPERAND\n         LA        7,1(7)         INCREASE POINTER\n         B         FIND           GO TO CHECK THIS SPACE\nOPC      LA        6,CARD         PUT ADDRESS OF CARD IN 6\n         MVC       0(5,6),=C'     ' MOVE ALL BLANKS INTO CARD TO TEST\nCHECK    CLI       0(7),C'A'      SEE IF THIS IS A LETTER\n         BL        EXIT           TOTAL OPERATER IN CARD THEN BRANCH\n         CLI       0(7),C'Z'      SEE IF IT IS A LTTTER\n         BH        EXIT           TOTAL OPERATOR IN CARD THEN BRANCH\n         MVC       0(1,6),0(7)    PUT THE OPERATOR IN CARD\n         A         7,=F'1'        INCREASE POINTER IN CARD\n         A         6,=F'1'        INCREASE TO NEXT BYTE IN CARD\n         B         CHECK          GO BACK TO COMPARE NEXT COLUMN\nEXIT     SR        10,10          REG 10 IS INDEX TO OPERATE\n         MVC       0(1,6),0(7)    MOVE INTO LAST SPOT\n         LA        8,OPERATE      PUT LOCATION OF OPERATOR IN 8\n         LA        6,CARD         PUT ODD OF CARD IN REG 6\n         CLC       0(5,6),=C'END  '\n         BNE       THERE\n         MVC       STOR(40),0(2)  IF IT IS A N END STATE PRINT OUT\n         XPRNT     CC4,66\n         B         PAS2END\nTHERE    CLC       0(5,6),=C'DC   '\n         BE        DC\n         CLC       0(5,6),=C'DS   '\n         BE        DS\nCOMPARE  CLC       0(5,6),0(8)    SEE IF CARD IS SAME AS OPCODE\n         BE        NUMBER         IF SO BRANCH\n         LA        8,5(8)         INCREASE INDEX TO OPERATE\n         LA        10,1(10)\n         B         COMPARE\nNUMBER   LA        6,OPCODE(10)   PUT ADDRESS OF OPERATOR IN 6\n         MVC       0(1,5),0(6)    MOVE INTO CORRECT SPOT IN OBTAB\n         LA        6,CARD\n         CLC       0(5,6),=C'YIELD'\n         BNE       TEST           IF NOT CONTINUE TESTING\n         L         8,COUNTER      PUT THE PRES LOCATION IN 8\n         CVD       8,TWIN         PUT THE DECIMAL VALUE TO BE PRINTED\n         L         10,TWIN+4      THIS IS TO GET RID OF THE SIGN NIBBLE\n         ST        10,TEMP        PUT HERE TO GET READY TO UNPACK\n         UNPK      TWIN(8),TEMP(4) PUT IN A FORM TO BE PRINTED OUT\n         OI        TWIN+7,X'F0'   TEST TO GET SIGN OF F\n         XPRNT     CC2,9\n         MVC       STOR(40),0(2)  PUT INSTRUCTION IS STOR\n         XPRNT     CC4,66\n         LA        8,2(8)         ADD IN 8 2 FOR YIELD\n         ST        8,COUNTER      PUT NEXT LOCAT&ON &NTO COUNTER\n         MVC       1(1,5),=X'00'\n         LA        5,2(5)\n         B         FINISH\nTEST     CLC       0(5,6),=C'B    '\n         BNE       NBRANCH\nLOCATE   CLI       0(7),C' '\n         BE        BLANK\n         LA        7,1(7)         INCREASE TO NEXT COLUMN\n         B         LOCATE         GO CHECK NEXT COLUMN FOR BLANK\nBLANK    CLI       0(7),C' '\n         BNE       ADLAB\n         LA        7,1(7)         INCREASE TO NEXT BYTE\n         B         BLANK\nADLAB    LR        8,4            PUT TABLE ASDRESS IN REG 8\n         LR        9,3            PUT IN ADDREAS OF ADTAB\nCIRCLE   CLC       0(2,7),0(8)    TEST IF RIGHT LABLE IN TABLE\n         BE        RIGHT          RRANCH IF IT IS\n         LA        8,2(8)         INCREASE INDEX TO TABLE\n         LA        9,4(9)         INCREASE INDEX TO ADTAB\n         B         CIRCLE         BRANCH TO CHECK AGAIN\nRIGHT    MVC       TEMP(4),0(9)   PUT ADDRESS OF LABLE IN TEMP\n         SR        10,10          REG 10 IS COUNTER FOR BYTE POSITION\n         LA        5,1(5)         INCREASE INDEX TO APATB\n         MVC       0(2,5),TEMP+2\n         LA        5,2(5)         INCRAASE INDEX TO OPTAB\n         LA        6,TEMP\nSECOND   LA        7,3(7)         INCREASE COLUMN POINTER\n         LR        8,4            PUT ADDRESS OF TABLE IN 8\n         LR        9,3            PUT ADDRESS OF ADTAB IN 9\nAGAIN    CLC       0(2,7),0(8)    SEE IF IT IS THE RIGHT LABLE\n         BE        EXACT\n         LA        8,2(8)         INCREASE INDEX TO TABLE\n         LA        9,4(9)         INCREASE INDEX TO ADTAB\n         B         AGAIN\nEXACT    MVC       0(2,6),2(9)    PUT ADDRESS IN TEMP\n         LA        6,2(6)         INCREASE TO FOURTH BYTE OF TEMP\n         LA        10,1(10)       INCREASE TO NEXT POSITION\n         C         10,=F'2'       IF 2 BYTES HAVE BEEN LOADED WE ASE\n*                                 THROUGH\n         BNE       SECOND\n         LH        8,TEMP         PUT FIRST LOCATION IN 8\n         LH        9,TEMP+2       SECOND LOCATION IN 9\n         SLL       9,20           KNOCK OFF FIRST 20 BYTES\n         SLDL      8,12           MOVE IT OVER\n         ST        8,TEMP\n         MVC       0(3,5),TEMP+1  STORE IN APTAB\n         LA        5,3(5)         INCREASE INDEX TO OPTAB\n         LR        6,5            PUT NEW ADDRESS OF OPTAB IN 6\n         S         6,=F'6'        SUBTRACT 6 TO GET TO FIRST BYTE\n         L         8,COUNTER      PUT THE PRES LOCATION IN 8\n         CVD       8,TWIN         PUT THE DECIMAL VALUE TO BE PRINTED\n         L         10,TWIN+4      THIS IS TO GET RID OF THE SIGN NIBBLE\n         ST        10,TEMP        PUT HERE TO GET READY TO UNPACK\n         UNPK      TWIN(8),TEMP(4) PUT IN A FORM TO BE PRINTED OUT\n         OI        TWIN+7,X'F0'   TEST TO GET SIGN OF F\n         XPRNT     CC2,9\n         MVC       STOR(40),0(2)  MOVE INPUT INTO SROR\n         XPRNT     CC4,66\n         LA        8,6(8)         ADD 6 FOR A BRANCH\n         ST        8,COUNTER      PUT NEXT LOCATION INTO COUNTER\n         B         FINISH\nDS       MVC       STOR(40),0(2)  PUT INSTRUCTION IN STORE\n         L         8,COUNTER      PUT THE PRES LOCATION IN 8\n         XDECI     6,0(7)         TEST FOR DUP FACTOR\n         LA        9,STOR+4\n         C         6,=F'0'        IF NO DUP FACTOR PUT MULTIPLICATION\n*                                 IDENTIFIER IN IT\n         BNE       OUTPUT\n         LA        6,1(6)\nOUTPUT   CVD       8,TWIN              PREPARE TO BE PRINTED AS DECIMAL\n         L         10,TWIN+4      THIS IS TO GET RID OF THE SIGN NIBBLE\n         ST        10,TEMP        PUT HERE TO GET READY TO UNPACK\n         UNPK      TWIN(8),TEMP(4) PUT IN A FORM TO BE PRINTED OUT\n         OI        TWIN+7,X'F0'   TEST TO GET SIGN OF F\n         XPRNT     CC2,9\n         XPRNT     CC4,66\nFUN      CLI       0(9),C'F'\n         BE        YES\n         CLI       0(9),C'C'\n         BE        YEA\n         LA        9,1(9)\n         B         FUN\nYES      LR        9,6\n         M         8,=F'4'\n         L         8,COUNTER      PUT THE PRES LOCATION IN 8\n         AR        8,9\n         ST        8,COUNTER\n         AR        5,9\n         B         FINISH\nYEA      LR        8,6\n         AR        5,6            ADD DUP FACTOR TO INDEX OF OPTAB\n         L         8,COUNTER\n         AR        8,6\n         ST        8,COUNTER\n         B         FINISH\nNBRANCH  CLC       0(5,6),=C'RD   '\n         BNE       WRITE\n         LA        7,2(7)         INCREASE POINTER TO COLUMN\nSAME     CLI       0(7),C' '\n         BE        ORBIT\n         LA        7,1(7)         INCREASE POINTER TO MEMO\n         B         SAME\nORBIT    LA        7,1(7)         INCREASE POINTER\n         CLI       0(7),C' '\n         BE        ORBIT\n         LR        8,4            PUT ADDRESS OF TABLE IN 8\n         LR        9,3            PUT ADDRESS OF ADTAB IN 9\nTURN     CLC       0(2,7),0(8)    TEST IF THIS IS RIGHT LABLE\n         BE        CORRECT\n         LA        8,2(8)         INCREASE TO NEXT LABLE\n         LA        9,4(9)         INCREASE TO NEXT ADDRESS\n         B         TURN\nCORRECT  LR        6,5            PUT THE ADDRESS OF OBTAB IN 6\n         LA        7,3(7)         INCREASE POINTER\n         LA        6,1(6)         INCREASE INDEX TO OBTAB\n         MVC       0(2,6),0(7)    MOVE LENGHT TO OBTAB\n         LA        6,1(6)         INCREASE INDEX TO OBTAB\n         MVC       0(2,6),0(9)    MOVE LOCATION IN LAST 3 BYTES\n         MVC       STOR(40),0(2)  PUT INSTRUCTION IN STORE\n         L         8,COUNTER      PUT THE PRES LOCATION IN 8\n         CVD       8,TWIN         PUT THE DECIMAL VALUE TO BE PRINTED\n         L         10,TWIN+4      THIS IS TO GET RID OF THE SIGN NIBBLE\n         ST        10,TEMP        PUT HERE TO GET READY TO UNPACK\n         UNPK      TWIN(8),TEMP(4) PUT IN A FORM TO BE PRINTED OUT\n         OI        TWIN+7,X'F0'   TEST TO GET SIGN OF F\n         XPRNT     CC2,9\n         XPRNT     CC4,66\n         LA        8,4(8)         ADD 4 FOR ALL OTHERS\n         ST        8,COUNTER\n         LA        5,4(5)         INCREASE TO NEXT OPTAB LOCATION\n         B         FINISH\nWRITE    CLC       0(5,6),=C'WRT  '\n         BE        SAME           THE WRT IS ASSEMBLED LIKE RD\n         B         LEAVE\nDC       LA        7,2(7)\n         MVC       STOR(40),0(2)  MOVE INSTRUCTION INTO STORE\n         CVD       8,TWIN         PUT THE DECIMAL VALUE TO BE PRINTED\n         L         10,TWIN+4      THIS IS TO GET RID OF THE SIGN NIBBLE\n         ST        10,TEMP        PUT HERE TO GET READY TO UNPACK\n         UNPK      TWIN(8),TEMP(4) PUT IN A FORM TO BE PRINTED OUT\n         OI        TWIN+7,X'F0'   TEST TO GET SIGN OF F\n         XPRNT     CC2,9\n         XPRNT     CC4,66\n         ST        10,TWIN+4      PUT THE LOCATION BACK IN TWIN\n         XDECI     6,0(7)         CONVERT THE DUP FACTOR INTO HEX\n         LA        9,STOR+4       PUT THE ADDRESS OF STORE IN REG 9\n         C         6,=F'0'        SEE IF DUP FACTOR WAS 0\n         BNE       WHAT           IF NOT BRANCH AROUND\n         A         6,=F'1' PUT MULT IDENTITY IN REG 6\nWHAT     CLI       0(9),C'F'\n         BE        F              IF SO BRANCH\n         CLI       0(9),C'C'\n         BE        C              IF SO BRANCH\n         LA        9,1(9)         ADD 1 TO MOVE TO NEXT COLUMN IN STOR\n         B         WHAT           TEST THIS COLUMN\nF        LA        9,2(9)         ADD 2 TO GET PAST THE F\n         LA        8,TEMP         TEMP WILL HOLD NUMBER TO BE STORED\n         L         7,COUNTER\n         LR      10,7        THIS IS TO TEST IF IT IS ON A FULL W BOUND\n         SRL       7,2            MOVE OVER TO LOWEST MULT OF 4\n         SLL       7,2            MOVE BACK TO RIGHT SPOT\n         CR        10,7           TEST IFA THE VALUE HAS CHANGED\n         BE        PUT            IF NOT IT IS A MULTIPLE\n         LA        7,4(7)\nPUT      MVC       0(1,8),0(9)\n         LA        8,1(8)         INCREASE INDEV TO TEMP\n         LA        9,1(9)         INCREASE POINTER OF COLUMN\n         CLI       0(9),C''''\n         BNE       PUT\n         MVC       0(4,5),=X'00000000'\n         L         8,TEMP         PUT CHARACTER IN 8\n         LR        10,8           SEE IF IT IS IN THE LAST BYTE YET\nGEE      SRL       8,8\n         SLL       8,8\n         CR        10,8\n         BNE       OK\n         SRL       8,8\n         B         GEE\nOK       ST        8,TEMP\n         MVC       0(4,5),TEMP    MOVE IT INTO OPTAB\n         LA        5,4(5)         INCREASE INDEX TO OPTAB\n         LA        7,4(7)         INCREASE COUNTER BY 4\n         BCT       6,PUT          TEST IF DUP FACTOR IS DNOE DUP\n         ST        7,COUNTER      PUT LOCATION BACK IN COUNTER\nPRIN     LA        5,1(5)         INCREASE POINTER TO OPTAB\n         B         FINISH\nC        LA        9,2(9)         GO PAST THE C'\n         LA        8,9            PUT ORIGINAL LOCATION IN 8\nLOOK     MVC       0(1,5),0(9)    MOVE FIRST MUMBER INTO OPTAB\n         LA        5,1(5)         INCREASE INDEX TO OPTAB\n         CLI       0(9),C''''\n         BE        DUN            IF SO BRANCH\n         LA        9,1(9)         GO TO NEXT COLUMN\n         B         LOOK           BRANCH TO MOVE IT\nDUN      CLC       0(4,6),=F'0'   DEE IF THERE WAS A DUP FACTOR\n         BNE       PRIN           IF NOT GO TO PRIN\n         LR        9,8            PUT ORIGINAL INST PLACE IN REG 9\n         BCT       6,GEE\n         B         PRIN           BRANCH TO PRIN IF IT IS\nLEAVE    CLI       0(7),C' '\n         BE        LAB            IF BLANK IS FOUND TAKE BRANCH\n         LA        7,1(7)\n         B         LEAVE\nLAB      LA        7,1(7)         INCREASE INDEX TO MEMO\n         CLI       0(7),C' '\n         BE        LAB\n         SR        9,9            REG 9 WILL BE USED AS LOCATION TO AD\n         LR        6,4            REG 6 CONTAINS ADDRESS OF TABLE\nHERE     CLC       0(2,7),0(6)    SEE IF THIS IS REGHT LABLE\n         BE        LOCATON        IF SO BRANCH TO LOCATON\n         LA        9,4(9)         INCREASE INDEX TO ADTAB\n         LA        6,2(6)         INCREASE INDEX TO TABLE\n         B         HERE\nLOCATON  AR        9,3            ADDRESS TO CORRECT SPOT IN ADTAB\n         L         8,COUNTER      PUT THE PRES LOCATION IN 8\n         MVC       STOR(40),0(2)\n         CVD       8,TWIN\n         L         10,TWIN+4      THIS IS TO GET RID OF THE SIGN NIBBLE\n         ST        10,TEMP        PUT HERE TO GET READY TO UNPACK\n         UNPK      TWIN(8),TEMP(4) PUT IN A FORM TO BE PRINTED OUT\n         OI        TWIN+7,X'F0'   TEST TO GET SIGN OF F\n         XPRNT     CC2,9\n         XPRNT     CC4,66\n         LA        8,4(8)         ADD 4 FOR ADD OTHERS\n         ST        8,COUNTER\n         LA        5,1(5)         INCREASE INDEX TO ABTAB\n         MVC       CARD(4),0(9)   PUT IT INTO CARD TO BE STORED AND\n*                                 PRINTED OUT\n         MVC       0(3,5),CARD+1\n         LA        5,3(5)         ADD TO GET TO THE END OF THE OBTAB\nFINISH   LA        2,40(2)        ADD 40 TO NEXT SPOT IN MEMO\n         B         START          GO TO BEGINNING\nPAS2END  L         13,SAVPAS2+4\n         LM        14,12,12(13)\n         BR        14\nSAVPAS2  DS        18F\nADCON2   DC        A(BASE2+4096)\nCC3      DC        C'      '\nCARD     DC        5C' '\n         DS        1C\nTEMP     DS        F\n         DS        0D\n         DS        15C\nCC2      DC        C' '\nTWIN     DS        D\nCOUNTER  DC        F'0'\nCC4      DC        C'+'\n         DC        29C' '\nSTOR     DS        40C\nOPERATE  DC        C'RD   RD1  WRT  WRT1 LD   ST   A    S    MT   DV  '\n         DC        C' GO   B    YIELD'\nOPCODE   DC        X'21223132414251525354111315'\n         LTORG\n         PRINT ON\n         END\n$ENTRY\n         RD        H1,60\n         WRT       H1,60\n         RD        H2,25\nU2:      RD1       A1\n         LD        A1\n         B         U9,U3,U3\nU3:      RD1       B1\n         RD1       C1\n         WRT       H2,25\n         WRT1      A1\n         WRT1      B1\n         WRT1      C1\n         GO        U4\nA1:      DS        F\nB1:      DS        F\nC1:      DS        F\nU4:      MT        C1\n         MT        F1\n         ST        Z1\n         LD        B1\n         MT        B1\n         S         Z1\n         B         L1,L2,L3\nL1:      WRT       M1,13\n         GO        U2\nU9:      YIELD\nL2:      LD        A1\n         MT        T1\n         ST        Z2\n         LD        B1\n         S         B1\n         S         B1\n         DV        Z2\n         ST        X1\n         WRT       M2,14\n         WRT1      X1\n         GO        U2\nL3:      WRT       M3,20\n         GO        U2\nZ1:      DC        1F'0'\nH1:      DS        45C\nH2:      DS        25C\nT1:      DC        1F'2'\nF1:      DC        F'4'\nZ2:      DS        6C\n         DC        1F'0'\nM1:      DC        C'NO REAL ROOTS'\nM2:      DC        C'A DOUBLE ROOT:'\nM3:      DC        C'TWO REAL ROOTS EXIST'\nX1:      DC        1F'-1'\n                                 END\n##\n   RD      A1,1\n   WRT    A1,1\n          RD1    A2\n    WRT1             A2\n    RD1    A3\n     RD1    A4\nA5:  LD      A1\n      A  A1\n  ST  A1\n    S   A2\n   MT   A1\n    DV  A3\n GO A4\nA4:  S A3\n     B     A4,A5,A4\n        YIELD\nA1:      DS        1C\nA2:      DS        3C\nA3:      DC        1F'0'\nA4:      DC        1F'1'\n                                END\n##\n    RD1    M1\n   RD1  N1\n    WRT1    M1\n     WRT1 N1\n  LD  M1\n     S         N1\n    B  B1,B1,A1\nA1: LD M1\n  ST       T1\n LD N1\n      ST    M1\n  LD       T1\n    ST  N1\nB1:     LD  N1\n   DV   M1\n     MT     M1\n   ST  Q2\n    LD     N1\n   S Q2\n   B        B2,D1,B2\nB2:     ST    T2\n   LD M1\n   ST   N1\n       LD   T2\n                ST        M1\n       GO       B1\nD1: WRT M5,31\n       WRT1  M1\n YIELD\nM1:   DS   1F\nN1:    DS    1F\nT1: DS 2F\nT2:     DS     10F\nM5:    DC 1C'THE GREATEST COMMON'\n     DC  1C' DIVISOR IS:'\nQ2:   DC   1F'0'\n                          END\n##\n$JOB   ASSIST  PROGTEST\n         TITLE   'FIRST PASS'\n*        *** SAMPLE FINAL PROJECT - 1ST ASSEMBLER LANGUAGE COURSE.\n*        460+ STATEMENTS, , APPROX 150 INPUT DATA CARDS,\n*        USER PROGRAM PRINTS 4 PAGES OF OUTPUT, EXECUTES 10411\n*        INSTRUCTIONS, THEN RETURNS NORMALLY.\n*        CMPSC 410.1 - FALL 1970 - PSU-INSTRUCTOR -C.HUGHES.\nTOPAL    CSECT\n         B       10(,15)\n         DC      X'05'\n         DC      CL5'TOPAL'\n         STM     14,12,12(13)\n         BALR    12,0\n         USING   *,12\n         ST      13,SAVE\n         XREAD   CARD,32           READ CARD\n         BNM     JOB\n         XPRNT   =CL29'0ALL JOBS HAVE BEEN PROCESSED',29\n         L       13,SAVE\n         LM      14,15,12(13)\n         LM      2,12,28(13)\n         MVI     12(13),X'FF'\n         BR      14\nJOB      CLC     CARD(2),=C'$$'    IS IT A JOB CARD?\n         BE      ID\n         XPRNT   =CL44'1****JOB CARD MISSING***********************',44\nID       XPRNT   =CL1'1',1         CC TO NEXT PAGE\n         MVC     IMAGE(32),CARD\n         XPRNT   CC2,33\n*\n* SET POINTERS AND LOCATION COUMTERS AND SET UP DSECT ADDRESSABILITY\n*\n         L       10,=V(CDEA)       LOAD ADDRESS OF CODE AREA\nCRDL     EQU     2                 CARD AREA L C\nCDEL     EQU     4                 CODE AREA L C\nSYTL     EQU     3                 SYMBOL TABLE L C\n         L       CRDL,=V(CRD)      LOAD ADDRESS OF CARD IMAGE AREA\n         L       CDEL,=V(CDEA)     LOAD ADDRESS OF CODE AREA\n         L       SYTL,=V(SYT)      LOAD ADDRESS OF SYMBOL TABLE\n         USING   SYTFORM,SYTL\n         USING   CRDFORM,CRDL\n*\n* ZERO OUT SYMBOL AREA\n*\n         LM      5,9,AREA2\n         LA      0,20\n         LA      1,480\n         SR      11,11\nLOOP1    STM     5,9,0(SYTL)\n         LA      SYTL,20(SYTL)\n         BXLE    11,0,LOOP1\n*\n* ZERO OUT CODE AREA\n*\n         LA      1,780\n         SR      11,11\nLOOP2    STM     5,9,0(CDEL)\n         LA      CDEL,20(CDEL)\n         BXLE    11,0,LOOP2\n* RESET LOCATION COUNTERS\n         L       SYTL,=V(SYT)\n         L       CDEL,=V(CDEA)\n         MVC     EX,TRUE           ALLOW EXECUTION\n         B       READ2\nREAD     LA      CRDL,32(CRDL)     UP DATE CARD AREA L C\nREAD2    XREAD   CARD,32\n*\n* BUILD CARD IMAGE TABLE\n*\n         MVC     0(32,CRDL),CARD   STORE CARD IN CARD TABLE\n         CLI     CARD,C'*'\n         BE      READ              BRANCH TO READ NEXT CARD\n         MVI     FLAG,X'00'\n         CLC     CARD+9(3),=C'END'\n         BE      PASS2             BRANCH TO SECOND PASS\n*\n* BUILD  SYMBOL  TABLE\n*\n         CLI     CARD,C' '         IS THERE A  LABEL?\n         BE      PROCESS\n         L       SYTL,=V(SYT)\nCOMP     CLC     CARD(8),SYMBOL    COMPARE WITH SYMBOL TABLE\n         BNE     ZERO\n         MVC     EX,FALSE          SET NO EXECUTE FLAG\n         OI      FLAG,X'80'        PUT ERROR FLAG IN CARD AREA\n         B       DCON\nZERO     CLI     SYMBOL,X'0'       CHECK FOR END OF SYMBOL TAVLE\n         BE      STORE\n         LA      SYTL,10(SYTL)     INCREMENT SYMBOL TABLE\n         B       COMP\nSTORE    MVC     SYMBOL(8),CARD\n*\n* PROCESS DCON CARDS\n*\nDCON     CLC     CARD+9(4),=C'DCON'   IS IT A DCON CARD\n         BNE     NODCON               FIND DCON CARD\n* ALIGN CODE LOCATION COUNTER TO FULL WORD BOUNDARY\n         LCR     9,CDEL\n         N       9,=X'00000003'\n         AR      CDEL,9\n         XDECI   5,CARD+14         CONVERT TO BINARY\n         ST      5,0(CDEL)         STORE DCON NUMBER IN CODE AREA\n* STORE  NUMBER  LOCATION IN SYMBOL TABLE\n         SR      CDEL,10\n         ST      CDEL,DISP\n         AR      CDEL,10\n         OC      SYMBOL+6(4),DISP\n         OI      FLDISP,X'80'      PUT DCON FLAG IN SYMBOL TABLE\n         LA      CDEL,4(CDEL)      UPDATE CODE AREA L C\n         B       READ\n*\n* BUILD CODE AREA\n*\nNODCON   SR      CDEL,10\n         ST      CDEL,DISP\n         AR      CDEL,10\n         OC      SYMBOL+6(4),DISP\n* SET REGISTERS\nPROCESS  LA      6,DICT\n         LA      9,72\n         LA      8,8\n         SR      5,5\n         LA      7,=A(ADD,SUB,MUL,DIV,OUT,IN,MOVE,STOP,BRM,BR)\n* SEARCH FOR OPCODE\nPROCED   CLC     CARD+9(4),0(6)\n         BE      OK\n         LA      7,4(7)            INCREMENT ADDRESS REGISTER\n         LA      6,8(6)            INCREMENT DISPLACEMENT REGISTER\n         BXLE    5,8,PROCED\n* IF NOT THERE INSERT ERROR CONTROLS\n         MVC     EX,FALSE\n         OI      FLAG,X'40'\n         B       READ\n* GET CODE LENGTH AND MOVE CODE TO CODE AREA\nOK       XDECI   9,4(6)\n         L       14,0(7)\n         EX      9,MOVADD\n         LA      9,1(9)\n         AR      CDEL,9            UPDATE LOCATION COUNTER\n         B       READ\n         TITLE   'SECOND PASS'\nPASS2    LA      5,LOOKUP\n* RESET POINTERS\n         L       CRDL,=V(CRD)\n         L       CDEL,=V(CDEA)\n         B       PRNT\n*\n* PROCESS CODE\n*\nCRDIM    LA      CRDL,32(CRDL)     GET NEXT CARD\nPRNT     MVC     IMAGE(32),LABEL\n         XPRNT   CC2,33\n*\n* CHECK FOR COMMENT CARD\n*\n         CLI     LABEL,C'*'\n         BE      CRDIM\n*\n* LOOK FOR ERROR FLAGS AND PRINT ERROR MESSAGES\n*\n         CLI     FLAG,X'40'\n         BNE     MDL\n         MVC     EX,FALSE\n         XPRNT   =CL44' ****ILLEGAL OPCODE*************************',44\n         B       CRDIM\nMDL      CLI     FLAG,X'80'\n         BNE     MDLS\n         MVC     EX,FALSE\n         XPRNT   =CL44' ****MULTIPLY DEFINED SYMBOL****************',44\n         B       CRDIM\nMDLS     CLI     FLAG,X'C0'\n         BNE     COM\n         MVC     EX,FALSE\n         XPRNT   =CL44' ****ILLEGAL OPCODE AND MULT DEFINED SYMBOL*',44\n         B       CRDIM\n*\n* CHECK OPCODE FOR END, STOP AND DCON\n*\nCOM      CLC     OPCODE(3),=C'END'\n         BE      EXECUTE\n         CLC     OPCODE(4),=C'STOP'\n         BNE     CONT\n         LA      CDEL,L'STOP(CDEL)\n         B       CRDIM\nCONT     CLC     OPCODE(4),=C'DCON'\n         BNE     AADD\n* ALIGN LC TO FULL WORD BOUNDARY\n         LCR     9,CDEL\n         N       9,=X'00000003'\n         AR      CDEL,9\n         LA      CDEL,4(CDEL)\n         B       CRDIM\n*\n* PROCESS CODE FOR MUL SUB AND ADD STATEMENT\n*\nAADD     CLC     OPCODE(3),=C'ADD'\n         BE      LREG\n         CLC     OPCODE(3),=C'SUB'\n         BE      LREG\n         CLC     OPCODE(3),=C'MUL'\n         BNE     CINOUT\nLREG     MVC     CHAR(8),OP1\n         BALR    7,5               BRANCH TO LOOKUP ROUTINE\n         MVC     FL,FLDISP\n         NI      FL,X'80'\n         CLI     FL,X'80'\n         BE      FILL10\n         XPRNT   =CL44' ****USING STATEMENT LABEL AS OPERAND*******',44\n         MVC     EX,FALSE\nFILL10   OC      2(2,CDEL),FLDISP\n         OC      10(2,CDEL),FLDISP\n         MVC     CHAR(8),OP2\n         BALR    7,5               BRANCH TO LOOKUP ROUTINE\n         MVC     FL,FLDISP\n         NI      FL,X'80'\n         CLI     FL,X'80'\n         BE      FILL11\n         XPRNT   =CL44' ****USING STATEMENT LABEL AS OPERAND*******',44\n         MVC     EX,FALSE\nFILL11   OC      6(2,CDEL),FLDISP\n         LA      CDEL,12(CDEL)\n         B       CRDIM\n*\n* PROCESS CODE FOR IN AND OUT STATEMENT\n*\nCINOUT   CLC     OPCODE(2),=C'IN'\n         BE      BLK\n         CLC     OPCODE(3),=C'OUT'\n         BNE      ADIVD\nBLK      MVC     CHAR(8),OP1\n         BALR    7,5               BRANCH TO LOOKUP ROUTINE\n         MVC     FL,FLDISP\n         NI      FL,X'80'\n         CLI     FL,X'80'\n         BE      FILL9\n         XPRNT   =CL44' ****USING STATEMENT LABEL AS OPERAND*******',44\n         MVC     EX,FALSE\nFILL9    OC      2(2,CDEL),FLDISP\n         LA      CDEL,6(CDEL)\n         B       CRDIM\n*\n* PROCESS CODE FOR DIV STATEMENT\n*\nADIVD    CLC     OPCODE(3),=C'DIV'\n         BNE     ABRM\n         MVC     CHAR(8),OP1\n         BALR    7,5               BRANCH TO LOOKUP ROUTINE\n         MVC     FL,FLDISP\n         NI      FL,X'80'\n         CLI     FL,X'80'\n         BE      FILL8\n         XPRNT   =CL44' ****USING STATEMENT LABEL AS OPERAND*******',44\n         MVC     EX,FALSE\nFILL8    OC      2(2,CDEL),FLDISP\n         OC      14(2,CDEL),FLDISP\n         MVC     CHAR(8),OP2\n         BALR    7,5               BRANCH TO LOOKUP ROUTINE\n         MVC     FL,FLDISP\n         NI      FL,X'80'\n         CLI     FL,X'80'\n         BE      FILL7\n         XPRNT   =CL44' ****USING STATEMENT LABEL AS OPERAND*******',44\n         MVC     EX,FALSE\nFILL7    OC      10(2,CDEL),FLDISP\n         LA      CDEL,16(CDEL)\n         B       CRDIM\n*\n* PROCESS CODE FOR BRM STATEMENT\n*\nABRM     CLC     OPCODE(3),=C'BRM'\n         BNE     ABR\n         MVC     CHAR(8),OP2\n         BALR    7,5               BRANCH TO LOOKUP ROUTINE\n         MVC     FL,FLDISP\n         NI      FL,X'80'\n         CLI     FL,X'00'\n         BE      FILL\n         XPRNT   =CL44' ****ATTEMPT TO BRANCH TO DATA**************',44\n         MVC     EX,FALSE\nFILL     OC      8(2,CDEL),FLDISP\n         MVC     CHAR(8),OP1\n         BALR    7,5               BRANCH TO LOOKUP ROUTINE\n         MVC     FL,FLDISP\n         NI      FL,X'80'\n         CLI     FL,X'80'\n         BE      FILL6\n         XPRNT   =CL44' ****USING STATEMENT LABEL AS OPERAND*******',44\n         MVC     EX,FALSE\nFILL6    OC      2(2,CDEL),FLDISP\n         LA      CDEL,10(CDEL)\n         B       CRDIM\n*\n* PROCESS CODE FOR BR STATEMENT\n*\nABR      CLC     OPCODE(2),=C'BR'\n         BNE     AMOVE\n         MVC     CHAR(8),OP1\n         BALR    7,5               BRANCH TO LOOKUP ROUTINE\n         MVC     FL,FLDISP\n         NI      FL,X'80'\n         CLI     FL,X'00'\n         BE      FILL2\n         XPRNT   =CL44' ****ATTEMPT TO BRANCH TO DATA**************',44\n         MVC     EX,FALSE\nFILL2    OC      2(2,CDEL),FLDISP\n         LA      CDEL,4(CDEL)\n         B       CRDIM\n*\n* PROCESS CODE FOR MOVE STATEMENT\n*\nAMOVE    CLC     OPCODE(4),=C'MOVE'\n         BNE     CRDIM\n         MVC     CHAR(8),OP1\n         BALR    7,5               BRANCH TO LOOKUP ROUTINE\n         MVC     FL,FLDISP\n         NI      FL,X'80'\n         CLI     FL,X'80'\n         BE      FILL5\n         XPRNT   =CL44' ****USING STATEMENT LABEL AS OPERAND*******',44\n         MVC     EX,FALSE\nFILL5    OC      2(2,CDEL),FLDISP\n         MVC     CHAR(8),OP2\n         BALR    7,5               BRANCH TO LOOKUP ROUTINE\n         MVC     FL,FLDISP\n         NI      FL,X'80'\n         CLI     FL,X'80'\n         BE      FILL3\n         XPRNT   =CL44' ****USING STATEMENT LABEL AS OPERAND*******',44\n         MVC     EX,FALSE\nFILL3    OC      4(2,CDEL),FLDISP\n         LA      CDEL,6(CDEL)\n         B       CRDIM\n         TITLE   'EXECUTE ROUTINE'\nEXECUTE  CLC     EX,FALSE\n         BNE     DMP\n         XPRNT   =CL44' ****JOB NOT EXECUTED***********************',44\n* GO TO $* CARD\nSCH1     XREAD   CARD,32\n         CLC     CARD(2),=C'$*'\n         BNE     SCH1\n         BR      12\nDMP      XDUMP   0(,10),800\n* SET REGISTERS\n         LA      9,OUTPUT\n          LA     8,INPUT\n* BRANCH TO CODE\n         BALR    11,10\n         XDUMP   0(10),800\n* CHECK FOR END OF DATA\n         XREAD   CARD,32\n         CLC     CARD(2),=C'$*'\n         BNE     MGS\n         BR      12\nMGS      XPRNT   =CL44' ****ALL DATA WAS NOT READ******************',44\n* GO TO $* CARD\nSCH2     XREAD   CARD,32\n         CLC     CARD(2),=C'$*'\n         BNE     SCH2\n         BR      12\n         TITLE   'SYMBOL TABLE LOOKUP ROUTINE'\nLOOKUP   L       SYTL,=V(SYT)\nLOOK     CLC     SYMBOL(8),CHAR\n         BE      0(7)\n         LA      SYTL,10(SYTL)\n         CLI     SYMBOL,X'0'\n         BNE     LOOK\n         XPRNT   =CL44' ****ILLEGAL OPERAND************************',44\n         MVC     EX,FALSE\n          B       CRDIM\n         TITLE   'INPUT ROUTINE'\nINPUT    XREAD   CARD,32\n         CLC     CARD(2),=C'$*'\n         BNE     CONV\n         XDUMP   0(,10),800\n         XPRNT   =CL44' ****ATTEMPT TO READ BEYOND END OF DATA*****',44\n         BR      12\nCONV     ST      1,REG1\n         XDECI   0,CARD\n         L       1,REG1\n         ST      0,0(1)\n         BR      7\n         TITLE   'OUTPUT ROUTINE'\nOUTPUT    XPRNT   =CL15'0THE NUMBER IS:',15\n         XDECO   1,DATA\n         XPRNT   CC,13\n         BR      7\n         TITLE    'DEFINED CONSTANT AND STORAGES'\nADD      DC      X'5800A0005A00A0005000A000'\nSUB      DC      X'5800A0005B00A0005000A000'\nMUL      DC      X'5810A0005C00A0005010A000'\nDIV      DC      X'5800A0008E0000205D00A0005010A000'\nOUT      DC      X'5810A0000579'\nIN       DC      X'4110A0000578'\nMOVE     DC      X'D203A000A000'\nSTOP     DC      X'07FB'\nBRM      DC      X'5800A00012004740A000'\nBR       DC      X'47F0A000'\nEX       DS      C\nTRUE     DC      X'01'\nFALSE    DC      X'00'\nAREA2    DC      5F'0'\nCARD     DS      CL32\n         DS      3C\nCC2      DC      C' '\nIMAGE    DS      32C\n         DS      3C\nCC       DC      C'0'\nDATA     DS      12C\nDISP     DS      F\nREG1     DS      F\nCHAR     DS      8C\nDICT     DC      C'ADD 0011SUB 0011MUL 0011DIV 0015OUT 0005IN  0005MOVE1\n               0005STOP0001BRM 0009BR  0003'\nMOVADD   MVC     0(0,CDEL),0(14)\nSAVE     DS      F\nFL       DS      C\n         LTORG\n         TITLE  'CARD IMAGE CSECT'\nCRD      CSECT\n         DS      50CL32\nCRDFORM  DSECT\nLABEL    DS      CL9\nOPCODE   DS      CL5\nOP1      DS      CL9\nOP2      DS      CL8\nFLAG     DS      CL1\n         TITLE  'SYMBOL TABLE CSECT'\nSYT      CSECT\n         DS      50CL10\nSYTFORM  DSECT\nSYMBOL   DS      CL8\nFLDISP   DS      CL2\n         TITLE  'CODE AREA CSECT'\nCDEA     CSECT\n         DS      50CL16\n         END\n$ENTRY\n$$          'SMITH J^JOB1'\n* DONT FORGET TO SUPPLY THE PROPER DELIMITERS\n* THIS IS PROGRAM NUMBER 1\n* RECOGNIZE THIS ONE ?\n* COMPUTE N!\n*        *    *        *\n         IN   N\n         OUT  N\n         MOVE NFAC     N\n         MOVE M        N\n         SUB  N        ONE\n* LOOP TO DO COMPUTATION\nLOOP     SUB  N        ONE\n         BRM  N        DONE\n         SUB  M        ONE\n         MUL  NFAC     M\n         BR   LOOP\nDONE     OUT  NFAC\n         STOP\nN        DCON 0\nM        DCON 0\nNFAC     DCON 0\nONE      DCON 1\n         END\n5\n$*\n$$          'SMITH J^JOB2'\n* THIS IS PROGRAM NUMBER 2\n* PROGRAM FINDS MAX & MIN OF SET\n* OF INTEGERS<10000000. MIN IS\n* MULT BY 5,MAX IS DIV BY 4\n* AND SUM OF RESULTS PRINTED. -1\n* READ IN HALTS PROGRAM\n*        *    *        *\nLOOP1    IN   N\n         BRM  N        QUIT\n         MOVE TEMP     N\n         SUB  TEMP     MAX\n* IF NEG RESULT OLD MAX STANDS\n         BRM  TEMP     TRYMIN\n         MOVE MAX      N\nTRYMIN   MOVE TEMP     N\n         SUB  TEMP     MIN\n* IF NEG RESULT THEN NEW MIN\n         BRM  TEMP     NEWMIN\n         BR   LOOP1\nNEWMIN   MOVE MIN      N\n         BR   LOOP1\nN        DCON 0\nMAX      DCON -4\nMIN      DCON 10000000\nTEMP     DCON 0\nFOUR     DCON 4\nFIVE     DCON 5\nQUIT     MUL  MIN      FIVE\n         DIV  MAX      FOUR\n         ADD  MIN      MAX\n         OUT  MIN\n         STOP\n         END\n200   DATA\n         20     DATA\n                5000      DATA\n  18    DATA\n         64     DATA\n     2    DATA\n          -1       DATA TRAILER\n$*\n$$          'SMITH J^JOB3'\n* PROGRAM NUMBER 2 WITH ERRORS\n*        *    *        *\nLOOP1    IN   N\n         BRM  N        QUIT\n         MOVE TEMP     N\n         SUB  TEMP     MAX\n* IF NEG RESULT OLD MAX STANDS\n         BRM  TEMP     TRYMIN\n         MOVE MAX      N\nTRYMIN   MOVE TEMP     N\n         SUB  TEMP     TRYMIN\n* IF NEG RESULT THEN NEW MIN\n         BRM  TEMP     NEWMIN\n         BR   MAX\nNEWMIN   MOVE MIN      N\n         BR   LOOP1\nN        DCON 0\nMAX      DCON -4\nTEMP     DCON 0\nFOUR     DCON 4\nFIVE     DCON 5\nMAX      DCON 1000000\nQUIT     MUL  MIN      FIVE\n         STM  MAX      FOUR\n         ADD  MIN      MAX\n         OUT  MIN\n         STOP\n         END\n200   DATA\n         20     DATA\n                5000      DATA\n  18    DATA\n         64     DATA\n     2    DATA\n          -1       DATA TRAILER\n$*\n$$          'SMITH J^JOB4'\n* PROGRAM NUMBER 1 WITH ERRORS\n*        *    *        *\n         IN   N\n         OUT  N\n         MOVE NFAC     N\n         MOVE M        N\n         SUB  N        ONE\n* LOOP TO DO COMPUTATION\nLOOP     SUB  N        ONE\n         BRM  DONE\n         SUB  M        ONE\n         MUL  NFAC     M\n         BR   POOL\nDONE     OUT  NFAC\n         STOP\nN        DCON 0\nM        DCON 0\nNFAC     DCON 0\nONE      DCON 1\n         END\n$*\n$JOB   ASSIST  PROGTEST\n*        *** SAMPLE FINAL PROJECT - 1ST ASSEMBLER COURSE - 500 STMTS,\n*        150-200 CARDS ARE READ BY THE STUDENT PROGRAM.\n*        USER PROGRAM PRINTS 6-7 PAGES OF OUTPUT, EXECUTES 15240 INSTS.\n*        THEN TERMINATES NORMALLY.\n*        CMPSC 410.1 - FALL 1970 - PSU-INSTRUCTOR -C.HUGHES.\nMAIN     CSECT\n         USING *,15\nSTART    XREAD CARD,32       READ TOPAL JOB CARD\n         BM STOP             BRANCH ON /*\n         CLC CARD(2),SIGN    $$  ???\n         BE PRINT\n         B LOAD\nSTOP     XPRNT =C'1ALL TOPAL PROGRAMS PROCESSED',28\n         BR 14               ALL TOPAL PROCESSED\nPRINT    XPRNT =C'1****TOPAL****TOPAL****TOPAL****TOPAL****',41\n         XPRNT CARDT,33      READ TOPAL CARD\n         L 4,=X'00000000'    SETTING SYMBOL\n         L 6,=X'00000001'    TABLE TO BLANKS\n         L 7,=X'000001F4'\n         L 3,=V(SYMBOLT)     LOAD ADDRESS OF SYMBOL TABLE\nBXL      MVI 0(3),C' '       MOVE BLANKS TO TABLE\n         LA 3,1(3)\n         BXLE 4,6,BXL        BRANCH TILL TABLE IS FULL\n         L 4,=X'00000000'    SETTING CARDAREA\n         L 6,=X'00000001'    TO BLANKS\n         L 7,=X'00000640'\n         L 5,=V(CARDAREA)    LOAD ADDRESS OF CARDAREA\nBXT      MVI 0(5),C' '       MOVE BLANKS TO AREA\n         LA 5,1(5)\n         BXLE 4,6,BXT        BRANCH TILL FULL\n         L 4,=X'00000000'\n         L 6,=X'00000001'\n         L 7,=X'00000320'    SETTING CODEAREA TO\n         L 10,=V(CODEAREA)   BLANKS\nBXD      MVI 0(10),C' '      MOVE BLANKS\n         LA 10,1(10)\n         BXLE 4,6,BXD\nLOAD     L 4,ZERO            SETTING LOCATION COUNTER TO ZERO\n         L 10,=V(CODEAREA)   LOAD ADDRESS OF CODEAREA\n         L 5,=V(CARDAREA)    LOAD ADDRESS OF CARDAREA\nCID      XREAD CARD,32       READ TOPAL CARD\n         MVC 0(32,5),CARD    MOVE CARD IMAGE TO CARDAREA\n         MVI 31(5),X'00'     SET FLAG TO 0\n         CLI CARD,C'*'       COMMENT CARD\n         BE A\n         B B                 NOT COMMENT CARD\nA        LA 5,32(5)          UPDATE CARDAREA\n         B CID               READ ANOTHER CARD\nB        CLC CARD+9(3),END   END CARD ?\n         BE PASS2\n         L 7,=V(LOOKUP)      LOAD ADDRESS OF LOOKUP TABLE\n         BALR 11,7\n         LA 5,32(5)          UPDATE CARDAREA\n         B CID\nPASS2    L 10,=V(CODEAREA)   LOAD REGISTERS FOR PASS 2\n         MVI 31(5),X'00'     SET END CARD TO NO ERRORS\n         L 5,=V(CARDAREA)\n         L 4,ZERO\nAAT      LA 6,PRNT-3         LOAD ADDRESS OF AREA TO PRINT OUT OF\n         MVC 0(31,6),0(5)    MOVE CARD IMAGE TO PRINT AREA\n         XPRNT PRNTT,32      PRINT CARD IMAGE\n         CLI 0(5),C'*'       COMMENT CARD ?\n         BE AAY\n         CLI 31(5),X'40'     ILLEGAL OPCODE ?\n         BE AAA\n         CLI 31(5),X'00'     NO ERRORS ?\n         BE AAD\n         CLI 31(5),X'80'     ILLEGAL OPCODE AND MULTI SYMBOL ?\n         BE AAC\n         CLI 31(5),X'C0'     MULTI SYMBOL ?\n         BE AAZ\nAAA      XPRNT =C'0ERROR******ILLEGAL OPCODE******ERROR',37\n         MVI EX,X'FF'        NO EXECUTE\n         B AAY\nAAC      XPRNT =C'0ERROR*****MULTIPLY DEFINED SYMBOL AND ILLEGAL OPCODEX\n               ******ERROR',64\n         MVI EX,X'FF'        NO EXECUTE\n         B AAY\nAAZ      XPRNT =C'0ERROR****MULTIPLY DEFINED SYMBOL IN LABEL FIELD****EX\n               RROR',57\n         MVI EX,X'FF'        NO EXECUTE\nAAY      LA 5,32(5)          UPDATE CARDAREA\n         B AAT\nAAD      CLI 0(5),C'*'       COMMENT CARD ?\n         BNE AAQ\n         LA 5,32(5)          UPDATE CARDAREA\n         B AAT\nAAQ      CLC 9(3,5),END      END STATEMENT ?\n         BNE AAM\n         B EXEC              IS END CATD SO EXECUTE PROGRAM\nAAM      CLC 9(4,5),STP      STOP CARD ?\n         BNE AAN\n         A 4,=X'00000002'    STOP CARD SO UPDATE LOCATION COUNTER\n         LA 10,2(10)         UPDATE CODEAREA\n         LA 5,32(5)          UPDATE CARDAREA\n         B AAT\nAAN      CLC 9(4,5),SPP      DCON CARD ?\n         BNE AAW\n         ST 4,TEST           DCON CARD SO TEST TO SEE IF ON FULL WORD\n         TM TEST+3,B'00000011'\n         BZ TUM              ON FULL WORD\n         LA 10,2(10)         NOT FULLWORD SO UPDATE TO FULLWORD\n         A 4,=X'00000002'    LOCATION COUNTER\nTUM      LA 5,32(5)          UPDATE CARDAREA\n         LA 10,4(10)         UPDATE CODEAREA\n         A 4,=X'00000004'\n         B AAT\nAAW      L 3,=V(SYMBOLT)     LOAD ADDRESS OF SYMBOL TABLE\nAAAB     CLC 14(8,5),0(3)    OPERAND IN TABLE ?\n         BE AAU\n         CLI 0(3),C' '       END OF TABLE ?\n         BE AAAA\n         LA 3,10(3)          UPDATE SYMBOL TABLE\n         B AAAB\nAAAA     XPRNT =C'0ERROR*****ILLEGAL OPERAND*****ERROR',37\n         MVI EX,X'FF'        NO EXECUTE\n         LA 5,32(5)          UPDATE CARDEEA\n         B AAT\nAAU      MVC DISA(1),9(3)    MOVE ADDRESS OF  OPERAND TO STORAGE\n         CLC 9(3,5),A3       BRM CARD ?\n         BE GOAH\n         CLC 9(2,5),A7       BR CARD ?\n         BNE GOAHD\n         CLI 8(3),X'00'      INSTRUVTION ?\n         BE GOAH3\n         XPRNT =C'0ERROR****BRANCH TO DATA AREA****ERROR',38\n         B GOAH\nGOAHD    CLI 8(3),X'80'      DATA AREA ?\n         BNE GOAH1\n         B GOAH\nGOAH1    XPRNT =C'0ERROR****TREATING AN INSTRUCTION AS DATA****ERROR',5X\n               0\nGOAH     L 3,=V(SYMBOLT)     LOAD ADDRESS OF SYMBOL TABLE\n         CLI 23(5),X'40'     SECOND OPERAND OR NOT ?\n         BE GOAH3\nAAAC     CLC 23(8,5),0(3)    OPERAND IN TABLE ?\n         BE OR\n         CLI 0(3),C' '       END OF TABLE ?\n         BE AAAA\n         LA 3,10(3)          UPDATE SYMBOL TABLE\n         B AAAC\nOR       MVC DISB(1),9(3)    STORE ADDRESS OF SECOND OPERAND\n         CLC 9(3,5),A3       BRM CARD ?\n         BNE GOAHD1\n         CLI 8(3),X'00'      INSTRUCTION ?\n         BE GOAH3\n         XPRNT =C'0ERROR****BRANCH TO DATA AREA****ERROR',38\n         B GOAH3\nGOAHD1   CLI 8(3),X'80'      DATA AREA ?\n         BNE GOAH2\n         B GOAH3\nGOAH2    XPRNT =C'0ERROR****TREATING AN INSTRUCTION AS DATA****ERROR',5X\n               0\nGOAH3    CLC 9(3,5),A1       ADD CARD ?\n         BE A11\n         CLC 9(3,5),A2       DIV CARD ?\n         BE A12\n         CLC 9(3,5),A3       BRM CARD ?\n         BE A13\n         CLC 9(3,5),A4       SUB CARD ?\n         BE A14\n         CLC 9(3,5),A5       OUT CARD ?\n         BE A15\n         CLC 9(4,5),A6       MOVE CARD ?\n         BE A16\n         CLC 9(2,5),A7       BR CARD ?\n         BE A17\n         CLC 9(3,5),A9       MUL CARD ?\n         BE A18\n         CLC 9(2,5),A10      IN CARD ?\n         BE A19\n         XPRNT =C'0ERROR*****ILLEGAL OPCODE*****ERROR',36\n         LA 5,32(5)          UPDATE CARDAREA\n         B AAT\nA11      OC 3(1,10),DISA     OR IN ADDRESSES INTO MACHINE CODE AREA\n         OC 7(1,10),DISB\n         OC 11(1,10),DISA\n         LA 10,12(10)\n         A 4,=X'0000000C'\n         LA 5,32(5)\n         B AAT\nA12      OC 3(1,10),DISA     OR IN ADDRESS INTO MACHINE CODE AREA\n         OC 11(1,10),DISB\n         OC 15(1,10),DISA\n         LA 10,16(10)\n         A 4,=X'0000000F'\n         LA 5,32(5)\n         B AAT\nA13      OC 3(1,10),DISA     OR IN ADDRESS INTO MACHINE CODE AREA\n         OC 9(1,10),DISB\n         LA 10,10(10)\n         A 4,=X'0000000A'\n         LA 5,32(5)\n         B AAT\nA14      OC 3(1,10),DISA     OR IN ADDRESS INTO MACHINE CODE AREA\n         OC 7(1,10),DISB\n         OC 11(1,10),DISA\n         LA 10,12(10)\n         A 4,=X'0000000C'\n         LA 5,32(5)\n         B AAT\nA15      OC 3(1,10),DISA     OR IN ADDRESS INTO MACHINE CODE AREA\n         LA 10,6(10)\n         A 4,=X'00000006'\n         LA 5,32(5)\n         B AAT\nA16      OC 3(1,10),DISA     OR IN ADDRESS INTO MACHINE CODE AREA\n         OC 5(1,10),DISB\n         LA 10,6(10)\n         A 4,=X'00000006'\n         LA 5,32(5)\n         B AAT\nA17      OC 3(1,10),DISA     OR IN ADDRESS INTO MACHINE CODE AREA\n         LA 10,4(10)\n         A 4,=X'00000004'\n         LA 5,32(5)\n         B AAT\nA18      OC 3(1,10),DISA     OR IN ADDRESS INTO MACHINE CODE AREA\n         OC 7(1,10),DISB\n         OC 11(1,10),DISA\n         LA 10,12(10)\n         A 4,=X'0000000C'\n         LA 5,32(5)\n         B AAT\nA19      OC 3(1,10),DISA     OR IN ADDRESS INTO MACHINE CODE AREA\n         LA 10,6(10)\n         A 4,=X'00000006'\n         LA 5,32(5)\n         B AAT\nEXEC     CLI EX,X'FF'        EXECUTE ?\n         BNE QTGO\n         XPRNT =C'0PROGRAM TERMINATION DUE TO ERROR IN PROGRAM',44\nQT       XREAD CARD,32       READ TOPAL DATA CARDS TILL $* CARD\n         CLC CARD(2),FT      $*  ???\n         BE FTA\n         B QT\nFTA      B START\nQTGO     L 10,=V(CODEAREA)   LOAD ADDRESS OF CODEAREA\n         XPRNT =C'0GENERATED CODE FOR TOPAL PROGRAM',33\n         XDUMP 0(10),200     DUMP CODAREA\n         L 8,=V(INPUT)       LOAD ADDRESS OF INPUT ROUTINE\n         L 9,=V(OUTPUT)      LOAD ADDRESS OF OUTPUT ROUTINE\n         BALR 11,10\n         L 10,=V(CODEAREA)   LOAD ADDRESS OF CODEAREA\n         XPRNT =C'0GENERATED CODE FOR TOPAL PROGRAM',33\n         XDUMP 0(10),200     DUMP CODEAREA\n         XREAD CARD,32       READ TOPAL CARD\n         CLC CARD(2),FT      $$  ???\n         BE START\n         XPRNT =C'0PROGRAM TERMINATED BEFORE ALL DATA READ',43\nPDQ      XREAD CARD,32       READ TOPAL CARDS TILL $* CARD\n         CLC CARD(2),FT      $*  ???\n         BE START\n         B PDQ\nSIG      DC C'/*'\nSIGN     DC C'$$'\nEND      DC C'END'\nCARDT    DC C'0'\nCARD     DC 32C' '\n         DS 0F\nZERO     DC X'00000000'\nPRNTT    DC C'0'\nPRNT     DS 32F\nEX       DS F\nSTP      DC C'STOP'\nSPP      DC C'DCON'\nDISA     DS F\nDISB     DS F\nTEST     DS F'0'\nA1       DC C'ADD'\nA2       DC C'DIV'\nA3       DC C'BRM'\nA4       DC C'SUB'\nA5       DC C'OUT'\nA6       DC C'MOVE'\nA7       DC C'BR'\nA9       DC C'MUL'\nA10      DC C'IN'\nFS       DC  X'FF'\nFT       DC C'$*'\n         LTORG\n         SPACE 5\nLOOKUP   CSECT               LOOKUP ROUTINE\n         STM 14,12,12(13)    STORE REGISTERS\n         BALR 7,0\n         USING *,7\n         CLC 9(4,5),DCON     DCON CARD ?\n         BE ET\n         CLI 0(5),X'40'      LABEL ?\n         BE G\nET       L 3,=V(SYMBOLT)     LOAD ADDRESS OF SYMBOL TABLE\n         CLI 0(5),X'40'      LABEL ?\n         BE DCO\nE        CLI 0(3),C' '       LABEL IN TABLE ?\n         BE D\n         CLC 0(8,5),0(3)     CARD LABEL EQUAL TO  TABLE LABEL\n         BE FALSE\n         LA 3,10(3)          UPDATE SYMBOL TABLE\n         B E\nFALSE    MVI 31(5),X'80'     MULTIPLY DEFINED LABEL\n         B G\nD        MVC 0(8,3),0(5)     MOVE LABEL TO SYMBOL TABLR\nDCO      CLC 9(4,5),DCON     DCON CARD ?\n         BE F\n         ST 4,QR             STORE LOCATION COUNTER\n         LA 9,QR\n         MVC 8(2,3),2(9)     MOVE ADDRESS INTO SYMBOL TABLE\n         MVI 8(3),X'00'      INSTRUCTION\n         B G\nF        CLI 0(5),X'40'      ILLEGAL  OPCODE ?\n         BE H\nH        XDECI 12,14(5)\n         ST 12,CVB           CONVERT TO BINARY THE  DCON\n         ST 4,TESTT          TEST LOCATION COUNTER FOR FULLWORD\n         TM TESTT+3,B'00000011'\n         BZ TUMM\n         LA 10,2(10)         NOT FULLWORD SO UPDATE\n         A 4,=X'00000002'\nTUMM     MVC 0(4,10),CVB     MOVE DCON TO CODEAREA\n         ST 4,QR             STORE LOCATION COUNTER\n         LA 9,QR\n         MVC 8(2,3),2(9)     MOVE ADDRESS TO SYMBOL TABLE\n         MVI 8(3),X'80'      DATA AREA\n         LA 10,4(10)\n         A 4,=X'00000004'\n         BR 11\nG        L 9,=V(CODEAR)      LOAD ADDRESS OF CODE ROUTINE\n         BR 9\nDCON     DC C'DCON'\nCVB      DS F\nQR       DS F\nTESTT    DS F'0'\n         LTORG\n         SPACE 5\nCODEAR   CSECT               CODE ROUTINE\n         STM 14,12,12(13)\n         BALR 7,0\n         USING *,7\n         CLC 9(3,5),AB       ADD CARD ?\n         BE K\n         CLC 9(3,5),BB       DIV CARD ?\n         BE M\n         CLC 9(3,5),CB       BRM CARD ?\n         BE C1\n         CLC 9(3,5),DB       SUB CARD ?\n         BE D1\n         CLC 9(3,5),EB       OUT CARD ?\n         BE E1\n         CLC 9(4,5),FB       MOVE CARD ?\n         BE F1\n         CLC 9(2,5),GB       BR CARD ?\n         BE G1\n         CLC 9(4,5),HB       STOP CARD ?\n         BE H1\n         CLC 9(3,5),IB       MUL CARD ?\n         BE I\n         CLC 9(2,5),JB       IN CARD ?\n         BE J\n         CLI 31(5),X'80'     DATA  MULTIPLY DEFINED LABEL ?\n         BE CS\n         MVI 31(5),X'40'     ILLEGAL OPCODE\n         B CP\nCS       MVI 31(5),X'C0'     MOVE ERROR FLAG TO CARD AREA\nCP       BR 11\nK        MVC 0(12,10),Z      MOVE MACHINE CODE TO CODEAREA\n         LA 10,12(10)\n         A 4,=X'0000000C'\n         B L\nM        MVC 0(16,10),Y      MOVE MACHINE CODE TO CODEAREA\n         LA 10,16(10)\n         A 4,=X'0000000F'\n         B L\nC1       MVC 0(10,10),X      MOVE MACHINE CODE TO CODE AREA\n         LA 10,10(10)\n         A 4,=X'0000000A'\n         B L\nD1       MVC 0(12,10),W      MOVE MACHINE CODE TO CODEAREA\n         LA 10,12(10)\n         A 4,=X'0000000C'\n         B L\nE1       MVC 0(6,10),V       MOVE MACHINE CODE TO CODEAREA\n         LA 10,6(10)\n         A 4,=X'00000006'\n         B L\nF1       MVC 0(6,10),U       MOVE MACHINE CODE TO CODEAREA\n         LA 10,6(10)\n         A 4,=X'00000006'\n         B L\nG1       MVC 0(4,10),T       MOVE MACHINE CODE TO CODEAREA\n         LA 10,4(10)\n         A 4,=X'00000004'\n         B L\nH1       MVC 0(2,10),S       MOVE MACHINE CODE TO CODEAREA\n         LA 10,2(10)\n         A 4,=X'00000002'\n         B L\nI        MVC 0(12,10),R      MOVE MACHINE CODE TO CODEAEA\n         LA 10,12(10)\n         A 4,=X'0000000C'\n         B L\nJ        MVC 0(6,10),Q       MOVE MACHINE CODE TO CODEAREA\n         LA 10,6(10)\n         A 4,=X'00000006'\nL        BR 11               RETURN TO MAIN CSECT\nAB       DC C'ADD'\nBB       DC C'DIV'\nCB       DC C'BRM'\nDB       DC C'SUB'\nEB       DC C'OUT'\nFB       DC C'MOVE'\nGB       DC C'BR'\nHB       DC C'STOP'\nIB       DC C'MUL'\nJB       DC C'IN'\nZ        DC X'5800A0005A00A0005000A000'\nY        DC X'5800A0008E00A0205D00A0005010A000'\nX        DC X'5800A00012004740A000'\nW        DC X'5800A0005B00A0005000A000'\nV        DC X'5810A0000579'\nU        DC X'D203A000A000'\nT        DC X'47F0A000'\nS        DC X'07FB'\nR        DC X'5810A0005C00A0005010A000'\nQ        DC X'4110A0000578'\n         LTORG\n         SPACE 5\nINPUT    CSECT               INPUT ROUTINE\n         STM 14,12,12(13)\n         BALR 12,0\n         USING *,12\n         LR 6,1              LOAD REGISTER WITH ADDRESS OF DATA AREA\n         XREAD CARD1,32      READ TOPAL DATA CARD\n         CLC CARD1(2),SIG1   $*  ???\n         BNE GO\n         L 10,=V(CODEAREA)   LOAD ADDRESS OF CODEAREA\n         XDUMP 0(10),200     DUMP CODEAREA\n         XPRNT =C'0ATTEMPT TO READ BEYOND END OF DATA',35\n         BR 11\nGO       XDECI 12,CARD1      CONVERT DATA TO BINARY\n         ST 12,0(6)          STORE BINARY DATA IN DATA AREA\n         BR 7\nSIG1     DC C'$*'\nCARD1    DC 32C' '\n         LTORG\n         SPACE 5\nOUTPUT   CSECT               OUTPUT ROUTINE\n         STM 14,12,12(13)\n         BALR 2,0\n         USING *,2\n         XDECO 1,OUTNUM      CONVERT OUTPUT TO DECIMAL\n         XPRNT =C'0TOPAL PROGRAM OUTPUT',21\n         XPRNT OUT           PRINT OUTPUT\n         BR 7\nOUT      DC C'0'\nOUTNUM   DC 12C' '\n         DC 120C' '\n         LTORG\n         SPACE 5\nCODEAREA CSECT               STORAGE FOR MACHINE CODE GENERATED\n         DS 0F\n         DS 200CL4' '\n         SPACE 5\nCARDAREA CSECT               STORAGE FOR TOPAL CARDS READ\n         DS 0F\n         DS 400CL4' '\n         SPACE 5\nSYMBOLT  CSECT               STORAGE FOR SYMBOL TABLE\n         DS 0F\n         DS 125CL4' '\n         END\n$ENTRY\n$$     SMITH, JOHN- JOB 1\n* THIS IS PROGRAM NUMBER 1\n* RECOGNIZE THIS ONE ?\n* COMPUTE N!\n*        *    *        *\n         IN   N\n         OUT  N\n         MOVE NFAC     N\n         MOVE M        N\n         SUB  N        ONE\n* LOOP TO DO COMPUTATION\nLOOP     SUB  N        ONE\n         BRM  N        DONE\n         SUB  M        ONE\n         MUL  NFAC     M\n         BR   LOOP\nDONE     OUT  NFAC\n         STOP\nN        DCON 0\nM        DCON 0\nNFAC     DCON 0\nONE      DCON 1\n         END\n     5\n$*\n$$    HOOVER,JAMES-JOB 1\n* THIS IS PROGRAM NUMBER 2\n* PROGRAM FINDS MAX & MIN OF SET\n* OF INTEGERS<10000000. MIN IS\n* MULT BY 5,MAX IS DIV BY 4\n* AND SUM OF RESULTS PRINTED. -1\n* READ IN HALTS PROGRAM\n*        *    *        *\nLOOP1    IN   N\n         BRM  N        QUIT\n         MOVE TEMP     N\n         SUB  TEMP     MAX\n* IF NEG RESULT OLD MAX STANDS\n         BRM  TEMP     TRYMIN\n         MOVE MAX      N\nTRYMIN   MOVE TEMP     N\n         SUB  TEMP     MIN\n* IF NEG RESULT THEN NEW MIN\n         BRM  TEMP     NEWMIN\n         BR   LOOP1\nNEWMIN   MOVE MIN      N\n         BR   LOOP1\nN        DCON 0\nMAX      DCON -4\nMIN      DCON 10000000\nTEMP     DCON 0\nFOUR     DCON 4\nFIVE     DCON 5\nQUIT     MUL  MIN      FIVE\n         DIV  MAX      FOUR\n         ADD  MIN      MAX\n         OUT  MIN\n         STOP\n         END\n200   DATA\n         20     DATA\n                5000      DATA\n  18    DATA\n         64     DATA\n     2    DATA\n          -1       DATA TRAILER\n$*\n$$    HAGG,JOSEPH-JOB 1\n* PROGRAM NUMBER 2 WITH ERRORS\n*        *    *        *\nLOOP1    IN   N\n         BRM  N        QUIT\n         MOVE TEMP     N\n         SUB  TEMP     MAX\n* IF NEG RESULT OLD MAX STANDS\n         BRM  TEMP     TRYMIN\n         MOVE MAX      N\nTRYMIN   MOVE TEMP     N\n         SUB  TEMP     TRYMIN\n* IF NEG RESULT THEN NEW MIN\n         BRM  TEMP     NEWMIN\n         BR   MAX\nNEWMIN   MOVE MIN      N\n         BR   LOOP1\nN        DCON 0\nMAX      DCON -4\nTEMP     DCON 0\nFOUR     DCON 4\nFIVE     DCON 5\nMAX      DCON 1000000\nQUIT     MUL  MIN      FIVE\n         STM  MAX      FOUR\n         ADD  MIN      MAX\n         OUT  MIN\n         STOP\n         END\n200   DATA\n         20     DATA\n                5000      DATA\n  18    DATA\n         64     DATA\n     2    DATA\n          -1       DATA TRAILER\n$*\n$$    WILSON,DUD-JOB 1\n* PROGRAM NUMBER 1 WITH ERRORS\n*        *    *        *\n         IN   N\n         OUT  N\n         MOVE NFAC     N\n         MOVE M        N\n         SUB  N        ONE\n* LOOP TO DO COMPUTATION\nLOOP     SUB  N        ONE\n         BRM  DONE\n         SUB  M        ONE\n         MUL  NFAC     M\n         BR   POOL\nDONE     OUT  NFAC\n         STOP\nN        DCON 0\nM        DCON 0\nNFAC     DCON 0\nONE      DCON 1\n         END\n    5\n$*\n$JOB   ASSIST  PROGTEST\n*        *** FINAL PROJECT - FIRST ASSEMBLER COURSE.\n*        493 STMTS, , EXECUTES 14375 INSTRUCTIONS, THEN TERMINATES\n*        *** WITH 0C4 AND DUMPS.\n*        CMPSC 410.1 - FALL 1970 - PSU-INSTRUCTOR -C.HUGHES.\nTOPAL    CSECT\n         B         10(,15)\n         DC        X'05'\n         DC        CL5'TOPAL'\n         STM       14,12,12(13)\n         BALR      12,0\n         USING     *,12              SET UP BASE REG.\nPASSTWO  LR        5,13\n         LA        13,SAVE\n         ST        13,8(5)\n         ST        5,4(13)\nTOPALX   XREAD     CARD,80           READ FOR JOB CARD OR /* CARD\n         BZ        TEST              IF NOT /* CARD BRANCH TO TEST\n         XPRNT     =C'1ALL JOBS HAVE BEEN PROCESSED,CONTROL BEING RETURN\n               NED TO ASSEMBLER',65\n         B         RESTORE\nTEST     CLC       CARD(2),=C'$$'    TEST FOR JOB CARD\n         BE        GO                IF JOB CARD GO AHEAD\n         XPRNT     =C'1****ABNORMAL TERMINATION-NO JOB CARD',37\n         B         RESTORE           RETURN CONTROL TO ASSEMBLER\nGO       XPRNT     =C'1',1           SKIP TOP OF PAGE\n         XPRNT     CARD-1,81         PRINT USER JOB AND ID CARD\n*      INITIALIZE  SYMBOL TABLE TO BLANKS\n         L         2,=V(SYMBOLTB)    LOAD ADDRESS OF SYMBOL TABLE\n         L         3,=F'125'\n         L         4,=C'    '\nBLNKOUT  ST        4,0(2)            STORE BLANKS\n         LA        2,4(2)            INCREMENT REGISTER\n         BCT       3,BLNKOUT         DECREASE COUNTER BY ONE\n* INITIALIZE CODE AREA TO HEX F'S\n         L         2,=V(CODETB)      LOAD ARDRESS OF CODE TABLE\n         L         4,=X'FFFFFFFF'    LOAD REGISTER WITH HEX F'S\n         L         3,=F'200'\nFOUT     ST        4,0(2)            LOAD TABLE INITIALLY\n         LA        2,4(2)            INCREMENT\n         BCT       3,FOUT            SUB. ONE FROM COUNTER\n* INITIALIZE CARD AREA TO BLANKS\n         L         2,=V(CARDTB)      LAOD ADDRESS OF CARD TABLE\n         L         3,=F'400'\n         L         4,=C'    '        LOAD REG. WITH BLANKS\nBOUT     ST        4,0(2)            LOAD TABLE\n         LA        2,4(2)            INCREMENT TABLE ADDRESS\n         BCT       3,BOUT            SUB ONE FROM COUNTER\n         L         6,=C'GO  '        LOAD REG TO SHOW GO WITH EXECUTION\n* READ IN TOPAL CARDS\n         L         10,=V(CODETB)     LOAD ADDRESS OF CODETABLE\n         L         5,=V(CARDTB)      LOAD ADDRESS OF CARD TABLE\n         USING     CARDFORM,5        FLOATING DSECT OVER CARD TABLE\n         USING     CODEDS,10         FLOATING DSECT OVER CODE TABLE\n         SR        3,3               ZERO OUT FOR LOCATION COUNTER\nREADCARD XREAD     CARDTP,31         READ IN TOPAL CARD\n         MVC       LABEL(31),CARDTP  PUT IN CARD TABLE\n         CLI       CARDTP,C'*'       COMMENT CARD ?\n         BNE       ENDCD             NO,TEST FOR END CARD\n         LA        5,32(5)           INCREMENT CARD TABLE ADDRESS\n         B         READCARD          READ IN NEXT CARD\nENDCD    CLC       =CL5'END',OPCODE  END CARD ?\n         BNE       LABELED\n         CL        6,=C'NOGO'\n         BNE       PASS2\n         OI        FLAG,B'00001000'\nPASS2    L         15,=V(PASTWO)\n         BALR      14,15\n         B         TOPALX\nLABELED  CLC       =CL9' ',LABEL     LABEL ?\n         BE        DCONST\n         L         2,=V(SYMBOLTB)    LOAD ADDRESS OF SYMBOL TABLE\n         USING     SYMBOLDS,2        FLOATING DSECT OVER SYMBOL TABLE\nTESTSBL  CLC       =CL8' ',SYMBOL    TEST FOR NO SYMBOL IN TABLE\n         BE        STORESBL\n         CLC       SYMBOL(8),LABEL   TEST FOR DUPLICATE LABEL\n         BNE       INCRE\n         L         6,=C'NOGO'        NO EXECUTION\n         OI        FLAG,B'00001000'  FLAG CARD AREA\n         B         DCONST\nINCRE    LA        2,10(2)           INCREMENT ADDRESS\n         B         TESTSBL\nSTORESBL MVC       SYMBOL(8),LABEL   PUT LABEL IN SYMBOL TABLE\n         CLC       =CL5'DCON',OPCODE TEST IF DCON\n         BE        STDC\n         STH       3,FLDISP          ENTER DISPLACEMENT\n         B         DCONST\nSTDC     LCR       9,3               SET TO FULL WORD BOUNDARY\n         N         9,=X'00000003'\n         AR        3,9\n         STH       3,FLDISP          ENTER DISPLACEMENT\n         OI        FLDISP,B'10000000' SET FLAG THAT DCON\n         B         CONVERT\nDCONST   CLC       =CL5'DCON',OPCODE  DCON?\n         BNE       NOTDCON\nCONVERT  XDECI     7,OPND1\n         LCR       9,10              SET TO FULL WORD BOUNDARY\n         N         9,=X'00000003'\n         AR        10,9\n         ST        7,CODE             STORE VALUE OF DCON IN CODE AREA\n         LA        3,4(3)            INCRE LOC COUNTER\n         LA        10,4(10)          INCRE TABLE ADDRESS\n         LA        5,32(5)           INCREMENT CARD TABLE ADDRESS\n         B         READCARD\nNOTDCON  CLC       =CL5'ADD',OPCODE  ADD INST ?\n         BNE       NOTADD\n         MVC       CODE(L'ADD),ADD   MOVE ADD CODE INTO TABLE\nINCRECT  LA        3,12(3)           INCRE LOC COUNTER\n         LA        10,12(10)         INCRE TABLE ADD.\n         LA        5,32(5)           INCREMENT CARD TABLE ADDRESS\n         B         READCARD\nNOTADD   CLC       =CL5'SUB',OPCODE  SUB INST ?\n         BNE       NOTSUB\n         MVC       CODE(L'SUB),SUB    MOVE SUB CODE INTO TABLE\n         B         INCRECT\nNOTSUB   CLC       =CL5'MUL',OPCODE  MUL INST ?\n         BNE       NOTMUL\n         MVC       CODE(L'MUL),MUL   MOVE CODE INTO TABLE\n         B         INCRECT\nNOTMUL   CLC       =CL5'DIV',OPCODE  DIVIDE INST ?\n         BNE       NOTDIV\n         MVC       CODE(L'DIV),DIV   MOVE CODE ONTO TABLE\n         LA        3,16(3)           INCRE LOC COUNTER\n         LA        10,16(10)         INCRE ADDRESS\n         LA        5,32(5)           INCREMENT CARD TABLE ADDRESS\n         B         READCARD\nNOTDIV   CLC       =CL5'OUT',OPCODE  OUT INST ?\n         BNE       NOTOUT\n         MVC       CODE(L'OUT),OUT   MOVE CODE INTO TABLE\nINOUT    LA        3,6(3)            INCRE LOC COUNTER\n         LA        10,6(10)          INCRE ADDRESS\n         LA        5,32(5)           INCREMENT CARD TABLE ADDRESS\n         B         READCARD\nNOTOUT   CLC       =CL5'IN',OPCODE   IN INST ?\n         BNE       NOTIN\n         MVC       CODE(L'IN),IN     LOAD CODE INTO TABLE\n         B         INOUT\nNOTIN    CLC       =CL5'BRM',OPCODE  BRM INST ?\n         BNE       NOTBRM\n         MVC       CODE(L'BRM),BRM   MOVE CODE INTO TABLE\n         LA        3,10(3)           INCRE LOC COUNTER\n         LA        10,10(10)         INCRE ADDRESS\n         LA        5,32(5)           INCREMENT CARD TABLE ADDRESS\n         B         READCARD\nNOTBRM   CLC       =CL5'BR',OPCODE   BR INST ?\n         BNE       NOTBR\n         MVC       CODE(L'BR),BR\n         LA        3,4(3)            INCRE LOC COUNTER\n         LA        10,4(10)          INCRE ADDRESS\n         LA        5,32(5)           INCREMENT CARD TABLE ADDRESS\n         B         READCARD\nNOTBR    CLC       =CL5'MOVE',OPCODE  MOVE INST ?\n         BNE       NOTMOVE\n         MVC       CODE(L'MOVE),MOVE  MOVE CODE INTO TABLE\n         B         INOUT\nNOTMOVE  CLC       =CL5'STOP',OPCODE    STOP INST ?\n         BNE       NOTANY\n         MVC       CODE(L'STOP),STOP\n         LA        3,2(3)            INCRE LOC COUNTER\n         LA        10,2(10)          INCRE ADDRESS\n         LA        5,32(5)           INCREMENT CARD TABLE ADDRESS\n         B         READCARD\nNOTANY   L         6,=C'NOGO'\n         OI        FLAG,B'00000100'  SET FLAG,ILLEGAL OPCODE\n         LA        5,32(5)           INCREMENT CARD TABLE ADDRESS\n         B         READCARD\nRESTORE  L         13,4(13)\n         LM        2,12,28(13)\n         L         14,12(13)\n         MVI       12(13),X'FF'\n         B         14\nSAVE     DC        18F'0'\nADD      DC        X'5800A0005A00A0005000A000'\nSUB      DC        X'5800A0005B00A0005000A000'\nMUL      DC        X'5810A0005C00A0005010A000'\nDIV      DC        X'5800A0008E0000205D00A0005010A000'\nOUT      DC        X'5810A0000579'\nIN       DC        X'4110A0000578'\nBRM      DC        X'5800A00012004740A000'\nMOVE     DC        X'D203A000A000'\nBR       DC        X'47F0A000'\nSTOP     DC        X'07FB'\n         DC        C' '\nCARD     DS        80C\nCARDTP   DS        31C\n         LTORG\nPASTWO   CSECT\n         B         12(,15)\n         DC        X'07'\n         DC        CL7'PASTWO'\n         STM       14,12,12(13)\n         BALR      12,0\n         USING     *,12\n         LA        8,INPUT           LOAD ADD OF INPUT\n         LA        9,OUTPUT          LOAD ADD OF OUTPUT\n         L         6,=C'GO  '        DETERMINES EXECUTION\n         L         10,=V(CODETB)     LOAD ADD OF CODE TABLE\n         L         5,=V(CARDTB)      LOAD ADD OF CARD TABLE\n         USING     CARDFORM,5        FLOATING DSECT OVER CARD TABLE\n         USING     CODEDS,10         FLOATING DSECT OVER CODE TABLE\n         B         *+8               BRANCH AROUND INCREMENT\nREADTB   LA        5,32(5)           INCRE CARD TABLE LOC\n         MVC       PRNTLB(31),LABEL\n         XPRNT     PRNTLB-1,32       PRINT CARD IMAGE\n         CLI       FLAG,X'40'        TEST FOR ERROR PASSONE\n         BE        COMMENT           NO ERRORS PASSONE\n         CLI       FLAG,X'44'        ILLEGAL OPCODE ?\n         BNE       TESTC0\n         XPRNT     =C' **** ILLEGAL  OPCODE',21\n         B         READTB            READ NEXT CARD IMAGE\nTESTC0   CLI       FLAG,X'4C'        ERROR?\n         BNE       READTB            READ NEXT CARD IMAGE\n         XPRNT     =C' **** MULTIPLY  DEFINED SYMBOL &&ILLEGAL OPCODE',4\n               48\n         B         READTB            READ NEXT CARD IMAGE\nCOMMENT  CLI       LABEL,C'*'        COMMENT CARD ?\n         BE        READTB            READ NEXT CARD IMAGE\n         CLC      =CL5'END',OPCODE   END CARD ?\n         BE        EXECUTE           EXECUTE PROGRAM\n         CLC      =CL5'STOP',OPCODE  STOP CARD ?\n         BNE       DCONSTX\n         LA        10,2(10)\n         B         READTB            READ NEXT CARD IMAGE\nDCONSTX  CLC      =CL5'DCON',OPCODE  DCON CARD ?\n         BNE       OPERANDS\n         LCR       4,10              PUT ON FULL WORD BOUNDARY\n         N         4,=X'00000003'\n         AR        10,3\n         LA        10,4(10)          INCRE CODE TABLE ADD\n         B         READTB            READ NEXT CARD IMAGE\nOPERANDS CLI       FLAG,X'48'        CORRECR LABEL ?\n         B         *+10\n         XPRNT     =C' **** MULTIPLY  DEFINED LABEL',29\n         L         4,=X'0000000E'\n         BAL       14,LOOKUP         DO LOOKUP FOR SYMBOL\n         MVC       TEST1(2),FLDISP\n         MVC       DISP1(2),FLDISP\n         NI        TEST1,B'11110000'\n         NC        DISP1,B'0000111111111111'\n         L         4,=X'00000017'\n         BAL       14,LOOKUP         DO SYMBOL LOOKUP\n         MVC       TEST2(2),FLDISP\n         MVC       DISP2(2),FLDISP\n         NI        TEST2,B'11110000'\n         NC        DISP2,B'0000111111111111'\n         CLC      =CL5'ADD',OPCODE   ADD STATEMENT ?\n         BE        AMSST\n         CLC      =CL5'SUB',OPCODE   SUB ST ?\n         BE        AMSST\n         CLC      =CL5'MUL',OPCODE   MUL ST ?\n         BE        AMSST\n         CLC      =CL5'DIV',OPCODE   DIV ST ?\n         BE        DIVST\n         CLC      =CL5'OUT',OPCODE   OUT ST ?\n         BE        OUTINST\n         CLC      =CL5'IN',OPCODE    IN ST ?\n         BE        OUTINST\n         CLC      =CL5'BRM',OPCODE   BRM ST ?\n         BE        BRMST\n         CLC      =CL5'MOVE',OPCODE  MOVE ST ?\n         BE        MOVEST\n         CLI       TEST1,B'11000000'\n         BNE       TESTAG\n         LA        10,4(10)          INCRE CODE LOC\nUNDSYMER XPRNT     =C' **** UNDEFINE D SYMBOL ERROR',29\n         L         6,=C'NOGO'\n         B         READTB            READ NEXT CARD IMAGE\nTESTAG   CLI       TEST1,B'10000000'\n         BNE       STBRCOD\n         LA        10,4(10)\nBRDCONER XPRNT     =C' **** ILLEGAL BRANCH TO DATA',28\n         L         6,=C'NOGO'\n         B         READTB            READ NEXT CARD IMAGE\nSTBRCOD  OC        CODE+2(2),DISP1   STORE DISP\n         LA        10,4(10)\n         B         READTB            READ NEXT CARD IMAGE\nAMSST    CLI       TEST1,B'11000000'\n         BNE       CAMS              TEST 2ND OPERAND\nINAMS    LA        10,12(10)         INCRE LOC COUNTER\n         B         UNDSYMER\nCAMS     CLI       TEST2,B'11000000'  ILLEGAL OPND ?\n         BE        INAMS\n         CLI       TEST1,B'01000000'\n         BNE       CCAMS\nINCRAMS  LA        10,12(10)         INCRE LOC\nLADCONER XPRNT     =C' **** LABEL USED AS DCON-ILLEGAL',32\n         B         READTB            READ NEXT CARD IMAGE\nCCAMS    CLI       TEST2,B'01000000'\n         BE        INCRAMS\n         OC        CODE+2(2),DISP1   STORE DISP\n         OC        CODE+6(2),DISP2   STORE DISP\n         OC        CODE+10(2),DISP1  STORE DISP\n         LA        10,12(10)         INCRE LOC COUNTER\n         B         READTB            READ NEXT CARD IMAGE\nDIVST    CLI       TEST1,B'11000000'  ILL OPND ?\n         BNE       CDIV              TEST 2ND OPND\nINDIV    LA        10,16(10)         INCRE LOC COUNTER\n         B         UNDSYMER\nCDIV     CLI       TEST2,B'11000000'\n         BE        INDIV\n         CLI       TEST1,B'01000000'\n         BNE       CCDIV\nSTDIV    LA        10,16(10)\n         B         LADCONER\nCCDIV    CLI       TEST2,B'01000000'\n         BE        STDIV\n         OC        CODE+2(2),DISP1\n         OC        CODE+10(2),DISP2  STORE DISP\n         OC        CODE+14(2),DISP1  STORE DISP\n         LA        10,16(10)\n         B         READTB            READ NEXT CARD IMAGE\nOUTINST  CLI       TEST1,B'11000000'\n         BNE       COUT\nINOUTX   LA        10,6(10)\n         B         UNDSYMER\nCOUT     CLI       TEST1,B'01000000'\n         BNE       STINOUT\nTSTMV    LA        10,6(10)\n         B         LADCONER\nSTINOUT  OC        CODE+2(2),DISP1   STORE DISP\n         B         READTB            READ NEXT CARD IMAGE\nBRMST    CLI       TEST1,B'11000000'\n         BNE       CBRM\nSTBRM    CLI       TEST1,B'01000000'\n         BNE       STOBRM\n         LA        10,10(10)\n         B         LADCONER\nCBRM     LA        10,10(10)\n         B         UNDSYMER\n         CLI       TEST2,B'11000000'\n         BE        CBRM\n         CLI       TEST2,B'10000000'  ILLEGAL BRANCH\n         BNE       STBRM\n         LA        10,10(10)\n         B         BRDCONER\nSTOBRM   OC        CODE+2(2),DISP1   STORE DISP\n         OC        CODE+8(2),DISP2   STORE DISP\n         LA        10,10(10)\n         B         READTB            READ NEXT CARD IMAGE\nMOVEST   CLI       TEST1,B'11000000'\n         BE        INOUTX\n         CLI       TEST2,B'11000000'  ILL OPND\n         BE        INOUTX\n         CLI       TEST1,B'01000000'\n         BE        TSTMV\n         CLI       TEST2,B'01000000'\n         BE        TSTMV\n         OC        CODE+2(2),DISP1   STORE DISP\n         OC        CODE+4(2),DISP2   STORE DISP\n         LA        10,6(10)\n         B         READTB            READ NEXT CARD IMAGE\nLOOKUP   L         2,=V(SYMBOLTB)\n         USING     SYMBOLDS,2        FLOATING DSECT OVER SYMBOL TABLE\n         B         *+8\nINCREX   LA        2,10(2)           INCRE LOC\n         CLC      =CL8' ',SYMBOL     LOC BLANK ?\n         BE        ERROR\n         CLC       0(4,5),SYMBOL\n         BNE       INCREX\n         BR        14                RETURN\nERROR    OI        FLDISP,B'11000000' SET FLAG\n         BR        14                RETURN\nEXECUTE  CLI       FLAG,X'48'\n         BE        TERMIN            TERMINAT PROGRAM\n         ST        6,TEST3\n         CLC      =CL4'NOGO',TEST3   TEST FOR ABORTION\n         BNE       NOTERMIN\nTERMIN   XPRNT     =C' ****PROGRAM  TERMINATED DUE TO ERRORS',38\nREADAG   XREAD     CARDX,80\n         CLC      =CL2'$*',CARDX     $* CARD ?\n         BNE       READAG            READ TILL FIND $* CARD\n         B         RESTORE2          RETURN TO TOPAL\nNOTERMIN L         10,=V(CODETB)     LOAD ADD CODE TABLE\n         XPRNT     =C'1 DUMP OF CODE ',15\n         XDUMP     0(10),800\n         XPRNT     =C'1',1\n         L         10,=V(CODETB)\n         BALR      11,10             EXECUTE CODE\n         XPRNT     =C'1 DUMP OF CODE ',15\n         L         10,=V(CODETB)\n         XDUMP     0(10),800\n         XREAD     CARDX,80\n         CLC      =CL2'$*',CARDX\n         BE        RESTORE2\n         XPRNT     =C' **** ERROR-AL L CARDS WERE NOT PROCESSED',41\n         B         READAG\nOUTPUT   L         1,0(1)\n         XDECO     1,OUTX\n         XPRNT     OUTX-1\n         BR        7\nINPUT    XREAD     CARDX,80\n         CLC      =CL2'$*',CARDX\n         BNE       CONVERTX\n         XPRNT     =C' **** PROGRAM  ABORTED-READ BEYOND END OF FILE',46\n               6\n         XPRNT     =C'1  DUMP OF CODE',15\n         L         10,=V(CODETB)\n         XDUMP     0(10),800\n         B         RESTORE2\nCONVERTX LR        3,1\n         L         3,0(3)\n         XDECI     3,CARDX\n         BR        7\nRESTORE2 LM        2,12,28(13)\n         L         14,12(13)\n         BR        14\nCARDX    DS        80C\nTEST1    DC        H'0'\nTEST2    DC        H'0'\nDISP1    DC        H'0'\nDISP2    DC        H'0'\nTEST3    DC        F'0'\n         DC        C' '\nOUTX     DC        F'0'\n         DC        C' '\nPRNTLB   DS        31C\n         LTORG\nCODETB   CSECT\n         DS        50CL16' '\nCODEDS   DSECT\nCODE     DS        CL16\nSYMBOLTB CSECT\n         DS        50CL10' '\nSYMBOLDS DSECT\nSYMBOL   DS        CL8\nFLDISP   DS        CL2\nCARDTB   CSECT\n         DS        50CL32' '\nCARDFORM DSECT\nLABEL    DS        CL9\nOPCODE   DS        CL5\nOPND1    DS        CL9\nOPND2    DS        CL8\nFLAG     DS        CL1\n         END\n$ENTRY\n$$             ' PROGRAM NUMBER 2 '\n* THIS IS PROGRAM NUMBER 2\n* PROGRAM FINDS MAX & MIN OF SET\n* OF INTEGERS<10000000. MIN IS\n* MULT BY 5,MAX IS DIV BY 4\n* AND SUM OF RESULTS PRINTED. -1\n* READ IN HALTS PROGRAM\n*        *    *        *\nLOOP1    IN   N\n         BRM  N        QUIT\n         MOVE TEMP     N\n         SUB  TEMP     MAX\n* IF NEG RESULT OLD MAX STANDS\n         BRM  TEMP     TRYMIN\n         MOVE MAX      N\nTRYMIN   MOVE TEMP     N\n         SUB  TEMP     MIN\n* IF NEG RESULT THEN NEW MIN\n         BRM  TEMP     NEWMIN\n         BR   LOOP1\nNEWMIN   MOVE MIN      N\n         BR   LOOP1\nN        DCON 0\nMAX      DCON -4\nMIN      DCON 10000000\nTEMP     DCON 0\nFOUR     DCON 4\nFIVE     DCON 5\nQUIT     MUL  MIN      FIVE\n         DIV  MAX      FOUR\n         ADD  MIN      MAX\n         OUT  MIN\n         STOP\n         END\n200   DATA\n         20     DATA\n                5000      DATA\n  18    DATA\n         64     DATA\n     2    DATA\n          -1       DATA TRAILER\n$*\n$$             ' PROGRAM NUMBER 3 '\n* PROGRAM NUMBER 2 WITH ERRORS\n*        *    *        *\nLOOP1    IN   N\n         BRM  N        QUIT\n         MOVE TEMP     N\n         SUB  TEMP     MAX\n* IF NEG RESULT OLD MAX STANDS\n         BRM  TEMP     TRYMIN\n         MOVE MAX      N\nTRYMIN   MOVE TEMP     N\n         SUB  TEMP     TRYMIN\n* IF NEG RESULT THEN NEW MIN\n         BRM  TEMP     NEWMIN\n         BR   MAX\nNEWMIN   MOVE MIN      N\n         BR   LOOP1\nN        DCON 0\nMAX      DCON -4\nTEMP     DCON 0\nFOUR     DCON 4\nFIVE     DCON 5\nMAX      DCON 1000000\nQUIT     MUL  MIN      FIVE\n         STM  MAX      FOUR\n         ADD  MIN      MAX\n         OUT  MIN\n         STOP\n         END\n200   DATA\n         20     DATA\n                5000      DATA\n  18    DATA\n         64     DATA\n     2    DATA\n          -1       DATA TRAILER\n$*\n$$             ' PROGRAM NUMBER 4 '\n* PROGRAM NUMBER 1 WITH ERRORS\n*        *    *        *\n         IN   N\n         OUT  N\n         MOVE NFAC     N\n         MOVE M        N\n         SUB  N        ONE\n* LOOP TO DO COMPUTATION\nLOOP     SUB  N        ONE\n         BRM  DONE\n         SUB  M        ONE\n         MUL  NFAC     M\n         BR   POOL\nDONE     OUT  NFAC\n         STOP\nN        DCON 0\nM        DCON 0\nNFAC     DCON 0\nONE      DCON 1\n         END\n    5\n$*\n$JOB   ASSIST  PROGTEST\n*        *** FINAL PROJECT - FIRST ASSEMBLER COURSE.  THIS IS A\n*        FINAL WORKING VERSION OF THE PREVIOUS PROGRR\n*        FINAL WORKING VERSION OF THE PREVIOUS PROGRAM.\n*        545 STMTS,  PRINTS 10 PAGES, EXECUTES 26539 INSTRUCTIONS,\n*        THEN QUITS NORMALLY.\n*        CMPSC 410.1 - FALL 1970 - PSU-INSTRUCTOR -C.HUGHES.\nTOPAL    CSECT\n         B         10(,15)\n         DC        X'05'\n         DC        CL5'TOPAL'\n         STM       14,12,12(13)\n         BALR      12,0\n         USING     *,12              SET UP BASE REG.\n* SET UP REGISTER SAVE AREA\nPASSTWO  LR        5,13\n         LA        13,SAVE\n         ST        13,8(5)\n         ST        5,4(13)\n* TEST AREA FOR /* CARD OR USER $$ JOB CARD\nTOPALX   XREAD     CARD,80           READ FOR JOB CARD OR /* CARD\n         BZ        TEST              IF NOT /* CARD BRANCH TO TEST\n         XPRNT     =C'1ALL JOBS HAVE BEEN PROCESSED,CONTROL BEING RETURN\n               NED TO ASSEMBLER',65\n         B         RESTORE\nTEST     CLC       CARD(2),=C'$$'    TEST FOR JOB CARD\n         BE        GO                IF JOB CARD GO AHEAD\n         XPRNT     =C'1****ABNORMAL TERMINATION-NO JOB CARD',37\n         B         RESTORE           RETURN CONTROL TO ASSEMBLER\nGO       XPRNT     =C'1',1           SKIP TOP OF PAGE\n         XPRNT     CARD-1,81         PRINT USER JOB AND ID CARD\n*      INITIALIZE  SYMBOL TABLE TO BLANKS\n         L         2,=V(SYMBOLTB)    LOAD ADDRESS OF SYMBOL TABLE\n         L         3,=F'125'\n         L         4,=C'    '\nBLNKOUT  ST        4,0(2)            STORE BLANKS\n         LA        2,4(2)            INCREMENT REGISTER\n         BCT       3,BLNKOUT         DECREASE COUNTER BY ONE\n* INITIALIZE CODE AREA TO HEX F'S\n         L         2,=V(CODETB)      LOAD ARDRESS OF CODE TABLE\n         L         4,=X'FFFFFFFF'    LOAD REGISTER WITH HEX F'S\n         L         3,=F'200'\nFOUT     ST        4,0(2)            LOAD TABLE INITIALLY\n         LA        2,4(2)            INCREMENT\n         BCT       3,FOUT            SUB. ONE FROM COUNTER\n* INITIALIZE CARD AREA TO BLANKS\n         L         2,=V(CARDTB)      LAOD ADDRESS OF CARD TABLE\n         L         3,=F'400'\n         L         4,=C'    '        LOAD REG. WITH BLANKS\nBOUT     ST        4,0(2)            LOAD TABLE\n         LA        2,4(2)            INCREMENT TABLE ADDRESS\n         BCT       3,BOUT            SUB ONE FROM COUNTER\n         L         6,=C'GO  '        LOAD REG TO SHOW GO WITH EXECUTION\n         EJECT\n* READ IN TOPAL CARDS\n         L         10,=V(CODETB)     LOAD ADDRESS OF CODETABLE\n         L         5,=V(CARDTB)      LOAD ADDRESS OF CARD TABLE\n         USING     CARDFORM,5        FLOATING DSECT OVER CARD TABLE\n         USING     CODEDS,10         FLOATING DSECT OVER CODE TABLE\n         SR        3,3               ZERO OUT FOR LOCATION COUNTER\n* READ IN TOPAL CARD AND TEST PARAMETERS\nREADCARD XREAD     CARDTP,31         READ IN TOPAL CARD\n         MVC       LABEL(31),CARDTP  PUT IN CARD TABLE\n         CLI       CARDTP,C'*'       COMMENT CARD ?\n         BNE       ENDCD             NO,TEST FOR END CARD\n         LA        5,32(5)           INCREMENT CARD TABLE ADDRESS\n         B         READCARD          READ IN NEXT CARD\nENDCD    CLC       =CL5'END',OPCODE  END CARD ?\n         BNE       LABELED\n         CL        6,=C'NOGO'\n         BNE       PASS2\n         OI        FLAG,B'00001000'\n* BRANCH TO PASS TWO\nPASS2    L         15,=V(PASTWO)\n         BALR      14,15\n         B         TOPALX\nLABELED  CLC       =CL9' ',LABEL     LABEL ?\n         BE        DCONST\n* SYMBOL STORAGE ROUTINE\n         L         2,=V(SYMBOLTB)    LOAD ADDRESS OF SYMBOL TABLE\n         USING     SYMBOLDS,2        FLOATING DSECT OVER SYMBOL TABLE\nTESTSBL  CLC       =CL8' ',SYMBOL    TEST FOR NO SYMBOL IN TABLE\n         BE        STORESBL\n         CLC       SYMBOL(8),LABEL   TEST FOR DUPLICATE LABEL\n         BNE       INCRE\n         L         6,=C'NOGO'        NO EXECUTION\n         OI        FLAG,B'00001000'  FLAG CARD AREA\n         B         DCONST\nINCRE    LA        2,10(2)           INCREMENT ADDRESS\n         B         TESTSBL\nSTORESBL MVC       SYMBOL(8),LABEL   PUT LABEL IN SYMBOL TABLE\n         CLC       =CL5'DCON',OPCODE TEST IF DCON\n         BE        STDC\n         STH       3,FLDISP          ENTER DISPLACEMENT\n         B         DCONST\nSTDC     LCR       9,3               SET TO FULL WORD BOUNDARY\n         N         9,=X'00000003'\n         AR        3,9\n         STH       3,FLDISP          ENTER DISPLACEMENT\n         OI        FLDISP,B'10000000' SET FLAG THAT DCON\n         B         CONVERT\n         SPACE     5\n* TEST & STORE AREA FOR OPCODES\n* TEST & STORE AREA FOR DCON OPCODE\nDCONST   CLC       =CL5'DCON',OPCODE  DCON?\n         BNE       NOTDCON\nCONVERT  XDECI     7,OPND1\n         LCR       9,10              SET TO FULL WORD BOUNDARY\n         N         9,=X'00000003'\n         AR        10,9\n         ST        7,CODE             STORE VALUE OF DCON IN CODE AREA\n         LA        3,4(3)            INCRE LOC COUNTER\n         LA        10,4(10)          INCRE TABLE ADDRESS\n         LA        5,32(5)           INCREMENT CARD TABLE ADDRESS\n         B         READCARD\n* TEST & STORE AREA FOR ADD OPCODE\nNOTDCON  CLC       =CL5'ADD',OPCODE  ADD INST ?\n         BNE       NOTADD\n         MVC       CODE(L'ADD),ADD   MOVE ADD CODE INTO TABLE\nINCRECT  LA        3,12(3)           INCRE LOC COUNTER\n         LA        10,12(10)         INCRE TABLE ADD.\n         LA        5,32(5)           INCREMENT CARD TABLE ADDRESS\n         B         READCARD\n* TEST & STORE AREA FOR SUBTRACT OPCODE\nNOTADD   CLC       =CL5'SUB',OPCODE  SUB INST ?\n         BNE       NOTSUB\n         MVC       CODE(L'SUB),SUB    MOVE SUB CODE INTO TABLE\n         B         INCRECT\n* TEST & STORE AREA FOR MULTIPLY OPCODE\nNOTSUB   CLC       =CL5'MUL',OPCODE  MUL INST ?\n         BNE       NOTMUL\n         MVC       CODE(L'MUL),MUL   MOVE CODE INTO TABLE\n         B         INCRECT\n* TEST & STORE AREA FOR DIVIDE OPCODE\nNOTMUL   CLC       =CL5'DIV',OPCODE  DIVIDE INST ?\n         BNE       NOTDIV\n         MVC       CODE(L'DIV),DIV   MOVE CODE ONTO TABLE\n         LA        3,16(3)           INCRE LOC COUNTER\n         LA        10,16(10)         INCRE ADDRESS\n         LA        5,32(5)           INCREMENT CARD TABLE ADDRESS\n         B         READCARD\n* TEST & STORE AREA FOR OUT OPCODE\nNOTDIV   CLC       =CL5'OUT',OPCODE  OUT INST ?\n         BNE       NOTOUT\n         MVC       CODE(L'OUT),OUT   MOVE CODE INTO TABLE\nINOUT    LA        3,6(3)            INCRE LOC COUNTER\n         LA        10,6(10)          INCRE ADDRESS\n         LA        5,32(5)           INCREMENT CARD TABLE ADDRESS\n         B         READCARD\n* TEST & STORE AREA FOR IN  OPCODE\nNOTOUT   CLC       =CL5'IN',OPCODE   IN INST ?\n         BNE       NOTIN\n         MVC       CODE(L'IN),IN     LOAD CODE INTO TABLE\n         B         INOUT\n* TEST & STORE AREA FOR BRANCH ON MINUS OPCODE\nNOTIN    CLC       =CL5'BRM',OPCODE  BRM INST ?\n         BNE       NOTBRM\n         MVC       CODE(L'BRM),BRM   MOVE CODE INTO TABLE\n         LA        3,10(3)           INCRE LOC COUNTER\n         LA        10,10(10)         INCRE ADDRESS\n         LA        5,32(5)           INCREMENT CARD TABLE ADDRESS\n         B         READCARD\n* TEST & STORE AREA FOR BRANCH OPCODE\nNOTBRM   CLC       =CL5'BR',OPCODE   BR INST ?\n         BNE       NOTBR\n         MVC       CODE(L'BR),BR\n         LA        3,4(3)            INCRE LOC COUNTER\n         LA        10,4(10)          INCRE ADDRESS\n         LA        5,32(5)           INCREMENT CARD TABLE ADDRESS\n         B         READCARD\n* TEST & STORE AREA FOR MOVE OPCODE\nNOTBR    CLC       =CL5'MOVE',OPCODE  MOVE INST ?\n         BNE       NOTMOVE\n         MVC       CODE(L'MOVE),MOVE  MOVE CODE INTO TABLE\n         B         INOUT\n* TEST & STORE AREA FOR STOP OPCODE\nNOTMOVE  CLC       =CL5'STOP',OPCODE    STOP INST ?\n         BNE       NOTANY\n         MVC       CODE(L'STOP),STOP\n         LA        3,2(3)            INCRE LOC COUNTER\n         LA        10,2(10)          INCRE ADDRESS\n         LA        5,32(5)           INCREMENT CARD TABLE ADDRESS\n         B         READCARD\n* TEST & STORE AREA FOR ILLEGAL OPCODE\nNOTANY   L         6,=C'NOGO'\n         OI        FLAG,B'00000100'  SET FLAG,ILLEGAL OPCODE\n         LA        5,32(5)           INCREMENT CARD TABLE ADDRESS\n         B         READCARD\n* RESTORE REGISTERS AND RETURN CONTROL TO ASSEMBLER\nRESTORE  L         13,4(13)\n         LM        2,12,28(13)\n         L         14,12(13)\n         MVI       12(13),X'FF'\n         BR        14\n         EJECT\nSAVE     DC        18F'0'\nADD      DC        X'5800A0005A00A0005000A000'\nSUB      DC        X'5800A0005B00A0005000A000'\nMUL      DC        X'5810A0005C00A0005010A000'\nDIV      DC        X'5800A0008E0000205D00A0005010A000'\nOUT      DC        X'5810A0000579'\nIN       DC        X'4110A0000578'\nBRM      DC        X'5800A00012004740A000'\nMOVE     DC        X'D203A000A000'\nBR       DC        X'47F0A000'\nSTOP     DC        X'07FB'\n         DC        C' '\nCARD     DS        80C\nCARDTP   DS        31C\n         LTORG\n         EJECT\n* PASS TWO AND SAVE AREA SETUP FOR PASS TWO\nPASTWO   CSECT\n         B         12(,15)\n         DC        X'07'\n         DC        CL7'PASTWO'\n         STM       14,12,12(13)\n         BALR      12,0\n         USING     *,12\n         LA        8,INPUT           LOAD ADD OF INPUT\n         LA        9,OUTPUT          LOAD ADD OF OUTPUT\n         L         6,=C'GO  '        DETERMINES EXECUTION\n         L         10,=V(CODETB)     LOAD ADD OF CODE TABLE\n         L         5,=V(CARDTB)      LOAD ADD OF CARD TABLE\n         USING     CARDFORM,5        FLOATING DSECT OVER CARD TABLE\n         USING     CODEDS,10         FLOATING DSECT OVER CODE TABLE\n         B         *+8               BRANCH AROUND INCREMENT\n* READ CARD IMAGE FROM CARD TABLE\nREADTB   LA        5,32(5)           INCRE CARD TABLE LOC\n         MVC       PRNTLB(31),LABEL\n         XPRNT     PRNTLB-1,32       PRINT CARD IMAGE\n* TEST FOR ERRORS FROM PASS ONE\n         CLI       FLAG,X'40'        TEST FOR ERROR PASSONE\n         BE        COMMENT           NO ERRORS PASSONE\n         CLI       FLAG,X'44'        ILLEGAL OPCODE ?\n         BNE       TESTC0\n         XPRNT     =C' **** ILLEGAL  OPCODE',21\n         B         READTB            READ NEXT CARD IMAGE\nTESTC0   CLI       FLAG,X'4C'        ERROR?\n         BNE       COMMENT\n         XPRNT     =C' **** MULTIPLY  DEFINED SYMBOL &&ILLEGAL OPCODE',4\n               48\n         B         READTB            READ NEXT CARD IMAGE\n* TEST FOR CERTAIN OPCODES\nCOMMENT  CLI       LABEL,C'*'        COMMENT CARD ?\n         BE        READTB            READ NEXT CARD IMAGE\n         CLC      =CL5'END',OPCODE   END CARD ?\n         BE        EXECUTE           EXECUTE PROGRAM\n         CLC      =CL5'STOP',OPCODE  STOP CARD ?\n         BNE       DCONSTX\n         LA        10,2(10)\n         B         READTB            READ NEXT CARD IMAGE\nDCONSTX  CLC      =CL5'DCON',OPCODE  DCON CARD ?\n         BNE       OPERANDS\n         CLI       FLAG,X'48'        CORRECR LABEL ?\n         BNE       *+10\n         XPRNT     =C' **** MULTIPLY  DEFINED LABEL',29\n         LCR       4,10              PUT ON FULL WORD BOUNDARY\n         N         4,=X'00000003'\n         AR        10,4\n         LA        10,4(10)          INCRE CODE TABLE ADD\n         B         READTB            READ NEXT CARD IMAGE\nOPERANDS CLI       FLAG,X'48'        CORRECR LABEL ?\n         BNE       *+10\n         XPRNT     =C' **** MULTIPLY  DEFINED LABEL',29\n* BRANCH TO LOOKUP ROUTINE FOR DISPLACEMENTS\n         MVC       OPERAND(8),OPND1\n         BAL       14,LOOKUP         DO LOOKUP FOR SYMBOL\n         MVC       TEST1(2),FLDISP\n         MVC       DISP1(2),FLDISP\n         NI        TEST1,B'11110000'\n         MVC       OPERAND(8),OPND2\n         BAL       14,LOOKUP         DO SYMBOL LOOKUP\n         MVC       TEST2(2),FLDISP\n         MVC       DISP2(2),FLDISP\n         NI        TEST2,B'11110000'\n         SPACE     5\n* FIND CORRESPONDING OPCODE\n         CLC      =CL5'ADD',OPCODE   ADD STATEMENT ?\n         BE        AMSST\n         CLC      =CL5'SUB',OPCODE   SUB ST ?\n         BE        AMSST\n         CLC      =CL5'MUL',OPCODE   MUL ST ?\n         BE        AMSST\n         CLC      =CL5'DIV',OPCODE   DIV ST ?\n         BE        DIVST\n         CLC      =CL5'OUT',OPCODE   OUT ST ?\n         BE        OUTINST\n         CLC      =CL5'IN',OPCODE    IN ST ?\n         BE        OUTINST\n         CLC      =CL5'BRM',OPCODE   BRM ST ?\n         BE        BRMST\n         CLC      =CL5'MOVE',OPCODE  MOVE ST ?\n         BE        MOVEST\n* TEST AREA FOR ILLEGAL CODING , ALSO STORES DISPLACEMENTS IN CODE AREA\n* TEST & STORE DISPLACEMENT AREA FOR BR OPCODE\n         CLI       TEST1,B'11000000'\n         BNE       TESTAG\n         LA        10,4(10)          INCRE CODE LOC\nUNDSYMER XPRNT     =C' **** UNDEFINED  SYMBOL ERROR',29\n         L         6,=C'NOGO'\n         B         READTB            READ NEXT CARD IMAGE\nTESTAG   CLI       TEST1,B'10000000'\n         BNE       STBRCOD\n         LA        10,4(10)\nBRDCONER XPRNT     =C' **** ILLEGAL BRANCH TO DATA',28\n         L         6,=C'NOGO'\n         B         READTB            READ NEXT CARD IMAGE\nSTBRCOD  OC        CODE+2(2),DISP1   STORE DISP\n         LA        10,4(10)\n         B         READTB            READ NEXT CARD IMAGE\n* TEST & STORE DISPLACEMENT AREA FOR ADD,SUB,MUL OPCODES\nAMSST    CLI       TEST1,B'11000000'\n         BNE       CAMS              TEST 2ND OPERAND\nINAMS    LA        10,12(10)         INCRE LOC COUNTER\n         B         UNDSYMER\nCAMS     CLI       TEST2,B'11000000'  ILLEGAL OPND ?\n         BE        INAMS\n         CLI       TEST1,X'00'\n         BNE       CCAMS\nINCRAMS  LA        10,12(10)         INCRE LOC\nLADCONER XPRNT     =C' **** USING INSTRUCTION AS DATA ',32\n         B         READTB            READ NEXT CARD IMAGE\nCCAMS    CLI       TEST2,X'00'\n         BE        INCRAMS\n         OC        CODE+2(2),DISP1   STORE DISP\n         OC        CODE+6(2),DISP2   STORE DISP\n         OC        CODE+10(2),DISP1  STORE DISP\n         LA        10,12(10)         INCRE LOC COUNTER\n         B         READTB            READ NEXT CARD IMAGE\n* TEST & STORE DISPLACEMENT AREA FOR DIV OPCODE\nDIVST    CLI       TEST1,B'11000000'  ILL OPND ?\n         BNE       CDIV              TEST 2ND OPND\nINDIV    LA        10,16(10)         INCRE LOC COUNTER\n         B         UNDSYMER\nCDIV     CLI       TEST2,B'11000000'\n         BE        INDIV\n         CLI       TEST1,X'00'\n         BNE       CCDIV\nSTDIV    LA        10,16(10)\n         B         LADCONER\nCCDIV    CLI       TEST2,X'00'\n         BE        STDIV\n         OC        CODE+2(2),DISP1\n         OC        CODE+10(2),DISP2  STORE DISP\n         OC        CODE+14(2),DISP1  STORE DISP\n         LA        10,16(10)\n         B         READTB            READ NEXT CARD IMAGE\n* TEST & STORE DISPLACEMENT AREA FOR OUT AND IN OPCODES\nOUTINST  CLI       TEST1,B'11000000'\n         BNE       COUT\nINOUTX   LA        10,6(10)\n         B         UNDSYMER\nCOUT     CLI       TEST1,X'00'\n         BNE       STINOUT\nTSTMV    LA        10,6(10)\n         B         LADCONER\nSTINOUT  OC        CODE+2(2),DISP1   STORE DISP\n         LA        10,6(10)\n         B         READTB            READ NEXT CARD IMAGE\n* TEST & STORE DISPLACEMENT AREA FOR BRM OPCODE\nBRMST    CLI       TEST1,B'11000000'\n         BE        CBRM\nSTBRM    CLI       TEST1,X'00'\n         BNE       STOBRM\n         LA        10,10(10)\n         B         LADCONER\nCBRM     LA        10,10(10)\n         B         UNDSYMER\n         CLI       TEST2,B'11000000'\n         BE        CBRM\n         CLI       TEST2,B'10000000'  ILLEGAL BRANCH\n         BNE       STBRM\n         LA        10,10(10)\n         B         BRDCONER\nSTOBRM   OC        CODE+2(2),DISP1   STORE DISP\n         OC        CODE+8(2),DISP2   STORE DISP\n         LA        10,10(10)\n         B         READTB            READ NEXT CARD IMAGE\n* TEST & STORE DISPLACEMENT AREA FOR MOVE OPCODE\nMOVEST   CLI       TEST1,B'11000000'\n         BE        INOUTX\n         CLI       TEST2,B'11000000'  ILL OPND\n         BE        INOUTX\n         CLI       TEST1,X'00'\n         BE        TSTMV\n         CLI       TEST2,X'00'\n         BE        TSTMV\n         OC        CODE+2(2),DISP1   STORE DISP\n         OC        CODE+4(2),DISP2   STORE DISP\n         LA        10,6(10)\n         B         READTB            READ NEXT CARD IMAGE\n         SPACE     5\n* SYMBOL LOOKUP TABLE FOR DISPLACEMENTS\nLOOKUP   L         2,=V(SYMBOLTB)\n         USING     SYMBOLDS,2        FLOATING DSECT OVER SYMBOL TABLE\n         B         *+8\nINCREX   LA        2,10(2)           INCRE LOC\n         CLC      =CL8' ',SYMBOL     LOC BLANK ?\n         BE        ERROR\n         CLC       SYMBOL(8),OPERAND\n         BNE       INCREX\n         BR        14                RETURN\nERROR    OI        FLDISP,B'11000000' SET FLAG\n         BR        14                RETURN\n         SPACE     5\n* EXECUTE CODE AREA\nEXECUTE  CLI       FLAG,X'48'\n         BE        TERMIN            TERMINAT PROGRAM\n         ST        6,TEST3\n         CLC      =CL4'NOGO',TEST3   TEST FOR ABORTION\n         BNE       NOTERMIN\n* AREA TO TERMINATE TOPAL PROGRAM\nTERMIN   XPRNT     =C' ****PROGRAM  TERMINATED DUE TO ERRORS',38\nREADAG   XREAD     CARDX,80\n         CLC      =CL2'$*',CARDX     $* CARD ?\n         BNE       READAG            READ TILL FIND $* CARD\n         B         RESTORE2          RETURN TO TOPAL\n* AREA TO EXECUTE TOPAL PROGRAM\nNOTERMIN L         10,=V(CODETB)     LOAD ADD CODE TABLE\n         XPRNT     =C'1 DUMP OF CODE ',15\n         XDUMP     0(10),800\n         XPRNT     =C'3',1\n         L         10,=V(CODETB)\n         BALR      11,10             EXECUTE CODE\n         XPRNT     =C'3 DUMP OF CODE ',15\n         L         10,=V(CODETB)\n         XDUMP     0(10),800\n         XREAD     CARDX,80\n         CLC      =CL2'$*',CARDX\n         BE        RESTORE2\n         XPRNT     =C' ****WARNING-ALL CARDS WERE NOT PROCESSED',41\n         B         READAG\n         SPACE     5\n* OUTPUT ROUTINE\nOUTPUT   XDECO     1,OUTX\n         XPRNT     OUTX-16,30\n         BR        7\n* INPUT ROUTINE\nINPUT    XREAD     CARDX,80\n         CLC      =CL2'$*',CARDX\n         BNE       CONVERTX\n         XPRNT     =C' **** PROGRAM  ABORTED-READ BEYOND END OF FILE',46\n               6\n         XPRNT     =C'3  DUMP OF CODE',15\n         L         10,=V(CODETB)\n         XDUMP     0(10),800\n         B         RESTORE2\nCONVERTX LR        3,1\n         XDECI     4,CARDX\n         ST        4,0(,3)\n         BR        7\n* RESTORE REGISTERS FRO PASS TWO AND RETURN TO PASS ONE\nRESTORE2 LM        2,12,28(13)\n         L         14,12(13)\n         BR        14\n         EJECT\nOPERAND  DS        8C\nCARDX    DS        80C\nTEST1    DC        H'0'\nTEST2    DC        H'0'\nDISP1    DC        H'0'\nDISP2    DC        H'0'\nTEST3    DC        F'0'\n         DC        CL16'0THE OUTPUT IS  '\nOUTX     DC        F'0'\n         DC        C' '\nPRNTLB   DS        31C\n         LTORG\n         EJECT\n* CONTROL SECTIONS FOR STORAGE OF TABLES\n* ALSO DSECTS FOR FLOATING DSECT OVER THE RESPECTIVE CONTROL STORAGE\n* SECTIONS\nCODETB   CSECT\n         DS        50CL16' '\nCODEDS   DSECT\nCODE     DS        CL16\nSYMBOLTB CSECT\n         DS        50CL10' '\nSYMBOLDS DSECT\nSYMBOL   DS        CL8\nFLDISP   DS        CL2\nCARDTB   CSECT\n         DS        50CL32' '\nCARDFORM DSECT\nLABEL    DS        CL9\nOPCODE   DS        CL5\nOPND1    DS        CL9\nOPND2    DS        CL8\nFLAG     DS        CL1\n         END\n$ENTRY\n$$             ' PROGRAM NUMBER 1 '\n* DONT FORGET TO SUPPLY THE PROPER DELIMITERS\n* THIS IS PROGRAM NUMBER 1\n* RECOGNIZE THIS ONE ?\n* COMPUTE N!\n*        *    *        *\n         IN   N\n         OUT  N\n         MOVE NFAC     N\n         MOVE M        N\n         SUB  N        ONE\n* LOOP TO DO COMPUTATION\nLOOP     SUB  N        ONE\n         BRM  N        DONE\n         SUB  M        ONE\n         MUL  NFAC     M\n         BR   LOOP\nDONE     OUT  NFAC\n         STOP\nN        DCON 0\nM        DCON 0\nNFAC     DCON 0\nONE      DCON 1\n         END\n     5\n$*\n$$             ' PROGRAM NUMBER 2 '\n* THIS IS PROGRAM NUMBER 2\n* PROGRAM FINDS MAX & MIN OF SET\n* OF INTEGERS<10000000. MIN IS\n* MULT BY 5,MAX IS DIV BY 4\n* AND SUM OF RESULTS PRINTED. -1\n* READ IN HALTS PROGRAM\n*        *    *        *\nLOOP1    IN   N\n         BRM  N        QUIT\n         MOVE TEMP     N\n         SUB  TEMP     MAX\n* IF NEG RESULT OLD MAX STANDS\n         BRM  TEMP     TRYMIN\n         MOVE MAX      N\nTRYMIN   MOVE TEMP     N\n         SUB  TEMP     MIN\n* IF NEG RESULT THEN NEW MIN\n         BRM  TEMP     NEWMIN\n         BR   LOOP1\nNEWMIN   MOVE MIN      N\n         BR   LOOP1\nN        DCON 0\nMAX      DCON -4\nMIN      DCON 10000000\nTEMP     DCON 0\nFOUR     DCON 4\nFIVE     DCON 5\nQUIT     MUL  MIN      FIVE\n         DIV  MAX      FOUR\n         ADD  MIN      MAX\n         OUT  MIN\n         STOP\n         END\n200   DATA\n         20     DATA\n                5000      DATA\n  18    DATA\n         64     DATA\n     2    DATA\n          -1       DATA TRAILER\n$*\n$$             ' PROGRAM NUMBER 3 '\n* PROGRAM NUMBER 2 WITH ERRORS\n*        *    *        *\nLOOP1    IN   N\n         BRM  N        QUIT\n         MOVE TEMP     N\n         SUB  TEMP     MAX\n* IF NEG RESULT OLD MAX STANDS\n         BRM  TEMP     TRYMIN\n         MOVE MAX      N\nTRYMIN   MOVE TEMP     N\n         SUB  TEMP     TRYMIN\n* IF NEG RESULT THEN NEW MIN\n         BRM  TEMP     NEWMIN\n         BR   MAX\nNEWMIN   MOVE MIN      N\n         BR   LOOP1\nN        DCON 0\nMAX      DCON -4\nTEMP     DCON 0\nFOUR     DCON 4\nFIVE     DCON 5\nMAX      DCON 1000000\nQUIT     MUL  MIN      FIVE\n         STM  MAX      FOUR\n         ADD  MIN      MAX\n         OUT  MIN\n         STOP\n         END\n200   DATA\n         20     DATA\n                5000      DATA\n  18    DATA\n         64     DATA\n     2    DATA\n          -1       DATA TRAILER\n$*\n$$             ' PROGRAM NUMBER 4 '\n* PROGRAM NUMBER 1 WITH ERRORS\n*        *    *        *\n         IN   N\n         OUT  N\n         MOVE NFAC     N\n         MOVE M        N\n         SUB  N        ONE\n* LOOP TO DO COMPUTATION\nLOOP     SUB  N        ONE\n         BRM  DONE\n         SUB  M        ONE\n         MUL  NFAC     M\n         BR   POOL\nDONE     OUT  NFAC\n         STOP\nN        DCON 0\nM        DCON 0\nNFAC     DCON 0\nONE      DCON 1\n         END\n    5\n$*\n$$     ' PROGRAM 1 WITH NO DATA CARDS '\n* COMPUTE N !\n         IN   N\n         OUT  N\n         MOVE NFAC     N\n         MOVE M        N\n         SUB  N        ONE\n* LOOP TO DO COMPUTATION\nLOOP     SUB  N        ONE\n         BRM  N        DONE\n         SUB  M        ONE\n         MUL  NFAC     M\n         BR   LOOP\nDONE     OUT  NFAC\n         STOP\nN        DCON          0\nM        DCON          0\nNFAC     DCON          0\nONE      DCON          1\n         END\n$*\n$$      ' PROGRAM 1 WITH EXTRA DATA CARDS '\n* DONT FORGET TO SUPPLY THE PROPER DELIMITERS\n* THIS IS PROGRAM NUMBER 1\n* RECOGNIZE THIS ONE ?\n* COMPUTE N!\n*        *    *        *\n         IN   N\n         OUT  N\n         MOVE NFAC     N\n         MOVE M        N\n         SUB  N        ONE\n* LOOP TO DO COMPUTATION\nLOOP     SUB  N        ONE\n         BRM  N        DONE\n         SUB  M        ONE\n         MUL  NFAC     M\n         BR   LOOP\nDONE     OUT  NFAC\n         STOP\nN        DCON 0\nM        DCON 0\nNFAC     DCON 0\nONE      DCON 1\n         END\n     5\n      4\n$*\n$JOB   ASSIST  PROGTEST\n*        *** FINAL PROJECT - FIRST ASSEMBLER COURSE.   1044 STMTS,\n*        USER PROGRAM PRINTS  APPROX 2 PAGES OF OUTPUT, THEN ABENDS\n*        WITH 0C4 COMPLETION CODE AFTER 48931 INSTRUCTIONS EXECUTED.\n*        **NOTE** REQUIRES  APPROX 6.5 SECONDS TOTAL TIME ON 360/67.\n*        UNDER NOLARGE,NOCMPRS, ASSEMBLER REQUIRES  78 BYTES/STMT,\n*        AND ASSEMBLES AT RATE OF 371 STMTS/SECOND (2.814 SECS).\n*        EXECUTION OF 48931 INSTRUCTIONS REQUIRED 2.970 SECONDS, AT\n*        RATE 16475 PER SECOND.\n*        TOTAL DYNAMIC STORAGE REQUIRED WAS  APPROX 82K.\n         TITLE 'CONSTRUCTION OF ASSEMBLER FOR CS 410'\nDRIVER   CSECT\n         BALR   12,0\n         USING  *,12\n         LA     7,LABT       FOR USE A BASE FOR DUMMY CSECT\n         LA     2,DATAAD\n         ST     14,SAV14\n         LA     6,SOURC      REGISTER 6 WILL BE USED TO RECORD ADDRESS\n*                            OF FIRST CARD STORED\n         LR     3,6          REGISTER 3 WILL BE USED TO RECORD ADDRESS\n*                            OF LAST CARD READ\n         LA     13,SAVDR     LOAD REGISTER 13 WITH ADDRESS OF DRIVER'S\n         LA     10,LABT        LOAD ADDRESS OF LABLE TABLE IN REG 10\n         LA     11,OUTP      USE REGISTER 11 TO INDICATE LOCATION OF\n*                            CODED PROGRAM\n         LA     5,BYPASS     LOAD ADDRESS OF FINAL OPERATION FOR USE\n*                            IN EVENT OF ERR DISCOVERY IN SUBROUTINE\n         MVI     ESLET+X'C1',X'AA'  PLACE LETTER IN PLACE OF 0 FOR\n*                            TEST\n         MVI     ESLET+X'C2',X'BB'  PLACE LETTER IN PLACE OF 0 FOR\n*                            TEST\n         MVI     ESLET+X'C3',X'CC'  PLACE LETTER IN PLACE OF 0 FOR\n*                            TEST\n         MVI     ESLET+X'C4',X'DD'  PLACE LETTER IN PLACE OF 0 FOR\n*                            TEST\n         MVI     ESLET+X'C5',X'EE'  PLACE LETTER IN PLACE OF 0 FOR\n*                            TEST\n         MVI     ESLET+X'C6',X'FF'  PLACE LETTER IN PLACE OF 0 FOR\n*                            TEST\n         MVI     ESLET+X'C7',X'11'  PLACE LETTER IN PLACE OF 0 FOR\n*                            TEST\n         MVI     ESLET+X'C8',X'11'  PLACE LETTER IN PLACE OF 0 FOR\n*                            TEST\n         MVI     ESLET+X'C9',X'11'  PLACE LETTER IN PLACE OF 0 FOR\n*                            TEST\n         MVI     ESLET+X'D1',X'11'  PLACE LETTER IN PLACE OF 0 FOR\n*                            TEST\n         MVI     ESLET+X'D2',X'11'  PLACE LETTER IN PLACE OF 0 FOR\n*                            TEST\n         MVI     ESLET+X'D3',X'11'  PLACE LETTER IN PLACE OF 0 FOR\n*                            TEST\n         MVI     ESLET+X'D4',X'11'  PLACE LETTER IN PLACE OF 0 FOR\n*                            TEST\n         MVI     ESLET+X'D5',X'11'  PLACE LETTER IN PLACE OF 0 FOR\n*                            TEST\n         MVI     ESLET+X'D6',X'11'  PLACE LETTER IN PLACE OF 0 FOR\n*                            TEST\n         MVI     ESLET+X'D7',X'11'  PLACE LETTER IN PLACE OF 0 FOR\n*                            TEST\n         MVI     ESLET+X'D8',X'11'  PLACE LETTER IN PLACE OF 0 FOR\n*                            TEST\n         MVI     ESLET+X'D9',X'11'  PLACE LETTER IN PLACE OF 0 FOR\n*                            TEST\n         MVI     ESLET+X'E2',X'11'  PLACE LETTER IN PLACE OF 0 FOR\n*                            TEST\n         MVI     ESLET+X'E3',X'11'  PLACE LETTER IN PLACE OF 0 FOR\n*                            TEST\n         MVI     ESLET+X'E4',X'11'  PLACE LETTER IN PLACE OF 0 FOR\n*                            TEST\n         MVI     ESLET+X'E5',X'11'  PLACE LETTER IN PLACE OF 0 FOR\n*                            TEST\n         MVI     ESLET+X'E6',X'11'  PLACE LETTER IN PLACE OF 0 FOR\n*                            TEST\n         MVI     ESLET+X'E7',X'11'  PLACE LETTER IN PLACE OF 0 FOR\n*                            TEST\n         MVI     ESLET+X'E8',X'11'  PLACE LETTER IN PLACE OF 0 FOR\n*                            TEST\n         MVI     ESLET+X'E9',X'11'  PLACE LETTER IN PLACE OF 0 FOR\n*                            TEST\n         MVI     ESNUM+X'F1',X'11'  PLACE NUMBER IN PLACE OF 0 FOR\n*                            TEST\n         MVI     ESNUM+X'F2',X'22'  PLACE NUMBER IN PLACE OF 0 FOR\n*                            TEST\n         MVI     ESNUM+X'F3',X'33'  PLACE NUMBER IN PLACE OF 0 FOR\n*                            TEST\n         MVI     ESNUM+X'F4',X'44'  PLACE NUMBER IN PLACE OF 0 FOR\n*                            TEST\n         MVI     ESNUM+X'F5',X'55'  PLACE NUMBER IN PLACE OF 0 FOR\n*                            TEST\n         MVI     ESNUM+X'F6',X'66'  PLACE NUMBER IN PLACE OF 0 FOR\n*                            TEST\n         MVI     ESNUM+X'F7',X'77'  PLACE NUMBER IN PLACE OF 0 FOR\n*                            TEST\n         MVI     ESNUM+X'F8',X'88'  PLACE NUMBER IN PLACE OF 0 FOR\n*                            TEST\n         MVI     ESNUM+X'F9',X'99'  PLACE NUMBER IN PLACE OF 0 FOR\n*                            TEST\n         XPRNT  INPUT,11     PRINT TITLE FOR INPUT ECHO CHECK\nINIT     XREAD  CARDA,40     READ INITIAL CARD\n         XPRNT  CRG,41       ECHO CHECK\nCKBEG    CLC    CARDA(5),BEGCK     DETERMINE IF THIS IS THE START OF\n*                            THE PROGRAM\n         BE     FIRST        IF SO, CONTINUE WITH REMAINDER OF\n*                            THE PROGRAM\n         XPRNT  BADBIG,47    IF ANY PROGRAM CARD IS BEFORE BEGIN,\n*                            PRINT, 'ERROR - SHOULD START WITH BEGIN\n*                            OR BEGIN JOB', AND -\n         B      INIT         GO TO NEXT CARD\nFIRST    XREAD  CARDA,40     READ CARD\n         BM     P            IF NO MORE CARDS, GO TO NEXT STEP\n         XPRNT  CRG,41       ECHO CHECK\n         MVC    0(40,3),CARDA PUT CONTENTS OF CARD INTO AREA (SOURCE)\n*                            ADDRESSED BY REGISTER 3\n         LA     3,40(3)      INCREMENT ADDRESS OF ARRAY TO ACCOMODATE\n*                            NEXT CARD AND -\n         B      FIRST        REPEAT STEPS OF FIRST LOOP\nP        L      15,ADDR      LOAD ADDRESS OF PASS 1 IN REGISTER 15\n         BALR   14,15        GO TO PASS1 CSECT\n         L      15,ADDTWO    LOAD ADDRESS OF PASS 2 IN REGISTER 15\n         BALR   14,15        GO TO PASS2 CSECT\n         L      15,ADDINT    LOAD ADDRESS OF INTERP IN REGISTER 15\n         BALR   14,15        GO TO INTERPRETER CSECT\nBYPASS   BR     14\nSAV14    DS     F\nINPUT    DC     C' INPUT DATA'\nCRG      DC     C' '\nCARDA    DS     40C\nBADBIG   DC     C' (ERROR-SHOULD START WITH - BEGIN OR BEGIN JOB)'\nADDR     DC     V(PASS1)\nADDTWO   DC     V(PTWO)\nADDINT   DC     V(INTERP)\nSAVDR    DS     18F\nBEGCK    DC     C'BEGIN'\nLABT     DS     150F\nESNUM    DC     256X'00'\nESLET    DC     256X'00'\nDATAAD   DS     F\nOUTP     DC     1000X'EE'\nSOURC    DS     4000C\n         EJECT\nPASS1    CSECT\n         STM    14,12,12(13)\n         BALR   12,0\n         USING  *,12\n         ST     13,SAVP1+4\n         USING  TESECT,7\n         LR     13,3         USE REG 13 TO CHECK FOR GROSS OVERRUNS\n*                            (IE NOT EVEN ONE ## CARD\n         LR     15,10        PLACE ADDRESS OF LABTAB IN REG 15 FOR\n*                            USE IN THIS PASS ONLY\n         SR     14,14        CLEAR REG 14 FOR USE IN ERROR CHECK\n         LA     10,6(10)     INCREMENT LABLE COUNTER TO POINT TO NEXT\n*                            LOCATION FOR FIRST TIME THROUGH\n         XPRNT  LABONE,9     PRINT TITLE FOR PASS 1 OUTPUT\n         B      F            SKIP NEXT STEP FOR FIRST ADDRESS AS IT IS\n*                            ALREADY CORRECT\nNEXTCD   LA     6,40(6)      INCREMENT ARRAY ADDRESS BY 1 'CARD'\n         CLR    6,13         COMPARE REGISTERS TO DETERMINE IF ENTIRE\n*                            SOURCE HAS BEEN READ\n         BE     NOEND        IF SO, THERE IS NO END CARD (##), SO\n*                            GO TO ERROR ROUTINE\nF        LR     4,6          EXAMINE EACH COLUMN OF EACH CARD THAT\n*                            IS STORED IN ARRAY SOURCE USING REGISTER\n*                            4 AS A COLUMN COUNTER. TO BEGIN, PLACE\n*                            ADDRESS OF 'THE CARD' (ARRAY INCREMENT)\n*                            TO BE READ INTO REGISTER 4\n         BCTR   6,0          DECREMENT  FOR CARRAIGE CONTROL (TEST)\n         XPRNT  0(6),40      PASS 1 ECHO CHECK\n         LA     6,1(6)       INCREMENT 1 TO RETURN REGISTER 6 TO PROPER\n*                            ADDRESS\n         CLC  0(2,4),=C'##'  CHECK TO DETERMINE IF THIS IS THE CODE FOR\n         BE     ENDONE       END CARD- BRANCH TO NEXT STEP\n         CLC    0(1,4),=C' ' DETERMINE IF 1ST COLUMN HAS A LABLE,\n         BE     CKOP         IF NOT, BRANCH TO CHECK OF OPERATION CODE\n*                            SEQUENCE\n         LR     5,15         INITIALIZE ADDR OF RECORDED TABLES FOR\n*                            CHECK PURPOSES\nCKDUP    CLC    0(2,4),0(5)  IF CARD HAS A LABLE, CHECK TO SEE IF IT\n*                            HAS BEEN PREVIOUSLY RECORDED\n         BE     DUP          IF SO, BRANCH TO ERROR ROUTINE\n         LA     5,6(5)       INCREMENT 6 BYTES TO THE ADDRESS OF NEXT\n*                            LABLE TO BE CHECKED\n         CLR    5,10         COMPARE REG 5 WITH REG 10 TO SEE IF ALL\n*                            LABLES HAVE BEEN CHECKED\n         BNE    CKDUP        IF NOT EQUAL, CONTINUE CHECK\n         MVC    0(2,10),0(4)   MOVE LABLE ADDRESSED BY REG 4 TO FIRST\n*                            2 BYTES OF PORTION OF LABLE TABLE\n*                            ADDRESSED BY REG 10\n         ST     11,LOCCTR    PLACE CONTENTS OF REG 11 (LOCATION\n*                            COUNTER ADDRESS OF LABLE) AT LOCCTR\n         MVC    2(4,10),LOCCTR MOVE LOCATION COUNTER ADDRESS NEXT TO\n*                            CORRESPONDING LABLE IN LABLE TABLE\n         LA     10,6(10)     INCREMENT LABLE TABLE BY 6 BYTES IN\n*                            PREPARATION FOR NEXT LABLE\n         B      CKLET        GO TO NEXT CHECK\nDUP      XPRNT  BADLAB,26    IF LABLE USED IN PROGRAM HAS BEEN USED\n*                            FOR SOME OTHER PURPOSE, PRINT, 'ERROR -\n*                            DUPLICATE LABLE' AND -\n         LA     14,=F'1'     RECORD THE FACT THAT THERE IS AN ERROR\n         B         NEXTCD    GO BACK AND READ NEXT CARD\nCKLET    TRT    0(1,4),TESLET DETERMINE IF FIRST CHARACTER IN LABLE\n*                            IS A LETTER -  IF SO\n         BC     2,CKNUM      BRANCH TO NEXT CHECK\n         XPRNT  BADONE,41    IF FIRST CHARACTER OF LABLE IS NOT A\n*                            LETTER, PRINT: ERROR, INVALID LABLE\n*                            FIRST CHARACTER\n         LA     14,=F'1'     RECORD THE FACT THAT THERE IS AN ERROR\nCKNUM    LA     4,1(4)       INCREMENT COLUMN COUNTER BY 1\n         TRT    0(1,4),TESNUM DETERMINE IF THE SECOND  CHARACTER IN\n*                      LABLE IS A NUMBER -  IF SO\n         BC     2,CKBL       BRANCH TO NEXT CHECK\n         XPRNT  BADTWO,42    IF SECOND CHARACTER OF LABLE IS NOT\n*                            A NUMBER, PRINT : ERROR - INVALID LABLE\n*                            SECOND CHARACTER\n         LA     14,=F'1'     RECORD THE FACT THAT THERE IS AN ERROR\nCKBL     LA     4,1(4)       INCREMENT COLUMN COUNTER BY 1\n         CLC    0(1,4),=C' ' TEST FOR BLANK. IF SO -\n         BE     SEARCH       BEGIN SEARCH, OTHERWISE\n         XPRNT  BADLEN,50    IF LABLE IS TOO LONG, PRINT ERROR MESSAGE\n         LA     14,=F'1'     RECORD THE FACT THAT THERE IS AN ERROR\nSEARCH   LA     4,1(4)       INCREMENT COLUMNCOUNTER\n         CLC    0(1,4),=C' ' TEST FOR BLANK. IF NOT -\n         BE     SEARCH        SEARCH AGAIN\n         CLC   0(2,4),=C'DS' DETERMINE IF THIS IS A DS STATEMENT\n         BE     DSDC         IF SO, BRANCH TO DS AND DC SEQUENCE\n         CLC   0(2,4),=C'DC' DETERMINE IF THIS IS A DC STATEMENT\n         BNE    CKOPLA       IF NOT, IT IS NEITHER A DC OR DS STATEMENT\n*                            SO BRANCH TO CHECK OF OPERATIONS SEQUENCE\nDSDC     LA     4,2(4)       IF IT IS A DS OR DC STATEMENT, INCREMENT\n*                            ADDRESS BY 2 SO AS TO POINT TO THE BLANK\n*                            AFTER DC OR DS\n         SR     8,8          CLEAR REGISTER 8 FOR USE IN MULTIPLICATION\n*                            SEQUENCE\n         LA     9,=F'1'      PLACE INITIAL DUPLICATION FACTOR IN REG 9\nBLN      CLC    0(1,4),=C' ' TEST FOR BLANK. IF SO -\n         LA     4,1(4)       INCREMENT CARD COUNTER\n         BE     BLN          AND CONTINUE SEARCH\n         TRT    0(1,4),TESNUM  DETERMINE IF THIS IS A DUPLICATION\n*                            FACTOR\n         BC     2,TESTF      IF NOT, CHECK FULL WORD SEQUENCE\n         IC     3,0(4)       PLACE IN REG 3 THE CONTENTS (1 BYTE)\n*                            OF STORAGE ADDRESSED BY REG 4\nIADD     LA     4,1(4)       INCREMENT CARD COUNTER\n         TRT    0(1,4),TESNUM  DETERMINE IF THIS IS A DUPLICATION\n*                            FACTOR\n         BC     2,TESTF      IF NOT, CHECK FULL WORD SEQUENCE\n         LA     3,=F'10'     OTHERWISE PLACE A 10 IN REGISTER 3 AND\n         MR     8,3          MULTIPLY PREVIOU DUPLICATION FACTOR\n*                            BY 10\n         IC     3,0(4)       PLACE IN REG 3 THE CONTENTS (1 BYTE)\n*                            OF STORAGE ADDRESSED BY REG 4\n         AR     9,3          ADD CONTENTS OF 3 TO CONTENTS OF 9\n         B      IADD         BRANCH TO TOP AND REPEAT THE PROCESS\nTESTF    CLC    0(1,4),=C'F' DETERMINE IF THIS IS A FULL WORD SYMBOL\n         BE     FULLST       IF SO, BRANCH TO FULL WORD SEQUENCE\n         CLC    0(1,4),=C'C' DETERMINE IF THIS IS A CONSONANT SYMBOL\n         BE     CONST        IF SO, BRANCH TO CONSONANT SEQUENCE\n         LA     14,=F'1'     RECORD THE FACT THAT THERE IS AN ERROR\n         B      NEXTCD       IF NOT A C,F, OR NUMBER, IT IS IN ERROR\n*                            SO GO TO NEXT CARD\nFULLST   LA     3,=F'4'      LOAD REG3 WITH A 4 FOR THE 4 BYTES\n*                            OF STORAGE PER FULL WORD\n         MR     8,3          MULTIPLY DUPLICATION FACTOR BY 4 TO DETER-\n*                            MINE THE AMOUNT OF STORAGE TO RESERVE\n*                            (ANSWER IN REG 9)\n         AR     11,9         INCREMENT STORAGE ADDRESS IN REGISTER\n*                            11 BY REQUIRED AMOUNT OF STORAGE\n         SR     8,8          CLEAR REGISTER 8\n         LR     9,11         LOAD ADDRESS OF STORAGE LOCATION\n*                            INTO REG 9\n         D      8,=F'4'      DIVIDE ADDRESS OF STORAGE BY 4 TO FIND\n*                            IF ON A FULL WORD BOUNDARY\n*        AR     11,8         ADD ANY REMAINDER TO ADDRESS OF STORAGE\n*                            LOCATION TO INSURE FULL WORD 'STARTED'ON\n*                            FULL WORD BOUNDARY\n         B         NEXTCD    GO BACK AND READ NEXT CARD\nCONST     LA    3,=F'1'      LOAD A 1 IN REG3 AND USE AS A SPACE COUNT\nCO       LA     4,1(4)       INCREMENT ADDRESS BY 1 SO AS TO POINT TO\n*                            COLUMN AFTER C\n         CLC    0(1,4),=C'''' ? THERE AN APOSTROPHE ?\n         BNE    CONDUP       IF NOT, GO DIRECTLY TO CONSIDERATION\n*                            OF DUPLICATION FACTOR\nAPSEQ    LA     4,1(4)       OTHERWISE, INCREMENT COLUMN COUNTER BY 1\n*                            AND SEARCH FOR NEXT APOSTROPHE\n         CLC     0(1,4),=C'''' IS THIS THE SECOND APOSTROPHE?\n         BE     CONDUP       IF SO, BRANCH TO NEXT STEP\n         LA     3,1(3)       OTHERWISE INCREMENT SPACE COUNTER IN\n*                            REGISTER 3 AND\n         B      APSEQ           CONTINUE\nCONDUP    MR    8,3          MULTIPLY DUPLICATION FACTOR IN REG 3 BY\n*                            NUMBER OF SPACES IF ANY, BETWEEN APOST.\n*                            TO GIVE TOTAL LENGTH OF STORAGE REQUIRED\n         AR     11,9         INCREMENT ADDRESS IN REGISTER 11 BY\n*                            THIS AMOUNT\n         B         NEXTCD    GO BACK AND READ NEXT CARD\nCKOP     LA     4,1(4)       INCREMENT CARD COUNTER\n         CLC    0(1,4),=C' ' TEST FOR BLANK\n         BE     CKOP         IF  SO, CONTINUE SEARCH\nCKOPLA   CLC  0(2,4),=C'LD'  CHECK TO DETERMINE IF THIS IS THE CODE FOR\n         BE     OKOP         LOAD    - BRANCH TO NEXT STEP\n         CLC  0(2,4),=C'ST'  CHECK TO DETERMINE IF THIS IS THE CODE FOR\n         BE     OKOP         STORE   - BRANCH TO NEXT STEP\n         CLC  0(2,4),=C'AD'  CHECK TO DETERMINE IF THIS IS THE CODE FOR\n         BE     OKOP         ADD     - BRANCH TO NEXT STEP\n         CLC  0(2,4),=C'SB'  CHECK TO DETERMINE IF THIS IS THE CODE FOR\n         BE     OKOP         SUBTRACT- BRANCH TO NEXT STEP\n         CLC  0(2,4),=C'MT'  CHECK TO DETERMINE IF THIS IS THE CODE FOR\n         BE     OKOP         MULTIPLY- BRANCH TO NEXT STEP\n         CLC  0(2,4),=C'DV'  CHECK TO DETERMINE IF THIS IS THE CODE FOR\n         BE     OKOP         DIVIDE  - BRANCH TO NEXT STEP\n         CLC  0(2,4),=C'GT'  CHECK TO DETERMINE IF THIS IS THE CODE FOR\n         BE   OKOP           GO TO   - BRANCH TO NEXT STEP\n         CLC  0(2,4),=C'IF'  CHECK TO DETERMINE IF THIS IS THE CODE FOR\n         BE     OKOP         IF      - BRANCH TO NEXT STEP\n         CLC  0(2,4),=C'RD'  CHECK TO DETERMINE IF THIS IS THE CODE FOR\n         BE     OKOP         READ    - BRANCH TO NEXT STEP\n         CLC  0(2,4),=C'WT'  CHECK TO DETERMINE IF THIS IS THE CODE FOR\n         BE     OKOP         WRITE, IF SO BRANCH TO NEXT STEP\n         CLC  0(2,4),=C'HT'  CHECK TO DETERMINE IF THIS IS THE CODE FOR\n         BE     OKOP         HALT    - BRANCH TO NEXT STEP\n         CLC  0(3,4),=C'END' CHECK TO DETERMINE IF THIS IS THE CODE FOR\n         BE     NEXTCD       END CARD - IF SO TAKE NO ACTION BUT\n*                            CHECK NEXT CARD FOR ##\n         XPRNT   BADOP,34    IF OPERATIONS CODE USED IN PROGRAM\n*                            DOES NOT MATCH ANY OF THE VALID OPER-\n*                            ATIONS CODES, PRINT,INVALID OPERATIONS\n*                            CODE, AND -\n         LA     14,=F'1'     RECORD THE FACT THAT THERE IS AN ERROR\n         B      NEXTCD       READ THE NEXT CARD\nOKOP     LA     11,3(11)     OPERATIONS OF THIS TYPE REQUIRE THREE\n*                            BYTES OF STORAGE. THEREFORE, THE\n*                            ADDRESS OF THE STORAGE LOCATION IS\n*                            INCREMENTED BY THREE TO GIVE THE ADDRESS\n*                            OF THE NEXT AVAILABLE BYTE OF STORAGE\n         B      NEXTCD       PASS 1 COMPLETED FOR THIS CARD, READ NEXT\nNOEND    XPRNT  BADEND,25    IF THERE IS NO ## CARD, PRINT ERROR -\n*                            MISSING ## CARD\n         LA     14,=F'1'     RECORD THE FACT THAT THERE IS AN ERROR\nENDONE   LA     2,=F'1'      LOAD REG 2 FOR ERROR CHECK\n         CR     2,14         DETERMINE IF AN ERROR HAS BEEN RECORDED\n         L      13,SAVP1+4\n         LA     6,40(6)      INCREMENT SOURCE ARRAY BY 1 CARD\n         ST     6,ADDATA     STORE ADDRESS OF FIRST DATA CAR FOR\n*                            USE BY INTERPRETER\n         LM     14,12,12(13)\n         BR     14\nERRORF   LR     14,5         RETURN TO A DIFFERENT LOCATION IN MAIN\n*                            STORAGE BECOUSE OF ERROR FOUND IN PROGRAM\n         BR     14\nSAVP1    DS     18F\nLOCCTR   DS     F\nLABONE   DC     C' PASS ONE'\nBADLAB   DC     C' (ERROR - DUPLICATE LABLE)'\nBADONE   DC     C' (ERROR - INVALID LABLE: FIRST CHARACTER)'\nBADTWO   DC     C' (ERROR - INVALID LABLE: SECOND CHARACTER)'\nBADLEN   DC     C' (ERROR - INVALID LABLE: OVER TWO CHARACTERS LONG)'\nBADOP    DC     C' (ERROR - INVALID OPERATIONS CODE)'\nBADEND   DC     C' ERROR - MISSING ## CARD)'\n         LTORG\n         EJECT\nPTWO     CSECT\n         STM    14,12,12(13)\n         BALR   12,0\n         USING  *,12\n         USING  TESECT,7\n       ST       13,SAVTWO+4\n         XPRNT  LABTWO,9     PRINT TITLE FOR PASS 2 OUTPUT\n         LR     15,10        PLACE ADDRESS OF LABTAB IN REG 15 FOR\n*                            USE IN THIS PASS ONLY\n         B      ERSTE        SKIP NEXT STEP FOR FIRST ADDRESS AS IT IS\n*                            ALREADY CORRECT\nNCARD    LA     6,40(6)      INCREMENT ARRAY ADDRESS BY 1 'CARD'\n         CLR    6,7          COMPARE REGISTERS TO DETERMINE IF ENTIRE\n*                            SOURCE HAS BEEN READ\n         BE     ENDTWO       IF SO, THERE IS NO END CARD (##), BUT\n*                            JOB OF PASS IS FINISHED\nERSTE    LR     4,6          EXAMINE EACH COLUMN OF EACH CARD THAT\n*                            IS STORED IN ARRAY SOURCE USING REGISTER\n*                            4 AS A COLUMN COUNTER. TO BEGIN, PLACE\n*                            ADDRESS OF 'THE CARD' (ARRAY INCREMENT)\n*                            TO BE READ INTO REGISTER 4\n         BCTR   6,0          DECREMENT  FOR CARRAIGE CONTROL (TEST)\n         XPRNT  0(6),40      PASS 2 ECHO CHECK\n         LA     6,1(6)       INCREMENT 1 TO RETURN REGISTER 6 TO PROPER\n*                            ADDRESS\n         CLC  0(2,4),=C'##'  CHECK TO DETERMINE IF THIS IS THE CODE FOR\n         BE     ENDTWO       END CARD- BRANCH TO NEXT STEP\n         CLC    0(1,4),=C' ' DETERMINE IF 1ST COLUMN HAS A LABLE,\n         BE     OPSEQ        IF NOT, BRANCH TO CHECK OF OPERATION CODE\n*                            SEQUENCE\n         LR     5,15         INITIALIZE ADDR OF RECORDED TABLES FOR\n*                            CHECK PURPOSES\n         LA     4,1(4)       IF CARD HAS A LABLE, INCREMENT COUNTER\n*                            BY 2 TO GET PAST LABLE AND THEN AGAIN\nCKBLAN   LA     4,1(4)       INCREMENT COLUMN COUNTER BY 1\n         CLC    0(1,4),=C' ' TEST FOR BLANK. IF SO -\n         BE     CKBLAN        SEARCH AGAIN . OTHERWISE -\n         CLC   0(2,4),=C'DS' DETERMINE IF THIS IS A DS STATEMENT\n         BE     DSDCSQ       IF SO, BRANCH TO DS AND DC SEQUENCE\n         CLC   0(2,4),=C'DC' DETERMINE IF THIS IS A DC STATEMENT\n         BNE    COMOP        IF NOT, IT IS NEITHER A DC OR DS STATEMENT\n*                            SO BRANCH TO CHECK OF OPERATIONS SEQUENCE\nDSDCSQ   LA     4,2(4)       IF IT IS A DS OR DC STATEMENT, INCREMENT\n*                            ADDRESS BY 2 SO AS TO POINT TO THE BLANK\n*                            AFTER DC OR DS\n         SR     8,8          CLEAR REGISTER 8 FOR USE IN MULTIPLICATION\n*                            SEQUENCE\n         LA     9,=F'1'      PLACE INITIAL DUPLICATION FACTOR IN REG 9\nBLAN     CLC    0(1,4),=C' ' TEST FOR BLANK. IF SO -\n         LA     4,1(4)       INCREMENT CARD COUNTER\n         BE     BLAN         AND CONTINUE SEARCH\n         TRT    0(1,4),TESNUM  DETERMINE IF THIS IS A DUPLICATION\n*                            FACTOR\n         BC     2,TCON       IF NOT, CHECK CONSONANT SEQUENCE\n         IC     3,0(4)       PLACE IN REG 3 THE CONTENTS (1 BYTE)\n*                            OF STORAGE ADDRESSED BY REG 4\nIADDR    LA     4,1(4)       INCREMENT CARD COUNTER\n         TRT    0(1,4),TESNUM  DETERMINE IF THIS IS A DUPLICATION\n*                            FACTOR\n         BC     2,TCON       IF NOT, CHECK CONSONANT SEQUENCE\n         LA     3,=F'10'     OTHERWISE PLACE A 10 IN REGISTER 3 AND\n         MR     8,3          MULTIPLY PREVIOU DUPLICATION FACTOR\n*                            BY 10\n         IC     3,0(4)       PLACE IN REG 3 THE CONTENTS (1 BYTE)\n*                            OF STORAGE ADDRESSED BY REG 4\n         AR     9,3          ADD CONTENTS OF 3 TO CONTENTS OF 9\n         B      IADDR        BRANCH TO TOP AND REPEAT THE PROCESS\nTCON     CLC    0(1,4),=C'C' DETERMINE IF THIS IS A CONSONANT SYMBOL\n         BE     CONSON       IF SO, BRANCH TO CONSONANT SEQUENCE\nFULLSQ   SR     8,8          CLEAR REGISTER 8\n         LR     9,11         LOAD ADDRESS OF STORAGE LOCATION\n*                            INTO REG 9\n         D      8,=F'4'      DIVIDE ADDRESS OF STORAGE BY 4 TO FIND\n*                            IF ON A FULL WORD BOUNDARY\n*        AR     11,8         ADD ANY REMAINDER TO ADDRESS OF STORAGE\n*                            LOCATION TO INSURE FULL WORD 'STARTS 'ON\n*                            FULL WORD BOUNDARY\n         SR     3,3               CLEAR  REG3 AND USE AS A SPACE COUNT\n         LA     4,1(4)       INCREMENT ADDRESS BY 1 SO AS TO POINT TO\n*                            COLUMN AFTER F\n         CLC    0(1,4),=C'''' ? THERE AN APOSTROPHE ?\n         BNE    NOFUAP       IF NOT, GO TO NO APOSTROPHE SEQUENCE\n         LA      11,4(11)     INCREMENT STORAGE FOR CONTENTS OF FULL W\nFSECAP   LA     4,1(4)       OTHERWISE, INCREMENT COLUMN COUNTER BY 1\n*                            AND SEARCH FOR NEXT APOSTROPHE\nBOY      CLC     0(1,4),=C'''' IS THIS THE SECOND APOSTROPHE?\n         BE     FAPF         IF SO, BRANCH TO NEXT STEP\n         LA     3,1(3)       OTHERWISE INCREMENT SPACE COUNTER IN\n*                            REGISTER 3 AND\nFAPF     LR     2,3          SAVE COUNT OF DIGITS\n         B      FSECAP       CONTINUE SEARCH\nFAPFND   BCTR   4,0          DECREMENT COLUMN COUNTER TO POINT TO\n*                            SIGNIFICANT CHARACTER\n         MVC    0(1,11),0(4)   MOVE A BYTE FROM CONTENTS OF CARD\n*                            STORAGE TO CODE STORAGE\n         BCTR    11,0        DECREMENT  CODE STORAGE FOR NEXT BYTE\n         BCTR     3,0        DEREMENT COUNTER BY 1\n         CL     3,=F'0'      HAS EVERYTHING BEEN MOVED?\n         BE     FULLDU       IF SO BRANCH TO CONSIDERATION OF ANY DUP-\n*                            LICATION FACTORS\n         B      FAPFND       OTHERWISE CONTINUE SEARCH\nFULLDU   AR     11,2         RETURN ADDRESS OF NEXT  OPEN STORE TO\n*                            CORRECT AMOUNT\n          CL    8,=F'1'       IS DUPLICATION REQUIRED?\n         BE     NCARD        IF NOT GO BACK TO NEXT CARD\n         BCTR    8,0         OTHERWISE DECREMENT DUPLICATION\n*                            FACTOR COUNTER AND\n         BCTR   4,0          DECREMENT COLUMN COUNTER\n         LA      11,4(11)     INCREMENT STORAGE FOR CONTENTS OF FULL W\n         B      BOY          CONTINUE\nNOFUAP   LA     3,=F'4'      LOAD REG3 WITH A 4 FOR THE 4 BYTES\n*                            OF STORAGE PER FULL WORD\n         MR     8,3          MULTIPLY DUPLICATION FACTOR BY 4 TO DETER-\n*                            MINE THE AMOUNT OF STORAGE TO RESERVE\n*                            (ANSWER IN REG 9)\n         AR     11,9         INCREMENT STORAGE ADDRESS IN REGISTER\n*                            11 BY REQUIRED AMOUNT OF STORAGE\n         B      NCARD        GO BACK AND READ NEXT CARD\nCONSON   SR     3,3               CLEAR  REG3 AND USE AS A SPACE COUNT\n         LA     4,1(4)       INCREMENT ADDRESS BY 1 SO AS TO POINT TO\n*                            COLUMN AFTER C\n         CLC    0(1,4),=C'''' ? THERE AN APOSTROPHE ?\n         BNE    NOAPOS       IF NOT, GO TO NO APOSTROPHE SEQUENCE\nAPSEQU   LA     4,1(4)       OTHERWISE, INCREMENT COLUMN COUNTER BY 1\n*                            AND SEARCH FOR NEXT APOSTROPHE\n         CLC     0(1,4),=C'''' IS THIS THE SECOND APOSTROPHE?\n         BE     DUPCON       IF SO, BRANCH TO NEXT STEP\n         LA     3,1(3)       OTHERWISE INCREMENT SPACE COUNTER IN\n*                            REGISTER 3 AND\n         MVC     0(1,11),0(4)  MOVE A BYTE FROM CONTENTS OF DC\n*                            STORAGE TO CODE STORAGE\n         LA     11,1(11)\nDUPCON    CL    8,=F'1'       IS DUPLICATION REQUIRED?\nDCFINI   BE     NCARD        GO BACK AND READ NEXT CARD\n         BCTR    8,0         OTHERWISE DECREMENT DUPLICATION\n*                            FACTOR COUNTER AND\n         SR     4,3          RETURN COLUMN COUNTER TO BLANK AFTER\n*                            FIRST APOSTROPHE\n         BCTR   4,0          DECREMENT COL COUNTER BY AN OTHER 1\n         SR      3,3         CLEAR REGISTER 3 FOR NEXT SEQUENCE\n         B      APSEQU          CONTINUE\nNOAPOS   AR     11,9         INCREMENT ADDRESS IN REG 11 BY REQUIRED\n*                              AMOUNT\n         B      NCARD        GO BACK AND READ NEXT CARD\nOPSEQ    LA     4,1(4)       INCREMENT CARD COUNTER\n         CLC    0(1,4),=C' ' TEST FOR BLANK\n         BNE    OPSEQ        IF NOT, CONTINUE SEARCH\n         LA     4,1(4)       INCREMENT CARD COUNTER\nCOMOP    CLC  0(2,4),=C'LD'  CHECK TO DETERMINE IF THIS IS THE CODE FOR\n         BE     LOAD         LOAD    - BRANCH TO NEXT STEP\n         CLC  0(2,4),=C'ST'  CHECK TO DETERMINE IF THIS IS THE CODE FOR\n         BE     STORE        STORE   - BRANCH TO NEXT STEP\n         CLC  0(2,4),=C'AD'  CHECK TO DETERMINE IF THIS IS THE CODE FOR\n         BE     ADD          ADD     - BRANCH TO NEXT STEP\n         CLC  0(2,4),=C'SB'  CHECK TO DETERMINE IF THIS IS THE CODE FOR\n         BE     SUBTR        SUBTRACT- BRANCH TO NEXT STEP\n         CLC  0(2,4),=C'MT'  CHECK TO DETERMINE IF THIS IS THE CODE FOR\n         BE     MULT         MULTIPLY- BRANCH TO NEXT STEP\n         CLC  0(2,4),=C'DV'  CHECK TO DETERMINE IF THIS IS THE CODE FOR\n         BE     DIVIDE       DIVIDE  - BRANCH TO NEXT STEP\n         CLC  0(2,4),=C'GT'  CHECK TO DETERMINE IF THIS IS THE CODE FOR\n         BE        GOTO      GO TO   - BRANCH TO NEXT STEP\n         CLC  0(2,4),=C'IF'  CHECK TO DETERMINE IF THIS IS THE CODE FOR\n         BE     IFXX         IF      - BRANCH TO NEXT STEP\n         CLC  0(2,4),=C'RD'  CHECK TO DETERMINE IF THIS IS THE CODE FOR\n         BE     READXX       READ    - BRANCH TO NEXT STEP\n         CLC  0(2,4),=C'WT'  CHECK TO DETERMINE IF THIS IS THE CODE FOR\n         BE     WRITXX       WRITE   - BRANCH TO NEXT STEP\n         CLC  0(2,4),=C'HT'  CHECK TO DETERMINE IF THIS IS THE CODE FOR\n         BE     HALTXX       HALT    - BRANCH TO NEXT STEP\n         CLC  0(3,4),=C'END' CHECK TO DETERMINE IF THIS IS THE CODE FOR\n         BE     ENDTWO       END CARD- BRANCH TO NEXT STEP\n         B      NCARD        IF OPERATION CODE IS INVALID, IGNORE\n*                            SAME AND GO TO NEXT CARD\nLOAD     LA     4,3(4)       INCREMENT PAST OP CODE AND FIRST BLANK\nLBLK     CLC    0(1,4),=C' ' DETERMINE IF BLANK\n         BNE    LAORI        IF NOTDETERMINE IF A OR I\n         LA     4,1(4)       OTHERWISE INCREMENT COUNTER AND\n         B      LBLK         SEARCH AGAIN\nLAORI    CLC    0(1,4),=C'A' DETERMINE IF AN A\n         BE     LISA         IF SO GO TO NEXT STEP\n         MVI    0(11),X'1F'  PLACE APPROPRIATE OPERATIONS CODE\n*                            IN FIRST BYTE OF STORAGE\n         B      STADD        GO TO NEXT STEP\nLISA     MVI    0(11),X'10'  PLACE APPROPRIATE OPERATIONS CODE\n*                            IN LEFT PORTION OF FIRST BYTE OF STORAGE\n*                            LOCATION (ZERO IN RIGHT HALF)\n         B      STADD        GO TO NEXT STEP\nSTORE    LA     4,3(4)       INCREMENT PAST OP CODE AND FIRST BLANK\nSTBLK    CLC    0(1,4),=C' ' DETERMINE IF BLANK\n         BNE    STAORI       IF NOTDETERMINE IF A OR I\n         LA     4,1(4)       OTHERWISE INCREMENT COUNTER AND\n         B      STBLK        SEARCH AGAIN\nSTAORI   CLC    0(1,4),=C'A' DETERMINE IF AN A\n         BE     STISA        IF SO GO TO NEXT STEP\n         MVI    0(11),X'2F'  PLACE APPROPRIATE OPERATIONS CODE\n*                            IN FIRST BYTE OF STORAGE\n         B      STADD        GO TO NEXT STEP\nSTISA    MVI    0(11),X'20'  PLACE APPROPRIATE OPERATIONS CODE\n*                            IN LEFT PORTION OF FIRST BYTE OF STORAGE\n*                            LOCATION (ZERO IN RIGHT HALF)\n         B      STADD        GO TO NEXT STEP\nADD      LA     4,3(4)       INCREMENT PAST OP CODE AND FIRST BLANK\nABLK     CLC    0(1,4),=C' ' DETERMINE IF BLANK\n         BNE    AAORI        IF NOTDETERMINE IF A OR I\n         LA     4,1(4)       OTHERWISE INCREMENT COUNTER AND\n         B      ABLK         SEARCH AGAIN\nAAORI    CLC    0(1,4),=C'A' DETERMINE IF AN A\n         BE     AISA         IF SO GO TO NEXT STEP\n         MVI    0(11),X'3F'  PLACE APPROPRIATE OPERATIONS CODE\n*                            IN FIRST BYTE OF STORAGE\n         B      STADD        GO TO NEXT STEP\nAISA     MVI    0(11),X'30'  PLACE APPROPRIATE OPERATIONS CODE\n*                            IN LEFT PORTION OF FIRST BYTE OF STORAGE\n*                            LOCATION (ZERO IN RIGHT HALF)\n         B      STADD        GO TO NEXT STEP\nSUBTR    LA     4,3(4)       INCREMENT PAST OP CODE AND FIRST BLANK\nSBBLK    CLC    0(1,4),=C' ' DETERMINE IF BLANK\n         BNE    SBAORI       IF NOTDETERMINE IF A OR I\n         LA     4,1(4)       OTHERWISE INCREMENT COUNTER AND\n         B      SBBLK        SEARCH AGAIN\nSBAORI   CLC    0(1,4),=C'A' DETERMINE IF AN A\n         BE     SUISA        IF SO GO TO NEXT STEP\n         MVI    0(11),X'4F'  PLACE APPROPRIATE OPERATIONS CODE\n*                            IN FIRST BYTE OF STORAGE\n         B      STADD        GO TO NEXT STEP\nSUISA    MVI    0(11),X'40'  PLACE APPROPRIATE OPERATIONS CODE\n*                            IN LEFT PORTION OF FIRST BYTE OF STORAGE\n*                            LOCATION (ZERO IN RIGHT HALF)\n         B      STADD        GO TO NEXT STEP\nMULT     LA     4,3(4)       INCREMENT PAST OP CODE AND FIRST BLANK\nMBLK     CLC    0(1,4),=C' ' DETERMINE IF BLANK\n         BNE    MAORI        IF NOTDETERMINE IF A OR I\n         LA     4,1(4)       OTHERWISE INCREMENT COUNTER AND\n         B      MBLK         SEARCH AGAIN\nMAORI    CLC    0(1,4),=C'A' DETERMINE IF AN A\n         BE     MISA         IF SO GO TO NEXT STEP\n         MVI    0(11),X'5F'  PLACE APPROPRIATE OPERATIONS CODE\n*                            IN FIRST BYTE OF STORAGE\n         B      STADD        GO TO NEXT STEP\nMISA     MVI    0(11),X'50'  PLACE APPROPRIATE OPERATIONS CODE\n*                            IN LEFT PORTION OF FIRST BYTE OF STORAGE\n*                            LOCATION (ZERO IN RIGHT HALF)\n         B      STADD        GO TO NEXT STEP\nDIVIDE   LA     4,3(4)       INCREMENT PAST OP CODE AND FIRST BLANK\nDBLK     CLC    0(1,4),=C' ' DETERMINE IF BLANK\n         BNE    DAORI        IF NOTDETERMINE IF A OR I\n         LA     4,1(4)       OTHERWISE INCREMENT COUNTER AND\n         B      DBLK         SEARCH AGAIN\nDAORI    CLC    0(1,4),=C'A' DETERMINE IF AN A\n         BE     DISA         IF SO GO TO NEXT STEP\n         MVI    0(11),X'6F'  PLACE APPROPRIATE OPERATIONS CODE\n*                            IN FIRST BYTE OF STORAGE\n         B      STADD        GO TO NEXT STEP\nDISA     MVI    0(11),X'60'  PLACE APPROPRIATE OPERATIONS CODE\n*                            IN LEFT PORTION OF FIRST BYTE OF STORAGE\n*                            LOCATION (ZERO IN RIGHT HALF)\n         B      STADD        GO TO NEXT STEP\nGOTO     MVI    0(11),X'70'  PLACE APPROPRIATE OPERATIONS CODE\n         B      STADD        GO TO NEXT STEP\nIFXX     LA     4,3(4)       INCREMENT PAST OP CODE AND FIRST BLANK\nIBLK     CLC    0(1,4),=C' ' DETERMINE IF BLANK\n         BNE    IFHZL        IF NOTDETERMINE IF H, Z OR L\n         LA     4,1(4)       OTHERWISE INCREMENT COUNTER AND\n         B      IBLK         SEARCH AGAIN\nIFHZL    CLC    0(1,4),=C'H' DETERMINE IF AN H\n         BE     IFH          BRANCH TO NEXT STEP\n         CLC    0(1,4),=C'Z' DETERMINE IF AN Z\n         BE     IFZ          BRANCH TO NEXT STEP\nIFL      MVI    0(11),X'81'  PLACE APPROPRIATE OPERATIONS CODE\n*                            IN FIRST BYTE OF STORAGE\n         B      STADD        GO TO NEXT STEP\nIFZ      MVI    0(11),X'82'  PLACE APPROPRIATE OPERATIONS CODE\n*                            IN FIRST BYTE OF STORAGE\n         B      STADD        GO TO NEXT STEP\nIFH      MVI    0(11),X'83'  PLACE APPROPRIATE OPERATIONS CODE\n*                            IN FIRST BYTE OF STORAGE\n         B      STADD        GO TO NEXT STEP\nHALTXX   MVI    0(11),X'00'  PLACE APPROPRIATE OPERATIONS CODE\n*                            IN LEFT PORTION OF FIRST BYTE OF STORAGE\n*                            LOCATION (ZERO IN RIGHT HALF)\n         LA     11,1(11)     INCREMENT STORAGE ADDRESS AND\n         MVI    0(11),X'00'  FILL THIS BYTE WITH ZEROS\n         LA     11,1(11)     INCREMENT STORAGE ADDRESS AND\n         MVI    0(11),X'00'  FILL THIS BYTE WITH ZEROS\n         LA     11,1(11)     INCREMENT STORAGE ADDRESS AND\n         B      NCARD        GO BACK AND READ NEXT CARD\nREADXX   LA     4,3(4)       INCREMENT PAST OP CODE AND FIRST BLANK\nRBLK     CLC    0(1,4),=C' ' DETERMINE IF BLANK\n         BNE    RIORC        IF NOTDETERMINE IF I OR C\n         LA     4,1(4)       OTHERWISE INCREMENT COUNTER AND\n         B      RBLK         SEARCH AGAIN\nRIORC    CLC    3(1,4),=C'I' READ PAST LABLE NAME AND COMMA TO FIND IF\n         BE     RISA         I. IF SO  GO TO NEXT STEP\n         LA     4,3(4)       INCREMENT ADDRESS SO AS TO GET PAST\n*                            LABLE NAME AND COMMA (IF A C)\nRI10     CLC    0(2,4),=C'10' IF NOT, IT IS A CHARACTER SO CHECK IF\n*                            A 2 DIGIT NUMBER\n         BNE    RI11         IF NOT, TRY NEXT I DIGIT NUMBER\n         MVI    0(11),X'BA'  PLACE APPROPRIATE OPERATIONS CODE\n         B      DEC3\nRI11     CLC    0(2,4),=C'11' IF NOT, IT IS A CHARACTER SO CHECK IF\n*                            A 2 DIGIT NUMBER\n         BNE    RI12         IF NOT, TRY NEXT I DIGIT NUMBER\n         MVI    0(11),X'BB'  PLACE APPROPRIATE OPERATIONS CODE\n         B      DEC3\nRI12     CLC    0(2,4),=C'12' IF NOT, IT IS A CHARACTER SO CHECK IF\n*                            A 2 DIGIT NUMBER\n         BNE    RI13         IF NOT, TRY NEXT I DIGIT NUMBER\n         MVI    0(11),X'BC'  PLACE APPROPRIATE OPERATIONS CODE\n         B      DEC3\nRI13     CLC    0(2,4),=C'13' IF NOT, IT IS A CHARACTER SO CHECK IF\n*                            A 2 DIGIT NUMBER\n         BNE    RI14         IF NOT, TRY NEXT I DIGIT NUMBER\n         MVI    0(11),X'BD'  PLACE APPROPRIATE OPERATIONS CODE\n         B      DEC3\nRI14     CLC    0(2,4),=C'14' IF NOT, IT IS A CHARACTER SO CHECK IF\n*                            A 2 DIGIT NUMBER\n         BNE    RI15         IF NOT, TRY NEXT I DIGIT NUMBER\n         MVI    0(11),X'BE'  PLACE APPROPRIATE OPERATIONS CODE\n         B      DEC3\nRI15     CLC    0(2,4),=C'15' IF NOT, IT IS A CHARACTER SO CHECK IF\n         BNE    RTEST        IF NOT, TRY TEST OF SINGLE DIGIT NUMS\n         MVI    0(11),X'BF'  PLACE APPROPRIATE OPERATIONS CODE\n         B      DEC3\nRTEST    TRT    0(1,4),TESNUM   FIND WHICH NUMBER (ANSWER IN REG 2)\n         SRDL   2,4          PUSH NIBBLE WITH NUMBER INTO REG 3\n         LA     2,=B'1011'   PLACE OP CODE SYMBOL IN REG 2\n         SLDL   2,4          SHIFT OP CODE A NIBBLE TO LEFT AND ADD\n*                            PREVIOUSLY STOREED NUMBER IN REG 3\n         STC    2,0(11)      PLACE UNSIGNED OP CODE + NUM IN STORAGE\n         B      DEC3\nRISA     LA     4,4(4)       INCREMENT ADDRESS TO GET PAST LABLE,\n*                            COMMA AND I\n         TRT    0(1,4),TESNUM   FIND WHICH NUMBER (ANSWER IN REG 2)\n         SRDL   2,4          PUSH NIBBLE WITH NUMBER INTO REG 3\n         LA     2,=B'1010'   PLACE OP CODE SYMBOL IN REG 2\n         SLDL   2,4          SHIFT OP CODE A NIBBLE TO LEFT AND ADD\n*                            PREVIOUSLY STOREED NUMBER IN REG 3\n         STC    2,0(11)      PLACE UNSIGNED OP CODE + NUM IN STORAGE\n         B      DEC4\nWRITXX   LA     4,3(4)       INCREMENT PAST OP CODE AND FIRST BLANK\nWBLK     CLC    0(1,4),=C' ' DETERMINE IF BLANK\n         BNE    WIORC        IF NOTDETERMINE IF I OR C\n         LA     4,1(4)       OTHERWISE INCREMENT COUNTER AND\n         B      WBLK         SEARCH AGAIN\nWIORC    CLC    3(1,4),=C'I' READ PAST LABLE NAME AND COMMA TO FIND IF\n         BE     WISA         I. IF SO  GO TO NEXT STEP\n         LA     4,3(4)       INCREMENT ADDRESS SO AS TO GET PAST\n*                            LABLE NAME AND COMMA (IF A C)\nWI10     CLC    0(2,4),=C'10' IF NOT, IT IS A CHARACTER SO CHECK IF\n*                            A 2 DIGIT NUMBER\n         BNE    WI11         IF NOT, TRY NEXT I DIGIT NUMBER\n         MVI    0(11),X'DA'  PLACE APPROPRIATE OPERATIONS CODE\n         B      DEC3\nWI11     CLC    0(2,4),=C'11' IF NOT, IT IS A CHARACTER SO CHECK IF\n*                            A 2 DIGIT NUMBER\n         BNE    WI12         IF NOT, TRY NEXT I DIGIT NUMBER\n         MVI    0(11),X'DB'  PLACE APPROPRIATE OPERATIONS CODE\n         B      DEC3\nWI12     CLC    0(2,4),=C'12' IF NOT, IT IS A CHARACTER SO CHECK IF\n*                            A 2 DIGIT NUMBER\n         BNE    WI13         IF NOT, TRY NEXT I DIGIT NUMBER\n         MVI    0(11),X'DC'  PLACE APPROPRIATE OPERATIONS CODE\n         B      DEC3\nWI13     CLC    0(2,4),=C'13' IF NOT, IT IS A CHARACTER SO CHECK IF\n*                            A 2 DIGIT NUMBER\n         BNE    WI14         IF NOT, TRY NEXT I DIGIT NUMBER\n         MVI    0(11),X'DD'  PLACE APPROPRIATE OPERATIONS CODE\n         B      DEC3\nWI14     CLC    0(2,4),=C'14' IF NOT, IT IS A CHARACTER SO CHECK IF\n*                            A 2 DIGIT NUMBER\n         BNE    WI15         IF NOT, TRY NEXT I DIGIT NUMBER\n         MVI    0(11),X'DE'  PLACE APPROPRIATE OPERATIONS CODE\n         B      DEC3\nWI15     CLC    0(2,4),=C'15' IF NOT, IT IS A CHARACTER SO CHECK IF\n*                            A 2 DIGIT NUMBER\n         BNE    WTEST        IF NOT, TRY TEST OF SINGLE DIGIT NUMS\n         MVI    0(11),X'DF'  PLACE APPROPRIATE OPERATIONS CODE\n         B      DEC3\nWTEST    TRT    0(1,4),TESNUM   FIND WHICH NUMBER (ANSWER IN REG 2)\n         SRDL   2,4          PUSH NIBBLE WITH NUMBER INTO REG 3\n         LA     2,=B'1101'   PLACE OP CODE SYMBOL IN REG 2\n         SLDL   2,4          SHIFT OP CODE A NIBBLE TO LEFT AND ADD\n*                            PREVIOUSLY STOREED NUMBER IN REG 3\n         STC    2,0(11)      PLACE UNSIGNED OP CODE + NUM IN STORAGE\n         B      DEC3\nWISA     LA     4,4(4)       INCREMENT ADDRESS TO GET PAST LABLE,\n*                            COMMA AND I\n         TRT    0(1,4),TESNUM   FIND WHICH NUMBER (ANSWER IN REG 2)\n         SRDL   2,4          PUSH NIBBLE WITH NUMBER INTO REG 3\n         LA     2,=B'1100'   PLACE OP CODE SYMBOL IN REG 2\n         SLDL   2,4          SHIFT OP CODE A NIBBLE TO LEFT AND ADD\n*                            PREVIOUSLY STOREED NUMBER IN REG 3\n         STC    2,0(11)      PLACE UNSIGNED OP CODE + NUM IN STORAGE\nDEC4     BCTR   4,0          DECREMENT COUNTER TO POINT TO LABLE\nDEC3     BCTR   4,0          DECREMENT COUNTER TO POINT TO LABLE\n         BCTR   4,0          DECREMENT COUNTER TO POINT TO LABLE\n         BCTR   4,0          DECREMENT COUNTER TO POINT TO LABLE\nSTADD    LA     4,2(4)       INCREMENT COLUMN COUNTERPAST A ORF AND\n*                            COMMA SO AS TO POINT TO OPERAND LABLE\n         LA     11,1(11)     INCREMEN\\ ADDRESS OF CODE STORAGE (OUTP.)\n         LR       5,15    PLACE ADDRESSS OF LABLETABLE IN REG 5\nEXLTAB   CLC    0(2,4),0(10) EXAMINE A LABLE IN LABLE TABLE TO SEE IF\n*                            ITIS THE ONE DESIRED\n         BE     LABFND       IF SO GO TO LABLE FOUND STEP\n         LA     10,6(10)     OTHERWISE INCREMENT LABLE COUNTER AND\n         B      EXLTAB       CONTINUE SEARCH\nLABFND   PACK   PCODE(2),0(4,4)    PACK ADDRESS +\n         L      2,PCODE      PLACE PACKED CODE + NUM BACK IN REG 2\n         SRL    2,4          ELIMINATE SIGN BITS FROM ADDRESS\n         STC    2,0(11)      PLACE ADDRESS SEGMENT IN STORAGE\n         LA     11,1(11)     INCREMENT STORAGE ADDRESS AND\n         STC    2,0(11)      PLACE ADDRESS SEGMENT IN STORAGE\n         B      NCARD        GO BACK AND READ NEXT CARD\nENDTWO   L      13,SAVTWO+4\n         LM     14,12,12(13)\n         BR     14\nUCODE    DS     F\nPCODE    DS     F\nSAVTWO   DS     18F\nLABTWO   DC     C' PASS TWO'\n         LTORG\n         EJECT\n         TITLE 'CONSTRUCTION OF ASSEMBLER AND INTERPRETER FOR CS 410'\nINTERP   CSECT\n         STM    14,12,12(13)\n         BALR   12,0\n         USING  *,12\n         ST     13,SAVINT+4\n         USING  TESECT,7\n         XPRNT  LABINT,12    PRINT TITLE OF INTERPRETER OUTPUT\n         LR     15,11        USE REG 11 AS A 'BASEREGISTER' FOR CODE\n*                            TABLE. PLACE ADDRESS OF CODE TABLE IN REG\n*                            15 AND USE LATTER TO POINT TO NEXT STEP\n         B      AUSSER       SKIP THIS STEP THE FIRST TIME\nNACHST   LA     15,3(15)     INCREMENT COUNTER TO POINT TO NEXT STEP\nAUSSER   CLI    0(15),X'00'    DETERMINE IF PROGRAM HAS ENDED,(HALT\n*                            STATEMENT CODE)\n         BE     ENDINT       IF SO, BRANCH TO PROGRAM COMPLETION SEQ\n         IC     4,1(15)      PLACE LEFT HALF OF PURE PACKED ADDRESS\n*                            OF OPERAND FROM CODE STORAGE INTO REG4\n          SLL   4,8          MAKE ROOM FOR REST OF ADDRESSS\n         IC     4,2(15)      PLACE RIGHTHALF OF PURE PACKED ADDRESS\n*                            OF OPERAND FROM CODE STORAGE INTO REG4\n         L      5,=C'5555'   PLACE X 'F5' IN REG 5\n         SLDL   4,4          SHIFT NIBBLE WITH F FROMREG 5 TO REG4\n         ST     4,PKADDR\n         UNPK    UNADDR(4),PKADDR(3) UNPACK AND PLACE IN  TEMP STORAGE\n         CLI    0(15),X'10'\n         BE        LDASEQ\n         CLI    0(15),X'1F'\n         BE     LDISEQ\n         CLI    0(15),X'20'\n         BE     STASEQ\n         CLI    0(15),X'2F'\n         BE     STISEQ\n         CLI    0(15),X'30'\n         BE     ADASEQ\n         CLI    0(15),X'3F'\n         BE     ADISEQ\n         CLI    0(15),X'40'\n         BE     SBASEQ\n         CLI    0(15),X'4F'\n         BE     SBISEQ\n         CLI    0(15),X'50'\n         BE     MTASEQ\n         CLI    0(15),X'5F'\n         BE     MTISEQ\n         CLI    0(15),X'60'\n         BE     DVASEQ\n         CLI    0(15),X'6F'\n         BE     DVISEQ\n         CLI    0(15),X'70'\n         BE     GTSEQ\n         CLI    0(15),X'81'\n         BE     IFLSEQ\n         CLI    0(15),X'82'\n         BE     IFZSEQ\n         CLI    0(15),X'83'\n         BE     IFHSEQ\n         SR     9,9          IF IT IS NOT ONE OF THE ABOVE, IT IS A\n*                            READ OR WRITE STATEMENT. SO CLEAR\n*                            REG 9 FOR NEXT STEP\n         SR     8,8\n         IC     8,0(15)      PLACE OP CODE AND LENGTH IN REG 8\n         SRDL   8,4          LEAVE OP CODE IN REG 8 AND PLACE LENGTH\n*                            TO BE READ OR WRITEN IN REG 9\n         ST     8,OPER\n         LA     2,OPER\n         L      8,=X'FFFFFFFF'  LOAD REG 8 WITH ONES\n         SRDL   8,4          MOVE AN 'F' INTO REGISTER 9 NEXT TO\n*                            PURE LENGTH (UNDER 10) TO GIVE DECIMAL\n         SRL    9,24         MOVE LENGTH TO FAR RIGHT OF REG 9\n         ST     9,LENGTH     PLACE THE DECIMAL REPRESENTATION OF THE\n*                            LENGTH TO BE READ OR WRITTEN INTO STORAGE\n         LA     9,LENGTH\n         SR     8,8\nTRY10    CLI    0(9),X'FA'\n         BNE    TRY11\n         LA     8,=C'0010'\n         B      LENOK\nTRY11    CLI    0(9),X'FB'\n         BNE    TRY12\n         LA     8,=C'0011'\n         B      LENOK\nTRY12    CLI    0(9),X'FC'\n         BNE    TRY13\n         LA     8,=C'0012'\n         B      LENOK\nTRY13    CLI    0(9),X'FD'\n         BNE    TRY14\n         LA     8,=C'0013'\n         B      LENOK\nTRY14    CLI    0(9),X'FE'\n         BNE    TRY15\n         LA     8,=C'0014'\n         B      LENOK\nTRY15    CLI    0(9),X'FF'\n         BNE     LENFND     OPER CONTAINS A 'REAL' DECIMAL\n         LA     8,=C'0015'\n         B      LENOK\nLENFND   L      8,0(9)\n         LR     1,8\nLENOK    ST     8,0(9)\n         SR     9,9\n         CLI    0(2),X'0A'\n         BE     RDISEQ\n         CLI    0(2),X'0C'\n         BE     WTISEQ\n         CLI    0(2),X'0D'\n         BE     WTCSEQ\nRDCSEQ   CLC    0(2,3),=C'##'   DETERMINE IF ALL THE DATA CARDS AVE\n         BE     ENDINT       BEEN READ. IF SO, TERMINATE THE PROGRAM\nMORC     MVC    0(1,15),0(3)   MOVE A BYTE OF\n*                                       THE DESIRED NUMBER OF COLUMNS\n*                            FROM THE 'DATA' CARD TO'STORAGE'\n         LA     15,1(15)\n         LA     3,1(3)\n         CR     8,9\n         BE     NXTC\n         BCTR   8,0\n         B      MORC\nNXTC     SR     3,1\n         LA     3,40(3)      INCREMENT THE ARRAY TO POINT TO NEXT DATA\n         B      AUSSER\nRDISEQ   CLC    0(2,3),=C'##'   DETERMINE IF ALL THE DATA CARDS AVE\n         BE     ENDINT       BEEN READ. IF SO, TERMINATE THE PROGRAM\nMORI     MVC    0(1,15),0(3)   MOVE A BYTE OF\n*                                       THE DESIRED NUMBER OF COLUMNS\n*                            FROM THE 'DATA' CARD TO'STORAGE'\n         LA     15,1(15)\n         LA     3,1(3)\n         CR     8,9\n         BE     NXTI\n         BCTR   8,0\n         B      MORI\nNXTI     SR     3,1\n         LA     3,40(3)      INCREMENT THE ARRAY TO POINT TO NEXT DATA\n         B      AUSSER\nWTCSEQ   XPRNT  UNADDR(11),15      TRANSLATE INTO ASSEMBLER\n         B      NACHST       GO TO THE NEXT STEP IN PROGRAM\nWTISEQ   XPRNT  UNADDR(11),8       TRANSLATE INTO ASSEMBLER\n         B      NACHST       GO TO THE NEXT STEP IN PROGRAM\nLDASEQ   L      1,UNADDR(11) TRANSLATE NEW LANGUAGE INTO ASSEMPLER\n         B      NACHST       GO TO THE NEXT STEP IN PROGRAM\nLDISEQ   L      3,UNADDR(11) TRANSLATE NEW LANGUAGE INTO ASSEMBLER\n         B      NACHST       GO TO THE NEXT STEP IN PROGRAM\nSTASEQ   ST     1,UNADDR(11) TRANSLATE NEW LANGUAGE INTO ASSEMBLER\n         B      NACHST       GO TO THE NEXT STEP IN PROGRAM\nSTISEQ   ST     3,UNADDR(11) TRANSLATE NEW LANGUAGE INTO ASSEMBLER\n         B      NACHST       GO TO THE NEXT STEP IN PROGRAM\nADASEQ   A      1,UNADDR(11) TRANSLATE NEW LANGUAGE INTO ASSEMBLER\n         B      NACHST       GO TO THE NEXT STEP IN PROGRAM\nADISEQ   A      3,UNADDR(11) TRANSLATE NEW LANGUAGE INTO ASSEMPLER\n         B      NACHST       GO TO THE NEXT STEP IN PROGRAM\nSBASEQ   S      1,UNADDR(11) TRANSLATE NEW LANGUAGE INTO ASSEMPLER\n         B      NACHST       GO TO THE NEXT STEP IN PROGRAM\nSBISEQ   S      3,UNADDR(11) TRANSLATE NEW LANGUAGE INTO ASSEMPLER\n         B      NACHST       GO TO THE NEXT STEP IN PROGRAM\nMTASEQ   M      2,UNADDR(11) TRANSLATE NEW LANGUAGE INTO ASSEMPLER\n         LR     1,3\n         B      NACHST       GO TO THE NEXT STEP IN PROGRAM\nMTISEQ   M      2,UNADDR(11) TRANSLATE NEW LANGUAGE INTO ASSEMPLER\n         B      NACHST       GO TO THE NEXT STEP IN PROGRAM\nDVASEQ   D      2,UNADDR(11) TRANSLATE NEW LANGUAGE INTO ASSEMPLER\n         LR     1,3\n         B      NACHST       GO TO THE NEXT STEP IN PROGRAM\nDVISEQ   D      2,UNADDR(11) TRANSLATE NEW LANGUAGE INTO ASSEM!LER\n         B      NACHST       GO TO THE NEXT STEP IN PROGRAM\nGTSEQ    LA     15,UNADDR(11)  TRANSLATE INTO ASSEMBLER\n         B      AUSSER       GO TO NEXT STEP SKIPPING INCREMENT STEP\nIFLSEQ   SR     2,2          CLEAR REG 2 SO IT IS 0 FOR COMPARISON\n         CR     1,2          COMPARE REG 1 (ACCUMULATOR)  WITH 0\n         BNL    NACHST       GO TO NEXT STEP IN PROGRAM\n         LA     15,UNADDR(11)  TRANSLATE INTO ASSEMBLER\n         B      AUSSER       GO TO NEXT STEP SKIPPING INCREMENT STEP\nIFZSEQ   SR     2,2          CLEAR REG 2 SO IT IS 0 FOR COMPARISON\n         CR     1,2          COMPARE REG 1 (ACCUMULATOR ) WITH 0\n         BNE    NACHST       GO TO NEXT STEP IN PROGRAM\n         LA     15,UNADDR(11)  TRANSLATE INTO ASSEMBLER\n         B      AUSSER       GO TO NEXT STEP SKIPPING INCREMENT STEP\nIFHSEQ   SR     2,2          CLEAR REG 2 SO IT IS 0 FOR COMPARISON\n         CR     1,2          COMPARE REG 1 (ACCUMULATOR)  WITH 0\n         BNH    NACHST       GO TO NEXT STEP IN PROGRAM\n         LA     15,UNADDR(11)  TRANSLATE INTO ASSEMBLER\n         B      AUSSER       GO TO NEXT STEP SKIPPING INCREMENT STEP\nENDINT   L      13,SAVINT+4\n         LM     14,12,12(13)\n         BR     14\nSAVINT   DS      18F\nUNADDR   DS     F\nPKADDR   DS     F\nOPER     DS     F\nLENGTH   DC     C'0001'\n         LTORG\nLABINT   DC     C' INTERPRETER'\n      EJECT\nTESECT   DSECT\nLABTAB   DS      150F\nTESNUM   DC     256X'00'\nTESLET   DC     256X'00'\nADDATA   DS     F\nSOURCE   DS      4000C\nOUTPUT   DC     1000X'EE'\n         EJECT\n                END\n$ENTRY\nBEGIN JOB\n     WT   H1,15C\n     LD   I,Z1   Z1=0\nT5   RD   T1,I4   READ A NUMBER\n      LD   A,T1\n    IF  Z,D1   IF ZERO=>LAST NUMBER\n     WT   T1,I5\n   LD I,I1   INDEX INTO A1 ARRAY\n   ST  A,A1  STORE T1 IN ARRAY A1\n AD    I,F1   KICK UP INDEX\n    ST  I,I1   SAVE INDEX FOR NEXT LOOP\n    LD  I,Z1  INDEX=0\n    GT  T5   GO TO READ AGAIN\nT1   DS   F\nZ1   DC   F'0'\nI1   DC   F'0'\nF1   DC   F'4'\nH1  DC  C'THE NUMBERS ARE'\nD1  LD  A,I1  LOAD VALUE OF INDEX\n  DV A,F1\n     ST   A,N1   N1=NUMBER OF #'S\n    LD  I,Z1   INDEX=0\n   ST  I,I1    I1=0\n   WT   H2,11C\nT6 LD I,I1   LOAD INDEX\n   LD  A,A1 GET VALUE FROM ARRAY\n     MT  A,A1   SQUARE THE VALUE\n   AD    I,F1   KICK UP INDEX\n     ST   I,I1   SAVE INDEX\n     LD   I,Z1   INDEX=0\n     ST   A,T1\n     WT   T1,I10   WRITE SQUARED NUMBER\n     LD   A,S1   LOAD THE SUM\n     AD    A,T1   SUM THE SQUARES\n     ST   A,S1    SAVE THE SUM\n   LD   A,N1 N1= NUMBER OF TIMES TO LOOP\n    SB   A,C1   SUBTRACT ONE\n    ST   A,N1    SAVE COPY OF N1\n   IF   H,T6  IF POSITIVE THEN LOOP\n    WT  H3,14C\n    WT  S1,I8   WRITE THE SUM OF SQUARES\n    HT       STOP\nN1 DC F'0'\nC1  DC 2F'1'\nH2  DC  C'SQUARES ARE'\nS1           DC          F'0'\nH3   DC   C'SUM OF SQUARES'\nA1  DC       20F'0'\n    END\n##\n  30\n   2\n   4\n  25\n##\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ASTEST03": {"ttr": 21001, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x132?\\x01\\x132?\\x010\\x02\\xe0\\x02\\xe0\\x00\\x00\\xc1\\xe2\\xe2\\xc9\\xe2\\xe3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-11-19T00:00:00", "modifydate": "2013-11-19T01:30:00", "lines": 736, "newlines": 736, "modlines": 0, "user": "ASSIST"}, "text": "//ASTEST03 JOB (SYS),'ASSIST IVP TEST #3',CLASS=S,MSGCLASS=X\n//*\n//TESTPROG EXEC ASSIST\n//SYSIN DD *\n$JOB   ASSIST REPTEST,REPL\n         TITLE 'REPLACE MONITOR TEST DECK #1'\n*        *** TESTS USAGE OF XREPL INSTRUCTION, CREATES MANY ERRORS.\n*        ALSO SHOWS CALL OF NONEXISTENT ENTRYPOINT.\nBROPS2   CSECT\nRB       EQU   8                   REG RB\n         ENTRY BRINIT,BRUSIN,BRDROP         NOTE BRDISP IS MISSING\n*        BRINIT FETCHES THE RFLAG AND DUMPS IT AND REGS.\n*              IT ALSO ERASES REGS 12-13, AND SETS RFLAG SO THAT\n*              REGS ARE ONLY PRINTED ON ERRORS.\n*        BRUSIN FETCHES THE INSTRUCTION COUNTER, AND SETS THE RFLAG.\n*              BRDROP SETS RB ALWAYS , THUS MAKING ERRORS SOME TIMES.\n*              BRDISP IS MISSING, SO IT SHOULD ABEND FIRST TIME CALLD\n         SPACE 1\nBRINIT   EQU   *\n         USING *,15                NOTE ENTRY USING\n         XREPL RFLAG,1             FETCH THE RFLAG\n         XDUMP RFLAG,2             DUMP IT TO SEE IF OK\n         XDUMP ,                   DUMP THE REGS TO SEE THEM\n         SR    12,12               MESS UP 12\n         SR    13,13               MESS UP 13 TOO\n         XREPL RFLAG2,0            SRT THE RLFAG, ALL OFF\n         BR    14                  RETURN\nBRUSIN   EQU   *\n         USING *,15                NOTE ENTRY USING\n         XREPL RFLAG,1             FETCH TO SEE IF BITS SET\n         XDUMP RFLAG,2             DUMP IT TO SEE IF BITS SET\n         XREPL ICOUNT,2            INSTRUCTION COUNT FECTH\n         L     0,ICOUNT            PUT INTO REG\n         XDUMP ,                   REGS\n         XREPL RFLAG1,0            SET TO NEW VALUE, STMTS ONLY\n         BR    14                  RETURN, HAVING MESSD 0\n         SPACE 1\nBRDROP   EQU   *\n         USING *,15                NOTE ENTRY USING\n         LA    RB,4                SHOW ERROR\n         BR    14                  RETURN, OK ONLY IF BAD DROP DONE\n         SPACE 1\nRFLAG    DC    H'0'                TO FETCH RFLAG HERE\nRFLAG1   DC    H'1'                ONLY PRINT STMT\nRFLAG2   DC    H'0'                ALL FLAGS OFF\nICOUNT   DC    F'0'                INSTRUCTION COUNTER\n         END\n$ENTRY\n         TITLE 'TEST DECK FOR REPLACEMENT OF BR- '\nCSECT1   CSECT\n         USING *,15                CALL TO USING\n         USING *,14                ANOTHER CALL TO USING\n         DROP  14                  REMOVE USING-PRODUCE REPL ERR AR059\n         DROP  13                  SHOULD BE OK REPL\n         LA    0,CSECT1            SHOULD CALL BR - ZAP HIM\n         LA    0,CSECT1            BRDISP SHOULD HAVE ABENDED LAST TIME\n         DROP  15\n         END\n$JOB   ASSIST  REPTEST,REPL\n         TITLE 'REPLACE TEST # 2 - CANNOT FIND CSECT NAME'\n*              THIS SHOULD PRODUCE MESSAGE AR100\nBROPS3   CSECT\n*              WE HAVE MISPELLED BROPS2\n         BR    14                  RETURN\n         END\n$ENTRY         EXECUTION SHOULD NO T BEGIN EVEN THOUGH THIS PRESENT.\n*              FAKE DATA CARD -SHOULD NOT BE SEEN BY ASSEMBLER.\n$JOB   ASSIST  REPTEST,REPL\n         TITLE 'REPLACE TEST # 3 - ABEND DURING EXECUTION'\n*        *** SHOULD PRODUCE 224 COMPLETION CODE.\nBROPS2   CSECT\n         ENTRY BRINIT,BRUSIN,BRDROP,BRDISP  ALL ENTRIES\nBRINIT   EQU   *\n         LA    15,20               SET UP FOR BAD BRANCH\n         BR    15                  BRANCH OUT OF PROGRAM\nBRUSIN   EQU   *\n         DC    H'0'                ABEND NOW\n         END   ,                   BRDROP,BRDISP UNDEFINED\n$ENTRY\n$JOB   ASSIST  REPTEST,REPL,NERR=1\n         TITLE 'REPLACE MONITOR TEST - CALLING ALLOWED'\n*        *** REQUIRES REPLACEMENT OPTION 2 - WILL NOT RUN IF ONLY\n*        REPLACEMENT OPTION 1 EXISTS.\nEVALUT   CSECT\n         EXTRN SDBCDX,SDDTRM       MAKE EXTRN, SINCE ASSIST MODS\nRA       EQU   7\nRD       EQU   10\nRE       EQU   11\n*              THIS ROUTINE WILL JUST CALL SDBCDX OR SDDTRM, THUS\n*              ASSUMING THAT IT IS SCANNING A SELF-DEFINING TERM.\n*              IT CLEARS REGS RD,RE FOR SDTERM, SO THAT THE ANSWER\n*              WILL BE CORRECT IF ACTUALLY LOOKING AT SD TERM.\n         USING *,15\n         ST    14,SAV14            SAVE THIS REG\n         CLI   0(RA),C'0'          WAS FIRST ONE A DIGIT\n         BNL   EVDIGIT             YES, GO THERE\n         L     RE,=V(SDBCDX)       OVERALL ENTRY\n         CLC   0(3,RA),=C'X''F'    SPECIAL-SCREW UP REGS\n         BNE   EVCALL              NO, GO CALL\n         SR    RA,RA               MESS THIS UP,ILLEGAL\n         B     EVCALL              GO CALL\nEVDIGIT  L     RE,=V(SDDTRM)       DECIMAL SELF DEF TERM\nEVCALL   LR    15,RE               MOVE OVER\n         BALR  14,15               CALL ROUTINE\n         USING *,14                NEW USING\n         SR    RD,RD               CLEAR\n         SR    RE,RE               CLEAR\n         L     14,SAV14            RESOTER RETURN @\n         BR    14                  RETURN\nSAV14    DS    F\n         DC    V(SYFIND)           NOT FLAGGED EXTRN, SHOULD BE UNRESV\n         END\n$ENTRY\n         TITLE 'TEST PROGRAM FOR EVALUT'\n         START\n         DC    A(SYMBOL)           WILL BE WRONG\n         DC    A(255)              SHOULD WORK OK\n         DC    A(C'12345')         SHOULD BE ERROR RETURN ALL OVER\n         DC    A(123456789123)     ERROR RETURN\n         DC    A(X'F0')            SHOUL PASS WRONG PARM TO SDBCDX\nSYMBOL   EQU   *\n         DC    A(0)                NO MORE CALLS\n         END\n$JOB   ASSIST  REPTEST,REPL\n         TITLE 'REPLACE TEST - CHECK STORAGE PROTECTION'\nEVALUT   CSECT\n         STC   0,0(7)              STORE AT SCAN PTR-SHOULD ABEND 0C4\n         BR   14\n         END\n$ENTRY\nTESTPROG CSECT\n         DC    A(X'FF')            MAKE SURE EXPRESSION EVAL CALLED\n         END\n$JOB   ASSIST  REPTEST,REPL\n         TITLE 'REPLACE MONITOR TEST - CBCONS'\nCBCONS   CSECT\n         ENTRY CBCON1,CBCON2       OK\n*              MODULE ACTS AS THOUGH ALL CONSTAS ARE B'1'\n         USING *,15\nCBCON1   LA    7,1(7)              BUMP SCAN PTR\n         SR    8,8                 SHOW OK\n         LA    9,1                 SHOW LENGTH OF 1\n         BR    14                  RETURN\n         USING *,15\nCBCON2   LA    7,1(7)              BUMP SCAN PTR\n         LA    9,=B'1'             @ GOOD ONE\n         BR    14                  RET\n         END\n$ENTRY\n         TITLE 'TEST CBCON1 WITH REPLACE MONITOR'\nCBCOTEST CSECT\n         DC    B'1'                COMPLETELY OK\n         DC    B'0'                RIGHT SCAN, WRONG VALUE\n         DC    B'000000001'        BAD SCAN PTR, LENGTH\n         DC    B'11'               BAD SCAN PTR\n         DC    B'2'                BAD CONST, NOT FLAGGED RIGHT\n         DC    B'012'              BAD CONST, NOT FLAGGED\n         DC    B'01'               BAD SCAN PTR, OK VALUE\n         END\n$JOB   ASSIST  REPTEST,REPL\n         TITLE 'REPLACE MONITOR TEST - CCCONS'\nCCCONS   CSECT\n         ENTRY CCCON1,CCCON2\n*              TREATS ALL CONSTANTS AS CL5'A'\n         USING *,15\nCCCON1   LA    7,1(7)              SCAN PTR\n         SR    8,8                 SHOW OK\n         LA    9,1                 SHOW LENGTH WE CAN SEE\n         BR    14\n         USING *,15\nCCCON2   LA    7,1(7)              SXAN PTR\n         LA    9,=CL5'A'           @ OK CONST\n         BR    14\n         END\n$ENTRY\n         TITLE 'TEST PROGRAM FOR REPLACE MONITOR CCCONS'\nCCCOTEST CSECT\n         DC    CL5'A'              OK\n         DC    C'A    '            GOO VALUE, LENGTH, BAD SCAN PTR\n         DC    C'          '       BAD LENGTH,VALUE\n         DC    C'&'                BAD CONST\n         END\n$JOB   ASSIST  REPTEST,REPL\n         TITLE 'REPLACE MONITRO CDECNS TEST'\nCDECNS   CSECT\n         ENTRY CDECN1,CDECN2\n*              MODULE ACTS AS THOUGH ALL ARE D'1.1'\n         USING *,15\nCDECN1   LA    7,3(7)              SCAN PTR\n         SR    8,8                 SHOW OK\n         BR    14                  RETRN\nCDECN2   LA    7,3(7)              SCAN PTR\n         SR    8,8                 SHOW OK\n         LA    9,=D'1.1'           @ CONST\n         BR    14                  RETURN\n         END\n$ENTRY\n         TITLE 'REPLACE MONITOR TEST PROGRAM - CDECNS'\nCDECTEST CSECT\n         DC    D'1.1'              OK\n         DC    D'01.1'             GOOD VALUE, BAD SCAN PTR\n         DC    D'1.0'              GOOD SCAN PTR, BAD L  VALUE\n         DC    D'1.1 '             BAD CONSTANT\n         END\n$JOB   ASSIST  REPTEST,REPL\n         TITLE 'REPLACE MONTOR TEST - CFHCNS'\nCFHCNS   CSECT\n         ENTRY CFHCN1,CFHCN2\n*              ALL ACT AS THOUGH CONST IS F'3'\n         USING *,15\nCFHCN1   LA    7,1(7)              SCAN PTR\n         SR    8,8\n         BR    14                  RETURN\n         USING *,15\nCFHCN2   LA    7,1(7)              SCAN PTR\n         SR    8,8                 SHOW GOOD\n         LA    9,=F'3'             GOOD S CONST\n         END\n$ENTRY\n         TITLE 'REPLACE MONITOR TEST - CFHCNS'\nCFHCTEST CSECT\n         DC    F'3'                OK\n         DC    F'1'                GOOD SCAN, BAD VALUE\n         DC    F'01'               GOOD VALUE, BAD SCAN\n         DC    F'                  BAD CONST, WON'T FLAG RIGHT\n         END\n$JOB   ASSIST  REPTEST,REPL\n         TITLE 'REPLACE MONITOR TEST -      OPCOD1'\nOPCOD1   CSECT\n*              ANY OPCODE BEGINNING WITH A IS TREATED AS 'A'.\n*              ALL OTHERS ARE TREATED A BAD.\n         ENTRY OPINIT,OPFIND\nOPINIT   BR    14                  OK\n         USING *,15\nOPFIND   CLI   0(7),C'A'           WE EXPECT ADD\n         BE    FOUND               YES GO THER\n         CLI   0(7),C'C'           WAS IT C\n         BE    FOUND               YES, BRANCH, WILL SHOW WORNG\n         LA    8,X'32'             SHPW $ERIVOPC FLAG\n         BR    14                  RETURN, LEAVING SCAN PTR\nFOUND    LA    7,1(7)              SCA NPTR\n         SR    8,8                 SHOW GOOD\n         LA    9,A-3               @ FAKE OPCODTB\n         BR    14                  RETN\nA        DC    C'A'                FAKE OPCODTB\n         END\n$ENTRY\n         TITLE 'TESRT REPL MONITOR WITH OPCOD1'\nOPCOTEST CSECT\n         A     0,0(1)              OK\n         B     0,0(1)              WILL FLAG WRONG, ISN'T\n         C     0,0(1)              WILL SHOW WRONG SYMBOL IN TA LE\n         AR    0,0                 WILL NOT HAVE RIGHT SCAN PTR,OPCDE\n         ST    0,0(1)              NOT RIGHT\n         Z     0(0(1)              WILL FLAG, CORRECTLY\n$JOB   ASSIST  REPTEST,REPL\n         TITLE 'REPLACE MONITOR - SYMOPS TEST'\n*        *** THIS PROGRAM ASSEMBLES CORRECTLY, HAS SYEND2 FLAGGED WITH\n*        MESSAGE AR002, THEN HANDLES A NUMBER OF CALLS  UNTIL SYEND2\n*        IS CALLED, AT WHICH TIME IT STOPS WITH MESSAGE AR101.\nSYMOPS   CSECT\n         ENTRY SYINT1,SYENT1,SYFIND         NOTE SYEND2 MISSING\nSYINT1   BR    14                  RETUNR\n*              ANY SYMBOL BEGINNING WITH A IS TREATED AS A, IN TABLE\n*              ANY ONE STARTING WITH B IS TREATED AS B, NEWLY ENTERED\n*              ANY OTHER -NOT IN TABLE\n         USING *,15\nSYENT1   EQU   *\nSYFIND   CLI   0(7),C'A'           DOES IT BEGIN WITH A\n         BE    SYMA                YES, GO THER\n         CLI   0(7),C'B'           BEGIN WITH B\n         BE    SYMB                YES, GO THER\n*        TREAT AS NOT IN TABLE\n         LA    8,4                 SHOW NOT THER\n         BR    14                  RETNR\nSYMA     LA    7,A-12              SHOW A FAKE BLOCK\n         SR    8,8                 IN TABLE ALREADY\n         BR    14                  RETURN\nSYMB     LA    8,4                 SHOW NOT INTABLE\n         LA    7,B-12              SHOW @\n         BR    14                  RETUNR\nA        DC    C'A'\nB        DC    C'B'\n         END\n$ENTRY\nA        LA    0,A                 WRONG FIRST TIME, OK NEXT\nB        LA    0,B                 RIGHT FIRST, WRONG SECOND\nAA       LA    0,AA                WRONG ALWAYS\nBB       LA    0,BB                WRONG ALWAYS\nC        LA    0,C                 LABEL OK, WRONG VALE, CALL WRONG\n         LA    0,D                 NOT IN TABLE, OK FLAGGED RIGHT\n         END\n$JOB   ASSIST  REPTEST,REPL\n*        TEST DECK FROM CMPSC 411, SPRING 1971.\n*        *** SAMPLE PROGRAM - 2ND ASSEMBLER COURSE - 123 STMTS,\n*        ABOUT 3 PAGES OF OUTPUT , SHOWING NO DEBUGGING CODE, SINCE\n*        THIS IS A FINAL VERSION OF PROGRAM.\nBROPS2   CSECT\n         ENTRY  BRINIT,BRUSIN,BRDROP,BRDISP\nRA       EQU    7\nRB       EQU    8\nRC       EQU    9\nRD       EQU    10\nRE       EQU    11\n         SPACE  3\n* THIS ROUTINE REPLACES THE BASE REGISTER ROUTINE CURRENTLY\n* EMPLOYED BY THE ASSIST PACKAGE. 'TABLE' IS USED TO STORE\n* SECTION ID'S AND THE CONTENTS OF THE BASE REGISTERS. IF A REGISTER\n* IS BEING USED AS A BASE REGISTER, THE ID FIELD CONTAINS THE\n* CSECT'S OR DSECT'S ID. OTHERWISE THE ID FIELD IS ZERO. THE TABLE\n* WAS CHOOSEN AS COMPOSED ONLY OF FULL WORDS TO INCREASE THE SPEED\n* OF EXECUTION. THE ADDITIONAL SPACE REQUIRED WAS 48 BYTES.  HOWEVER,\n* THIS ADDITION TO THE SPACE REQUIRED ALLOWED A REDUCTION IN THE\n* TIME FOR INSERTING THE ADDRESS TO WHICH A REGISTER IS POINTING\n* AND THE ID OF THE SECTION BY ABOUT 11.45 MICROSECONDS. AN EQUIVALENT\n* AMOUNT OF TIME IS SAVED IN REMOVING THE SAME INFORMATIO FOR\n* COMPUTING DISPLACEMENTS\n         SPACE  3\n* BRINIT  FROM THIS ENTRY POINT ALL INITILIZATION TAKES PLACE\n         SPACE  1\nBRINIT   B      12(,15)\n         DC     X'07'\n         DC     CL7'BRINIT '\n         USING  BRINIT,15\n         MVI    TABLE,X'00'        INSERT ZERO\n         MVC    TABLE+1(127),TABLE FILL WITH ZEROS\n         SPM    14\n         BR     14\n         SPACE  3\n* BRUSIN  THIS ENTRY IS CALLED WHENEVER A USING IS FOUND AND DECODED\n* TO NOTE THAT A GIVEN REGISTER CAN BE USED WITH A GIVEN ADDRESS\n* AND ID\n         SPACE 1\nBRUSIN   B      12(,15)\n         DC     X'07'\n         DC     CL7'BRUSIN '\n         USING  BRUSIN,15\n         SLL    RA,3               MULTIPLY BY 8 (8 BYTES/ENTRY)\n         A      RA,ADDR            COMPUTE TABLE ENTRY ADDRESS\n         USING  FORM,RA            DECLARE DSECT BASE REGISTER\n         ST     RC,ID              STORE ID\n         ST     RB,ADDRESS         ADDRESS CONTAINED BY BASE REG\n         SPM    14                 RESET CC\n         BR     14\n         SPACE  3\n* BRDROP  HANDLES DROPS\n         SPACE  1\nBRDROP   B      12(,15)\n         DC     X'07'\n         DC     CL7'BRDROP '\n         USING  BRDROP,15          BASE REG\n         SLL    RA,3               MULT BY 8 (8BYTES/ENTRY)\n         A      RA,ADDR            GET ENTRY ADDRESS\n         USING  FORM,RA            DSECT BASE REG\n         L      RE,ID              GET ID FOR 'ACTIVE' TEST\n         LTR    RE,RE              TEST FOR ID=0;=> REG WAS NOT ACTIVE\n         BP     NEXT\n         LA     RB,255             SET FLAG => REG WAS NOT ACTIVE\n         B      LEAVE\nNEXT     SR     RB,RB              ZERO FLAG => REG WAS ACTIVE\n         ST     RB,ID              SET ID=0=>NOW UNASSIGNED\nLEAVE    SPM    14\n         BR     14\n         SPACE  3\n* BRDISP  THIS ENTRY IS CALLED WHENEVER AN ADDRESS MUST BE CONVERTED TO\n* BASE - DISPLACEMENT FORM\n* FLAG=N  =>HAVE NOT YET COMPUTED A DISP< 4096; FLAG=Y => HAVE COAMPUTE\n* A DISP < 4096\n         SPACE  1\nBRDISP   B      12(,15)\n         DC     X'07'\n         DC     CL7'BRDISP '\n         USING  BRDISP,15\n         LA     RE,128\n         SLL    RE,5               PUT 4096 IN \"SMALLEST\"\n         ST     RE,SMALLEST\n         MVI    FLAG,C'N'          INITIALIZE FLAG => NO DISP<4096 YET\n         LA     RD,15              INITIALIZE REG # RECORDER\n         LA     RC,120\n         A      RC,ADDR            SET POINTER TO LAST MEMBER OF TABLE\n         USING  FORM,RC            BASE REG FOR DSECT\nAGAIN    LR     RE,RA              SAVE ADDRESS PASSED\n         C      RB,ID              FROM SAME SECTION?\n         BNE    UPDATE             BRANCH IF NOT A POSSIBLE BASE REG\n         S      RE,ADDRESS         FIND DISPLACEMENT\n         LTR    RE,RE\n         BM     UPDATE             ENSURE DISP IS POSITIVE\n         C      RE,SMALLEST        SMALLER DISPLACEMENT?\n         BNL    UPDATE             BRANCH IF SMALLEST<= LATEST DISP\n         ST     RE,SMALLEST        STORE NEWEST DISP\n         STC    RD,REGNO           STORE REG#\n         MVI    FLAG,C'Y'          INDICATE INITIAL VALUE CHANGED\nUPDATE   BCTR   RD,0               DECREMENT REG# RECORDER\n         S      RC,EIGHT           POINT TO NEXT LOWER REG#\n         LTR    RD,RD              TOP OF TABLE?\n         BNM    AGAIN              IF NOT, GO TO NEXT ENTRY\n         CLI    FLAG,C'Y'          FINISHED TABLE-COMPUTED DISP<4096?\n         BNE    BADOUT             BRANCH IF NO DISP<4096\n         SR     RB,RB              SET FLAG => CONVERSION WAS OK\n         L      RA,SMALLEST        LOAD DISP FOR TRANSFER\n         SR     RC,RC\n         IC     RC,REGNO           PICK UP REG NUMB\n         SLL    RC,12              PUT IN PROPER COLUMNS\n         OR     RA,RC              PUT BASE IN WITH DISP IN REG RA\nBADOUT   SPM    14\n         BR     14\n         SPACE  3\nADDR     DC     A(TABLE)\nEIGHT    DC     F'8'\nSMALLEST DS     F\nTABLE    DS     128C\nFLAG     DS     C\nREGNO    DS     C\n         LTORG\n         SPACE  3\nFORM     DSECT\nID       DS     F\nADDRESS  DS     F\n         END\n$ENTRY\n         TITLE 'ASSIST BASE REGISTER/USING/DROP TEST PROGRAM'\nTEST     CSECT\n         BALR  12,0\n         USING *,12\nT1       L     0,AA5\n         L     5,AA4\n         USING AA5,9\n         ST    3,AA5\n         USING AA5,10\n         A     2,AA5\n         USING AA4,10\n         SL    3,AA5\n         ST    3,AA4\n         DROP  10\n         USING DSECT1,7\n         STH   4,DS1\n         LH    5,DS6\n         DROP  8,10\n         CVB   6,DS8\n         USING DSECT1,9\n         CVD   6,DS8\n         USING DSECT2,10\n         M     8,DS4\n         LA    5,CARD\n         D     8,DS5\n         DROP  10\n         B     T1\n         IC    10,DS2A\n         LA    11,OUTR\n         USING *,13\n         ST    5,AA4\nAA4      DS    F\n         DS    1500F\nOUTR     DS    C\nAA5      DS    F\nDSECT1   DSECT\nDS1      DS    H\nDS2      DS    HL8\nDS4      DS    A\nDS8      DS    D\nDSECT2   DSECT\nCARD     DS    CL80\nDS2A     DS    P\nBASE     CSECT\n         USING *,13,14,15\n         DROP  8,12\n         AH    6,DS1\n         AH    4,AA6\n         L     5,AA5\n         DROP  7,9,10\n         DROP  13,14,15\nAA6      DS    H\n         END\n$JOB   ASSIST  REPTEST,REPL\n         TITLE 'BASE REGISTER PROBLEM - CHUCK PFLEEGER'\n*        *** SAMPLE PROGRAM - 2ND ASSEMBLER-LEVEL COURSE -\n*        206 STMTS, WITH NO ERRORS IN PROGRAM.\n*        TEST DECK FROM CMPSC 411, SPRING 1971.\n***                                                               ***\n***  ***********************************************************  ***\n***                                                               ***\n***          CHUCK PFLEEGER - BASE REGISTER PROBLEM               ***\n***                                                               ***\n***          COMPSC - 411  -  MAY 5, 1971                         ***\n***                                                               ***\n***  SYMBOLS:                                                     ***\n***          A,B,C,D - SYMBOLIC REGISTERS 7,8,9, AND 10           ***\n***          DSBASE - REG. 11 - USED FOR BASE REG. IN DSECT       ***\n***          HEADLINK - LAVSLINK  -  LINKS TO THE HEADS OF        ***\n***              THE ACTIVE BASE REGISTER LIST, AND THE           ***\n***              AVAILABLE SPACE LIST.  A ZERO IN EITHER OF       ***\n***              THESE INDICATES THE NULL LIST.  THEY AND THE     ***\n***              LINKS ARE ARRANGED FROM A DISPLACEMENT OF 2 TO   ***\n***              A DISPLACEMENT OF 122 FROM THE POINT BRTAB,      ***\n***              WHICH IS TWO BYTES BEFORE THE START OF THE       ***\n***              BASE REGISTER TABLE.                             ***\n***          ID IS THE PORTION OF A NODE FOR SECTION ID           ***\n***          RNO IS THE PORTION OF A NODE FOR REGISTER NO.        ***\n***          LINK IS THE LOCATION IN THE NODE FOR THE LINK TO     ***\n***              THE NEXT CELL (RELATIVE TO BRTAB)                ***\n***          ADDR IS THE PORTION OF A NODE FOR THE ADDRESS        ***\n***              IN A BASE REGISTER.                              ***\n***          NEWID IS THE NEW SECTION ID TO INSERT                ***\n***          NEWNO IS THE NEW REGISTER NO TO ALLOCATE             ***\n***          NEWLINK IS THE LINK OF THIS NEW CELL                 ***\n***          NEWADDR IS THE ADDRESS CURRENTLY BEING HANDLED.      ***\n***                                                               ***\n***  ***********************************************************  ***\n  SPACE 4\nBROPS2   CSECT\n         ENTRY BRINIT,BRUSIN,BRDROP,BRDISP\nA        EQU   7\nB        EQU   8\nC        EQU   9\nD        EQU   10\nDSBASE   EQU   11            BASE REG. FOR DSECT\n  SPACE 4\n***              BRINIT - INITIALIZE CONSTANT AREAS               ***\n***                                                               ***\nBRINIT   EQU   *\n         USING *,15\n         USING BRDSCT,DSBASE\n         LA    D,15          SET UP FOR BCT\n         LA    C,2           DITTO\n         STH   C,LAVSLINK    LINK TO TOP OF LAVS\n         LA    DSBASE,BRTAB+2     LOC OF FIRST CELL\n***  SET UP LINKS WITHIN CELLS.                                   ***\nINITLOOP LA    C,8(C)        LINK FOR NEXT CELL\n         STH   C,LINK        INSERT LINK\n         LA    DSBASE,8(DSBASE)   MOVE TO NEXT CELL\n         BCT   10,INITLOOP   BRANCH TO INITIALIZE ALL\n***  SET UP PROPER HEAD AND END POINTERS.                         ***\n         SR    C,C\n         STH   C,HEADLINK    GROUND ACTIVE LIST\n         STH   C,LINK        GROUND BOTTOM OF LAVS\n         BR    14            RETURN\n  SPACE 4\n***              BRUSIN - PROCESS USINGS                          ***\n***                                                               ***\nBRUSIN   EQU   *\n         USING *,15\n         STC   A,NEWNO       INSERT NEW REG, NO\n***  FIRST BEGIN CELL WITH ID, RNO, AND ADDR FIELDS               ***\n         ST    B,NEWADDR     INSERT NEW B/REG CONTENTS\n         STC   C,NEWID       INSERT NEW ID\n         LH    DSBASE,HEADLINK\n         LTR   DSBASE,DSBASE LIST EMPTY?\n         BZ    INSERT        NO ENTRY FOUND\n         LA    DSBASE,BRTAB(DSBASE)    START OF LIST\n***  BEGIN SEARCH FOR THIS REGISTER ALREADY IN USE                ***\nUSINLOOP CLC   NEWNO,RNO     COMPARE REG. NOS.\n         BZ    REPLACE       SAME REGISTER ALREADY IN USE\n         LH    D,LINK        LINK TO NEXT CELL\n         LTR   D,D           LAST CELL?\n         BZ    INSERT        REGISTER NOT NOW IN LIST\n         LA    DSBASE,BRTAB(D)    LINK TO NEXT CELL\n         B     USINLOOP\n***  IF REGISTER IS NOW ACTIVE, MERELY INSERT THE SAME LINK       ***\n***     IN A NEW CELL.                                            ***\nREPLACE  MVC   NEWLINK,LINK  INSERT PROPER LINK\n         B     LAST          MOVE IN NEW CELL\n***  IF REGISTER IS NOT ACTIVE, INSERT A CELL FROM LAVS.          ***\nINSERT   LH    D,LAVSLINK    PTR. TO LAVS\n         LA    DSBASE,BRTAB(D)    GET NEXT AVAILABLE CELL\n         LH    C,LINK        RETAIN PREVIOUS LINK\n         STH   C,LAVSLINK    NEW LAVS POINTER\n         LH    B,HEADLINK    OLD HEADER IS NEW LINK TO NEXT CELL\n         STH   B,NEWLINK\n         STH   D,HEADLINK    POINTER HEADER AT FIST CELL\n***  MOVE THE TEMPORARY CELL INTO ITS PROPER LOCATION.            ***\nLAST     LM    A,B,NEWID     GET NEW INFO NODE\n         STM   A,B,ID        PUT AT NEXT AVAILABLE LOCATION\n         BR    14            RETURN\n  SPACE 4\n***              BRDROP - HANDLE DROP STATEMENTS                  ***\n***                                                               ***\nBRDROP   EQU   *\n         USING *,15\n         STC   A,NEWNO       INSERT REG. NO DROPPING\n         LH    DSBASE,HEADLINK    TOP OF LIST\n         LTR   DSBASE,DSBASE LIST EMPTY\n         BZ    RETBAD        IF EMPTY, RETURN CODE=BAD\n         LA    DSBASE,BRTAB(DSBASE)    GET START OF LIST\n         LA    D,HEADLINK-2  TO PLACE HEAD PTR PROPERLY IF SINGLE LIST\n***  CHECK FOR THE OCCURANCE OF THIS REGISTER NO.                 ***\nDROPLOOP CLC   NEWNO,RNO     CHECK REG. NOS.\n         BZ    FOUND         PROPER REG. FOUND\n         LH    C,LINK        IF NO, GET LINK TO NEXT CELL\n         LTR   C,C           LIST EMPTY?\n         BZ    RETBAD        REGISTER NOT IN LIST\n         LR    D,DSBASE      BACK POINTER\n         LA    DSBASE,BRTAB(C)    LINK TO NEXT CELL\n         B     DROPLOOP      GET NEXT CELL\n***  IF FOUND, DELETE ITS ENTRY AND RETURN TO LAVS.               ***\nFOUND    LH    B,2(D)        GET PREVIOUS LINK\n         LH    C,LINK        GET CURRENT LINK\n         STH   C,2(D)        LINK AROUND THIS CELL\n         LH    A,LAVSLINK    SAVE PREVIOUS LAVS LINK\n         STH   A,LINK        POINT TO TOP OF LAVS\n         STH   B,LAVSLINK    UPDATE TOP OF LAVS\n         SR    B,B           GOOD RETURN\n         BR    14\n***  IF NOT FOUND, RETURN ERROR CODE.                             ***\nRETBAD   LR    B,14          BAD RETURN\n         BR    14            RETURN\n  SPACE 4\n***              BRDISP - CALCULATE DISPLACEMENTS                 ***\n***                                                               ***\nBRDISP   EQU   *\n         USING *,15\n         STC   B,NEWID       INSERT NEW ID\n***  SEEK ADDRESS <= 4095 WITH AVAILABLE REGISTER                 ***\n         LA    D,4095        ADDRESS TO COMPARE AGAINST\n         MVI   NEWNO,X'00'   CLEAR FOR NEW REG. NO\n         LH    DSBASE,HEADLINK    TOP OF LIST\n         LTR   DSBASE,DSBASE\n         BZ    BADDISP       LIST EMPTY\n         LA    DSBASE,BRTAB(DSBASE)    GO T O TOP OF LIST\n***  CHECK SECTION ID FIRST                                       ***\nDISPLOOP CLC   NEWID,ID      CHECK FOR SAME SECTION ID\n         BNZ   ADVPNT        ADVANCE IF NOT EQUAL\n***  IF SECTION IDS AGREE, CALCULATE DISPLACEMENT                 ***\n         LR    C,A           GET ABSOLUTE ADDR\n         S     C,ADDR        SUBTRACT BASE ADDR\n         BM    ADVPNT        BRANCH IF NOT + DISPLACEMENT\n         SR    B,B\n***  SET UP TO COMPARE REGISTER NOS. IF NECESSARY                 ***\n         IC    B,RNO         PICK UP REG. NO\n         LA    B,1(B)        INCREASE REGISTER NO.\n         CR    D,C           CHECK IF DISPLACEMENT WAS BETTER\n***  COMPARE DISPLACEMENTS. IF OLD HIGH SWITCH; NEW HIGH SKIP     ***\n         BH    SWITCH        SWITCH IF BETTER\n         BL    ADVPNT        GET NEXT CELL IF WORSE\n***  IF DISPLACEMENTS EQUAL, COMPARE REGISTER NUMBERS.            ***\n         EX    B,CLI         COMPARE NUMBERS\n         BNL   ADVPNT        GET NEW CELL IF NOT HIGHER NO.\nSWITCH   STC   B,NEWNO       STORE NEW REG. NO\n         LR    D,C           SHOW NEW DISPLACEMENT\nADVPNT   LH    B,LINK        GO TO NEXT NODE\n         LTR   B,B           CHECK IF END\n         BZ    DONEDISP      END OF LIST\n         LA    DSBASE,BRTAB(B)    LINK TO NEXT CELL\n         B     DISPLOOP\n***  CHECK IF ANY REGISTER HAD VALID DISPLACEMENT                 ***\nDONEDISP CLI   NEWNO,X'00'   NO REG FOUND?\n         BZ    BADDISP       RETURN=BAD\n***  FORM PROPER BASE DISPLACEMENT REFERENCE IN 16-31             ***\n         SLL   D,4           SHIFT FOR PROPER ALIGNMENT\n         ST    D,NEWADDR     BEST DISPLACEMENT\n         SR    B,B\n         IC    B,NEWNO       PICK UP REG. NO\n         BCTR  B,0           MOBE REG. NO DOWN AGAIN\n         STC   B,NEWADDR+1   PUT INTO BASE/DISP EXPR.\n         L     A,NEWADDR     PICK UP BASE/DISP FORM\n         SRL   A,4           SHIFT TO ALIGN AGAIN\n         SR    B,B           RETURN CODE GOOD\n         BR    14\nBADDISP  LR    8,14          RETURN BAD\n         BR    14            RETURN\n  SPACE 4\n***          DC AREA                                              ***\n***                                                               ***\nCLI      CLI   NEWNO,X'00'   EXECUTED CLI INSTR. CO COMPARE REG. NOS.\n         DS    0F\nBRTAB    EQU   *-2\n         DS    32F           LINKED LIST OF BASE REGS\nNEWID    DS    C             NEW SECTIO ID TO INSERT\nNEWNO    DS    C             NEW REG NO.\nNEWLINK  DS    H             LINK FOR NEXT CELL\nNEWADDR  DS    F             NEW BASE REG. CONTENTS\nHEADLINK DS    H             LINK AT TOP OF LIST (BACK POINTER)\nLAVSLINK DS    H             POINTER TO FIRST AVAILABLE CEEL\n  SPACE 4\n***          BRDSCT - BASE REGISTER LIST TEMPLATE                 ***\n***                                                               ***\nBRDSCT   DSECT\n*  DSECT   TO FLOAT OVER LINKED LIST\nID       DS    C             SECTION ID.\nRNO      DS    C             REGISTER NO\nLINK     DS    H             LINK TO NEXT CELL\nADDR     DS    F             CONTENTS OF BASE REG.\n         END\n$ENTRY\n         TITLE 'ASSIST BASE REGISTER/USING/DROP TEST PROGRAM'\nTEST     CSECT\n         BALR  12,0\n         USING *,12\nT1       L     0,AA5\n         L     5,AA4\n         USING AA5,9\n         ST    3,AA5\n         USING AA5,10\n         A     2,AA5\n         USING AA4,10\n         SL    3,AA5\n         ST    3,AA4\n         DROP  10\n         USING DSECT1,7\n         STH   4,DS1\n         LH    5,DS6\n         DROP  8,10\n         CVB   6,DS8\n         USING DSECT1,9\n         CVD   6,DS8\n         USING DSECT2,10\n         M     8,DS4\n         LA    5,CARD\n         D     8,DS5\n         DROP  10\n         B     T1\n         IC    10,DS2A\n         LA    11,OUTR\n         USING *,13\n         ST    5,AA4\nAA4      DS    F\n         DS    1500F\nOUTR     DS    C\nAA5      DS    F\nDSECT1   DSECT\nDS1      DS    H\nDS2      DS    HL8\nDS4      DS    A\nDS8      DS    D\nDSECT2   DSECT\nCARD     DS    CL80\nDS2A     DS    P\nBASE     CSECT\n         USING *,13,14,15\n         DROP  8,12\n         AH    6,DS1\n         AH    4,AA6\n         L     5,AA5\n         DROP  7,9,10\n         DROP  13,14,15\nAA6      DS    H\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ASTEST04": {"ttr": 21505, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x132?\\x01\\x132?\\x010\\x17y\\x17y\\x00\\x00\\xc1\\xe2\\xe2\\xc9\\xe2\\xe3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-11-19T00:00:00", "modifydate": "2013-11-19T01:30:00", "lines": 6009, "newlines": 6009, "modlines": 0, "user": "ASSIST"}, "text": "//ASTEST04 JOB (SYS),'ASSIST IVP TEST #4',CLASS=S,MSGCLASS=X\n//*\n//TESTPROG EXEC ASSIST\n//SYSIN DD *\n$JOB   ASSIST       MACRO=F\n***********************************************************************\n*                                                                     *\n*              SET OF JOBS - ILLUSTRATES MACRO PROCESSOR UNDER        *\n*              REASONABLE AND NORMAL OPERATIONS - WITH SOME ACTUAL    *\n*              PROGRAM WRITTEN PREVIOUSLY.                            *\n***********************************************************************\n         TITLE 'MACRO ILLUSTRATION TEST'\n         MACRO\n&L       @DOUB &REG,&TIMES\n         AIF   (&TIMES LT 1).ZERO\n         AIF   (&TIMES EQ 1).AR\n&L       SLL   &REG,&TIMES\n         MEXIT\n.AR      ANOP\n&L       AR    &REG,&REG\n.ZERO    MEND\n         SPACE 3\n         MACRO\n&L       MULT  &OUT,&IN,&BY\n         LCLA  &X,&BP,&DC,&SL,&WORK\n         LCLC  &AR,&SR\n         LCLB  &B(33)\n         AIF   (&BY NE 0).NOTZERO\n         MNOTE ,'*** MULT ***   JUST WHAT ARE YOU TRYING TO DO ??? ***'\n&L       SR    &OUT,&OUT\n         MEXIT\n         SPACE 1\n.NOTZERO AIF   (&BY GT 0).PLUS\n         LCR   &OUT,&IN\n&AR      SETC  'SR'\n&SR      SETC  'AR'\n&X       SETA  0-&BY\n         AGO   .CONVERT\n.PLUS    LR    &OUT,&IN\n&AR      SETC  'AR'\n&SR      SETC  'SR'\n&X       SETA  &BY\n.CONVERT ANOP\n&B(33)   SETB  (0)\n&B(32)   SETB  (0)\n&BP      SETA  31\n.CONLOOP ANOP\n&WORK    SETA  &X\n&X       SETA  &X/2\n&WORK    SETA  &WORK-2*&X\n&B(&BP)  SETB  (&WORK)\n&BP      SETA  &BP-1\n         AIF   (&BP GT 0).CONLOOP\n         AIF   (&X NE 0).BLEWIT\n&DC      SETA  0\n.FIRST   ANOP\n&BP      SETA  &BP+1\n         AIF   ( NOT &B(&BP)).FIRST\n.HEAD    AIF   (&B(&BP+1) AND &B(&BP+2)).SHIFTY\n         @DOUB &OUT,&DC\n         &AR   &OUT,&IN\n&DC      SETA  1\n&BP      SETA  &BP+1\n         AGO   .FOOT\n.SHIFTY  ANOP\n&WORK    SETA  &DC-1\n         @DOUB &OUT,&WORK\n&DC      SETA  1\n         &AR   &OUT,&IN\n&SL      SETA  0\n.SCAN    ANOP\n&SL      SETA  &SL+1\n&BP      SETA  &BP+1\n         AIF   (&B(&BP)).SCAN\n         SLL   &OUT,&SL\n         &SR   &OUT,&IN\n.FOOT    AIF   (&B(&BP)).HEAD\n&BP      SETA  &BP+1\n&DC      SETA  &DC+1\n         AIF   (&BP LT 32).FOOT\n&WORK    SETA  &DC-2\n         @DOUB &OUT,&WORK\n         SPACE 2\n         MEXIT\n.BLEWIT  MNOTE 16,'*** MULT ***  INTERNAL MACRO ERROR, SOMEBODY GOOFED'\n         MEND\n         SPACE 3\n* THE CORRECT CODE FOR THE FOLLOWING MACRO IS AS FOLLOWS\n*        LR    1,2           1*\n*        SLL   1,5           (2**5)=32*\n         MULT  1,2,32\n* THE CORRECT CODE FOR THE FOLLOWING MACRO IS AS FOLLOWS\n*        LR    2,3           1*\n*        SLL   2,2           (2**2)=4*\nLABEL1   MULT  2,3,4\n* THE CORRECT CODE FOR THE FOLLOWING MACRO IS AS FOLLOWS\n*        LR    5,4           1*\n*        AR    5,5           2*\n*        AR    5,4           +1=3*\nTHREE    MULT  5,4,3\n* THE CORRECT CODE FOR THE FOLLOWING MACRO IS AS FOLLOWS\n*        LR    6,8           1*\n*        SLL   6,6           (2**6)=64*\n*        SR    6,8           -1=63*\n         MULT  6,8,63\n* THE FOLLOWING NUMBERS WERE PICKED OUT OF THE AIR SO WHO KNOWS\n* WHAT THEY WILL PRODUCE, BUT IT CAN BE CHECKED\n         MULT  3,5,7238\n         MULT  5,6,5570\n         END\n$JOB   ASSIST       MACRO=F\n         TITLE 'MACRO - PA DEMAINE - SOLID SYSTEM'\n******************************** REIDC *********************AUGUST/1970\n           MACRO\n&J         REIDC &FMT,&VAR,&LEN=$,&SAV=$,&MSG=$,&CC=0\n*XXXXXXXXXXXXXXXXXXXXXXXXXXXX    REIDC     XXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*---REIDC IS THE CALLING ROUTINE FOR FORMATTED INPUT FROM CARDS.\n*---&FMT IS THE LIST OF FORMATS TO BE USED DURING THE READ.\n*---&VAR IS THE LIST OF VARIABLES TO BE READ (USE LIST FORM ).\n*---&LEN IS A FULL WORD TO STORE THE NUMBER OF BYTES READ.\n*---&SAV IS A SAVEAREA FROM USER OR DEFINED IN ROUTINE.\n*---&MSG IS A 132 BYTE WORKAREA FOR PRINTING MESSAGES FROM READ.\n*---&CC IS A CARRIAGE CONTROL CHARACTER TO BE USED WHEN PRINT. MESS.\n*----------------------------------------------------------------------\n           LCLA  &FLG,&NV,&CFMT,&CVAR,&C1,&C2,&C3,&C4,&C5\n           LCLC  &NAM1,&NAM2\n           SPACE 2\n.* SET FLAG AND COUNT FOR SET SYMBOLS &FLG AND &NV.\n&FLG       SETA  N'&SYSLIST\n&NV        SETA  N'&VAR\n.* CHECK IF THE COUNTS ARE IN THE PROPER RANGE.\n           AIF   (K'&FMT EQ 0 OR K'&VAR EQ 0).ARGERR\n           AIF   (&FLG LT 2 OR &FLG GT 6).ARGERR\n           AIF   (&NV LT 1 OR &NV GT 8).VARERR\n*** ALIGN THE CODE ON A WORD BOUNDARY.\n           CNOP  0,4\n.* DETERMINE HOW THE SAVEAREA FOR REGISTERS IS TO BE SET UP.\n           AIF   ('&SAV'(1,1) EQ '$').MAC1\n.* USE SAVEAREA PROVIDED BY THE USER (&SAV).\n&J         STM   14,1,&SAV      .              *SAVE REGISTERS FOR I/O.\n&FLG       SETA  1\n           AGO   .MAC2\n.* DEFINE SAVEAREA WITHIN THIS MACRO.\n.MAC1      ANOP\n&J         STM   14,1,DA&SYSNDX. .             *SAVE REGISTERS FOR I/O.\n&FLG       SETA  2\n.* CREATE ARGUMENT LIST FOR I/O ROUTINE.\n.MAC2      ANOP\n&C1        SETA  1\n&C2        SETA  0\n&C3        SETA  4\n           B     EA&SYSNDX. .             *BRANCH AROUND ARGUMENT LIST.\nAA&SYSNDX  DC    F'&NV.' .             *NUMBER OF VARIABLES TO BE READ.\n           DC    A(CA&SYSNDX.) .          *ADDRESS OF THE READ FORMATS.\n.* CREATE ADDRESSES FOR EACH OF THE VARIABLES.\n.MAC3      AIF   ('&VAR(&C1)'(1,1) EQ '*').MAC4\n           AIF   ('&VAR(&C1)'(1,8) EQ 'GENERATE').MAC3A\n           AIF   ('&VAR(&C1)'(1,8) EQ 'NOSCREEN').MAC3A\n           AIF   ('&VAR(&C1)'(1,7) EQ 'JLRSKIP').MAC3A\n           AIF   ('&VAR(&C1)'(1,7) EQ 'NUMDIAG').MAC3A\n           AIF   ('&VAR(&C1)'(1,7) EQ 'KLENGTH').MAC3A\n           AIF   ('&VAR(&C1)'(1,7) EQ 'LLENGTH').MAC3A\n           AIF   ('&VAR(&C1)'(1,7) EQ 'NEWFILE').MAC3A\n           AIF   ('&VAR(&C1)'(1,6) EQ 'JLGATE').MAC3A\n           AIF   ('&VAR(&C1)'(1,6) EQ 'JVALUE').MAC3A\n           AIF   ('&VAR(&C1)'(1,6) EQ 'MVALUE').MAC3A\n           AIF   ('&VAR(&C1)'(1,6) EQ 'RSKIPS').MAC3A\n           AIF   ('&VAR(&C1)'(1,6) EQ 'NTASKS').MAC3A\n           AIF   ('&VAR(&C1)'(1,6) EQ 'SECURE').MAC3A\n           AIF   ('&VAR(&C1)'(1,6) EQ 'LEXCON').MAC3A\n           AIF   ('&VAR(&C1)'(1,6) EQ 'OUTPXT').MAC3A\n           AIF   ('&VAR(&C1)'(1,6) EQ 'RNOSEG').MAC3A\n           AIF   ('&VAR(&C1)'(1,5) EQ 'TGATE').MAC3A\n           AIF   ('&VAR(&C1)'(1,5) EQ 'NJOBS').MAC3A\n           AIF   ('&VAR(&C1)'(1,5) EQ 'NFORM').MAC3A\n           AIF   ('&VAR(&C1)'(1,5) EQ 'INPXT').MAC3A\n           AIF   ('&VAR(&C1)'(1,5) EQ 'LEXNO').MAC3A\n           AIF   ('&VAR(&C1)'(1,4) EQ 'RNOS').MAC3A\n           AIF   ('&VAR(&C1)'(1,4) EQ 'MODE').MAC3A\n           AIF   ('&VAR(&C1)'(1,2) EQ 'LJ').MAC3A\n           AIF   ('&VAR(&C1)'(1,2) NE 'NV').MAC3B\n.* ARGUMENT IS SYMBOLIC ADDRESS (USE VDCON FOR ADDRESS).\n.MAC3A     DC    V(&VAR(&C1).) .         *ADDRESS OF SYMBOLIC ARGUMENT.\n           AGO   .MAC5\n.* ARGUMENT IS SYMBOLIC ADDRESS (USE ADCON FOR ADDRESS).\n.MAC3B     DC    A(&VAR(&C1).) .         *ADDRESS OF SYMBOLIC ARGUMENT.\n           AGO   .MAC5\n.* ARGUMENT IS IN REGISTER NOTATION (DEFINE STORAGE FOR LATER USE).\n.MAC4      DC    F'0' .             *ADDRESS FOR REGISTER NOTATION ARG.\n&C2        SETA  &C2+1\n.* SEE IF ALL ARGUMENTS HAVE BEEN PROCESSED.\n.MAC5      ANOP\n&C3        SETA  &C3+4\n&C1        SETA  &C1+1\n           AIF   (&C1 LE &NV).MAC3\n.* ARGUMENT LIST SET UP FOR VARIABLES - SEE IF PRINT MESSAGE IS WANTED.\n           AIF   ('&MSG'(1,1) EQ '$').MAC6\n.* PRINT OUT READ MESSAGE DURING EXECUTION.\n.*   DEFINE THE CARRIAGE CONTROL CHAR. AND ADDRESS OF MACRO BEGIN.\n           AIF   ('&MSG'(1,1) EQ '*').MAC5A\n&NAM1      SETC  '&MSG'\n           DC    CL1'&CC.',AL3(AA&SYSNDX.-8)\n&C4        SETA  1\n           AGO   .MAC5B\n.MAC5A     ANOP\n&NAM1      SETC  '&MSG'(2,8)\n           DC    CL1'&CC.',AL3(0)\n&C4        SETA  2\n.MAC5B     AIF   ('&NAM1'(1,4) EQ 'DASH').MAC5C\n           AIF   ('&NAM1'(1,5) EQ 'BLANK').MAC5C\n           AIF   ('&NAM1'(1,5) EQ 'WORKA').MAC5C\n           DC    A(&NAM1.)\n           AGO   .MAC5D\n.MAC5C     DC    V(&NAM1.)\n.MAC5D     ANOP\n&C3        SETA  &C3+8\n           AIF   (&C4 EQ 2).MAC6\n.*         DEFINE STORAGE FOR THE VARIABLE LIST SYMBOLS.\n&CVAR      SETA  (K'&VAR+1)/2*2\n           AIF   (&CVAR LE 50).LESS\n&CVAR      SETA  50\n.LESS      ANOP\nBA&SYSNDX  DC    CL&CVAR.'&VAR.'\n.* DEFINE STORAGE FOR THE FORMAT LIST SYMBOLS.\n.MAC6      ANOP\n&CFMT      SETA  (K'&FMT+1)/2*2\nCA&SYSNDX  DC    CL10'&FMT.'\n.* DEFINE SAVEAREA FOR REGISTERS IF REQUESTED.\n           AIF   (&FLG NE 2).MAC7\n           DS    0F\nDA&SYSNDX  DS    4F .                          *SAVEAREA FOR REGISTERS.\n.* END OF STORAGE DEFINITION - CONTINUE EXECUTION.\n.MAC7      ANOP\nEA&SYSNDX  EQU   * .                *CONTINUE EXECUTION AFTER ARG LIST.\n           AIF   (&C2 EQ 0).MAC11\n.* MUST LOAD ADDRESS OF REGISTER NOTATION ARGUMENTS.\n&C1        SETA  1\n&C5        SETA  8\n.MAC8      AIF   ('&VAR(&C1)'(1,1) NE '*').MAC10\n&NAM1      SETC  '&VAR(&C1)'(2,8)\n&NAM2      SETC  '        '\n           AIF   (K'&VAR(&C1)-9 LE 0).MAC9\n&NAM2      SETC  '&VAR(&C1)'(10,8)\n.MAC9      LA    0,&NAM1&NAM2 .              *LOAD ADDRESS OF VARIABLE.\n           ST    0,AA&SYSNDX.+&C5 .    *STORE ADDRESS IN ARGUMENT LIST.\n&C2        SETA  &C2-1\n.MAC10     ANOP\n&C5        SETA  &C5+4\n&C1        SETA  &C1+1\n           AIF   (&C2 GT 0).MAC8\n.* FINISHED LOADING ARGUMENT LIST - SET END OF LIST FLAG.\n.*  SEE IF AN ORG INSTRUCTION CAN MARK END OF ARGLIST.\n.*  IF PRINTING MESSAGES DURING EXECUTION, CAN USE ORG TO MARK LIST.\n.MAC11     AIF   ('&MSG'(1,1) EQ '$').MAC13\n.* SET LOC COUNTER BACK TO MARK LIST END.\n.MAC12     ORG   AA&SYSNDX.+&C3.\n           DC    X'80' .                 *TAG END END OF ARGUMENT LIST.\n           ORG\n           AGO   .MAC14\n.*  IF LAST ARG IS NON-REGISTER NOTATION - CAN USE ORG TO TAG LIST.\n.MAC13     AIF   ('&VAR(&NV)'(1,1) NE '*').MAC12\n.*  LAST ARG USING REG NOTATION - GENERATE EXEC INSTR TO TAG LIST.\n           MVI   AA&SYSNDX.+&C3.,X'80' .  *TAG END OF LIST DURING EXEC.\n.* PRINT READ MESSAGE DURING EXECUTION.\n.MAC14     AIF   (&C4 NE 1).MAC15\n*** SET UP MESSAGE TO BE OUTPUT DURING THE READ OPERATION.\n           MVI   &MSG.+52,C' ' .               *BLANK OUT THE WORKAREA.\n           MVC   &MSG.+53(79),&MSG.+52\n           MVC   &MSG.(52),=CL52' **READ IN AFTER STATEMENT        . INX\n               FORMATION FOR'\n           MVC   &MSG.+52(&CVAR.),BA&SYSNDX. .    *MOVE IN VAR SYMBOLS.\n           MVC   &MSG.+105(7),=CL7'FORMAT=' .        *MOVE FORMAT INFO.\n           MVC   &MSG.+113(&CFMT.),CA&SYSNDX. .   *MOVE FORMAT SYMBOLS.\n.MAC15     ANOP\n*** BRANCH TO THE READ ROUTINE TO PERFORM THE READ OPERATION.\n           LA    1,AA&SYSNDX. .         *LOAD ADDRESS OF ARGUMENT LIST.\n           L     15,=V(REID) .                  *LOAD ADDRESS OF SREID.\n           BALR  14,15 .                     *EXECUTE THE READ ROUTINE.\n           AIF   ('&LEN'(1,1) EQ '$').MAC16\n           ST    0,&LEN .               *RETURN LENGTH OF DATA TO USER.\n.MAC16     AIF   (&FLG EQ 2).MAC17\n.* RELOAD REGISTERS FROM &SAV (USER SAVEAREA).\n           LM    14,1,&SAV      .                *RELOAD I/O REGISTERS.\n           AGO   .MAC18\n.* RELOAD REGISTERS FROM SAVEAREA DEFINED IN THIS ROUTINE.\n.MAC17     LM    14,1,DA&SYSNDX. .               *RELOAD I/O REGISTERS.\n           AGO   .MAC18\n.* ERROR IN ARGUMENT LIST - DO NOT GENERATE READ ROUTINE CODE.\n.ARGERR    MNOTE 2,'ARGUMENT LIST IMPROPERLY FORMED.'\n           AGO   .ERR1\n.* ERROR IN LIST OF VARIABLES - DO NOT GENERATE READ CODE.\n.VARERR    MNOTE 2,'NUMBER OF VARIABLES TO READ EXCEEDS LIMITS.'\n.ERR1      ANOP\n*** READ STATEMENT WILL BE REPLACED BY A 'NOPR 1' INSTRUCTION\n*** DUE TO THE ERROR IN DEFINING MACRO PROTOTYPE.\n&J         NOPR  1 .                      *REPLACES THE READ STATEMENT.\n.MAC18     ANOP\n*XXXXXXXXXXXXXXXXXXXXXXXXXXXX  END REIDC   XXXXXXXXXXXXXXXXXXXXXXXXXXXX\n           SPACE 2\n           MEND\n******************************** REIDC ********************************\n         USING *,15\n         REIDC *I,(X,Y,Z),LEN=JI,SAV=SAVEAREA,MSG=MESSAGE\nJI       DS    F\nX        DS    F\nY        DS    F\nZ        DS    F\nSAVEAREA DC    18F'0'\nMESSAGE  DS    33F\n         ENTRY REID\nREID     DS    F\n         END\n$JOB   ASSIST       MACRO=F\n*        ***NOTE*** ILLUSTRATES ERROR IN HANDKING OF KEYWORD DEFAULTS\n*        WHICH ARE ALSO SUBLISTS.\n*              EARLY ASSIGNMENT - CMPSC 411 - STUDENT-WRITTEN PROGRAM\n*                                  - DAVID COLEMAN - SUMMER 1972.\n         TITLE 'MACRO QSAVE'\n         MACRO\n&NAME    QSAVE &REGS=(14,12),&BASE=12,&SA=*\n.*\n.**********************************************************************\n.*\n.*       MACRO QSAVE - CS411 - SUMMER 72.\n.*       QSAVE IS A LINKAGE MACRO WRITTEN ACCORDING TO SPECS\n.*                                 IN CS411MC1.\n.*       &SA IS SPECIFIED AS IN PSU MACRO 'XSAVE'.\n.*\n.**********************************************************************\n.*\n         GBLC  &SAVE               &SAVE USED BY QRETURN.\n         LCLA  &LENGTH,&DISP,&LENGTH1\n         LCLC  &NAME1,&BASER,&A\n         SPACE\n         USING *,15 .              TEMPORARY BASE REGISTER.\n.**********************************************************************\n.*\n.*       GENERATE IDENTIFICATION FIELD.\n.*\n.**********************************************************************\n&LENGTH  SETA  K'&NAME             OBTAIN COUNT OF NAME FIELD.\n&NAME1   SETC  '&NAME'             STORE NAME FIELD.\n         AIF   (&LENGTH NE 0).ID   BRANCH IF &NAME EXISTED.\n&NAME1   SETC  '&SYSECT'           USE CSECT NAME INSTEAD.\n.*       COUNT CHARACTERS IN CSECT NAME.\n.TOP     ANOP\n&LENGTH  SETA  (&LENGTH+1)         ADD 1 TO COUNT.\n         AIF   ('&SYSECT'(1,&LENGTH) EQ '&SYSECT'(1,&LENGTH+1)).ID\n         AGO   .TOP                LOOK FOR NEW CHARACTER.\n.ID      ANOP\n&LENGTH1 SETA  (&LENGTH/2*2+1)     MAKE LENGTH ODD.\n&NAME    B     5+&LENGTH1.(,15) .  BRANCH AROUND ID.\n         DC    X'&LENGTH1' .       ID CONVENTION.\n         DC    CL&LENGTH1'&NAME1'\n.**********************************************************************\n.*\n.*       SAVE PASSED REGISTERS - ONLY ONE PAIR IS ALLOWED.\n.*\n.**********************************************************************\n&DISP    SETA  (&REGS(1)-14)       EXTABLISH DISPLACEMENT OF 1ST REG.\n         AIF   (&DISP GE 0).POSITIV\n&DISP    SETA  (&DISP+16)          MAKE # POSITIVE.\n.POSITIV ANOP\n&DISP    SETA  (&DISP*4+12)        THIS IS DISPLACEMENT.\n         STM   &REGS(1),&REGS(2),&DISP.(13) . SAVE PASSED REGISTERS.\n.**********************************************************************\n.*\n.*       LINK SAVE AREAS\n.*\n.**********************************************************************\n&SAVE    SETC  '&SA'               TO BE USED BY QRETURN.\n         AIF   ('&SAVE' EQ 'NO').BASE   'NO'=NO SA LINKAGE.\n         AIF   ('&SAVE' NE '*').LINK    BRANCH IF NAME GIVEN.\n&SAVE    SETC  '&SYSECT'(1,3).'&SYSNDX'.'S'    GENERATE SAVE AREA NAME.\n.LINK    LA    15,&SAVE     .      GET SAVE AREA ADDRESS.\n         ST    15,8(13) .          POINTER TO LOW SAVE AREA.\n         ST    13,4(15) .          POINTER TO HIGH SAVE AREA.\n         LR    13,15 .             ADDRESS OF LOW SAVE AREA.\n.BASE    ANOP\n&BASER   SETC  '&BASE'\n         AIF   (&BASE LE 12).USING     BRANCH IF B.R. IS LEGAL.\n         MNOTE 4,'***WARNING*** REGISTER &BASE CANNOT BE USED AS A BASEX\n               REGISTER: REGISTER 12 USED INSTEAD'\n&BASER   SETC  '12'\n.USING   BALR  &BASER,0 .          SET UP NEW BASE.\n         DROP  15                  DELETE TEMPORARY.\n         USING *,&BASER .          NEW USING.\n         SPACE\n         MEND\n         TITLE 'MACRO QCALL'\n         MACRO\n&NAME    QCALL &ENTRY,&ARGS\n.*\n.**********************************************************************\n.*\n.*       MACRO QCALL - CS411 - SUMMER 72.\n.*       QCALL IS A LINKAGE MACRO WRITTEN ACCORDING TO SPECS IN CS411MA\n.*       QCALL IS A LINKAGE MACRO WRITTEN ACCORDING TO SPECS\n.*             GIVEN IN CS411MC19\n.*             GIVEN IN CS411MC1.\n.*\n.**********************************************************************\n.*\n         LCLA  &KOUNT,&TEMPA\n         LCLC  &LSTNAME\n         SPACE\n&NAME    DS    0H .                PROVIDE LABEL IN GENERATED CODE.\n.**********************************************************************\n.*\n.*       DECIPHER ARGUMENT (2ND) OPERAND.\n.*\n.**********************************************************************\n         AIF   (N'&ARGS EQ 0).BRANCH   BRANCH IF 2ND OPERAND MISSINGC\n         AIF   ('&ARGS'(1,1) NE '(').ADDNAME   BRANCH IF NOT A SUBLIST.\n&LSTNAME SETC  'LIST'.'&SYSNDX'    CREATE UNIQUE ADDRESS LIST NAME.\n         AGO   .LR1\n.ADDNAME ANOP\n&LSTNAME SETC  '&ARGS'             USE ADDRESS LIST NAME FROM MACRO.\n.LR1     LA    1,&LSTNAME .        R1==>ADDRESS OF ADDRESS LIST.\n.**********************************************************************\n.*\n.* IS TRANSFER OF CONTROL WANTED.\n.*\n.**********************************************************************\n.BRANCH  AIF   (N'&ENTRY EQ 0).STORE BRANCH IF NO TRANSFER WANTED.\n         L     15,=V(&ENTRY) .     SUBROUTINE ADDRESS.\n         BALR  14,15 .             CALL ROUTINE.\n.**********************************************************************\n.*\n.*       DECIDE IF ADDRESS MUST BE CREATED.\n.*\n.**********************************************************************\n         AIF   (N'&ARGS EQ 0).END  BRANCH IF NO ARGUMENTS PASSED.\n.STORE   AIF   ('&ARGS'(1,1) NE '(').END   BRANCH IF ARGS NOT LISTED.\n&TEMPA   SETA  (4*N'&ARGS)         SIZE OF ADDRESS LIST.\n         B     &LSTNAME+&TEMPA .   BRANCH AROUND ADDRESS LIST.\n&KOUNT   SETA  1                   COUNTER FOR LOOP.\n&LSTNAME DS    0F .                TOP OF ADDRESS LIST.\n.TOP     AIF   (&KOUNT EQ N'&ARGS).LAST   BRANCH FOR NO MORE ARGS.\n         DC    A(&ARGS(&KOUNT)) .  PUT ADDRESS OF ARGUMENT INTO LIST.\n&KOUNT   SETA  &KOUNT+1\n         AGO   .TOP\n.LAST    DC    X'80',AL3(&ARGS(&KOUNT)) .     FLAG LAST ADDRESS.\n.END     ANOP\n         SPACE\n         MEND\n         TITLE 'MACRO QRETURN.'\n         MACRO\n&NAME    QRETURN &REGS=(14,12),&SA=\n.*\n.**********************************************************************\n.*       MACRO QRETURN - CS411 - SUMMER 72.\n.*       QRETURN IS A LINKAGE MACRO WRITTEN ACCORDING TO SPECS\n.*             GIVEN IN CS411MC1.\n.*       SA IS APECIFIED SAME AS IN PSU MACRO 'XRETURN'.\n.*\n.**********************************************************************\n.*\n         GBLC  &SAVE               CONTAINS INFO FROM MACRO QSAVE.\n         LCLA  &DISP\n         SPACE\n&NAME    DS    0H .                DEFINE LABEL.\n         AIF   ('&SA' EQ 'NO').RGS  BRANCH IF NO SAVE AREA PRESENT.\n         L     13,4(13) .          RESTORE PREVIOUS SA POINTER.\n.**********************************************************************\n.*\n.*       RESTORE CALLING PROGRAM'S REGISTERS.\n.*\n.**********************************************************************\n.RGS     ANOP\n&DISP    SETA  (&REGS(1)-14)       ESTABLISH DISPLACEMENT IN SAVE AREA.\n         AIF   (&DISP GE 0).POSITIV\n&DISP    SETA  (&DISP+16)          MAKE # POSITIVE.\n.POSITIV ANOP\n&DISP    SETA  (&DISP*4+12)        THIS IS DISPLACEMENT.\n         LM    &REGS(1),&REGS(2),&DISP.(13) . RESTORE PASSED REGISTER.\n         MVI   12(13),X'FF' .      FLAG RET IN HSA.\n         BR    14 .                RETURN CONTROL TO CALLING PROGRAM.\n.**********************************************************************\n.*\n.*       DECIDE IF A SAVE AREA IS TO BE GENERATED.\n.*\n.**********************************************************************\n         AIF   ('&SA' EQ 'NO').END     BRANCH FOR NO.\n         AIF   (K'&SA EQ 0).END    DEFAULT\n         AIF   ('&SA' EQ '*' OR '&SA' EQ '&SAVE').SKIP      NEW LABEL?\n&SA      DS    0F .                LABEL FROM QRETURN.\n.SKIP    ANOP\n&SAVE    DC    18F'0'              DEFINE SAVE AREA.\n.END     ANOP\n         SPACE\n         MEND\n         TITLE 'TEST OF LINKAGE MACROS.'\nMAINPRG  CSECT\n         QSAVE REGS=(14,12)     USE VALUES\n         QCALL SUBX,ADDRX\n         QCALL SUBY\nGOBACK   QRETURN SA=*\nADDRX    QCALL ,(MAINPRG,GOBACK)\n         LTORG\nSUBXCS   CSECT\n         ENTRY SUBX,SUBY\nSUBX     QSAVE SA=SUBXSA\n         CNOP  2,4                 CNOP FOR NASTINESS\n         QCALL SUB1,(SUBX)\n         QCALL SUB2\nSUBRET   QRETURN SA=SUBXSA\nSUBY     QSAVE SA=NO\n         XPRNT =CL50'0*** AT SUBY *****',50\n         QRETURN  SA=NO\n         LTORG\nSUB1     CSECT\n         QSAVE BASE=13\n         QRETURN  SA=*\nSUB2     CSECT\n         QSAVE BASE=15,REGS=(2,12)\n         QRETURN SA=*,REGS=(2,12)\n$ENTRY\n$JOB   ASSIST       MACRO=F\n***********************************************************************\n***********************************************************************\n**********************************************************************\n*                                                                     *\n*              FOLLOWING DECKS ILLUSTRATE MACROS FROM ASSEMBLER       *\n*        MANUAL OR ELSE VARIOUS CONDTIONAL ASSEMBLY OPERATION.        *\n*                                                                     *\n**********************************************************************\n**********************************************************************\n**********************************************************************\n         TITLE 'ILLUSTRATE MACROS:  ASSEMBLER MANUAL SECTION 6'\n         MACRO\n&NAME    MOVE  &TO,&FROM\n&NAME    ST    2,SAVE\n         L     2,&FROM\n         ST    2,&TO\n         L     2,SAVE\n         MEND\n         SPACE 1\n         MACRO\n&NAME    MOVE1 &TY,&P,&TO,&FROM\n&NAME    ST&TY 2,SAVEAREA\n         L&TY  2,&P&FROM\n         ST&TY 2,&P&TO\n         L&TY  2,SAVEAREA\n         MEND\n         SPACE 1\n         MACRO\n&NAME    MOVE2 &P,&S,&R1,&R2\n&NAME    ST    &R1,&S.(&R2)\n         L     &R1,&P.B\n         ST    &R1,&P.A\n         L     &R1,&S.(&R2)\n         MEND\n         SPACE 1\n         USING *,15\nHERE     MOVE  FIELDA,FIELDB\nLABEL    MOVE  IN,OUT\nSAVE     DS    F\nFIELDA   DS    D\nFIELDB   DS    D\nIN       DS    F\nOUT      DS    F\n         SPACE 1\n         MOVE1 D,FIELD,A,B\nSAVEAREA DS    D\n         SPACE 2\nHERE2    MOVE2 FIELD,SAVE,2,4\n         END\n$JOB   ASSIST       MACRO=F\n         MACRO\n         ADDX  &NUMBER,&REG\n.*             ILLUSTRATES SETA, SUBLISTS.\n         LCLA  &LAST\n&LAST    SETA  N'&NUMBER\n         L     &REG,&NUMBER(1)\n         A     &REG,&NUMBER(&LAST)\n         ST    &REG,&NUMBER(1)\n         MEND\n         SPACE 1\n         USING *,15\n         ADDX  (A,B,C,D,E),3\nA        DS    F\nE        DS    F\n         END\n$JOB   ASSIST       MACRO=F\n         MACRO\n         ATTRIB    &ARG\n.*   THIS MACRO ILLUSTRATES ATTRIBUTES ALLOWED:\n.*   T'  (N,O, OR U ONLY);  K'; AND N'\n         LCLA  &K,&N\n         LCLC      &T\n&T       SETC  T'&ARG\n&K       SETA  K'&ARG\n&N       SETA  N'&ARG\n         MNOTE '&&ARG = &ARG: T'' = &T; K'' = &K; N'' = &N.'\n         MEND\n         SPACE 1\n         ATTRIB ,             OMITTED ARGUMENT\n         ATTRIB 20            SELF-DEFINING TERM\n         ATTRIB X'20'         ANOTHER SELF-DEFINING TERM\n         ATTRIB FULLWORD      TYPE IS U, UNLIKE STNDRD ASMS\nFULLWORD DS    F\n         ATTRIB ()             NULL SUBLIST\n         ATTRIB (1,2,3,4,5)\n         ATTRIB (FULLWORD,1)   NOTE TYPE ATTRIBUTE\n         ATTRIB 2(10,12)\n         ATTRIB A(2)\n         ATTRIB 'A''B'\n         ATTRIB ' '\n         ATTRIB ''\n         SPACE  1\n         ATTRIB (A,B,C,D,E)\n         ATTRIB (A,,C,D,E)\n         ATTRIB (A,B,C,D)      4 OPERANDS\n         ATTRIB (A,B,C,D,,)    6 OPERANDS\n         END\n$JOB   ASSIST       MACRO=F\n         TITLE 'ILLUSTRATE SETX STATEMENTS'\n         MACRO\n&LABEL   SET   &ARG1,&ARG2,&ARG3\n.*             ILLUSTRATE SETX STATEMENTS.\n         LCLA  &A1,&A2\n         LCLB  &B1,&B2\n         LCLC  &C1,&C2\n         MNOTE *,'INITIAL VALUES: &A1,&A2; &B1,&B2; &C1,&C2'\n         AIF   (T'&ARG1 NE 'N').X1\n&A1      SETA  &ARG1(1)            NOTE T' TAKEN FROM 1ST OF SUBLIST\n.X1      AIF   (T'&ARG2 NE 'N').X2\n&A1      SETA  &A1+&ARG2(1)\n.X2      AIF   (T'&ARG3 NE 'N').X3\n&A1      SETA  &A1+&ARG3(1)\n.X3      MNOTE *,'&&A1 = &&ARG1+&&ARG2+&&ARG3 = &A1.'\n.*\n&A2      SETA  (K'&ARG1+K'&ARG2+K'&ARG3)*N'&ARG1\n         MNOTE *,'&&A2 = &A2'\n&C1      SETC  'ABC'.'DEF'\n&C2      SETC  '&ARG1&ARG2&ARG3'\n         MNOTE *,'&&C1 = &C1;  &&C2 = &C2.'\n&C1      SETC  '&C1'(2,4)\n&C2      SETC  'ABCDEFGHIJKLMNOPQRSTUVWXYZ'(26,1)\n         MNOTE *,'&&C1 = &C1; &&C2 = &C2'\n&C1      SETC  'ABCDE'.'&C1'(2,2)\n&C2      SETC  'ABCDE&C1'(2,2)\n         MNOTE *,'&&C1 = &C1; &&C2 = &C2'\n&B1      SETB  ('&ARG1' EQ '&ARG2' AND '&ARG3' EQ '0')\n&B2      SETB  (&B1 OR 0)\n         MNOTE *,'&&B1 = &B1; &&B2 = &B2'\n&B1      SETB  (&A1 EQ &A1)\n&B2      SETB  (&A1 GT &A1)\n         MNOTE *,'&&B1 = &B1; &&B2 = &B2  (0,1)'\n         MEND\n         SPACE 2\n         SET   1,3,5\n         SET   (20,10),(20,10),X\n         SET   =F'20',ABCDEFGHIJKLMNOPQRSTUVWXYZ,0\n        SET   X'20',C'0',B'00000001'\n         END\n$JOB   ASSIST       MACRO=F\n         TITLE 'ILLUSTRATE ARITHMETIC OPERATIONS IN SETA OPERATIONS'\n         MACRO\n&LABEL   SETAX &A\n.*             ILLUSTRATES ARITHMETIC OPERATIONS\n.*             IN SETA OPERATIONS.\n         GBLA  &W,&X,&Y,&Z\n         LCLA  &I,&J,&K,&L\n         MNOTE *,'INITIAL VALUES: W=&W; X=&X; Y=&Y; Z=&Z'\n&W       SETA  &A+&W\n&I       SETA  &I+1\n         MNOTE *,'W=A+W = &W;  I = I+1 = &I'\n.*             SUBTRACTION\n&X       SETA  &X-&A\n&J       SETA  &J-1\n         MNOTE *,'X=X-A = &X;  J=J-1 = &J'\n.*             MULTIPLICATION\n&Y       SETA  (&Y+1)*&A\n&K       SETA  2*(&K+1)\n         MNOTE *,'Y=(Y+1)*A = &Y;  K=2*(K+1) = &K'\n.*             DIVISION\n&Z       SETA  (&Z+20)/&A\n&L       SETA  10/(&L+2)          SHOULD = 5\n         MNOTE *,'Z=(Z+20)/A = &Z;  L = 10/(L+2) = &L'\n.*             PARENTHESES.\n&I       SETA  (((((0)))))\n&J       SETA  1+2*3                  =7\n&K       SETA  (1+2)*3            =9\n&L       SETA  (((&J+&K)/4+1)+0*&L)+10    = 5+10 = 15\n         MNOTE *,'I,J,K,L = &I,&J,&K,&L'\n         MNOTE *,'END VALUES: W,X,Y,Z: &W,&X,&Y,&Z'\n         MEND\n         SPACE 2\n         SETAX 10\n         SETAX X'A'\n         SETAX B'00001010'\n         END\n$JOB   ASSIST       MACRO=F\n         TITLE 'TEST SETB INSTRUCTION'\n         MACRO\n         SETBX &A,&B,&C\n         GBLB  &W,&X,&Y,&Z\n         LCLB  &D,&E,&F,&TRUE,&FALSE\n         LCLA  &I,&J\n         LCLC  &Q,&R\n.*\n         MNOTE *,'INITIAL VALUES: W,X,Y,Z = &W,&X,&Y,&Z'\n&FALSE   SETB  0                   FALSE VALUE\n&TRUE    SETB  1                   TRUE VALUE\n&W       SETB  (NOT &W)           INVERSION\n&X       SETB  (&W AND &TRUE)\n&Y       SETB  (&W OR  &FALSE)\n&Z       SETB  (\n1M 7150\n&Z       SETB  (&TRUE  OR &TRUE AND NOT &TRUE)   SHOULD BE 0\n         MNOTE *,'W,X,Y,Z = &W,&X,&Y,&Z'\n.*             COMPARISONS, CHARACTER OPERATIONS\n&D       SETB  ('&Q' EQ '&R')      COMPARE NULL STRINGS\n&Q       SETC  'ABCDEFGH'\n&E       SETB  ('&Q' EQ 'ABCDEFGH')    TRUE\n&R       SETC  '&Q'\n&F       SETB  ('&Q'(1,3) EQ '&R'(1,3))\n         MNOTE *,'D,E,F = &D,&E,&F  (1,1,1)'\n&D       SETB  ('&Q'(2,5) GT '&Q'(1,4))    FALSE\n&E SETB (&I+1 EQ &J+1)              TRUE\n&F SETB (&I+1 GT &J)                TRUE\n MNOTE *,'D,E,D = &D,&E,&F (0,1,1)\n MEND\n SPACE 1\n SETBX 1\n END\n$JOB   ASSIST       MACRO=F\n         TITLE 'DEMONSTRATE SETC'\n         MACRO\n&LABEL   SETCX &A,&B,&C\n         GBLC  &W,&X,&Y\n         LCLC  &D,&E,&F\n         LCLA  &I,&J\n         MNOTE *,'INITIAL VALUES: W/X/Y: &W/&X/&Y'\n.*             TRANSFER, CONCATENATION.\n&D       SETC  '&A'               TRANSFER\n&E       SETC  '&A&B'             CONCAT, NO PERIODS\n&F       SETC  '&A.&B'            CONCAT, WITH PERIOD'\n         MNOTE *,'D/E/F = &D/&E/&F'\n&W       SETC  '&A'.'&W'          CONCAT, QUOTES EACH\n&X       SETC  '&A&X'\n&Y       SETC  '&A&A&A&A&A&A&A&A&A&A'  LONGGER THAN 8 BYTES\n         MNOTE *,'W/X/Y = &W/&X/&Y'\n.*             SUBSTRING OPERATIONS\n&D       SETC  '123456789'(8,2)         89\n&I       SETA  &C                       89 ALSO\n&D       SETC  '123456789'(97-&I,2+1*&I-&I)  89 ALSO\n&E       SETC  '123456789'(9,2)         JUST 9\n         MNOTE *,'C/I/D/E = &C/&I/&D/&E  (89/89/89/9)'\n         MEND\n         SPACE 1\n         SETCX A,B,C\n         SETCX D,E,F\n         SETCX (1,2,3,4,5,6,7,8,9),,ABCDEF\n         END\n$JOB   ASSIST       MACRO=F\n         TITLE 'AIF, AGO, ACTR'\n         MACRO\n         ATRAN &I\n         LCLA  &J,&K\n         ACTR  &I                  LIMIT ON #\n         AGO   .X    DEFINITE\n         MNOTE *,'SHOULD NOT BE PRINTED'\n.X       AIF   (&I NE &I).Y            DEFINITELY NOT\n         MNOTE *,'THIS MUST BE PRINTED'\n.Y       AIF   (&I EQ &I).Z            DEFINITE GO\n         MNOTE *,'MUST NOT BE PRINTED'\n.Z       ANOP\n         MNOTE *,'AT THIS PT, THERE HAVE BEEN 2 SUCCESSFUL AGO/AIF'\n.LOOP     ANOP\n&J       SETA  &J+1\n         MNOTE *,'J = &J'\n         AGO   .LOOP               LOOP UNTIL ACTR GETS IT\n         MEND\n         ATRAN 8\n         END\n$JOB   ASSIST       MACRO=F\n***********************************************************************\n***********************************************************************\n**********************************************************************\n*                                                                     *\n*              IN NEXT GROUP OF JOBS, ERRORS, WEIRD STATEMENTS,       *\n*              ETC ARE SHOWN.                                         *\n*                                                                     *\n***********************************************************************\n**********************************************************************\n**********************************************************************\n         TITLE 'ZERO DIVIDE, OVERFLOW TEST - DURING EXPANSION'\n         MACRO\n         TESTZDIV\n.*  TESTS ZERO DIVIDE AND FIXED POINT OVERFLOW ERROR CONDITIONS\n         LCLA  &I,&J\n&I       SETA  2147483647\n         MNOTE *,' FOLLOWING MESSAGE OCCURS WHEN ZERO DIVIDE OCCURS'\n&J       SETA  &I/&J\n         MNOTE *,'FOLLOWING MESSAGE OCCURS WHEN FXD PNT OVRFLW OCCURS'\n&J       SETA  &I+1\n         MEND\n         SPACE 1\n         TESTZDIV\n         END\n$JOB   ASSIST       MACRO=F\n         TITLE 'SHOW COMBINED EDIT / EXPANSION ERRORS'\n         MACRO\n         TESTSUBS &A\n.*  TESTS VARIOUS SUBSCRIPT ERROR CONDITIONS\n         LCLA  &ARRAY(10)\n         LCLC  &C\n.*  FOLLOWING MESSAGE OCCURS WHEN DIMENSION EXCEEDS LIMIT OF 2500\n         LCLA &EXCEED(2501)\n.*  FOLLOWING MESSAGE OCCURS WHEN DUPLICATE VARIABLE SYMBOL NAME IS\n.*  USED\n         LCLB  &ARRAY\n.*  FOLLOWING MESSAGE OCCURS WHEN SUBSCRIPT OMITTED FROM DIMENSIONED\n.*  VARIABLE\n&ARRAY   SETA  13\n         MNOTE *,'FOLLOWING MESSAGE OCCURS WHEN INDEX VALUE EXCEEDS ARR#\n               AY SIZE'\n&ARRAY(20)  SETA  20\n          MNOTE *,'FOLLOWING MESSAGE OCCURS WHEN SUBSCRIPT VALUE IS NON#\n               ARITHMETIC'\n&ARRAY(&A)  SETA  100\n.*  FOLLOWING MESSAGE OCCURS WHEN ILLEGAL SUBSCRIP  IS USED IN\n.*  DIMENSIONED VARIABLE\n&ARRAY(3)   SETA  &ARRAY(/E)\n.*   FOLLOWING MESSAGES OCCUR WHEN WRONG NUMBER OF SUBSCRIPTS USED\n&C       SETC  '&A'(3)\n&C       SETC  '&A(2,2)'\n         MEND\n         SPACE 1\n         TESTSUBS  NONDECIMALSTRING\n         END\n$JOB   ASSIST       MACTR=10,MNEST=5,MACRO=F\n         TITLE 'ILLUSTRATE MACTR,MNEST OPTIONS'\n         MACRO\n         TESTXCED\n.*  THIS MACRO TESTS EXCESSIVE NESTED MACRO CALLS\n         GBLB  &FLAG\n         AIF   (&FLAG).SKIP\n&FLAG    SETB  (1)\n         MNOTE *,'FOLLOWING MESSAGE OCCURS WHEN NUMBER OF NESTED MACRO #\n               CALLS EXCEEDS MSTMG'\n.SKIP    ANOP\n         TESTXCED\n         MNOTE *,'NEVER PRINT - WHOLE NEST CANCELED'\n         MEND\n         SPACE 1\n         MACRO\n         LOOPER\n         LCLA  &I\n.LOOP    ANOP\n&I       SETA  &I+1                INCREMENT NOW\n         MNOTE *,'&&I = &I'\n         AGO   .LOOP               LOOP UNTIL ACTR GETS US\n         MEND\n         SPACE 1\n         TESTXCED\n         SPACE 1\n         LOOPER\n         END\n$JOB   ASSIST       MACRO=F,MSTMG=20\n         TITLE 'ILLUSTRATE MSTMG OPTION'\n         MACRO\n         GEN6\n         MNOTE *,'1'\n         MNOTE *,'2'\n         MNOTE *,'3'\n         MNOTE *,'4'\n         MNOTE *,'5'\n         MNOTE *,'6'\n         MEND\n         GEN6\n         GEN6\n         GEN6\n         GEN6\n         GEN6\n         END\n$JOB   ASSIST       MACRO=F\n         MACRO\n         TESTCHAR &A\n         LCLA     &I\n         LCLB     &B\n         LCLC     &C\n.*   FOLLOWING MESSAGE OCCURS WHEN CHAR EXPRESSION DOES NOT START\n.*   WITH QUOTE\n&C       SETC  ABCDE\n.*   FOLLOWING MESSAGE OCCURS WHEN CHAR EXPRESSION DOES NOT END\n.*   WITH QUOTE\n&C       SETC  'ABCDE\n.*   FOLLOWING MESSSAGE OCCURS WHEN TYPES ARE MIXED IN SET STMT\n&C       SETA   12\n.*   FOLLOWING MESSAGES OCCUR WHEN OPERAND NOT COMPATIBLE WITH\n.*   OPERATOR\n&B       SETB  (NOT &C)\n&B       SETB  (&B AND &I*&A)\n         MEND\n         END\n$JOB   ASSIST       MACRO=F\n         MACRO\n         TESTDNAM\n         MEND\n         SPACE 1\n         MACRO\n         TESTDNAM\n.*   ABOVE MESSAGE OCCURS WHEN DUPLICATE NAME IS USED IN\n.*   MACRO PROTOTYPE STMT.  DUMMY NAME SUBBED AND ASSEMBLY CONTINUES\n         MEND\n         SPACE 1\n         MACRO\n         AB*X\n.*   ABOVE MESSAGE OCCURS WHEN ILLEGAL SYMBOL IS USED FOR MACRO\n.*   NAME.  DUMMY NAME IS SUBBED AND ASSEMBLY CONTINUES.\n         MEND\n         SPACE 1\n         MACRO\n         TESTOPR1  &A=3427,&B\n.*   ABOVE MESSAGE OCCU9S WHEN POSITIONAL OPRND FOLLOWS KEYWORD\n         MEND\n         SPACE 1\n         MACRO\n         TESTOPR2   &A=Z=347\n.*   ABOVE MESSAGE OCCURS WHEN OPERAND VALUE IN PROTOTYPE STMT OR\n.*   MACRO CALL DOES NOT CONFORM TO IBM GC28-6514 SECTION 8.\n         MEND\n         SPACE 1\n         MACRO\n&LABEL   TESTLABL\n         MNOTE *,'ABOVE MESSAGE OCCURS WHEN OPERAND VALUE ASSIGNED TO  #\n               LABEL FIELD SYMBOLIC PARAMETER IS NOT ORDINARY SYMBOL'\n         MEND\n         SPACE 1\n(234)    TESTLABL\n         END\n$JOB   ASSIST       MACRO=F\n         MACRO\n         TESTSEQ\n.*   FOLLOWING MESSAGE OCCURS WHEN ILLEGAL SEQUENCE SYMBOL IS USED\n         AGO  LOOP1\n         AGO  .LOOP1\n         AGO   .LOOP1              UNDEFINED\n         AGO   .OOP2               ALSO UNDEFINED\n.*   FOLLOWING MESSAGE OCCURS WHEN SEQUENCE SYMBOL IS UNDEFINED\n         MEND\n         END\n$JOB   ASSIST       MACRO=F\n         MACRO\n         TESTXPND  &A\n         LCLA    &I\n         LCLB    &B\n         LCLC    &C\n.*   FOLLOWING MESSAGE OCCURS WHEN SET SYMBOL DEFINITIONS OCCUR\n.*   OUT OF ORDER\n         GBLA    &Z\n         MNOTE *,'FOLLOWING MESSAGE OCCURS WHEN ILLEGAL CONVERSION -   #\n                CHAR TO BINARY - IS ATTEMPTED.'\n&C       SETC  'ABCD'\n&I       SETA  &C\n         MNOTE *,'FOLLOWING MESSAGE OCCURS WHEN ILLEGAL CONVERSION -   #\n                CHAR TO BOOLEAN - IS ATTEMPTED'\n&B       SETB  (&A)\n         MNOTE *,'FOLLOWING MESSAGE OCCURS WHEN ILLEGAL CONVERSION -   #\n                BINARY TO BOOLEAN - IS  ATTEMPTED.'\n&I       SETA  100\n&B       SETB  (&I)\n         MNOTE *,'FOLLOWING MESSAGE OCCURS WHEN ILLEGAL ATTRIBUTE USE  #\n                IS ATTEMPTED.'\n&B       SETB  (T'&A)\n         MEND\n         SPACE 1\n         TESTXPND  WXYZ\n         END\n$JOB   ASSIST       MACRO=F\n         MACRO\n         TESTCONT  &A=1234,&B=2345,                                    #\n               &C=5000,&D=6000,                                        #\n               &E=7000,&F=8000,                                        #\n               &G=9000,&H=9000,                                        #\n               &I=12000,                                               #\n               &J=13000,                                               #\n               &K=14000,                                               #\n               &L=15000       AN INDEFINITE NBR OF CONT CARDS ARE OKAY\n         MNOTE *,' PARAM VALUES ARE &A, &B, &C, &D, &E, &F, &G, &H, &I,#\n                &J, &K AND &L'\n         MEND\n         SPACE 1\n         TESTCONT  A=12,B=30,C=20,                                     #\n               D=45,F=34,                                              #\n               E=6,                                                    #\n               G=78,H=90,                                              #\n               I=99,                                                   #\n               J=17,                                                   #\n               K=74,                                                   #\n               L=43\n        END\n$JOB   ASSIST       MACRO=F\n         MACRO\n         TSTCONT1  &A=(AAAAAAAAAAAAAAAAAAA,BBBBBBBBBBBBBB,CCCCCCCCCCCCC#\n               CCC,DDDDDDDDDDDDDDDDDD,EEEEEEEEEEEEE,FFFFFFFFFFFFF,GGGGG#\n               GGGGGGGGG,HHHHHHHHHHH,IIIIIIIIIIIIIIIIII,JJJJJJJJJJJJJJJ#\n               JJJJJ,KKKKKKKKKKK)\n.*   ABOVE ERROR MESSAGE ILLUSTRATES RESTRICTION ON ASSIST CONTINUATION\n.*   CARDS, I.E. THE 3RD, 6TH, 9TH ETC CONTINUATION CARDS CANNOT END IN\n.*   THE MIDDLE OF AN OPERAND, THEY MUST BE OF THE NON-STANDARD CONTIN-\n.*   UATION FORMAT\n         MEND\n         MACRO\n         TSTCONT2  &A=(AAAAAAAAAAA,BBBBBBBBB,CCCCCCCCCC,DDDDDDDDDD,UVVV#\n               VVVVVVVVV,WWWWWWWWWWW,XXXXXXXXXXXXXXXXX,YYYYYYYYYYYYY,ZZ#\n               ZZZZZZZZZZZZZZ),&B=ABCDEFGHIJKLIMONPQRSTUVWXYZ,         #\n               &C=(111111111,222222222,333333333,444444444,555555555,66#\n               6666666,777777777,888888888,999999999,123456789,23456789#\n               0,345678901,456789012)\n.*   ABOVE EXAMPLE ILLUSTRATES HOW EVERY 3RD CARD SHOULD END ON WITH\n.*   NON-STANDARD FORMAT.  REGULAR CONTINUATION CAN THEN PICK UP AGAIN\n.*   FOR SUCCEEDING TWO CARDS\n.*   THE SAME RESTRICTION APPLIES TO A MACRO CALL AS TO THE PROTOTYPE\n.*   STATEMENT\n         MEND\n TSTCONT2 A=1,B=2,C=3\n TSTCONT1 A=1\n END\n$JOB   ASSIST       MACRO=F\n         TITLE 'TEST FOR NASTY COMMENTS, CONTINUATIONS'\n         MACRO\n         TESTCMMT  &A=20,&B=30,                                        #\n               &C=40,                                                  #\n               &D=50,&E=60\n          LCLA  &I\n          MNOTE *,' SYM PARAMS ARE &A, &B, &C, &D AND &E.'\n           MEND\n         MACRO\n         TESTCMMU &A=,                  PARAMATER A                    #\n               &B=10,&C=20              PARMS B,C\n         DC    C' &&A = &A,  &&B = &B, &&C = &C . XXXXXXXXXXXX XXXXXXXX#\n               XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXABCDEFGHIJKL#\n               MNOPQRSTUVWXYZ'\n         MNOTE *,'*****************************************************#\n               &A,&B,&C ***********************************************#\n               X '\n         TESTCMMT B=10,C=105,           THIS IS A COMMENT ON INNER MAC #\n               A=&A\n          MEND\n         SPACE 2\n          TESTCMMT   A=100,B=200,                                      #\n               C=300,D=400,                                            #\n               E=500\n         TESTCMMU A=X,B=Y,              ANOTHER COMMENT                #\n                  C=500                 COMMENT\n                                               TESTCMMT        A=101,B=#\n               102,C=103\n         TESTCMMT A=101,                                               #\n               C=102,                                                  #\n               B=103\n         TESTCMMU A=1000,S=2000,C=3000       COMMENTS\n         END\n$JOB   ASSIST       MACRO=F\n**********************************************************************\n**********************************************************************\n**********************************************************************\n**********************************************************************\n**********************************************************************\n**********************************************************************\n**********************************************************************\n**********************************************************************\n**********************************************************************\n*                                                                     *\n*              WARNING:   FOLLOWING JOBS REQUIRE THE MACRO LIBRARY    *\n*              PROCESSOR, AND SOME MAY REQUIRE CERTAIN MACROS TO BE   *\n*              AVAILABEL  (SUCH AS XSAVE, XRETURN, ETC).              *\n*                                                                     *\n*              JOBS USING IBM MACROS MAY REQUIRE EXORBITANT AMOUNTS   *\n*              OF MEMORY, DUE ESPECIALLY TO IHBERMAC, ETC.            *\n*              HOWEVER, THEY DO ASSEMBLE IN 280 K REGION OR LESS      *\n*              AND WE HAVE ACTUALLY RUN THEM.                         *\n**********************************************************************\n***********************************************************************\n***********************************************************************\n**********************************************************************\n**********************************************************************\n**********************************************************************\n         TITLE 'ILLUSTRATE XSAVE,XRETURN'\n         MACRO\n         GETMAIN\n.*             FAKE GETAMIN, SINCE WHILE XSAVE CALLS IT, IT IS NOT    *\n.*       GOING TO USE IT.  IF GETMAIN COMES IN, SO WILL IHBERMAC.     *\n         MEND\n         MACRO\n         FREEMAIN\n.*       FAKE FREEMAIN, FOR XRETURN, SAME AS GETMAIN.\n         MEND\n         SPACE 1\n         MACRO\n&LABEL   XCALL &ENTRY,&ADLIST\n.*             SIMPLE CALL, GET AROUND REGUALR CALL\n&LABEL   DS    0H                  DEFINE LABEL\n         AIF   ('&ADLIST' EQ '').X\n         L     15,=V(&ENTRY)\n         LA    1,=A&ADLIST         REQUIRES WHOLE LIST\n.X       BALR  14,15               CALL ROUTINE\n         MEND\n*SYSLIB  XSAVE,XRETURN             MENTION, SINCE NOT BEFORE\n         SPACE 2\nMAIN     CSECT\n         XSAVE\n         XCALL SUB1,(MAIN1,MAIN2)\n         XRETURN SA=*\nMAIN1    DS    F\nMAIN2    DS    F\n         LTORG\nSUB1     CSECT\n         XSAVE TR=NO,BR=13\nSUB1RET  XRETURN\n         END\n$ENTRY                             EXECUTE THE PROGRAM\n$JOB   ASSIST       MACRO=F\n         TITLE 'QSAM I/O MACROS'\n*              THIS PROGRAM GOBBLES CORE.\n         MACRO\n&LABEL    IHBERMAC &A,&B,&C,&D,&E,&F,&G\n.*        STUPID FAKE IHBERMAC\n         MNOTE *,'IHBERMAC: &A,&B,&C,&D,&E,&F,&G'\n         MEND\n*              NOTE:  MACROS CALLED FOR SPEARATELY, SO CAN SEE HOW\n*              LONG THEY ARE WITHOUT LISTING THEM.\n*SYSLIB OPEN\n*SYSLIB  CLOSE\n*SYSLIB GET\n*SYSLIB  PUT\n*SYSLIB DCB\n         USING *,15\n         OPEN  (XDCB,INPUT)\n         OPEN  (YDCB,OUTPUT)\n         GET   XDCB\n         PUT   YDCB,(0)            OUTPUT\n         CLOSE (XDCB,,YDCB)\nXDCB     DCB   DDNAME=X,MACRF=GL,EODAD=XDCB,LRECL=80,DSORG=PS\nYDCB     DCB   DDNAME=Y,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FA,BUFNO=4\n         END\n$JOB   ASSIST       MACRO=F\n*\n*        THESE PROGRAMS TEST THE ERROR DETECTIO CODE AS WELL AS\n*        THE NORMAL RETRIEVAL LOGIC INCORPORATED INTO MOCOMSYS\n*        THESE ROUTINES ALSO TEST THE XXIOCO RETRIEVAL LOGIC\n*\n*\n*        INNER MACRO CALL NOT ON THE SYSLIB CARD\n*\n*\n         MACRO\n         MCALL &RTNE\n         CALL  &RTNE\n         MEND\n         SPACE 5\n*        NEXT STMT PULLS IN: CALL,SAVE,RETURN,IHBERMAC, ETC.\n*SYSLIB  SAVE,RETURN\n         EJECT\nTEST1    CSECT\n         USING TEST1,15\n         SAVE  (14,12)\n         ST    13,TEST1SV+12\n         LA    13,TEST1SV\n         MCALL SUB1\n         L     13,TEST1SV+12\n         RETURN (14,12)\nTEST1SV  DS    18F\n         LTORG\n         DROP  15\nSUB1     CSECT\n         USING SUB1,15\n         SAVE  (14,12)\n         ST    13,SUB1SV+12\n         LA    13,SUB1SV\n*              NEXT STMT MUST BE FLAGGED, DID NOT MENTION XSNAP.\n         XSNAP LABEL='SUB1 ENTERED'\n         L     13,SUB1SV+12\n         RETURN (14,12)\nSUB1SV   DS    18F\n         DROP  15\n         END\n$JOB   ASSIST       MACRO=F\n*        THIS PROGRAM IS COMPLETELY UNEXECUTABLE\n*        IT TEST THE LIBRARY SEARCH FACILITY AND THE\n*        MACRO DEFINITION AND EXPANSION PHASES OF THE ASSIST\n*        ASSEMBLER SYSTEM\n*\n*\n*        MACROS USED FOR THE TEST:\n         EJECT\n*SYSLIB  ATTACH                    USES ENTRY1 AND DCBDUMMY\n         EJECT\n*SYSLIB  CHAP                      USES NO LOCAL ADDRESS\n         EJECT\n*SYSLIB  CHKPT                     USES NO LOCAL ADDRESS\n         EJECT\n*SYSLIB  DELETE                    USES ENTRY1\n         EJECT\n*SYSLIB  9XR                       TESTS MOCOMSYS SCAN LOGIC\n*                                  FOR ILLEGAL FIRST CHARACTER\n         EJECT\n*SYSLIB  DXR                       USES NO LOCAL ADDRESSES\n*SYSLIB  EXTRACT                   USES A 7-WORD, ALINED AREA, ANSER\n*SYSLIB  GTRACE                    USES GDATA ADDRESS\n*SYSLIB  LINK                      USES ENTRY1\n*SYSLIB  SEGLD                     USES EXTERN\n*SYSLIB  SPIE                      USES INTERADD\n*SYSLIB  STATUS                    USES TCBDUM\n*SYSLIB  STATUE                    TEST MOCOMSYS NO FIND ERROR\n*SYSLIB  XCTL                      USES ENTRY1 AND DCBDUMMY\n*SYSLIB  DETACH                    USES TCBDUM\n*\n*\n*        NEXT TEST THE ACTION OF A BLANK SYSLIB CARD\n*\n         MACRO\n         MCALL &RTNE\n         CALL  &RTNE\n         MEND\n*SYSLIB\n*SYSLIB  SAVE.RETURN               BAD DELIMITER\n*SYSLIB  SAVE,RETURN               FOR LINKAGE AND ADDRESSABILITY\n*\nWIERD    CSECT\n         USING TEST,15             SET UP ADDRESSABILITY\n         SAVE (14,12)\n*        BEGIN TEST OF MACRO EXPANSION CODE\n         MCALL SUB1\n         ATTACH    EP=ENTRY1,DCB=DCBDUMMY,HIARCHY,1,SZERO=YES\n         ATTACH    EP=ENTRY1,DCB=DCBDUMMY,HIARCHY=1,SZERO=YES\n         CHAP  -1,'S'\n         CHKPT CANCEL,(3),'S'\n         DELETE EP=ENTRY1\n         DETACH TCBDUM,STAE=YES\n         DXR   0,4\n         EXTRACT                   ANSER,'S',FIELDS=ALL\n         GTRACE DATA=GDATA,LNG=4,ID=7,FID=0\n         LINK  EP=ENTRY1,EPLOC=(5),ID=57,HIARCHY=0\n         SEGLD EXTERN\n         SPIE  INTERSDD,((1,14))\n         SPIE  INTERADD,((1,14))\n         STATUS STOP,TCB=TCBDUM\n         XCTL  (2,12),EP=ENTRY1,DCB=DCBDUMMY,HIARCHY=1\n*SYSLIB  DCB                       GET THE DCB MACRO\n         RETURN (14,12)\n         DS    0F\nDCBDUMMY DS    F\nENTRY1   DS    F\nTCBDUM   DS    F\nANSER    DS    7F\nEXTERN   DS    F\nINTERADD DS    F\n*\n*        END\n*        END OF WIERD MACRO TEST PROGRAM\n*\nSUB1     CSECT\n         USING SUB1,14\n         SAVE  (14,12)\n*SYSLIB  CHAP                      MORE WIERD TESTING\n         RETURN\n         END   WIERD\n$JOB\n*        THE FOLLOEING CODE MULTIPLIES TWO SPARSE MATRICES WHICH ARE\n*        LOADED INTO STORAGE AS ORTHAGONAL ARRAYS.  IF A MATRIX ELEMENT\n*        IS ZERO, IT IS NOT KEPT AND ITS ABSENCE INDICATES A VALUE\n*        OF ZERO FOR THAT NODE.\n*              MATRIX NODES HAVE THE FOLLOWING FORM:\n*                                 WORD 1-->THE MATRIX VALUE\n*                                 WORD 2-->THE ROW LINK\n*                                 WORD 3-->THE COLUMN LINK\n*                                 WORD 4-->SUBSCRIPT VALUES OF THE NODE\n*              THE ROW HEADERS LOOK LIKE:\n*                                 WORD 1-->THE HEADER FLAG\n*                                 WORD 2-->THE LINK(TO THE LAST NODE\n*                                 IN THE ROW).\n*                                 WORD 3-->ROW SUBSCRIPT\n*                                 WORD 4-->UNUSED\n*              THE COLUMN HEADERS LOOK LIKE:\n*                                 WORD 1-->HEADER FLAG\n*                                 WORD 2-->THE LINK(AS ABOVE)\n*                                 WORD 3-->COLUMN SUBSCRIPT\n*                                 WORD 4-->UNUSED\n*              THE OUTPUT STACK HEADERS LOOK LIKE:\n*                                 WORD 1-->UNUSED\n*                                 WORD 2-->HEADER FLAG\n*                                 WORD 3-->SUBSCRIPT VALUES\n*                                 WORD 4-->THE RIGHT LINK\n*              THE OUTPUT STACK NODES LOOK LIKE:\n*                                 WORD 1-->LEFT LINK\n*                                 WORD 2-->PARTIAL VALUE\n*                                 WORD 3-->SUBSCRIPT VALUES\n*                                 WORD 4-->THE RIGHT LINK\n*        AS THE MULTIPLY PORTION OF THE PROGRAM DEVELOPES A PARTIAL\n*        PRODUCT OF THE PRODUCT MATRIX, IT IS PUSHED ONTO THE FRONT\n*        OF A STACK.  THE STACK IS A RIGHT CIRCULAR, DOUBLY LINKED\n*        LIST.  SINCE THE MULTIPLY ALGORITHM DEVELOPS THE PRODUCT\n*        MATRIX FROM LAST ELEMENT TO FIRST, LOADING THE STACK FROM THE\n*        FRONT DEVELOPES THE PRODUCT MATRIX IN STORAGE IN THE PROPER\n*        ORDER.\n*              DATA TO THE PROGRAM:\n*        1.    'M' IN COL. 1 OF A CARD(OMIT FOR FIRST MATRIX PAIR)\n*        2.    MATRIX DIMENSIONS(INTEGER NUMBERS 0<I>51, SEPARATED BY\n*              AT LEAST ONE BLANK)\n*        3.    ROW 1 OF MATRIX 'A', EACH VALUE SEPARATED BY A BLANK\n*              LAST VALUE FOLLOWED BY: A BLANK, AND THE CHARACTER 'E'\n*        4.    ROW 2 AS ABOVE, ETC.\n*        5.    '*' IN COL. 1 TO DELIMIT MATRICES\n*        6.    VALUES OF MATRIX 'B' AS ABOVE\n*        7.    SAME AS 1 ABOVE TO DELIMIT MATRICES\n*\n*\n*\n*\n*\nMAIN     CSECT\n         BALR  12,0\n         USING *,12\n         ST    14,SAV14\n*\n*\n*              GENERATE A LIST OF  AVAILABLE SPACE LINKED THRU AVAIL\n*\n*\nBEGIN    XPRNT =CL5'1',5\n         XPRNT =CL22'0MATRIX DIMENSIONS ARE',22\n         LA    4,500              LOOP CONTROL FOR INITIAL LINKAGE\n         LA    2,WORKAREA         R2<--ADDRESS OF WORKING AREA\n         ST    2,AVAIL            STORE START OF AVAILABLE NODES\n         LR    3,2                COPY FOR CORRECT LINKAGE\nSTART    LA    3,16(3)            INCREMENT TO NEXT NODE FOR LINK\n         ST    3,4(2)             LINK WITH PREVIOUS NODE\n         LA    2,16(2)            ACCESS NEXT NODE FOR LINKUP\n         BCT   4,START            LOOP\n         MVC   0(4,2),=X'00000000'       GROUND LAST NODE\n*\n*\n*              INPUT, CONVERT, AND SAVE EACH MATRIX PARAMETER CARD\n*              CHECK FOR MATRIX COMPATIBILITY\n*              ECHO PRINT EACH PARAMETER CARD\n*\n*\n         XREAD CARD,80            READ MATRIX PARAMETER CARD\n         XPRNT CARD-1,50          ECHO PRINT INPUT\n         XPRNT =CL50'0ECHO CHECK ON INPUT MATRICES',50\n         BM    STOP               ON LAST CARD OF DECK END EXECUTION\n         XDECI 2,CARD             COVERT ROW PARAM. MATRIX A\n         XDECI 3,0(1)             CONVERT COL. PARAM MATRIX A\n         XDECI 4,0(1)             CONVERT ROW PARAM. MATRIX B\n         XDECI 5,0(1)             CONVERT COL. PARAM. MATRIX B\n         STM   2,5,ROWA           STORE FOR LATER USE\n         ST    4,ROWBI            STORE ROWB FOR LATER USE\n         CR    3,4                ARE MATRICES COMPATIBLE\n         BE    SKIP               YES-- SKIP ERROR OUTPUT\n         XPRNT =CL100'***ERROR*** MARICES ARE NOT COMPATIBLE; AND CANNOT\n               T BE MULTIPLIED',100\n         XPRNT =CL50'   MATRIX DIMENSIONS ARE:',50\n         XDECO 2,EMESS+26         CONVERT MATRIX DIMENSIONS FOR OUTPUT\n         XDECO 3,EMESS+43\n         XDECO 4,EMESS+77\n         XDECO 5,EMESS+94\n         XPRNT EMESS,106          PRINT MATRIX  DIMENSIONS\nDUMP     XREAD CARD,1             LOOK FOR MATRIX DELIMITER\n         CLI   CARD,C'M'\n         BE    BEGIN\n         B     DUMP\n*\n*\n*              DEVELOPE TABLES OF ARRAY HEADER ADDRESSES\n*                  TABRA-->ROW HEADER TABLE MATRIX 'A'\n*                  TABCA-->COLUMN HEADER TABLE MATRIX 'A'\n*                  TABRB-->ROW HEADERS OF MATRIX 'B'\n*                  TABCB-->COLUMN HEADERS TABLE OF MATRIX 'B'\n*\n*\nSKIP     L     3,AVAIL            SET AVAIL TO FIRST NODE\n         LA    10,ROWA            ADDRESS OF IMAX,JMAX,KMAX,LMAX\n         LA    11,TABRA           ADDRESS OF HEADER TABLES\n         LA    4,4                OUTER LOOP CONTROL\nOUTER    LR    9,11               NEW REG. TO INDEX INTO EACH TABLE\n         SR    1,1                COUNTER FOR EACH INDEX\n         L     2,0(10)            SUCCESIVE DIMENSIONS IN R2\nINNER    LA    1,1(1)             INCREMENT INDEX\n         L     3,AVAIL            P<--AVAIL\n         CLC   4(3),=F'0'         LOOK FOR LAST NODE\n         BE    OVFLOW             IF FOUND OVERFLOW HAS OCCURRED\n         MVC   AVAIL(4),4(3)      OTHERWISE; AVAIL<--LINK(AVAIL)\n         ST    3,0(9)             HEADER ADDRESS IN HEADER TABLE\n         ST    1,8(3)             INDEX VALUE IN HEADER\n         MVC   0(4,3),=C'HEAD'    VALUE(HEADER)<--HEADER FLAG\n         ST    3,4(3)             LINK HEADER TO ITSELF(EMPTY LIST)\n         LA    9,4(9)             NEXT CELL OF HEADER TABLE\n         BCT   2,INNER            LOOP TO INNER LOOP\n         LA    10,4(10)           GET NEXT DIMENSION\n         LA    11,200(11)         GET NEXT HEADER TABLE\n         BCT   4,OUTER            LOOP TO OUTER ATEP\n*\n*\n*              DEVELOPE A TABLE OF OUTPUT STACK HEADER ADDRESSES\n*                  TABSTK--> STACK HEADER TABLE\n*\n*\n         LA    5,TABSTK           REFERENCE STACK HEADER TABLE\n         LA    1,0                ZERO R1 FOR ROW INDEX\n         L     2,ROWA             NUMBER OF STACKS=ROWA\nSTACK    LA    1,1(1)             INCREMENT INDEX COUNTER\n         L     3,AVAIL            P<--AVAIL\n         CLC   4(3),=F'0'         IS IT LAST NODE?\n         BE    OVFLOW             YES--OVERFLOW\n         MVC   AVAIL(4),4(3)      N/-- AVAIL<--LINK(AVAIL)\n         ST    3,0(5)             PUT HEADER ADDRESS IN TABLR\n         STH   1,8(3)             PUT ROW INDEX IN HEADER\n         MVC   4(4,3),=C'HEAD'    PUT HEADER FLAG IN HEADER\n         ST    3,12(3)            LINK HEADER TO ITSELF FOR EMPTY LIST\n         LA    5,4(5)             GET NEXT PLACE IN TABLE\n         BCT   2,STACK            CONTINUE UNTILL ROWA=0\n*\n*\n*              INPUT, CONVERT, AND STORE THE MATRIX ELEMENTS INTO\n*              THE ORTHAGONAL ARRAY\n*              IF AN ELEMENT EQUALS ZERO NO SPACE IS SAVED FOR THAT\n*              ELEMENT\n*\n*\n         LA    5,TABRA            INITIALIZE FOR ARRAY LOADING\n         LR    6,5                OPERATIONS ON MATRIX 'A'\n         LA    8,TABCA\n         LR    9,8\nNEWMTRX  L     10,0(9)            COL. HEADER ADDRESS IN R10\nSTRTNWR  L     7,0(6)             ROW HEADER ADDRESS IN R7\nNEWCARD  LA    4,CARD             USE R4 FOR MULTIPLE READ OFF A CARD\n         XREAD 0(4),80            READ A DATA CARD\n         XPRNT CARD-1,81          ECHO PRINT THE ROW OF A MATRIX\n         CLI   CARD,C'M'          HAS MATRIX INPUT ENDED\n         BE    MULT               YES--THEN MULTIPLY THE MATRICES\n         CLC   0(1,4),=C'*'       LOOK FOR MATRIX SEPARATER\n         BE    MATRIXB            IF FOUND--LOAD ARRAY 'B'\nNEXTELEM XDECI 11,0(4)            CONVERT FROM CARD TO HEX\n         LR    4,1                KEEP XDECI MOVING IN CARD\n         BO    NEWROW             END OF CURRENT ROW, GET NEW ROW\n         LTR   11,11              IS VALUE ZERO?\n         BZ    NEWCOL             YES<- GOTO NEXT COLUMN OF THIS ROW\n         L     2,AVAIL            TEMP<--AVAIL\n         MVC   AVAIL(4),4(2)      AVAIL<--LINK(AVAIL)\n         ST    11,0(2)            VALUE(AVAIL)<--ELEMENT\n         MVC   4(4,2),4(7)        ROWLINK(AVAIL)<--LINK(ROWHEADER\n         MVC   8(4,2),4(10)       COLLINK(AVAIL)<--LINK(COLHEADER)\n         ST    2,4(7)             LINK(ROWHEADER)<--AVAIL\n         ST    2,4(10)            LINK(COLHEADER)<--AVAIL\n         MVC   14(2,2),10(7)      ROWINDEX(AVAUL)<-- ROW INDEX\n         MVC   12(2,2),10(10)     COLINDEX(AVAIL)<--COL. INDEX\nNEWCOL   LA    9,4(9)             DISPLACE TO NEXT HEADER IN COL. TABLE\n         L     10,0(9)            RETREIVE NEW HEADER ADDRESS IN R10\n         B     NEXTELEM\nNEWROW   LR    9,8                RESTART ROW ACCESSING TABCA\n         LA    6,4(6)             GET NEXT ROW HEADER FROM LIST\n         B     NEWMTRX            RESTART LOADING LOOP\nMATRIXB  LA    5,TABRB            INITIALIZE FOR ARRAY LOADING\n         LR    6,5                OPERATIONS ON ARRAY 'B'\n         LA    8,TABCB\n         LR    9,8\n         B     NEWMTRX\n*\n*\n*              THIS SECTION USES THE HEADER TABLES AS A STARTING POINT\n*              AND MULTIPLIES THE TWO SPARSE MATRICES.  IF A ROW OF\n*              MATRIX 'A' OR A COLUMN OF MATRIX 'B' ARE ALL ZEROS\n*              OR IF A CORRESPONDING NODE DOES NOT EXIST IN EITHER\n*              MATRIX, THAT NODE OR ROW OF OUTPUT IS SKIPPED AND THE\n*              NEXT ROW-COLUMN PAIR OR NODE-NODE PAIR IS CONSIDERED.\n*\n*\nMULT     XPRNT =CL50'0THE PRODUCT MATRIX IS',50\nTEMP     EQU   14                 EQUATE THESE REGISTERS TO LABLES AT\nRESULT   EQU   2                  LEFT FOR EASE IN IMPLEMENTING\nI        EQU   3                  MULTIPLY OPERATION\nJ        EQU   4\nK        EQU   5\nL        EQU   6\n         SR    14,14              TEMP<--0\n         LR    RESULT,TEMP        RESULT<--0\n         LM    I,L,ROWA           I<-IMAX,J<-JMAX,K<-KMAX,L<-LMAX\n         LA    7,TABRA            REFERENCE HEADER TABLES FOR\n         LA    8,TABCB            INDEXING INTO THE MATRICES\n         SLL   L,2                DISPLACEMENT INTO THE TABLES\n         AR    8,L                DISPLACE INTO TABLE\n         S     8,=F'4'            CORRECT DISPLACEMENT FOR LAST ENTRY\n         SRL   L,2                FOR LOOPING PURPOSES\nBOTTOM   SLL   I,2                CORRECT TO BYTES,IMAX&LMAX FOR PROPER\n         AR    7,I                DISPLACE INTO TABLES\n         S     7,=F'4'            CORRECT DISPLACEMENT FOR LAST ENTRY\n         SRL   I,2                RESTORE TO DECIMAL EQUIVALENT\n         L     10,0(8)            R10<--HEADER (LMAX) ADDRESS\n         L     13,4(10)           GET LAST NODE OF LIST\n         ST    13,LASTNODE        SAVE FOR USE IN LOOP\nSTART1   L     9,0(7)             R9<--HEADER(IMAX) ADDRESS\n         L     11,4(9)            INDEX I TH NODE OF MATRIX A\nCHECK    CR    10,13              IS COL(I) OF MATRIX B EMPTY\n         BE COLNULL               YES--CONTINUE AT COLNULL\n         CR    9,11               IS ROW(I) OF MATRIX A EMPTY\n         BE    ROWNULL            YES--CONTINUE TA ROWNULL\n         CH    I,14(11)           IS NODE THE I,J TH NODE OF A\n         BNE   ROWZIP             NO--RECOVER AT ROWZIP\n         CH    J,12(11)\n         BNE   ROWZIP\n         CH    K,14(13)           IS NODE K,L TH NODE OF B\n         BNE   COLZIP             NO--RECOVER AT COLZIP\n         CH    L,12(13)\n         BNE   COLZIP\nMULTPLY  L     15,0(11)           TEMP<--A(I,J)*B(K,L)\n         M     TEMP,0(13)\n         AR    RESULT,15          RESULT<--RESULT+TEMP\n         BCTR  J,0                DECREMENT J & K FOR NEXT STAGE\n         BCTR  K,0\n         LTR   J,J                IS J ZERO\n         BNP   JUMP1              YES--THEN GO TO JUMP FOR OUTPUT\nTAKLINK  L     11,4(11)           TAKE LINK TO NEXT NODE IN BOTH MAT.\n         L     13,8(13)\n         B     CHECK              CHECKK IF THESE NODES ARE CORRECT\nJUMP1    LTR   RESULT,RESULT      IF RESULT=0\n         BZ    DECI               SKIP INSERTING RESULT IN OUT LIST\n         BAL   15,INSERT          IF NOT--GO TO INSERT & OUTPUT RESULT\nDECI     L     J,COLA             J<--JMAX\n         L     K,ROWB             K<--KMAX\n         SR    RESULT,RESULT      RESULT<--0\n         L     13,LASTNODE        PREPARE MATRIX B FOR NEXT OPERATION\n         BCTR  I,0                DECREMENT I FOR OPERATION CONTROL\n         LTR   I,I                IS I=0\n         BZ    DECL               GO TO DECL AND GET NEW COL IN B\n         S     7,=F'4'            OTHERWISE GET NEXT ROW OF A\n         B     START1             AND CONTINUE\nCOLNULL  CR    9,11               SINCE ROW(I) OF A IS EMPTY TESTTO\n*                                 SEE IF CORRISPONDING COL OF B IS\n*                                 ALSO EMPTY\n         BE    DECL               IF IT IS GO TO DECL AND CONTINUE\n         B     DECI               OTHERWISE--GO TO DECI AND CONTINUE\nCOLZIP   CH    I,14(11)           SINCE CORRECT NODE EXISTS IN MATRIX A\n*                                 BUT NOT IN MATRIX B,  TEST FOR AT\n*                                 LEAST ONE NODE IN  ROW(I) OF A\n         BE    ROWLINK            IF IT EXISTS, TAKE A LINK IN A\nCOUT     BCTR  J,0                IF NOT, DECREMENT J & K AND CONTINUE\n         BCTR  K,0\n         B     CHECK\nROWLINK  L     11,4(11)           TAKE A LINK IN MATRIX A AND\n         B     COUT               MAINTAIN LOOP CONTROLS AT COUT\n*\n*\n*        SAME LOGIC FOR THE CASE WHEN  THE CORRECT NODE EXISTS IN\n*        MATRIX B BUT NOT IN MATRIX A\n*\n*\nROWZIP   CH    K,14(13)\n         BE    COLINK\nROUT     BCTR  J,0\n         BCTR  K,0\n         B     CHECK\nCOLINK   L     13,8(13)\n*\n         BCTR  J,0\n         BCTR  K,0\n         B     CHECK\n*\n*        LOGIC FOR ROWNULL IS THE SAME AS USED IN SECTION HEADED BY\n*        COLNULL\n*\n*\nROWNULL  BCTR  J,0\n         BCTR  K,0\n         LTR   J,J\n         BNP   JUMP1\n         B     TAKLINK\n*\n*\n*        LOGIC USED IN DECL SAME AS IN DECI\n*\n*\nDECL     BCTR  L,0\n         LTR   L,L\n         BZ    OUTPUT\n         S     8,=F'4'\n         LA    7,TABRA\n         L     I,ROWA\n         B     BOTTOM\n*\n*\n*              WHEN MULT DEVELOPES A PARTIAL PRODUCT, IT IS GIVEN TO\n*              INSERT AND IS PUSHED ON THE FRONT OF THE OUTPUT STACK\n*\n*\nINSERT   STM   0,9,SAVMAIN        PROTECT SOME REGS. TO USE LOCALLY\n         L     1,TABSTK           ACCESS FIRST TABLE ENTRY\nLOOK     CH    I,8(1)             IS HEADER THE I TH HEADER\n         BE    LOCATED            YES--GO TO LOCATED\n         LA    1,16(1)            NO--FIND NEXT HEADER\n         B     LOOK               CONTINUE\nLOCATED  L     7,AVAIL            P<--AVAIL\n         CLC   4(4,7),=F'0'       IF LINK(P)=0\n         BE    OVFLOW             THEN OVERFLOW\n         MVC   AVAIL(4),4(7)      AVAIL<--LINK(AVAIL)\n         C     1,12(1)            DOES LINK(HEADER)=HEADER ADDRESS\n         BE    OPEN               YES--THEN OPEN THE LIST\n         ST    1,0(7)             OTHERWISE; LLINK(P)<--HEADER ADDRESS\n         MVC   12(4,7),12(1)      RLINK(P)<--RLINK(HEADER)\n         L     3,12(1)            LINK TO NEXT AVAIL NODE IN R3\n         ST    7,0(3)             RLINK(LLINK(HEADER))<--P\n         ST    7,12(1)            RLINK(HEADER)<--P\nBACK     ST    RESULT,4(7)        VALUE(P)<--RESULT\n         STH   I,8(7)             ROWINDEX(P)<--I\n         STH   L,10(7)            COLINDEX(P)<--L\n         LM    0,9,SAVMAIN        RESTORE REGS. FOR RETURN\n         BR    15                 RETURN\nOPEN     MVC   12(4,7),12(1)      RLINK(P)<--RLINK(HEADER)\n         MVC   0(4,7),12(1)       LLINK(P)<--RLINK(HEADER)\n         ST    7,12(1)            RLINK(HEACER)<--P\n         B     BACK               RETURN VIA BACK\n*\n*\n*              WHEN MULTIPLICATION OPERATIONS ARE COMPLETEED, THE NEXT\n*              SECTION OUTPUTS THE PRODUCT MATRIX AS STORED IN THE\n*              ROW STACKS DEVELOPED AT INSERT\n*\n*\nOUTPUT   L     1,TABSTK           ACCESS TABLE OF STACK HEADERS\n         LA    2,ROWOUT2+3        R2<--ADD. OF BUFFER TO OUTPUT\n         LA    10,COLOUT2+3       PRODUCT MATRIX\n         L     3,ROWA             R3= NUMBER OF ROWS IN PRODUCT MATRIX\nOUTLOOP  C     1,12(1)            IS LIST FOR ROW(I) EMPYT\n         LR    14,1               COPY HEADER ADD. FOR EMPTY TEST\n         BE    NOVALUES           YES--PRINT MESS AND CONTINUE\n         L     9,12(1)            GET FIRST NODE OF CURRENT ROW\nOUTNEXT  L     6,4(9)             TEMP<--VALUE(NODE)\n         XDECO 6,OUTTEMP          CONVERT FOR OUTPUT\n         MVC   0(4,2),OUTTEMP+8   PUT SIGNIFICANT PORTIOM OF NUMBER\n*                                 INTO OUTPUT BUFFER\n         LA    2,4(2)             GET NEXT USABLE PORTION OF BUFFER\n         LH    6,10(9)            R6<--COL. INDEX\n         XDECO 6,OUTTEMP          CONVERT FOT OUTPUT\n         MVC   1(2,10),OUTTEMP+10 MOVE TO RIGHT IN COL BUFFER\n         LA    10,4(10)           GET NEXT PORTION OF COL. BUFFER\n         C     14,12(9)           ARE WE DONE--RLINK(NODE)=HEADER\n         BE    DONE               YES--PRINT COMPLETED ROW & CONTINUE\n         L     9,12(9)            ACCESS JTH NODE OF CURRENT ROW\n         B     OUTNEXT            DO ABOVE FOR ALL NODES(I) OF EACH\n*                                 ROW\nDONE     LH    6,8(1)             R6<--ROW VALUE OF CURRENT ROW\n         XDECO 6,OUTTEMP          CONVERT TO OUTPUT\n         MVC   ROWOUT+3(2),OUTTEMP+10   MOVE INDEX INTO BUFFER\n         XPRNT COLOUT,133         PRINT COL. INDICATOR\n         XPRNT ROWOUT,133         PRINT COMPLETED ROW\n         MVC   ROWOUT2(130),BLANK BLANK OUT WORKIG AREA OF BUFFER\n         MVC   COLOUT2(130),BLANK BLANK OUT WORKIG AREA OF BUFFER\n         XPRNT SKIP,3             SKIP 3 LINES\n         LA    1,16(1)            ACCESS NEXT HEADER IN HEADER TABLE\n         LA    2,ROWOUT2+3        RE-INITIALIZE OUTPUT AREA\n         LA    10,COLOUT2+3       RE-INITIALIZE OUTPUT AREA\nJUMP     BCT   3,OUTLOOP          LOOP IMAX TIMES\n         XREAD CARD,10            LOOK FOR CONTROL CARDS OF NEXT\n         BM    STOP               MATRIX OPERATION...IF /* FOUND STOP\n         B     BEGIN              IF NOT--RESTART PROGRAM AT BEGIN\nSTOP     L     14,SAV14           PUT ASSIST RETURN ADDRESS IN R14\n         XPRNT =CL5'1',5          SKIP A PAGE TO CLEAR OUTPUT\n         BR    14                 RETURN TO ASSIST\nNOVALUES XPRNT =CL50'0NO NON-ZERO ELEMENTS IN NEXT ROW',50\n         B     DONE\nOVFLOW   XPRNT =CL50'0OVERFLOW HAS OCCURRED, STOP EXECUTION',50\n         B     STOP\n         LTORG\nSAV14    DS    F\nAVAIL    DS    F\nLASTNODE DS    F\nROWA     DS    F\nCOLA     DS    F\nROWB     DS    F\nCOLB     DS    F\nROWBI    DS    F\nSAVMAIN  DS    18F\nTABRA    DS    50F\nTABCA    DS    50F\nTABRB    DS    50F\nTABCB    DS    50F\nTABSTK   DS    50F\n         DC    CL8' '              PROVIDE BLANKS FOR PRINTING\nCARD     DS    80C\nOUTTEMP  DS    12C\nCOLOUT   DC    C'0J='\nCOLOUT2  DC    130C' '\nROWOUT   DC    C'0I='\nROWOUT2  DC    130C' '\nSKIP3    DC    C'0  '\nEMESS    DC    C'0     MATRIX ONE----> ROW=            ;COL=           1\n                ;MATRIX TWO-----> ROW=            ;COL=            '\nBLANK    DC    130C' '\n         DS    0D\nWORKAREA DS    9000C\n         END\n$ENTRY\n 3 2 2 4\n1 0 E\n3 4 E\n0 6 E\n*\n0 8 9 10 E\n0 12 0 14 E\nM\n\n3 3 3 3\n0 0 0 E\n4 5 6 E\n7 8 9 E\n*\n9 0 7 E\n6 0 4 E\n3 0 1 E\nM\nM\n3 3 3 3\n1 2 3  E\n4 5 6 E\n7 8 9 E\n*\n9 8 7 E\n6 5 4 E\n3 2 1 E\nM\nM\n3 2 2 3\n1 2 E\n3 4 E\n5 6 E\n*\n7 8 9 E\n10 11 12 E\nM\nM\n1 3 3 1\n1 2 3 E\n*\n4 E\n5 E\n6 E\nM\nM\n1 1 1 1\n4 E\n*\n4 E\nM\nM\n1 8 8 1\n0 0 0 0 0 0 0 0 E\n*\n1 E\n0 E\n0 E\n0 E\n0 E\n0 E\n0 E\n0 E\nM\nM\n3 2 2 5\n1 2 E\n3 4 E\n5 6 E\n*\n1 2 3 4 5 E\n6 7 8 9 10 E\nM\nM\n$JOB   ASSIST   MACRO=F\n         MACRO\n&LABEL   QSAVE     &REGS=(14,12),&BASE=12,&SA=*\n         GBLC      &SAVADDR\n         LCLA      &DISP,&CNTR,&TBASE\n         LCLC      &NAME\n&LABEL   DS        0F .                     DEFINE LABEL, ALLIGN\n         AIF       (&BASE EQ 13).ERROR .    IF BASE IS R13,R14, OR R15\n         AIF       (&BASE EQ 14).ERROR .    ILLEGAL, SET DEFAULT VALUE\n         AIF       (&BASE NE 15).OKAY\n.ERROR   MNOTE     'ILLEGAL BASE REGISTER'\n&TBASE   SETA      12\n         AGO       .SKIP\n.OKAY    ANOP\n&TBASE   SETA      &BASE\n.SKIP    USING     *,15\n&CNTR    SETA      0-1\n         AIF       ('&LABEL' EQ '').CSECTNM\n.AGAIN   ANOP\n&CNTR    SETA      &CNTR+2\n         AIF       ('&LABEL'(1,&CNTR) LT '&LABEL').AGAIN\n&NAME    SETC      '&LABEL'\n         AGO       .IDFIELD\n.CSECTNM ANOP\n&CNTR    SETA      &CNTR+2\n         AIF       ('&SYSECT'(1,&CNTR) LT '&SYSECT').CSECTNM\n&NAME    SETC      '&SYSECT'\n.IDFIELD B         1+&CNTR+4(,15)\n         DC        X'&CNTR',CL.&CNTR'&NAME'\n         AIF       (&REGS(1) EQ 14).ASPECAL .IS &REGS(1) 14 OR 15\n         AIF       (&REGS(1) NE 15).AREGULR .IF YES GO TO ASPECAL\n.ASPECAL ANOP\n&DISP    SETA      ((&REGS(1)-14)*4)+12 .   DISPLACEMENT FOR R14&R15\n         AGO       .ARESUME\n.AREGULR ANOP\n&DISP    SETA      (&REGS(1)*4)+20 .   DISPLACEMENT FOR R0-R12\n.ARESUME STM       &REGS(1),&REGS(2),&DISP.(13). SAVE REGISTERS\n         AIF       ('&SA' EQ 'NO').NOSAVE .SIP SAVE AREA\n         AIF       ('&SA' EQ '*').DEFAULT\n&SAVADDR SETC      '&SA'\n         AGO       .AROUND\n.DEFAULT ANOP\n&SAVADDR SETC      '&SYSECT'(1,3).'&SYSNDX'(2,3).'S' .GENERATE NAME\n.AROUND  LA        &TBASE,&SAVADDR .        GET SAVE AREA ADDR\n         ST        &TBASE,8(13) .           PTR TO NEW SAVE AREA\n         ST        13,4(&TBASE) .           PTR TO OLD SAVE AREA\n         LR        13,&TBASE .              GET IN RIGHT SAVE AREA\n.NOSAVE  BALR      &TBASE,0\n         DROP      15 .                     DELETE TEMP BASE REG\n         USING     *,&TBASE .               USING NEW BASE REG\n         MEND\n         SPACE     5\n         MACRO\n&LABEL   QRETURN   &REGS=(14,12),&SA=*\n         GBLC      &SAVADDR\n         LCLA      &DISP\n&LABEL   DS        0H .                     DEFINE LABEL, ALLIGN\n         AIF       (&REGS(1) EQ 14).BSPECAL .IS REG(1) 14 OR 15\n         AIF       (&REGS(1) NE 15).BREGULR .IF YES GO TO BSPECAL\n.BSPECAL ANOP\n&DISP    SETA      ((&REGS(1)-14)*4)+12 . DISPLACDMENT FOR R14&R15\n         AGO       .BRESUME\n.BREGULR ANOP\n&DISP    SETA      (&REGS(1)*4)+20 .        DISPLACEMENT FOR R0-R12\n.BRESUME AIF       ('&SA' EQ 'NO').NORESTR\n         L         13,4(13) .               RESTORE PREVIOUS SA PTR\n         LM        &REGS(1),&REGS(2),&DISP.(13) .STANDARD REG RESTORA\n         BR        14 .                     RETURN TO CALLER\n&SAVADDR DC        18F'0' .                 SAVE AREA, USING GENERATED\n         MEXIT\n.NORESTR LM        &REGS(1),&REGS(2),&DISP.(13) .STANDARD REG RESTORA\n         BR        14 .                     RETURN TO CALLER\n         MEND\n         SPACE     5\n         MACRO\n&LABEL   FREEHDR   &NUMBER,&LENGTH\n         GBLA      &FREENUM(20),&FREELEN(20),&FREECTR\n         GBLB      &FREEOFF\n         AIF       (&FREEOFF).ERROR2\n         AIF       (&FREECTR GE 20).ERROR1\n&FREECTR SETA      &FREECTR+1\n&LABEL   DC        A(FR&FREECTR)\n&FREENUM(&FREECTR) SETA &NUMBER\n&FREELEN(&FREECTR) SETA &LENGTH\n         MEXIT\n.ERROR1  MNOTE     8,'***MORE THAN 20 CALLS MADE ON FREEHDR**'\n&FREEOFF SETB      1\n         MEXIT\n.ERROR2  MNOTE     *,'***FREEHDR HAS BEEN DISABLED**'\n         MEND\n         SPACE     3\n         MACRO\n         FREEAREA\n         GBLA      &FREENUM(20),&FREELEN(20),&FREECTR,&FRCTR\n         AIF       (&FREECTR GT &FRCTR). MORE\n         MNOTE     *,'**CALL TO FREEAREA RESULTED IN NO PROCESSING**'\n         MEXIT\n.MORE    ANOP\n&FRCTR   SETA      &FRCTR+1\nFR&FRCTR DS        0F\n.NEXT    AIF       (&FREENUM(&FRCTR) LE 1).LAST\n         DC        A(*+4*(&FREELEN(&FRCTR)+1)),&FREELEN(&FRCTR)F'0'\n&FREENUM(&FRCTR)   SETA &FREENUM(&FRCTR)-1\n         AGO       .NEXT\n.LAST    DC        A(0),&FREELEN(&FRCTR)F'0'\n         AIF       (&FRCTR LT &FREECTR).MORE\n         MEND\n         SPACE     3\n         MACRO\n&LABEL   LISTHDR\n&LABEL   DC        4F'0'\n         MEND\n         SPACE     3\n         MACRO\n&LABEL   GETFREE   &FRHDR,&REG,&END\n&LABEL   L         &REG,&FRHDR .            GET PTR TO TOP\n         LTR       &REG,&REG .              IS LIST EMPTY\n         BZ        &END .                   YES, TAKE EXCEPTION EXIT\n         MVC       &FRHDR.(4),0(&REG) .     NO, DELINK\n         MEXIT\n&END     SR        0,0\n         MEND\n         SPACE     3\n         MACRO\n&LABEL   PUTFREE   &FRHDR,&REG\n&LABEL   MVC       0(4,&REG),&FRHDR .       RETURN NODE\n         ST        &REG,&FRHDR .            TO TOP OF FREE LIST\n         MEND\n         SPACE     3\n         MACRO\n&LABEL   PUTNODE   &HDR,&REG,&KEY=4,&KEYLEN=4,&LENGTH=0,&MSG=\n         GBLB      &NOTRC\n         LCLC      &SVAREA,&LAB\n&SVAREA  SETC      '&SYSECT'(1,3).'&SYSNDX'.'S'\n&LAB     SETC      '&SYSECT'(1,3).'&SYSNDX'.'L'\n         STM       1,3,&SVAREA .            SAVE R1, R2, R3\n         LR        3,&REG .                 ADDR OF NODE TO BE PUT IN\n         LA        1,&HDR\n         L         &KEYLEN,&KEY.(1)\n         LA        &KEYLEN,1(&KEYLEN) .     ADD 1 TO CURRENT LEN CNTR\n         ST        &KEYLEN,&KEY.(1)\n         C         &KEYLEN,&LENGTH.(1) .    IF CURRENT LENGTH\n         BNH       *+8 .                    IS GREATER THAN MAX\n         ST        &KEYLEN,&LENGTH.(1) .    THEN CHANGE MAX\n&LAB     LR        &KEYLEN,1 .              TRANSVERSE LIST\n         L         1,0(1)\n         LTR       1,1 .                    IF WE ARE AT END\n         BZ        *+14 .                   PUT NEW NODE HERE\n         CLC       &KEY.(2,1),&KEY.(3) .    SHOULD NODE GO IN\n         BNH       &LAB .                   NOT YET\n         ST        1,0(3) .                 PUT IN NEW NODE\n         ST        3,&HDR\n         LR        &REG,3\n         LM        1,3,&LAB .               RESTORE R1,R2,R3\n         AIF       (&NOTRC EQ 1).NOTRACE .  OMIT TRACE\n         AIF       (K'&MSG EQ 0).HDR .      PRINT HDR IF NO MSG\n         XPRNT     =CL(13+K'&MSG)'0ADDITION TO &MSG',13+K'&MSG\n         AGO       .DUMP\n.HDR     XPRNT     =CL(13+K'&HDR)'0ADDITION TO &HDR',13+K'&HDR\n.DUMP    XDUMP     &KEY.(&REG),&LENGTH\n         XDUMP\n.NOTRACE B         &SVAREA+12\n&SVAREA  DC        3F'0'\n         MEND\n         SPACE     3\n         MACRO\n&LABEL   DELETE    &HDR,&REG,&END,&LENGTH=0,&MSG=\n         GBLB      &NOTRC\n         LCLC      &SVAREA,&LABM,&LABE,&LABL\n&SVAREA  SETC      '&SYSECT'(1,3).'&SYSNDX'.'S'\n&LABM    SETC      '&SYSECT'(1,3).'&SYSNDX'.'M'\n&LABE    SETC      '&SYSECT'(1,3).'&SYSNDX'.'E'\n&LABL    SETC      '&SYSECT'(1,3).'&SYSNDX'.'L'\n         STM       1,3,&SVAREA .            SAVE R1, R2, R3\n         LR        3,&REG\n         LA        1,&HDR\n&LABL    LR        &HDR,1 .                 TRANSVERSE LIST\n         L         1,0(1)\n         LTR       1,1 .                    IF DONE, ITEM\n         BZ        &LABM .                  WAS NOT IN LIST\n         CR        1,3\n         BNE       &LABL .                  TRY NEXT NODE\n         MVC       0(4,&REG),0(1) .         GOT IT NOW DELINK\n         LA        1,&HDR .                 UPDATE LENGTH\n         L         &REG,4(1)\n         BCTR      &REG,0\n         ST        &REG,4(1)\n         LM        1,3,&SVAREA .            RESTORE R1, R2, R3\n         AIF       (&NOTRC EQ 1).NO\n         XPRNT     =CL(15+K'&HDR)'0DELETION FROM &HDR',15+K'&HDR\n.NO      XDUMP\n         B         &LABE\n&SVAREA  DC        3F'0'\n&LABM    LM        1,3,&SVAREA .            RESTORE R1, R2, R3\n         B         &END\n&LABE    EQU       *\n&END     SR        0,0\n         MEND\n         SPACE     3\n         MACRO\n&LABEL   POP       &HDR,&REG,&END,&LENGTH=0,&MSG=\n&LABEL   L         &REG,&HDR .              ADDR OF NODE TO REMOVE\n&LABEL   DELETE    &HDR,&REG,&END,LENGTH=&LENGTH,MSG=&MSG\n         MEND\n         MACRO\n         SETGBL    &CATNO=1,&IONO=1,&NOTRACE=NO\n         GBLA      &CAT,&ION\n         GBLB      &NOTRC\n&CAT     SETA      &CATNO\n&ION     SETA      &IONO\n&NOTRC   SETB      0\n         AIF       ('&NOTRACE' EQ 'NO').DONE\n&NOTRC   SETB      1\n.DONE    MEND\n         SPACE     3\n         MACRO\n         LISTS\n         GBLA      &CAT,&ION\n.* GENERATE LIST HEADERS\n         CRLISTS   CATHDR,&CAT\n         CRLISTS   IOQHDR,&ION\n         MEND\n         SPACE     3\n         MACRO\n         CRLISTS   &PREFIX,&NUM\n         LCLA      &COUNT\n.MORE    ANOP\n&COUNT   SETA      &COUNT+1\n&PREFIX&COUNT LISTHDR\n         AIF       (&COUNT LT &NUM).MORE\n         MEND\n         SETGBL\nDATA     CSECT\nEVQFR    FREEHDR   3,3\nDQFR     FREEHDR   18,3\n         LISTS\nRJQHDR   LISTHDR\nEVQHDR   LISTHDR\n         FREEAREA\nDQEL     DSECT\nDQLINK   DS        F\nDQKEY    DS        CL8\nEVQEL    DSECT\nEVQLINK  DS        F\nEVQKEY   DS        CL8\n         TITLE     'TEST'\n         PRINT     GEN\nTEST     CSECT\n         QSAVE      ,\n         L         11,DATAADR\n         USING     DATA,11\n         USING     EVQEL,1\n         USING     DQEL,3\n         GETFREE   EVQFR,ERROR\n         MVC       EVQKEY,EVENT1\n         PUTNODE   EVQHDR,1,KEYLEN=6,LENGTH=8\n         GETFREE   EVQFR,1,ERROR\n         MVC       EVQKEY,EVENT2\n         PUTNODE   EVQHDR,1,KEYLEN=6,LENGTH=8\n         GETFREE   EVQFR,1,ERROR\n         MVC       EVQKEY,EVENT1\n         PUTNODE   EVQHDR,1,KEYLEN=6,LENGTH=8\n         LR        2,1\n         GETFREE   EVQFR,1,UNDER1\n         B         ERROR\nUNDER1   XDUMP     EVQHDR,16\n         DELETE    EVQHDR,2,ERROR,LENGTH=8\n         PUTFREE   EVQFR,2\n         DELETE    EVQFR,2,OK\n         B         ERROR\nOK       GETFREE   EVQHDR,1,ERROR\n         MVC       EVQKEY,EVENT3\n         SETGBL    NOTRACE=YES\n         PUTNODE   EVQHDR,1,KEYLEN=6\n         SETGBL    NOTRACE=NO\nCONTINUE POP       EVQHDR,1,DONE,LENGTH=8\n         PUTFREE   EVQFR,1\n         B         CONTINUE\nDONE     LA        5,JQE1\nGETMORE  GETFREE   DQFR,3,UNDER2\n         MVC       DQKEY,0(5)\n         PUTNODE   CATHDR1,3,KEYLEN=2,LENGTH=8,MSG='CAT'\n         SETGBL    NOTRACE=YES\n         GETFREE   DQFR,3,ERROR\n         MVC       DQKEY,0(5)\n         PUTNODE   RJQHDR,3,KEY=6,KEYLEN=2\n         GETFREE   DQFR,3,ERROR\n         MVC       DQKEY,0(5)\n         PUTNODE   IOQHDR1,3,KEY=8,KEYLEN=2\n         LA        5,8(5)\n         B         GETMORE\n         SETGBL    NOTRACE=NO\nUNDER2   POP       CATHDR1,1,ALLDONE,LENGTH=8\n         POP       RJQHDR,1,ERROR,LENGTH=8\n         POP       IOQHDR1,1,ERROR,LENGTH=8\n         B         UNDER2\nERROR    XPRNT     =CL6'0ERROR',6\nALLDONE  XDUMP     CATHDR1,64\n         QRETURN   SA=*\nEVENT1   DC        F'5',H'1,2'\nEVENT2   DC        F'6',H'0,0'\nEVENT3   DC        F'5',H'0,0'\nJQE1     DC        H'1,2,3,1'\n         DC        H'2,3,1,2'\n         DC        H'3,1,2,3'\n         DC        H'3,2,1,4'\n         DC        H'2,1,3,5'\n         DC        H'1,3,2,6'\nDATAADR  DC        V(DATA)\n         END       TEST\n$JOB   ASSIST   MACRO=F\n         MACRO\n&LABEL   QRETURN     &REGS=(14,12),&SA=*\n         GBLC  &SAVL\n         LCLA  &D\n&LABEL   DS    0H  .               LABEL\n         AIF   ('&SA' EQ 'NO').NOSAV\n         L     13,4(13)  .         GET OLD POINTER\n.NOSAV   AIF   (T'&REGS(1) NE 'N').EREG\n&D       SETA  &REGS(1)*4+20\n         AIF   (&D LE 75).LOADA\n&D       SETA  &D-64\n.LOADA   AIF   (N'&REGS NE 2).LOAD1\n         LM    &REGS(1),&REGS(2),&D.(13)  .   RESTORE REGS\n         AGO   .RET\n.LOAD1   AIF   (N'&REGS NE 1).EREG\n         L     &REGS(1),&D.(13)   .     SAVE ONLY ONE REG\n.RET     BR    14  .               RETURN\n         AIF   ('&SA' NE 'NO').GOON\n         MEXIT\n.GOON    AIF   ('&SA' NE '*').USEN\n&SAVL    DC    18F'0'  .           SAVE AREA\n         MEXIT\n.USEN    ANOP\n&SA      DC    18F'0'  .           SAVE AREA\n         MEXIT\n.EREG    MNOTE 8,'***REGISTERS CANNOT BE RETURNED-SPECIFICATION ERROR'\n         MEND\n         MACRO\n&LABEL   QSAVE &REGS=(14,12),&BASE=12,&SA=*\n         GBLA  &GINS\n         GBLC  &SAVL\n         LCLA  &LABLN,&BRDIST,&D\n         LCLC  &LAB2,&BAS2\n&LAB2    SETC '&LABEL'\n&LABLN   SETA  K'&LABEL\n&BAS2    SETC '&BASE'\n         USING *,15  .             SET UP TEMP ADDS\n         AIF   (&LABLN NE 0).LAB\n         CSTLNG &SYSECT\n&LABLN   SETA  &GINS\n.LAB     ANOP\n&LAB2    SETC '&SYSECT'\n&BRDIST  SETA  (&LABLN+2)/2*2+4\n&LABEL   B     &BRDIST.(,15)  .      CONVENTIONS FOR NAME\n         DC    X'&LABLN',CL(&LABLN)'&LAB2'\n         AIF   (T'&REGS(1) NE 'N').EREG\n&D       SETA  &REGS(1)*4+20\n         AIF   (&D LE 75).STOREA\n&D       SETA  &D-64\n.STOREA  AIF   (N'&REGS NE 2).STORE1\n         STM   &REGS(1),&REGS(2),&D.(13)   .     SAVE CALLERS REGS\n         AGO   .SAVE\n.STORE1  AIF   (N'&REGS NE 1).EREG\n         ST    &REGS(1),&D.(13)  .***ONLY ONE REG SAVED\n.SAVE    AIF   ('&BAS2' LE '12').OK\n         MNOTE 4,'***REG &BASE NOT A LEGAL BASE REG-REG 12 USED'\n&BAS2    SETC  '12'\n.OK      AIF   ('&SA' EQ 'NO').NOSAV\n         AIF   ('&SA' NE '*').USEN\n&SAVL    SETC  '&SYSECT'(1,3).'&SYSNDX.S'\n         LA    &BAS2,&SAVL\n         AGO   .SETSAV\n.USEN    LA    &BAS2,&SA    .      SAVE AREA CONVENTIONS\n.SETSAV  ST    &BAS2,8(13)\n         ST    13,4(&BAS2)\n         LR    13,&BAS2\n.NOSAV   BALR  &BAS2,0   .             ADDRESSABILITY\n         DROP  15\n         USING *,&BAS2\n         MEXIT\n.EREG    MNOTE 8,'***REGISTERS NOT SAVED DUE TO SPEDC ERROR'\n         MEND\n         MACRO\n         CSTLNG &NAME\n         GBLA  &GINS\n&GINS    SETA  K'&NAME\n         MEND\n         MACRO\n         SETGBL  &TR\n         GBLB  &NOTRC\n         AIF   ('&TR' NE 'NO').GOON\n&NOTRC   SETB  1\n.GOON    MEND\n         MACRO\n&LABEL   FREEHDR    &NUMBER,&LENGTH\n         GBLA  &FREENUM(20),&FREELEN(20),&FREECTR\n         GBLB  &FREEOFF\n         AIF   (&FREEOFF).ERROR2\n         AIF   (&FREECTR GE 20).ERROR1\n&FREECTR SETA  &FREECTR+1\n&LABEL   DC    A(FR&FREECTR)\n&FREENUM(&FREECTR)      SETA       &NUMBER\n&FREELEN(&FREECTR)  SETA  &LENGTH\n         MEXIT\n.ERROR1  MNOTE 8,'**MORE THAN 20 CALLS MADE ON FREEHDR**'\n&FREEOFF SETB  1\n         MEXIT\n.ERROR2  MNOTE *,'**FREEHDR HAS BEEN DISABLED**'\n         MEND\n         MACRO\n         FREEAREA\n         GBLA  &FREENUM(20),&FREELEN(20),&FREECTR,&FRCTR\n         AIF   (&FREECTR GT &FRCTR).MORE\n         MNOTE *,'**CALL TO FREEAREA RESULTED IN NO PROCESSING**'\n         MEXIT\n.MORE    ANOP\n&FRCTR   SETA  &FRCTR+1\nFR&FRCTR DS    0F\n.NEXT    AIF   (&FREENUM(&FRCTR) LE 1).LAST\n         DC    A(*+4*(&FREELEN(&FRCTR)+1)),&FREELEN(&FRCTR)F'0'\n&FREENUM(&FRCTR)  SETA             &FREENUM(&FRCTR)-1\n         AGO   .NEXT\n.LAST    DC    A(0),&FREELEN(&FRCTR)F'0'\n         AIF   (&FRCTR LT &FREECTR).MORE\n         MEND\n         MACRO\n&LABEL   LISTHDR\n&LABEL   DC    4F'0'\n         MEND\n         MACRO\n&LABEL   GETFREE  &FRHDR,&REG,&END\n&LABEL   L     &REG,&FRHDR  .GET LINK TO NODE\n         LTR   &REG,&REG   .         IS IT THE NULL LIKN\n         BZ    &END   .            IF SO THERE IS NO LINL\n         MVC   &FRHDR.(4),0(&REG)  .   DELINK\n         MEND\n         MACRO\n&LABEL   PUTFREE  &FRHDR,&REG\n&LABEL   MVC   0(4,&REG),&FRHDR   .      RETURN NODE\n         ST    &REG,&FRHDR   .     NEW TOP LINK\n         MEND\n         MACRO\n&LABEL   PUTNODE  &HDR,&REG,&KEY=4,&KEYLEN=4,&LENGTH=0,&MSG=\n         GBLB  &NOTRC\n         LCLA  &KONT\n         LCLC  &CHAR\n&LABEL   DS    0H    .             DEFINE LABEL\n         CNOP  0,4  .              ASSURE CORRECT ALIGNMENT\n         STM   14,0,EP&SYSNDX.A+4  .     SAVE WORKING REGS\n         LA    0,&HDR     .        PARAMETER\n         ST    0,EP&SYSNDX.A+16  .     STORE PARAM\n         LR    0,&REG              TRANSFER FOR CALL\n         L     15,EP&SYSNDX.A  .     ENTRYPOINT\n         BALR  14,15  .            GO TO SUBR\nEP&SYSNDX.A    DC    V(PUTNODE)\n         DC    4F'0'   .           SAVE AREA\n         DC    AL1(&KEYLEN)\n         DC    AL3(&KEY)\n         LM    14,0,4(14)  .       RESTORE SECOND SET OF REGS\n         AIF   (&NOTRC).NOTR\n&CHAR    SETC '&HDR'\n&KONT    SETA  K'&HDR\n         AIF   (K'&MSG EQ 0).GENP\n&CHAR    SETC '&MSG'\n&KONT    SETA  K'&MSG\n.GENP    ANOP\n&KONT    SETA  &KONT+13\n         XPRNT =CL&KONT' ADDITION TO &CHAR',&KONT\n         AIF   (&LENGTH EQ 0).REGO\n         XDUMP 4(&REG),&LENGTH  .    DUMP THE NODE\n.REGO    XDUMP ,  .                DUMP REGS\n.NOTR    MEND\n         MACRO\n&LABEL   DELETE  &HDR,&REG,&END,&LENGTH=0,&MSG=\n         GBLB  &NOTRC\n         LCLA  &KONT\n         LCLC  &CHAR\n&LABEL   DS    0H\n         CNOP  0,4  .              ASSURE CORRECT ALIGNMENT\n         STM   14,0,ENT&SYSNDX.D+4  .    SAVE FIRST REGS\n         LA    0,&HDR\n         ST    0,ENT&SYSNDX.D+16\n         LR    0,&REG  .           SAVE REG TO CSECT\n         L     15,ENT&SYSNDX.D   .       ENTRYPOINT\n         BALR  14,15  .            CALL SUBR\nENT&SYSNDX.D   DC  V(DELETE)\n         DC    4F'0'  .            CONTROL BLOCK SAVE AREA\n         LTR   15,15               .            TEST FOR RESULTS\n         LM    14,0,4(14)  .       RETURN TOP LEVEL REGS\n         BNZ   &END                IF WAS NOT GO TO END\n         AIF   (&NOTRC).NOTR\n&CHAR    SETC '&HDR'\n&KONT    SETA  K'&HDR\n         AIF   (K'&MSG EQ 0).GENP\n&CHAR    SETC '&MSG'\n&KONT    SETA  K'&MSG\n.GENP    ANOP\n&KONT    SETA  &KONT+15\n         XPRNT =CL&KONT' DELETION FROM &CHAR',&KONT\n         XDUMP ,  .                DUMP REGS\n.NOTR    MEND\n         PRINT ON\n         MACRO\n&LABEL   POP   &HDR,&REG,&END,&LENGTH=0,&MSG=\n&LABEL   L     &REG,&HDR     .     MAKE IT THE FIRAST NODE\n         DELETE  &HDR,&REG,&END,LENGTH=&LENGTH,MSG=&MSG\n         MEND\n         MACRO\n         SETGBL  &CATNO=1,&IONO=1,&NOTRACE=NO\n         GBLA  &CAT,&ION\n         GBLB  &NOTRC\n&CAT     SETA  &CATNO\n&ION     SETA  &IONO\n&NOTRC   SETB  0\n         AIF   ('&NOTRACE' EQ 'NO').DONE\n&NOTRC   SETB  1\n.DONE    MEND\n         MACRO\n         LISTS\n         GBLA  &CAT,&ION\n.* GENERATE LIST HEADERS\n         CRLISTS  CATHDR,&CAT\n         CRLISTS  IOQHDR,&ION\n         MEND\n         MACRO\n         CRLISTS  &PREFIX,&NUM\n         LCLA  &COUNT\n.MORE    ANOP\n&COUNT   SETA  &COUNT+1\n&PREFIX&COUNT  LISTHDR\n         AIF   (&COUNT LT &NUM).MORE\n         MEND\nPUTNODE  CSECT\n*        ROUTINE TO PUT A NODE INTO A LIST BY KEYWORD\n*        USES SPECIAL NON-DESTRUSTIVE LINKAGE\n         USING PUTNODE,15          ADDRESSABILITY\n         STM   1,7,PUSAVE          SAVE WORKING REGS\n         SR    7,7                 CLEAR A EREG\n         IC    7,20(14)            GET &KEYLEN\n         LR    3,0                 TRANS R0 TO A USEABLE REG\n         L     4,20(14)            GET KEY\n         LA    6,0(4,3)            FOR OPERATIONAL EASE\n         L     1,16(14)            ADDR OF &HDR\n         L     2,4(1)              INCREMENT\n         LA    2,1(2)              LENGTH CNTR\n         ST    2,4(1)              STORE NEW CURRENT LENGTH\n         C     2,8(1)              IS LENGTH>MAX\n         BNH   PUNOCHNG            IF NOT DONT CHANGE\n         ST    2,8(1)              UPDATE MAX\nPUNOCHNG LR    2,1                 SAVE R1\n         L     1,0(1)              GET LIMK\n         LTR   1,1                 IS IT THE NULL LINK\n         BZ    PUNEW0              IF SO WE ARE DONE\n         LA    5,0(1,4)            SET UP ADDR FOR EX\n         EX    7,PUCLC             COMPARE KEYS\n         BNH   PUNOCHNG            IF NOT HIGH TRY SOME MORE\nPUNEW0   ST    1,0(3)              PUT IN NEW NODE\n         ST    3,0(2)              AND LINK UP\n         LM    1,7,PUSAVE          RESTORE\n         B     28(14)              RETURN\nPUCLC    CLC   0(0,5),0(6)         USED BY EX\nPUSAVE   DC    7F'0'               SAVE AREA\nDELETE   CSECT\n*        ROUTINE TO DELETE A GIVEN NODE FROM A LIST\n*        USES SPECIAL NON-DESTRUSTIVE LINKAGE\n         USING DELETE,15           ADDRESSABILITY\n         STM   1,3,DESAV           SAVE WORKING REGS\n         L     1,16(14)            ADDR OF &HDR\n         LR    3,1                 COPY REG 1\nDETOPL   LR    2,1                 COPY REG 1\n         L     1,0(1)              LINK\n         LTR   1,1                 IS IT END\n         BZ    DENOTL              IF SO WE ARE DONE\n         CR    1,0                 IS IT THE ONE\n         BNE   DETOPL              IF NOT TRY AGAIN\n         MVC   0(4,2),0(1)         DELINK NODE\n         L     2,4(3)              UPDATE LENGCH\n         BCTR  2,0                 BY DECREMENT BY 1\n         ST    2,4(3)              STORE NEW LENGTH\n         SR    15,15               SET FLAG--NORMAL RETURN\nDERETL   LM    1,3,DESAV           RETURN WORKING REGS\n         B     20(14)              RETURN\nDENOTL   LA    15,1                SET RETUNR CODE--ITEM NOT IN LIST\n         B     DERETL\nDESAV    DS    3F'0'               SAVE AREA\n         SETGBL\nDATA     CSECT\nEVQFR    FREEHDR 3,3\nDQFR     FREEHDR  18,3\n         LISTS\nRQJHDR   LISTHDR\nEVQHDR   LISTHDR\n         FREEAREA\nDQEL     DSECT\nDQLINK   DS    F\nDQKEY    DS    CL8\nEVQEL    DSECT\nEVQLINK  DS    F\nEVQKEY   DS    CL8\n         TITLE 'TEST'\n         PRINT GEN\nTEST     CSECT\n         QSAVE\n         L     11,DATAADR\n         USING DATA,11\n         USING EVQEL,1\n         USING DQEL,3\n         GETFREE  EVQFR,1,ERROR\n         MVC   EVQKEY,EVENT1\n         PUTNODE  EVQHDR,1,KEYLEN=6,LENGTH=8\n         GETFREE  EVQFR,1,ERROR\n         MVC   EVQKEY,EVENT1\n         PUTNODE  EVQHDR,1,KEYLEN=6,LENGTH=8\n         GETFREE  EVQFR,1,ERROR\n         MVC   EVQKEY,EVENT1\n         PUTNODE  EVQHDR,1,KEYLEN=6,LENGTH=8\n         LR    2,1\n         GETFREE  EVQFR,1,UNDER1\n         B     ERROR\nUNDER1   XDUMP EVQHDR,16\n         DELETE  EVQHDR,2,ERROR,LENGTH=8\n         PUTFREE  EVQFR,2\n         DELETE  EVQHDR,2,OK\n         B     ERROR\nOK       GETFREE  EVQHDR,1,ERROR\n         MVC   EVQKEY,EVENT3\n         SETGBL  NOTRACE=YES\n         PUTNODE  EVQHDR,1,KEYLEN=6\n         SETGBL  NOTRACE=NO\nCONTINUE POP   EVQHDR,1,DONE,LENGTH=8\n         PUTFREE  EVQFR,1\n         B     CONTINUE\nDONE     LA    5,JQE1\nGETMORE  GETFREE  DQFR,3,UNDER2\n         MVC   DQKEY,0(5)\n         PUTNODE  CATHDR1,3,KEYLEN=2,LENGTH=8,MSG='CAT'\n         SETGBL  NOTRACE=YES\n         GETFREE  DQFR,3,ERROR\n         MVC   DQKEY,0(5)\n         PUTNODE  RJQHDR,3,KEY=6,KEYLEN=2\n         GETFREE  DQFR,3,ERROR\n         MVC   DQKEY,0(5)\n         PUTNODE  IOQHDR1,3,KEY=8,KEYLEN=2\n         LA    5,8(5)\n         B     GETMORE\n         SETGBL  NOTRACE=NO\nUNDER2   POP   CATHDR1,1,ALLDONE,LENGTH=8\n         POP   RJQHDR1,1,ERROR,LENGTH=8\n         POP   IOQHDR1,1,ERROR,LENGTH=8\n         B     UNDER2\nERROR    XPRNT =CL6'0ERROR',6\nALLDONE  XDUMP CATHDR1,64\n         QRETURN\nEVENT1   DC    F'5',H'1,2'\nEVENT2   DC    F'6',H'0,0'\nEVENT3   DC    F'5',H'0,0'\nJQE1     DC    H'1,2,3,1'\n         DC    H'2,3,1,2'\n         DC    H'3,1,2,3'\n         DC    H'3,2,1,4'\n         DC    H'2,1,3,5'\n         DC    H'1,3,2,6'\nDATAADR  DC    V(DATA)\n         LTORG\n         END   TEST\n$JOASSIST  MACRO=F\n         CSECT\n         BALR  11,0\n         USING *,11\n         SR       6,6\n         SR       7,7\n         XREAD    CARD\n         XDUMP  OVER,300\n         L        7,=A(CARD)\nOVER     CLI      0(7),C' '\n         LA       7,1(7)\n         BE       SS\n         B        OVER\nSS       LA       6,LAST\nOK       MVC      0(1,6),0(7)\n         LA       6,1(6)\n         LA       7,1(7)\n         CLI      0(7),C' '\n         BNE      OK\n         L        7,=A(CARD)\n         IC       6,C' '\n         LA       6,1(6)\nANEW     MVC      0(1,6),0(7)\n         CLI      0(7),C' '\nPRNT     XPRNT    LAST-1,81\n         BE       PRNT\n         LA       7,1(7)\n         LA       6,1(6)\n         B        ANEW\n         BR       14\n         DC       C'1'\nLAST     DS       CL80' '\nCARD     DS       CL80\n         END\n$ENTRY\nLINDA BURNS\n$JOASSIST MACRO=F\n         MACRO\n&LABEL   DEFLIST   &N\n         LCLA      &CNT\n&CNT     SETA      &N-2\nLISTHEAD DC        A(&LABEL)\n&LABEL   DC        A(*+80),72C' ',A(0)\n.LOOP    DC        A(*+80),72C' ',A(*-76)\n&CNT     SETA      &CNT-1\n         AIF       (&CNT NE 0).LOOP\n         DC        A(0),72C' ',A(*-76)\n         MEND\n         EJECT\nMAIN     CSECT\nBEGIN    STM       14,12,12(13)\n         BALR      12,0\n         USING     *,12\nSSN      EQU       4\nNAME     EQU       16\nSTATUS   EQU       14\nADDR     EQU       46\nFLINK    EQU       0\nBLINK    EQU       76\n         LA        5,LISTHEAD\n         L         5,0(5)\n         MVC       SSN(5),SELECT\nREAD     XREAD     CARD,80\n         BC        7,EOF\n         MVC       TEMP(10),CARD\n         MVI       TEMP+10,C' '\n         XDECI     2,TEMP\n         ST        2,DULLW\n         C         2,SSN(5)\n         BC        8,ERROR\n         BC        2,HIGH\n         L         5,FLINK(5)\nMOVE     MVC       SSN(5),DULLW\n         MVC       STATUS(5),ISTATUS\n         MVC       NAME(5),INAME\n         MVC       ADDR(5),IADDR\n         B         READ\nHIGH     MVC       TCARD(72),0(5)\n         L         5,FLINK(5)\n         MVC       0(72,5),TCARD\n         L         5,BLINK(5)\n         B         MOVE\nEOF      LR        4,5\n         LA        5,LIST1\nPRINT    MVC       OSTATUS,STATUS(5)\n         MVC       ONAME,NAME(5)\n         MVC       OADDR,ADDR(5)\n         L         3,SSN(5)\n         CVD       3,DOUBLE\n         XPRNT     LINE,132\n         L         5,0(5)\n         CR        5,4\n         BC        11,EOJ\n         B         PRINT\nERROR    MVC       LINE,LINE-1\n         MVC       LINE(16),=C'THIS IS AN ERROR'\n         XPRNT     LINE,132\nEOJ      BR        14\n         DC        C' '\nLINE     DS        0CL132\n         DC        17C' '\nOSSN     DC        10C' '\n         DC        17C' '\nOSTATUS  DC        2C' '\nDC       9C' '\nONAME    DC        30C' '\n         DC        9C' '\nOADDR    DC        30C' '\n         DC        8C' '\nCARD     DS        0CL80\nISSN     DS        CL10\nISTATUS  DS        CL2\nINAME    DS        CL30\nIADDR    DS        CL30\n         DS        CL8\nSELECT   DC        F'9999999999'\nDULLW    DS        D\nDOUBLE   DS        D\nTEMP     DS        CL10\nTCARD    DS        CL76\n         LTORG\nLIST1    DEFLIST   50\n         END\n$ENTRY\nTHIS IS ANY OLD CARD\n$JOASSIST  MACRO=F\n         MACRO\n&LABEL   POP   &HDR,&REG,&END,&LENGTH,&MSG\n.*\n.*       THIS IS MACRO POP. IT TAKES A NODE OFF OF THE TOP OF THE\n.*       LINKED LIST.\n.*\n.*       &HDR -ADDRESS OF THE HEADER OF THE LINKED LIST.\n.*       &REG -REGISTER WITH HEADER OF LINKED LIST.\n.*       &END -THIS IS THE LABEL OF SOME INSTRUCTION.\n.*       &LENGTH -NUMBER OF BYTES OF DATA PORTION OF NODE ADDED.\n.*       &MSG -A QUOTED STRING OF CHARACTERS.\n.*\n         L     &REG,&HDR           LOAD HDR INTO REG.\n&LABEL   DELETE &HDR,&REG,&END,&LENGTH,&MSG\n         MEND\n         MACRO\n&LABEL   GETFREE &FRHDR,&REG,&END\n.*\n.*       THIS MACRO GETS A FREE NODE FROM THE FREE LIST WHOSE HEADER\n.*       IS AT &FRHDR.\n.*\n.*       &REG -REGISTER INTO WHICH ADDRESS OF NODE IS PLACED.\n.*       &END -AREA OF CODE TO BE GENERATED IF GETFREE FAILS TO GET\n.*       ANY FREE SPACE FROM THE LIST.\n.*       &LABEL -LABEL TO BE PLACED IN FIRST INSTRUCTION OF GEN. CODE.\n.*       &FRHDR -IS A RELOCATABLE EXPRESSION.\n.*       &REG -ABSOLUTE EXPRESSION BETWEEN 1 AND 15.\n.*       &END -LABEL OF SOME INSTRUCTION.\n.*\n&LABEL   L     &REG,&FRHDR         GET POINTER TO THE TOP.\n         LTR   &REG,&REG           TEST TO SEE IF LIST NULL.\n         BZ    &END                IF YES TAKE THE EXIT.\n         MVC   &FRHDR.(4),0(&REG)  NO DELINK   TOP CELL.\n         MEND\n         MACRO\n&LABEL   PUTFREE &FRHDR,&REG\n.*\n.*       THE PUTFREE MACRO RETURNS A NODE TO THE FREE LIST. THE\n.*           HEADER IS AT &FRHDR. THE ADDRESS OF THE NODE IS IN &REG.\n.*\n.*       &REG -NUMBER BETWEEN 1 AND 15.\n.*       &FRHDR - THIS IS A RELOCATEABLE EXPRESSION.\n.*\n&LABEL   DS    OH\n         MVC   0(4,&REG),&FRHDR    RETURN THE NODE TO LIST.\n         ST    &REG,&FRHDR         PUT IT ON THE VERY FRONT.\n         MEND\n         MACRO\n&LABEL   PUTNODE &HDR,&REG,&KEY,&KEYLEN,&LENGTH,&MSG\n.*\n.*       PUTNODE PUTS A NODE INTO LINKED LIST WITH HEADER AT &HDR.\n.*       THE NODES ADDRESS IS FOUND IN &REG. THE INSERTION IS BY ASCEND\n.*       ING ORDER AT AN OFFSET OF &KEY BYTES FROM BEGINNING OF NODE.\n.*       LENGTH OF KEY IS SPECIFIED BY KEYLEN. THE LIST LENGTH WILL BE\n.*       UPDATED.\n.*\n.*       &LABEL -THIS IS A LABEL.\n.*       &REG - THIS IS ABSOLUTE EXPRESSION BETWEEN 1 AND 15.\n.*       &HDR - THIS TELLS WHERE HEADER IS.\n.*       &KEY - ABSOLUTE EXPRESSION AS DEFINED ABOVE\n.*       &KEYLEN -ABSOLUTE EXPRESSION AS DEFINED ABOVE.\n.*       &LENGTH -ABSOLUTE EXPRESSION AS DEFINED ABOVE.\n.*       &MSG - THIS IS A QUOTED STRING OF CHARACTERS.\n.*\n         LCLC  &PUT\n&PUT     SETC  'PUT0001'\n&LABEL   STM   1,3,&PUT.'S'        SAVE REGISTERS 1,2,AND3.\n         LR    3,&REG              LOAD REGISTER 3 INTO REGISTER 5.\n         LA    1,&HDR\n         L     2,4(1)              ADD ONE TO CURRENT LENGTH COUNTER.\n         LA    2,1(2)\n         ST    2,4(1)\n         C     2,&LENGTH(1)        IS CURRENT LENGTH GREATER THAN MAX.\n         BNH   *+&LENGTH\n         ST    2,&LENGTH(1)        YES, THEN CHANGE MAX.\n&PUT.'L' LR    2,1                 TRANSVERSE THE LIST.\n         L     1,0(1)\n         LTR   1,1                 ARE WE AT THE END.\n         BZ    *+14                END REACHED, PUT NEW NODE HERE.\n         CLC   4(KEYLEN,1),4(3)    COMPARE TO SEE IF NODE GOES IN.\n         BNH   &PUT.'L'            FT DOES NOT GO IN YET.\n         ST    1,0(3)              STORE REGISTER 1 ZERO BEYOND 3.\n         ST    3,&HDR              STORE REGISTER 3 INTO &HDR.\n         LR    &REG,3              RELOAD REGISTER 3 INTO &REG.\n         LM    1,3,&PUT.'S'        RESTORE REGISTERS 1,2,AND3.\n         XPRNT =CL(13+3)' ADDITION TO &MSG ',13+3\n         XDUMP 4(&REG),&LENGTH\n         B     &PUT.'S'+12\n&PUT.'S' DC    3F'0'\n         MEND\n         MACRO\n&LABEL   DELETE &HDR,&REG,&END,&LENGTH,&MSG\n.*\n.*       THE DELETE MACRO DELETES A NODE FROM THE LINKED LIST.\n.*\n.*       &REG -ADDRESS OF NODE TO BE DELETED.\n.*       &HDR -HEADER OF LINKED LIST.\n.*       &END -THIS IS LABEL OF SOME INSTRUCTION TO WHICH TO BRANCH.\n.*       &LENGTH -LENGTH OF BYTES OF NODE TO BE DELETED.\n.*       &MSG -THIS IS A MESSAGE.\n.*\n         LCLC  &PUT\n&PUT     SETC  'DEL0005'\n         STM   1,3,&PUT.'S'        SAVE REGISTERS 1,2,AND3.\n         LR    3,&REG\n         LA    1,&HDR\n&PUT.'L' LR    &REG,1              TRANSVERSE THE LIST.\n         L     1,0(1)\n         LTR   1,1                 CHECK TO SEE IF DONE.\n         BZ    &PUT.'M'            YES,ITEM NOT IN LIST.\n         CR    1,3\n         BNE   &PUT.'L'            TRY THE NEXT NODE.\n         MVC   0(4,&REG),0(1)      GOT THE NODE, NOW DELINK IT.\n         LA    1,&HDR              UPDATE THE LENGTH NOW.\n         L     &REG,4(1)\n         BCTR  &REG,0\n         ST    &REG,4(1)\n         LM    ',3,&PUT.'S'        RESTORE REGISTERS 1,2,AND3.\n         XPRNT =CL(15+5)' DELETION FROM &HDR ',15+5\n         XDUMP                     JUST REGISTERS\n         B     &PUT.'E'\n&PUT.'S' DC    3F'0'\n&PUT.'M' LM    1,3,&PUT.'S'        RESTORE REGISTERS 1,2,AND3.\n         B     &END\n&PUT.'E' EQU   *\n         MEND\n         MACRO\n&LABEL   DUMPLIST &HDR,&NUM,&LEN,&MSG\n.*\n.*       THIS MACRO DUMPS THE FIRST &LEN BYTES BEYOND LINK OF EACH OF\n.*       THESE UP TO &NUM FIRST NODE IN LINKED LIST WHOSE HEADER=&HDR.\n.*       THE MESSAGE 'DUMP OF &HDR' OR 'DUMP OF MSG' IS PRINTED AS\n.*       PRELUDE TO DUMP. EACH NODE IS LABELED THRU XSNAP BY THE STRING\n.*       'NEXT NODE'\n.*\n&LABEL   XSNAP LABEL='DUMP OF PMSG'\n         LCLC  &PUT\n         STM   1,2,DMP0007S        SAVE REGISTERS 1 AND 2.\n         L     1,&HDR\n         LA    2,&NUM\n&PUT     SETC  'DMP0007'\n&PUT.'L' LTR   1,1                 IF AT THE END THEN QUIT.\n         BZ    &PUT.'E'\n         XSNAP T=NO,LABEL='NEXT NODE',STORAGE-(*4(1),*&NUM(1))\n         L     1,0(1)\n         BCT   2,&PUT.'L'          GET THE NEXT NODE\n         B     &PUT.'E'\n&PUT.'S' DC    2F'0'\n&PUT.'E' LM    1,2,&PUT.'S'\n         MEND\n        MACRO\n         SETGBL  &NOTRACE=NO\n         GBLA      &CAT,&ION\n         GBLB      &NOTRC\n&CAT     SETA    1\n&ION     SETA    1\n&NOTRC   SETB      0\n         AIF       ('&NOTRACE' EQ 'NO').DONE\n&NOTRC   SETB      1\n.DONE    MEND\n         MACRO\n         LISTS\n         GBLA      &CAT,&ION\n.* GENERATE LIST HEADERS\n         CRLISTS   CATHDR,&CAT\n         CRLISTS   IOQHDR,&ION\n         MEND\n         MACRO\n         CRLISTS   &PREFIX,&NUM\n         LCLA      &COUNT\n.MORE    ANOP\n&COUNT   SETA      &COUNT+1\n&PREFIX&COUNT      LISTHDR\n         AIF       (&COUNT LT &NUM).MORE\n         MEND\n         SETGBL\nDATA     CSECT\nEVQFR    FREEHDR   3,3\nDQFR     FREEHDR   18,3\n         LISTS\nRJQHDR   LISTHDR\nEVQHDR   LISTHDR\n         FREEAREA\nDQEL     DSECT\nDQLINK   DS        F\nDQKEY    DS        CL8\nEVQEL    DSCET\nEVQLINK  DS        F\nEVQKEY   DS        CL8\n         TITLE     'TEST'\n         PRINT     GEN\nTEST     CSECT\n         QSAVE ,                   OR WHAT HAVE (BR=12)\n         L         11,DATAADR\n         USING     DATA,11\n         USING     EVQEL,1\n         USING     DQEL,3\n         GETFREE   EVQFR,1,ERROR\n         MVC       EVQKEY,EVENT1\n         PUTNODE   EVQHDR,1,KENLEN=6,LENGTH=8\n         GETFREE   EVQFR,1,ERROR\n         MVC       EVQKEY,EVENT2\n         PUTNODE   EVQHDR,1,KENLEN=6,LENGTH=8\n         GETFREE   EVQFR,1,ERROR\n         MVC       EVQKEY,EVENT1\n         PUTNODE   EVQHDR,1,KEYLEN=6,LENGTH=8\n         LR        2,1\n         GETFREE   EVQFR,1,UNDER1\n         B         ERROR\nUNDER1   XDUMP     EVQHDR,16\n         DELETE    EVQHDR,2,ERROR,LENGTH=8\n         PUTFREE   EVQFR,2\n         DELETE    EVQHDR,2,OK\n         B         ERROR\nOK       GETFREE   EVQHDR,1,ERROR\n         MVC       EVQKEY,EVENT3\n         SETGBL    NOTRACE=YES\n         PUTNODE   EVQHDR,1,KEYLEN=6\n         SETGBL    NOTRACE=NO\nCONTINUE POP       EVQHDR,1,DONE,LENGTH=8\n         PUTFREE   EVQFR,1\n         B         CONTINUE\nDONE     LA        5,JQE1\nGETMORE  GETFREE   DQFR,3,UNDER2\n         MVC       DQKEY,0(5)\n         PUTNODE   CATHDR1,3,KEYLEN=2,LENGTH=8,MSG='CAT'\n         SETGBL    NOTRACE=YES\n         GETFREE   DQFR,3,ERROR\n         MVC       DQKEY,0(5)\n         PUTNODE   RJQHDR,3,KEY=6,KEYLEN=2\n         GETFREE   DQFR,3,ERROR\n         MVC       DQKEY,0(5)\n         PUTNODE   IOQHDR1,3,KEY=8,KEYLEN=2\n         LA        5,8(5)\n         B         GETMORE\n         SETGBL    NOTRACE=NO\nUNDER2   POP       CATHDR1,1,ALLDONE,LENGTH=8\n         POP       RJQHDR,1,ERROR,LENGTH=8\n         POP       IOQHDR1,1,ERROR,LENGTH=8\n         B         UNDER2\nERROR    XPRNT     =CL6'OERROR',6\nALLDONE  XDUMP     CATHDR1,64\n         QRETURN   SA=*\nEVENT1   DC        F'5',H'1,2'\nEVENT2   DC        F'6',H'0,0'\nEVENT3   DC        F'5',H'0,0'\nJQE1     DC        H'1,2,3,1'\n         DC        H'2,3,1,2'\n         DC        H'3,1,2,3'\n         DC        H'3,2,1,4'\n         DC        H'2,1,3,5'\n         DC        H'1,3,2,6'\n         DC        V(DATA)\n         END       TEST\n         MACRO\n&LABEL   FREEHDR   &NUMBER,&LENGTH\n         GBLA      &FREENUM(20),&FREELEN(20),&FREECTR\n         GBLB      &FREEOFF\n         AIF       (&FREEOFF).ERROR2\n         AIF       (&FREECTR GE 20).ERROR1\n&FREECTR SETA      &FREECTR+1\n&LABEL   DC        A(FR&FREECTR)\n&FREENUM(&FREECTR) SETA &NUMBER\n&FREELEN(&FREECTR) SETA &LENGTH\n         MEXIT\n.ERROR1 MNOTE 8,'**MORE THAN 20 CALLS MADE ON FREEHDR**'\n&FREEOFF SETB      1\n         MEXIT\n.ERROR2 MNOTE *,'**FREEHDR HAS BEEN DISABLED**'\n         MEND\n         MACRO\n         FREEAREA\n         GBLA      &FREENUM(20),&FREELEN(20),&FREECTR,&FRCTR\n         AIF       (&FREECTR GT &FRCTR).MORE\n         MNOTE *,'**CALL TO FREEAREA RESULTED IN NO PROCESSING**'\n         MEXIT\n.MORE    ANOP\n&FRCTR   SETA      &FRCTR+1\nFR&FRCTR DS        0F\n.NEXT    AIF       (&FREENUM(&FRCTR) LE1).LAST\n         DC        A(*+4*(&FREELEN(&FRCTR)+1)),&FREELEN(&FRCTR)F'0'\n&FREENUM(&FRCTR) SETA &FREENUM(&FRCTR)-1\n         AGO       .NEXT\n.LAST    DC        A(0),&FREELEN(&FRCTR)F'0'\n         AIF       (&FRCTR LT &FREECTR).MORE\n         MEND\nDATA     CSECT\nFRLIST1  FREEHDR   200,10\nFRLIST2  FREEHDR   75,3\n         FREEAREA\nMAIN     CSECT\n         XSAVE\n         L         11,=V(DATA)\n         USING     DATA,11\n         END\n$JOASSIST  MACRO=F\n         MACRO\n&LABEL   GETFREE   &FRHDR,&REG,&END\n&LABEL   L     &REG,&FRLIST1       GET POINTER TO TOP\n         LTR   &REG,&REG           IS LIST EMPTY\n         BZ    &END                YES, TAKE ERROR RETURN\n         MVC   &FRHDR(4),0(&REG)   NO,DELINK\n*        TOP CELL\n         MEND\n         MACRO\n&LABEL   PUTFREE   &FRHDR,&REG\n&LABEL   MVC   0(4,&REG),&FRHDR    RETURN NODE\n         ST    &REG,&FRHDR         NODE TO TOPE OF LIST\n         MEND\n         MACRO\n&LABEL   PUTNODE   &HDR,&REG,&KEY,\n&LABEL   PUTNODE   &HDR,&REG,&KEY=4,&KEYLEN=4,&LENGTH=0,&MSG=\n&LABEL   STM   1,3,PUT&SYSNDX.S    SAVE R1,R2,R3\n         LR    3,&EEG\n         LR    3,&REG              ADDR OF NODE TO BE ADDED\n         LA    1,&HDR              ADDR OF HEADER TO LINKED LIST\n         L     2,4(1)              GET CURRENT LENGTH COUNTER\n         LA    2,1(2)              ADD\n         LA    2,1(2)              ADD ONE TO CURRENT LENGTH COUNTER\n         ST    2,4(1)              SAVE UPDATED LENGTH COUNTER\n         C     2,8(1)              CONPARE CURRENT TO MAX LENGTH LIST\n         C\n         BNH   *+8\n         ST    2,8(1)              STRE\n         ST    2,8(1)              STORE NEW MAX LIST LENGTH\nPUT&SYSNDX.L   LR  2,1             TRAVERSE LIST\n         L     1,0(1)\n         LTR   1,1                 CHECK FOR END OF LIST\n         BZ    *+14\n         BZ    *+14                END, PUT NEW NODE HERE\n         CLC   &KEY(&KEYLENG\n         CLC   &KEY(&KEYLEN,1),&KEY(3)           SHOULD NEW NODE GO IN\n         BNH   PUT&SYSNDX.L        NOT YET\n\n         ST    1,0(3)              PUT IN NEW NODE\n         ST    3,0(2)\n         LR    5,3\n         LM    1,3,PUT&SYSNDX.S    RESTORE R1,R2,R3\n         MEND\n         MACRO\n&LABEL   DELETE    &HDR,&REG,&END,&LENGTH=0,&MSG=\n&LABEL   STM   1,3,DEL&SYSNDX.S    SAVE R1,R2,R3\n         LR    3,2                 NODE ADDR INTO REGISTER\n         L\n         LA    1,&HDR              ADDR OF HEADER TO LINKED LIST\nDEL&SYSNDX.L   LR  2,1             TRAVERSE LIST\n         6     1,0(1)              GET LINK\n         LTR   1,1                 CHECK FOR NULL LINK - END OF LIST\n         BZ    DEL&SYSNDX.M        ITEM NOT IN LIST\n         CR    1,3                 TEST LINKS\n         BNE   DEL&SYSNDX.L        TRY NEXT NODE\n         MVC   0(4,2),0(1)         GOT IT, NOW DELETE\n         LA    1,&HDR              HEADER ADDR\n         L     2,4(1)              LIST LENGTH\n         BCTR  2,0                 LENGTH=LENGTH-1\n         ST    2,4(1)\n         LM    1,3,DEL&SYSNDX.S    RESTORE R1-R3\n         B     DEL&SYSNDX.E        BRANCH AROUND DC\nDEL&SYSNDX.S   DC  3F'0'           REGISTER SAVE AREA\nDEL&SYSNDX.M   LM  1,3,DEL&SYSNDX.S    RESTORE REG\n         B     &END                ERROR RETURN\nDEL&SYSNDX.E   EQU *\n         MEND\n         MACRO\n&LABEL   POP   &HDR,&REG,&END,&LENGTH=0,&MSG=\n&LABEL   L     &REG,&HDR\n&LABEL   DELETE    &HDR,&REG,&END,LENGTH=&LENGTH,MSG=&MSG\n         MEND\n         MACRO\n&LABEL   FREEHDR   &NUMBER,&LENGTH\n         GBLA  &FREENUM(20),&FREELEN(20),&FREECTR\n         GBLB  &FREEOFF\n         AIF   (&FREEOFF).ERROR2\n         AIF   (&FREECTR GE 20).ERROR1\n&FREECTR SET   &FREECTR+1\n&LABEL   DC    A(FR&FREECTR)\n&FREENUM(&FREECTR) SETA      &NUMBER\n&FREELEN(&FREECTR) SETA      &LENGTH\n         MEXIT\n.ERROR1  MNOTE 8,'**MORE THAN 20 CALLS MADE ON FREEHDR**'\n&FREEOFF SETB  1\n         MEXIT\n.ERROR2  MNOTE *,'**FREEHDR HAS BEEN DISABLED**'\n         MEND\n         MACRO\n         FREEAREA\n         GBLA  &FREENUM(20),&FREELEN(20),&FREECTR,&FRCTR\n         AIF   (&FREECTR GT &FRCTR).MORE\n         MNOTE *,'**CALL TO FREEAREA RESULTED IN NO PROCESSING**'\n         MEXIT\n.MORE    ANOP\n&FRCTR   SETA  &FRCTR+1\nFR&FRCTR DC    0F\n.NEXT    AIF   (&FREENUM(&FRCTR) LE 1).LAST\n         DC    A(*+4*(&FREELEN(&FRCTR)+1)),&FREELEN(&FRCTR)F'0'\n&FREENUM(&FRCTR)   SETA      &FREENUM(&FRCTR)-1\n         AGO   .NEXT\n.LAST    DC    A(0),&FREELEN(&FRCTR)F'0'\n         AIF   (&FRCTR LT &FREECTR).MORE\n         MEND\n         MACRO\n&LABEL   LISTHDR\n&LABEL   DC    4F'0'\n         MEND\n         MACRO\n         SETGBL    &CATNO=1,&IONO=1,&NOTRACE=NO\n         GBLA  &CAT,&ION\n         GBLB  &NOTRAC\n&CAT     SETA  &CATNO\n&ION     SETA  &IONO\n&NOTRAC  SETB  0\n         AIF   ('&NOTRACE' EQ 'NO').DONE\n&NOTRAC  SETB  1\n.DONE    MEND\n         MACRO\n         LISTS\n         GBLA  &CAT,&ION\n.*             GENERATE LIST HEADERS\n         CRLISTS   CATHDR,&CAT\n         CRLISTS   IOQHDR,&ION\n         MEND\n         MACRO\n         CRLISTS   &PREFIX,&NUM\n         LCLA  &COUNT\n.MORE    ANOP\n&COUNT   SETA  &COUNT+1\n&PREFIX&COUNT  LISTHDR\n         AIF   (&COUNT LT &NUM).MORE\n         MEND\n         SETGBL\nDATA     CSECT\nEVQFR    FREEHDR   3,3\nDQFR     FREEHDR   18,3\n         LISTS\nRJQHDR   LISTHDR\nEVQHDR   LISTHDR\n         FREEAREA\nDQEL     DSECT\nDQLINK   DS    F\nDQKEY    DS    CL8\nEVQEL    DSECT\nEVQLINK  DS    F\nEVQKEY   DS    CL8\nTITLE    'TEST'\n         PRINT GEN\nTEST     CSECT\n         QSAVE ,                   OR WHAT HAVE (BR=12)\n         L     11,DATAADR\n         USING DATA,11\n         USING EVQEL,1\n         USING DQEL,3\n         GETFREE   EVQFR,1,ERROR\n         MVC   EVQKEY,EVENT1\n         PUTNODE   EVQHDR,1,KEYLEN=6,LENGTH=8\n         GETFREE   EVQFR,1,ERROR\n         MVC   EVQKEY,EVENT2\n         PUTNODE   EVQHDR,1,KEYLEN=6,LENGTH=8\n         GETFREE   EVQFR,1,ERROR\n         MVC   EVQKEY,EVENT1\n         PUTNODE   EVQHDR,1,KEYLEN=6,LENGTH=8\n         LR    2,1\n         GETFREE   EVQFR,1,UNDER1\n         B     ERROR\nUNDER1   XDUMP EVQHDR,16\n         DELETE    EVQHDR,2,ERROR,LENGTH=8\n         PUTFREE   EVQFR,2\n         DELETE    EVQHDR,2,OK\n         B     ERROR\nOK       GETFREE   EVQHDR,1,ERROR\n         MVC   EVQKEY,EVENT3\n         SETGBL    NOTRACE=YES\n         PUTNODE   EVQHDR,1,KEYLEN=6\n         SETGBL    NOTRACE=NO\nCONTINUE POP   EVQHDR,1,DONE,LENGTH=8\n         PUTFREE   EVQFR,1\n         B     CONTINUE\nDONE     LA    5,JQE1\nGETMORE  GETFREE   DQFR,3,UNDER2\n         MVC   DQKEY,0(5)\n         PUTNODE   CATHDR1,3,KEYLEN=2,LENGTH=8,MSG='CAT'\n         SETGBL    NOTRACE=YES\n         GETFREE   DQFR,3,ERROR\n         MVC   DQKEY,0(5)\n         PUTNODE   RJQHDR,3,KEY=6,KEYLEN=2\n         GETFREE   DQFR,3,ERROR\n         MVC   DQKEY,0(5)\n         PUTNODE   IOQHDR1,3,KEY=8,KEYLEN=2\n         LA    5,8(5)\n         B     GETMORE\n         SETGBL    NOTRACE=NO\nUNDER2   POP   CATHDR1,1,ALLDONE,LENGTH=8\n         POP   RJQHDR,1,ERROR,LENGTH=8\n         POP   IOQHDR1,1,ERROR,LENGTH=8\n         B     UNDER2\nERROR    XPRNT =CL6'0ERROR',6\nALLDONE  XDUMP CATHDR1,64\n         QRETURN   SA=*            OR WHAT HAVE YOU\nEVENT1   DC    F'5',H'1,2'\nEVENT2   DC    F'6',H'0,0'\nEVENT3   DC    F'5',H'0,0'\nJQE1     DC    H'1,2,3,1'\n         DC    H'2,3,1,2'\n         DC    H'3,1,2,3'\n         DC    H'3,2,1,4'\n         DC    H'2,1,3,5'\n         DC    H'1,3,2,6'\nDATAADR  DC    V(DATA)\n         END   TEST\n$JOASSIST  MACRO=F\n         MACRO\n&NAME    $TRT  &FIELD,&TAB,&LEN=15\n         SPACE 3\n.*\n.*       $TRT WILL\n.*       1)   DO A TRT STARTING AT &FIELD WHICH MAY BE ANY OPERAND\n.*       VALID AS SECOND OPERAND IN AN LA INSTRUCTION.\n.*       2)  THE NUMBER OF BYTES SCANNED WILL BE PLACED IN GPR 0.\n.*       3)    &TAB IS THE TABLE FOR THE TRT.\n.*       4)  THE NUMBER OF BYTES TO BE SCANNED IS IN THE REGISTER\n.*       SPECIFIED IN THE &LEN KEYWORD PARAMETER.  AFTER THE $TRT\n.*       THIS REGISTER WILL HAVE THE NUMBER OF BYTES NOT SCANNED.\n.*       5) THE CC , GPR 1, &GPR 2 HAVE THEIR USUAL VALUES AFTER A TRT.\n.*\n&NAME    STM   2,3,$TRT&SYSNDX-8   .      SAVE REGS\n         LA    3,&FIELD .          3 -> FIELD\n         LR    2,&LEN .            GET LENGTH\n         BCTR  2,0 .               SET FOR EXECUTE\n         B     $TRT&SYSNDX .       BR AROUND INST & SAVE AREA\n         CNOP  2,4 .               GET PROPER ALIGNMENT\n         TRT   0(0,3),&TAB .          ACT TRT\n         DS    2F .                SAVEAREA\n$TRT&SYSNDX EX 2,*-14 .            DO TRT\n         BNZ   *+18 .              NON ZERO TAB BYTES?\n         LR    0,&LEN .            NO\n         LA    &LEN,0 .            SET 0 AND &LEN TO PROPER VALS\n         LM    2,3,$TRT&SYSNDX-8 .       RESTORE REGS\n         B     *+22 .              DONE\n         STC   2,$TRT&SYSNDX-5 .      SAVE FUNCTION BYTE\n         BALR  2,0 .               SAVE CC\n         SR    3,1 .               COMPUTE -(LEN SCANNED)\n         LCR   0,3 .               LEN SCANNED\n         SR    &LEN,0 .            LEN REMAINING\n         SPM   2 .                 RESET CC\n         LM    2,3,$TRT&SYSNDX-8 .       SAVE REGS\n         SPACE 3\n         MEND\n         SPACE 5\n         MACRO\n&NAME    TRTAB &FILL,&TABLE=\n         LCLA  &N,&I,&K,&N1\n         LCLC  &A\n         SPACE 3\n&NAME    DC    256FL1'&FILL'\n&I       SETA  1\n&N       SETA  N'&TABLE\n         AIF   (&N/2*2 EQ &N).BACK\n         MNOTE 8,'ODD NUMBER OF ARGS FOR TABLE INVALID'\n.BACK    AIF   (&I GE &N).END\n&K       SETA  K'&TABLE(&I)\n         AIF   (&K EQ 1).NOTSPEC\n         AIF   ('&TABLE(&I)'(1,1)  NE  '@').STRING\n&K       SETA  &K-1\n&A       SETC  '&TABLE(&I)'(2,&K)\n         AIF   (&K GT 2).NOT2DIG\n         AIF   ('&A' EQ 'BL').BL\n         AIF   ('&A' EQ 'LP').LP\n         AIF   ('&A' EQ 'RP').RP\n         AIF   ('&A' EQ 'QT').QT\n         AGO   .INVALID\n.BL      ORG   &NAME+C' '\n         DC    FL1'&TABLE(&I+1)'\n         AGO   .BOT\n.LP      ORG   &NAME+C'('\n         DC    FL1'&TABLE(&I+1)'\n         AGO   .BOT\n.RP      ORG   &NAME+C')'\n         DC    FL1'&TABLE(&I+1)'\n.QT      ORG   &NAME+C''''\n         DC    FL1'&TABLE(&I+1)'\n         AGO   .BOT\n.NOT2DIG AIF   (&K GT 3).NOT3DIG\n         AIF   ('&A' EQ 'NUM').NUM\n         AIF   ('&A' EQ 'COM').COM\n         AIF   ('&A' EQ 'AMP').AMP\n         AGO   .INVALID\n.NUM     ORG   &NAME+C'0'\n         DC    10FL1'&TABLE(&I+1)'\n         AGO   .BOT\n.COM     ORG   &NAME+C','\n         DC    FL1'&TABLE(&I+1)'\n         AGO   .BOT\n.AMP     ORG   &NAME+C'&&'\n         DC    FL1'&TABLE(&I+1)'\n         AGO   .BOT\n.NOT3DIG AIF   ('&A' NE 'ALPHA').INVALID\n.ALPHA   ORG   &NAME+C'A'\n         DC    9FL1'&TABLE(&I+1)'\n         ORG   &NAME+C'J'\n         DC    9FL1'&TABLE(&I+1)'\n         ORG   &NAME+C'S'\n         DC    8FL1'&TABLE(&I+1)'\n         AGO   .BOT\n.STRING  ANOP\n&A       SETC  '&TABLE(&I)'(&K,1)\n         ORG   &NAME+C'&A'\n         DC    FL1'&TABLE(&I+1)'\n&K       SETA  &K-1\n         AIF   (&K GE 1).STRING\n         AGO   .BOT\n.NOTSPEC ORG &NAME+C'&TABLE(&I)'\n         DC    FL1'&TABLE(&I+1)'\n.BOT     ANOP\n&I       SETA  &I+2\n         AGO   .BACK\n.INVALID MNOTE 8,'INVALID KEYWORD OR MULTIPLE CHAR ARG IN LIST'\n         AGO   .BOT\n.END     ORG\n         SPACE 3\n         MEND\n         SPACE 5\n         MACRO\n         CALL  &NAME\n         CNOP  0,4\n         B     *+8\nI&SYSNDX DC    V(&NAME)\n         L     15,I&SYSNDX\n         BALR  14,15\n         MEND\n         SPACE 5\n         MACRO\n&NAME    XBACK\n         LCLA  &DISP,&N1,&N2,&N3,&N,&TEMP\n         SPACE 3\n&NAME    L     13,4(13)\n&N       SETA  N'&SYSLIST\n         AIF   (&N GT 0).BACK\n         L     14,12(13)\n         LM    2,12,28(13)\n.DONE    BR    14\n         LTORG\n         SPACE 3\n         MEXIT\n.BACK    ANOP\n&N1      SETA  &N1+1\n         AIF   (&N1 GT &N).DONE\n&N2      SETA  N'&SYSLIST(&N1)\n         AIF   (&N2 LE 0 OR &N2 GT 2).ERR1\n&TEMP    SETA  &SYSLIST(&N1,1)\n         AIF   (&TEMP LT 0 OR &TEMP GT 15).ERR2\n         AIF   (&TEMP LT 14).LOW\n&DISP    SETA  12+(&TEMP-14)*4\n         AGO   .X2\n.LOW     ANOP\n&DISP    SETA  20+&TEMP*4\n.X2      AIF   (&N2 EQ 2).A2\n         L     &TEMP,&DISP.(13)\n         AGO   .X3\n.A2      LM    &TEMP,&SYSLIST(&N1,2),&DISP.(13)\n.X3      ANOP\n&N2      SETA  0\n         AGO   .BACK\n.ERR1    MNOTE 8,'NUMBER OF ARGS IN SUBLIST MUST BE 1 OR 2'\n         MEXIT\n.ERR2    MNOTE 8,'REGISTER SPECIFICATION NOT BETWEEN 0 AND 16'\n         MEND\n         SPACE 5\n         MACRO\n&NAME    XGO   &ACONSA=,&ENTRY=\n         LCLA  &###DISP\n         LCLB  &ENT\n         SPACE 3\n         AIF   ('&ENTRY' EQ 'ENTRY').ENTER\n         AIF   ('&ACONSA' EQ '').X1\n&ENT     SETB  1\n&###DISP SETA  4\n.X1      TITLE '******** &NAME CSECT ***************************'\n&NAME    CSECT\n         B     14(0,15)\n         DC    X'09',CL9'&NAME '\n         STM   14,12,12(13)\n         LR    14,13\n         BAL   13,96+&###DISP.(15)\n         USING *,13\n         DC    18F'-1'\n         AIF   (NOT &ENT).BACK\n&ACONSA  DC    A(*-72)\n.BACK    ST    14,4(13)\n         ST    13,8(14)\n         L     14,12(14)\n         SPACE 3\n         MEXIT\n.ENTER   CNOP  0,4\n         TITLE '******** &NAME ENTRY ********************************'\n&NAME    DS    0H\n         ENTRY &NAME\n         B     0(0,15)\n         DC    X'09',CL9'&NAME '\n         STM   14,12,12(13)\n         LR    14,13\n         USING &SYSECT+24,13\n         L     13,28(15)\n         B     *+8\n&ACONSA  DC    A(&SYSECT+24)\n         AGO   .BACK\n         MEND\n         SPACE 5\n         PRINT ON\n         PRINT NOGEN\n***********************************************************************\n***********************************************************************\n*              THIS PROGRAM CONTAINS EVERYTHING REQUIRED  PLUS  THE\n*        ADDED FEATURES OF A LINKED CLASS FIELD AND NOTIFICATION OF A\n*        DELETION OR A MODIFICATION. LIST HEADS ARE USED FOR THE CODE2,\n*        CLASS, MAGIC NUMBER, AND THE SEX FIELDS.  THE ONLY LIMITATION\n*        IS THAT NON-BLANK FIELDS ARE ASSUMED FOR INITIAL READ IN. THIS\n*        PROGRAM HAS THE CAPABILITY TO LINK A FILE OF 200 CARDS, INDEX\n*        25 DIFFERENT CODE 2 AND CLASS FIELDS.  ALL ERRORS ARE DETECTED\n*        AND FLAGGED WITH ONLY THE SEVEREST CAUSING TERMINATION OF THE\n*        PROGRAM\n***********************************************************************\n***********************************************************************\nMAIN     XGO\n***********************************************************************\n******************* EQUATES REGISTERS TO SYMBOLIC NAMES ***************\n***********************************************************************\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nCONREG   EQU   12\nCLASSREG EQU   R4\nPOINTREG EQU   R5\nAVAILREG EQU   R6\nADVCDE2  EQU   R7\nNODELINK EQU   R8\nPREG     EQU   R9\nMAGNOREG EQU   R10\nCLASINFO EQU   2\nCLASSADD EQU   4\nCODEINF2 EQU   0\nCODELIK2 EQU   4\n***********************************************************************\n******************* SET UP A PSUEDO DSECT FOR SYMBOLIC  ***************\n*******************  ADDRESSING IN ASSIST                **************\n***********************************************************************\nNAMELINK EQU   0\nCODE2LL  EQU   4\nCODE2LR  EQU   8\nFSEXLINK EQU   12\nMSEXLINK EQU   16\nMAGNOL   EQU   20\nMAGNOR   EQU   24\nCLASSLIK EQU   28\nNAME     EQU   32\nSEX      EQU   51\nMAGNUM   EQU   52\nCLASS    EQU   61\nCODE1    EQU   63\nCODE2    EQU   68\n***********************************************************************\n*******************  INITIALLY CLEARS THE REGISTERS *******************\n***********************************************************************\n         SR    R0,R0\n         SR    R1,R1\n         SR    R2,R2\n         SR    R3,R3\n         SR    R4,R4\n         SR    R5,R5\n         SR    R6,R6\n         SR    R7,R7\n         SR    R8,R8\n         SR    R9,R9\n         SR    R10,R10\n         SR    R11,R11\n***********************************************************************\n         USING CONSTANT,CONREG,R11\n         L     CONREG,=V(CONSTANT)\n         LA    R11,4095(CONREG)\n         LA    R11,1(R11)\n         LA    POINTREG,LAMDA\n         LA    R3,LAVS\n         LA    PREG,P\n         LR    AVAILREG,R3\n         ST    POINTREG,PTR\n         ST    R3,AVAIL\n         MVC   P(4),LAMDA\n         MVI   STATFLAG,C'0'       INITIATIIZE STATE OF OPERATIONS FLAG\n***********************************************************************\n******************* LINKS AVAILABLE SPACE TOGETHER ********************\n***********************************************************************\nLINKLAVS CLC   0(3,R3),LAMDA\n          BE  INIREAD\n         LA    R3,72(R3)\n         ST    R3,LAVS(R4)\n         LA    R4,72(R4)\n         B     LINKLAVS\nINIREAD  XREAD CARD,80\n         MVI   FLAG,C'0'           RESET THE FLAG\n         CLC   CARD+1(5),STARS     LOOK FOR END OF DATA SET\n         BE    EOFPRINT            PRINT OUT THE LISTS\n***********************************************************************\n*******************  READS IN AND DETECTS OVERFLOW ********************\n*******************  AND EMPTY LIST TO SET LIST HEADS *****************\n***********************************************************************\nNAMEIN   CLC   LAMDA(4),AVAIL      SEE IF STORAGE IS EXHAUSTED\n         BE    OVERFLOW            IT IS, SO GO TO OVERFLOW\n         CLC   P(4),LAMDA          SEE IF THE LIST IS EMPTY\n         BE    LISTMT              IT IS,  SO GO TO LISTMT\n         MVC   AVAIL(4),NAMELINK(AVAILREG)   ADVANCE AVAIL\n         CALL  MOVER               INSERT INTO NODE FOR ADDING TO LIST\n         B     SEXFIND\n***********************************************************************\n*******************PRINTS LISTS FOR PARTS  A&B*************************\n***********************************************************************\nEOFPRINT EQU   *\n         XPRNT NAMEHEAD,124\n         XPRNT SPECNAME,133        PRINT THE SECOND HEADER\nEOFLOOP  EQU   *\n         MVC   FILES+11(19),NAME(PREG)\n         MVC   FILES+44(1),SEX(PREG)\n         MVC   FILES+61(9),MAGNUM(PREG)\n         MVC   FILES+86(2),CLASS(PREG)\n         MVC   FILES+102(5),CODE1(PREG)\n         MVC   FILES+121(3),CODE2(PREG)\n         L     PREG,NAMELINK(PREG)\n         C     PREG,P\n         BE    FINPRINT\n         XPRNT FILES,133           NOW PRINT THE SEPARATE FILES\n         B     EOFLOOP\nFINPRINT EQU   *\n         XPRNT FILES,133           PRINT ALL LISTS FORMED\n         XPRNT CD2HEAD,132         PRINT THE CODE2 HEADER\n         MVC   NAMEDUMP+1(39),BLANKS   CLEAR THE OUTPUT AREA\n         LA    NODELINK,HDCODE2+4\n         ST    NODELINK,STOREIN\n         L     NODELINK,HDCODE2+4\n         ST    NODELINK,NODLKST\nPRINTCD2 MVC   NAMEDUMP+1(19),NAME(NODELINK)     MOVE THE NAME IN\n         MVC   NAMEDUMP+36(3),CODE2(NODELINK)    MOVE THE CODE2 IN\n         XPRNT NAMEDUMP,40\n         CLC   NODLKST(4),CODE2LR(NODELINK)\n         BE    CREMENT\n         L     NODELINK,CODE2LR(NODELINK)\n         B     PRINTCD2\nCREMENT  L     NODELINK,STOREIN\n         LA    NODELINK,8(NODELINK)\n         ST    NODELINK,STOREIN\n         L     R2,STOREIN\n         MVC   NODLKST(4),0(R2)\n         CLC   0(4,NODELINK),ZEROS\n         BE    NOWEND\n         CLC   0(4,NODELINK),PLUSES\n         BE    NOWEND\n         CLC   0(4,NODELINK),MINUS\n         BE    CREMENT\n         L     NODELINK,0(NODELINK)\n         XPRNT =C'-',1\n         BNE   PRINTCD2\nNOWEND   EQU   *\n         XPRNT MAGHEAD,128         PRINT THE MAGIC # HEADING\n         L     NODELINK,HDMAGNO\n         MVC   NAMEDUMP+1(39),BLANKS   CLEAR THE OUTPUT AREA\nMAGPRINT MVC   NAMEDUMP+1(19),NAME(NODELINK)     MOVE NAME IN FOR OUTPT\n         MVC   NAMEDUMP+30(9),MAGNUM(NODELINK)   MOVE THE MAGIC # IN\n         XPRNT NAMEDUMP,40\n         CLC   MAGNOR(4,NODELINK),HDMAGNO\n         BE    MORE\n         L     NODELINK,MAGNOR(NODELINK)\n         B     MAGPRINT\nMORE     EQU   *\n         CLC   HDFSEX(4),LAMDA\n         BE    NOFEM\n         XPRNT FEMHEAD,132         PRINT THE FEMALE HEADING\n         MVC   NAMEDUMP+1(39),BLANKS             CLEAR THE OUTPUT AREA\n         L     NODELINK,HDFSEX\nFEMLOOP  MVC   NAMEDUMP+1(19),NAME(NODELINK)     MOVE THE NAME IN\n         MVC  NAMEDUMP+30(1),SEX(NODELINK)       MOVE THE SEX IN\n         XPRNT NAMEDUMP,40\n         CLC   FSEXLINK(4,NODELINK),LAMDA\n         BE    NOWMALE             GO TO PRINT THE MALE LIST\n         L     NODELINK,FSEXLINK(NODELINK)\n         B     FEMLOOP\nNOFEM    XPRNT NFEM,132\n         BE    NOWMALE             GO TO PRINT THE MALE LIST\nNOWMALE  EQU   *\n         CLC   HDMSEX,LAMDA        SEE IF THE LIST IS EMPTY\n         BE    NOMALE              IT IS EMPTY\n         XPRNT MALEHEAD,128        PRINT THE MALE HEADER\n         MVC   NAMEDUMP+1(39),BLANKS             CLEAR OUTPUT AREA\n         L     NODELINK,HDMSEX     SET THE INDEX REGISTER\nMALLOOP  MVC   NAMEDUMP+1(19),NAME(NODELINK)     MOVE THE NAME IN\n         MVC  NAMEDUMP+30(1),SEX(NODELINK)       MOVE THE SEX IN\n         XPRNT NAMEDUMP,40\n         CLC   MSEXLINK(4,NODELINK),LAMDA        SEE IF END OF LIST\n         BE    NWCLASS             NOW PRINT THE CLASS\n         L     NODELINK,MSEXLINK(NODELINK)       INCREMENT NODELINK REG\n         B     MALLOOP             CONTINUE\nNOMALE   XPRNT NMALE,131\n         BE    NWCLASS             NOW PRINT THE CLASS\nNWCLASS  EQU   *\n         XPRNT CLASHEAD,127\n         MVC   NAMEDUMP+1(39),BLANKS   CLEAR THE OUTPUT AREA\n         LA    CLASSREG,HDCLASS    RESET THE CLASS REGISTER FOR OUTPUT\nBIGCLOOP CLC   CLASINFO(6,CLASSREG),ZEROS        SEE IF DONE\n         BE    UPDATEER\n         CLC   0(8,CLASSREG),PLUSES              SEE IF DONE\n         BE    UPDATEER\n         L     NODELINK,CLASSADD(CLASSREG)       INITIALIZE REGISTER\nCLOOPRNT MVC   NAMEDUMP+1(19),NAME(NODELINK)     MOVE THE NAME IN\n         MVC   NAMEDUMP+31(2),CLASS(NODELINK)    MOVE THE CLASS IN\n         XPRNT NAMEDUMP,40\n         CLC   CLASSLIK(4,NODELINK),LAMDA\n         BE    UPCLASS\n         L     NODELINK,CLASSLIK(NODELINK)\n         B     CLOOPRNT\nUPCLASS  LA    CLASSREG,8(CLASSREG)\n         XPRNT =C'-',1             SPACE DOWN 3\n         B     BIGCLOOP\n***********************************************************************\n*******************FINAL PRINTER **************************************\n***********************************************************************\nFINALPTR EQU   *\n         L     NODELINK,HDFSEX     INITIALIZE THE REGISTER\n         MVC   NAMEDUMP+1(39),BLANKS\n         XPRNT FFEMPRIT,131        PRINT THE HEADER\nFFEMLOOP CLC   MAGNUM(9,NODELINK),FIVES          SEE IF MAGIC # > 5'S\n         BH    FEMFPRNT            >,  SET FLAG AND PRINT OUT\nFINCFIN  CLC   FSEXLINK(4,NODELINK),LAMDA        ALL GIRLS GONE ????\n         BE    CKFLAG              WERE THERE ANY\n         L     NODELINK,FSEXLINK(NODELINK)       INCREMENT REGISTER\n         B     FFEMLOOP            TRY AGAIN\nCKFLAG   CLI   FEMFLAG,C'0'        WAS THERE ANY\n         BE    NOCHICS             NO!!\n         BNE   NEXTFINA\nNOCHICS  XPRNT NOCHIC,131\n         B     NEXTFINA            NEXT FINAL OUTPUT\nFEMFPRNT MVI   FEMFLAG,C'1'        SET A FLAG\n         MVC   NAMEDUMP+1(19),NAME(NODELINK)     MOVE THE NAME IN\n         MVC   NAMEDUMP+22(1),SEX(NODELINK)      MOVE THE SEX IN\n         MVC   NAMEDUMP+30(9),MAGNUM(NODELINK)   MOVE THE MAGIC # IN\n         XPRNT NAMEDUMP,40\n         B     FINCFIN             SEE IF ANY MORE\nNEXTFINA EQU   *\n         MVI   FEMFLAG,C'0'        RESET THE FLAG\n         XPRNT FCLASOUT,132        PRINT THE HEADER\n         MVC   NAMEDUMP+1(39),BLANKS             CLEAR OUTPUT AREA\n         LA    CLASSREG,HDCLASS    INITIALIZE POINTER\nONEMT    CLC   CLASINFO(2,CLASSREG),SEVEN        > 07 ???\n         BH    NACLASSP            IF PRINT THE FILE\n         CLC   CLASINFO(6,CLASSREG),ZEROS        DONE ???\n         BE    CLFCHEC             SEE IF THERE WERE ANY\n         CLC   0(8,CLASSREG),PLUSES              DONE ?????\n         BE    CLFCHEC             WERE THERE ANY ???\n         LA    CLASSREG,8(CLASSREG)    INCREMENT CLASS POINTER\n         B     ONEMT               TRY AGAIN\nNACLASSP MVI   FEMFLAG,C'1'        SET A FLAG\n         L     NODELINK,CLASSADD(CLASSREG)       SET TO FIRST NODE\nINCREMLP MVC   NAMEDUMP+1(19),NAME(NODELINK)     MOVE NAME IN\n         MVC   NAMEDUMP+25(2),CLASS(NODELINK)    MOVE CLASS IN\n         XPRNT NAMEDUMP,40\n         CLC   CLASSLIK(4,NODELINK),LAMDA        LAST ONE ???\n         BE    LOOPCREM            GO BACK FOR MORE\n         L     NODELINK,CLASSLIK(NODELINK)       SET TO THE NEXT NODE\n         B     INCREMLP            GET NEXT ONE\nLOOPCREM LA    CLASSREG,8(CLASSREG)              INCREMENT LIST HEAD\n         B     ONEMT               LOOK AGAIN\nCLFCHEC  CLI   FEMFLAG,C'1'        WHERE THERE ANY ???\n         BL    PRNTERCL            NO, SO PRINT MESSAGE\n         B     STOP                FINISHED!!!!!!!!!!!!!!!!!!!\nPRNTERCL XPRNT NOCHIC,131\n         B     STOP                FINISHED !!!!!!!!!!!!!!!\n***********************************************************************\n*******************  BEGINNING OF PART B, INSERT, MODIFY **************\n*******************  AND DELETION FROM THE LIST          **************\n***********************************************************************\nUPDATEER EQU   *\nUPREAD   XREAD CARD,80\n         BNZ    FINALPTR           GO PRINT THE FINAL OUTPUT\n         SR    R2,R2               CLEAR REGISTER 2 FOR INDEX BRANCH\n         CLC   CARD+1(5),STARS     SEE IF END OF UPDATING OF FILE\n         BE    FPRINTND\n         MVC   FAKENODE(72),BLANKS CLEAR THE NODE FOR UPDATING\n***********************************************************************\n*******************  INDEX BRANCH TO TYPE OF OPERATION   **************\n***********************************************************************\n         TR    CARD+41(1),OPTAB    CHANGE LETTER INTO A NUMERIC\n         IC    R2,CARD+41          INSERT FOR INDEX BRANCH\n         B     *+0(R2)             INDEX BRANCH TO OPERATION\n         B     ADDER               GO TO ADD ROUTINE\n         B     DELETER             GO TO DELETE ROUTINE\n         B     MODFYER             GO TO MODIFY ROUTINE\n         B     DOWHAT              UNDEFINED OPERATION IS SPECIFIED\n***********************************************************************\n*******************  ADDITION PART OF PART B         ******************\n***********************************************************************\nADDER    EQU   *\n         MVI   STATFLAG,C'1'       SET TO ADD STATE\n         B     NAMEIN\n***********************************************************************\n*******************  DELETION PART WHICH IN CASE OF AN ****************\n*******************  EMPTY LIST BYPASSES ANY DELETION  ****************\n*******************  UNTIL THERE IS SOMETHING TO DELETE  **************\n******************** AND GIVES NOTIFICATION OF COMPLETE  **************\n******************** EMPTYING OF THE LIST                **************\n***********************************************************************\nDELETER  EQU   *\n         CLC   P,LAMDA             SEE IF EMPTY LIST\n         BE    UPREAD              LIST EMPTY, NO DELETIONS ALLOWED\n         L     PREG,P              RESET NEEDED REGISTERS\n         L     POINTREG,PTR\n         CALL  SAMENAME            FIND NODE = AND ONE BEFORE\n         CLI   DFFLAG,C'4'         CHECK TO SEE IF IN LIST\n         BE    UPREAD              NOT IN LIST SO GET NEXT CARD\n         L     R1,NMADSTOR         LOAD FOR PRINT OUT\n         MVC   NAMEDUMP+1(39),NAME(R1)\n         CLI   DFFLAG,C'2'         IS IT THE END NODE???\n         BE    PTCHANGE            YES\n         BH    SOLONG              LAST NODE, SO TELL HIM\n         CLI   DFFLAG,C'1'         SEE IF FIRST NODE\n         BE    PCHANGE             IF YES, GO TO PCHANGE\nCALLSTUF EQU   *\n         CALL  DNL                 NAME LINK DELETER\n         CALL  DSL                 SEX LINK DELETER\n         CALL  DM#L                MAGIC NUMBER DELETER\n         CALL  DCLASS              CLASS LINK DELETER\n         CALL  DC#2L               CODE2 LINK DELETER\n         B     INCLAVS             NOW INCREMENT AVAILABLE SPACE\n***********************************************************************\n*******************  CHANGES THE POSITION OF CRITICAL POINTERS ********\n***********************************************************************\nPCHANGE  L     PREG,NAMELINK(PREG) SET PREG TO NEXT NODE\n         ST    PREG,P              SAVE THIS ADDRESS\n         B     CALLSTUF            NOW DELETE\nPTCHANGE L     R2,TEMPNAME         SET R2 TO THE NODE\n         ST    PREG,NAMELINK(R2)   SET THE NEW FIRST\n         LR    POINTREG,R2         SET NEW END POINTER\n         ST    POINTREG,PTR        NOW SAVE IN PTR\n         B     CALLSTUF\nSOLONG   MVC   P,LAMDA             SET P TO EMPTY LIST\n         XPRNT STAR,133\n         XPRNT GOODBYE,131\n         XPRNT STAR,133\n         B     INCLAVS             DON'T DELETE, JUST INCREMENT\n***********************************************************************\n*******************  RETURNS THE NODES TO LAVS ************************\n***********************************************************************\nINCLAVS  L     NODELINK,NMADSTOR   SET NODELINK FOR RETURN TO LAVS\n         MVC   NAMELINK(4,NODELINK),AVAIL        SET NAMELINK TO AVAIL\n         ST    NODELINK,AVAIL      UPDATE AVAIL\n         XPRNT =CL26' THE FILE BEING DELETED IS',26\n         XPRNT NAMEDUMP,40\n         B     UPREAD              WHATS NEXT UPDATE\n***********************************************************************\n*******************  MODIFY SECTION WITH FEATURES OF NOTI- ************\n*******************  FICATION OF A BLANK MODIFY FIELD, AN  ************\n*******************  UNDEFINED MODIFY CODE, AND ATTEMPTED  ************\n*******************  MODIFICATION OF AN NONEXISTANT FILE   ************\n***********************************************************************\nMODFYER  EQU   *\n         ST    AVAILREG,AVADST     SAVE NEXT NODE LOCATION\n         SR    R2,R2               RECLEAR REGISTER 2 FOR INDEX BRANCH\n         CLC   CARD+49(19),BLANKS  SEE IF BLANK MOD FIELD\n         BE    FDBLANK             IF SO  PRINT MESSAGE AND LEAVE\n         TR    CARD+43(1),OPOP     TRANSLATE BYTE FOR BRANCH\n         IC    R2,CARD+43          INSERT FOR BRANCH\n         B     *+0(R2)             INDEX BRANCH\n         B     FDNAME              NAME MODIFICATION\n         B     FDSEX               SEX MODIFICATION\n         B     FDMAGNO             MAGIC # MODIFICATION\n         B     FDCLASS             CLASS MODIFICATION\n         B     FDCODE1             CODE1 MODIFICATION\n         B     FDCODE2             CODE2 MODIFICATION\n         B     FDERROR             INVALID MODIFICATION\nFDERROR  MVC   NAMEDUMP+1(19),CARD+1   GET READY FOR MESSAGE\n         XPRNT ERFIELD,131\n         XPRNT NAMEDUMP,20\n         XPRNT =C'-',1\n         B     UPREAD\nFDBLANK  MVC   NAMEDUMP+1(19),CARD+1\n         XPRNT ERBLANK,129\n         XPRNT NAMEDUMP,20\n         XPRNT =C'-',1\n         B     UPREAD\n***********************************************************************\n******************** MODIFIES THE NAME FIELD             **************\n***********************************************************************\nFDNAME   EQU   *\n         CALL  SAMENAME            FIND THE NODE WITH SAME NAME FIELD\n         CALL  DNL                 DELETE THE NAME\n         L     AVAILREG,NMADSTOR   SET AVAILREG TO NODE FOR SUBROUTINES\n         MVC   NAME(19,AVAILREG),CARD+49         INSERT NEW NAME\n         CALL  FINAPLAC            NOW LINK THE NEW NAME\n         B     MODBACK             GET READY TO LEAVE\n***********************************************************************\n******************** MODIFIES THE SEX FIELD              **************\n***********************************************************************\nFDSEX    EQU   *\n         CALL  SAMENAME            FIND THE NODE WITH SAME NAME FIELD\n         CALL  DSL                 DELETE THE SEX\n         L     AVAILREG,NMADSTOR   SET AVAILREG TO NODE FOR SUBROUTINES\n         MVC   SEX(1,AVAILREG),CARD+49           INSERT THE NEW SEX\n         CALL  SEXLINK             LINK THE NEW SEX TO THE LIST\n         B     MODBACK             GET READY TO LEAVE\n***********************************************************************\n******************** MODIFIES THE MAGIC NUMBER           **************\n***********************************************************************\nFDMAGNO  EQU   *\n         CALL  SAMENAME            FIND THE NODE WITH SAME NAME FIELD\n         CALL  DM#L                DELETE THE MAGIC NUMBER\n         L     AVAILREG,NMADSTOR   SET AVAILREG TO NODE FOR SUBROUTINES\n         MVC   MAGNUM(9,AVAILREG),CARD+49        INSERT THE NEW MAGIC #\n         CALL  MAG#LINK            NOW LINK IN THE NEW MAGIC NUMBER\n         B     MODBACK             GET READY TO LEAVE\n***********************************************************************\n******************** MODIFIES THE CLASS FIELD            **************\n***********************************************************************\nFDCLASS  EQU   *\n         CALL  SAMENAME            FIND THE NODE WITH SAME NAME FIELD\n         CALL  DCLASS              DELETE THE CLASS STANDING\n         L     AVAILREG,NMADSTOR   SET AVAILREG TO NODE FOR SUBROUTINES\n         MVC   CLASS(2,AVAILREG),CARD+49         INSERT THE NEW CLASS\n         CALL  CLASLINK            NOW LINK IT IN\n         B     MODBACK             GET READY TO LEAVE\n***********************************************************************\n******************** MODIFIES THE CODE1 FIELD            **************\n***********************************************************************\nFDCODE1  EQU   *\n         CALL  SAMENAME            FIND THE NODE WITH SAME NAME FIELD\n         L     AVAILREG,NMADSTOR   SET AVAILREG TO NODE FOR SUBROUTINES\n         MVC   CODE1(5,AVAILREG),CARD+49         INSERT THE NEW CODE1\n         B     MODBACK             GET READY TO LEAVE\n***********************************************************************\n******************** MODIFIES THE CODE2 FIELD            **************\n***********************************************************************\nFDCODE2  EQU   *\n         CALL  SAMENAME            FIND THE NODE WITH SAME NAME FIELD\n         CALL  DC#2L               DELETE THE CODE2 OF THE NODE\n         L     AVAILREG,NMADSTOR   SET AVAILREG TO NODE FOR SUBROUTINES\n         MVC   CODE2(3,AVAILREG),CARD+49         INSERT THE NEW CODE2\n         CALL  COD2LINK            LINK IT IN THE RIGHT PLACE\n         B     MODBACK             GET READY TO LEAVE\n***********************************************************************\n******************** PRINTS A MESSAGE TELLING OF MODIFICATION  ********\n***********************************************************************\nMODBACK  MVC   NAMEDUMP+1(39),NAME(AVAILREG)     MOVE IN FOR OUTPUT\n         XPRNT FDMOD,131           PRINT THE HEADING\n         XPRNT NAMEDUMP,40         PRINT THE FILE\n         L     AVAILREG,AVADST     RESET AVAILREG\n         B     UPREAD              GET THE NEXT CARD\nDOWHAT   EQU   *\n         MVC   NAMEDUMP+1(39),CARD MOVE THE NAME IN FOR ERROR MESSAGE\n         XPRNT WROP,131            PRINT ERROR MESSAGE\n         XPRNT NAMEDUMP,40\n         B     UPREAD              GET THE NEXT CARD\nFPRINTND XPRNT STAR,133            TO DRAW ONE'S ATTENTION TO THE MESS.\n         XPRNT STAR,133\n         XPRNT UPDFILE,131         PRINT AN UPDATE COMPLETION MESSAGE\n         XPRNT STAR,133\n         XPRNT STAR,133\n         B     EOFPRINT            PRINT THE UPDATED LISTS\nSTOP     DC    H'0'\n***********************************************************************\n***********************************************************************\n******************** INITIALIZES THE LINKS AND LIST HEADS IN A ********\n******************** COMPLETELY EMPTY LIST               **************\n***********************************************************************\nLISTMT   EQU   *\n         SR    CLASSREG,CLASSREG\n         MVC   P,AVAIL             EMPTY LIST,   INITIALIZE POINTERS\n         L     PREG,P\n         MVC   PTR,AVAIL\n         L     POINTREG,PTR\n         LR    NODELINK,AVAILREG\n         MVC   AVAIL(4),NAMELINK(POINTREG)         ADVANCE AVAIL\n         MVC   NAMELINK(4,AVAILREG),PTR          SET PTR TO FIRST NODE\n         MVC   NAME(19,AVAILREG),CARD+1          MOVE NAME IN\n         CLI   CARD+20,C'M'        CHECK FOR MALE SEX\n         BE    MALEMT              HE IS,  SO GO TO MALEMT\n         ST    NODELINK,HDFSEX     SHE ISN'T,  SO DO A FEMALE\n         MVC   FSEXLINK(4,AVAILREG),LAMDA        SET THE SEX LINK-LAMDA\n         MVI   SEX(AVAILREG),C'F'  PUT A F IN THE SEX FIELD\n         B     NUMBMT              NOW GO TO MAGIC NUMBER INSERTER\nMALEMT   ST    NODELINK,HDMSEX     STORE THE ADDRESS OF NODE\n         MVC   MSEXLINK(4,AVAILREG),LAMDA        SET SEXLINK TO LAMDA\n         MVI   SEX(AVAILREG),C'M'  SET SEX FIELD TO A M\nNUMBMT   ST    NODELINK,MAGNOR(AVAILREG)         SET DOUBLE LINKS\n         ST    NODELINK,MAGNOL(AVAILREG)\n         ST    AVAILREG,HDMAGNO    SAVE NODE'S ADDRESS\n         MVC   MAGNUM(9,AVAILREG),CARD+21        INSERT MAGIC NUMBER\nCLASSMT  LA    CLASSREG,HDCLASS\n         MVC   CLASS(2,AVAILREG),CARD+30         INSERT THE CLASS\n         MVC   CLASINFO(2,CLASSREG),CARD+30      PUT IN CLASS INDEX\n         ST    AVAILREG,CLASSADD(CLASSREG)       PUT ADDRESS IN INDEX\n         MVC   CLASSLIK(4,AVAILREG),LAMDA        SET NODE LINK TO LAMDA\nCODE1MT  MVC   CODE1(5,AVAILREG),CARD+32         INSERT THE CODE1\nCODE2MT  MVC   HDCODE2+1(3),CARD+37  PUT CODE2 IN CODE2 INDEX\n         LA    ADVCDE2,HDCODE2     PUT THE ADDRESS IN ADVANCE REGISTER\n         ST    NODELINK,CODE2LR(AVAILREG)        SET INITIAL LINKS\n         ST    NODELINK,CODE2LL(AVAILREG)\n         ST    NODELINK,CODELIK2(ADVCDE2)        PUT ADDRESS IN INDEX\n         MVC   CODE2(3,AVAILREG),CARD+37         PUT CODE2 IN NODE\n         LR    POINTREG,AVAILREG   UPDATE THE LINKAGE POINTERS\n         ST    POINTREG,PTR\n         L     AVAILREG,AVAIL\n         B     INIREAD             GET THE NEXT FILE\nOVERFLOW XPRNT NOROOM,126          PRINT ERROR MESSAGE\n         DC    H'0'                TERMINATE WITH A SOC-1\n***********************************************************************\nSEXFIND  EQU   *\n***********************************************************************\n******************** CALLS THE LINKING SUBROUTINES AND   **************\n******************** DETERMINES THE STATE OF OPERATION   **************\n***********************************************************************\n         CALL  FINAPLAC            LINK THE NAME FIELD\n         CLI   FLAG,C'1'           CHECK STATE OF FLAG\n         BE    INIREAD\n         L     PREG,P              RESET FRONT POINTER\n         L     POINTREG,PTR        RESET THE END OF LIST POINTER\n         CALL  SEXLINK             CALL MY SEX LINKER\n         CALL  MAG#LINK            CALL MY MAGIC NUMBER LINKER\n         CALL  CLASLINK            LINK THE CLASS FIELD\n         CALL  COD2LINK            CALL MY CODE2 LINKER\n         L     AVAILREG,AVAIL      UPDATE THE POINTERS AND REGISTERS\n         LA    ADVCDE2,HDCODE2     RESET ADVANCE REGISTER\n         CLI   STATFLAG,C'1'       SEE IF IN UPDATE STATE\n         BE    UPDATEER            YES,  SO GO TO UPDATE\n         B     INIREAD             GET THE NEXT CARD\n         LTORG\n***********************************************************************\nMOVER    XGO\n***********************************************************************\n*            INSERT ALL INFORMATION FROM THE CARD INTO STORAGE\n***********************************************************************\n         MVC   NAME(19,AVAILREG),CARD+1\n         MVC   SEX(1,AVAILREG),CARD+20\n         MVC   MAGNUM(9,AVAILREG),CARD+21\n         MVC   CLASS(2,AVAILREG),CARD+30\n         MVC   CODE1(5,AVAILREG),CARD+32\n         MVC   CODE2(3,AVAILREG),CARD+37\n         XBACK\n***********************************************************************\n***********************************************************************\n******************** LINKS THE NAME FIELD IN CIRCULAR LIST ************\n***********************************************************************\nFINAPLAC XGO\n         CLC   NAME(19,AVAILREG),NAME(POINTREG)   COMPARE THE NAMES\n         BE    OOPS                IF THEY ARE EQUAL, THEN DOUBLE ENTRY\n         BH    SETNALK\n         L     POINTREG,NAMELINK(POINTREG)       SET TO NEXT NODE\n         B     NWCHECK\nNWCHECK  EQU   *\n         CLC   NAME(19,AVAILREG),NAME(POINTREG)   COMPARE THE NAMES\n         BL    FIRST\n         B     INCRMNT\nINCRMNT  L     POINTREG,NAMELINK(POINTREG)       SET TO NEXT NODE\n         CLC   NAME(19,AVAILREG),NAME(POINTREG)   COMPARE THE NAMES\n         BL    BEFORE1             FIND THE PRECEEDING NAME NODE\n         B     INCRMNT\nBEFORE1  ST    POINTREG,TEMPNAME   SAVE THE NEXT NODE > ADDRESS\n         LR    POINTREG,PREG       SET POINTER TO THE BEGINNING OF LIST\nFOR1LOOP CLC   NAMELINK(4,POINTREG),TEMPNAME     FIND ONE BEFORE\n         BE    RESET               WHEN FOUND GO AND LINK IT\n         L     POINTREG,NAMELINK(POINTREG)       ADVANCE POINTER\n         B     FOR1LOOP            TRY AGAIN,  PLEASE\nFIRST    EQU   *\n         L     PREG,P              RESET THE FIRST POINTER\n         L     POINTREG,PTR        RESET THE POINTER REGISTER\n         ST    AVAILREG,NAMELINK(POINTREG)       LINK BETWEEN\n         ST    PREG,NAMELINK(AVAILREG)           LINK TO LAST FIRST\n         ST    AVAILREG,P          UPDATE THE FIRST POINTER\n         B     NAMEBACK            LEAVE\nRESET    MVC   NAMELINK(4,AVAILREG),NAMELINK(POINTREG)\n         ST    AVAILREG,NAMELINK(POINTREG)\n         B     NAMEBACK            LEAVE\nSETNALK  MVC   NAMELINK(4,AVAILREG),NAMELINK(POINTREG)\n         ST    AVAILREG,NAMELINK(POINTREG)\n         ST    AVAILREG,PTR\n         B     NAMEBACK\nOOPS     EQU   *\n         MVC   AGAINAME(19),CARD+1\n         XPRNT DOUBENTR,125\n         MVI   FLAG,C'1'           SET THE FLAG FOR DOUBENTRY\n         B     NAMEBACK            LEAVE\nSTORADD  ST    POINTREG,NMADSTOR\nNAMEBACK EQU   *\n         XBACK\n***********************************************************************\n******************** LINKS THE SEX FIELD IN A LIST  *******************\n***********************************************************************\nSEXLINK  XGO\n         LR    NODELINK,AVAILREG   SET NODELINK REGISTER FOR LINKING\n         CLI   SEX(AVAILREG),C'M'  IS IT A MALE ??\n         BE    CHCHDM              YES,  CHECK HDMSEX\n         CLI   SEX(AVAILREG),C'F'  SEE IF A FEMALE\n         BE    CHCHDF              YES IT IS\n         B     AWHAT               WHAT OR WHO IS IT???\nCHCHDM   CLC   HDMSEX,LAMDA        SEE IF FIRST MALE\n         BE    SETHDM              YES,  SO SET HDMSEX\n         L     R4,HDMSEX           NO,  SO LOAD THE ADDRESS INTO R4\n         LA    R4,MSEXLINK(R4)     SET R4 TO THE LINK OF THE NEXT MALE\nSEXLOOPM CLC   0(4,R4),LAMDA       FIND THE LAST MALE\n         BE    INSETMSX            FOUND SO LINK NEW ENTRY\n         L     R4,0(R4)            NOT FOUND--->UPDATE ADDRESS\n         LA    R4,MSEXLINK(R4)     SET R4 TO THE LINK OF THE NEXT MALE\n         B     SEXLOOPM            TRY AGAIN\nINSETMSX ST    NODELINK,0(R4)      LINK IN THE NEW ENTRY\n         MVC   MSEXLINK(4,NODELINK),LAMDA\n         B     SEXBACK             FINISHED SO LEAVE\nSETHDM   ST    NODELINK,HDMSEX     SET MALE INDEX\n         MVC   MSEXLINK(4,NODELINK),LAMDA        SET NODE LINK TO LAMDA\n         B     SEXBACK             FINISHED, SO LEAVE\nCHCHDF   CLC   HDFSEX,LAMDA        SEE IF FIRST FEMALE\n         BE    SETHDF              YES,  SET THE FEMALE INDEX\n         L     R4,HDFSEX           NO,  FIND THE LAST FEMALE\n         LA    R4,FSEXLINK(R4)     SET R4 TO THE LINK OF  NEXT FEMALE\nSEXLOOPF CLC   0(4,R4),LAMDA       IS THIS THE LAST FEMALE???\n         BE    INSETFSX            YES,,  INSERT AND LINK HER\n         L     R4,0(R4)            NOT FOUND--->UPDATE ADDRESS\n         LA    R4,FSEXLINK(R4)     SET R4 TO THE LINK OF NEXT FEMALE\n         B     SEXLOOPF            TRY AGAIN\nSETHDF   ST    NODELINK,HDFSEX     SET THE FEMALE SEX INDEX\n         MVC   FSEXLINK(4,NODELINK),LAMDA        SET NODE LINK TO LAMDA\n         B     SEXBACK             NOW LEAVE\nINSETFSX ST    NODELINK,0(R4)      SET LINK TO NEW FEMALE\n         MVC   FSEXLINK(4,NODELINK),LAMDA        SET HER LINK TO LAMDA\n         B     SEXBACK             LEAVE\nAWHAT    MVC   WHATSEX(19),NAME(AVAILREG)        MOVE THE NAME IN\n         XPRNT NOSEX,131\nSEXBACK  EQU   *\n         XBACK\n***********************************************************************\n******************** LINKS THE MAGIC NUMBER IN A DOUBLY  **************\n******************** LINKED CIRCULAR LIST                **************\n***********************************************************************\nMAG#LINK XGO\n         L     MAGNOREG,HDMAGNO    SET # REGISTER TO THE FIRST NUMBER\n         CLC   MAGNUM(9,AVAILREG),MAGNUM(MAGNOREG)    COMPARE 1ST ORDER\n         BL    NEWFIRST            LESS THAN,  GO TO NEWFIRST\n         B     MAGCHECK\nMAG#LOOP L     MAGNOREG,MAGNOR(MAGNOREG)         UPDATE ADDRESS\n         CLC   MAGNUM(9,AVAILREG),MAGNUM(MAGNOREG)   COMPARE FOR ORDER\n         BL    MAG#INST            IT <,  SO LINK AND INSERT\nMAGCHECK CLC   MAGNOR(4,MAGNOREG),HDMAGNO        SEE IF LAST ONE\n         BE    LASTONE\n         BNE   MAG#LOOP\nLASTONE  MVC   MAGNOR(4,AVAILREG),MAGNOR(MAGNOREG)\n         ST    MAGNOREG,MAGNOL(AVAILREG)\n         ST    AVAILREG,MAGNOR(MAGNOREG)\n         L     MAGNOREG,MAGNOR(AVAILREG)\n         ST    AVAILREG,MAGNOL(MAGNOREG)\n         B     MAG#OUT\nMAG#INST ST    MAGNOREG,MAGNOR(AVAILREG)\n         MVC   MAGNOL(4,AVAILREG),MAGNOL(MAGNOREG)\n         ST    AVAILREG,MAGNOL(MAGNOREG)              SET LINKS\n         L    MAGNOREG,MAGNOL(AVAILREG)\n         ST    AVAILREG,MAGNOR(MAGNOREG)\n         B     MAG#OUT             LEAVE\nNEWFIRST ST    AVAILREG,HDMAGNO    SET INDEX TO FIRST NUMBER\n         MVC   MAGNOL(4,AVAILREG),MAGNOL(MAGNOREG)\n         ST    MAGNOREG,MAGNOR(AVAILREG)\n         ST    AVAILREG,MAGNOL(MAGNOREG)\n         L     MAGNOREG,MAGNOL(AVAILREG)\n         ST    AVAILREG,MAGNOR(MAGNOREG)\n         B     MAG#OUT             LEAVE\nMAG#OUT  EQU   *\n         XBACK\n***********************************************************************\n******************** LINKS THE CLASS FIELD IN A LIST     **************\n***********************************************************************\nCLASLINK XGO\n         LA    CLASSREG,HDCLASS    RESET THE CLASS REGISTER\nCLASCHEC CLC   0(8,CLASSREG),PLUSES  SEE IF INDEX IS FULL\n         BE    NOCLASPE\n         CLC   0(8,CLASSREG),ZEROS   SEE IF EMPTY SPACE IS PRESENT\n         BE    INSTCLAS\n         CLC   CLASINFO(2,CLASSREG),CLASS(AVAILREG)     IS IT A OLD ONE\n         BE    NOWCLAIN            YES,  SO INSERT\n         LA    CLASSREG,8(CLASSREG)  INCREMENT CLASS REGISTER\n         B     CLASCHEC\nNOCLASPE MVC   CLASFILE(19),NAME(AVAILREG)       MOVE NAME INTO CLASFLE\n         XPRNT NCLASPCE,113\n         XPRNT CLASFILE+19,131\n         ST    AVAILREG,AVAIL      UNSET ADVANCED AVAIL\n         DC    H'0'                TERMINATE WITH A SOC---1\nINSTCLAS MVC   CLASINFO(2,CLASSREG),CLASS(AVAILREG)    PUT IN INDEX\n         ST    AVAILREG,CLASSADD(CLASSREG)       PUT ADDRESS IN INDEX\n         MVC   CLASSLIK(4,AVAILREG),LAMDA        SET NODE LINK TO LAMDA\n         B     CLASBACK            LEAVE\nNOWCLAIN L     R3,CLASSADD(CLASSREG)   INITIALIZE R3\nCLASLOOP CLC   CLASSLIK(4,R3),LAMDA              SEE IF LAST ONE\n         BE    EARCLASS            YES,  SO NOW INSERT\n         L     R3,CLASSLIK(R3)     UPDATE SEARCH ADDRESS\n         B     CLASLOOP            TRY AGAIN\nEARCLASS ST    AVAILREG,CLASSLIK(R3)   SET LAST NODE TO NEW NODE ADDRES\n         MVC   CLASSLIK(4,AVAILREG),LAMDA        SET NODE LINK TO LAMDA\n         B     CLASBACK            LEAVE\nCLASBACK EQU   *\n         XBACK\n***********************************************************************\n***********************************************************************\n******************** LINKS THE CODE2 FIELDS IN A DOUBLY  **************\n******************** LINKED CIRCULAR LIST                **************\n***********************************************************************\nCOD2LINK XGO\nCDECHECK CLC   1(3,ADVCDE2),PLUSES SEE IF CODE2 INDEX IS FULL\n         BE    NOSPACE             IT IS,  PRINT AN ERROR MESSAGE\n         CLC   1(3,ADVCDE2),ZEROS  IS IT A NEW CODE ?????\n         BE    INSTCOD2            YES,  SO INSERT IT IN THE INDEX\n         CLC   1(3,ADVCDE2),CODE2(AVAILREG)      IS IT A NEW CODE ??\n         BE    NOWINCD2            NO, SO PUT WITH OLD\n         LA    ADVCDE2,8(ADVCDE2)  KEEP LOOKING\n         B     CDECHECK\nNOSPACE  MVC   CD2FILE(19),NAME(AVAILREG)        MOVE FOR OUTPUT\n         XPRNT CD2SPACE,123\n         ST    AVAILREG,AVAIL      UNSET THE NEW AVAIL ADDRESS\n         DC    H'0'                TERMINATE WITH A SOC--1\nINSTCOD2 MVC   1(3,ADVCDE2),CODE2(AVAILREG)      PUT CODE2 IN INDEX\n         ST    AVAILREG,CODELIK2(ADVCDE2)        SET LINKS\n         ST    AVAILREG,CODE2LL(AVAILREG)\n         ST    AVAILREG,CODE2LR(AVAILREG)\n         B     CD#2OUT             LEAVE\nNOWINCD2 L     ADVCDE2,CODELIK2(ADVCDE2)         POINTS TO FIRST CODE2\n         ST    ADVCDE2,TEMPCOD2    STORE FOR COMPARISON\nCD2LOOP  CLC   TEMPCOD2,CODE2LR(ADVCDE2)         FIND LAST SIMILIAR CD2\n         BE    INCODE2             FOUND!!!!!\n         L     ADVCDE2,CODE2LR(ADVCDE2)          NO,  LOOK AGAIN\n         B     CD2LOOP\nINCODE2  EQU   *\n         MVC   CODE2LR(4,AVAILREG),CODE2LR(ADVCDE2)      SET LINKS\n         ST    AVAILREG,CODE2LR(ADVCDE2)\n         ST    ADVCDE2,CODE2LL(AVAILREG)\n         L     ADVCDE2,TEMPCOD2    RESET CODE2 INDEX REGISTER\n         ST    AVAILREG,CODE2LL(ADVCDE2)\n         B     CD#2OUT             LEAVE\nCD#2OUT  EQU   *\n         XBACK\n***********************************************************************\n***********************************************************************\n******************** FINDS THE SAME NAME AND THE ONE     **************\n******************** BEFORE FOR DELETION OR MODIFICATION  *************\n***********************************************************************\nSAMENAME XGO\n         LA    AVAILREG,FAKENODE   SET AVAILREG TO FAKE NODE ADDRESS\n         MVC   NAME(19,AVAILREG),CARD+1          MOVE NAME ITO FAKE NOD\n         LR    NODELINK,PREG       SET NODELINK TO FIRST NODE IN LIST\n         CR    PREG,POINTREG       SEE IF LAST NODE\n         BE    LASTNODE            YES IT IS\nSAMELOOP CLC   NAME(19,AVAILREG),NAME(NODELINK)\n         BE    CHEKPT              IF =,CHECK FOR POSITION IN LIST\n         L     NODELINK,NAMELINK(NODELINK)       NOT =, SO COMPARE NEXT\n         CR    PREG,NODELINK       IS IT IN THE LIST??\n         BE    AHA                 NO IT IS NOT IN THE LIST\n         B     SAMELOOP            COMPARE AGAIN\nCHEKPT   ST    NODELINK,NMADSTOR   SAVE THE ADDRESS OF THE NODE-EQUAL\n         CR    PREG,NODELINK       IS IT THE FIRST NODE ??\n         BE    DELFIRST            YES\n         CR    POINTREG,NODELINK   IS IT THE LAST NODE??\n         BE    DELELAST            YES\n         B     FINDBFOR            NO SPECIAL POSITION SO JUST FIND 1B4\nFINDBFOR L     NODELINK,NAMELINK(NODELINK)     TRY NEXT NODE\n         CLC   NAMELINK(4,NODELINK),NMADSTOR      SEE IF ONE B4\n         BE    BEFOUND             THIS IS THE ONE!!\n         B     FINDBFOR            TRY AGAIN\nDELFIRST MVI   DFFLAG,C'1'         SET A FLAG\n         B     SAMEBACK            LEAVE\nDELELAST MVI   DFFLAG,C'2'         SET FLAG AND FIND ONE BEFORE\n         B     FINDBFOR\nLASTNODE ST    NODELINK,NMADSTOR   SAVE ADDRESS\n         MVI   DFFLAG,C'3'         SET FLAG\n         B     SAMEBACK            LEAVE\nBEFOUND  ST    NODELINK,TEMPNAME   SAVE ADDRESS OF NODE BEFORE\n         B     SAMEBACK            LEAVE\nAHA      MVC   MICFIN(19),NAME(AVAILREG)\n         XPRNT NOFILE,133          PRINT MESSAGE OF NOT IN LIST\n         MVI   DFFLAG,C'4'         SET FLAG\nSAMEBACK EQU   *\n         XBACK\n***********************************************************************\n******************** DELETES THE NAME FIELD               *************\n***********************************************************************\nDNL      XGO\n         L     NODELINK,TEMPNAME   SET TO NAME B4\n         L     R4,NMADSTOR         SET TO THE NODE\n         MVC   NAMELINK(4,NODELINK),NAMELINK(R4)     DELETE THE NAME\n         XBACK\n***********************************************************************\n******************** DELETES THE SEX FIELD               **************\n***********************************************************************\nDSL      XGO\n         L     NODELINK,NMADSTOR   SET TO THE NODE\n         CLI   SEX(NODELINK),C'M'  SEE IF A MALE\n         BE    DM                  YES, SO WORK ON MALE LIST\n         L     R4,HDFSEX           NO SO IT IS A FEMALE\nCFSEX    CR    R4,NODELINK         IS SHE THE LAST FEMALE??\n         BE    CHECKITF            SEE IF LAST NODE IN SUBLIST\n         C     NODELINK,FSEXLINK(R4)   SEE IF THE END FEMALE\n         BE    LINKARF             YES, DELINK HER\n         L     R4,FSEXLINK(R4)     NO, SO TRY NEXT LINKED NODE\n         B     CFSEX               TRY AGAIN\nDM       L     R4,HDMSEX           SET TO ADDRESS IN LIST HEAD\n         CR    NODELINK,R4         SEE IF LAST MALE\n         BE    CHECKITM            IS IT THE LAST 1 IN SUBLIST ???\nCMSEX    C     NODELINK,MSEXLINK(R4)         SEE IF END MALE\n         BE    LINKARM             YES!!\n         L     R4,MSEXLINK(R4)     NO---SET R4 TO NEXT LINKED MALE\n         B     CMSEX               TRY AGAIN\nLINKARM  MVC   MSEXLINK(4,R4),MSEXLINK(NODELINK)   LINK AROUND\n         B     DSLBACK\nTHATSITF MVC   HDFSEX,LAMDA\n         B     DSLBACK\nTHATSITM MVC   HDMSEX,LAMDA        SET LIST HEAD TO LAMDA\n         B     DSLBACK\nCHECKITF CLC   FSEXLINK(4,NODELINK),LAMDA        LAST ONE ???\n         BE    THATSITF            YES SO SET HDFSEX TO LAMDA\n         MVC   HDFSEX(4),FSEXLINK(NODELINK)      NO SO SET THIS IN HDFS\n         B     LINKARF             NOW DELETE\nCHECKITM CLC   MSEXLINK(4,NODELINK),LAMDA        SEE IF LAST ONE\n         BE    THATSITM\n         MVC   HDMSEX(4),MSEXLINK(NODELINK)      SO SET THE MALE LIST H\n         B     LINKARM             NOW DELETE\nLINKARF  MVC   FSEXLINK(4,R4),FSEXLINK(NODELINK)    LINK AROUND\nDSLBACK  XBACK\n***********************************************************************\n******************** DELETES THE MAGIC NUMBER FIELD      **************\n***********************************************************************\nDM#L     XGO\n         L     R4,NMADSTOR         SET TO NODE\n         L     NODELINK,NMADSTOR   ALSO SET TO THE NODE\n         L     NODELINK,MAGNOR(NODELINK)         SET TO THE RIGHT LINK\n         L     R4,MAGNOL(R4)       SET TO THE LEFT LINK\n         CLC   HDMAGNO(4),NMADSTOR SEE IF FIRST ONE\n         BE    SETHDMAG            YES,  SO SET HDMAGNO\nSETML    ST    NODELINK,MAGNOR(R4) LINK AROUND\n         ST    R4,MAGNOL(NODELINK) LINK AROUND\n         B     DM#LBACK\nSETHDMAG ST    NODELINK,HDMAGNO    SET THE MAGIC # LIST HEAD\n         B     SETML               NOW DELETE\nDM#LBACK EQU   *\n         XBACK\n***********************************************************************\n******************** DELETES THE CLASS FIELD             **************\n***********************************************************************\nDCLASS   XGO\n         L     NODELINK,NMADSTOR   SET TO THE NODE\n         LA    R4,HDCLASS+2        SET R4 TO INFO FEILD OF CLASS HEAD\nDCLASLOP LR    R3,R4               SAVE FOR LATER\n         CLC   CLASS(2,NODELINK),0(R4)           SEE IF OF SAME CLASS\n         BE    NOWTLINK            IF OF SAME CLASS , THEN FIND NODE\n         LA    R4,8(R4)            SET TO NEXT CLASS FIELD\n         B     DCLASLOP\nNOWTLINK L     R4,2(R4)            SET TO THE ADDRESS OF FIRST CLNODE\n         CR    R4,NODELINK         SEE IF LAST ONE\n         BE    CHECKITC            SEE IF LAST ONE LEFT\nDLINLOOP C     NODELINK,CLASSLIK(R4)     IS THIS THE NODE BEFORE???\n         BE    LINKARC             IF YES, THEN LINK AROUND\n         L     R4,CLASSLIK(R4)     NO, SO TRY NEXT LINKED NODE\n         B     DLINLOOP            TRY AGAIN\nTHATSALL MVC   0(6,R3),ZEROS       RESET CLASS LIST HEAD\n         B     DC#LBACK            NOW LEAVE\nCHECKITC CLC   CLASSLIK(4,NODELINK),LAMDA        IS IT THE LAST ONE\n         BE    THATSALL            YES IT IS THE LAST ONE OF THIS CLASS\n         MVC   2(4,R3),CLASSLIK(NODELINK)        UPDATE THE CLASS INDEX\nLINKARC  MVC   CLASSLIK(4,R4),CLASSLIK(NODELINK)     LINK AROUND\nDC#LBACK EQU   *\n         XBACK\n***********************************************************************\n******************** DELETES THE CODE2 FIELD             **************\n***********************************************************************\nDC#2L    XGO\n         LA    R4,HDCODE2+1        SET TO INFO FIELD OF CODE2 INDEX\n         L     NODELINK,NMADSTOR   SET TO THE NODE\nFINDCD#2 CLC   CODE2(3,NODELINK),0(R4)           SEE IF OF SAME CODE2\n         BE    CD#FOUND            YES,? THEN FIND LINK\n         LA    R4,8(R4)            SEE IF IT IS THE NEXT ONE\n         LR    R3,R4               SAVE FOR LATER\n         B     FINDCD#2\nCD#FOUND L     R4,3(R4)            LOAD THE FIRST SIMILAR ADDRESS IN R4\n         CR    R4,NODELINK         SEE IF LAST ONE\n         BE    CHECKC#2            SEE IF THE LAST ONE IN SUBLIST\n         LR    R4,NODELINK         SET R4\n         L     NODELINK,CODE2LR(NODELINK)        LINK AROUND\n         L     R4,CODE2LL(R4)\n         ST    NODELINK,CODE2LR(R4)    SET LINKS AROUND\n         ST    R4,CODE2LL(NODELINK)    SET LINKS AROUND\n         B     C#2LBACK            LEAVE\nCHECKC#2 CLC   3(4,R3),CODE2LR(NODELINK)         IS IT THE LAST ONE\n         BE    THATACD2            YES?  GO SET LIST HEAD\n         MVC   3(4,R3),CODE2LR(NODELINK)         UPDATE THE LIST HEAD\n         B     C#2LBACK\nTHATACD2 MVC   0(7,R3),MINUS       RESET THE LIST HEAD TO THE NULL LINK\nC#2LBACK EQU   *\n         XBACK\n***********************************************************************\nCONSTANT CSECT\nOPTAB    TRTAB 16,TABLE=(A,4,D,8,M,12)\nOPOP     TRTAB 28,TABLE=(1,4,2,8,3,12,4,16,5,20,6,24)\nFEMFLAG  DC    C'0'\nDFFLAG   DC    C'0'\nSTATFLAG DS    C\nFLAG     DS    C\nBLANKS   DC    CL72' '\nLAMDA    DC    CL10'-1-1-1-1-1'\nSTARS    DC    CL19'*******************'\nMINUS    DC    CL8'--------'\nPLUSES   DC    CL8'++++++++'\nCD2HEAD  DC    C'1',49C'*',CL33'THE LIST OF SIMILIAR CODE2 FIELDS',49C'1\n               *'\nMAGHEAD  DC    C'1',38C'*',CL53'THE LIST ACCORDING TO MAGIC NUMBER IN A1\n               SCENDING ORDER',38C'*'\nFEMHEAD  DC    C'1',47C'*',CL35'THE LIST OF ALL FEMALES IN THE FILE',491\n               C'*'\nNFEM     DC    C'2',44C'/',CL43'THE LIST OF FEMALES ON FILE IS NONEXIST1\n               ANT',44C'/'\nMALEHEAD DC    C'1',47C'*',CL33'THE LIST OF ALL MALES IN THE FILE',47C'1\n               *'\nNMALE    DC    C'2',45C'/',CL40'THE LIST OF MALES ON FILE IN NONEXISTAN1\n               TANT',45C'/'\nCLASHEAD DC    C'1',40C'*',CL46'THE LIST OF PEOPLE WITH IDENTICAL CLASS1\n                FIELDS',40C'*'\nNAMEHEAD DC    C'1',40C'*',CL43'THE LIST IN ALPHABETICAL ORDER BY LAST 1\n               NAME',40C'*'\nNAMEDUMP DC    C'0'\n         DS    CL39\nSPECNAME DC    C'0',17C' ',CL4'NAME',21C' ',CL3'SEX',13C' '\n         DC    CL12'MAGIC NUMBER',13C' ',CL5'CLASS',13C' ',CL5'CODE1',11\n               3C' ',CL5'CODE2',15C' '\nFILES    DC    133C' '\nDOUBENTR DC    C'+',5C'/',CL11'THE FILE OF',3C' '\nAGAINAME DS    CL19\n         DC    3C' ',CL56'IS ALREADY IN THE ORIGINAL FILE SO IT HAS NOT1\n                BEEN ADDED',8C'*',CL15'CHECK YOUR DATA',7C'*'\nNCLASPCE DC    C'0',10C'*',CL81'THE SPACE FOR CLASS INDEXING IS EXHAUST1\n               ED, THE FILE BEING READ IN AT OVERFLOW WAS',3C' '\nCLASFILE DS    CL19\n         DC    C' ',40C'*',CL50'PROBABLE CAUSE---CLASS IN DATA OTHER TH1\n               AN 01--->13',40C'*'\nCD2SPACE DC    C'1',10C'*',CL93'THE SPACE FOR CODE2 INDEXING IS EXHAUST1\n               ED, THE FILE BEING READ IN AT THE TIME OF OVERFLOW WAS'\nCD2FILE  DS    CL19\n         DC    8C'*'\nNOROOM   DC    C' ',20C'*',CL5'ERROR',15C'*',CL50'THOU LAVS RUNNETH OVE1\n               R AVAILABLE ALLOCATED STORAGE',35C'*'\nNOSEX    DC    C'2',15C'/',CL24'THE PERSON WHOSE NAME IS',3C' '\nWHATSEX  DS    CL19\n         DC    3C' ',CL70'IS OF THE NEUTER SEX, THEREFORE HAS NOT BEEN 1\n               ADDED TO THE ORIGINAL LIST',15C'/'\nNOFILE   DC    C'2',24C'?',CL11'THE FILE OF',3C' '\nMICFIN   DS    CL19\n         DC    3C' ',CL48'CAN NOT BE DELETED BECAUSE IT IS NOT IN THE L1\n               IST',24C'?'\nGOODBYE  DC    48C' ',CL36'THE LIST HAS BEEN EMPTIED COMPLETELY',47C' '\nERFIELD  DC    C' ',CL5'ERROR',7C'-',CL79'THE FOLLOWING FILE TO BE MODI1\n               FIED CONTAINS AN INVALID FIELD MODIFICATION NUMBER',5C'*2\n               ',CL27'THIS CARD HAS BEEN BYPASSED',6C'-'\nERBLANK  DC    C' ',25C'*',CL5'ERROR',3C'-',CL70'THE FOLLOWING FILE HAS1\n                BEEN BYPASSED DUE TO A BLANK MODIFICATION FIELD',25C'*'\nFDMOD    DC    C'-',25C'*',CL24'THE FILE NOW MODIFIED IS',81C'*'\nWROP     DC    C'2',17C'/',CL5'ERROR',3C'-',CL88'AN UNDEFINED OPERATION1\n                WAS SPECIFIED IN COL. 42, THE CARD THAT FOLLOWS HAS BEE2\n               N BYPASSED',17C'/'\nUPDFILE  DC    C'0',35C' ',CL60'THE UPDATING AND MODIFICATION OF THE LI1\n               ST HAS BEEN COMPLETED',35C' '\nFCLASOUT DC    C'1',35C'*',CL66'THE FOLLOWING LIST CONTAINS PERSONS WHO1\n               SE CLASS IS GREATER THAN 07',30C'*'\nNOCHIC   DC    C'0',56C'!',CL18'THIS LIST IS EMPTY',56C'!'\nFFEMPRIT DC    C'1',25C'*',CL69'THE FOLLOWING LIST CONTAINS ALL GIRLS W1\n               ITH MAGIC NUMBERS GREATER THAN',3C' ',9C'5',25C'*'\nSTAR     DC    C' ',132C'*'\nZEROS    DC    CL10'0000000000'\nFAKENODE DC    CL72' '\nSEVEN    DC    CL2'07'\nFIVES    DC    CL9'555555555'\n         DS    0F\nNODLKST  DC    CL4'0000'\nSTOREIN  DC    CL4'0000'\nHDMAGNO  DC    CL4'-1-1'\nHDFSEX   DC    CL4'-1-1'\nHDMSEX   DC    CL4'-1-1'\nHDCLASS  DC    25CL8'00000000'\n         DC    CL8'++++++++'\nHDCODE2  DC    25CL8'00000000'\nHDCODEND DC    CL8'++++++++'\nCARD     DS    CL80\nP        DS    CL4\nPTR      DC    CL4'0000'\nAVAIL    DC    CL4'0000'\nTEMPCOD2 DS    F\nAVADST   DC    CL4'0000'\nNMADSTOR DC    CL4'0000'\nTEMPNAME DC    CL4'0000'\nLAVS     DC    200CL72' '\n         DC    CL10'-1-1-1-1-1'\n         END\n$ENTRY\n6HADDEN JOHN DANIEL M226621106GRCMPSCS25CMPSCS25404 01             33570\n6HELSEL BARBARA JEANF16242231309CMPSCS25CMPSCS25404 01             33570\n6QUAMMEN GERALD A   M19940708508CMPSCS25CMPSCS25404 01             33570\n6RUSSONIELLO VINCENTM17842659008CMPSCS25CMPSCS25404 01             33570\n6HICKS ROBERT W     M19036492309CMPSCS25CMPSCS25404 01             33570\n6HOLZER PAUL LOUIS  M17038543507CMPSCS25CMPSCS25404 01             33570\n6HOSTETLER CLETUS L M280267240GRCMPSCS25CMPSCS25404 01             33570\n6SCHOKA ANDREW M    M157302377GRN DEGY30CMPSCS25404 01             33570\n6SEIFRIT GEORGE EARLM20038844410CMPSCS25CMPSCS25404 01             33570\n6TURNBULL MICHAEL G M17638198509CMPSCS25CMPSCS25404 01             33570\n6WARRICK THOMAS R   M178407063GRCMPSCS25CMPSCS25404 01             33570\n6WEISSER PAUL T     M20442083508CMPSCS25CMPSCS25404 01             33570\n6WEISBERG ARVIN MILEM16440250809CMPSCS25CMPSCS25404 01             33570\n6RIGHI EARL THOMAS JM20840146308CMPSCS25CMPSCS25404 01             33570\n6JOHN RHYS DAVID    M19038036109CMPSCS25CMPSCS25404 01             33570\n6COPE CLARENCE GILL M18140918308CMPSCS25CMPSCS25404 01             33570\n6DIGGINS CHARLES F  M19242162708CMPSCS25CMPSCS25404 01             33570\n6ELLIOTT WILLIAM IIIM080320606GRCMPSCS25CMPSCS25404 01             33570\n6HUNDY MICHAEL J    M172328223AEADJ  Y05CMPSCS25404 01             33570\n6RIVELL RICHARD     M14036301710CMPSCS25CMPSCS25404 01             33570\n6LANGE BETTYLOU     F053403527GRCMPSCS25CMPSCS25404 01             33570\n6CLARK RICHARD A    M329383268GRCMPSCS25CMPSCS25404 01             33570\n6MOON BYRON JOHN II M18640627609CMPSCS25CMPSCS25404 01             33570\n6BANGE CLAIR JOHN JRM174365058GRCMPSCS25CMPSCS25404 01             33570\n6NELSON KEVIN ERIK  M18138124008CMPSCS25CMPSCS25404 01             33570\n6KALIN RICHARD STUARM479408587GRCMPSCS25CMPSCS25404 01             33570\n6MULLAN KATHLEEN K  F17242864808CMPSCS25CMPSCS25404 01             33570\n6AUKER CHARLES W    M189360098UESC   S90CMPSCS25404 01             33570\n6TILEY JANE LOUISE  F04838578908CMPSCS25CMPSCS25404 01             33570\n6NICKESON KENNETH E M18442360908CMPSCS25CMPSCS25404 01             33570\n6COCHRAN JOHN L     M17442164008CMPSCS25CMPSCS25404 01             33570\n6STEWART BARBARA JEAF17042446211MATH S30CMPSCS25404 01             33570\n6RAPHAEL BARRY S    M046346440ADADJ  Y05CMPSCS25404 01             33570\n6CARELLI DENNIS JOHNM16042669808CMPSCS25CMPSCS25404 01             33570\n6NAPOLEON FRANK L   M19240483308CMPSCS25CMPSCS25404 01             33570\n6MILFORD MARK TERENCM20338549008CMPSCS25CMPSCS25404 01             33570\n6CATON ROBERT GEORGEM16242355511CMPSCS25CMPSCS25404 01             33570\n6SKERCHOCK JOHN A   M16442239911CMPSCS25CMPSCS25404 01             33570\n6STALTER IRA A JR   M184366253GRCMPSCS25CMPSCS25404 01             33570\n6STOCKMAN GEORGE C  M191348516GRCMPSCS25CMPSCS25404 01             33570\n6EDGAR LUCINDA ANN  F208367961AEADJ  Y05CMPSCS25404 01             33570\n6BECKER THOMAS JOSEPM18340977508CMPSCS25CMPSCS25404 01             33570\n6LEARMONT ELIZABETH F392463876GRCMPSCS25CMPSCS25404 01             33570\n6EICHHOLTZ ROBERT JRM18838547008CMPSCS25CMPSCS25404 01             33570\n6LINZ PAUL RICHARD  M19336714513SOC  L92CMPSCS25404 01             33570\n6KENEPP PAUL L      M185303508GECMPSCS25CMPSCS25404 01             33570\n6WILSON DEBORAH     F20738510909CMPSCS25CMPSCS25404 01             33570\n6BLACK SANDRA       F18638210910ADVT L01CMPSCS25404 01             33570\n6MACEYUNAS PAUL J   M041389959GRCMPSCS25CMPSCS25404 01             33570\n6BLAKE WILLIAM C    M48158304106E E  G25CMPSCS25404 01             33570\n6MAGILL DONALD RAY  M20530675810CMPSCS25CMPSCS25404 01             33570\n6MAURER THOMAS A    M210369617GRCMPSCS25CMPSCS25404 01             33570\n6MC CALL KEITH R    M18142569105CMPSCS25CMPSCS25404 01             33570\n6STUMP WILLIAM HUNTEM17742909608CMPSCS25CMPSCS25404 01             33570\n6BRONG DOUGLAS G    M20340141012COUN T01CMPSCS25404 01             33570\n6THOMAS GREGORY DALEM17040925808CMPSCS25CMPSCS25404 01             33570\n6BENNETT IAN G      M264864999AEADJ  Y05CMPSCS25404 01             33570\n6LIPP H ANNE        F18638242907CMPSCS25CMPSCS25404 01             33570\n6BLACK KARL DEAN    M523502468GRCD FRJ01CMPSCS25404 01             33570\n6BLUNT CHARLES R    M579466035GECMPSCS25CMPSCS25404 01             33570\n6OLIVIERI LAURA A   F05138716208CMPSCS25CMPSCS25404 01             33570\n6LYLE THOMAS JOSEPH M16242982508CMPSCS25CMPSCS25404 01             33570\n6PAULHAMUS RICHARD EM183407013GRCMPSCS25CMPSCS25404 01             33570\n6PEARSON MARY WINDERF223721061GRCMPSCS25CMPSCS25404 01             33570\n6ELSTON JAY COLLIN  M19436461908CMPSCS25CMPSCS25404 01             33570\n6FRY STANLEY B      M161422090AEADJ  Y05CMPSCS25404 01             33570\n6GIBBONS JOHN J     M20634189111ZOOL S96CMPSCS25404 01             33570\n6GINGERICH JEFFREY ZM17338784114ARCH B10CMPSCS25404 01             33570\n6GORE GEORGE ROLAND M18340649710CMPSCS25CMPSCS25404 01             33570\n ******\n6LEARMONT ELIZABETH F392463876GRCMPSCS25CMP3CS254567890123         33570\n6IAMADUMMYENTRY!!!  M18138124008CMPSCS25CAPSCS25404 01             33570\n6STUMP WILLIAM HUNTEM17742909608CMPSCS25CMP2CS254F4 01             33570\n6FRY STANLEY B      M161422090AEADJ  Y05CDPSCS25404 01             33570\n6LYLE THOMAS JOSEPH M16242982508CMPSCS25CMP1CS254SLYLER THOMAS JOSEPH570\n6TILEY JANE LOUISE  F04838578908CMPSCS25CMP4CS254NONE              33570\n6BLUNT CHARLES R    M579466035GECMPSCS25CMP4CS254Y0501             33570\n*******\n$JOB ASSIST MACRO=F\n         MACRO\n&LABEL   QSAVE &REGS,&BASE,&SA\n.*\n.*       QSAVE GIVES STANDARD LINKAGE CONVENTIONS FOR A CSECT.\n.*\n.*       BASE=NUMBER -THIS IS THE BASE REGISTER. DEFAULT IS REGISTER 12\n.*                    REGISTER 13,14,15 ARE ILLEGAL\n.*       REGS=(CNT1,CNT2) -THESE ARE REGISTERS TO BE SAVED.\n.*                    THE DEFAULT VALUE IS 14,12.\n.*       SA=VALUE -TAKES CARE OF SAVE AREA NAME AND ITS PROPER LINKAGE\n.*                 IF VALUE=NO - THEN THERE IS NO SAVEAREA CREATED.\n.*                 IF VALUE=NAME SAVE AREA LINKAGE WILL BE DONE AND\n.*                      ITS ADDRESS PLACED IN REGISTER 13.\n.*                 IF VALUE=* -SAVE AREA NAME IS FIRST 3 LETTERS OF\n.*                      CSECT NAME FOLLOWED BY A UNIQUE NUMBER AND AN\n.*                      'S'. THIS IS DEFINED AS GBLC TO BE USED BY\n.*                      QRETURN LATER.\n.*\n.*       &SANAME - SAVE AREA NAME GENERATED IF VALUE=*. USED BY QRETURN\n.*       &DISPLT -DISPLACEMENT FOR ST OR STM INSTRUCTIONS.\n.*       &REGNUM -REGISTER NUMBER USED TO DETERMINE DISPLACEMENT.\n.*       &BASERG -BASE REGISTER IS DEFAULTED TO 12.\n.*       &NAME   -CSECT OR LABEL IDENTIFICATION NAME\n.*       &NUMBER -LENGTH OF BRANCH AND CSECT IDENTIFICATION NAME.\n.*\n         GBLC  &SANAME\n         LCLA  &DISPLT,&REGNUM,&NUMBER,&BASERG\n         LCLC  &NAME\n&BASERG  SETA  12\n&DISPLT  SETA  12\n&REGNUM  SETA  14\n.*\n.*       DEFINE LABEL IN DC AND BRANCH INSTRUCTIONS.\n.*\n&LABEL   DS    OH\n         USING *,15                TEMPORARY BASE REGISTER.\n         AIF   (T'&LABEL EQ '0').NACSECT     IF NO LABEL,USE CSECT NAME\n&NAME    SETC  '&LABEL'            IDENTIFICATION NAME =&LABEL\n         AGO   .AROUND             BRANCH TO MAKE ID.\n.NACSECT AIF   ('&SYSECT' EQ '').CHECK13  NO CSECT,USE NO ID.\n&NAME    SETC  '&SYSECT'           ID NAME = NAME OF CSECT.\n.AROUND  ANOP\n&NUMBER  SETA  6+((K'&NAME+1)/2)*2 LENGTH OF BRANCH\n         B     &NUMBER.(,15)       BRANCH AROUND THE ID.\n&NUMBER  SETA  &NUMBER\n         DC    AL1(&NUMBER),CL&NUMBER'&NAME' DEFINE THE ID NAME .\n.*\n.*       SET UP THE DISPLACEMENT REQUIRED FOR THE PROPER STORAGE OF\n.*       REGISTERS AND THE ST OR STM INSTRUCTIONS.\n.*\n.CHECK13 AIF   (&REGS(1) NE 13).AGAIN\n         MNOTE 0,'**ERROR-REGISTER 13 WAS FIRST REGISTER OF THE PAIR**'\n&REGNUM  SETA  14                  WE SHALL USE REGISTER 14 INSTEAD.\n         AGO   .GOON               GO ON TO .GOON\n.AGAIN   AIF   (&REGS(1) EQ &REGNUM).GOON    GO ON IF REG(1) EQUALS 14\n&DISPLT  SETA  &DISPLT+4           DISPLACEMENT IS NOW INCREASED.\n&REGNUM  SETA  &REGNUM+1           INCREASE THE REGISTER NUMBER.\n         AIF   (&REGNUM NE 16).AGAIN  IF WE HAVE 16 START NOW AT 0\n&REGNUM  SETA  0\n         AGO   .AGAIN              CONTINUE FOR 0 THROUGH 12\n.GOON    AIF   ('&REGS(2)' NE '').PUTSTM    REG(2) NOT NULL GO PUTSTM\n         ST    &REGNUM,&DISPLT.(13)  SAVE THIS REGISTER\n         AGO   .SAVEIT             GO TO SAVEIT\n.PUTSTM  STM   &REGNUM,&REGS(2),&DISPLT.(13)   DO STORE MULTIPLE\n.*\n.*       GET THE NAME OF THE SAVE AREA PLUS THE POINTERS TO NEW AND\n.*       OLD SAVE AREAS. UNIQUE NAME GENERATED IF NO SA VALUE IS\n.*       PRESCRIBED.\n.*\n.SAVEIT  AIF   ('&SA' EQ 'NO').BASERT   NO SA VALUE IS TO BE HAD.\n         AIF   ('&SA' EQ '*').CSECTNA   SA=*,GO TO GET A SAVE AREA NAME\n&SANAME  SETC  '&SA'                    SAVE AREA NAME IS DEFINED\n         AGO   .DOLINK             GO TO SET SAVE AREA POINTERS.\n.CSECTNA ANOP\n         AIF   ('&SYSECT' EQ '').NULCECT    NULL CSECT\n&SANAME  SETC  '&SYSECT'(1,3).'&SYSNDX'.'S' GENERATE SAVE AREA NAME\n         AGO   .DOLINK\n.NULCECT ANOP\n&SANAME  SETC  'SAV&SYSNDX'\n.DOLINK  AIF   (&BASE GT 12).CONTIN  SET THE SAVE AREA POINTERS.\n&BASERG  SETA  &BASE               WORK REGISTERS FOR SAVE AREA.\n.CONTIN  LA    &BASERG,&SANAME     GET SAVE AREA ADDRESS\n         ST    &BASERG,8(13)       POINTER TO THE NEW SAVE AREA.\n         ST    13,4(&BASERG)       POINTER TO OLD SAVE AREA.\n         LR    13,&BASERG          GET THE NEW SAVE AREA.\n.*\n.*       WE NOW TAKE CARE F\n.*       WE NOW TAKE CARE OF THE BASE REGISTER. REGISTERS 13,14,AND 15\n.*       ARE INVALID BASE REGISTERS. REGISTER 12 IS DEFAULT VALUE.\n.*\n.BASERT  AIF   (&BASE GT 12).ERROR2  INVALID BASE REGISTER SPECIFIED.\n         AIF   ('&BASE' EQ '').NEWBASE  NO BASE SPECIFIED,USE 12.\n&BASERG  SETA  &BASE\n.NEWBASE BALR  &BASERG,0                SET UP NEW BASE REGISTER.\n         USING *,&BASERG                NEW USING\n         DROP  15                  DROP THE TEMPORARY BASE REGISTER.\n         AGO   .STOP               BRANCH TO THE END.\n.ERROR2  MNOTE 0,'**ERROR INVALID BASE REGISTER 12 IS USED**'\n&BASERG  SETA  12                  SET BASE REGISTER TO 12\n         AGO   .NEWBASE            GO TO NEWBASE.\n.STOP    MEND                      END\n        MACRO\n&LABEL   QRETURN &REGS,&SA\n.*\n.*       QRETURN GENERATES STANDARD LINKAGE FOR AN EXIT FROM A CSECT.\n.*\n.*       REGS=(CNT1,CNT2)  THIS CONTAINS THE REGISTERS TO BE RESTORED.\n.*          THE DEFAULT VALUE WILL BE (14,12)\n.*       SA=VALUE -THIS CONTROLS THE SAVE AREA LINKAGE AND ITS NAME.\n.*          VALUE=NO NO SAVE AREA IS CREATED\n.*          VALUE=NAME  THE NAME IS GIVEN TO THE SAVE AREA AND NORMAL\n.*             LINKAGE OCCURS.\n.*          VALUE=*     A NAME IS GIVEN TO SAVE AREA AND LINKAGE OCCURS\n.*\n.*       &SANAME -SAVE AREA NAME IF GENERATED (PASSED FROM QSAVE).\n.*       &DISPLT -DISPLACEMENT FOR LOAX AND LOAD MULTIPLE INSTRUCTIONS.\n.*       &REGNUM -REGISTER NUMBER USED TO DETERMINE DISPLACEMENT.\n         GBLC  &SANAME\n         LCLA  &DISPLT,&REGNUM\n.*\n&DISPLT  SETA  12\n&REGNUM  SETA  14\n&LABEL   DS    OH                  DEFINE THE LABEL\n         L     13,4(13)            RESTORE OUR OLD SAVE AREA POINTER.\n.*\n.*       CHECK FOR THE SAVE AREA. IF NONE,RESTORE REGISTER 13 AND GO\n.*       TO STOP\n.*\n         AIF   ('&SA' NE 'NO').CHECK\n         AGO   .STOP\n.*\n.*       SET THE AMOUNT OF DISPLACEMENT FOR THE LOAD OR LOAD MULTIPLE\n.*       INSTRUCTIONS.\n.*\n.CHECK   AIF   (&REGS(1) NE 13).AGAIN   GO TO AGAIN IF REGS (1) NOT 13.\n         MNOTE 0,'**WARNING REGISTER 13 IS PART OF REGISTER PAIR**'\n&REGNUM  SETA  14                  NOW WE USE REGISTER 14.\n         AGO   .DONE               IGNORE THIS IF REGISTER 13 WAS FIRST\n.AGAIN   AIF   (&REGS(1) EQ &REGNUM).DONE   IF REGS(1) IS 14 GO TO DONE\n&DISPLT  SETA  &DISPLT+4           INCREMENT THE DISPLACEMENT\n&REGNUM  SETA  &REGNUM+1           INCREMENT THE NUMBER REGISTER.\n         AIF   (&REGNUM NE 16).AGAIN    IF REGNUM NOT 16 GO TO AGAIN.\n&REGNUM  SETA  0                   SET REGNUM TO ZERO\n         AGO   .AGAIN              GO TO AGAIN.\n.DONE    AIF   ('&REGS(2)' NE '').DOLM  IF REGS(2) NOT ZERO,GO TO DOLM\n         L     &REGNUM,&DISPLT.(13)     RESTORE THE ONE REGISTER.\n         AGO   .SAAREA\n.DOLM    LM    &REGNUM,&REGS(2),&DISPLT.(13) RESTORE ALL THE REGISTERS.\n.*\n.*       SAVE AREA WITH NAME FROM QSAVE(&SANAME).RETURN TO CALL PROGRAM\n.*\n.SAAREA  BR    14                  RETURN TO CALL\n&SANAME  DC    18F'0'              SAVE AREA IS DEFINED.\n         MEXIT\n.STOP    BR    14                  RETURN TO CALL\n         MEND                      END\n         MACRO\n&LABEL   QCALL &NAME,&LIST\n.*\n.*       NAME=NAME OF THE ENTRY\n.*       LIST= NAME OF THE ADDRESS LIST.\n.*\n.*       &NUMBER =THIS IS THE COUNTER TO COUNT NUMBER PARAMETERS IN LIS\n.*       &LASTNUM =THIS IS NUMBER OF LAST NUMBER IN LIST.\n.*       &IDENTY  =THIS IS THE UNIQUE NAME\n.*\n         LCLA  &NUMBER,&LASTNUM\n         LCLC  &IDENTY\n&NUMBER  SETA  1                   SET NUMBER TO 1.\n&LASTNUM SETA  ('&LIST\n&LABEL   DS    OH                  DEFINE THE LABEL.\n.*\n.*       THIS TAKES CARE OF PART2 OR JUST AN ENTRY NAME.\n.*\n         AIF   ('&LIST' EQ '').AR1 THIS CHECKS FOR THE NULL LIST.\n.*\n.*       THIS TAKES CARE OF PART3 OR AN ENTRY NAME AND ADDRESS LIST\n.*       NAME.\n.*\n         AIF   ('&LIST'(1,1) NE '(').AR2     THIS IS FOR NO PARAMETERS.\n.*\n.*       THIS TAKES CARE OF PART 1 AND 4. THIS IS AN ENTRY NAME AND AN\n.*       ARGUMENT LIST.\n.*\n         CNOP  0,4                 SET ON A FULL WORD BOUNDARY9\n         B     *+&LASTNUM*4+4      DO A BRANCH AROUND THE LIST\n&IDENTY  SETC  'PARM&SYSNDX'       THIS GIVES US THE UNIQUE NAME.\n.AGAIN   AIF   (&LASTNUM EQ &NUMBER).LASTP\n         AIF   (&NUMBER EQ 1).FIRSTP         CHECK FOR FIRST PARAMETER\n.FIRSTP  ANOP\n&IDENTY  DC    A(&LIST(&NUMBER))   NOT THE LAST PARAMETER.\n&IDENTY  SETC  ''                  SET THE IDENTY TO ONE.\n&NUMBER  SETA  &NUMBER+1           INCREASE  NUMBER BY 1.\n         AGO   .AGAIN              GO TO AGAIN\n.LASTP   ANOP\n&IDENTY  DC    X'80',AL3 (&LIST(&NUMBER))   THIS DOES THE LAST PARAMER.\n.*\n.*       THIS DOES PART IS ARGUMENT LIST\n.*\n         AIF   ('&NAME' EQ '').STOP\n.*\n.*       THIS DOES PART 4 ENTRY NAME AND ARGUMENT LIST.\n.*\n         LA    1,&IDENTY           THIS GETS YOU THE PARAMETER LIST ADD\n         AGO   .AR2                GO GET THE ENTRY NAME.\n.AR1     LA    1,&LIST             GET THE PARAMETER LIST ADDRESS.\n.AR2     AIF   ('&NAME' EQ '').ERROR1   THIS CHECKS FOR THE NAME.\n         L     15,=V(&NAME)        GET ENTRY POINT ADDRESS WITH V ADCON\n         BALR  14,15               BRANCH TO THE SUBPROGRAM.\n         AGO   .STOP               BRANCH TO STOP\n.ERROR1  MNOTE 0,'**THERE IS NO ENTRY POINT ADDRESS**'\n.STOP    MEND                      THIS IS THE END.\nMAINPRG  CSECT\n         QSAVE\n         QCALL SUBX,ADDRX\n         QCALL SUBY\nGOBACK   QRETURN   SA=*\nADDRX    QCALL ,(MAINPRG,BOBACK)\n         LTORG\nSUBXCS   CSECT\n         ENTRY SUBX,SUBY\nSUBX     QSAVE SA=SUBXSA,BASE=11,REGS=(14,11)\n         CNOP  2,4\n         QCALL SUB1,(SUBX)\n         QCALL SUB2\nSUBRET   QRETURN SA=SUBXSA,REGS=(14,11)\nSUBY     QSAVE SA=NO\n         XPRNT =CL50'0************ AT SUBY ************',50\n         QRETURN SA=NO\n         LTORG\nSUB1     CSECT\n         QSAVE BASE=13\n         QRETURN SA=*\nSUB2     CSECT\n         QSAVE BASE=15,REGS=(2,12)\n         QRETURN SA=*,REGS=(2,12)\n         END\n$JOB ASSIST MACRO=F\n         MACRO\n         SETGBL &TRACE=,&LSNAP=,&STSNAP=\n         GBLB  &NOTRC,&NOLSNAP,&NOSNAP GLOBALS FOR DEBUG, LISTSNAP,\n.*                                   AND STSNAP\n&NOTRC   SETB  (T'&TRACE EQ 'O' AND &NOTRC OR '&TRACE' EQ 'OFF')\n&NOLSNAP SETB  (T'&LSNAP EQ 'O' AND &NOLSNAP OR 'LSNAP' EQ 'OFF')\n&NOSNAP  SETB  (T'&STSNAP EQ 'O' AND &NOSNAP OR '&STSNAP' EQ 'OFF')\n         MEND\n         EJECT\n         MACRO\n&LABEL   POP   &HDR,&REG,&END,&LENGTH=48,&MSG=\n&LABEL   L     &REG,&HDR .          GET ADDRESS TOP ELEMENT\n         AIF   (T'&END EQ 'O').NOTEST  SEE IF SHOULD DO EMPTY TEST\n         LTR   &REG,&REG .              TEST FOR NULL LINK\n         BZ    &END  .          IF EMPTY LIST, BRANCH OUT\n.NOTEST  ANOP\n         STM   0,1,POP&SYSNDX.S .    SAVE REGS THAT ARE CHANGED\n         L     0,0(&REG) .           GET SECOND TO TOP NODE\n         ST    0,&HDR    .           POINT HEAD TO 2ND NODE\n         LA    1,&HDR    .           GET ADDRESS OF HEADER\n         L     0,4(1) .           GET CURRENT LIST LENGTH\n         BCTR  0,0 .              DECREMENT LENGTH BY 1\n         ST    0,4(1) .           STORE UPDATED LENGTH\n         LM    0,1,POP&SYSNDX.S .    RESTORE REGISTERS\n         B     POP&SYSNDX.S+8 .       BRANCH AROUND SAVE AREA\nPOP&SYSNDX.S DC    2F'0' .           SAVE AREA FOR REGS 0 AND 1\n         DEBUG POP,&HDR,&MSG,4(&REG),&LENGTH\n         MEND\n         SPACE 3\n         MACRO\n&LABEL   PUTFREE &FRHDR,&REG\n&LABEL   MVC   0(4,&REG),&FRHDR .    RETURNED NODE ==> FREE LIST\n         ST    &REG,&FRHDR .          FREE LIST HEAD ==> RETURNED NODE\n         SPACE 1\n         MEND\n         EJECT\n         MACRO\n&LABEL   DELETE &HDR,&REG,&END,&LENGTH=48,&MSG=\n&LABEL   STM   14,1,DEL&SYSNDX.S .    SAVE REGS THAT ATE CHANGED\n         LR    0,&REG .              LOAD @ OF NODE TO BE DELETED\n         LA    1,&HDR    .        LOAD ADDRESS OF LIST HEAD\n         L     15,=V(DELETE) .    LOAD ADDR NODE DELETION ROUTINE\n         CNOP  2,4 .              FOR ALIGNMENT OF SAVE AREA\n         BALR  14,15 .            LINK TO DELETION ROUTINE\n         LM    14,1,8(14) .       RELOAD REGISTERS\n         B     &END  .          NODE NOT IN LIST, BRANCH OUT\nDEL&SYSNDX.S DC    4F'0' .            SAVE AREA FOR REGS 14-1\n         LM    14,1,8(14) .       RELOAD REGISTERS FOR NORMAL RETURN\n         DEBUG DELETION,&HDR,&MSG,4(&REG),&LENGTH\n         SPACE 1\n         MEND\n         SPACE 2\n         MACRO\n         SYSGEN &CPU=1,&MEM=64,&IONO=1,&DISKQ=10,&CATNO=1,&JQLOOK=NO\n         GBLA  &CPN,&MMS,&ION     # CPU'S, MEM SIZE, # CHANNELS\n         GBLA  &DQN,&CAT          SIZE OF DISK QUEUE, # CATEGORY Q'S\n         GBLB  &LOOK              TRUE IF INITIATOR MAY LOOK AHEAD\n&CPN     SETA  &CPU\n&MMS     SETA  &MEM\n&ION     SETA  &IONO\n&DQN     SETA  &DISKQ\n&CAT     SETA  &CATNO\n&LOOK    SETB  ('&JQLOOK' EQ 'YES')\n         MEND\n         SPACE 2\n         MACRO\n&LABEL   PUTNODE &HDR,&REG,&KEY=4,&KEYLEN=2,&LENGTH=48,&MSG=,&WORK=15\n         AIF   (&KEYLEN EQ 0).SHORT    TEST IF SIMPLE INSERT OR ORDERED\n&LABEL   STM   14,1,PUT&SYSNDX.S .    STORE REGS THAT ARE CHANGED\n         LR    0,&REG .              LOAD ADDR OF NODE TO BE ADDED\n         LA    1,&HDR    .        LOAD ADDRESS OF LIST HEAD\n         L     15,=V(PUTNODE) .   LOAD @ NODE INSERTION ROUTINE\n         CNOP  2,4 .              FOR FULLWORD ALIGNMENT OF SAVE AREA\n         BALR  14,15 .            LINK TO NODE INSERTION ROUTINE\nPUT&SYSNDX.S DC    4F'0' .            SAVE AREA FOR REGS 14-1\n         CLC   &KEY.(&KEYLEN,2),&KEY.(1) .              CLC FOR PUTNODE\n         LM    14,1,0(14) .       RESTORE REGISTERS\n         AGO   .END               BRANCH AROUND SIMPLE INSERT\n.SHORT   ANOP\n&LABEL   ST    ZERO,0(&REG) .        ZERO LINK TO OTHER JOBS\n         ST    ZERO,0(&REG) .        ZERO LINK TO OTHER JOBS\n         LA    &WORK,&HDR    .       GET ADDRESS OF HEADER\n         MVI   7(&WORK),X'01' .       INDICATE PROCESSOR BEING USED\n.END     DEBUG ADDITION,&HDR,&MSG,4(&REG),&LENGTH\n         MEND\n         EJECT\n         MACRO\n&LABEL   GETFREE &FRHDR,&REG,&END\n&LABEL   L     &REG,&FRHDR   .       GET TOP ELEMENT OFF FREE LIST\n         LTR   &REG,&REG .              TEST FOR EMPTY LIST\n         BZ    &END    .         NO FREE NODES; TAKE ALTERNATE EXIT\n         MVC   &FRHDR.(4),0(&REG) .    MOVE STACK POINTER DOWN\n         SPACE 1\n         MEND\n         EJECT\n         MACRO\n         DEBUG &PREFIX,&HDR,&MSG,&LOC,&LEN\n         GBLB  &NOTRC             FALSE IF TRACE IS ON\n         LCLA  &LN\n         LCLC  &NAME              EITHER &MSG OR &HDR\n         AIF   (&NOTRC).END       TEST FOR TRACE OFF\n         AIF   ('&MSG' EQ '').HDRMSG   USE &HDR IF &MSG OMITTED\n&NAME    SETC  '&MSG'(2,K'&MSG-2) STRIP QUOTES OFF &MSG\n&LN      SETA  K'&MSG-2\n         AGO   .GENTR\n.HDRMSG  ANOP\n&NAME    SETC  '&HDR'             PUT &HDR INTO &NAME\n&LN      SETA  K'&HDR\n.GENTR   XPRNT =C'0NODE &PREFIX AT &NAME',18+&LN\n         XDUMP &LOC,&LEN\n.END     MEND\n         SPACE 2\n         MACRO\n         CRLISTS &PREFIX,&NUM\n         LCLA  &COUNT\n         LCLA  &SUM               # EVENT QUEUE ELEMENTS\n.MORE    ANOP\n&COUNT   SETA  &COUNT+1\n&PREFIX&COUNT  DC    4F'0'.                LIST HEADER\n         AIF   (&COUNT LT &NUM).MORE\n         MEND\n         EJECT\n         MACRO\n         LISTS\n         GBLA  &MMS,&DQN,&CAT,&ION,&CPN     DECLARE GLOBALS\n.*       GENERATE LIST HEADERS\nEVQ      DC    4F'0'              EVENT QUEUE HEADER\nRJQ      DC    4F'0'              READY JOB QUEUE HEADER\n         CRLISTS DQ,&CAT          LIST HEADERS FOR CATEGORY QUEUES\n         CRLISTS IOQ,&ION         LIST HEADERS FOR CHANNEL WAIT QUEUES\n         CRLISTS CHAN,&ION        LIST HEADERS FOR CHANNEL USE QUEUES\n         CRLISTS CPU,&CPN         LIST HEADERS FOR CPU USING QUEUES\nEVQFR    DC    A(FR1)\nJQEFR    DC    A(FR2)\nMMS      DC    F'&MMS' .          MEMORY SIZE\nHEADERS  DC    AL4(2+&CPN+&ION+&ION+&CAT) .      NUMBER OF HEADERS\nCAT      DC    F'&CAT' .             NUMBER OF CATEGORIES\nION      DC    F'&ION' .             NUMBER OF I/O CHANNELS\nMEMTABLE DC    &MMS.CL12'    U'   MEMORY TABLE\nHOLES    DC    &MMS.F'0' .           TABLE OF HOLES IN MEMORY\n&SUM     SETA  &CPN+&ION+4        GET SIZE OF EVENT QUEUE\nFR1      FREEAREA &SUM,2          AREA FOR EVENT QUEUE\nFR2      FREEAREA &DQN,12            AREA FOR JQE'S\n         MEND\n         SPACE 3\n         MACRO\n&LABEL   FREEAREA &NUM,&DATA\n         LCLA  &I                 LOCAL COUNTER\n&LABEL   DS    0F .               DEFINE FREE LIST\n&I       SETA  &NUM               GET NUMBER OF NODES TO GENERATE\n.NEXT    AIF   (&I LE 1).LAST     SEE IF AT END YET\n         DC    A(*+4*(&DATA+1)),&DATA.F'0'\n&I       SETA  &I-1               DECREMENT COUNTER\n         AGO   .NEXT              GO DO NEXT NODE\n.LAST    DC    A(0),&DATA.F'0'\n         SPACE 1\n         MEND\n         EJECT\n         MACRO\n&LABEL   QRETURN &REGS=(14,9),&SA=*\n         GBLC  &SANAME            SAVE AREA GENERATED BY QSAVE\n&LABEL   DS    0H .               DEFINE LABEL\n         AIF   ('&SA' EQ 'NO').LM NO SAVE AREA NO R13 RESTORE\n         L     13,4(13) .         GET POINTER TO BACK SAVE AREA\n.LM      AIF   (&REGS(1) GE 14).R1415  DIFF. CODE IF RESTORE 14-15\n         LM    &REGS(1),&REGS(2),(&REGS(1)+5)*4(13) . RESTORE REGS\n         AGO   .BR14              GENERATE BRANCH BACK\n.R1415   LM    &REGS(1),&REGS(2),(&REGS(1)-11)*4(13) RESTORE REGS\n.BR14    BR    14 .               RETURN TO CALLING ROUTINE\n         AIF   ('&SA' EQ '').END  NO SAVE AREA, THEN DONE\n         AIF   ('&SA' EQ 'NO').END\n         AIF   ('&SA' NE '*').SA  SA=* ==> USE GENERATED NAME\n&SANAME  DC    18F'0' .           SAVE AREA, USING GENERATED NAME\n         AGO   .END\n.SA      ANOP\n&SA      DC    18F'0' .           GENERATE SAVE AREA\n.END     SPACE 1\n         MEND\n         EJECT\n         MACRO\n&LABEL   IDENT &NAME\n         LCLA  &LIDENT            LENGTH OF LABEL OR NAME\n         AIF   ('&LABEL' EQ '').SYSECT IF LABEL OMITTED, USE CSECT NAME\n&LIDENT  SETA  K'&LABEL/2*2+1     MAKE LENGTH OF LABEL ODD\n&LABEL   B     *+5+&LIDENT .            BRANCH AROUND IDENTIFIER\n         DC    X'&LIDENT',CL&LIDENT'&LABEL' .  ENTRY NAME\n         MEXIT\n.SYSECT  ANOP\n&LIDENT  SETA  K'&NAME/2*2+1      MAKE CSECT NAME LENGTH ODD\n         B     *+5+&LIDENT .            BRANCH AROUND IDENTIFIER\n         DC    X'&LIDENT',CL&LIDENT'&NAME' .  ENTRY NAME\n         MEND\n         EJECT\n         MACRO\n&LABEL   QSAVE &REGS=(14,9),&BASE=9,&SA=*\n         GBLC  &SANAME            NAME OF GENERATED SAVE AREA\n         LCLA  &BR                BASE REGISTER TO BE USED\n         AIF   (&BASE GE 13).BERROR    BASE REG CANNOT BE > 12\n&BR      SETA  &BASE              USE &BASE AS BASE REGISTER\n         AGO   .U15               BRANCH AROUND BASE REG ERROR RESET\n         MNOTE *,'NOT UNLESS AN ERROR IN ASSIST'\n.BERROR  MNOTE *,'&BASE IS ILLEGAL BASE REGISTER. VALUE CHANGED TO 12.'\n&BR      SETA  12                 USE 12 AS BASE REGISTER\n.U15     USING *,15 .             FOR TEMPORARY ADDRESSIBILITY\n&LABEL   IDENT &SYSECT            GENERATE IDENTIFIER\n         AIF   (&REGS(1) GE 14).R1415  IF SAVE REGS 14-15, DIFF. CODE\n         STM   &REGS(1),&REGS(2),(&REGS(1)+5)*4(13) . SAVE REGS\n         AGO   .SAVEA\n.R1415   STM   &REGS(1),&REGS(2),(&REGS(1)-11)*4(13) SAVE REGS\n.SAVEA   AIF   ('&SA' EQ 'NO').BASEREG NO SAVE AREA, DO BASE REG\n         AIF   ('&SA' EQ '*').GENSA    GENERATE NAME IF SA=*\n&SANAME  SETC  '&SA'              USE NAME PROVIDED\n         AGO   .R13FIX\n.GENSA   ANOP\n&SANAME  SETC  '&SYSECT'(1,3).'&SYSNDX.S'   GENERATE SAVE AREA NAME\n.R13FIX  LR    &BR,13 .            SAVE OLD POINTER\n         LA    13,&SANAME  .      GET ADDRESS NEW AREA\n         ST    13,8(&BR) .         PUT NEW POINTER IN OLD AREA\n         ST    &BR,4(13) .         STORE POINTER TO OLD SAVE AREA\n.BASEREG BALR  &BR,0 .             LOAD BASE REGISTER\n         USING *,&BR .             DECLARE BASE REGISTER\n         DROP  15 .               END TEMPORARY ADDRESSIBILITY\n         SPACE 1\n         MEND\n         EJECT\n         MACRO\n&LABEL   QCALL &ENTRY,&ARG\n         LCLA  &CTR               COUNTER FOR ARG LIST GENERATION\n         LCLA  &ARGLEN            # OF ITEMS IN ARGUMENT LIST\n         AIF   ('&ENTRY' EQ '').LABELF NO ENTRY PT. PUT LABEL ON DS  F\n&LABEL   DS    0H .               DEFINE LABEL\n         AIF   ('&ARG' EQ '').L15 NO ARG LIST, GENERATE L AND BALR\n         AIF   ('&ARG'(1,1) NE '(').LA1     GET ARG LIST @ IN REG 1\n         CNOP  0,4 .              ALIGN ARGUMENT LIST ON FULLWORD\n&ARGLEN  SETA  N'&ARG             GET NUMBER OF ARGUMENTS\n         BAL   1,*+4+4*&ARGLEN .        LOAD ARG LIST @ AND BRANCH OVER\n         AGO   .ARGLIST           GO GENERATE ARGUMENT LIST\n.LABELF  ANOP\n&LABEL   DS    0F .               ALIGN ARGUMENT LIST TO FULLWORD\n.ARGLIST ANOP\n&CTR     SETA  1                  INITIALIZE COUNTER\n.TEST    AIF   (&CTR GE N'&ARG).LAST   TEST FOR LAST ARGUMENT\n         DC    A(&ARG(&CTR)) .       ARGUMENT FOR CALLED PROGRAM\n&CTR     SETA  &CTR+1             INCREMENT COUNTER\n         AGO   .TEST              TEST FOR LAST ARGUMENT\n.LAST    DC    X'80',AL3(&ARG(&CTR)) .LAST ARG; VL FLAG SET TO 1\n         AIF   ('&ENTRY' EQ '').END    DONE IF NO ENTRY POINT\n         AGO   .L15               GENERATE CODE TO L AND BALR\n.LA1     LA    1,&ARG     .       LOAD ADDRESS OF REMOTE ARGUMENT LIST\n.L15     L     15,=V(&ENTRY)   .  GET ADDRESS OF ENTRY POINT\n         BALR  14,15 .            LINK TO CALLED ROUTINE\n.END     SPACE 1\n         MEND\n         PRINT ON\n         EJECT\n         SYSGEN CATNO=2\nPROCJCL  CSECT\n         ENTRY PUTNODE,DELETE,EVQINIT,ARRIVE\n         DS    55CL80\n         ORG   PROCJCL+X'7C0'\nPUTNODE  DS    0H\n         ORG   PROCJCL+X'802'\nDELETE   DS    0H\n         ORG   PROCJCL+X'870'\nEVQINIT  DS    0H\n         ORG   PROCJCL+X'A88'\nARRIVE   DS    0H\n         ORG\nLOADER   CSECT\n         QSAVE REGS=(14,2),BASE=2\n         LA    0,55\n         L     1,=A(PROCJCL)\nLOADREAD XREAD 0(1),72\n         LA    1,72(1)\n         BCT   0,LOADREAD\n         QCALL MAIN\n         QRETURN\n         LTORG\n         TITLE 'GLOBAL CSECT'\nGCSECT   CSECT\n         USING GCSECT,12          FOR ADDRESSIBILITY OF GBL TABLE\nZERO     EQU   10                 WILL CONTAIN ZERO AT EXECUTION TIME\nSYSTIME  EQU   11                 SYSTEM CLOCK\nCOMLINE  DC    C'-  COMMENT: '\nCOMCARD  DS    CL80               SPACE FOR COMMENT CARD\nCARDLINE DC    CL12' '            LINE TO PRINT CARD IMAGE\nCARD     DC    80C' ',C' #'       SPACE FOR CARD AND BYTES TO STOP TRT\nERRLINE  DC    CL12' ',82C'-',3C' '    ONE - IS CHANGED TO $ TO POINT\n*                                    TO ERROR IN CARD IMAGE\nERRMSG   DS    CL33               SPACE FOR ERROR MESSAGE\nBATCHTBL DS    0F                 KEYWORD DESCRIPTOR TBL FOR $B CARDS\n         DC    CL3'CPP',B'00000001',X'03',AL3(CPP),X'02',AL3(CPPST)\n         DC    CL3'CPS',B'00000101',X'03',AL3(CPS),X'03',AL3(CPSST)\n         DC    CL3'INP',B'00000101',X'02',AL3(INP),X'01',AL3(INPST)\n         DC    CL3'INS',B'00000001',X'01',AL3(INS),X'02',AL3(INSST)\n         DC    CL3'IOS',B'00000101',X'03',AL3(IOS),X'03',AL3(IOSST)\n         DC    CL3'JAR',B'00001000',X'00',AL3(JAR),X'00',AL3(0)\n         DC    CL3'MMA',B'00000001',X'03',AL3(MMA),X'03',AL3(MMAST)\n         DC    CL3'MMJ',B'00000100',X'00',AL3(MMJ),X'00',AL3(0)\n         DC    CL3'RPS',B'00000100',X'00',AL3(RPS),X'00',AL3(0)\n         DC    CL3'XXX',B'00000010',X'00',AL3(XXX),X'00',AL3(0)\nBATCHOP  DS    0F                 SPACE FOR OPERANDS FROM $B CARDS\nCPP      DC    2F'0'\nCPS      DC    2F'0'\nINP      DC    2F'0'\nINS      DC    2F'0'\nIOS      DC    2F'0'\nJAR      DC    F'0'\nMMA      DC    2F'0'\nMMJ      DC    F'0'\nRPS      DC    F'0'\nXXX      DC    F'0'\nBTCHDFLT DC    F'0,2,1,0,1,0,0,1,1'    $BATCH CARD DEFAULTS\n         DC    F'0,0,0,1,15,999999999,0'\nCPPST    DC    C'YES',X'00'       STRING TABLES FOR $B CARDS\n         DC    C'NO ',X'00'\nCPSST    DC    C'IBC',X'01'\n         DC    C'CBC',X'01'\n         DC    C'C  ',X'00'\nINPST    DC    C'MS',X'00'\nINSST    DC    C'C',X'00'\n         DC    C'R',X'00'\nIOSST    EQU   CPSST\nMMAST    DC    C'CNF',X'00'\n         DC    C'CNB',X'00'\n         DC    C'S  ',X'00'\n         SPACE 2\nJOBTBL   DS    0F                 KEYWORD DESCRIPTOR TBL FOR $J CARDS\n         DC    CL3'CHI',B'00000100',A(JCHI),A(0)\n         DC    CL3'CHL',B'00001000',A(JCHL),A(0)\n         DC    CL3'CHN',B'00000100',A(JCHAN),A(0)\n         DC    CL3'CTN',B'00000100',A(JCAT),A(0)\n         DC    CL3'MEM',B'00000100',A(JMEM),A(0)\n         DC    CL3'PRI',B'00000100',A(JPRI),A(0)\n         DC    CL3'TIM',B'00000100',A(JTIME),A(0)\nJOBOP    DS    0F                 SPACE FOR OPERANDS FROM $J CARDS\nJTIME    DC    F'1'\nJMEM     DC    F'1'\nJPRI     DC    F'999999999'\nJCAT     DC    F'1'\nJCHAN    DC    F'1'\nJCHI     DC    F'999999999'\nJCHL     DC    F'0'\nJOBDFLT  DC    F'1,1,999999999,2,4,999999999,0' $JOB CARD DEFAULTS\nCOLUMN   DS    F                  COLUMN TO BEGIN PROCESSING CARD\nDBLWRK   DS    D                  DOUBLE WORD FOR CVD'S\nFORTIME  DS    F                  SYSTIME TIME FOR FORTRAN REPORTS\nFORTURN  DS    F                  TURNAROUND TIME FOR FORTRAN REPORTS\nFMEMRES  DS    F                  MEMORY RESIDENCE TIME FOR REPORTS\nFORTJOB  DS    H                  JOB NUMBER FOR FORTRAN REPORTS\nOVERLAP  DS    F                  TOTAL AMOUNT OF TIME A CPU AND CHAN\n*                                    WERE BUSY AT THE SAME TIME\nAVJOBMEM DS    F                  (AVERAGE # OF JOBS IN MEM)*(CURRENT\n*                                    SYSTEM TIME)\nJOBFLOW  DS    F                  SUM OF TURNAROUND TIMES FOR ALL JOBS\n*                                 TERMINATED TO DATE\nBADJOB   DS    F                  NUMBER OF BAD JOBS IN THIS BATCH\nJQEUSED  DS    F'0'               NUMBER OF JQE'S BEING USED\nJOBIM    DC    F'0'               # OF JOBS CURRENTLY IN MEMORY\nJOB#     DC    H'0'               NUMBER OF THE LAST JOB READ\nBATCH#   DC    PL2'0'             BATCH #\nSTAT#    DS    PL2                STATUS REPORT NUMBER\nEDWRK    DS    CL11               WORK AREA FOR EDITS\nEQOUTHEX DC    C'0123456789ABCDEF'     HEX OUTPUT TR TABLE\nHEXTBL   EQU   EQOUTHEX-240       TO ADDRESS HEX TABLE\nEOF      DC    X'00'              SET TO 01 WHEN END OF FILE IS FOUND\nINHIBIT  DC    C'F'               SET TO T IF ALL JQE'S ARE BEING USED\nJOBLAST  DC    C'F'               SET TO T WHEN LAST JOB IN BATCH FOUND\nCATL     DC    X'01'              CATEGORY LAST INITIATED FROM\nJOBARG   QCALL ,(JOBTBL,L7)       ARGUMENT LIST TO CALL PROCJCL FOR $J\nL7       DC    F'7'               LENGTH OF JOB TABLE\nBATCHARG QCALL ,(BATCHTBL,L10)    ARGS TO CALL PROCJCL FOR $BATCH\nL10      DC    F'10'              LENGTH OF $B ARG TABLE\n         LISTS\n         TITLE 'DSECTS'\nLISTHEAD DSECT                    FORMAT OF 4 WORD LIST HEADER\nTOP      DS    A                  POINTER TO TOP NODE\nLLEN     DS    F                  CURRENT NUMBER OF NODES IN LIST\nMAXLEN   DS    F                  MAX LENGTH LIST HAS EVER HAD\nAVGLEN   DS    F                  AVERAGE Q LENGTH * TOTAL TIME\n         SPACE 2\nEVQEL    DSECT                    FORMAT EVENT QUEUE NODE\n         DS    F                  LINK TO NEXT EVENT\nEVTIME   DS    F                  TIME OF EVENT\nEV#      DS    H                  EVENT NUMBER\nEVFLAG   DS    H                  EVENT FLAGS\n         SPACE 2\nJQEL     DSECT                    FORMAT JOB QUEUE ELEMENT\n         DS    F                  LINK TO NEXT JQE\nJOBID    DS    H                  JOB IDENTIFICATION NUMBER\nCHAN     DS    H                  CHANNEL JOB WILL USE\nTIME     DS    F                  CPU TIME REQUESTED, IN MILLISECONDS\nTIMREM   DS    F                  CPU TIME REMAINING UNTIL TERMINATION\nCPUPRI   DS    H                  PRIORITY FOR USING THE CPU\nIOPRI    DS    H                  PRIORITY FOR USING A CHANNEL\nCHI      DS    F                  INTERVAL BETWEEN CHANNEL INTERRUPTS\nCOMPCHI  DS    F                  TIME UNTIL NEXT CHANNEL INTERRUPT\nCHL      DS    F                  LENGTH OF EACH CHANNEL USAGE\nINDQ     DS    F                  TIME ENTERED SYSTEM\nCPS#IO   DS    H                  # I/O REQUESTS IN LAST CPS INTERVAL\nIOS#IO   DS    H                  # I/O REQUESTS IN LAST IOS INTERVAL\nMEMPTR   DS    0F                 POINTER TO THE FIRST MEMORY BLOCK\nMEM      DS    H                  # OF MEMORY BLOCKS REQUESTED\nINITPRI  DS    H                  INITIATION PRIORITY\nEVPTR    DS    F                  POINTER TO NEXT EVENT FOR THIS JOB\nINITIME  DS    F                  TIME INITIATED\n         TITLE 'MAIN ROUTINE'\nMAIN     CSECT\n         QSAVE REGS=(14,12)\n         SR    ZERO,ZERO          PUT 0 IN ZERO\n         L     12,=V(GCSECT)      GET ADDR OF GLOBAL TABLE\n         USING GCSECT,12\n         XPRNT =CL30'1 OS/411   JAMES WYLLIE',30\n         XPRNT =C'1',1            SKIP TO A NEW PAGE\nMREAD    XREAD CARD,80            READ NEXT CARD\n         BM    MAINRET            DONE IF ENDFILE\n         B     MBATCH             BRANCH AROUND END FILE TEST\nMAINM2   CLI   EOF,X'01'          TEST FOR END OF FILE\n         BE    MAINRET            IF END OF FILE; THEN DONE\nMBATCH   CLC   CARD(2),=C'$B'     TEST FOR $BATCH CARD\n         BE    MEVALB             GO CALL PROCJCL IF $B CARD\n         CLC   CARD(2),=C'$C'     TEST FOR COMMENT CARD\n         BNE   MERROR             ERROR IF NOT $C OR $B\n         SPACE 1\n         MVC   COMCARD,CARD       MOVE COMMENT TO COMMENT PRINT AREA\n         XPRNT COMLINE,92         PRINT FIRST COMMENT\n         MVI   CARDLINE,C' '      MOVE BLANK TO CARRIAGE CONTROL\nMCOMREAD XREAD CARD,80            READ NEXT CARD\n         BM    MAINRET            DONE IF END FILE\n         CLI   CARD,C'$'          TEST FOR CONTROL CARD\n         BE    MBATCH             TEST IF CONTROL CARD IS $B\n         XPRNT CARDLINE,92        PRINT COMMENT CONTINUATION\n         B     MCOMREAD           GO READ NEXT CARD\n         SPACE 1\nMERROR   XPRNT =C'-EXPECTING $B OR $C CARD.  THE FOLLOWING CARD WAS FOUX\n               ND:',56            PRINT ERROR MESSAGE\n         XPRNT CARD-1,81          PRINT BAD CARD\n         B     MREAD              GO READ NEXT CARD\n         SPACE 1\nMEVALB   MVC   COLUMN,=F'7'       SET START COLUMN FOR PROCJCL\n         MVC   BATCHOP(64),BTCHDFLT    SET $B DEFAULTS\n         QCALL PROCJCL,BATCHARG   CALL PROCJCL FOR $B CARDS\n         B     *+8                IF GOOD, BRANCH AROuND BAD CARD BR\n         B     MAINM2             BAD $BATCH CARD, GO CHECK EOF\n         QCALL BEGINB             PRINT BEGINNING OF BATCH REPORT\n         SPACE 1\nMJTYPE   CLC   CARD(2),=C'$J'     TEST FOR JOB CARD IN BUFFER\n         BE    MEVALJ             IF $J, GO CALL PROCJCL FOR $J\n         CLC   CARD(2),=C'$C'     TEST IF COMMENT CARD IN BUFFER\n         BE    MJCOMM             DUMP COMMENTS  IF FOUND\n         CLC   CARD(2),=C'$B'     TEST FOR $B IN BUFFER\n         BE    EMPTYB             EMPTY BATCH IF NO $J CARDS\n         XPRNT =C'-EXPECTING $J, $B, OR $C CARD.  THE FOLLOWING CARD WAX\n               S FOUND:',61\n         XPRNT CARD-1,81          PRINT BAD CARD\n         XREAD CARD,80            READ NEXT CARD\n         BNM   MJTYPE             NOT EOF; FIND TYPE OF CARD\nMEOF     MVI   EOF,X'01'          TURN ON ENDFILE FLAG\n         B     EMPTYB             PRINT EMPTY BATCH MESSAGE\n         SPACE 1\nMJCOMM   MVC   COMCARD,CARD       MOVE COMMENTS TO COMMENT PRINT AREA\n         XPRNT COMLINE,92         PRINT FIRST COMMENT\n         MVI   CARDLINE,C' '      MOVE BLANK CARRIAGE CONTROL IN\nMJCOMRD  XREAD CARD,80            READ NEXT CARD\n         BM    MEOF               GO SET EOF FLAG AND PRINT EMPTY BATCH\n         CLI   CARD,C'$'          TEST FOR CONTROL CARD\n         BE    MJTYPE             FIND TYPE OF CONTROL CARD\n         XPRNT CARDLINE,92        PRINT COMMENT CONTINUATION\n         B     MJCOMRD            GO READ NEXT CARD\n         SPACE 1\nMEVALJ   MVC   COLUMN,=F'5'       SET START COLUMN FOR PROCJCL\n         MVC   JOBOP(28),JOBDFLT  SET $J DEFAULTS\n         QCALL PROCJCL,JOBARG     CALL PROCJCL TO EVALUATE $J CARD\n         B     MMTEST             GOOD $J; CHECK MEM NOT > &MMS\nMBADJOB  L     3,BADJOB           ADD ONE TO COUNT OF BAD JOBS IN BATCH\n         LA    3,1(3)\n         ST    3,BADJOB\n         CLI   EOF,X'01'          CHECK FOR ENDFILE\n         BNE   MJTYPE             IF NOT EOF, THEN TEST FOR A JOB CARD\n         SPACE 1\nEMPTYB   XPRNT =C'-THERE WERE NO VALID $JOB CARDS IN THE PRECEDING BATCX\n               H.  NO SIMULATIONS WERE DONE.',82 PRINT EMPTY BATCH MSG\n         B     MAINM2             GO TEST FOR END OF FILE\n         SPACE 2\nMMTEST   CLC   JMEM,MMS           TEST FOR MEMORY REQUEST TOO HIGH\n         BNH   MAINM1             IF WITHIN RANGE, GO DO SIMULATION\n         XPRNT =C'-A JOB REQUESTED TOO MUCH MEMORY.  IGNORED.',43\n         B     MBADJOB            GO INC COUNT OF BAD JOBS\nMAINM1   SR    SYSTIME,SYSTIME    SET SYSTEM TIME TO ZERO\n         MVI   INHIBIT,C'F'       NOT ALL JQE'S IN USE\n         MVI   JOBLAST,C'F'       NOT LAST JOB IN BATCH\n         STH   ZERO,JOB#          SET JOB NUMBER TO 0\n*        ZERO MAXIMUM LENGTH AND AVERAGE LENGTH FIELDS OF QUEUE HEADERS\n         L     5,HEADERS          GET NUMBER OF HEADERS TO BLANK\n         LA    4,EVQ              GET START ADDRESS OF HEADERS\nMHEADBL  STM   ZERO,SYSTIME,8(4)  ZERO MAX AND AVG LENGTH FIELDS\n         LA    4,16(4)            INCREMENT POINTER\n         BCT   5,MHEADBL          DECREMENT AND TEST COUNTER\n         SPACE 1\n*        MUST REINITIALIZE MEMORY TABLE\n         LA    4,MEMTABLE         GET BEGIN ADDRESS OF TABLE\n         L     5,MMS              GET NUMBER OF CELLS TO CLEAR\nMEMBLANK ST    ZERO,8(4)          BLANK OUT CELL IN MEMORY TABLE\n         LA    4,12(4)            INCREMENT POINTER\n         BCT   5,MEMBLANK         DECREMENT COUNTER AND LOOP\n         SPACE 1\n         AP    BATCH#,=PL1'1'     INCREMENT BATCH NUMBER\n         ZAP   STAT#,=P'0'        ZERO STATUS REPORT NUMBER\n         MVC   CATL,CAT+3         SET LAST CAT INITIATED FROM TO &CAT\n         ST    ZERO,OVERLAP       ZERO CHANNEL-CPU CONCURRENCY TIME\n         STM   ZERO,SYSTIME,AVJOBMEM   ZERO AVG # JOBS IN MEM AND TOTAL\n*                                    TURNAROUND TIME\n         SPACE 2\n         QCALL EVQINIT            INITIALIZE EVENT QUEUE\n         QCALL EVENT              PERFORM SIMULATION\n         QCALL ENDBATCH           WRITE END OF BATCH REPORT\n         B     MAINM2             GO TEST FOR END FILE\n         SPACE 2\nMAINRET  QRETURN REGS=(14,12)\n         LTORG\n         TITLE 'I/O REQUEST'\nIOREQ    CSECT\n*        AT ENTRY, REG 2 CONTAINS THE ADDRESS OF THE EVENT QUEUE\n*        ELEMENT ASSOCIATED WITHE THE I/O REQUEST\n         QSAVE\n         USING EVQEL,2            TO ADDRESS EVENT QUEUE ELEMENT\n         LH    1,EVFLAG           GET (CPU#-1)*16\n         POP   CPU1(1),3,MSG='IOREQ'   FREE CORRECT CPU\n         USING JQEL,3             TO ADDRESS THE JQE\n         L     1,CHAN             GET CHANNEL # JOB WILL USE\n         SLA   1,4                MULT BY 16 TO GET INDEX INTO CHAN HDR\n         L     0,CHAN1-12(1)      GET LENGTH OF CHANNEL QUEUE\n         LTR   0,0                LENGTH = 0 IF CHANNEL IDLE;\n         BNZ   IORWAIT                   = 1 IF BUSY\n         PUTNODE CHAN1-16(1),3,KEYLEN=0,MSG='IOR CHAN' ASSIGN CHANNEL\n         GETFREE EVQFR,2,ERROR    GET A FREE EVENT QUEUE NODE\n         LR    0,SYSTIME          COMPUTE TIME FINISHED USING CHANNEL\n         A     0,CHL\n         ST    0,EVTIME           SET TIME OF CHANNEL TERMINATION\n         LA    0,3                GET # FOR I/O TERMINATION\n         STH   0,EV#              PUT EVENT TYPE INTO NODE\n         STH   1,EVFLAG           PUT (CHAN#)*16 INTO EVENT FLAG\n         PUTNODE EVQ,2,KEYLEN=6,LENGTH=8,MSG='REQ TERM' SCHED CHAN TERM\n         MSTATUS 3,I              SET MEMORY USAGE FLAGS TO I\n         B     IOREQEND\n         SPACE 2\n*        CHANNEL IS BUSY, MUST ENQUEUE JOB ON I/O WAIT QUEUE\nIORWAIT  PUTNODE IOQ1-16(1),3,KEY=18,MSG='I/O WAIT' PUT JOB INTO I/O Q\n         MSTATUS 3,W              SET MEMORY BLOCK USAGE FLAGS TO WAIT\nIOREQEND QRETURN\n         LTORG\n         DROP  2,3\n         TITLE 'I/O TERMINATOR'\nIOTERM   CSECT\n*        AT ENTRY, REG 2 CONTAINS THE ADDRESS OF THE EVENT QUEUE\n*        ELEMENT ASSOCIATED WITH THIS I/O TERMINATION\n         USING EVQEL,2            TO ADDRESS EVENT QUEUE ELEMENT\n         LH    3,EVFLAG           GET CHANNEL# * 16\n         POP   CHAN1-16(3),1,MSG='I/O TERM'      FREE CHANNEL\n         USING JQEL,1             TO ADDRESS JOB QUEUE ELEMENT\n         LH    4,CPS#IO           UPDATE # I/O REQUESTS FOR CPS\n         LA    4,1(4)\n         STH   4,CPS#IO\n         LH    4,IOS#IO           UPDATE # I/O REQUESTS FOR IOS\n         LA    4,1(4)\n         STH   4,IOS#IO\n         ST    ZERO,COMPCHI       SET COMPUTED CHI TO 0 AWAITING CPU\n         PUTNODE RJQ,1,KEY=16,MSG='I/O TO R'  PUT JOB BACK INTO RJQ\n         MSTATUS 1,R              FIX UP MEMORY STATUS FLAGS FOR READY\n         POP   IOQ1-16(3),1,IOTEND,MSG='I/O NEXT' GET NEXT JOB FOR CHAN\n         PUTNODE CHAN1-16(3),1,KEYLEN=0,MSG='IOT CHAN'CHAN TO NEXT\n         MSTATUS 1,I              SET MEM STATUS FLAGS TO I/O WAIT\n         GETFREE EVQFR,2,ERROR    GET A FREE EVENT QUEUE NODE\n         L     0,CHL              COMPUTE TIME JOB DONE WITH CHANNEL\n         AR    0,SYSTIME\n         ST    0,EVTIME           SET TIME OF CHANNEL TERMINATION\n         LA    0,3                GET # FOR I/O TERMINATION\n         STH   0,EV#              SET EVENT TYPE TO I/O TERMINATION\n         STH   3,EVFLAG           PUT CHANNEL #16 INTO EVQ ELEMENT\n         STH   3,EVFLAG           PUT CHANNEL# * 16 INTO EVQ ELEMENT\nIOTEND   QRETURN\n         LTORG\n         DROP  1,2                END ADDRESSIBILITY OF QUEUE ELEMENTS\n         END   LOADER\n/*\n$ENTRY\n 00  PROCJCL  } &}3M ] }3}&       { j A3    k-{*\\ {* *k {*  K      ~  K\n    kB    { ! BYk              w\\ {  &    n${     j A3    \\ {* *  {  0\nk C nB      j A3    K A  :k$ *\\ {  bk- * 0 o\\      0 o                N\n       }     r       0      n=     YkK      j       k          2 6 0 2 0\n   0  j                    \\   0          n -    -N   -    +\n - 0             d   0        &0  P     k          2 : 0   0   0   0  j\n      k               \\ {  &    k C     q }   n${     j A3   M\\ {* *  {\n 0               0  j            0  j        - k    j        0  j\n - k    j       &        0 o        nA     %n9     %nF   }  n0     %\n 0               M   & &   &           0        n0&    yn9&  } m   &\n { & &     y   6K A    0  K A    0  K A    0  K A    0  K A  & 0  K A\n 0  K A  k 0  K A    0  K A  M 0  K A  5 0  K A    0  K A    0  K A    0\n  K A  `k$ ;j A3 \\ !\\ {* *\\ {  bk- ;k  #\\ {  &   kn${    o   hk0 #\\\n\\ {* * 0  k C  }  q }     55555555555555\n                                              K  y     y  2    y2  y  55\n5555555555555550123456789\n\n\n                                                                 5555555\n$JOB   ASSIST       MACRO=F\n         TITLE 'QDEFL MACRO - DEFINE A LIST OF NODES'\n         MACRO\n&LABEL   QDEFL &NUMBER,&LENGTH,&MESSAGE\n         LCLA  &MSGK,&NNODES\n         LCLC  &XLABEL\n         ACTR  100\n.*\n.*\n.*THIS MACRO GENERATES &NUMBER NODES, EACH OF TOTAL LENGTH &LENGTH\n.*  BYTES (INCLUDING 4-BYTE LINK), LINKED TOGETHER, WITH KEY/DATA AREAS\n.*  INITIALIZED TO BLANKS, AND PRECEDED BY AN OPTIONAL MESSAGE.\n.*&NUMBER IS A SELF-DEFINING TERM OF VALUE >0, GIVING THE NUMBER OF\n.*  NODES TO BE GENERATED.\n.*&LENGTH IS ANY ABSOLUTE EXPRESSION GIVING A LENGTH FOR EACH NODE.\n.*  CODE GENERATED ALLOWS FOR ROUNDING THIS TO A 4-MULTIPLE.\n.*&MESSAGE IS A STRING ENCLOSED IN QUOTES.  IF OMITTED, THE LIST ONLY\n.*  IS CREATED, BUT IF PRESENT, THE MESSAGE STRING IS GENERATED AS\n.*  A C-TYPE CONSTANT, ROUNDED UP TO A 4-MULTIPLE, AND PLACED ON\n.*  A FULLWORD BOUNDARY PRECEDING THE LIST.  IT IS USED FOR DEBUGGING\n.*  (I.E., TO LOCATE A LIST IN MEMORY IN A DUMP).\n.*&LABEL IS GENERATED ON OR BEFORE THE FIRST NODE GENERATED.\n.*\n.*\n&XLABEL  SETC  '&LABEL'\n         AIF   (T'&MESSAGE EQ 'O').NOMSG . IS THERE A MESSAGE?\n&MSGK    SETA  ((K'&MESSAGE+3)/4)*4 .  MESSAGE LENGTH TO A 4-MULTIPLE.\n         DC    0F'0',CL&MSGK&MESSAGE .  DEBUGGING MESSAGE FOR THIS LIST\n.NOMSG   ANOP\n&NNODES  SETA  &NUMBER-1 .        NUMBER OF NODES TO CREATE LESS ONE.\n.ONELEFT AIF   ('&NNODES' LT '1').LASTNOD . IS THIS THE LAST NODE?\n&XLABEL  DC    A(*+((&LENGTH+3)/4)*4),CL(&LENGTH-4)' ' . SET UP A NODE.\n.*                                LESS LINK POINTER OF 4 BYTES.\n&XLABEL  SETC  '' .               NULL THE LABEL.\n&NNODES  SETA  &NNODES-1 .        DECREMENT NODES TO DO.\n         AGO   .ONELEFT .         GO CHECK IF THERE IS ONLY ONE MORE.\n.LASTNOD ANOP\n&XLABEL  DC    A(0),CL(&LENGTH-4)' ' . POINTER OF LAST NODE IS ZERO.\n         MEND\n         TITLE 'QHED MACRO - DEFINE A LIST HEADER'\n         MACRO\n&LABEL   QHED  &LISTNAM\n         ACTR  50\n.*\n.*\n.*IF &LISTNAM IS CODED, THIS MACRO DEFINES A HEADER CONTAINING THE\n.*  ADDRESS OF THIS LIST, OTHERWISE IT IS A HEADER CELL HAVING A VALUE\n.*  OF 0, I.E., DEFINING AN EMPTY LIST.\n.*FOR DEBUG PURPOSES, THIS MACRO GENERATES A MESSAGE '&LABEL LIST\n.*  HEADER' IMMEDIATELY PRECEDING THE HEADER WORD.\n.*\n.*\n         DC    0F'0',CL16'&LABEL HEADER' . DEBUGGING HEADER.\n         AIF   (T'&LISTNAM EQ 'O').NULLNAM . IS THERE A HEADER NAME?\n&LABEL   DC    A(&LISTNAM) .      SET UP HEADER WITH ADDRESS OF LIST.\n         MEXIT\n.NULLNAM ANOP\n&LABEL   DC    A(0) .             SET UP HEADER WITH NULL LIST.\n         MEND\n         TITLE 'QNEXT MACRO - GET ADDRESS OF NEXT NODE IN LIST'\n         MACRO\n&LABEL   QNEXT &RND,&ADDR,&RLK=,&END=\n.*\n.*\n.*THIS MACRO SETS REGISTER &RND TO THE ADDRESS OF THE NEXT NODE IN\n.*  A LIST, GIVEN THAT &ADDR INDICATES THE ADDRESS OF A NODE WHOSE LINK\n.*  FIELD POINTS TO THE NEXT NODE.  IF DESIRED, THE VALUE IN &RND MAY\n.*  BE SAVED INTO REGISTER &RLK BEFORE &RND IS CHANGED (USEFUL FOR LIST\n.*  SEARCH AND INSERT OPERATIONS).  IF &END IS SPECIFIED, A TEST IS\n.*  MADE AND BRANCH TAKEN IF THERE ARE NO MORE NODES IN THE LIST.\n.*&RND IS A REGISTER EQU SYMBOL OR NUMBER, INTO WHICH WILL BE LOADED\n.*  THE ADDRESS OF THE NEXT NODE.\n.*&ADDR IF SPECIFIED AT ALL, IS AN RX-TYPE ADDRESS OF THE LINK FIELD\n.*  WHICH ADDRESSES THE NEXT NODE.  THE WORD AT THIS ADDRESS IS TO BE\n.*  LOADED INTO &RND.  IF OMITTED ENTIRELY, IT IS TO BE ASSUMED THAT\n.*  &RND CONTAINS THE ADDRESS OF THE LINK ALREADY.\n.*&RLK IF SPECIFIED, GIVES THE NAME OR NUMBER OF A REGISTER INTO WHICH\n.*  &RND SHOULD BE SAVED BEFORE IT IS CHANGED.\n.*&END IF SPECIFIED, GIVES A STATEMENT LABEL, IN WHICH CASE THE VALUE\n.*  NEWLY LOADED INTO &RND IS TO BE TESTED, AND IF FOUND = 0, A BRANCH\n.*  TAKEN TO THE GIVEN STATEMENT LABEL.\n.*NOTE THAT 'LINK' IS ASSUMED TO BE THE LINK DISPLACEMENT.\n.*\n.*\n         LCLC  &XLABEL\n         ACTR  50\n&XLABEL  SETC  '&LABEL'\n         AIF   (T'&RLK EQ 'O').NOWORKR . IS THERE A WORK REGISTER?\n&XLABEL  LR    &RLK,&RND .        SAVE NEXT NODE REGISTER.\n&XLABEL  SETC  '' .               NULL THE LABEL.\n.NOWORKR AIF   (T'&ADDR EQ 'O').NOADDR . IS THERE AN ADDR OF THE LINK?\n&XLABEL  L     &RND,&ADDR+LINK .  ADDR OF THE LINK FIELD.\n&XLABEL  SETC  '' .               NULL THE LABEL.\n         AGO   .ENDTEST .         GO TEST FOR END ENTRY.\n.NOADDR  ANOP\n&XLABEL  L     &RND,LINK(,&RND) . SET TO POINT TO NEXT NODE.\n.ENDTEST AIF   (T'&END EQ 'O').NOEND .   IS THE END OPTION REQUESTED?\n         LTR   &RND,&RND .        SET THE CONDITION CODE TO TEST\n         BZ    &END .                FOR LAST NODE, BRANCH IF YES.\n         MEXIT\n.NOEND   MEND\n         TITLE 'QPOP MACRO - POP THE FIRST ELEMENT OF A LIST'\n         MACRO\n&LABEL   QPOP  &RND,&HDR,&END=\n.*\n.*\n.*QPOP SETS REGISTER &RND TO THE ADDRESS OF THE FIRST NODE IN THE LIST\n.*  BEGUN BY HEADER AT ADDRESS &HDR, TAKING BRANCH TO &END= IF THE LIST\n.*  IS EMPTY.\n.*&RND SPECIFIES REGISTER TO BE SET TO ADDRESS OF NODE.\n.*&HDR USUALLY SPECIFIES THE NAME OR OTHER RX-ADDRESS OF THE HEADER\n.*  CELL OF A LIST.\n.*&END IF SPECIFIED, REQUESTS CODE TO TEST THE LINK JUST LOADED INTO\n.*  &RND, AND BRANCH TO THE LABEL SPECIFIED IF IT IS ZERO.\n.*NOTICE 'LINK' IS ASSUMED TO BE THE LINK DISPLACEMENT.\n.*MACROS  USED : QNEXT.\n.*\n.*\n         ACTR  50\n&LABEL   QNEXT &RND,&HDR,END=&END\n         MVC   LINK+&HDR.(4),LINK(&RND) . POINT HEADER TO NEW TOP NODE.\n         MEND\n         TITLE 'QPUSH MACRO - PUSH A NODE ONTO THE BEGINNING OF A LIST'\n         MACRO\n&LABEL   QPUSH &RND,&HDR\n.*\n.*\n.*&RND CONTAINS THE ADDRESS OF A NODE, WHICH IS PUSHED ONTO THE LIST\n.*  BEGUN AT &HDR.\n.*&RND SPECIFIES A REGISTER NAME OR NUMBER.\n.*&HDR IS A NAME OF A HEADER CELL.\n.*NOTICE 'LINK' IS ASSUMED TO BE THE LINK DISPLACEMENT.\n.*\n.*\n         ACTR  50\n&LABEL   MVC   LINK(4,&RND),&HDR .   MOVE HEADER POINTER TO NEW NODE.\n         ST    &RND,&HDR .        SET HEADER POINTER TO POINT TO\n*                                    NEW NODE.\n         MEND\n         TITLE 'QSRCH MACRO - LIST SEARCH AND INSERT NODE IN SEQUENCE'\n         MACRO\n&LABEL   QSRCH &RND,&HDR,&RGW=(RWK1,RWK2),&KO=4,&KL=KEYL\n.*\n.*\n.*THIS MACRO SEARCHES THE LIST BEGUN BY HEADER &HDR, WHICH IS LINKED\n.*  IN ASCENDING ORDER BY KEY FIELDS, FOR THE CORRECT PLACE TO INSERT\n.*  THE NODE ADDRESSED BY REGISTER &RND.  THE KEY FIELDS ARE AT OFFSET\n.*  &KO, AND ARE &KL BYTES LONG.  &RGW GIVES TWO REGISTERS WHICH MAY BE\n.*  USED IF NEEDED FOR TEMPORARY WORK REGISTERS WITHOUT DISTURBING\n.*  ANYTHING.\n.*&RND GIVES ADDRESS OF THE NODE TO BE INSERTED.\n.*&HDR IS THE NAME OF THE LIST HEADER CELL.\n.*&RGW GIVES THE NAMES/NUMBERS OF 2 REGISTERS WHICH CAN SAFELY BE USED\n.*  AS TEMPORARY WORK REGISTERS, AND DESTROYED BY THE MACRO.\n.*&KO GIVES A NUMBER (OR EQU SYMBOL) OF THE OFFSET IN BYTES FROM THE\n.*  BEGINNING OF THE NODE TO THE KEY FIELD IN THE NODE.\n.*&LK IS THE LENGTH (NUMBER OR EQU VALUE) OF THE KEY FIELD.\n.*NOTE THAT THE NODE TO BE INSERTED IS INSERTED AFTER ANY NODES WHICH\n.*  HAVE THE SAVE KEY VALUE.\n.*NOTICE RWK1, RWK2, AND LINK AND KEYL ARE ASSUMED TO BE SET IN THE\n.*  MAIN PROGRAM BY EQU'S.\n.*\n.*\n         LCLC  &LOOP,&SETLINK\n         ACTR  50\n&LOOP    SETC  '&SYSECT'(1,2).'&SYSNDX'.'LP' . MAKE UP A LOOPING NAME.\n&SETLINK SETC  '&LOOP'(1,6).'SL' .   MAKE UP A BRANCHING NAME.\n&LABEL   LA    &RGW(1),&HDR .     ADDR OF HEADER TO WORK REGISTER 1.\n&LOOP    LR    &RGW(2),&RGW(1) .  SAVE IT FOR LINKING.\n         L     &RGW(1),LINK(,&RGW(1)) . POINTER TO NEXT NODE.\n         LTR   &RGW(1),&RGW(1) .  SET CONDITION CODE TO SEE IF THIS IS\n         BZ    &SETLINK .            THE LAST NODE.  IF SO, BRANCH.\n         CLC   &KO.(&KL,&RGW(1)),&KO.(&RND) . IS THIS THE PLACE TO PUT\n         BNH   &LOOP .            NODE IN?  IF NOT GO PROCESS NEXT NODE\n&SETLINK ST    &RGW(1),LINK(,&RND) . SET NEW NODE POINTER TO NEXT NODE\n.*                                   IN ORIGINAL SEQUENCE.\n         ST    &RND,LINK(,&RGW(2)) . SET NODE POINTER IN NODE BEFORE\n.*                                   INSERTED NEW NODE TO POINT TO\n.*                                   NEW NODE.\n         MEND\n         TITLE 'QSNAP MACRO - PRINT THE CONTENTS OF A LIST'\n         MACRO\n&LABEL   QSNAP &HDR,&MSG,&RGW=(RWK1,RWK2),&COUNT=4095,&LEN=20\n.*\n.*\n.*THIS MACRO DUMPS THE LIST BEGINNING AT THE HEADER &HDR, USING XSNAP\n.*  WITH A MESSAGE &MSG PRINTED.  THE WORK REGISTERS NEEDED ARE GIVEN\n.*  BY &RGW, AND UP TO &COUNT NODES ARE PRINTED.\n.*&HDR IS NAME OF LIST HEADER.\n.*&MSG IS QUOTED STRING USED AS TITLE FOR LIST OUTPUT.\n.*&RGW SPECIFIES NAMES/NUMBERS OF 2 REGISTERS WHICH MAY BE ERASED.\n.*&COUNT SPECIFIES THE MAXIMUM NUMBER OF NODES TO BE PRINTED.\n.*&LEN IS AN ABSOLUTE EXPRESSION GIVING NODE LENGTH IN BYTES.\n.*NOTICE RWK1 AND RWK2 ARE ASSUMED TO BE SET IN MAIN PROGRAM BY EQU'S\n.*MACROS REQUIRED: QNEXT,XSNAP.\n.*\n.*\n         LCLC  &LOOP,&ENDADDR\n         ACTR  50\n&ENDADDR SETC  '&SYSECT'(1,2).'&SYSNDX'.'EN' . UNIQUE BRANCH NAME.\n&LOOP    SETC  '&ENDADDR'(1,6).'LP' . UNIQUE LOOPING NAME.\n&LABEL   LA    &RGW(1),&COUNT .   SET MAXIMUM NODES TO BE PRINTED.\n         LA    &RGW(2),&HDR .     GET ADDRESS OF LIST HEADER.\n&LOOP    QNEXT &RGW(2),END=&ENDADDR . GO TO NEXT NODE.\n         XSNAP LABEL=&MSG,T=NO,STORAGE=(*0(&RGW(2)),*&LEN.(&RGW(2)))\n         BCT   &RGW(1),&LOOP .    LOOP BACK TO GO TO NEXT NODE.\n&ENDADDR EQU   *\n         MEND\n         SPACE 2\n*              DUMMY MACROS TO SPEED PROCESSSING.\n         MACRO\n         GETMAIN\n*              SAVE FROM XSAVE.\n         MEND\n         MACRO\n         FREEMAIN\n*        SAVE FROM XRETURN.\n         MEND\n         MACRO\n         XSNAP\n         XSNAP &LABEL=,&STORAGE=,&T=,&IF=\n         XDUMP\n         MEND\n*SYSLIB XSAVE,XRETURN,EQUREGS\n         TITLE 'TEST LIST MACROS MAIN PROGRAM'\n         SPACE 3\nTENODES  DSECT\nTELINK   DS    A                  LINK TO NEXT NODE.\nTEKEY    DS    CL8                KEY ORDERING FIELD.\nTEDATA   DS    CL12               NODE'S DATA.\nNODELEN  EQU   ((*-TELINK+3)/4)*4    NODE LENGTH, TO A 4-MULTIPLE.\n         SPACE 3\n         SPACE 2\n*THIS TEST PROGRAM DOES THE FOLLOWING:\n*  1)DEFINES A LIST OF 15 EMPTY NODES CALLED FREE LIST, EACH WITH\n*  8-BYTE KEY AND 12-BYTE DATA AREAS.  ALSO DEFINES TWO EMPTY LISTS,\n*  LISTA AND LISTB.  (I.E. THESE ARE NAMES OF HEADERS).\n*  2)READS IN 10 DATA CARDS, EACH OF WHICH CONTAINS KEY AND DATA FOR\n*  A SINGLE NODE IN COLUMNS 1-20.  AFTER EACH CARD IS READ, AN EMPTY\n*  NODE IS OBTAINED FROM THE FREE LIST, FILLED WITH THE KEY AND DATA\n*  JUST READ (AND A DSECT IS USED TO REFER TO THESE FIELDS AT THIS\n*  POINT), THEN IT IS ENTERED IN LISTA.\n*  3)DUMPS LISTS FREE, LISTA, AND LISTB.\n*  4)READS IN 5 CARDS, EACH WITH A KEY VALUE ON COLUMNS 1-8.  SEARCHES\n*  LISTA FOR THE SAME KEY VALUE.  IF NOT FOUND, PRINTS A MESSAGE.\n*  IF FOUND, FIRST REMOVES THE NODE FROM LISTA, THEN PUSHES IT ONTO\n*  BEGINNING OF LISTB.\n*  5)POPS EACH NODE OF LISTA, PRINTS EACH AS IT IS OBTAINED, THEN\n*  PLACES THE NODE BACK ONTO THE FREE LIST, UNTIL LISTA IS EMPTY.\n*  6)PERFORMS SAME ACTION AS IN 5, BUT FOR LISTB.\n*MACROS REQUIRED: XSNAP, XPRNT.\n         SPACE 2\n         PRINT NOGEN\n         EQUREGS\nLINK     EQU   0                  OFFSET OF THE LINK FIELD IN A NODE.\nKEYO     EQU   4                  COMMON OFFSET TO KEY FIELD.\nKEYL     EQU   8                  MOST COMMON KEY LENGTH.\nRWK1     EQU   5                  TEMPORARY WORK REG.\nRWK2     EQU   6                  ANOTHER TEMPORARY WORK REG.\nTESTLIST CSECT\n         XSAVE ,                  ESTABLISH ENTRY LINKAGE, BASE=R12.\n         SPACE 2\n*READ IN 10 CARDS AND INSERT THEM IN LISTA.\n         SPACE 2\n         LA    R2,10              NUMBER OF CARDS TO BE READ.\n         PRINT NOGEN\n         XPRNT =CL80'-HERE ARE THE 10 CARDS TO GO ONTO LIST A:',80\nTEREAD1  XREAD TECARD,20          GET A CARD.\n         XPRNT TECC,TECHOLEN      ECHO PRINT THE CARDS.\n         PRINT GEN\n         QPOP  R3,TEFREE,END=TEDUMMY  GET A FREE NODE, TEST END FEATURE\n         USING TENODES,R3         DESECT SET UP TO MOVE DATA.\nTEDUMMY  MVC   TEKEY,TECARDK      KEY IN FREE NODE GETS KEY ON CARD.\n         MVC   TEDATA,TECARDD     DATA IN FREE NODE GETS DATA ON CARD.\n         QSRCH R3,TELISTA         INSERT THIS NODE IN LIST A.\n         XSNAP STORAGE=(TEFREE,TECARDMS),IF=(R2,H,=F'6',C)\n         BCT   R2,TEREAD1         HAVE 10 CARDS BEEN READ?\n         DROP  R3\n         SPACE 2\n*DUMP LISTS FREE, LISTA, AND LISTB.\n         SPACE 2\n         QSNAP TEFREE,'LIST OF FREE NODES',COUNT=16,LEN=NODELEN\n         QSNAP TELISTA,'LIST A',COUNT=16,LEN=NODELEN\n         QSNAP TELISTB,'LIST B',COUNT=16,LEN=NODELEN\n         SPACE 2\n*READ IN 5 CARDS, SEARCH LISTA FOR THAT KEY, IF NOT FOUND, PRINT A\n*  MESSAGE SAYING SO; IF FOUND, MOVE THE NODE FROM LIST A TO LIST B.\n         SPACE 2\n         LA    R2,5               NUMBER OF CARDS TO BE READ IN.\n         PRINT NOGEN\n         XPRNT =CL80'-HERE ARE THE 5 CARDS TO BE LIST A SEARCHED:',80\nTEREAD2  XREAD TECARD,20          GET CARD.\n         XPRNT TECC,TECHOLEN      ECHO PRINT THE CARD.\n         PRINT GEN\n         LA    R3,TELISTA         BEGINNING OF LIST TO BE SEARCHED.\nTENEXT   QNEXT R3,RLK=RWK1,END=TELAST1\n         CLC   TECARDK,4(R3)      IF THE NODE KEY AND THE INPUT CARD\n         BE    TEFOUND               KEY ARE SAME, THERE IS A MATCH.\n         B     TENEXT             GO BACK TO LOOK AT NEXT NODE.\nTELAST1  CLC   TECARDK,4(R3)      IF THE NODE KEY AND THE INPUT CARD\n         BE    TEFOUND               KEY ARE SAME, THERE IS A MATCH.\n         PRINT NOGEN\n         XPRNT TECC,TEMSGLEN      PRINT A NOT FOUND MESSAGE.\n         PRINT GEN\n         B     TENEWCRD           GO PROCESS NEXT CARD, IF ANY.\nTEFOUND  MVC   LINK(4,RWK1),LINK(R3) REMOVE FOUND NODE FROM LIST.\n         QPUSH R3,TELISTB         INSERT FOUND NODE IN LIST.\n         XSNAP STORAGE=(TEFREE,TECARDMS)\nTENEWCRD BCT   R2,TEREAD2         GO READ NEXT CARD TO BE SEARCHED.\n         SPACE 2\n*POP EACH NODE OF LISTA AND PRINT AS OBTAINED, THEN PUT ON FREE LIST.\n         SPACE 2\n         PRINT NOGEN\n         XPRNT =CL40'0LIST A FOLLOWS:',40\n         PRINT GEN\nTEPOPA   QPOP  R3,TELISTA,END=TESTOPOP\n         MVC   TEPRNODE(NODELEN-4),4(R3) MOVE TO PRINT AREA LESS LINK.\n         PRINT NOGEN\n         XPRNT TECCPN,TECCPNL     PRINT THE NODE.\n         PRINT GEN\n         B     TEPOPA             GO BACK TO POP NEXT NODE.\n         PRINT NOGEN\n         SPACE 2\n*POP EACH NODE OF LISTB AND PRINT AS OBTAINED, THEN PUT ON FREE LIST.\n         SPACE 2\nTESTOPOP XPRNT =CL40'0LIST B FOLLOWS:',40\n         PRINT GEN\nTEPOPB   QPOP  R3,TELISTB,END=TESTOPB  TAKE A NODE OFF LIST B.\n         MVC   TEPRNODE(NODELEN-4),4(R3)  MOVE TO PRINT AREA LESS LINK.\n         PRINT NOGEN\n         XPRNT TECCPN,TECCPNL     PRINT THIS NODE.\n         PRINT GEN\n         B     TEPOPB             GO BACK TO POP NEXT NODE.\n         PRINT NOGEN\nTESTOPB  XRETURN SA=*\n         PRINT  GEN\n         DROP  12\n         SPACE 3\n         LTORG\n         SPACE 3\nTEFREE   QHED  TELIST1            HEADER FOR LIST OF FREE NODES.\nTELIST1  QDEFL 15,NODELEN,'FREE NODES FOR TEST'\nTELISTA  QHED  ,                  HEADER FOR LIST A.\nTELISTB  QHED  ,                  HEADER FOR LIST B.\nTECC     DC    CL1'0'             CARRIAGE CONTROL FOR PRINTING CARDS.\nTECARD   EQU   *                  CARD IMAGE AREA HAS 2 NAMES.\nTECARDK  DC    CL8' '             CARD IMAGE KEY.\nTECARDD  DC    CL12' '            CARD IMAGE DATA.\nTECHOLEN EQU   *-TECC             LENGTH OF ECHO PRINT MESSAGE.\nTECARDMS DC    CL24' MATCHING NODE NOT FOUND'\nTEMSGLEN EQU   *-TECC             LENGTH OF PRINT MESSAGE.\n         SPACE 2\nTECCPN   DC    CL1' '             NODE PRINT CARRIAGE CONTROL CHAR.\nTEPRNODE DC    CL132' '           NODE PRINT AREA.\nTECCPNL  EQU   *-TECCPN           LENGTH OF THE NODE PRINT LINE.\n         END   TESTLIST\n$ENTRY\nCCCCCCCCTEST CARD 1\nAAAAAAAATEST CARD 2\nDDDDDDDDTEST CARD 3\nFFFFFFFFTEST CARD 4\nBBBBBBBBTEST CARD 5\nZZZZZZZZTEST CARD 6\nXXXXXXXXTEST CARD 7\nGGGGGGGGTEST CARD 8\nKKKKKKKKTEST CARD 9\nEEEEEEEETEST CARD 10\nNOTFOUNDTEST CARD 11\nZZZZZZZZTEST CARD 12\nAAAAAAAATEST CARD 13\nAAAAAAAATEST CARD 14\nKKKKKKKKTEST CARD 15\n$JOB ASSIST MACRO=F\n         TITLE '*** DCBDUMP - FORMATTED DUMP OF DATA CONTROL BLOCK ***'\n         MACRO\n         IHBERMAC\n         MEND\n*SYSLIB DCBD\n         PRINT NOGEN\n*\n*        SET UP SYMBOLIC NAMES FOR SYSTEM CONTROL BLOCKS\n*        USING I-B-M STANDARD MACROS TO AVOID PROBLEMS WITH\n*              FUTURE OPERATING SYSTEMS.\n*\n*\n         DCBD  DSORG=PS\n         SPACE 4\nIHACVT   DSECT\nCVTTCBP  DS    F\nCVTPTR   EQU   16\n         SPACE 4\nIHATCBP  DSECT\nTCBPNTCB DS    F\nTCBPCTCB DS    F\n         SPACE 4\nIHATCB   DSECT\n         DS    3F\nTCBTIO   DS    F\n         SPACE 4\nIHATIOT  DSECT\n         DS    F\n         SPACE 3\nBS       DSECT ,                   BYTE SCANER PARM FIELD\nBSBYTE   DS    A                   ADRS OF BYTE TO BE SCANNED\nBSOUT    DS    A                   START ADRS OF OUTPUT FIELD\nBSLIST   DS    A                   LIST HEADER OF OPTION DESCRIPTION\nBSLEN    DS    F                   EFFECTIVE LENGTH OF OUTPUT FIELD\nBSADD    DS    F                   SPACE BETWEEN OUTPUT FIELDS\n         SPACE 3\nBITFLG   DSECT ,                   BIT PATTERN DESCRIPTION\nBFLINK   DS    A                   LINK TO NEXT NODE\nBFMASK   DS    C                   MASK ON SOURCE BYTE\nBFMATCH  DS    C                   PATTERN BEING CHECKED FOR\nBFOUT    DS    0C                  MESSAGE FOR THIS BIT PATTERN\n         EJECT\nDCBDUMP  CSECT\n         USING *,15\n         STM   0,15,SAVEALL        SAVE ALL REGS\n         CNOP  0,4\n         BAL   13,PGMSTART\n         DROP  15\n         USING *,13\n         DC    18F'0'\nSAVEALL  DS    16F\nPGMSTART EQU   *\n         ST    1,SAVEPARM\n         L     Z,0(1)                  LOAD ADDRESS OF D-C-B\n         USING IHADCB,Z                ADDRESSABILITY WITH DCBD\n         SPACE 10\n*        FIND DDNAME AND STATUS\n*\n         MVC   STATUS(3),=C'NOT'\n         LA    A,DCBDDNAM\n         TM    DCBOFLGS,X'10'\n         BZ    CLOSED\n         L     A,CVTPTR                CVT POINTER\n         USING IHACVT,A\n         L     A,CVTTCBP               ADDRESS OF T-C-B\n         USING IHATCBP,A\n         L     A,TCBPCTCB\n         USING IHATCB,A\n         L     A,TCBTIO                ADDRESS OF T-I/O-T\n         USING IHATIOT,A\n         LH    B,DCBTIOT               T-I/O-T OFFSET\n         LA    A,4(A,B)\n         MVC   STATUS(3),STATUS-1\nCLOSED   MVC   DDNAME(8),0(A)\n*\n         XPRNT LINE1,LEN1\n         EJECT\n         XPRNT HEADER2\n         LA    A,96(Z)             END OF D-C-B\n         ST    A,ENDDCB\n         LM    A,C,=A(DUMPLINE+20,9,DUMPLINE+47)\n         LR    E,Z\nOUTLOOP  LR    D,A\nINLOOP   UNPK  0(9,D),0(5,E)\n         MVI   8(D),X'FE'\n         LA    E,4(E)\n         BXLE  D,B,INLOOP\n         TR    DUMPLINE+20(36),HEXTAB\n         XPRNT DUMPLINE\n         C     E,ENDDCB\n         BL    OUTLOOP\n         EJECT\n*        BLKSIZE, LRECL, RECFM\n*\n*              BLOCK SIZE\n         LH    A,DCBBLKSI\n         CVD   A,DWORD\n         MVC   BLKSIZE(6),EDIT\n         ED    BLKSIZE(6),DWORD+5\n*              LOGICAL RECORD LENGTH\n         LH    A,DCBLRECL\n         CVD   A,DWORD\n         ED    LRECL(6),DWORD+5\n*              RECORD FORMAT\n         SR    A,A\n         IC    A,DCBRECFM\n         SRL   A,6\n         LA    A,FORMATS(A)\n         MVC   RECFM(1),0(A)\n         LA    A,RECFM+1\n         TM    DCBRECFM,B'00100000'\n         BZ    *+12\n         MVI   0(A),C'T'\n         LA    A,1(A)\n         TM    DCBRECFM,B'00010000'\n         BZ    *+12\n         MVI   0(A),C'B'\n         LA    A,1(A)\n         IC    B,DCBRECFM\n         SLL   B,29\n         SRL   B,31\n         LA    B,PCCC(B)\n         MVC   0(1,A),0(B)\n         SPACE 3\n* MACRO FORMAT,ACCESS METHOD\n         MVC   MACRF,BLANKS\n         SPACE 1\n         TM    DCBMACR,B'10000000' TEST FOR EXCP\n         BO    EXCP\n         SPACE 1\n         TM    DCBMACR,B'11000000' TEST FOR BSAM\n         BNZ   NOTBSAM\n         TM    DCBMACR+1,B'11000000'\n         BZ    BSAM\nNOTBSAM  EQU   *\n         SPACE 1\n         TM    DCBMACR,B'10100000' CHECK FOR QSAM\n         BNZ   NOTQSAM\n         TM    DCBMACR+1,B'10100000'\n         BZ    QSAM\nNOTQSAM  EQU   *\n         SPACE 1\n         MVC   ACCESS,=CL8' INVALID'\n         B     MACRFXX\n         SPACE 1\nEXCP     MVC   ACCESS,=CL8'    EXCP'\n         B     MACRFXX\n         SPACE 1\nBSAM     MVC   ACCESS,=CL8'    BSAM'\n         LM    A,B,=A(MAC1BS1,MAC2BS1)\n         B     MACRFDMP\n         SPACE 1\nQSAM     MVC   ACCESS,=CL8'    QSAM'\n         LM    A,B,=A(MAC1QS1,MAC2QS1)\n*        B     MACRFDMP\n         SPACE 1\nMACRFDMP LR    1,A                 BYTE 1 MACRF CODES\n         LA    D,DCBMACRF          ADRS OF DCBMACRF\n         ST    D,0(1)              STORE FOR BYTESCAN\n         BAL   14,BYTESCAN\n         L     C,NEXTADRS\n         MVC   0(C),C','\n         LA    C,1(C)\n         LR    1,B                 BYTE 2 MACRF CODES\n         USING BS,1\n         ST    C,BSOUT\n         DROP  1\n         LA    D,DCBMACRF+1\n         ST    D,0(1)\n         BAL   14,BYTESCAN\n         L     C,NEXTADRS\n         MVC   0(C),C')'\nMACRFXX  EQU   *\n*\n         XPRNT LINE2,LEN2\n         MVC   RECFM(5),RECFM-1\n         EJECT\n*        BFALN, BFTEK, BUFCB, BUFL, BUFNO\n*\n*              BUFFER ALIGNMENT\n         IC    A,DCBBFALN\n         SLL   A,30\n         SRL   A,27\n         LA    A,ALIGN(A)\n         MVC   BFALN(5),0(A)\n*              BUFFERING TECHNIQUE\n         IC    A,DCBBFTEK\n         SLL   A,25\n         SRL   A,29\n         LA    A,TECH(A)\n         MVC   BFTEK(1),0(A)\n*              BUFFER CONTROL BLOCK ADDRESS\n         L     A,DCBBUFCB\n         LA    A,0(A)\n         ST    A,FULL\n         UNPK  DWORD(7),FULL+1\n         TR    DWORD(6),HEXTAB\n         MVC   BUFCB(6),DWORD\n*              BUFFER LENGTH\n         LH    A,DCBBUFL\n         CVD   A,DWORD\n         MVC   BUFL(6),EDIT\n         ED    BUFL(6),DWORD+5\n*              NUMBER OF BUFFERS\n         SR    A,A\n         IC    A,DCBBUFNO\n         CVD   A,DWORD\n         MVC   BUFNO(4),EDIT\n         ED    BUFNO(4),DWORD+6\n*\n         XPRNT LINE3,LEN3\n         EJECT\n*        DSORG, EODAD, EROPT\n*\n*              DATA SET ORGANIZATION\n         LA    1,DCBDSORG\n         MVC   LRECL(6),EDIT\n         BAL   14,BASE2\n         SLL   1,1\n         LA    A,ORGANS(1)\n         MVC   DSORG(2),0(A)\n*              END OF DATA ADDRESS\n         L     A,DCBEODAD\n         LA    A,0(A)\n         ST    A,FULL\n         UNPK  DWORD(7),FULL+1(4)\n         TR    DWORD(6),HEXTAB\n         MVC   EODAD(6),DWORD\n*              ERROR OPTION\n         LA    1,DCBEROPT\n         BAL   14,BASE2\n         SLL   1,2\n         LA    A,ERRORS(1)\n         MVC   EROPT(3),0(A)\n         SPACE 3\n* DCBOPTCD\n         MVC   OPTCD,BLANKS\n         L     1,=A(DMPOPTCD)\n         LA    A,DCBOPTCD\n         ST    A,0(1)\n         BAL   14,BYTESCAN\n*\n         XPRNT LINE4,LEN4\n         SPACE 3\n*\n*        OUTPUT DCB CIND FLAGS\n*\n* CLEAR OUTPUT BUFFER\n         LM    A,B,=A(CINDOUT,CINDSAVE)\n         MVC   0(133,A),0(B)\n         LM    A,C,=A(CINDOUT+133,133,CINDOUT+7*133)\n         MVI   0(A),C' '\nCINDBLNK MVC   1(133,A),0(A)\n         BXLE  A,B,CINDBLNK\n         SPACE 1\n* CALL BYTESCAN SUBROUTINE TO FILL IN OUTPUT FIELDS\n         L     1,=A(DMPCND1)\n         LA    A,DCBCIND1          ADRS OF CIND 1 BYTE\n         ST    A,0(1)              STORE IN PARM FOR BYTESCAN\n         BAL   14,BYTESCAN\n         L     1,=A(DMPCND2)\n         LA    A,DCBCIND2          ADRS OF CIND BYTE 2\n         ST    A,0(1)              STORE IN PARM FOR BYTESCAN\n         BAL   14,BYTESCAN\n         SPACE 1\n* PRINT OUTPUT BUFFER\n         LM    A,C,=A(CINDOUT,133,CINDOUT+7*133)\nCINDPRNT XPRNT 0(A),133\n         BXLE  A,B,CINDPRNT\n         EJECT\n*              THAT'S ALL FOLKS\n         L     1,SAVEPARM          PARM LIST ADRS\n         CLI   0(1),X'80'          END OF LIST\n         BE    PGMEXIT\n         LA    1,4(1)              NEXT LIST ELEMENT\n         B     PGMSTART\n         SPACE 1\nPGMEXIT  LM    0,15,SAVEALL\n         SPM   14\n         BR    14\n         SPACE 10\nBYTESCAN DS    0H\n         STM   14,12,12(13)\n         USING BS,1\n         LM    A,E,BS              LOAD PARM REGS\n         USING BITFLG,C\nBSLOOP   MVC   BSWORK,0(A)         WORK ON SOURCE BYTE\n         NC    BSWORK,BFMASK       PATTERN MASK\n         CLC   BSWORK,BFMATCH      COMPARE WITH WANTED PATTERN\n         BNE   BSNEXT                   NO MATCH\n         EX    D,MVC1              MOVE MESSAGE TO OUTPUT FIELD\n         AR    B,E                 NEXT ADRS IN OUTPUT BUFFER\nBSNEXT   L     C,BFLINK            NEXT NODE ADRS\n         LTR   C,C                 END OF LIST ???\n         BNZ   BSLOOP                   NO\n         ST    B,NEXTADRS\n         LM    14,12,12(13)\n         BR    14\nMVC1     MVC   0(*-*,B),BFOUT      MOVE MESSAGE TO OUTPUT FIELD\nNEXTADRS DS    A                   NEXT ADRS OF OUTPUT BUFFER\nBSWORK   DS    CL1\n         SPACE 10\nA        EQU   3\nB        EQU   4\nC        EQU   5\nD        EQU   6\nE        EQU   7\nF        EQU   8\nZ        EQU   11\n*\nLINE     DC    10C' '\n         DS    8CL9\nLEN      EQU   *-LINE\n*\nDWORD    DS    D\nEDIT     DC    C' ',15X'20'\nFULL     DS    F\nHEXTAB   EQU   *-239\n         DC    C' 0123456789ABCDEF'\nLINE1    DC    0D'0',C'0'\n         DC    C'DDNAME='\nDDNAME   DC    CL8' ',C' '\nSTATUS   DC    CL3' ',C' OPEN'\nLEN1     EQU   *-LINE1\n         DC    (133-LEN1)C' '\n         SPACE 1\nLINE2    DC    0D'0',C'0'\n         DC    C' BLKSIZE='\nBLKSIZE  DC    CL6' '\n         DC    C' LRECL='\nLRECL    DC    CL6' '\n         DC    C' RECFM='\nRECFM    DC    CL5' '\nACCESS DC CL8' ',C' ACCESS METHOD'\n         DC    C' MACRF=('\nMACRF    DC    CL14' '\nLEN2     EQU   *-LINE2\n         DC    (133-LEN2)C' '\n         SPACE 1\nLINE3    DC    0D'0',C'0'\n         DC    C' BFALN='\nBFALN    DC    CL5' '\n         DC    C' BFTEK='\nBFTEK    DC    CL1' '\n         DC    C' BUFCB='\nBUFCB    DC    CL6' '\n         DC    C' BUFL='\nBUFL     DC    CL6' '\n         DC    C' BUFNO='\nBUFNO    DC    CL4' '\nLEN3     EQU   *-LINE3\n         DC    (133-LEN3)C' '\n         SPACE 1\nLINE4    DC    0D'0',C'0'\n         DC    C' DSORG='\nDSORG    DC CL3' '\n         DC    C' EODAD='\nEODAD    DC    CL6' '\n         DC    C' EROPT='\nEROPT    DC    CL3' '\n         DC    C' OPTCD='\nOPTCD    DS    CL8\nLEN4     EQU   *-LINE4\n         DC    (133-LEN4)C' '\nALIGN    DC    CL8' ',CL8'F-DCB',CL8'D',CL8'F-DD'\nTECH     DC    C' ERES A '\nFORMATS  DC    C' VFU'                 RECORD FORMATS\nPCCC     DC    C' MA '                 PRINTER CARRIAGE CONTROL CHAR\nBLANKS   DC    256C' '\nORGANS   DC    C'  ISPSDA******POU **'\nERRORS   DC    C'    ACC SKP ABE ',6C'*** '\n         EJECT\nBASE2    LA    A,8\nBTEST    LA    B,POWERS(A)\n         CLC   0(1,B),0(1)\n         BE    BOKAY\n         BCT   A,BTEST\n         LA    A,9\nBOKAY    LR    1,A\n         BR    14\nPOWERS   DC    AL1(0,128,64,32,16,8,4,2,1)\nSAVEPARM DS    A                   PARM LIST ADRS\nENDDCB   DS    A                   END OF D-C-B\nHEADER2  DC    CL133'0CORE IMAGE        +0       +4       +8       +12(\\\n               C)'\nDUMPLINE DC    CL133'             DD(XX)'\n*\n         LTORG\nDMPCND1  DC    A(DCBCIND1-IHADCB,CINDOUT+10,CND1LST1,49,133)\nDMPCND2  DC    A(DCBCIND2-IHADCB,CINDOUT+76,CND2LST1,49,133)\nCND1LST1 DC    A(CND1LST2),X'80',X'80',CL50'TRACK OVERFLOW - NO DATA WR\\\n               ITTEN'\nCND1LST2 DC    A(CND1LST3),X'40',X'40',CL50'SEARCH DIRECT'\nCND1LST3 DC    A(CND1LST4),X'20',X'20',CL50'END OF VOLUMNE - EOB'\nCND1LST4 DC    A(CND1LST5),X'10',X'10',CL50'END OF VOLUMNE - CHANNEL EN\\\n               D APPENDAGE'\nCND1LST5 DC    A(CND1LST6),X'01',X'01',CL50'EXCHANGE BUFFERING SUPPORTE\\\n               D'\nCND1LST6 EQU   0\nCND2LST1 DC    A(CND2LST2),X'80',X'80',CL50'STOW PREFORMED'\nCND2LST2 DC    A(CND2LST3),X'40',X'40',CL50'LAST I/O WAS WRITE RECORD 0\\\n               '\nCND2LST3 DC    A(CND2LST4),X'20',X'20',CL50'CLOSE IN PROGRESS'\nCND2LST4 DC    A(CND2LST5),X'10',X'10',CL50'PERMANENT I/O ERROR'\nCND2LST5 DC    A(CND2LST6),X'08',X'08',CL50'OPEN ACQUIRED BUFFER POOL'\nCND2LST6 DC    A(CND2LST7),X'04',X'04',CL50'CHAINED SCHEDULING SUPPORTE\\\n               D'\nCND2LST7 DC    A(CND2LST8),X'02',X'02',CL50'F-E-O-V BIT'\nCND2LST8 DC    A(CND2LST9),X'01',X'01',CL50'THIS IS A QSAM DCB'\nCND2LST9 EQU   0\nCINDSAVE DC    C'0',CL66'DCBCIND1',CL66'DCBCIND2'\nCINDOUT  DS    8CL133\n         SPACE\nDMPOPTCD DC    A(DCBOPTCD-IHADCB,OPTCD,OPTCD1,0,1)\nOPTCD2   DC    A(OPTCD3),X'40',X'40',C'U'\nOPTCD3   DC    A(OPTCD4),X'20',X'20',C'C'\nOPTCD4   DC    A(OPTCD5),X'10',X'10',C'H'\nOPTCD5   DC    A(OPTCD6),X'08',X'08',C'Q'\nOPTCD6   DC    A(OPTCD7),X'04',X'04',C'Z'\nOPTCD7   DC    A(OPTCD8),X'02',X'02',C'T'\nOPTCD8   EQU   0\n         SPACE 1\nMAC1BS1  DC    A(MAC1BS2),X'2020',C'R'\nMAC1BS2  DC    A(MAC1BS3),X'0404',C'P'\nMAC1BS3  DC    A(MAC1BS4),X'0202',C'C'\nMAC1BS4  EQU   0\n         SPACE 1\nMAC2BS1  DC    A(MAC2BS2),X'2020',C'W'\nMAC2BS2  DC    A(MAC2BS3),X'0808',C'L'\nMAC2BS3  DC    A(MAC2BS4),X'0404',C'P'\nMAC2BS4  DC    A(MAC2BS5),X'0202',C'C'\nMAC2BS5  DC    A(MAC2BS6),X'0101',C'X'\nMAC2BS6  EQU   0\n         SPACE 1\nMAC1QS1  DC    A(MAC1QS2),X'4040',C'G'\nMAC1QS2  DC    A(MAC1QS3),X'1010',C'M'\nMAC1QS3  DC    A(MAC1QS4),X'0808',C'L'\nMAC1QS4  DC    A(MAC1QS5),X'0404',C'T'\nMAC1QS5  DC    A(MAC1QS6),X'0202',C'C'\nMAC1QS6  DC    A(MAC1QS7),X'0101',C'D'\nMAC1QS7  EQU   0\n         SPACE 1\nMAC2QS1  DC    A(MAC2QS2),X'4040',C'P'\nMAC2QS2  DC    A(MAC2QS3),X'1010',C'M'\nMAC2QS3  DC    A(MAC2QS4),X'0808',C'L'\nMAC2QS4  DC    A(MAC2QS5),X'0404',C'T'\nMAC2QS5  DC    A(MAC2QS6),X'0202',C'C'\nMAC2QS6  DC    A(MAC2QS7),X'0101',C'D'\nMAC2QS7  EQU   0\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ASTEST05": {"ttr": 23815, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x132?\\x01\\x132?\\x010\\x01+\\x01+\\x00\\x00\\xc1\\xe2\\xe2\\xc9\\xe2\\xe3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-11-19T00:00:00", "modifydate": "2013-11-19T01:30:00", "lines": 299, "newlines": 299, "modlines": 0, "user": "ASSIST"}, "text": "//ASTEST05 JOB (SYS),'ASSIST IVP TEST #5',CLASS=S,MSGCLASS=X\n//*\n//TESTPROG EXEC ASSIST\n//SYSIN DD *\n$JOB     ASSIST XREF=3\n*        THIS IS A TEST PROGRAM FOR THE NEW XOPC INSTRUCTION OF THE\n*        ASSIST EXTENDED INTERPRETER.  IT TESTS XOPC #'S 0,1,2,4 AND 21\n         SPACE 2\nMAIN     CSECT\n         STM   14,12,12(13)        SAVE THOSE REGISTERS\n         BALR  12,0\n         USING *,12\n         LA    1,ABCODE            GET ADDRESS OF ABEND CODE IN REG 1\n         SR    0,0                 GET ZERO IN R2\n         O     0,=XL4'00004F00'    TURN ON PROPER BITS FOR ABEND\n         XOPC  0                   SET SPIES OC1,4,5,6 AND 7\n         LA    5,10\n         LA    7,15\n         DC    X'00000000'         BLOW UP WITH AN OC1\nNEXTEX   EQU   *\n         XDUMP\n         LA    1,ABCODE            GET ASDDR OF TOP OF TRACE\n         LA    0,NEXTEX            GET ADR OF BOTTOM OF THE TRACE\n         XOPC  1                   SET TRACE ADDRESSES\n         XOPC  2                   TURN ON THE TRACE\n         BZ    OKXOPC              IF CONDITION CODE OK BRANCH\n         XPRNT =CL33'0XOPC RETURNED A BAD CONDITION CODE ',33\n         XDUMP\n         B     RETURN              BAG THIS TEST\nOKXOPC   XPRNT =CL27'0THIS IS THE TRACED LOOP',27\n         XDUMP\n         BCT   5,OKXOPC            BRANCH INTO A LOOP 10 TIMES.\n         XOPC  4                   LOOP FINISHED TURN OFF THE TRACE\n         BZ    RETURN              TEST CC AGAIN\nABCODE   EQU   *                   THE SPIE EXIT CODE\n         XDUMP ,                   DUMP THE REGS\n         XPRNT =CL40'0HI  WE ARE IN THE ABEND CODE     ',40\n         LA    1,NEXTEX            GET ADDR OF RESUMING INSTR\n         XOPC  21                  RESUME NORMAL EXECUTION\nRETURN   EQU   *\n         XOPC  21                  TEST THE CC AGAIN\n         BL    RETURNA\n         XPRNT =CL13'0BAD CC AGAIN',13\nRETURNA  EQU   *\n         LM    14,12,12(13)        RELOAD THOSE REGISTERS\n         BR    14\n         LTORG\n         END\n$ENTRY\n$JOB     ASSIST XREF=1\n*              THIS IS A TEST PROGRAM FOR THE NEW XOPC INSTRUCITON\n*              OF THE ASSIST EXTENDED INTERPRETER.  IT TESTS XOPC #'S\n*              0,3,4,11,14,15 AND 21\nMAIN     CSECT                     THIS IS XPOPC TEST PROGRAM #2\n         STM   14,12,12(13)        SAVE THOSE REGISTERS\n         BALR  12,0\n         USING *,12\n         SR    0,0                 ZERO OUT REG 0 FOR XOPC SPIE SET\n         O     0,=XL4'00004F00'    SET UP ZERO SO SOC 1 ,4,5,6,AND 7 A\n         LA    1,ABCODE            GET ADDRESS OF ABEND CODE\n         XOPC  0                   SET SPIE EXIT ADDRESS\nLOWADDR  EQU   *\n         LA    0,LOWADDR           GET LOW ADDRESS FOR THE TRACE\n         LA    1,AFTERCL           GET HIGH ADDRESS FOR THE TRACE\n         XOPC  3\n         LA    0,CLOCKEX           SET CLOCK EXIT ADDRESS\n         XOPC  15                  SET UP A CLOCK EXIT\n         XDUMP ,                   GET THOSE REGS\n         XOPC  11                  FETCH INSTRUCTION COUNTER\n         S     0,=F'40'            DECREMENT COUNTER BY 40\n         XOPC  14                  SET A CLOCK INTERRUPT FOR 40 INSTRS\n         SR    5,5\nSOCLOOP  EQU   *                   THIS LOOP FORCES A SOCK 4\n         LA    5,200(5)\n         ST    5,0(5)\n         BCT   5,SOCLOOP           LOOP BACK UNTIL ABEND OCCURS\nNEXTEX   EQU   *                   INSTRUCTION THAT RESUMES NORMAL EXEC\n         XDUMP\n         LA    5,40                FORCE A CLOCK EXIT TO OCCUR\nCLOCKLP  EQU   *\n         XDUMP\n         XPRNT =CL45'0WE ARE IN A LOOP TO CAUSE A CLOCK INTERRUPT',45\n         BCT   5,CLOCKLP\nAFTERCL  EQU   *\n         L     0,=F'-1'\n         XOPC  14\n         XOPC  4                   TURN OFF THE CLOCK AND THE TRACE\n         B     RETURN\nCLOCKEX  EQU   *\n         XDUMP\n         XPRNT =CL50'0WE ARE HANDLING A CLOCK INTERRRUPT',50\n         B     AFTERCL\nABCODE   EQU   *                   SPIE EXIT CODE\n         XDUMP\n         XPRNT =CL75'0HANDLING A SPIE CAUGHT INTERRUPT',75\n         LA    1,NEXTEX            RESUME EXECUTION\n         XOPC  21                  RETURN FROM INT HANDLING STATE\nRETURN   EQU   *\n         LM    14,12,12(13)\n         BR    14\n         LTORG\n         END\n$ENTRY\n$JOB   ASSIST  XREF=3\n*              THIS IS XOPC TEST PROGRAM NUMBER THREE.  IT\n*              WILL TEST LOTS OF XOPCS INCLUDING 0,3,4,5,6,7,8,9,10\n*              AND 21\n         SPACE 2\nMAIN     CSECT\n         STM   14,12,12(13)\n         BALR  12,0\n         USING *,12\n         LA    1,ABCODE            GET ADDR OF ABEND ROUTINE\n         SR    0,0                 ZERO OUT REGISTER ZERO\n         O     0,=XL4'00004F00'    CATCH OC'S 1,4,5,AND 6\n         XOPC  0                   TURN ON A PSEUDO SPIE INTERRUPT\nLOWADRT  EQU   *\n         LA    0,LOWADRT           SET LOW AND HIGH ADDRESSES FOR TRACE\n         LA    1,HIGHADRT\n         XOPC  3\n         XOPC  5                   SET ADDRS FOR STORAGE MODIFICATION\n         XOPC  6                   TURN ON STORAGE MOD CHECK\n         XOPC  10                  TURN OFF BOUNDARY ALIGNMENT CHECK\n         LA    1,STORADD           GET STORAGE ADDRESS\n         ST    1,0(1)              TEST STORAGE MODIFICATION CHECKING\n         LA    2,3                 GET ODD ADDR INDX TO CHECK ALIGN OFF\n         ST    1,0(2,1)            TRY TO STORE ON ODD WORD BOUNDARY\n         XDUMP\nTOPLOOP  EQU   *                   TEST THE TRACE AND MOD CHECK\n         ST    1,0(1)\n         BCT   2,TOPLOOP           LOOP THRU HERE THREE TIMES\n         XOPC  9                   TURN ALIGNMENT CHECKING FACILITY ON\n         LA    2,3                 GET ODD INDEX AGAIN\n         ST    1,0(2,1)            A SOC 6 INTERRUPT SHOULD HAPPEN\nNEXTIN   EQU   *\n         XOPC  8                   TURN OFF STORAGE MOD CHECK\n         XDUMP\n         LA    1,STORADD           MODIFY TO SEE IF FACILITY REALLY OFF\n         ST    1,0(1)\n         LA    0,LOWADRT\n         LA    1,HIGHADRT\n         XOPC  7                   SET ADDRS AND TURN ON STORAGE MOD\nBOTLOOP  EQU   *\n         LA    1,STORADD           GET STORAGE ADDR\n         ST    1,0(1)              TEST TO SEE IF REALLY ON NOW\n         BCT   2,BOTLOOP           BCT FOR TEST\n         XOPC  8                   TURN OFF STOR MOD CHECK\n         XOPC  4                   TURN OFF TRACE\n         BZ    RETURN              TEST COND CODE\n         XPRNT =CL12'0CC PROBLEMS',12\nRETURN   EQU   *\n         LM    14,12,12(13)\n         BR    14\nABCODE   EQU   *\n         XDUMP\n         XPRNT =CL31'0 SHOULD BE IN ABEND CODE SOC 6',31\n         LA    1,NEXTIN            CONTINUE AFTER ABEND\n         XOPC  21\n         LTORG\nSTORADD  DS    3F'0'               GET STORAGE AREA\nHIGHADRT DS    18F\n         END\n$ENTRY\n$JOB     ASSIST XREF=3\n*              THIS PROGRAM TESTS SOME OF THE NEW FEATURES OF THE\n*              EXTENDED INTERPRETER.  MANY XOPC INSTRUCTIONS ARE\n*              TESTED  INCLUDING, 3, 16, 17, 18, 19, 20 AND 22\n         SPACE 2\nMAIN     CSECT\n         STM   14,12,12(13)        SAVE THOSE REGISTERS\n         BALR  12,0\n         USING *,12                SET UP ABASE REGISTER\nLOWADDR  EQU   *\n         LA    0,LOWADDR           SET LOW ADDRESS FOR TRACE\n         LA    1,NOSPACE           GET HIGH ADDRESS FOR TRACE\n         XOPC  3                   TURN ON TRACE FACILITY\n         XOPC 18                   TURN ON COUNT FACILITY\n         BL    NOSPACE             CHECK FOR NO SPACE ALLOCATION\n         XOPC 20                   CLEAR COUNTERS FOR GOOD COUNT\n         LA    2,40                GET LOOP NUMBER\nTOPLOOP  EQU   *\n         LA    3,2                 DO JUNK FOR COUNTING PURPOSES\n         LR    4,3\n         LR    5,4\n         LR    6,5\n         AR    4,3\n         BCT   2,TOPLOOP           LOOP AROUND COUNTING INSTRUCTIONS\n         XDUMP\n         XPRNT =CL25'0HAVE FINISHED FIRST LOOP',25\n         XOPC  17                  SHOW CAN CHANGE ADDRS MID-PROGRAM\n         XOPC  16                  TRY TO TURN ON AGAIN\nTURNOFF  EQU   *\n         XOPC  19                  SHUT OFF COUNT FACILITY\n         LA    2,40                SET UP NEW LOOP TO PROVE OFF\nNXTLOOP  EQU   *                   LOOP 40 TIMES WITH JUNK\n         LR    3,2\n         LR    4,3\n         LR    5,4\n         LR    6,5\n         AR    4,5\n         BCT   2,NXTLOOP\n         XOPC  16                  TURN COUNT FACILITY BACK ON\n         BNL   DUMPCNT\n         XPRNT =CL28'0BAD CONDITION CODE NUMBER 2',28\nDUMPCNT  EQU   *\n         XOPC  22                  DUMP THE COUNTERS\n         XOPC  19                  TURN OF FACILITY AGAIN\n         XOPC  22                  DUMP COUNTERS AGAIN MAKE SURE SAME\n         XOPC  20                  CLEAR THE COUNTERS\n         XOPC  22                  DUMP COUNTERS AGAIN TO PROVE ZERO\nNOSPACE  EQU   *\n         XPRNT =CL12'0END OF TEST',12\n         LM    14,12,12(13)\n         BR    14\n         END\n$ENTRY\n$JOB     ASSIST XREF=3\n*        THIS XOPC TEST PROGRAM TESTS THE COUNT FACILITY EXTENSIVELY\n*        MANY XOPC INSTRUCTIONS ARE INCLUDED IN THIS TEST PROGRAM\n*        THOSE TESTED ARE XOPC #'S 2, 16,17,18,19,20, AND 22\nMAIN     CSECT\n         STM   14,12,12(13)        SAVE THOSE REGISTERS\n         BALR  12,0\n         USING *,12                SET UP A BASE REGISTER\n         XOPC  2                   TURN ON A TRACE\n         XOPC  20                  TRY TO CLEAR NON-EXISTANT AREA\n         BL    CHECK1              TEST CC SETTING\n         XPRNT =CL28'0BAD CONDITION CODE NUMBER 1',28\nCHECK1   EQU   *\n         XOPC  19                  TRY TO TURN OFF COUNT FACILITY OFF\n         XOPC  16                  TURN ON COUNT FACILITY\n         XOPC  16                  TRY TO TURN ON AGAIN\n         XOPC  20\nCHECK3   EQU   *\n         XOPC  22                  TRY TO DUMP CLEAN AREA\n         LA    2,40\n         LA    5,2\nTOPLOOP  EQU   *\n         LR    3,2\n         AR    3,2\n         BCT   2,TOPLOOP           LOOP AROUND COUNTING\n         XOPC  22                  DUMP STATISTICS\n         XOPC  19                  SHUT OFF COUNT FACILITY\n         XOPC  22                  DUMP STATS AGAIN TO SEE IF SAME\n         XOPC  20                  CLEAR COUNTERS\n         LA    0,TOPLOOP           GET NEW COUNT ADDRESSES\n         LA    1,HIGHADDR          GET NEW COUNT ADDRS\n         XOPC  17                  SET NEW COUNT ADDRESSES\n         XOPC  16                  TURN ON COUNT FACILITY\n         XOPC  18                  TRY TO SET ADDRESSES AND TURN ON\n         XOPC  22                  DUMP STATISTICS AGAIN\n         XOPC  19                  TURN OFF COUNTING\n         XOPC  16                  TURN ON COUNTING\n         XOPC  17                  SET ADDRESSES\n         XOPC  20                  CLEAR COUNTERS\n         XOPC  22                  DUMP STATISTICS\n         LM    14,12,12(13)        RELOAD REGISTERS\nHIGHADDR EQU   *\n         BR    14                  DOMEEEEEEEEEEEEEEEEEEEEEEEEEE\n         END\n$ENTRY\n$JOB     ASSIST XREF=3\n*              THIS TEST PROGRAM MAINLY TESTS THE EMULATION FEATURES\n*              OF THE ASSIST EXTENDED INTERPRETER.  MANY XOPC\n*              INSTRUCTIONS ARE USED INCLUDING XOPC #'S 0, 3,\n*              4, 12, 13, AND 21.  MACHINE EMULATION WILL BE\n*              CHANGED IN THIS PROGRAM CAUSING A S0C1 EXCEPTION TO\n*              WHICH WILL BE INTERCEPTED BY THE ASSIST SPIE\n         SPACE 2\nMAIN     CSECT\n         USING *,15\n         STM   14,12,12(13)        SAVE THOSE REGISTERS\n         SR    0,0                 ZERO OUT REG FOR SPIE CODE\n         O     0,=XL4'00007800'    SET UP TO CATCH 0C1,2,3AND4\n         LA    1,ABNDCDE           GET ADDRESS OF ABEND CODE\n         XOPC  0                   SET UP ASSIST SPIE\nLOWADDR  EQU   *\n         LA    0,LOWADDR           GET A LOW ADDRESS FOR TRACE\n         LA    1,RETURN            GET HIGH ADDRESS FOR TRACE\n         XOPC  3                   SET ADDRESSES AND TURN ON TRACE\n         STCM  1,15,STORAGE        PROVE THAT ASSIST DEFAULTS TO S370\n         XOPC  12                  CHANGE ASSIST EMULATION TO S360\n         STCM  1,15,STORAGE        THIS SHOULD CAUSE A S0C1\nCONTIN   EQU   *\n         XOPC  13                  EMULATE 370 AGAIN\n         STCM  1,15,STORAGE        PROVE WE HAVE 370 EMULATION\n         B     RETURN              WE ARE FINISHED\nABNDCDE  EQU   *\n         XDUMP ,                   DUMP THE REGISTERS\n         XPRNT =CL40'1HELLO FROM THE ABEND CODE FOR S0C1',40\n         LA    1,CONTIN            GET RETURN ADDRESS\n         XOPC  21                  RETURN FROM INT PROCESSING\nRETURN   EQU   *\n         XPRNT =CL25'*** END OF TEST ***',25\n         LM    14,12,12(13)        RELOAD REGISTERS\n         BR    14\nSTORAGE  DS    F                   STORAGE AREA\n         END\n$ENTRY\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LOGIC": {"ttr": 24067, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x132?\\x01\\x132?\\x135\\x14*\\x14*\\x00\\x00\\xd7\\xc4\\xc6@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-11-19T00:00:00", "modifydate": "2013-11-19T13:35:00", "lines": 5162, "newlines": 5162, "modlines": 0, "user": "PDF"}, "mimetype": "application/pdf", "datatype": "binary", "extension": ".pdf"}, "USERGD": {"ttr": 26117, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x132?\\x01\\x132?\\x135\\nG\\nG\\x00\\x00\\xd7\\xc4\\xc6@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-11-19T00:00:00", "modifydate": "2013-11-19T13:35:00", "lines": 2631, "newlines": 2631, "modlines": 0, "user": "PDF"}, "mimetype": "application/pdf", "datatype": "binary", "extension": ".pdf"}, "XMSYSGEN": {"ttr": 27143, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x132?\\x01\\x132?\\x136\\x015\\x015\\x00\\x00\\xd7\\xc4\\xc6@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-11-19T00:00:00", "modifydate": "2013-11-19T13:36:00", "lines": 309, "newlines": 309, "modlines": 0, "user": "PDF"}, "mimetype": "application/pdf", "datatype": "binary", "extension": ".pdf"}, "XMWRITES": {"ttr": 27395, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x132?\\x01\\x132?\\x136\\x03\\x11\\x03\\x11\\x00\\x00\\xd7\\xc4\\xc6@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-11-19T00:00:00", "modifydate": "2013-11-19T13:36:00", "lines": 785, "newlines": 785, "modlines": 0, "user": "PDF"}, "mimetype": "application/pdf", "datatype": "binary", "extension": ".pdf"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT901/FILE901.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT901", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}