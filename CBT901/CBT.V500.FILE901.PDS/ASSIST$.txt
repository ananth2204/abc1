//ASSIST$  JOB (SYS),'INSTALL ASSIST',
//             CLASS=A,MSGCLASS=X,COND=(0,NE)
//*
//*  ! ! ! DO NOT RENUMBER THIS JOBSTREAM ! ! !
//*
//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
//* THIS JOB INSTALLS THE ASSIST LOAD MODULE.
//* STEP 1: THE SOURCE IS COPIED FROM INSTREAM STATEMENTS TO TWO
//*         TEMPORARY DATASETS.
//* STEP 2: UPDATES ARE APPLIED TO THOSE DATASETS USING ADDITIONAL
//*         INSTREAM STATEMENTS.  IF YOU WISH TO MAKE CHANGES TO THE
//*         INSTALLATION DEFAULTS, MAKE THEM TO THE STATEMENTS
//*         FOLLOWING THE UPDATEA.SYSIN STATEMENT BELOW AND RE-SUBMIT
//*         THE JOB.  (THE SECOND SET OF UPDATES CORRECTS SOME
//*         PROBLEMS WITH THE ORIGINAL SOURCE THAT SEEMS TO HAVE
//*         ORIGINATED DURING TRANSMISSION AND/OR TRANSLATION.
//* STEP 3: THE UPDATED SOURCE IS ASSEMBLED AND LINK-EDITED INTO
//*         SYS2.LINKLIB.  IF YOU WISH TO USE A DIFFERENT LIBRARY,
//*         CHANGE THE SINGLE INSTANCE WHERE SYS2.LINKLIB IS CODED
//*         BELOW.
//* STEP 4: A SET OF MACROS IS ADDED TO SYS1.MACLIB THAT ARE REQUIRED
//*         TO EXECUTE ASSIST.
//* STEP 5: A PROCEDURE TO INVOKE ASSIST IS ADDED TO SYS2.PROCLIB.  IF
//*         YOU WISH TO USE A DIFFERENT LIBRAYR, CHANGE THE SINGLE
//*         INSTANCE WHERE SYS2.PROCLIB IS CODED BELOW.
//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
//*
//ASOURCE  PROC
//*
//CREATEA  EXEC PGM=IEBUPDTE,PARM=NEW
//SYSPRINT DD  SYSOUT=*
//SYSUT2   DD  DSN=&&ASSRCO1,UNIT=SYSDA,DISP=(,PASS),
//             DCB=(DSORG=PS,RECFM=FB,LRECL=80,BLKSIZE=5600),
//             SPACE=(TRK,(10,10))
//*
//CREATEB  EXEC PGM=IEBUPDTE,PARM=NEW
//SYSPRINT DD  SYSOUT=*
//SYSUT2   DD  DSN=&&ASSRCO2,UNIT=SYSDA,DISP=(,PASS),
//             DCB=(DSORG=PS,RECFM=FB,LRECL=80,BLKSIZE=5600),
//             SPACE=(TRK,(300,100))
//*
//UPDATEA  EXEC PGM=IEBUPDTE
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  DSN=&&ASSRCO1,DISP=(OLD,DELETE)
//SYSUT2   DD  DSN=&&ASSRCM1,UNIT=SYSDA,DISP=(,PASS),
//             DCB=(DSORG=PS,RECFM=FB,LRECL=80,BLKSIZE=5600),
//             SPACE=(TRK,(10,10))
//*
//UPDATEB  EXEC PGM=IEBUPDTE
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  DSN=&&ASSRCO2,DISP=(OLD,DELETE)
//SYSUT2   DD  DSN=&&ASSRCM2,UNIT=SYSDA,DISP=(,PASS),
//             DCB=(DSORG=PS,RECFM=FB,LRECL=80,BLKSIZE=5600),
//             SPACE=(TRK,(300,100))
//         PEND
//*
//         EXEC ASOURCE
//*
//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
//* STEP 1 - COPY SOURCE TO TEMPORARY DATASETS FOR SUBSEQUENT INSTALL.
//*          (DO NOT MAKE CHANGES TO THE STATEMENTS BELOW!)
//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
//*
//CREATEA.SYSIN DD *
./ ADD LIST=ALL
         MACRO
         ASSYSGEN
*
*        THIS IS THE FULL VERSION WITH EVERYTHING
*
         GBLB  &$ACCT              =1 => ACCOUNT DISCRIMINATION POSSIBL
         GBLB  &$ALIGN             =0 -> NO BOUNDRY CHECK,=1 -> CHECKS
*                     ==0: 360 ONLY(USED FOR 360 ONLY)
*                     ==1:370 OR 360 ACTING AS 370'S
         GBLB  &$ASMLVL            =0==>DOS,=1==>OS
         GBLC  &$BATCH             LIMIT/DFLT: BATCH(DOS) - NOBATCH(OS)
         GBLA  &$BLEN              SET TO BUFFER LENGTH IN BYTES
         GBLC  &$BTCC(4)      BATCH CONTROL CARD ITEMS: SEE SETC'S    J
         GBLA  &$BUFNO             THE NUMBER OF BUFFERS
         GBLB  &$CMPRS             =0 NO CMPRS CODE, =1 CMPRS OPTION
         GBLA  &$COMNT             >0 COMMENT CHECK (&$COMNT % REQ)
         GBLB  &$DATARD            =0 SOURCE,DATA THRU SYSIN ONLY(WATFV
*                                  =1 DATA MAY BE READ FROM FT05F001
*                                  (I.E.- SINGLE JOB PROCESSING-PSU)
         GBLB  &$DEBUG             0==>DEBUG MODE, 1==> PRODUCTION MODE
         GBLB  &$DECSA             SHOULD ASSEMBLER PERMIT DECIMALS
         GBLB  &$DECSM             DOES MACHINE HAVE DECIMALS
         GBLB  &$DECK              =0 NO OBJ DECKS PUNCHED. =1 CAN DO
         GBLA  &$DISKU             0 FOR NO DISK UTILITY
*                                      1 FOR USER OPTION
*                                      2 FOR ALWAYS DISK
         GBLB  &$DMPAG             =1 BEGIN DUMP ON NEW PAGE, 0=> NO  J
         GBLC  &$DSKUDV            FOR DOS DISKU ONLY
         GBLA  &$ERNUM             # DIFFERENT ERROR MESSAGES
         GBLB  &$EXINT             EXTENDED INTERPRETER 1 = YES 0 = NO
         GBLB  &$FLOTA             SHOULD ASSEMBLER ALLOW FLOATING PT
         GBLB  &$FLOTAX            SHOULD ASSEMBLER ALLOW EXTENDED FP'S
         GBLB  &$FLOTE             =1==> WILL INTERPRET FLT,0==> (3
         GBLB  &$FLOTEX            =1==> WILL INTERPRET EX FP'S,0==> NO
         GBLB  &$FLOTM             =1==> MACHINE HAS FLTING PT,0==>NO
         GBLB  &$FLOTMX            =1==> MACHINE HAS FX FP'S,0==> NO
         GBLA  &$FREE,&$FREEMN     DEFAULT FREE=, MINIMUM FREE= (80A) J
         GBLC  &$GENDAT            GENERATATION DATE FOR THIS ASSIST
         GBLB  &$HASPBT            =1 HASP AUTOBATCH CODE SUPPORTED   J
         GBLB  &$HEXO                  =0=> NO HEXO =1=> XHEXO ALLOWED
         GBLB  &$HEXI                  =0=> NO HEXI =1=> XHEXI ALLOWED
         GBLA  &$IDF,&$IMX         DRFAULT,MAXIMUM I=
         GBLC  &$IOUNIT(8)         DIFFERENT DDNAMES USED IN ASSIST
         GBLB  &$JRM               =1 FOR PSU LOCAL SPECIAL CODE: JRM
         GBLB  &$KP26              =1 ALLOW KP=26 OR K&=29 OPTION
*                                  =0 ALLOW ONLY 029 KEYPUNCH CARDS
         GBLA  &$LDF,&$LMX         DEFAULT,MAX L= # LINES/PAGE
         GBLB  &$MACOPC            =1 => ALLOW OPEN CODE COND ASMBL
         GBLB  &$MACROG            =1 ==> ADD ASM G FEATURES TO ASM F
         GBLB  &$MACROH            =1 ==> ADD SOME ASM H FEATURES TO F
         GBLB  &$MACROV            OS/VS SUPPORT
         GBLB  &$MACROS            MACRO/CONDITIONAL ASSEMBLY ALLOWED
*              **NOTE** BASIC MACRO FACILITY IS ASSEMBLER F COMPATIBLE.
         GBLB  &$MACSLB            =1 ==> MACRO LIBRARY ALLOWED
         GBLC  &$MCHNE             SO CAN CHANGE SYSTEM TYPE
         GBLA  &$MMACTR            LOCAL ACTR INITIAL VALUE DEFAULT
         GBLA  &$MMNEST            MACRO NEST LIMIT DEFAULT
         GBLA  &$MMSTMG            GLOBAL MACRO STMT LIMIT DEFAULT
         GBLA  &$MODEL             MODEL NUMBER OF 360 BEING RUN ON
         GBLB  &$OBJIN             =0 CANNOT READ OBJECT DECK. =1 CAN
         GBLA  &$OPTMS             OPTIMIZE - 0==> MEMORY, 9==> SPEED
         GBLB  &$PAGE              =0 NO PAGE COINT/CONTROL CODE EXISTS
*                                  =1 PAGE CONTROL&OPTIONS ALLOWED
         GBLA  &$PDF,&$PMX         DEFAULT,MAX P= # PAGES LIMIT
         GBLA  &$PDDF,&$PDMX       DEFAULT,MAX PD= # PAGES SAVED FOR DP
         GBLB  &$PRIVOP            =0==>NO PRIV OPS, =1==> PRIV OPS OK
         GBLA  &$PRTSIZ            MAX # CHARS IN PRINT LINE FOR ASM  J
         GBLB  &$PUNCH             =0 WE DON'T ACTUALLY HAVE CARD PUNCH
*                                  =1 REAL PUNCH EXISTS, POSSIBLE USED
         GBLA  &$PXDF,&$PXMX       DEFAULT,MAX PX= PAGES FOR EXECUTION
         GBLB  &$P370              =1 WILL INTERPRET PRIVELEGED S/370
         GBLB  &$P370A             SHOULD ASSEMBLER PERMIT PRIV S/370'S
         GBLA  &$RDF,&$RMX         DEFAULT,MAX R= TOTAL # RECORDS
         GBLA  &$RDDF,&$RDMX       DEFAULT,MAX RD= RECORDS FOR DUMP
         GBLA  &$RECORD            =0,1=> NO $TIRC RECREM, =2=> $TIRC
         GBLB  &$RECOVR            (ONLY USED FOR &$RECORD=2).
*              =0 => R= DOES NOT OVERRIDE $TIRC VALUE, =1 => IT DOES.
*              (AT PSU, OUTPUT CAN GO TO BAT FILES - DON'T COUNT).
         GBLB  &$RELOC             =0==> NO RELOCATION CODE GENERATED
         GBLA  &$REPL              0=> NO REPL,1=> LIMITED,2=> FULL
         GBLA  &$RXDF,&$RXMX       DEFAULT,MAX RD= RECORDS FOR EXECUTE
         GBLB  &$SPECIO            SPECIAL ROUTINES EXIST(TYPE=$IS+)
         GBLA  &$SYHASH            SIZE OF INITIAL PTR TABLE FOR SYMOPS
         GBLC  &$SYSTEM            SYSTEM BEGIN RUN - DOS,PCP,MFT,MVT
         GBLA  &$S370              =0==> NO S/370 INSTR INTERPRETED
*                                  =1==> S/370 INSTR INTERPRETED ON 370
*                                  =2==> S/370 INSTR INTERPRETED ON 360
         GBLB  &$S370A             SHOULD ASSEMBLER PERMIT SYSTEM 370'S
         GBLC  &$TDF,&$TMX         DEFAULT,MAX T= TOTAL TIME FOR RUN
         GBLC  &$TDDF,&$TDMX       DEFAULT,MAX TD= TIME FOR DUMP
         GBLA  &$TIMER             0==> NO TIMING AT ALL
*              1==> STIMER/TTIMER ONLY. =2==> LOCAL TIMER FOR TIMREM
         GBLC  &$TXDF,&$TXMX       DEFAULT,MAX TX= TIME FOR EXECUTION
         GBLC  &$VERSLV            VERSION #.LEVEL #
         GBLB  &$XIOS              =0==>NO XIO MACROS,=1==>XIO MACROS
         GBLB  &$XREF              CONTROL GENERATION OF XREF FACILITYA
*        =1 FULL XREF, =0 NO XREF AT ALL                              A
         GBLA  &$XREFDF(3)         DEFAULT VALUES FOR FLAGS           A
*        &$XREFDF(1)=0       NO XREF(OTHERS =3MEANS COMPRESSED LISTINGA
*        &$XREFDF(2)=3       COLLECT MODIFY AND FETCH DEFN            A
*        &$XREFDF(3)=3       COLLECT REFERENCES MODIFY/FETCH          A
         GBLA  &$XREF#B            NUMBER OF SLOTS FOR XREF BLKS      A
         GBLB  &$XXIOS             =0 ALLOWS XGET AND XPUT
         GBLB  &X$DDMOR            =0 ALLOWS USER OWN DDNAMES
**       GLOBAL SET VARIABLES - INTERNAL TYPE -                       *
         GBLC  &DEBUG              DEBUG NUMBER FOR TESTING AVDEBUG
         GBLC  &ID                 IDENT GENERATION CONTROL
         GBLC  &TRACE              SPECIFIES FORM OF TRACE-SNAP,*,NO
         SPACE 1
&$ALIGN  SETB  1                   NEED BOUNDRY CHECKING
&$BATCH  SETC  'BATCH'             DEFAULT VALUE IS BATCH RUNS
&$BLEN   SETA  3520                SET FOR HALF TRACK BUFFERS
&$BLEN   SETA  4*(&$BLEN/4)        ROUND BLEN DOWN TO FULLWORD MULTIPLE
&$BTCC(1) SETC '$'            CONTROL CHARACTER FOR BATCH CARDS       J
&$BTCC(2) SETC 'JOB'          JOB BEGINNING INDICATOR                 J
&$BTCC(3) SETC 'ENTRY'        BEGIN DATA CARD: SET = '' IF NONE NEEDEDJ
&$BTCC(4) SETC 'STOP'         TERMINATOR CARD: SET = '' IF NONE       J
&$BUFNO  SETA  2                   SET FOR 4 BUFFERS
&$CMPRS  SETB  (1)                 ALLOW CMPRS OPTION
&$COMNT  SETA  80                  REQUIRE 80% COMMENTS, IF COMNT OPT
&$DATARD SETB  (1)                 ALLOW SINGLE JOB/TWO RDRS
&$DEBUG  SETB  (1)                 FOR QUICK RUN, KILL GENERATION
&$DECK   SETB  (1)                 ALLOW OBJECT DECKS TO BE PUNCHED
&$DECSA  SETB  (1)                 ASSEMBLER WILL ACCEPT DECIMAL INSTS
&$DECSM  SETB  (1)                 PSU 360/67 HAS DECIMAL INSTRUCTIONS
&$DISKU  SETA  1                   SET FOR USER OPTION ON DISK UTILITY
&$DMPAG  SETB  1                   ASSUME COMPLETION DUMP ON NEW PAGE J
&$DSKUDV SETC  '2314'              SET DEVICE FOR DOS DISKU CODE
&$EXINT  SETB  1                   BIG OS GETS NEW INTERPRETER ***
&$FLOTA  SETB  (1)                 ASSEMBLER ALLOWS FLOATING POINT
&$FLOTAX SETB  (1)                 ASSEMBLER ALLOWS EXTENDED F. P.
&$FLOTE  SETB  (1)                 WE WILL EXECUTE FLTINGS,IF POSSIBLE
&$FLOTEX SETB  (1)                 WILL EXECUTE EXTENDED F. P., IF POSS
&$FLOTM  SETB  (1)                 PSU 360/67 HAS FLOATING POINT
&$FLOTMX SETB  (1)                 PSU 360/67 HASN'T GOT EXTENDED F. P.
&$FREE   SETA  4096                NORMALLY RETURN 4K TO OS/360
&$FREEMN SETA  2048                MINIMUM ALLOWED FREE=;  *****NOTE  J
*              IF YOU HAVE 80A ABEND'S OFTEN, RAISE THIS AS NEEDED*** J
&$GENDAT SETC  '04/28/75'          CURRENT GENERATION DATE            J
&$HASPBT SETB  1                   HASP BATCH ON
&$HEXI   SETB  (1)                     XHEXI ALLOWED THIS ASSEMBLY
&$HEXO   SETB  (1)                     XHEXO ALLOWED
&$IDF    SETA  150000              100 SECS ON /67
&$IMX    SETA  150000              100 SECS ON /67
&$KP26   SETB  (1)                 ALLOW 026 KEYPUNCH
&$LDF    SETA  63                  DEFAULT 63 LINES/PAGE
&$LMX    SETA  63                  MAXIMUM OF 63 LINES/PAGE
*              MACRO SETS: ONLY SIGNIFICANT IF &$MACROS=1.
&$MACOPC SETB  1                   OPEN CODE, COND ASSMBL WORKS
&$MACROS SETB  1                   ALLOW MACROS TO BE PROC ESSED
&$MACROG SETB  0                   NO ASM G CODE ***NOT SUPPORTED YET**
&$MACROH SETB  0                   NO ASM H CODE ***NOT SUPPORTED YET**
&$MACROV SETB  0                   NO OS/VS ASSEMBLER SUPPORT YET
&$MACSLB SETB  1                   ALLOW MACRO LIBRARY
&$MCHNE  SETC  '370'               MACHINE GENERATED ON
&$MMACTR SETA  200                 DEFAULT ACTR VALUE = 200
&$MMNEST SETA  15                  DEFAULT LIMIT OF 15 DEEP IN MACS
&$MMSTMG SETA  4000                DEFAULT MAXIMUM TOTAL 4000 MAC STMTS
         SPACE 1
&$MODEL  SETA  65                  DEFAULT MODEL NUMBER
&$OBJIN  SETB  (1)                 ALLOW OBJECT DECKS TO BE READ
&$OPTMS  SETA  9                   WE WANT SPEED OPTIMIZATION
&$PAGE   SETB  (1)                 ALLOW ALL PAGE CONTROL OPTIONS
&$PDF    SETA  10                  TEN TOTAL PAGES
&$PMX    SETA  25                  MAXIMUM POSSIBLE OF 25 TOTAL
&$PDDF   SETA  1                   NORMAL DUMP-JUST FIRST PAGE
&$PDMX   SETA  5                   MAXIMUM OF 5 PAGES FOR THE DUMP
&$PRIVOP SETB  1                   ALLOW ALL PRIVILEGED OPERATIONS
&$PRTSIZ SETA  121                 LIMIT TO 121 CHARS AS DEFAULT LIM  J
&$PUNCH  SETB  (1)                 A REAL PUNCH EXISTS
&$PXDF   SETA  5                   MAXIMUM PAGES FOR EXECUTION
&$PXMX   SETA  5                   MAXIMUM MAXIMUM FOR EXECUTION
&$RDF    SETA  100000              DEFAULT RECORDS FOR EXEC
&$RMX    SETA  100000              MAX EXECUTION RECORDS
&$RDDF   SETA  25                  DEFAULT RECORDS FOR A DUMP
&$RDMX   SETA  5000                MAXIMUM RECORDS FOR DUMP
&$RECORD SETA  1                   SHOW $TIRC RECREM CAN'T BE USED
&$RELOC  SETB  (1)                 NEED RELOC SINCE WE HAVE REPL
&$REPL   SETA  2                   COMPLETE REPLACEMENT ALLOWED
&$RXDF   SETA  10000               EXECUTION RECORDS
&$RXMX   SETA  10000               EXECUTION RECORDS
&$SYSTEM SETC  'OS-MVT'            SYSTEM IS OS OPTION MVT
&$S370   SETA  2                   PSY WANTS S/370'S ON 360/67
&$S370A  SETB  (1)                 ASSEMBLER ALLOWS S/370'S
&$TDDF   SETC  '.1'                DEFAULT TIME FOR DUMP
&$TDF    SETC  '100'               SECONDS FOR EXECUTION
&$TMX    SETC  '200'               MAX POSSIBLE SECONDS FOR EXECUTION
&$TDMX   SETC  '10'                MAXIMUM TIME FOR A DUMP
&$TIMER  SETA  1                   SHOW WE WANT OVERALL TIMING DONE
&$TXDF   SETC  '100'               MAX TIME FOR EXECUTION
&$TXMX   SETC  '200'               MAXIMUM MAXIMUM FOR EXECUTION
&$VERSLV SETC  '4.0/A'             CURRENT ASSIST VERSION             J
&$XIOS   SETB  (1)                 WE'RE ALLOWING XIO MACROS
&$XREF   SETB  1                   ALLOW CROSS REFERENCE
&$XREFDF(1) SETA  0                NO XREF                            A
&$XREFDF(2) SETA  3                COLLECT ALL MOD/FETCH DEFN         A
&$XREFDF(3) SETA  3                COLLECT ALL MOD/FETCH REFERENCES   A
&$XREF#B SETA  10                  ALLOCATE 10 SLOTS/BLOCK            A
&$ASMLVL SETB  ('&$SYSTEM'(1,2) EQ 'OS')     SET LEVEL OF ASSEMBLER
&$FLOTE  SETB  (&$FLOTE AND &$FLOTM)         KILL GEN IF NO FLOATS
&$FLOTEX SETB  (&$FLOTEX AND &$FLOTMX) KILL GEN IF NO EXTENDED FLOATS
&$HASPBT SETB  (&$HASPBT AND &$ASMLVL)  ELIM HASP IF NOT OS SYSTEM    J
&$MACSLB SETB  (&$MACSLB AND &$MACROS)  REMOVE LIBRARY IF NO MACROS   J
&$RELOC  SETB  (&$RELOC OR (&$REPL NE 0))  IF REPL, MAKE SURE RELOC   J
&ID      SETC  'NO'                SET NO ID FOR TIME BEING
         AIF   (&$DEBUG).EQU1      LEAVE NO ID IF PRODUCTION PROG
&ID      SETC  '*'                 DEBUG==> GENERATE ID'S AT ENTRIES
.EQU1    ANOP
         AIF   (&$ASMLVL).OSGEN    SKIP IF OS GENERATION
&$BATCH  SETC  'BATCH'             DEFAULT FOR DOS IS BATCH
&$IOUNIT(1) SETC  'SYSIPT'         SET DOS MAIN INPUT
&$IOUNIT(2)  SETC  'SYSRDR'        SET DOS SECONDARY INPUT
&$IOUNIT(3)  SETC  'SYSLST'        SET DOS PRINTER
&$IOUNIT(4) SETC 'SYSPCH'          SET DOS PUNCH
&$IOUNIT(5) SETC 'SYS001'          SET TO 'HRB' SCRATCH DEVICE
&$BUFNO  SETA  2                   FOR DOS GEN INSURE ONLY 2 BUFFERS
&$DSKUDV SETC  '2314'              SET DOS DISK DRIVE TYPE
         AGO   .OSGEN1
.OSGEN   ANOP
&$BATCH  SETC  'NOBATCH'           DEFAULT FOR OS IS NOBATCH
&$IOUNIT(1)  SETC  'SYSIN'         SET OS PRIMARY INPUT
&$IOUNIT(2)  SETC  'FT05F001'      SET OS SECONDARY INPUT
&$IOUNIT(3)  SETC  'FT06F001'      SET OS PRINTER
&$IOUNIT(4)  SETC  'FT07F001'      SET OS PUNCH
&$IOUNIT(5)  SETC  'FT08F001'      SET OS DISK INTERMEDIATE
&$IOUNIT(6)  SETC  'SYSLIB'        SET OS MACRO LIBRARY
.OSGEN1  ANOP
         MEND
//CREATEB.SYSIN DD *
./ ADD
         PRINT ON,NOGEN
         TITLE 'ASSIST VERSION 4.0/A - MARCH 1975'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        PENNSYLVANIA STATE UNIVERSITY COMPUTER SCIENCE DEPARTMENT    *
*        PROJECT SUPERVISION: GRAHAM CAMPBELL                         *
*        PROGRAM DESIGN, CODING, DOCUMENTATION: JOHN R. MASHEY.       *
*        DOS/360 CONVERSION, $SPIE, XXXXSPIE: SCOTT A. SMITH.         *
*                                                                     *
*        PROGRAM WRITTEN BEGINNING SUMMER 1969.                       *
*        FIRST BATCH USAGE:  SPRING TERM, 1970.                       *
*        FIRST USAGE ON STUDENT REMOTE TERMINALS: FALL TERM, 1970.    *
*        FIRST DISTRIBUTION TO OTHER INSTALLATIONS: SUMMER 1971.      *
*        FIRST DISTRIBUTION (DOS/360 VERSION) : FALL 1971.            *
*                                                                     *
*        DISK UTILITY (DISKU) FACILITY (XXXXDK##, UTOPRS CHANGES):    *
*              RICHARD FORD, PAUL WEISSER - SPRING 1972.              *
*        XHEXI, XHEXO ADDITIONS: ALAN ARTZ - SPRING 1972.             *
*        S/370 INSTRUCTIONS: CHARLES JOHNSON - SPRING 1972.           *
*        MACRO PROCESSOR - GRAHAM CAMPBELL - SPRING, SUMMER 1972.     *
*        LIBRARY MACRO FETCH AND PROCESSING: RICHARD FORD, SUMMER 1972*
*        IMPROVED MACRO PROCESSOR, OPEN CODE ALAN ARTZ,               *
*              JOHN STERNBERGH - FALL,WINTER 1972 - 73                *
*        DOS DISK UTILITY - RICHARD FORD - WINTER 1973                *
*        EXTENDED I/O PACKAGE, XGET - XPUT - RICHARD FOWLER -         *
*              FALL 1972                                              *
*        CROSS-REFERENCE- ALAN ARTZ, ALICE FELTE, RICH LONG -         *
*              SPRING, SUMMER 1973.                                   *
*        EXTENDED INTERPRETER- MARK DALTON, JOHN STERNBERGH, RICH     *
*              LONG - SPRING, SUMMER, FALL 1973.                      *
*        DOCUMENTATION UPDATE- GLENN FADNER - FALL 1973, WINTER 1974. *
*                                                                     *
*         MANY THANKS TO SHELLY GEARHART FOR HELP WITH DISTRIBUTION   *
*         MATERIALS.  SPECIAL THANKS TO KAREN HOERTER (PSU CC PROGRAM *
*         LIBRARIAN)FOR HANDLING OF ASSIST TAPE DISTRIBUTION, AND FOR *
*         FACING MASSIVE PILE OF TAPES WITHOUT MOANING (TOO MUCH).    *
* * * * * NOTES ON DISTRIBUTION VERSIONS OF ASSIST  * * * * * * * * * *
*                                                                     *
*        VERSION   DATE AVAIL.     COMMENTS                           *
*                                                                     *
*        1.2/A1    09/01/71        ORIGINAL DISTRIBUTION VERSION      *
*                                                                     *
*        1.3/A     04/01/72        CONTAINS DOS/360 CODE, FIXES BUGS  *
*                                                                     *
*        2.0/A     08/72(APPROX)   MACRO PROCESSOR, S/370, DISK OPTION*
*                                  FOR INTERMEDIATE STORAGE IF NEEDED.*
*              PREPARED BY: RICHARD FORD + JRM                        *
*                                                                     *
*        2.1/A     02/01/73        OPEN CODE, DOS DISKU, XGET - XPUT  *
*              PREPARED BY: ALAN ARTZ, ALICE FELTE + JRM              *
*                                                                     *
*        3.0/A     08/01/73        XREF, HASP AUTOBATCH, OVERLAYS     *
*              PREPARED BY: RICH LONG + JRM                           *
*                                                                     *
*        3.0/B     03/01/74        EXTENDED INTERPRETER,DOCUMENTATION *
*                                    UPDATES.                         *
*              PREPARED BY: MARK DALTON, GLENN FADNER, RICH LONG      *
*                                                                     *
*        4.0/A     3/01/75         CLEANS UP 3.0/B                    *
*                                  EXTENDED INTERP., ETC              *
*           PREPARED BY THOMAS MINSKER                                *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         TITLE '*** XCHAR MACRO - SAFE RIGHT-END SUBSTRING MACRO ***'
         MACRO
         XCHAR &STRING,&NUM
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XCHAR      RETURN SAFE RIGHT-END SUBSTRING OF A STRING.  *
.*                                     JOHN R. MASHEY-JULY 1969-360/67*
.*       THIS MACRO RETURNS IN &XXCHAR THE &NUM CHARACTERS TAKEN FROM *
.*       THE RIGHT END OF THE CHARACTER STRING &STRING, WITHOUT       *
.*       BLOWING UP IF THERE ARE LESS THAN &NUM CHARS IN &STRING.     *
.*       THIS MACRO IS USED BY XSAVE,XRETURN, AND XSRNR               *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLC  &XXCHAR             RETURN RESULT IN THIS
         AIF   (&NUM GT K'&STRING).XGA       SKIP IF HE WANTS MORE
&XXCHAR  SETC  '&STRING'(K'&STRING+1-&NUM,&NUM)        SCOOP RIGHT AMT
         MEXIT
.XGA     ANOP
&XXCHAR  SETC  '&STRING'           STRING SMALLER-USE WHOLE THING
         MEND
         TITLE 'XDECI MACRO - EXTENDED DECIMAL INPUT CONVERSION'
         MACRO
&LABEL   XDECI &REG,&ADDRESS
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*-->MACRO: XDECI      EXTENDED DECIMAL INPUT CONVERSION              *
.*--> MACRO: XDECI      EXTENDED DECIMAL INPUT CONVERSION * * * * * * *
.*             EXTENDED DECIMAL INPUT MACRO - ENABLES PROGRAMS        *
.*       WRITTEN FOR ASSIST TO BE RUN UNDER OS/360 DIRECTLY.          *
.*       USES MODULE XXXXDECI TO SCAN DECIMAL STRING BEGINNING AT     *
.*       &ADDRESS, CONVERT ITS VALUE INTO REGISTER &REG, AND SET      *
.*       REGISTER R1 AS A SCAN POINTER TO THE DELIMITER FOLLOWING THE *
.*       STRING OF DECIMAL DIGITS.  THE CONDITION CODE IS SET BY THE  *
.*       VALUE IN &REG, UNLESS AN ERROR OCCURRS, IN WHICH CASE CC=3.  *
.*       SEE ASSIST USER MANUAL FOR USAGE INSTRUCTIONS.               *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         LCLC  &XLABL              FOR CREATION OF LABEL
&XLABL   SETC  'XX&SYSNDX.E'       CREATE UNIQUE LABEL
         CNOP  2,4  .              LINE UP ON BOUNDARY
&LABEL   STM   14,1,&XLABL  .      SAVE LINKAGE REGS
         LA    0,&ADDRESS .        BEGINNING @ FOR SCANNING
         L     15,&XLABL-4  .      GET ADCON FOR CONVERSION
         BALR  14,15 .             CALL ROUTINE, PT WITH R14
         DC    V(XXXXDECI) .       ADCON FOR CONVERSION ROUTINE
&XLABL   DS    5F .                REGS 14,15,0,1, VALUE FOR &REG
         LM    14,1,4(14) .        RELOAD REGS
         BO    *+8 .               BRANCH IF &REG SHOULDN'T CHANGE
         L     &REG,&XLABL+16  .   GET VALUE FOR &REG
         AIF   (T'&REG EQ 'N' AND '&REG' NE '1').XXEXIT SKIP IF SAFE
         L     1,&XLABL+12  .      USER MAY HAVE REG=1, LOAD FOR SAFE
.XXEXIT  MEND
         TITLE 'XDECO MACRO - EXTENDED DECIMAL OUTPUT CONVERSION'
         MACRO
&LABEL   XDECO &REG,&ADDRESS
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XDECO      EXTENDED DECIMAL OUTPUT CONVERSION            *
.*       USES MODULE XXXXDECO TO CONVERT VALUE IN REGISTER &REG TO    *
.*       AN EDITED 12-BYTE FIELD, WITH SIGN, AT LOCATION &ADDRESS.    *
.*             EXTENDED DECIMAL OUTPUT MACRO - ENABLES PROGRAMS       *
.*       WRITTEN FOR ASSIST TO BE RUN UNDER OS/360 DIRECTLY.          *
.*       SEE ASSIST USER MANUAL FOR USAGE INSTRUCTIONS.               *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         LCLC  &XLABL              FOR CREATION OF UNIQUE LABEL
&XLABL   SETC  'XX&SYSNDX.D'       CREATE UNIQUE LABEL
         CNOP  2,4 .               LINE UP ON RIGHT BOUNDARY
&LABEL   STM   14,0,&XLABL  .      STORE LINKAGE REGS
         ST    &REG,&XLABL+12  .   SAVE VALUE TO BE CONVERTED
         LA    0,&ADDRESS .        OBTAIN @ OPERAND FILED
         L     15,&XLABL-4  .      GET ADCON FOR CONVERSION PROG
         BALR  14,15 .             CALL XXXXDECO, PT R14
         DC    V(XXXXDECO) .       ADCON FOR CONVERSION PROG
&XLABL   DS    4F .                REGS 14,15,0, REG TO BE CONVERTED
         LM    14,0,4(14) .        RELOAD LINKAGE REGISTERS
         MEND
         TITLE 'MACRO-->XHEXI EXTENDED HEXADECIMAL CONVERSION'
         MACRO
&NAME    XHEXI &REG,&ADDR
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*-->MACRO: XHEXI  HEXADECIMAL INPUT CONVERSION MACRO.                *
.*                                WRITTEN BY ALAN ARTZ 4/17/72        *
.*       THIS MACRO TAKES THE VALUE STARTING AT THE ADDRESS GIVEN BY  *
.*  &ADDR AND CONVERTS IT AND PUTS THE HEXADECIMAL VALUE IN &REG.     *
.*  IF THERE ARE MORE THAN 8 DIGITS, R1 POINTS TO THE 9TH AND THE     *
.*  FIRST 8 ARE CONVERTED.  IF THERE IS A NON-BLANK, NON-HEX DIGIT    *
.*  FOUND, R1 POINTS TO THAT CHARACTER AND THE CC=3, OTHERWISE CC SET *
.*  BY VALUE IN REG.                                                  *
.*                                                                    *
.*       CALLS MODULE XXXXHEXI TO DO THE ACTUAL CONVERSIONS           *
.*                                                                    *
.*       SEE ASSIST USER MANUAL FOR USAGE INSTRUCTIONS.               *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         LCLC  &LABEL
&LABEL   SETC  'XX&SYSNDX.H'      UNIQUE LABEL
&NAME    STM   14,0,&LABEL  .     SAVE REGISTERS
         ST    &REG,&LABEL+12  .  REGISTER STORE INCASE OF OVERFLOW CND
         LA    0,&ADDR  .         GET STRING TO BE CONVERTED
         CNOP  2,4  .             GET PROPER ALIGNMENT
         L     15,&LABEL-4  .     ADDRESS OF XXXXHEXI
         BALR  14,15  .           GO TO APPROPRIATE PLACE
         DC    V(XXXXHEXI)  .     VCON OF ROUTINE
&LABEL   DS    4F  .              STORAGE FOR REGISTERS
         LM    14,0,4(14)  .      RESTORE REGISTERS
         L     &REG,&LABEL+12  .  GET CONVERTED NUMBER
         MEND
         TITLE 'MACRO-->XHEXO EXTENDED HEXADECIMAL CONVERSION'
         MACRO
&NAME    XHEXO &REG,&ADDR
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*-->MACRO: XHEXO  HEXADECIMAL OUTPUT CONVERSION MACRO                *
.*                                WRITTEN BY ALAN ARTZ 4/17/72        *
.*       THIS MACRO TAKES THE VALUE IN &REG AND CONVERTS IT TO        *
.*  PRINTABLE FORM.                                                   *
.*       IT PUTS THE CONVERTED VALUE IN AN EIGHT BYTE AREA STARTING AT*
.* THE ADDRESS GIVEN IN &ADDR.                                        *
.*       THE CC AND REGISTERS ARE LEFT UNCHANGED.                     *
.*                                                                    *
.*       CALLS MODULE XXXXHEXO TO DO THE ACTUAL CONVERSIONS.          *
.*                                                                    *
.*       SEE ASSIST USER MANUAL FOR USAGE INSTRUCTIONS.               *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         LCLC  &LABEL
&LABEL   SETC  'XX&SYSNDX.H'      UNIQUE LABEL
&NAME    DS    0H
         STM   14,0,&LABEL  .     SAVE REGISTERS
         ST    &REG,&LABEL+12  .  SAVE &REG
         LA    0,&ADDR   .        PASS REGISTER TO XXXXHEXO
         CNOP  2,4  .             GET PROPER ALIGNMENT
         L     15,&LABEL-4  .     ADDRESS OF XXXXHEXO
         BALR  14,15  .           CALL XXXXHEXO
         DC    V(XXXXHEXO)
&LABEL   DS    4F  .              STORAGE FOR REGISTERS
         LM    14,0,&LABEL  .     RESTORE REGISTERS
         MEND
         TITLE '*** XIDENT MACRO - CREATE ID FOR XSAVE MACRO ***'
         MACRO
         XIDENT &ID,&LABEL,&XCSECT,&PRIVATE
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XIDENT     IDENTIFY ENTRY POINT FOR XSAVE,$SAVE.         *
.*       MACRO USED BY XSAVE TO PRODUCE ID AT AN ENTRY POINT.  WILL   *
.*       USE THE FIRST NON-NULL OPERAND PASSED TO IT AS THE ID.       *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         LCLA  &I,&J                LOCAL COUNTERS
&I       SETA  1                    INITIALIZE
         AIF   ('&ID' NE '*').XIDINC         SKIP IF EXPLICIT ID FIELD
.XILOOP  ANOP
&I       SETA  &I+1                 INCREMENT TO NEXT ONE
         AIF   ('&SYSLIST(&I)' EQ '').XILOOP SKIP BACK IF THIS IS NULL
.XIDINC  ANOP
&J       SETA  6+((K'&SYSLIST(&I)+1)/2)*2   GET BRANCH LENGTH
         B     &J.(,15) .           BRANCH AROUND ID
&J       SETA  &J-5                 GET ACTUAL LENGTH OF ID
         DC    AL1(&J),CL&J'&SYSLIST(&I)'
         MEND
         TITLE ' *** XIONR-INNER MACRO FOR XREAD,XPRNT,XPNCH ***'
         MACRO
&XLABEL  XIONR &XNAME,&XNUM,&XAREA,&XDEFT
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XIONR      INNER MACRO-$READ,$PNCH,$PRNT,$SORC           *
.*                                 ALSO XGET,XPUT,$GET,AND$PUT        *
.*                                 JOHN R. MASHEY - FEB 1970 - V.4.0  *
.*       XIONR IS USED BY XIOPAK MACROS XREAD,XPRNT,XPNCH TO SET UP   *
.*       THE REQUIRED CODE FOR CALLING THEIR RESPECTIVE SUBROUTINES.  *
.*       *** ARGUMENTS ***                                            *
.*       XNAME     THE NAME OF THE I/O ROUTINE TO BE CALLED.          *
.*       XNUM      THE LENGTH OF XAREA TO BE PRINTED,PUNCHED,ETC.     *
.*       XAREA     THE AREA ON WHICH I/O OPERATION TO BE PERFORMED.   *
.*             MAY BE SPECIFIED BY (0) OR (R0).                       *
.*       XDEFT     DEFAULT VALUE OF XNUM TO BE USED, IF IT IS OMITTED *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         AIF   (T'&XAREA EQ 'O').XERR1       PRODUCE MNOTE
&XLABEL  STM   14,0,XX&SYSNDX.R+4 .    SAVE REGS WHICH WILL BE CHANGED
         AIF   (T'&XNUM EQ 'O').XN1    SKIP NEXT CHECK IF OMITTED
         AIF   ('&XNUM'(1,1) NE '(' OR '&XNUM'(K'&XNUM,1) NE ')').XN1
         STH   &XNUM,XX&SYSNDX.R+16 .       STORE LENGTH
.XN1     AIF   ('&XAREA' EQ '(0)' OR '&XAREA' EQ '(R0)').XNOLA
.XN2     LA    0,&XAREA
.XNOLA   L     15,XX&SYSNDX.R  .   GET BRANCH ADDRESS
         CNOP  2,4  .              ADJUST FOR RIGHT ALIGNEMNT
         BALR  14,15 .             CALL ROUTINE, R14==> CONTROL BLOCK
XX&SYSNDX.R DC V(&XNAME)  .        ROUTINE ADDRESS
         DS    3F .                SAVE SPACE FOR REGS 14-0
         AIF   ('&XNUM' EQ '').XDFT         SKIP IF DEFAULT SHOULD BE
         DC    AL2(&XNUM) .        LENGTH OF AREA
         AGO   .XDS                SKIP
.XDFT    DC    AL2(&XDEFT) .       DEFAULT LENGTH USED
.XDS     LM    14,0,4(14) .        RESTORE REGS. CON CODE ALREADY DONE
         MEXIT
.XERR1   MNOTE 0,'**XIONR- AREA ADDRESS OMITTED-GENERATION CANCELLED'
         MEND
         TITLE '*** XLOOK MACRO - LOOK UP ELEMENT IN LIST ***'
         MACRO
         XLOOK &ARG1,&ARGL
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XLOOK      FIND POSITION OF ELEMENT IN LIST.             *
.*                                 JOHN R. MASHEY - FEB 1970 - V.4.0  *
.*       MACRO TO FIND AND RETURN POSTION OF ARGUMENT IN A SUBLIST.   *
.*       &ARG1 ARGUMENT TO BE SEARCHED FOR                            *
.*       &ARGL LIST OF ARGUMENTS FOR &ARG1 TO BE CHECKED FOR IN       *
.*       &XXLOOK   THE FIRST POSITION IN &ARGL IN WHICH &ARG1 IS      *
.*       FOUND, IF ANY.  IF &ARG1 IS NOT IN &ARGL, &XXLOOK = 0.       *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLA  &XXLOOK             FOR RETURN OF INDEX VALUE
&XXLOOK  SETA  1                   INITIALIZE THE COUNTER
.XLA     AIF   (&XXLOOK GT N'&ARGL).XLB     IF GT,QUIT,NOT FOUND
         AIF   ('&ARG1' EQ '&ARGL(&XXLOOK)').XXEXIT   IF FOUND,RETURN
&XXLOOK  SETA  &XXLOOK+1           INCREMENT COUNTER
         AGO   .XLA                GO BACK FOR NEXT CHECK
.XLB     ANOP
&XXLOOK  SETA  0                   NOT FOUND, SET TO 0 TO SHOW THIS
.XXEXIT  MEND
         TITLE ' *** XMUSE - INNER MACRO FOR XSAVE-MULTIPLE USING ***'
         MACRO
         XMUSE &BR,&AD
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XMUSE      BASE REGISTER SETUP MACRO FOR XSAVE           *
.*                                 JOHN R. MASHEY - FEB 1970 - V.4.0  *
.*       THIS MACRO IS CALLED BY XSAVE TO HANDLE BR AND AD OPERANDS,  *
.*       AND PRODUCE APPROPRIATE USINGS.  &BR AND &AD ARE FROM XSAVE. *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         LCLA  &I,&N               LOCAL COUNTERS
         LCLC  &B(4),&V            BASE REGS, USING NAME
&N       SETA  N'&BR               GET NUMBER WHERE HANDY
&V       SETC  '*'                 NORMAL USE
         AIF   (&N LE 4).XNOKA     MAKE SURE NOT TOO MANY BASES
&N       SETA  4                   IDIOT USER HAD >4 BASES, IGNORE EXTR
         MNOTE 4,'**XMUSE- MORE THAN 4 BASE REGS-EXTRAS IGNORED'
.XNOKA   AIF   ('&AD' EQ '').X1LOOP         SKIP IF NORMAL SITUATION
.*             USED IF AD PARAMATER WAS SPECIFIED IN XSAVE MACRO.     *
         CNOP 0,4
         B     *+8 .               SKIP AROUND ADDRESS CONSTANT
         DC    A(&AD)       .      ADDRESS CONSTANT FOR AD=PARAMETER
         L     &BR(1),*-4 .        LOAD ADCON INTO RIGHT REGISTER
&V       SETC  '&AD'               CHANGE NAME FOR USING 1ST OPERND
.*             NORMAL SECTION OF CODE FOR GENERATING USING.           *
.X1LOOP  ANOP
&I       SETA  &I+1      INCREMENT COUNTER TO BASE REG
&B(&I)   SETC  ',&BR(&I)'          GET I'TH BASE REGISTER
         AIF   (&I LT &N).X1LOOP   CONTINUE UNTIL ALL BASE REGS DONE
         DROP  15 .                CLEAN UP USING SITUATION
         USING &V&B(1)&B(2)&B(3)&B(4)
         MEND
         TITLE '*** XRETURN MACRO - EXTENDED RETURN MACRO ***'
         MACRO
&LABEL   XRETURN &RGS=(14-12),&SA=,&RC=,&RP=,&T=,&TR=*,&REEN=
.** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XRETURN    GENERAL RETURN MACRO, OS LINKAGE              *
.*                                 JOHN R. MASHEY - FEB 1970 - V.4.0  *
.*       EXTENDED RETURN MACRO - SEE PSU CC WRITEUP - XSAVE/XRETURN   *
.*       FOR EXPLANATION AND USE OF OPERANDS.                         *
.*       USES MACROS: FREEMAIN,XCHAR,XSRNR                            *
.** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLB  &XRETUST            =0 TRACE GENERATION OK, =1 NO TRACE
         GBLC  &XSAVE,&XXCHAR      STD SAVE AREA NAME, XCHAR VARIABLE
         LCLA  &I                  LOCAL COUNTER
         LCLB  &RCA,&RCB           FOR CONTROL OF RETURN CODE GENER
.*                                                                    *
.*       GENERATE LABEL IF THERE IS ONE, GENERATE TRACE CODE IF IT    *
.*       IF DESIRED, AND SET UP LCLB VARIABLES TO DESCRIBE RETURN     *
.*       CODE CONDITIONS. GENERATE LR IF NEEDED FOR RC OPTION.        *
.*                                                                    *
         SPACE 1
         AIF   (T'&LABEL EQ 'O').XNOLB       SKIP IF NO LABEL USED
&LABEL   DS    0H .                DEFINE LABEL
.XNOLB   AIF   ('&TR' EQ 'NO' OR &XRETUST).XNORT       SKIP IF NO TRACE
         XSRTR &TR,&LABEL,EXITED   GET TRACE GENERATED
.XNORT   ANOP
&RCA     SETB  (T'&RC EQ 'O')      TRUE IF WHOLE THING OMITTED
&RCB     SETB  (1)                 SET THIS WAY FOR NEXT TEST
         AIF   (&RCA).XNRCB        SKIP IMMEDIATELY IF OMITTED
&RCB     SETB  ('&RC'(1,1) NE '(' OR '&RC'(K'&RC,1) NE ')')  NOT RG TYP
         AIF   (&RCB).XNRCB       SKIP IF NOT REGISTER TYPE
         XCHAR &RC,3               GET LAST 3 CHARS
         AIF   ('&XXCHAR' EQ '15)').XNRCB    SKIP IF ALREADY IN 15
         LR    15,&RC .            LOAD RETURN CODE FROM DESIRED REG
.XNRCB   AIF   (T'&REEN EQ 'O').XNORM        SKIP IF NOT REENTRANT
.*                                                                    *
.*       REENTRANT RETURN CODE GENERATION - OBTAIN ADDRESS AND LENGTH *
.*       OF AREA FROM WHERE XSAVE PUT THEM,DO FREEMAIN,FIXUP REGS.    *
.*                                                                    *
         AIF   ('&TR' EQ 'NO' OR &XRETUST).XGOK        MAKE SURE REENT
         MNOTE 0,'**XRETURN- TR OPTION IMPLIES NON-REENTRANT CODE'
.XGOK    L     13,4(13) .          GET OLD SA POINTER BACK
         STM   15,1,16(13) .       SAVE REGS FROM FREEMAIN CRUNCHING
         L     1,8(13) .           GET ADDRESS OF AREA BACK
*        FREEMAIN R,LV=8*((&REEN+79)/8),A=(1)          FREE STORAGE
         FREEMAIN R,LV=8*((&REEN+79)/8),A=(1)          FREE STORAGE
         LM    15,1,16(13) .       RESTORE THE REGS
         AGO   .XNORM1             GO TO PROCESS REGISTER RESTORATION
.XNORM   AIF   ('&SA' EQ 'NO').XNORM1        SKIP RESTORATION IF UNUSED
.*                                                                    *
.*       REGISTER RESTORATION CODE - RESTORE REGS FROM CALLER'S       *
.*       SAVE AREA,DEPENDING ON RETURN CODE AND FUNCTION OPTIONS.     *
.*                                                                    *
         L     13,4(13) .          RESTORE PREVIOUS SAVE AREA POINT
.XNORM1  AIF   ('&RGS' EQ 'NO').XNORM2A     SKIP IF NO REGS NEEDED
         AIF   ('&RGS' NE '(14-12)' OR NOT &RCB).XNORM2
         LM    14,12,12(13) .      STANDARD REGISTER RESTORATION
         AGO   .XNORM2A            CONTINUE
.XNORM2  ANOP
&I       SETA  &I+1                INCREMENT COUNTER
         XSRNR L,&RGS(&I),&RCB     HAVE RESTORE CODE GENRATED
         AIF   (&I LT N'&RGS).XNORM2        LOOP UNTIL DONE
.*                                                                    *
.*       RETURN CODE(15) AND RETURN PAST(14) CODE GENERATION.         *
.*                                                                    *
.XNORM2A AIF   (&RCA OR NOT &RCB).XNORM3    SKIP IF NOT LA TYPE RC=
         LA    15,&RC .            PUT RETURN CODE IN 15
.XNORM3  AIF   ('&T' NE '*').XNORM4          SEE IF MVI WANTED
         MVI   12(13),X'FF' .      SHOW WE HAVE RETURNED
.XNORM4  AIF   (T'&RP EQ 'O').XNORP          SKIP IF RP NOT USED
         B     &RP.(14) .          RETURN GIVEN NUMBER PAST 14
         AGO   .XNORM5
.XNORP   BR    14 .                RETURN NORMALLY TO CALLER
.*                                                                    *
.*       SAVE AREA GENERATION - IF A SAVE AREA SHOULD BE CREATED,     *
.*       USE EITHER ONE SPECIFIED BY MACRO,OR ELSE STANDARD ONE.      *
.*                                                                    *
.XNORM5  AIF   (T'&SA EQ 'O' OR '&SA' EQ 'NO').XEXIT   SKIP IF NO SAV5
         AIF   ('&SA' EQ '*').XSASTD         IF *,USE STANDARD SAVE
&SA      DC    18F'0' .            SAVE AREA,NAMED BY MACRO
         AGO   .XEXIT
.XSASTD  ANOP
&XSAVE   DC    18F'0' .            SAVE AREA,USING GENERATED NAME
.XEXIT   SPACE 1
         MEND
         TITLE '*** XSAVE - EXTENDED SAVE MACRO ***'
         MACRO
&LABEL   XSAVE &RGS=(14-12),&BR=12,&SA=*,&ID=*,&TR=*,&REEN=,&OPT=,&AD=
.** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XSAVE      EXTENDED SAVE MACRO - OS LINKAGE.             *
.*                                 JOHN R. MASHEY - FEB 1970 - V.4.0  *
.*       EXTENDED SAVE MACRO - SEE PSU CC WRITEUP - XSAVE/XRETURN     *
.*       FOR DESCRIPTION OF ARGUMENTS FOR THIS MACRO                  *
.*       USES MACROS: GETMAIN,XCHAR,XIDENT,XLOOK,XMUSE,XSRNT,XSRTR    *
.** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLA  &XXLOOK             RETURN VARIABLE FROM XLOOK MACRO
         GBLB  &XSAVEST            =0 TRACE GEN OK, =1 NO TRACE DONE
         GBLC  &XSAVE,&XCSECT,&XXCHAR  STD NAME,CSECT NAME,XCHAR VAR
         LCLA  &I                  LOCAL COUNTER
         LCLB  &XNSECT             FLAG FOR NEW CSECT
         LCLC  &B1,&BT             1ST BASE,LAST 2 CHARS OF 1ST BASE
&B1      SETC  '&BR(1)'            GET FIRST OR ONLY BASE IN EASIER NAM
         XCHAR &B1,2               GET LAST 2 CHARS OF BASE REG
&BT      SETC  '&XXCHAR'           GET LAST 2 CHARACTERS
&XNSECT  SETB  ('&SYSECT' NE '&XCSECT')      NOTE IF NEW CSECT NEEDED
&XCSECT  SETC  '&SYSECT'           SET TO SYSECT, FOR NORMAL USE
.*                                                                    *
.*       CHECK OPT FIELD - GENERATE TITLE AND/OR ENTRY OR CSECT       *
.*       STATEMENTS, DEPENDING ON CONTENTS OF OPT FIELD, IF USED.     *
.*                                                                    *
         AIF   (T'&OPT EQ 'O').XNOPS         SKIP IF OPT UNUSED
         XLOOK TITLE,&OPT           WAS TITLE OPTION USED
         AIF   (&XXLOOK EQ 0).XNTITL         SKIP IF TITLE NOT USED
         AIF   (N'&OPT EQ 1).XNOPS SKIP IF TITLE ONLY
         TITLE '*** &LABEL ***'
.XNTITL  XLOOK ENTRY,&OPT           WAS ENTRY USED
         AIF   (&XXLOOK EQ 0).XTRCS         SKIP IF NOT USED
         AIF   ('&LABEL' EQ '').XENTE        SKIP TO ERR IF NO LABEL
         ENTRY &LABEL  .            NOTE XSAVE ENTRY OPTION
         AGO   .XNOPS
.XENTE   MNOTE 4,'**XSAVE- OPT=ENTRY USED WITHOUT LABEL-OPTION IGNORED'
         AGO   .XNOPS
.XTRCS   XLOOK CSECT,&OPT           CHECK FOR CSECT OPTION
         AIF   (&XXLOOK EQ 0).XTRCS1        SKIP IF OPTION NOT THERE
&LABEL   CSECT
&XCSECT  SETC  '&LABEL'            SET THIS TO SHOW NEW CSECT
&XNSECT  SETB  (1)                  NOTE THAT NEW CSECT IS NEEDED
         AGO   .XENT1               SKIP OVER &LABEL DEFN
.XTRCS1  MNOTE 0,'**XSAVE- UNKNOWN OPT=&OPT- IGNORED'
.*                                                                    *
.*       CREATE STATMENT LABEL IF ANY. IF IDENTIFIER REQUESTED,USE    *
.*       SPECIFIED IDENTIFIER,STATEMENT LABEL,OR CSECT NAME IN XIDENT *
.*       TO GENERATE CORRECT IDENTIFIER WITH BRANCH AROUND IT.        *
.*                                                                    *
.XNOPS   SPACE 2
&LABEL   DS    0H .                DEFINE LABEL,MAKE SURE ALIGNED
.XENT1   USING *,15 .              FOR TEMPORARY ADDRESSIBILITY
         AIF   ('&SA' EQ '*' OR '&SA' EQ 'NO').XCHKS1 SKIP IF NO CHANGE
&XSAVE   SETC  '&SA'                EXPLICIT NEW SAVE AREA NAME
         AGO   .XSAOK
.XCHKS1  AIF   ('&XSAVE' NE '').XCHKS2       SKIP IF NOT NULL
&XSAVE   SETC  '$PR#&SYSNDX'        SET UP DEFAULT SAVE AREA NAME
         AGO   .XSAOK
.XCHKS2  AIF   (NOT &XNSECT).XSAOK SKIP IF NEW SAVE NOT NEEDED
&XSAVE   SETC  '&XCSECT'(1,3).'#&SYSNDX'     DEFAULT SAVE AREA NAME
.*                                                                    *
.XSAOK   AIF   ('&ID' EQ 'NO').XID3 SKIP IF NO ID WANTED
         XIDENT &ID,&LABEL,&XCSECT,$PRIVATE CALL TO SET UP IDENT
.*                                                                    *
.*       IF TR OPTION IN EFFECT, CALL XSRTR TO GENERATE RIGHT CODE,   *
.*       THEN HAVE XSRNR GENERATE CODE TO SAVE RANGES OF REGISTERS    *
.*                                                                    *
.XID3    AIF   (&XSAVEST OR '&TR' EQ 'NO').XNOTR       SKIP IF NO TRACE
         XSRTR &TR,&LABEL,ENTERED  GET TRACE GENERATED
.XNOTR   AIF   ('&RGS' NE '(14-12)').XSRCAL SKIP IF NOT STANDARD
         STM   14,12,12(13) .      SAVE STANDARD REGISTER SET
         AGO   .XCHK13
.XSRCAL  AIF   ('&RGS' EQ 'NO').XCHK13       SKIP IF NO REGS SAVED
&I       SETA  1                   INITIALIZE COUNTER
.XSETUP  XSRNR ST,&RGS(&I)         CALL XSRNR WITH EACH REG SET
&I       SETA  &I+1                INCREMENT TO NEXT REGS SET
         AIF   (&I LE N'&RGS).XSETUP         CONTINUE PROCESSING RGS
.XCHK13  AIF   ('&BT' NE '13').XNORM1       NOT REG 13,DO NORMALLY
.*                                                                    *
.*       REGISTER 13 DOUBLE USAGE - THIS SECTION GENERATES CODE TO    *
.*       USE REGISTER 13 BOTH AS A BASE AND AS THE SAVE AREA POINTER. *
.*                                                                    *
         AIF   (T'&AD EQ 'O').XU2  SKIP TO NORMAL IF &AD OMITTED
         LR    14,13 .             SAVE @ OLD SAVE AREA BEFORE SETTING
         XMUSE &BR,&AD             HAVE ADCON SET UP
         ST    13,8(14) .          SAVE NEW POINTER INTO OLD SAVEAREA
         ST    14,4(13) .          SAVE OLD POINTER INTO NEW AREA
         AGO   .XEND1              GO FINISH UP
.XU2     CNOP  0,4
         ST    13,&XSAVE+4 .       SAVE OLD SA POINTER INTO NEW AREA
         BAL   13,&XSAVE+72 .      SET UP 13, BRANCH AROUND SA
         XMUSE &BR                 SET UP WHATEVER USING REQUIRED
&XSAVE   DC    18F'0'  .           SAVE A¢EA
.XU3     L     15,&XSAVE+4 .       GET OLD SA POINTER BACK TO SET LINKS
         ST    13,8(15) .          STORE NEW POINTER IN OLD AREA
         AGO   .XEND1              CHECK NUMBER OF BR'S,GET LA'S SET UP
.*                                                                    *
.XNORM1  AIF   (T'&REEN EQ 'O').XNORM2       SKIP OVER REENTRANT
.*                                                                    *
.*       REENTRANT ENTRY CODE GENERATION - THIS GENERATES CODE TO     *
.*       ACQUIRE SPACE FOR SAVEAREA(72 BYTES) + AS MUCH MORE SPACE    *
.*       AS IS SPECIFIED IN REEN PARAMATER, IF USED.                  *
.*                                                                    *
         AIF   ('&TR' EQ 'NO' OR &XSAVEST).XGOK        MAKE SURE REENT
         MNOTE 0,'**XSAVE- USE OF TR OPTION IMPLIES NON-REENTRANT CODE'
.XGOK    ANOP
         GETMAIN R,LV=8*((&REEN+79)/8) .GET CORE ROUNDED TO DBLWRD
         ST    13,4(1) .           STORE OLD POINTER IN NEW AREA
         ST    1,8(13) .           STORE (EW POINTER IN OLD AREA
         LR    &B1,1 .             SAVE VALUE OF NEW SAVE POINTER
         LM    0,1,20(13) .        RESTORE PREVIOUS VALUES OF REGS
         LR    13,&B1 .            POINT 13 TO NEW SAVE AREA
         AGO   .XNEWBS             GO GENERATE NEW BALR,USING
.*                                                                    *
.*       NORMAL,NON-REENTRANT ENTRY CODE SECTION.                     *
.*                                                                    *
.XNORM2  AIF   ('&SA' EQ 'NO').XNEWBS        SKIP IF NO SAVE AREA
         ST    13,&XSAVE+4 .       SAVE OLD POINTER IN NEW AREA
         AIF   ('&BT' NE '15').XSN15         SKIP IF NOT 15
         LA    13,&XSAVE .         GET ADDRESS OF NEW SAVE AREA
         L     &B1,&XSAVE+4 .      GET OLD SAVE POINTER BACK
         AGO   .XSOLD              GO SAVE NEW POINTER
.XSN15   LR    &B1,13 .            MOVE OLD POINTER OVER
         LA    13,&XSAVE    .      ADDRESS OF NEW SAVE AREA
.XSOLD   ST    13,8(&B1) .         SAVE NEW POINTER IN OLD AREA
.*             SET UP BALR, LA'S IF REQUIRED, AND USING STATEMENT.    *
.XNEWBS  AIF   ('&BT' NE '15' OR N'&BR GT 1).XSET2  SKIP IF 15
         AIF   ('&REEN' EQ '' AND '&SA' EQ 'NO' AND '&AD' EQ '').XEND2
.XSET2   AIF   (T'&AD NE 'O').XSET3          SKIP BALR IF ADCON USED
         BALR  &B1,0 .             SET UP NEW BASE REGISTER
.XSET3   XMUSE &BR,&AD             SET UP USINGS, ADCON IF NEEDED
.XEND1   AIF   (N'&BR EQ 1).XEND2  IF ONLY 1 BASE,DON'T CALL XMUSE
&I       SETA  2                    INITIALIZE
.XA2A    LA    &BR(&I),4095 .       LOAD IN ADDRESS
         LA    &BR(&I),1(&BR(&I),&BR(&I-1))  .   SET USING VALUES
&I       SETA  &I+1                 INCREMENT TO NEXT BASE
         AIF   (&I LE N'&BR AND &I LE 4).XA2A         LOOP FOR # BASES
.XEND2   SPACE 1
         MEND
         TITLE '*** XSNAP MACRO DEFINITION ***'
         MACRO
&XLABEL  XSNAP &T=PR,&LABEL=,&STORAGE=,&IF=
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XSNAP      EXTENDED SNAP MACRO-DEBUGGING-DUMPING.        *
.*                                 JOHN R. MASHEY - FEB 1970 - V.4.0  *
.*       XSNAP     IS USED FOR STORING,PRINTING OF REGISTERS AND ANY  *
.*       OTHER ADDRESSABLE AREAS. XSNAP HARMS NO REGISTERS,CAN BE USED*
.*       IN ANY NUMBER OF CSECTS IN 1 ASSEMBLY,AND PRINTS REGISTERS   *
.*       EXACTLY AS THEY ARE WHEN THE XSNAP IS CALLED.  XSNAP         *
.*       ACTION MAY BE MADE CONDITIONAL EITHER AT ASSEMBLY TIME OR    *
.*       DURING EXECUTE TIME.  SEE WRITEUP FOR OPERAND DESCRIPTION.   *
.*       USES MACROS: XLOOK                                           *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLA  &XXLOOK             XLOOK RETURN VALUE
         GBLB  &XSNAPST            GENERATION STATUS,ON=0,OFF=1
         LCLA  &I,&K,&L,&N         LOCAL COUNTERS
         LCLB  &XP,&XF             PRINT REGS AND PRINT FLOATING REGS
         LCLC  &NAM,&INST,&A(5)
.*                                                                    *
.*       CHECK FOR XSNAPS BEING CANCELLED. CREATE LABEL IF NEEDED.    *
.*                                                                    *
         AIF   ('&T(3)' NE '').XGOGEN  SKIP  SKIP IF NONCANCELLABLE
         AIF   (NOT &XSNAPST).XGOGEN   GENERATE IF STATUS=ON
         AIF   (T'&XLABEL EQ 'O').XXEXIT    SKIP IF NOTHING TO GEN
&XLABEL  DS    0H  .               LABEL USED ON NULLIFIED XSNAP
         MEXIT
.XGOGEN  SPACE 1
&NAM     SETC  'XX&SYSNDX'         SET UP MOST OF NAME FOR LABELS
&N       SETA  (N'&STORAGE/2)*2    GET ROUNDED NUMBER OF OPERANDS
&XLABEL  STM   0,15,&NAM.B  .      SAVE ALL REGISTERS
.*                                                                    *
.*       IF OPTION - IF IF OPTION IS USED AND HAS CORRECT ARGUMENTS,  *
.*       GENERATE A CLI, C, OR CR INSTRUCTION TO PERFORM APPROPRIATE  *
.*       TEST,DEPENDING ON THE KIND OF IF ARGUMENTS . NEGATE THE      *
.*       CONDITION AND CREATE THE RIGHT EXTENDED MNEMONIC BRANCH      *
.*       SO THAT THE XSNAP WILL BE SKIPPED IF THE STATED CONDTION IS  *
.*       NOT MET.  GENERATE USER'S OWN OPCODE IF HE SUPPLIED ONE.     *
.*                                                                    *
         AIF   (T'&IF EQ 'O').XNOIF          SKIP IF IF NOT REQUESTED
         AIF   (N'&IF GE 3).XOKIF  SKIP IF ENOUGH ARGUMENTS
         MNOTE 0,'**XSNAP- IF=&IF:IGNORED, LACKS REQUIRED 3-4 OPERANDS'
         AGO   .XNOIF              CANCEL IF OPTION
.XOKIF   XLOOK &IF(2),(H,L,E,O,P,M,Z,NH,NL,NE,NO,NP,NM,NZ)
         AIF   (&XXLOOK GT 0).XOKIF1        SKIP IF OK RELATION
         MNOTE 0,'**XSNAP- IF=&IF(2) UNKNOWN-CANCELLED'
         AGO   .XNOIF              SKIP GENERATION OF THIS OPTION
.XOKIF1  ANOP
&INST    SETC  '&IF(4)'            GET INSTRUCTION
         AIF   (N'&IF EQ 4).X      IF OPCODE SUPPLIED,SKIP CHECKING
&INST    SETC  'CLI'               MAKE TENTATIVE INSTRUCTION SETUP
         AIF   ('&IF(1)'(1,1) NE '(' OR '&IF(1)'(K'&IF(1),1) NE ')').X
&INST    SETC  'C'                 PROBABLY WANTS RX TYPE
         AIF   ('&IF(3)'(1,1) NE '(' OR '&IF(3)'(K'&IF(3),1) NE ')').X
&INST    SETC  'CR'                2 REGS-USER WANTS RR TYPE
.X       ANOP
         &INST &IF(1),&IF(3) .     TEST
&INST    SETC  'BN&IF(2)'          NEGATE COND, HOPE FOR 1 OF 1ST SET
         AIF   (&XXLOOK LE 7).XOKIF2        SKIP IF NOW SET UP RIGHT
&INST    SETC  'B'.'&IF(2)'(2,2)   REMOVE N FROM COND
.XOKIF2  &INST &NAM.C
.*                                                                    *
.*             CREATE BRANCH AROUND THE SAVE AREA, FLAGS, ETC.        *
.*                                                                    *
.XNOIF   XLOOK &T(1),(PR,PRINT,FL,FLOAT,NO,NOREGS,ST,STORE)
&I       SETA  72+4*&N             LENGTH FOR T=PRINT,NOREGS
         AIF   (&XXLOOK LE 6).XBRNCH        SKIP IF ILLEGAL, OR PR,NO
&I       SETA  68                  LENGTH FOR T=STORE
.XBRNCH  B     &NAM.B+&I  .        BRANCH AROUND CONSTANTS
.*                                                                    *
.*       CREATE FRONT BRACKET CHARACTER STRING FOR REGISTER AREA      *
.*                                                                    *
         DS    0F  .               ALIGN LABEL ON FULLWORD
&L       SETA  8                   SET &L FOR NO LABEL= LENGTH
         AIF   (T'&LABEL EQ 'O').XNOLAB    IF NO LABEL,SKIP GENERATION
&L       SETA  ((K'&LABEL+1)/4)*4  ROUND LENGTH UP TO FULLWORD
         AIF   (&L LE 92).XLAB1    SKIP IF LABEL SMALL ENOUGH
         MNOTE 0,'**XSNAP- LABEL= OPERAND TRUNCATED TO 92 CHARACTERS'
&L       SETA  92                  TRUNCATE
.XLAB1   DC    CL&L&LABEL
         AGO   .XCHK1              SKIP GENRATION OF 1ST DELIMETER
.XNOLAB  DC    CL8'&NAM.B'   .     FRONT BRACKET FOR REGISTER AREA
.*                                                                    *
.*             CREATE REGISTER AREA, BRACKETS, FLAG VALUES, AS NEEDED *
.XCHK1   AIF   (&XXLOOK LT 7).XPRINT        SKIP IF PRINTED OUTPUT
&NAM.B   DC    16F'-1',4C'X' .     REGISTER SAVE AREA, BRACKET X'S
         AGO   .XIFLB              SKIP TO CHECK FOR IF LABEL
.XPRINT  AIF   (&XXLOOK GT 0).XPRINT1       SKIP IF LEGAL T=
         MNOTE 0,'**XSNAP- UNKNOWN T=&T: T=PR ASSUMED'
.XPRINT1 ANOP
&XP      SETB  (&XXLOOK LT 5)      SET TO 1 IF GP REGS NEEDED
&XF      SETB  (&XXLOOK GT 2 AND &XP)       SET TO 1 IF T=FL OR T=FLOAT
&XF      SETB  (&XF OR '&T(2)' EQ 'FL' OR '&T(2)' EQ 'FLOAT')
&NAM.B   DC    16F'-1',B'&T(3)00&XF&XP',AL1(0,&L,&N/2),V(XXXXSNAP)
.*                                                                    *
.*       GENERATE ADDRESS LIST FOR STORAGE=, WITH EITHER WORDS FOR    *
.*       STORING ADDRESSES OR A-TYPE ADDRESS CONSTANTS.               *
.*                                                                    *
         AIF   (T'&STORAGE EQ 'O').OKN      SKIP IF STORAGE= NOT USED
&I       SETA  1                   INITIALIZE AS COUNTER
         AIF   (&N EQ N'&STORAGE).LOOP1               SKIP IF LEGAL
         MNOTE 0,'**XSNAP- ODD OPERAND IGNORED: STORAGE=&STORAGE(&N)'
         AIF   (&N EQ 0).OKN
.LOOP1   AIF   ('&STORAGE(&I)'(1,1) NE '*').LOOP1E
&K       SETA  1                   INITIALIZE COUNTER
.*             PROCESS ADDRESS REQUIRING LA - ST COMBINATION          *
.LOOP1A  AIF   (&I+&K GT &N).LOOP1C         SKIP IF WE'RE AT END
         AIF   ('&STORAGE(&I+&K)'(1,1) NE '*').LOOP1C SKIP IF NOT *
&K       SETA  &K+1                INCREM # CONSECUTIVE * FORMS
         AGO   .LOOP1A             GO CHECK NEXT
.LOOP1C  DS    &K.A .              WORDS WHERE ADDRESSES WILL BE STORED
&I       SETA  &I+&K               INCREMENT
         AGO   .LOOP1G             GO FOR NEXT CHECK
.*             PROCESS ADDRESS CONSTANT TYPE OF OPERAND               *
.LOOP1E  DC    A(&STORAGE(&I))
&I       SETA  &I+1                INCREMENT # OPERANDS DONE
.LOOP1G  AIF   (&I LE &N).LOOP1    CONTINUE IF ANY MORE
.*                                                                    *
.*       CREATE LOAD ADDRESS - STORE PAIRS FOR EXPRESSION ADDRESSES   *
.*                                                                    *
&I       SETA  1
.LOOP2   AIF   ('&STORAGE(&I)'(1,1) NE '*').LOOP2E    SKIP IF NOT *
&L       SETA  K'&STORAGE(&I)-1    GET # CHARS IN EXPRESSION
&K       SETA  1                   INIT COUNTER
         AIF   (&L LE 40).LOOP2A   SKIP IF SMALL ENOUGH
         MNOTE 8,'**XSNAP- STORAGE(&I) LONGER THAN 40 CHARACTERS'
&L       SETA  40                  TRUNCATE AND HOPE IT GOES
.*       BREAK EXPRESSION INTO 8 CHARACTER SECTIONS.                  *
.LOOP2A  ANOP
&A(&K)   SETC  '&STORAGE(&I)'(8*&K-6,8)      GET UP TO 8 NEXT CHARS
&K       SETA  &K+1                INCRMENT COUNTER
         AIF   (8*&K-8 LT &L).LOOP2A        LOOP UNTIL HAVE WHOLE OPR
         LA    0,&A(1)&A(2)&A(3)&A(4)&A(5)
         ST    0,&NAM.B+4*&I+68    STORE ADDRESS IN LIST
.LOOP2C  ANOP
&K       SETA  &K-1                DECRMENT SECTION TO NULL
&A(&K)   SETC  ''                  NULL FOR NEXT USE
         AIF   (&K GT 2).LOOP2C    CONTINUE UNTIL ALL BUT &A(1) NULL
.LOOP2E  ANOP
&I       SETA  &I+1                INCREMENT POSITION IN LIST
         AIF   (&I LE &N).LOOP2    CONTINUE WITH LIST
.*                                                                    *
.*       CREATE CODE TO SET UP REGISTERS FOR XXXXSNAP,CALL IT,AND     *
.*       RESTORE REGS ON RETURN.  XXXXSNAP RESTORES THE CONDTION CODE.*
.*                                                                    *
.OKN     LA    10,&NAM.B  .        GET ADDRESS OF REGISTER BLOCK
         L     15,68(10) .         GET V(XXXXSNAP) FOR BRANCH
         BALR  14,15 .             CALL XXXXSNAP,POINT 14 AT NEXT INST
         LM    0,15,0(10) .        RELOAD THE REGISTERS
.*             CREATE LABEL FOR IF OPTION, IF IT WAS USED.            *
.XIFLB   AIF   ('&INST' EQ '').XEXIT         SKIP GEN OF IF LABEL
&NAM.C   EQU   * .                 DEFINE LABEL FOR IF= BRANCH
.XEXIT   SPACE 2
.XXEXIT  MEND
         SPACE 2
         MACRO
         XSET &XSNAP=
         GBLB  &XSNAPST            =0 ==> XSNAPS, =1 ==> NONE
.*             SIMPLE XSET, JUST FOR XSNAPS.
&XSNAPST SETB  ('&XSNAP' EQ 'OFF')           1==> NO XSNAPS
         MEND
         TITLE '*** XSRNR - REGISTER LOAD-STORE FOR XRETURN-XSAVE ***'
         MACRO
         XSRNR &OP,&RG,&NO15
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XSRNR      SAVE/RESTORE REGISTERS FOR XSAVE/XRETURN      *
.*                                 JOHN R. MASHEY- FEB 1970 - V.4.0   *
.*             THIS MACRO IS USED BY XSAVE AND XRETURN TO SET UP      *
.*       REGISTER SAVING AND RESTORATION.                             *
.*       &OP IS THE OPCODE TO BE USED.  I.E.  EITHER L  OR ST.        *
.*       &RG  IS 1 OPERAND FROM THE &RGS OPERAND USED BY XSAVE AND    *
.*             XRETURN.  IT IS EITHER 1 REGISTER, OR A PAIR OF REGS   *
.*             SEPARATED BY A DASH.                                   *
.*       &NO15   =0  STATES THAT A RETURN CODE IS CURRENTLY IN REG 15 *
.*             AND SHOULD NOT BE DISTURBED, REGARDLESS OF HOW THE REGS*
.*             ARE SPECIFIED.                                         *
.*       USES MACROS: XCHAR                                           *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLC  &XXCHAR             FOR COMMUNICATION WITH XCHAR
         LCLA  &I
         LCLC  &R1,&R2             1ST REG, 2ND REG, TEMPORARY
         AIF   ('&RG' EQ 'NO').XXEXIT        DON'T GEN ANYTHING
.*             SCAN FOR DASH-MEANING 2 REGISTERS.                     *
.XSL1    ANOP
&I       SETA  &I+1                INCREMENT FOR NEXT CHARACTER
         AIF   ('&RG'(&I,1) EQ '-').XDASH    JUMP IF DASH FOUND
         AIF   (&I LT K'&RG).XSL1  CONTINUE TO END OF OPERAND
&R1      SETC  '&RG'               &RG IS 1 REGISTER BY ITSELF
         AGO   .XSAA               GO TO NEXT DECISION POINT
.*             FOUND DASH-NOW SEPARATE THE REGISTERS.                 *
.XDASH   ANOP
&R1      SETC  '&RG'(1,&I-1)       GET FIRST REGISTER
         AIF   (&I EQ K'&RG).XSAA  DUMB USER - 1 REG FOLLOWED BY -
&R2      SETC  '&RG'(&I+1,K'&RG-&I)         GET 2ND REGISTER
.XSAA    XCHAR &R1,2               GET UP TO LAST 2 CHARS OF 1ST REG
         AIF   ('&XXCHAR' NE '14' AND '&XXCHAR' NE '15').XNO1415
&I       SETA  4*&XXCHAR-44         OFFSET FOR 14 OR 15
         AIF   ('&R2' NE '').XS2RG SKIP IF 2 REGISTERS SPECIFIED
         AIF   ('&XXCHAR' EQ '15' AND '&NO15' EQ '0').XXEXIT
         &OP   &R1,&I.(13)  .       SAVE/RESTORE 1 REG
         MEXIT
.XS2RG   AIF   ('&NO15' EQ '0').XSN15        SKIP IF 15 SHOULDN'T BE
         &OP.M &R1,&R2,&I.(13)  .  SAVE/RESTORE RANGE OF REGS
         MEXIT
.XSN15   AIF   ('&XXCHAR' EQ '15').XSN15A    SKIP IF 15 SPECIFIED
         L     &R1,12(13)  .        RELOAD REG 14
         XCHAR &R2,2                GET 2ND REG
         AIF   ('&XXCHAR' EQ '15').XXEXIT    SKIP IF 15 SPECIFIED
.XSN15A  LM    0,&R2,20(13)  .     RELOAD REST OF REGS
         MEXIT
.*             RESTORE 1 REG OR RANGE (NOT STARTING WITH 14 OR 15).   *
.XNO1415 AIF   ('&R2' NE '').XLMSTM          JUMP IF MULTIPLE REGS
         &OP   &R1,&R1*4+20(13)
         MEXIT
.XLMSTM  &OP.M &R1,&R2,&R1*4+20(13)
.XXEXIT  MEND
         TITLE 'DISK UTILITY I/O DOS/OS MACROS'
         MACRO
&LA      XDKCHK    &P1,&P2,&P3
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*-->MACRO: XDKCHK                                                    *
.*       THIS MACRO WILL PRODUCE EITHER A DOS CHECK MACRO OR A        *
.*       OS VERSION OF THE CHECK MACRO                                *
.*                                                                    *
.*       &P1 IS THE OS CHECK MACRO PARAMETER                          *
.*       &P2 IS THE DOS CHECK MACRO PARAMETER                         *
.*       &P3   IF 'DOS' AND &$ASMLVL IS DOS GEN DOS CHECK             *
.*             OTHERWISE GEN &$ASMLVL TYPE CHECK                      *
.*       USES INNER MACROS: CHECK (OS OR DOS VERSION)                 *
.*                                                                    *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLB  &$ASMLVL            OS/DOS LEVEL SWITCH
&LA      DS    0H .                GEN LABEL AND BOUNDRY
         AIF   (&$ASMLVL).XOSGEN   DETERMINE LEVEL
         CHECK &P2 .               GEN DOS CHECK
.XEND    MEXIT                     ALL DONE
.XOSGEN  AIF   ('&P3' EQ 'DOS').XEND   IF NOT DEFAULT QUIT
         CHECK &P1 .               GEN OS TYPE CHECK
         MEND
         SPACE 10
         MACRO
&LA      XDKPT &P1,&P2
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*-->MACRO: XDKPT                                                     *
.*       THIS MACRO GENERATES EITHER A DOS POINTS MACRO CALL OR AN    *
.*       OS POINT MACRO CALL                                          *
.*                                                                    *
.*       &P1 IS THE DCB OR DTF NAME                                   *
.*       &P2 IS THE POINT WORD ADDRESS (OS ONLY)                      *
.*                                                                    *
.*       USES INNER MACROS: POINT (OS), POINTS (DOS)                  *
.*                                                                    *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLB  &$ASMLVL            GLOBAL ASMBLY LEVEL SWITCH
         AIF   (&$ASMLVL).XDKP1    GENERATE CORRECT MACRO VERSION
&LA      POINTS  &P1 .             DOS POINTS MACRO
         MEXIT
.XDKP1   ANOP
&LA      POINT &P1,&P2 .           OS POINT MACRO
         MEND
         SPACE 10
         MACRO
&LA      XDKWT &P1,&P2,&P3
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*-->MACRO:XDKWT                                                      *
.*       THIS MACRO WILL GENERATE A CORRECT WRITE MACRO CALL FOR      *
.*       EITHER ASSEMBLY UNDER OS OR DOS.                             *
.*                                                                    *
.*       &P1 IS THE DECB NAME                                         *
.*       &P2 IS THE FILE NAME UNDER DOS GEN AND THE DCB NAME FOR OS   *
.*       &P3 IS THE AREA ADDRESS FOR BOTH LEVELS OF GENERATION        *
.*                                                                    *
.*       THIS MACRO GENERATES AN EXECUTE FORM MACRO FOR OS            *
.*       ALL OPERANDS ARE ASSUMED CORRECT AS NO ERROR CHECKING        *
.*       IS PERFORMED                                                 *
.*                                                                    *
.*       USES INNER MACROS: WRITE (OS FORM OR DOS FORM)               *
.*                                                                    *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLB  &$ASMLVL            GLOBAL SWITCH FOR ASSEMBLY LEVEL
         AIF (NOT &$ASMLVL).XWT1   GEN CORRECT CALL BY LEVEL SWTCH
&LA      WRITE &P1,SF,&P2,&P3,MF=E .        GENERATE AN OS MACRO CALL
         MEXIT
.XWT1    ANOP
&LA      WRITE &P2,SQ,&P3 .        GENERATE A DOS MACRO CALL
         MEND
         SPACE 10
         MACRO
&LA      XDKRD &P1,&P2,&P3
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*-->MACRO: XDKRD                                                     *
.*       THIS MACRO WILL GENERATE A CORRECT READ MACRO CALL FOR       *
.*       EITHER ASSEMBLY UNDER OS OR DOS.                             *
.*                                                                    *
.*       &P1 IS THE DECB NAME                                         *
.*       &P2 IS THE DCB ADDRESS FOR OS AND THE FILENAME UNDER DOS     *
.*       &P3 IS THE AREA ADDRESS FOR BOTH LEVELS OF ASSEMBLY          *
.*                                                                    *
.*       THIS MACRO GENERATES AN EXECUTE FORM MACRO FOR OS            *
.*       ALL OPERANDS ARE ASSUMED CORRECT AS NO ERROR CHECKING        *
.*       IS PERFORMED                                                 *
.*                                                                    *
.*       USES INNER MACROS: READ (OS FORM OR DOS FORM)                *
.*                                                                    *
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLB  &$ASMLVL            GLOBAL SWITCH FOR ASSEMBLY LEVEL
         AIF   (NOT &$ASMLVL).XRE1  GEN CORRECT CALL BY LEVEL SWTCH
&LA      READ &P1,SF,&P2,&P3,MF=E .         GENERATE AN OS MACRO CALL
         MEXIT
.XRE1    ANOP
&LA      READ  &P2,SQ,&P3 .                 GENERATE A DOS MACRO CALL
         MEND
         SPACE 10
         TITLE 'XXDKDECB MACRO DEFINE CONTROL BLOCKS FOR DISK UTILITY'
         MACRO
&LABEL   XXDKDECB   &II
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XXDKEDCB GENERATE TABLE OF DECBS FOR DISK UTILITY        *
.*       THIS MACRO GENERATES A LINKED TABLE OF DECBS.                *
.*       THE BUFFER ADDRESSES ARE PLACED IN THE DECB BY XXXXDKOP      *
.*       USES MACRO: WRITE                                            *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLB  &$ASMLVL            LEVEL OF ASSEMBLY SWITCH
         LCLA  &I,&XXLNK           LCL COUNTER AND LINK FACTOR(OS/DOS)
&I       SETA  &II                 INITIALIZE FOR UNIQUE NAMES
         AIF   (&$ASMLVL).OS1      GENERATE CORRECT LINK FACTOR(OS/DOS)
&XXLNK   SETA  8                   DOS LEVEL LINK FACTOR
         AGO   .OS2
.OS1     ANOP
&XXLNK   SETA  24                  OS LEVEL LINK FACTOR
.OS2     ANOP
         SPACE 2
&LABEL   DS    0F .                DEFINE LABEL, ALIGN TO FULLWORD
         AIF   (&I EQ 1).DESTOP    BRANCH IF LAST ENTRY
.DENEXT  DC    A(*+&XXLNK) .       LINK TO NEXT ENTRY
         AIF   (&$ASMLVL).XXDK1    LEVEL DEPENDENT CODE GENERATION
         DC    F'0'                FULLWORD FOR FAKE DECB
         AGO   .XXDK2
.XXDK1   WRITE XXDECB&I,SF,XXDKUDCB,0,MF=L    GENERATE A DECB
.XXDK2   SPACE 2
&I       SETA  &I-1                DECREMENT COUNTER
         AIF   (&I GT 1).DENEXT    LOOP IF NOT LAST ENTRY
.DESTOP  DC    A(&LABEL) .         LAST ENTRY, LINK TO TOP OF TABLE
         AIF   (&$ASMLVL).XXDK3    LEVEL OF ASSEMBLY
         DC    F'0'                FULLWORD FOR FAKE DECB
         AGO   .XXDK4
.XXDK3   WRITE XXDECB&I,SF,XXDKUDCB,0,MF=L    GENERATE A DECB
.XXDK4   SPACE 5
         MEND
         SPACE 3
         MACRO
&L       $DISK &TYPE
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $DISK     CALL DISK UTILITY                              *
.*       $DISK CALLS MACRO XIONR TO SET UP A BRANCH TO A DISK         *
.*       UTILITY ROUTINE.                                             *
.*       USES MACRO: XIONR                                            *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
&L       XIONR XXXXDK&TYPE,0,(0)   CALL DISK UTILITY
         MEND
         TITLE '$ERCGN MACRO - GENERATE COMPLETION CODE BLOCK '
         MACRO
&LABEL   $ERCGN &CODE,&MSSG,&TYPE=SYSTEM
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $ERCGN     GENERATE COMPLETION CODE BLOCK FOR XXXXSNAP   *
.*       EACH CALL CREATES 1 ENTRY DESCRIBED BY DSECT ERCOMPCD.       *
.*                                                                    *
.*       &CODE     CHARACTER VALUE OF ERROR CODE NUMBER.              *
.*       &MSSG     ERROR MESSAGE TO BE PRINTED                        *
.*       &TYPE     TYPE OF COMPLETION CODE - SYSTEM, ASSIST, OR USER. *
.*                                                                    *
.*       *NOTE* IF &$OPTMS = 0, NO MESSAGE WILL BE GENED, ONLY CODE.  *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLA  &$OPTMS             MEMORY OPTIMIZATION(0=SMALL)
         LCLA  &I                  FOR LENGTH
         LCLC  &T                  FOR TYPE
&T       SETC  'ERC&TYPE'(1,7)     GET EQU FOR TYPE
&I       SETA  K'&CODE+K'&MSSG-2   GET LENGTH OF TOTAL MESSAGE
         AIF   (&$OPTMS GT 0).ERCA     SKIP IF NOT MINIMAL MEMORY
&I       SETA  K'&CODE-1           GET LENGTH - 1 OF ERROR CODE
&LABEL   DC    AL2(256*&I+&T),C'&CODE'
         AGO   .XXEXIT             QUIT
.ERCA    ANOP
&LABEL   DC    AL2(256*&I+&T),C'&CODE ',C&MSSG
.XXEXIT  MEND
         SPACE 2                                                      S
         MACRO                                                        A
&LABEL   $MSG  &NMBR,&MSG,&FLAG=0                                     A
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $MSG                  USED TO GENERATE LINE IN MSG TABLE *
.*       &NMBR IS MESSAGE #   (3 DIGITS)                              *
.*       &MSG IS QUOTED STRING OF MESSAGE                             *
.*       &FLAG IS FLAG BYTE                                           *
.* GENERATES:(LENGTH-1 OF MSG): #BYTES +3 FOR LENGTH OF MSG           *
.*       (FLAG BYTE): 1 BYTE                                          *
.*       (CHAR FORM OF NMBR): 3 BYTES                                 *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLA  &$OPTMS             MEMORY OPTIMIZATION(0=SMALL)       S
         LCLA  &K                  FOR K'&MSG                         S
         AIF   (&$OPTMS EQ 0).SMALL   SKIP FOR MIMIMAL MEMORY         S
&K       SETA  K'&MSG-2-1+3   MSG-QUOTES-1+LENGTH OF NMBR             S
&LABEL   DC    AL1(&K,&FLAG),CL3'&NMBR',C&MSG                         S
         MEXIT                                                        S
.SMALL   ANOP                                                         S
&LABEL   DC    AL1(2,&FLAG),CL3'&NMBR'                                S
         MEND                                                         S
         TITLE '*** CARD-PUNCH, LINE-PRINT MACROS - $PNCH,$PRNT ***'
         MACRO
&LABEL   $PNCH &XAREA,&XNUM,&OVER
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $PNCH      PUNCH A CARD, BRANCH IF RECORD OVERFLOW       *
.*       &XAREA,&XNUM-SEE XIONR MACRO FOR EXPLANATION, OR XPNCH WRTUP *
.*       &OVER IS LABEL TO BE BRANCHED TO IF RECORDS EXCEED LIMIT.    *
.*       USES MACROS: XIONR                                           *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
&LABEL   XIONR XXXXPNCH,&XNUM,&XAREA,80     HAVE CONTROL BLOCK SET
         AIF   ('&OVER' EQ '').XXEXIT       SKIP IF OVER NOT SPEC
         BL    &OVER   .           BRANCH IF EXCEEEDED RECORD COUNT
.XXEXIT  MEND
         SPACE 4
         MACRO
&LABEL   $PRNT &XAREA,&XNUM,&OVER
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $PRNT      PRINT A LINE, BRANCH IF RECORD OVERFLOW.      *
.*       &XAREA,&XNUM-SEE XIONR MACRO FOR EXPLANATION, OR XPRNT WRITUP*
.*       &OVER IS LABEL TO BE BRANCHED TO IF RECORDS EXCEED LIMIT.    *
.*       USES MACROS: XIONR                                           *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
&LABEL   XIONR XXXXPRNT,&XNUM,&XAREA,133    HAVE BLOCK SETUP
         AIF   ('&OVER' EQ '').XXEXIT       SKIP IF NO LABEL
         BL    &OVER    .          BRANCH IF EXCEEDED RECORDS
.XXEXIT  MEND
         TITLE '*** CARD-READ MACROS - $READ,$SORC ***'
         MACRO
&LABEL   $READ &XAREA,&XNUM,&EOF
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $READ      READ CARD DURING EXECUTION, BRANCH IF EOF.    *
.*       &XAREA,&XNUM-SEE XIONR MACRO FOR EXPLANATION, OR XREAD WRITUP*
.*       &EOF      LABEL TO BE BRANCHED TO IF END-FILE OCCURS.        *
.*       USES MACROS: XIONR                                           *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
&LABEL   XIONR XXXXREAD,&XNUM,&XAREA,80   SET UP CONTROL BLOCK
         AIF   (T'&EOF EQ 'O').XXEXIT       SKIP IF NO LABEL
         BL    &EOF   .            TAKE BRANCH IF END OF FILE
.XXEXIT  MEND
         SPACE 4
         MACRO
&LABEL   $SORC &XAREA,&XNUM,&EOF
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $SORC      READ ASSEMBLER SOURCE CARD, BRANCH IF EOF.    *
.*       &XAREA,&XNUM-SEE XIONR MACRO FOR EXPLANATION, OR XREAD WRITUP*
.*       &EOF      LABEL TO BE BRANCHED TO IF END-FILE OCCURS.        *
.*       USES MACROS: XIONR                                           *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
&LABEL   XIONR XXXXSORC,&XNUM,&XAREA,80  SET UP CONTROL BLOCK         *
         AIF   (T'&EOF EQ 'O').XXEXIT       SKIP IF NO LABEL
         BL    &EOF   .            BRANCH IF END-FILE
.XXEXIT  MEND
         TITLE 'SPECIAL XGET AND XPUT MACROES FOR ASSIST'
         MACRO
&XLABEL  $GET  &XAREA,&XNUM
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $GET  INTERNAL XGET MACRO FOR ASSIST.                    *
.*                                      RICHARD FOWLER NOV, 1972 V.5.0*
.*       LIKE XGET BUT CONVERTS USER REG1 AND SETS ACTUAL R1 TO       *
.*       ACTUAL ADDRESS.  ALSO CALLS XDDGET.                          *
.*                                                                    *
.*       EXECUTION ASSUMES USER REGISTER POINTS TO DDNAME.            *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
&XLABEL  L     R1,ECREG1           GET USER @ DDNAME
         AR    R1,RMEM             GET REAL ADDRESS
         XIONR XDDGET,&XNUM,&XAREA,80
.XMEND   MEND
         SPACE 5
         MACRO
&XLEBEL  $PUT  &XAREA,&XNUM
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $PUT                                                     *
.*       LIKE $GET, BUT CALLS XDDPUT.                                 *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
&XLEBEL  L     R1,ECREG1           GET USER @ DDNAME
         AR    R1,RMEM             GET REAL ADDRESS
         XIONR XDDPUT,&XNUM,&XAREA,133
.XMEND   MEND
         TITLE 'EXTENDED I/O MACROES XGET AND XPUT'
         MACRO
&XLABEL  XGET  &XAREA,&XNUM
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XGET    GET RECORD OFF OF &DDNAME FILE                   *
.*                                 RICHARD FOWLER AUG, 1972 V.5.0     *
.*       MACRO FOR EASY READING OFF OF ANY DD FILE, READS &XNUM       *
.*       CHARACTERS. CONDITION CODE SET TO 0 NORMALLY, OR TO 1 ON     *
.*       END OF FILE. GENERATION CONTROLLED BY &XGETST.               *
.*       EXECUTION ASSUMES REG 1 POINTS TO DD NAME                    *
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **
         GBLB  &XGETST             GENERATION STATUS- 0=YES, 1=NO
         AIF   (&XGETST).XNOGEN    IF SHOULDN'T GENERATE-SKIP CALL
&XLABEL  XIONR XXXXGET,&XNUM,&XAREA,80   SET UP CONTROL BLOCK
         MEXIT
.XNOGEN  AIF   (T'&XLABEL EQ 'O').XXEXIT     GEN LABEL ONLY IF NEEDED
&XLABEL  DS    0H .                LABEL FOR CANCELLED XGET
.XXEXIT  MEND
         SPACE 5
         MACRO
&XLABEL  XPUT  &XAREA,&XNUM
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XPUT           PUT A RECORD ONTO FILE &DDNAME            *
.*                                 RICHARD FOWLER AUG 1972 V.5.0      *
.*       MACRO FOR EASY PRINTING ONTO ANY DD FILE. RECORD LENGTH=&XNUM*
.*       IF PRINT FILE, FIRST CHARACTER IS USED AS CARRIAGE CONTROL   *
.*       GENERATION CONTROLLED BY &XPUST                              *
.*       EXECUTION ASSUMES REG 1 POINTS TO DD NAME                    *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLB  &XPUTST             GENERATION STATUS- 0=YES, 1=NO
         AIF   (&XPUTST).XNOGEN    IF SHOULDN'T GENERATE, SKIP CALL
&XLABEL  XIONR XXXXPUT,&XNUM,&XAREA,133   SET UP CONTROL BLOCK
         MEXIT
.XNOGEN  AIF   (T'&XLABEL EQ 'O').XXEXIT     GEN LABEL ONLY IF NEEDED
&XLABEL  DS    0H .                LABEL FOR CANCELLED XPUT
.XXEXIT  MEND
         TITLE 'MACRO---XGPSRCH--- INNER MACRO FOR XGPGN MACRO'
         MACRO
        XXGPSRCH &DIREC,&TIME
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*-->MACRO: XXGPSRCH  INNER MACRO FOR XGPGEN                          *
.*     ARGUMENTS:                                                     *
.*       &DIREC= G--> INPUT                                           *
.*               P--> OUTPUT                                          *
.*       &TIME=1 --> FIRST CALL, SETS UP EXTRA CODE AND ACTS AS &SYSND*
.*             2--> SECOND CALL                                       *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         L     R3,X&DIREC.ELEM .   GET # LAST POINTER TO OPEN FILES
         LA    R1,X&DIREC.PNTSRT . GET @ OF FIRST POINTER
         LTR   R3,R3 .             ARE THERE ANY ELEMENTS?
         BE    X&DIREC.MAKE&TIME   NO - GO CREATE ONE
         LA    R2,12 .             SET UP INCREMENT SIZE
X&DIREC.LOOP&TIME CLC 0(8,R1),X&DIREC.CURENT COMPARE DD NAMES
         BE    X&DIREC.CONT&TIME   IF EQUAL, GO TO I/O
         BXLE  R1,R2,X&DIREC.LOOP&TIME ^EQUAL, SEARCH TILL END OF TABLE
         SPACE 2
         MEND
         TITLE 'MACRO---XGPGEN--- GENERATE GENERAL I/O MODULES'
         MACRO
&LABEL   XGPGEN &DIREC=G,&FETCH=NOT,&DDNUM=20
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XGPGEN  GENERATE GENERAL I/O MODULES                     *
.*                                    RICHARD FOWLER NOV, 1972 V.5.0  *
.*                                                                    *
.*       ARGUMENTS:                                                   *
.*             &DIREC = P --> OUTPUT                                  *
.*                   ^= P --> INPUT                                   *
.*             &FETCH  =NOT --> NO FETCH PROTECTION                   *
.*                    =PROTECT -->    FETCH PROTECTION                *
.*             &DDNUM = MAXIMUM NUMBER OF DD NAMES ALLOWED AT ONCE    *
.*     (**EACH DD FILE REQUIRES 3F TABLE ENTRY PLUS DCB AND BUFFER**) *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         TITLE ' &LABEL - MODULE CREATED BY XGPGEN'
&LABEL   CSECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> CSECT: EXTENDED I/O MODULE FOR GENERAL I/O                       *
*        THIS MODULE IS CALLED TO DO GENERAL I/O WORK ON A FILE       *
*              SIMILAR IN OPERATION TO XIO ROUTINES, BUT CAN HANDLE   *
*              MANY FILES AT ONCE.                                    *
*        ENTRY CONDITIONS:                                            *
*          R14 = @ OF CONTROL BLOCK                                   *
*          R15  = ENTRY POINT ADDRESS                                 *
*          R0  = ADDRESS OF AREA TO MOVE DATA INTO                    *
*          R1  = ADDRESS OF DD NAME TO BE USED                        *
*        CONTROL BLOCK:                                               *
*      OFFSET  LENGTH        WHAT                                     *
*        0       1F        ENTRY POINT ADDRESS                        *
*        4       3F          SAVE AREA                                *
*        16      2           LENGTH OF AREA                           *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         USING *,15 .              NOTE TEMPORARY ADDRESSABILITY
         USING XIOBLOCK,R14
         STM   R13,R7,X&DIREC.SAV1 SAVE REGISTERS TO BE USED          A
         CNOP  0,4 .               GET ON FULLWORD
         BAL   R13,*+76            SET UP FAKE AREA PNTR - BASE
         USING *,R13 .             NOTE NEW USING/SAVE AREA POINTER
         DS    18F .               FAKE SAVE AREA
         DROP  R15 .               KILL OLD ADDRESSING
         SPACE 2
         USING IHADCB,R1 .         SET UP ADDRESSIBILITY TO DCB S
         MVC   X&DIREC.CURENT(8),0(R1) . GET CURRENT DD NAME
*   CHECK FOR CLOSE
         SR    R1,R1               GET ZERO LENGTH INDICATOR
         CH    R1,XIOLENG          ARE THEY EQUAL?
         BE    X&DIREC.EOF .       YES-GO CLOSE AND FORGET FILE
         XXGPSRCH &DIREC
*  THE FOLLOWING CODE, IF EXECUTED, GENERATES A DCB AND TRIES AN OPEN
*
X&DIREC.MAKE C R1,=A(X&DIREC.FULL) CHECK FOR TABLE OVERFLOW
         BNL   X&DIREC.CC3         NO SPACE, DON'T TRY OPEN-RETURN    J
         ST    R1,X&DIREC.ELEM .   SAVE NEW ADDRESS, R1 ALREADY POINTIN
         MVC   0(8,R1),X&DIREC.CURENT  SAVE DD NAME FOR FUTURE CALLS
         L     0,X&DIREC.LONG      LOAD R2 WITH LENGTH OF DCB
         GETMAIN R,LV=(0) .        GET SPACE FROM OS
         L     R2,X&DIREC.ELEM .   GET ADDRESS OF POINTER
         ST    R1,8(R2) .          SAVE @ OF DCB
*
         ST    R1,X&DIREC.FULL     KLUDGE TO GET AROUND ADDRESSIBILITY
         MVC   X&DIREC.OPEN+1(3),X&DIREC.FULL+1  COPY OVER DCB @ INTO J
*
         MVC   0(X&DIREC.ELEM-X&DIREC.DCB,R1),X&DIREC.DCB BUILD DCB
         MVC   DCBDDNAM,X&DIREC.CURENT MOVE DD NAME INTO DCB
         OPEN  MF=(E,X&DIREC.DCBPTR)  DO REMOTE OPEN
         L     R1,X&DIREC.FULL .   FIX R1, DESTROYED IN OPEN
         TM    DCBOFLGS,X'10' .    DID OPEN GO?
         BO    X&DIREC.CONT4       YES, DO I/O
*              OPEN DIDN'T GO - CLEAN UP SO DOESN'T BOMB LATER        J
         L     R0,X&DIREC.LONG     GET LENGTH OF DCB FOR FREEMAIN     J
         FREEMAIN R,LV=(0),A=(1)   GIVE THE SPACE BACK TO OS          J
         XC    0(12,R2),0(R2)      CLEAR OUT SO WON'T THINK IT'S OPEN J
X&DIREC.CC3 TM *+1,X'FF'           SET CC=3  ==> OPEN IMPOSSIBLE      J
         B     X&DIREC.RET         RETURN TO USER
         SPACE 2
X&DIREC.CONT L R1,8(R1) .          GET DCB ADDRESS
X&DIREC.CONT4 LH R5,XIOLENG        GET LENGTH OF AREA
         AIF   ('&FETCH' EQ 'PROTECT').SKPFTCH
         L     R2,X&DIREC.SAV1+12  GET @ I/O AREA
* THE FOLLOWING CODE IS USED FOR ADDRESS ILLEGAL     ******************
*****  THIS CODE WILL NOT WORK IF MACHINE HAS FETCH PROTECT ***********
         SPACE 2
         L     R4,16 .             GET CVT PNTR FROM LOC 16
         LA    R0,0(R2,R5) .       GET ENDING ADDRESS OF I/O AREA
         C     R0,164(R4) .        COMPARE TO CVTMZ00 - HIGHEST ADDRESS
         BNL   X&DIREC.ABD3 .      GO ABEND IF HIGHER
.SKPFTCH ANOP
         AIF   ('&DIREC' EQ 'P').XOUT  SKIP IF OUTPUT
         LH    R7,DCBLRECL         GET LRECL FROM DCB                 J
         GET   IHADCB .            GET # BUFFER
         CLR   R5,R7               COMPARE REQUEST LENGTH TO LRECL    J
         BNH   *+6                 SKIP AROUND IF OK                  J
         LR    R5,R7               TOO BIG, USE LRECL INSTEAD         J
         LR    R4,R5 .             SET UP FOR SHIFT
         SRDL  R4,8 .              PUT RIGHTMOST BYTE IN R5
         SRL   R5,24 .             RIGHT JUSTIFY FOR MOVE
         LTR   R4,R4 .             ANYTHING LEFT IN R4?
         BE    *+22 .              NO - DO NORMAL MOVE
         MVC   0(256,R2),0(R1) .   GIVE USER 256 BYTES OF DATA
         LA    R2,256(R2) .        GO TO NEXT BLOCK
         LA    R1,256(R1) .        GO TO NEXT BLOCK
         BCT   R4,*-14 .           IF ANYTHING LEFT IN R4, DO ANOTHER
*              NORMAL MOVE FOLLOWS
         LTR   R5,R5 .             IS ANYTHING IN R5?
         BE    *+10 .              NO - DONT MOVE LEFTOVER BYTES
         BCTR  R5,0 .              DECREMENT LENGTH BY 1
         EX    R5,X&DIREC.MOV .    MOVE INTO RIGHT PLACE
.XCLOSE  ANOP
         SR    R0,R0 .             SET COND CODE TO 0, USER OK
         B     X&DIREC.RET .       GO TO RETURN                       B
X&DIREC.EOF EQU *                  CLOSE IHADCB
         XXGPSRCH &DIREC,2
X&DIREC.MAKE2 B X&DIREC.RET .      GO RETURN
X&DIREC.CONT2 LR R4,R1 .           SAVE THE ADDRESS
         MVC   X&DIREC.PTR+1(3),9(R1)
         LA    R1,X&DIREC.PTR
         CLOSE MF=(E,(1))          DO REMOTE CLOSE
         L     R1,8(R4) .          POINT TO DCB TO FREE
         FREEPOOL (1)              FREE THE BUFFERS
         L     R1,8(R4)            RESET R1 IN CASE DESTROYED
         L     R0,X&DIREC.LONG     GET AMOUNT TO FREE
         FREEMAIN R,LV=(0),A=(1)
*
*   DCB NO LONGER EXISTS,  REMOVE CORRESPONDING ELEMENT FROM LIST
*
         LA    R3,X&DIREC.FULL .    GET UPPER ADDRESS OF TABLE
         SR    R3,R4   .           FIND LENGTH OF REST OF TABLE
         EX    R3,X&DIREC.WIPOUT   WIPE OUT 12 BYTES OF MEMORY
*
*      IF NO POINTERS REMAIN, SET POINTER TO LAST = ZERO
*
         LA    R3,12
         L     R2,X&DIREC.ELEM
         SR    R2,R3
         LA    R1,X&DIREC.PNTSRT
         CR    R1,R2
         BNH   *+8
         LA    R2,0 .              SET POINTER TO ZERO
         ST    R2,X&DIREC.ELEM     SAVE POINTER
         AIF   ('&DIREC' EQ 'P').XRET
         OI    *+1,1 .             SET COND CODE FOR END OF FILE
.*       SHOULD REMOVE DCB FROM LIST NOW
         AGO   .XRET .             HAVE RETURN CODE GENERATED
.*
.XOUT    ANOP
         LH    R7,82(R1) .         GET LRECL
         PUT   IHADCB .            PRINT THE STUFF
         CLR   R5,R7               COMPARE REQUEST LENGTH TO LRECL    J
         BNH   *+6                 SKIP AROUND IF OK LENGTH           J
         LR    R5,R7               TOO BIG- USE LRECL INSTEAD         J
         LR    R4,R5 .             SET UP FOR SHIFT
         LR    R6,R5               SAVE FOR LATER
         SRDL  R4,8 .              PUT RIGHTMOST BYTE IN R5
         SRL   R5,24 .             RIGTH JUSTIFY FOR MOVE
         LTR   R4,R4 .             ANYTHING LEFT IN R4?
         BE    *+22 .              NO - DO NORMAL MOVE
         MVC   0(256,R1),0(R2) .   PUT STUFF INTO BUFFER
         LA    R2,256(R2) .        GO TO NEXT BLOCK
         LA    R1,256(R1) .        GO TO NEXT BLOCK
         BCT   R4,*-14 .           IF ANYTHING LEFT IN R4, DO ANOTHER
*              NORMAL MOVE FOLLOWS
         LTR   R5,R5 .             IS ANYTHING IN R5?
         BE    *+12
         BCTR  R5,0 .              DECREMENT LENGTH BY 1
         EX    R5,X&DIREC.MOV .    MOVE INTO RIGHT PLACE
         AR    R1,R5               GET BEGINNING @ TO BLANK
         SR    R7,R6               GET DIFFERENCE BETWEEN USER AND DCB
         BZ    *+12                NO DIFFERENCE, DO NOTHING          A
         MVI   1(R1),C' '
         EX    R7,X&DIREC.MOV2     CLEAR REST
*  ****NOTE THAT THIS ONLY WORKS FOR DIFFERENCES < 256
         AGO   .XCLOSE
.*
.XRET    ANOP
         SPACE 2
X&DIREC.RET LM R13,R7,X&DIREC.SAV1 RESTORE REGS                       A
         B     XIORETRN            RETURN
         DROP  R14
X&DIREC.ABD3 CLI  *,0              SET CC=2, SHOW EXECUTE ERROR       J
         B     X&DIREC.RET         GO RETURN, SHOWING ERROR           J
.*
         SPACE 2
X&DIREC.PTR CLOSE (X&DIREC.CONT),MF=L    GENERAL PURPOSE CLOSE
X&DIREC.WIPOUT MVC 0(1,R4),12(R4)
X&DIREC.CURENT DS  CL8  .          AREA TO HOLD CURRENT DD NAME
X&DIREC.SAV1 DS 11F                SAVE AREA FOR REGS USED            A
X&DIREC.PNTSRT DS (&DDNUM*3)F .    AREA FOR DDNUM DD NAMES & POINTERS
X&DIREC.FULL DS F
X&DIREC.OPEN DS 0F                 EXTRA LABEL
         AIF   ('&DIREC' EQ 'P').XDEFSR  SKIP IF OUTPUT
X&DIREC.DCBPTR OPEN (X&DIREC.CONT,(INPUT)),MF=L  OPEN CONTROL WORD    J
X&DIREC.DCB DCB DSORG=PS,MACRF=GL,EODAD=X&DIREC.EOF
X&DIREC.ELEM DC  F'0' .            INITIAL # OF ELEMENTS
XX&DIREC.LONG EQU X&DIREC.ELEM-X&DIREC.DCB   GET DCB LENGTH
X&DIREC.LONG DC A(XX&DIREC.LONG)   SAVE LENGTH OF DCB
X&DIREC.MOV MVC 0(1,R2),0(R1) .    GIVES USER THE DATA
         LTORG
         DROP  R13
         MEXIT                     DONE
.XDEFSR  ANOP
X&DIREC.DCBPTR OPEN (X&DIREC.CONT,(OUTPUT)),MF=L OPEN CONTROL WORD    J
X&DIREC.DCB DCB DSORG=PS,MACRF=PL
X&DIREC.ELEM DC F'0' .             INITIAL # OF ELEMENTS
XX&DIREC.LONG EQU X&DIREC.ELEM-X&DIREC.DCB   GET DCB LENGTH
X&DIREC.LONG DC A(XX&DIREC.LONG)   SAVE LENGTH OF DCB
X&DIREC.MOV MVC 0(1,R1),0(R2) .    MOVE INTO LINE
X&DIREC.MOV2 MVC 2(1,R1),1(R1)     CLEAR OUT REST OF BUFFER
         LTORG
         DROP  R13
         MEND
         TITLE '***MACRO*** XDDSLOT  GENERATES XGET-XPUT CONTROL TABLE'
         MACRO
&LABEL   XDDSLOT &NAME,&WHICH,&POSIN=0,&POSOUT=0,&PERM=1,&REST1=00,    X
               &REST2=0
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XDDSLOT CREATE TABLE ENTRY FOR XGET-XPUT                 *
.*                                    RICHARD FOWLER OCT. 1972. V.5.0 *
.*                                                                    *
.*       THIS MACRO GENERATES AN ELEMENT TO HELP ASSIST KEEP          *
.*             CONTROL OF THINGS WHILE EXECUTING XGET-XPUT.           *
.*             &NAME CHAR STRING OF RESERVED DD NAME                  *
.*             &WHICH  MISSING OR IN ERROR, USER MAY XGET-XPUT IT     *
.*                 =XREAD   USER CAN XREAD ONLY                       *
.*                 =XPRNT   USER CAN XPRNT ONLY                       *
.*                 =XPNCH   USER CAN XPNCH ONLY                       *
.*                                                                    *
.*             &POSIN = 1 CAN INPUT                                   *
.*                    = 0 CANNOT INPUT                                *
.*                                                                    *
.*             &POSOUT = 1 CAN OUTPUT                                 *
.*                     = 0 CANNOT OUTPUT                              *
.*             &PERM = 1 ON REENTERING, &NAME WILL STILL EXIST        *
.*                   =0  &NAME WILL NOT EXIST ON REENTERING           *
.*                                                                    *
.*             &REST 1,2  NOT USED                                    *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         AIF   (T'&NAME EQ 'O').DDEMPTY   CREATE AN EMPTY SLOT
&LABEL   DC    CL8'&NAME' .        NO, SHOVE IN DDNAME
.*             SET BITS, NOTE NOT CURRENTLY OPEN
         DC    B'00&REST1&POSOUT&POSIN&REST2&PERM'
         AIF   (T'&WHICH NE 'O').DDSK1      WAS &WHICH OMITTED
.DDSK4   DC    XL1'00' .           YES ASSUME XGET-XPUT
         MEXIT
.DDSK1   AIF   ('&WHICH' NE 'XREAD').DDSK2   READ ONLY?
         DC    XL1'04' .           YES,  FIX INDEX
         MEXIT
.DDSK2   AIF   ('&WHICH' NE 'XPRNT').DDSK3  DO WRITES ONLY?
         DC    XL1'08' .           YES,   FIX INDEX
         MEXIT
.DDSK3   AIF   ('&WHICH' NE 'XPNCH').DDSK4 IF INVALID, ASSUM XGET-XPUT
         DC    XL1'0C' .           VALID,  SET INDEX
         MEXIT
.DDEMPTY ANOP
&LABEL   DC    CL8' ' .            BLANK DDNAME
         DC    XL2'0C00' .         BLANK EVERYTHING, XGET-XPUT ALLOWED
         MEND
         TITLE '*** LINKAGE MACROS - $CALL,$RETURN,$SAVE ***'
         MACRO
&LABEL   $CALL &ENTRY
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $CALL      SUBROUTINE CALL INSIDE ASSIST ASSEMBLER.      *
.*       &ENTRY    ENTRY POINT NAME TO BE CALLED, OS LINKAGE.         *
.*       **NOTE** GENERATES NAME WITH AX PREFIX, SO CAN ONLY BE USED  *
.*       INSIDE ASSEMBLER WHERE AVWXTABL USING HOLDS.                 *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
&LABEL   L     REP,AX&ENTRY .      GET ADCON FROM THE TABLE
         BALR  RET,REP .           CALL THE DESIRED ROUTINE
         MEND
         SPACE 2
         MACRO
&LABEL   $RETURN &RGS=NO,&SA=
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $RETURN    RETURN FROM SUBROUTINE, OS LINKAGE.           *
.*       SUPPLIES EXTRA DEBUGGING CONTROL AND DEFAULTS TO XRETURN.    *
.*       USES MACROS: XRETURN                                         *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLC  &TRACE              SPECIFIES FORM OF TRACE-SNAP,*,NO
&LABEL   XRETURN RGS=&RGS,SA=&SA,TR=&TRACE
         MEND
         SPACE 2
         MACRO
&LABEL   $SAVE &RGS=NO,&BR=15,&SA=
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $SAVE      SUBROUTINE ENTRY SETUP, OS LINKAGE.           *
.*       SUPPLIES EXTRA DEBUGGING CONTROL AND DEFAULTS TO XSAVE MACRO.*
.*       USES MACROS: XSAVE                                           *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLC  &TRACE,&ID          TRACE FORM, IDENT
&LABEL   XSAVE RGS=&RGS,BR=&BR,SA=&SA,TR=&TRACE,ID=&ID
         MEND
         SPACE 2
         MACRO
         $DBG  &D,&T
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $DBG       SET TRACE, DEBUGGING SET VARIABLES FOR ASM.   *
.*       &D        HEX FLAG BYTE FOR USE IN TM INSTRUCTION.           *
.*       &T        IS TRACE MODE FOR AN XSNAP = NO,*,SNAP.            *
.*       SEE MACROS $RETURN,$SAVE,XSRTR FOR GENERATION OF TRACE CODE  *
.*       ON ROUTINE ENTRY/EXIT. SEE ALSO ASSIST PROGRAM LOGIC MANUAL. *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLC  &DEBUG,&TRACE       DEBUG FLAG BYTE,TRACE MODE
         AIF   ('&D' EQ '').D1     SKIP IF OMITTED,DON'T CHANGE
&DEBUG   SETC  'X''&D'''           SET FLAG BYTE FOR MASK
.D1      AIF   ('&T' EQ '').D2     SKIP IF NOTRACE,DON'T CHANGE
&TRACE   SETC  '&T'                SET UP TRACE MODE,IF ANY
.D2      MEND
         TITLE '*** $AL2 MACRO - CREATE AL2 JUMP INDEX CONSTANTS ***'
         MACRO
&LABEL   $AL2  &BASE,&LIST,&OFSET,&L
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $AL2       CREATE HALFWORD ADDRESS OFFSET TABLE.         *
.*       USED TO GENERATE LIST OF AL2 ADDRESS CONSTANTS WHICH         *
.*       CONTAIN THE RELATIVE ADDRESS OF EACH ITEM IN &LIST FROM &BASE*
.*       &OFSET GIVES A NUMBER TO BE ADDED OR SUBTRACTED WHEN SETTING *
.*       UP THE EQU FOR THE LABEL,SO THAT INDEXING MAY START ANYWHERE *
.*       &L IS CODED IF THE OFFSET LIST SHOULD BE PRECEDED BY LENGTH  *
.*       SET UP FOR BXLE .                                            *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         LCLA  &I                  LOCAL COUNTER
         DS    0H                  ALIGN
         AIF   (T'&LABEL EQ 'O').XCHKL       SKIP IF NO LABEL
&LABEL   EQU   *&OFSET
.XCHKL   AIF   (T'&L EQ 'O').XNOFS1          SKIP IF LENGTH OMITTED
&I       SETA  N'&LIST*2-2         SET UP FOR BXLE-# OF OPS
         DC    H'&I'
&I       SETA  0                   RESET COUNTER
.XNOFS1  ANOP
&I       SETA  &I+1
         DC    AL2(&LIST(&I)-&BASE)
         AIF   (&I LT N'&LIST).XNOFS1        KEEP LOOPING UNTIL DONE
         MEND
         TITLE '*** $SPIE - EXTENDED INTERRUPT COMMUNICATIONS ***'
         MACRO
&LABEL   $SPIE &EXIT,&TYPES,&CE=0,&ACTION=INIT
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $SPIE        INTERRUPT COMMUNICATIONS                    *
.*                                 SCOTT A. SMITH - FALL 1971.        *
.*       MAY BE USED BY OS OR DOS SYSTEMS TO SPECIFY THE ADDRESS      *
.*       OF AN INTERRUPTION EXIT ROUTINE AND TO SPECIFY THE PROGRAM   *
.*       INTERRUPT TYPES THAT ARE TO CAUSE THE EXIT ROUTINE TO BE     *
.*       GIVEN CONTROL.                                               *
.*       &EXIT     LABEL TO BE BRANCHED TO FOR THE INTERRUPTION       *
.*                 EXIT.  ADDRESS MAY BE IN A REGISTER.               *
.*       &TYPES    A LIST OF INTERRUPTION TYPES TO CATCH.  IF THIS    *
.*                 IS NOT SPECIFIED, A DEFAULT VALUE OF  ((1,15))     *
.*                 IS ASSUMED.  THE FORM OF THIS OPERAND IS A LIST    *
.*                 OF OPERANDS SEPARATED BY COMMAS.  THE LIST ITSELF  *
.*                 IS ENCLOSED IN PARENTHESES WITH EACH OPERAND       *
.*                 SPECIFYING A GROUP OF INTERRUPT TYPES TO CATCH.    *
.*                 EACH OF THESE IS EITHER A SINGLE INTEGER BETWEEN   *
.*                 1 AND 15, OR A PAIR OF INTEGERS BETWEEN 1 & 15     *
.*                 REPRESENTING AN INCLUSIVE RANGE OF INTERRUPTS.     *
.*                 EACH PAIR IS ENCLOSED IN PARENTHESES.              *
.*       &ACTION=  SPECIFIES THE ACTION THIS MACRO IS TO TAKE.        *
.*             -->INIT: IDENTIFIES THIS AS AN INITIAL $SPIE CALL      *
.*                 AND INITIALIZATION IS TO BE PERFORMED.             *
.*             -->CR: CREATE A NEW $SPIE COMMUNICATION, BUT DO        *
.*                 NOT REINITIALIZE.                                  *
.*             -->(RS,(REG)) RESTORE A PREVIOUS $SPIE COMMUNICATION   *
.*                 LINK USING THE XSPIEBLK AT THE ADDRESS IN THE      *
.*                 REGISTER.  ALL OTHER PARAMETERS ARE IGNORED        *
.*            ***DEFAULT***INIT                                       *
.*       &CE=      THIS SPECIFIES AN OPTIONAL CALLABLE EXIT WHICH     *
.*                 MAY RECEIVE TEMPORARY CONTROL IMMEDIATELY FOLLOW-  *
.*                 ING AN INTERRUPT.  THIS EXIT MUST RETURN.          *
.*       *REGISTERS 14,15,0,1 ARE DESTROYED BY THIS MACRO*            *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         LCLA  &I,&PTRVAL,&ENDVAL
         LCLB  &BIT(15),&J,&K
         LCLC  &STR,&PTR,&END,&NAME
         SPACE 1 .                 SEPARATE FROM MAIN LINE CODE
         AIF   ('&LABEL' EQ '').NOLAB  DO NOT GENERATE A LABEL IF NONE
&LABEL   DS    0H .                GENERATE USER LABEL
.NOLAB   AIF   ('&ACTION(1)' NE 'INIT').NOINT   NO INITIALIZATION
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*       PERFORM CALL TO XXXXSPIN FOR INITIALIZATION                  *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.INITIAL CNOP  0,4 .               ALIGNMENT FOR ADCON
         BAL   R14,*+8 .           SKIP AROUND ADCON FOR XXXXSPIN
         DC    V(XXXXSPIN) .       INITIALIZATION ADCON
         L     R15,0(R14) .        LOAD INITIALIZATION ROUTINE ADDRESS
         BALR  R14,R15 .           GO INITIALIZE, RETURN FOR XXXXSPIE
         AGO   .CREATE             SKIP ACTION CHECK, ALREADY KNOW
.NOINT   AIF   ('&ACTION(1)' EQ 'RS').RSTR    RESTORE OLD XSPIEBLK
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*       INITIALIZE A BIT STRING TO REPRESENT THE INTERRUPT TYPES     *
.*       TO CATCH FOR THIS PARTICULAR $SPIE                           *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.CREATE  AIF   ('&TYPES' NE '').LIST   IF OMMITED, GET ALL INTERRUPTS
&PTRVAL  SETA  1                   SET POINTER TO START AT SOC #1
&ENDVAL  SETA  15                  FLAG ALL INTERRUPTS UP TO SOC #15
         AGO   .NEXT               MAKE APPROPRIATE BIT MARKS
.LIST    ANOP
&I       SETA  1                   START SCAN OF TYPES FIELD AT LOC9 1
.TOP     AIF   ('&TYPES(&I)' EQ ' ').SKIP   TO SKIP EMBEDDED BLANKS
&STR     SETC  '&TYPES(&I)'        SAVE NEXT CHAR IN TYPES STRING
         AIF   ('&STR'(1,1) NE '(').SINGLE   FOR NON-PAIRS OF TYPES
&PTR     SETC  '&STR'(2,1)         ASSUME ONE DIGIT LONG
         AIF   ('&STR'(3,1) EQ ',').OKLOOK   IT WAS ONE DIGIT, GET #2OP
&PTR     SETC  '&STR'(2,2)         FIRST TYPE: 2 DIGITS LONG
&END     SETC  '&STR'(5,2)         SHOULD BE LEN=2; IF NOT, CAUGHT LATR
         AGO   .SETOK              HAVE CHAR STRINGS OF TWO TYPE LIMITS
.OKLOOK  ANOP                      FIND TYPE LIM #2 DIGIT LENGTH
&END     SETC  '&STR'(4,1)         ASSUME OF LENGTH 1, SINCE FIRST WAS
         AIF   ('&STR'(5,1) EQ ')').SETOK   IT IS OF LENGTH 1, SO IS OK
&END     SETC  '&STR'(4,2)         SECOND LIMIT IS A 2 DIGIT #
.SETOK   ANOP
&PTRVAL  SETA  &PTR                GET INTEGER VALUE FOR BIT MARKING
&ENDVAL  SETA  &END                INTEGER ENDING VALUE
         AIF   (&PTRVAL GT &ENDVAL OR &PTRVAL LT 1 OR &ENDVAL GT 15).ER
.NEXT    ANOP                      LOOP TO SET UP BIT MARKERS FOR TYPES
&BIT(&PTRVAL)  SETB  1             MARK THIS INTERRUPT TO BE CAUGHT
         AIF   (&PTRVAL EQ &ENDVAL).SKIP   ALL DONE, SEE IF MORE INTRPS
&PTRVAL  SETA  &PTRVAL+1           FLAG NEXT INTERRUPT TYPE TO CATCH
         AGO   .NEXT               MARK IT IN BIT FLAG FIELD
.SINGLE  AIF   (&TYPES(&I) LT 1 OR &TYPES(&I) GT 15).ER  OUT OF RANGE
&BIT(&STR)     SETB  1             CATCH THIS INTERRUPT TYPE (BIT MARK)
.SKIP    ANOP                      GET NEXT OPERAND FROM &CATCH
&I       SETA  &I+1                UP SCAN POINTER TO NEXT LOC.
         AIF   (&I LE N'&TYPES).TOP    GET NEXT MASK SPEC., IF IT EXIST
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*       WE HAVE THE BIT STRING INITIALIZED, NOW WE MUST BUILD UP     *
.*       THE NEW XSPIEBLK FOR NEW INTERRUPTS AND EXIT ADDRESSES.      *
.*       DETERMINE THE PRESENCE & NATURE OF INTERRUPT EXIT ROUTINE    *
.*       ADDRESS AND THE CALLABLE EXIT ADDRESS, AND PUT IN XSPIEBLK   *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         CNOP  2,4 .               ALIGNMENT FOR ADCONS
         LA    R1,*+18 .           ADDRESS FOR BRANCH AROUND XSPIEBLK
         BALR  R1,R1 .             BR AROUND BLK; R1 <= @ XSPIEBLK
         AIF   ('&EXIT' EQ '').NOEXIT  NO EXIT RTN @ SUPPLIED
         AIF   ('&EXIT'(1,1) EQ '(').INREG  EXIT RTN @ IS IN A REGISTER
         DC    AL4(&EXIT) .        # OF EXIT RTN
.CONT    AIF   ('&CE'(1,1) EQ '(').CEREG    @ IS IN A REGISTER
         DC    AL4(&CE) .          CALLABLE EXIT ROUTINE ADDRESS
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*       EXPAND BIT PATTERN FOR INTERRUPT TYPES TO CATCH.  EXPANDED   *
.*       TO A FULLWORD FOR EASIER MANIPULATION                        *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.INT     DC    B'0&BIT(1)&BIT(2)&BIT(3)&BIT(4)&BIT(5)&BIT(6)&BIT(7)&BITX
               (8)&BIT(9)&BIT(10)&BIT(11)&BIT(12)&BIT(13)&BIT(14)&BIT(1X
               5)',BL2'0' .    BIT PATTERN WITH PADDED ZEROS
         AIF   (NOT &J).KEF        SKIP IF &EXIT NOT IN REGISTER
         ST    &EXIT(1),0(0,R1) .  STORE REG VALUE FOR &EXIT @
.KEF     AIF   ('&CE'(1,1) NE '(').XSPYCAL .    SKIP IF &CE NOT IN REG.
         ST    &CE(1),4(0,R1) .    STORE CALLABLE EXIT @ IN XSPIEBLK
         AGO   .XSPYCAL            GO FOR A CALL TO XXXXSPIE TO CHNG PT
.INREG   ANOP                      &EXIT IS IN A REGISTER
&J       SETB  1                   FLAG THIS CONDITION SO WE STORE @
.NOEXIT  DC    AL4(0) .            SET ASIDE LOCATION FOR EXIT @
         AGO   .CONT               SEE ABOUT SECOND ADDRESS
.CEREG   DC    AL4(0) .            @ FOR RESERVING LOC. FOR CALLABLE EX
         AGO   .INT                GENERATE BIT PATTERN FOR INTERRUPTS
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*       HERE WE ARE INTERESTED IN RESTORING AN OLD XSPIEBLK.  GET    *
.*       XSPIEBLK ADDRESS IN R1.                                      *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.RSTR    ANOP
&PTR     SETC  '&ACTION(2)'        GET SECOND ARGUMENT: REG. IN PARENS
&END     SETC  '&PTR'(2,1)         ASSUME ONLY A ONE DIGIT NUMBER
&I       SETA  &END                CONVERT CHARACTER # TO ACTUAL #
         AIF   ('&PTR'(3,1) EQ ')').CHKR1  ASSUMPTION WAS RIGHT
&END     SETC  '&PTR'(2,2)         GET THE TWO DIGIT NUMBER
&I       SETA  &END                CONVERT CHARACTER # TO ACTUAL #
.CHKR1   AIF   (&I EQ 1).XSPYCAL   DON'T DO A :  LR 1,1
         LR    R1,&I .             GET @ OF OLD XSPIEBLK IN REG #1
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*       PREPARE CALL TO XXXXSPIE AND THEN CALL IT.  R1 SHOULD BE     *
.*       POINTING TO THE NEW (OR OLD, IN CASE OF ACTION=(RS)) SPYBLK  *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.XSPYCAL CNOP  0,4 .               ALIGNMENT FOR UPCOMING ADCON
         B     *+8 .               SKIP AROUND XXXXSPIE ADCON
         DC    V(XXXXSPIE) .       ENTRY POINT @ FOR ACTION EXECUTION
         L     R15,*-4 .           R15 <- @ OF XXXXSPIE FOR CALL
         BALR  R14,R15 .           CHANGE XSPIEBLK POINTERS--RETURN OL@
         AGO   .XXIT               RETURN
.ER      MNOTE 4,'**ERROR--INVALID SEQUENCE OF INTERRUPT TYPES--$SPIE CX
               ANCELLED'
.XXIT    SPACE 1
         MEND
         TITLE '*** XSRTR-XSAVE/XRETURN TRACE-ASSIST VERSION ***'
         MACRO
         XSRTR &TR,&LABEL,&MSG
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XSRTR      CREATE SPECIAL ASSIST ENTRY/EXIT TRACE CODE.  *
.*                                     JOHN R. MASHEY-JULY 1969-360/67*
.*       THIS MACRO IS USED BY XSAVE AND XRETURN TO GENERATE THE      *
.*       TRACE CODE CALLS TO XPRNT OR XSNAP, IF THE TR OPERAND IS USED*
.*       *NOTE* THIS IS MODIFIED VERSION FOR USE IN ASSIST ONLY.      *
.*       USES MACROS: XSNAP                                           *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLB  &XSNAPST            XSNAP STATUS;0==>ON,1==>OFF
         GBLB  &$DEBUG             DEBUG MODE FLAG,0==>YES,1==>NO
         GBLC  &DEBUG              DEBUG FLAG BITS FOR TESTING
         LCLB  &XSTSAV             FOR SAVING STATUS VARIABLES
         LCLC  &NAME               FOR EITHER LABEL OR CSECT
         LCLC  &T                  FOR TYPE
         AIF   (&$DEBUG).XXEXIT    SKIP WHOLE THING IF NO DEBUG
&NAME    SETC  '&LABEL'            ASSUME NAME IS LABEL
         AIF   (T'&LABEL NE 'O').XNOK1       SKIP IF LABEL EXISTS
&NAME    SETC  '&SYSECT'           USE CSECT NAME INSTEAD
         AIF   ('&SYSECT' NE '').XNOK1       SKIP IF CSECT NOT PC
&NAME    SETC  '$PRIVATE'          USE NAME FOR PRIVATE CODE (PC)
.XNOK1   ANOP
&XSTSAV  SETB  (&XSNAPST)          SAVE XSNAP STATUS, IN CASE OFF
&XSNAPST SETB  (0)                 MAKE SURE XSNAP WILL GENERATE
*        XSNAP LABEL='  MESSAGE '
&T       SETC  'PR'                FOR NORMAL PRINTING OF REGS
         AIF   ('&TR(1)' NE '*').XDFTB       SKIP AND PRINT REGS
&T       SETC  'NO'                DO NOT PRINT REGISTERS
.XDFTB   XSNAP LABEL='*** &NAME &MSG ***',T=&T,IF=(AVDEBUG,O,&DEBUG,TM)
&XSNAPST SETB  (&XSTSAV)           RESTORE STATUS,IN CASE IT WAS OFF
.XXEXIT  MEND
         TITLE '*** ALIGN LOCATION COUNTER MACROS - $ALIGN,$ALIGR ***'
         MACRO
&LABEL   $ALIGN &R,&A,&TAG
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $ALIGN     GET,ALIGN, RESTORE UPDATED LOCATION COUNTER.  *
.*       USED TO ALIGN LOCATION COUNTER TO H, F, OR D BOUNDARIES.     *
.*       &R WILL CONTAIN ALIGNED VALUE OF LOCATION COUNTER            *
.*       &A GIVES ALIGNMENT REQUIRED , IF IN PARENTHESES, GIVES REG,  *
.*       IF NOT, GIVES DECIMAL NUMBER 1-3-7 FOR H,F,D ALIGN           *
.*       &TAG  IF CODED-MEANS THAT LOCATION COUNTER IS ALREADY IN &R. *
.*       USES MACROS: $ALIGR,$GLOC,$SLOC                              *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         AIF   (T'&TAG EQ 'O').XNORM         NORMAL USE
         AIF   (T'&LABEL EQ 'O').XC          SKIP IF NOT NEEDED
&LABEL   DS    0H
         AGO   .XC                 SKIP TO DECIDE
.XNORM   ANOP
&LABEL   $GLOC &R .                GET THE LOCATION COUNTER
.XC      AIF   ('&A'(1,1) EQ '(').XREG       SKIP IF REGISTER FORM
         LA    &R,&A.(&R) .        INCREMENT THE LOCATION COUNTER
         O     &R,AWF&A .          MAKE LAST BITS ALL 1'S
         S     &R,AWF&A .          SUBTRACT,GETTING RIGHT ALIGNMENT
         AGO   .XST                GO STORE IT BACK
.XREG    $ALIGR &R,&A
.XST     $SLOC &R .                STORE LOCATION COUNTER BACK
         MEND
         SPACE 2
         MACRO
&LABEL   $ALIGR &R,&A
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $ALIGR     ALIGN VALUE IN REGISTER (USUALLY LOCCNTR).    *
.*        ALIGN REGISTER MACRO-ALIGN REGISTER &R TO BOUNDARY GIVEN    *
.*       BY VALUE IN REG &A, WHICH HAS 1,3,7 ETC IN IT.               *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
&LABEL   AR    &R,&A .             ADD LENGTH-1 TO LOCATION COUNTER
         OR    &R,&A .             MAKE LAST 1-3 BITS ALL 1'S
         SR    &R,&A .             ALIGN VALUE APPROPRIATELY
         MEND
         TITLE '*** MISC LOC-COUNTER MACROS-$CKALN,$GLOC,$SLOC ***'
         MACRO
&LABEL   $CKALN &MASK,&B
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $CKALN     CHECK LOC-COUNTER ALIGNMENT, BRANCH IF OK.    *
.*       USED TO CHECK ALIGNMENT - &MASK IS 1-3-7, &B IS BRANCH LOC   *
.*       IF LOCATION COUNTER IS PROPERLY ALIGNED.                     *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
&LABEL   TM    AVLOCNTR+3,&MASK .  CHECK FOR RIGHT ALIGNMENT
         BZ    &B .                TAKE BRANCH IF WAS ALIGNED
         MEND
         SPACE 2
         MACRO
&LABEL   $GLOC &RG
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $GLOC      GET LOCATION COUNTER INTO REGISTER.           *
.*       GET LOCATION COUNTER MACRO-PUTS LOCCNTR VALUE IN &RG         *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
&LABEL   L     &RG,AVLOCNTR        GET LOCATION COUNTER
         MEND
         SPACE 2
         MACRO
&LABEL   $SLOC &RG
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $SLOC      SET LOCATION COUNTER TO REGISTER VALUE.       *
.*       SET LOCATION COUNTER MACRO - SETS &RG AS LOCCNTR VALUE       *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
&LABEL   ST    &RG,AVLOCNTR        SET LOCATION COUNTER
         MEND
         TITLE '*** SCAN POINTER MACROS - $SCOF, $SCPT ***'
         MACRO
&LABEL   $SCOF &RG,&SCP,&BYTE,&AD=AVRSBPT
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $SCOF      CONVERT REGISTER SCAN POINTER TO OFFSET VALUE.*
.*       SCAN POINTER OFFSET MACRO - PLACE SCAN POINTER REGISTER &SCP *
.*       INTO WORK REGISTER &RG. FIND OFFSET, AND STORE IT INTO &BYTE *
.*       IF &BYTE SPECIFIED.  &AD= WORD GIVING BEGINNING @ FOR OFFSET.*
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
&LABEL   LR    &RG,&SCP .          MOVE SCAN POINTER ADDRESS OVER
         S     &RG,&AD .           SUBTRACT STARTING ADDR
         AIF   (T'&BYTE EQ 'O').XEXIT        SKIP IF NO STORE WANTED
         STC   &RG,&BYTE .         SAVE OFFSET INTO BYTE
.XEXIT   MEND
         SPACE 2
         MACRO
&LABEL   $SCPT &RG,&BYTE,&AD=AVRSBPT
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $SCPT      CONVERT OFFSET TO A SCAN POINTER @ INTO REG.  *
.*       GET SCAN POINTER ADDRESS FROM OFFSET-OFFSET IS IN &BYTE,ADDR *
.*       IS CREATED IN &RG.  &AD GIVES BEGINNING @ OF FIELD.          *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
&LABEL   SR    &RG,&RG .           CLEAR FOR INSERTION
         IC    &RG,&BYTE .         GET THE OFFSET VALUE
         A     &RG,&AD .           ADD START ADDR TO GET REAL ADDR
         MEND
         TITLE '*** STORAGE ALLOCATION MACROS - $ALLOCH,$ALLOCL ***'
         MACRO
&LABEL   $ALLOCH &R,&L,&OVRFL
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $ALLOCH    GET CORE IN FREEAREA HIGH END (ASSEMLBER).    *
.*       &R  GIVES REGISTER WHERE ADDRESS OF NEW USABLE AREA APPEARS  *
.*       &L  GIVES REGISTER CONTAINING THE LENGTH DESIRED             *
.*       &OVRFL IS ADDRESS TO BE BRANCHED TO IF OVERFLOW OCCURS.      *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
&LABEL   L     &R,AVADDHIH .       GET CURRENT HIGH END POINTER
         SR    &R,&L .             GET NEW HIGH END POINTER
         C     &R,AVADDLOW .       MAKE SURE NO OVERFLOW
         BL    &OVRFL .            TAKE BRANCH IF OVERFLOW
         ST    &R,AVADDHIH .       RESTORE UPDATED POINTER
         MEND
         SPACE 2
         MACRO
&LABEL   $ALLOCL &R,&L,&OVRFL
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $ALLOCL    GET CORE IN LOW FREEAREA (IN ASSEMBLER).      *
.*       &R  GIVES REGISTER WHERE ADDRESS OF NEW USABLE AREA APPEARS  *
.*       &L  GIVES REGISTER CONTAINING THE LENGTH DESIRED.            *
.*       &OVRFL  IS ADDRESS TO BE BRANCHED TO IF OVERFLOW OCCURS.     *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
&LABEL   L     &R,AVADDLOW .       LOAD CURRENT LOW END POINTER
         AR    &R,&L .             ADD REQUESTED LENGTH TO POINTER
         C     &R,AVADDHIH .       MAKE SURE NO OVERFLOW
         BH    &OVRFL .            TAKE BRANCH IF OVERFLOW
         ST    &R,AVADDLOW .       REPLACE UPDATED POINTER
         SR    &R,&L .             RESTORE POINTER
         MEND
         TITLE '*** STORAGE ALLOCATION MACROS - $MALLOCL,$MALLOCH ***'
         MACRO
&LABEL   $MALLOCL  &R,&L,&OVRFL=MXPNDOVR,&LENG=                       S
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*-->  MACRO:  &MALLOCL    GET CORE IN LOW FREEAREA.  SAME AS &ALLOCL *
.*        EXCEPT USES AVGEN2CD AS POINTER TO FREE HIGH AREA.  USED IN *
.*        MEXPND                                                      *
.*                                                                    *
.*     &R  GIVES REGISTER WHERE ADDRESS OF NEW USEABLE AREA APPEARS   *
.*     &L  GIVES REGISTER CONTAINING LENGTH DESIRED                   *
.*     &OVRFL IS @ TO BE BRANCHED TO IF OVERFLOW                      *
.*     &LENG IS THE LENGTH TO BE ALLOCATED                            *
.*                                                                    *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
&LABEL   DS    0H                  DEFINE LABEL                       S
         AIF   ('&LENG' EQ '').X                                      S
         LA    &L,&LENG            LOAD LENGTH TO ALLOCATE            S
.X       L     &R,AVADDLOW         LOAD CURRENT LOW END PTR           S
         AR    &R,&L               ADD REQUESTED LENGTH
         C     &R,AVGEN2CD         MAKE SURE NO OVERFLOW
         BH    &OVRFL              BRANCH IF OVERFLOW
         ST    &R,AVADDLOW         REPLACE UPDATED POINTER
         SR    &R,&L               RESTORE POINTER
         MEND
         SPACE 2
         MACRO
&LABEL   $MALLOCH  &R,&L,&OVRFL=MXPNDOVR
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*-->  MACRO:  &MALLOCH   GET CORE IN HIGH FREEAREA.  SAME AS &ALLOCH *
.*        EXCEPT USES AVGEN2CD AS HIGH END POINTER.  USED IN MEXPND   *
.*     &R  IS REG NEW USEABLE @ APPEARS IN                            *
.*     &L  GIVES REGISTER DESIRED LENGTH IS IN                        *
.*     &OVRFL  IS BRANCH @ IF OVERFLOW OCCURS                         *
.*                                                                    *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
&LABEL   L     &R,AVGEN2CD         LOAD CURRENT HIGH END POINTER
         SR    &R,&L               GET NEW HIGH END POINTER
         C     &R,AVADDLOW         MAKE SURE NO OVERFLOW
         BL    &OVRFL              BRANCH IF OVERFLOW
         ST    &R,AVGEN2CD         RESTORE UPDATED POINTER
         MEND
         TITLE '*** STORAGE DEALLOCATION MACRO - $DALLOCH ***'
         MACRO
&LABEL   $DALLOCH &R,&L
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $DALLOCH   RETURN CORE-HIGH FREEAREA (IN ASSEMBLER)      *
.*       &R IS A WORK REGISTER, WHICH WILL BE DESTROYED               *
.*       &L REPRESENTS THE LENGTH. IF 1ST CHAR IS '(', WILL BE        *
.*       TAKEN AS REGISTER CONTAINING THE LENGTH, OTHER WISE TO       *
.*       BE AN ACTUAL LENGTH TO BE ADDED.                             *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
&LABEL   L     &R,AVADDHIH .       GET CURRENT HIGH END POINTER
         AIF   ('&L'(1,1) NE '(').XLENG      IF NOT REG FORM,SKIP
         AR    &R,&L .             ADD THE LENGTH BACK
         AGO   .XST                GO RESTORE
.XLENG   LA    &R,&L.(&R) .        INCREMENT REGISTER
.XST     ST    &R,AVADDHIH .       RESTORE UPDATED POINTER
         MEND
         TITLE '*** ASSEMBLER SYMBOL DEFINIITON MACRO - $SDEF ***'
         MACRO
&LABEL   $SDEF &RVAL,&RESD,&RLENG
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $SDEF      STORE VALUES IN SYMBOL TABLE ENTRY, FLAG DEFN.*
.*       &RVAL     REGISTER CONTAINING SYMBOL VALUE.                  *
.*       &RESD     REGISTER CONTAINING SECTION ID OF SYMBOL.          *
.*       &RLENG    REGISTER CONTAINING LENGTH ATTRIBUTE-1 FOR SYMBOL. *
.*       *NOTE* SYMSECT DSECT MUST HAVE VALID USING AT TIME OF CALL.  *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
&LABEL   ST    &RVAL,SYVALUE .     DEFINE VALUE
         STC   &RESD,SYESDID .     NOTE ESDID OF SYMBOL
         STC   &RLENG,SYLENG .     NOTE LENGTH ATTRIBUTE
         OI    SYFLAGS,$SYDEF .    NOTE SYMBOL NOW DEFINED
         MEND
         TITLE '*** $SERR - SET ERROR CODE EQUS AND MESSAGES'
         MACRO
&ERR     $SERR &MSG,&NM
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $SERR      SET ERROR CODE MESSAGES AND EQU SYMBOLS.      *
.*       CALLED 2 TIMES FOR EACH ERROR EQU, 1 TIME TO SET UP EQU, 1   *
.*       TIME TO CREATE ERROR MESSAGE DC'S IN CSECT OUTPUT OF ASMBLER.*
.*       &ERR      IS LAST 5 CHARACTERS OF ERROR MESSAGE EQU SYMBOL.  *
.*       &MSG      IS THE ERROR MESSAGE ASSOCIATED WITH THE EQU.      *
.*       &NM       IS THE ERROR CODE FOR EXTERNAL USE - AS###.        *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLA  &$ERNUM,&$ERFA      # ERRORS, ADDRESS OFFSET VALUE
         GBLA  &$OPTMS             MEMORY OPTIMIZATION
         LCLA  &I                  LOCAL COUNTER
         AIF   ('&SYSECT' EQ 'OUTPUT').SGEN GO TO GEN IF IN OUTPUT
.*             GENERATE THE EQU                                       *
&$ERNUM  SETA  &$ERNUM+2           INCREMENT # ERRORS, EQU VALUE
$ER&ERR  EQU   &$ERNUM
         MEXIT
.SGEN    AIF   (&$OPTMS GT 2).SGEN1    SKIP UNLESS VERY SMALL SYSTEM
.*             SMALL MEMORY - GEN JUST ERROR #, DON'T USE POINTERS
.*             OR LENGTHS, SINCE LENGTHS WILL BE CONSTANT = 3.
         DC    C'&NM'
         AGO   .XXEXIT
.*             GENERATE POINTER TO LENGTH-1 AND ERROR MESSAGE         *
.SGEN1   ORG   OUERRPT+$ER&ERR
         DC    H'&$ERFA'
         ORG
&I       SETA  K'&MSG+K'&NM-2      LENGTH-1 OF ERROR MESSAGE
.SENORM  DC    AL1(&I),C'&NM ',C&MSG
&$ERFA   SETA  &$ERFA+&I+2         INCREMENT THE OFFSET POINTER
.XXEXIT  MEND
         TITLE '*** $SETRT MACRO - BUILD TRT TABLE FOR SCANNING ***'
         MACRO
&LABEL   $SETRT &LIST
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $SETRT     SET UP TRT TABLE FOR SCANNING IN ASSEMBLER.   *
.*       USED INSIDE ASSIST ASSEMBLER TO CREATE TEMPORARY TRT TABLE IN*
.*       COMMON AREA AWTZTAB (WHICH CONTAINS 256 HEX 0'S).            *
.*       &LIST IS LIST OF CHARACTER/VALUE PAIRS, WITH CHARACTERS      *
.*       ENCLOSED IN QUOTES.  CORRESPONDONG VALUES ARE MOVED INTO     *
.*       CORRESPONDING LOCATIONS IN 256-BYTE TABLE OF ZEROS.          *
.*       IF VALUE IS OMITTED, ZERO IS ASSUMED.                        *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         LCLA  &I
         LCLC  &CH1,&CH2
&I       SETA  1
         AIF   (T'&LABEL EQ 'O').XNOLB
&LABEL   DS    0H
.XNOLB   ANOP
&CH1     SETC  '&LIST(&I)'         GET NEXT LIST VALUE
&CH2     SETC  '&CH1'(1,2)         GET UP TO 2 CHARS
         AIF   ('&CH2' EQ 'X''' OR '&CH2' EQ 'C''').XGEN
         AIF   ('&CH2'(1,1) EQ '''').XC
&CH1     SETC  'C''&CH1'''         ADD C' ' TO ELEMENT
         AGO   .XGEN
.XC      ANOP
&CH1     SETC  'C&CH1'             ADD C TO ELEMENT
.XGEN    ANOP
&CH2     SETC  '&LIST(&I+1)'       GET VALUE OP
         AIF   ('&CH2' NE '').XGEN1
&CH2     SETC  '0'                 SET TO ZERO
.XGEN1   MVI   AWTZTAB+&CH1,&CH2
&I       SETA  &I+2                INCREMENT
         AIF   (&I LT N'&LIST).XNOLB         CONTINUE LOOPING
         MEND
         TITLE '*** MISC. UTILITY MACROS - $GTAD,$LV,$STV ***'
         MACRO
&LABEL   $GTAD &RG,&ENTRY
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $GTAD      LOAD ADCON INTO REGISTER FORM AVWXTABL.       *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
&LABEL   L     &RG,AX&ENTRY
         MEND
         SPACE 2
         MACRO
&LABEL   $LV   &RG,&AD,&L=3
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $LV        LOAD VARIABLE LENGTH VALUE INTO REGISTER(ASMB)*
.*       LOAD VARIABLE - PLACES &L BYTES IN &RG FROM &AD              *
.*       HIGH ORDER BYTES ARE ZEROED, USES AVFWORK1                   *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         AIF   (&L NE 3).XNO3      SKIP IF NOT 3
&LABEL   MVI   AVFWORK1,0
         AGO   .XMVC2              SKIP TO MOVE OVER
.XNO3    ANOP
&LABEL   SR    &RG,&RG .           CLEAR REG FOR ZEROS
         ST    &RG,AVFWORK1 .      ZERO WORK WORD OUT
.XMVC2   MVC   AVFWORK1-&L+4(&L),&AD .       MOVE BYTES OVER
         L     &RG,AVFWORK1 .      LOAD THE REGISTER
         MEND
         SPACE 2
         MACRO
&LABEL   $STV  &RG,&AD,&L=3
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $STV       STORE VARIABLE LENGTH VALUE FROM REGISTER (AS)*
.*       STORE VARIABLE MACRO-STORES &L BYTES FROM LOW ORDER END OF   *
.*       REGISTER &RG INTO ADDRESS &AD.                               *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
&LABEL   ST    &RG,AVFWORK1 .      STORE REG INTO WORK WORD
         MVC   &AD.(&L),AVFWORK1+4-&L
         MEND
         TITLE '*** CONG MACRO - GEN CONSTATNT CODE TABLES(CODTL1)***'
         MACRO
         CONG  &C,&TYP,&LEN,&LD='''',&RD='''',&LW=1,&HI=8,&E=$CNERR
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: CONG       GENERATE CONSTANT CODE TABLE (CSECT CODTL1).  *
.*       USED IN CODTL1 OF ASSEMBLER TO PRODUCE 1 ENTRY IN            *
.*       CONSTANT DESCRIPTION BLOCK.  SEE CONBLK DSECT IN CODTL1.     *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         ORG   CODINXO+C'&C'       ORG INTO RIGHT SPOT IN TABLE
         DC    AL1(CODT&C-CONTAB1) DEFINE OFFSET VALUE
         ORG
CODT&C   DC    AL1(&TYP+$CN&C+&E,&LEN-1,C&LD,C&RD,&LW-1,&HI-1)
         MEND
         TITLE '*** MACROS USED BY THE EXTENDED INTERPRETER ONLY'
         MACRO
&LABEL   EITAB &INS,&SYS,&IL,&CL,&TYPE,&OPC,&MODCHK,&OP1,&OP2,&D2B,    X
               &D2H,&ALN,&R1,&R2,&ROUTINE
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: EITAB       INTERPRETER CONTROL TABLE MACRO              *
.*                                                                    *
.*       THIS MACRO IS USED BY THE EXTENDED INTERPRETER TO CONSTRUCT  *
.*       A SINGLE CONTROL TABLE ENTRY.  EACH TABLE ENTRY DEFINES THE  *
.*       DECODING NECESSARY FOR ITS CORRESPONDING INSTRUCTION(S).     *
.*                                                                    *
.*       IT SHOULD BE NOTED THAT:                                     *
.*         (1)     IT IS SUGGESTED THAT ASTERISKS BE PLACED IN        *
.*                 ARGUMENT FIELDS NOT APPLICABLE TO A PARTICULAR     *
.*                 INSTRUCTION DECODING FORMAT.  IF THIS IS DONE,     *
.*                 THE ARGUMENT FIELDS WILL FORM ALIGNED COLUMNS      *
.*                 IN THE SOURCE LISTING, MAKING READING AND DE-      *
.*                 BUGGING EASIER.                                    *
.*         (2)     ONLY TWO ARGUMENTS ARE REQUIRED FOR EXTENDED       *
.*                 OPCODE INSTRUCTIONS IN THE MAIN TABLE.  THESE      *
.*                 ARE &OPC AND &ROUTINE.  THE LATTER SHOULD BE       *
.*                 THE LABEL OF THE APPROPRIATE EXTENDED OPCODE       *
.*                 SECONDARY TABLE (NOT THE USUAL ROUTINE LABEL).     *
.*                 IT IS SUGGESTED THAT ALL OTHER FIELDS CONTAIN      *
.*                 ASTERISKS.                                         *
.*                                                                    *
.*       ***** ARGUMENTS *****                                        *
.*                                                                    *
.*       &INS      = THE MNEMONIC INSTRUCTION CODE (LA,BCT,SR,ETC.)   *
.*       &SYS      = 360 IF THE INSTR IS GOOD ON 360'S & 370'S        *
.*                 = 370 IF THE INSTR IS GOOD ONLY ON 370'S           *
.*       &IL       = INSTRUCTION LENGTH IN BYTES (2, 4 OR 6)          *
.*       &CL       = AN INTEGER (1 <= &CL <= 8) SPECIFYING THE LENGTH *
.*                   OF STORAGE MODIFIED OR FETCHED BY THIS INSTR     *
.*                 = 0   IF THE LENGTH IS CONTAINED IN THE INST ITSELF*
.*                   (SS INSTRUCTIONS)                                *
.*                 = *   IF NOT APPLICABLE                            *
.*       &TYPE     = NO  IF THIS IS NOT A PRIVILEGED INSTR            *
.*                 = PR  IF THIS IS A PRIVILEGED INSTRUCTION          *
.*       &OPC      = NM  IF THIS INSTR'S OPCODE IS NORMAL (8 BITS)    *
.*                 = EX  IF THIS INSTR'S OPCODE IS EXTENDED (> 8 BITS)*
.*       &MODCHK   = CK  IF THE STORAGE ACCESS @ AND LENGTH ARE TO BE *
.*                   RANGE CHECKED IN THE MAIN DECODING LOOP (NEAR    *
.*                   STMT LABEL -> EINOCHK)                           *
.*                 = NO  IF CHECKING SHOULD NOT BE DONE IN THE MAIN   *
.*                   DECODING LOOP                                    *
.*                 = **  IF NOT APPLICABLE                            *
.*       &OP1      = F   IF OPRND #1 SHOULD BE FETCH CHECKED          *
.*                 = S   IF OPRND #1 SHOULD BE STORE CHECKED          *
.*                 = N   IF NO CHECKING IS REQUIRED FOR OPRND #1      *
.*                 = *   IF NOT APPLICABLE                            *
.*       &OP2      = SAME AS &OP1, BUT FOR OPRND #2                   *
.*       &D2B      = RR4 IF 2ND BYTE TO BE DECODED AS 2 REGS (X 4)    *
.*                 = LL1 IF 2ND BYTE TO BE DECODED AS 2 FIELDS (X 1)  *
.*                 = IOL IF 2ND BYTE TO BE DECODED AS 1 FIELD (X 1)   *
.*       &D2H      = BD  IF 2ND HALFWORD @ IS ONLY BASE+DISPL         *
.*                 = IX  IF 2ND HALFWORD @ IS BASE+DISPL+INDEX        *
.*                 = **  IF NOT APPLICABLE                            *
.*       &ALN      = DBL IF OPRND ALIGNMENT MUST BE DOUBLEWORD        *
.*                 = FUL IF OPRND ALIGNMENT MUST BE AT LEAST FULLWORD *
.*                 = HAF IF OPRND ALIGNMENT MUST BE AT LEAST HALFWORD *
.*                 = NON IF NO ALIGNMENT NEEDED                       *
.*                 = *** IF NOT APPLICABLE                            *
.*       &R1       = E   IF THE R1 FIELD MUST SPECIFY AN EVEN REG     *
.*                 = O   IF THE R1 FIELD CAN SPECIFY AN ODD REG       *
.*                 = *   IF NOT APPLICABLE  (IF &D2B ^= RR4)          *
.*       &R2       = SAME AS &R1, BUT FOR R2 FIELD                    *
.*       &ROUTINE  = A STMT LABEL SPECIFYING A ROUTINE TO WHICH       *
.*                   CONTROL IS PASSED FOLLOWING PRIMARY DECODING     *
.*                   (E.G. - EIBAL, EILA, EINORMRR, ETC.)             *
.*                 = A STMT LABEL OF THE SECONDARY CONTROL TABLE      *
.*                   APPROPRIATE FOR AN EXTENDED OPCODE INSTRUCTION   *
.*                   (SEE NOTES ABOVE ARGUMENT LISTING)               *
.*                                                                    *
.** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         LCLC  &BYTE               BYTES ARE BUILT WITH THIS VAR
         SPACE 1
EIT&INS  EQU   *                   LABEL FOR EIXTAB MACRO
.*
.*             CHECK IF THIS ENTRY IS FOR AN EXTENDED OPCODE INSTR --
.*             BRANCH IF IT IS
.*
         AIF   ('&OPC' EQ 'EX').OPEXTD
.*
.*             ASSEMBLE AND GENERATE THE 1ST AND 2ND BYTES OF THIS
.*             TABLE ENTRY  --  INCLUDING LABEL IF ANY
.*
&BYTE    SETC  '00001000'          INITIAL BYTE SET-UP
         AIF   (&SYS EQ 370).OPB1A SKIP IF 370-ONLY INSTR
&BYTE    SETC  '00001100'          ADD BIT IF 360/370 INSTR
.OPB1A   AIF   ('&TYPE' NE 'PR').OPB1B  SKIP IF NOT A PRIV INSTR
&BYTE    SETC  '01'.'&BYTE'(3,6)   ADD BIT IF PRIV INSTR
.OPB1B   AIF   (&IL NE 2).OPB1C    SKIP IF NOT AN RR INSTR
&BYTE    SETC  '&BYTE'(1,2).'1'.'&BYTE'(4,5)  ADD BIT IF RR INSTR
         AGO   .OPB1D              NO CHECKING IF RR INSTR
.OPB1C   AIF   (('&MODCHK' EQ '') OR ('&MODCHK' EQ '**') OR ('&MODCHK' X
               EQ 'NO')).OPB1D     SKIP IF NO CHECKING TO BE DONE
&BYTE    SETC  '&BYTE'(1,3).'1'.'&BYTE'(5,4)  ADD BIT IF CHECKING
.OPB1D   ANOP
&LABEL   DC    B'&BYTE',HL1'&IL'                                      L
.*
.*             1ST & 2ND BYTES GENERATED  --  NOW ASSEMBLE AND
.*             GENERATE BYTE # 3
.*
&BYTE    SETC  '00000000'          INITIAL BYTE SET-UP
.*             SET OPERAND #1 CHECKING BITS
         AIF   (('&OP1' EQ 'N') OR ('&OP1' EQ '*')).OPB3A  SKIP IF NOCK
&BYTE    SETC  '01000000'          AT LEAST THIS BIT IS ON
         AIF   ('&OP1' EQ 'F').OPB3A  SKIP IF FETCH CHECKING
&BYTE    SETC  '11000000'          SET STORE CHECK BITS ON
.*             SET OPERAND #2 CHECKING BITS
.OPB3A   AIF   (('&OP2' EQ 'N') OR ('&OP2' EQ '*')).OPB3B
&BYTE    SETC  '&BYTE'(1,2).'010000'  AT LEAST FETCH BIT IS ON
         AIF   ('&OP2' EQ 'F').OPB3B  SKIP IF FETCH CHECKING
&BYTE    SETC  '&BYTE'(1,2).'110000'  SET STORE CHECK BITS ON
.*             SET BIT IF THIS IS A NON-RR BRANCH INSTR
.OPB3B   AIF   ((&IL EQ 2) AND ('&INS' NE 'XOPC')).OPB3E  SKIP IF RR
         AIF   (('&INS' NE 'BAL') AND ('&INS' NE 'BC') AND ('&INS' NE 'X
               BCT') AND ('&INS' NE 'BXH') AND ('&INS' NE 'BXLE')).OPB3X
               C                   SKIP IF NOT A NON-RR BRANCH
&BYTE    SETC  '&BYTE'(1,4).'1000' SET NON-RR BRANCH INSTR BIT ON
.*             SET BIT FOR 2ND HALFWORD DECODING
.OPB3C   AIF   (('&D2H' EQ '**') OR ('&D2H' EQ 'IX')).OPB3D  NOT = B+D
&BYTE    SETC  '&BYTE'(1,5).'100'  SET BASE+DISP BIT ON
.OPB3D   ANOP
.*             SET BITS FOR 2ND BYTE DECODING (NOT HERE IF AN RR INSTR)
         AIF   ('&D2B' EQ 'RR4').OPB3E     SKIP IF RR4                L
&BYTE    SETC  '&BYTE'(1,6).'01'   ASSUME LLX1
         AIF   ('&D2B' EQ 'LL1').OPB3E  SKIP IF LLX1
&BYTE    SETC  '&BYTE'(1,6).'11'   SET BITS FOR IOL
.OPB3E   ANOP
         DC    B'&BYTE.'
.*
.*             1ST 3 BYTES GENERATED  --  NOW DO BYTE 4
.*
&BYTE    SETC  '00000000'          INITIAL BYTE SET-UP
         AIF   (('&ALN' EQ '') OR ('&ALN' EQ 'NON') OR ('&ALN' EQ '***'X
               )).OPB4A
&BYTE    SETC  '00000001'          SET HALFWORD ALIGN
         AIF   ('&ALN' EQ 'HAF').OPB4A JUMP IF NOW OK
&BYTE    SETC  '00000011'          SET FULL WORD ALIGN
         AIF   ('&ALN' EQ 'FUL').OPB4A JUMP IF NOW OK
&BYTE    SETC  '00000111'          SET DOUBLEWORD ALIGN
.OPB4A   ANOP
         DC    B'&BYTE.'
.*
.*             1ST 4 BYTES GENERATED  --  NOW DO BYTE 5
.*
&BYTE    SETC  '00000000'          INITIAL BYTE SET-UP
         AIF   ('&D2B' NE 'RR4').OPB5B  SKIP IF NO REGS TO CHK
         AIF   ('&R1' NE 'E').OPB5A  SKIP IF R1 CAN BE ODD
&BYTE    SETC  '00010000'          SET BIT FOR R1 EVEN
.OPB5A   AIF   ('&R2' NE 'E').OPB5B  SKIP IF R2 CAN BE ODD
&BYTE    SETC  '&BYTE'(1,4).'0001' SET BIT FOR R2 EVEN
.OPB5B   ANOP
         DC    B'&BYTE.'
.*
.*             1ST 5 BYTES GENERATED  --  NOW DO BYTE 6
.*             AND THE HALFWORD DISPL TO THE ROUTINE
.*
&BYTE    SETC  '0'                 INITIAL BYTE SET-UP
         AIF   (('&CL' EQ '*') OR ('&CL' EQ '') OR ('&CL' EQ '0')).OPB6X
               A
&BYTE    SETC  '&CL'
.OPB6A   ANOP
         DC    HL1'&BYTE.',AL2(&ROUTINE.-EISPEJMP)
         SPACE 1
         MEXIT
.*
.*             EXTENDED OPCODE IF HERE -- GENERATE TABLE ENTRY
.*
.OPEXTD  ANOP
&LABEL   DC    B'10000000',XL3'0',A(&ROUTINE)                         L
         SPACE 1
         MEND
         EJECT
         MACRO
&LABEL   EIXTAB  &L1,&L2,&L3,&L4,&L5,&L6,&L7,&L8
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO:  EIXTAB       INTERPRETER SECONDARY CONTROL TABLE MACRO  *
.*                                                                    *
.*             THIS MACRO IS USED BY THE EXTENDED INTERPRETER TO      *
.*             GENERATE THE 256 BYTE SECONDARY TABLE.  THIS TABLE IS  *
.*             INDEXED INTO BY THE OPCODE OF THE INSTRUCTION BEING    *
.*             EXECUTED.  EACH TABLE ENTRY CONTAINS A DISPLACEMENT    *
.*             INTO THE MAIN DECODING TABLE.  INVALID OPCODES ALSO    *
.*             ARE GIVEN DISPLACEMENTS INTO THE TABLE.  THESE         *
.*             POINT TO ZERO ENTRIES IN THE MAIN TABLE NOTING THE     *
.*             THE OPCODES AS BEING INVALID.  THE NUMBER OF           *
.*             PARAMETERS USED FOR A CALL TO THIS MACRO IS 8.  IF     *
.*             8 ARE NOT USED AN MNOTE IS GIVEN AND THE GENERATION    *
.*             FOR THAT MACRO CALL IS TERMINATED.  THE PARAMETERS     *
.*             SHOULD EACH BE THE MNEMONIC OF THE INSTRUCTION OR      *
.*             THE NAME OF THE GROUP OF INSTRUCTIONS REPRESENTED.     *
.*             THESE NAMES MUST CORRESPOND TO NAMES IN THE MAIN       *
.*             TABLE.  NUMERIC PARAMETERS SHOULD BE USED FOR ALL      *
.*             ILLEGAL OPCODES.  THESE SHOULD BE A 2, 4 OR 6          *
.*             DEPENDING ON THE LENGTH OF THE ZERO MAIN TABLE ENTRY   *
.*             BEING INDEXED.                                         *
.*                                                                    *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         LCLA  &L
&LABEL   DC    0C' '
         AIF   (N'&SYSLIST EQ 8).EILOOP
         MNOTE 30,'***** EIGHT INSTRUCTIONS NOT SPECIFIED - ERROR ****'
         MEXIT
.EILOOP  ANOP
&L       SETA  &L+1
         AIF   (T'&SYSLIST(&L) NE 'N').EINONUM
         AIF   ((&SYSLIST(&L) EQ 2) OR (&SYSLIST(&L) EQ 4) OR (&SYSLISTX
               (&L) EQ 6)).EINONUM
         MNOTE 30,'*** NUMERIC VALUE SPECIFIED NOT EQUAL 2, 4, 6 ***'
         MEXIT
.EINONUM ANOP
         DC    AL1((EIT&SYSLIST(&L).-EICONTAB)/8)
         AIF   (&L LT 8).EILOOP
         MEND
         TITLE '*** EVCG TABLE - GENERATE ROW OF EVALUT TRANSITION TAB'
         MACRO
         CROSSET  &NUM
         GBLB  &$XREF              CONTROLS GENERATION OF MACRO
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: CROSSET               MACRO TO SET FLAGS FOR XREF        *
.*  THIS MACRO IS USED IN THE ICMOP2 CSECT AND IS CALLED EVERY TIME   *
.*  A NEW OPERAND IS SCANNED.  IT SETS THE INSTRUCTION TYPE           *
.*  AND THE FLAG AVXRTYPE.                                            *
.*    &NUM ==>  # OF OPERAND BEING SCANNED.  CONTROLS TESTING         *
.*              OF CORRECT FLAG.                                      *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         AIF   (NOT &$XREF).NOXREF SKIP IF NOT CROSS REFERENCE
         OI    AVXRTYPE,AVXRFTCH .  SET BIT ON
         TM    AVXRMDFT,AVXRMOD&NUM  .  SEE IF MODIFY REFERENCE
         BZ    *+8                 NO SKIP RESETING
         NI    AVXRTYPE,X'FF'-AVXRFTCH  .  TURN OFF FLAG
.NOXREF  MEND
         SPACE 5
         MACRO
&LABEL   EVCG  &L
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: EVCG       CREATE ROW OF TRANSITION TABLE (CSECT EVALUT) *
.*       &L        LIST OF PAIRS- JUMP LABEL,(ERROR CODE OR STATE #). *
.*       CREATES 1 ROW OF TABLE EVCTAB IN GENERAL EXPRESSION EVALUATOR*
.*       CSECT EVALUT.  SEE EVCTDSCT DSECT FOR ENTRIES IN EACH ROW.   *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         LCLA  &I                  LOCAL COUNTER
&I       SETA  1                   INIT
&LABEL   DS    0H
.EVCA    AIF   (T'&L(&I+1) EQ 'N').EVCC     JUMP IF IT IS STATE #
         DC    AL1(EV&L(&I)-EVDJUMP,$ERV&L(&I+1)) .   OFFSET,ERROR
         AGO   .EVCE
.EVCC    DC    AL1(EV&L(&I)-EVDJUMP,EVCT&L(&I+1)-EVCTAB)
.EVCE    ANOP
&I       SETA  &I+2                INCREMENT BY 2 FOR NEXT PAIR
         AIF   (&I LT N'&L).EVCA   GO BACK IF THERE'S MORE
         MEND
         TITLE '*** TABLE GENERATION MACROS -IBPRTAB, ICT ***'
         MACRO
&LABEL   IBPRTAB &OP,&VO,&VX
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: IBPRTAB    GENERATE 1 BLOCK FOR PRINT SCAN LIST          *
.*.      USED ONLY IN IBASM1. CREATES 1 BLOCK: DSECT IBPSCECT         *
.*.      &OP       OPERAND NAME (ON, OFF, ETC).                       *
.*.      &VO       VALUE TO BE OR'D INTO PRINT BYTE: BIT TO SET ON/OFF*
.*.      &VX       VALUE TO BE XOR'D INTO PRINT CONTROL: EITHER 0     *
.*.                IF BIT ON (&VX OMITTED), OR SAME AS &VO IF * CODED.*
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         LCLA  &K                  FOR COUNT
         LCLC  &C                  FOR &VX VALUE
&K       SETA  K'&OP-1             GET #-1 OF CHARS IN OPERAND
&C       SETC  '0'                 ASSUME &VX OMITTED
         AIF   ('&VX' EQ '').IB1   SKIP IF WAS OMITTED
&C       SETC  '&VO'               DUPLICATE VALUE OF EQUATE
.IB1     ANOP
&LABEL   DC    AL1(&K,&VO,&C),C'&OP'
         MEND
         SPACE 4
         MACRO
&LABEL   ICT   &TYPE,&VALUE
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: ICT        CREATE CONTROL CODES(ICYFLAG) VALUES(ICMOP2). *
.*       &TYPE     TYPE OF INSTRUCTION FORMAT ($RR,$RX,ETC).          *
.*       &VALUE    VALUE OF CODE REQUIRED FOR TABLE.                  *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         ORG   ICTTAB+&TYPE/2
&LABEL   DC    AL1(&VALUE)
         MEND
         TITLE '*** OPG MACRO - GENERATE OPCODTB ENTRY FOR OPCOD1 ***'
         MACRO
         OPG   &MNEM,&TYPE,&HEX,&MASK,&CODE
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: OPG        CREATE 1 ENTRY IN ASM OPCODE TABLE (OPCOD1).  *
.*       THE GENERATED ENTRY IS DESCRIBED BY DSECT OPCODTB.           *
.*       GENERATES THE 4 FIELDS OF AN OPCODTB ENTRY - OPCTYPE,OPCHEX, *
.*       OPCMASK, AND OPCMNEM.  IF &HEX OR &MASK ARE OMITTED,THEY     *
.*       ARE ASSUMED TO BE 0.   &CODE IS USED FOR INSTRUCTIONS WHICH  *
.*       MAY NOT BE GENERATED. IF USED , IT IS 'D' FOR DECIMAL INSTS, *
.*       'F' FOR FLOATING POINT INSTRUCTIONS, AND 'P' FOR PRIVILEGED  *
.*       OPERATIONS.  IF THE SPECIFIED TYPE IS NOT TO BE GENERATED,   *
.*       THE APPROPRIATE GLOBAL VARIABLE WILL HAVE BEEN SET, AND THE  *
.*       OPCODTB ENTRY WILL NOT BE CREATED.                           *
.*       &CODE = 'M' FOR MACRO OPCODES.                               *
.*       &CODE = 'FX' FOR EXTENDED FLOATING POINT OPCODES.            *
.*       &CODE = 'S370' FOR NON-PRIVILEGED S/370 OPCODES.             *
.*       &CODE = 'P370' FOR PRIVILEGED S/370 OPCODES.                 *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLB  &OPNGN(8)           USED TO KNOW IF LENGTH HAS BEEN USED
         GBLB  &$DECSA,&$FLOTA,&$PRIVOP      GENERATION STATUS VARS
         GBLB  &$MACROS            =1 GEN MACRO OPCODES
         GBLB  &$FLOTAX            =1 GEN EXTENDED FP OPCODES
         GBLB  &$S370A             =1 GEN NON-PRIVILEGED S/370 OPCODES
         GBLB  &$P370A             =1 GEN PRIVILEGED S/370 OPCODES
         AIF   (T'&CODE EQ 'O').XNOC         SKIP IF NO CODE USED
         AIF   ('&CODE' EQ 'F' AND NOT &$FLOTA).XEXIT  SKIP IF NOTFLOAT
         AIF   ('&CODE' EQ 'FX' AND NOT &$FLOTAX).XEXIT SKIP IF NO EXFP
         AIF   ('&CODE' EQ 'D' AND NOT &$DECSA).XEXIT  SKIP IF NO DECS
         AIF   ('&CODE' EQ 'P' AND NOT &$PRIVOP).XEXIT SKIP IF NO PRIVS
         AIF   ('&CODE' EQ 'M' AND NOT &$MACROS).XEXIT SKIP IF NO MACRS
         AIF   ('&CODE' EQ 'S370' AND NOT &$S370A).XEXIT SKIP IF NO 370
         AIF   ('&CODE' EQ 'P370' AND NOT &$P370A).XEXIT SKIP IF NO PRV
.XNOC    ANOP
&OPNGN(K'&MNEM) SETB 1       NOTE THAT ONE OF THIS LENGTH HAS BEEN USED
         AIF   ('&HEX' EQ '' OR '&MASK' EQ '').XNOQ    SKIP IF OMITTED
         DC    AL1(&TYPE,&HEX,&MASK),C'&MNEM'
         MEXIT
.XNOQ    AIF   (T'&HEX EQ 'O').XNOX    SKIP IF HEX OMITTED.
         DC    AL1(&TYPE,&HEX,0),C'&MNEM'
         MEXIT
.XNOX    AIF   (T'&MASK EQ 'O').XNOMSK SKIP IF MASK FIELD OMITTED
         DC    AL1(&TYPE,0,&MASK),C'&MNEM'
         MEXIT
.XNOMSK  DC    AL1(&TYPE,0,0),C'&MNEM'
.XEXIT   MEND
         TITLE '*** OPGT MACRO - GENERATE OPCOD1 POINTER TABLES ***'
         MACRO
         OPGT
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: OPGT       CREATE 2ND LEVEL OPCODE PTR TABLES (OPCOD1).  *
.*       USES MACROS: $AL2                                            *
.*       NOTE &OPNGN VALUES WERE SET BY OPG MACRO. CALLED 1 TIME ONLY.*
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLB  &OPNGN(8)           LENGTH TAGS
         LCLC  &O                  PREFIX CHARACTERS
         LCLA  &I                  LOOP COUNTER
.OPLOOP  ANOP
&I       SETA  &I+1                INCREMENT TO NEXT LENGTH
         AIF   (&OPNGN(&I)).OPGEN1 GENERATE, IF ANY WERE USED
OPF&I    EQU   OPADS .             NAME FOR UNUSED # OF LETTERS
         AGO   .OPBOT              GO TO BOTTOM OF LOOP
.OPGEN1  ANOP
&O       SETC  'OP&I'              GET PREFIX CHRACTERS
OPF&I    $AL2  OPFIND,                                                 X
               (&O.A,&O.B,&O.C,&O.D,&O.L,&O.M,&O.N,&O.S,&O.T,&O.END)
.OPBOT   AIF   (&I LT 8).OPLOOP    CONTINUE LOOPING
         MEND
         TITLE 'REPRNT MACRO - PRINT MACRO FOR REMONI INTERNAL USE'
         MACRO
&LABEL   REPRNT &MSG,&MSGL
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: REPRNT     PRINT MESSAGE MACRO FOR REMONI USE            *
.*       &MSG  GIVES RX-TYPE ADDRESS OF MESSAGE TO BE PRINTED.        *
.*       &MSGL GIVES LENGTH OF THE MESSAGE TO BE PRINTED.             *
.*       MODIFIES REGISTERS  R7, R8, R14.                             *
.*       CALLS INSUB, REXPRINT.                                       *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
&LABEL   LA    R7,&MSG   .         SHOW @ MESSAGE
         LA    R8,&MSGL   .        SHOW LENGTH OF MESSAGE
         BAL   R14,REXPRINT .      CALL THE INSUB
         MEND
         TITLE 'RFSGN MACRO - GENERATES 1 ENTRY IN TABLE CSECT RFSYMS'
         MACRO
&LABEL   RFSGN &CSECT,&ENTRY,&TYPE=0
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: RFSGN      GENERATE 1 ENTRY OF REPLACE NAME TABLE(RFSYMS)*
.*             RFSGN MACRO IS USED TO GENERATE THE PRIMARY TABLE      *
.*       OF CSECT NAMES AND THEIR ENTRY POINT NAMES, WHICH IS USED TO *
.*       DO REPLACEMENT AND CHECKING OF STUDENT-WRITTEN CSECTS.       *
.*             IF &$REPL=2 AND TYPE=2, RFSGN CREATES AN ELEMENT IN    *
.*       THE SECOND SECTION OF RFSYMS, WHICH DESCRIBES A CALLABLE     *
.*       ENTRYPOINT IN REAL ASSIST ROUTINES.                          *
.*       &CSECT    NAMES A CSECT WHICH CAN BE REPLACED.               *
.*             IF TYPE=2, NAMES A CALLABLE ENTRY FOR 2ND SECTION.     *
.*       &ENTRY    IS A LIST OF 1 OR MORE ENTRY POINT NAMES IN &CSECT.*
.*             IF TYPE=2, THIS ONE IS OMITTED.                        *
.*       &TYPE     = 1 IF &CSECT MAY CALL OTHER CSECTS, OMITTED IF NOT*
.*             =2 IF CALL IS TO CREATE CALLABLE ENTRY ELEMENT.        *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLA  &$REPL              REPLACE VAR. 0=NONE, 1=LIMITED
         LCLA  &I,&N               INDEX, L'&ENTRY
         LCLC  &EN                 TEMPORARY ENTRY NAME FOR CONVENINCE
         AIF   ('&TYPE' NE '0' AND &$REPL NE 2).RFSB  SKIP IF NOT LIM R
         AIF   ('&TYPE' EQ '2').RFSA2       SKIP IF TYPE 2 ELEMENT
&N       SETA  N'&ENTRY            GET # ENTRIES, >= 1
.*             RFSYMB,RFSENTN,RFSENTL,RFSTYPE.
&LABEL   DC    CL6'&CSECT',AL1(&N,RFS$LEN*(&N+1))
         AIF   ('&TYPE' EQ '0').RFSA1       SKIP IF CAN'T CALL OTHER
         DC    AL2(RI&CSECT-RFSYMS)    REPLACE CSECT WHICH CAN CALL
         AGO   .RFSA               GO BACK FOR NEXT
.RFSA1   DC    AL2(0)
.RFSA    AIF   (&I GE &N).RFSB     JUMP OUT IF NO MORE ENTRIES
&I       SETA  &I+1                INCREMENT INDEX TO ENTRIES
.*             RFSYMB,RFSAXPT,RFSRGPT,RFSRHPT.
&EN      SETC  '&ENTRY(&I)'        GET ENTRY, FOR CONVENIENCE
         DC    CL6'&EN',AL2(AX&EN-AX$BASE,RG&EN-RG$BASE)
         AGO   .RFSA
.RFSA2   ANOP
RF&CSECT DC    CL6'&CSECT',AL2(AX&CSECT-AX$BASE,RH&CSECT-RH$BASE)
.RFSB    SPACE 1
         MEND
         TITLE '*** WCONG MACRO - GENERATE CONST.ADDR OFFSET TABLE ***'
         MACRO
         WCONG &C
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: WCONG      CREATE OFFSETS TO CONSTANT SUBR ADCONS-VWXTABL*
.*       CREATE WCONADS TABLE IN VWXTABL FOR USE OF CODTL1 AND CNDTL2 *
.*       IN DOING TABLE-DRIVEN CONSTANT PROCESSING. CALLED 1 TIME ONLY*
.*       &C        LIST OF CONSTANT TYPES ALLOWED.    (A,B,C, ETC).   *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         LCLA  &I                  COUNTER
         AIF   ('&SYSECT' NE 'VWXTABL').XXEXIT         SKIP IF NOT VWXT
.LOOP    ANOP
&I       SETA  &I+1                INCREMENT TO NEXT 1
         ORG   WCONADS+$CN&C(&I)   ORG TO ADCON SPOT
         DC    AL1(AXC&C(&I).CON1-AXC$BASE)
         AIF   (&I LT N'&C).LOOP   LOOP UNTIL DONE
         ORG
.XXEXIT  MEND
         TITLE '$TIRC MACRO - TIME OR RECORS -USED OR REMAINING(PSU)'
         MACRO
&LABEL   $TIRC &TYPE
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $TIRC      GET TIME/RECORDS DATA FROM OPERATING SYSTEM.  *
.*             THIS MACRO USES PSU SVC CALL 250 TO OBTAIN TIME OR     *
.*       RECORDS INFORMATION.  &TYPE IS TIMREM,TIMUSE,RECREM,RECUSE.  *
.*       RESULT IS RETURNED IN R0, IN EITHER RECORDS, OR IN TIMER     *
.*       UNITS OF 26.04 MICROSECOND.  DESTROYS R0,R1,R15.             *
.*       *NOTE* MAY HAVE TO BE REWRITTEN FOR LOCAL CONDITONS.         *
.*       &TYPE CAN ALSO BE OF FORM  (NAME,ADDR)  WHERE ADDR IS AN     *
.*       RX-TYPE ADDRESS, AT WHICH THE MACRO PLACES THE FOLLOWING:    *
.*       BYTES  0-4  : ACCOUNT NUMBER       .... INFORMATION FROM     *
.*       BYTES  5-12 : JOB NAME             .... FROM                 *
.*       BYTES 13-32 : PROGRAMMER NAME      .... JOB CARD             *
.*       THIS FORM NEEDED ONLY IF &$ACCT=1,  AND IS COMPLETELY LOCAL  *
.*       TO PSU CC, THUS MUST BE REWRITTEN IF USED ELSEWHERE.         *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         AIF   ('&TYPE(1)' NE 'NAME').TIMREC          SKIP IF NOT NAME
         CNOP  0,4                 ALIGN FOR LATER ADCON
&LABEL   LA    R1,&TYPE(2)  .      GET @ WHERE INFO TO BE PUT
         ST    R1,*+8 .            STORE INTO PARAMATER LIST
         BAL   R1,*+8 .            SET R1==> ADCON, SKIP AROUND
         DS    A .                 FOR @ AREA FOR INFORMATION
         SR    R15,R15             R15 = 0 PART OF CONVENTION
         SR    R0,R0 .             SET R0 TO 0 FOR NAME CALL
         BCTR  R0,0 .              SET R0 TO -1==> WANT NAME
         SVC   250 .               GET ACCOUNTING INFO****PSU CC*******
         AGO   .XXEXIT             QUIT GENERATING
.TIMREC  ANOP
         AIF   ('&TYPE'(1,3) EQ 'TIM').TIM  SKIP IF TIME DESITRED
&LABEL   SR    R0,R0
         SR    R15,R15
         SVC   250 .               MAKE RECORD CALL
         AIF   ('&TYPE'(4,3) EQ 'USE').XXEXIT         SKIP IF DONE
         LR    R0,R1 .             MOVE RECORDS REMAINING OVER
         MEXIT
.TIM     ANOP
&LABEL   LA    R0,1
         SR    R15,R15
         SVC   250 .               MAKE CALL FOR TIME INFO
         AIF   ('&TYPE'(4,3) EQ 'USE').TIM2 SKIP IF IN RIGHT REG
         LR    R0,R1 .             MOVE TIME REMAINING OVER
.TIM2    SLL   R0,2 .              *4 FOR # 26.04 MIC TIMER UNITS
.XXEXIT  MEND
         TITLE 'APCGN MACRO - GENERATE APCBLK IN CSECT APARMS'
         MACRO
&LABEL   APCGN &PARM,&AJOFS,&BITS,&C=0,&N=0,&D=0,&I1=0,&Y=0,&G=1,&GC=0,#
               &LK=111
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: APCGN      GENERATE 1 APCBLK ELEMENT IN APARMS           *
.*       GENERATES BLOCK FOR PARM OPTION SCANNING CONTROL, DEPENDING  *
.*       ON DESIRED CHARACTERISTICS OF THE PARM. MAY SKIP GENERATION  *
.*       IF THE REQUIRED OPTION DOES NOT EXIST IN PARTICULAR SYSTEM.  *
.*       ***SEE DSECT APCBLK AND CSECT APARMS (FROM LABEL APFOUND)    *
.*       FOR FURTHER INFORMATION ON HANDLING OF BLOCK CREATED BY THIS.*
.*  &PARM      NAME OF THE PARM OPTION.                               *
.*  &AJOFS     NAME OF VARIABLE IN AJOBCON TO BE SET BY THIS PARM     *
.*  &BITS      VALUE USED TO SET FLAG FOR YES/NO TYPE PARMS.          *
.*       IF =PARM AND NOT CALL TYPE, SHOULD BE GIVEN VALUE 0.         *
.*  &G,&GC     USED TO CONTROL GENERATION.  GENERATION IS SKIPPED     *
.*       IF &G EQ &GC, THUS ALLOWING CONDITIONAL ASSEMBLY OF PARMS.   *
.*       &C THRU &Y GIVE TYPE BITS TO BE PLACED INTO APCFLAG.  EACH   *
.*       CORRESPONDS TO 1 OR MORE EQU SYMBOLS, AS LISTED.             *
.*  &C         =1 IF PARM IS NONSTANDARD AND A ROUTINE MUST BE CALLED.*
.*       APPLIES ONLY TO =VALUE TYPE PARMS.  THE ROUTINE CALLED MUST  *
.*       BE NAMED APA&PARM.                           (APCCALL)       *
.*  &N         =1 IF VALUE CANNOT BE GIVEN ANOTHER VALUE ONCE IT HAS  *
.*       BEEN SET ONCE.  MAY BE USED BY ANY PARM TYPE.(APCNRSET)      *
.*  &D         =1 IF PARM IS PARM=DECIMAL VALUE.  IF THIS IS CODED    *
.*       AND PARM IS NOT A SPECIAL CALL TYPE, THEN IT IS ASSUMED THAT *
.*       THE VALUE CONVERTED IS TO BE STORED AS A FULLWORD AT THE     *
.*       GIVEN VARIABLE LOCATION IN AJOBCON.          (APCD)          *
.*  &I1        =1 IF PARM IS A YES/NO TYPE AND  1BIT ON CORRESPONDS   *
.*       TO A YES VALUE (1BIT MEANS NO OTHERWISE).    (APCYES1B)      *
.*             =1 IF PARM IS =DECIMAL # PARM, AND MAY NEVER BE        *
.*       INCREMENTED AFTER IT HAS BEEN SET (BUT MAY BE DECREASED).    *
.*       USED PARTICULARLY FOR TIME/RECORDS LIMITS.   (APCNINCR)      *
.*  &Y         =1 IF THE PARM IS A YES/NO TYPE.  OTHERWISE, IT IS     *
.*       AN =PARM OF SOME SORT.                       (APCYESNO)      *
.*  &LK        DENOTES WHICH OF THE POSSIBLE CALLS IS ALLOWED TO SET  *
.*       A VALUE FOR THE GIVEN PARM.  CONSISTS OF 3 BITS: ###, WITH   *
.*       MEANINGS AS FOLLOW:                                          *
.*       100   CAN BE SET BY LIMIT OR DEFAULT VALUE  (APCSETLD)       *
.*       010   CAN BE SET FROM THE PARM FIELD         (APCSETP)       *
.*       001   CAN BE SET BY USER FROM $JOB CARD      (APCSETU)       *
.*             THIS MACRO USED ONLY IN APARMS CSECT.                  *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         AIF   ('&G' EQ '&GC').XXEXIT       SKIP IF FLAGGED THAT WAY
&LABEL   DC    CL(APCP$L)'&PARM',B'&LK&C&N&D&I1&Y',AL1(&AJOFS-AJO$APC)
         DC    B'0'
         AIF   (&C EQ 1).APCC      SKIP IF CALL TYPE
         DC    AL1(&BITS)
         MEXIT
.APCC    DC    AL1(APA&PARM-APAJUMP)
.XXEXIT  MEND
         TITLE '*** ASSIST CSECT MACROS: ASPRNT,ASTIME ***'
         MACRO
&LABEL   ASPRNT &XAREA,&XNUM
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: ASPRNT     PRINT LINE INSIDE MAIN PROG ASSIST.           *
.*       ASPRNT SETS UP R0=@ LINE, R1=LENG, CALLS INSUB ASASPRNT OF   *
.*       ASSIST.  MODIFIES REGS R0,R1,R14.                            *
.*       &XAREA,&XNUM SAME AS THOSE FOR $PRNT = @, LENGTH TO PRINT.   *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
&LABEL   LA    R0,&XAREA  .        SHOW @ PRINT AREA
         AIF   ('&XNUM'(1,1) EQ '(').ASREG  SKIP IF REGISTER FORM
         LA    R1,&XNUM  .         SHOW LENGTH
         AGO   .ASBAL
.ASREG   LR    R1,&XNUM  .         MOVE LENGTH REGISTER VALUE OVER
.ASBAL   BAL   R14,ASASPRNT .      CALL INSUB ASPRNT
         MEND
         SPACE 2
         MACRO
&LABEL   ASTIME &ASH,&VALUE
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: ASTIME     UPDATE TIMER,PRINT TIMING MESSAGES(ASSIST).   *
.*       &ASH      NAME OF MESSAGE, IF OMITTED UPDATE TIMER ONLY.     *
.*       &VALUE    NAME OF VALUE TO BE CONVERTED, OMITTED-NO 2ND PART *
.*       *NOTE* ONLY USABLE INSIDE MAIN PROGRAM ASSIST.               *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         AIF   (T'&ASH NE 'O').ASCALL1       SKIP IF OPERAND USED
&LABEL   SR    R2,R2 .             SHOW ASTIMER JUST UPDATE TIMER
         AGO   .ASCALL2            GO HAVE BAL GENREATED
.ASCALL1 ANOP
&LABEL   LA    R2,&ASH .           ENTER @ AREA TO BE PRINTED
         LA    R3,&ASH.P
         LA    R4,&ASH.L  .        LENGTH OF MESSAGE TO BE PRINTED
         AIF   ('&VALUE' EQ '').ASCNV       SKIP IF NO VALUE
         LA    R6,&ASH.N .         SHOW @ WHERE STMT/SEC GOES
         AIF   ('&VALUE' EQ '*').ASCALL2    SKIP IF VALUE ALREADY IN
         L     R7,&VALUE .         GET VALUE TO BE CONVERTED
         AGO   .ASCALL2
.ASCNV   SR    R6,R6 .             SHOW THERE IS NO 2ND PART MESSAGE
.ASCALL2 BAL   R14,ASTIMER .       CALL TEST TIMER ROUTINE
         MEND
         TITLE '*** ASSIST MACROS: ASPAGE,ASRECL,ASTIMR ***'
         MACRO
         ASPAGE &CODE
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: ASPAGE     LINK TO SECTION OF PAGE CONTROL CODE          *
.*       &CODE IS TWO-DIGIT # GIVING DESIRED SECTION OF PAGE CONTROL  *
.*       CALL IS GENERATED ONLY IF &$PAGE = 1.                        *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLB  &$PAGE              =1 PAGE CONTROL CODE EXISTS
         AIF   (NOT &$PAGE).XXEXIT SKIP IF NO PAGE CODE EXISTS
         BAL   R9,ASPAGE&CODE .    CALL SECTION OF ASPAGE##
.XXEXIT  MEND
         SPACE 2
         MACRO
         ASRECL &CODE
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: ASRECL     LINK TO RECORD LIMIT CONTROL CODE             *
.*       &CODE IS TWO DIGIT NUMBER GIVING SECTION OF ASRECL## CALLED  *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         BAL   R9,ASRECL&CODE .    CALL SECTION OF ASRECL##
         MEND
         SPACE 2
         MACRO
&LABEL   ASTIMR &CODE,&TLEVEL
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: ASTIMR     LINK TO TIMER ROUTINES IN MAIN PROGRAM ASSIST *
.*       ASTIMR ALLOWS FOR CONDITIONAL GENERATION OF CALLS TO         *
.*       VARIOUS TIMING MODULES INSIDE ASSIST MAIN PROGRAM, DEPENDING *
.*       ON THE DESIRED TIMING METHOD BEING USED.                     *
.*       &CODE  IS 2-DIGIT CODE, GIVING SECTION OF ASTIMR TO BE CALLED*
.*       &TLEVEL IS 0,1,2.  NO CODE IS CREATED IF &$TIMER<&TLEVEL.    *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLA  &$TIMER             TIMER LEVEL BEING USED
&LABEL   DS    0H
         AIF   (&$TIMER LT &TLEVEL).XXEXIT  SKIP IF NOT IN USE
         BAL   R9,ASTIMR&CODE .    CALL ENTRY OF ASTIMR## CODE
.XXEXIT  MEND
         TITLE '*** XCALL - OS LINKAGE, LITERAL VCON ***'
         MACRO
&LABEL   XCALL &ENTRY
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XCALL      SUBROUTINE CALL, OS LINKAGE, LITERAL FORM.    *
.*       &ENTRY    NAME OF ENTRYPOINT TO BE CALLED.                   *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
&LABEL   L     REP,=V(&ENTRY) .    GET @ ENTRY POINT
         BALR  RET,REP .           CALL THE ROUTINE
         MEND
         TITLE '*** GLOBAL SET SYMBOLS AND EQUATES ***'
**       GLOBAL SET VARIABLES - SYSGEN TYPE - &$------                *
         GBLB  &$ACCT              =1 => ACCOUNT DISCRIMINATION POSSIBL
         GBLB  &$ALIGN             =0 ==> MODEL REQUIRES DATA ALIGNED
*                                  =1 ==> MODEL DOES NOT REQUIRE ALIGN
         GBLB  &$ASMLVL            =0==>DOS,=1==>OS
         GBLC  &$BATCH             LIMIT/DFLT: BATCH(DOS) - NOBATCH(OS)
         GBLC  &$BTCC(4)           BATCH CONTROL CARD ITEMS: SEE SETC'S
         GBLA  &$BLEN              SET TO BUFFER LENGTH IN BYTES
         GBLA  &$BUFNO             THE NUMBER OF BUFFERS
         GBLB  &$CMPRS             =0 NO CMPRS CODE, =1 CMPRS OPTION
         GBLA  &$COMNT             >0 COMMENT CHECK (&$COMNT % REQ)
         GBLB  &$DATARD            =0 SOURCE,DATA THRU SYSIN ONLY(WATFV
*                                  =1 DATA MAY BE READ FROM FT05F001
*                                  (I.E.- SINGLE JOB PROCESSING-PSU)
         GBLB  &$DECSA             SHOULD ASSEMBLER PERMIT DECIMALS
         GBLB  &$DECSM             DOES MACHINE HAVE DECIMALS
         GBLB  &$DECK              =0 NO OBJ DECKS PUNCHED. =1 CAN DO
         GBLB  &$DMPAG             =1 BEGIN DUMP ON NEW PAGE, 0=> NO  J
         GBLC  &$DSKUDV            DEVICE TYPE FOR DISK DEFAULT TO
*                                  2314 DISK DRIVE
         GBLA  &$DISKU             0 FOR NO DISK UTILITY
*                                      1 FOR USER OPTION
*                                      2 FOR ALWAYS DISK
         GBLB  &$FLOTA             SHOULD ASSEMBLER ALLOW FLOATING PT
         GBLB  &$FLOTAX            SHOULD ASSEMBLER ALLOW EXTENDED FP'S
         GBLB  &$DEBUG             0==>DEBUG MODE, 1==> PRODUCTION MODE
         GBLA  &$ERNUM             # DIFFERENT ERROR MESSAGES
         GBLB  &$EXINT             = 0 REGULAR INTERPRETER
*                                  = 1 EXTENDED INTERPRETER
         GBLB  &$FLOTE             =1==> WILL INTERPRET FLT,0==> NO
         GBLB  &$FLOTEX            =1==> WILL INTERPRET EX FP'S,0==> NO
         GBLB  &$FLOTM             =1==> MACHINE HAS FLTING PT,0==> NO
         GBLB  &$FLOTMX            =1==> MACHINE HAS EX FP'S,0==> NO
         GBLA  &$FREE,&$FREEMN     DEFAULT FREE=, MINIMUM FREE= (80A) J
         GBLC  &$GENDAT            GENERATATION DATE FOR THIS ASSIST
         GBLB  &$HASPBT            =1 HASP AUTOBATCH CODE SUPPORTED   J
         GBLB  &$HEXO              =1==> HEXO ALLOWED,=0==> NOT ALLOWED
         GBLB  &$HEXI              =1==> HEXI ALLOWED,=0==> NOT ALLOWED
         GBLA  &$IDF,&$IMX         DEFAULT,MAXIMUM I= # INSTRUCTIONS
         GBLC  &$IOUNIT(8)         GLOBAL SUBLISTED VARIABLE FOR
*                                  DDNAMES IN DCB'S AND DTF'S
*
*        &$IOUNIT(1)= PRIMARY INPUT, OS=> SYSIN, DOS=> SYSIPT
*        &$IOUNIT(2)= SECONDARY INPUT, OS=> FT05F001, DOS=> SYSRDR
*        &$IOUNIT(3)= PRINTER, OS=>FT06F001, DOS=> SYSLST
*        &$IOUNIT(4)= PUNCH, OS=> FT07F001, DOS=> SYSPCH
*        &$IOUNIT(5)= DISK INTERMEDIATE, OS=>FT08F001, DOS=> IJSYS01
*        &$IOUNIT(6)= MACRO LIBRARY, OS=> SYSLIB, DOS=> N/A
*        &$IOUNIT(7)= FUTURE USE
*        &$IOUNIT(8)= FUTURE USE
*
         GBLB  &$JRM               =1 FOR PSU LOCAL SPECIAL CODE: JRM
         GBLB  &$KP26              =1 ALLOW KP=26 OR KP=29 OPTION
*                                  =0 ALLOW ONLY 029 KEYPUNCH CARDS
         GBLA  &$LDF,&$LMX         DEFAULT,MAX L= # LINES/PAGE
         GBLB  &$MACOPC            =1 ==> ALLOW OPEN CODE COND ASMBL
         GBLB  &$MACROG            =1 ==> ADD ASM G FEATURES TO ASM F
         GBLB  &$MACROH            =1 ==> ADD SOME ASM H FEATURES TO F
         GBLB  &$MACROV            OS/VS SUPPORT
         GBLB  &$MACROS            MACRO/CONDITIONAL ASSEMBLY ALLOWED
*              **NOTE** BASIC MACRO FACILITY IS ASSEMBLER F COMPATIBLE.
         GBLB  &$MACSLB            =1 ==> MACRO LIBRARY ALLOWED
         GBLC  &$MCHNE             MACHINE GENERATION OF EQUIPMENT
         GBLA  &$MMACTR            LOCAL ACTR INITIAL VALUE DEFAULT
         GBLA  &$MMNEST            MACRO NEST LIMIT DEFAULT
         GBLA  &$MMSTMG            GLOBAL MACRO STMT LIMIT DEFAULT
         GBLA  &$MODEL             MODEL NUMBER OF 360/370 BEING RUN ON
         GBLB  &$OBJIN             =0 CANNOT READ OBJECT DECK. =1 CAN
         GBLA  &$OPTMS             OPTIMIZE - 0==> MEMORY, 9==> SPEED
         GBLB  &$PAGE              =0 NO PAGE COUNT/CONTROL CODE EXISTS
*                                  =1 PAGE CONTROL &OPTIONS ALLOWED
         GBLA  &$PDF,&$PMX         DEFAULT,MAX P= # PAGES LIMIT
         GBLA  &$PDDF,&$PDMX       DEFAULT,MAX PD= # PAGES FOR DUMP
         GBLB  &$PRIVOP            =0==>NO PRIV OPS, =1==> PRIV OPS OK
         GBLA  &$PRTSIZ            MAX # CHARS IN PRINT LINE FOR ASM
         GBLB  &$PUNCH             =0 WE DON'T ACTUALLY HAVE CARD PUNCH
*                                  =1 REAL PUNCH EXISTS, POSSIBLE USE
         GBLA  &$PXDF,&$PXMX       DEFAULT,MAX PX= PAGES FOR EXECUTION
         GBLB  &$P370              =1 WILL INTERPRET PRIVELEGED S/370
         GBLB  &$P370A             SHOULD ASSEMBLER PERMIT PRIV S/370'S
         GBLA  &$RDF,&$RMX         DEFAULT,MAX R= TOTAL # RECORDS
         GBLA  &$RDDF,&$RDMX       DEFAULT,MAX RD= RECORDS FOR DUMP
         GBLA  &$RECORD            =0,1=> NO $TIRC RECREM, =2=> $TIRC
         GBLB  &$RECOVR            (ONLY USED FOR &$RECORD=2).
*              =0 => R= DOES NOT OVERRIDE $TIRC VALUE, =1 => IT DOES.
*              (AT PSU, OUTPUT CAN GO TO BAT FILES - DOESN'T COUNT).
         GBLB  &$RELOC             =0==> NO RELOCATION CODE GENERATED
         GBLA  &$REPL              0=> NO REPL,1=> LIMITED,2=> FULL
         GBLA  &$RXDF,&$RXMX       DEFAULT,MAX RD= RECORDS FOR EXECUTE
         GBLB  &$SPECIO            SPECIAL ROUTINES EXIST(TYPE=$IS+)
         GBLA  &$SYHASH            SIZE OF INITIAL PTR TABLE FOR SYMOPS
         GBLC  &$SYSTEM            SYSTEM BEGIN RUN - DOS,PCP,MFT,MVT
         GBLA  &$S370              =0==> NO S/370 INSTR INTERPRETED
*                                  =1==> S/370 INSTR INTERPRETED ON 370
*                                  =2==> S/370 INSTR INTERPRETED ON 360
         GBLB  &$S370A             SHOULD ASSEMBLER PERMIT SYSTEM 370'S
         GBLC  &$TDF,&$TMX         DEFAULT,MAX T= TOTAL TIME FOR RUN
         GBLC  &$TDDF,&$TDMX       DEFAULT,MAX TD= TIME FOR DUMP
         GBLA  &$TIMER             0==> NO TIMING AT ALL
*              1==> STIMER/TTIMER ONLY. =2==> LOCAL TIMER FOR TIMREM
         GBLC  &$TXDF,&$TXMX       DEFAULT,MAX TX= TIME FOR EXECUTION
         GBLC  &$VERSLV            VERSION #.LEVEL #
         GBLB  &$XIOS              =0==>NO XIO MACROS,=1==>XIO MACROS
         GBLB  &$XREF              CONTROL GENERATION OF XREF FACILITY
*        =1 FULL XREF, =0 NO XREF AT ALL                              A
         GBLA  &$XREFDF(3)         DEFAULT VALUES FOR FLAGS           A
*        &$XREFDF(1)=0       NO XREF(OTHERS =3MEANS COMPRESSED LISTING
*        &$XREFDF(2)=3       COLLECT MODIFY AND FETCH DEFN            A
*        &$XREFDF(3)=3       COLLECT REFERENCES MODIFY/FETCH          A
         GBLA  &$XREF#B            NUMBER OF SLOTS FOR XREF BLKS      A
         GBLB  &$XXIOS             =0==>XGET-XPUT MACROS,=1==> NO
         GBLB  &X$DDMOR          ALLOW USER OWN DDNAMES:=1==>YES,0==>NO
**       GLOBAL SET VARIABLES - INTERNAL TYPE -                       *
         GBLC  &DEBUG              DEBUG NUMBER FOR TESTING AVDEBUG
         GBLC  &ID                 IDENT GENERATION CONTROL
         GBLC  &TRACE              SPECIFIES FORM OF TRACE-SNAP,*,NO
&$BTCC(1) SETC '$'            CONTROL CHARACTER FOR BATCH CARDS       J
&$BTCC(2)  SETC  'JOB'            JOB BEGINNING INDICATOR       CPP
&$BTCC(3) SETC 'ENTRY'        BEGIN DATA CARD: SET = '' IF NONE NEEDED
&$BTCC(4)  SETC  'STOP'           TERMINATOR INDICATOR          CPP
         SPACE 1
*********  NOTE  ********  SHOULD THE VALUE OF &$BLEN BE CHANGED
*        AND THE VERSION OF ASSIST TO BE GENERATED IS A DOS SYSTEM
*        THEN BE SURE TO CHANGE THE VALUE OF THE BLKSIZE PARAMETER
*        ON THE DTFSD DEFINITION IN CSECT XXXIOCO
&$BLEN   SETA  3520                HALF-TRACK SIZE FOR IBM 2316 PACK
&$BLEN   SETA  4*(&$BLEN/4)        ROUND BLEN DOWN TO FULLWORD MULTIPLE
&$BUFNO  SETA  2                   SET FOR 4 BUFFERS
&$CMPRS  SETB  (1)                ALLOW 'CMPRS' OPTION          CPP
&$COMNT  SETA  80                  REQUIRE 80% COMMENTS, IF COMNT OPT
&$DATARD SETB  (1)                 ALLOW SINGLE JOB/TWO RDRS
&$DEBUG  SETB  (1)                 FOR QUICK RUN, KILL GENERATION
&$DECK   SETB  (1)                 ALLOW OBJECT DECKS TO BE PUNCHED
&$DECSA  SETB  (1)                 ASSEMBLER WILL ACCEPT DECIMAL INSTS
&$DECSM  SETB  (1)                 PSU 360/67 HAS DECIMAL INSTRUCTIONS
&$DISKU  SETA  1                   SET FOR USER OPTION ON DISK UTILITY
&$DMPAG  SETB  1                   ASSUME COMPLETION DUMP ON NEW PAGE J
&$EXINT  SETB  1                   USE EXTENDED INTERPRETER           L
&$FLOTA  SETB  (1)                 ASSEMBLER ALLOWS FLOATING POINT
&$FLOTAX SETB  (1)                 ASSEMBLER ALLOWS EXTENDED F. P.
&$FLOTE  SETB  (1)                 WE WILL EXECUTE FLTINGS,IF POSSIBLE
&$FLOTEX SETB  (1)                 WILL EXECUTE EXTENDED F. P., IF POSS
&$FLOTM  SETB  (1)                 PSU 360/67 HAS FLOATING POINT
&$FLOTMX SETB  (0)                 PSU 360/67 HASN'T GOT EXTENDED F. P.
&$FREE   SETA  30720               RETURN 30K TO OS/360               L
&$FREEMN SETA  2048                MINIMUM ALLOWED FREE=;  *****NOTE  J
*              IF YOU HAVE 80A ABEND'S OFTEN, RAISE THIS AS NEEDED*** J
&$GENDAT SETC  '12/02/75'          CURRENT GENERATION DATE
&$IDF    SETA  150000              100 SECS ON /67
&$IMX    SETA  150000              100 SECS ON /67
&$KP26   SETB  (1)                 ALLOW 026 KEYPUNCH
&$LDF    SETA  63                  DEFAULT 63 LINES/PAGE
&$LMX    SETA  63                  MAXIMUM OF 63 LINES/PAGE
*              MACRO SETS: ONLY SIGNIFICANT IF &$MACROS=1.
&$MACOPC SETB  1                   ALLOW OPEN CODE, AT LEAST FOR TEST
&$MACROS SETB  1                   ALLOW MACROS TO BE PROC ESSED
&$MACROG SETB  0                   NO ASM G CODE ***NOT SUPPORTED YET**
&$MACROH SETB  0                   NO ASM H CODE ***NOT SUPPORTED YET**
&$MACROV SETB  0                   NO OS/VS ASSEMBLER SUPPORT YET
&$MACSLB SETB  1                   ALLOW MACRO LIBRARY FETCH
&$MCHNE  SETC  '370'               PSU RUNS SYSTEM 370
&$MMACTR SETA  200                 DEFAULT ACTR VALUE = 200
&$MMNEST SETA  15                  DEFAULT LIMIT OF 15 DEEP IN MACS
&$MMSTMG SETA  4000                DEFAULT MAXIMUM TOTAL 4000 MAC STMTS
         SPACE 1
&$MODEL  SETA  65                  DEFAULT MODEL NUMBER
&$OBJIN  SETB  (1)                 ALLOW OBJECT DECKS TO BE READ
&$OPTMS  SETA  4                   MEDIUM OPTIMIZATION
&$PAGE   SETB  (1)                 ALLOW ALL PAGE CONTROL OPTIONS
&$PDF    SETA  10                  TEN TOTAL PAGES
&$PMX    SETA  25                  MAXIMUM POSSIBLE OF 25 TOTAL
&$PDDF   SETA  1                   NORMAL DUMP-JUST FIRST PAGE
&$PDMX   SETA  5                   MAXIMUM OF 5 PAGES FOR THE DUMP
&$PRIVOP SETB  1                   ALLOW ALL PRIVILEGED OPERATIONS
&$PRTSIZ SETA  121                 LIMIT TO 121 CHARS AS DEFAULT LIM  J
&$PUNCH  SETB  (1)                 A REAL PUNCH EXISTS
&$PXDF   SETA  5                   DEFAULT PAGES FOR EXECUTION
&$PXMX   SETA  5                   MAXIMUM PAGES FOR EXECUTION
&$RDF    SETA  100000              DEFAULT RECORDS FOR EXEC
&$RMX    SETA  100000              MAX EXECUTION RECORDS
&$RDDF   SETA  25                  DEFAULT RECORDS FOR A DUMP
&$RDMX   SETA  5000                MAXIMUM RECORDS FOR DUMP
&$RECORD SETA  1                   SHOW $TIRC RECREM CAN'T BE USED
&$RELOC  SETB  (1)                 NEED RELOC SINCE WE HAVE REPL
&$REPL   SETA  2                  ALLOW FULL REPL. OPTIONS      CEH
&$RXDF   SETA  10000               DEFAULT EXECUTION RECORDS
&$RXMX   SETA  10000               MAXIMUM EXECUTION RECORDS
&$SYSTEM SETC  'OS-MVT'            SYSTEM IS OS OPTION MVT
&$S370   SETA  2                   PSU WANTS S/370'S ON 360/67
&$S370A  SETB  (1)                 ASSEMBLER ALLOWS S/370'S
&$XIOS   SETB  (1)                 WE'RE ALLOWING XIO MACROS
&$XXIOS  SETB  0                   ALLOW XGET - XPUT
&X$DDMOR SETB  0                   ALLOW USER OWN DD NAMES
&$HEXI   SETB  (1)                 XHEXI ALLOWED THIS ASSEMBLY
&$HEXO   SETB  (1)                 XHEXO ALLOWED
&$TDF    SETC  '100'               DEFAULT SECONDS FOR RUN
&$TMX    SETC  '200'               MAX POSSIBLE SECONDS FOR RUN
&$TDDF   SETC  '.1'                DEFAULT TIME FOR DUMP
&$TDMX   SETC  '10'                MAXIMUM TIME FOR A DUMP
&$TIMER  SETA  1                   SHOW WE WANT OVERALL TIMING DONE
&$TXDF   SETC  '100'               DEFAULT TIME FOR EXECUTION
&$TXMX   SETC  '200'               MAXIMUM TIME FOR EXECUTION
&$VERSLV SETC  '4.0/A2'            VERSION LEVEL (CEH,CPP,TXM 12/02/75)
&$XREF   SETB  1                   ALLOW CROSS REFERENCE
&$XREFDF(1) SETA  3                PSU TESTING                        L
&$XREFDF(2) SETA  3                COLLECT ALL MOD/FETCH DEFN         A
&$XREFDF(3) SETA  3                COLLECT ALL MOD/FETCH REFERENCES   A
&$XREF#B SETA  10                  ALLOCATE 10 SLOTS/BLOCK            A
&$ASMLVL SETB  ('&$SYSTEM'(1,2) EQ 'OS')     SET LEVEL OF ASSEMBLER
&$FLOTE  SETB  (&$FLOTE AND &$FLOTM)         KILL GEN IF NO FLOATS
&$FLOTEX SETB  (&$FLOTEX AND &$FLOTMX) KILL GEN IF NO EXTENDED FLOATS
         AIF   (&$ASMLVL).OSGEN    SKIP IF OS GENERATION
&$BATCH  SETC  'BATCH'            DEFAULT OF DOS IS BATCH       CEH
&$IOUNIT(1) SETC  'SYSIPT'         SET DOS MAIN INPUT
&$IOUNIT(2)  SETC  'SYSRDR'        SET DOS SECONDARY INPUT
&$IOUNIT(3)  SETC  'SYSLST'        SET DOS PRINTER
&$IOUNIT(4) SETC 'SYSPCH'          SET DOS PUNCH
&$IOUNIT(5)    SETC 'SYS001'       SET DOS DISK INTERMEDIATE
&$BUFNO  SETA  2                   FOR DOS GEN INSURE ONLY 2 BUFFERS
&$DSKUDV SETC  '2314'              SET DOS DISK DRIVE TYPE
         AGO   .OSGEN1
.OSGEN   ANOP
&$BATCH  SETC  'NOBATCH'          DEFAULT FOR OS IS NOBATCH     CEH
&$IOUNIT(1)  SETC  'SYSIN'         SET OS PRIMARY INPUT
&$IOUNIT(2)  SETC  'FT05F001'      SET OS SECONDARY INPUT
&$IOUNIT(3)  SETC  'FT06F001'      SET OS PRINTER
&$IOUNIT(4)  SETC  'FT07F001'      SET OS PUNCH
&$IOUNIT(5)  SETC  'FT08F001'      SET OS DISK INTERMEDIATE
&$IOUNIT(6)  SETC  'SYSLIB'        SET OS MACRO LIBRARY
.OSGEN1  ANOP
&ID      SETC  'NO'                SET NO ID FOR TIME BEING
         AIF   (&$DEBUG).EQU1      LEAVE NO ID IF PRODUCTION PROG
&ID      SETC  '*'                 DEBUG==> GENERATE ID'S AT ENTRIES
.EQU1    ANOP
         ASSYSGEN ,                CALL TO POSSIBLY RESET SET VARIABLES
&$P370   SETB  (&$PRIVOP AND (&$S370 NE 2)) KILL GEN IF NO PRIV OR S370
&$P370A  SETB  (&$PRIVOP AND &$S370A) NO PRIV 370'S IF NO PRIV OR S370
&$ALIGN  SETB  (&$ALIGN OR (&$S370 EQ 1 OR &$MODEL EQ 85)) FORCE VALUE
&$MACSLB SETB  (&$MACSLB AND &$MACROS)  REMOVE LIBRARY IF NO MACROS   J
&$RELOC  SETB  (&$RELOC OR (&$REPL NE 0))  IF REPL, MAKE SURE RELOC   J
&$HASPBT SETB  (&$HASPBT AND &$ASMLVL)  ELIM HASP IF NOT OS SYSTEM    J
         SPACE 2
         TITLE '*** OPCODTB DSECT - OPCODE CONTROL TABLE ENTRY ***'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: OPCODTB    DESCRIBES 1 ENTRY IN OPOCDE TABLE              *
*        LOCATION: ELEMENTS OF TABLE IN CSECT OPCOD1 OF ASSEMLBER.    *
*        GENERATION: 1 CALL TO MACRO OPG CREATES AN ELEMENT.          *
*        SECTIONS OPCTYPE,OPCHEX,OPCMASK CORRESPOND TO SIMILARLY-NAMED*
*        SECTIONS OF DUMMY SECTION RCODBLK. SEE CSECT OPCOD1.         *
*        NAMES: OPC-----                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
OPCODTB  DSECT
OPCTYPE  DS    C                   TYPE BYTE FOR MNEMONIC
OPCHEX   DS    C                   HEX CODE FOR MACHINE OPS/SUBCODE
OPCMASK  DS    C                   MASK/ALIGNMENT(MACHINE) / SUBCODE
OPCMNEM  DS    CL8                 MNEMONIC- FROM 1 TO 8 CHARACTERS
         SPACE 4
* * * * * EQUATES USED FOR BCR INSTRUCTIONS * * * * * * * * * * * * * *
H        EQU   2                   HIGH
L        EQU   4                   LOW
E        EQU   8                   EQUAL
NH       EQU   13                  NOT HIGH
NL       EQU   11                  NOT LOW
NE       EQU   7                   NOT EQUAL
O        EQU   1                   ONES OR OVERFLOW
P        EQU   2                   POSITIVE
M        EQU   4                   MINUS
Z        EQU   8                   ZERO
NP       EQU   13                  NOT POSITIVE
NM       EQU   11                  NOT MINUS
NZ       EQU   7                   NOT ZERO
NO       EQU   14                  NOT ONES OR NOT OVERFLOW
         SPACE 1
$CHN     EQU   0                   FOR ANY FIELD CHANGED DURING EXECUT
$        EQU   0                   FOR ANY FIELD CHANGED DURING EXECUT
         SPACE 1
$PRGFILC EQU   C'5'                CHAR USED TO FILL UNUSED PROG CORE
$PRGFILR EQU   C'4'                CHAR USED TO FILL USER REGS AT FIRST
         TITLE 'DSECT***X$SLOT*** FORMAT OF AN ENTRY FOR XGET-XPUT MON'
X$SLOT   DSECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*-->DSECT: X$SLOT FORMAT FOR XGET-XPUT MONITOR TABLE                  *
*        USED IN XDDGET AND XDDPUT TO CONTROL USE OF CERTAIN          *
*           DD NAMES BY USER WITH XGET-XPUT PERMITTED.                *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
X$SLNAME DS    CL8                 DDNAME
X$SLFLAG DS    CL1                 FLAG BITS
X$SLWAY  DS    CL1
X$SLLONG EQU   *-X$SLNAME          GET LENGTH OF ENTRY
X$SLOPEN EQU   X'C0'               THESE BITS OFF IF FILE NOT OPEN
X$SLXGET EQU   X'40'               INPUT FILE
X$SLXPUT EQU   X'80'               OUTPUT FILE
X$SLPERM EQU   X'01'               PERMANENT FILE NAME
X$SLCLOS EQU   X'3F'               OPPOSITE OF X$SLOPEN
X$SLPOIN EQU   X'0C'               ON FOR POSSIBLE INPUT OR OUTPUT
X$SLXGPT EQU   X'00'               BITS OFF MEAN USE XGET-XPUT
         TITLE '*** REGISTER EQUATES AND CONVENTIONS ***'
*        *** ABSOLUTE REGISTER EQUATES ***                            *
F0       EQU   0                   FLOATING POINT REGISTER 0          *
F2       EQU   2                   FLOATING POINT REGISTER 2          *
F4       EQU   4                   FLOATING POINT REGISTER 4          *
F6       EQU   6                   FLOATING POINT REGISTER 6          *
         SPACE 1
R0       EQU   0                   SPECIAL WORK REGISTER 0            *
R1       EQU   1                   SPECIAL WORK REGISTER 1            *
R2       EQU   2                   SPECIAL WORK REGISTER 2            *
R3       EQU   3                   GENERAL WORK REGISTER 1            *
R4       EQU   4                   GENERAL WORK REGISTER 2            *
R5       EQU   5                   GENERAL WORK REGISTER 3            *
R6       EQU   6                   GENERAL WORK REGISTER 4            *
R7       EQU   7                   PARAMETER REGISTER 1               *
R8       EQU   8                   PARAMETER REGISTER 2               *
R9       EQU   9                   PARAMETER REGISTER 3               *
R10      EQU   10                  PARAMETER REGISTER 4               *
R11      EQU   11                  PARAMETER REGISTER 5               *
R12      EQU   12                  ASSEMBLER TABLE POINTER-READ ONLY  *
R13      EQU   13                  SAVE AREA POINTER/BASE REG FOR SOME*
R14      EQU   14                  RETURN ADDRESS USED IN CALLS       *
R15      EQU   15                  ENTRY POINT ADDRESS/OFTEN USED BASE*
         SPACE 1
*        *** SYMBOLIC REGISTER EQUATES ***                            *
RW       EQU   R3                  GENERAL WORK REGISTER 1            *
RX       EQU   R4                  GENERAL WORK REGISTER 2            *
RY       EQU   R5                  GENERAL WORK REGISTER 3            *
RZ       EQU   R6                  GENERAL WORK REGISTER 4            *
RA       EQU   R7                  PARAMETER REGISTER 1               *
RB       EQU   R8                  PARAMETER REGISTER 2               *
RC       EQU   R9                  PARAMETER REGISTER 3               *
RD       EQU   R10                 PARAMETER REGISTER 4               *
RE       EQU   R11                 PARAMETER REGISTER 5               *
RAT      EQU   R12                 ASSEMBLER TABLE POINTER-READ ONLY  *
RSA      EQU   R13                 SAVE AREA POINTER/BASE REG FOR SOME*
RET      EQU   R14                 RETURN ADDRESS USED IN CALLS       *
REP      EQU   R15                 ENTRY POINT ADDRESS/OFTEN USED BASE*
         SPACE 1
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        *** REGISTER CONVENTIONS ***                                 *
*        A. REGISTERS R0-R6 ARE PROTECTED ACROSS CALLS.               *
*        B. REGISTER RAT(R12) MAY NOT BE CHANGED BY ANY ROUTINE.      *
*        C.REGISTERS R7-R11 (RA-RE) ARE COMPLETELY UNPROTECTED ACROSS *
*         CALLS, AND MAY BE USED BY ANY ROUTINE .  PARAMATERS WILL    *
*         NORMALLY BE PLACED TO USE FIRST RA, THEN RB, ETC.  IF MORE  *
*         THAN 5 PARAMATERS ARE REQUIRED, REGISTER RE WILL POINT TO   *
*         AN OS TYPE PARAMATER LIST.                                  *
*        D. EXCEPT FOR THE ABOVE, THE CONVENTIONS ARE EXACTLY THE     *
*         SAME AS STANDARD IBM CONVENTIONS WITH REGARD TO LINKAGE,    *
*         SAVE AREA STRUCTURE, REQUIREMENTS, ETC.                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         TITLE '*** ERROR CODE EQUATE SYMBOLS - $ER----- ***'
ALIGN    $SERR 'W-ALIGNMENT ERROR-IMPROPER BOUNDARY',000
ENTRY    $SERR 'W-ENTRY ERROR-CONFLICT OR UNDEFINED',001
EXTRN    $SERR 'W-EXTERNAL NAME ERROR OR CONFLICT',002
RGNUS    $SERR 'W-REGISTER NOT USED',003
ODDRG    $SERR 'W-ODD REGISTER USED-EVEN REQUIRED',004
NOEND    $SERR 'W-END CARD MISSING-SUPPLIED',005
ADDR     $SERR 'ADDRESSIBILITY ERROR',100
CNLNG    $SERR 'CONSTANT TOO LONG',101
CNTYP    $SERR 'ILLEGAL CONSTANT TYPE',102
CONT     $SERR 'CONTINUATION CARD COLS. 1-15 NONBLANK',103
CONTX    $SERR 'MORE THAN 2 CONTINUATION CARDS',104
CXREL    $SERR 'COMPLEX RELOCATABILITY ILLEGAL',105
DCEXT    $SERR 'TOO MANY OPERANDS IN DC',106
DPCSE    $SERR 'MAY NOT RESUME SECTION CODING',107
DUPLF    $SERR 'ILLEGAL DUPLICATION FACTOR',108
EXGTA    $SERR 'EXPRESSION TOO LARGE',109
EXLTA    $SERR 'EXPRESSION TOO SMALL',110
ICNOP    $SERR 'INVALID CNOP OPERAND(S)',111
ILLAB    $SERR 'LABEL NOT ALLOWED',112
ILORG    $SERR 'ORG VALUE IN WRONG SECTION OR TOO LOW',113
INVCN    $SERR 'INVALID CONSTANT',114
INVDM    $SERR 'INVALID DELIMITER',115
INVF     $SERR 'INVALID FIELD',116
INVSY    $SERR 'INVALID SYMBOL',117
IVOPC    $SERR 'INVALID OP-CODE',118
MULDF    $SERR 'PREVIOUSLY DEFINED SYMBOL',119
NEABS    $SERR 'ABSOLUTE EXPRESSION REQUIRED',120
NODLM    $SERR 'MISSING DELIMITER',121
NOIMP    $SERR 'FEATURE NOT CURRENTLY IMPLEMENTED',122
NOOPR    $SERR 'MISSING OPERAND',123
NONAM    $SERR 'LABEL REQUIRED',124
RELOC    $SERR 'RELOCATABLE EXPRESSION REQUIRED',126
SDINV    $SERR 'INVALID SELF-DEFINING TERM',127
START    $SERR 'ILLEGAL START CARD',128
TLIT     $SERR 'ILLEGAL USE OF LITERAL',129
UNDEF    $SERR 'UNDEFINED SYMBOL',130
UNRV     $SERR 'UNRESOLVED EXTERNAL REFERENCE',131
VILCH    $SERR 'ILLEGAL CHARACTER',132
VPARN    $SERR 'TOO MANY PARENTHESIS LEVELS',133
VRELO    $SERR 'RELOCATABLE VALUE USED WITH * OR /',134
VSYNT    $SERR 'SYNTAX',135
VTMTR    $SERR 'TOO MANY TERMS IN EXPRESSION',136
VUNEX    $SERR 'UNEXPECTED END OF EXPRESSION',137
INTPT    $SERR 'STATEMENT CAUSED INTERRUPT',138
         SPACE 1
         AIF   (NOT &$MACROS).SERR1         SKIP IF NO MACROS
ILOPR    $SERR 'OPERAND NOT ALLOWED',201
STMNA    $SERR 'STATEMENT OUT OF ORDER',202
SSDIM    $SERR 'SET SYMBOL DIMENSION ERROR',203
INSBV    $SERR 'INVALID NBR OF SUBSCRIPTS',204
ILCNV    $SERR 'ILLEGAL CONVERSION',205
MISQU    $SERR 'MISSING QUOTES IN CHAR EXPR',206
ILMNM    $SERR 'ILLEGAL OR DUP MACRO NAME',207
MXDMD    $SERR 'OPRND NOT COMPATIBLE WITH OPRTR',208
UNDKW    $SERR 'UNDFND OR DUP KEYWORD',209
EXMAC    $SERR 'MNEST LIMIT EXCEEDED',210
ILAT     $SERR 'ILLEGAL ATTRIBUTE USE',211
MEXST    $SERR 'GENERATED STMT TOO LONG',212
OVRGN    $SERR 'GENERATED STMTS OVERWRITTEN',298
.SERR1   ANOP
         TITLE '*** INSTRUCTION TYPES AND CODES ***'
* * * * * INSTRUCTION TYPES FOR MACHINE INSTRUCTIONS(OPCTYPE FIELD)   *
$IA      EQU   X'00'               (OPCHEX)==> PREFIX FOR MACHINE OPS
$RRM     EQU   2                   RR EXTENDED MNEMONICS -R2
$RXM     EQU   4                   RX EXTENDED MNEMONICS - D2(X2,B2)
$RR      EQU   6                   NORMAL RR - R1,R2
$RX      EQU   8                   NORMAL RX - R1,D2(X2,B2)
$RS      EQU   10                  RS(LM,STM,BXH,BXLE)-R1,R3,D2(B2)
$RSH     EQU   12                  RS(SHIFTS) - R1,D2(B2)
$SI      EQU   14                  SI NORMAL - D1(B1),I2
$SS      EQU   16                  SS-1 LENGTH- D1(L,B1),D2(B2)
$SS2     EQU   18                  SS-2 LENGTHS - D1(L1,B1),D2(L2,B2)
$RSO     EQU   20                  ODD RR-SI'S (SPM,SVC,LPSW,SSM,TS,IO)
$SPC     EQU   22                  SPECIAL(FAKE) INSTRUCTIONS-XREAD,ETC
$ICTMX   EQU   11                  MAXIMUM IC TYPE / 2
         SPACE 1
IAA      EQU   X'10'               (RCMASK) - R1 REQUIRED TO BE EVEN
IAL1     EQU   X'00'               (RCMASK) - LITERAL OK-OP1==>NEVER!
IAL2     EQU   X'08'               (RCMASK) - LITERAL PERMITTED-OP2
IAB      EQU   X'20'               (RCMASK) - R2 REQUIRED TO BE EVEN
         SPACE 1
* * * * * ASSEMBLER INSTRUCTION TYPES - $I------ (OPCTYPE FIELD)  * * *
$IB      EQU   X'C0'               OPCODTB ENTRY TAG BITS FOR AM INST
*              *NOTE* SECTIONS MO, MT DEPEND ON $IB HAVING THIS VALUE *
$IUSING  EQU   2                   USING INSTRUCTION
$IDROP   EQU   4                   DROP INSTRUCTION
$ISTART  EQU   6                   START INSTRUCTION
$ICSECT  EQU   8                   CSECT INSTRUCTION
$IDSECT  EQU   10                  DSECT INSTRUCTION
$IENTRY  EQU   12                  ENTRY INSTRUCTION
$IEXTRN  EQU   14                  EXTRN INSTRUCTION
$IEQU    EQU   16                  EQU INSTRUCTION
$IDC     EQU   18                  DC INSTRUCTION
$IDS     EQU   20                  DS INSTRUCTION
$ICCW    EQU   22                  CCW INSTRUCTION
$ITITLE  EQU   24                  TITLE INSTRUCTION
$IEJECT  EQU   26                  EJECT INSTRUCTION
$ISPACE  EQU   28                  SPACE INSTRUCTION
$IPRINT  EQU   30                  PRINT INSTRUCTION
$IORG    EQU   32                  ORG INSTRUCTION
$ILTORG  EQU   34                  LTORG INSTRUCTION
$ICNOP   EQU   36                  CNOP INSTRUCTION
$IEND    EQU   38                  END INSTRUCTION
$IDEBUG  EQU   40                  DEBUG FLAG SETTING ROUTINE
         SPACE 1
IBNONAM  EQU   X'40'               (OPCHEX)==> LABEL NOT PERMITTED
IBNENAM  EQU   X'20'               (OPCHEX)==> LABEL IS REQUIRED
IBOMOP   EQU   X'10'               (OPCHEX)==> OPERAND MAY BE OMITTED
IBMOSPEC EQU   X'08'               (OPCHEX,RCHEX)==> REQUIRES SPECIAL
*              HANDLING OF SOME KIND IN MOCON1 (END, ALL PRINT CTRL).
IBMOPRCT EQU   X'04'               (OPCHEX,RCHEX)==> IS SOME KIND OF
*              PRINT CNTRL, SO REQUIRES SPEC HANDLING BY MOCON1.
IBMOPRCX EQU   IBMOSPEC+IBMOPRCT   (OPCHEX,RCHEX)==> PRT CNTRL
         TITLE '*** MISCELLANEOUS EQUATE SYMBOLS ***'
$ESDSECT EQU   1                   (AVCESDID)-IN DSECT, EVEN=>CSECT
$IS      EQU   X'40'               OPCTYPE CODE FOR SPECIALS
$IM      EQU   X'80'               OPCTYPE CODE FOR MACROS
         SPACE 1
$IBPON   EQU   X'80'               (AVPRINT,AVPRINT1)-PRINT ON
$IBPGEN  EQU   X'40'               (AVPRINT,AVPRINT1)- PRINT GEN
$IBPDAT  EQU   X'20'               (AVPRINT,AVPRINT1)- PRINT DATA
*                                  PRINT DATA, NODATA ONLY FOR COMPATIB
$IBPLIST EQU   X'02'               (AVPRINT)==> LIST IS ON
         SPACE 1
$IBSTAR1 EQU   X'80'               (AVTAGS1)==> START NO LONGER ALLOWED
$IBDSEC1 EQU   X'40'               (AVTAGS1)==> PROCESSING DSECT NOW
*              IF THIS FLAG IS NOT SET, CURRENT SECTION IS A CSECT.   *
$IBPRCD1 EQU   X'20'               (AVTAGS1) - PRIVATE CODE HAS OCCURRD
         SPACE 1
$INEND2  EQU   B'10000000'         (AVTAGS2)==> ENDFILE ON SYSIN-INCARD
         SPACE 1
$OUMACH  EQU   0                   CODE FOR MACHINE INSTRUCTIONS
$OUCONS  EQU   2                   CODE FOR CONSTANTS
$OULIST  EQU   4                   LISTING CONTROL INSTRUCTONS
$OUCOMM  EQU   6                   COMMENTS,ETC WITHOUT LOCATION COUNTE
         AIF   (NOT &$MACROS).NOMMMMM  SKIP IF NO MACROS
* * * * * * * * EQUATES FOR MACRO-TYPE OPCODES* * * * * * * * * * * * *
         SPACE 2
$MACRO   EQU   2                   MACRO DECLARATION
$GBLA    EQU   4                   GLOBAL ARITHMETIC DECLARATION
$GBLB    EQU   6                   GLOBAL BINARY DECLARATION
$GBLC    EQU   8                   GLOBAL CHARACTER DECLARATION
$LCLA    EQU   10                  LOCAL ARITHMETIC DECLARATION
$LCLB    EQU   12                  LOCAL BINARY DECLARATION
$LCLC    EQU   14                  LOCAL CHARACTER DECLARATION
$ACTR    EQU   16                  ACTR INSTRUCTION
$SETA    EQU   18                  SET ARITHMETIC INSTRUCTION
$SETB    EQU   20                  SET BINARY INSTRUCTION
$SETC    EQU   22                  SET CHARACTER INSTRUCTION
$AIF     EQU   24                  AIF INSTRUCTION
$AGO     EQU   26                  AGO INSTRUCTION
$ANOP    EQU   28                  ANOP INSTRUCTION
$MNOTE   EQU   30                  MNOTE INSTRUCTION
$MEXIT   EQU   32                  MEXIT INSTRUCTION
$MEND    EQU   34                  MEND INST
         SPACE 1
$ARITH   EQU   4                   ARITHMETIC VLAUE
$BOOL    EQU   8                   LOGICAL VALUE
$CHAR    EQU   12                  CHARACTER VALUE
.NOMMMMM ANOP
         SPACE 1
         TITLE '*** ICBLOCK - MACHINE INSTRUCTION CODE BLOCK ***'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: ICBLOCK    MACHINE INSTRUCTION OBJECT CODE BLOCK.         *
*        THIS DSECT IS USED TO TRANSMIT DATA FROM ICMOP2 CSECT TO     *
*        OUTPT2 FOR PRINTING MACHINE INSTRUCTIONS.                    *
*        LOCATION: TABLE ICYBLOCK IN CSECT ICMOP2 OF ASSEMBLER.       *
*        NAMES: ICB-----                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
ICBLOCK  DSECT
$ICBEA1  EQU   X'40'               (ICBFLAG) ==> EA1 EXISTS
$ICBEA2  EQU   X'20'               (ICBFLAG) ==> EA2 EXISTS
         SPACE 1
ICBEA1   DS    F                   1ST ADDRESS
ICBEA2   DS    F                   2ND ADDRESS
ICBOPR1R DS    0H                  OPCODE - R1 - R2
ICBOP    DS    C                   HEX OPCODE
ICBR1R2  DS    C                   REGISTERS OR LENGTHS OR IMMED.FIELD
ICBOPN1  DS    H                   1ST BASE DISPLACEMENT IN INSTRUCTION
ICBOPN2  DS    H                   2ND BASE DISPLACEMENT IN INSTRUCTION
ICBFLAG  DS    C                   FLAG BYTE FOR EXISTENCE OF EAU,EA2
         TITLE '*** SYMSECT DSECT - SYMBOL TABLE ENTRIES ***'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: SYMSECT    ASSEMBLER SYMBOL TABLE ENTRY.                  *
*        CREATED BY ENTRY SYENT1 OF CSECT SYMOPS, AND HAS VALUES ADDED*
*        BY MOCON1,IBASM1, FOR VALUE, SECTION ID, LENGTH ATTRIBUTE,   *
*        AND BY ESDOPRS FOR SPECIAL ATTRIBUTES(CSECT,ETC).            *
*        LOCATION:  FREEAREA HIGH END ($ALLOCH'D).                    *
*        NAMES: SY------                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
SYMSECT  DSECT
$SYDEF   EQU   X'80'               (SYFLAGS) - SYMBOL HAS BEEN DEFINED
$SYENT   EQU   X'40'               (SYFLAGS) - DECLARED AN ENTRY
$SYCSE   EQU   X'20'               (SYFLAGS) - DECLARED A CSECT
$SYDSE   EQU   X'10'               (SYFLAGS) - DECLARED A DSECT
$SYEXT   EQU   X'08'               (SYFLAGS) - DECLARED EXTRN
$SYXRMD  EQU   X'02'               (SYFLAGS) - XREF HAS MODIFY REFERS A
$SYXRFT  EQU   X'01'               (SYFLAGS) - XREF HAS FETCH REF     A
         SPACE 1
SYLINK   DS    0F                  ADDRESS OF NEXT SYMBOL IN CHAIN
SYHASH2  DS    C                   SECONDARY HASH CODE OF NEXT SYMBOL
SYLINKA  DS    CL3                 ADDRESS REFERRED TO BY SYLINK
SYVALUE  DS    F                   VALUE OF THE SYMBOL
SYESDID  DS    C                   ESDID OF THE SYMBOL
SYLENG   DS    C                   LENGTH ATTRIBUTE OF THE SYMBOL
SYFLAGS  DS    C                   FLAG BYTE
SYCHARS  DS    C                   #-1 OF BYTES IN SYMBOL (RANGE:0-7)
SYMBOL   DS    CL8                4-8 CHARS OF SYMBOL,R-PADDED WITH BLK
         TITLE '*** CNCBLOCK DSECT - CONSTANT CODE BLOCK ***'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: CNCBLOCK   CONSTANT CODE BLOCK-DC'S, LITERALS.            *
*        LOCATION: EACH CNCBLOCK IS CREATED IN AREA COBLK OF CODTL1.  *
*        1 OR MORE CNCBLOCKS MAY BECOME PART OF THE RCODBLK CREATED   *
*        IN AREA IBRCB BY IBASM1, AND 1 CNCBLOCK BECOMES PART OF THE  *
*        ENTRY FOR EACH DISTINCT LITERAL(SEE LTLENTRY DSECT, LTOPRS   *
*        CSECT.)                                                      *
*        NAMES: CNC-----                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
CNCBLOCK DSECT
* * * * * CONSTANT TYPE,DESCRIPTOR CODES-USED IN CNCBLOCK AREAS * * * *
$CNA     EQU   0                   A-TYPE CONSTANT TYPE CODE
$CNB     EQU   1                   B-TYPE CONSTANT TYPE CODE
$CNC     EQU   2                   C-TYPE CONSTANT TYPE CODE
$CND     EQU   3                   D-TYPE CONSTANT TYPE CODE
$CNE     EQU   4                   E-TYPE CONSTANT TYPE CODE
$CNF     EQU   5                   F-TYPE CONSTANT TYPE CODE
$CNH     EQU   6                   H-TYPE CONSTANT TYPE CODE
$CNP     EQU   7                   P-TYPE CONSTANT TYPE CODE
$CNV     EQU   8                   V-TYPE CONSTANT TYPE CODE
$CNX     EQU   9                   X-TYPE CONSTANT TYPE CODE
$CNZ     EQU   10                  Z-TYPE CONSTANT TYPE CODE
$CNT$N   EQU   11                  1 MORE THAN MAX $CN# CODE=# TYPES
$CNALN   EQU   X'80'               (CNCTYP)==> ALIGNMENT REQUIRED
$CNVLN   EQU   X'40'               (CNCTYP)==> VARIABLE LENGTH (LIKE C)
$CNMUL   EQU   X'20'               (CNCTYP)==> MULTIPLE CONSTANTS OK
$CNERR   EQU   X'10'               (CNCTYP)==> RB HAS ERR CODE-PASS 2
         SPACE 1
CNCTYP   DS    C                   FLAGS AND TYPE CODE
CNCLEN   DS    C                   LENGTH-1 OF CONSTANT
CNCSCAN  DS    C                   SCAN POINTER TO 1ST CHAR OF 1ST CONS
CNCNUM   DS    C                   NUMBER OF CONSTANTS IN OPERAND
CNCDUP   DS    H                   DUPLICATION FACTOR
CNCTOT   DS    H                   TOTAL LENGTH OF OPERAND(<=65K)
CNC$LEN  EQU   *-CNCBLOCK          LENGTH OF CONSTANT CODE BLOCK
         TITLE '*** RECORD BLOCKS - RCODBLK, REBLK ***'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: RCODBLK    RECORD CODE BLOCK - VARIABLE DATA FOR STMT.    *
*        AN RCODBLK IS CREATED BY EITHER IAMOP1 OR IBASM1 DURING      *
*        ASSEMBLER PASS 1 FOR EVERY STATEMENT WITH AN ACCEPTABLE      *
*        OPERATION CODE.  IT CONTAINS VARIABLE INFORMATION WHICH      *
*        DEPENDS ON THE TYPE OF INSTRUCTION, AND MAY INCLUDE HEX      *
*        MACHINE CODES AND MASKS, ALIGNMENT INFORMATION, LITERAL      *
*        ADDRESSES, EQU SYMBOL ADDRESSES, AND 1 -10 CNCBLOCKS FOR DC  *
*        COMMANDS.  THE MOST COMMON LENGTHS ARE 8 AND 12.             *
*        LOCATION: CREATED IN AREA IARCB(IN IAMOP1) OR IBRCB(IN       *
*        IBASM1). STORED IN LOW AREA AFTER ITS RSBLOCK BY UTPUT1.     *
*        FOR MACHINE INSTRUCTIONS, MOVED TO ICRCB(IN ICMOP2) IN PASS 2*
*        NAMES: RC------                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
RCODBLK  DSECT
RCLENG   DS    C                   LENGTH OF RCB
RCLOC    DS    AL3                 LOCATION COUNTER VALUE
RCTYPE   DS    C                   PRIMARY INSTRUCTION TYPE
RCHEX    DS    C                   HEX CODE FOR MACH OPS, 2ND CODE OTHR
RCMASK   DS    C                   MASK-ALIGNMENT FOR MACH OPS
RCLQ     DS    C                   SLOT FOR LENGTH ATTRIBUTE L'*
RC$LEN   EQU   *-RCODBLK-1         NORMAL LENGTH,WITHOUT LITERAL/EQU
RCLITEQ  DS    A                   LITERAL/EQU ADDRESS
RC$LEN2  EQU   *-RCODBLK-1         LENGTH-1 INCLUDING EQU OR LITERAL
         SPACE 2
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: REBLK      SCAN POINTER/ERROR CODE PAIR BLOCK.            *
*        LOCATION: AVREBLK(AVWXTABL DSECT), CREATED BY ERRTAG SUBR.   *
*        MOVED INTO LOW AREA FOLLOWING CORRESPONDING RCODBLK. MOVED   *
*        BY UTGET2 BACK INTO AVREBLK AREA IN AVWXTABL DURING PASS 2.  *
*        *NOTE* ONLY EXISTS FOR STATEMENTS HAVING 1 OR MORE ERROR OR  *
*        WARNING MESSAGES ATTACHED TO IT.                             *
*        NAMES: REB-----                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
REBLK    DSECT
REBLN    DS    C                   LENGTH-1 OF ERROR BLOCK
$ERREBMX EQU   4                   MAX # ERROR MESSAGES KEPT PER STMT
*              THERE IS 1 REBLN, UP TO $ERREBMX REBSCN-REBERR PAIRS.
REBSCN   DS    C                   SCAN OFFSET POINTER TO ERROR
REBERR   DS    C                   ERROR CODE
         TITLE '*** RECORD BLOCKS - RSBLOCK,RSCBLK,RSOURCE ***'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: RSBLOCK    RECORD SOURCE BLOCK-SOURCE CODE, FLAGS.        *
*        AN RSBLOCK IS CREATED FOR EVERY SOURCE STATEMENT BY INCARD   *
*        AND CONTAINS DATA COMMON TO EVERY STATEMENT, SUCH AS 1-3     *
*        SOURCE CARD IMAGES, FLAGS FOR EXISTENCE OF OTHER RECORD      *
*        BLOCKS.  ONLY RECORD BLOCK NECESSARY FOR A SOURCE STATEMENT. *
*        LOCATION: CREATED IN AVRSBLOC (AVWXTABL DSECT) BY INCARD,    *
*        WITH MODIFICATION BY ERRTAG AND MOCON1. MOVED TO LOW  END    *
*        OF FREEAREA BY UTPUT1, AND REMAINS THERE.                    *
*        NAMES: RSB-----                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
RSBLOCK  DSECT
$RSMXCRD EQU   3                   MAXIMUM # OF CARDS IN 1 STATEMENT
$RCBX    EQU   X'80'               (RSBFLAG)==>RECORD CODE BLOCK EXISTS
$REBX    EQU   X'40'               (RSBFLAG)==>RECORD ERROR BLOCK EXIST
$RSCX    EQU   X'20'               (RSBFLAG)==>RECORD SOURCE CODE BLOCK
*              FOLLOWING MAINLY INVOLVED WITH MACRO PROC.
$RSBGENR EQU   X'08'               (RSBFLAG)==> GENERATED STMT
*              I.E., SHOULD BE PRINTED WITH + BEFORE STMT.
$RSBNP## EQU   X'04'               (RSBFLAG)==> DO NOT PROCESS FURTHER,
*              EXCEPT TO PRINT.  HAS STMT #. (COMMENTS, OUTER MACROS).
$RSBNPNN EQU   X'02'               (RSBFLAG)==> DO NOT PROCESS FURTHER,
*              EXCEPT PRINT.  NO STMT #.  (INNER MACROS, SPEC ERRORS).
$RSBMERR EQU   X'01'               (RSBFLAG)==> ERROR RECORD, GIVEN
*              SPECIAL TREATMENT IN OUTPT2, COUNTS AS ERROR.  NOTE:
*              IF THIS FLAG ON, $RSBNPNN SHOULD BE ALSO.
         SPACE 1
RSBLENG  DS    C                   LENGTH-1 OF THIS RSB(0-216)
RSBFLAG  DS    C                   FLAG BITS FOR THIS RSB
RSBNUM   DS    C                   NUMBER OF CARDS USED IN RSB
RSBSCAN  DS    C                   SCAN POINTER OFFSET TO OPERAND FLD
RSB$L    EQU   *-RSBLOCK           LENGTH OF STANDARD PART OF RSBLOCK
RSBSOURC DS    0CL71               SPACE FOR 3 CARD IMAGES
RSBLOPC  DS    CL71                1ST CARD IMAGE
RSB$LN1  EQU   *-RSBLOCK-1         LENGTH-1 DEFAULT VALUE
         DS    2CL71               0-2 MORE CARD IMAGES
         SPACE 2
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: RSCBLK     RECORD SOURCE-CONTINUATIONS, SEQUENCE #'S      *
*        CREATED BY INCARD FOR ANY STATEMENT HAVING EITHER SEQUENCE   *
*        NUMBERS OR CONTINUATION PUNCHES.                             *
*        LOCATION: CREATED BY INCARD IN AVRSCBLK(AVWXTABL) DURING     *
*        ASSEMBLY PASS 1. MOVED TO LOW END OF DYNAMIC AREA BY UTPUT1, *
*        FOLLOWING CORRESPONDING REBLK(IF ONE EXISTS).  REMAINS IN    *
*        THAT AREA FOR REST OF PROCESSING.                            *
*        NAMES: RSC-----                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
RSCBLK   DSECT
RSCLENG  DS    C                   LENGTH-1 OF THIS RSCBLK
* * * * * THE PREVIOUS ENTRIES ARE FIXED,THERE MAY BE UP TO 3 OF REST *
RSCILEN  DS    C                   LENGTH OF INDIVIDUAL CARD IMAGE
RSCONSQ  DS    CL9                 CONTINUATION-SEQUENCE NUMBER COLUMNS
RSC$LEN  EQU   *-RSCILEN           LENGTH OF 1 ENTRY OF VARIABLE PART
         SPACE 2
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: RSOURCE    DESCRIPTION OF A SINGLE SOURCE CARD            *
*        USED FOR INPUT PROCESSING BY SUBROUTINE INCARD.              *
*        LOCATION: AVRSBLOC(AVWXTABL) DURING CREATION OF RSBLOCK.     *
*        NAMES: RSO-----                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
RSOURCE  DSECT
RSOLOPC  DS    CL15                LABEL+OPCODE,NORMAL
RSOOPRCM DS    CL56                OPERAND+COMMENTS FIELD
RSOL1    EQU   *-RSOLOPC           LENGTH OF 1ST OR ONLY SOURCE CARD
RSOLC    EQU   *-RSOOPRCM          LENGTH OF SOURCE CONTINUATION CARD
RSOCONT  DS    C                   CONTINUATION COLUMN
RSOSEQN  DS    CL8                 SEQUENCE NUMBERS,IF ANY
         AIF   (NOT &$MACROS).AVNMCCC           SKIP IF NO MACROS
         TITLE 'MACLIB DSECT AND EQUS'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT:  MACLIB   THIS DSECT GIVES THE FORMAT OF A MACRO          *
*         LIBRARY ENTRY.                                              *
*        NOTE: THIS IS ONLY MACRO DSECT NEEDED OUTSIDE MACRO PROCESSOR*
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE
MACLIB   DSECT
MCLIBNXT DS    F                   POINTER TO NEXT ENTRY
MCLBNMLN DS    C                   LENGTH OF MACRO LIB ENTRY NAME
MCLBNAM  DS    CL8                 MACRO LIBRARY ENTRY NAME
MCLBFLGS DS    0C                  MACRO LIBRARY ENTRY FLAGS
MCLBTAGS DS    C                   MACLIB ENTRY FLAG BYTE
MCLBFLG2 DS    C                   MACRO LIBRARY ENTRY FLAGS
MCLBFLG3 DS    C                   MACRO LIBRARY ENTRY FLAGS
MCPOPRNB DS    H                   NUMBER OF OPERANDS (NOT LABEL FLD)
MCKOPRNB DS    H                   NUMBER OF KEYWORD OPERANDS
MCDDVPNT DS    F                   LINK TO LOCAL DICT DOPE VECTORS
MCLOCDLN DS    F                   LENGTH OF LOCAL DICTIONARY
MCLDNBRE DS    F                   # OF LOCAL DICT. ENTRIES
MCPARPNT DS    F                   POINTER TO PARAMETER DOPE VECTORS
MCCODLNK DS    F                   POINTER TO DEFINITION CODE
$LMACLIB EQU   *-MACLIB            LENGTH OF MACLIB ENTRY
         SPACE 5                                                      S
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: MSGBLOCK        ERROR MESSAGE BLOCK                       *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
MSGBLOCK DSECT                                                        S
MSGLENM1 DS    AL1                 L-1 OF NUMBR+MSG                   S
MSGFLAG  DS    AL1                 MISC FLAG BYTE                     S
MSGNMBR  DS    CL3                 ERROR #                            S
MSGMSG   DS    0C                  VARYING LEN MSG                    S
         SPACE 5                                                      S
AVMCLBDF EQU   X'80'               MCLBTAGS - MACRO DEFINED FLAG
AVMCLBNF EQU   X'40'               MCLBTAGS - MACRO SEARCHED FOR/LIBRY
.AVNMCCC ANOP
         TITLE '*** AVWXTABL DSECT - MAIN ASSEMBLER TABLE ***'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: AVWXTABL   MAIN CONTROL TABLE FOR THE ASSEMBLER.          *
*        THIS DSECT IS USED BY ALMOST ALL SUBROUTINES OF THE ASSEMBLER*
*        FOR COMMUNICATION, COMMON CONSTANTS, AND WORKAREAS, AND IS   *
*        ALSO USED SOMEWHAT BY THE MAIN PROGRAM ASSIST AND THE        *
*        REPLACE MONITOR REMONI.                                      *
*        LOCATION: CSECT VWXTABL, WITH SAME NAMES PREFIXED WITH 'A'.  *
*        NAMES: AX------,AW------,AV------  (DEPENDS ON SECTION)      *
*        THIS DSECT CONTAINS THE FOLLOWING SECTIONS:                  *
*                                                                     *
*              1. ADDRESS CONSTANTS(NAMES: AX, FOLLOWED BY ENTRY NAME)*
*        THIS SECTION CONTAINS 1 ADDRESS CONSTANT FOR EVERY CALLABLE  *
*        ENTRY POINT IN THE ASSIST ASSEMBLER.  THESE ARE READ-ONLY,   *
*        EXCEPT DURING A REPLACE RUN, IN WHICH THE ADCONS FOR A       *
*        SINGLE CSECT ARE TEMPORARILY MODIFIED.  THE LABEL AX$BASE IS *
*        USED AS A BASE ADDRESS FOR THE CALCULATION OF OFFSETS TO     *
*        INDIVIDUAL ADCONS, FOR THOSE ROUTINES REQUIRING TABLE-DRIVEN *
*        CALLING SEQUENCES (CNDTL2,CODTL1,MPCON0,REMONI).  NOTE THAT  *
*        ALL ENTRY POINTS HAVE 6-CHARACTER NAMES.  THE MACRO $CALL    *
*        IS USED IN CONJUNCTION WITH THIS PART OF AVWXTABL.           *
*                                                                     *
*              2. CONSTANT VALUES (NAMES: AW------)                   *
*        THIS SECTION CONTAINS USEFUL CONSTANT VALUES, SUCH AS        *
*        ZEROES, BLANKS, MASK VALUES, TRANSLATE TABLES, EDIT PATTERNS.*
*        ALL VALUES ARE READ-ONLY, EXCEPT THAT ANY ROUTINE MAY        *
*        MODIFY PART OF THIS SECTION IF IT RESTORES IT BEFORE         *
*        ALLOWING ANOTHER SUBROUTINE TO GAIN CONTROL.  TRANSLATE      *
*        TABLES INCLUDE ONES FOR SCANNING DECIMAL NUMBERS AND MACHINE *
*        INPUT CONVERSION - HEX TO BINARY, SCANNING SYMBOLS AND       *
*        INSTRUCTION OPERANDS, SCANNING HEXADECIMAL CONSTANTS, DOING  *
*        GENERAL EXPRESSIONS, CONVERTING BINARY TO OUPUT HEXADECIMAL. *
*        GENERATION: SECTION AWCONADS IS CREATED BY MACRO WCONG.      *
*                                                                     *
*              3. VARIABLES (NAMES: AV------)                         *
*        THIS SECTION CONTAINS ALL VARIABLE AREAS USED FOR            *
*        COMMUNICATION INSIDE THE ASSIST ASSEMBLER, IN ADDITION TO    *
*        VARIOUS WORKAREAS, WHICH MAY BE OVERLAPPED TO SAVE SPACE.    *
*        THE AREAS PROVIDED INCLUDE THE RECORD BLOCKS, LOCATION       *
*        COUNTER VALUES, CURRENT SECTION ID, CURRENT DYNAMIC STORAGE  *
*        AREA LIMITS, AND VARIOUS FLAGS.  TEMPORARY WORKAREAS ARE     *
*        SUPPLIED, ALL WITH 'WORK' INCLUDED IN THEIR NAMES, WHICH     *
*        CAN BE USED BY ANY ROUTINE , BUT ARE NOT SAFE ACROSS A       *
*        SUBROUTINE CALL.  NOTE THAT THIS SECTION REQUIRES EQU SYMBOLS*
*        FROM CNCBLOCK AND THE RECORD BLOCKS TO ASSEMBLE CORRECTLY.   *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         EJECT
AVWXTABL DSECT
         SPACE 1
* * * * * NAMES IN AVWXTABL DSECT ARE SAME, EXCEPT WITH A'S PREFIXED  *
* * * * * AVWXTABL SECTION X - ADDRESS CONSTANTS  * * * * * * * * * * *
AX$BASE  DS    0A                  BASE ADDRESS FOR OFFSETS TO ROUTINES
*              *** BROPS2 ENTRY POINTS ***                            *
AXBRINIT DS    V(BRINIT)           BASE-REG INITIALIZATION
AXBRUSIN DS    V(BRUSIN)           BASE-REG SET UP USING VALUE
AXBRDROP DS    V(BRDROP)           BASE REG DROP A REGISTER
AXBRDISP DS    V(BRDISP)           BASE REG GET BASE-DISPLACEMENT
AXC$BASE DS    0F                  BASE ADDRESS FOR CONSTANT ADDR OFFSE
*              *** CACONS ENTRY POINTS ***                            *
AXCACON1 DS    V(CACON1)           SCAN A-TYPE CONST
AXCACON2 DS    V(CACON2)           ASSEMBLE A-TYPE CONSTANT
*              *** CBCONS ENTRY POINTS ***                            *
AXCBCON1 DS    V(CBCON1)           SCAN BINARY CONSTANT
AXCBCON2 DS    V(CBCON2)           ASSEMBLE BINARY CONSTANT
*              *** CCCONS ENTRY POINTS ***                            *
AXCCCON1 DS    V(CCCON1)           SCAN CHARACTER CONSTANT
AXCCCON2 DS    V(CCCON2)           ASSEMBLE CHARACTER CONSTANT
*              *** CDECNS ENTRY POINTS ***                            *
AXCDECN1 DS    V(CDECN1)           SCAN FLOATING PT CONST
AXCDECN2 DS    V(CDECN2)           ASSEMBLE FLOATING PT CONSTANT
AXCDCON1 EQU   AXCDECN1            MAKE EQUATE FOR STANDARD NAMES
AXCECON1 EQU   AXCDECN1            MAKE EQUATE FOR STANDARD NAMES
*              *** CFHCNS ENTRY POINTS ***                            *
AXCFHCN1 DS    V(CFHCN1)           SCAN FIXED POINT CONSTANT
AXCFHCN2 DS    V(CFHCN2)           ASSEMBLE FIXED POINT CONSTANT
AXCFCON1 EQU   AXCFHCN1            MAKE EQUATE FOR STANDARD NAMES
AXCHCON1 EQU   AXCFHCN1            MAKE EQUATE FOR STANDARD NAMES
*              *** CONSTANT PROCESSOR CONTROL ROUTINES ***            *
AXCNDTL2 DS    V(CNDTL2)           PASS 2 CONSTANT PROCESSING
AXCODTL1 DS    V(CODTL1)           DUPLICATION FACTOR-TYPE-LENGTH PROC
*              *** CPCONS ENTRY POINTS ***                            *
AXCPCON1 DS    V(CPCON1)           SCAN PACKED CONSTANT
AXCPCON2 DS    V(CPCON2)           ASSEMBLE PACKED CONSTANT
*              *** CVCONS ENTRY POINTS ***                            *
AXCVCON1 DS    V(CVCON1)           SCAN V-TYPE CONSTANTS
AXCVCON2 DS    V(CVCON2)           ASSEMBLE V-TYPE ADDRESS CONSTANTS
*              *** CXCONS ENTRY POINTS ***                            *
AXCXCON1 DS    V(CXCON1)           SCAN HEXADECIMAL CONSTANTS
AXCXCON2 DS    V(CXCON2)           ASSEMBLE HEXADECIMAL CONSTANTS
*              *** CZCONS ENTRY POINTS ***                            *
AXCZCON1 DS    V(CZCON1)           SCAN ZONED CONSTANTS
AXCZCON2 DS    V(CZCON2)           ASSEMBLE ZONED CONSTANTS
*              *** ERRORS ENTRY POINTS ***                            *
AXERRTAG DS    V(ERRTAG)           FLAG ERROR
AXERRLAB DS    V(ERRLAB)           ERROR FLAG FOR A LABEL
*              *** ESDOPRS ENTRY POINTS ***                           *
AXESINT1 DS    V(ESINT1)           ESD ROUTINE INITIALIZATION
AXESCSEC DS    V(ESCSEC)           CSECT,START, OR DSECT
AXESENX1 DS    V(ESENX1)           ENTRY OR EXTRN - PASS 1
AXESENX2 DS    V(ESENX2)           PASS 2 ENTRY AND EXTRN
*              *** EVALUT - EXPRESSION EVALUATOR ***                  *
AXEVALUT DS    V(EVALUT)           GENERAL EXPRESSION EVALUATION ROUT
*              *** 2ND LEVEL PROCESSOR CSECTS ***                     *
AXIAMOP1 DS    V(IAMOP1)           MACHINE OPCODES-PASS 1
AXIBASM1 DS    V(IBASM1)           ASSEMBLER OPCODES - PASS 1
AXICMOP2 DS    V(ICMOP2)           MACHINE OPCODES - PASS 2
AXIDASM2 DS    V(IDASM2)           ASSEMBLER OPCODES - PASS 2
*              *** INPUT1 ENTRY POINTS ***                            *
AXINCARD DS    V(INCARD)           INPUT CARD PROCESSOR
*              *** LTOPRS ENTRY POINTS ***                            *
AXLTINT1 DS    V(LTINT1)           LITERAL TABLE INITIALIZATION
AXLTENT1 DS    V(LTENT1)           ENTER A LITERAL INTO POOL
AXLTDMP1 DS    V(LTDMP1)           RETURN LITERAL LENGTH-PASS 1
AXLTEND1 DS    V(LTEND1)           END PASS 1 FOR LITERAL TABLE
AXLTGET2 DS    V(LTGET2)           GET ADDRESS OF LITERAL
AXLTDMP2 DS    V(LTDMP2)           PRODUCE LITERAL RECORDS-PASS 2
         AIF   (NOT &$MACROS).AXNOMAC       SKIP IF NO MACROS
*              ** MACROS ENTRY POINTS **                              *
AXMACINT DS    V(MACINT)           MACRO INITIALIZATION ENTRY
AXMACRO1 DS    V(MACRO1)           BUILD MACRO DEFINITION TABLES
AXMEXPND DS    V(MEXPND)           MACRO EXPANSION ENTRY
AXMCBODY DS    V(MCBODY)           PROCESS MACRO DEFINITION BODY
AXMACSCN DS    V(MACSCN)           SCAN MACRO STATEMENT
AXMACFND DS    V(MACFND)           SEARCH MACRO LIBRARY
AXMCVSCN DS    V(MCVSCN)           SCAN VARIABLE SYMBOL
AXMCSCOP DS    V(MCSCOP)           SCAN STANDARD OPERAND
AXMCGTST DS    V(MCGTST)           MOVE STRING TO LOW CORE
AXMCSYSR DS    V(MCSYSR)           SEARCH MACRO LIBRARIES FOR VAR SYMBL
AXMACLEX DS    V(MACLEX)           MACRO STMT LEX ANALYSIS
AXMCGNCD DS    V(MCGNCD)           MACRO DEFINITION CODE GENERATION
AXMXMVSR DS    V(MXMVSR)           MOVE GENERATED STMT TO HIGH CORE
AXMXERRM DS    V(MXERRM)           GENERATE ERROR MESSAGE
AXMCDTRM DS    V(MCDTRM)           CHAR TO BINARY CONVERSION
AXMCATRM DS    V(MCATRM)           TEST FOR ATTRIBUTE
         DS    2V                  SPACE FOR MACRO ENTRY POINTS
.AXNOMAC ANOP
*              ***  MAIN PROGRAMS - PASS 1&2 ***                      *
AXMOCON1 DS    V(MOCON1)           MAIN CONTROL - PASS 1
AXMOSTOP DS    V(MOSTOP)           DISASTER EXIT-PASS 1
AXMTCON2 DS    V(MTCON2)           MAIN CONTROL - PASS 2
*              *** OPCOD1 ENTRY POINTS ***                            *
AXOPINIT DS    V(OPINIT)           INITIALIZATION,IF ANY
AXOPFIND DS    V(OPFIND)           LOOKUP OPCODE
*              *** OUTPUT ENTRY POINTS ***                            *
AXOUINT1 DS    V(OUINT1)           INITIALIZATION ENTRY FOR OUTPUT
AXOUTPT2 DS    V(OUTPT2)           OUTPUT LINE PRINTER
AXOUEND2 DS    V(OUEND2)           FINISH UP LAST PRINTING
*              *** SCANRS ENTRY POINTS ***                            *
AXSCANBL DS    V(SCANBL)           SCAN TO FIRST BLANK OUTSIDE OF C'
AXSCANCO DS    V(SCANCO)           SCAN TO COMMA OR BLANK
AXSCANEQ DS    V(SCANEQ)           SCAN TO = OR BLANK
*              *** SDTERM ENTRY POINTS ***                            *
AXSDBCDX DS    V(SDBCDX)           SELF DEFINING TERM-ALL 4 KINDS     *
AXSDBTRM DS    V(SDBTRM)           BINARY SELF-DEFINING TERM
AXSDCTRM DS    V(SDCTRM)           CHARACTER SELF-DEFINING TERM
AXSDDTRM DS    V(SDDTRM)           DECIMAL SELF-DEFINING TERM
AXSDXTRM DS    V(SDXTRM)           HEXADECIMAL SLEF-DEFINING TERM
*              *** SYMOPS ENTRY POINTS ***                            *
AXSYINT1 DS    V(SYINT1)           SYMBOL TABLE INITIALIZATION
AXSYENT1 DS    V(SYENT1)           ENTER A SYMBOL INTO SYMBOL TABLE
AXSYFIND DS    V(SYFIND)           LOOK UP A SYMBOL IN SYMBOL TABLE
AXSYEND2 DS    V(SYEND2)           CLEANUP/STATISTICS AT END OF SYM TAB
*              *** UTOPRS ENTRY POINTS ***                            *
AXUTINT1 DS    V(UTINT1)           UTILITIES INITIALIZATION
AXUTPUT1 DS    V(UTPUT1)           PASS 1 OUTPUT OF EXPANDED RECORDS
AXUTEND1 DS    V(UTEND1)           END PASS 1-INIT FOR PASS 2
AXUTGET2 DS    V(UTGET2)           GET ADDR'S OF EXPANDED RECRDS-PASS 2
AXUTPUT2 DS    V(UTPUT2)           OBJECT CODE CREATION-PASS 2
AXUTEND2 DS    V(UTEND2)           FINISH UP PASS 2
         AIF   (NOT &$XREF).NOXREF2  SKIP IF NO CROSS REFERENCE       A
*    CROSS REFERENCE ENTRY POINTS                                     A
AXXRINT1 DS    V(XRINT1)           1ST PASS INIT ROUTINE              A
AXXRINT2 DS    V(XRINT2)           2ND PASS INIT ROUTINE              A
AXXRCOLL DS    V(XRCOLL)           COLLECTION ROUTINE                 A
AXXRPRNT DS    V(XRPRNT)           PRINT ROUTINE                      A
AXXRSCAN DS    V(XRSCAN)           CONTROL CARD SCANNING ROUTINE      A
.NOXREF2 ANOP
AXSPECAD DS    A                   BASE ADDRESS FOR SPECIAL ROUTINES
AXSPECA2 DS    A                   BASE @ LEV2-PASS 2 - 'SPECIALS'
         EJECT
* * * * * AVWXTABL SECTION W - CONSTANTS  * * * * * * * * * * * * * * *
AWD0     DS    0D                  FLOATING POINT 0 FOR CDE
AWZEROS  DS    32D'0'              256 BYTES OF BINARY ZEROS
AWD10    DS    D'10'               DOUBLEWORD CONSTANT 10
AWF1     DS    F'1'                FULLWORD 1 CONSTANT
AWH1     EQU   AWF1+2              HALFWORD 1 CONSTANT
AWB1     EQU   AWF1+3              BYTE 1 CONSTANT
AWF3     DS    F'3'                FULLWORD 3 CONSTANT
AWH3     EQU   AWF3+2              HALFWORD 3 CONSTANT
AWB3     EQU   AWF3+3              BYTE 3 CONSTANT
AWF4     DS    F'4'                FULLWORD CONSTANT 4
AWF7     DS    F'7'                FULLWORD 7 CONSTANT
AWH7     EQU   AWF7+2              HALFWORD 7 CONSTANT
AWB7     EQU   AWF7+3              BYTE 7 CONSTANT
AWF10    DS    F'10'               FULLWORD CONSTANT 10
AWH10    EQU   AWF10+2             HALFWORD CONSTANT 10
AWF12    DS    F'12'               FULLWORD CONSTANT 12
AWF15    DS    F'15'               FULLWORD CONSTANT 15 (4 1 BITS)
AWFXF    EQU   AWF15               FULLWORD CONSTANT,4 1-BITS
AWFXFF   DS    F'255'              FULLWORD CONSTANT 255
AWF4095  DS    F'4095'             FULLWORD 4095 CONSTANT
AWFXFFF  EQU   AWF4095             XL4'FFF'      ON F BOUNDARY
AWHXFFF  EQU   AWFXFFF+2           XL2'0FFF'  ON H BOUNDARY
AWFX7FFF DS    X'00007FFF'         MAXIMUM SIZE, MASK VALUE
AWFXFFFF DS    X'0000FFFF'         65K DECIMAL NUMBER
AWFX6F   DS    XL4'FFFFFF'         FULLWORD 24-BIT MASK
AWFM4    DS    F'-4'               FULLWORD -4 CONSTANT
AWFM1    DS    F'-1'               FULLWORD -1 CONSTANT
AWHM1    EQU   AWFM1+2             HALFWORD -1 CONSTANT
         EJECT
*        TABLE USED TO SCAN DECIMAL NUMBERS                           *
*        CHARACTERS 0-9 HAVE ZERO VALUES,ALL OTHERS NONZERO           *
*        ALSO USED IN ICMOP2 FOR GENERAL SCANNING.                    *
*   TR TABLE      0 1 2 3 4 5 6 7 8 9 A B C D E F                     *
AWTDECT  DS    X'02020202020202020202020202020202'    0
         DS    X'02020202020202020202020202020202'    1
         DS    X'02020202020202020202020202020202'    2
         DS    X'02020202020202020202020202020202'    3
         DS    X'100202020202020202020202020C0202'    4 BLANK (
         DS    X'02020202020202020202020608020202'    5  $ *
         DS    X'02020202020202020202020E02020202'    6  ,
         DS    X'02020202020202020202020606020A02'    7 # @ =
         DS    X'02020202020202020202020202020202'    8
         DS    X'02020202020202020202020202020202'    9
         DS    X'02020202020202020202020202020202'    A
         DS    X'02020202020202020202020202020202'    B
         DS    X'02060404060606060606020202020202'    C B-C(4) ALPHS-6
         DS    X'02060604060606060606020202020202'    D L-(4) ALPHS-6
         DS    X'02020606060606040606020202020202'    E X-(4) ALPHS - 6
         DS    X'00000000000000000000020202020202'    F
         SPACE 1
*        TABLE USED TO SCAN HEXADECIMAL CONSTANTS FOR CORRECTNESS     *
*        CHARACTERS A-F,0-9 ARE ZERO,ALL OTHERS ARE NON-ZERO          *
AWTHEXT  DS    X'02020202020202020202020202020202'    0
         DS    X'02020202020202020202020202020202'    1
         DS    X'02020202020202020202020202020202'    2
         DS    X'02020202020202020202020202020202'    3
         DS    X'02020202020202020202020202020202'    4
         DS    X'02020202020202020202020202020202'    5
         DS    X'02020202020202020202020202020202'    6
         DS    X'02020202020202020202020202020202'    7
         DS    X'02020202020202020202020202020202'    8
         DS    X'02020202020202020202020202020202'    9
         DS    X'02020202020202020202020202020202'    A
         DS    X'02020202020202020202020202020202'    B
         DS    X'02000000000000020202020202020202'    C
         DS    X'02020202020202020202020202020202'    D
         DS    X'02020202020202020202020202020202'    E
         DS    X'00000000000000000000020202020202'    F
         SPACE 1
*        TABLE USED TO CONVERT HEXADECIMAL CONSTANTS                  *
AWTHEX2  EQU   *-C'A'              OFFSET SYMBOL FROM TABLE CORRECTLY
*   TR TABLE      0 1 2 3 4 5 6 7 8 9 A B C D E F                     *
         DS      X'0A0B0C0D0E0F000000000000000000'    C
         DS    X'00000000000000000000000000000000'    D
         DS    X'00000000000000000000000000000000'    E
         DS    X'00010203040506070809'                F
         EJECT
*        USED TO SCAN ACROSS SYMBOLS,STOP ON DELIMITERS               *
*        CHARACTERS $,#,@,A-Z,0-9 ARE ZERO. ALL OTHERS ARE NONZERO    *
*        ALSO USED IN EVALUT FOR OPERATOR CODES- (+*)-/,              *
*   TR TABLE      0 1 2 3 4 5 6 7 8 9 A B C D E F                     *
AWTSYMT  DS    X'01010101010101010101010101010101'     0
         DS    X'01010101010101010101010101010101'     1
         DS    X'01010101010101010101010101010101'     2
         DS    X'01010101010101010101010101010101'     3
         DS    X'04010101010101010101010101020501'     4 BLANK (+
         DS    X'01010101010101010101010007030101'     5 $*)
         DS    X'06080101010101010101010401010101'     6 -/,
         DS    X'01010101010101010101010000010101'     7  #@
         DS    X'01010101010101010101010101010101'     8
         DS    X'01010101010101010101010101010101'     9
         DS    X'01010101010101010101010101010101'     A
         DS    X'01010101010101010101010101010101'     B
         DS    X'01000000000000000000010101010101'     C  A-I
         DS    X'01000000000000000000010101010101'     D  J-S
         DS    X'01010000000000000000010101010101'     E  S-Z
         DS    X'00000000000000000000010101010101'     F  0-9
         SPACE 1
AWTZTAB  EQU   AWZEROS             SPACE FOR 256-BYTE ZEROED TRT TABLE
         DS    0D                  LINE UP BLANKS ON D BOUNDARY
AWBLANK  DS    CL132' '            BLANKS
         ORG   AWBLANK+16          MAXIMUM OVERLAP OF AWBLANK&AWTHEX3
*        TABLE USED TO CONVERT INTERNAL BINARY TO EXTERNAL HEX.       *
*   TR TABLE     0123456789ABCDEF0123456789ABCDEF                     *
AWTHEX3  DS    C'                                '    0-1
         DS    C'                                '    2-3
         DS    C'                                '    4-5
         DS    C'                                '    6-7
         DS    C'                                '    8-9
         DS    C'                                '    A-B
         DS    C'                                '    C-D
         DS    C'                0123456789ABCDEF'    E-F
AWEP4    DS    X'40202120'         4-BYTE DECIMAL EDIT PATTERN
AWEP6    DS    X'402020202120'     6-BYTE EDIT PATTERN FOR DEC #
AWP0     DS    PL1'0'              FOR ZEROING DECIMAL COUNTERS
AWP1     DS    P'1'                DECIMAL CONSTANT 1
AWCONADS DS    ($CNT$N)AL1         OFFSETS TO CONSTANT PROG ADCONS
         EJECT
AVOENTR  EQU   B'00000010'         (AVTAGS1)<AOBJIN> ENTRY @ FROM END
AVO1TXT  EQU   B'00000100'         (AVTAGS1)<AOBJIN> >=1 TXT CARDS FND
         SPACE 1
* * * * * AVWXTABL SECTION V - VARIABLES  * * * * * * * * * * * * * * *
         DS    0D                  GET ALIGNMENT
*        **NOTE  VARIABLES FROM HERE THRU AVAJL ARE GIVEN INITIAL     *
*        VALUES BY CALLING PROGRAM BEFORE CALLING MPCON0.             *
AVADDLOW DS    F                   POINTER TO HIGH END OF LOW AREA
*                        GIVES FIRST FREE LOCATION AT LOW END.        *
AVADDHIH DS    F                   POINTER TO LOW ADDR OF HIGH END
*                        GIVES LOWEST ADDR OF ALREADY USED SPACE      *
AVECONPT DS    A                   @ ECONTROL, IF NEEDED (REPLMON)
AVAJOBPT DS    A                   @ AJOBCON TABLE, IN CASE EVER NEEDED
         SPACE 1
*              VARIABLES FROM HERE TO AVAJL CORRESPOND TO AJOBOCN
*              SECTION AJONERR - AJOAVL, AND CANNOT BE CHANGED WITHOUT
*              EXTREME CARE.  AJOAVL MUST = AVAJL.
         CNOP  2,4                 ALIGN AVNERR LIKE AJONERR
AVNERR   DS    H                   MAX # ACTUAL ERRORS ALLOWED
         SPACE 1
         AIF   (NOT &$MACROS).AVMXX1        SKIP IF NO MACROS AT ALL
         SPACE 1
*        AVMMACTR-AVMMSTMG MUST BE IN SAME ORDER AS AJOMACTR-AJOMSTMG.
AVMMACTR DS    F                   DEFAULT INITIAL VALUE OF MACRO ACTR
AVMMNEST DS    F                   ABSOLUTE LIMIT ON MACRO NEST LEVEL
AVMMSTMG DS    F                   GLOBAL LIMIT ON MACRO STMTS PROCESSD
AVTAGSM  DS    B                   MACRO OPTIONS BITS (FROM AJOASMFM)
*   BIT7=0 => NO MACROS ALLOWED.   =1(AJOMACRO) => MACROS ALLOWED
*   BIT6=0 => NO ASM G FEATURES.   =1(AJOMACRG) => ADD MACRO G TO ABOVE
*   BIT5=0 => NO ASM H FEATURES    =1(AJOMACRH) => ADD MACRO H TO F
*   REMAINING BITS RESERVED FOR FUTURE USE WITH MACRO PROCESSING.     *
.AVMXX1  ANOP
AVTAGS0  DS    B                   FLAG- FUTURE USE FROM AJOBCON
         SPACE 1
AVTAGS1  DS    B                   1ST BYTE OF FLAG BITS
*   BIT0=0 => START ALLOWED, =1($IBSTAR1)=> START NO LONGER ALLOWED.  *
*   BIT1=0 => CURRENT SECTION IS CSECT, =1($IBDSEC1)=> IN DSECT NOW   *
*   BIT2=0 => NO PRIVATE CODE, =1($IBPRCD1)=> PRIV CODE HAS OCCURREC  *
*   BIT3=0 => NORMAL LOAD, =1(AJORELOC)=> LOAD RELOCATED TO REAL @'S  *
*   BIT4=0 => ALL IN CORE, =1(AJODISKU) => USE DISK INTERMEDIATE.     *
*   BIT5=0 => NORMAL PROGRAM, =1(AJOLARGE)=> PROG LARGE, CRUNCH MUCH  *
*   BIT6=0 => LIST SOURCE, =1(AJNLIST)=> NOLIST (EXCEPT ERRORS)       *
*   BIT7=0 => LOAD OBJECT CODE, =1(AJNLOAD)=> CREATE NO OBJECT CODE   *
*        *NOTE* BITS 3-7 ARE SET FROM AJOASMF, BITS 0-2 INIT  = 0.    *
*              AVTAGS1 BITS ALSO USED BY OBJECT CODE LOADER AOBJIN.
*   BIT0=0 => NO TXT CARDS FOUND YET. =1(AVO1TXT) => >= 1 CARD FOUND. *
*   BIT1=0 => NO ENTRY @ FND ON END CARD YET. =1(AVOENTR) => FOUND.   *
         SPACE 1
AVTAGS2  DS    B                   2ND BYTE OF FLAG BITS
*   BIT0=0 => NO EOF FOUND, =1($INEND2)=> EOF, CREATE END CARD
*   BIT1=0 => CONTINUE ASSEMBLY. =1(AJOASTOP) ==> STOP ASSEMBLY.
*   BIT0=0 => NODECK. =1(AJODECK) => OBJECT DECK(USES <AODECK>).      *
*   BIT6=0 => NO COMMENT CHECK. =1 REQUIRES &$COMNT % OF MACH INSTS
*   BIT7=0=> NORMAL LISTING. =1 => CMPRS LISTING (2 STMTS/LINE)
*   OTHER BITS FOR FUTURE USE, SET FROM AJOASMF2 IN AJOBCON.          *
         AIF   (NOT &$XREF).NOXREF1 SKIP IF NO XREF                   A
AVXRFLAG DS    C                   FLAG BYTE FOR CROSS REFERENCE      A
          SPACE 2
* THE FOLLOWING FLAGS USED IN TESTING THE ABOVE FLAG                  A
         SPACE
AVXRON   EQU   B'00100000'         XREF FACILITY ON                   A
AVXRCOMP EQU   B'00110000'         COMPRESSED LISTING                 A
AVXRSDMD EQU   B'00001000'         SD OPERAND MOD REFERENCE           A
AVXRSDFT EQU   B'00000100'         SD OPERAND FETCH REFERENCE         A
AVXRSRMD EQU   B'00000010'         SR OPERAND MOD                     A
AVXRSRFT EQU   B'00000001'         SR OPERAND FETCH                   A
.NOXREF1 ANOP
AVAJL    EQU   *-AVNERR            LENGTH OF BLOCK FROM AJOBCON
*              VRADL,VRADH,VRELOC,VFENTER,VLOCLOW,VLOCHIH MUST BE IN  *
*        THE ORDER WHICH IS GIVEN.  THEY ARE USED IN LM-STM GROUPS    *
AVRADL   DS    A                   LOWEST REAL ADDRESS OF USER PROGRAM
AVRADH   DS    A                   HIGHEST REAL ADDRESS OF USER PROGRAM
AVRELOC  DS    F                   RELOCATION FACTOR FOR OBJECT CODE
AVZAREA1 DS    0F                  VARIABLE AREA TO BE ZEROED-BEGINNING
AVFENTER DS    A                   PROGRAM ENTRY POINT ADDRESS
*              AVLOCLOW,AVLOCHIH,AVLOCNTR,AVCSLOW,AVCSHIH-REQUIRED ORDR
AVLOCLOW DS    F                   LOWEST LOCATION COUNTER(START OR 0)
AVLOCHIH DS    F                   HIGHEST VALUE OF AVLOCCNTR
AVLOCNTR DS    F                   LOCATION COUNTER
AVCSLOW  DS    F                   CURRENT CSECT LOW LOCCNTR VALUE
AVCSHIH  DS    F                   CURRENT CSECT HIGH VALUE
         SPACE 1
AVSTMTNO DS    H                   TOTAL # OF STATEMENTS
AVSTMTER DS    H                   TOTAL # STMTS FLAGGED
AVNERRA  DS    H                   # FATAL ERROR MESSAGES
AVNWARN  DS    H                   # WARNING MESSAGES
AVOUCOUN DS    H                   WITHIN PAGE LINE COUNT (OUTPUT)
AVOULNCN DS    PL3                 STATEMENT NUMBER CURRENT
AVOUPGCN DS    PL2                 NUMBER OF PAGES (OUTPUT)
         AIF   (NOT &$XREF).NOXREF4  SKIP IF NO XREF
AVXRLAVS DS    F                   LIST OF AVAIL SPACE FOR XREF       A
AVXRHEAD DS    F                   HEADER POINTER FOR XREF TREE       A
AVXRCNT  DS    H                   COUNTER FOR NUMBER OF REFERENCES   A
AVXRLNCN DS    PL3                 ADDITIONAL LINE COUNTER FOR XREF   A
AVXRMDFT DS    C                   ADDITIONAL FLAG FOR XREF           A
* FLAG TO BE TESTED WITH THE FOLLOWING                                A
AVXRMOD1 EQU   B'10000000'         MODIFY FIRST OPERAND               A
AVXRMOD2 EQU   B'01000000'         MODIFY SECOND OPERAND              A
AVXRMOD3 EQU   B'00100000'         MODIFY THIRD OPERAND               A
AVXRMOD4 EQU   B'00010000'         MODIFY FIRST THRU SECOND OPERAND   A
AVXRFET1 EQU   B'00001000'         FETCH FIEST OPERAND                A
AVXRFET2 EQU   B'00000100'         FETCH SECOND OPERAND               A
AVXRFET3 EQU   B'00000010'         FETCH THIRD OPERAND                A
AVXRFET4 EQU   B'00000001'         FETCH FIRST THRU SECOND OPERAND    A
AVXRTYPE DS    C                   USED TO TEST M/F REFERENCE         A
AVXRFTCH EQU   X'08'               USED TO TEST ABOVE FLAG            A
* IF NOT TYPE , MUST BE MODIFY REFERNCE                               A
.NOXREF4 ANOP
         SPACE
AVCESDID DS    C                   CURRENT CSECT ESDID
*              EVEN VALUE=> CSECT, ODD VALUE=> DSECT ($ESDSECT FLAG).
AVPRINT  DS    C                   LISTING CONTROL FLAG BYTE
AVPRINT1 DS    C                   LISTING CONTROL: 1ST PASS ONLY
AVPRSAVE EQU   B'00000001'         (AVPRINT1,AVPRINT)==> SAVE IN 1ST PS
AVDEBUG  DS    C                   DEBUGGING FLAG TESTED BY XSNAPS
AVTAGS3  DS    B                   VARIOUS FLAGS
*  BIT0=0 => NO STORAGE OVERFLOW. =1(AVOVERFL) => STORAGE EXCEEDED.
AVOVERFL EQU   B'10000000'         (AVTAGS3) => STORAGE OVERFLW OCCRD
AVMTAG00 DS    B                   MISC FLAG BYTE, MACRO COMMUNICATION
AVMOPENC EQU   B'00000001'         (AVMTAG00)==> GBLX,LCLX IN OPEN COD
AVMNOMAC EQU   B'00000010'         (AVMTAG00) => NO MORE MACROS       S
*                                  BECAUSE GBLX, LCLX, ETC. FOUND     S
AVMOPDIC EQU   B'00000100'         (AVMTAG00) => OPEN CODE LOCAL      S
*                                  DICTIONARY HAS BEEN ALLOCATED      S
AVMOPGO  EQU   B'00001000'         (AVMTAG00) => SUCCESSFUL AIF/AGO   S
AVMOPMIN EQU   B'00010000'         (AVMTAG00) - OPEN CODE MACLIB ENTRY X
                                   IS PROPERLY ZEROED & @ OF LOCAL    SX
                                   DUMMY HAS BEEN ENTERED             S
AVMISC00 DS    B                   MISC FLAG BYTE, FUTURE USE
AVMISC01 DS    B                   MISC FLAG BYTE, FUTURE USE
AVMISC02 DS    B                   MISC FLAG BYTE, FUTURE USE
AVZAREA2 DS    0D                  VARIABLE AREA TO BE ZEROED - END
         EJECT
AVECONTR DS    0D                  ECONTROL DSECT WILL BE LOCATED HERE
AVCONCAT DS    CL256               SPACE FOR CONSTANT BUILDING(CNDTL2)
AVCONBLD DS    CL256               CONSTANT/CODE BUILDING AREA
AVRSBLOC DS    CL(RSB$L+RSOL1+80+RSOLC*($RSMXCRD-2)) RSBLOCK AREA
AVRSCBLK DS    (RSCONSQ-RSCBLK+$RSMXCRD*RSC$LEN)C AREA FOR RSCBLK
AVREBLK  DS    0C                  BEGINNING OF RECORD ERROR BLOCK
AVREBLN  DS    C                   RECORD ERROR BLOCK LENGTH-1
AVREBES  DS    ($ERREBMX)CL2       ERROR CODE AREAS
AVREBSCN EQU   AVREBES             BYTE FOR SCAN OFFSET
AVREBERR EQU   AVREBES+1           BYTE FOR ERROR CODE
         ORG   ,                   MAKE SURE BACK FAR ENOUGH
         SPACE 1
AVDWORK1 DS    D                   1ST DOUBLE WORD WORK AREA
AVDWORK2 DS    D                   2ND DOUBLE WORD WORK AREA
AVRCBPT  DS    A                   ADDRESS OF RECORD CODE BLOCK
AVREBPT  DS    A                   ADDRESS OF RECORD ERROR BLOCK
AVRSBPT  DS    A                   ADDRESS OF RECORD SOURCE BLOCK
AVRSCPT  DS    A                   RECORD SOURCE CODE BLOCK POINTER
AVLABPT  DS    F                   ADDRESS OF LABEL ENTRY,=0 IF NO LAB
AVFWORK1 DS    F                   1ST FULLWORD WORKAREA
AVMPSPIE DS    A                   @ SPIE BLOCK WHEN ENTERED ASSEMBLER
AVSOLAST DS    A                   @ BLANK BEFORE ' AFTER SOURCE STMT
         AIF   (&$COMNT EQ 0).AVNOCOM       SKIP IF NO COMMENT CHECKING
*              FOLLOWING 2 VARIABLES MUST BE IN GIVEN ORDER.
AVMACHIN DS    H                   # MACHINE INSTS, SET BY IAMOP1
AVCOMNTN DS    H                   # MACHINE INSTS WITH COMMENTS
.AVNOCOM ANOP
         AIF   (&$DISKU EQ 0).AVDKTA        SKIP IF NO DISK AT ALL
*
*        BUFFER CONTROL BLOCK FOR DISK UTILITY I/O SYNCHRONIZATION
*
AVBCB    DS    0F                  BUFFER CONTROL BLOCK
AVDECB   DS    A(0)                ADDRESS OF CURRENT DECB
AVBUFF@  DS    A(0)                ADDRESS OF CURRENT BUFFER
AVBUFINC DS    A(0)                POINTER TO 1ST UNUSED BYTE IN BUFFER
AVBUFEND DS    A(0)                POINTER TO END OF BUFFER
         AIF   (&$BUFNO EQ 1).AVDKTA        SKIP IF ONLY 1 BUFFER
AVDECBNX DS    A(0)                ADDRESS OF NEXT DECB
AVDECBLT DS    A(0)                POINTER TO LAST DECB
.AVDKTA  ANOP
         AIF   (NOT &$MACROS).AVNOMAC       SKIP IF NO MACROS
         SPACE 2
*              VARIABLES USED IN MACRO PROCESSING.                    *
AVSYSECT DS    D                   CURRENT CSECT/DSECT NAME
AVGEN1CD DS    A                   @ 1ST BYTE BEYOND 1ST GEN'D CARD-
*              SET BY MEXPND.  THEN USED AS PTR BY INCARD.
AVGEN2CD DS    A                   USED AS PTR BY INCARD. HAS @ LAST
*              CARD GENERATED BY MEXPND (ORIG SETTING OF AVADDHIH).
AVMACSPC EQU   *                   LABEL FOR SPACE FOR MACRO AVM'S
*
.AVNOMAC ANOP
         AIF   (NOT &$MACROS).AVNLIB         SKIP IF NO MACROS
AVMFLD1  DS    F                   POINTER TO CURRENT LABEL FIELD
AVMFLDL1 DS    C                   LENGTH OF LABEL
AVMFLDT1 DS    C                   TYPE OF LABEL - SEQ, VAR OR OTHER
AVMFLD1H DS    H                   NOT CURRENTLY USED
AVMFLD2  DS    F                   POINTER TO OPCODE FIELD
AVMFLDL2 DS    C                   LENGTH OF OPCODE FIELD
AVMFLDT2 DS    C                   TYPE OF OPCODE - ASM, MACR OR MAC IN
AVMFLD2H DS    H                   NOT CURRENTLY USED
AVMFLD3  DS    F                   POINTER TO OPERAND FIELD
AVMFLDL3 DS    C                   LENGTH OF OPERAND FIELD
AVMFLDT3 DS    C                   TYPE OF OPERAND FIELD
AVMFLD3H DS    H                   NOT CURRENTLY USED
AVMFLD4  DS    F                   POINTER TO COMMENT FIELD
AVMFLDL4 DS    C                   LENGTH OF COMMENT FIELD
AVMFLDT4 DS    C                   TYPE OF COMMENT FIELD - NOT USED
AVMFLD4H DS    H                   NOT CURRENTLY USED
AVMFLD5  DS    F                   2ND CARD NON STND OPRND
AVMFLDL5 DS    C                   2ND CARD NON STND OPRND LENGTH
AVMFLDT5 DS    C                   2ND CARD NON STND OPRND TYPE
AVMFLD5H DS    H                   NOT CURRENTLY USED
AVMFLD6  DS    F                   2ND NON STND CARD COMMENT
AVMFLDL6 DS    C                   2ND NON STND CARD COMMENT LENGTH
AVMFLDT6 DS    C                   2ND NON STND CARD COMMENT TYPE
AVMFLD6H DS    H                   NOT CURRENTLY USED
AVMFLD7  DS    F                   3RD NON STND CARD OPRND
AVMFLDL7 DS    C                   3RD NON STND CARD OPRND LENGTH
AVMFLDT7 DS    C                   3RD NON STND CARD OPRND TYPE
AVMFLD7H DS    H                   NOT CURRENTLY USED
AVMFLD8  DS    F                   3RD NON STND CARD COMMENT
AVMFLDL8 DS    C                   3RD NON STND CARD COMMENT 6ENGTH
AVMFLDT8 DS    C                   3RD NON STND CARD COMMENT TYPE
AVMFLD8H DS    H                   NOT CURRENTLY USED
$LAVMFLD EQU   *-AVMFLD1           LENGTH OF FIELD INFO POINTERS
         SPACE 1
AVMBYTE1 DS    C                   1ST MACRO FLAG BYTE
AVMBYTE2 DS    C                   2ND MACRO FLAG BYTE
AVMBYTE3 DS    C                   3RD MACRO FLAG BYTE
AVMBYTE4 DS    C                   FLAG BYTE
AVMBYTE5 DS    C                   FLAG BYTE
         SPACE 1
AVMSYMLN DS    C                   LENGTH OF CURRENT SYMBOL
AVMSYMBL DS    CL8                 GLOBAL AREA FOR CURRENT SYMBOL
AVMSYSDX DS    PL2                 CURRENT &SYSNDX COUNT
         SPACE 1
AVMSEQPT DS    F                   POINTER TO SEQ SYMBOL TABLE
AVMCRINS DS    F                   CURRENT GENERATED INSTRUCTION @
AVMMACID DS    F                   CONTAINS ID NUMBER OF CURRENT MACRO
AVMACNST DS    F                   CURRENT MACRO NESTING COUNT
AVMLDICT DS    F                   POINTER TO OPEN LOCAL DICTIONARY
AVMGDICT DS    F                   POINTER TO GLOBAL DICTIONARY
AVMACLIB DS    F                   POINTER TO MACRO LIBRARY
AVMOVRFL DS    A                   @ OVERFLOW EXIT ROUTINE
AVMTSCNP DS    F                   TEMP STORAGE FOR SCAN POINTER
         SPACE 1
AVMBSPIE DS    F                   TEMP STORAGE FOR MCBODY $SPIE INT @
         ORG   AVMBSPIE            PUT AVMXSPIE IN SAME PLACE**********
AVMXSPIE DS    F                   TEMP STORAGE FOR MXPEND SPIE INT @
         SPACE 1
AVMCHSTR DS    F                   @ OF CHARACTER WORK AREA
AVMCHLIM DS    F                   LAST AVAILABLE BYTE OF CHAR WORK
AVMWRKL1 DS    F                   @ OF LAST BYTE OF AVMWRK1
AVMWRKL2 DS    F                   @ OF LAST BYTE OF AVMWRK2
         SPACE 1
AVMWRK1  DS    CL256               MACRO WORK AREA 1
AVMWRK2  EQU   AVCONCAT            USE CONCAT FOR WORK AREA 2
         SPACE 1
AVMDWRK1 DS    D                   1ST DOUBLE WORD WORK AREA
AVMDWRK2 DS    D                   2ND DOUBLE WORD WORK AREA
AVMDWRK3 DS    D                   3RD DOUBLE WORD WORK AREA
AVMDWRK4 DS    D                   4TH DOUBLE WORD WORK AREA
         SPACE 1
AVMFWRK1 DS    F                   1ST FULL WORD WORK AREA
AVMFWRK2 DS    F                   2ND FULL WORD WORK AREA
AVMFWRK3 DS    F                   3RD FULL WORD WORK AREA
AVMFWRK4 DS    F                   4TH FULL WORD WORK AREA
         SPACE 1
AVMHWRK1 DS    H                   1ST HALFWORD WORK AREA
AVMHWRK2 DS    H                   2ND HALFWORD WORK AREA
AVMHWRK3 DS    H                   3RD HALFWORD WORK AREA
AVMHWRK4 DS    H                   4TH HALFWORD WORK AREA
         SPACE 1
AVMSNBY1 DS    C                   CONTAINS FLAGS TO CONTROL SNAPS
AVMSNBY2 DS    C                   CONTAINS FLAGS TO CONTROL SNAPS
         AIF   (NOT &$MACSLB).AVNLIB         SKIP IF NO LIBRARY FETCH
AVLIBBUF DS    F                   POINTER TO LIBRARY BUFFER SPACE
.AVNLIB  ANOP
AVWXEND  DS    0D                  ENDING @ AVWXTABL
         TITLE 'ERCOMPCD DSECT - COMPLETION CODE MESSAGE BLOCK'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: ERCOMPCD   COMPLETION CODE/ERROR MESSAGE BLOCK            *
*        THIS GIVES FORMAT OF 1 COMPLETION CODE/MESSAGE BLOCK FOR     *
*        USE IN A USER COMPLETION DUMP BY SUBROUTINE XXXXSNAP.  THE   *
*        ADDRESS OF THE APPROPRIATE BLOCK IS PLACED INTO WORD ECERRAD *
*        IN DSECT ECONTROL, AND IS USED THEN BY XXXXSNAP TO PRINT THE *
*        INFORMATION IN THE ERCOMPCD BLOCK.                           *
*        LOCATION: INSIDE EXECUT, WILL BE ELSEWHERE(FUTURE).          *
*        GENERATION: 1 BLOCK CREATED BY 1 CALL TO $ERCGN MACRO.       *
*        NAMES: ERC-----                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
ERCOMPCD DSECT
ERCSYST  EQU   0                   (ERCTYPE)==> SYSTEM COMPLETION CODE
ERCASSI  EQU   1                   (ERCTYPE)==> ASSIST SPECIAL MESSAGE
ERCUSER  EQU   2                   (ERCTYPE)==> USER ABEND COMPLETION
ERCLENG  DS    C                   LENGTH-1 OF ERCMSSG
ERCTYPE  DS    C                   CODE OF COMPLETION TYPE
ERCMSSG  DS    0C                  COMPLETION MESSAGE(VARIABLE LENGTH)
         TITLE 'AJOBCON - MAIN JOB CONTROL TABLE DSECT'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: AJOBCON    MAIN JOB CONTROL TABLE                         *
*        THIS DSECT PROVIDES THE PRIMARY COMMUNICATION TABLE USED     *
*        BY THE MAIN PROGRAM ASSIST, THE I/O ROUTINES(XXXXIOCO), THE  *
*        PARM FIELD ANALYZER (APARMS), THE MAIN PROGRAM OF THE        *
*        ASSEMBLER (MPCON0), AND THE REPLACE MONITOR (REMONI).  IT    *
*        PROVIDES FOR GLOBAL FLAG VALUES DEALING WITH THE OVERALL     *
*        JOB IN PROGRESS, PARM FIELD VALUES, USEFUL CONSTANTS, BLANKS,*
*        ZEROES, WORKAREAS, AND DYNAMIC STORAGE AREA LIMITS.          *
*        LOCATION: IN TABLE ASJOBCON OF CSECT ASSIST.                 *
*        NAMES: AJ------                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
AJOBCON  DSECT
*              FOLLOWING EQU'S USED FOR COMMUNICATION BETWEEN ASSIST  J
*              AND XXXXSORC DURING CONTROL CARD CHECKING. VALUES ARE  J
*              PLACED INTO AJOBTRQ AND ATOBTYP.                       J
AJO$D    EQU   0                   (AJOBTRQ)- DATA READ (NORMAL CASE) J
AJO$J    EQU   1                   (AJOBTRQ)- LOOKING FOR $JOB CARD   J
AJO$E    EQU   2                   (AJOBTRQ)- LOOKING FOR $ENTRY      J
AJOAPRSE EQU   B'00000001'         (AJOAPMOD)- ZERO ALL APCFLAG SET
*                                  BITS BEFORE SCANNING PARM OPTIONS
AJOAPDEF EQU   B'00000010'         (AJOAPMOD)- DEFAULT CALL TO APARMS-
*                                  OVERRIDE NO VALUE ALREADY SET ANY WY
AJOAPFIN EQU   B'00000100'         (AJOAPMOD)- FINAL CALL TO APARMS-
*                                  SET ANY FINAL FLAGS NEEDED.
AJOAPMOV EQU   B'00001000'         (AJOAPMOD)- MOVE PARM FIELD INTO
*              AJOPARM, WITH BLANK PADDING.  IF NOT SET, APARMS WILL
*              LEAVE PARM WHERE IT IS, AND ASSUME THAT ITS LENGTH
*              INCLUDES AT LEAST ONE BLANK FOLLOWING ACTUAL PARM.
         SPACE 1
*        ----- NEXT 2 BITS POSSIBLY SET ONLY WHEN &$TIMER=2,&$RECORD=2
AJOAPUSR EQU   B'01000000'         (AJOAPMOD)- SET IF USER SUPPLIED R=
AJOAPUST EQU   B'10000000'         (AJOAPMOD)- SET IF USER SUPPLIED T=
AJOBATCH EQU   B'00000001'         (AJOMODE)==> BATCH MODE,DON'T CLOSE
         SPACE 1
AJOREPLF EQU   B'00000010'         (AJOMODE)==> REPLACE MODE RUN
AJOMONIT EQU   B'00000100'         (AJOMODE)==> RUNNING UNDER WATFR MON
AJNSYSIN EQU   B'00001000'         (AJOMODE)==> NO SYSIN, ABORT RUN
AJOSRECX EQU   B'00100000'         (AJOMODE)==> RECORD OVERRUN OCCURRED
AJOSOVRT EQU   B'00010000'         (AJOMODE)==> TIME OVERRUN OCCURRED
AJOREPHB EQU   B'01000000'         (AJOMODE)==>REPLACEMENT PHASE B
         SPACE 1
AJOMSINT EQU   B'00000001'         (AJOSTEP)- MAIN STORAGE INIT DONE
AJOSDUMP EQU   B'00100000'         (AJOSTEP)- PROGRAM IN DUMPING PHS
AJOSEXEC EQU   B'01000000'         (AJOSTEP)==> PROGR IN EXECUTION
AJOSASM  EQU   B'10000000'         (AJOSTEP)==> PROG IN ASSEMBLY PHASE
         SPACE 1
AJNLOAD  EQU   B'00000001'         (AJOASMF)==> CHECK ONLY, NO OBJCT CD
AJNLIST  EQU   B'00000010'         (AJOASMF)==> NO LISTING DESIRED
AJOLARGE EQU   B'00000100'         (AJOASMF)==> PROGRAM IS LARGE,OPTIM
AJODISKU EQU   B'00001000'         (AJOASMF,AVTAGS1) => DISK OPTION
AJORELOC EQU   B'00010000'         (AJOASMF)==> RELOC CODE TO REAL @'S
         SPACE 1
AJOCMPRS EQU   B'00000001'         (AJOASMF2,AVTAGS2)-COMPRESSD LISTING
AJOCOMNT EQU   B'00000010'         (AJOASMF2-AVTAGS2)- COMMENT CHECK
AJODECK  EQU   B'00000100'         (AJOASMF2-AVTAGS2)- PUNCH OBJ DECK
AJOASTOP EQU   B'01000000'         (AJOASMF2-AVATGS2)- STOP ASSEMBLY
         SPACE 1
AJOMACRO EQU   B'00000001'         (AJOASMFM,AVMTAGSM)=> MACROS(F) OK
AJOMACRG EQU   B'00000010'         (AJOASMFM,AVMTAGSM)=> ASM G MACROS
AJOMACRH EQU   B'00000100'         (AJOASMFM,AVMTAGSM)=> ASM H MACROS
AJOMACRV EQU   B'00001000'         (AJOASMFM,AVTAGSM)=> OS/VS ASM
         SPACE 1
AJOLIBMC EQU   B'10000000'         (AJOASMFM,AVMTAGSM)=>PRT LIB MACROS
AJOSUPER EQU   B'00000010'         (AJOEXEF)==> INIT USER IN SUPERVISOR
AJONALGN EQU   B'00000100'         (AJOEXEF-ECFLAG4)==>NO ALIGNMENT 0C6
         SPACE 1
AJIOPEN  EQU   B'00000001'         (AJIO-SO-RE-PR-PN)==> DCB OPEN
AJIOEOF  EQU   B'00000010'         (AJIO-SO-RE)==> END-FILE ENCOUNTERED
AJIODEOF EQU   B'00000100'         DISK END-OF-FILE FLAG
AJIOSYND EQU   B'00010000'         DISK SYNAD ERROR FLAG
AJIOSOHS EQU   B'00010000'         (AJIOSO)- OUTPUT BUFFER FLUSH      J
AJIOPSEO EQU   B'00000100'         (AJIO-SO-RE)=> PSEUDO ENDFILE(JCL)
AJIOPAGE EQU   B'01000000'         (AJIOPR)- PAGE CONTROL MODE ON
AJIOSORR EQU   B'01000000'         (AJIOSO)- REREAD LAST CARD READ    J
AJIODKNO EQU   B'10000000'         DISK DCB COULD NOT BE OPENED
AJIOKP26 EQU   B'10000000'         (AJIOSO) - KP=26 -TRANSLATE TO 029
AJIOSING EQU   B'10000000'         (AJIOPR)-SINGLE SPACE CARRIAGE CONT
*                                  EXCEPT  NEW PAGE==> DOUBLESPACE
AJIODFLT EQU   B'10000000'         (AJIO-RE,PN)==> USING SO OR PR DEFLT
         SPACE 1
AJOOBJIN EQU   B'00000001'         (AJODECKF) - OBJECT INPUT DECK
         SPACE 1
AJOZEROS DC    16F'0'              FOR USE IN ZEROING THINGS
AJ1000   DS    F'1000'             FOR CONVERSIONS
AJ2604   DC    F'2604'             FOR USE IN TIME CONVERSIONS
AJ100000 DC    F'100000'           FOR USE IN TIME CONVERSIONS
AJ100M   DC    F'100000000'        FOR USE IN SECS==>TIMER UNITS
AJOVWXPT DS    V(VWXTABL)          @ MAIN ASSEMBLER TABLE
AJOEXECU DS    V(EXECUT)           ADCON FOR INTERPRETER CODE
         DS    0D
         AIF   (NOT &$KP26).AJNKP26         SKIP IF NO KP=26 OPT ALLWS
AJTRTB26 DS    XL256               026-->029 KEYPUNCH TRANSLATE TABLE
.AJNKP26 ANOP
AJOBLANK DC    CL136' '            FOR GENERAL SUPERVISOR BLANKING
AJOPARMA DS    C                   FOR CARRIAGE CONTROL
AJOP$L   EQU   100                 MAXIMUM LENGTH OF PARM FIELD
AJOPNDFT DS    0CL88               CARD IMAGE HERE IF NOPUNCH USED.
AJOPARM  DS    CL(AJOP$L+2)        SPACE FOR PARM,2 TRAILING BLANKS
AJOCP$L  EQU   5                   MAX # CHARACTERS IN EACH PARM
         DS    0D                  MAKE AJOCOMP PART OF AJODWORK
AJOCOMP  DS    0CL(AJOCP$L)        SPACE FOR COMPARE DURING PARM SCAN
         SPACE 1
AJODWORK DS    D                   GENERAL DOUBLEWORD WORKAREA
AJOPADL  DS    A                   PERMANENT LOW @ WORKAREA
AJOPADH  DS    A                   PERMANENT HIGH @ WORKAREA
AJOTADL  DS    A                   TEMPORARY LOW @ WORKAREA
AJOTADH  DS    A                   TEMPORARY HIGH @ WORKAREA
AJOECOPT DS    A                   @ ECONTROL, EXECUTION CONTROL BLK
         SPACE 1
AJO$APC  EQU   *                   BASE @ FOR OFFSETS TO PARM VARIABLES
AJOZER1  EQU   *                   PLACE TO BEGIN ZEROING ON INIT
         AIF   (&$REPL EQ 0).AJNREPL        SKIP GEN IF NO REPL
AJORFLAF DS    0F,H                DUMMY RFLAG INTO FULLWORD-MAKES
*                                  CODE IN APARMS CSECT EASIER
AJORFLAG DS    H                   REPLACE FLAG FROM RFLAG=
.AJNREPL ANOP
         AIF   (NOT &$PAGE).AJNPAGE         SKIP IF NO PAGE CONTROL
AJOL     DS    F                   LINES/PAGE FROM PARM FIELDS
AJOP     DS    F                   TOTAL PAGES FROM PARM FIELDS
AJOPX    DS    F                   PAGES FOR EXECUTION TIME,PARM FIELD
AJOPD    DS    F                   PAGES FOR DUMP IF RECORDS EXCEEDED
*              AJOLREM-AJOPREM MUST BE IN ORDER GIVEN TOGETHER
AJOLREM  DS    F                   LINES REMAINING IN PAGE AT ANY TIME
AJOPREM  DS    F                   PAGES REMAINING AT ANY TIME
*              FOLLOWING VARIABLES MAY BE SET WITH AJIOSING FLAG TO
*              SHOW SINGLE SPACE CRUNCHING DURING NOTED PROG PHASE.
*              SINGLE SPACE ACTION TAKEN ONLY IF PAGE CONTROL OPT USED
AJIOSS   DS    B                   SET==> SINGLE SPACE DURING ASSEMBLY
AJIOSSD  DS    B                   SET==> SINGLE SPACE DURING DUMP
AJIOSSX  DS    B                   SET==> SINGLE SPACE DURING EXECUT
.AJNPAGE ANOP
AJORD    DS    F                   # RECORDS MINIMUM ALLLOWED FOR DUMP
AJORX    DS    F                   RECORDS FOR EXECUTION TIME
AJOTD    DS    F                   MINIMUM TIME SAVED FOR DUMP
AJOTX    DS    F                   TIME(SECS) FOR EECUTION TIME
AJOTIML  DS    F                   TIME LIMIT FOR JOB, FROM T=
AJORECNT DS    F                   # RECORDS REMAINING(DECREMENTED)
AJORECL  DS    F                   RECORD LIMIT, FROM R=
AJOINSL  DS    F                   # EXECUTED INST LJMIT, FROM I=
AJONERRF DS    0F,H                DUMMY AJONERR INTO FULLWORD.
*                                  SIMPLIFIES CODE IN APARMS
*        **NOTE** SECTION FROM AJONERR - AJOAVL MUST CORRESPOND       *
*        EXACTLY TO SECTION AVNERR - AVAJL, INC ALIGNMENT.            *
*        THIS SECTION MOVED TO CORRESPONDING SECTION IN AVWXTABL.     *
AJONERR  DS    H                   MAXIMUM # ERRORS TO STILL OK EXECUT
         SPACE 1
         AIF   (NOT &$MACROS).AJNMACX       SKIP IF NO MACROS
*              MACRO  OPTIONS AND FLAG BYTES.
AJOMAC01 DS    0F                  START OF MACRO PARAMETER OPTIONS
AJOMACTR DS    F                   INITIAL ACTR VALUE FOR MACROS/MAIN
AJOMNEST DS    F                   MAXIMUM NEST LEVEL FOR MACROS
AJOMSTMG DS    F                   GLOBAL LIMIT: MACRO STMTS PROCESSED
AJOASMFM DS    B                   MACRO FLAGS (SETS AVTAGSM)
.AJNMACX ANOP
AJOASMF0 DS    B                   ASSEMBLER FLAG **FUTURE USE*********
AJOASMF  DS    C                   FLAG BYTE FOR ASSEMBLER SECTION
AJOASMF2 DS    B                   2ND BYTE OF FLAG BITS(FUTR USE)
         AIF   (NOT &$XREF).NOXREF3                                   A
*  CROSS REFERENCE FLAG BYTE                                          A
AJOXREF  DS    C                   FLAG FOR XREF FACILITY             A
.NOXREF3 ANOP                                                         A
AJOAVL   EQU   *-AJONERR           LENGTH OF SECTION MOVED TO AVWXTABL
         SPACE 2
AJOMODE  DS    B                   MODE FLAG, MISC FLAGS.
AJOSTEP  DS    B                   FLAG SHOWING CURRENT STEP
*              EXECUTION CONTROL FLAGS, MUST BE IN GIVEN ORDER. SECTION
*        AJOEC - AJOECL MUST CORRESPOND WITH ECAJ - ECAJL.            *
AJOEC    DS    0F                  BEGIN AREA  --  ALIGNMENT
AJOIECF  DS    F                   IECF=  (ONLY NEEDED FOR &$EXINT=1)
AJODMPF  DS    B                   DUMP FLAGS (SETS ECFLAG3)
AJOEXEF  DS    B                   GENRAL EXECUTION MODE FLAGS(ECFLAG4)
AJOEXEFA DS    B                   EXECUTION FLAGS (ECFLAG5) **FUTURE**
AJOECL   EQU   *-AJOEC             LENGTH OF FLAG BYTES
         SPACE 1
AJOAPMOD DS    B                   FLAG BYTE FOR RUNNING MODE OF APARMS
AJOAPSET DS    B                   SET BYTE - OR'D BY APARMS WHEN IT
*              SETS APCFLAG TO SHOW VALUE SET. SEE APCSET,SETLD,SETU
         SPACE 1
AJIOFLAG DS    0BL4                AREA OF FLAGS FOR DCB'S
AJIORE   DS    B                   FLAG BYTE FOR DATA READER(XXXXREAD)
AJIOSO   DS    B                   FLAG BYTE FOR SOURCE RDR (XXXXSORC)
AJIOPR   DS    B                   FLAG BYTE FOR PRINTER(XXXXPRNT)
AJIOPN   DS    B                   FLAG BYTE FOR PUNCH (XXXXPNCH)
AJIODSK  DS    B                   FLAG BYTE FOR RUNNING MODE DISKU
AJIOWRKB DS    B                   WORK BYTE FOR USE OF XXXXIOCO
         SPACE 1
AJODEBUG DS    B                   DEBUG FLAG BYTE
AJODECKF DS    B                   OBJECT DECK CONTROL FLAG
AJOBTRQ  DS    C                   ASSIST SETS FOR XXXXSORC USE       J
AJOBTYP  DS    C                   XXXXSORC SETS FOR ASSIST           J
AJOTIMR  DS    F                   TEMPORARY TIME WORK AREA
AJOFREE  DS    F                   MEMORY TO BE FREED TO OPERATING SYST
AJOZER$L EQU   *-AJOZER1           LENGTH OF AREA TO BE ZEROED
         DS    0D
AJOJCLCD DS    CL80                ASSIST JCL STORED HERE BY READ ROUTN
AJOJCLPM EQU   AJOJCLCD+15         LOCATION OF $JOB PARM FIELD
         AIF   (NOT &$ACCT).AJONACC         SKIP IF NO ACCT INFO
         SPACE 1
*              ACCOUNT # CHECKING DATA - FROM $TIRC (NAME,AJOACCT)
AJOACCT  DS    CL5                 ACCOUNT #
AJOJOBNM DS    CL8                 JOB NAME
AJOPRGNM DS    CL20                PROGRAMMER'S NAME
.AJONACC ANOP
AJOB$L   EQU   *-AJOBCON           GET LENGTH OF AJOBCON
         TITLE '*** ECONTROL DSECT - EXECUTION CONTROL BLOCK ***'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: ECONTROL   EXECUTION CONTROL BLOCK                        *
*        THIS BLOCK CONTAINS ALL DATA REQUIRED TO DESCRIBE A USER     *
*        PROGRAM TO BE EXECUTED BY THE ASSIST INTERPRETER (EXECUT).   *
*        IT CONTAINS SIMULATED USER REGISTERS AND PROGRAM STATUS WORD,*
*        AN INSTRUCTION STACK, POINTERS TO THE USER PROGRAM CODE,     *
*        AND VARIOUS FLAGS DESCRIBING THE RUNNING MODE AND OPTIONS    *
*        ALLOWED TO THE USER PROGRAM.  IT IS CREATED FROM INFORMATION *
*        FROM THE ASSEMBLER, THE USER PARM FIELD, AND FROM THE        *
*        OPTIONS IN ASSIST, AND IS MODIFIED BY EXECUT.  IT ALSO       *
*        PROVIDES ALL DATA NEEDED BY XXXXSNAP TO DO A USER DUMP.      *
*        LOCATION: IN HIGH END OF DYNAMIC CORE AREA.                  *
*        NAMES: EC------                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
ECONTROL DSECT
EC$STACK EQU   10                  MAX # OF INSTS KEPT IN STACK
         SPACE 1
$ECCONT  EQU   X'80'               (ECFLAG0)==>CONTINUE,DO NOT INIT
$ECADSOK EQU   X'40'               (ECFLAG0)==>RELOCATION&LIMIT @'S OK
$ECEOF   EQU   X'20'               (ECFLAG0)==>EOF ON CARD READER
$ECPROT  EQU   X'10'               (ECFLAG0)==> ABSOLUTE PROTECT MODE
*              I.E. THIS FLAG MEANS FETCH PROTECT IN ADDITION TO STORE*
$ECSPIEA EQU   X'08'               (ECFLAG0)==> EXECUT SPIE IN EFFECT
$ECSPIEB EQU   X'04'               (ECFLAG0)==> REMOVE SPIE BEFORE EXIT
         SPACE 1
$ECBROUT EQU   2                   (ECFLAG1)==> BRANCH OUT OF RANGE
$ECTIMEX EQU   4                   (ECFLAG1)==> TIME COUNT EXCEEDED
$ECREADR EQU   6                   (ECFLAG1)==> ATTEMPT READ PAST EOF
$ECRECEX EQU   8                   (ECFLAG1)==> RECORDS EXCEEDED
$ECABEND EQU   10                  (ECFLAG1)==> USER REQUESTED ABEND
$ECBRN14 EQU   12                  (ECFLAG1)==> NORMAL RETURN (R14)
         SPACE 1
$ECREGS  EQU   B'00000001'         (ECFLAG3)==>PRINT REGS IN DUMP
$ECDINST EQU   B'00000010'         (ECFLAG3)==>PRINT INST TRACE IN DUMP
$ECSTORG EQU   B'00000100'         (ECFLAG3)==> PRINT USER STORAGE
$EC$JRM  EQU   B'10000000'         (ECFLAG3)==> SPECIAL JRM DEBUG
         SPACE 1
$ECPRBST EQU   X'01'               (ECKYAMWP) ==> PROBLEM STATE PROG
         SPACE 1
*              REPLACE MONITOR FLAGS, SET BY RFLAG= AND XREPL INSTR.
ECR$CARD EQU   B'00000001'         (ECRFLAG+1)PRINT CARDIMAGE
ECR$REGA EQU   B'00000010'         (ECRFLAG+1)PRINT REGS BEFORE ENTRY
ECR$REGB EQU   B'00000100'         (ECRFLAG+1)PRINT RESULTS FROM REAL P
ECR$REGC EQU   B'00001000'         (ECRFLAG+1)PRINT RESULTS OF USER PRG
ECR$REGD EQU   B'00010000'         (ECRFLAG+1) PRT IF USER CALLS
ECR$ERRC EQU   B'10000000'         (ECRFLAG+1)=> ERROR FOUND IN REGS
         SPACE 1
*              FLOATING POINT REGISTER SAVE AREA                      *
ECFPREGS DS    4D                  DUMMY FLOATING POINT REGS
ECDWORK  EQU   ECFPREGS            WE CAN USE FP REGS AS WORK AREA
         SPACE 1
*              SIMULATED GENERAL PURPOSE REGISTERS                    *
ECREGS   DS    16F                 FAKE REGISTERS FOR INTERPRETER
ECREG1   EQU   ECREGS+4            FAKE R1
ECREGRA  EQU   ECREGS+4*RA         FAKE RA
ECREG12  EQU   ECREGS+48           FAKE R12(RAT)
ECREG13  EQU   ECREGS+52           FAKE R13
ECREG14  EQU   ECREGS+56           FAKE R14, RETURN @ REG
ECREG15  EQU   ECREGS+60           FAKE R15, ENTRY PT REG
         DS    F                   DUMMY REG, SIMPLIFIES SINGLE SHIFTS
*              NECESSARY TO USE CURRENT CODE FOR SLL 15,1, FOR EXAMPLE
ECR14SAV DS    A                   ORIGINAL RETURN @ FOR COMPARISON
ECZER1   EQU   *                   BEGINNING FOR BLOCK ZEROING
         SPACE 1
*              SIMULATED PROGRAM STATUS WORD                          *
ECPSW    DS    0D                  PSW FOR PROG
ECSYSMSK DS    C                   SYSTEM MASK
ECKYAMWP DS    C                   PROT KEY, AMWP FIELD
ECINTCOD DS    H                   INTERRRUPT CODE
ECILCMSK DS    C                   ILC-CC-PROGRAM MASK
ECPSWIAD DS    CL3                 INSTRUCTION ADDRESS
         SPACE 1
*              CONTROL FLAGS                                          *
ECFLAGS  DS    0F                  A FULLWORD FOR FLAGS
ECFLAG0  DS    C                   MAJOR CONTROL BITS
ECFLAG1  DS    C                   USED TO RETURN SPECIAL ERROR CODES
ECFLAG2  DS    C                   CONTROLS DEBUG MODE SNAPS
ECAJ     DS    0F                  BEGIN AJOBCON FLAGS, ALIGN
ECOIECF  DS    F                   ORIGINAL IECF (&$EXINT ONLY)
ECFLAG3  DS    B                   DUMP CONTROL FLAG (AJODMPF)
ECFLAG4  DS    B                   MISC. EXEC FLAGS (AJOEXEC)
ECFLAG5  DS    B                   MISC EXEC FLAGS (AJOEXEFA)*FUTURE***
ECAJL    EQU   *-ECAJ              LENGTH OF FLAGS GROUP MUST = AJECL
ECRFLAG  DS    H                   REPLACE MONITOR FLAG
         SPACE 1
ECERRAD  DS    A                   @ SPECIAL ASSIST COMPLETION MESSAGE
ECSVCADS DS    A                   @ ADDRESS LIST OF SVC'S,=0 IF NONE
ECZER$L  EQU   *-ECZER1            LENGTH OF AREA FOR BLOCK ZEROING
ECFADHC  DS    A                   HIGH @ PROG + SAVE = ECFADH-256
*              ECILIMT-ECILIMP MUST BE IN ORDER GIVEN, USED IN LM     *
ECILIMT  DS    F                   INST COUNT LIMIT (DECREMENTED)
ECILIMP  DS    F                   PERMANENT INSTRUCTION COUNT LIMIT
         SPACE 1
*              ECRDLIML-ECRDLIMH GIVE DUMP LIMTS. MUST BE IN GIVEN ORDR
ECRDLIML DS    A                   REAL DUMP LIMIT LOW(INIT=ECRADL)
ECRDLIMH DS    A                   REAL DUMP LIMIT HIH(INIT=ECRADH)
         SPACE 1
*              ADDRESS VALUES DESCRIBING LIMITS OF USER PROGRAM.      *
*              **NOTE** THEY MUST BE IN THE ORDER GIVEN BELOW.        *
ECRADL   DS    F                   REAL LOWEST ADDRESS OF PROGRAM
ECRADH   DS    F                   REAL HIGHEST ADDRESS
ECRELOC  DS    F                   RELOCATION CONTINUALLY APPLIED
ECFENTER DS    A                   USER PROGRAM FAKE ENTRY POINT @
ECFADL   DS    F                   FAKE LOWEST ADDRESS OF PROGRAM
ECFADH   DS    F                   FAKE HIGHEST ADDRESS OF PROGRAM
         SPACE 1
ECINSTAC DS    (EC$STACK)CL16      INSTRUCTION STACK
ECRSTK   DS    F                   SAVE WORD FOR RSTK POINTER
ECSAVE1  DS    A                   @ FAKE SAVE AREA FOR USER PROG
ECPICA   DS    F                   SAVE WORD FOR PREVIOUS PICA
ECTSAVE  DS    16F                 FOR SAVING REGS WHEN DOING CALLS
         AIF   (NOT &$EXINT).ECOVER
         SPACE 2
EC$BRSTC EQU   10                  SIZE OF BRANCH STACK (# OF SLOTS)
ECBRSTAC DS    (EC$BRSTC)CL16      BRANCH STACK
ECBSTK   DS    F                   SAVE WORD FOR BSTK POINTER
ECBCUR   DS    F                   CURRENT STACK PTR SAVED HERE
         AIF   (&$EXINT EQ 0).ECNOEXT   SKIP IF NO EXTENDED INTERPRETER
         SPACE 5
* * * * * * * * * * * * * * ##### EXTENSION ##### * * * * * * * * * * *
*                                                                     *
*        IMPORTANT-->  THIS SECTION IS AN EXTENSION TO THE            *
*        ECONTROL DSECT AND IS USED BY THE OPTIONAL ASSIST            *
*        INTERPRETER.  IT CONTAINS FLAGS, EQUATES, AND                *
*        ADDRESSES FOR USER INTERRUPT HANDLING AND OTHER              *
*        USER OPTIONS.  SEE PSEUDO-INSTRUCTION XOPC.                  *
*                                                                     *
*        NOTE:  DATA IN THIS AREA IS ACCESSABLE TO THE USER           *
*        PROGRAMMER BY MEANS OF VARIOUS XOPC INSTRUCTION              *
*        CODES, AND IN GENERAL BY XOPC 12 & 13.                       *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 2
ECPRCB   EQU   *
*              FLAGS USED BY THE OPTIONAL INTERPRETER
*
*              FLAGS FOR OPTIONS-IN-EFFECT CHECKING
*              NOTE: ECPRCBF1 WILL NOT BE USED FOR ANY OTHER
*                    FLAG TYPES.
ECPRTRCE EQU   B'00000001'         (ECPRFLG1)==> TRACE = ON
ECPRMODC EQU   B'00001000'         (ECPRFLG1)==> MODIFICATION CHECKING X
                                                 = ON
ECPRIECF EQU   B'00000010'         (ECPRFLG1)==> COUNT FACILITY ON
ECPRCTON EQU   B'00000100'         (ECPRFLG1)==> HAS COUNT ON BEFORE?
ECPRCTOF EQU   B'00000000'         (ECPRFLG1)==> COUNT FACILITY OFF
ECPRNOSP EQU   B'00001000'         (ECPRFLG1)==> NO SPACE FOR COUNT FAC
*
*              FLAGS FOR MACHINE EMULATION (ECPRCBF2 LOW ORDER NIBBLE)
*              AND OTHER DATA.
*
*              NOTE: THE FLAGS FOR MACHINE EMULATION CAN BE CHANGED
*              DYNAMICALLY BY THE USER PROGRAMMER BY WAY OF THE XOPC
*              INSTRUCTION.  THIS ALLOWS RUN-TIME CONTROL OF EMULATION
*              OPTIONS, SINCE THESE FLAGS ARE CHECKED BEFORE THE
*              INTERPRETATION OF EACH USER INSTRUCTION.  IF THE USER
*              PROGRAM SCREWS UP THESE FLAGS, IT MAY BE
*              TERMINATED 'CONFUSINGLY' WITH AN OC-1 ON A VALID
*              INSTRUCTION.
ECEM360  EQU   B'00000100'         (ECPRFLG2)==>  MACHINE = 360
ECEM370  EQU   B'00001000'         (ECPRFLG2)==>  MACHINE = 370
ECSUPRST EQU   B'01000000'         (ECPRFLG2)==> IN SUPERVISOR STATE
ECALNCHK EQU   B'10000000'         (ECPRFLG2)==> ALIGNMENT CHECKING=ON
ECSPISET EQU   B'10000000'         (ECPRFLG3)==> A PSEUDO SPIE IS SET
ECINHDST EQU   B'01000000'         (ECPRFLG3)==> INTERRUPT HANDLING ST
ECNOSPI  EQU   B'00000000'         (ECPRFLG3)==> NO SPIE INTERRUPT SET
ECLKADR  EQU   B'00000001'         (ECPRFLG4)==> CLOCK EXIT ADDR SET
*              PRCB STORAGE BEGINS HERE
ECPRFLG1 DS    B
ECPRFLG2 DS    B
ECPRFLG3 DS    B
ECPRFLG4 DS    B
ECPRFLG5 DS    B
ECPRFLG6 DS    B
ECPRFLG7 DS    B
ECPRFLG8 DS    B
*              INSTRUCTION TRACE AND MONITOR ADDRESSES
*              ***** NOTE: DO NOT CHANGE THE ORDER OF THESE SOURCE
*                          RECORDS
ECPRTRAL DS    A                   BEGINNING (LOW) @ OF TRACE         M
ECPRTRAH DS    A                   ENDING (HIGH) @ OF TRACE           M
ECPRMODL DS    A                   BEGINNING (LOW) @ OF CHECK FACILITY
ECPRMODH DS    A                   ENDING (HIGH) @ OF CHECK FACILITY
*              INSTRUCTION COUNTER (PSEUDO-CLOCK) INFORMATION
ECPRCLOK DS    F                   CLOCK (DECMTD BY 1 FOR EACH INSTR)
ECPRCMPR DS    F                   COMPARATOR (CHECKED AGAINST CLOCK   X
                                   FOR INTERRUPT TEST)
ECPRCLEA DS    A                   USER SPECIFIED CLOCK EXIT ADDRESS
*              EXIT ADDRESS FOR USER SPECIFIED PSUEDO-SPIE HANDLING
*              (IF NOT SPECIFIED, THIS ADDRESS WILL BE ZERO.)
ECPRSCDE DS    F                   USER SPECIFIED SPIE CODE MASK
ECPRSPIE DS    A                   EXIT ADDRESS FOR PSUEDO-SPIE XOPC 0
*              2 WORD SAVE AREA FOR INTERRUPT (REGS 0 - 1)
ECPRIRGS DS    2F                  DEFINE 2 WORD SAVE AREA
*              STORAGE FOR IECF (BY ADDRESS) INFORMATION
ECPRICA  DS    A                   BEGIN @ OF IECF (BY ADDR) COUNTERS
ECPRICAL DS    F                   LENGTH OF COUNTING AREA
ECPRICL  DS    A                   IECF LOW @ COMPARATOR (BEGINNING)  M
ECPRICH  DS    A                   IECF HIGH @ COMPARATOR (ENDING)    M
*              MISCELLANEOUS EQUATES FOR THE OPTIONAL INTERPRETER
EISSINST EQU   B'11000000'         IDENTIFIES SS INSTRUCTIONS
ECPROPON EQU   ECPRTRCE+ECPRIECF
EC#XOPC  EQU   22                  # OF THE MAX LEGAL XOPC CODE
ECREG0   EQU   ECREGS              FAKE REG 0
ECREG2   EQU   ECREGS+8            FAKE REG 2
         SPACE 1
ECPRWORK DS    8F                  WORK AREA FOR FUTURE GENERAL USE
         SPACE 1
ECPRCB$L EQU   *-ECPRCB            LENGTH OF PRCB
.ECNOEXT  ANOP
.ECOVER  ANOP
         DS    0D
EC$LEN   EQU   *-ECONTROL          LENGTH OF ECONTROL DSECT
         TITLE '*** ECSTACKD DSECT - ECONTROL INSTRUCTION STACK ***'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: ECSTACKD   SINGLE ENTRY IN ECONTROL INSTRUCTION STACK     *
*        THE ECONTROL INSTRUCTION STACK IS A CIRCULAR LINKED LIST     *
*        WHICH ALWAYS CONTAINS DATA ON UP TO THE LAST 10 INSTRUCTIONS *
*        INTERPRETED DURING EXECUTION.  IT IS FILLED IN BY EXECUT, AND*
*        IS USED BY XXXXSNAP TO PROVIDE THE INSTRUCTION TRACE PART    *
*        OF A USER COMPLETION DUMP.                                   *
*        LOCATION: INSIDE AREA ECINSTAC IN DSECT ECONTROL.            *
*        NAMES: EC------     (SAME AS ECONTROL NAME CHARACTERS)       *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
ECSTACKD DSECT
ECSTENT  DS    0CL16               INST STACK ENTRY
ECSTLINK DS    F                   ADDRESS OF NEXT STACK ENTRY
ECSTIADD DS    F                   INSTRUCTION ADDRESS
ECSTCCPM DS    H                   CON-CODE & PROGRAM MASK
         SPACE 1
ECSTINST DS    0CL6                UP TO 6 BYTES OF INSTRUCTION
ECOP     DS    C                   OPCODE
ECM1R2   DS    0C                  M1,R2 FIELD FOR BC'S
ECR1R2   DS    0C                  R1,R2 FIELD FOR RR INSTRUCTIONS
ECR1X2   DS    0C                  FIELD FOR RX INSTRUCTIONS
ECR1R3   DS    0C                  FIELD FOR RS INSTRUCTIONS
ECR1M3   DS    0C                  FIELD FOR RS INSTRUCTIONS
ECI2     DS    0C                  FIELD FOR SI INSTRUCTIONS
ECL1I3   DS    0C                  FIELD FOR SRP INSTRUCTION
ECOPEX   DS    0C                  2ND BYTE OF EXTENDED OP CODE
ECL1L2   DS    C                   FIELD FOR ALL SS INSTRUCTIONS
ECBD     DS    H                   1ST OR ONLY BASE-DISPLACEMENT FIELD
ECB2D2   DS    H                   2ND BASE-DISP(SS & SPECIALS ONLY)
         TITLE '*** ASSIST - MAIN CONTROL - OVERALL ***'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> CSECT: ASSIST     MONITOR CONTROL PROGRAM FOR THE ASSIST SYSTEM  *
*        ENTRY CONDITIONS                                             *
*   R1= @ POINTER TO OS LENGTH/PARM FIELD AREA.                       *
*        CALLS AOBJIN,AODECK,APARMS,EXECUT,MPCON0,REENDA,REINTA       *
*        CALLS XXXXFINI,XXXXINIT                                      *
*        USES DSECTS: AJOBCON,AVWXTABL,ECONTROL                       *
*        USES MACROS: $DBG,$PRNT,$RETURN,$SAVE,$SORC,$TIRC            *
*        USES MACROS: ASPAGE,ASPRNT,ASRECL,ASTIME,ASTIMR              *
*        USES MACROS: FREEMAIN,GETMAIN,STIMER,TTIMER,XCALL,XSNAP,WTL  *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
ASSIST   CSECT
* * * * * * * * REGISTER USAGE IN ASSIST MAIN PROGRAM * * * * * * * * *
*   R0,R1,R15  USUALLY LOCAL WORK REGISTERS. PARAMETER REGS FOR SOME. *
*   R9 = INTERNAL LINK REGISTER FOR TIME/RECORDS/PAGES CONTROL .      *
*   R10= ADDRESS OF EXECUTION CONTROL BLOCK ECONTROL (PART OF TIME).  *
*   R11= ADDRESS OF JOB CONTROL TABLE AJOBCON(ALWAYS).                *
*   R12= ADDRESS OF ASSEMBLER CONTROL TABLE AVWXTABL(PART OF TIME).   *
*   R13= SAVE AREA PTR AND BASE REGISTER ALSO.                        *
*   R14= EXTERNAL LINK REGISTER.  INTERNAL LINK REGISTER FOR LOWEST   *
*              LEVEL INTERNAL SUBROUTINES.                            *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         $DBG  ,NO                 NO DEBUG,SINCE NO AVWXTABL
         AIF   (&$ASMLVL).ASXSAVE  SKIP FOR OS $SAVE
         BALR  R15,0               SET UP TEMPORARY ADDRESSABILITY(DOS)
         USING *,R15               INFORM ASSEMBLER OF R15 USING
         CNOP  0,4                 FULLWORD ALIGNMENT FOR FUTURE SAVE
         BAL   R13,ASSAVE+72       BR AROUND SAVE,SET R13 = @ SAVEAREA
         USING *,R13               SHOW R13 AS ASSIST BASE REGISTER
         DROP  R15                 KILL USING
ASSAVE   DC    18F'0'              SAVEAREA FOR CSECT ASSIST
.ASXSAVE AIF   (NOT &$ASMLVL).ASNXSAV  SKIP IF UNDER DOS GENERATION
         $SAVE RGS=(R14-R12),BR=R13,SA=ASSAVE
.ASNXSAV ANOP
         MVC   ASPARMSV,0(R1)      MOVE @ LENGTH/PARM FIELD OVER
         ASTIMR 00,2               INITIALIZE TIMER IF &$TIMER=2
         XCALL XXXXSPIN            INITIALIZE PROGRAM INTERRUPT CODE
         LA    R11,ASJOBCON        GET @ FOR AJOBCON
         USING AJOBCON,R11         NOTE MAIN TABLE USING
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              INITIALIZE AJOBCON.  CALL XXXXINIT TO INITIALIZE       *
*        INPUT/OUTPUT PROCESSORS.  (I.E. DO OPENS, SET FLAGS.  )      *
*        MAKE SURE BOTH LINE PRINTER (PR) AND SOURCE CARD READER (SO) *
*        OPENED SUCCESSFULLY.  QUIT IMMEDIATELY IF THEY DIDN'T.       *
*        CALL APARMS TO ANALYZE PARM FIELD IF ANY,SET FLAGS IN AJOBCON*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
ASJINIT  EQU   *                   SECTION TO INIT AJOBCON
         XC    AJOZER1(AJOZER$L),AJOZER1    ZERO OUT WHOLE SECTION
         SPACE 1
ASJOBINT EQU   *                    ENTRY FOR BEGINNING OF NEW $JOB
*              CALL PARM FIELD ANALYSIS ROUTINE TO SET FLAGS.         *
ASJPARMS EQU   *
*              ***** LIMIT PARMS & RESETABLE DEFAULTS *****
         LA    R9,ASPARLIM         SHOW @ PARM FIELD
         LA    R10,ASPARL$L        SHOW LENGTH OF PARM FIELD
         MVI   AJOAPMOD,AJOAPRSE   SHOW THIS IS RESET CALL
         MVI   AJOAPSET,APCSETLD   SHOW LIMIT/DEFAULT CALL TYPE
         XCALL APARMS              CALL PARM FIELD SCANNER
         AIF   (NOT &$ASMLVL).ASPARMC  NO // EXEC PARM FIELD
         SPACE 1
*              ***** REAL PARM FIELD ANALYSIS *****
         L     R9,ASPARMSV         GET PTR TO LENGTH-PARM FOR APARMS
         LH    R10,0(R9)           GET LENGTH OF THE REAL PARM
         LA    R9,2(R9)            GET @ ACTUAL PARM FIELD
         MVI   AJOAPMOD,AJOAPMOV   SHOW PARM SHOULD BE MOVED OVER
         MVI   AJOAPSET,APCSETP    SHOW THIS IS THE REAL PARM FIELD NOW
         XCALL APARMS              CALL SCANNER PROGRAM
.ASPARMC ANOP
         SPACE 1
         TM    AJOSTEP,AJOMSINT    HAVE GONE THRU 1-TIME INIT ALREADY
         BO    ASNOT1T             YES, SO DON'T DO IT AGAIN.
         SPACE 1
*              ***** ONE-TIME-PER-BATCH INITIALIZATION *****
         BAL   R14,ASMSINIT        MAIN STORAGE INITIALIZATION
         TM    AJOMODE,AJNSYSIN    WAS NOSYSIN SPECIFIED
         BO    ASZERR2             NOSYSIN, SO QUIT NOW. NO SOURCE CRDS
         SPACE 1
*              HAVE DCB'S OPEND FOR PRINTER, SOURCE RDR. CHECK FOR OK.
         XCALL XXXXINIT            CALL I/O INITIALIZER
         TM    AJIOPR,AJIOPEN      DID PRINTER OPEN RIGHT
         BZ    ASZERR1             NO,GO DO MESSAGE AND QUIT
         TM    AJIOSO,AJIOPEN      DID SOURCE CARD RDR OPEN RIGHT
         BZ    ASZERR2             NO, BRANCH AND QUIT IMMEDIATELY
ASNOT1T  EQU   *                   ENTER FOR EVERY-TIME PROCESSING
         TM    AJOMODE,AJOBATCH    WAS THIS BATCH RUN
         BZ    ASPARFIN            NO, SKIP TO PUT IN FINAL DEFAULTS
         AIF   (NOT &$DATARD).ASNRDX   SKIP IF NO DATA RDR EXISTS
         OI    AJIORE,AJIODFLT     SINCE BATCH, MAKE SURE  NO DATA RDR
.ASNRDX  ANOP
         SPACE 1
*              ***** BATCH MODE - GET $JOB CARD AND ITS PARMS *****
         AIF   (NOT &$MACSLB).ASSNOMC
         XCALL XXXXLBED         MAKE SURE THAT XXXXSORC GETS CARD RIGHT
.ASSNOMC ANOP
         MVI   AJOBTRQ,AJO$J       SHOW THAT $JOB CARD IS DESIRED     J
         BAL   R14,ASFLUSH         GO GET IT; RETURN ONLY IF FOUND    J
*              ***** $JOB CARD OR EQUIV FOUND. PROCESS PARM.
         MVI   AJOAPMOD,AJOAPMOV   SHOW PARM SHOULD BE MOVED OVER
         MVI   AJOAPSET,APCSETU    SHOW USER SETTING THIS TIME
         LA    R9,AJOJCLPM         SHOW @ PARM FIELD ON $JOB CARD
         LA    R10,80-(AJOJCLPM-AJOJCLCD)   LENGTH OF PARM FIELD(MAX)
         XCALL APARMS              CALL PARM ANALYSIS ROUTINE
         MVC   AJOPARM(80),AJOJCLCD         MOVE WHOLE JCL CARD IN INST
         SPACE 1
*              ***** DEFAULT PARM FIELDS - DON'T OVERRRIDE SET *****
ASPARFIN EQU   *                   SKIP HERE IF NOBATCH
         MVI   AJOAPMOD,AJOAPDEF+AJOAPFIN   DEFAULT CALL, ALSO LAST 1
         MVI   AJOAPSET,APCSETLD   SHOW LIMIT/DEFAULT TYPE SETTING
         LA    R9,ASPARDF          SHOW DEFAULT PARMS
         LA    R10,ASPARD$L        SHOW LENGTH OF DEFAULT PARM LIST
         XCALL APARMS              MAKE FINAL CALL TO PARM ROUTINE
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              TIME,RECORDS,PAGES INITIALIZATION FOR ASSEMBLY.        *
*              PRINT ASSIST HEADER + 1 PARM FIELD.                    *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         ASRECL 04                 CALL RECORD INIT CODE
         ASPAGE 04                 CALL PAGE HANDLING, IF EXISTS
         ASTIMR  04,1              SET UP TIME/INST COUNT LIMITS
         SPACE 1
*              PRINT HEADER.  PRINT REAL PARM OR $JOB PARM AREA
ASPRHEAD EQU   *                   ENTRY FOR MULTIPLE ASSEMBLYS/EXEC
         ASPRNT ASH1HD,ASH1H$L     PRINT BEGINNING HEADER
         ASPRNT AJOPARMA,AJOP$L+1  PRINT THE PARM FIELD
         AIF   (&$DEBUG).ASDA      SKIP IF PRODUCTION
         XSNAP LABEL='AFTER TIME/RECORDS SET',IF=(AJODEBUG,O,8,TM),    X
               STORAGE=(*AJOPARMA,*AJOBCON+AJOB$L)
.ASDA    ANOP
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              SET UP ADDRESSES FOR CALL TO THE ASSIST ASSEMBLER.     *
*        ALSO SET UP TIME,SO CAN DO TIMING FOR THE ASSEMBLER          *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
ASASMCL  EQU   *                   SECTION TO CALL ASSEMBLER
         MVC   AJOTADL(8),AJOPADL  REINITIALIZE TEMP TO PERMANENTS
         SPACE 1
ASASMCLR EQU   *                   ENTRY LABEL FOR REPLACE PHAS B
         L     RAT,AJOVWXPT        INIT ADCON FOR ASSEMBLER TABLE
         USING AVWXTABL,RAT        NOTR POINTER IN R12
         ST    R11,AVAJOBPT        INIT POINTER TO AJOBCON.
         MVC   AVADDLOW(8),AJOTADL MOVE CURRENT CORE LIMITS OVER
         MVC   AVNERR(AJOAVL),AJONERR       GIVE FLAGS TO ASSEMBLER
         AIF   (NOT &$OBJIN).ASNOBJ1        SKIP IF NO OBJECT DECK IN
         SPACE 1
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              OBJECT DECK INPUT CODE                                 *
*        IF PARM=OBJIN, CALL AOBJIN TO LOAD DECK, SKIPPING EXECUTION  *
*        IF THERE IS NOT ENOUGH ROOM FOR IT.  AOBJIN SETS UP VALUES   *
*        IN AVWXTABL JUST AS THOUGH THERE HAD BEEN AN ASSEMBLY.       *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         TM    AJODECKF,AJOOBJIN   WAS THERE OBJECT DECK,INSTD OF SOURC
         BZ    ASOBJINN            NO, NO OBJECT DECK-SKIP TO ASSEMBLE
         AIF   (&$REPL EQ 0).ASNRPX    SKIP IF NO REPLACEMENT
         TM    AJOMODE,AJOREPLF    REPLACE RUN
         BO    ASOBJINN            YES, SO DON'T LET HIM READ DECK IN
.ASNRPX  ANOP
         XCALL AOBJIN              CALL OBJECT INPUT ROUTINE
         TM    AVTAGS1,AJNLOAD     NOLOAD SET IF SOMETHING WRONG
         BO    ASNOEXEC            BAD DECK - SKIP EXECUTION
         B     ASOBJINX            OK, SKIP OVER ASSEMBLY AND CONTINUE
ASOBJINN EQU   *                   SKIP HERE IF NO OBJECT INPUT
.ASNOBJ1 ANOP
         AIF   (&$REPL EQ 0).ASNREP1        SKIP IF NO REPLACEMENT
*              IF REPLACEMENT POSSIBLE, CALL REINTA TO SET FLAGS,ADCONS
         XCALL REINTA              CALL REPLACE PRE-ASSEMBLY INIT
.ASNREP1 SPACE 1
         SPACE 1
*              FLAG ASSEMBLY, CALL ASSEMBLER, UNFLAG ASSEMBLY.
         OI    AJOSTEP,AJOSASM     SHOW WE'RE IN ASSEMBLER NOW
         XCALL MPCON0              CALL THE ASSEMBLER
         NI    AJOSTEP,255-AJOSASM SHOW WE FINISHED ASSEMBLER
         SPACE 1
         ASTIMR 12,1               CALL FOR ASSEMBLY TIME,RATE PRINTING
         SPACE 1
         AIF   (&$REPL EQ 0).ASNREP2        SKIP IF NO REPLACEMENT
*              IF REPLACEMENT POSSIBLE, CALL REENDA TO CHANGE ADCONS
         XCALL REENDA              POST-ASSEMBLY PROCESSOR
.ASNREP2 SPACE 1
         TM    AVTAGS1,AJNLOAD     WAS NO LOAD FLAG SET
         BO    ASNOEXEC            EITHER USER DIDN'T WANT, OR ERRS
ASOBJINX EQU   *                   EXIT HERE IF OBJECT INPUT
         AIF   (NOT &$DECK).ASNDECK         SKIP IF NO DECKS PUNCHED
         SPACE 1
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              OBJECT DECK PUNCH CODE                                 *
*        IF PARM=DECK, PUNCH THE CURRENT USER PROGRAM OUT, AS LONG    *
*        AS IT WASN'T ONE JUST READ IN FOR PARM=OBJIN.                *
*        ALSO, DON'T PUNCH IF IN REPLACE RUN.                         *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         TM    AJOASMF2,AJODECK    DID USER WANT AN OBJECT DECK
         BZ    ASDECKN             NO, SKIP
         TM    AJODECKF,AJOOBJIN   DID HE JUST READ IT IN
         BO    ASDECKN             YES, IDIOT USER-DON'T PUNCH IT
         AIF   (&$REPL EQ 0).ASNREDK        SKIP IF NO REPLACEMENT
         TM    AJOMODE,AJOREPLF    ARE WE IN REPLACE RUN
         BO    ASDECKN             YES, DON'T ALLOW DECK PUNCHED
.ASNREDK ANOP
         XCALL AODECK              CALL TO PUNCH OBJECT DECK
ASDECKN  EQU   *                   SKIP LABEL OVER OBJECT DECK PUNCH
.ASNDECK ANOP
         SPACE 2
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              PRE-EXECUTION CONTROL CARD CHECKING                    *
*        IF IN BATCH MODE, FLUSH CARDS UNTIL A $ENTRY CARD FOUND,     *
*        AND POSSIBLY ALLOW EXECUTION, OR A $JOB CARD FOUND, IN       *
*        WHICH CASE GO BACK FOR NEXT JOB.  $STOP CARD FOUND WILL NOT  *
*        RETURN HERE ANYWAY.    NOTE THAT EXECUTION IN BATCH MODE     *
*        CURRENTLY REQUIRES A $ENTRY CARD.                            *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         TM    AJOMODE,AJOBATCH    ARE WE IN MIDDLE OF BATCH RUN
         BZ    ASEXNBAT            NO, NO BATCH, DON'T READ ANY CARDS
         SPACE 1
         AIF   ('&$BTCC(3)' EQ '').ASBTCC1  SKIP IF NO $ENTRY NEEDED  J
         MVI   AJOBTRQ,AJO$E       SHOW THAT $ENTRY IS WHAT WE WANT   J
         BAL   R14,ASFLUSH         GO GET; IF RETURN, IT EXISTS       J
         CLI   AJOBTYP,AJO$E       WAS IT ACTUALLY $ENTRY             J
         BE    ASEXNBAT            YES, CONTINUE                      J
         OI    AJIOSO,AJIOSORR     $JOB- SET FOR REREAD, FINISH JOB   J
         B     ASNOEXEC            GO TO END THIS JOB, PICK UP $JOB   J
.ASBTCC1 ANOP
ASEXNBAT EQU   *
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              PREPARE ADDRESSES AND ECONTROL BLOCK FOR EXECUTION     *
*        OF USER PROGRAM BY EXECUT.  SET UP ECONTROL APPROPRIATELY.   *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
ASEXECAL EQU   *
         LM    R0,R5,AVRADL        GET THE 6 @ WORDS FROM AVWXTABL
         LA    R10,AVECONTR        OVERLAP ECONTROL&UNNEEDED AV SECT
         DROP  RAT                 REMOVE USING FOR TIME BEING
         AIF   (&$REPL EQ 0).ASNRP1E        SKIP IF NO REPLACE
         SPACE 1
*              IF IN REPLACE MODE A, THE ECONTROL BLOCK CANNOT BE
*              LOCATED IN MIDDLE OF AVWXTABL, SO ALLOCATE SPACE FOR
*              IT AT HIGH END OF DYNAMIC AREA INSTEAD.
         TM    AJOMODE,AJOREPLF+AJOREPHB    ARE WE IN REPL, OR PHASE B
         BNM   ASREPLBM            BRANCH-NOT PHASE A IN ANY CASE
         SPACE 1
         L     R10,AJOTADH         GET CURRENT HIGH POINTER
         SH    R10,=AL2(EC$LEN)    SPACE FOR ECONTROL
         ST    R10,AJOTADH         SAVE BACK, ALSO LEAVE IN R10
ASREPLBM EQU   *                   BRANCH HERE IF NOT REPL PHASE A
.ASNRP1E SPACE 1
         USING ECONTROL,R10        NOTE EXECUTION TIME USING
         XC    ECZER1(ECZER$L),ECZER1       ZERO OUT AREA IN ECONTROL
         LR    R1,R5               MOVE HIGHEST FAKE @ OVER
         SR    R1,R4               GET LENGTH OF PROGRAM
         AR    R1,R0               GET UPPER @ LIMIT FOR PROGRAM
         LR    R6,R1               SAVE ENDING @ OF PROGRAM
         LA    R1,72+256(R1)       INCREMENT ENDING @,SAVAR+BUFFER
         C     R1,AJOTADH          IS THERE ENOUGH ROOM FOR SAVA,BUFFR
         BH    ASEXOVSP            NO,BRANCH OUT, ABORT EXECUTION
         SPACE 1
         MVI   0(R6),$PRGFILC      PUT IN FILL CORE CHARACTER
         MVC   1(71,R6),0(R6)      PROPAGATE FILL THRU 1ST SAVE AREA
         MVC   72(256,R6),64(R6)   FILL DUMMY 256 BYTES ALSO
         XC    4(4,R6),4(R6)       ZERO INITIAL BACKWARDS SA PTR (HSA)
         STM   R0,R5,ECRADL        SAVE ALL THE @ POINTERS IN ECONTROL
         STM   R0,R1,ECRDLIML      STORE ECRADL-ECRADH==> ECRDLIML-H
         SPACE 1
         ST    R1,AJOTADL          STORE BACK UPDATED LOWER LIMIT
         ST    R6,ECSAVE1          SAVE @ DUMMY SAVE AREA,FOR DUMPS
         SPACE 1
         S     R6,ECRELOC          SUBTRACT THE RELOCATION FACTOR
         L     R7,=F'-100000'      SET UP FOR WEIRD RETURN @
         LR    R8,R3               MOVE TO STORE IN FAKE R15- EPA
         STM   R6,R8,ECREG13       STORE FAKE R13-R14-R15 INTO FAKE RGS
         MVI   ECREGS,$PRGFILR     PUT FILL REGISTER CHAR INTO 1ST BYTE
         MVC   ECREGS+1(51),ECREGS PROPAGATE 4'S THROUGH REGS 0-12
         MVC   ECFPREGS(32),ECREGS PUT 4'S IN FP REGS ALSO
         MVC   ECILIMP,AJOINSL     MOVE INSTRUCTION LIMIT OVER
         MVC   ECAJ(ECAJL),AJOEC   MOVE EXECUTION FLAGS OVER
         MVI   ECSYSMSK,X'FF'      SET CHANNEL MASKS TO INTERRUPT CEH
         MVI   ECKYAMWP,X'C5'      SET KEY-C, AMWP=0101           CEH
         SPACE 1
         OI    ECFLAG0,$ECSPIEB    NOTE WE WANT SPIE REMOVED AT END
*              IF 'RELOC' OPTION USED, ALLOW STORE-ONLY PROTECT
         AIF   (NOT &$RELOC).ASNRELC        SKIP IF NO RELOC MODE AVAIL
         TM    AJOASMF,AJORELOC    DID USER ASK FOR RELOC MODE
         BO    *+8                 YES, SKIP, DON'T SET FETCH PROTECT
.ASNRELC ANOP
         OI    ECFLAG0,$ECPROT     SHOW BOTH FETCH/STORE PROTECT
         SPACE 1
         XCALL XXXXSNIN            HAVE XXXXSNAP INIT CALL #
         ST    R10,AJOECOPT        SAVE @ ECONTROL, IN CASE TIMER
         AIF   (&$DEBUG).ASXS1     SKIP XSNAP IF NOT DEBUG MODE
         XSNAP LABEL='ECONTROL BEFORE EXECUT',IF=(AJODEBUG,O,2,TM),    #
               STORAGE=(*ECONTROL,*ECONTROL+EC$LEN)
         LM    R14,R15,ECRADL      GET STORAGE LIMITS
         XSNAP T=(NO,,1),LABEL='USER STORAGE BEFORE EXEC(FAKE ADDR)',  #
               STORAGE=(*0(R14),*0(R15)),IF=(AJODEBUG,O,4,TM)
.ASXS1   ANOP
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        EXECUTION CONTROL BLOCK PREPARATION COMPLETED.  MAKE SURE    *
*        THAT TIME OR RECORDS LIMITS HAVE NOT BEEN OVERRUN ALREADY.   *
*        IF NOT, THEN PRINT HEADER, SET TIMER, AND EXECUTE PROGRAM.   *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         TM    AJOMODE,AJOSOVRT+AJOSRECX    HAS ANY OVERRUN OCCURRED
         BNZ   ASNOEXEC            SKIP IF OVERRUN ALREADY. DON'T EXEC
         AIF   (&$REPL EQ 0).ASNREP3        SKIP IF NO REPLACEMENT
         TM    AJOMODE,AJOREPLF+AJOREPHB     TEST REPLACE STATUS
         BNM   ASREPLBZ            BR-EITHER NO REPLACE(Z) OR PHS B(O)
         OI    AJOMODE,AJOREPHB    WAS IN PHASE A, SET NOW TO B
         MVC   ECRFLAG,AJORFLAG    INITIALIZE THE FLAG VALUE
         ASPAGE 14                 GET PAGE CONTROL SET
         ASRECL 14                 GET RECORDS SET (LIKE EXEC)
         ASTIMR 14,1               SET TIMER, AS FOR NORMAL EXEC.
         B     ASASMCLR            RETURN TO RUN A REPLACED CSECT
ASREPLBZ EQU   *                   EXIT LABEL- NO REPLACE, PHASE B
.ASNREP3 SPACE 2
         ASPRNT ASHEXGO,L'ASHEXGO  PRINT PRE-EXECUTION HEADING
         SPACE 1
         ASPAGE 16                 SET PAGE LIMITS FOR EXECUTION
         ASRECL 16                 SET UP RECORD LIMITS FOR EXECUTION
         SPACE 1
*              FLAG EXECUTION, CALL EXECUT, UNFLAG EXECUTION.
         OI    AJOSTEP,AJOSEXEC    FLAG TO SHOW WE'RE IN INTERPRETER
         ASTIMR 16,1               SET TIMER, AFTER SHOWN IN EXEC PHASE
         XCALL EXECUT              CALL THE INTERPRETER
         NI    AJOSTEP,255-AJOSEXEC         SHOW FINISHED EXECUTION
         SPACE 1                                                      J
*              POST-EXECUTION PHASE - USE ALL DUMP LIMITS IN ORDER TO J
*              PREVENT UNNECESSARY LOSS OF MESSAGES.                  J
         OI    AJOSTEP,AJOSDUMP    SHOW NOW IN DUMP STEP              J
         ASRECL 20                 RECORD LIMIT; CLEAR AJOSRECX FLAG  J
         ASPAGE 20                 PAGE LIMIT, IF USED                J
         ASTIMR 18,0               PRINT INSTRUCTION COUNT/RATE
         ASTIMR 20,1               RESET TIMER FOR DUMP PROCESSING    J
*              IF 1 OR MORE DATA CARDS WAS NOT READ DURING EXECUTION, J
*              READ IT AND PRINT WITH MESSAGE TO THAT EFFECT.         J
         AIF   (NOT &$DATARD).ASNDRZZ  SKIP IF NO DATA RDR            J
         TM    AJIORE,AJIOPEN+AJIODFLT  WAS RDR OPEN, OR DEFAULT USED J
         BNZ   ASCARDRR            YES, SAFE TO DO $READ NOW          J
         MVC   AJOPARM(80+L'ASCARDMS),AJOBLANK   BLANK OUT WHOLE AREA J
         MVC   AJOPARM+L'ASCARDMS(27),=C'NO CARDS READ:FILE UNOPENED' J
         B     ASCARDMM
.ASNDRZZ ANOP
ASCARDRR $READ AJOPARM+L'ASCARDMS,80,ASNOMORC    READ, SKIP IF EOF    J
ASCARDMM MVC   AJOPARM(L'ASCARDMS),ASCARDMS  COPY MESSAGE OVER        J
         ASPRNT AJOPARMA,81+L'ASCARDMS  PRINT THE ASSEMBLED LINE      J
*              NOTE: ABOVE MESSAGE MAY OVERLAP INTO AJODWORK.  BUT OK.J
ASNOMORC EQU   *                   COME HERE IF NO CARDS UNREAD       J
         SPACE 2
*              DETERMINE WHETHER PROGRAM ENDED WITH A NORMAL RETURN OR*
*        AN ERROR. PRINT NORMAL MESSAGE IF IT WAS FLAGGED AS NORMAL.  *
         CLI   ECFLAG1,$ECBRN14    WAS RETURN NORMAL
         BNE   ASDUMPCL            NO, SO CALL DUMP ROUTINE
         ASPRNT ASNORMAL,L'ASNORMAL    PRINT NORMAL COMPLETION BY RET
         B     ASNOEXEC
         SPACE 1
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              USER PROGRAM DUMP PHASE                                *
*        SET UP CORRECT LIMITS FOR DUMP, THEN MAKE SPECIAL XSNAP      *
*        CALL WHICH PRODUCES THE FINAL DUMP, USING APPROPRIATE LIMITS.*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
ASDUMPCL EQU   *
         LM    R14,R15,ECRDLIML    ECRDLIML-ECRDLIMH - DUMP LIMITS
         XSNAP T=(PR,FL,10),STORAGE=(*0(R14),*0(R15))      FINAL DUMP
         B     ASNOEXEC            GO TO MAKE BATCH CHECK
         EJECT
*              ASEXOVSP - ENTERED IF STORAGE OVERFLOW.                *
ASEXOVSP ASPRNT ASEMSG,L'ASEMSG    PRINT STORAGE OVERFLOW MESSAGE
         SPACE 1
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              MAIN END-OF-$JOB EXIT - ASNOEXEC                       *
*        IF TIME AND RECORDS OVERRUN OCCURRED, PRINT MESSAGE.         *
*        THEN TEST FOR BATCH RUN, IF SO REUTURN FOR NEXT $JOB CARD.   *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              ASNOEXEC - PRINT OVERRUN MESSAGE IF ONE HAS OCCURRED.  *
ASNOEXEC EQU   *
         TM    AJOMODE,AJOSRECX+AJOSOVRT    TEST FOR OVERRUN
         BZ    ASTSTBAT            NO OVERRUN, TEST FOR BATCH
         NI    AJOMODE,255-AJOSRECX    IF SPURIOUS ON, REMOVE SO FLAG
         MVI   AJORECNT+3,1        ALLOW ONE PRINT LINE FOR AM005 CEH
         ASPRNT ASRTOVR,L'ASRTOVR  OVERFLOW- NOTE OCCURRENCE
         SPACE 1
*              ASTSTBAT - TEST FOR BATCH RUN, CONTINUE IF SO.         *
ASTSTBAT EQU   *
         AIF   (&$XXIOS).ASFIN     SKIP IF NO EXTENDED I/O            J
         XCALL XXDDFINI            CALL TO CLOSE EVERYTHING UP        J
.ASFIN   ANOP
         TM    AJOMODE,AJOBATCH    WAS RUN A BATCH ONE
         BZ    ASFINIS             NO, SO WE'RE DONE. QUIT NOW
         SPACE 1
*              FOR BATCH RUN, MAKE SURE MODE/STEP BITS RESET RIGHT.
         NI    AJOMODE,255-(AJOREPLF+AJOSRECX+AJOSOVRT+AJOREPHB)
         NI    AJOSTEP,255-(AJOSASM+AJOSEXEC+AJOSDUMP)     RESET PHASE
         B     ASJPARMS            GO BACK, SEARCH FOR NEXT $JOB
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> INSUB: ASFLUSH    FLUSH CARD RDR UNTIL NEXT COMMAND CARD         *
*        FLUSH UNTIL ASSIST JCL CARD FOUND, PLACING SUCH CARD INTO    *
*        AJOJCLCD (XXXXSORC DOES IT AUTOMATICALLY WHEN FOUND).        *
*        IF END-FILE FOUND, TERMINATE RUN.  NOTE $STOP == EOF.        *
*        ENTRY CONDITIONS                                             *
*   R14= RETURN ADDRESS TO CALLING CODE.                              *
*        EXIT CONDITIONS                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
ASFLUSH  $SORC AJOJCLCD,80,ASFINIS IF END-FILE, ALL DONE-QUIT         J
         MVI   AJOBTRQ,AJO$D       SET TO BE DATA AGAIN               J
         BR    R14                 RETURN TO CALLER                   J
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> INSUB: ASTIMR##   TIMING SERVICES IN ASSIST MAIN PROGRAM.        *
*        THIS SECTION CONSISTS OF A NUMBER OF ENTRIES CALLED FROM     *
*        POINTS IN THE ASSIST MAIN PROGRAM, USING THE MACRO ASTIMR    *
*        AND A TWO-DIGIT CODE AS ONE OPERAND.  EACH ENTRY PERFORMS A  *
*        SPECIFIC TIMING FUNCTION. AS OF 10/20/70, NO ENTRY IS CALLED *
*        FROM MORE THAN ONE POINT IN ASSIST, SO ACTUALLY, THE CODE FOR*
*        EACH ONE COULD BE INSERTED INLINE, SAVING SOME SPACE.  THE   *
*        SECTIONS ARE GROUPED THIS WAY FOR EASE OF MODIFICATION, AND  *
*        EASE OF GENERATION, SINCE NOT ALL ENTRIES EXIST FOR ALL      *
*        GENERATION OPTIONS (CONTROLLED BY &$TIMER).  THE ASTIMR MACRO*
*        GENERATES CALLS ONLY TO THE EXISTING SECTIONS.               *
*        ENTRY CONDITIONS (FOR ALL ASTIMR## ENTRIES)                  *
*   R9 = RETURN @ TO CALLING SECTION IN ASSIST.                       *
*        EXIT CONDITIONS                                              *
*   R0,R1,R14,R15  MAY BE DESTROYED.                                  *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         AIF   (&$TIMER LT 2).AST00A        SKIP IF NO $TIRC USABLE
*              ASTIMR00 - &$TIMER=2 - INITIALIZE OVERALL TIMER        *
ASTIMR00 EQU   *
         $TIRC TIMREM              GET REMAINING TIME, TIMER UNITS
         ST    R0,ASTBEGIN         SAVE THIS INITIAL TIME
         BR    R9                  RETURN TO CALLER
         SPACE 1
.AST00A  AIF   (&$TIMER GT 0).AST04A        SKIP IF ANY TIMER AT ALL
         SPACE 1
*              ASTIMR18 - &$TIMER=0 - PRINT INSTRUCTION COUNT.        *
ASTIMR18 EQU   *
         LM    R0,R1,ECILIMT       GET ECILIMT-ECILIMP FOR COMPUTE
         SR    R1,R0               GET DIFFERENCE = # EXECUTED
         CVD   R1,AJODWORK         CONVERT # EXECUTED
         MVC   ASHEXP2,ASPATB      MOVE EDIT PATTERN OVER
         ED    ASHEXP2,AJODWORK+8-ASPBL/2   EDIT # INSTRS DONE
         SPACE 1
         ASPRNT ASHEX,ASHEXL       PRINT EXECUTION MESSAGE
         BR    R9                  RETURN TO CALLER
         SPACE 1
         AGO   .AST24A             SKIP OVER REST OF CODE
.AST04A  AIF   (&$TIMER GT 1).AST04B        SKIP IF NOT =1
*              ASTIMR04 - &$TIMER=1 - FIND TIME FOR STIMER SETTING.   *
ASTIMR04 EQU   *
         L     R0,AJOTIML          LOAD TOTAL TIME LIMIT INTO PARM REG
         BAL   R14,ASTIMSET        GO SET TIMER TO VALUE IN R0(TU)
         BR    R9                  RETURN TO CALLER
         SPACE 1
         AGO   .AST08A             SKIP OVER CODE
.AST04B  ANOP
*              ASTIMR04 - &$TIMER=2 - GET TIME LEFT FOR STIMER        *
ASTIMR04 EQU   *
         L     R0,AJOTIML          TOTAL TIME LIMIT (TIMER UNITS)
         TM    AJOAPMOD,AJOAPUST   DID USER ACTUALLY SUPPLY T= VALUE
         BO    AST04A              YES, SO LEAVE IT ALONE-OK
*              USER DID NO SUPPLY T=, USE TIMREM TO GET ACTUAL LEFT.
         $TIRC TIMREM              GET ACTUAL TIME REMAINING
         SH    R0,=AL2(5000/26)    5 MILLISEC FUDGE FACTOR FOR SAFETY
AST04A   BAL   R14,ASTIMSET        GO SET TIMER TO DESIRED VALUE
         BR    R9                  RETURN TO CALLER
.AST08A  SPACE 2
         SPACE 1
*              ASTIMR12 - &$TIMER=1,2 - PRINT ASSEMBLY STATISTICS.    *
*        ENTRY CONDITIONS                                             *
*   R12(RAT) = @ AVWXTABL DUMMY SECTION                               *
ASTIMR12 EQU   *
         USING AVWXTABL,RAT        NOTE THE POINTER
         LH    R7,AVSTMTNO         GET # STATEMENTS FOR ASTIMER
         DROP  RAT                 ERASE THE USING
         ASTIME ASHASM,*           CALL TIMER TO PRINT MSG
         BR    R9                  RETURN TO CALLER
         SPACE 1
*              ASTIMR14 - SET UP FOR REPLACEMENT PHASE B EXEC.        *
ASTIMR14 EQU   *                   (SAME AS -16, I.E., EXECUTION)
*              ASTIMR16 - &$TIMER=1,2 - SET TIMER FOR EXECUTION TIMING*
ASTIMR16 EQU   *
         L     R0,AJOTIMR          GET CURRETN TIME REMAINING FOR T=
         L     R1,AJOTX            GET DESIRED TX= LIMIT
         LA    R15,AJOTD           ADDRESS OF TIME TO BE SAVED FOR DUMP
         BAL   R14,ASTRP16         CALL ROUTINE TO CALCULATE TIME
         BAL   R14,ASTIMSET        CALL STIMER CODE
         BR    R9                  RETURN TO CALLING SECTION OF CODE
         SPACE 1
*              ASTIMR18 - &$TIMER=1,2  CALC,PRINT EXEC TIME,RATE      *
ASTIMR18 EQU   *
         LM    R6,R7,ECILIMT       GET ECILIMT/ECLIMP FROM ECONTROL
         SR    R7,R6               GET # INSTRUCTIONS ACTUALLY DONE
         CVD   R7,AJODWORK         CONVERT # INSTRS DONE
         MVC   ASHEXP2,ASPATB      MOVE EDIT PATTERN OVER
         ED    ASHEXP2,AJODWORK+8-ASPBL/2   EDIT # INSTRUCTIONS DONE
         ASTIME ASHEX,*            GO TO DO TIMING
         BR    R9                  RETURN TO CALLING SECTION
         SPACE 1
*              ASTIMR20 - &$TIMER=1,2. SET UP FOR DUMP
ASTIMR20 EQU   *
         L     R0,AJOTIMR          GET CURRENT TIMER SETTING
         A     R0,AJOTD            ADD IN TIME FOR DUMP
         BAL   R14,ASTIMSET        CALL STIMER ROUTINE
         BR    R9                  RETURN TO CALLER
         SPACE 1
         AIF   (&$TIMER LT 2).AST24A        SKIP IF NO ENDING TIME
*              ASTIMR24 - &$TIMER=2 - COMPUTE,PRINT TOTAL ASSIST TIME *
ASTIMR24 EQU   *
         $TIRC TIMREM              GET TIME REMAINING INTO R0
         L     R1,ASTBEGIN         PLACE BEGINNING TIME FOR ASTIMER
         LA    R2,ASHEND           SHOW @ OF MESSAGE
         LA    R3,ASHENDP          SHOW @ NUMBER AREA
         LA    R4,ASHENDL          SHOW LENGTH OF MESSAGE
         SR    R6,R6               SHOW NO RATE (2ND PART OF MESSAGE)
         BAL   R14,ASTIMERE        ENTER MIDDLE SECTION OF TIME PRINTER
         BR    R9                  RETURN TO CALLER
.AST24A  ANOP
         EJECT
         AIF   (&$TIMER LT 1).AST60A        SKIP CODE IF UNNEEDED
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> INSUB: ASTIMSET   SET INTERVAL TIMER ROUTINE                     *
*        CALLED BY ASTIMR## SECTIONS TO SET TIMER FOR GIVEN INTERVAL. *
*        **NOTE** THIS IS ONLY USE OF IBM STIMER MACRO IN ASSIST.     *
*        ALSO, UNDER DOS, ONLY USE OF STXIT MACRO.                    *
*        ENTRY CONDITIONS                                             *
*   R0 = VALUE OF TIMER INTERVAL TO BE SET (TIMER UNITS = 26.04 MICS) *
*   R14= RETURN ADDRESS TO CALLING SECTION IN ASTIMR##                *
*        EXIT CONDITIONS                                              *
*   R0,R1,R15  MAY BE MODIFIED.                                       *
*   AJOMODE IS SET TO SHOW NO TIME OVERRRUNS EXIST AT MOMENT.         *
*        USES MACROS:  STIMER(OS) ; STXIT,SETIME, GETIME(DOS)         *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
ASTIMSET EQU   *
         ST    R0,AJOTIMR          STORE VALUE AS CURRENT LAST TIMER
         NI    AJOMODE,255-AJOSOVRT         MAKE SURE FLAG SET OFF
         AIF   (&$ASMLVL).ASTDOST  SKIP OVER DOS TIMING OPTIONS
         LR    R1,R0               GET VALUE OF TIMER INTERVAL IN R1
         M     R0,AJ2604           MULT BY MICROSEC/TU
         D     R0,AJ100M           CONVERT TO SEC IN R1
         SETIME  (R1)              SET INTERVAL TIMER
         GETIME  TU                R1 <= TIME OF DAY IN TIMER UNITS
         A     R1,AJOTIML          R1 <= TIME OF DAY FOR TIMER INTERRPT
         ST    R1,ASTMRMDS         SAVE TIME FOR TIMREM OPTION
         STXIT IT,ASTEXIT,ASTSAVAD ALLOW TIMER INTERRUPTION
.ASTDOST AIF   (NOT &$ASMLVL).ASTOSTM  SKIP OS STIMER
         STIMER TASK,ASTEXIT,TUINTVL=AJOTIMR
.ASTOSTM ANOP
         BR    R14                 RETURN TO CALLER
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> INSUB: ASTIMER    UPDATE TIMER,PRINT ELAPSED TIME,MESSAGE        *
*        **NOTE** THIS IS ONLY USE OF IBM TTIMER MACRO IN ASSIST.     *
*        ENTRY CONDITIONS                                             *
*   R2 = @ MESSAGE TO BE PRINTED OUT                                  *
*      = 0 ==> UPDATE TIMER ONLY, DO NOT PRINT MESSAGE OUT            *
*   R3 = @ AREA WHERE TIME INCREMENT SHOULD BE PLACED                 *
*   R4 = LENGTH OF MESSAGE TO BE PRINTED                              *
*   R6 = @ WHERE SECOND PART OF MESSAGE TO GO (INSTS/SEC, ETC)        *
*      = 0 ==> THERE IS NO 2ND PART OF MESSAGE                        *
*   R7 = VALUE TO BE USED IN 2ND PART OF MESSAGE, IF ANY              *
*   R14= RETURN @ TO CALLING SECTION OF PROGRAM.                      *
*        USES MACROS:  TTIMER(OS) ; GETIME(DOS)                       *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
ASTIMER  EQU   *                   ENTRY FOR TIMING PRINTING MODULE
         AIF   (&$ASMLVL).ASTOSGT  SKIP IF OS TTIMER DESIRED
         GETIME  TU                R1 <= TIME OF DAY IN TIMER UNITS
         L     R0,ASTMRMDS         GET TIME OF DAY FOR INTERRUPT(TIME)
         SR    R0,R1               YIELDS TIME (TU) LEFT IN INTERVAL
.ASTOSGT AIF   (NOT &$ASMLVL).ASTDSGT  SKIP IF DOS GETIME IN EFFECT
         TTIMER ,                  GET TIME LEFT IN INTERVAL
.ASTDSGT ANOP
         L     R1,AJOTIMR          GET CURRENT TIME REMAINING
         ST    R0,AJOTIMR          STORE NEW TIME REMINAING
         LTR   R2,R2               IS THERE A MESSAGE TO BE PRINTED
         BCR   Z,R14               RETURN TO CALLER, JUST RESET TIMER
         SPACE 1
*              ASTIMERE ENTRY ONLY ENTERED FROM SECTION ASTIMR24,IF GEN
ASTIMERE EQU   *                   ENTRY WITH NO TIMER UPDATE.
         SR    R1,R0               GET TIME DIFFERENCE
         M     R0,AJ2604           MULT BY 26.04 MICROSEC/TU
         D     R0,AJ100000         CONVERT TO MILLISEC IN R1
         CVD   R1,AJODWORK         CONVERT ELAPSED TIME
         MVC   0(ASPAL,R3),ASPATA  MOVE THE EDIT PATTERN IN
         ED    0(ASPAL,R3),AJODWORK+8-ASPAL/2         EDIT VALUE OVER
         LTR   R3,R6               TEST CODE AND MOVE OVER
         BZ    ASTPRINT            SKIP REST IF ZERO,GO PRINT
         SPACE 1
         M     R6,AJ1000           MULT # STMTS, GET STMTS/SEC
         LTR   R1,R1               MAKE SURE TIME >= 1MILLISEC
         BZ    *+6                 SKIP DIVIDE IF 0
         DR    R6,R1               DIVIDE TO GET STMTS OR INSTS/SEC
         CVD   R7,AJODWORK         CONVERT RESULT TO DECIMAL
         MVC   0(ASPBL,R3),ASPATB  MOVE EDIT PATTERN OVER
         ED    0(ASPBL,R3),AJODWORK+8-ASPBL/2         EDIT VALUE ACCROS
ASTPRINT LR    R0,R2               MOVE @ MESSAGE OVER FOR ASASPRINT
         LR    R1,R4               MOVE LENGTH OVER FOR ASASPRNT
*              FALL THRU INTO ASASPRNT
.AST60A  ANOP
         SPACE 1
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> INSUB: ASASPRNT   CALLED BY ASPRNT MACRO TO PRINT A LINE.        *
*        THIS INSUB IS USED INSTEAD OF MANY $PRNTS TO SAVE SPACE.     *
*        *** MUST IMMEDIATELY FOLLOW ASTIMER SECT., IF IT EXISTS.     *
*        ENTRY CONDITIONS                                             *
*   R0 = @ LINE TO BE PRINTED                                         *
*   R1 = LENGTH OF LINE TO BE PRINTED.                                *
*   R14= RETURN @ TO CALLING CODE INSIDE MAIN PROG ASSIST.            *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
ASASPRNT $PRNT (R0),(R1)           PRINT THE LINE DESIRED
         BR    R14                 RETURN TO CALLER
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              MAIN STORAGE MANAGEMENT CODE SECTIONS.                 *
*        THE FOLLOWING SECTIONS OF CODE CONTAIN THE INTERFACE         *
*        BETWEEN ASSIST AND THE OPERATING SYSTEM WITH RESPECT TO      *
*        DYNAMIC MEMORY MANAGEMENT.  IF ASSIST MUST BE RUN UNDER      *
*        A SYSTEM WITHOUT SUCH FACILITIES, THIS CODE CAN BE MODIFIED  *
*        TO JUST SUPPLY ADDRESSES OF A FIXED STORAGE AREA.            *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 2
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> INSUB: ASMSINIT   MAIN STORAGE INITIALIZATION                    *
*              ASMSINIT IS CALLED TO OBTAIN THE LARGEST POSSIBLE      *
*        BLOCK OF MAIN STORAGE >= 8K BYTES, FREE BACK THE AMOUNT      *
*        GIVEN BY ASLENOS (OR FREE= PARM, IF USED), AND SET VALUES    *
*        DESCRIBING THE STORAGE AREA LEFT, WHICH IS USED AS THE       *
*        SINGLE DYNAMIC STORAGE AREA FOR THE ENTIRE RUN.              *
*        STORAGE ALLOCATION IS DONE 1 TIME ONLY FOR WHOLE BATCH.      *
*        ENTRY CONDITIONS                                             *
*   R14= RETURN @ TO CALLING SECTION OF CODE.                         *
*        EXIT CONDITIONS                                              *
*   R0,R1,R2,R15   ARE MODIFIED BY THIS SECTION.                      *
*   AJOPADL,AJOPADH HAVE BEEN SET(LOWER, UPPER LIMITS OF CORE AREA).  *
*        AJOSTEP SET WITH FLAG AJOMSINT TO SHOW DONE.                 *
*        USES MACROS: GETMAIN (ONLY USE OF GETMAIN IN ASSIST).        *
*                     COMRG-(DOS)                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
ASMSINIT EQU   *
         OI    AJOSTEP,AJOMSINT    SHOW MAIN CORE OBTAINED. HALT FREE=
         LA    R2,AJOPADL          GET @ WHERE @'S TO BE PUT
         AIF   (&$ASMLVL).ASGETMN  FOR THE OS GETMAIN
         SPACE
         COMRG                     GET @ OF OUR COMMUNICATIONS REGION
         LM    R0,R1,32(R1)        R0 <- HIGHEST PARTITION ADDRESS
*                                  R1 <- END @ OF LAST PHASE LOADED
         LA    R1,3(R1)            GET @ OF AT LEAST NEXT FULLWORD
         N     R1,=X'FFFFFFFC'     INSURE FULLWORD BOUNDARY
         N     R0,=X'FFFFFFFC'     MAKE SURE ON FULLWORD BOUNDARY
         SR    R0,R1               GET LENGTH OF FREE STORAGE LEFT
         ST    R1,0(R2)            SAVE @ OF FREE BLOCK
         ST    R0,4(R2)            SAVE LENGTH OF FREE BLOCK
.ASGETMN AIF   (NOT &$ASMLVL).ASNGTMN  IN CASE OF STATIC ALLOCATION
         GETMAIN VU,LA=ASSPACE,A=(2),SP=1    GET AT LEAST 8K
.ASNGTMN ANOP
*              AT THIS PT AJOPADL=@ AREA, AJOPADH=LENGTH OF IT
         SPACE 1
         AIF   (&$DEBUG).ASZX1     SKIP IF NOT DEBUG MODE
*              ZERO ENTIRE DYNAMIC MEMORY AREA FOR DEBUGGING.
         LH    R0,=H'-256'         FOR BXH DECREMENT
         L     R15,AJOPADH         GET LENGTH OF AREA
         L     R1,AJOPADL          GET @ AREA
         AR    R15,R1              ADD BEGIN TO LENGTH TO GET END@
         AR    R15,R0              ADD -256 TO ENDING @
         SPACE 1
         XC    0(256,R15),0(R15)   ZERO A BLOCK OF MEMORY
         BXH   R15,R0,*-6          LOOP BACKWARDS, ZEROING
         XC    0(256,R1),0(R1)     ZERO 1ST 256 TO MAKE SURE
.ASZX1   ANOP
         SPACE 1
         LM    R0,R1,AJOPADL       AJOPADL,H= AREA @, LENGTH
         LR    R15,R1              SAVE THE LENGTH OF THE AREA
         AR    R1,R0               GET UPPER @ LIMIT
         ST    R1,AJOPADH          SAVE AS PERMANENT UPPER LIMIT
         SPACE 1
*              CHECK FREE VALUE, FREE SPACE AS REQUESTED.
         L     R0,AJOFREE          GET FREE VALUE (INIT TO ASLENOS)
         CR    R0,R15              COMPARE FREE LENGTH TO OBTAINED ONE
         BNH   *+6                 SKIP IF OK, FREE <= GOTTEN         J
         LR    R0,R15              FREE WHOLE THING (LOOK FOR AS999)  J
         AIF   (&$FREEMN EQ 0).ASZQQQ  SKIP IF NO LOWER LIMIT ON FREE J
         CH    R0,=H'&$FREEMN'     COMPARE AGAINST MINIMUM ALLOWED    J
         BNL   *+8                 SKIP IF >= MINIMUM ALLOWED         J
         LH    R0,=H'&$FREEMN'     PROBABLY ERROR, USE MINIMUM ALLOWED
.ASZQQQ  ANOP                                                         J
         SRL   R0,3                SHIFT, REMOVE 3 BITS
         SLA   R0,3                SHIFT, ALIGNED ON DOUBLEWORD
         BCR   Z,R14               RETURN, FREE=0, SO FREE NONE
         SR    R1,R0               SUBTRACT FROM UPPER LIMIT
         ST    R1,AJOPADH          NEW UPPER LIMIT
         B     ASMSFREE            GO FREE THE SPACE REQUESTED
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> INSUB: ASMSFINI FREE CURRENT DYNAMIC STORAGE AREA                *
*        CALLED TO FREE SPACE DESCRIBED BY AJOPADL-AJOPADH PTRS.      *
*        SINCE DOS USER MUST ALLOCATE OWN DYNAMIC AREA FOR THE USERS  *
*        PROGRAMS, THERE IS NO NEED TO FREE THIS BLOCK.               *
*        ENTRY CONDITIONS                                             *
*   R14= RETURN @ TO CALLING SECTION OF CODE.                         *
*        EXIT CONDITIONS                                              *
*   R0,R1,R15  ARE MODIFIED.                                          *
*   STORAGE FROM (AJOPADL) TO (AJOPADH) HAS BEEN FREEMAIN'ED.         *
*        USES MACROS: FREEMAIN   (ONLY USE OF FREEMAIN IN ASSIST).    *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
ASMSFINI EQU   *
         LM    R15,R0,AJOPADL      GET AJOPADL-AJOPADH
         LR    R1,R15              MOVE LOWER @ OVER
         SR    R0,R15              LENGTH = (AJOPADH) - (AJOPADL).
         SPACE 1
ASMSFREE EQU   *                   ENTRY POINT FROM ASMSINIT TO FREE
         AIF   (NOT &$ASMLVL).ASNFRMN   SKIP IF DOS DYNAMIC STORAGE USE
         AL    R0,=XL4'01000000'   SHOW SP=1
         FREEMAIN R,LV=(0),A=(1)   FREE THE SPACE TO OS
.ASNFRMN ANOP
         BR    R14                 RETURN TO CALLER
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> INSUB: ASRECL##   RECORD LIMIT CONTROL                           *
*        VARIOUS ENTRIES IN THIS SECTION ARE CALLED TO MANIPULATE     *
*        RECORD CONTROL VARIABLES.  EACH SECTION IS NORMALLY CALLED   *
*        ONLY ONE PLACE, BUT ARE GROUPED HERE FOR EASE OF CHANGE, AND *
*        SETUP FOR DIFFERING OPTIONS.                                 *
*        ENTRY CONDTIONS                                              *
*   R9 = RETURN ADDRESSS OF CALLING CODE                              *
*        EXIT CONDITIONS                                              *
*   R0,R1,R14,R15  MAY BE DESTROYED.                                  *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
*              ASRECL04 - INITIALIZE TOTAL RECORD COUNT               *
ASRECL04 EQU   *
         AIF   (&$RECORD EQ 2).ASR04A       SKIP IF  $TIRC EXISTS
         MVC   AJORECNT,AJORECL    MOVE USER VALUE OVER
         BR    R9                  RETURN TO CALLER
.ASR04A  AIF   (&$RECORD LT 2).ASR04B       SKIP IF NO $TIRC
*              CALCULATED RECORD LIMIT: =RECREM (IF USER SUPPLIED NO
*              R= PARM.   OR  MIN(RECREM, USER R= PARM)).
         $TIRC RECREM              GET # LEFT SAID BY SYSTEM
         TM    AJOAPMOD,AJOAPUSR   DID USER ACTUALLY SPECIFY
         BZ    ASR04A              NO, SO JUST USE RECREM
         AIF   (&$RECOVR).ASRPSU1  SKIP IF R= SHOULD BE USED-PSU BATS
         C     R0,AJORECL          CHECK AGIANST USER R=
         BNH   *+8                 SKIP IF MINIMUM THERE ALREADY
.ASRPSU1 L     R0,AJORECL          GET USER SPECIFIED R= RECORD LIMIT
ASR04A   ST    R0,AJORECNT         STORE THE COUNT THERE
         BR    R9                  RETURN TO CALLER
.ASR04B  ANOP
         SPACE 1
*              ASRECL14 - SET RECORD COUNT BEFORE REPL PHASE B.
ASRECL14 EQU   *                   JUST SAME AS FOR EXECUTE TIME
         SPACE 1
*              ASRECL16 - RECORD CONTROL JUST BEFORE USER EXECUTION.
*              AJORECNT = MIN(AJORECNT, RX=) - RD=  .
*              THIS METHOD ALLOWS FOR DUMP IF DESIRED.
ASRECL16 EQU   *
         L     R0,AJORECNT         GET CURRENT LINES LEFT-TOTAL
         L     R1,AJORX            GET DESIRED TOTAL FOR EXEC+DUMP
         LA    R15,AJORD           @ RECORDS SAVED FOR DUMP
         BAL   R14,ASTRP16         CALL COMPUTING ROUTINE
         ST    R0,AJORECNT         STORE THE VALUE COMPUTED
         NI    AJOMODE,255-AJOSRECX    REMOVE POSSIBLE OVERRUN FLAG
         BR    R9                  RETURN TO CALLER
         SPACE 1
*        ASRECL20 - RESET RECORD CONTROL JUST BEFORE USER DUMP DONE.
ASRECL20 EQU   *
         L     R0,AJORECNT         GET # LEFT FROM EXECUTION
         A     R0,AJORD            ADD THOSE SAVED FOR DUMP
         ST    R0,AJORECNT         STORE CORRECT NEW VALUE
         NI    AJOMODE,255-AJOSRECX         REMOV OVERRRUN FLAG IF ON
         BR    R9                  RETURN TO CALLER
         SPACE 2
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> INSUB: ASTRP16    COMPUTE VALUES FOR BEFORE EXECUTION            *
*        USED BY (ASTIMR,ASRECL,ASPAGE)16 TO COMPUTE THE VALUE FOR    *
*        CONTROL FOR USER EXECUTION.  THE VALUE IS THE MINIMUM OF     *
*        REMAINING VALUE AND THE USER EXECUTION VALUE.  THEN SUBTRACT *
*        AMOUNT TO BE SAVED FOR A DUMP.                               *
*        ENTRY CONDITIONS                                             *
*   R0 = CURRENT VALUE OF COUNTER  (AJOTIMR,AJORECNT,AJOPREM)         *
*   R1 = EXECUTION VALUE           (AJOTX,  AJORX,  AJOPX)            *
*   R15= @ DUMP VALUE              (AJOTD,  AJORD,  AJOPD)            *
*        EXIT CONDITIONS                                              *
*   R0 = MIN ((R0), (R1)) - 0(R15).  IF <0, = 0(R15) & 0(R15) = 0.    *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
ASTRP16  EQU   *
         CR    R0,R1               WAS REMAINING LESS THAN EXEC SPECFD
         BL    *+6                 YES, USE IT SINCE MIN
         LR    R0,R1               NO, USE EXECUTION TIME SPECIFIED VAL
         S     R0,0(,R15)          SUBTRACT VALUE SAVED FOR DUMP
         BCR   P,R14               RETURN IF OK
         A     R0,0(,R15)          ADD THE VALUE BACK TO 0 OR ABOVE
         SR    R1,R1               GET A 0
         ST    R1,0(,R15)          ZERO OUT-SO WE DON'T GIVE HIM MORE
         BR    R14                 RETURN TO CALLING SECTION
         EJECT
         AIF   (NOT &$PAGE).ASPG100         SKIP IF NO PAGE CONTROL
**--> INSUB: ASPAGE##   PAGE CONTROL CODE FOR PAGE MODE LIMITS  + + + +
*+       THESE SECTIONS CALLED TO SET LINE AND PAGE LIMITS.  NOTE THAT+
*+       THEY DO NOT BOTHER TO CHECK WHETHER PAGE CONTROL MODE IS     +
*+       ON OR NOT.  THIS IS SAFE BECAUSE THESE ACTIONS HAVE NO       +
*+       EFFECT WHATSOEVER IF PAGE CONTROL NOT ON, SINCE XXXXIOCO     +
*+       SECTIONS DO NO CHECKING UNLESS IT IS.                        +
*+       NOTE THAT SECTIONS OF ASTIMR##, ASRECL##, AND ASPAGE## HAVING+
*+       SAME TWO-DIGIT CODE FOR END GENERALLY ARE CALLED TOGETHER.   +
*+       ENTRY CONDITIONS                                             +
*+  R9 = RETURN ADDRESS TO CALLING SECTION OF CODE.                   +
*+       EXIT CONDITIONS                                              +
*+  R0,R1,R14,R15  MAY BE DESTROYED.                                  +
*+  + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
         SPACE 1
*+             ASPAGE04 - INITIALIZE FOR WHOLE RUN.  SET UP FOR       +
*+             DEFINITE NEW PAGE SKIP, SINGLE SPACE IF REQUESTED.     +
ASPAGE04 EQU   *
         MVC   AJOPREM,AJOP        SET FROM WHATEVER VALUE OF P=
         SR    R0,R0               ZERO REGISTER
         ST    R0,AJOLREM          LINES LEFT = 0, CREATE NEW PAGE
         NI    AJIOPR,255-AJIOSING REMOVE POSSIBLE SINGLE SPACE FLAG
         OC    AJIOPR,AJIOSS       ENTER SINGLE SPACE FLAG IF REQUIRED.
         BR    R9                  RETURN
         SPACE 1
         AIF   (&$REPL EQ 0).ASPNR SKIP IF NO REPL
*+             ASPAGE14 - PAGE CONTROL BEFORE REPLACE PHASE B.
ASPAGE14 EQU   *
         SR    R0,R0               ZERO REGISTER
         ST    R0,AJOLREM          SAME AS ASPAGE16, BUT ****NEW PAGE**
*              FALL THRU INTO ASPAGE16.
.ASPNR   ANOP
         SPACE 1
*              ASPAGE16 - PAGE LIMIT SET BEFORE USER PROGRAM EXECUTE.
ASPAGE16 EQU   *
         L     R0,AJOPREM          GET CURRENT # PAGES LEFT
         L     R1,AJOPX            GET NUMBER FOR EXEC+DUMP
         LA    R15,AJOPD           GET VALUE FOR DUMP
         BAL   R14,ASTRP16         CALL GENERAL COMPUTE FOR EXEC
         ST    R0,AJOPREM          STORE COMPUTED VALUE BACK
         NI    AJIOPR,255-AJIOSING REMOVE POSSIBLE SINGLESPACE FLAG
         OC    AJIOPR,AJIOSSX      FLAG SINGLE SPACE IF DESIRED
         BR    R9                  RETURN TO CALLER
         SPACE 1
*+             ASPAGE20 - SET UP PAGE LIMIT FOR DUMP.                 +
ASPAGE20 EQU   *
         L     R0,AJOPREM          GET CURRENT PAGES LEFT
         A     R0,AJOPD            ADD IN DUMP PAGES
         ST    R0,AJOPREM          STORE BACK
         NI    AJIOPR,255-AJIOSING REMOVE POSSIBLE SINGLE SPACE FLAG
         OC    AJIOPR,AJIOSSD      PUT IN SSD FLAG IF EXISTS
         BR    R9                  RETURN
.ASPG100 ANOP
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              DISASTROUS TERMINATIONS.                               *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
*              ASZERR1 - COULD NOT OPEN PRINTER - ABORT               *
         AIF   (&$ASMLVL).ASOSWTL      SKIP $PRNT IF UNDER OS GENERATN
ASZERR1  $PRNT =CL50' AM001 - ASSIST COULD NOT OPEN PRINTER - ABORT',50
.ASOSWTL AIF   (NOT &$ASMLVL).ASDSPNT  SKIP IF DOS GENERATED $PRNT
ASZERR1  WTO   'AM001 ASSIST COULD NOT OPEN PRINTER FT06F001:ABORT',   #
               ROUTCDE=11          WRITE-TO-PROGRAMMER NOW
.ASDSPNT ANOP
         TM    AJIOSO,AJIOPEN      COULD READER BE OPENED FOR SOURCE
         BO    ASZERRXI            SKIP IF RDR DID OPEN OK
         SPACE 1
*              ASZERR2 - COULDN'T OPEN SOURC RDR - ABORT              *
         AIF   (&$ASMLVL).ASRDRNO      SKIP FOR OS WTL & ABORT
ASZERR2  $PRNT =CL50' AM002 - ASSIST COULD NOT OPEN READER - ABORT',50
.ASRDRNO AIF   (NOT &$ASMLVL).ASNOWTL  SKIP IF NO OS WTL ALLOWED
ASZERR2  WTO   'AM002 ASSIST COULD NOT OPEN READER SYSIN:ABORT',       #
               ROUTCDE=11          WRITE-TO-PROGRAMMER RATHER THAN WTL
.ASNOWTL ANOP
         SPACE 1
ASZERRXI LA    R2,16               SET RETURN CODE TO DISASTER
         B     ASFINISZ            TAKE ERROR EXIT
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                       FINISH AND EXIT SECTION                       *
*        HAVE TOTAL RUN TIME COMPUTED AND PRINTED.                    *
*        CLOSE ALL DCB'S WHICH ARE CURRENTLY OPEN (XXXXFINI).         *
*        FREE ALL THE STORAGE OBTAINED BY GETMAIN AT BEGINNING.       *
*        STORE VALUE IN R2 AS RETURN CODE.                            *
*        RETURN TO CALLING PROGRAM.                                   *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
ASFINIS  EQU   *                   NORMAL TERMINATION LABEL
         ASTIMR 24,2               PRINT END MESSAGE IF REQUIRED
         SPACE 1
         XCALL XXXXFINI            HAVE ALL DCB'S CLOSED
         SR    R2,R2               SET RETURN CODE TO 0
         SPACE 1
*              ASFINISZ ENTERED IF COULDN'T OPEN RDR OR PRINTER       *
*              RETURN ALL GETMAIN'ED STORAGE TO THE SYSTEM.           *
ASFINISZ EQU   *
         BAL   R14,ASMSFINI        GO RETURN ALL SPACE USED TO OS
         SPACE 1
         AIF   (&$ASMLVL).ASNOEOJ      SKIP FOR OS RETURN
         EOJ                       SVC RETURN TO SUPERVISOR IF DOS
.ASNOEOJ AIF   (NOT &$ASMLVL).ASDSEOJ  SKIP IF DOS EOJ IN EFFECT
         L     R1,4(R13)           GET PREVIOUS SAVE AREA PTR
         ST    R2,16(R1)           STORE VALUE IN R2 AS RETURN CODE
         $RETURN RGS=(R14-R12)     RETURN TO CALLER
.ASDSEOJ ANOP
         SPACE 1
         AIF   (&$TIMER LT 1).AST65A       SKIP STIMER EXIT IF NON REQR
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                       TIMER EXIT ROUTINE                            *
*        THIS SECTION IS CALLED IF A TIMER INTERRUPT OCCURS DURING    *
*        AN ASSIST RUN.  IT FLAGS AJOSOVRT BIT IN AJOMODE TO NOTE THE *
*        OVERRUN, THEN EXAMINES AJOSTEP TO DETERMINE WHAT STEP ASSIST *
*        IS IN.  DEPENDING ON THE STEP, IT TAKES ACTION TO ENSURE     *
*        THAT THE PARTICULAR PHASE WILL BE TERMINATED FAIRLY QUICKLY. *
*        PHASES CAN BE ASSEMBLY, EXECUTION, DUMP, OR ASSEMBLY+EXEC    *
*        (THE LAST CASE BEING DURING A REPLACE PHASE B, IF ANY).      *
*        **NOTE** UNDER DOS USE, ANY MODIFIED REGS MUST BE PLACED IN  *
*        THE INTERRUPT SAVE AREA BEFORE EXITING                       *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         AIF   (&$ASMLVL).ASTEXIN  SKIP IF UNDER OS GENERATION
ASTEXIT  BALR  R15,0               ESTABLISH ADDRESSABILITY
         USING *,R15               INFORM OF BASE REG R15 USING
.ASTEXIN AIF   (NOT &$ASMLVL).ASTEXDS  SKIP IF UNDER DOS GENERATION
         USING ASTEXIT,R15         NOTE TEMPORARY USING
ASTEXIT  STM   R14,R12,12(R13)     SAVE ALL , FOR SAFETY
.ASTEXDS ANOP
         LA    R11,ASJOBCON        GET @ MAIN TABLE BACK
         OI    AJOMODE,AJOSOVRT    SHOW REAL TIME OVERRUN
         TM    AJOSTEP,AJOSEXEC    WAS INTERPRETER BEING USED
         BZ    ASTEXASM            NO, GO TO CHECK ASM FLAG
         L     R10,AJOECOPT        GET @ ECONTROL BLOCK
         MVI   ECFLAG1,$ECTIMEX    TELL EXECUT TO QUIT NEXT BRANCH
         SPACE 1
ASTEXASM EQU   *
*              **NOTE** THE MAIN PROGRAMS FOR BOTH PASSES OF THE
*              ASSEMBLER TEST AVTAGS2 1 TIME FOR EACH STATEMENT.
*              **NOTE** IT IS ALWAYS SAFE TO SET THE BIT THIS WAY.
         L     RAT,AJOVWXPT        GET @ VWXTABL
         USING AVWXTABL,RAT        NOTE PTR THERE
         OI    AVTAGS2,AJOASTOP    SET BIT-ASSEMBLER WILL STOP
         DROP  RAT                 ZAP USING
*              WE MAY BE IN DUMP STEP (AJOSDUMP IN AJOSTEP).  IN
*              IN ANY CASE, SET AJOSRECX , WHICH WILL STOP ANY
*              ASSIST MODULE, THE NEXT TIME ANY OUTPUT IS DONE.
         TM    AJOSTEP,AJOSDUMP    ARE WE IN DUMP STEP                J
         BZ    *+8                 NO, SKIP OVER OVERRUN SET
         OI    AJOMODE,AJOSRECX    SHOW RECORDS EXCEEDED(PSEUDO)
ASTEXIZ  EQU   *
         AIF   (&$ASMLVL).ASTEXEX  SKIP IF UNDER OS GENERATION
         EXIT  IT                  RETURN TO DOS SUPERVISOR
ASTSAVAD DC    18F'-1'             DOS -IT- INTERRUPT SAVE AREA
ASTMRMDS DS    F                   TIME OF DAY FOR TIMER INTERRUPT
.ASTEXEX AIF   (NOT &$ASMLVL).ASTEX2   SKIP IF UNDER DOS GENERATION
         LM    R14,R12,12(R13)     RELOAD REGS
         BR    R14                 RETURN TO OS/360
.ASTEX2  ANOP
         DROP  R15                 KILL THE USING
.AST65A  ANOP
         EJECT
*              PRIMARY SPACE ALLOCATION CONTROL WORDS                 *
ASSPACE  DC    A(8192,524288)      GET ALL WE CAN, UP TO 512 K
ASTBEGIN DS    F                   FOR TIME LEFT AT BEGINNING
ASFWORK  DS    F                   TEMPORARY WORKAREA
ASPARMSV DS    A                   SAVE WORD FOR @ PARM FILED,ETC
         SPACE 1
*                  *** HEADER FOR BEGINNING OF EACH JOB ***
ASH1HD   DC    C'1*** ASSIST &$VERSLV-&$GENDAT'                 CPP
         DC    C'  &$MCHNE/&$MODEL:&$SYSTEM'                    CPP
*                                  INSTRUCTION SET-DECIMAL,FLOAT,PRIVIL
         DC    C'  INS=S',(&$DECSA)C'D',(&$FLOTA)C'F',(&$PRIVOP)C'P'
         DC    (&$S370A)C'7'       SUPPORT DEC. FLOAT, PRIV, 370 CPP
         DC    C'/X=',(&$XIOS)C'B',(1-&$XXIOS)C'G',(&$HEXI*&$HEXO)C'H'
         DC    (&$EXINT)C'O'       SUPPORT BASIC,XGET,HEXS,XOPC CPP
         DC    ((1-(&$HEXI+&$HEXO+&$XIOS+&$EXINT+3)/4)*&$XXIOS)C'NONE'
*                                  TIME,RECORDS,PAGE CHECKING/CONTROL
         DC    C', CHECK/TRC/=&$TIMER&$RECORD&$COMNT'           CPP
*                                  MAJOR OPTIONALS-CMPRS,COMNT,
*                                  026 KEYPUNCH, MACRO, REPLACE MONITOR
         DC    C', OPTS=',(&$CMPRS)C'C',((&$DISKU+1)/2)C'D'     CPP
         DC    (&$KP26)C'K',(&$MACROS)C'M',(&$PAGE)C'P'         CPP
         DC    ((&$REPL+1)/2)C'R',(&$XREF)C'X'                  CPP
         DC    C'  PENN STATE UNIV ***'                         CPP
ASH1H$L  EQU   *-ASH1HD            LENGTH OF THIS HEADER
         SPACE 1
*              EDIT PATTERN, OUTPUT HEADINGS                          *
         AIF   (&$TIMER LT 1).AST70A        SKIP EDIT PATTERN
ASPATA   DC    X'40202021204B202020'         EDIT PATTERN FOR TIMING
ASPAL    EQU   L'ASPATA            LENGTH ATTRIB OF EDIT TIME PATTERN
.AST70A  ANOP
ASPATB   DC    X'4020202020202120' EDIT PATTERN FOR # INSTRUCTIONS DONE
ASPBL    EQU   L'ASPATB            LENGTH ATTRIB OF STMT EDIT PATTERN
         SPACE 1
         AIF   (&$TIMER GT 0).AST75A        SKIP IF NOT =0
*              EXECUTION STATISTICS MESSAGE FOR &$TIMER=0 ONLY.
ASHEX    DC    C'0*** EXECUTION:'
ASHEXP2  DC    ZL(ASPBL)'0',C' INSTRUCTIONS EXECUTED ***'
ASHEXL   EQU   *-ASHEX             LENGTH OF MESSAGE
.AST75A  AIF   (&$TIMER EQ 0).AST80A        SKIP MESSAGES IF UNNEEDED
ASHASM   DC    C'0*** ASSEMBLY TIME ='
ASHASMP  DS    CL(ASPAL)
         DC    C' SECS, '
ASHASMN  DC    ZL(ASPBL)'0',C' STATEMENTS/SEC ***'
ASHASML  EQU   *-ASHASM            DEFINE LENGTH OF MESSAGE
         SPACE 1
ASHEX    DC    C'0*** EXECUTION TIME ='
ASHEXP   DS    CL(ASPAL)
         DC    C' SECS.  '
ASHEXP2  DC    ZL(ASPBL)'0',C' INSTRUCTIONS EXECUTED - '
ASHEXN   DC    ZL(ASPBL)'0',C' INSTRUCTIONS/SEC ***'
ASHEXL   EQU   *-ASHEX             DEFINE TOTAL LENGTH OF MESSAGE
.AST80A  ANOP
ASCARDMS DC     C'*** FIRST CARD NOT READ: '   CARD MESSAGE           J
         SPACE 1
ASEMSG   DC    C'0*** AM003 - STORAGE OVERFLOW BEFORE EXECUTION, EXECUTX
               TION DELETED ***'
         SPACE 1
ASNORMAL DC    C'0*** AM004 - NORMAL USER TERMINATION BY RETURN ***'
         SPACE 1
ASRTOVR  DC    C'0*** AM005 - TIME OR RECORDS HAVE BEEN EXCEEDED'
         SPACE 1
         AIF   (&$TIMER LT 2).AST90A        SKIP END MESSAGE IF ^NEED
ASHEND   DC    C'0*** TOTAL RUN TIME UNDER ASSIST = '
ASHENDP  DC    ZL(ASPAL)'0',C' SECS ***'
ASHENDL  EQU   *-ASHEND            LENGTH OF MESSAGE
         SPACE 1
.AST90A  ANOP
ASHEXGO  DC    C'0*** PROGRAM EXECUTION BEGINNING - ANY OUTPUT BEFORE EX
               XECUTION TIME MESSAGE IS PRODUCED BY USER PROGRAM ***'
         SPACE 2
*              ***** PARM FIELD OPTION LISTS *****
         SPACE 1
*              ASPARLIM - SUPPLIES LIMIT VALUES FOR NUMERICAL PARMS,
*              PLUS DEFAULT VALUES FOR ANY OVERRIDABLE VALUES.
*              **NOTE** MOST OF OVERRIDABLE ONES COULD BE SUPPLIED
*              IN DEFAULT PARM FIELD BELOW ALSO.
ASPARLIM DS    0D                  ALIGN
*              UPPER LIMIT VALUES-CANNOT BE INCREASED BEYOND THESE.
         DC    C'I=&$IMX'          MAXIMUM INSTRUCTION COUNT
         AIF   (NOT &$PAGE).ASPL10 SKIP IF NO PAGE CONTROL
         DC    C',L=&$LMX,P=&$PMX,PD=&$PDMX,PX=&$PXMX'  PAGE LIMITS
.ASPL10  ANOP
         DC    C',R=&$RMX,RD=&$RDMX,RX=&$RXMX'        RECORD LIMITS
         AIF   (&$TIMER EQ 0).ASPL20        SKIP IF NO TIMING
         DC    C',T=&$TMX,TD=&$TDMX,TX=&$TXMX'        TIME LIMITS
.ASPL20  ANOP
         SPACE 1
*              OVERRIDABLE DEFAULT VALUES FOR RESETTABLE PARM OPTIONS.
         DC    C',&$BATCH,NOCMPRS,NOCOMNT,DUMP=0,FREE=&$FREE'
         DC    C',LIST,LOAD,NOMONIT,NERR=0'  (LARGE NO LONGER EXISTS) J
         AIF   (NOT &$DATARD).ASPL25        SKIP IF NO DATA RDR
         DC    C',DATA,SYSIN'      DEFAULT - THEY BOTH EXIST
.ASPL25  ANOP
         AIF   (&$DEBUG).ASPL30    SKIP IF NO DEBUG
         DC    C',DEBUG=0'         NO VALUE FOR DEBUG
.ASPL30  ANOP
*********AIF   (NOT &$EXINT).ASPL35    **********NEW INTERPRETER******
         DC    C',IECF=0'          DEFAULT: NO STATISTICS
.ASPL35  ANOP
         AIF   (NOT &$KP26).ASPL40 SKIP IF NO ALTERNATE KEYPINCH
         DC    C',KP=29'           DEFAULT IS 029
.ASPL40  ANOP
         AIF   (NOT &$PAGE).ASPL50 SKIP IF NO PAGE CONTROL
*              CHANGE BELOW TO ---CPAGE TO PAGE CONTROL DEFAULT.
         DC    C',NOSS,NOSSX,NOSSD,CPAGE'   MAKE CPAGE DEFAULT IF GEN J
.ASPL50  ANOP
         AIF   (&$DISKU NE 1).ASPL60                   SKIP
         DC    C',NODISKU'         NORMAL - DO INCORE
.ASPL60  ANOP
         AIF   (NOT &$PUNCH).ASPL70         SKIP IF NOPUNCH
         DC    C',PUNCH'           REAL PUNCH EXISTS
.ASPL70  ANOP
         AIF   (&$REPL EQ 0).ASPL90         SKIP IF NO REPLACE
         DC    C',NOREPL,RFLAG=0'
.ASPL90  ANOP
         AIF   (NOT &$PRIVOP).ASPL100       SKIP IF NO PRIVILEGED OPS
         DC    C',NOSUPER'
.ASPL100 ANOP
         AIF   (NOT (&$DECK OR &$OBJIN)).ASPL110      SKIP IF NO DECKS
         DC    C',NODECK,NOOBJIN'
.ASPL110 ANOP
         AIF   (NOT &$RELOC).ASPL120   SKIP IF NO RELOC MODE
         DC    C',NORELOC'         MAKE NON RELOCATED NORMAL MODE
.ASPL120 ANOP
         AIF   (&$S370 NE 2).ASPL130 SKIP IF NOT SIMULATING S/370
         DC    C',ALGN'            MAKE DEFAULT ALGN (ALIGNMENT NEEDED)
.ASPL130 ANOP
         AIF   (NOT &$MACROS).ASPL140       SKIP IF NO MACROS
         DC    C',MACRO=N,MACTR=&$MMACTR,MNEST=&$MMNEST,MSTMG=&$MMSTMG'
         AIF   (NOT &$MACSLB).ASPL135        SKIP IF NO LIBRARY MACS
         DC    C',NOLIBMC'                   DEFAULT = NO CALL LIBR MCS
.ASPL135 ANOP
.ASPL140 ANOP
         AIF   (NOT &$XREF).NOXREF6  SKIP IF NO XREF                  A
         DC    C',XREF=(&$XREFDF(1),&$XREFDF(2),&$XREFDF(3))'  DEFAULTA
.NOXREF6 ANOP                                                         A
         DC    C' '                PUT IN BLANK AT END*****MUST HAVE***
ASPARL$L EQU   *-ASPARLIM          LENGTH OF ENTIRE FIELD
         SPACE 2
*              DEFAULT VALUES FOR LIMIT VALUES AND NONRESETTABLE PARMS.
ASPARDF  DS    0D                  ALIGN
         AIF   (NOT &$PAGE).ASPD10 SKIP IF NO PAGE CONTROL
         DC    C'L=&$LDF,P=&$PDF,PD=&$PDDF,PX=&$PXDF,'
.ASPD10  ANOP
         DC    C'R=&$RDF,RD=&$RDDF,RX=&$RXDF'         RECORD DEFAULTS
         AIF   (&$TIMER EQ 0).ASPD20        SKIP IF NO TIMER
         DC    C',T=&$TDF,TD=&$TDDF,TX=&$TXDF'
.ASPD20  ANOP
         DC    C' '                PUT IN BLANK AT END*****MUST HAVE***
ASPARD$L EQU   *-ASPARDF           LENGTH OF THIS PARM FIELD
         SPACE 1
         LTORG
         SPACE 1
*              FOLLOWING SECTION CORRESPONDS TO AJOBCON DSECT.        *
ASJOBCON DS 0D
         DC    16F'0'              FOR ZEROING
         DC    F'1000'             FOR CONVERSION, AJ1000
         AIF   (&$ASMLVL).ASJOSTU      SKIP TO SET OS TIMER UNIT=26.04
         DC    F'333334'           DOS TIMER UNITS(USEC) * 100
.ASJOSTU AIF   (NOT &$ASMLVL).ASJDSTU  SKIP IF DOS TU OF 1/300 SEC
         DC    F'2604'             FOR TIME CONVERSIONS
.ASJDSTU ANOP
         DC    F'100000'           FOR TIME CONVERSIONS
         DC    F'100000000'        100 MILLION, TIME CONVERSIONS
         DC    V(VWXTABL)          @ MAIN ASSEMBLER TABLE
         DC    V(EXECUT)           ADCON FOR INTERPRETER CODE
         DS    0D
         AIF   (NOT &$KP26).ASNKP26         SKIP IF NO 026 KEYPUNCH ALL
         SPACE 1
*              TRANSLATE TABLE - 026-->029 KEYPUNCH.  ALLOWS KP=26.
*                 0 1 2 3 4 5 6 7 8 9 A B C D E F   SAME EXCEPT )+(='
         DC    X'000102030405060708090A0B0C0D0E0F'    0X
         DC    X'101112131415161718191A1B1C1D1E1F'    1X
         DC    X'202122232425262728292A2B2C2D2E2F'    2X
         DC    X'303132333435363738393A3B3C3D3E3F'    3?
         DC    X'404142434445464748494A4B5D4D4E4F'    4X   ) 4C
         DC    X'4E5152535455565758595A5B5C5D5E5F'    5X  + 50
         DC    X'606162636465666768696A6B4D6D6E6F'    6X  ( 6C
         DC    X'707172737475767778797A7E7D7D7E7F'    7X  = 7B  ' 7C
         DC    X'808182838485868788898A8B8C8D8E8F'    8X
         DC    X'909192939495969798999A9B9C9D9E9F'    9X
         DC    X'A0A1A2A3A4A5A6A7A8A9AAABACADAEAF'    AX
         DC    X'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF'    BX
         DC    X'C0C1C2C3C4C5C6C7C8C9CACBCCCDCECF'    CX
         DC    X'D0D1D2D3D4D5D6D7D8D9DADBDCDDDEDF'    DX
         DC    X'E0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF'    EX
         DC    X'F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF'    FX
         SPACE 1
.ASNKP26 ANOP
         DC    CL136' '            FOR BLANKING
         DC    C'0'                FOR CARRIAGE ONTROL
         ORG   ASJOBCON+AJOB$L     GET REMAINING LENGTH FOR SECTION
         DS    0D                  SEE WHAT LENGTH IS
         DROP  R10,R11,R13         KILL LEFTOVER USINGS
         TITLE '*** APCBLK DSECT - APARMS PARM CODE BLOCK ***'
**--> DSECT: APCBLK     APARMS PARM CODE BLOCK. . . . . . . . . . . . .
*.       THIS BLOCK DESCRIBES A PARM OPTION TABLE, GIVING THE NAME OF .
*.       THE PARM, A FLAG BYTE, AND AN OFFSET ADDRESS TO A PROCESSING .
*.       SECTION OF CODE IN CSECT APARMS.  IT IS USED ONLY IN APARMS. .
*.       LOCATION:  INSIDE TABLE APBPARMA IN CSECT APARMS.            .
*.       GENERATION: EACH APCBLK IS CREATED BY 1 CALL TO APCGN MACRO. .
*.       NAMES: APC-----                                              .
*.  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         SPACE 1
APCBLK   DSECT
*              EQU FLAG LIST FOR APCFLAG) - GIVE HANDLING TYPES.
APCYESNO EQU   B'00000001'         (APCFLAG)- YES/NO PARM;ELSE =PARM
APCYES1B EQU   B'00000010'         (APCFLAG)- FOR YES/NO TYPE PARMS
*                                  ON=> 1BIT=>YES;OFF=> 1BIT=> NO
APCNINCR EQU   B'00000010'         (APCFLAG)- IF =PARM DECIMAL VALUE
*                                  IF VALUE SET, DO NOT INCREMENT
APCD     EQU   B'00000100'         (APCFLAG)- PARM=DECIMAL # VALUE
APCNRSET EQU   B'00001000'         (APCFLAG)- ONCE SET, DO NOT RESET
APCCALL  EQU   B'00010000'         (APCFLAG)- CALL ROUTINE -APCADDR @
APCSETU  EQU   B'00100000'         (APCFLAG)-VALUE SET BY USER-$JOB CRD
APCSETP  EQU   B'01000000'         (APCFLAG)-VALUE SET FROM REAL PARM
APCSETLD EQU   B'10000000'         (APCFLAG)- VALUE WAS SET BY LIMIT
*                                  OR DEFAULT VALUE.
APCSET   EQU   APCSETLD+APCSETU+APCSETP     VALUE SET BY ANYBODY
APCP$L   EQU   AJOCP$L             LENGTH OF MAXIMUM # CHARS IN PARM
         SPACE 1
*              VARIABLES IN APCBLK - GIVE PARM NAME AND FLAGS
APCPARM  DS    CL(APCP$L)          EBCDIC FORM OF PARM, R-PADDED BLANKS
APCFLAG  DS    B                   FLAGS- DESCRIBE TYPE OF HANDLING
APCAJOFS DS    AL1                 OFFSET OF VARIABLE FROM AJO$PARM
APCLKSET DS    B                   FLAG SHOWING WHICH CALL SET/IF SET
APCBITS  DS    B                   FLAG USED TO SET FOR YES OPT OF Y/N
         ORG   APCBITS             BACK UP TO OVERLAY FOR =PARM
APCADDR  DS    AL1                 OFFSET FROM APAJUMP TO ROUTINE
APC$L    EQU   *-APCBLK            LENGTH OF 1 APCBLK
         TITLE '*** APARMS - USER PARM FIELD PROCESSING CSECT ***'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> CSECT: APARMS     USER PARM FIELD PROCESSING CSECT               *
*        SCANS USER PARM FIELD, SETS VALUES IN AJOBCON DSECT.         *
*        ENTRY CONDITIONS                                             *
*   R9 = @ OF ACTUAL PARM FIELD CHARACTER STRING.                     *
*   R10= LENGTH OF PARM FIELD AT 0(R9).                               *
*   R11= ADDRESS OF AJOBCON DUMMY SECTION AREA.                       *
*        EXIT CONDITIONS                                              *
*   AJOPARM IN AJOBCON NOW HAS USER PARM FIELD, RIGHT-PADDED WITH ' '.*
*   VARIOUS FLAGS IN AJOBCON ARE NOW SET(SEE CODE STARTING AT APAJUMP)*
*        USES DSECTS: AJOBCON,APCBLK                                  *
*        USES MACROS: $DBG,$RETURN,$SAVE,$TIRC,APCGN,XDECI            *
*        *NOTE* AS OF 8/12/70, THIS PROGRAM IS MORE GENERAL THAN      *
*        CURRENTLY NEEDED, TO ALLOW FOR FUTURE NEW PARM OPTIONS.      *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
APARMS   CSECT
         $DBG  ,NO                 SHOW NO DEBUG CODE FROM $SAVE/RETURN
         SPACE 1
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*         REGISTER USAGE AND CONVENTIONS IN APARMS CSECT              *
*   R0,R1,R2 = TEMPORARY WORK REGISTERS                               *
*   R3   ADDRESS OF CURRENT APCBLK WHEN LOOKING DOWN PARM LIST        *
*   R4 = APCP$L = LENGTH OF 1 APCBLK.  USED AS INCREMENT IN BXLE'S.   *
*   R5 = @ LAST APCBLK IN TABLE OR PART OF TABLE SEARCHED, BXLE LIMIT.*
*   R6 = SCAN POINTER TO NEXT CHARACTER TO BE PROCESSED IN PARM FIELD *
*   R7 = 1    CONSTANT FOR USE IN BXH'S AND  INCREMENTING,DECREMENTING*
*   R8 = BASE REGISTER                                                *
*   R9 = @ PARM FIELD ON INPUT.  USED AS BYTE REGISTER THEREAFTER.    *
*   R10= LENGTH OF PARM FIELD ON INPUT. @ LAST BYTE OF PARM AS LIMIT @*
*   R11= @ AJOBCON BLOCK, ON INPUT AND UNCHANGED                      *
*   R12  (UNUSED)                                                     *
*   R13= @ CALLING PROGRAM'S SAVE AREA, UNCHANGED                     *
*   R14= INTERNAL LINK REGISTER, WORK REGISTER                        *
*   R15= TEMPORARY WORK REGISTER                                      *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         USING AJOBCON,R11         NOTE POINTER TO JOB TABLE
         $SAVE RGS=(R14-R12),SA=NO,BR=R8
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                       INITIALIZATION SECTION                        *
*              INITIALIZE FLAGS IN LEADING NIBBLES OF APCFLAG BYTES.  *
*        CHECK TO SEE IF A PARM FIELD WAS USED. IF SO, MOVE IT OVER   *
*        TO INTERNAL AREA, WITH BLANKS FOLLOWING, TO MAKE SCANNING    *
*        EASIER AND USE LESS REGISTERS. SET UP FOR DOING ANALYSIS.    *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         LA    R4,APC$L            FOR INCREMENT ON MANY BXLE'S
         USING APCBLK,R3           NOTE USING, WILL USE R3 ALWAYS
         SPACE 1
*              ***** TEST FOR FLAG RESET REQUIRED. DO SO IF NEEDED ****
         TM    AJOAPMOD,AJOAPRSE   WAS THIS CALL A RESET CALL
         BZ    APNOTRSE            NO, SO SKIP RESET THIS TIME
         LA    R3,APBPARMA         @ BEGINNING OF TABLE
         LA    R5,APBPARMB-APC$L   @ LAST ELEMENT IN TABLE
         SPACE 1
         NI    APCLKSET,255-APCSET REMOVE ALL SET FLAGS
         BXLE  R3,R4,*-4           LOOP THRU TABLE
         SPACE 1
APNOTRSE EQU   *                   EXIT HERE IF NOT A RESET CALL
         LA    R7,1                USEFUL CONSTANT
         LR    R6,R10              MOVE LENGTH OF PARM OVER
*              IF AJOAPMOV SET, LEAVE PARM WHERE IT IS (MUST BE LIMIT
*              OR DEFAULT, WHICH HAVE BLANK AFTER PARM.)
         TM    AJOAPMOD,AJOAPMOV   SHOULD IT BE MOVED
         BO    *+12                YES, GO TO MOVE AND PAD CODE
         LR    R6,R9               MOVE BEGINNING ADDRESS OVER TO INIT
         AR    R10,R9              ADD BEGIN TO LENGTH GIVING END IN 10
         B     APMINIT             SKIP OVER TO INIT CODE
         MVC   AJOPARM,AJOBLANK+1  BLANK OUT ENTIRE PARM AREA
         SR    R6,R7               DECREMENT FOR MVC,CHECK FOR SIGN
         BM    APFINE              THERE WAS NO PARM FIELD,BRANCH
         LA    R0,AJOP$L-1         LENGTH-1 OF MAXIMUM PARM FIELD
         CR    R6,R0               IS LENGTH SMALL ENOUGH
         BNH   *+6                 SKIP IF LEGAL
         LR    R6,R0               TOO BIG,USE MAXIMUM
         STC   R6,*+5              STORE THIS LENGTH INTO MVC
         MVC   AJOPARM($),0(R9)    MOVE PARM FIELD OVER, R-PAD WITH BL
         AIF   (NOT &$KP26).APNKP2T         SKIP IF NO 026 KEYPUNCH
         STC   R6,*+5              PUT LENGTH INTO TR
         TR    AJOPARM($),AJTRTB26 TRANSLATE SO WILL PRINT RIGHT
.APNKP2T ANOP
         LA    R10,AJOPARM(R6)     SET LIMIT @ FOR SCANNING
         LA    R6,AJOPARM          INIT SCAN POINTER TO BEGINNING
APMINIT  EQU   *                   ENTRY TO BEGIN INIT FOR SCANNING
         SR    R9,R9               CLEAR FOR USE AS BYTE REG AFTER NOW
         MVC   APFLOCKT+1(1),AJOAPSET  MOVE INTO TM INSTR TO TEST LOCK
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                       PARAMETER FIELD SCAN SECTION                  *
*              CHECK FOR PARM BEGINNING WITH 'NO', AND SET FLAGS IF   *
*        FOUND.  SCAN FOR , = OR BLANK TERMINATING PARM, SAVING UP TO *
*        FIVE CHARS OF PARM, RIGHT-PADDED WITH BLANKS, FOR LOOKUP.    *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
APMSCAN  EQU   *                   BEGINNING OF SCAN FOR 1 PARM OPTION
         CLI   0(R6),C' '          SEARCH FOR NONBLANK
         BNE   *+8                 FOUND NONBLANK, EXIT LOOP
APMSCANX BXH   R6,R7,APFINC        BUMP SCAN PTR, GO TO CHECK FOR END
         SPACE 1
         SR    R2,R2               SHOW EXPECTED POSTIVE PARM
         AIF   (&$DEBUG).APND1     SKIP IF PRODUCTION
         XSNAP STORAGE=(*AJOPARMA,*AJIOFLAG),LABEL='APMSCAN',          X
               IF=(AJODEBUG,O,1,TM)         SNAP IF DEBUG ON
.APND1   ANOP
         CLC   0(2,R6),=C'NO'      IS PARM PRECEDED BY NO
         BNE   APMSCA              NO,SO SKIP,LEAVING R2 SET
         LA    R2,2                SET TO SHOW NO VALUE
         AR    R6,R2               ADD 2 TO SCAN PTR, BEYOND 'NO'
         SPACE 1
*              SEARCH FOR A POSSIBLE DELIMITER CHARACTRER (^ALPHABETIC)
APMSCA   EQU   *
         LR    R15,R6              SAVE @ OF BEGINNING OF PARM
         CLI   0(R6),C'A'          IS IT A DELIMITER
         BL    *+8                 PROBABLY-BRANCH OUT
         BXH   R6,R7,*-8           LOOP UNTIL FIND (NOT BLANKS END PRM)
         SPACE 1
         LR    R1,R6               @ DELIMITER
         SR    R1,R15              R1 = LENGTH OF PARM
         BNP   APMSCANX            EXTRA DELIMITER-GO TO IGNORE IT
         SR    R1,R7               R1= LENGTH(PARM OPTION) - 1
         LA    R0,APCP$L-1         MAXIMUM POSSIBLE LENGTH-1 OF PARM
         CR    R1,R0               WAS PARM TOO LONG TO BE LEGAL ONE
         BH    APMSCANX            YES, SO IGNORE IT
*              **NOTE** COULD CHANGE ABOVE TO ALLOW TRUNC OF LONG PARMS
         STC   R1,APMSCMVC+1       STORE LENGTH-1 INTO MVC
         MVC   AJOCOMP,AJOBLANK    FILL PARM WITH BLANKS
APMSCMVC MVC   AJOCOMP($),0(R15)   MOVE OPTION IN, PAD WITH BLANKS
         AR    R6,R7               POSITION SCAN PTR BEYOND DELIMITER
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                       PARAMETER LOOKUP AND FLAGGING                 *
*        USING 1ST LETTER OF OPTION AS TABLE INDEX, SEARCH SECTION    *
*        OF LOOKUP TABLE FOR IT. IF NOT FOUND, IGNORE IT. IF FOUND,   *
*        USE BITS OF ITS APCFLAG TO DETERMINE HANDLING. IF THIS CALL  *
*        ACTUALLY SETS A VARIABLE, OR INTO ITS APCFLAG BIT(S) SHOWING *
*        WHAT TYPE CALL PRODUCED THIS VALUE, FOR LATER CHECKING.      *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         CLI   AJOCOMP,C'Z'        MAKE SURE CHARACTER OK (NOT DIGIT)
         BH    APFINC              BAD OPTION NAME-IGNORE IT
         IC    R9,AJOCOMP          GET FIRST LETTER OF OPTION
         LA    R5,B'00111100'      MASK FOR MIDDLE 4 BITS OF OPTION
         NR    R9,R5               MASK OUT ALL BUT MIDDLE BITS
         SRL   R9,1                SHIFT FOR HALFWORD INDEX VALUES
         LA    R3,APBPARMA         BEGINNING OF TABLE @
         AH    R3,APLNDX(R9)       = @ BEGINNING OF TABLE SECTION
         LA    R5,APBPARMA-APC$L   @ BEGINNING - 1 ELEMENT LENGTH
         AH    R5,APLNDX+2(R9)     = @ LAST POSSIBLE ELEMENT IN SECTION
*              AT THIS PT, R3 IS INDEX, AND R5 LIMIT FOR ENSUING BXLE
         SPACE 2
APLOOK   CLC   AJOCOMP,APCPARM     COMPARE NEW PARM WITH TABLE ENTRY
         BE    APFOUND             SKIP OUT IF FOUND
         BXLE  R3,R4,APLOOK        LOOP THRU TABLE
         B     APFINC              FELL THRU, NOT IN TABLE, IGNORE IT
         SPACE 1
APFOUND  EQU   *                   EXIT HERE WHEN PARM IDENTIFIED
         AIF   (&$DEBUG).APND2     SKIP IF PRODUCTION
         XSNAP LABEL='APFOUND',STORAGE=(*APCBLK,*APCBLK+8),            #
               IF=(AJODEBUG,O,1,TM)         SNAP FOUND BLOCK,IF DEBUG
.APND2   ANOP
APFLOCKT TM    APCFLAG,$           CAN THIS PARM BE SET BY CURRENT CALL
         BNO   APFNOSET            NO,SO IGNORE HIM
         IC    R9,APCAJOFS         GET OFFSET IN AJOBCON TO VARIABLE
*              IF PARM=DECIMAL #, CONVERT THE VALUE INTO R0.
         TM    APCFLAG,APCD        WAS THIS DECIMAL CONVERT
         BZ    *+8                 NO, SKIP CONVERT
         BAL   R14,APDECON         CALL ROUTINE TO SCAN, PUT VALU IN R0
*              IF VALUE NOT SET PREVIOUSLY, SKIP TO TEST FOR TYPE
         TM    APCLKSET,APCSET     HAS IT BEEN SET ALREADY BY ANYBODY
         BZ    APFTYPE             NO, SO SAFE TO DO IT THIS TIME
*              HAS ALREADY BEEN SET-CHECK IF CAN DO IT AGAIN.
         TM    APCFLAG,APCNRSET    IS IT ALLOWED TO BE RESET
         BO    APFNOSET            NOT ALLOWED TO RESET-SKIP OUT
         TM    APCLKSET,APCSETU+APCSETP     WAS IT SET BY $JOB
         BZ    APFDFSK             NO, SKIP CHECK FOR DEFAULT-OK TO SET
         TM    AJOAPMOD,AJOAPDEF   IS THIS DEFAULT TYPE CALL
         BO    APFNOSET            YES, JUMP OUT-DON'T OVERRIDE VALUE
APFDFSK  EQU   *
*              IF PARM IS YES/NO TYPE, GO TO RESET ITS VALUE
         TM    APCFLAG,APCYESNO    WAS IT YES/NO TYPE
         BO    APFYESNO            YES, SO GO PROCESS IT
         SPACE 1
*              ***** PARM=VALUE PROCESSING *****
         TM    APCFLAG,APCNINCR    SEE IF DECIMAL# AND CAN'T INCR
         BZ    APFCALL             ALLOWABLE TO CHANGE-GO SEE IF CALL
*              VARIABLE ALREADY SET AND NEW VALUE SUPPLIED.  VALUE
*              CAN BE RESET IF IT IS LESS THAN OR EQUAL OLD ONE.
         C     R0,AJO$APC(R9)      COMPARE (ASSUMES FULLWORD VALUE)
         BH    APFNOSET            TOO HIGH-IGNORE HIM
*              IF FLAGGED, CALL INDIVIDUAL PROCESSING ROUTINE.
*              THIS TAKES CARE OF SPECIAL CASES.
APFCALL  TM    APCFLAG,APCCALL     DOES PARM REQUIRE CALL
         BZ    APFSTORE            NO, SO JUST STORE VALUE(ASSUMED F)
         IC    R2,APCADDR          GET OFFSET @ OF ROUTINE
         LA    R14,APFSET          RETURN @ TO SHOW VALUE SET
         B     APAJUMP(R2)         GO TO THE ROUTINE INDICATED
*              **NOTE- ROUTINE WILL EXIT TO R14(SET) OR APFNOSET.
APFSTORE ST    R0,AJO$APC(R9)      STORE THE COMPUTED VALUE
         B     APFSET              GO TO FLAG THAT VALUE HAS BEEN SET
*              TYPE TEST - DEFINITELY LEGAL TO SET NEW VALUE.
APFTYPE  TM    APCFLAG,APCYESNO    WAS IT YES/NO TYPE PARM
         BZ    APFCALL             NO WAS = PARM OR SPECIAL-GO DO IT
*              ***** YES/NO PARM PROCESSING *****
*              AT THIS POINT R2=0 => YES VALUE, R2=2 => NO VALUE.
*              R9 = OFFSET FROM AJO$APC TO BYTE TO BE FLAGGED.
*              DETERMINE POLARITY OF FLAG BYTE AND SET ACCORDINGLY.
APFYESNO TM    APCFLAG,APCYES1B    DOES A YES VALUE => A BIT ON
         BO    *+6                 YES, SO LEAVE R2 AS IS/SKIP
         AR    R2,R7               NO. YES VALUE=> BIT OFF-INCREM R2
         LA    R14,AJO$APC(R9)     GET ACTUAL @ BYTE TO BE SET
         OC    0(1,R14),APCBITS    SET BIT(S) DEFINITELY ON
         IC    R2,APFYNTAB(R2)     GET THE BYTE FROM CONTROL TABLE
         LTR   R2,R2               MUST WE NOW RESET GIVEN BIT TO 0
         BNZ   *+10                NO, SKIP SINCE BIT SET TO 1 OK
         XC    0(1,R14),APCBITS    YES, MUST TURN BIT OFF TO BE RIGHT
         SPACE 1
*              ***** COMMON PARM VALUE SETTING EXITS *****
APFSET   EQU   *                   VALUE WAS ACTUALLY SET THIS TIME
         OC    APCLKSET,AJOAPSET   OR IN TO SHOW WHO ACTUALLY SET VALUE
APFNOSET EQU   *                   EXIT HERE IF NOT SET THIS TIME
APFINC   CR    R6,R10              HAVE WE REACHED END YET(R10=LIMIT @)
         BL    APMSCAN             NO,RETURN FOR NEXT PARM
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                       COMPLETION SECTION                            *
*        IF AJOAPMOD WAS FLAGGED WITH AJOAPFIN, THE CURRENT CALL TO   *
*        APARMS IS THE LAST BEFORE ASSEMBLY BEGINS. ANY OPTION NEEDING*
*        IT MAY THEN TEST THE SET BITS IN ITS APCFLAG TO DETERMINE    *
*        WHERE THE PARM CAME FROM WHICH ACTUALLY SET ITS VALUE.       *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
APFINE   EQU   *                   EXIT HERE AT END OF 1 COMPLETE SCAN
         TM    AJOAPMOD,AJOAPFIN   WAS THIS LAST CALL
         BZ    APNOTLST            NO, SO DON'T MAKE CHECKS
         AIF   (&$TIMER LT 2).APFNNT        SKIP IF NOT SPECIAL TIMER
         SPACE 1
*              FLAG AJOAPMOD IF USER ACTUALLY SUPPLIED T=.  IF HE DID
*              NOT, ASSIST WE USE TIMREM VALUE INSTEAD OF DEFAULT,
*              THUS ALLOWING MORE PRECISE CONTROL OVER TIME.
         TM    APBT+(APCLKSET-APCBLK),APCSETU+APCSETP VALUE FROM $J,PAR
         BZ    *+8                 NO,DON'T SET THE FLAG
         OI    AJOAPMOD,AJOAPUST   YES, USER ACTUALLY GAVE VALUE-NOTE
         SPACE 1
.APFNNT  AIF   (&$RECORD LT 2).APFNNR       SKIP IF NO SPECIAL RECORDS
         SPACE 1
*              FLAG AJOAPMOD IF USER ACTUALLY SUPPLIED R=. IF HE DID
*              NOT, WILL USE $TIRC RECREM FOR PRECISE RECORD COUNT.
         TM    APBR+(APCLKSET-APCBLK),APCSETU+APCSETP DID HE SET VALUE
         BZ    *+8                 NO, SKIP OVER
         OI    AJOAPMOD,AJOAPUSR   SHOW USER SET R= HIMSELF
.APFNNR  ANOP
         SPACE 2
         AIF   (NOT &$ACCT).APNCOM1         SKIP IF NO ACCOUNT DISCRIM
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              ACCOUNT NUMBER CHECKING                                *
*        THE FOLLOWING CODE CAN BE USED TO SET DIFFERENT OPTIONS      *
*   DEPENDING ON THE ACCOUNT NUMBER OF THE JOB.  AS OF 03/01/71,      *
*   THE ONLY DISCRIMINATION PRESENT IS TO REQUIRE COMMENT CHECKING    *
*   CERTAIN ACCOUNTS, I.E., INTRODUCTORY COURSES.                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         $TIRC (NAME,AJOACCT)      GET ACCOUNTING INFO
         LA    R0,L'AJOACCT        INCREMENT FOR BXLE
         LA    R1,APXCOMLB         @ LAST ENTRY IN TABLE FOR LIMIT BXLE
         LA    R2,APXCOMLA         START OF ACCT# TABLE FOR INDEX BXLE
         SPACE 1
*              SEARCH TABLE FOR ACCOUNT NUMBER.
         CLC   AJOACCT,0(R2)       IS THIS THE ONE
         BE    APXCOMFN            YES, JUMP OUT OF LOOP
         BXLE  R2,R0,*-10          LOOP UNTIL END OF TABLE
         B     APXCOMXT            NOT FOUND - IGNORE IT
APXCOMFN OI    AJOASMF2,AJOCOMNT   COMMENT CHECKING NOW IN EFFECT
         SPACE 1
APXCOMXT EQU   *                   EXIT POINT FROM ACCT# CHECKING
*              CHECK FOR CERTAIN NAME TO ALLOW SPECIAL DEBUGGING.
         AIF   (NOT &$JRM).APNCOM1 SKIP IF NOT ANY SPECIAL JRM CODE
         CLC   =C'MASHEY J ',AJOPRGNM       CHECK FOR NAME, SPECIAL OPT
         BNE   APNOTJRM            NO, NOT NAME, SO SKIP
         CLC   AJOACCT,APACCJRM    IS ACCOUNT CURRENT ONE
         BNE   APNOTJRM            NO, IT ISN'T, SKIP
         OI    AJODMPF,$EC$JRM     SET FLAG TO MAKE EXECUT DO EXTRA
APNOTJRM EQU   *                   SKIP HERE IF NOT SPECIAL DEBUG
.APNCOM1 ANOP
APNOTLST EQU   *                   EXIT HERE UNLESS LAST CALL TO AP
APRET    $RETURN RGS=(R14-R12),SA=NO
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> INSUB: APDECON    CONVERT DECIMAL PARM VALUE                     *
*        ENTRY CONDITIONS                                             *
*   R6 = SCAN PTR TO 1ST CHARACTER OF DECIMAL #                       *
*   R14= RETURN @ TO CALLING SECTION OF APARMS                        *
*        EXIT CONDITIONS                                              *
*   R0 = CONVERTED RESULT OF DECIMAL #, =0 IF THERE WERE NO NUMBERS   *
*   R6 = SCAN POINTER TO 1ST NON-DECIMAL DIGIT FOUND                  *
*        THIS ROUTINE MODIFIES REGS R0,R1,R6                          *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
APDECON  LR    R1,R6               SAVE INIT SCAN POINTER
         SR    R0,R0               SET DEFAULT AMOUNT
         XDECI R0,0(R6)            SCAN AND CONVERT VALUE
         LR    R6,R1               MOVE SCAN PTR @ OVER INTO PTR REG
         BR    R14                 RETURN TO CALLING SECTION OF CODE
         EJECT
* * * * * INDIVIDUAL PARAMETER FIELD ANALYSIS SECTIONS.               *
*        ALL LABELS ARE OF FORM APA$$$$$ WHERE $$$$$ IS PARAMETER NAME*
APAJUMP  EQU   *                   BASE @ FOR PARM ROUTINES
         SPACE 3
*              PARM=VALUE TYPE PARAMETERS                             *
         SPACE 1
         AIF   (NOT &$ACCT).APNACCT         SKIP IF NO ACCT DISCRIMINAT
APAACCT  BR    R14                 ACCT NUMBER OPTION *****FUTURE USE**
.APNACCT ANOP
         SPACE 1
APADUMP  MVI   AJODMPF,$ECREGS+$ECDINST+$ECSTORG DEFAULT DUMP FLAGS
         LTR   R0,R0               WAS VALUE 0 (LEAVE DEFAULT OK)
         BCR   Z,R14               YES, SO LEAVE FLAG THERE
         NI    AJODMPF,255-$ECSTORG         JUST SMALL DUMP,REMV FLAG
         BR    R14                 RETURN
         SPACE 1
         AIF   (&$DEBUG).APNDEBG   SKIP IF DEBUG NOT MODE
APADEBUG STC   R0,AJODEBUG         STORE VALUE IN DEBUG FLAG
         BR    R14                 RETURN
         SPACE 1
.APNDEBG ANOP
         SPACE 2
         AIF   (NOT &$MACROS).APNMAC        SKIP IF NO MACRO STUFF
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              *** SCANNING CODE FOR MACRO=  PARM.                    *
*        POSSIBLE OPTIONS ARE AS FOLLOWS:                             *
*        MACRO=N                   NO MACROS (ASSUMED IF IN ERROR)    *
*        MACRO=F                   F-LEVEL MACRO (BASIC REQUEST)      *
*        MACRO=G                   ADD G-LEVEL FEATURES               *
*        MACRO=H                   ADD H-LEVEL FEATURES               *
*        **NOTE** THE BASIC FACILITY IS THE F-LEVEL COMPATIBLE ONE.   *
*        SOME OF THESE OPTIONS MAY NOT BE SUPPORTED, AND IN ANY CASE, *
*        CODE FOR THEM IS ALL CONDITIONAL.                            *
*        SEE SET VARIABLES BEGINNING &$MACRO- .                       *
*        ** SETS BITS IN AJOASMFM, SEE FLAGS AT BEGINNING OF AJOBCON. *
         SPACE 1
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
APAMACRO EQU   *                   CODE FOR MACRO=
*              FOLLOWING STMT MAKES ASSUMPTION OF  MACRO=N.
         NI    AJOASMFM,(255-AJOMACRO-AJOMACRG-AJOMACRH) SET MACRO=N
         SR    R2,R2               CLEAR, WILL BE INDEX TO TABLE
         CLI   0(R6),C'F'          WAS IT MACRO=F
         BE    APAMACR1            YES, SKIP, LEAVE R2=0
         AR    R2,R7               SET R2=1
         CLI   0(R6),C'G'          WAS IT G
         BE    APAMACR1            YES, BRANCH, LEAVE R2=1
         AR    R2,R7               SET R2=2
         CLI   0(R6),C'H'          WAS IT MACRO = H
         BNE   APAMACRZ            NO, MUST BE MACRO=N, OR ERROR-SKIP
APAMACR1 LA    R2,APAMACRT(R2)     GET @ FLAG BYTE FOR ACTUAL LEVEL
         OC    AJOASMFM(1),0(R2)   OR APPRORPIATE BITS INTO FLAG
APAMACRZ BXH   R6,R7,APFSET        BUMPSCAN PTR, GO TO SHOW SET
*              AJOASMFM FLAG BYTES FOR MACRO= F, G, H .
APAMACRT DC    AL1(AJOMACRO,AJOMACRO+AJOMACRG,AJOMACRO+AJOMACRH,0)
         DS    0H                  MUST BE HALF ALIGNED (NOTE 0 ABOVE)
.APNMAC  ANOP
         SPACE 1
         AIF   (NOT &$KP26).APKP29X         SKIP IF NO 026 KEYPUNCH
APAKP    EQU   *                   KP=26 OR KP=29.  29 DEFAULT
*              ANYTHING BUT KP=26 TREATED AS KP=29.
         NI    AJIOSO,255-AJIOKP26 RESET TO DEFAULT KP=029
         LA    R1,26               VALUE FOR COMPARE
         CR    R0,R1               WAS KP=26 SPECIFIED
         BCR   NE,R14              NO, VALUE SET RIGHT, RETURN
         OI    AJIOSO,AJIOKP26     SHOW 026 KEYPUNCH
         BR    R14                 RETURN, GO TO APFSET
.APKP29X ANOP
         SPACE 1
         AIF   (&$TIMER EQ 0).APNOT         SKIP IF NO TIMING
*              ***** SCANNING/CONVERSION FOR T=, TD=, TX= *****       *
*              THE FOLLOWING CODE ALLOWS THESE PARMS TO SPECIFY       *
*        FRACTIONAL PARTS OF A SECOND.  IT SCANS THE FRACTIONAL PART  *
*        IF ANY AND CONVERTS THE VALUE INTO TIMER UNITS (26.04 MICSEC *
*        AND STORES IT IN APPROPRIATE LOCATION.  IT ACCEPTS UP TO 3   *
*        FRACTIONAL DIGITS (I.E., MILLISECONDS).                      *
         SPACE 1
APAT     EQU   *
APATD    EQU   *
APATX    EQU   *
         LR    R1,R0               MOVE # SECONDS ON PARM OVER
         M     R0,AJ1000           *1000 = # MILLISECONDS
         CLI   0(R6),C'.'          DID HE SPECIFY FRACTION
         BNE   APTINT              NO,JUST INTERGER-SKIP
         LR    R2,R1               MOVE MILLISEC # OVER FOR SAFETY
         AR    R6,R7               BUMP SCAN PTR BEYOND .
         LR    R5,R6               SAVE @ 1ST FRAFTION DIGIT
         BAL   R14,APDECON         CALL CONVERTER FOR SCANNING
         SR    R5,R6               GET # DIGITS
         AH    R5,=H'4'            ADD LIMIT+1 TO GET 3-1 OF MULTS
         BNP   APTIGNOR            IF MORE THAN 3 DIGITS-IGNORE IT
         SPACE 1
         LR    R1,R0               MOVE VALUE OF FRACTION
         LA    R15,10              VALUE FOR MULTIPLY
         BAL   R14,*+6             SET REG,SKIP OVER MULT & INTO LOOP
         MR    R0,R15              CONVERT*10
         BCTR  R5,R14              LOOP.    END WITH # MILLISEC IN R1
         AR    R2,R1               ADD TO PREVIOUSLY SAVED # MILLISEC
APTIGNOR LR    R1,R2               MOVE VALUE BACK TO R1
         SPACE 1
*              AT THIS PT, R1=# MILLISECONDS SPECIFIED
APTINT   EQU   *
         M     R0,AJ100000         GET 100*# MICROSECONDS
         D     R0,AJ2604           / BY 100# MICRO SEC IN A TIMER UNIT
*              AT THIS PT R1 = # TIMER UNITS IN INTERVAL
         LR    R0,R1               MOVE OVER FOR LATER STORE
         TM    APCLKSET,APCSET     HAS IT BEEN SET BY ANYONE
         BZ    APFSTORE            NO, DEFINITELY SAFE TO STORE-GO
         TM    APCLKSET,APCSETU+APCSETP     SET BY USER
         BZ    *+12                NO, SKIP DEFAUL TEST
         TM    AJOAPMOD,AJOAPDEF   IS IT DEFAUL T CALL
         BO    APFNOSET            YES, ALREADY SET-DON'T OVERRRIDE
         SPACE 1
         C     R0,AJO$APC(R9)      COMPARE TO PREVIOUS VALUE
         BH    APFNOSET            TOO-HIGH-IGNORE HIM
         B     APFSTORE            OK-GOTO STORE VALUE
.APNOT   ANOP
           AIF   (NOT &$XREF).NOXREF5                                 A
        SPACE 3
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
* THIS ROUTINE IS THE CROSS REFERENCE OPTION SCANNING ROUTINE         *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
APAXREF  EQU   *
         IC    R0,AJOXREF         GET FLAG IN                         A
         LR    R2,R0              MOVE FLAG TO R0,R1,R2               A
         LR    R1,R2
         N     R0,APXRB3          GET RIGHT BITS SET                  A
         N     R1,APXRB2
         N     R2,APXRB1                                              A
         LR    R12,R6             GET POINTER TO PARM FIELD           A
         CLI   0(R12),C'('        SEE IF LIST OF VALUES               A
         BNE   APXRXRO            PROCESS FIRST ONLY                  A
         AR    R12,R7             BUMP PAST "("                       A
         CNOP  0,4                MAKE SURE OF PROPER ALIGNMENT       A
         BAL   R14,APXRCHK        CHECK FOR PROPER DELIMETER          A
         DC    A(APXRSD)          WHERE TO GO IF OMITTED              A
         BAL   R14,APXRSET        SET  VALUE INTO PROPER REGISTER     A
         SLL   R15,4              MOVE TO RIGHT POSITION              A
         LR    R0,R15             MOVE TO CORRECT REGISTER
         AR    R12,R7             BUMP TO NEXT CHARACTER              A
APXRSD   EQU   *                  CHECK FOR VALUES IN SD=
         AR    R12,R7             BUMP PAST VALUE                     A
         CNOP  0,4                MAKE SURE OF ALIGNMENT              A
         BAL   R14,APXRCHK        CHECK PROPER DELIMITER              A
         DC    A(APXRSR)          ADDRESS TO GO TO IF USING DEFAULTS
         BAL   R14,APXRSET        SET CORRECT VALUE                   A
         SLL   R15,2              MOVE TO CORRECT POSITION            A
         LR    R1,R15             MOVE TO RIGHT REG                   A
         AR    R12,R7             BUMP TO NEXT CHARACTER              A
APXRSR   EQU   *                  DO SR= DEFAULT                      A
         AR    R12,R7             BUMP POINTER                        A
         CLI   0(R12),C')'        WAS IT OMITTED                      A
         BE    APXRADD            YES, DO ADD                         A
         CLI   1(R12),C')'        PROPER DELIMITER                    A
         BNE   APXRFIN            NO, BAG IT                          A
         BAL   R14,APXRSET        GET NUMBER IN REG                   A
         LR    R2,R15             MOVE TO RIGHT REG                   A
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
* THIS SECTION ADDS THE REGISTERS R0,R1,R2.  THESE REGISTERS HAVE THE *
* CORRECT VALUES IN THEM EITHER BY THE DEFAULT VALUES OR BY SETTING   *
* A FLAG WITH THE XREF= OPTION.                                       *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
APXRADD  EQU   *                                                      A
         AR    R1,R0              COLLECT XREF AND SD VALUES          A
         AR    R2,R1              COLLECT ALL                         A
         STC   R2,AJOXREF         SET ACTUAL FLAG                     A
APXRRET  EQU   *                                                      A
         LA    R6,1(R12)          SET PROPER DELIMITER                A
         B     APFSET             SHOW VALUE SET                      A
APXRXRO  BAL   R14,APXRSET        GET NUMBER                          A
         SLL   R15,4              MOVE TO RIGHT POSITION              A
         LR    R0,R15             MOVE TO RIGHT REGS                  A
         B     APXRADD            SET ACTUAL XREF FLAG                A
         SPACE 2
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*-->INSUB: APXRSET   CONVERT NUMBER TO INTERNAL FORM                  *
*     CONVERTS XREF PARM NUMBERS AND CHECKS TO SEE IF THEY'RE IN THE  *
*     RANGE 0-3.                                                      *
*     ENTRY CONDITIONS                                                *
*   R12= POINTER TO NUMBER TO BE CONVERTED                            *
*     EXIT CONDITIONS                                                 *
*   R15= CONVERTED NUMBER                                             *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
APXRSET  EQU   *                  INSUB TO SET VALUE IN REGISTER 15   A
         MVC   APXRWORK+7(1),0(R12)    MOVE NUMBER TO WORK AREA       A
         PACK  APXRWORK(8),APXRWORK                                   A
         CVB   R15,APXRWORK       CONVERT NUMBER TO INTERNAL FORM     A
         C     R15,=X'00000003'   SEE IF TOO BIG                      A
         BH    APXRFIN            DENOTE ERROR                        A
         BR    R14                RETURN                              A
         SPACE 2
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*-->INSUB: APXRCHK   CKECK FOR VALID DELIMITER                        *
*     CHECKS FOR ',' IN XREF=(A,B,C) PARM FIELD.  SPECIAL RETURN      *
*     FOR XREF=(A).                                                   *
*     ENTRY CONDITIONS                                                *
*   R12= POINTER OF NEXT CHARACTER                                    *
*     EXIT CONDITIONS                                                 *
*   R14= @ OF ROUTINE TO BRANCH TO                                    *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
APXRCHK  EQU   *                                                      A
         CLI   0(R12),C','        WAS NEXT OPERAND OMITTED?           A
         BE    APXRNXT            YES: DO NEXT SECTION
         CLI   1(R12),C','        PROPER DELIMITER?                   A
         BNE   APXRFIN            NO: GO TO ERROR                     A
         B     4(R14) GO BAVK                                         A
APXRNXT  L     R14,0(R14)         GET ADDRESS
         BR    R14                GO TO ROUTINE
APXRFIN  EQU   *
         LR    R6,R12             GET @ BACK IN R6
         B     APFNOSET           ERROR FOUND: SHOW NOT SET           A
APXRB1   DC    A(3)               MASK OUT ALL BUT LOWER BITS         A
APXRB2   DC    A(12)              MIDDLE BITS                         A
APXRB3   DC    A(48)              TOP BITS                            A
APXRWORK DC    D'0'               WORK AREA                           A
.NOXREF5 ANOP
*              TABLE OF APCBLKS FOR PARM FIELD ANALYSIS               *
APBPARMA DS    0D                  DEFINE BEGINNING SYMBOL, ALIGN
APLAC    EQU   *                   PARMS A-C
         APCGN ACCT,AJOACCT,0,C=1,G=&$ACCT
         AIF   (&$S370 NE 2).APNALGN    SKIP IF NO S/370 SIMULATION
         APCGN ALGN,AJOEXEF,AJONALGN,Y=1
.APNALGN ANOP
         APCGN BATCH,AJOMODE,AJOBATCH,I1=1,Y=1,LK=110
         APCGN CMPRS,AJOASMF2,AJOCMPRS,I1=1,Y=1,G=&$CMPRS
         APCGN COMNT,AJOASMF2,AJOCOMNT,I1=1,Y=1,G=&$COMNT,LK=110
         APCGN CPAGE,AJIOPR,AJIOPAGE,I1=1,Y=1,G=&$PAGE,LK=110
APLDG    EQU   *                   PARMS D-G
         APCGN DATA,AJIORE,AJIODFLT,Y=1,G=&$DATARD,LK=110
         APCGN DEBUG,AJODEBUG,C=1,D=1,G=&$DEBUG,GC=1
         APCGN DECK,AJOASMF2,AJODECK,Y=1,I1=1,G=&$DECK
         APCGN DISKU,AJOASMF,AJODISKU,G=&$DISKU,Y=1,I1=1
         APCGN DUMP,AJODMPF,C=1,D=1
         APCGN FREE,AJOFREE,0,D=1,LK=110
APLHI    EQU   *                   PARMS H-I
         APCGN I,AJOINSL,0,D=1,I1=1
         APCGN IECF,AJOIECF,0,D=1,G=&$EXINT   IECF OF EXT'D INTPRTR
APLJL    EQU   *                   PARMS J-L, GAP
         APCGN KP,AJIOSO,C=1,D=1,G=&$KP26
         APCGN L,AJOL,0,D=1,I1=1,G=&$PAGE
         APCGN LIBMC,AJOASMFM,AJOLIBMC,I1=1,Y=1,G=&$MACROS  PRT LIB MCS
         APCGN LIST,AJOASMF,AJNLIST,Y=1
         APCGN LOAD,AJOASMF,AJNLOAD,Y=1
APLMP    EQU   *                   PARMS M-P
         APCGN MACRO,AJOASMFM,C=1,G=&$MACROS          MACRO LEVEL
         APCGN MACTR,AJOMACTR,0,D=1,G=&$MACROS        MACRO ACTR
         APCGN MNEST,AJOMNEST,0,D=1,G=&$MACROS        MACRO NEST LIMIT
         APCGN MSTMG,AJOMSTMG,0,D=1,G=&$MACROS        MACRO STMT LIMIT
         APCGN MONIT,AJOMODE,AJOMONIT,I1=1,Y=1,LK=110
         APCGN NERR,AJONERRF,0,D=1
         APCGN OBJIN,AJODECKF,AJOOBJIN,Y=1,I1=1,G=&$OBJIN
         APCGN P,AJOP,0,D=1,I1=1,G=&$PAGE
APBPD    APCGN PD,AJOPD,0,D=1,I1=1,G=&$PAGE
         APCGN PUNCH,AJIOPN,AJIODFLT,Y=1,G=&$PUNCH,LK=110
APBPX    APCGN PX,AJOPX,0,D=1,I1=1,G=&$PAGE
APLQR    EQU   *                   PARMS Q-R, GAP
APBR     APCGN R,AJORECL,0,D=1,I1=1
APBRD    APCGN RD,AJORD,0,D=1,I1=1
         APCGN RELOC,AJOASMF,AJORELOC,I1=1,Y=1,G=&$RELOC
         APCGN REPL,AJOMODE,AJOREPLF,I1=1,Y=1,G=&$REPL
         APCGN RFLAG,AJORFLAF,0,D=1,G=&$REPL
APBRX    APCGN RX,AJORX,0,D=1,I1=1
APLST    EQU   *                   PARMS S-T
         APCGN SS,AJIOSS,AJIOSING,I1=1,Y=1,G=&$PAGE
         APCGN SSD,AJIOSSD,AJIOSING,I1=1,Y=1,G=&$PAGE
         APCGN SSX,AJIOSSX,AJIOSING,I1=1,Y=1,G=&$PAGE
         APCGN SUPER,AJOEXEF,AJOSUPER,I1=1,Y=1,G=&$PRIVOP
         APCGN SYSIN,AJOMODE,AJNSYSIN,Y=1,G=&$DATARD,LK=110
APBT     APCGN T,AJOTIML,D=1,I1=1,G=&$TIMER,C=1
         APCGN TD,AJOTD,D=1,I1=1,G=&$TIMER,C=1
APBTX    APCGN TX,AJOTX,D=1,I1=1,G=&$TIMER,C=1
APLUX    EQU   *                   PARMS U-X
         APCGN XREF,AJOXREF,C=1,G=&$XREF                              A
APLYZ    EQU   *                   PARMS Y-Z
APBPARMB EQU   *                   LIMIT OF APCGN'D TABLE
         SPACE 2
*              PARM TABLE LOOKUP INDEX - APLNDX
*              GIVES OFFSETS TO BEGINNING OF EACH SECTION OF TABLE,
*              DETERMINED BY INITIAL LETTER
*              DETERMINED BY MIDDLE 4 BITS OF 1ST BYTE OF OPTION NAME.
APLNDX   $AL2  APBPARMA,(APLAC,APLDG,APLHI,APLJL,APLJL,APLMP,APLQR,    #
               APLST,APLST,APLUX,APLYZ,APBPARMB)
         AIF   (NOT &$ACCT).APNCOM2         SKIP IF NO ACCT# CHECKING
         SPACE 1
*              TABLE OF ACCOUNT NUMBERS RECEIVING SPECIAL TREATMENT.
APXCOMLA EQU   *                   BEGINNING OF TABLE
         DC    5CL5'ACCT#'         DUMMIES, TO BE FIXED IN OBJ DECK
APACCJRM DC    C'C3338'            CURRENT ACCT# FOR TESTING PURPOSES
APXCOMLB EQU   *-L'AJOACCT         @ LAST 1 IN TABLE
         SPACE 1
.APNCOM2 ANOP
         SPACE 1
*              TABLE TO DETERMINE WHETHER YES/NO PARM SHOULD HAVE ITS
*              VARIABLE BYTE BITS SET TO 1'S OR 0'S.
APFYNTAB DS    0BL4                YES/NO BIT SETTING CONTROL TABLE
         DC    B'1'                YES PARM,YES1B ==> BIT = 1
         DC    B'0'                YES PARM, ^YES1B ==> BIT  = 0
         DC    B'0'                NO PARM, YES1B ==> BIT = 0
         DC    B'1'                NO PARM, ^YES1B ==> BIT = 1
         LTORG
         DROP  R3,R8,R11           KILL ALL USINGS
         AIF   (NOT (&$DECK OR &$OBJIN)).AOBNONE      SKIP IF NO DECKS
         TITLE 'AOBJCARD DSECT : OBJECT DECK CARDIMAGE'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: AOBJCARD   IMAGE OF OBJECT DECK CARD                      *
*        THIS DSECT DESCRIBES 1 CARD OF AN ASSIST OBJECT DECK.  THE   *
*   DECK FORMAT IS COMPATIBLE WITH NORMAL S/360 OBJECT DECKS, SO THAT *
*   THEY CAN BE USED UNDER SOME CIRCUMSTANCES.    THEY ARE HOWEVER    *
*   SIMPLER, IN ORDER TO ALLOW FOR PRODUCTION OF THEM FROM STUDENT-   *
*   COMPILERS, I.E. XPL.  LATER VERSIONS OF THE LOADER MAY PERMIT     *
*   MORE COMPLEX OBJECT DECKS, BUT AS OF 9/01/71, THE ONLY TYPES OF   *
*   OBJECT DECK CARDS RECOGNIZED ARE TXT AND END CARDS.               *
*        NAMES: AO------                                              *
*        REFERENCE: ASSEMBLER(F) PROGRAMMER'S GUIDE - GC26-3756-4     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
AOBJCARD DSECT
         SPACE 1
*              ***** COMMON BASE BEGINNING *****
         DS    X'02'               1     (S/360) - ASSIST IGNORES
AOBJTYPE DS    CL3                 2-4   TYPE OF CARD
         SPACE 1
*              ***** ESD CARD LAYOUT *****
********************    NOT CURRENTLY IMPLEMENTED   *******************
         SPACE 1
*              ***** TXT CARD LAYOUT *****
         ORG   AOBJTYPE            BACK UP TO SHOW LAYOUT
         DS    CL3'TXT'            2-4   TEXT CARD IDENTIFIACTION
AOTADDR  DS    0A,C' '             5     ASSIST IGNORES 1ST BYTE
AOTADDRT DS    AL3                 6-8   @ WHERE OBJECT CODE GOES
         DS    CL2' '              9-10  ASSIST IGNORES THESE COLS
AOTLENG  DS    0H,C                11-12 LENGTH OF CODE ON CARD
AOTLENG2 DS    AL1                 12    LENGTH USED BY ASSIST 0-56
         DS    CL4' '              13-16 IGNORED *****FUTURE USE ******
AOTCODE  DS    CL56                17-72 OBJECT CODE 0-56 BYTES OF IT
AOTSEQN  DS    CL8                 73-78 SEQUENCE NUMBER, IGNORED
         SPACE 1
*              ***** RLD CARD LAYOUT *****
********************    NOT CURRENTLY IMPLEMENTED   *******************
         SPACE 1
*              ***** END CARD LAYOUT *****
         ORG   AOBJTYPE            BACK TO SHOW TYPE
         DS    CL3'END'            2-4   END CARD FLAG
AOEBLNK  EQU   *                   BEGINNING OF BLANK AREA
AOENTRY  DS    0A,C' '             5     ASSIST IGNORES LEADING BLANK
AOENTRY2 DS    AL3                 6-8   GIVES ENTRY @, UNLESS BLANK
AOEBLNKL EQU   72-(*-AOBJCARD)     LENGTH TO BE BLANKED
         TITLE 'AOBJDK CSECT - OBJECT DECK PUNCH/LOAD'
AOBJDK   CSECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> CSECT: AOBJDK     OBJECT DECK HANDLING MODULE                    *
*                                  JOHN R. MASHEY - 09/01/71          *
*        THE TWO ENTRIES OF AOBJDK ARE USED TO LOAD OR PUNCH OBJECT   *
*   DECKS WHICH ARE SUBSETS OF NORMAL S/360 DECKS.   THE TWO ENTRIES  *
*   MAY OR MAY NOT EXIST, DEPENDING ON FLAGS &$DECK AND &$OBJIN.      *
*        USES DSECTS: AOBJCARD,AVWXTABL                               *
*        USES MACROS: $RETURN,$SAVE                                   *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         $DBG  ,NO                 NO DEBUG IN $SAVE,$RETURN
         EJECT
         AIF   (NOT &$OBJIN).AOBJN1         SKIP IF NO OBJECT INPUT
         ENTRY AOBJIN
AOBJIN   $SAVE RGS=(R14-R12),SA=NO,BR=R6
         USING AVWXTABL,RAT        NOTE ASSEMBLER CONTROL TABLE
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> ENTRY: AOBJIN     LOAD OBJECT DECK                               *
*        ENTRY CONDITIONS                                             *
*   R12(RAT) = @ ASSEMBLER CONTROL TABLE (AVWXTABL).                  *
*        EXIT CONDITIONS                                              *
*   AVRADL,AVRADH,AVRELOC,AVFENTER,AVLOCLOW,AVLOCHIH  ARE SET UP      *
*   AS THEY WOULD HAVE BEEN HAD THE PROGRAM BEEN ASSEMBLED.           *
*   AVTAGS1    IS FLAGGED WITH AJNLOAD IF SOME ERROR OCCURRED.        *
*        NAMES: AOB-----                                              *
*        USES MACROS: $PRNT,$RETURN,$SAVE,$SORC,XSNAP                 *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
* * * * * * * * REGISTER USAGE FOR AOBJIN * * * * * * * * * * * * * * *
*   R0,R1      WORK REGISTERS.  R1 USED FOR ADDRESS CALCULATIONS.     *
*   R2 = LOWEST REAL @ LOADED CODE. INIT=AVADDLOW. INTO AVRADL.       *
*   R3 = @+1 OF HIGHEST LOADED CODE. INIT=AVADDLOW.  INTO AVRADH.     *
*   R4 = LOAD RELOCATION FACTOR. = AVADDLOW - (1ST TXT @ FOUND).      *
*   R5 = USER ENTRYPOINT @ (FAKE).  TO BE STORED INTO AVFENTER.       *
*   R6 = BASE REGISTER                                                *
*   R7 = ADDRESS OF OBJECT CARD IMAGE (AOBJCARD DSECT).               *
*   R8 = BYTE REGISTER (USED FOR INSERT OF LENGTH FROM AOTLENG2)      *
*   R9 = @+1 OF HIGHEST USABLE BYTE FOR PROGRAM.  = AVADDHIH.         *
*   R10,R11    UNUSED                                                 *
*   R12(RAT)= @ AVWXTABL CONTROL BLOCK                                *
*   R13= @ CALLING PROGRAM'S SAVE AREA.                               *
*   R14= INTERNAL LINK REGISTER, WORK REGISTER.                       *
*   R15= WORK REGISTER                                                *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              OBJECT LOAD INITIALIZATION.                            *
*        1. FILL OBJECT AREA (AVADDLOW-AVADDHIH) WITH FILL CHARS.     *
*        2. SET UP INITIAL VALUES FOR @'S IN REGISTERS.               *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         LM    R8,R9,AVADDLOW      AVADDLOW-AVADDHIH - CORE LIMITS
         LA    R7,31(,R8)          * ALIGN ACTUAL BEGINNING @
         SRL   R7,5                * TO MULTIPLE OF 32.
         SLL   R7,5                * THIS IS REQUIRED BY XXXXSNAP
         ST    R7,AVADDLOW         * STORE ALIGNED VALUE BACK
         LA    R8,32               # BYTES TO BE FILLED WITH 1 STM
         SR    R9,R8               SUBTRACT 32 FOR BXLE USE
         SR    R9,R8               -32 MORE FOR COMPLETE SAFETY
         BXH   R7,R8,AOBINTA       MAKE SURE AT LEAST 32 BYTES
         SPACE 1
         SR    R7,R8               BACK UP TO  BEGINNING FOR SAFETY
         MVI   0(R7),$PRGFILC      PUT IN FILL CHARACTER
         MVC   1(31,R7),0(R7)      PROPAGATE FILL CHARACTER
         LM    R14,R5,0(R7)        GET 8 REGS WORTH OF FILL CHARACTER
         SPACE 1
         STM   R14,R5,0(R7)        STORE 32 BYTES OF FILL CHARACTER
         BXLE  R7,R8,*-4           LOOP TO FILL WHOLE AREA
         SPACE 1
AOBINTA  LM    R8,R9,AVADDLOW      AVADDLOW-AVADDHIH - LIMIT @'S
         LR    R2,R8               R2= INIT VALUE LOWEST REAL(AVRADL)
         LR    R3,R2               R3= INIT VALUE HIGHEST LIMIT(RADH)
         SR    R5,R5               INIT ENTRY @ TO 0 (BEGINNING OF CD)
         NI    AVTAGS1,255-AVOENTR-AVO1TXT  SHOW NO TXT, ENTRY @ FOUND
         LA    R7,AVCONCAT         USE THIS AS WORKAREA FOR AOBJCARD
         USING AOBJCARD,R7         NOTE DSECT
         SR    R8,R8               CLEAR R8 AS BYTE REGISTER FOR INSERT
         SPACE 1
*              PRINT HEADER MESSAGE AL000.
         BAL   R14,AOBHEXCO        CONVERT VALUES TO HEX FOR PRINT
         DC    H'2'                # ITEMS IN FOLLOWING LIST
         DC    AL2(AVADDLOW-AVWXTABL,AOB000A-AOB)     REAL @ START
         DC    AL2(AVADDHIH-AVWXTABL,AOB000B-AOB)     REAL LIMIT
         BAL   R14,AOBPRINT        GO PRINT COMPLETED MESSAGE
         DC    AL2(AOB000-AOB,AOB000L)      @ OFFSET, LENGTH
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              READ OBJECT DECK AND LOAD LOOP HEAD                    *
*        READ 1 CARD OF OBJECT DECK, UNTIL EOF FOUND. DETERMINE TYPE  *
*   OF CARD, BRANCH TO PROCESSING SECTION, RETURN FOR NEXT CARD.      *
*   **NOTE** AS OF 9/01/71, WILL PROCESS ONLY TXT AND END CARDS, THUS *
*   SECTIONS OF CODE COMMENTED OUT ARE TO INDICATE POSSIBLE EXTENSIONS*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
AOBREAD  EQU   *                   ENTRY LABEL FOR 1 CARD PROCESS
         $SORC AOBJCARD,80,AOBJEOF READ UNTIL END-FILE
         CLC   AOBJTYPE,=C'TXT'    WAS IT TEXT CARD (MOST LIKELY)
         BE    AOBTXT              YES (NOTE WE IGNORE COL 1 OF CARD)
         CLC   AOBJTYPE,=C'END'    WAS IT END CARD
         BE    AOBEND              YES, GO THERE TO PROCESS IT
*****    CLC   AOBJTYPE,=C'RLD'    WAS IT RLD
*****    BE    AOBRLD              YES, GO THERE
*****    CLC   AOBJTYPE,=C'ESD'    WAS IT ESD CARD
*****    BE    AOBESD              YES, GO THERE
*****    IF DESIRED, INSERT COUNTER HERE FOR UNKNOWN TYPES OF CARDS.
         B     AOBREAD             UNKNOWN TYPE OF CARD-IGNORE IT
         SPACE 1
*        ***** PROCESSING CODE FOR INDIVIDUAL TYPES OF CARDS *****
         SPACE 2
*              ***** END CARD(S) *****
*              SETS R5 = ENTRY @, IF:  1) A PREVIOUS END CARD HAS     *
*              NOT ALREADY SPECIFIED ONE, AND 2) ONE IS GIVEN ON THIS *
*              END CARD.                                              *
AOBEND   EQU   *
         TM    AVTAGS1,AVOENTR     HAS ONE BEEN SPECIFIED ALREADY
         BO    AOBREAD             YES, SO DON'T DO IT AGAIN
         CLC   AOENTRY2,AWBLANK+1  WAS ENTRY POINT BLANK
         BE    AOBREAD             YES, SO IGNORE IT
         L     R5,AOENTRY          GET FULLWORD CONTAINING ENTRY @
         LA    R5,0(,R5)           REMOVE LEADING BYTE
         OI    AVTAGS1,AVOENTR     SHOW ENTRY @  FOUND, SO WONT DO AGAN
         B     AOBREAD             GO BACK FOR MORE (IF ANY)
         SPACE 2
*              ***** ESD CARD(S) *****                                *
*AOBESD  EQU   *                   EXTERNAL SYMBOL DICTIONARY
         SPACE 2
*              ***** RLD CARD(S) *****                                *
*AOBRLD  EQU   *                   RELOCATION DICTIONARY
         EJECT
*              ***** TXT CARD(S) *****                                *
*              MOVE TEXT CODE FROM CARDIMAGE INTO MEMORY.             *
*              COMPUTE RELOCATION FACTOR FROM FIRST TEXT CARD FOUND.  *
*              MAINTAIN HIGH LIMIT FOR ACTUAL OBJECT CODE, AND MAKE   *
*              SURE CODE DOES NOT EXCEED HIGH LIMIT, OR GO BELOW      *
*              THE LOW LIMIT (AFTER FIRST TEXT CARD).                 *
AOBTXT   EQU   *                   ENTRY LABEL FOR TEXT CARD
         L     R1,AOTADDR          GET @ CODE (USER PROG RELATIVE)
         LA    R1,0(,R1)           REMOVE HI-ORDER BYTE
         TM    AVTAGS1,AVO1TXT     HAVE WE GOTTEN AT LEAST 1 TXT CARD
         BO    AOBTXT1             YES, SO SKIP
*              FIRST TEXT CARD - COMPUTE RELOCATION FACTOR
         LR    R4,R2               MOVE REAL BEGINNING @ OVER
         SR    R4,R1               SUBTRACT USER LOW @ FROM REAL= RELOC
         OI    AVTAGS1,AVO1TXT     FLAG SO WE DON'T COMPUTE IT AGAIN
         BZ    AOBTXT1             NO, LEAVE ENTRY PT REG AS IS
         TM    AVTAGS1,AVOENTR     HAS ENTRY PT BEEN RECEIVED ALREADY
         BO    AOBTXT1             YES, SO DON'T CHANGE R5
         LR    R5,R1               MAKE DEFAULT ENTRY PT THE FIRST BYTE
AOBTXT1  AR    R1,R4               RELOC USER @ TO REAL ONE
         CR    R1,R2               WAS IT LOWER THAN REAL LIMIT
         BL    AOBTXTIL            YES, GO TO FLAG OR PRINT MESSAGE
         IC    R8,AOTLENG2         GET LENGTH FROM CARD OF CODE
         LA    R0,0(R8,R1)         GET REAL @+1 OF LAST BYTE OF CODE
         CR    R0,R9               WAS IT HIGHER THAN ACTUAL SPACE
         BH    AOBTXTIH            YES, TOO MUCH CODE-EXIT
         CR    R0,R3               WAS IT HIGHER THAN PREVIOUS HIGH
         BNH   *+6                 NO, SKIP
         LR    R3,R0               YES, SET NEW HIGH LIMIT
         SPACE 1
         LTR   R8,R8               WAS LENGTH=0 (POSSIBLE FOR DS'S)
         BZ    AOBREAD             YES, SO DON'T DO ANYTHING
         BCTR  R8,0                DECREMENT LENGTH TO LENGTH-1 FOR MVC
         EX    R8,AOBTXTMV         MOVE TEXT CODE OVER
         B     AOBREAD             RETURN FOR NEXT CARD
AOBTXTMV MVC   0($,R1),AOTCODE     MOVE CODE TO MEMORY **MODIFIED**
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              EXIT CODE - CHECK AND STORE FINAL ADDRESSES            *
*        MAKE SURE WE RECIEVED AT LEAST 1 TEXT CARD, ASSURE *8        *
*   LENGTH MULTIPLE, AND STORE BLOCK OF 6 ADDRESSES APPROPRIATELY.    *
*   NOTE THAT ALTERATIONS MUST BE MADE IF THE USER CODED RELOC, IN    *
*   WHICH CASE HIS PROGRAM MUST EITHER BE LOADED FROM WHERE IT WAS    *
*   ASSEMBLED ORIGINALLY, OR MUST CONTAIN NO ADDRESS CONSTANTS AT ALL.*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
AOBJEOF  EQU   *
         TM    AVTAGS1,AVO1TXT     DID WE GET AT LEAST 1 TXT CARD
         BZ    AOBNOTXT            NO, QUIT NOW WITH ERROR
         LA    R3,7(,R3)           ROUND UPPER REAL @ UP
         SRL   R3,3                SHIFT TO REMOVE 3 BITS
         SLL   R3,3                SHIFT BACK, NOW ALIGNED
         TM    AVTAGS1,AJORELOC    WAS THIS TO BE RELOACTED MODE
         BZ    AOBJNORM            NO, NORMAL-SKIP
         AR    R5,R4               RELOCATE USER LOCATION TO REAL
         SR    R4,R4               MAKE EXECUTION RELOC FACTOR = 0
AOBJNORM EQU   *                   FINAL STORE OF @'S
         STM   R2,R5,AVRADL        AV(RADL-RADH-RELOC-FENTER)
         SR    R2,R4               RADL-RELOC = FAKE LOW @ FOR USER
         SR    R3,R4               RADH-RELOC = FAKE HIGH LIMIT @
         STM   R2,R3,AVLOCLOW      AV(LOCLOW-LOCHIH) -USER RELATIVE LIM
         SPACE 1
*              SUCCESFFUL COMPLETION MESSAGE AL100.
         BAL   R14,AOBHEXCO        GO CONVERT VALUES TO HEX
         DC    H'4'                # ITEMS IN LIST
         DC    AL2(AVLOCLOW-AVWXTABL,AOB100A-AOB)     LOWEST USER @
         DC    AL2(AVLOCHIH-AVWXTABL,AOB100B-AOB)     HIGH USER @
         DC    AL2(AVFENTER-AVWXTABL,AOB100C-AOB)     FAKE ENTRY @
         DC    AL2(AVRELOC-AVWXTABL,AOB100D-AOB)      RUN TIME RELOC
         BAL   R14,AOBPRINT        PRINT COMPLETED MESSAGE
         DC    AL2(AOB100-AOB,AOB100L)      MESSG OFFSET, LENGTH
         SPACE 1
AOBJEXIT $RETURN RGS=(R14-R12),SA=NO        RETURN TO CALLER
         SPACE 1
*              ***** ERROR EXITS *****
AOBNOTXT BAL   R14,AOBPRINT        PRINT AL996 - NO TEXT CARDS FOUND
         DC    AL2(AOB996-AOB,AOB996L)      OFFSET, LENGTH
         B     AOBJBAD             GO TO SHOW ABORT
AOBTXTIL BAL   R14,AOBPRINT        AL997 - TXT @ TOO LOW
         DC    AL2(AOB997-AOB,AOB997L)      OFFSET,LENGTH
         B     AOBTXTID            GO TO DUMP STMT FOR USER
AOBTXTIH BAL   R14,AOBPRINT        AOB998 - OVERFLOW OF AREA
         DC    AL2(AOB998-AOB,AOB998L)      OFFSET, LENGTH
AOBTXTID BAL   R14,AOBDUMP         DUMP USER CARDIMAGE, FALL TO AOBJBAD
AOBJBAD  BAL   R14,AOBPRINT        GO PRINT AL999 - LOAD ABORT
         DC    AL2(AOB999-AOB,AOB999L)      OFFSET, LENGTH
         OI    AVTAGS1,AJNLOAD     FLAG NOLOAD
         B     AOBJEXIT            RETURN SHOWING ERROR
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> INSUB: AOBDUMP    DUMP CURRENT USER CARDIMAGE                    *
*        ENTRY CONDITIONS                                             *
*   R14= RETURN ADDRESS TO CALLING CODE                               *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
AOBDUMP  EQU   *
         XSNAP T=(NO,,0),LABEL='IMAGE OF INCORRECT OBJECT CARD',       X
               STORAGE=(*AOBJCARD,*AOBJCARD+80)
         BR    R14
         SPACE 2
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> INSUB: AOBHEXCO   CONVERT VALUES TO EDITED HEXADECIMAL           *
*        ENTRY CONDITIONS                                             *
*   R14= @ PARAMETER LIST.  LIST CONSISTS OF THE FOLLOWING:           *
*        1) HALFWORD GIVING # ITEMS IN LIST TO BE CONVERTED.          *
*        2) 1 OR MORE PAIRS OF OFFSET VALUES GIVING DISPLACEMENT      *
*        FROM AVWXTABL TO FULLWORD VARIABLE TO BE CONVERTED, AND      *
*        OFFSET FROM LABEL AOB TO 6-BYTE FIELD WHERE EDITED HEX       *
*        SHOULD BE PLACED. REQUIRES FREE BYTE AFTER THIS FIELD.       *
*        EXIT CONDITIONS                                              *
*   R0,R1,R14,R15  ARE ALL MODIFIED.                                  *
*   CONTROL RETURNED TO LOCATION AFTER PARAMETER LIST.                *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
AOBHEXCO LH    R0,0(,R14)          GET # ENTRIES IN FOLLOWING LIST
AOBHEX2  LH    R1,2(,R14)          GET OFFSET OF FULLWORD TO CONVERT
         LA    R1,AVWXTABL(R1)     GET ACTUAL @ OF VARIABLE
         LH    R15,4(,R14)         GET OFFSET TO OUTPUT FIELD
         LA    R15,AOB(R15)        GET ACTUAL @ OUTPUT FIELD
         UNPK  0(7,R15),1(4,R1)    UNPACK 3 BYTES, WITH EXTRA FOR EASE
         TR    0(6,R15),AWTHEX3    TRANSLATE TO PRINTABLE
         MVI   6(R15),C' '         PUT IN BLANK AFTER TO WIPE EXTRA OUT
         LA    R14,4(,R14)         BUMP PTR TO NEXT PAIR
         BCT   R0,AOBHEX2          LOOP THORUGH LIST
         B     2(,R14)             RETURN TO CALLER
         SPACE 2
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> INSUB: AOBPRINT   PRINT 1 LINE OF OUTPUT MESSAGE                 *
*        ENTRY CONDITIONS                                             *
*   R14= @ PARAMETER LIST, WHICH HAS OFFSET @ OF MESSAGE FROM AOB,    *
*        FOLLOWED BY LENGTH OF MESSAGE, BOTH IN HALFWORDS.            *
*        EXIT CONDITIONS                                              *
*   R0,R1      ARE MODIFIED.                                          *
*   CONTROL RETURNED TO LOCATION AFTER PARAMETER LIST.                *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
AOBPRINT LA    R0,AOB              BASE @ FOR MESSAGE
         AH    R0,0(,R14)          ADD IN OFFSET @
         LH    R15,2(,R14)         LENGTH OF MESSAGE
         $PRNT (R0),(R15)          PRINT THE MESSAGE
         B     4(,R14)             RETURN TO CALLER
         EJECT
*              AOBJIN LOADER MESSAGES - AL###                         *
*              AL000 - BEGINNIG HEADER LABEL.                         *
*              AL100 - SUCCESSFUL COMPLETION.                         *
*              AL996 - NO TEXT CARDS RECEIVED.                        *
*              AL997 - TXT CARD @ TOO LOW                             *
*              AL998 - TXT CARD @ TOO HIGH - OVERFLOW OF AREA         *
*              AL999 - LOAD ABORTED MESSAGE                           *
AOB      EQU   *                   BASE FOR OFFSET @'S IN PARM LISTS
         SPACE 1
AOB000   DC    C'0*** AL000 - ASSIST LOADER BEGINS LOAD AT '
AOB000A  DC    XL6'0'              LOWEST @ = AVADDLOW
         DC    C' ,USABLE CORE ENDS AT '
AOB000B  DC    XL6'0',C' ***'      HIGH LIMIT = AVADDHIH
AOB000L  EQU   *-AOB000            LENGTH OF THIS MESSAGE
         SPACE 1
AOB100   DC    C'0*** AL100 - LOAD COMPLETED, USER ADDRESSES: LOW '
AOB100A  DC    XL6'0',C' ,HIGH '   AVLOCLOW - LOW USER LIMT
AOB100B  DC    XL6'0',C' ,ENTRY '  HIGH LIMIT  AVLOCHIH
AOB100C  DC    XL6'0',C' . RUN-TIME RELOCATION '      USER ENTRY @
AOB100D  DC    XL6'0',C' ***'      AVRELOC - RUN-TIME RELOCATION
AOB100L  EQU   *-AOB100            LENGTH OF THIS MESSAGE
         SPACE 1
AOB996   DC    C'0*** AL996 - NO TXT CARD RECEIVED ***'
AOB996L  EQU   *-AOB996            LENGTH OF MESSAGE
         SPACE 1
AOB997   DC    C'0*** AL997 - TXT CARD ADDRESS BELOW 1ST TXT CARD ***'
AOB997L  EQU   *-AOB997            LENGTH OF MESSAGE
         SPACE 1
AOB998   DC    C'0*** AL998 - TXT CARD ADDRESS EXCEEDED STORAGE ***'
AOB998L  EQU   *-AOB998            LENGTH OF MESSAGE
         SPACE 1
AOB999   DC    C' *** AL999 - LOAD ABORTED ***'
AOB999L  EQU   *-AOB999            LENGTH OF MESSAGE
         DROP  R6,R7,RAT           REMV USINGS: BASE,AOBJCARD,AVWXTABL
.AOBJN1  AIF   (NOT &$DECK).AOBNONE    SKIP IF NO DECK
         EJECT
         ENTRY AODECK
AODECK   $SAVE RGS=(R14-R12),SA=NO,BR=R6
         USING AVWXTABL,RAT        NOTE ASSEMBLER CONTROL TABLE
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> ENTRY: AODECK     PUNCH OBJECT DECK FOLLOWING ASSEMBLY           *
*        IF THE DECK OPTION IS SPECIFIED, AODECK IS CALLED FOLLOWING  *
*   A SUCCESSFULL ASSEMBLY TO PUNCH THE USER PROGRAM OUT IN OBJECT    *
*   DECK FORM.  THE DECK PUNCHED CONTAINS 1 OR MORE TXT CARDS AND     *
*   1 END CARD, AND FOLLOWS S/360 DECK FORMAT FAIRLY CLOSELY.         *
*        **NOTE** THIS FACILITY IS VERY PRIMITIVE, AND THE DECKS      *
*   PRODUCED CANNOT REALLY BE USED FOR ANYTHING BUT INPUT TO ASSIST,  *
*   SINCE THERE IS NEITHER EXTERNAL SYMBOL DICTIONARY NOR RELOCATION  *
*   DICTIONARY PRODUCED.  ALSO, SINCE THE ENTIRE USER PROGRAM IS      *
*   PUNCHED, OBJECT CARDS ARE PRODUCED FOR SPACE CONTAINING ONLY DS   *
*   LOCATIONS.  IN SOME CASES, THIS COULD CAUSE HUGE DECKS TO BE      *
*   PUNCHED.   IF A BETTER SETUP IS DESIRED, ASSEMBLER MODULE UTOPRS  *
*   COULD BE CHANGED TO PRODUCE SMALLER DECKS, ALTHOUGH RLD ENTRIES   *
*   WOULD STILL BE DIFFICULT TO PRODUCE.                              *
*        **NOTE** THE MOST LIKELY USE FOR THIS OPTION IS TO PRODUCE   *
*   OBJECT DECKS TO BE USED AS UTILITY PROGRAMS FROM RJE TERMINALS.   *
*        ENTRY CONDITIONS                                             *
*   R12(RAT) = @ ASSEMBLER CONTROL TABLE (AVWXTABL).                  *
*        USES MACROS: $PNCH,$RETURN,$SAVE                             *
*        NAMES: AOD-----                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
* * * * * * * * REGISTER USAGE FOR AODECK * * * * * * * * * * * * * * *
*   R4 = @ CURRENT BLOCK OF CODE TO BE PUNCHED (INIT = AVRADL).       *
*   R5 = CURRENT LENGTH OF CODE REMAINING (INIT =AVRADH-AVRADL)       *
*   R6 = BASE REGISTER                                                *
*   R7 = @ AOBJCARD : OBJECT CARD OUTPUT IMAGE                        *
*   R8 = CURRENT @ OF CODE TO PUNCHED (USER PROGRAM RELATIVE).        *
*   R9 = L'AOTCODE = LENGTH OF NORMAL(ALL BUT LAST) CODE ON CARD      *
*   R12(RAT)= @ ASSEMBLER CONTROL TABLE (AVWXTABL).                   *
*   R13= @ CALLING PROGRAM'S SAVE AREA, UNCHANGED                     *
*   R14= INTERNAL LINK REGISTER                                       *
*   ALL OTHERS ARE UNUSED                                             *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              INITIALIZATION FOR OBJECT PUNCH                        *
*        INITIALIZE REGISTERS, SEQUENCE #, AND TXT CARDIMAGE.         *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         LM    R4,R5,AVRADL        AV(RADL-RADH) LOWER/UPPER REAL @'S
         SR    R5,R4               SIZE OF CODE = UPPER-LOWER LIMIT
         BNP   AODEXIT             NO MORE, QUIT
         LA    R7,AVCONCAT         WE WILL USE THIS AS WORKAREA
         USING AOBJCARD,R7         NOTE PTR THERE
         L     R8,AVLOCLOW         GET LOWEST USER PROGRAM @
         MVC   AOBJCARD(72),AWBLANK    BLANK OUT CARD, EXCEPT SEQUENCE
         MVC   AOBJTYPE,=C'TXT'    FLAG AS TXT CARD
*****    MVI   AOBJCARD,X'02'      NORMAL S/360 FLAG
         LA    R9,L'AOTCODE        LENGTH OF NORMAL OBJECT CODE
         STH   R9,AOTLENG          STORE FOR NORMAL LENGTH
         ZAP   AVDWORK1(5),AWP0    ZERO WORKAREA FOR SEQUENCE#
         UNPK  AOTSEQN(8),AVDWORK1(5)       MOVE SEQUENCE # OVER
         OI    AOTSEQN+7,X'F0'     MAKE PRINTABLE
         MVI   AODTXTMV+1,L'AOTCODE-1       NORMAL LENGTH-1 OF OBJCODE
         SPACE 1
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              LOOP FOR PUNCHING OBJECT DECK                          *
*        PUNCH FULL OBJECT CARD FOR (ALL BUT POSSIBLY LAST BLOCK)     *
*   OF CODE IN USER PROGRAM.                                          *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
AODTXT   EQU   *
         ST    R8,AOTADDR          STORE USER CODE FAKE @ INTO CARD
*****    MVI   AOTADDR,C' '        BLANK OUT FOR S/360 NORMAL
         CR    R5,R9               HOW MUCH IS LEFT TO BE PUNCHED
         BNL   AODTNORM            STILL ENOUGH FOR FULL CARD-BRANCH
         SPACE 1
         BCTR  R5,0                LENGTH-1 FOR MVC
         STC   R5,AODTXTMV+1       STORE INTO MVC FOR LAST PUNCH
         MVC   AOTCODE,AWBLANK     BLANK OUT WHOLE CARD, SINCE PART NOT
AODTNORM EQU   *
AODTXTMV MVC   AOTCODE($),0(R4)    MOVE CODE FROM MEMORY
         BAL   R14,AODPUNCH        GO PUNCH THE CARD
         AP    AVDWORK1(5),AWP1    INCREMENT THE CARD COUNTER
         UNPK  AOTSEQN(8),AVDWORK1(5)       UNPACK FOR NEXT CARD
         OI    AOTSEQN+7,X'F0'     MAKE SURE PRINTABLE
         AR    R8,R9               INCREMENT USER CODE @
         AR    R4,R9               INCREMENT REAL @ IN MEMORY PTR
         SR    R5,R9               DECREMENT LENGTH PUNCHED LAST TIME
         BP    AODTXT              IF MORE TO DO, RETURN FOR NEXT CARD
         SPACE 1
*              ***** COMPLETION - PUNCH END CARD
         MVC   AOBJTYPE,=C'END'    MAKE CARD AN END CARD
         MVC   AOEBLNK(AOEBLNKL),AWBLANK    BLANK OUT CARD(CEPT SEQN#)
         MVC   AOENTRY2,AVFENTER+1 MOVE ENTRY @ IN
         BAL   R14,AODPUNCH        PUNCH THE ASSEMBLED END CARD
AODEXIT  $RETURN RGS=(R14-R12),SA=NO
         SPACE 1
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> INSUB: AODPUNCH   PUNCH 1 OBJECT CARD FOR AODECK                 *
*        ENTRY CONDITIONS                                             *
*   R14= RETURN @ TO CALLING SECTION OF CODE                          *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
AODPUNCH EQU   *
         $PNCH AOBJCARD,80,AODEXIT PUNCH, QUIT IF OVERRUN
         BR    R14                 RETURN TO CALLING SECTION
         LTORG
         DROP  R6,R7,RAT           REMV USINGS: BASE,AOBJCARD,AVWXTABL
.AOBNONE ANOP
         AIF   (&$EXINT).EXYZ      SKIP IF USING EXTENDED INTERPRETER
         TITLE '*** EXECUT - ASSIST INTERPRETER SECTION ***'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> CSECT: EXECUT       INTERPRETER SECTION                          *
*              EXECUT PERFORMS ALL 360 INSTRUCTION SIMULATION DURING  *
*        INTERPRETIVE EXECUTION OF THE USER PROGRAM.  ALL CONTROL     *
*        VALUES FOR THIS MODULE ARE CONTAINED IN DSECT ECONTROL, WHICH*
*        IS PASSED TO EXECUT BY THE CALLING PROGRAM.  THE INSTRUCTION.*
*        SET SIMULATED INCLUDES THE FOLLOWING:                        *
*              1. STANDARD INSTRUCTION SET (INCL. 370'S IF ALLOWED)   *
*              2. DECIMAL INSTRUCTION SET (IF PRESENT ON MACHINE).    *
*              3. FLOATING POINT INSTRUCTIONS (OPTIONAL).             *
*              4. X-MACRO PSEUDO INSTRUCTIONS - XDUMP, XLIMD,         *
*                XPNCH, XPRNT, XREAD.                                 *
*        THE PRIVILEGED OPERATIONS MAY BE DECODED TO THE POINT OF     *
*        BRANCHING TO INDIVIDUAL INSTRUCTION HANDLERS, BUT THEY ARE   *
*        ARE FLAGGED WITH AN 0C2 INTERRUPT AT PRESENT, AND ARE NOT    *
*        INTERPRETED FURTHER.  THE CODE PRESENT IS FOR FUTURE USE.    *
*              THE SVC INSTRUCTION IS CURRENTLY FLAGGED WITH AN 0C2 IF*
*        USED, BUT CODE EXISTS TO HANDLE ALL SVC CALLS IN A TABLE-    *
*        DRIVEN WAY, USING THE @ OF AN SVC CONTROL TABLE PASSED IN THE*
*        WORD ECSVCADS IN ECONTROL.  AS OF 8/2/70, THERE ARE NOT SVC  *
*        ROUTINES, BUT THE CODE EXISTS FOR FUTURE USE.                *
*              GENERAL CODE IS ALSO PROVIDED FOR ANY ADDITIONAL NEW   *
*        INSTRUCTIONS OR I/O SIMULATORS BY THE SECTION EXCALL, WHICH  *
*        ALLOWS CALLS TO EXTERNAL ROUTINES (WHICH WOULD BE USED BY    *
*        ANY SVC CALLS, IF THERE ARE ANY).                            *
*        ENTRY CONDITIONS                                             *
*   R10= @ ECONTROL - EXECUTION CONTROL BLOCK.                        *
*   ECONTROL CONTAINS ALL INITIAL VALUES FOR REGS,LIMITS,ETC.         *
*        EXIT CONDITIONS                                              *
*   ECINTCOD   CONTAINS INTERRRUPT CODE, IF PROGRAM INTERRUPT.        *
*   ECFLAG1    CONTAINS SPECIAL COMPLETION CODE, IF ANY.              *
*   ECERRAD  = ADDRESS OF AN ERCOMPCD ERROR COMPLETION CODE BLOCK     *
*   ECONTROL   CONTAINS ALL OTHER VALUES NEEDED FOR A COMPLETION DUMP.*
*        USES DSECTS: ECONTROL,ECSTACKD                               *
*        USES MACROS: $AL2,$ERCGN,$PNCH,$PRNT,$READ,$RETURN,$SAVE     *
*        USES MACROS: $SPIE, XDECI, XDECO, XSNAP                      *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
EXECUT   CSECT
         $DBG  ,NO                 KILL TRACE CODE HERE
         SPACE 1
EXPRFETC EQU   B'10000000'         (EXIPROT) - INST ACCESSES STORAGE
EXPRSTOR EQU   B'01000000'         (EXIPROT) - INST MODIFIES STORAGE
EXPRFET2 EQU   B'00100000'         (EXIPROT) - SS INST ACCESSES CORE
EXPRSTO2 EQU   B'00010000'         (EXIPROT) - SS INST MODS CORE(2ND @)
         SPACE 1
*        *** SYMBOLIC REGISTER EQUATES ***                            *
RSTK     EQU   R3                  ADDR OF CURRENT INST. STACK ENTRY
RIA      EQU   R4                  INSTRUCTION ADDRESS REGISTER
RCC      EQU   R5                  CONDITION CODE REGISTER
REC      EQU   R6                  POINTER TO ECONTROL BLOCK
RWK      EQU   R7                  WORK REGISTER
RR1      EQU   R8                  DECODING REGISTER FOR R1 FIELD
RR2      EQU   R9                  REGISTER 2 (WHEN USED IN RR'S)
RX2      EQU   RR2                 INDEX REGISTER(FOR RX'S)
RR3      EQU   RR2                 RO OPERAND(FOR RS INST)
RB1      EQU   R10                 1ST BASE-DISPLACEMENT-(B1-D1)
RB2      EQU   R11                 2ND BASE-DISPLACEMENT-(B2-D2)
RMEM     EQU   R12                 CONTAINS RELOCATION VALUE
RLINK    EQU   R14                 INTERNAL LINAKGE REGISTER-RETURN ADD
ROP      EQU   R15                 USED TO HOLD OPCODE BYTE
*        **NOTE** DURING MAIN EXECUTION REGS R2,ROP ARE BYTE REGS.    *
         SPACE 1
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*              ORGANIZATION OF THE ASSIST INTERPRETER                 *
*                                                                     *
*        1.    INITIALIZATION CODE                                    *
*        2.    INTERRUPT-HANDLING AND EXIT CODE                       *
*        3.    OCCASIONAL INTERNAL SUBROUTINE CODE                    *
*        4.    PRIMARY INSTRUCTION FETCH AND COMMON DECODING          *
*        5.    1ST-LEVEL DECODING, IN GROUPS :  RR, RX, SI-RS, AND SS *
*        6.    2ND-LEVEL SECTIONS-PERFORM INDIVIDUAL INSTRUCTIONS,    *
*              IN GROUPS:  RR, RR-RX OVERLAP, RX, SI, RS, SS,SPECIAL  *
*        7.    3RD-LEVEL INTERNAL SUBROUTINES (DECODERS,RANGE CHECK)  *
*        8.    DATA AREAS, OPCODE BRANCH AND PROTECTION TABLES        *
*                                                                     *
*        **WARNING** ADDRESSIBILITY IS NOW TIGHT IN EXECUT.           *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        INITIALIZATION PHASE - OBTAIN PARAMATER ADDRESSES FROM CALLER*
*   PERFORM CALCULATIONS TO GET THEM INTO NEEDED FORM. ZERO OUT THE   *
*   INSTRUCTION STACK FINSTACK,AND INITIALIZE ANY REQUIRED REGISTER   *
*   VALUES FOR THE EXECUTION. ALSO SAVE INSTRUCTION LIMIT VALUE.      *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         $SAVE RGS=(R14-R12),BR=R8,SA=EXECSAVE
         LR    REC,R10             MOVE ECONTROL BLOCK POINTER OVER
         USING ECONTROL,REC        NOTE USAGE
         TM    ECFLAG0,$ECCONT     IS THIS A CONTINUE OR A NEW
         BO    EXCONTIN            INIT ALREADY DONE-KEEP GOING
         OI    ECFLAG0,$ECCONT     NOTE THAT ANY OTHERS WILL BE CONTINU
         SPACE 1
*              INSTRUCTION STACK ZEROING AND CHAINING.                *
         SR    R1,R1               CLEAR FOR ZEROING USE
         SR    R2,R2               CLEAR FOR ZEROING
         SR    R3,R3               CLEAR FOR ZEROING
         LA    R4,L'ECSTENT        VALUE OF SINGLE ENTRY
         LA    R5,ECINSTAC+L'ECINSTAC*(EC$STACK-1)     GET ENDING LIMIT
         LA    R7,ECINSTAC         GET BEGINNING ADDRESS OF STACK AREA
         USING ECSTACKD,R7         SET UP TEMPORARY USING
         LA    R0,ECINSTAC+L'ECINSTAC        GET @ 2ND ELEMENT
         SPACE 1
EXINITST STM   R0,R3,ECSTENT       ZERO 1 TABLE ENTRY
         LR    R7,R0               UPDATE POINTER TO STACK ENTRY
         BXLE  R0,R4,EXINITST      CONTINUE LOOPING
         SPACE 1
         LA    R0,ECINSTAC         ADDRESS FOR WRAPAROUND
         STM   R0,R3,ECSTENT       STORE IN LAST ENTRY
         ST    R7,ECRSTK           SAVE WHERE CAN BE PICKED UP
         DROP  R7        DROP TEMPORARY REG TO KEEP USING STRAIGHT
         MVC   ECILIMT,ECILIMP     MOVE PERMANENT TO TEMPORARY
         MVC   ECILCMSK(4),ECFENTER          MAKE ENTRY POINT THE PSW
         MVC   ECR14SAV,ECREG14    SAVE FOR ORIGINAL RETURN @
         SPACE 1
EXCONTIN BAL   RLINK,EXADCALC      GO TO RECALCULATE ADDRESSES IF NEED
         SPACE 1
EXSPIEGO EQU   *
         TM    ECFLAG0,$ECSPIEA    IS OUR SPIE ALREADY IN EFFECT
         BO    EXSPIEA             YES,WE DON'T HAVE TO RE-SPIE
         $SPIE EXSPIERT,((1,15)),CE=EXSPIEXT,ACTION=CR  CATCH ALL INTRP
         ST    R1,ECPICA           SAVE PREVIOUS PICA, IF ANY
         OI    ECFLAG0,$ECSPIEA    SHOW OUR SPIE IS IN CONTROL
EXSPIEA  L     RSTK,ECRSTK         GET POINTER TO NEXT SLOT FOR STACK
         USING ECSTACKD,RSTK       SET UP STACK USING FROM NOW ON
         L     RMEM,ECRELOC        GET RELOCATION VALUE IN REGISTER
         SR    R2,R2               CLEAR REG FOR CONSTANT INSERTS
         STH   R2,ECINTCOD         SET THE INTERRUPT CODE TO 0
         SR    ROP,ROP             CLEAR OPCODE REG FOR CONSTANT IC'S
         L     RB2,ECILCMSK        LOAD INST ADDR WHERE EXFINB EXPECTS
         LR    RCC,RB2             PLACE CC AND MASK OVER
         SPM   RCC                 INITIALIZE REAL CC TO FAKE ONE
         AIF   (NOT &$FLOTE).EXNOFL1         SKIP IF NOT GOING TO DO FP
         LD    F0,ECFPREGS         GET FP REG
         LD    F2,ECFPREGS+8       GET 2ND FP REG
         LD    F4,ECFPREGS+16      LOAD 3RD FP REG
         LD    F6,ECFPREGS+24      GET 4TH FP REG
.EXNOFL1 ANOP
         B     EXFINB              SKIP TO START RUN
EXECSAVE DC    18F'0'              SAVE AREA, ALSO BASE REGISTER HERE
         DROP  R8                  KILL TEMPORARY USING
         USING EXECSAVE,R13        USE R13 AS BASE/SAVEAREA POINTER
EXJUMP   DS    0H                  BASE FOR 2ND LEVEL INDEX JUMPS
         SPACE 1
* * * * * 0CX INTERRUPT EXITS   * * * * * * * * * * * * * * * * * * * *
*              THE LABELS ARE HERE SO THAT OTHERS MAY BE EQU'D TO THEM*
EX0C1    LA    R0,1                SHOW OPERATION INTERRUPT
         AIF   (&$DEBUG).EX0C1A    SKIP DEBUG CODE IF PRODUCTION
         CLI   ECOP,X'83'          IS CODE THE PSEUDO DIAGNOSE
         BE    EXDIAG              YES,GO THERE FOR OUR PSEUDO DIAGNOSE
.EX0C1A  ANOP
         B     EXEXITI             EXIT POINT FOR INTERRUPTS
EX0C2C   EQU   *                   CHECK FOR PRIVILEGED OPERATION
         TM    ECKYAMWP,$ECPRBST   ARE WE IN PROBLEM STATE
         BCR   Z,RLINK             NO,SUPERVISOR STATE,SO OK-RETURN
EX0C2    LA    R0,2                PRIVILEGED OPERATION
         B     EXEXITI             EXIT POINT FOR INTERRUPTS
EX0C3    LA    R0,3                EXECUTE INTERRUPT
         B     EXEXITI             EXIT POINT FOR INTERRUPTS
EX0C4    LA    R0,4                PROTECTION INTERRUPT
         B     EXEXITI             EXIT POINT FOR INTERRUPTS
*EX0C5   LA    R0,5                ADDRESSING INTERRUPT
*        B     EXEXITI             QUIT
EX0C6    LA    R0,6                SPECIFICATION INTERRUPT
         B     EXEXITI             EXIT POINT FOR INTERRUPTS
*EX0C7   LA    R0,7                DATA EXCEPTION
*        B     EXITI               QUIT
EX0CA    LA    R0,10               DECIMAL OVERFLOW
         B     EXEXITI             QUIT
         SPACE 2
*              ENTERED WHEN PROGRAM BRANCHES OUT OF RANGE             *
EXIAOUT  MVI   ECFLAG1,$ECBRN14    HOPE FOR NORMAL RETURN
         L     R14,ECR14SAV        GET RETURN @, ORIGINAL
         LA    R14,0(R14)          REMOVE LEADING BYTE
         CR    RIA,R14             WAS BRANCH TO THIS @
         BE    EXITA               RETURN
         MVI   ECFLAG1,$ECBROUT    WAS ACTUAL BRANCH OUT OF PROG,RET
         LA    R1,EXCCBROU         SHOW @ BRANCH OUT
         B     EXITIA              GO HAVE @ STORED, QUIT
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              INTERRUPT HANDLER - THIS SECTION IS ENTERED FOR ANY    *
*        REAL INTERRUPT, SUCH AS 0C7,0C6,ETC.  THE REAL INTERRUPT     *
*        IS SAVED AS THE PSEUDO INTERRUPT, SINCE THEY MUST BE THE     *
*        SAME. THE ADDRESS IN THE PSW PART OF THE PIE IS MODIFIED SO  *
*        THAT OS WILL RETURN CONTROL TO EXSPIERT INSTEAD OF TO THE    *
*        INTERRUPTED CODE, AND THEN CONTROL IS GIVEN TO OS. WHEN THE  *
*        INTERPRETER REGAINS CONTROL, IT EXITS, SHOWING AN INTERRUPT. *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         USING *,R15
EXSPIEXT LH    RB1,2(R1)           GET INTERRUPT CODE FROM PIE
         AIF   (&$DEBUG).EXXNSP    SKIP IF PRODUCTION
         XSNAP LABEL='SPIE',STORAGE=(*0(R1),*32(R1)),                  X
               IF=(ECFLAG2,O,X'20',TM)      XSNAP PIE
.EXXNSP  ANOP
         BR    R14                 RETURN TO OS CONTROL
         DROP  R15                 DROP USING TO KEEP STRAIGHT
         SPACE 1
EXSPIERT LR    R0,RB1              MOVE INTERRUPT CODE OVER WHERE NEED
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              EXIT AND RETURN CODE - SAVE EVERYTHING REQUIRED,       *
*        REMOVE $SPIE IF NECESSARY, AND RETURN TO CALLER.             *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
EXEXITI  STH   R0,ECINTCOD         SAVE INTO INTERRUPT CODE
         MVI   ECFLAG1,0           RESET, NEEDED BY REPLACE MONITOR
*              FOLLOWING FINDS MESSAGE FOR 0CX COMPLETION CODES.      *
         ALR   R0,R0               SLL R0,1,DOUBLE CODE FOR INDEX
         LR    R1,R0               MOVE WHERE WE CAN USE FOR INDEX
         LH    R1,EXCOFFS(R1)      GET OFFSET TO MESSAGE BLOCK
         LA    R1,EXCC0(R1)        GET @ MESSAGE BLOCK
EXITIA   ST    R1,ECERRAD          STORE THIS @ IN ECONTROL
         SPACE 1
EXITA    ST    RSTK,ECRSTK         SAVE THE STACK POINTER
         N     RCC,=XL4'3F000000'  REMOVE @, ILC(WHICH IS WRONG)
         ALR   RCC,RIA             PUT THE ADDRESS AND CONCODE TOGETHER
         ST    RCC,ECILCMSK        SAVE INTO THE PSW
         OI    ECILCMSK,X'40'      SET ILC TO =1
         CLI   ECOP,X'40'          WAS LAST INSTRUCTION RR
         BL    EXITAILC            YES, SO ILC IS SET RIGHT,BRANCH
         XI    ECILCMSK,X'C0'      SET ILC TO 2 FOR RX-SI-RS
         CLI   ECOP,X'C0'          WAS INST AN SS
         BL    EXITAILC            NO, IT WAS SI-RX-RS, BRANCH, ILC=2
         OI    ECILCMSK,X'40'      SET ILC=3 FOR SS INSTS
EXITAILC EQU   *
         AIF   (NOT &$FLOTE).EXNOFL3         SKIP IF NOT FLOATINGS
         STD   F0,ECFPREGS         STORE FIRST FP REG
         STD   F2,ECFPREGS+8       STORE 2ND FP REG
         STD   F4,ECFPREGS+16      SAVE THE THIRD FP REG
         STD   F6,ECFPREGS+24      SAVE 4TH FP REG
.EXNOFL3 ANOP
         TM    ECFLAG0,$ECSPIEB    DO WE NEED TO UNDO SPIE
         BZ    EXECRET             NO WE DON'T,SO DON'T SPIE
         L     R1,ECPICA           GET PICA ADDRESS BACK
         $SPIE ACTION=(RS,(1))     RESTORE PREVIOUS XSPIEBLK
         NI    ECFLAG0,255-$ECSPIEA          WE WILL HAVE TO RESPIES
EXECRET  $RETURN RGS=(R14-R12)
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        SPECIAL ROUTINES - THE FOLLOWING ROUTINES ARE USED AT MOST   *
*        OCCASIONALLY, AND ARE NOT DIRECTLY PARTS OF THE INTERPRETER. *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              EXTERNAL CALL ROUTINE - THIS SECTION PREPARES ALL OF   *
*        THE DUMMY MACHINE AREAS, AND CALLS THE ROUTINE WHOSE ADDRESS *
*        IS IN RWK.  IT CHECKS FOR AN INTERRUPT CONDITION,RESTORES    *
*        ALL THE REGISTERS, AND RETURNS CONTROL TO NORMAL EXECUTION.  *
*        ***NOTE*** THIS ROUTINE IS MAINLY FOR FUTURE USE, I.E. FOR   *
*        IMPLEMENTATION OF CERTAIN SVC'S, MACHINE LEVEL I/O, OR       *
*        ANY ADDITIONAL PSEUDO MACHINE OPCODES WHICH ARE REQUIRED.    *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
EXCALL   STM   R0,R15,ECTSAVE      SAVE THE REGS TO BE SAFE
         ST    RSTK,ECRSTK         SAVE POINTER IN CONTROL BLOCK
         N     RCC,=XL4'3F000000'  REMOVE EXTRA BITS IN CC REG
         ALR   RCC,RIA             PUT THE ADDRESS AND CONCODE TOGETHER
         ST    RCC,ECILCMSK        SAVE INTO THE PSW
         LR    R15,RWK             PLACE ADDRESS IN R15 FOR CALL
         BALR  RLINK,R15           CALL THE ROUTINE
         LM    R0,R15,ECTSAVE      RESTORE THE REGS
         SR    R0,R0     CLEAR THIS OUT
         CH    R0,ECINTCOD         SEE IF INTERRUPT CODE
         BNE   EXITA               IF THERE WAS CODE-RETURN
         CLI   ECFLAG1,0           WAS SPECIAL CODE STILL 0
         BNE   EXITA               NO,SO EXIT WITH ERROR FLAG
         BAL   RLINK,EXADCALC      HAVE ADDRESS RECALCULATED IF NEEDED
         L     RB2,ECILCMSK        GET PSW BACK
         LR    RCC,RB2             GET CC AND MASK BACK
         B     EXFINB              BRANCH THERE, IN CASE PSW CHANGED
         SPACE 1
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              ADDRESS CALCULATION SECTION - IF THE ADDRESS VALUES    *
*        MAY HAVE BEEN CHANGED, OR ARE NOT ALREADY COMPUTED,THIS      *
*        SECTION FINDS THE USER HIGH ADDRESS AND RELOCATION FACTOR    *
*        GIVEN REAL LOW AND HIGH ADDRESSES, AND USER LOW ADDRESS.     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
EXADCALC TM    ECFLAG0,$ECADSOK    SEE IF THE ADDR'S NEED FIXING
         BCR   O,RLINK             RETURN IF CALCULATIONS UNNEEDED
         OI    ECFLAG0,$ECADSOK    FLAG ADDRS OK, WHICH THEY WILL BE
         L     R0,ECRADH           GET REAL HIGH ADDRESS LIMIT
         S     R0,ECRADL           GET LENGTH OF PROGRAM
         A     R0,ECFADL           ADD TO FAKE LOW ADDRESS
         ST    R0,ECFADH           STORE THIS IN FAKE HIGHEST
         SH    R0,=H'256'          FOR @ CHECKING DIFFERENCE
         ST    R0,ECFADHC          SAVE FOR @ CHECKING EXRANGE
         L     R0,ECRADL           GET REAL LOWEST ADDRESS
         S     R0,ECFADL           SUBTRACT TO GET RELOCATION EXEC
         ST    R0,ECRELOC          SAVE THIS FOR EXECUTION TIME RELOCAT
         BR    RLINK               RETURN TO CALLING SECTION
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        MAIN INTERPRETER LOOP HEAD. ALL SUCCESSFUL BRANCHES PASS     *
*   THROUGH EFINB, WHICH CHECKS FOR ILLEGAL BRANCHES. CONTROL THEN    *
*   PASSES THROUGH EFIN,WHICH CHECKS FOR LOOPING BEYOND INSTRUCTION   *
*   COUNT LIMIT.  ALL OTHER INSTRUCTIONS SKIP EFINB AND RETURN        *
*   DIRECTLY TO EFIN.   THE NEXT INSTRUCTION IS THEN ACCESSED,DECODED *
*   PARTIALLY FOR 4-WAY BRANCH (RR,RX,SI&RS,SS),AND VARIOUS           *
*   BOOKKEEPING DETAILS DONE (UPDATING INSTRUCTION ADDRESS,MOVING     *
*   INSTRUCTION INTO NEXT STACK LOCATION,ETC. )                       *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
EXFINB   LA    RIA,0(RB2)          MOVE BRANCH ADDRESS OVER,REM 1ST BYT
         C     RIA,ECFADL          COMPARE FOR BELOW LOWEST FAKE
         BL    EXIAOUT             BRANCHED OUT OF RANGE
         C     RIA,ECFADH          COMPARE TO NEXT ADDRESS BEYOND AREA
         BNL   EXIAOUT             ADDRESS OUT OF RANGE-ERROR
         AIF   (NOT &$ALIGN).EXFT1 SKIP IF MACHINE REQUIRES ALIGN
         ST    RB2,ECTSAVE         SAVE ADDR: MUST DO CHECK SLOW WAY
         TM    ECTSAVE+3,X'01'     WAS ADDR ODD
         BO    EX0C6               YES-BAD PROGRAMMER-JUMP
.EXFT1   AIF   (&$ALIGN).EXFT2     SKIP IF ALIGN NOT NEEDED
         LH    R0,0(RB2,RMEM)      QUICK ALIGNEMNT CHECK
.EXFT2   ANOP
*              IF TIMER RUNOUT OCCURS, ASSIST SETS ECFLAG1=$ECTIMEX.
*              EXECUT DISCOVERS THIS NEXT TIME BRANCH IS SUCCESSFUL.
         AIF   (&$TIMER EQ 0).EXNOTOA       SKIP IF NO TIMER AT ALL
         CLI   ECFLAG1,$ECTIMEX    HAS FLAG BEEN SET BY TIMER EXIT
         BE    EXOVRTIM            YES, SO GO THERE, TIME RAN OUT
.EXNOTOA ANOP
         SPACE 2
*              CHECK FOR EXCEEDING TOTAL INSTRUCTION COUNT            *
*              ALL INSTRUCTIONS BUT SUCCESSFUL BRANCHES ENTER HERE    *
EXFIN    L     R0,ECILIMT          GET THE COUNTER
EXTIMDEC BCT   R0,EXGO             DECREMENT COUNTER, BRANCH IF OK
         ST    R0,ECILIMT          RESTORE INST COUNT FOR STATS(0)
         MVI   ECFLAG1,$ECTIMEX    SHOW TIME EXCEEDED(INSTR LIMIT)
         LA    R1,EXCCTIME         SHOW @ TIME MESSAGE
         B     EXITIA              GO TO FINISH AND EXIT
         AIF   (&$TIMER EQ 0).EXNOTOB       SKIP IF NO TIMER AT ALL
EXOVRTIM LA    R1,EXCCTIMB         SHOW TIMER OVER. ECFLAG1 ALREADY SET
         B     EXITIA              SKIP TO EXIT SECTION
.EXNOTOB ANOP
EXGO     ST    R0,ECILIMT          STORE THIS BACK IN LIMIT
         SPACE 1
*              INSTRUCTION FETCH AND PRIMARY DECODING SECTION.        *
         SPACE 1
         LA    RWK,0(RIA,RMEM)     OBTAIN PHYSICAL REAL ADDRESS
EXFEXENT L     RSTK,ECSTLINK       OBTAIN ADDRESS OF NEXT STACK SLOT
         STM   RIA,RCC,ECSTIADD    SAVE INSTRUCTION ADDRESS,CC,MASK
         MVC   ECSTINST,0(RWK)     MOVE 6 BYTES INTO NEXT SLOT
         IC    ROP,ECOP            GET OPCODE INTO REGISTER
         IC    R2,EXOPTAB1(ROP)    GET SECONDARY CODE FOR OPCODES
         LR    R1,ROP              GET OPCODE WHERE CAN BE CHANGED
         SRL   R1,6                REMOVE ALL BUT 1ST 2 BITS
         SLL   R1,2                SHIFT BACK = MULT*4 FOR INDEX
         AIF   (&$DEBUG).EXSNAP1   SKIP XSNAPS GENERATION IF NOT DEBUG
         XSNAP LABEL='PRIMARY FETCH',IF=(ECFLAG2,O,X'80',TM),          #
               STORAGE=(*ECSTENT,*ECB2D2+2,*ECFPREGS,*ECILIMP)
         LM    RB1,RB2,ECRADL      GET LOW AND HIGH @ POINTERS
         XSNAP T=NO,LABEL='USER AREA',STORAGE=(*0(RB1),*0(RB2)),IF=(ECF#
               LAG2,O,X'40',TM)
.EXSNAP1 ANOP
         SPACE 1
*              UPDATE INSTRUCTION COUNTER RIA TO NEXT INSTRUCTION,    *
*        TAKE 4-WAY BRANCH TO PRIMARY TYPE DECODING SECTIONS.         *
EXEXLEN  A     $CHN+RIA,EXILENG(R1)    UPDATE RIA**CHANGED BY EXEX*****
EXPRIME  B     *+4(R1)             TAKE BRANCH FOR PRIMARY PROCESSING
         B     EXTRR               R1=0 ==> RR INSTRUCTION
         B     EXTRX               R1=4 ==> RX INSTRUCTION
         B     EXTSIRS             R1=8 ==> SI OR RS INSTRUCTION
         B     EXTSS               R1=12 ==> SS INSTRUCTION
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        RR PRIMARY DECODING - DECODE R1-R2 FIELDS,THEN MAKE          *
*   SECOND LEVEL BRANCH TO INDIVIDUAL INSTRUCTION PROCESSORS.         *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
EXTRR    BAL   RLINK,EXR1R2        GET R1,R2 FIELDS SEPARATED
         LH    R1,EXSECRR(R2)      GET SECOND LEVEL BRANCH INDEX VALUE
         B     EXJUMP(R1)          TAKE BRANCH TO INDIVIUDAL ROUTINES
         SPACE 4
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        RX PRIMARY DECODING - DECODE B2-D2 FIELDS,R1-X2 FIELDS,      *
*   YIELDING 2ND OPERAND ADDRESS IN REGISTER RB2. IF INSTRUCTION IS   *
*   ONE OF THOSE NOT REQUIRING ADDRESS RELOCATION(I.E. BRANCHES OF    *
*   SOME TYPE,LOAD ADDRESS) TAKE SECOND LEVEL BRANCH IMMEDIATELY.     *
*   FOR OTHER INSTRUCTIONS,THE 2ND OPERAND ADDRESS IS CHECKED FOR     *
*   WITHIN THE PERMITTED RANGE BY EXRANGE, AND THEN THE ADDRESS IS    *
*   RELOCATED TO THE ACTUAL CORE ADDRESS.  THEN THE SECOND-LEVEL      *
*   CHOICE IS MADE FOR THE INDIVIDUAL PROCESSORS.                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
EXTRX    BAL   RLINK,EXABD         PERFORM B2-D2 ADDRESS CALCULATION
         BAL   RLINK,EXR1R2        OBTAIN R1,X2 FIELDS
         BZ    EXRXNOX             IF X2=0,NO INDEXING NEED BE DONE
         AL    RB2,ECREGS(RX2)     PERFORM INDEXING OPERATION
         LA    RB2,0(RB2)          ZAP POSSIBLE 1ST BYTE FROM X2 FIELD
EXRXNOX  LH    R1,EXSECRX(R2)      GET BRANCH INDEX ADDRESS
         CH    R2,EXNORNG          COMPARE WITH HIGHEST FOR NO RANGECK
         BNH   EXJUMP(R1)          TAKE BRANCH TO ROUTINES
         BAL   RLINK,EXRANGE       HAVE THE RANGE CHECKED FOR THE INST
         AR    RB2,RMEM            RELOCATE FAKE @ TO REAL @
         AIF   (&$S370 NE 2).EXTRX SKIP IF NOT SIMULATING S/370'S
         TM    ECFLAG4,AJONALGN    MUST WE FAKE ALIGNMENT
         BZ    EXJUMP(R1)          NO--> BRANCH
         CH    R2,EXALIGN          DOES INSTRUCTION REQUIRE ALIGNMENT
         BH    EXJUMP(R1)          NO--> BRANCH
         LTR   RB1,RB2             SAVE FOR LATER, SET CC TO ^=
         MVC   EXDUBLWD(8),0(RB2)  MOVE MAXIMUM OF 8 BYTES OVER
         LA    RB2,EXDUBLWD        LOAD ADDRESS OF ALIGNED FIELD
.EXTRX   ANOP
         B     EXJUMP(R1)          TAKE BRANCH TO APPROPRIATE ROUTINE
         SPACE 4
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        SI-RS PRIMARY DECODING - DECODE B1-D1 FIELD,WITH RESULTING   *
*   ADDRESS APPEARING IN REGISTER RB2. THEN MAKE SECOND-LEVEL CHOICE  *
*   TO THE VARIOUS INDIVIDUAL PROCESSORS.                             *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
EXTSIRS  BAL   RLINK,EXABD         ADDRESSING FOR B1-D1 FIELD
         LH    R1,EXSECSI(R2)      GET SECOND LEVEL JUMP INDEX
         B     EXJUMP(R1)          TAKE BRANCH TO INDIVIUAL ROUTINE
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        SS PRIMARY DECODING - DECODE AND CHECK 1ST AND 2ND OPERAND   *
*   ADDRESSES FOR WITHIN RANGE,USING DECODED VALUES OF L OR L1 AND L2 *
*   FIELDS AS REQUIRED. AFTER RELOCATING TO ACTUAL MACHINE ADDRESSES, *
*   MAKE SECOND-LEVEL BRANCH TO INDIVIDUAL PROCESSOR SEGMENTS.        *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
EXTSS    BAL   RLINK,EXABD         HAVE 1ST @ DECODED
         BAL   RLINK,EXRANGE       CHECK 1ST @ FOR WITHIN RANGE
         LA    RB1,0(RB2,RMEM)     RELOCATE THE 1ST @ TO REAL @
         LH    RB2,ECB2D2          GET THE BASE-DISP FOR 2ND @
         BAL   RLINK,EXABD1        HAVE 2ND @ DECODED
         SPACE 1
*              NOTE THAT THE FOLLOWING SEQUENCE IS ESSENTIALLY LIKE   *
*        THE SECTION EXRANGE.  THIS IS REQUIRED BECAUSE THE 1ST AND   *
*        2ND OPERANDS OF SS INSTRUCTIONS DO NOT NECESSARILY HAVE THE  *
*        SAME PROTECTION ATTRIBUTES, I.E. 1ST OPERANDS ARE SOMETIMES  *
*        STORE PROTECTION VIOLATION CAUSES, WHILE 2ND OPERANDS USUALLY*
*        CAUSE ONLY FETCH PROTECTION VIOLATIONS, IF ANY.              *
         C     RB2,ECFADL          IS @ LOWER THAN LOWEST ALLOWED
         BL    EXSSL               TOO LOW,GO SEE IF REALLY ILLEGAL
         C     RB2,ECFADHC         COMP WITH ACTUAL HI LIM(ECFADH-256)
         BL    EXSSL2              @ ACCEPTABLE,GO RELOCATE AND EXECUTE
         SPACE 1
*              ADDRESS OUT OF RANGE-CHECK INST TYPE/PROTECTION MODE.  *
EXSSL    LA    RWK,EXIPROT-64(ROP) GET @ PROTECTION CONTROL BYTE
         TM    0(RWK),EXPRSTO2+EXPRFET2     ANY CORE ACCESS AT ALL?
         BO    EXRANOUT            YES,AND @ OUT OF RANGE-GO TO FLAG
         SPACE 1
         BZ    EXSSL2              NO IT ISN'T,SO ITS OK ANYWAY
         TM    ECFLAG0,$ECPROT     OUT OF RANGE,FETCH PROT,IF MODE ON
         BNZ   EXRANOUT            ABSOLUTE PROTECT MODE-SO PROTECT ERR
         SPACE 1
EXSSL2   AR    RB2,RMEM            RELOCATE THE 2ND OP ADDRESS
         MVC   EXQSS(2),ECOP       MOVE THE OPCODE AND LENGTH(S) OVER
         LH    R1,EXSECSS(R2)      GET SECOND LEVEL BRANCH INDEX
         B     EXJUMP(R1)          TAKE BRANCH
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        SECOND-LEVEL PROCESSOR SECTIONS - THESE SECTIONS PERFORM     *
*   ALL REQUIRED COMPUTING AFTER INITIAL DECODING HAS BEEN DONE IN    *
*   RESPECTIVE PRIMARY SECTIONS.                                      *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 4
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              RR SECOND-LEVEL PROCESSOR SECTION.                     *
*              TO CONDENSE CODE IN  RR SECTION, REMOVE THE CODE       *
*        SECTIONS BELONGING TO EXLR AND EXFPRR AND EQU THOSE SYMBOLS  *
*        TO EXNORMRR INSTEAD                                          *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
*              SET PROGRAM MASK                                       *
EXSPM    L     RCC,ECREGS(RR1)     PLACE SPECIFIED REG INTO CC REGISTER
         SPM   RCC                 SET REAL CC-PM TO FAKE CC-PM
         B     EXFIN               RETURN FOR NEXT INSTRUCTION
         SPACE 1
         AIF   (&$PRIVOP).EXSSK    SKIP AND GENERATE RITH CODE-PRIVS OK
EXSSK    EQU   EX0C2               PRIVILEGEDS NOT ALLOWED-FLAG
EXISK    EQU   EX0C2               PRIVILEGEDS NOT ALLOWED-FLAG
         AGO   .EXSVC              SKIP OVER GENERATION OF CODE
.EXSSK   ANOP
EXSSK    BAL   RLINK,EX0C2C        GO CHECK FOR SUPERVISOR STATE
EXISK    BAL   RLINK,EX0C2C        GO CHECK FOR SUPERVISOR STATE
.EXSVC   ANOP
         SPACE 1
EXSVC    L     RWK,ECSVCADS        GET @ SVC CONTROL TABLE,IF EXISTS
         LTR   RWK,RWK             ARE SVC'S ALLOWED
         BZ    EX0C2               NO SVC'S AT ALL,SO ERROR
         IC    RR1,ECI2            GET IMMEDIATE FIELD
         IC    RR1,0(RR1,RWK)      GET SVC OFFSET BYTE TO @ ROUTINE
         SLA   RR1,2               MULT*4 FOR INDEX TO FULLWORDS
         BZ    EX0C2               IF =0,MAKE IT PRIVILEGED OPERATION
         L     RWK,256(RWK)        GET @ SVC ROUTINE @ TABLE
         L     RWK,0(RR1,RWK)      PICK UP ACTUAL @ SVC ROUTINE
         B     EXCALL              GO TO CALL ROUTINE
*        **NOTE** AN SVC CONTROL TABLE IS 260 BYTES LONG, CONTAINING  *
*        256 BYTES OF INDIVIUDAL SVC INDICATORS, AND 1 FULLWORD PTR.  *
         EJECT
*              REGULAR RR INSTRUCTIONS - 3 ENTRIES TO SEQUENCE -      *
*              LR        (SEPARATE SINCE CURRENT CC IS NOT CHANGED)   *
*              NR,CLR,OR,XR,CR,AR,SR,ALR,SLR -   NORMALS              *
*              LPR,LNR,LTR,LCR     (DO NOT NEED R1 LOADED)            *
EXLR     L     RWK,ECREGS(RR2)     GET SECOND OPERAND
         ST    RWK,ECREGS(RR1)     PLACE INTO FIRST OPERAND
         B     EXFIN               RETURN FOR NEXT INSTRUCTION
         SPACE 1
EXNORMRR L     RWK,ECREGS(RR1)     OBTAIN 1ST OPERAND
EXLPNTR  L     RR2,ECREGS(RR2)     OBTAIN 2ND OPERAND
         STC   ROP,EXQRR           PLACE ACTUAL OPCODE INTO INST
EXQRR    LR    $CHN+RWK,RR2        **RIGHT OPCODE IS ENTERED IN *******
         ST    RWK,ECREGS(RR1)     SAVE IN FAKE 1ST OPERAND LOCATION
         BAL   RCC,EXFIN           GET CC, RETURN FOR NEXT INST
         SPACE 1
         AIF   (&$FLOTEX).EXXFPRR  GO GENERATE CODE IF XFP OK
EXXFPRR  EQU   EX0C1               NOTE XFP NOT ALLOWED
         AIF   (&$FLOTE).EXFPRR    GO GENERATE IF FLOATINGS OK
EXFPRR   EQU   EX0C1               NOTE WE DO NOT ALLOW FLOATINGS
         AGO   .EXFPRR2
.EXXFPRR ANOP
EXXFPRR  EQU   *                   CODE FOR XFP SAME AS REGULAR FP
.EXFPRR  ANOP
         SPACE 2
*              RR FLOATING POINT INSTRUCTIONS.                        *
EXFPRR   SPM   RCC                 SET THE CONDITION CODE
         EX    0,ECOP              EXECUTE THE ACTUAL INSTRUCTION
         BAL   RCC,EXFIN           GET CC, RETURN FOR NEXT INST
.EXFPRR2 ANOP
         SPACE 2
         AIF   (&$S370 NE 0).EXLONG1 SKIP IF GENERATING S/370'S
EXLONG   EQU   EX0C1               NOTE S/370 RR'S NOT ALLOWED
         AGO   .EXLONG3            SKIP OVER CODE GENERATION
.EXLONG1 ANOP
*        ADDRESS CHECKING CODE FOR CLCL, AND MVCL
EXLONG   EQU   *                   COMMON CODE FOR MVCL, CLCL CHECKING
         TM    ECR1R2,X'11'        DID HE SPECIFY EVEN REGS?
         BNZ   EX0C6               NO--> SPECIFICATION ERROR
         L     R0,EXLONGMK         LOAD MASK TO ZAP TOP OF REGS
         LA    R1,ECREGS(RR1)      GET ADDRESS OF FIRST REGISTER PAIR
         LM    RB1,RB2,0(R1)       LOAD FIRST SET OF REGISTERS
         NR    RB1,R0              GET RID OF UPPER BYTE OF ADDRESS
         NR    RB2,R0              GET RID OF UPPER BYTE OF LENGTH
         BZ    EXLONG2             IF LENGTH = 0, DON'T CHECK ADDRESS
         C     RB1,ECFADL          IS ADDRESS TOO LOW?
         BL    EXLONG1             YES - BRANCH TO CHECK PROTECTION
         LR    RWK,RB1             COPY ADDRESS TO WORK REGISTER
         AR    RWK,RB2             COMPUTE HIGHEST ADDRESS
         C     RWK,ECFADH          IS IT ABOVE MAXIMUM FOR USER?
         BL    EXLONG2             NO - BRANCH AROUND PROTECTION CHECK
EXLONG1  CLI   ECOP,14             IS THIS A MVCL INSTRUCTION
         BE    EX0C4               YES - PROTECTION ERROR
         TM    ECFLAG0,$ECPROT     IS FETCH PROTECT ON?
         BNZ   EX0C4               YES - PROTECTION ERROR
         SPACE 2
*        FIRST ADDRESS OK - CHECK SECOND
EXLONG2  LA    R2,ECREGS(RR2)      GET ADDRESS OF SECOND REG. PAIR
         LM    RR1,RR2,0(R2)       LOAD SECOND SET OF REGISTERS
         NR    RR1,R0              GET RID OF UPPER BYTE AF ADDRESS
         NR    RR2,R0              GET RID OF UPPER BYTE OF LENGTH
         BZ    EXLONG4             IF LENGTH = 0, DON'T CHECK ADDRESS
         C     RR1,ECFADL          IS ADDRESS TOO LOW?
         BL    EXLONG3             YES - BRANCH TO CHECK FOR PROTECTION
         LR    RWK,RR1             COPY ADDRESS INTO WORK REGISTER
         AR    RWK,RR2             COMPUTE HIGHEST ADDRESS
         C     RWK,ECFADH          IS IT ABOVE USER MAXIMUM
         BL    EXLONG4             NO - BRANCH AROUND ERROR CHECK
EXLONG3  TM    ECFLAG0,$ECPROT     IS ABSOLUTE PROTECT ON
         BNZ   EX0C4               YES - PROTECTION ERROR
         SPACE 2
*        BOTH ADDRESSES ARE OK - RELOCATE THEM AND PERFORM COMMAND
EXLONG4  ALR   RB1,RMEM            RE-LOCATE ADDRESS TO ACTUAL
         ALR   RR1,RMEM            RE-LOCATE ADDRESS TO ACTUAL
         SPACE 2
         AIF   (&$S370 NE 1).EXLONG2 SKIP IF NOT ON REAL 370
         L     RB2,4(,R1)          RESTORE UPPER BYTES IN LENGTH REGS
         L     RR2,4(,R2)          RESTORE UPPER BYTES IN LENGTH REGS
         STC   ROP,EXQLONG         STORE IN OPCODE
EXQLONG  CLCL  RB1,RR1             *** OPCODE STORED IN ***
         BALR  RCC,0               CAPTURE COND CODE
         AGO   .EXLONG4
.EXLONG2 ANOP
         CLI   ECOP,14             IS THIS A MVCL COMMAND?
         BE    EXMVCL              YES - BRANCH
         SPACE 2
*        CODE FOR CLCL COMMAND
         LTR   RR2,RR2             SECOND LENGTH = 0?
         BZ    EXCLCL6             YES - BRANCH TO CHECK FIRST LENGTH
         LTR   RB2,RB2             FIRST LENGTH = 0?
         BZ    EXCLCL2             YES - BRANCH TO USE PAD & OPND 2
EXCLCL1  CLC   0(1,RB1),0(RR1)     COMPARE A CHARACTER FROM EACH FIELD
         BNE   EXCLCL5             IF NOT EQUAL, WE ARE DONE - BRANCH
         LA    RB1,1(,RB1)         INCREMENT POINTERS
         LA    RR1,1(,RR1)         INCREMENT POINTERS
         BCT   RB2,EXCLCL3         DECREMENT FIRST LENGTH, BRANCH ^= 0
         B     EXCLCL7             LENGTH = 0 - BRANCH INTO PAD LOOP
EXCLCL2  CLC   4(1,R2),0(RR1)      COMPARE PAD TO OPND 2
         BNE   EXCLCL5             IF NOT EQUAL, WE ARE DONE - BRANCH
         LA    RR1,1(,RR1)         INCREMENT POINTER
EXCLCL7  BCT   RR2,EXCLCL2         DECREMENT SECOND COUNT - BRANCH ^= 0
         B     EXCLCL5             IF LENGTH = 0, OPNDS = - WE'RE DONE
EXCLCL3  BCT   RR2,EXCLCL1         DECREMENT SECOND LENGTH, BRANCH ^= 0
EXCLCL4  CLC   0(1,RB1),4(R2)      COMPARE FIRST OPND & PAD
         BNE   EXCLCL5             IF NOT EQUAL, WE ARE DONE - BRANCH
         LA    RB1,1(,RB1)         INCREMENT POINTER
         BCT   RB2,EXCLCL4         DECREMENT LENGTH, BRANCH ^= 0
EXCLCL5  BAL   RCC,EXLONG5         CAPTURE CON CODE AND RETURN
EXCLCL6  LTR   RB2,RB2             FIRST LENGTH = 0?
         BNZ   EXCLCL4             NO, USE 1ST OPND AND PAD
         BAL   RCC,EXLONG5         GET COND CODE (=0) AND RETURN
         SPACE 2
*        CODE FOR MVCL COMMAND
EXMVCL   EQU   *                   CODE FOR MVCL COMMAND
         LR    R0,RB2              ASSUME FIRST LENGTH SMALLEST
         CR    RB2,RR2             COMPARE THE LENGTHS
         BALR  RCC,0               CAPTURE CON CODE
         BL    *+6                 IF FIRST LOWER, BRANCH
         LR    R0,RR2              SECOND LENGTH MUST BE THE SMALLER
         LTR   R0,R0               IS SMALLEST LENGTH = 0?
         BZ    EXMVCL3             IF SMALLER = 0, BRANCH
         SPACE 2
*        FOLLOWING CODE CHECKS FOR DESTRUCTIVE OVERLAP
         CR    RB1,RR1             IS 1ST FIELD AFTER SECOND?
         BNH   EXMVCL1             NO - NO OVERLAP - BRANCH
         AR    RWK,RMEM            RE-LOCATE HIGH OPND 2 ADDRESS
         CR    RB1,RWK             IS 1ST FIELD AFTER END OF 2ND
         BNL   EXMVCL1             YES - NO OVERLAP - BRANCH
         TM    *+1,1               SET CON CODE TO OVERFLOW (3)
         BAL   RCC,EXLONG5         CAPTURE CON CODE AND RETURN
         SPACE 2
EXMVCL1  SR    RB2,R0              DECREMENT LENGTHS BY THE SMALLER
         SR    RR2,R0              DECREMENT LENGTHS BY THE SMALLER
EXMVCL2  MVC   0(1,RB1),0(RR1)     MOVE A BYTE
         LA    RB1,1(,RB1)         INCREMENT POINTERS
         LA    RR1,1(,RR1)         INCREMENT POINTERS
         BCT   R0,EXMVCL2          DECREMENT LENGTH, IF ^= 0, BRANCH
EXMVCL3  LTR   RB2,RB2             DO WE NEED PADDING?
         BZ    EXLONG5             NO - WE ARE DONE - BRANCH
         MVC   *+7(1),4(R2)        MOVE PAD CHAR INTO MVI INSTRUCTION
EXMVCL4  MVI   0(RB1),$CHN         MOVE PAD TO FIRST OPRND
         LA    RB1,1(,RB1)         INCREMENT POINTER
         BCT   RB2,EXMVCL4         DECREMENT LENGTH - IF ^= 0, BRANCH
         SPACE 2
*        COMMON CLCL, MVCL EXIT CODE
EXLONG5  XC    5(3,R1),5(R1)       ZAP LOWER PART OF LENGTH IN CORE
         XC    5(3,R2),5(R2)       ZAP LOWER PART OF LENGTH IN CORE
         O     RB2,4(,R1)          PUT UPPER BYTE BACK INTO REG
         O     RR2,4(,R2)          PUT UPPER BYTE BACK INTO REG
         L     R0,EXLONGMK         GET MASK TO ZAP UPPER BYTE OF REGS
.EXLONG4 ANOP
         SPACE 2
*        OPERATION COMPLETE - RESTORE REGISTERS AND RETURN
         SLR   RB1,RMEM            DE-RELOCATE FINAL ADDRESSES
         SLR   RR1,RMEM            DE-RELOCATE FINAL ADDRESSES
         NR    RB1,R0              ZAP UPPER BYTES OF ADDRESS REGS
         NR    RR1,R0              ZAP UPPER BYTES OF ADDRESS REGS
         STM   RB1,RB2,0(R1)       PUT REGISTERS BACK INTO CORE
         STM   RR1,RR2,0(R2)       PUT REGISTERS BACK INTO CORE
         SR    R2,R2               RESTORE R2 AS BYTE REGISTER
         B     EXFIN               RETURN
.EXLONG3 ANOP
         EJECT
*              RR-RX OVERLAP SECOND-LEVEL PROCESSOR SECTION.          *
         SPACE 1
*              BRANCH AND LINK  (BALR,BAL)                            *
EXBALR   MVI   EXILC,X'40'         SET ILC RIGHT
         LR    RB2,RIA             NO BRANCH WILL OCCUR-SET UP FOR REST
         BZ    EXBAL1              IF R2=0, NO BRANCH WILL OCCUR
         L     RB2,ECREGS(RR2)     BRANCH DOES OCCUR-LOAD ADDR IN
         B     EXBAL1              SKIP CODE TO SET FILC
EXBAL    MVI   EXILC,X'80'         SET ILC UP RIGHT
EXBAL1   N     RCC,=XL4'3F000000'  LEAVE ONLY CC-PM IN REGISTER RCC
         AL    RCC,EXILC           ADD ILC INTO PSW BEING BUILT
         ALR   RIA,RCC             NOW HAVE ILC-CC-PM-IA FILEDS
         ST    RIA,ECREGS(RR1)     PLACE BUILT PSW INTO FAKE REG
         B     EXFINB              BRANCH TAKEN-RETURN
         SPACE 1
*              BRANCH ON COUNT  (BCTR,BCT)                            *
EXBCTR   BNZ   EXBCTR1             IF R2=0,NO BRANCH WILL OCCUR
         L     RWK,ECREGS(RR1)     OBTAIN VALUE OF REGISTER
         BCTR  RWK,0               DECREMENT THE VALUE
         ST    RWK,ECREGS(RR1)     RESTORE IT TO FAKE REGISTER
         B     EXFIN               RETURN FOR NEXT INSTRUCTION
         SPACE 1
EXBCTR1  L     RB2,ECREGS(RR2)     GET BRANCH ADDRESS IN SAME AS BCT
EXBCT    L     RWK,=F'-1'          PUT -1 IN
         A     RWK,ECREGS(RR1)               ADD VALUE IN (DOING BCT)
         ST    RWK,ECREGS(RR1)     RESTORE DECREMENTED VALUE TO FAKE RG
         BNZ   EXFINB              IF NOT=0, BRANCH IS TAKEN
         B     EXFIN               BRANCH FAILED
         SPACE 1
*              BRANCH ON CONDITION  (BCR,BC)                          *
EXBCR    BZ    EXFIN               IF R2 IS 0, NO BRANCH OCCURS
         L     RB2,ECREGS(RR2)     BRANCH ADDRESS TO FIT WITH BC
EXBC     SLL   RR1,2               GET MASK BACK IN RIGHT SPOT
         SPM   RCC                 SET REAL CC = FAKE CC
         STC   RR1,EXQBC+1         STORE INTO MASK FIELD
EXQBC    BC    $CHN,EXFINB         **MASK STORED IN**
         B     EXFIN               BRANCH FIALED
         SPACE 1
*              MULTIPLY AND DIVIDE  (MR,DR,M,D)                       *
EXMRDR   LA    RB2,ECREGS(RR2)     MAKE ADDRESS COMPATIBLE WITH M-D
EXMD     TM    ECR1R2,X'10'        MAKE SURE R1 IS EVEN SPECIFICATION
         BO    EX0C6               SPECIFICATION ERROR-ODD REGISTER
         LA    RR1,ECREGS(RR1)     OBTAIN ACTUAL ADDRESS OF FAKE R1
         LM    R0,R1,0(RR1)        OBTAIN 2 FAKE REGISTER VALUES
         MVN   EXQMD(1),ECOP       MOVE CODE - SAYS M OR D
EXQMD    M     $CHN+R0,0(RB2)      **CHANGED TO M OR D DURING EXEC*****
         STM   R0,R1,0(RR1)        RESTORE THE REGISTERS TO THE FAKES
         B     EXFIN               RETURN FOR NEXT INSTRUCTION
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              RX SECOND-LEVEL PROCESSOR SECTION.                     *
*              TO CONDENSE CODE IN RX SECTION, THE CODE BELONGING     *
*        TO THE SECTIONS BEGINNING EXLOADS,EXSTORS,EXLA, AND EXFPRX   *
*        SHOULD BE EQU'D TO EXNORMRX, AND THE ACTUAL CODE OF THOSE    *
*        SECTIONS REMOVED.                                            *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
*              RX NORMAL (IC,CH,AH,SH,MH,N,CL,O,X,C,A,S,AL,SL)        *
EXNORMRX L     RWK,ECREGS(RR1)     OBTAIN 1ST OPERAND
         STC   ROP,EXQNORMR        STORE OPCODE IN
         SPM   RCC                 SET REAL CC = FAKE CC
EXQNORMR IC    $CHN+RWK,0(RB2)     **WILL BE CHANGED TO RIGHT OPCODE***
         ST    RWK,ECREGS(RR1)     PLACE RESULT INTO FAKE REGISTER
         BAL   RCC,EXFIN           GET CC, RETURN FOR NEXT INST
         SPACE 1
*              EXECUTE -USES SECTION OF PRIMARY DECODING SECTION      *
EXEX     LH    RWK,0(RB2)          QUICK CHECK FOR ALIGNMENT ERROR
         CLI   0(RB2),X'44'        MAKE SURE NOT AN EXECUTE
         BE    EX0C3               EXECUTE INTERRUPT
         LR    RWK,RB2             PUT ADDRESS WHERE EXPECTED
         MVC   EXEXLEN(2),EXEXBRNC REPLACE ADD BY BR RLINK
         BAL   RLINK,EXFEXENT      GO BACK AND DO COMMON SECTION
         SPACE 1
*              THE FOLLOWING EXECUTED AFTER PRIMARY DECODING DONE     *
         SR    RB2,RMEM            DE-RELOCATE INSTR @
         ST    RB2,ECSTIADD        STORE INTO INSTR STACK FOR DUMP
EXEXOR   MVC   EXEXLEN(2),EXEXLEN2 FIX UP A TO BE ONE AGAIN
         LTR   RR1,RR1             CHECK FOR R1 OPERAND BEING USED
         BZ    EXPRIME+4(R1)       NOTHING TO OR IN-BRANCH
         LA    RB2,ECREGS+3(RR1)   ADDRESS OF LAST BYTE OF GIVEN REG
         OC    ECR1R2,0(RB2)       OR BYTE INTO INSTRUCTION
         B     EXPRIME+4(R1)       TAKE PRIMARY BRANCH
EXEXLEN2 A     RIA,EXILENG(R1)     INST TO REPLACE MODIFIED ONE
         ORG   *-2                 WE ONLY NEED 1ST 2 BYTES OF LAST INS
EXEXBRNC BR    RLINK               WILL BE MOVED IN FOR EXECUTE
         SPACE 1
*              RX LOAD OPERATIONS(NO CC SETTING)  (LH,CVB,L)          *
EXLOADS  STC   ROP,EXQLOAD         STORE OPCODE IN
EXQLOAD  L     $CHN+RWK,0(RB2)     ** OPCODE WILL BE MOVED IN *********
         ST    RWK,ECREGS(RR1)     PLACE RESULT INTO FAKE REG
         B     EXFIN               RETURN FOR NEXT INSTRUCTION
         SPACE 1
*              RX STORE OPERATIONS  (NO CC SETTING)  (STH,CVD,STC,ST) *
EXSTORS  L     RWK,ECREGS(RR1)     OBTAIN 1ST OPERAND
         STC   ROP,EXQSTORS        STORE OPCODE INTO INST
EXQSTORS ST    RWK,0(RB2)          ** OPCODE WILL BE CHANGED***********
         AIF   (&$S370 NE 2).EXSTORS SKIP IF NOT SIMULATING S/370
         BZ    EXFIN               IF CHECKING ALIGNMENT, RETURN
         MVC   0(8,RB1),EXDUBLWD   PUT ALTERED CORE BACK IN RIGHT PLACE
.EXSTORS ANOP
         B     EXFIN               RETURN FOR NEXT INSTRUCTION
         SPACE 1
*        LOAD ADDRESS  LA                                             *
EXLA     ST    RB2,ECREGS(RR1)     PUT RESULT IN DESIRED FAKE REGISTER
         B     EXFIN               RETURN FOR NEXT INSTRUCTION
         AIF   (&$FLOTEX).EXXFPRX  SKIP IF WE HAVE EXTENDED FP
EXXFPRX  EQU   EX0C1               NOTE INSTRUCTIONS NOT ALLOWED
         AIF   (&$FLOTE).EXFPRX    GO GEN IF FLOATINGS ALLOWED
EXFPRX   EQU   EX0C1               NOTE FLOATINGS NOT ALLOWED
EXFPRXST EQU   EX0C1               NOTE FLOATINGS NOT ALLOWED
         AGO   .EXFPRX2            SKIP OVER GENERATION
.EXXFPRX ANOP
EXXFPRX  EQU   *                   CODE FOR EXTENDED FLOATINGS
.EXFPRX  ANOP
         SPACE 1
*        FLOATING POINT RX INSTRUCTIONS.                              *
EXFPRX   EQU   *                   ODD REG CHECK DONE WITH SPIE
         STC   ROP,EXQFPRX         STORE OPCODE IN
         SLL   RR1,2               GET R1 FIELD BACK INTO PLACE
         STC   RR1,EXQFPRX+1       STORE R1 FIELD INTO INST ALSO
         SPM   RCC                 SET THE CONDITION CODE
EXQFPRX  STD   $,0(,RB2)           **OPCODE AND R1 FIELDS STORED IN****
         BAL   RCC,EXFIN           GET CC, RETURN FOR NEXT INST
         AIF   (&$S370 EQ 2).EXFPRX1 SKIP IF SIMULATING S/370
EXFPRXST EQU   EXFPRX              CODE FOR STORES SAME AS OTHERS
         AGO   .EXFPRX2            SKIP AROUND CODE GENERATION
.EXFPRX1 ANOP
         SPACE 2
*        CODE FOR FLOATING POINT STORES WHEN FAKING ALIGNMENT
EXFPRXST EQU   *                   CODE FOR FLOATING POINT STORES
         STC   ROP,EXQFPRXS        STORE OPCODE IN
         SLL   RR1,2               GET R1 FIELD BACK INTO PLACE
         STC   RR1,EXQFPRXS+1      STORE R1 FIELD INTO INST ALSO
EXQFPRXS STD   $,0(,RB2)           **OPCODE AND R1 FIELDS STORED IN****
         BZ    EXFIN               IF ALIGNMENT CHECKING, RETURN
         MVC   0(8,RB1),EXDUBLWD   PUT ALTERED CORE BACK IN RIGHT PLACE
         B     EXFIN               RETURN
.EXFPRX2 ANOP
         SPACE 2
         AIF   (NOT &$XIOS).EXCONT SKIP IF NO XMACROS
*              XDECO - EXTENDED DECIMAL OUTPUT INSTRUCTION.           *
*        SPECIAL RX INSTRUCTION CONVERTS REGISTER VALUE TO EDITED     *
*        12-BYTE DECIMAL FIELD.  (X'52' OPCODE).                      *
EXXDECO  L     R0,ECREGS(RR1)      GET VALUE OF THE REGISTER
         XDECO R0,0(RB2)           CONVERT THE VALUE
         B     EXFIN               GO FOR NEXT INSTRUCTION
         SPACE 1
*              XDECI - EXTENDED DECIMAL INPUT INSTRUCTION.            *
*        SPECIAL INPUT CONVERTER, SCANS 1-9 DIGIT, SIGNED/UNSIGNED    *
*        DECIMAL NUMBERS WITH ANY # PRECEDING BLANKS. SETS CC TO 0,1,2*
*        ACCORDING TO VALUE OF RESULT.  CC=3 IF >9 DIGITS, OR 1ST     *
*        CHARACTER NOT +, -, DIGIT, OR + OR - WITHOUT DIGIT FOLLOWING.*
*        OPCODE IS HEX '53'  (RX FORMAT).                             *
EXXDECI  XDECI R0,0(RB2)           CONVERT AND SCAN VALUE
         BALR  RCC,0               SAVE THE CC
         BO    *+8                 SKIP STORE IF VALUE WAS BAD
         ST    R0,ECREGS(RR1)      SAVE THE CONVERTED VALUE IF OK
         SR    R1,RMEM             DE-RELOCATE THE SCAN PTR VALUE
         ST    R1,ECREG1           SAVE SCAN PTR IN USER REG 1
         B     EXFIN               GO BACK FOR NEXT INSTR
         SPACE 1
         AIF   (NOT &$HEXI).EXNOHXI    SKIP OF NO XHEXI
*              XHEXI-EXTENDED HEXADECIMAL INPUT INSTRUCTION           *
*        SPECIAL INPUT MACRO, SCANS 1-8 DIGITS.     SKIPS LEADING     *
*        BLANKS. SETS CONDITION CODE TO 3 IF ILLEGAL HEX CHARACTER    *
*        FOUND.  IF GREATER THAN 8 DIGITS FOUND R1 POINTS TO 9TH ELSE *
*        R1 POINTS TO FIRST NON-HEX CHARACTER IN STRING               *
*        (X'61' OPCODE)                                               *
EXXHEXI  XHEXI R0,0(RB2)               CONVERT AND SCAN VALUE
         BALR  RCC,0                   SAVE THE CC
         BO    *+8                     SKIP STORE IF VALUE WAS BAD
         ST    R0,ECREGS(RR1)          STORE CONVERTED VALUE IF OK
         SR    R1,RMEM                 DE-RELOCATE SCAN POINTER VALUE
         ST    R1,ECREG1               SAVE SCAN POINTER IN USER R1
         B     EXFIN                   GO FOR NEXT INSTRUCTION
         AGO   .EXCKHXO                CHECK IF XHEXO ALLOWED
.EXNOHXI ANOP
EXXHEXI  EQU   EX0C1                   INVALID OP-CODE
.EXCKHXO AIF   (NOT &$HEXO).EXNOHXO    SKIP IF NOT XHEXO ALLOWED
*              XHEXO-EXTENDED HEXADECIMAL OUTPUT MACRO                *
*        SPECIAL RX INSTRUCTION CONVERTS REGISTER VALUE TO OUTPUT     *
*        8 BYTE FORM.  (X'62' OPCODE).                                *
EXXHEXO  L     R0,ECREGS(RR1)          GET VALUE OF THE REGISYER
         XHEXO R0,0(RB2)               CONVERT VALUE
         B     EXFIN                   GET NEXT INSTRUCTION
         AGO   .EXCONT
.EXNOHXO ANOP
EXXHEXO  EQU   EX0C1                   INVALID OP CODE
.EXCONT  ANOP
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              SI SECOND-LEVEL PROCESSOR SECTION                      *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
*              ALL NORMAL SI'S - OP  D(B),I2                          *
EXSI     BAL   RLINK,EXRANGE       CHECK ADDRESS FOR IN RANGE
         AR    RB2,RMEM            RELOCATE TO REAL @
         MVC   EXQSI(2),ECOP       MOVE OPCODE AND I2 FIELD IN
         SPM   RCC                 SET REAL CON-CODE= FAKE ONE
EXQSI    TM    0(RB2),$CHN         ** OP AND I2 WILL BE MOVED IN*******
         BAL   RCC,EXFIN           GET CC, RETURN FOR NEXT INST
         SPACE 1
         AIF   (&$DEBUG).EXDIAG1   SKIP IF NOT  DEBUG MODE
*              DIAG-PSEUDO SI INSTRUCTION USED FOR DEBUGGING PURPOSES *
EXDIAG   MVC   ECFLAG2,ECI2        SUPPLY CONTROL FLAG TO BYTE
         B     EXFIN               GO BACK FOR NEXT INSTRUCTION
.EXDIAG1 ANOP
         SPACE 1
         AIF   (&$P370).EXLCTL     SKIP IF PRIVILEGED 370'S ALLOWED
EXLCTL   EQU   EX0C2               NO PRIVILEGED 370 OPS ALLOWED
EXSTCTL  EQU   EX0C2               NO PRIVILEGED 370 OPS ALLOWED
EXP370   EQU   EX0C2               NO PRIVILEGED 370 OPS ALLOWED
         AGO   .EXNP370            SKIP OVER CODE GENERATION
.EXLCTL  ANOP
EXLCTL   BAL   RLINK,EX0C2C        GO CHECK FOR SUPERVISOR STATE
EXSTCTL  BAL   RLINK,EX0C2C        GO CHECK FOR SUPERVISOR STATE
EXP370   BAL   RLINK,EX0C2C        GO CHECK FOR SUPERVISOR STATE
.EXNP370 ANOP
         AIF   (&$PRIVOP).EXSIO    GENERATE CODE,IF PRIVILEGEDS EXIST
EXSIO    EQU   EX0C2               NO PRIVILEGED OPS ALLOWED
EXTIO    EQU   EX0C2               NO PRIVILEGED OPS ALLOWED
EXHIO    EQU   EX0C2               NO PRIVILEGED OPS ALLOWED
EXSSM    EQU   EX0C2               NO PRIVILEGED OPS ALLOWED
EXTCH    EQU   EX0C2               NO PRIVILEGED OPS ALLOWED
EXLPSW   EQU   EX0C2               NO PRIVILEGED OPS ALLOWED
EXWRD    EQU   EX0C2               NO PRIVILEGED OPS ALLOWED
EXRDD    EQU   EX0C2               NO PRIVILEGED OPS ALLOWED
         AGO   .EXNOPRV            SKIP OVER CODE GENERATION
.EXSIO   ANOP
EXSIO    BAL   RLINK,EX0C2C        GO CHECK FOR SUPERVISOR STATE
EXTIO    BAL   RLINK,EX0C2C        GO CHECK FOR SUPERVISOR STATE
EXHIO    BAL   RLINK,EX0C2C        GO CHECK FOR SUPERVISOR STATE
EXTCH    BAL   RLINK,EX0C2C        GO CHECK FOR SUPERVISOR STATE
EXSSM    BAL   RLINK,EX0C2C        GO CHECK FOR SUPERVISOR STATE
EXLPSW   BAL   RLINK,EX0C2C        GO CHECK FOR SUPERVISOR STATE
EXWRD    BAL   RLINK,EX0C2C        GO CHECK FOR SUPERVISOR STATE
EXRDD    BAL   RLINK,EX0C2C        GO CHECK FOR SUPERVISOR STATE
.EXNOPRV ANOP
         AIF   (&$REPL GT 0).EXNREP0    SKIP IF REPL OPTION ALLOWED
EXXREPL  EQU   EX0C1               NO REPLACEMENT: MAKE ILLEGAL OP
.EXNREP0 AIF   (&$REPL EQ 0).EXNREPL    SKIP IF NO REPLACEMENT
         SPACE 2
EXXREPL  EQU   *                   CODE FOR XREPL COMMAND -REPLACE
         BAL   RLINK,EXRANGE       HAVE @ CHECKED FOR RANGE
         AR    RB2,RMEM            RELOCATE TO REAL @
         SPACE 1
         CLI   ECI2,0              WAS IT SET RFLAG TYPE XREPL
         BH    EXXREPL1            NO, SKIP TO NEXT TYPE
         MVC   ECRFLAG,0(RB2)      SET RFLAG FROM USER LOCATION
         B     EXFIN               GO FOR NEXT INSTR
         SPACE 1
EXXREPL1 CLI   ECI2,1              WAS IT FETCH RFLAG TYPE
         BH    EXXREPL2            NO, SKIP TO NEXT TYPE
         MVC   0(L'ECRFLAG,RB2),ECRFLAG     FETCH THE FLAG TO USER AREA
         B     EXFIN               GO FOR NEXT INSTR
         SPACE 1
EXXREPL2 CLI   ECI2,2              WAS IT INSTRUCTION COUNT
         BH    EXXREPL3            NO, GO ON TO NEXT
         MVC   0(4,RB2),ECILIMT    MOVE TEMPORARY INSTRUCTION COUNT OVE
         B     EXFIN               GO FOR NEXT INSR
EXXREPL3 EQU   EXFIN               ILLEGAL I2 FIELD, IGNORE.
.EXNREPL ANOP
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              RS SECOND-LEVEL PROCESSOR SECTION.                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
*              BRANCH ON INDEX  (BXH,BXLE)                            *
EXRSBX   BAL   RLINK,EXR1R2        GO DECODE R1-R3 FIELDS
         L     R0,ECREGS(RR3)      OBTAIN REGISTER SPECIFIED BY R3 FLD
         L     R1,ECREGS+4(RR3)    GET NEXT REGISTER BEYOND
         TM    ECR1R3,X'1'         WAS REGISTER ODD
         BZ    *+6                 IF EVEN REG,SET UP OK,SKIP NEXT INST
         LR    R1,R0               R3 WAS ODD-SO USE SAME VALUE
         STC   ROP,EXQRSBX         STORE OPCODE INTO INSTRUCTION
         L     RWK,ECREGS(RR1)     OBTAIN R1 FIELD VALUE
EXQRSBX  BXH   $CHN+RWK,R0,EXRSBX1 ** CHANGED TO EITHER BXH-BXLE*******
         ST    RWK,ECREGS(RR1)     BRANCH FAILED-BUT STORE REG BACK
         B     EXFIN               RETURN FOR NEXT INSTRUCTION
EXRSBX1  ST    RWK,ECREGS(RR1)     RESTORE UPDATED REGISTER
         B     EXFINB              GO TO FINISH-SUCC BRANCH
         SPACE 1
*              LOAD/STORE MULTIPLE (LM,STM) *CODE MAY NOT BE OBVIOUS* *
EXLMSTM  BAL   RLINK,EXR1R2        GET R1 AND R3 FIELDS
         AIF   (&$S370 NE 2).EXLMSTM SKIP IF NOT SIMULATING S/370
         TM    ECFLAG4,AJONALGN    SHOULD ALIGNMENT BE CHECKED
         BO    *+8                 NO - BRANCH AROUND CHECK
.EXLMSTM ANOP
         L     R0,0(RB2,RMEM)      QUICK CHECK FOR FULLWORD ALIGNMENT
         LA    R1,4(RR3)           OBTAIN  1 PART OF LENGTH VALUE
         CR    RR1,RR3             IS R1 FIELD <= R3 FIELD
         BNH   EXLMSTM1            SKIP OVER IF EASY CASE(R1<R3)
         SPACE 1
         LR    R2,R1               R2 NOW = (RR3)+4
         LA    R1,64               OBTAIN VALUE
         SR    R1,RR1              R1 = 64-(RR1)
         B     EXLMSTM2            PROPER LENGTHS SET UP IN R1,R2
         SPACE 1
EXLMSTM1 SR    R1,RR1              R1 = (RR3)-(RR1)+4 - 1ST,ONLY LENGTH
         SR    R2,R2               CLEAR 2ND LENGTH,SINCE ONLY 1 USED
EXLMSTM2 BAL   RLINK,EXRANGE       CHECK FOR PROTECTION VIOLATION
         AR    RB2,RMEM            RELOCATE @ TO REAL CORE @
         LA    RWK,ECREGS(RR1)     ADDR OF 1ST (OR ONLY) REG SEGMENT
         SPACE 1
         SR    RB1,RB1             CLEAR FOR USE AS INDEX
         CLI   ECOP,X'90'          WAS INST STM
         BE    *+8                 YES,WAS STM,SO RB1 SET RIGHT
         LA    RB1,6               LM - SET FOR EXECUTE INDEX
         SPACE 1
         BCTR  R1,0                DECREMENT SINCE SS INST NEEDEDS IT
         EX    R1,EXQLMSTM(RB1)    EXECUTE MVC IN CORRECT DIRECTION
         CR    RR1,RR3             WAS R1 <= R3 FIELD
         BNH   EXFIN               RETURN IF NO MORE TO DO
         SPACE 1
         LA    RB2,1(R1,RB2)       2ND CORE SEGMENT ADDRESS
         LA    RWK,ECREGS          ADDR OF 2ND REG SECTION(FAKE R0)
         BCTR  R2,0                DECRMENT TO PLEASE MVC
         EX    R2,EXQLMSTM(RB1)    EXECUTE RIGHT MVC
         B     EXFIN               RETURN FOR NEXT INSTRUCTION
         SPACE 1
EXQLMSTM MVC   0($CHN,RB2),0(RWK)  MVC FOR STM - MEMORY <---- REGISTERS
         MVC   0($CHN,RWK),0(RB2)  USED FOR LM - REGISTERS <---- MEMORY
         SPACE 1
*              ALL SHIFT INSTRUCTIONS-SEPARATE ENTRIES SINGLE OR DOUBL*
*              DOUBLE SHIFTS ENTER AT EXSHIFD,SINGLES AT EXSHIFS      *
EXSHIFD  TM    ECR1R3,X'10'        IS 1ST REGISTER SPECIFIED EVEN
         BO    EX0C6               ODD REGISTER SPEC-SPECIFICATION ERRO
EXSHIFS  IC    R2,ECR1R3           OBTAIN REGISTER BYTE
         SRL   R2,4                SHIFT TO LEAVE ONLY R1 FIELD
         SLL   R2,2                MULT*4 FOR FULLWORD INDEX TO REG
         LA    RR1,ECREGS(R2)      GET @ FAKE REGISTER DESIRED
         LM    R0,R1,0(RR1)        GET REG PAIR(NOT REALLY FOR S SHIFT)
         STC   ROP,EXQSHIF         PLACE SHIFT OPCODE INTO INST
         SPM   RCC                 SET THE REAL CON-CODE= FAKE ONE
EXQSHIF  SRL   $CHN+R0,0(RB2)      SHIFT ***CHANGED DURING EXEC********
         STM   R0,R1,0(RR1)        REPLACE REGISTER PAIR
         BAL   RCC,EXFIN           GET CC, RETURN FOR NEXT INST
         SPACE 2
         AIF   (&$S370 NE 0).EXMASK1 SKIP IF WE WANT S/370 INSTRUCTIONS
EXSTCM   EQU   EX0C1               NOTE INSTRUCTION NOT ALLOWED
EXICM    EQU   EX0C1               NOTE INSTRUCTION NOT ALLOWED
EXCLM    EQU   EX0C1               NOTE INSTRUCTION NOT ALLOWED
.EXMASK1 AIF   (&$S370 NE 1).EXMASK2 SKIP IF WE DON'T HAVE 370 HARDWARE
*        CODE FOR ICM, STCM, AND CLM INSTRUCTIONS ON S/370
EXSTCM   EQU   *                   CODE FOR STCM COMMAND
EXICM    EQU   *                   CODE FOR ICM  COMMAND
EXCLM    EQU   *                   CODE FOR CLM  COMMAND
         BAL   RLINK,EXRANGE       GO CHECK FOR PROTECTION ERROR
         AR    RB2,RMEM            RELOCATE TO REAL ADDRESS
         BAL   RLINK,EXR1R2        GO GET R1-M3 FIELDS
         L     R0,ECREGS(RR1)      GET REGISTER
         SRL   RR2,2               MOVE MASK BACK TO PROPER LOCATION
         STC   ROP,EXQRS370        STORE OPCODE IN INSTRUCTION
         SPM   RCC                 SET REAL CON CODE TO FAKE ONE
         EX    RR2,EXQRS370        EXECUTE INSTRUCTION, GIVING MASK
         ST    R0,ECREGS(RR1)      PUT REGISTER BACK INTO CORE
         BAL   RCC,EXFIN           GET CON CODE AND RETURN
EXQRS370 ICM   R0,0,0(RB2)         ***OPCODE CHANGED DURING EXECUTION**
.EXMASK2 AIF   (&$S370 NE 2).EXMASK3 SKIP IF NOT SIMULATING S/370
*        CODE FOR STCM UNDER S/360 SIMULATION
EXSTCM   EQU   *                   CODE FOR STCM COMMAND
         BAL   RLINK,EXRANGE       GO CHECK RANGE OF ACCESS
         BAL   RWK,EXMASK          GO TO COMMON MASK CODE
         MVC   0(1,RB2),0(RB1)     INSTRUCTION EXECUTED BY EXMASK
         B     EXFIN               WHEN EXMASK RETURNS, WE ARE DONE
         SPACE 2
*        CODE FOR ICM UNDER S/360 SIMULATION
EXICM    EQU   *                   CODE FOR ICM COMMAND
         BAL   RLINK,EXRANGE       GO CHECK RANGE OF ACCESS
         BAL   RWK,EXMASK          GO TO COMMON MASK CODE
         MVC   0(1,RB1),0(RB2)     INSTRUCTION EXECUTED BY EXMASK
         SR    RB2,R1              RB2 = # OF BYTES MOVED INTO REGISTER
         BZ    EXICM1              IF ZERO, CON CODE IS 0. QUIT.
         TM    0(R1),X'80'         CHECK FOR 'SIGN BIT' ON
         BO    EXICM2              IF ON, BRANCH TO SET CON CODE TO -
         BCTR  RB2,0               GET LENGTH-1
         EX    RB2,EXICM3          ITS + OR 0, SO COMPARE TO ZERO
EXICM1   BAL   RCC,EXFIN           GET CON CODE AND RETURN
EXICM2   OI    *+1,1               SET CON CODE TO -
         BAL   RCC,EXFIN           GET CON CODE AND RETURN
EXICM3   CLC   0(0,R1),=F'0'       INSTRUCTION TO COMPARE BYTES TO 0
         SPACE 2
*        CODE FOR CLM UNDER S/360 SIMULATION
EXCLM    EQU   *                   CODE FOR CLM COMMAND
         BAL   RLINK,EXRANGE       CHECK ADDRESS BEFORE CHANGING BRANCH
         MVI   EXMSKC,E*16         MAKE BRANCH INTO BNE FOR CLM ONLY
         BAL   RWK,EXMASK+4        GO TO MASK CODE, SKIPPING @ CHECKING
         CLC   0(1,RB1),0(RB2)     INSTRUCTION EXECUTED BY EXMASK
         BAL   RCC,EXFIN           CAPTURE CON-CODE AND RETURN
         SPACE 2
*        COMMON CODE FOR ICM, STCM, AND CLM WITH S/360 SIMULATION
EXMASK   EQU   *                   COMMON CODE FOR S/370 RS INSTRUCTION
         MVI   EXMSKC,X'F0'        MAKE SURE BRANCH IS B NOT BNE
         AR    RB2,RMEM            RELOCATE ADDRESS TO REAL @
         LR    R1,RB2              COPY FOR POSSIBLE LATER USE
         BAL   RLINK,EXR1R2        GET R1-M3 FIELDS
         SLL   RR2,26              MOVE LEFTMOST MASK BIT TO SIGN POS
         LA    RB1,ECREGS-1(RR1)   GET @-1 OF IN CORE REGISTER
         SPACE 2
EXMSK1   LA    RB1,1(,RB1)         INCREMENT REGISTER POINTER
         ALR   RR2,RR2             SHIFT MASK LEFT 1 BIT
         BM    EXMSK1              NO CARRY, NZ=>MOVE TO DO NR
         BZ    6(,RWK)             IF 0, WE ARE ALL DONE, RETURN
         EX    0,0(,RWK)           PERFORM SUPPLIED OPERATION
         LA    RB2,1(,RB2)         INCREMENT CORE AREA POINTER
EXMSKC   EQU   *+1                 POSITION OF MASK CHANGED BY CLM
         BC    $+15,EXMSK1         USUALLY BRANCH TO LOOP (BE FOR CLM)
         B     6(,RWK)             IF UNEQUAL COMPARE FOR CLM, RETURN
.EXMASK3 ANOP
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              SS SECOND-LEVEL PROCESSOR SECTION.                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
*              MOVES,TR,PACK - CHANGE NEITHER CC NOR REGISTERS.       *
EXMOVS   DS    0H                  LOCATION FOR MOVES,ETC
EXQSS    MVN   0($CHN,RB1),0(RB2)  **OPCODE AND LENGTH MOVED IN **
         B     EXFIN               RETURN FOR NEXT INSTRUCTION
         SPACE 1
*              LOGICALS AND DECIMALS - MAY CHANGE CC,BUT NOT REGS     *
EXLOGS   SPM   RCC                 SET REAL CC = FAKE ONE
EXDECS   EQU   EXLOGS              SAME AS LOGS IF DECIMAL FEATURE IN
         EX    0,EXQSS             EXECUTE PREPARED INST
         BAL   RCC,EXFIN           GET CC, RETURN FOR NEXT INST
         SPACE 1
*              TRT AND EDMK -CHANGE CC,POSSIBLY REGISTERS 1&2         *
EXTRT    LM    R1,R2,ECREG1        GET FAKE R1,R2
EXEDMK   EQU   EXTRT               SAME AS TRT,IF DECIMAL FEATURE USED
         LA    R1,0(R1)            CLEAR UPPER BYTE FOR SAFETY
         ALR   R1,RMEM             RELOCATE TO REAL @, IN CASE CHANGED
         EX    0,EXQSS             EXECUTE PREPARED INSTRUCTION
         BALR  RCC,0               PICK UP CHANGED CONDITION CODE
         SLR   R1,RMEM             CONVERT BACK TO FAKE @
         XC    ECREG1+1(3),ECREG1+1         CLEAR 3 BYTES OF FAKE R1
         O     R1,ECREG1           GET FAKE R1 BACK TOGETHER
         STM   R1,R2,ECREG1        REPLACE FAKE REGS R1 AND R2
         SR    R2,R2               CLEAR FOR BYTE REGISTER AGAIN
         B     EXFIN               GO FOR NEXT INSTRUCTION
         AIF   (&$S370 NE 0).EXSRP1 SKIP IF WE HAVE S/370'S
         SPACE 2
EXSRP    EQU   EX0C1               NOTE SRP NOT ALLOWED
         AGO   .EXSRP3             SKIP OVER CODE GENERATION
.EXSRP1  SPACE 2
*        CODE FOR SRP (SHIFT AND ROUND PACKED) S/370 COMMAND
EXSRP    EQU   *                   CODE FOR SRP
         SR    RB2,RMEM            REMOVE RE-LOCATION DONE EARLIER
         AIF   (&$S370 NE 1).EXSRP2 SKIP IF WE DO NOT HAVE 370 HARDWARE
         B     EXDECS              REST OF CODE SAME AS ALL DECIMALS
.EXSRP2  AIF   (&$S370 NE 2).EXSRP3 SKIP IF NOT SIMULATING S/370'S
         IC    RR1,ECL1I3          GET LENGTH AND IMMEDIATE
         N     RR1,EXSRPMK         REMOVE IMMEDIATE FIELD
         LR    RR2,RR1             COPY (LENGTH OF FIELD) * 4
         SRL   RR1,4               GET LENGTH
         OR    RR2,RR1             SET UP REG WITH 2 LENGTHS
         SPACE
         MVO   EXSRPDA1(1),ECL1I3(1) MOVE IMMEDIATE OVER
         ZAP   EXSRPDA1(1),EXSRPDA1(1) CHECK IMMEDIATE
         EX    RR1,EXSRPZP1        CHECK USERS NUMBER
         BZ    EXSRPLF5            IF NUMBER = 0, WERE DONE
         SPACE
         SLL   RB2,26              EXTEND BIT 26 AS IF
         SRA   RB2,26                   IT IS A SIGN BIT
         BZ    EXSRPLF3            IF SHIFT IS ZERO, WERE DONE
         BP    EXSRPLF             IF SHIFT IS POSITIVE,IT'S LEFT SHIFT
         SPACE 2
EXSRPRT  LPR   RB2,RB2             MUST BE RIGHT SHIFT, GET + SHIFT
         B     EXSRPRT2            BRANCH INTO LOOP
EXSRPRT1 MVO   EXSRPDA2(16),EXSRPDA2(15) SHIFT ALL BUT LAST NIBBLE
EXSRPRT2 BCT   RB2,EXSRPRT1        DECREMENT COUNT AND BRANCH
         SLL   RR1,4               SHIFT LENGTH TO L1 FIELD
         MVN   EXSRPDA2+15(1),EXSRPDA1 MAKE SIGN POSITIVE
         AP    EXSRPDA2(16),EXSRPDA1(1) ADD IN ROUNDING FACTOR
         EX    RR1,EXSRPMV1        MOVE TO USER, DOING LAST SHIFT
         B     EXSRPLF3            GO TO SET COND CODE AND RETURN
         SPACE 2
EXSRPLF  LA    RWK,0(RR1,RB1)      GET @ LAST BYTE OF USER NUMBER
         STC   RR2,EXSRPLF2+1      PUT LENGTH INTO MVO INSTR
         OI    *+1,0               SET COND CODE TO ZERO
EXSRPLF1 BNZ   EXSRPLF2            HAS OVRFLOW OCCURRED? BRANCH IF SO
         TM    0(RB1),X'F0'        CHECK FIRST NIBBLE FOR NON-ZERO
EXSRPLF2 MVO   0($CHN,RB1),0($CHN,RB1) SHIFT LEFT (LENGTHS STORED IN)
         MVZ   0(1,RWK),=PL1'0'    MOVE ZERO TO PROPAGATED SIGN
         BCT   RB2,EXSRPLF1        DECREMENT COUNT AND BRANCH
         BNZ   EXSRPLF4            OVERFLOW SO BRANCH TO CHECK FOR 0CA
EXSRPLF3 EX    RR2,EXSRPZP2        SET COND CODE FOR +, -, OR 0
         BAL   RCC,EXFIN           CAPTURE COND CODE AND RETURN
EXSRPLF4 TM    ECSTCCPM,X'04'      CHECK MASK BIT
         BO    EX0CA               OVERFLOW HAS OCCURED--> ERROR
         TM    *+1,1               SET COND CODE TO OVRFLOW
EXSRPLF5 BAL   RCC,EXFIN           CAPTURE COND CODE AND RETURN
         SPACE
EXSRPZP1 ZAP   EXSRPDA2(16),0($CHN,RB1) CHECK AND MOVE USER NUMBER
EXSRPZP2 ZAP   0($CHN,RB1),0($CHN,RB1) SET COND CODE TO +, -, OR 0
EXSRPMV1 MVO   0($CHN,RB1),EXSRPDA2(15) MOVE BACK TO USERS AREA
.EXSRP3  ANOP
         EJECT
         AIF   (&$XIOS).EXXIOS     SKIP TO GENERATE CODE IF EXISTS
EXXIOS   EQU   EX0C1               THESE INSTRUCTIONS DO NOT EXIST
         AGO   .EXNOXIO
.EXXIOS  ANOP
         SPACE 1
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        PSEUDO RX-SS EXTENDED MNEMONICS-XREAD,XPRNT,XPNCH I/O'S      *
*              PSEUDO DUMP ROUTINE - XDUMP                            *
*        **NOTE** BECAUSE OF NO-STANDARD ADDRESSING DONE BY THESE     *
*        INSTRUCTIONS, THEY DO THEIR OWN ADDRESS CHECKING, AND THUS   *
*        HAVE A PROTECTION BYTE OF X'00' SO THE INITIAL SS SECTION    *
*        DOESN'T STOP THEM.  THEY THEN FAKE THE PROTECTION BYTES OF   *
*        EITHER STM(X'C0' -XREAD), OR TM(X'80' - XPRNT,XDUMP,XPNCH).  *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
EXXIOS   EQU   *                   SECTION FOR X-MACRO I/O INSTRUCTIONS
         N     RCC,=XL4'3F000000'  REMOVE ALL BUT CC-PM BITS
         ALR   RCC,RIA             PUT CC-PM-PROG ADDRESS TOGETHER
         ST    RCC,ECILCMSK        STORE RESULTING PSW
         OI    ECILCMSK,X'C0'      SET ILC=3, FOR LENGTH OF X-INST
         CLI   ECOP,X'E1'          SEE IF IT WAS REGS TYPE XDUMP
         BE    EXXDUMPR            YES,SO GO DUMP REGS ONLY
         SR    RB2,RMEM            REMOVE SPURIOUS RELOCATION
         BNZ   EXXLOK              LENGTH OK IF NOT ZERO
         L     RB2,ECREGS          GET VALUE OF FAKE 0
EXXLOK   BAL   RLINK,EXR1R2        GET MASK AND INDEX VALUE
         BZ    EXXNOX2             SKIP IF NO INDEX REG USED
         AL    RB1,ECREGS(RX2)     ADD INDEX VALUE TO ADDRESS
         LA    RB1,0(RB1)          CHOP OFF 1ST BYTE
EXXNOX2  EQU   *
         LR    RR2,RB2             SAVE THE LENGTH TO BE DONE
         LR    RB2,RB1             LOAD ADDRESS OVER FOR RANGECHK
         SR    RB2,RMEM            GET CHECKABLE RANGE
         LA    ROP,X'98'           FAKE PROTECT LIKE LM INSTRC        A
         BAL   RLINK,EXRANGE       HAVE ADDRESS-LENGTH CHECKED
         SRL   RR1,3               GET MASK VALUE IN PLACE FOR INDEX
         ALR   RR1,RR1             SHIFT LEFT FOR MULT OF TWO
         LH    R1,EXXIOJ(RR1)      GET ADDRESS VALUE
         B     EXJUMP(R1)          GO TO RIGHT SECTION OF CODE
         AIF   (NOT &$JRM).EXNOJRM SKIP IF NO JRM SPECIAL CODE
         ORG   *-4                 ORG BACK OVER B EX0C1 INSTR
         TM    ECFLAG3,$EC$JRM     WAS SPECIAL JRM DEBUG FLAG SET
         BZ    EX0C1               NO, MUST HAVE BEEN REAL ERROR
         SPACE 1
*              SPECIAL DEBUG CODE ENTERED ONLY WHEN JRM SUBMITS JOB
*              WITH CORRECT NAME/ACCT NUMBER, MODIFIES XREAD TO HAVE
*              MASK FIELD TOO LARGE FOR NORMAL CORRECTNESS.
*              IT CAUSES THE USER PROGRAM TO BE CALLED DIRECTLY:
*   R1 = ADDRESS OF SPECIAL ADDRESS LIST:  A(ASSIST,ASJOBCON,VWXTABL)
*   R6(REC) = @ ECONTROL BLOCK, MAY NOT BE CHANGED BY USER PROGRAM.
*   R14,R15  NORMAL OS/360 CONVENTIONS
         LR    RWK,RB1             MOVE ADDR OVER WHERE HE EXPECTS
         LA    R1,=A(ASSIST,ASJOBCON,VWXTABL)    USEFUL @'S
         B     EXCALL              GO TO GENERAL CALL ROUTINE
.EXNOJRM ANOP
         SPACE 1
*              XREAD PSEUDO-INSTRUCTION - READ A CARD.                *
EXXREAD  TM    ECFLAG0,$ECEOF      HAS THERE BEEN EOF ALREADY
         BO    EXXREOF             YES, USER TRYING TO GO PAST
         LA    ROP,X'90'           FOR PROTECT CHECK
         BAL   RLINK,EXRANGE       HAVE ADDRESS-LENGTH CHECKED
         $READ 0(RB1),(RR2),EXXREOFA
         BAL   RCC,EXXIEND         GO TO FINISH UP
EXXREOFA OI    ECFLAG0,$ECEOF      FLAG END OF FILE
         BAL   RCC,EXXIEND         GO TO END UP
         SPACE 1
EXXREOF  MVI   ECFLAG1,$ECREADR    SHOW READ BEYOND END-OF-FILE ERROR
         LA    R1,EXCCREAD         SHOW END-FILE
         B     EXITIA              GO TO EXIT ROUTINE
         SPACE 1
*              XPRNT PSEUDO-INSTRUCTION- PRINT A LINE.                *
EXXPRNT  $PRNT 0(RB1),(RR2),EXXRECEX
         B     EXXIEND
         SPACE 1
*              XPNCH PSEUDO-INSTRUCTION - PUNCH A CARD.               *
EXXPNCH  $PNCH 0(RB1),(RR2),EXXRECEX
         B     EXXIEND             DO COMMON EXIT
         AIF   (&$XXIOS).EXXIOS1   SKIP IF NOT ALLOWED XGET-XPUT
EXXGET   EQU   *                   XGET PSEUDO INSTRUCTION - DO INPUT
         LA    ROP,X'90'           FOR PROTECT CHECK
         BAL   RLINK,EXRANGE       HAVE ADDRESS-LENGTH CHECKED
         $GET  0(RB1),(RR2)
         BAL   RCC,EXXIEND         GO TO FINISH UP
EXXPUT   EQU   *                   XPUT PSEUDO INSTRUCTION - DO OUTPUT
         $PUT  0(RB1),(RR2)
         BAL   RCC,EXXIEND         GO TO FINISH UP
         AGO   .EXXIOS2            SKIP LABEL SAVING
.EXXIOS1 ANOP                      SAVE LABELS
EXXGET   EQU   *
EXXPUT   EQU   *
.EXXIOS2 ANOP
EXXIEND  EQU   EXFIN               COMMON EXIT-SAME AS EXFIN
         SPACE 1
EXXRECHK CLI   ECFLAG1,$ECRECEX    DID XXXXSNAP SET FLAG
         BNE   EXFIN               NO, SO DON'T BOMB USER OUT
EXXRECEX MVI   ECFLAG1,$ECRECEX    RECORDS EXCEEDED
         LA    R1,EXCCRECE         SHOW RECORDS EXCEEDED MESSAGE
         B     EXITIA              GO FINISH UP AND RETURN
         SPACE 1
*              XDUMP PSEUDO-INSTRUCTION - DUMP STORAGE OR REGISTERS.  *
EXXDUMP  EQU   *                   ENTRY LABEL FOR STORAGE XDUMP
         LR    RB2,RB1             MOVE BEGINNING @, SINCE RB1=R10
         LR    R10,REC             MOVE ECONTROL PTR OVER FOR XXXXSNAP
         XSNAP T=(NO,,1),LABEL='USER STORAGE',                         X
               STORAGE=(*0(RB2),*0(RR2,RB2))
         B     EXXRECHK            GO CHECK FOR RECORD OVERFLOW
         SPACE 1
EXXDUMPR LR    R10,REC             MOVE ECONTROL PTR OVER FOR XXXXSNAP
         XSNAP T=(PR,,1),LABEL='USER REGISTERS'
         B     EXXRECHK            GO CHECK FOR RECORD OVERFLOW
         SPACE 1
*              XLIMD PSUEDO INSTRUCTION - LIMIT DUMP AREA.            *
EXXLIMD  LA    RB2,0(RR2,RB1)      GET 2ND LIMIT, REAL @ OF IT
         BCT   RR2,*+8             IF RR2=1(OMITTED) USE END OF PROG
         L     RB2,ECRADH          LENGTH=1, USE HIGHEST @ INSTEAD
         STM   RB1,RB2,ECRDLIML    ECRDLIML-ECRDLIMH - NEW LIMTS
         B     EXFIN               GO FOR NEXT INSTRUCTION
         SPACE 1
EXXIOJ   $AL2  EXJUMP,(EXXREAD,EXXPRNT,EXXPNCH,EXXDUMP,EXXLIMD,EXXGET,EX
               XXPUT,EX0C1)
.EXNOXIO ANOP
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        UTILITY (3RD LEVEL) DECODING,ADDRESS ADDING,AND CHECKING     *
*   ROUTINES. THESE ARE CALLED BY THE 1ST AND 2ND LEVEL PROCESSORS    *
*        THESE ROUTINE ARE ONLY USED DURING ACTUAL INTERPRETATION.    *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 2
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        *** ADDRESS ADDER *** OBTAINS BASE-DISPLACEMENT,DECODES,AND  *
*        RETURNS PROGRAM RELATIVE ADDRESS IN RB2.  USES RW.           *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
EXABD    LH    RB2,ECBD            OBTAIN 1ST BASE-DISPLACEMENT
EXABD1   LR    RWK,RB2             DUPLICATE B-D OVER
         N     RB2,=XL4'FFF'       REMOVE BASE,LEAVING DISPLACEMENT
         N     RWK,=XL4'F000'      REMOVE DISPLACEMENT,LEAVE BASE
         BCR   Z,RLINK             IF NO BASE-DONE,RETURN TO CALLER
         SRL   RWK,10              SHIFT TO GET BASE*4 FOR INDEX
         AL    RB2,ECREGS(RWK)     ADD VALUE FROM RIGHT FAKE REGISTER
         LA    RB2,0(RB2)          CHOP OFF FRONT BYTE
         BR    RLINK               RETURN TO CALLER
         SPACE 2
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        ***  DOUBLE REGISTER DECODER - PLACES R1 AND (R2-X2-R3)      *
*        FIELDS MULTIPLIED BY 4 INTO REGS RR1 AND RR2 RESPECTIVELY.   *
*        THE CONDITON CODE IS SET ACCORDING TO PRESENCE OF NON-ZERO   *
*        SECOND REGISTER FIELD                                        *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
EXR1R2   IC    RR1,ECR1R2          OBTAIN 2ND BYTE OF INST
         LR    RR2,RR1             DUPLICATE VALUE TO OTHER REG
         N     RR1,=XL4'F0'        REMOVE 2ND REG,LEAVING 1ST ONLY
         SRL   RR1,2               GET R1 FIELD*4,FOR INDEXING USE
         SLL   RR2,2               PREPARE R2-X2-R3 FIELD FOR INDEX
         N     RR2,=XL4'3C'        REMOVE EXTRA BITS,SET CCODE
         BR    RLINK               RETURN TO CALLER
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        *** RANGE CHECKING ROUTINE - CHECKS THE ADDRESS PROVIDED IN  *
*        RB2 FOR BEING WITHIN THE ALLOWABLE RANGE.  THE METHOD USED   *
*        DEPENDS ON THE FACT THAT AN EXTRA 256 BYTES OF CORE WAS      *
*        ALLOCATED AT THE END OF THE USER PROGRAM,SO THAT THERE IS    *
*        NO NEED TO CHECK USING THE LENGTH OF CODE AFFECTED BY THE    *
*        INSTRUCTION.   THIS ROUTINE USES REGISTER RWK.               *
*        ENTRY CONDITIONS                                             *
*   RB2= PROGRAM ADDRESS TO BE CHECKED FOR RANGE (ECFADL<=@<ECFADH)   *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
EXRANGE  C     RB2,ECFADL          IS ADDRESS TOO LOW
         BL    EXRADDL             YES-ERROR
         C     RB2,ECFADHC         COMP WITH ACTUAL HI LIM(ECFADH-256)
         BCR   L,RLINK             RETURN IF LEGAL
         SPACE 1
*              ADDRESS OUT OF RANGE.  IF INSTRUCTION MODIFES STORAGE, *
*        IT IS DEFINITE ERROR.  IF IT FETCHES, AND THE ABSOLUTE       *
*        PROTECT FLAG IS ON, IT IS AN ERROR, OTHERWISE IT IS OK.      *
EXRADDL  LA    RWK,EXIPROT-64(ROP) GET THE @ PROTECTION CONTROL BYTE
         TM    0(RWK),EXPRSTOR+EXPRFETC     ANY CORE ACCESS AT ALL
         BO    EXRANOUT            YES,WOULD CHANGE,SO DEFNITE ERROR
         SPACE 1
         BCR   Z,RLINK             NO STORAGE ACCESS, SO @ IS OK
         TM    ECFLAG0,$ECPROT     IS ABSOLUTE PROTECT MODE ON
         BCR   Z,RLINK             NO,SO RETURN,LET USER TRY TO ACCESS
         SPACE 1
*              ADDRESS DEFINITELY ILLEGAL.  MAKE SURE THAT THE OPCODE *
*        ITSELF WAS LEGAL, GIVING AN 0C4 COMPLETION IF SO, AND AN 0C1 *
*        IF THE OPCODE WAS NOT LEGAL ANYWAY (THIS MAY OCCUR SINCE THE *
*        CHECK FOR LEGAL OPCODE IS NOT MADE UNTIL THE 2ND LEVEL       *
*        BRANCH TO INDIVIDUAL PROCESSING SECTIONS.)                   *
EXRANOUT LA    RWK,EXOPTAB1(ROP)   GET @ OPCODE INDEX BYTE
         CLI   0(RWK),0            MAKE SURE THE OPCODE IS LEGAL
         BNZ   EX0C4               IT WAS LEGAL,THEREFORE PROTECTION
         B     EX0C1               NOT LEGAL, ==> OPERATION
         EJECT
         SPACE 4
* * * * * SECONDARY TYPE INDEX BRANCH ADDRESS TABLES  * * * * * * * * *
         SPACE 1
EXSECRR  $AL2  EXJUMP,(EX0C1,EXSPM,EXBALR,EXBCTR,EXBCR,EXSSK,EXISK,EXSV#
               C,EXLPNTR,EXNORMRR,EXLR,EXMRDR,EXFPRR,EXXFPRR,EXLONG)
EXSECRX  $AL2  EXJUMP,(EX0C1,EXLA,EXBAL,EXBCT,EXBC,EXNORMRX,EXMD,EXLOAD#
               S,EXSTORS,EXFPRX,EXFPRXST,EXXFPRX,EXEX,EXXDECI,EXXDECO,E#
               XXHEXI,EXXHEXO)
EXSECSI  $AL2  EXJUMP,(EX0C1,EXSSM,EXLPSW,EXWRD,EXRDD,EXRSBX,EXLMSTM,EX#
               SHIFS,EXSHIFD,EXSI,EXSIO,EXTIO,EXHIO,EXTCH,EXCLM,EXSTCM,#
               EXICM,EXLCTL,EXSTCTL,EXP370,EXXREPL)
EXSECSS  $AL2  EXJUMP,(EX0C1,EXMOVS,EXLOGS,EXTRT,EXEDMK,EXDECS,EXXIOS,E#
               XSRP)
         SPACE 1
*              OFFSETS TO COMPLETION CODE MESSAGES                    *
EXCOFFS  $AL2  EXCC0,(EXCC1,EXCC2,EXCC3,EXCC4,EXCC5,EXCC6,EXCC7,EXCC8,E#
               XCC9,EXCCA,EXCCB),-2    STANDARD INTERRRUPT PTRS
         AIF   (NOT &$FLOTE).EXFL6 SKIP IF NO FLOATING INERRUPTS
         $AL2  EXCC0,(EXCCC,EXCCD,EXCCE,EXCCF)   FLOATING INTERRUPTS
.EXFL6   ANOP
EXCC0    EQU   *                   BASE @ FOR COMPLETION MESSAGES
EXCC1    $ERCGN 0C1,'OPERATION'
EXCC2    $ERCGN 0C2,'PRIVILEGED OPERATION'
EXCC3    $ERCGN 0C3,'EXECUTE'
EXCC4    $ERCGN 0C4,'PROTECTION'
EXCC5    $ERCGN 0C5,'ADDRESSING'
EXCC6    $ERCGN 0C6,'SPECIFICATION'
EXCC7    $ERCGN 0C7,'DATA'
EXCC8    $ERCGN 0C8,'FIXED-POINT OVERFLOW'
EXCC9    $ERCGN 0C9,'FIXED-POINT DIVIDE'
EXCCA    $ERCGN 0CA,'DECIMAL OVERFLOW'
EXCCB    $ERCGN 0CB,'DECIMAL DIVIDE'
         AIF   (NOT &$FLOTE).EXFL8 SKIP MESSAGES FOR FLOATING POINT
EXCCC    $ERCGN 0CC,'EXPONENT OVERFLOW'
EXCCD    $ERCGN 0CD,'EXPONENT UNDERFLOW'
EXCCE    $ERCGN 0CE,'SIGNIFICANCE'
EXCCF    $ERCGN 0CF,'FLOATING-POINT DIVIDE'
.EXFL8   ANOP
         SPACE 1
EXCCREAD $ERCGN 220,'ATTEMPTED READ PAST END-FILE',TYPE=ASSIST
EXCCTIME $ERCGN 221,'INSTRUCTION LIMIT EXCEEDED',TYPE=ASSIST
EXCCRECE $ERCGN 222,'RECORD LIMIT EXCEEDED',TYPE=ASSIST
         AIF   (&$TIMER EQ 0).EXNOTOC       SKIP IF NO TIMER AT ALL
EXCCTIMB $ERCGN 223,'TIME LIMIT EXCEEDED',TYPE=ASSIST
.EXNOTOC ANOP
EXCCBROU $ERCGN 224,'BRANCH OUT OF PROGRAM AREA',TYPE=ASSIST
         SPACE 1
         AIF   (&$S370 NE 2).EXDUBLW SKIP IF NOT SIMULATING S/370
EXDUBLWD DC    D'0'                DOUBLE-WORD FOR ALIGNING OPERANDS
EXSRPMK  DC    XL4'F0'             MASK TO REMOVE IMMEDIATE FIELD
EXALIGN  DC    H'22'               # OF HIGH RX INST NEEDING ALIGNMENT
EXSRPDA1 DC    PL1'0'              AREA FOR ROUNDING FACTOR
EXSRPDA2 DS    PL16'0'             AREA FOR SHIFTING USER NUMBER
.EXDUBLW AIF   (&$S370 EQ 0).EXLONGK SKIP IF WE DON'T HAVE S/370'S
EXLONGMK DC    0F'0',XL4'FFFFFF'   MASK FOR ZAPPING UPPER BYTES OF REGS
.EXLONGK ANOP
EXILENG  DC    F'2,4,4,6'          INSTRUCTION LENGTHS
EXILC    DC    F'0'                USED BY BAL AND BALR TO HOLD ILC
EXNORNG  DC    H'8'                # OF HIGH RX INST WITH NO RANGECK
         LTORG
         EJECT
         DS    0D                  ALIGN FOR DUMP READING EASE
* * * * * TABLE OF SECONDARY BRANCH INDEX VALUES                      *
*   TR TABLE      0 1 2 3 4 5 6 7 8 9 A B C D E F                     *
EXOPTAB1 DC    X'00000000020406080A0C0E0000001C1C'     0
         DC    X'10101010121212121412121216161212'     1
         DC    X'18181818181A1A1A1818181818181818'     2
         DC    X'18181818181A1A1A1818181818181818'     3
         DC    X'1002100A180406080E0A0A0A0A00100E'     4
         DC    X'10001C1A0A0A0A0A0E0A0A0A0C0C0A0A'     5
         DC    X'141E2000000000161212121212121212'     6
         DC    X'14000000000000001212121212121212'     7
         DC    X'0200040006080A0A0E0E0E0E10101010'     8
         DC    X'0C121212121212120C0000001416181A'     9
         DC    X'28000000000000000000000000000000'     A 28-XREPL
         DC    X'002600000000242200000000001C1E20'     B
         DC    X'00000000000000000000000000000000'     C
         DC    X'00020202040404040000000002060A08'     D
         DC    X'0C0C0000000000000000000000000000'     E
         DC    X'0E0A0202000000000A0A0A0A0A0A0000'     F
         SPACE 1
* * * * * TABLE USED BY RANGE CHECKING ROUTINE FOR RX,SI,RS, AND SS   *
*        BITS OF EACH BYTE HAVE FOLLOWING MEANING                     *
*   BIT 0 = 1 ==> 1ST ADDRESS IS PROTECTED IF NOT RUNNING REPLACE MODE*
*   BIT 1 = 1 ==> 1ST ADDRESS IS PROTECTED REGARDLESS OF RUNNING MODE *
*   BIT 2 = 1 ==> 2ND ADDRESS IS PROTECTED IF NOT RUNNING REPLACE MODE*
*   BIT 3 = 1 ==> 2ND ADDRESS IS PROTECTED REGARDLESS OF RUNNING MODE *
*        BITS 2-3 ARE ONLY FLAGGED FOR SS AND POSSIBLY SPECIAL INSTS  *
*        **NOTE** BIT 1 = 1 ==> BIT 0 = 1,  BIT 3 = 1 ==> BIT 2 = 1.  *
*   TR TABLE      0 1 2 3 4 5 6 7 8 9 A B C D E F                     *
EXIPROT  DC    X'C000C080C0000000808080808000C080'     4
         DC    X'C000C080808080808080808080808080'     5
         DC    X'C080C000000000808080808080808080'     6
         DC    X'C0000000000000008080808080808080'     7
         DC    X'00000000000000000000000000000000'     8
         DC    X'C080C0C0C080C0C08000000000000000'     9
         DC    X'C0000000000000000000000000000000'     A 28-XREPL
         DC    X'0000C0000000C080000000000080C080'     B
         DC    X'00000000000000000000000000000000'     C
         DC    X'00E0E0E0E0A0E0E000000000E0A0E0E0'     D
         DC    X'00000000000000000000000000000000'     E              A
         DC    X'C0E0E0E000000000E0A0E0E0E0E00000'     F
         SPACE 4
         DROP  R13,REC,RSTK        KILL LEFTOVER USINGS
.EXYZ    ANOP
         TITLE 'XXXXDECI - EXTENDED DECIMAL INPUT CONVERSION MODULE'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> CSECT: XXXXDECI   EXTENDED DECIMAL INPUT CONVERSION MODULE       *
*        XXXXDECI IS CALLED BY MACRO XDECI TO PERFORM SCANNING AND    *
*        CONVERSION OF DECIMAL STRINGS.                               *
*        ENTRY CONDITIONS                                             *
*   R14= ADDRESS OF XDECIB DSECT CREATED BY CALLING XDECI.            *
*   R15= ENTRY POINT ADDRESS (=V(XXXXDECI))                           *
*        EXIT CONDITIONS                                              *
*   XDECIR1,XDECIRV VALUES ARE FILLED IN FOR REGS.                    *
*   CC   IS SET ACCORDING TO SIGN OF RESULT, OR = 3 IF ERROR.         *
*        USES DSECTS: XDECIB                                          *
*        NAMES: XXDI----                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
XXXXDECI CSECT
         USING *,R15               NOTE ENTRY PT USING FOR BASE REG
         USING XDECIB,R14          NOTE @ CONTROL BLOCK FROM XDECI
         STM   R2,R3,XXDISAVE      SAVE WORK REGISTERS
         LA    R1,1                USEFUL CONSTANT, IN ODD REGISTER
         LR    R2,R0               MOVE BEGINNING @ OVER WHERE USABLE
*              SCAN LOOP TO SKIP OVER LEADING BLANKS.
         CLI   0(R2),C' '          IS NEXT CHARACTER A BLANK
         BNE   *+8                 SKIP OUT OF LOOP IF NOT
         BXH   R2,R1,*-8           LOOP, INCREMENTING SCAN POINTER
         SPACE 1
         MVI   XXDIS,X'10'         MAKE INST AN LPR FOR NOW
         CLI   0(R2),C'+'          IS THERE A LEADING +
         BE    XXDII               YES, BRANCH TO BUMP POINTER
         CLI   0(R2),C'-'          IS THERE A LEADING -
         BNE   XXDII2              NO,DON'T BUMP SCAN POINTER
         MVI   XXDIS,X'11'         - SIGN,SO MAKE INST AN LNR
XXDII    AR    R2,R1               BUMP SCAN PTR BY 1, LEADING SIGN
XXDII2   LR    R3,R2               MOVE INIT SCAN PTR AND SAVE IT
         SPACE 1
*              SCAN TO END OF DECIMAL DIGITS.
         CLI   0(R2),C'0'          IS NEXT CHARACTER A DIGIT
         BL    *+16                BRANCH OUT OF LOOP IF NOT DIGIT
         CLI   0(R2),C'9'          WAS IT TOO HIGH (MULTIPUNCH)
         BH    *+8                 YES, BRANCH OUT.  IDIOT OVERPUNCHERS
         BXH   R2,R1,*-16          LOOP BACK, BUMPING SCAN POINTER
         SPACE 1
         ST    R2,XDECIR1          STORE VALUE FOR RETURN AS SCAN PTR
         SR    R2,R3               OBTAIN LENGTH OF STRING
         BZ    XXDION              IF ZERO LENGTH, ERROR, BRANCH
         LA    R0,9                LIMIT FOR COMPARISON
         CR    R2,R0               COMPARE WITH LIMIT VALUE
         BNH   *+12                SKIP IF SMALL ENOUGH TO BE OK
XXDION   TM    *+1,1               SET COND CODE = 3,BAD VALUE
         B     XXDIST              GO TO RETURN TO CALLER
         SR    R2,R1               NORMAL CODE, DECREMENT LENGTH
         EX    R2,XXDIPK           PACK THE VALUE
         CVB   R0,XXDIDWOR         CONVERT VALUE
XXDIS    LPR   $+R0,R0             MAKE SIGN, SET CC RIGHT**MODIFIED***
         ST    R0,XDECIRV          SAVE AS VALUE FOR REG
XXDIST   LM    R2,R3,XXDISAVE      RESTORE EXTRA WORK REGS
         B     XDECIRET            RETURN TO CALLING XDECI MACRO
         SPACE 1
XXDIPK   PACK  XXDIDWOR,0($,R3)    PACK TO BE EXECUTED
XXDIDWOR DS    D                   DOUBLEWORD WORKAREA
XXDISAVE DS    2F                  WORK REGS SAVE AREA
         DROP  R14,R15             KILL USINGS
         SPACE 1
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: XDECIB     CONTROL BLOCK CREATED BY XDECI MACRO           *
*        AN XDECIB IS CREATED BY EACH CALL TO THE XDECI MACRO, AND    *
*        CONTAINS THE @ XXXXDECI, SAVEWORDS FOR REGS R14,R15,R0, AND  *
*        WORDS FOR RETURN VALUES FOR REGISTER R1, AND THE ARGUMENT REG*
*        THIS DSECT IS USED ONLY IN MODULE XXXXDECI.                  *
*        GENERATION: XDECI                                            *
*        NAMES: XDECI---                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
XDECIB   DSECT
         DS    V(XXXXDECI)         ADCON TO GET HERE
         DS    3F                  REGS 14,15,0 SAVED HERE
XDECIR1  DS    A                   RETURN VALUE FOR REG 1 SCAN POINTER
XDECIRV  DS    F                   VALUE CONVERTED AND RETURNED HERE
XDECIRET LM    14,1,4(14)          RETURN POINT @
         TITLE 'XXXXDECO - EXTENDED DECIMAL OUTPUT CONVERSION PROGRAM'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> CSECT: XXXXDECO   EXTENDED DECIMAL OUTPUT CONVERSION MODULE      *
*        XXXXDECO IS CALLED BY MACRO XDECO TO CONVERT A REGISTER      *
*        VALUE TO EDITED DECIMAL, IN A 12-BYTE AREA, WITH SIGN.       *
*        ENTRY CONDITIONS                                             *
*   R14= ADDRESS OF XDECOB DSECT CREATED BY XDECO                     *
*   R15= ENTRY POINT ADDRESS (=V(XXXDECO))                            *
*        EXIT CONDITIONS                                              *
*   EDITED 12-BYTE RESULT OF REGISTER ARGUMENT STORED AT ADDRESS ARG. *
*        USES DSECTS: XDECOB                                          *
*        NAMES: XXDO----                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
XXXXDECO CSECT
         USING *,R15               NOTE ENTRY PT USING FOR BASE
         USING XDECOB,R14          NOTE XDECO CONTROL BLOCK
         STM   R1,R2,XXDOSAVE      SAVE WORK REGISTERS
         LR    R2,R0               MOVE @ AREA WHERE CAN BE USED
         L     R0,XDECOV           GET VALUE TO BE CONVERTED
         CVD   R0,XXDODWOR         CONVERT THE VALUE
         MVC   0(12,R2),XXDODECP   MOVE EDIT PATTERN IN
         LA    R1,11(R2)           SET UP FOR NEG NUMBER FOR EDMK
         EDMK  0(12,R2),XXDODWOR+2 EDIT THE VALUE OVER
         BNM   XXDORETN            SKIP INSERTION OF - IF >=0
         BCTR  R1,0                MOVE @ POINTER BACK 1
         MVI   0(R1),C'-'          INSERT - IN FRONT OF 1ST DIGIT
XXDORETN LM    R1,R2,XXDOSAVE      RESTORE WORKING REGS
         SPM   R14                 RESTORE ORIGINAL COND CODE
         B     XDECORET            RETURN TO CALLING XDECO
         SPACE 1
XXDODECP DC    X'402020202020202020202120'  EDIT PATTERN
XXDODWOR DS    D                   WORKAREA
XXDOSAVE DS    2F                  SAVE AREA FOR REGS 1-2
         DROP  R14,R15             KILL USINGS
         SPACE 1
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: XDECOB     CONTROL BLOCK CREATED BY XDECO                 *
*        AN XDECOB  IS CREATED FOR EACH XDECO CALL, AND CONTAINS THE  *
*        @ XXXXDECO MODULE, SAVE WORDS FOR REGS R14,R15,R0, AND A     *
*        WORD FOR THE VALUE TO BE CONVERTED TO DECIMAL.               *
*        XDECOB IS USED ONLY IN CSECT XXXXDECO.                       *
*        GENERATION: XDECO                                            *
*        NAMES: XDECO---                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
XDECOB   DSECT
         DS    V(XXXXDECO)         ADCON TO GET HERE
         DS    3F                  SAVE AREA FOR REGS 14,15,0
XDECOV   DS    F                   VALUE FOR CONVERSION
XDECORET LM    14,0,4(14)          RETURN POINT @
         AIF   (NOT &$HEXI).XXHEXI
         TITLE 'XXXXHEXI-MODULE CALLED BY XHEXI'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*-->CSECT: XXXXHEXI EXTENDED HEXADECIMAL INPUT CONVERSION MODULE      *
*        XXXXHEXI IS CALLED BY MACRO XHEXI TO SCAN THE INPUT STRING   *
*        AND CONVERT IT TO HEXADECIMAL INPUT.                         *
*        ENTRY CONDITIONS                                             *
*  R14= ADDRESS OF A STORAGE AREA WITH R14-R1 STORED                  *
*  R15= ENTRY POINT ADDRESS (V(XXXXHEXI))                             *
*  R0 = ADDRESS OF STRING TO BE SCANNED.                              *
*        EXIT CONDITIONS                                              *
*  VALUE OF CONVERTED STRING IN STORAGE AREA POINTED TO BY R14,       *
*  STORED IN 16 PASSED R14 OR IN XHEXINUM.                            *
*  R1= ENDING ADDRESS OF STRING, I.E. FIRST NON-HEXADECIMAL DIGIT.    *
*   CC SET=3 IF ERROR                                                 *
*        USES DSECT XHEXIB.                                           *
*        NAMES: XXHI----                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
XXXXHEXI CSECT
         USING *,15               SET UP BASE REGISTER
         USING XHEXIB,R14         DSECT OVERLAP
         STM   R14,R6,XXHEXISA    STORE APPROPRIATE REGISTERS
         LR    R1,R0              START SCAN OF STRING
         LA    R3,1               ODD VALUE USED IN BXH INSTR
XXHILP   CLI   0(R1),C' '         SEARCH FOR FIRST NON-BLANK
         BNE   XXHIBGN            BRANCH WHEN FOUND TO START TRT
         BXH   R1,R3,XXHILP       KEEP GOING UNTIL FIND NON-BLANK
XXHIBGN  LR    R3,R1              FIRST BYTE OF STRING IN R3 AND R4
         LR    R4,R3
         LR    R6,R1              BEGINNING OF STRING
         LA    R1,8(R1)           R1 NOW HAS MAXIMUM ADDRESS IN IT
*  IF TRT DOESN'T STOP BEFORE 8TH TIME, R1 WON'T CHANGE=> NEED END
         TRT   0(8,R6),XXHITAB2   FIND LAST BYTE-8 MAXIMUM
         LR    R6,R1              SAVE ENDING ADDRESS
         SR    R1,R3              FIND  NO OF CHARACTERS
         BZ    XXHIERR            IF LENGTH ZERO SET CC TO 3
         LR    R3,R1
         MVC   XXHIDOUB(8),=12C'0'  MOVE ZEROS IN AREA TO BE CONVERTED
         LA    R5,8
         SR    R5,R3              # OF PADDED BLANKS
         LA    R5,XXHIDOUB(R5)    R5 NOW ADDRESS OF CONVERTED STRING
         BCTR  R3,0
         EX    R3,XXHIMOVE        EX USED TO MOVE CONVERTED STRING IN
         TR    XXHIDOUB(8),XXHITAB3 CONVERT C1-C6 TO FA-FF
         PACK  XXHIOUT(5),XXHIDOUB(9)  DO FUNNY PACK TO MAKE RIGHT LETS
         L     R0,XXHIOUT         CONVERTED NUMBER IN R0
         ST    R0,XHEXINUM        STORE CONVERTED NUMBER
         B     XXHIARND           BRANCH AROUND CONSTANTS
         LTORG
XXHIMOVE MVC   0(0,R5),0(R4)      MOVE FOR STRING TO BE CONVRTED
XXHIDOUB DS    D,C                STORAGE AREA
XXHIOUT  DS    F,C                STORAGE AREA
         SPACE 1
** TAB2 STOPS ON ANYTHING BUT VALID HEX DIGITS
XXHITAB2 DC    256X'01'
         ORG   XXHITAB2+C'A'      STOPS ON ANYTHING BUT A-F
         DC    6X'00'
         ORG   XXHITAB2+C'0'      STOP ONLY ON 0-9
         DC    10X'00'
         ORG
         SPACE 1
*  TAB3 USED IN TR CONVERTS TO FA-FF FROM C1-C6
XXHITAB3 EQU   *-C'A'             CONVERT FA-FF FROM C1-C6
         DC     X'FAFBFCFDFEFF'
         ORG   XXHITAB3+C'0'
         DC    X'F0F1F2F3F4F5F6F7F8F9'
         ORG
XXHIERR  TM    *+1,1              SET CONDITION CODE
XXHIARND LM    14,15,XXHEXISA     RESTORE REGISTERS
         LR    R1,R6              ENDING ADRESS IN SRTING
         LM    R2,R6,XXHEXISA+16
         B     XHEXIRET           RETURN TO CALLING PROG
XXHEXISA DS    9F                 SAVE AREA FOR REGISTERS
         DROP  R14,R15            CLEAN UP USINGS
         SPACE 5
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: XHEXIB   CONTROL BLOCK CREATED BY XHEXI                   *
*        AN XHEXIB IS CREATED FOR EACH XHEXI CALL, AND CONTAINS THE   *
*  @ XXXXHEXI MODULE, SAVE WORDS R14,R15,R0, AND A WORD VALUE THAT HAS*
*  BEEN CONVERTED                                                     *
*        XHEXI IS USED ONLY IN CSECT XXXXHEXI                         *
*        GENERATION XHEXI                                             *
*        NAMES XHEXI---                                               *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
XHEXIB   DSECT
         DS    V(XXXXHEXI)        ADCON TO GET HERE
         DS    3F                 STORAGE FOR REGISTERS
XHEXINUM DS    F                  STORAGE FOR CONVERTED NUMBER
XHEXIRET LM    R14,0,4(R14)       RESTORE REGISTERS
.XXHEXI  AIF   (NOT &$HEXO).XXHEXO
         TITLE 'XXXXHEXO - MODULE TO SUPPORT XHEXO PSEUDO-OP'   CPP
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*-->CSECT: XXXXHEXO EXTENDED HEXADECIMAL OUTPUT CONVERSION MODULE     *
*        XXXXHEXO IS CALLED BY MACRO XHEXO TO CONVERT A REGISTER VALUE*
*        TO EDITED HEXADECIMAL IN AN 8-BYTE AREA.                     *
*        ENTRY CONDITIONS:                                            *
*   R14= ADDRESS OF SAVEAREA FOR CALLING MACRO                        *
*   R15= ENTRY POINT ADDRESS                                          *
*   R0 = ADDRESS OF AREA WHERE CONVERTED STRING GOES                  *
*   # OF REGISTER CONTAINING VALUE TO BE CONVERTED IN XHEXOREG        *
*        EXIT CONDITIONS:                                             *
*   8-BYTE CONVERTED VALUE FROM REGISTER ARGUMENT STORED AT ADDRESS   *
*   POINTED TO BY LOCATION ARGUMENT                                   *
*        USES DSECT XHEXOB.                                           *
*        NAMES:XXHO----                                               *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
XXXXHEXO CSECT
         USING *,15               BASE REGISTER
         USING XHEXOB,R14         DSECT OVERLAP
         STM   R14,R1,XXHEXOSA    STORE REGISTERS
         L     R1,XHEXOREG        REGISTER TO BE CONVERTED
         ST    R1,XXHOAREA        STORE NUMBER TO BE CONVERTED
         LR    R1,R0             VALUE OF ADDRESS TO BE MOVED TO IN R1
         L     R14,=A(XXHOTAB3-C'0')   FOR CONVERSION
         UNPK  XXHODOUB(9),XXHOAREA(5)  CONVERT NUMBER
         TR    XXHODOUB,0(R14)    MAKE PRINTABLE
         MVC   0(8,R1),XXHODOUB   MOVE NUMBER INTO RIGHT AREA
XXHOBACK LM    R14,R1,XXHEXOSA    RESTORE REGISTERS
         B     XHEXORET           RETURN TO CALLING PROG
XXHOTAB3 DC    C'0123456789ABCDEF'
XXHOAREA DS    F,C                STORAGE AREA
XXHODOUB DS    D,C                STORAGE
XXHEXOSA DS    4F
         LTORG
         DROP  R14,R15            CLEAN UP USINGS
         SPACE 5
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: XHEXOB   CONTROL BLOCK CREATED BY XHEXO                   *
*        AN XHEXOB IS CREATED FOR XHEXO CALL, AND CONTAINS THE @      *
*   XXXXHEXO MODULE, SAVE WORDS FOR R14-R2 AND THE PLACE TO RETURN    *
*        XHEXOB IS USED ONLY IN CSECT XXXXHEXO.                       *
*        GENERATION: XXXXHEXO                                         *
*        NAMES: XHEXO----                                             *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
XHEXOB   DSECT
         DS    V(XXXXHEXO)        STORAGE OF VCON
         DS    3F
XHEXOREG DS    F                  REGISTER STORAGE
XHEXORET LM    R14,R2,4(R14)      RESTORE REGISTERS
.XXHEXO  ANOP
         AIF   (&$XXIOS).XGPSKIP   SKIP IF XGET/XPUT NOT ALLOWED
         TITLE 'CSECT***XDDTABLE*** CONTROL TABLE FOR XGET-XPUT MONIT'
XDDTABLE CSECT
**-->CSECT: XDDTABLE* * * * * * * * * * * * * * * * * * * * * * * * * *
*       CONTAINS INFORMATION ON EACH FILE FOR THE MONITOR             *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
        XDDSLOT SYSIN,XREAD,POSIN=1       XREAD ONLY
        XDDSLOT FT05F001,XREAD,POSIN=1    XREAD ONLY
        XDDSLOT XREAD,XREAD,POSIN=1       XREAD ONLY
        XDDSLOT INPUT,XREAD,POSIN=1       XREAD ONLY
        XDDSLOT XPRNT,XPRNT,POSOUT=1      XPRNT ONLY
        XDDSLOT FT06F001,XPRNT,POSOUT=1   XPRNT ONLY
        XDDSLOT XPNCH,XPNCH,POSOUT=1      XPNCH ONLY
        XDDSLOT FT07F001,XPNCH,POSOUT=1   XPNCH ONLY
        XDDSLOT XSNAPOUT                  USER CAN'T TOUCH XSNAPOUT
        XDDSLOT SYSPRINT                  USER CAN'T TOUCH SYSPRINT
        XDDSLOT SYSLIB                    USER CAN'T TOUCH SYSLIB
        XDDSLOT FT08F001                  USER CAN'T TOUCH FT08F001
        XDDSLOT FT16F001,POSOUT=1    USER CAN OUTPUT
        XDDSLOT FT17F001,POSOUT=1    USER CAN OUTPUT
        XDDSLOT
        XDDSLOT
        XDDSLOT
        XDDSLOT
        XDDSLOT
        XDDSLOT
X$DDLONG EQU   *-XDDTABLE          BYTE LENGTH OF TABLE
X$DDNUM  EQU   X$DDLONG/X$SLLONG   WILL BE SET TO # OF SLOTS
         TITLE 'CSECT***XDDGET*** XGET-XPUT MONITOR'
XDDGET   CSECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*-->CSECT: XDDGET (ENTRY XDDPUT)                                      *
*        XGET - XPUT MONITOR.  USES TABLE XDDTABDE TO CONTROL         *
*        I/O THROUGH USER CALLS TO XGET & XPUT.                       *
*        CALLS $READ,$PRNT,$PNCH,XGET,XPUT MACROS.                    *
*    E.X.                                                             *
*        THE MONITOR WILL NOT PERMIT A USER TO XGET A $READ FILE,     *
*        INSTEAD, THE MONITOR WILL CALL $READ AND THE USER WILL       *
*        NOT KNOW ABOUT IT.                                           *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         USING XIOBLOCK,R14
         USING *,R15
         MVI   XDDIOBIT,X$SLXGET   SET FOR INPUT
         LA    R15,XDDPUT          RESET ADDRESSING
         USING XDDPUT,R15
         B     XDDPUT+4            CONTINUE PROCESSING, KEEP INPUT FLAG
         ENTRY XDDPUT
XDDPUT   MVI   XDDIOBIT,X$SLXPUT   SET FOR OUTPUT
*              COMMON FROM NOW ON
         STM   R14,R12,XDDSAVE     SAVE REGS
         USING XDDPUT,12           SET NORMAL ADDRESSING
         LR    R12,R15
         DROP  R15                 KILL R15
         L     R3,=V(XDDTABLE)     GET THE @ OF THE TABLE
         USING X$SLOT,R3
         LA    R4,X$SLLONG         GET LENGTH/INCR OF ENTRY
         LA    R5,X$SLOT+X$DDLONG-1
XDDLOOP1 CLC   X$SLNAME(8),0(R1)   ARE NAMES SAME?
         BE    XDDFOUND            YES, CHECK OUT REST OF ENTRY
         BXLE  R3,R4,XDDLOOP1
*              NOT FOUND
         AIF   (&X$DDMOR).XDDSK1   ALLOWED OWN DDNAMES?
*              YES                 TRY TO FIND SPACE
         L     R3,=A(XDDTABLE)     RESET BEGINNING ADDRESS
XDDLOOP  TM    X$SLFLAG,X$SLPERM   ENTRY TEMPORARY?
         BZ    XDDMAKE             YES
XDDLPBOT BXLE  R3,R4,XDDLOOP
.XDDSK1  ANOP
*                                  SIGNAL ERROR
XDDFBAD  EQU   *
         TM    *+1,X'FF'           SET COND CODE
XDDFGOOD EQU   *
         LM    R14,R12,XDDSAVE     RESTORE REQS
         B     XIORETRN            RETURN
         AIF   (&X$DDMOR).XDDSK2
*                                  PUT DDNAME IN
XDDMAKE  TM    X$SLFLAG,X$SLOPEN   FILE OPEN?
         BM    XDDLPBOT            YES, TRY AGAIN
         MVC   X$SLNAME(8),0(R1)
         MVI   X$SLFLAG,X$SLPOIN   SET FOR POSSIBLE IN OR OUT
         B     XDDAAAA
.XDDSK2  ANOP
XDDFOUND TM    X$SLFLAG,X$SLOPEN   IS IT OPEN?
         BZ    XDDNOPEN            NO,  GO FIX UP
         TM    X$SLFLAG,$          *****CHANGES-  GOING THE RIGHT WAY?
XDDIOBIT EQU   *-3                 LABEL FOR IMMEDIATE BYTE
         BO    XDDECIDE            GOING RIGHT WAY --- BRANCH
         B     XDDFBAD             TAKE BAD BRANCH
XDDNOPEN SR    R2,R2               EMPTY R2
         IC    R2,XDDIOBIT
         SRL   R2,4                MOVE BITS OVER
         STC   R2,*+5              PUT IN TM INST BELOW
         TM    X$SLFLAG,$ ****CHANGES*****  USER ALLOWED TO GO THIS WAY
         BZ    XDDFBAD             NO, GO RETURN
XDDAAAA  OC    X$SLFLAG,XDDIOBIT   SET TEMP DIRECTION BIT
XDDECIDE SR    R2,R2               CLEAR R2
         IC    R2,X$SLWAY
         LH    R8,XIOLENG          SET UP LENGTH
         B     *+4(R2)             BRANCH INTO BRANCH TABLE
         B     XDD$GPIO            DO XGET-XPUT
         B     XDD$READ            DO NORMAL READ
         B     XDD$PRNT            DO NORMAL PRINT
         B     XDD$PNCH            DO NORMAL PUNCH
XDD$READ EQU   *
         $READ  (R0),(R8)
         B     XDDFGOOD            GO RETURN
XDD$PRNT EQU   *
         $PRNT  (R0),(R8)
         B     XDDFGOOD            GO RETURN
XDD$PNCH EQU   *
         $PNCH (R0),(R8)
         B     XDDFGOOD            GO RETURN
XDD$GPIO EQU   *
         LTR    R8,R8              IS LENGTH ZERO?
         BNE   *+8                 NO, DON'T FORGET ELEMENT
         NI     X$SLFLAG,X$SLCLOS  EMPTY ELEMENT
         CLI   XDDIOBIT,X$SLXPUT   WAS IT OUTPUT?
         BE    XDD$PUT             YES, DO OUTPUT
*                                  NO,  DO INPUT
         XGET  (R0),(R8)
         B     XDDCLEAN
XDD$PUT  EQU   *
         XPUT  (R0),(R8)
XDDCLEAN EQU   *
*        IF COND CODE IS BAD, WIPE OUT FLAG
         BE    XDDFGOOD            GO RETURN
         BALR  R2,0                SAVE COND CODE FOR AFTER NI
         NI    X$SLFLAG,X$SLCLOS   WIPE OUT FLAG
         SPM   R2                  RESTORE COND CODE TO BEFORE NI
         B     XDDFGOOD            GO RETURN
XDDSAVE  DS    15F                 SAVE AREA FOR REGISTERS
         LTORG
         DROP  R14,R3,R12          CLEAN UP USINGS
         TITLE 'CSECT***XXDDFINI*** CLOSE XGET-XPUT HANDLED FILES'
XXDDFINI CSECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*-->CSECT: XXDDFINI  CLOSES XGET-XPUT FILES                           *
*    LIKE XXXXFINI, CALLED AT SAME TIME.                              *
*    BUT CLOSES ONLY THE FILES HANDLED BY XGET-XPUT                   *
*                                                                     *
*    SEARCHS TABLE XDDTABLE FOR FILES THAT ARE OPEN AND ARE HANDLED   *
*              BY XGET-XPUT.                                          *
*    WHEN FOUND, CLOSES THEM THROUGH XGET-XPUT. BLANKS OUT FIRST BYTE *
*              OF NAME IN TABLE.  IF NOT PERMANENT, AND NOT OPEN,     *
*              JUST WIPES OUT FIRST BYTE.                             *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         USING XIOBLOCK,R14        ADDRESSABILITY INTO XIOBLOCK
         USING *,R15               TEMPORARY ADDRESSABILITY
         STM   R14,R12,XDDFSAVE    SAVE REGISTERS
         BALR  R12,0               SET R12
         USING *,R12               PERMANENT ADDRESSABILITY
         DROP  R15                 KILL R15
         L     R3,=V(XDDTABLE)     GET THE @ OF THE TABLE
         USING X$SLOT,R3 .         SET UP FOR TABLE
         LA    R4,X$SLLONG         GET INCREMENT SIZE
         LA    R5,X$SLOT+X$DDLONG-1     GET UPPER BOUNDARY
XXDDFLOP TM    X$SLFLAG,X$SLOPEN   IS FILE OPEN
         BZ    XXDDFCHK            NO, GO SEE IF IT IS PERMANENT
         CLI   X$SLWAY,X$SLXGPT    IS FILE HANDLED BY XGET-XPUT?
         BNE   XXDDFBOT            NO, CLOSED BY XXXXFINI
         LR    R1,R3               POINT TO DD NAME
         TM    X$SLFLAG,X$SLXGET   HANDLED BY XGET?
         BO    XXDDFGET            YES CLOSE BY XGET
*                                  NO, CLOSE BY XPUT
         XPUT  XDDFSAVE,0          CLOSE, USE DUMMY OUTPUT AREA
         B     XXDDFCHK
XXDDFGET EQU   *
         XGET  XDDFSAVE,0          CLOSE, USE DUMMY INPUT AREA
XXDDFCHK NI    X$SLFLAG,X$SLCLOS   REMOVE OPEN BITS
         TM    X$SLFLAG,X$SLPERM   IS FILE PERMANENT
         BO    XXDDFBOT            YES, LEAVE ALONE
         MVI   X$SLNAME,C' '       NO, BLANK OUT
XXDDFBOT BXLE  R3,R4,XXDDFLOP      TRY NEXT ENTRY
*                                  RAN OUT OF ENTRIES, DONE
         LM    R14,R12,XDDFSAVE    RESTORE REGISTERS
         BR    R14                 RETURN
XDDFSAVE DS    15F                 SAVE AREA FOR REGISTERS
         LTORG
         DROP  R14,R3,R12          KILL USINGS
         PRINT GEN
XXXXGET  XGPGEN
XXXXPUT  XGPGEN DIREC=P
         PRINT NOGEN               TURN OFF AFTER
.XGPSKIP ANOP
         TITLE 'CSECT XXXXXIOCO  ASSIST I/O PROCESSOR'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> CSECT: XXXXIOCO   ASSIST INPUT/OUTPUT CONTROL PROCESSING         *
*              XXXXIOCO CONTAINS ALL ACTUAL INPUT/OUTPUT OPERATIONS.  *
*        XXXXINIT AND XXXXFINI ARE USUALLY CALLED ONCE EACH, TO       *
*        PERFORM INITIALIZATION AND TERMINATION RESPECTIVELY.         *
*        THE ENTRIES XXXXSORC,XXXXREAD,XXXXPNCH,XXXXPRNT ARE CALLED   *
*        TO READ SOURCE CARDS,READ DATA CARDS, PUNCH CARDS, OR PRINT  *
*        LINES DURING EXECUTION.  THE DCB'S FOR READ AND PNCH ARE NOT *
*        OPENED UNLESS THEY ARE USED, AND IF USED WITHOUT WORKABLE    *
*        OPEN'S, THEY DEFAULT BACK TO SORC AND PRNT, RESPECTIVELY.    *
*        THESE 4 ENTIRES SHARE A COMMON BASE REGISTER (R13,ALSO @ SAVE*
*        AREA), COMMON VALUES OF R11 (@ AJOBCON) AND R12 ( CONSTANT 1)*
*        COMMON EXIT CODE.  SORC AND READ SHARE SOME COMMON CODE (GET)*
*        AND PNCH AND PRNT SHARE SOME COMMON CODE (PUT).              *
*        THESE ROUTINES ARE DESIGNED TO ACCEPT THE XIOBLOCK SET UP BY *
*        THE XIONR MACRO($READ,$PRNT,$PNCH,$SORC). LOCATE MODE IS     *
*        USED TO MINIMIZE MOVEMENT OF CARD AND LINE IMAGES.           *
*        *NOTE* REMOTE OPEN/CLOSE PARM LISTS ARE USED TO SAVE SPACE.  *
*        UNDER A DOS SYSTEM, NO SUCH LIST EXISTS DUE TO THE NON-      *
*        EXISTENCE OF MACRO EXECUTE FORMS FOR THE CLOSING OF DTF'S    *
*        USES MACROS:  DCB,DCBD(OS) OR DTF(DOS)   (OVERALL USE)       *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
XXXXIOCO CSECT
         $DBG  ,NO                 SHOW NO DEBUG CODE-$SAVE/$RETURN
         ENTRY XXXXINIT,XXXXFINI,XXXXREAD,XXXXSORC,XXXXPNCH,XXXXPRNT
         AIF   (&$DISKU EQ 0).XXNOENT  SKIP ENTRY DEFINITION IF NODSK
         AIF   (&$ASMLVL).XXBOS1   GEN. CORRECT DISK I/O EQUATES
XXDECBE  EQU   4 .                 DOS 'DECB' OFFSET
XXDECBIN EQU   0 .                 OFFSET INTO FAKE DECB - XXFIXUP
XXDKOFFL EQU   8 .                 DOS BUFFER OFFSET, NEEDS 8 BYTES
XXDKOPEN EQU   X'15'               DTF OFFSET FOR OPEN TEST
XXMASK   EQU   X'04'               DOS OPEN TEST MASK
         AGO   .XXBOS2
.XXBOS1  ANOP
XXDECBE  EQU   16 .                OS DECB OFFSET
XXDECBIN EQU   12 .                OFFSET INTO OS DECB - XXFIXUP
XXDKOFFL EQU   0 .                 OS BUFFER OFFSET, NONE NEEDED
XXDKOPEN EQU   48 .                OS DCB DISP. FOR OPEN TEST
XXMASK   EQU   X'10' .             OS OPEN TEST MASK.
.XXBOS2  ANOP
         ENTRY XXXXDKOP,XXXXDKRD,XXXXDKE1,XXXXDKWT
.XXNOENT ANOP
         AIF   (NOT &$MACSLB).XXNOMET    SKIP ENTRIES IF NO MACSLB
         ENTRY XXXXLBOP,XXXXLBRD,XXXXFIND,XXXXLBED
.XXNOMET ANOP
         USING AJOBCON,R11         NOTE GLOBAL USING FOR WHOLE CSECT
         SPACE 1
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> ENTRY: XXXXINIT   INITIAL OPEN FOR READER/PRINTER                *
*        OPENS PRINTER,SOURCE CARD RDR.  INITIALIZES XXIOCPTR, WHICH  *
*        ALWAYS HAS BEGINNING @ OF OPEN/CLOSE PARM LIST (OS GEN. ONLY)*
*        ENTRY CONDITIONS                                             *
*   R11= @ AJOBCON DUMMY SECTION                                      *
*   AJIO-- FLAGS IN AJOBCON ARE ALL ZEROS.                            *
*        EXIT CONDITIONS                                              *
*   AJIOSO,AJIOPR FLAGGED WITH AJIOPEN IF DCB'S OPENED PROPERLY.      *
*        USES MACROS: $RETURN,$SAVE,OPEN                              *
*        USES DSECT: AJOBCON                                          *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
XXXXINIT $SAVE RGS=(R14-R12),SA=XXIOSAVE,BR=R6
         ST    R11,XXIOAJOB        SAVE @ OF MAIN TABLE
         AIF   (NOT &$MACSLB).XXINNOM  SKIP WHEN NO MACSLB ABILITY
         MVI   XXLBFLG,X'00'       SHOW NO BUFFER(MACSLB) AT THIS POINT
.XXINNOM ANOP
         AIF   (&$ASMLVL).XXOSOPN  SKIP FOR OS GENERATION OPEN
         OPEN  XXSODCB,XXPRDCB     OPEN XXSODCB, XXPRDCB RIGHT NOW
         TM    XXSODCB+15,X'20'    DID SOURCE READER OPEN?
         BO    *+8                 SKIP FLAGGING IF IT DIDN'T OPEN
         OI    AJIOSO,AJIOPEN      SHOW SOURCE READER OPEN
         TM    XXPRDCB+15,X'20'    DID LINE PRINTER OPEN?
         BO    *+8                 SKIP FLAGGING IF IT DIDN'T OPEN
.XXOSOPN AIF   (NOT &$ASMLVL).XXDOSOP        SKIP IF A DOS OPEN
         LA    R1,XXIOCSP          INIT VALUE OF OPEN/CLOSE PTR
         ST    R1,XXIOCPTR         STORE INIT VALUE OF PTR
         OPEN  MF=(E,(1))          OPEN XXSODCB,XXPRDCB RIGHT NOW
         TM    XXSODCB+48,X'10'    DID SOURCE READER OPEN?
         BZ    *+8                 SKIP FLAGGING IT OPEN IF DIDN'T
         OI    AJIOSO,AJIOPEN      SHOW SOURCE READER OPEN
         TM    XXPRDCB+48,X'10'    DID PRINTER OPEN?
         BZ    *+8                 SKIP FLAGGING IT OPEN IF DIDN'T
.XXDOSOP ANOP
         OI    AJIOPR,AJIOPEN      SHOW PRINTER OPEN
XXIOOPRT $RETURN RGS=(R14-R12)
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> ENTRY: XXXXFINI   CLOSE ALL DCB'S WHICH ARE OPEN                 *
*        XXXXFINI USES THE OPEN/CLOSE PARM LIST BUILT DURING EXECUTION*
*        TO CLOSE ALL DCB'S CURRENTLY OPEN.  USES 1 EXECUTE TYPE OPEN.*
*        DOS GENERATIONS HAVE NO OPEN/CLOSE LIST, SO A CHECK MUST BE  *
*        MADE TO SEE WHICH DCB'S MUST BE CLOSED.                      *
*        ENTRY CONDITIONS                                             *
*   R11= @ AJOBCON DUMMY SECTION                                      *
*        EXIT CONDITIONS                                              *
*   AJIO-- FLAGS ARE ALL ZEROED OUT.                                  *
*        USES DSECTS: AJOBCON                                         *
*        USES MACROS: $RETURN,$SAVE,CLOSE                             *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
XXXXFINI $SAVE RGS=(R14-R12),BR=R6,SA=XXIOSAVE
         AIF   (&$ASMLVL).XXOSCLS  SKIP FOR OS GENERATION CLOSE
         PUT   XXPRDCB             OUTPUT LAST DOS RECORD
         CLOSE XXSODCB,XXPRDCB     CLOSE SOURCE READER AND PRINTER
         AIF   (NOT &$DATARD).XXNORDR     SKIP IF NO //DATA.INPUT RDR
         TM    AJIORE,AJIOPEN      WAS OTHER READER OPENED
         BNO   XXFIPNCH            IF NOT, THEN DON'T CLOSE IT
         CLOSE XXREDCB             CLOSE DATA CARD READER
.XXNORDR AIF   (NOT &$PUNCH).XXNOPNC         SKIP IF NO REAL CARD PUNCH
XXFIPNCH TM    AJIOPN,AJIOPEN      WAS THE PUNCH OPENED
         BNO   XXFIEXIT            IF NOT, THEN DON'T CLOSE IT
         PUT   XXPNDCB             OUTPUT LAST PUNCHED DOS CARD
         CLOSE XXPNDCB             CLOSE CARD PUNCH FILE
.XXNOPNC AIF   (&$PUNCH).XXOSCLS   SKIP IF CARD PUNCH EXISTS
XXFIPNCH EQU   *                   EQU TO EXIT, SINCE NO REAL PUNCH
         TM    AJIODSK,AJIOPEN     IS DISK DTF OPEN
         BO    XXFIOUT             NO - SO GO RETURN
         CLOSE XXDKUDCB            YES - SO CLOSE DTF
XXFIOUT  EQU   *
.XXOSCLS AIF   (NOT &$ASMLVL).XXDOSCL     SKIP IF DOS CLOSE IN EFFECT
         L     R1,XXIOCPTR         GET PTR TO BUILT UP OPEN/CLOSE LIST
         CLOSE MF=(E,(1))          REMOTE CLOSE ON ALL OPEN DCB'S
.XXDOSCL ANOP
XXFIEXIT XC    AJIOFLAG,AJIOFLAG   CLEAR ALL FLAGS OUT
         AIF   (NOT &$ASMLVL).XXFIF1   SKIP IF NOT OS/360
*              FOLLOWING CODE REQUIRED FOR PROPER REUSABILITY.
         L     R2,XXIOCPTR         GET @ BEGINNING OF DCB @ LIST
         SPACE 1
XXFIFREE L     R1,0(,R2)           GET @ NEXT DCB
         AIF   ((&$DISKU EQ 0) AND (NOT &$MACSLB)).XXFINA
         USING IHADCB,R1           NOTE USING ON R1
         TM    DCBBUFCB+3,1        DOES DCB OWN A BUFFER POOL OR NOT
         BO    XXDCBLST            SINCE ODD @, NO BUFFER POOL - BRANCH
XXFRPOOL FREEPOOL (1)              DO THE FREEPOOL TO GET RID OF BUFS
XXDCBLST TM    0(R2),X'80'         WAS THAT THE LAST?
         AGO   .XXFINB
.XXFINA  ANOP
         FREEPOOL (1)              DO THE FREEPOOL TO GET RID OF BUFS
         TM    0(R2),X'80'         WAS THAT ONE THE LAST ONE?
.XXFINB  ANOP
         LA    R2,4(R2)            INCREMENT TO NEXT DCB @
         BNO   XXFIFREE            NOT LAST, GO BACK FOR NEXT ONE
         SPACE 1
.XXFIF1  ANOP
         $RETURN RGS=(R14-R12),SA=XXIOSAVE
         DROP  R6                  KILL USING
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*         REGISTER USAGE FOR SECTIONS SORC,READ,PNCH,PRNT             *
*   R0 = @ I/O AREA WHERE USER DESIRES DATA MOVED TO/FROM             *
*   R1 = @ DCB FOR OPERATION (SET BEFORE ENTRY TO SECTIONS GET, PUT   *
*   R2 = @ CONTROL BYTE FOR READER SECTIONS, SET BEFORE ENTRY TO GET  *
*   R3,R4 WORK REGISTERS                                              *
*   R5 = DOS IOREG FOR BOTH GET & PUT OPERATIONS                      *
*   R6,R7,R8,R9,R10  ARE NOT MODIFIED OR USED                         *
*   R11= @ AJOBCON, MAIN CONTROL DUMMY SECTION                        *
*   R12= 1, USEFUL CONSTANT                                           *
*   R13= @ SAVE AREA XXIOSAVE, ALSO COMMON BASE REGISTER              *
*   R14= @ XIOBLOCK, CONTAINING LENGTH OF I/O REQUEST                 *
*   R15= LOCAL WORK REGISTER, TEMPORARY SINCE I/O OPRS MODIFY.        *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         USING XXIOSAVE,R13        NOTE GLOBAL USING
         USING XIOBLOCK,R14        NOTE PTR TO XIOBLOCK, GLOBAL
         AIF   (NOT &$DATARD).XXNDAT0       SKIP IF NO //DATA.INPUT RDR
         SPACE 2
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> ENTRY: XXXXREAD   READ 1 CARD AT USER EXECUTION TIME             *
*        OPENS CARD READER(DDNAME FT05F001) IF NOT ALREADY OPEN, OR   *
*        USES OPEN READER (DDNAME FT00F001) TO GET 1 CARD, USING THE  *
*        COMMON CODE SECTION XXIOGET.  IF NODATA WAS SPECIFIED IN THE *
*        USER PARM FIELD, NO OPEN WILL BE DONE FOR  FT05F001, BUT     *
*        SYSIN WILL BE USED INSTEAD.  CALLED BY $READ MACRO.          *
*        ENTRY CONDITIONS                                             *
*   R0 = @ I/O AREA WHERE DATA TO BE READ/WRITTEN                     *
*   R14= @ XIOBLOCK CREATED BY THE CALLING XIONR MACRO.               *
*   R15= ENTRY POINT ADDRESS                                          *
*        EXIT CONDITIONS                                              *
*   CC=  0     NORMAL RETURN, CARD WAS READ AND TRANSFERRED TO USER   *
*   CC=  1     ENDFILE ON READER.  IF ASSIST JCL, SAVED IN AJOBCON.   *
*        USES MACROS:   GET,OPEN                                      *
*        USES DSECTS: AJOBCON,XIOBLOCK                                *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         USING XXXXREAD,REP        NOTE TEMPORARY USING
XXXXREAD STM   R11,R5,XXIOSAVT     STORE REGS TO BE CHANGED
         LM    R11,R13,XXIOAJOB    LOAD NEEDED VALUES
         DROP  REP                 KILL TEMPORARY USING
         TM    AJIORE,AJIOPEN      WAS IT ALREADY OPEN?
         BO    XXREC               YES,GO DO GET
         TM    AJIORE,AJIODFLT     ARE WE USING SOURCE RDR INSTEAD?
         BO    XXSORE              YES, SO USE SORC READER INSTEAD
*              CALL OPTIONAL USING OPEN ROUTINE TO OPEN RDR IF IT CAN.
         LA    R2,AJIORE           SHOW @ RDR CONTROL BYTE
         AIF   (&$ASMLVL).XXNDTF   SKIP IF UNDER OS GENERATION
         LA    R1,XXREDCB          SHOW @ OF DOS DCB
.XXNDTF  AIF   (NOT &$ASMLVL).XXNIOCR  SKIP IF UNDER DOS GENERATION
         LA    R3,XXIOCRE          SHOW @ OF OPEN/CLOSE PARM VALUE
.XXNIOCR ANOP
         BAL   R4,XXIOPENO         CALL OPEN/FLAGGING SECTION
         BZ    XXIOGET             IF OK, ALL SET UP-GO READ
         B     XXSORE              OPEN DIDN'T GO, USE SOURCE RDR
         SPACE 1
XXREC    LA    R1,XXREDCB          SHOW @ DCB
         LA    R2,AJIORE           SHOW @ CONTROL BYTE
         B     XXIOGET             GO TO COMMON GET ROUTINE
.XXNDAT0 AIF   (&$DATARD).XXNDAT2  SKIP IF DATA RDR EXISTS
XXXXREAD EQU   *                   EQU TO XXXXSORC-DATA RDR ^EXIST
.XXNDAT2 ANOP
         SPACE 2
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> ENTRY: XXXXSORC   READ A CARD DURING ASSEMBLY TIME               *
*        CALLED BY MACRO $SORC TO READ CARD FOR ASSEMBLER, USING      *
*        ALREADY OPEN DCB (DDNAME SYSIN).                             *
*        ENTRY CONDITIONS - SAME AS THOSE FOR ENTRY XXXXREAD.         *
*        EXIT CONDITIONS  - SAME AS THOSE FOR ENTRY XXXXREAD.         *
*        USES DSECTS: AJOBCON,XIOBLOCK                                *
*        USES MACROS: GET                                             *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         USING XXXXSORC,REP        NOTE TEMPORARY USING
XXXXSORC STM   R11,R5,XXIOSAVT     STORE REGS TO BE CHANGED
         LM    R11,R13,XXIOAJOB    LOAD NEEDED VALUES
         DROP  REP                 KILL TEMPORARY USING
         AIF   (NOT &$MACSLB).XXNOSOC  SKIP IF NO MACRO LIBRARY
XXSWTCH  BC    $,XXXXLBRD          GET A CARD FROM LIBRARY-MAYBE
.XXNOSOC  ANOP
         CLI   AJOBTRQ,AJO$D       REQUEST FOR DATA?                  J
         BE    XXIOBTAA            YES, NO NEED FRO SPECIAL CHECKS    J
*              AT THIS POINT, ASSIST IS ASKING FOR A $JOB/$ENTRY CARD J
         NI    AJIOSO,255-AJIOPSEO MAKE SURE NO PSEUD-END-FILE ON     J
         AIF   (NOT &$HASPBT).XXIOBTA   SKIP IF NO HASP AUTOBATCH     J
         TM    AJIOSO,AJIOSOHS     DO WE NEED BUFFER FLUSH?           J
         BZ    XXIOBTAA            NO,SKIP OVER IT                    J
         NI    AJIOSO,255-AJIOSOHS REMOVE FLAG SO WON'T DO AGAIN      J
*              JUST PREVIOUSLY, TWO OS NULL CARDS HAD BEEN FOUND, AND J
*              ASSIST WANTS TO READ FOR THE NEXT $JOB CARD, IN WHICH  J
*              CASE HASP MAY WANT TO PERFORM TERMINATION.  IT IS USED J
*              THUSLY.   IF USING MULTIPLE BUFFERS, CONSIDER CHANGING J
*              THIS TO CLOSE/OPEN ON XXPRDCB.                         J
*              IT IS NECESSARY TO PUT A BLANK LINE (SINCE LOCATE MODE)J
XXSORD   PUT   XXPRDCB             DO PUT LOCATE
         LH    R2,XXPRDCB+DCBLRECL-IHADCB   GET ACTUAL RECORD LENGTH  J
         BCTR  R2,0                GET LENGTH-1 FOR MVC               J
         STC   R2,*+5              PUT LENGTH-1 INTO MVC              J
         MVC   0($,R1),AJOBLANK    PUT OUT A BLANK LINE TO FLUSH      J
.XXIOBTA ANOP                                                         J
XXIOBTAA EQU   *                   BRANCH IF DATA OR NO BUFFER FLUSH  J
XXSORE   LA    R1,XXSODCB          SHOW @ DCB
         LA    R2,AJIOSO           SHOW @ CONTROL BYTE
         SPACE 2
* * * * * XXIOGET - COMMON GET CODE FOR XXXXSORC AND XXXXREAD         *
XXIOGET  TM    0(R2),AJIOEOF+AJIOPSEO    WAS EITHER EOF FLAG ALREADY ON
         BNZ   XXIORETA            YES, REFUSE TO READ A CARD NOW
         LM    R14,R0,XXIOSAVT+12  RELOAD ORIG VALUES, IN CASE CHANGED
         LH    R3,XIOLENG          GET THE LENGTH OF OPERATION FROM XIO
         LR    R4,R0               MOVE @ AREA OVER FOR SAFEKEEPING
         TM    AJIOSO,AJIOSORR     WAS REREAD REQUIRED?               J
         BZ    *+16                NO, BRANCH AND READ NEXT CARD      J
         L     R1,XXIOLSTC         REREAD- GET @ OF LAST BUFFER       J
         NI    AJIOSO,255-AJIOSORR CLEAR FLAG SO DON'T REREAD AGAIN   J
         B     XXIOBTBB            BRANCH AROUND READ                 J
         GET   (1)                 DO GET LOCATE ON DCB @
         AIF   (&$ASMLVL).XXNIORG      SKIP IF OS & HAVE NO IOREG (PUT)
*        WHEN DOS ISSUES A GET, R5 IS USED AS ITS IOREG (SINCE R1     *
*        IS ILLEGAL) TO POINT TO INPUT BUFFER. MUST LOAD R1 NOW.      *
         LR    R1,R5               GET @ OF INPUT RECORD
.XXNIORG ANOP
         ST    R1,XXIOLSTC         SAVE ADDRESS OF THIS BUFFER        J
XXIOBTBB EQU   *                   BRANCH HERE IF DOING REREAD        J
         SPACE 1
*              ***** BATCH CONTROL CARD PROCESSING *****
*              IF NOT RUNNING BATCH MODE, ANYTHING GOES; ELSE $JOB &
*              $ENTRY CARDS CREATE PSEUDO EOF AND ARE SAVED. $STOP
*              SETS REAL EOF FLAG TO TERMINATE PROCESSING
         TM    AJOMODE,AJOBATCH    ARE WE IN BATCH MODE
         BNZ   XXIOBTCC            YES, GO LOOK FOR CONTROL CARDS     J
         SPACE 1
*              THRU HERE ==> NORMAL CARD-SIMULATE READ
XXIONORM EQU   *                   ENTER HERE FOR NORMAL CARD
         SR    R3,R12              SUBTRACT 1 FROM LENGTH
         BM    XXIORETB            0 LENGTH READ(MUST BE FLUSHING)
         STC   R3,*+5              STORE LENGTH - 1 INTO MOVE
         MVC   0($CHN,R4),0(R1)    MOVE DESIRED PART OF CARD OVER
         AIF   (NOT &$KP26).XXNKP26         SKIP IF NO 026 KEYPUNCH
         SPACE 1
*              IF KP=26 OPTION USED, TRSANSLATE CARD TO EBCDIC.
         TM    AJIOSO,AJIOKP26     WAS KP=26 OPTION SPECIFIED
         BZ    XXIOKP29            NO, DON'T TRANSLATE, ALREADY -29
         STC   R3,*+5              STORE LENGTH-1 INTO TR
         TR    0($,R4),AJTRTB26    TRANSLATE AMOUNT READ BY RDR TO 029
XXIOKP29 EQU   *                   SKIP HERE IF NO TRANSLATE NEEDED
.XXNKP26 ANOP
         B     XXIORETB            RETURN, SHOWING NORMAL RETURN      P
         SPACE 1                                                      J
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *J*
*         BATCH CONTROL CARD SCANNING PROCESS -  NEW FOR VERSION 3.0 J*
*         THIS VERSION INCORPORATES MORE FLEXIBILITY, AND ALSO       J*
*         SUPPORTS HASP AUTOBATCH CODE AS AN OPTION.  MODULE ASSIST  J*
*         SETS FLAG AJOBTRQ TO SHOW THE TYPE OF CONTROL CARD THAT IT J*
*         IS REQUESTING (AJOBTRQ=0 OTHERWISE).  ACTIONS THEN DEPEND  J*
*         ON THE TYPE REQUESTED AND THE INPUT FOUND.  NOTE THAT THIS J*
*         CODE NOW PERFORMS THE FLUSH TO CONTROL CARD, RATHER THAN   J*
*         HAVING ASSIST LOOP LOOKING FOR ONE.                        J*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *J*
XXIOBTCC CLI   0(R1),C'&$BTCC(1)'  DOES CARD HAVE CONTROL CHARACTER?  J
         BNE   XXIOBTEE            NO, CAN'T BE CONTROL CARD, BRANCH  J
         CLC   =C'&$BTCC(2)',1(R1) IS IT JOB BEGINNER?                J
         LA    R15,AJO$J           SHOW CODE FOR JOB BEGINNER         J
         BE    XXIOBTFF            YES, GO HANDLE IT                  J
         AIF   ('&$BTCC(3)' EQ '').XXIOBT3   SKIP IF NO $ENTRY WANTED J
         CLC   =C'&$BTCC(3)',1(R1) WAS IT $ENTRY OR EQUIVALENT?       J
         LA    R15,AJO$E           SHOW CODE FOR $ENTRY               J
         BE    XXIOBTFF            YES, GO TO PROCESS IT              J
.XXIOBT3 AIF   ('&$BTCC(4)' EQ '').XXIOBT4  SKIP IF $STOP NOT ALLOWED J
         CLC   =C'&$BTCC(4)',1(R1) IS THIS A $STOP CARD OR EQUIV?     J
         BE    XXIOEOF             YES, TREAT AS REAL EOF             J
.XXIOBT4 ANOP                                                         J
XXIOBTEE SR    R15,R15             SET = AJOB$D, NOT A CONTROL CARD   J
XXIOBTFF EQU   *                   COME HERE TO MAKE PROCESS DECISION J
         SPACE 1                                                      J
         AIF   (NOT &$HASPBT).XXIOBT6  SKIP IF NOT HASP AUTOBATCH     J
*              HASP AUTOBATCH CODE FOLLOWS: SET UP TO READ OVER OS    J
*              JOB CARDS, HANDLE TWO NULLS AS REQUIRED, ALLOW READING J
*              OF SINGLE NULL, AND MAKE UP DUMMY $JOB CARD IF OMITTED J
*              FOLLOWING OS JOB CARD.                                 J
         CLC   0(2,R1),=C'//'      WAS THIS CARD // CARD?             J
         BNE   XXIOBTSS            NO, GO TO DETERMINE ACTION         J
         CLC   2(70,R1),AJOBLANK+2       WAS IT NULL CARD (COLS 3-72)?
         BNE   XXIOBTNN            NO, NOT A NULL CARD AT ALL-BRANCH  J
*              AT THIS POINT, WE HAVE 1 NULL.  NOW CHECK FOR 2ND.     J
         GET   XXSODCB             READ CARD, SET R1 => CARD          J
         ST    R1,XXIOLSTC         MAKE SURE @ CARD SAVED FOR LATER   J
         CLC   0(2,R1),=C'//'      COULD IT BE NULL?                  J
         BNE   XXIOBTHH            NO, GO TO HANDLE SINGLE NULL(GAH)  J
         CLC   2(70,R1),AJOBLANK+2       WAS IT NULL CARD (COLS 3-72)?
         BNE   XXIOBTHH            NOT NULL- BRANCH                   J
*              TWO NULL CARDS FOUND - ACTION DEPENDS ON REQUEST TYPE. J
         CLI   AJOBTRQ,AJO$J       WAS $JOB CARD ASKED FOR?           J
         BE    XXSORD              YES, GO BUFFER FLUSH AND DO GET    J
         OI    AJIOSO,AJIOSOHS     NEXT TIME-SHOW WILL NEED BUFFER FLSH
         AIF   ('&$BTCC(3)' EQ '').XXIOBT5 SKIP IF NO $ENTRY          J
         MVI   AJOBTYP,AJO$J       FAKE TO MAKE $ENTRY REQ QUIT       J
         CLI   AJOBTRQ,AJO$E       WAS IT ACTUALLY $ENTRY?            J
         BE    XXIORETB            RETURN NORMAL, WILL CALL FOR $JOB  J
.XXIOBT5 B     XXIOASJC            GO SHOW PSEUDO-END-FILE            J
*              FOLLOWING CODE FOR SINGLE NULL BY ITSELF IN JOB(?)     J
XXIOBTHH MVC   AJOJCLCD,AJOBLANK   BLANK OUT WORK AREA                J
         MVC   AJOJCLCD(2),=C'//'  CREATE DUMMY NULL CARD             J
         LA    R1,AJOJCLCD         SHOW @ NULL CARD                   J
XXIOBTJJ OI    AJIOSO,AJIOSORR     REREAD,DON'T LOSE LAST CARD        J
         SR    R15,R15             SHOW AJO$D => NON-CONTROL CARD     J
         B     XXIOBTSS            GO TO DETERMINE ACTION NEEDED      4
*              FOLLOWING CODE IF // CARD, BUT NOT NULL CARD           J
XXIOBTNN CLI   AJOBTRQ,AJO$J      SHOULD WE BE SCANNING FOR $JOB      J
         BNE   XXIOBTSS            NO, SO TREAT AS NORMAL DATA CARD   J
*              WE ASSUME THAT WE'RE ACTUALLY LOOKING AT OS JOB CARD   J
*              NOW: HERE IS PLACE FOR ACCOUNTING IF YOU WANT IT.      J
         GET   XXSODCB             SKIP OVER THE CARD                 J
         ST    R1,XXIOLSTC         SAVE @, IN CASE NEEDED LATER       J
         CLC   =C'&$BTCC(1)&$BTCC(2)',0(R1)  WAS IT A $JOB NEXT       J
         BE    XXIOBTOO            YES, THIS IS WHAT WE WANTED        J
*              NO $JOB CARD AFTER OS JOB: BE NICE AND FAKE ONE.       J
*              FOLLOWING STATEMENT CAN BE USED TO SUPPLY PARMS, SINCE J
*              ASSIST THINKS IT'S A $JOB CARD.  CHANGE AS DESIRED.    J
         MVC   AJOJCLCD,AJOBLANK   BLANK OUT CARD WORKAREA            J
         MVC   AJOJCLCD(15),=CL15'&$BTCC(1)&$BTCC(2) ASSUMED'         J
         LA    R1,AJOJCLCD         SHOW ADDRESS OF ASSEMBLED FAKE CARDJ
         OI    AJIOSO,AJIOSORR     MARK, SO DON'T LOSE LOOKAHEAD      J
XXIOBTOO LA    R15,AJO$J           FAKE CODE OF $JOB CARD             J
.XXIOBT6 ANOP
*              FOLLOWING CODE EXPECTS R15=0,1,2 TO INDICATE TYPE OF   J
*              CARD FOUND (DATA, $JOB, $ENTRY(MAYBE)).  USE TABLE TO  J
*              DETERMINE ACTION: FUNCTION OF TYPE REQESTED&THAT FOUND.J
XXIOBTSS STC   R15,AJOBTYP         SHOW THE TYPE ACTUALLY FOUND       J
         MH    R15,=H'3'           MULTIPLY TO GET OFFSET OF TABLE ROW
         SR    R14,R14             CLEAR FOR INSERT                   J
         IC    R14,AJOBTRQ         GET COLUMN SELECTOR: TYPE REQUEST  J
         AR    R15,R14             GET OFFSET OF CODE BYTE IN TABLE   J
         IC    R15,XXIOBTAB(R15)   GET CODE BYTE TO DETERMINE ACTION  J
*              ACTIONS:  0: LOOP (SEARCHING FOR $JOB/$ENTRY CARD);    J
*              4: RETURN NORMAL, COPYING CARD TO REQUESTED AREA;      J
*              8:  EXIT WITH END-FILE (CONTROL CARD FOUND IN DATA)    J
         B     *+4(R15)            TAKE INDEXED BRANCH                J
         B     XXSORE              0: LOOP, HUNTING CONTROL CARD      J
         B     XXIONORM            4: NORMAL RETURN, COPY CARD        J
*                                  8: FALL THRU INTO XXIOASJC         J
XXIOASJC OI    AJIOSO,AJIOPSEO+AJIOSORR PSEUDO-EOF, REREAD TO SAVE CARD
         B     XXIORETA            SHOW A PSEUDO END-FILE
XXIOEOF  OI    0(R2),AJIOEOF       SHOW END-FILE HAS OCCURRED
         B     XXIORETA            RETURN SHOWING END-FILE
*              ACTION CONTROL TABLE: USED IN XXIOBTSS CODE.  CHANGE   J
*              AS NEEDED IF DIFFERENT ACTIONS DESIRED.                J
*  AJOBTRQ=        DATA,$JOB,$ENTRY   (REQUEST).  ACTUAL FOUND BELOW  J
XXIOBTAB DC    AL1(0004,0000,0000)    DATA FOUND- NORMAL, LOOP, LOOP  J
         DC    AL1(0008,0004,0004)    $JOB FOUND- EOF, NORMAL, NORMAL J
         DC    AL1(0008,0000,0004) $ENTRY FOUND- EOF,LOOP,NORMAL      J
XXIOLSTC DS    A                   @ LAST CARD READ, FOR REREAD USE   J
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> ENTRY: XXXXPNCH   PUNCH A CARD, OPENING IF REQUIRED              *
*        CALLED BY $PNCH MACRO TO PUNCH A CARD (DDNAME FT07F001).  IF *
*        THE DCB XXPNDCB CANNOT BE OPENED, OR IF NOPUNCH WAS USED IN  *
*        THE USER PARM FIELD, THE CARD IS PRINTED (DDNAME FT06F001)   *
*        WITH ' CARD-->' PRECEDING IT TO NOTE USAGE.                  *
*        ENTRY CONDITIONS - SAME AS ENTRY XXXXREAD                    *
*        EXIT CONDITIONS                                              *
*   CC=  0     NORMAL RETURN, CARD WAS PUNCHED OR PRINTED             *
*   CC=  1     RECORD LIMIT HAS BEEN EXCEEDED, CARD PUNCHED ANYWAY    *
*        USES DSECTS: AJOBCON,IHADCB,XIOBLOCK                         *
*        USES MACROS: OPEN,PUT                                        *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         USING XXXXPNCH,REP        NOTE TEMPORARY USING
XXXXPNCH STM   R11,R5,XXIOSAVT     SAVE REGS TO BE CHANGED
         LM    R11,R13,XXIOAJOB    LOAD NEEDED VALUES
         DROP  REP                 KILL TEMPORARY USING
         AIF   (NOT &$PUNCH).XXNPN0    SKIP IF NO REAL PUNCH
         LA    R2,AJIOPN           SHOW @ CONTROL BYTE
         TM    AJIOPN,AJIOPEN      HAS PUNCH BEEN OPENED?
         BO    XXPNC               YES, SO GO DO IT
         TM    AJIOPN,AJIODFLT     ARE WE ALREADY USING PRINTER?
         BO    XXPNNOPN            YES, SO GO FIX UP
         SPACE 1
*              CALL OPTIONAL UNIT OPEN ROUTINE TO OPEN PUNCH IF IT CAN.
         AIF   (&$ASMLVL).XXYIOCR  SKIP IF UNDER OS GENERATION
         LA    R1,XXPNDCB          SHOW @ OF DOS PUNCH DCB
.XXYIOCR AIF   (NOT &$ASMLVL).XXYSDTF  SKIP IF UNDER DOS GENERATION
         LA    R3,XXIOCPN          SHOW @ OPEN/CLOSE PARM VALUE
.XXYSDTF ANOP
         BAL   R4,XXIOPENO         CALL OPEN/FLAGGING ROUTINE, SETS CC
         BZ    XXIOPUT             IF OK, ALL SET UP, SO GO PUNCH
XXPNNOPN EQU   *                   SECTION TO USE PRINTER FOR PUNCH
.XXNPN0  ANOP
         LR    R2,R0               SAVE @ I/O AREA
         MVC   AJOPNDFT(8),=C' CARD-->'     ENTER CARD FLAG
         MVC   AJOPNDFT+8(80),0(R2)         MOVE POSSIBLE CARD OVER
         LA    R0,AJOPNDFT         FAKE I/O @ TO BE THIS AREA
         LH    R3,XIOLENG          GET LENGTH DESIRED TO PUNCH
         LA    R3,8(R3)            ADD EXTRA LENGTH OF ' CARD-->'
         LA    R1,XXPRDCB          SHOW @ OF PRINTER INSTEAD
         LA    R2,AJIOPR           SHOW @ CONTROL BYTE(IN CASE PAGE)
         B     XXPRPN              PRINT CARD INSTEAD OF PUNCHING
         AIF   (NOT &$PUNCH).XXNPN1         SKIP IF NOPUNCH
         SPACE 1
XXPNC    LA    R1,XXPNDCB          SHOW @ DCB
         B     XXIOPUT             GO TO COMMON PUT SECTION
.XXNPN1  ANOP
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> ENTRY: XXXXPRNT   PRINT ONE LINE OF OUTPUT                       *
*        CALLED BY $PRNT MACRO TO PRINT 1 LINE, USING DDNAME FT06F001.*
*        ENTRY CONDITIONS - SAME AS ENTRY XXXXREAD                    *
*        EXIT CONDITIONS - SAME AS XXXXPNCH                           *
*        USES DSECTS: AJOBCON,IHADCB,XIOBLOCK                         *
*        USES MACROS: PUT                                             *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         USING XXXXPRNT,REP        NOTE TEMPORARY BASE
XXXXPRNT STM   R11,R5,XXIOSAVT     SAVE REGS TO BE CHANGED
         LM    R11,R13,XXIOAJOB    LOAD NEEDED VALUES
         DROP  REP                 KILL TEMPORARY USING
         LA    R1,XXPRDCB          SHOW @ PRINTER DCB
         LA    R2,AJIOPR           SHOW @ PRINTER CONTROL BYTE
         SPACE 1
* * * * * XXIOPUT - COMMON PUT ROUTINE FOR PNCH, PRNT                 *
XXIOPUT  TM    AJOMODE,AJOSRECX    ARE RECORDS ALREADY EXCEEDED
         BO    XXIORETA            YES, IGNORE THIS GUY
         SPACE 1
         LH    R3,XIOLENG          GET LENGTH OF REQUEST
*              ***** OUTPUT RECORD COUNT AND TESTING *****
XXPRPN   EQU   *                   ENTRY POINT IF FAKING PUNCH ON PRNTR
         L     R15,AJORECNT        GET CURRENT RECORDS REMAINING
         SR    R15,R12             DECREMENT
         BM    XXIOVERP            SKIP OUT, NO MORE-DON'T WRITE
         ST    R15,AJORECNT        STORE UPDATED COUNTER BACK
         SPACE 1
         AIF   (NOT &$PAGE).XXNPAG2         SKIP WHOLE SECT IF NO PAGE
         LR    R15,R0              MOVE @ USER AREA WHERE CAN USE IT
         MVC   AJIOWRKB,0(R15)     SAVE 1ST BYTE WHERE WE CAN GET IT
         TM    0(R2),AJIOPAGE      ARE WE 1)PRINTING AND 2)IN PAGE CONT
         BZ    XXNPAGEC            NO, WE AREN'T IN PAGE CONTROL MODE-B
         SPACE 1
*              ***** PAGE CONTROL MODE - PERFORM COINT,CHECK *****
         MVC   XXIOPCLI+1(1),0(R15)    MOVE CARRIAGE CONTROL IN FOR CLI
         LA    R2,XXIOPGTA         BEGINNING @ LEGAL CAR CON BYTE TABLE
         LA    R14,4               INCREMENT FOR BXLE SEARCH
         LA    R15,XXIOPGTZ        @ LAST ELEMNT IN TABLE,BXLE LIMIT
         SPACE 1
XXIOPCLI CLI   0(R2),$             COMPARE TABLE ELEMENT TO USER CARCON
         BE    XXIOPFND            FOUND WHAT HE USED-BRANCH
         BXLE  R2,R14,XXIOPCLI     LOOP UNTIL FIND IT OR RUN OUT
         SPACE 1
         LA    R2,XXIOPGTB         @ BLANK CARRAGE CONTROL TABLE ELEM.
XXIOPFND EQU   *                   CHARACTER FOUND
         TM    AJIOPR,AJIOSING     ARE WE IN CRUNCHED SINGLESPACE MODE?
         BZ    XXIONSIN            NO, NOT SINGLE SPACE MODE
*              FOLLOWING IMPLEMENTS SINGLE SPACE MODE, WHICH SINGLE
*              SPACES ANY CARRIAGE CONTROL EXCEPT '1', WHICH IS JUST
*              DOUBLE SPACED INSTEAD OF NEW PAGED.  THIS MAY BE USEFUL
*              FOR CRAMMING AS MUCH OUTPUT AS POSSIBLE IN GIVEN #
*              OF PAGES, OR OBTAINING AS MUCH OF A DUMP AS POSSIBLE.
         IC    R14,1(,R2)          GET OFFSET TO WORD FOR REPLACEMENT
         LA    R2,XXIOPGTA(R14)    GET @ REPLACEMENT CARRIAGE CONTROL
XXIONSIN EQU   *                   SKIP HERE IF NO SINGLE SPACE
         MVC   AJIOWRKB,0(R2)      PICK UP CORRECT BYTE FOR CC
         SPACE 1
         LM    R14,R15,AJOLREM     GET AJOLREM-AJOPREM FOR TESTING
         SH    R14,2(R2)           LINES REMAINING-LINES FOR GIVEN CCON
         BP    XXIOPSTL            STILL MORE-JUMP-NO OVERFLOW
         SPACE 1
*              OVERFLOW TO NEXT PAGE- COUNT <= 0
         MVI   AJIOWRKB,C'1'       SHOW NEW PAGE CARRAGE CONTROL
         L     R14,AJOL            RESET # LEFT ON PAGE TO LIMIT
         SR    R15,R12             # PAGES LEFT = # PAGES LEFT -1
         ST    R15,AJOPREM         STORE UPDATED PAGES REMAINING
         BM    XXIOVERP            PAGE COUNT EXCEEDED-SHOW OVERFLOW
XXIOPSTL ST    R14,AJOLREM         STORE BACK COMPLETED LINES LEFT
XXNPAGEC EQU   *                   BRANCH HERE IF NO PAGE CONTROL ON
.XXNPAG2 ANOP
         SPACE 1
         LR    R2,R0               MOVE @ DATA AREA OVER WHERE SAFE
         AIF   (&$ASMLVL).XXOSREC  SKIP IF UNDER OS GENERATION
         L     R4,8(R1)            @ OF DTF CCW (CONTAINS LRECL-1)
         LH    R4,6(R4)            ORIGINAL DTF LRECL FIELD - 1
         LA    R4,1(R4)            +1 => ORIGINAL DTF LRECL
         PUT   (1)                 DO DOS PUT, WITH IOREG AS SPECIFIED
*        WHEN DOS ISSUES A PUT, R5 IS USED AS THE IOREG (SINCE R1 IS  *
*        ILLEGAL) TO POINT TO NEXT OUTPUT BUFFER.  GET @ INTO R1.     *
         LR    R1,R5               @ OF DOS DTF OUTPUT BUFFER
.XXOSREC AIF   (NOT &$ASMLVL).XXDSREC  SKIP IF UNDER DOS GENERATION
         USING IHADCB,R1           USING FOR DCB DUMMY SECTION
         LH    R4,DCBLRECL         GET LRECL FIELD FROM DCB
         DROP  R1                  KILL USING
         PUT   (1)                 DO PUT LOCATE
.XXDSREC ANOP
*              NEXT 3 STMTS GUARD AGAINST I/O OF LENGTH > REAL LENGTH.
         CLR   R3,R4               IS I/O <= LRECL (CLR RATHER THAN CR)
         BNH   *+6                 YES, GOOD PERSON, SKIP OVER
         LR    R3,R4               NO, BAD PERSON, USE LRECL
         SR    R3,R12              DECREMENT LENGTH TO L-1
         BM    XXIOPUTA            SKIP IF 0 LENGTH
         STC   R3,*+5              STORE LENGTH-1 FOR MOVE
         MVC   0($CHN,R1),0(R2)    MOVE DATA OVER
XXIOPUTA SR    R4,R12              DECREMENT REG -LRECL FIELD
         AIF   (NOT &$PAGE).XXNPAG4         SKIP IF NO PAGE CONTROL
         MVC   0(1,R1),AJIOWRKB    PUT IN POSSIBLY-CHANGED CAR CON BYTE
.XXNPAG4 ANOP
         AR    R1,R3               GET @-1 OF 1ST BYTE FOR BLANK PAD
         SR    R4,R3               GET # BLANKS REQUIRED FOR PAD
         BZ    XXIOPUTC            SKIP IF NO BLANK PAD
         SR    R4,R12              DECREMENT TO L-1 FOR PAD
         STC   R4,*+5              STORE L-1 INTO MOVE
         MVC   1($CHN,R1),AJOBLANK BLANK PAD AT END OF RECORD
XXIOPUTC EQU   *                   EXIT HERE FOR NORMAL RETURN
         SPACE 1
* * * * * COMMON EXIT CODE FOR SORC,READ,PNCH,PRNT                    *
*        THIS SECTION MUST IMMEDIATELY FOLLOW XXIOPUT SECTION.        *
*        XXIORETA SETS CONDITION CODE TO 1, SHOWING EITHER END-FILE   *
*        ON INPUT DEVICE, OR RECORD OVERFLOW ON OUTPUT DEVICE.        *
*        XXIORETB SETS CC = 0 TO SHOW NO SPECIAL CONDITION.           *
XXIORETB SR    R0,R0               SET CC TO 0
XXIORETC LM    R11,R5,XXIOSAVT     RELOAD CHANGED REGS
         B     XIORETRN            RETURN APPROPRIATELY
XXIOVERP OI    AJOMODE,AJOSRECX    SHOW PAGES/RECORDS EXCEEDED
XXIORETA OI    *+1,1               SET CC TO 1
         B     XXIORETC            GO TO RELOAD AND RETURN
         AIF   (&$DISKU EQ 0).XNODISK  SKIP DISK UTILITY WHEN NODISK
         USING AVWXTABL,R7         NOTE MAIN TABLE USING
         USING XIOBLOCK,R14
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> ENTRY:  XXXXDKOP    INITIALIZES FOR DISK UTILITY RUN             *
*              ALL XXXXDK ENTRIES BY RICHARD FORD, PAUL WEISSER.      *
*        XXXXDKOP IS CALLED FROM UTINT1 IF THE DISK UTILITY OPTION    *
*        IS ENABLED.  IT PERFORMS A STANDARD FORM OPEN ON THE DISK    *
*        UTILITY DCB,  INITIALIZES ANY VARIABLES USED BY THE DISK     *
*        UTILITY ROUTINES. XXXXDKOP ALSO COMPLETES THE DECB'S CREATED *
*        FOR BUFFER POOL MANAGEMENT BY FILLING IN THE RESPECTIVE      *
*        BUFFER ADDRESS. IN BATCH MODE XXXXDKOP RESETS THE DISK DATA  *
*        SET WITH A POINT MACRO INSTRUCTION.                          *
*                                                                     *
*                                                                     *
*        REGISTER ASSIGNMENTS                                         *
*              R13-> SAVE AREA POINTER                                *
*              R14-> XIOBLOCK POINTER REGISTER                        *
*              R15-> TEMP. BASE REGISTER                              *
*              R0 -> HOLDS LOW END ROINTER TO BUFFER AREA             *
*              R1 -> WORK REGISTER                                    *
*              R3 -> HOLDS NUMBER OF BUFFERS FOR LOOP CONTROL         *
*              R7 -> BASE REGISTER FOR AVWXTABL                       *
*                                                                     *
*        USES MACROS: POINT (OS), POINTS (DOS)                        *
*        USES DSECTS: AVWXTABL, XXIOBLOCK                             *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         USING XXXXDKOP,R15        NOTE TEMPORARY USING
XXXXDKOP STM   R11,R8,XXIOSAVT     SAVE REGISTERS IN LOCAL AREA
         LM    R11,R13,XXIOAJOB    LOAD BASE REGISTERS AND CONSTANT 1
         USING XXIOSAVE,R13        NOTE MAIN USING
         DROP  R15                 KILL R15
         L     R7,AJOVWXPT         GET ADDRESS OF MAIN TABLE
         NI    AJIODSK,255-AJIOEOF CLEAR EOF FLAG FOR BATCH RUN
         LA    R8,4+XXDKOFFL       GET OFFSET INTO BUFFER IN R8
         TM    XXDKUDCB+XXDKOPEN,XXMASK     IS DISK DCB/DTF OPEN
         BO    XXOPNPT             IF SO, GO ISSUE POINT MACRO
         AIF   (NOT &$ASMLVL).XXDR01  SKIP IF DOS GENERATION
         XC    XXDKBLKS(2),XXDKBLKS    CLEAR BLKSIZE FOR JCL
.XXDR01  LA    R2,AJIODSK          GET ADDRESS OF CONTROL BYTE
         AIF   (&$ASMLVL).XXDR1    SKIP IF OS GENERATION
         LA    R1,XXDKUDCB         GET ADDR OF DTF FOR OPEN
         AGO   .XXDR2
.XXDR1   LA    R3,XXIODSKU         R3 <-- ADDR OF REMOTE CLOSE WORD
.XXDR2   BAL   R4,XXIOPENO         OPEN DCB/DTF
         BM    XXEXIT              DID NOT OPEN---DISASTER
         OI    AJIODSK,AJIOPEN     SHOW DCB OPEN
XXOPNPT  L     R0,AVADDHIH         GET CURRENT HIGH CORE POINTER
         S     R0,XXDKLN           GET SPACE FOR FIRST BUFFER
         SR    R0,R8               BUMP PAST LENGTH USED WORD
         AIF   (&$BUFNO EQ 1).XXDKOPC  SKIP IF ONLY ONE BUFFER
         LA    R3,&$BUFNO-1        GET # OF BUFFERS - 1 FOR LOOP
.XXDKOPC ANOP
         LA    R1,XXDECB+4         GET ADDR OF 1ST DECB
         ST    R1,AVDECB           PUT ADDR OF DECB IN BCB
         LR    R1,R0               DUPLICATE BUFFER ADDR
         AR    R1,R8               BUMP PAST LENGTH USED WORD
         STM   R0,R1,AVBUFF@       INITIALIZE AVBCB
         A     R1,XXDKLN           COMPUTE ENDING BUFFER @
         ST    R1,AVBUFEND         PUT VALUE IN BCB
         AIF   (&$BUFNO EQ 1).XXDKOPA  SKIP IF ONLY ONE BUFFER
         L     R1,XXDECB           GET LINK IN R1
         ST    R1,AVDECBNX         PUT THIS IN BCB
.XXDKOPA ANOP
         LA    R1,XXDECB           GET DECB BLOCK ADDRESS
         ST    R0,XXDECBE(R1)      STORE 1ST BUFF @ IN DECB 1
         AIF   (&$BUFNO EQ 1 ).XXDKOPB  SKIP IF ONLY 1 BUFFER
         A     R8,XXDKLN           GET FULL BUFF LENGTH IN R8
         SR    R0,R8               GET NEXT BUFF @
         L     R1,0(R1)            GET LINK TO NEXT DECB
         ST    R0,XXDECBE(R1)      STORE NEW BUFF @ AT NEW DECB
         BCT   R3,*-10             LOOP FOR ALL DECBS
.XXDKOPB ANOP
         ST    R0,AVADDHIH         STORE UPDATED LOW END POINTER
         XDKPT XXDKUDCB,XXXPOINT   REPOSITION THE DISK
         SR    R2,R2               CLEAR R2 TO INITIALIZE COUNT
         B     XXXXDKRT            RETURN TO CALLER
XXEXIT   XI    AVTAGS1,AJODISKU    CANCEL DISK OPTION
         OI    *+1,1               SET CC TO MINUS TO FLAG UTINIT1
         B     XXXDKRTB            RETURN
         SPACE 2
XXDKEOF  EQU   *                   EOF EXIT ( FUTURE USE )
XXDKSYND OI    AJIODSK,AJIOEOF+AJIOSYND MARK END-FILE, ALSO SYNAD
         B     XXXDKRTB            RETURN
         SPACE 2
         AIF   (NOT &$ASMLVL).XXEX1    SKIP IF OS GENERATION
*              XXDKUDCB DCB EXIT - USE BLKSIZE FROM JCL IF GIVEN, ELSE
*              USE DEFAULT &$BLEN.
*              THIS CODE ONLY USEFUL IN OS/360 SYSTEM.
         USING XXDKEXCD,R15        LOCAL USING
         USING IHADCB,R1           @ DCB, SUPPLIED BY OPEN
XXDKEXCD LH    R0,DCBBLKSI         GET BLKSIZE FROM THE DCB
         SRA   R0,2                DIVIDE BY 4, TEST FOR ZERO
         SLL   R0,2                ALIGN TO FULLWORD MULTIPLE
         BNZ   *+8                 SKIP IF BLKSIZE FROM JCL
         LH    R0,=AL2(&$BLEN)     USE DEFAULT BUFFER LENGTH INSTEAD
         STH   R0,DCBBLKSI         STORE ACTUAL BLKSIZE TO BE USED
         SH    R0,=H'4'            WANT BLKSIZE-4 FOR LATER USE
         ST    R0,XXDKLN           SAVE IT WHERE EXPECTED
         BR    R14                 RETURN TO OPEN EXECUTOR
         DROP  R1,R15              REMOVE DCB, LOCAL USINGS
.XXEX1   ANOP
         TITLE 'DISK UTILITY READ'
         USING XXXXDKRD,REP        NOTE TEMPORARY USING
         USING XIOBLOCK,R14        FORMAT FOR CONTROL BLOCK
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*-->ENTRY XXXXDKRD   RETURN A SET OF RECORD BLOCKS TO UTGET2          *
*        XXXXDKRD IS CALLED BY UTGET2 WHEN IT HAS COMPLETED           *
*        PROCESSING A SET OF RECORD BLOCKS. XXXXDKRD RETURNS THE      *
*        ADDRESS OF THE NEXT BUFFER TO BE PROCESSD VIA THE BUFFER     *
*        CONTROL BLOCK AND RE-FILLS THE BUFFER WHICH WAS JUST         *
*        PROCESSED. WHEN ALL BLOCKS HAVE BEEN READ, XXXXDKRD CON-     *
*        TINUES TO ACCEPT CALLS UNTIL ALL BUFFERS HAVE BEEN           *
*        PROCESSED, AT WHICH TIME AN END-OF-FILE INDICATION           *
*        (CC=1) IS RETURNED.                                          *
*                                                                     *
*        REGISTER ASSIGNMENTS                                         *
*              R13-> BASE REGISTER AND SAVE AREA POINTER              *
*              R14-> XIOBLOCK POINTER REGISTER                        *
*              R15-> TEMP. BASE REGISTER                              *
*              R2 -> WORK REGISTER FOR COUNTER                        *
*              R3 -> DECB POINTER                                     *
*              R4 -> BUFFER POINTER                                   *
*                                                                     *
*        USES MACROS: READ, CHECK                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
XXXXDKRD STM   R11,R8,XXIOSAVT     SAVE REGISTERS IN LOCAL AREA
         LM    R11,R13,XXIOAJOB    LOAD BASE REGISTERS AND CONSTANT 1
         USING XXIOSAVE,R13        GLOBAL USING
         DROP  REP                 DROP R15
         L     R7,AJOVWXPT         GET ADDRESS OF MAIN TABLE
         LM    R3,R4,AVBCB         GET BCB INFO
         TM    AJIODSK,AJIOEOF     TEST IF LAST BLOCK READ
         AIF   (&$BUFNO NE 1).XXDKRDA   SKIP IF MORE THAN 1 BUFFER
         BO    XXCCSET             BRANCH TO SET CONDITION CODE
.XXDKRDA ANOP
         LH    R2,XXBLKCNT         SET R2 TO COUNTER VALUE
         BCT   R2,XXDKNZ           IF COUNT ^=0 TAKE BRANCH
         AIF   (&$BUFNO EQ 1).XXDKRDB   SKIP IF ONLY ONE BUFFER
         SPACE 2
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*        LAST REAL READ HAS BEEN PERFORMED---RESET COUNTER TO         *
*        EMPTY ALL BUFFERS; SET FLAG TO SHOW END-OF-FILE              *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         BO    XXCCSET             IF LAST BLK PASSED, SET CC
.XXDKRDB ANOP
         OI    AJIODSK,AJIOEOF     SET END-OF-FILE FLAG
         AIF   (&$BUFNO EQ 1).XXDKRDC   SKIP IF ONLY ONE BUFFER
         LA    R2,&$BUFNO          GET COUNT OF BUFFERS
         B     XXDKREAD            GO AND READ LAST BLOCK
         SPACE 2
.XXDKRDC ANOP
XXDKNZ   EQU   *
         AIF   (&$BUFNO EQ 1).XXDKRDE   SKIP IF ONLY ONE BUFFER
         BO    XXDKNM               IF END FLAG SET, SKIP READ
.XXDKRDE ANOP
XXDKREAD XDKCHK    (R3),XXDKUDCB,DOS   CHECK BEFORE GIVING OUT BLOCK
         XDKRD (R3),XXDKUDCB,(R4)  READ A BLOCK
         AIF   (&$BUFNO EQ 1).XXRDD    SKIP IF ONLY 1 BUFFER
XXDKNM   BAL   R14,XXFIXUP         GO UPDATE POINTERS
.XXRDD   AIF   (&$ASMLVL).XXRDD1       SKIP IF OS GEN
         TM    AJIODSK,AJIOEOF     IF EOF IS SET,
         BZ    XXXXDKRT            DO NOT CHECK LAST BLOCK
.XXRDD1  XDKCHK    (R3),XXDKUDCB   CHECK BEFORE GIVING OUT BLOCK
         SR    R0,R0               SET CC TO NOT NEGATIVE
         B     XXXXDKRT            RETURN TO CALLER
         SPACE 5
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*        LAST BLOCK HAS ALREADY BEEN PASSED--- SET CC & RETURN        *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
XXCCSET  OI    *+1,1               SET CC TO MINUS
         B     XXXDKRTB            RETURN TO CALLER
         TITLE 'END PASS1 INITIALIZE FOR PASS2'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> ENTRY: XXXXDKE1    COMPLETE PASS1 PROCESSING, SET UP FOR PASS 2  *
*        XXXXDKE1 IS CALLED FROM UTEND1.  XXXXDKE1 WRITES LAST BUFFER *
*        OR IF NO PREVIOUS WRITES WERE PERFORMED,  PASSES UTGET2 THE  *
*        INITIAL ADDRESS OF THE ONLY BUFFER USED.  IF AT LEAST 1      *
*        WRITE TO DISK WAS DONE,  XXXXDKE1 POINTS THE DISK TO START   *
*        AND READS N-1 BUFFERS FROM THE DISK AND SETS UP FOR          *
*        PASS 2 OF THE ASSIST ASSEMBLER.                              *
*                                                                     *
*        REGISTER ASSIGNMENTS                                         *
*              R14-> XIOBLOCK POINTER REGISTER                        *
*              R15-> TEMP. BASE REGISTER                              *
*              R2 -> COUNTER WORK REGISTER                            *
*              R3 -> DECB POINTER                                     *
*              R4 -> BUFFER POINTER                                   *
*              R8 -> WORK REGISTER                                    *
*                                                                     *
*        USES DSECTS: XXIOBLOCK, AVWXTABL                             *
*        USES MACROS: READ, WRITE, POINT, CHECK                       *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         USING XXXXDKE1,REP        TEMPORARY USING
XXXXDKE1 STM   R11,R8,XXIOSAVT     SAVE REGISTERS IN LOCAL AREA
         LM    R11,R13,XXIOAJOB    LOAD BASE REGISTERS AND CONSTANT 1
         USING XXIOSAVE,R13        NOTE GLOBAL USING
         DROP  REP                 DROP TEMPORARY USING
         L     R7,AJOVWXPT         GET ADDRESS OF MAIN TABLE
         LH    R2,XXBLKCNT         GET # OF BLOCKS TO BE READ
         AIF   (&$BUFNO EQ 1).XXDKEA   SKIP IF JUST 1 BUFFER
         LTR   R2,R2               IS IT 0?
         BNP   XXONEBLK            TAKE BRANCH TO ONE BLK WRITTEN
         L     R6,AVDECBLT         GET POINTER TO LAST DECB
         XDKCHK  (R6),XXDKUDCB     ISSUE CHECK
.XXDKEA  ANOP
XXONEBLK LM    R3,R5,AVBCB         OBTAIN NEEDED VALUES
         SR    R5,R4               GET BUFFER USED LENGTH
         ST    R5,XXDKOFFL(,R4)    STORE LENGTH IN BUFFER
         XDKWT (R3),XXDKUDCB,(R4)  WRITE THE BLOCK
         XDKCHK  (R3),XXDKUDCB     CHECK COMPLETION OF LAST WRITE
         XDKPT XXDKUDCB,XXXPOINT   POINT TO THE FIRST RECORD
         AIF   (&$BUFNO NE 1).XXDK1    SKIP IF MORE THAN 1 BUFFER
         ST    R4,AVBUFINC         RESET LENGTH WORD
         AR    R2,R12              INCREMENT COUNTER
         B     XXXXDKRT            GO RETURN
.XXDK1   AIF   (&$BUFNO EQ 1).XXDEC    SKIP IF 1 BUFFER
         AR    R2,R12              INCREMENT THE COUNTER
         LA    R8,&$BUFNO-1        GET # OF BUFFERS LESS 1
         LR    R6,R12              INITIALIZE TO GET ALL INFO
XXEPRD1  XDKRD (R3),XXDKUDCB,(R4)  READ FIRST BLOCK
         AR    R6,R12              INCREMENT READ COUNTER
         SR    R2,R12              DECREMENT BLOCK COUNTER
         BZ    XXFEWER             IF ZERO GO TO XXFEWER
         BAL   R14,XXFIXUP         ELSE MOVE POINTERS TO NEXT BLOCK
         BCT   R8,XXEPRD1          LOOP TO CONTINUE READING
         B     XXXXDKRT            RETURN TO CALLER
XXFEWER  OI    AJIODSK,AJIOEOF     SET LAST-BLOCK-READ FLAG
         STH    R6,XXBLKCNT        STORE # OF FULL BUFFERS
         BAL   R14,XXFIXUP         BRANCH TO UPDATE POINTERS
         BCT   R8,XXFIXUP          LOOP TO POSITION DECB POINTERS
         B     XXXDKRTB            RETURN TO CALLER
.XXDEC   ANOP
         TITLE 'DISK UTILITY WRITE'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> ENTRY: XXXXDKWT     WRITE A FULL BUFFER TO DISK                  *
*        XXXXDKWT IS CALLED FROM UTPUT1 WHEN PASS1 HAS FILLED A       *
*        BUFFER.  XXXXDKWT WRITES THE BUFFER TO DISK AND UPDATES      *
*        THE BUFFER MANAGEMENT TABLE WHICH RETURNS THE ADDRESS OF     *
*        THE NEXT AVAILABLE BUFFER TO UTPUT1.                         *
*                                                                     *
*        REGISTER ASSIGNMENTS                                         *
*              R13-> BASE REGISTER AND SAVE AREA POINTER              *
*              R14-> XIOBLOCK POINTER REGISTER                        *
*              R15-> TEMP. BASE REGISTER                              *
*              R3 -> POINTER TO CURRENT DECB                          *
*              R4 -> BUFFER POINTER                                   *
*              R5 -> BUFFER LENGTH USED ACCUMULATOR                   *
*              R6 -> POINTER TO OLD DECB                              *
*                                                                     *
*        USES DSECTS: AVWXTABL, XXIOBLOCK                             *
*        USES MACROS: WRITE, CHECK                                    *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         USING XXXXDKWT,REP        NOTE TEMP USING
XXXXDKWT STM   R11,R8,XXIOSAVT     SAVE REGISTERS IN LOCAL AREA
         LM    R11,R13,XXIOAJOB    LOAD BASE REGISTERS AND CONSTANT 1
         USING XXIOSAVE,R13        NOTE GLOBAL USING
         DROP  REP                 KILL TEMP USING
         L     R7,AJOVWXPT         GET ADDRESS OF MAIN TABLE
         LH     R2,XXBLKCNT        GET CURRENT COUNTER VALUE
         AIF   (&$BUFNO EQ 1).XXWTA    SKIP IF ONLY 1 BUFFER
         LTR   R2,R2               IS THIS FIRST CALL TO THIS ENTRY
         BZ    XXXX1ST             IF IT IS, SKIP CHECK
         L     R6,AVDECBLT         GET POINTER TO LAST DECB
         XDKCHK  (R6),XXDKUDCB     ISSUE CHECK
.XXWTA   ANOP
XXXX1ST  LM    R3,R5,AVBCB         OBTAIN NEEDED VALUES
         SR    R5,R4               SUBTRACT TO GET LENGTH OF INFO
         ST    R5,XXDKOFFL(,R4)    STORE LENGTH IN BUFFER
         XDKWT (R3),XXDKUDCB,(R4)  WRITE THE RECORD(BLOCK)
         AIF   (&$BUFNO NE 1).XXWTB   SKIP IF > 1 BUFFER
         XDKCHK  (R3),XXDKUDCB     CHECK LAST WRITE
.XXWTB   ANOP
         AR    R2,R12              INCREMENT COUNTER
         AIF   (&$BUFNO EQ 1).XXWTC    SKIP IF ONLY 1 BUFFER
         BAL   R14,XXFIXUP         GO TO FIXUP ROUTINE
.XXWTC   AIF   (&$BUFNO NE 1).XXWTD    SKIP IF BUFNO > 1
         LA    R4,4(R4)            INCREMENT POINTER PAST LENGTH WORD
         ST    R4,AVBUFINC         STORE AVBUFINC BACK INTO BCB
.XXWTD   ANOP
         SPACE 2
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*        COMMON RETURN CODE FOR DISK ROUTINES                         *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
XXXXDKRT STH   R2,XXBLKCNT         STORE UPDATED COUNTER
XXXDKRTB LM    R11,R8,XXIOSAVT     RESTORE REGISTERS
         B     XIORETRN            RETURN TO CALLER
         AIF   (&$BUFNO EQ 1).XXFXA    SKIP WHOLE SECTION IF 1 BUFFER
         TITLE 'DISK UTILITY BCB UPDATE ROUTINE'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> INSUB: XXFIXUP     UPDATE BCB POINTERS TO NEXT BUFFER            *
*                                                                     *
*        XXFIXUP UPDATES THE POINTERS IN THE BCB, MOVING THE NEXT     *
*        I/O OPERATION TO THE NEXT BUFFER.                            *
*                                                                     *
*        ENTRY CONDITIONS:   R3-> ADDRESS OF CURRENT DECB.            *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
XXFIXUP  ST    R3,AVDECBLT         STORE ADDR FOR BACKWARD REFERENC
         L     R3,AVDECBNX         LINK TO NEXT DECB BLOCK
         MVC   AVDECBNX(4),0(R3)   MOVE LINK TO AVBCB
         LA    R3,4(R3)            GET DECB @ FOR NEXT BUFFER
         L     R4,XXDECBIN(R3)     GET BUFFER ADDRESS
         LA    R5,4+XXDKOFFL(R4)   BUMP PAST LENGTH USED WORD
         STM   R3,R5,AVDECB        FILL PART OF THE BCB
         A     R5,XXDKLN           GET BUFFER ENDING ADDRESS
         ST    R5,AVBUFEND         COMPLETE BCB BLOCK
         BR    R14                 RETURN TO CALLER
.XXFXA   ANOP
XXDKLN   DC    A(&$BLEN-4)         BUFFER LENGTH FOR HIGH END POINT
XXXPOINT DC    X'00000100'         POINT CONTROL WORD
XXBLKCNT DS    H                   COUNTER HALF-WORD
XXDECB   XXDKDECB  &$BUFNO         DEFINE DECB TABLE
         DROP  R7                  DELETE AVWXTABL USING
.XNODISK ANOP
         EJECT
         AIF   (NOT (&$PUNCH OR &$DATARD OR (&$DISKU NE 0) OR &$MACSLB)#
               ).XXNRP4            SKIP IF NO SPECIAL OPEN NEEDED
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> INSUB: XXIOPENO   OPEN OPTIONAL DATA SET, FIX FLAGS              *
*        XXIOPENO IS CALLED FROM ENTRIES XXXXREAD OR XXXXPNCH TO      *
*        OPEN A DCB, FLAG ITS AJIO-- BYTE AJIODFLT IF OPEN FAILS,     *
*        OR AJIOPEN IF IT GOES.  IF OPEN OK, THE OPEN/CLOSE PARM WORD *
*        ADDED TO THE FRONT OF CURRENT LIST BEING BUILT FOR CLOSING.  *
*        UNDER DOS GENERATIONS, NO OPEN/CLOSE PARM WORD IS PRESENT,   *
*        SO JUST OPEN AND SET RETURN CODE.                            *
*        ENTRY CONDITIONS                                             *
*   R1 = @ OF DCB (XXREDCB, XXPNDCB) UNDER DOS GENERATIONS ONLY       *
*   R2 = @ AJIO-- CONTROL BYTE (AJIORE, AJIOPN)                       *
*   R3 = @ OPEN/CLOSE PARM WORD (XXIOCRE, XXIOCPN)                    *
*   R4 = RETURN @ TO CALLING SECTION OF CODE                          *
*        EXIT CONDITIONS                                              *
*   R1 = @ OF DCB (XXREDCB, XXPNDCB)                                  *
*   R2 = @ AJIO-- FLAG BYTE (SAME AS ON ENTRY)                        *
*   R0,R14 ARE PRESERVED FROM EFFECTS OF OPEN                         *
*   CC = 0 ==> OPEN WENT.  AJIO-- FLAG FLAGGED WITH AJIOPEN.          *
*   CC = 1 ==> OPEN FAILED.  AJIO-- BYTE FLAGGED WITH AJIODFLT.       *
*   XXIOCPTR=XXIOCPTR-4 IF OPEN OK, OPEN/CLOSE WORD MOVE ALSO.        *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         AIF   (&$ASMLVL).XXNIHA   SKIP IF UNDER OS GENERATION
XXIOPENO OPEN  (1)                 OPEN OPTIONAL DATA SET
         LM    R14,R0,XXIOSAVT+12  RELOAD MESSED UP REGISTERS
         TM    15(R1),X'20'        DID THE OPEN GO
         BZ    XXIOPENQ            YES, OPEN WENT
.XXNIHA  AIF   (NOT &$ASMLVL).XXYIHA   SKIP IF UNDER DOS GENERATION
XXIOPENO LR    R1,R3               MOVE PTR TO OPEN/CLOSE WORD OVER
         OPEN  MF=(E,(1))          DO REMOTE OPEN
         LM    R14,R0,XXIOSAVT+12  RELOAD MESSED-UP REGISTERS
         L     R1,0(R3)            GET @ DCB FROM OPEN/CLOSE PARM
         USING IHADCB,R1           NOTE DCB DSECT USING
         TM    DCBOFLGS,X'10'      DID THE OPEN GO?
         BO    XXIOPENQ            YES, OPEN WENT
         DROP  R1                  KILL USING
.XXYIHA  ANOP
         SPACE 1
         OI    0(R2),AJIODFLT      OPEN FAILED, USE DEFAULT DATA SET
         BR    R4                  RETURN TO CALLER, CC=1 AT MOMENT
         SPACE 1
*        OPEN SUCCEEDED. MARK DATA SET OPEN. ADD ITS OPEN/CLOSE PARM  *
*        WORD TO FRONT OF LIST SO IT WILL BE CLOSED LATER (OS ONLY).  *
XXIOPENQ OI    0(R2),AJIOPEN       SHOW OPEN OK
         AIF   (NOT &$ASMLVL).XXNPRMW  NO DOS PARM WORD LIST
         L     R15,XXIOCPTR        GET CURRENT PTR TO OPEN/CLOSE LIST
         SH    R15,=H'4'           SUBTRACT TO GET NEXT POSITION
         ST    R15,XXIOCPTR        STORE UPDATED VALUE
         MVC   0(4,R15),0(R3)      MOVE NEW OPEN/CLOSE PARM IN
         NI    0(R15),X'7F'        REMOVE LEADING BIT, SINCE NOT LAST
.XXNPRMW ANOP
         SR    R15,R15             SET CC=0 TO SHOW SUCCESSFUL
         BR    R4                  RETURN TO CALLING CODE
         SPACE 1
.XXNRP4  AIF   (NOT &$ASMLVL).XXNPN2   NO LIST FORMS UNDER DOS
XXIOCPTR DS    A                   @ 1ST VALID OPEN/CLOSE PARM IN LIST
*              OPEN/CLOSE PARM VALUES.  ORDER REQUIRED NEXT 2 CARDS.
         DS    2F                  FOR RE, PN OPEN/CLOSE PARMS
         AIF   (&$DISKU LT 1).XXNDKOP
         DS    F                   ROOM FOR DISK UTILITY PARM WORD
.XXNDKOP AIF   (NOT &$MACSLB).XXNMCLB  SKIP WORD IF NOT NEEDED
         DS    A                   SPACE FOR ANOTHER PTR WORD
.XXNMCLB ANOP
XXIOCSP  OPEN  (XXSODCB,INPUT,XXPRDCB,OUTPUT),MF=L    SET UP VALUES
         SPACE 1
         AIF   (NOT &$DATARD).XXNRE2        SKIP IF NO DATA RDR
XXIOCRE  OPEN  (XXREDCB,INPUT),MF=L         SET UP VALUE HERE
.XXNRE2  AIF   (NOT &$PUNCH).XXNPN2         SKIP IF NO REAL PUNCH
XXIOCPN  OPEN  (XXPNDCB,OUTPUT),MF=L        SET UP VALUE HERE
.XXNPN2  ANOP
         AIF   (&$DISKU EQ 0).XXNDOPN  SKIP IF NO DISK OPTION
         AIF   (NOT &$ASMLVL).XXNDOPN  SKIP IF OS GENERATION
XXIODSKU OPEN  (XXDKUDCB,(OUTIN)),MF=L
.XXNDOPN ANOP
         EJECT
         AIF   (NOT &$MACSLB).XXNMCOP
XXLIBCLS OPEN  (XXLIBDCB,INPUT),MF=L   LIST FORM FOR MACRO LIBRARY OPEN
         EJECT
         SPACE 10
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*-> ENTRY: XXXXLBOP                                                   *
*              XXXXLBOP INITIALIZES FOR A MACRO LIBRARY RUN.  XXXXLBOP*
*        IS CALLED BY MOCOMSYS IN MCON1.  IT OPENS THE SYSTEM LIBRARY *
*        DCB IF NECESSARY, ALLOCATES BUFFER SPACE IN HIGH CORE, AND   *
*        SETS SWITCH IN XXXXSORC SUCH THAT XXXXSORC PROVIDES INCARD   *
*        THE ADDRESS OF A CARD IMAGE FROM THE SYSTEM LIBRARY BUFFER   *
*        INSTEAD OF FROM THE NORMAL SYSIN DATA SET.  ALSO SETS THE    *
*        ADDRESS INTO THE GLOBAL TABLE NEEDED BY THE SUPPORTING       *
*        ROUTINES.                                                    *
*                                                                     *
*        REGISTER ASSIGNMENTS:                                        *
*              PSEUDO-STANDARD OS LINKAGE (SAVING ONLY NEEDED REG)    *
*              R1=> BASE FOR IHADCB DSECT                             *
*              R4=> BASE FOR XLBDSECT DSECT                           *
*              R7=> AVWXTABL BASE REGISTER                            *
*              R13=> SAVE AREA POINTER AND MAIN BASE REGISTER         *
*              R15=> TEMP BASE REGISTER                               *
*                                                                     *
*        USES MACROS:                                                 *
*              $ALLOCH                                                *
*                                                                     *
*        USES DSECTS:                                                 *
*              AVWXTABL, XLBDSECT, IHADCB                             *
*                                                                     *
*        EXIT CONDITIONS:                                             *
*              CC = 1 (MINUS) IF OPEN DID NOT GO                      *
*              AND ZERO (0) IF OPEN WENT                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 5
         USING AVWXTABL,R7         NOTE MAIN TABLE USING
         USING XXXXLBOP,R15        TEMP BASE REGISTER
XXXXLBOP STM   R11,R8,XXLBSAVT     SAVE REGISTERS TO BE CHANGED
         LM    R11,R13,XXIOAJOB    LOAD NEEDED VALUES
         USING XXIOSAVE,R13        NOTE MAIN USING
         DROP  R15                 CLEAN UP USINGS
         L     R7,AJOVWXPT         GET MAIN TABLE ADDRESS
         MVC   AVLIBBUF,AWZEROS    ZERO THE GLOBAL WORD
         TM    XXLIBDCB+48,X'10'   IS THE LIBRARY DCB ALREADY OPEN
         BO    XXLBALOP            YES-- GO TO ALREADY OPEN
         LA    R2,XXLBFLG          R2 <-- ADDRESS OF CONTROL BYTE
         LA    R3,XXLIBCLS         R3 <-- DDDRESS OF REMOTE CLOSE WORD
         BAL   R4,XXIOPENO         GO DO OPEN
         BM    XXLBOVR             OPEN DID NOT GO -- HURT
         SPACE 2
*        OPEN WENT SO COMPLETE LIBRARY RUN SET UP
         SPACE 2
XXLBALOP LA    R1,XXLIBDCB         GET ADDRESS OF LIBRARY DCB
         USING IHADCB,R1           SET USING FOR DCB DSECT
         LH    R2,DCBBLKSI         GET BLOCK SIZE FROM THE DCB
         SPACE 2
*        ROUND UP TO A D-WORD MULTIPLE TO BE SURE
         SPACE 2
         LA    R2,7+XLBUFCNT(R2)   ADD 7 PLUS LENGTH OF CONTROL AREA
         SRL   R2,3                DIVIDE BY 8
         SLL   R2,3                MULTIPLY BY 8
         SPACE 2
*        GET THE SPACE FOR THE BUFFER AND CONTROL WORDS IN HIGH CORE
         SPACE 2
         USING XLBDSECT,R4         NOTE LIBRARY DSECT
         $ALLOCH R4,R2,XXLBOVR     GET THE SPACE IN HIGH CORE
         MVI   XXLBFLG,X'FF'       SET FLAG TO SHOW BUFFER ALLOCATED
         SPACE 2
*        INITIALIZE GLOBAL CONTROL WORD
         ST    R4,AVLIBBUF         STORE BUFFER AND CONTROL BLOCK
*                                  ADDRESS IN THE GLOBAL TABLE
         SPACE 2
*        INITIALIZE THE BUFFER CONTROL WORDS
         SPACE 2
         ST    R2,XLBUFLNG         STORE TOTAL LENGTH IN CONTROL WORD 1
         AR    R2,R4               GET START PLUS LENGTH IN R2
         ST    R2,XLBUFEND         STORE IN CONTROL WORD 2
         SR    R2,R4               REMOVE STARTING ADDRESS
         LA    R2,XLBUFCNT(R4)     GET REAL BUFFER START ADDRESS
         LR    R3,R2               DUPLICATE FOR MUTIPLE STORE
         STM   R2,R3,XLBUFSTR      STORE IN CONTROL WORDS 2 & 3
         DROP  R4,R1               CLEAN UP USINGS
         SPACE 2
*        SET XXXXSORC SWITCH TO ALWAYS BRANCH
         SPACE 2
         MVI   XXSWTCH+1,X'F0'     SET SWITCH TO BRANCH
         SPACE 2
         SR    R0,R0               MAKE CC NOT MINUS
XXLBOUTA LM    R11,R8,XXLBSAVT     RESTORE REGISTERS
         BR    R14                 RETURN TO CALLER
         SPACE 2
*        STORAGE OVERFLOW EXIT
         SPACE 2
XXLBOVR  OI    *+1,1               SET CC TO MINUS
         B     XXLBOUTA            RETURN
         DROP  R7,R13              CLEAN UP USINGS
         SPACE 5
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*-> ENTRY: XXXXFIND                                                   *
*              XXXXFIND DOES A D-TYPE FIND ON EACH MACRO THAT IS      *
*        REQUIRED BY THE USER PROGRAM AS DEFINED ON THE SYSLIB CARD.  *
*        CALLED FROM MOCOMSYS IN THE MCON1 CSECT.                     *
*                                                                     *
*        REGISTER ASSIGNMENTS:                                        *
*              R12 => AVWXTABL BASE REGISTER                          *
*              R13 => SAVE AREA  POINTER AND MAIN BASE REGISTER       *
*              R14 => DCB ADDRESS                                     *
*                                                                     *
*        ENTRY CONDITIONS:                                            *
*              MEMBER NAME IS IN AVMSYMBL                             *
*                                                                     *
*        EXIT CONDITIONS:                                             *
*              CC SET TO ZERO IF ALL WENT WELL                        *
*              CC SET TO MINUS IF NAME COULD NOT BE FOUND             *
*                                                                     *
*        USES MACROS:                                                 *
*              FIND                                                   *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 5
         USING AVWXTABL,R12        NOTE MAIN TABLE USING
         USING XXXXFIND,R15
XXXXFIND STM   R11,R1,XXLBSAVT     SAVE REGISTERS THAT MIGHT CHANGE
         L     R13,XXIOAJOB+8      GET BASE REGISTER SET UP
         USING XXIOSAVE,R13        NOTE MAIN USING
         DROP  R15                 CLEAN UP USING SITUATION
         SPACE 2
         MVC   XXFNDDW,AVMSYMBL    PUT NAME ON A D-WORD BOUNDRY
         SPACE 2
         FIND  XXLIBDCB,XXFNDDW,D  DO THE FIND
         LTR   R15,R15             TEST RETURN CODE FROM FIND ROUTINE
         BNZ   XXFNDERR            COULDNOT FIND NAME--SET UP BAD RTN
         SPACE 2
         SR    R0,R0               MAKE CC NOT MINUS
XXXXFDOT LM    R11,R1,XXLBSAVT     RESTORE REGISTERS
         BR    R14                 RETURN TO CALLER
         SPACE 2
XXFNDDW  DS    D                   D-WORD ALIGNED PLACE FOR MEMBER NAME
XXFNDERR OI    *+1,1               SET CC TO MINUS FOR RETURN
         B     XXXXFDOT            RETURN
         DROP  R12,R13             CLEAN UP USINGS
         SPACE 5
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*-> ENTRY: XXXXLBRD                                                   *
*                                                                     *
*              CALLED BY INCARD VIA XXXXSORC TO PROVIDE THE MACRO     *
*        PROCESSOR WITH DEBLOCKED RECORDS FROM THE SYSTEM MACRO       *
*        LIBRARIES.  FUNCTIONS AS AN INSUB TO ENTRY XXXXSORC.         *
*                                                                     *
*        REGISTER ASSIGNMENTS:                                        *
*              SAME AS XXXXSORC: EXCEPT R12 IS BASE FOR AVWXTABL      *
*                                                                     *
*        ENTRY CONDITIONS:                                            *
*              SAME AS XXXXSORC                                       *
*              ADDITIONALLY -- INCARDS DATA AREA COMES OVER IN        *
*              REGISTER R0 AND MUST BE PROTECTED FROM SYSTEM ACTIONS  *
*                                                                     *
*        USES DSECTS:                                                 *
*              XLBDSECT, IHADCB                                       *
*                                                                     *
*        USES MACROS:                                                 *
*              READ, CHECK                                            *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 5
         USING XXIOSAVE,R13        NOTE MAIN USING
         USING IHADCB,XXXLBDCB
XXXXLBRD STM   R6,R7,XXLBSAVT      SAVE SOME WORK REGISTERS
         L     R12,AJOVWXPT        GET AVWXTABL BASE ADDRESS
         USING AVWXTABL,R12        NOTE MAIN TABLE USING
         L     R3,AVLIBBUF         GET ADDRESS OF BUFFER SPACE
         USING XLBDSECT,R3         NOTE LIBRARY DSECT USING
         LR    R4,R0               MOVE DATA AREA ADDRESS OVER
         SPACE 2
XXXLBDCB EQU   R5                  HOLDS THE LIBRARY DCB ADDRESS
XXRECPT  EQU   R6                  HOLDS ADDRESS OF CARD IMAGE
XXBUFEND EQU   R7                  POINTER TO THE END OF THE BUFFER
         SPACE 2
         LM    XXRECPT,XXBUFEND,XLBUFSTR   GET CONTROL INFORMATION
         CR    XXRECPT,XXBUFEND    IS BUFFER EMPTY
         BNL   XXXLIBRD            YES--GO READ A NEW BUFFER FULL
         SPACE 2
XXLBRCPT MVC   0(80,R4),0(XXRECPT) MOVE CARD WHERE INCARD EXPECTS
         LA    XXRECPT,80(XXRECPT) INCREMENT TO NEW RECORD
         SPACE 2
*        SET UP FOR RETURN
         SPACE 2
         ST    XXRECPT,XLBUFSTR    SAVE UPDATED RECORD POINTER
XXLBRDRT LM    R6,R7,XXLBSAVT      RESTORE REGISTERS
         B     XXIORETB            RETURN TO CALLER (INCARD)
XXXLIBRD LA    XXXLBDCB,XXLIBDCB   GET DCB ADDRESS IN A REG
         LA    XXRECPT,XLIBBUF     GET AREA ADDRESS INTO XXRECPT REG
         READ  XXLBDECB,SF,(XXXLBDCB),(XXRECPT),'S'   READ A BLOCK
         CHECK XXLBDECB            CHECK FOR I/O COMPLETION
         SPACE 2
         LH    XXBUFEND,DCBBLKSI   GET BLOCKSIZE FROM DCB
         L     R2,XXLBDECB+16      GET IOB ADDRESS
         SH    XXBUFEND,14(R2)     GET RELATIVE END OF NEW BLOCK
         LA    XXBUFEND,XLBUFCNT(R3,XXBUFEND)  GET ABSOULUTE END OF NEW
*                                  BLOCK
         ST    XXBUFEND,XLBUFCED   SET CONTROL WORD 4, CURRENT END
         B     XXLBRCPT            GO TO DEBLOCK
XXMCEODD MVC   0(80,R4),AWBLANK    BLANK OUT AREA FOR CARD
         MVC   10(4,R4),=C'MEND'   PUT MEND CARD IMAGE THERE
         B     XXLBRDRT            RETURN VIA XXXXSORC, INCARD
         SPACE 5
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         DROP  R3,R5,R12,R13       CLEAN UP USINGS
*-> ENTRY: XXXXLBED                                                   *
*                                                                     *
*              CALLED 1 TIME BY THE MAIN PROGRAM MCON1 TO INSURE      *
*        THAT THE XXXXSORC SWITCH BRANCH IS SET FOR NORMAL PROCESSING.*
*        ALSO CALLED BY MOCOMSYS IN MCON1 TO DEALLOCATE THE BUFFER    *
*        AND CONTROL WORD SPACE AND TO RESET THE XXXXSORC SWITCH      *
*        BRANCH TO THE NORMAL CONDITION.                              *
*                                                                     *
*        REGISTER ASSIGNMENTS:                                        *
*              R2=> AVWXTABL BASE REGISTER                            *
*              R13 => SAVE AREA POINTER AND MAIN BASE REGISTER        *
*              R15 => TEMP BASE REGISTER                              *
*                                                                     *
*        USES DSECTS:                                                 *
*              XLBDSECT                                               *
*                                                                     *
*        USES MACROS:                                                 *
*              $DALLOCH                                               *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 5
         USING AVWXTABL,R2         NOTE TABLE USING
         USING XXXXLBED,R15        TEMP USING
XXXXLBED STM   R11,R2,XXLBSAVT     SAVE SOME WORK REGISTERS
         LM    R11,R13,XXIOAJOB    GET NEEDED VALUES
         L     R2,AJOVWXPT         GET BASE VALUE FOR MAIN TABLE
         USING XXIOSAVE,R13        NOTE MAIN USING
         DROP  R15                 CLEAN UP USING SITUATION
         TM    XXLBFLG,X'FF'       IS THERE A BUFFER AROUND?
         BZ    XXEDSET             NO -- DO NOT DE-ALLOCATE THE BUFFER
         SPACE 2
*        DEALLOCATE BUFFER SPACE IN HIGH FREEAREA
         SPACE 2
         L     R15,AVLIBBUF        GET ADDRESS OF BUFFER AREA
         USING XLBDSECT,R15        NOTE LIBRARY DSECT USING
         L     R15,XLBUFLNG        GET TOTAL LENGTH OF SPACE TO BE
*                                  FREED
         $DALLOCH R1,(R15)         DEALLOCATE THE AREA
         DROP  R15                 CLEAN UP USING SITUATION
         SPACE 2
*        SET XXXXSORC SWITCH BRANCH TO NORMAL NON-BRANCH
         SPACE 2
XXEDSET  MVI   XXLBFLG,X'00'       MARK BUFFER AS GONE
         MVI   XXSWTCH+1,X'00'     SET TO NEVER BRANCH IN XXXXSORC
         LM    R11,R2,XXLBSAVT     RESTORE REGISTERS
         BR    R14                 RETURN TO CALLER
         DROP  R2                  CLEAN UP USING SITUATION
         SPACE 2
XXLBSAVT DS    14F                 SPACE FOR TEMP STORAGE OF REGISTERS
XXLBFLG  DS    B                   DUMMY FLAG BYTE FOR REMOTE OPEN
         SPACE 5
.XXNMCOP ANOP
XXIOAJOB DS    A                   SPACE FOR @ AJOBCON BLOCK
         DC    A(1,XXIOSAVE)       FOR REGS R12-R13-FOLLOW XXIOAJOB
XXIOSAVT DS    14F                 SAVE AREA FOR I/O ROUTINES
         AIF   (NOT &$PAGE).XXNPAG8         SKIP IF NO PAGE CONTROL
*              LEGAL CARRIAGE CONTROL CHARACTERS.  ITEMS ARE THE
*              CHARACTER, AN OFFSET TO ITS REPLACEMENT CHARCATER
*              WORD IF IN MODE SINGL, AND DECREMENT FOR LINE COUNTER.
XXIOPGTA DS    0H                  ORIGIN OF TABLE, ALIGN
XXIOPB   EQU   *-XXIOPGTA          OFFSET FROM TABLE TO BLANK'S BLOCK
XXIOPGTB DC    C' ',AL1(XXIOPB),H'1'        SINGLE SPACE, SINGLE SPACE
XXIOPD   EQU   *-XXIOPGTA          OFFSET TO DOUBLE SPACE
         DC    C'0',AL1(XXIOPB),H'2'        DOUBLE SPACE,SINGLE SPACE
         DC    C'1',AL1(XXIOPD),H'32000'    NEW PAGE, DOUBLESPACE
         DC    C'-',AL1(XXIOPB),H'3'        TRIPLE SPACE,SINGLE SPACE
         DC    C'+',AL1(*-1-XXIOPGTA),H'0'  NO SPACE, NOSPACE
XXIOPGTZ EQU   *-4                 @ LAST ELEMENT IN TABLE
.XXNPAG8 ANOP
         LTORG
         SPACE 1
*              DCB'S FOR THE SOURCE AND DATA CARD READERS.
         AIF   (NOT &$ASMLVL).XXNPN4   SKIP IF UNDER DOS GENERATION
XXSODCB  DCB   DDNAME=&$IOUNIT(1),DSORG=PS,MACRF=GL,EODAD=XXIOEOF
         AIF   (NOT &$DATARD).XXNRE4        SKIP IF NO DATA RDR
XXREDCB  DCB   DDNAME=&$IOUNIT(2),DSORG=PS,MACRF=GL,EODAD=XXIOEOF
.XXNRE4  ANOP
         SPACE 1
*              DCB'S FOR THE LINE PRINTER AND CARD PUNCH.
XXPRDCB  DCB   DDNAME=&$IOUNIT(3),DSORG=PS,MACRF=PL,                   #
               RECFM=FA,LRECL=133,BLKSIZE=133,BUFNO=1
         AIF   (NOT &$PUNCH).XXNPN4        SKIP IF NO REAL PUNCH EXISTS
XXPNDCB  DCB   DDNAME=&$IOUNIT(4),DSORG=PS,MACRF=PL,                   #
               RECFM=F,LRECL=80,BLKSIZE=80,BUFNO=1
.XXNPN4  ANOP
         AIF   (&$ASMLVL).XXNPN8   SKIP IF UNDER OS GENERATION
XXSODCB  DTFCD DEVADDR=&$IOUNIT(1),EOFADDR=XXIOEOF,IOREG=(5),          X
               IOAREA1=XXIOLOCP,IOAREA2=XXIOLOCS,TYPEFLE=INPUT
XXIOLOCP DC    80C' '              DOS IOAREA1
XXIOLOCS DC    80C' '              DOS IOAREA2
         AIF   (NOT &$DATARD).XXNRE8   SKIP IF NO DATA CARD READER
XXREDCB  DTFCD DEVADDR=&$IOUNIT(2),EOFADDR=XXIOEOF,IOREG=(5),          X
               IOAREA1=XXIOLOCP,IOAREA2=XXIOLOCS,TYPEFLE=INPUT
.XXNRE8  ANOP
         SPACE 1
*        DCB'S FOR THE LINE PRINTER AND CARD PUNCH                    *
XXPRDCB  DTFPR DEVADDR=&$IOUNIT(3),BLKSIZE=133,IOREG=(5),CTLCHR=ASA,   X
               IOAREA1=XXIOFILP,IOAREA2=XXIOFILS
XXIOFILP DC    133C' '             PRINTER IOAREA1
XXIOFILS DC    133C' '             PRINTER IOAREA2
         AIF   (NOT &$PUNCH).XXNPN8    SKIP IF NO REAL CARD PUNCH
XXPNDCB  DTFCD DEVADDR=&$IOUNIT(4),CRDERR=RETRY,IOREG=(5),CTLCHR=ASA,  X
               IOAREA1=XXIOPNCP,IOAREA2=XXIOPNCS,TYPEFLE=OUTPUT
XXIOPNCP DC    80C' '              PUNCH IOAREA1
XXIOPNCS DC    80C' '              PUNCH IOAREA2
.XXNPN8  ANOP
         AIF   (&$DISKU EQ 0).XXNDDCB  SKIP IF NO DISK OPTION
         AIF   (&$ASMLVL).XXDDCB1  SKIP IF OS GENERATION
XXDKUDC  DTFSD DEVADDR=&$IOUNIT(5),EOFADDR=XXDKEOF,TYPEFLE=WORK,       X
               BLKSIZE=3520,NOTEPNT=YES,DEVICE=&$DSKUDV
XXDKUDCB EQU   XXDKUDC             ATTACH 7-CHAR DTFSD LABEL TO EXPECTD
         AGO   .XXNDDCB
.XXDDCB1 ANOP
XXDKUDCB DCB  DDNAME=&$IOUNIT(5),EODAD=XXDKEOF,RECFM=FB,EXLST=XXDKEXLS,#
               SYNAD=XXDKSYND,DSORG=PS,NCP=&$BUFNO,MACRF=(RP,W)
XXDKBLKS EQU   XXDKUDCB+X'3E'      BLKSIZE FIELD (DCBBLKSI) ADDRESS
XXDKEXLS DC    0F'0',X'85',AL3(XXDKEXCD)  DCB EXIT, FILL IN BLKSIZE
.XXNDDCB ANOP
         EJECT
         AIF   (NOT &$MACSLB).XXNMDCB
*        DCB FOR THE MACRO LIBRARY FETCH OPTION
XXLIBDCB DCB   DSORG=PO,DDNAME=&$IOUNIT(6),MACRF=R,EODAD=XXMCEODD
.XXNMDCB ANOP
         SPACE 1
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: XIOBLOCK   CONTROL BLOCK FOR INPUT/OUTPUT MACROS          *
*        THIS BLOCK IS CREATED FOR ANY I/O MACRO BY THE INNER MACRO   *
*        XIONR, AND CONTAINS THE ADCON FOR THE DESIRED I/O ENTRYPOINT,*
*        SAVE WORDS FOR MODFIED REGS R14,R15,R0, AND THE LENGTH FOR   *
*        THE I/O AREA TO BE READ OR WRITTEN.                          *
*        THIS DSECT IS ONLY USED IN CSECT XXXXIOCO.                   *
*        GENERATION: BY MACRO XIONR (FOR $READ,$SORC,$PRNT,$PNCH).    *
*        NAMES: XIO-----                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
XIOBLOCK DSECT
         DS    V .                 @ I/O ROUTINE
         DS    3F                  AREA FOR REGS 15-0 TO BE SAVED
XIOLENG  DS    AL2 .               LENGTH OF RECORD, (CODES-FUTURE USE)
XIORETRN LM    14,0,4(14)          RETURN CODE FOR RESTORING REGISTERS
         AIF   (NOT &$ASMLVL).XXNDCBD  NO IHADCB UNDER DOS
         SPACE 1
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: IHADCB     DATA CONTROL BLOCK DSECT                       *
*        DCB DSECT USED BY PARTS OF XXXXIOCO.                         *
*        GENERATION: DCBD MACRO                                       *
*        LOCATION: XXSODCB,XXREDCB,XXPNDCB,XXPRDCB                    *
*        NAMES: DCB-----                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         DCBD  DSORG=QS
.XXNDCBD ANOP
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*-> LIBRARY DSECT -- XLBDSECT                                         *
*                                                                     *
*              DESCRIBES LIBRARY BUFFER SPACE AND CONTROL WORDS       *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
XLBDSECT DSECT
XLBUFLNG DS    F                   CONTROL WORD 1 => TOTAL LENGTH
XLBUFEND DS    F                   CONTROL WORD 2 => PERMENENT BUFFER
*                                     END
XLBUFSTR DS    F                   CONTROL WORD 3 => START OF BUFFER
XLBUFCED DS    F                   CONTROL WORD 4 => END OF BLOCK
XLBUFCNT EQU   *-XLBUFLNG          LENGTH OF CONTROL SECTION OF BUFFER
XLIBBUF  DS    F                   ACTUAL BUFFER STARTS HERE
         SPACE 5
         DROP  R11,R13,R14         AJOBCON,BASE REG, XIOBLOCK
         TITLE '*** XXSNAPC DSECT - XSNAP CONTROL BLOCK ***'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: XXSNAPC    CONTROL BLOCK USED BY THE XSNAP MACRO          *
*        THIS BLOCK IS CREATED BY EVERY PRINTING XSNAP MACRO.  IT     *
*        CONTAINS THE  EXACT CONTENTS OF THE GP REGISTERS BEFORE THE  *
*        XSNAP WAS CALLED, A FLAG BYTE INDICATING DESIRED OUTPUT AND  *
*        SPECIAL OPTIONS, THE NUMBER OF ADDRESS PAIRS USED IN THE     *
*        XSNAP STORAGE= OPERAND, THE ADDRESS PAIRS THEMSELVES, AND    *
*        THE ADDRESS CONSTANT FOR XXXXSNAP.  THE BYTE XXSFLAGS MAY    *
*        HAVE SEVERAL BITS TURNED ON REQUESTING SPECIAL ASSIST        *
*        SERVICES, SUCH AS USER DEBUGGING OUTPUT AND USER DUMP.  THE  *
*        BITS ARE SUPPLIED BY XSNAP OPERAND T(3), AND HAVE            *
*        MEANING ONLY WHEN USED INSIDE ASSIST WITH THE SPECIAL ASSIST *
*        VERSION OF THE CSECT XXXXSNAP.                               *
*        GENERATION: XSNAP MACRO, WITH T= ANY TYPE BUT ST OR STORE.   *
*        NAMES: XXS-----                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
XXSNAPC  DSECT
XXSGPRG  EQU   B'00000001'         (XXSFLAGS)=> PRINT GP REGS
XXSFLRG  EQU   B'00000010'         (XXSFLAGS)=> PRINT FL REGS
XXSAVTR  EQU   B'00000100'         (XXSFLAGS)=> SAVE AREA TRACE(FUTURE)
XXSASNAP EQU   B'00010000'         (XXSFLAGS)=> ASSIST EXECUTE SNAP
XXSASDMP EQU   B'00100000'         (XXSFLAGS)=> ASSIST FINAL DUMP
         SPACE 1
XXSRGSAV DS    16F                 REGISTER AREA, REGS SAVED BY XSNAP
XXSFLAGS DS    B                   OPTION BYTE FLAG
         DS    AL1                 **** UNUSED AS OF VERSION 4.0***
XXSLABLN DS    AL1                 LENGTH OF THE LABEL FIELD
XXSNMSTR DS    AL1                 NUMBER OF @ PAIRS IN STORAGE= LIST
         DS    V(XXXXSNAP)         ADCON FOR CALL TO XXXXSNAP ROUTINE
XXSADSTR DS    0A                  STORAGE = ADDRESS LIST(OPTIONAL)
         TITLE '*** XXXXSNAP-DEBUGGIN,DUMPING MODULE- V.4.0.AS ***'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                       JOHN R. MASHEY - MAY 1969     *
*                                       VERSION 4.0 - FEBRUARY 1970   *
*                                       VERSION 4.0.AS(SIST) FEB 1970 *
*                                       IBM 360/67 ASSEMBLER 'G'      *
*                                       PENNSYLVANIA STATE UNIVERSITY *
*        ABSOLUTE REGISTER EQUATES AND USAGE                          *
*              EQU'S HAVE BEEN CHANGED TO COMMENTS TO PREVENT MULTIPLE*
*        DEFINITION WHEN ASSEMBLING AS PART OF ASSIST.                *
*R0      EQU   0                   WORK REGISTER                      *
*R1      EQU   1                   USED AS WORK REGISTER              *
*R2      EQU   2                   USED TO HOLD 1ST ADDRESS OF PAIR   *
*R3      EQU   3                   USED TO HOLD SECOND ADDRESS OF PAIR*
*R4      EQU   4                   USED AS INCREMENT FOR BXLE'S       *
*R5      EQU   5                   LIMIT ADDRESS IN VARIOUS BXLE'S    *
*R6      EQU   6                   WILL CONTAIN CVTMZ00(HIGHEST ADDR) *
*R7      EQU   7                   OLD ADDRESS IN SAME LINE CHECK     *
*R8      EQU   8                   INTERNAL LINKAGE REGISTER          *
*R9      EQU   9                   ADDRESS OF CURRENT ADDRESS PAIR    *
*R10     EQU   10                  POINTS TO XSNAP LABEL,REGISTER AREA*
*R11     EQU   11                  @ ECONTROL BLOCK, RELOCATION VALUE *
*        THIS VALUE IN R11 ONLY IF XXSFLAGS HAS XXASNAP OR XXASDMP ON.*
*R12     EQU   12                  # STORAGE= ADDRESS PAIRS TO DO     *
*R13     EQU   13                  BASE REGISTER/@ DUMMY SAVE AREA    *
*R14     EQU   14                  RETURN ADDR,POINTER TO LABEL LENGTH*
*R15     EQU   15                  ENTRY POINT REGISTER               *
*        EQUREGS L=F,DO=(0,6,2)    SET UP FLOATING EQU'S              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        XSNAP CONTROL BLOCK AND POINTERS ON ENTRY TO XXXXSNAP.       *
*        FIELD     LENGTH(BYTES)   DESCRIPTION/PURPOSE                *
*        LABEL      LABLN          LABEL=, PADDED TO FULLWORD WITH ' '*
* R10===>RGSAV      64             16 FULLWORDS, WHERE REGS WERE SAVED*
*        FLAGS      1              BYTE FOR OPTION BITS               *
*              BIT 2 = 1 ==>       ASSIST COMPLETION FINAL DUMP       *
*              BIT 3 = 1 ==>       XSNAP USER DEBUGGING DUMP(XDUMP)   *
*              BIT 6 = 1 ==>       PRINT FP REGISTERS. IF =0, DO NOT  *
*              BIT 7 = 1 ==>       PRINT GP REGISTERS. IF =0, DO NOT  *
*        UNUSED     1              FOR FUTURE USE, NOT USED IN V.4.0  *
*        LABLN      1              LENGTH OF THE LABEL FIELD          *
*        NMSTR      1              # 8-BYTE @ PAIRS IN STORAGE= LIST  *
*        ADCON      4              V(XXXXSNAP) FOR CALL               *
*        ADSTR      NMSTR*8        STORAGE= @ LIST, IF PRESENT        *
*        INSTRUCTS  10       3 INSTRUCTIONS - LA, L, BALR             *
* R14===>LM    0,15,0(10)          RETURN POINT, RELOADS REGISTERS    *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> CSECT: XXXXSNAP   DEBUGGING OUTPUT, COMPLETION DUMP              *
*        THIS MODULE PROVIDES ALL REGISTER AND STORAGE DUMPING FOR    *
*        DEBUGGING PURPOSES, BOTH FOR INTERNAL ASSIST DEBUGGING, AND  *
*        FOR USER PROGRAMS DURING EXECUTION.  IT IS CALLED BY THE     *
*        MACRO XSNAP (XDUMP PSEUDO-INSTRUCTION FOR USER PROGRAMS),    *
*        AND PRODUCES A USER DUMP OR DEBUGGING OUPUT IF THE CALLING   *
*        XSNAP SPECIFIED A BINARY VALUE FOR OPERAND T(3).             *
*        ENTRY CONDITIONS                                             *
*   SEE XSNAP CONTROL BLOCK AND POINTERS ON ENTRY TO XSNAP COMMENTS.  *
*   ALSO, IF SPECIAL ASSIST OUTPUT IS DESIRED I.E. T(3) IS USED, THE  *
*   WORD IN XXSRGSAV WHERE REGISTER R10 WAS SAVED MUST CONTAIN THE    *
*   ADDRESS OF THE ECONTROL DUMMY SECTION, WHICH SUPPLIES VALUES      *
*        EXIT CONDITIONS                                              *
*   ALL REGISTERS AND CONDITION CODE ARE RESTORED TO ORIGINAL VALUES  *
*   AFTER EXECUTION OF THE INSTRUCTION AT THE RETURN POINT.           *
*        USES DSECTS: ECONTROL,XXSNAPC                                *
*        USES MACROS: $PRNT(IF &$DEBUG=1), OPEN,PUT(IF&$DEBUG=0)      *
*        NAMES: XX------ , ALL NAMES ADDED FOR ASSIST: XXAS----       *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
XXXXSNAP CSECT
         USING XXXXSNAP,R15        NOTE TEMPORARY ENTRY USING
         USING XXSNAPC,R10         NOTE POINTER TO BLOCK
         CNOP  0,4                 MAKE SURE ALIGNED ON FULLWORD
         BAL   R13,*+76            SET UP BASE AND SAVE AREA @
         USING *,R13               NOTE USING FOR BASE/SAVE AREA
XXSSAVE  DS    18F                 FAKE SAVE AREA FOR OS TO SAVE INTO
         ORG   XXSSAVE             ORG BACK
XXDWORK  DS    4D                  OVERLAP FLT WORK AREAS INTO FAKE SAV
         ORG
         DROP  R15                 CLEAR TEMPORARY USING
         ST    R14,XXSAVE14        SAVE RETURN ADDRESS,CC PROG MAKS
         L     R11,XXSRGSAV+4*R10  GET PTR (WAS IN R10)
         USING ECONTROL,R11        NOTE POINTER TO ECONTROL BLOCK
         SPACE 2
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        GET ADDRESS OF LABEL FROM FIRST POSITION IN ADDRESS LIST,    *
*   AND USING REGISTER 10(THE ADDRESS OF THE REGISTER SAVE AREA)      *
*   FIND THE LENGTH OF THE LABEL AND PRINT THE LABEL & HEADER LINE.   *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 2
XXOPENOK SR    R2,R2               CLEAR FOR INSERTION
         BAL   R8,XXSNBLNC         MAKE SURE XXLABEL BLANK, CC = 0
         TM    XXSFLAGS,XXSASDMP   ARE WE IN ASSIST FINAL DUMP
         BZ    XXASNDMP            NO, SO SKIP NEXT SECTION OF CODE ***
         EJECT
*              FOLLOWING SECTION PRINTS HEADER,COMPLETION CODE,PSW,   *
*        AND INSTRUCTION TRACE(OPTIONAL) FOR AN ASSIST FINAL DUMP     *
         SPACE 1
         MVC   XXLABEL(L'XXAS1HD),XXAS1HD   MOVE FIRST HDR, 1 CC IN
         BAL   R8,XXPRINTP         GO TO PRINT AS DESIRED             J
         BAL   R8,XXSNBLNC         REBLANK XXLABEL, MAKE CC = 0 AGAIN
         SPACE 1
         MVC   XXAS2HD,=C'PSW AT ABEND'     MOVE HDR IN
         MVC   XXAS2CC,=C'COMPLETION CODE'  MOVE HDR IN
         UNPK  XXAS2P1,ECPSW(5)    FIRST HALF OF PSW
         UNPK  XXAS2P2,ECILCMSK(5) 2ND HALF OF PSW
         TR    XXAS2P1(2*L'XXAS2P1-1),XXTAB1         FIND CONVERSION
         MVI   XXAS2P1+8,C' '      BLANK BETWEEN PARTS OF PSW
         MVI   XXAS2P2+8,C' '      BLANK AFTER 2ND PART OF PSW
         SPACE 1
         L     R1,ECERRAD          GET @ ERROR BLOCK
         USING ERCOMPCD,R1         NOTE THE POINTER
         MVC   *+7(1),ERCLENG      MOVE LENGTH-1 OVER
         MVC   XXAS2MS($CHN),ERCMSSG        MOVE MESSAGE OVER
         SPACE 1
         IC    R2,ERCTYPE          GET TYPE OF COMPLETION
         SLL   R2,3                MULT * 8 FOR INDEX TO TABLE
         DROP  R1                  NOTE NO LONGER USING BLOCK PTR
         LA    R1,XXAS2TPM(R2)     GET @ COMPLETION TYPE
         MVC   XXAS2TP,0(R1)       MOVE THE TYPE INTO MESSAGE
         BAL   R8,XXPRINTL         PRINT ASSEMBLED XXLABEL
         BAL   R8,XXSNBLNK         REBLANK XXLABEL
         SPACE 1
         TM    ECFLAG3,$ECDINST    SHOULD THERE BE INSTRUCTION TRACE
         BZ    XXASREGS            NO,SO DON'T PRINT INSTRUCTIONS
         LA    R0,XXAS3HD          SHOW @ THIS HEADER
         BAL   R8,XXPRINT          PRINT MESSAGE
         SPACE 1
         LA    R0,XXAS4HD          SHOW @ OF THIS LABEL
         BAL   R8,XXPRINT          PRINT (R0=@ XXLABEL STILL)
         SPACE 1
         L     R9,ECRSTK           GET @ CURRENT INSTRUCTION STACK
         LR    R12,R9              SAVE @ FOR COMPARISON IN LOOP
         USING ECSTACKD,R9         NOTE DSECT FOR EACH STACK ENTRY
         SPACE 1
*              FIRST LOOP SEARCHES FOR 1ST ACTUAL INSTRUCTION IN THE  *
*        INSTRUCTION STACK.  CHECK REQUIRED IN CASE OF PROGRAM WHICH  *
*        BOMBS ON 1ST INSTRUCTION, SUCH AS BEGINNING WITH DC H'0'.    *
XXASINA  L     R9,ECSTLINK         GET @ NEXT INSTRUCTION ENTRY
         CLI   ECOP,0              WAS THIS AN INSTRUCTION
         BNE   XXASINB             YES,SKIP TO BEGIN PRINTING
         CR    R9,R12              CHECK FOR COMPLETE CYCLE
         BNE   XXASINA             NOT CYCLE,LOOP UNTIL 1ST INST
         SPACE 1
*              HAVING FOUND 1ST ACTUAL INSTRUCTION, OR SINGLE OPCODE  *
*        OF 0 IN INSTRUCTION CYCLE, PRINT 1 OR MORE INSTRUCTIONS.     *
XXASINB  NI    ECSTCCPM,X'3F'      ZERO OUT ILC(NOT ALREADY SAVED)
XXASINB1 OI    ECSTCCPM,$CHN       OR BUILT-UP ILC FROM LAST INST
         MVI   *-3,0               ZERO OUT BYTE FOR ILC
         MVC   XXAS5I2(10),XXBLANKS         BLANK HALFWORDS 2-3
         SPACE 1
         UNPK  XXAS5I1(5),ECOP(3)  CONVERT OPCODE REGS/LENGTH (ALWAYS)
         MVI   XXAS5I1+4,C' '      BLANK TRAILING BYTE
         CLI   ECOP,X'40'          WAS INSTRUCTION RR
         BL    XXASINC             YES,SO DO NO MORE ON INST
         SPACE 1
         UNPK  XXAS5I2(5),ECBD(3)  UNPACK FIRST BASE-DISPLACEMENT
         OI    XXASINB1+1,X'80'    SET ILC FOR NEXT INST TO 2
         MVI   XXAS5I2+4,C' '      BLANK TRAILING BYTE
         CLI   ECOP,X'C0'          WAS INST RX,RS,SI
         BL    XXASIND             YES,SO NO MORE CONVERT NEEDED
         SPACE 1
         UNPK  XXAS5I3(5),ECB2D2(3) UNPACK 3RD HALFWORD- 2ND BASE-DISP
         MVI   XXAS5I3+4,C' '      BLANK TRAILING BYTE
XXASINC  OI    XXASINB1+1,X'40'    SET NEXT ILC TO 1(RR), OR 3(SS)
XXASIND  UNPK  XXAS5CC(3),ECSTCCPM CONVERT ILC(NOW RIGHT) CC PM OF PSW
         MVI   XXAS5CC+2,C' '      BLANK TRAILING BYTE
         SPACE 1
         UNPK  XXAS5AD(7),ECSTIADD+1(4)     CONVERT INST ADDRESS
         MVI   XXAS5AD+6,C' '      BLANK TRAILING BYTE
         TR    XXAS5CC(XXAS5$L-2),XXTAB1    FINISH HEX CONVERT
         SPACE 1
         CR    R9,R12              WAS THIS LAST ONE
         BNE   *+10                BRANCH OVER MVC IF NOT LAST ONE
         MVC   XXLABEL+2+XXAS5$L(L'XXAS5P),XXAS5P     MOVE ERR PTR
         BAL   R8,XXPRINTL         PRINT ASSEMBLED XXLABEL
         CR    R9,R12              WAS THIS THE LAST 1(ABENDING INSTR)
         L     R9,ECSTLINK         GET @ NEXT ENTRY IN TABLE
         BNE   XXASINB             GOBACK FOR NEXT ENTRY IN TABLE
         SPACE 1
XXASINE  MVC   XXLABEL+1(XXAS5$L+2+L'XXAS5P),XXBLANKS REBLANK
         BAL   R8,XXPRINTL         PRINT ASSEMBLED XXLABEL
         DROP  R9                  DROP LEFTOVER USING          CPP
         AIF   (NOT &$EXINT).NOXXINT
         SPACE 3
         SPACE 2
         LA    R0,XXAS7HD          GET ADDR 1ST BRANCH TRACE HEADER
         BAL   R8,XXPRINT          BRANCH, AND PRINT THES HEADER
         SPACE 2
         LA    R0,XXAS4HD          GET ADDR 2ND BRANCH TREE HEADER
         BAL   R8,XXPRINT          PRINT THIS HEADER
         SPACE 2
*              GET BRANCH STACK ADDRESSIBILITY
         L     R1,ECBSTK           GET @ CURRENT BRANCH INSTR STACK
         LR    R12,R1              SAVE ADDRESS FOR COMPARISON IN LOOP
         USING ECSTACKD,R1         NOTE DSECT FOR EACH BSTACK ENTRY CEH
         SPACE 2
*              FIRST LOOP SEARCHES FOR 1ST ACTUAL BRANCH INSTRUCTION IN
*              THE BRANCH INSTRUCTION STACK.  CHECK REQUIRED IN CASE OF
*              PROGRAM BOMB HAVING EXECUTED NO BRANCHES.
XXASBINA EQU   *
         L     R1,ECSTLINK         GET @ NEXT BRANCH ENTRY      CEH
         CLI   ECOP,0              WAS THIS ENTRY AN INSTR.     CEH
         BNE   XXASBINB            YES, SKIP TO BEGIN PRINTING
         CR    R1,R12              CHECK FOR A COMPLETE CYCLE
         BNE   XXASBINA            NOT CYCLE, LOOP UNTIL 1ST BRANCH
         SPACE 2
*              HAVE FOUND 1ST ACTUAL !RANCH INSTRUCTION, OR A SINGLE  *
*              OPCODE IN BRANCH INSTRUCTION CYCLE. PRINT 1 OR MORE    *
*              INSTRUCTIONS                                           *
XXASBINB EQU   *
         NI    ECSTCCPM,X'3F'      ZERO OUT ILC(NOT ALREADY SAVED) CEH
XXASBIN1 OI    ECSTCCPM,$CHN       OR BUILT-UP ILC FROM LAST INSTR CEH
         MVI   *-3,0               ZERO OUT BYTE FOR ILC
         MVC   XXAS5I2(10),XXBLANKS     BLANK OUT HALFWORDS 2 AND 3
         SPACE 2
         UNPK  XXAS5I1(5),ECOP(3)  CONVERT OPCODE, REGS. & LEN  CEH
         MVI   XXAS5I1+4,C' '      BLANK OUT TRAILING BYTE
         CLI   ECOP,X'40'          WAS THIS AN RR INSTR.       CEH
         BL    XXASBINC            YES WE ARE FINISHED WITH THIS INSTR
         SPACE 2
         UNPK  XXAS5I2(5),ECBD(3)   UNPACK ONLY BASE-DISPL.      CEH
         OI    XXASBIN1+1,X'80'    SET ILC NEXT INSTR TO 2
         MVI   XXAS5I2+4,C' '      BLANK OUT TRAILING BYTE
         B     XXASBIND            NO MORE CONVERSION NEEDED
         SPACE 2
XXASBINC EQU   *
         OI    XXASBIN1+1,X'40'    SET NEXT ILC TO 1 FOR RR INSTR
XXASBIND EQU   *
         UNPK  XXAS5CC(3),ECSTCCPM CONVERT GOOD ILC-CC PM OF PSW CEH
         MVI   XXAS5CC+2,C' '      BLANK OUT TRAILING BYTE
         SPACE 2
         UNPK  XXAS5AD(7),ECSTIADD+1(4)    CONVERT BR INST. ADDR. CEH
         MVI   XXAS5AD+6,C' '      BLANK OUT TRAILING BYTE
         TR    XXAS5CC(XXAS5$L-2),XXTAB1   FINISH HEX CONVERT
         SPACE 2
         BAL   R8,XXPRINTL         PRINT ASSEMBLED XXLABEL
         CR    R1,R12              WAS THIS THE FINAL BRANCH INSTR
         L     R1,ECSTLINK         GET NEXT ENTRY IN TABLE      CEH
         BNE   XXASBINB            GO BACK FOR NEXT ENTRY IN TABLE
         BAL   R8,XXSNBLNC         CLEAR XXLABEL OF GARBAGE
         DROP  R1                  CLEAR AWAY BASE REGISTER
.NOXXINT ANOP
         SPACE 1
*              FINAL DUMP==> EITHER PRINT ALL REGS OR NONE            *
XXASREGS TM    ECFLAG3,$ECREGS     SHOULD WE GIVE REGS
         BO    XXASREG1            YES,SO GO DO IT
         B     XXCHKST             NO REGS AT ALL
         EJECT
XXASNDMP EQU   *                   ENTRY LABEL FOR NORMAL XSNAP
         IC    R2,XXSLABLN         GET LENGTH OF LABEL FIELD
         LR    R1,R10              GET DUPLICATE OF XXSNAPC PTR
         SR    R1,R2               SUBTRACT TO GET START @ FOR LABEL
         BCTR  R2,0                DECREMENT TO LENGTH-1 FOR MVC
         STC   R2,*+5              STORE INTO MVC
         MVC   XXLABEL+38($CHN),0(R1)       MOVE LABEL TO PRINT AREA
         ST    R1,XXWORK1          SAVE THIS @ FOR CONVERSION
         MVC   XXWORK1(1),XXSAVE14 MOVE CCMASK OVER FOR CONVERSION
         SPACE 1
         TM    XXSFLAGS,XXSASNAP   IS THIS A USER SNAP
         BZ    *+10                NO,SO DON'T CHANGE PSW
         MVC   XXWORK1(4),ECILCMSK MOVE USER PSW OVER
         MVC   XXLABEL+1(XXSN1B),XXSNP1ST    MOVE HEADER,PATTERN,MSG
         ED    XXLABEL+L'XXSNP1ST+1(6),XXCOUNT         EDIT CALL NUMBER
         UNPK  XXLABEL+1+XXSN1B(9),XXWORK1(5)       CONVERT CCPM,LOCN
         TR    XXLABEL+1+XXSN1B(8),XXTAB1  FINISH HEX CONVERSION
         AP    XXCOUNT,=P'1'       INCREMENT # CALLS
         BAL   R8,XXPRINTL         PRINT ASSEMBLED XXLABEL
         BAL   R8,XXSNBLNK         REBLANK XXLABEL
         SPACE 2
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        CHECK TO SEE IF THE REGISTERS SHOULD BE PRINTED.             *
*        PRINT THE HEADING FOR THE REGISTER DUMP.  CONVERT AND PRINT  *
*   THE REGISTERS IN 2 LINES. CHECK TO SEE IF ONLY THE REGISTERS      *
*   WERE DESIRED. FINISH UP AND RETURN TO CALLING XSNAP IF SO.        *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 2
         TM    XXSFLAGS,XXSGPRG    DOES HE WANT GP REGS PRINTED
         BZ    XXCHKFP             NO, SO DONT PRINT THEM
         LR    R2,R10              DUPLICATE @ RGSAV OVER
         TM    XXSFLAGS,XXSASNAP   WAS THIS USER XSNAP
         BZ    XXGOREG             NO,NORMAL XSNAP,SKIP
XXASREG1 LA    R2,ECREGS           SHOW @ FAKE REGS INSTEAD
XXGOREG  EQU   *                   ***WE HAVE DELETED REG HEADER**    J
         SPACE 1
         MVC   XXREGOUT(12),=CL12'0 REGS 0-7'          LABEL-1ST REGS
         BAL   R8,XXREGS1          CONVERT 1>T REGS BLOCK,PRINT LINE
         BAL   R8,XXPRINT          HAVE LINE PRINTED
         SPACE 1
         MVC   XXREGOUT(12),=CL12'  REGS 8-15'   2ND LINE LABEL
         BAL   R8,XXREGS2          GET 2ND GROUP CONVERTED,PRINTED
         BAL   R8,XXPRINT          HAVE LINE PRINTED
         SPACE 1
XXCHKFP  EQU   *
         AIF   (NOT &$FLOTM).XXS2  SKIP IF MACHINE DOEN'T HAVE FLOT
         TM    XXSFLAGS,XXSFLRG    DOES HE WANT FLOATING PT REGS PRINT
         BZ    XXCHKST             NO,SO GO CHECK FOR STORAGE=
         SPACE 1
*              FOLLOWING SECTION PRINTS FLOATING POINT REGISTERS      *
         MVC   XXREGOUT(12),=CL12'0 FLTR 0-6'         MOVE LABEL IN
         LA    R2,ECFPREGS         SHOW @ FAKE REGS
         TM    XXSFLAGS,XXSASDMP+XXSASNAP   WAS THIS ASSIST SNAP/DUMP
         BNZ   XXFPCONV            GO CONVERT THEM
         STD   F0,XXDWORK          SAVE REG F0
         STD   F2,XXDWORK+8        SAVE F2
         STD   F4,XXDWORK+16       SAVE F4
         STD   F6,XXDWORK+24       SAVE F6
         LA    R2,XXDWORK          SET UP @ WORKAREA FOR XXREGS1
XXFPCONV EQU   *
         BAL   R8,XXREGS1          CALL GP REG CONVERTER
         MVC   XXREGOUT+24(12),XXREGOUT+28           PUT F0 TOGETHER
         MVC   XXREGOUT+48(12),XXREGOUT+52           PUT F2 TOGETHER
         MVC   XXREGOUT+72(12),XXREGOUT+76           PUT F4 TOGETHER
         MVC   XXREGOUT+96(12),XXREGOUT+100          PUT F6 TOGETHER
         BAL   R8,XXPRINT          PRINT THE ASSEMBLED LINE
         MVC   XXREGOUT,XXBLANKS   REBLANK LINE LIKE ITS SUPPOSED TO BE
.XXS2    ANOP
         SPACE 1
XXCHKST  EQU   *
         SR    R12,R12             CLEAR FOR INSERTION
         IC    R12,XXSNMSTR        GET # OF ADDRESS PAIRS
         LTR   R12,R12             ARE THERE ANY @ PAIRS
         BZ    XXEXIT1             NO STORAGE=, SO QUIT
         LA    R9,XXSADSTR         INIT R9 TO @ FIRST ADDRESS PAIR
         LA    R4,4                SET UP BXLE INDEX FOR REST OF PROG
         SPACE 1
         TM    XXSFLAGS,XXSASNAP+XXSASDMP   ARE SPECIAL @ GAMES NEEDED
         BZ    XXASTA              SKIP IF NOT (I.E. NORMAL XSNAP)
         TM    XXSFLAGS,XXSASDMP   WAS THIS A DUMP?
         BZ    XXAST               SKIP IF JUST SNAP
         TM    ECFLAG3,$ECSTORG    SHOULD STORAGE BE DUMPED
         BZ    XXEXIT3             NO STORAGE,SO QUIT
         MVC   XXLABEL(L'XXAS6HD),XXAS6HD   MOVE IN STORAGE DUMP HEADER
         BAL   R8,XXPRINTP         GO PRINT AS DESIRED                J
         BAL   R8,XXSNBLNC         REBLANK XXLABEL, MAKE SURE CC = 0
         SPACE 1
XXAST    L     R6,ECRADH           GET REAL HIGH LIMIT @
         TM    ECFLAG0,$ECPROT     WAS ABSOLUTE PROTECT MODE ON
         L     R11,ECRELOC         GET EXECUTION TIME RELOCATION FACTOR
         BZ    XXASTB              NO, SKIP, RESET TO NORMAL LIMIT
         DROP  R11                 NOTE NO LONGER USING WITH ECONTROL
         LCR   R11,R11             MAKE NEGATIVE,SO CAN USE IN LA'S
         B     XXASTC              SKIP TO BEGIN PROCESSING
*              NOTE ASSIST DUMP REQUIRES USER CORE TO BEGIN ON REAL   *
*        ADDRESS DIVISIBLE BY 32,TO GET REASONABLE OUTPUT.            *
         SPACE 1
*              THE FOLLOWING 2 LINES HELP US PREVENT 0C5'S            *
XXASTA   SR    R11,R11             SET RELOCATION TO 0 (NORMAL XSNAP)
         AIF   (NOT &$ASMLVL).XXASDOS   SKIP IF OTHER THAN OS/360
XXASTB   L     R6,16               CVT PTR **********OS/360 ONLY ******
         L     R6,164(R6)          GET CVTMZ000 - HIGHEST CORE @
.XXASDOS AIF   (&$ASMLVL).XXASNOS  SKIP IF OS/360, CAN GET SIZ FROM CVT
XXASTB   COMRG                     R1 <- @ OF COMMUNICATIONS REGION
         L     R6,48(R1)           GET @ OF END OF MACHINE (DOS)
         LA    R6,1(R6)            GET @ ON NEXT NON-AVAIL BYTE
.XXASNOS ANOP
XXASTC   SH    R6,=H'32'           REDUCE SO WILL NOT 0C5
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        SECTIONS XXMEMA - XXMEME SERVE TO PROCESS 1 ADDRESS PAIR     *
*   FROM THE LIST OF ADDRESS PAIRS SPECIFYING STORAGE TO BE DUMPED.   *
*   AT XXMEMF,THE 2ND ADDRESS IS TESTED TO SEE IF IT IS THE LAST ONE  *
*   AND  THE DUMP COMPLETED IF SO. OTHERWISE,A BRANCH IS TAKEN BACK   *
*   TO XXMEMA TO PROCESS THE NEXT ADDRESS PAIR.                       *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 2
XXMEMA   LM    R2,R3,0(R9)         OBTAIN NEXT ADDRESS PAIR
         LA    R0,0(R11,R2)        RELOCATE ADDRESS IF NEEDED
         ST    R0,XXWORK1          SAVE FOR CONVERSION
         UNPK  XXCOREL,XXWORK1+1(4)         CONVERT WITH TRAILING BLANK
         LA    R0,0(R11,R3)        GET HIGH ADDRESS,RELOCATE
         ST    R0,XXWORK1          SAVE FOR CONVERT
         UNPK  XXCOREH,XXWORK1+1(4)         CONVERT WITH TRAILING BLANK
         TR    XXCOREL(17),XXTAB1  TRANSLATE TO COMPLETE HEX CONVERT
         MVC   XXCOREL+7(2),=C'TO' PUT REST OF MSG IN
         MVC   XXCORETL,=C'CORE ADDRESSES SPECIFIED-' PUT IN MSG
         BAL   R8,XXPRINTL         PRINT XXLABEL
         MVC   XXCORETL(XXCORE$L),XXBLANKS+30         REBLANK THE AREA
         SPACE 1
         CR    R3,R6               MAKE SURE HIGH ADDR ISN'T TOO HIGH
         BNH   *+6                 SKIP OVER IF NOT TOO HIGH
         LR    R3,R6               @ WOULD 0C5-USE HIGHEST INSTEAD
         LA    R3,31(R3)           PREPARE TO ROUND 2ND ADDR UPWARD
         SRDL  R2,5                ROUND BOTH ADDRESSES
         SLL   R2,5                NOW HAVE 1ST ADDR IN R2,ROUNDED DOWN
         SLL   R3,5                NOW HAVE HIGH ADDR IN R3,ROUNDED UP
         CR    R2,R3               WAS USER IN ERROR: LOW ADDR>HIGH ADD
         BH    XXMEMF              ADDR ERROR-PRINT NOTHING,GO TO NEXT
         CR    R2,R6               MAKE SURE IF 1ST=2ND>MEMORY SIZE
         BH    XXMEMF              PRINT NOTHING IF SO
         SPACE 2
XXMEMB   EQU   *
         AR    R2,R11              RELOCATE IF NEEDED
         ST    R2,XXWORK1          STORE BEGINNING ADDR FOR CONVERT
         SR    R2,R11              CONVERT BACK TO REAL @
         LR    R7,R2               SAVE BEGINNING ADDRESS FOR SAME CHK
         UNPK  XXCORADD+1(7),XXWORK1+1(4)    GET BEGINNING ADDRESS
         MVC   XXCORE3,0(R2)       MOVE 32 BYTES OVER FOR ALPHMERIC TR
         TR    XXCORE3,XXTAB2      PERFORM ALPHAMERIC CONVERSION
         SPACE 1
         LA    R1,XXCORE1          ADDRESS FOR 1ST BLOCK CONVERSION
         BAL   R8,XXMEMP1          GET 1ST BLOCK OF 4 WORDS CONVERTED
         LA    R1,XXCORE2          ADDRESS FOR 2ND BLOCK CONVERSION
         BAL   R8,XXMEMP1          GET 2ND BLOCK CONVERTED
         SPACE 1
         TR    XXCORADD+1(84),XXTAB1         FINISH HEX CONVERSION
         LA    R0,XXCORADD         ADDRESS OF CORE OUTPUT LINE
         BAL   R8,XXPRINT          GET 1 CORE LINE PRINTED
         EJECT
*        XXMEMC-XXMEME CHECK FOR DUPLICATE LINES. HAVING FOUND 1 OR   *
*   MORE DUPLICATE LINES,CORE IS SCANNED UNTIL A DIFFERENT LINE IS    *
*   FOUND,OR THE BLOCK FINISHED,AND THEN PRINTS SAME LINES MESSAGE.   *
         SPACE 2
XXMEMC   CR    R2,R3               R2 HAS BEEN INCREMENTED-ARE WE DONE
         BNL   XXMEMF              YES WE'RE DONE WITH THIS SECTION
         CLC   0(32,R7),0(R2)      COMPARE PREVIOUS SECTION WITH NEXT
         BNE   XXMEMB              NOT THE SAME-WILL HAVE TO PRINT LINE
         LA    R7,32(R11,R7)       INCREMENT TO MAKE RIGHT @,RELOCATE
         ST    R7,XXWORK1          SAVE 1ST LINE ADDRESS OF SAME AREAS
         SR    R7,R11              CONVERT BACK TO REAL @
         UNPK  XXSAML,XXWORK1+1    1ST STEP TO CONVERT
         SPACE 1
XXMEMD   LA    R2,32(R2)           INCREMENT TO LOOK AT NEXT SECTION
         CR    R2,R3               ARE WE DONE
         BNL   XXMEME              YES,WE'RE DONE-SAME LINES MESSAGE
         CLC   0(32,R7),0(R2)      CHECK NEXT SECTION WITH 1ST OF SAMES
         BE    XXMEMD              SAME-KEEP LOOPING UNTIL DIFFERENT
         SPACE 1
XXMEME   LA    R1,0(R11,R2)        GET END @,RELOCATE,WHERE CAN DESTROY
         SH    R1,=H'32'           DECRMENT SO LINE ADDR RIGHT
         ST    R1,XXWORK1          SAVE FOR HEX CONVERSION
         UNPK  XXSAMH,XXWORK1+1    CONVERT-FIRST STEP
         TR    XXSAML(13),XXTAB1   FINISH HEX CONVERSION OF SAME LINES
         MVI   XXSAML+6,C'-'       PLACE DASH BETWEEN ADDRESSES
         MVC   XXLABEL+1+3(XXSAM$L),XXSAME  MOVE SAME LINES MSG OVER
         LA    R0,XXLABEL+1        SHOW @ 1 BEYOND CARRIAGE CONTROL
         BAL   R8,XXPRINT          PRINT THE SAME LINE MESSAGE
         CR    R2,R3               HAVE WE MEANWHILE FINISHED BLOCK
         BL    XXMEMB              NO-KEEP GOING UNTIL BLOCK DONE
         SPACE 1
XXMEMF   LA    R9,8(R9)            INCREM R9 TO @ NEXT @ PAIR
         MVC   XXLABEL+1+3(XXSAM$L),XXBLANKS+1+3      REBLANK AREA
         BCT   R12,XXMEMA          GO BACK FOR NEXT BLOCK
         B     XXEXIT2             ALL STORAGE= DONE, GO RETURN
         EJECT
*        XXEXIT - PRINT ENDING LINE,THEN RETURN TO CALLING XSNAP.     *
         SPACE 2
XXEXIT1  TM    XXSFLAGS,XXSGPRG+XXSFLRG     WERE EITHER REGS PRINTED
         BZ    XXEXIT3             NO OPTIONS, JUST LEAVE SINGLE LINE
XXEXIT2  EQU   *                   DON'T HAVE TO SET R0, USE XXPRINTL
         BAL   R8,XXPRINTL         PRINT XXLABEL FOR A BLNKA LINE
XXEXIT3  L     R14,XXSAVE14        RELOAD RETURN @, CC
         SPM   R14                 RESTORE CONDITION CODE
         BR    R14                 RETURN TO CALLING XSNAP
         EJECT
*        ***  INTERNAL SUBROUTINE AREA ***                            *
         SPACE 1
*              XXSNBLNC BLANKS XXLABEL, SETS CARRIAGE CONTROL = 0.
*              XXSNBLNK JUST BLANKS XXLABEL, NOT CHANGING CC.
XXSNBLNC MVI   XXLABEL,C'0'        MAKE NORMAL DOUBLE SPACE CC
XXSNBLNK MVC   XXLABEL+1(L'XXLABEL-1),XXBLANKS+1 REBLANK ENTIRE AREA
         BR    R8                  RETURN TO CALLER
         SPACE 2
*              XXREGS1 CONVERTS AND PRINTS 1 LINE OF 8 REGISTERS      *
         SPACE 1
XXREGS1  LA    R4,12               INCREMENT FOR BXLE
         LA    R5,XXREGOUT+16+7*12 LIMIT ADDRESS FOR BXLE
XXREGS2  LA    R3,XXREGOUT+16      START POINT,INDEX FOR COMING BXLE
XXREGS3  UNPK  0(9,R3),0(5,R2)     CONVERT 1 REGISTER VALUE
         MVI   8(R3),C' '          BLANK OUT EXTRA BYTE USED IN CONVERT
         LA    R2,4(R2)            INCREMENT POINTER TO REGISTER
         BXLE  R3,R4,XXREGS3       LOOP-DO 1 LINE OF 8 REGISTER VALUES
         TR    XXREGOUT+16(92),XXTAB1        FOR REST OF HEX CONVERT
         LA    R0,XXREGOUT         ADDRESS OF OUTPUT LINE
         BR    R8                  RETURN TO CALLER
         SPACE 2
*              XXMEMP1 CONVERTS 1 BLOCK OF 16 BYTES TO HEX.           *
         SPACE 1
XXMEMP1  LA    R5,12(R2)           SET UP LIMIT FOR BXLE
XXMEMP2  UNPK  0(9,R1),0(5,R2)     UNPACK 1 WORD OF MEMORY
         MVI   8(R1),C' '          BLANK OUT EXTRA BYTE UNPACKED
         LA    R1,9(R1)            INCREMENT POINTER TO OUTPUT AREA
         BXLE  R2,R4,XXMEMP2       CONTINUE,CONVERTING 16 BYTES
         BR    R8                  RETURN TO CALLER
         SPACE 2
*              XXPRINTL PRINTS 121 CHARACTERS STARTING AT XXLABEL.    *
*              XXPRINT  PRINTS 121 CHARACTERS STARTING AT @ IN R0.    *
         SPACE 1
XXPRINTP EQU   *    ***COME HERE IF MIGHT BE PAGE SKIP POSSIBLE***    J
         AIF   (&$DMPAG).XXNPQQQ   SKIP IF PAGE EJECTS ALLOWED AT ALL J
         MVI   XXLABEL,C'0'        USE DOUBLE SPACE RATHER THAN EJECT J
.XXNPQQQ ANOP                                                         J
XXPRINTL LA    R0,XXLABEL          SHOW @ XXLABEL
XXPRINT  EQU   *
         AIF   (&$DEBUG).XXS50     SKIP IF PRODUCTION
         PUT   XXSNDCB,(0)
         AGO   .XXS60              SKIP
.XXS50   $PRNT (0),121,XXSNPROV    PRINT OUTPUT,GO TO LABEL IF OVERFLOW
.XXS60   ANOP
         BR    R8                  RETURN TO CALLER
         EJECT
*              EXIT TAKEN IF RECORD LIMIT OVERRUN.  THIS CHECKS TO    *
*        SEE IF OUTPUT IS FOR AN EXECUTION-TIME XDUMP, IN WHICH CASE  *
*        EXECUTION IS STOPPED, SINCE USER IS OVERRUNNING HIS LIMIT.   *
XXSNPROV EQU   *
         TM    XXSFLAGS,XXSASNAP   WAS THIS A USER SNAP (XDUMP)
         BZ    XXEXIT3             NO, FINAL DUMP-WE'RE DONE
         SPACE 1
*              OVERFLOW OCCURED.  QUIT, FLAGGING ECONTROL.
         L     R11,XXSRGSAV+4*R10  GET PTR TO ECONTROL, WAS IN R10
         USING ECONTROL,R11        NOTE POINTER
         MVI   ECFLAG1,$ECRECEX    SHOW EXECUT THAT RECORD OVERFLOWED
         B     XXEXIT3             GO RETURN CONTROL
         DROP  R11                 NOT NEEDED ANYMORE
         SPACE 5
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> ENTRY: XXXXSNIN   XXXXSNAP INITIALIZATION ENTRY                  *
*        CALLED TO INITIALIZE 'XSNAP - CALL' NUMBER TO 1 (IN CASE     *
*        BATCHED RUNS ARE USED).                                      *
*        ENTRY CONDITIONS                                             *
*   R14= RETURN ADDRESS                                               *
*   R15= @ XXXXSNIN                                                   *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         ENTRY XXXXSNIN            INITIALIZATION ENTRY FOR ASSIST
         USING XXXXSNIN,R15        NOTE USING
XXXXSNIN ZAP   XXCOUNT,=P'1'       INITILZE COUNTER TO 1
         BR    R14                 RETURN TO CALLER
         SPACE
         EJECT
*        *** OUTPUT LINE,CONSTANT, AND TRANSLATE TABLE AREA ***       *
         SPACE 2
XXSAVE14 DS    A                   SAVE WORD FOR RETURN @, CC,MASK
XXWORK1  DC    F'0',X'04'          FIELD + REVERSED BLANK FOR HEX CONVT
XXCOUNT  DC    PL3'1'              COUNTER FOR NUMBER OF CALLS
         AIF   (&$DEBUG).XXS70     SKIP IF PRODUCTION VERSION
         PRINT NOGEN
         ENTRY XXSNDCB             SO PEOPLE CAN CHANGE,IF THEY WISH
         AIF   (&$ASMLVL).XXSNDTF  SKIP IF UNDER OS GENERATION
XXSNDCB  DTFPR DEVADDR=SYSLST,BLKSIZE=121,CTLCHR=YES,IOAREA1=XXSNIOAR, X
               WORKA=YES
XXSNIOAR DC    121C' '             DOS XSNAP IOAREA
.XXSNDTF AIF   (NOT &$ASMLVL).XXS70    SKIP IF UNDER DOS GENERATION
XXSNDCB  DCB   DSORG=PS,MACRF=PM,RECFM=FA,LRECL=121,BLKSIZE=121,       #
               DDNAME=XSNAPOUT,BUFNO=1
.XXS70   ANOP
         SPACE 1
         DS    0D                  ALIGN FOR SPEED
XXSNP1ST DC    C'BEGIN XSNAP - CALL'         HEADER TITLE
         DC    X'402020202021'     EDIT PATTERN FOR CALL NUMBER
         DC    C' AT '             FOR XSNAP LOCATION MESSAGE
XXSN1B   EQU   *-XXSNP1ST          LENGTH OF HEADER,NUMBER,LOCATION
         SPACE 1
         DS    0D                  ALIGN FOR SPEED
XXSAME   DC    CL9'LINES'          BEGINNING OF SAME LINE MSG
XXSAML   DC    CL7' '              LOWEST ADDRESS AREA
XXSAMH   DC    CL7' ',C'   SAME AS ABOVE'   END OF SAME LINES MSG
XXSAM$L  EQU   *-XXSAME            LENGTH OF MESSAGE
         SPACE 1
         DS    0D                  ALIGN FOR SPEED
XXLABEL  DC    CL121'0'            MAIN PRINTING AREA, WITH SKIP CARCON
         DC    CL7' '              PAD TO DOUBLEWORD BOUNDARY
         SPACE 1
         DS    0D                  ALIGN FOR SPEED
XXBLANKS DC    CL121' ',CL7' '     BLANKS, ALSO FOR XXREGLAB PRINTING
         DS    0D                  ALIGN FOR SPEED
XXREGOUT DC    CL121' '            REGISTER PRINTING AREA
         SPACE 1
         DS    0D                  ALIGN FOR SPEED
XXTAB    DC    C'0123456789ABCDEF' TR TABLE FOR HEX CONVERT
XXTAB1   EQU   XXTAB-240           TO MAKE CONSTANT TR'S EASIER FOR HEX
         SPACE 1
         DS    0D                  ALIGN FOR SPEED
XXTAB2   DC    64C'.',C' ',128C'.',C'ABCDEFGHI',7C'.',C'JKLMNOPQR'
         DC    8C'.',C'STUVWXYZ',6C'.',C'0123456789',6C'.'  ALPH TR TAB
         SPACE 1
         DS    0D                  ALIGN FOR SPEED
XXCORADD DC    CL7' ',CL3' '       10 BYTES - LINE ADDRESS
XXCORE1  DC    4CL9' ',CL3' '      39 BYTES - SPACE FOR 4 WORDS
XXCORE2  DC    4CL9' ',CL3'  *'    39 BYTES - SPACE FOR 2ND BLOCK
XXCORE3  DC    CL32' ',C'*'        33 BYTES - ALPHAMERICS +   *
         SPACE 1
         ORG   XXLABEL+30          ORG BACK TO MAIN LABEL AREA
XXCORETL DS    C'CORE ADDRESSES SPECIFIED-'   SPACE FPR HDR
         ORG   XXCORETL+30         SPACE UPWARD
XXCOREL  DS    CL7,CL3             SPACE FOR LOW ADDR, 'TO '
XXCOREH  DS    CL7' '              SPACE FOR 2ND @
XXCORE$L EQU   *-XXCORETL          GET LENGTH OF HDR
         ORG   ,                   RESTORE NORMAL LOCATION CTR
         EJECT
         DS    0D                  ALIGN FOR SPEED
XXAS1HD  DC    C'1 ASSIST COMPLETION DUMP'  HEADER 1ST PAGE OF DUMP
         SPACE 1
         ORG    XXLABEL+1          ORG BACK TO LABEL PRINTING AREA+1
XXAS2HD  DS    C'PSW AT ABEND'     SPACE FOR HDR, L' ATTRIBUTE SET
         DS    C                   SPACING BYTE
XXAS2P1  DS    CL9                 1ST HALF OF PSW
XXAS2P2  DS    CL9                 2ND HALF OF PSW
         DS    CL6' '
XXAS2CC  DS    C'COMPLETION CODE',CL3' '    SPACE, L'
XXAS2TP  DS    CL8                 SPACE FOR TYPE-SYTEM,ASSIST,USER =
         DS    C' '
XXAS2MS  EQU   *                   FOR MESSAGE
         ORG   ,                   ORG BACK TO NORMAL LOCATION CTR
         SPACE 1
XXAS2TPM DC    CL8'SYSTEM =',CL8'ASSIST =',CL8' USER  ='
         SPACE 1
XXAS3HD  DC    CL121'0** TRACE OF INSTRUCTIONS JUST BEFORE TERMINATION:#
                PSW BITS SHOWN ARE THOSE BEFORE CORRESPONDING INSTRUCTI#
               ON DECODED ***'
         SPACE 1
XXAS4HD  DC    CL121'0  IM LOCATION    INSTRUCTION :  IM = PSW BITS 32-#
               39(ILC,CC,MASK) BEFORE INSTRUCTION EXECUTED AT PROGRAM L#
               OCATION SHOWN'
         SPACE 1
         ORG   XXLABEL+1           ORG BACK INTO MAIN LABEL
XXAS5HD  DS    C'  '               SPACING
XXAS5CC  DS    XL2                 ILC-CC-PM
         DS    C'  '               SPACING
XXAS5AD  DS    XL6                 PSW ADDRESS
         DS    CL5' '
XXAS5I1  DS    XL5                 1ST HALFWORD OF INSTRUCTION
XXAS5I2  DS    XL5                 2ND HALFWORD OF INSTRUCTION
XXAS5I3  DS    XL5                 3RD HALFWORD OF INSTRUCTION
XXAS5$L  EQU   *-XXAS5HD           DEFINE LENGTH OF THIS MESSAGE
         ORG   ,                   RESTORE NORMAL LOCATION CTR
XXAS5P   DC    C'<-- LAST INSTRUCTION DONE - PROBABLE CAUSE OF TERMINAT#
               ION'                BOMB POINTER MSG
         SPACE 1
XXAS6HD  DC    C'1 USER STORAGE'   HEADER 2ND PAGE OF DUMP
         LTORG
         AIF   (NOT &$EXINT).XXASNXT
         SPACE 3
*              THESE LABELS ARE ONLY USED IN THE LAST 10 BRANCH       *
*              INSTRUCTION COMPLETION MESSAGE                         *
         SPACE 2
XXAS7HD  DC    CL121'-** TRACE OF LAST 10 BRANCH INSTRUCTIONS EXECUTED:X
                PSW BITS SHOWN ARE THOSE BEFORE CORRESPONDING INSTRUCTIX
               ON DECODED ***'
.XXASNXT ANOP
         DROP  R10,R13             DROP REGISTERS NO LONGER USED CPP
         TITLE '*** XXXXSPIE  ASSIST INTERRUPTS COMMUNICATIONS ***'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> CSECT: XXXXSPIE       INTERRUPT CONTROL & COMMUNICATIONS         *
*                                  SCOTT A SMITH - FALL 1971.         *
*        THIS IS CALLED ONLY FROM THE MACRO EXPANSION OF $SPIE.  IT   *
*        CONTAINS THE ONLY MACROS THAT CAUSE LINKAGE TO BE SET UP     *
*        BETWEEN THE SUPERVISOR AND THE EXIT ROUTINE FOR INTERRUPT    *
*        HANDLING.  THE INITIAL COMMUNICATIONS ARE NEVER MADE UNLESS  *
*        AT LEAST ONE $SPIE IS EXPANDED.  ONLY ONE ACTUAL SUPERVISOR  *
*        CALL IS NECESSARY.  ALL OTHER $SPIE EXPANSIONS JUST MANI-    *
*        PULATE THE CONTROL BLOCKS GENERATED BY THAT EXPANSION.       *
*        **NOTE**  XXXXSPIE CONTAINS THE ONLY OCCURENCES OF THE       *
*        MACROS  SPIE (OS) OR STXIT (DOS)                             *
*        NAMES:  XSP-----                                             *
*                                                                     *
*        THIS ENTRY HANDLES THE UPDATING OF THE POINTER TO THE        *
*        ACTIVE XSPIEBLK .                                            *
*        ENTRY CONDITIONS                                             *
*   R1 = @ NEWLY CREATED ACTIVE XSPIEBLK (OR RESTORED XSPIEBLK)       *
*   R14= RETURN ADDRESS                                               *
*   R15= @ ENTRY POINT                                                *
*        EXIT CONDITIONS                                              *
*   R1 = @ LAST PREVIOUS ACTIVE XSPIEBLK                              *
*      = 0 , IF NO PREVIOUS XSPIEBLK'S EXISTED                        *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
XXXXSPIE CSECT
         $DBG  ,NO                 SHOW NO DEBUG CODE - $SAVE/$RETURN
         USING XXXXSPIE,REP        SHOW OF ENTRY POINT REGISTER USING
         L     R0,XSPACBLK         GET CURRENT XSPIEBLK @
         ST    R1,XSPACBLK         SAVE THE NEW ACTIVE XSPIEBLK @
         LR    R1,R0               RETURN PREVIOUS XSPIEBLK @
         BR    RET                 ACTIVE XSPIEBLK PTRS CHANGED, RETURN
         DROP  REP                 INFORM ASSEMBLER NO LONGER USING R15
         SPACE 2
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> ENTRY: XXXXSPIN     INITIALIZATION OF INTERRUPT COMMUNICATIONS   *
*        THE ONLY NECESSARY SPIE(OS) OR STXIT(DOS) IS EXECUTED HERE   *
*        TO CATCH ALL INTERRUPTS AND TO REQUEST THE RETURN OF CONTROL *
*        TO THE SAME EXIT ROUTINE HANDLER.  AS SUBSEQUENT $SPIE'S     *
*        ARE ISSUED, NO SVC IS NEEDED; JUST AN ANALYSIS OF THE        *
*        STATUS OF THE ACTIVE CONTROL BLOCK(XSPIEBLK) BY THE COMMON   *
*        INTERRUPT EXIT ROUTINE.                                      *
*        USES MACROS: SPIE(OS) OR STXIT(DOS),$SAVE,$RETURN            *
*        ENTRY CONDITIONS                                             *
*   R14= RETURN ADDRESS                                               *
*   R15= @ ENTRY POINT                                                *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         ENTRY XXXXSPIN
XXXXSPIN $SAVE RGS=(R14-R12),SA=XSPYSAVE
         XC    XSPACBLK,XSPACBLK   SET PREVIOUS XSPIEBLK PTR TO ZERO
         AIF   (&$ASMLVL).XSPOS    SKIP IF WE ARE IN OS GENERATION
         STXIT PC,XXXXSPEX,XSPYSAVE    CATCH ALL PROGRAM CHECKS
.XSPOS   AIF   (NOT &$ASMLVL).XSPDOS   SKIP IF SET BY DOS GENERATION
         SPIE  XXXXSPEX,((1,15))   CATCH ALL PROGRAM EXCEPTIONS
.XSPDOS  ANOP
         $RETURN RGS=(R14-R12)     RETURN AFTER ESTABLISHING COMMUNCTS
         SPACE 2
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> INSUB: XXXXSPEX              INTERRUPT EXIT ROUTINE              *
*        RECEIVES CONTROL FOR ALL INTERRUPTS, REGARDLESS OF @ ON      *
*        MOST PREVIOUS $SPIE CALL.  XXXXSPEX MONITORS THE INTERRUPT   *
*        HANDLING.  IT FIRST DETERMINES IF THIS PARTICULAR INTERRUPT  *
*        WAS TO BE CAUGHT, SINCE ALL REAL INTERRUPTS WILL EFFEC-      *
*        TIVELY BE NAILED.  IF IT WAS NOT TO BE CAUGHT, THEN CONTROL  *
*        IS RETURNED TO THE SUPERVISOR TO REINITIALIZE EXECUTION      *
*        WHERE IT WAS LEFT OFF.   ***NOTE***   IT MIGHT BE DESIRABLE  *
*        TO INSERT CODE IN THIS CASE TO EITHER PRINT OUT A MESSAGE    *
*        OR TO TAKE SOME OTHER ACTION.  THE CALLABLE EXIT(IF ANY) IS  *
*        GIVEN CONTROL , BUT IT MUST RETURN CONTROL.  UPON RETURN     *
*        THE PSW IS CHANGED (IF EXIT @ GIVEN) AND SUPERVISOR GETS CNTL*
*        USES DSECTS: XSPIEBLK                                        *
*        THIS ROUTINE PRESERVES THE CONTENTS OF R2-R12 FOR THE        *
*        INSPECTION BY THE CALLABLE EXIT ROUTINE.                     *
*        ENTRY CONDITIONS                                             *
*   R1 = @ OF OS PIE BLOCK (*DOS*MOST LOAD @ INTRPT SAVEAREA(PSW)     *
*   R14= RETURN ADDRESS                                               *
*   R15= @ ENTRY POINT                                                *
*        EXIT CONDITIONS                                              *
*   R1 = @ OF OS PIE BLOCK OR @ OF DOS PSW & SAVE.  **NOTE** CALLABLE *
*        EXIT ROUTINE MUST NOT CHANGE THE CONTENTS OF REGISTER #1     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         AIF   (&$ASMLVL).XSPNBAL  SKIP IF UNDER OS GENERATION
XXXXSPEX BALR  R15,0               ESTABLISH TEMP DOS ADDRESSABILITY
         USING *,R15               INFORM OF USING
         LA    R1,XSPYSAVE         GET DOS @ OF PSW & SAVE AREA
.XSPNBAL AIF   (NOT &$ASMLVL).XSPADDR  SKIP IF UNDER DOS GENERATION
         USING *,R15               SHOW OF ENTRY POINT REG USING
XXXXSPEX LA    R1,4(R1)            GET R1 <- OS PSW IN PIEBLOCK
.XSPADDR ANOP
         STM   R13,R15,XSPSVRES    STORE THE REGISTERS
         LA    R13,XSPYSAVE        @ OUR SAVE AREA, FOR SAFETY
         L     R14,XSPACBLK        LOADS @ OF ACTIVE XSPIEBLK
         USING XSPIEBLK,R14        DSECT USING FOR CONTROL BLOCK
         LTR   R14,R14             SEE IF A $SPIE IS IN EFFECT
         BZ    XSPNOSPY            NO SPIE WAS IN EFFECT AT PRESENT
         L     R0,=X'80000000'     LOAD 1 BIT IN HIGH ORDER END
         MVC   *+8(2),2(R1)        PLACE INT. # INTO L' NEXT INSTRUCTN
         SRL   R0,$                GET BIT TO MASKABLE POSITION
         N     R0,XSPINTRP         AND WITH INTERRUPT TYPES TO BE CAUGT
         BZ    XSPNTCTH            THIS INTERRUPT WAS NOT TO BE CAUGHT
         L     R0,XSPEXRTN         GET CALLABLE EXIT @
         LTR   R0,R0               WAS ONE ACTUALLY SUPPLIED?
         BZ    XSPNOCLX            IF NONE, THEN DON'T TRY TO CALL
         LR    R15,R0              MOVE @ TO R15 FOR BALR, WATCH ADDRES
         BALR  R14,R15             GO TO CALLABLE EXIT: MUST RETURN
         USING *,R14               NOTE TEMP USING FOR REGAIN OF R15
         L     R15,XSPSVRET+4      GET ORIGINAL ENTRY POINT ADDRESS
         USING XSPIEBLK,R14        INFORM OF DSECT USING AGAIN
         AIF   (&$ASMLVL).XSPNRES  SKIP REGISTER SAVE IF UNDER OS
         SPACE
*        UNDER DOS, REGS THAT WERE CHANGED BY CALLABLE EXIT MUST BE   *
*        UPDATED IN SAVE AREA TO SHOW NEW VALUES OVER IN EXIT ROUTINE *
         STM   R2,R12,XSPYSAVE+16  SAVE NEW VALUES FROM CALLABLE EXIT
.XSPNRES ANOP
         L     R14,XSPACBLK        REGAIN POINTER TO XSPIEBLK
XSPNOCLX L     R0,XSPCLBEX         GET @ OF EXIT ROUTINE
         LTR   R0,R0               WAS IT EVER SUPPLIED?
         BZ    XSPIERTN            DON'T CALL, JUST RETURN
         MVC   5(3,R1),XSPCLBAD    CHANGE THE PSW ADDRESS FIELD
         B     XSPIERTN            GO TO RETURN TO SUPERVISOR
XSPNTCTH EQU   *                   COME HERE IF NO SPIE SET
******** AIF   (&$DEBUG).XXSPNBG   SKIP IF NOT DEBUG MODE
         L     R14,=V(VWXTABL)     GET @ ASSEMBLER TABLE
         USING AVWXTABL,R14        NOTE PTR THERE
         XSNAP LABEL='ASSIST ABEND-SEND DECK TO SYSTEMS: 3-12; PSW,14-2#
               ; AVTAB',STORAGE=(*0(R1),*28(R1),*AVADDLOW,*AVWXEND) CPP
         DROP  R14                 ZAP TEMPORARY USING
.XXSPNBG DC    H'0'                BOMB HERE WITH S0C1
XSPNOSPY EQU   *                   MAY WISH TO PRINT A MSG.
XSPIERTN DS    0H
         L     R13,XSPSVRES        RELOAD CORRECT R13
         AIF   (NOT &$ASMLVL).XSPRST        DON'T RESTORE R1 IF NOT OS
         S     R1,=F'4'            RESTORE OS R1 TO POINT TO PIE BLOCK
         L     R14,XSPSVRET        GET RETURN ADDRESS
         BR    R14                 RETURN CONTROL TO SUPERVISOR
.XSPRST  AIF   (&$ASMLVL).XSPNEXT  SKIP IF OS, SINCE NO EXIT PC
         EXIT  PC                  RETURN CONTROL TO SUPERVISOR
.XSPNEXT ANOP
XSPACBLK DC    F'-1'               ACTIVE XSPIEBLK POINTER
XSPYSAVE DC    18F'-1'             SAVEAREA FOR REGS & DOS INTERRUPTS
XSPSVRES DC    F'-1'               FOR REG 13
XSPSVRET DC    2F'-1'              FOR TEMP LOC. OF RET & REP REGS
         LTORG
         SPACE 2
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: XSPIEBLK    INTERRUPT COMMUNICATIONS CONTROL BLOCK        *
*        THIS BLOCK CONTAINS EXIT ADDRESSES AND INTERRUPT MASKS FOR   *
*        USE IN HANDLING THE 15 PROGRAM EXCEPTIONS.  THE INTERRUPT    *
*        MASK IS EXTENDED TO A FULLWORD FOR EASE OF TESTING AGAINST   *
*        THE INTERRUPTS THAT WERE DESIRED TO BE TRAPPED.  THE EXIT    *
*        ADDRESS IS OF LENGTH 3 FOR CHANGING THE PSW(ONLY 3 BYTE @    *
*        LOCATION:  INSIDE $SPIE MACRO EXPANSION                      *
*        GENERATION:  ONE XSPIEBLK IS GENERATED FOR EVERY $SPIE       *
*            EXPANSION EXCEPT LINKAGE TERMINATION & RESTORATION       *
*        NAMES:  XSP-----                                             *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
XSPIEBLK DSECT
XSPCLBEX DS    C                   ALIGNMENT FOR VL3 PSW (@ PORTION)
XSPCLBAD DS    VL3                 @ OF INTERRUPT EXIT ROUTINE
XSPEXRTN DS    VL4                 @ OF CALLABLE EXIT ROUTINE
XSPINTRP DS    BL2                 POSSIBLE INTERRUPT MASK BITS
         DS    BL2'0'              TRAILING ZEROES FOR EASY TESTING
         TITLE '*** BROPS2 - BASE REGISTER OPERATIONS - PASS 2 ***'
**--> CSECT: BROPS2   2   ALL BASE REGISTER OPERATIONS - ALL PASS 2 . .
*.       USES DSECTS: AVWXTABL                                        .
*.       USES MACROS: $RETURN,$SAVE                                   .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
BROPS2   CSECT
         $DBG  A0,SNAP
         ENTRY BRINIT,BRUSIN,BRDROP,BRDISP
         USING AVWXTABL,RAT        NOTE MAIN USING
         SPACE 2
**--> ENTRY: BRINIT   2   INITIALIZE BASE REGISTER TABLES . . . . . . .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
BRINIT   $SAVE SA=NO
         MVC   BRVALS(4*16),AWZEROS         ZERO OUT VALUE /ID TABLE
         $RETURN SA=NO
         SPACE 2
**--> ENTRY: BRUSIN   2   ENTER A REGISTER-VALUE PAIR . . . . . . . . .
*.       ENTRY CONDITIONS                                             .
*.  RA = NUMBER OF REGISTER FOR WHICH USING TO BE SET UP = 0-15       .
*.  RB = ADDRESS DECLARED IN USING FOR GIVEN REGISTER = 0-2**24-1     .
*.  RC = ESDID OF THE USING VALUE, IN LOW ORDER BYTE = 1-255          .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
BRUSIN   $SAVE SA=NO
         SLL   RA,2                REG #*4 FOR FULLWORD INDEXING
         ST    RB,BRVALS(RA)       STORE VALUE OF REG IN RIGHT SLOT
         STC   RC,BRVALS(RA)       STORE ID IN HI-ORDER BYTE
         $RETURN SA=NO
         SPACE 2
**--> ENTRY: BRDROP   2   DROP A REGISTER FROM USING. . . . . . . . . .
*.       ENTRY CONDITIONS                                             .
*.  RA = NUMBER OF REGISTER TO BE DROPPED FROM USING - = 0-15         .
*.       EXIT CONDITIONS                                              .
*.  RB = 0    THE REGISTER WAS CURRENTLY USABLE                       .
*.  RB = ^0   THE REGISTER WAS NOT CURRENTLY IN USE                   .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
BRDROP   $SAVE SA=NO
         SLL   RA,2                REG# * 4 FOR INDEX TO TABLE
         LA    RB,BRVALS(RA)       SET RB^=0, @ WORD FOR DESIRED REG
         CLI   0(RB),0             WAS THE REG IN USE
         BE    BRDRRET             NO,BRANCH,LEAVING RB^=0-ERROR
         MVI   0(RB),0             SET ID = 0, DEFINITELY DROPPING REG
         SR    RB,RB               SET RB=0 TO SHOW OK
BRDRRET  $RETURN SA=NO
         EJECT
**--> ENTRY: BRDISP   2   GIVEN VALUE&ESDID, RETURN BASE-DISPLACEMENT .
*.       ENTRY CONDITIONS                                             .
*.  RA = ADDRESS VALUE TO BE DECOMPOSED TO BASE-DISPLACEMENT (24 BITS).
*.  RB = ESDID OF ADDRESS TO BE DECOMPOSED - LOW ORDER BYTE           .
*.       VALUE IS FROM 1-255. 0 CAN BE USED TO MARK NONUSABLE.        .
*.       EXIT CONDITIONS                                              .
*.  RA = BASE-DISPLACEMENT FORM OF ADDRESS, IF ADDRESSABLE            .
*.  RB = 0    NORMAL RETURN - ADDRESS WAS DECOMPOSABLE                .
*.     = ^0   ADDRESSIBILITY ERROR(NO REG,OR DISP TOO LARGE)          .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
BRDISP   $SAVE RGS=R14,SA=NO
         STC   RB,BRCESD+1         PLACE ESDID INTO CLI INSTRUCTION
         SLL   RB,24               SHIFT ID TO HI-ORDER BYTE OF RB
         ALR   RA,RB               PUT SECITON ID IN WITH VALUE
         LM    RC,RE,BRRGSCDE      GET INITIAL VALUES FOR RC,RD,RE
         SR    R14,R14             R14 = 0 ==> NO REGISTER FOUND YET
         SPACE 1
*              THE FOLLOWING LOOP EXECUTED 16 TIMES, CHECK EACH REG   *
BRCESD   CLI   0(RC),$CHN          COMPARE INCOMING ESDID WITH 1 OLD
         BNE   BRLOOP              IF NOT EQUAL,GO TO NEXT
         CL    RA,0(,RC)           COMP INCOMING VALUE TO ONE IN USE RG
         BL    BRLOOP              REGISTER HIGHER THAN ADDRESS-NO USE
         CL    RB,0(,RC)           COMP PREVIOUS BEST REG TO NEXT ONE
         BH    BRLOOP              IF PREVIOUS BEST > NEW, SKIP
         L     RB,0(,RC)           GET NEW BEST ID/VALUE
         LR    R14,RC              SAVE FOR INDEX TO BEST REG
BRLOOP   BXLE  RC,RD,BRCESD        BUMP TO NEXT REG, GO BACK TO CHK
         SPACE 1
         S     R14,BRRGSCDE        S R14,=A(BRVALS) = 4* REG #, IF OK
         BM    BRNOGOOD            IF R14 WAS =0, NO USABLE REG, BRANCH
         SLR   RA,RB               COMPUTE DISPLACEMENT FOUND
         C     RA,AWF4095          C RA,=F'4095' -MAKE SURE NOT BOG
         BH    BRNOGOOD            JUMP IF ILLEGALLY BIG
         SLL   R14,10              SHIFT REG NUMBER TO RIGHT SPOT
         AR    RA,R14              PUT BASE AND SIP TOGETHER
         SR    RB,RB               ZERO TO SHOW SUCCESSFUL COMPLETE
BRRET    $RETURN RGS=R14,SA=NO
BRNOGOOD LR    RB,RD               RB = 4 ==> ADDRESSIBLITY ERROR
         B     BRRET               GO RETURN TO CALLER
         SPACE 1
BRRGSCDE DC    A(BRVALS,4,BRVALS+60)   2NDEX,INCREM,LIMIT-REGS RC,RD,RE
* * * * * INTERNAL VARIABLES                                          *
         DS    0D                  FOR ALIGNEMENT
BRVALS   DS    16F                 TABLE OF USABLE VALUES IN REGS
*              1ST BYTE OF EACH HAS ID, RESTS HAVE ADDRESS.
         DROP  RAT,REP             CLEAN UP USING
         TITLE '*** CACONS - A-TYPE CONSTANT PROCESSING ***'
**--> CSECT: CACONS   1-2 PROCESS A-TYPE ADDRESS CONSTANTS. . . . . . .
*.       USES DSECTS: AVWXTABL                                        .
*.       USES MACROS: $CALL,$RETURN,$SAVE                             .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CACONS   CSECT
         $DBG  A0,SNAP
         ENTRY CACON1,CACON2
         USING AVWXTABL,RAT        NOTE MAIN USING
         SPACE 2
**--> ENTRY: CACON1     SCAN ACON, BUT DO NOT ASSEMBLE VALUE. . . . . .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER (ADDRESS OF 1ST CHAR AFTER PREVIOUS DELIMETER)  .
*.       EXIT CONDITIONS                                              .
*.  RA = SCAN POINTER (ADDRESS OF DELIMITER STOPPING SCAN, OR ERROR)  .
*.  RB = 0    CONSTANT WAS LEGAL, NO ERRORS                           .
*.  RB = NONZERO  ==> ILLEGAL CONSTANT ($ERINVCN)                     .
*.       CALLS SCANCO                                                 .
*.       **NOTE** EXPRESSION ENDING IN  )  INSIDE MULTIPLE CONSTANT   .
*.       WILL BE PROCESSED IMPROPERLY, SUCH AS  DC  A(B+(C),D)  .     .
*.       THE CHARACTERS  C)  ARE TREATED AS END OF THE ACON.          .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CACON1   $SAVE RGS=(R14-R1),BR=R1,SA=CACOSAVE
         LR    R0,RA               SAVE ORIG SCAN POINTER
         $CALL SCANCO              SCAN TO COMMA OR BLANK
         LTR   RB,RB               WAS THERE ERROR
         BNZ   CAC1RET             YES-ERROR-RETURN WITH IT
         CR    R0,RA               WAS THERE A NULL CONSTANT
         BE    CAC1ERR             YES-ERROR-BRANCH
         SPACE 1
         BCTR  RA,0                BACK UP SCAN PTR 1 BYTE
         CLI   1(RA),C','          WAS SCAN STOPPER A COMMA
         BNE   CAC1RET             NO, MUST BE END OF CONST: EXPR)
         SPACE 1
         CLI   0(RA),C')'          MAKE SURE THS IS RIGHT PAREN
         BE    CAC1RET             SKIP IF SO
         LA    RA,1(RA)            CONST ENDED WITH EXPR, RESET PTR=>,
         B     CAC1RET             GO EXIT
CAC1ERR LA     RB,$ERINVCN         NULL CONSTANT
CAC1RET  $RETURN RGS=(R14-R1)
         EJECT
**--> ENTRY: CACON2   1-2 SCAN ACON, ASSEMBLE VALUE . . . . . . . . . .
*.  RA = SCAN POINTER (ADDRESS OF 1ST CHAR AFTER PREVIOUS DELIMETER)  .
*.  RB = LENGTH-1 OF 1 CONSTANT OF 1 OPERAND TO BE ASSEMBLED          .
*.       EXIT CONDITIONS                                              .
*.  RA = SCAN POINTER (ADDRESS OF DELIMITER STOPPING SCAN, OR ERROR)  .
*.  RB = 0    CONSTANT WAS LEGAL, NO ERRORS                           .
*.  RB = NONZERO VALUE - ERROR CODE (FROM EVALUT)                     .
*.     = $ERRELOC  IF SECTION ID IS A DSECT, WHICH IS NOT ALLOWED.    .
*.  RC = ADDRESS OF PROPERLY ASSEMBLED CONSTANT                       .
*.  RD = ESDID OF CONSTANT, IF =0 ==> ABSOLUTE EXPRESSION             .
*.       CALLS EVALUT                                                 .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CACON2   $SAVE RGS=(R14-R0),BR=R13,SA=CACOSAVE
         LR    R0,RB               SAVE THE LENGTH-1 FOR ASSEMBLY
         $CALL EVALUT              CALL EXPRESSION EVALUATOR
         LTR   RB,RB               WAS THERE ERROR
         BNZ   CAC2RET             ERROR-RETURN
*              CHECK TO MAKE SURE DON'T DC  A(DSECT SYMBOL)
         STC   RD,AVFWORK1         STORE FOR TEST OF EVEN/ODD
         TM    AVFWORK1,$ESDSECT   TEST FOR ODD
         BZ    *+8                 NO, EVEN=> CSECT TYPE OR ABS TERM-OK
         LA    RB,$ERRELOC         NO GOOD- FLAG ERROR-DSECT RELOC
         ST    RC,AVCONBLD         STORE THE VALUE
         LCR   RE,R0               GET NEGATIVE OF LENGTH-1 FOR ASSMBLY
         LA    RC,AVCONBLD+3(RE)   GET REAL STARTING ADDRESS
CAC2RET  $RETURN RGS=(R14-R0)
         DROP  RAT,R1,R13
         TITLE '*** CBCONS - SCAN AND/OR ASSEMBLE BINARY CONSTANTS ***'
**--> CSECT: CBCONS   1-2 PROCESS BINARY CONSTANTS. . . . . . . . . . .
*.       USES DSECTS: AVWXTABL                                        .
*.       USES MACROS: $RETURN,$SAVE                                   .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CBCONS   CSECT
         $DBG  A0,SNAP
         ENTRY CBCON1,CBCON2
         USING AVWXTABL,RAT        NOTE MAIN TABLE USING
         SPACE 2
**--> ENTRY: CBCON1   1   SCAN B CONSTANT, DO NOT ASSEMBLE. . . . . . .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER (ADDRESS OF 1ST CHAR AFTER PREVIOUS DELIMETER)  .
*.       EXIT CONDITIONS                                              .
*.  RA = SCAN POINTER (ADDRESS OF DELIMITER STOPPING SCAN, OR ERROR)  .
*.  RB = 0    CONSTANT WAS LEGAL, NO ERRORS                           .
*.  RB = NONZERO VALUE FOR ERROR CODE - INVALID CONSTANT - ($ERINVCN) .
*.  RC = NUMBER OF BYTES REQUIRED FOR CONSTANT                        .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CBCON1   $SAVE RGS=(R1-R2),SA=NO
         MVC   AWTDECT+C'2'(8),AWBLANK      CAUSE 2-9 TO BE ^=0
         SR    R1,R1               CLEAR SO TRT WORKSA RIGHT
         TRT   0(256,RA),AWTDECT   MUST ENCOUNTER DELIMITER (3CRD LIM)
         MVC   AWTDECT+C'2'(8),AWZEROS+C'2' REZERO TRT TABLE
         LA    RC,7(R1)            MOVE ENDING PTR,ROUND UP
         SR    RC,RA               GET # 0'S & 1'S,ROUNDED UP TO 8
         LR    RA,R1               MOVE ENDING POINTER FOR RETURN
         CLI   0(RA),C''''         WAS DELIMIER ' LIKE SUPPOSED TO
         BNE   CB1ERR              NO, ERROR, INVALID DELIMITER
         SRA   RC,3                DIVIDE BY 8, GET # BUTES REQUIRED
         BZ    CB1ERR              IF 0, CONST WAS B'', ERROR,BRANCH
         SR    RB,RB               SHOW NO ERROR
CB1RET   $RETURN RGS=(R1-R2),SA=NO
         SPACE 1
CB1ERR   LA    RB,$ERINVCN         INVALID CONSTANT -SET FLAG FOR RETUR
         B     CB1RET              GO RETURN, SHOWING ERROR
         EJECT
**--> ENTRY: CBCON2   1-2 ASSEMBLE BINARY CONSTANT. . . . . . . . . . .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER (ADDRESS OF 1ST CHAR AFTER PREVIOUS DELIMETER)  .
*.  RB = LENGTH-1 OF 1 CONSTANT OF 1 OPERAND TO BE ASSEMBLED          .
*.       EXIT CONDITIONS                                              .
*.  RA = SCAN POINTER (ADDRESS OF DELIMITER STOPPING SCAN, OR ERROR)  .
*.  RC = ADDRESS OF PROPERLY ASSEMBLED CONSTANT                       .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CBCON2   $SAVE RGS=(R0-R2),SA=NO
         STC   RB,*+5              STORE LENGTH-1 INTO NEXT MVC
         MVC   AVCONBLD($CHN),AWZEROS       ZERO OUT WHOLE AREA
         SR    R1,R1               CLEAR FOR COMING TRT
         L     RD,AWFM1            =F'-1' FOR DECREMENTING LATER
         TRT   0(256,RA),AWTDECT   WE CHECKED IN PASS 1, LOOK FOR DLM
         LA    RE,0(RD,RA)         GET LIMIT FOR BXH, @ 1ST ' OF CONST
         LR    RA,R1               GET @  OF ENDING '
         BXH   R1,RD,CB2L2         DECREM LAST PTR, ENTER LOOP RIGHT
         SPACE 1
CB2L1    BCT   R2,CB2L3            DECREMENT BIT POSITION POINTER,BRNCH
         STC   R0,AVCONBLD(RB)     STORE ASSEMBLED BYTE INTO POSITION
         AR    RB,RD               SUBTRACT 1 FROM BYTE COUNT
         BM    CB2RETA             IF <0, WE ARE DONE, QUIT
         SPACE 1
*              INITIALIZATION - 1 TIME FOR EACH BYTE REQUIRED         *
CB2L2    SR    R0,R0               CLEAR FOR BUILDING UP BYTE
         LA    R2,8                # BITS IN 1 BYTE
         LCR   RC,RD               RC = 1, FOR SHIFTING BIT TO ADD
         SPACE 1
CB2L3    CLI   0(R1),C'0'          IS NEXT CHAR A 0
         BE    *+6                 SKIP ADDING BIT IN, IF SO
         ALR   R0,RC               ADD 1 BIT IN IN RIGHT BIT POSITION
         ALR   RC,RC               == SLL RC,1 - SHIFT 1 BIT OVER FOR N
         BXH   R1,RD,CB2L1         DECREMENT POINTER, JUMP TO CHECK
         SPACE 1
         STC   R0,AVCONBLD(RB)     RAN OUT OF DIGITS, STORE THE BYTE
CB2RETA  LA    RC,AVCONBLD         GET @ BEGINNING OF ASSEMBLED CONST
CB2RET   $RETURN RGS=(R0-R2),SA=NO
         DROP  RAT,REP             KILL USINGS
         TITLE '*** CCCONS - SCAN AND/OR ASSEMBLE C-TYPE CONSTANTS ***'
**--> CSECT: CCCONS   1-2 PROCESS CHARACTER TYPE CONSTANTS. . . . . . .
*.       USES DSECTS: AVWXTABL                                        .
*.       USES MACROS: $RETURN,$SAVE                                   .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CCCONS   CSECT
         $DBG  A0,SNAP
         ENTRY CCCON1,CCCON2
         USING AVWXTABL,RAT        NOTE MAIN TABLE USING
         SPACE 2
**--> ENTRY: CCCON1   1   SCAN,RETURN LENGTH,DO NOT ASSEMBLE. . . . . .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER (ADDRESS OF 1ST CHAR AFTER PREVIOUS DELIMETER)  .
*.       EXIT CONDITIONS                                              .
*.  RA = SCAN POINTER (ADDRESS OF DELIMITER STOPPING SCAN, OR ERROR)  .
*.  RB = 0    CONSTANT WAS LEGAL, NO ERRORS                           .
*.  RB = NONZERO VALUE FOR ERROR CODE - INVALID CONSTANT - ($ERINVCN) .
*.  RC = NUMBER OF BYTES REQUIRED FOR CONSTANT                        .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CCCON1   $SAVE SA=NO
         SR    RC,RC               INDEX FOR BXLE, WILL GO FROM 0==>255
         LA    RD,1                INCREMENT FOR BXLE FOR LOOP
         LA    RE,255              LIMIT=LENGTH OF MAXIMUM CONSTANT
         SPACE 1
*              INITIALIZATION DONE, NOW DO CHECKING LOOP              *
CC1LOOP  CLI   0(RA),C''''         IS THE NEXT CHAR A '
         BNE   CC1CHK2             NO, GO CHECK FOR & OR OTHER
         CLI   1(RA),C''''         IS NEXT CHARACTER & '
         BNE   CC1OUT              NO IT ISNT, MUST BE END OF CONSTANT
         BXH   RA,RD,CC1LOOPA      BUMP SCAN POINTER 1 AND BRANCH
         SPACE 1
CC1CHK2  CLI   0(RA),C'&&'         IS CHAR AN &
         BNE   CC1LOOPA            BRANCH IF NOT==> NORMAL CHARACTER
         AR    RA,RD               INCREMENT TO 2ND &,HOPEFULLY
         CLI   0(RA),C'&&'         MAKE SURE 2ND & IS THERE TOO
         BNE   CC1ERR              ERROR IF IT ISNT-BRANCH
         SPACE 1
CC1LOOPA AR    RA,RD               INCREMENT POINTER TO NEXT CHAR
         BXLE  RC,RD,CC1LOOP       CONTINUE LOOPING
         SPACE 1
CC1ERR   LA    RB,$ERINVCN         NOTE THIS IS AN INVALID CONSTANT
         B     CC1RET              RETURN, WITH ERROR
         SPACE 1
CC1OUT   LTR   RC,RC               MAKE SURE LENGTH OF CONST>0
         BZ    CC1ERR              NULL CONSTANT==>ERROR
         SR    RB,RB               CLEAR TO SHOW LEGAL CONSTANT
CC1RET   $RETURN SA=NO
         EJECT
**--> ENTRY: CCCON2   2   SCAN, ASSEMBLE. . . . . . . . . . . . . . . .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER (ADDRESS OF 1ST CHAR AFTER PREVIOUS DELIMETER)  .
*.  RB = LENGTH-1 OF 1 CONSTANT OF 1 OPERAND TO BE ASSEMBLED          .
*.       EXIT CONDITIONS                                              .
*.  RA = SCAN POINTER (ADDRESS OF DELIMITER STOPPING SCAN, OR ERROR)  .
*.  RC = ADDRESS OF PROPERLY ASSEMBLED CONSTANT                       .
*.  RD = LENGTH-1 OF CONSTANT (WAS IN RB ON ENTRY)              CPP
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CCCON2   $SAVE SA=NO
         LA    RD,1                FOR INCREMENT AND USEFUL CONST
         SR    RE,RE               CLEAR FOR COUNTER
*              **NOTE** BXH'S WORK OK SINCE RA>256 ALWAYS.
         SPACE 1
CC2LOOP  CLI   0(RA),C''''         IS CHAR A '
         BNE   CC2CHK2             BRANCH IF IT ISN'T
         CLI   1(RA),C''''         SEE IF NEXT 1 IS '
         BNE   CC2PAD              BRANCH==>HIT END OF CONST,PAD NEEDED
         BXH   RA,RD,CC2MOV        INCREMENT POINT TO 2ND '&JUMP
         SPACE 1
CC2CHK2  CLI   0(RA),C'&&'         IS CHAR AN &
         BNE   CC2MOV              JUMP IF IT IS NORMAL CHARACTER
         AR    RA,RD               INCREMENT TO POINT AT 2ND &
CC2MOV   IC    RC,0(RA)            GET THE CHARACTER
         STC   RC,AVCONBLD(RE)     SAVE THIS IN THE RIGHT PLACE IN CONS
         AR    RE,RD               INCREMENT NUMBER OF BYTES DONE
         BXH   RA,RD,CC2LOOP       INCREMENT AND JUMP BACK FOR NEXT
         SPACE 1
CC2PAD   LR    RD,RB               SAVE LENGTH-1 OF CONSTANT    CPP
         SR    RB,RE               RE=LENGTH-1 OF PAD, IF ANY   CPP
         BM    CC2RETA             IF <0, NO PAD REQUIRED, QUIT
         LA    RE,AVCONBLD(RE)     RE=@ OF FIRST BYTE TO BLANK  CPP
         STC   RB,*+5              STORE LENGTH INTO MVC
         MVC   0($CHN,RE),AWBLANK  PAD--BLANK OUT ENOUGH        CPP
         SPACE 1
CC2RETA  LA    RC,AVCONBLD         POINT TO BEGINNING OF ASSEMBLED CONS
CC2RET   $RETURN SA=NO
         DROP  RAT,REP             CLEAN UP USING
         TITLE '*** CDECNS - D AND E TYPE CONSTANT PROCESSING ***'
**--> CSECT: CDECNS   1-2 PROCESS D&E TYPE CONSTS . . . . . . . . . . .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CDECNS   CSECT
         $DBG  A0,SNAP
         USING AVWXTABL,RAT        NOTE MAIN TABLE USING
         ENTRY CDECN1,CDECN2
         SPACE 2
**--> ENTRY: CDECN1   1   SCAN, BUT DO NOT ASSEMBLE D OR E TYPE CONSTS.
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER (ADDRESS OF 1ST CHAR AFTER PREVIOUS DELIMETER)  .
*.       EXIT CONDITIONS                                              .
*.  RA = SCAN POINTER (ADDRESS OF DELIMITER STOPPING SCAN, OR ERROR)  .
*.  RB = 0    CONSTANT WAS LEGAL, NO ERRORS                           .
*.  RB = NONZERO VALUE FOR ERROR CODE - INVALID CONSTANT - ($ERINVCN) .
*.       CALLS CDECN2                                                 .
*.       USES DSECTS: AVWXTABL                                        .
*.       USES MACROS: $RETURN,$SAVE                                   .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CDECN1   EQU   *                   USE SAMEENTRY AS CDECN2 FOR THIS
         EJECT
**--> ENTRY: CDECN2   1-2 SCAN,ASSEMBLE D&E TYPE CONSTANTS. . . . . . .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER (ADDRESS OF 1ST CHAR AFTER PREVIOUS DELIMETER)  .
*.  RB = LENGTH-1 OF 1 CONSTANT OF 1 OPERAND TO BE ASSEMBLED          .
*.       EXIT CONDITIONS                                              .
*.  RA = SCAN POINTER (ADDRESS OF DELIMITER STOPPING SCAN, OR ERROR)  .
*.  RB = 0    CONSTANT WAS LEGAL, NO ERRORS                           .
*.  RB = NONZERO VALUE FOR ERROR CODE - INVALID CONSTANT - ($ERINVCN) .
*.  RC = ADDRESS OF PROPERLY ASSEMBLED CONSTANT                       .
*.       CALLS SDDTRM                                                 .
*.       USES DSECTS: AVWXTABL                                        .
*.       USES MACROS: $CALL,$RETURN,$SAVE                             .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         SPACE 1
* * * * * REGISTER ALLOCATION - CDECN2  * * * * * * * * * * * * * * * *
*   F0 = ACCUMULATOR FOR VALUE BUILT UP FOR CONSTANT                  *
*   F2 = FLOATING POINT 10.0                                          *
*   F4 = INITIALLY FLOATING POINT 10.0. MULTIPLIED BY 10 FOR FRACTION *
*   F6 = FLOATING POINT WORK REGISTER                                 *
*   RA = SCAN POINTER ADDRESS REGISTER, ADVANCED DURING SCAN          *
*   RC = UNUSED CURRENTLY                                             *
*   RD = UNUSED CURRENTLY                                             *
*   RE = 1  USEFUL CONSTANT IN ODD REGISTER, USED FOR BXH'ING.        *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         AIF   (&$FLOTA AND &$FLOTM).CD2FULL  SKIP IF OK TO HAVE D&E
*              RESTRICTED VERSION - IF NOT ACCEPTING FLOATING PT, OR
*              NOT ON MACHINE, ASSEMBLE ONLY D'0'  OR E'0'.
CDECN2   $SAVE SA=NO
         CLI   0(RA),C'0'          WAS IT LEGAL ZERO
         BNE   CD2INVCN            NO, BAD, WE ONLY ACCEPT 0
         LA    RA,1(RA)            BUMP SCAN PTR 1
         LA    RC,AWZEROS          SHOW @ 8 BYTES OF ZERO
         SR    RB,RB               SHOW ACCEPTABLE
CD2RET   $RETURN SA=NO             RETURN FROM SMALL MODULE
CD2INVCN LA    RB,$ERINVCN         SHOW INVALID, WASN'T 0
         B     CD2RET              RETURN WITH RROR
         DROP  RAT,REP             AVWXTABL,ENTRY BASE
         AGO   .CD2MINI            SKIP OVER REGULAR CODE
.CD2FULL ANOP
         SPACE 1
CDECN2   $SAVE SA=CDE2SAVE,RGS=(R14-R15),BR=R13
         MVI   CD2CON+1,X'F0'      MAKE NOOP TO BRANCH,INIT
         MVI   CD2FTEST+1,0        INIT THIS TEST TO NOOP
         LD    F0,AWD0             GET CONSTANT 0
         LD    F2,AWD10            GET USEFUL CONSTANT 10
         STD   F2,AVDWORK1         STORE VALUE WITH X'41' EXPONENT
         MVI   CD2PERI+1,0         INIT . BRANCH TO NOOP
         LDR   F4,F2               INIT F4 TO FLOATING PT 10 FOR DIVIDE
         LA    RE,1                FOR BXHING AND OTHER INCREMNTING
         MVI   CD2SIGN,X'20'       MAKE INST A LPDR-ASSUME + #
         CLI   0(RA),C'0'          DO WE START WITH DIGIT
         BNL   CD2DIG              YES,GO PROCESSES
         CLI   0(RA),C'.'          DO WE HAVE . AT BEGINNING
         BE    CD2PERI             GO THERE IF SO
         CLI   0(RA),C'+'          DO WE HAVE +
         BE    CD2INCA             YES,BUMP SCAN PTR,LEAVE SIGN OK
         CLI   0(RA),C'-'          DO WE HAVE -
         BNE   CD2INVCN            NO,MUST BE ERROR
         MVI   CD2SIGN,X'21'       MAKE INST LNDR SINCE NEGATIVE SIGN
CD2INCA  AR    RA,RE               BUMP SCAN PTR BEYOND SIGN
         EJECT
*              LOOP HEAD FOR SCANNING FOLLOWS.                        *
CD2LOOP  CLI   0(RA),C'0'          DO WE HAVE DIGIT
         BL    CD2NDIG             NO,BRANCH OUT
CD2DIG   MVI   CD2CON+1,0          MAKE BRANCH NOOP,SHOW 1 DIGIT,AT LEA
         UNPK  AVDWORK1+1(1),0(1,RA)   MOVE SWITCHED NIBBLES TO WORK
         NI    AVDWORK1+1,X'F0'    REMOVE EXTRA NIBBLE AT END, LEAVE #
CD2FTEST BC    $CHN,CD2LDIV        BRANCH OUT IF IN FRACTIONAL PART
         MDR   F0,F2               MULT ACCUMULATED VALUE BY 10
         AD    F0,AVDWORK1         ADD NEW VALUE INTO ACCUMUALTOR
         BXH   RA,RE,CD2LOOP       BUMP SCAN POINTER, GO FOR NEXT
         SPACE 1
CD2LDIV  LD    F6,AVDWORK1         GET VALUE OF NEXT DIGIT
         DDR   F6,F4               DIVIDE BY CURRENT POWER OF 10
         MDR   F4,F2               RAISE POWER OF 10 IN F4 BY ANOTHER
         ADR   F0,F6               ADD NEW VALUE IN
         BXH   RA,RE,CD2LOOP       BUMP SCAN PTR, GET NEXT
         SPACE 1
CD2NDIG  CLI   0(RA),C'.'          IS IT PERIOD
         BNE   CD2NOPR             NEITHER DIG NOR PERIOD
CD2PERI  BC    $CHN,CD2INVCN       IF WE COME HERE 2 TIMES-GO TO ERROR
         MVI   CD2PERI+1,X'F0'     MAKE NOOP A BRANCH TO ERROR
         MVI   CD2FTEST+1,X'F0'    MAKE BRANCH-SHOW FRACTION NOW
         BXH   RA,RE,CD2LOOP       BUMP SCAN PTR,GET NEXT
         EJECT
*              FOLLOWING SECTION SCANS FOR AN EXPONENT E AND SIGN
CD2NOPR  CLI   0(RA),C'E'          WAS THIS EXPONENT INDICATOR
         BNE   CD2DLM              NO,MUST BE DELIMITER
         AR    RA,RE               BUMP SCAN PTR BEYOND E
         MVI   CD2SIGNE,X'2C'      MAKE EXPONENT SIGN + (MDR INST)
         CLI   0(RA),C'0'          IS NUMBER THERE
         BNL   CD2EVAL             IF DECIMAL,GO EVALUATE
         CLI   0(RA),C'+'          WAS THERE A + SIGN
         BE    CD2INCB             YES,JUST BUMP SCAN PTR
         CLI   0(RA),C'-'          WAS THERE - SIGN
         BNE   CD2INVCN            NO,ERROR
         MVI   CD2SIGNE,X'2D'      -EXPONENT, MAKE INST A DDR
CD2INCB  AR    RA,RE               BUMP SCAN PTR BY 1
         SPACE 1
*              HAVE EXPONENT VALUE CONVERTED. ADJUST FRACTION BY IT.
CD2EVAL  $CALL SDDTRM
         LTR   RB,RB               WAS IT OK
         BNZ   CD2INVCN            NO,ERROR
         LTR   RC,RC               WAS EXPONENT 0
         BZ    CD2CON              YES,DON'T DO ANYTHING
*              THERE SHOULD BE SOME MAGNITUDE CHECKING HERE
CD2SIGNE MDR   $CHN+F0,F2          **MODIFIED** MUL OR DIV,DEP ON SIGN
         BCT   RC,CD2SIGNE         LOOP FOR REQUIRED AMOUNT
         SPACE 1
*              MAKE ENDING CHECKS, THEN RETURN TO CALLER.
CD2DLM   CLI   0(RA),C''''         WAS THIS ' DELIMITER
         BE    CD2CON              YES,OK
         CLI   0(RA),C','          WAS IT , DELIM
         BNE   CD2INVCN            INVALID DELIMITER
CD2CON   BC    $CHN,CD2INVCN       BRANCH OUT IF NO FRACTIO ANYWHERE
CD2SIGN  LPDR  $CHN+F0,F0          **MODIFIED** GET RIGHT SIGN
         STD   F0,CD2CONB          SAVE THIS VALUE
         LA    RC,CD2CONB          POINT TO THIS @
         SR    RB,RB               SHOW OK
CD2RET   $RETURN RGS=(R14-R15)
CD2INVCN LA    RB,$ERINVCN         SHOW ERROR
         B     CD2RET              RETURN
CD2CONB  DS    D                   SPACE FOR SAVING CONSTANT
         DROP  RAT,R13             KILL USINGS
.CD2MINI ANOP
         TITLE '*** CFHCNS - FULLWORD-HALFWORD FIXED CONSTANTS ***'
**--> CSECT: CFHCNS   1-2 PROCESS FULLWORD-HALFWORD CONSTANTS . . . . .
*.       USES DSECTS: AVWXTABL                                        .
*.       USES MACROS: $RETURN,$SAVE                                   .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CFHCNS   CSECT
         $DBG  A0,SNAP
         USING AVWXTABL,RAT        NOTE MAIN USING
         ENTRY CFHCN1,CFHCN2
         SPACE 2
**--> ENTRY: CFHCN1   1   SCAN CONST, DO NOT ASSEMBLE . . . . . . . . .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER (ADDRESS OF 1ST CHAR AFTER PREVIOUS DELIMETER)  .
*.       EXIT CONDITIONS                                              .
*.  RA = SCAN POINTER (ADDRESS OF DELIMITER STOPPING SCAN, OR ERROR)  .
*.  RB = 0    CONSTANT WAS LEGAL, NO ERRORS                           .
*.  RB = NONZERO VALUE FOR ERROR CODE - INVALID CONSTANT - ($ERINVCN) .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CFHCN1   $SAVE RGS=(R1-R2),SA=NO
         SPACE 1
*              INITIALIZE, CHECK FOR LEADING SIGN.  **NOTE** THIS     *
*        ROUTINE DOES NOT PERMIT DECIMAL POINTS INSIDE CONSTANTS.     *
         SR    R1,R1               CLEAR FOR ADDRESS INSERT
         CLI   0(RA),C'+'          PLUS SIGN CHECK
         BE    CFH1INC             GO BUMP SCAN POINTER IF SO
         CLI   0(RA),C'-'          MUST BE MINUS SIGN
         BNE   CF1TRT              SKIP IF NOT ASIGN
CFH1INC  LA    RA,1(RA)            INCR SCAN POINTER PAST + OR -
         SPACE 1
*              SCAN DECIMAL DIGITS, MAKE SURE THERE'S AT LEAST 1.
CF1TRT   TRT   0(11,RA),AWTDECT    SCAN FOR DELIMITER
         BZ    CFH1BIG             BRANCH IF TOO BIG
         SR    R1,RA               GET NUMBER OF CHARS
         BZ    CFH1INVC            NO DIGITS, SO INVLAID, LIKE F''
         SPACE 1
         AR    RA,R1               GET POINTER BACK
         SR    RB,RB               CLEAR TO SHOW OK
CFH1RET  $RETURN RGS=(R1-R2),SA=NO
         SPACE 1
CFH1INVC LA    RB,$ERINVCN         INVALID CONSTANT ERROR
         B     CFH1RET             GO RETUN
CFH1BIG  EQU   CFH1INVC            TOO BIG, USE JUST INVALID MESSAGE
         EJECT
**--> ENTRY: CFHCN2   2   ASSEMBLE F OR H CONST . . . . . . . . . . . .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER (ADDRESS OF 1ST CHAR AFTER PREVIOUS DELIMETER)  .
*.  RB = LENGTH-1 OF 1 CONSTANT OF 1 OPERAND TO BE ASSEMBLED          .
*.       EXIT CONDITIONS                                              .
*.  RA = SCAN POINTER (ADDRESS OF DELIMITER STOPPING SCAN, OR ERROR)  .
*.  RB = 0    CONSTANT WAS LEGAL, NO ERRORS                           .
*.  RB = NONZERO VALUE FOR ERROR CODE - INVALID CONSTANT - ($ERINVCN) .
*.  RC = ADDRESS OF PROPERLY ASSEMBLED CONSTANT                       .
*.       **NOTE** - THIS ROUTINE WILL ASSEMBLE VALUES INTO F OR H     *
*.       CONSTANTS OF LENGTH 1-8, BUT THE VALUE OF ANY CONSTANT MUST  *
*.       BE OF SIZE TO FIT INTO 1 FULLWORD, I.E. THE OTHER FULLWORD   *
*.       MUST EITHER BE ALL 0'S OR ALL 1'S (BINARY).  .               *
*.       **NOTE** IT IS POSSIBLE FOR THIS ROUTINE TO CAUSE A FIXED PT *
*.       OVERFLOW, WHICH WILL CAUGHT AND LAGGED BY SPIE MONITOR IN    *
*.       MAIN PROGRAM MPCON0.                                         *
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CFHCN2   $SAVE RGS=(R1-R2),SA=NO
         SPACE 1
*              INITIALIZE.  CHECK SIGN, KAE CFH2SIG EITHR LR OR LCR.
         SR    R1,R1               CLEAR FOR ADDRESS INSERTION
         MVI   CFH2SIG+1,X'FF'     ASSUME + SIGN WILL OCCUR
         CLI   0(RA),C'0'          IS THERE NO SIGN
         BNL   CFH2TRT             NO SIGN-BRANCH
         CLI   0(RA),C'+'          PLUS SIGN CHECK
         BE    CFH2INC             BRANCH IF SO
         MVI   CFH2SIG+1,X'FD'     SET TO SHOW MINUS
CFH2INC  LA    RA,1(RA)            BUMP PAST SIGN
         SPACE 1
*              SCAN CONSTANT, CONVERT TO BIANRY FORM.
CFH2TRT  TRT   0(11,RA),AWTDECT    GO FOR DELIMITER
         SR    R1,RA               GET DIFFERENCE=#OF DIGITS
         BCTR  R1,0                DECREMENT FOR LENGTH-1
         EX    R1,CFH2PACK         PACK THE NUMBER
CFH2SIG  NI    AVDWORK1+7,$        CHANGE SIGN TO SHOW + (F) OR - (D)
         CVB   RD,AVDWORK1         CONVERT THE VALUE
         SPACE 1
*              GIVE CONSTANT RIGHT SIGN, STORE IT, POINT TO IT.
         SRDA  RD,32               MAKE CONSTANT A DOUBLE WORD-
         STM   RD,RE,AVCONBLD      STORE IN BUILDING AREA
         LCR   RB,RB               MAKE LENGTH-1 NEGATIVE-GET OFFSET
         LA    RC,AVCONBLD+7(RB)   GET START ADDR OF DESIRED CONST
         SR    RB,RB               SHOW THE CONSTANT IS OK
         LA    RA,1(R1,RA)         GET SCAN POINTER TO ENDING ' ,
CFH2RET  $RETURN RGS=(R1-R2),SA=NO
         SPACE 1
CFH2PACK PACK  AVDWORK1,0(0,RA)    PACK DECIMAL STRING
         DROP  RAT,REP             CLEAN UP USING
         TITLE '*** CNDTL2 - CONSTANT PROCESSOR CONTROL - PASS 2 ***'
**--> CSECT: CNDTL2   2   CONSTANT PROCESSOR CONTROL - PASS 2 . . . . .
*.       ENTRY CONDITIONS                                             .
*.  RB = NUMBER OF CONSTANT CONTROL BLOCKS TO BE PROCESSED            .
*.  RC = ADDRESS OF FIRST OR ONLY CNCBLOCK TO BE DONE                 .
*.       CALLS CACON2,CBCON2,CCCON2,CDECN2,CFHCN2,CPCON2,CVCON2,CXCON2.
*.       CALLS CZCON2,ERRTAG,OUTPT2,UTPUT2                            .
*.       USES DSECTS: AVWXTABL,CNCBLOCK                               .
*.       USES MACROS: $ALIGR,$CALL,$GLOC,$GTAD,$RETURN,$SAVE          .
*.       USES MACROS: $SCPT,$SLOC                                     .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CNDTL2   CSECT
         $DBG  A0,SNAP
* * * * * REGISTER ALLOCATION AND USAGE FOR CNDTL2  * * * * * * * * * *
*   R0 = # CONSTANTS REMAINING TO BE DONE IN CURRENT CNCBLOCK(CNCNUM) *
*   R1 = LENGTH-1 OF CONSTANT(S) IN INDIVIDUAL OPERAND, (FROM CNCLEN) *
*              ALSO USED AS BYTE REGISTER, 3 HI-ORD* BYTES=0          *
*   R2 = DUPLICATION FACTOR FOR CONSTANT OPERAND ( FROM CNCDUP)       *
*   RW = @ CURRENT CNCBLOCK BEING PROCESSED.                          *
*   RX = @ AREA FOR BUILDING UP MULTIPLE CONSTANTS (AVCONBL2)         *
*   RY = @ SPECIFIC CONSTANT PASS 2 ROUTINE                           *
*   RZ = CURRENT TOTAL LENGTH OF ASSEMBLED CONSTANTS (MULTIPLE OPRNDS)*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         USING AVWXTABL,RAT
         $SAVE RGS=(R14-R6),BR=R13,SA=CNDTSAVE
         SPACE 1
*              INITIALIZEREGISTERS, COUNTERS.  ENTER CODE LOOP.
         SR    R0,R0               CLEAR FOR INSERIONS
         SR    R1,R1               CLEAR FOR INSERTIONS
         LR    RW,RC               MOVE @ 1ST OR ONLY CNCBLOCK OVER
         USING CNCBLOCK,RW         NOTE POINTER
         MVC   CNDOCNT,AWHM1       =H'-1' = 6-1 OF BYTES FOR PRINTING
         B     CNDAA1              ENTR RIGHT SPOT TO BEGIN
         SPACE 1
*              CNDA IS ENTERED 1 TIME FOR EACH OPERAND AFTER FIRST    *
CNDA     LH    R15,CNCTOT          GET TOTAL LENGTH OF LAST CONSTANT
         A     R15,AVLOCNTR        ADD LOCATION COUNTER
         LA    RW,CNC$LEN(RW)      INCREMENT CNCBLOCK POINTER TO NEXT
         TM    CNCTYP,$CNALN       DOES NEW OPERAND REQUIRE ALIGNMENT
         BZ    CNDNOLN             NO,SKIP ALIGNING THE LOCCNTR
         IC    R1,CNCLEN           GET L-1 OF CONST(NOTE R1 BYTE REG)
         $ALIGR R15,(R1)           ALIGN LOCATION COUNTER
CNDNOLN  $SLOC R15                 RESET LOCATION COUNTER
         SPACE 1
*              CNDAA1 IS ENTERED 1 TIME FOR EACH CNCBLOCK PROCESSED.  *
CNDAA1   STH   RB,CND#CNCS         SAVE CURRENT # CNCBLOCKS TO BE DONE
CNDAA    $SCPT RA,CNCSCAN          CONVERT OFFSET TO ACTUAL @ PTR
         IC    R1,CNCTYP           GET TYPE BYTE
         N     R1,AWF15            REMOVE LEADING BITS
         IC    R1,AWCONADS(R1)     GET OFFSET TO PASS 1 CONSTANT SUBR
         $GTAD RY,C$BASE+4(R1)     GET @ PASS 2 CONSTANT ROUTINE
         IC    R0,CNCNUM           GET # OF CONSTANTS IN THIS OPERAND
         IC    R1,CNCLEN           GET THE LENGTH-1 OF EACH CONSTANT
         LA    RX,AVCONCAT         SET UP @ OF BUILDING AREA
         SR    RZ,RZ               CLEAR THE TOTAL LENGTH BUILT UP
         EJECT
*              CNDBB ENTERED ONCE FOR EACH CONSTANT IN EACH OPERAND   *
CNDBB    LR    RB,R1               MOVE LENGTH-1 OVER FOR CALL TO ROUTI
         LR    REP,RY              MOVE @ ROUTINE OVER
         BALR  RET,REP             CALL THE ROUTINE
         TM    CNCTYP,$CNERR       SHOULD WE TEST RB FOR ERRORS
         BZ    CNDNERR             SKIP IF NO TEST NEEDED
         LTR   RB,RB               WAS THERE AN ERROR
         BZ    CNDNERR             SKIP IF NO ERROR
         SPACE 1
*              ERROR FOUND IN PASS 2. FLAG IT,PRINT STMT, AND QUIT.   *
         $CALL ERRTAG              HAVE ERROR FLAGGED
         B     CNDRETA             RETURN TO CALLER
         SPACE 1
CNDNERR  EQU   *
         LA    RE,0(RX,RZ)         GET @ WHERE NEXT CODE TO GO
         LA    RZ,1(R1,RZ)         INCREM TOTAL LENGTH BY NEW AMOUNT
         CLI   CNCNUM,1            WAS THERE ONLY 1 CONSTANT(LIKELY)
         BE    CNDPRNT1            SKIP TO SIMPLE CASE IF SO
         STC   R1,*+5              STORE L-1 INTO NEXT INST
         MVC   0($CHN,RE),0(RC)    MOVE CODE OVER
         LA    RA,1(RA)            BUMP THE SCAN POINTER TO NEXT OPERAN
         BCT   R0,CNDBB            GO BACK FOR NEXT CONSTANT IN OPERAND
         SPACE 1
*              FALL THRU AFTER ASSEMBLING 2 OR MORE CONSTS IN 1 OPRND.*
         LR    RC,RX               MOVE @ ASSEMBLED CONSTANT OVER
CNDPRNT1 BCTR  RZ,0                DECREMENT TOTAL LENGTH TO L-1
         LH    R2,CNCDUP           GET DUPLICATION FACTOR
         LTR   R2,R2               TEST (MAX VAL FOR DUPL=X'7FFF')
         BZ    CNDLOOP2            SKIP REST IF ZERO DUPLICATION FACTOR
         SPACE 1
*              ACCUMULATE ENOUGH BYTES FOR PRINTING, IF NOT ALREADY.  *
         LH    RA,CNDOCNT          GET LENGTH-1 CUR¢ENTLY READY
         LA    R15,6               FOR COMPARISON A(D LIMIT VALUE
         CR    RA,R15              IS THERE ENOUGH  ALREADY
         BH    CNDUTPUT            BRANCH OUT IF ALREADY ENOUGH
         SPACE 1
         LA    R14,1               FOR BXLE INCREME(T
         SR    RD,RD               INIT FOR INDEX I(TO ASSEMBLED CONT
         LR    RE,R2               DUPLICATE DUPLIC"ATION FACTOR,>0
         B     CNDLC               ENTER LOOP APPRO&RIATELY
         SPACE 1
*              LOOP TO ACCUMULATE PRINTING CODE, 1 BYTE AT TIME.
CNDLA    AR    RD,R14              INCREMENT WITHIN CONSTANT PTR TO NXT
         CR    RD,RZ               HAVE WE REACHED END OF CONST
         BNH   CNDLC               NO,KEEP GOING
         SR    RD,RD               END OF CONST,CLEAR TO BEGIN AGAIN
         SR    RE,R14              DECREMENT TEMPORARY DUPLICATION FAC
         BNP   CNDLE               QUIT IF RUN OUT OF DUPLFAC
         SPACE 1
CNDLC    IC    RB,0(RD,RC)         GET 1 BYTE OF CONSTANT OPERAND
         STC   RB,CNDOCOD+1(RA)    STORE FOR PRINTING
         BXLE  RA,R14,CNDLA        LOOP UNTIL HAVE 8 BYTES OR RUN OUT
         SPACE 1
CNDLE    STH   RA,CNDOCNT          STORE BACK THE UPDATED PR COUNT
         EJECT
*              CALL UTPUT2 TO DUPLICATE AND LOAD OBJECT CODE          *
CNDUTPUT EQU   *
         LR    RE,R2               MOVE DUPLICATION FACTOR OVER
         $GLOC RA                  GET LOCATION COUNTER FOR CODE
         LR    RD,RZ               TOTAL L-1 OF CODE(NOT CNTING DUPL)
         $CALL UTPUT2              HAVE OBJECT CODE LOADED,DUPLICATED
         SPACE 1
*              LOOP BACK FOR NEXT OPERAND, IF >1 WAS USED.
CNDLOOP2 LH    RB,CND#CNCS         GET # CNCBLOCKS LEFT TO DO
         BCT   RB,CNDA             GET NEXT OPERAND (UNLIKELY)
         SPACE 1
CNDRETA  EQU   *                   INSERT $DALLOCH CODE LATER
         LA    RB,$OUCONS          SHOW WE WANT LOCATION COUNTER
         LA    RC,CNDOCOD          GET @ OF CODE TO BE PRINTED
         LH    RD,CNDOCNT          GET LENGTH-1 OF CONST TO PRINT
         $CALL OUTPT2              HAVE STMT PRINTED
CNDRET   $RETURN RGS=(R14-R6)
         SPACE 1
* * * * * INTERNAL VARIABLES                                          *
CND#CNCS DS    H                   # CNCBLOCKS TO BE PROCESSED (U=1)
CNDOCNT  DS    H                   FOR LENGTH-1 OF CODE TO PRINT
CNDOCOD  DS    D                   AREA TO BUILD UP PRINTED CODE
         DROP  RAT,R13,RW          KILL USINGS
         TITLE '*** CODTL1 - SCAN DUPL FAC,TYPE,LENGTH,CONST-PASS1 ***'
**--> CSECT: CODTL1   1   SCAN DUPFAC,TYPE,LENGTH-CALL C ROUTINES . . .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER TO DUPLICATION FACTOR OR CONSTANT TYPE          .
*.  RB = 0    CONSTANT IS IN A DEFINE STORAGE STMT                    .
*.  RB = 4     CONSTANT IS IN A DC STATEMENT                          .
*.  RB = 8     CONSTANT IS A LITERAL - (I.E. DUPLFAC ^= 0, DECIMALS)  .
*.       EXIT CONDITIONS                                              .
*.  RA = SCAN POINTER TO DELIMITER FOLLOWING CONSTANT                 .
*.  RB = 0    LEGAL SPECIFICATION OF CONSTANT                         .
*.  RB = NONZERO VALUE - ERROR CODE - ILLEGAL                         .
*.  RC = ADDRESS OF A CONSTANT CONTROL BLOCK                          .
*.  RE = TOTAL LENGTH OF OPERAND,INCLUDING MULTIPLE OPERANDS,IF ANY   .
*.       CALLS CACON1,CBCON1,CCCON1,CDECN1,CFHCN1,CPCON1,CVCON1,CXCON1.
*.       CALLS CZCON1,EVALUT,SDDTRM                                   .
*.       USES DSECTS: AVWXTABL,CONBLK                                 .
*.       USES MACROS: $CALL,$GTAD,$RETURN,$SAVE,$SCOF,CONG
*        NOTE RESTRICTIONS - DUPLICATION FACTOR AND TOTAL LENGTH MUST *
*        BOTH BE ABLE TO FIT IN HALFWORD EACH. LENGTH MAY BE GREATER  *
*        THAN 256 FOR A DS,BUT LENGTH ATTRIBUTE WILL NOT BE CORRECT   *
*.  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         SPACE 1
CODTL1   CSECT
         $DBG  A0,SNAP
* * * * * REGISTER ALLOCATION FOR CODTL1  * * * * * * * * * * * * * * *
*   R0 = 0 ==> PROCESSING DS,  = 4 ==> PROCESSING DC STATEMENT.       *
*      = 8 ==> LITERAL CONSTANT, I.E. REQUIRE DECIMAL MODIFIERS.      *
*   R1 = 1         USED TO BUMP SCAN POINTER IN BXH'S,ETC.            *
*   R2 = ADDRESS OF CONSTANT BLOCK ENTRY (CONBLK),AFTER TYPE FOUND    *
*   RW = LENGTH-1 OF OPERAND BEING PROCESSED.IMPLIED OR SPECIFIED.    *
*   RX = NUMBER OF CONSTANTS IN THE OPERAND                           *
*   RY = DUPLICATION FACTOR OF THE OPERAND                            *
*   RZ   USED AS LINK OR WORK REGISTER                                *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         USING AVWXTABL,RAT        NOTE MAIN USING
         $SAVE RGS=(R14-R6),BR=R13,SA=COSAVE
         SPACE 1
*              INITIALIZATION OF REGISTERS, CONSTANT BLOCK, FLAGS.
         LR    R0,RB               SAVE R0=0==>DS,R0=4==>DC
         SR    RB,RB               SHOW NO ERRORS AT BEGINNING
         LA    R1,1                HANDY CONSTANT
         LR    RY,R1               SET DEFAULT DUPLICATION FACTOR=1
         LM    R2,R4,AWZEROS       ZERO POINTER REG,LENGTH,#OF CONSTS
         STM   R2,R3,COBLK         ZERO OUT BLOCK
         MVI   CODXLEN+1,0         INITIALIZE TO NO EXPLICIT LENGTH
         SPACE 1
*              BEGIN PROCESSING OF DUPLICATION FACTOR, IF PRESENT.
         BAL   R14,CODNUM          GO GET DUPLICATION FACTOR
         B     CODLOOK             NO DUPLICATION FACTOR,SKIP
         SPACE 1
*              DUPLICATION FACTOR EXPLICIT-CHECK IT,MOVE TO RY.       *
         C     RC,AWFX7FFF         =XL4'7FFF' COMPARE TO MAX SIZE LEGAL
         BH    CODEDUPL            BRANCH IF TOO BIG
         LTR   RY,RC               MOVE FACTOR OVER AND TEST
         BNZ   CODLOOK             BRANCH IF DEFINITELY LEGAL
         C     R0,AWF7             0 DUPLICATION FACTOR, IS IT LITERL
         BNL   CODEDUPL            BRANCH - 0 DUPLFAC IN LITERAL -ERROR
         SPACE 1
*              CHECK TYPE FOR LEGALITY. GET ADDR OF CONBLK ENTRY.     *
CODLOOK  CLI   0(RA),C'A'          MAKE SURE LEGITAMATE
         BL    CODERTYP            NO,IT IS AN ERROR
         IC    R2,0(RA)            GET THE TYPE CODE
         IC    R2,CODINXO(R2)      GET OFFSET INTO CONTABL ENTRIES
         LTR   R2,R2               IS THE TYPE LEGAL
         BZ    CODERTYP            NO,ERROR
         SPACE 1
         LA    R2,CONTAB1(R2)      GET ACTUAL ADDRESS OF RIGHT ENTRY
         USING CONBLK,R2           NOTE DUMMY SECT FOR CONTABL ENTRY
         MVC   COTYP,CONTYP        MOVE TYPE+FLAGS OVER
         AR    RA,R1               INCREMENT SCAN POINT BEYOND TYPE
         SPACE 1
*              CHECK FOR EXPLICIT LENGTH SPECIFICATION,EVAL IT IF SO. *
         CLI   0(RA),C'L'          IS THERE A LENGTH SPECIFICATION
         BNE   CODEFAL             NO,USE DEFAULT LENGTH
         EJECT
*              LENGTH EXPLICITLY SUPPLIED - PROCESS IT,NOTE NO ALIGN. *
         AR    RA,R1               INCREMENT SCAN POINTER TO BEYOND L
         BAL   R14,CODNUM          GO GET LENGTH
         B     CODINVD             INVALID DELIMITER OR SOMETHING
CODEDL   LR    RW,RC               MOVE LENGTH OVER
         SR    RW,R1               DECREMENT TO LENGTH-1
         NI    COTYP,255-$CNALN    WIPE OUT ALIGNMENT FLAG,IF ANY
         MVI   CODXLEN+1,X'F0'     MAKE NOP A BRANCH-EXPLICIT LENGTH
         SPACE 1
*              CHECK EXPLICIT LENGTH FOR BEEING IN RIGHT RANGE.
         SR    RD,RD               CLEAR REG FOR INSERT
         IC    RD,CONLLW           GET LOWEST LIMIT VALUE
         CR    RW,RD               IS LENGTH TOO LOW
         BL    CODLBAD             ILLEGAL LENGTH
         IC    RD,CONLHI           GET HIGH LIMIT ON LENGTH-1
         CR    RW,RD               COMPARE TO SEE IF HIGH
         BNH   CODCONGO            THE LENGTH IS IN RANGE
         LTR   R0,R0               IS THIS IN A DS
         BNZ   CODEBIG             NO,IT IS DC, THEREFORE ILLEGAL
         SPACE 1
*              NOTE C & X DC'S MAY EXCEED NORMAL 256 LENGTH LIMIT.
         CLI   CONTYP,$CNVLN+$CNC  IS IT C TYPE
         BE    CODCONGO            YES,SO IT IS OK
         CLI   CONTYP,$CNVLN+$CNX  IS IT HEX CONST
         BE    CODCONGO            YES,SO ITS OK
         B     CODEBIG             NO,IT IS TOO LARGE,SINCE NOT X OR C
         SPACE 1
CODEFAL  IC    RW,CONLEN           GET DEFALUT LENGTH-1
*              HAVE GOTTEN DUPFAC-TYPE-LENGTH,NOW SCAN FOR CONSTANT.  *
CODCONGO CLI   0(RA),C' '          CHECK,IS THIS THE END
         BE    *+12                SKIP NEXT 2 INSTS==> NO OPERAND
         CLI   0(RA),C','          CHECK FOR , AFTER LENGTH
         BNE   CODOPR              NO,THERE'S STILL MORE
         LTR   R0,R0               IF FIELD OMITTED,MUST BE DS
         BNZ   CODEOMOP            OMITTED OPERAND IN DC==>ERROR
         BXLE  RX,R1,CODFIN        SET # OEPRANDS = 1 AND BRANCH
         SPACE 1
*              GET ADDRESS OF APPROPRIATE PASS 1 CONSTANT SUB&CALL IT *
CODOPR   CLC   0(1,RA),CONLD       IS THE LEFT DELIMITER OK
         BNE   CODINVD             NO IT ISNT-BRANCH TO ERROR
         AR    RA,R1               BUMP SCAN POINTER TO 1ST CHAR OF CON
         IC    RD,CONTYP           GET TYPE VALUE
         N     RD,AWFXF            =XL4'F' WIPE OUT FLAG BITS FROM NIBL
         IC    RD,AWCONADS(RD)     GET OFFSET TO ADDR OF TYPE
         $GTAD R0,C$BASE(RD)       GET @ PASS 1 ROUTINE - C#CON1
         $SCOF R15,RA,COSCAN       GET THE OFFSET AND SAVE IT
         EJECT
*              CONSTANT TYPE KNOWN. CALL ROUTINE TO PROCESS IT.       *
CODCALL  LR    REP,R0              MOVE ADDRESS OV ROUTIN OVER
         BALR  RET,REP             CALL THE ROUTINE
         LTR   RB,RB               WAS THERE AN ERROR
         BNZ   CODRETA             YES,RETURN WITH THE RROR
         AR    RX,R1               INCREMENT THE # OF OPERANDS
         CLC   0(1,RA),CONRD       IS DELIM THE RIGHT DELIM
         BE    CODCONA             YES,THIS IS END OF OPERAND
*              THE FOLLOWING TAKES CARE OF MULTIPLE OPERANDS WHERE OK *
         CLI   0(RA),C','          IS DELIMITER RIGHT
         BNE   CODINVD             NO,IT IS BAD DELIMITER
         TM    COTYP,$CNMUL        ARE MULTIPLE DELIMS ALLOWED
         BZ    CODINVD             SKIP IF THEY AREN'T ERROR
         BXH   RA,R1,CODCALL       BUMP SCAN POINTER AND CALL ROUTINE
         SPACE 1
*              HAVE PROCESSED WHOLE OPERAND. CHECK FOR OVERRIDE LENGTH*
CODCONA  AR    RA,R1               INCREMENT SCAN POINTER
CODXLEN  BC    $CHN,CODFIN         BRANCH IF LENGTH EXPLICIT,NOP IFNOT
         TM    COTYP,$CNVLN        WAS LENGTH VARIABLE,ALLOWING OVERD
         BZ    CODFIN              NO,LEAVE THE LENGTH ALONE
         LR    RW,RC               MOVE THE RETURNED LENGTH OVER
         SR    RW,R1               DECREMENT BY 1 TO GET CONSISTENT
         SPACE 1
*              STORE FLAGS INTO COBLK. COMPUTE TOTAL LENGTH INTO RE   *
CODFIN   STC   RX,CONUM            STORE NUMBER OF OPERANDS
         STC   RW,COLEN            SAVE THE LENGTH-1 OF OPERAND
         LTR   RE,RY               MOVE OVER AND TEST DUPL FACTOR
         BZ    CODRETA             YES,0 DUP FACTOR-0 EVERYTHING
         STH   RY,CODUP            STORE A NONZERO DUPLICATION FACTOR
         BAL   R14,*+6             SKIP 1ST AR AND GO TO BCTR
         AR    RE,RY               ADD DUPLFAC TO SLEF
         BCTR  RX,R14              LOOP ON NUMBER OF CONSTANTS IN OPRND
*              DUPLICATION FACTOR * NUMBER OF OPERANDS IS IN RE       *
         CR    RE,R1               IS DUP FAC*#OPERANDS =1
         BNE   CODMULT             IF NOT,GIVE UP AND MULTIPLY
         LA    RE,1(RW)            MOVE THE LENGTH OVER&ADD 1
         B     CODSTOR             HAVE LENGTH SAVED AND QUIT
CODMULT  AR    RW,R1               INCREMENT LENGTH-1 TO LENGTH
         MR    RD,RW               MULTIPLY TO GET TOTL LENGTH
CODSTOR  STH   RE,COTOT            SAVE THE TOTAL LENGTH
         CL    RE,AWFX7FFF         MAKE SURE WHOLE LENGTH NOT TOO BIG
         BH    CODEBIG             TOTAL LENGTH IS TOO BIG
*              POINT AT THE COBLK AND RETURN                          *
CODRETA  LA    RC,COBLK            SHOW ADDRESS OF OUR CODE BLOCK
CODRET   $RETURN RGS=(R14-R6)
         EJECT
* * * * * CODNUM - CALLED TO EVALUATE DUPLICATION FACTOR OR LENGTH -  *
*        RETURNS 0(R14) IF EXPRESSION OMITTED. RETURNS TO 4(R14) IF OK*
*        RC HAS VALUE OF EXPRESSION                                   *
CODNUM   LA    RZ,4(R14)           SET UP GOOD RETURN FOR SECTIONS
         CLI   0(RA),C'0'          DO WE HAVE DECIMAL NUMBER
         BNL   CODECAL             YES,DECIMAL NUMBER,GO CONVERT
         CLI   0(RA),C'('          EITHER EXPRESSION,OR OMITTED
         BCR   NE,R14              RETURN IF IT WAS OMITTED
         SPACE 1
*              IF FALLS THRU==>EXPRESSION,ENCLOSED IN PARENS. EVALUATE*
         C     R0,AWF7             ARE WE IN LITERAL
         BH    CODESYNT            YES, ILLEGAL DUPLFAC OR LENGTH
         AR    RA,R1               BUMP SCAN POINTER PAST 1ST (
         $CALL EVALUT
         LTR   RB,RB               CHECK FOR ERROR
         BNZ   CODRET              RETURN WITH ERROR CODE IF SO
         LTR   RD,RD               WAS IT RELOCATABLE
         BNZ   CODNEABS            RELOCATABLE RELOCATION FACTOR,ERROR
         CLI   0(RA),C')'          SEE IF THIS WAS END
         BNE   CODINVD             INVALID DELIMITER IF NOT
         BXH   RA,R1,0(RZ)         INCREMENT SCAN POINTER PAST ) AND BR
         SPACE 1
*              DUPLFAC OR LENGTH WAS DECIMAL NUMBER. GET ITS VALUE    *
CODECAL  $CALL SDDTRM              GET DECIMAL SELF-DEFINING TERM
         LTR   RB,RB               WAS THERE AN ERROR
         BCR   Z,RZ                RETURN IF THE NUM WAS OK
         B     CODRET              RETURN WITH ERROR CODE IN RB
         SPACE 1
* * * * * INDIVIDUAL ERROR CODE SECTIONS                              *
CODERTYP LA    RB,$ERCNTYP         UNKNOWN TYPE OF CONSTANT
         B     CODRET              RETURN SHOWING ERROR
CODEOMOP LA    RB,$ERNOOPR         MISSING OPERAND(CONSTANT)
         B     CODRET              RETURN SHOWING ERROR
CODEBIG  LA    RB,$EREXGTA         NUMBER OR EXPRESSION TOO LARGE
         B     CODRET              RETURN SHOWING ERROR
CODLBAD  LA    RB,$EREXLTA         NUMBER OR EXPRESSION TOO SMALL     P
         B     CODRET              RETURN SHOWING ERROR
CODINVD  LA    RB,$ERINVDM         INVALID DELIMITER
         B     CODRET              RETURN,SHOWING ERROR CODE
CODNEABS LA    RB,$ERNEABS         ABSOLUTE EXPRESSION REQUIRED
         B     CODRET              RETURN
CODESYNT LA    RB,$ERVSYNT         SYNTAX - ILLEGAL () IN LITERAL
         B     CODRET              RETURN
CODEDUPL LA    RB,$ERDUPLF         ILLEGAL DUPLICATION FACTOROR
         B     CODRET              RETURN
         EJECT
* * * * * INTERNAL CONSTANTS                                          *
CODINX   DC    XL(256-C'A')'0'     CONSTANT INDEX TABLE
CODINXO  EQU   CODINX-C'A'            GET SYMBOL WITH OFFSET
CONTABL  EQU   *                   BEGINNING OF CONSTANT DESCRIPTOR TAB
CONTAB1  EQU   CONTABL-1           GET OFFSET SYMBOL SO OFFSETS NOT ZER
         CONG  A,$CNALN+$CNMUL,4,LD='(',RD=')',HI=4
         CONG  B,$CNVLN,1,HI=256,E=0
         CONG  C,$CNVLN,1,HI=256,E=0
         CONG  D,$CNALN+$CNMUL,8
         CONG  E,$CNALN+$CNMUL,4
         CONG  F,$CNALN+$CNMUL,4
         CONG  H,$CNALN+$CNMUL,2
         CONG  P,$CNVLN+$CNMUL,1,HI=16,E=0
         CONG  V,$CNALN+$CNMUL,4,LD='(',RD=')',LW=3,HI=4
         CONG  X,$CNVLN,1,HI=256,E=0
         CONG  Z,$CNVLN+$CNMUL,1,HI=16,E=0
         LTORG
         SPACE 1
* * * * * INTERNAL VARIABLES                                          *
* * * * * COBLK AREA - SET UP LIKE CNCBLOCK FOR CONSTANT CODES        *
COBLK    DS    0D                  INTERNAL CONSTANT BLOCK LIKE CNCBLK
COTYP    DS    C                   TYPE + FLAGS
COLEN    DS    C                   LENGTH-1 OF CONSTANT OPERAND
COSCAN   DS    C                   SCAN POINTER OFFSET TO START OF CONS
CONUM    DS    C                   NUMBER OF OPERANDS IN CONSTANT
CODUP    DS    H                   DUPLICATION FACTOR
COTOT    DS    H                   TOTAL LENGTH OF CONSTANT
         SPACE 1
**--> DSECT: CONBLK     CONSTANT DESCRIPTOR CODES BLOCK(CODTL1) . . . .
*.       THIS BLOCK CONTAINS DATA FOR A GIVEN CONSTANT TYPE, AND IS   .
*.       USED BY ASSEMBLER SUBR. CODTL1 IN SCANNING CONSTANTS AND     .
*.       BUILDING CNCBLOCKS DURING ASSEMBLY PASS 1.  THE DATA         .
*.       GIVEN INCLUDES A FLAG BYTE, DEFAULT LENGTH-1, LEFT AND       .
*.       RIGHT DELIMITER CHARACTERS REQUIRED FOR THE CONSTANT, AND    .
*.       MINIMUM AND MAXIMUM VALUES FOR THE LENGTH-1 OF THE CONSTANT. .
*.       THE FLAG BYTE, WITH MODIFICATIONS, BECOMES THE CNCTYPE BYTE  .
*.       OF THE CNCBLOCK CREATED FOR EACH CONSTANT OPERAND.           .
*.       LOCATION: TABLE CONTABL OF CSECT CODTL1                      .
*.       GENERATION: 1 CALL TO MACRO CONG CREATES A CONBLK ENTRY.     .
*.  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         SPACE 1
CONBLK   DSECT
CONTYP   DS    C                   CONSTANT TYPE+ FLAGS
CONLEN   DS    C                   DEFAULT LENGTH
CONLD    DS    C                   LEFT DELIMITER
CONRD    DS    C                   RIGHT DELIMITER
CONLLW   DS    C                   LOWEST VALUE OF LENGTH-1
CONLHI   DS    C                   HIGHEST VALUE OF LENGTH-1
         DROP  RAT,R13,R2          CLEAN UP USING
         TITLE '*** CPCONS - PACKED DECIMAL CONSTANTS ***'
**--> CSECT: CPCONS   1-2 PROCESS PACKED CONSTANTS. . . . . . . . . . .
*.       USES DSECTS: AVWXTABL                                        .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CPCONS   CSECT
         $DBG  A0,SNAP
         ENTRY CPCON1,CPCON2       PASS 1 AND 2 ENTRIES
         USING AVWXTABL,RAT        NOTE MAIN TABLE USING
         SPACE 2
**--> ENTRY: CPCON1   1   SCAN,DO NOT ASSEMBLE PACKED CONSTATNT . . . .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER (ADDRESS OF 1ST CHAR AFTER PREVIOUS DELIMETER)  .
*.       EXIT CONDITIONS                                              .
*.  RA = SCAN POINTER (ADDRESS OF DELIMITER STOPPING SCAN, OR ERROR)  .
*.  RB = 0    CONSTANT WAS LEGAL, NO ERRORS                           .
*.  RB = NONZERO VALUE FOR ERROR CODE - INVALID CONSTANT - ($ERINVCN) .
*.  RC = NUMBER OF BYTES REQUIRED FOR CONSTANT                        .
*.       USES MACROS: $RETURN,$SAVE                                   .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CPCON1   $SAVE SA=NO
         SR    RC,RC               CLEAR FOR USE AS FLAG
         LA    RD,32               (MAX # DIGITS IN CONST) + 1 AS LIMIT
         LA    RE,1                FOR INCREMENTING AND DECREMENTING
         CLI   0(RA),C'+'          IS THERE A + SIGN NEXT
         BE    CP1LOOP             YES,BRANCH TO INCREMENT SCAN PTR
         CLI   0(RA),C'-'          IS IT - SIGN
         BNE   *+6                 SKIP BUMPING SCAN PTR IF SO
         SPACE 1
CP1LOOP  AR    RA,RE               BUMP SCAN POINTER BY 1
         CLI   0(RA),C'0'          IS NEXT CHAR A DIGIT
         BL    CP1NODIG            BRANCH IF NOT - SOME PUNCTUATION
         BCT   RD,CP1LOOP          DIGIT-DECREMENT LIMIT COUNTER,BRANCH
         B     CP1INVCN            INVALID (TOO LONG)
         SPACE 1
CP1NODIG CLI   0(RA),C'.'          WAS NON-DIGIT A PERIOD
         BNE   CP1QUOT             NO,MUST BE ENDING ' OR ,
         BXLE  RC,RE,CP1LOOP       SET RC=1, BRANCH BACK IF 1ST TIME
CP1INVCN LA    RB,$ERINVCN         2 PERIODS, OR OTHER ERROR
         B     CP1RET              GO RETURN WITH ERROR MESSAGE
         SPACE 1
CP1QUOT  CLI   0(RA),C''''         WAS ENDING MARK A QUOT
         BE    CP1DONE             YES,OK,BRANCH
         CLI   0(RA),C','          WERE MULTIPLE OPS USED
         BNE   CP1INVCN            INVALID (PROBABLY DELIMITER)
         SPACE 1
CP1DONE  SR    RB,RB               SHOW NO ERRRORS
         LA    RC,32               (MAX # DIGITS + 1) FOR SUBTRCT
         SR    RC,RD               SUBTRACT COUNTER = ACTUAL # DIGITS
         BZ    CP1INVCN            IF 0 DIGITS, QUIT - NULL CONTSNAT
         SRA   RC,1                SHIFT TO GET # OF BYTES REQUIRED
         AR    RC,RE               HAD # BYTES - 1, NOW GET # BYTES
CP1RET   $RETURN SA=NO
         EJECT
**--> ENTRY: CPCON2   1-2 SCAN AND ASSEMBLE P TYPE CONSTANT . . . . . .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER (ADDRESS OF 1ST CHAR AFTER PREVIOUS DELIMETER)  .
*.  RB = LENGTH-1 OF 1 CONSTANT OF 1 OPERAND TO BE ASSEMBLED          .
*.       EXIT CONDITIONS                                              .
*.  RA = SCAN POINTER TO DELIMITER ENDING SCAN                        .
*.  RC = ADDRESS OF PROPERLY ASSEMBLED CONSTANT                       .
*.       USES MACROS: $RETURN,$SAVE,$SETRT                            .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CPCON2   $SAVE RGS=(R1-R2),SA=NO
         MVC   AVCONBLD(16),AWZEROS         ZERO OUT WORK AREA
         LA    RC,AVCONBLD(RB)     @ LAST BYTE OF ASSEMBLED CONSTANT
         LA    RE,1                FOR INCREMENTING,DECREMENTING
         AR    RB,RE               RB = ACTUAL # OF BYTES DESIRED
         SR    R1,R1               CLEAR FOR INSERTION OF ADDRESS
         $SETRT ('''',1,',',1)     SET UP TABLE FOR SCANNING
         TRT   1(32,RA),AWTZTAB    SIGN+PERIOD+31 DIGS-1 = 32 MAX LEN
         $SETRT ('''',0,',',0)     RESET TABLE TO ZEROS
         MVI   CP2BRNCH+1,0        MAKE BRANCH A NOOP INITIALLY
         LA    RD,X'F0'            MASK FOR REMOVING ZONE NIBBLES
         MVI   0(RC),X'C'          INIT SIGN TO A PLUS SIGN
         CLI   0(RA),C'+'          WAS PLUS THERE
         BE    CP2LOAD             YES,SKIP
         CLI   0(RA),C'-'          WAS MINUS THERE
         BNE   CP2LOAD             NO,MUST BE DIGIT OR PERIOD
         MVI   0(RC),X'D'          PLACE DECIMAL MINUS SIGN IN CONST
CP2LOAD  LR    RA,R1               DUPLICATE @ ENDING PUNCTUATION
         SR    R1,RE               BACK POINTER UP TO LAST DIG IN CONST
         SPACE 1
CP2NUMBR CLI   0(R1),C'0'          ARE WE LOOKING AT DIGIT
         BL    CP2NODIG            NOT DIGIT-BRANCH
         IC    R2,0(R1)            GET THE DIGIT
CP2BRNCH BC    $CHN,CP2EVEN        COMMUTATOR - B(EVEN) NOOP(ODD)
         SLL   R2,4                ODD DIGIT - GET INTO LEFT NIBBLE
         STC   R2,*+5              PLACE INTO OI INSTRUCTION FOLLOWING
         OI    0(RC),$CHN          WILL OR IN 1 NIBBLE TO CONSTANT
         SR    RC,RE               BACK POINTER UP,HAVE FINISHED THIS 1
         BCT   RB,CP2FLIP          DECREMENT COUNTER,BRANCH IF MORE
         B     CP2RETA             HAVE DONE REQUIRED # - NOW RETURN
         SPACE 1
CP2EVEN  SLR   R2,RD               REMOVE THE ZONE NIBBLE FROM DIGIT
         STC   R2,0(RC)            STORE THE NUMERIC INTO CONSTNT
CP2FLIP  XI    CP2BRNCH+1,X'F0'    FLIP COMMUTATOR SWITCH/EVEN/ODD
CP2DECR  BCT   R1,CP2NUMBR         DECREM SCN PTR, BRANCH ALWAYS
         SPACE 1
CP2NODIG CLI   0(R1),C'.'          WAS NON-DGIT THE PERIOD
         BE    CP2DECR             YES,DECREM SCAN PTR AND GET NEXT
         SPACE 1
CP2RETA  LA    RC,AVCONBLD         SHOW @ OF CONSTT,WITH L-PAD ZEROS
CP2RET   $RETURN SA=NO,RGS=(R1-R2)
         DROP  RAT,REP             KILL USINGS
         TITLE '*** CVCONS - V-TYPE ADDRESS CONSTANT PROCESSING ***'
**--> CSECT: CVCONS   1-2 PROCESS V-TYPE ADCONS . . . . . . . . . . . .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CVCONS   CSECT
         $DBG  A0,SNAP
         USING AVWXTABL,RAT        NOTE MAIN USING
         ENTRY CVCON1,CVCON2
         SPACE 2
**--> ENTRY: CVCON1   1   SCAN V-TYPE CONST, NO ASSEMBLE. . . . . . . .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER (ADDRESS OF 1ST CHAR AFTER PREVIOUS DELIMETER)  .
*.       EXIT CONDITIONS                                              .
*.  RA = SCAN POINTER (ADDRESS OF 1ST CHAR AFTER PREVIOUS DELIMETER)  .
*.  RB = 0    CONSTANT WAS LEGAL, NO ERRORS                           .
*.  RB = NONZERO VALUE - ILLEGAL SYMBOL ($ERINVSY)                    .
*.       USES DSECTS: AVWXTABL                                        .
*.       USES MACROS: $RETURN,$SAVE                                   .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CVCON1   $SAVE RGS=(R1-R2),SA=NO
         SR    R1,R1               CLEAR FOR ADDRESS INSERT
         TRT   0(9,RA),AWTSYMT     SCAN FOR SYMBOL DELIMITER
         BZ    CVC1ERR             ERROR IF NOT FOUND
         CLI   0(RA),C'0'          IS 1ST CHAR LETTER
         BNL   CVC1ERR             NO-ERROR BRANCH
         CR    R1,RA               MAKE SURE NOT NULL
         BE    CVC1ERR             NULL ERROR-BRANCH
         SR    RB,RB               SHOW OK
         LR    RA,R1               MOVE SCAN POINTER OVER
CVC1RET  $RETURN RGS=(R1-R2),SA=NO
CVC1ERR LA     RB,$ERINVSY         INVALID SYMBOL
         B     CVC1RET             RETURN
         EJECT
**--> ENTRY: CVCON2   2   SCAN&ASSEMBLE VCON. . . . . . . . . . . . . .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER TO FIRST CHARACTER OF VCON.                     .
*.       EXIT CONDITIONS                                              .
*.  RA = SCAN POINTER (ADDRESS OF DELIMITER STOPPING SCAN, OR ERROR)  .
*.  RB = 0 ==> NO ERRORS, NONZERO ==> ERROR CODE                      .
*.     = NONZERO ERROR CODE ($ERUNRV  OR  $ERRELOC).                  .
*.  RC = ADDRESS OF PROPERLY ASSEMBLED CONSTANT                       .
*.       CALLS SYFIND                                                 .
*.       CALLS RESYMB (ONLY IF &$REPL=2 AND EXTRN SYMBOL USED).       .
*.       USES DSECTS: AVWXTABL,SYMSECT                                .
*.       USES MACROS: $CALL,$RETURN,$SAVE                             .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CVCON2   $SAVE RGS=(R14-R2),BR=R13,SA=CVCOSAVE
         LR    R0,RB               SAVE LENGTH-1 OF SSEMBLY
         SR    R1,R1               CLEAR FOR ADDRESS INSERT
         TRT   0(9,RA),AWTSYMT     SCAN SYMBOL
         LR    RB,R1               MOVE SCAN POINTER TO END BACK
         SR    RB,RA               GET LENGTH OF SYMBOL
         $CALL SYFIND              LOOK UP SYMBOL
         LTR   RB,RB               WAS IT FOUND
         BNZ   CVCONUNR            UNRESOLVED REFERENCE
         SPACE 1
         USING SYMSECT,RA          NOTE USING
         AIF   (&$REPL LT 2).CVNREPL        SKIP IF NO REPL CALLS
         TM    SYFLAGS,$SYEXT      WAS IT FLAGGED EXTRN
         BZ    CVC2NOEX            NO, SO SKIP CALLING CODE
         L     R15,CVRESYMB        GET  =V(RESYMB)
         BALR  R14,R15             CALL HIM
         LTR   RB,RB               WAS NAME LEGITAMATE
         BZ    CVC2VAL             YES, RESYMB PUT VALUE INTO TABLE
         B     CVCONUNR            NO, SO EXTRN, THUS UNRESOLVED
CVRESYMB DC    V(RESYMB)           SYMBOL CHECKING MODULE
CVC2NOEX EQU   *                   BRANCH HERE IF NOT EXTRN SYMBOL
.CVNREPL ANOP
         SPACE 1
         TM    SYFLAGS,$SYDEF      IS IT DEFINED
         BZ    CVCONUNR            NO, UNDEFINED, UNRESOLVED
         TM    SYFLAGS,$SYENT+$SYCSE         IS IT EITHER CSECT OR ENTR
         BZ    CVCONUNR            NO-ERROR
*              CHECK TO SEE IF SYMBOL WAS A DSECT SYMBOL.
         TM    SYESDID,$ESDSECT    WAS IT A DSECT
         BZ    CVC2VAL             NO, OK, BRANCH
         LA    RB,$ERRELOC         SHOW ERROR NOT ALLOWED
         B     CVC2RETA            EXIT WITH ERROR
CVC2VAL  LCR   RE,R0               NEGATIVE OF LENGTH-1 FOR OFFSET
         LA    RC,SYVALUE+3(RE)    GET ACTUAL STARTIN @ OF CONSTANT
         SPACE 1
CVC2RETA LR    RA,R1               MOVE SCAN POINTER BACK
CVC2RET  $RETURN RGS=(R14-R2)
CVCONUNR LA    RB,$ERUNRV          UNRESOLVED EXTERNAL REFERENCE
         B     CVC2RETA            RETURN
         DROP  RAT,RA,R13                   REMOVE USINGS
         TITLE '*** CXCONS - SCAN AND/OR ASSEMBLE HEX CONSTANTS ***'
**--> CSECT: CXCONS   1-2 PROCESS HEXADECIMAL CONSTANTS . . . . . . . .
*.       USES DSECTS: AVWXTABL                                        .
*.       USES MACROS: $RETURN,$SAVE                                   .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CXCONS   CSECT
         $DBG  A0,SNAP
         ENTRY CXCON1,CXCON2
         USING AVWXTABL,RAT        NOTE MAIN TABLE USING
         SPACE 2
**--> ENTRY: CXCON1   1   SCAN HEX CONST, DO NOT ASSEMBLE . . . . . . .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER (ADDRESS OF 1ST CHAR AFTER PREVIOUS DELIMETER)  .
*.       EXIT CONDITIONS                                              .
*.  RA = SCAN POINTER (ADDRESS OF DELIMITER STOPPING SCAN, OR ERROR)  .
*.  RB = 0    CONSTANT WAS LEGAL, NO ERRORS                           .
*.  RB = NONZERO VALUE FOR ERROR CODE - INVALID CONSTANT - ($ERINVCN) .
*.  RC = NUMBER OF BYTES REQUIRED FOR CONSTANT                        .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CXCON1   $SAVE RGS=(R1-R2),SA=NO
         SR    R1,R1               CLEAR FOR INSERTION OF ADDRESS HERE
         TRT   0(256,RA),AWTHEXT   SCAN AND CHECL CHARACTERS
         CLI   0(R1),C''''         DELIMITER MUST BE A '
         BNE   CX1ERR              IF NOT,IT IS ERROR
         LA    RC,1(R1)            GET END POINTER +1
         SR    RC,RA               GET # OF HEX DIGITS+1
         SRA   RC,1                DIVIDE BY 2 FOR NUMBER OF BYTES
         BZ    CX1ERR              NULL CONST==> ERROR BRANCH
         SR    RB,RB               CLEAR REG TO SHOW A LEGAL CONST
CX1RETA  LR    RA,R1               GET SCAN POINTER OVER
CX1RET   $RETURN RGS=(R1-R2),SA=NO
CX1ERR   LA    RB,$ERINVCN         INVALID CONST (OR ILLEGAL DELIM)
         B     CX1RETA             GO RETURN
         EJECT
**--> ENTRY: CXCON2   1-2 ASSEMBLE HEX CONSTANT . . . . . . . . . . . .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER (ADDRESS OF 1ST CHAR AFTER PREVIOUS DELIMETER)  .
*.  RB = LENGTH-1 OF 1 CONSTANT OF 1 OPERAND TO BE ASSEMBLED          .
*.       EXIT CONDITIONS                                              .
*.  RA = SCAN POINTER (ADDRESS OF DELIMITER STOPPING SCAN, OR ERROR)  .
*.  RC = ADDRESS OF PROPERLY ASSEMBLED CONSTANT                       .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CXCON2   $SAVE RGS=(R0-R2),SA=NO
         SR    R1,R1               CLEAR FOR TRT
         SR    R2,R2               CLEAR FOR LATER INSERTS
         STC   RB,*+5              STORE LENGTH-1 INTO MVC
         MVC   AVCONBLD($CHN),AWZEROS       ZERO, IN CASE PADDING
         L     RC,AWFM1            GET =F'-1' FOR DECREMENT
         TRT   0(256,RA),AWTHEXT   SCAN FOR ENDING '
         MVI   CX2EVOD+1,X'F0'     SET UP BRANCH FOR ODD 1ST TIME
         LA    RD,0(RC,R1)         GET @ LAST DIGIT OF CONST
         SR    RD,RA               GET NUMBER OF HEX DIGITS IN CONST
         SPACE 1
CX2HGET  IC    R2,0(RD,RA)         GET THE NEXT HEX DIGIT
CX2EVOD  BC    $CHN,CX2ODD         BRANCH IF ODD (FROM RIGHT END)
         IC    RE,AWTHEX2(R2)      GET VALUE OF THE BYTE
         SLL   RE,4                SHIFT IT OVER
         ALR   RE,R0               ADD ODD BYTE TO THE EVEN ONE
         STC   RE,AVCONBLD(RB)     STORE COMPLETED BYTE IN PLACE
         BXH   RB,RC,CX2FLIP       DECREMENT REMAIN COUNT
         B     CX2RETA             BRANCH IF EXACT OR TRUNCATION      P
         SPACE
CX2ODD   IC    R0,AWTHEX2(R2)      GET THE VALUE OF THE DIGIT
CX2FLIP  XI    CX2EVOD+1,X'F0'     SWITH B ODD, NOOP EVEN & VICE VRSA
         BXH   RD,RC,CX2HGET       DECREMENT DIGITS REAMINING,LOOP
         SPACE 1
*              FALLS THRU ==> MAY BE ODD # DIGITS,STORE LAST IF SO    *
         CLI   CX2EVOD+1,X'F0'     WAS LAST DIGIT DONE AN EVEN ONE
         BE    *+8                 YES,SO DON'T STORE ODD ONE
         STC   R0,AVCONBLD(RB)     STORE INTO POSITION
CX2RETA  LA    RC,AVCONBLD         SHOW @ CONSTANT
         LR    RA,R1               SHOW SCAN PTR TO DELIMITING '
CX2RET   $RETURN RGS=(R0-R2),SA=NO
         DROP  RAT,REP             CLEAN UP USING
         LTORG
         TITLE '*** CZCONS - ZONED DECIMAL CONSTANTS ***'
**--> CSECT: CZCONS   1-2 PROCESS ZONED CONSTS. . . . . . . . . . . . .
*.       USES DSECTS: AVWXTABL                                        .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CZCONS   CSECT
         $DBG A0,SNAP
         ENTRY CZCON1,CZCON2
         USING AVWXTABL,RAT        NOTE MAIN TABLE USING
         SPACE 2
**--> ENTRY: CZCON1   1   SCAN, BUT DO NOT ASSEMBLE . . . . . . . . . .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER (ADDRESS OF 1ST CHAR AFTER PREVIOUS DELIMETER)  .
*.       EXIT CONDITIONS                                              .
*.  RA = SCAN POINTER (ADDRESS OF DELIMITER STOPPING SCAN, OR ERROR)  .
*.  RB = 0    CONSTANT WAS LEGAL, NO ERRORS                           .
*.  RB = NONZERO VALUE FOR ERROR CODE - INVALID CONSTANT - ($ERINVCN) .
*.  RC = NUMBER OF BYTES REQUIRED FOR CONSTANT                        .
*.       USES MACROS: $RETURN,$SAVE                                   .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CZCON1   $SAVE SA=NO
         SR    RC,RC               CLEAR FLAG FOR # OF PERIODS
         LA    RD,17               (MAX @ DIGITS) +1
         LA    RE,1                FOR INCREMENTING AND DECREMENTING
         CLI   0(RA),C'+'          IS THERE PLUS SIGN
         BE    CZ1LOOP             YES,GO BUMP SCAN PTR
         CLI   0(RA),C'-'          IS THERE MINUS
         BNE   *+6                 SKIP IF NOT
         SPACE 1
CZ1LOOP  AR    RA,RE               BUMP SCAN PTR BY 1
         CLI   0(RA),C'0'          IS NEXT CHAR A DIGIT
         BL    CZ1NODIG            BRANCH IF NO DIGIT
         BCT   RD,CZ1LOOP          DECREMENT LIMIT,BRANCH IF OK
         B     CZ1INVCN            GO FLAG (TOO MANY DIGITS)
         SPACE 1
CZ1NODIG CLI   0(RA),C'.'          WAS NONDIGIT A PERIOD
         BNE   CZ1QUOT             NO,MUST BE ' OR ,
         BXLE  RC,RE,CZ1LOOP       SET RC=1,BRANCH IF FIRST TIME
         B     CZ1INVCN            2 PERIODS - ERROR - BRANCH
         SPACE 1
CZ1QUOT  CLI   0(RA),C''''         WAS DELIMITER '
         BE    CZ1DONE             YES,QUIT
         CLI   0(RA),C','          WAS DELIMITER ,
         BNE   CZ1INVCN            INVALID CONSTANT
         SPACE 1
CZ1DONE  SR    RB,RB               SHOW NO ERROR
         LA    RC,17               (MAX @ DIGITS+1)
         SR    RC,RD               GET ACTUAL # BYTES REQUIRED
         BNZ   CZ1RET              BRANCH IF LEGAL (NONZERO) LENGTH
CZ1INVCN LA    RB,$ERINVCN         SHOW INVALID CONSTANT
CZ1RET   $RETURN SA=NO
         EJECT
**--> ENTRY: CZCON2   1-2 SCAN AND ASSEMBLE Z-TYPE CONSTANT . . . . . .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER (ADDRESS OF 1ST CHAR AFTER PREVIOUS DELIMETER)  .
*.  RB = LENGTH-1 OF 1 CONSTANT OF 1 OPERAND TO BE ASSEMBLED          .
*.       EXIT CONDITIONS                                              .
*.  RA = SCAN POINTER (ADDRESS OF DELIMITER STOPPING SCAN, OR ERROR)  .
*.  RC = ADDRESS OF PROPERLY ASSEMBLED CONSTANT                       .
*.       USES MACROS: $RETURN,$SAVE,$SETRT                            .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CZCON2   $SAVE SA=NO,RGS=(R1-R2)
         MVI   AVCONBLD,C'0'       SET UP FOR PUTTING ZEROES
         MVC   AVCONBLD+1(14),AVCONBLD      PROPAGATE DECIMAL 0'S
         LA    RC,AVCONBLD(RB)     @ LAST BYTE OF CONSTANT
         LA    RE,1                HANDY CONST FOR INCREM-DECREM
         AR    RB,RE               RB = # OF BYTES REQUIRED
         LR    RD,RC               SAVE @ LAST BYTE FOR SIGN LATER
         SR    R1,R1               CLEAR FOR @ INSERTION
         $SETRT ('''',1,',',1)     SET UP TABLE FOR SCAN
         TRT   1(17,RA),AWTZTAB    SCAN TO ENDING DELIMITER
         $SETRT ('''',0,',',0)     ZERO TABLE OUT AGAIN
         MVI   CZ2SIGN+1,255-X'CF' SET UP FOR + SIGN
         CLI   0(RA),C'+'          IS THERRE A PLUS SIGN
         BE    CZ2LOAD             YES,BRANCH
         CLI   0(RA),C'-'          IS THERE MINUS
         BNE   CZ2LOAD             NO,BRANCH
         MVI   CZ2SIGN+1,255-X'DF' SET UP FOR MINUS SIGN
CZ2LOAD  LR    RA,R1               DUPLICATE PTR TO ENDING PUNCTUATION
         SR    R1,RE               BACK UP PTR TO LAST DIGIT
         SPACE 1
CZ2NUMBR CLI   0(R1),C'0'          ARE WE LOOKING  AT DIGIT
         BL    CZ2NODIG            BRANCH IF NOT DIGIT
         MVC   0(1,RC),0(R1)       MOVE DIGIT TO CONSTANT
         SR    RC,RE               DECREMENT CONSTANT POINTER
         SR    R1,RE               DECREMENT SCAN POINTER
         BCT   RB,CZ2NUMBR         DECREMENT,BRANCH IF MORE NEEDED
         B     CZ2RETA             BRANCH TO RETURN
         SPACE 1
CZ2NODIG CLI   0(R1),C'.'          WAS THIS PERIOD
         BNE   CZ2RETA             NO,SO MUST BE ENDING ' OR , - BRANCH
         BCT   R1,CZ2NUMBR         DECREM SCAN PTR,BACK FOR NEXT DIGIT
         SPACE 1
CZ2RETA  LA    RC,AVCONBLD         SHOW @ OF ASSEMBLEE CONSTANT
CZ2SIGN  XI    0(RD),$CHN          CREAT RIGHT SIGN IN ZONE OF LAST BYT
CZ2RET   $RETURN SA=NO,RGS=(R1-R2)
         DROP  RAT,REP             KILL USINGS
         TITLE '*** ERRORS - ERROR FLAGGING AND POINTER SETUP ***'
**--> CSECT: ERRORS   1-2 ERROR FLAGGING ROUTINES . . . . . . . . . . .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER TO CAUSE OF ERROR                               .
*.  RB = ERROR CODE                                                   .
*.       EXIT CONDITIONS                                              .
*.  RA,RB ARE UNCHANGED BY ERRTAG OR ERRLAB                           .
*.       USES DSECTS: AVWXTABL,RSBLOCK                                .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
ERRORS   CSECT
         $DBG  80,SNAP             NOTE WE WANT TO SEE ALL ERRS
         ENTRY ERRTAG,ERRLAB
         USING AVWXTABL,RAT        NOTE MAIN TABLE USING
         SPACE 2
**--> ENTRY: ERRTAG       FLAG ERROR AT SCAN POINTER POSITION . . . . .
*.       ENTRY CONDITIONS-EXIT CONDITIONS - SEE CSECT ERRORS          .
*.       USES MACROS: $RETURN,$SAVE,$SCOF                             .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
ERRTAG   $SAVE SA=NO
         L     RE,AVRSBPT          GET ADDR OV RECORD SOURCE BLOCK
         USING RSBLOCK,RE          NOTE USING
         TM    RSBFLAG,$REBX       DOES A RECORD ERROR BLOCK EXIST
         BO    ERREBEX             REB ALREADY EXISTS
         OI    RSBFLAG,$REBX       FLAG==>REB EXISTS,THERE ARE ERROR(S)
         DROP  RE                  NO LONGET USING
         MVI   AVREBLN,0           INITIALIZE TO LENGTH-1 OF 0
ERREBEX  CLI   AVREBLN,$ERREBMX*L'AVREBES    CHECK IF MORE ROOM
         BNL   ERRTRET             NO MORE ROOM-RETURN
         SR    RD,RD               CLEAR FOR INSERT TO FOLLOW
         IC    RD,AVREBLN          GET THE CURRENT LENGTH-1 OF REB
         $SCOF RE,RA,AVREBSCN(RD)
         STC   RB,AVREBERR(RD)     PLACE ERROR CODE IN ALSO
         LA    RD,L'AVREBES(RD)    INCREMENT COUNTER
         STC   RD,AVREBLN          PLACE NEW VALUE INTO COUNTER AREA
         $DBG  ,NO                 DON'T NEED TO SEE GOING OUT
ERRTRET  $RETURN SA=NO
         SPACE 2
**--> ENTRY: ERRLAB       FLAG ERROR FOR A LABEL. . . . . . . . . . . .
*.       ENTRY CONDITIONS-EXIT CONDITIONS - SEE CSECT ERRORS          .
*.       CALLS ERRTAG                                                 .
*.       USES MACROS: $CALL,$RETURN,$SAVE                             .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
ERRLAB   $SAVE RGS=(R14-R0),SA=NO
         LR    R0,RA               SAVE THE REAL SCAN POINTER
         L     RE,AVRSBPT          GET POINTER TO RECORD SOURCE BLOCK
         USING RSBLOCK,RE          NOTE THE USING
         LA    RA,RSBSOURC         MAKE A FAKE POINTER TO LABEL
         DROP  RE                  NOTE NO LONGER USING
         $CALL ERRTAG              CALL FLAGGING SECTION
         USING ERRTAG,REP          NOTE CHANGED USING
         LR    RA,R0               RETURN REAL SCAN POINTER
ERRLRET  $RETURN RGS=(R14-R0),SA=NO
         DROP  RAT,REP             CLEAN UP USING
         TITLE  '*** ESDOPR - EXTERNAL SYMBOL DICTIONARY ***'
**--> CSECT: ESDOPRS  1-2 EXTERNAL SYMBOL DICTIONARY&ESDID OPERATIONS .
*.       THIS MODULE HANDLES ALL FLAGGING AND CHECKING OF SECTION     .
*.       AND EXTERNAL ATTRIBUTES, INCLUDING FLAGGING SYMBOL TABLE     .
*.       ENTRIES AND MANIPULATING LOCATION COUNTERS AND SECTION IDS.  .
*.       USES DSECTS: AVWXTABL,SYSMSECT                               .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
ESDOPR   CSECT
         $DBG  90,*
         ENTRY ESINT1,ESCSEC,ESENX1,ESENX2
         USING AVWXTABL,RAT        NOTE MAIN TABLE USING
         SPACE 1
**--> ENTRY: ESINT1       INITIALIZATION . PASS 1 . . . . . . . . . . .
*.       THIS SECTION FOR COMPLETENESS, FUTURE USE. DOES NOTHING 8/70..
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
ESINT1   $SAVE SA=NO
*        ***** FUTURE USE - DOES NOTHING AT PRESENT TIME.**************
ESINRET  $RETURN SA=NO
         SPACE 1
**--> ENTRY: ESCSEC       DECLARE A CONTROL SECTION OR DUMMY SECTION. .
*.       ENTRY CONDITIONS                                             .
*.  RB = 0 ==> CSECT                                                  .
*.     = 2 ==> DSECT                                                  .
*.     = 4 ==> START                                                  .
*.  RC = VALUE TO BE USED TO SET LOCATION COUNTER(START ONLY,RB=4)    .
*.       EXIT CONDITIONS                                              .
*.  RB = 0 ==> NO ERRORS.  ^=0 ==> AN ERROR CODE TO BE SET            .
*.  RB = NONZERO VALUE - ERROR CODE - ($ERDPCSE)                      .
*.  AVCESDID  IS INCREMENTED BY 1 OR 2 FOR NEXT VALUE OF REQUIRED TYPE.
*.       I.E. CSECTS HAVE EVEN VALUES, DSECTS ODD ONES.               .
*.  LOCATION COUNTERS ARE MODIFIED (AVLOCHIH,AVLOCNTR).               .
*.       USES MACROS: $ALIGR,$AL2,$GLOC,$RETURN,$SAVE,$SLOC           .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
ESCSEC   $SAVE SA=NO
         L     RE,AVLABPT          GET POINTER TO LABEL ENTRY
         LTR   RE,RE               WAS THER A STMT LABEL
         BNZ   ESCSLAB             RE = @ SYMBOL TABLE ENTRY,BRANCH
         TM    AVTAGS1,$IBPRCD1    HAS PRIVATE CODE OCCURRED
         BO    ESCSERPC            ERROR-RESUMPTION OF PRIVATE CODE
         OI    AVTAGS1,$IBPRCD1    FLAG THAT PRIVATE CODE HAS NOW OCCUR
         AIF   (NOT &$MACROS).ESNOMA1       SKIP IF NO MACROS
         MVC   AVSYSECT,AWBLANK    SET &SYSECT FOR USE OF MEXPND
.ESNOMA1 ANOP
         B     ESCSINCR            GO BUMP ESDID
         SPACE 1
         USING SYMSECT,RE          NOTE SYMBOL TABLE USING
ESCSLAB  TM    SYFLAGS,$SYDEF      HAS SYMBOL BEEN DEFINED ALREADU
         BO    ESCSERPC            ERROR-RESUMPTION OF CONTROL SECT
         AIF   (NOT &$MACROS).ESNOMA2       SKIP IF NO MACRO EXPANDSER
*              SET UP &SYSECT FOR MACRO EXAPNDER MEXPND.
         MVC   AVSYSECT,AWBLANK    BLANK OUT SECTION NAME
         MVC   *+7(1),SYCHARS      MOVE LEN-1 INTO NEXT INSTR
         MVC   AVSYSECT($),SYMBOL  MOVE SYMBOL OVER, NOW RIGHT-PADDED
.ESNOMA2 ANOP
ESCSINCR SR    RD,RD               CLEAR FOR INSERTION
         IC    RD,AVCESDID         GET CURRENT ESDID
         LA    RD,2(RD)            INITIALLY INCREMENT BY 2 FOR NEXT
         STC   RD,AVCESDID         REPLACE UPDATED SECTION ID
         LH    RB,ESCSJUMP(RB)     GET OFFSET TO ROUTINE
ESCSJ    B     ESCSJ(RB)           TAKE BRANCH TO RIGHT SECTION
         SPACE 1
* * * * * PROCESS CSECT STATEMENT                                     *
ESCSECT  TM    AVTAGS1,$IBDSEC1    ARE WE IN DSECT CURRENTLY
         BZ    ESCSCS              NO WE AREN'T,SKIP
         NI    AVTAGS1,255-$IBDSEC1          REMOVE DSECT FLAG
         L     RC,AVLOCHIH         GET HIGHEST LOCATION COUNTER VALUE
         B     ESCSTAG             GO TO FLAG SYMBOL TABLE ENTRY
         SPACE 1
ESCSCS   $GLOC RC                  GET CURRENT LOCATION COUNTER
         C     RC,AVCSHIH          COMPARE TO HIGHEST IN CSECT
         BNL   ESCSTAG             GO TO TAG IF HIGHEST VALUE IN RC
         L     RC,AVCSHIH          ORG *-X MUST HAVE OCCURED-GET HIGHES
         EJECT
* * * * * COMMON CODE FOR START AND CSECT                             *
ESCSTART EQU   *
ESCSTAG  LTR   RE,RE               WAS THERE A SYMBOL
         BZ    ESCSDBL             SKIP TO ALIGN IF NO SYMBOL
         OI    SYFLAGS,$SYCSE      NOTE SYMBOL IS A CSECT
ESCSDBL  LA    RD,7                SET UP FOR D ALIGNING
         $ALIGR RC,RD              ALIGN VALUE TO DOUBLEWORD
         NI    AVCESDID,255-$ESDSECT        FLAG AS A CSECT, EVEN VALUE
         B     ESCSETL             GO SET LOCATION COUNTER,ETC.
         SPACE 1
* * * * * ESCSDSEC - PROCESS DSECT                                    *
ESCSDSEC SR    RC,RC               CLEAR FOR VALUE TO SET LOCATION COUN
         OI    SYFLAGS,$SYDSE      FLAG SYMBOL WITH DSECT
         OI    AVCESDID,$ESDSECT   MAKE SURE ODD, I.E. DSECT
         TM    AVTAGS1,$IBDSEC1    ARE WE ALREADY IN DSECT
         BO    ESCSETL             GO SET LOCCNTR IF ALREADY IN DSECT
         L     RD,AVCSHIH          GET HIGH IN CURRENT CSECT
         C     RD,AVLOCNTR         IS IT HIGHER THAN LOCATION COUNTER
         BNL   *+8                 SKIP IF VALUE IN RD IS HIGH
         L     RD,AVLOCNTR         GET LOCATION COUNTER-IT IS HIGH
         ST    RD,AVLOCHIH         SAVE THIS AS HIGHEST VALUE YET ENCOU
         OI    AVTAGS1,$IBDSEC1    NOTE THAT WE ARE NO WIN DSECT
         SPACE 1
ESCSETL  $SLOC RC                  SET NEW LOCATON COUNTER VALUE
         LR    RD,RC               DUPLICATE VALUE OVER FOR SETTING UP
         STM   RC,RD,AVCSLOW       STORE VALUE INTO AVCSLOW-AVCSHIH
         SR    RB,RB               SHOW NO ERRORS
ESCSRET  $RETURN SA=NO
ESCSERPC LA    RB,$ERDPCSE         ILLEGAL CSECT RESUMPTION
         B     ESCSRET             RETURN
         SPACE 1
*              JUMP OFFSET TABLE FOR 3 TYPES OF CALLS TO ESCSEC       *
ESCSJUMP $AL2  ESCSJ,(ESCSECT,ESCSTART,ESCSDSEC)
         DROP  RE                  CLEAR USING
         EJECT
**--> ENTRY: ESENX1       ENTRY AND EXTRN STATEMENTS- PASS 1. . . . . .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER                                                 .
*.  RB = 0 ==> ENTRY                                                  .
*.     = 2 ==> EXTRN                                                  .
*.       EXIT CONDITIONS                                              .
*.  RA = SCAN POINTER TO BLANK FOLLOWING OPERAND FIELD, OR ERROR      .
*.  RB = 0 ==> NO ERRORS.  ^= 0 ==> ERROR CODE TO BE SET              .
*.  RB = NONZERO VALUE - ERROR CODE - ($ERINVDM,$ERINVSY)             .
*.  ALL LABEL'S IN STMT HAVE SYMSECTS FLAGGED APPROPRIATELY.          .
*.       CALLS SYENT1                                                 .
*.       USES MACROS: $CALL,$GTAD,$RETURN,$SAVE                       .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
ESENX1   $SAVE SA=ESDOSAVE,RGS=(R14-R6),BR=RW
         LA    RZ,ESNX1RET         SHOW @ FOR RETURN FROM ERROR
         MVI   ESENXF+1,$SYENT     PLACE THIS INTO FLAGGING INST
         LTR   RB,RB               WAS THIS CALL FOR ENTRY
         BZ    *+8                 SKIP IF SO
         MVI   ESENXF+1,$SYEXT     WAS EXTRN-PUT FLAG BYTE IN
         LA    RY,1                ST UP USEFUL 1 IN ODDREG
         SPACE 1
ESENX1A  BAL   RX,ESSYMBOL         GO HAVE SYMBOL SCANNED AND ENTERED
         USING SYMSECT,RC          NOTE USING(SET UP BY ESSYMBOL)
ESENXF   OI    SYFLAGS,$CHN        WILL HAVE FLAG BYTE PLACED IN
         CLI   0(RA),C' '          WAS THIS LAST ONE
         BE    ESN1RETA            GO RETURN WITH NO ERRORS
         CLI   0(RA),C','          IS DELIMITER RIGHT ONE
         BNE   ESERIND             NO,ERROR
         BXH   RA,RY,ESENX1A       BUMP SCAN PTR, GO FOR NEXT NAME
         SPACE 1
ESN1RETA SR    RB,RB               SHOW NO ERRORS
ESNX1RET $RETURN RGS=(R14-R6)
         EJECT
**--> ENTRY: ESENX2       ENTRY AND EXTRN STATEMENTS - PASS 2 . . . . .
*.       CHECKS ENTRY/EXTRN STATEMENTS FOR CONFLICTS, ERRORS.         .
*.       ENTRY AND EXIT CONDITIONS EXACTLY SAME AS ESENX1             .
*.             EXCEPT EXIT VALUE OF RB MEANS NOTHING.                 .
*.       CALLS ERRTAG,SYENT1                                          .
*.       USES MACROS: $CALL,$GTAD,$RETURN,$SAVE                       .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
ESENX2   $SAVE SA=ESDOSAVE,RGS=(R14-R6),BR=RW
         LA    RZ,ESNX2RET         SHOW @ FOR ERROR RETURN, IF ANY
         LR    R0,RB               SAVE CODE, =0 ==> ENTRY, =2==>EXTRN
         LA    RY,1                FOR BXH'ING CONSTANT IN ODD REG
         SPACE 1
ESNX2L   BAL   RX,ESSYMBOL         CALL SYMBOL LOOKUP ROUTINE
         LTR   R0,R0               ENTRY OR EXTRN
         BNZ   ESNX2EXT            EXTRN-BRANCH
         SPACE 1
         TM    SYFLAGS,$SYDEF      WAS ENTRY DEFINED
         BZ    ESNX2ERA            NO IT WASNT, ERROR BRANCH
         TM    SYFLAGS,$SYDSE+$SYEXT        WAS IT ALSO MARKED DSECT/EX
         BZ    ESNX2M              NO, IT WAS LEGAL, BRANCH
ESNX2ERA LA    RB,$ERENTRY         ENTRY ERROR
         B     ESNX2ERR            GO HAVE IT FLAGGED
         SPACE 1
ESNX2EXT TM    SYFLAGS,$SYDEF+$SYENT+$SYCSE+$SYDSE    IS EXTRN OK
         BZ    ESNX2M              YES, BRANCH, LEGAL
         LA    RB,$EREXTRN         EXTERNAL NAME ERROR
ESNX2ERR SR    RA,RY               BACK SCAN PTR UP 1
         $CALL ERRTAG              HAVE THERROR FLAGGED
         AR    RA,RY               INCREMENT BACK TO DELIMITER
         SPACE 1
ESNX2M   CLI   0(RA),C' '          WAS ENDING DELIMITER BLANK
         BCR   E,RZ                B ESNX2RET - QUIT
         BXH   RA,RY,ESNX2L        BUMP SCAN PTR AND CONTINUE
         SPACE 1
ESNX2RET $RETURN RGS=(R14-R6),SA=ESDOSAVE
         EJECT
         USING ESDOSAVE,R13        GIVE SUBR COMMON BASE FROM 1-2
*              INDIVIUDAL ERROR EXITS AND FLAGGING                    *
ESERIND  LA    RB,$ERINVDM         INVALID DELIMITER
         BR    RZ                  RETURN TO REQUIRED LOCATION
ESERSYM  LA    RB,$ERINVSY         INVALID SYMBOL
         BR    RZ                  RETURN TO REQUIRED LOCATION
         SPACE 1
* * * * * ESSYMBOL - SCAN SYMBOL,HAVE IT ENTERED IN TABLE,RETURN @    *
ESSYMBOL SR    R1,R1               CLEAR SO TRT'S WORK
         TRT   0(9,RA),AWTSYMT     SCAN FOR DELIMITER
         BZ    ESERIND             FLAG ERROR, IF SYMBOL TOO LONG
         CLI   0(RA),C'0'          MAKE SURE NOT LEADING DIGTI
         BNL   ESERSYM             LEADING DIGIT-ILLEGAL
         LR    RB,R1               MOVE END SCAN POINTER OVER
         SR    RB,RA               GET LENGTH OF SYMBOL
         BZ    ESERIND             ZWRO LENGTH SYMBOL -DELIMITER
         $CALL SYENT1              HAVE SYMBOL ENTRED IN TABLE
         LR    RC,RA               MOVE POINTER TO SYMBOL ENTRY OVER
         LR    RA,R1               UPDATE  SCAN POINTER
         BR    RX                  RETURN TO CALLER
         DROP  RC,RW,R13           SYMSECT, REGUALR BASE, 2ND BASE
         TITLE '*** EVALUT - EXPRESSION EVALUATOR ***'
**--> DSECT: EVCTDSCT   EVALUT TRANSITION TABLE ENTRY . . . . . . . . .
*.       THIS DESCRIBES 1 ENTRY IN 1 ROW OF THE GENERAL EXPRESSION    .
*.       EVALUATOR EVALUT, AND GIVES A SECTION OFFSET @ TO USE, AND   .
*.       EITHER A NEXT STATE(ROW) IN TABLE OR AN ERROR CODE FOR AN    .
*.       ILLEGAL CURRENT STATE/CURRENT VALUE COMBINATION.             .
*.       LOCATION: TABLE EVCTAB IN CSECT EVALUT.                      .
*.       GENERATION: 1 ROW OF EVCTDSCTS IS GENERATED BY 1 EVCG MACRO. .
*.       NAMES: EVCT----                                              .
*.  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         SPACE 1
EVCTDSCT DSECT
EVCTADR  DS    AL1                 JUMP OFFSET INDEX FOR ROUTINES
EVCTCOD  DS    AL1                 NEXT ROW OFFSET OR ERROR CODE
EVCTL    EQU   *-EVCTDSCT          LENGTH OF SINGLE TABLE ENTRY
*              EQU'S DEFINING OFFSETS ALONG ROWS IN EVCTAB            *
EVCLP    EQU   0                   (
EVCRP    EQU   EVCTL               )
EVCPL    EQU   2*EVCTL             + -
EVCMU    EQU   3*EVCTL             *
EVCDI    EQU   4*EVCTL             /
EVCAB    EQU   5*EVCTL             ABSOLUTE TERM
EVCRE    EQU   6*EVCTL             RELOCATABLE TERM
EVCBL    EQU   7*EVCTL             BLANK OR ,
         SPACE 2
**--> CSECT: EVALUT   1-2 GENERAL EXPRESSION EVALUATION ROUTINE . . . .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER (ADDRESS OF 1ST CHARACTER OF EXPRESSION)        .
*.       EXIT CONDITIONS                                              .
*.  RA = SCAN POINTER TO DELIMITER STOPPING SCAN, OR ERROR            .
*.  RB = 0 ==> EXPRESSION GOOD, = NONZERO VALUE==>ERROR CODE          .
*.  RC = VALUE OF EXPRESSION, IF IT WAS GOOD                          .
*.  RD = 0 ==> EXPRESSION WAS AN ABSOLUTE EXPRESSION                  .
*.     = ESDID FOR A RELOCATABLE EXPRESSION (1-255)                   .
*.  RE = LENGTH ATTRIBUTE - 1 OF EXPRESSION.                          .
*.       CALLS SDBCDX,SYFIND                                          .
*.       USES DSECTS: AVWXTABL,EVCTDSCT,RCODBLK,RSBLOCK,SYMSECT       .
*.       USES MACROS: $CALL,$GLOC,$RETURN,$SAVE,EVCG                  .
*.                                                                    .
*.       **NOTE** SEE IBM PLM Y26-3700-0, PP. 45-47. EVALUT SOMEWHAT  .
*.       RESEMBLES IEUF7V-EXPRESSION EVALUATION ROUTINE.  NOTE EVALUT .
*.       HAS 1 LESS STATE SETTING, SINCE IEUF7V COND=0 IS UNNEEDED.   .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         EJECT
EVALUT   CSECT
         $DBG  B0,SNAP
* * * * * REGISTER ALLOCATION AND USAGE FOR EVALUT* * * * * * * * * * *
*   R0   UNRESTRICTED WORK REGISTER                                   *
*   R1   ADDRESS WORK REGISTER - HIGH-ORDER BYTE =0 ALWAYS            *
*   R2   BYTE WORK REGISTER - HIGH-ORDER 3 BYTES = 0 ALWAYS           *
*   RW   TERM /SIGN/ID STACK INDEX = INDEX OF NEXT EMPTY H IN EVTRID  *
*   RX   OPERATOR STACK POINTER = @ LAST OPERATOR CODE IN EVOPRS      *
*   RY = 1     USEFUL CONSTANT IN ODD REGISTER, CAN BE USED FOR BSH'S *
*   RZ   STATE REGISTER = @ ROW IN EVCTAB OR @ ENTRY IN EVCTAB        *
*   RA   SCAN POINTER TO NEXT CHARACTER TO BE EXAMINED                *
*   RB-RE      GENERAL WORK REGISTERS AND PARAMETER REGISTERS         *
*   R13  BASE REGISTER AND SAVE AREA POINTER                          *
*   R14  INTERNAL AND EXTERNAL LINK REGISTER                          *
*   R15  UNRESTRICTED WORK REGISTER                                   *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         USING AVWXTABL,RAT        NOTE MAIN TABLE USING
         $SAVE RGS=(R14-R6),BR=R13,SA=EVALSAVE
EVLPC    EQU   2                   AWTSYMT CODE FOR LEFT PAREN
         SPACE 1
*              INITIALIZATION SECTION                                 *
         NI    EVFLENG+1,X'0F'     MAKE SURE BRANCH IS A NOPR
         LA    R0,16               FOR INIT OF EVPCNT-EVTRNM
         STH   R0,EVPCNT           STORE EVPCNT=0, EVTRNM=16
         LM    R1,RW,AWZEROS       ZERO OUT
         LA    RX,EVOPRS           INIT TO BEFINNING OF STACK
         LA    RY,1                HANDY CONSTANT IN ODD REGISTER
         USING EVCTDSCT,RZ         NOTE TRANSITION TABLE ENTRY USING
         B     EVCNEXTA            ENTER AT RIGHT PLACE TO START
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              MAIN CONTROL POINT - PICK UP CODE FROM PREVIOUS ENTRY  *
*        IN TRANSITION TABLE, TO MAKE IT THE CURRENT STATE. FIND FROM *
*        THIS THE @ NEW ROW INT ABLE (NEW STATE).  GET THE NEXT CHAR  *
*        TO BE SCANNED, GET CODE FORM AWTSYMT WHICH DESCRIBES IT. IF  *
*        THE CHAR IS A DELIMITER, SKIP TO EVCOPRT.  FOR A CHARACTER   *
*        WHICH MIGHT BEGIN A TERM (ALPHANUMERIC), SCAN AND EVALUATE   *
*        THE TERM, DETERMINING ITS RELOCATIBILITY ATTRIBUTE FOR LATER *
*        IN REGS RC & RD FOR USE BY EVTERM, IF LEGAL.                 *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
EVCNEXT  IC    R2,EVCTCOD          GET CODE FROM PREVIOUS ENTRY
EVCNEXTA LA    RZ,EVCTAB(R2)       GET @ REQUIRED ROW IN EVCTAB
         AIF   (&$DEBUG).EVCX0     SKIP IF PRODUCTION MODE
         XSNAP IF=(AVDEBUG,O,X'B0',TM),STORAGE=(EVOPRS,EVALQ),         #
               LABEL='EVCNEXTA'
.EVCX0   ANOP
         IC    R2,0(RA)             GET THE NEXT SOURCE BYTE
         IC    R2,AWTSYMT(R2)       GET THE CODE FROM THE TABLE
         CR    R2,RY                COMPARE TO 1 FOR TYPE
         BH    EVCOPRT              IF >1, CHARACTER WAS OPERATOR
         BE    EVZILCH              ILLEGAL CHARACTER, IF =1
         SPACE 1
*              TERM-PROCESSING SECTION - CODE IN R2 = 0               *
         CLI   0(RA),C'0'           WAS IT A DIGIT
         BNL   EVCSDT2             SKIP TO SELF-DEFINING TERM SECTION
         CLI   1(RA),C''''          IS NEXT CHAR A '
         BE    EVCSDT1              SKIP IF SO, I.E. L' B' C' OR X'
         SPACE 1
*              SYMBOL FOUND - HAVE IT SCANNED. GET VALUE,SECTION ID.
         BAL   R14,EVSYMB           CALL SYMBOL ROUTINE
         USING SYMSECT,RB           NOTE POINTER
         L     RC,SYVALUE           GET VALUE OF SYMBOL INTO RC
         IC    R2,SYLENG            GET LENGTH-1
         BAL   R14,EVFLENG          CALL LENGTH ATTRIB SAVER
         IC    R2,SYESDID           GET SECTION ID
         LTR   RD,R2                MOVE SECTION ID AND TEST IT
         BZ    EVCABSA              SKIP IF0, I.E. ABSOLUTE SYMBOL
         LA    R2,EVCRE            SHOW OFFSET FOR RELOCATABLE TERM
         B     EVCJUMPA             GO TO MAKE CHOICE
         EJECT
*              ABSOLUTE TERM - SELF-DEFINING OR LENGTH ATTRIBUTE      *
EVCSDT1  CLI   0(RA),C'L'           WAS IT L'
         BNE   EVCSDT2              NO, MUST BE X' B' OR C'
*              TERM IS A LENGTH ATTRIBUTE - L'SYMBOL OR L'*.
         LA    RA,2(RA)             BUMP SCAN PTR PAST L'
         CLI   0(RA),C'*'          IS IT L'*
         BNE   EVCSDT2A            SKIP IF NOT (BRANCH PROBABLE)
         BAL   R14,EVFLQAS         CALL L'* ROUTINE
         BXH   RA,RY,EVCSDT2B      BRANCH, INCREM SCAN PTR BEYOND *
         SPACE 1
*              PROCESS SELF-DEFINING TERM                             *
EVCSDT2  $CALL SDBCDX              CALL SELF-DEF TERM PROCESSOR
         LTR   RB,RB                WAS RESULT OK
         BZ    EVCSDT3              YES,OK,RESULT IN RC
         BP    EVZERROR             ERROR,BRANCH
         BXH   RA,RY,EVZSYNT       ' BAD, LETTER NOT B,C,X-ERROR
         SPACE 1
EVCSDT2A BAL   R14,EVSYMB          CALL SYMBOL LOOKUP
         IC    R2,SYLENG           GET LENGTH-1
         DROP  RB                  REMOVE SYMSECT USING
EVCSDT2B LA    RC,1(R2)            MOVE, CONVERT LENGTH-1 TO LENGTH
         BAL   R14,EVFLENG         HAVE LENGTH ATTRIB SAVED,IF NEEDED
*              IF EVCSDT3 ENTERED THRU EVCSDT1, R2 STILL =0 (L' =1)
EVCSDT3  BAL   R14,EVFLENG         HAVE LENGTH-1 SAVED, IF NOT ALREADY
         SR    RD,RD                SHOW ABSOLUTE TERM
EVCABSA  LA    R2,EVCAB            SHOW OFFSET FOR ABSOLUTE TERM
         B     EVCJUMPA             GO TO MAKE BRANCH
         EJECT
* * * * * EVFLQAS - OBTAIN L'*-1, RETURN IT IN R2, IF IT EXISTS       *
*        THIS ROUTINE CALLED ONLY BY TERM PROCESSING SECTION          *
*        EXIT CONDITIONS                                              *
*   R2 = L'* - 1, FOR USE AS EXPLICIT LENGTH ATTRIBUTE, OR IMPLIED L  *
         SPACE 1
EVFLQAS  L     R15,AVRSBPT         GET RSB POINTER
         USING RSBLOCK,R15         NOTE USING FOR RSBLOCK
         SR    R2,R2               SET R2=0, I.E. L'* = 1
         TM    RSBFLAG,$RCBX       IS THERE AN RCB
         BCR   Z,R14               RETURN IF THERE ISN'T ANY,USE 1
         L     R15,AVRCBPT         RCB EXISTS, GET THE @ OF IT
         USING RCODBLK,R15         NOTE NEW USING
         IC    R2,RCLQ             GET THE L'* VALUE
*        BR R14 FALL THRU INTO EVFLENG, SET LENGTH-1 OR JUST RETURN.
         DROP  R15                 KILL RCODBLK USING
         SPACE 1
* * * * * EVFLENG - STORE LENGTH ATTRIBUTE-1, IF 1ST TIME             *
*        THIS ROUTINE CALLED ONLY FROM TERM PROCESSING SECTION.       *
*        MUST IMMEDIATELY FOLLOW SECTION EVFLQAS.                     *
*        ENTRY CONDITIONS                                             *
*   R2 = LENGTH ATTRIVUTE-1                                           *
         SPACE 1
EVFLENG  BCR   $CHN,R14             RETURN TO CALLER IF NOT 1ST TIME
         OI    EVFLENG+1,X'F0'      CHANGE NOPR TO BR
         STC   R2,EVALQ             SAVE LENGTH ATTRIBUTE - 1
         BR    R14                  RETURN TO CALLER
         SPACE 1
* * * * * EVSYMB - SCAN SYMBOL AND HAVE IT LOOKED UP BY SYFIND        *
*        THIS SECTION CALLED ONLY FROM TERM PROCESSING SECTION.       *
*        ENTRY CONDITIONS                                             *
*   RA = SCAN POINTER TO 1ST CHARACTER OF SYMBOL                      *
*        EXIT CONDITIONS                                              *
*   RA = SCAN POINTER TO DELIMITER FOLLOWING SYMBOL                   *
*   RB = @ SYMSECT ENTRY IN SYMBOL TABLE OF THE SYMBOL                *
         SPACE 1
EVSYMB   TRT   0(9,RA),AWTSYMT      SCAN FOR DELIMITER
         BZ    EVZINVSY             IF NOT FOUND,SYMBOL TOO LONG-ERROR
         LR    RB,R1               GET PTR TO DELIMITER INTO RB
         SR    RB,RA                GET LENGTH OF SYMBOL
         BZ    EVZILCH              ILLEGAL CHARACTER
         LR    R0,R14               SAVE RETURN @
         SPACE 1
         $CALL SYFIND              CALL LOOKUP ROUTINE
         LTR   RB,RB                WAS THE SYMBOL UNDEFINED
         BNZ   EVZUNDEF             UNDEFINED SYMBOL,ERROR
         LR    RB,RA                MOVE POINTER TO SYMBOL OVER
         USING SYMSECT,RB           NOTE SYMBOL POINTE
         TM    SYFLAGS,$SYDEF       WAS SYMBOL DEFINED
         BZ    EVZUNDEF             NO,UNDEFINED-BRANCH
         LR    RA,R1                GET SCAN PTR TO DELIMITER
         LR    R14,R0               RESTORE RETURN @
         BR    R14                  RETURN TO CALLING SECTION
         DROP  RB                   KILL USING
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              BRANCH ACCORDING TO CURRENT STATE (GIVEN BY RZ) AND    *
*        TYPE OF TERM OR DELIMITER.  USE VALUES IN EVCTAB, WHICH      *
*        CONTAIN OFFSET JUMP VALUES, AND EITHER A NEXT STATE VALUE,   *
*        OR AN ERROR CODE IF A BRANCH TAKEN DIRECTLY TO EVCERR.       *
*        THE LABELS EVERR, EVLOCNT, EVTERM, EVPCHIH, EVPCTES, EVPCZER,*
*        AND EVOPCHK MUST ALL BE WITHIN 256 BYTES OF EVDJUMP.         *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
EVCOPRT  LR    R1,R2               SAVE OPERATOR CODE FROM AWTSYMT
         IC    R2,EVCOFFS(R2)      GET OFFSET FOR TRANSITION TABLE
EVCJUMPA LA    RZ,EVCTDSCT(R2)     GET @ INDIVIDUAL ENTRY INTABLE
         IC    R2,EVCTADR          GET JUMP INDEX VALUE FROM TABLE
         AIF   (&$DEBUG).EVCX1     SKIP IF PRODUCTION MODE
         XSNAP IF=(AVDEBUG,O,X'B0',TM),                                #
               STORAGE=(*EVDJUMP(R2),*EVDJUMP+4(R2)),LABEL='EVDJUMP'
.EVCX1   ANOP
         B     EVDJUMP(R2)         TAKE BRANCH TO PARTICULAR ROUTINE
EVDJUMP  EQU   *                   BASE FOR RPUTINE JUMPS
         SPACE 1
* * * * * EVERR - OBTAIN ERROR CODE FROM TRANSITION TABLE, EXIT.      *
EVERR    IC    R2,EVCTCOD          GET ERROR CODE
         LR    RB,R2                MOVE TO EXPECTED LOCATION
         B     EVZERROR             GO TO FINISH
         SPACE 1
* * * * * EVLOCNT - PROCESS LOCATION COUNTER REFERENCE                *
EVLOCNT  $GLOC RC                   GET LOCATION COUNTER
         IC    R2,AVCESDID          GET SECTION ID CURRENT
         LR    RD,R2               MOVE OVER WHERE EXPECTED
         BAL   R14,EVFLQAS         CALL L'* ROUTINE, SAVE LENGTH-1 ATT
         AR    RA,RY               BUMP SCAN PTR 1, FALL THRU TO EVTERM
         SPACE 1
* * * * * EVTERM - ENTER TERM VALUE AND ID INTO EVTRMS/EVTRID         *
*        THIS SECTION MUST IMMEDIATELY FOLLOW EVLOCNT.                *
*        ENTRY CONDITIONS                                             *
*   RC = VALUE OF TERM TO BE ENTERED                                  *
*   RD = SECTION ID (1-255) FOR RELOCATABLE, 0 FOR ABSOLUTE TERM      *
*   RW = INDEX OF NEXT EMPTY SLOT IN EVTRID                           *
*        EXIT CONDITIONS                                              *
*   RW = RW+2  (I.E. ONE ENTRY HAS BEEN PUSHED INTO STACK)            *
         SPACE 1
EVTERM   IC    R2,EVTRNM           GET # TERMS LEFT TO GO
         SR    R2,RY               DECREMENT
         BM    EVZTMTR             TOO MANY TERMS IN EXPRESSION
         STC   R2,EVTRNM           STORE BACK UPDATED VALUE
         STH   RD,EVTRID(RW)       STORE SECTION ID
         LA    R15,0(RW,RW)        GET INDEX FOR EVTRMS ENTRY
         ST    RC,EVTRMS(R15)      STORE  THE VALUE OF TERM
         LA    RW,2(RW)            INCREMENT THE OFFSET INDEX
         B     EVCNEXT             GO BACK FOR NEXT ONE
         EJECT
* * * * * EVPCHIH - ( FOUND, INCREMENT AND TEST PAREN COUNT           *
EVPCHIH  CLI   EVPCNT,4             CHECK PAREN COUNT
         BH    EVZPARN              TOO MANY PARENS-BRANCH
         IC    R2,EVPCNT            GET PAREN COUNT
         AR    R2,RY               INCREMENT BY 1
         STC   R2,EVPCNT            STORE BACK
         B     EVOPENT             GO ENTER OPERATOR
         SPACE 1
* * * * * EVPCTES - , OR BLANK FOUND, MAKE SURE PAREN COUNT = 0       *
EVPCTES  CLI   EVPCNT,0             IS PAREN COUNT 0 LIKE IT SHOULD BE
         BE    EVFRCA              YES, GO FORCEBACK ALL OPERATORS
         B     EVERR               ERR-UNEXPECTED END OF EXPRESSION
         SPACE 1
* * * * * EVPCZER - ) FOUND, TEST AND DECREMENT PAREN COUNT, FORCEBACK*
EVPCZER  IC    R2,EVPCNT            GET PAREN COUNT
         SR    R2,RY                DECREMENT PAREN COUNT
         BNM   *+8                 IF WAS NOT PREVIOUSLY ZERO, JUMP
         BXLE  R2,RY,EVFRCA        SET R2=0, BRANCH TO FINISH UP
         STC   R2,EVPCNT            STORE BACK
         SPACE 1
* * * * * EVFRCP - FORCE EVALUATION BACK TO LAST LEFT PAREN           *
*              LOOP UNTIL LEFT PAREN CODE FOUND IN OPERATOR STACK     *
EVFRCP   BALR  R14,0               SET R14 = @ NEXT INSTRUCTION, LOOP
         CLI   0(RX),EVLPC         IS CURRENT CODE THAT OF LEFT PAREN
         BNE   EVFRCO              NO, SO EVALUATE UNTIL WE FIND (
         SPACE 1
         SR    RX,RY               DECREMENT OPERATOR STACK POINTER
         AR    RA,RY               BUMP SCAN POINTER PAST )
         LH    R15,EVTRID-2(RW)    GET CURRENT SIGN/ID
         LTR   R15,R15             IS IT ABSOLUTE
         BZ    EVCNEXT             ABSOLUTE, SO USE NEXT STATE FROM TAB
         LA    R2,EVCT4-EVCTAB     OFFSET FOR RELOCATABLE
         B     EVCNEXTA            GO FOR NEXT
         SPACE 1
* * * * * EVOPCHK - CHECK OPERATOR PRECEDENCE, EVALUATE IF NEEDED     *
*        ENTRY CONDITIONS                                             *
*   R1 = OPERATOR CODE OF CURRENT OPERATOR, FROM AWTSYMT              *
EVOPCHK  IC    R2,0(RX)            GET CODE OF PREVIOUS OPERATOR
         IC    R2,EVOPREC(R2)      PRECEDENCE OF PREV OP +- = 0
         SR    R15,R15             CLEAR FOR INSERT
         IC    R15,EVOPREC(R1)     GET PRECEDENCE OF NEW OPERATOR
         CR    R15,R2              IF NEW PREC > OLD, SKIP EVALUATRE
         BH    *+8                 IF NEW CODE> OLD CODE, SKIP EVAL
         BAL   R14,EVFRCO          FORCE 1 OPERATOR EVALUATION
         SPACE 1
EVOPENT  AR    RX,RY               INCREMENT POINTER TO EMPTY SLOT
         STC   R1,0(RX)            STORE CODE OF NEW OPERATOR
         BXH   RA,RY,EVCNEXT       BUMP SCAN POINTER, GET NEXT CODE
         SPACE 1
         EJECT
* * * * * EVFRCO - EVALUATE 1 OPERATOR AND 2 TERMS IN STACKS          *
*        ENTRY CONDITIONS                                             *
*   RW = INDEX OF NEXT EMPTY HALFWORD IN EVTRID STACK                 *
*   RX = @ LAST OPERATOR CODE ENTERED IN OPERATOR STACK EVOPRS        *
*   R14= RETURN ADDRESS TO CALLING SECTION OF CODE.                   *
*        EXIT CONDITONS                                               *
*   RC = COMPUTED RESULT OF OPERATION                                 *
*   RW = RW-2  (I.E. 1 ENTRY OF EVTRID&EVTRMS WAS POPPED)             *
*   RX = RX-1  (I.E. ONE ENTRY FROM OPERATOR STACK WAS POPPED)        *
EVFRCO   SR    RW,RY               SUBTRACT 1 FROM INDEX
         SR    RW,RY               SUBTRACT ANOTHER 1, MAKING -2
         LH    RE,EVTRID(RW)       GET PREVIOUS SIGN CODE/SECTION ID
         LA    R15,0(RW,RW)        GET 2* RW FOR INDEX INTO EVTRMS
         LA    R15,EVTRMS-4(R15)   GET @ 2ND PREVIOUS ENTRY
         LM    RC,RD,0(R15)        GET 2ND PREVIOUS,PREVIOUS EVTRMS
         IC    R2,0(RX)            GET CURRENT OPERAOTR CODE
         IC    R2,EVFRCT-5(R2)     GET OFFSET VALUE FOR TYPE JUMP
         B     EVFRJ(R2)           TAKE BRANCH TO SECTION
EVFRJ    EQU   *                   BASE FOR OPERATOR JUMPS
         SPACE 1
*        - OPERATOR                                                   *
EVFRMI   SR    RC,RD               PERFORM OPERATION
         LCR   RE,RE               COMPLEMENT SIGN CODE/SECTION ID
         B     EVFRPLA             CONTINUE WITH COMMON +- CODE
         SPACE 1
*        + OPERATOR                                                   *
EVFRPL   AR    RC,RD               PERFORM OPERATION
         LTR   RE,RE               WAS PREVIOUS AN ABS TERM(RE=0 IF SO)
EVFRPLA  BZ    EVFRCOEX            YES, SO LEAVE 2ND PREV CODE AS IS
         LH    RB,EVTRID-2(RW)     GET 2ND PREVIOUS SIGN CODE/ID
         LTR   RB,RB               WAS 2ND PREV TETRM ABSOLUTE
         BZ    EVFRPLB             YES, SO USE PREV CODE UNCHANGED-BRAN
         AR    RE,RB               2 RELOCATABLE TERMS, ADD SIGN/ID
         BNZ   EVZCXREL            IF NO 0, COMPLEX RELOCATIBILITY
EVFRPLB  STH   RE,EVTRID-2(RW)     SAVE COMPUTED SIGN/ID INTO RESULT
         B     EVFRCOEX            HAVE RESULT SAVED AND EXIT
         SPACE 1
*        * OPERATOR                                                   *
EVFRMU   MR    RB,RD               1ST OP IN RC, RESULT VALUE ALSO
         B     EVFRCOEX            GO HAVE RESULT STORED
         SPACE 1
*        / OPERATOR                                                   *
EVFRDI   LR    RB,RC               MOVE 2ND PREVIOUS VALUE OVER
         LTR   RC,RD               MOVE AND TEST DIVISOR OVER
         BZ    EVFRCOEX            IF DIVISOR =0, LEAVE RC=0,BRANCH
         SRDA  RB,32               PROPAGATE SIGN,MOVE DIVIDEND BACK
         DR    RB,RD               PERFORM OPEATION ,HAVING CHECKED 0
         SPACE 1
EVFRCOEX ST    RC,0(R15)           STORE RESULT INTO EVTRMS STACK
         AIF   (&$DEBUG).EVCX2     SKIP IF PRODUCTION MODE
         XSNAP IF=(AVDEBUG,O,X'B0',TM),LABEL='EVFRCOEX'
.EVCX2   ANOP
         BCTR  RX,R14              BACK UP OPERATOR POINTER 1, RETURN
         EJECT
* * * * * EVFRCA - FORCE EVALUATION OF ALL VALUES, RETURN TO CALLER   *
*        LOOP CALLING EVFRCO UNTIL LEFT PAREN CODE FOUND              *
*        NOTE THAT EVFRCO LEAVE RESULT IN RC, SO NEED NOT BE FETCHED. *
EVFRCA   BALR  R14,0               SET R14 = @ NEXT INSTRUCTION
         CLI   0(RX),EVLPC         IS CURRENT OP CODE LEFT PAREN
         BNE   EVFRCO              IF NOT, CALL FORCE 1 OPERATOR SECTIO
         SPACE 1
         LH    RD,EVTRID           GET 1ST RELOCATE ID HALFWORD
         LTR   RD,RD               IS IT ACCEPTABLE (0 OR +)
         BM    EVZCXREL            IF <0, NEGATIVE RELOCATABLE TERM
         CL    RC,AWFX6F           IS VALUE WITHIN 24 BITS
         BH    EVZEXGTA            NO,ERROR BRANCH
         IC    R2,EVALQ            GET LENGTH ATTRIBUTE - 1
         LR    RE,R2               MOVE LENGTH ATTRIBUTE - 1 OVER
         SR    RB,RB               SHOW THE EXPRESSION WAS OK
EVZERROR EQU   *                   DEFINE LABEL FOR ERROR EXIT
EVRET    $RETURN RGS=(R14-R6)
         SPACE 1
* * * * * ERROR EXIT SECTION                                          *
EVZCXREL LA    RB,$ERCXREL         COMPLEX RELOCATIBILITY ILLEGAL
         B     EVZERROR            EXIT, WITH ERROR CODE
EVZEXGTA LA    RB,$EREXGTA         SHOW LARGER THAN 24 BITS
         LTR   RC,RC               WAS VALUE POSITIVE
         BP    EVZERROR            BRANCH IF SO, FALL THRU IS NOT
EVZEXLTA LA    RB,$EREXLTA         SHOW EXPRESSION NEGATIVE
         B     EVZERROR            GO RETURN WITH ERROR
EVZILCH  LA    RB,$ERVILCH         ILLEGAL CHARACTER
         B     EVZERROR            EXIT, WITH ERROR CODE
EVZINVSY LA    RB,$ERINVSY          SHOW INVALID SYMBOL
         B     EVZERROR             GO TO SHOW ERROR
EVZPARN  LA    RB,$ERVPARN         TOO MANY PARENS
         B     EVZERROR            EXIT, WITH ERROR CODE
EVZSYNT  LA    RB,$ERVSYNT         SYNTAX
         B     EVZERROR            EXIT, WITH ERROR CODE
EVZTMTR  LA    RB,$ERVTMTR         TOO MANY TERMS IN EXPRESSION
         B     EVZERROR            GO RETURN WITH ERROR
EVZUNDEF LR    RA,R1                MOVE SCAN POINTER BACK
         SR    RA,RY               DECREMNT BY 1 FOR BETTER POINTER
         LA    RB,$ERUNDEF          SHOW UNDEFINED
         B     EVZERROR             GO TO ERROR SECTION
         EJECT
* * * * * INTERNAL CONSTANTS                                          *
EVCOFFS  EQU   *-2                 OFFSET BACKWARDS SMALLEST INDEX
*              OFFSETS OBTAINED USING INDEX VALUE FROM AWTSYMT        *
         DC    AL1(EVCLP,EVCRP,EVCBL,EVCPL,EVCPL,EVCMU,EVCDI)
*        JUMP OFFSET TABLE FOR EVFRCO - FOR + - * / OPERATORS         *
EVFRCT   DC    AL1(EVFRPL-EVFRJ,EVFRMI-EVFRJ,EVFRMU-EVFRJ,EVFRDI-EVFRJ)
EVOPREC  EQU   *-2                 ORIGIN RIGHT FOR INDICES 2 UP
         DC    AL1(0,0,0,1,1,2,2)  PRECEDENCES: ( X X + - * / (2-8)
         SPACE 1
EVCTAB   DS    0H                  TRANSITION TABLE
EVCT1    EVCG  (PCHIH,1,ERR,SYNT,ERR,SYNT,LOCNT,4,ERR,SYNT,TERM,3,TERM,#
               4,ERR,UNEX)         BEGINNING ( + - LAST FOUND
EVCT2    EVCG  (PCHIH,1,ERR,SYNT,ERR,SYNT,ERR,SYNT,ERR,SYNT,TERM,3,ERR,#
               RELO,ERR,UNEX)      * / OPERATORS LAST ENCOUNTERD
EVCT3    EVCG  (PCTES,SYNT,PCZER,3,OPCHK,1,OPCHK,2,OPCHK,2,ERR,SYNT,ERR#
               ,SYNT,PCTES,UNEX)   ABSOLUTE TERM WAS LAST
EVCT4    EVCG  (PCTES,SYNT,PCZER,3,OPCHK,1,ERR,RELO,ERR,RELO,ERR,SYNT,E#
               RR,SYNT,PCTES,UNEX) RELOCATABLE TERM LAST PREVIOUS
         SPACE 1
*              OPERATOR STACK - 1ST ENTRY IS CODE FOR (               *
EVOPRS   DC    AL1(EVLPC)          BEGINNING OF OPERATOR STACK,LEFT PRN
         DS    21C                 REMAINING SECTION OF EVOPRS
         SPACE 1
*              TERM STACK - COMPUTED VALUES KEPT TO 32 BITS.          *
EVTRMS   DS    16F                 TERM STACK
         SPACE 1
*              SIGN CODE/ID STACK. EACH HALFWORD IS ASSOCIATED WITH   *
*        CORRESPONDING FULLWORD IN EVTRMS.   FOR ABSOLUTE VALUES, THE *
*        EVTRID ENTRY = 0, FOR RELOCATABLE VALUES, THE SECTION ID IS  *
*        ENTERED IN THE 2ND BYTE OF A HALFWORD, WITH ZEROS IN THE 1ST *
*        BYTE.  IF THE VALUE IS NEGATIVE, THE HALFWORD IS COMPLEMENTED*
EVTRID   DS    16H                 SIGN CODE/ID STACK
*              EVPCNT AND EVTRNM MUST BE IN ORDER, ON H BOUNDARY      *
EVPCNT   DS    C                   PAREN COUNT - 0<=EVPCNT<=5
EVTRNM   DS    C                   # TERMS LEFT (INIT TO 16
EVALQ    DS    C                   LENGTH ATTRIVUTE - 1 OF EXPRESSION
         DROP  RAT,R13,RZ          KILL USINGS
         TITLE '*** IAMOP1 - MACHINE OPCODES - PASS 1 ***'
**--> CSECT: IAMOP1   1   MACHINE OPERATIONS - PASS 1 . . . . . . . . .
*.       THIS IS 1 OF 2 PASS 1,LEVEL 2 PROGRAMS.  IT PERFORMS ALL     .
*.       PASS 1 MACHINE INSTRUCTION PROCESSING, INCLUDING ALIGNMENT   .
*.       OF THE LOCATION COUNTER, SCANNING FOR LITERAL CONSTANTS,     .
*.       AND BUILDING AN RCODBLK FOR THE STATEMENT.  THE RCODBLK      .
*.       INCLUDES THE INSTRUCTION FORMAT TYPE, THE MACHINE CODE FOR   .
*.       THE GIVEN INSTRUCTION, MASK (EXTENDED MNEMONICS), FLAGS      .
*.       AND ALIGNMENT VALUES NEEDED, THE LENGTH ATTRIBUTE-1 FOR THE  .
*.       INSTRUCTION, AND THE ADDRESS OF A LITERAL CONSTANT IN THE    .
*.       LITERAL TABLE, IF THERE IS ONE USED.                         .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER (ADDRESS OF 1ST CHARACTER OF OPERAND FIELD)     .
*.  RC = ADDRESS OF OPCODE CONTROL TABLE ENTRY FOR OPCODE USED        .
*.       EXIT CONDITIONS                                              .
*.  RB = 0    NO ERRORS WERE ENCOUNTERED                              .
*.     = >0   ERRORS WERE FOUND IN STATEMENT                          .
*.  RC = @ RECORD CODE BLOCK(RCODBLK) FOR THE STATEMENT.              .
*.       THE RCODBLK HAS ALL VALUES FILLED IN EXCEPT RCLOC(IARCLOC).  .
*.  RD = LENGTH OF CODE - TO BE ADDED AFTER ALIGNMENT DONE            .
*.       CALLS ERRTAG,LTENT1,SCANEQ                                   .
*.       USES DSECTS: AVWXTABL,OPCODTB                                .
*.       USES MACROS: $CALL,$CKALN,$GLOC,$LTENT1,$RETURN,$SAVE,$SLOC  .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
IAMOP1   CSECT
         $DBG  90,*
         USING AVWXTABL,RAT        NOTE MAIN TABLE USING
         $SAVE RGS=(R14-R3),BR=R13,SA=IAMOSAVE
         USING OPCODTB,RC          NOTE TABLE POINTER
         MVC   IARCTYPE(3),OPCTYPE MOVE CODE BYTES OVER
         DROP  RC                  NO LONGER NEED POINTER HERE
         MVI   IARCLENG,RC$LEN     PUT IN NORMAL LENGTH-1
         LM    R1,R3,AWZEROS       GET HANDY ZEROS
         IC    R1,IARCHEX          GET HEX OPCODE
         SRL   R1,6                SHIFT TO GET INDEX
         IC    R3,IALENGS(R1)      GET LENGTH-1 FOR LENGTH ATTRIBUTE
         STC   R3,IARCLQ           SAVE FOR L' ATTRIBUTE
         SPACE 1
         CLI   AVCESDID,0          WAS CODE PRECEDED BY A CSECT
         BNE   IALICHK             CSECT OR DSECT BEFORE-BRANCH
         SPACE 1
         MVI   AVCESDID,2          NO, UNITIATED PRIVAT  CODE
         OI    AVTAGS1,$IBSTAR1+$IBPRCD1    SHOW NO START, PRIV CODE IN
         SPACE 1
IALICHK  $CKALN 1,IALNOK           CHECK ALIGNMENT AND BRANCH OK
         $GLOC R1                  GET LOCATION COUNTER VALUE
         LA    R1,1(R1)            INCREMENT TO HALFWORD BOUNDARY
         $SLOC R1                  SET NEW LOCATION COUNTE VALUE
         EJECT
*              SCAN FOR LITERAL OR END OF OPERAND FIELD               *
IALNOK   EQU   *
         $CALL SCANEQ              SCAN TO = OR LBANK
         CLI   0(RA),C' '          ARE WE TO END OF STATEMENT
         BE    IARETA              YES,WE'RE DONE
         CLI   0(RA),C'='          MAKE SURE IT IS =
         BNE   IARETA              IF NOT, ERROR, BUT DON'T FLAG NOW
         SPACE 1
*              LITERAL FOUND- HAVE IT SAVED, WITH POINTER VALUES.
         $CALL LTENT1              CALL TO ENTER LITERAL
         LTR   RB,RB               WAS LITERAL OK
         BNZ   IAERROR             NO IT WASN'T,BRANCH
         MVI   IARCLENG,RC$LEN2    SET LENGTH TO LENGTH WITH LITERAL
         ST    RC,IARCLITA         SAVE ADDRESS OF LITERAL
         SPACE 1
IARETA   EQU   *                   EXIT LABEL
         AIF   (&$COMNT EQ 0).IANOCOM       SKIP IF NO COMMENT CHEK
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              MACHINE INSTRUCTION COMMENT COUNTING ROUTINE.          *
*        IF THE COMMENT CHECK OPTION IS SPECIFIED, EITHER BY THE      *
*   COMNT PARM OPTION, OR BY ACCOUNT NUMBER SETTING,  THIS CODE       *
*   COUNTS THE NUMBER OF MACHINE INSTRUCTIONS, AND ALSO COUNTS THE    *
*   APPROXIMATE NUMBER OF THEM WHICH HAVE A COMMENT OF 4 OR MORE      *
*   NONBLANK CHARACTERS.  (SEE VARIABLES AVMACHIN  AND  AVCOMNTN).    *
*   THESE VALUES ARE INITIALIZED TO ZERO IN OUINT1, AND ARE USED IN   *
*   OUEND2 TO MAKE SURE THAT STUDENT PROGRAMMERS PUT A GIVEN AMOUNT   *
*   OF COMMENTS ON THEIR INSTRUCTIONS (I.E. &$COMNT PER CENT OF THE   *
*   MACHINE INSTRUCTIONS MUST HAVE COMMENTS ARE ELSE THE PROGRAM WILL *
*   NOT BE EXECUTED.).                                                *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         TM    AVTAGS2,AJOCOMNT    IS COMMENT CHK IN EFFECT
         BZ    IARETA2             NO, SO DON'T CHECK THEM
         SPACE 1
         LA    R1,1                SET R1 FOR USEFUL VALUE, BXHING
         AR    RA,R1               BUMP SCAN PTR BEYOND POSSIBLE '(LIT)
         LH    RE,AVMACHIN         GET CURRENT # MACHINE INSTS
         AR    RE,R1               INCREMENT FOR THIS INSTRUCTION
         STH   RE,AVMACHIN         STORE UPDATED COUNTER BACK
         SPACE 1
*              SCAN TO FIND THE COMMENT FIELD, IF ANY.
         CLI   0(RA),C' '          IS NEXT CHAR BLANK
         BNE   *+8                 NO-JUMP OUT, COMMENT BEGUN
         BXH   RA,R1,*-8           BUMP SCAN PTR BY 1, LOOP
         SPACE 1
         L     RE,AVSOLAST         GET @ BLANK BEFORE AFTER QUOTE
         LR    RD,R1               MOVE A 1 TO REG RD FOR BXLE INCREM
         LA    R1,4                ***** # NONBLANKS REQUIRED *********
         SPACE 1
*              LOOP UNTIL EITHER AFTERQUOTE FOUND OR 4 NONBLANKS.
         CLI   0(RA),C' '          IS THIS A BLANK
         BNE   *+12                NO, SKIP TO BCT TO COUNT IT
         BXLE  RA,RD,*-8           INCREMENT SCN PTR, LOOP BACK
         B     IARETA2             FELL THRU - SHORT COMMENT-DON'T COUN
         BCT   R1,*-8              COUNT # CHARS, LOOP TO BXLE
         SPACE 1
*              LEGITAMATE COMMENT FILED-GIVE PROGRAMMER CREDIT FOR IT.
         LH    RE,AVCOMNTN         GET ACCUMULATD # COMMENTS
         AR    RE,RD               INCREMENT BY 1 FROM RD
         STH   RE,AVCOMNTN         RESTORE UPDATED # COMMENTS
         SPACE 1
.IANOCOM ANOP
*              POINT TO OUR RCB AND RETURN TO MAIN CONTROL.
IARETA2  LA    RC,IARCB            SHOW @ OF OUR RCB FOR MAINPROG
         LA    RD,1(R3)            GET TOTAL LENGTH IN RD FOR RETURN
IARET    $RETURN RGS=(R14-R3)      RETURN TO CALLER
         SPACE 1
* * * * * INDIVIDUAL ERROR SECTIONS
IAERROR  $CALL ERRTAG              CALL ERROR FLAGGING ROUTINE
         B     IARETA              GO RETURN
         EJECT
* * * * * INTERNAL CONSTANTS                                          *
IALENGS  DC    HL1'1,3,3,5'        LENGTH-1 BYTES FOR EACH INST TYPE
         SPACE 1
* * * * * INTERNAL VARIABLES                                          *
*        RCB ENTRIES FOR IAMOP1                                       *
IARCB    DS    0D                  RECORD CODE BLOCK
IARCLENG DS    C                   LENGTH OF RCB
IARCLOC  DS    AL3                 LOCATION COUNTER VALUE (BY MOCON1)
IARCTYPE DS    C                   PRIMARY TYPE BYTE
IARCHEX  DS    C                   HEX OPCODE FOR MACH INSTS
IARCMASK DS    C                   MASK/LITERAL TAGS/ALIGNMENT
IARCLQ   DS    C                   FOR L'*
IARCLITA DS    A                   ADDRESS OF A LITERAL,IF EXISTS
IARCEND  DS    0C                  END OF RCB ENTRY
         DROP  RAT,R13             CLEAR USING
         TITLE '*** IBASM1 - ASSEMBLER OPCODES - PASS 1 ***'
**--> CSECT: IBASM1   1   ASSEMBLER INSTRUCTIONS - PASS 1 . . . . . . .
*.       THIS MODULE IS 1 OF THE 2 PASS 1,LEVEL 2 ROUTINES OF THE     .
*.       ASSIST ASSEMBLER.  IT PERFORMS ALL PROCESSING FOR ASSEMBLER  .
*.       INSTRUCTIONS DURING PASS 1, INCLUDING SCANNING, MODIFYING    .
*        LOCATION COUNTERS, AND BUILDING AN RCODBLK FOR THE STMT.     .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER (ADDRESS OF 1ST CHARACTER OF OPERAND FIELD)     .
*.  RC = ADDRESS OF OPCODE CONTROL TABLE ENTRY FOR OPCODE USED        .
*.       EXIT CONDITIONS                                              .
*.  RB = 0    NO ERRORS WERE ENCOUNTERED                              .
*.     = >0   ERRORS WERE FOUND IN STATEMENT                          .
*.  RC = ADDRESS OF RECORD CODE BLOCK (RCB)                           .
*.  RD = LENGTH OF CODE - TO BE ADDED AFTER ALIGNMENT DONE            .
*.       CALLS CCCON1,CODTL1,ERRLAB,ERRTAG,ESCSEC,ESENX1              .
*.       CALLS EVALUT,LTDMP1,SDBCDX,SDDTRM                            .
*.       USES DSECTS: AVWXTABL,CNCBLOCK,IBPSECT,OPCODTB,SYMSECT       .
*.       USES MACROS: $AL2,$ALIGR,$CALL,$CKALN,$GLOC,$RETURN,$SAVE    .
*.       USES MACROS: $SDEF,$SLOC,IBPRTAB                             .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         SPACE 1
IBASM1   CSECT
         $DBG  90,*
         SPACE 1
* * * * * REGISTER ALLOCATION AND USAGE IN IBASM1 * * * * * * * * * * *
*   R0 = WORK REGISTER. SCAN POINTER SAVED HERE BY SOME INTERNAL SUBRS*
*   R1 = 1     USEFUL VALUE, IN ODD REG FOR BXH'ING SCAN POINTER.     *
*   R2 = BYTE REGISTER (HI-ORDER 3 BYTES = 0).                        *
*   R3(IBLN)   LENGTH TO BE ADDED TO LOCATION COUNTER (INIT = 0).     *
*   R4(IBLB)   @ IN SYMBOL TABLE OF LABEL.  IF NO LABEL, = 0.         *
*   R5(IBLR)   INTERNAL LINKAGE REGISTER.                             *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
IBLN     EQU   R3                  LENGTH REGISTER
IBLB     EQU   R4                  LABEL POINTER,IF EXISTS
IBLR     EQU   R5                  LINKAGE REGISTER
IBMAXCON EQU   10                  MAXIMUM NUMBER OF CONSTANTS
         SPACE 1
         USING AVWXTABL,RAT        NOTE MAIN TABLE USING
         $SAVE RGS=(R14-R6),BR=R13,SA=IBSAVE
         SPACE 1
*              INITIALIZATION - SET UP REGISTERS,GET OPCODTB CODES    *
         LA    R1,1                SET UP USEFUL VALUE IN R1
         SR    R2,R2               CLEAR REGISTER
         SR    IBLN,IBLN           SET LENGTH TO 0
         STM   R2,IBLN,IBRCB       ZERO OUT RCB
         USING OPCODTB,RC          NOTE OPCODE TABLE
         MVC   IBRCTYPE(3),OPCTYPE MOVE CODE BYRS OVER
         MVC   IBRCLQ,OPCMASK      PLACE DEFAULT LENGTH ATTRIBUTE IN
         DROP  RC                  NO LONGER NEEDED
         MVI   IBRCLENG,RC$LEN     MOVE IN NORMAL LENGTH-1 OF RCB
         SR    RB,RB               CLEAR, TYPICAL NO ERROR SETTING
         SPACE 1
*              TEST FOR LEGALITY/FLAG START INSTRUCTION               *
         TM    AVTAGS1,$IBSTAR1+$IBDSEC1     CHECK TAGS1 SETTING
         BNZ   IBALAB              ALREADY SET OR SHOUDLN'T-SKIP
         TM    IBRCHEX,$IBSTAR1    IS THIS A START PREVENTER
         BZ    IBALAB              NO IT ISN'T,DON'T FLAG
         OI    AVTAGS1,$IBSTAR1    FLAG THE START NO LONGER GOOD
         CLI   AVCESDID,0          DOES A CSECT EXIST
         BNE   IBALAB              SOMETHING EXIST-BRANCH
         MVI   AVCESDID,2          UNITIATED PRIV CODE STARTS NOW
         OI    AVTAGS1,$IBPRCD1    SHOW PRIV CODE EXISTS NOW
         SPACE 1
*              CHECK FOR LABEL WHERE NONE ALLOWED,OR MISSING WHERE REQ*
IBALAB   L     IBLB,AVLABPT        GET ADDRESS OF LABEL,IF EXISTS
         LTR   IBLB,IBLB           SEE IF A LABEL EXISTS
         BNZ   IBANOLB             SKIP IF LABEL EXISTS
         TM    IBRCHEX,IBNENAM     NO NAME EXISTS,SEE IF IT IS REQUIRED
         BZ    IBAOPTST            NO NAME NEEDED,SKIP TO CHEK OPERAND
         LA    RB,$ERNONAM         NAME IS NEEDED,DOESN'T EXIST-ERR
         B     IBERLAB             GO FLAG ERROR-NO LABEL
         SPACE 1
IBANOLB  TM    IBRCHEX,IBNONAM     IT HAS A LABEL,SEE IF IT IS ALLOWED
         BZ    IBAOPTST            NAME IS ALLOWED,GO CHK OPERAND
         LA    RB,$ERILLAB         LABEL NOT PERMITTED
         $CALL ERRLAB              FLAG ERROR AT LABEL FIELD
         SPACE 1
*              IF OPERAND IS OMITTED, CHECK THAT ITS NOT ILLEGALLY SO *
IBAOPTST CLI   0(RA),C' '          SEE IF OPERAND EXISTS
         BNE   IBALEV2             OPERAND EXISTS-JUMP
         TM    IBRCHEX,IBOMOP      MAKE SURE OPERAND MAY BE OMITTED
         BZ    IBERNOPR            MISSING OPERAND-ILLEGAL
         SPACE 1
IBALEV2  IC    R2,IBRCTYPE         GET TYPE BYTE FOR TABLE
         LH    R14,IBAJUMP-$IB(R2) GET OFFSET TO INDIVIDUAL SECTION
IBASMJ   B     IBASMJ(R14)         BRANCH TO INDIVIDUAL SECTION
         SPACE 1
IBARBZER SR    RB,RB               CLEAR RB TO SHOW NO ERRORS
IBASCAN  EQU   *                   NO LONGER NEED SCAN TO END OF FIELDS
* * * * * EXIT CODE                                                   *
IBRETA   LR    RD,IBLN             PLACE LENGTH TO BE ADDED TO LOCCNTR
         LA    RC,IBRCB            PLACE ADDRESS FOR MAIN PROG
IBRET    $RETURN RGS=(R14-R6)
         SPACE 2
* * * * * CCW * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
IBCCW    EQU   *
         LA    RB,$ERNOIMP         NOT CURRENTLY IMPLEMENTED
         B     IBERRORA            HAVE THIS FLAGGED FOR NOW
         EJECT
* * * * * CNOP  * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        SETS RCMASK = # BYTES TO BE GENERATED (=0,2,4,6).            *
IBCNOP   $GLOC IBLB                GET VALUE OF LOCATION COUNTER
         $CKALN 1,IBCNOL           CHECK HALFWORD ALIGNMENT
         AR    IBLB,R1             INCREMENT LOCCNTR BY 1 TO ALIGN
         $SLOC IBLB                SET LOCCNTR VALUE
         SPACE 1
IBCNOL   BAL   IBLR,IBCNEV         CALL EXPRESSION EVAL, CHECK ROUTINE
         STC   RC,AVFWORK1         STORE VALUE,SO CAN TEST FOR ODD
         TM    AVFWORK1,1          WAS THE VALUE ODD
         BZ    *+8                 SKIP AND CONTINUE IF EVEN-OK
         BCT   RA,IBERICNO         MOVE SCAN PTR BACK, GO FLAG ERROR
         CLI   0(RA),C','          IS DELIM COMMA
         BNE   IBERIND             NO,ERROR
         AR    RA,R1               ADD 1 TO SCAN POINTER
         LR    IBLN,RC             SAVE 1ST OPERAND HERE
         SPACE 1
         BAL   IBLR,IBCNEV         CALL EXPRESSION EVAL, CHECK
         SR    RC,R1               GET 2ND OPERAND - 1
         C     RC,AWF3             WAS 2ND OPERAND ORIGINALLY 4
         BE    *+12                YES, SKIPP IF OK
         C     RC,AWF7             WAS 2ND OPERAND ORIGINALLY 8
         BNE   IBERICNO            NO, SO ERROR
         NR    IBLB,RC             GET LAST 2-3 BITS OF LOCCNTR
         LA    IBLN,1(IBLN,RC)     GET 1ST OPERAND + 4 OR 8
         SR    IBLN,IBLB           GET (1ST OPRND + 4 OR 8) - LOCNTR
         NR    IBLN,RC             GET LAST 2-3 BITS OF RESULT = LENGTH
         STC   IBLN,IBRCMASK       STORE RESULTING LENGTH FOR PASS 2
         CLI   0(RA),C' '          WAS THIS ALL
         BE    IBRETA              YES, SO DONE
         B     IBERIND             NO, INVALID DELIMIETER
         SPACE 1
IBCNEV   $CALL EVALUT              CALL EXPRESSION EVALUATOR
         LTR   RB,RB               WAS EXPRESSION OK
         BNZ   IBERRORA            NO ,ERROR, FLAG IT
         LTR   RD,RD               WAS EXPRESSION ABSOLUTE
         BCR   Z,IBLR              YES, RETURN TO CALLING SECTION
         B     IBERICNO            NO, CNOP ERROR
         SPACE 2
* * * * * CSECT * * * * * * * * * * * * * * * * * * * * * * * * * * * *
IBCSECT  SR    RB,RB               SHOW THIS IS A CSECT CALL
         B     IBESCALL            GO TO COMMON CODE SECTION
         SPACE 2
* * * * * DROP  * * * * * * * * * * * * * * * * * * * * * * * * * * * *
IBDROP   EQU   IBASCAN             NOTHING TO DO THIS PASS
         AIF   (&$DEBUG).IBNOD1    SKIP IF NOT DEBUG MODE
         SPACE 1
* * * * * DEBUG * * * * * * * * * * * * * * * * * * * * * * * * * * * *
IBDEBUG  MVC   IBRCHEX,0(RA)       GET 1ST CHAR,EITHER 1 OR 2
         LA    RA,2(RA)            BUMP SCAN POINTER PAST 1, OR 2,
         BAL   IBLR,IBEVCALL       CALL EXPRESSION EVALUATOR FOR VALUE
         STC   RC,IBRCMASK         SAVE THE BYTE CODE
         CLI   IBRCHEX,C'2'        WAS THIS PASS 2 ONLY
         BE    IBRETA              YES,DON'T CHANGE AVDEBUG
         STC   RC,AVDEBUG          SAVE THE NEW FLAG INTO DEBUG
         B     IBRETA              GO RETURN
.IBNOD1  ANOP
         EJECT
* * * * * DC - DS * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        SETS RCMASK = # OPERANDS IN DC STMT (= 1 TO IBMAXCON).       *
*        ADDS TO RCODBLK 1 CNCBLOCK FOR EACH OPERAND.                 *
*        SETS RCLQ = LENGTH ATTRIBUTE - 1 OF 1ST OPERAND.             *
*        **NOTE** MUST CHECK FOR MISSING QUOTE, ELSE ABEND MAY OCCUR. *
         SPACE 1
* * * * * REGISTER ALLOCATION FOR DC-DS PROCESSING  * * * * * * * * * *
*   R0 = CURRENT NUMBER OF OPERANDS PROCESSED                         *
*   R1 = 1                         CONSTANT FOR BXHING                *
*   R2 = CURRENT LENGTH-1 OF IBRCB,WILL BE INCREMENTED BY DC'S        *
*   RW(IBLN) = LOCATION COUNTER FOR BEGINNING OF STATEMENT            *
*   RX = 0 ==> DS, 4 ==> DC STATEMENT.                                *
*   RY = MAXIMUM # OPERANDS ALLOWED(= IBMAXCON IF DC, = 4095 IF DS).  *
*   RZ = ADDRESS OF CURRENT CNCBLOCK PART OF IBRCB BEING FILLED(DC'S) *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
IBDC     LA    RX,4                SHOW THIS IS A DC
         LA    RZ,IBRCONS          ADDRESS OF 1ST CONST BLOCK
         LA    RY,IBMAXCON         MAXIMUM NUMBER OF CONSTANTS ALOOWED
         B     IBDCDS              BRANCH TO COMMON CODE
         SPACE 1
IBDS     SR    RX,RX               CLEAR TO SHOW CODTL1 THIS IS DS
         LA    RY,4095             PUT HUGE NUMBER SO WON'T FLAG EXCED
IBDCDS   SR    R0,R0               CLEAR TO SHOW NO OPERANDS RIGHT NOW
         IC    R2,IBRCLENG         GET CURRENT LENGTH OF IBRCB
         $GLOC IBLN                GET THE LOCATION COUNTER
         SPACE 1
*              LOOP FOR 1 OR MORE OPERANDS.                           *
IBDSCAL  LR    RB,RX               SHOW CODTL1 WHETHER DC OR DS
         $CALL CODTL1              CALL THE OPERAND PROCESSOR
         LTR   RB,RB               WAS THERE AND ERROR
         BNZ   IBDCENDA            IF RB^=0, ==> ERROR
         SPACE 1
         USING CNCBLOCK,RC         RC POINTS AT CODTL1'S CNCBLOCK
         IC    RB,CNCLEN           GET LENGTH-1 OF CONSTANT
         TM    CNCTYP,$CNALN       IS ALIGNMENT REQUIRED
         BZ    IBDSLQ              DO NOT ALIGN UNLESS NEEDED
         $ALIGR IBLN,RB
IBDSLQ   BXH   R0,R1,IBDSADD       SKIP FOLLOWING 2 STMTS IF NOT 1ST
         $SLOC IBLN                SET LOCATION COUNTER FOR STMT START
         STC   RB,IBRCLQ           SAVE THE LENGTH ATTRIBUTE
IBDSADD  AR    IBLN,RE             ADD THE TOTAL LENGTH OVER
         LTR   RX,RX               IS THIS A DS OR A DC
         BZ    IBDSOPA             IT IS A DS, BRANCH
         CR    R0,RY               COMPARE # OF OPS TO MAXIMUM ALLOWED
         BH    IBDCEXT             IF EXCEEDS, FLAG ERROR
         SPACE 1
IBDCMOV  MVC   0(CNC$LEN,RZ),CNCBLOCK        MOVE BLOCK OVER(DC ONLY)
         LA    R2,CNC$LEN(R2)      INCREMENT THE LENGTH
         LA    RZ,CNC$LEN(RZ)      BUMP POINTER OF NEXT EMPTY SPACE
IBDSOPA  CLI   0(RA),C' '          IS THIS THE END
         BE    IBDCHEKA            GO TO CHECK FOR MISSING DELIMT
         CLI   0(RA),C','          IS DELIM ACTUALLY A COMMA
         BNE   IBDCINDL            NO, BAD USER, GET HIM
         BXH   RA,R1,IBDSCAL       BUMP SCAN POINT AND GET NEXT OPERAND
         SPACE 1
IBDCHEKA C     RA,AVSOLAST         COMPARE TO @ BLANK BEFORE AFTER '
         BL    IBDCEND             LOW, THEREFOR NO MISSING '
         LA    RB,$ERNODLM         MISSING ', ERROR-SHOW IT
         B     IBDCENDA            HAVE IT FLAGGED, , NO ASMBLY
         SPACE 1
IBDCINDL LA    RB,$ERINVDM         INVALID DELIMITER-SHOW IT
         B     IBDCENDA            GO FLAG ERROR
IBDCEXT  LA    RB,$ERDCEXT         TOO MANY CONSTANT OPERANDS IN DC
IBDCENDA $CALL ERRTAG              HAVE THE ERROR FLAGGED
         LA    R2,RC$LEN           GET REGULAR LENGTH-1 BACK
IBDCEND  S     IBLN,AVLOCNTR       GET DIFFERENCE, TO BE ADDED TO LOCCN
         STC   R0,IBRCMASK         SAVE NUMBER OF OPERANDS
         STC   R2,IBRCLENG         PLACE THE LENGTH-1 BACK INTO RCB
         B     IBRETA              RETURN
         DROP  RC
         SPACE 2
* * * * * DSECT * * * * * * * * * * * * * * * * * * * * * * * * * * * *
IBDSECT  LA    RB,4                SHOW ESD ROUTINE THIS IS DSECT
         B     IBESCALL            GO CALL ROUTINE
         SPACE 2
* * * * * EJECT * * * * * * * * * * * * * * * * * * * * * * * * * * * *
IBEJECT  EQU   IBRETA              NOTHING TO DO
         SPACE 2
* * * * * END PLUS COMMON END-LTORG CODE* * * * * * * * * * * * * * * *
IBEND    LR    R0,RA               SAVE SCAN POINTER
         $CALL LTDMP1              CALL LITERAL DUMP
         LR    IBLN,RA             MOVE LENGTH REQUIRED OVER
         TM    AVTAGS1,$IBDSEC1    ARE WE IN A DSECT RIGHT NOW
         BO    IBEND1              SKIP OVER IF SO,AVLOCHIH IS OK
         SPACE 1
         A     RA,AVLOCNTR         ADD LOCATION COUNTER TO INCREMENT
         C     RA,AVCSHIH          IS THIS LARGE THAN PREVIOUS LARGEST
         BNL   *+8                 YES,SO USE JUST COMPUTED VALUE
         L     RA,AVCSHIH          BACKWARDS ORG,USE PREVIOUS HIGHEST
         ST    RA,AVLOCHIH         SAVE HIGHEST VALUE OF CODE,USE IT
IBEND1   LR    RA,R0               RESTORE THE SCAN POINTER
         B     IBARBZER            GO ZERO RB TO SHOW OK
         SPACE 2
* * * * * ENTRY * * * * * * * * * * * * * * * * * * * * * * * * * * * *
IBENTRY  SR    RB,RB               SHOW ESENX1 THIS IS ENTRY
         B     IBENEXCL            GO CALL ROUTINE
         SPACE 2
* * * * * EQU * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        SETS RCEQU = VALUE OF SYMBOL (IF EVALUATION COMPLETE).       *
*        ALSO ZEROS AVLABPT SO THAT MPCON0 DOESNT REDEFINE SYMBOL.    *
IBEQU    EQU   *                   SHOW LENGTH 4> THAN USUAL
         MVC   AVLABPT,AWZEROS     ZERO IT, MOCON1 WILL THINK NO LABEL
         BAL   IBLR,IBEVCALL       CALL GEN EXPRESSION EVALUTAR
         BNZ   IBERRORA            NOGOOD, QUIT,FLAG ERROR.
         SPACE 1
         USING SYMSECT,IBLB        NOT SYMBOL TABLE USING
         CLI   0(RA),C' '          RIGHT DELIMITER
         BNE   IBERIND             NO,ERROR
         $SDEF RC,RD,RE            DEFINE THE SYMBOL
         DROP  IBLB                ERASE USING
         ST    RC,IBRCEQU          PLACE VALUE FOR LATER USE
         MVI   IBRCLENG,RC$LEN2    SHOW LENGTH 4> THAN USUAL
         B     IBRETA              GO RETURN
         SPACE 2
* * * * * EXTRN * * * * * * * * * * * * * * * * * * * * * * * * * * * *
IBEXTRN  LA    RB,2                SHOW ESENX1 THIS IS EXTRN CALL
IBENEXCL $CALL ESENX1              CALL EXTRN-ENTRY ROUTINE
         LTR   RB,RB               WERE THERE ERRORS
         BZ    IBRETA              NO ERRORS-QUIT
         B     IBERRORA            GO HAVE ERROR FLAGGED AND QUIT
         SPACE 2
* * * * * LTORG * * * * * * * * * * * * * * * * * * * * * * * * * * * *
IBLTORG  EQU   IBEND               USE SAME CODE. LTDMP1 ALIGNS LOCNTR.
         SPACE 2
* * * * * ORG * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
IBORG    CLI   0(RA),C' '          WAS OPERAND OMITTED
         BE    IBORGOM             YES,OMITTED
         BAL   IBLR,IBEVCALL       GET EXPRESSION EVALUATED
         BNZ   IBERRORA            IF ERROR,RETURN
         CLI   0(RA),C' '          MAKE SURE ENDS WITH ' '
         BNE   IBERIND             INVALID DELIM
         IC    R2,AVCESDID         GET ESDID
         CR    R2,RD               MAKE SURE THEY ARE SAME            7
         BNE   IBERORG             WRONG SECTION - BAD ORG
         C     RC,AVCSLOW          IS IT LOWER THAN LOWEST LEGAL VALUE
         BL    IBERORG             LOWERR THAN LOWEST LEGAL, ERROR
         SPACE 1
         L     R0,AVCSHIH          GET HIGHEST VALUE
         C     R0,AVLOCNTR         IS HIGHEST NOT HIGHER THAN LOCCNTR
         BNL   IBORGH1             SKIP IF HIGH VALUE>=LOCCNTR
         $GLOC R0                  GET CURRENT LOCCNTR
IBORGH1  CR    R0,RC               IS HIGHEST VALUE LESS THAN NEW
         BNL   IBORGH2             NO IT ISNT,BRANCH
         LR    R0,RC               NEW HIGHEST VALUE
IBORGH2  ST    R0,AVCSHIH          STORE NEW HIGH VALUE
         $SLOC RC                  SET LOCATION COUNTER
         B     IBRETA              GO RETURN
         SPACE 1
*              OMITTED OPERAND IN ORG==>SET TO HIGHEST UNUSED VALUE   *
IBORGOM  $GLOC R0                  GET LOCCNTR
         C     R0,AVCSHIH          COMPARE TO HIGHEST VALUE
         BNL   IBORGO1             SKIP IF LOCCNTR HIGH
         L     R0,AVCSHIH          USE HIGHEST VALUE
IBORGO1  ST    R0,AVCSHIH          SET POSSIBLY NEW HIGHEST LOCCNTR VAL
         $SLOC R0                  SET NEW LOCCNTR VALUE
         B     IBRETA              GO RETURN
         EJECT
* * * * * PRINT * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        SETS RCMASK = VALUE OF PRINT CODE TO BE SET BY PRINT.        *
*        ALSO IMMEDIATELY SETS AVPRINT1 TO CORECT PRINT CONTROL.      *
IBPRINT  LA    RE,IBPLAST          ADDRSS OF LAST IN TABLE
         SR    RD,RD               CLEAR FOR INSERTIONS
         MVI   AVFWORK1,0          INIT=0 FOR CORRECTNESS TESTS
         MVC   IBRCMASK,AVPRINT1   COPY CURRENT PRINT STATUS
         SPACE 1
*              LOOP TO LOOK UP NEXT OPERAND IN LEGAL PRINT LIST       *
IBPLOOP  LA    R14,IBPTAB          @ BEGINNING OF TABLE
         USING IBPSECT,R14         NOTE THE TABLE
         SPACE 1
IBPLOOPA IC    RD,IBPLENG          GET LENGTH-1 OF ENTRY
         STC   RD,*+5              STORE L-1 INTO CLC INST
         CLC   0($CHN,RA),IBPOPR   COMPARE INCOMING OPERAND
         BNE   IBPLOOPB            GO TO BOTTOM IF NOT
         SPACE 1
         MVC   *+7(1),IBPVO        COPY BIT TO CHECK INTO TM NEXT
         TM    AVFWORK1,$          TEST: SEE IF 2 OF SAME OR CONTRADCT
         BNZ   IBERINVF            INVALID
         OC    AVFWORK1(1),IBPVO   OR IN: RECORD FOR COMPATIBLITY TST
         OC    IBRCMASK,IBPVO      SET DESIRED BIT DEFINITELY = 1
         XC    IBRCMASK,IBPVX      XOR: SET BIT OFF IF REQUIRED OFF
         MVC   AVPRINT1,IBRCMASK   KEEP AVPRINT1 SAME VALUE AS RCMASK
         LA    RA,1(RD,RA)         BUMP SCP TO DELIMITER
         CLI   0(RA),C' '          IS THIS THE END
         BE    IBRETA              YES,RETURN
         CLI   0(RA),C','          CHECK DELIMITER
         BNE   IBERIND             ERROR IF NOT
         BXH   RA,R1,IBPLOOP       GO BACK FOR NEXT OP,BUMP SCPTR
         SPACE 1
IBPLOOPB LA    R14,IBPOPR-IBPSECT+1(R14)     INCREMENT BY RITHT OFFSET
         BXLE  R14,RD,IBPLOOPA     INCREMENT WITH VARIABLE LENGTH
         B     IBERINVF            IF FALSS THRU==>UNRECOGNIZABLE
         DROP  R14                 CLEAR USING
         SPACE 2
* * * * * SPACE * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        SETS RCMASK = # LINES TO BE SPACED. OMITTED OPERAND ==> 1.   *
IBSPACE  CLI   0(RA),C' '          IS OPERAND OMITTED
         BE    IBRETA              SKIP CALL,LEAVE IBRCMASK=1
         $CALL SDDTRM              GET VALUE FOR SPACING
         LTR   RB,RB               WAS VALUE OK
         BNZ   IBERRORA            BRANCH IF ERROR
         LTR   RC,RC               WAS VALUE ^=0
         BZ    IBRETA              RETURN IF =0,LEAVE 1 AS SPACE VALUE
         STC   RC,IBRCMASK         STORE VALUE FOR PASS 2.
         B     IBRETA              RETURN
         EJECT
* * * * * START PLUS COMMON START,DSECT,CSECT CODE  * * * * * * * * * *
*        SETS RCMASK = NEW CURRENT ESDID NUMBER.                      *
*        START SETS ITS VALUE INTO AVLOCLOW&AVFENTER FOR INIT.        *
IBSTART  TM    AVTAGS1,$IBSTAR1    IS START NO LONGER ALLOWED
         BO    IBSTERR             BRANCH-ERROR
         SR    RC,RC               CLEAR FOR VALUE IF OMITTED
         CLI   0(RA),C' '          WAS OPERAND OMITTED.
         BE    IBESCALA            YES,GO CALL SED ROUTINE
         $CALL SDBCDX              GET SELF-DEFINING TERM
         LTR   RB,RB               WAS VALUE OK
         BP    IBERRORA            BRANCH, ERROR CODE IN RB
         BM    IBERINVF            RB=-4, NOT SELF-DEFTERM, ERROR
         CLI   0(RA),C' '          MAKE SURE DELIMITER OK
         BNE   IBERIND             INVALID DELIMITER
         LA    RB,7                FOR DBLWD ALIGNMENT
         $ALIGR RC,RB              ALIGN STARTING VALUE TO *8
         ST    RC,AVLOCLOW         THIS IS NOW LOWEST LOC(UT WANTS IT)
         ST    RC,AVFENTER         STORE FOR BEGINNING @
IBESCALA LA    RB,2                SHOW ESD ROUTINE THIS IS A START
         SPACE 1
*              COMMON CODE - START, DSECT, CSECT.
IBESCALL LR    R0,RA               SAVE SCAN POINTER
         $CALL ESCSEC              CALL FOR CSECT,DSECT,OR START
         OI    AVTAGS1,$IBSTAR1    FLAG NO MORE STARTS
         LR    RA,R0               RESTORE SCAN POINTER
         LTR   RB,RB               CHECK FOR ERRPRS
         BNZ   IBERLAB             GO HAVE ERRORS FLAGGED IF NEEDED
         MVC   IBRCMASK,AVCESDID   KEEP NEW ESDID VALUE
         B     IBRETA              RETURN
         SPACE 2
* * * * * TITLE * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        SETS RCMASK = LENGTH OF TITLE OPERAND FIELD.                 *
IBTITLE  CLI   0(RA),C''''         MAKE SURE DELIM OK
         BNE   IBERIND             ERROR IF NOT
         AR    RA,R1               BUMP SCAN POINTER BY 1
         $CALL CCCON1              HAVE THE TITLE CHECKED
         LTR   RB,RB               WAS THERE ERROR
         BNZ   IBERRORA            YES,GO FLAG IT
         CLI   1(RA),C' '          MAKE SURE ENDS WITH QUOTE BLANK
         BNE   IBERIND             BRANCH IF ERROR
         C     RA,AVSOLAST         WAS IT >= @ BLANK BEFORE AFERQUOTE
         BNL   IBERNODL            TOO LONG, MISSING DELIMITER
         SR    RC,R1               S RC,=F'1' GET LENGTH-1 AS NEEDED
         STC   RC,IBRCMASK         SAVE THE LEGNTH REQUIRED
         BXH   RA,R1,IBRETA        BUMP SCAN POINTER AND RETURN
         SPACE 2
* * * * * USING * * * * * * * * * * * * * * * * * * * * * * * * * * * *
IBUSING  EQU   IBASCAN             NOTHING TO DO THIS PASS
         EJECT
* * * * * INDIVIDUAL ERROR EXITS                                      *
IBERNODL LA    RB,$ERNODLM         MISSING DELIMITER ERROR
         B     IBERRORA            GO FLAG AND EXIT
IBERICNO LA    RB,$ERICNOP         ILLEGAL CNOP OPERAND COMBINATION
         B     IBERRORA            GO TO FLAG
IBERIND  LA    RB,$ERINVDM         INVALID DELIMITER
         B     IBERRORA            SET ERROR CODE AND RETUN
IBERINVF LA    RB,$ERINVF          ILLEGAL FIELD OF SOME SORT
         B     IBERRORA            GO FLAG IT
IBERNOPR LA    RB,$ERNOOPR         MISSING OPERAND
         B     IBERRORA            GO PUT OUT ERROR CODE
IBERORG  LA    RB,$ERILORG         ILLEGAL ORG
         B     IBERRORA            GO FLAG IT
IBSTERR  LA    RB,$ERSTART         SHOW BAD START, FALL THRU-IBERRORA
         SPACE 2
* * * * * ALL ERRORS EXCEPT LABEL ERRORS                              *
IBERRORA $CALL ERRTAG              HAVE LABEL FLAGGED
         B     IBRETA              RETURN TO CALLER
         SPACE 2
* * * * * LABEL ERRORS                                                *
IBERLAB  $CALL ERRLAB              CALL LABEL ERROR
         B     IBRETA              RETURN TO CALLER
         SPACE 2
*              INTERNAL SUBROUTINES.
         SPACE 2
* * * * * EXPRESSION EVALUATION - CALL TO EVALUT                      *
IBEVCALL $CALL EVALUT              CALL EXPRESSION EVALUATOR
         LTR   RB,RB               SET THE CONDTION CODE
         BR    IBLR                RETURN TO CALLER
         EJECT
* * * * * INTERNAL CONSTANTS                                          *
* * * * * 2ND LEVEL JUMP TABLE FOR IBASM1                             *
IBAJUMP  $AL2  IBASMJ,(IBUSING,IBDROP,IBSTART,IBCSECT,IBDSECT,IBENTRY,I#
               BEXTRN,IBEQU,IBDC,IBDS,IBCCW,IBTITLE,IBEJECT,IBSPACE,IBP#
               RINT,IBORG,IBLTORG,IBCNOP,IBEND),-2
         AIF   (&$DEBUG).IBNOD2    SKIP IF NOT DEBUG MODE
         DC    AL2(IBDEBUG-IBASMJ)           OFFSET TO DEBUG ROUTINE
.IBNOD2  ANOP
         SPACE 1
* * * * * PRINT OPERAND TABLE                                         *
IBPTAB   IBPRTAB ON,$IBPON         SET BIT ON
         IBPRTAB OFF,$IBPON,*      SET 'ON' BIT OFF
         IBPRTAB GEN,$IBPGEN       SERT GEN BIT ON
         IBPRTAB NOGEN,$IBPGEN,*   SET 'GEN' BIT OFF
         IBPRTAB DATA,$IBPDAT      SET DATA BIT ON (ONLY COMPATIBLITY)
         IBPRTAB NODATA,$IBPDAT,*  SET 'DATA' BIT OFF
IBPLAST  EQU   *-1                 @ LAST BYTE FOR LIMIT
         SPACE 1
         LTORG
         SPACE 1
* * * * * INTERNAL VARIABLES                                          *
* * * * * RCB AREA FOR IBASM1                                         *
IBRCB    DS    0D                  RECORD CODE BLOCK
IBRCLENG DS    C                   LENGTH OF RCB
IBRCLOC  DS    AL3                 LOCATION COUNTER VALUE
IBRCTYPE DS    C                   OPCODE TYPE
IBRCHEX  DS    C                   2ND LEVEL TAGS-LABLE&OPERAND
IBRCMASK DS    C                   FROM OPCTYPE=LENGTH ATTRIBUTE
IBRCLQ   DS    C                   BYTE FOR LENGTH ATTRIBUTE L'*
IBRCEQU  DS    0F                  VALUE OF AN EQUATE SYMBOL
IBRCONS  DS    (IBMAXCON)CL(CNC$LEN)         CONSTANT CODE BLOCKS
         SPACE 1
* * * * * DSECT USED BY PRINT ROUTINE FOR TABLE LOOKUP  * * * * * * * *
IBPSECT  DSECT
IBPLENG  DS    C                   NUMBER OF CHARACTERS IN CODE
IBPVO    DS    B                   BIT TO BE OR'D IN: BIT TO TEST
IBPVX    DS    B                   BIT TO BE XOR'D IN, RESET =0 IF NEED
IBPOPR   DS    C                   OPERAND CHARACTERS(ON,OFF,ETC)
         DROP  RAT,R13             CLEAN UP USING SIUTATION
         TITLE '*** ICMOP2 - MACHINE INSTRUCTIONS - PASS 2 ***'
**--> CSECT: ICMOP2   2   MACHINE OPERATIONS - PASS 2 . . . . . . . . .
*.       THIS MODULE IS 1 OF THE 2 PASS 2,LEVEL 2 ROUTINES IN THE     .
*.       ASSIST ASSEMBLER.  IT PROCESSES ALL MACHINE INSTRUCTIONS IN  .
*.       THE SECOND PASS, SCANNING ALL THE OPERAND FIELDS AND CREATING.
*.       THE OBJECT CODE FOR THEM.  IT ALSO DOES THE SETUP REQUIREED  .
*.       FOR OUTPT2 TO PRODUCE THE PRINTED LISTING. THIS ROUTINE HAS  .
*.       MANY SPECIAL-CASE SECTIONS WHICH ARE USED FOR SPEED, AND     .
*.       WHICH COULD USE LESS SPACE IF CALLS TO THE GENERAL EXPRESSION.
*.       EVALUATOR EVALUT WERE USED INSTEAD.                          .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER (ADDRESS OF 1ST CHARACTER OF OPERAND FIELD)     .
*.  RC = ADDRESS OF RECORD CODE BLOCK(RCODBLK) FOR STATEMENT          .
*.  RE = ADDRESS OF RECORD SOURCE BLOCK(RSBLOCK) FOR STATEMENT        .
*.       CALLS BRDISP,ERRTAG,EVALUT,LTGET2,SDBCDX,SDDTRM              .
*.       CALLS SDBCDX,SYFIND,OUTPT2,UTPT2                             .
*.       USES MACROS: $AL2,$CALL,$GLOC,$RETURN,$SAVE,ICT              .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         SPACE 1
ICMOP2   CSECT
         $DBG  90,*
ICB1D1   EQU   X'10'               (ICYFLAG) - ==> B(D) OPERAND FORMAT
ICBX2    EQU   X'08'               (ICYFLAG) ==> D(X,B) FORMAT,NOT L
ICBSOPN2 EQU   X'04'               (ICYFLAG) ==> B(D) STORED INTO OPN2
ICBSEA2  EQU   X'02'               (ICYFLAG) ==> @ GOES TO ICYEA2
ICYXLFN  EQU   X'80'               (ICYF2) ==> X OR L FIELD PRESENT
         USING AVWXTABL,RAT        NOTE MAIN TABLE USING
         USING RCODBLK,RC          NOTE POINTER TO CODE BLOCK
         EJECT
* * * * * OVERALL REGISTER USAGE FOR ICMOP2 * * * * * * * * * * * * * *
*   R1 = @ REGISTER-HI-ORDER BYTE =0. OFTEN USED TO SAVE SCAN PTR RA  *
*   R2 = BYTE REGISTER - HI-ORDER 3 BYTES = 0. USED FOR INSERTIONS,ETC*
*   RW = LEVEL 1 LINK REGISTER                                        *
*   RX = LEVEL 3 LINK REGISTER                                        *
*   RY = 1    USED FOR INCREMENTING,DECREMENTING REGS,BXH'ING SCAN PTR*
*   RZ = LEVEL 2 LINK REGISTER                                        *
*   RA = SCAN POINTER REGISTER - @ NEXT CHARACTER TO BE EXAMINED      *
*   RB = USUAL PLACE FOR AN ESDID TO BE KEPT,IF THERE IS ONE          *
*   RC = NORMAL PARAMATER REGISTER FOR RETURN OF A CONVERTED VALUE    *
*   R13= @ SAVEAREA AND BASE REGISTER                                 *
*   R14-R15   LOCAL WORK REGISTERS, EXTERNAL LINK REGISTERS           *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         $SAVE RGS=(R14-R6),BR=R13,SA=ICMOSAVE
         MVC   ICRCB(RCLITEQ-RCODBLK+4),RCODBLK        MOVE TO FREE RC
         DROP  RC                  NO LONGER USING,WILL NEED EVERY REG
         LM    R0,R3,AWZEROS       ZERO OUT THESE REGS
         STM   R0,R3,ICYBLOCK      ZERO OUT BLOCK FOR OBJ CODE
         LA    RY,1                INITIALIZE REGISTER
         MVC   ICYOP(2),ICRCHEX    MOVE OPCODE-MASK OVER
         AIF   (NOT &$XREF).NOXRF15                                   A
         IC    R2,ICYOP            GET OPCODE                         A
         IC    R2,ICXRTAB(R2)      GET FLAG BYTE FROM TABLE           A
         STC   R2,AVXRMDFT         STORE FLAG BYTE IN FLAG            A
.NOXRF15 ANOP
         NI    ICYR1R2,X'F0'       REMOVE 2ND NIBBLE,LEAVING MASK ONLY
         SPACE 1
*              OBTAIN TYPE INFORMATION,INSTRUCTION SECTION @. TAKE
*              BRANCH TO ONE OF LEVEL 0 INSTRUCTION PROCESSORS.
         IC    R2,ICRCTYPE         GET TYPE BYTE
         LH    R14,ICOJUMP(R2)     GET OFFSET @ FOR LEVEL 0 ROUTINE
         SRL   R2,1                DIVIDE BY 2 FOR BYTE INDEX
         IC    R2,ICTTAB(R2)       GET FLAG BYTE BELONGING TO TYPE
         STC   R2,ICYFLAG          STORE FLAG BYTE FOR LATER USE
ICMOJ    B     ICMOJ(R14)          TAKE BRANCH TO INSTRUCTION TYPE SUBR
* * * * * JUMP OFFSET TABLE FOR INSTRUCTION TYPE PROCESSORS (LEVEL 0) *
ICOJUMP  $AL2  ICMOJ,(ICRRM,ICRXM,ICRR,ICRX,ICRS,ICRSH,ICSI,ICSS,ICSS2,#
               ICRSO,ICSPC),-2
         EJECT
* * * * * INDIVIDUAL ERROR EXITS                                      *
ICNUNDEF LA    RB,$ERUNDEF         UNDEFINED SYMBOL
         LR    RA,R1               GET A SCAN POINTER BACK
         BCT   RA,ICNERROR         MOVE SCAN PTR BACK,GO FLAG ERR
ICNEABS  LA    RB,$ERNEABS         AN ABSOLUTE TERM OR EXPRESSION NEEDD
         B     ICNERROR            GO FLAG ERROR
ICNBADSY LA    RB,$ERINVSY         INVALID SYMBOL
         BCT   RA,ICNERROR         MOVE SCAN PTR BACK,GO FLAG ERR
ICNLITER LA    RB,$ERTLIT          ILLEGAL USE OF LITERAL
         B     ICNERROR            GO FLAG ERROR
ICNRELC  LA    RB,$ERRELOC         RELOCATABILITY ERROR
         BCT   RA,ICNERROR         MOVE SCAN PTR BACK,GO FLAG ERR
ICNEXGTB AR    RA,RY               BUMP SCAN PTR TO ALLOW FOR BCT
ICNEXGTA LA    RB,$EREXGTA         EXPRESSION TOO LARGE
         BCT   RA,ICNERROR         MOVE SCAN PTR BACK,GO FLAG ERR
ICNADDR  LA    RB,$ERADDR          ADDRESSIBILITY ERROR
         BCT   RA,ICNERROR         MOVE SCAN PTR BACK,GO FLAG ERR
ICNILLEG CLI   0(RA),C' '          WAS ILLEGAL A BLANK (MISSING)
         BNE   ICNINVDM            NO,SOMETHING ELSE ILLEFAL
ICNNOOPR LA    RB,$ERNOOPR         MISSING OPERAND
         B     ICNERROR            GO HAVE IT FLAGGED
ICBLANK  CLI   0(RA),C' '          FINAL CHECK FOR BLANK
         BE    ICOUTPT             BRANCH OUT IF OK
ICNINVDM LA    RB,$ERINVDM         INVALID DELIMITER (MOST COMMON)
ICNERROR $CALL ERRTAG              HAVE ERROR FLAGGED
ICNERRF  MVC   ICYEA1(14),AWZEROS  ZERO THE INSTRUCTION OUT
         SPACE 1
* * * * * ICOUTPT - COMMON EXIT - PRODUCE OBJECT CODE,PRINT STMT      *
ICOUTPT  $GLOC RA                  GET LOCATION COUNTER FOR UTPUT2
         LA    RC,ICYOP            @ OBJECT CODE FOR UTPUT2
         IC    R2,ICRCLQ           GET LENGTH-1 OF STATEMENT CODE
         LR    RD,R2               MOVE OVER FOR LENGTH-1 FOR UTPUT2
         LR    RE,RY               SET RE = 1 ==> PRODUCE 1 OF OBJECT
         $CALL UTPUT2              HAVE OBJECT CODE LOADED
         SPACE 1
*              SET UP AND CALL PRINTER ROUTINE                        *
         LA    RB,$OUMACH          SHOW THIS IS A MACHINE INSTRUCTION
         LA    RC,ICYBLOCK         GET @ BLOCK
         LR    RD,R2               MOVE LENGTH-1 WHERE OUTPT2 WANTS IT
         $CALL OUTPT2              CALL OUTPUT ROUTINE
         AIF   (NOT &$XREF).ICNXRF1  SKIP IF NO CROSS-REF OPTION      J
         MVI   AVXRTYPE,AVXRFTCH   MAKE FETCH TYPE NORMAL FOR REST    J
.ICNXRF1 ANOP
ICRET    $RETURN RGS=(R14-R6)
         EJECT
* * * * * ICRR - NORMAL RR INSTRUCTIONS,EXTENDED MNEM RR'S - LEVEL - 0*
ICRRM    BAL   RZ,ICREG            GO GET REG 2 FIELD
         EX    RC,ICOIR            HAVE IT ORED IN
         B     ICBLANK             GO CHECK FOR BLANK
ICRR     EQU   *                                                      A
         CROSSET   1               SET FLAG M/F FIRST OPRND           A
         BAL   RW,ICWREG1          GO GET FIRST REGISTER              A
         CROSSET   2               SET FLAG M/F 2ND OPERAND           A
         BAL   RZ,ICREG            GO GET 2ND REGISTER
         EX    RC,ICOIR            HAVE IT OR'D INTO R2 FIELD
         AIF   (NOT(&$FLOTA OR &$FLOTAX OR &$S370A)).ICRRNF
         TM    ICRCMASK,IAB        SHOULD R2 BE EVEN?
         BNO   ICBLANK             NO, SO BRANCH TO CHECK FOR BLANK
         TM    ICYR1R2,X'01'       WAS THRE AN ODD REG IN 2ND POSITION
         BZ    ICBLANK             NO, SO OK -BRANCH
         BAL   RZ,ICWODDR          HAVE ODD REG FLAGGED
.ICRRNF  B     ICBLANK             GO TO CHECK FOR BLANK AND QUIT
         SPACE 2
* * * * * ICRX - NORMAL RX AND RX EXTENDED MNEMONICS - LEVEL - 0      *
ICRX     EQU   *                                                      A
         CROSSET  1                SET FLAG FOR 1ST OPERAND           A
         BAL   RW,ICWREG1          CALL FOR 1ST REG                   A
ICRXM    EQU   *                   ENTRY FOR RX EXTENDED MNEMONICS
         CROSSET  2                SET FLAG 2ND OPERAND               A
         BAL   RW,ICXBD            GO GET THE OPERAND
         TM    ICYF2,ICYXLFN       WAS INDEX SPECIFIED
         BZ    *+10                SKIP OVER IF SO
         OC    ICYR1R2,ICYXL       PLACE X2 FIELD IN,IF IT WAS SPECIFIE
         B     ICBLANK             GO CHECK FOR BLANK
         SPACE 2
* * * * * ICRS - REGULAR NON-SHIFT RS INSTRUCTIONS - LEVEL - 0        *
ICRS     EQU   *                                                      A
         CROSSET  1                SET 1ST OPERAND FLAG               A
         BAL   RW,ICWREG1          GET 1ST REGISTER                   A
         CROSSET 2 SET SECOND OPERAND                                 A
         BAL   RZ,ICREG            GET 2ND REG
         EX    RC,ICOIR            HAVE 2ND REG PLACED ALSO
         CLI   0(RA),C','          IS DELIM WHAT IT SHOULD BE
         BNE   ICNINVDM            NO-ERROR
         CROSSET 3                 SET 3RD OPERAND                    A
         BXH   RA,RY,ICRSH1        BUMP PAST , AND GO GET D2-B2
         SPACE 2
* * * * * ICRSH - RS SHIFT INSTRUCTIONS - LEVEL - 0                   *
ICRSH    EQU   *                                                      A
         CROSSET  1                SET FLAG                           A
         BAL   RW,ICWREG1          GET 1ST REGISTER                   A
         CROSSET  2                SET SECOND OPERAND                 A
ICRSH1   BAL   RW,ICXBD            GET BASE-DISP (COMMON RS CODE)
         B     ICBLANK             GO TEST FR BLANK AND QUIT
         EJECT
* * * * * ICSI - NORMAL SI INSTRUCTIONS - OP D1(B1),I2 - LEVEL - 0    *
ICSI     EQU   *                                                      A
         CROSSET  1                1ST OPERAND                        A
         BAL   RW,ICXBD            GET B(D) FIELD                     A
         CLI   0(RA),C','          CHECK FOR COMMA
         BNE   ICNINVDM            BRANCH IF NOT-ILLEGAL
         AR    RA,RY               BUMP SCAN POINTER PAST ,
         SPACE 1
ICSI1    LR    R1,RA               SAVE SCAN PTR, IN CASE NOT JUST SDT
         BAL   RX,ICSDTRM          GO GET SDT IF IT IS ONE
         BM    ICSI2               NO IT WAN'T-GIVE UP AND USE EXPRESSI
         CLI   0(RA),C' '          WAS THIS ALL (WE HOPE SO)
         BE    ICSI3               YES,WE GOT BY WITH SIMPLE CASE
         LR    RA,R1               NOT SD TERM BY SELF-RESTORE SCP
         SPACE 1
ICSI2    BAL   RX,ICEXP            GO GET EXPRESSION
         BP    ICNEABS             EXPRESSION HAD TO BE ABSOLUTE-ERROR
ICSI3    CL    RC,AWFXFF           WAS EXPRESSION SMALL ENOUGH
         BH    ICNEXGTA            NO-TOO BIG
         STC   RC,ICYR1R2          SAVE I2 FIELD
         B     ICBLANK             GO CHECK FOR BLANK AND FINISH UP
         SPACE 1
ICSS     EQU   *                                                      A
* * * * * ICSS - SS INSTRUCTIONS WITH 1 LENGTH - LEVEL - 0            *
         CROSSET  1                1ST OPERAND FLAG SET               A
         BAL   RW,ICXBD            GET 1ST BASE DISPLACEMENT          A
         BAL   RX,ICULEN           PICK UP LENGTH IN R2
         STC   R2,ICYR1R2          SAVE INTO INSTRUCTION
         CLI   0(RA),C','          IS DELIMITER OK
         BNE   ICNINVDM            NO,ERROR
         AR    RA,RY               BUMP SCAN POINTER PAST ,
         SPACE 1
         OI    ICYFLAG,ICB1D1+ICBSOPN2+ICBSEA2         SET FOR 2ND OP
         CROSSET 2                 2ND OPERAND                        A
         BAL   RW,ICXBD            GO PROCESS 2ND OPERAND
         B     ICBLANK             GO CHECK FOR BLANK AND QUIT
         SPACE 1
* * * * * ICSS2 - SS INSTRUCTIONS WITH 2 LENGTHS - LEVEL - 0          *
ICSS2    EQU   *                                                      A
         CROSSET 1                 SET 1ST OPERAND FLAG               A
         BAL   RW,ICXBD            GET 1ST BASE DISPLACEMNT           J
         BAL   RX,ICULEN           GO GET LENGTH
         C     R2,AWF15            MAKE SURE LEGAL SIZE
         BH    ICNEXGTA            TOO BIG-BRANCH
         SLL   R2,4                SHIFT OVER FOR L1 POSITION
         STC   R2,ICYR1R2          SAVE THE LENGTH
         CLI   0(RA),C','          CHECK DELIMITER
         BNE   ICNINVDM            ERROR IF NOT
         AR    RA,RY               BUMP SCAN POINTER
         SPACE 1
         AIF   (NOT &$S370A).ICSS2 SKIP IF NOT ASSEMBLING S/370'S
         CLI   ICYOP,240           IS THIS A SRP INSTRUCTION?
         BE    ICSS2A              YES - BRANCH
         SPACE 2
.ICSS2   ANOP
         OI    ICYFLAG,ICBSOPN2+ICBSEA2      RESET FLAGS FOR 2ND OPRND
         MVI   ICYF2,0             REZERO RETURN CODES FLAG
         CROSSET 2                 SET FLAGS                          A
         BAL   RW,ICXBD            GET 2ND LENGTH-BASE-DISP
         BAL   RX,ICULEN           GO PICK UP LENGTH IN R2
         C     R2,AWF15            MAKE SURE LEGAL SIZE
         BH    ICNEXGTA            NO-TOO BIG-ERROR
         EX    R2,ICOIR            HAVE THE LENGTH OR'D IN
         B     ICBLANK             GO CHECK FOR BLANK AND QUIT
         AIF   (NOT &$S370A).ICSS2A SKIP IF NOT ASSEMBLIN& S/3 0'S
         SPACE 2
* * * * * ICSS2A - SPECIAL CODE FOR SRP (S/370) INSTRUCTION
ICSS2A   OI    ICYFLAG,ICB1D1+ICBSOPN2+ICBSEA2       SET FOR 2ND OPND
         CROSSET 2                 SET 2ND OPERAND FLAG               A
         BAL   RW,ICXBD            GO PROCESS 2ND OPERAND
         CLI   0(RA),C','          CHECK DELIMITER
         BNE   ICNINVDM            ERROR IF NOT
         AR    RA,RY               BUMP SCAN POINTER
         BAL   RZ,ICREG            GO GET IMMEDIATE FIELD
         CH    RC,AWH10            IS IMMEDIATE TO LARGE?
         BNL   ICNEXGTA            YES - ERROR
         EX    RC,ICOIR            HAVE IMMEDIATE OR'ED IN
         B     ICBLANK             GO CHECK FOR BLANK AND QUIT
.ICSS2A  ANOP
         EJECT
* * * * * ICRSO - SPM,SVC, AND IO-TYPE SI'S - LEVEL - 0               *
ICRSO    EQU   *
         CLI   ICYOP,X'0A'         IS IT SVC
         BE    ICSI1               YES, USE IMMEDIATE FIELD PART OF SI
         CLI   ICYOP,X'01'         IS THIS AN XOPC INSTRUCTION        M
         BE    ICSI1               YES, USE IMMEDIATE FIELD PART OF SIM
         CLI   ICYOP,X'04'         IS IT  SPM
         BE    ICRSO1              YES,GO PROCESS
*              FALL THRU ==> ODD SI INSTRS (TS, SIO, TCH, ETC)
         MVI   ICYFLAG,$ICBEA1+ICB1D1        CHANGE FLAG FOR SEMI-SI
         AIF   (NOT &$P370A).ICRSO IF NO PRIVELEGED S/370'S, BRANCH
         MVO   ICYR1R2(2),ICRCMASK MOVE IN MASK DIGIT FOR S/370
.ICRSO   ANOP
         BAL   RW,ICXBD            GET BASE-DISPLACEMENT
         B     ICBLANK             GO FOR BLANK AND QUIT
         SPACE 1
ICRSO1   BAL   RZ,ICREG            SPM HAS 1 REG,GO GET IT
         SLL   RC,4                SHIFT OVER FOR RIGHT POSITION
         STC   RC,ICYR1R2          STORE R1 FIELD
         B     ICBLANK             LOOK FOR BLANK AND QUIT
         SPACE 1
* * * * * ICSPC - SPECIAL INSTRUCTIONS - XREAD,XPRNT,XPNCH - LEVEL - 0*
ICSPC    EQU   *                   FOR SPECIAL IO INSTRUCTIONS
         AIF   (NOT &$XIOS).ICXIO  SKIP IF THESE SPECIALS NOT ALLOWED
         MVI   ICSPCDUM+1,0        MAKE A NOOP
         CLI   ICYR1R2,X'60'       WAS IT XDUMP
         BNE   ICSPCO              SKIP IF NOT XDUMP IN 1ST PLACE
         MVI   ICSPCDUM+1,X'F0'    SHOW XDUMP WITH ARGUMENTS
         CLI   0(RA),C' '          ARE THERE ANY OPERANDS
         BNE   ICSPCO              YES, ALREADY SET RIGHT, CONTINUE
         MVI   ICYOP,X'E1'         CHANGE OPCODE E0 TO E1-REGS XDUMP
         B     ICOUTPT             GO OUTPUT CODE
         SPACE 1
ICSPCO   BAL   RW,ICXBD            GET ADDRESS OPERAND
         TM    ICYF2,ICYXLFN       WAS INDEX REG USED
         BZ    *+10                NO,SKIP IT
         OC    ICYR1R2,ICYXL       PUT LENGTH IN
         CLI   0(RA),C' '          WAS THIS ALL
         BNE   ICSPC1              SKIP IF LENGTH FOLLOWS
         IC    R2,ICYR1R2          GET MASK VALUE
         SRL   R2,5                SHIFT OVER FOR BYTE INDEXING
         IC    R2,ICSPCDLT(R2)     GET DEFAULT LENGTH VALUE
         STH   R2,ICYOPN2          SAVE THE VALUE IN D(B) FIELD
         B     ICOUTPT             GO HAVE PRINTED AND RETURN
         SPACE 1
ICSPC1   CLI   0(RA),C','          MAKE SURE DELIM WHAT IT'S SUPPOSED T
         BNE   ICNINVDM            ERROR - BRANCH
         AR    RA,RY               BUMP SCAN POINTER
         CLI   0(RA),C'('          IS THIS REGISTER FORM
         BNE   ICSPC2              NO,MUST BE SPECIFIED LENGTH
ICSPCDUM BC    $CHN,ICNINVDM       XDUMP WITH ARGS DOESN'T ALLOW (R) FM
         AR    RA,RY               BUMP SCAN POINTER PAST (
         BAL   RZ,ICREG            GET REGISTER VALUE
         SLL   RC,4                SHIFT FOR POSITION
         STC   RC,ICYOPN2          SAVE INTO B POSTION
         CLI   0(RA),C')'          IS DELIMITER RIGHT
         BNE   ICNINVDM            NO-ERROR-BRANCH
         BXH   RA,RY,ICBLANK       BUMP SCP AND GO CHK BLANK          P
         SPACE 1
ICSPC2   BAL   RX,ICEXP            GO GET EXPRESSION
         BNZ   ICNEABS             SHOULD BE ABSOLUTE-ERR IF NOT
         STH   RC,ICYOPN2          SAVE THE VALUE
         B     ICBLANK             GO CHK BLANK AND FINISH UP
ICSPCDLT DC    AL1(80,133,80,4,1)  DFLT L'S-READ,PRNT,PUNCH,DUMP,LIMD
.ICXIO   ANOP
         EJECT
* * * * * ICWREG1 - PROCESS 1ST REGISTER OR MASK - LEVEL - 1          *
*        ENTRY CONDITIONS                                             *
*   RA = SCAN POINTER TO 1ST CHAR OF 1ST REGISTER                     *
*   RW = RETURN ADDRESS OF CALLING SECTION                            *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
ICWREG1  BAL   RZ,ICREG            GET 1ST REG CONVERTED
         SLL   RC,4                SHIFT OVER
         STC   RC,ICYR1R2          STORE INTO AREA
         TM    ICRCMASK,IAA        MUST THE REGISTER BE EVEN
         BZ    ICWR1               NO,GO FINISH UP
         TM    ICYR1R2,X'10'       MAKE SURE REG IS EVEN
         BZ    ICWR1               REG IS OK,SKIP
         LA    RZ,ICWR1            SET UP RETURN @ TO CONTINUE
         SPACE 1
*              ICWODDR MAY BE CALLED TO FLAG ODD FLT-PT REG - LEVEL-2 *
ICWODDR  SR    RA,RY               DECREMENT SCAN PTR BY 1 TO REG
         LA    RB,$ERODDRG         REGISTER IS ODD-FLAG IT
         $CALL ERRTAG              FLAG ERROR
         BXH   RA,RY,0(RZ)         PUT SCAN PTR FORWARD 1, RETURN TO CL
         SPACE 1
ICWR1    CLI   0(RA),C','          IS REG FOLLOWED BY ,
         BNE   ICNINVDM            NO-ERROR
         BXH   RA,RY,0(RW)         BUMP PAST , AND RETURN
         EJECT
* * * * * ICXBD - PROCESS 1 OPERAND - D(B) OR D(X-L,B) - LEVEL - 1    *
*        ENTRY CONDITIONS                                             *
*   RW = RETURN ADDRESS OF CALLING SECTION                            *
*        EXIT CONDITIONS                                              *
*        ICYEA1 OR ICYEA2 WILL BE FILLED IN. ICYOPN1 OR ICYOPN2 WIIL  *
*        BE FILLED IN AND A LENGTH OR INDEX REGISTER WILL BE STORED   *
*        INTO ICYFL, IF PRESENT.                                      *
*        **NOTE** MOST OF THE CODE IN THIS SECTION IS DESIGNED TO     *
*   MAKE NORMAL CASE PROCESSING AS FAST AS POSSIBLE. THE PROGRAM      *
*   ATTEMPTS TO FIND ONE OF SEVERAL TYPICAL OPERAND FORMATS, AND IF   *
*   SUCCESSFULL, PROCESSES THEM QUICKLY. IF NOT, IT GIVES UP AND      *
*   USES THE EXPRESSION EVALUATOR EVALUT INSTEAD. THE ROUTINE WILL    *
*   CONVERT ANY OF THE FOLLOWING SORTS OF OPERANDS WITHOUT CALLING    *
*   THE EVALUT ROUTINE :                                              *
*   1. FOR OPERANDS OF FORM S OR D(B) - IF D IS A DECIMAL # OR        *
*        SELF-DEFINING TERM BY ITSELF, AND (B) IS PRESENT OR NOT, OR  *
*   IF S IS EITHER A SYMBOL BY ITSELF, OR SYMBOL+# OR SYMBOL-#, WHERE *
*        SYMBOL IS EITHER AN ORDINARY SYMBOL OR LOCATION COUNTER REF  *
*   2. FOR OPERANDS OF FORM S(XL) OR D(XL,B) OR D(XL) OR D(,B)        *
*        SYMBOL IS EITHER AN ORDNIARY SYMBOL OR LOCATION COUNTER REFE *
*        IF S OR D ARE AS DESCRIBED BY 1., AND IF XL DESIGNATES A     *
*   LENGTH, IT IS GIVEN BY A DECIMAL #.                               *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         AIF   (&$OPTMS LT 2).ICX2 SKIP IF MEMORY TIGHT
ICXBD    ST    RA,ICZ1RA           SAVE THE SCAN POINTER IF BACK-UP NEE
         IC    R2,0(RA)            GET THE FIRST CHARACTER OF OPERAND
         IC    R2,AWTDECT(R2)      GET INDEX VALUE FROM TABLE
         C     R2,AWF12            MAKE SURE NOT ILLEGAL
         BH    ICNILLEG            ILLEGAL CHAR-BRANCH
         LH    R14,ICXJUMP(R2)     GET THE OFFSET @
ICXBDJ   B     ICXBDJ(R14)         JUMP TO RIGHT BEGINNING SECTION
* * * * * JUMP OFFSET TABLE FOR 1ST CHARACTER FOR ICXBD ROUTINE       *
ICXJUMP  $AL2  ICXBDJ,(ICXDEC,ICNINVDM,ICXSDT,ICXSYM,ICXLOC,ICXLIT,ICXL#
               PARN)
.ICX2    AIF   (&$OPTMS GE 2).ICX3 SKIP IF NOT GREAT MEMORY OPT
ICXBD    CLI   0(RA),C'='          CHECK FOR LITERAL (MEMORY OPT CODE)
         BNE   ICXDEXP2            NOT LITERAL, GO CALL EXPRESSION EVAL
.ICX3    ANOP
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        THE FOLLOWING CODE SECTIONS PROCESS AN OPERAND SPECIFIED AS  *
*   A LITERAL, A RELOCATABLE SYMBOL OR EXPRESSION, OR AN EXPLICIT     *
*   DISPLACEMENT.  EXPLICIT BASES,LENGTHS, OR INDEX REGISTERS ARE     *
*   PROCESSED BY ICXABS-ICXRELOC                                      *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
* * * * * ICXLIT - PROCESS A LITERAL OPERAND - 1ST CHAR WAS =         *
ICXLIT   TM    ICRCMASK,IAL2       IS LITERAL ALLOWED
         BZ    ICNLITER            NO,GO FLAG IT
         CLI   ICRCLENG,RC$LEN2    DOES A LITERAL @ EXIST
         BNE   ICNERRF             NO,BUT IT WAS ALREADY FLAGGED-QUIT
         L     RC,ICRCLITA         GET @ LITERAL IN LITERAL TABLE
         $CALL LTGET2              GET THE PROGRAM @ LITERAL(IN RC)
         STC   RD,ICYLQT           STORE LENGTH-1 ATTRIBUTE
         NI    ICYF2,255-ICYXLFN   ZERO TO SHOW NO EXPLICIT LENGTH
         BAL   RZ,ICGBD            HAVE IT CONVERTED TO B-D FORM
         BR    RW                  RETURN TO CALLER OF ICXBD
         AIF   (&$OPTMS LT 2).ICX4 SKIP IF MEMORY OPTMIZED
         SPACE 1
* * * * * ICXSDT - CHECK SELF-DEFING TERM OR L' - 1ST CHAR WAS BCLX   *
ICXSDT   CLI   1(RA),C''''         IS ' 2ND CHAR OF OPERAND
         BNE   ICXSYM              NO,SO GO PROCESS SYMBOL
         BAL   RX,ICSDTRM          GO GET SELF-DEFINING TERM
         BZ    ICXDEC1             IF WAS SDTERM-ENTER DEC ROUTINE
         B     ICXDEXP2            IF NOT,MUST HAVE BEEN L'-GO EVAL EXP
         SPACE 1
* * * * * ICXLOC - PROCESS LOCATION COUNTER REFERENCE - 1ST CHAR WAS **
ICXLOC   $GLOC RC                  GET CURRENT LOCATION COUNTER VALUE
         SR    RB,RB               CLEAR FOR INSERTION
         IC    RB,AVCESDID         GET CURRENT ESDID
         IC    RE,ICRCLQ           GET LENGTH ATTRIBUTE,IF NEEDED
         BXH   RA,RY,ICXSYM1       BUMP SCAN POINTER AND CONTINUE
         EJECT
* * * * * ICXSYM - PROCESS SYMBOL REFERENCE - 1ST CHARACTER WAS ALPH  *
ICXSYM   BAL   RX,ICSYM            GO GET SYMBOL VALUE,ETNRY
         USING SYMSECT,RA          NOTE USING, RC=VALUE,RB=ESDID
         IC    RE,SYLENG           GET LENGTH ATTRIBUTE
         DROP  RA                  NO LONGER USING
         LR    RA,R1               RESTORE SCAN POINTER
         SPACE 1
*              COMMON CODE - SYMBOL AND LOCATION COUNTER REFERENCE.
ICXSYM1  STC   RE,ICYLQT           SAVE LENGTH ATTRIBUTE IN CASE NEEDED
         IC    R2,0(RA)            GET NEXT CHARACTER
         IC    R2,AWTDECT(R2)      GET INDEX VALUE OF CHARACTER
         C     R2,AWF12            COMPARE TO VALUE FOR (
         BNL   ICXSTEST            SKIP IF ( COMMA OR BLANK-DONE
         SPACE 1
         MVI   ICXSUBAD,X'1A'      MAKE INSTRUCTION AN AR
         CLI   0(RA),C'+'          IS IT PLUS LIKE WE HOPE
         BE    ICXSINC             YES,GO HAVE# CONVERTED
         CLI   0(RA),C'-'          IS IT -
         BE    ICXSUB              YES,GO SET INSTRUCTION
         LTR   RB,RB               WAS THE SYMBOL ABSOLUTE
         BZ    ICXDEXP1            YES,SO GO EVALUATE WHOLE EXPRESSION
         B     ICNRELC             NO,RELOCATABLE TERM IN * OR /
         SPACE 1
ICXSUB   MVI   ICXSUBAD,X'1B'      MAKE INSTRUCTION SUBTRACT TEMPORARIL
ICXSINC  AR    RA,RY               BUMP THE SCAN POINTER
         CLI   0(RA),C'0'          ARE WE LOOKING AT DECIMAL #
         BL    ICXDEXP1            IF NOT,GIVE UP AND USE EXPRESION EVA
         STM   RB,RC,ICZ1A         SAVE THES REGS
         BAL   RX,ICDNUM           GET # CONVERTED
         IC    R2,0(RA)            GET NEXT CHAR
         IC    R2,AWTDECT(R2)      GET INDEX VALUE
         C     R2,AWF12            IS IT ( COMMA OR BLANK
         BL    ICXDEXP1            NO,SO MUST BE MORE COMPLEX EXPR-JUMP
         SPACE 1
         LR    RD,RC               SAVE VALUE OF DECIMAL #
         LM    RB,RC,ICZ1A         GET SYMBOL VALUE-ESDID BACK
ICXSUBAD AR    $CHN+RC,RD          ADD OR SUBTRACT VALUE(OPCODE CHNG)
ICXSTEST LTR   RB,RB               WAS SYMBOL ABSOLUTE OR RELOCATABLE
         BZ    ICXABS              SKIP IF ABSOLUTE(UNLIKELY)
.ICX4    ANOP
         SPACE 2
* * * * * ICXRELOC - RELOCATABLE OPERAND- CONVERT TO D(B) FORM        *
*        ON ENTRY TO ICXRELOC, RC = ADDRESS, RB = ESDID OF ADDRESS    *
ICXRELOC BAL   RZ,ICGBD            GET BASE-DISPLACEMENT FORM
         TM    ICYFLAG,ICB1D1      WAS THERE ONLY BASE-DISPLACEMENT
         BCR   O,RW                YES RETURN TO CALLER
         CLI   0(RA),C'('          WAS INDEX OR LENGTH SPECIFIED
         BCR   NE,RW               NO,SO JUST RETURN TO CALLER
         AR    RA,RY               BUMP SCAN POINTER PAST (
         BAL   RZ,ICX2L12          GO GET INDEX OR LENGTH AS NEEDED
         STC   RC,ICYXL            SAVE THIS VALUE FOR LATER
         CLI   0(RA),C')'          IS ) THERE LIKE IT SHOULD BE
         BNE   ICNINVDM            NO-ERROR
         BXH   RA,RY,0(RW)         BUMP SCAN POINTER AND RETURN
         EJECT
         AIF   (&$OPTMS LT 2).ICX6 SKIP IF MEMORY OPT
* * * * * ICXDEC - PROCESS DECIMAL DISPLACEMENT - 1ST CHAR WAS DEC #  *
ICXDEC   BAL   RX,ICDNUM           GO GET DECIMAL #
ICXDEC1  CLI   0(RA),C'('          IS NEXT (
         BE    ICXABSA             YES,BASE-X-L FOLLOW
         CLI   0(RA),C' '          IS BLANK NEXT
         BE    ICXABSB             YES,GO INTO ABS SECTION
         CLI   0(RA),C','          IS THIS FIRST OPERAND OF SEVERAL
         BE    ICXABSB             YES,GO FINISH OFF
         SPACE 1
*        FALLS THRU==> NOT SIMPL,HOPED-FOR DECIMAL #-USE EXPRESSION EV*
ICXDEXP1 L     RA,ICZ1RA           GET THE ORIGINAL SCAN POINTER BACK
ICXLPARN EQU   *                   1ST CHAR WAS ( ==> PROCESS EXPRESSN
.ICX6    ANOP
ICXDEXP2 BAL   RX,ICEXP            GO GET EXPRESSION EVALUATED
         STC   RE,ICYLQT           SAVE THIS AS LENGTH ATTRIBUTE
         BNZ   ICXRELOC            CC SET BY ESDID TEST-GO TO RELOC IF
         SPACE 2
* * * * * ICXABS - OPERAND DISPLACEMENT EXPLICIT - GET X,L,B,ETC      *
*        ON ENTRY TO ICXABS,ICXABSA,ICXABSB, RC = DISPLACEMENT VALUE  *
ICXABS   CLI   0(RA),C'('          WAS DISPLACEMENT ALONE(PROB SHIFT)
         BNE   ICXABSB             YES,GO FINISH UP
ICXABSA  CL    RC,AWFXFFF          IS DISPLACEMENT > 4095
         BH    ICNEXGTA            DISPLACEMENT TOO LARGE
         ST    RC,ICZ1A            SAVE THE DISPLACEMENT VALUE
         AR    RA,RY               BUMP SCAN POINTER PAST (
         TM    ICYFLAG,ICB1D1      IS THER LENGTH OR INDEX
         BO    ICXABSN             NO-BASE-DISPLACEMENT ONLY
         SPACE 1
         CLI   0(RA),C','          IS L OR X FIELD OMITTED
         BNE   *+8                 SKIP IF NOT OMITTED
         BXH   RA,RY,ICXABSN       BUMP PAST , AND JUMP-OMITTED X OR L
         BAL   RZ,ICX2L12          GET LENGTH OR INDEX
         STC   RC,ICYXL            SAVE LENGTH OR INDEX
         SPACE 1
         SR    RC,RC               CLEAR FOR OMITTED BASE,INCASE IT IS
         CLI   0(RA),C','          IS BASE SPECIFIED
         BNE   ICXABSP             NO,MUST BE OMITTED
         AR    RA,RY               BUMP SCAN POINTER BY 1
ICXABSN  BAL   RZ,ICREG            GET BASE REGISTER
ICXABSP  CLI   0(RA),C')'          IS THE DELIMITER AN ENDING )
         BNE   ICNINVDM            NO-EEROR
         LR    RD,RC               MOVE VALUE OF REGISTER OVER
         SLL   RD,12               SHIFT INTO RIGHT POSITOON
         L     RC,ICZ1A            GET DISPLACEMENT BACK
         AR    RD,RC               PUT BAS AND DISPLACEMENT TOGETHER
         BXH   RA,RY,ICXABSB2      BUMP SCAN PTR PAST ) AND BRANCH
         EJECT
*              ICXABSB ENTERED IF DISPLACEMENT ALONE,NO X,L,B         *
ICXABSB  CL    RC,AWFXFFF          IS DISPLACEMENT > 4095
         BH    ICNEXGTA            NO-ERROR -DISPLACEMNT >4095
         LR    RD,RC               DUPLICATE VALUE OF ADDRESS AS B-D
         SPACE 1
*              ICXABSB2 ENTERED AS COMMON EXIT FROM ICXABS.           *
ICXABSB2 BAL   RX,ICPEA            HAVE ADDRESS CHECKED AND STORED
         BAL   RZ,ICQOPN           HAVE BASE-DISPLACEMENT STORED
         BR    RW                  RETURN TO CALLER
         EJECT
* * * * * ICGBD - GET AND STORE BASE-DISP OF @ - LEVEL - 2  * * * * * *
*   RB = ESDID OF THE @                                               *
*   RC = @ FOR WHICH BASE-DISPLACEMENT IS TO BE FOUND                 *
*   RZ = RETURN ADDRESS OF CALLING ROUTINE                            *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
ICGBD    BAL   RX,ICPEA            HAVE ACTUAL ADDRESS CHECKED AND SAVE
         LR    R1,RA               SAVE THE SCAN POINTER
         LR    RA,RC               MOVE @ OVER FOR BRDISP CALL
         $CALL BRDISP              GO HAVE BASE-DISPLACEMENT FOUND
         LR    RD,RA               MOVE VALUE OVER TO FALL INTO ICQOPN
         LR    RA,R1               RESTORE THE SCAN POINTER
         LTR   RB,RB               WAS BASE-DISP OK
         BNZ   ICNADDR             NO,ADDRESSIBILITY ERROR
         SPACE 2
* * * * * ICQOPN - STORE BASE-DISPLACEMENT INTO OPN1-OPN2 - LEVEL - 2 *
*        ENTRY CONDITIONS                                             *
*   RD = VALUE TO BE STORED INTO ICYOPN1-OPN2 FIELD
*   RZ = RETURN ADDRESS OF CALLING ROUTINE                            *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
ICQOPN   TM    ICYFLAG,ICBSOPN2    SHOULD IT GO INTO OPN2
         BO    *+10                YES,SKIP OVER IF OPN2
         STH   RD,ICYOPN1          STORE INTO 1ST OPERAND D(B) FIELD
         BR    RZ                  RETURN TO CALLER
         STH   RD,ICYOPN2          STORE INTO 2ND FIELD (SS INSTS ONLY)
         BR    RZ                  RETURN TO CALLER
         EJECT
* * * * * ICREG - SCAN AND CONVERT A REGISTER VALUE. - LEVEL - 2.     *
*        AS OF VERSION 3.0/A, ANY ABSOLUTE EXPRESSION <= 15 IS       J*
*        ALLOWED FOR REGISTER.  CODE IS ORIENTED TOWARDS NORMAL CASE.J*
*        ENTRY CONDTIONS                                              *
*   RA = @ FIRST CHARACTER OF REGISTER.                               *
*   RZ = RETURN ADDRESS.                                              *
*        EXIT CONDITIONS                                              *
*   RA = SCAN POINTER TO CHARACTER FOLLOWING REGISTER                 *
*   RC = VALUE OF REGISTER,RIGHT JUSTIFIED.  0 <= RC <= 15            *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
ICREG    LR    R0,RA               SAVE @ OF 1ST CHAR OF EXPRESSION   J
         BAL   RX,ICSDTRM          NOW GO TRY FOR SELF-DEFINING TERM  J
         BZ    ICREGSYC            IF OK, BRANCH TO CHECK DELIM AFTER J
*              NOT SELF-DEF TERM, TRY EXPRESSION OR SYMBOL.           J
         CLI   0(RA),C'('          MAKE SURE NOT EXPRESSION IN PARENS J
         BE    ICREGSYE            WAS EXPRESS IN PARENS-BRANCH OUT   J
         BAL   RX,ICSYM            SYMBOL, GO TO EVALUATE IT          J
         LR    RA,R1               MOVE SCAN POINTER BACK RIGHT
         BNZ   ICNEABS             BRANCH ==> RELOCATABLE REGISTER-ERR
*              MAKE SURE ACTUALLY IS END OF REGISTER FIELD            J
ICREGSYC CLI   0(RA),C','          MOST COMMON ENDING DELIMITER       J
         BE    ICREGSYO            YES, WAS COMMA, DONE, BRANCH OUT   J
         CLI   0(RA),C' '          NEXT COMMON DELIMITER              J
         BE    ICREGSYO            YES, IT WAS BLANK, BRANCH OUT      J
         CLI   0(RA),C')'          LAST CAHNCE, RIGHT PAREN           J
         BE    ICREGSYO            BRANCH OUT, WAS END OF EXPRESSION  J
*              WAS MORE COMPLEX EXPRESSSION, PROCESS IT (R), R+1, ETC.J
ICREGSYE LR    RA,R0               RESTORE ORIGINAL PTR, FROM ICREG.  J
         BAL   RX,ICEXP            CALL GENERAL EXPRESSION EVAL (SLOW)J
         BNZ   ICNEABS             MUST BE ABSOLUTE EXPRESS-BR IF NOT J
ICREGSYO C     RC,AWF15            WAS IT LEGAL SIZE
         BCR   NH,RZ               RETURN TO CALLER IF SMALL ENOUGH
         B     ICNEXGTA            TOO BIG-ERROR-FLAG IT
         EJECT
* * * * * ICX2L12 - FLAG X-L FOUND, MAKE CHOICE OF ROUTINE - LEVEL - 2*
*        ENTRY CONDITIONS                                             *
*   RA = SCAN POINTER TO 1ST CHAR OF LENGTH OR INDEX                  *
*   RZ = RETURN ADDRESS OF CALLING ROUTINE                            *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
ICX2L12  OI    ICYF2,ICYXLFN       NOTE THAT LENGTH OR INDEX FOUND
         TM    ICYFLAG,ICBX2       ARE WE LOOKING FOR AN INDEX REG
         BO    ICREG               SKIP IF REG,FLL THRU TO LENGTH IF NT
         SPACE 2
* * * * * ICLENG - SCAN AND CONVERT A LENGTH.   LEVEL - 2             *
*        ENTRY CONDITIONS                                             *
*   RA = SCAN POINTER TO 1ST CHARACTER OF LENGTH.                     *
*   RZ = RETURN ADDRESS TO CALLING ROUTINE                            *
*        EXIT CONDITIONS                                              *
*   RA = SCAN POINTER TO DELIMITER FOLLOWING LENGTH, EITHER , OR )    *
*   RC = LENGTH FOR ASSEMBLY(I.E. L-1,EXCEPT L=0).  0 <= RC <= 255    *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         AIF   (&$OPTMS LT 2).ICX10         SKIP IF MEMORY OPT
ICLENG   CLI   0(RA),C'0'          DO WE HAVE DECIMAL # (WE HOPE SO!)
         BL    ICLEXP              NO WE DON'T - USE EXPRESSION EVAL
         ST    RA,ICZ2A            SAVE THE SCAN POINTER
         BAL   RX,ICDNUM           GO GET DECIMAL #
         CLI   0(RA),C','          IS IT FOLLOWED BY COMMA
         BE    ICLSIZE             YES- LENGTH WAS JUST DECIMAL #
         CLI   0(RA),C')'          IS DELIM  )
         BE    ICLSIZE             YES,GO CHECK FOR SIZE
         SPACE 1
         L     RA,ICZ2A            GET SCAN POINTER BACK-MORE THAN #
.ICX10   AIF   (&$OPTMS GE 2).ICX11         SKIP IF NOT EMMORY OPT
ICLENG   EQU   *
.ICX11   ANOP
ICLEXP   BAL   RX,ICEXP            GO GET EXPRESSION EVALUATED
         BNZ   ICNEABS             BRANCH==> RELOCATABLE EXP-ERR
ICLSIZE  SR    RC,RY               DECREMENT LENGTH TO LENGTH-1
         BNM   *+6                 SKIP IF ORIG LENGTH ^= 0
         SR    RC,RC               MAKE LENGTH ZERO
         C     RC,AWFXFF           IS THE VALUE <= 255
         BCR   NH,RZ               RETURN IF VALUE OK
         B     ICNEXGTA            LENGTH > 255-DEFINITELY BAD
         EJECT
* * * * * ICPEA - CHECK @ ALIGNMENT, SET UP EA1 OR EA2 - LEVEL - 3    *
*        **NOTE** REGS RA-RD ARE SAFE ACROSS CALL TO ICPEA            *
*        ENTRY CONDITIONS                                             *
*   RC = ADDRESS VALUE TO BE STORED INTO ICYEA1 OR ICYEA2             *
*   RX = RETURN ADDRESS TO CALLING SECTION                            *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
ICPEA    ST    RC,ICYEA2           STORE VALUE IN 2ND SLOT ALWAYS
         TM    ICYFLAG,ICBSEA2     DID VALUE ACTUALLY BELONG IN 2ND POS
         BO    *+8                 BRANCH IF WAS 2ND OPERAND
         ST    RC,ICYEA1           STORE VALUE IN FIRST SLOT
         IC    R14,ICRCMASK        GET MAK FOR ALIGNMENT
         N     R14,AWF7            REMOVE ALL BUT LAST 3 BITS
         NR    R14,RC              TEST FOR RIGHT ALIGNMENT
         BCR   Z,RX                IF ZERO==> ALIGNMENT OK
         SPACE 1
*              FALLS THRU ==> ALIGNMENT ERROR MESSAGE                 *
         STM   RB,RD,ICZ3A         SAVE THE VALUES OF REGS
         LA    RB,$ERALIGN         NOTE ALIGNMENT ERROR
         SR    RA,RY               MOVE SCAN PTR BACK 1
         $CALL ERRTAG              HAVE IT FLAGGED
         AR    RA,RY               PUT SCAN PTR BACK WHERE BELONGS
         LM    RB,RD,ICZ3A         RESTORE REGS
         BR    RX                  RETURN TO CALLER
         SPACE 2
* * * * * ICDNUM - SCAN AND CONVERT DECIMAL #.   LEVEL - 3            *
*        ENTRY CONDITIONS                                             *
*   RA = SCAN POINTER TO 1ST DIGIT OF DECIMAL #                       *
*   RX = RETURN ADDRESS OF CALLING SECTION                            *
*        EXIT CONDITIONS                                              *
*   RA = @ DELIMITER BEYOND #                                         *
*   RC = VALUE OF #, RIGHT JUSTIFIED.                                 *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
ICDNUM   EQU   *
         $CALL SDDTRM              CALL DECIMAL CONVERTER
         LTR   RB,RB               WAS THERE ERROR
         BCR   Z,RX                NO ERRORS,RETURN
         B     ICNERROR            ERROR-GO HAVE IT FLAGGED
         EJECT
* * * * * ICEXP - SCAN AND EVALUATE EXPRESSION - LEVEL - 3            *
*        ENTRY CONDITIONS                                             *
*   RA = SCAN POINTER TO 1ST CHARACTER OF EXPRESSION                  *
*   RX = RETURN ADDRESS OF CALLING SECTION                            *
*        EXIT CONDITIONS                                              *
*   RA = SCAN POINTER TO DELIMITER FOLLOWING EXPRESSION               *
*   RB = ESDID OF EXPRESSION, =0 FOR ABSOLUTE EXPRESSION              *
*   RC = VALUE OF EXPRESSION                                          *
*   RE = LENGTH ATTRIBUTE - 1 OF EXPRESSION                           *
*   CC = SET BY TESTING ESDID                                         *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
ICEXP    $CALL EVALUT              EVALUATE EXPRESSION
         LTR   RB,RB               WAS IT LEGAL
         BNZ   ICNERROR            NO-GO FLAG AND QUIT
         LTR   RB,RD               MOVE ESDID OVER AND SET CC
         BR    RX                  RETURN TO CALLER
         SPACE 2
* * * * * ICSDTRM - GET SELF-DEFINING TERM VALUE - LEVEL - 3          *
*        ENTRY CONDITIONS                                             *
*   RA = SCAN POINTER TO 1ST CHARACTER                                *
*   RX = RETURN ADDRESS OF CALLING SECTION                            *
*        EXIT CONDITIONS                                              *
*   RA = UNCHANGED IF NOT SD TERM, SCAN PTR TO DELIMITER IF WAS SDTERM*
*   RC = VALUE OF SELF-DEFING TERM, IF IT WAS ONE                     *
*   CC   SET BY TESTING RB ON RETURN (<0 ==> NOT SD TERM)             *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
ICSDTRM  EQU   *                   DON'T NEED TO SET RB ANYMORE
         $CALL SDBCDX              CALL GENERAL SD TERM PROCESSOR
         LTR   RB,RB               TEST CONDITON
         BCR   NP,RX               RETURN IF EITHER GOOD, OR NOT SD TER
         B     ICNERROR            IT WAS SD TERM, BUT ILLEGAL ONE
         EJECT
* * * * * ICSYM - SCAN AND LOOK UP SYMBOL,RETURN VALUES. LEVEL - 3    *
*        ENTRY CONDITIONS                                             *
*   RA = SCAN POINTER TO 1ST CHARACTER OF SYMBOL                      *
*   RX = RETURN ADDRESS OF CALLING SECTION                            *
*        EXIT CONDTIONS                                               *
*   R1 = SCAN POINTER TO DELIMITER FOLLOWING SYMBOL                   *
*   RA = @ SYMSECT ENTRY FOR THE SYMBOL                               *
*   RB = ESDID OF THE SYMBOL                                          *
*   RC = VALUE OF THE SYMBOL                                          *
*   CC = SET BY TESTING THE ESDID OF THE SYMBOL                       *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
ICSYM    TRT   0(9,RA),AWTSYMT     SCAN FOR END OF SYMBOL
         BZ    ICNBADSY            BAS SYMBOL - TOO LONG
         LR    RB,R1               MOVE ENDING POINTER OVER
         SR    RB,RA               GET LENGTH OF SYMBOL
         BZ    ICNBADSY            SYMBOL OF 0 LENGTH -ERROR
         $CALL SYFIND              HAVE IT LOOKED UP IN TABLE
         LTR   RB,RB               WAS IT ALREADY THERE
         BNZ   ICNUNDEF            UNDEFINED-NOT IN TABLE
         SPACE 1
         USING SYMSECT,RA          NOTE SYMBOL TABLE USING
         TM    SYFLAGS,$SYDEF      IS SYMBOL DEFINED
         BZ    ICNUNDEF            NOT FLAGGED DEFINED - ERROR
         IC    RB,SYESDID          GET ESDID OF THE SYMBOL
         L     RC,SYVALUE          GET VALUE OF THE SYMBOL
         LTR   RB,RB               SRT CC HERE
         BR    RX                  RETURN TO CALLER
         DROP  RA                  KILL USING FOR SYMSECT
         SPACE 2
* * * * * ICULEN - GET SPECIFIED LENGTH, OR IMPLIED LENGTH - LEVEL - 3*
*        ENTRY CONDITIONS                                             *
*   RX = RETURN ADDRESS OF CALLING SECTION                            *
*        EXIT CONDITIONS                                              *
*   R2 = LENGTH-1,SUITABLE FOR USE IN SS INSTRUCTION                  *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
ICULEN   IC    R2,ICYXL             GET LENGTH (IF SPECIFIED)
         TM    ICYF2,ICYXLFN       WAS A LENGTH EXPLICITYLY SPECIFIED
         BCR   O,RX                YES,RETUNR NOW
         IC    R2,ICYLQT           NO, IMPLIED LENGTH, GET THE LENGTH-1
         BR    RX                  RETUNR TO CALLER
         SPACE 1
ICOIR    OI    ICYR1R2,$CHN        REG OR LENGTH SUPPLIED BY EXECUTE
         EJECT
* * * * * INTERNAL CONSTANTS                                          *
* * * * * TABLE OF ICYFLAG VALUES FOR VARIOUS INSTRUCTION TYPES.      *
*        A MACRO IS USED TO KEEP INDEPENDENCE ON ACTUAL EQUATE VALUES *
ICTTAB   EQU   *-1                 OFFSET SYMBOL
         DS    ($ICTMX)C           DEFINE ENOUGH STORAGE FOR MAX TYPES
         ICT   $RRM,0
         ICT   $RXM,$ICBEA2+ICBX2+ICBSEA2
         ICT   $RR,0
         ICT   $RX,$ICBEA2+ICBX2+ICBSEA2
         ICT   $RS,$ICBEA2+ICB1D1+ICBSEA2
         ICT   $RSH,$ICBEA2+ICB1D1+ICBSEA2
         ICT   $SI,$ICBEA1+ICB1D1
         ICT   $SS,$ICBEA1+$ICBEA2 WILL BE CHANGED AFTER 1ST OP DONE
         ICT   $SS2,$ICBEA1+$ICBEA2 ILL BE CHANGED AFTER 1ST OP DONE
         ICT   $RSO,0              FOR SPM,SVC. OTHERS WILL CHANGE
         ICT   $SPC,$ICBEA1+ICBX2
         ORG
         SPACE 1
* * * * * INTERNAL VARIABLES                                          *
         AIF   (&$OPTMS LT 2).ICX12         SKIP IF MEMORY OPT
ICZ1A    DS    2F                  USED BY LEVEL 1 ROUTINES AS SAVE
ICZ1RA   DS    F                   FOR SAVING SCAN POINTER IN ICXBD
ICZ2A    DS    F                   SAVE WORD FOR LEVEL 2 ROUTINES
.ICX12   AIF   (&$OPTMS GE 2).ICX13         SKIP IF MEMORY NO OPT
ICZ1A    DS    F                   LEVEL 1 SAVE WORD (MEMORY OPTMZ)
.ICX13   ANOP
ICZ3A    DS    3F                  USED BY LEVEL 3 ROUTINES AS SAVE
         SPACE 1
*              INTERNAL LOCATION FOR RCODBLK VARIABLES                *
ICRCB    DS    0F                  ALIGN ON FULLWORD
ICRCLENG DS    C                   LENGTH - 1 OF ICRCB
         DS    AL3                 ICRCLOC
ICRCTYPE DS    C                   INSTRUCTION TYPE
ICRCHEX  DS    C                   HEX OPCODE
ICRCMASK DS    C                   MASK AND FLAG BITS
ICRCLQ   DS    C                   LENGTH-1 ATTRIBUTE OF INSTRUCTION
ICRCLITA DS    A                   @ LITERAL IN LITERAL TABLE,IF EXISTS
         SPACE 1
*              INTERNAL LOCATION FOR OBJECT CODE BLOCK-ICBLOCK        *
ICYBLOCK DS    0F                  ALIGN ON F
ICYEA1   DS    F                   INSTRUCTION @ 1 FOR OUTPT2
ICYEA2   DS    F                   INSTRUCTION @ 2 FOR OUTPT2
ICYOP    DS    C                   OPCODE
ICYR1R2  DS    C                   REGISTERS,MASK,LENGTHS
ICYOPN1  DS    H                   1ST BASE DISPLACEMENT
ICYOPN2  DS    H                   2ND BASE-DISPLACEMENT
ICYFLAG  DS    C                   CONTROLS PROCESSING&PRINTING OF OPRD
*              THE ABOVE VARS ARE USED BY OUTPT2                      *
ICYF2    DS    C                   BYTE FOR ICXBD TO RETURN STATUS
ICYXL    DS    C                   INDEX OR LENGTH STORED HERE -ICXBD
ICYLQT   DS    C                   FOR IMPLIED LENGTH - LENGTH-1 HERE
         AIF   (NOT &$XREF).NOXRF16
*                 0 1 2 3 4 5 6 7 8 9 A B C D E F                     A
ICXRTAB  DC    X'000000000884840C0C0C080000000C0C'         0          A
         DC    X'84848484840C8484840C848484848484'         1          A
         DC    X'84848484848484840C84848484848484'         2          A
         DC    X'8484848484848484840C848484848484'         3          A
         DC    X'488448840C84840C840C848484004884'         4          A
         DC    X'48004884840C8484840C848484848484'         5          A
         DC    X'4884480000000084840C848484848484'         6          A
         DC    X'4800000000000000840C848484848484'         7          A
         DC    X'08000800000086868484848484848484'         8          A
         DC    X'2C00840C840C8484C200000000000000'         9          A
         DC    X'00000000000000000000000000000000'         A          A
         DC    X'00000000000000000000000000882C86'         B          A
         DC    X'06000000000000000000000000000000'         C          A
         DC    X'00848484840C84840000000084848484'         D          A
         DC    X'00000000000000000000000000000000'         E          A
         DC    X'84848484000000008484848484840000'         F          A
.NOXRF16 ANOP                                                         A
         DROP  RAT,R13             KILL USINGS
         TITLE '*** IDASM2 - ASSEMBLER INSTRUCTIONS - PASS 2 ***'
**--> CSECT: IDASM2   2   ASSEMBLER INSTRUCTIONS - PASS 2 . . . . . . .
*.       THIS MODULE IS 1 OF THE 2 PASS 2,LEVEL 2 ROUTINES IN THE     .
*.       ASSIST ASSEMBLER.  IT PERFORMS ALL PROCESSING OF ASSEMBLER   .
*.       INSTRUCTIONS IN THE SECOND PASS.  IT PRODUCES SOME OBJECT    .
*.       CODE, AND DOES SETUP FOR PRINTING.  MOST OF THE WORK HAS     .
*.       ALREADY BEEN DONE IN THE CORREPONDING PASS 1 MODULE, IBASM1. .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER (ADDRESS OF 1ST CHARACTER OF OPERAND FIELD)     .
*.  RC = ADDRESS OF RECORD CODE BLOCK(RCODBLK) FOR STATEMENT          .
*.  RE = ADDRESS OF RECORD SOURCE BLOCK(RSBLOCK) FOR STATEMENT        .
*.       CALLS BRDROP,BRUSIN,CCCON2,CNDTL2,ERRTAG,ESENX2,EVALUT,LTDMP2.
*.       CALLS OUTPT2,UTPUT2                                          .
*.       USES DSECTS: AVWXTABL,RCODBLK,RSBLOCK,SYMSECT                .
*.       USES MACROS: $AL2,$CALL,$GLOC,$RETURN,$SAVE,$SDEF,$STV       .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         SPACE 1
IDASM2   CSECT
         $DBG  90,*
         USING AVWXTABL,RAT        NOTE MAIN TABLE USING
         USING RCODBLK,RC          RC HAS POINTER ON ENTRY
         USING RSBLOCK,RE          NOTE ADDRESSIBILITY
         SPACE 1
* * * * * REGISTER USAGE FOR IDASM2 * * * * * * * * * * * * * * * * * *
*   R2 = BYTE REGISTER (HI-ORDER 3 BYTES = 0).                        *
*   RW = INTERNAL LINK REGISTER - LEVEL - 1 (IDREGET,IDEVAL)          *
*   RY = 1     USEFUL CONSTANT IN ODD REGISTER.                       *
*   RC = @ RCODBLK FOR STMT (= AVRCBPT).                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         $SAVE RGS=(R14-R6),SA=IDSAVE,BR=R13
         LA    RY,1                SET UP HANDY CONSTANT FOR MANY SECTS
         SR    R2,R2               CLEAR FOR INSERTIONS
         IC    R2,RCTYPE           GET TYPE BYTE
         LH    R14,IDAJUMP-$IB(R2) GET OFFSET @ TO RIGHT SECTION
         TM    RSBFLAG,$REBX       DO ERRORS EXIST ALREADY
         DROP  RE                  REMOVE RSBLOCK USING NOW
IDASMJ   BZ    IDASMJ(R14)         GO IF NO ERRORS
*              ERRORS EXIST - CURRENTLY, PROCESS END CARDS ONLY
         CLI   RCTYPE,$IB+$IEND    WAS IT AN END CARD
         BNE   IDOUT2              ANYTHING ELSE - FORGET IT
         B     IDEND               PROCESS END WHETHER ERRS OR NOT
         EJECT
* * * * * INDIVIDUAL ERROR EXITS                                      *
IDERELOC LA    RB,$ERRELOC         NEED RELOCATABLE VALUE
         B     IDERROR             GO HAVE ERROR FLAGGED
IDERELC  LA    RB,$ERNEABS         ABSOLUTE VALUE REQUIRED
         B     IDERROR             GO HAVE ERROR FLAGGED
IDREGBIG LA    RB,$EREXGTA         REGISTER OR OTHER VALUE TOO LARGE
         B     IDERROR             GO HAVE ERROR FLAGGED
IDERIND  LA    RB,$ERINVDM         INVALID DELIMITER
IDERROR  $CALL ERRTAG              FLAG IT
         SPACE 1
* * * * * PRINT STATEMENT AND RETURN TO CALLER.                       *
IDOUT2   L     RD,AWFM4            PUT NEG # TO SHOW NO CODE PRINTED
IDOUT2A  LA    RB,$OUCONS          SHOW TYPE OF CALL TO OUTPT2
IDOUT    $CALL OUTPT2              HAVE LINE PRINTED
IDRET    $RETURN RGS=(R14-R6)
         EJECT
* * * * * CCW * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
IDCCW    EQU   IDOUT2              **UNTIL CCW CODE WRITTEN           *
         SPACE 1
* * * * * CNOP  * * * * * * * * * * * * * * * * * * * * * * * * * * * *
IDCNOP   IC    R2,RCMASK           GET LENGTH 0-2-4-6
         SR    R2,RY               DECREMENT LENGTH TO LENGTH - 1
         BM    IDOUT2              IF L<0,NO OBJECT CODE NEEDED-SKIP
         LR    RD,R2               MOVE LEN-1 OVER FOR UTPUT2
         LR    RE,RY               PLACE A 1 IN REG RE-DUPFAC OF 1
         LA    RC,=3X'0700'        GET @ 3 NOPRS
         $GLOC RA                  GET LOCATION COUNTER FOR UTPUT2
         $CALL UTPUT2              CALL OBJECT CODE ROUTINE
         LA    RC,=3X'0700'        GET @ 3 NOPRS
         LR    RD,R2               MOVE LENGTH-1 OVER FOR OUTPT2
         B     IDOUT2A             GO HAVE CODE PRINTED
         SPACE 1
* * * * * CSECT * * * * * * * * * * * * * * * * * * * * * * * * * * * *
IDCSECT  NI    AVTAGS1,255-$IBDSEC1          MAKE SURE FLAGGED CSECT
         B     IDESCH              GO CHANGE ESDID
         SPACE 1
* * * * * DC  * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
IDDC     SR    RB,RB               CLEAR FOR INSERT
         IC    RB,RCMASK           GET THE NUMBER OF OPERANDS IN DC
         LA    RC,RCLITEQ          GET @ FIRST OR ONLY CNCBLOCK
         $CALL CNDTL2              CALL 2ND PASS CONSTANT PROCESSOR
         B     IDRET               RETURN(CNDTL2 PRINTED LINE)
         SPACE 1
         AIF   (&$DEBUG).IDNOD1    SKIP OVER IF NOT DEBUG MODE
         SPACE 1
* * * * * DEBUG * * * * * * * * * * * * * * * * * * * * * * * * * * * *
IDDEBUG  CLI   RCHEX,C'2'          WAS THIS FOR PASS 2
         BNE   IDOUT2              QUIT IF WASN'T FOR 2
         MVC   AVDEBUG,RCMASK      MOVE BYTE INTO DEBUG FIELD
         B     IDOUT2              GO HAVE PRINTED OUT
.IDNOD1  ANOP
         SPACE 1
* * * * * DS  * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
IDDS     EQU   IDOUT2              EVERYTHING DONE IN PASS 1
         SPACE 1
* * * * * DROP  * * * * * * * * * * * * * * * * * * * * * * * * * * * *
IDDROP   BAL   RW,IDREGET          GET THE REGISTER VALUE
         $CALL BRDROP              HAVE REG DROPPED
         LR    RA,R1               RESTORE SCAN POINTER
         LTR   RB,RB               WAS THERE AN ERROR
         BZ    IDDROK              NO ERROR CONTINUE
         SR    RA,RY               BACK UP SCAN POINTER BY 1
         LA    RB,$ERRGNUS         REGISTER NOT USED-ONLY ERROR POSSIBL
         $CALL ERRTAG              HAVE THE ERROR TAGGED
         AR    RA,RY               BUMP SCAN POINTER TO NEXT CHAR
         SPACE 1
IDDROK   CLI   0(RA),C' '          WAS THIS LAST REGISTER
         BE    IDOUT2              YES-QUIT
         CLI   0(RA),C','          IS DELIMITER OK
         BNE   IDERIND             INVALID DELIMITER-NO COMMA
         BXH   RA,RY,IDDROP        BUMP SCAN POINTER AND GO BACK
         EJECT
* * * * * DSECT * * * * * * * * * * * * * * * * * * * * * * * * * * * *
IDDSECT  OI    AVTAGS1,$IBDSEC1    FLAG DSECT NOW
IDESCH   MVC   AVCESDID,RCMASK     MOVE NEW ESDID OVER
         B     IDOUT2              GO HAVE STATEMENT PRINTED
         SPACE 1
* * * * * ENTRY * * * * * * * * * * * * * * * * * * * * * * * * * * * *
IDENTRY  SR    RB,RB               SHOW THIS IS ENTRY CALL
         B     IDENEXCL            GO CALL ESENX2 ROUTINE
         SPACE 1
* * * * * EJECT * * * * * * * * * * * * * * * * * * * * * * * * * * * *
IDEJECT  SR    RE,RE               SHOW THIS IS SPACE OR EJECT
         B     IDPRIN2             GO TO CALL PRINTOUT ROUTINE
         SPACE 1
* * * * * END * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        SETS AVFENTER=ENTRY @, LEAVES = START VALUE OR 0 IF NO END SY*
IDEND    CLI   0(RA),C' '          WAS THERE A SYMBOL ON THE END CARD
         BE    IDLTORG             GO HANDLE AS LTORG
         BAL   RW,IDEVAL           HAVE EXPRESSION EVALUATED
         ST    RC,AVFENTER         SAVE THIS ENTRY POINT VALUE
         B     IDLTORG             GO HANDLE AS LTORG NOW
         SPACE 1
* * * * * EQU * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        SETS RCLOC = VALUE OF EQU SYMBOL FOR LISTING.                *
IDEQU    MVC   RCLOC,RCLITEQ+1     MOVE VALUE OF SYMBOL OVER FOR PRINT
         B     IDOUT2              GO PRINT STMT
         SPACE 1
* * * * * EXTRN * * * * * * * * * * * * * * * * * * * * * * * * * * * *
IDEXTRN  LA    RB,2                SHOW ESENX2 THIS IS EXTRN
IDENEXCL $CALL ESENX2              CALL ROUTINE
         B     IDOUT2              PRINT STATEMENT AND RETURN
         SPACE 1
* * * * * LTORG * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              END CARD PROCESSING ALSO USES THIS CODE                *
IDLTORG  LA    RB,$OUCOMM          SHOW NO LOCATION COUNTER-END-LTORG
         L     RD,AWFM4            SHOW THERE IS NO CODE TO BE PRINTED
         $CALL OUTPT2
         $CALL LTDMP2              HAVE LITERALS DUMPED AND PRINTED
         B     IDRET               RETURN
         SPACE 1
* * * * * ORG * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
IDORG    EQU   IDOUT2              EVERYTHING ALREADY DONE IN PASS 1
         EJECT
* * * * * PRINT * * * * * * * * * * * * * * * * * * * * * * * * * * * *
IDPRINT  LA    RE,2                SHOW THIS IS A PRINT COMMAND
IDPRIN2  LA    RC,RCMASK           @ TAG BITS(PRINT) OR # (SPACE,EJECT)
         B     IDLIST              GO TO CALL ROUTINE
         SPACE 1
* * * * * SPACE * * * * * * * * * * * * * * * * * * * * * * * * * * * *
IDSPACE  EQU   IDEJECT             HANDLED SAME AS EJECT
         SPACE 1
* * * * * START * * * * * * * * * * * * * * * * * * * * * * * * * * * *
IDSTART  EQU   IDCSECT             HANDLE SAME AS CSECT
         SPACE 1
* * * * * TITLE * * * * * * * * * * * * * * * * * * * * * * * * * * * *
IDTITLE  EQU   *                   PROCESS TITLE STATEMENT       CPP
         LA    RA,1(RA)            RA=>1ST BYTE OF TITLE (AFTER ') CPP
         SR    RB,RB               CLEAR FOR INSERT            CPP
         IC    RB,RCMASK           GET LENGTH-1 OF TITLE       CPP
         $CALL CCCON2              EVALUATE OPD. (SAME AS C-TYPE DC) CP
         LA    RE,4                SHOW THIS IS A TITLE
*              COMMON CODE - EJECT,PRINT,SPACE,TITLE.
IDLIST   LA    RB,$OULIST          SHOW LISTING CONTROL
         B     IDOUT               GO FINALLY TO CALL OUTPT2
         SPACE 1
* * * * * USING * * * * * * * * * * * * * * * * * * * * * * * * * * * *
IDUSING  BAL   RW,IDEVAL           CALL EXPRESSION EVALUATORE
         SPACE 1
*              INITIALIZES FOR POSSIBLE MULTIPLE USING, LOOP IF SO.
IDUSB    LR    RX,RC               MOVE LOCATION COUNTER VALUE OVER
         L     RC,AVRCBPT          GET RCODBLK POINTER BACK,USING THER
         $STV  RX,RCLOC            SAVE LOCATION FOR PRINTING
         SPACE 1
IDUSC    CLI   0(RA),C','          MAKE SURE COMMA IS THERE
         BNE   IDERIND             BRANCH IF NOT-INVALIDDELIM
         AR    RA,RY               BUMP SCAN POINTER BEYOND ,
         BAL   RW,IDREGET          GO GET 1ST OR AFTER REGISTER VALUE
         LR    RB,RX               PUT CURRENT USING VALUE IN REG
         LR    RC,RZ               MOVE THE ESDID OVER FOR THE CALL
         $CALL BRUSIN              HAVE USING ENTERED
         SPACE 1
         CLI   0(R1),C' '          SCAN PT IN R1,CHECK FOR LAST
         BE    IDOUT2              QUIT IF DONE
         LA    RX,4095(RY,RX)      BUMP CURRENT USING 4096
         LR    RA,R1               MOVE SCAN POINTER BACK OVER
         B     IDUSC               BUMP SCAN POINTER AND CONTINUE
         EJECT
**--> INSUB: IDREGET    CONVERT REGISTER, CHECK VALIDITY  + + + + + + +
*+       ENTRY CONDITIONS                                             +
*+  RA = SCAN POINTER TO 1ST CHARACTER OF REGISTER                    +
*+  RW = RETURN @ TO CALLING SECTION OF CODE                          +
*+       EXIT CONDITIONS                                              +
*+  R1 = SCAN PTR TO @ DELIMITER FOLLOWING SCAN (IF REGISTER GOOD).   +
*+  RA = VALUE OF REGISTER IF GOOD, = SCAN PTR TO ERROR IF BAD.       +
*+  RC = VALUE OF REGISTER IF GOOD.                                   +
*+  + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
         SPACE 1
IDREGET  $CALL EVALUT              USE EXP EVAL (LOW PROB USAGE)
         LR    R1,RA               SAVE SCAN PTR
         LTR   RB,RB               WAS REGISTER OK
         BNZ   IDERROR             NO, BRANCH AND FLAG IT
         LTR   RD,RD               CHECK FOR ABSOLUTE VALUE, NOT RELOC
         BNZ   IDERELC             ^=0 ==> RELOCATABLE==> ERROR
         SPACE 1
IDREGCHK C     RC,AWF15            MAKE SURE REG NOT TOOT LARGE
         BH    IDREGBIG            NO,REGISTER TOO LARGE
         LR    RA,RC               PUT REGISTER WHERE DESIRED
         BR    RW                  RETURN TO CALLER,READY FOR DROP,USIN
         SPACE 1
**--> INSUB: IDEVAL     EVALUATE RELOCATABLE EXPRESSION + + + + + + + +
*+       ENTRY CONDITIONS                                             +
*+  RA = SCAN PTR TO 1ST CHARACTER OF EXPRESSION                      +
*+  RW = RETURN @ TO CALLING SECTION IN IDASM2                        +
*+       EXIT CONDITIONS                                              +
*+  RZ = SECTION ID OFTHE EXPRESSION  (SAME AS VALUE IN RD)           +
*+  RA = SCAN PTR @ TO DELIMITER IF GOOD, TO ERROR IF NOT.            +
*+  RC = VALUE OF THE EXPRESSION                                      +
*+  + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
IDEVAL   $CALL EVALUT
         LTR   RB,RB               WAS EXPRESSION OK
         BNZ   IDERROR             NO, ERROR
         LTR   RZ,RD               DUPLICATE ESDID, TEST FOR RELOCATBL
         BCR   NZ,RW               RETURN IF RELOCATABLE (RD ^= 0)
         B     IDERELOC            ERROR, NEED RELOCATABLE EXPRESSION
         SPACE 1
* * * * * INTERNAL CONSTANTS                                          *
* * * * * BRANCH OFFSET TABLE FOR INDIVIDUAL INSTRUCTIONS             *
IDAJUMP $AL2   IDASMJ,(IDUSING,IDDROP,IDSTART,IDCSECT,IDDSECT,IDENTRY,I#
               DEXTRN,IDEQU,IDDC,IDDS,IDCCW,IDTITLE,IDEJECT,IDSPACE,IDP#
               RINT,IDORG,IDLTORG,IDCNOP,IDEND),-2
         AIF   (&$DEBUG).IDNOD2    SKIP IF NOT DEBUG MODE
         DC    AL2(IDDEBUG-IDASMJ)           OFFSET TO DEBUG ROUTINE
.IDNOD2  ANOP
         LTORG
         DROP  RAT,R13,RC          KILL USINGS
         TITLE '*** INPUT1 - INPUT CARDIMAGE READER/PROCESSORS ***'
**--> CSECT: INPUT1   1   INPUT AND MANIPULATION OF SOURCE CARDS. . . .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
INPUT1   CSECT
         $DBG  90,*
         USING AVWXTABL,RAT        MAIN TABLE USING
         ENTRY INCARD
         SPACE 2
**--> ENTRY: INCARD       CALLED TO GET CARD AND CREATE RSBLOCK . . . .
*.       THIS ENTRY READS 1 STATEMENT (1-3 CARDS), AND SETS UP THE    .
*.       RECORD BLOCKS RSBLOCK, AND RSCBLK (IF CONTINUATIONS OR       .
*.       SEQUENCE NUMBERS ARE USED).  IT IS CALLED DURING PASS 1 OF   .
*.       THE ASSEMBLY.  IF AN ENDFILE INDICATION IS ENCOUNTERED, IT   .
*.       CREATES A PSEUDO ENDCARD, SINCE THE MAIN PROGRAM OF PASS 1   .
*.       MOCON1 ONLY STOPS AFTER AN END CARD IS FOUND.  AS OF 8/17/70,.
*.       INCARD IS THE ONLY ASSEMBLER ENTRY DOING CARD READING.       .
*.       IN SETTING UP THE RSBLOCK, INCARD CONCATENATES THE SECTIONS  .
*.       OF A CONTINUED STATEMENT, AND REMOVES BLANKS TO SOME DEGREE  .
*.       FROM THE TRAILING EDGE OF THE STATEMENT.  IT ALSO INSERTS    .
*.       THE 3 CHARACTERS BLANK,APOSTROPHE,BLANK AFTER THE LAST       .
*.       NONBLANK CHARACTER IN THE SOURCE STATEMENT.  THIS IS CRUCIAL .
*.       TO THE PROPER SCANNING OF THE SOURCE STATEMENT WITHOUT       .
*.       REQUIRING LENGTHS TO BE CARRIED FROM ROUTINE TO ROUTINE.     .
*.                                                                    .
*.             IF THE MACRO PROCESSOR EXISTS (&$MACROS=1), INCARD     .
*.       ALSO HANDLES RECOVERY OF GENERATED STMTS (CREATED BY MEXPND ..
*.       IN THE DYNAMIC-HIGH AREA).                                   .
*.             IF A MACRO LIBRARY FACILITY EXISTS (&$MACSLB=1),       .
*.       INCARD CAN BE SWITCHED TO READ FROM IT, INSTEAD OF $SORC.    .
*.       EXIT CONDITIONS                                              .
*.  RA = SCAN PTR TO ERROR, ONLY IF RB ^= 0.  NO MEANING IF RB = 0.   .
*.  RB = 0     NO ERRORS FOUND IN STATEMENT BY INCARD                 .
*.  RB = ERROR CODE (NONZERO) OF ERROR.  RA HAS SCAN PTR OF IT.       .
*.  AVSOLAST = @ BLANK IMMEDIATELY BEFORE ' IN THE 4-BYTE FIELDWHICH  .
*.       INCARD PLACES AFTER THE SOURCE STMT TO STOP SCANNING OVERRUN..
*.       USES DSECTS: AVWXTABL,RSBLOCK,RSCBLK,RSOURCE                 .
*.       USES MACROS: $RETURN,$SAVE,$SORC                             .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         SPACE 1
* * * * * REGISTER ALLOCATION FOR INCARD  * * * * * * * * * * * * * * *
*   R1 = NUMBER OF CARDS INCLUDED IN CURRENT RSBLOCK (FROM 1-3)       *
*   R2 = 0 (INITIALLY) - BYTE REGISTER FOR INSERTION                  *
*   RW = ADDRESS OF RSBLOCK BEING BUILT                               *
*   RX = ADDRESS OF RSCBLK BEING BUILT(IF ANY)                        *
*   RY = ADDRESS WHERE NEXT SOURCE SHOULD BE READ(RSOURCE)            *
*   RZ = CURRENT LENGTH-1 OF RSBLOCK BEING BUILT                      *
*   R14= INTERNAL LINK REGISTER (FOR INCRSMV).                        *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         EJECT
INCARD   $SAVE RGS=(R14-R6),SA=NO
         AIF   (&$DEBUG).INNZ      SKIP IF NOT DEBUGGIN MODE
         MVC   AVRSBLOC(256),AWTZTAB         ZERO OUT ***DEBUGGING ***
.INNZ    LA    R1,1                INIT # CARDS TO 1
         LM    RW,RX,AVRSBPT       VRSBPT,VRSCPT POINTERS
         USING RSBLOCK,RW          NOTE RSBLOCK USING SETUP
         USING RSCBLK,RX           NOTE RSCBLK USING SETUP
         LA    RY,RSBSOURC         INIT POINTER TO NEXT INPUT AREA
         USING RSOURCE,RY          NOTE CARDIMAGE USING
         LA    RZ,RSB$LN1          INIT LENGTH-1 OF RSBLOCK
         SR    R2,R2               CLEAR FOR ZERO VALUE
         ST    R2,RSBLENG          ZERO OUT WHOLE CODES SECTION
         SR    RB,RB               CLEAR INITIALLLY==> NO ERRORS
         TM    AVTAGS2,$INEND2     HAS THERE BEEN EOF, END CARD NEEDED
         BO    INCREOF             END CARD NEEDED-GO CREATE IT
         SPACE 1
         AIF   (NOT &$MACROS).INNOMA        SKIP IF NO MACROS
*              SEE IF EXPANDED STMTS EXIST. IF SO, PROCESS NEXT ONE.
         L     RC,AVGEN1CD         @ 1ST BYTE BEYOND NEXT GEN'D STMT
         C     RC,AVGEN2CD         CHECK AGAINST LOWER LIMIT
         BNH   INNOTGEN            SKIP IF THERE ARE NO MORE CARDS
         SPACE 1
         C     RC,AVADDHIH         MAKE SURE AVGEN1CD <= AVADDHIH
         BH    INMOVRGN            RAN OVER GENERATED CODE FROM TOP
         CLC   AVGEN2CD,AVADDLOW   CHECK FOR OVERRUN FROM BOTTO4
         BNH   INMOVRGN            YES IT DID (MORE LIKELY) - GO
         SPACE 1
*              MOVE NEXT EXPANDED STMT OVER TO RSBLOCK AREA.
         LA    RD,RSB$L            = LENGTH OF CONSTANT PART OF RSBLOCK
         SR    RC,RD               DECREMENT GEN PTR
         MVC   RSBLOCK(RSB$L),0(RC)         COPY CONSTANT PART
         IC    RZ,RSBLENG          GET L-1 OF GEN'D STMT
         STC   RZ,INMMOVE+1        PUT L-1 INTO MVC INSTR
         SR    RC,RZ               GET @ 2ND BYTE OF GEN'D STMT (L-1)
         SR    RC,R1               GET @ 1ST BYTE OF GEN'D STMT
INMMOVE  MVC   RSBSOURC($),0(RC)   MOVE WHOLE STMT OVER
         SPACE 1
*              IF THERE ARE ALREADY ERRORS IN THE STMT, MOVE THE
*              RESULTING REBLK OVER TO NORMAL LOCATION.
         TM    RSBFLAG,$REBX       DOES THE STMT HAVE ERRORS
         BZ    INMNOREB            NO, JUMP (NORMAL CASE)
         IC    R2,RSBNUM           GET REBLN FROM TEMPORARY LOCATION
         STC   R2,AVREBLN          STORE THE LENGTH-1 OF ERROR BLOCK
         SR    RC,R2               RC = @ OF REST OF REBLK (NOT REBLN)
         SR    R2,R1               GET L-1 OF PART OF REBLK LEFT
         STC   R2,*+5              PLACE L-1 INTO MVC INSTR
         MVC   AVREBES($),0(RC)    MOVE REST OF ERROR BLOCK OVER
         SPACE 1
INMNOREB ST    RC,AVGEN1CD         UPDATE PTR TO NEXT GEN'D STMT
         SPACE 1
*              STMT FROM MACRO PROCESSOR MAY HAVE 1-2 EXTRA BLANKS AT
*              END: REMOVE THEM SO DON'T CAUSE UNNECESSARY CONT CARDS.
         LA    RC,RSBSOURC-1(RZ)   @ NEXT TO LAST CHAR OF STMT
         CLI   1(RC),C' '          WAS LAST BYTE A BLANK
         BNE   INMOBLN             NO, SKIP, DON'T REMOVE
         CLI   0(RC),C' '          WAS NEXT TO LAST A BLANK
         BNE   *+6                 NO, REMOVE ONLY 1 - BRANCH
         SR    RZ,R1               YES, REMOVE 2 BLANKS FROM COUNT
         SR    RZ,R1               REMOVE OTHER BLANK
*              NOW CONSTRUCT RSCBLK, IF STMT REQUIRES IT BY BEING TOO *
*        LARGE TO FIT ON 1 CARD.  AT THIS PT, RZ = LENGTH-1 OF STMT.  *
*        (RZ) <=  70 ==> 1 CARD,  NO RSCBLK.                          *
*        (RZ) <= 126 ==> 2 CARDS, RSCBLK, 21 BYTES LONG               *
*              RSCLENG = 2*RSC$LEN; RSCILEN(1) = RSOL1;               *
*              RSCILEN(2) = (RC) - (RSOL1-1) .
*        (RZ) <= 182 ==> 3 CARDS, RSCBLK, 31 BYTES LONG.              *
*              RSCLEN = 3*RSC$LEN; RSCILEN(1) = RSOL1;
*              RSCILEN(2) = RSOLC; RSCILEN(3) = (RC) -(RSOL1-1)-RSOLC.
         SPACE 1
INMOBLN  LR    RC,RZ               GET L-1 TO BE DESTROYED
         AR    RZ,RD               GET L-1 OF ENTIRE RSBLOCK, AS NEEDED
         SPACE 1
         SH    RC,=AL2(RSOL1-1)    GET # BYTES IN GEN'D CARDS 2,3
         BNP   INCNORM             <=0, SO ONLY 1 CARD- BRANCH(NORMAL)
         TM    RSBFLAG,$RSBMERR    MACRO ERROR?                       J
         BO    INCNORM             YES, CAN'T BE CONTINUED ANYWAY     J
         SPACE 1
*              CONTINUATION CARDS NEEDED, LIKEWISE RSCBLK (MOAN).
         LA    RY,AWBLANK          FAKE BLANK CARDIMAGE FOR INCRSMV
         LA    RE,RSOLC            GET LENGTH OF CONTINUED CARDIMAGE
         AR    R1,R1               SET # CARDS SO FAR = 2 (AT LEAST)
         BAL   R14,INCRSMV1        HAVE 1ST SECTION OF RSCBLK SET UP
         MVI   RSCONSQ-RSCILEN(RD),C'X'      INDICATE CONTINUED CARD
         BAL   R14,INCMOV          MOVE SECOND CARD SEQNO/SET CODES
         SPACE 1
         CR    RC,RE               ARE THERE 2 CARDS OR 3
         BNH   INMCONT2            <= RSOLC ==> ONLY 2 CARDS TOTAL - GO
         SPACE 1
         SR    RC,RE               GET LENGTH OF 3RD CARD IMAGE
         MVI   RSCONSQ-RSCILEN(RD),C'X'   SHOW 2ND CARD CONINUED
         BAL   R14,INCMOV          SAVE 3RD AND LAST SECTION OF RSCBLK
         LA    R1,1(,R1)           SET  TOTAL # CARDS = 3.
*              IT IS ASSUMED THAT MEXPND NEVER CREATES STMTS HAVING   *
*              MORE THAN 193 (RSOL1+2*RSOLC) BYTES OF SOURCE DATA.    *
*              OTHERWISE, IT WOULD BE NECESSARY TO CHECK (RC) <= RSOLC*
INMCONT2 STC   RC,RSCILEN-RSCILEN(,RD)  SAVE LENGTH OF LAST PART <=56.
         B     INCNORM             ALL SET, NO GO PROCESS NORMALLY
         SPACE 1
INMOVRGN EQU   *                   COME HERE IF OVERRUN OCCURS
         MVC   AVGEN1CD,AVGEN2CD   COPY, SO THINKS NO MORE GEN'D STMTS
         MVC   0(80,RY),AWBLANK    FAKE A BLANK CARD
         OI    RSBFLAG,$RSBNPNN    DON'T PROCESS FURHTER
         LA    RB,$EROVRGN         FLAG ERROR: GEN'D STMTS OVERRUN
         B     INCHECK             SKIP OVER CARD READ AND GO ON
         EJECT
         SPACE 1
INNOTGEN EQU   *                   ENTERED IF NOT GENRTED STMT
.INNOMA  ANOP
         $SORC 0(RY),80,INCREOF    READ FIRST,HOPEFULLY ONLY,CARD
INCHECK  CLI   RSOCONT,C' '        CHECK FOR CONTINUATION CAHR
         BNE   INCCONT             CARD MUST BE CONTINUED-BRANCH
         CLC   RSOSEQN,AWBLANK     IS THERE SEQUENCE INFO
         BE    INCNORM             NO SEQNO-BRANCH NORMAL
INCHC    BAL   R14,INCRSMV         CALL CONTINUATION/SENO SAVER
         EJECT
*              ENTIRE STATEMENT READ-FINISH UP AND RETURN             *
INCNORM  STC   R1,RSBNUM           SAVE # CARDS(HOPEFULLY 1)
         LA    RE,RSBLOCK(RZ)      GET @ LAST ACTUAL SOURCE BYTE
*              FOLLOWING SECTION REMOVES BLANKS FROM END OF CARD.     *
         BCT   R1,INCBLC           SKIP BLANK-CRUNCH IF >1 CARD
*              REMOVE 36 BLANKS QUICKLY, IF POSSIBLE
         LH    R2,=H'-36'          GET VALUE TO BACK UP @ PTR
         AR    R2,RE               GET @ BEGINNING OF COMMENTS FIELD
         CLC   1(36,R2),AWBLANK    IS HALF OF CARD ALL BLANK
         BE    INCBL               YES,SO LEAVE R2 WHERE IT IS, BLANKS
         LR    R2,RE               WASN'T BLANK, DO WHOLE THING
INCBL    LA    R1,RSBSOURC+9       LIMIT @, INCLUDING POSSIBLE LABEL
         LH    R0,=H'-8'           DECREMENT: 8 BLANKS PER CHUNK
         BXLE  R2,R0,INCBLN        DECREMENT/TEST, SKIP IF TERHE ALREAD
         SPACE 1
         CLC   1(8,R2),AWBLANK     CHOP OFF 8 BLANKS IF POSSIBLE
         BNE   INCBLN              NOT BLANKS, TOO BAD, SKIP OUT
         BXH   R2,R0,*-10          LOOP UNTIL LIMIT REACHED
INCBLN   SR    R2,R0               SUBTRCT DECREMNT, PUT PTR BACK OK
         SPACE 1
         L     R0,AWFM1            GET NEW DECREMENT FOR 1 AT A TIME
         SPACE 1
*              LOOP TO REMOVE BLANKS FROM END OF STMT, 1 AT A TIME.   *
INCBLA   CLI   0(R2),C' '          IS THIS A BLANK
         BNE   INCBLB              NO IT ISNT, SO QUIT REMOVING-BRANCH
         BXH   R2,R0,INCBLA        LOOP UNTIL LIMIT @ REACHED
         SPACE 1
         SR    R2,R0               SUBTRCT -1,PUT POINTER BACK RIGHT
INCBLB   SR    R2,RE               GET # BLANKS REMOVED
         AR    RZ,R2               ADD DECREMENT TO LENGTH VALUE IN RZ
         AR    RE,R2               OBTAIN @ LAST BYTE(NEW)
         SPACE 1
*              CONCATENATE ENDING FIELD "  ' " TO SOURCE STMT TO      *
*              PREVENT SCANNING BEYOND END OF STMT. SAVE LIMIT @ IN   *
*              AVSOLAST, SAVE FINAL LENGTH-1 OF RSBLOCK. RETURN.      *
INCBLC   EQU   *                   FOR SKIP IF >1 CARD, NO CRUNCH
         MVC   1(4,RE),INCBQB      MOVE IN DELIMITER  VALUE
         LA    RC,2(RE)            GET @ OF BLANK BEFORE ENDING '
         ST    RC,AVSOLAST         STORE THIS FOR OTHER'S USE
         LA    RZ,2(RZ)            INCREMENT RZ BY 1 TO GET >=2BLANKS
         STC   RZ,RSBLENG          SAVE L-1 OF RSBLOCK
INCRET   $RETURN RGS=(R14-R6),SA=NO
         EJECT
*              FOLLOWING SECTION ENTERED FOR CONTINUATION CARD        *
INCCONT  BAL   R14,INCRSMV         HAVE CONTINUATION FIELD-SEQNO SAVED
         C     R1,AWF3             IS # OF CARDS<3(MAXIMUM)
         BNL   INCERR1             NO,WE HAVE TOO MANY CONTS(3 OR MORE)
         LA    RY,RSBLOCK+1(RZ)    GET NEXT ADDRESS TO BE INPUT
         $SORC 0(RY),80,INCREOFA   GET NEXT CARD
         CLC   RSOLOPC,AWBLANK     ARE 1ST 15 COLUMNS BLANK
         BE    INCCOK              BRANCH IF IT IS BLANK(OK)
         LR    RA,RY               ERROR-MOVE  ADDRESS OVER
         LA    RB,$ERCONT          ILLEGAL CONTINUATION-ERROR
         SPACE 1
INCCOK   MVC   RSOURCE(L'RSOOPRCM),RSOOPRCM  MOVE CARD IMAGE OVER
         LA    RZ,L'RSOOPRCM(RZ)   INCREMENT LENGTH-1 OD RSBLOCK
         LA    R1,1(R1)            INCRMENT NUMBER OF CARDS
         CLI   RSOCONT,C' '        IS CONTINUATION CARD CONINUED ALSO
         BE    INCHC               NO IT ISNT,HAVE LAST CONT/SEN SAVED
         B     INCCONT             CONINUED AGAIN-KEEP GOING
INCREOF  MVC   RSBSOURC(71),AWBLANK         BLANK OUT SOURCE AREA
         SPACE 1
         MVC   RSBSOURC+9(3),=C'END'        MAKE UP END CARD
         LA    RA,RSBSOURC+10      SET PTR TO END FOR WARNING
         LA    RB,$ERNOEND         WARNING-MESSAGE CODE-NO END CARD
INCREOFA OI    AVTAGS2,$INEND2     EOF==> CREATE END CARD NEXT TIME
         B     INCNORM             GO SET FLAGS AND RETURN
INCERR1  LA    RB,$ERCONTX         TOO MANY CONTINUATIONS(>2)
         LA    RA,RSOCONT-1        GET THE POINTER
         LA    R14,INCNORM         SET RETURN ADDR OF INCRSMV
*              FALL THRU INTO INCRSMV (WHICH MUST FOLLOW).
         SPACE 1
**--> INSUB: INCRSMV    SAVE CON/SEQNO INTO RSCBLK  + + + + + + + + + +
*+       ENTRY CONDITIONS                                             +
*+  RY = @ CARDIMAGE FROM WHICH CON/SEQNO TAKEN (RSOURCE DSECT)       +
*+       EXIT CONDITIONS                                              +
*+  RD = @ VARIABLE PART OF RSCBLK JUST CREATED (I.E. NEWEST RSCILEN) +
*+  R14= RETURN @ TO CALLING SECTION OF CODE IN INCARD.               +
*+  R2   IS DESTROYED.                                                +
*++ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
         SPACE 1
INCRSMV  TM    RSBFLAG,$RSCX       HAVE THERE BEEN PREVIOUS CONT/SEQS
         BO    INCMOV              YES THERE HAVE,BRANCH
INCRSMV1 OI    RSBFLAG,$RSCX       SHOW 1ST ONE - RSC EXISTS
         MVI   RSCLENG,0           ZERO OUT LENGTH AT FIRST
         MVI   RSCILEN,RSOCONT-RSOURCE      LENGTH FOR 1ST CRD(71)
INCMOV   IC    R2,RSCLENG          GET CURRENT L-1 OF BYTES
         LA    RD,RSCILEN(R2)      GET ADDR OF NEXT SLOT
         LTR   R2,R2               WAS THIS 1ST CARD
         BZ    *+8                 SKIP MVI IF IT WAS 1ST
         MVI   0(RD),L'RSOOPRCM    MOVE IN LENGTH FOR CONT CARD (56,
         MVC   RSCONSQ-RSCILEN(9,RD),RSOCONT MOVE CONT/SEQ OVER
         LA    R2,RSC$LEN(R2)      INCREMENT LENGTH-1
         STC   R2,RSCLENG          UPDATE LENGTH-1
         BR    R14                 RETURN TO CALLING SECTION
         SPACE 1
* * * * * INTERNAL CONSTANTS                                          *
INCBQB   DC    C'  '' '            DELIMITER FIELD FOR END OF SOURCE
         LTORG
         DROP  RAT,REP,RW,RX,RY    REMOVE ALL USINGS
         TITLE '*** LTOPRS - LITERAL OPERATIONS ***'
**--> CSECT: LTOPRS   1-2 ALL LITERAL TABLE OPERATIONS. . . . . . . . .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
LTOPRS   CSECT
         $DBG  A0,*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              NOTE RESTRICTION - A-TYPE ADCONS IN LITERALS MAY NOT   *
*              MAKE REFERENCES TO THE LOCATION COUNTER.   A WARNING   *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         USING AVWXTABL,RAT        NOTE MAIN TABLE USING
         ENTRY LTINT1,LTENT1,LTDMP1,LTEND1,LTGET2,LTDMP2
         SPACE 2
**--> ENTRY: LTINT1   1   INITIALIZE LITERAL TABLE IF NEEDED. . . . . .
*.  ALLOCATES AND ZEROS 1ST LITERAL POOL BASE TABLE. INITS 1ST AND    *
*.  CURRENT BLOCK POINTERS TO 1ST LTBASETB.                           *
*.       CALLS MOSTOP                                                 .
*.       USES DSECTS: AVWXTABL,LTBASETB                               .
*.       USES MACROS: $ALLOCH,$RETURN,$SAVE                           .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
LTINT1   $SAVE SA=NO
         LA    RB,LTB$LEN          GET LENGTH OF 1 LTBASETB ENTRY
         $ALLOCH RA,RB,LTZOVER     GET NEEDED SPACE
         LR    RB,RA               DUPLICATE THIS VALUE
         STM   RA,RB,LTBFIRST      LTBFIRST-LTBNOW - SET POINTERS
         USING LTBASETB,RA         NOTE USING
         MVC   LTBASETB(LTB$LEN),AWZEROS     ZERO OUT THE TABLE
         DROP  RA                  CLEAN UP USING
         $RETURN SA=NO
         EJECT
**--> ENTRY: LTENT1   1   ENTER A LITERAL INTO THE TABLE. . . . . . . .
*.       THIS ENTRY IS CALLED DURING PASS 1 TO SCAN A LITERAL BY      .
*.       IAMOP1.  THE LITERAL IS SCANNED BY CODTL1, AND IT IS ENTERED .
*.       IF IT IS NOT ALREADY PRESENT.  NOTE THAT NO DUPLICATES       .
*.       ARE EVER KEPT IN THE SAME POOL, EVEN FOR A-TYPE CONSTANTS    .
*.       WITH LOCATION COUNTER REFERENCES.                            .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER (ADDRESS OF = IN LITERAL)                       .
*.       EXIT CONDITIONS                                              .
*.  RA = SCAN POINTER (ADDRESS OF ERROR OR DELIMETER)                 .
*.  RB = 0 IF LITERAL LEGAL, ERROR CODE OTHER WISE                    .
*.  RC = ADDRESS OF LITERAL TABLE ENTRY                               .
*.       CALLS CODTL1,MOSTOP                                          .
*.       USES DSECTS: AVWXTABL,CNCBLOCK,LTBASETB,LTLENTRY,RSBLOCK     .
*.       USES MACROS: $ALLOCH,$CALL,$RETURN,$SAVE,$SCPT               .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         SPACE 1
* * * * * REGISTER ALLOCATION FOR LTENT1  * * * * * * * * * * * * * * *
*   R1 = #-1 OF CHARACTERS IN THE LITERAL BEING PROCESSED             *
*   R2 = # OF CHARACTERS IN LITERAL,ROUNDED TO FULLWORD, THEN -1      *
*   RW = BASE REGISTER                                                *
*   RX = INITIAL SCAN POINTER TO = OF LITERAL                         *
*   RC = @ CNCBLOCK PROVIDED BY CODTL1                                *
*   RD = TOTAL LENGTH OF NEW LTENTRY BLOCK                            *
*   RE = @ LTENTRY BLOCK FOR A NEW LITERAL                            *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
LTENT1   $SAVE RGS=(R14-R6),SA=LTOPSAVE,BR=R3
         SPACE 1
*              INITIALIZES, CALL 1ST-PASS CONSTANT PROCESSOR.
         LR    RX,RA               SAVE SCAN POINTER
         LA    RA,1(RA)            INCREMENT POINTER PAST =
         LA    RB,8                SHOW CODTL1 WE ARE IN LITERAL
         $CALL CODTL1              CALL DUPLFAC-TYPE-LENGTH PROCESSOR
         LTR   RB,RB               WAS THERE AN ERROR
         BNZ   LTE1RET             IF SO,RETURN SHOWING ERROR
         SPACE 1
*              CHECK TO MAKE SURE NO MISSING DELIMITER.
         C     RA,AVSOLAST         COMPARE TO @ BLANK BEFORE '
         BNL   LTE1ERR3            MISSING QUOTE ON C-CON-ERROR
         USING CNCBLOCK,RC         CODTL1 HAS SET UP A CNCBLOCK
         SPACE 1
*              SET UP FOR LOOKING FOR A DUPLICATE LITERAL             *
         LR    R1,RA               MOVE NEW SCAN POINTER OVER
         SR    R1,RX               GET LENGTH OF LITERAL-# OF CHARS
         LA    R15,112             GET LENGTH FOR COMPARISON
         CR    R1,R15              MAKE SURE NO MORE THAN 2 CARDS
         BH    LTE1ERR4            BRANCH IF TOO LONG
         BCTR  R1,0                GET # CHARS - 1 IN LITERAL
         BCTR  RE,0                GET TOTAL LENGTH-1 OF LITERAL DC
         N     RE,AWF7             REMOVE ALL BUT LAST 3 BITS OF LENGTH
         IC    R15,LTEB1248(RE)    GET THE OFFSET TO POINTER -LTBASETB
         L     R14,LTBNOW          GET @ CURRENT LTBASETB
         USING LTBASETB,R14        NOTE TABLE USING
         LA    RE,LTBCH1(R15)      GET @ ACTUAL POINTER -LTBCH1-2-4-8
         DROP  R14                 NO LONGER NEEDED
         USING LTLENTRY,RE         WILL POINT AT 1ST ENTRY,IF ^=0
         STC   R1,LTE1CLI+1        SAVE #-1 OF CHARS INTO CLI
         STC   R1,LTE1CLC+1        SAVE #-1 OF CHARS INTO CLC ALSO
         BAL   R15,LTE1L           BEGIN SEARCH,SETTING REG FOR BCR TOO
         SPACE 1
*              SEARCH FOR LITERAL IN CHAIN OF RIGHT LENGTH.           *
LTE1CLI  CLI   LTLCHARS,$CHN       CHECK 1ST FOR SAME # OF CHARS
         BNE   LTE1L               IF NOT,LOOP TO NEXT ON CHAIN
LTE1CLC  CLC   LTLITRAL($CHN),0(RX)          IS LITERAL THE SAME
         BE    LTE1OLD             BRANCH OUT IF SAME LITERAL
         SPACE 1
LTE1L    LR    RD,RE               SAVE @ OLD LTLENTRY
         L     RE,LTLINK           GET @ NEXT LTLENTRY FROM OLD ONE
         LA    RE,0(RE)            REMOVE 1ST BYTE
         LTR   RE,RE               IS THE LINK = 0
         BCR   NZ,R15              BNZ LTE1CLI - GO BACK FOR NEXT TEST
         SPACE 1
*              FALL THRU==> THIS IS A NEW LITERAL-GET SPACE&ENTER IT  *
         LA    R14,LTL$LEN+4(R1)   GET TOTAL LENGTH,ROUNDED OVER FULL
         O     R14,AWF3            MAKE LAST 2 BITS 1'S
         S     R14,AWF3            ALIGN TO FULLWORD AMOINT
         $ALLOCH RE,R14,LTZOVER    GET SPACE FOR NEW ENTRY
         STC   R1,*+5              PUT LENGTH-1 INTO MVC
         MVC   LTLITRAL($CHN),0(RX)          MOVE LITERAL OVER
         LR    R15,RE              MOVE POINTER OVER
         AL    R15,0(RD)           ADD LTLCHARS OF PREVIOUS ENTRY
         ST    R15,0(RD)           STORE LTLCHARS-LTLINKA BACK
         MVC   LTLTYP(CNC$LEN),CNCBLOCK      MOVE ALL THE CODES OVER
         DROP  RC                  HAVE GOTTEN CODES,NO MORE USING
         SLL   R1,24               SHIFT LENGTH-1 FOR POSITION TO STORE
         ST    R1,LTLINK           STORE LTLCHARS FIELD, WITH 0 LTLINKA
         $SCPT R15,LTLSCAN         GET SCAN POINTER ADDRESS
         SR    R15,RX              GET OFFSET FROM = SIGN
         STC   R15,LTLSCAN         SAVE THIS SCAN POINTER INSTEAD
LTE1OLD  LR    RC,RE               MOVE @ LITERAL ENTRY FOR RETURN
LTE1RET  $RETURN RGS=(R14-R6)
         SPACE 1
*              INDIVIDUAL ERROR EXITS.                                *
LTE1ERR3 LA    RB,$ERNODLM         MISSING DELIMITER
         B     LTE1RET             RETURN
LTE1ERR4 LA    RB,$ERCNLNG         CONSTANT TOO LONG FOR LITERAL
         B     LTE1RET             GO RETURN
         EJECT
**--> ENTRY: LTDMP1   1   DUMP LITERALS ON FINDING LTORG AND END. . . .
*.       LTDMP1 IS CALLED BY IBASM1 TO FIND LENGTH OF THE CURRENT     .
*.       LITERRAL POOL, AND AVANCE THE CURRENT POOL PTR TO THE NEXT 1..
*.       EXIT CONDITIONS                                              .
*.  RA = TOTAL LENGTH REQUIRED FOR THE LITERAL BLOCK                  .
*.       CALLS MOSTOP                                                 .
*.       USES DSECTS: AVWXTABL,LTBASETB,LTLENTRY                      .
*.       USES MACROS: $ALIGN,$ALLOCH,$CALL,$GLOC,$RETURN,$SAVE        .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
LTDMP1   $SAVE RGS=(R14-R0),SA=NO
         SPACE 1
*              INITIALIZE PROCESSING FOR 1 LITERAL POOL.
         SR    RA,RA               CLEAR TOTAL LENGTH
         L     RB,LTBNOW           GET POINTER TO CURRENT LTBASETB
         USING LTBASETB,RB         TELL ASSEMBLER
         $GLOC RE                  GET LOCATION COUNTER
         $ALIGN RE,7,*             ALIGN TO DOUBLEWORD
         ST    RE,LTBVALUE         SAVE THIS VALUE IN LTBLOCK
         LA    RC,4                # OF LITERAL CHAINS - LTBCH1-2-4-8
         LA    RD,LTBCH8           @ FIRST CHAING POINTER TO BE DONE
         SPACE 1
*              OUTSIDE LOOP - GET NEXT CHAIN OF LITERALS - 8-4-2-1.
LTD1L    L     RE,0(RD)            GET NEXT POINTER FORM LTBCH1-2-4-8
         USING LTLENTRY,RE         NOTE ENTRY POINTER(@ SET LOWER DOWN)
         A     RD,AWFM4            SUBTRACT 4 TO GET NEXT ONE NEXT TIME
         BAL   R14,LTD1LTR         GO TEST LINK PTR,ALSO SETING R14
         SPACE 1
*              LOOP ALONG LITERAL CHAINS,ADDING LENGTHS,GETTING OFSETS*
LTD1E    STH   RA,LTLOFSET         SAVE OFFSET OF LITERAL
         AH    RA,LTLTOT           ADD THE TOTAL LENGTH OF LITERAL IN
         AIF   (&$DEBUG).LTXS1     SKIP IF PRODUCTION
         XSNAP STORAGE=(*LTLENTRY,*LTLITRAL),IF=(AVDEBUG,O,X'84',TM)
.LTXS1   ANOP
         L     RE,LTLINK           GET @ NEXT LITERAL ON CHAIN
         LA    RE,0(RE)            REMOVE FIRST BYTE(LTLCHARS)
LTD1LTR  LTR   RE,RE               IS POINTER 0. IF SO==> LAST ON CHAIN
         BCR   NZ,R14              BNZ LTD1E - KEEP GOING IF MORE
         SPACE 1
         BCT   RC,LTD1L            LOOP TO GET ALL LITERALS - 8-4-2-1
         DROP  RE                  NO LONGER NEEDED
         SPACE 1
         LA    RD,LTB$LEN          GET LENGTH FOR NEXT LTBASETB
         $ALLOCH RE,RD,LTZOVER     GET THE SPACE
         ST    RE,LTBLINK          SAVE POINTER TO NEW LTBASETB IN OLD
         MVC   LTBESDID,AVCESDID   MOVE CURRENT ESDID OVER
         DROP  RB                  NO MORE REFS TO OLD LTBASETB
         USING LTBASETB,RE         USING FOR JUST CREATED LTBASETB
         MVC   LTBASETB(LTB$LEN),AWZEROS     ZERO IT OUT
         ST    RE,LTBNOW           SAVE NEW POINTER
LTD1RET  $RETURN RGS=(R14-R0),SA=NO
         DROP  RE                  NO LONGER USING
         EJECT
* * * * * LTZOVER IS ENTERED IF STORAGE OVERFLOW OCCURS, PASS 1       *
LTZOVER  $GTAD REP,MOSTOP          GET ADDR OF OVERFLOW ERROR EXIT
         BR    REP                 GO THERE, WILL EVENTAULLY PRINT 999
         SPACE 1
**--> ENTRY: LTEND1   1   CLEANUP AFTER PHASE 1 PREPARE FOR PHASE 2 . .
*.       THIS ENTRY SETS UP FOR ASSEMBLER PASS 2 LITERAL PROCESSING.  .
*.       USES MACROS: $RETURN,$SAVE                                   .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
LTEND1   $SAVE SA=NO
         MVC   LTBNOW,LTBFIRST     RESET ORIG POINTER TO CURRENT ONE
         $RETURN SA=NO
         SPACE 2
**--> ENTRY: LTGET2   2   GET ADDRESS OF LITERAL IN ASSEMBLY. . . . . .
*.       LTGET2 IS CALLED BY ICMOP2 EACH TIME A LITERAL IS FOUND IN   .
*.       SCANNING MACHINE INST OPERANDS DURING PASS 2. IT RETURNS THE .
*.       ATTRIBUTES OF THE LITERAL, INCLUDING THE USER PROGRAM @ FOR  .
*.       THE LITERAL, THE SECTION ID OF THE LITERAL, AND THE LENGTH   .
*.       ATTRIBUTE OF THE LITERAL. ICMOP2 SUPPLIES A POINTER TO THE   .
*.       LTLENTRY OF THE LITERAL, WHICH HAD BEEN SAVED IN THE         .
*.       STATEMENT'S RCODBLK .                                        .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER TO 1ST CHAR OF LITERAL =                        .
*.  RC = @ LITERAL TABLE ENTRY IN LITERAL TABLE(WAS SAVED IN RCB)     .
*.       EXIT CONDITIONS                                              .
*.  RA = SCAN POINTER TO CHARACTER AFTER LITERAL                      .
*.  RB = ESDID OF CSECT IN WHICH LITERAL EXISTS                       .
*.  RC = ADDRESS OF LITERAL (PROGRAM ADDRESS-FOR LISTING,ETC)         .
*.  RD = IMPLIED LENGTH-1 OF THE LITERAL(LOW ORDER BYTE, OTHERS INDTR).
*.       USES DSECTS: AVWXTABL,LTBASETB,LTLENTRY                      .
*.       USES MACROS: $RETURN,$SAVE                                   .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         USING LTLENTRY,RC         NOTE USING,ON ENTRANCE
LTGET2   $SAVE SA=NO
         L     RE,LTBNOW           GET POINTER TO CURRENT LTBASETB
         USING LTBASETB,RE         NOTE THE USING HERE
         SR    RB,RB               CLEAR FOR INSERT OF ESDID
         IC    RB,LTLCHARS         GET LENGTH-1 OF LITERAL STRING
         LA    RA,1(RA,RB)         BUMP SCAN POINTER PAST LITERAL
         IC    RB,LTBESDID         GET THE ESDID OF LITERAL POOL
         AIF   (&$DEBUG).LTXS2     SKIP IF PRODUCTION
         XSNAP STORAGE=(*LTLENTRY,*LTLITRAL),IF=(AVDEBUG,O,X'84',TM)
.LTXS2   ANOP
         IC    RD,LTLLEN           GET LENGTH-1 BEFORE RC ERASED
         LH    RC,LTLOFSET         GET OFFSET FROM LITERAL POOL BASE
         A     RC,LTBVALUE         GET ACTUAL ADDRESS
LTG2RET $RETURN SA=NO
         DROP  RC,RE               REMOVE THE USINGS
         EJECT
**--> ENTRY: LTDMP2   2   DUMP LITERALS IN PASS 2 . . . . . . . . . . .
*.       LTDMP2 IS CALLED BY IDASM2 DURING PASS 2, WHENEVER A LTORG   .
*.       OR END STMT IS FOUND, TO PRODUCE THE OBJECT CODE AND LISTING .
*.       OF ANY LITERALS IN THE CURRENT LITERAL POOL.  THE CURRENT    .
*.       POOL BASE POINTER IS ADVANCED TO THE NEXT LTBASETB.          .
*.       CALLS CNDTL2                                                 .
*.       USES DSECTS: AVWXTABL,LTBASETB,LTLENTRY                      .
*.       USES MACROS: $CALL,$GLOC,$RETURN,$SAVE,$SLOC                 .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
LTDMP2   $SAVE RGS=(R14-R6),SA=LTOPSAVE,BR=R13
         SPACE 1
* * * * * REGISTER ALLOCATION AND USAGE FOR LTDMP2  * * * * * * * * * *
*   R1 = @ CURRENT LTBASETB BEING PROCESSED. 1 IS DONE FOR EACH CALL. *
*   R2 = BYTE REGISTER FOR INSERTIONS.                                *
*   RW = @ LOOP HEAD FOR 1 LINK OF 1 LITERAL CHAIN.                   *
*   RX = @ CURRENT LTLENTRY BLOCK BEING PROCESSED.                    *
*   RY = -4   FOR BXH INDEX AND LIMIT VALUE.                          *
*   RZ = OFFSET(0-4-8-12) TO LTBCH# POINTER OF LENGTH BEGIN DONE      *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
*              INITIALIZATION - SET UP FAKE RECORD PTRS,ETC.          *
         LA    RA,LTRCODBL         GET @ FAKE RCODBLK SET UP
         ST    RA,AVRCBPT          SAVE THIS ADDRESS
         LA    RA,LTRSBLOC         GET @ FAKE RSBLOCK
         LA    RB,LTRSCBLK         GET @ FAKE RSCBLOCK
         STM   RA,RB,AVRSBPT       STORE PTRS IN AVRSBPT-AVRSCPT
         $GLOC R0                  GET LOCATION COUNTER
         L     R1,LTBNOW           GET @ NEXT LTBASETB
         USING LTBASETB,R1         NOTE THE POINTER
         SR    R2,R2               BYTE REGISTER-CLEAR FOR INSERTS
         L     RY,AWFM4            GET -4 FOR BXH'ING
         LA    RZ,LTBCH8-LTBCH1    GET OFFSET FROM LTBCH1-DO LENGTH 8
         EJECT
*              PROCESS CHAINS OF LITERALS, IN ORDER OF LENGTH 8-4-2-1.*
*              LTD2LRX ENTERD 4 TIMES,1 FOR EACH CHAIN OF LITERALS.   *
LTD2LRX  L     RX,LTBCH1(RZ)       GET NEXT POINTER FROM LTBASETB
         USING LTLENTRY,RX         NOTE POINTER
         BAL   RW,LTD2LTR          GO CHECK FOR LITERALS OF THIS LENGTH
         SPACE 1
*              FOLLOWING CODE EXECUTED 1 TIME FOR EACH LITERAL IN POOL*
*              PLACE LITERAL FOR PASS 2 SCAN AND PRINTING.            *
LTD2LTL  IC    R2,LTLSCAN          GET SCAN POINTER OFFSET FROM = TO CN
         LA    R2,LTRSBOPR-LTRSBLOC(R2)      GET CORRECT OFFSET
         STC   R2,LTLSCAN          SAVE WHERE CNDTL2 WILL EXPECT IT
         IC    R2,LTLCHARS         GET #-1 OF CHARS IN LITERAL
         MVC   LTRSBLOC(3),LTRSBCO1          GET CODES FOR 1 CARD LITER
         CLI   LTLCHARS,55         ARE THERETOO MANY CHARS FOR 1 CARD
         BNH   *+10                SKIP IF ONLY 1 CARD NEEDED
         MVC   LTRSBLOC(3),LTRSBCO2          GET CODES FOR 2 CARDS
         SPACE 1
         STC   R2,*+5              STORE LENGTH-1 INTO MVC
         MVC   LTRSBOPR($CHN),LTLITRAL       MOVE LITERAL FROM TABLE
         $SLOC R0                  SET LOCATION COUNTER
         MVC   LTRCLOC,AVLOCNTR+1  MOVE LOCATION COUNTER INTO FK RCB
         AH    R0,LTLTOT           ADD TOTAL LENGTH OF LITERAL TO LOC
         SPACE 1
         LA    RB,1                SHOW CNDTL2 WE HAVE 1 OPERAND
         LA    RC,LTLTYP           GET @ CNCBLOCK PART OF LTLENTRY
         $CALL CNDTL2              HAVE CONSTANT PROCESSED,PRINTED
         STC   R2,*+5              SAVE LENGTH-1 INTP BLANKING MVC
         MVC   LTRSBOPR($CHN),AWBLANK+15+RSB$L         BLANK,KEEPING BD
         L     RX,LTLINK           GET @ NEXT LTLENTRY ON CHAIN
         LA    RX,0(RX)            REMOVE 1ST BYTE IF ANY
         SPACE 1
*              CONTINUE LOOPING UNTIL LAST LITERAL FOUND ON CHAIN.    *
*              THEN DECREMENT TO NEXT CHAIN BEGINNING AND PROCESS IT. *
LTD2LTR  LTR   RX,RX               WAS THIS LAST ONE ON CHAIN
         BCR   NZ,RW               BNZ LTD2LTL - GO BACK FOR NEXT
         BXH   RZ,RY,LTD2LRX       DONE WITH 1 CHAIN,GO ON TO NEXT
         SPACE 1
         MVC   LTBNOW,LTBLINK      MOVE POINTER TO NEXT LTBASETB OVER
LTD2RET  $RETURN RGS=(R14-R6)      RETURN TO CALLER
         DROP  R1,RX               KILL USINGS
         EJECT
* * * * * INTERNAL CONSTANTS                                          *
LTEB1248 DC    X'000400080004000C' OFFSETS TO LTBCH1-2-4-8 FOR LENGTHS
LTRSBCO1 DC    AL1(RSB$LN1,$RCBX,1)          CODES FOR FAKE RSBLOCK-1CD
LTRSBCO2 DC    AL1(RSB$LN1+56,$RCBX+$RSCX,2) CODES FOR RSBLOCK-2 CARDS
         SPACE 1
*              FAKE RSCBLK, USED IF MORE THAN 1 CARD REQUIRED FOR LIT.*
LTRSCBLK DC    AL1(1+2*RSC$LEN,71) RSCLEN,1ST RSCILEN FOR CONT/SEQ
         DC    CL9'X'              CONTINUATION FLAG,SEQNO
         DC    AL1(56)             LENGTH OF 2ND CARD IMAGE
         DC    CL9' '              SEQNO OF 2ND CARD IMAGE
         SPACE 1
* * * * * INTERNAL VARIABLES                                          *
LTBFIRST DS    A                   @ FIRST LTBASETB IN EXISTENCE
LTBNOW   DS    A                   @ CURRENT LTBASETB BEING PROCESSED
         SPACE 1
*              FAKE RCODBLK-RCLOC WILL BE USED AS LOCATION COUNTER.   *
LTRCODBL DS    0F                  LINE UP ON RIGHT BOUNDARY
         DC    X'7'                RCLENG - LENGTH-1 OF BLOCK
LTRCLOC  DS    AL3                 LOCATION COUNTER WILL BE PLACE HERE
         DC    F'0'                FILL OUT BLOCK
         SPACE 1
*              FAKE RSBLOCK - WILL BE USED TO ASSEMBLE AND PRINT.     *
LTRSBLOC DS    0D                  LINE UP
         DS    CL4                 RSBLEN-RSBFLAG,RSBNUM,RSBSCAN BYTES
LTRSBSOU DC    CL15' '             15 BLANKS IN FRONT OF =
LTRSBOPR DC    CL56' '             OPERAND FIELD, IF ONLY 1 CARD USED
         DC    CL56' '             CONTINUATION OF OPERAND FIELD
         EJECT
**--> DSECT: LTBASETB   LITERAL POOL BASE TABLE - 1 FOR EACH POOL . . .
*.       ONE LTBASETB IS CREATED FOR EACH LITERAL POOL, BY LTINT1 OR  .
*.       LTDMP1.  THE TOTAL # CREATED = # LTORGS + 2, WHICH INCLUDES  .
*.       1 FOR THE END STMT, AND 1 EXTRA 1 FOR CODE SIMPLIFICATION.   .
*.       WHEN LTDMP1 IS CALLED, IT FILLS IN THE SECTION ID OF THE     .
*.       SECTION WHERE THE POOL WILL BE ASSEMBLED, THE BEGINNING @ OF .
*.       THE POOL, AND THE OFFSET @ VALUES FROM THE BEGINNING @ TO    .
*.       EACH LITERAL IN THE POOL.  IN ADDITION TO ADDRESS AND SECTION.
*.       ID, THE LTBASETB ALSO CONTAINS THE LIST HEADS FOR 4 LISTS    .
*.       OF LITERAL ENTRIES (LTLENTRY BLOCKS). USED ONLY IN LTOPRS.   .
*.       LOCATION: HIGH END OF DYNAMIC AREA ($ALLOCH MACRO).          .
*.       NAMES: LTB-----                                              .
*.  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         SPACE 1
LTBASETB DSECT
LTBLINK  DS    0F                  ADDRESS OF NEXT LTB, =0 IF LAS
LTBESDID DS    C                   ESDID OF CSECT IN WHICH OCCURS
LTBLINKA DS    AL3                 ACTUAL LINKA ADDRESS
LTBVALUE DS    F                   ADDRESS OF LTORG OR END,D BOUNDARY
LTBCH1   DS    A                   ADDRESS OF 1ST LTENRY FOR LENGTH 1
LTBCH2   DS    A                   ADDRESS OF 1ST ENTRY FOR LENGTH 2
LTBCH4   DS    A                   ADDRESS OF 1ST ENTRY FOR LENGTH 4
LTBCH8   DS    A                   ADDRESS OF 1ST ENTRY FOR LENGTH 8
LTB$LEN  EQU   *-LTBASETB          LENGTH OF 1 LITERAL BASE TABLE
         EJECT
**--> DSECT: LTLENTRY   LITERAL TABLE ENTRY FOR EACH LITERAL. . . . . .
*.       1 LTLENTRY BLOCK IS CREATED BY LTENT1 FOR EACH UNIQUE        .
*.       LITERAL IN A GIVEN LITERAL POOL.  THE LTLENTRY BLOCKS ARE    .
*.       ORGANIZED IN 4 LINKED LISTS, WITH LIST HEADS IN THE CURRENT  .
*.       LTBASETB BLOCK.  EACH LTLENTRY INCLUDES THE OFFSET FROM THE  .
*.       BEGINNING OF THE CURRENT LITERAL POOL @ (ENTERED BY LTDMP1), .
*.       A COMPLETE CNCBLOCK DESCRIBING THE LITERAL CONSTANT, AND THE .
*.       CONSTANT IN CHARACTER FORM.  LTGET2 USES THESE BLOCKS TO     .
*.       DETERMINE THE USER PROGRAM ADDRESS FOR ANY DESIRED LITERAL,  .
*.       AND LTDMP2 USES THEM TO PRINT LITERAL POOL LISTING AND       .
*.       HAVE THE CODE ASSEMBLED FOR THE POOL.   USED ONLY IN LTOPRS. .
*.       LOCATION: HIGH END OF DYNAMIC AREA ($ALLOCH MACRO).          .
*.       NAMES: LTL-----                                              .
*.  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         SPACE 1
LTLENTRY DSECT
LTLINK   DS    0F                  ADDRESS OF NEXT ENTRY ON CHAIN
LTLCHARS DS    C                   #-1 OF CHARACTERS IN LITERAL
LTLINKA  DS    AL3                 ACTUAL POINTER TO NEXT LTLENTRY
LTLOFSET DS    H                   OFFSET OF THIS LITERAL FROM BASE
         SPACE 1
*              FOLLOWING SECTION (INCLD LTLTOT) = 1 CNCBLOCK DSECT.
LTLTYP   DS    C                   CONSTANT TYPE+ FLAGS
LTLLEN   DS    C                   LENGTH-1 OF OPERAND
LTLSCAN  DS    C                   SCAN POINTER TO 1ST CONSTANT
LTLNUM   DS    C                   NUMBER OF CONSTANTS IN OPERAND
LTLDUP   DS    H                   DUPLICATION FACTOR
LTLTOT   DS    H                   TOTAL LENGTH OF OPERAND
LTL$LEN  EQU   *-LTLENTRY          LENGTH OF CONSTANT SECTION
LTLITRAL DS    C                   LITERAL, LENGTH ROUNDED UP TO F
         DROP  RAT,R13             KILL USINGS
         TITLE '*** MOCON1 - MAIN CONTROL - ASSEMBLER PASS ONE ***'
**--> CSECT: MOCON1   1   MAIN CONTROL - ASSEMBLER PASS 1 . . . . . . .
*.       MOCON1 PROVIDES OVERALL CONTROL FOR PASS 1 OF THE ASSIST     .
*.       ASSEMBLER, AND SUPERVISES OR PERFORMS THE FOLLOWING:         .
*.        1. READING INPUT CARDS, CREATING RECORD BLOCKS (INCARD).    .
*.        2. SCANNING LABELS, ENTERING THEM IN SYMBOL TABLE(SYENT1).  .
*.        3. SCANNING CARD FOR THE OPCODE, IF ANY.                    .
*.        4. FINDING OPCODE IN OPCODE TABLE (OPFIND).                 .
*.        5. SCANNING FOR OPERAND FIELD, SAVING SCAN POINTER.         .
*.        6. 2ND LEVEL INSTRUCTION PROCESSING (IAMOP1,IBASM1).        .
*.        7. DEFINING ATTRIBUTES, VALUE OF LABEL, IF REQUIRED.        .
*.        8. UPDATING LOCATION COUNTER TO NEXT LOCATION.              .
*.        9. STORING RECORD BLOCKS FOR STMT (UTPUT1).                 .
*.                                                                    .
*.       NOTE: PRINT CONTROL/COMMENTS STMTS ARE PROCESSED COMPLETELY  .
*.       DURING PASS 1 AND NOT SAVED, IF POSSIBLE.                    .
*.                                                                    .
*.       CALLS ERRLAB,ERRTAG,IAMOP1,IBASM1,INCARD,OPFIND,SYENT1,UTPUT1.
*.       CALLS OUTPT2                                                 .
*.       USES DSECTS: AVWXTABL,OPCODTB,RCODBLK,RSBLOCK                .
*.       USES MACROS: $CALL,$GLOC,$GTAD,$PRNT,$RETURN,$SAVE           .
*.       USES MACROS: $SCOF,$SDEF,$SLOC                               .
*.       CALLS ERRLAB,ERRTAG,IAMOP1,IBASM1,INCARD,OPFIND,SYENT1       .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         SPACE 1
MOCON1   CSECT
         $DBG  90,*
         ENTRY MOSTOP              NOTE DISASTER ENTRY POINT
* * * * * REGISTER USAGE IN MOCON1  * * * * * * * * * * * * * * * * * *
*   R0   CURRENTLY UNUSED.                                            *
*   R2 = BYTE REGISTER, USED FOR INSERTIONS                           *
*   RW = ADDRESS OF RSBLOCK(NORMALLY IN AVWXTABL)                     *
*   RX = ADDRESS OF SYMBOL TABLE ENTRY,IF ANY,SAME AS AVLABPT.        *
*   R5 = 1, USED FOR BXH'S,ETC.                                       *
*   RA = SCAN POINTER ADDRESS REGISTER                                *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         USING AVWXTABL,RAT        NOTE MAIN TABLE USING
         $SAVE RGS=(R14-R6),BR=R13,SA=MOCOSAVE
         LA    R2,AVREBLK          RECORD ERROR BLOCK
         LA    RW,AVRSBLOC         RECORD SOURCE BLOCK
         USING RSBLOCK,RW          RECORD SOURCE BLOCK
         LA    RX,AVRSCBLK         RECORD SOURCE CODE BLOCK
         STM   R2,RX,AVREBPT       SORE THE ADDRESSES IN TABLE
         SR    R1,R1               CLEAR,SO TRT'S WILL WORK
         LR    R2,R1               CLEAR THIS FOR INSERTS
         LA    R5,1                INIT FOR BXH'S,ETC
         MVI   MOBACK+1,X'F0'      MAKE THE BC A BRANCH,UNTIL END FOUND
         AIF   (NOT &$MACSLB).MONOMC1
         XCALL XXXXLBED         MAKE SURE XXXXSORC SWITCH SET NORMALLY
.MONOMC1 ANOP
         EJECT
*              MAIN LOOP - PASS 1. THRU MOSTINIT 1 TIME FOR EACH STMT.*
MOSTINIT EQU   *                   LOOP HEAD FOR ALL STATEMENTS
         SPACE 1
*              IF TIME/RECORDS EXCEEDED, HALT PROCESSING NOW.
         TM    AVTAGS2,AJOASTOP    WAS STOP BIT SET BY TIMER EXIT
         BO    MORET               YES, QUIT
         SPACE 1
         $CALL INCARD              GET NEXT SOURCE CARD
         LTR   RB,RB               DID INCARD FIND AN ERROR
         BZ    MOSTINIV            NO, SO DON'T FLAG IT
         $CALL ERRTAG              FLAG ERROR FOUND BY INCARD
         SPACE 1
MOSTINIV EQU   *
         AIF   (NOT &$MACROS).MONMC1   SKIP IF NO MACROS
         TM    RSBFLAG,$RSBNPNN+$RSBNP##    DOES STMT NEED NO PROCESS
         BNZ   MOUTOUCK            NO PROC - SKIP TO SAVE OR PRINT NOW
.MONMC1  ANOP
         SR    RX,RX               CLEAR TO SHOW NO LABEL YET ENCOUNTER
         LA    RA,RSBSOURC         SET UP ADDRESS FOR START SCAN
         SPACE 1
*              CHECK FOR COMMENT OR LACK OF LABEL ON STMT.
         CLI   RSBSOURC,C' '       IS THIS NORMAL SOURCE,NO LABEL
         BE    MONOLB              YES,BRANCH TO HANDLE IT
         CLI   RSBSOURC,C'*'       IS IT  A COMMENT
         BE    MOCMSYSC            SKIP TO CHK *SYSLIB POSSIBILITY
         SPACE 1
*              STATEMENT HAS A LABEL IF FALLS THRU HERE.              *
         CLI   RSBSOURC,C'0'       MAKE SURE BEGINNING OF SYMBOL<C'0'
         BNL   MOLABR1             NO IT ISN'T,STARTS WITH #==>ILLEGAL
         TRT   RSBSOURC(9),AWTSYMT           SCAN A SYMBOL
         BZ    MOLABR1             SYMBOL 9+ CHARACTERS LONG-ERROR
         CLI   0(R1),C' '          IS DELIMITER BLANK LIKE SUPPOSED TO
         BNE   MOLABR2             NO IT ISNT==> ERROR-BRANCH
         SPACE 1
*              LEGAL LABEL FOUND. ENTER IN SYMBOL TABLE. CHECK FOR
*              MULTIPLE DEFINITION, FLAG STMT IF SO.
         LR    RB,R1               MOVE POINTER TO BLANK OVER
         SR    RB,RA               GET LENGTH OF SYMBOL
         $CALL SYENT1              HAVE SYMBOL ENTERED OR LOOKED UP
         LR    RX,RA               MOVE POINTER TO SYMBOL BACK OVER
         USING SYMSECT,RX          NOTE SYMBOL TABLE USING
         TM    SYFLAGS,$SYDEF      WAS SYMBOL ALREADY DEFINED
         BZ    MOLABGO             NO IT WASNHT-OK
MOLABMUL EQU   *                   ENTER HERE IF MULTIPLE DEFINED LABEL
         LA    RB,$ERMULDF         MULTUPLY-DEFINED SYMBOL
         $CALL ERRLAB              LABEL ERROR
MOLABGO  LR    RA,R1               MOVE POINTER TO BLANK AFTER LABEL
         BXH   RA,R5,MOOPC         BUMP SCAN POINTER 1 AND BRANCH
         SPACE 1
*              THE FOLLOWING IS ENTERED IF THERE WAS NO LABEL         *
MONOLB   CLC   RSBSOURC+1(8),AWBLANK         HOPE THAT THESE COLS BLANK
         BNE   MOOPC               NO THEY WERE'T,SKIP AND DO GENERALLY
         LA    RA,RSBSOURC+9       HAPPINESS-1ST 9 COLS BLANK
MOOPC    ST    RX,AVLABPT          SAVE POINTER(IF LABEL) OR 0(IF NOT)
         EJECT
*              SCAN LOOP TO FIND OPCODE                               *
MOOPCA   CLI   0(RA),C' '          IS THIS ANOTHER BLANK
         BNE   MOOPCB              NO IT ISNT BLANK-BRANCH OUT
         BXH   RA,R5,MOOPCA        BUMP SCAN POINTER AND CONTINUE
         SPACE 1
*              OPCODE IS FOUND-RA POINTS THERE. IF OMITTED,RA==> '    *
MOOPCB   C     RA,AVSOLAST         COMPAE TO @ BLANK BEFORE ' AFTER
         BNL   MOOPNONE            BRANCH OUT - - MISSING OPCODE
         $CALL OPFIND              LOOK UP TYPE OF OPCODE
         LTR   RB,RB               WAS IT LEGAL
         BNZ   MOMACHK             GO TO ERROR OR MACRO CHECK
         USING OPCODTB,RC          NOTE OPCODE TABLE POINTER
         AR    RA,R5               INCREMENT SCAN POINTER BY 1
         LR    RE,RA               SAVE SCAN POINTER FOR LATER
         SPACE 1
*              SEARCH FOR OPERAND FIELD.                              *
MOOPRA   CLI   0(RA),C' '          IS THIS STILL BLANK FIELD
         BNE   MOOPRB              NO-BRANCH OUT-WE HAVE OPERAND FIELD
         BXH   RA,R5,MOOPRA        BUMP SCAN POINT AND CONTINUE
         SPACE 1
*              FOUND FIRST NONBLANK CHAR IN OPERAND FIELD. TEST FOR
*              OMITTED OPERAND, EITHER COMPLETELY OR SHOWN BY ,.
MOOPRB   CLC   0(2,RA),=C', '      DOES HE SHOW OMITTED OPERAND
         BNE   MOOPRB2             NO,SO SKIP TO CHK FOR TOTAL OMIT
         BXH   RA,R5,MOOPRC        BUMP SCAN PTR TO SHOW BLANK,FAKE OMI
         SPACE 1
MOOPRB2  C     RA,AVSOLAST         CHK WITH @ BLANK BEFORE AFTERQUOTE
         BL    MOOPRC              OPERAND EXISTS, BRANCH
         LR    RA,RE               OMITTED,SO REPLACE ADDR OF 1ST BLNK
MOOPRC   $SCOF RE,RA,RSBSCAN       PLACE SCAN POINTER
         SPACE 1
*              MAKE TYPE TEST TO DETERMINE WHICH 2ND LEVEL PROCESSOR.
         TM    OPCTYPE,$IB         MAKE TEST FOR TUPE OF OPCODE
         BZ    MOCALLIA            BRANCH TO CALL MACHINE INSTRUCTIONS
         BO    MOCALLIB            CALL ASSEMBLER INSTS
         AIF   (NOT &$SPECIO).MONS SKIP IF NO SPECIALS
         AIF   (NOT &$MACROS).MOSPNM        SKIP IF SPECIALS,NO MACROS
         TM    OPCTYPE,$IS         WAS INSTRUCTION A SPECIAL
         BZ    MOCALLMA            BRANCH TO CALL MACRO1
.MOSPNM  IC    R2,OPCTYPE          GET TYPE OF OPCODE
         SLL   R2,2                MULT BY 4 FOR ADDRESS
         $GTAD REP,SPECAD-4*$IS(R2)         GET RIGHT ADDRESS
         B     MOCALLXX            GO TO CALL SECTION
.MONS    AIF   (NOT &$MACROS).MONSM         SKIP IF NO MACROS
MOCALLMA TM    AVTAGSM,AJOMACRO    ARE WE IN MACRO MODE
         BZ    MOOPNONE            NO, FALG AS UNDERINFED OPCODE
MOCALLMC EQU   *                   ENTRY FROM OPEN CODE CHECK         J
         $CALL MACRO1              CALL THE MACRO DEFINITOON PROCESSOR
         B     *+4(RB)             TAKE INDEXED BRANCH ACCORDINGLY
         B     MOSTINIT            NORMAL RETURN - GO BACK FOR NEXT CRD
         B     MOSTINIV            NO, PROB AIF-AGO - CARD ALREADY EXIS
         B     MOPUT               ERROR ALREADY FLAGGED, GO TO SAVE
.MONSM   ANOP
         SPACE 1
MOCMSYSC EQU   *                   COME HWERE FOR ALL COMMENT CARDS
         AIF   (NOT &$MACSLB).MONSYS1       SKIP IF NO MACRO LIBRARY
         CLC   RSBSOURC+1(6),=C'SYSLIB'     WAS THIS *SYSLIB CARD
         BE    MOCOMSYS            GO TO CHECK AND PROCESS IT
.MONSYS1 ANOP
         AIF   (NOT &$XREF).NOXRF12                                   A
*  CHECK FOR *XREF CARD                                               A
         CLC   RSBSOURC+1(4),=C'XREF'  IS IT XERF                     A
         BNE   MOUTOUCK            NO GO ON                           A
         LA    RA,RSBSOURC+5       FOR ENTRY TO XRSCAN (@ TO BEGIN)   L
         SR    RD,RD               CLEAR FOR PROPER ENTRY CONT        L
         $CALL XRSCAN              CALL SCANNING ROUTINE              A
.NOXRF12 ANOP                                                         A
         SPACE 1
*              BRANCH HERE TO DETERMINE WTHER STMT SHOULD BE SAVED VIA
*              UTPUT1, OR PRINTED IMMEDIATELY AS A COMMENT TYPE.
MOUTOUCK TM    AVPRINT1,AVPRSAVE   MUST WE SAVE THE CARD
         BO    MOPUT               YES, SO GO DO IT
MOOUCOMM LA    RB,$OUCOMM          SHOW COMMENT TYPE ( NO LC CTR)
         B     MOIBOUTA            GO TO PUT IT OUT TO LISTING
*              ASSEMBLER INSTRUCTIONS                                 *
MOCALLIB EQU   *                   PROCESSING FOR ASSEMBLER OPS FOLLOWS
         AIF   (NOT &$MACOPC).MOIBA      SKIP ID NO OPEN CODE         J
         BAL   R14,MOOPAMPC        GO CHECK FOR SUBSTITUTE OF EVAR    J
.MOIBA   ANOP                                                         J
         $CALL IBASM1              CALL ASSEMBLER OPS PROCESSOR
         USING RCODBLK,RC          IBASM1 RETURNED PTR TO BLK IN RC
         L     RX,AVLABPT          RELOAD PTR: IF EQU, MAY NOW BE = 0
         TM    RCHEX,IBMOSPEC+IBMOPRCT WAS SPECIAL OF ANY KIND
         BZ    MOCALLXX            NO, SO SKIP TO COMPLETE PROCESSING
*              FALL THRU ==> SOME SPECIAL KIND OF HANDLING NEEDED.
         BM    MOCASEND            AT PRSENT, THIS COND ==> END CARD-B
         SPACE 2
*              SPECIAL HANDLING: BYPASS PASS 2 PROCESSING.            *
*        DURING PASS 1, IT IS POSSIBLE TO PROCESS A STMT COMPLETELY,  *
*   INCLUDING PRINTING IT, UNTIL ANY STMT EXCEPT ONE OF THE FOLLOWING *
*   IS FOUND IN THE INPUT STREAM:                                     *
*   COMMENT CARD, PRINT, SPACE, EJECT, TITLE.                         *
*   MACRO DEFINITIONS, GBL OR LCL IN OPEN CODE.                       *
*        THESE STMTS CAN BE COMPLETELY PROCESSED, THUS SAVING SPACE   *
*   AND TIME.   THE SECTIONS OF CODE BELOW HANDLE THIS.               *
         SPACE 1
         TM    AVPRINT1,AVPRSAVE   MUST WE SAVE RATHER THAN FINISH
         BO    MOCALLXY            YES, BRANCH, MUST SAVE IT
         SPACE 1
*              PROCESS PRINT CONTROL STMTS: SEE CORRESPOND IDASM2 CODE.
*              NOTE: SOME ERROS IN PRINT WILL CAUSE PRINT ON,NOGEN.
         CLI   RCTYPE,$IB+$ITITLE  IS THIS ACTUALLY TITLE STMT
         BNE   MOIBPR1             NO, BRANCH FOR NEXT CHECK
         SR    RB,RB               YES, WAS TITLE; CLEAR FOR INSERT CP
         IC    RB,RCMASK           GET LENGTH-1 OF TITLE        CPP
         $SCPT RA,RSBSCAN          GET SCAN POINTER BACK       CPP
         AR    RA,R5               (R5=1) RA=>1ST BYTE TITLE   CPP
         $CALL CCCON2              ASSEMBLE AS IF C-TYPE CONST. CPP
*              RETURNS: RC=> ASSEMBLED TITLE, RD=LEN-1 OF TITLE CPP
         LA    RE,4                SHOW THIS WAS A TITLE        CPP
         B     MOIBOUTL            BRANCH TO PRINT OR STORE TITLE CPP
         SPACE 1
MOIBPR1  CLI   RCTYPE,$IB+$IPRINT  WAS IT ACTUALLY PRINT STMT
         LA    RC,RCMASK           @ CONTROL BYTE(PRINT,SPACE,EJECT)
         LA    RE,2                SHOW THIS WAS A PRINT STMT.  CPP
         BE    MOIBOUTL            WAS PRINT; ALL REGS SET, PRINT CPP
         SR    RE,RE               FALL THRU==> SPACE OR EJCT, RESET =0
MOIBOUTL LA    RB,$OULIST          SHOW THIS WAS A LISTING CTRL CPP
         SPACE 1
*              IMMEDIATE PRINT CONTROL: CALL PRINT ROUTINE.
MOIBOUTA $CALL OUTPT2              REGS RB,RC,RD,RE ALREADY SET UP
         B     MOSTINIT            GO BACK, PICK UP NEXT STMT
         SPACE 1
MOCASEND EQU   *                   COME HERE FOR END CARD
         MVI   MOBACK+1,0          MAKE BRANCH A NOOP SO WE FALL THROUG
         B     MOCALLXX            GO CALL ROUTINE
         DROP  RC                  NOTE NO LONGER USING RC BLOCK
         SPACE 1
*              MACHINE OPCODES                                        *
MOCALLIA EQU   *                   COME HERE FOR MACHINE OPS          J
         AIF   (NOT &$MACOPC).MOIAA                                   J
         BAL   R14,MOOPAMPC        GO CHECK FOR SUBSTITUTEION OF &VAR J
.MOIAA   ANOP                                                         J
         $CALL IAMOP1              CALL MACHINE OP PROCESSOR          J
         EJECT
*              CALL THE 2ND LEVEL PROCESSOR ROUTINE REQUIRED.         *
MOCALLXX EQU   *
MOCALLXY EQU   *                   SKIP HERE IF AVPRINT1 SET ALREADY
         USING RCODBLK,RC          RC--> RCB OF 2ND LEVEL ROUTINE
         SPACE 1
*              FINISH CREATION OF RCODBLK,ADDING LOC.COUNTER VALUE.
         OI    RSBFLAG,$RCBX       NOTE THAT AN RCB EXISTS NOW
         $GLOC RE                  GET LOCATION COUNTER
         MVC   RCLOC,AVLOCNTR+1    MOVE THE LOCATION COUNTER IN
         SPACE 1
*              DEFINE STMT LABEL, IF ANY, IF NOT ALREADY DEFINED.
         LTR   RX,RX               IS THERE A LABEL ON STATMENT
         BZ    MONOLB2             NO,SKIP DEFINING IT
         TM    SYFLAGS,$SYDEF      HAS THIS BEEN DEFINED YET
         BO    MONOLB2             YES,DON'T REDEFINE IF ALREADY
         IC    R14,AVCESDID        GET ESDID
         IC    RB,RCLQ             GET LENGTH ATTRIBUTE
         $SDEF RE,R14,RB           DEFINE THE SYMBOL
         SPACE 1
*              INCREMENT LOCATION COUNTER BY LENGTH OF THIS STMT.
MONOLB2  AR    RE,RD               ADD INCREMENT TO LOCATION COUNTER
         $SLOC RE
         ST    RC,AVRCBPT          SAVE ADDR OF RCB
         AIF   (&$DEBUG).MONOXS    SKIP IF PRODUCION
         XSNAP STORAGE=(*0(RC),*12(RC),*AVLOCNTR,*AVDWORK1-1),T=NO,    #
               IF=(AVDEBUG,O,X'88',TM)
.MONOXS  ANOP
         SPACE 1
MOPUT    $CALL UTPUT1              OUTPUT THE EXPANDED RECORDS
MOBACK   BC    $CHN,MOSTINIT       B MOSTINIT UNTIL END-BECOMES NOOP
         SPACE 1
MORET    $RETURN RGS=(R14-R6)
         EJECT
**--> ENTRY: MOSTOP     CALLED IF DISASTROUS ERROR OCCURS IN PASS 1 . .
*.       RESTORES CONDITIONS FOR MOCON1, NOTE OVERFLOW OCCURRENCE.    .
*.  ENDS EXECUTION FOR PASS 1, FLAGGING PROGRAM NONEXECUTABLE.        .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         USING MOSTOP,REP          NOTE TEMPORARY USING
MOSTOP   L     R13,=A(MOCOSAVE)    GET @ SAVE AREA,BAS REG
         DROP  REP                 KILL TEMPORARY USING,BACK TO NORMAL
         OI    AVTAGS3,AVOVERFL    SHOW OVERFLOW OCCURRED.
         B     MORET               RETURN TO MAIN CONTROL
         AIF   (NOT &$MACOPC).MOAMP1                                  J
         SPACE 1                                                      J
**--> INSUB: MOOPAMPC CHECK STATEMENT FOR SET VARIABLE SUBSTITUTION  *J
*+       ENTRY CONDITIONS:                                           +J
*+  RA= @ OPERAND FIELD / UNCHENGED ON EXP                           +J
*+  R14 = RETURN ADDRESS                                             +J
*+       EXIT CONDITIONS                                             +J
*+  RETURN IF NO POSSIBLE SUBSTITUTION                               +J
*+  -->MOCALLMC IF SUBSTITUTION POSSIBLE                             +J
*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +J
MOOPAMPC TM    AVMTAG00,AVMOPENC   HAVE SET VARS FOUND ALRESDY        J
         BCR   Z,RET               NO, NO SUBSTITUTION POSSIBLE       J
         TM    RSBFLAG,$RSBGENR    GENERATE STATMENT                  J
         BCR   O,RET               YES, CAN'T SUBSTITUTE AGAIN        J
         IC    R2,RSBLENG          GET LENGTH-1 OF WHOLE STMT         J
         SH    R2,=AL2(RSB$L)      GET LENGTH-1 OF STMT               J
         STC   R2,MOOPAMPT+1       PUT L-1 INTO TRT                   J
         $SETRT ('&&',4)           FLAG TO STOP ONE                   J
MOOPAMPT TRT   RSBSOURC($),AWTZTAB SCAN FOR &                         J
         $SETRT ('&&',0)           REZERO                             J
         BCR   Z,RET               NO SUBSTITUTION-RET                J
         LA    RC,AWZEROS          SHOW @ ZEROS: MACRO WANTS THIS     J
         B     MOCALLMC            GO TO CALL MACRO1 TO SCAN          J 1665432-
.MOAMP1  ANOP                                                         J
         SPACE 1
* * * * * OUT-OF-LINE ERROR PROCESSING SECTIONS * * * * * * * * * * * *
         SPACE 2
*              ERROR IN LABEL - FLAG, MOVE SCAN PTR TO 1ST BLANK.
         SPACE 1
MOLABR2  EQU   *
         AIF   (NOT &$MACOPC).MOLABR                                  J
*              IF MACROS MAY BE PRESENT, CHECK FOR SEQUENCE SYMBOL.
         TM    AVTAGSM,AJOMACRO    ARE WE IN MACRO RUN                A
         BZ    MOLABR2B            NO, SO ERROR FOR SURE
         TRT   RSBSOURC+1(8),AWTSYMT        SCAN SYMBOL
         BZ    MOLABR1             TOO LONG, ERROR
         CLI   0(R1),C' '          TERMINATE PROPERLY
         BNE   MOLABR2B            NO ERROR FLAG IT                   J
         TM    RSBFLAG,$RSBGENR    WAS IT GENERATED                   J
         BO    MOLABGO             YES,SO IGNOR LABEL                 J
         CLI   0(RA),C'&&'         SET VARIABLE                       J
         BE    MOLABGO             YES,CONTINUE                       J
         CLI   0(RA),C'.'          SEQUENCE SYMBOL?                   A
         BNE   MOLABR2B            NO ERROR                           J
         CLI   1(RA),C'0'          CHECK FOR LEGALITY                 J
         BNL   MOLABR2B            BAD-1ST CHAR IS DIGIT              J
* LEGAL SET SYMBOL-PLACE IT IN SYMBOL TABLE                           J
         LR    RB,R1               @ TERMINATOR BLANK                 J
         SR    RB,RA               GET LENGTH                         J
         $CALL SYENT1              HAVE SYMBOL LOOKED UP              J
         USING SYMSECT,RA          NOT PTR                            J
         TM    SYFLAGS,$SYDEF      YES ERROR                          J
         BO    MOLABMUL            YES ERROR                          J
         OI    SYFLAGS,$SYDEF      SHOW DEFINED NOW                   J
         B     MOLABGO             CONTINUE AS USUAL                  J
         DROP  RA                  ZAP USING                          J
         SPACE 1
*              DEFINITE ILLEGAL LABEL FIELD.
.MOLABR  ANOP
MOLABR2B LR    RA,R1               INVALID CHARACTER, SHOW SCAN PTR
MOLABR1  LA    RB,$ERINVSY         INVALID SYMBOL
         $CALL ERRTAG              FALG IT
MOLABLP  CLI   0(RA),C' '          SEARCH FOR BLANK
         BE    MOOPC               FOUND BLANK AFTER SYMBOL-BRANCH
         BXH   RA,R5,MOLABLP       BUMP SCAN POINTER AND CONTINUE
         SPACE 1
*              MISSING OPERATION CODE ERROR.
MOOPNONE LA    RA,RSBSOURC+9       POINT WHERE OPCODE SHOULD BE
         LA    RB,$ERIVOPC         OMITTED OPCODE
         B     MOERRORA            GO HAVE IT FLAGGED
         SPACE 1
MOMACHK  EQU   *                   DEFINE LABEL, EITHER MACRO CHECK, ER
         AIF   (NOT &$MACROS).MONMAC        SKIP IF NO MACROS
*              THIS CODE ENTERED IF UNRECOGNIZED OPCODE.  AT THIS PT,
*              RB = $ERIVOPC, SET BY OPFIND.  MAKE SURE STMT WAS NOT
*              ALREADY A GENERATED ONE.  CALL MEXPND TO SEE IF MACRO.
         TM    AVTAGSM,AJOMACRO    ARE WE IN MACRO MODE
         BZ    MOERRORA            NO, FLAG AS UNDEFINED OPCODE
         BAL   R14,MOOPAMPC        CHECK FOR SUBSTITUTION OF &VAR     S
         $CALL MEXPND              CALL TO EXPAND MACROS
*********CODE MAY BE REQUIRED TO SHOW WE ARE IN EXPANSION MODE        *
         LTR   RB,RB               WAS THE MACRO KNOWN
         BZ    MOSTINIT            OK,BRANCH IF OS
.MONMAC  ANOP
         SPACE 1
*              GENERAL 1-STMT UNRECOVERABLE ERROR SECTION.
MOERRORA $CALL ERRTAG              HAVE ERROR FLAGGED
         B     MOUTOUCK            GO TO CHK PRINT/SAVE OPTION
         SPACE 1
         EJECT
         AIF   (NOT &$MACSLB).MONOMC2
* . . . .   MOCOMSYS  SECTION . . . . . . . . . . . . . . . . . . . . .
*                                                                     .
*        THIS SECTION OF MOCON1 IS CALLED WHENEVER A '*SYSLIB CARD    .
*        HAS BEEN FOUND.  IT COORDINATES THE ACTIVITIES OF MACRO      .
*        LIBRARY PROCESSING AND THE MACRO PROCESSOR                   .
*                                                                     .
*        ENTRY CONDITIONS:                                            .
*              REGISTER RA --> SCAN POINTER TO SYSLIB CARD            .
*                                                                     .
*        EXIT CONDITIONS:                                             .
*              REGISTERS UNCHANGED                                    .
*                                                                     .
*        USES MACROS:                                                 .
*              $CALL, $ALLOCL                                         .
* . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         SPACE 2
MOCOMSYS STM   RA,RE,MOCOMSVE      SAVE CONDITION OF WORK REGISTERS
         MVC   MOCPRTSV,AVPRINT    SAVE CURRENT PRINT STATUS
         TM    AVTAGSM,AJOMACRO    RETURN IF MACRO DISENABLED
         BZ    MOUTOUCK            NOT MACRO MODE GO TO PRINT CARD
         TM    AVPRINT1,AVPRSAVE   IS SYSLIB CARD IN LEGAL POSITION
         BO    MOCLBER1            IN ERROR--GO THERE TO FINISH
         AIF   (NOT &$MACOPC).MOMXX1         SKIP IF NO OPEN CODE
         TM    AVMTAG00,AVMOPENC   HAVE GBLX, LCLX BEEN FOUND
         BO    MOCLBER1            YES, ERROR - FLAG IT
.MOMXX1  ANOP
         LA    RA,7(RA)            SYSLIB LEGAL-INCREMENT POINTER PAST
*                                  SYSLIB TO THE FOLLOWING BLANK
         SPACE 1
*        SCAN AND SKIP BLANKS TILL FIRXT SYMBOL OF NAME FOUND
MOCBLNK  CLI   0(RA),C' '          IS THIS A BLANK
         BNE   MOCLBSC             NO BRANCH OUT TO CONTINUE
         BXH   RA,R5,MOCBLNK       BUMP SCAN POINTER AND CONTINUE
         SPACE 1
MOCBUMP  LA    RA,1(R1)            KICK PAST A LEGAL DELIMITER
MOCLBSC  LR    R1,RA               MOVE POINTER OVER FOR ERROR FLUSH
         C     RA,AVSOLAST         IS SYSLIB CARD BLANK
         BNL   MOCNLSYS            YES--> SO SKIP NAME SCAN CODE
         CLI   0(RA),C'0'          DOES NAME START WITH LEGAL CHARACTE
         BNL   MOCLBER2            NOT LEGAL STARTING CHARACTER
         TRT   0(9,RA),AWTSYMT     SCAN THE NAME
         BZ    MOCLBER2            NAME TOO LONG--ERROR
         LR    RB,R1               MOVE BLANK POINTER OVER
         SR    RB,RA               GET LENGTH OF NAME
         SR    RB,R5               DECREMENT FOR LENGTH-1 OF NAME
         MVC   AVMSYMBL,AWBLANK    BLANK OUT SEARCH AREA
         EX    RB,MOCMVEL          MOVE NAME INTO SEARCH AREA
         L     RC,AVMACLIB         SET UP TO SEARCH LIST WITH MACFND
         BAL   RD,MOCLOOK          SEARCH LIST FOR NEW NAME
         LTR   RB,RB               SET CC ON RETURNED MAGNITUDE OF RB
         BNZ   MOCNMADD            NOT FOUND- PUT NAME IN THE LIST
MOCNAMNT CLI   0(R1),C','          IF LEGAL NAME DELIMITER LOOP FOR ALL
*                                  NAMES
         BE    MOCBUMP             LOOP FOR ALL NAMES
         CLI   0(R1),C' '          IS SCAN CHARACTER A BLANK
         BNE   MOCLBER3            NOT BLANK OR COMMA--ERROR INVALID
*                                  DELIMITER
MOCNLSYS LA    RB,$OUCOMM          SET TO PRINT A COMMNNT
         $CALL OUTPT2              PRINT STATEMENT AND ANY ERRORS
         L     RC,AVMACLIB         GET BEGIN ADDRESS OF MACRO LIST    M
         USING MACLIB,RC           NOTE USING ON MACRO LIST DSECT     M
         SR    RB,RB               ZERO FOR SEARCH END LIST           M
         CL    RB,MCLIBNXT         IF LIST HEADER IS NULL             M
         BE    MOCLBOUT            THEN NO OPEN - JUST QUIT           M
         DROP  RC                  CLEAR USING                        M
         XCALL XXXXLBOP            CALL TO OPEN LIBRARY DCB           M
         BM    MOCLBER4            NO--SET UP ERROR
         SPACE 2
         TM    AVTAGSM,AJOLIBMC    SHOULD WE PRINT MACRO DEFINITIONS
         BO    *+8                 NO -- PROCESS NORMALLY
         NI    AVPRINT,255-$IBPON  TURN PRINT STATUS OFF
         SPACE 1
MOCLBMOR L     RC,AVMACLIB         GET BEGIN ADDRESS OF MACRO LIST
         USING MACLIB,RC           NOTE USING ON MACRO LIST DSECT
         SR    RB,RB               ZERO FOR SEARCH END TEST
         CL    RB,MCLIBNXT         IF LIST HEADER IS NULL
         BE    MOCLBOUT            THEN NOTHING TO DO -- GO HOME
         L     RC,MCLIBNXT         ELSE START LIST SCAN
         B     MOCLBFD2            SKIP TO LOOK AT FIRST ENTRY
MOCLBFD1 L     RC,MCLIBNXT         GET @ OF NEXT ENTRY
MOCLBFD2 TM    MCLBTAGS,AVMCLBDF   PREVIOUSLY DEFINED?
         BO    MOCLBFD5            DEFINED -- GO LOOK AT NEXT ENTRY
         TM    MCLBTAGS,AVMCLBNF   PREVIOUSLY SEARCHED FOR
         BNO   MOCLBFND            N/- GO DO FIND AND MACRO DEFINITION
MOCLBFD5 CL    RB,MCLIBNXT         IS THIS FINAL ENTRY
         BNE   MOCLBFD1            NO--LOOK AT NEXT
         SPACE 5
MOCLBSP  XCALL XXXXLBED            CALL LIBRARY ENDUP ROUTINE
         L     RC,AVMACLIB         GET BEGIN @ OF MACRO LIST
         SR    RB,RB               ZERO FOR SEARCH EBD TEST
         B     MOCLBFD4            SKIP TO LOOK AT FIRST ENTRY
MOCLBFD3 L     RC,MCLIBNXT         GET @ OF NECT ENTRY
MOCLBFD4 TM    MCLBTAGS,AVMCLBDF   HAS THIS MACRO BEEN DEFINED
         BO    MOCLBMR1            DEFINED -- SKIP ERROR SET
         MVC   MOCER7MS+10(8),MCLBNAM       MOVE BAD NAME INTO MESS
         BAL   RE,MOCLBER7         GO TO MARK NAME AS ERROR
MOCLBMR1 CL    RB,MCLIBNXT         IS THIS FINAL ENTRY
         BNE   MOCLBFD3            NO--CONTINUE SEARCH
         SPACE 2
MOCLBOUT MVC   AVPRINT,MOCPRTSV    RESTORE THE PRINT STATUS
         LM    RA,RE,MOCOMSVE      RESTORE REGISTER TO PREVIOUS CONDIT
         SPACE 2
         B     MOSTINIT            RETURN FOR NEXT SOURCE CARD
         SPACE 2
MOCLBFND MVC   AVMSYMBL,MCLBNAM    MOVE NAME INTO WORK AREA FOR FIND
         OI    MCLBTAGS,AVMCLBNF   MARK NAME AS SEARCHED FOR
         XCALL XXXXFIND            CALL FIND ROUTINE
         BM    MOCLBMOR            ERROR NOT FOUND -- MESSAGE WILL
*                                  COME OUT LATER
         DROP  RC                  KILL USING
MOCLIBNI $CALL INCARD              CALL INCARD TO READ FROM MACRO
*                                  LIBRARY
         LTR   RB,RB               TEST MAGNITUDE OF RETURN REGISTER
         BNZ   MOCLBER5            ERROR ON NON-ZERO VALUE
         LA    RC,MOCMAC           GET OPCODTB ENTRY FOR MACRO
         $CALL MACRO1              START MACRO DEFINITION PHASE
         B     MOCLBMOR            GO BACK TO PICK UP REST OF NAMES
         SPACE 2
*        ERROR ROUTINES FOLLOW
         SPACE 2
MOCLBER1 LA    RB,$ERSTMNA         SET ERROR-SYSLIB OUT OF ORDER
         $CALL ERRTAG              CALL TO SET ERROR FLAG BIT
         $CALL UTPUT1              SEND ILLEGAL CARD OUT
         B     MOCLBOUT            RETURN
         SPACE 2
MOCLBER2 BAL   RB,MOCERALL         GO FOR COMMON ERROR CODE
         DC    AL2($ERINVSY)       DEFINE ERROR--INVALID SYMBOL
         SPACE 2
MOCLBER3 BAL   RB,MOCERALL         GO FOR COMMON ERROR CODE
         DC    AL2($ERINVDM)       DEFINE ERROR--INVALID DELIMITER
         SPACE 2
MOCLBER4 MVC   RSBLENG(RSB$L+MOCER4LN+1),MOCER4ST  MOVE ERROR IN
         LA    RB,$OUCOMM          SET COMMENT FLAG                   A
         $CALL OUTPT2              PRINT ALLREADY DEFINED ERROR
         B     MOCLBOUT            RETURN
         SPACE 2
MOCLBER5 $CALL ERRTAG              SET ERROR BIT-DEFINED BY INCARD
         B     MOCCOM              GO FOR COMMON RETURN CODE
         SPACE 2
MOCLBER7 MVC   RSBLENG(RSB$L+MOCER7LN+1),MOCER7ST  MOVE THE ERROR IN
MOCCOM   LA    RB,$OUCOMM          SET TO PRINT A COMMENT
         $CALL OUTPT2              PRINT THE MESSAGE
         SR    RB,RB               ER-ZERO RG TO CONTINUE
         BR    RE                  RETURN TO CALLER
MOCERALL LH    RB,0(,RB)           GET THE ERROR FLAG FOR ERRTAG
         LR    RA,R1               MOVE BAD CHAR POINTER OVER
         $CALL ERRTAG              CALL TO SET ERROR BIT
         B     MOCNLSYS            ON BAD CHAR -- PROCESS  WHAT THERE
*                                  IS UP TO THIS POINT
         SPACE 5
         USING MACLIB,RC           NOTE USING ON MACRO LIST
MOCLOOK  SR    RB,RB               ZERO WORK REG FOR END TEST
         B     MOCLOOK2            SKIP FIRST LINK JUMP
MOCLOOK1 L     RC,MCLIBNXT         LINK TO NEXT ENTRY
MOCLOOK2 CLC   AVMSYMBL,MCLBNAM    IS THIS THE ONE WE ARE LOOKING FOR
         BE    MOCLKRT             YESYES -- GO BACK TO PRCESS
         CL    RB,MCLIBNXT         IS THIS THE LAST ENTRY
         BNE   MOCLOOK1            NO -- LINK TO THE NEXT ENTRY
         LA    RB,$ERUNDEF         NAME NOT IN LIST INDICATE THIS
MOCLKRT  BR    RD                  RETURN TO CONTINUE
         SPACE 2
MOCNMADD LA    RE,$LMACLIB         GET LIST ENTRY LENGTH
         $ALLOCL RB,RE,MOCLBOUT    GET LIST SPACE
         ST    RB,MCLIBNXT         LINK LIST TO NEW ENTRY
         DROP  RC                  CLEAR USING
         USING MACLIB,RB           NOTE USING ON MACLIB DSECT
         MVC   MACLIB($LMACLIB),AWZEROS     ZERO NEW ENTRY
         MVC   MCLBNAM,AVMSYMBL    MOVE NAME INTO LIST
         DROP  RB                  KILL USING
         SR    RB,RB               REZERO REGISTER TO CONTINUE
         B     MOCNAMNT            CONTINUE SCAN FOR NEW NAMES
         SPACE 2
MOCOMSVE DS    5F                  TEMP REGISTER SAVE AREA
MOCPRTSV DS    C                   SAVE BYTE FOR PRINT STATUS
MOCMVEL  MVC   AVMSYMBL($),0(RA)   VARIABLE LENGTH NAME MOVE
MOCMAC   DC    AL1($IM,$MACRO,0)   SEE OPG CALL TO MACRO
MOCER4ST DC    AL1(RSB$L+MOCER4LN,$RSBMERR,1,0)  DEFINE THIS ERROR
MOCER4MS DC    C'289 UNABLE TO OPEN MACRO LIBRARY: OPTION CANCELED'
MOCER4LN EQU   *-MOCER4MS          LENGTH OF THE MESSAGE
MOCER7ST DC    AL1(RSB$L+MOCER7LN,$RSBMERR,1,0)  DEFINE THIS ERROR
MOCER7MS DC    C'288 MACRO          COULD NOT BE FOUND'
MOCER7LN EQU   *-MOCER7MS          GET LENGTH OF THE MESSAGE
.MONOMC2 ANOP
         LTORG
         DROP  RAT,R13,RW,RX       CLEAN UP USINGS
         TITLE '*** MPCON0 - ASSIST ASSEMBLER MAIN CONTROL PROGRAM ***'
**--> CSECT: MPCON0   0   MAIN PROGRAM CONTROL-INIT,SET UP TABLES,ETC..
*.       MPCON0 INITIALIZES AVWXTABL DSECT VALUES FOR WHOLE ASSEMBLY, .
*.       SETS A $SPIE TO INTERCEPT SOME TYPES OF INTERRUPTS, SETS THE .
*.       PROGRAM AMSK TO ONLY HAVE FIXED-OVERFLOW INTRPTS, AND CALLS  .
*.       ALL THE SUBROUTINES REQUIRED FOR AN ASSEMBLY IN A TABLE-     .
*.       DRIVEN MANNER, USING A LIST OF POINTERS TO ADDRESS CONSTNATS..
*.       AFTER THE ASSEMBLY IS COMPLETED, IT PRINTS VARIOUS STATISTICS.
*.       AND THEN RETURNS CONTROL TO THE ASSIST MONITOR.  NOTE THAT   .
*.       MPCON0 IS THE ONLY CSECT IN THE ASSEMBLER WHICH ACTUALLY     .
*.       REFERS TO AJOBCON, ALTHOUGH OTHERS USE EQU FLAGS FROM IT.    .
*.       ENTRY CONDITIONS                                             .
*   R12(RAT)= @ VWXTABL CSECT, INITIALIZED BY ASSIST CONTROL PROG.    .
*   AVAJOBPT,AVECONPT HAVE BEEN INITIALIZED IF NEEDED BY ASSIST.      .
*.       CALLS ESINT1,LTINT1,OPINIT,SYINT1,UTINT1,OUINT1,MOCON1       .
*.       CALLS LTEND1,UTEND1,BRINIT,MTCON2                            .
*.       CALLS OUEND2,SYEND2,UTEND2                                   .
*.       USES DSECTS: AVWXTABL                                        .
*.       USES MACROS: $AL2, $CALL, $PRNT, $RETURN, $SAVE, $SPIE       .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
MPCON0   CSECT
         $DBG  ,NO
         $SAVE RGS=(R14-R12),BR=R13,SA=MPSAVE
         SPACE 1
*              INITIALIZATION FOR ASSEMBLY - OBTAIN VARIOUS VALUES    *
*              FROM AJOBCON. ZERO FLAGS. SET SPIE,PROGRAM MASK.       *
         SPACE 1
         USING AVWXTABL,RAT        NOTE MAIN USING FROM NOW ON
         LM    R2,R3,AVADDLOW      GET ORIG CORE LIMITS FOR STATS LATER
         MVC   AWZEROS+C' '(64),AWZEROS     MAKE SURE ZERO(SEE SCANRS)
         MVC   AVZAREA1(AVZAREA2-AVZAREA1),AWZEROS     ZERO OUT AREA
         MVC   AVRCBPT(7*4),AWZEROS         ZERO AVRCBPT---AVSOLAST
*                                  REQUIRED FOR REPLACE, GOOD DEBUG
         NI    AVTAGS1,255-$IBSTAR1-$IBDSEC1-$IBPRCD1  INIT VALUES
         NI    AVTAGS2,255-$INEND2     CLEAR EOF FLAG
         SPACE 1
         $SPIE ,((7,15)),ACTION=CR,CE=MPSPIEXT   GET CONTROL FOR ERRS
         ST    R1,AVMPSPIE         SAVE @ PREVIOUS SPIE CONTROL BLOCK
         L     R0,=XL4'08000000'   GET MASK FOR SPM (FIXED OVER ONLY)
         SPM   R0                  SET TO STOP ANY FP INTERRUPTS
         SPACE 1
*              SET UP VALUES FOR CALLS TO ALL SUBROUTINES             *
         LA    RZ,MPCALL1          INIT INDEX FOR BXLE CALL LOOP
         LA    RX,2                INCREMENT FOR BXLE
         LA    RY,MPCALL2-2        LIMIT ADDRESS FOR BXLE
         SPACE 1
*              FOLLOWING LOOP PERFORMS ENTIRE ASSEMBLY PROCESS.
MPCALLR  LH    REP,0(,RZ)          GET OFFSET @ FROM OFFSET LIST
         $CALL $BASE(REP)          CALL THE RIGHT ROUTINE
         BXLE  RZ,RX,MPCALLR       LOOP THRU CALL LIST
         EJECT
*              IF 'STOP' BIT SET, FLAG NOLOAD ALSO
         TM    AVTAGS2,AJOASTOP    HAS STOP BIT BEEN SET FOR ANY REASON
         BZ    *+8                 NO, CONTINUE
         OI    AVTAGS1,AJNLOAD     SHOW NO LOAD CAN BE DONE
         SPACE 1
*              CONVERT AND PRINT STORAGE USAGE. NOTE THAT THIS CODE,  *
*              MPCONV, AND DATA MPAT-MPHLEN ARE NOT REQUIRED FOR      *
*              ACTUAL WORKING OF THE PROGRAM, AND COULD BE REMOVED.   *
         LM    R0,R1,AVADDLOW      GET CURRENT FREE AREA POINTERS
         SPACE 1
         SR    R3,R1               AJOTADH -AVADDHIH = HIGH CORE USED
         SR    R0,R2               AVADDLOW-AJOTADL = LOW CORE USED
         LR    R5,R0               SAVE TO CALCULATE TOTAL SPACE.
         S     R1,AVADDLOW         AVADDHIH-AVADDLOW = REMAINING AREA
         LA    R2,MPARL            @ FIRST AREA FOR LOW STORAGE
         BAL   RZ,MPCONV           HAVE LOW VALUE(R0) CONVERTED
         LA    R2,MPARH            ADDRESS OF HIGH AREA USED
         LR    R0,R3               MOVE DIFFERENCE OVER WHERE EXPECTED
         SPACE 1
         BAL   RZ,MPCONV           CALL CONVERTER ROUTINE
         LA    R2,MPREM            @ REMAINING AREA TO BE PRINTED
         LR    R0,R1               MOVE VALUE OVER FOR CONVERTER
         BAL   RZ,MPCONV           CALL CONVERTER
         SPACE 1
*              COMPUTE AVERGAE # BYTES PER STATEMENT USED.
         AR    R5,R3               ADD HIGH USED (R5) TO LOW USED(R3)
         SR    R4,R4               CLEAR SO DIVIDE WORKS OK
         LH    R0,AVSTMTNO         GET # STATEMENTS
         DR    R4,R0               DIVIDE TO GET BYTES/STATEMENT
         LR    R0,R5               MOVE QUOTIENT OVER
         LA    R2,MPBYSTMT         FOR # BYTES/STMT
         BAL   RZ,MPCONV           CALL CONVERTER
         SPACE 1
         $PRNT MPHEAD,MPHLEN       PRINT THE ASSEMBLED LINE
         AIF   (NOT &$XREF).NOXREF9  SKIP IF NO XREF                  A
         TM    AVXRFLAG,AVXRON     DO WE WANT A CROSS REFERENCE       A
         BZ    MPRETA              NO SKIP CALL                       A
         $CALL XRPRNT              CALL CROSS REF PRINT ROUTINE       A
.NOXREF9 ANOP                                                         A
MPRETA   EQU   *
         L     R1,AVMPSPIE         GET @ PREVIOUS SPIE BLOCK BACK
         $SPIE ACTION=(RS,(1))     RESTORE PREVIOUS SPIE BLOCK
MPRET    $RETURN RGS=(R14-R12)
         EJECT
*              SPIE EXIT ROUTINE - FLAGS INTERRUPTS 0C7-0CF.          *
         USING MPSPIEXT,R15        NOTE ENTRY PT AT SPIE
MPSPIEXT STM   R14,R12,12(R13)     SAVE ALL THE REGS
         LA    RB,$ERINTPT         SHOW INTERRUPT MESSAGE
         $CALL ERRTAG              CALL ERROR FLAGGING
         LM    R14,R12,12(R13)     RELOAD REGS
         BR    R14                 RETURN TO SUPERVISOR
         DROP  R15                 KILL TEMPORARY USING
         SPACE 1
         SPACE 2
* * * * * MPCONV - CONVERT 1 ADDRESS DIFERENCE  AND EDIT IT           *
*        ENTRY CONDITIONS                                             *
*   R0 = ADDRESS DIFFERENCE TO BE CONVERTED                           *
*   R2 = ADDRESS OF AREA WHERE EDITED VALUE TO BE PUT                 *
*   RZ = RETURN ADDRESS TO CALLING CODE                               *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
MPCONV   CVD   R0,AVDWORK1         CONVERT DIFFERENCE TO DECIMAL
         MVC   0(L'MPAT,R2),MPAT   MOVE THE PATTERN IN
         ED    0(L'MPAT,R2),AVDWORK1+8-L'MPAT/2       EDIT VALUE OVER
         BR    RZ                  RETURN TO CALLER
         SPACE 1
* * * * * INTERNAL CONSTANTS                                          *
*              OFFSETS TO ADCONS FOR ROUTINES TO BE CALLED            *
MPCALL1  DS    0H
         $AL2  AX$BASE,(AXESINT1,AXLTINT1,AXOPINIT,AXSYINT1,AXUTINT1)
         AIF   (NOT &$MACROS).MPNOMA1       SKIP IF NO MACRO MODS
         $AL2  AX$BASE,(AXMACINT)      OPCODE INITIALIZATION
.MPNOMA1 ANOP
         AIF   (NOT &$XREF).NOXREF8                                   A
         $AL2  AX$BASE,(AXXRINT1)  XREF INTIALIZATION PASS 1          A
.NOXREF8 ANOP                                                         A
         $AL2  AX$BASE,(AXOUINT1,AXMOCON1)
MPCALL1A $AL2  AX$BASE,(AXLTEND1,AXUTEND1,AXBRINIT)                   A
         AIF   (NOT &$XREF).NOXRF70   SKIP IF NO XREF
         $AL2  AX$BASE,(AXXRINT2)   XREF INITIALIZATION 2ND PASS      1
.NOXRF70 ANOP
         $AL2  AX$BASE,(AXMTCON2)
         $AL2  AX$BASE,(AXOUEND2,AXSYEND2,AXUTEND2)
MPCALL2  EQU   *
         SPACE 1
*              STORAGE USAGE OUTPUT HEADING,EDIT PATTERN              *
MPAT     DC    X'4020202020202120' EDIT PATTERN FOR ADDRESSES
MPHEAD   DC    C'0*** DYNAMIC CORE AREA USED:  LOW:'
MPARL    DS    CL(L'MPAT)          FOR LOW AREA USAGE
         DC    C' HIGH:'
MPARH    DS    CL(L'MPAT)          FOR HIGH AREA USAGE(SYMBOL TABLE)
         DC    C' LEAVING:'
MPREM    DS    CL(L'MPAT)          FOR REMAINING STORAGE
         DC    C' FREE BYTES. AVERAGE: '
MPBYSTMT DS    CL(L'MPAT)          FOR AVERAGE BYTES/STMT
         DC    C' BYTES/STMT ***'
MPHLEN   EQU   *-MPHEAD            DEFINE LENGTH OF AREA
         LTORG
         DROP  RAT,R13             CLEAR UP USING
         TITLE '*** MTCON2 - MAIN CONTROL - PASS 2 ***'
**--> CSECT: MTCON2   2   MAIN CONTROL - ASSEMBLER PASS 2 . . . . . . .
*.       MTCON2 IS THE CONTROL PROGRAM FOR THE 2ND PASS OF THE ASSIST .
*.       OF THE ASSIST ASSEMBLER.  IT IS RELATIVELY SMALL, SINCE      .
*.       MOST OF THE WORK HAS BEEN DONE IN PASS 1.   IT PERFORMS OR   .
*.       SUPERVISES THE FOLLOWING ACTIONS, FOR EACH SOURCE STMT:      .
*.        1. RETRIEVES POINTERS TO THE RECORD BLOCKS (UTGET2).        .
*.        2. SETS UP THE LOCATION COUNTER AND OPERAND SCAN POINTER.   .
*.        3. CALLS 2ND LEVEL INSTRUCTION PROCESSORS(ICMOP2,IDASM2).   .
*.        4. PRINTS ANY STATEMENT WITH NO RCODBLK (OUTPT2).           .
*.       FINISH BY ROUNDING UP LENGTH OF PROG TO DOUBLEWORD BOUNDARY. .
*.       CALLS ICMOP2,IDASM2,OUTPT2,UTGET2                            .
*.       USES DSECTS: AVWXTABL,RCODBLK,RSBLOCK                        .
*.       USES MACROS: $CALL,$RETURN,$SAVE,$SLOC                       .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
MTCON2   CSECT
         $DBG  90,*
         USING AVWXTABL,RAT        NOTE MAIN USING
         $SAVE RGS=(R14-R6),SA=MTCOSAVE,BR=R13
         SR    R2,R2               CLEAR FOR INSERTIONS
         MVI   AVCESDID,2          INIT TO VALUE IN CASEE UNIT PRIV CD
         SPACE 1
*              MTGET2 ENTERED 1 TIME FOR EACH STATEMENT. CALLS UTGET2 *
*        TO GET @'S OF RECORD BLOCKS.  @ RSBLOCK IS RETURNED IN RC,   *
*        AND ALL EXISTING VALUES HAVE BEEN FILLED IN FOR RECORD PTRS. *
         SPACE 1
MTGET2   EQU   *                   ENTRY FOR LOOP HEAD FOR 1 STMT
*              IF 'STOP' BIT SET BY ANYONE, QUIT NOW.
         TM    AVTAGS2,AJOASTOP    HAS IT BEEN SET
         BO    MTRET               YES, QUIT
         SPACE 1
         $CALL UTGET2              CALL TO OBTAIN NEXT BLOCKS
         LTR   RE,RE               WAS THIS THE END
         BNZ   MTENDOF             YES,NO MORE TO DO-QUIT
         LR    RE,RC               MOVE @ RSBLOCK OVER
         USING RSBLOCK,RE          NOTE POINTER
         TM    RSBFLAG,$RCBX       DOES A RCB EXIST
         BZ    MTPRINT             NO IT DOESN'T,EITHER ERROR OR COMM
         SPACE 1
*              GET INFORMATION FROM RCODBLK. SRT UP FOR LEVEL 2 SUBRS.
         L     RC,AVRCBPT          GET @ RCODBLK BACK INTO REG
         USING RCODBLK,RC          NOTE THIS USING
         IC    R2,RSBSCAN          GET SCAN POINTER TO BEGINNING OF OPE
         LA    RA,RSBLOCK(R2)      GET @ OPERAND FIELD
         L     RD,RCLOC-1          GET THE LOCATION COUNTER FOR STMT
         LA    RD,0(RD)            REMOVE 1ST BYTE
         $SLOC RD                  SET THE LOCATION COUNTER
         SPACE 1
*              CHOOSE CORRECT 2ND-LEVEL PROCESSOR.
         TM    RCTYPE,$IB          MAKE TYPE TEST
         BO    MTCID               BRANCH TO CALL ASSEMBLER ROUTINE
         AIF   (NOT &$SPECIO).MTNOSPC       SKIP IF NO SPECIALS
         BZ    MTCID               BRANCH IF ASSEMBLER INSTRUCTIONS
*              FALLS THRU ==> SPECIAL INST                            *
         IC    R2,RCTYPE           GET TYPE BYTE
         SLL   R2,2                *4 FOR FULLWORD @ INDEXING
         $CALL SPECA2-4*$IS(R2)    GET 2ND PASS SPECIAL ROUTINES
         B     MTGET2              GO GET NEXT RECORD
.MTNOSPC ANOP
MTCIC    $CALL ICMOP2              PASS 2 MACHINE INSTRUCTIONS
         B     MTGET2              GO GET NEXT ONE
         SPACE 1
MTCID    $CALL IDASM2              ASSEMBLER INSTRUCTIONS
         B     MTGET2              GO GET NEXT ONE
         SPACE 1
MTPRINT  LA    RB,$OUCOMM          SHOW OUTPT2 NO LOCCNTR OR CODE
         $CALL OUTPT2              CALL PRINTER ROUTINE
         AIF   (NOT &$XREF).NOXRF13                                   A
*   CHECK FOR THE * XREF CARD                                         A
         CLI   RSBSOURC,C'*'       IS IT A COMMENT CARD               A
         BNE   MTNXREFF            NO, CAN'T BE * XREF CARD           A
         CLC   RSBSOURC+1(4),=C'XREF'  IS IT XREF                     A
         BNE   MTNXREFF            NO, GO ON                          A
         LA    RA,RSBSOURC+5       FOR ENTRY TO XRSCAN (@ TO BEGIN)   L
         LA    RD,8                SET ENTRY CONDITIONS TO XRSCAN     L
         $CALL XRSCAN              CALL SCANNING ROUTINE              A
MTNXREFF EQU   *                                                      A
.NOXRF13 ANOP                                                         A
         B     MTGET2              GO GET NEXT ONE
MTENDOF  EQU   *
*              ALIGN LENGTH OF PROG TO MULTIPLE OF 8.
         L     R0,AVLOCHIH         GET HIGHEST LOCATION COUNTER  VALUE
         LA    R1,7                GET VALUE FOR DOUBLEWORD ALIGN
         $ALIGR R0,R1              ALIGN UP TO DOUBLEWORD BOUNDARY
         ST    R0,AVLOCHIH         RESTORE UPDATED,ALIGNED VALUE
         S     R0,AVLOCLOW         LENGTH= HIGH LOCATION-LOW LOCATION
         A     R0,AVRADL           + LOWEST REAL LOCATION
         ST    R0,AVRADH           = HIGH LIMIT FOR REAL @'S
MTRET    $RETURN RGS=(R14-R6)
         DROP  RAT,RC,RE,R13       CLEAR USINGS
         LTORG                                                        A
         TITLE '*** OPCOD1 - IDENTIFY MNEMONIC OPERATION CODES ***'
**--> CSECT: OPCOD1   1   OPCODE TABLES AND LOOKUP CODE . . . . . . . .
*.       THIS MODULE CONTAINS THE CODE,TABLES TO IDENTIFY OPCODES.    .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
OPCOD1   CSECT
         $DBG  90,*
         USING AVWXTABL,RAT        NOTE MAIN TABLE USING
OP1      EQU   IAL2+1              COMMON MASK FIELD==>LIT ALLOWED,H AL
OP3      EQU   IAL2+3              MASK FIELD==>LIT ALLOWED, FULL ALIG
OP7      EQU   IAL2+7              MASK FIELD==>LIT ALLOWED,D ALIGN
IAR      EQU   IAA+IAB             MASK FIELD==>R1 AND R2 MUST BE EVEN
         ENTRY OPINIT,OPFIND
         SPACE 2
**--> ENTRY: OPINIT   1   INITILIAZE OPCODE ROUTINE IF NEEDED . . . . .
*.       AS OF 8/17/70, THIS ENTRY DOES NOTHING. IT IS INCLUDED FOR   .
*.       COMPLETENESS, POSSIBLE MODIFICATION REQUIRING INITIALIZATION..
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
OPINIT   BR    R14                 RETURN-NOTHING TO DO NOW
         SPACE 2
**--> ENTRY: OPFIND   1   LOOK UP AN OPCODE . . . . . . . . . . . . . .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER TO 1ST CHARACTER OF OPCODE                      .
*.       EXIT CONDITIONS                                              .
*.  RA = SCAN POINTER TO 1ST BLANK FOLLOWING LEGAL OPCODE,OR SAME AS O.
*.       ENTRY IF OPCODE WAS NOT RECOGNIZED.                          .
*.  RB = 0 IF THE OPCODE WAS FOUND IN OPCODE TABLE                    .
*.  RB = NONZERO VALUE - ERROR CODE FOR ILLEGAL OPCODE ($ERIVOPC)     .
*.  RC = ADDRESS OF OPCODTB ENTRY FOR THE OPCODE, IF IT WAS FOUND     .
*.       USES DSECTS: AVWXTABL,OPCODTB                                .
*.       USES MACROS: $RETURN,$SAVE,OPG,OPGT                          .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
OPFIND   $SAVE RGS=(R1-R2),SA=NO
         CLI   0(RA),C'A'          MAKE SURE NO ILLEGAL
         BL    OPFERR              ILLEGAL,NOTE ERROR
         LR    R1,RA               DUPLICATE THE SCAN POINTER
         LA    RE,6(R1)            GET THE LIMIT FOR THE BXLE
         LA    RD,1                GET INCREMENT FOR BXLE
         SPACE 1
*              SCAN LOOP TO FIND END OF MNEMONIC                      *
OPFLOOP  CLI   1(R1),C' '          LOOK FOR BLANK
         BE    OPFLNG              BLANK FOUND-END OF OPCODE
         BXLE  R1,RD,OPFLOOP       CONTINUE SEARCHING
         B     OPFERR              ERROR- NOT RIGHT SIZE
         SPACE 1
*              END OF MNEMONIC FOUND, GET POINTERS ET UP FOR LOOKUP   *
OPFLNG   LR    R2,R1               DUPLICATE PT TO LAST CHAR OF OPCODE
         SR    R2,RA               GET LENGTH-1 OF OPCODE = 0-7
         STC   R2,OPFCOMP+1        PLACE INTO CLC INSTRUCTION
         LA    RD,OPCMNEM-OPCODTB+1(R2)      GET TOTAL LENGTH OF ENTRY
         IC    R2,OPFL1(R2)        GET 1ST OFFSET VALUE,DEPNDING ON LEN
         LTR   R2,R2               MAKE SURE THERE ARE SOME OF THIS LEN
         BZ    OPFERR              NO THERE AREN'T-ERROR
         SPACE 1
         LA    RE,OPADS(R2)        ADDR OF RIGHT TABLE SET
         IC    R2,0(RA)            GET THE 1ST CHAR OF OPCODE
         IC    R2,OPFCH1-C'A'(R2)  GET 2ND OFFSET VALUE FOR LETTERS
         LH    RC,0(R2,RE)         GET THE CORRECT POINTER
         AR    RC,R15              ADD ADDRESS OF OPFIND TO GET REAL AD
         USING OPCODTB,RC          NOTE DSECT FOR TABLE ENTRY
         LH    RE,2(R2,RE)         GET THE LIMIT ADDRESS IN TABLE
         AR    RE,R15              ADD TO GET REAL ADDRESS
         SPACE 1
*              SEARCH LOOP TO LOOK UP MNEMONIC                        *
OPFCOMP  CLC   0($CHN,RA),OPCMNEM  COMPARE MNEMONIC WITH TABLE ENTRY
         BNH   OPFCHK              IF NOT HIGH, EITHER SAME, OR NO GOOD
         BXLE  RC,RD,OPFCOMP       CONTINUE LOOPING
OPFCHK   BNE   OPFERR              NE==>ERROR(GET LOOP FALL THRU TOO)
         SPACE 1
         SR    RB,RB               CLEAR RB TO SHOW OK.
         LA    RA,1(R1)            UPDATE SCAN POINTER TO BLANK
OPFRET   $RETURN RGS=(R1-R2),SA=NO
OPFERR   LA    RB,$ERIVOPC         INVALID OPCODE
         B     OPFRET              RETURN
         EJECT
* * * * * INTERNAL CONSTANTS                                          *
*        1ST LEVEL POINTER TABLE-HAS OFFSET ADDRESSES OF POINTER SETS *
*        BELONGING TO EACH USABLE OPCODE LENGTH FROM 1 TO 8.          *
OPFL1    DC    AL1(OPF1-OPADS,OPF2-OPADS,OPF3-OPADS,OPF4-OPADS,OPF5-OPA#
               DS,OPF6-OPADS,OPF7-OPADS,OPF8-OPADS)
         SPACE 2
*        INDIVIDUAL OPCODTB ENTRY TABLES, IN ORDER BY LENGTH, THEN    *
*        ALPHABETICALLY WITHIN LENGTH                                 *
         SPACE 1
*              1-CHARACTER INSTRUCTIONS                               *
OP1A     EQU   *
         OPG   A,$RX,90,OP3        ADD
OP1B     EQU   *
         OPG   B,$RXM,71,X'F0'+1   BRANCH
OP1C     EQU   *
         OPG   C,$RX,89,OP3        COMPARE
OP1D     EQU   *
         OPG   D,$RX,93,OP3+IAA    DIVIDE
OP1L     EQU   *
         OPG   L,$RX,88,OP3        LOAD
OP1M     EQU   *
         OPG   M,$RX,92,OP3+IAA    MULTIPLY
OP1N     EQU   *
         OPG   N,$RX,84,OP3        AND
         OPG   O,$RX,86,OP3        OR
OP1S     EQU   *
         OPG   S,$RX,91,OP3        SUBTRACT
OP1T     EQU   *
         OPG   X,$RX,87,OP3        EXCLUSIVE OR
OP1END   EQU   *
         EJECT
*              2-CHARACTER INSTRUCTIONS                               *
OP2A     EQU   *
         OPG   AD,$RX,106,OP7+IAA,F    ADD NORM LONG
         OPG   AE,$RX,122,OP3+IAA,F    ADD NORM SHORT
         OPG   AH,$RX,74,OP1       ADD HALFWORD
         OPG   AL,$RX,94,OP3       ADD LOGICAL
         OPG   AP,$SS2,250,IAL2,D  ADD DECIMAL
         OPG   AR,$RR,26           ADD REGISTER
         OPG   AU,$RX,126,OP3+IAA,F    ADD UNNORM SHORT
         OPG   AW,$RX,110,OP7+IAA,F    ADD UNNORM LONG
OP2B     EQU   *
         OPG   BC,$RX,71,1         BRANCH ON CONDITION
         OPG   BE,$RXM,71,X'80'+1  BRANCH ON EQUAL
         OPG   BH,$RXM,71,X'20'+1  BRANCH ON HIGH
         OPG   BL,$RXM,71,X'40'+1  BRANCH ON LOW
         OPG   BM,$RXM,71,X'40'+1  BRANHC ON MINUS
         OPG   BO,$RXM,71,X'10'+1  BRANCH ON ONES
         OPG   BP,$RXM,71,X'20'+1  BRANCH ON PLUS
         OPG   BR,$RRM,7,X'F0'     BRANCH REGISTER
         OPG   BZ,$RXM,71,X'80'+1  BRANCH ON ZERO
OP2C     EQU   *
         OPG   CD,$RX,105,OP7+IAA,F    COMPARE LONG
         OPG   CE,$RX,121,OP3+IAA,F    COMPARE SHORT
         OPG   CH,$RX,73,OP1       COMPARE HALFWORD
         OPG   CL,$RX,85,OP3       COMPARE LOGICAL
         OPG   CP,$SS2,249,IAL1+IAL2,D       COMPARE DECIMAL
         OPG   CR,$RR,25           COMPARE REGISTER
OP2D     EQU   *
         OPG   DC,$IDC+$IB,$IBSTAR1          DEFINE CONSTANT
         OPG   DD,$RX,109,OP7+IAA,F    DIVIDE LONG
         OPG   DE,$RX,125,OP3+IAA,F    DIVIDE SHORT
         OPG   DP,$SS2,253,IAL2,D  DIVIDE DECIMAL
         OPG   DR,$RR,29,IAA       DIVIDE REGISTER
         OPG   DS,$IDS+$IB,$IBSTAR1          DEFINE STORAGE
         OPG   ED,$SS,222,IAL2,D   EDIT
         OPG   EX,$RX,68,OP1       EXECUTE
         OPG   IC,$RX,67,IAL2      INSERT CHARACTER
OP2L     EQU   *
         OPG   LA,$RX,65,IAL2      LOAD ADDRESS
         OPG   LD,$RX,104,OP7+IAA,F    LOAD LONG
         OPG   LE,$RX,120,OP3+IAA,F    LOAD SHORT
         OPG   LH,$RX,72,OP1       LOAD HALFWORD
         OPG   LM,$RS,152,OP3      LOAD MULTIPLE
         OPG   LR,$RR,24           LOAD REGISTER
         EJECT
OP2M     EQU   *
         OPG   MD,$RX,108,OP7+IAA,F    MULTIPLY LONG
         OPG   ME,$RX,124,OP3+IAA,F    MULTIPLY SHORT
         OPG   MH,$RX,76,OP1       MULTIPLY HALFWORD
         OPG   MP,$SS2,252,IAL2,D  MULTIPLY DECIMAL
         OPG   MR,$RR,28,IAA       MULTIPLY REGISTER
OP2N     EQU   *
         OPG   NC,$SS,212,IAL2     AND CHARACTER
         OPG   NI,$SI,148          AND IMMEDIATE
         OPG   NR,$RR,20           AND REGISTER
         OPG   OC,$SS,214,IAL2     OR CHARACTER
         OPG   OI,$SI,150          OR IMMEDIATE
         OPG   OR,$RR,22           OR REGISTER
OP2S     EQU   *
         OPG   SD,$RX,107,OP7+IAA,F    SUBTRACT NORM LONG
         OPG   SE,$RX,123,OP3+IAA,F    SUBTRACT NORM SHORT
         OPG   SH,$RX,75,OP1       SUBTRACT HALFWORD
         OPG   SL,$RX,95,OP3       SUBTRACT LOGICAL
         OPG   SP,$SS2,251,IAL2,D  SUBTRACT DECIMAL
         OPG   SR,$RR,27           SUBTRACT REGISTER
         OPG   ST,$RX,80,3         STORE
         OPG   SU,$RX,127,OP3+IAA,F    SUBTRACT UNNORM SHORT
         OPG   SW,$RX,111,OP7+IAA,F    SUBTRACT UNNORM LONG
OP2T     EQU   *
         OPG   TM,$SI,145,IAL1     TEST UNDER MASK
         OPG   TR,$SS,220,IAL2     TRANSLATE
         OPG   TS,$RSO,147         TEST AND SET (ONLY NON-PRIV TYPE)
         OPG   XC,$SS,215,IAL2     EXCLUSIVE OR CHARACTER
         OPG   XI,$SI,151          EXCLUSIVE OR IMMEDIATE
         OPG   XR,$RR,23           EXCLUSIVE OR REGISTER
OP2END   EQU   *
         EJECT
*              3-CHARACTER INSTRUCTIONS                               *
OP3A     EQU   *
         OPG   ADR,$RR,42,IAR,F       ADD NORM LONG REGISTER
         OPG   AER,$RR,58,IAR,F       ADD NORM SHORT REGISTER
         OPG   AGO,$IM,$AGO,,M
         OPG   AIF,$IM,$AIF,,M
         OPG   ALR,$RR,30          ADD LOGICAL REGISTER
         OPG   AUR,$RR,62,IAR,F       ADD UNNORM SHORT REGISTER
         OPG   AWR,$RR,46,IAR,F       ADD UNNORM LONG REGISTER
         OPG   AXR,$RR,54,IAR,FX        ADD EXTENDED REGISTER
OP3B     EQU   *
         OPG   BAL,$RX,69,1        BRANCH AND LINK
         OPG   BCR,$RR,7           BRANCH ON CONDITION REGISTER
         OPG   BCT,$RX,70,1        BRANCH ON COUNT
         OPG   BER,$RRM,7,X'80'    **EXTENDED BRANCH MNEMONIC**       J
         OPG   BHR,$RRM,7,X'20'    **EXTENDED BRANCH MNEMONIC**       J
         OPG   BLR,$RRM,7,X'40'    **EXTENDED BRANCH MNEMONIC**       J
         OPG   BMR,$RRM,7,X'40'    **EXTENDED BRANCH MNEMONIC**       J
         OPG   BNE,$RXM,71,X'70'+1 BRANCH ON NOT EQUAL
         OPG   BNH,$RXM,71,X'D0'+1 BRANCH ON NOT HIGH
         OPG   BNL,$RXM,71,X'B0'+1 BRANCH ON NOT LOW
         OPG   BNM,$RXM,71,X'B0'+1 BRANCH ON NOT MINUS
         OPG   BNO,$RXM,71,X'E0'+1 BRANCH ON NOT ONES
         OPG   BNP,$RXM,71,X'D0'+1 BRANCH ON NOT PLUS
         OPG   BNZ,$RXM,71,X'70'+1 BRANCH ON NOT ZERO
         OPG   BOR,$RRM,7,X'10'    **EXTENDED BRANCH MNEMONIC**       J
         OPG   BPR,$RRM,7,X'20'    **EXTENDED BRANCH MNEMONIC**       J
         OPG   BXH,$RS,134,1       BRANCH ON INDEX HIGH
         OPG   BZR,$RRM,7,X'80'    **EXTENDED BRANCH MNEMONIC**       J
OP3C     EQU   *
         OPG   CCW,$ICCW+$IB,$IBSTAR1,7,P    CHANNEL COMMAND WORD
         OPG   CDR,$RR,41,IAR,F       COMPARE LONG REGISTER
         OPG   CER,$RR,57,IAR,F       COMAPRE SHORT REGISTER
         OPG   CLC,$SS,213,IAL1+IAL2         COMPARE LOGICAL CHARACTER
         OPG   CLI,$SI,149,IAL1    COMPARE LOGICAL IMMEDIATE
         OPG   CLM,$RS,189,IAL2,S370    COMPARE LOGICAL UNDER MASK
         OPG   CLR,$RR,21          COMPARE LOGICAL REGISTER
         OPG   CVB,$RX,79,OP7      CONVERT TO BINARY
         OPG   CVD,$RX,78,7        CONVERT TO DECIMAL
OP3D     EQU   *
         OPG   DDR,$RR,45,IAR,F       DIVIDE LONG REGISTER
         OPG   DER,$RR,61,IAR,F       DIVIDE SHORT REGISTER
         OPG   END,$IEND+$IB,IBOMOP+IBNONAM+IBMOSPEC  END
         OPG   EQU,$IEQU+$IB,IBNENAM+$IBSTAR1,1        EQUATE
         OPG   HDR,$RR,36,IAR,F       HALVE LONG
         OPG   HER,$RR,52,IAR,F       HALVE SHORT
         OPG   HIO,$RSO,158,,P     HALT I/O
         OPG   ICM,$RS,191,IAL2,S370    INSERT CHARACTERS UNDER MASK
         OPG   ISK,$RR,9,,P        INSERT STORAGE KEY
OP3L     EQU   *
         OPG   LCR,$RR,19          LOAD COMPLEMENT REGISTER
         OPG   LDR,$RR,40,IAR,F       LOAD LONG REGISTER
         OPG   LER,$RR,56,IAR,F       LOAD SHORT REGISTER
         OPG   LNR,$RR,17          LOAD NEGATIVE REGISTER
         OPG   LPR,$RR,16          LOAD POSITIVE REGISTER
         OPG   LTR,$RR,18          LOAD AND TEST REGISTER
         EJECT
OP3M     EQU   *
         OPG   MDR,$RR,44,IAR,F       MULTIPLY LONG REGISTR
         OPG   MER,$RR,60,IAR,F       MULTIPLY SHORT REGISTER
         OPG   MVC,$SS,210,IAL2    MOVE CHARACTER
         OPG   MVI,$SI,146         MOVE IMMEDIATE
         OPG   MVN,$SS,209,IAL2    MOVE NUMERICS
         OPG   MVO,$SS2,241,IAL2   MOVE WITH OFFSET (2 LENGTHS)
         OPG   MVZ,$SS,211,IAL2    MOVE ZONES
         OPG   MXD,$RX,103,IAA+OP7,FX   MULTIPLY EXTENDED/LONG
         OPG   MXR,$RR,38,IAR,FX        MULTIPLY EXTENDED REGISTER
OP3N     EQU   *
         OPG   NOP,$RXM,71,X'00'+1 NO OPERATION
         OPG   ORG,$IORG+$IB,IBNONAM+IBOMOP+$IBSTAR1   ORIGIN
         OPG   RDD,$SI,133,,P      READ DIRECT
OP3S     EQU   *
         OPG   SCK,$RSO,178,X'40'+OP7,P370   SET CLOCK
         OPG   SDR,$RR,43,IAR,F       SUBTRACT NORM LONG REGISTER
         OPG   SER,$RR,59,IAR,F       SUBTRACT NORM SHORT REGISTER
         OPG   SIO,$RSO,156,,P     START I/O
         OPG   SLA,$RSH,139,IAL2   SHIFT LEFT ALGEBRAIC
         OPG   SLL,$RSH,137,IAL2   SHIFT LEFT LOGICAL
         OPG   SLR,$RR,31          SUBTRACT LOGICAL REGISTER
         OPG   SPM,$RSO,4
         OPG   SRA,$RSH,138,IAL2   SHIFT RIGHT ALGEBRAIC
         OPG   SRL,$RSH,136,IAL2   SHIFT RIGHT LOGICAL
         OPG   SRP,$SS2,240,,S370   SHIFT AND ROUND PACKED
         OPG   SSK,$RR,8,,P        SET STORAGE KEY
         OPG   SSM,$RSO,128,,P     SET SYSTEM MASK
         OPG   STC,$RX,66          STORE CHARACTER
         OPG   STD,$RX,96,7+IAA,F      STORE LONG
         OPG   STE,$RX,112,3+IAA,F     STORE SHORT
         OPG   STH,$RX,64,1        STORE HALFWORD
         OPG   STM,$RS,144,3       STORE MULTIPLE
         OPG   SUR,$RR,63,IAR,F       SUBTRACT UNNORM SHORT REGISTER
         OPG   SVC,$RSO,10         SUPERVISOR CALL
         OPG   SWR,$RR,47,IAR,F       SUBTRACT UNNORM LONG REGISTER
         OPG   SXR,$RR,55,IAR,FX        SUBTRACT EXTENDED REGISTER
OP3T     EQU   *
         OPG   TCH,$RSO,159,,P     TEST CHANNEL
         OPG   TIO,$RSO,157,,P     TEST I/O
         OPG   TRT,$SS,221,IAL1+IAL2         TRANSLATE AND TEST
         OPG   WRD,$SI,132,,P      WRITE DIRECT
         OPG   ZAP,$SS2,248,IAL2,D ZERO AND ADD DECIMAL
OP3END   EQU   *
         EJECT
*              4-CHARACTER INSTRUCTIONS                               *
OP4A     EQU   *
         OPG   ACTR,$IM,$ACTR,,M
         OPG   ANOP,$IM,$ANOP,,M
OP4B     EQU   *
         OPG   BALR,$RR,5          BRANCH AND LINK REGISTER
         OPG   BCTR,$RR,6          BRANCH ON COUNT REGISTER
         OPG   BNER,$RRM,7,X'70'   **EXTENDED BRANCH MNEMONIC**       J
         OPG   BNHR,$RRM,7,X'D0'   **EXTENDED BRANCH MNEMONIC**       J
         OPG   BNLR,$RRM,7,X'B0'   **EXTENDED BRANCH MNEMONIC**       J
         OPG   BNMR,$RRM,7,X'B0'   **EXTENDED BRANCH MNEMONIC**       J
         OPG   BNOR,$RRM,7,X'E0'   **EXTENDED BRANCH MNEMONIC**       J
         OPG   BNPR,$RRM,7,X'D0'   **EXTENDED BRANCH MNEMONIC**       J
         OPG   BNZR,$RRM,7,X'70'   **EXTENDED BRANCH MNEMONIC**       J
         OPG   BXLE,$RS,135,1      BRANCH INDEX LOW OR EQUAL          J
OP4C     EQU   *
         OPG   CLCL,$RR,15,IAR,S370     COMPARE LOGICAL CHARACTERS LONG
         OPG   CNOP,$ICNOP+$IB,IBNONAM+$IBSTAR1        CONDITIONAL NOP
OP4D     EQU   *
         AIF   (&$DEBUG).OPDIAG    SKIP DIAGNOSE IF NOT DEBUG MODE
         OPG   DIAG,$SI,131        DIAGNOSE(EXECUT EQUIV OF DEBUG)
.OPDIAG  ANOP
         OPG   DROP,$IDROP+$IB,IBNONAM       DROP REGISTER
         OPG   EDMK,$SS,223,IAL2,D EDIT AND MARK
         OPG   GBLA,$IM,$GBLA,$ARITH,M
         OPG   GBLB,$IM,$GBLB,$BOOL,M
         OPG   GBLC,$IM,$GBLC,$CHAR,M
OP4L     EQU   *
         OPG   LCDR,$RR,35,IAR,F      LOAD COMPLEMENT LONG REGISTER
         OPG   LCER,$RR,51,IAR,F      LOAD COMPLEMENT SHORT REGISTER
         OPG   LCLA,$IM,$LCLA,$ARITH,M
         OPG   LCLB,$IM,$LCLB,$BOOL,M
         OPG   LCLC,$IM,$LCLC,$CHAR,M
         OPG   LCTL,$RS,183,OP3,P370    LOAD CONTROL
         OPG   LNDR,$RR,33,IAR,F      LOAD NEGATIVE LONG REGISTER
         OPG   LNER,$RR,49,IAR,F      LOAD NEGATIVE SHORT REGISTER
         OPG   LPDR,$RR,32,IAR,F      LOAD POSITIVE LONG REGISTER
         OPG   LPER,$RR,48,IAR,F      LOAD POSITIVE SHORT REGISTER
         OPG   LPSW,$RSO,130,7,P   LOAD PROGRAM STATUS WORD
         OPG   LRDR,$RR,37,IAR,FX       LOAD ROUNDED EXTENDED ==> LONG
         OPG   LRER,$RR,53,IAR,FX     LOAD ROUNDED LONG ==> SHORT
         OPG   LTDR,$RR,34,IAR,F      LOAD AND TEST LONG REGISTER
         OPG   LTER,$RR,50,IAR,F      LOAD AND TEST SHORT REGISTER
OP4M     EQU   *
         OPG   MEND,$IM,$MEND,,M
         OPG   MVCL,$RR,14,IAR,S370     MOVE CHARACTERS LONG
         OPG   MXDR,$RR,39,IAR,FX       MULTIPLY EXTENDED / LONG REG
OP4N     EQU   *
         OPG   NOPR,$RRM,7,X'00'   NO OPERATION
         OPG   PACK,$SS2,242,IAL2  PACK
OP4S     EQU   *
         OPG   SETA,$IM,$SETA,$ARITH,M
         OPG   SETB,$IM,$SETB,$BOOL,M
         OPG   SETC,$IM,$SETC,$CHAR,M
         OPG   SIOF,$RSO,156,X'10',P370      START I/O FAST
         OPG   SLDA,$RSH,143,IAL2+IAA        SHIFT LEFT DOUBLE ALGEBRAI
         OPG   SLDL,$RSH,141,IAL2+IAA        SHIFT LEFT DOUBLE LOGICAL
         OPG   SRDA,$RSH,142,IAL2+IAA        SHIFT RIGHT DOUBLE ALGEBRA
         OPG   SRDL,$RSH,140,IAL2+IAA        SHIFT RIGHT DOUBLE LOGICAL
         OPG   STCK,$RSO,178,X'50',P370      STORE CLOCK
         OPG   STCM,$RS,190,,S370       STORE CHARACTERS UNDER MASK
OP4T     EQU   *
         OPG   UNPK,$SS2,243,IAL2  UNPACK
         AIF   (&$XXIOS).OP4TSK1   SKIP IF NO XGETS ALLOWED     CPP
         OPG   XGET,$SPC,224,X'A0'  GENERAL INPUT              D
.OP4TSK1 AIF   (NOT &$EXINT).OP4TSK2  SKIP IF NO XOPC'S         CPP
         OPG   XOPC,$RSO,1         EXTENDED USER DEBUG CONTROL INSTR
.OP4TSK2 AIF   (&$XXIOS).OP4TSK    SKIP IF NO XPUTS ALLOWED     CPP
         OPG    XPUT,$SPC,224,X'C0'+IAL2  GENERAL OUTPUT OP           J
.OP4TSK  ANOP
OP4END   EQU   *
         EJECT
*              5-CHARACTER INSTRUCTIONS                               *
OP5A     EQU   *
OP5B     EQU   *
OP5C     EQU   *
         OPG   CSECT,$ICSECT+$IB,IBOMOP      CSECT
OP5D     EQU   *
         AIF   (&$DEBUG).OPNOD1    SKIP IF NOT DEBUG MODE
         OPG   DEBUG,$IDEBUG+$IB   DEBUG FLAG SETTING OPCODE
.OPNOD1  ANOP
         OPG   DSECT,$IDSECT+$IB,IBOMOP+IBNENAM        DUMMY SECTION
         OPG   EJECT,$IEJECT+$IB,IBNONAM+IBOMOP+IBMOPRCX,255 EJECT
         OPG   ENTRY,$IENTRY+$IB,IBNONAM     ENTRY DECLARATION
         OPG   EXTRN,$IEXTRN+$IB,IBNONAM     EXTERNAL DECLARATION
OP5L     EQU   *
         OPG   LTORG,$ILTORG+$IB,IBOMOP+$IBSTAR1       LTORG
OP5M     EQU   *
         OPG   MACRO,$IM,$MACRO,,M
         OPG   MEXIT,$IM,$MEXIT,,M
         OPG   MNOTE,$IM,$MNOTE,,M
OP5N     EQU   *
         OPG   PRINT,$IPRINT+$IB,IBNONAM+IBMOPRCX,$IBPON+$IBPGEN
OP5S     EQU   *
         OPG   SPACE,$ISPACE+$IB,IBNONAM+IBOMOP+IBMOPRCX,1 SPACE
         OPG   START,$ISTART+$IB,IBOMOP      START
         OPG   STCTL,$RS,182,3,P370    STORE CONTROL
         OPG   STIDC,$RSO,178,X'30',P370     STORE CHANNEL ID
         OPG   STIDP,$RSO,178,X'20',P370     STORE CPU ID
OP5T     EQU   *
         OPG   TITLE,$ITITLE+$IB,IBNONAM+IBMOPRCX,0   TITLE
         OPG   USING,$IUSING+$IB,IBNONAM+$IBSTAR1      USING
         AIF   (NOT &$XIOS).OPNOXIO          SKIP IF NO XIOS WANTED
         OPG   XDECI,$RX,83        DECIMAL INPUT
         OPG   XDECO,$RX,82        DECIMAL OUTPUT
         OPG   XDUMP,$SPC,224,X'60'+IAL2     DUMP
         AIF   (NOT &$HEXI).OPNOHXI    SKIP IF NO XHEXI
         OPG   XHEXI,$RX,97            OP CODE FOR XHEXI
.OPNOHXI ANOP
         AIF   (NOT &$HEXO).OPNOHXO    SKIP IF NO XHEXO
         OPG   XHEXO,$RX,98            OP CODE FOR XHEXO
.OPNOHXO ANOP
         AIF   (NOT &$XIOS).OPNOXIO  SKIP IF NO X-I/O PSEUDOS   CPP
         OPG   XLIMD,$SPC,224,X'80'    LIMIT AREA (COMPLETION DUMP)
         OPG   XPNCH,$SPC,224,X'40'+IAL2     PUNCH
         OPG   XPRNT,$SPC,224,X'20'+IAL2     PRINT
         OPG   XREAD,$SPC,224,X'00'          READ
.OPNOXIO ANOP
         AIF   (&$REPL EQ 0).OPNREPL        SKIP IF NOT REPLACE
         OPG   XREPL,$SI,160       XREPL SPECIAL COMMAND
.OPNREPL ANOP
OP5END   EQU   *
         SPACE 2
*        SECOND LEVEL OFFSET TABLE - HAS POINTERS FOR EACH BEGINNING  *
*        CHARACTER, IN TABLE DETERMINED BY LENGTH.                    *
*   TR TABLE      0 1 2 3 4 5 6 7 8 9 A B C D E F                     *
OPFCH1   DC      X'000204060606060606060606060606'     C
         DC    X'060606080A0C0C0C0C0C0C0C0C0C0C0C'     D
         DC    X'0C0C0E10101010101010101010101010'     E
         DC    X'10101010101010101010101010101010'     F
         SPACE 2
*        OFFSET VALUES INTO OPCODTB ENTRY AREA                        *
OPADS    DS    H                   BASE ADDRESS OF 2ND LEVEL OFFSET TAB
         OPGT
         DROP  REP,RC              CLEAN UP USINGS
         TITLE '*** OUTPUT - SOURCE AND OBJECT LISTING ***'
**--> CSECT: OUTPUT       PRINTED LISTING ROUTINE . . . . . . . . . . .
*.       OUTPUT HANDLES THE FORMATTING AND PRINTING OF THE ASSEMBLY   .
*.       LISTING FOR THE ASSIST ASSEMBLER.                            .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
OUTPUT   CSECT
         $DBG  C0,SNAP
         ENTRY OUINT1,OUTPT2,OUEND2
         USING AVWXTABL,RAT        NOTE MAIN TABLE USING
         SPACE 1
*              LIST OF LINE/PAGE CONTROL EQUATE VALUES FOLLOWS.
$OU#LNS  EQU   60                  MAXIMUM PRINTED LINES/PAGE
OUH#     EQU   3                   # LINES USED BY STANDARD HEADING
$OU#NORM EQU   $OU#LNS-OUH#        NORMAL LINES/PAGE FOR ACTIAL STMTS
$OU#PAG1 EQU   $OU#NORM-5          # LINES FOR STMTS ON 1ST PAGE ONLY
         SPACE 1
**--> ENTRY: OUINT1   1   INITIALIZATION ENTRY - CALLED BEFORE PASS 1 .
*.       OUINT1 IS CALLED TO INITIALIZE FLAG VALUES AND COUNTERS      .
*.       USED IN OUTPUT, INCLUDING LISTING CONTROL, STATEMENT #,      .
*.       PAGE COUNT, WITHIN-PAGE LINE COUNT, AND TITLE AREA.          .
*.       USES DSECTS: AVWXTABL                                        .
*.       USES MACROS: $RETURN,$SAVE                                   .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         SPACE 1
OUINT1   $SAVE SA=NO
         AIF   (&$COMNT EQ 0).OUNCOM1       SKIP IF NO COMMENT CHK
         MVC   AVMACHIN(4),AWZEROS ZERO VARIABLES(SEE IAMOP1 CSECT)
.OUNCOM1 ANOP
         MVI   AVPRINT,$IBPON+$IBPGEN       PRINT ON,GEN,NODATA
         TM    AVTAGS1,AJNLIST     IS LIST ON         OR OFF
         BO    *+8                 SKIP IF LIST IS OFF
         OI    AVPRINT,$IBPLIST    SHOW LIST IS ON FOR LATER TEST
         MVC   AVPRINT1,AVPRINT    COPY VALUE FOR USE DURING PASS 1
         ZAP   OULNCNT,AWP1        SET CURRENT STMT # = 1
         ZAP   OUPGCNT,AWP0        SET PAGE COUNT TO ZERO LASO
         MVC   OUCOUNT,AWH1        INIT WITHIN PAGE COUNT TO 1
         MVC   OUHEADNG,AWBLANK    BLANK OUT SPOT FOR HEADING
*              FOLLOWING STMTS HELP AVOID WASTED 1ST PAGE LISTING.
         LA    RE,$OU#PAG1         # LINES FOR STMTS ON 1ST PAGE ONLY
         STH   RE,OUH#LINE         SET COUNTERSETTER TO INITIAL VALUE
         MVI   OUHEAD1,C'0'        JUST DO DOUBLESPACE 1ST TIME
         AIF   (NOT &$CMPRS).OUINCM         SKIP IF NO COMPRESS CODE
         SPACE 2
*              CMPRS OPTION INITIALIZATION&TESTING - IF ON, GET
*              SPACE FOR OUCMPRSD BLOCK, INIT VARIABLES.
         SPACE 1
         TM    AVTAGS2,AJOCMPRS    IS CMPRS OPTION USED
         BZ    OUINOCMP            NO, SO DON'T GET SPACE
         SPACE 1
         LA    RA,OUCMPR$L         TOTAL LENGTH OF OUCMPRSD BLOCK
         $ALLOCH RB,RA,OUINCMOV    ACQUIRE AREA
         USING OUCMPRSD,RB         NOTE PTR THERE
         ST    RB,OUCMPRAD         STORE @ BLOCK FOR OUTPT2 USE
         LA    RE,$OU#PAG1+OUH#    TOTAL # LINES FOR PAGE 1
         STH   RE,OUCMOPAG         SET # LINES ON FIRST PAGE ONLY
         STH   RE,OUCMLEFT         SET # LINES LEFT IN OUCMSAVE,PAGE1
         SPACE 1
         LA    RC,OUCMSAVE         @ 1ST BYTE OF STORAGE AREA
         ST    RC,OUCMSTMT         SET @ SO 1ST STMT WILL BE THERE
         NI    OUCMPHAS,255-OUCMPHSB        SHOW OUTPT2 IN PHASE 'A'
         MVI   OUCMCCIN,C'0'       MAKE INITIAL CARRIAGE CONT D SPACE
         MVC   OUCMBREK,=C'. '     INITIALZE SEPARATER FIELD
         B     OUINOCMP            SKIP OVER RESET CODE
         DROP  RB                  KILL USING
         SPACE 1
*              INSUFFICIENT SPACE - CANCEL CMPRS OPTION NOW.
OUINCMOV NI    AVTAGS2,255-AJOCMPRS         REMOVE CMPRS FLAG
OUINOCMP EQU   *
         SPACE 1
.OUINCM  ANOP
OUINRET  $RETURN SA=NO
         EJECT
**--> ENTRY: OUTPUT2      PRINT 1 STATEMENT,WITH CODE AS NEEDED,ERROR .
*.       OUTPT2 PRINTS 1 STATEMENT, WITH ANY ERROR MESSAGES NEEDED,   .
*.       PRINTS TITLES AND HEADINGS WHEN REQUIRED, PERFORMS PAGE AND  .
*.       LINE COUNTING, MAINTAINS LISTING CONTROL STATUS, AND KEEPS   .
*.       COUNTS OF NUMBER OF STATEMENTS FLAGGED, TOTAL # ERRORS,      .
*.       TOTAL # WARNING MESSAGES.                                    .
*.       ENTRY CONDITIONS                                             .
*.  RB = PRIMARY CALL TYPE CODE                                       .
*.     = 0    ($OUMACH) MACHINE INSTRUCTIONS                          .
*.     = 2    ($OUCONS) CONSTANTS,CNOPS,ETC. PRINT LOCATION COUNTER,CO.
*.     = 4    ($OULIST) - LISTING CONTROL - EJECT,SPACE,PRINT,TITLE   .
*.     = 6    ($OUCOMM) - COMMENTS,ETC.-DO NOT HAVE LOCATION COUNTER  .
*.  RC = AN INFORMATION ADDRESS OF SOME TYPE                          .
*.     = @ OBJECT CODE (RB=0,2)                                       .
*.     = @ # LINES TO SPACE (RB=4,RE=0)                               .
*.     = @ PRINT CONTROL CODE BYTE (RB=4,RE=2) I.E. PRINT             .
*.     = @ TITLE CODE (RB=4,RE=4)                                     .
*.  RD = #-1 OF BYTES OF OBJECT CODE OR TITLE                         .
*.  RE = SECONDARY CODE OR ADDRESS                                    .
*.     = SECONDARY CODE FOR LISTING CONTROL OPERATIONS                .
*.     = 0    SPACE OR EJECT                                          .
*.     = 2    PRINT                                                   .
*.     = 4    TITLE                                                   .
*.       USES DSECTS: AVWXTABL,ICBLOCK,RCODBLK,RSBLOCK,RSCBLK,REBLK   .
*.       USES MACROS: $AL2,$PRNT,$RETURN,$SAVE,$SERR                  .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         EJECT
* * * * * REGISTER USAGE FOR OUTPT2 * * * * * * * * * * * * * * * * * *
*   RW = CURRENT VALUE OF OUCOUNT. IF =1,NEW HEADING NEEDED           *
*   RX = BASE REGISTER                                                *
*   RY = UNUSED AT PRESENT                                            *
*   RZ = @ RSBLOCK BELONGING TO STATEMENT BEING PROCESSED.            *
*   R14= INTERNAL LINK REGISTER.  LOCAL WORK REGISTRE.                *
*   R15= LOCAL WORK REGISTER.                                         *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
OUTPT2   $SAVE RGS=(R14-R6),SA=NO           LEAVE R15 AS IS
         LR    RX,R15              MOVE @ OUTPT2 OVER FOR NEW BASE
         DROP  R15                 REMOVE OLD USING
         USING OUTPT2,RX           NOTE NEW USING
         SPACE 1
*              COMMON INITIALIZATION. MAKE PROCESSOR CHOICE, BASED    *
*        ON CONTENTS OF REG RB. PRINT IF PRINT ON, OR INSTRUCTION IS  *
*        A LISTING CONTROL, OR ANY STMT WITH AN ERROR IN IT.          *
         SPACE 1
         L     RZ,AVRSBPT          GET POINTER TO RSBLOCK
         USING RSBLOCK,RZ          NOTE POINTER
         LH    RW,OUCOUNT          GET WITHIN PAGE COUNT
         MVC   OUTLINE(OUTLEN),AWBLANK       BLANK OUT LEFT HAND SIDE
         AIF   (NOT &$MACROS).OUNGEN        SKIP IF NO MACRO CODE
         SPACE 1
         TM    RSBFLAG,$RSBGENR    WAS THIS GENERATED STMT
         BZ    OUNGEN              NO, NORMAL, SKIP
         MVI   OUSOURC-1,C'+'      MARK OUTPUT AS GENERATED
         TM    AVPRINT,$IBPGEN     IS PRINT GEN: SHOULD WE PRINT
         BO    OUNGEN              PRINT GEN-DEFINITELY PRINT
*              FOLLOWING STMTS ALLOW GENERATED PRINT STMTS TO BE USED.
*        WARNING: EXTENSION FROM ASMBLER F.
         CH    RB,=AL2($OULIST)    IS IT LISTING CONTROL STMT
         BNE   OUTRETE             NO, NOT LISTING CONTROL - GO CHK
         CH    RE,=H'2'            WS IT ACTUALLY  PRINT
         BNE   OUTRETE             NO, SO IGNORE IT
*              YES, FALL THRU AND DO IT
OUNGEN   EQU   *                   SKIP HERE IF NOT GEN'D STMT
         SPACE 1
.OUNGEN  ANOP
         LH    R14,OUJUMP1(RB)     GET PRIMARY TUPE OF STATEMENT
         TM    AVPRINT,$IBPON+$IBPLIST SET CC=3 IF PRINT ON AND LIST
OUTJ1    BAL   R14,OUTJ1(R14)      GO TO RIGHT CODE, WITH CC SET
*              IF SPECIFIC STMT TYPE CODE DOESN'T WANT TO PROCESS IT,
*              IT CAN RETURN HERE VIA A BCR NO,R14, AND STMT WON'T BE
*              PRINTED UNLESS IT HAS ERRORS IN IT.
         SPACE 1
OUTRETE  TM    RSBFLAG,$REBX+$RSBMERR  ARE THERE ANY ERRORS/ERR RECRD
         BZ    OUTRETA             XKIP IF NONE,PRINT STMT IF SO
         EJECT
*              OUTSTMT - FORMAT AND PRINT STATEMENT,WITH ERRORS       *
*              NORMALLY ENTERED AFTER INDIVIUDAL TYPE PROCESSING.
OUTSTMT  EQU   *                   COME HERE IF STMT SHOULD BE PRINTED
         AIF   (NOT &$MACROS).OUNMAC1       SKIP IF NO MACROS ALLOWED
         TM    RSBFLAG,$RSBNPNN    WAS THIS NOT TO BE NUMBERED
         BO    OUTSTMTN            NO NUMBER - SKIP EDITING
.OUNMAC1 ANOP
         SPACE 2
         MVC   OUDSTMNT-1(6),AWEP6     COPY THE EDIT PATTERN
         ED    OUDSTMNT-1(6),OULNCNT         FORMAT STATEMENT #
*              GET 1ST(OR ONLY) CARD-IMAGE IN PLACE FOR PRINTING      *
*              NEXT STMT ASSUMES 1ST CARD OF SEVERAL IS 71 BYTES LONG.
OUTSTMTN LA    R1,RSOL1-1          NORMAL LENGTH-1, CLEAR FOR INSERT
         L     R2,AVRSCPT          GET @ RSCBLK,IF IT EXISTS
         USING RSCBLK,R2           NOTE USING,FOR ANY SECTION REQUIRING
         CLI   RSBNUM,1            WAS THERE ONLY 1 CARD
         BNE   OUTC1B              NO, SKIP, R1 ALREADY SET OK
OUTC1A   IC    R1,RSBLENG          GET THE LENGTH OF RSBLOCK, 1 SOURCE
         LA    R1,(255-RSB$L)(R1)  SUBTRACT LENGTH, LOW-ORDER BYTE-WISE
         MVC   OUSOURCE,AWBLANK+9           BLANK STMT, CONT/SEQNO
         SPACE 1
         AIF   (NOT &$MACROS).OUNMAC2  SKIP IF NO MACRO
         TM    RSBFLAG,$RSBMERR    SPECIAL ERROR FORMT STMT
         BZ    OUTC1B              NO, SO SKIP SPECIAL FORMATTING
         SPACE 1
*              SPECIAL ERROR MESSAGE - ISSUED BY MACRO PROCESSOR -
*              STMT IMAGE IS CONSTRUCTED TEXT OF ERROR MESSAGE.
*              **NOTE** THESE ARE NOT CURRENTLY COUNTED AS ERRORS
         STC   R1,OURSBMOV+1       PUT L-1 INTO MOVE FOR MESSAGE
         MVC   OUTLINE+1(L'OUTERRAS-1),OUTERRAS+1  ERROR PTR ON LEFT
         MVC   OUCONSQ+1(8),OUTEREND+1 ERROR PTE ON RIGHT
OURSBMOV MVC   OUTLINE+L'OUTERRAS($),RSBSOURC   MOVE MESSAGE IN
         B     OUTSPRNT            GO PRINT WITHOUT FURHTER ADO
.OUNMAC2 ANOP
         SPACE 1
OUTC1B   STC   R1,*+5              STORE LENGTH-1 INTO NEXT INSTR
         MVC   OUSOURC($CHN),RSBSOURC        MOVE VARIABLE LENGTH OVER
         SPACE 1
*              PLACE CONTINUATION SEQNO IN IF NEEDED                  *
         TM    RSBFLAG,$RSCX       DO WE HAVE CONT/SEQN
         BZ    OUTSPRNT            NO,DON'T NEED CONT/SEQN
         MVC   OUCONSQ,RSCONSQ     MOVE FIELD IN
         SPACE 1
OUTSPRNT EQU   *                   POINT FOR PRINTING 1ST /ONLY CARD
OUTSPRNU BAL   R14,OUTLNSA         HAVE THE STMT PRINTED
         CLI   RSBNUM,1            WAS THERE ONLY 1 CARD(HOPE)
         BNE   OUTSCON             NO(GROAN)-MULTIPLE CARDS IN STMT
         TM    RSBFLAG,$REBX       WERE THERE ERRORS
         BNZ   OUTERR              BRANCH IF ERRORS(UNFORTUNATE)
         SPACE 1
OUTRETA  STH   RW,OUCOUNT          SAVE WITHIN PAGE COUNT
         AIF   (NOT &$MACROS).OUNMAC3       SKIP IF NO MACROS
         TM    RSBFLAG,$RSBNPNN    SEE IF SHOULDN'T INCRE STMT #
         BO    OUTRETAA            SKIP OVER STMT# ADD INSTR(S)       J
.OUNMAC3 AP    OULNCNT,AWP1        BUMP STMT # TO # OF NEXT ONE
         AIF   (NOT &$XREF).NOXRF10                                   A
         AP    AVXRLNCN,AWP1       INCREMENT ADDITIONAL LINE COUNTER  A
.NOXRF10 ANOP                                                         A
OUTRETAA EQU   *                   BRANCH HERE BEFORE EXIT            J
         $DBG  C0,*                JUST TRACE ON EXIT
OUTRET   $RETURN RGS=(R14-R6),SA=NO
         EJECT
* * * * * OUTSCON - HANDLE PRINTING OF CONTINUATION CARDS.SET UP OFFSE*
* * * * * REGISTER USAGE                                              *
*   R1 = CURRENT COUNT OF # CARDS REMAINING TO BE PRINTED(INIT-RSBNUM)*
*   R2 = @ CURRENT RSCBLK SECTION BEING PROCESSED                     *
*   RD = CURRENT TOTAL OFFSET. USED TO EXTRACT CARDS,SET ERROR MESSGS *
*              INIT.  LOOP THOURHG OUTSCON2 FOR EACH CONT/CARD. SET   *
*              UP OFFSETS IN OUTOFFS FOR USE IN ERROR POINTERS.       *
         SPACE 1
OUTSCON  SR    R1,R1               CLEAR FOR INSERTION
         IC    R1,RSBNUM           GET TOTAL # OF CARDS
         LA    RC,OUTOFFS(R1)      GET @ LAST BYTE FOR OFFSETS
         MVI   0(RC),RSB$L         MOVE BEGINNING OFFSET IN
         SR    RD,RD               CLEAR FOR INSERT
         IC    RD,RSCILEN          GET LENGTH OF 1ST CARDIMAGE
         LA    RD,RSB$L(RD)        INCREMENT LENGTH BY 1ST OFFSET
         STC   RD,OUTOFFS-1(R1)    STORE IN APPROPRAITE PART OF OUTOFFS
         BCTR  R1,0                DECREMENT # CARDS LEFT TO DO
         MVC   OUTLINE,AWBLANK     BLANK WHOLE LINE
         SPACE 1
OUTSCON2 LA    R2,RSC$LEN(R2)      BUMP RSCB POINTER TO NEXT FIELD
         LA    RC,RSBLOCK(RD)      GET @ NEXT SOURCE CARD ELEMENT
         SR    RB,RB               CLEAR FOR INSERT
         IC    RB,RSCILEN          GET LENGTH OF NEXT CARD
         AR    RD,RB               ADD TO TOAL OFFSET LENGTH
         STC   RD,OUTOFFS-1(R1)    STORE NEXT OFFSET INTO LIST
         BCTR  RB,0                DECREMENT FOR LENGTH-1
         STC   RB,*+5              SAVE INTO MVC
         MVC   OUSOURC+15($CHN),0(RC)        MOVE CARD IMAGE OVER
         MVC   OUCONSQ,RSCONSQ     MOVE CONT/SEQNO OVER
         BAL   R14,OUTLNSA         HAVE STMT PRINTED
         STC   RB,*+5              PUT LENGTH-1 INTO NEXT MVC
         MVC   OUSOURC+15($CHN),AWBLANK      BLANK OUT PART OF LINE USE
         BCT   R1,OUTSCON2         LOOP UNTIL WHOLE STATEMENT FINISHED
         SPACE 1
         TM    RSBFLAG,$REBX       DO ERRORS EXIST
         BZ    OUTRETA             NO ERRORS - QUIT
         EJECT
* * * * * OUTERR - PRINT ERROR MESSAGES AND SCAN POINTERS             *
*   R2 = # ERROR CODE/SCAN POINTER PAIRS (= 1 TO $ERREBMX).           *
*   RE = CUMULATIVE COUNT OF ERRORS(NOT WARNINGS) THOURGHOUT SECTION. *
OUTERR   L     RD,AVREBPT          GET POINTER TO ERRORS
         USING REBLK,RD            NOTE USING
         LH    RE,AVNERRA          GET ACTUAL # ERRORS
         LH    R14,AVSTMTER        GET TOTAL # STMT ERRORS
         LA    R14,1(R14)          INCREMENT TO SHOW 1 MORE STMT FLAGD
         STH   R14,AVSTMTER        STORE BACK UPDATED POINTER
         SR    R2,R2               CLEAR FOR INSERTION
         IC    R2,REBLN            GET TOTAL ELNGTH OF ERROR BLOCK
         SRL   R2,1                DIVIDE BY TO=#ERRORS
         SR    R1,R1               CLEAR FOR CONSTANT INSERTS
         SPACE 1
OUTERR1  IC    R1,REBSCN           GET SCAN POINTER
         CLI   RSBNUM,1            WAS THERE ONLY 1 STATEMENT
         BE    OUTERR5             SKIP OVER MULTIPLE SECTION IF SO
         SPACE 1
*              SECTION FROM HERE TO OUTERR5 REQUIRED FOR MULT CARDS.  *
         SR    RC,RC               CLEAR FOR INSERT
         IC    RC,RSBNUM           GET NUMBER OF CARDS
         SR    R0,R0               CLEAR FOR INSERTS
OUTERR3  IC    R0,OUTOFFS-1(RC)    GET LIMIT SCAN POINTER FOR CARD
         CR    R0,R1               COMPARE WITH ERROR POINTER
         BH    OUTERR4             BRANCH OUT IF CORRECT SPOT FOUND
         BCT   RC,OUTERR3          LOOP FOR # OF CARDS
         B     OUTERR5             NOT FOUND-WILL BE TOO HIGH
OUTERR4  IC    R0,OUTOFFS(RC)      GET BEGINNING SCAN POINTER
         SR    R1,R0               GET OFFSET FROM CARD BEGINNING
         LA    R1,RSB$L(R1)        ADD SCAN OFFSET FROM RSBLOCK
         IC    R0,RSBNUM           GET # OF CARDS
         CR    R0,RC               SEE IF SAME,I.E. IN 1ST CARDIMAGE
         BE    OUTERR5             SKIP OVER-ITS IN 1ST CARD,SO OK
         LA    R1,15(R1)           CONTINUATION CARD-BUMP POINTER
         SPACE 1
*              FOLLOWING CONCLUDES PROCESSING FOR SINGLE CARD STMTS   *
OUTERR5  LA    RC,OUTEOFF(R1)      GET @ WHERE $ SHOULD GO
         LA    R0,OUTEREND         GERT LAST POSSIBLE SCAN POINTER
         CR    R0,RC               MAKE SURE POINTER NOT BEYOND END
         BNL   *+6                 SKIP IF OK
         LR    RC,R0               USE LAST POSSIBLE OFFSET @
*              RC = @ FOR $ SCAN POINTER AT THIS POINT.               *
         IC    R1,REBERR           GET THE ERROR CODE
         AIF   (&$OPTMS GT 2).OUOP1         SKIP IF BIG MEMORY
*              SMALL SPACE==> NO PTRS, JUST MULT CODE BY 3/2.
         LR    RB,R1               MOVE ERROR CODE OVER
         SRL   RB,1                ITS EVEN NUMBER, SO DIVIDE BY 2
         AR    R1,RB               = 3/2 CODE, DESIRED NUMBER
         LA    RB,OUERRMS-3-1(R1)  @-1 OF 3BYTE ERROR NUMBER
         AGO   .OUOP2
.OUOP1   ANOP
         LH    RB,OUERRPT(R1)      GET OFFSET TO ERROR MESSAGE
         LA    RB,OUERRMS(RB)      GET ACTUAL @ ERROR MESSAGE
.OUOP2   ANOP
*              INCREMENT ERROR OR WARNING MESSAGE TOTAL COUNT.
         LA    R15,1               SET UP FOR ERROR-WARNING INC
         CLI   1(RB),C'0'          WAS ERR # FROM 000-099 (WARNING)
         BE    *+10                YES, BRANCH IF IT IS A WARNING
         AR    RE,R15              INCREMENT # ERRORS (AVNERRA)
         B     *+12                BRANCH OVER WARNING CODE
         AH    R15,AVNWARN         INCREMENT # WARNING MESSAGES
         STH   R15,AVNWARN         PUT # WARNINGS BACK
         SPACE 1
*              SET UP MESSAGE, SCAN POINTER. PRINT MESSAGE.
         AIF   (&$OPTMS GT 2).OUOP3         SKIP IF LARGE MEMORY
         MVC   OUTERMS(3),1(RB)    MOVE ERROR # INTO MSG
         AGO   .OUOP4              SKIP REGUALR CODE
.OUOP3   ANOP
         IC    R1,0(RB)            GET LENGTH-1 OF ERROR MESSAGE
         STC   R1,OUTERR6+1        SAVE INTO BLANKING MVC
         STC   R1,*+5              STORE TO MOVE MESSAGE INTO BUFFER
         MVC   OUTERMS($CHN),1(RB) MOVE ERROR MESSAGE INTO BUFFER
.OUOP4   ANOP
         MVI   0(RC),C'$'          PLACE SCAN POINTER IN
         LA    RA,OUTERROR         SET UP @ ERROR LINE
         BAL   R14,OUTLNS          HAVE ERROR MESSAGE PRINTED
         SPACE 1
         AIF   (&$OPTMS LE 2).OUOP5         SKIP IF SMALL MEMORY
OUTERR6  MVC   OUTERMS($CHN),OUBLDASH       RESTORE BLANKS-DASHES
.OUOP5   ANOP
         MVI   0(RC),C'-'          FILL IN DASH WIPED BY $
         LA    RD,2(RD)            INCREMENT ERROR BLOCK PTR
         BCT   R2,OUTERR1          LOOP FOR NUMBER OF ERRORS
         SPACE 1
*              UPDATE ERROR COUNT & CHECK FOR EXCEEDING LIMIT.
         STH   RE,AVNERRA          STORE UPDATED ERROR COUNT
         CH    RE,AVNERR           COMPARE TO ERROR LIMIT
         BNH   OUTRETA             IF STILL OK,BRANCH
         OI    AVTAGS1,AJNLOAD     FLAG NOLOAD,NO MORE OBJECT CODE
         B     OUTRETA             GO RETURN
         EJECT
* * * * * RB=$OUMACH - FORMAT LEFT-SIDE FOR MACHINE INSTRUCTIONS  * * *
OUMACH   EQU   *
         BCR   NO,R14              RETURN UNLESS PRINT ON AND LIST
         L     R14,AVRCBPT         GET # RCB TO PICK UP INFO
         USING RCODBLK,R14         NOTE USING
         UNPK  OULOC(7),RCLOC(4)   UNPACK LOCATION COUNTER
         MVI   OULOC+6,C' '        BLANK OT EXTRA BYE
         DROP  R14                 LOCATION COUNTER ALL THAT WAS NEEDED
         USING ICBLOCK,RC          NOTE INSTRUCTION CODE BLOCK
*              RD = LENGTH-1 OF INSTRUCTION = 1,3,5.                  *
         UNPK  OUOPR1R2(5),ICBOPR1R(3)       GET OPCODE-R1-R2 FIELD
         MVI   OUOPR1R2+4,C' '     BLANK OUT EXTRA BYTE
         C     RD,AWF3             CHECK LENGTH-1 AND SET CC
         BL    OUMACH1             ONLY 2 BYTE INSTRUCTION-QUIT
         UNPK  OUOPN1(5),ICBOPN1(3)          UNPACK 1ST BASE-DISP
         MVI   OUOPN1+4,C' '       BLANK OUT END BYTE
         BE    OUMACH1             IF RD=3,==> 4 BYTE INST-QUIT
         UNPK  OUOPN2(5),ICBOPN2(3)          6-BYTE INST.UNPK 2ND B-D
         MVI   OUOPN2+4,C' '       BLANK OUT END BYTE
         SPACE 1
*              OBJECT CODE ALL UNPACKED - NOW CHECK FOR INSTRUCT ADDRS*
OUMACH1  TM    ICBFLAG,$ICBEA1     WAS THERE A 1ST INST ADDR
         BZ    OUMACH2             NO,DON'T LOOK FOR ONE
         UNPK  OUEA1+1(6),ICBEA1+1(4)        GET 5 BYTES OF ADDRESS OVE
OUMACH2  TM    ICBFLAG,$ICBEA2     WAS THERE A 2ND ADDRESS TO BE PRINTE
         BZ    OUMACH3             NO THERE WASN'T,BRANCH
         UNPK  OUEA2+1(6),ICBEA2+1(4)        GET 5 BYTES OF ADDR
OUMACH3  TR    OUTLINE+1(OUTLENM),AWTHEX3    TRANSLATE TO FINISH
         B     OUTSTMT             GO HAVE STATEMENT PRINTED OUT
         SPACE 1
* * * * * RB=$OUCONS - FORMAT LEFT-SIDE WITH LOC,CONSTANT IF NEEDED * *
OUCONS   EQU   *
         BCR   NO,R14              RETURN IF NOT PRINT ON, LIST
         L     R14,AVRCBPT         GET @ RCB FOR INFO THERE
         USING RCODBLK,R14         NOTE POINTER
         UNPK  OULOC(7),RCLOC(4)   CONVERT THE LOCATION COUNTER
         MVI   OULOC+6,C' '        BLANK OT EXTRA BYE
         DROP  R14
         LTR   RD,RD               IS LENGTH-1 <0,WHICH ==> NO CONSTANT
         BM    OUCONS2             NO CONSTANT - TRANSLATE LOCCNTR&QUIT
         C     RD,AWF7             IS LENGTH-1 > 7
         BNH   *+8                 SKIP NEXT IF WITHIN RANGE
         LA    RD,7                USE ONLY 1ST 8 BYTES OF CONSTANT
         SPACE 1
         LA    R14,0(RD,RD)        GET 2*(L-1 OF CODE) FOR UNPACK LENGT
         LA    R15,OUCONST(R14)    SAVE @ LAST UNPACKED BYTE
         SLL   R14,4               SHIFT OVER INTO 1ST NIBBLE OF LOW BT
         AR    RD,R14              PUT LENGTHS INTO LOW-ORDER BYTE
         STC   RD,*+5              STORE INTO UNPK INSTRUCTION
         UNPK  OUCONST($CHN),0($CHN,RC)      CONVERT CONST CODE
         UNPK  1(1,R15),0(1,R15)   DUPLICATE AND REVERSE NIBBLES
         OI    0(R15),X'F0'        MAKE DIGIT PRINTABLE
         OI    1(R15),X'F0'        FIX UP LAST BYTE
OUCONS2  TR    OUTLINE+1(24),AWTHEX3         CONVERT OT HEX OUTPUT
         B     OUTSTMT             GO PRINT PUT STATEMENT
         EJECT
* * * * * RB=$OULIST - LISTING CONTROL - SPACE,EJECT,PRINT,TITLE  * * *
OULIST   EQU   *                   ""=3 IF PRINT ON, LIST OPTION
         LH    R15,OUJUMP2(RE)     GET SECONDARY BRANCH CODE
OUTJ2    B     OUTJ2(R15)          BRANCH TO STMT TYPE, DON'T CHANGE CC
         SPACE 1
* * * * * OUSPEJ - PROCESS SPACE OR EJECT,USING # OF LINES TO BE SPACD*
*              AT THIS PT, CC MUST =3, ELSE NO SPACING DONE.
OUSPEJ   BCR   NO,R14              QUIT, (RETURN TO OUTRETE
         LA    RD,1                SET COUNTER CLEAR
         LA    RA,AWBLANK          @ BLANK LINE
         CLI   0(RC),255           REAL EJECT ?
         BE    OUSPEJ1A            YES, GO DO THE EJECT
         IC    RD,0(RC)            GET # OF LINES TO BE PSACED
OUSPEJ1  SR    RW,RD               GET # LINES LEFT ON THIS PAGE
         BP    OUSPEJ2             SKIP SOME LEFT - PRINT BLANK LINES
         LCR   RD,RW               # BLANKS TO BE PRINTED AFTER TITIL
         BZ    OUTITL2             IF NO BLANK LINES, JUST RESET TITLE
OUSPEJ1A BAL   R14,OUTLNSTI        HAVE TITLE LINES PRINTED
         B     OUSPEJ1             LOOP-BE SAFE FOR PRINT 200 ETC
OUSPEJ2  BAL   R14,OUXPRNT         PRINT 1 BLANK LINE
         BCT   RD,OUXPRNT          GO PRINT BLANK LINES
         B     OUTRETA             GO RETURN
         SPACE 1
* * * * * OUPRINT - PROCESS PRINT INSTRUCTION. RC = @ CONTROL BYTE    *
OUPRINT  MVC   AVPRINT,0(RC)       MOVE PRINT CONTROL BYTE OVER
         B     OUTRETE             NOT ON,GO CHECK FOR ERRORS
         SPACE 1
* * * * * OUTITLE - BRING IN NEW TITLE,FLAG TITLE EXISTS,PRINT IF ON. *
OUTITLE  MVC   OUHEADNG,AWBLANK    BLANK THE HEADING OUT
         STC   RD,*+5              STORE LENGTH-1 OF NEW TITLE INTO MVC
         MVC   OUHEADNG($CHN),0(RC)          MOVE NEW HEADING INTO FIEL
OUTITL2  LA    RW,1                SET COUNT SO WILL CREATER HEADER NXT
         B     OUTRETE             GO MAKE SURE THERE WAS NO ERROR
         SPACE 2
OUCOMM   EQU   *                   COME HERE FOR COMMENTS, SPEC ERRS
         BCR   NO,R14              PRINT OFF/NOLIST - RETURN
         B     OUTSTMT             PRINT LIST AND ON - GO PRINT STMT
         EJECT
**--> INSUB: OUTLNSA/OUTLNS  PRINT 1 LINE (WITH HEADING IF NEEDED)+ + +
*+       PRINTS A 121 BYTE LINE, DECREMENTS REMAINING LINE COUNT.     +
*+       ENTRY CONDITIONS                                             +
*+  RA = @ 121-BYTE LINE TO BE PRINTED (OUTLNS ONLY).                 +
*+  RW = LINE COUNT REMAINING.  IF = 1, WILL PRODUCE HEADING.         +
*+  R14= RETURN @ TO CALLING SECTION OF CODE.                         +
*+  + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
         SPACE 1
OUTLNSA  LA    RA,OUTLINE          ENTRY FOR MOST COMMON @
OUTLNS   BCT   RW,OUXPRNT          DECREMENT REMAINING, BRANCH IF OK
         SPACE 1
*              A HEADING AND PAGE SKIP ARE REQUIRED IF FALLS THRU HERE.
OUTLNSTI LR    RW,RA               SAVE ORIG LINE @ PTR INTO RW
         LR    R15,R14             SAVE THE ORIGIANL RETURN @ IN R15
         SPACE 1
         AP    OUPGCNT,AWP1        INCREMENT PAGE COUNT
         MVC   OUPCNT,AWEP4        MOVE EDIT PATTERN OVER
         ED    OUPCNT,OUPGCNT      EDIT PAGE COUNT OVER
         LA    RA,OUHEAD1          SHOW @ 1ST HEADING (TITLE)
         BAL   R14,OUXPRNT         PRINT IT
         LA    RA,OUHEAD2          SHOW @ 2ND HEADNING
         BAL   R14,OUXPRNT         HAVE IT PRINTED
         SPACE 1
         LR    RA,RW               RESTORE OLD LINE @
         LR    R14,R15             RESTORE OLD RETURN @
         SPACE 1
         LH    RW,OUH#LINE         GET # LINES LEFT TO DO
         MVI   OUHEAD1,C'1'        MAKE SURE SET FOR PAGE SKIP
         MVC   OUH#LINE,=AL2($OU#NORM)      SET COUNTERSETTER NORMAL
*              FALL THRU INTO OUXPRNT TP PRINT STMT ITSELF.
         SPACE 1
**--> INSUB: OUXPRNT    LOW-LEVEL PRINT ROUTINE- 121-BYTE LINE  + + + +
*+       ROUTINE PRINTS 1 LINE (NORMAL), OR ELSE BRANCHS TO CMPRS     +
*+       OPTION CODE TO SAVE/PRINT 2 STMTS PER LINE, IF CMPRS CODE    +
*+       EXISTS AND USER SPECIFIES THE OPTION.                        +
*+       ENTRY CONDITIONS                                             +
*+  RA = @ 121-CHARACTER LINE TO BE PRINTED                           +
*+  R14= RETURN @ TO CALLING SECTION OF CODE.                         +
*++ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
         SPACE 1
OUXPRNT  EQU   *                   ENTRY FOR PRINTING OR SAVING
         AIF   (NOT &$CMPRS).OUXCM1         SKIP IF NO CMPRS CODE
         TM    AVTAGS2,AJOCMPRS    IS CMPRS OPTION IN EFFECT
         BO    OUXCMINT            YES, GO TO PROCESS NEW STMT
         SPACE 1
.OUXCM1  ANOP
         $PRNT 0(RA),121           PRINT 1 NORMAL LINE
         BCR   Z,R14               RETURN IF NO OVERFLOW
         OI    AVTAGS2,AJOASTOP    RECORDS OVER-SHOW FLAG FOR STOPPING
         BR    R14                 RETURN TO CALLING SECTION.
         AIF   (NOT &$CMPRS).OUXCM2         SKIP IF NO CMPRS OPTION
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              CMPRS OPTION PROCESSING - 2 STMTS/LINE                 *
*   THIS SECTION PERFORMS ALL MANIPULATION AND PRINTING REQUIRED TO   *
*   PRODUCE A LISTING IN WHICH THE FIRST HALF OF APPROX. 120 STMTS    *
*   IS PRINTED ON THE LEFT SIDE OF A PAGE, AND THE OTHER HALF ON THE  *
*   OTHER SIDE, THUS REDUCING THE LINES PRINTED BY THE ASSEMBLER BY   *
*   APPROXIMATELY 1/2.  IT CONSISTS OF THE FOLLOWING STEPS:           *
*   INITIALIZATION CODE: OUXCMINT : CONVERTS NONBLANK CARRIAGE        *
*        CONTROL LINES TO BLANK LINES FOLLOWED BY ACTUAL LINES.       *
*        ALSO SAVES REGISTERS WHICH WILL BE MODIFIED BY THIS SECTION. *
*   PHASE 'A' CODE :  ENTERED FOR EACH LINE UNTIL ENTIRE LHS OF PAGE  *
*        IS STORED, THEN SETS FLAGS FOR PHASE 'B'.                    *
*   PHASE 'B' CODE : OUXCMB : BUILD AND PRINT LINE CONSISTING OF      *
*        ONE STMT SAVED DURING PHASE 'A' AND THE LINE JUST GIVEN.     *
*        WHEN ALL SAVED STMTS HAVE BEEN PRINTED, RESET TO PHASE 'A'.  *
*        **NOTE** THIS SECTION IS ALSO USED FROM OUEND2 ENTRY.        *
*              REGISTER USAGE IN THIS SECTION                         *
*   RA = @ INCOMING LINE TO BE PRINTED.                               *
*   RB = @ CMPRS WORKAREA (OUCMPRSD DSECT)                            *
*   RC = @ NEXT EMPTY STMT SLOT, NEXT TO BE PRINTED / WORK REG.       *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
**--> INSUB: OUXCMINT   ENTRY POINT FOR CMPRS HANDLING  + + + + + + + +
*        INITIAL SECTION - CHECK FOR NONBLANK CARRIAGE CONTROL.       +
*        ENTRY CONDTIONS           (ENTIRE SECTION)                   +
*   RA = @ 121-BYTE LINE IMAGE FOR OUTPUT  (OUSTMTIM DSECT)           +
*   R14= RETURN @ TO CALLING SECTION OF CODE                          +
*        *NOTE* MODIFIES NO REGISTERS, DOES USE AVDWORK1&AVDWORK2.    +
*        NAMES: OUXCM---                                              +
*+  + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
         SPACE 1
         USING OUSTMTIM,RA         NOTE DSECT FOR CONVENIENCE
OUXCMINT STM   RA,RC,AVDWORK1      INTO AVDWORK1,AVDWORK2 D'S
         CLI   OUSTCC,C' '         WAS CARRIAGE CONTROL NORMAL ' '
         BE    OUXCMPRT            YES, DON'T NEED DO FIXUP-BRANHC
         SPACE 1
*              NONBLANK CC - INSERT BLANK LINE, SAVING/RESTORING REGS.
         ST    R14,AVDWORK2+4      SAVE INTO TEMPORARY AREA
         LA    RA,AWBLANK          SHOW @ BLANK LINE
         BAL   R14,OUXCMPRT        CALL INTERIOR SECTION
         L     RA,AVDWORK1         RESTORE ORIG LINE @
         L     R14,AVDWORK2+4      RESTORE REAL RETURN @
         SPACE 1
*              OUXCMPRT - GET WORKAREA @, CHOOSE CURRENT PHASE A,B
OUXCMPRT L     RB,OUCMPRAD         GET @ CMPRS CONTROL BLOCK
         USING OUCMPRSD,RB         NOTE THE POINTER
         TM    OUCMPHAS,OUCMPHSB   IS IT PHASE B (PRINTOUT)
         BO    OUXCMB              YES, SO GO TO PRINT OUT 2 STMTS
         EJECT
*              PHASE 'A' - SAVE STMT IMAGES UNTIL AREA FULL.
         L     RC,OUCMSTMT         GET @ NEXT SLOT FOR STMT SEGMENT
         MVC   0(OUCM$L1,RC),OUSTP1         GET 1ST SECTION OF STMT
         MVC   OUCM$L1(OUCM$L2,RC),OUSTP2   2ND STMT SECTION (SOURCE)
         LA    RC,OUCM$LT(RC)      INCREMENT SLOT PTR TO NEXT ONE
         ST    RC,OUCMSTMT         STORE UPDATED SLOT PROINTER BACK
         SPACE 1
         LH    RC,OUCMLEFT         GET # EMPTRY SLOTS LEFT THIS TIME
         S     RC,AWF1             DECREMENT # EMPTRY SLOTX
         STH   RC,OUCMLEFT         RESTORE UPDATED # SLOTS
         BP    OUXCMRET            IF SLOTS LEFT, GO TO EXIT CODE
         SPACE 1
*              NO EMPTY SLOTS LEFT FOR STMTS.  RESET VARIABLES AND
*              FLAG SO ENTERS PHASE 'B' OF CMPRS PROCESSING NEXT TIME.
OUXCMA1  LA    RC,OUCMSAVE         INIT @ TO 1ST SAVED STMT
         ST    RC,OUCMSTMT         INIT PTR TO 1ST SAVED STMT
         MVC   OUCMLICC,OUCMCCIN   INIT CARRIAGE CONTROL 1ST STMT
         MVI   OUCMCCIN,C'1'       MAKE SURE NEW PAGE FOR PAGES 2-
         OI    OUCMPHAS,OUCMPHSB   SHOW NOW PHASE 'B'
         B     OUXCMRET            GO TO RETURN CODE
         SPACE 2
*              PHASE 'B' - RETIRIEVE AND PRINT SAVED STMT WITH NEW 1.
OUXCMB   L     RC,OUCMSTMT         GET @ NEXT STMT TO PRINT
         MVC   OUCMSTMA,0(RC)      MOVE THE STMTS TO PRINT AREA
         MVC   OUCMSTMB(OUCM$L1),OUSTP1     GET 1ST SECTION OF NEW 1
         MVC   OUCMSTMB+OUCM$L1(OUCM$L2),OUSTP2       2ND SECT OF NEW
         $PRNT OUCMLINE,133        PRINT THE ENTIRE LINE, 2 STMTS
         BM    OUXCMOVR            OVER NOW ON PRINTER-STOP
         SPACE 1
         MVI   OUCMLICC,C' '       MAKE SURE CC IS ' ' FOR REST OF PAGE
         LA    RC,OUCM$LT(RC)      INCREMENT PTR TO NEXT SAVED STMT
         ST    RC,OUCMSTMT         STORE BACK UPDATE PTR @
         SPACE 1
         LH    RC,OUCMLEFT         GET # EMPTY SLOTS LEFT
         LA    RC,1(RC)            INCREMNT # EMPTY (JUST PRINTED 1)
         STH   RC,OUCMLEFT         RESTORE UPDATED # EMPTRY SLOTS
         CH    RC,OUCMOPAG         IS EMPTY # = # ON PAGE
         BL    OUXCMRET            NO, STILL MORE TO DO, RETURN
         SPACE 1
*              HAVE PRINTED ALL SAVED STMTS, RETURN TO PHASE 'A'
         LA    RC,OUCMSAVE         GET @ FIRST SLOT
         ST    RC,OUCMSTMT         RE-INIT TO @ FIRST SLOT
         LA    RC,$OU#LNS          NORMAL # LINES PER PAGE
         STH   RC,OUCMOPAG         SET # ON PAGE TO NORMAL # FOR SURE
         STH   RC,OUCMLEFT         SET COUNTER VALUE NORMAL TOO
         NI    OUCMPHAS,255-OUCMPHSB        REST TO PHASE 'A'
         SPACE 1
*              OUXCMRET - EXIT CODE - RESTORE REGS,RETURN
OUXCMRET LM    RA,RC,AVDWORK1      RESTORE REGS FROM SAVED WORDS
         BR    R14                 RETURN TO CALLING SECTION OF CODE
OUXCMOVR OI    AVTAGS2,AJOASTOP    FLAG OVERRRUN
         B     OUXCMRET            GO TO EXIT FROM CMPRS SECTION
         DROP  RA,RB               REMOVE USINGS
.OUXCM2  ANOP
         EJECT
**--> ENTRY: OUEND2   2   PRINT ENDING STATISTICS FOR ASSMBLY . . . . .
*.       OUEND2 IS CALLED AT THE END OF THE ASSEMBLY TO PRINT SUMMARY .
*.       OF ERRORS AND WARNINGS ISSUED.  FIRST LINE PRINTED GIVES     .
*.       TOTAL # OF STMTS FLAGGED, TOTAL # ERRORS, TOTAL # WARNINGS.  .
*.       IF MAXIMUM # ERRORS IS EXCEEDED, ANOTHER LINE IS PRINTED.    .
*.       USES DSECTS: AVWXTABL                                        .
*.       USES MACROS: $PRNT,$RETURN,$SAVE                             .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
OUEND2   $SAVE SA=NO
         AIF   (NOT &$CMPRS).OUENC1         SKIP IF NO COMPRS CODE
         SPACE 1
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              CMPRS OPTION COMPLETION CODE                           *
*              SET UP COMMON USING CONDITIONS WITH OUTPT2, AND TEST   *
*        FOR CMPRS OPTION IN EFFECT.  IF IT IS, THEN HAVE ANY         *
*        STATEMENTS PRINTED WHICH HAD BEEN SAVED, BUT NOT YET         *
*        PRINTED.                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         TM    AVTAGS2,AJOCMPRS    DID USER SPECIFY CMPRS OPTION
         BZ    OUENCMNO            NO HE DIDNT, SKIP
         SPACE 1
         STM   R14,RX,12(R13)      STORE REGS, ESPEC RX,R14
         L     RX,=A(OUTPT2)       GET ADDR (SAFE IN OVERLAY)         J
         DROP  R15                 REMOVE OLD USING
         USING OUTPT2,RX           NOTE COMMON USING WITH OUTPT2
         SPACE 1
*              TEST PHASE OF CMPRS HANDLING.  IF STMTS LEFT, SET TO
*              PHASE B TO DUMP THOSE LEFT, IF NOT ALREADY PHASE B.
         L     RB,OUCMPRAD         GET @ CONTROL BLOCK FOR CMPRS
         USING OUCMPRSD,RB         NOTE CONTROL BLOCK USING
         TM    OUCMPHAS,OUCMPHSB   ARE WE IN PHASE B ALREADY
         BO    OUENPHSB            YES, JUMP TO FINISH
         BAL   R14,OUXCMA1         IN PHASE A, CALL THIS TO SET TO B
         L     RB,OUCMPRAD         RELOAD RB, WHICH WAS ERASED
         SPACE 1
*              CMPRS HANDLER IN PHASE 'B' - PRINT ANY REMAINING STMTS
OUENPHSB LH    RD,OUCMOPAG         GET # ON PAGE
         SH    RD,OUCMLEFT         DIFFERENCE = # LEFT TO DO
         BNP   OUENCMDN            NO STMTS LEFT, NO PRINTING NEEDED
         LA    RA,AWBLANK          SHOW @ FAKE BLANK LINE
         SPACE 1
         BAL   R14,OUXCMINT        GO TO PRINT 1 MORE STMT/BLANK LINE
         BCT   RD,*-4              LOOP UNTIL ALL LINES LEFT PRINTED
         SPACE 1
OUENCMDN LM    R14,RX,12(R13)      RESTORE REGS, ESP RX,R14
         DROP  RB                  REMOVE USING
         USING OUEND2,R15          RESTORE REGULAR USING
         EJECT
OUENCMNO EQU   *                   NORMAL OUEND2 PROCESSING
.OUENC1  ANOP
         SPACE 1
         TM    AVTAGS3,AVOVERFL    DID OVERFLOW OF STORAGE OCCUR
         BZ    OUNOVRFL            NO, DON'T PRINT MSG
         $PRNT OUAS999,OUAS999L    PRINT THE MESSAGE
OUNOVRFL EQU   *                   BRANCH HERE IF STORAGE OK
         SPACE 1
         ZAP   AVDWORK1,OULNCNT    MOVE LINE COUNT OVER FOR CONVERT
         CVB   RE,AVDWORK1         CONVERT THE LINE COUNT TO BINARY
         STH   RE,AVSTMTNO         SAVE AS NUMBER OF STATEMENTS
         SPACE 1
         LH    RE,AVSTMTER         GET # STATEMENTS FLAGGED
         LA    RD,OUSTMTER         GET @ TO PUT RESULT
         BAL   RC,OUENCONV         GO CONVERT VALUE
         SPACE 1
         LH    RE,AVNWARN          # WARNINGS ISSUED
         LA    RD,OUNWARN          @ FOR RESULT
         BAL   RC,OUENCONV         GO CONVERT VALUE
         SPACE 1
         LH    RE,AVNERRA          ACTUAL # ERRORS
         LA    RD,OUNERRA          @ FOR RESULT
         BAL   RC,OUENCONV         CONVERT VALUE
         $PRNT OUEND2M,OUEND2ML    PRINT 1ST MESSAGE
         SPACE 1
         LH    RE,AVNERR           GET LIMIT # ERRORS
         CH    RE,AVNERRA          COMPARE TO ACTUAL
         BNL   OUENDREA            SKIP TO EXIT CODE IF OK
         SPACE 1
         LA    RD,OUNERR           GET @ FOR CONVERTED RESULT
         BAL   RC,OUENCONV         GO CONVERT ACTUAL #
         $PRNT OUEND2N,OUEND2NL    PRINT 2ND MESSAGE
         SPACE 1
OUENDREA EQU   *                   EXIT CODE LABEL
         AIF   (&$COMNT EQ 0).OUNCOM2       SKIP IF NO COMMENT CHEKCING
         EJECT
*              FINAL CHECK - IF COMMENT CHECK OPTION IN EFFECT,
*              MAKE SURE PROGRAMMER HAS SUPPLIED COMMENTS ON AT LEAST
*              &$COMNT PER CENT OF MACHINE INSTRUCTIONS. IF NOT,
*              DELETE HIS EXECUTION.  SEE OUINT1 AND IAMOP1 FOR CODE.
         SPACE 1
         TM    AVTAGS2,AJOCOMNT    IS COMMENT OPTION IN EFFECT
         BZ    OUENDRET            NO, SO SKIP
         SPACE 1
         LH    RE,AVMACHIN         # MACHINE INSTRUCTIONS
         MH    RE,=H'&$COMNT'      * PERCENT REQUIRED TO HAVE COMMENTS
         LH    RD,AVCOMNTN         # COMMENTS ON THE MACH INSTRS
         MH    RD,=H'100'          BY 100 FOR COMPARISON
         CR    RD,RE               IS COMNTN>= MACHIN*&$COMNT/100
         BNL   OUENDRET            YES, SO HE HAD ENOUGH COMMENTS-OK
         SPACE 1
*              INSUFFICIENT COMMENTS - ZAP USER WITH MESSAGE.
         OI    AVTAGS1,AJNLOAD     NO EXECUTION
         $PRNT OUEND2P,OUEND2PL    PRINT THE MESSAGE
         SPACE 1
.OUNCOM2 ANOP
OUENDRET $RETURN SA=NO             RETURN TO CALLER
         SPACE 1
* * * * * OUENCONV - CONVERT AND EDIT INTEGER TO 6 BYTE FIELD         *
*        ENTRY CONDTIONS                                              *
*   RC = RETURN @ TO CALLING SECTION                                  *
*   RD = @ 6-BYTE FIELD WHERE CONVERTED AND EDITED RESULT TO BE PLACED*
*   RE = VALUE TO BE CONVERTED TO DECIMAL                             *
*        EXIT CONDTIONS                                               *
*        6-BYTE FIELD AT 0(RD) HAS EDITED RESULT, WITH 'NO' IF RE=0.  *
OUENCONV LTR   RE,RE               IS RESULT 0
         BZ    OUENCONO            YES, SO PU 'NO' IN
         CVD   RE,AVDWORK1         CONVERT VALUE TO DECIMAL
         MVC   0(6,RD),AWEP6       MOVE 6-BYTE EDIT PATTERN IN
         ED    0(6,RD),AVDWORK1+5  EDIT THE FIELD
         BR    RC                  RETURN TO CALLER
OUENCONO MVC   0(6,RD),=CL6'  NO  '         VALUE = 0, USE 'NO' INSTEAD
         BR    RC                  RETURN TO CALLER
         EJECT
* * * * * INTERNAL CONSTANTS                                          *
*              PRIMARY TYPE BRANCH OFFSETS                            *
OUJUMP1  $AL2  OUTJ1,(OUMACH,OUCONS,OULIST,OUCOMM)
*              SECONDARY BRANCH OFFSETS FOR LISTING CONTROL.          *
OUJUMP2  $AL2  OUTJ2,(OUSPEJ,OUPRINT,OUTITLE)
         SPACE 1
* * * * * INTERNAL VARIABLES                                          *
OUCOUNT  EQU   AVOUCOUN            H, WITHIN-PAGE LINES REMAINING
OULNCNT  EQU   AVOULNCN            PL3 - STATEMENT #
OUPGCNT  EQU   AVOUPGCN            PL2 - # PAGES
OUTOFFS  DS    ($RSMXCRD+1)C       SPACE FOR SAVING OFFSETS FOR CARDS
OUH#LINE DS    H                   # LINES PER PAGE, EXCEPT HEADING
         AIF   (NOT &$CMPRS).OUECMPA        SKIP IF NO CMPRS MODE
OUCMPRAD DS    A                   @ OUCMPRSD AREA, IF CMPRS OPT USED
.OUECMPA ANOP
         SPACE 1
*              PAGE HEADING 1 - TITLE FIELD,IF ANY, PAGE NUMBER       *
         DS    0D                  ALIGNMENT FOR MODEL 65+
OUHEAD1  DS    0CL121
         DC    CL8'1'              CARRIAGE CONTROL
OUHEADNG DS    CL100               SPACE FOR TITLE FIELD
         DC    CL9'    PAGE '
OUPCNT   DS    ZL4                 PAGE NUMBER
         SPACE 1
*              PAGE HEADING 2 - COLUMN HEADINGS AND DATE              *
         DS    0D                  ALIGNMENT FOR MODEL 65+
OUHEAD2  DS    0CL121
         DC    C'0  LOC  '         CARRIAGE CONTROL, LOCATION COUNTER
         DC    C'OBJECT CODE    ADDR1 ADDR2  STMT   SOURCE STATEMENT'
         DC    CL54' '
OUDATE   DC    CL8' '              DATE (IF AVAILABLE)
         EJECT
*              OUTPUT BUFFER SETUP FOR ALL STATEMENTS                 *
         DS    0D                  ALIGNMENT FOR SPEED IN MODELS 65+
OUTLINE  DS    0CL121
         DS    C                   CARRIAGE CONTROL
OULOC    DS    XL6                 SPACE FORLOCATION COUNTER
         DS    C
OUCONST  DS    0XL16               SPACE FOR UP TO 8 BYTES CONVERTED
OUOPR1R2 DS    XL4                 SPACE FOR CONVERTED OPCODE-R1-R2
         DS    C
OUOPN1   DS    XL4                 CONVERTED 1ST BASE-DISPLACEMENT
         DS    C
OUOPN2   DS    XL4                 CONVERTED 2ND BASE DISPLACEMENT
OUEA1    DS    XL6                 CONVERTED 1ST INSTRUCTION ADDRESS
OUEA2    DS    XL6                 CONVERTED 2ND INSTRUCTION ADDRESS
         DS    C
OUTLENM  EQU   *-OULOC             LENGTH FOR TRANSLATE: MACHINE OPS
         SPACE 1
OUDSTMNT DS    ZL5                 STATEMENT NUMBER
         DS    C                   BLANK OR PLUS
OUTLEN   EQU   *-OUTLINE           LENGTH FOR BLANKING ORIGINAL
OUSOURCE DS    0CL80               SOURCE STATEMENT
OUSOURC  DS    CL71                SOURCE CARD,WITHOUT CONT/SEQNO
OUCONSQ  DS    CL9                 CONTINUATION/SEQUENCE # FIELD
         SPACE 1
*              OUTPUT BUFFER SETUP FOR ERROR MESSAGES                 *
         DS    0D
OUTERROR DS    0CL121              ERROR LINE
OUTERRAS DC    CL9' ----->AS'      ERROR FLAG - LEFT
OUTERMS  DC    CL32' '             SPACE FOR ERROR MESSAGE
OUTEOFF  EQU   *-RSB$L             OFFSET FROM SOURCE IMAGE
         DC    72C'-',CL8' <-ERROR'         SPACE FOR $, END FLAG
OUTEREND EQU   *-9                 @ LAST POSSIBLE SCAN POINTER
         AIF   (&$OPTMS LE 2).OUOP5A   SKIP IF SMALL MEMORY
OUBLDASH DC    CL(L'OUTERMS)' ',18C'-'      FOR REBLANKING ERROR FIELD
.OUOP5A  ANOP
         SPACE 1
*              FINAL MESSAGE(S) ON STATEMENTS FLAGGED,WARNINGS,ETC.   *
*              THIS SECTION USED BY ENTRYPT OUEND2.
OUEND2M  DC    C'0***'
OUSTMTER DC    ZL6'0',C' STATEMENTS FLAGGED -'
OUNWARN  DC    ZL6'0',C' WARNINGS,'         # WARNINGS ISSUED
OUNERRA  DC    ZL6'0',C' ERRORS'   # ERRORS
OUEND2ML EQU   *-OUEND2M           LENGTH OF THIS MESSAGE
         SPACE 1
OUEND2N  DC    C'0***** NUMBER OF ERRORS EXCEEDS LIMIT OF'
OUNERR   DC    ZL6'0',C' ERRORS - PROGRAM EXECUTION DELETED *****'
OUEND2NL EQU   *-OUEND2N           LENGTH OF THIS ERROR MESSAGE
         AIF   (&$COMNT EQ 0).OUNCOM3       SKIP IF NO COMMENT CHEK
OUEND2P  DC    C'0***** EXECUTION DELETED - LESS THAN &$COMNT '
         DC    C'PER CENT OF MACHINE INSTRUCTIONS HAVE COMMENTS *****'
OUEND2PL EQU   *-OUEND2P           GET LENGTH OF WHOLE MESSAGE
         SPACE 1
.OUNCOM3 ANOP
         SPACE 1
OUAS999  DC    C'0AS999'           MESSAGE NUMBER
         AIF   (&$OPTMS LE 2).OUAS999  SKIP IF LOW CORE USAGE
         DC    C' DYNAMIC STORAGE EXCEEDED'
.OUAS999 ANOP
OUAS999L EQU   *-OUAS999           LENGTH OF MESSAGE
         LTORG
         EJECT
*              ERROR POINTERS AND ERROR MESSAGES                      *
*              FOR ADDRESSIBILITY, THIS SECTION SHOULD BE LAST.       *
*        **NOTE** FOR SMALL COMPUTERS, THIS CODE CAN BE GREATLY       *
*        BY MODIFYING MACRO $SERR TO GENERATE ONLY THE ERROR NUMBERS. *
         AIF   (&$OPTMS LE 2).OUOP6         SKIP IF SMALL MEMORY
*        THE PROGRAM LOGIC REMIANS UNCHNAGED, BUT 1100 BYTES CAN BE   *
*        SAVED WHICH ARE CURRENTLY TAKEN BY THE ERROR MESSAGES.       *
*              THE TABLE CONSISTS OF 2 SECTIONS: A HALFWORD OFFSET    *
*              @ LIST, AND A LIST OF MESSAGES CREATED BY $SERR'S,     *
*              WHICH ARE POINTED TO BY THE OFFSET @'S.                *
         SPACE 1
         DS    0H                  ALIGN ON HALF WORD BPUNDARY
OUERRPT   EQU  *-2 .               OFFSET TO 1 ' BACKWARDS
         DS    (&$ERNUM/2)H .      SPACE FOR HALFWORD ERROR POINTERS
.OUOP6   ANOP
         EJECT
OUERRMS  EQU   *                   BASE ADDRESS FOR ERROR MESSAGES
ALIGN    $SERR 'W-ALIGNMENT ERROR-IMPROPER BOUNDARY',000
ENTRY    $SERR 'W-ENTRY ERROR-CONFLICT OR UNDEFINED',001
EXTRN    $SERR 'W-EXTERNAL NAME ERROR OR CONFLICT',002
RGNUS    $SERR 'W-REGISTER NOT USED',003
ODDRG    $SERR 'W-ODD REGISTER USED-EVEN REQUIRED',004
NOEND    $SERR 'W-END CARD MISSING-SUPPLIED',005
ADDR     $SERR 'ADDRESSIBILITY ERROR',100
CNLNG    $SERR 'CONSTANT TOO LONG',101
CNTYP    $SERR 'ILLEGAL CONSTANT TYPE',102
CONT     $SERR 'CONTINUATION CARD COLS. 1-15 NONBLANK',103
CONTX    $SERR 'MORE THAN 2 CONTINUATION CARDS',104
CXREL    $SERR 'COMPLEX RELOCATABILITY ILLEGAL',105
DCEXT    $SERR 'TOO MANY OPERANDS IN DC',106
DPCSE    $SERR 'MAY NOT RESUME SECTION CODING',107
DUPLF    $SERR 'ILLEGAL DUPLICATION FACTOR',108
EXGTA    $SERR 'EXPRESSION TOO LARGE',109
EXLTA    $SERR 'EXPRESSION TOO SMALL',110
ICNOP    $SERR 'INVALID CNOP OPERAND(S)',111
ILLAB    $SERR 'LABEL NOT ALLOWED',112
ILORG    $SERR 'ORG VALUE IN WRONG SECTION OR TOO LOW',113
INVCN    $SERR 'INVALID CONSTANT',114
INVDM    $SERR 'INVALID DELIMITER',115
INVF     $SERR 'INVALID FIELD',116
INVSY    $SERR 'INVALID SYMBOL',117
IVOPC    $SERR 'INVALID OP-CODE',118
MULDF    $SERR 'PREVIOUSLY DEFINED SYMBOL',119
NEABS    $SERR 'ABSOLUTE EXPRESSION REQUIRED',120
NODLM    $SERR 'MISSING DELIMITER',121
NOIMP    $SERR 'FEATURE NOT CURRENTLY IMPLEMENTED',122
NOOPR    $SERR 'MISSING OPERAND',123
NONAM    $SERR 'LABEL REQUIRED',124
RELOC    $SERR 'RELOCATABLE EXPRESSION REQUIRED',126
SDINV    $SERR 'INVALID SELF-DEFINING TERM',127
START    $SERR 'ILLEGAL START CARD',128
TLIT     $SERR 'ILLEGAL USE OF LITERAL',129
UNDEF    $SERR 'UNDEFINED SYMBOL',130
UNRV     $SERR 'UNRESOLVED EXTERNAL REFERENCE',131
VILCH    $SERR 'ILLEGAL CHARACTER',132
VPARN    $SERR 'TOO MANY PARENTHESIS LEVELS',133
VRELO    $SERR 'RELOCATABLE VALUE USED WITH * OR /',134
VSYNT    $SERR 'SYNTAX',135
VTMTR    $SERR 'TOO MANY TERMS IN EXPRESSION',136
VUNEX    $SERR 'UNEXPECTED END OF EXPRESSION',137
INTPT    $SERR 'STATEMENT CAUSED INTERRUPT',138
         AIF   (NOT &$MACROS).OUSERR1       SKIP IF NO MACROS
ILOPR    $SERR 'OPERAND NOT ALLOWED',201
STMNA    $SERR 'STATEMENT OUT OF ORDER',202
SSDIM    $SERR 'SET SYMBOL DIMENSION ERROR',203
INSBV    $SERR 'INVALID NBR OF SUBSCRIPTS',204
ILCNV    $SERR 'ILLEGAL CONVERSION',205
MISQU    $SERR 'MISSING QUOTES IN CHAR EXPR',206
ILMNM    $SERR 'ILLEGAL OR DUP MACRO NAME',207
MXDMD    $SERR 'OPRND NOT COMPATIBLE WITH OPRTR',208
UNDKW    $SERR 'UNDFND OR DUP KEYWORD',209
EXMAC    $SERR 'MNEST LIMIT EXCEEDED',210
ILAT     $SERR 'ILLEGAL ATTRIBUTE USE',211
MEXST    $SERR 'GENERATED STMT TOO LONG',212
OVRGN    $SERR 'GENERATED STMTS OVERWRITTEN',298
.OUSERR1 SPACE 1
         DROP  RAT,R2,RC,RD,RX,RZ  REMV USINGS
         AIF   (NOT &$CMPRS).OUCMDSE        SKIP IF NO CMPRS CODE
         EJECT
**--> DSECT: OUCMPRSD   CONTROL BLOCK FOR OUTPUT CMPRS OPTION . . . . .
*.       THIS BLOCK DESCRIBES AREA USED BY OUTPT2 WHEN DOING THE      .
*.       CMPRS LISTING OPTION (2 STMTS/LINE).  IT CONTAINS VARIABLES, .
*.       FLAGS, AND SPACE FOR $OU#NORM PARTIAL CARD IMAGES, WHICH     .
*.       ARE SAVED AND USED FOR THE LEFT-HAND-SIDE OF THE PAGE.       .
*.       THIS BLOCK IS ALLOCATED SPACE ONLY IF THE CMPRS PARM IS      .
*.       USED.  THE @ OUCMPRSD IS STORED IN OUCMPRAD VARIABLE.        .
*.       LOCATION: IN DYNAMIC AREA, ACQUIRED BY $ALLOCH IN OUINT1.    .
*.       NAMES: OUCM----                                              .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         SPACE 1
OUCMPRSD DSECT
*              LENGTH EQUS FOR PARTS OF STMT ACTUALLY PRINTED/SAVED.
OUCM$LT  EQU   (&$PRTSIZ-3)/2      TOTAL # BYTES SAVED PER CMPRS STMT
OUCM$L1  EQU   OUEA1-OULOC         # BYTES IN FIRST PART OF STMT
OUCM$L2  EQU   OUCM$LT-OUCM$L1     # BYTES SAVED, FROM OUDSTMT-1
         SPACE 1
*              CMPRS OPTION PHASE EQUATE FLAGS.
OUCMPHSB EQU   B'00000001'         (OUCMPHAS)- PHASE B - PRINTING CARDS
         SPACE 1
*              CMPRS PROCESSING VARIABLES.
OUCMSTMT DS    A                   @ SLOT FOR NEXT CARD SAVED/PRINTED
OUCMOPAG DS    H                   # STMTS TOTAL ON CURRENT PAGE
OUCMLEFT DS    H                   # SLOTS LEFT/ # ALREADY PRINTED
OUCMPHAS DS    B                   PHASE FLAG - A OR B.
OUCMCCIN DS    C                   CARRIAGE CONTROL INIT - '0' OR '1'
         SPACE 1
*              STATEMENT ASSEMBLY AREA - HOLDS BOTH HALVES OF A
*              LINE FOR PRINTING, DURING PHASE B OF PROCESSING.
         DS    0F                  ALIGN FOR POSSIBLE SPEED
OUCMLINE DS    0CL133
OUCMLICC DS    C                   CARRIAGE CONTROL BYTE
OUCMSTMA DS    CL(OUCM$LT)         SPACE FOR CARD SAVED IN PHASE A
OUCMBREK DS    CL2' '              BREAK - MUST INIT TO C'  '
OUCMSTMB DS    CL(OUCM$LT)         SPACE FOR CARD FROM PHASE B
         SPACE 1
*              CARD SEGMENT SAVE AREA - DURING PHASE A, ENOUGH CARDS
*              ARE SAVED HERE FOR LEFT-HAND-SIDE OF PAGE.
OUCMSAVE DS    ($OU#LNS)CL(OUCM$LT)         1 PAGE OF STMT SEGMENTS
         SPACE 1
OUCMPR$L EQU   ((*-OUCMPRSD+3)/4)*4         DSECT TOTAL LENGTH, ROUNDED
         SPACE 2
**--> DSECT: OUSTMTIM   STATEMENT IMAGE USED IN OUTPUT  . . . . . . . .
*.       USED IN CMPRS OPTION HANDLER OF OUTPT2 TO ACCESS PORTIONS    .
*.       OF INCOMING STATEMENTS TO BE SAVED.                          .
*.       NAMES: OUST----                                              .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         SPACE 1
OUSTMTIM DSECT
OUSTCC   DS    C                   CARRIAGE CONTROL
OUSTP1   DS    CL(OUCM$L1)         FIRST PART - LOC, OBJ CODE
         DS    2XL6                SKIP ADDR1-ADDR2, DON'T SAVE
OUSTP2   DS    CL(OUCM$L2)         2ND PART - STMT #, PART OF CARD
.OUCMDSE ANOP
         TITLE '*** SCANRS - SCANNING ROUTINES -SCAN-BL,CO,EQ ***'
**--> CSECT: SCANRS   1-2 SCANNING ROUTINES . . . . . . . . . . . . . .
*.       SCANRS CONTAINS VARIOUS UTILITY SCANNING ROUTINES. ALL 3     .
*.       ENTRIES TERMINATE SCANNING ON FINDING A BLANK. 1 ENTRY ALSO  .
*.       STOPS FOR A COMMA, AND THE OTHER STOPS FOR AN EQUALS SIGN.   .
*.       ****NOTE**** THIS ROUTINE MODIFIES TABLE AWTZTAB IN AVWXTABL..
*.       IT MAY THEN CALL SDBCDX WITHOUT RESETTING THE TABLE. THIS    .
*.       IS AN EXCEPTION TO THE RULE OF NOT PERMITTING MODIFICATION   .
*.       TO AV------ SECTIONS WHEN CALLING ANOTHER MODULE.            .
*.       CALLS SDBCDX                                                 .
*.       USES DSECTS: AVWXTABL                                        .
*.       USES MACROS: $CALL,$RETURN,$SAVE,$SETRT                      .
*.       NAMES: SCAN----                                              .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
SCANRS   CSECT
         $DBG  90,*
         USING AVWXTABL,RAT        NOTE MAIN USING
         ENTRY SCANBL,SCANCO,SCANEQ
         SPACE 2
**--> ENTRY: SCANEQ       SCAN TO = OR BLANK(USED BY IAMOP1 FOR LITERA.
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER                                                 .
*.       EXIT CONDITIONS                                              .
*.  RA = SCAN POINTER TO = OR BLANK, OR ERROR IF ANY                  .
*.  RB = 0    IF SCAN OK, = ERROR CODE IF ERROR FOUND(IN SELF-DEF TRM).
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
SCANEQ   $SAVE RGS=(R14-R2),SA=SCANSAVE     SAVE REGS,SET UP SA @
         $SETRT ('=',4)            SET UP CODE FOR =
         B     SCANGO              GO TO COMMON SECTION OF CODE
         SPACE 2
**--> ENTRY: SCANCO       SCAN TO COMMA OR BLANK (USED BY A-TYPE ADCON.
*.       ENTRY AND EXIT CONDITIONS SAME AS SCANEQ                     .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
SCANCO   $SAVE RGS=(R14-R2),SA=SCANSAVE     SAVE REGS,SET UP SA @
         $SETRT (',',4)            SET THE SCAN CODE FOR ,
         B     SCANGO              GO TO COMMON SECTION OF CODE
         SPACE 2
**--> ENTRY: SCANBL       SCAN TO BLANK ONLY. . . . . . . . . . . . . .
*.       ENTRY AND EXIT CONDITIONS SAME AS SCANEQ                     .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
SCANBL   $SAVE RGS=(R14-R2),SA=SCANSAVE,BR=R13   SAVE REGS, SET UP SA @
*              FALL THRU INTO COMMON SECTION OF CODE, SCANGO.
         EJECT
* * * * * COMMON CODE SECTION FOR SCANNING AND RESETTING TRT TABLE    *
SCANGO   $SETRT (' ',4,'''',8)     SET FOR QUOTE AND BLANK
         SR    R1,R1               CLEAR FOR INSERTING ADDRESS
         SR    R2,R2               CLEAR CODE INSERTION
         SR    RB,RB               CLEAR TO SHOW OK
*              INITIALIZATION DONE. REMAINDER IS SCAN LOOP            *
SCANTRT  TRT   0(256,RA),AWTZTAB   SCAN FOR ',BLANK OR EITHER = OR ,
         LR    RA,R1               MOVE THE SCAN POINTER OVER
         B     *(R2)               BRANCH APPROPRAITELY(CC=0 IMPOSSIB)
         B     SCANRETA            CHAR WAS =, OR BLANK-RETURN
         BCTR  R1,0                CHAR WAS QUOTE-BACK UP TO SEE BEFORE
         CLI   0(R1),C'L'          WAS THIS LENGTH ATTRIBUTE
         BNE   SCANSDT             NO-MUST BE SELF-DEFINING TERM-BRANCH
         LA    RA,2(R1)            INCREMENT SCAN POINTER PAST L'
         B     SCANTRT             GO BACK FOR NEXT SCAN
*              SELF-DEFINING TERM TENTATIVELY FOUND-CHECK             *
SCANSDT  LR    RA,R1               MOVE THE SCAN POINTER OVER
         $CALL SDBCDX              CALL ROUTINE(RB=0==>SCAN ONLY)
         LTR   RB,RB               DETERMINE RESULT
         BP    SCANRETA            ERROR FOUND,RETURN WITH IT
         BM    *+12                INVALID, ' BUT NOT X' B' C' L'
         CLI   0(RA),C''''         CHECK FOR CL21' ' TYPE ERROR IN OPRN
         BNE   SCANTRT             IF NOT,OK, CONTINUE, ELSE ERROR
         LA    RB,$ERINVDM         WE HAVE ',BUT NOTSDTRM-ERROR
SCANRETA $SETRT (' ',0,'''',0,'=',0,',',0)  REZERO ALL BYTES USED
         SPACE 1
SCANRET  $RETURN RGS=(R14-R2)      RETURN   TO CALLER
         DROP  RAT,R13             CLEAN UP USING SITUATION
         TITLE '*** SDTERM - SELF-DEFINING TERM PROCESSORS ***'
**--> CSECT: SDTERM     SELF-DEFINING TERM CONVERSIONS. . . . . . . . .
*.       SDTERM INCLUDES AN ENTRY POINT FOR CONVERTING EACH TYPE OF   .
*.       SELF-DEFINING TERM, AND AN ENTRY POINT WHICH FIRST DECIDES   .
*.       WHICH TYPE(IF ANY) THE SCAN POINTER IS POINTING AT, THEN     .
*.       BRANCHES TO THE CORRECT SECTION TO CONVERT THE TERM.         .
*.       USES DSECTS: AVWXTABL                                        .
*.       USES MACROS: $RETURN,$SAVE                                   .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
SDTERM   CSECT
         $DBG  90,SNAP
         ENTRY SDBCDX,SDBTRM,SDCTRM,SDDTRM,SDXTRM
         USING AVWXTABL,RAT        NOTE MAIN USING
         SPACE 2
**--> ENTRY: SDBCDX   1-2 DETERMINE TYPE OF SELF-DEFINING TERM-CHECK. .
*.       DECIDE TYPE OF SELF-DEFINING TERM, BRANCH TO RIGHT SECTION.  .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER TO BEGINNING OF TERM- TO C,B,X, OR 1ST DIGIT    .
*.       EXIT CONDITIONS                                              .
*.  RA = SCAN POINTER TO DELIMITER BEYOND TERM,(NOT ' ENDING B,C,X)   .
*.  RB = 0    SELF DEFINING TERM WAS LEGAL                            .
*.  EB = >0 - ERROR CODE - ILLEGAL TERM ($ERSDINV)                    .
*.  RB = -4 ==> SCAN POINTER DID NOT POINT AT SELF-DEFINING TERM      .
*.  RC = VALUE OF SELF-DEFINING TERM, FROM 0 TO 2**24-1               .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
SDBCDX   $SAVE SA=NO
         CLI   0(RA),C'0'          CHECK FOR DIGITS
         BNL   SDDTRM1             GO PROCESS DECIMAL FIELD
         CLI   1(RA),C''''         IS 2ND CAHR A '
         BNE   SDBCDX1             NO, SO RETURN SHOWING NO SELF-DEF TR
         CLI   0(RA),C'C'          CHARACTER TYPE
         BH    SDTX                HIGHER THAN C,TRY X
         BE    SDCTRM1             PROCESS C'----
         CLI   0(RA),C'B'          BINARY TYPE
         BE    SDBTRM1             PROCESS BINARY TERM
         B     SDBCDX1             EROR, NOT ONE OF THESE
SDTX     CLI   0(RA),C'X'          HEXADECIMAL TYPE
         BE    SDXTRM1             PROCESS HEX TERM
SDBCDX1  L     RB,AWFM4            PUT NEGATIVE 4 IN FOR RETURN CODE
         $RETURN SA=NO
         EJECT
**--> ENTRY: SDBTRM   1-2 SCAN, COMPUTE BINARY SELF-DEFINING TERM . . .
*.       ENTRY,EXIT CONDITONS SAME AS SDBCDX, EXCEPT RB >= 0 ON EXIT. .
*.       NAMES: SDB-----                                              .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
SDBTRM1  BALR  R15,0               SET UP ADDRESS AS EXPECTED ON ENTRY
SDBTRM   $SAVE RGS=NO,SA=NO
         LA    RA,2(RA)            INCREMENT BEYOND B'
         CLI   0(RA),C''''         MAKE SURE NOT NULL CONST
         BE    SDBINVCN            NULL CONSTANT-ILLEGAL
         SR    RC,RC               CLEAR REGISTER RESULT APPEARS IN
         LA    RD,1                FOR LOOP INCREMENT
         LA    RE,24(RA)           FOR LIMIT ADDRESS
         SPACE 1
SDBLOOP  CLI   0(RA),C'0'          CHECK FOR 0
         BE    SDBLOOPB            IF SO, JUST SHIFT RESULT
         CLI   0(RA),C'1'          CHECK FOR  A 1
         BNE   SDBOUT              BRANCH IF NOT, SHOULD BE '
         AR    RC,RD               ADD A 1 INTO REGISTER
SDBLOOPB AR    RC,RC               = SLL RC,1 - SHIFT TO NEXT
         BXLE  RA,RD,SDBLOOP       CONTINUE LOOPING
         BCT   RA,SDBINVCN         TOO LARGE, BACK UP AND FLAG
         SPACE 1
SDBOUT   CLI   0(RA),C''''         MAKE SURE DELIMETER IS '
         BNE   SDBINVCN            IF NOT , ILLEGAL
         AR    RA,RD               POINT TO NEXT BEYOND
         SRL   RC,1                SHIFT BACK FOR CORRECT RESULT
         SR    RB,RB               SHOW NO ERRORS
SDBRET   $RETURN SA=NO,RGS=NO
SDBINVCN LA    RB,$ERSDINV         SHOW ILLEGAL
         B     SDBRET              RETURN
         EJECT
**--> ENTRY: SDCTRM   1-2 SCAN, COMPUTE CHARACTER SELF-DEFINING TERM. .
*.       ENTRY,EXIT CONDITONS SAME AS SDBCDX, EXCEPT RB >= 0 ON EXIT. .
*.       NAMES: SDC-----                                              .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
SDCTRM1  BALR  R15,0               SET UP ADDRESS AS EXPECTED ON ENTRY
SDCTRM   $SAVE RGS=NO,SA=NO
         SR    RC,RC               CLEAR REGISTER FOR RESULT
         LA    RD,1                FOR USEFUL CONTANT
         AR    RA,RD               INCREMENT FOR  C TO '
         LA    RE,4                LIMIT = MAX CHARS(3)+1
         SPACE 1
*              SCAN LOOP - CHECK FOR 'S AND &S AND LENGTH <4 BYTES.
SDCLOOP  AR    RA,RD               INCREMENT TO LOOK AT NEXT SLOT
         CLI   0(RA),C''''         IS IT A QUOTE
         BE    SDCQUOT             YES-BRANCH
         CLI   0(RA),C'&&'         IS IT AN &
         BNE   SDCNORM             NO, GO DO NORMAL CASE
         AR    RA,RD               INCREMENT TO NEXT SLOT
         CLI   0(RA),C'&&'         IS THIS ONE & ALSO
         BE    SDCNORM             2 &&'S TOGETHER-OK
         B     SDCINVCN            INVALID - SINGLE & BY ITSELF
         SPACE 1
SDCQUOT  AR    RA,RD               LOOK AT NEXT CHAR
         CLI   0(RA),C''''         IS IS FOLLOWED BY '
         BNE   SDCOUT              NO, IT IS END OF CONST
SDCNORM  SLL   RC,8                SHIFT 1 CHRACTER WORTH
         IC    RC,0(RA)            GET THE CHARACTER
         BCT   RE,SDCLOOP          KEEP GOING-UP TO 24 BITS WORTH
         SPACE 1
         B     SDCINVCN            FELL THRU-MORE THAN 3 CHARS-ILLEGAL
SDCOUT   C     RE,AWF3             WAS THERE A NULL CONSTANT
         BH    SDCINVCA            RE = 4 ==> NULL CONST,ILLEGAL
         SR    RB,RB               SHOW NO ERRORS
SDCRET   $RETURN RGS=NO,SA=NO
SDCINVCA SR    RA,RD               NULL CONST-BACK UP SCAN PTR 1
SDCINVCN LA    RB,$ERSDINV         SHOW INVALID
         B     SDCRET              GO RETURN
         EJECT
**--> ENTRY: SDDTRM   1-2 CHECK OR CONVERT DECIMAL SELF-DEFINING TERM .
*.       ENTRY,EXIT CONDITONS SAME AS SDBCDX, EXCEPT RB >= 0 ON EXIT. .
*.       NAMES: SDD-----                                              .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
SDDTRM1  BALR  R15,0               SET UP ADDRESS AS EXPECTED ON ENTRY
SDDTRM   $SAVE RGS=(R1-R2),SA=NO
         LR    RD,RA               DUPLICATE SCAN POINTER
         SR    R1,R1               CLEAR FOR USE WITH TRT
         TRT   0(9,RD),AWTDECT     TRANSLATE WITH DECIMAL TABLE
         BZ    SDDINVCN            MORE THAN 9 DIGITS, ERROR
         LR    RA,R1               MAKE R1 NEW SCAN POINTER
         SR    R1,RD               SUBTRACT TO GET LENGTH
         BZ    SDDINVCN            IF ZERO LENGTH,ILLEGAL
         SPACE 1
         BCTR  R1,0                GET LENGTH-1 FOR EXECUTE
         EX    R1,SDDPACK          PACK THE CHARS IN
         CVB   RC,AVDWORK1         CONVERT THE NUMBER
         C     RC,AWFX6F           COMPARE TO HIGHEST VALUE
         BH    SDDINVCM            IF TOO BIG, BACK UP SCAN PTR,RETURN
         SPACE 1
         SR    RB,RB               SHOW NO ERRORS EXIST
SDDRET   $RETURN RGS=(R1-R2),SA=NO
SDDINVCM BCTR  RA,0                DECREMENT SCAN POINTER BY 1
SDDINVCN LA    RB,$ERSDINV         SHOW INVALID SD TERM
         B     SDDRET              GO RETURN WITH ERROR
         SPACE 1
SDDPACK  PACK  AVDWORK1(8),0($CHN,RD)        PACK A DECIMAL FIELD
         EJECT
**--> ENTRY: SDXTRM   1-2 SCAN, COMPUTE HEXADECIMAL SELF-DEFINING TERM.
*.       ENTRY,EXIT CONDITONS SAME AS SDBCDX, EXCEPT RB >= 0 ON EXIT. .
*.       NAMES: SDX-----                                              .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
SDXTRM1  BALR  R15,0               SET UP ADDRESS AS EXPECTED ON ENTRY
SDXTRM   $SAVE RGS=(R1-R2),SA=NO
         LA    RA,2(RA)            INCREMENT PAST X'
         SR    R1,R1               CLEAR FOR TRT
         TRT   0(7,RA),AWTHEXT               CHECK FOR LEGALITY
         BZ    SDXINVCX            TOO LARGE, GO FLAG IT
         CLI   0(R1),C''''         CHECK FOR PROPER DELIMIETER
         BNE   SDXINVCY            INVALID CHARACTER,ERROR
         SPACE 1
         LR    RD,RA               SAVE THE SCAN POINTER
         LA    RA,1(R1)            INCREMENT THE SCAN POINTER
         SR    R1,RD               GET THE LENGTH
         BZ    SDXINVCW            NULL CONSTANT-BRANCH ERROR
         SPACE 1
         EX    R1,SDXMOVE          MOVE THE CONST+1 EXTRA BYTE OVER
         EX    R1,SDXTRAN          TRANSLATE THE BYTES APPROPRIATELY
         EX    R1,SDXPACK          PACK THEM TOGETHER
         L     RC,AVDWORK1         LOAD FULLWORD VALUE INTO REG
         SR    RB,RB               SHOW LEGAL VALUE
SDXRET   $RETURN RGS=(R1-R2),SA=NO
         SPACE 1
SDXINVCW BCT   RA,SDXINVCN         BACK UP SCAN PTR,GO RETURN ERR
SDXINVCX LA    R1,6(RA)            TOO LONG-PLACE SCAN PTR RIGHT
SDXINVCY LR    RA,R1               MOVE SCAN POINTER OVER
SDXINVCN LA    RB,$ERSDINV         INVALID SELF-DEFINING TERM
         B     SDXRET              GO RETURN
         SPACE 1
SDXMOVE  MVC   AVDWORK2($CHN),0(RD)          MOVE HEX TERM TO WORKAREA
SDXTRAN  TR    AVDWORK2($CHN),AWTHEX2        CONVERT HEX TO BINARY
SDXPACK  PACK  AVDWORK1(5),AVDWORK2($CHN)    DO CORRECT PACK-INTERNAL
         DROP  RAT,REP             CLEAN UP USING
         TITLE '*** SYMOPS - ASSIST SYMBOL TABLE OPERATIONS ***'
**--> CSECT: SYMOPS   1-2 ALL NORMAL SYMBOL TABLE OPERATIONS. . . . . .
*.       SYMOPS BUILDS, MAINTAINS, AND RETRIEVES FROM THE SYMBOL      .
*.       TABLE OF THE ASSIST ASSEMBLER.  THE SYMBOL TABLE IS A VIRUTAL.
*.       SCATTER TABLE, WITH CHAIN ORDERING BY A SECONDARY HASH CODE. .
*.       ALL SYMBOLS ARE HASHED INTO A SMALL PRIMARY POINTER TABLE.   .
*.       EACH WORD IN THE PRIMARY TABLE POINTS TO A LINKED LIST OF    .
*.       SYMBOLS HASHING TO THAT LOCATION IN THE PRIMARY TABLE. THE   .
*.       SYMBOLS ARE ORDERED ON THE LIST IN DESCENDING ORDER BY THE   .
*.       VALUE OF A SECOND HASH CODE, WHICH IS KEPT IN THE LINK       .
*.       POINTER POINTING TO THE SYMBOL TO WHICH IT BELONGS.  THIS    .
*.       METHOD IS USED BECAUSE MAKES NO ASSUMPTIONS ABOUT THE FINAL  .
*.       SIZE OF THE FINAL SYMBOL TABLE, PERMITTING ALLOCATION OF     .
*.       ENTRIES FROM THE DYNAMIC AREA.  IT ALSO PERMITS A VERY FAST  .
*.       (3 FAST INSTRUCTIONS) MAJOR SEARCH LOOP, WHICH STILL GIVES   .
*.       GOOD PERFORMACNE EVEN WITH A SMALL INITIAL POINTER TABLE     .
*.       AND LONG LISTS OF SYMBOLS.                                   .
*.       CALLS MOSTOP                                                 .
*.       USES DSECTS: AVWXTABL,SYMSECT                                .
*.       USES MACROS: $ALLOCH,$CALL,$RETURN,$SAVE                     .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         SPACE 1
SYMOPS   CSECT
         $DBG  90,*
&$SYHASH SETA  8                   SET UP 1ST VALUE
         AIF   (&$OPTMS EQ 0).SYHA
&$SYHASH SETA  16                  TRY ALRGER VALUE
         AIF   (&$OPTMS LE 3).SYHA SKIP IF NOW HAVE RIGHT VALUE
&$SYHASH SETA  32                  LARGER VALUE
         AIF   (&$OPTMS LE 6).SYHA          SKIP IF NOW HAVE VALUE
&$SYHASH SETA  64                  LARGEST VALUE CURRENTLY
.SYHA    ANOP
*              USING VALUE OF &$OPTMS, DETERMINE SIZE OF INITIAL POINT*
*        HASH TABLE.  VALUES ARE (&$OPTMS)-&$SYHASH -                 *
*        (0)-8, (1-3)-16, (4-6)-32, (7-9)-64.   THE RELATIVELY SMALL  *
*        SIZES CAN BE TOLERATED BECAUSE OF THE SECONDARY KEY ORDERING.*
         SPACE 1
         ENTRY SYINT1,SYENT1,SYFIND,SYEND2
         USING AVWXTABL,RAT        NOTE MAIN USING
         EJECT
**--> ENTRY: SYINT1   1   INITIALIZE SYMBOL TABLE . . . . . . . . . . .
*.       OBTAINS SPACE FOR INITIAL POINTER TABLE, ZEROES IT.          .
*.       ALSO SAVES THE ADDRESS OF THE INITIAL POINTER TABLE.         .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
SYINT1   $SAVE RGS=(R14-R6),SA=NO
         LM    R0,R7,AWZEROS       GET ZEROS FOR ZEROING HASH TABLE
         LA    R10,32              # BYTES ZEROED BY EACH STM
         LA    R11,4*&$SYHASH      GET LENGTH OF INITIAL PTR TABLE
         $ALLOCH R9,R11,SYOVER     ALLOCATE THE REQUIRED SPACE
         AR    R11,R9              END TABLE @ = BEGIN TABLE @ + LENGTH
         SPACE 1
         SR    R11,R10             BXLE LIMIT = END @ - LOOP INCREMENT
         ST    R9,SYRA             SAVE THE BEGIN TABLE @ FOR LATER
SYIZERO  STM   R0,R7,0(R9)         ZERO 32 BYTES OF INDEX TABLE
         BXLE R9,R10,SYIZERO       CONTINUE ZEROING
         $RETURN RGS=(R14-R6),SA=NO
         EJECT
**--> ENTRY: SYENT1   1   ENTER A SYMBOL INTO TABLE,RETURN ADDRESS. . .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER TO FIRST CHARACTER OF THE SYMBOL                .
*.  RB = NUMBER OF CHARACTERS IN THE SYMBOL  =  1 - 8                 .
*.       EXIT CONDITIONS                                              .
*.  RA = ADDRESS IN THE SYMBOL TABLE WHERE SYMBOL IS                  .
*.  RB = 0    THE SYMBOL WAS ALREADY PRESENT IN THE TABLE             .
*.     = 4    THE SYMBOL WAS NOT ALREADY PRESENT IN THE TABLE         .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         AIF   (NOT &$XREF).NOXRF19
SYENT1   $SAVE RGS=(R14-R6),SA=SYXRSA,BR=R2  **NOTE ODD BASE REG***
         AGO   .NOXRF20            SKIP OLD SAVE MACRO
.NOXRF19 ANOP
SYENT1   $SAVE RGS=(R3-R6),SA=NO
.NOXRF20 ANOP                                                         A
         LA    RC,SYENTER          SET UP FOR BRANCH LATER ON
         LA    RW,SYRETB           SET UP FOR BRANCH LATER            L
         AIF   (NOT &$XREF).NOXRF22  SKIP IF NO XREF                  A
         B     SYXFINDX            GO TO ROUTINE                      A
         AGO   .NOXRF23            SKIP OLD CODE IF XREF              A
.NOXRF22 ANOP                                                         A
         LA    REP,SYFIND          SET UP FOR NEW USING
         USING SYFIND,REP          SET SO BRANCH WILL WORK
         B     SYFINDA             GO TO COMMON CODE SECTION
.NOXRF23 ANOP                                                         A
         SPACE 2
**--> ENTRY: SYFIND   1-2 LOOK UP SYMBOL,REPORT PRESENCE/ADDRESS. . . .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER TO FIRST CHARACTER OF THE SYMBOL                .
*.  RB = NUMBER OF CHARACTERS IN THE SYMBOL  =  1 - 8                 .
*.       EXIT CONDITIONS                                              .
*.  RA = ADDRESS OF THE SYMBOL IN THE SYMBOL TABLE, IF IT IS THERE    .
*.  RB = 0    THE SYMBOL IS IN THE TABLE                              .
*.     = 4    THE SYMBOL IS NOT IN THE TABLE                          .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         AIF   (NOT &$XREF).NOXRF24                                   A
SYFIND   $SAVE RGS=(R14-R6),SA=SYXRSA,BR=R2     ***NOTE ODD BASE REG  A
         AGO   .NOXRF25                                               A
.NOXRF24 ANOP                                                         A
SYFIND   $SAVE RGS=(R3-R6),SA=NO
.NOXRF25 ANOP                                                         A
         LA    RC,SYRETA           SET ADDRESS FOR LATER
         LA    RW,SYRET            SET UP FOR BRANCH LATER            L
         AIF   (NOT &$XREF).NOXRF88    SKIP IF NO XREF                A
SYXFINDX BALR  R2,0                SET UP BASE REG                    A
         USING *,R2                                                   A
.NOXRF88 ANOP                                                         A
         SPACE 1
*              GET SYMBOL, PAD WITH BLANKS, GET LENGTH OF SYMBOL      *
*              THE FOLLOWING CODE IS COMMON TO BOTH SYFIND AND SYENT1 *
SYFINDA  STC   RB,SYCOMP2+1        SAVE THE LENGTH INTO CLC
         BCTR  RB,0                DECRMENT LENGTH FOR MOVE
         MVC   SYMTEMP,AWBLANK     FILL WITH BLANKS FOR PADDING
         STC   RB,SYMTEMPC         SAVE VALUE IN FRONT OF SYMBOL
         STC   RB,*+5              PUT LENGTH INTO MVC INSTRUCTION
         MVC   SYMTEMP($CHN),0(RA)           MOVE AND PAD SYMBOL
         EJECT
*              HASH SYMBOL, GET ADDRESS OF 1ST POINTER, GET 2ND HASH  *
         LM    RD,RE,SYMTEMP       GET HALVES OF SYMBOL FOR HASHING
         MR    RD,RD               MULT 1ST HALF * 2ND HALF OF SYMBOL
         LM    RX,RB,SYREGS        GET WHOLE BLOCK OF REGS            L
         NR    RD,RZ               COMPUTE PRIMARY HASH CODE
         AR    RA,RD               GET ADDRESS OF  1ST HASHTAB ENTRY
         USING SYMSECT,RA          NOTE USAGE OF DSECT FROM NOW ON
*              FIRST HASH CODE COMPLETE. NOW GET SECONDARY HASH CODE. *
         SR    RD,RD               CLEAR REG OUT BEFORE SHIFTING CODE
         SLDL  RD,8                MOVE  8 BITS FOR SECONDARY CODE
         LTR   RD,RD               IS SECONDARY CODE ZERO
         BNZ   SYKEY2A             IF NOT ZERO,OK
         LA    RD,255              PUT THIS VALUE FOR SECONDARY KEY
SYKEY2A  STC   RD,SYCOMP1+1        PLACE SECONDARY KEY INTO CLI INST
         BAL   RE,SYCOMP1          SKIP L 1ST TIME,SET UP ADDR IN REG
         SPACE 1
*              FOLLOWING THREE INSTRUCTIONS - MAIN SEARCH LOOP        *
*              EACH LOOP CHECKS SECONDARY CODE OF NEXT SYMBOL IN LIST.*
SYLOOP1  L     RA,SYLINK           GET NEXT POINTER
SYCOMP1  CLI   SYHASH2,$CHN        COMPARE SECONDARY CODES
         BCR   H,RE                BH SYLOOP1 - CONTINUE IF HIGH
         BCR   L,RC                BL SYENTER OR SYRETA IF NOT PRESENT
         SPACE 1
*              SEARCH LOOP FOR ACTUAL SYMBOL COMPARISON               *
*              THIS IS ONLY ENTERED FOR SYMBOLS WITH IDENTICAL CODES  *
SYLOOP2  LR    RE,RA               DUPLICATE OLD POINTER VALUE
         L     RA,SYLINK           GET @ NEXT POINTER ON CHAIN
SYCOMP2  CLC   SYMTEMPC($CHN),SYCHARS        COMPARE # OF CHARS,SYMBOLS
         BCR   E,RW                BE->SYRETB(PASS1),SYRET(PASS2)     L
         EX    0,SYCOMP1          MAKE SURE SECONDARY IS SAME
         BCR   E,RX                BE SYLOOP2 - KEEP CHECKING
         LR    RA,RE               RESTORE REG POINTER FOR ENTRY
         BR    RC                  B SYENTER OR SYRETA,DEPENDING
         SPACE 1
         SPACE 1                                                      L
*        ENTERS PASS 2 WHEN SYMBOL IS IN SMBL TABLE (RB=0)            L
SYRET    EQU   *                   ENTER WHEN SYMBOL PRESENT          L
         AIF   (NOT &$XREF).NOXRF17                                   L
         TM    AVXRFLAG,AVXRON     FLAG MAY HAVE BEEN DISARMED(XRCOLL)L
         BZ    SYRETB              RETURN IF NOT ON (=0)              L
         MVC   AVFWORK1(1),AVXRFLAG SET UP FOR REF COLLECT TESTING    L
         NC    AVFWORK1(1),SYFLAGS  AND WITH SD= BITS                 L
*  SEE IF MODIFY OR FETCH                                             L
         TM    AVXRTYPE,AVXRFTCH   FETCH REFERENCE                    L
         BZ    SYCKMOD             NO,MODIFY REF                      L
         TM    AVFWORK1,AVXRSRFT   FETCH REFS?                        L
         BZ    SYRETB              NO, RETURN                         L
         B     SYXRCALL            GO COLLECTBREFS                    L
SYCKMOD  TM    AVFWORK1,AVXRSRMD   COLLECT MOD REFS?                  L
         BZ    SYRETB              NO,RETURN                          L
SYXRCALL EQU   *                   CALLING XRCOLL TO COLLECT REFERENCEL
         $CALL XRCOLL              CALL COLLECTIMG ROUTINE            L
         SR    RB,RB               SET RETURN CODE                    L
.NOXRF17 ANOP                                                         F
         B     SYRETB              GO RETURN                          L
*              ENTER NEW SYMBOL-MUST HAVE BEEN CALLED AT SYENT1       *
SYENTER  CLI   SYMTEMPC,4          CHECK FOR LENGTH
         BL    *+8                 L<=4==> LEAVE 4 IN RW-PREV LOADED
         LA    RY,8                WILL NEED 8 BYTES                  L
         LA    RC,SYMBOL-SYMSECT(RY)  GET LENGTH OF ENTRY             L
         $ALLOCH RE,RC,SYOVER      GET NEEDED SPACE
         L     RC,SYLINK           GET THE OLD SYLINK-SYHASH2 FIELD
         ST    RE,SYLINK           SAVE THE POINTER INTO OLD POINTER
         STC   RD,SYHASH2          SAVE 2ND HASH CODE IN THERE TOO
         LR    RA,RE               MAKE DSECT LOCATED AT NEW AREA
         ST    RC,SYLINK           STORE OLD SYLINK-SYHASH2 INTO NEW
         MVC   SYVALUE(SYCHARS-SYVALUE),AWZEROS        ZERO FLAGS,ETC
         STC   RY,*+5              MOVE LENGTH INTO MVC               L
         MVC   SYCHARS($CHN),SYMTEMPC        MOVE LENGTH&SYMBOL OVER
         SPACE  5                                                     A
         AIF   (NOT &$XREF).NOXRF55  SKIP ID NO CROSS REF             A
*  THE FOLLWING SECTION OF CODE IS USED FOR THE CROSS REFERENCE       A
*   FACILITY.  THE BYTE SYFLAGS IS SET BY THE BITS IN AVXRFLAG, THIS  A
*   ARE LATER TESTED TO SEE WHICH REFERENCES WE ARE COLLOECTING       A
*                                                                     A
         TM    AVXRFLAG,AVXRSDFT+AVXRSDMD   ARE WE COLLECTIOG DEFS    A
         BZ    SYRETA              NO, RETURN                         A
         LH    RB,AVXRCNT          GET # OF REFS COLLECTED            A
         LA    RB,1(RB)            INCREASE BY ONE                    A
         STH   RB,AVXRCNT          RESTORE IT                         A
         IC    RB,AVXRFLAG         GET FLAG IN REG TO SET BITS        A
         N     RB,=A(AVXRSDFT+AVXRSDMD)     FOR SETTING SYFLAGS       L
         SRL   RB,2                MOVE TO RIGHT POSITION             A
         IC    RY,SYFLAGS          PREPARE TO OR FLAGS                L
         OR    RB,RY               SET PROPER BITS IN SYFLAGS         L
         STC   RB,SYFLAGS          STORE IT IN FLAG                   A
.NOXRF55 ANOP                                                         A
         SPACE 1
*              RETURN,SHOWING SYMBOL PRESENT/NOT PRESENT/OVERFLOW     *
SYRETA   LA    RB,4                SHPW THE SYMBOL WAS NEW
SYRETB   EQU   *                                                      A
         AIF (NOT &$XREF).NOXRF18                                     F 1944322
         $RETURN RGS=(R14-R6),SA=*     RETURN IF XREF IS ON           F
         AGO   .NOXRF99                                               F
.NOXRF18 ANOP                                                         F
         $RETURN RGS=(R3-R6),SA=NO     RETURN IF XREF IS OFF          F
.NOXRF99 ANOP                                                         F
         EJECT
*              EXIT FOR STORAGE EXCEEDED.  AS 999 MESSAGE.
SYOVER   $GTAD REP,MOSTOP          GET ADDR OF EXIT
         BR    REP                 GO THERE, NVER TO RETURN
         SPACE 2
**--> ENTRY: SYEND2   2   CLEANUP AT END OF PASS 2. . . . . . . . . . .
*.       *** FUTURE USE - WILL COMPUTE SYMBOL TABLE STATISTICS.       .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
SYEND2   BR    RET                 RETURN,NOTHING EXISTS RIGHT NOW
         SPACE 2
* * * * * INTERNAL CONSTANTS                                          *
SYREGS   DS    0F                  FOLLOWING IS REGISTER BLOCK FOR LM
SYRX     DC    A(SYLOOP2)          ADCON FOR BRANCHES
SYRY     DC    F'4'                FIRST GUESS FOR ROUNDED SYMBL LEN  L
SYRZ     DC    A(4*(&$SYHASH-1))   SHIFTED MASK FOR 1ST HASH CODE
SYRA     DS    A                   BEGINNING @ HASH INDEX TABLE
SYRB     DC    F'0'               RETURN CODE= SYMBOL ALREADY PRESENT
         SPACE 1
* * * * * INTERNAL VARIABLES                                          *
SYMTEMP  EQU   AVDWORK2            DS D, SPACE FOR SYMBOL
SYMTEMPC EQU   SYMTEMP-1           FOR # CHARACTERS IN SYMBOL
         AIF   (NOT &$XREF).NOXRF50                                   A
         DROP  RAT,R2,RA           CLEAN UP USINGS                    A
         LTORG                                                        A
         AGO   .NOXRF51                                               A
.NOXRF50 ANOP                                                         A
         DROP  RAT,REP,RA          CLEAN UP USING SITUATION
.NOXRF51 ANOP                                                         A
         TITLE '*** UTOPRS - INCORE DISK UTILITY OPERATIONS ***'
**--> CSECT: UTOPRS   1-2 UTILITY DATA SET ROUTINES . . . . . . . . . .
*.             THIS MODULE PERFORMS ALL THE HANDLING WHICH WOULD      .
*.       NORMALLY BE DONE USING SECONDARY STORAGE FOR INTERMEDIATE    .
*.       SOURCE RECORDS AND FOR OBJECT CODE.  IT USES THE LOWER END   .
*.       OF THE DYNAMIC CORE AREA TO STORE THE RECORD BLOCKS (RSBLOCK,.
*.       RSCBLK,REBLK) RESULTING FROM THE SOURCE PROGRAM, AND PLACING .
*.       THEM DURING PASS 1 SO THAT THE OBJECT CODE CAN BE OVERLAID   .
*.       INTO THE SAME AREA.  I.E. IN NO CASE WILL THE RECORDS BLOCKS .
*.       FOR A SOURCE STATEMENT BE PLACED NEARER THE BEGINNING OF THE .
*.       AREA THAN THE OBJECT CODE RESULTING FROM THE STATEMENT.      .
*.                                                                    .
*.       CODE FOR THIS MODULE DEPENDS HEAVILY ON &$DISKU, WHICH       .
*.       CAN ALLOW UTOPRS TO USE DISK FOR INTERMEDIATE STORAGE.       .
*.       &$DISKU = 0 ==> EVERYTHING IN CORE (NORMAL ASSIST).          .
*.       &$DISKU = 1 ==> USER HAS INCROEE/DISK OPTION (DISKU,NODISKU) .
*.       &$DISKU = 2 ==> ALWAYS GO TO DISK, NO INCORE CODE EXISTS.    .
*.                                                                    .
*.       USES MACROS: $DISK,$RETURN,$SAVE                             .
*.       CALLS XXXXDKOP,XXXXDKRD,XXXXDKE1,XXXXDKWT                    .
*.       USES DSECTS: AVWXTABL                                        .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
UTOPRS   CSECT
         $DBG  C0,*
         ENTRY UTINT1,UTPUT1,UTEND1,UTGET2,UTPUT2,UTEND2
         USING AVWXTABL,RAT        NOTE MAIN TABLE USING
         SPACE 2
**--> ENTRY: UTINT1   1   INITIALIZE UTILITY ROUTINES . . . . . . . . .
*.       INITIALIZES UT POINTER TO BEGINNING OF RECORD BLOCK AREA.    .
*.       USES DSECTS: AVWXTABL                                        .
*.       USES MACROS: $RETURN,$SAVE                                   .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
UTINT1   $SAVE SA=NO
         AIF   (&$DISKU NE 1).UTINADK  SKIP UNLESS DISKU OPTIONAL
         TM    AVTAGS1,AJODISKU    IS DISK UTILITY ON?
         BNO   UTINODSK            N/--NODISK--CONTINUE NORMALLY
.UTINADK AIF   (&$DISKU LT 1).UTINODK        SKIP IF NO DISK
         $DISK OP                  INITIALIZE DISK UTILITY
         BM    UTINODSK            DISK DCB NOT OPEN-CANCEL DISK OPTION
         LA    RE,AVBUFINC         GET @ OF BUFFE @
         ST    RE,UTCONTRL         SAVE IN UTOPS CONTROL WORD
         AIF   (&$DISKU EQ 2).UTINODK        SKIP UNNEC CODE FOR 2
         MVI   UTBRCHNG+1,X'F0'    SET UTPUT1 TO ALWAYS BRANCH
         B     UTDISKON            DISK IS ON--SKIP NEXT CODE
UTINODSK EQU   *                   ESTABLISH DESTINATION LABEL
         LA    RE,AVADDLOW         INITIALIZE UTCONTROL WORD
         ST    RE,UTCONTRL         WITH @ OF AVADDLOW
         MVI   UTBRCHNG+1,X'00'    SET BRANCH MASK TO 0
.UTINODK AIF   (&$DISKU EQ 2).UTINODL        SKIP UNNNEC CODE FOR 2
         MVI   UTP1RSB1+1,X'00'    MAKE INCORE CODE NOP FIRST TIME
.UTINODL ANOP
*              FOLLOWING CODE MAKES SURE REAL LOWEST @ OF USER PROGRAM
*              IS MULTIPLE OF 32.  XXXXSNAP REQUIRES THIS TO GET
*              REASONABLE COMPLETION DUMPS AND XDUMPS.
*              OTHERWISE, CODE  MVC UTSTART,AVADDLOW WOULD SUFFICE.
UTDISKON L     RE,AVADDLOW         GET LOWEST LIMIT VALUE
         LA    RD,31               SET UPF ALIGNMENT VALUE
         $ALIGR RE,RD              ALIGN TO 32-MULTIPLE
         ST    RE,AVADDLOW         STORE BACK, NOW ALIGNED
         ST    RE,AVRADL           STORE BACK, ALIGNED OK
         AIF   (NOT &$RELOC).UTINREL        SKIP IF NO RELOCATION
         TM    AVTAGS1,AJORELOC    SHOULD CODE BE RELOCATED
         BZ    UTINTRET            NO,DON'T FIXUP ADDRESSES
*              FOLLOWING CODE SIMULATES A USER START CARD WITH VALUE
*        OF ACTUAL LOAD POINT IN MEMORY. RELOCATION IS THUS AUTOMATIC.
         MVC   AVFENTER,AVADDLOW   MOVE IN LOWEST ADDR AS DEFAULT ENTRY
         MVC   AVLOCLOW(20),AVFENTER   FILL IN @'S INSTEAD OF ZEROES
         OI    AVTAGS1,$IBSTAR1    FLAG A START, FINISH FAKERY
.UTINREL ANOP
UTINTRET $RETURN SA=NO
         AIF   (&$DISKU NE 2).UTINODM        SKIP IF NOT DISK ONLY
UTINODSK $GTAD REP,MOSTOP          GET ADDR OF EXIT/OVERFL
         BR    REP                 GO TO FLAG, END PASS 1
.UTINODM ANOP
         EJECT
**--> ENTRY: UTPUT1   1   WRITE TO UTILITY DURING PASS 1. . . . . . . .
*.       UTPUT1 MOVES ALL EXISISTING RECORD BLOCKS FOR A STATEMENT    .
*.       INTO THE LOW END OF THE DYNAMIC CORE AREA, AT THE END OF     .
*.       PROCESSING EACH STATEMENT DURING PASS 1.  THE BLOCKS ARE     .
*.       NEVER PLACED CLOSER TO THE BEGINNING OF THE RECORD BLOCK     .
*.       AREA THAN ANY OBJECT CODE WHICH COULD BE PRODUCED BY THE     .
*.       STATEMENT.  THIS MAKES IT SAFE IN PASS 2 TO JUST MOVE        .
*.       OBJECT CODE INTO THE SAME OVERALL AREA, WITH NO FEAR OF      .
*.       OVERWRITING RECORD BLOCKS STILL NEEDED FOR THE SAME OR       .
*.       LATER STATEMENTS.  THE BLOCKS ARE PLACED IN THIS ORDER:      .
*.       RSBLOCK, (RCODBLK), (REBLK), (RSCBLK)   WITH THE BLOCKS      .
*.       IN ( ) PLACED IF THEY EXIST.  **NOTE** BLOCKS RSBLOCK AND    .
*.       RCODBLK ARE ALWAYS ALIGNED TO FULLWORD BOUNDARY.             .
*.       CALLS MOSTOP                                                 .
*.       USES DSECTS: AVWXTABL,RSBLOCK                                .
*.       USES MACROS: $ALIGR,$CALL,$GLOC,$RETURN,$SAVE                .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         SPACE 1
* * * * * REGISTER ALLOCATION FOR UTPUT1  * * * * * * * * * * * * * * *
*   RX = INTERNAL LINK REGISTER (FOR CALLING UTPMOVE).                *
*   RY = CURRENT FREEAEA POINTER (AVADDLOW)                           *
*   RZ = CURRENT HIGH END POINTER (AVADDHIH)                          *
*   RA = 3     USED TO ALIGN LOCATIONS TO FULLWORD BOUNDARY($ALIGR)   *
*   RB = BYTE REGISTER FOR INSERTS(HI-ORDRR 3 BYTES = 0).             *
*   RC = VRSBPT    (FROM AVWXTABL)                                    *
*   RD = PARAMATER REGISTER FOR UTPMOVE INTERNAL SUBR (@ BLOCK).      *
*   RE = WORK REGISTER                                                *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
UTPUT1   $SAVE RGS=(R3-R6),SA=NO   RW-RZ, USE AS FEW REGS AS CAN
         OI    AVPRINT1,AVPRSAVE   MAKE SURE SAVED FROM NOW ON
         LA    RA,3                SET UP ALIGNMENT VALUE
         SR    RB,RB               CLEAR FOR INSERTIONS
         AIF   (&$DISKU NE 1).UTPT1A   NO USER OPTION ON DISK UTILITY
         L     RW,UTCONTRL         SET UP CONTROL WITH USER OPTION
         LM    RY,RZ,0(RW)         LOAD FROM EITHER AVADDLOW OR
*                                      AVBUFINC
UTBRCHNG BC     $,UTPNOFF           ALWAYS/NEVER BRANCH-DISK/NODISK
*                                      AROUND NORMALL PROCESSING IF DKU
*                                      NO BRANCH IF NOT DISK
.UTPT1A  AIF   (&$DISKU NE 2).UTPT1B   NO DISK AT ALL
         LM    RY,RZ,AVBUFINC      ALWAYS DISK, GET BUFFER PARMS
         AGO   .UTPT1DK            SKIP ALL INCORE ONLY CODE
.UTPT1B  AIF   (&$DISKU NE 0).UTPT1X   SKIP WHEN DISK UTILITY ON
         LM    RY,RZ,AVADDLOW      GET LOW-HIGH CORE POINTERS
.UTPT1X  ANOP
         $GLOC RE                  GET LOCATION COUNTER VALUE
         S     RE,AVLOCLOW         GET OFFSET
UTP1RSB1 BC    $,UTP1RSBX          SKIP IF NOT 1ST INCORE RSBLOCK SAVED
         MVI   UTP1RSB1+1,X'F0'    MAKE NOP A BRANCH AFTER 1ST TIME
         MVC   UTG2PT,AVADDLOW     INIT @ 1ST RSBLOCK, IF  ANY INCORE
UTP1RSBX EQU   *                   BRANCH HERE AFTER 1ST TIME THRU
         A     RE,AVRADL           ADD BASE @ OF UT CORE AREA
         SR    RE,RY               GET OFFSET REQUIRED,IF ANY
         BNP   UTPNOFF             BRANCH IF NO FURTHER OFFSET NEEDED
         TM    AVTAGS1,$IBDSEC1+AJNLOAD     IS EITHER DSECT OR NOLOAD
         BNZ   UTPNOFF             DSECT OR NOLAD, SO NO OFFSET REQUIRD
         SPACE 1
*              IF FALLS THRU-MUST OFFSET NEXT ENTRY BEYOND LOCCNTR    *
         $ALIGR RE,RA              ROUND OFFSET TO FULLWORD MULTIPLE
         AR    RE,RY               GET BACK ACTUAL @ FOR NEXT RSB TO GO
         CR    RE,RZ               MAKE SURE WE HAVE ROOM
         BNL   UTPOVER             DISASTER EXIT-OVERFLOW
         ST    RE,0(RY)            SAVE ADDRESS OF NEXT BLOCK
         LR    RY,RE               MOVE NEW POINTER OVER
.UTPT1DK ANOP
         SPACE 1
*              GET ALL THE RECORD POINTERS AND MOVE EXISTING ONES.    *
UTPNOFF  L     RC,AVRSBPT          GET ONLY DEFINITE EXISTING BLOCK
         USING RSBLOCK,RC          NOTE RECORD SOURCE BLOCK USING
         AIF   (NOT &$XREF).NOXRF11  SKII IF NO XREF                  A
         TM    RSBFLAG,$RSBNPNN    IS STMT TO BE NUMBERED             A
         BZ    UTPTNPRC            NO, DON'T INCREMENT                A
         AP    AVXRLNCN,AWP1       APP 1 TO LINE COUNTER(CROSS REF)   A
UTPTNPRC EQU   *                                                      A
.NOXRF11 ANOP                                                         A
         LR    RD,RC               MOVE PTR OVER FOR UTPMOVE
         BAL   RX,UTPMOVE          CALL MOVER SUBROUTINE
         SPACE 1
         $ALIGR RY,RA              GET FULLWORD ALIGNMENT
         TM    RSBFLAG,$RCBX       DO WE HAVE A RCB WITH THIS
         BZ    UTPREB              NO RCB-TRY FOR REB
         L     RD,AVRCBPT          GET @ RCODBLK
         BAL   RX,UTPMOVE          CALL MOVER ROUTINE
         SPACE 1
UTPREB   TM    RSBFLAG,$REBX       DO WE HAVE A REB
         BZ    UTPRSC              NO REB,LOOK FOR  RSCB
         L     RD,AVREBPT          GET @ REBLK (AVREBLK)
         BAL   RX,UTPMOVE          CALL MOVER ROUTINE
         SPACE 1
UTPRSC   TM    RSBFLAG,$RSCX       TEST FOR RSC
         BZ    UTPEND1             NO RSC-SKIP TO END
         L     RD,AVRSCPT          GET @ RSCBLK
         BAL   RX,UTPMOVE          CALL MOVER ROUTINE
         DROP  RC                  NO LONGER NEEDED FOR RSB
         SPACE 1
UTPEND1  $ALIGR RY,RA              ALIGN POINTER TO FULLWORD
         AIF   (&$DISKU NE 0).UTPT1D
         ST    RY,AVADDLOW         STORE POINTER BACK
         AGO   .UTPT1F
.UTPT1D  AIF   (&$DISKU NE 1).UTPT1E   GO TO ALWAYS DISK CODE
         ST    RY,0(RW)            STORE POINTER BACK
         AGO   .UTPT1F
.UTPT1E  ST    RY,AVBUFINC         STORE POINTER BACK
.UTPT1F  ANOP
UTPRET   $RETURN RGS=(R3-R6),SA=NO       RETURN
         SPACE 2
**--> INSUB: UTPMOVE    MOVE 1 RECORD BLOCK INTO DYNAMIC AREA + + + + +
*+       ENTRY CONDITIONS                                             +
*+  RD = ADDRESS OF THE BLOCK TO BE MOVED. ITS FIRST BYTE GIVES LEN-1 +
*+  RY = ADDRESS WHERE BLOCK SHOULD BE PLACED                         +
*+       EXIT CONDITIONS                                              +
*+  RY = ADDRESS OF NEXT FREE SPACE FOR BLOCKS.                       +
*+  + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
UTPMOVE  IC    RB,0(,RD)           GET LENGTH-1 OF BLOCK
         LA    RE,1(RB,RY)         INCREMENT @ PTR BY WHOLE LENGTH
         CR    RE,RZ               MAKE SURE WE HAVE ROOM
         BNL   UTPOVER             NO MORE ROOM-DISASTER
         STC   RB,*+5              STORE LENGTH-1 INTO MVC INSTUCTION
         MVC   0($,RY),0(RD)       MOVE BLOCK INTO DYNAMIC AREA
         LR    RY,RE               MOVE UPDATED LOW END POINTER BACK
         BR    RX                  RETURN TO CALLING SECTION OF UTPUT1
         SPACE 1
         AIF   (&$DISKU NE 0).UTPOVRA
UTPOVER  $GTAD REP,MOSTOP          GET ADDR OF EXIT - AS999 MESSAGE
         BR    REP                 GO THERE, ENDING PASS 1
         AGO   .UTPOVRB
.UTPOVRA AIF   (&$DISKU EQ 1).UTPOVRC  SKIP IF DISK UTILITY OPTIONAL
UTPOVER  $DISK WT                  CALL DISK UTILITY TO WRITE A BLOCK
         LM    RY,RZ,AVBUFINC      GET PARMS FROM CONTROL BLOCK
         B     UTPNOFF             PROCESS AT UTPNOFF
         AGO   .UTPOVRB
.UTPOVRC ANOP
UTPOVER  TM    AVTAGS1,AJODISKU    IS DISK ENABLED?
         BNO   UTPEXIT             NOT ENABLED  TAKE EXIT
         $DISK WT                  DISK ENABLED  WRITE A BLOCK TO DISK
         LM    RY,RZ,AVBUFINC      GRAB SOME CONTROL INFORMATION
*                                  ADDRESS OF NEXT BUFFER TO BE FILLED
         B     UTPNOFF             PROCEES AT UTPNOFF
UTPEXIT  $GTAD REP,MOSTOP          GET ADDRESS OF EXIT--AS999 MESSAGE
         BR    REP                 TAKE EXIT NOW
.UTPOVRB ANOP
         EJECT
**--> ENTRY: UTEND1   1   END PASS 1, PREPARE FOR PASS 2 OF ASSEMBLER .
*.       UTEND1 RESETS CORE POINTERS AND CALCULATES RELOCATION FACTOR..
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
UTEND1   $SAVE SA=NO
         L     RD,AVRADL           GET @ 1ST BYTE WHERE OBJ CODE GOES
         AIF   (&$DISKU EQ 2).UTE1A1  SKIP IF NO INCORE CODE AT ALL
         L     RE,AVADDLOW         CURRENT ENDING POINTER
         ST    RE,UTG2END          PTR TO END OF CORE USED (IF INCORE)
*              FOLLOWING STMT ONLY NEEDED IF UNUSED CORE FILL DONE.
         ST    RD,UTP2LAST         SAVE AVRADL AS INIT @ LAST CODE LOAD
         S     RD,AVLOCLOW         GET RELOCATION FACTOR
         ST    RD,AVRELOC          SAVE THE RELOCATION FACTOR
         AIF   (&$DISKU EQ 0).UTRET    SKIP WHEN NO DISK AT ALL
         AIF   (&$DISKU EQ 2).UTALW    SKIP WHEN ALWAYS DISK
         TM    AVTAGS1,AJODISKU    IS DISK UTILITY ON?
         BNO   UTRETE1             NO  RETURN AFTER THIS CODE
         SPACE 1
*        IF DISKU OPTION ON, MAKE SURE OBJECT CODE FITS INTO THE      *
*        ALLOWED AREA.  (THIS CHECK IS MADE CONSTANTLY DURING UTPUT1  *
*        FOR THE INCORE VERSION).  THIS ASSUMES AVADDHIH WILL REMAIN  *
*        CONSTANT FROM THIS POINT ON.  IF AVADDHIH MAY BE CHANGED,    *
*        IT WILL BE NECESSARY TO CHECK DURING UTPUT2 .                *
         SPACE 1
         A     RD,AVLOCHIH         RD = REAL @ OF END OF OBJ CODE
         C     RD,AVADDHIH         CHECK AGAINST LOWER LIMIT OF UPPER
         BNH   *+12                IF NEEDED <= AVAIL, SKIP, OK
         OI    AVTAGS3,AVOVERFL    SHOW STORAGE EXCEEDED
         OI    AVTAGS1,AJNLOAD     KILL OBJECT CODE GENERATION
         SPACE 1
.UTALW   $DISK E1                  CALL END-PASS-1 FIX ROUTINE
         LR    RD,RE               DUPLICATE RE
         STM   RD,RE,UTG2PT        SET POINTERS TO FORCE CALL TO DISKU
.UTRET   ANOP
UTRETE1  $RETURN SA=NO             RETURN TO MASTER CONTROL
         EJECT
**--> ENTRY: UTGET2   2   GET FROM UTILITY DUIRNG PASS 2. . . . . . . .
*.       UTGET2 IS CALLED DURING PASS 2 TO RETRIEVE THE ADDRESSES OF  .
*.       THE SET OF RECORD BLOCKS BELONGING TO THE NEXT STATEMENT. A  .
*.       CHECK IS REQUIRED FOR ANY OFFSET ADJUSTMENT MADE BY UTPUT1,  .
*.       WHICH MADE SURE THAT NO RECORD BLOCK COULD BE OVERLAID BY    .
*.       ITS OWN CODE.
*.       EXIT CONDITIONS                                              .
*.  RC = @ RSBLOCK (THE ONLY BLOCK DEFINITELY PRESENT).               .
*.  RE = 0    NORMAL RETURN.      RE = 4 ==> END-FO-FILE-QUIT         .
*.  AVRSBPT,AVRCBPT,AVRSCPT NOW POINT TO THEIR BLOCKS, IF THEY EXIST. .
*.  AVREBLK HAS HAD THE REBLK MOVED INTO IT, IF THERE WAS ONE.        .
*.  AVREBPT IS NOT CHANGED, STILL POINTS AT AVREBLK, AS ALWAYS.       .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         SPACE 1
* * * * * REGISTER ALLOCATION FOR UTGET2  * * * * * * * * * * * * * * *
*   RA = 3     MASK FOR DOING FULLWORD ALIGNMENT.                     *
*   RB = BYTE REGISTER FOR INSERTIONS (HI-ORDER 3 BYTES = 0).         *
*   RC = @ RSBLOCK, USED TO TEST FOR EXISTENCE OF OTHERS.             *
*   RD = CURRENT @ NEXT BLOCK, INITIALIZED = UTG2PT                   *
*   RE = UTG2END-LIMIT @, USED TO DETERMINE END OF RECORDS.           *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         AIF   (&$ASMLVL).UTOS     SKIP FOR OS GENERATION
UTDKDISP EQU   8                   GEN DOS BUFFER DISP
         AGO   .UTGLVL
.UTOS    ANOP
UTDKDISP EQU   0                   GEN OS BUFFER DISP
.UTGLVL  SPACE 1
UTGET2   $SAVE RGS=NO,SA=NO        USE ONLY TEMP REGS
         LA    RA,3                SET UP FOR FULLWORD ALIGNMENT
         SR    RB,RB               CLEAR FOR INSERTIONS
         LM    RC,RD,UTG2PT        UTG2PT-UTG2END VALUES FOR COMPARE
         CR    RC,RD               COMPARE CURRENT POINTER TO END @
         BNL   UTG2DONE            NO MORE RECORDS-BRANCH-DONE
         SPACE 1
*        THE FOLLOWING CHECKS FOR AN OFFSET ADJUSTMENT @ FOLLWING THE *
*        LAST RSB, INSTEAD OF ANOTHER RSB.  THE 1ST BYTE FOR AN OFFSET*
*        WILL =0, BUT AN RSBLENG NEVER = 0.
         CLI   0(RC),0             IS NEXT BYTE 0, IF SO RC==> OFFSET@
         BNE   *+8                 BRANCH IF NORMAL RSB FOLLOWS
         L     RC,0(RC)            OFFSET @ ==> NEXT RSBLOCK, LOAD IT
UTG2DKCT ST    RC,AVRSBPT          STORE THE @ OF THE RSBLOCK
         USING RSBLOCK,RC          NOTE ADDRESS
         SPACE 1
         IC    RB,RSBLENG          GET THELENGTH-1 OF BLOCK
         LA    RD,4(RB,RC)         MOVE @ OVER, ADD LENGTH+ALIGN
         OR    RD,RA               MAKE LAST 2 BITS 1'S
         SR    RD,RA               HAVE ROUNDED UP TO NEXT FULLWORD B
         SPACE 1
         TM    RSBFLAG,$RCBX       DO WE HAVE RCB
         BZ    UTG2REB             NO RCB-SKIP
         ST    RD,AVRCBPT          STORE @ RCODBLK
         USING RCODBLK,RD          NOTE POINTER
         IC    RB,RCLENG           GET LENGTH-1 OF RCODBLK
         LA    RD,1(RB,RD)         INCREMENT POINTER BY FULL LENGTH
         SPACE 1
UTG2REB  TM    RSBFLAG,$REBX       DOES REB EXIST
         BZ    UTG2RSC             NO IT DOESN'T - SKIP
         USING REBLK,RD            NOTE PTR TO ERROR BLOCK
         IC    RB,REBLN            GET LENGTH-1 OF THE BLOCK
         STC   RB,*+5              STORE LENGTH-1 INTO NEXT INSTR
         MVC   AVREBLK($),REBLK    MOVE THE ERROR BLOCK OVER
         LA    RD,1(RB,RD)         INCREMENT POINTER TO NEXT POSITION
         SPACE 1
UTG2RSC  TM    RSBFLAG,$RSCX       DOES RECORD SOURCE CODE BLOCK EXIST
         BZ    UTG2EXIT            NO,SKIP OVER
         ST    RD,AVRSCPT          STORE @ RSCBLK WHERE NEEDED
         USING RSCBLK,RD           NOTE POINTER
         IC    RB,RSCLENG          GET LENGTH-1 OF RSCBLK
         LA    RD,1(RB,RD)         INCREMENT BY LENGTH TO NEXT POSITION
         SPACE 1
UTG2EXIT $ALIGR RD,RA              ALIGN TO FULLWORD FOR NEXT RSBLOCK
         ST    RD,UTG2PT           STORE THE POINTER BACK, NEXT RSBLOCK
         SR    RE,RE               CLEAR TO SHOW NORMAL
         $DBG  C0,SNAP
UTG2RET  $RETURN RGS=NO,SA=NO      RETURN
UTG2DONE EQU   *                   ESTABLISH LABEL
         AIF   (&$DISKU GT 1).UTG2DA   DISK ONLY
         AIF   (&$DISKU LT 1).UTG2DB   USER OPTION--DISK OR NO DISK
         TM    AVTAGS1,AJODISKU    IS DISK ON?
         BNO   UTG2EOF             NO--SET E-O-F FLAG
.UTG2DA  ANOP
         $DISK RD                  GET NEXT BUFFER OF INFO
         BM    UTG2EOF             ON REAL EOF--SET FLAG AND RTURN
         L     RC,AVBUFF@          GET BUFFER ADDRESS
         LR    RD,RC               DUPLICATE FOR BUFFER LENGTH
         A     RD,0+UTDKDISP(RC)   ADD IN BUFFER USED LENGTH
         LA    RC,4+UTDKDISP(RC)   BUMP PAST LENGTH USED WORD
         ST    RD,UTG2END          STORE ENDING ADDRESS
         B     UTG2DKCT            GO BACK AND PROCESS
.UTG2DB  ANOP
UTG2EOF  LA    RE,4                SHOW E-O-F  NO MORE SOURCE
         B     UTG2RET
         DROP  RC,RD               KILL THESE USINGS
         EJECT
**--> ENTRY: UTPUT2       PRODUCES AND RELOCATES OBJECT CODE. . . . . .
*.       UTPUT2 MOVES OBJECT CODE PRODUCED BY THE ASSEMBLER INTO IT   .
*.       PROPER LOCATION IN THE OBJECT PROGRAM, APPLYING DUPLICATION  .
*.       FACTOR AT THIS TIME, IF NECESSARY.  BECAUSE OF THE WAY THE   .
*.       ASSIST INTERPRETER EXECUT WORKS, AND BECAUSE OF THE PSEUDO   .
*.       START CARD USED BY THE REPLACE MONITOR, NO RELOCATION NEED   .
*.       EVER BE DONE BY THIS PROGRAM, MAKING IT FAST AND SMALL.  THE .
*.       MODULE ALSO FILLS IN  AREAS OF THE OBJECT PROGRAM HAVING NO  .
*.       CODE WITH CHARACTER 5'S, WHICH HELP REDUCE THE SIZE OF ANY   .
*.       COMPLETION DUMPS, AND AID DEBUGGING  (X'F5F5F5' SHOWS UP     .
*        DISTINCTIVELY IN A DUMP, AND IS NOT A LEGAL INSTRUCTION).    .
*.       ENTRY CONDITIONS                                             .
*.  RA = PROGRAM LOCATION COUNTER OF THE OBJECT CODE                  .
*.  RC = @ ASSEMBLED CODE IN MEMORY                                   .
*.  RD = LENGTH-1 OF OBJECT CODE                                      .
*.  RE = DUPLICATION FACTOR FOR THE CODE - 1 OR GREATER               .
*.       USES DSECTS: AVWXTABL                                        .
*.       USES MACROS: $RETURN,$SAVE                                   .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
UTPUT2   $SAVE RGS=NO,SA=NO        NO REGS NEEDED
         SPACE 1
         TM    AVTAGS1,$IBDSEC1+AJNLOAD     DSECT OR NOLOAD
         BNZ   UTP2RET             RETURN IF SO, DON'T LOAD ANY CODE
         A     RA,AVRELOC          ADD RELOCATION FACTOR TO ADDRESS
         STC   RD,UTP2MOVE+1       STORE LENGTH-1 INTO MVC IMMEDIATLY
         SPACE 1
*              FOLLOWING SECTION PLACES CHARACTER 5'S IN ANY UNUSED   *
*        LOCATIONS OF MEMORY, EXCEPT POSSIBLY A BLOCK OF DS AREAS     *
*        ENDING PROGRAM, WITH NO FOLLOWING LITERALS, DC'S.            *
*        SECTION NOT REALLY NECESSARY, COULD BE REMOVED WITH NO HARM. *
         LR    RB,RA               DUPLICATE VALUE OF CODE @
         S     RB,UTP2LAST         SUB @ LAST CODE, GET # FILLED
         BNP   UTP2MOVE            SKIP, NO PADDING NEED BE DONE
         SPACE 1
         STM   R1,R2,24(R13)       SAVE WORK REGISTERS
         L     R2,UTP2LAST         GET STARTING @ AREA TO BE TWOED
         MVI   0(R2),$PRGFILC      PUT IN CORE FILL CHARACTER
         LA    R1,256              SET UP FOR LENG FILL IF NEEDED
         BCT   RB,UTP2ZB           DECREMENT COUNT 1, BRANCH >1 ORIG
         B     UTP2NT              1 BYTE ONLY, ALREADY DONE,QUIT
         SPACE 1
UTP2ZA   MVC   1(256,R2),0(R2)     PROPAGATE 5'S FOR 256 BYTES
         AR    R2,R1               ADD 256 TO BEGINNING @ OF CODE
         SR    RB,R1               DECREMENT COUNT REMAINING BY 256
         BZ    UTP2NT              BRANCH IF NOTHING LEFT TO DO
         SPACE 1
UTP2ZB   CR    RB,R1               COMPARE COUNT REMAINING TO 256
         BH    UTP2ZA              IF STILL HIGH, FILL ANOTHER 256
         BCTR  RB,0                DECREMENT COUNT TO LENGTH-1 FOR MVC
         STC   RB,*+5              STORE LENGTH-1 INTO MVC
         MVC   1($,R2),0(R2)       PROPAGATE 5'S FOR LAST TIME
UTP2NT   LM    R1,R2,24(R13)       RELOAD DESTOYED WORK REGS
*              END OF CORE-FILLING SEGMENT.                           *
         EJECT
*              FOLLOWING 3 STMTS DO ACTUAL CODE LOAD/DUPLICATION.
UTP2MOVE MVC   0($CHN,RA),0(RC)    MOVE OBJECT CODE OVER
         LA    RA,1(RD,RA)         BUMP ADDRESS TO NEXT LOCATION
         BCT   RE,UTP2MOVE         DUPLICATE AS MANY TIMES AS NEEDED
         SPACE 1
*              FOLLOWING 3 STMTS USED ONLY FOR CORE-FILL ACTIONS.     *
         C     RA,UTP2LAST         WAS END @ OF CODE HIGHEST SO FAR
         BNH   *+8                 SKIP  IF NOT SO
         ST    RA,UTP2LAST         STORE NEW HIGHEST CODE @
         SPACE 1
         $DBG  C0,*
UTP2RET  $RETURN SA=NO
         SPACE 2
**--> ENTRY: UTEND2   2   CLEANUP AFTER PHASE 2 DONE. . . . . . . . . .
*.       UTEND2 IS CALLED AT THE END OF ASSEMBLY PASS 2.  IT ASSURES  .
*.       THAT ANY DS STATEMENTS ENDING THE PROGRAM WILL BE FILLED IN  .
*.       WITH 5'S, LIKE ANY OTHER DS'S FOLLOWED BY CODE (THE VERY LAST.
*.       STRING OF DS'S MAY NOT BE CAUGHT BY UTPUT2).  IT DOES THIS BY.
*.       CALLING UTPUT2 WITH SOME NONEXISTENT OBJECT CODE.            .
*.       CALLS UTPUT2                                                 .
*.       USES DSECTS: AVWXTABL                                        .
*.       USES MACROS: $SAVE                                           .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         SPACE 1
UTEND2   $SAVE RGS=NO,SA=NO        NO REGS NEED BE SAVED
         NI    AVTAGS1,255-$IBDSEC1         MAKE SURE DSECT FLAG OFF
         L     RA,AVLOCHIH         GET @ 1 BYTE BEYOND HIGHEST LOCNTR
         LA    RC,=AL1($PRGFILC)   SET @ 1 BYTE CORE FILL CHARACTER
         SR    RD,RD               SHOW LENGTH-1 OF 0 FOR FAKE CODE
         LA    RE,1                SHOW DUPLICATION FACTOR OF 1
         $GTAD REP,UTPUT2          GET ADCON FOR OTHER SECTION
         BR    REP                 GO TO UTPUT2, IT WILL FILL IF NEEDED
         LTORG
         SPACE 2
* * * * * INTERNAL VARIABLES                                          *
*              USED BY PASS 1                                         *
         AIF   (&$DISKU NE 1).UTCNTRL  SKIP UNLESS DISK IS OPTION
UTCONTRL DS    F                   @ AVBUFINC/AVADDLOW-DEPENDS ON DISKU
.UTCNTRL ANOP
*              USED BY PASS 2                                         *
UTG2PT   DS    A                   POINTER TO NEXT RSBLOCK TO BE GOTTEN
UTG2END  DS    A                   POINTER TO END OF CORE AREA USED
UTP2LAST DS    A                   @ HIGHEST CODE LOADED,**FILL USE****
         DROP  RAT,REP
         TITLE '*** VWXTABL - MAIN ASSEMBLER CONTROL TABLE ***'
**--> CSECT: VWXTABL    MAIN ASSEMBLER COMMUNICATION TABLE. . . . . . .
*.       THIS IS ACTUAL TABLE THAT AVWXTABL DSECT CORREPSONDS TO.     .
*.       SEE AVWXTABL COMMENTS FOR DESCRIPTION.                       .
*.       USES MACROS: WCONG                                           .
*.       NAMES: X------, W------, V------                             .
*.  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         SPACE 1
VWXTABL  CSECT
         SPACE 1
* * * * * NAMES IN AVWXTABL DSECT ARE SAME, EXCEPT WITH A'S PREFIXED  *
* * * * * AVWXTABL SECTION X - ADDRESS CONSTANTS  * * * * * * * * * * *
X$BASE   DS    0A                  BASE ADDRESS FOR OFFSETS TO ROUTINES
*              *** BROPS2 ENTRY POINTS ***                            *
XBRINIT  DC    V(BRINIT)           BASE-REG INITIALIZATION
XBRUSIN  DC    V(BRUSIN)           BASE-REG SET UP USING VALUE
XBRDROP  DC    V(BRDROP)           BASE REG DROP A REGISTER
XBRDISP  DC    V(BRDISP)           BASE REG GET BASE-DISPLACEMENT
XC$BASE  DS    0F                  BASE ADDRESS FOR CONSTANT ADDR OFFSE
*              *** CACONS ENTRY POINTS ***                            *
XCACON1  DC    V(CACON1)           SCAN A-TYPE CONST
XCACON2  DC    V(CACON2)           ASSEMBLE A-TYPE CONSTANT
*              *** CBCONS ENTRY POINTS ***                            *
XCBCON1  DC    V(CBCON1)           SCAN BINARY CONSTANT
XCBCON2  DC    V(CBCON2)           ASSEMBLE BINARY CONSTANT
*              *** CCCONS ENTRY POINTS ***                            *
XCCCON1  DC    V(CCCON1)           SCAN CHARACTER CONSTANT
XCCCON2  DC    V(CCCON2)           ASSEMBLE CHARACTER CONSTANT
*              *** CDECNS ENTRY POINTS ***                            *
XCDECN1  DC    V(CDECN1)           SCAN FLOATING PT CONST
XCDECN2  DC    V(CDECN2)           ASSEMBLE FLOATING PT CONSTANT
XCDCON1  EQU   XCDECN1             MAKE EQUATE FOR STANDARD NAMES
XCECON1  EQU   XCDECN1             MAKE EQUATE FOR STANDARD NAMES
*              *** CFHCNS ENTRY POINTS ***                            *
XCFHCN1  DC    V(CFHCN1)           SCAN FIXED POINT CONSTANT
XCFHCN2  DC    V(CFHCN2)           ASSEMBLE FIXED POINT CONSTANT
XCFCON1  EQU   XCFHCN1             MAKE EQUATE FOR STANDARD NAMES
XCHCON1  EQU   XCFHCN1             MAKE EQUATE FOR STANDARD NAMES
*              *** CONSTANT PROCESSOR CONTROL ROUTINES ***            *
XCNDTL2  DC    V(CNDTL2)           PASS 2 CONSTANT PROCESSING
XCODTL1  DC    V(CODTL1)           DUPLICATION FACTOR-TYPE-LENGTH PROC
*              *** CPCONS ENTRY POINTS ***                            *
XCPCON1  DC    V(CPCON1)           SCAN PACKED CONSTANT
XCPCON2  DC    V(CPCON2)           ASSEMBLE PACKED CONSTANT
*              *** CVCONS ENTRY POINTS ***                            *
XCVCON1  DC    V(CVCON1)           SCAN V-TYPE CONSTANTS
XCVCON2  DC    V(CVCON2)           ASSEMBLE V-TYPE ADDRESS CONSTANTS
*              *** CXCONS ENTRY POINTS ***                            *
XCXCON1  DC    V(CXCON1)           SCAN HEXADECIMAL CONSTANTS
XCXCON2  DC    V(CXCON2)           ASSEMBLE HEXADECIMAL CONSTANTS
*              *** CZCONS ENTRY POINTS ***                            *
XCZCON1  DC    V(CZCON1)           SCAN ZONED CONSTANTS
XCZCON2  DC    V(CZCON2)           ASSEMBLE ZONED CONSTANTS
*              *** ERRORS ENTRY POINTS ***                            *
XERRTAG  DC    V(ERRTAG)           FLAG ERROR
XERRLAB  DC    V(ERRLAB)           ERROR FLAG FOR A LABEL
*              *** ESDOPRS ENTRY POINTS ***                           *
XESINT1  DC    V(ESINT1)           ESD ROUTINE INITIALIZATION
XESCSEC  DC    V(ESCSEC)           CSECT,START, OR DSECT
XESENX1  DC    V(ESENX1)           ENTRY OR EXTRN - PASS 1
XESENX2  DC    V(ESENX2)           PASS 2 ENTRY AND EXTRN
*              *** EVALUT - EXPRESSION EVALUATOR ***                  *
XEVALUT  DC    V(EVALUT)           GENERAL EXPRESSION EVALUATION ROUT
*              *** 2ND LEVEL PROCESSOR CSECTS ***                     *
XIAMOP1  DC    V(IAMOP1)           MACHINE OPCODES-PASS 1
XIBASM1  DC    V(IBASM1)           ASSEMBLER OPCODES - PASS 1
XICMOP2  DC    V(ICMOP2)           MACHINE OPCODES - PASS 2
XIDASM2  DC    V(IDASM2)           ASSEMBLER OPCODES - PASS 2
*              *** INPUT1 ENTRY POINTS ***                            *
XINCARD  DC    V(INCARD)           INPUT CARD PROCESSOR
*              *** LTOPRS ENTRY POINTS ***                            *
XLTINT1  DC    V(LTINT1)           LITERAL TABLE INITIALIZATION
XLTENT1  DC    V(LTENT1)           ENTER A LITERAL INTO POOL
XLTDMP1  DC    V(LTDMP1)           RETURN LITERAL LENGTH-PASS 1
XLTEND1  DC    V(LTEND1)           END PASS 1 FOR LITERAL TABLE
XLTGET2  DC    V(LTGET2)           GET ADDRESS OF LITERAL
XLTDMP2  DC    V(LTDMP2)           PRODUCE LITERAL RECORDS-PASS 2
         AIF   (NOT &$MACROS).XNOMAC        SKIP IF NO MACROS
*              ** MACROS ENTRY POINTS **                              *
XMACINT  DC    V(MACINT)           MACRO INITIALIZATION ENTRY
XMACRO1  DC    V(MACRO1)           BUILD MACRO DEFINITION TABLES
XMEXPND  DC    V(MEXPND)           MACRO EXPANSION ENTRY
XMCBODY  DC    V(MCBODY)           PROCESS MACRO DEFINITION BODY
XMACSCN  DC    V(MACSCN)           SCAN MACRO STATEMENT
XMACFND  DC    V(MACFND)           SEARCH MACRO LIBRARY
XMCVSCN  DC    V(MCVSCN)           SCAN VARIABLE SYMBOL
XMCSCOP  DC    V(MCSCOP)           SCAN STANDARD OPERAND
XMCGTST  DC    V(MCGTST)           MOVE STRING TO LOW CORE
XMCSYSR  DC    V(MCSYSR)           SEARCH MACRO LIBRARIES FOR VAR SYMB
XMACLEX  DC    V(MACLEX)           MACRO STMT LEX ANALYSIS
XMCGNCD  DC    V(MCGNCD)           MACRO DEFINITION CODE GENERATION
XMXMVSR  DC    V(MXMVSR)           MOVE GENERATED STMT TO HIGH CORE
XMXERRM  DC    V(MXERRM)           GENERATE ERROR MESSAGE
XMCDTRM  DC    V(MCDTRM)           CHAR TO BINARY CONVERSION
XMCATRM  DC    V(MCATRM)           TEST FOR ATTRIBUTE
         DS    2V                  SPACE FOR MACRO ENTRY POINTS
.XNOMAC  ANOP
*              ***  MAIN PROGRAMS - PASS 1&2 ***                      *
XMOCON1  DC    V(MOCON1)           MAIN CONTROL - PASS 1
XMOSTOP  DC    V(MOSTOP)           DISASTER EXIT-PASS 1
XMTCON2  DC    V(MTCON2)           MAIN CONTROL - PASS 2
*              *** OPCOD1 ENTRY POINTS ***                            *
XOPINIT  DC    V(OPINIT)           INITIALIZATION,IF ANY
XOPFIND  DC    V(OPFIND)           LOOKUP OPCODE
*              *** OUTPUT ENTRY POINTS ***                            *
XOUINT1  DC    V(OUINT1)           INITIALIZATION ENTRY FOR OUTPUT
XOUTPT2  DC    V(OUTPT2)           OUTPUT LINE PRINTER
XOUEND2  DC    V(OUEND2)           FINISH UP LAST PRINTING
*              *** SCANRS ENTRY POINTS ***                            *
XSCANBL  DC    V(SCANBL)           SCAN TO FIRST BLANK OUTSIDE OF C'
XSCANCO  DC    V(SCANCO)           SCAN TO COMMA OR BLANK
XSCANEQ  DC    V(SCANEQ)           SCAN TO = OR BLANK
*              *** SDTERM ENTRY POINTS ***                            *
XSDBCDX  DC    V(SDBCDX)           SLEF DEFINING TERM-ALL 4 KINDS     *
XSDBTRM  DC    V(SDBTRM)           BINARY SELF-DEFINING TERM
XSDCTRM  DC    V(SDCTRM)           CHARACTER SELF-DEFINING TERM
XSDDTRM  DC    V(SDDTRM)           DECIMAL SELF-DEFINING TERM
XSDXTRM  DC    V(SDXTRM)           HEXADECIMAL SLEF-DEFINING TERM
*              *** SYMOPS ENTRY POINTS ***                            *
XSYINT1  DC    V(SYINT1)           SYMBOL TABLE INITIALIZATION
XSYENT1  DC    V(SYENT1)           ENTER A SYMBOL INTO SYMBOL TABLE
XSYFIND  DC    V(SYFIND)           LOOK UP A SYMBOL IN SYMBOL TABLE
XSYEND2  DC    V(SYEND2)           CLEANUP/STATISTICS AT END OF SYM TAB
*              *** UTOPRS ENTRY POINTS ***                            *
XUTINT1  DC    V(UTINT1)           UTILITIES INITIALIZATION
XUTPUT1  DC    V(UTPUT1)           PASS 1 OUTPUT OF EXPANDED RECORDS
XUTEND1  DC    V(UTEND1)           END PASS 1-INIT FOR PASS 2
XUTGET2  DC    V(UTGET2)           GET ADDR'S OF EXPANDED RECRDS-PASS 2
XUTPUT2  DC    V(UTPUT2)           OBJECT CODE CREATION-PASS 2
XUTEND2  DC    V(UTEND2)           FINISH UP PASS 2
         AIF   (NOT &$XREF).NOXREF7  SKIP ID NO XREF                  A
*              ***  CROSS REFERENCE ENTRY POINTES ***                 A
XXRINT1  DC    V(XRINT1)           1ST PASS INIT ROUTINE              A
XXRINT2  DC    V(XRINT2)           2ND PASS INIT ROUTINE              A
XXRCOLL  DC    V(XRCOLL)           COLLECTION ROUTINE                 A
XXRPRNT  DC    V(XRPRNT)           PRINT ROUTINE                      A
XXRSCAN  DC    V(XRSCAN)           SCANNING ROUTINE                   A
.NOXREF7 ANOP                                                         A
XSPECAD  DS    A                   BASE ADDRESS FOR SPECIAL ROUTINES
XSPECA2  DS    A                   BASE @ LEV2-PASS 2 - 'SPECIALS'
         EJECT
* * * * * AVWXTABL SECTION W - CONSTANTS  * * * * * * * * * * * * * * *
WD0      DS    0D                  FLOATING POINT 0 FOR CDE
WZEROS   DC    32D'0'              256 BYTES OF BINARY ZEROS
WD10     DC    D'10'               DOUBLEWORD FLOATING CONSTANT 10
WF1      DC    F'1'                FULLWORD 1 CONSTANT
WH1      EQU   WF1+2               HALFWORD 1 CONSTANT
WB1      EQU   WF1+3               BYTE 1 CONSTANT
WF3      DC    F'3'                FULLWORD 3 CONSTANT
WH3      EQU   WF3+2               HALFWORD 3 CONSTANT
WB3      EQU   WF3+3               BYTE 3 CONSTANT
WF4      DC    F'4'                FULLWORD CONSTANT 4
WF7      DC    F'7'                FULLWORD 1
WH7      EQU   WF7+2               HALFWORD 7 CONSTANT
WB7      EQU   WF7+3               BYTE 7 CONSTANT
WF10     DC    F'10'               FULLWORD CONSTANT 10
WH10     EQU   WF10+2              HALFWORD CONSTANT 10
WF12     DC    F'12'               FULLWORD CONSTANT 12
WF15     DC    F'15'               FULLWORD CONSTANT 15 (4 1 BITS)
WFXF     EQU   WF15                FULLWORD CONSTANT,4 1-BITS
WFXFF    DC    F'255'              FULLWORD CONSATNT 255
WF4095   DC    F'4095'             FULLWORD 4095 CONSTANT
WFXFFF   EQU   WF4095              XL4'FFF'      ON F BOUNDARY
WHXFFF   EQU   WFXFFF+2            XL2'0FFF'  ON H BOUNDARY
WFX7FFFF DC    X'00007FFF'         MAXIMUM SIZE, MASK VALUE
WFXFFFF  DC    X'0000FFFF'         65K DECIMAL NUMBER
WFX6F    DC    XL4'FFFFFF'         FULLWORD 24-BIT MASK
WFM4     DC    F'-4'               FULLWORD -4 CONSTANT
WFM1     DC    F'-1'               FULLWORD -1 CONSTANT
WHM1     EQU   WFM1+2              HALWORD -1 CONSTANT
         EJECT
*        TABLE USED TO SCAN DECIMAL NUMBERS                           *
*        CHARACTERS 0-9 HAVE ZERO VALUES,ALL OTHERS NONZERO           *
*        ALSO USED IN ICMOP2 FOR GENERAL SCANNING.                    *
*   TR TABLE      0 1 2 3 4 5 6 7 8 9 A B C D E F                     *
WTDECT   DC    X'02020202020202020202020202020202'    0
         DC    X'02020202020202020202020202020202'    1
         DC    X'02020202020202020202020202020202'    2
         DC    X'02020202020202020202020202020202'    3
         DC    X'100202020202020202020202020C0202'    4 BLANK (
         DC    X'02020202020202020202020608020202'    5  $ *
         DC    X'02020202020202020202020E02020202'    6  ,
         DC    X'02020202020202020202020606020A02'    7 # @ =
         DC    X'02020202020202020202020202020202'    8
         DC    X'02020202020202020202020202020202'    9
         DC    X'02020202020202020202020202020202'    A
         DC    X'02020202020202020202020202020202'    B
         DC    X'02060404060606060606020202020202'    C B-C(4) ALPHS-6
         DC    X'02060604060606060606020202020202'    D L-(4) ALPHS-6
         DC    X'02020606060606040606020202020202'    E X-(4) ALPHS - 6
         DC    X'00000000000000000000020202020202'    F
*        TABLE USED TO SCAN HEXADECIMAL CONSTANTS FOR CORRECTNESS     *
*        CHARACTERS A-F,0-9 ARE ZERO,ALL OTHERS ARE NON-ZERO          *
WTHEXT   DC    X'02020202020202020202020202020202'    0
         DC    X'02020202020202020202020202020202'    1
         DC    X'02020202020202020202020202020202'    2
         DC    X'02020202020202020202020202020202'    3
         DC    X'02020202020202020202020202020202'    4
         DC    X'02020202020202020202020202020202'    5
         DC    X'02020202020202020202020202020202'    6
         DC    X'02020202020202020202020202020202'    7
         DC    X'02020202020202020202020202020202'    8
         DC    X'02020202020202020202020202020202'    9
         DC    X'02020202020202020202020202020202'    A
         DC    X'02020202020202020202020202020202'    B
         DC    X'02000000000000020202020202020202'    C
         DC    X'02020202020202020202020202020202'    D
         DC    X'02020202020202020202020202020202'    E
         DC    X'00000000000000000000020202020202'    F
*              TABLE FOR HEXADECIMAL INPUT CONVERSIONS.               *
WTHEX2   EQU   *-C'A'              OFFSET SYMBOL FROM TABLE CORRECTLY
*   TR TABLE      0 1 2 3 4 5 6 7 8 9 A B C D E F                     *
         DC      X'0A0B0C0D0E0F000000000000000000'    C
         DC    X'00000000000000000000000000000000'    D
         DC    X'00000000000000000000000000000000'    E
         DC    X'00010203040506070809'                F
         EJECT
*        USED TO SCAN ACROSS SYMBOLS,STOP ON DELIMITERS               *
*        CHARACTERS $,#,@,A-Z,0-9 ARE ZERO. ALL OTHERS ARE NONZERO    *
*        ALSO USED IN EVALUT FOR OPERATOR CODES- (+*)-/,              *
*   TR TABLE      0 1 2 3 4 5 6 7 8 9 A B C D E F                     *
WTSYMT   DC    X'01010101010101010101010101010101'     0
         DC    X'01010101010101010101010101010101'     1
         DC    X'01010101010101010101010101010101'     2
         DC    X'01010101010101010101010101010101'     3
         DC    X'04010101010101010101010101020501'     4 BLANK (+
         DC    X'01010101010101010101010007030101'     5 $*)
         DC    X'06080101010101010101010401010101'     6 -/,
         DC    X'01010101010101010101010000010101'     7  #@
         DC    X'01010101010101010101010101010101'     8
         DC    X'01010101010101010101010101010101'     9
         DC    X'01010101010101010101010101010101'     A
         DC    X'01010101010101010101010101010101'     B
         DC    X'01000000000000000000010101010101'     C  A-I
         DC    X'01000000000000000000010101010101'     D  J-S
         DC    X'01010000000000000000010101010101'     E  S-Z
         DC    X'00000000000000000000010101010101'     F  0-9
WTZTAB   EQU   WZEROS              SPACE FOR 256-BYTE ZEROED TRT TABLE
         DS    0D                  LINE UP BLANKS ON D BOUNDARY
WBLANK   DC    CL132' '            BLANKS
         ORG   WBLANK+16           OVERLAP WBLANK&WTHEX3
         SPACE 1
*        TABLE USED TO CONVERT INTERNAL BINARY TO EXTERNAL HEX.       *
*   TR TABLE     0123456789ABCDEF0123456789ABCDEF                     *
WTHEX3   DC    C'                                '    0-1
         DC    C'                                '    2-3
         DC    C'                                '    4-5
         DC    C'                                '    6-7
         DC    C'                                '    8-9
         DC    C'                                '    A-B
         DC    C'                                '    C-D
         DC    C'                0123456789ABCDEF'    E-F
         SPACE 1
WEP4     DC    X'40202120'         4-BYTE DECIMAL EDIT PATTERN
WEP6     DC    X'402020202120'     6-BYTE EDIT PATTERN FOR DEC #
WP0      DC    PL1'0'              FOR ZEROING DECIMAL COUNTERS
WP1      DC    P'1'                DECIMAL CONSTANT 1
WCONADS  DS    ($CNT$N)AL1         SPACE FOR CONSTANT OFFSET TABLE
         WCONG (A,B,C,D,E,F,H,P,V,X,Z)       GENERATE OFFSETS IN WCONAD
         EJECT
* * * * * AVWXTABL SECTION V - VARIABLES  * * * * * * * * * * * * * * *
         DS    0D                  GET ALIGNEMENT
*        **NOTE** FOLLOWING SECTION SHOULD MIRROR AV- SECTION OF      *
*        AVWXTABL DSECT, BUT HAS BEEN REMOVED, BECAUSE NO CODE IS     *
*        ACTUALLY GENERATED, AND FINAL ORG TAKES CARE OF LENGTH.      *
         ORG   VWXTABL+AVWXEND-AVWXTABL     MAKE SURE AS BIG AS AVWXTB
         AIF   (NOT &$XREF).XXNOXRF                                   J
XREFTAB  DSECT
XREFSYM  DS    F                   @ OF SYMBOL'S SYMSECT ENTRY
XREFLLNK DS    H                   LEFT LINK TO NEXT SYMBOL IN TREE
XREFRLNK DS    H                   RIGHT LINK TO NEXT SYMBOL IN TREE
XREFBLCK DS    F                   @ OF BLOCK WITH STATEMENT NUMBERS
XREFTLGN EQU   *-XREFTAB           LENGTH OF XREF TABLE ENTRY
XREFBLK  DSECT
XRBLKNUM DS    F                   NEG # OF SLOTS LEFT IN BLOCK OR
*                                  POINTER TO NEXT BLOCK OF REFERENCES
         DS    &$XREF#B.H          SLOTS FOR STMT NUMBERS
XREFBLGN EQU   *-XREFBLK           LENGTH OF BLOCK OF STMT #
XRPL     EQU   &$PRTSIZ            SET UP XREF LINE LENGTH = MAX LENG J
XRPLAST  EQU   XRPL-18             OFFSET: LAST PLACE TO START        L
         TITLE 'XREFA - CROSS REFERENCE FACILITY'
**--> CSECT: XREFA   CROSS REFERENCE CONTROL SECTION...................
*.         WRITTEN BY ALICE FELTE,ALAN ARTZ, AND RICH LONG            .
*.                                           ---SPRING/SUMMER 1973    .
*.                                                                    .
*.  THIS CSECT IS THE MAIN CONTROL SECTION FOR THE CROSS REFERENCE    .
*. FOR ASSIST. IT HAS THREE ENTRY POINTS WHICH WILL BE DESCRIBED LATER.
*. THIS ROUTINE CONTROLS ALL THE CROSS-REFERENCE FACILITY IF IT IS TO .
*. BE GENERATED.  THE FIRST PASS THE FLAGS AND LOCATION COUNTER ARE   .
*. INITIALIZED--XRINT1.  SPACE IS ALLOCATED FOR THE CROSS-REFERENCE   .
*. ENTRIES AND NECESSARY FLAGS ARE SET FOR THE SECOND PASS--XRINT2.   .
*. THE *XREF CARD WILL BE SCANNED BY XRSCAN.                          .
*.                                                                    .
*.  XRINT1: PASS ONE INITIALIZATION                                   .
*.         CALLED FROM MPCON0.                                        .
*.         1)  INITIALIZE THE ADDITIONAL LOCATION COUNTER,            .
*.             AVXRLNCN, TO 1.                                        .
*.         2)  INITIALIZE THE COUNTER, AVXRCNT, FOR THE NUMBER OF     .
*.             REFERENCES TO 0.                                       .
*.                                                                    .
*.  XRINT2: PASS TWO INITIALIZATION                                   .
*.         CALLED FROM MTCON2.                                        .
*.         1)  ALLOCATE SPACE USING THE MACRO $ALLOCH TO THE          .
*.             DSECT, XREFTAB, SIZE * THE NUMBER OF REFERENCES        .
*.             TO BE COLLECTED AND INITIALIZE ALL SPACE TO 0.         .
*.         2)  SET AVXRLAVS TO FIRST FREE NODE.                       .
*.         3)  SET HEADER NODE FOR THE TREE STRUCTRUE EQUAL TO 0.     .
*.                                                                    .
*.  XRSCAN:  CARD SCANNING ROUTINE.                                   .
*.             A FLAG IS PASSED IN A REGISTER TO DETERMINE WHICH      .
*.         PASS IS BEING PROCESSED.  FOR THE FIRST PASS, SCAN THE     .
*.         CARD AND SET THE SD FLAG ACCORDINGLY.  FOR THE SECOND      .
*.         PASS, SCAN THE CARD AND SET THE SR FLAG ACCORDINGLY.       .
*.                                                                    .
*......................................................................
XREFA    CSECT
         ENTRY XRINT1,XRINT2,XRSCAN
         EJECT
**--> ENTRY: XRINT1     PASS ONE INITIALIZATION........................
*.       THIS IS CALLED FROM MPCON0 ONLY ONCE                         .
*.       MODULE DESCRIPTION--                                         .
*.            INITIALIZES AVXRLNCT, THE ADDITIONAL LINE COUNTER, TO 1 .
*.       AND AVXRCNT, COUNTER FOR THE NUMBER OF REFERENCES FOUND, TO 0.
*.                                                                    .
*......................................................................
         SPACE 2
XRINT1   EQU   *                   ENTRY INITIALIZATION FIRST PASS
         USING *,R15
         USING AVWXTABL,RAT        MAIN TABLE USING
         ZAP   AVXRLNCN(3),AWP1    INITIALIZE ADDITIONAL LINE COUNTER
         MVC   AVXRCNT(2),AWZEROS  INITIALIZE # OF REFERENCES TO 0
         MVI   XRSDORSR,C'D'       FOR SD= SCAN ON *XREF CARDS        L
         MVC   XRFLAGSV,AVXRFLAG   SAVE FLAG
         NI    AVXRFLAG,X'FF'-AVXRSRFT-AVXRSRMD  ZAP, NO PASS 1 REFS
XRI1RET  BR    R14                 RETURN
         DROP  R15,RAT
         SPACE 3
**--> ENTRY: XRINT2     PASS TWO INITIALIZATION........................
*.       THIS IS CALLED FROM MPCON0 ONLY ONCE.                        .
*.       MODULE DESCRIPTION--                                         .
*.            ALLOCATES A BLOCK OF SPACE USING $ALLOCH WHERE THE SIZE .
*.       IS AVXRCNT * XRSIZE.  IT SET AVXRLAVS TO THE ADDRESS OF THE  .
*.       BEGINNING OF THE BLOCK OR FIRST FREE NODE AS RETURNED BY     .
*.       $ALLOCH.  IT ALSO SETS AVXRHEAD, THE HEADER POINTING TO THE  .
*.       FIRST ENTRY IN THE TREE, EQUAL TO 0.                         .
*.                                                                    .
*......................................................................
         SPACE 2
XRINT2   EQU   *                   ENTRY INITIALIZATION SECOND PASS
         USING *,R15
         USING AVWXTABL,RAT        MAIN TABLE USING
         USING XREFTAB,RB          CROSS REFERENCE TABLE
         TM    AVXRFLAG,AVXRON     IS XREF WANTED
         BZ    XRI2RET             NO, RETURN
         MVI   XRSDORSR,C'R'       FOR SR= SCAN ON *XREF CARDS        L
         MVC   AVXRFLAG,XRFLAGSV   RESTORE FOR REF COLL BITS
         LA    RC,XREFTLGN         GET LENGTH OF XREF TABLE ENTRY
         MH    RC,AVXRCNT          GET AMOUNT OF SPACE TO BE ALLOCATED
XRI2ALLO $ALLOCH RB,RC,XRI2OVFL    ALLOCATE SPACE FOR TABLE
         MVC   AVXRHEAD(4),AWZEROS HEADER WILL BE NULL
         ST    RB,AVXRLAVS         PUT @ OF SPACE IN FREE SPACE LIST
         MVI   AVXRTYPE,AVXRFTCH   MAKE SURE FETCH TYPE REF NORMAL    J
         MVC   AVXRLNCN(3),AVOULNCN  INITIALIZE LINE COUNTER
         BR    R14                 RETURN
*     CANCEL XREF OPTION AND SET OVERFLOW FLAG
XRI2OVFL NI    AVXRFLAG,X'FF'-AVXRON  TURN XREF OFF
         OI    AVTAGS3,AVOVERFL    SHOW OVERFLOW OCCURRED
XRI2RET  BR    R14                 RETURN
XRFLAGSV DC    AL1($),X'0'         SAVE WORD,  PAD
         DROP  RAT,RB
         EJECT
**--> ENTRY: XRSCAN     CARD SCANNING ROUTINE..........................
*.       THIS IS CALLED FROM MOCON1 AND MTCON2 TO SCANN THE *XREF CARD.
*.                                                                    .
*.       ENTRY CONDITIONS--  RA  @ TO BEGIN *XREF PARM SCAN           .
*.                           RD  IDX TO SET FLAGS(0=PASS 1,8=PASS 2)  .
*.                                                                    .
*.       MODULE DESCRIPTION--                                         .
*.            CHECK TO SEE WHICH PASS IT IS IN.  DEPENDING ON WHICH   .
*.       PASS IT IS, THE *XREF CARD IS SCANNED AND THE FLAGS SET.     .
*.            IF IT IS PASS ONE, THE CARD IS SCANNED FOR SD=.  IF IT  .
*.       NOT THERE, AVXRFLAG IS NOT CHANGED.  IF IT IS, CHECK FOR     .
*.       LEGAL VALUES OF *, 0, OR 1.  IF IT IS NONE OF THESE THREE,   .
*.       THE STATEMENT IS FLAGGED WITH A SYNTAX ERROR.  IF IT IS A    .
*.       LEGAL VALUE, THE AVXRFLAG IS SET ACCORDINGLY.                .
*.            IF IT IS PASS TWO, THE CARD IS SCANNED SR= AND IS       .
*.       PROCESSED SIMILARLY TO SD= ABOVE.                            .
*.                                                                    .
*......................................................................
         SPACE 2
XRSCAN   $SAVE RGS=(R14-R6),SA=NO   SAVE REGISTERS TO BE USED
         USING AVWXTABL,RAT        MAIN TABLE USING
         TM    AVXRFLAG,AVXRON     IS XREF ON?
         BZ    XRRETURN            NO, RETURN
         LA    RC,1                USEFUL CONSTANT
         $SETRT ('S',1)            SET UP AWTZTAB TO STOP ON S        L
         LA    RE,65(RA)           LAST @ TO CHECK FOR 'S'            L
*
*  PASS 1 -- SCAN FOR SD= AND SET AVWXFLAG ACCORDINGLY                F
* PASS 2 -- SCAN FOR SR= AND SET AVWXFLAG ACCORDINGLY                 L
*
XRSTRT   LR    RB,RE               RB=END OF SCAN                     L
         SR    RB,RA               DETERMINE MACHINE LENGTH FOR EX INST
         EX    RB,XRSEXTRT         SCAN FOR 'S'                       L
         BZ    XRRETURN            IF NOT FOUND,RETURN                F
         CLC   1(2,R1),XRSDORSR    CHK FOR D= (PASS1),R= (PASS2)      L
         BE    *+8                 YES, CHECK FOR LEGAL NUMBER        L
         BXH   RA,RC,XRSTRT        INCR & CHECK FOR ANOTHER S         L
*
*  CHECK MODIFY CHAR FOR '*', '0', OR '1'. ANYTHING ELSE IS ILLEGAL   F
*
         LA    RA,3(R1)            GET @ OF MODIFY CHAR               L
         CLI 0(RA),C'0'            IS IT 0                            F
         BE    XRM0(RD)            YES, SET FLAG                      L
         CLI 0(RA),C'1'            IS IT 1                            F
         BE    XRM1(RD)            YES SET FLAG                       L
         CLI   0(RA),C'*'          IS IT *                            L
         BNE   XRSDSRER            ERROR IF NOT                       L
*                                                                     F
*     CHECK FETCH CHAR FOR '*', '0', '1', ',', OR ' '.  ANYTHING ELSE F
*     IS AN ERROR.  MARK IT SYNTAX ERROR                              F
*                                                                     F
XRNUM2   AR    RA,RC               GET @ OF FETCH CHAR                L
         CLI   0(RA),C'0'          IS IT 0                            F
         BE    XRF0(RD)            YES, SET AVXRFLAG                  L
         CLI   0(RA),C'1'          IS IT 1                            F
         BE    XRF1(RD)            YES, SET AVXRFLAG                  L
         CLI   0(RA),C'*'           IS IT *
         BNE   *+6                 NO, CHECK FOR ',' OR ' '           L
*                                                                     F
*     CHECK FOR A BLANK OR COMMA.    IF IT IS BLANK, RETURN           F
*                                  IF IT IS COMMA, SCAN REST OF CARD  F
*                                                                     F
XRBLNK   AR    RA,RC               NO CHANGE NECESSARY  CHECK FOR ',' L
         CLI   0(RA),C' '          IS IT BLANK                        L
         BE    XRRETURN            YES, RETURN                        F
         CLI   0(RA),C','          IS IT A COMMA                      F
         BE    XRSTRT              GO TO SCAN REST OF THE CARD        L
XRSDSRER LA    RB,$ERVSYNT         SET ERROR CODE
         $CALL ERRTAG              CALL ERROR ROUTINE
*
*     RETURN TO CALLING ROUTINE
XRRETURN $SETRT ('S',0)            RESET AWTZTAB TO ZERO
         $RETURN RGS=(R14-R6),SA=NO
*        SET AVXRFLAG APPROPRIATELY                                   L
XRM0     NI    AVXRFLAG,X'FF'-AVXRSDMD SET SD MODIFY OFF              L
         B     XRNUM2              GET 2ND #                          L
         NI    AVXRFLAG,X'FF'-AVXRSRMD  SET SR MODIFY OFF             L
         B     XRNUM2              GET 2ND #                          L
XRM1     OI    AVXRFLAG,AVXRSDMD   SET SD MODIFY ON                   L
         B     XRNUM2              GET 2ND #                          L
         OI    AVXRFLAG,AVXRSRMD   SET SR MODIFY                      L
         B     XRNUM2              GET 2ND #                          L
XRF0     NI    AVXRFLAG,X'FF'-AVXRSDFT  SET SD FETCH OFF              L
         B     XRBLNK              GO CHECK FOR ',' OR ' '            L
         NI    AVXRFLAG,X'FF'-AVXRSRFT  SET SR FETCH FLAG OFF         L
         B     XRBLNK              GO CHECK FOR ',' OR ' '            L
XRF1     OI    AVXRFLAG,AVXRSDFT   SET SD FETCH ON                    L
         B     XRBLNK              GO CHECK FOR ',' OR ' '            L
         OI    AVXRFLAG,AVXRSRFT   SET SR FETCH FLAG ON               L
         B     XRBLNK              GO CHECK FOR ',' OR ' '            L
XRSEXTRT TRT   0($,RA),AWTZTAB     SEARCH FOR AN S                    L
         DROP  RAT                                                    L
XRSDORSR DC    C'$='               $ REPLACED BY D(PASS 1) OR R(PASS2)
         LTORG
         TITLE 'XRCOLL - CROSS REFERENCE COLLECTION ROUTINE'
**--> CSECT: XRCOLL     COLLECTION ROUTINE.............................
*.       THIS IS CALLED BY SYFIND AFTER IT IS FOUND THAT THE SYMBOL   .
*.       IS DEFINED AND THE REFERENCE IS TO BE COLLECTED.             .
*.                                                                    .
*.       ENTRY CONDITIONS--  RA  HAS THE ADDRESS OF THE SYMBOL IN THE .
*.                                SYMBOL TABLE.                       .
*.                                                                    .
*.       MODULE DESCRIPTION--                                         .
*.          AVXRHEAD HAS THE ADDRESS OF THE FIRST NODE IN THE TREE.   .
*.          AVXRLAVS HAS THE ADDRESS OF THE FIRST AVAILABEL FREE NODE .
*.                                                                    .
*.            THE FOLLOWING ALGORITHM IS FROM "THE ART OF COMPUTER    .
*.       PROGRAMMING" VOL. 1  'FUNDAMENTAL ALGORITHMS' BY DONALD KNUTH.
*.            CHECK HEADER 'AVXRHEAD' FOR EMPTY TREE(= 0).  IF EMPTY, .
*.       EXECUTE INSUB 'XRCLAVS' TO GET FREE NODE FOR PROCESSING.     .
*.       'XRCLAVS' INSERTS SYMBOL AND INITIALIZES LINKS IN NODES---   .
*.       LEFT LINK=0,RIGHT KINK=-1 (ODD DISPLACEMENT IMPOSSIBLE, NEGA-.
*.       TIVE TO SIMPLIFY CHECKS IN XRPRNT ROUTINE).  IF NOT EMPTY,   .
*.       DETERMINE WHETHER OR NOT A NODE HAS ALREADY BEEN CREATED FOR .
*.       THE PRESENT SYMBOL BY COMPARING THE ADDRESS OF THE SYMBOL    .
*.       IN REG RA TO THE ADDRESSES OF SYMBOLS ALREADY IN THE TREE    .
*.       NODES.  IF EQUAL, PROCESS THE REFERENCE (DESCRIBED LATER).   .
*.       OTHERWISE, COMPARE ACTUAL SYMBOLS TO DETERMINE WHERE IN THE  .
*.       TREE THE NEWLY CREATED NODE SHOULD BE INSERTED.  IF THE NEW  .
*.       SYMBOL IS SMALLER IN VALUE THAN THAT OF A NODE IN TREE, THE  .
*.       COMPARISON CONTINUES WITH IT'S LEFT SUBTREE.  IF LARGER, COM-.
*.       PARISON CONTINUES WITH RIGHT SUBTREE.  WHEN A ZERO LEFT LINK .
*.       IS FOUND, OR NEGATIVE RIGHT LINK, THE LINK IS CHANGED TO     .
*.       POINT TO THE NODE WHICH WILL CONTAIN THE INFO FOR THE NEW    .
*.       SYMBOL(NODE FETCHED AND INITIALIZED BY 'XRCLAVS'.            .
*.                                                                    .
*.       PROCESSING THE REFERENCES:                                   .
*.            ONCE THE SYMBOL IS PLACED IN THE TREE, THE REFERENCE    .
*.       MUST BE ENTERED IN A BLOCK OF REFERENCES.  THIS IS DONE IN   .
*.       THE FOLLOWING MANNER:                                        .
*.            1)  IF THE PTR TO THE BLOCK OF REFERENCES IS NULL       .
*.                (I.E. FIRST REFERENCE), A BLOCK MUST BE             .
*.                ALLOCATED AND THE ADDRESS PLACED IN THE POINTER     .
*.                OF THE XREFTAB.                                     .
*.            2)  IF IT IS NOT NULL, THE POINTER IS AN ADDRESS AND    .
*.                THE BLOCK CAN BE LOCATED.                           .
*.                                                                    .
*.            3)  THE FIRST FULLWORD OF THE REFERENCE-BLOCK           .
*.                CONTAINS EITHER:                                    .
*.                A)  THE NUMBER OF SLOTS LEFT IN THE BLOCK.          .
*.                    THE REFERENCE MAY BE ENTERED IN THE BLOCK, THE  .
*.                    NUMBER OF SLOTS IS DECREMENTED BY 1.            .
*.                B)  NEGATIVE ADDRESS OF AN ADDITIONAL BLOCK         .
*.                C)  ZERO, MEANING A NEW BLOCK MUST BE ALLOCATED.    .
*.                    ALLOCATE A NEW BLOCK AND SET THE POINTER IN     .
*.                    PRECEDING BLOCK TO IT (NEGATIVE ADDRESS). THEN  .
*.                    A) MAY BE FOLLOWED.                             .
*......................................................................
         SPACE 2
* * * *  REGISTER USAGE: XRCOLL * * * * * * * * * * * * * * * * * * * *
*   R0=  X'0000FFFF'               USED TO INITIALIZE NODE LINKS      *
*   RW=  @ NODE IN XREF LIST BEING CHECKED  (@ XREFTAB)               *
*   RX=  @ SYMSECT OF SYMBOL ALREADY IN XREF TABLE                    *
*   RA=  @ SYMSECT OF SYMBOL TO BE CHECKED IN XREFTAB                 *
*   RB=  @  BEGIN OF XREF TABLE (FROM WHICH OFFSETS COMPUTED)         *
*   RC,RD,RE,RY,RZ   WORK REGISTERS                                   *
*   R14= INTERNAL LINKAGE                                             *
*   R15= BASE REGISTER                                                *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 2
XRCOLL   CSECT
         $SAVE RGS=(R14-R6),SA=NO
         USING AVWXTABL,RAT        NOTE MAIN TABLE USING
         USING XREFTAB,RW          CROSS TABLE (POINTERS)
         L     R0,AWFXFFFF         =X'0000FFFF'  USED TO INIT PTRS    J
         MVC   AVDWORK2,AWBLANK    PREPARE FOR SYMBOL TO BE CHECKED
         USING SYMSECT,RA
         IC    RD,SYCHARS          GET LENGTH OF LABEL
         EX    RD,XRCSYMO          MOVE SYMBOL TO PADDED AREA FOR COMP
         DROP  RA                  DROP SO USING ON RX OK
         L     RW,AVXRHEAD         GET HEADER POINTER TO FIRST NODE
         LTR   RB,RW               IS IT ZERO, NO NODES ALLOCATED
         BNZ   XRCSYMCK            SYMBOLS IN TABLE - BRANCH
         SPACE 1
*              FIRST SYMBOL - ALLOC SPACE,SET AVXRHEAD
         BAL   R14,XRCLAVS         CALL ALLOCATE ROURINE
         ST    RW,AVXRHEAD         POINTER TO 1ST ENTRY
         LR    RB,RW               RB--> TOP OF TREE
         B     XRCNUENT            GO TO FILL IN
         SPACE 1
XRCSYMCL LA    RW,0(RY,RB)         GET @ NEXT NODE
         USING SYMSECT,RX          SYMBOL TABLE USING
XRCSYMCK L     RX,XREFSYM          GET @ OF SYMSECT ENTRY FOR SYMBOL
         MVC   AVDWORK1(8),AWBLANK INITIALIZE WORK AREA TO BLANKS
         IC    RD,SYCHARS          GET LENGTH OF LABEL
         EX    RD,XRCSYMN          MOVE SYMBOL TO PADDED FIELD
         DROP  RX
         CLC   AVDWORK2(8),AVDWORK1  COMPARE SYMBOLS TO SEE IF WANTED
         BE    XRCENTER            IF EQUAL, HAVE TO ENTER STMT # INTO
         BH    XRCRIGHT            IF> GO TO RIGHT LINK AND CHECK AGAIN
*   IF < GO TO LEFT LINK AND CHECK AGAIN
         LH    RY,XREFLLNK         GET DISP OF LINK IN TABLE
         LTR   RY,RY               IS IT THE END OF TREE
         BNZ   XRCSYMCL            NO, LOOP
*
*           ENTER NEW NODE INTO TREE - LEFT LINKED
*
XRCNULEF BAL   R14,XRCLAVS         GET A NEW NODE
         LR    RZ,RB               TO SAVE @ OF OLD NODE
         SR    RZ,RX               COMPUTE DISPLACEMENT OF OLD NODE
         STH   RZ,XREFRLNK         STORE THREAD TO PREVIOUS NODE
         USING XREFTAB,RX
         LR    RZ,RW               TO SAVE @ OF NEW NODE
         SR    RZ,RB               COMPUTE DISP OF NEW NODE
         STH   RZ,XREFLLNK         STORE INTO LEFT LINK OF PREV NODE
         DROP  RX
         B     XRCNUENT            NOW READY TO ENTER STMT NUMBER
         SPACE 1
XRCRIGHT LH    RY,XREFRLNK         DET DISP OF LINK IN TABLE
         LTR   RY,RY               IS IT THE END OF THE LIST
         BP    XRCSYMCL            NO,LOOP
*
*           ENTER NEW NODE INTO TREE - RIGHT LINKED
*
XRCNURIT BAL   R14,XRCLAVS         GET A NEW NODE
         LR    RZ,RW               TO SAVE @ OF NEW NODE
         SR    RZ,RB               GET DISP OF NEW NODE
         USING XREFTAB,RX
         LH    RY,XREFRLNK         GET RIGHT LINK OF OLD NODE
         STH   RZ,XREFRLNK         STORE DISP OF NEW NODE IN RLINK OF L
         DROP  RX
         STH   RY,XREFRLNK         STORE RLINK OF OLD NODE IN NEW
*
*  ALLOCATE NEW BLOCK FOR REFERENCES
*
XRCNUENT LA    RY,XREFBLGN         GET LENGTH OF BLOCK TO BE ALLOCATED
         $ALLOCH RX,RY,XRCOVFLW    ALLOCATE A BLOCK FOR REFERENCE
         USING XREFBLK,RX          XREF BLOCK OF STMT NUMBERS
         ST    RX,XREFBLCK         STORE POINTER TO BLK OF REFERENCES
         USING SYMSECT,RA
         B     XRCLBLK             GO INSERT STATEMENT NUMBER
*        ENTER HERE IF OLD SYMBOL
XRCENTER L     RX,XREFBLCK         GET ADDRESS OF REFERENCE BLOCK
XRCNXBLK L     RY,XRBLKNUM         GET NUB OF SPACES LEFT OR @ NEXT BLK
         LTR   RY,RY               IS IT ZERO
         BP    XRCSTMT#            POSITIVE, PUT STMT # INTO BLOCK
         BZ    XRCALLOC            ALLOCATE NEW BLOCK IF 0
         LPR   RX,RY               RX--> NEXT REFERENCE BLOCK
         B     XRCNXBLK            GO SEE IF THIS BLOCK HAS ROOM
*              ALLOCATE ADDITIONAL REFERENCE BLOCK
XRCALLOC LA    RY,XREFBLGN         GET LENGTH TO BE ALLOCATED
         LR    RZ,RX               SAVE @ OF FILLER REFERENCE BLOCK
         $ALLOCH RX,RY,XRCOVFLW    ALLOCATE NEW BLOCK OF REFERENCES
         LNR   RY,RX               ADDITIONAL BLK @ IS NEGATIVE
         ST    RY,0(RZ)            STORE @ OF NEW BLOCK INTO FILLED BLK
XRCLBLK  LA    RY,&$XREF#B         GET MAX AVAIL STMT SLOTS,IDX TO 1ST
*
*  INSERT STATEMENT NUMBER INTO REFERENCE BLOCK (- IF MODIFY)
*
XRCSTMT# LA    RC,2(RY,RY)         GET DISPLACEMENT OF OPEN SLOT
         ZAP   AVDWORK1(8),AVXRLNCN GET STMT # OF REFERENCE
         CVB   RZ,AVDWORK1          GET STMT # OF REFERENCE
         TM    AVXRTYPE,AVXRFTCH   IS IT A FETCH REF
         BNZ   *+6                 NO, MUST BE A MODIFY REFERENCE
         LNR   RZ,RZ               GET NEGATIVE STMT # INTO REF BLOCK
         STH   RZ,0(RC,RX)         STORE STMT # OF REFERENCE
         BCTR  RY,0                DECREMENT # OF SLOTS
         ST    RY,XRBLKNUM         STORE REMAINING # OF SLOTS
XRCRET   $RETURN RGS=(R14-R6),SA=NO
         DROP  RX
         SPACE 3
*.-->  INSUB: XRCLAVS . . . . . . . . . . . . . . . . . . . . . . . . .
*.            GET THE FIRST FREE NODE FROM THE LIST OF AVAILABLE      .
*.       SPACE, AVXRLAVS.  SETS AVXRLAVS TO POINT TO THE NEW FIRST    .
*.       FREE NODE.  STORES THE ADDRESS OF THE SUMBOL'S SYMSECT ENTRY .
*.       IN THE NEW NODE.                                             .
*.       RW  HAS THE ADDRESS OF THE NEW NODE                          .
*.       RX  HAS ADDRESS OF OLD NODE                                  .
*.       LEFT LINK INITIALIZED TO ZERO; RIGHT LINK TO -1              .
*.       NOTE: IT IS POSSIBLE TO HAVE THREAD OF A NODE POINT BACK TO  .
*.       ROOT NODE WHICH HAS INDEX DISPLACEMENT OF ZERO.  SINCE -0 IS .
*.       NOT DISTINGUISHABLE FROM +0, THE END OF THE TREE IS DENOTED  .
*.       BY -1 VICE 0                                                 .
*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  .
         SPACE 2
XRCLAVS  LR    RX,RW               SAVE ADDRESS OF OLD NODE
         L     RW,AVXRLAVS         ADDRESS OF FIRST FREE NODE
         LA    RZ,XREFTLGN(RW)     GET @ OF NEXT FREE NODE
         ST    RZ,AVXRLAVS         SAVE @ OF NEW FIRST FREE NODE
         ST    RA,XREFSYM          STORE @ OF SYMBOLS' SYMSECT ENTRY IN
         ST    R0,XREFLLNK         ZERO BOTH LINKS
         BR    R14                 RETURN
         SPACE 3
*
*     COMES HERE WHEN IT DOES NOT HAVE ENOUGH SPACE TO ALLOCATE A NEW
*      REFERENCE BLOCK
*
XRCOVFLW OI    AVTAGS3,AVOVERFL    SET OVERFLOW FLAG ON
         MVI   AVXRFLAG,X'00'      DISARM FLAG NEVER TO RETURN        L
         B     XRCRET              RETURN
XRCSYMN  MVC   AVDWORK1($),SYMBOL-SYMSECT(RX)  MOVE SYMBOL ALREADY IN
*                                              TREE TO WORK AREA
XRCSYMO  MVC   AVDWORK2($),SYMBOL  MOVE NEW SYMBOL TO WORK AREA
         DROP  RW,RA,RAT
         LTORG
         TITLE 'XRPRNT - CROSS REFERENCE PRINT ROUTINE'
**--> CSECT: XRPRNT     PRINT ROUTINE..................................
*.       CALLED FROM MPCON0 TO PRINT OUT THE CROSS REFERENCE.         .
*.            THE COMPRESS BIT OF AVXRFLAG IS TESTED BY AVXRCOMP TO   .
*.       DETERMINE WHICH FORMAT TO USE FOR PRINTING.  IF IT IS OFF,   .
*.       EACH REFERENCE SYMBOL IS PRINTED ON A NEW LINE.  IF IT IS ON,.
*.       THE REFERENCED LABELS ARE PRINTED MORE THAN ONE PER LINE IF  .
*.       THERE IS ROOM.                                               .
*.            THE FOLLOWING ALGORITHM IS FROM "THE ART OF COMPUTER    .
*.       PROGRAMMING" VOL. 1  'FUNDAMENTAL ALGORITHMS' BY DONALD KNUTH.
*.            THE TREE IS THEN TRAVERSED IN POSTORDER.                .
*.                GET THE ADDRESS OF THE FIRST NODE IN THE TREE FROM  .
*.            AVXRHEAD.  IF IT IS 0, PRINT A MESSAGE THAT NO SYMBOLS  .
*.            HAVE BEEN REFERENCED.  IF IT IS NOT 0, FOLLOW THE LEFT  .
*.            LINKS UNTIL IT IS 0.  THEN PRINT THE SYMBOL FROM THE    .
*.            NODE AND ALL ITS REFERENCES.  NOTE: A NEGATIVE          .
*.            REFERENCE IS A MODIFY AND A POSITIVE REFERENCE IS A     .
*.            FETCH.  IT IS PRINTED ACCORDING TO THE FORMAT DESCRIBED .
*.            ABOVE.                                                  .
*.                THEN THE RIGHT LINK IS CHECKED.  IF IT IS -1,WE ARE .
*.            AT THE END OF THE TREE AND RETURN TO ASSIST.            .
*.            IF IT IS LESS THAN -1,IT IS A THREAD BACK TO A NODE.    .
*.            GET THE POSITIVE ADDRESS OF THE NODE, PRINT THE SYMBOL  .
*.            AND ITS REFERENCES.  CHECK THE RIGHT LINK AGAIN.        .
*.            IF IT IS POSITIVE, IT IS THE ADDRESS OF THE NEXT NODE.  .
*.            GO TO THAT NODE AND CHECK ITS LEFT LINK AS ABOVE.       .
*.                                                                    .
*......................................................................
         SPACE 2
* * * *  REGISTER USAGE: XRPRNT * * * * * * * * * * * * * * * * * * * *
*   RW=  @ CURRENT XREFTAB ENTRY PROCESSED                            *
*   R0=  LAST @ TO START STMT # (COMPRESSED OUTPUT)                   *
*   R2=  -1  DENOTES END OF TREE                                      *
*   RA=  LAST @ TO START A SYMBOL (COMPRESSED OUTPUT)                 *
*   RB= @ XREFBLK BEING PROCESSED                                     *
*   RC,RD,RZ   WORK REGISTERS                                         *
*   RE=  @ OF 1ST ELEMENT (BASE FROM WHICH OFFSETS GIVEN)             *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 2
XRPRNT   CSECT
         $SAVE RGS=(R14-R6),SA=NO
         USING AVWXTABL,RAT        MAIN TABLE USING
         USING XREFTAB,RW          SET UP USINGS ON POINTER TABLE
*
*     PRINT CROSS REFERENCE HEADERS
*
         L     RW,AVXRHEAD         GET @ OF FIRST NODE IN TREE
         LTR   RE,RW               IS THERE AN @ THERE?
         BZ    XRPRRET             NO,RETURN
         $PRNT XREFTTL1,L'XREFTTL1 FIRST LINE OF HEADER
         LA    RZ,XRPOUTPT+1       GET ADDRESS OF OUTPUT LINE
         LA    RA,XRPOUTPT+XRPLAST LAST @ TO START SYMBOL
         LA    R0,11(RA)           LAST @ TO START STMT #
         SR    R2,R2               SET UP REG TO FIND END OF TREE
         BCTR  R2,0                -1 DENOTES END OF TREE
         MVC   XRPOUTPT(XRPL),AWBLANK  BLANK OUT OUTPUT LINE
         MVI   XRPOUTPT,C'0'       CC FOR 1ST LINE
XRPLLNK  LH    RX,XREFLLNK         GET LEFT LINK
         LTR   RX,RX               IS IT THE NODE TO BE PRINTED
         BZ    XRPRNODE            YES,PRINT NODE
         LA    RW,0(RX,RE)         @ OF NODE IN RW
         B     XRPLLNK             IS IT THE LAST NODE
XRPRLNK  LH    RX,XREFRLNK         GET RIGHT LINK
         CR    RX,R2               END OF TREE?
         BE    XRPRRETP            -1, END OF TREE
         TM    AVXRFLAG,AVXRCOMP   IS IT TO BE COMPRESSED OUTPUT
         BNO   XRPSYMBL            NO,GO PRINT LINE
*        OUTPUT IS TO BE COMPRESSED
         LA    RZ,3(RZ)            SKIP 3 SPACES BEFORE NEXT SYMBOL
         CR    RZ,RA               IS PTR TO OR PAST THAT POINT?
         BL    *+8                 NO,MOVE CHARACTERS INTO LINE
XRPSYMBL BAL   R14,XRPRLINE        PRINT OUTPUT LINE
         LTR   RX,RX               THREAD OR NODE?
         BNP   *+12                A THREAD, PRINT NODE
         LA    RW,0(RX,RE)         @ OF NODE IN RW
         B     XRPLLNK             CHECK FOR LEFT
         LPR   RW,RX               @ OF NODE TO PRINTED
         LA    RW,0(RW,RE)         @ OF NODE TO BE PRINTED
         SPACE 1
*        OBTAIN AND PRINT SYMBOL
XRPRNODE L     RY,XREFSYM          GET @ OF SYMBOL'S SYMSECT ENTRY
         USING SYMSECT,RY          DO USING
         IC    RD,SYCHARS          GET LENGTH OF SYMBOL
         EX    RD,XRPMOVE          MOVE SYMBOL TO OUTPUT LINE
         LA    RZ,9(RZ)            INVREMENT PTR TO POSITION IN OUTPUT
         L     RB,XREFBLCK         GET @ OF REFERENCE BLOCK
         USING XREFBLK,RB          SET UP REFERENCE BLOCK DSECT
         UNPK  0(7,RZ),SYVALUE+1(4) UNPACK
         MVI   6(RZ),C' '          MAKE BLANK
         TR    0(6,RZ),AWTHEX3     FINISH HEX CONVERT
         LA    RZ,6(RZ)            INCR PTR TO POSITION IN OUTPUT LINE
         BAL   R14,XRPNUMSL        GET NUM OF SLOTS USED AND TIMES LOOP
XRPNEXT# CR    RZ,R0               IS IT THE END OF THE LINE?
         BL    *+8                 NO GET STMT NO.
         BAL   R14,XRPRLINE        YES PRINT LINE
         LA    RC,2(RX,RX)         SAVE NUMBER TO BE PRINTED
         LH    RC,0(RC,RB)         PUT STM # IN REG
         CVD   RC,AVDWORK2         PACKED DECIMAL VALUE OF STMT #
         MVC   0(6,RZ),AWEP6       MOVE EDIT PATTERN IN
         LA    R1,5(RZ) DO NOT REMOVE..A MUST FOR 1 DIGIT,NEGATIVE    L
*                       STATEMENT NUMBERS..EDMK NEEDS THIS @          L
         EDMK  0(6,RZ),AVDWORK2+5  EDIT STMT # TO PRINTABLE FORM
         BNM   *+10                POSITIVE STMT # (MOD REF)
         BCTR  R1,0                GET @ TO INSERT -
         MVI   0(R1),C'-'          INSERT MINUS SIGN TO SHOW MODIFY
         LA    RZ,6(RZ)            INREMENT PTR TO  POS IN OUTPUT LINE
         BCTR  RX,0                DECREMENT TIMES THRU LOOP
         CR    RD,RX               HAVE ALL REFS IN BLK BEEN COLLECTED?
         BL    XRPNEXT#            NO,IF LOW
         SPACE 1
         LTR   RY,RY               IS THERE ANOTHER BLOCK OF REFERENCES
         BNM   XRPRLNK             NO GET NEXT SYMBOL IN TREE
         LPR   RB,RY               PUT @ OF NEXT BLOCK IN RB
         BAL   R14,XRPNUMSL        GET NUMBER OF SLOTS USED; TIMES THRU
         B     XRPNEXT#            PRINT NEXT REFERENCE
XRPMOVE  MVC   0($,RZ),SYMBOL      MOVE SYMBOL TO OUTPUT LINE  EXECUTED
         SPACE 3
*.--> INSUB: XRPRLINE       PRINTS A LINE OF REFERENCES . . . . . . . .
*.       SETS RZ TO POINT TO THE BEGINNING OF THE LINE. CLEAR         .
*.       OUTPUT LINE TO ALL BLANKS.                                   .
*.  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ..
         SPACE 2
XRPRLINE $PRNT XRPOUTPT,XRPL,XRPMSG PRINT OUT THE LINE OF REFERENCES
         LA    RZ,XRPOUTPT+1       GET ADDRESS OF OUTPUT LINE
         MVC   XRPOUTPT(XRPL),AWBLANK   CLEARS OUTPUT LINE
         BR    R14                 RETURN
         SPACE 3
*.--> INSUB: XRPNUMSL . . . . . . . . . . . . . . . . . . . . . . . . .
*.       GETS INDEX TO 1ST REFERENCE OF BLOCK, INDEX TO LAST REFERENCE.
*.       TO PRINT, AND VALUE FROM XRBLKNUM TO USE AS FLAG FOR TEST FOR.
*.       ADDITIONAL BLOCKS LATER IN MAIN SECTION OF CODE.             .
*.         RX=  INDEX TO 1ST REFERENCE TO BE PRINTED                  .
*.         RD=  INDEX TO LAST REFERENCE TO BE PRINTED                 .
*.         RY=  FLAG USED LATER(IF - THERE IS AN ADDITIONAL BLOCK)    .
*......................................................................
         SPACE 2
XRPNUMSL LA    RX,&$XREF#B         RX=POSS # REFS(ASSUME 1ST BLOCK
         L     RY,XRBLKNUM         GET # OF UNUSED SLOTS
         LTR   RD,RY               IS IT AN @ OR # OF SLOTS
         BCR   NM,R14              RD=LAST REFERENCE
         SR    RD,RD               RD=LAST REFERENCE
         BR    R14                 RETURN
         SPACE 3
* XRPMSG EQU   XRPRRET  *****      RETURN ON RECORDS EXCEEDED  CEH
XRPRRETP $PRNT XRPOUTPT,XRPL,XRPMSG        PRINT LAST LINE
XRPRRET  $RETURN RGS=(R14-R6),SA=NO
XRPMSG   EQU   XRPRRET             RETURN ON RECORDS EXCEEDED  CEH
XRPOUTPT EQU   AVCONCAT            WORK AREA
XREFTTL1 DC    C'0*** CROSS-REFERENCE:  VALUE(HEX) LOCATION REF REF ...X
                (- SHOWS MODIFY) ***'
         DROP  RW,RY,RB,RAT
.XXNOXRF ANOP
         AIF   (&$REPL EQ 0).RENREPL        SKIP IF NO REPLACE AT ALL
         TITLE 'RECORBLK DSECT - REPLACE CORRESPONDENCE TABLE'
**--> DSECT: RECORBLK   REPLACE MODULE-DESCRIBES 1 REAL-REPLACE PAIR. .
*.             THIS DSECT DESCRIBES 1 ENTRY IN THE TABLE RECORRAD.    .
*.       WHEN AN ENTRY POINT IS REPLACED, A RECORBLK IS CREATED FOR   .
*.       IT AND FILLED WITH VALUES FROM THE ENTRY POINT'S RFSYMBLK.   .
*.       THE ENTRY ADDRESS OF THE NEW ENTRY IS FOUND FROM THE SYMBOL  .
*.       TABLE (WHICH STILL EXISTS), AND IS SAVED INTO THE RECFPSW    .
*.       FIELD (OR A -1 PLACED HERE TO SHOW THE ENTRY COULD NOT BE    .
*.       FOUND IN THE USER PROGRAM).  USING THE RECAXAD FIELD, WHICH  .
*.       POINTS TO THE ADCON IN AVWXTABL OF THE REAL ROUTINE, THE REAL.
*.       ADCON IS SAVED IN RECADRE, AND IT IS REPLACED BY THE ADDRESS .
*.       OF REFAKE.  A CODE IS PLACED INTO THE HI-ORDER BYTE OF THE   .
*.       WORD IN AVWXTABL, WHICH IS USED BY REFAKE TO IDENTIFY WHICH  .
*.       ENTRY IS CALLED.                                             .
*.             AT THE END OF A REPLACE RUN, THE REAL ADCONS ARE MOVED .
*.       BACK TO THEIR PROPER PLACES IN AVWXTABL, USING THE RECAXAD   .
*.       FIELD OF EACH RECORBLK ELEMENT IN THE RECORRAD TABLE.        .
*.       **NOTE** FIRST SECTION OF DSECT SAME AS DSECT RFSYMBLK.      .
*.       LOCATION: CSECT REMONI, TABLE RECORRAD.                      .
*.       NAMES: REC-----                                              .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         SPACE 1
RECORBLK DSECT
*              DATA TRANSFERRED FROM RFSYMS CSECT TABLES.
RECSYMB  DS    CL6                 ENTRY POINT NAME
RECAXAD  DS    H                   OFFSET IN AVWXTABL=AX#-AX$BASE
RECRGAD  DS    H                   OFFSET FOR CHECK CODE=RG#-RGENTS
         SPACE 1
RECADRE  DS    V                   SPACE TO SAVE REAL ADDRESS CONSTNAT
RECFPSW  DS    0F                  BEGINNING PSW FOR ONE ENTRY POINT
RECFPCC  DS    C                   ILC-CC-PM, ALSO USED AS FLAG
RECFPAD  DS    AL3                 BEGINNING @ FOR ENTRY POINT IN FAKE
         SPACE 1
*              RUN STATISTICS VARIABLES
RECINSTS DS    F                   CUMULATIVE # INSTRUCTIONS DONE
RECCALLS DS    H                   CUMULATIVE # TIMES ENTRY CALLED
RECWRONG DS    H                   CUMULATIVE # TIMES PROG WRONG VALUES
RECZ$L   EQU   *-RECINSTS          LENGTH TO BE ZEROED-COUNTERS
REC$LEN  EQU   ((*-RECORBLK+3)/4)*4         LENGTH, RNDED TO FULLWRD
         TITLE 'RFSYMBLK DSECT - REPLACE ENTRY INFORMATION TABLE'
**--> DSECT: RFSYMBLK   REPLACE MODULE: 1 ENTRY IN TABLE CSECT RFSYMS .
*.             EACH SECTION OF RFSYMS GIVES EITHER A REPLACABLE       .
*.       CSECT NAME OR ONE OF ITS ENTRY POINT NAMES.   THE ENTRY      .
*.       POINT ELEMENTS CONTAIN VARIOUS POINTERS WHICH ARE USED TO    .
*.       GIVE OFFSET ADDRESSES FOR REAL ENTRY ADDRESS CONSTANTS OR    .
*.       FOR VARIOUS CHECKING CODE IN THE REPLACE MONITOR.            .
*.       **NOTE** THIS DSECT IS SAME AS FIRST PART OF RECORBLK DSECT. .
*.       GENERATION: 1 CALL TO RFSGN MACRO CREATS 1 CSECT ELEMENT     .
*.             AND 1 TO REC$MAX  ENTRY ELEMENTS.                      .
*.       LOCATION: CSECT RFSYMS.                                      .
*.       NAMES: RFS-----                                              .
*.  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         SPACE 1
RFSYMBLK DSECT
RFSYMB   DS    CL6                 CSECT/ENTRY NAME, ALPHAMERIC
RFSENTN  DS    AL1                 CSECT: NUMBER OF ENTRY POINTS
RFSENTL  DS    AL1                 CSECT: LENGTH OF CSECT+ENTRY BLKS
RFSRIAD  DS    H                   OFFSET TO RI&CSECT-PTRS TO CALLABLES
         SPACE 1
         ORG   RFSENTN             ORG BACK . DEFINE ENTRY FIELDS
RFSAXAD  DS    H                   OFFSET TO ENTRY ADCON IN AVWXTABL
*                                  = AXENTRY - AX$BASE
RFSRGAD  DS    H                   OFFSET TO REG CHECKING CODE FOR
*                                  RETURN VALUES. = RGENTRY-RGENTS
         ORG   RFSRGAD             BACK OVER, REALLY FOR RFSYMS PART 2
RFSRHAD  DS    H                   OFFSET TO CODE TO CHECK REGS FOR
*                                  CALLING OTHER PROGS.=RHENTRY-RHENTS
RFS$LEN  EQU   ((*-RFSYMBLK+1)/2)*2         LENGTH OF BLOCK,RD FULLWORD
         TITLE 'REMONI - REPLACE MONITOR CONTROL PROGRAM'
         PRINT NOGEN
REMONI   CSECT
**--> CSECT: REMONI     REPLACE MONITOR CONTROL PROGRAM . . . . . . . .
*.       REMONI HANDLES MOST OF THE DETIALS REQUIRED FOR A STUDENT TO .
*.  WRITE AN ASSIST CSECT, HAVE IT ASSEMBLED BY ASSIST, AND THEN RUN  .
*.  A TEST PROGRAM.  THE ENTRYPOINTS OF HIS PROGRAM ARE CALLED ALONG  .
*.  WITH THE ORIGINALS, AND HIS RESULTS CHECKED FOR ACCURACY.  WHILE  .
*.  ADDRESS CONSTANT MODIFCATION IS PERFORMED, THE ENTIRE PROCESS IS  .
*.  STILL A SERIALLY RESUABLE PROGRAM.  SEE THE ASSIST REPLACE USER'S .
*.  GUIDE   FOR DETAILS ON USING THE REPLACE MONITOR.                 .
*.       NAMES: RE------           MAIN CODE BODY AND INSUBS.         .
*.       NAMES: RG------           CHECKING CODE FOR RETURN VALUES.   .
*.       NAMES: RH------           EXTERNAL CALL CHECKING (&$REPL=2)  .
*.       CALLS SYFIND                                                 .
*.       USES DSECTS: AJOBCON,AVWXTABL,ECONTROL,RECORBLK,RFSYMBLK     .
*.       USES MACROS: $CALL,$PRNT,$RETURN,$SAVE,REPRNT,XDECO,XSNAP    .
*.                                                                    .
*.       OVERALL REGISTER CONVENTIONS AND USAGE.                      .
*.  R0,R1,R2,R3,R4,R15  WORK REGISTERS                                .
*.  R5 = @ RECORBLK ELEMENT FOR CURRENT ENTRY BEING PROCESSED.        .
*.  R6 = BASE REGISTER FOR MAIN CODE OF EACH REMONI ENTRY POINT.      .
*.  R7,R8      USUAL PARAMETER REGS FOR INTERNAL SUBROUTINES.         .
*.  R9 = LINK REGISTER FOR INSUBS WHICH MUST CALL OTHERS WITH R14.    .
*.  R10= @ ECONTROL (EXECUTION CONTROL BLOCK, USER PSEUDO REGISTERS.  .
*.  R11= @ AJOBCON DSECT (MAIN JOB CONTROL TABLE)                     .
*.  R12(RAT)= @ VWXTABL CSECT (AVWXTABL DSECT).                       .
*.  R13= SAVE AREA ADDRESS, BASE REGISTER FOR DATA, INTERNAL SUBRS.   .
*.  R14= INTERNAL LINK REGISTER. LOCAL WORK REGISTER.                 .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         SPACE 1
         $DBG  ,NO                 NO DEBUG
         ENTRY REINTA,REENDA,REFAKE    ENTRIES ALWAYS PRESENT
         SPACE 1
*              REMONI FLAG EQUATES
READMOD  EQU   B'00000001'         (REFLAGS)=>ADCONS IN AX ARE MODIFID
REFPRT   EQU   B'00000010'         (REFLAGS)=> REFAKE PRTED >=1 MSG,SKP
         SPACE 1
REC$MAX  EQU   5                   MAXIMUM # ENTRIES TO BE REPLACED
         EJECT
**--> ENTRY: REINTA     INITIALZE BEFORE ASSEMBLER CALLED . . . . . . .
*.       THIS ENTRY IS CALLED 1 TIME BEFORE ASSIST ASSEMBLER IS CALLED.
*.  IT CHECKS FOR PRESENCE OF REAL ADDRESS CONSTANTS IN VWXTABL, AND  .
*.  REPLACES THEM IF THEY HAVE BEEN MODIFIED IN PREVIOUS REPLACE RUN. .
*.       IT ALSO MAY SET FLAGS IN AVWXTABL IF THE SYSTEM IS IN        .
*.       REPLACE PHASE A (ASSEMBLE REPLACEMENT PROGRAM AND LINK IT).  .
*.       ENTRY CONDITIONS                                             .
*.  R11= @ AJOBCON (MAIN JOB CONTROL BLOCK).                          .
*.  R12(RAT)= @ VWXTABL CSECT (AVWXTABL DSECT).                       .
*.                                                                    .
*.  AVWXTABL: HAS BEEN COMPLETELY INITIALIZED BY MAIN PROGRAM ASSIST. .
*.       THIS PERMITS REINTA TO MODIFY ASSEMBLER CONTROL FLAGS IF     .
*.       NEEDED TO MAKE ASSEMBLER PERFORM REQUIRED ACTIONS.           .
*.       USES DSECTS: AJOBCON,AVWXTABL                                .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
REINTA   $SAVE RGS=(R14-R12),BR=R6,SA=RESAVE
         USING RESAVE,R13          NOTE AVAIL AS BASE
         USING AVWXTABL,RAT        NOTE ASSEMBLER TABLE USING
         USING AJOBCON,R11         NOTE MAIN JOB CONTROL TABLE
         TM    AJOMODE,AJOREPLF+AJOREPHB    TEST REPLACE STATUS
         BZ    REINREAL            NOT REPLACE AT ALL, RESTORE ADCONS
         BM    REINPHSA            AJOREPLF ONLY==> REPLACE PHASE A-BR
         SPACE 2
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              PRE-ASSEMBLY -- REPLACEMENT PHASE B                    *
*        THIS ACTION OCCURS JUST BEFORE THE ASSEMBLER IS CALLED WITH  *
*        MODIFIED ADCON TABLE FOR THE TEST RUN OF USER-WRITTEN CSECT. *
*        DON'T MODIFY ADCONS AGAIN, BUT FIX AVWXTABL FLAGS SO RUN     *
*        WILL BE NORMAL.                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         OI    AJOSTEP,AJOSEXEC    SHOW MAY BE IN INTERP FROM NOW ON
         NI    AVTAGS1,255-AJORELOC         SHOW NO RELOCATION
         B     REINRETA            BRANCH TO EXIT CODE
         SPACE 2
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              PRE-ASSEMBLY -- REPLACEMENT PHASE A                    *
*        THIS SECTION IS ENTERED JUST BEFORE A USER-WRITTEN REPLACE   *
*        CSECT IS ASSEMBLED.  MAKE SURE THAT THE REAL ADCONS ARE IN   *
*        AVWXTABL (MAY HAVE BEEN CHANGED BY PREVIOUS REPLACE RUN),    *
*        AND SET FLAGS REQUIRED FOR REPLACEMENT. THIS INCLUDES        *
*        MAKING THE ASSEMBLER RELOACTE THE OBJECT CODE TO ITS         *
*        ACTUAL LOCATION IN MEMORY, SIMPLIFYING DUMP PRINTING AND     *
*        DATA TRANSFERS.                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
REINPHSA EQU   *                   ENTRY LABEL: REPLACE PHASE A
         OI    AVTAGS1,AJORELOC    WE WANT USER PROGR AT REAL ADDRESS
*              FALL THRU, HAVE ANY MODIFIED ADCONS RESTORED IF NEEDED.
         SPACE 1
REINREAL BAL   R14,REREAL          HAVE REAL ADCONS REPLACED, IF NEED
REINRETA EQU   *                   EXIT LABEL
REINRET  $RETURN RGS=(R14-R12)
         DROP  R6,R11,RAT,R13      REMV USINGS
         AIF   (&$REPL LT 2).RESY1     SKIP IF NO CALLING ALLOWED
         EJECT
**--> ENTRY: RESYMB     ENTER CODE IN SYMBOL TABLE OF CALLABLE ENTRY. .
*.       RESYMB IS CALLED FROM CVCON2 IF A SYMBOL FLAGGED EXTRN IS    .
*.  USED IN A VCON.  IT PLACES A CODE INTO THE SYVALUE ENTRY OF THE   .
*.  SYMBOLS SYMSECT.  THIS CODE (THE OFFSET TO A CALLABLE ENTRY       .
*.  ELEMENT IN THE SECOND SECTION OF RFSYMS), IS USED FOR CHECKING    .
*.  WHEN THE USER PROGRAM ACTUALLY CALLS THE ROUTINE.                 .
*.       ENTRY CONDITIONS                                             .
*.  RA = @ SYMSECT FOR THE EXTRN SYMBOL.                              .
*.  ALL OTHER REGS: SAME AS ASSEMBLER REGISTER CONVENTIONS.           .
*.       EXIT CONDITIONS                                              .
*.  RA = @ SAME SYMSECT, BUT CODE HAS BEEN ENTERED IN SYVALUE.        .
*.  RB = 0     IF SYMBOL WAS LEGITAMATE.                              .
*.     = 4     IF SYMBOL WAS NOT LEGITAMETE ENTRY TO BE CALLED.       .
*.       NAMES: RES-----                                              .
*.       USES DSECTS: RFSYMBLK,SYMSECT                                .
*.  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         SPACE 1
         ENTRY RESYMB              DECLARE HERE, SINCE MAY NOT EXIST
RESYMB   $SAVE RGS=(R14-R6),SA=RESAVE,BR=R6
         USING RESAVE,R13          NOTE FOR SAFETY
         USING SYMSECT,RA          NOTE SYMBOL TABLE PTR
         L     R3,RERFSYMS         =V(RFSYMS)
         USING RFSYMS,R3           NOTE PTR TO TABLE CSECT
         LA    R0,RFS$LEN          INCREMENT FOR BXLE SEARCH
         LA    R1,RFSCALLZ-RFS$LEN LIMIT @ FOR BXLE
         LA    R2,RFSCALLA         INDEX FOR BXLE
         USING RFSYMBLK,R2         NOTE BLOCK PTR
         SPACE 1
*              SEARCH CALLABLE ENTRY TABLE FOR THE GIVEN ENTRY.
         CLC   RFSYMB,SYMBOL       IS IT? (IGNORE 7-8 CHAR SYMBOLS)
         BE    RESFOUND            YES, SKIP OUT
         BXLE  R2,R0,*-10          LOOP THROUTHE TABLE
         SPACE 1
         LA    RB,4                COULDNT FIND IT, FLAG SO ANDRETRN
RESRETA  EQU   *                   EXIT LABEL
         $RETURN RGS=(R14-R6)      RTURN, RESTORE ALL BUT PARM REGS
         SPACE 1
*              SYMBOL FOUND - PUT OFFSET TO TABLE ELEMENT IN SYMTAB.
RESFOUND SR    R2,R3               GET OFFSET FROM RFSYMS TO ELEMENT
         ST    R2,SYVALUE          SAVE THIS AS SYMBOL VALUE
         SR    RB,RB               CLEAR TO SHOW OK
         B     RESRETA             GO RETURN
         DROP  R2,R3,R6,RA,R13     RFSYMBLK,RFSYMS,BASE1,SYMSECT,BASE2
.RESY1   ANOP
         EJECT
**--> ENTRY: REENDA     REPLACE MODULE: POST-ASSEMBLY PROCESSING  . . .
*.       REENDA IS CALLED JUST AFTER AN ASSEMBLY IS COMPLETED.        .
*.       IF THE RUN IS NOT A REPLACE RUN, NOTHING IS DONE.            .
*.       IF IT IS REPLACE PHASE A, THE ASSEMBLED PROGRAM WAS A REPLACE.
*.  VERSION OF AN ASSIST MODULE, SO CHECK AND MODIFY ASSEMBLER ADCONS..
*.       IF THE RUN IS IN PHASE B, THE ASSEMBLY JUST FINISHED WAS     .
*.  A TEST PROGRAM, SO PRINT PERFORMANCE STATISTICS FOR THE MODULE.   .
*.       ENTRY CONDITIONS                                             .
*.  R11= @ AJOBCON (MAIN JOB CONTROL BLOCK).                          .
*.  R12(RAT)= @ VWXTABL CSECT (AVWXTABL DSECT).                       .
*.       CALLS SYFIND                                                 .
*.       USES DSECTS: AJOBCON,AVWXTABL,RECORBLK,RFSYMBLK,SYMSECT      .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
REENDA   $SAVE RGS=(R14-R12),BR=R6,SA=RESAVE
         USING RESAVE,R13          NOTE 2ND BASE REGISTER
         USING AVWXTABL,RAT        NOTE MAIN ASSEMBLER TABLE USING
         USING AJOBCON,R11         NOTE POINTER THERE
         SPACE 1
*              DETERMINE REPLACE PHASE (IF ANY). IF PHASE A, LINK
*              REPLACEMENT PROGRAM.  IF PHASE B, PRINT STATISTICS.
         TM    AJOMODE,AJOREPLF+AJOREPHB    REPLACE STATUS
         BZ    REENRET             NO REPLACE, DON'T DO ANYTHING
         BO    REEPHSB             BOTH FLAGS==> PHASE B-BRANCH
         SPACE 1
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              POST-ASSEMBLY -- REPLACEMENT PHASE A                   *
*        FIND CSECT NAME IN RFSYMS TABLE.  CREATE A RECORBLK BLOCK    *
*        FOR EACH ENTRY POINT, FILLING IN VALUES.  MODIFY THE ADCONS  *
*        IN AVWXTABL WHICH BELONG TO ENTRYPOINTS OF THE CSECT.        *
*        PRINT ERROR MESSAGES FOR ANY MISSING NAMES.                  *
*              ***** PHASE A REGISTER USAGE *****                     *
*   R1 = @ RFSYMBLK OF CSECT, THEN ENTRY POINT BEING PROCESSED        *
*   R2 = INCREMENT FROM EACH CSECT ELEMENT TO THE NEXT DURING SEARCH. *
*   R3 = OFFSET VALUE OF RECORBLK FROM BEGINNING OF RECORRAD          *
*      = NUMBER OF ENTRY ELEMENTS LEFT TO PROCESS FOR GIVEN CSECT     *
*   R4 = @ SYFIND. MUST BE SAVED HERE BECUASE IT IS LEGAL TO REPLACE  *
*        SYFIND, THUS LEADING TO INTERCEPTED CALL WHEN SYFIND IS      *
*        CALLED TO LOOKUP SYEND2, WITH ADCON ALREADY MODIFIED.        *
*   R5 = @ RECORBLK ELEMENT IN RECORRAD OF ENTRY BEING PROCESSED      *
*   R7(RA)= @ ENTRYPOINT SYMSECT, THEN ADDRESS OF THAT ENTRY          *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
*              INITIALIZE FOR SEARCH FOR AJOREPL IN RFSYMS LIST.
         L     R1,RERFSYMS         GET ADCON FOR RFSYMS
         SR    R2,R2               CLEAR FOR INSERTIONS
         LA    R3,RFSYMS$L-RFS$LEN(R1) ADEQUATE LIMIT FOR BXLE
         USING RFSYMBLK,R1         OVERLAY DSECT ON 1ST SECTION RFSYMS
         L     R4,AXSYFIND         =V(SYFIND), GET IT NOW, SO SAFE
         EJECT
*              SEARCH FOR CSECT NAME TO BE REPLACED.
*              LOOK AT EACH CSECT NAME IN RFSYMS, UNTIL ONE IS FOUND
*              WHICH IS IN THE SYMBOL TABLE AND DECLARED CSECT.
REESEARC LA    RA,RFSYMB           SHOW @ OF CSECT NAME
         LA    RB,L'RFSYMB         SHOW LENGTH OF IT (ALWAYS 6)
         LR    REP,R4              REP= =V(SYFIND). MOVE OVER FOR CALL
         BALR  RET,REP             CALL SYFIND TO LOOKUP THE SYMBOL
         L     R11,AVAJOBPT        RESTORE THE PTR IN CASE NEEDED
         SPACE 1
         LTR   RB,RB               WAS THE SYMBOL IN THE SYMBOL TABLE
         BNZ   REESEARE            NO, SO SKIP TO LOOK AT NEXT ONE
         USING SYMSECT,RA          NOTE SYMBOL TABLE PTR, IT WAS IN
         TM    SYFLAGS,$SYCSE      WAS IT FLAGGED A CSECT (A MUST)
         BO    REEFOUND            YES, THIS IS ONE WE'RE LOOKING FOR
         DROP  RA                  REMOVE SYMSECT USING
         SPACE 1
REESEARE IC    R2,RFSENTL          GET LENGTH OF CSECT+ENTRY ENTIRES
         BXLE  R1,R2,REESEARC      ADD INCREM TO NEXT CSECT, LOOP OK
         SPACE 1
*              FALLS THRU==> CSECT NAME TO BE REPLACED NOT FOUND.
*              FLAG PROGRAM UNEXECUTABLE, NEVER ENTER PHASE B.
         OI    AVTAGS1,AJNLOAD     SHOW THE REPLACE PROG NOGOOD,NO EXEC
         REPRNT REZAR100,L'REZAR100    MISSING NAME MESSAGE
         B     REENRET             RETURN, NO ADCONS CHANGED
         SPACE 1
*              CSECT NAME FOUND, NOW LINK ITS ENTRY POINTS IN VWXTABL.
REEFOUND MVC   REZCSECT,RFSYMB     MOVE REPLACED CSECT NAME OVER
         REPRNT REZAR000,REZ000L   PRINT MESSAGE WITH CSECT NAME
         SPACE 1
         IC    R2,RFSENTN          GET # ENTRIES BELONGING TO CSECT
         STH   R2,RECORNUM         STORE COUNT INTO CORRESPONDENCE #
         MVC   REFRIAD,RFSRIAD     SAVE @ OFFSET TO CALL LIST CHK VALS
         LA    R1,RFS$LEN(R1)      SET RFSYMBLK TO 1ST ENTRY-TYPE ENTRY
         LA    R5,RECORRAD         INIT TO BEGINNING @ OF CORRES TABLE
         USING RECORBLK,R5         NOTE DSECT PTR
         SR    R3,R3               CLEAR, WILL BE INDEX TO RECORRAD
         SPACE 1
*              LOOP THRU ENTRY LIST.  LOOK EACH ONE UP IN SYMBOL
*              TABLE. OBTAIN EACH ENTRY POINT @ AND CREATE A RECORBLK
*              ELEMENT FOR IT.  MODIFY ADCON IN AVWXTABL.
REESYCAL LA    RA,RFSYMB           @ SYMBOLIC ENTRYPT NAME
         LA    RB,L'RFSYMB         LENGTH OF NAME(ALWAYS 6)
*              SYFIND MAY ERASE REGISTERS RA-RE (R7-R11).
         LR    REP,R4              REP= =V(SYFIND). MOVE OVER FOR CALL
         BALR  RET,REP             CALL SYFIND TO LOOKUP THE SYMBOL
         L     R11,AVAJOBPT        RESTORE R11 IN CASE WE NEED IT
         LTR   RB,RB               WAS IT THERE
         BNZ   REENOENT            NO, UNDEFINED, NOT IN TABLE AT ALL
         USING SYMSECT,RA          NOTE SYMBOL TABLE POINTER
         TM    SYFLAGS,$SYDEF      WAS SYMBOL DEFINED
         BZ    REENOENT            NO,FLAG IT
         TM    SYFLAGS,$SYENT+$SYCSE   WAS IT EITHER CSECT OR ENTRY
         BZ    REENOENT            NO, SO FLAG IT
         L     R7,SYVALUE          GET VALUE OF SYMBOL, FOR ENTRY
         DROP  RA                  NO MORE SYMBOL DSECT
         B     REENLINK            BRANCH TO LINKAGE SEGMENT
         EJECT
*              ENTRY NOT FOUND OR UNDEFINED - PRINT MESSAGE, FLAG.
REENOENT MVC   REZEN002,RFSYMB     MOVE THE ENTRY NAME OVER
         REPRNT REZAR002,REZ002L   MESSAGE SHOWING ENTRY NOT FOUND
         L     R7,AWFM1            TO GO INTO RECFPSW, SHOW NOGOOD
         SPACE 1
*              LINK NEEDED POINTERS AND CORRESPONDENCE TABLE RECORRAD.
REENLINK MVC   RECSYMB(RFS$LEN),RFSYMB      MOVE RFSYMBLK OVER
         ST    R7,RECFPSW          SAVE ENTRYPT IN USER PROGRAM
         LH    R14,RECAXAD         GET OFFSET INTO AVWXTABL FOR ADCON
         LA    R14,AX$BASE(R14)    GET ACTUAL @ OF THE ADCON
         MVC   RECADRE,0(R14)      SAVE THE REAL ADCON
         MVC   RECINSTS(RECZ$L),AWZEROS     ZERO STATS COUNTERS
*              FILL IN AVWXTABL WORD- @ REFAKE, OFFSET ID OF ENTRYPT
         MVC   0(4,R14),REREFAKE   PUT IN @ FAKE/CHECK ROUTINE
         STC   R3,0(,R14)          STORE RECORBLK OFFSET INTO ADCON BYT
         SPACE 1
*              CHECK IF ENTRY OK, PRINT MESSAGE IF SO.
         LTR   R7,R7               WAS ENTRY @ < 0 (I.E. NOT FOUND)
         BM    REENOENS            NO, MESSAGE ALREADY PRINTED
         LA    R8,REZLOCAT         SHOW @ FOR HEX CONVERSION
         BAL   R14,REXCON3         CONVERT TO HEX
         MVC   REZEN001,RFSYMB     MOVE SYMBOL IN FOR ENTRY NAME
         REPRNT REZAR001,REZ001L   MESSAGE DESCRIBNG OK ENTRY
         SPACE 1
REENOENS LA    R1,RFS$LEN(R1)      BUMP PTR TO NEXT RFSYMBLK ENTRY
         LA    R3,REC$LEN(R3)      INCREMENT OFFSET VALUE IN RECORRAD
         LA    R5,REC$LEN(R5)      BUMP PTR TO NEXT RECORBLK ELEMENT
         BCT   R2,REESYCAL         GO BACK FOR NEXT ENTRY. LOOP ON #
         DROP  R1,R5               REMV RFSYMBLK,RECORBLK
         SPACE 1
         OI    REFLAGS,READMOD     SHOW WE'VE MODIFIED ADCONS
         B     REENRET             RETURN TO CALLING PROGRAM
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              POST-ASSEMBLY -- REPLACEMENT PHASE B                   *
*        PRINT STATISTICS OF USER-PROGRAM PERFORMANCE.                *
*              ***** PHASE B REGISTER USAGE *****                     *
*   R0,R1,R2,R8,R9      WORK REGISTERS                                *
*   R4 = NUMBER OF RECORBLK ENTRIES LEFT TO PROCESS                   *
*   R5 = @ RECORBLK OF ENTRY WHOSE STATISTICS ARE BEING CALCULATED.   *
*   R7 = @ 12-BYTE FIELD WHERE NEXT OUTPUT NUMBER TO BE PLACED        *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
REEPHSB  REPRNT REZAR003,REZ003L   PRINT HEADER LINE
         LH    R4,RECORNUM         # ENTRY POINTS FOR LOOP COINTER
         LA    R5,RECORRAD         INIT @ TO BEGINNING OF TABLE
         USING RECORBLK,R5         NOTE POINTER
         SPACE 1
REESTATS MVC   REZ004EN,RECSYMB    MOVE ENTRYPOINT NAME OVER
         LA    R7,REZ004NS         @ 1ST OUTPUT NUMBER, INCRD BY DECO
         SPACE 1
         L     R8,RECINSTS         # INSTRUCTIONS DONE
         BAL   R14,REEXDECO        PRINT IT, ADVANCE R7 PTR
         SPACE 1
         LR    R1,R8               SAVE # INSTRUCTIONS DONE FOR LATER
         LH    R8,RECCALLS         # CALLS TO ROUTINE
         BAL   R14,REEXDECO        CONVERT # CALLS, ADVANCE R7
         SPACE 1
         LR    R2,R8               SAVE # CALLS FOR LATER DIVIDESX
         LH    R8,RECWRONG         GET # WRONG RETURN TIMES
         BAL   R14,REEXDECO        CONVERT # WRONG, ADVANCE R7
         SPACE 1
         LR    R9,R8               SAVE # WRONG
         LTR   R2,R2               WAS # CALLS ZERO
         BNZ   *+8                 NO, SO LEAVE AS IS
         LA    R2,1                YES, =0, SO MAKE =1 FOR SAFE DIVIDES
         SR    R0,R0               CLEAR FOR DIVIDE SETUP
         DR    R0,R2               AVG # INSTRS/CALL
         LR    R8,R1               MOVE QUOTIENT OVER FOR CONVERT
         BAL   R14,REEXDECO        CALL CONVERT ROUTINE, ADVANCE R7
         SPACE 1
         LA    R8,100              VALUE FOR PERCENT CONVERT
         MR    R8,R8               # WRONG * 100, RESULT IN R9
         DR    R8,R2               #WRONG*100/#CALLS = PERCENT
         LR    R8,R9               MOVE QUOTIENT FOR CONVERT
         BAL   R14,REEXDECO        CONVERT, ADVANCE R7
         SPACE 1
         REPRNT REZAR004,REZ004L   PRINT MESSAGE FOR THIS ENTRY
         LA    R5,REC$LEN(R5)      INCREMENT THE RECORBLK PTR
         BCT   R4,REESTATS         LOOP BACK FOR NEXT RECORBLK VALS
         DROP  R5                  DON'T NEED RECORBLK ANYMORE
         SPACE 1
REENRET  $RETURN RGS=(R14-R12)
         DROP  R6,R11,RAT,R13      DROP TABLE USINGS, BASE REGS
         EJECT
**--> ENTRY: REFAKE     INTERCEPT REPLACED CALLS, CHECK REAL/USER . . .
*.       ENTRY CONDITIONS                                             .
*.  R15(BITS 0-7)= OFFSET CODE # FOR SPECIFIC ENTRY BEING CALLED.     .
*.  R0-R14     ARE AS DESCRIBED IN ASSEMBLER CALLING CONVENTIONS.     .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         SPACE 1
* * * * * REFAKE ENTRY REGISTER USAGE * * * * * * * * * * * * * * * * *
*   R0,R1,R2,R3,R4,R15  WORK REGISTERS                                *
*   R5 = @ RECORBLK ELEMENT FOR THE ENTRY POINT BEING CALLED.         *
*   R6 = FIRST BASE REGISTER, USED FOR MAIN CODE.                     *
*   R9 = LINK REGISTER FOR INSUBS WHICH MUST CALL OTHERS WITH R14.    *
*   R10= @ ECONTROL (EXECUTION CONTROL BLOCK, USER PSEUDO REGISTERS.  *
*   R13= SAVE AREA @, ALSO SECOND BASE REGISTER, FOR INSUBS.          *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
REFAKE   $SAVE RGS=(R14-R6),BR=R6,SA=RESAVE      SAVE ALL BUT PARM RGS
         USING AVWXTABL,RAT        NOTE MAIN ASM TABLE USING
         USING RESAVE,R13          NOTE SECONDARY BASE REG USING
         SPACE 1
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        REFAKE IS ENTERED VIA A MODIFIED ADCON IN AVWXTABL, WHICH    *
*   ALSO CONTAINS THE OFFSET IN RECORRAD OF THE RECORBLK FOR THE      *
*   REPLACED ENTRY BEING CALLED.  SET R5 TO THE @ THIS RECORBLK, TO BE*
*   USED THROUGHOUT THIS CODE.  CALL THE CORRESPONDING REAL ASSIST    *
*   ROUTINE.  SAVE INITIAL PARM REGISTER VALUES AND THOSE RETURNED    *
*   BY REAL ROUTINE FOR TESTING, OR PRINTING.  ALSO PRINT VARIOUS     *
*   REGISTER SETS OR THE CURRENT STATEMENT, IF REQUIRED BY SETTING    *
*   OF VARIOUS BITS IN ECRFLAG OF THE ECONTROL BLOCK.                 *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         STM   RA,RE,REGSAVA       SAVE ORIGINAL PARM REG VALUES
         SRL   R15,24              GET HI-ORDER BYTE BY ITSELF
         LA    R5,RECORRAD(R15)    ADD OFFSET TO TABLE @==>@RECORBLK
         USING RECORBLK,R5         NOTE @ TABLE ELEMENT
*              INCREMENT TOTAL NUMBER OF TIMES CALLED.
         LH    R15,RECCALLS        CURRENT TOTAL NUMBER OF CALLS
         LA    R15,1(R15)          +1 FOR THIS TIME
         STH   R15,RECCALLS        = NEW CURRENT TOTAL # CALLS
         SPACE 1
*              CALL THE REAL ASSIST ROUTINE FIRST.  SAVE THE VALUES
*              IT RETURNS IN REGISTERS RA-RE FOR LATER USE.
         SPACE 1
         L     R15,RECADRE         GET REAL ENTRY POINT @
         BALR  RET,REP             CALL THE REAL ROUTINE
         STM   RA,RE,REGSAVB       SAVE THE RETURNED PARAMETERS
         SPACE 2
*              ENTRY ACCEPTED, SET UP FOR INTERPRETATION
         L     R11,AVAJOBPT        GET PTR TO ,AIN CONTROL BLOCK
         USING AJOBCON,R11         NOTE PTR
         L     R10,AJOECOPT        GET PTR TO PARTIALLY-FILLED ECONTROL
         USING ECONTROL,R10        NOTE PTR
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        DEPENDING ON ECRFLAG (WHICH CAN BE CHANGED BY THE USER PROG  *
*   DURING EXECUTION), PRINT THE CURRENT CARDIMAGE (IF ANY), THE 5    *
*   PARAMETER REGISTERS ON ENTRY, AND/OR THE PARAMETER REGISTERS      *
*   RETURNED BY THE REAL ASSIST ROUTINE.                              *
*        THEN FLIP THESE BIT FLAGS, SO THAT IF AN ERROR OCCURS, WE    *
*   CAN PRINT ANYTHING WE DIDN'T ALREADY PRINT .                      *
*              INIT REFPRT BIT IN REFLAGS OFF.  USE OF REXPRINT INSUB *
*        SETS THIS BIT ON.  IF IT IS ON WHEN REFAKE EXITS, 2 LINES ARE*
*        SKIPPED TO SEPARATE OUR MESSAGES FROM FOLLOWING LISTING. THE *
*        LISTING IS VERY HARD TO FOLLOW IF THIS IS NOT DONE.          *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         NI    REFLAGS,255-REFPRT      INIT FLAG TO SHOW NO MSGS PRT YT
         MVC   REFRFLAG,ECRFLAG    SAVE THE BYTES FOR LATER
         BAL   R9,REFRFC           CALL INSUB FOR 3 CHECKS/PRINTS
         XI    REFRFLG1,ECR$REGB+ECR$REGA+ECR$CARD    FLIP BITS
         SPACE 2
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        FINISH CONSTRUCTION OF ECONTROL FOR INTERPRETIVE CALL TO     *
*   USER-WRITTEN REPLACEMENT PROGRAM.  CALL THE INTERPRETER, WITH THE *
*   USER PROGRAM AS ARGUMENT. INCREMENT STATISTICS, AND BRANCH TO     *
*   PROCESS POSSIBLE ERROR IF ANY BUT NORMAL RETURN INDICATED.        *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
*              TEST USER ENTRYPT TO MAKE SURE HAS BEEN FOUND.
         CLI   RECFPCC,0           WAS BYTE 0, I.E. LEGAL @
         BNE   REFNOCAL            NO, SO QUIT NOW, CAN'T EXECUT
         SPACE 1
         MVC   ECFENTER,RECFPSW    INIT ENTRY POINT TO RIGHT @
         MVI   ECFLAG0,$ECSPIEB+$ECEOF      SET FLAG PROPERLY
         SPACE 1
*              INITIALIZE REGISTER CONTENTS FOR USER PROGRAM.
         MVC   ECREGS(7*4),REFILLRG         PUT IN REGISTER FILLER
         MVC   ECREGRA(5*4),REGSAVA         MOVE ORIG PARM REGS TO FAKE
         MVC   ECFPREGS(32),ECREGS PUT 4'S OVER HERE ALSO
         ST    RAT,ECREG12         SAVE AVWXTABL PTR HERE
         MVC   ECREG13,ECSAVE1     MOVE @ DUMMY SAVEAREA INTO FAKE 13
         MVC   ECREG14,RERFSYMS    PUT DISTINCT, EASY-TO-CHECK RET @
         MVC   ECREG15,ECFENTER    PUT ENTRY PT @ IN FAKE R15
         SPACE 1
REEXECUT EQU   *                   ENTER HERE AFTER USER CALLED AN
*                                  ASSIST MODULE AND IT REURNED OK
         L     REP,AJOEXECU        =V(EXECUT)         PUT IN ADCON
         BALR  RET,REP             CALL THE INTERPRETER
         SPACE 1
*              UPDATE TOTAL NUMBER OF INSTRUCTIONS PERFORMED.
         LM    R14,R15,ECILIMT     GET ECILIMT-ECILIMP
         SR    R15,R14             # INSTRUCTIONS EXECUTED THIS TIME
         A     R15,RECINSTS        +  CUMULATIVE TOTAL FROM BEFORE
         ST    R15,RECINSTS        =  NEW CUMULATIVE TOTAL INSTRUCTIONS
         SPACE 1
         MVI   RERGEFLG,0          ZERO OUT RETURN CODE FLAG
         MVC   REZ059MS(REZ059ML),AWBLANK   BLANK OUT MESSAGE AREA
         SPACE 1
         CLI   ECFLAG1,$ECBRN14    WAS A PROPER RETURN DONE
         BNE   REFNORET            NO GOOD RETURN-BRANCH
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              CHECKING SECTION FOR USER-RETURNED REGISTERS           *
*        1. CALL INSUB RGENTS TO CHECK REGS RA-RE FOR INDIVIDUAL CASES*
*        2. MAKE COMMON CHECK FOR MODIFIED REGS - R0-R6, R12, R13.    *
*        3. SET ECRFLAG IF NEEDED AND PRINT MESSAGE AR059 AND OTHER   *
*        MESSAGES, IF THERE WERE ONE OR MORE ERRORS.                  *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         LH    R15,RECRGAD         GET OFFSET FOR SPECIFIC ERROR
         BAL   R14,RGENTS          CALL CHECKING ROUTINE.INITS RERGEFLG
         SPACE 1
         NI    ECRFLAG+1,255-ECR$ERRC       INIT TO SHOW NO ERRORS
         SPACE 1
         CLC   ECREGS(7*4),REFILLRG         MAKE SURE DIDN'T MESS UP
         BE    *+14                OK, SKIP ERROR
         OI    RERGEFLG,RGE06      FLAG THIS ERROR
         MVC   REZ059R0,=C'R0-R6'  MOVE MESSAGE IN
         SPACE 1
         BAL   R14,REGC1213        CALL R1K R13 CHECKER
         SPACE 1
         TM    RERGEFLG,X'FF'      WERE THERE ANY ERRORS AT ALL
         BZ    REFNOERR            NO, SO SKIP PRINTING
         SPACE 1
         OI    ECRFLAG+1,ECR$ERRC  SET ERROR FLAG FOR THE USER
         BAL   R9,REFRFC           PRINT OUT ANYTHING NOT ALREADY DONE
         B     REF059PR            SKIP TEST, GO PRINT AR058-AR059
         SPACE 1
*              TEST FOR PRINTING REGS RETURNED BY USER PROGRAM.
REFNOERR TM    ECRFLAG+1,ECR$REGC  DID HE WANT TO SEE RETURN REGS
         BZ    REFRFZ08            NO, SKIP
         SPACE 1
REF059PR MVI   REZ05XN,C'8'        SHOW AR058 MESSAGE
         BAL   R14,REREGSRA        CALL REREGS, PRINT ECREGSRA-
REFRFZ08 EQU   *                   BRANCH LABEL IF PREVIOUS CODE SKIPPE
         SPACE 1
         TM    RERGEFLG,X'FF'      WERE THERE ANY ERRORS
         BZ    REFNOERS            NO ERRORS, BRANCH OUT AGAIN
         SPACE 1
*              AR058 MESSAGE JUST PRINTED. ADD AR059 WITH ERROR FLAGS.
         BAL   R9,REGCRARE         CALL TO CHK BITS, FLAG, PRINT AR059
         SPACE 1
         LH    R1,RECWRONG         GET CURRENT # WRONG
         LA    R1,1(R1)            +1 FOR THIS TIME
         STH   R1,RECWRONG         = NEW TOTAL # WRONG
         B     REFARETA            GO RESTORE PARM REGS, RETURN
         EJECT
*              EXIT TAKEN IF UNFOUND ENTRY POINT CALLED DURING EXEC.
REFNOCAL EQU   *                   CALLED ENTRY NOT FOUND EXIT
         MVC   REZEN101,RECSYMB    MOVE NAME OF ENTRY OVER-ERROR
         REPRNT REZAR101,REZ101L   PRINT UNFOUND ENTRY CALLED DURING EX
         LM    R14,R15,ECRDLIML    ECRDLIML-H - DUMP LIMITS
         XSNAP T=(PR,FL,1),STORAGE=(*0(R14),*0(R15)),                  #
               LABEL='REPLACE MONITOR AR101 DUMP'
         B     REFAREAL            GO RESTORE ADCONS
         SPACE 2
REFNORET EQU   *                   BRANCH HERE IF NOT RIGHT RETURN
         AIF   (&$REPL LT 2).REFNOBR        SKIP IF CAN'T CALL OTEHRS
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              CHECK USER FOR CALLING ASSIST ROUTINE PROPERLY         *
*        CHECK USER ROUTINE FOR BRANCHING OUT IF ITSELF, USING A LEGAL*
*        OFFSET CODE GIVEN TO IT BY RESYMB.                           *
*              REGISTER USAGE IN CALL CHECKING SECTION                *
*   R4 = @ RFSYMBLK OF CALLED ROUTINE (SECTION 2 OR RFYSMS).          *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         CLI   ECFLAG1,$ECBROUT    WAS ERROR BRANCH OUT OF RANGE
         BNE   REFABEND            NO, SO MUST BE ACTUAL ERROR
         SPACE 1
         LH    R15,REFRIAD         GET OFFSET TO RI&CSECT IF ANY
         LTR   R15,R15             IS THIS CSECT ALLOWED TO CALL
         BZ    REFABEND            =0 ==> CAN'T CALL-BRANCH -ERROR
         SPACE 1
         L     R1,RERFSYMS         =V(RFYSMS), @ CONTROL TABLE
         LH    R0,0(R15,R1)        GET # ENTRY PTS CALLABLE FROM CSECT
         L     R4,ECREG15          GET USER REGISTER 15
         LA    R4,0(R4)            REMOVE ANY GARBAGE FROM FRONT
         SPACE 1
*              SEE IF USER BRANCHED TO LEGAL OFFSET GIVEN HIM BY RESYMB
REHSEARC LA    R15,2(R15)          INCREMENT COUNTER TO NEXT HALF
         LH    R2,0(R15,R1)        GET NEXT VALUE, EXPAND
         CR    R4,R2               WAS VALUE THE SAME
         BE    *+12                YES, ITS OK, SO JUMP OUT OF LOOP
         BCT   R0,REHSEARC         LOOP BACK FOR LIST OF CALLABLES
         B     REFABEND            VALUE WASN'T ONE OF OURS-QUIT
         SPACE 1
*              OFFSET INTO SECTION 2 OF RFSYMS CHECKED AND OK.
         AR    R4,R1               ADD =V(RFYSMS), GET @ ELEMENT
         DROP  R5                  TEMPORARILY REMOVE USING FOR USER
         USING RFSYMBLK,R4         NOTE PTR TO CALLED ASSIST PROG
         LH    R15,RFSRHAD         GET OFFSET OF CHECKING CODE
         BAL   R14,RHENTS          CALL CHECKER, NOTE RERGEFLG =0 ALRED
         SPACE 1
         BAL   R14,REGC1213        GET R12 CHECKED, R13 PARTIALLY
         TM    RERGEFLG,RGE13      WAS R13 FLAGGED
         BZ    REHN13              NO, SO IT WAS OLD SA PTR, OK
         SPACE 1
         TM    ECREG13+3,3         AS IT ON F BOUNDARY
         BNZ   REHN13              NO, ERROR, LEAVE IT FLAGGED
         L     R15,ECREG13         GET USER R13
         LA    R15,0(R15)          REMOVE LEADING BYTE
         C     R15,ECFADL          LOWER THAN LOWEST USER @
         BL    REHN13              OUT OF AREA, ALREADY MARKED,BR
         C     R15,ECFADHC         COMPARE TO HIGH LIMIT FOR USER
         BH    REHN13              OUTSIDE, NOGOOD, LAREADY FLAGGED
         NI    RERGEFLG,255-RGE13  IN USER AREA, OS OK, REMOVE FLAG
         MVC   REZ05913,AWBLANK    REMOVE R13 MESSAGE TOO
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              IF USER WANTS TO SEE THEM, OR IF THERE IS AN ERROR,    *
*        PRINT PARAMETER REGISTERS PASSED BY USER PROGRAM.  IF IN     *
*        ERROR, PRINT ERROR MESSAGE AND ABEND THE USER.  IF CORRECT,  *
*        CALL THE ASSIST ROUTINE, AND PASS ITS ANSWERS BACK TO THE    *
*        USER PROGRAM.  THE INTERPRETR CONTINUES FROM WHERE IT LEFT   *
*        OFF, WITHOUT REINITIALIZING INSTRUCTION STACK.               *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
REHN13   TM    ECRFLAG+1,ECR$REGD  DID USER WANT REGS PRINTED ON CALL
         BO    REF050PR            YES, OS GO PRINT
         SPACE 1
         TM    RERGEFLG,X'FF'      WAS NAYTHING WRONG WITH HIS REGS
         BZ    REHNOERS            NO, SO LEGIT CALL, GO DO IT
         SPACE 1
REF050PR MVI   REZ05XN,C'0'        SHOW AR050 MESSAGE
         MVC   REZ05XMS,=CL9'CALL TO'       MOVE IN MESSAGE
         MVC   REZ05XEN,RFSYMB     MOVE IN SYMBOL OF ENTRY CALLED
         BAL   R14,REREGSRA        GO PRINT USER REGS OUT
         SPACE 1
         TM    RERGEFLG,X'FF'      WERE THER ANY ERRORS
         BZ    REHNOERS            NO, USER JUST WANTED TO SEE, SKIP
         SPACE 1
         BAL   R9,REGCRARE         HAVE REGS RA-RE FLAGGED IF NEED,PRT
         B     REFABEND            USER MADE HIS MISTAKE-ABEND
         SPACE 1
REHNOERS LH    R15,RFSAXAD         OFFSET IN AVWXTABL OF V(REAL ROUT)
         DROP  R4                  DON'T NEED CALLED RFSYMBLK ANYMORE
         USING RFSYMBLK,R5         RESTORE NOREMAL USING FOR ELSEWHERE
         L     R15,AX$BASE(R15)    GET ACTUAL @ CALLED ROUTINE
         SPACE 1
         LR    R1,R10              SAVE @ ECONTROL
         LM    RA,R13,ECREGRA      GET USER REGS RA-RE,R12,R13
         USING ECONTROL,R1         TEMPORARY USING
         DROP  R10                 REMOVE USING SO WE CAN USE R1 TEMPRL
         DROP  R13                 WIPED OUT REG, SO ERASE USING
         BALR  R14,R15             CALL REAL ASSIST ROUTINE
         SPACE 1
         STM   RA,RE,ECREGRA       SAVE THE PARM REGS
         LR    R10,R1              GET @ ECONTROL BACK IN USUAL REG
         DROP  R1                  REMOVE TGEMP USING
         USING ECONTROL,R10        RESTORE NORMAL USING
         L     R11,AVAJOBPT        GET @ AJOBCON BACK
         LA    R13,RESAVE          GET @ OF OUR SAVE AREA BACK
         USING RESAVE,R13          RESOTRE NORMAL USING HERE
         SPACE 1
         MVC   ECPSWIAD,ECREG14+1  MOVE TO PSW @ SO STARTS THERE
         B     REEXECUT            GO TO START INTEPRETER UP AGAIN
         EJECT
.REFNOBR ANOP
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              REFAKE EXIT CODE SECTIONS                              *
*        IF USER ABENDED FOR ANY REASON, GIVE HIM A DUMP AND          *
*        HAVE ALL ADCONS REPLACED, THUS TERMINATING REPLACEMENT.      *
*        IN ANY CASE, PLACE THE CORRECT RETURN VALUES IN PARAMETER    *
*        REGISTERS RA-RE.  THEN RETURN TO THE ASSIST ASSEMBLER        *
*        ROUTINE WHICH UNWITTINGLY CALLED REFAKE.                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
REFABEND EQU   *                   USER PROGRAM ABEND EXIT
         REPRNT REZAR102,REZ102L   ABEND MESSAGE
         BAL   R9,REFRFC           PRINT ANYTHING NOT ALREADY PRINTED
REFADUMP EQU   *                   ENTER HERE TO DUMP USER AND RESTORE
         LM    R14,R15,ECRDLIML    GET DUMP LIMITS
         XSNAP T=(PR,FL,10),STORAGE=(*0(R14),*0(R15)) GIVE DUMP
REFAREAL EQU   *                   ENTER HERE IF CANNOT USE DUMP ABOVE
         BAL   R14,REREAL          CANCEL REPLACEMENT
         SPACE 1
REFNOERS EQU   *                   BRANCH HERE IF NO ERRORS IN REG CHEC
REFARETA EQU   *                   EXIT LABEL FOR ENTIRE REFAKE
         TM    REFLAGS,REFPRT      HAVE WE PRINTED ANY MESSAGE
         BZ    REFARETE            NO, SO DON'T DO ANYTHING
         REPRNT  REZAR000,1        =C'0'.  SKIP 2 LINES FOR READABLE
REFARETE EQU   *                   BRANCH HERE IF DON'T HAVE TO SKIP
         LM    RA,RE,REGSAVB       RELOAD REAL SUBR'S RIGHT PARM RGS
REFARET  $RETURN RGS=(R14-R6)      RESTORE ALL BUT PARM REGS
         DROP  R5,R6,R10,R11,RAT,R13        ERASE ALL USINGS
         TITLE 'REPLACE MONITOR - INTERNAL DATA AREAS - BASE R13'
RESAVE   DS    18F                 SAVE AREA, SECONDARY BASE REG
         SPACE 1
REREFAKE DC    A(REFAKE)           ADCON TO PLACE INTO AVWXTABL
RERFSYMS DC    V(RFSYMS)           SYMBOLIC ENTRY TABLE CSECT
REFILLRG DC    (7*4)AL1($PRGFILR)  FILL CHARS FOR REGISTERS
REGSAVA  DS    5F                  REGS RA-RE BEFORE REAL PROG CALLED
REGSAVB  DS    5F                  REGS RA-RE AFTER CALL TO REAL SUBR
RECORRAD DS    0F,(REC$MAX)CL(REC$LEN)      ADCON CORRESPONDENCE TABLE
REXFWORK DC    F'0',X'04'          WORKAREA, WITH REVERSED ' ' FOR HEX
REFLAGS  DC    B'0'                FLAG BYTE
RECORNUM DC    H'0'                CURRENT # ENTRIES IN RECORRAD
REFRFLAG DS    H                   SAVE AREA FOR ECRFLAG OVER CALL
REFRFLG1 EQU   *-1                 @ 2ND BYTE REFRFLAG, WHERE BITS ARE
REFRIAD  DS    H                   OFFSET @ FROM RFSYMS TO COUNT, THEN
*              LIST OF OFFSETS TO RFSYMBLK ELEMENTS FOR CALLABLE SUBS
*              FOR REPLACED CSECT.  ONLY USED IF &$REPL=2.
RERGEFLG DS    B                   FLAG FOR ERROR CONDTIONS IN USER RGS
         SPACE 2
*              INFORMATION, WARNING MESSAGES - AR00# MESSAGES.        *
*        ///AR000 - LIST NAME OF CSECT BEING REPLACED.                *
*        ///AR001 - LIST NAME AND LOCATION OF EACH ENTRY BEING REPPD. *
*        ///AR002 - LIST NAME OF ENTRY REQUIRED BUT NOT FOUND.        *
*        ///AR003 - OUTPUT HEADER FOR PERFORMANCE STATISTICS          *
*        ///AR004 - LIST PERFORMANCE STATISTICS FOR SINGLE ENTRY.     *
         SPACE 1
REZAR000 DC    C'0///AR000 REPLACE CSECT: '
REZCSECT DC    CL6' ',C' ///'
REZ000L  EQU   *-REZAR000          LENGTH OF MESSAGE
         SPACE 1
REZAR001 DC    C'0///AR001 REPLACE ENTRY: '
REZEN001 DC    CL6' ',C' AT LOCATION: '
REZLOCAT DC    XL6'0',C' ///'
REZ001L  EQU   *-REZAR001          LENGTH OF MESSAGE
         SPACE 1
REZAR002 DC    C'0///AR002 REPLACE ENTRY: '
REZEN002 DC    CL6' ',C' NOT FOUND AS CSECT OR ENTRY ///'
REZ002L  EQU   *-REZAR002          LENGTH OF MESSAGE
         SPACE 1
REZAR003 DC    C'0///AR003 STATISTICS :  # INSTRUCTIONS    # CALLS    '
         DC    C'# WRONG    INSTRS/CALL   % WRONG'
REZ003L  EQU   *-REZAR003          LENGTH OF MESSAGE
         SPACE 1
REZAR004 DC    C' ///AR004     '
REZ004EN DC    CL6' ',C' : '       SPACE OFR ENTRY NAME
REZ004NS DS    5ZL12               5 SLOTS FOR OUTPUT NUMBERS
         DC    C' %'
REZ004L  EQU   *-REZAR004          LENGTH OF MESSAGE
         EJECT
*              DEBUG SERVICE MESSAGES - AR05# MESSAGES AND ITEMS.
*        ///AR050 - PARM REGISTERS ON CALL TO ANOTHER ROUTINE.        *
*        ///AR051 - CARDIMAGE BEFORE ENTRY TO ROUTINE.                *
*        ///AR052 - PARM REGISTERS BEFORE ENTRY TO ROUTINE.           *
*        ///AR054 - PARM REGISTERS RETURNED BY REAL ROUTINE.          *
*        ///AR058 - PARM REGISTERS RETURNED BY USER ROUTINE.          *
*        ///AR059 - REGISTER ERROR MESSAGE, SHOWING ONES IN ERROR     *
         SPACE 1
REZAR051 DC    C'0///AR051 ON ENTRY TO  '
REZ051EN DC    CL6' ',C' STMT ADDR: '       ENTRY NAME
REZ051AD DC    XL6'0',C' ->'       @ CARDIMAGE, PTR TO IT
REZ051CD DS    CL71                SPACE FOR MOST OF CARD
REZ051L  EQU   *-REZAR051          LENGTH OF MESSAGE
         SPACE 2
REZ05ENT DC    C'ENTRY TO '        ... THESE TWO CONSTANTS MUST
REZ05EXT DC    C'EXIT FROM'        ... BE OF THE SAME LENGTH.
         SPACE 1
REZAR05X DC    C'0///AR05'         HEADER BEGINNING
REZ05XN  DC    X'0',C' ON '        LAST DIGIT OF MESSAGE NUMBER
REZ05XMS DC    CL(L'REZ05ENT)' ',C' '       'ENTRY TO' OR 'EXIT FROM'
REZ05XEN DC    CL6' ',C' REGISTERS RA-RE: '           ENTRY NAME
         DC    C'RA/7/: '
REZ05XRG DC    XL8'0',C' RB/8/: ',XL8'0',C' RC/9/: ',XL8'0',C' RD/A/: '
         DC    XL8'0',C' RE/B/: ',XL8'0',C' '
REZ05XL  EQU   *-REZAR05X          LENGTH OF MESSAGE AREA
         SPACE 1
REZAR059 DC    C' ///AR059 WARNING: ERROR IN USER REGS: '
REZ059MS EQU   *                   BEGINNING OF AREA TO BE BLANKED
REZ059R0 DS    C'R0-R6',C' '       ERR IN ANY OF THESE
REZ05912 DS    C'R12',C' '         ASM TABLE REG-CAN'T CHANGE
REZ05913 DS    C'R13',C' '         SAVE AREA PTR
         ORG   REZAR059+(REZ05XRG-REZAR05X) ORG TO SIMILAR OFFSET
REZ059RG EQU   *                   BEGINNING OF MESSAGES FOR REGS
         ORG   REZAR059+REZ05XL    LEAVE SAME AMOUNT OF SPACE
REZ059ML EQU   *-REZ059MS          LENGTH TO BLANK OUT
REZ059L  EQU   *-REZAR059          LENGTH OF MESSAGE
         SPACE 2
*              SEVERE ERROR MESSAGES  - AR10# MESSAGES.               *
*              THESE ERRORS TERMINATE REPLACEMENT IMMEDIATELY.        *
*        ///AR100 - REPL= NAME COULD NOT BE FOUND.                    *
*        ///AR101 - UNFINDABLE ENTRY NAME CALLED DURING EXECUTION.    *
*        ///AR102 - USER PROGRAM ABENDED.                             *
         SPACE 1
REZAR100 DC    C'0///AR100 REPLACE CSECT NOT FOUND - REPLACE ABORT ///'
         SPACE 1
REZAR101 DC    C'0///AR101 INVALID ENTRYPOINT NAME: '
REZEN101 DC    CL6' ',C' CALLED. REPLACE ACTION ABORTED ///'
REZ101L  EQU   *-REZAR101          LENGTH OF MESSAGE
         SPACE 1
REZAR102 DC    C'0///AR102 USER PROGRAM ABENDED DURING REPLACEMENT ///'
REZ102L  EQU   *-REZAR102
         TITLE 'REPLACE MONITOR INTERNAL SUBROUTINES - BASE R13'
         SPACE 1
*              ***NOTE*** THE FOLLOWING USINGS ARE ASSUMED WHEN
*        NECESSARY BY ANY OF THE INSUBS WHICH NEED THEM.
         USING RECORBLK,R5         INDIVIDUAL ENTRY INFORMATION
         USING ECONTROL,R10        EXECUTION CONTROL TABLE
         USING AJOBCON,R11         JOB CONTROL TABLE PTR
         USING AVWXTABL,RAT        NOTE FOR REST OF CODE
         USING RESAVE,R13          NOTE SECONDARY BASE REGISTER
         SPACE 2
*              *****   LIST OF INSUBS *****                           *
*        REEXDECO  -   CONVERT NUMBER FROM BINARY TO EDITED DECIMAL   *
*        REFRFC    - PRINT REGISTER SETS DETERMINED BY USER           *
*        REGC1213  - CHECK USER REGS  12 AND 13, SET FLAGS            *
*        REGCRARE  - TEST FLAGS FOR REGS RA-RE. FORMAT AND PRINT MSG  *
*        REREAL    - RESTORE NORMAL ADDRESS CONSTANTS IN AVWXTABL     *
*        REREGS    - FORMAT,PRINT PARM REGS. REREGSRA PRINTS ECREGRA- *
*        REXCON3   - CONVERT REGISTER VALUE TO 3 BYTES OF HEXADECIMAL *
*        REXPRINT  - PRINT A LINE (CALLED BY REPRNT MACRO)            *
*                                                                     *
*        RGENTS    - RETURN VALUE CHECKING SECTION                    *
*        RGRAADDR  - (RGENTS INTERNAL) - CHECK RA FOR LEGAL SCAN PTR  *
*        RGRCADDR  - (RGENTS INTERNAL) - CHECK RC FOR @ IN USER PROGR *
*                                                                     *
*        RHENTS    - CHECK PARM REGS USER PASSED TO ASSIST SUBR.      *
*        RHRAADDR  - (RHENTS INTERNAL) CHECK RA FOR LEGALITY          *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 4
**--> INSUB: REEXDECO   CONVERT NUMBER TO DECIMAL   + + + + + + + + + +
*+       CALLED FROM REENDA, PHASE B, CONVERT NUMBER, ADVANCE PTR.    +
*+       ENTRY CONDITIONS                                             +
*+  R7 = @ 12-BYTE FIELD WHERE NUMBER SHOULD BE PLACED.               +
*+  R8 = NUMBER TO BE CONVERTED TO DECIMAL AND PLACED AT 0(R7).       +
*+  R14= RETURN @ TO CALLING CODE IN REENDA.                          +
*+       EXIT CONDITIONS                                              +
*+  R7 = INPUT VALUE OF R7 + 12, I.E., ADVANCED 1 POSITION.           +
*+  + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
         SPACE 1
REEXDECO XDECO R8,0(R7)            CONVERT NUMBER
         LA    R7,12(R7)           INCREMENT FIELD POINTER
         BR    R14                 RETURN
         EJECT
**--> INSUB: REFRFC     TEST ECRFLAG AND PRINT NEEDED INFOR + + + + + +
*+       ENTERED BEFORE USER PROGRAM EXECUTION (AND POSSIBLY AFTER,   +
*+       IF IT ABENDED), TO PRINT STATEMENT/AND/OR REGISTERS.         +
*+       ENTRY CONDITIONS                                             +
*+  R9 = RETURN @ TO CALLING CODE.                                    +
*+  R10= @ ECONTROL                                                   +
*+       EXIT CONDITIONS                                              +
*+  R7,R8,R14,R15  MAY BE CHANGED.                                    +
*+       MESSAGES AR051, AR052, AND/OR AR054 MAY BE PRINTED.          +
*+       MAY CALL INSUBS  REREGS,REXCON3,REXPRINT.                    +
*+  + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
         SPACE 1
*              TEST FOR CARDIMAGE PRINTING AND DO IT IF NEEDED.
*              **NOTE** REQUIRES AVRSBPT=0 IF NO CARD YET PROCESSED.
REFRFC   TM    REFRFLG1,ECR$CARD   DOES HE WANT CARDIMAGE
         BZ    REFRFZ01            NO, SO SKIP ENTIRELY
         L     R8,AVRSBPT          GET @ RSBLOCK, IF ANY
         LTR   R8,R8               =0 IF THERE ISN'T ANY CARD YET
         BZ    REFRFZ01            NO CARDIMAGE, CAN'T PRINT-BRANCH
         USING RSBLOCK,R8          NOTE POINTER TO RSBLOCK
         SPACE 1
         MVC   REZ051EN,RECSYMB    MOVE ENTRY NAME INTO MESSAGE
         SR    R7,R7               CLEAR FOR INSERTION
         IC    R7,RSBLENG          GET LENGTH-1 OF ENTRIE BLOCK
         SH    R7,=AL2(RSB$L)      - LENGTH BEFORE CARDIMAGE STARTS
         LA    R15,RSOL1-1         LENGTH-1 OF SINGLE CARD (MAX ALLWD)
         CR    R7,R15              WAS ACTUAL L-1 > MAX
         BNH   *+6                 NO, SKIP, USE ACTUAL L-1
         LR    R7,R15              YES, USE JUST 1 CARD OF SEVERAL
         SPACE 1
         MVC   REZ051CD,AWBLANK    BLANK PUT THE CARDIMAGE
         STC   R7,*+5              STORE LENGTH-1 INTO NEXT MVC
         MVC   REZ051CD($),RSBSOURC         MOVE VARIABLE SIZE CARD OVR
REFRFX01 LA    R7,RSBSOURC         PUT @ IN REG FOR CONVERSION
         DROP  R8                  DON'T NEED RSBLOCK USING ANY MORE
         LA    R8,REZ051AD         SHOW @ WHERE CONVERTED VALUE GOES
         BAL   R14,REXCON3         CALL CONVERT ROUTINE
         REPRNT REZAR051,REZ051L   PRINT CARDIMAGE, MESSAGE
REFRFZ01 EQU   *                   BRANCH LABEL, PREVIOUS CODE SKIPPED
         EJECT
*              TEST FOR INITIAL REGISTER VALUE PRINTING.
         MVC   REZ05XEN,RECSYMB    MOVE ENTRY NAME NOW. CAN USE # TIMES
         TM    REFRFLG1,ECR$REGA   DOES HE WANT INPUT REGISTERS
         BZ    REFRFZ02            NO, SO DON'T DO IT, BRANCH
         SPACE 1
         MVC   REZ05XMS,REZ05ENT   MV ENTRY TO MESSAGE IN
         MVI   REZ05XN,C'2'        MAKE MESSAGE ***AR052
         LA    R7,REGSAVA          SHOW @ BLOCK OF 5 ORIGINAL REGS
         BAL   R14,REREGS          CALL REGISTER CONVERT AND PRINT CODE
REFRFZ02 EQU   *                   BRANCH LABEL FOR SKIP PREVIOUS CODE
         SPACE 1
*              TEST FOR PRINTING OF REGS RETURNED BY REAL PROGRAM.
         MVC   REZ05XMS,REZ05EXT   PUT  'EXIT FROM' IN NOW
         TM    REFRFLG1,ECR$REGB   DOES HE WANT RETURNED VALUES
         BCR   Z,R9                NO RETURN TO CALLER
         SPACE 1
         MVI   REZ05XN,C'4'        MESSAGE IS ***AR054
         LA    R7,REGSAVB          SHOW @ 5 REGISTERS
         BAL   R14,REREGS          CALL REG CONVERT AND PRINT
         BR    R9                  RETURN TO CALLER
         EJECT
**--> INSUB: REGCRARE   USING RERGEFLG, FLAG AND PRINT REG MSG  + + + +
*+       **NOTE** SEE SECTION RGENTS FOR RGE-- FLAGS, AS FOLLOWING    +
*+       CODE MAY NOT BE OBVIOUS WITHOUT THEM.                        +
*+       ENTRY CONDITIONS                                             +
*+  R9 = RETURN @ TO CALLING CODE                                     +
*+  RERGEFLG IS NONZERO, I.E. AT LEAST 1 ERROR EXISTS.                +
*+       EXIT CONDITIONS                                              +
*+  REZAR059 MESSAGE IS COMPLETED AND PRINTED.                        +
REGCRARE IC    R0,RERGEFLG         GET THE FLAG, WITHS BITS POSS IN 3-7
         SLL   R0,32-5             SHIFT SO 5 BITS AT LEFT END OF REG
         LA    R1,REZ059RG         @ 1ST SLOT FOR FLAGGING
         SPACE 1
REFRAREF ALR   R0,R0               SET CC BY 1ST BIT, REST OF REG
         BC    Z+M,*+10            SKIP IF 1ST BIT=0, NOT ERROR
         MVC   0(8,R1),=8C'$'      FLAG THIS REG
         LA    R1,8+8(R1)          INCREMENT POINTER TO NEXT AREA
         BC    M+O,REFRAREF        LOOP BACK IF ANY MORE TO DO
         SPACE 1
         REPRNT REZAR059,REZ059L   PRINT ERROR FLAG LINE
         BR    R9                  RETURN TO CALLER
         SPACE 4
**--> INSUB: REGC1213   CHECK USER REGS 12-13,FLAG RERGEFLG + + + + + +
*+       ENTRY CONDITIONS                                             +
*+  R14= RETURN @ TO CALLING CODE                                     +
*+  REZAR059MS  IS ASSUMED TO BE BLANKED OUT                          +
*+       EXIT CONDITIONS                                              +
*+  RERGEFLG   MAY BE FLAGGED WITH RGE12 OR RGE13 OR BOTH             +
*+  REZ059MS   MAY CONTAIN REGISTER FLAGS  R12  OR R13                +
*++ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
         SPACE 1
REGC1213 C     RAT,ECREG12         DID HE LEAVE R12 ALONE
         BE    *+14                YES, SKIP
         OI    RERGEFLG,RGE12      SHOW R12 IN ERROR
         MVC   REZ05912,=C'R12'    SHOW ERROR MESSAGE
         SPACE 1
         CLC   ECREG13,ECSAVE1     DID HE SAVE SA PTR OK
         BCR   E,R14               YES, OK, RETURN
         OI    RERGEFLG,RGE13      NO, MODIFIED R13 ERROR
         MVC   REZ05913,=C'R13'    SHOW ERROR MESSAGE
         BR    R14                 RETURN TO CALLER
         EJECT
*+--> INSUB: REREAL     REPLACE REAL ADCONS IN VWXTABL IF NOT THERE.  +
*+       ENTRY CONDITIONS                                             +
*+  R11= @ AJOBCON JOB CONTROL TABLE.                                 +
*+  R12(RAT)= ADDRESS OF VWXTABL CSECT (FOR DSECT AVWXTABL)           +
*+  R14= RETURN ADDRESS TO CALLING CODE IN REMONI                     +
*+       EXIT CONDITIONS                                              +
*+  ALL ADCONS IN VWXTABL ARE CORRECT, REFLAGS IS MARKED UNMODIFIED.  +
*+  AJOSTEP IS FLAGGED TO SHOW NOT IN EXECUTION PHASE FOR SURE.       +
*+       USES REGS: R0,R1,R2,R15                                      +
*+       USES  DSECTS: AVWXTABL,RECORBLK                              +
*++ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
REREAL   EQU   *                   ENTRY FOR RESTORATION
         NI    AJOSTEP,255-AJOSEXEC         REMOVE INTERP FLAG FOR SURE
         TM    REFLAGS,READMOD     HAVE ADCONS BEEN MODIFIED
         BCR   Z,R14               NO,JUST RETURN TO CALLER
*              INITIALIZE FOR LOOP TO RESTORE ADCONS.
         LH    R0,RECORNUM         GET # ENTRIES IN RECORRAD
         LA    R1,RECORRAD         GET @ 1ST ENTRY IN RECORRAD
         USING RECORBLK,R1         NOTE DSECT POINTER
         DROP  R5                  ZAP NORMAL USING SO WE CAN USE R1
         SPACE 1
*              LOOP, RESTORING ADCONS FROM RECORRAD BACK TO VWXTABL.
REREALA  LH    R2,RECAXAD          GET ADCON OFFSET VALUE
         L     R15,RECADRE         GET ADCON FROM TABLE
         ST    R15,AX$BASE(R2)     STORE ADCON BACK IN ORIGINAL LOCAT
         LA    R1,REC$LEN(R1)      BUMP DSECT POINTER TO NEXT ONE
         BCT   R0,REREALA          LOOP ON # ENTRIES IN RECORRAD TABLE
         SPACE 1
         NI    REFLAGS,255-READMOD SHOW VWXTABL NOW IN UNMODIFIED STATE
         BR    R14                 RETURN TO CALLING SECTION
         DROP  R1                  KILL USING
         USING RECORBLK,R5         RESORE NORMAL USING FOR REST OF INSU
         EJECT
**--> INSUB: REREGS     FORMAT PARAMETER REGS AND PRINT THEM  + + + + +
*+       CONVERTS BLOCK OF 5 REGISTERS TO HEXADECIMAL, PLACES THEM    +
*+       IN LOCATIONS IN MESSAGE AREA REZAR05X, AND PRINTS MESSAGE.   +
*+       ENTRY CONDITIONS                                             +
*+  R7 = @ 5-WORD BLOCK OF REGISTERS TO BE PRINTED                    +
*+  R14= RETURN @ TO CALLING CODE                                     +
*+       EXIT CONDITIONS                                              +
*+  R7 = @ REZAR05X MESSAGE, WITH REGS FILLED IN, USED TO PRINT IT.   +
*+  R8 = LENGTH OF REZAR05X MESSAGE AREA, FOR PRINTING ALSO.          +
*+  R15  IS USED AS WORK REGISTER AND MODIFIED                        +
*+  + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
         SPACE 1
REREGSRA LA    R7,ECREGRA          @ 5 REGS IN ECONTROL BLOCK
         SPACE 1
REREGS   LA    R15,5               LOOP COUNTER = # REGS TO BE DONE
         LA    R8,REZ05XRG         INIT TO @ FIRST SLOT FOR HEX REG
         SPACE 1
REREGSA  UNPK  0(9,R8),0(5,R7)     UNPK 1 REGISTER VALUE, EXTRA BYTE
         TR    0(8,R8),AWTHEX3     TRANSLATE PROPERLY
         MVI   8(R8),C' '          ADD BLANK AFTERWARD
         LA    R7,4(R7)            ADVANCE REG PTR TO NEXT REGISTER
         LA    R8,8+8(R8)          ADVANCE HEX PTR TO NEXT SLOT
         BCT   R15,REREGSA         LOOP FOR 5 REGS TO BE DONE
         SPACE 1
         LA    R7,REZAR05X         SHOW @ MESSAGE AREA
         LA    R8,REZ05XL          SHOW LENGTH
         B     REXPRINT            BRANCH TO PRINT ROUTINE
         EJECT
**--> INSUB: REXCON3    CONVERT 3 BYTES OF REGISTER R7 TO HEX.  + + + +
*+       ENTRY CONDITIONS                                             +
*+  R7 = VALUE TO BE CONVERTED ( IN 3 LOW-ORDER BYTES )               +
*+  R8 = ADDRESS OF 7 BYTE AREA FOR FIELD TO BE PLACED (WITH TRL ' ') +
*+  RAT(R12)= ADDRESS OV VWXTABL CSECT, NEEDED FOR TRANSLATE TABL     +
*+  R14= RETURN @ TO CALLING SECTION IN REMONI                        +
*+       USES  DSECTS: AVWXTABL                                       +
*++ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
         SPACE 1
REXCON3  ST    R7,REXFWORK         SAVE THE WORD FOR UNPK
         UNPK  0(7,R8),REXFWORK+1(4)        UNPK WITH TRAILING ' '
         TR    0(6,R8),AWTHEX3     TRANSLATE TO PRINTABLE HEX
         BR    R14                 RETURN TO CALLER
         SPACE 4
**--> INSUB: REXPRINT   PRINT MESSAGE + + + + + + + + + + + + + + + + +
*+       PRINT MESSAGE AND FLAG REFLAGS WITH REFPRT TO SHOW PRINTED.  +
*+       ENTRY CONDITIONS                                             +
*+  R7 = ADDRESS OF MESSAGE TO BE PRINTED                             +
*+  R8 = LENGTH OF MESSAGE TO BE PRINTED                              +
*+  R14= RETURN ADDRESS TO CALLING SECTION OF REMONI                  +
*++ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
         SPACE 1
REXPRINT $PRNT 0(R7),(R8)          PRINT MESSAGE
         OI    REFLAGS,REFPRT      SHOW SOMETHING PRTED DURING REFAKE
         BR    R14                 RETURN TO CALLING CODE
         TITLE 'REMONI: INSUB RGENTS: PARAMETER REGISTER CHECKING'
**--> INSUB: RGENTS     CHECK USER VALUES IN PARAMETER REGISTERS+ + + +
*+       THIS CODE CHECKS THE VALUES RETUNRED IN USER REGISTERS RA-RE +
*+  AGAINST THE VALUES RETURNED BY THE REAL ASSIST ROUTINE.  THE      +
*+  BYTE FLAG RERGEFLG IS SET ACCORDINGLY, FOR ANY OF THE REGISTERS   +
*+  WHICH MAY HAVE INCORRECT VALUES.  NOTE THAT THE REGISTERS CAN'T   +
*+  JUST BE COMPARED DIRECTLY, SINCE SOME REGISTERS MAY BE IGNORED,   +
*+  DEPENDING ON THE CONTENTS OF OTHERS (FOR INSTANCE, IF RB HAS AN   +
*+  ERROR CODE, RA AND RC ARE INDETERMINATE FOR MANY ENTRIES.)        +
*+       ENTRY CONDITIONS                                             +
*+  R5 = @ RECORBLK ELEMENT FOR THE ENTRYPOINT CALLED.                +
*+  R6,R13 = FIRST AND SECOND BASE REGISTERS FOR REMONI(REFAKE).      +
*+  R10= @ ECONTROL BLOCK (WHICH CONTAINS USER RETURN REGS)           +
*+  R12(RAT) = @ AVWXTABL CONTROL BLOCK                               +
*+  R14= RETURN @ TO CALLING SECTION OF REMONI.                       +
*+  R15= OFFSET FROM RG$BASE TO CODE FOR CHECKING ENTRYPOINT CALLED.  +
*+             = 0 IF NO CHECKS ARE REQUIRED.                         +
*+       EXIT CONDITIONS                                              +
*+  R5,R6,R10,R11,R12,R13,R14,R15  ARE PRESERVED ACROSS THIS CODE.    +
*+  RERGEFLG   CONTAINS BITS SHOWING ERROR FLAGS, REGS RA-RE.         +
*+       NAMES: RG------                                              +
*+  + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
         SPACE 2
* * * * * * * * RGENTS  REGISTER ALLOCATION * * * * * * * * * * * * * *
*   R0 = WORK REGISTER                                                *
*   R1 = LINK REGISTER FOR INTERNAL SUBROUTINES (INTERNAL TO RGENTS)  *
*   R2,R3,R4 (RGRA,RGRB,RGRC) HAVE REAL ROUTINES RETURN VALUES.       *
*  R7,R8,R9 (RA,RB,RC) HAVE USER RETURN VALUES OF THESE REGS.         *
*              (NOTE MOST PROGS RETURN VALUES IN NOR MORE THAN THESE. *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
*              LOCAL REGISTER EQUATES FOR RGENTS.  THESE ARE USED FOR
*              EASE OF PROGRAMMING, AND MAY BE READ AS: RGRA:
*              REGISTER(GOOD) VALUE OF RA.
RGRA     EQU   R2                  GOOD VALUE OF RETURNED RA
RGRB     EQU   R3                  GOOD VALUE OF RETURNED RB
RGRC     EQU   R4                  GOOD VALUE OF RETURNED RC
         SPACE 1
*              ERROR EQUS USED IN USER-RETURN REGISTER CHECKING.
RGERE    EQU   B'00000001'         (RERGEFLG)- RE FOUND IN ERROR
RGERD    EQU   B'00000010'         (RERGEFLG)- RD FOUND IN ERROR
RGERC    EQU   B'00000100'         (RERGEFLG)- RC FOUND IN ERROR
RGERB    EQU   B'00001000'         (RERGEFLG)- RB FOUND IN ERROR
RGERA    EQU   B'00010000'         (RERGEFLG)- RA FOUND IN ERROR
RGE13    EQU   B'00100000'         (RERGEFLG)- R13 MODFIED
RGE12    EQU   B'01000000'         (RERGEFLG)- R12 MODIFIED
RGE06    EQU   B'10000000'         (RERGEFLG)- >=1 OF R0-R6 MODIFIED
         SPACE 1
RGENTS   EQU   *                   ENTRY FOR CHECKING CODE
         LM    RGRA,RGRC,REGSAVB   GET THE CORRECT VALUES RETURNED
         LM    RA,RC,ECREGRA       GET THE USER'S REGS
         B     RG$BASE(R15)        BRANCH TO CORRECT CODE
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              INDIVIDUAL ROUTINE REGISTER CHECKING CODE              *
*        THE OFFSET VALUES STORED IN RFSYMS WERE CALCULATED RELATIVE  *
*        TO LABEL RG$BASE, WITH AN OFFSET OF 0 MEANING THAT NO        *
*        REGISTER CHECKING IS REQUIRED.  THE ENTRY LABELS IN THIS     *
*        SECTION ARE ALL OF THE FORM  'RG' FOLLOWED BY THE NAME OF    *
*        THE DESIRED ENTRY POINT.  NOTE THAT MANY OF THEM ARE EQU'D   *
*        TOGETHER AND USE EXACTLY THE SAME CODE FOR CHECKING.         *
*              THE ENTRY LABELS ARE IN ORDER FIRST BY WHETHER THEY    *
*        MAY CALL OTHER MODULES OR NOT, AND THEN ALPHABETICALLY.      *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
RG$BASE  EQU   *                   BASE LABEL FOR OFFSETS
         BR    R14                 RETURN, NO CHECKING
         SPACE 2
RGBRUSIN EQU   RG$BASE             NO CHECKING
         SPACE 1
RGBRINIT EQU   RG$BASE             NO CHECKING
         SPACE 1
RGBRDROP EQU   *                   RB AND GRB BOTH =0 OR ^=0
         LTR   RGRB,RGRB           WAS REAL RETURN CODE 0
         BNZ   RGBR10              NO, BRANCH
         LTR   RB,RB               WAS USER RETURN CODE ALSO ZERO
         BCR   Z,R14               YES, NO MORE, QUIT
         B     RGRBERR             RGRB=0, RB^=08 ERROR
         SPACE 1
RGBRDISP EQU   *                   GRB=0==>RB=0 AND RA=GRA.
*                                  GRB^=0 ==> RB^=0
         LTR   RGRB,RGRB           WAS REAL RB =0
         BNZ   RGBR10              ^=0, GO CHECK USER RB
         LTR   RB,RB               RB MUST =0 ALSO
         BNZ   RGRBERR             IT DOESN'T, SO WORNG
         CR    RA,RGRA             RB=GRB=0, SO CHECK RA TOO
         BCR   E,R14               SAME, OK, RETURN
         B     RGRAERR             NO, ERRO, GO FLAG IT
RGBR10   LTR   RB,RB               WAS USER RB ALSO NOT ZERO
         BCR   NZ,R14              YES, OK, QUIT
         B     RGRBERR             NO, RGRB^=0, RB=0, ERROR
         SPACE 2
RGCBCON1 EQU   *                   GRB=$ERINVCN==> RB=$ERINVCN, RA OK
*                                  GRB=0 ==> RA=GRA, RC=GRC
         CR    RB,RGRB             ARE THEY SAME
         BNE   RGRBERR             NO, GO FLAG, DON'T DO MORE
         LTR   RGRB,RGRB           WAS CONSTNAT GOOD
         BZ    RGCB10              YES, GO CONTINUE CHECK
         BAL   R1,RGRAADDR         BAD CONSTANT, BUT CHECK SCAN PTR
         BR    R14                 IF RETURNED HERE, OK
RGCB10   CR    RC,RGRC             SAME VALUE OF RC
         BE    RGCB20              YES, SKIP, OK
         OI    RERGEFLG,RGERC      NO, ERROR, FLAG IT
RGCB20   CR    RA,RGRA             WAS RA SAME
         BNE   RGRAERR             NO, ERROR, GO FLAG IT
         BR    R14                 RETURN, OK
         EJECT
RGCBCON2 EQU   *                   RA=GRA. CODE AT @RC = CODE @GRC.
*                                  LENGTH-1 FOR CLC FROM ORIG. RB
         CR    RA,RGRA             MAKE SURE SAME SCAN PTR
         BE    *+8                 SKIP IF OK
         OI    RERGEFLG,RGERA      FLAG SCAN PTR ERR  7
         BAL   R1,RGRCADDR         MAKE SURE RC HAS OK @, SO DON'T 0C5
         L     RB,REGSAVA+4        GET ORIGINAL INPUT VALUE OF RB
         EX    RB,RGCBCLC          SUPPY LENGTH-1 TO THE CLC
         BCR   E,R14               SAME, SO OK, RETURN
         B     RGRCERR             BAD, GO FLAG IT
RGCBCLC  CLC   0($,RC),0(RGRC)     COMPARE VALUE, EX SUPPLIES LENGTH
         SPACE 2
RGCCCON1 EQU   RGCBCON1            SAME CODE AS ABOVE
         SPACE 1
RGCCCON2 EQU   RGCBCON2            SAME CODE AS ABOVE
         SPACE 2
RGCDECN1 EQU   *                   RB=GRB. GRB=0==> RA=GRA.
         LR    RC,RGRC             DUPLICATE VALUE SO CHECK OK
         B     RGCBCON1            BRANCH BACK TO USE SAME CODE
         SPACE 1
RGCDECN2 EQU   *                   RB=GRB. OTHERWISE, SAME AS CBCON2
         CR    RB,RGRB             WAS IT SAME
         BE    RGCBCON2            YES  SO GO CONTIUE CHECK
         B     RGRBERR             NO, GO FLAG AS ERROR
         SPACE 2
RGCFHCN1 EQU   RGCDECN1            SAME AS DE CONSTANTS
         SPACE 1
RGCFHCN2 EQU   RGCDECN2            SAME AS DE CONSTANTS
         SPACE 2
RGCPCON1 EQU   RGCBCON1            SAME AS ABOVE
         SPACE 1
RGCPCON2 EQU   RGCBCON2            SAME AS ABOVE
         SPACE 2
RGCXCON1 EQU   RGCBCON1            SAME CODE AS ABOVE
         SPACE 1
RGCXCON2 EQU   RGCBCON2            SAME CODE AS ABOVE
         SPACE 2
RGCZCON1 EQU   RGCBCON1            SAME CODE AS ABOVE
         SPACE 1
RGCZCON2 EQU   RGCBCON2            SAME CODE AS ABOVE
         EJECT
RGOPINIT EQU   RG$BASE             NO CHECKING REQUIRED
         SPACE 1
RGOPFIND EQU   *                   RA=GRA. RG=GRB. RGRB=0 ==> RC OK
         CR    RA,RGRA             IS IT OK
         BE    *+8                 YES, SKIP
         OI    RERGEFLG,RGERA      NO, FLAG RA ERROR
         CR    RB,RGRB             WAS RETURN CODE OK
         BNE   RGRBERR             NO, GO FLAG IT AND QUIT
         LTR   RGRB,RGRB           WSS RETURN CODE ZERO
         BCR   NZ,R14              NO, QUIT NOW, OK
         BAL   R1,RGRCADDR         MAKE SURE OPCODTB PTR IN LEGAL AREA
         S     RA,REGSAVA          GET LENGTH OF OPCODE
         BCTR  RA,0                GET LENGTH-1
         USING OPCODTB,RC          NOTE PTR THERE
         EX    RA,RGOPCLC          IS SYMBOL THE SAME
         BCR   E,R14               YES, OK RETURN
         B     RGRCERR             NO, GO FLAG ERROR
RGOPCLC  CLC   OPCMNEM($),OPCMNEM-OPCODTB(RGRC)       COMPARE OPCODES
         DROP  RC                  REMOVE OPCODTB USING
         BR    R14                 RETURN , OK
         SPACE 2
RGSDBCDX EQU   *                   RB=GRB. GRB=0 OR -4 ==> RA=GRA,RC=
         CR    RB,RGRB             SAME
         BNE   RGRBERR             NO, QUIT NOW, ERROR
         LTR   RGRB,RGRB           WAS RETURN CODE 0 OR -4
         BNP   RGCB10              YES, SO GO TO COMMON CHECKING CODE
         BAL   R1,RGRAADDR         CHECK SCAN PTR FOR LEGALITY
         BR    R14                 RETURN, OK
         SPACE 1
RGSDBTRM EQU   RGSDBCDX            SAME CODE
         SPACE 1
RGSDCTRM EQU   RGSDBCDX            SAME CODE AS ABOVE
         SPACE 1
RGSDDTRM EQU   RGSDBCDX            SAME CODE AS ABOVE
         SPACE 1
RGSDXTRM EQU   RGSDBCDX            SAME CODE AS ABOVE
         EJECT
RGSYINT1 EQU   RG$BASE             NO CHECKING
         SPACE 1
RGSYENT1 EQU   *                   RB=GRB. (RA==> SYMBOL)=(GRA=>SYM)
         CR    RB,RGRB             SAME OR NOT
         BE    RGSY10              YES, OK
         OI    RERGEFLG,RGERB      NO, ERROR
         B     RGSY10              GO CONTINUE CHECKING
         SPACE 1
RGSYFIND EQU   *                   RG=GRB. GRB=0 ==> SYMBOLS SAME
         CR    RB,RGRB             RETURN CODE SAME
         BNE   RGRBERR             NO, ERROR RIGHT OFF
         LTR   RGRB,RGRB           WAS SYMBOL IN TABLE(RGRB=4)
         BCR   NZ,R14              NO, SO DON'T LOOK, RETURN
RGSY10   C     RA,ECFADL           BEGIN CHECK FOR WITHIN USER PROG
         BL    RGRAERR             RA TOO LOW-ERROR
         C     RA,ECFADHC          COMPARE WITH HIGH CHECK LIMIT
         BH    RGRAERR             TOO HIGH-BRANCH-ERROR
         L     RB,REGSAVA+4        GET ORIGINAL LENGTH OF SYMBOL 1-8.
         BCTR  RB,0                OBTAIN LENGTH-1 FOR EXECUTE MVC
         USING SYMSECT,RA          NOTE SYMBOL TABLE DSECT
         EX    RB,RGSYCLC          COMPARE THE SYMBOLS
         BNE   RGRAERR             NOT SAME SYMBOL, ERROR
         BR    R14                 OK, RETURN
RGSYCLC  CLC   SYMBOL($),SYMBOL-SYMSECT(RGRA)         COMPARE SYMBOLS
         DROP  RA                  REMOVE SYMSECT USING
         SPACE 1
RGSYEND2 EQU   RG$BASE             NO CHECKING
         SPACE 2
         AIF   (&$REPL LT 2).RGNERE2 SKIP IF REPL ENTRIES MAY NOT CALL
*                                     ASSIST SUBROUTINES
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              CHECKING CODE - ENTRIES WHICH MAY CALL OTHERS.         *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 2
RGEVALUT EQU   *                   GRB^=0 ==> RB^=0. GRB=0 ==> RA=GRA.
*                                  GRB=0 ==> RC=GRC, RD=GRD, RE=GRE.
         LTR   RGRB,RGRB           WAS REAL RETURN CODE ZERO
         BZ    RGEV10              YES, SKIP
         LTR   RB,RB               WAS USER CODE NO TZERO
         BZ    RGRBERR             DIDN'T MATCH, ERROR BRANCH
         BAL   R1,RGRAADDR         ERROR IN EXP-GO CHECK FOR OK SCAN PT
         BR    R14                 RETURN, SCAN PTR OK
RGEV10   LTR   RB,RB               WAS FAKE USER RB ZERO ALSO
         BNZ   RGRBERR             NO, ERROR, QUIT
         LM    R0,R1,ECREGRA+12    GET USER REGS RD-RE
         C     R0,REGSAVB+12       COMPARE WITH REAL RD
         BE    *+8                 SKIP IF OK
         OI    RERGEFLG,RGERD      FLAG RD WRONG
         C     R1,REGSAVB+16       COMPARE WITH REAL RE RETURNED
         BE    RGCB10              OK, GO CONTINUE CHK FOR RC,RA
         OI    RERGEFLG,RGERE      FLAG RE IN ERROR
         B     RGCB10              GO TO CHECK RC,RA
.RGNERE2 ANOP
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              MISC. CHECKING AND EXIT CODE SECTIONS.                 *
*        THESE SECTIONS OF CODE CAN BE CALLED OR BRANCHED TO BY ANY   *
*        OF THE INDIVIDUAL SECTIONS ABOVE.                            *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 2
**--> INSUB: RGRAADDR   CHECK LEGITAMACY OF SCAN PTR RA + + + + + + + +
*+       ENTRY CONDITIONS                                             +
*+  R1 = RETURN @ OF CALLING PROGRAM CODE.                            +
*+  RA = VALUE OF SCAN POINTER TO BE CHECKED.                         +
*+  R14= RETURN @ TO BE TAKEN IF RA IS IN ERROR.                      +
*+       EXIT CONDITIONS                                              +
*+  RB,RC ARE DESTROYED.  MUST BE RELOADED IF CALLER NEEDS THEM.      +
*+  RERGEFLG IS MARKED WITH RGERA IF RA IS INCORRECT.                 +
*+  + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
RGRAADDR C     RA,REGSAVA          COMPARE TO ORIGINAL SCAN PTR
         BL    RGRAERR             ROUTINE BACKED UP SCAN PTR-ERROR
         LA    R0,200              MAXIMUM POSSIBLE DIF IN SCAN PTRS
         A     R0,REGSAVA          ADD ORIG RA TO MAX DIFFERENCE
         CR    RA,R0               CHECK GAINST THIS LIMIT
         BCR   L,R1                YES, OK, NO ERROR
         SPACE 1
*              EXIT POINT - FLAG RA IN ERROR, QUIT CHECKING.
RGRAERR  OI    RERGEFLG,RGERA      SHOW RA WRONG
         BR    R14                 RETURN, QUIT CHECKING
         SPACE 2
*              EXIT POINT - FLAG RB IN ERROR, QUIT CHECKING.
RGRBERR  OI    RERGEFLG,RGERB      FLAG RB IN ERROR
         BR    R14                 RETURN, NO MORE CHECKING
         SPACE 2
**--> INSUB: RGRCADDR   CHECK RC FOR @ INSIDE USER PROG.+ + + + + + + +
*+       ENTRY CONDITIONS                                             +
*+  R1 = RETURN @ TO CALLING CODE IN RGENTS                           +
*+  RC = VALUE TO BE CHECKED                                          +
*+  R14= RETURN @ TO BE TAKEN IF RC HAS INCORRECT VALUE.              +
*+  + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
RGRCADDR C     RC,ECFADL           MUST BE >= LOWER FAKE LIMIT
         BL    RGRCERR             IT WASNT, SO ERROR-BRANCH
         C     RC,ECFADHC          MUST BE <= HIGH LIMIT FOR CHECKING
         BCR   NH,R1               NOT HIGH, SO OK, RETURN TO CALLER
         SPACE 1
*              EXIT POINT - FLAG RC IN ERROR, QUIT CHECKING
RGRCERR  OI    RERGEFLG,RGRC       FLAG ERROR IN RC
         BR    R14                 RETURN TO REGULAR PROG. QUIT CHECK
         AIF   (&$REPL LT 2).RHNREP         SKIP IF NO REPL CALLS
         TITLE 'REMONI - RHENTS SECTION - CHECK CALLING VALUES'
**--> INSUB: RHENTS     CHECK PARM REGS PASSED TO CALLED PROGRAM+ + + +
*+       RHENTS IS CALLED ONLY WHEN A CALL TO A REAL ASSIST MODULE    +
*+  IS MADE BY A REPLACABLE MODULE PERMITTED TO CALL OTHERS.  ITS     +
*+  PURPOSE IS TO PROTECT ASSIST FROM ABENDS CAUSED BY IMPROPER VALUES+
*+  BEING PASSED TO REAL ASSIST ROUTINES, WHICH EXECUTE DIRECTLY.     +
*+       ENTRY CONDITIONS                                             +
*+  R14= RETURN @ TO CALLLING CODE IN MAIN SECTION OF REFAKE.         +
*+  R15= OFFSET @ FROM RH$BASE TO INDIVIDUAL CODE CHECKING SECTION.   +
*+  RERGEFLG   BITS FOR RGERA-RGERE   ARE ZEROED.                     +
*+       EXIT CONDITIONS                                              +
*+  R0,R1,RA,RB,RC      MAY BE MODIFED.                               +
*+  R4-R6,R10-R15  ARE PRESERVED ACROSS CALLS TO RHENTS.              +
*+  RERGEFLG  BITS ARE SET AS NEEDED.                                 +
*+       NAMES: RH------                                              +
*+  + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
         SPACE 1
* * * * * * * * RHENTS REGISTER ALLOCATION  * * * * * * * * * * * * * *
*   R0 = WORK REGISTER                                                *
*   R1 = INTERNAL LINK REGISTER FOR CHECKING ROUTINES.                *
*   R2,R3      UNUSED AT PRESENT, MAY BE USED IF REQUIRED IN FUTURE.  *
*   RA,RB,RC   HOLD VALUES OF CORRESPONDING USER REGISTERS.           *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
RHENTS   EQU   *
         LM    RA,RC,ECREGRA       GET PARM REGS, MOST USUAL ONES
         B     RH$BASE(R15)        BRANCH TO RIGHT SECTION OF CODE
         SPACE 1
RH$BASE  EQU   *                   BASE LABEL FOR CALL CHECKING SECTS
         BR    R14                 IF COMES HERE, NO CHECKING
         SPACE 2
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              INDIVIDUAL ROUTINE REGISTER CHECKING CODE SECTIONS     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 2
RHSDBCDX EQU   *                   RA IN MACHINE REASONABLY
         BAL   R1,RHRAADDR         CALL CHECKING ROUTINE
         BR    R14                 RETURN
         SPACE 1
RHSDBTRM EQU   RHSDBCDX            SAME CODE
RHSDCTRM EQU   RHSDBCDX            SAME CODE
RHSDDTRM EQU   RHSDBCDX            SAME CODE
RHSDXTRM EQU   RHSDBCDX            SAME CODE
         SPACE 2
RHSYFIND EQU   *                   RA REASONBALE, 1<= RB <= 7
         BAL   R1,RHRAADDR         CHECK RA FOR REAONABLENESS
         C     RB,AWF1             TEST
         LTR   RB,RB               WAS RB<=0
         BNP   RHRBERR             YES, ILLEGAL-BRANCH
         C     RB,AWF7             WAS IT TOO BIG
         BCR   NH,R14              NO,OK,RETURN
RHRBERR  OI    RERGEFLG,RGERB      RB IN ERROR
         BR    R14                 RETURN
         EJECT
*              RHENTS INTERNAL SUBROUTINES                            *
         SPACE 2
**--> INSUB: RHRAADDR   CHECK RA FOR REASONABLE @ + + + + + + + + + + +
*+       ENTRY CONDITIONS                                             +
*+  R1 = RETURN @ TO CALLING CODE                                     +
*+  RA = VALUE TO BE CHECKED FOR LEGALITY.                            +
*+  + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
         SPACE 1
RHRAADDR EQU   *
*              CHECK FOR @ IN USER PROGRAM.
         C     RA,ECFADL           LOWER LIMIT OF USER
         BL    RHRA2               NO, NOT IN USER PROG
         C     RA,ECFADHC          HIGH CHECKING LIMIT
         BCR   NH,R1               INSIDE USER, OK, RETURN
         SPACE 1
*              CHECK FOR IN AVWXTABL
RHRA2    EQU   *
         CR    RA,RAT              LOWER TAHN PTR
         BL    RHRA3               YES, NOT THERE EIEHRE
         LA    R0,AVWXEND-8        HIGHEST @ IN TABLE
         CR    RA,R0               COMPARE TO UPPER LIMIT POSSIBLE
         BCR   NH,R1               IN THERE, OK RETURN
         SPACE 1
*              CHECK FOR @ IN DYNAMIC AREA.
RHRA3    EQU   *
         C     RA,AJOTADL          LOWER THAN LOWEST
         BL    RHRA4               YES
         C     RA,AJOTADH          HIGHER THAN HIGHEST
         BCR   NH,R1               NO, SO OK, RETURN
         SPACE 1
RHRA4    EQU   *
RHRAERR  OI    RERGEFLG,RGERA      FLAG RA WORNG
         BR    R1                  RETURN TO CALLER
.RHNREP  ANOP
         LTORG
         DROP  R5,R10,R11,RAT,R13  REMOVE ALL USINGS
         TITLE 'RFSYMS - REPLACE TABLE CSECT - CSECT,ENTRY NAMES'
         PRINT GEN
**--> CSECT: RFSYSMS    TABLE OF CSECT-ENTRY NAMES-REPLACE  . . . . . .
*.             RFYSMS (SECT.1) HAS AN ELEMENT FOR EACH CSECT WHICH CAN.
*.       BE DYNAMMICALLY REPLACED BY A USER-WRITTEN ROUTINE. EACH     .
*.       ELEMENT CONTAINS THE NAME OF THE CSECT, THE NUMBER OF        .
*.       ENTRY POINTS IN IT, AND A LIST OF ENTRY POINT NAMES AND      .
*.       OFFSETS TO THEIR ADCONS IN AVWXTABL, SO THEY CAN BE CHANGED. .
*.             THE 2ND SECTION IS PRESENT IF &$REPL=2.  IT LISTS ALL  .
*.       ENTRYPOINTS WHICH CAN BE CALLED FROMA USER PROGRAM, WITH     .
*.       OFFSET @ PTRS TO THEIR ADCONS IN AVWXTABL, AND TO CODE IN    .
*.       SECTION RHENTS OF REMONI.  THIS CODE IS USED TO CHECK THE    .
*.       REGISTERS PASSED BY THE USER TO THE CALLED PROGRAM.          .
*.             THE 3RD SECTION IS ALSO PRESENT ONLY IF &$REPL=2. IT   .
*.       HAS LABELS OF THE FORM RI&CSECT, WITH &CSECT BEING ONE WHICH .
*.       NOT ONLY CAN BE REPLACED, BUT CAN ALSO CALL OTHER ROUTINES.  .
*.       EACH ELEMNT CONTAINS A HALFWORD WITH THE NUMBER OF DIFFERENT .
*.       SUBROUTINE ENTRIES WHICH THIS CSECT IS PERMITTED TO CALL,    .
*.       FOLOWED BY THAT # OFFSET VALUES TO THE ELEMENTS IN THE 2ND   .
*.       SECTION OF THOSE ENTRIES IT CAN CALL.  REMONI OBTAINS AN     .
*.       OFFSET FROM RFSYMS TO RI&CSECT FROM THE RFSYMBLK BELONGING   .
*.       TO THAT CSECT.  NOTE, IF A CSECT CAN CALL NO OTHER, THE      .
*.       VALUE SAVED IS = 0.                                          .
*.       NAMES: RF------                                              .
*.       NAMES: RI------           (IN SECTION 3, IF &$REPL=2)
*.       DSECT RFSYMBLK IS USED TO DESCRIBE EACH ENTRY IN SECTS.1&2.  .
*.       USES MACROS: $AL2,RFSGN                                      .
*.  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         SPACE 1
RFSYMS   CSECT
*        **NOTE** COMMENTED ENTRIES ARE NOT CURRENTLY AVAILABLE.
         RFSGN BROPS2,(BRINIT,BRUSIN,BRDROP,BRDISP)
*        RFSGN CACONS,(CACON1,CACON2),TYPE=1
         RFSGN CBCONS,(CBCON1,CBCON2)
         RFSGN CCCONS,(CCCON1,CCCON2)
         RFSGN CDECNS,(CDECN1,CDECN2)
         RFSGN CFHCNS,(CFHCN1,CFHCN2)
*        RFSGN CODTL1,CODTL1,TYPE=1
         RFSGN CPCONS,(CPCON1,CPCON2)
*        RFSGN CVCONS,(CVCON1,CVCON2),TYPE=1
         RFSGN CXCONS,(CXCON1,CXCON2)
         RFSGN CZCONS,(CZCON1,CZCON2)
         RFSGN EVALUT,EVALUT,TYPE=1
         RFSGN OPCOD1,(OPINIT,OPFIND)
*        RFSGN SCANRS,(SCANBL,SCANCO,SCANEQ),TYPE=1
         RFSGN SDTERM,(SDBCDX,SDBTRM,SDCTRM,SDDTRM,SDXTRM)
         RFSGN SYMOPS,(SYINT1,SYENT1,SYFIND,SYEND2)
RFSYMS$L EQU   *-RFSYMS            LENGTH OF SEARCH IN RFSYMS CSECT
         SPACE 1
         AIF   (&$REPL LT 2).RENREPA        SKIP IF NO SECTS 2 & 3
         SPACE 2
*              SECTION 2 - CALLABLE ENTRY POINT INFORMATION.
RFSCALLA DS    0H                  BEGINNING OF LIST
         RFSGN SDBCDX,TYPE=2
         RFSGN SDBTRM,TYPE=2
         RFSGN SDCTRM,TYPE=2
         RFSGN SDDTRM,TYPE=2
         RFSGN SDXTRM,TYPE=2
         RFSGN SYFIND,TYPE=2
RFSCALLZ EQU   *-RFS$LEN           END @ - LENGTH FOR BXLE LIMIT
         SPACE 2
*              SECTION 3 - OFFSETS TO CALLABLES FROM EACH REPLACABLE.
*              ALTHOUGH EVALUT IS ONLY ONE NOW, OTHERS COULD BE ADDED.
         SPACE 1
RIEVALUT DC    H'6'                EVALUT CAN CALL 6 ENTRIES IF IT WANT
         $AL2  RFSYMS,(RFSDBCDX,RFSDBTRM,RFSDCTRM,RFSDDTRM,RFSDXTRM,RFS#
               YFIND)              OFFSETS TO SECTION 2 BLOCKS ABOVE
         SPACE 2
         PRINT NOGEN               TURN OFF GENERATION IN REST  CPP
.RENREPA ANOP
.RENREPL ANOP
         TITLE  '***  EQU''S FOR MACRO ROUTINES '
         AIF   (NOT &$MACROS).MAXXXX   SKIP MACROS                    J
*   FOLLOWING EQU'S HANDLE ERROR MESSAGES IN MEXPND NOT TAKEN CAREOF
*     BY ERRTAG
$ER#ACTR EQU   2                   ACTR EXCEEDED                      S
$ER#DMER EQU   4                   SET SYMBOL SUBSCRIPT               S
$ER#SBST EQU   6                   SUBSTRING EXPRESSION               S
$ER#CVCA EQU   8                   CHAR TO ARITH CONV ERR             S
$ER#CVAB EQU   10                  ARITH TO BOOL CONV ERR             S
$ER#CVCB EQU   12                  CHAR TO BOOL CONV ERR              S
$ER#ATER EQU   14                  ATTRIBUTE USE ERR                  S
$ER#SYSL EQU   16                  &SYSLIST ERR                       S
$ER#SYER EQU   18                  SYSTEM ERR                         S
$ER#EXBF EQU   20                  CHAR BUFFER EXCEEDED               S
$ER#MXST EQU   22                  MAX # OF STMTS EXCEEDED            S
$ER#ZDIV EQU   24                  FIXED PT OVERFLOW OR ZERO DIVIDE   S
$ER#PRVR EQU   26                                                     A
         SPACE 2
*   FOLLOWING FLAGS SET IN AVMSNBY1 WILL TURN ON RESPECTIVE SNAPS
$MSNP01  EQU   X'80'               MACINT SNAP FLAG
$MSNP02  EQU   X'40'               MACRO1 SNAP FLAG
$MSNP03  EQU   X'20'               MACSCN SNAP FLAG
$MSNP04  EQU   X'10'               MCSCOP SNAP FLAG
$MSNP05  EQU   X'08'               MACFND,MCVSCN SNAP FLAG
$MSNP06  EQU   X'04'          MCSYSR, DECTRM, MCGTST, ATTERM SNAP FLAG
$MSNP07  EQU   X'02'               MCBODY SNAP FLAG
$MSNP08  EQU   X'01'               BSU'S SNAP FLAG
         SPACE
*   FOLLOWING FLAGS SET IN AVMSNBY2 WILL TURN ON RESPECTIVE SNAPS
$MSNP09  EQU   X'80'               MACLEX SNAP FLAG
$MSNP10  EQU   X'40'               MCGNCD SNAP FLAG - ONE OPS
$MSNP11  EQU   X'20'               MEXPND SNAP - INIT AND INTERPRET
$MSNP12  EQU   X'10'               MEXPND SNAP - INTERNAL ROUTINES
$MSNP13  EQU   X'08'               MXERRM, MXMVSR SNAP CONTROL
$MSNP14  EQU   X'04'               SET MEXPND ENTER EXIT SNAPS
         SPACE
$MINDEF  EQU   X'80'               AVMBYTE1 - IN MACRO DEFINITION
$MINEXP  EQU   X'40'               AVMBYTE1 - IN MACRO EXPANSION
$MGBLFLG EQU   X'80'               MCLBFLG2 - GLOBALS NO LONGER OK    S
$MLCLFLG EQU   X'40'+$MGBLFLG      MCLBFLG2 - LOCALS NO LONGER OK     S
$MACTFLG EQU   X'20'+$MLCLFLG      MCLBFLG2 - ACTR NO LONGER OK       S
$MCOCFL1 EQU   B'00000001'         (MCLBFLG2) - OPEN CODE - DECLARE   S#
                                   TYPES ALLOWED                      S
$MCOCFL2 EQU   B'00000011'         (MCLBFLG2) - OPEN CODE - DECLARE   S#
                                   TYPES NOT ALLOWED                  S
$MC1DCL  EQU   B'10000000'         DECLARE TYPE                       S
$MC1ERR  EQU   B'01000000'         ORDER ERROR                        S
$MC1SKIP EQU   B'00100000'         DON'T CALL MXINST                  S
$MC1RET  EQU   B'00010000'         RETURN AFTER MXINST                S
$MSBLIST EQU   X'04'               AVMBYTE1 - PROCESSING OPERAND SUBLST
$MINQUOT EQU   X'02'               AVMBYTE1 - INSIDE QUOTED STRING
$MKEYOPR EQU   X'01'               KEYWORD OPRND PROCESSSED, POSIT NOGO
         SPACE 1
$MOPRTR  EQU   X'80'               AVMBYTE2 - PREV SYMBOL = OPRTR
$MTERM   EQU   X'40'               AVMBYTE2 - PREV SYMBOL = TERM
$MINARIT EQU   X'20'               AVMBYTE2 - IN ARITHMETIC EXPRESSION
$MINBOOL EQU   X'10'               AVMBYTE2 - IN BOOLEAN EXPRESSION
$MINCHAR EQU   X'08'               AVMBYTE2 - IN CHARACTER EXPRESSION
$MDIMVAR EQU   X'04'               AVMBYTE2 - PREV SYMBOL = DIMEN SYMB
$MINAPAR EQU   X'02'               AVMBYTE2 - IN ARITH SUBSCR EXPRESS
$MINPEXP EQU   X'01'               AVMBYTE2 - DO EXPRES IN PARENS ONLY
         SPACE 1
$MRPARST EQU   X'80'               AVMBYTE4 - RIGHT PAREN IN INPUT
$MINSTRN EQU   X'40'               AVMBYTE4 - PROC VAR SYMB IN STRING
$MCOMST  EQU   X'20'               AVMBYTE4 - COMMA IN BSU INPUT STRM
$MGENSTP EQU   X'10'               AVMBYTE4 - STOP MACRO GENERATION
$MXJMPFL EQU   X'08'               AVMBYTE4 - AGO OR SUCCESSFUL AIF SWT
$MSTOPEX EQU   X'04'               AVMBYTE4 - DON'T EXPAND CRRNT MACRO
         SPACE 2
$GLOBAL  EQU   4
$LOCAL   EQU   8
$SYMPAR  EQU   12
$SYSVAR  EQU   16                  SYSTEM VARIABLE INDEX
         SPACE 2
$LCHWRK  EQU   1024
$LSUBENT EQU   12                  LENGTH OF SUB-OPERAND ENTRY
$LMSRCMX EQU   (RSOL1+2*RSOLC)-1   MAXIMUM LENGTH-1 OF GEN'D STMT
         SPACE 2
$BSAR    EQU   X'20'               MCBSFLGS, ARITHMETIC TYPE
$BSBOOL  EQU   X'10'               MCBSFLGS, BOOLEAN TYPE
$BSCHAR  EQU   X'08'               MCBSFLGS, CHARACTER TYPE
         SPACE 2
*  EQUATES FOR INDEX VALUES FOR OPERATOR BSU'S
$BSPLUS  EQU   2
$BSMIN   EQU   4
$BSMULT  EQU   6
$BSDIV   EQU   8
$BSOR    EQU   10
$BSAND   EQU   12
$BSNOT   EQU   14
$BSNE    EQU   16
$BSGE    EQU   18
$BSLE    EQU   20
$BSLT    EQU   22
$BSEQ    EQU   24
$BSGT    EQU   26
$BSCAT   EQU   28
$BSAGO   EQU   30
$BSAIF   EQU   32
$BSETA   EQU   34
$BSETB   EQU   36
$BSETC   EQU   38
$BSRPAR  EQU   40
$BSLPAR  EQU   42
$BSBSCRP EQU   44
$BSBSTR  EQU   46
$BSBSYL  EQU   48
$BSCOMMA EQU   50                  HIERARCHY = ZERO
$BSPRINT EQU   52                  HIERARCHY = 2
$BSMEXIT EQU   54                  HIERARCHY = 2
$BSMEND  EQU   56                  HIERARCHY = 2
$BSANOP  EQU   58                  HIERARCHY = 2
$BSERR01 EQU   60                  HIERARCHY = 2
$BSINMAC EQU   62                  SET INNER MACRO CALL CODE HIER = 2
$BSMVSTM EQU   64                  BSU INDEX FOR MOVE STMT
$BSMNTER EQU   X'80'               FLAG TO FORCE ERR MSSGE ON MNOTE
$BSRLCHR EQU   X'80'               FLAG FOR CHAR TYPE RELATIONAL OPRTR
$MPRCOM  EQU   1                   (MCBSFLGS)=> SPECIAL PRINT         A
         SPACE 2
*   EQUATES FOR OPERATOR HIERARCHIES
$MCOMMHR EQU   0
$MPARHR  EQU   0
$MPRNTHR EQU   2
$MSETHR  EQU   2
$MORHR   EQU   4
$MANDHR  EQU   6
$MRELHR  EQU   8
$MCATHR  EQU   10
$MPLUSHR EQU   12
$MMULTHR EQU   14
$MNOTHR  EQU   16
$MAGOHR  EQU   16
$MAIFHR  EQU   16
         SPACE 2
*  EQUATES FOR TERM BSU INDEXES
$BSTSYAG EQU   2                   GLOBAL ARITH SET SYMBOL
$BSTSYBG EQU   4                   GLOBAL BOOLEAN SET SYMBOL
$BSTSYCG EQU   6                   GLOBAL CHAR SET SYMBOL
$BSTSYAL EQU   8                   LOCAL ARITH SET SYMBOL
$BSTSYBL EQU   10                  LOCAL BOOL SET SYMBOL
$BSTSYCL EQU   12                  LOCAL CHAR SET SYMBOL
$BSYMPAR EQU   14                  SYMBOLIC PARAMETER
$BSIMMA  EQU   16                  ARITH IMMEDIATE BALUE
$BSIMMB  EQU   18                  BOOLEAN IMMEDIATE VALUE
$BSTRING EQU   20                  STRING VALUE
$BSYSNDX EQU   22                  &SYSNDX SYSTEM VARIABLE
$BSYSLST EQU   24                  &SYSLIST SYSTEM VARIABLE
$BSYSECT EQU   26                  &SYSECT SYSTEM VARIABLE
$BSLABEL EQU   28
$BSTEMP  EQU   30
$BSATI   EQU   34                  BSU NBR FOR I' ATTRIBUTE
$BSATK   EQU   36                  BSU NBR FOR K' ATTRIBUTE
$BSATL   EQU   38                  BSU NBR FRR L' ATTRIBUTE
$BSATN   EQU   40                  BSU NBR FOR N' ATTRIBUTE
$BSATS   EQU   42                  BSU NBR FOR S' ATTRIBUTE
$BSATT   EQU   44                  BSU NBR FOR T' ATTRIBUTE
$BSADDRA EQU   46                  BSU NBR FOR ARITH TYPE @
$BSADDRB EQU   48                  BSU NBR FOR BOOL @
$BSADDRC EQU   50                  BSU NBR FOR CHAR TYPE @
         SPACE 2
*  EQUATES FOR VARIOUS LEFT PAREN TYPES
$MINLPAR EQU   X'80'               ARITH LEFT PAREN
$MINSBST EQU   X'40'               SUBSTRING LEFT PAREN
$MINSBSC EQU   X'20'               SUBSCRIPT LEFT PAREN
$MINSYSL EQU   X'10'               &SYSLIST LEFT PAREN
         TITLE '*** DSECTS FOR MACRO CAPABILITY IN ASSIST***'
**-->  DSECT: MCGLBDCT    FORMAT FOR GLOBAL DICTIONARY ENTRY          *
*.                                                                    *
*.*********************************************************************
         SPACE
MCGLBDCT DSECT
MCGLBNXT DS    F                   LINK TO NEXT GLOBAL ENTRY
MCGLBLEN DS    C                   LENGTH OF GLOBAL NAME
MCGLBNAM DS    CL8                 GLOBAL DICT ENTRY NAME
MCGLBTYP DS    C                   ENTRY TYPE, ARITH, BOOL OR CHAR
MCGLBDIM DS    H                   DIMENSION OF SET VARIABLE
MGLCLPNT DS    0F                  POINTER OFFSET FOR LOCAL VALUE
MCGLBDEF DS    F                   COUNT # OF MACRO DEFINITION
$LGLBENT EQU   *-MCGLBDCT          LEN OF GLOBAL DICT ENTRY STND PART
MCGBAVAL DS    0F                  GLOBAL ARITH VALUE
MCGBBVAL DS    0F                  GLOBAL BOOL VALUE
MCGBCLEN DS    F                   GOBAL CHAR VALUE LENGTH
MCGBCVAL DS    CL8                 GLOBAL CHAR VALUE
         EJECT
**--> DSECT:  MCLCLDPV   FORMAT FOR LOCAL DICTIONARY DOPE VECTOR      *
*.                                                                    *
*.*********************************************************************
         SPACE
MCLCLDPV DSECT
MCLOCNXT DS    F                   POINTER TO NEXT ENTRY
MCLCLLEN DS    C                   LOCAL ENTRY NAME LENGTH
MCLCLNAM DS    CL8                 LOCAL ENTRY NAME
MCLCLTYP DS    C                   TYPE, IE ARITH, BOOL OR CHAR
MCLCLDIM DS    H                   DIMENSION OF LOCAL ENTRY
MCLCLPNT DS    F                   OFFSET POINTER FOR VALUE
$LLCLDV  EQU   *-MCLCLDPV          LEN OF LOCAL DICT D.V.
         SPACE 2
**--> DSECT: MCPARENT   FORMAT FOR SYMBOLIC PARAMETER ENTRY           *
*.                                                                    *
*.*********************************************************************
         SPACE
MCPARENT DSECT
MCPARNXT DS    F                   POINTER TO NEXT ENTRY
*              NOTE: NEXT 3 ENTRIES MUST BE IN ORDER GIVEN.  JRM.     J
MCPARNLN DS    C                   PARAM ENTRY NAME LENGTH
MCPARNAM DS    CL8                 SYMBOLIC PARAM NAME
MCPARTYP DS    C                   PARAMETER TYPE, POSIT OR KEYWORD
MCPARNTL EQU   *-MCPARNLN          LENGTH MOVED TOGETHER              J
MCPARNDX DS    H                   PARAMETER POSITION IN LIST
MCPROPLN DS    C                   LENGTH OF OPERAND
MCPRATYP DS    C                   ATTRIBUTE TYPE, IE 'N', 'O'
MCPARNB  DS    C                   UNUSED AT PRESENT                  J
MCPARFIL DS    C                   UNUSED AT MOMENT                 JRM
MCPROPRN DS    F                   OPERAND STANDARD VALUE POINTER
$LPARENT EQU   *-MCPARENT          LEN OF SYM PARAM ENTRY
         SPACE 2
**-->  DSECT:  MCBSU   FORMAT OF BASIC SYNTACTIC UNIT                 *
*.                                                                    *
*.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE
MCBSU    DSECT
MCBSFLGS DS    C                   INDICATES OPRTR, TERM ETC
MCBSINDX DS    C                   BSU INDEX OF SYMBOL
MCBSOFST DS    C                   SYMBOL OFFSET RELATIVE TO SOURCE
MCBSTRLN DS    0C                  STRING LENGTH
MCBSHIER DS    C                   HIERARCHY OF OPERATOR, IF OPRTR
MCBSVALU DS    0F                  ARITH OR BOOL IMMEDIATE VALUE
MCBSLOC  DS    F                   LOCATION OF TERM VALUE
$LMCBSU  EQU   *-MCBSU            LENGTH OF BSU ENTRY
         SPACE 2
**-->  DSECT:  MCSEQ   FORMAT OF SEQUENCE SYMBOL ENTRY                *
*.                                                                    *
*.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE
MCSEQ    DSECT
MCSEQNXT DS    F                   POINTER TO NEXT ENTRY
MCSEQNLN DS    C                   LENGTH OF NAME
MCSEQNAM DS    CL8                 NAME OF SEQ SYMBOL
MCSEQFLG DS    C                   ENTRY FLAG BYTE
MCSEQDUM DS    H                   UNUSED
MCSEQVAL DS    F                   POINTER TO SEQ SYMBOL LOCATION     *
$LMCSEQ  EQU   *-MCSEQ             LENGTH OF SEQ SYMBOL ENTRY
         SPACE 2
**-->  DSECT:  MCOPQUAD  FORMAT OF ONE OP ENTRY.  MACRO DEFINITIONS   *
*.        ARE TRANSLATED INTO ONE OPS FOR SUBSEQUENT INTERPRETATION   *
*.                                                                    *
*.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE
MCOPQUAD DSECT
*        EACH STATEMENT BEGINS WITH A PARTIAL ONE OP GIVEN FIRST,     A
*        FOLLOWED BY 0 OR MORE NORMAL-SIZE ONE-OPS                    A
MCQUDNXT DS    A                   ADDRESS OF NEXT STMT'S CODE        A
MCQSTMNO DS    PL3                 STATEMENT NUMBER                   A
MCQS1FLG DS    C                   FLAGE BYTE OR UNUSED               A
$LMCOPL1 EQU   *-MCOPQUAD          LENGTH OF 1ST ONE-OP IN STMY       A
         SPACE 1                                                      A
*        FORMAT OF NORMAL ONE-OPS IN STATEMENT FOLLOWS                A
         ORG   MCOPQUAD            BACK TO BEGINNING                  A
MCBOPRTR DS    C                   OP CODE
MCARG1DX DS    C                   ARG #1 BSU INDEX
MCARG2DX DS    C                   ARG #2 BSU INDEX
MCRSLTYP DS    C                   RESULT TYPE
MCARG1LC DS    F                   ARG #1 LOCATION
MCARG2LC DS    A                   ADDRESS OF ARGUMENT #1             A
MCRESULT DS    F                   RESULT
$LMCQUAD EQU   *-MCOPQUAD          LENGHT OF ONE-OP
         SPACE 2
**-->  DSECT:  MCBSTRMS   FORMAT OF TWO BSU'S FOR EASE                *
*.        OF MANIPULATION IN TERM STACK                               *
*.                                                                    *
*.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE
MCBSTRMS DSECT
MCBSFLG1 DS    C                   TERM #1 FLAG BYTE
MCBSNDX1 DS    C                   TERM #1 BSU INDEX
MCBOFST1 DS    C                   TERM #1 OFFSET
MCBLN1   DS    C                   TERM #1 LENGTH
MCBSLOC1 DS    F                   TERM #1 LOCATION OR VALUE
MCBSFLG2 DS    C                   TERM#2 FLAG BYTE
MCBSNDX2 DS    C                   TERM #2 BSU INDEX
MCBOFST2 DS    C                   TERM #2 OFFSET
MCBLN2   DS    C                   TERM #2 LENGTH
MCBSLOC2 DS    F                   TERM #2 LOCATION OR VALUE
         SPACE 2
*.-->  DSECT:  MCBOPRST    FORMAT OF OPERATOR STACK ENTRY             *
*.                                                                    *
*.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
MCBOPRST DSECT
MCBOPFL  DS    C                   OPERATOR FLAGS
MCBSOPST DS    C                   OPERATOR BSU INDEX
MCBOPOF  DS    C                   OFFSET
MCBOPHR  DS    C                   OPRTR HIERARCHY
MCBOPVAL DS    F                   NOT USED
         SPACE 2
**--> DSECT: MXPNTSAV       CONTROL FOR LEVEL OF MACRO EXPANSION * *  S
*.       ONE IS ALLOCATED FOR EACH LEVEL OF MACRO CALL                A
*.       NAMES:MXP_____                                               A
*.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE
MXPNTSAV DSECT
MXPNLINK DS    A                   @ LAST PREVIOUS MXPNTSAV           A
MXPLSYPT DS    F                   PNTR TO SYM PARAM D.V.'S
MXPSYSDX DS    PL3                 CURRENT SYSNDX VALUE
MXPNFLG1 DS    C                   FLAG BYTE
MXPCHRBF DS    F                   PNTR TO CHAR BUFFER FOR CATEN OPRTNS
MXPNMCLB DS    F                   PNTR TO MAC LIB ENTRY
MXPNKYPT DS    F                   PNTR TO 1ST KEYWORD SYM PAR DV
MXPNKLPT DS    F                   PNTR TO 1ST KEYWORD DICT ENTRY
MXPNLDBS DS    F                   PNTR TO SET SYMB LOCAL DICT
MXPNCDPT DS    F                   PNTR TO 1ST INSTRUCTION
MXPNCRCD DS    F                   PNTR TO CURRENT INST
MXPNBOPS DS    F                   NBR OF POSITIONAL OPRNDS
MXPNLSPT DS    F                   PNTR TO SYM PAR DICT ENTRIES
$LMXPTSV EQU *-MXPNTSAV            LEN OF DYNAMIC WORK AREA IN MEXPND
         SPACE 2
**-->  DSECT:  MCPAROPR  FORMAT FOR SYMBOLIC PARAMETER DICTIONARY     *
*.        ENTRY.  ONE ENTRY FOR EACH SYM PARAM ON ENTRY TO MEXPND     *
*.                                                                    *
*.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE
MCPAROPR DSECT
MCPAROFL DS    C                   OPRNDS FLAGS
MCPAROLN DS    C                   OPRND LENGTH, IE K'
MCPARONB DS    C                   # OF SUBOPRNDS IE N'
MCPAROTP DS    C                   OPRND TYPE, IE N, O OR U
MCPAROPT DS    F                   POINTER TO OPRND
MCPRSBPT DS    F                   POINTER TO LSUB OPRND LIST
$LMPAROP EQU   *-MCPAROPR          LEN OF SYM PAR DICT ENTRY
         SPACE 2
**-->  DSECT:  MCPARSUB   FORMAT FOR DICT ENTRY FOR SUBLIST OPRNDS    *
*.        ONE ENTRY FOR EACH ELEMENT OF SUBLIST OF SYM PARAM ENTRY    *
*.                                                                    *
*.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE
MCPARSUB DSECT
MCPARSFL DS    C                   SUBOPRND FLAGS
MCPARSNU DS    C                   NOT USED
MCPARSTP DS    C                   SUB OPRND TYPE
MCPARSLN DS    C                   SUB OPRND LENGTH
MCPARSPT DS    F                   PNTR TO SUB OPRND
$LMPARSB EQU   *-MCPARSUB          LEN OF SUBLIST OPRND ENTRY
         AIF   (NOT &$DEBUG).MACDBG          SKIP IF DEBUG
         XSET  XSNAP=OFF           KILL REMAINING XSANPS
.MACDBG  ANOP
         PRINT ON,NOGEN
         TITLE '*** MACINT - MACRO INITIALIZATION ROUTINE'            S
**--> CSECT:  MACINT    THIS ROUTINE IS CALLED IN INITIALIZATION      *
*.       PHASE OF ASSIST.  IT PERFORMS CERTAIN REQUIRED STORAGE       *
*.       ALLOCATION AND SETS POINTERS AVGEN1CD AND AVGEN2CD.          *
*.       OVERFLOW MESSAGE FOR GENERAL USE IS ALSO CREATED.            *
*.                                 G.M.CAMPBELL - SUMMER - 1972       *
*.                                                                    *
*.       USES MACROS:  $ALLOCL, $SAVE, $RETURN, $CALL                 *
*.        USES DSECTS: AVWXTABL                                       *
*.                                                                    *
*.       REGISTER USAGE:                                              S
*.             WORK REGS:  RA,RB                                      S
*.                                                                    *
*.*********************************************************************
         SPACE
MACINT   CSECT
         $DBG  ,NO
          $SAVE                    SA=NO
         USING AVWXTABL,RAT        NOTE MAIN TABLE USING
         MVI   AVMSNBY1,X'FF'      TURN OFF SNAPS                     S
         MVI   AVMSNBY2,X'FF'      TURN OFF SNAPS                     S
         AIF   (&$DEBUG).MACINT1   SKIP IF  IF NOT DEBUG
         MVI   AVMSNBY1,X'00'      CLEAR SNAP BYTE 1
         MVI   AVMSNBY2,X'00'      CLEAR SNAP BYTE 2
         XSNAP LABEL='***MACINT ENTERED***',IF=(AVMSNBY1,O,$MSNP01,TM)
.MACINT1 ANOP
         MVC   AVMBYTE1(4),AWZEROS   CLEAR FLAGS
         LA    RA,AVMWRK1+255      GET UPPER LIMIT OF WORK AREA1
         ST    RA,AVMWRKL1         SAVE IN MAIN CONTROL AREA
         LA    RA,AVMWRK2+255      GET WORK AREA2 LIMIT
         ST    RA,AVMWRKL2         SAVE IN MAIN CONTROL AREA
         SPACE 2
         XC    AWZEROS(256),AWZEROS    ZERO TABLE                     S
         TM    AVTAGSM,AJOMACRO    MACRO OPTION USED?
         BZ    MACINTRT            RETURN IF NOT
         SPACE 1
*        CONSIDER MODIFYING CODE FOR LIST HANDLING ********************
         LA    RB,$LMACLIB+$LGLBENT+$LCHWRK   TOTAL WORKAREA LENGTH   J
         $ALLOCL  RA,RB,MCINITOV   GET DUMMY AREA FOR MACLIB
         ST    RA,AVMACLIB         STORE @ IN MAIN TABLE
         MVC   0($LMACLIB+$LGLBENT,RA),AWZEROS  ZERO MAC,GBLX TABLES  A
         USING MACLIB,RA           NOTE USING ON MACLIB ENTRY
         OI    MCLBTAGS,AVMCLBDF   SET DEFINED FLAG ON DUMMY
         DROP  RA
*              SPACE FOR 1 DUMMY MCGLBDCT.                            J
         LA    RA,$LMACLIB(,RA)    BUMP PTR BEYOND MACRO ENTRY        J
         ST    RA,AVMGDICT         STORE @ IN MAIN TABLE
         SPACE 1                   REMV OLD MVC                       J
*              BUMP, POINT AT $LCHWORK BYTES FOR CHARACTER WORKAREA.  J
         LA    RA,$LGLBENT(,RA)    BUMP PTR BEYOND GBLX ENTRY         J
         ST    RA,AVMCHSTR         SAVE @ IN AVWXTABL
         LA    RA,$LCHWRK-1(RA)    GET @ OF LAST BYTE
         ST    RA,AVMCHLIM         SAVE @ IN AVWXTABL
         LA    RA,MCINITOV         GET @ OF OVRFLW ROUTINE
         ST    RA,AVMOVRFL         SAVE IN AVWXTABL
         MVC   AVMACNST,AWZEROS    INIT NEXTING COUNT TO ZERO
         MVC   AVMMACID,AWZEROS    INITIALIZE MACRO ID TO ZERO
         ZAP   AVMSYSDX,AWP0       INIT SYSNDX TO ZERO
MACINTRT EQU   *
         MVC   AVGEN1CD,AVADDHIH   INIT EXPANSION POINTER 1
         MVC   AVGEN2CD,AVADDHIH   INIT EXPANSION POINTER 2
         XSNAP LABEL='***MACINT EXITED*** ',IF=(AVMSNBY1,O,$MSNP01,TM)
         $RETURN  SA=NO
         SPACE 2                                                      S
**--> INSUB: MCINITOV       OVERFLOW ROUTINE + + + + + + + + + + + + +S
*+       CALLED BY ANY ROUTINE WHEN STORAGE OVERFLOW OCCURS.         +S
*+       -- TERMINATES SECOND PASS                                   +S
*+                                                                   +S
*+       USES MACROS:  $SPIE,$CALL                                   +S
*+       EXIT CONDITIONS:  PROGRAM MARKED NON-EXECUTABLE             +S
*+       CALLED BY:  MACRO1,MCGTEST,MCBODY, AND MCGNCD               +S
*+                                                                   +S
*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +S
         SPACE 2                                                      S
MCINITOV EQU   *                   PROGRAM EXITS TO HERE IF OVERFLOW
         BALR  R15,0               **KLUDGE** NONSTANDRD BR'S *********
         USING *,R15               SHOULD HAVE THIS USING
*        **WARNING** MACRO1 & MEXPND CANNOT BOTHE BE ACTIVE FOR THIS.
         L     R1,AVMBSPIE         GET @ LAST PREVIOUS SPIE BLK
         OI    AVTAGS2,AJOASTOP    STOP 2ND PASS PROCESSING
         $SPIE ACTION=(RS,(1))     RESTORE PREVIOUS PTR
         $CALL MOSTOP              GO TO MOSTOP TO QUIT
         LTORG
         DROP  RAT,R15
         TITLE '***  MACRO1 - MAIN ROUTINE FOR MACRO DEFINITION'
**-->  CSECT:  MACRO1   CALLED BY MAIN CONTROL WHEN MACRO OPCODE      *
*.        ENCOUNTERED.  AT PRESENT (DEC 31, 1971) ONLY MACRO          *
*.        DEFINITIONS ARE ALLOWED, NO CONDITIONAL ASSEMBLY.  MACRO1   *
*.        CREATES ENTRY IN MACLIB FOR FUTURE EXPANSION BY MEXPND      *
*.        ENTRY CONDITIONS                                            *
*.     RA = SCAN POINTER @ OF OPERAND                                 *
*.     RC = @ OPCODTB ENTRY FOR OPERATION                             *
*.                                                                    *
*.        CALLS MACSCN,OUTPT2,MACFND,ERRTAG,ERRLAB,MCVSCN,MCSCOP,     *
*.              MCBODY                                                *
*.        USES MACROS: $SAVE,$RETURN,$CALL,$ALLOCL                    *
*.        USES DSECTS: RSBLOCK,OPCODTB,AVWXTABL,MACLIB,MCPARENT       *
*.                                                                    *
*.       REGISTER USAGE:                                              S
*.             WORK REGS: R0,R1,R2,RA,RB,RD,RE                        S
*.             BASE REGS: RAT,RW,RX,RY,R13,RC                         S
*.             UNUSED: RZ                                             S
*.                                                                    S
*.*********************************************************************
         XSET  XSNAP=OFF                                              A
         SPACE
MACRO1   CSECT
         $SAVE RGS=(R14-R6),SA=*,BR=13
         USING AVWXTABL,RAT        NOT MAIN TABLE USING
         XSNAP LABEL='***MACRO1 ENTERED***',IF=(AVMSNBY1,O,$MSNP02,TM)
         L     RW,AVRSBPT          GET @ OF SOURCE STATEMENT
         USING RSBLOCK,RW          ESTAB BASE FOR SOURCE
         USING OPCODTB,RC          ESTAB BASE FOR OPCODE ENTRY
         AIF   (&$DEBUG).MACQQ00   SKIP IF NO DEBUF
         $SPIE ,,ACTION=CR,CE=MCBSPIEP
         ST    R1,AVMBSPIE         SAVE PREV INT @
.MACQQ00 ANOP
         LA    RA,RSBSOURC         SET SCAN POINTER
         LR    R0,RC               SAVE RC ACROSS MACSCN CALL         A
         $CALL MACSCN              SCAN SOURCE STATEMENT FOR FIELDS
         LR    RC,R0               RESTORE RC                         A
         L     RA,AVMFLD2          GET OPCODE ADDRESS
         CLI   OPCHEX,$MACRO       OPCODE=MACRO?
         BNE   MACR1R01            ERROR IF NOT
         TM    AVPRINT1,AVPRSAVE   AFTER START STMNT OR EQUIV?
         BO    MACR1R01            ERROR IF YES
         AIF   (NOT &$MACOPC).MAC1A  BRANCH IF NO OPEN CODE           S
         TM    AVMTAG00,AVMNOMAC   MACROS ALLOWED?                    S
         BO    MACR1R01            MACROS NOT ALLOWED                 S
.MAC1A   ANOP                                                         S
         CLI   AVMFLDT1,X'00'      LABEL PRESENT?
         BE    MACRO101            OK IF NOT
         LA    RB,$ERILLAB         SET ERROR FLAG IF YES
         $CALL ERRLAB              MARK STATEMENT
MACRO101 EQU   *
MCR1PRNT EQU   *
         LA    RB,$OUCOMM          SET PRINT FLAG
         $CALL OUTPT2              PRINT STATEMENT
         MVC   AVMBYTE1(3),AWZEROS CLEAR ALL FLAGS
         L     RA,AVMMACID         GET PREV MACRO ID
         LA    RA,1(RA)            INCREMENT BY ONE
         ST    RA,AVMMACID         RESTORE CURRENT ID
*
*  NEXT SECTION READS AND PROCESSES THE PROTOTYPE STATEMENT
*
         BAL   RET,MACRORD         READ PROTOTYPE STMT
         LA    RA,RSBSOURC         SET SCAN POINTER TO ASTART
MACPROT1 EQU   *
         $CALL  MACSCN              SCAN SOURCE FOR FIELDS
         CLI   AVMFLDT2,C'I'       OPCODE = MACRO INSTRUCTION?
         BNE   MACR1DUM            IF ERR-BRANCH-BAD PROTOTYPE        S
*                                                                     S
*        IMPROPER PROTOTYPE STMT FOUND OR PREVIOUSLY DEFINED MACRO-   S
*        ERROR FLAGS SET AND UNIQUE NAME INSERTED.                    S
*                                                                     S
*                                                                     S
*        SCAN MACRO LIBRARY FOR MACRO NAME --                         S
*              PREVIOUSLY DEFINED FLAGGED AS ERROR                    S
*              NOT PREVIOUSLY DEFINED ==> OK                          S
*                                                                     S
MACPROT2    EQU   *
         SR    RE,RE               ZERO RE FOR EX USE
         IC    RE,AVMFLDL2         GET LENGTH OF SYMBOL
         BCTR  RE,0                DECR LENGTH FOR EX INST
         MVC   AVMSYMBL,AWBLANK    BLANK OUT COMMON SYMBOL FIELD
         L     RA,AVMFLD2          MOVE @ OPCODE TO SCAN PNTR
         EX    RE,MCMVSYM          MOVE SYMBOL INTO AVMSYMBL FOR SEARCH
         MVC   AVMSYMLN(1),AVMFLDL2 MOVE SYMBOL LENGTH INTO COMMON AREA
         L     RC,AVMACLIB         GET @ OF MACRO LIBRARY
         USING MACLIB,RX           SET USING FOR MACLIB ENTRY
         $CALL MACFND              SEARCH MACRO LIBRARY FOR SYMBOL
         LTR   RB,RB               ALREADY THERE?
         BNZ   MACPROT3            IF NOT, ENTER
         LR    RX,RC               MOVE BASE TO RX
         TM    MCLBTAGS,AVMCLBDF   PREVIOUSLY DEFINED?
         BNO   MACPROT4            NO, JUST MARK DEFINED NOW          S
         SPACE 1                                                      S
*              EITHER INCORRECT OR DUPLICATE MACRO NAME - GET @       S
*              OF DUMMY MACLIB HAVING X'00' AS MACRO NAME (ALWAYS     S
*              POINTED TO BY AVMACLIB - THIS DUMMY IS REUSED FOR ALL  S
*              SUCH ERRONEOUS MACROS.  ALSO FLAG ERROR.               S
MACR1DUM LA    RB,$ERILMNM         DUPLICATE/BAD MACRO NAME           S
         L     RA,AVMFLD2          GET @ OF OPCODE                    S
         $CALL ERRTAG              CALL ERROR FLAGGING                S
         L     RX,AVMACLIB         GET @ OF DUMMY ELEMENT             S
         MVC   MCLBFLG2($LMACLIB-(MCLBFLG2-MACLIB)),AWZEROS   RECLEAR S
         B     MACPROT4            AND PROCEED
*                                                                     S
*        MACRO NAME DEFINED AND ENTERED IN LIBRARY, SPACE ALLOCATED   S
*                                                                     S
MACPROT3 EQU   *
         LR    RX,RC               MOVE LIB ENTRY PNTR TO RX
         LA    RE,$LMACLIB         GET LENGTH OF MACRO LIN ENTRY
         $ALLOCL RD,RE,MCOVRPR     GET AREA FOR NEW ENTRY
         ST    RD,MCLIBNXT         SAVE @ OF NEW ENTRY IN PREV ENTRY
         LR    RX,RD               MOVE BASE TO RD
         MVC   MACLIB($LMACLIB),AWZEROS   ZERO NEW ENTRY
         MVC   MCLBNMLN(9),AVMSYMLN  MOVE NAME INTO LIBRARY
         SPACE
*   MACLIB ENTRY ESTABLISHED.  &SYSECT, &SYSNDX AND &SYSLIST ARE NEXT
*   ENTERED IN PARAMETER LIST
         SPACE
MACPROT4 EQU   *
         OI    MCLBTAGS,AVMCLBDF   SET DEFINED FLAG
         USING MCPARENT,RY         SET USING FOR PARAM ENTRY
         LA    RE,(MACSVAR#+1)*$LPARENT   GET SLOTS FOR SYSTEM        A
         $ALLOCL  RY,RE,MCOVRPR     GET SPACE FOR ENTRY
         MVC   MCPARNLN(MCPARNTL),MACSVAR1   MOVE &SYSECT ENTRIES     J
         LA    R1,AVSYSECT         GET @ OF CURRENT CSECT NAME
         ST    R1,MCPROPRN         SAVE IN ENTRY
         ST    RY,MCPARPNT         SAVE POINTER IN MACLIB ENTRY
         LA    RC,$LPARENT(,RY)    @ OF NEXT ENTRY                    A
         ST    RC,MCPARNXT         SAVE POINTER IN PREV ENTRY
         LR    RY,RC               MOVE BASE TO NEW ENTRY
         MVC   MCPARNLN(MCPARNTL),MACSVAR2   MOVE &SYSNDX ENTY        J
         MVC   MCPROPRN,AWZEROS    SET POINTER TO ZERO
         LA    RC,$LPARENT(,RC)    @ OF NEXT ENTRY                    A
         ST    RC,MCPARNXT         SAVE POINTER IN PREV ENTRY
         LR    RY,RC               MOVE AASE TO NEW ENTRY
         MVC   MCPARNLN(MCPARNTL),MACSVAR3   MOVE &SYSLIST ENTRY      J
         SPACE
*    SYSTEM VARIABLES ENTERED IN PARAM LEST.  NEXT GET LABEL IF ANY
         SPACE
         LA    RC,$LPARENT(,RC)    @ OF NEXT ENTRY
         ST    RC,MCPARNXT         SAVE LINK IN PREV ENTRY
         LR    RY,RC               MOVE BASE TO NEW ENTRY
         MVC   MCPARENT($LPARENT),AWZEROS ZERO OUT ENTRY
         L     RA,AVMFLD1          GET @ OF LABEL, IF ANY
         LTR   RA,RA               IS THERE A LABEL
         BZ    MCPARSCN            IF NOT, PROCEED WITH OPERAND SCAN
         $CALL MCVSCN              ELSE SCAN LABEL FIELD
         LTR   RB,RB               VARIABLE SYMBOL?
         BZ    MCLAB01             OKAY IF RB = 0
         LA    RB,$ERINVSY         ELSE FLAG INVALID SYMBOL
MACLABER EQU   *
         $CALL ERRLAB              FLAG ERROR
         B     MCPARSCN            RESUME SCAN AFTER FLAGGING ERROR
         SPACE
MCMVSYM  MVC   AVMSYMBL($),0(RA)   DUMMY FOR EX INST TO MOVE SYMBOL
         SPACE
*                                                                     S
*        SCAN FOR &LABEL -- IF NOT MULTIPLY DEFINED ENTER IN          S
*        PARAMETER LIST                                               S
*                                                                     S
MCLAB01  EQU   *
         L     RC,MCPARPNT         GET @ OF PARAM LIST
         $CALL MACFND              SCAN LIST
         LTR   RB,RB               NAME ALREADY PRESENT
         BNZ   MCLAB02             OKAY IF NONZERO
         LA    RB,$ERMULDF         ELSE SET MULTIPLE DEF FLAG
         B     MACLABER            BRANCH AND FLAG ERROR
MCLAB02   EQU  *
         MVC   MCPARNLN(9),AVMSYMLN       MOVE LABEL NAME INTO ENTRY
         MVI   MCPARTYP,C'P'       SET ENTRY TYPE TO POSITIONAL
         SPACE
*  START SCAN OF PARAMETER OPERAND FIELD
         SPACE
MCPARSCN CLI   AVMFLDL3,X'00'      OPERAND PRESENT?
         BE    MACRO1RT            IF NOT, FINI
         L     RA,AVMFLD3          ELSE GET @ OF OPERAND IN SCAN PNTR
         SPACE 2                                                      S
*        BEGIN LOOP TO SCAN MACRO PARAMETER LIST                      S
         SPACE 1                                                      S
MCPARST  EQU   *
         LR    R0,RA               COPY SCAN POINTER TEMPORRARILY
         $CALL MCVSCN              SCAN NEXT SYMBOL
         LTR   RB,RB               VAR SYMBOL OK?
         BZ    MCPRSC01            IF YES, PROCEED
         LA    RB,$ERINVSY         IF RB ^= 0, ILLEGAL                S
         B     MACR1TG1            FLAG STNT
         SPACE
*        HAVE LEGAL PARAMETER -- SCAN, DETERMINE TYP) AND INSERT      S
*                                                                     S
MCPRSC01 EQU   *
         CLI   0(RA),C'='          KEYWORD PARAMETER?
         BE    MCPRSC11            IF YES, OKAY
         TM    AVMBYTE1,$MKEYOPR   KEYWORD ALREADY PROCESSED?
         BO    MACR1R03            ERROR IF YES
***************  POSSIBLE CHANGE FOR ASM H OR VS  ***************     S
*                                                                     S
*        LEGAL PARM FOUND -- INSERT IF NOT DUPLICATE                  S
*                                                                     S
MCPRSC11 EQU   *
         ST    RA,AVMTSCNP         SAVE SCAN POINTER TEMPORARILY
         L     RC,MCPARPNT         GET @ OF PAR LIST
         $CALL MACFND              SEARCH PARAMETER LIST
         LTR   RB,RB               SYMBOL ALREADY PRESENT?
         BNZ   MCPRSC02            IF NOT, OKAY
         LR    RA,R0               RESTORE SCAN POINTER FOR ERROR MSG
MCPRSCMD LA    RB,$ERMULDF         SET MULT DEF FLAG
         B     MACR1TG1            BRANCH AND FLAG STMT
*
*        ALLOCATE SPACE FOR PARM ENTRY, CHACK TYPE AND BUMP COUNTERS  S
*                                                                     S
MCPRSC02 LA    RE,$LPARENT         GET LENGTH OF PAR ENTRY
         $ALLOCL R1,RE,MCOVRPR     GET AREA FOR NEW ENTRY
         ST    R1,MCPARNXT         PUT POINTER IN PREV ENTRY
         LH    R2,MCPARNDX         GET CURRENT OPERAND COUNT
         LR    RY,R1               MOVE BASE TO NEW ENTRY
         MVC   MCPARENT($LPARENT),AWZEROS   CLEAR ENTRY
         MVC   MCPARNLN(9),AVMSYMLN     MOVE SYMBOL INTO NIE ENTRY
         LA    R1,1(R2)            BUMP OPERAND COUNT BY ONE
         STH   R1,MCPARNDX         RESTORE NEW COUNT
         STH   R1,MCPOPRNB         UPDATE TOTAL NBR OF OPRNDS
         L     RA,AVMTSCNP         RESTORE SCAN POINTER
         CLI   0(RA),C'='          KEYWORD PARAMETER?
         MVI   MCPARTYP,C'P'       ELSE SET TYPE = POSITIONAL
         BNE   MCPRSC06            JUMP OUT IF POSITIONAL             A
         SPACE
*        KEYWORD PARM FOUND -- PROCESS ACCORDINGLY                    S
*                                                                     S
MCPRSCK  LA    RA,1(RA)            BUMP SCAN PNTR PAST '='
         MVI   MCPARTYP,C'K'       IDENTIFY AS KEYWORD OPERAND
         ST    RA,AVMTSCNP         SAVE SCAN PNTR TEMPORARILY
         NI    AVMBYTE1,X'FF'-$MSBLIST  TURN OFF SUBLIST FLAG
         OI    AVMBYTE1,$MKEYOPR   SET KEYWORD OPRND FLAG
         $CALL MCSCOP              SCAN OPERAND
         LTR   RB,RB               OPERAND OK?
         BNZ   MACR1TG1            IF NOT, BRANCH AND FLAG
         STC   RD,MCPRATYP         SAVE ATTRIBUTE TYPE
         STC   RC,MCPROPLN         STORE LENGTH
         LH    RE,MCKOPRNB         GET KEYWORD COUNT
         LA    RE,1(RE)            BUMP KEYWORD COUNT
         STH   RE,MCKOPRNB         RESTORE NEW COUNT
         LTR   RC,RC               CHECK FOR NULL STRING
         BZ    MCPRSC03            IF YES, GO TO NEXT OPERAND
         LA    RE,3+1(,RC)         ROUND TO FULLWORD+1 FOR DELIM AFTERJ
         SRL   RE,2                SHIFT RIGHT TO TRUNCATE 2 BITS
         SLL   RE,2                SHIFT LEFT TO RESTORE
         $ALLOCL RB,RE,MCOVRPR     GET AREA FOR KEYWORD VALUE
         ST    RB,MCPROPRN         SAVE STND VALUE @ IN ENTRY
*              OMIT  BCTR RC,0 : USE LENG RATHER THAN LENG-1, SO WILL J
*              PICK UP DELIMITER AFTER VALUE.  HELPS MEXPND SCAN OK   J
         L     RE,AVMTSCNP         RESTORE SCAN POINTER FOR OPRND MOVE
         EX    RC,MCMVOPRN         MOVE KEYWORD VALUE INTO ENTRY
*                                                                     S
*        PROCESS SUBLISTED PARAMETERS                                 S
*                                                                     S
MCPRSC03 EQU   *
         CLI   MCPRATYP,C'S'       SUBLIST?
         BNE   MCPRSC06            PROCEED IF NOT
         LR    R0,RA               COPY SCAN PNTR
         L     RA,AVMTSCNP         GET ORIGINAL SCAN PNTR
         LA    RA,1(RA)            BUMP PAST '('
         OI    AVMBYTE1,$MSBLIST   SET SUBLIST FLAG
*                                                                     S
*        BEGIN LOOP TO PROCESS SUBOPERANDS                            S
*                                                                     S
MCPRSC05 EQU   *
         $CALL MCSCOP              SCAN SUBOPRND
         LTR   RB,RB               OKAY?
         BNZ   MACR1TG1            IF NOT, BRANCH AND FLAG
         CLI   0(RA),C')'          END OF SUBLIST?
         LA    RA,1(RA)            BUMP PAST DELIM
         BNE   MCPRSC05            RESUME SCAN IF NOT END
         LR    RA,R0               ELSE RESTORE SCAN PNTR
*                                                                     S
*        DELIMETER CHECK                                              S
*                                                                     S
MCPRSC06 EQU   *
         CLI   0(RA),C' '          END OF OPERAND?
         BE    MACRO1RT            BRANCH AND PRINT IF YES
         CLI   0(RA),C','          DELIM = ','?
         BE    MCPRBMP             OK IF YES
         LA    RB,$ERINVDM         ELSE SET BAD DELIM FLAG
         B     MACR1TG1            BRANCH AND FLAG
MCPRBMP  EQU   *
         LA    RA,1(RA)            BUMP SCAN POINTER
         CLI   0(RA),C' '          BLANK AFTER ','?
         BNE   MCPARST             RESUME SCAN IF NOT
         SPACE 1
*        POSSIBLE NON-STD CONT CARDS -- MACROS ONLY                   S
         CLI   RSBNUM,1            ONLY 1 CARD?
         BE    MCPARST             RESUME SCAN IF YES
         LA    RB,RSBLOCK+RSB$L+RSOL1  POINT TO 1ST BYTE, 2ND CARD
         CR    RA,RB               POINTING AT WHICH CARD?
         BNH   MCPRCO#2            PROCESS 2ND CARD IF LOW
         CLI   RSBNUM,3            TWO CONT CARDS?
         BNE   MCPARST             RESUME SCAN IF NOT
         LA    RB,RSOLC(RB)        POINT TO 1ST BYTE, 3RD CARD
         CR    RA,RB               WHERE IS SCAN POINTER?
         BH    MCPRCO#3            CHECK FOR 4TH CARD
MCPRCO#2 EQU   *
         LR    RA,RB               MOVE SCAN POINTER TO CONT CARD
         B     MCPARST             GO BACK FOR NEXT OPRND
         SPACE 2
MCPRCO#3 EQU   *
         CLI   AVMBYTE5,$ERCONTX   MORE THAN THREE CARDS?
         BNE   MCPARST             RESUME SCAN IF NOT
         LA    RB,$OUCOMM          SET PRINT FLAG
         $CALL OUTPT2              PRINT STMT
         BAL   RET,MACRORD         GET NEXT STMT
         OI    RSBFLAG,$RSBNPNN    SET NO ACTION FLAG
         LA    RA,RSBSOURC         POINT TO START OF STMT
         CLC   0(15,RA),AWBLANK    ALL BLANKS IN COL 1-15?
         BE    MCPRCO#4            OKAY IF YES
         LA    RB,$ERCONT          ELSE SET ERROR FLAG
         $CALL ERRTAG              FLAG STMT
MCPRCO#4 EQU   *
         LA    RA,15(RA)           BUMP SCN PNTR TO COL 16
         B     MCPARST             AND RESUME SCAN
MCMVOPRN MVC   0($,RB),0(RE)       DUMMY FOR EX INSTR TO MOVE OPRND   S
         SPACE 2
**--> INSUB: MACRORD       MACRO READER  + + + + + + + + + + + + + + +S
*+       CALLED BY MACRO1 THREE PLACES:                              +S
*+             1ST TO READ PROTOTYPE STMT                            +S
*+             2ND TO CHECK FOR CONT CARDS (MACRO)                   +S
*+             3RD TO GET NEXT CONT CARD (NON-MACRO)                 +S
*+       ENTRY CONDS:                                                +S
*+             RETURN POINT = RET                                    +S
*+       EXIT CONDS:                                                 +S
*+             AVMBYTE5 (ERROR FLAG) SET IF MORE THAN ALLOWED        +S
*+             CONTINUATION CARDS  (LIMIT = 3)                       +S
*+       CALLS:  INCARD TO ACTUALLY READ CARDS                       +S
*+               ERRTAG FOR ERROR PROCESSING                         +S
*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +S
         SPACE 2                                                      S
MACRORD  EQU   *
         ST    RET,MACRDSAV        SAVE RETURN @
         $CALL INCARD              READ NEXT STMT
         STC   RB,AVMBYTE5         SAVE ERROR FLAG
         CLI   AVMBYTE5,$ERCONTX   MORE THAN THREE CARDS?
         BE    MACRDRTN            PROCEED IF YES
         LTR   RB,RB               ELSE TEST FOR OTHER ERROR
         BZ    MACRDRTN            RETURN IF NONE
         $CALL ERRTAG              ELSE FLAG STMT
         TM    AVTAGS2,$INEND2     END OF FILE ERROR?
         BO    MACRO1RT            RETURN IF YES
MACRDRTN EQU   *
         L     RET,MACRDSAV        RESTORE RETURN @
         BR    RET                 AND RETURN
MACRDSAV DS    F                   SPACE FOR RETURN @
         SPACE 4
*        ERROR ROUTINE CALLED WHEN ERROR FOUND IN MAC DEF             S
*                                                                     S
MACR1R01 EQU   *
         AIF   (NOT &$MACOPC).MAC1B  BRANCH IF NO OPEN CODE           S
         EJECT                                                        S
*        MAIN CONTROL BLOCK FOR OPEN CODE CONDITIONAL ASSEMBLY        S
*                                                                     S
*              REGISTER USAGE FOR THIS SECTION:                       S
*                                                                     S
*              R0  - WORK REG                                         S
*              R1  - PTR TO CONTROL TABLE AND TRT REG                 S
*              R2  - PTR TO CONTROL TABLE                             S
*              RW  - BASE FOR RSBLOCK                                 S
*              RX  - BASE FOR MACLIB                                  S
*              RY  - UNUSED (BUT --> BASE FOR MCPARENT IN MACRO1)     S
*              RZ  - BASE FOR MXPNTSAV AND WORK REG                   S
*              RA  - WORK REG                                         S
*              RB  - BASE FOR MCLCLDPV AND WORK REG                   S
*              RC  - BASE FOR OPCODTB AND WORK REG                    S
*              RD  - UNUSED                                           S
*              RE  - UNUSED                                           S
*              RAT - BASE FOR AVWXTABL                                S
*              R13 - BASE FOR THIS CSECT --> MACRO1                   S
*                                                                     S
         OI    AVMTAG00,AVMNOMAC   FLAG => NO MORE MACROS             S
         SR    R1,R1               CLEAR FOR TABLE INDEX              S
         IC    R1,OPCHEX           GET OPCODE INDEX                   S
         LA    R1,MC1CONTB(R1)     LOAD @ OF TABLE ENTRY              S
         L     RX,AVMACLIB         GET @ OF OPEN CODE MACLIB          S
*        SET UP MACLIB ENTRY AND LOCAL DICTIONARY DUMMY ENTRY,        S
*        IF NOT ALREADY DONE                                          S
         TM    AVMTAG00,AVMOPMIN   IS LOCAL DUMMY BUILT ?             S
         BO    MC1CLMCB            BRANCH IF YES                      S
         L     RD,AVMMACID         INCRESE MACID                      A
         LA    RD,1(RD)            INCREASE BY ONE                    A
         ST    RD,AVMMACID         STORE IT BACK                      A
         MVC   MACLIB+4($LMACLIB-4),AWZEROS  ZERO OUT MACLIB ENTRY    S
         MVC   MCLBNMLN(9),MC1OPNCD  ENTER NAME AND LENGTH INTO MACLIBS
*        ALLOCATE CORE FOR LOCAL DUMMY ENTRY (SEE MCBODY START)       S
         LA    RA,$LLCLDV+$LGLBENT GET LENGTH OF DICTS                A
         USING MCLCLDPV,RB         NOTE USING ON LOCAL DICT DOPE VECT S
         $ALLOCH  RB,RA,MC1OVRFL   GET AREA FOR ENTRY                 S
         ST    RB,MCDDVPNT         SAVE @ IN MACLIB                   S
         MVC   0($LLCLDV+$LGLBENT,RB),AWZEROS   CLEAR ENTRY           A
         MVI   MCLCLTYP,$ARITH     SET TYPE = ARITH FOR LENGTH        S
         MVI   MCLCLDIM+1,1        SET DIMENSION TO 1                 S
         DROP  RB                                                     S
         MVI   MCLOCDLN+3,4        INIT LENGTH OF DICT TO 4           S
         OI    AVMTAG00,AVMOPMIN+AVMNOMAC   SET FLAGS                 A
         OI    MCLBFLG2,$MCOCFL1   SHOW OPEN CODE                     A
         XSNAP LABEL='AFTER OPEN MACLIB',STORAGE=(*MACLIB,*MACLIB+100),X
               IF=(AVTAGSM,O,AJOMACRH,TM)                             A
MC1CLMCB EQU   *                                                      S
         XSNAP LABEL='MCICLMB,R1 TABLE ENTRY'                         A
         TM    0(R1),$MC1DCL       DECLARE TYPE OPCODE ?              S
         BNO   MC1ACTON            NO, ACTION TYPE                    S
         TM    AVPRINT1,AVPRSAVE   LISTING CONTROL = SAVE ?           S
         BO    MC1NORM             BRANCH IF YES                      S
         TM    MCLBFLG2,$MCOCFL2   DECLARE TYPE ALLOWED ?             S
         BO    MC1NORM             NO, OUT OF ORDER                   S
         OI    AVMTAG00,AVMOPENC   SET FLAG TO SHOW IN OPEN           A
         LR    RC,RX               COPY @ MACLIB WHERE EXPECTED       J
         $CALL MCBODY              PROCESS STATEMENT                  S
         B     MC1RTN0             RETURN, RB=0                       S
*        ACTION TYPE MACRO OPCODE PROCESSED BELOW                     S
MC1ACTON EQU   *                                                      S
         XSNAP LABEL='ACTION TYPE FOUND'                              A
         TM    0(R1),$MC1ERR       ERROR FLAG ON ?                    S
         BO    MC1NORM             BRANCH IF YES                      S
         OI    MCLBFLG2,$MCOCFL2   DECLARE TYPES NO LONGER ALLOWED    S
         TM    AVMTAG00,AVMOPDIC   HAS OPEN CODE LOCAL DICT BEEN      S#
                                   ALLOCATED ?                        S
         BO    MC1SAVLO            BRANCH IF YES                      S
*        ALLOCATE SPACE FOR OPEN CODE LOCAL DICTIONARY AND MXPNTSAV   S
         L     RA,MCLOCDLN         GET LENGTH OF LOCAL DICT           S
         LA    RA,$LMXPTSV(RA)     ADD LENGTH OF MXPNTSAV             S
         $ALLOCH RB,RA,MC1OVRFL    GET CORE FOR LOCAL DICT            S
*        INITIALIZE LOCAL DICTIONARY AND MXPNTSAV TO ZEROS            S
         ST    RB,MC1PTSAV         SAVE POINTER TO ALLOCATED CORE     S
         LR    R0,RA               COPY OVER LENGTH FOR LATER USE     J
         BCTR  RA,0                DECR COUNT                         S
         EX    RA,MC1MOVZR         CLEAR LENGTH MOD 256               S
         SRA   RA,8                SHIFT TO GET # 256 BYTE BLOCKS LEFTS
         BNP   MC1DNZER            SKIP IF NO MORE TO DO              S
         N     R0,AWFXFF      REMOVE ALL BUT LAST BYTE OF LENGTH      J
         AR    RB,R0               ADD LENGTH, GET @ FIRST BYTE TO 0  J
         MVC   0(256,RB),AWZEROS   CLEAR 256 BYTES AT A TIME          S
         LA    RB,256(,RB)         INCMT TO NEXT BLOCK                S
         BCT   RA,*-10             LOOP, CLEAR TILL DONE              S
*        SET UP MXPNTSAV AND SET ACTR LIMIT                           S
MC1DNZER EQU   *                                                      S
         USING MXPNTSAV,RZ         BASE REG FOR MXPNTSAV              S
         L     RZ,MC1PTSAV         BASE REG FOR MXPNTSAV              S
         ST    RX,MXPNMCLB         STORE @ OF MACLIB ENTRY            A
         LA    RB,$LMXPTSV(RZ)     GET ADDR OF LOCAL DICTIONARY       S
         ST    RB,MXPNLDBS         SAVE @ IN MXPNTSAV                 S
         MVC   0(4,RB),AVMMACTR    SET ACTR LIMIT                     S
         OI    AVMTAG00,AVMOPDIC   FLAG => DICT ALLOCATED             S
*        CALL MCBODY TO CREATE ONE-OPS.  IF NO ERROR ON RETURN,       S
*        CALL MXINST TO INTERPRET THE ONE-OPS.  OTHERWISE RETURN.     S
MC1SAVLO EQU   *                                                      S
         MVC   MC1LOPTR(4),AVADDLOW  SAVE CURRENT LO PTR              S
         LR    RC,RX               COPY @ MACLIB WHERE EXPECTED       J
         XSNAP LABEL='BEFORE CALL MCBODY OC',                          X
               IF=(AVTAGSM,O,AJOMACRH,TM)                             A
         L     RD,AVADDHIH         GET HIGH PTR                       A
         LR    RE,RD               COPY INTO RE                       A
         STM   RD,RE,AVGEN1CD      STORE INTO AVGEN1DC,AVGEN2DC       A
         $CALL MCBODY              PROCESS STATEMENT                  S
         L     RA,MCCODLNK         GET # FIRST INSTRUCTION            A
         USING MCOPQUAD,RA         NOTE ONE/OP PTR                    A
         CLI   MCQS1FLG,$BSERR01   WAS IT IN ERROR                    A
         BNE   *+8                 SKIP AROUND RESET IF O.K.          A
         LA    R1,=AL1($MC1SKIP,$MC1RET)  FAKE NO MORE ACTION         A
         NI    AVMTAG00,255-AVMOPGO  TURN OFF AIF/AGO FLAG (AVMOPGO)  S
         TM    0(R1),$MC1SKIP      IS SKIP BIT ON ? (SKIP MXINST)     S
         BO    MC1RSTLO            IF YES, SKIP CALL TO MXINST        S
         L     RC,MC1PTSAV         LOAD @ OF MXPNTSAV                 S
         USING MXPNTSAV,RC          SET UP ANOTHER USING              Z
         MVC   MXPNCRCD(4),MCCODLNK  LOAD @ OF UST INSTR              A
         DROP  RZ,RC,RA                                               A
         XSNAP LABEL='BEFORE CALL TO MXINST'                          A
         XCALL MXINST              CALL TO INTERPRET ONE-OPS          S
         L     RD,AVGEN1CD                                            A
         L     RE,AVADDHIH                                            A
         XSNAP LABEL='AFTER MXINST',STORAGE=(*0(RD),*4(RD),*0(RE),*4(REX
               ))                                                     A
*        WIPE OUT ONE-OPS AND RETURN IF DONE                          S
MC1RSTLO EQU   *                                                      S
         MVC   AVADDLOW(4),MC1LOPTR  RESTORE AVADDLOW                 S
*              IF ORIGINAL STATEMENT NOT ALREADY PRINTED, GET IT      A
*              BACK FROM HIGH AREA AND SAVE IT VIA UTPUT1             A
         TM    AVPRINT1,AVPRSAVE   ALREADY IN SAVE MODE               A
         BZ    MC1ALPRT            NO, SO PRINTED STMT ALREADY        A
         $CALL INCARD              GET STMT BACK                      A
         OI    RSBFLAG,$RSBNP##    SHOW NO MORE PROCESSING            A
         $CALL UTPUT1              HAVE IT SAVED                      A
MC1ALPRT TM    0(R1),$MC1RET       IS RETURN BIT ON ?                 S
         BO    MC1RTN0             BRANCH IF YES                      S
*        PROCESS AIF, AGO AND ANYTHING ELSE NEEDING ACTION            S
         SR    R2,R2               CLEAR R2 FOR INDEX                 S
         IC    R2,1(R1)            LOAD JUMP CODE FROM CONTROL TABLE  S
         B     *+4(R2)             BRANCH ON INDEX                    S
         B     MC1AGO              BRANCH TO PROCESS AGO              S
         TM    AVMTAG00,AVMOPGO    WAS AIF SUCCESSFUL ?               S
         BNO   MC1RTN0             NOT SUCCESSFUL SO RETURN           S
*        AGO OR SUCCESSFUL AIF -- CHECK FOR ILLEGAL BACKWARD REFERENCES
MC1AGO   EQU   *                                                      S
         LA    RA,AVMSYMBL         LOAD @ OF SEQ SYMBOL               S
         SR    RB,RB               CLEAR RB FOR LENGTH-1 IF SYMBOL    S
         IC    RB,AVMSYMLN         LOAD LENGTH-1                      S
         STC   RB,MC1CLC1+1        STORE LENGTH IN CLC INSTR          S
         LA    RB,1(RB)            ADD 1 TO GET LENGTH                S
         LR    RZ,RB               COPY LENGTH FOR LATER              S
         $CALL SYFIND              LOOK UP SEQ SYMBOL                 S
         B     *+4(RB)             BRANCH ON RETURNED INDEX           S
         B     MC1SEQDF            BRANCH IF PREVIOUSLY DEFINED       S
*        SEQ SYMBOL NOT PREVIOUSLY DEFINED -->                        S
*        READ CARDS UNTIL SEQ SYMBOL OR END-OF-FILE FOUND             S
MC1READ  EQU   *                                                      S
         $CALL INCARD              READ NEXT SOURCE CARD              S
         TM    AVTAGS2,$INEND2     END-OF-FILE ?                      S
         BO    MC1EOF              BRANCH IF YES                      S
         CLI   RSBLOPC,C'.'        IS THIS A SEQ SYMBOL?              S
         BNE   MC1READ             IF NOT, READ NEXT CARD             S
         LA    RA,RSBSOURC         @ 1ST BYTE OF CARD                 S
         $SETRT  (' ',4)           STOP TRT ON BLANK                  S
         TRT   1(8,RA),AWTZTAB     SCAN FOR BLANK                     S
         $SETRT  (' ',0)           REZERO TABLE                       S
         BZ    MC1READ             INVALID SEQ SYM -- IGNORE          S
         LR    RB,R1               @ OF BLANK                         S
         SR    RB,RA               GET LENGTH                         S
         CR    RB,RZ               IS IT = ONE WE WANT ?              S
         BNE   MC1AGOSY            NO, BUT SHOW DEFINED               S
MC1CLC1  CLC   AVMSYMBL($),0(RA)   COMPARE SYMBOLS                    S
         BE    MC1RTN4             SEQ SYM FOUND -- RETURN            S
MC1AGOSY $CALL SYENT1              ENTER SEQ SYM IN TABLE             S
*        IF WANTED, COULD SEE IF PREVIOUSLY DEFINED - WE IGNORE IT    S
         B     MC1READ             GO FOR NEXT CARD                   S
*        SEQUENCE SYMBOL PREVIOUSLY DEFINED -->                       S
*        (AS242 -- BACKWARDS AIF/AGO IN OPEN CODE)                    S
MC1SEQDF EQU   *                                                      S
         MVC   AVRSBLOC(MC1MSEQU),MC1MSSG   MOVE ERROR MSG INTO       S#
                                   RSBLOCK  (AS242)                   S
         B     MC1RTN4             RETURN                             A
*        END-OF-FILE ENCOUNTERED BEFORE SEQ SYMBOL FOUND -->          S
*        (AS241 - SEQUENCE SYMBOL NOT FOUND)                          S
MC1EOF   EQU   *                                                      S
         MVC   AVRSBLOC(MC1MSEQ2),MC1MSSG2  MOVE ERROR MSG INTO RSB   S
*        RETURN SHOWING NEXT SOURCE ALREADY IN RSBLOCK                S
MC1RTN4  EQU   *                                                      S
         LA    RB,4                SET RETURN CODE                    S
         B     MACRO1FN            RETURN                             S
*        RETURN SHOWING NEXT SOURCE NOT IN RSBLOCK                    S
MC1RTN0  EQU   *                                                      S
         SR    RB,RB               CLEAR FLAG REGISTER                S
         B     MACRO1FN            BRANCH TO RETURN                   S
*                                                                     S
*        OVERFLOW EXIT  --  HALT ASSEMBLY                             S
*                                                                     S
MC1OVRFL EQU   *                                                      S
         OI    AVTAGS2,AJOASTOP    STOP 2ND PASS PROCESSING           S
         $CALL MOSTOP              GO TO MOSTOP TO QUIT               S
*                                                                     S
*        MACRO1 DC/DS/DUMMYS FOR OPEN CODE                            S
MC1MOVZR MVC   0($,RB),AWZEROS     DUMMY INSTR                        S
MC1LOPTR DC    F'0'                WORD TO SAVE CURRENT AVADDLOW      S
MC1PTSAV DC    F'0'                WORD TO SAVE PTR TO MXPNTSAV       S
MC1MSSG  DC    AL1(MC1MSEQU,$RSBNPNN+$RSBMERR,1,0)                    A
         DC    C'242 BACKWARDS AIF/AGO ILLEGAL'                       S
MC1MSEQU EQU   *-MC1MSSG                                              S
MC1MSSG2 DC    AL1(MC1MSEQ2,$RSBNPNN+$RSBMERR,1,0)                    A
         DC    C'241 SEQUENCE SYMBOL NOT FOUND'                       S
MC1MSEQ2 EQU   *-MC1MSSG2                                             S
MC1OPNCD DC    X'08',CL8'OPEN-CDE'                                    S
         EJECT                                                        S
*        MACRO1 CONTROL TABLE FOR OPEN CODE CONDITIONAL ASSEMBLY      S
*                                                                     S
*              THE FIRST BYTE CONTAINS FLAG BITS;                     S
*              BYTE 2 CONTAINS JUMP CODES                             S
         SPACE 2                                                      S
MC1CONTB EQU   *                                                      S
         DC    AL1($MC1RET,0)          NON-MACRO STMT                 S
         DC    AL1($MC1ERR,0)          MACRO                          S
         DC    AL1($MC1DCL,0)          GBLA                           S
         DC    AL1($MC1DCL,0)          GBLB                           S
         DC    AL1($MC1DCL,0)          GBLC                           S
         DC    AL1($MC1DCL,0)          LCLA                           S
         DC    AL1($MC1DCL,0)          LCLB                           S
         DC    AL1($MC1DCL,0)          LCLC                           S
         DC    AL1($MC1RET,0)          ACTR                           S
         DC    AL1($MC1RET,0)          SETA                           S
         DC    AL1($MC1RET,0)          SETB                           S
         DC    AL1($MC1RET,0)          SETC                           S
         DC    AL1(0,4)                AIF                            S
         DC    AL1($MC1SKIP,0)         AGO                            S
         DC    AL1($MC1SKIP+$MC1RET,0) ANOP                           S
         DC    AL1($MC1RET,0)          MNOTE                          S
         DC    AL1($MC1ERR,0)          MEXIT                          S
         DC    AL1($MC1ERR,0)          MEND                           S
         DS    0H                  ALIGN IF NECESSARY                 S
         EJECT                                                        S
MC1NORM  EQU   *                                                      S
.MAC1B   ANOP                                                         S
         L     RA,AVMFLD2          GET @ OF OPCODE                    S
MACR1LAB LA    RB,$ERSTMNA         SET CODE / USE WHATEVER @ IN RA    S
MACR1TAG $CALL ERRTAG              SET FLAG
         LA    RB,8                SET PROPER RETURN CODE
         B     MACRO1FN
*        ERROR ROUTINE CALLED WHEN POSITIONAL PARAM FOUND AFTER       S
*        KEYWORD PARAM                                                S
***************  POSSIBLE CHANGES WITH ASM H OR VS  ***************   S
*                                                                     S
MACR1R03 EQU   *
         LA    RB,$ERVSYNT         SE T SYNTAX ERROR FLAG
         B     MACR1TG1            FLAG STMT
MCOVRPR  L     RE,AVMOVRFL         GET @ OF OVERFLOW ROUTINE
         BR    RE                  BRANCH THERE
         SPACE 4
*        GENERAL ROUTINE TO FLAG INCORRECT PARAM FIELDS               S
*                                                                     S
MACR1TG1 EQU   *
         $CALL ERRTAG              FLAG STMT
         SPACE 2
*        CHECK FOR END OF PROTOTYPE AND CALL ROUTINE TO PROCESS       S
*        BODY OF MACRO  (MCBODY)                                      S
*                                                                     S
MACRO1RT EQU   *
         LA    RB,$OUCOMM
         $CALL OUTPT2
         CLI   AVMBYTE5,$ERCONTX   MORE THAN THREE CARDS?
         BNE   MACRO1RU            PROCEED IF NOT
         BAL   RET,MACRORD         ELSE GET NEXT STMT
         OI    RSBFLAG,$RSBNPNN    SET NO ACTION FLAG
         B     MACRO1RT            AND PRINT LINES
MACRO1RU EQU   *
         LR    RC,RX
         SR    RB,RB
         TM    AVTAGS2,$INEND2     END OF FILE?
         BO    MACRO1FN            RETURN IF YES
         $CALL MCBODY              PROCESS BODY OF DEFINIETION
MACRO1FN EQU   *
         AIF   (&$DEBUG).MACROFN   SKIP OVER DEBUG CODE IF NOT NEEDED J
         L     R1,AVMBSPIE
         $SPIE ,,ACTION=(RS,(1))   TURN OFF SPIE
         L     R1,AVADDLOW         GET @ OF START OF DYNAMIC AREA
         XSNAP LABEL='DYNAMIC AREA',STORAGE=(*0(RX),*0(R1),*AVADDLOW,*AX
               VWXEND),IF=(AVMSNBY1,O,$MSNP02,TM)
.MACROFN ANOP
         $RETURN  RGS=(R14-R6)
         AIF   (&$DEBUG).MACQQ01   SKIP IF NO DEBUG
         USING MCBSPIEP,R15
MCBSPIEP EQU   *
         L     RC,AVMACLIB         GET PONTR TO LOW ENDOF LOW CORE
         L     RD,AVADDLOW        GET HIGH END OFLOW CORE
         XSNAP LABEL='*** INTERRUPT IN MACRO DEFINITION PHASE ***',    #
               STORAGE=(*0(R1),*16(R1),*0(RC),*0(RD),*AVADDLOW,*AVWXEND#
               )
         DC    H'1'                FORCE INTERRUPT
         DROP  R15
.MACQQ01 ANOP
         DROP  RAT,RW,RX,RY,R13                                       A
         LTORG
MACSVAR# EQU   3                   ACTUAL # SYSTEM VARIABLES          J
*              SYSTEM VARIABLES - VALUES FOR MCPAR- NLN,NAM,TYP.      J
MACSVAR1 DC    AL1(7),CL8'&&SYSECT ',C'S'                             J
MACSVAR2 DC    AL1(7),CL8'&&SYSNDX ',C'S'                             J
MACSVAR3 DC    AL1(8),CL8'&&SYSLIST',C'S'                             J
         TITLE '*** MACSCN - MACRO STATEMENT SCAN ***'
**-->  CSECT: MACSCN   SCANS MACRO INSTRUCTION STATEMENT. IDENTIFIES  *
*.        LABEL, OPCODE, OPERAND AND COMMENT (IF ANY) FIELDS.         *
*.        LOCATION OF EACH FIELD STORED IN AVMFLD_.  LENGTH OF EACH   *
*.        FIELD STORED IN AVMFLDL_.  TYPE OF EACH FIELD PLACED IN     *
*.        AVMFLDT_.  FIELDS ARE SET TO ZERO IF NOT PRESENT.           *
*.        AVMFLDT1 CONTAINS '&' IF VARIABLE SYMBOL AND '.' IF SEQUENCE*
*.        SYMBOL ELSE ZERO.  AVMFLDT2 CONTAINS 'I' IF OPCODE IS       *
*.        SUSPECTED MACRO INSTRUCTION, 'M' IF MACRO OPCODE (AIF,      *
*.        AGO, SETA, ETC), 'O' IF OPCODE IS REGULAR ASSEMBLER OR      *
*.        MACHINE INSTRUCION AND X'00' IF ANYTHING ELSE.              *
*.        SCANS NON STND CONTINUATION FILDS AND PLACES VALUES IN      *
*.        AVMFLD5 THRU AVMFLD8                                        *
*.                                                                    *
*.        ENTRY CONDITIONS                                            *
*.     RA = @ OF FIRST CAHARACTER OF STATEMENT                        *
*.        EXIT CONDITIONS                                             *
*.     RA = SAME AS ENTRY CONDITIONS                                  *
*.     RB = 4 IF COMMENT STATEMENT, 8 IF MACRO COMMENT, ELSE ZERO     *
*.     RC = @ OF OPCODTB ENTRY IF OPCODE = M OR O                     *
*.                                                                    *
*.        USES MACROS: $CALL, $SAVE, $RETURN, $SETRT                  *
*.        USES DSECTS: AVWXTABL, OPCODTB                              *
*.       CALLS ERRTAG,MCATRM,OPFIND                                   S
*.   NAMES: MAC----- OR MC------                                      S
*.             BASE REGS:  R13,RAT,RX,RC                             S*
*.             WORK REGS:  R1,R2,RA,RB,RW,RZ                         S*
*.*********************************************************************
         SPACE 2
* * * * * REGISTER USAGE IN MACSCN  * * * * * * * * * * * * * * * * * S
*   R0 = SAVE REGISTER FOR RETURN @ IN MACSCSTR  *2ND MINIMAL USED*  J*
*   R1 = TRT USAGE; ADDRESS REGISTER (HI-ORDER BYTE = 0).            J*
*   R2 = BYTE REGISTER (HI-ORDER 3 BYTES = 0); TRT USAGE.            J*
*   RW = PARENTHESES LEVEL COUNT IN SECTION MACSCSTR                 J*
*   RX = @ RSBLOCK BEGIN SCANNED                                     J*
*   RY = 1 FOR SCANNING USAGE (BXH, ETC)                             J*
*   RZ = SAVE REG FOR OPCODTB PTR  * MINIMAL-USED REGISTER           J*
*   RA = SCAN POINTER                                                J*
*   RB = RETURN CODE USAGE                                           J*
*   RC,RD,RE  = PARAMETER REGISTERS FOR EXTERNAL ROUTINES.           J*
*   R13 = SAVE AREA PTR; BASE REGISTER                               J*
*   R13= BASE REGISTER, SAVE AREA PTR.                               J*
*   RET,REP=  USUAL LINKAGE, INCLUDING INTERNAL LINKAGE              J*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * S
         EJECT                                                        S
MACSCN   CSECT
         $SAVE RGS=(R14-R6),SA=*,BR=13
         USING AVWXTABL,RAT        SET MAIN CONTROL TABLE USING
         XSNAP LABEL='***MACSCN ENTERED***',IF=(AVMSNBY1,O,$MSNP03,TM)
         MVC   AVMFLD1($LAVMFLD),AWZEROS  CLEAR FIELD POINTERS
         SR    RB,RB
         LM    R1,R2,AWZEROS       CLEAR R1 AND R2 FOR TRT INST
         ST    RA,AVMTSCNP         SAVE SCAN POINTER TEMPORARILY
*
         LA    RY,1                SET UP USEFUL VALUE FOR SCANNING   J
*   CHECK FOR PRESENCE OF COMMENT STATEMENT
*
         CLI   0(RA),C'*'          REGULAR COMMENT?
         BNE   MCMNT01             IF NOT, JUMP
         LA    RB,4                ELSE SET COMMENT STMNT FLAG
         B     MCSCNRT             AND RETURN
MCMNT01  CLC   0(2,RA),=C'.*'      MACRO COMMENT?
         BNE   MACLABSC            IF NOT, JUMP AND START SCAN
         LA    RB,8                ELSE SET MACRO COMMENT FLAG
         B     MCSCNRT             AND RETURN
*
*   SET UP TRT TABLE TO SCAN FOR DELIMITERS
*
MACLABSC $SETRT  (' ',4,'(',8,')',12,'''',16)
         SPACE 2
*        START SCAN FOR LABEL -- DETERMINE TYPE (VAR,SEQ OR NORMAL)   S
*        AND PROCESS ACCORDINGLY                                      S
*                                                                     S
         CLI   0(RA),C' '          LABEL PRESENT?
         BE    MACOPCSC            IF BLANK, JUMP AND SCAN OPCODE
         ST    RA,AVMFLD1          ELSE SAVE LABEL @
         CLI   0(RA),C'&&'         VAR SYMBOL?
         BE    MACSCN02            IF YES, SCAN REST OF SYMBOL
         CLI   0(RA),C'.'          SEQ SYMBOL?
         BE    MACSCN02            IF YES, JUMP AND SCAN REST OF SYMBOL
         SPACE 2
MACSCN01 BAL   RET,MACSCSTR        BRANCH AND SCAN STRING
         B     MACSCN03
         SPACE 2
*        SCAN VAR OR SEQ SYMBOL -- SETS AVMFLDT1 TO PROPER TYPE       S
*                                                                     S
MACSCN02 CLI   1(RA),C'0'          FIRST CHAR IS A LETTER?
         BNL   MACSCN01            NOT ORD. SYMBOL IF NOT
         TRT   1(8,RA),AWTSYMT     SCAN SYMBOL
         BZ    MACSCN01            NOT SYMBOL, 9+ CHARS, RESUME SCAN
         CLI   0(R1),C' '          DELIM = BLANK?
         BNE   MACSCN01            NO SYMBOL IF NOT
         MVC   AVMFLDT1(1),0(RA)   SAVE TYPE
         LR    RA,R1               UPDATE SCAN POINTER
         SPACE 2
*        COMPUTE AND STORE CHARACTER LENGTH                           S
*                                                                     S
MACSCN03 S     RA,AVMFLD1          GET LENGTH OF FIELD
         STC   RA,AVMFLDL1         SAVE LENGTH
         A     RA,AVMFLD1          RESTORE SCAN POINTER
*
*    SCAN FOR START OF OPCODE
*
MACOPCSC BAL   RET,MACSCBLN        SCAN FOR NON BLANK
         ST    RA,AVMFLD2          SAVE @ OF OPCODE
         USING OPCODTB,RC          ESTAB BASE FOR OPCODE ENTRY
         $CALL OPFIND              LEGAL OPCODE?
         LTR   RB,RB               YES IF RB = 0
         BNZ   MACSCN04            IF NOT TREAT AS STRING
         LR    RZ,RC               COPY OPCODTB @ TEMPORARILY
         IC    R2,OPCTYPE          GET TYPE                           J
         SRL   R2,6                REMOVE ALL BUT 1ST 2 BITS          J
         IC    R2,MACSTAB1(R2)     GET TYPE: 'O' OR 'M' OF OPCODE     J
         STC   R2,AVMFLDT2         SAVE THE TYPE VALUE FOR LATER USE  J
         B     MACSCN06
MACSTAB1 DC    AL1(C'O',C'O',C'M',C'O')  OPCODE TYPE TABLES           J
         ORG   *+0*($IA+$IS+$IM+$IB)  REFER TO TYPES FOR XREF         J
         SPACE 2
MACSCN04 CLI   0(RA),C'0'          FIRST CHAR < 0?
         BNL   MACSCN07            NO SYMBOL IF NOT
         TRT   0(9,RA),AWTSYMT     SCAN SYMBOL
         BZ    MACSCN07            9+ CHARS IF ZERO
         CLI   0(R1),C' '          DELIM = BLANK?
         BNE   MACSCN07            NO SYMBOL IF NOT
         MVI   AVMFLDT2,C'I'       SET MACRO INSTRUCTION FLAG
         LR    RA,R1               MOVE SCAN POINTER
         B     MACSCN06            BRANCH TO GET LENGTH
         SPACE 2
MACSCN07 BAL   RET,MACSCSTR        SCAN OPCODE STRING
MACSCN06 S     RA,AVMFLD2          GET LENGTH OF OPCODE
         STC   RA,AVMFLDL2         SAVE LENGTH
         A     RA,AVMFLD2          RESTORE SCAN POINTER
*
*   NEXT SECTION FINDS AND SCANS OPERAND FIELD
*
         L     RX,AVRSBPT          POINT TO RSBLOCK
         USING RSBLOCK,RX          SET USING ON RSBLOCK
         BAL   RET,MACSCOPR        SCAN OPRND FIELD
         MVC   AVMFLD3(5),MACSCNFD MOVE DATA TO FIELD PNTRS
         BAL   RET,MACSCHEK        CHECK FOR NON STND CONT CARD
         BAL   RET,MACSCMMT        SCAN COMMENT FIELD
         MVC   AVMFLD4(5),MACSCNFD MOVE DATE TO FIELD PNTRS
         BAL   RET,MACSCOPR        SCAN NEXT OPRND(IF PRESENT)
         MVC   AVMFLD5(5),MACSCNFD MOVE DATA TO FIELD PNTRS
         BAL   RET,MACSCHEK        CHECK FOR 1 MORE NON STND CARD
         BAL   RET,MACSCMMT        SCAN COMMENT
         MVC   AVMFLD6(5),MACSCNFD   MOVE DATA TO FIELD PNTRS
         BAL   RET,MACSCOPR        SCAN 3RD OPRND(IF ANY)
         MVC   AVMFLD7(5),MACSCNFD   MOVE DATA TO FIELD PNTRS
         L     RB,AVSOLAST         SET EOR @ FOR LAST COMMENT
         BCTR  RB,0                DECR FOR TRUE LENGTH
         BAL   RET,MACSCMMT        SCAN COMMENT
         MVC   AVMFLD8(5),MACSCNFD  MOVE DATA TO FIELD PNTRS
         B     MCSCNFT             AND FINI
         SPACE 2
**--> INSUB: MACSCOPR       FIND AND SCAN OPERAND + + + + + + + + + ++S
*+       THIS ROUTINE FINDS, SCANS, GETS ADDR AND LENGTH OF THE      +S
*+       OPERAND FIELD                                               +S
*+                                                                   +S
*+       EXIT CONDS:  ADDR & LENGTH ARE PLACED IN APPROPRIATE        +S
*+                    PLACES IN TABLE.                               +S
*+                                                                   +S
*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +S
         SPACE 2                                                      S
MACSCOPR EQU   *
         ST    RET,MACSCSAV        SAVE RETURN @
         BAL   RET,MACSCBLN        SCAN FOR NONBLANK
         ST    RA,MACSCNFD         SAVE @ OF OPRND
         BAL   RET,MACSCSTR        SCAN OPRND
         S     RA,MACSCNFD         SUBTRACT START @
         STC   RA,MACSCNFL         SAVE LENGTH
         A     RA,MACSCNFD         RESTORE POINTER
         L     RET,MACSCSAV        RESTORE RETURN @
         BR    RET                 AND RETURN
         SPACE 2
**--> INSUB: MACSCMMT       SCAN COMMENT FIELD + + + + + + + + + + + +S
*+       THIS ROUTINE SCANS FOR NON-BLANK, CHECKS FOR CARD           +S
*+       OVERRUN.  IF OK, SAVES @ AND LENGTH OF FIELD.               +S
*+                                                                   +S
*+       EXIT CONDS:  ADDR & LENGTH ARE PLACED IN APPROPRIATE        +S
*+                    PLACES IN TABLE.                               +S
*+                                                                   +S
*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +S
         SPACE 2                                                      S
MACSCMMT EQU   *
         ST    RET,MACSCSAV        SAVE RETURN @
         MVC   MACSCNFD(6),AWZEROS   ZERO POINTER STORAGE
         BAL   RET,MACSCBLN        SCAN FOR NON BLANK
         CR    RA,RB               COMPARE WITH END OF RECORD
         BNL   MACSCMRT            RETURN IF IN NEXT CARD IMAGE
         ST    RA,MACSCNFD         ELSE SAVE @
         SR    RB,RA               GET LENGTH
         STC   RB,MACSCNFL         SAVE LENGTH
         AR    RA,RB               BUMP SCN PNTR TO BLNK BEYOND CMMT
MACSCMRT EQU   *
         L     RET,MACSCSAV        GERT RETRUN @
         BR    RET                 AND RETURN
MACSCSAV DS    F                   STORAGE FOR RETURN @
MACSCNFD DS    F                   TEMP STRORAE FOR LOCATION PNTR
MACSCNFL DS    C                   TEMP STROAGE FOR FIELD LENGTH
MACSCNTY DS    C                   TEMP STRGE FOR FIELD TYPE
         SPACE 2
**--> INSUB: MACSCHEK       CHECK FOR NON-STD COND CARD  + + + + + + +S
*+       CHECKS FOR MACRO PROTOTYPE CONTINUATION CARDS (UP TO 3)     +S
*+                                                                   +S
*+       EXIT CONDS:  RB = PTR SET TO:                               +S
*+             1.  LAST CHAR ON ORIGINAL CARD (NOT CONTINUATION)     +S
*+             2.  1ST BYTE ON 2ND OR 3RD CARD (NON-STD CONT)        +S
*+                                                                   +S
*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +S
         SPACE 2                                                      S
MACSCHEK EQU   *
         L     RB,AVSOLAST         GET EOR @
         BCTR  RB,0                DECR TO BLANK PAST LAST CHAR
         BCTR  RA,0                DECR SCAN POINTER
         CLI   0(RA),C','          STOP ON ','?
         LA    RA,1(RA)            RESTORE SCAN POINTER
         BCR   NE,RET              NOT NON-STND IF NO COMMA
         CLI   AVMFLDT2,C'I'       POSSIBLE MACRO CALL?
         BCR   NE,RET              ALSO RETURN IF NOT
         LA    RB,RSBLOCK+RSB$L+RSOL1  POINT TO 1ST BYTE, 2ND CARD
         CR    RA,RB               COMPARE WITH SCAN POINTER
         BCR   NH,RET              RETURN IF NOT HIGH
         LA    RB,RSOLC(RB)        ELSE BYMP RB TO 3RD CARD
         CR    RA,RB               COMPARE SCAN PONTR AGAIN
         BCR   NH,RET              RETURN IF NOT HIGH
         L     RB,AVSOLAST         ELSE LOAD EOR @
         BCTR  RB,RET              DECREM TO 1ST BLANK, BRANCH ALWAYS J
         DROP  RX
         SPACE 2
**--> INSUB: MACSCBLN       SCAN FOR NON-BLANK CHAR  + + + + + + + + +S
*+       SCANS FOR NON-BLANK CHAR WITHOUT CARD OVERRUN               +S
*+                                                                   +S
*+       ENTRY COND:  RA = @ WHERE SCAN TO BEGIN                     +S
*+       EXIT COND:  RA = @ OF 1ST NON-BLANK OR                      +S
*+                        @ OF END OF RECORD                         +S
*+                                                                   +S
*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +S
         SPACE 2                                                      S
MACSCBLN EQU   *                   SCAN FOR NON-BLANK                 S
MACBLN01 CLI   0(RA),C' '          BLANK?
         BNE   MACBLN02            IF NOT, NON BLANK FOUND
         BXH   RA,RY,MACBLN01      ELSE TRY AGAIN                     J
MACBLN02 C     RA,AVSOLAST         END OF RECORD?
         BNL   MCSCNFT             IF YES, SCAN FINI, RETURN
         BR    RET                 ELSE RESUME STMNT SCAN
         EJECT                                                        S
**--> INSUB: MACSCSTR       SCAN ARBITRARY STRING  + + + + + + + + + +S
*+       THIS SECTION IS A ROUTINE TO SCAN AN ARBITRARY              +S
*+       STRING AND RETURN THE LENGTH.  SCAN PTR IS LEFT             +S
*+       AT BLANK FOLLOWING STRING.                                  +S
*+                                                                   +S
*+       ENTRY COND:  RA = @ OF BEGINNING OF STRING                  +S
*+                                                                   +S
*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +S
         SPACE 2                                                      S
MACSCSTR EQU   *
         LR    R0,RET              COPYRETURN @
         SR    RW,RW               CLEAR RW FOR PAREN COUNT
         NI    AVMBYTE1,X'FF'-$MINQUOT   CLEAR QUOTE FLAG
         SPACE 2
MACSTRT  EQU   *
         TRT   0(200,RA),AWTZTAB   SCAN STRING
         B     *(R2)               BRANCH INTO TABLE FOR ROUTINE
         B     MCSCBLNK
         B     MCSCLPAR
         B     MCSCRPAR
         B     MCSCQUOT
         SPACE 2
MCSCBLNK TM    AVMBYTE1,$MINQUOT   INSIDE QUOTE?
         BO    MCSCBLOK            IF YES, PROCEED
         LTR   RW,RW               INSIDE PARENS?
         BP    MCSCBLOK            IF YES, PROCEED
         LR    RA,R1               ELSE UPDATE SCAN POINTER
         LR    RET,R0              RESTORE RETURN @
         BR    RET                 AND RETURN TO STMNT SCAN
         SPACE 2
MCSCLPAR AR    RW,RY               = LA RW,1(RW) BUMP PAREN COUNTER   J
         B     MCSCBLOK            GO TO BUMP SCAN PTR & CONTINUE     S
         SPACE 2
MCSCRPAR EQU   *
         BCTR  RW,0
MCSCBLOK LA    RA,1(,R1)           BUMP SCAN PTR TO NEXT CHAR         S
         B     MACSTRT             RESUME SCAN
         SPACE 2
MCSCQUOT C     R1,AVSOLAST         END OF RECORD?
         BNL   MCSCQU01            BRANCH AND PROCESS ERROR IF YES
         CLI   1(R1),C''''         TWO QUOTES?
         BE    MCSCQTWO            IF YES, JUMP AND PROCEED
         LR    RA,R1               MOVE SCAN POINTER
         TM    AVMBYTE1,$MINQUOT    ARE WE IN SIDE QUOTED STRING?
         BO    MCSCQTRT            IF YES, DON'T LOOK FOR ATTRIBUTE
         BCTR  RA,0                DEC POINTER FOR ATTERM
         TRT   0(1,RA),AWTSYMT     IS PREV CHAR ALPHA?
         BNZ   MCSCNOAT            IF NOT CAN'T BE ATTRIBUTE
         $CALL MCATRM              IS IT AN ATTRIBUTE?
         LTR   RB,RB               ATTRIBUTE IF RB=0
         BZ    MACSTRT             IF YES THEN RESUME SCAN
         BP    MCSCQTWO            IF ATTRIB NOT IMPLEMENTED RESUME SCA
MCSCNOAT AR    RA,RY               = LA RA,1(RA) RESTORE POINTER      J
         TM    AVMBYTE1,$MINQUOT   ARE WE INSIDE QUOTES?
         BO    MCSCQTRT            IF YES RESET TRT TABLE
         $SETRT ('(',0,')',0,' ',0)  ELSE TURN OFF TRT FOR QUOTE STRNG
         B     MCSCQUFT
MCSCQTRT $SETRT (' ',4,'(',8,')',12)  RESET TRT FOR END OF QUOTE STRNG
MCSCQUFT XI    AVMBYTE1,$MINQUOT   FLIP QUOTE FLAG
         BXH   RA,RY,MACSTRT       BUMP SCAN PTR, BRANCH ALWAYS       J
MCSCQTWO LA    RA,2(R1)            BUMP SCAN POINTER PAST DOUBLE '
         B     MACSTRT             RESUME SCAN
         SPACE 2
MCSCQU01 EQU   *
         NI    AVMBYTE1,X'FF'-$MINQUOT   TURN OFF QUOTE FLAG
         BCTR  R1,0                DEC R1
         LR    RA,R1               COPY R1 INTO SCAN POINTER
         LA    RB,$ERNODLM         SET NO DELIM FLAG
         $CALL ERRTAG              FLAG STATEMENT
         LA    RB,8                INDICATE MACRO COMMENT
         B     MCSCNERR            AND RETURN
         SPACE 4
*        RETURN SEQUENCE FOR MACSCN -- SETS RETURN CODES              S
*        AND RESETS TABLES, ETC.                                      S
*                                                                     S
MCSCNFT  EQU   *
         SR    RB,RB               CLEAR RB FOR NORMAL RETURN
MCSCNERR EQU   *
         $SETRT  (' ',0,'(',0,')',0,'''',0)    CLEAR TRT TABLE
MCSCNRT  EQU   *
         LR    RC,RZ               RESTORE OPCODTB @ TO RC FOR RETURN
         L     RA,AVMTSCNP         RESTORE SCAN POINTER
         XSNAP LABEL='***MACSCN EXITED***',IF=(AVMSNBY1,O,$MSNP03,TM), #
               STORAGE=(*AVMFLD1,*AVMBYTE5)
         $RETURN  RGS=(R14-R6)
         DROP  RAT,RC,R13
         LTORG
         TITLE '*** MCSCOP - STANDARD VALUE SCANNER ***'
**-->  CSECT:  MCSCOP   THIS ROUTINE SCANS A MACRO INSTRUCTION        *
*.        OPERAND.  THE OPERAND MUST CONFORM TO A STANDARD VALUE AS   *
*.        LAID DOWN IN SECTION 8 OF IBM GC28-2514                     *
*.                                                                    *
*.        ENTRY CONDITIONS                                            *
*.       AVMBYTE1: FLAG $MSBLIST EXPECTED SET IF ALREADY INSIDE SUBLISS
*.                                                                    *
*.        EXIT CONDITIONS                                             *
*.     RA = DELIM PAST OPRND IF STND VALUE ELSE POINTS AT ERROR       *
*.     RB = 0 IF STANDARD VALUE ELSE $ER MESSAGE                      *
*.     RC = LENGTH OF OPERAND IF OKAY                                 *
*.     RD = TYPE OF OPERAND.  IN THIS CASE TYPE WILL BE ONE OF        *
*.          'O' (NULL), 'N' (SELF-DEFINING TERM) OR 'U' (ALL OTHERS)  *
*.             CAN BE 'S' AFTER SCANNING   (1ST SUBPOPERAND           S
*.     RE = VALUE OF SELF DEFINING TERM                               *
*.       AVMBYTE1: FLAG $MINQUOT HAS INDETERMINATE VALUE.             S
*.        USES MACROS: $SAVE, $RETURN, $SETRT, $CALL                  *
*.        USES DSECTS: AVWXTABL                                       *
*.        CALLS SDBCDX                                                *
*.                                                                    *
*.*********************************************************************
         SPACE 4
* * * * * * * * * * REGISTER USAGE IN MCSCOP  * * * * * * * * * * * * S
*   R0 = TEMPORARY SAVE REGISTER FOR SCAN POINTER.                    S
*   R1 = SCAN POINTER FROM TRT INSTRUCTIONS.                          S
*   R2 = BYTE REGISTER, TRT USAGE.                                    S
*   RA = NORMAL SCAN POINTER.                                         S
*   RB = RETURN CODE REGISTER.                                        S
*   RC = RETURN LENGTH REGISTER.                                      S
*   RD = FLAG REGISTER FOR TYPE:  'U', 'N', 'O', OR 'S' .             S
*   RE = PARENTHESES NEST LEVEL COUNTER;  SELF-DEF TERM VALUE RETURN. S
*   R13= BASE REGISTER.                                               S
*   R14= INTERNAL LINK REGISTER.                                      S
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * S
         SPACE 2                                                      S
MCSCOP   CSECT
         $SAVE RGS=(R14-R2),SA=*,BR=13
         USING AVWXTABL,RAT
         XSNAP LABEL='***MCSCOP ENTERED***',IF=(AVMSNBY1,O,$MSNP04,TM)
         NI    AVMBYTE1,X'FF'-$MINQUOT  TURN OFF QUOTE FLAG
         LA    RD,C'U'             SET UNDEFINED FLAG FOR STARTS
         BAL   R14,MCSET1          SET TRT TABLE FOR CORRECT SCANNING J
         SR    RE,RE               USE RE AS PAREN COUNTER
         SR    R1,R1                                                  A
         SR    R2,R2               CLEAR R2 FOR TRT USE
         LR    R0,RA               COPY SCAN POINTER
         TRT   0(1,RA),AWTDECT     POSSIBLE SDTERM?
         BZ    MCOPSDTM            DECIMAL TERM IF CC = 0
         C     R2,AWF4             IS IT B, C OR X?
         BE    MCOPSDTM            POSSIBLE IF EQUAL TO 4
         B     MCOPSTRT            SKIP AROUND SCAN POINTER BUMP FIRSTJ
MCOPSTRS LA    RA,1(,R1)           SET SCAN PTR 1 BEYOND LAST TRT END J
MCOPSTRT EQU   *
         TRT   0(200,RA),AWTZTAB   START SCAN
         B     *(R2)               JUMP TO TABLE OF BRANCHES
         B     MCOPQUOT
         B     MCOPLPAR
         B     MCOPRPAR
         B     MCOPEQUL
         B     MCOPAMPR
         B     MCOPSCFT
         B     MCOPBLNK
         SPACE 2
MCOPQUOT EQU   *                   COME HERE FOR '                    A
         CLI   1(R1),C''''         TWO QUOTES IN ROW?
         BE    MCOPQTWO            IF YES, JUMP AN  PROCESS
         TM    AVMBYTE1,$MINQUOT
         BO    MCOPINQU
         LA    R2,2                                                   A
         SR    R1,R2                                                  A
         CLI   1(R1),C'L'                                             A
         BNE   MCOPQU11                                               A
         TRT   0(1,R1),AWTSYMT     CHACK CHARACTER
         BZ    MCOPQU11            IF LETTER THEN IS NOT L'
         TRT   3(1,R1),AWTSYMT     CHAR AFTER L' = ALPHA?
         BNZ   MCOPQU11            IF NOT, JUMP OUT
         CLI   3(R1),C'Z'          CHAR GREATER THAN Z?
         BH    MCOPQU11            IF YES, CANT BE ALPAH
         CLI   0(R1),C'&&'         IS IT AN AMPERSAND?
         BE    MCOPQU11            IF YES, NOT L'
         LA    RA,3(R1)            BUMP SCAN POINTER
         B     MCOPSTRT            RESUME SCAN
         SPACE 2
MCOPQTWO LA    RA,2(R1)            BUMP SCAN POINTER PAST ''
         B     MCOPSTRT
         SPACE 2
MCOPQU11 AR    R1,R2               RESTORE SCAN PTR TO ' FOUND        A
*   THE $SETRT MACRO IS USED TO CLEAR THE AWTZTAB TABLE FOR SCAN OF
*   A QUOTED STRING
         IC    RB,AWTZTAB+C','     SAVE CURRENT COMMA STATUS ACRS '   J
         BAL   R14,MCSET2A         SET FOR INSIDE QUOTED STRING -ZERO J
         B     MCOPQU02
*     WHEN END OF QUOTED STRING HAS BEEN REACHED, AWTZTAB IS RESTORED
*    SO THAT NORMAL SCAN CAN CONTINUE
MCOPINQU BAL   R14,MCSET1A         RESET, NO LONGER INSIDE QUOTED STRNJ
         STC   RB,AWTZTAB+C','     RESTORE ORIGINAL COMMA STATUS      J
MCOPQU02 XI    AVMBYTE1,$MINQUOT   FLIP QUOTE FLAG
         B     MCOPSTRS            GO BACK TO INCREMENT PTR AND SCAN  J
         SPACE 2
MCOPLPAR CR    R1,R0               BEGINNING OF OPERAND?
         BNE   MCOPLP01            IF NOT, PROCEED
         L     RD,=C'   S'         ELSE SET SUBLIST FLAG
MCOPLP01 LA    RE,1(RE)            BUMP PAREN COUNTER
         $SETRT (',',0)            COMMAS OK INSIDE PARENS
         B     MCOPSTRS            GO AND BUMP SCAN PTR BY 1          A
         SPACE 2
MCOPRPAR BCT   RE,MCOPRP01         DECR PAREN COUNTER
         $SETRT (',',24)           RESET TRT TABLE IF ZERO
         B     MCOPRP02
MCOPRP01 LTR   RE,RE               TEST PAREN COUNT
         BNM   MCOPRPFT            IF NOT MINUS, OKAY
         TM    AVMBYTE1,$MSBLIST   ARE WE IN SUBLIST
         BO    MCOPSCFT            IF YES, OKAY. END OF SUBLIST
MCOPRER1 LA    RB,$ERVSYNT        SET SYNTAX ERROR
         LR    RA,R1               SET SCAN POINTER
         B     MCOPSCRT
MCOPRPFT EQU   MCOPSTRS            SAME AS PREVIOUS LABEL: BUMP PTR   J
         SPACE 2
MCOPRP02 C     RD,=C'   S'         ARE WE IN SUBLIST?
         BNE   MCOPRPFT            IF NOT, PROCEED
         CLI   1(R1),C','          END OF OPERAND?
         BE    MCOPRPFT            IF YES, PROCEED
         CLI   1(R1),C' '          END OF OPERAND?
         BE    MCOPRPFT
         LA    RD,C'U'             INSERT UNDEFINED FLAG
         B     MCOPRPFT            CONTINUE SCAN
         SPACE 4
MCOPEQUL CR    R1,R0               AT START OF OPERAND?
         BE    MCOPEQ01            IF YES, OKAY
         LTR   RE,RE               ELSE ARE WEIN PARENS?
         BZ    MCOPRER1            ERROR IF NOT
MCOPEQ01 EQU   MCOPSTRS            SAME AS PREVIOUS LABEL, SKIP THERE J
         B     MCOPSTRS            BRANCH THERE, IF FLLA THRU HERE    J
         SPACE 4
MCOPAMPR CLI   1(R1),C'&&'         TWO AMPERSANDS?
         BE    MCOPQTWO            IF YES USE DOUBLE QUOTE CODE
         CR    R0,R1               BEGINNING OF OPERAND?
         BE    MCOPEQ01            IF YES USE = CODE
         B     MCOPRER1            ELSE ERROR, USE RPAR CODE
         SPACE 2
MCOPSDTM EQU   *
         $CALL SDBCDX              CALL SELF-DEFINING TERM ROUTINE
         LTR   RB,RB               WAS IT SD TERM
         BNZ   MCOPSTRT            JUMP IF NOT REALY SELF-DEF TERM  JRM
         CLI   0(RA),C','          NORMAL DELIM AFTER SDTERM?
         BE    MCOPSDT1            PROCEED IF YES
         CLI   0(RA),C' '          DELIM = ' '?
         BE    MCOPSDT1            PROCEED IF YES
         CLI   0(RA),C')'          DELIM IS A ')'?
         BNE   MCOPSDT2            IF NOT, START SCAN OVER
         TM    AVMBYTE1,$MSBLIST   SCANNING SUBLIST?
         BO    MCOPSDT1            RIGHT PAREN OKAY  IF SO
MCOPSDT2 EQU   *
         LM    RC,RD,AWZEROS       CLEAR RC, RD AFTER SDDTERM
         LR    RA,R0               RESTORE SCAN POINTER TO RESUME SCAN
         B     MCOPSTRT
MCOPSDT1 EQU   *
         LR    R1,RA               MOVE SCAN POINTER INTO R1
         LA    RD,C'N'             SET SELF DEF TERM FLG
         LR    RE,RC               MOVE VALUE OF SDTERM INTO RE
         B     MCOPSCFT
         SPACE 2
MCOPBLNK EQU   *
         LTR   RE,RE               ARE WE IN PARENS
         BZ    MCOPSCFT            IF NOT, FINI
         LA    RB,$ERNODLM         ELSE SET WRONG DELIM FLAG
         B     MCOPSCRT            AND RETURN
         SPACE 4
MCOPSCFT LR    RA,R1               MOVE SCAN POINTER
         LR    RC,R1               COPPY POINTER
         SR    RB,RB               CLEAR RB FOR FLAG USE
         C     RD,=C'   S'         SUBLIST?
         BNE   MCOPSCF1            SKIP IF NOT
         TM    AVMBYTE1,$MSBLIST   IN SUBLIST FLAG ON?
         BNO   MCOPSCF1            SKIP IF NOT
         LA    RD,C'U'             ELSE SET UNEFINED FLAG
MCOPSCF1 EQU   *
         SR    RC,R0               GET LENGTH OF OPERAND
         BNZ   MCOPSCRT            JUMP AROUND IN NOT ZERO
         LA    RD,C'O'             ELSE SET NULL FLAG
MCOPSCRT BAL   R14,MCSET2          RESET ALL VALUES CHANGED IN TRT TB J
         XSNAP LABEL='***MCSCOP EXITED*** ',IF=(AVMSNBY1,O,$MSNP04,TM)
         $RETURN  RGS=(R14-R2)
         SPACE 2                                                      J
**--> INSUB: MCSET#     MODIFY TRT TABLE AWTZTAB  + + + + + + + + + + S
MCSET1   $SETRT ('''',4)       SET TO CATCH ' ,  AND THEN OTHER CHARS J
MCSET1A  $SETRT ('(',8,')',12,'=',16,'&&',20,',',24,' ',28) OTHER CHRSJ
         BR    R14                 RETURN TO CALLER                   J
         SPACE 1                                                      J
MCSET2   $SETRT ('''',0)           RESET ' TO 0, THEN OTHERS          J
MCSET2A  $SETRT ('(',0,')',0,'=',0,'&&',0,',',0,' ',0) RESET OTHERS   J
         BR    R14                 RETURN TO CALLER                   J
         DROP  RAT,R13
         LTORG
         TITLE '*** MACFND - SEARCHES DICTIONARIES FOR VARIABLE ***'
**-->  CSECT:  MACFND    THIS ROUTINE IS GENERAL SEARCH PROCEDURE     *
*.        WHICH CAN SCAN THE MACRO LIBRARY, GLOBAL AND LOCAL          *
*.        DICTIONARIES AND THE SYMBOLIC PARAMETER LIST.  THE CALLING  *
*.        ROUTINE DETERMINES WHICH LIBRARY BY PLACING THE APPROPRIATE *
*.        POINTER IN RC.                                              *
*.                                                                    *
*.        ENTRY CONDITIONS                                            *
*.     RC = @ OF FIRST ENTRY OF LIST TO BE SEARCHED                   *
*.                                                                    *
*.        EXIT CONDITIONS                                             *
*.     RB = 0 IF ENTRY IS FOUND                                       *
*.        = $ERUNDEF IF ENTRY IS NOT FOUND                            *
*.     RC = @ OF ENTRY IF FOUND ELSE @ OF FINAL ENTRY IF NOT FOUND    *
*.        USES MACROS: $SAVE, $RETURN                                 *
*.        USES DSECTS: MACLIB, AVWXTABL                               *
*.                                                                    *
*.REGISTER USAGE                                                      A
*.RC-MACLIB BASE REGISTER, LIST TO BE SEARCHED                        A
*.RAT- MAIN TABLE DSECT USING                                         A
*.RB-RETURN REGISTER                                                  A
*.                                                                    A
*. NAMES=MACFN___                                                     A
*.                                                                    A
*.                                                                    *
*.*********************************************************************
         SPACE 2
MACFND   CSECT
         $SAVE SA=NO
         USING AVWXTABL,RAT
         XSNAP LABEL='***MACFND ENTERED***',T=NO,IF=(AVMSNBY1,O,$MSNP05X
               ,TM)
         USING MACLIB,RC           USE MACLIB AS REPRESENTATIVE DSECT
         LTR   RC,RC               CHECK FOR NULL (MAYBE OPEN CDE)    J
         BZ    MACFNDRU            SKIP IF NULL LIST                  J
         SR    RB,RB
         B     MACFND02            JUMP TO COMPARE FIRST ENTRY
MACFND01 L     RC,MCLIBNXT         GET @ OF NEST ENTRY
MACFND02 CLC   AVMSYMBL,MCLBNAM   COMPARE NAME WITH GLOBAL SYMBOL
         XSNAP LABEL='IN MACFND LOOP RC # LIB',STORAGE=(*0(RC),*30(RC))
         BE    MACFNDRT            IF EQUAL RETURN
         CL    RB,MCLIBNXT         FINAL ENTRY?
         BNE   MACFND01            IF NOT, TRY AGAIN
MACFNDRU LA    RB,$ERUNDEF         SHOW UNDEFINED SYMBOL              J
MACFNDRT EQU   *
         XSNAP LABEL='***MACFND EXITED***',IF=(AVMSNBY1,O,$MSNP05,TM)
         $RETURN   SA=NO
         DROP  RAT,RC,REP
         LTORG
         TITLE '***MCVSCN - VARIABLE SYMBOL SCANNER ***'
**-->  CSECT:  MCVSCN   THIS ROUTINE SCANS A STRING AND CHECKS        *
*.        FOR A LEGAL VARIABLE SYMBOL.  IF OKAY, SYMBOL IS MOVED INTO *
*.        AVMSYMBL IN AVWXTABL WHERE IT WILL BE UTILIZED IN SEARCHES. *
*.                                                                    *
*.        ENTRY CONDITIONS                                            *
*.     RA = @ OF FIRST CHARACTER OF STRING                            *
*.                                                                    *
*.        EXIT CONDITIONS                                             *
*.     RA = @ OF DELIMITER PAST SYMBOL IF LEGAL                       *
*.        = SAME AS ENTRY IF NOT VARIABLE SYMBOL                      *
*.     RB = 0 IF OKAY, <0 IF NOT VARIABLE SYMBOL,                     *
*.        = $ER MESSAGE IF ILLEGAL SYMBOL                             *
*.        USES MACROS: $SAVE, $RETURN                                 *
*.        USES DSECTS: AVWXTABL                                       *
*.                                                                    *
*.REGISTER USAGE                                                      A
*.RAT- MAIN TABLE DSECT USING                                         A
*.R1,R2 USED IN TRT'S                                                 A
*.RB- SET AS IN EXIT CONDITIONS ABOVE                                 A
*.                                                                    A
*.NAMES=MCVS____                                                      A
*.                                                                    A
*.*********************************************************************
         SPACE 2
MCVSCN   CSECT
         $SAVE RGS=(R0-R2),SA=NO
         USING AVWXTABL,RAT
         XSNAP LABEL='***MCVSCN ENTERED***',T=NO,STORAGE=(*AVMSYMBL,*AVX
               MSYMBL+10),IF=(AVMSNBY1,O,$MSNP05,TM)
         LM    R1,R2,AWZEROS       ZERO R1, R2, FOR TRT USE
         LR    R0,RA               COPY SCAN POINTER
         CLI   0(RA),C'&&'         STARTS WITH '&'?
         BNE   MCVSCNOT             IF NOT, NO VAR SYMBOL
         CLI   1(RA),C'0'          2ND CHAR = ALAPHA?
         BNL   MCVSCNER             IF NOT, ERROR
         TRT   1(8,RA),AWTSYMT     SCAN RMNDER OF SYMBOL
         BZ    MCVSCNER             IF ZERO, 9+ CHARS LONG, ERROR
         SR    R1,R0               GET LENGTH OF SYMBOL
         AR    R0,R1               BUMP SCAN &
         STC   R1,AVMSYMLN         SAVE LENGTH IN GLOBAL AREA
         BCT   R1,MCVSCN01          DECR FOR EX BUT FALL THROUGH IF ZER
         B     MCVSCNER             ERROR IF LENGTH = 1
MCVSCN01 MVC   AVMSYMBL,AWBLANK    BLANK GLOBAL AREA
         EX    R1,MCVSMOVE         MOVE SYMBOL INTO GLOBAL AREA
         LR    RA,R0               BUMP SCAN POINTER
         SR    RB,RB
         B     MCVSCNRT
MCVSCNOT L     RB,AWFM4            SET NO SYMBOL FLAG
         B     MCVSCNRT
MCVSCNER LA    RB,$ERINVSY         SET INVALID SYMBOL FLAG
MCVSCNRT EQU   *
         XSNAP LABEL='***MCVSCN EXITED***',IF=(AVMSNBY1,O,$MSNP05,TM)
         $RETURN  RGS=(R0-R2),SA=NO
MCVSMOVE MVC   AVMSYMBL(0),0(RA)   DUMMY TO MOVE SYMBOL IN EX INST
         DROP  RAT,REP
         LTORG
         TITLE '***MCSYSR - DICTIONARY SEARCH ROUTINE***'
**-->  CSECT:  MCSYSR  SCANS SUSPECTED VARIABLE SYMBOL FOR LEGALITY.  *
*.        IF VARIABLE SYMBOL THEN PLACES IN AVMSYMBL.  THEN SEARCHES  *
*.        GLOBAL, LOCAL AND SYMBOLIC PARAMETER DICTIONARIES FOR SYMBOL*
*.                                                                    *
*.        ENTRY CONDITIONS                                            *
*.     RA = @ OF FIRST CHARACTER OF SYMBOL                            *
*.                                                                    *
*.        EXIT CONDITIONS                                             *
*.     RA = @ OF DELIMITER PAST VARIABLE SYMBOL IF OKAY               *
*.        = SAME AS ENTRY IF NOT VARIABLE SYMBOL OR IF NOT FOUND      *
*.     RB = $ERUNDEF  IF SYMBOL IS NOT FOUND                          *
*.     RB = 0 IF SYMBOL IS FOUND IN ONE OF THE DICTIONARIES           *
*.        = SET TO -4 IF RA DOES NOT POINT AT VARIABLE SYMBOL         *
*.     RC = POINTER TO SYMBOL ENTRY IF FOUND                          *
*.     RD = $GLOBAL IF SYMBOL PRESENT IN GLOBAL DICTIONARY            *
*.        = $LOCAL IF SYMBOL FOUND IN LOCAL DICTIONARY                *
*.        = $SYMPAR IF SYMBOL IS SYMBOLIC PARAMETER                   *
*.        = $SYSTEM IF SYMBOL IS SYTEM VARIABLE                       *
*.                                                                    *
*.        USES MACROS: $CALL, $SAVE, $RETURN                          *
*.        USES DSECTS: MCGLBDCT, MACLIB,AVWXTABL                      *
*.        CALLS MCVSCN, MACFND                                        *
*.                                                                    A
*.REGISTER USAGE ***************                                      A
*.R13 -BASE REGISTER AND SAVEAREA POINTER                             A
*.RC- BASE REGISTER FOR GLOBAL DSECT                                  A
*.RX- BASE REGISER FOR MACRO DICTIONARY                               A
*.                                                                    A
*.NAMES=MCSY____                                                      A
*.                                                                    A
*.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 2
MCSYSR   CSECT
         $SAVE RGS=(R14-R0),SA=*,BR=13
         USING AVWXTABL,RAT        SET MAIN TABLE USING
         XSNAP LABEL='***MCSYSR ENTERED***',T=NO,IF=(AVMSNBY1,O,$MSNP06X
               ,TM)
         USING MCGLBDCT,RC         USE GLOBAL DSCT AS DUMMY FOR SEARCH
         USING MACLIB,RX           RX POINTS TO CURRENT MACLIB ENTRY
         LR    R0,RA               COPY SCAN POINTER
         SR    RD,RD               CLEAR RD FOR RETURN CODE
         $CALL MCVSCN              SCAN SYMBOL
         LTR   RB,RB               VAR SYMBOL?
         BZ    MCSY01              PROCEED IF YES
         L     RB,AWFM4            ELSE SET NO SYMBOL FLAG
         B     MCSYFT              AND RETURN
         SPACE
*.VARIABLE SYMBOL FOUND SEARCH PARAM DICTIONAY                        A
*.                                                                    A
MCSY01   EQU   *
         L     RC,MCPARPNT         GET PNTR TO PARAM LIST
         $CALL MACFND              SCAN PARAM DICT.
         LTR   RB,RB               SYMBOL F6UND?
         BNZ   MCSY02              IF NOT PROCEED WITH  GLOBAL SEARCH
         LA    RD,$SYMPAR          ELSE SET PARAMETER FLAG
         CLI   MCGLBTYP,C'S'       CHECK IF SYSTEM VARIABLE
         BNE   MCSYFT              RETURN IF NOT
         LA    RD,$SYSVAR          ELSE SET SYSTEM FLAG
         B     MCSYFT              AND RETURN
         SPACE
*.NOT IN PARM DICTIONARY, SEARCH GLOBAL DICTIONARY                    A
*.                                                                    A
MCSY02   EQU   *
         L     RC,AVMGDICT         GET PNTR TO GLOBAL DICTIONARY
         $CALL MACFND              SEARCH DICTIONARY
         LTR   RB,RB               SYMBOL FOUND?
         BNZ   MCSY03              PROCEED WITH PARAM SEARCH IF NOT
         CLC   MCGLBDEF,AVMMACID   GLOBAL DECLARED THIS DEFINITION?
         BNE   MCSY03              IF NOT, PROCEED AND SEARCH LOCAL DIC
         LA    RD,$GLOBAL          SET GLOBAL TYPE FLAG
         B     MCSYFT              AND RETURN
         SPACE
*.NOW CHECK LOCAL DICTIONARY                                          A
*.                                                                    A
MCSY03   EQU   *
         LA    RD,$LOCAL           SET LOCAL FLAG
         L     RC,MCDDVPNT         GET LOCAL DICT @
         $CALL MACFND              SEARCH LOCAL DICTIONARY
         LTR   RB,RB               SYMBOL FOUND?
         BZ    MCSYFT              IF YES, RETURN
         LR    RA,R0               ELSE RESTORE SCAN POINTER FIRST
MCSYFT   EQU   *
         XSNAP LABEL='***MCSYSR EXITED***',IF=(AVMSNBY1,O,$MSNP06,TM)
         $RETURN  RGS=(R14-R0)
         DROP  RAT,RC,RX,R13
         LTORG
         TITLE '***MCDTRM - CONVERTS DECIMAL TO BINARY***'
**-->  CSECT:  MCDTRM   DECIMAL CONSTANT CONVERSION.  MCDTRM DECIDES  *
*.        SCAN POINTER IS POINTING AT LEGAL DECIAMAL TERM AND IF SO,  *
*.        CONVERTS TO BINARY FORM. HANDLES VALUES UP TO 2**31-1       *
*.                                                                    *
*.        ENTRY CONDITIONS                                            *
*.     RA = @ OF FIRST CHAR OF TERM                                   *
*.                                                                    *
*.        EXIT CONDITIONS                                             *
*.     RA = @ OF DELIMITER BEYOND CONSTANT                            *
*.        = SAME AS ENTRY IF ERROR                                    *
*.     RB = 0 IF CONSTANT WAS LEGAL                                   *
*.        = $ER MSSGE IF ILLEGAL TERM                                 *
*.     RC = VALUE OF CONSTANT, 0 TO 2**31-1                           *
*.                                                                    *
*.        USES DSECTS: AVWXTABL                                       *
*.        USES MACROS: $SAVE, $RETURN                                 *
*.REGISTER USAGE                                                      A
*.R12 -BASE REG                                                       A
*.RAT-MAIN TABLE DSECT USING                                          A
*.RD- SCAN POINTER                                                    A
*.                                                                    A
*.NAMES=MCD_____                                                      A
*.                                                                    A
*** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 4
MCDTRM   CSECT
         $SAVE RGS=(R0-R2),SA=NO
         USING AVWXTABL,RAT        NOTE MAIN TABLE USING
         XSNAP LABEL='***MCDTRM ENTERED***',T=NO,IF=(AVMSNBY1,O,$MSNP06X
               ,TM)
         LR    RD,RA               COPY SCAN POINTER
         SR    R1,R1               USE IN TRT INST
         TRT   0(11,RD),AWTDECT    TRANSLATE WITH DEC TABLE
         BZ    MCDTRMR1            ERROR IF MORE THAN 10 DIGITS
         BM    MCDTRM01            < 10 DIGITS, PROCEED
         CLC   0(10,RA),=C'2147483647'  10 DIGIT NUMBER WITHIN RANGE?
         BH    MCDTRMR1            ERROR IF GREATER
MCDTRM01 EQU   *
         LR    RA,R1               UPDATE SCAN POINTER
         SR    R1,RD               GET LENGTH
         BZ    MCDTRMR1            ILLEGAL IF ZERO LENGTH
         BCTR  R1,0                GET LENGTH-1 FOR EX INST
         EX    R1,MCDECPAK         PACK CHARS
         CVB   RC,AVDWORK1         CONVERT THE NIMBER
         SR    RB,RB               SHOW NO ERRORS
MCDTRMRT EQU   *
         XSNAP LABEL='***MCDTRM EXITED***',IF=(AVMSNBY1,O,$MSNP06,TM)
         $RETURN  RGS=(R0-R2),SA=NO
MCDTRMR1 LA    RB,$ERSDINV         SET ILLEGAL NUMBER FLAG
         B     MCDTRMRT            AND RETURN
MCDECPAK PACK  AVDWORK1(8),0(0,RD)  PACK DEC CHARS
         LTORG
         DROP  RAT
         TITLE '***MCGTST - CHARSTRING STORE ROUTINE***'
**-->  CSECT:  MCGTST  THIS ROUTINE TAKES A STRING AS DELINEATED BY   *
*.        BEGINNING AND END POINTERS, OBTAINS STORAGE DYNAMICALLY AND *
*.        MOVES THE STING.  IF INSIDE QUOTES DOUBLE QUOTES WILL BE    *
*.        CRUNCHED TO ONE QUOTE                                       *
*.                                                                    *
*.        ENTRY CONDITIONS                                            *
*.     RA = @ OF FIRST CAHRACTER OF STRING                            *
*.     RB = @ OF DELIMITER PAST STRING                                *
*.                                                                    *
*.        EXIT CONDITIONS                                             *
*.     RA = @ OF DELIMITER PAST STRING                                *
*.     RC = @ OF STRING IN NEW STORAGE                                *
*.     RD = LENGTH OF STRING                                          *
*.                                                                    *
*.        USES MACROS: $SAVE, $RETURN, $ALLOCL                        *
*.        USES DSECTS: AVWXTABL                                       *
*.                                                                    *
*.   REGISTER USAGE                                                   A
*.       RAT-MAIN TABLE USING                                         A
*.       RA,RB,RC,RD-AS IN ENTR/EXIT CONDITIONS                       A
*.       RE,R1,R3-WORK REGISTERS                                      A
*** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 2
MCGTST   CSECT
         $SAVE RGS=(R0-R3),SA=NO
         USING AVWXTABL,RAT
         XSNAP LABEL='***MCGTST ENTERED***',IF=(AVMSNBY1,O,$MSNP06,TM)
         CR    RA,RB               NULL STRING?
         BE    MCGTSTF             SKIP OUT IF NULL STRING            S
         LR    RE,RB               COPY END DELIM
         SR    RE,RA               GET LENGTH
         LR    RD,RE               COPY LENGTH
         LA    RE,3(RE)            GET NEXT FULL WORD PLUS            A
         SRL   RE,2
         SLL   RE,2                TRUNCATE TO FULL WORD
         $ALLOCL  RC,RE,MCGTOVR    OBTAIN STORAGE FOR STRING
         LR    RE,RD               COPY ORIGINAL LENGTH
         BCTR  RE,0                DECR FOR EX INST
         EX    RE,MCGTMV           MOVE STRING INTO STORAGE
         TM    AVMBYTE1,$MINQUOT   INSIDE QUOTES?
         BNO   MCGTSTFT            IF NOT, RETURN
         LR    R1,RC               GET @ OF STIRNG START
         LR    R3,R1
         AR    R3,RE               GET @ OF END OF STRING
         BCTR  R3,0                DECR TO SECOND LAST CHAR
         LA    R2,1                USE R2 AS INDEX
MCGTST02 EQU   *
         CLI   0(R1),C''''         QUOTE?
         BCTR  RE,0                REDUCE RMNDR COUNT
         BE    MCGTST03            SQUEEZE QUOTE IF YES
         BXLE  R1,R2,MCGTST02      ELSE BUMP INDEX AND RESUME SCAN
          B    MCGTSTFT            ELSE RETURN IF SCAN FINISHED
MCGTST03 EQU   *
         EX    RE,MCGTMVC                                             A
         MVI   1(R3),C' '          INSERT BLANK AT END OF SQUZD STRNG
         BCTR  R3,0                DECR END OF STRING POINTER
         BCTR  RE,0                DECR REMAINING LENGTH
         BCTR  RD,0                REDUCE OVERALL LENGTH
         AR    R1,R2               BUMP SCAN POINTER                  A
         B     MCGTST02            RESUME SCAN
MCGTMVC  MVC   0($,R1),1(R1)       SQUEEZE OUT QUOTE                  A
         SPACE 2
MCGTSTF  LM    RC,RD,AWZEROS       ZERO OUT- NULL STRING              S
MCGTSTFT EQU   *
         LR    RA,RB               MOVE SCAN POINTER
         XSNAP LABEL='***MCGTST EXITED***',IF=(AVMSNBY1,O,$MSNP06,TM)
         $RETURN RGS=(R0-R3),SA=NO
         SPACE
MCGTOVR  L     R15,AVMOVRFL        GET @ OF OVERFLOW ROUTINE
         BR    REP                 BRANCH THERE
MCGTMV   MVC   0($,RC),0(RA)       MOVE STRING INTO STORAGE           A
         DROP  RAT
         LTORG
         TITLE '*** MCATRM - ATTRIBUTE PROCESSOR ***'
**-->  CSECT: MCATRM       THIS ROUTINE SCANS A TERM AND DETERMINES   *
*.        WHETHER IT IS A VALID ATTRIBUTE, IE I', K', L', N', S' OR T'*
*.        THE LENGTH (L'), SCALE (S') AND INTEGER (I') ATTRIBUTES ARE *
*.        NOT IMPLEMENTED AND ARE SO FLAGGED.                         *
*.                                                                    *
*.        ENTRY CONDITIONS                                            *
*.     RA = @ OF FIRST CHAR OF TERM                                   *
*.                                                                    *
*.        EXIT CONDITIONS                                             *
*.     RA = @ OF DELIM PAST QUOTE IF VALID ATTRIBUTE ELSE SAME AS     *
*.          ENTRY.                                                    *
*.     RB = 0 IF ATTRIBUTE                                            *
*.        = -4 IF NOT ATTRIBUTE                                       *
*.        = $ERMESSAGE IF NOT IMPLEMENTED                             *
*.     RC = TYPE OF ATTRIBUTE                                         *
*.                                                                    *
*.        USES MACROS: $SAVE, $RETURN                                 *
*.        USES DSECTS: AVWXTABL                                       *
*.                                                                    *
*.*********************************************************************
         SPACE 2
MCATRM   CSECT
         $SAVE RGS=(R14-R2),SA=NO
         USING AVWXTABL,RAT        NOTE MAIN TABLE USING
         XSNAP LABEL='***MCATRM ENTERED***',T=NO,IF=(AVMSNBY1,O,$MSNP06X
               ,TM)
         LM    RB,RC,AWZEROS       ZERO RB AND RC
*                                                                     A
         BCTR  RA,0                DECR POINTER
         TRT   0(1,RA),AWTSYMT     TEST PREV CHAR
         LA    RA,1(RA)            RESTORE POINTER
         BZ    MCATRMR1            NOT ATTRIBUTE IF PREV CHAR = ALPHA
         LA    RD,MCATTABL         GET @ OF ATTRIBUTE TABLE
MCATRMSC CLC   0(2,RA),0(RD)       COMPARE NEXT ENTRY
         BL    MCATRMR1            IF LOW, NOT FOUND, RETURN
         BE    MCATRMYS            IF EQUAL, FOUND
         LA    RD,4(RD)            ELSE BUMP TABLE POINTER
         B     MCATRMSC            TRY AGAIN
         SPACE
MCATRMYS IC    RB,3(RD)            SET PRESENCE FLAG
         IC    RC,2(RD)            SET TYPE
         CLI   3(RD),$ERNOIMP      IMPLEMENTED?
         BE    MCATRMRT            IF NOT, DON'T MOVE POINTER
         LA    RA,2(RA)            BUMP POINTER
         B     MCATRMRT
MCATRMR1 EQU   *
         L     RB,AWFM4            SET -4 FOR NO ATTIB
MCATRMRT EQU   *
         XSNAP LABEL='***MCATRM EXITED***',IF=(AVMSNBY1,O,$MSNP06,TM)
         $RETURN  RGS=(R14-R2),SA=NO
         SPACE 2
MCATTABL DC    C'I''',AL1($BSATI,$ERNOIMP),C'K''',AL1($BSATK,X'00')
         DC    C'L''',AL1($BSATL,$ERNOIMP),C'N''',AL1($BSATN,X'00')
         DC    C'S''',AL1($BSATS,$ERNOIMP),C'T''',AL1($BSATT,X'00')
         DC    X'FFFF'                                                A
         LTORG
         DROP  RAT,REP
         TITLE '***MCBODY - PROCESSES BODY OF MACRO DEFINITION***'
**-->  CSECT:  MCBODY   PROCESSES THE BODY OF MACRO DEFINITION.       *
*.        CALLED FORM MACRO1 AFTRR PROTOTYPE STATEMENT PROCESSED.     *
*.        INITIALIZES LOCAL DICTIONARY FOR CURRENT DEFINITION.        *
*.        PROCESSES EACH STATEMENT TILL MEND STATEMENT ENCOUNTERED.   *
*.        TERMINATES AND RETURNS AT THAT POINT                        *
*.                                                                    *
*.       IN OPEN-CODE MODE, ($MCOCFL1 ON IN MCLBFLG2),                *
*.       MCBODY ONLY PROCESSES STMT IN RSBLOCK                        *
*.       IF AVPRSAVE IS SET IN AVPRINT1, IT CALL MXMVSR               *
*.       TO SAVE STMT IN HIGH AREA, ELSE IT PRINTS IT IMMEDIATELY     *
*.        ENTRY CONDITIONS                                            *
*.     RC = @ OF MACLIB ENTRY OF CURRENT MACRO DEFINITION             *
*.                                                                    *
*.        USES MACROS: $SAVE,$RETURN,$CALL,$ALLOCL,$ALLOCH,$SCOF,     *
*.                     $SETRT                                         *
*.        USES DSECTS: AVWXTABL,MACLIB,MCLCLDPV,OPCODTB,RSBLOCK,MCBSU,*
*.                     MCSEQ,MCGLBDCT,MCOPQUAD                        *
*.        CALLS INCARD,ERRTAG,MACSCN,ERRLAB,MCVSCN,MACFND,SDDTRM,     *
*.              MCSYSR,MACLEX,MCGTST,OUTPT2,MCGNCD                    *
*.                                                                    *
*.  REGISTER USAGE *************************                          A
*.R13- BASE REGISTER AND SAVEAREA POINTER                             A
*.RAT-MAIN TABLE DSECT USING                                          A
*.RX- MACLIB DSECT USING                                              A
*.RY- LOCAL DICTIONARY DSECT UING                                     A
*.RZ-OPCODE TABLE DSECT USING                                         A
*.RB,RE,RA- WORK REGISTERS                                            A
*.R1,R2 USED IN TRT'S                                                 A
*.RET- RETURN REGISTER USED FOR INSUBS                                A
*.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 2
MCBODY   CSECT
         $SAVE RGS=(R14-R6),SA=*,BR=13
         USING AVWXTABL,RAT
         XSNAP LABEL='***MCBODY ENTERED***',IF=(AVMSNBY1,O,$MSNP07,TM)
         USING MACLIB,RX           SET USING FOR MACRO LIBRARY ENTRY
         LR    RX,RC               COPY @ OF MACLIB ENTRY
         USING MCLCLDPV,RY         SET USING FOR LOCAL DV ENTRY
         USING OPCODTB,RZ          SET USING FOR OPCODE TABLE ENTRY
         NI    AVMBYTE1,$MINDEF    CLEAR AVMBYTE1
         LM    R1,R2,AWZEROS       CLEAR R1 AND R2
         MVC   AVMCRINS,AWZEROS    ZERO PTR TO 1ST ONE-OP             J
         AIF   (NOT &$MACOPC).MCBODYA   SKIP IF NOT OPEN CODE         S
         TM    MCLBFLG2,$MCOCFL1   IN OPEN CODE ?                     S
         BO    MCBOD02             IF YES, SKIP DUMMY ENTRIES         S
.MCBODYA ANOP                                                         S
         LA    RB,$LLCLDV          GET LENGTH OF LOCAL DOPE VECTOR
         SPACE
*    THIS DUMMY ENTRY IN LOCAL DICT WILL BE USED FOR ACTR AND &SYSNDX
         $ALLOCL  RY,RB,MCBODOVR   GET AREA FOR ENTRY
         ST    RY,MCDDVPNT         SAVE @ IN MACLIB
         MVC   0($LLCLDV,RY),AWZEROS   CLEAR ENTRY
         MVI   MCLCLTYP,$ARITH     SET TYPE EQUAL TO ARITH FOR LENGTH
         MVI   MCLCLDIM+1,1        SET DIMENSION TO 1
         MVI   MCLOCDLN+3,4        INIT LENGTH OF DICT TO 4
         SPACE
*    DUMMY ENTRY FOR SEQUENCE SYMBOL TABLE
         USING MCSEQ,RE            SET USING FOR SEQ SYMBOL ENTRY
         LA    RB,$LMCSEQ          GET LENGTH OF ENTRY
         $ALLOCH RE,RB,MCBODOVR    OBTAIN AREA FOR ENTRY
         ST    RE,AVMSEQPT         SAVE @ IN MAIN TABLE
         MVC   0($LMCSEQ,RE),AWZEROS   ZERO ENTRY
         MVI   MCSEQFLG,X'FF'      SET DEFINED FLAG
         DROP  RE        CLEAR USING
         EJECT                                                        A
         USING RSBLOCK,RW          SET USING FOR SOURCE STMNT
MCBOD01  EQU   *
         AIF   (NOT &$MACOPC).MCBODYB   SKIP IF NOT OPEN CODE         S
         TM    MCLBFLG2,$MCOCFL1   IN OPEN CODE ?                     S
         BO    MACBODRT            RETURN IF YES                      S
.MCBODYB ANOP                                                         S
         L     RW,AVRSBPT          GET @ OF SOURCE STMNT
         $CALL INCARD              READ NEXT STATEMNT
         LTR   RB,RB               ERROR ON INPUT
         BZ    MCBOD02             JUMP ND PROCESS IF NOT
         $CALL ERRTAG              ELSE FLAG STMNT
         TM    AVTAGS2,$INEND2     END OF FILE?
         BO    MACBODRT            RETURN IF YES
MCBOD02  EQU   *
         LA    RA,RSBSOURC         SET SCAN POINTER
         ST    RA,MCBDSRPT         SAVE RSBSOURC @ FOR $SCOF USE
         MVI  AVMBYTE2,X'00'       ZERO FLAG BYTE 2
         MVI   AVMBYTE4,X'00'      CLEAR AVMBYTE4
         $CALL MACSCN              SCAN STMT
         C     RB,=F'8'            MACRO COMMENT?
         BE    MCBODPR1            JUMP AND PRINT IF YES
         LR    RZ,RC               COPY OPCODTB ENTRY @ INTO RZ
         DROP  RW                  DROP USING ON SOURCE IMAGE
         USING MCBSU,RW            SET UP USING ON BSU
         L     RW,AVMCHSTR         SET BASE FOR BSU WORKAREA
         MVC   MCBSU(8),AWZEROS    CLEAR FIRST BSU
         CLI   AVMFLDT2,C'M'       MACRO OPCODE?
         BE    MCBODJMP            IF YES, JUMP AND FIND WHICH OPCODE
         CLI   AVMFLDT2,C'I'       INNER MACRO INSTRUCTION?
         BNE   MCBODSTR            PROCESS MODEL STMT IF NOT          S
         AIF   (NOT &$MACOPC).MCBODYE   SKIP IF NOT OPEN CODE         S
         TM    MCLBFLG2,$MCOCFL1   IN OPEN CODE ?                     S
         BO    MCBODSTQ            PROCESS MODEL STMT (NO INNER MACS) A
.MCBODYE ANOP                                                         S
         B     MCBDINMC            PROCESS INNER MACRO                S
*  THIS SECTION GETS THE TYPE OF OPERATION AND BRANCHES TO THE        A
*  CODE TO PROCESS IT                                                 A
MCBODBAS DS    0H
MCBODJMP EQU   *
         SR    R2,R2               C3EAR R2 FOR INDEX ACTION
         IC    R2,OPCHEX           GET OPCODE INDEX
         LA    R1,MCFLGTAB(R2)     LOAD @ OF TABLE ENTRY              S
         MVC   *+7(1),1(R1)        MOVE MASK INTO NEXT TM INSTR       S
*              NOTE:  THE NEXT INST IS MODIFIED BY THE PREVIOUS INST  S
         TM    MCLBFLG2,$          TEST IF CARD OUT OF ORDER          S
         BO    MACMACRO            BRANCH IF CARD OUT OF ORDER        S
         OC    MCLBFLG2(1),0(R1)   SET CURRENT OPCODE FLAG            S
         LH    R1,MACBINDX(R2)     GET REL @ FROM TABLE
         B     MCBODBAS(R1)        JUMP TO ROUTINE
         SPACE 2
MACBINDX $AL2  MCBODBAS,(MACMACRO,MACGBLA,MACGBLB,MACGBLC,MACLCLA,MACLCX
               LB,MACLCLC,MACACTR,MACSETA,MACSETB,MACSETC,MACAIF,MACAGOX
               ,MACANOP,MACMNOTE,MACMEXIT,MACMEND),-2
         EJECT                                                        S
*        THIS MACRO FLAG TABLE IS USED TO EITHER SET OR TEST A FLAG   S
*        TO CHECK IF A MACRO OPCODE IS OUT OF ORDER.                  S
*        ......THE FIRST BYTE OF EACH TWO BYTE ENTRY CONTAINS THE     S
*              FLAG TO BE SET INTO MCLBFLG2 WHEN THE OPCODE IS        S
*              ENCOUNTERED.  THE SECOND BYTE IS USED TO TEST AGAINST  S
*              MCLBFLG2 TO SEE IF THE CURRENT OPCODE IS OUT OF ORDER. S
*                                                                     S
*                  SET , TEST          OPCODE                         S
*                  ---   ----          ------                         S
*                                                                     S
MCFLGTAB EQU   *-2                 ORIGIN OF HALF-WORD TABLE          A
         DC    AL1(0,$MGBLFLG)     MACRO                              A
         DC    AL1(0,$MGBLFLG)         GBLA                           S
         DC    AL1(0,$MGBLFLG)         GBLB                           S
         DC    AL1(0,$MGBLFLG)         GBLC                           S
         DC    AL1($MGBLFLG,$MLCLFLG)  LCLA                           S
         DC    AL1($MGBLFLG,$MLCLFLG)  LCLB                           S
         DC    AL1($MGBLFLG,$MLCLFLG)  LCLC                           S
         DC    AL1($MACTFLG,$MACTFLG)  ACTR                           S
         DC    AL1($MACTFLG,0)         SETA                           S
         DC    AL1($MACTFLG,0)         SETB                           S
         DC    AL1($MACTFLG,0)         SETC                           S
         DC    AL1($MACTFLG,0)         AIF                            S
         DC    AL1($MACTFLG,0)         AGO                            S
         DC    AL1($MACTFLG,0)         ANOP                           S
         DC    AL1($MACTFLG,0)         MNOTE                          S
         DC    AL1($MACTFLG,0)         MEXIT                          S
         DC    AL1($MACTFLG,0)         MEND                           S
         DROP  RY                  CLEAR TEMP USING OF RY
         SPACE 2
         TITLE '***MCBODY - GBLX ROUTINES***'
         USING MCGLBDCT,RY         ESTAB USING FOR GLOBAL ENTRY
MACGBLA  EQU   *
MACGBLB  EQU   *
MACGBLC  EQU   *
         BAL   RET,MCB01           CHECK FOR LABEL & OPERAND          J
MCGB04   EQU   *
         ST    RA,AVMTSCNP         COPY SCAN POINTER TEMPRORARILY
         $CALL MCVSCN              SCAN SYMBOL
         LTR   RB,RB               VARIABLE SYMBOL?
         BZ    MCGB05              PROCESS IF OKAY
*                                                                    AS
         LA    RB,$ERINVSY         SET ERROR FLAG IF RB^=0            A
         B     MCBDPRER            AND JUMP AN4 FLAG
*   AT THIS POINT LEGAL SET SYMBOL                                    A
MCGB05   EQU   *
         L     RC,MCPARPNT         GET PARAM LIST START @
         $CALL MACFND              SCAN PARAM LIST
         LTR   RB,RB               SYMBOL PRESENT
         BZ    MCGBMD              ERROR IF YES-QUIT                  A
*  LEGAL GLOBAL DECLARATION                                           A
         L     RC,AVMGDICT         GET GLOBAL DICT POINTER
         $CALL MACFND              SCAN GLOBAL DICT
         LR    RY,RC               MOVE DICT ENTRY TO REGULAR BASE
         LTR   RB,RB               SYMBOL PRESENT?
         BNZ   MCGB07              JUMP AND PROCESS IF NOT PRESENT
         CLC   MCGLBDEF,AVMMACID   ELSE IS IT PREV DEFINED THIS DEF?
         BE    MCGBMD              MULT DEF IF YES
         CLC   MCGLBTYP,AVMBYTE3   DO TYPES MATCH?
         BNE   MCGBMD              IF NOT, THEN ERROR
         LA    RC,1                SET DIMENSION=1 FOR NO DIMEN       A
         CLI   0(RA),C'('          SYMBOL DIMENSIONED?
         BNE   MCGB08              IF NOT, PROCEED
         BAL   RET,MCB02           GET DIMENSION                      J
MCGB08   EQU   *                   COME HERE TO CHECK SIZES=          A
         CH    RC,MCGLBDIM         DIMENSIONS M1TCH?
         BE    MCGB10              PROCEED IF YES
         B     MCGBMD              AND JUMP AND FLAG MULT DEF ERROR
         SPACE
MCGB07   EQU   *
         LA    RC,1                SET DIMENSION TO 1
         CLI   0(RA),C'('          DIMENSIONED?
         BNE   MCGB11              PROCEED WITH SINGLE DIM IF NOT
         BAL   RET,MCB02           GET DIMENSION                      J
         BAL   RET,MCB03           CHECK SIZE                         J
MCGB11   EQU   *
         LA    RB,$LGLBENT         GET LENGTH OF GLOBAL ENTRY
         $ALLOCL  RE,RB,MCBODOVR   GET AREA FOR ENTRY
         ST    RE,MCGLBNXT         SAVE POINTER IN PREV ENTRY
         LR    RY,RE               MOVE BASE TO NEW ENTRY
         MVC   MCGLBNXT($LGLBENT),AWZEROS   CLEAR NEW ENTRY
         MVC   MCGLBLEN(9),AVMSYMLN  MOVE SYMABOL INTO ENTRY
         MVC   MCGLBTYP,AVMBYTE3   SAVE TYPE IN ENTRY
         STH   RC,MCGLBDIM         SAVE DIMENSI6N IN ENTRY
         SR    RE,RE               CLEAR RE
         IC    RE,AVMBYTE3         PLACE TYPE LENGTH IN RE
         CLI   AVMBYTE3,$CHAR      WAS IT CHARACTER?
         BE    MCGB12              IF YES , PROCEED WITH LENGTH OF 12
         LA    RE,4                ELSE USE LNG OF 4 FOR BOOL & ARITH A
MCGB12   LH    RD,MCGLBDIM         GET DIMENSION OF ARRAY
         SR    R0,R0               CL1R R0 FOR USE IN LOOP
MCGB13   EQU   *
         $ALLOCL  RB,RE,MCBODOVR   GET AREA FOR ELEMENT
         ST    R0,0(RB)            INITIALIZE TO ZERO
         BCT   RD,MCGB13           LOOP BACK IF NOT FINISHED
         SPACE 2
MCGB10   EQU   *
         MVC   MCGLBDEF,AVMMACID   SAVE CURRENT DEF ID
         CLI   0(RA),C' '          END OF OPRND LIST?
         BE    MCBODPR             JUMP AND PRINT IF YES
         CLI   0(RA),C','          PROPER DELIMITER?
         BNE   MCGBINVD            INVALID DELIM-GO FLAG              A
         LA    RA,1(RA)            BUMP SCAN POINTER PAST ','
         B     MCGB04              AND RESUME SCAN
         DROP  RY                  CLEAR RY USING AFTER GLOBAL USE
         TITLE '***MCBODY - LCLX ROUTINES***'
         USING MCLCLDPV,RY         USE RY AS BASE FOR LOCAL ENTRIES
MACLCLA  EQU   *
MACLCLB  EQU   *
MACLCLC  EQU   *
         BAL   RET,MCB01           CHECK FOR LABEL & OPERAND          J
MCLC04   EQU   *
         ST    RA,AVMTSCNP         COPY SCAN POINTER
         $CALL MCVSCN              SCAN FOR LEGAL VAR SYMBOL
         LTR   RB,RB               OKAY?
         BNZ   MCBDPRER            IF NOT, JUMP AND FLAG
         LR    R0,RA               COPY NEW SCAN POINTER VALUE TEMP
         L     RA,AVMTSCNP         GET ORIGINAL SCAN POINTER
         $CALL MCSYSR              SEARCH ALL DICTS FOR SYMBOL
         LTR   RB,RB               PRESENT ALREADY?
         BZ    MCGBMD              GO FLAG MULTIPLE DEFINITION        A
         LR    RA,R0               RESTORE SCAN POINTER
         LR    RY,RC               MOVE BASE TO USING REG RY
         LA    RB,$LLCLDV          GET LENGTH OF LCAL DV
         $ALLOCL  RE,RB,MCBODOVR   GET AREA FOR ENTRY
         MVC   0($LLCLDV,RE),AWZEROS   ZERO OUT ENTRY
         ST    RE,MCLOCNXT         SAVE POINTER IN PREV ENTRY
         LR    RY,RE               MOVE BASE TO NEW ENTRY
         MVC   MCLCLLEN(9),AVMSYMLN  MOVE NAME INTO NEW ENTRY
         MVC   MCLCLTYP,AVMBYTE3   ESTABLISH TYPE OF SET SYMBOL ENTRY
         MVC   MCLCLDIM,AWH1       SET DIM = 1 FOR PRESENT
         CLI   0(RA),C'('          DIMENSIONED?
         BNE   MCLCFT              IF NOT, PROCEED
         BAL   RET,MCB02           GET DIMENSION                      J
         SPACE
MCLC07   EQU   *
         BAL   RET,MCB03           CHECK DIMENSION SIZE               J
MCLC08   EQU   *
         STH   RC,MCLCLDIM         SET DIMENSION IN ENTRY
MCLCFT   EQU   *
         LA    R1,4                ASSUME LENGTH = 4
         TM    MCLCLTYP,$CHAR      TEST FOR TYPE
         BNO   MCLC11              SKIP IF NOT CHAR
*        ASSEMBLER G CAHRACTER DECL WILL CHANGE FOLLOWING.
         LA    R1,12               ELSE USE CHAR LENGTH OF ENTRY
MCLC11   EQU   *
         MH    R1,MCLCLDIM         GET TOTAL SIZE OF ARRAY
         L     RE,MCLOCDLN         GET CURRENT OFFSET/LENGTH          A
         ST    RE,MCLCLPNT         STORE AS OFFSET TO THIS VAR        A
         AR    R1,RE               UPDATE TOTAL DICT LENGTH           A
         ST    R1,MCLOCDLN         SAVE LENGTH OF LOCAL DICT IN MACLIB
         SPACE 1                                                      A
         CLI   0(RA),C' '          WAS THIS LAST ONE?                 A
         BE    MCBODPR             YES QUIT AND PRINT                 A
         CLI   0(RA),C','          OK DLM                             A
         BNE   MCGBINVD            NO, ERROR KILL IT                  A
         LA    RA,1(,RA)           BUMP SCAN PTR TO NEXT OPRND        A
         B     MCLC04              RETURN FOR NEXT OPRND              A
         DROP  RY                  DROP TEMP USING OF RY FOR LOCALS
         EJECT                                                        A
**--> INSUB: MCB01      CHECK LCLX,BLX FOR LABEL, OPCODE  + + + + + + J
*+                                                                   +A
*+    THIS IS CALLED TO CHECK FOR AN ERROR IN THE GBLX OR             A
*+       GBLX INSTRUCTION. IF AN ERROR OCCURES WHEN A LABEL IS PRESENTA
*+       AND/OR THERE IS NO OPERANDS.                                 A
*+                                                                    A
*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +A
         SPACE 2                                                      A
MCB01    EQU   *                                                      J
         MVC   AVMBYTE3,OPCMASK    GET TYPE OF SET SYMBOL             A
         CLI   AVMFLDL1,0          CHECK IF LABEL PRESENT(L^=0)       A
         BE    MCB001              IF NOT PROCEED                     J
         ST    RET,MCB##SAV        SAVE THE RETURN @                  J
         LA    RB,$ERILLAB         ELSE SET ERROR FLAG                A
         $CALL ERRLAB              AND FLAG STMT                      A
         L     RET,MCB##SAV        RESTORE RETURN @                   J
MCB001   EQU   *                                                      J
         L     RA,AVMFLD3          GET @ OPERAND; =0 IF NONE          A
         LTR   RA,RA               DID ONE EXISTS                     A
         BCR   NZ,RET              YES-RET, NORMAL CASE               A
         B     MCBDOPER            NO-ERROR-MISSING OPERAND           A
         SPACE 5                                                      A
**--> INSUB: MCB02      OBTAIN DIMENSION OF GBLX OR LCLX STMT + + + + J
*+       BUNPS POINTER GETS DIMENSION AND FLAGS ERROR IF NOT CONST   QA
*+ RA= @ '(' ON ENTRY; @ BEYOND '(' ON EXIT IF GOOD                   A
*+  RC=VALUE OF SUBSCRIPT IF GOOD                                     A
*+ + + + + + + + + + ++  + + + + + + + + + + + + + + + + + + + + + + +A
         SPACE 5                                                      A
MCB02    ST    RET,MCB##SAV        SAVE RETURN @                      J
         LA    RA,1(RA)            BUMP PTR PAST )                    J
         $CALL SDDTRM              AND GET DIMENSION                  A
         LTR   RB,RB               DIMENSION=CONSTANT?                A
         BNZ   MCBDPRER            FLAG ERROR IF NOT                  A
         CLI   0(RA),C')'          CURRENT ENDING DLM                 A
         BNE   MCGBINVD            NO ERROR                           A
         LA    RA,1(,RA)           YES BUMP BEYOND )                  A
         L     RET,MCB##SAV        RESTORE RETURN @                   J
         BR    RET                 RETURN                             A
         SPACE 5                                                      A
**--> INSUB: MCB03: CHECK DIMENSION SIZE FOR GBLX,LCLX+ + + + + + + + J
*+       CHECKS TO MAKE SURE DIMENSION OF                           + A
*+       GBLX AND/OR LCLX IS WITHIN RANGE                           + A
*+       FLAGS ERROR IF NOTS WITHIN RANGE                           + A
*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +  A
         SPACE 2                                                      A
MCB03    C     RC,=F'2500'         DIMENSION WITHIN RANGE?            J
         BCR   NH,RET              RETURN IF NOT                      J
         LA    RB,$EREXGTA         ELSE SET ERROR FLAG                A
         B     MCBDPRER            AND FLAG STMT                      A
         TITLE '***MCBODY - SET INSTRUCTION ROUTINES***'
*                                                                     A
* SETX SYMBOLS FOUND, SET FLAG FOR TYPE & CONTINUE SCAN OF EXPRESSION A
*                                                                     A
MACSETA  EQU   *
         MVI   AVMBYTE3,$ARITH      SET ARITH TYPE FLAG
         B     MACSET
MACSETB  EQU   *
         MVI   AVMBYTE3,$BOOL       SET BOOLEAN FLAG
         B     MACSET
MACSETC  EQU   *
         MVI   AVMBYTE3,$CHAR       SET CHARACTER TYPE FLAG
*                                                                     A
*  CKECK FOR LEGAL SETUP IE, NO OPERAND ERRORS, NO LABEL              A
* ON STATEMENT, ERROR IF LOOKS LEGAL, GO ON ELSE FLAG ERROR           A
*                                                                     A
MACSET   EQU   *
         BAL   RET,MCB001          CHECK FOR OPERND,GET@              A
         L     RA,AVRSBPT          GET SOURCE BLOCK ADDRESS
         LA    RA,4(RA)            BUMP TO SOURCE STMNT
         CLI   AVMFLDL1,X'00'      LABEL PRESENT?
         BNE   MCBDST03            PROCEED IF YES
         LA    RB,$ERNONAM         SET MISSING LA&EL FLAG
         B     MCBDPRER            JUMP AND FLAG ERROR
* GET THE BSU ADDRESS SET TYPE & IF NEITHER OF THE SET TYPES-ERROR    A
*                                                                     A
MCBDST03 EQU   *
         LR    RC,RW               SET POINTER TO BSU
         $CALL MACLEX              SCAN LABEL FIELD
         LTR   RB,RB               ERROR?
         BNZ   MCBDPRER            JUMP OUT IF YES
         LR    RW,RC               RESTORE BSU POINTER
         L     RE,AVMCHSTR         GET @ OF BSU WORKAREA
         CLI   AVMBYTE3,$BOOL      IS SET A, B, OR C
         BH    MCSETCHR            CHR IF HIGHER
         BE    MCSETBOL            BOOLEAN IF EQUAL
         OI    AVMBYTE2,$MINARIT   ELSE IS ARITHMETIC
         MVI   MCBSINDX,$BSETA     SET BSU INDEX FOR SETA
         CLI   1(RE),$BSTSYAG      IS IT GLOBAL ARITH SET SYSMB?
         BE    MCBDST01            IF YES, OKAY
         CLI   1(RE),$BSTSYAL      ELSE IS IT LOACAL ARITH SET SYMBOL?
         BE    MCBDST01            IF YES, OKAY
         B     MCLMXDER            ELSE FLAG ERROR
*                                                                     A
*  CHECKS THE FORMAT OF SETB-MAKE SURE ITS 0 OR 1, PARENS LEGAL       A
*   THEN CHECKS FOR GLOBAL OR LOCALS                                  A
*                                                                     A
MCSETBOL EQU   *
         L     RA,AVMFLD3          GET OPERAND @
         CLI   0(RA),C'('          STARTS WITH LEFT PAREN?
         BE    MCSETB01            OKAY IF YES
         CLI   0(RA),C'1'          OPERAND = 1?
         BE    MCSETB01            OKAY IF YES
         CLI   0(RA),C'0'          OPERAND = 0?
         BE    MCSETB01            OKAY IF YES
         LA    RB,$ERINVF          ELSE SET INVALID FIELD FLAG
         B     MCBDPRER            JUMP AND FLAG STMTN
MCSETB01 EQU   *
         OI    AVMBYTE2,$MINBOOL   SET BOOLEAN FLAG
         MVI   MCBSINDX,$BSETB     SET BSU INDEX
         CLI   1(RE),$BSTSYBG      IS IT BOOLEAN GLOBAL SET?
         BE    MCBDST01            OKAY IF YES
         CLI   1(RE),$BSTSYBL      ELSE IS IT BOOLEAN LOCAL SET?
         BE    MCBDST01            OKAY IF YEW
         B     MCLMXDER            ELSE FLAG EROR
*                                                                     A
* CHECK FOR LEGAL SETC SYMBOL                                         A
*                                                                     A
MCSETCHR EQU  *
         MVI   MCBSINDX,$BSETC     SET BSU INDEX
         OI    AVMBYTE2,$MINCHAR   SET CHAR FLAG
         CLI   1(RE),$BSTSYCG      IS IT CHAR GLOBAL SET SYMBOL?
         BE    MCBDST01            OKAY IF YES
         CLI   1(RE),$BSTSYCL      ELSE IS IT CHAR LOCAL SET?
         BNE   MCLMXDER            ERROR IF NOT
MCBDST01 EQU  *
*                                                                     A
* SETS HIERARCHY OF BSU, SETS FLAGA & MOVES ADRESS THEN SCANS         A
*  THE OPERAND, IF IN ERROR, FLAGS IT                                 A
*                                                                     A
         MVI   MCBSHIER,$MSETHR    SET HEERARCHY
         OI    MCBSFLGS,$MOPRTR    SET OPERATOR FLAG IN BSU
         L     RA,AVMFLD2          GET @ OF OPCODE
         $SCOF  RB,RA,MCBSOFST     GET OPCODE @ INTO BSU
         BAL   RE,MCBDBMP          BUMP BSU POINTER
         LR    RC,RW               MOVE BSU POINTER TO RC
         L     RA,AVMFLD3          GET ADDRESS OF OPERAND
         $CALL MACLEX      SCAN OPERAND
         LTR  RB,RB                ERROR
         BNZ  MCBDPRER             FLAG STMNT IF YES
         B     MCBODPR             JUMP TO FOOT
         TITLE '***MCBODY - AGO,AIF, MNOTE ETC ROUTINES***'
*  WHEN AN ACTR STATEMENT FOUND, SETS FLAG FOR NO MORE GLOBALS OR     A
*  LOCALS. SEES IF ACTR STMT OK, THEN CHECKS IF LABEL PRESENT(ERROR)  A
* CHECKS FOR OPERANDS(ERROR IF NOT THERE) SETS INDEX(COUNTER) & SETS  A
* UP THE BSU.                                                         A
*                                                                     A
MACACTR  EQU   *
         BAL   RET,MCB01           CHECK OPRND @ EXISTENCE            A
         MVI   MCBSFLGS,$MTERM+$BSAR    SET BSU FLAGS
         MVI   MCBSINDX,$BSTSYAL   SET LOCAL ARITH SET INDEX
         MVC   MCBSLOC,MCDDVPNT    MOVE @ OF ACTR TO BSU
         BAL   RE,MCBDBMP          BUMP BSU
         L     RD,MCBDSET          CREATE BSU                         S
         BAL   RE,MCBDBMP0         BUMP BSU POINTER                   S
         OI    AVMBYTE2,$MINARIT   SET ARITH EXPRESSION FLAG
         LR    RC,RW               GET BSU POINTER
         $CALL MACLEX              SCAN EXPRESSION
         LTR   RB,RB               ERROR?
         BNZ   MCBDPRER            FLAG IF YES
         LR    RW,RC               RESTORE BSU POINTER
         B     MCBODPR             JUMP AND PRINT STMNT
         SPACE 2
* AIF FOUND, CHECK FOR LEGAL SEQUENCE, NO LCLX OR GBLX, AND SYNTAX    A
*  MUST START WITH ( AND HAVE SEQ SYMB FOLLOWING, THEN SETS UP THE    A
*  BSU WITH THE ADDRESSES.                                            A
*                                                                     A
MACAIF   EQU   *
         BAL   RET,MCBDCHLB        CHECK FOR LEGAL LABEL
         BAL   RET,MCB001          CHECK OPRND @ EXISTENCE            A
         CLI   0(RA),C'('          FIRST CHAR = '('?
         BE    MACAIF01            PROCEED IF YES
         LA    RB,$ERVSYNT         SET SYNTAX FLAG
         B     MCBDPRER            AND FLAG ERROR
MACAIF01 EQU   *
         OI    AVMBYTE2,$MINPEXP+$MINBOOL  SET FLGS FOR PAREN SCAN
         LR    RC,RW               GET BSU POINTER
         $CALL MACLEX              SCAN OPERAND
         LR    RW,RC               RESTORE BSU POINTER
         LTR   RB,RB               ERROR?
         BNZ   MCBDPRER            FLAG IF YES
         CLI   0(RA),C'.'          SEQ SYMBOL AFTER EXPRESSION?
         BNE   MCBDISER            ERROR IF NOT
         MVC   MCBSFLGS(4),MCBDAIF                                    A
         L     R2,AVMFLD2          GET OFFSET OF OPCODE
         $SCOF R1,R2,MCBSOFST      INSERT OFFSET IN BSU
         BAL   RE,MCBDBMP          BUMP BSU
         L     RD,MCBDLABL         GET FIRST HALF OF BSU              A
*                                                                     A
         B     MACAGO03                                               S
         SPACE 2
* SAME THING WITH AGO, CKS SYNTAX, LEGAL SEQ, ETC AND SETS UP         A
* THE BSU                                                             A
*                                                                     A
MACAGO   EQU   *
         BAL   RET,MCBDCHLB        CHECK FOR LEGAL CLABEL
         BAL   RET,MCB001          CHECK OPRND GET @                  A
         CLI   0(RA),C'.'          POSSIBLE SEQ SYMBOL?
         BE    MACAGO02            PROCEED IF YES
         LA    RB,$ERINVSY         ELSE SET BAD SYMBOL FLAG
         B     MCBDPRER            AND FLAG STATEMNT
MACAGO02 EQU   *
         L     RD,MCBDAGO          CREATE BSU                         S
MACAGO03 ST    RA,MCBSLOC          SAVE @ OF LABEL                    S
         B     MCBODPR0            PRINT STATEMENT                    S
         SPACE 2
MACANOP  EQU   *
         MVI   MCBSINDX,$BSANOP    INSERT BSU ANOP INDEX
         B     MACAMM
MACMEXIT EQU   *
         MVI   MCBSINDX,$BSMEXIT   SET MEXIT BSU
         B     MACAMM
MACMEND  EQU   *
         MVI   MCBSINDX,$BSMEND    SET MEND BSU INDEX
MACAMM   EQU   *
         BAL   RET,MCBDCHLB        CHECK FOR LEGAL LABEL
         MVI   MCBSFLGS,$MOPRTR    SET OPRTR FLAG
         MVI   MCBSHIER,$MPRNTHR   SET PRINT HIERARCHY
         L     RA,AVMFLD2          GET OPCODE @
         $SCOF RB,RA,MCBSOFST      PUT OFFSET IN BSU
         BAL   RE,MCBDBMP          BUMP BSU POINTER                   A
         B     MCBODPR                                                A
         SPACE 2
* MNOTE STMT FOUND, CKS FOR VALID SYNTAX, CREATES BSU. SCANS STRING   A
*  FOR MESSAGE, ALSO CHECKING SYNTAX(INVALID DELIM ETC) CONCATS IFL   A
* NECESSARY                                                           A
*                                                                     A
MACMNOTE EQU   *
         BAL   RET,MCBDCHLB        CHECK FOR LABEL
         CLI   AVMFLDL3,X'00'      OPRND PRESENT?
         BE    MCBDOPER            ERROR IF NOT
         BAL   RET,MCBDPFLC        CREATE PRINT BSU AND BUMP PTR      F
         MVC   MCBSU(8),MCBDSTG1   COPY WHOLE BSU FROM TABLE          J
         BAL   RE,MCBDBMP          BUMP BSU POINTER
         L     RA,AVMFLD3          GET OPRND @
         BAL   RET,MCBDPFLC        CREATE PRINT BSU AND BUMP PTR      F
         CLI   0(RA),C''''         QUOTED STRING?
         BNE   MCMNOT01
         MVC   MCBSU(8),MCBDSTG2   COPY WHOLE BSU= '1,' BSU           J
         BAL   RE,MCBDBMP
         NI    AVMBYTE2,255-($MTERM+$MOPRTR)  TURN OFF PREV IND FLAG
         OI    AVMBYTE2,$MTERM     SET TERM PREV FLAG
         B     MCMNOT04
MCMNOT01 EQU   *
         $SETRT  (',',4,'''',8)    SET TABLE FOR SCAN
         SR    RE,RE
         IC    RE,AVRSBLOC         GET LENGTH-1
         S     RA,AVRSBPT           GET OFFSET OF RA
         SR    RE,RA               SUBTRACT OVERALL LENGTH
         A     RA,AVRSBPT          RESTORE RA
         EX    RE,MCMNOTSC
         $SETRT  (',',0,'''',0)    RESTORE TABLE
         BNZ   MCMNOT02            PROCEED IF SCAN STOPPED ON CHAR
MCMNOTER EQU   *
         LA    RB,$ERNODLM         ELSE SET BAD DELIM FLAG
         B     MCBDPRER            AND FLAG STMT
MCMNOT02 EQU   *
         CLI   0(R1),C','          STOP ON COMMA?
         BNE   MCMNOTER            ERROR IF NO
         LA    RB,1(R1)            GET DELIM @
         SR    RB,RA               GET LENGTH IN RB
         BAL   RET,MCBDSCAN        SCAN SEVERITY EXPRESSION
MCMNOT04 EQU   *
         CLI   0(RA),C''''         QUOTE?
         BNE   MCMNOTER            ERROR IF NOT
         BAL   RET,MCBDCATI        INSERT CAT OPRTR
         OI    AVMBYTE2,$MINCHAR   SET CHAR STRING FALG
         LR    RC,RW               GET BSU PNTR
         $CALL MACLEX              SCAN STRING
         LR    RW,RC               BUMP BSU PNTR
         LTR   RB,RB               ERROR
         BNZ   MCBDPRER            FLAG IF YES
         MVI   AVMFLDT2,X'00'      ZERO TYPE BYTE
         L     RD,MCBDPR2          CREATE BSU                         S
         L     RA,AVMFLD3          GET OPRND @
         CLI   0(RA),C'*'          COMMNET?
         BE    MCBODPR0            SKIP IF YES                        S
         L     RD,MCBDPR3          MNOTE BSU                          A
         B     MCBODPR0            PRINT STATEMENT                    S
MCMNOTMS DC    CL12'***MNOTE***'
MCMNOT1C DC    C'1,'               DEFAULT MNOTE SEVERITY             J
MCMNOTSC TRT   0($,RA),AWTZTAB     DUMMY FOR COMMA QUOTE SCAN
         SPACE 2
MACMACRO EQU   *
         L     RA,AVMFLD2          GET OPCODE @ IN RA
         LA    RB,$ERSTMNA         SET STMNT NO GOOD FLAG
         B     MCBDPRER            JUMP AND FLAG ERROR
         TITLE '***MCBODY - STRING, INNER MACRO AND OPCODE ROUTINES***'
* CHECKS COMMENT, SETS PRINT BSU IF STMT SHOULD BE PRINTED AND/OR     A
*        DOESN'T PRINT SEQ SYMBOLS IN MACRO, OR MACRO COMMENTS. ALSO  A
* MOVES OPCODE DATA IN IF PRESENT                                     A
*                                                                     A
MCBODSTQ EQU   *                                                      A
         MVI   AVMFLDT2,0          OPEN CODE FAKE FOR MODEL STMT      A
MCBODSTR EQU   *
         C     RB,AWF4             COMMENT?
         BE    MCBODCOM            ORDINARY COMMENT IF EQUAL
         OI    MCLBFLG2,$MACTFLG   GLBL'S, ETC. NO LONGER OK          S
MCBDSTIN EQU   *
         CLI   AVMFLDT1,C'.'       SEQ SYMBOL?
         BE    MCBDOPCD            PROCESS OPCODE IF YES
         L     RA,AVMFLD1          ELSE GET PNTR TO LABEL FIELD
         LTR   RA,RA               LABEL PRESENT
         BZ    MCBDOPCD            PROCESS OPCODE IF NOT
         BAL   RET,MCBDPFLC        CREATE PRINT BSU, NON COMMENT TYPE A
         IC    RB,AVMFLDL1         GET LENGTH OFLABEL FIELD
         SR    RC,RC               SET TERMINAL CHAR INDICATOR        S
         BAL   RET,MCBDSCAN        SCAN LABEL FIELD
MCBDOPCD EQU   *
         CLI   AVMFLDL2,X'00'      OPCODE EXISTS?
         BE    MCBDSFIN            FINI IF NOT
         MVC   MCBDFLDS(5),AVMFLD2 ELSE MOVE OPCODE FIELD DATA
         SR    RC,RC               INDICATE VAR SYMBOLS PRESENT
         BAL RET,MCBDSCFD          SCAN OPCODE FIELD
*                                                                     A
* SCANS OPERAND FIELD ALLOWING FOR NON-STANDARD CONTINUATIONS         A
* THAT IS RUNNINF ACROSS UP TO 3 CARDS, BALS TO MCBDSCFD TO TEST FOR  A
*THE DIFFERENT FIELDS.                                                A
*                                                                     A
MCBDOPRN EQU   *
         MVC   MCBDFLDS(5),AVMFLD3   GET DATA FOR OPRND FILED
         SR    RC,RC               CLEAR RC FOR VAR SYMBOLS
         BAL   RET,MCBDSCFD        SCAN OPRND FILED
         MVC   MCBDFLDS(5),AVMFLD4  GET DATA FOR COMMENT FIELD
         LA    RC,4                INDICATE NO VAR SYMBOLS
         BAL   RET,MCBDSCFD        SCAN COMMNET FIELD
         CLI   AVMFLDL5,0          2ND NON STND CARD?
         BE    MCBDSFIN            FINI IF NOT
         MVC   MCBDFLDS(5),AVMFLD5   GET DATA ON 2ND CARD OPRND
         SR    RC,RC               INCICATE VAR SYMBOLS
         BAL   RET,MCBDSCFD        SCAN OPNRD ON 2ND CARD
         MVC   MCBDFLDS(5),AVMFLD6   GET DATA ON COMMNET FIELD( IF ANY)
         LA    RC,4                INDICATE NO VAR SYMBOLS
         BAL   RET,MCBDSCFD        SCAN COMMNET FIELD
         CLI   AVMFLDL7,0          3RD NON STND CARD?
         BE    MCBDSFIN            FINI IF NOT
         MVC   MCBDFLDS(5),AVMFLD7   GET DATA ON OPRND
         SR    RC,RC               INDICATE VAR SYMBOLS
         BAL   RET,MCBDSCFD        SCAN OPRND
         LA    RC,4                INDICATE NO VAR CYMBOLS
         BAL   RET,MCBDSCFD        SCAN 3RD CARD COMMENT(IF ANY)
*                                                                     A
*  END OF STATEMENT  TEST FOR POSSIBLE INNER MACRO CALL, PROCESS      A
*   ELSE, BUMP BSU POINTER, PRINT LINE, AND CONTINUE                  A
*                                                                     A
MCBDSFIN EQU   *
         L     RD,MCBDPR2          CREATE BSU                         A
         CLI   AVMFLDT2,C'I'       INNER MACRO CALL
         BNE   MCBODPR0            SKIP OUT IF NOT INNER MACRO CALL   A
         L     RD,MCBDINMA         GET INNER MACRO BSU                A
         B     MCBODPR0            PRINT STATEMENT                    S
         SPACE 2
**--> INSUB:MCBDFLD   CREATES A PRINT BSU+ + + + + + + + + + + + + + +A
*+                                                                   +A
*+  CALLED TO CREATE A BSU SO STMT WILL BE PRINTED. IT ALSO          +A
*+  BUMPS THE BSU POINTER                                            +A
*+                                                                   +A
*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +A
         SPACE 2                                                      A
MCBDPFLC SR    RC,RC               ENTRY NON COMMENT TYPE PRINT BSU   A
MCBDPFLD EQU   *
         LR    RD,RA               COMPUT OFFSET                      A
         S     RD,MCBDSRPT                                            A
         SLL   RD,8                MOVE TO RIGHT BYTE                 A
         AL    RD,MCBPRBSU(RC)     GET PRINT BSU OR PRINT/COMMENT BSU A
         NI    AVMBYTE2,255-($MTERM+$MOPRTR)  TURN OFF PREV IND FLAG
         OI    AVMBYTE2,$MOPRTR    SET PREV INDICATOR TO OPRTR
         BAL   RE,MCBDBMP0         BUMP BSU POINTER                   A
         BR    RET
         SPACE 2
**--> INSUB:MCBDSCFN     LOOKS FOR FIELDS  + + + + + + + + + + + + + +A
*+                                                                   +A
*+  SCAN FIELDS IN STMT, CREATES BSU'S, IF ONE EXISTS.  RETURNS       S
*+  THE LENGTH AND ENDING ADDRESS.                                   +A
*+                                                                   +A
*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +A
         SPACE 2                                                      A
MCBDSCFD EQU   *
         ST    RET,MCBDSAVE        SAVE RETURN @
         L     RA,MCBDFLD          GET POINTER TO FIELD
         LTR   RA,RA               FIELD EXISTS?
         BZ    MCBDSCFN            FINI IF NOT
         SR    RB,RB               CLEAR RB TO CARRY LENGTH
         IC    RB,MCBDFLDL         GET LENGTH OF FIELD
         BAL   RET,MCBDPFLD        CREATE BSU
         BAL   RET,MCBDSCAN        SCAN FIELD
MCBDSCFN EQU   *
         L     RET,MCBDSAVE        RESTORE RETURN @
         BR    RET                AND RETURN
MCBDSAVE DS    F                   CORE FOR RETURN @
MCBDFLDS DS    0F                  TEMP STORAGE FOR FIELD INFO
MCBDFLD  DS    F                   POINTER TO FILED
MCBDFLDL DS    C                   LENGTH OF FIELD
MCBDFLDT DS    C                   TYPE OF FIELD
         SPACE 2
*                                                                     A
* PROCESSES INNER MACRO CALLS  MOVES OPCODE IN FIELD, SEARCHES        A
*  FOR NAME IF LIBRARY, IF NOT THERE, MAKES NOTE OF REFERENCE FOR LATEA
*  SEARCH OR POSSIBLE ERROR                                           A
MCBDINMC EQU   *
         OI    MCLBFLG2,$MACTFLG   GLBL'S, ETC. NO LONGER OK          S
         SR    R2,R2               CLEAR R2 FOR EX INST
         L     R1,AVMFLD2          GET OPCODE @
         IC    R2,AVMFLDL2         GET LENGTH OF OPCODE
         BCTR  R2,0                DECR BY ONE FOR EX INST
         MVC   AVMSYMBL,AWBLANK    CLEAR PREVIOUS NAME
         EX    R2,MCBDINM1         MOVE OPCODE TO AVMBL               A
         MVC   AVMSYMLN,AVMFLDL2   MOEE LENGTH
         USING MACLIB,RC
         L     RC,AVMACLIB         GET @ OF MACLIB
         $CALL MACFND              SEARCH MACRO LIBRARY
         LTR   RB,RB               SYMBOL FOUND?
         BZ    MCBDSTIN            PROCESS IF YES IN STRING CODE
         LA    RE,$LMACLIB         GET LENGTH OF MACLIB ENTRY
         $ALLOCL RD,RE,MCBODOVR    GET SPACE FOR ENTRY
         ST    RD,MCLIBNXT         SAVE LINK IN PREV ENTRY
         LR    RC,RD               MOVE BASE TO RC
         MVC   MACLIB($LMACLIB),AWZEROS ZERO NEW ENTRY
         MVC   MCLBNMLN(9),AVMSYMLN     MOVE NAME INTO LIB ENTRY
         B     MCBDSTIN
MCBDINM1 MVC   AVMSYMBL($),0(R1)   DUMMY FOR EXECUTE INSTRUCTION      A
         DROP  RC                  CLEAR USING
         SPACE 2
MCBDSCAN EQU   *
**--> INSUB:MCBDSCAN  SCANS STATEMENTS IN A MOCOR DEFINITION + + + + +A
*+                                                                   +A
*+  SETS DIFFERENT TRT TABLES UP DEPENDING ON WHERE CALLED FORM      +A
*+   IN ROUTINE                                                      +A
*+  CHECKS BSU LIST AS TO WHICH VARIABLES NEED CONCATINATION         +A
*+  CREATES BSU & SETS FLAGS AS THE CONDITIONS WARRENT               +A
*+  SCANS STRINGS AND PROCESSES EXPRESSIONS WITH & VARIABLES         +A
*+                                                                   +A
*+       NOTE: WE ASSUME THAT A PERIOD SHOWS CONCATENATION ONLY IF   +J
*&       USED IMMEDIATELY AFTER A SET VAR/PARAMETER.                 +J
*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +A
         SPACE 2                                                      A
         ST    RET,MCBDSAV         SAVE RETURN @
         LA    RY,0(RB,RA)         GET DELIM @
         LTR   RC,RC               LOOK FOR &'S?
         BNZ   MCBDSC01            SKIP IF NO
MCBDSC00 $SETRT ('&&',4)           SET TO STOP ONLY ON &              J
MCBDSC01 EQU   *
         LR    R0,RA               COPY SCAN POINTER
MCBDSC0A EQU   *
         XSNAP T=NO,STORAGE=(*AVRSBLOC,*AVRSBLOC+80,*0(RW),*8(RW)),   S#
               LABEL=' MCBDSC0A ',IF=(AVTAGSM,O,AJOMACRH,TM)          S
         LR    RB,RY               GET FINAL @ IN RB
         SR    RB,RA               GET LENGTH IN RB
         LR    R1,RY               COPY DELIM @ IN R1 FOR TRT
         SR    R2,R2               CLEAR R2
         IC    R2,0(RA)            GET 1ST CHAR
         LA    RE,AWTZTAB(R2)      USE AS PNTR TO TRT TABLE
         CLI   0(RE),X'04'         '&', '.' OR BLANK?
         BE    MCBDSCMP            '&&' IF EQUAL
MCBDSC02 EQU   *                   FALL THRU MEANS NONTERMIANL
         TM    AVMBYTE2,$MOPRTR    PREV BSU = OPRTR?
         BO    MCBDSC03            PROCEED IF YES
         BAL   RET,MCBDCATI        ELSE INSERT CAT OPRTR
MCBDSC03 EQU   *
         EX    RB,MCBDTRSC         SCAN STRING
         CLC   0(2,R1),=C'&&&&'    STOP ON DOUBLE &?
         BNE   MCBDSC04
         LA    RA,2(R1)            BUMP PAST &'S
         B     MCBDSC0A            AND RESUME SCAN
MCBDSC04 EQU   *
         LR    RA,R0               ELSE GET START @
         LR    RB,R1               MOVE DELIM@ TO RB
         $CALL MCGTST              MOVE STRING TO LOW CORE
         OI    MCBSFLGS,$MTERM+$BSCHAR  SET BSU FLAGS
         MVI   MCBSINDX,$BSTRING   SET BSU INDEX
         STC   RD,MCBSTRLN         STORE LEN IN BSU
         ST    RC,MCBSLOC          SAVE @ OF STING IN BSU
         NI    AVMBYTE2,255-($MTERM+$MOPRTR)  TURN OFF PREV IND FLAG
         OI    AVMBYTE2,$MTERM     SET PREV FLAG TO TERM
         BAL   RE,MCBDBMP          BUMP BSU OINTER
         CR    RA,RY               END OF STRING?
         BNL   MCBDSCFT            JUMP TO FOOT IF YES
         B     MCBDSC01            ELSE RESUME SCAN
MCBDSCMP EQU   *
         CLI   1(RA),C'&&'         TWO '&&'S?
         BNE   MCBDSCM1            CONTINUE IF NOT
         LA    RA,2(RA)            BUMP SCN PNTR PAST &&'S
         B     MCBDSC0A            AND RESUME SCAN
MCBDSCM1 EQU   *
         TM    AVMBYTE2,$MOPRTR    PREV BSU = OPRTR?
         BO    MCBDSCM2            PROCEED IF YES
         BAL   RET,MCBDCATI        ELSE INSERT CATEN OPRTR
MCBDSCM2 EQU   *
         OI    AVMBYTE4,$MINSTRN   SET IN STRING FLAG
         LR    RC,RW               MOVE BSU PNTR TO RC
          $SETRT ('&&',0)          CLEAR TRT TABLE FOR MACLEX         J
         XSNAP T=NO,STORAGE=(*0(RW),*8(RW)),LABEL='MCBDSCAN -- BSU     #
               BEFORE CALL TO MACLEX',IF=(AVTAGSM,O,AJOMACRH,TM)
         $CALL MACLEX
         LR    RW,RC               RESTORE BSU POINTER
         LTR   RB,RB               ERROR?
         BNZ   MCBDPRER            JUMP OUT IF YES
         CR    RA,RY               SCAN FINI?
         BNL   MCBDSCFT            JUMP OUT IF YES
*              CHECK FOR . AFTER &VARIABLE - ONLY CASE IN WHICH .     J
*              IS NOT AN ORDINARY CHARACTER.                          J
         CLI   0(RA),C'.'          . AFTER &VARIABLE ?                J
         BNE   MCBDSC00            NO, GO BACK FOR NEXT SCAN          J
         LA    RA,1(,RA)      YES, BUMP OVER = CONCATENATION          J
         B     MCBDSC00            GO BACK FOR NEXT CHARACTER         J
MCBDSCFT EQU   *
         $SETRT ('&&',0)      MAKE SURE TRT TABLE CLEARED             J
         XSNAP T=NO,STORAGE=(*0(RW),*8(RW)),LABEL='MCBDSCAN -- BSU     #
               BEFORE RETURN        ',IF=(AVTAGSM,O,AJOMACRH,TM)
         L     RET,MCBDSAV         RESTORE RETURN @
         BR    RET                 AND RETURN
MCBDSAV  DS    F                   CORE FOR RETURN @
MCBDTRSC TRT   0(0,RA),AWTZTAB     DUMMY TO SCAN STRING
         SPACE 2
*  ORDINARY COMMENT, SET UP BSU AND CRETE CODE                        A
*                                                                     A
MCBODCOM EQU   *
         L     RD,MCBPRBSU         CREATE BSU                         A
         OI    AVMBYTE2,$MOPRTR    SET PREV FLAG TO OPERTR
         BAL   RE,MCBDBMP0         BUMP BSU POINTER                   A
         SR    RB,RB
         IC    RB,AVRSBLOC         GET LENGTH-1 OF STMT
         S     RB,AWF3             DECR FOR STND PART
         L     RA,MCBDSRPT         GET PNTR TO SOURCE
         LA    RC,4                INDICATE NO TERMINAL CHARS
         BAL   RET,MCBDSCAN        SCAN COMMENT STMT
         L     RD,MCBDPR2          CREATE BSU                         A
         BAL   RE,MCBDBMP0         BUMP BSU POINTER                   A
         B     MCBODPRC            JUMP AND GENRATE CODE
         TITLE '***MCBODY - MEND, PRINT, ERROR ETC. ROUTINES***'
**--> INSUB:MCBDCATI    CREATE CONCOT BSU+ + + + + + + + + + + + + + +A
*+                                                                   +A
*+   CONCATENATION OPERATION NEEDED. IN CASE OF VARIABLES THAT       +A
*+  HAVE TO BE COMBINED (IE IN SETC STMT)                            +A
*+                                                                   +A
*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +A
         SPACE 2                                                      A
MCBDCATI EQU   *                   ROUTINE TO INSERT CATEN OPRTR
         L     RD,MCBDCAT          CREATE BSU                         A
         NI    AVMBYTE2,X'FF'-($MTERM+$MOPRTR)  TURN OFF PREV BSU FLAG
         OI    AVMBYTE2,$MOPRTR    SET PREV BSU FLAG
         LR    RE,R14              COPY RETURN @ TO MCBDBMP0 REG      S
*        *** FALL THRU INTO MCBDBMP0  --  MUST IMMEDIATELY FOLLOW *** S
         SPACE 2
**--> INSUB: MCBDBMP       BUMPS BSU POINTER + + + + + + + + + + + + +A
*+                                                                   +A
*+   CALLED WHENEVER BSU ADDED & NEED POINTER MOVED                  +A
*+                                                                   +A
*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +A
         SPACE 2                                                      A
MCBDBMP0 ST    RD,MCBSU            FILL IN BSU                        A
MCBDBMP  EQU  *
         XSNAP T=NO,STORAGE=(*0(RW),*8(RW)),LABEL='BSU - MCBDBMP',     #
               IF=(AVTAGSM,O,AJOMACRH,TM)
         LA    RW,8(RW)            BUMP BSU POINTER
         C     RW,AVMCHLIM         WORK AREA EXCEEDED?
         BL    MCBDBMP1            OK IF NOT
         LA    RB,$ERVTMTR         ELSE SET TOO MANY TERMS FLAG
         B     MCBDPRER            AND FLAG STATEMNT
MCBDBMP1 EQU   *
         MVC   MCBSU(8),AWZEROS    ZERO NEW BSU
         BR    RE                  AND RETURN
         SPACE  2
*  OVERFLOW CALL EXIR ROUTINE                                         A
MCBODOVR EQU   *
         L     REP,AVMOVRFL        GET @ OF OVERFLOW ROUTINE
         BR    REP                 BRANCH THERE
         SPACE 2
MCLMXDER EQU   *
         L     RA,AVRSBPT          GET SOURCE BLOCK @
         LA    RA,RSB$L(RA)        BUMP TO GET SOURCE STMT
         LA    RB,$ERILCNV         SET ILLEGAL CONVERSION ERROR FLAG
         B     MCBDPRER
         EJECT                                                        S
**--> INSUB:MCBDPR      PRINT STATEMENTS + + + + + + + + + + + + + + +A
*+                                                                   +A
*+  CALLED EACH TIME STATEMENTS NEEDS TO BE PRINTED. TEST FOR SEQ    +A
*+  SYMBOL, IF PRESENT TEST FOR ALREADY DEFINED, IF NOT ENTER INTO   +A
*+   LIST OF SYMBOLS & THEN PRINT, CONTINUES ' READING' STMTS        +A
*+  AND STOPS WHEN MEND FLAG SET.                                    +A
*+                                                                   +A
*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +A
         SPACE 2                                                      A
MCBODPR0 BAL   RE,MCBDBMP0         BUMP BSU POINTER                   A
MCBODPR  EQU   *
         AIF   (&$DEBUG).MCBODPR
         L     R1,AVMCHSTR         GET @ OF BSU WORKAREA
         XSNAP LABEL='***BSU''S***',STORAGE=(*0(R1),*170(R1)),IF=(AVMSNX
               BY1,O,$MSNP08,TM)
.MCBODPR ANOP
         USING MCSEQ,RC            SET USING FOR SEQ SYMBOL ENTRY
         TM    MCLBFLG2,$MLCLFLG   DEFINITION TYPE STMT?              S
         BC    12,MCBODPR1         IF YES, JUMP AND PRINT
MCBODPRC EQU   *
         LR    RC,RX               COPY MACLIB POINTER
         $CALL MCGNCD              ELSE GENERATE CODE
         AIF   (NOT &$MACOPC).MCBODYC   SKIP IF NOT OPEN CODE         S
         TM    MCLBFLG2,$MCOCFL1   IN OPEN CODE ?                     S
         BO    MCBODPR1            IF YES, SKIP PROCESSING            S
.MCBODYC ANOP                                                         S
         CLI   AVMFLDT1,C'.'       SEQ SYMBOL PRESENT?
         BNE   MCBODPR1            JUMP AND PRINT IF NOT
         SR    RE,RE
         IC    RE,AVMFLDL1         GET LENGTH OF SYMBOL
         BCTR  RE,0                REDUCE FOR EX INSTRUCTION
         L     RA,AVMFLD1          GET @ OF SEQ LABEL
         MVC   AVMSYMBL,AWBLANK    BLANK OUT COMMON AREA
         EX    RE,MCBDPR1          EX MOVE INSTRUCTION                A
         L     RC,AVMSEQPT         GET POINTER TO SEQ SYM ENTRIES
         $CALL MACFND              SEARCH SYMBOL DICT
         LTR   RB,RB               PRESENT?
         BZ    MCBODPR2            JUMP IF YES
         LA    RB,$LMCSEQ          ELSE GET LENGTH OF ENTRY
         $ALLOCH R1,RB,MCBODOVR    GET SPACE FOR ENTRY
         ST    R1,MCSEQNXT         STORE POINTER IN PREV ENTRY
         LR    RC,R1               MOVE BASE TO NEW ENTRY
         MVC   MCSEQNAM,AVMSYMBL   MOVE NAME INTO ENTRY
         OI    MCSEQFLG,X'FF'      SET DEFINED FLAG
         MVC   MCSEQNXT,AWZEROS    ZERO LINK POINTER
         MVC   MCSEQVAL,AVMCRINS   MOVE INST @ INTO ENTRY
         B     MCBODPR1            JUMP AND PRINT
MCBODPR2 EQU   *
         CLI   MCSEQFLG,X'FF'      ALREADY DEFINED?
         BNE   MCBODPR3            JUMP AND PROCESS IF NOT
         LA    RB,$ERMULDF         ELSE SET MULT DEF FLAG
         $CALL ERRLAB              AND FLAG STATEMENT
         B     MCBODPR1            PRINT STMNT
MCBODPR3 EQU   *
         L     RE,MCSEQVAL         GET @ OF INST
         USING MCOPQUAD,RE         SET USING FOR ONE OP ENTRY
MCBODPR4 EQU   *
         MVC   MCARG2LC,AVMCRINS   MOVE INST @ INTO ONE OP ENTRY
         L     RE,MCRESULT         GET NEXT POINTER
         LTR   RE,RE               POINTER PRESENT?
         BNZ   MCBODPR4            IF YES, UPDATE NEXT ENTRY IN LIST
         MVI   MCSEQFLG,X'FF'      ELSE SET DEFINED FLAG IN ENTRY
         MVC   MCSEQVAL,AVMCRINS   SET VALUE IN ENTRY
         DROP  RE
         SPACE
MCBODPR1 EQU   *
         AIF   (NOT &$MACOPC).MCBODYD   SKIP IF NOT OPEN CODE         S
         TM    AVPRINT1,AVPRSAVE   LISTING CONTROL = SAVE ?           S
         BNO   MCBODP1A            BRANCH IF NOT                      S
         SR    RE,RE               ZERO  FOR BYTE REGS USE            A
         IC    RE,AVRSBLOC         GET LENGTH-1                       A
         SH    RE,=AL2(RSB$L)      DECREMENT LENGTH FOR MXMVSR        A
         STC   RE,AVRSBLOC         RESTORE IT                         A
         $CALL MXMVSR              SAVE STATEMENT                     A
         B     MACBODRT            RETURN                             S
MCBODP1A EQU   *                                                      S
.MCBODYD ANOP                                                         S
         LA    RB,$OUCOMM
         $CALL OUTPT2              PRINT STATEEMNT
         CLI   OPCHEX,$MEND        MEND STATEMENT?
         BE    MACMEND1            CLEAN UP IF YES
         B     MCBOD01             ELSE READ NEXT STMNT
         DROP  RC
         SPACE 2
MCBDCHLB EQU   *
         ST    RET,MCBDCHSV        SAVE RETURN ADDRESS
         CLI   AVMFLDT1,C'.'       SEQ SYMBOL?
         BE    MCBDCHFT            OKAY IF YES
         CLI   AVMFLDL1,X'00'      NO LABEL?
         BE    MCBDCHFT            OKAY ALSO
         LA    RB,$ERILLAB         ELSE SET BAD LABEL FLAG
         $CALL ERRLAB              AND FLAG STMT
MCBDCHFT EQU   *
         L     RET,MCBDCHSV        RESTORE RETURN @
         BR    RET                 AND RETURN
MCBDCHSV DS    F                   CORE FOR RETURN @
MCBDPR1  MVC   AVMSYMBL($),0(RA)   DUMMY MOVE FOR LABEL               A
         SPACE 2
MCGBINVD LA    RB,$ERINVDM         INVALID DLM                        A
         B     MCBDPRER            GO FLAG ERROR                      A
         SPACE 1                                                      A
MCGBMD   L     RA,AVMTSCNP         GET @ OF 1ST CHAR OF VAR NAME      A
         LA    RB,$ERMULDF         SHOW MULTIPLR DEFN                 A
         B     MCBDPRER            GO FLAG                            A
         SPACE 1                                                      A
MCBDOPER EQU   *
         LA    RA,AVRSBLOC+RSB$L+20 GUESS AT OPRND ADDRESS            A
         LA    RB,$ERNOOPR         SET NO OPRND FLAG
         SPACE 2
*                                                                     S
*  PRINTS AN APPROPRIATE MESSAGE & SETS ERR INDX IN BSU               A
*                                                                     A
MCBDPRER EQU   *
         L     RW,AVMCHSTR         SET BSU PNTR TO START OF WORK AREA
         LR    RD,RA               COMPUT OFFSET                      A
         S     RD,AVRSBPT                                             A
         SLL   RD,8                MOVE TO RIGHT BYTE                 A
         AL    RD,MCBDERR                                             A
         BAL   RE,MCBDBMP0         BUMP BSU POINTER                   A
         $CALL ERRTAG              FLAG STMNT
         B     MCBODPR             JUMP AND PRINT STATEMENT
         SPACE 2
MCBDISER EQU   *
         LA    RB,$ERINVSY         SET INVALID SYMBOL FLAG
         B     MCBDPRER            AND FLAG STATEMENT
         SPACE 2
*                                                                     A
*        END OF ROUTINE, SET OP POINTERS TO ONE-OP ENTRIES PRINTS     A
*    OUT ERROR MESSAGES & DEBUG ADDRESS FOUND & STORED                A
*                                                                     A
MACMEND1 EQU   *
         USING MCOPQUAD,RE
         USING MCSEQ,RC
         L     RC,AVMSEQPT         GET @ OF SEQ SYM LIST
         USING RSBLOCK,RZ          NOTE USING FOR OUTPPUT RECORD
         L     RZ,AVRSBPT          SET BASE FOR OUTPUT RECORD
         MVC   RSBLOCK(RSB$L+L'MCMNERMS),MCMNERMF   SET FLAGS         S
MACMEND2 EQU   *
         CLI   MCSEQFLG,X'FF'      SYMBOL DEFINED?
         BNE   MACMEND3            PROCESS IF NOT
MACMENDN EQU   *
         L     RC,MCSEQNXT         SET BASE TO NEXT ENTRY
         LTR   RC,RC               LAST ENTRY?
         BNZ   MACMEND2            IF NOT, RESUME SEARCH
         B     MACMEND5            ELSE JUMP TO FOOT
MACMEND3 EQU   *
         L     RE,MCSEQVAL         GET @ OF ONE OP ENTRY
MACMEND4 EQU   *
         MVC   RSBSOURC+L'MCMNERMS(6),AWEP6   PUT EDIT MASK IN OUTPUT
         L     R1,MCRESULT         COPY LINK TO NXT SEQ ERROR TEMP
         L     RE,MCARG2LC         MOVE BASE TO 1ST ONE-OP
         ED    RSBSOURC+L'MCMNERMS(6),MCQSTMNO    EDIT STMT NBR TO FLD
         MVI   MCQS1FLG,$BSERR01   SET ERROR MSG OPCODE               A
         LA    RB,$OUCOMM          SET PRINT FLAG
         LR    R0,RC               COPY RC TEMPORARILY
         $CALL OUTPT2              PRINT ERROR MESSAGE
         LR    RC,R0               RESTORE RC
         LTR   RE,R1               SET BASE TO NEXT SEQ ERR ENTRY     S
         BNZ   MACMEND4            PRINT NEXT MESSAGE IF NOYT
         B     MACMENDN            RESUME SCAN OF SEQ SYMBOL DICT
MACMEND5 EQU   *
         LA    RC,$LMCSEQ           GET LENGTH OF SEQ ENTRY
         L     R1,AVADDHIH         GET PNTR FOR DEBUG STMNT
         A     RC,AVMSEQPT         ADD ORIGINAL POINTER
         ST    RC,AVADDHIH         RELEASE STORAGE IN HIGH END
         SPACE 2
MACBODRT EQU   *
         AIF   (&$DEBUG).MACBODR
         L     R2,AVMSEQPT         GET @ OF SEQ SYM TABLE FOR DEBUG
         XSNAP LABEL='***MCBODY EXITED***',STORAGE=(*0(R1),*0(R2)),IF=(X
               AVMSNBY1,O,$MSNP07,TM)
.MACBODR ANOP
         SR   RB,RB                CLEAR RB FOR RETURN
         $RETURN  RGS=(R14-R6)
MCBDSRPT DS    F                   WORD FOR RSBSOURC @
MCB##SAV DS    F                   RETURN @ FROM MCB## ROUTINES       J
MCBPRBSU DC    AL1($MOPRTR,$BSPRINT,0,$MPRNTHR)    PRINT BSU
MCBPRBSV DC    AL1($MOPRTR+$MPRCOM,$BSPRINT,0,$MPRNTHR) COMMENT PRM   A
*        ***** BSU TABLE - FIRST FULLWORDS OF MANY BSU'S. *****       J
MCBDERR  DC    AL1($MOPRTR,$BSERR01,0,$MPRNTHR)                       A
MCBDSET  DC    AL1($MOPRTR,$BSETA,0,$MSETHR)                          A
MCBDAGO  DC    AL1($MOPRTR,$BSAGO,0,$MAGOHR)                          A
MCBDSTG1 DC    AL1($MTERM+$BSCHAR,$BSTRING,0,11),A(MCMNOTMS) WHOLE BS J
MCBDSTG2 DC    AL1($MTERM+$BSCHAR,$BSTRING,0,2),A(MCMNOT1C) WHOLE BSU J
MCBDPR2  DC    AL1($MOPRTR,$BSMVSTM,0,$MPRNTHR)                       A
MCBDPR3  DC    AL1($MOPRTR,$BSMVSTM+$BSMNTER,0,$MPRNTHR)              A
MCBDAIF  DC    AL1($MOPRTR,$BSAIF,0,$MAIFHR)                          A
MCBDCAT  DC    AL1($MOPRTR,$BSCAT,0,$MCATHR)                          A
MCBDINMA DC    AL1($MOPRTR,$BSINMAC,0,$MPRNTHR)  INNER MACRO BSU      A
MCBDLABL DC    AL1($MTERM,$BSLABEL,0,0)                               A
MCMNERMF DC    AL1(L'MCMNERMS+RSB$L+6,$RSBNPNN+$RSBMERR,1,0)          A
MCMNERMS DC    C'220  UNDEFINED SEQUENCE SYMBOL IN STATEMENT'
         LTORG
         DROP  RAT,RW,RX,R13,RC,RZ,RE
         TITLE '***MACLEX - LEXICAL SCAN OF EXPRESSIONS***'
**-->  CSECT:  MACLEX   THIS PROCEDURE SCANS A MCRO STATEMENT AND     *
*.        CONVERTS IT INTO BSU'S.  ALSO CHECKS FOR SUCH ERRORS AS TWO *
*.        TERMS OR TWO OPERATORS IN A ROW.  WHERE NECESSARY IT INSERTS*
*.        CATENATION OPERATORS WHERE CATENATION IS IMPLICIT           *
*.                                                                    *
*.        ENTRY CONDITIONS                                            *
*.     RA = @ OF FIRST CHARACTER OF EXPRESSION                        *
*.     RC = @ ON NEXT AVAILABLE BSU IN WORKSPACE                      *
*.                                                                    *
*.        EXIT CONDITIONS                                             *
*.     RA = @ OF DELIM PAST EXPRESSION IF NO ERROR                    *
*.        = @ OF ERROR IF ERROR PRESENT                               *
*.     RB = 0 IF OKAY                                                 *
*.        = $ERMSSGE IF ERROR                                         *
*.     RC = @ OF NEXT AVAILABLE SPACE FOR BSU                         *
*.                                                                    *
*.        CALLS MCGTST,MCDTRM,SDBCDX,MCSYSR,MCATRM,MCGTST             *
*.        USES DSECTS: AVWXTABL,MCBSU,MCPARENT,MCGLBDCT,MCLCLDPV      *
*.        USES MACROS: $SAVE,$RETURN,$ALLOCL,$SCOF,$SCPT,$CALL,$SETRT *
*.                                                                    *
*.       REGISTER USAGE                                               A
*.        WORK REGS: R0,R1,R2,RY,RZ,RB,RC,RE                          A
*.        USED FOR TRT: R1,R2                                         A
*.        RW-BASE REG FOR BSU                                         A
*.        R13 BASE REG FOR THIS CSECT                                 A
*.        RAT- BASE REGISTER FOR MAIN TABLE                           A
*.       RX-UNUSED                                                    A
*.       RD-?                                                         A
*.                                                                    A
*** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 2
MACLEX   CSECT
         $SAVE RGS=(R14-R6),SA=*,BR=13
         USING AVWXTABL,RAT        NOTE MAIN TABLE USING
         XSNAP LABEL='***MACLEX ENTERED***',T=NO,IF=(AVMSNBY2,O,$MSNP09X
               ,TM)
         USING MCBSU,RW            SET USING FOR BSU ENTRY
         LR    RY,RC               COPY ADDR OF NEXT BSU              A
         S     RY,=F'8'            GET ADDR OF PRECIOUS POINTER       A
         MVC   MCBSFLGP(4),0(RY)   MOVE PREV BSU INTO WORK AREA       A
         SR    RY,RY               USE RY FOR PAREN COUNT
         LR    RW,RC               GET @ OF SPACE FOR BSU
         MVI   AVMDWRK4,X'00'      CLEAR PAREN INFO BYTE
         MVC   MCBSU(8),AWZEROS    BLANK OUT ENTRY
         NI    AVMBYTE1,X'FF'-$MINQUOT   CLEAR QUOTE FLAG
         NI    AVMBYTE2,X'FF'-$MTERM    MAKE SURE TERM FLG IS OFF
         OI    AVMBYTE2,$MOPRTR    SET OPERATOR FLAG FOR START
         $SETRT ('''',26,'&&',28,'.',30)  SET TRT TABLE FOR QUOTE SCAN
         MVI   AWTDECT+C'+',18
         MVI   AWTDECT+C'-',20
         MVI   AWTDECT+C'/',22     MODIFY AWTDECT TABLE FOR TEMPORARY
         MVI   AWTDECT+C')',24     USE IN LEXICAL SCAN.  THIS SAVES
         MVI   AWTDECT+C'''',26    CREATING A NEW TABLE.
         MVI   AWTDECT+C'&&',28
         MVI   AWTDECT+C'.',30
         B     MCLXSTR0            JUMP TO LOOKUP CHAR ROUTINE        A
MCLEXBAS DS    0H
         SPACE 2
MACLINDX $AL2  MCLEXBAS,(MCLDIGIT,MCLEXERR,MCLSDTRM,MCLALPHA,MCLMULT,MCX
               LEQUAL,MCLXLPAR,MCLCOMMA,MCLBLANK,MCLPLUS,MCLMINUS,MCLDIX
               VID,MCLXRPAR,MCLQUOTE,MCLAMPRS,MCLPEROD)
         SPACE 2
*  TRT  TABLE SET-UP, LOOK UP CHARACTER OF EXPRESSIO AND GO TO THE    A
* ROUTINE TO PROCESS THE EXPRESSION.                                  A
MCLXSTRS EQU   *                                                      S
         LA    RA,1(R1)            BUMP SCAN POINTER                  S
MCLXSTRT EQU   *
MCLXSTR0 EQU   *                                                      A
         LR    R0,RA               COPY SCAN POINTER
MCLXSCAN EQU   *
         SR    R1,R1               ZERO R1 FOR TRT USE
         SR    R2,R2               USE R2 IN TRT INST
         TM    AVMBYTE1,$MINQUOT   INSIDE QUOTES?
         BO    MCLX01              USE LIMITEE TRT IF YES
MCLX03   EQU   *
         TRT   0(1,RA),AWTDECT     LOOKUP NEXT CHAR
         B     MCLX02              AND JUMP TO GET ROUTINE
MCLX01   EQU   *
         TM    AVMBYTE2,$MINAPAR+$MDIMVAR  PAREN EXPRESSSION EXPECTED?
         BC    5,MCLX03            IF YES, USE REGULAR TRT
         TRT   0(200,RA),AWTZTAB
MCLX02   EQU   *
         LH    RE,MACLINDX(R2)     GET HALFWORD OFFSET FROM TABLE
         B     MCLEXBAS(RE)        ADD TO BASE AND JUMP TO ROUTINE
         SPACE 2
* DIGIT FOUND, CHECK TO SEE IF PROPER CONST, CONVERT IT, SET UP       A
*  BSU WITH CONSTANT VALUE, DECREMENT # BSU COUNTER & PROCESS         A
MCLDIGIT EQU   *
         TM    AVMBYTE2,$MINARIT+$MINAPAR+$MINBOOL CONSTANT OKAY?
         BZ    MCLXSYER            IF NOT, JUMP AND FLAG
         $CALL MCDTRM              CONVERT CONSTANT
         LTR   RB,RB               OK?
         BNZ   MCLXERTN             RETURN IF NOT
         MVI   MCBSINDX,$BSIMMA    SET IMMED ARITH INDEX
         OI    MCBSFLGS,$BSAR      INDICATE ARITH IN BSU
         ST    RC,MCBSVALU         STORE VALUE IN BSU
         S     RC,AWF1             DECR BY 1
         BH    MCLXTRMF            IF > 1 THEN FINI
         OI    MCBSFLGS,$BSBOOL    ELSE FLAG AS BOOLEAN CONSTANT ALSO
         B     MCLXTRMF            JUMP TO TERM FOOT
         SPACE 2
*  POSSIBLE SELF DEFINING TERM, CHECK NEXT CHAR, IF QUOTE, ALPHA,     A
*  ELSE CHECK FOR OK SDT.-SETS FLAGS ETC.                             A
MCLSDTRM EQU   *
         CLI   1(R1),C''''         NEXT CHAR = '?
         BNE   MCLALPHA            PROCESS ALPHA IF NOT
         $CALL SDBCDX              CHECK FOR SELF DEFINING TERM
         LTR   RB,RB               OKAY?
         BM    MCLALPHA            MAY BE L', BRANCH                  A
         BP    MCLXERTN            BAD SDTERM IF RB > 0               A
         TM    AVMBYTE2,$MINARIT+$MINAPAR+$MINBOOL  IN OKAY EXPRESSION?
         BZ    MCLXSYER            ERROR IF NOT
         OI    MCBSFLGS,$BSAR+$MTERM  SET TYPE TO ARITH TERM
         MVI   MCBSINDX,$BSIMMA    SET TO ARITH IMMED TYPE INDEX
         ST    RC,MCBSVALU         STORE VALUE IN BSU
         B     MCLXTRMF            JUMP TO TERM FOOT
         SPACE 2
*  ALPHA CHAR FOUND, CK ARITH EXPRESSION, PROCESS  IF IS, NEXT        A
*  CK  TYPE ATTR, ERROR  IF NOT FIRST CHAR OF OPRND  ALSO IF  (       A
*  SETS SYSLIST FLAG  SEARCHES ATTRIBUTES IN DICTIONARY               A
MCLALPHA EQU   *
         TM    AVMBYTE2,$MINARIT+$MINBOOL+$MINAPAR   IN ARITH EXPRES?
         BM    MCLALPH0            PROCEED IF YES
         C     R1,AVMFLD3          BEGINNING OF OPRND?
         BNE   MCLXSYER            ERROR IF NOT
         CLC   0(2,R1),=C'T'''     T' ATTIBUTE?
         BNE   MCLXSYER            ERROR IF NOT
MCLALPH0 EQU   *
         CLI   1(R1),C''''         NEXT CHAR = QUOTE?
         BNE   MCLRELOP            IF NOT TEST FOR RELOP
         $CALL MCATRM              IS IT AN ATTRIBUTE?
         LTR   RB,RB
         BM    MCLXSYER            IF NOT, SET SYNTAX EROR FLAG
         BP    MCLXERTN           NOT IMPLEMENTED
         STC   RC,MCBSINDX         STORE TYPE OF ATTRIB IN BSU
         $CALL MCSYSR              SEARCH DICTIONARIES
         LTR   RB,RB
         BM    MCLXISER            INVALID SYMBOL IF MINAS
         BP    MCLXERTN            NOT DEFINED IF RB > 0
         LA    RB,$SYMPAR          LOAD SYMBOLIC PARAM FLAG
         CR    RD,RB               IS IT SYM PAR?
         BE    MCLA01              IF YES PROCEED
         USING MCPARENT,RC         NOTE USING FOR ENTRY
         LA    RB,$SYSVAR          NEXT CHECK FOR SYSTEM VARIABLE
         CR    RB,RD
         BNE   MCLXISER            IF NOT, FLAG ERROR
         CLI   MCPARNLN,8          MUST BE &SYSLIST WITH LENGTH 8
         BNE   MCLXISER            ERROR IF NOT
         MVC   MCBSVALU,AWFM1      INDICATE &SYSLIST WITH -1
*   N'&SYSLIST CAN STAND ALONE SO CHECK FOR LEFT PAREN
         CLI   MCBSINDX,$BSATN     ATTRIB = N'?
         BNE   MCLALPH2            PROCEED IF NOT
         CLI   0(RA),C'('          NEXT CHAR = '('?
         BNE   MCLXTRMF            PROCESS IF NOT
MCLALPH1 EQU   *
         MVI   AVMDWRK4,$MINSYSL   SET &SYSLIST FLAG IF PAREN
         B     MCLXTRMF
MCLALPH2 EQU   *
         CLI   0(RA),C'('          NEXT CHAR = LEFT PAREN?
         BE    MCLALPH1            T' OR K' REQUIRE PAREN
         B     MCL$ERI                                                S
         SPACE
*  SYMBOLIC PARAMETER FOUND  SET UP BSU, AND CHK LEGALITY             A
MCLA01   EQU   *
         LH    R2,MCPARNDX         GET SYMBOLIC PARAM ID
         ST    R2,MCBSVALU         STORE IN BSU
         CLI   0(RA),C'('          NEXT CHAR  IS '('?
         BNE   MCLXTRMF            JUMP TO FOOT IF NOT
         OI    AVMBYTE2,$MDIMVAR   ELSE SET DIM VAR FLAG
         CLI   MCBSINDX,$BSATN     N' ATTRIB?
         BNE   MCLXTRMF            OKAY IF NOT
MCL$ERI  LA    RB,$ERILAT          SET BAD ATTRIB FLAG                S
         B     MCLXERTN            AND RETURN
      SPACE 2                                                         A
*   RELATIONAL OPERATOR FOUND, IF ^BOOL ERROR, ELSE GET OPERAND LENGTHA
*   AND LOOK UP IN TABLE FOR OPERATION WHEN LEGAL OPERATOR  FOUND,    A
*   SET UP BSU                                                        A
MCLRELOP EQU   *
         TM    AVMBYTE2,$MINBOOL   IN BOOLEAN EXPRESSION?
         BNO   MCLXSYER            IF NOT, REL OPCODE NOT ALLOWED
         TRT   0(4,RA),AWTSYMT     SCAN STRING FOR DELIM
         BZ    MCLXSYER            ERROR IF > 3 CHARS
         LR    R2,R1               COPY DEIIM @
         SR    R2,RA               GET LENGTH OF STRING
         BCT   R2,MCLARL01         DECR FOR EX INST
         B     MCLXSYER            ERROR IF ONE CHAR
MCLARL01 EQU   *
         LA    RE,MCRLOPTB         GET @ OF CONSTANT TABEL
MCLARL02 EQU   *
         EX    R2,MCLACMPR         COMPARE WITH NEXT ENTRY
         BE    MCLARL03            FOUND IF EQUAL
         BL    MCLXSYER            NOT PRESENT IF <
         LA    RE,5(RE)            BUMP TABLE POINTER
         B     MCLARL02            RESUME SEARCH OF TABEL
         SPACE
MCLARL03 EQU   *
         MVC   MCBSINDX,3(RE)      SET INDEX
         MVC   MCBSHIER,4(RE)      SET HIERARCHY IN BSU
         LR    RA,R1               BUMP SCAN POINTER
         B     MCLXOPRF            JUMP TO OPRTR FOOT
         SPACE 2
MCLACMPR CLC   0(0,RA),0(RE)       COMPARE STRING WITH TABLE ENTRY
MCRLOPTB DC    C'AND',AL1($BSAND,$MANDHR),C'EQ ',AL1($BSEQ,$MRELHR)
         DC    C'GE ',AL1($BSGE,$MRELHR),C'GT ',AL1($BSGT,$MRELHR)
         DC    C'LE ',AL1($BSLE,$MRELHR),C'LT ',AL1($BSLT,$MRELHR)
         DC    C'NE ',AL1($BSNE,$MRELHR),C'NOT',AL1($BSNOT,$MNOTHR)
         DC    C'OR ',AL1($BSOR,$MORHR),C'999'
         DROP RC
         SPACE 2
*   NEXT BLOCKS WHEN  +,-,/,OR * FOUND, SETS HIERARCHY AND SETS UP    A
*   THE BSU'S                                                         A
MCLMULT  EQU   *
         MVI   MCBSINDX,$BSMULT    SET INDEX TYPE IN BSU
MCLMHIER EQU   *
         MVI   MCBSHIER,$MMULTHR   SET MULT/DIVID HIERARCHY
         B     MCLXARFT            JUMP TO ARITH OPRTR FOOT
         SPACE 2
MCLDIVID EQU   *
         MVI   MCBSINDX,$BSDIV     SET BSU INDEX FOR DIVIDE
         B     MCLMHIER            JUMP AND SET HIERARCHY
         SPACE 2
MCLPLUS  EQU   *
         MVI   MCBSINDX,$BSPLUS    SET ADDITION INDIX IN BSU
MCLPHIER EQU   *
         MVI   MCBSHIER,$MPLUSHR    SET HIERARCHY OF OPRTR
         B     MCLXARFT            JUMP TO ARITH FOOT
         SPACE 2
MCLMINUS EQU   *
         MVI   MCBSINDX,$BSMIN     SET MINUS INDEX IN BSU
         B     MCLPHIER            JUMP AND SET SAME HIERARCHY AS PLUS
         SPACE 2
*   CK  IF ARITH EXPRESSION, ERROR IF NOT                             A
MCLXARFT EQU   *
         TM    AVMBYTE2,$MINARIT+$MINAPAR+$MINBOOL  IN ARITH EXPRESSION
         BZ    MCLXSYER            ERROR IF NOT
         LA    RA,1(R1)            BUMP SCAN POINTER
         B     MCLXOPRF            JUMP TO OPERATOR FOOT
         SPACE 2
         SPACE 2
*   LEFT  PAREN FOUND CHECK IF NESTING LEVEL OK, , CHKS & BRANCHES TO A
*   SEE IF 1)SUBSCRIPTED VAR,2)IN SUBSTRING,3)OR SYSLIST              A
MCLXLPAR EQU   *
         LA    RY,1(RY)            BUMP PAREN COUNT
         C     RY,=F'6'            CHECK NEXTING LEVEL
         BL    MCLXLP01            OKAY IF < 6
         LA    RB,$ERVPARN         ELSE SET TOO MANY PAREN FLAG
         B     MCLXERTN            AND RETURN
MCLXLP01 EQU   *
         LA    RZ,AVMDWRK4(RY)     USE RZ AS PNTR TO CURRENT PAREN
         TM    AVMDWRK4,$MINSYSL   IS &SYSLIST FLAG ON?
         BO    MCLXSBSL            IF YES MUST BE &SYSLIST PAREN
         TM    AVMBYTE2,$MDIMVAR   PREV BSU = DIMEN VARIABLE?
         BO    MCLXSBSC            IF YES, MUST BE SUBSCRIPT LP
         BCTR  R1,0                DECR POINTER
         CLI   0(R1),C''''         PREV CHAR = QUOTE?
         LA    R1,1(R1)            RESTORE POINTER BEFORE TEST
         BE    MCLXSBST            IF YES MUST BE SUBSTRING LP
         TM    AVMBYTE2,$MOPRTR    PREV BSU = OPRTR?
         BNO   MCLXSYER            ERROR IF NOT
         MVI   0(RZ),X'00'         CLEAR FIRST BYTE OF PAREN INFO
         MVI   MCBSINDX,$BSLPAR    ELSE MUST BE LEFT PAREN
         B     MCLXPARF            JUMP TO L PAREN FOOT
         SPACE
*   SUBSCRIPT  CHECK                                                  A
MCLXSBSC EQU   *
         MVI   0(RZ),$MINSBSC      IDENTIFY PAREN LEVEL
         MVI   MCBSINDX,$BSBSCRP   SET BSU INDEX
         OI    AVMBYTE2,$MINAPAR   INDICATE INSIDE ARITH PARENS
         B     MCLXPARF            JUMP TO PAREN FOOT
         SPACE
*   SYSLIST CHECK                                                     A
MCLXSBSL EQU   *
         MVI   0(RZ),$MINSYSL      SET PAREN ID TO SYSLIST
         MVI   MCBSINDX,$BSBSYL    SET BSU INDEX ALSO
         OI    AVMBYTE2,$MINAPAR   INDICATE INSIDE ARITH PARENS
         CLI   MCBSINDP,$BSATN     IS IT THE N'                       A
         BNE   MCLXPARF            PROCEED IF NOT
         MVI   0(RZ),$MINSBSC      ELSE SET FLAG TO STOP 2 SUBSCRIPTS
         B     MCLXPARF            JUMP TO L PAREN FOOT
         SPACE
*   SUBSTRING CHECK                                                   A
MCLXSBST EQU   *
         MVI   0(RZ),$MINSBST      INDICATE PAREN IS SUBSTRING START
         MVI   MCBSINDX,$BSBSTR    SET BSU INDEX ALSO
         OI    AVMBYTE2,$MINAPAR   ALSO INDICATE INSIDE ARITH PARENS
         B     MCLXPARF            JUMP TO L PAREN FOOT
         SPACE
*   FOOT FOR LEFT PAREN                                               A
MCLXPARF EQU   *
         LA    RA,1(R1)            BUMP SCAN POINTER PAST (
         MVI   MCBSHIER,$MPARHR    SET PAREN HIERARCHY
         NI    AVMBYTE2,X'FF'-$MDIMVAR   TURN OFF DIMVAR FLAG
         MVI   AVMDWRK4,X'00'      TURN OFF SYSLIST FLAG
         B     MCLXDLMF            JUMP TO DELIM/OPRTR FOOT
         SPACE 4
* RIGHT PAREN FOUND CHECKS FOR RIGHT NUMBER AF ARGUMENTS, SEES IF     A
* CORRECT NESTING MOVES SUBSCIPTS INTO BSU, ALWAYS PROCESSED INFO     A
* AND CHECKS FOR MATCHED PARENS(N'LPREN=N'RPAREN)                     A
*                                                                     A
MCLXRPAR EQU   *
         LA    RZ,AVMDWRK4(RY)     GET @ CURRENT PAREN INFORMATION    J
         TM    0(RZ),$MINSBST      IN SUBSTRING?
         BNO   MCLXRP01            PROCEED IF NOT
         TM    0(RZ),$MINSBST+X'01'     TWO ARGUMENTS?
         BNO   MCLCOMR1                                               S
MCLXRP01 EQU   *
         TM    AVMBYTE2,$MTERM     PREV BSU = TERM?
         BO    MCLXRP02            OKAY IF YES
         CLI   MCBSINDP,$BSRPAR    MUST BE RIGHT RAREN                A
         BNE   MCLXSYER            ERROR IF NOT )
MCLXRP02 EQU   *
         MVC   MCBSLOC+3(1),0(RZ)  MOVE NBR OF SUBSCRIPTS INTO BSU
         S     RY,AWF1             DECR PAREN COUNT
         BP    MCLXRP03            OKAY IF STILL POSITIVE
         BM    MCLXSYER            ERROR IF NEGATIVE
         NI    AVMBYTE2,X'FF'-$MINAPAR  TURN OFF ARITH EXPRESSION FLAG
         TM    AVMBYTE2,$MINPEXP   END OF EXPRESSI6N?
         BO    MCLXRP04            IF YES RETURN
         B     MCLXRP06            RETURN IF PAREN COUNT IS ZERO
MCLXRP03 EQU   *
         BCTR  RZ,0                DECR POINTER TO PAREN INFO
         LR    RE,RY               COPY PAREN COUNT INTO RE
MCLXRP05 EQU   *
         TM    0(RZ),$MINSBST+$MINSBSC+$MINSYSL  IN ARITH EXPRESSION?
         BM    MCLXRP06            IF YES RETURN
         BCTR  RZ,0                ELLE DECR POINTER AGAIN
         BCT   RE,MCLXRP05         DECR PAREN COUNT
         NI    AVMBYTE2,X'FF'-$MINAPAR  TURN OFF ARITH FLAG IF ZERO
MCLXRP06 EQU   *
         MVI   MCBSINDX,$BSRPAR    SET RIGHT PAREN INDEX IN BSU
         LA    RA,1(RA)            BUMP POINTER PAST PAREN
         B     MCLXDLMF
         SPACE
MCLXRP04 EQU   *
         MVI   MCBSINDX,$BSRPAR    SET INDEX IN BSU
         MVI   MCBSHIER,$MPARHR    SET HIERARCHY
         OI    MCBSFLGS,$MOPRTR    SET OPRTR FLAG IN BSU
         $SCOF RB,RA,MCBSOFST      GET OFFSET IN BSU
         LA    RA,1(R1)            BUMP SCAN POINTER
         BAL   RE,MCLXBMP          BUMP BSU
         NI    AVMBYTE2,X'FF'-$MINPEXP  TURN OFF PAREN EXPR FLAG
         B     MCLXFOOT            RETURN
         SPACE 2
* COMMA FOUND, CHECKS VALIDITY AND FLAGS ERRORS                       A
*                                                                     A
MCLCOMMA EQU   *
         LTR   RY,RY               ARE WE IN PARENS?
         BZ    MCLXSYER            ERROR IF NOT
         LA    RZ,AVMDWRK4(RY)     GET PTR TO PAREN INFO              A
         TM    0(RZ),$MINSBST+$MINSYSL  IN SUBSTR OR SYSLIST?
         BM    MCLCOM01            OKAY IF YES
MCLCOMR1 EQU   *
         LA    RB,$ERINSBV        ELSE SET WRONG NBR ARGS FLAG
         B     MCLXERTN            AND RETURN
MCLCOM01 EQU   *
         TM    0(RZ),X'01'         ONE ARG ALREADY PROCESSED?
         BO    MCLCOMR1            ERROR IF YES
         OI    0(RZ),X'01'         INDICATE ONE ARG PROCESSED
         MVI   MCBSINDX,$BSCOMMA   SET BSU INDEX
         MVI   MCBSHIER,$MCOMMHR   SET HIERARCHY
         LA    RA,1(R1)            BUMP SCAN POINTER
         B     MCLXDLMF            JUMP TO DILIM/OPRTR FOOT
         SPACE 4
* AMPERSANDS FOUND, PROCESS IT. C HECKS FOR VARIABLES, FOR INSIDE     A
* QUOTES, ADDS CONCATINATION OPERATOR WHEN NEEDED, SYBOL PARMS, ETC   A
* ALSO SEARCHES DICTIONARIES AND PROCESS GLOBAL, LOCAL & SYMBOLIC     A
* VARIABLES                                                           A
*                                                                     A
MCLAMPRS EQU   *
         TM    AVMBYTE2,$MINCHAR   IN CHAR EXPRESSION?
         BNO   MCLAMP00            PROCEED IF NOT
         TM    AVMBYTE1,$MINQUOT   SHOULD BE IN QUOTES
         BO    MCLAMP00            OKAY IF YES
         TM    AVMBYTE2,$MINAPAR   IN SUBSCRIPT?
         BO    MCLAMP00            THIS EXCUSSES ALL
         LA    RB,$ERMISQU         ELSE SETT MISSING QUOTES FLAG
         B     MCLXERTN            AND RETURN
MCLAMP00 EQU   *
         TM    AVMBYTE1,$MINQUOT   INSIDE QUOTES?
         BNO   MCLAMPR1            IF NOT, PROCEED
         CLI   1(R1),C'&&'         NEXT CAR = &?
         BNE   MCLAMP01            PROCEED IF NOT
         LA    RA,2(R1)            ELSE BUMP SCAN POINTER PAST &&
         B     MCLXSCAN            AND RESUME SCAN
MCLAMP01 EQU   *
         CR    R0,R1               STRING PRECEEDING &?
         BE    MCLAMPRT            PROCESS VAR SYMB IF NOT
         TM    AVMBYTE2,$MOPRTR    PREV BSU = OPRTR?
         BO    MCLAMP02            PROCEED IF YES
         BAL   RET,MCLXCATI        ELSE INSERT CAT OPRTR
MCLAMP02 EQU   *
         LR    RB,R1               ELSSE COPY END OF STRING+1
         LR    RA,R0               GET START OF STRING
         $CALL MCGTST              GET STRING
         STC   RD,MCBSTRLN         SAVE STRING LENGTH IN BSU
         ST    RC,MCBSLOC          SAVE LOCATION IN BSU
         MVI   MCBSINDX,$BSTRING   IDENTIFY BSU
         OI    MCBSFLGS,$MINQUOT+$MTERM+$MINCHAR  SET FLAGS IN BSU
         $SCOF RB,R0,MCBSOFST      PUT OFFSET IN BSU
         LR    R0,RA               BUMP START POINTER
         BAL   RE,MCLXBMP          BUMP BSU
         B     MCLAMPR0            PROCEED                            A
MCLAMPRT EQU   *
         TM    AVMBYTE2,$MOPRTR    PREV BSU = OPRTR?
         BO    MCLAMPR1            PROCEED IF YES
         SPACE 2
MCLAMPR0 BAL   RET,MCLXCATI        INSERT CONCAT OPR                  A
MCLAMPR1 EQU   *
         TM    AVMBYTE1,$MINQUOT   INSIDE QUOTES?
         BNO   MCLAMPR2            PROCEED IF NOT
         OI    MCBSFLGS,$MINQUOT   ELSE SET QUOTR FLAG IN BSU
MCLAMPR2 EQU   *
         $CALL MCSYSR              FIND SYMBOL IN DICTIONARIES
         LTR   RB,RB               OKAY?
         BP    MCLXERTN            UNDEFINED IF RB > 0
         BM    MCLXISER            INVALID SYMBOL IF RB < 0
         B     *(RD)               JUMP TO ROUTINE
         B     MCLAGLOB            GLOBAL SYMBOL?
         B     MCLALOCL            LOCAL SYMBOL?
         B     MCLASYPR            SYMBOLIC PARAMETER?
         USING MCPARENT,RC         SET USING FOR PARAMETER
MCLASYSV EQU   *                   SYTEM VARIABLE IF BRANCH HERE
         CLI   MCPARNLN,X'08'      COMPARE LENGTH
         BE    MCLASYLS            IF 8, MUST BE SYSLIST
         CLI   MCPARNAM+6,C'X'     IS IT &SYSNDX
         BE    MCLASYDX            PROCESS IF YES
         MVI   MCBSINDX,$BSYSECT   MUST BE &SYSSECT
         B     MCLXTRMF
MCLASYLS EQU   *
         MVI   MCBSINDX,$BSYSLST   SET &SYSLST INDEX IN BSU
         OI    AVMDWRK4,$MINSYSL   SET SYSLIST FLAG IN PAREN BYTE
         B     MCLAGSYL            GO TO MAKE SURE ( THERE AND FLAG   J
MCLASYDX EQU   *
         MVI   MCBSINDX,$BSYSNDX   SET &SYSNDX FLAG IN BSU
         B     MCLXTRMF
* SYMBOLIC PARAMETER FOUND                                            A
MCLASYPR EQU   *
         MVI   MCBSINDX,$BSYMPAR   SET SYMBOLIC PARAM BSU INDEX
         LH    R2,MCPARNDX         GET SYM PAR POSITION
         ST    R2,MCBSLOC          STORE IN BSU
         CLI   0(RA),C'('          NEXT CHAR = '('?
         BNE   MCLXTRMF            PROCEED TO FOOT IF NOT
         OI    AVMBYTE2,$MDIMVAR    ELSE SET DIM VARIABLE FLAG
         B     MCLXTRMF
         DROP  RC
         SPACE 2
* GLOBAL SYMBOL FOUND                                                 A
         USING MCGLBDCT,RC
MCLAGLOB EQU   *
         ST    RC,MCBSLOC          STORE ENTRY @ IN BSU
         CLI   MCGLBTYP,X'08'      WHAT TYPE OF GLOBAL SYMBOL?
         BH    MCLASY01
         BL    MCLASY02            ARITH IF LOW
         MVI   MCBSINDX,$BSTSYBG   MUST BE BOOL IF FALLS THROUGH
         OI    MCBSFLGS,$BSBOOL    SET BOOLEAN FLAG
         B     MCLAGLFT
MCLASY01 EQU   *
         MVI   MCBSINDX,$BSTSYCG   SET CHAR BSU INDEX
         OI    MCBSFLGS,$BSCHAR    SET CHAR FLAG
         B     MCLAGLFT
MCLASY02 EQU   *
         MVI   MCBSINDX,$BSTSYAG   SET ARITH BSU INDEX
         OI    MCBSFLGS,$BSAR      SET ARITH FLAG
         B     MCLAGLFT
         DROP  RC
         SPACE 2
* LOCAL SYMBOL FOUND                                                  A
         USING MCLCLDPV,RC
MCLALOCL EQU   *                   ROUTINE FOR LOCAL SYMBOLS
         ST    RC,MCBSLOC          SAVE ENTRY @ IN BSU
         CLI   MCLCLTYP,X'08'      WHAT TYPE LOCAL SYMBOL?
         BH    MCLASY03            CHAR IF HIGH
         BL    MCLASY04            ARITH IF LOW
         MVI   MCBSINDX,$BSTSYBL   SET LOCAL INDEX IF FALLS THROUGH
         OI    MCBSFLGS,$BSBOOL    SET BOOLEAN TYPE FLAG
         B     MCLAGLFT
MCLASY03 EQU   *
         MVI   MCBSINDX,$BSTSYCL   SET LOCAL CHAR SYMBOL INDEX
         OI    MCBSFLGS,$BSCHAR    SET CHAT TYPE FLAG
         B     MCLAGLFT
MCLASY04 EQU   *
         MVI   MCBSINDX,$BSTSYAL   SET LOCAL ARTITH INDEX
         OI    MCBSFLGS,$BSAR      SET ARITH TYPE FLAG
MCLAGLFT EQU   *
         CLC   MCLCLDIM,AWH1       SET SYMBOL DIMENSIONED?
         BE    MCLASY06            IF NOT, JUMP
MCLAGSYL OI    AVMBYTE2,$MDIMVAR   SHOW DIMENSIONED                   J
         CLI   0(RA),C'('          MUST BE LEFT PAREN
         BE    MCLXTRMF            OK IF YES
MCLASY05 EQU   *
         LA    RB,$ERSSDIM         ELSE SET SUBSCRIPT ERROR FLAG
         B     MCLXERTN            AND RETURN
MCLASY06 EQU   *
         CLI   0(RA),C'('          NEXT CHAR = (?
         BNE   MCLXTRMF            OKAY IF NOT
         TM    AVMBYTE1,$MINQUOT   INSIDE QUOTES?
         BO    MCLXTRMF            PAREN OKAY IF YES
         B     MCLASY05            ELSE FLAG BAD PAREN
         DROP  RC
         SPACE 2
* PERIOD FOUND, LEGAL IF IN CHAR EXP & IF NOT, CONCATINATION OPERATOR A
* NEEDED AND BSU INSERTED                                             A
MCLPEROD EQU   *
         TM    AVMBYTE2,$MINCHAR   IN CHAR EXPRESSION?
         BNO   MCLXSYER            ERROR IF NOT
         TM    AVMBYTE1,$MINQUOT   ARE WE IN QUOTES?
         BNO   MCLPER01            PROCEED IF NO
         CR    R0,R1               POINTER MOVED?
         BE    MCLPER02            PROCEED IF NOT
MCLPER00 EQU   *
         LA    RA,1(R1)            ELSE BUMP PNTR PAST '.' AND RESUME
         B     MCLXSCAN            SCAN
MCLPER02 EQU   *
         CLI   1(R1),C'&&'         POSSIBLE VAR SYMBOL?
         BNE   MCLPER0A            PROCEED IF NOT
         CLI   2(R1),C'&&'         DOUBLE '&&'?
         BNE   MCLPER0B            CAT OPRTR IF NOT
MCLPER0A EQU   *
         IC    R2,1(R1)            GET NEXT CHARACTER
         LA    R2,AWTSYMT(R2)      USE AS POINTER INTO TABLE
         CLI   0(R2),X'00'         NEXT CHAR IS ALPHANUM?
         BNE   MCLPER00            TREAT PERIOD AS CHAR IF NOT
MCLPER0B EQU   *
         CLI   MCBSINDP,$BSCAT     PREV SYM= COCAT?                   A
         BE    MCLPER00            TREAT AS CHAR IF YES
MCLPER01 EQU   *
         $SCOF RB,R1,MCBSOFST      GET OFFSET OF CAT OPRTR
         BAL   RET,MCLXCATI        ELSE INSERT CAT OPRTR
         B     MCLXSTRS            RESUME SCAN                        S
         SPACE 4
* QUOTE FOUND, PROCESS FOR CHAR END, NULL STRING SYMBOL(DOUBLE QUOTES)A
* ALSO ERROR CHECKING DONE                                            A
MCLQUOTE EQU   *
         C     R1,AVSOLAST         END OF RECORD?
         BNL   MCLQUER1            ERROR IF YES
         TM    AVMBYTE1,$MINQUOT   ARE WE IN QUOTES?
         BNO   MCLQ02              IF NOT, SET FLAGS AND PROCEED
         CLI   1(R1),C''''         DOUBLE QUOTE?
         BNE   MCLQTF              IF NOT, GET STRING
         LA    RA,2(R1)            ELSE BUMP POINTER AND RESUME SCAN
         B     MCLXSCAN
MCLQ01   EQU   *
         LR    RB,R1               COPY END OF STRING + 1
         LR    RA,R0               COPY START OF STING
         $CALL MCGTST              GET STRING
         ST    RC,MCBSLOC          SAVE LOCATION IN BSU
         STC   RD,MCBSTRLN         SAVE STRING LENGTH IN BSU
         MVI   MCBSINDX,$BSTRING   IDENT BSU
         OI    MCBSFLGS,$MINQUOT   FLAG BSU AS IN QUOTE
         LA    RA,1(R1)            BUMP SCAN POINTER PAST QUOTE
         XI    AVMBYTE1,$MINQUOT   TURN QUOTE FLAG ON/OFF
         B     MCLXTRMF
MCLQ02   EQU   *
         TM    AVMBYTE2,$MINARIT   IN ARITH EXPRESSION?
         BO    MCLXISER            ERROR IF YES
         XI    AVMBYTE1,$MINQUOT   TURN ON QUOTE FLAG
         B     MCLXSTRS            RESUME SCAN                        S
MCLQTF EQU *
         CR    R0,R1               STRING PRESENT?
         BNE   MCLQTF01            IF YES, PROCEED
         BCTR  R1,0                ELSE DECR POINTER
         CLI   0(R1),C''''         PREV CHAR = QUOTE?
         LA    R1,1(R1)            RESTORE POINTER BEFORE TEST
         BE    MCLQ01              IF YES, PROCESS NULL STRING
         B     MCLQ02              ELSE TURN OFF FLAG AND RESUME SCAN
MCLQTF01 EQU   *
         TM    AVMBYTE2,$MTERM     PREV BSU = TERM?
         BNO   MCLQ01              PROCEED IF NOT
         BAL   R14,MCLXCATI        ELSE INSERT CATEN OPRTR
         B     MCLQ01              AND THEN PROCEED
         SPACE 2
         SPACE
MCLQUER1 EQU   *
         LR    RA,R1               GET @ OF RECORD ENDING QUOTE
         S     RA,=F'2'            DECR TO END OF OPERAND
         B     MCL$ERV                                                S
         SPACE 2
MCLBLANK EQU   *
         LTR   RY,RY               STILL IN PARENS?
         BZ    MCLXFOOT            RETURN IF NOT
         TM    AVMBYTE2,$MINBOOL   IN BOOLEAN EXPRESSION
         BO    MCLXSTRS            OK IF YES, RESUME SCAN             S
MCL$ERV  LA    RB,$ERVUNEX         ELSE SET ERROR FLAG                S
         B     MCLXERTN            AND RETURN
         SPACE 4
MCLXOPRF EQU   *
         TM    AVMBYTE2,$MOPRTR    PREV BSU = OPRTR?
         BNO   MCLXDLMF            OKAY IF NOT
         CLI   MCBSINDX,$BSNOT     IS CURRENT SYMBOL = NOT ?          S
         BNE   MCLXOPER            ERROR IF NOT
         CLI   MCBSINDP,$BSLPAR    IS IT LEFT PAREN                   A
         BE    MCLXOP01            OKAY IF YES
         CLI   MCBSINDP,$BSAND     IS IT AN AND?                      A
         BE    MCLXOP01            OKAY IF YES
         CLI   MCBSINDP,$BSOR      IT IS OR?                          A
MCLXOP01 EQU   *
         BE    MCLXDLMF            RESUME SCAN IF ONE OF (, AND OR
         B     MCLXSYER            ELSE FLAG ERROR
MCLXOPER EQU   *
         CLI   MCBSINDP,$BSRPAR    PREV SYMBOL = RIGHT PAREN ?        S
         BE    MCLXOP01            OKAY IF YES
         B     MCLXSYER            ELSE FLAG ERROR
         SPACE 4
MCLXTRMF EQU   *
         TM    AVMBYTE2,$MTERM     PREV BSU = TERM?
         BO    MCLXSYER            ERROR IF YES
         OI    MCBSFLGS,$MTERM     SET FLAG IN BSU
         XI    AVMBYTE2,$MOPRTR+$MTERM  TURN ON TERM FLAG
         B     MCLXF09             JUMP TO FOOT
         SPACE 4
MCLXDLMF EQU   *
         OI    MCBSFLGS,$MOPRTR    TURN ON OPRTR FLG IN BSU
         NI    AVMBYTE2,X'FF'-$MDIMVAR-$MTERM  TERM,DIMVAR FLAGS      A
         OI    AVMBYTE2,$MOPRTR    TURN ON OPRTR FLAG
         B     MCLXF09
         SPACE 4
**--> INSUB: MCLXCATI    ROUTINE TO INSERT CONCATINATION + + + + + + +A
*+                                                                    A
*+ CALLED WHEN CONCATINATION OPERATION NEEDED, INSERTR BSU            A
*+                                                                    A
*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +A
         SPACE 2                                                      A
MCLXCATI EQU   *
         MVI   MCBSINDX,$BSCAT     SET CATEN INDEX
         MVI   MCBSHIER,$MCATHR    SET HEERARCHY
         TM    AVMBYTE1,$MINQUOT   INSIDE QUOTES?
         BNO   MCLXCAT1            SKIP IF NOT
         OI    MCBSFLGS,$MINQUOT   SET IN QUOTE FLAG IN BSU
MCLXCAT1 EQU   *
         OI    MCBSFLGS,$MOPRTR    SET OPRTR FLAG IN BSU
         BAL   RE,MCLXBMP          BUMP BSU
         NI    AVMBYTE2,X'FF'-($MOPRTR+$MTERM)  TURN OFF FLAGS
         OI    AVMBYTE2,$MOPRTR    SET PREV SYMBOL = OPRTR FLAG
         BR    R14                 RETURN
         SPACE 4
**--> INSUB: MCLXBMP       BUMP POINTER  + + + + + + + + + + + + + + +S
*+       SAVE PREVIOUS BSU AND BUMP POINTER                          +S
*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +S
         SPACE 2                                                      S
MCLXBMP  EQU   *
         MVC   MCBSFLGP(4),0(RW)   MOVE PREV BSU INTO WRK AREA        A
         XSNAP T=NO,STORAGE=(*0(RW),*8(RW)),LABEL='BSU - MACLEXP',     #
               IF=(AVTAGSM,O,AJOMACRH,TM)
         LA    RW,$LMCBSU(RW)      BUMP BSI POINTER                   A
         C     RW,AVMCHLIM         WORK AREA EXCEEDED?
         BL    MCLXBMP1            OK IF NOT
         LA    RB,$ERVTMTR         ELSE FLAG TOO MANY TERMS
         B     MCLXERTN            AND RETURN
MCLXBMP1 EQU   *
         MVC   MCBSU(8),AWZEROS    ZERO NEW BSU
         BR    RE                  AND RETURN
MCBSFLGP DS    C                   PREVIOS                            A
MCBSINDP DS    C                   BSU                                A
MCBSOFSP DS    C                   WORK                               A
MCBSHIEP DS    C                   AREA                               A
         SPACE 2
MCLXF09  EQU   *
         $SCOF RB,R0,MCBSOFST      GET OFFSET INTO BSU
         BAL   RE,MCLXBMP          BUMP BSU
         TM    AVMBYTE4,$MINSTRN   PROCESSING OUTSIDE VAR SYMBOL?
         BNO   MCLXSTRT            IF NOT, RESUME SCAN
         NI    AVMBYTE4,X'FF'-$MINSTRN  ELSE TURN OFF FLAG
         CLI   0(RA),C'('          PAREN FOLLOWING?
         BNE   MCLXFOOT            RETURN IF NOT
         OI    AVMBYTE2,$MINPEXP   ELSE SET PARENS ONLY FLAG
         B     MCLXSTRT            AND RESUME SCAN
         SPACE 2
MCLXISER EQU   *
         LR    RA,R0               RESTORE SCAN POINTER
         LA    RB,$ERINVSY         SET INVALID SYMBOL FLAG
         B     MCLXERTN            AND RETURN
         SPACE 2
MCLEXERR EQU   *
MCLXSYER EQU   *
         LR    RA,R0               RESTORE SCAN POINTER
         LA    RB,$ERVSYNT         SET SYNTAX ERROR FLAG
         B     MCLXERTN            AND RETURN
         SPACE 2
MCLXFOOT EQU   *
         SR    RB,RB
         TM    AVMBYTE2,$MOPRTR    LAST BSU = OPRTR?
         BNO   MCLXERTN            RETURN NORMALLY IF NOT
         CLI   MCBSINDP,$BSRPAR    IT IS RIGHT PAREN?                 A
         BE    MCLXERTN            RETURN                             S
MCLXFTER EQU   *
         $SCPT RA,MCBSOFST         GET POINTER TO ERROR
         LA    RB,$ERVSYNT         SET ERROR FLAG
MCLXERTN EQU   *
MCLEQUAL EQU   MCLXERTN            ERROR IF '==' TURNS UP             S
         $SETRT ('''',0,'&&',0,'.',0)   RESTORE TRT TABLE
         MVI   AWTDECT+C'+',2
         MVI   AWTDECT+C'-',2
         MVI   AWTDECT+C'/',2      RESTORE AWTDEDT TABLE TO ORIGINAL
         MVI   AWTDECT+C')',2      CONDITIONS BEFORE RETURNING
         MVI   AWTDECT+C'''',2
         MVI   AWTDECT+C'&&',2
         MVI   AWTDECT+C'.',2
         XSNAP LABEL='***MACLEX EXITED***',IF=(AVMSNBY2,O,$MSNP09,TM)
         LR    RC,RW               SET BSU POINTER
         $RETURN  RGS=(R14-R6)
         LTORG
         DROP  RAT,RW
         TITLE '***  MCGNCD - GENERATE INTERNAL CODE FOR MACRO S'
**-->  CSECT:  MCGNCD  CONVERTS STRING OF BSU'S TO INTERNAL CODE      *
*.        IN ONE-OP FORM.  ONE-OPS ARE QUADRUPLES WITH OPRTR, TWO     *
*.        OPRNDS AND RESULT FIELD.   ADDRESS OF CURRENT GENERATED INST*
*.        IS IN AVMCRINS.  GEERATED CODE IS POINTED TO BY MCCODLNK    *
*.        FIELD IN MACLIB.  BSU STRING LOCATED IN AVMWRK1             *
*.                                                                    *
*.        ENTRY CONDITIONS                                            *
*.     RC = @ OF CURRENT MACLIB ENTRY                                 *
*.                                                                    *
*.        USES MACROS: $CALL,$SAVE,$RETURN,$SCOF,$SCPT,$ALLOCL,$ALLOCH*
*.        USES DSECTS: AVWXTABL,MCBSU,MCBSTRMS,MCBOPRST,MCOPQUAD,     *
*.                     MACLIB,MCSEQ                                   *
*.        CALLS MACFND, ERRTAG,                                       *
*.                                                                    *
*.        REGISTER USAGE:                                             S
*.             WORK REGS:  R0,R1,RA,RB,RC,RE                          S
*.             TRT BYTE REG:  R2                                      S
*.             RW  - BASE REG FOR BSU                                 S
*.             RX  - BASE REG FOR OPRND STACK                         S
*.             RY  - BASE REG FOR OPRTR STACK                         S
*.             RZ  - BASE REG FOR ONE-OP ENTRY                        S
*.             RAT - BASE REG FOR MAIN TABLE                          S
*.             R1  - BASE REG FOR MACLIB                              S
*.             RD  - UNUSED                                           S
*.                                                                    S
*.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 2
MCGNCD   CSECT
         $SAVE RGS=(R14-R6),BR=13,SA=*
         USING AVWXTABL,RAT        NOTE MAIN TABLE USING
         XSNAP LABEL='***MCGNCD ENTERED***',IF=(AVMSNBY2,O,$MSNP10,TM)
         USING MCBSU,RW            NOTE USING FOR BSU INPUT STRING
         USING MCBSTRMS,RX         USING FOR OPRND STACK
         USING MCBOPRST,RY         USING FOR OPRTR STACK
         USING MCOPQUAD,RZ         USING FOR ONE-OP ENTRY
         USING MACLIB,RC           USING FOR MACLIB ENTRY
         NI    AVMBYTE4,X'FF'-($MCOMST+$MRPARST)   CLEAR COMMA, RP FLAG
         LA    R0,$LMCBSU          LENGTH OF BSU FOR BUMPING          A
         SR    R2,R2               CLEAR BYTE REGISTER                A
         LA    RB,$LMCOPL1         GET LENGTH OF PREFIX SECTION       A
         $ALLOCL RE,RB,MCGNCDOV    GET SPACE FOR IT                   A
         MVC   0($LMCOPL1,RE),AWZEROS CLEAR OUT ONE-OP PREFIX         A
         L     RZ,AVMCRINS         GET PREV INST @
         LTR   RZ,RZ               1ST INSTRUCTION?
         BNZ   MCGNCD00            IF NOT, PROCEED
         LA    RZ,MCCODLNK         FAKE POINTER AS 1ST ONE            A
MCGNCD00 EQU   *
         ST    RE,MCQUDNXT         SAVE LINK IN PREV INSTRUCTION
* CREATE STACK OF ONE OPS                                             A
MCGNCD01 EQU   *
         LR    RZ,RE               SET BASE TO NEW ENTRY
         ST    RZ,AVMCRINS         SAVE CURRENT INST @
         ZAP   MCQSTMNO,AVOULNCN   STORE CURRENT PACKED DEC STMT NBR
         L     RW,AVMCHSTR         GET @ OF BSU INPUT STRING
         XSNAP LABEL='BEGIN MCGENCD',STORAGE=(*0(RW),*100(RW)),        X
               IF=(AVTAGSM,O,AJOMACRH,TM)                             A
         LA    RX,AVMWRK2          USE AVMWRK2 FOR OPRND STACK
         LA    RY,AVMWRK1          USE QVMWRK1 FOR OPRTR STACK
         MVC   MCBSTRMS($LMCBSU),AWZEROS  CLEAR OPRND STACK
         MVC   MCBOPRST($LMCBSU),AWZEROS   CLEAR OPRTR STACK
         SR    RX,R0               DECR APRND PTR FOR STMT            A
*  POP BSU, SET PRIORITIES AND PUSH ON APPROPRIATE STACK              A
MCGNCDSC EQU   *
         CLI   MCBSINDX,X'00'      END OF BSU'S?
         BE    MCGENCD             IF YES , POP INSTRUCTIONS
         TM    AVMBYTE4,$MRPARST+$MCOMST  PAREN OR COMMA FLAG ON?
         BM    MCGENCD             IF YES, POP INSTRUCTION
         TM    MCBSFLGS,$MTERM     TERM?
         BNO   MCGNCD02            IF NOT, PROCESS OPRTR
         AR    RX,R0               ELSE BUMP OPRND STACK PTR          A
         MVC   MCBSFLG2($LMCBSU),MCBSU  ELSE PUSH TERM ON OPRND STACK
         B     MCGNCD06
MCGNCD02 EQU   *
         CLI   MCBSINDX,$BSCOMMA   COMMA?
         BNE   MCGNCD03            TEST FOR PAREN IF NOT
         OI    AVMBYTE4,$MCOMST    ELSE SET FLAG
         B     MCGNCD06            AND JUMP TO FOOT
MCGNCD03 EQU   *
         CLI   MCBSINDX,$BSRPAR    REGHT PAREN?
         BNE   MCGNCD04            PROCEED IF NOT
         OI    AVMBYTE4,$MRPARST   ELSE SET FLAG
         B     MCGNCD06            AND JUMP TO FOOT
MCGNCD04 EQU   *
         CLI   MCBSHIER,$MPARHR    PAREN?
         BNE   MCGNCD05            PROCEED IF NOT
         CLI   MCBSINDX,$BSBSTR    SUBSTRING?
         BNE   MCGNPUSH            IF NOT, PUSH ONTO OPRTR STACK
         CLI   MCBSOPST,$BSCAT     CAT OPRTR IN STACK?
         BNE   MCGNPUSH            PUSH OPRTR IF NOT
         TM    MCBOPFL,$MINQUOT    CAT OPRTR IN QUOTES?
         BO    MCGENCD             POP OPRTR IF YES
MCGNPUSH EQU   *
         AR    RY,R0               BUMP STACK POINTER                 A
         MVC   MCBOPRST($LMCBSU),MCBSU  PUSH OPRTR ONTO STACK
         B     MCGNCD06            JUMP TO FOOT
MCGNCD05 EQU   *
         CLI   MCBSINDX,$BSCAT     CAT OPRTR?
         BNE   MCGNCD07            PROCESS NORMALLY IF NOT
         TM    MCBSFLGS,$MINQUOT   CAT OPRTR IN QOTES?
         BNO   MCGNCD07            PROCESS NORMAL IF NOT
         CLC   MCBSHIER,MCBOPHR    COMPARE HIERARCHIES
         BNL   MCGNPUSH            H(OPRRTR) >=H(STACK) THEN PUSH
         B     MCGENCD             ELSE POP OPRTR
MCGNCD07 EQU   *
         CLC   MCBSHIER,MCBOPHR    COMPARE HIERARCHIES
         BH    MCGNPUSH            PUSH OPRTR ONLY IF HIGH
         B     MCGENCD             ELSE POP OPRTR
MCGNCD06 EQU   *
         AR    RW,R0               POP INPUT BSU STACK                A
         B     MCGNCDSC            AND RESUME SCAN OF INPUT
MCOPRBAS DS    0H
         EJECT                                                        A
MCGENCD  EQU   *
         NI    AVMBYTE1,X'FF'-$MINQUOT   TURN OFF QUOTE FLAG
         TM    MCBSFLG1,$MINQUOT     FIRST TERM IN QUOTES?
         BZ    MCGENCD0            PROCEED IF NOT
         OI    AVMBYTE1,$MINQUOT   ELSE SET QUOTE FLAG
MCGENCD0 EQU   *
         CLI   MCBOPHR,$MPARHR     LEFT PAREN?
         BNE   MCGENCD2            PROCEED IF NOT
         TM    AVMBYTE4,$MCOMST    WORKING ON COMMA?
         BNO   MCGENCD1            PROCEED IF NOT
         XI    AVMBYTE4,$MCOMST    ELLE TURN OFF COMMA FLAG
         B     MCGNCDSC            AND RESUME SCAN
MCGENCD1 EQU   *
         NI    AVMBYTE4,X'FF'-$MRPARST   ELSE TURN OFF PAREN FLAG
         CLI   MCBSOPST,$BSLPAR     ORDINARY LEFT PAREN?
         BE    MCGENRT             IF YES POP OPRTR AND RESUME SCAN
*                                                                     A
*  ALLOCATE SPACE FOR ONE OP ENTRIES                                  A
*  HIERARCHY AND JUMP ON INDEX TO PROCESS                             A
*                                                                     A
MCGENCD2 EQU   *
         CLI   MCBSOPST,X'00'      OPRTR STACK EMPTY?
         BE    MCGNCDRT            RETURN IF YES
         BAL   RET,MCGNALLO        ALLOCATE SP FOR 1 OP ENTRY         S
         IC    R2,MCBOPHR          GET HIERARCHY
         LH    R1,MCOPRNDX(R2)     GET OFFSET
         B     MCOPRBAS(R1)        JUMP TO ROUTINE
         SPACE
MCOPRNDX $AL2  MCOPRBAS,(MCPARGEN,MCHRTW,MCORGEN,MCANDGEN,MCRELGEN,MCCAX
               TGEN,MCPLSGEN,MCMULGEN,MCNOTGEN)
         SPACE
*  PAREN BSU FOUND PUT ONE-OP ON STACK                                A
*                                                                     A
MCPARGEN EQU   *                   HIER = 0 ROUTINES
         BAL   RE,MCMVTRMS         MOVE ARGS TO ONE-OP
         CLI   MCBOPRTR,$BSBSTR    SUBSTRING PAFEN?
         BE    MCPARG0Q            PROCEED IF NOT                     S
MCPARG02 EQU   *
         CLI   MCARG1DX,$BSATT     1ST ARG IS T'?
         BE    MCPARG0Q            TREAT AS QUOTED STRING IF YES
         TM    AVMBYTE1,$MINQUOT   FIRST TERM INSIDE QUOTES?
         BZ    MCPARG03            PROCEED IF NOT
MCPARG0Q EQU   *
         OI    MCBSFLG2,$MINQUOT   SET QUOTE FLAG IN OPRND STACK
MCPARG03 EQU   *
         SR    RW,R0               DECR PTR TO CHECK PREV ENTRY       S
         TM    MCBSLOC+3,X'01'     TWO ARG'S IN PARENS?
         LA    RW,$LMCBSU(RW)      RESTORE POINTER
         BNO   MCGENRT             PROCEED IF NOT
         BAL   RET,MCGNALLO        ALLOCATE SP FOR 1 OP ENTRY         S
         MVC   MCARG1DX,MCBSNDX1   MOVE IDENT OF ARG INTO ONE-OP
         MVC   MCARG1LC,MCBSLOC1   MOVE LOCATION OF OPRND INTO ONE-OP
         CLI   MCARG1DX,$BSTRING   STRING TERM?
         BNE   MCPARG04            PROCEED IF NOT
         MVC   MCARG1LC(1),MCBLN1   MOVE LENGTH OF STRING INTO ONE-OP
MCPARG04 EQU   *
         MVC   MCBSFLG1($LMCBSU),MCBSFLG2 PUSH DOWN OPRND STACK
         B     MCTWODEC            DECR OPRND STACK
         SPACE
*  HEIR=2, PUT ONE-OP ON STACK                                        A
*                                                                     A
MCHRTW   EQU   *
         MVC   MCBOPRTR,MCBSOPST   MOVE OPRTR FROM STACK TO ONE-OP
         CLI   MCBSOPST,$BSPRINT   WHICH BSU OF HIER = 2?
         BL    MCTWOSET            IF LOW, MUST BE SETX
         BE    MCTWOPRA            IF EQUAL MUST BE PRINT             A
         CLI   MCBSOPST,$BSINMAC   ELSE IS IT INNER MACRO CALL?
         BNL   MCTWOPR             INNER IF EQUAL, MVSTR IF HIGH
*        NOTE: THESE JUST USE ONE-OP PREFIX BY THEMSELVES             A
         L     RZ,AVMCRINS         GET # PREFIX ONE-OP                A
         MVC   MCQS1FLG,MCBSOPST   COPY OPERATOR OVER                 A
         B     MCPREFIX            GO TO PREFIX-ONLY EXIT             A
MCTWOSET EQU   *
         BAL   RE,MCMVTRMS         MOVE OPRNDS INTO ONE-OP
         B     MCTWODEC
MCTWOPRA TM    MCBOPFL,$MPRCOM     WAS THIS SPECIAL PRINT COMMENT UP  A
         BZ    *+8                 NO, SKIP                           A
         OI    MCBOPRTR,$MPRCOM    YES, MAKE PRINT OPRTR ODD, SO KNOW A
MCTWOPR  EQU   *
         MVC   MCARG2LC+3(1),MCBOPOF   MOVE OFFSET INTO INTO ARG2LC
         MVC   MCARG1DX,MCBSNDX2   MOVE TYPE INTO ARG1DX
         MVC   MCARG1LC,MCBSLOC2   MOVE LOCATION OF STRING INTO ONE-OP
         CLI   MCBSNDX2,$BSTRING   INDEX BSU IS CHAR STRING?
         BNE   MCTWODEC            SKIP MOVE LEN IF NOT
         MVC   MCARG1LC(1),MCBLN2  MOVE LENGTH INTO LOC FIELD
         B     MCTWODEC            DECR OPRND STACK
*                                                                     A
* PLUS OR MULTIPLY BSU FOUND PUT ONE-OP ON STACK                      A
*                                                                     A
MCPLSGEN EQU   *
MCMULGEN EQU   *
         BAL   RE,MCMVTRMS         MOV& OPRNDS INTO ONE-OP
         MVI   MCBSFLG2,$MTERM+$BSAR  IDENT OPRND STACK TOP AS ARITH TR
         B     MCGENRT             JUMP TO FOOT
         SPACE
*                                                                     A
* AND | OR BSU FOUND, PUT ONE OP ONTO STACK                           A
*                                                                     A
MCORGEN  EQU   *
MCANDGEN EQU   *
         TM    MCBSFLG1,$BSBOOL    1ST OPRND = BOOL?
         BNO   MCMXDR1             ERROR IF NOT
         TM    MCBSFLG2,$BSBOOL    2ND OPRND = BOOL?
         BNO   MCMXDR1             ERROR IF NOT
         BAL   RE,MCMVTRMS         MOVE OPRNSD INTO ONE-OP
         MVI   MCBSFLG2,$MTERM+$BSBOOL  IDENTIFY AS BOOLEAN TERM
         B     MCGENRT             JUMP TO FOOT
         SPACE
* RELATIONAL OPERATOR FOUND PUT ONE-OP ONTO STACK                     A
*                                                                     A
MCRELGEN EQU   *
         MVI   AVMBYTE3,X'00'      CLEAR AVMBYTE3 FOR FLAG USE
         TM    MCBSFLG1,$MINQUOT   1ST TERM IN QUOTES?
         BO    MCRELG02
         TM    MCBSFLG2,$MINQUOT   2ND TERM IN QUOTES?
         BO    MCRELG03
         B     MCRELG01            ELSE PROCEED
MCRELG02 EQU   *
         OI    AVMBYTE3,$BSRLCHR   SET CHAR RELTN FLAG
         TM    MCBSFLG2,$MINQUOT   2ND TERM IN QUOTES?
         BO    MCRELG01            OKAY IF YES
         CLI   MCBSNDX2,$BSATT    ELSE IS IT T'?
         BE    MCRELG01            OKAY IF YES
         B     MCMXDR2             ELSE ERROR
MCRELG03 EQU   *
         OI    AVMBYTE3,$BSRLCHR   SET CHAR RELTN FLAG
         CLI   MCBSNDX1,$BSATT     1ST TERM = T'?
         BNE   MCMXDR2             ELSE ERROR                         S
MCRELG01 EQU   *
         BAL   RE,MCMVTRMS         MOVE TERMS INTO ONE-OP
         OC    MCBOPRTR,AVMBYTE3   SET CHR OR ARIT FLAG IN OPRTR
         MVI   MCBSFLG2,$MTERM+$BSBOOL   IDENTIFY AS BOOLEAN TERM
         B     MCGENRT             JUMP TO FOOT
         SPACE
*  CATENATION BSU FOUND PUT ONE-OP ON STACK                           A
*                                                                     A
MCCATGEN EQU   *
         CLI   AVMFLDT2,C'M'       MACRO OPCODE?
         BNE   MCCATG01            JUMP PAST QUOTE TEST IF NOT
         TM    MCBSFLG1,$MTERM+$MINQUOT  1ST TERM IN QUOTES?
         BNO   MCMXDR1             ERROR IF NOT
         TM    MCBSFLG2,$MTERM+$MINQUOT     2ND TERM IN QUOTES?
         BNO   MCMXDR1             ERROR IF NOT
MCCATG01 EQU   *
         BAL   RE,MCMVTRMS         MOVE OPRNDS INTO ONE-OP
         MVI   MCBSFLG2,$MTERM+$BSCHAR+$MINQUOT   IDENTIFY TEMP OPRND
         B     MCGENRT             JUMP TO FOOT
         SPACE
* 'NOT' BSU FOUND PUT IN OP-OP STACK                                  A
* ALSO CHECK FOR AGO AND AIF, AND PROCESS IF FOUND                    A
*                                                                     A
MCNOTGEN EQU   *
         CLI   MCBSOPST,$BSAGO     AGO OPRTR?
         BH    MCAIFGEN            IF HIGH MUST BE AIF
         BE    MCAGOGEN            IF EQUAL MUST BE AGO
         TM    MCBSFLG2,$MTERM+$BSBOOL  BOOLEAN TERM?
         BNO   MCMXDR2             ERROR IF NOT
         MVC   MCARG1DX,MCBSNDX2   MOVE INDEX INTO ONE-OP
         MVC   MCBOPRTR,MCBSOPST   MOVE OPRTR INTO ONE-OP
         MVC   MCARG1LC,MCBSLOC2   MOVE OPRND LOC INTO ONE-OP
         ST    RZ,MCBSLOC2         PUT @ OF ONE-OP IN OPRND STACK
         MVI   MCBSNDX2,$BSTEMP    IDENTIFY STACK AS TEMP
         B     MCGENRT             JUMP TO FOOT
         SPACE
* AGO OR AIF FOUND, PUT ON OP ON STACK                                A
*                                                                     A
MCAGOGEN EQU   *
         L     RA,MCBOPVAL         GET @ OF SEQ SYMBOL
         BAL   RE,MCSEQSCN         JUMP  TO SCAN SEQ SYM DICT
         MVC   MCBOPRTR,MCBSOPST   MOVE OPRTR INTO ONE-OP
         B     MCGENRT             JUMP TO FOOT
         SPACE
MCAIFGEN EQU   *
         L     RA,MCBSLOC2         GET ADDRESS OF SEQ SYMBOL
         TM    MCBSFLG1,$BSBOOL    BOOLEAN TERM?
         BNO   MCMXDR1             ERROR IF NOT
         BAL   RE,MCSEQSCN         SEQRCH SEQ SYMBOL DICT             A
         MVC   MCARG1DX,MCBSNDX1   MOVE TERM ID TO ONE-OP
         MVC   MCARG1LC,MCBSLOC1   MOVE LOCATION OF TERM TO ONE-OP
         MVC   MCBOPRTR,MCBSOPST   MOVE OPRTR INTO ONE-OP
         MVC   MCARG2DX,MCBSNDX2   MOVE BSU TERM OF ARG INTO ONE-OP
         B     MCTWODEC            DECR OPRND STACK
         EJECT                                                        S
**--> INSUB: MCSEQSCN       ENTER SEQ SYMBOL IN DICT + + + + + + + + +S
*+       SCAN FOR ERRORS & PUT SEQ SYMBOL IN DICT                    +S
*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +S
         SPACE 2                                                      S
MCSEQSCN EQU   *                   ROUTINE TO ENTER SEQ SYMBOL IN DICT
         DROP  RC
         USING MCSEQ,RC            SET USING FOR SEQ SYM ENTRY
         CLI   1(RA),C'0'          FIRST CHAR  IS LETTER?
         BNL   MCSEQR1             ERROR IF DIGIT
         TRT   1(8,RA),AWTSYMT     SCAN SYMBOL
         BZ    MCSEQR1             SYMBOL 8+ CHARS, TOO LONG
         CLI   0(R1),C' '          DELIM = BLANK?
         BNE   MCSEQR1             ERROR IF NOT
         SR    R1,RA               GET LENGTH
         BCT   R1,MCSEQS01         DECR LENGTH FOR EX INST
         B     MCSEQR1             BUT FALL THRU IF LENGHT = 1
MCSEQS01 EQU   *
         MVC   AVMSYMBL,AWBLANK    BLANK GLOBAL NAME AREA
         STC   R1,AVMSYMLN         STORE LENGTH
         EX    R1,MCGMVC           MOVE SYMBOL                        S
         AIF   (NOT &$MACOPC).MCGNCDA  SKIP IF NOT OPEN CODE          S
         L     R1,AVMACLIB         LOAD @ OF MACLIB ENTRY             S
         USING MACLIB,R1           NOTE USING ON MACLIB               S
         TM    MCLBFLG2,$MCOCFL1   IN OPEN CODE ?                     S
         BCR   O,RE                IF YES, SKIP SEQ SYM MANAGEMENT    S
         DROP  R1                                                     S
.MCGNCDA ANOP                                                         S
         L     RC,AVMSEQPT         GET SEQ SYM POINTER
         LA    R1,0(RE)            SAVE RETURN @ TEMP                 S
         $CALL MACFND              SEARCH SEQ SYMBOL DICT
         LR    RE,R1               RESTORE RETURN @                   S
         LTR   RB,RB               SYMBOL PRESENT IN DECT?
         BZ    MCSEQS02            PROCEED IF YES
         LA    RB,$LMCSEQ          ELSE GET LENGTH OF ENTRY
         $ALLOCH  R1,RB,MCGNCDOV   GET SPACE FOR NEW ENTRY
         ST    R1,MCSEQNXT         SAVE LINK IN PREV ENTRY
         LR    RC,R1               MOVE BASE TO NEW ENTRY
         MVC   MCSEQ($LMCSEQ),AWZEROS  CLEAR NEW ENTRY
         MVC   MCSEQNAM,AVMSYMBL   MOVE NEW NAME INTO ENTRY
         MVC   MCARG2LC,AVMCRINS   STORE STMT @ IN ARG2
         ST    RZ,MCSEQVAL         SAVE LINK TO INST
         BR    RE                  RETURN
MCGMVC   MVC   AVMSYMBL($),0(RA)   DUMMY INSTR                        S
MCSEQS02 EQU   *
         CLI   MCSEQFLG,X'FF'      SYMBOL DEFINED?
         BNE   MCSEQS03            IF NOT, JUMP AND PROCESS
         MVC   MCARG2LC,MCSEQVAL   ELSE PUT VALUE IN ONE-OP
         BR    RE                  AND RETURN
MCSEQS03 EQU   *
         LR    R1,RZ               COPY INST @ TEMPORARILY
         L     RZ,MCSEQVAL         GET POINTER FROM ENTRY
MCSEQS04 EQU   *
         CLC   MCRESULT,AWZEROS    END OF CHAIN?
         BE    MCSEQS05            IF YES, ENTERLINK IN LAST ENTRY
         L     RZ,MCRESULT         ELSE GET POINTER TO NEXT LINK
         B     MCSEQS04            AND TRY AGAIN
MCSEQS05 EQU   *
         ST    R1,MCRESULT         PUT CURRENT @ IN LAST LINK
         LR    RZ,R1               RESTORE BSE OF ONE-OP
         MVC   MCARG2LC,AVMCRINS   STORE STMT @ IN ARG2
         BR    RE                  AND RETURN
         DROP  RC
         SPACE
MCTWODEC EQU   *
         SR    RX,R0               POP OPRND STACK                    S
MCGENRT  EQU   *
         SR    RY,R0               POP OPERATOR STACK                 S
         B     MCGNCDSC            RESUME SCAN
         SPACE 5                                                      S
**--> INSUB: MCMVTRMS       CREATE ONE BINARY ONE-OP + + + + + + + + +S
*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +S
         SPACE 2                                                      S
MCMVTRMS EQU   *                   ROUTINE TO CREATE ONE BINARY ONE OP
         MVC   MCARG1DX,MCBSNDX1   MOVE 1ST TERM ID INTO ONE OP
         MVC   MCARG2DX,MCBSNDX2   MOVE 2ND TERM ID INTO ONE OP
         MVC   MCARG1LC,MCBSLOC1   MOVE 1ST TERM LOCATION INTO ONE-OP
         MVC   MCARG2LC,MCBSLOC2   MOVE 2ND TERM LOCATION INTO ONE-OP
         CLI   MCBSNDX1,$BSTRING   BSU IS A STRING?
         BNE   MCMVTRM1            JUMP IF NOT
         MVC   MCARG1LC(1),MCBLN1    MOVE STRING LENGTH INTO ONE OP
MCMVTRM1 EQU   *
         CLI   MCBSNDX2,$BSTRING   2ND TERM IS STRING?
         BNE   MCMVTRM2            JUMP AROUND IF NOT
         MVC   MCARG2LC(1),MCBLN2  ELSE MOVE STRING LENGTH INTO ONE-OP
MCMVTRM2 EQU   *
         SR    RX,R0               POP OPRND STACK                    S
         MVI   MCBSNDX2,$BSTEMP    IDENTIFY OPRND STACK TOP AS TEMP
         MVC   MCBOPRTR,MCBSOPST   MOVE OPRTR FROM STACK TO ONE-OP
         ST    RZ,MCBSLOC2         PUT TESULST LOCATION IN OPRND STACK
         BR    RE                  RETURN
         SPACE
*        THE FOLLOWING SECTIONS ARE EXIT ROUTINES                     S
*                                                                     S
MCMXDR1  EQU   *
         LA    RB,$ERVSYNT         SETT ERROR TYPE
MCMXDFLG EQU   *
         $CALL ERRTAG              FLAG STMNT
         L     RZ,AVMCRINS         MOVE BASE TO 1ST ONE-OP
         MVI   MCQS1FLG,$BSERR01   SHOW ERRIR BSU                     A
MCPREFIX EQU   *                   ENTER FOR PREFIX/ONLY(NEND,MEXIT,ETA
         LA    RZ,$LMCOPL1(,RZ)    SHOW @ END OF PREFIX               A
         ST    RZ,AVADDLOW         RESTORE  LOW STORAGE
         B     MCGNCDRT            AND RETURN
         SPACE
MCMXDR2  EQU   *
         LA    RB,$ERMXDMD         SET MIXED MODE ERROR
         B     MCMXDFLG            JUMP AND FLAG STMNT
         SPACE
MCSEQR1  EQU   *
         LA    RB,$ERINVSY         SET BAD SYMBOL FLAG
         XSNAP LABEL='BAD SYBOL FLAGGED',                              X
               IF=(AVTAGSM,O,AJOMACRH,TM)                             A
         B     MCMXDFLG            JUMP AND FLAG STMNT
         SPACE
MCGNCDOV EQU   *
         L     REP,AVMOVRFL
         BR    REP
         SPACE
**--> INSUB: MCGNALLO       ALLOCATE LOW CORE  + + + + + + + + + + + +S
*+                                                                   +S
*+       ALLOCATES SPACE FOR OPERAND ENTRIES                         +S
*+                                                                   +S
*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +S
         SPACE 2                                                      S
MCGNALLO EQU   *                                                      S
         LA    RB,$LMCQUAD         LOAD LENGTH OF AREA NEEDED         S
         $ALLOCL RZ,RB,MCGNCDOV    GET AREA FOR ONE OP                S
         MVC   0($LMCQUAD,RZ),AWZEROS  ZERO ENTRY                     S
         BR    RET                 RETURN                             S
         SPACE 2                                                      S
MCGNCDRT EQU   *
         XSNAP LABEL='MCGENCD EXITED',                                 X
               IF=(AVTAGSM,O,AJOMACRH,TM)                             A
         AIF   (&$DEBUG).MCGNCDR
         L     R1,AVMCRINS         GET @ OF ONE-OPS
         XSNAP LABEL='***ONE-OP''S***',STORAGE=(*0(R1),*200(R1),*AVMWRK1
               1,*AVMWRK1+64,*AVMWRK2,*AVMWRK2+64),IF=(AVMSNBY2,O,$MSNPX
               10,TM)
         XSNAP LABEL='***MCGNCD EXITED ***',IF=(AVMSNBY2,O,$MSNP10,TM)
.MCGNCDR ANOP
         $RETURN  RGS=(R14-R6)
         LTORG
         DROP  RAT,RW,RX,RY,RZ
         TITLE 'MEXPND - MACRO EXPANSION'
**-->  CSECT: MEXPND  EXPANDS MACRO DEFINITION. RECURSIVE. ACQUIRES   *
*.        STORAGE FROM LOW DYNAMIC AREA FOR STANDARD SAVE AREA AND    *
*.        LOCAL VARIABLES.  RELEASES STORAGE ON EXIT.  PUTS GENERATED *
*.        STATEMENTS IN HIGH STORAGE.  AVGEN1CD POINTS TO FIRST BYTE  *
*.        AFTER FIRST STATEMENT.  AVGEN1CD POINTS TO 1ST BYTE OF LAST *
*.        STATEMENT GENERATED                                         *
*.                                                                    *
*.        USES MACROS:  $MALLOCL, $MALLOCH, $CALL, $SAVE, $RETURN,    *
*.                      $AL2                                          *
*.        USES DSECTS: MACLIB, MCGLBDCT, MCOPQUAD, MCPAROPR, MCPARSUB *
*.                     AVWXTABL, MXPNTSAV, MCPARENT, RSBLOCK          *
*.        CALLS ERRTAG, MCSCOP,MXMVSR,MACSCN,MACFND,MXMVSR,MXERRM,    *
*.              ERRTAG,MEXPND,DECTRM                                  *
*.                                                                    *
*.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE
MEXPND   CSECT
         $SAVE RGS=(R14-R6),BR=13,SA=*                                A
         USING AVWXTABL,RAT        NOTE MAIN TABLE USING
         MVC   MXADDLOW(4),AVADDLOW SAVE ADDR OF LOW STORAGE          A
         MVC   AVMACNST,AWZEROS    NEST LEVEL = 0                     A
         MVI   AVMBYTE5,0          CLEAR CONT CARD INDICATOR
         L     RC,AVRSBPT          SET BASE FOR SOURCE BLOCK
         USING RSBLOCK,RC          SET USING FOR SOURCE
         CLI   RSBNUM,3            WERE THERE ACTUALLY 3 CARDS IN STMTJ
         BL    MEXPND0A            NO, SKIP CONTINUED-FURTHER TEST    J
         L     RB,AVRSCPT          POINT TO CONT BLOCK
         USING RSCBLK,RB           ESTAB USING ON CONT BLOCK
         CLI   RSCONSQ+2*RSC$LEN,C' '   MORE THAN TWO CARDS?
         BE    MEXPND0A            PROCEED IF NOT
         NI    RSBFLAG,255-$REBX   TURN OFF ERROR FLAG
         MVI   AVMBYTE5,$ERCONTX   ELSE SET CONT CARD INDICATR
         DROP  RB,RC
MEXPND0A EQU   *
         OI    AVRSBLOC+1,$RSBNP##  TURN ON OUTER FLAG
         L     RB,AVADDHIH         GET HIGH PNTR
         LR    RC,RB               COPY INTO RC
         STM   RB,RC,AVGEN1CD      MOVE INTO AVGEN1CD,AVGEN2CD
         ST    RB,MEXGN2OV         SAVE ORIG VALUE, IN CASE OVERFLW JRM
         LA    RB,L'MXPOVRMS+RSB$L   GET LENGTH OF MSSGE
         $MALLOCH  R1,RB           GET STORAGE FOR ERROR MSSGE
         ST    R1,MEXGN2OV         SAVE @, IN CASE OVERFLOW NPW     JRM
         MVC   0(L'MXPOVRMS+RSB$L,R1),MXPOVRMS   MOVE ERROR MSSGE
         LA    RE,RSB$L            GET LENGTH OF SNDRD PART OF RSBLOCK
         IC    RB,AVRSBLOC         GET LENGTH-1 OF RSBLOCK
         SR    RB,RE               DECR BY RSB$L
         STC   RB,AVRSBLOC         RESTORE
         MVC   AVGEN1CD,AVGEN2CD   DECR HIGH PNTR AWAY FROM MSSGE
         EJECT                                                        S
MEXPND01 EQU   *
* EVERY NEST LEVEL                                                    A
         L     RC,AVMACNST                                            A
         LA    RC,1(,RC)           INCREASE BY ONE                    A
         C     RC,AVMMNEST         TEST FOR OVER                      A
         BH    MEXPMNES            OVER THE LIMIT                     A
* FALLS THROUGH IF OK                                                 A
         ST    RC,AVMACNST         STORE NEW LEVEL                    S
         LR    R1,RZ               SAVE PREVIOUS @ MXPNTSAV           S
         $MALLOCL RZ,RB,LENG=$LMXPTSV  GET SPACE FOR NEXT ONE         S
         USING MXPNTSAV,RZ                                            A
         ST    R1,MXPNLINK         STORE PREVIOUS RZ                  S
         L     RA,AVRSBPT          LOAD SCAN POINTER                  S
         LA    RA,RSB$L(RA)        GET @ OF SOURCE IMAGE              S
         SPACE
*  NEXT SECTION CHECKS NAME FOR VALIDITY
         SPACE
         $CALL MACSCN              SCAN SOURCE FOR FIELDS
         L     RA,AVMFLD2          GET OPCODE @
         CLI   AVMFLDT2,X'00'      UNIDENTIFIED OPCODE?
         BE    MEXPND03            ERROR IF YES
         MVC   AVMSYMBL,AWBLANK    ELSE CLEAR GLOBAL NAME AREA
         MVC   AVMSYMLN,AVMFLDL2   MOVE LENGTH OF OPCODE
         SR    R1,R1               CLEAR R1 FOR EX
         IC    R1,AVMFLDL2         GET OPCODE LEN
         BCTR  R1,0                DECR FOR EX INST
         EX    R1,MXPNMVC          MOVE OPCODE NAME TO GLOBAL DICT    S
         L     RC,AVMACLIB         GET MACLIB @
         $CALL MACFND              SEARCH MACLIB
         LTR   RB,RB               FOUND?
         BZ    MEXPND04            IF YES, PROCEED
MEXPND03 EQU   *
         LA    RB,$ERIVOPC         ELSE SET BAD OPCODE FLAG
         B     MXPNDERT            AND RETURN
MEXPND04 EQU   *
         USING MACLIB,RW           NOTE USING ON MACLIB
         LR    RW,RC               SET MACLIB BASE
         TM    MCLBTAGS,AVMCLBDF   PREVIOUSLY DEFINED MACRO?
         BNO   MEXPND03            ERROR IF NOT
         ST    RW,MXPNMCLB         SAVE MACLIB PNTR IN LOCAL AREA
         LH    RA,MCPOPRNB          GET NBR OF OPRNDS
         LA    RA,1(RA)            BUMP FOR LABEL FIELD
         LA    RC,$LMPAROP         GET LEN OF SYM PAR DICT ENTRY
         MR    RB,RA               GET LEN REQ'D
         $MALLOCL  RY,RC           GET CORE FOR SYM PAR DICTIONARY
         ST    RY,MXPNLSPT         COPPY PNTR TO SYM PAR DICT
         SPACE
*  NEXT SECTION ZEROS SYM PAR DICTIONARY AND INITIALIZES ENTRIESTO TYPE
*  'O'.  ALSO FINDS FIRST KEYWORD D.V. IF ANY.
         SPACE
         USING MCPARENT,RX         SET USING FOR SYM PAR D.V.
         USING MCPAROPR,RY         SET USING FOR SYM PAR DICT ENTRIES
         L     RX,MCPARPNT         SET BASE FOR D.V.'S
         MVC   MXPNKYPT(8),AWZEROS  CLEAR KEYWORD PNTRS
         NI    AVMBYTE1,255-$MKEYOPR SHOW NO KEYWORDS YET             S
MEXPND05 EQU   *
         CLI   MCPARTYP,C'S'       SYSTEM VAR?
         BNE   MEXPND06            IF NOT, PROCEED
         L     RX,MCPARNXT         ELSE POINT TO NEXT ENTRY
         B     MEXPND05            AND TRY AGIAN
MEXPND06 EQU   *
         ST    RX,MXPLSYPT         SET PNTR TO SYM PAR D.V.'S
MEXPND07 EQU   *
         MVC   MCPAROPR($LMPAROP),AWZEROS  CLEAR NEXT ENTRY
         MVI   MCPAROTP,C'O'       SET TYPE TO NULL
         CLI   MCPARTYP,C'K'       KEYWORD?
         BNE   MEXPND08            JUMP TO FOOT IF NOT
         TM    AVMBYTE1,$MKEYOPR   1ST KEYWRD DV FOUND?
         BO    MEXPND08            JUMP TO FOOT IF YES
         ST    RY,MXPNKLPT         SAVE @ OF 1ST KEYWRD DICT ENTRY
         ST    RX,MXPNKYPT         SAVE @ OF 1ST KEYWRD D.V.
         OI    AVMBYTE1,$MKEYOPR   TURN ON KEYWRD FOUND FLAG
MEXPND08 EQU   *
         L     RX,MCPARNXT         GET NEXT ENTRY PNTR
         LTR   RX,RX               LAST ENTRY IN D.V.'S
         BZ    MXPLAB01            PROCESS LABEL IF YES
         LA    RY,$LMPAROP(RY)     ELSE BUMP DICT POINTER
         B     MEXPND07            AND INITIALIZE NEXT ENTRY
         SPACE 2
*   NEXT SECTION PROCESS LABEL FIELD OF MACRO CALL
MXPLAB01 EQU   *
         NI    AVMBYTE1,X'FF'-$MKEYOPR  TURN OFF KEYWORD FLAG
         L     RX,MXPLSYPT         SET BASE TO 1ST SYM PAR DV
         L     RY,MXPNLSPT         POINT TO SYM PAR DICTIONARY
         L     RA,AVMFLD1          GET @ OF LABEL
         CLI   AVMFLDL1,X'00'      LABEL PRESENT?
         BE    MXPOPR01            IF NOT, PROCESS OPRND FIELD
         CLI   MCPARNLN,X'00'      LABEL OPRND DEFINED?
         BNE   MXPLAB03            PROCESS IF YES
         LA    RB,$ERILLAB         ELSE SET ILLEGAL LABEL FLAG
         $CALL ERRTAG              FLAG STMNT
         B     MXPOPR01            PROCESS OPRND
MXPLAB03 EQU   *
         SR    R2,R2               CLEAR R2
         IC    R2,AVMFLDL1         GET LABEL LENGTH
         LA    R2,3(,R2)           BUMP FOR ROUND/4                 JRM
         SRL   R2,2                DIVIDE BY 4                      JRM
         SLL   R2,2                MULT BY 4, ROUNDED UP            JRM
         $MALLOCL   RB,R2          GET STORAGE
         IC    R2,AVMFLDL1         GET LENGTH
         STC   R2,MCPAROLN         SAVE LEN IN DICT ENTRY
         BCTR  R2,0                DECR FOR EX INST
         EX    R2,MXPNMVOP         MOVE LABEL TO STORAGE
         MVI   MCPAROFL,X'FF'      SET DEFINED FLAG
         MVI   MCPAROTP,C'U'       SET TYPR TO UNDEFINED
         ST    RB,MCPAROPT         STORE OPRND LOC IN DICTIONARY
         SPACE 2
*   START PROCESSING OPRND FIELD.  IS THERE AN OPRND?
MXPOPR01 EQU   *
         MVC   MXPNBOPS,AWZEROS    INIT OPRND COUNT TO ZERO
         CLC   MCPARNXT,AWZEROS    SYM PAR DV'S?
         BE    MXPNOPFN            IF NOT, MOVE STMT TOHIG CORE
         L     RA,AVMFLD3          GET OPRND @
         LTR   RA,RA               OPRND PRESENT?
         BNZ   MXPOPR03            PROCESS IF YES
         IC    RA,AVMFLDL2         ELSE GET LEN OF OPCODE
         A     RA,AVMFLD2          ADD OPCODE @ TO SCAN POINTER
         DROP  RW                  DROP MACLIB USING
MXPOPR03 EQU   *
         ST    RA,AVMTSCNP         SAVE PNTR TEMP
         TM    AVMBYTE1,$MKEYOPR   KEYWORD PROCESSED?
         BO    MXPOPK01            JUMP IF YES
         LA    RY,$LMPAROP(RY)     ELSE BYMP DICT PNTR
         L     RX,MCPARNXT         AND GET NEXT DV ENTRY
         LTR   RX,RX               FINAL ENTRY?
         BNZ   MXPOPR04            PROCESS IF NOT
         CLI   0(RA),C' '          OPRND PRESENT?
         BE    MXPNOPFN            FINISHED IF NOT
         LA    RB,$ERILOPR         ELSE SET NO OPRND ALLWD FLAG
         $CALL ERRTAG              FLAG STMT
         B     MXPNOPFN            AND JUMP TO FOOT
MXPNMVOP MVC   0($,RB),0(RA)       DUMMY TO MOVE OPRND TO STORAGE
MXPOPR04 EQU   *
         CLI   MCPARTYP,C'K'       SYM PAR DV = KEYWORD?
         BE    MXPOPK00            PROCESS KEYWORD                    S
MXPOPR05 EQU   *
         CLI   0(RA),C' '          OPRND PRESENT?
         BE    MXPOPR07            CLEAN UP KEY WORDS IF NOT
         CLI   0(RA),C','          COMMA INIDICATES NULL
         BE    MXPOPR0C            BUMP OPRND COUNT IF YES
         BAL   RET,MXPNOSY7        ORDINARY SYMBOL ?                  S
         LTR   RB,RB               RB TELLS ALL
         BNZ   MXPOPR06            JUMP AND SCAN OPRND IF NOT
         CLI   0(RC),C'='          KEYWORD ?
         BNE   MXPOPR06            PROCESS IF NOT
         OI    AVMBYTE1,$MKEYOPR   SET KEYWORD FLAG
         B     MXPOPK02            PROCESS KEYWRD OPRND
MXPOPR06 EQU   *
         BAL   RET,MXPOPSCN        SCAN OPRND, SAVE IN DICT
MXPOPR0C EQU   *
         L     R1,MXPNBOPS         GET OPRND COUNT
         LA    R1,1(R1)            BUMP BY 1
         ST    R1,MXPNBOPS         RESTORE
         B     MXPOPRFT            JUMP TO FOOT
MXPOPR07 EQU   *
         BCTR  RA,0                DECR SCN PNTR TO CHECK FOR ','
         CLI   0(RA),C','          COMMA PRESENT
         LA    RA,1(RA)            RESTORE SCAN POINTER
         BNE   MXPOPKFN            IF NOT, JUMP AND CLEAN UP
         L     R1,MXPNBOPS         ELSE GET N' COUNT
         LA    R1,1(R1)            BUMP
         ST    R1,MXPNBOPS         RESTORE
         B     MXPOPKFN            AND JUMP TO CLEAN UP
         SPACE 2
MXPOPK00 OI    AVMBYTE1,$MKEYOPR   SET KEYWORD FLAG                   S
MXPOPK01 EQU   *                   PROCESS KEYWORD OPRNDS
         CLI   0(RA),C' '          BLANK?
         BE    MXPOPKFN            IF YES, FINISH KEYWORD PROTOTYEP
         BAL   RET,MXPNOSY7        ORDINARY SYMBOL ?                  S
         LTR   RB,RB               RB TELLS ALL
         BNZ   MXPOPKFR            ERROR IF NONZERO, JUMP OUT
         CLI   0(RC),C'='          KEYWORD ID?
         BNE   MXPOPKFQ            FLAG ERROR IF NOT '='
MXPOPK02 EQU   *
         LA    RC,1(RC)            BUMP PAST '='
         ST    RC,AVMTSCNP         SAVE ADDRESS OF DELIM
         MVC   AVMSYMBL,AWBLANK    CLEAR GLOBAL AREA
         STC   R1,AVMSYMLN         SAVE LENGHT
         BCTR  R1,0                DECR FOR EX INST
         MVI   AVMSYMBL,C'&&'      SET AMPERSAND IN GLOBAL FILED
         EX    R1,MXPNMVC2                                            A
         L     RC,MXPNKYPT         GET @ OF FIRST KEYWORD DV
         $CALL MACFND              SEARCH SYM PAR LIST
         LTR   RB,RB               SYMBOL FOUND?
         BNZ   MXPOPKFQ            FLAG ERROR IF NOT FOUND
         LR    RX,RC               MOVE BASE TO NEW ENTRY
MXPOPK03 EQU   *
         LA    RY,$LMPAROP         GET LENGTH OF ENTRY
         MH    RY,MCPARNDX         MULT BY POSIT OF OPRND IN LIST
         A     RY,MXPNLSPT         ADD BASE @ OF SYM PAR DICT
         L     RA,AVMTSCNP         GET @ OF KEYWORD VALUE
         CLI   MCPAROFL,X'FF'      PREVIOUSLY DEFINED?
         BE    MXPOPK06            SET ERROR FLAG IF SO
         CLI   0(RA),C' '          OPRND PRESENT?
         BE    MXPOPK05            IF NOT, NULL OPRND
         CLI   0(RA),C','          COMMA?
         BE    MXPOPK05            ALSO NULL IF YES
         B     MXPOPK04            ELSE PROCEED
MXPOPK06 EQU   *
         IC    R1,AVMSYMLN         GET LEN OF KEYWORD NAME
         LA    R1,1(R1)            BUMP FOR '='
         SR    RA,R1               RESTORE SCAN POINTER
         B     MXPOPKFQ            JUMP AND FLAG ERROR
MXPOPK04 EQU   *
         BAL   RET,MXPOPSCN        SCAN OPRND AND SAVE IN TEMP STORGE
         B     MXPOPRFT            JUMP TO FOOT
MXPOPK05 EQU   *
         MVI   MCPAROFL,X'FF'      NULL OPRND, SET DEFINED FLAG
         B     MXPOPRFT            JUMP TO FOOT
         SPACE
*   NEXT ROUTINE CLEANS UP DEFAULTS FOR KEYWORD OPRNDS
MXPOPKFQ EQU   *
         LA    RB,$ERUNDKW         SET BAD KEYWORD FLAG
MXPOPKFR EQU   *
         $CALL ERRTAG              FLAG STMT
MXPOPKFN EQU   *
         L     RX,MXPNKYPT         POINT AT 1ST SYM PARDV KEYWORD
         LTR   RX,RX               PRESENT?
         BZ    MXPNOPFN            FINISHED IF ZERO
         L     RY,MXPNKLPT         POINT TO 1ST KEYWORD DICT ENTRY
MXPOPKF1 EQU   *
         CLI   MCPAROFL,X'FF'      DEFINED?
         BE    MXPOPKFB            JUMP TO FOOT IF YES
         BAL   RET,MXPOPKPR        ELSE LOOK AT PROTOTYPE
MXPOPKFB EQU   *
         L     RX,MCPARNXT         GET NEXT KEYWORD OPRND
         LTR   RX,RX               FINAL OPRND?
         BZ    MXPNOPFN            FINI IF YES
         LA    RY,$LMPAROP(RY)     BUMP DICTIONARY POINTER
         B     MXPOPKF1            AND RESUME SCAN
         EJECT                                                        S
**--> INSUB: MXPOPKPR  + + + + + + + + + + + + + + + + + + + + + + + +S
*+                                                                   +S
*+       SCAN PROTOTYPE OPRND AND SAVE IN LOCAL DICTIONARY           +S
*+                                                                   +S
*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +S
         SPACE 2                                                      S
MXPOPKPR EQU   *
         ST    RET,MXPKPRSV        SAVE RETURN @
         MVC   MCPAROTP,MCPRATYP   COPY TYPE ATTRIB INTO DICTIONARY   J
         CLI   MCPRATYP,C'O'       NULL OPRND?
         BE    MXPPRKFT            FINI IF YES
         L     RA,MCPROPRN         GET POINTER TO PROTOTYP OPRND
         MVI   MCPARONB,1          ASSUME N' = 1 TEMPORARILY          J
         MVC   MCPAROLN,MCPROPLN   COPY LENGTH
         MVC   MCPAROPT,MCPROPRN   COPY POINTER
         MVI   MCPAROFL,X'FF'      SET DEFINED FLAG
         CLI   MCPAROTP,C'S'       SUB LIST?
         BNE   MXPPRKFT            FIISHED IF NOT
         MVI   MCPARONB,0          ZERO, SO WILL ACCUMULATE N' OK     J
         BAL   RET,MXPNSBSC        SCAN OPRND SUB LIST
MXPPRKFT EQU   *
         L     RET,MXPKPRSV        RESTORE RETURN @
         BR    RET                 AND RETURN
MXPKPRSV DS    F                   STORAGE FOR RETURN @
         EJECT                                                        S
**--> INSUB: MXPOPSCN  + + + + + + + + + + + + + + + + + + + + + + + +S
*+                                                                   +S
*+       SCAN STD OPRND AND STORE IN LOW STORAGE                     +S
*+                                                                   +S
*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +S
         SPACE 2                                                      S
MXPOPSCN EQU   *
         ST    RET,MXPPSCSV        SAVE RETURN @
         ST    RA,AVMTSCNP         SAVE SCAN POINTER
         NI    AVMBYTE1,X'FF'-$MSBLIST  TURN OFF SUBLIST FLAG
         $CALL MCSCOP              SCAN OPRND
         LTR   RB,RB               OKAY?
         BNZ   MXPOPKFR            AND LEAVE OPRNDS
         STC   RC,MCPAROLN         PUT OPRND LEN IN DICT
         STC   RD,MCPAROTP         STORE TYPE
         MVI   MCPAROFL,X'FF'      SET OPRND FLAG
         LA    RC,3+1(,RC)         ROUND + 1 BYTE FOR DELIMITER AFTER J
         SRL   RC,2                TRUNCATE
         SLL   RC,2                BY SHIFITING
         $MALLOCL  RB,RC           GET STORAGE
         IC    RC,MCPAROLN         GET ORIGINAL LENGTH
*              USE LENGTH RATHER THAN L-1: COPY DELIMITER AFTER ARG,  J
*              HELPS MEXPND SCAN RIGHT FOR &I SETA &ARG OPERATION.    J
         LR    R0,RA               COPY SCAN POINTER
         L     RA,AVMTSCNP         GET ORIGINAL POINTER
         ST    R0,AVMTSCNP         SAVE SCAN POINTER
         EX    RC,MXPNMVOP         MOVE OPRND TO LOW STORAGE
         ST    RB,MCPAROPT         SAVE OPRND @ IN DICTIONARY
         CLI   MCPAROTP,C'S'       SUB LIST?
         BE    MXPOPSBS            PROCESS SUBLIST IF YES
         MVI   MCPARONB,1          ELSE SET OPRND COUNT TO 1
         B     MXPOPSCF
MXPOPSBS EQU   *
         LR    RA,RB               SCAN PNTR TO OPRND
         BAL   RET,MXPNSBSC        SCAN SUB OPRNDS
MXPOPSCF EQU   *
         L     RA,AVMTSCNP         RESTORE SCAN POINTER
         L     RET,MXPPSCSV        RESTORE RETURN @
         BR    RET                 AND RETURN
MXPPSCSV DS    F                   STORAGE FOR RETURN @
         EJECT                                                        S
**--> INSUB: MXPNSBSC  + + + + + + + + + + + + + + + + + + + + + + + +S
*+                                                                   +S
*+     SCAN OPRND SUBLIST, CREATE ENTRY IN DICTIONARY                +S
*+                                                                   +S
*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +S
         SPACE 2                                                      S
MXPNSBSC EQU   *
         ST    RET,MXPNSBSV        SAVE RETURN @
         USING MCPARSUB,RW         NOTE USING ON SUBOPRND ENTRY
         LA    RA,1(RA)            BUMP PAAST '('
         OI    AVMBYTE1,$MSBLIST   SET SUBLIST FLAG
MXPNSB01 EQU   *
         LA    RB,$LMPARSB         GET LENGTH OF SUB ENTRY
         $MALLOCL  RW,RB           GET STORAGE
         MVC   0($LMPARSB,RW),AWZEROS  CLEAR ENTRY
         ST    RA,MCPARSPT         SAVE POINTER TO SUB ENTRY STRNG
         $CALL MCSCOP              SCAN SUB OPRND
         LTR   RB,RB               ERROR?
         BZ    MXPNSB02            PROCEED IF NOT
         S     RA,MCPAROPT         GET OFFSET OF POINTER
         LR    RE,RA               COPY TEMPORARILY
         IC    RA,MCPAROLN         GET LENGTHOF OPRND
         S     RA,AVMTSCNP         SUBTRACT CURRENT PNTR
         LPR   RA,RA               GET POS VALUE
         AR    RA,RE               ADD OFFSET OF ERROR
         B     MXPOPKFR            FORGET ABOUT REST OF OPRNDS
MXPNSB02 EQU   *
         CLI   MCPARONB,X'00'      1ST SUB OPRND?
         BNE   MXPNSB03
         STC   RD,MCPAROTP         MAIN OP TYPE = 1ST SUB TYPE
         ST    RW,MCPRSBPT         SAVE PNTR TO SUB ENTRIES
MXPNSB03 EQU   *
         STC   RC,MCPARSLN         SAVE LEN IN DV
         STC   RD,MCPARSTP         SAVE TYPE
         IC    RD,MCPARONB         GET SUB OPRND COUNT
         LA    RD,1(RD)            BUMP BY ONE
         STC   RD,MCPARONB         RESOTRE
         CLI   0(RA),C')'          END OF LIST?
         LA    RA,1(RA)            BUMP PAST DELIM
         BNE   MXPNSB01            RESUME SCAN IF NO ')'
         L     RET,MXPNSBSV        GET RETURN @
         BR    RET                 AND RETURN
MXPNSBSV DS    F                   SPACE FOR RETURN @
         DROP  RW
         EJECT                                                        S
**--> INSUB: MXPNOSYM       DETERMINS IF STRING IS ORDINARY  + + + + +S
*+           SYMBOL OF EITHER LENGTH 7 OR 8 (MAX)                    +S
*+           MXPNOSY7:  SETS RB = 7                                  +S
*+                                                                   +S
*+             ENTRY CONDITIONS:                                     +S
*+       RA = 1ST CHAR OF SYMBOL                                     +S
*+       RB = ALLOWABLE LENGTH (7 OR 8)                              +S
*+                                                                   +S
*+             EXIT CONDITIONS:                                      +S
*+       RA = SAME AS ENTRY                                          +S
*+       RB = ERROR INDICATION  (0 --> OK)                           +S
*+       RC = @ OF DELIM PAST SYMBOL                                 +S
*+       R1 = LENGTH OF SYMBOL                                       +S
*+                                                                   +S
*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +S
         SPACE 2                                                      S
MXPNOSY7 LA    RB,7                SET MAX LENGTH OF KEYWORD          S
MXPNOSYM EQU   *
         CLI   0(RA),C'0'          FIRST CHAR = DIGIT?
         BNL   MXPSYMR1            ERROR IF YES
         EX    RB,MXPNOSSC         SCAN SYMBOL
         BZ    MXPSYMR2            ZERO MEANS TOO LONG
         LR    RC,R1               ELSE MOVE DELIM TO RC
         SR    R1,RA               GET LENGTH IN R1
         BZ    MXPSYMR2            NO SYMBOL IF ZERO LENGTH
         SR    RB,RB               CLAR RB FOR RETURN
         BR    RET
MXPSYMR1 EQU   *
MXPSYMR2 EQU   *
         LA    RB,$ERINVSY         SET BAD SYMBOL FALG
         BR    RET                 AND RETURN
MXPNOSSC TRT   0($,RA),AWTSYMT     DUMMY FOR SCAN
         EJECT                                                        S
MXPOPRFT EQU   *
         CLI   0(RA),C' '          BLANK?
         BE    MXPOPR03            RESUME SCAN IF YES
         LA    RA,1(RA)            ELSE BUMP PAST DELIM
         CLI   0(RA),C' '          BLANK AFTER ','?
         BNE   MXPOPR03            RESUME SCAN IF NOT
         SPACE 1
         L     RC,AVRSBPT          SET BASE OF RSBLOCK
         USING RSBLOCK,RC          NOTE USING ON RSBLOCK
*              POSSIBLE NON-STND CONT CARD
         CLI   RSBNUM,1            ONLY 1 CARD?
         BE    MXPOPR03            RESUME SCAN IF YES
         LA    RB,RSBLOCK+RSB$L+RSOL1  POINT TO 1ST BYTE, 2ND CARD
         CR    RA,RB               POINTING AT WHICH CARD?
         BNH   MXPOPC#2            PROCESS 2ND CARD IF LOW
         CLI   RSBNUM,3            TWO CONT CARDS?
         BNE   MXPOPR03            RESUME SCAN IF NOT
         LA    RB,RSOLC(RB)        POINT TO 1ST BYTE, 3RD CARD
         CR    RA,RB               WHERE IS SCAN POINTER?
         BH    MXPOPC#3            CHECK FOR 4TH CARD
MXPOPC#2 EQU   *
         LR    RA,RB               MOVE SCAN POINTER TO CONT CARD
         CLI   0(RA),C' '          CONT CARD IS NON BLANK?
         BNE   MXPOPR03            PROCEED IF YES
         LA    RB,$ERVILCH         SET BAD CONT CARD ERROR FLAG
         B     MXPOPKFR            AND JUMP TO FOOT
         SPACE 2
MXPOPC#3 EQU   *
         CLI   AVMBYTE5,$ERCONTX  MORE THAN TREE CARDS?
         BNE   MXPOPR03            PROCEED WITH SCAN IF NOT
         $CALL MXMVSR              ELSE MOVE CARDS TO HIGH CORE
         LTR   RB,RB               CORE EXCEEDED?
         BNZ   MXPNDOVR            JUMP OUT IF YES
         BAL   RET,MXPNRDR         ELSE READ CONT CARDS
         L     RC,AVRSBPT          ESTAB BASE ON RSBLOCK
         LA    RA,RSBSOURC         POINT TO STMT START
         CLC   0(15,RA),AWBLANK    COLS 1-15 BLANK?
         BE    MXPOPC#4            OKAY IF YES
         LA    RB,$ERCONT          ELSE SET ERROR FLAG
         $CALL ERRTAG              AND FLAG STMT
MXPOPC#4 EQU   *
         LA    RA,15(RA)           POINT TO COL 16
         B     MXPOPR03            AND RESUME SCAN
         EJECT                                                        S
**--> INSUB: MXPNRDR   + + + + + + + + + + + + + + + + + + + + + + + +S
*+                                                                   +S
*+             CARD READER FOR ROUTINE MEXPND                        +S
*+                                                                   +S
*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +S
         SPACE 2                                                      S
MXPNRDR  EQU   *                                                      S
         ST    RET,MXPNRDSV        SAVE RETURN @
         MVC   MXPGENCD,AVGEN1CD   COPY AVGEN1CD
         MVC   AVGEN1CD,AVGEN2CD   MAKE PNTRS EQUAL FOR INCARD
         $CALL INCARD              READ NEXT STMT
         OI    AVRSBLOC+1,$RSBNPNN SET NO PROCESS FLAG                S
         SR    RE,RE              CLEAR RE
         IC    RE,AVRSBLOC        GET LENG-1 OF STMT
         LA    RD,RSB$L           GET LENGTH OF STND PART
         SR    RE,RD              SUBTRACT FROM OVERALL LENGTH
         STC   RE,AVRSBLOC        RESTORE REDUCED LENGTH
         MVC   AVGEN1CD,MXPGENCD   RESTORE AVGEN1CD POINTER
         STC   RB,AVMBYTE5         SAVE ERROR FLAG
         CLI   AVMBYTE5,$ERCONTX   MORE THAN THREE CARDS?
         BE    MXPNRDRT            PROCEED IF YES
         LTR   RB,RB               ELSE TEST FOR ERROR
         BZ    MXPNRDRT            PROCEED IF NONE
         $CALL ERRTAG              ELSE FLAG STMT
         TM    AVTAGS2,$INEND2     END OF FILE ERROR?
         BO    MXPNDERT            JUMP OUT IF YES
MXPNRDRT EQU   *
         L     RET,MXPNRDSV        RESTORE RETURN @
         BR    RET                 AND RETURN
MXPNRDSV DS    F                   SPACE FOR RETURN @
MXPGENCD DS    F                   TEMP STORAGE FOR AVGEN1CD
         EJECT                                                        S
*        NORMAL EXIT CODE                                             S
         SPACE 1                                                      S
MXPNOPFN EQU   *
         $CALL MXMVSR              MOVE SOURCE TO HIGH AREA
         CLI   AVMBYTE5,$ERCONTX   4 CARDS?
         BNE   MXPNOPFP            PROCEED IF NOT
         BAL   RET,MXPNRDR         ELSE READ NEXT CARD
         L     RC,AVRSBPT          SET BASE FOR RSBSOURC
         OI    RSBFLAG,$RSBNPNN    SET NO ACTION FLAG
         B     MXPNOPFN            AND PTINT CARDS
         DROP  RC
MXPNOPFP EQU   *
         CLC   AVMACNST,AWF1       WAS THIS ACTUALLY OUTER MACRO CL JRM
         BNE   *+10                NO, SO SKIP RESET OF PTR         JRM
         MVC   MEXGN2OV,AVGEN2CD   THUS SAVE CURRENT PTR FOR OVRFL  JRM
         LTR   RB,RB               OVERFLOW?
         BZ    MXPNLOCD            PROCEED IF NOT
         SPACE 3                                                      S
*        OVERFLOW EXIT                                                S
         SPACE 1                                                      S
MXPNDOVR EQU   *
         MVC   AVGEN1CD,AVADDHIH   SET PNTR TO OVRFLW MESSAGE
         MVC   AVGEN2CD,MEXGN2OV   RESET OVERFLO PTR, SHOW @ EITHER OF #
               AS218 MESSAGE OR OF OUTER MACRO CALL.                JRM
         B     MXNORML                                                A
         SPACE 1                                                      A
         SPACE
MEXGN2OV DC    F'0'                @ LAST STMT, IF OVERFL**MOVE***  JRM
MXPOVRMS DC    C'218 STORAGE EXCEEDED BY FOLLOWING MACRO EXPANSION'
         DC    AL1(L'MXPOVRMS-1,$RSBNPNN+$RSBMERR,$,$)
         SPACE
         DS    0H                                                     A
MEXPMNES EQU   *                   ERROR EXIT MNEST LIMIT             A
         LA    RB,$EREXMAC                                            A
         L     RA,AVRSBPT                                             A
         LA    RA,RSB$L+10(RA)     POINT TO OPCODE                    A
MXPNDERT DS    0H
         $CALL ERRTAG
         $CALL MXMVSR              MOVE SOURCE TO HIGH AREA IF INNER
         LTR   RB,RB               OVERFLOW?
         BNZ   MXPNDOVR            JUMPP AND FLAG IF YES
*                                                                     S
*        NORMAL RETURN SEQUENCE FOR MEXPND                            S
*         -- ALSO SET PTR TO RELEASE LOW STORAGE AREA                 S
*                                                                     S
MXNORML  EQU   *                   NORMAL RETURN                      A
         MVC   AVADDLOW,MXADDLOW   RESTOR PTR                         A
         SR    RB,RB               SHOW NORMAL RETURN ALWAYS          J
         $RETURN RGS=(R14-R6)                                         A
         SPACE 4
*   NEXT SECTION ALLOCATES AND INITIALIZES STORAGE FORLOCAL SET SYMBOL*
*    DICTIONARY
MXPNLOCD EQU   *
         SPACE
         AIF   (&$DEBUG).MXPNLDB
         L     RA,MXPNLSPT         GET PNTR TO SYM PAR DICT
         L     R1,AVGEN2CD         GET PNTR TO HIGH AREA
         L     R2,AVADDHIH         GET PNTR TO BEGINNING OF HIGH AREA
         XSNAP LABEL='***SYM PAR DICT INITIALIZED***',                 X
               IF=(AVMSNBY2,O,$MSNP11,TM),                             X
               STORAGE=(*0(R1),*0(R2),*0(R13),*124(R13),*0(RA),*128(RA)X
               )
.MXPNLDB ANOP
         SPACE
         AP    AVMSYSDX,AWP1       BUMP SYSNDX COUNTER
         ZAP   MXPSYSDX,AVMSYSDX   COPY INTO LOCAL AREA
         L     RW,MXPNMCLB         GET POINTER TO MACLIB
         USING MACLIB,RW           SET USING
         MVC   MXPNCDPT,MCCODLNK  SAVE PNTR TO CODE
         L     R1,MCLOCDLN         GET LEN OF LOCAL DICTIONARY
         $MALLOCL  R2,R1           GET CORE FOR SET SYMBOL DICT
         ST    R2,MXPNLDBS         SAVE BASE IN LOCAL AREA
*  INITIALIZE DICTIONARY TO ZEROS
         LR    R0,R1               SAVE COMPLETE LENGTH FOR LATER     J
         BCTR  R1,0                DECR COUNT
         EX    R1,MXPNMVZR         CLEAR LENGTH MOD 256
         SRA   R1,8                SHIFT TO GET # 256 BYTE BLOCKS LEFT
         BNP   MXPNLOC2            SKIP IF NO MORE TO DO
         N     R0,AWFXFF      GET LAST BYTE OF LENGTH                 J
         AR    R2,R0               GET @ FIRST BYTE TO ZERO           J
         SPACE 1
         MVC   0(256,R2),AWZEROS   CLEAR 256 BYTES AT A TIME
         LA    R2,256(,R2)         INCREMENT TO NEXT
         BCT   R1,*-10             LOOP, CLEARING UNTIL DONE
         SPACE
MXPNLOC2 EQU   *
         L     R2,MXPNLDBS         GET BASE OF SET SYMB LOCAL DICT
         MVC   0(4,R2),AVMMACTR    SET ACTR LIMIT
         TM    AVMBYTE4,$MGENSTP   ARE MACROS KILLED ?                S
         BO    MXNORML             IF YES, RETURN                     S
         MVC   MXPNCRCD,MXPNCDPT   SET PTR TO 1ST INSTR               S
         SPACE 2                                                      S
*        THIS NEXT SECTION OF CODE SETS CALLING                       S
*        ARGUMENTS AND CALLS MXINST TO                                S
*        INTERPRET DICTIONARY ONE-OPS AND                             S
*        CREATE GENERATED CODE -----                                  S
*        THEN USE RETURNED CODE TO BRANCH ON INDEX                    S
*        FOR FURTHER PROCESSING                                       S
         SPACE 2                                                      S
MXPNCALL EQU   *                                                      S
         LR    RC,RZ               SET CALLING CONVENTION             S
         XCALL MXINST              CALL ROUTINE                       A
         B     *+4(RB)             BRANCH ON RETURNED INDEX           S
         B     MXPNDX0             RB=0 MEND,MEXIT                    A
         B     MEXPND01            RB=4 INNER MACRO CALL              A
         B     MXNORML             RB=8   KILL THIS NEST              S
         B     MXKILMAC            RB=12  KILL ALL MACROS             S
         B     MXPNDOVR            RB=16  STORAGE OVERFLOW            S
         SPACE 2                                                      S
*        SET FLAG TO KILL ALL MACROS                                  S
*                                                                     S
MXKILMAC EQU   *                   KILL ALL MACROS                    A
         OI    AVMBYTE4,$MGENSTP   LILL                               A
         B     MXNORML                                                A
*                                                                     S
*        BACK UP NEST DEPTH COUNTER AND CALL MXINST                   S
*        AGAIN IF NOT DONE WITH NEST                                  S
*                                                                     S
MXPNDX0  EQU   *                                                      S
         ST    RZ,AVADDLOW         STORE CURRENT RZ                   S
         L     R0,AVMACNST         GET NEST LEVEL                     S
         BCTR  R0,0                DECR BY 1                          S
         ST    R0,AVMACNST         STORE NEW DEPTH LEVEL              S
         LTR   R0,R0               LEVEL = 0 ?                        S
         L     RZ,MXPNLINK         GET NEXT LINK                      S
         BZ    MXNORML             NO MORE, RETURN                    S
         L     RE,MXPNCRCD         GET @ OF LAST INSTR PROC (CALL)    S
         USING MCOPQUAD,RE         NOTE ONE-OP PTR                    S
         MVC   MXPNCRCD,MCQUDNXT   GET @ OF NEXT INSTR (AFTER CALL)   S
         DROP  RE                  REMOVE USING                       S
         B     MXPNCALL            CALL MXINST TO GENERATE CODE       S
         SPACE 2                                                      S
*        DEFINED CONSTANTS/STORAGE & DUMMY INSTRS                     S
MXADDLOW DS    F                   FULL WORD TO SAVE AVADDLOW         S
MXPNMVZR MVC   0($,R2),AWZEROS     DUMMY INSTR                        S
MXPNMVC2 MVC   AVMSYMBL+1($),0(RA) DUMMY INSTR                        S
MXPNMVC  MVC   AVMSYMBL($),0(RA)   DUMMY INSTR                        S
         LTORG                                                        S
         DROP  RW,RX,RY,RZ                                            S
         TITLE 'MXINST -- INTERPRETATION PHASE'                       S
**--> CSECT: MXINST       EXECUTE INSTRUCTIONS IN MACRO DEF          *S
*.             ENTRY CONDITIONS:                                     *S
*.       RC = @ MXPNTSAV                                             *S
*.             EXIT CONDITIONS:                                      *S
*.       RB = 0                    MEND OR MEXIT FOUND               *S
*.            4                    INNER MACRO CALL                  *S
*.            8                    KILL THIS MACRO NEST              *S
*.           12                    KILL ALL MACROS                   *S
*.           16                    STORAGE OVERFLOW                  *S
*.                                                                   *S
*.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **S
         SPACE 2                                                      S
MXINST   CSECT                                                        A
         $SAVE RGS=(R14-R6),BR=13,SA=*                                A
         USING AVWXTABL,RAT        NOTE MAIN TABLE USING              S
         USING MCOPQUAD,RW         NOTE USING ON ONE-OP
         MVC   AVRSBLOC(RSB$L),AWZEROS   ZERO STND PART OF RSBLOC
         MVC   AVRSBLOC+4($LMSRCMX),AWBLANK   BLANK REMAINDER
         LR    RZ,RC                                                  A
         USING MXPNTSAV,RZ                                            A
         L     RW,MXPNCRCD                                            A
         XSNAP LABEL='MXINST INIT',STORAGE=(*MXPNTSAV,*MXPNLSPT+4,*AVADX
               DLOW,*AVWXEND),IF=(AVTAGSM,O,AJOMACRG,TM)              S
         $SPIE MXPNINJE,((8,9)),ACTION=CR,CE=MXPNZDIV  PRODUCTION TYPE
         ST    R1,AVMXSPIE         SAVE PREV INT BLOCK @
         B     MXPNIN01            SKIP, BEGIN AT 1ST ONE-OP
         SPACE
MXPNEXBS DS    0H                  ESTAB BASE FOR INDEX TABLE
MXPNINJE EQU   *                   ENTER HERE TO FLAG ERROR AND GO ON
*              TO NEXT ONE OP.  EXPECTS RB = ERROR CODE.
         BAL   R1,MXINERRM         GENERATE ERROR MESG                A
         SPACE 1
MXPNINJP EQU   *                   COME HERE FOR EACH NON-BRANCH STMT
*                                  AFTER VERY FIRST ONE.
         L     RW,MXPNCRCD         RESTORE BASE TO 1ST ONE-OP
         L     RW,MCQUDNXT         GET @ NEXT SEQUENTIAL INSTRUCTION
         SPACE 1
MXPNINJQ EQU   *                   COME HERE FOR AGO/GOOD AIF. RW= @
         AIF   (NOT &$MACOPC).MXINSTA  SKIP IF NOT OPEN CODE          S
*        ALLOW ONLY ONE STATEMENT DONE IF IN OPEN CODE                S
         L     RX,MXPNMCLB         LOAD @ OF MACLIB ENRTY             A
         USING MACLIB,RX           NOTE USING ON MACLIB               S
         TM    MCLBFLG2,$MCOCFL1   IN OPEN CODE ?                     S
         BO    MXMEND              RETURN IF YES                      S
         DROP  RX                                                     S
.MXINSTA ANOP                                                         S
         SPACE
         AIF   (&$DEBUG).MXPNNDB
         L     R1,MXPNCRCD         GET @ OF CURRENT INST
         L     R2,AVMCHSTR         GET POINTER TO CHAR WORK AREA
         XSNAP LABEL='***INSTRUCTION EXECUTED***',                     X
               IF=(AVMSNBY2,O,$MSNP11,TM),                             X
               STORAGE=(*0(R1),*128(R1),*0(R2),*128(R2))
.MXPNNDB ANOP
         SPACE
         L     R1,AVMMSTMG         GET GLOBAL LIMIT ON ISNTRUCTIONS
         S     R1,AWF1             DECR COUNT
         ST    R1,AVMMSTMG         RESTORE
         BNP   MXMENDER            GO TO FLAG ERROR AND STOP
         SPACE
MXPNIN01 EQU   *
         MVC   MXPCHRBF,AVMCHSTR   INIT BUFFER POINTER
         ST    RW,MXPNCRCD         UPDATE CURRENT INST POINTER
*        EACH STMT CONSISTS OF ONE-OP PREFIX(PTR,STMT#,STC),          A
*        FOLLOWED BY 0-MORE REGULAR ONE-OPS(MXOPQUAD DSECT)L          A
*        FOR ANOP,MEND,MEXIT,$BSERR01(ERROR), THE OPERATOR            A
*        CODE IS IN PREFIX (MCQS1FLG). FOR OTHERS, IT =0              A
         CLI   MCQS1FLG,0          WAS IT NORMAL PREFIX WITH ONE-OPS  A
         BE    MXPNIN03            YES SKIP SPECIAL CODE              A
         IC    R2,MCQS1FLG         GET OPERATOR TYPE                  A
         B     MXPNPREF            GO TO PREFIX ONLY CODE             A
MXPNIN03 SH    RW,=AL2($LMCQUAD-$LMCOPL1) BACK UP,SO WILL BUMP RIGHT  A
*        FALL THRU, START DOING ONE-OPS                               A
         EJECT
*   NEXT SECTION PROCESSES A SINGLE ONE-OP
MXPNONJP EQU   *
         LA    RW,$LMCQUAD(RW)     BUMP PAST CURRENT ONE-OP
         SR    RA,RA               CLEAR FOR INSERTS****************JRM
         MVI   AVMBYTE2,X'00'      CLEAR FLAG BYTE FOR TYPE USE       A
         IC    RA,MCARG1DX         GET INDEX OF 1ST ARG
         L     RB,MCARG1LC         GET LOC OF 1ST ARG
         IC    R2,MCBOPRTR         GET OPCODE
MXPNPREF EQU   *                   ENTER HERE FOR PREFIX ONLY ONES    A
         N     R2,=X'0000007E'     MASK OUT CHAR REL BIT, SPECIAL PRINA
         LH    R1,MXPNINDX(R2)     GET OFFSET
         XSNAP LABEL='MXPNONJP',STORAGE=(*0(RW),*16(RW)),              X
               IF=(AVTAGSM,O,AJOMACRH,TM)
         B     MXPNEXBS(R1)        JUMP TO ROUTINE
               SPACE
MXPNINDX $AL2  MXPNEXBS,(MXFIN,MXPLUS,MXMIN,MXMULT,MXDIV,MXOR,MXAND,MXN#
               OT,MXNE,MXGE,MXLE,MXLT,MXEQ,MXGT,MXCAT,MXAGO,MXAIF,MXSET#
               A,MXSETB,MXSETC,MXINV,MXINV,MXSBSCRP,MXSBST,MXSYSL,MXINV#
               ,MXPRNT,MXMEXIT,MXMEND,MXANOP,MXERRMS,MXINMAC,MXMVSTMT)
         SPACE
*   ENTRY POINT FOR SPIE ACTION
MXPNZDIV EQU   *
         USING MXPNZDIV,REP
         LA    RB,$ER#ZDIV         SET ERROR FLAG
         BR    RET                 RETURN NOW, RB SET
         AIF   (&$DEBUG).MACQQ04   SKIP IF NO DEBUG
         ORG   *-2                 GET BACK OVER NON-DEBUG CODE
         CLI   3(R1),8             FIXED POINT OVERFLOW?
         BCR   E,RET               RETURN IF YES FOR MORE SPIE ACTION
         CLI   3(R1),9             ZERO DIVIDE?
         BCR   E,RET               RETURN IF YES FOR MORE SPIE ACTION
         L     RA,AVGEN2CD         ELSE POINT TO LOW END OF HIGH CORE
         L     RB,AVADDHIH         POINT TO HIGH END OF HIGH CORE
         L     RC,AVMACLIB         POINT TO START OF LOW CORE
         L     RD,AVADDLOW         POINT TO HIGH END OF LOW CORE
         XSNAP LABEL='*** INTERRUPT IN MACRO EXPANSION ***',           X
               STORAGE=(*0(R1),*20(R1),*0(RA),*0(RB),*0(RC),*0(RD),*AVA#
               DDLOW,*AVWXEND,*0(R13),*130(R13))
         DC    X'00FF'             FORCE INTERRUPT
.MACQQ04 ANOP
         DROP  REP
         SPACE
*                                                                     A
MXPLUS   EQU   *
MXMIN    EQU   *
*        ARITHMETIC OPERATIONS HERE                                   A
MXMULT   EQU   *
MXDIV    EQU   *
         BAL   RET,MXARITH         CVRT 1ST ARG TO ARITH VLUE
         ST    RC,MXARG1           SAVE TEMPORRAILY
         IC    RA,MCARG2DX         GET 2ND ARG TYPE
         L     RB,MCARG2LC         GET LOCATION OF 2ND ARG
         BAL   RET,MXARITH         GET ARITH VALUE
         LR    RD,RC               COPY INTO RD
         L     RB,MXARG1           RELOAD 1ST ARGUMENT**************JRM
         SRDA  RB,32               MOVE OVER TO RC, WITH SIGN RIGHT
         IC    RA,MCBOPRTR         GET OPCODE
         EX    0,MXARITOP-2(RA)    EXECUTE CORRECT OPERATION
         ST    RC,MCRESULT         PUT RESULT IN ONE-OP
         MVI   MCRSLTYP,$BSIMMA    SET TYPE
         B     MXPNONJP            GET NEXT ONE-OP
         SPACE 1
MXARITOP DS    0H                  TABLE OF INSTRS TO BE EXECUTED
         AR    RC,RD               ADD
         SR    RC,RD               SUBTRACT
         MR    RB,RD               MULTIPLY
         DR    RB,RD               DIVIDE
         EJECT                                                        A
* LOGICAL OPERATORS                                                   A
*                                                                     A
MXOR     EQU   *
MXAND    EQU   *
         BAL   RET,MXBOOL          GET 1ST ARG VALUE
         ST    RC,MXARG1           SAVE TEMPORARILY
         IC    RA,MCARG2DX         GET 2ND ARG TYPE
         L     RB,MCARG2LC         GET 2ND ARG LOC'N
         BAL   RET,MXBOOL          GET 2ND ARG VALUE
         L     RD,MXARG1           RESTORE 1ST ARG VALUE
         CLI   MCBOPRTR,$BSOR      OR OPRND?
         BE    MXOR01              JUMP TO OR IF YES
         NR    RC,RD               ELSE CARRY OUT AND OPERATION
         B     MXOR02              JUMP TO FOOT
MXOR01   EQU   *
         OR    RC,RD               CARRY OUT OR OPERATION
MXOR02   EQU   *
         ST    RC,MCRESULT         STORE RESULT IN ONE-OP
         MVI   MCRSLTYP,$BSIMMB    SET TYPE
         B     MXPNONJP            GET NEXT ONE-OP
         SPACE
MXNOT    EQU   *
         BAL   RET,MXBOOL          CONVERT TO BOOL VALUE
         X     RC,AWF1             DO EXCLUSINVE OPERATION
         B     MXOR02              SAVE RESULT IN ONE-OP
         EJECT
MXNE     EQU   *
MXGE     EQU   *
MXLE     EQU   *
MXLT     EQU   *
MXEQ     EQU   *
MXGT     EQU   *
         LA    R1,$BSNE            GET $BSNE VALUE IN R1
         SRL   R2,1                DIVIDE OPCADE BU 2                 A
         IC    R2,MXRELOPS-($BSNE/2)(R2)                              A
         STC   R2,MXRELCH2+1       SAVE IT                            A
         MVI   MCRSLTYP,$BSIMMB    SET RESULT TYPE
         MVC   MCRESULT,AWZEROS    ASSUME FALSE FOR START
         TM    MCBOPRTR,$BSRLCHR   CHAR RELATION?
         BO    MXRELCHR            PROCESS CHAR REL IF YES
MXRELAR  EQU   *                   ELSE PROCESS ARITH RELATION
         BAL   RET,MXARITH         GET 1ST VALUE
         ST    RC,MXARG1           STORE TEMP
         IC    RA,MCARG2DX         GET ARG2 INDEX
         L     RB,MCARG2LC         GET ARG2 LOCATION
         BAL   RET,MXARITH         GET ARITH VALUE
         L     RB,MXARG1           GET 1ST ARG
         CR    RB,RC               COMPARE OPRNDS
         B     MXRELCH2            FALL THROUGH MEANS FALSE           A
MXRLATRU EQU   *                   TARGET FOR TRUE CONDITION
         MVI   MCRESULT+3,X'01'    SET RESULT TO TRUE
         B     MXPNONJP            GET NEXT ONE-OP
MXRELCHR EQU   *
         BAL   RET,MXCHAR          GET ARG1 CHAR VLAUE
         STM   RB,RC,MXARG1LN      SAVE LEN AND TYPE TEMP
         IC    RA,MCARG2DX         GET ARG2 TYPE
*                                                                     A
         L     RB,MCARG2LC         GET ARG2 LOC
         BAL   RET,MXCHAR          GET CHAR VALUE
         LR    RD,RB               MOVE 2ND ARG LEN TO RD
         LR    RE,RC               MOVE 2ND ARG LOC TO RE
         LM    RB,RC,MXARG1LN      RESTORE LEN AND TYPE
         CR    RB,RD               COMPARE LENGTHS
         BNE   MXRELCH2            UNEQUAL ==> COMPARE LENGHTS INSTD
         LTR   RB,RB               ZERO LENGTH?
         BZ    MXRELCH2            IF YES USE LEN COMPARE
MXRELCH1 EQU   *
         BCTR  RB,0                DECR LEN FOR EX INST
         EX    RB,MXCHCOMP         COMPARE STRINGS
MXRELCH2 BC    $,MXRLATRU                                             A
         B     MXPNONJP            FALL THRU MEANS FALSE
MXCHCOMP CLC   0($,RC),0(RE)       DUMMY FOR CHAR COMPARE
MXRELOPS DC    XL6'70B0D0408020'   MASKS FOR DIFFERENT RELATIONS
         EJECT
*                                                                     A
*        CONCATENATION PROCESSED                                      A
MXCAT    EQU   *
         MVI   MCRSLTYP,$BSTRING   SET TYPE TO CHAR
         BAL   RET,MXCHAR          GET CHAR VALUE OF ARG1
         STM   RB,RC,MXARG1LN      SAVE LEN & LOC TEMP
         IC    RA,MCARG2DX         GET ARG2 INDEX
         SPACE 1                                                      A
         L     RB,MCARG2LC         GET ARG2 LOC
         BAL   RET,MXCHAR          GET CHAR VALUE OF ARG2
         LM    RD,RE,MXARG1LN      GET ARGU VALUE
         LR    RA,RB               GET LEN OF ARG2
         AR    RA,RD               GET TOTAL LEN OF ARGS
         LA    R1,AVMWRK1          GET @ OF WORK AREA
         S     RD,AWF1             DECR LEN OF ARG1 FOR EX INST
         BM    MXCAT02             IF ZERO LEN, JUMP
         EX    RD,MXMVWRK1         MOVE ARGU TO WORKAREA
         LA    RD,1(RD)            RESTORE ARG1 LEN
         AR    R1,RD               BUMP WORKAREA POINTER
         C     RA,AWFXFF           COMPARE TO MAX LENGTH
         BNH   MXCAT02             IF NOT HIGH, OKAY
         LR    RB,RA               ELSE MOVE TOTAL TO RB
         LA    RA,255              GET MAXIMUM ALLOWED LENGTH
         SR    RB,RA               GET ALLOWABLE REMADR IN RB
MXCAT02  EQU   *
         S     RB,AWF1             DECR BY 1 FOR EX INST
         BM    MXCAT03             IF ZERO LEN ON ARG2, JUMP
         LR    RE,RC               MOE PNTR TO FOR EX
         EX    RB,MXMVWRK1         ADD ARG2 TO STRING
MXCAT03  EQU   *
         LA    RE,AVMWRK1          GET STRING @ IN RE
         S     RA,AWF1             DECR FOR EX INST
         BM    MXCAT04             IF ZERO JUMP
         L     R1,MXPCHRBF         GET CURRENT @ OF STRING BUFFER
         AR    R1,RA               GET FINAL @
         C     R1,AVMCHLIM         EXCEED BUFFER?
         BH    MXCAT05             IF HIGH, JUMP FOR ERROR
         SR    R1,RA              RESTORE POINTER
         EX    RA,MXMVWRK1         MOVE TO BUFFER
         ST    R1,MCRESULT         SAVE @ IN ONE-OP
MXCAT04  EQU   *
         LA    RA,1(,RA)           BUMP TO RESTORE CAT STRING LEN
         STC   RA,MCRESULT         SAVE LEN IN ONE-OP
         AR    R1,RA               GET FINAL DELIM @
         ST R1,MXPCHRBF            STORE @ IN TABLE
         B     MXPNONJP            GET NEXT ONE-OP
         SPACE
MXMVWRK1 MVC   0($,R1),0(RE)       MOVE ARG TO WORK AREA BUFFERER
         SPACE
MXCAT05  EQU   *
         LA    RB,$ER#EXBF         SET EXCEEDED BUFFER FLAG
         B     MXPNINJE            GO FLAG ERROR AND CONTINUE
         EJECT
*                                                                     A
*        AGO AMD AIF CODE PROCESSED                                   A
*                                                                     A
MXAIF    EQU   *
         BAL   RET,MXBOOL          GET BOOL VALUE
         LTR   RC,RC               TRUE OR FLSE?
         BZ    MXPNINJP            NO JUMP, CONTINUE SEQUENTAILLY
         AIF   (NOT &$MACOPC).MXINSTB  SKIP IF NOT OPEN CODE          S
         OI    AVMTAG00,AVMOPGO    SHOW AIF WAS SUCCESSFUL            S
.MXINSTB ANOP                                                         S
*              FALL THRU, PROCESS LIKE AGO.
         SPACE
MXAGO    EQU   *
         L     R1,MXPNLDBS         GET SET SYMB DICT BASE(LOCAL)
         L     R0,0(R1)            GET ACTR ALUE
         BCT   R0,MXAGO01          DECR COUNT
         LA    RB,$ER#ACTR         SET ACTR ERROR FLAG IF FALL THRU
         B     MXINKIL1            GENERAL ERROR MSG & SET FLAG       A
MXAGO01  EQU   *
         ST    R0,0(R1)            RESTORE DECREMENTED ACTR
         L     RW,MCARG2LC         GET @ OF BRANCH INTO RW, WHERE EXPCT
         B     MXPNINJQ            GO TO HAVE BRANCH DONE
         SPACE
MXSETA   EQU   *
MXSETB   EQU   *
MXSETC   EQU   *
         BAL   RET,MXADDR          GET @ OF TARGET
         ST    RC,MXARG1           SAVE TEMP
         IC    RA,MCARG2DX         GET ARG2 INDEX
         L     RB,MCARG2LC         GET 2ND RG LOC
         CLI   MCBOPRTR,$BSETB     ARITH, BOOL OR CHAR?
         BH    MXSETC01            CHAR IF HIGH
         BE    MXSETB01            BOOL IF EQUAL
         BAL   RET,MXARITH         ARITH IF FALL THRU
         B     MXSETB02            USE BOOL CODE TO STORE
         SPACE 1
MXSETB01 EQU   *
         BAL   RET,MXBOOL          GET BOOL VALUE
MXSETB02 EQU   *
         L     R1,MXARG1           GET TARGET @
         ST    RC,0(R1)            STORE RESULT
         B     MXPNINJP            GET NEXT INST
         SPACE 1
MXSETC01 EQU   *
         BAL   RET,MXCHAR          GET CHAR VALUE
         L     R1,MXARG1           GET TARGET @
*************** POSSIBLE CHANGE WITH ASM H OR VS *********************S
         C     RB,=F'8'            LEN > 8
         BNH   MXSETC02            PROCEED IF NOT
         LA    RB,8                ELSE SET LEN TO MAX
MXSETC02 EQU   *
         ST    RB,0(R1)            SAVE LENGTH
         S     RB,AWF1             DECR FOR EX
         BM    MXPNINJP            IF ZERO, GET NEXT INST
         EX    RB,MXPMVSET         MOVE STRING TO SET SYMBOL
         B     MXPNINJP            GET NEXT INST
         SPACE
MXPMVSET MVC   4($,R1),0(RC)       DUMMY TO MOVE STRING
         EJECT
*   NEXT SECTION HANDLES SUBSCRIPTED SET SYMBOLS AND SYMBOLIC PRAMS
         SPACE
MXSBSCRP EQU   *
         CLI   MCARG1DX,$BSYMPAR   SYMPAR, K' OR T'?
         BNL   MXSCRP01            JUMP AND PROCESS IF YES
         BAL   RET,MXADDR          ELSE GET @ OF SET SYMBOL
         LA    R1,$BSATT          GET $BSADDRA-2
         SRL   RE,1                DIVIDE $ARITH, ETC TO GET 2, 4 OR 6
         AR    R1,RE               GET $BSADDRA, B ORC
         STC   R1,MCRSLTYP         SAVE TYPE  IN ONE-OP
         ALR   RE,RE               RESTORE TYPE(4,8,12)
         STM   RC,RE,MXARG1LN      SAVE @, LEN AND TYPE TEMP
MXSCRP01 EQU   *
         IC    RA,MCARG2DX         GET ARG2 INDEX
         L     RB,MCARG2LC         GET ARG2 LOC
         BAL   RET,MXARITH         GET ARITH VALUE
         LTR   RC,RC               TEST VALUE OF INDEX
         BP    MXSCRP02            PROCEED IF > 0
MXSCRPDR EQU   *
         LA    RB,$ER#DMER         ELSE SET DIMENON ERROR FLAG
         B     MXPNINJE            GO FLAG ERROR AND CONTINUE
MXSCRP02 EQU   *
         CLI   MCARG1DX,$BSYMPAR   SYM PAR, K' OR T'?
         BNL   MXSBSCSP            JUMP IF YES
         C     RC,MXARG1           COMPARE WITH SET SYMB DIM
         BH    MXSCRPDR            ERROR IF HIGH
         BCTR  RC,0                DECR TO GET OFFSET
         CLI   MCRSLTYP,$BSADDRB   BOOL TYPE?
         BNE   MXSCRP03            SKIP IF NOT
         MVI   MXARG2+3,4          ELSE SET LEN TO 4
MXSCRP03 EQU   *
         MH    RC,MXARG2+2         MULT TO GET OFFSET
         A     RC,MXARG1LN         ADD BASE @
         ST    RC,MCRESULT         PUT RESULT IN ONE-OP
         B     MXPNONJP            GET NEXT ONE-OP
         SPACE
MXSBSCSP EQU   *                   PROCESS SYMBOLIC PARAMETER SUBSCRIPT
         MVI   MCRSLTYP,$BSTRING   SET TO CHAR FOR OPERNERS
         MVC   MCRESULT,AWZEROS    INIT REULST TO ZERO
         LA    R1,$LMPAROP         GET LEN OF SYM PAR DICT ENTRY
         MH    R1,MCARG1LC+2       MULST BY SYM PAR SUBSCRIPT
         A     R1,MXPNLSPT         ADD SYM PAR BASE @ OF DICT
         USING MCPAROPR,R1         SET USING FOR DICT ENTRY
         SR    RB,RB               CLEAR RB FOROPRND COUNT
         IC    RB,MCPARONB         GET NBR OF SUBOPRNDS
         CR    RB,RC               COMPARE WITH SUBSCRIPT
         BNL   MXSCSP03            PROCEED IF WITHIN RANGE
MXSCSP00 EQU   *
         CLI   MCARG1DX,$BSATK     K' ATRIB?
         BE    MXSCSP01            K' IF EQUAL
         BH    MXSCSP02            T' IF HIGH
         C     RC,AWF1             1ST SUBSCRIPT WANTED?
         BNE   MXPNONJP            FINI IF NOT
         MVC   MCRESULT+1(3),MCPAROPT+1      ELSE IS SYMPAR, COPY RESUL
         MVC   MCRESULT(1),MCPAROLN
         B     MXPNONJP            SYM PAR IF FALL THRU, DEFAULT VALUE
MXSCSP01 EQU   *                   PROCESS K' OUT OF RANGE
         MVI   MCRSLTYP,$BSIMMA    SET TYPE TO ARITH
         C     RC,AWF1             1ST SUBSCRIPT WANTED?
         BNE   MXPNONJP            FINI IF NOT
         MVC   MCRESULT+3(1),MCPAROLN  MOVE K' OF MAIN OPRND TO RESULT
         B     MXPNONJP            AND GET NEXT ONE-OP
MXSCSP02 EQU   *                   PROCESS  T' OUT OF RANGE
         C     RC,AWF1             1ST SUBSCRIPT WANTED?
         BNE   MXSCSP21            USE NULL TYPE IF NOT
         LA    RA,MCPAROTP         ELSE POINT AT OPRND TYPE
         B     MXSCSP22
MXSCSP21 EQU   *
         LA    RA,=C'O'            POINT AT NULL TYPE
MXSCSP22 EQU   *
         ST    RA,MCRESULT         STORE IN ONE-OP
         MVI   MCRESULT,1          ST LENGTH TO 1
         B     MXPNONJP            GET NEXT ONE-OP
MXSCSP03 EQU   *                   PRROCESS SUBSCRIPTS IN RANG
         L     R2,MCPRSBPT         GET POINTER TO SUBLIST ENTRIES
         LTR   R2,R2               SUBLIST EXISTS?
         BZ    MXSCSP00            PROCESS AS OUT OF RANGE IF NOT
         BCTR  RC,0                DECR INDEX
         SLL   RC,3                MULT BY 8 TO GET OFFSET
         AR    R2,RC               POINT TO SUBENTRY
         USING MCPARSUB,R2         SET USING ON SUB ENTRY
         CLI   MCARG1DX,$BSATK     K' ATTRIB?
         BE    MXSCSP04            YES IF EQUAL
         BH    MXSCSP05            T' IF HIGH
         MVC   MCRESULT+1(3),MCPARSPT+1      ELSE IS SYMPAR, COPY POINT
         MVC   MCRESULT(1),MCPARSLN   GET LEN OF STRING
         B     MXPNONJP            AND GET NEXT ONE-OP
MXSCSP04 EQU   *                   PROCESS K' IN RANGE
         MVC   MCRESULT+3(1),MCPARSLN   MOVE K' TO RESULT
         MVI   MCRSLTYP,$BSIMMA    SET TYPE TO ARITH
         B     MXPNONJP            GET NEXT ONE-OP
MXSCSP05 EQU   *                   PROCESS T' IN RANGE
         LA    RB,MCPARSTP         GET @ OF TYPE
         ST    RB,MCRESULT         PLACE IN RESULT
         MVI   MCRESULT,1          SET LEN TO 1
         B     MXPNONJP            GET NEXT ONE-OP
         DROP  R1,R2               DROP USING ON MCPAROPR,MCPARSUB
         SPACE
         EJECT
*   NEXT SECTION PROCESSES SUBSTRING ACTION
         SPACE
MXSBST   EQU   *
         MVI   MCRSLTYP,$BSTRING   INIT TYPE TO STRING
         MVC   MCRESULT,AWZEROS    INIT LEN TO ZERO
         BAL   RET,MXARITH         GET 1ST ARG VALUE
         LTR   RC,RC               WAS 1ST EXP <= 0
         BNP   MXSBSTER            ERROR IF INDEX <=0
         ST    RC,MXARG1           SAVE VALUE TEMP
         IC    RA,MCARG2DX         GET ARG2 INDEX
         L     RB,MCARG2LC         GET ARG2 LOC
         BAL   RET,MXARITH         GET ARITH VALUE
         LTR   RC,RC               WAS VALUE <= 0
         BNP   MXSBSTER            ERROR IF SO
*        **NOTE** MAY CHANGE THIS FOR G-LEVEL COMPATIBLE CODE
         C     RC,=F'8'            LEN > 8?
         BH    MXSBSTER            ERROR IF YES
         ST    RC,MXARG2           SAVE ARG2 TEMP
         IC    RA,MCARG1DX+$LMCQUAD  GET TYPE OF OPRND
         L     RB,MCARG1LC+$LMCQUAD  GET LOC OF OPERAND
         BAL   RET,MXCHAR          CONVERT TO CHAR
         C     RB,MXARG1           LEN < STARTING CHAR?
         BNL   MXSBST01            OKAY IF NO LOW
         L     RC,MXARG1           ELSE PUT BAD VALUE IN RC
         B     MXSBSTER            AND JUMP TO FLAG ERROR
MXSBST01 EQU   *
         LM    RD,RE,MXARG1        GET START NBR AND LEN
         AR    RD,RC               GET NEW START @ + 1
         BCTR  RD,0                DECR @
         ST    RD,MCRESULT         SAVE START @ OF SUBSTING
         AR    RC,RB               GET PNTR TO END OF STRING + 1
         AR    RD,RE               GET PNTR TO SUBSTR END PLUS 1
         CR    RC,RD               SUBSTRING OKAY?
         BNL   MXSBST03            JUMP IF OKAY
         S     RC,MCRESULT         ELSE GET LEN OF RMNDR OF STRING
         STC   RC,MCRESULT         SAVE LEN OF SUBST
         B     MXSBSTFT            JUMP TO FOOT
MXSBST03 EQU   *
         S     RD,MCRESULT         GET LENGTH OF SUBSTR
         STC   RD,MCRESULT         SVE LEN OF SUBSTR IN ONE-OP
MXSBSTFT EQU   *
         LA    RW,$LMCQUAD(RW)     BUMP PNTR PAST DUMMY ONE-OP
         B     MXPNONJP            GET NEXT ONE-OP
         SPACE 1
MXSBSTER EQU   *
         LA    RB,$ER#SBST         SET SUBSTR ERROR FLAG
         B     MXPNINJE            GO FLAG ERROR AND CONTINUE
         EJECT
*    NEXT SECTION PROCESSES SYSLIST SUBSCRIPTED VARIABLE
         SPACE
MXSYSL   EQU   *
         MVI   MCRSLTYP,$BSTRING   INIT TO CHAR TYPE
         MVC   MCRESULT,AWZEROS    INIST RESULT TO ZERO
         CLI   MCBOPRTR+$LMCQUAD,X'00'    DOUBLE SUBSCRIPT?
         BNE   MXSYSL01            SINGLE ONE-OP IF NOT
         BAL   RET,MXARITH         ELSE GET VALUE OF 1ST SUBSCRIPT
         ST    RC,MXARG1           STORE TEMP
MXSYSL01 EQU   *
         IC    RA,MCARG2DX         GET 2ND ARG
         L     RB,MCARG2LC         GET LOC
         BAL   RET,MXARITH         CONVERT TO ARITH
         ST    RC,MXARG2           SAVE TEMP(1ST SUB OF SINGLE)
         CLI   MCBOPRTR+$LMCQUAD,X'00'   2 OPRNDS
         BNE   MXSYSL02            JUMP IF NOT
         L     RC,MXARG1           ELSE RESTORE 1ST ARG VALUE         A
MXSYSL02 EQU   *
         LTR   RC,RC               VALUE > 0
         BNL   MXSYSL03            IF >= 0, OKAY
MXSYSLR1 EQU   *
         LA    RB,$ER#SYSL         SET SYSLIST DIM ERROR
         B     MXPNINJE            GO FLAG ERROR AND CONTINUE
MXSYSL03 EQU   *
         C     RC,MXPNBOPS         COMPARE WITH NBR OF POSIT OPRNDS
         BH    MXSYSLHI            JUMP IF HIGH
*   PROCESS &SYSLIST(A), N', K', T' WITHIN RANGE
         LA    RB,$LMPAROP         GET LEN OF SY PAR DICT ENTRY
         MR    RB,RB               MULT BY SUBSCRIPT TO GET OFFSET
         A     RC,MXPNLSPT         ADD BASE @ OF SYM PAR DICT
         USING MCPAROPR,RC         SET USING FOR DICT ENTRY
         CLI   MCBOPRTR+$LMCQUAD,X'00'   DOUBLE SUBSCRIPT?
         BE    MXSYLDBL            PROCESS IF YES
         CLI   MCARG1DX,$BSYSLST   &SYSLIST?
         BNE   MXSYSL04            IF NOT MUST BE ATTRIB
         MVC   MCRESULT+1(3),MCPAROPT+1  MOVE OPRND PNTR TO ONE-OP
         MVC   MCRESULT(1),MCPAROLN   MOVE LENGTH OF OPNRD TO ONE-OP
         B     MXPNONJP            GET NEXT OPCODE
MXSYSL04 EQU   *
         SR    R1,R1
         CLI   MCARG1DX,$BSATN     WHICH ATTRIB?
         BH    MXSYSLTP            T' IF HIGH
         BE    MXSYSLNP            N' IF EQUAL
         MVC   MCRESULT+3(1),MCPAROLN   K' IF FALL THRU
         MVI   MCRSLTYP,$BSIMMA    SET TYPE TO ARITH
         B     MXPNONJP            GET NEXT ONE-OP
MXSYSLNP EQU   *
         MVI   MCRSLTYP,$BSIMMA    SET TYPE TO ARITH
         MVC   MCRESULT+3(1),MCPARONB   GET NBR OF SUB OPRNDS
         CLI   MCPARONB,X'00'      ZERO SUBOPRNDS?
         BNE   MXPNONJP            IF > 0, GET NEXT ONE-OP
         CLI   MCPAROTP,C'O'       NULL OPRND?
         BE    MXPNONJP            IF YES, GET NEXT ONE-OP
         MVI   MCRESULT+3,1        ELSE SET NBR TO 1
         B     MXPNONJP            AND GET NEXT ONE-OP
MXSYSLTP EQU   *                   PROCESS T' IN RANGE
         LA    R1,MCPAROTP         GET @ OF TYPE
         ST    R1,MCRESULT         STORE RESULT IN ONE-OP
         MVI   MCRESULT,1          SET LEN=1
         B     MXPNONJP            GET NEXT ONE-OP
MXSYLDBL EQU   *                   PROCESS DOUBLE SUBSCRIPTE
         L     R1,MXARG2           GET 2ND VALUE
         LTR   R1,R1               POSITIVE?
         BH    MXSYLDB1            OKAY IF YES
         LR    RC,R1               ELSE MOVE BAD VALUE TO RC
         LA    RW,$LMCQUAD(RW)     BUMP ONE-OP PNTR PAST DUMMY
         B     MXSYSLR1            JUMP TO FLAG ERROR
MXSYLDB1 EQU   *
         SR    RE,RE
         IC    RE,MCPARONB         GET SUBOPRND COUNT
         CR    R1,RE               SUBS > NBR SUBOPRNDS?
         BNH   MXSYLDB2            PROCEED IFLOW
         CLI   MCARG1DX+$LMCQUAD,$BSYSLST  $BSYSLIST?
         BE    MXSYSDFT            JUMP TO FOOT IF YES
         MVI   MCRSLTYP,$BSIMMA    SET TYPE = ARITH
         CLI   MCARG1DX+$LMCQUAD,$BSATK   K'&SYSLIST?
         BE    MXSYSDFT            FINI IF YES
         MVI   MCRSLTYP,$BSTRING   ELSE SET TYPE TO CHAR
         LA    R1,=C'O'            ELSE GET @ OF NULL TYPE
         B     MXSYLDB5            SKIP TO SAVE @, SET LEN=1
MXSYLDB2 EQU   *                   PROCESS &SYSLIST(A,B) IN RANGE
         L     RC,MCPRSBPT         GET @ OF SUBOPRNDS
         USING MCPARSUB,RC         SET USING FOR SUB E TRY
         BCTR  R1,0                DECR INDEX FOR MULT
         SLL   R1,3                MULT BY 8 FOR OFFSET
         AR    RC,R1               MOVE BASE TO RIGHT ENTRY
         CLI   MCARG1DX+$LMCQUAD,$BSYSLST   &SYSLIST?
         BNE   MXSYSDB3            IF NOT, PROCESS T' OR K'
         MVC   MCRESULT,MCPARSPT   ELSE MOVE @ OF SUBOPRND TO ONE-OP
         MVC   MCRESULT(1),MCPARSLN    MOVE LEN TO ONE-OP
         B     MXSYSDFT            JUMP TO FOOT
MXSYSDB3 EQU   *                   PROCESS K'&SYSLIST OR T'&SYSLIST
         CLI   MCARG1DX+$LMCQUAD,$BSATT     T'&SYSLIST?
         BE    MXSYLDB4            JUMP IF YES
         MVC   MCRESULT+3(1),MCPARSLN    ELSE MUST BE K'&SYSLIST
         MVI   MCRSLTYP,$BSIMMA    SET TYPE TO ARITH
         B     MXSYSDFT            JUMP TO FOOT
MXSYLDB4 EQU   *
         LA    R1,MCPARSTP         GET @ OF TYPE
MXSYLDB5 ST    R1,MCRESULT         STORE IN ONE-OP
         MVI   MCRESULT,1          SET LEN TO 1
*              FALL THRU INTO MXSYSDFT
MXSYSDFT EQU   *
         LA    RW,$LMCQUAD(RW)     BUMP PNTR PAST DUMMT ONE-OP
         B     MXPNONJP            GET NEXT ONE-OP
         DROP  RC
         SPACE
*  PROCESS &SYSLIST(A), T' OR K' WHERE A > NBR OPRNDS
         SPACE
MXSYSLHI EQU   *
         CLI   MCBOPRTR+$LMCQUAD,X'00'     DOUBLE SUBS?
         BE    MXSYSLHD            PROCESS IF YES
         CLI   MCARG1DX,$BSYSLST   $&SYSLIST?
         BE    MXPNONJP            GET NEXT ONE OP IF YES
         CLI   MCARG1DX,$BSATN      N'?
         BNH   MXSYSLHK            K' OR N' IF LOW OR EQUAL
         B     MXSYSLHT            T' IF HIGH
MXSYSLHD EQU   *                   PROCESS DUBLE SUBSCRIPT
         CLI   MCARG1DX+$LMCQUAD,$BSYSLST     &SYSLIST?
         BE    MXSYSDFT            FINI IF YES
         CLI   MCARG1DX+$LMCQUAD,$BSATN     N'?
         BH    MXSYSLHT            ELSE IS T'&SYSLIST
*              FALL THRU ==> K', IF LOW
MXSYSLHK EQU   *
         MVI   MCRSLTYP,$BSIMMA     SET TYPE TO ARITH
MXSYSTSD EQU   *
         CLI   MCBOPRTR+$LMCQUAD,X'00'    DOUBLE SUBS?
         BE    MXSYSDFT            FINI IF YES, JUMP TO DOUBLE FOOT
         B     MXPNONJP            ELSE GET NEXT ONE-OP
MXSYSLHT EQU   *
         LA    R1,=C'O'            GET @ OF NULL TYPE
         ST    R1,MCRESULT         STORE @ IN ONE-OP
         MVI   MCRESULT,1          SET LEN TO 1
         B     MXSYSTSD            TEST FOR DOUBLE SUBS
         EJECT
* SECTION TO ADD CHARS TO OUTPUT                                      A
*                                                                     A
MXPRNT   EQU   *
         USING RSBLOCK,RY          NOTE USING ON SOURCE
         L     RY,AVRSBPT          SET BASE ON SOURCE
         BAL   RET,MXCHAR          CONVERT ARG TO STRING
         LA    RA,RSBSOURC         SET SCAN POINTER
         LA    RE,$LMSRCMX(RA)     SET UPPER LIMIT POINTER
         A     RA,MCARG2LC         ADD OFFSET
         CLI   RSBLENG,X'00'       1ST MOVE?
         BE    MXPRNT01
         SR    R1,R1
         IC    R1,RSBLENG          GET PREV LEN-1
         LA    R1,RSB$L+1(R1,RY)   POINT TO AVAILABLE BYTE
         CR    RA,R1               COMPARE WITH TARGET
*          FOLLOWING CHECKS SPECIAL CASE OF OPRND MEETING COMMENT     A
         BH    MXPRNT01            OKAY IF NEXT PTR > OLD END         A
         BL    MXPRNT00            IF LOW, MUST INCREM BEYOND ANYWAY  A
         TM    MCBOPRTR,$MPRCOM    IF EQUAL, CHECK FOR SPECIAL COMPR  A
         BZ    MXPRNT01            NOT COMMENT,CONCAT IF COM,MOVE OVERA
MXPRNT00 LA    RA,1(,R1)           SKIP BLANK B                       A
MXPRNT01 EQU   *
         S     RB,AWF1             DECR RB
         BM    MXPNONJP            IF NULL, GET NEXT ONE-OP
         LA    R2,0(RA,RB)         POINT TO FINAL BYTE
         CR    R2,RE               EXCEED LIMIT?
         BNH   MXPRNT02            PROCEED IF OKAY
         LA    RB,$ERMEXST         ELSE SET ERROR FLAG
         $CALL ERRTAG              FLAG STMT
         B     MXPNONJP            GET NEXT ONE-OP
MXPRNT02 EQU   *
         EX    RB,MXPMVSRC         MOVE STRING TO SOURCE BLOCK
         LA    RA,RSBSOURC         GET START @
         SR    R2,RA               GET LEN-1 IN R2
         STC   R2,RSBLENG          STORE LEN-1
         B     MXPNONJP            GET NEXT ONE-OP
MXPMVSRC MVC   0($,RA),0(RC)       DUMMY TO MOVE STRING
         DROP  RY
         EJECT
         SPACE 2
*        INNER MACRO CALL                                             A
*                                                                     A
MXINMAC  EQU   *
         USING RSBLOCK,RY          NOTE USING
         L     RY,AVRSBPT          SET BASE
         SR    R1,R1               USE R1 FOR LENGTH
         IC    R1,RSBLENG          GET LENGTH IN R1
         LA    R1,RSB$L+1(RY,R1)   POINT TO NEXT AVAILABLE BYTE
         MVC   0(4,R1),=C'  '' '   MOVE END OF RECORD INDICATROR
         LA    R1,1(R1)            BUMP R1
         ST    R1,AVSOLAST         SAVE END OF RECORD @
         MVI   RSBNUM,1            SET NBR CARDS TO 1
         LA    RB,RSBLOCK+RSB$L+RSOL1  POINT TO 1ST BYTE, 2ND CARD
         CR    R1,RB               COMPARE WITH AVSOLAST
         BL    MXINMAC1            AVSOLAST LOW, ONE CARD
         MVI   RSBNUM,2            SET COUNT TO 2 CARDS
         LA    RB,RSOLC(RB)        BUMP RB TO 1ST BYTE, 3RD CARD
         CR    R1,RB               COMPARE WITH AVSOLAST
         BL    MXINMAC1            IF LOW, 2 CARDS
         MVI   RSBNUM,3            ELSE IS 3 CARDS
MXINMAC1 EQU   *
         OI    RSBFLAG,$RSBGENR+$RSBNPNN  SET GEN & NO ACTION FLAGS
         TM    RSBFLAG,$REBX       ERROR BLOCK EXISTS?
         BNO   MXINCALL                                               A
         SPACE 4
MXMVSTMT EQU   *
         USING RSBLOCK,RY
         L     RY,AVRSBPT          SET BASE
         OI    RSBFLAG,$RSBGENR    SET GEN FLAG
         TM    MCBOPRTR,$BSMNTER   MNOTE ERROR?
         BNO   MXMVSTMU            SKIP IF NOT
         OI    RSBFLAG,$RSBMERR    SET ERROR FLAG
MXMVSTMU EQU   *
         $CALL MXMVSR              MOVE SOURCE TO HIGH
         LTR   RB,RB               OVERFLOW?
         BNZ   MXEXECOV            FLAG IF YES
         B     MXPNINJP            GET NEXT INST
MXERRMS  EQU   *
         LA    RB,$ER#PRVR         SHOW PREVIOUS ERROR                S
         DROP  RY                                                     S
         BAL   R1,MXINERRM         CALL ERROR FLAG ROUTINE            S
         B     MXPNINJP            ELSE GET NEXT INST
         SPACE
MXANOP   EQU   MXPNINJP            NO CODE NEEDED, GO FOR NEXT
MXFIN    EQU   MXPNINJP            NO CODE NEEDED, GO FOR NEXT
         EJECT                                                        S
*              *** ERROR EXITS: TERMINATE PROCESSING *****
MXINV    EQU   *
         LA    RB,$ER#SYER         SET SYSTEM ERR FLAG
         B     MXMENDEC            STOP PROCESSING AND RETURN
MXMENDER LA    RB,$ER#MXST         SET EXCEED STMTS FLAG
MXMENDEC EQU   *                   CALL MXERRM AND QUIT-TYPE EXIT LABEL
         BAL   R1,MXINERRM         GENERATE ERROR MESSAGE             A
MXENDEF  LA    RB,12               RB SET TO KILL MACROS              A
         B     MXINRTN             RETURN                             A
*              FALL THRU, HANDLE AS MEND OR MEXIT.
         SPACE
MXMEND   EQU   *
MXMEXIT  EQU   *
         SR    RB,RB               RB SET FOR MEND OR MEXIT           S
MXINRTN  EQU   *                                                      A
         L     R1,AVMXSPIE         RELOAD R1 FROM SPIE PTR            A
         LM    RC,RD,AVGEN1CD                                         A
         XSNAP LABEL='AT MXINST RET',STORAGE=(*0(RD),*0(RC),*AVADDLOW,*X
               AVWXEND),IF=(AVTAGSM,O,AJOMACRH,TM)
         $SPIE ,,,ACTION=(RS,(1))                                     A
         $RETURN RGS=(R14-R6)                                         A
         SPACE
MXARG1LN DS    F                   TEMP STORAGE FOR ARG1 LENGTH
MXARG1   DS    F                   TEMP STORAGE FOR ARG1
MXARG2   DS    F                   TEMP STORAGE FOR ARG2
*                                                                     S
*        SET RB TO RETURN CONDITION                                   S
*                                                                     S
MXINKIL1 EQU   *                                                      S
         BAL   R1,MXINERRM         CALL ERR MSG ROUTINE               S
         LA    RB,8                SET KILL MACRO NEST FLAG           S
         B     MXINRTN             NORMAL RETURN                      S
MXINCALL EQU   *                                                      A
         LA    RB,4                SET RETURN CODE                    A
         B     MXINRTN             RETURN                             A
         LTORG                                                        S
         DS    0H                  FORCE ALIGNMENT                    S
         EJECT                                                        A
**--> INSUB: MXINERRM       CALLS MXERRM TO HANDLE ERROR MESSAGES  + +S
*+                                                                   +S
*+             ENTRY CONDITIONS:                                     +S
*+       RB = ERROR CODE                                             +S
*+       RC = VALUE IF ANY                                           +S
*+       RD = LENGTH                                                 +S
*+       R1 = LINK REG                                               +S
*+                                                                   +S
*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +S
         SPACE 2                                                      S
MXINERRM EQU   *                                                      S
         LR    RE,RZ               COPY @ OF MXPNTSAV                 A
         $CALL MXERRM              CALL ERROR ROUTINE                 S
         LTR   RB,RB               TEST RB FOR OVERFLOW               S
         BCR   Z,R1                RETURN ON NOT OVERFLOW             S
*        SET RB TO OVERFLOW VALUE AND RETURN                          S
MXEXECOV EQU   *                                                      S
         LA    RB,16               SET OVERFLOW FLAG                  S
         B     MXINRTN             NORMAL RETURN                      S
         SPACE 5                                                      S
**--> INSUB: MXARITH MXARITH PRODUCES ARITH ONE-OP                    A
*+                                 MXBOOL PRODUCES BOOLEAN ONE-OP     A
*+                                 MXCHAR PRODUCES CHAR ONE-OP        A
*         TYPE.                                                       *
*                                                                     *
*         ENTRY CONDITIONS                                            *
*      RA = TYPE OF OPRND                                             *
*      RB = @ OF OPRND (OR VALUE IF IMMEDIATE TYPE)                   *
*                                                                     *
*         EXIT CONDITIONS                                             *
*+       RA=BYTE REG                                                  A
*+       R1=WIPED OUT                                                 A
*+       RE=WIPED OUT                                                 A
*      RB = LENGTH OF CHAR STRING IF CHAR VALUE                       *
*      RC = VALUE IF ARITH OR BOOL, @ OF STRING IF CHAR               *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE
MXARITH  DS    0F
         OI    AVMBYTE2,$MINARIT   SET ARITH FLAG
         B     MXSCCV
MXBOOL   EQU   *
         OI    AVMBYTE2,$MINBOOL   SET BOOL REQ'D FLAG
         B     MXSCCV
MXCHAR   EQU   *
         OI    AVMBYTE2,$MINCHAR   SET CHAR REQ'D FLAG
MXCONVBS DS    0H                  BASE FOR JUMP TABLE
MXSCCV   EQU   *
         ST    RET,MXSCCVSV        SAVE RETURN @
         SPACE
MXCONJMP EQU   *
         N     RA,AWFXFF           MASK OUT ALL EXCEPT INDEX
         LH    R1,MXCONNDX(RA)     GET OFFSET OF ROUTINE
         XSNAP LABEL='***MXARITH ENTERED***',                          X
               IF=(AVMSNBY2,O,$MSNP12,TM)
         B     MXCONVBS(R1)        JUMP TO ROUTINE
         SPACE
MXCONNDX $AL2  MXCONVBS,(MXCNGLA,MXCNGLB,MXCNGLC,MXCNLCA,MXCNLCB,MXCNLC#
               C,MXCNSYPR,MXCNIMMA,MXCNIMMB,MXCNIMMC,MXCNSYSX,MXCNUND,M#
               XCNCSCT,MXCNUND,MXCNTEMP,MXCNUND,MXCNUND,MXCNATTK,      #
               MXCNUND,MXCNATTN,MXCNUND,MXCNATTT,MXCNADDA,MXCNADDB,    #
               MXCNADDC),-2
         SPACE
*        PROCESS GLOBALS                                              A
*                                                                     A
         USING MCGLBDCT,RB         NOTE USING FOR GLOBAL SET SYMB DV
MXCNGLA  EQU   *
         L     RC,MCGBAVAL         GET ARITH VALUE
         B     MXCONV0A
         SPACE
MXCNGLB  EQU   *
         L     RC,MCGBAVAL         GET BOOL VALUE
         B     MXCONV0B
MXCNGLC  EQU   *
         LA    RC,MCGBCVAL         GET @ OF CHAR VALUE
         L     RB,MCGBCLEN         GET LENGTH OFSTRING
         B     MXCONV0C
         EJECT
MXCNLCA  EQU   *
MXCNLCB  EQU   *
MXCNLCC  EQU   *
         L     RC,MGLCLPNT         GET OFFSET
         A     RC,MXPNLDBS         ADD BASE @ OF LOCAL SET SYM DICT
         CLI   MCGLBTYP,$BOOL      WHAT TYPE                          A
         BH    MXCNLCA1            CHAR IF HIGH
         L     RC,0(RC)            ELSE GET ARITH OR BOOL VALUE
         BL    MXCONV0A            ARITH IF LOW
         B     MXCONV0B            ELSE IS BOOL
MXCNLCA1 EQU   *
         L     RB,0(RC)            GET LEN OF CHAR
         LA    RC,4(RC)            BUMP POINTER TO STRING
         B     MXCONV0C
         DROP  RB                  DROP USING ON SET SYMB DV
         SPACE
MXCNSYPR EQU   *
         USING MCPAROPR,RE         NOTE USING ON SYM PAR DICT ENTRY
         LA    RE,$LMPAROP         GET LEN OF ENTRY
         MR    RD,RB               CALCULATE OFFSET
         A     RE,MXPNLSPT         ADD SYM PAR DICT BASE
         L     RC,MCPAROPT         GET POINTER TO STRING
         IC    RB,MCPAROLN         GET LEN OF STRING
         TM    AVMBYTE2,$MINCHAR+$MINBOOL                             A
         BNZ   MXCONV0C                                               S
         CLI   MCPAROTP,C'N'       FALL THRU MEANS ARITH REQ'D
         BE    MXCNSYP1            IF SELF DEF TERM, OK
MXCNSYER EQU   *
         LR    RD,RB               ELSE MOVE LEN TO RD
         LA    RB,$ER#CVCA         SET CONVERSION ERROR
         B     MXPNINJE            GO FLAG ERROR AND CONTINUE
MXCNSYP1 EQU   *
         LR    RA,RC               MOVE POINTER TO RA
         $CALL SDBCDX              CHECK FOR SELF DEF TERM
         LTR   RB,RB               OKAY?
         BZ    MXCONRTN            RETURN IF YES
         SR    RB,RB               ELSE CLEAR RB
         IC    RB,MCPAROLN         INSERT STRING LENGTH
         L     RC,MCPAROPT         POINT TO STRING
         B     MXCNSYER            AND FLAG ERROR
         SPACE
MXCNIMMA EQU   *
         LR    RC,RB               MOVE VALUE TO RC
         B     MXCONV0A            CONVERT IF NECESSARY
MXCNIMMB EQU   *
         LR    RC,RB               MOVE IMM VALUE TO RC
         B     MXCONV0B            CONVERT IF NECESSARY
MXCNIMMC EQU   *
         SRDL  RB,24               MOVE @ TO RC, LEAVE LEN IN RB
         SRL   RC,8                FINISH SHIFT IN RC
         B     MXCONV0C            CONVERT IF NECESSARY
*                                                                     A
*  PROCESS SYSNDX                                                     A
MXCNSYSX EQU   *                   GET SYSYNX VALUE
         TM    AVMBYTE2,$MINCHAR   CHAR REQ'D?
         BO    MXCNSX01            PROCESS CHAR IF YES
         ZAP   AVDWORK1,MXPSYSDX   MOVE SYSNDX TO DOUBLE WORD
         CVB   RC,AVDWORK1         CONVERT TO BINARY
         TM    AVMBYTE2,$MINBOOL   BOOL REQ'D?
         BNO   MXCONRTN            RETURN IF NOT
MXCNSX03 EQU   *
         LA    RB,$ER#CVAB         SET ARITH - BOOL ERROR
         B     MXCONVAR                                               A
         EJECT
*                                                                     A
*  CONVERT SYSNDX TO CHAR                                             A
*                                                                     A
MXCNSX01 EQU   *
         L     RE,MXPCHRBF         GET POINTER TO WORK AREA
         LA    RE,4(RE)            BUMP TO TEST END
         C     RE,AVMCHLIM         TEST AGAINST LIMIT
         BNH   MXCNSX02            PROCEED IF OKAY
         LA    RB,$ER#EXBF         SET ERROR FLAG
         B     MXPNINJE            GO FLAG ERROR AND CONTINUE
MXCNSX02 EQU   *
         LA    RB,4                PUT USEFUL VALUE IN RB
         SR    RE,RB               RESTORE THE POINTER
         UNPK  0(4,RE),MXPSYSDX    UNPACK &SYSNDX
         OI    3(RE),X'F0'         CHANGE LAST ZONE TO F
         LR    RC,RE               POINT RC AT STRING
         AR    RE,RB               BUMP RE TO END OF BUFFER
         ST    RE,MXPCHRBF         RESOTRE BUFFER POINTER
         B     MXCONRTN            AND RETURN
         SPACE
MXCNCSCT EQU   *
         LA    RC,AVSYSECT         GET @ OF CSECT NAME
         TRT   0(9,RC),AWTSYMT     SCAN NAME FOR LENGTH
         SR    R1,RC               GET LENGTH
         LR    RB,R1               MOVE LENGTH TO RB
         TM    AVMBYTE2,$MINCHAR   CHAR REQ'D?
         BO    MXCONRTN            RETURN IF YES
         B     MXCONCAR                                               A
         SPACE
MXCNTEMP EQU   *
         USING MCOPQUAD,RB         SET USING ON ONE-OP
         IC    RA,MCRSLTYP         GET INDEX
         L     RB,MCRESULT         GET LOCATION
         B     MXCONJMP            EVALUATE
         DROP  RB
         EJECT
MXCNATTK EQU   *
MXCNATTN EQU   *
         LTR   RB,RB               &SYSLIST?
         BNL   MXCNAT01            NO IF NOT LOW
         L     RC,MXPNBOPS         ELSE GET NBR OF OPRNDS
         B     MXCONV0A            AND CONVERT IF NECESSARY
MXCNATTT EQU   *
MXCNAT01 EQU   *
         TM    AVMBYTE2,$MINBOOL   BOOLEAN VALUE REQUIRED             J
         BZ    MXCNAT02            IF NOT OKAY
         LA    RB,$ER#ATER         ELSE SET ATTRIB USE ERR
         B     MXPNINJE            GO FLAG ERROR AND CONTINUE
MXCNAT02 EQU   *
         USING MCPAROPR,RE         SET USING ON SYM PAR DICT ENTRY
         SR    RC,RC
         LA    RE,$LMPAROP         GET LENGTH OF ENTRY
         MR    RD,RB               GET OFFSET
         A     RE,MXPNLSPT         ADD SYM PAR DICT BASE
         LA    R1,$BSATN           GET N' INDEX
         CR    RA,R1               COMPARE WITH OPRND INDEX
         BH    MXCNATTP            T' IF HIGH
         BE    MXCNATNP            N' IF EQUAL
         IC    RC,MCPAROLN         K' IF FALL THRU
         B     MXCONV0A            RETRN
MXCNATNP EQU   *
         IC    RC,MCPARONB         GET N'
         B     MXCONV0A            JUMP TO CONVERT
MXCNATTP EQU   *
         LA    RB,1                GET LENGTH OF TYPE
         LA    RC,MCPAROTP         GET POINTER TO TYPE
         B     MXCONV0C            CONVERT IF NECESSARY
         DROP  RE
         SPACE
MXCNADDA EQU   *
         L     RC,0(RB)            GET ARITH VALUE
         B     MXCONV0A            CONVERT IF NECESSARY
MXCNADDB EQU   *
         L     RC,0(RB)            GET VALUE
         B     MXCONV0B            CONVERT IF NECESSARY
MXCNADDC EQU   *
         LA    RC,4(RB)            GET @ OF STRING
         L      RB,0(RB)           GET LENGTH OF STRING
         B     MXCONV0C            CONVERT IF NECESSARY
         SPACE
MXCNUND  EQU   *
         LA    RB,$ER#SYER         SET SYSTEM ERROR FALG
         B     MXPNINJE            GO FLAG ERROR AND CONTINUE
         EJECT
*                                                                     A
*        CONVERT TO ARITH                                             A
*                                                                     A
MXCONV0A EQU   *
         TM    AVMBYTE2,$MINARIT   ARITH REQ'D?
         BO    MXCONRTN            RETURN IF YES
         B     MXCONVAR            ELSE CONVERT
*                                                                     A
*        CONVERT TO BOOLEAN                                           A
*                                                                     A
MXCONV0B EQU   *
         TM    AVMBYTE2,$MINBOOL+$MINARIT   ARITH OR BOOL REQ'D?
         BM    MXCONRTN            RETURN IF YES
         B     MXCONVBL            ELSE CONVERT
*                                                                     A
*        CONVERT TO CHAR                                              A
*                                                                     A
MXCONV0C EQU   *
         TM    AVMBYTE2,$MINCHAR   CHAR REQ'D?
         BO    MXCONRTN            RETURN IF YES
         B     MXCONVCH            ELSE CONVERT
MXCONVAR EQU   *
         TM    AVMBYTE2,$MINCHAR   CHAR REQ'D?
         BO    MXCONVAC            CONVERT IF YES
         C     RC,AWF1             BOOL VALUE?
         BE    MXCONRTN            RETURN IF YES
         LTR   RC,RC               ZERO VALUE?
         BE    MXCONRTN            OKAY IF YES
MXCONVAB LA RB,$ER#CVAB            ELSE SET ERROR FLAG                A
         B     MXPNINJE            GO FLAG ERROR AND CONTINUE
MXCONVAC EQU   *
         LPR   RC,RC               GET POS VALUE
         CVD   RC,AVDWORK1         CONVERT TO PACKED DEC
         LA    RB,12               GET MAX LENGTH OF DEC NUMBER+1
         $MALLOCL  RE,RB,OVRFL=MXEXECOV   GET STORAGE FOR NBR
         MVC   0(12,RE),MXCEP12    MOVE EDIT MASK FOR MAX NBR
         LA    R1,11(RE)           POINT TO LAST CHAR
         LA    RB,1(R1)            GET @ OF DELIM IN RB
         EDMK  0(12,RE),AVDWORK1+2 EDIT DEC FIELD
         LR    RC,R1               MOVE POINTER TO RC
         SR    RB,R1               PUT LENGTHIN RB
         B     MXCONRTN            AND RETURN
         EJECT
MXCONVBL EQU   *
*                                                                     A
* CONVERT BOOLEAN --> CHAR                                            A
*                                                                     A
         LA    RB,1                SET LEN TO 1
         LA    RC,MXCONBLT(RC)     GET @ OF '0' OR '1' AS APPROPRIATE
         B     MXCONRTN            AND RETURN
MXCONBLT DC    C'01'               CONVERT BOOLEAN TO CHARACTER
         SPACE
MXCONVCH EQU   *
         TM    AVMBYTE2,$MINBOOL   BOOL REQ'D?
         BO    MXCONVCB            CONVERT IF YES
*                                                                     A
* CONVERT CHAR --> ARITH                                              A
*                                                                     A
MXCONVCA EQU   *                   CONVERT TO ARITH
         SR    R2,R2
         SR    R1,R1
         LTR   RB,RB               TEST LENGTH OF CHAR
         BNZ   MXCONCA1            PROCEED IF NONZERO
MXCONCAR EQU   *                   PROCESS ZERO STRING
         LR    RD,RB               MOVE LENGTH TO RD
         LA    RB,$ER#CVCA         SET CONVERSION ERROR FLAG
         B     MXPNINJE            GO FLAG ERROR AND CONTINUE
MXCONCA1 EQU   *                   CONVERT TO ARITH
         TRT   0(1,RC),AWTDECT     POSSIBLE SELF DEF TERM?
         BNZ   MXCONCA4            CKECK FOR C,B OR X IF NOT
         C     RB,AWF10            TEST LENGTH
         BH    MXCONCAR            ERROR IF > 10
         BL    MXCONCA2            IF < 10, OKAY
         CLC   0(10,RC),=C'2147483647'  ELSE COMPARE AGAINST LIMIT
         BH    MXCONCAR            ERROR IF HIGH
MXCONCA2 EQU   *
         BCTR  RB,0                DECR LEN FOR TRT
         EX    RB,MXPSCDEC         SCAN FOR DEC NBRS
         BZ    MXCONCA3            OKAY IF ALL DEC
         LA    RB,1(RB)            ELSE RESTORE RB
         B     MXCONCAR            AND FLAG ERROR
MXCONCA3 EQU   *
         EX    RB,MXPMVDEC         MOVE DEC STRING TO WORK AREA PACKED
         CVB   RC,AVDWORK1         CONVERT TO BIN
         B     MXCONRTN            AND RETURN
MXCONCA4 EQU   *
         C     R2,AWF4             B, C OR X?
         BNE   MXCONCAR            ERROR IF NOT
         LR    R1,RB               SAVE LENGTH
         LR    RA,RC               MOVE POINTER TO RA
         $CALL SDBCDX              CHECK FOR SELF DEF AND CONVERT
         LTR   RB,RB               OKAY?
         BZ    MXCONRTN            RETURN IF OKAY
         LR    RB,R1               RESTORE LENGTH TO RB
         LR    RC,RA               PUT POINTER IN RC
         B     MXCONCAR            AND FLAG ERROR
         SPACE
MXPMVDEC PACK  AVDWORK1,0($,RC)    DUMMY TO PACK STRING
MXPSCDEC TRT   0($,RC),AWTDECT     DUMMY TO SCAN FOR DEC CHARS
         SPACE 10                                                     S
MXCONVCB EQU   *                   CONVERT CHAR TO BOOL
         C     RB,AWF1             LEN = 1?
         BE    MXCONCB1            OKAY IF 1
MXCONCBR EQU   *                   ELSE IS ERROR
         LR    RD,RB               MOVE LEN TO RD
         LA    RB,$ER#CVCB         SET CHAR->BOOL ERROR
         B     MXPNINJE            GO FLAG ERROR AND CONTINUE
MXCONCB1 EQU   *
         CLI   0(RC),C'1'          CHAR = 1?
         BNE   MXCONCB2            PROCEED IF NOT 1
         LA    RC,1                SET BOOL VALUE
         B     MXCONRTN            AND RETURN
MXCONCB2 EQU   *
         CLI   0(RC),C'0'          DID CHAR = '0' (ZERO)              J
         BNE   MXCONCBR            ERROR IF NOT
         SR    RC,RC               SET FALSE BOOL FALUE
*                                                                     A
MXCONRTN EQU   *
         XSNAP LABEL='***MXARITH EXITED***',                           X
               IF=(AVMSNBY2,O,$MSNP12,TM)
         SR    RA,RA               ZERO RA FOR BYTE USE               A
         L     RET,MXSCCVSV        RESTORE RETURN @
         BR    RET                 AND RETURN
MXSCCVSV DS    F                   SPACE FOR RETURN ADDRESS
MXCEP12  DC    X'402020202020202020202120'    12 BYTE DEC MASK
         LTORG
         TITLE ' MXINST-INTERNAL ROUTINES'                            A
**--> INSUB: MXADDR       THIS ROUTINE ACCEPTS A ONE-OP  + + + + + + +S
*+       OPRND AND RETURNS THE @ OF THE SYMBOL.  OPRND MUST BE       +S
*+       A SET SYMBOL OR TEMP VALUE POINTING TO AN ADDRESS.          +S
*+                                                                   +S
*+             ENTRY CONDITIONS:                                      S
*+       RA = INDEX OF OPRND                                         +S
*+       RB = @ OF OPRND                                             +S
*+                                                                   +S
*+             EXIT CONDITIONS:                                      +S
*+       RC = @ OF VALUE                                             +S
*+       RD = DIMENSION OF SET SYMBOL                                +S
*+       RE = TYPE OF SYMBOL (IE -  $ARIT, $BOOL OR $CHAR)           +S
*+                                                                   +S
*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +S
         SPACE
MXADDR   DS    0F                  ENTRY PT FOR INTERNAL SUB
         XSNAP LABEL='***MXADDR ENTERED***',                           X
               IF=(AVMSNBY2,O,$MSNP12,TM)
         USING MCGLBDCT,RB         NOT USING ON SET SYMB DV
         SR    RE,RE
         SR    RD,RD
         LA    R1,$BSYMPAR         GET SYM PAR BSU VALUE
         CR    RA,R1               COMPRE WITH OPNRD
         BNL   MXADDR01            NOT SET SYM IF NOT LOW
         SRL   R1,1                DIVIDE SYM PAR BSU BY 2
         CR    RA,R1               COMPARE WITH OPRND
         BNL   MXADDRLC            SET SYM LOCAL IF NOT LOW
         LA    RC,MCGBAVAL         GET @ OF VALUE
         LH    RD,MCGLBDIM         GET DIMENSION
         IC    RE,MCGLBTYP         GET TYPE IN RE
         B     MXADDRET            JUMP TO FOOT
MXADDRLC EQU   *                   TREAT LOCAL SET SYMBOLS
         LH    RD,MCGLBDIM         GET DIMENSION
         IC    RE,MCGLBTYP         GET TYPE
         L     RC,MGLCLPNT         GET OFFSET
         A     RC,MXPNLDBS         ADD BASE @ OF SET SYM DICT
         B     MXADDRET            JUMP TO FOOT
MXADDR01 EQU   *
         USING MCOPQUAD,RB         NOTE USING ON ONE-OP
         LA    R1,$BSTEMP          GET TEMP BSU
         CR    R1,RA               MUST BE $BSTEMP
         BNE   MXADDRR1            ERROR IF NOT
         L     RC,MCRESULT         GET @ OF DESIRED VALUE
         CLI   MCRSLTYP,$BSADDRA   COMPARE WITH ARITH @
         BL    MXADDRR1            ERROR IF LOW
         BE    MXADDR02
         CLI   MCRSLTYP,$BSADDRC   CHECKFOR CHAR @
         BH    MXADDRR1            ERROR IF HIGH
         BE    MXADDR03            ARITH IF EQUAL
         LA    RE,$BOOL            FALL THRU MEANS BOOLEAN
         B     MXADDRET            JUMP TO FOOT
MXADDR02 EQU   *
         LA    RE,$ARITH           SET ARITH TYPE
         B     MXADDRET            JUMP TO FOOT
MXADDR03 EQU   *
         LA    RE,$CHAR            SET CHAR TYPE
         B     MXADDRET            JUMP TO FOOT
MXADDRR1 EQU   *
         LA    RB,$ER#SYER         SET SYSTEM ERROR
         B     MXPNINJE            GO FLAG ERROR AND CONTINUE
MXADDRET EQU   *
         XSNAP LABEL='*** MXADDR EXITED ***',                          #
               IF=(AVMSNBY2,O,$MSNP12,TM)
         BR    RET                 AND RETURN
         LTORG
         DROP  RB,RZ,RAT                                              S
         TITLE '***MXERRM  GENERATES ERROR MSSGS IN MEXPND***'
**-->  CSECT:  MXERRM  CALLED DURING MACRO GENERATION TO GENERATE     *
*.        ERROR MESSAGES NOT HANDLED BY ERRTAG                        *
*.                                                                    *
*.        ENTRY CONDITIONS                                            *
*.       RA-SCAN PTR                                                  A
*.     RB = ERROR TYPE                                                *
*.     RC = OPERAND VALUE OR LOCATION                                 *
*.     RD = LENGTH OF STRING IF CHAR VALUE                            *
*.       RE-@ MXPNTSACV                                               A
*.                                                                    *
*.       EXIT CONDITIONS                                              A
*.       RB=0 ==> OK                                                  A
*.       RB=4 ==> STORAGE OVERFLOW CAUSED MESSAGE SELECTED IS PLACED  A
*.       IN RSBLOCK, THEN MOVED OUT TO HIGH AREA BY MXMVSR            A
*.                                                                    A
*.        USES MACROS: $CALL, $AL2, $SAVE, $RETURN                    *
*.        CALLS MXMVSR                                                *
*.        USES DSECTS: RSBLOCK, MXPNTSAV, MCOPQUAD, AVWXTABL          *
*.                                                                    *
*.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE
MXERRM   CSECT
         $SAVE RGS=(R14-R6),BR=R13,SA=*
         USING AVWXTABL,RAT        NOTE MAIN TABLE USING
         XSNAP LABEL='***MXERRM ENTERED***',T=NO,                      X
               IF=(AVMSNBY2,O,$MSNP13,TM)
         USING RSBLOCK,RW          NOTE USING FOR SOURCE BLOCK
         L     RW,AVRSBPT          SET BASE FOR SOURCE
         USING MXPNTSAV,RE         MACRO BLOCK                        A
         L     RY,MXPNCRCD         CURRENT INSTRUCTION                A
         USING MCOPQUAD,RY         NOTE USING                         S
         MVC   RSBLOCK(RSB$L),=AL1(0,$RSBNPNN+$RSBMERR,1,0)           S
         LA    R1,MXMSSGS          ADDRESS OF MESSAGES                A
         AH    R1,MXERRPTR(RB)     @ SPECIFIC MSG                     A
         USING MSGBLOCK,R1                                            A
         SR    R2,R2               CLEAR R2                           A
         IC    R2,MSGLENM1         GET LENGTH-1 OF MSG & NUMBER       A
         EX    R2,MXERRMVC         MOVE IT IN                         A
*  1ST PART (MSG) NOW DONE                                            A
*  NOW FILL IN STM NUMBER, OTHER DATA                                 A
*  R2 WILL BE ACCUMUALTION OF L-1                                     A
         LA    RA,RSBSOURC+1(R2)   @ NEXT BYTE                        A
         MVC   0(MXERRS$L,RA),MXERRSTN  STMT NUMBER EDIT PATTERN      A
         ED    L'MXERRSTN(6,RA),MCQSTMNO                              A
         L     RY,MXPNMCLB         GET MACRO PTR                      A
         USING MACLIB,RY                                              A
         MVC   MXERRS$L(L'MCLBNAM,RA),MCLBNAM                         A
         LA    RB,MXMSSGS(RB)      ADD @ BEGINNING OF TABLE
         LA    R2,MXERRS$L+L'MCLBNAM(R2)  BUMP L-1                    A
         DROP  RE,RY                                                  A
         LA    RA,RSBSOURC+1(R2)   BUMP PTR FOR MSG OUTPUT            A
*        MSGFLAG = 0               MSG #                              S
*                  4               NUMERICAL                          S
*                  8               CHAR VALUE                         S
*                                                                     S
         CLI   MSGFLAG,X'04'       COMPARE VALUE                      S
         BL    MXERFOOT            IF LOW, DONE.
         MVC   0(3,RA),=C'-->'     MOVE POINTER TO RSBSOURC
         LA    RA,3(RA)            BUMP SCAN POINTER
         LA    R2,3(R2)            BUMP LEN-1
         BH    MXERRM0C            CHAR STRING IF HIGH
         SPACE
MXERRM0A EQU   *                   FALL THRU FOR ARITH TYPR
         LA    R1,AVMWRK1+11       POINT TO END OF EDIT MASK
         LA    RE,1(R1)            POINT RE TO DELIMMPAST MASK
         CVD   RC,AVDWORK1         CONVERT VALUE TO PACKED DEC
         MVC   AVMWRK1(12),MXEEP12  MOVE EDIT MASK TO WORK AREA
         EDMK  AVMWRK1(12),AVDWORK1+2  EDIT AND MARK VALUE
         SR    RE,R1               GET LENGTH OF STRING
         BCTR  R1,0                DECR POINTER TO SIGN POSIT
         EX    RE,MXMVSTRN         MOVE CHAR VALUE TO OUTPUT
         LTR   RC,RC               NEG VALUE?
         BNL   MXERRMA1            SKIP IF NOT
         MVI   1(RA),C'-'          ELSE INSERT MINUS SIGN
MXERRMA1 EQU   *
         LA    R2,2(RE,R2)        BUMP LENGTH
         B     MXERFOOT            JUMP TO FOOT
MXERRM0C EQU   *
         LR    R1,RC               MOVE @ OF STRING TO R1
         LA    RE,RSOL1-2                                             A
         SR    RE,R2               SUBTRACT CURRENT L-1               A
         CR    RD,RE               VALUE LEN OK?
         BNH   MXERRMC1            PROCEED IF OKAY
         LR    RD,RE               ELSE SUB OKAY LENGTH
MXERRMC1 EQU   *
         LA    R2,1(RD,R2)         GET TOTAL L-1                      A
         LTR   RD,RD               NULL STRING?
         BZ    MXERFOOT            FINI IF YES
         EX    RD,MXMVSTRN         MOVE STRING TO OUTPUP
*              FALL THRU INTO MXERFOOT.
MXERFOOT EQU   *
         STC   R2,RSBLENG          PUT LEN-1 IN OUTPUT
         $CALL MXMVSR              MOVE STMT TO HIGH AREA
         SPACE
         XSNAP LABEL='***MXERRM EXITED***',T=NO,                       X
               IF=(AVMSNBY2,O,$MSNP13,TM)
         SPACE
         $RETURN  RGS=(R14-R6)
         SPACE
MXERRMVC MVC   RSBSOURC($),MSGNMBR                                    A
MXMVSTRN MVC   1($,RA),0(R1)       DUMMY TO MOVE STRING
MXEEP12  DC    X'402020202020202020202120'    12 BYTE DEC MASK
MXMSSGS  EQU   *
MXACTRMS $MSG  221,' ACTR COUNTER EXCEEDED'                           A
MXDMSNMS $MSG  222,' INVALID SYM PAR OR SET SYMBL SUBSCRIPT',FLAG=4   A
MXSBSTMS $MSG  223,' SUBSTRING EXPRESSION OUT OF RANGE',FLAG=4        A
MXCVCAMS $MSG  224,' INVALID CONVERSION, CHAR TO ARITH',FLAG=8        A
MXCVABMS $MSG  225,' INVALID CONVERSION, ARITH TO BOOLEAN',FLAG=4     A
MXCVCBMS $MSG  226,' INVALID CONVERSION, CHAR TO BOOLEAN',FLAG=8      A
MXATTRMS $MSG  227,' ILLEGAL ATTRIBUTE LIST'                          A
MXSYSLMS $MSG  228,' &&SYSLIST SUBSCRIPT OUT OF RANGE',FLAG=4         A
MXSYERMS $MSG  229,' ASSIST CANNOT EXPAND--SIMPLIFY STMT OR USE .' CPP
MXERBFM  $MSG  230,' INTERNAL CHAR BUFFER EXCEEDED'                   A
MXEXSTMS $MSG  231,' MSTMG LIMIT EXCEEDED'                            A
MXZDIVMS $MSG  232,' ZERO DIVIDE OR FIXED POINT OVERFLOW'             A
MXPRVR   $MSG  217,' STMT NOT PROCESSED: PREVIOUS ERROR'              A
MXERRSTN DC    C': STMT/MACRO',X'402020202120',C'/'                   S
MXERRS$L EQU   *-MXERRSTN                                             A
MXERRPTR $AL2  MXMSSGS,(MXACTRMS,MXDMSNMS,MXSBSTMS,MXCVCAMS,MXCVABMS,MXX
               CVCBMS,MXATTRMS,MXSYSLMS,MXSYERMS,MXERBFM,MXEXSTMS,MXZDIX
               VMS,MXPRVR),-2                                         A
         LTORG
         DROP  RAT,RW                                                 A
         TITLE '***MXMVSR - MOVES GENERATED STMT TO HIGH CORE***'
**-->  CSECT:  MXMVSR  MOVES GENERATED STMT FROM RSBLOCK TO HIGH FREE *
*.        AREA. AVGEN2CD POINTS TO BEGINNING OF STMT                  *
*.                                                                    *
*.        EXIT CONDITIONS                                             *
*.     RB = ZERO IF OKAY ELSE 4 IF OVERFLOW                           *
*.                                                                    *
*.        USES MACROS: $SAVE, $RETURN, $MALLOCH                       *
*.       USES DSECTS RSBLOCK,REBLK,AVGEN1CD,AVGEN2CD                  A
*.                                                                    *
*.       REGISTER USAGES                                              A
*.       RAT-MAIN TABLE USING                                         A
*.       RW-SOURCE BLK USING                                          A
*.       RX-ERROR BLK USING                                           A
*.       R1,RB-BYTE REGISTERS                                         A
*.       RA-WORK REGISTER                                             A
*.                                                                    A
*.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE
MXMVSR   CSECT
         $SAVE RGS=(R14-R4),SA=NO                                     A
         USING AVWXTABL,RAT        NOTE MAIN TABLE USING
         XSNAP LABEL='***MXMVSR ENTERED***',T=NO,                      X
               IF=(AVMSNBY2,O,$MSNP13,TM)
         USING RSBLOCK,RW          NOTE SOURCE USING
         L     RW,AVRSBPT          SET BASE FOR RSBLOCK
         USING REBLK,RX            SET USING FOR ERROR BLOCK
         LA    RX,AVREBLK          SET BASE FOR ERROR BLOCK
         SR    R1,R1
         SR    RB,RB
         TM    RSBFLAG,$REBX       EROOR BLOCK EXISTS?
         BZ    MXMVSR01            JUMP AROUND IF NO
         IC    RB,REBLN            GET LEN-1 OF ERR BLOCK
         STC   RB,RSBNUM           PUT ERR BLOCK LEN IN RSB
*              REBLN IS ACTUAL LENGTH OF PART OF REBLK TO BE MOVED,
*              SINCE IT IS L-1 OF WHOLE THING (COUNTING REBLN)
MXMVSR01 EQU   *
         IC    R1,RSBLENG          GET LEN-1 OF STMT
         LA    RB,RSB$L+1(RB,R1)   GET TOTAL LENGTH FOR ENTIRE SECT
         $MALLOCH RA,RB,OVRFL=MXMVOVR    GET STORAGE FOR STMT
         TM    RSBFLAG,$REBX       ERROR BLOCK?
         BZ    MXMVSR02            SKIP IF NO
         IC    RB,REBLN            GET LEN-1 OF ERR BLOCK
         BCTR  RB,0                GET LENGTH-1 OF PART TO BE MOVED
         LA    RX,1(RX)            BUMP REBLK PTR TO PART BEING MOVED
         EX    RB,MXMVSRCE         MOVE ERRBLOCK TO HIGH STORAGE
         LA    RA,1(RA,RB)         GET ACTUAL LENGTH MOVED
MXMVSR02 EQU   *
         LA    RX,RSBSOURC         PUT @ OF SOURCE IN RX FOR EX INST
         EX    R1,MXMVSRCE         MOVE STMT TO HIGH CORE
         AR    RA,R1               BUMP PTR TO LAST CHAR              A
         MVC   1(RSB$L,RA),RSBLOCK MOVE FLAG BYTE ETC                 A
         SR    RB,RB               CLEAR RB FOR RETURN
MXMVRTN  EQU   *
         MVC   RSBLOCK(RSB$L),AWZEROS   ZERO STANDARD PART OF RSBLOCK
         MVC   RSBSOURC($LMSRCMX),AWBLANK   BLANK REMAINDER OF RECORD
         SPACE
         AIF   (&$DEBUG).MACQQ09   SKIP IF NO DEBUG
         L     R1,AVGEN2CD         GET POINTER TO NEW STMT
         XSNAP LABEL='***MXMVSR EXITED***',STORAGE=(*0(R1),*128(R1)),  X
               IF=(AVMSNBY2,O,$MSNP13,TM)
.MACQQ09 ANOP
         SPACE
         $RETURN RGS=(R14-R4),SA=NO                                   A
         SPACE
MXMVOVR  EQU   *
         LA    RB,4                SET OVERFLOW FLAG
         B     MXMVRTN             RETURN
MXMVSRCE MVC   0($,RA),0(RX)       DUMMY TO MOVE STIRNG TO HIGH
         LTORG
         DROP  RAT,RW,RX,REP
.MAXXXX  ANOP
         PRINT ON,NOGEN
         AIF   (NOT &$EXINT).EINONE                                   L
         TITLE '*** ECBRSTKD - DSECT FOR THE EXT'D INT BRANCH STACK'
**--> DSECT: ECBRSTKD       SINGLE ENTRY FOR THE BRANCH STACK . . . . .
*.                                                                    .
*.       THIS DSECT MIRRORS THE ECSTACKD DSECT BUT IS                 .
*.       USED BY THE EXTENDED INTERPRETER FOR THE                     .
*.       SUCCESSFUL-BRANCH STACK.                                     .
*.                                                                    .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         SPACE 2
ECBRSTKD DSECT
ECBSTENT DS    0CL16               BRANCH STACK ENTRY
ECBSLINK DS    F                   @ OF THE NEXT STACK ENTRY (LINK)
ECBSIADD DS    F                   BRANCH INSTRUCTION ADDRESS
ECBSCCPM DS    H                   CC AND PM
         SPACE
ECBSINST DS    0CL6                UP TO 6 BYTES OF INSTRUCTION
ECBSOP   DS    C                   OPCODE
ECBSB2   DS    C                   2ND BYTE OF INSTRUCTION
ECBSBD   DS    H                   1ST OR ONLY BASE/DISPLACEMENT
ECBSB2D2 DS    H                   2ND BASE/DISPLACEMENT
         TITLE '*** EXECUT- EXTENDED INTERPRETER SECTION'
**--> CSECT: EXECUT       EXTENDED INTERPRETER SECTION  . . . . . . . .
*.                                                                    .
*.             EXTENDED INTERPRETER FOR ASSIST                        .
*.                                                                    .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         SPACE 5
******************   REGISTER USAGE IN EXECUT   ***********************
*                                                                     *
*        REG #                     USAGE IN EXECUT                    *
*        -----                     ---------------                    *
*                                                                     *
*        R0             GENERAL WORK REG                              *
*        R1             TEMPORARY BASE / GENERAL WORK REG             *
*        R2             BYTE REG / TEMPORARY WORK REG                 *
*        R3             BASE REG FOR THE INSTRUCTION STACK            *
*        R4             INSTRUCTION ADDRESS REGISTER & OPERAND        *
*                       ADDRESS REGISTER                              *
*        R5             CONDITION CODE REG                            *
*        R6             BASE REGISTER FOR DSECT -> ECONTROL           *
*        R7-R9          DECODING AND GENERAL WORK REGS                *
*        R10            DECODING REG & OPERAND ADDRESS REGISTER       *
*        R11            CONTAINS RELOCATION VALUE (RARELY USED AS     *
*                       A WORK REG - BUT ALWAYS RESTORED)             *
*        R12 & R13      BASE REGISTERS FOR EXECUT                     *
*        R14            WORK REG / INTERNAL LINKAGE REG               *
*        R15            CONTAINS OPCODE OF CURRENT INSTRUCTION        *
*                                                                     *
***********************************************************************
EXECUT CSECT
RWK0     EQU   R0
RWK1     EQU   R1
RSTK     EQU   R3
RIA      EQU   R4
RAD1     EQU   RIA
RAD2     EQU   R10
RCC      EQU   R5
REC      EQU   R6
RMEM     EQU   R11
RLINK    EQU   R14
RWK14    EQU   R14
ROP      EQU   R15
         TITLE '*** EXECUT - INITIALIZATION PHASE'
***********************************************************************
*                                                                     *
*              INITIALIZATION CODE FOR EXECUT                         *
*                                                                     *
***********************************************************************
         SPACE 5
         $SAVE RGS=(R14-R12),BR=(R13,R12),SA=EIECSAVE
         LR    REC,R10             MOVE ECONTROL POINTER OVER
         USING ECONTROL,REC        NOTE ECONTROL USAGE
         SPACE 2
*              INSTRUCTION STACK ZEROING AND CHAINING
         SR    R1,R1               CLEAR FOR ZEROING
         SR    R2,R2               DITTO
         SR    R3,R3               DITTO
         LA    R4,L'ECSTENT        VAL OF SINGLE STACK ENTRY
         LA    R5,ECINSTAC+L'ECINSTAC*(EC$STACK-1)  GET ENDING LIMIT
         LA    R7,ECINSTAC         GET BEGINNING @ OF STACK AREA
         USING ECSTACKD,R7         SET UP TEMPORARY USING
         LA    R0,ECINSTAC+L'ECINSTAC  GET @ OF THE 2ND ELEMENT
EINITIST EQU   *
         STM   R0,R3,ECSTENT       ZERO ONE TABLE ENTRY
         LR    R7,R0               UPDATE POINTER TO STACK ENTRY
         BXLE  R0,R4,EINITIST      CONTINUE LOOPING
         SPACE
         LA    R0,ECINSTAC         ADDRESS FOR WRAP-AROUND
         STM   R0,R3,ECSTENT       STORE IN LAST ENTRY
         ST    R7,ECRSTK           SAVE WHERE CAN BE PICKED UP
         DROP  R7                  DROP TEMP REG
         SPACE 2
*              BRANCH STACK ZEROING AND CHAINING
         LA    R4,L'ECBSTENT       VAL OF SINGLE BRANCH STACK ENTRY
         LA    R5,ECBRSTAC+L'ECBRSTAC*(EC$BRSTC-1)  GET ENDING LIMIT
         LA    R7,ECBRSTAC         GET BEGINNING @ OF STACK AREA
         USING ECBRSTKD,R7         SET UP TEMPORARY USING
         LA    R0,ECBRSTAC+L'ECBSTENT   GET @ OF 2ND ELEMENT
EINITBST EQU   *
         STM   R0,R3,ECBSTENT      ZERO ONE TABLE ENTRY
         LR    R7,R0               UPDATE POINTER TO STACK ENTRY
         BXLE  R0,R4,EINITBST      CONTINUE LOOPING
         SPACE
         LA    R0,ECBRSTAC         ADDRESS FOR WRAP-AROUND
         STM   R0,R3,ECBSTENT      STORE IN LAST ENTRY
         ST    R7,ECBSTK           SAVE WHERE CAN BE PICKED UP
         ST    R7,ECBCUR           SAVE FOR EIFINB LIST MANIPULATION
         DROP  R7                  DROP TEMP REG
         SPACE 2
*              MORE INITIALIZATION
         MVC   ECILCMSK(4),ECFENTER MAKE ENTRY POINT THE PSW
         MVC   ECR14SAV,ECREG14    SAVE FOR ORIGINAL RETURN @
         MVC   ECILIMT,ECILIMP     MOVE PERMENANT TO TEMPORARY        L
         SPACE 2
*              ADDRESS CALCULATION SECTION
*              THE BELOW FAKE HIGH ADDRESS CALCULATION IS A DUPLICATION
*              OF THE ADDRESS CALCULATIONS DONE IN ASSIST MAIN CONTROL
*              REMOVING THIS CODE HOWEVER CAUSES THE HIGH ADDRESS TO
*              TO END UP VERY WRONG WHEN IT GETS TO THE INTERPRETER
EICONTIN EQU   *
         L     R0,ECRADH           GET REAL HIGH ADDRESS LIMIT
         S     R0,ECRADL           GET LENGTH OF USER PROGRAM
         A     R0,ECFADL           ADD TO FAKE LOW ADDRESS
         ST    R0,ECFADH           STORE IN FAKE HIGHEST ADDR
         SPACE 2
*              SET UP SPIE CODE
EISPIEGO EQU   *
         TM    ECFLAG0,$ECSPIEA    IS OUR SPIE ALREADY IN EFFECT
         BO    EISPIEA             YES, WE DON'T HAVE TO RE-SPIE
         $SPIE EISPIERT,((1,15)),CE=EISPIEXT,ACTION=CR CATCH ALL INTRP
         ST    R1,ECPICA           SAVE PREVIOUS PICA, IF ANY
         OI    ECFLAG0,$ECSPIEA    SHOW OUR SPIE IS IN CONTROL
         SPACE 2
EISPIEA  EQU  *
*        INITIALIZE THE PRCB FOR THIS RUN
*        (ALL DEFAULT ADDRESSES, FLAGS, ETC SET)
         MVC   ECPRFLG1(8),EIDFAULT  MOVE DEFAULT VALS TO PRCB
         MVC   ECPRWORK(4),ECFADL  SET UP HIGH AND LOW DEFAULT        M
         MVC   ECPRWORK+4(4),ECFADH    ADDRESSES IN WORK AREA         M
         MVC   ECPRTRAL(8),ECPRWORK  SET TRACE LIMIT ADDRS            M
         MVC   ECPRMODL(8),ECPRWORK  SET MOD CHK LIMIT ADDRS          M
         MVC   ECPRICL(8),ECPRWORK   SET IECF LIMIT ADDRESSES         M
         MVC   ECPRCLOK(4),ECILIMP   SET INSTR COUNTER (CLOCK)
         MVC   ECPRCMPR(4),=F'-1'  DISARM INTERRUPT CLOCK
         MVI   EITSTMSK+1,ECEM370  ITIALIZE INVALID OP CODE TEST
         SPACE 2
*              SET UP USINGS, REGS, ETC. FOR THIS RUN
         L     RSTK,ECRSTK         GET PTR TO STACK FOR BASE
         USING ECSTACKD,RSTK       SET UP PERMANENT USING
         L     RMEM,ECRELOC        GET RELOCATION VAL IN REG
         SR    R2,R2               CLEAR BYTE REG
         STH   R2,ECINTCOD         SET THE INTERRUPT CODE TO 0
         SR    ROP,ROP             CLEAR OPCODE REG FOR CONSTANT IC'S
         L     RIA,ECILCMSK        LOAD INSTR @ REG FOR EIFINB
         LR    RCC,RIA             PLACE CC AND MASK OVER
         SPM   RCC                 INIT REAL CC = FAKE CC
         AIF   (NOT &$FLOTE).EINOFL1  SKIP IF NOT DOING FL
         LD    F0,ECFPREGS         GET FP REG
         LD    F2,ECFPREGS+8       GET FP REG
         LD    F4,ECFPREGS+16      GET FP REG
         LD    F6,ECFPREGS+24 GET FP REG
.EINOFL1 ANOP
         B     EIFINB              BEGIN MAIN LOOP INTERPRETATION
         SPACE 5
*              DEFAULT PRCB FLAGS
EIDFAULT DC    AL1(0)              ECPRFLG1 DEFAULT
         DC    AL1(ECEM370+ECALNCHK)  ECPRFLG2 DEFAULT
         DC    XL6'0'              ECPRFLG3-ECPRFLG8 DEFAULT
         EJECT
* * * * * * * * * * *  OCX  INTERRUPT  EXITS  * * * * * * * * * * * * *
***********************************************************************
         SPACE 2
EIOC1    EQU   *
         LA    R0,1                SHOW OPERATION INTERRUPT
         B     EIEXITI             EXIT POINT FOR INTERRUPTS
EIOC2    EQU   *
         LA    R0,2                SHOW PRIVILEGED OPERATION
         B     EIEXITI             EXIT POINT FOR INTERRUPTS
EIOC3    EQU   *
         LA    R0,3                EXECUTE INTERRUPT
         B     EIEXITI             EXIT POINT FOR INTERRUPTS
EIOC4    EQU   *
         LA    R0,4                PROTECTION INTERRUPT
         B     EIEXITI             EXIT POINT FOR INTERRUPTS
*EIOC5   EQU   *
*        LA    R0,5                ADDRESSING INTERRUPT
*        B     EIEXITI             EXIT POINT FOR INTERRUPTS
EIOC6A   EQU   *                  NO NEED FOR SEPARATE CASES    CEH
EIOC6    EQU   *
         LA    R0,6                SPECIFICATION INTERRUPT
         B     EIEXITI             EXIT POINT FOR INTERRUPTS
*EIOC7   EQU   *
*        LA    R0,7                DATA EXCEPTION
*        B     EIEXITI             EXIT POINT FOR INTERRUPTS
EIOCA    EQU   *
         LA    R0,10               DECIMAL OVERFLOW
         B     EIEXITI             EXIT POINT FOR INTERRUPTS
         SPACE 5
*              ENTERED WHEN PROGRAM BRANCHES OUT OF RANGE
EIIAOUT  EQU   *
         MVI   ECFLAG1,$ECBRN14    HOPE FOR NORMAL RETURN
         L     R14,ECR14SAV        GET RETURN @, ORIGINAL
         LA    R14,0(R14)          REMOVE LEADING BYTE
         CR    RIA,R14             WAS BRANCH TO THIS ADDR ?
         BE    EIITAILC            YES, PERFORM A NORMAL RETURN       M
         MVI   ECFLAG1,$ECBROUT    WAS ACTUAL BRANCH OUT OF PROG
         LA    R1,EICCBROU         SHOW @ BRANCHED OUT
         NI    ECPRFLG3,ECNOSPI    MAKE SURE SPIE IS OFF FOR SAFETY
         B     EIITIA              GO, HAVE @ STORED, QUIT            M
         EJECT
***********************************************************************
*                                                                     *
*              INTERRUPT HANDLER                                      *
*                                                                     *
***********************************************************************
         SPACE 2
EISPIEXT EQU   *
         USING *,R15
         MVC   ECINTCOD(2),2(R1)   SAVE INTERRUPT CODE
         BR    R14                 RETURN TO OS CONTROL
         DROP  R15                 DROP TEMP REG
         SPACE
         SPACE 5
***********************************************************************
*                   EXIT AND RETURN CODE                              *
***********************************************************************
         SPACE 2
EIEXITI  EQU   *
         STH   R0,ECINTCOD         SAVE INTO INTERRUPT CODE
EISPIERT EQU   *
         MVI   ECFLAG1,0           RESET, NEEDED BY REPLACE MONITOR
         LH    R1,ECINTCOD  NOTE:NEED THIS WHEN ENTERED AT EISPIERT   L
         ALR   R1,R1               DOUBLE FOR HALFWORD INDEX          L
         LH    R1,EICOFFS(R1)      GET OFFSET TO MESSAGE BLOCK
         LA    R1,EICC0(R1)        GET @ OF MESSAGE
EIITIA   EQU   *
         ST    R1,ECERRAD          STORE @ IN ECONTROL
         MVC   ECBSTK(4),ECBCUR    SAVE THE CURRENT BR STK PNTR
         ST    RSTK,ECRSTK         SAVE THE STACK POINTER
        N      RCC,=XL4'3F000000'  REMOVE @ & ILC (WHICH IS WRONG)
         L     RIA,EIRIA          RELOAD ADDR. OF NEXT INSTR.   CEH
         ALR   RCC,RIA             PUT THE @ AND CC TOGETHER
         IC    RIA,EICTB2          GET ILC FROM LAST INST             L
         SLL   RIA,29              SHIFT ILC TO EXTREME LEFT          L
         OR    RCC,RIA             COMPLETE PSW IN RCC                L
         ST    RCC,ECILCMSK        SAVE INTO THE PSW
         SPACE 5
*              THIS SECTION TESTS FOR AN XOPC SPIE BEING SET
*              IF AN INTERRUPT OCCURS AND AN XOPC SPIE HAS NOT BEEN
*              SET ABNORMAL USER TERMINATION IS PERFORMED.  IF A SPIE
*              HAS BEEN SET AND THE INTERPRETER IS NOT ALREADY CATCH-
*              ING AN INTERRUPT, THE SPIE EXIT ADDRESS BECOMES THE
*              ADDRESS OF THE NEXT INSTRUCTION AND EXECUTION CONTINUES
EITSTST  EQU   *
         TM    ECPRFLG3,ECINHDST   TEST IF ALREADY HANDLING AN INTERUPT
         BO    EIITAILC            IF SO, GO AHEAD AND TERMINATE
         TM    ECPRFLG3,ECSPISET   TEST IF CATCHING INTERRUPTS
         BNO   EIITAILC            IF NO SPIE SET, TERMINATE
         LH    R1,ECINTCOD         GET THE INTERRUPT CODE IN A REGISTER
         LA    R1,16(R1)           SHIFT 16 MORE THAN INTRPT CODE
         STC   R1,EISPISFT+3       STORE INTERRUPT CODE IN SHIFT INSTR
         L     R1,ECPRSCDE         GET THE INT CODES TO BE CAUGHT
EISPISFT SLL   R1,$                SHIFT TO SEE IF THIS INT CAUGHT
         LTR   R1,R1               COMPARE SHIFTED REGISTER TO ITSELF
         BNM   EIITAILC            IF RESULT NOT MINUS DO NOT CATCH
         MVC   ECPRIRGS(8),ECREG0  SAVE USER REGS 0 AND 1
         MVC   ECREG0(8),ECPSW     SAVE PSW IN USER REGS 0 AND 1
         L     RIA,ECPRSPIE        PUT SPIE EXIT ADDR FOR BRANCH
         OI    ECPRFLG3,B'01000000' NOW IN INTERRUPT HANDLING STATE
         B     EIFINB              TREAT AS HAVING EXECUTED BRANCH INST
EIITAILC EQU   *
         AIF   (NOT &$FLOTE).EINOFL3  SKIP IF NO FLOATINGS
         STD   F0,ECFPREGS         STORE FP REGS
         STD   F2,ECFPREGS+8       STORE FP REGS
         STD   F4,ECFPREGS+16      STORE FP REGS
         STD   F6,ECFPREGS+24      STORE FP REGS
.EINOFL3 ANOP
         TM    ECFLAG0,$ECSPIEB    DO WE NEED TO UNDO SPIE
         BZ    EIECRET             NO, RETURN
         L     R1,ECPICA           GET PICA ADDR BACK
         $SPIE ACTION=(RS,(1))     RESTORE PREVIOUS XSPIEBLK
         NI    ECFLAG0,255-$ECSPIEA  WE WILL HAVE TO RESPIE
EIECRET  EQU   *
         $RETURN RGS=(R14-R12)
         TITLE '*** EXECUT - MAIN INSTRUCTION FETCH AND DECODING LOOP'
***********************************************************************
*                                                                     *
*                  MAIN INTERPRETER LOOP HEAD                         *
*                                                                     *
*        ALL SUCCESSFUL BRANCHES PASS THROUGH EIFINB, WHERE           *
*        CHECKING FOR ILLEGAL BRANCHES IS DONE.  CHECKING IS          *
*        ALSO DONE FOR TIMER RUNOUT.                                  *
*                                                                     *
*        OTHER INSTRUCTIONS (UNSUCCESSFUL BRANCHES INCLUDED)          *
*        PASS THROUGH EIFIN OR EIFINRR AS APPROPRIATE.                *
*                                                                     *
***********************************************************************
         SPACE 4
EIFINB   EQU   *
*              MOVE INSTRUCTION TO BRANCH STACK
         L     R1,ECBCUR           GET POINTER TO PRES STK SLOT
         USING ECBRSTKD,R1         SET UP TEMPORARY USING
         L     R1,ECBSLINK         GET POINTER TO NEXT AVAILABLE SLOT
         MVC   ECBSTENT+4(L'ECBSTENT-4),ECSTENT+4  MOVE ENTRY OVER
         ST    R1,ECBCUR           SAVE ADDRESS OF THIS SLOT FOR LATER
         DROP  R1                  DROP TEMP REG
         SPACE
*              CHECK IF BRANCH IS LEGAL
         LA    RIA,0(RIA)          REMOVE 1ST BYTE OF BRANCH @
         ST    RIA,EIRIA          SAVE CURRENT INSTR. ADDR.     CEH
         C     RIA,ECFADL          CMPR FOR BELOW LOWEST FAKE
         BL    EIIAOUT             BRANCH IF OUT OF RANGE - ERROR
         C     RIA,ECFADH          CMPR FOR OVER HIGHEST FAKE
         BNL   EIIAOUT             BRANCH IF OUT OF RANGE - ERROR
         AIF   (NOT &$ALIGN).EIFT1 SKIP IF MACHINE REQUIRES ALIGNMENT
         ST    RIA,ECTSAVE         SAVE @: MUST DO CHECK SLOW WAY
         TM    ECTSAVE+3,EIALHALF  DO WE HAVE HALFWORD ALIGN ?
         BO    EIOC6               NO - SPEC. ERROR
         AGO   .EIFT2              SKIP OTHER ALIGN CODE
.EIFT1   ANOP
         LH    R0,0(RIA,RMEM)      QUICK ALIGN CHECK
.EIFT2   ANOP
         SPACE
*              IF TIMER RUNOUT OCCURS, ASSIST SETS ECFLAG1=$ECTIMEX.
*              EXECUT DISCOVERS THIS NEXT TIME BRANCH IS SUCCESSFUL.
         AIF   (&$TIMER EQ 0).EINOTOA  SKIP IF NO TIMER AT ALL
         CLI   ECFLAG1,$ECTIMEX    IS TIMER RUNOUT FLAG SET ?
         BNE   EIFINRR             NO - FETCH AND PROCESS INSTR AT NEW X
                                   BRANCH ADDRESS
*              TIMER RUNOUT HAS OCCURRED - FLAG IT.  ECFLAG1
*              ALREADY SET.
         LA    R1,EICCTIMB         SHOW @ OF OVER TIME MESSAGE
         B     EIITIA              JUMP TO EXIT SECTION               M
         AGO   .EINOTOB
.EINOTOA ANOP
         B     EIFINRR             BRANCH TO FETCH AND PROCESS INSTR
.EINOTOB ANOP
         SPACE 4
***********************************************************************
*                                                                     *
*              HERE BEGINS THE PRIMARY INSTR FETCH AND                *
*              DECODING SECTION.                                      *
*                                                                     *
***********************************************************************
         SPACE 3
*              CHECK FOR EXCEEDING TOTAL INSTRUCTION COUNT --
*
*              CONTROL IS PASSED TO EIFIN AFTER INTERPRETATION OF
*              ALL INSTRUCTIONS EXCEPT SUCCESSFUL BRANCHES AND RR
*              INSTRUCTIONS.  CONTROL IS PASSED TO EIFINRR AFTER
*              RR'S, AND TO EIFINB AFTER SUCCESSFUL BRANCHES.
EIFIN    EQU   *
         L     RIA,EIRIA           RESTORE INSTR @ REG
EIFINRR  EQU   EIFIN              RR NOW MERGES WITH OTHER      CEH
         L     R0,ECILIMT          GET INSTRUCTION COUNTER
         BCT   R0,EIGO             DECREMENT COUNTER
*              COUNTER LIMIT EXCEEDED -- BR TO INTERRUPT ROUTINE
EICNTINT EQU   *
         ST    R0,ECILIMT          RESTORE INSTR LIMIT FOR STATS
         MVI   ECFLAG1,$ECTIMEX    SHOW INSTR LIMIT EXCEEDED
         LA    R1,EICCTIME         GET @ OF TIME MESSAGE
         NI    ECPRFLG3,ECNOSPI    MAKE SURE SPIE IS OFF FOR SAFETY
         B     EIITIA              BR TO EXIT ROUTINE                 M
EIGO     EQU   *
         C     R0,ECPRCMPR         CMPR CLOCK AGAINST USER LIMIT
         BNE   EICLKOK             CONTINUE ON IF NO COUNT LIMIT EXCEED
         TM    ECPRFLG4,ECLKADR    TEST TO SEE IF CLOCK EXIT ADDR GIVEN
         BNO   EICNTINT            IF NO ADDR GIVEN - DO TIMER EXIT
         L     RIA,ECPRCLEA        PREPARE BRANCH TO GIVEN EXIT ADDR
         MVC   ECPRCMPR(4),=F'-1'  DISARM THE CLOCK FROM FURTHER INTRPS
         B     EIFINB              TREAT AS BR INST SINCE CAUSE OF INTR
EICLKOK  EQU   *                   NO CLOCK INTERRUPT HAS OCCURED
         ST    R0,ECILIMT          RESTORE COUNTER
         SPACE 2
*              PRIMARY INSTRUCTION FETCH
         LA    RWK14,0(RIA,RMEM)   OBTAIN PHYSICAL REAL ADDRESS
         L     RSTK,ECSTLINK       OBTAIN ADDRESS OF NEXT STACK SLOT
         STM   RIA,RCC,ECSTIADD    SAVE INSTRUCTION ADDRESS, CC, MASK
         MVC   ECSTINST,0(RWK14)   MOVE 6 BYTES INTO THE NEXT SLOT
         IC    ROP,ECOP            GET OPCODE INTO A REGISTER
         SPACE 2
*              FETCH MAIN TABLE ENTRY BY OPCODE INDEXING
EIEXPEN  EQU   *
         SR    R1,R1               R1 IS ZERO FOR IC
         IC    R1,EIOPCDTB(ROP)    FETCH POINTER TO MAIN TABLE
         SLL   R1,3                MULTIPLY BY 8 FOR MAIN TAB INDEX
         LA    R1,EICONTAB(R1)     GET @ OF CONTROL TABLE ENTRY
         MVC   EICTNTRY(EICTE$L),0(R1)    MOVE TABLE ENTRY TO WORK AREA
         TM    EICTB1,EIEXOPCD     DOES OPCODE TELL ALL ?
         BZ    EICHKF$A            IF YES, BR TO CHK FACILITIES ON
         SPACE 2
*              OPCODE DOES NOT TELL ALL - - - GET TABLE ENTRY
*              FOR EXTENDED OPCODE INSTRUCTION
         L     R1,EIEXTTAB         GET ADDRESS OF TOP SEC TABLE
         MVC   EISHFTIN+3(1),EI#SHIFT(R1) PUT SHIFT # INTO INST.      L
         IC    R2,ECOPEX           GET OPCODE EXTENSION BYTE
*              THE FOLLOWING SHIFT INSTRUCTION WILL BE MODIFIED DURING
*              EXECUTION TO SHIFT THE CORRECT AMOUNT FOR EACH
*              DIFFERENT EXTENDED OPCODE.
EISHFTIN SRL   R2,$                SHIFT FOR INDEX INTO BYTE TABLE
         C     R2,EIMAXIND(R1)     CMPR SHFT VALUE TO MAX
         BH    EIOC1               BR IF OPCODE IS BAD
         IC    R2,EICTE$L(R2,R1)   GET BYTE TABLE ENTRY
         LTR   R2,R2               TEST FOR LEGAL EXTENDED OP CODE
         BZ    EIOC1               BRANCH IF INVALID OPCODE
         LA    R1,0(R2,R1)         GET ADDRESS OF TABLE ENTRY
         MVC   EICTNTRY(EICTE$L),0(R1)  FETCH EXTENDED OPCD TAB ENTRY
         SPACE 2
*              CHECK FOR INSTRUCTION TRACE AND IECF
EICHKF$A EQU   *
         TM    ECPRFLG1,ECPROPON   CHECK IF ANY OPTIONS = ON
         BNZ   EITRIC              BRANCH IF TRACE OR IECF ON
         SPACE 2
*              INCREMENT INSTRUCTION ADDRESS REGISTER
*
*              ** NOTE ** DO NOT CHANGE THE ORDER OF THE NEXT FEW
*              INSTRUCTIONS WITHOUT FIRST SEEING AND MODIFYING THE
*              EX INSTR CODE (EIEX)
EIINCPSW EQU   *
         SR    R2,R2               ZERO FOR IC INST                   L
         IC    R2,EICTB2           GET THE LENGTH OF THE INSTRUCTION
         AR    RIA,R2              INCREMENT INSTRUCTION ADDRESS REG
         SPACE 2
*              CHECK IF OPCODE IS LEGAL ON THE MACHINE
*              PRESENTLY BEING EMULATED
*              NOTE:  THE MASK FOR THE FOLLOWING TM INSTRUCTION WAS
*              INSERTED EARLIER, EITHER AT INITIALIZATION (AS 370)
*              OR WHEN EVER AN XOPC INSTRUCTION IS EXECUTED WHICH COULD
*              CHANGE THE MACHINE EMULATION FLAGS IN THE PRCB
EITSTMSK TM    EICTB1,$            TEST TAB ENTRY FOR VALID OP CODE
         ST    RIA,EIRIA          SAVE FOR RESTORING LATER      CEH
         BZ    EIOC1               BRANCH TO INTER ROUTINE IF INVALID
         SPACE 2
*              CHECK IF THIS IS A PRIVILEGED INSTRUCTION
EIOPOK   EQU   *
         TM    EICTB1,EIPRIVOP     IS THIS A PRIV INSTR ?
         BO    EICHKST             IF YES, BRANCH TO CHECK STATE
         SPACE 2
*              THE FOLLOWING SECTION DECODES THE SECOND BYTE OF THE
*              INSTRUCTION AND PERFORMS A MULTI-WAY BRANCH TO GET
*              THE NEEDED INFORMATION IN THE PROPER PLACES
*              EXPECTED LATER IN THE SPECIAL ROUTINES.
EI2BDECD EQU   *
         CLI   ECOP,X'E1'          CHECK FOR ONLY REGISTER XDUMP
         BE    EIXIOSR             SKIP EXTRANEOUS DECODEING FOR XDUMPR
         SR    R7,R7               CLEAR BYTE REGISTER
         IC    R7,ECI2             GET 2ND BYTE OF INSTR
         TM    EICTB3,EIB2IORL     TEST TO DETERMINE DECODING NEEDED
         BZ    EIRRX4              2 REGS - MULT BY 4 FOR INDEX
         BO    EI2BMERG            IF IMMED OR LENGTH, DONE
         SPACE 2
*              PROCESS 2ND BYTE AS LL X 1
         LR    R9,R7               COPY 2ND BYTE OF INSTR
         SRL   R7,4                R7 = L1
         N     R9,=XL4'0F'         R9 = L2
         B     EI2BMERG            BRANCH TO MERGE BACK
         SPACE 2
*              PROCESS 2ND BYTE AS RR X 4
*              (EVEN/ODD REGISTER CHECKING DONE ALSO)
EIRRX4   EQU   *
         SPACE 2
*              THIS SECTION TESTS FOR EVEN ODD REGISTERS WHEN
*              THEY ARE NEEDED IN AN INSTRUCTION.
         MVC   *+7(1),EICTB5       MOVE TABLE BYTE 5 INTO TM INST
         TM    ECR1R2,$            TEST EVEN/ODD REG ** MASK MOVED IN**
         BNZ   EIOC6               IF RESULT NOT ZERO SOC 6 INT
EIRRX4A  EQU   *
         LR    R9,R7               COPY 2ND BYTE OF INSTR
         N     R9,=F'15'           REMOVE 1ST REG, LEAVING 2ND ONLY
         SLL   R9,2                GET R2 FIELD*4 FOR INDEXING
         SRL   R7,4                GET R1 FIELD*4
         SLL   R7,2                FOR INDEXING
         L     R8,ECREGS(R7)       GET VALUE IN USER REG (R1)
         L     R10,ECREGS(R9)      GET VALUE IN USER REG (R2)
         SPACE 2
***********************************************************************
*                                                                     *
*        AT THIS POINT IN THE DECODING, THE FOLLOWING INFORMATION     *
*        IS CONTAINED IN REGISTERS R7 - R10:                          *
*                                                                     *
*      --2 REGS SPECIFIED IN INSTR+1                                  *
*                                                                     *
*              R7 = # OF THE 1ST REG MULT BY 4                        *
*              R8 = CONTENTS OF THE 1ST REG                           *
*              R9 = # OF THE 2ND REG MULT BY 4                        *
*             R10 = CONTENTS OF THE 2ND REG                           *
*                                                                     *
*      --2 LENGTHS OR IMMED FIELDS SPEC IN INSTR+1                    *
*                                                                     *
*              R7 = THE 1ST LENGTH OR IMMED FIELD                     *
*              R8 = UNUSED                                            *
*              R9 = THE 2ND LENGTH OR IMMED FIELD                     *
*             R10 = UNUSED                                            *
*                                                                     *
*      --1 LENGTH OR IMMED FIELD SPEC IN INSTR+1                      *
*                                                                     *
*              R7 = THE LENGTH OR IMMED FIELD                         *
*              R8 = UNUSED                                            *
*              R9 = UNUSED                                            *
*             R10 = UNUSED                                            *
*                                                                     *
***********************************************************************
         SPACE 2
*              MERGE BACK AFTER 2ND BYTE DECODING -- CHECK IF
*              THIS IS AN RR INSTR; IF SO, BRANCH TO PROCESS
EI2BMERG EQU   *
         TM    EICTB1,EIRR         IS THIS AN RR INSTR ?
         BNO   EI2HDECD            IF NOT, BR TO DECODE 2ND HALFWORD
         LH    R1,EICTDISP         GET DISP TO SPECIAL ROUTINE
         B     EISPEJMP(R1)        BRANCH TO SPECIAL ROUTINE
         SPACE 2
*              DECODE 2ND HALFWORD OF THE INSTRUCTION.  INFORMATION
*              IS PUT WHERE EXPECTED LATER.  ADDRESS IS CHECKED FOR
*              ALIGNMENT ERROR.
EI2HDECD EQU   *
         LH    RWK0,ECBD           LOAD 1ST B1D1 IN WORK REG FOR INSUB
         BAL   RLINK,EIBASDSP      HAVE INSUB EVALUATE B1D1
         LR    RAD1,RWK0           COPY ADDR INTO 1ST ADDR REG
         TM    EICTB3,EIH2NODX     CHECK IF INDEX REG NEEDED
         BO    EINODX              BRANCH IF B/D ONLY
         LTR   R9,R9               TEST IF INDEX REG = 0
         BZ    EINODX              BRANCH IF ZERO
         LA    RAD1,0(RAD1,R10)    ZERO OUT HIGH ORDER BYTE
         SPACE 2
*              THIS SECTION CHECKS FOR AND PERFORMS OPERAND ALIGNMENT
*              CHECKING IF NEEDED
EINODX   EQU   *
         TM    ECPRFLG2,ECALNCHK   IS ALIGNMENT CHECKING = ON ?
         BNO   EINOCHK             BRANCH IF NOT
         MVC   EITSMK+1(1),EICTB4    MOVE MASK INTO TM INSTR
         STC   RAD1,EIWORK         ST LOW ORDER BYTE OF @ IN WORK AREA
EITSMK   TM    EIWORK,$            TEST FOR ALGN ERR **MASK MOVED IN**
         BNZ   EIOC6A              BRANCH & RESET RIA ON ALGN ERROR   L
         SPACE 2
*              CHECK 1ST OPRND ADDR FOR PROPER RANGE AND
*              STORAGE MODIFICATION.
EINOCHK  EQU   *
         MVC   EIWORK(1),EICTB3   STORE CONTROL BYTE IN WORK  CPP
         TM    EICTB1,EINOCNOW     DO WE CHECK MOD STOR RANGE NOW
         BNO   EI2HEND             BRANCH IF NOT
         IC    R2,EICTB6           GET MOD STORE LENGTH BYTE
         LTR   RWK0,R2             GET LENGTH IN RIGHT REG
         BNZ   EIHAVLEN            BRANCH IF RWK0 HAS LENGTH
         LA    RWK0,1(R7)          GET LENGTH FROM THE INSTR
EIHAVLEN EQU   *
         LR    RWK1,RAD1           COPY ADDR TO BE CHECKED
         BAL   RLINK,EIMSFCHK      BR TO ADDR CHECKING ROUTINE
         SPACE 2
***********************************************************************
*                                                                     *
*        AT THIS POINT IN THE DECODING PROCESS, THE FOLLOWING         *
*        INFORMATION IS CONTAINED IN THE SPECIFIED REGISTERS:         *
*                                                                     *
*        (NOTE:  NO RR-TYPE INSTRS IF HERE)                           *
*                                                                     *
*          R7 - SAME AS IN COMMENT BLOCK ABOVE                        *
*          R8 - SAME AS IN COMMENT BLOCK ABOVE                        *
*          R9 - SAME AS IN COMMENT BLOCK ABOVE                        *
*         R10 - SAME AS IN COMMENT BLOCK ABOVE                        *
*        RAD1 - CONTAINS THE CALCULATED RELATIVE ADDRESS FROM THE     *
*               2ND HALFWORD OF THE INSTR (B1-D1  OR  I1-B1-D1)       *
*                                                                     *
*        NOTE:  RAD1 IS RELOCATED TO REAL IFF THIS IS NOT A BRANCH    *
*               INSTRUCTION.                          ---             *
*                                                                     *
***********************************************************************
         SPACE 2
EI2HEND  EQU   *
         TM    EICTB2,EILEN6       IS INSTR LENGTH = 6 ?
         BO    EI3HDECD            BRANCH IF YES
         TM    EICTB3,EIBRINST     IS THIS A BRANCH INSTRUCTION ?
         BO    EI4JUMP             YES - DON'T RELOCATE RAD1
         ALR   RAD1,RMEM           RELOCATE ADDRESS TO REAL
         AIF   (&$S370 NE 2).EITRX SKIP IF ON A REAL 370
*
*              IF FAKING ALIGNMENT IS NECESSARY, DO IT !
*
         TM    ECPRFLG2,ECALNCHK   IS ALIGNMENT CHECKING ON ?
         BZ    EI4JUMP             NO - SKIP FAKING CODE
         TM    EICTB4,EIALDOBL     DOES THIS INSTR NEED ALIGN ?
         BZ    EI4JUMP             NO - SKIP FAKING CODE
         CLI   ECOP,X'90'         IS THIS A STM?                CPP
         BE    EI4JUMP            IF YES SKIP FAKING CODE       CPP
         CLI   ECOP,X'98'         IS THIS AN LM?                CPP
         BE    EI4JUMP            IF YES, SKIP FAKING CODE      CPP
         CLI   ECOP,X'44'         IS THIS AN EX?                CPP
         BE    EI4JUMP            IF YES, SKIP FAKING CODE      CPP
         LTR   RWK14,RAD1          SAVE FOR LATER, SET CC ^= 0
         MVC   EIDUBLWD(8),0(RAD1) MOVE A MAX OF 8 BYTES OVER
         LA    RAD1,EIDUBLWD       LOAD @ OF ALIGNED FIELD
.EITRX   ANOP
EI4JUMP  EQU   *
         LH    RWK1,EICTDISP       GET DISP FOR BR TO SPECIAL ROUTINE
         B     EISPEJMP(RWK1)      BRANCH TO SPECIAL ROUTINE
         AIF   (&$S370 NE 2).EITRXA  SKIP IF ON A REAL 370
EIDUBLWD DC    D'0'                USED FOR FAKING 360 ALIGNMENT
.EITRXA  ANOP
         SPACE 2
*              THIS SECTION DECODES THE THIRD HALFWORD OF THE 6 BYTE
*              SS-TYPE INSTRUCTION, AND THEN BRANCHES TO A SPECIAL
*              ROUTINE TO COMPLETE PROCESSING.
EI3HDECD EQU   *
         LH    RWK0,ECB2D2         GET 3RD HALFWORD OF THE INSTR
         BAL   RLINK,EIBASDSP      CALCULATE RELATIVE ADDR (B2D2)
         LR    RAD2,RWK0           COPY ADDR INTO 2ND ADDR REG
         SPACE 2
*              CHECK 2ND OPRND ADDRESS FOR PROPER RANGE
         TM    ECFLAG0,$ECPROT     IS ABSOLUTE PROTECT FLAG ON ?
         BZ    EI3HEND             IF NOT, BRANCH AROUND INSUB CALL
         CLI   ECOP,X'E0'          IS THIS AN X-PSEUDO INSTR ?
         BE    EI3HEND             YES - DON'T CHECK THIS ADDRESS
         LR    RWK1,RAD2           COPY ADDRESS FOR CHECKING
         LR    RWK0,R7             ASSUME ONE LENGTH FOR OPERANDS
         TM    EICTB3,EIB2IORL     TEST TO FIND LENGTH TYPE
         BO    *+6                 IF ONE LENGTH BRANCH AROUND
         LR    RWK0,R9             GET RIGHT LENGTH
         ALR   RWK0,RWK1           GET @ OF HIGHEST BYTE ACCESSED
         BAL   RLINK,EIFTHCHK      CHECK ADDR FOR FETCH RANGE
***********************************************************************
*                                                                     *
*        REGISTER USAGE FOR SS-TYPE INSTRUCTIONS IS AS FOLLOWS:       *
*                                                                     *
*          R7 - CONTAINS EITHER:                                      *
*              A.  THE LENGTH OR IMMED FIELD AS A FULL BYTE, OR       *
*              B.  THE 1ST OF 2 LENGTHS OR IMMED FIELDS               *
*          R8 - IS UNUSED                                             *
*          R9 - IS EITHER UNUSED OR CONTAINS THE 2ND OF 2 LENGTHS OR  *
*               IMMEDIATE FIELDS                                      *
*        RAD1 - CONTAINS THE 1ST RELATIVE ADDRESS (B1D1)              *
*        RAD2 - CONTAINS THE 2ND RELATIVE ADDRESS (B2D2)              *
*                                                                     *
*        NOTE: THE ADDRESSES IN RAD1 AND RAD2 ARE RELOCATED FOR       *
*              ASSIST.                        ---                     *
*                                                                     *
***********************************************************************
         SPACE 2
EI3HEND  EQU   *
         AR    RAD1,RMEM           RELOCATE 1ST FAKE @ TO REAL
         AR    RAD2,RMEM           RELOCATE 2ND FAKE @ TO REAL
         MVC   EIQSS(2),ECOP       MOVE OPCODE & LENGTH(S) INTO INSTR
         LH    RWK1,EICTDISP       GET DISP FOR BR TO SPECIAL ROUTINE
         B     EISPEJMP(RWK1)      BRANCH TO SPECIAL ROUTINE
         SPACE 1
EIRIA    DC    F'0'                SAVE AREA FOR INSTRUCTION ADDR
         SPACE 5
EISPEJMP EQU   *                   USED TO CALCULATED JUMP ADDRESS
*
*------------> THIS MARKS THE END OF THE PRIMARY FETCH/DECODE LOOP
         TITLE '*** EXECUT - CODE CALLED FROM MAIN FETCH/DECODE LOOP'
*              THE FOLLOWING CODE COMPRISES SOME OUT-OF-LINE
*              ROUTINES BRANCHED TO FROM THE ABOVE PRIMARY FETCH
*              AND DECODING LOOP:
         SPACE 2
*              CHECK STATE  ----  PRIV OPCODE WAS ENCOUNTERED
EICHKST  EQU   *
         TM    ECPRFLG2,ECSUPRST   ARE WE IN SUPERVISOR STATE ?
         BO    EI2BDECD            IF IN SUPER STATE BRANCH TO DECODE
         B     EIOC2               IF NOT IN SUPER STATE SOC 2 FLAGGED
         SPACE 2
*              THIS SECTION PROCESSES INSTRUCTION TRACE AND
*              COUNTING FACILITIES
         SPACE 2
*              INCREMENT THE INSTRUCTION EXECUTION COUNT FACILITY
*              COUNTERS
EITRIC   EQU   *
         TM    ECPRFLG1,ECPRIECF   IS THE IECF ACTIVE NOW?
         BNO   EITRICB             IF NOT ON GO SEE IF TRACE IS ON
         C     RIA,ECPRICH         CMPR INSTR @ WITH HIGH ADDR LIMIT
         BH    EITRICB             BRANCH IF OUT OF RANGE
         C     RIA,ECPRICL         CMPR INSTR @ WITH LOW ADDR LIMIT
         BL    EITRICB             BRANCH IF OUT OF RANGE
         LR    RWK1,RIA            MOVE INSTR @ REG TO WORKABLE REG
         S     RWK1,ECFADL         SUBTRACT FOR INSTRUCTION OFFSET
         L     R7,ECPRICA          GET BEGINNING ADDRESS OF COUNT AREA
         LH    RWK14,0(RWK1,R7)    LOAD THE PROPER HALFWORD COUNTER
         LA    RWK14,1(RWK14)      INCREMENT THE INSTRUCTION COUNTER
         STH   RWK14,0(RWK1,R7)    RESTORE THE INCREMENTED COUNTER
*              PROCESS ---->  TRACE FACILITY
EITRICB  EQU   *
         TM    ECPRFLG1,ECPRTRCE   IS THE TRACE FACILITY ON
         BNO   EIINCPSW            BRANCH IF FACILITY NOT ON
         C     RIA,ECPRTRAH        COMPARE INSTR @ WITH HIGH LIMIT
         BH    EIINCPSW            BRANCH IF OUT OF RANGE
         C     RIA,ECPRTRAL        CMPR INSTR @ WITH LOW LIMIT
         BL    EIINCPSW            BRANCH IF OUT OF RANGE
         MVC   EITRMSIN+4(10),EIBLANKS   BLANK OUT INSTR AREA
         XHEXO RIA,EITRMSAD        CONVERT INSTR @ TO HEX
         MVC   EITRMSAD(2),EIBLANKS      BLANK OUT 1ST TWO BYTE OF @
         LM    R0,R1,ECSTCCPM      FETCH INSTR FROM INSTR STACK
         SLDL R0,16                RR AND RX CODE IN REG 0
         XHEXO R0,EIWORK           CONVERT INSTR TO HEX (4 BYTES)
         TM    ECSTINST,EISSINST   IS THIS AN SS INSTR ?
         BNO   EINOTSS             BRANCH IF NOT
         XHEXO R1,EIWORK+8         CONVERT INSTR TO HEX (LAST 2 BYTES)
EINOTSS  EQU   *
         LA    RWK1,EITRMSIN       GET @ OF HEX INSTR
         BAL   R2,EIMOVINS         MOVE HEX INSTR INTO FORMAT
         $PRNT EITRMSG,EITRMSGL,EICNTEXC  PRINT INSTR FOR TRACE AND BR X
                                          OUT IF LINE COUNT EXCEEDED
         B     EIINCPSW            RETURN TO MAIN PROGRAM LOOP
*              WORK AREAS USED BY THE TRACE FACILITY
EITRMSG  DC    C' TRACE-->   INSTR ADDR:'  TRACE MESSAGE
EITRMSAD DC    8C' '               TRACE MESSAGE
         DC    C'   INSTR:  '       TRACE MESSAGE
EITRMSIN DC    14C' '              TRACE MESSAGE
EITRMSGL EQU   *-EITRMSG           LENGTH OF THE TRACE MESSAGE
EIWORK   DC    16C' '              WORK AREA
EIBLANKS DC    10C' '              BLANKS USED IN TRACE
         TITLE '*** EXECUT - RR PROCESSING ROUTINES'
***********************************************************************
*                                                                     *
*              RR INSTRUCTION PROCESSING ROUTINES                     *
*                                                                     *
***********************************************************************
         SPACE 5
*        ********** NORMAL RR INSTRUCTION PROCESSING **********
*
*              2 ENTRIES TO SEQUENCE -->
*              LR   SEPARATE SINCE CURRENT CC NOT CHANGED
*              NR,CLR,OR,XR,CR,AR,SR,ALR,SLR,LPR,LNR,LCR,LTR    NORMAL
         SPACE 1
EILR     EQU   *                   LOAD REGISTER INST
         ST    R10,ECREGS(R7)      LOAD R1 WITH VALUE FROM R2
         B     EIFINRR             RETURN FOR NEXT INSTR
         SPACE 1
EINORMRR EQU   *                   NORMAL RR INSTRS
         STC   ROP,EIQRR           PLACE ACTUAL OPCODE INTO INSTR
EIQRR    LR    $+R8,R10            EXECUTE RIGHT INSTRUCTION           X
                                   ***** OPCODE MOVED IN *****
         ST    R8,ECREGS(R7)       SAVE RESULT IN OPERAND LOCATION
         BAL   RCC,EIFINRR         GET CC, RETURN FOR NEXT INSTR
         SPACE 2
*              THIS SECTION PROCESSES THE BALR INSTRUCTION
EIBALR   EQU   *
         LR    RWK1,RIA            COPY ADDR NEXT INSTR OVER
         N     RCC,=XL4'3F000000'  LEAVE ONLY CC-PM IN RCC
         AL    RCC,=XL4'40000000'  ADD ILC INTO PSW BEING BUILT
         ALR   RWK1,RCC            NOW HAVE ILC-CC-PM-IA FIELDS
         ST    RWK1,ECREGS(R7)     FAKE REGISTER GETS BUILT PSW
         LTR   R9,R9               TEST FOR NO BRANCHING R2 = 0
         BZ    EIFINRR             NO BRANCH TREAT AS REG RR GET NEXT  X
                                                 INSTRUCTION
         LR    RIA,R10             PUT BRANCH ADDRESS IN PROPER REG
         B     EIFINB              PROCESS SUCCESSFUL BRANCH
         SPACE 2
*              BRANCH ON COUNT REGISTER  (BCTR)
EIBCTR   EQU   *
         BCTR  R8,0                DECREMENT VALUE IN FAKE R1
         ST    R8,ECREGS(R7)       RESTORE VALUE TO FAKE REG
         LTR   R9,R9               IS R2 = 0 ?
         BZ    EIFINRR             IF ZERO, NO BRANCH
         LTR   R8,R8               IS DECREMENTED VALUE = 0 ?
         BZ    EIFINRR             IF ZERO, NO BRANCH
         LR    RIA,R10             PUT BRANCH @ IN RIGHT REG
         B     EIFINB              PROCESS SUCCESSFUL BRANCH
         SPACE 2
*              BRANCH ON CONDITION REGISTER (BCR)
EIBCR    EQU   *
         LTR   R9,R9               IS R2 = 0 ?
         BZ    EIFINRR             IF ZERO, NO BRANCH
         SLL   R7,2                GET MASK IN RIGHT SPOT
         STC   R7,EIQBCR+1         STORE MASK INTO INSTR
         LR    RWK1,RIA            COPY @ OF NEXT SEQ INSTR
         LR    RIA,R10             PUT BRANCH ADDR IN RIGHT REG
         SPM   RCC                 SET REAL CC = FAKE CC
EIQBCR   BC    $,EIFINB            *** MASK STORED IN ***
         LR    RIA,RWK1            RESTORE INSTR @ REG
         B     EIFINRR             BRANCH FAILED
         SPACE 1
*              CHECK FOR FLOATING-POINT INSTR OR EXT FLOATING POINT
         AIF   (&$FLOTEX).EIXFPRR  GO GENER CODE IF XFP IS OK
EIXFPRR  EQU   EIOC1               NOTE XFP INVAL OP IF NOT ALLOWED
         AIF   (&$FLOTE).EIFPRR    GO GENERATE IF FLOAT PNT INST OK
EIFPRR   EQU   EIOC1               NOTE NOT ALLOWING FLOATINGS
         AGO   .EIFPRR2
.EIXFPRR ANOP
EIXFPRR  EQU   *                   CODE FOR XFP SAME AS FOR REGULAR FP
.EIFPRR  ANOP
         SPACE 2
*              RR FLOATING POINT INSTRUCTIONS EXECUTED
EIFPRR   EQU   *                   FLOATING-PNT RR'S ENTER HERE
         SPM   RCC                 SET OUR CC SAME AS USER'S
         EX    R0,ECOP             EXECUTE ACTUAL INSTR FROM THE STACK
         BAL   RCC,EIFINRR         GET CC AND RETURN FOR NEXT INSTR
.EIFPRR2 ANOP
         SPACE 2
*              THE FOLLOWING CODE PROCESSES THE CLCL, MVCL
*              INSTRUCTIONS
*
*              ADDRESS CHECKING CODE FOR CLCL AND MVCL
EILONG   EQU   *
         L     RWK0,ECREGS+4(R7)   GET LENGTH VALUE OF REG 2 PAIR 1
         N     R8,EILONGMK         ZAP OUT UPPER BYTE OF ADDRESS
         N     RWK0,EILONGMK       ZAP OUT UPPER BYTE OF LENGTH
         BZ    EILONG1             IF LENGTH = 0 DON'T CHECK ADDRESS
         MVC   EIWORK(1),EICTB3    STORE CONTROL BYTE IN WORK AREA
         LR    RWK1,R8             COPY ADDRESS TO BE CHECKED
         BAL   RLINK,EIMSFCHK      BRANCH TO ROUTINE CHECK FIRST @
         SPACE 2
*              FIRST ADDRESS IS OKAY ---  CHECK THE SECOND
EILONG1  EQU   *
         L     RWK0,ECREGS+4(R9)   GET VALUE (LENGTH) OF 2ND REG PAIR 2
         N     R10,EILONGMK        ZAP OUT UPPER BYTE OF SECOND ADDRESS
         N     RWK0,EILONGMK       ZAP OUT UPPER BYTE OF SECONG LENGTH
         BZ    EILONG2             IF LENGTH 0 DON'T CHECK ADDRESS
         IC    RWK1,EICTB3         GET CONTROL BYTE
         SLL   RWK1,2              SHIFT BECAUSE WOKING ON SECOND OPRND
         STC   RWK1,EIWORK         PUT TAB ENTRY IN INSUB WORK AREA
         LR    RWK1,R10            PUT ADDR WHERE INSUB EXPECTS IT
         BAL   RLINK,EIMSFCHK      BRANCH TO INSUB CHECK 2ND ADDRESS
         SPACE 2
*              BOTH ADDRESSES ARE OK  --- RELOCATE THEM AND PERFORM
*              THE APPROPRIATE COMMAND
EILONG2  EQU   *
         ALR   R8,RMEM             RELOCATE 1ST ADDRESS TO REAL ADDRESS
         ALR   R10,RMEM            RELOCATE 2ND ADDRESS TO ACTUAL
         SPACE 2
         AIF   (&$S370 NE 1).EILONG1    SKIP IF NOT ON REAL 370
         STC   ROP,EIQLONG         STORE OPCODE IN INSTRUCTION
         LR    RWK1,R9             SAVE SECOND OPERAND REG NUMBER
         LR    RWK0,RMEM           SAVE RELOCATION REGISTER
         L     R9,ECREGS+4(R7)     GET LENGTH OF FIRST OPERAND
         L     R11,ECREGS+4(RWK1)  GET LENGTH OF SECOND OPERAND
EIQLONG  CLCL  R8,R10              **** OPCODE MOVED IN DURING EXEC***
         BALR  RCC,0               PICK UP THE CONDITION CODE
         SLR   R8,RWK0             DE-RELOCATE FINAL ADDRESSES
*              *** THE INSTRUCTIONS ON EITHER SIDE OF THIS COMMENT
*              *** BLOCK ARE USING RWK0 INSTEAD OF RMEM DUE TO
*              *** TEMPORARY REGISTER SHIFTING *****
         SLR   R10,RWK0            DE-RELOCATE FINAL ADDRESSES
         N     R8,EILONGMK         ZAP UPPER BYTE OF ADDRESS REG
         N     R10,EILONGMK        ZAP UPPER BYTE OF ADDRESS REGISTER
         ST    R8,ECREGS(R7)       PUT REGISTERS BACK INTO CORE
         ST    R9,ECREGS+4(R7)     PUT REGISTERS BACK INTO CORE
         ST    R10,ECREGS(RWK1)    PUT REGISTERS BACK INTO CORE
         ST    R11,ECREGS+4(RWK1)  PUT REGISTERS BACK INTO CORE
         LR    RMEM,RWK0           RELOAD RELOCATION REGISTER
         B     EIFINRR            GET NEXT INSTR                PSU.
         AGO   .EILONG2
.EILONG1 ANOP
         SPACE 2
*              CHECK WHICH INSTRUCTION TO SIMULATE (MVCL OR CLCL)
         LA    RWK14,1             SET UP INCREMENT REGISTER
         IC    RWK1,ECREGS+4(R9)   GET PAD BYTE FROM INSTR
         STC   RWK1,EIPAD          STORE PAD BYTE IN WORK AREA
         L     RWK1,ECREGS+4(R7)   GET 1ST OPERAND LENGTH
         L     R2,ECREGS+4(R9)     GET SECOND OPERAND LENGTH
         N     RWK1,EILONGMK       ZAP OUT HIGH ORDER BYTE LENGTH 1
         N     R2,EILONGMK         ZAP OUT HIGH ORDER BYTE LENGTH 2
         CLI   ECOP,X'0E'          IS THIS AN MVCL COMMAND
         BE    EIMVCL              IF SO BRANCH TO ROUTINE
         SPACE 2
*              CODE FOR THE CLCL COMMAND
EICLCL   EQU   *
         LTR   R2,R2               TEST SECOND LENGTH = 0?
         BZ    EICLCL6             BRANCH IF SECOND LENGTH 0
         LTR   RWK1,RWK1           TEST 1ST LENGTH = 0 ?
         BZ    EICLCL2             YES, BRANCH TO USE PAD AND OPRND 2
EICLCL1  EQU   *
         CLC   0(1,R8),0(R10)      COMPARE A CHARACTER FROM EACH FIELD
         BNE   EICLCL5             IF NOT EQUAL WE ARE DONE BRANCH
         AR    R10,RWK14           INCREMENT POINTERS
         AR    R8,RWK14            INCREMENT POINTERS
         BCT   RWK1,EICLCL3        DECREMENT 1ST LENGTH - BRANCH ^= 0
         B     EICLCL7             LENGTH = 0, BRANCH INTO PAD LOOP
EICLCL2  EQU   *
         CLC   EIPAD(1),0(R10)     COMPARE PAD TO OPERAND 2
         BNE   EICLCL5             IF NOT EQUAL WE ARE DONE -- BRANCH
         AR    R10,RWK14           INCREMENT OPERAND 2 POINTER
EICLCL7  EQU   *
         BCT   R2,EICLCL2          DECREMENT 2ND COUNT BR IF ^= 0
         B     EICLCL5             IF LENGTH = 0 OPRNDS = WE'RE DONE
EICLCL3  EQU   *
         BCT   R2,EICLCL1          DECREMENT 2ND LENGTH BR IF ^=0
EICLCL4  EQU   *
         CLC   0(1,R8),EIPAD       COMPARE FIRST OPERAND AND PAD CHAR
         BNE   EICLCL5             IF NOT = WE ARE DONE BRANCH
         AR    R8,RWK14            INCREMENT POINTER
         BCT   RWK1,EICLCL4        DECREMENT LENGTH, BRANCH IF ^= 0
EICLCL5  EQU   *
         BAL   RCC,EILONG5         CAPTURE CONDITION CODE AND RETURN
EICLCL6  EQU   *
         LTR   RWK1,RWK1           FIRST LENGTH = 0?
         BNZ   EICLCL4             NO, USE 1ST OPRND AND PAD
         BAL   RCC,EILONG5         GET CC (=0) AND RETURN
         SPACE 2
*              CODE FOR THE MVCL COMMAND
EIMVCL   EQU   *
         LR    RWK0,RWK1           ASSUME FIRST LENGTH SMALLEST
         CR    RWK1,R2             COMPARE THE LENGTHS
         BALR  RCC,0               CAPTURE THE CC
         BL    *+6                 IF 1ST LENGTH LOWER, BRANCH
         LR    RWK0,R2             2ND LENGTH MUST BE SMALLER
         LTR   RWK0,RWK0           IS SMALLEST LENGTH = 0?
         BZ    EIMVCL3             IF SMALLER = 0, BRANCH
         SPACE 2
*              FOLLOWING CODE CHECKS FOR DESTRUCTIVE OVERLAP
         CR    R8,R10              IS FIRST FIELD AFTER 2ND
         BNH   EIMVCL1             IF NO OVERLAP, BRANCH
         LR    RWK14,R10           COPY OVER 2ND ADDRESS
         LA    RWK14,0(R2,RMEM)    COMPUTE HIGHEST @, RELOCATED + 1
         BCTR  RWK14,0             COMPUTE HIGHEST ADDRESS
         CR    R8,RWK14            IS 1ST FIELD AFTER END OF SECOND
         BNL   EIMVCL1             YES -- NO OVERLAP, SO BRANCH
         TM    *+1,1               SET CC = 3
         BAL   RCC,EILONG5         GET CC AND RETURN
         SPACE 2
EIMVCL1  EQU   *
         SR    RWK1,RWK0           DECREMENT LENGTH BY SMALLEST
         SR    R2,RWK0             DECREMENT LENGTH BY SMALLEST
         LA    RWK14,1             LOAD INCREMENT REGISTER
EIMVCL2  EQU   *
         MVC   0(1,R8),0(R10)      MOVE 1 BYTE !!!!!!
         AR    R8,RWK14            INCREMENT POINTER BY 1
         AR    R10,RWK14           INCREMENT POINTER BY 1
         BCT   RWK0,EIMVCL2        DECREMENT LENGTH, ^= 0 BRANCH
EIMVCL3  EQU   *
         LTR   RWK1,RWK1           DO WE NEED PADDING
         BZ    EILONG5             NO --- DONE, SO BRANCH
EIMVCL4  MVI   0(R8),$             MOVE PAD TO FIRST OPERAND
         AR    R8,RWK14            INCREMENT POINTER BY 1
         BCT   RWK1,EIMVCL4        DECREMENT LENGTH, ^= 0 BRANCH
         SPACE 2
EILONG5  EQU   *
         LA    RWK14,ECREGS(R7)    GET ADDRESS OF 1ST REG PAIR
         XC    5(3,RWK14),5(RWK14) ZAP LOWER PART OF LENGTH IN CORE
         O     RWK1,4(,RWK14)      PUT UPPER BYTE BACK INTO USER REG
         LA    RWK14,ECREGS(R9)    GET ADDR OF SECOND REGISTER PAIR
         XC    5(3,RWK14),5(RWK14) ZAP LOWER PART OF LENGTH IN CORE
         O     R2,4(,R2)           PUT UPPER BYTE BACK INTO REGISTER
*              OPERATION COMPLETE ----- RESTORE REGISTERS AND RETURN
         SLR   R8,RMEM             DE-RELOCATE FINAL ADDRESSES
         SLR   R10,RMEM            DE-RELOCATE FINAL ADDRESSES
         N     R8,EILONGMK         ZAP UPPER BYTES OF ADDRESS REGS
         N     R10,EILONGMK        ZAP UPPER BYTES OF ADDRESS REGS
         ST    R8,ECREGS(R7)       PUT REGISTERS BACK INTO CORE
         ST    RWK1,ECREGS+4(R7)   PUT REGISTERS BACK INTO CORE
         ST    R10,ECREGS(R9)      PUT REGISTERS BACK INTO CORE
         ST    R2,ECREGS+4(R9)     PUT REGISTERS BACK INTO CORE
         SR    R2,R2               RESTORE R2 AS A BYTE REGISTER
         B     EIFINRR            RETURN FOR NEXT INSTR.        CEH
EIPAD    EQU   EIMVCL4+1           MVCL/CLCL PAD BYTE IS MOVED HERE
.EILONG2 ANOP
EILONGMK DC    0F'0',XL4'00FFFFFF' USED TO CLEAR UPPER BYTE OF REGS
         SPACE 2
*              THE FOLLOWING CODE PROCESSES SET PROGRAM MASK
EISPM    EQU   *
         L     RCC,ECREGS(R7)      PLACE SPECIFIED REG INTO CC REG
         SPM   RCC                 SET REAL CC-PM TO FAKE CC-PM
         B     EIFINRR             RETURN FOR NEXT INSTRUCTION
         SPACE 1
*              THESE TWO PRIVILEGED INSTRUCTIONS ARE NOT IMPLEMENTED
*               AT THE PRESENT TIME.  THE HOOKS ARE PROVIDED HOWEVER,
*              IF IT SHOULD BECOME POSSIBLE TO IMPLEMENT THEM IN THE
*              FUTURE
EISSK    EQU   EIOC2
EIISK    EQU   EIOC2
         SPACE 2
*              THE FOLLOWING CODE PROCESSES THE SVC INSTRUCTION
*              CONTROL IS PASSED HERE FROM THE MAIN DECODONG LOOP
*              WHEN AN SVC OPCODE IS ENCOUNTERED.  AT THIS POINT
*              REGISTER 7 CONTAINS THE SECOND BYTE OF THE INSTRUCTION
*              AND REGISTER ROP CONTAINS THE INSTRUCTION OPCODE.  THIS
*              INSTRUCTIONS IS PRESENTLY FLAGGED AS AN OC2 EXCEPTION.
*                 IN THE FUTURE, CODE MAY BE PLACED HERE TO ACTUALLY
*              PERFORM OR SIMULATE THE SCV.  IT SHOULD BE NOTED THAT
*              REGISTERS RWK0, RWK1, R8, R9, R10 AND R14 ARE AVAILABLE
*              FOR USE HERE.  R2 CAN ALSO BE USED AS A BYTE REGISTER OR
*              RESTORED TO A BYTE REGISTER IF USED FOR ANOTHER PURPOSE.
*              NO OTHER REGISTERS SHOULD BE USED HERE.
*                FOLLOWING ANY FUTURE SVC PROCESSING, CONTROL MUST BE
*              PASSED TO LABEL EIFINRR TO FETCH AND PROCESS THE NEXT
*              INSTRUCTION.
         SPACE 2
EISVC    EQU   EIOC2
         SPACE 2
*              THIS CODE IS USED TO PERFORM THE MR AND DR INSTRS
EIMRDR   EQU   *
         STC   ROP,EIQMRDR         STORE PROPER OPCODE IN INSTRUCTION
         LA    RWK1,ECREGS(R7)     GET ADDRESS OF FAKE REGISTER PAIR
         L     R9,ECREGS+4(R7)     GET CONTENTS OF SECOND REG OF PAIR
EIQMRDR  MR    $+R8,R10            ****OPCODE MOVED IN DURING EXEC****
         STM   R8,R9,0(RWK1)       STORE CHANGED REGS INTO FAKE REGS
         B     EIFINRR             BRANCH AND RETURN FOR NEXT INSTR
         TITLE '*** EXECUT - RX PROCESSING ROUTINES'
***********************************************************************
*                                                                     *
*              RX TYPE INSTRUCTION INTERPRETING SECTION               *
*                                                                     *
*                                                                     *
***********************************************************************
*                                                                     *
*              RX NORMAL PROCESSING                                   *
*              (IC,CH,AH,SH,MH,N,CL,O,X,C,A,S,AL,SL,L,LH,CVB)         *
EINORMRX EQU   *
         STC   ROP,EINRMRX         MOVE PROPER OP CODE TO INSTRUCTION
         SPM   RCC                 SET OUR CONDITION CODE TO USERS
EINRMRX  IC    $+R8,0(RAD1)        ** PROPER OP CODE WILL BE MOVED IN**
         ST    R8,ECREGS(R7)       STORE RESULT IN PROPER USER REGISTER
         BAL   RCC,EIFIN           GET CC AND RETURN FOR NEXT INSTR
         SPACE 2
*              THIS SECTION PROCESSES THE BAL INSTRUCTION
EIBAL    EQU   *
         L     RWK1,EIRIA          GET @ OF NEXT SEQUENTIAL INSTR
         N     RCC,=XL4'3F000000'  LEAVE ONLY CC-PM IN RCC
         AL    RCC,=XL4'80000000'  ADD ILC TO PSW BEING BUILT
         ALR   RWK1,RCC            NOW HAVE ILC-CC-PM-IA FIELDS
         ST    RWK1,ECREGS(R7)     FAKE REGISTER GETS BUILT PSW
*              ** NOTE ** RAD1 HAS BRANCH ADDRESS VALUE
         B     EIFINB              PROCESS SUCCESSFUL BRANCH INSTRS
         SPACE 2
*              BRANCH ON COUNT (BCT)
EIBCT    EQU   *
         BCTR  R8,0                DECREMENT VALUE IN REG
         ST    R8,ECREGS(R7)       STORE DECREMENTED VALUE IN FAKE REG
         LTR   R8,R8               VALUE = 0 ?
         BNZ   EIFINB              IF NOT ZERO, SUCCESSFUL BRANCH
         B     EIFIN               BRANCH FAILED, GET NEXT INSTR
         SPACE 2
*              BRANCH ON CONDITION (BC)
EIBC     EQU   *
         SLL   R7,2                GET MASK IN RIGHT SPOT
         STC   R7,EIQBC+1          STORE MASK INTO INSTR
         SPM   RCC                 REAL CC = FAKE CC
EIQBC    BC    $,EIFINB            *** MASK STORED IN ***
         B     EIFIN               BRANCH FAILED
         SPACE 2
*              PROCESS THE LA INSTRUCTION (LOAD ADDRESS)
EILA     EQU   *
         SLR   RAD1,RMEM           DE-RELOCATE ADDRESS FOR USER
         ST    RAD1,ECREGS(R7)     STORE RESULT IN FAKE REG
         B     EIFIN               BRANCH TO GET NEXT INSTR
         SPACE 2
*              INTERPRETATION OF THE EXECUTE INSTRUCTION (EX)
EIEX     EQU   *
         CLI   0(RAD1),X'44'       MAKE SURE NOT AN EXECUTE
         BE    EIOC3               EXECUTE INTERRUPT
*              FETCH INSTRUCTION AND PUT IN STACK
         L     RSTK,ECSTLINK       GET @ OF NEXT STACK SLOT
         ST    RCC,ECSTCCPM        SAVE CC AND PROG MASK IN STACK
         MVC   ECSTINST,0(RAD1)    GET UP TO 6 BYTES OF INSTR
         IC    ROP,ECOP            GET OPCODE INTO REGISTER
         SR    RAD1,RMEM           DE-RELOCATE INSTR ADDR
         ST    RAD1,ECSTIADD       SAVE INSTR ADDR FOR DUMP
         MVC   EIINCPSW+2(4),EIEXMBR  ** CHANGE INSTR IN MAIN LOOP TO  X
                                   RETURN TO EXECUTE CODE **
*              OR BYTE INTO INSTR AS NEEDED - THEN BRANCH TO PROCESS
         LTR   R7,R7               CHECK IF BYTE SHOULD BE OR'ED IN
         BZ    EIEXPEN             BRANCH TO PROCESS IF NOT
         LA    R9,ECREGS+3(R7)     GET @ OF BYTE TO BE OR'ED IN
         OC    ECR1R2(1),0(R9)     OR BYTE INTO INSTRUCTION (IN STACK)
         B     EIEXPEN             BRANCH TO PROCESS INSTR
*              ***** RETURNED HERE TO FIX UP THE ADDRESS OF THE NEXT
*              ***** INSTRUCTION (AFTER THE THE INSTR EXECUTED BY THE
*              ***** EX INSTR)
EIEXRET  EQU   *
         L     RIA,EIRIA           RELOAD CORRECT NEXT INSTR @
         MVC   EIINCPSW+2(4),EIEXRSTR  RESTORE IC INSTR IN MAIN LOOP
         B     EITSTMSK            BRANCH TO CONTINUE PROCESSING
*              THE FOLLOWING INSTRUCTIONS ARE MOVED INTO THE MAIN LOOP
*              TO MODIFY OR RESTORE CODE AS NEEDED BY THE EX INSTR
EIEXMBR  B     EIEXRET
EIEXRSTR IC    R2,EICTB2
         SPACE 2
*              THIS CODE IS USED TO PERFORM THE M AND D COMMANDS
EIMD     EQU   *
         STC   ROP,EIQMD           STORE PROPER OPCODE IN INSTRUCTION
         LA    RWK1,ECREGS(R7)     GET ADDRESS OF FAKE REGISTER PAIR
         L     R9,ECREGS+4(R7)     GET CONTENTS OF SECOND REG OF PAIR
EIQMD    M     $+R8,0(RAD1)        ****OPCODE MOVED DURING EXEC ****
         STM   R8,R9,0(RWK1)       RESTORE CHANGED REGS INTO FAKE REGS
         B     EIFIN               BRANCH AND RETURN FOR NEXT INSTR
         SPACE 2
*              THIS SECTION PROCESSES RX STORE OPERATIONS
*              (NO CC SETTING)   (STH,CVD,STC,ST)
EISTORS  EQU   *
         STC   ROP,EIQSTORS        STORE OPCODE IN INSTRUCTION
EIQSTORS ST    $+R8,0(RAD1)        **** OPCODE CHANGED DURING EXEC ****
         AIF   (&$S370 NE 2).EISTORS    SKIP IF ON S370
         BZ    EIFIN               IF NOT FAKING ALIGNMENT RETURN
         MVC   0(8,RWK14),EIDUBLWD PUT ALTERED CORE BACK IN PLACE
.EISTORS ANOP
         B     EIFIN               BRANCH BACK FOR NEXT INSTRUCTION
         SPACE 2
*              THIS CODE PROCESSES FLOATING POINT RX INSTRUCTIONS
         AIF   (&$FLOTEX).EIXFPRX  SKIP IF WE HAVE EXTENDED FP
EIXFPRX  EQU   EIOC1               NOTE XFP INSTRS NOT ALLOWED
         AIF   (&$FLOTE).EIFPRX    GO GEN IF FLOATINGS ARE ALLOWED
EIFPRX   EQU   EIOC1               NOTE FLOATINGS NOT ALLOWED
EIFPRXST EQU   EIOC1               NOTE FLOATINGS NOT ALLOWED
         AGO   .EIFPRX2            SKIP OVER GENERATION
.EIXFPRX ANOP
EIXFPRX  EQU   *
.EIFPRX   ANOP
         SPACE 1
*              THE FLOATING POINT RX INSTRUCTIONS
EIFPRX   EQU   *
         STC   ROP,EIQFPRX         STORE OPCODE IN INSTRUCTION
         SLL   R7,2                GET R1 FIELD BACK INTO PLACE
         STC   R7,EIQFPRX+1        STORE R1 FIELD INTO INSTRUCTION ALSO
         SPM   RCC                 SET THE CONDITION CODE
EIQFPRX  STD   $,0(,RAD1)          ** OPCODE AND R1 FIELDS STORED IN **
         BAL   RCC,EIFIN           GET CC AND RETURN FOR NEXT INSTR
         SPACE 2
*        CODE FOR FLOATING POINT STORES
         AIF   (&$S370 EQ 2).EIFPRX1   SKIP IF ON A 360
EIFPRXST EQU   EIFPRX              CODE FOR STORES SAME AS OTHERS
         AGO   .EIFPRX2            SKIP AROUND CODE GENERATION
.EIFPRX1 ANOP
         SPACE 2
*              CODE FOR FLOATING POINT STORES WHEN FAKING ALIGNMENT
EIFPRXST EQU   *
         STC   ROP,EIQFPRXS        STORE OPCODE INTO INSTRUCTION
         SLL   R7,2                GET R1 FIELD BACK
         STC   R7,EIQFPRXS+1       STORE R1 FIELD INTO INSTRUCTION ALSO
EIQFPRXS STD   $,0(,RAD1)          **OPCODE AND R1 FIELDS STORED IN ***
         BZ    EIFIN               IN NO ALIGNMENT CHECKING, RETURN
         MVC   0(8,RWK14),EIDUBLWD PUT ALTERED CORE BACK IN PLACE
         B     EIFIN               RETURN
.EIFPRX2 ANOP
         SPACE 2
         AIF   (NOT &$XIOS).EINOXD SKIP IF NO XMACROS
*                     XDECO - EXTENDED DECIMAL OUTPUT INSTRUCTION     *
*              SPECIAL RX INSTRUCTION CONVERTS REGISTER VALUE TO      *
*              EDITED 12 - BYTE DECIMAL FIELD.  (X'52' OPCODE)        *
         SPACE 1
EIXDECO  EQU   *
         XDECO R8,0(RAD1)          CONVERT AND MOVE THE VALUE
         B     EIFIN               RETURN FOR THE NEXT INSTR
         SPACE 2
*                  XDECI - EXTENDED DECIMAL INPUT INSTRUCTION         *
*              SPECIAL INPUT CONVERTER, SCANS 1 - 9 DIGITS, SIGNED    *
*              UNSIGNED DECIMAL NUMBERS WITH ANY # OF PRECEDING       *
*              BLANKS.  SETS CC TO 0,1,2 ACCORDING TO VALUE OF        *
*              RESULT.  CC = ; IF > 9 DIGITS OR 1ST CHARACTER         *
*              NOT +, -, DIGIT, OR + OR - WITHOUT DIGIT FOLLOWING     *
*              OPCODE IS X'53' WITH THE RX FORMAT                     *
         SPACE 1
EIXDECI  EQU   *
         XDECI RWK0,0(RAD1)        CONVERT AND SCAN THE VALUE
         BALR  RCC,0               SAVE THE CONDITION CODE
         BO    *+8                 SKIP STORE IF VALUE WAS BAD
         ST    RWK0,ECREGS(R7)     SAVE THE CONVERTED VALUE IF OK
         SR    RWK1,RMEM           DE-RELOCATE THE SCAN PTR VALUE
         ST    R1,ECREG1           PUT SCAN PTR IN USER REG 1
         B     EIFIN               RETURN FOR THE NEXT INSTR
.EINOXD  ANOP
         AIF   (NOT &$XIOS).EICONT SKIP IF NO XMACROS
         AIF   (NOT &$HEXI).EINOHXI   SKIP IF NO XHEXI
         SPACE 2
*                  XHEXI - EXTENDED HEXADECIMAL INPUT INSTRUCTION     *
*              SPECIAL INPUT MACRO, SCANS 1-8 DIGITS . SKIPS LEADING  *
*              BLANKS.  SETS CONDITION CODE TO 3 IF ILLEGAL HEX       *
*              CHARACTER IS FOUND.  IF GREATER THAN 8 DIGITS FOUND R1 *
*              POINTS TO THE 9TH ELSE R1 POINTS TO FIRST NON-HEX      *
*              IN STRING.                                             *
*              OPCODE IS X'61' IN THE RX FORMAT.                      *
         SPACE 1
EIXHEXI  EQU   *
         XHEXI RWK0,0(RAD1)        CONVERT AND SCAN VALUE
         BALR  RCC,0               SAVE THE CONDITION CODE
         BO    *+8                 SKIP STORE IF VALUE WAS BAD
         ST    RWK0,ECREGS(R7)     STORE CONVERTED VLUE IF OK
         SR    RWK1,RMEM           DE-RELOCATE SCAN POINTER VALUE
         ST    RWK1,ECREG1         SAVE SCAN POINTER IN USER REG 1
         B     EIFIN               RETURN FOR THE NEXT INSTRUCTION
         AGO   .EICKHXO            CHECK IF XHEXO ALLOWED
.EINOHXI ANOP
EIXHEXI  EQU   EIOC1               NOTE XHEXI NOT ALLOWED -- INVALID OP
.EICKHXO AIF   (NOT &$HEXO).EINOHXO   SKIP IF XHEXO NOT ALLOWED
         SPACE 2
*                  XHEXO - EXTENDED HEXADECIMAL OUTPUT MACRO          *
*              SPECIAL RX INSTRUCTION CONVERTS REGISTER VALUE TO      *
*              OUTPUT 8 BYTE FORM.  OPCODE IS X'62'.                  *
         SPACE 2
EIXHEXO  EQU   *
         XHEXO R8,0(RAD1)          CONVERT VALUE AND MOVE TO USER AREA
         B     EIFIN               RETURN FOR THE NEXT INSTRUCTION
         AGO   .EICONT
.EINOHXO ANOP
EIXHEXO  EQU   EIOC1               NOTE XHEXO INVALID OPCODE
.EICONT  ANOP
         TITLE '*** EXECUT - SI PROCESSING ROUTINES'
***********************************************************************
*                                                                     *
*              SI  TYPE INSTRUCTION INTERPRETING SECTION              *
*                                                                     *
***********************************************************************
*                                                                     *
*              SI NORMAL PROCESSING                                   *
*              (TM,MVI,NI,CLI,OI,XI  -  OP D(B),I2)                   *
         SPACE 2
EINORMSI EQU   *
         STC   ROP,EIQSI           MOVE OPCODE INTO INSTRUCTION
         STC   R7,EIQSI+1          MOVE I2 FIELD INTO INSTRUCTION
         SPM   RCC                 SET REAL COND-CODE = TO FAKE ONE
EIQSI    TM    0(RAD1),$           *** OPCODE AND I2 WILL BE MOVED IN**
         BAL   RCC,EIFIN           CAPTURE CC, RETURN FOR NEXT INSTR
         SPACE 1
*              DIAG - PSEUDO SI INSTRUCTION USED FOR DEBUGGING PURPOSE
EIDIAG   EQU   *
         MVC   ECFLAG2,ECI2        SUPPLY CONTROL FLAG TO BYTE
         B     EIFIN               RETURN FOR NEXT INSTRUCTION
         SPACE 2
*              THE FOLLOWING ARE THE GROUP OF S360 / S370 PRIVILEGED
*              OPERATIONS.  CONTROL IS PASSED HERE FROM THE MAIN
*              DECODING LOOP WITH ROP CONTAINING THE OPCODE AND R7
*              CONTAINING THE FIRST REGISTER OR IMMEDIATE FIELD.  AT
*              THE PRESENT TIME ALL OF THESE INSTRUCTIONS ARE FLAGGED
*              WITH OC2 EXCEPTIONS.  THE HOOKS ARE ALL PROVIDED HOWEVER
*              FOR THEIR FUTURE IMPLEMENTATION.
         SPACE 2
EILCTL   EQU   EIOC2               NO PRIVILEGED OPS ALLOWED AT PRESENT
EISTCTL  EQU   EIOC2               NO PRIVILEGED OPS ALLOWED AT PRESENT
EIP370   EQU   EIOC2               NO PRIVILEGED OPS ALLOWED AT PRESENT
EISIO    EQU   EIOC2               NO PRIVILEGED OPS ALLOWED AT PRESENT
EITIO    EQU   EIOC2               NO PRIVILEGED OPS ALLOWED AT PRESENT
EIHIO    EQU   EIOC2               NO PRIVILEGED OPS ALLOWED AT PRESENT
EISSM    EQU   EIOC2               NO PRIVILEGED OPS ALLOWED AT PRESENT
EITCH    EQU   EIOC2               NO PRIVILEGED OPS ALLOWED AT PRESENT
EILPSW   EQU   EIOC2               NO PRIVILEGED OPS ALLOWED AT PRESENT
EIWRD    EQU   EIOC2               NO PRIVILEGED OPS ALLOWED AT PRESENT
EIRDD    EQU   EIOC2               NO PRIVILEGED OPS ALLOWED AT PRESENT
         SPACE 2
         AIF   (&$REPL GT 0).EINREPO   SKIP IF REPL OPTION ALLOWED
EIXREPL  EQU   EIOC1               NO REPLACEMENT:  MAKE ILLEGAL OP
.EINREPO AIF   (&$REPL EQ 0).EINREPL   SKIP IF NO REPLACEMENT ALLOWED
         SPACE 2
*              CODE FOR THE XREPL COMMAND
EIXREPL  EQU   *
         CLI   ECI2,0              WAS IT A SET RFLAG TYPE XREPL
         BH    EIXREPL1            NO, SKIP TO NEXT TYPE
         MVC   ECRFLAG,0(RAD1)     SET RFLAG FROM USER LOCATION
         B     EIFIN               RETURN FOR THE NEXT INSTRUCTION
         SPACE 1
EIXREPL1 CLI   ECI2,1              WAS IT A FETCH RFLAG TYPE
         BH    EIXREPL2            O, SKIP TO NEXT TYPE
         MVC   0(L'ECRFLAG,RAD1),ECRFLAG   FETCH THE FLAG TO USER AREA
         B     EIFIN               RETURN FOR THE NEXT INSTR
         SPACE 1
EIXREPL2 CLI   ECI2,2              WAS IT INSTRUCTION COUNT
         BH    EIXREPL3            NO, GO ON TO NEXT
         MVC   0(4,RAD1),ECILIMT   MOVE TEMP INSTR COUNT OVER
         B     EIFIN               RETURN FOR THE NEXT INSTRUCTION
EIXREPL3 EQU   EIFIN               ILLEGAL I2 FIELD IGNORE AND RETURN
.EINREPL ANOP
         TITLE '*** EXECUT - RS PROCESSING ROUTINES'
***********************************************************************
*                                                                     *
*              RS INSTRUCTION PROCESSING ROUTINES                     *
*                                                                     *
***********************************************************************
         SPACE 5
*              BRANCH ON INDEX (BXH,BXLE)
EIRSBX   EQU   *
         STC   ROP,EIQRSBX         STORE OPCODE INTO INSTRUCTION
         L     RWK1,ECREGS+4(R9)   GET NEXT REGISTER BEYOND R3
         LR    RWK0,R10            COPY R3 VALUE IN EXPECTED REGISTER
         TM    ECR1R3,X'1'         WAS REGISTER ODD
         BZ    EIQRSBX             IF EVEN REG,SET UP OK SKIP NEXT INST
         LR    RWK1,RWK0           R3 WAS ODD SO USE SAME VALUE
EIQRSBX  BXH   R8,RWK0,EIRSBX1     **CHANGED TO EITHER BXH-BXLE *******
         ST    R8,ECREGS(R7)       BRANCH FAILED BUT STORE REG BACK
         B     EIFIN               RETURN FOR NEXT INSTR
EIRSBX1  ST    R8,ECREGS(R7)       BRANCH SUCCESSFULL BUT RESTORE REG
         B     EIFINB              RETURN TO BR'D TO INSTR
         SPACE 2
*              LOAD & STORE MULTIPLE (LM,STM) *CODE MAY NOT BE OBVIOUS
EILMSTM  EQU   *
         AIF   (&$S370 NE 2).EILMSTM     CHECK IF NOT ON A 370
         TM    ECPRFLG2,ECALNCHK   SHOULD ALIGNMENT BE CHECKED
         BZ    *+8                 NO ALIGNMENT CHECK BRANCH AROUND
         L     R0,0(RAD1)          QUICK CHECK FOR FULL WORD ALIGNMENT
.EILMSTM ANOP
         SLR   RAD1,RMEM           DE-RELOCATE THE ADDRESS
         LA    RWK0,4(R9)          OBTAIN PART 1 OF LENGTH VALUE
         LR    RWK1,RAD1           PUT ADDR TO BE CHECKED WHERE EXPECT
         CR    R7,R9               IS R1 FIELD <= R3 FIELD
         BNH   EILMSTM1            SKIP OVER IF EASY CASE (R1<R3)
         SPACE 1
         LR    R8,RWK0             R8 NOW = 2ND OPER REG VALUE +4
         LA    RWK0,64             OBTAIN VALUE
         SR    RWK0,R7             R0 = 64 - 1ST REG NUMBER
         LR    R2,RWK0             SAVE LENGTH 2
         AR    RWK0,R8             GET THE TOTAL LENGTH
         B     EILMSTM2            HAVE LENGTHS IN PROPER PLACE
EILMSTM1 EQU   *
         SR    RWK0,R7             RWK0 =(2ND REG)-(1ST REG)+4 1ST ONLY
         LR    R2,RWK0             PUT 1ST LENGTH WHERE EXPECTED
EILMSTM2 BAL   RLINK,EIMSFCHK      CHECK FOR PROTECTION VIOLATION
         ALR   RAD1,RMEM           RELOCATE ADDR TO REAL CORE ADDR
         LA    R10,ECREGS(R7)      ADDR OF 1ST (OR ONLY) REG SEGMENT
         SR    RWK1,RWK1           CLEAR FOR USE AS AN INDEX
         CLI   ECOP,X'90'          WAS INSTRUCTION STM
         BE    *+8                 YES WAS STM, SO RWK1 SET RIGHT
         LA    RWK1,6              LM- SET FOR EXECUT INDEX
         SPACE 1
         BCTR  R2,0                DECREMENT LENGTH FOR SS MVC
         EX    R2,EIQLMSTM(RWK1)   EXECUTE MVC IN CORRECT DIRECTION
         CR    R7,R9               WAS R1 <= R3 FIELD
         BNH   EIFIN               RETURN IF NO MORE TO DO
         SPACE 1
         LA    RAD1,1(R2,RAD1)     2ND CORE SEGMENT ADDRESS
         LA    R10,ECREGS          ADDR OF 2ND REGISTER SECTION FAKE R0
         BCTR  R8,0                DECREMENT TO PLEASE MVC
         EX    R8,EIQLMSTM(RWK1)   EXECUTE PROPER MVC INSTR
         B     EIFIN               RETURN FOR NEXT INSTR
         SPACE 1
EIQLMSTM MVC   0($,RAD1),0(R10)    MVC FOR STM - MEMORY <---- REGISTERS
         MVC   0($,R10),0(RAD1)    USED FOR LM - REGISTERS <---- MEMORY
         SPACE 2
*              CODE FOR ALL SHIFT INSTRUCTIONS ALL ENTER AT SAME PLACE
*              SHIFT DOUBLES ENTER SAME AS SHIFT SINGLES
EISHIFT  EQU   *
         STC   ROP,EIQSHIF         PLACE SHIFT OPCODEINTO INSTRUCTION
         L     R9,ECREGS+4(R7)     GET SECOND REG IN CASE OF DOUBLE
         LA    RWK1,ECREGS(R7)     GET USER REG ADDRESS FOR SHIFT INST
         SPM   RCC                 SET REAL COND CODE = FAKE ONE
EIQSHIF  SRL   $+R8,0(RAD1)        SHIFT ***CHANGED DURING EXEC****
         STM   R8,R9,0(RWK1)       REPLACE THE REGISTER PAIR
         BAL   RCC,EIFIN           CAPTURE CC, RETURN FOR NEXT INSTR
         SPACE 2
         AIF   (&$S370 NE 1).EIMASK2   SKIP IF DON'T HAVE S370 HARDWARE
*              CODE FOR ICM, STCM, AND CLM INSTRUCTIONS ON S/370
EIICM    EQU   *
EISTCM   EQU   *
EICLM    EQU   *
         STC   ROP,EIQRS370        STORE OPCODE INTO INSTRUCTION
         SRL   R9,2                TREATED AS RR X 4 MOVE MASK PROPER
         SPM   RCC                 SET REAL CONDITION CODE TO FAKE ONE
         EX    R9,EIQRS370         EXECUTE INSTR GIVING MASK
         ST    R8,ECREGS(R7)       PUT REGISTER BACK IN CORE
         BAL   RCC,EIFIN           GET COND CODE AND RETURN
EIQRS370 ICM   R8,0,0(RAD1)        ***OPCODE CHANGED DURING EXECUTION**
.EIMASK2 AIF   (&$S370 NE 2).EIMASK3   SKIP IF ON A 370
*              CODE FOR STCM USING 360 HARDWARE
EISTCM   EQU   *                   CODE FOR STCM COMMAND
         BAL   RWK14,EIMASK        GO TO COMMON MASK CODE
         MVC   0(1,RAD1),0(RWK1)   INSTRUCTION EXECUTED BY EXMASK
         B     EIFIN               WHEN EIMASK RETURNS WE ARE DONE
         SPACE 2
*              CODE FOR ICM USING S/360 HARDWARE
EIICM    EQU   *
         BAL   RWK14,EIMASK        GO TO COMMON MASK CODE
         MVC   0($,RWK1),0(RAD1)   INSTRUCTION EXECUTED BY EIMASK
         SR    RAD1,R10            RAD1 = # OF BYTES MOVED INTO REG
         BZ    EIICM               IF ZERO, CON CODE IS 0 QUIT
         TM    0(R10),X'80'        CHECK FOR SIGN BIT ON
         BO    EIICM2              IF ON, BRANCH TO SET CC TO -
         BCTR  RAD1,0              GET LENGTH - 1
         EX    RAD1,EIICM3         ITS + OR - SO COMARE TO ZERO
EIICM1   BAL   RCC,EIFIN           GET COND CODE AND RETURN
EIICM2   OI    *+1,1               SET COND COE TO -
         BAL   RCC,EIFIN           GET COND CODE AND RETURN
EIICM3   CLC   0(0,R10),=F'0'      INSTRUCTION TO COMPARE BYTES TO 0
         SPACE 2
*              CODE FOR CLM COMMAND UNDER S / 360 HARDWARE
EICLM    EQU   *
         MVI   EIMSKC,E*16         CHANGE BRANCH TO BE INSTR
         BAL   RWK14,EIMASK        GO DO COMMON MASK CODE
         CLC   0(1,RWK1),0(RAD1)   INSTRUCTION EXECUTED BY EIMASK
         MVI   EIMSKC,X'F0'        RESTORE CHANGED BRANCH INSTRUCTION
         BAL   RCC,EIFIN           CAPTURE CON CODE FROM EIMASK RETURN
         SPACE 2
*              COMMON CODE FOR ICM, STCM AND CLM ALL ON S/360 HARDWARE
EIMASK   EQU   *
         MVI   EIMSKC,X'F0'        MAKE SURE BRANCH IS B NOT BNE
         LR    R10,RAD1            COPY ADDRESS FOR POSSIBLE LATER USE
         SLL   R9,26               MOVE LEFT MOST MASK BIT TO SIGN POS
         LA    RWK1,ECREGS-1(R7)   GET ADDRESS OF INCORE USER REGISTER
         SPACE 2
EIMSK1   LA    RWK1,1(,RWK1)       INCERMENT REGISTER POINTER
         ALR   R9,R9               SHIFT MASK LEFT 1 BIT
         BM    EIMSK1              NO CARRY NZ => MOVE TO DO NR
         BZ    6(,RWK14)           IF 0, WE ARE ALL DONE RETURN
         EX    0,0(,RWK14)         PERFORM SUPPLIED OPERATION
         LA    RAD1,1(RAD1)        INCERMENT CORE AREA POINTER
EIMSKC   EQU   *+1                 POSITION OF MASK CHANGED BY CLM
         BC    $+15,EIMSK1         USUALLY BRANCH TO LOOP (BE FOR CLM)
         B     6(,RWK14)           IF UNEQUAL COMPARE FOR CLM, RETURN
.EIMASK3 ANOP
         TITLE '*** EXECUT - SS PROCESSING ROUTINES'
***********************************************************************
*                                                                     *
*              SS  TYPE  INTERPRETING  SECTION                        *
*                                                                     *
***********************************************************************
         SPACE 5
*              MOVES,TR,PACK,LOGICALS & DECIMALS  (DON'T CHANGE REGS)
EIMOVES  EQU   *
EILOGS   EQU   EIMOVES
EIDECS   EQU   EIMOVES
         SPM   RCC                 SET REAL CC = FAKE CC
EIQSS    MVN   0($,RAD1),0(RAD2)   ** OPCODE & LENGTH(S) MOVED IN **
         BAL   RCC,EIFIN           RETURN FOR NEXT INSTR
         SPACE 2
*              TRT AND EDMK - CHANGE CC & POSSIBLY REGS R1 & R2
EITRT    EQU   *
EIEDMK   EQU   EITRT
         LM    R1,R2,ECREG1        GET FAKE R1 & R2
         LA    R1,0(R1,RMEM)       CLEAR UPPER BYTE & RELOCATE
         EX    0,EIQSS             EXECUTE TNE INSTRUCTION
         BALR  RCC,0               SCOOP UP THE CC
         SLR   R1,RMEM             CONVERT BACK TO FAKE ADDR
         AIF   (&$S370 NE 1).EITRT1  SKIP IF NOT ON A REAL 370
         ICM   R1,8,ECREG1         GET 1ST BYTE IF FAKE REG1
         AGO   .EITRT2
.EITRT1  ANOP
         XC    ECREG1+1(3),ECREG1+1  CLEAR 3 BYTES OF FAKE REG1
         O     R1,ECREG1           GET FAKE REG1 BACK TOGETHER
.EITRT2  ANOP
         STM   R1,R2,ECREG1        REPLACE FAKE REGS R1 & R2
         SR    R2,R2               RECLEAR BYTE REG
         B     EIFIN               RETURN FOR NEXT INSTR
         SPACE 2
*              CODE FOR THE SRP COMMAND (SHIFT AND ROUND)
EISRP    EQU   *
         SR    RAD2,RMEM           REMOVE RELOCATION DONE EARLIER
         IC    R2,ECB2D2           GET B2 BASE REG
         SRA   R2,4                REMOVE UNNEEDED BITS
         AIF   (&$S370 NE 1).EISRP1  SKIP IF NOT ON A REAL 370
         BZ    EIDECS              BRANCH TO EXECUTE THE INSTRUCTION
         SLL   R2,2                B2 * 4 FOR INDEX
         S     RAD2,ECREGS(R2)     DON'T WANT VALUE OF BASE REG
         B     EIDECS              BRANCH TO EXECUTE THE INSTRUCTION
         AGO   .EISRP2
.EISRP1  ANOP
         BZ    EISRPA              NO BASE REG ADDED IN, SKIP OVER
         SLL   R2,2                B2 * 4 FOR INDEX
         S     RAD2,ECREGS(R2)     DON'T WANT VALUE OF BASE REG
EISRPA   EQU   *
         LR    R8,R7               COPY LENGTH FIELD OVER
         SLL   R8,4                GET LENGTH * 16
         OR    R8,R7               SET UP REG WITH 2 LENGTHS
         SPACE
         MVO   EISRPRND(1),ECL1I3(1)  MOVE IMMEDIATE OVER
         ZAP   EISRPRND(1),ECL1I3(1)  CHECK IMMEDIATE
         EX    R7,EISRPZP1         CHECK USER NUMBER
         BZ    EISRPLF5            IF NUMBER=0, WERE DONE
         SPACE
         SLL   RAD2,26             EXTEND BIT 26 AS IF
         SRA   RAD2,26                 IT IS A SIGN BIT
         BZ    EISRPLF3            IF SHIFT IS ZERO, WERE DONE
         BP    EISRPLF             IF SHIFT IS POS, ITS LEFT
         SPACE
*              RIGHT SHIFT CODE
EISRPRT  EQU   *
         LPR   RAD2,RAD2           RIGHT SHIFT, GET POS SHIFT
         B     EISRPRT2            BRANCH INTO LOOP
EISRPRT1 EQU   *
         MVO   EISRPSHF(16),EISRPSHF(15)  SHIFT ALL BUT LAST NIBBLE
EISRPRT2 EQU   *
         BCT   RAD2,EISRPRT1       CONTINUE LOOP (DECMT COUNT)
         SLL   R7,4                SHIFT LENGTH TO L1 FIELD
         MVN   EISRPSHF+15(1),EISRPRND  MAKE SIGN POSITIVE
         AP    EISRPSHF(16),EISRPRND(1) ADD IN ROUNDING FACTOR
         EX    R7,EISRPMV1         MOVE TO USER, DOING LAST SHIFT
         B     EISRPLF3            GO TO SET CC AND RETURN
         SPACE
*              LEFT SHIFT CODE
EISRPLF  EQU   *
         STC   R8,EISRPLF2+1       PUT LEN INTO MVO INSTR
         LA    RWK1,0(R7,RAD1)     GET @ OF LAST BYTE OF USER #
         OI    *+1,0               SET CC = 0
EISRPLF1 EQU   *
         BNZ   EISRPLF2            IF OVERFLOW HAS OCCURRED, BRANCH
         TM    0(RAD1),X'F0'       CHECK 1ST NIBBLE FOR NON ZERO
EISRPLF2 EQU   *
         MVO   0($,RAD1),0($,RAD1)    SHIFT LEFT ** LENGTHS STORED IN**
         MVZ   0(1,RWK1),EISRPPK0  MOVE ZERO TO PROPAGATED SIGN
         BCT   RAD2,EISRPLF1       DECREMENT COUNT AND BRANCH
         BNZ   EISRPLF4            OVERFLOW, BRANCH TO CHECK FOR OCA
EISRPLF3 EQU   *
         EX    R8,EISRPZP2         SET CC FOR +, - OR 0
         BAL   RCC,EIFIN           CAPTURE CC AND RETURN FOR NEXT INSTR
EISRPLF4 EQU   *
         TM    ECSTCCPM,X'04'      CAPTURE MASK BIT
         BO    EIOCA               OVERFLOW HAS OCCURRED -- ERROR
         TM    *+1,1               SET CC TO OVERFLOW
EISRPLF5 EQU   *
         BAL   RCC,EIFIN           CAPTURE CC AND RETURN FOR NEXT INSTR
         SPACE 1
EISRPZP1 ZAP   EISRPSHF(16),0($,RAD1)    CHECK AND MOVE USER #
EISRPZP2 ZAP   0($,RAD1),0($,RAD1) SET CC TO +, -, OR 0
EISRPMV1 MVO   0($,RAD1),EISRPSHF(15)  MOVE BACK TO USER AREA
         SPACE 1
EISRPRND DC    PL1'0'              AREA FOR SRP ROUNDING FACTOR
EISRPSHF DC    PL16'0'             AREA FOR SHIFTING USER #
EISRPPK0 DC    PL1'0'              USED TO SET SIGN
.EISRP2  ANOP
         SPACE 2
*              CHECK IF GENERATION OF XIO'S IS ON
         AIF   (&$XIOS).EIXIOS     SKIP TO GENERATE CODE IF EXISTS
EIXIOS   EQU   EIOC1               THESE INSTRUCTIONS DO NOT EXIST
         AGO   .EINOXIO
.EIXIOS  ANOP
         SPACE 2
*        PSEUDO RX - SS EXTENDED MNEMONICS - XREAD, XPRNT, XPNCH, IO'S*
*              PSEUDO DUMP ROUTINE  -  XDUMP                          *
*        ** NOTE ** BECAUSE OF NO-STANDARD ADDRESSING DONE BY THESE   *
*        INSTRUCTIONS, THEY DO THEIR OWN ADDRESS CHECKING AND THUS    *
*        HAVE A PROTECTION BYTE OF X'00' SO THE INITIAL SS SECTION    *
*        DOESN'T STOP THEM.  THEY THEN FAKE THE PROTECTION BYTES OF   *
*        EITHER STM (X'C0'-XREAD),OR TM(X'80'-XPRNT,XDUMP,XPNCH).     *
         SPACE 1
EIXIOSR  ST    RIA,EIRIA           XDUMPR SHORT CUT                   L
EIXIOS   EQU   *                   SECTION FOR X-MACRO I/O INSTRS
         N     RCC,=XL4'3F000000'  REMOVE ALL BUT CC - PM BITS
         AL    RCC,EIRIA           PUT CC - PM PROG ADDR TOGETHER
         ST   RCC,ECILCMSK         STORE RESULTING PSW
         OI    ECILCMSK,X'C0'      SET ILC = 3, FOR LENGTH OF X-INST
         CLI   ECOP,X'E1'          SEE IF IT WAS A REGS TYPE XDUMP
         BE    EIXDUMPR            YES, GO DUMP REGS ONLY
         SR    RAD2,RMEM           REMOVE SPERIOUS RELOCATION
         BNZ   EIXLOK              LENGTH OK IF NOT ZERO
         L     RAD2,ECREGS         GET VALUE OF FAKE ZERO
EIXLOK   EQU   *
         LR    RWK1,RAD2           SAVE THE LENGTH TO BE DONE
         SRL   R7,3                GET MASK VALUE IN PLACE FOR INDEX
         ALR   R7,R7               SHIFT LEFT FOR MULTIPLE OF 2
         LH    R9,EIXIOJ(R7)       GET ADDRESS VALUE
         B     EISPEJMP(R9)        GO TO RIGHT SECTION OF CODE
         SPACE 2
*              XREAD PREUDO INSTRUCTION
EIXREAD  EQU   *
         TM    ECFLAG0,$ECEOF      HAS THERE BEEN AN EOF ALREADY
         BO    EIXREOF             YES, USER TRYING TO GO PAST
         $READ 0(RAD1),(RWK1),EIXREOFA   ACTUALLY READ A CARD
         BAL   RCC,EIFIN           CAPTURE CC AND RETURN FOR NEXT INSTR
         SPACE 1
EIXREOFA OI    ECFLAG0,$ECEOF      FLAG END OF FILE
         BAL   RCC,EIFIN           GET COND CODE AND RETURN
         SPACE 1
EIXREOF  MVI   ECFLAG1,$ECREADR    SHOW READ BEYOND END OF FILE
         LA    R1,EICCREAD         SHOW EOF OCCURRED                  M
         NI    ECPRFLG3,ECNOSPI    MAKE SURE SPIE IS OFF FOR SAFETY   M
         B     EIITIA              GO TO EXIT ROUTINE                 M
         SPACE 2
*              XPRNT PSEUDO INSTRUCTION  -  PRINT A LINE
EIXPRNT  EQU   *
         $PRNT    0(RAD1),(RWK1),EIXRECEX   PRINT THE LINE
         B      EIFIN              RETURN FOR THE NEXT INSTRUCTION
         SPACE 2
*              XPNCH PSEUDO INSTRUCTION  -  PUNCH A CARD
EIXPNCH  EQU   *
         $PNCH 0(RAD1),(RWK1),EIXRECEX   PUNCH THE CARD
         B     EIFIN               RETURN FOR NEXT INST
         SPACE 2
         AIF   (&$XXIOS).EIXIOS1   SKIP IF NOT ALLOWED XGET , XP T
*              XGET PSEUDO INSTRUCTION  INPUT
EIXGET   EQU   *
         $GET  0(RAD1),(RAD2)      DO GET INPUT                  CEH
         BAL   RCC,EIFIN           GET CC AND RETURN
         SPACE 2
*              XPUT PSEUDO INSTRUCTION DO OUTPUT
EIXPUT   EQU   *
         $PUT  0(RAD1),(RAD2)      DO PUT OUTPUT         CEH
         BAL   RCC,EIFIN           GET CC AND RETURN FOR NEXT INSTR
         AGO   .EIXIOS2            SKIP LABEL SAVING
.EIXIOS1 ANOP
EIXGET   EQU   EIOC1               MAKE XGET AN ERROR           CPP
EIXPUT   EQU   EIOC1               MAKE XPUT AN ERROR           CPP
.EIXIOS2 ANOP
         SPACE 2
EIXRECHK CLI   ECFLAG1,$ECRECEX    DID XXXXSNAP SET FLAG?
         BNE   EIFIN               NO,SO DON'T BOMB USER OUT
EIXRECEX MVI   ECFLAG1,$ECRECEX    SET RECORDS EXCEEDED FLAG
EICNTEXC LA    R1,EICCRECE         SHOW RECORDS EXCEEDED MESSAGE
         NI    ECPRFLG3,ECNOSPI    MAKE SURE SPIE IS OFF FOR SAFETY   M
         B     EIITIA              GO TO FINISH UP AND RETURN
         SPACE 2
*              XDUMP PSEUDO INSTRUCTION - DUMP STORAGE AND REGISTERS
EIXDUMP  EQU   *                   ENTRY LABEL FOR STORAGE XDUMP
         LR    R10,REC             MOVE ECONTROL POINTER FOR XXXXSNAP
         XSNAP T=(NO,,1),LABEL='USER STORAGE',STORAGE=(*0(RAD1),*0(RWK1X
               ,RAD1))
         B     EIXRECHK            GO CHECK FOR RECORD OVERFLOW
         SPACE 2
EIXDUMPR EQU   *
         LR    R10,REC             MOVE ECONTROL POINTER FOR XXXXSNAP
         XSNAP T=(PR,,1),LABEL='USER REGISTERS'
         B     EIXRECHK            GO CHECK FOR RECORD OVERFLOW
         SPACE 2
*              XLIMD PSEUDO INSTRUCTION -- LIMIT DUMP AREA
EIXLIMD  EQU   *
         LA    RAD2,0(RWK1,RAD1)   GET SECOND LIMIT REAL ADDRESS
         BCT   RWK1,*+8            IF RWK1=1 (OMITTED) USE END OF PROG
         L     RAD2,ECRADH         LENGTH=1 USE HIGHEST @ INSTEAD
         ST    RAD1,ECRDLIML       ECRDLIML - ECRDLIMH - NEW LIMITS
         ST    RAD2,ECRDLIML+4     STORE NEW LIMITS
         B     EIFIN               RETURN FOR NEXT INSTRUCTION
         EJECT
*              THE FOLLOWING CODE INTERPRETS THE XOPC PSEUDO INSTRS
         SPACE 5
*              CHECK IF LEGAL CODE # IS SPECIFIED IN THE IMMED FIELD
*              OF THE INSTR  --  IF OK, BRANCH TO INDIVIDUAL XOPC
*              ROUTINES.
EIXOPC   EQU   *
         C     R7,=A(EC#XOPC)      IS CODE # LEGAL ?
         BNH   EIXOPCOK            YES, BR AROUND ERROR CODE
         TM    *+1,1               SET CC = 3 TO NOTE ERROR
         BAL   RCC,EIFINRR         GET CC, FETCH NEXT INSTR
EIXOPCOK EQU   *
         LR    RWK1,R7             COPY CODE # FOR OFFSET INDEX
         ALR   RWK1,RWK1           GET INDEX INTO OFFSET TABLE
         LH    RWK1,EIOPCJMP(RWK1) GET BRANCH OFFSET TO ROUTINE
         B     EIXOPC(RWK1)        BRANCH TO ROUTINE
         SPACE 5
*              THE FOLLOWING CODE PROCESSES THE INDIVIDUAL XOPC
*              PSEUDO INSTRUCTIONS
         SPACE 2
*              XOPC 0  (SET UP PSEUDO SPIE)
EIOPC0   EQU   *
         L     RWK1,ECREG1         GET USER SPECIFIED EXIT @
         LA    RWK0,1              ASSUME LENGTH-1 = 1
         BAL   RLINK,EIXOPCHK      CHECK GIVEN ADDRESS FOR CORRECTNESS
         ST    RWK1,ECPRSPIE       SET USER SPIE EXIT ADDR
         MVC   ECPRSCDE(4),ECREG0  SET USER SPIE CODE MASK
         OI    ECPRFLG3,B'10000000'  TURN ON FLAG NOTE SPIE IS SET
         B     EIXOPCC0            BRANCH TO COMMON XOPC EXIT CODE
         SPACE 2
*              INSTRUCTION TRACE XOPC INSTRUCTIONS
*
*              CHECK AND SET LIMIT ADDRESSES FOR TRACE
EIOPC1   EQU   *
EIOPC3   EQU   EIOPC1
         LM    RWK0,RWK1,ECREGS    GET LOW AND HIGH ADDRS FOR TRACE
         CR    RWK0,RWK1           ARE ADDRESSES RELATIVELY CORRECT ?
         BNL   EIXOPCC1            BRANCH IF NOT
         BAL   RLINK,EIXOPCHA      CHECK ADDRESSES FOR LEGALITY
         STM   RWK0,RWK1,ECPRTRAL  SET TRACE ADDRESS LIMITS IN PRCB
         BCTR  R7,0                XOPC CODE# = CODE#-1
         LTR   R7,R7               IS CODE = 1  (R7 = 0) ?
         BZ    EIXOPCC0            YES, DOING XOPC 1 - FINISHED
*        TURN ON INSTRUCTION TRACE FACILITY
EIOPC2   EQU   *
         OI    ECPRFLG1,ECPRTRCE   TURN ON TRACE FACILITY
         B     EIXOPCC0            BRANCH TO COMMON XOPC EXIT CODE
*              TURN OFF INSTRUCTION TRACE FACILITY
EIOPC4   EQU   *
         NI    ECPRFLG1,255-ECPRTRCE  TURN OFF TRACE FACILITY
         B     EIXOPCC0            BRANCH TO COMMON XOPC EXIT CODE
         SPACE 2
*              STORAGE MODIFICATION CHECK XOPC INSTRUCTIONS
*
*              CHECK AND SET LIMIT ADDRESSES FOR MOD CHECK
EIOPC5   EQU   *
EIOPC7   EQU   EIOPC5
         LM    RWK0,RWK1,ECREGS    GET LOW AND HIGH ADDRS FOR MOD CHK
         CR    RWK0,RWK1           ARE ADDRS RELATIVELY CORRECT ?
         BNL   EIXOPCC1            BRANCH IF NOT
         BAL   RLINK,EIXOPCHA      CHECK IF ADDRESSES ARE LEGAL
         STM   RWK0,RWK1,ECPRMODL  SET MOD CHECK ADDRESSES
         LA    RWK1,5              LOAD CODE # COMPARATOR
         CR    R7,RWK1             IS THIS AN XOPC 5 INSTR ?
         BE    EIXOPCC0            YES - FINISHED
*              TURN ON MODIFICATION CHECK FACILITY
EIOPC6   EQU   *
         OI    ECPRFLG1,ECPRMODC   TURN ON MOD CHECKING
         B     EIXOPCC0            BRANCH TO COMMON XOPC EXIT CODE
*              TURN OFF MODIFICATION CHECKING FACILITY
EIOPC8   EQU   *
         NI    ECPRFLG1,255-ECPRMODC  TURN OFF MOD CHECKING
         B     EIXOPCC0            BRANCH TO COMMON XOPC EXIT CODE
         SPACE 2
*              TURN ON ALIGNMENT CHECKING  (360 STYLE)
*              (OC-6 ALIGNMENT INTERRUPTS ALLOWED)
EIOPC9   EQU   *
         OI    ECPRFLG2,ECALNCHK   TURN ON CHECKING
         B     EIXOPCC0            BRANCH TO COMMON XOPC EXIT CODE
*              TURN OFF ALIGNMENT CHECKING   (370 STYLE)
*              (OC-6 ALIGNMENT INTERRUPTS NOT ALLOWED)
EIOPC10  EQU   *
         NI    ECPRFLG2,255-ECALNCHK    TURN OFF CHECKING
         B     EIXOPCC0            BRANCH TO COMMON XOPC EXIT CODE
         SPACE 2
*              XOPC 11  (FETCH INSTRUCTION COUNT)
EIOPC11  EQU   *
         MVC   ECREG0(4),ECILIMT   PUT COUNT IN USER REG 0
         B     EIXOPCC0            BRANCH TO COMMON XOPC EXIT CODE
         SPACE 2
*              XOPC 12   -   EMULATE SYSTEM 360
EIOPC12  EQU   *
         NI    ECPRFLG2,B'11110011' SHUT OFF ALL EMULATION BITS
         OI    ECPRFLG2,ECEM360    SHOW NOW EMULATING A 360
         MVI   EITSTMSK+1,ECEM360  SET TM INSTR FOR NO 370 INSTRS
         B     EIXOPCC0            BRANCH TO COMMON XOPC EXIT CODE
         SPACE 2
*              XOPC 13   -   EMULATE SYSTEM 370
EIOPC13  EQU   *
         NI    ECPRFLG2,B'11110011' SHUT OFF ALLL EMULATION BITS
         OI    ECPRFLG2,ECEM370    SHOW NOW EMULATING A 370
         MVI   EITSTMSK+1,ECEM370  SET TM INSTR FOR BOTH 370 AND 360
         B     EIXOPCC0            BRANCH TO COMMON XOPC EXIT CODE
         SPACE 2
*              XOPC 14   -   SET INTERRUPT COUNT
EIOPC14  EQU   *
         MVC   ECPRCMPR(4),ECREG0  MOVE GIVEN VALUE TO PRCB
         B     EIXOPCC0            BRANCH TO COMMON EXIT CODE
         SPACE 2
*              XOPC 15   -   SET COUNT EXIT ADDRESS
EIOPC15  EQU   *
         MVC   ECPRCLEA(4),ECREG0  MOVE GIVEN EXIT ADDRESS PRCB
         OI    ECPRFLG4,ECLKADR    TURN ON FLAG TO NOTE CLOCK EXIT ADDR
         B     EIXOPCC0            BRANCH TO COMMON EXIT CODE
         SPACE 3
*              INSTRUCTION EXECUTION COUNT FACILITY INSTRUCTIONS
*
*              XOPC 17 AND XOPC 18
*              CHECK AND SET LIMIT ADDRESSES FOR COUNT FACILITY
EIOPC17  EQU   *
EIOPC18  EQU   *
         LM    RWK0,RWK1,ECREGS    GET LOW AND HIGH ADDRS FOR COUNT
         CR    RWK0,RWK1           ARE ADDRESSES RELATIVELY CORRECT ?
         BNL   EIXOPCC1            BRANCH IF NOT SET CC = 1
         BAL   RLINK,EIXOPCHA      CHECK ADDRESSES FOR LEGALITY
         STM   RWK0,RWK1,ECPRICL   SET COUNT LIMIT ADDRESSES IN PRCB
         CLI   R7,X'11'            IS XOPC CODE 17 OR 18?
         BE    EIXOPCC0            IS 17, SO FINISHED
         SPACE 3
*              TURN ON THE INSTRUCTION EXECUTION COUNT FACILITY
EIOPC16  EQU   *
         TM    ECPRFLG1,ECPRNOSP   TEST PRCB FOR NO COUNTING SPACE AVAL
         BO    EIXOPCC1            NO SPACE AVAILABLE, QUIT
         TM    ECPRFLG1,ECPRCTON   HAS SPACE FOR COUNT ALREADY ALLOCED
         BO    EINOALL             SPACE ALREADY ALLOCATED
         L     RWK0,ECFADH         GET HIGH PROG ADDR IN REG 0
         S     RWK0,ECFADL         SUBTRACT TO FIND CORE LENGTH NEEDED
         LA    R9,ECPRICA          GET ADDR IECF AREAS IN ECONTROL
         GETMAIN  EC,LV=(0),A=(R9),SP=1  TRY  GET LENGTH USER PROG
         LTR   R15,R15             TEST TO SEE IF WE GOT WHAT WE NEEDED
         BZ    EISPCOK             IF CC=0, WE GOT WHAT WE NEEDED
         OI    ECPRFLG1,ECPRNOSP   IF NOT, NOT ENOUGH SPACE - SET FLAG.
         B     EIXOPCC1            AND QUIT.
EISPCOK  EQU   *
         ST    RWK0,ECPRICAL       GOT AMOUNT NEEDED STORE LENGTH
         OI    ECPRFLG1,ECPRCTON   NOTE ALLOCATION OF COUNTER SPACE
EINOALL  EQU   *
         OI    ECPRFLG1,ECPRIECF   NOTE THAT THE COUNT FACILITY IS ON
         B     EIXOPCC0            BRANCH TO COMMON XOPC RETURN CODE
         SPACE 3
*              XOPC 19
*              TURN OFF THE INSTRUCTION EXECUTION COUNT FACILITY
EIOPC19  EQU   *
         NI    ECPRFLG1,255-ECPRIECF  TURN OFF THE COUNT FACILITY FLAG
         B     EIXOPCC0            BRANCH TO COMMON XOPC RETURN CODE
         SPACE 3
*              XOPC 20
*              CLEAR INSTRUCTION EXECUTION COUNT FACILITY COUNT AREAS
EIOPC20  EQU   *
         TM    ECPRFLG1,ECPRCTON   TEST FOR COUNT SPACE ALLOCATION
         BNO   EIXOPCC1            IF NOT ALLOCATED, CANNOT CLEAR IT
         L     RWK1,ECPRICA        GET ADDRESS OF CORE TO BE CLEARED
         L     R9,ECPRICAL         GET LENGTH OF CORE TO BE CLEARED
         BCTR  R9,0                GET LENGTH IN WORKABLE FORM
         C     R9,=XL4'000000FF'   IS LENGTH > 256 BYTES
         BNH   EIREMAIN            IF NOT > 256 BYTES CLEAR USING EX
         XR    R8,R8               ZERO OUT R8 FOR DIVIDE
         D     R8,=XL4'00000100'   DIVIDE LEN BY 256 GIVING REMAINDER
EIOPCLP  EQU   *
         XC    0(256,RWK1),0(RWK1) ZERO OUT 256 BYTE AREA
         LA    RWK1,256(RWK1)      MOVE ADDRESS POINTER OVER
         BCT   R9,EIOPCLP          GO BACK AND GET NEXT 256 BYTE AREA
         LTR   R9,R8               PUT REMNDR WHERE NEEDED BY EXECUTE
         BZ    EIXOPCC0            IF REMAINDER IS 0 WE ARE DONE
EIREMAIN EQU   *
         EX    R9,EIXOPCXC         EXECUTE XC TO DO REMAINING BYTES
         B     EIXOPCC0            BRANCH TO COMMON XOPC EXIT CODE
EIXOPCXC XC    0(0,RWK1),0(RWK1)    ZERO OUT REMAINING BYTES IN COUNT
         SPACE 3
*              XOPC 21  (RETURN FROM INTERRUPT HANDLING STATE)
EIOPC21  EQU   *
         TM    ECPRFLG3,ECINHDST   TEST SEE IF IN INTERRUPT HANDLING
         BO    EIOPC21A            IF WE ARE CONTINUE XOPC INSTR
         TM    *,X'FF'             SET CC=1 TO DENOTE ERROR
         BAL   RCC,EIFINRR         GET CC, FETCH NEXT INSTR
EIOPC21A EQU   *
         L     RIA,ECREG1          GET RESUMING ADDR FROM USER REG 1
         MVC   ECREG0(8),ECPRIRGS  RELOAD USER REGISTERS 0 AND 1
         NI    ECPRFLG3,B'10111111'  TURN OFF INTERRUPT HANDLING FLAG
         SR    RWK1,RWK1           SET CC = 0 TO NOTE OKAY EXEC
         BAL   RCC,EIFINB          GET NEXT INSTR TREAT XOPC 21 AS BR
         SPACE 5
*              XOPC 22 - DUMP INSTRUCTION EXECUTION COUNT STATISTICS
         SPACE 2
*              THIS SECTION PRINTS THE STATISTICAL REPORT FOR THE
*              INSTRUCTION EXECUTION COUNT FACILITY.  DUE TO THE TABLE
*              DESIGN OF IECF, MANY POINTERS ARE USED AND REGISTER
*              USAGE DIFFERS A LITTLE FROM THAT IN THE REST OF THE
*              EXTENDED INTERPRETER. REGISTER USAGE IN THIS SECTION IS
*              AS FOLLOWS: RWK0  -  GENERAL WORK REGISTER
*                          RWK1  -  OFFSET POINTER IN COUNT TABLE
*                          R7    -  GENERAL WORK REGISTER
*                          R8    -  THE CURRENT INSTRUCTION COUNT
*                          R9    -  BASE ADDRESS OF COUNTING AREA
*                          R10   -  BASE ADDRESS OF USER PROGRAM AREA
*                          RWK14  -  CURRENT PROGRAM RELATIVE ADDRESS
*                                BEING INSPECTED
*              IT SHOULD BE NOTED THAT THIS SECTION IS VERY INSTRUCTION
*              LENGTH DEPENDENT.  ANY NEW INSTRUCTION DIFFERING IN THE
*              TRADITIONAL LENGTH CODES WILL DRASTICALLY EFFECT THIS
*              SECTION.
         SPACE 3
EIOPC22  EQU   *
         TM    ECPRFLG1,ECPRCTON   TEST COUNT SPACE ALLOCATION
         BNO   EIXOPCC1            IF NEVER ALLOCATED CANNOT DUMP IT
         L     RWK1,ECFADL         GET FAKE BEGIN INSTR ADDR
         LA    R10,0(RMEM,RWK1)    GET PHYSICAL REAL STARTING INSTR ADR
         L     RWK1,ECPRICL        GET BEGINNING COUNTABLE FAKE INSTR
         ST    RWK1,EISAV22        SAVE FIST OFFSET AS BEG LOOP ADDR
         LR    RWK14,RWK1          SAVE FIRST ADDR FOR LATER USE
         S     RWK1,ECFADL         SET OFFSET POINTER AT BEG
         SR    R8,R8               ZERO OUT COUNT SAVING REGISTER
         L     R9,ECPRICA          GET STARTING ADDRESS OF COUNT SPACE
         SPACE 2
EILOP22  EQU   *
         CH    R8,0(RWK1,R9)       IS THE NEW COUNT THE SAME AS OLD?
         BE    EIMVPNTR            IF SAME, MOVE POINTER OVER
         SPACE 2
*              THIS SECTION ACTUALLY PRINTS THE STATISTICS LINE
         LTR   R8,R8               WAS THE OLD COUNT ZERO?
         BZ    EINEWCT             IF OLD WAS ZERO, JUST SAVE & RETURN
         L     RWK0,EIEND22        GET ENDING ADDR OF THIS LOOP
         XHEXO RWK0,EISTEND        CONVERT ENDING ADDR TO HEX
         L     RWK0,EISAV22        SET BEGINNING ADDR OF THIS LOOP
         XHEXO RWK0,EISTBEG        CONVERT BEGINNING ADDR TO HEX
         XDECO R8,EISTCNT          CONVERT INSTR COUNT TO DECIMAL
         MVC   EISTBEG(2),EISTBLK  BLANK OUT FIRST TWO BYTES OF ADDR
         MVC   EISTEND(2),EISTBLK   BLANK OUT FIRST TWO BYTES OF ADDR
         $PRNT EISTMSG,EISTMSGL,EICNTEXC    PRINT STATISTICAL LINE
         SPACE 2
EINEWCT  EQU   *
         ST    RWK14,EISAV22       SAVE BEGINNING LOOP ADDRESS
         LH    R8,0(RWK1,R9)       REPLACE OLD COUNT WITH NEW
         SPACE 2
EIMVPNTR EQU   *
         ST    RWK14,EIEND22       SAVE ENDING LOOP ADDRESS
         LTR   R8,R8               TEST FOR ZERO COUNT
         BZ    EIRR22              ASSUME 2 BYTE LENGTH INSTRS ON H-WRD
         LA    R7,0(RWK1,R10)      GET ADDRESS OPCODE OF PRES INSTR
         TM    0(R7),X'C0'         TEST OPCODE FOR LENGTH
         BM    EIRXSI22            BRANCH IF LENGTH EQUAL 4
         BO    EISS22              BRANCH IF AN SS INSTR LENGTH = 6
         SPACE 2
EIRR22   EQU   *
         LA    RWK1,2(RWK1)        LENGTH = 2 INCERMENT AND CHECK DONE
         B     EICHK22             BRANCH CHECK IF DONE
         SPACE 2
EIRXSI22 EQU   *                   RX OR SI THEN LENGTH =4
         LA    RWK1,4(RWK1)        LENGTH = 4 INCERMENT AND CHECK
         B     EICHK22             CHECK FOR FINISHED
         SPACE 2
EISS22   EQU   *                   LENGTH = 6
         LA    RWK1,6(RWK1)        INCERMENT OFFSET AND CHECK
EICHK22  EQU   *
         LR    RWK14,RWK1          MOVE OFFSET FOR ADDR CALCULATION
         A     RWK14,ECFADL        ADD TO GET NEW USER PROGRAM ADDR
         C     RWK14,ECPRICH       TEST TO SEE IF OUT OF COUNTING RANGE
         BL    EILOP22             IF NOT OUT OF RANGE CONTINUE
         LTR   R8,R8               IF FINISHED CHECK LAST COUNT
         BZ    EIXOPCC0            IF ZERO, DONE, BRANCH COMMON CODE
         L     RWK0,EIEND22        GET LAST ENDING ADDRESS
         SPACE 2
*              THIS SECTION PRINTS THE LAST STATISTICS LINE
         XHEXO RWK0,EISTEND        CONVERT ENDING ADDRESS TO HEX
         L     RWK0,EISAV22        SET BEGINNING ADDR OF THIS LOOP
         XHEXO RWK0,EISTBEG        CONVERT BEGINNING ADDRESS TO HEX
         XDECO R8,EISTCNT          CONVERT INSTR "OUNT TO DECIMAL
         MVC   EISTBEG(2),EISTBLK  BLANK OUT FORST TWO BYTES OF ADDR
         MVC   EISTEND(2),EISTBLK  BLANK OUT FIRST TWO BYTES OF ADDR
         $PRNT EISTMSG,EISTMSGL,EICNTEXC    PRINT STATISTICAL LINE
         B     EIXOPCC0            BRANCH TO COMMON XOPC EXIT CODE
         SPACE 2
EISTMSG  DC    C' STATS-->   BEGIN ADDR:'   STATISTICS MESSAGE
EISTBEG  DC    8C' '               STATS MESSAGE
         DC    C'   END ADDR:'     STATS MESSAGE
EISTEND  DC    8C' '               STATS MESSAGE
         DC    C'   INSTRUCTION COUNT:'      STATS MESSAGE
EISTCNT  DC    12C' '              STATS MESSAGE
EISTMSGL EQU   *-EISTMSG           LENGTH OF STATISTICAL MESSAGE
EISTBLK  DC    2C' '               BLANK AREA
EIEND22  DS    F                   ENDING LOOP ADDRESS
EISAV22  DS    F                   BEGINNING LOOP ADDRESS
         SPACE 2
*              THIS IS THE XOPC COMMON EXIT CODE
EIXOPCC0 EQU   *
         SR    RWK1,RWK1           SET CC=0 NOTE OK EXECUTION
         BAL   RCC,EIFINRR         BRANCH BACK AND FETCH NEXT INSTR
         SPACE 2
*              THIS IS THE XOPC EXIT CODE FOR CC = 1
EIXOPCC1 EQU   *
         O     RWK1,=XL4'11'       SET CC=1 TO NOTE USER ERROR
         BAL   RCC,EIFINRR         GET CC AND BRANCH TO FETCH NXT INSTR
         SPACE 3
**--> INSUB: EIBASDSP      CALCULATE BASE/DISPLACEMENT  + + + + + + + +
*+                                                                    +
*+       ENTRY CONDS:                                                 +
*+             RWK0 - MUST CONTAIN THE APPROPRIATE HALFWORD OF THE    +
*+                    INSTRUCTION                                     +
*+       EXIT CONDS:                                                  +
*+             RWK0 - CONTAINS THE CALCULATED RELATIVE ADDRESS        +
*+                    (NOT RELOCATED FOR ASSIST)                      +
*+             RWK1 - CONTENTS ARE DESTROYED                          +
*+                                                                    +
*++ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
         SPACE 2
EIBASDSP EQU   *
         LR    RWK1,RWK0           COPY B/D OVER
         N     RWK0,=XL4'FFF'      REMOVE BASE, LEAVING DISP
         N     RWK1,=XL4'F000'     REMOVE DISP, LEAVING BASE
         BCR   Z,RLINK             IF NO BASE, RETURN
         SRL   RWK1,10             MULT BASE REG BY 4 FOR INDEX
         AL    RWK0,ECREGS(RWK1)   ADD IN BASE REG'S VALUE
         N     RWK0,EILONGMK       ZERO OUT HIGH ORDER BYTE
         BR    RLINK               RETURN TO CALLER
         SPACE 5
**--> INSUB: EIMSFCHK       MODIFICATION & RANGE CHECKING ROUTINE + + +
*+                                                                    +
*+       THIS ROUTINE CHECKS THE ADDRESS IN RWK1 FOR BEING WITHIN     +
*+       THE ALLOWABLE RANGE.  MODIFICATION CHECKING IS ALSO          +
*+       PERFORMED IF THE INSTRUCTION MODIFIES STORAGE.               +
*+                                                                    +
*+       ENTRY CONDS:                                                 +
*+             RWK1 - CONTAINS THE ADDRESS TO BE CHECKED              +
*+             RWK0 - CONTAINS THE LENGTH OF STORAGE AFFECTED         +
*+            RLINK - CONTAINS THE RETURN ADDRESS                     +
*+           EIWORK - IS A STORAGE AREA THAT MUST CONTAIN THE CONTROL +
*+                    BYTE EICTB3  (SHIFTED LEFT 2 BITS IF 2ND OPRND) +
*+       EXIT CONDS:                                                  +
*+             RWK0 - IS DESTROYED                                    +
*+             RWK1 - IS DESTROYED                                    +
*+                                                                    +
*++ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
         SPACE 2
EIMSFCHK EQU   *
*              DETERMINE WHAT CHECKING TO PERFORM
         BCTR  RWK0,0              RWK0 CONTAINS LENGTH-1
         ALR   RWK0,RWK1           GET @ OF HIGHEST BYTE ACCESSED
         TM    EIWORK,EI1STORE     WHAT CHECKING IS TO BE DONE ?
         BCR   Z,RLINK             RETURN IF NO CHECKING
         BO    EISTRCHK            BRANCH TO DO STORE CHECKING
*              PERFORM FETCH CHECKING
         TM    ECFLAG0,$ECPROT     IS ABSOLUTE PROTECT MODE ON ?
         BCR   Z,RLINK             RETURN IF NOT
EIFTHCHK EQU   *
         C     RWK1,ECFADL         IS BEGINNING @ TOO LOW ?
         BL    EIOC4               YES, SO ERROR
         C     RWK0,ECFADH         IS ENDING @ TOO HIGH ?
         BCR   L,RLINK             RETURN IF NOT (ADDR IS OK)
         B     EIOC4               @ IS TOO HIGH, SO ERROR
*              PERFORM STORE CHECKING
EISTRCHK EQU   *
         C     RWK1,ECFADL         IS BEGINNING @ TOO LOW ?
         BL    EIOC4               YES, SO ERROR
         C     RWK0,ECFADH         IS ENDING @ TOO HIGH ?
         BH    EIOC4               YES, SO ERROR
*              PERFORM MODIFICATION CHECKING
         TM    ECPRFLG1,ECPRMODC   IS MOD CHECK OPTION ON ?
         BCR   Z,RLINK             NO, SO RETURN TO CALLER
         C     RWK1,ECPRMODH       IS BEGINNING @ HIGHER THAN CHK AREA?
         BCR   H,RLINK             RETURN IF YES
         C     RWK0,ECPRMODL       IS ENDING @ LOWER THAN CHECK AREA ?
         BCR   L,RLINK             RETURN IF YES
*              IF HERE, THE INSTRUCTION MODIFIES STORAGE WITHIN THE
*              CHECKING AREA.  PERTINENT INFORMATION IS PRINTED FOR THE
*              USER PROGRAMMER.
         XHEXO RWK0,EICKHIGH       CONVERT HIGH @ TO HEX FOR PRINTING
         MVC   EICKHIGH(2),EIBLANKS  BLANK OUT 1ST 2 DIGITS
         XHEXO RWK1,EICKLOW        CONVERT LOW @ TO HEX FOR PRINTING
         MVC   EICKLOW(2),EIBLANKS   BLANK OUT 1ST 2 DIGITS
         L     RWK1,ECSTIADD       GET INSTRUCTION ADDR
         XHEXO RWK1,EICKINAD       CONVERT INSTR ADDR TO HEX FOR PRNT
         MVC   EICKINAD(2),EIBLANKS  BLANK OUT 1ST 2 DIGITS
         MVC   EICKINST+4(10),EIBLANKS  BLANK OUT INSTR AREA
         LM    RWK0,RWK1,ECSTCCPM  FETCH INSTR FROM INSTR STACK
         SLDL R0,16                RR AND RX CODE IN REG 0
         XHEXO RWK0,EIWORK         CONVERT 1ST 4 BYTES TO HEX
         TM    ECSTINST,EISSINST   IS THISAN SS INSTR ?
         BNO   EINOTSSI            BRANCH IF NOT
         XHEXO RWK1,EIWORK+8       CONVERT LAST 2 BYTES TO HEX
EINOTSSI EQU   *
         LA    RWK1,EICKINST       GET @ OF THE HEX INSTR
         BAL   R2,EIMOVINS         MOVE HEX INSTR TO PRINT FORMAT
         $PRNT EICHKMSG,EICHKMSL,EICNTEXC  PRINT INSTR FOR MOD CHK,    X
                                           BR OUT IF COUNT EXCEEDED
         BR    RLINK               RETURN TO CALLER
*              THE FOLLOWING STORAGE IS USED AS A PRINT FORMAT AREA BY
*              THE MODIFICATION CHECK FACILITY
EICHKMSG DC    C' CHECK-->   INSTR ADDR:'
EICKINAD DC    8C' '
         DC    C'   INSTR:  '
EICKINST DC    14C' '
         DC    C'     MODIFICATION LIMIT ADDRS-->   LOW:'
EICKLOW  DC    8C' '
         DC    C'   HIGH:'
EICKHIGH DC    8C' '
EICHKMSL EQU   *-EICHKMSG          LENGTH OF PRINT MESSAGE
         SPACE 5
**--> INSUB: EIMOVINS     MOVE HEX INSTR TO PRINT FORMAT  + + + + + + +
*+                                                                    +
*+       THIS INSUB MOVES A HEXIDECIMAL INSTRUCTION TO A              +
*+       SPECIFIED AREA WITH BLANKS INSERTED TO RESEMBLE              +
*+       SOURCE CODE LISTING FORMAT.                                  +
*+                                                                    +
*+       ENTRY CONDS:                                                 +
*+             RWK1  -  CONTAINS THE TARGET ADDRESS FOR THE MOVE      +
*+             R2    -  USED AS THE BAL LINK REG                      +
*+             EIWORK-  ASSUMED TO BE THE FETCH AREA FOR THE MOVE     +
*+       EXIT CONDS:                                                  +
*+             R2    -  IS RE-CLEARED AS A BYTE REG                   +
*+             RWK0  &                                                +
*+             RWK1  -  CONTENTS DESTROYED                            +
*+                                                                    +
*++ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
         SPACE 2
EIMOVINS DS  0H
         ST    R2,EIMOVSAV         SAVE RETURN ADDR
         SR    RWK0,RWK0           CLEAR LOOP COUNTER REG
         IC    RWK0,EICTB2         GET INSTR LEN FOR LOOP COUNT
         SRL   RWK0,1              DIVIDE LENGTH BY 2 FOR LOOP CTR
         LA    R2,EIWORK           GET @ OF FETCH AREA
EIMOVEIN EQU   *
         MVC   0(4,RWK1),0(R2)     MOVE 4 HEX BYTES
         LA    RWK1,5(RWK1)        INCREMENT TARGET ADDRESS
         LA    R2,4(R2)            INCREMENT FETCH ADDRESS
         BCT   RWK0,EIMOVEIN       IF CTR ^= 0, CONTINUE LOOP
         L     RWK1,EIMOVSAV       GET RETURN ADDRESS
         SR    R2,R2               CLEAR BYTE REG
         BR    RWK1                RETURN TO CALLER
EIMOVSAV DC    F'0'                RET ADDR SAVED HERE
         SPACE 5
**--> INSUB: EIXOPCHK       CHECK ADDRESSES FOR XOPC INSTRUCTIONS + + +
*+                                                                    +
*+       ENTRY CONDITIONS:                                            +
*+             RWK1  - CONTAINS THE ADDRESS TO BE CHECKED (LOW @)     +
*+             RWK0  - CONTAINS LENGTH-1 OF STORAGE AFFECTED          +
*+             RLINK - INTERNAL LINK REGISTER                         +
*+       EXIT CONDITIONS:                                             +
*+             RWK0  - CONTENTS (LENGTH) DESTROYED, UNLESS            +
*+                     EIXOPCHA IS CALLED WITH RWK0 CONTAINING        +
*+                     THE HIGH ADDRESS --> (LOW @ + LENGTH - 1)      +
*+                                                                    +
*++ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
         SPACE 2
EIXOPCHK EQU   *
         ALR   RWK0,RWK1           COMPUTE HIGH ADDRESS
EIXOPCHA EQU   *
         C     RWK1,ECFADL         IS LOW ADDRESS IN RANGE ?
         BL    EIXOPCC1            NO, BRANCH TO NOTE ERROR
         C     RWK0,ECFADH         IS HIGH ADDRESS IN RANGE ?
         BCR   L,RLINK             YES, SO RETURN
         B     EIXOPCC1            NO, BRANCH TO NOTE ERROR
         LTORG
         SPACE 2
*        TABLE FOR THE XOPC INSTRUCTION DISPLACEMENTS
EIOPCJMP $AL2  EIXOPC,(EIOPC0,EIOPC1,EIOPC2,EIOPC3,EIOPC4,EIOPC5,EIOPC6X
               ,EIOPC7,EIOPC8,EIOPC9,EIOPC10,EIOPC11,EIOPC12,EIOPC13,EIX
               OPC14,EIOPC15,EIOPC16,EIOPC17,EIOPC18,EIOPC19,EIOPC20,EIX
               OPC21,EIOPC22)
         SPACE 2
*              TABLE FOR EXTENDED I/I INSTRUCTION DISPLACEME1T
EIXIOJ   $AL2  EISPEJMP,(EIXREAD,EIXPRNT,EIXPNCH,EIXDUMP,EIXLIMD,EIXGETX
               ,EIXPUT,EIOC1)
.EINOXIO ANOP
         SPACE 2
*              OFF SETS TO COMPLETION CODE MESSAGES
EICOFFS  $AL2  EICC0,(EICC1,EICC2,EICC3,EICC4,EICC5,EICC6,EICC7,EICC8,EX
               ICC9,EICCA,EICCB),-2    STANDARD INTERRUPT POINTERS
         AIF   (NOT &$FLOTE).EIFL6 SKI1IF NO FLOATING INTERRUPTS
         $AL2  EICC0,(EICCC,EICCD,EICCE,EICCF)    FLOATING INTERS
.EIFL6   ANOP
         SPACE 2
*              COMPLETION CODE MESSAGES
EICC0    EQU   *
EICC1    $ERCGN  0C1,'OPERATION'
EICC2    $ERCGN  0C2,'PRIVILEGED OP)RATION'
EICC3    $ERCGN  0C3,'EXECUTE'
EICC4    $ERCGN  0C4,'PROTECTION'
EICC5    $ERCGN  0C5,'ADDRESSING'
EICC6    $ERCGN  0C6,'SPECIFICATION'
EICC7    $ERCGN  0C7,'DATA'
EICC8    $ERCGN  0C8,'FIXED-POINT OVERFLOW'
EICC9    $ERCGN  0C9,'FIXED-POINT DIVIDE'
EICCA    $ERCGN  0CA,'DECIMAL OVERFLOW'
EICCB    $ERCGN  0CB,'DECIMAL DIVIDE'
         AIF   (NOT &$FLOTE).EIFL8   SKIP MESSAGES FOR FLOATING PNT
EICCC    $ERCGN  0CC,'EXPONENT OVERFLOW'
EICCD    $ERCGN  0CD,'EXPONENT UNDERFLOW'
EICCE    $ERCGN  0CE,'SIGNIFICANCE'
EICCF    $ERCGN  0CF,'FLOATING-POINT DIVIDE'
.EIFL8   ANOP
         SPACE 1
EICCREAD $ERCGN  220,'ATTEMPTED READ PAST END-FILE',TYPE=ASSIST
EICCTIME $ERCGN  221,'INSTRUCTION LIMIT EXCEEDED',TYPE=ASSIST
EICCRECE       $ERCGN  222,'RECORD LIMIT EXCEEDED',TYPE=ASSIST
         AIF   (&$TIMER EQ 0).EINOTOC     SKIP IF NO TIMER AT ALL
EICCTIMB $ERCGN  223,'TIME LIMIT EXCEEDED',TYPE=ASSIST
.EINOTOC ANOP
EICCBROU $ERCGN  224,'BRANCH OUT OF PROGRAM AREA',TYPE=ASSIST
         SPACE 2
*              THE FOLLOWING IS THE 256 SECONDARY CONTROL TABLE
*              WHICH CONTAINS INDICES INTO THE MAIN CONTROL TABLE
EIOPCDTB EQU   *
         EIXTAB  2,XOPC,2,2,SPM,BALR,BCTR,BCR                         M
         EIXTAB  PRIVH,PRIVH,PRIVH,2,2,2,MVCL,CLCL                    M
         EIXTAB  NMRR,NMRR,NMRR,NMRR,NMRR,NMRR,NMRR,NMRR
         EIXTAB  LR,NMRR,NMRR,NMRR,MRDR,MRDR,NMRR,NMRR
         EIXTAB  FPRR,FPRR,FPRR,FPRR,FPRR,FPRR,FPRR,FPRR
         EIXTAB  FPRR,FPRR,FPRR,FPRR,FPRR,FPRR,FPRR,FPRR
         EIXTAB  FPRR,FPRR,FPRR,FPRR,FPRR,FPRR,FPRR,FPRR
         EIXTAB  FPRR,FPRR,FPRR,FPRR,FPRR,FPRR,FPRR,FPRR
         EIXTAB  STH,LA,STC,IC,EX,BAL,BCT,BC
         EIXTAB  NMRXH,NMRXH,NMRXH,NMRXH,NMRXH,4,CVD,CVB
         EIXTAB  ST,4,DECO,DECI,NMRXF,NMRXF,NMRXF,NMRXF
         EIXTAB  NMRXF,NMRXF,NMRXF,NMRXF,MD,MD,NMRXF,NMRXF
         EIXTAB  FPRS,HEXI,HEXO,4,4,4,4,XFPRF
         EIXTAB  FPRF,FPRF,FPRF,FPRF,FPRF,FPRF,FPRF,FPRF
         EIXTAB  FPRS,4,4,4,4,4,4,4
         EIXTAB  FPRF,FPRF,FPRF,FPRF,FPRF,FPRF,FPRF,FPRF
         EIXTAB  PRIVF,4,PRIVF,DIAG,PRIVF,PRIVF,BXH,BXLE              M
         EIXTAB  SHFTS,SHFTS,SHFTS,SHFTS,SHFTD,SHFTD,SHFTD,SHFTD
         EIXTAB STM,NMSIF,NMSIS,NMSIS,NMSIS,NMSIF,NMSIS,NMSIS
         EIXTAB  LM,4,4,4,PRIVF,PRIVF,PRIVF,PRIVF                     M
         EIXTAB  4,4,4,4,4,4,4,4
         EIXTAB  4,4,4,4,PRIVF,PRIVF,4,PRIVF                          M
         EIXTAB  4,PRIVF,PRIVF,4,4,4,PRIVF,PRIVF                      M
         EIXTAB  4,4,4,4,4,CLM,STCM,ICM
         EIXTAB  6,6,6,6,6,6,6,6
         EIXTAB  6,6,6,6,6,6,6,6
         EIXTAB 6,MOVES,MOVES,MOVES,LOGS,LOGFS,LOGS,LOGS
         EIXTAB  6,6,6,6,TR,TRT,MOVES,EDMK
         EIXTAB  XTND,DUMPR,6,6,6,6,6,6                               L
         EIXTAB  6,6,6,6,6,6,6,6
         EIXTAB  SRP,MVO,PACK,UNPK,6,6,6,6
         EIXTAB  DECS,CP,DECS,DECS,DECS,DECS,6,6
         TITLE '*** EXECUT - MAIN CONTROL TABLE'
*              THE FOLLOWING IS THE MAIN CONTROL TABLE FOR THE
*              EXTENDED INTERPRETER
EICONTAB DS    0F                                                     L
EIT2     DC    X'00020000',4X'00'                                     L
EIT4     DC    X'00040000',4X'00'                                     L
EIT6     DC    X'00060000',4X'00'                                     L
         EITAB  NMRR,360,2,*,NO,NM,**,*,*,RR4,**,***,O,O,EINORMRR
         EITAB    LR,360,2,*,NO,NM,**,*,*,RR4,**,***,O,O,EILR
         EITAB  BALR,360,2,*,NO,NM,**,*,*,RR4,**,***,O,O,EIBALR
         EITAB  BCTR,360,2,*,NO,NM,**,*,*,RR4,**,***,O,O,EIBCTR
         EITAB   BCR,360,2,*,NO,NM,**,*,*,RR4,**,***,O,O,EIBCR
         EITAB  FPRR,360,2,*,NO,NM,**,*,*,RR4,**,***,O,O,EIFPRR
         EITAB  CLCL,370,2,*,NO,NM,NO,F,F,RR4,**,***,E,E,EILONG
         EITAB  MVCL,370,2,*,NO,NM,NO,S,F,RR4,**,***,E,E,EILONG
         EITAB   SPM,360,2,*,NO,NM,**,*,*,RR4,**,***,O,O,EISPM
         EITAB  MRDR,360,2,*,NO,NM,**,*,*,RR4,**,***,E,O,EIMRDR
         EITAB PRIVH,360,2,*,PR,NM,**,*,*,IOL,**,***,O,O,EILCTL       M
         EITAB NMRXF,360,4,4,NO,NM,CK,F,*,RR4,IX,FUL,O,O,EINORMRX
         EITAB    IC,360,4,1,NO,NM,CK,F,*,RR4,IX,NON,O,O,EINORMRX
         EITAB NMRXH,360,4,2,NO,NM,CK,F,*,RR4,IX,HAF,O,O,EINORMRX
         EITAB   CVB,360,4,8,NO,NM,CK,F,*,RR4,IX,DBL,O,O,EINORMRX
         EITAB   BAL,360,4,*,NO,NM,NO,*,*,RR4,IX,NON,O,O,EIBAL
         EITAB   BCT,360,4,*,NO,NM,NO,*,*,RR4,IX,NON,O,O,EIBCT
         EITAB    BC,360,4,*,NO,NM,NO,*,*,RR4,IX,NON,O,O,EIBC
         EITAB    LA,360,4,*,NO,NM,CK,*,*,RR4,IX,NON,O,O,EILA
         EITAB    EX,360,4,*,NO,NM,CK,F,*,RR4,IX,HAF,O,O,EIEX
         EITAB    MD,360,4,4,NO,NM,CK,F,*,RR4,IX,FUL,E,O,EIMD
         EITAB   STH,360,4,2,NO,NM,CK,S,*,RR4,IX,HAF,O,O,EISTORS
         EITAB   CVD,360,4,8,NO,NM,CK,S,*,RR4,IX,DBL,O,O,EISTORS
         EITAB   STC,360,4,1,NO,NM,CK,S,*,RR4,IX,NON,O,O,EISTORS
         EITAB    ST,360,4,4,NO,NM,CK,S,*,RR4,IX,FUL,O,O,EISTORS
         EITAB  FPRF,360,4,4,NO,NM,CK,F,*,RR4,IX,FUL,E,O,EIFPRX
         EITAB  FPRS,360,4,4,NO,NM,CK,S,*,RR4,IX,FUL,E,O,EIFPRXST CEH
         EITAB XFPRF,360,4,8,NO,NM,CK,F,*,RR4,IX,DBL,E,O,EIFPRX
         EITAB XFPRS,360,4,8,NO,NM,CK,S,*,RR4,IX,DBL,E,O,EIFPRXST CEH
         EITAB NMSIS,360,4,1,NO,NM,CK,S,*,IOL,BD,NON,*,*,EINORMSI
         EITAB NMSIF,360,4,1,NO,NM,CK,F,*,IOL,BD,NON,*,*,EINORMSI
         EITAB  DIAG,360,4,1,NO,NM,NO,*,*,IOL,BD,NON,*,*,EIDIAG
         EITAB   BXH,360,4,*,NO,NM,NO,N,*,RR4,BD,NON,O,O,EIRSBX
         EITAB BXLE,360,4,*,NO,NM,NO,N,*,RR4,BD,NON,O,O,EIRSBX
         EITAB    LM,360,4,*,NO,NM,NO,F,*,RR4,BD,FUL,O,O,EILMSTM
         EITAB   STM,360,4,*,NO,NM,NO,S,*,RR4,BD,FUL,O,O,EILMSTM
         EITAB SHFTS,360,4,*,NO,NM,NO,N,*,RR4,BD,NON,O,O,EISHIFT
         EITAB SHFTD,360,4,*,NO,NM,NO,N,*,RR4,BD,NON,E,O,EISHIFT
         EITAB   ICM,370,4,4,NO,NM,CK,F,*,RR4,BD,NON,O,O,EIICM
         EITAB  STCM,370,4,4,NO,NM,CK,S,*,RR4,BD,NON,O,O,EISTCM
         EITAB   CLM,370,4,4,NO,NM,CK,F,*,RR4,BD,NON,O,O,EICLM
         EITAB PRIVF,360,4,*,PR,NM,**,*,*,IOL,**,***,O,O,EILCTL       M
         EITAB MOVES,360,6,0,NO,NM,CK,S,F,IOL,BD,NON,*,*,EIMOVES
         EITAB   MVO,360,6,0,NO,NM,CK,S,F,LL1,BD,NON,*,*,EIMOVES
         EITAB  LOGS,360,6,0,NO,NM,CK,S,F,IOL,BD,NON,*,*,EILOGS
         EITAB  LOGFS,360,6,0,NO,NM,CK,F,F,IOL,BD,NON,*,*,EILOGS
         EITAB    TR,360,6,0,NO,NM,CK,S,F,IOL,BD,NON,*,*,EIMOVES
         EITAB  PACK,360,6,0,NO,NM,CK,S,F,LL1,BD,NON,*,*,EIMOVES
         EITAB  UNPK,360,6,0,NO,NM,CK,S,F,LL1,BD,NON,*,*,EIMOVES
         EITAB  DECS,360,6,0,NO,NM,CK,S,F,LL1,BD,NON,*,*,EIDECS
         EITAB    CP,360,6,0,NO,NM,CK,F,F,LL1,BD,NON,*,*,EIDECS
         EITAB   TRT,360,6,0,NO,NM,CK,F,F,IOL,BD,NON,*,*,EITRT
         EITAB  EDMK,360,6,0,NO,NM,CK,S,F,IOL,BD,NON,*,*,EIEDMK
         EITAB   SRP,370,6,0,NO,NM,CK,S,N,LL1,BD,NON,*,*,EISRP
         EITAB  XTND,*,*,*,*,EX,*,*,*,*,*,*,*,*,EI2EXTAB
*        ONLY LENGTH AND OPCODE REQ FOR REGISTER XDUMP                L
         EITAB DUMPR,360,6,*,NO,NM,**,*,*,*,*,*,*,*,EIXDUMPR          L
         EITAB  HEXI,360,4,8,NO,NM,CK,F,*,RR4,IX,NON,O,O,EIXHEXI      M
         EITAB  HEXO,360,4,8,NO,NM,CK,S,*,RR4,IX,NON,O,O,EIXHEXO      M
         EITAB  DECI,360,4,8,NO,NM,CK,F,*,RR4,IX,NON,O,O,EIXDECI      M
         EITAB  DECO,360,4,12,NO,NM,CK,S,*,RR4,IX,NON,O,O,EIXDECO     M
         EITAB  XOPC,360,2,*,NO,NM,**,*,*,IOL,**,***,*,*,EIXOPC       M
***********************************************************************
*                                                                     *
*        THE FOLLOWING BLOCK OF STMTS DESCRIBES A SINGLE ENTRY        *
*        OF THE OPTIONAL INTERPRETER MAIN CONTROL TABLE               *
*                                                                     *
***********************************************************************
*                                                                     *
*        NOTES ON THE DESIGN OF THE MAIN INTERPRETER TABLE            *
*        -------------------------------------------------            *
*                       (AND SUB-TABLES)                              *
*                                                                     *
*     => IMPORTANT:  THIS SHOULD BE REQUIRED READING FOR ANYONE       *
*        NEEDING TO UNDERSTAND AND/OR MODIFY THIS TABLE SCHEME.       *
*                                                                     *
*             A 256 BYTE TABLE (1 BYTE PER POSSIBLE OPCODE) OF        *
*        POINTERS ALLOW EASY ACCESS TO INSTRUCTION DECODING           *
*        INFORMATION BY INDEXING INTO A LARGER MAIN TABLE             *
*        DESCRIBED BELOW.                                             *
*             THE OPTIONAL ASSIST INTERPRETER'S MAIN CONTROL TABLE    *
*        (NAMED: EICONTAB) CONTAINS ONE ENTRY FOR EACH POSSIBLE       *
*        TYPE OF INSTRUCTION DECODING.  EACH 8 BYTE ENTRY CONTAINS    *
*        APPROPRIATE FLAGS AND OTHER INFORMATION (AS DESCRIBED        *
*        BELOW) TO CONTROL EACH STEP OF THE SPECIFIC INSTRUCTION      *
*        DECODING PROCESS.                                            *
*             THE FIRST THREE COMPLETE ENTRIES OF EICONTAB WILL       *
*        BE ALL ZEROS EXCEPT THE INSTRUCTION LENGTH BITS.  THE        *
*        FIRST ENTRY'S INSTRUCTION LENGTH WILL BE EQUAL TO TWO,       *
*        THE SECOND'S WILL EQUAL FOUR AND THE THIRD'S WILL EQUAL      *
*        SIX.  ALL ILLEGAL OPCODES (IN EIOPCDTB, THE 256 BYTE         *
*        TABLE DESCRIBED ABOVE) WILL POINT TO THE ENTRY WHOSE         *
*        INSTRUCTION LENGTH CORRESPONDS TO THE HIGH ORDER TWO BITS    *
*        OF THE OPCODE ITSELF.                                        *
*             FOR EXTENDED OPCODES (S-TYPE & PSEUDO-INSTRUCTIONS)     *
*        THE ENTRY IN EICONTAB WILL BE MARKED 'OPCODE-DOES-NOT-       *
*        TELL-ALL' AND WILL CONTAIN INFORMATION CONCERNING ACCESS     *
*        TO A SUB-TABLE GIVING ALL NECESSARY INFORMATION ABOUT        *
*        INSTRUCTION DECODING.  SEE EQUATES BELOW.                    *
*                                                                     *
***********************************************************************
*
EICTNTRY DS    0D                  MOVE CONTROL TABLE ENTRY HERE
*              FLAG BYTES -- CONTAIN INSTR DECODING INFORMATION AS
*              DESCRIBED BY EQUATES BELOW
EICTB1   DS    B                   FLAG BYTE 1
EICTB2   DS    B                   FLAG BYTE 2
EICTB3   DS    B                   FLAG BYTE 3
EICTB4   DS    B                   FLAG BYTE 4
EICTB5   DS    B                   FLAG BYTE 5
EICTB6   DS    B                   FLAG BYTE 6
EICTDISP DS    H                   DISPLACEMENT FOR BRANCHING TO       X
                                   SPECIAL ROUTINE
EICTE$L  EQU   *-EICTNTRY          LENGTH OF A SINGLE TABLE ENTRY
*              MISCELLANEOUS EQUATES
EIEXTTAB EQU   EICTB5              ADDRESS OF EXTENDED OP CODE TABLE
EI360PLS EQU   B'00001100'         (EICTB1)==> 360 & 370 INSTR
EI370ONL EQU   B'00001000'         (EICTB1)==> 370 INSTR ONLY
EIRR     EQU   B'00100000'         (EICTB1)==> THIS IS AN RR INSTR
EIPRIVOP EQU   B'01000000'         (EICTB1)==>  THIS IS A PRIVILEGED   X
                                                INSTRUCTION
EIEXOPCD EQU   B'10000000'         (EICTB1)==>  OPCODE DOES NOT TELL   X
                                                ALL (EXTENDED OPCODE)
EINOCNOW EQU   B'00010000'         (EICTB1)==>  DO PERFORM MOD/ST/FTCH X
                                                CHECKING AT EINOCHK
*              EQUATES FOR INSTRUCTION LENGTH CODE
*              **** NOTE ****  NO OTHER FLAGS CAN BE ADDED TO EICTB2
EILEN2   EQU   B'00000010'         (EICTB2)==>  LENGTH=2 BYTES
EILEN4   EQU   B'00000100'         (EICTB2)==>  LENGTH=4 BYTES
EILEN6   EQU   B'00000110'         (EICTB2)==>  LENGTH=6 BYTES
*              EQUATES FOR MODIFICATION OR FETCH CHECKING
*              --- FOR FIRST OPERAND
EI1NOCHK EQU   B'00000000'         (EICTB3)==>  NO CHECKING
EI1FETCH EQU   B'01000000'         (EICTB3)==>  FETCH CHECKING
EI1STORE EQU   B'11000000'         (EICTB3)==>  STORE CHECKING
*              --- FOR SECOND OPERAND
EI2NOCHK EQU   B'00000000'         (EICTB3)==>  NO CHECKING
EI2FETCH EQU   B'00010000'         (EICTB3)==>  FETCH CHECKING
EI2STORE EQU   B'00110000'         (EICTB3)==>  STORE CHECKING
*              EQUATES FOR INSTR DECODING (2ND BYTE OF INSTR)
EIB2RRX4 EQU   B'00000000'         (EICTB3)==>  2 REGS (MULT BY 4)
EIB2LLX1 EQU   B'00000001'         (EICTB3)==>  2 LENGTHS (NO MULT)
EIB2IORL EQU   B'00000011'         (EICTB3)==>  1 LENGTH OR IMMED FLD
*              EQUATES FOR INSTR DECODING (2ND HALFWORD OF INSTR)
EIH2NODX EQU   B'00000100'         (EICTB3)==>  BASE+DISP ONLY (OTHER- X
                                   WISE INDEX+(BASE+DISP))
*              NOTE IF THIS IS A BRANCH INSTRUCTION
EIBRINST EQU   B'00001000'         (EICTB3)==> THIS IS A NON-RR BR INST
*              EQUATES FOR OPERAND ALIGNMENT
*              ***** NO OTHER FLAGS ALLOWED IN EICTB4 *****
EIALNONE EQU   B'00000000'         (EICTB4)==>  NO ALIGNMENT NEEDED
EIALHALF EQU   B'00000001'         (EICTB4)==>  HALFWORD ALIGNMENT
EIALFULL EQU   B'00000011'         (EICTB4)==>  FULLWORD ALIGNMENT
EIALDOBL EQU   B'00000111'         (EICTB4)==>  DOUBLE-WORD ALIGNMENT
*              EQUATES FOR EVEN/ODD REGISTER CHECKING
*              (THIS BYTE CAN NOT CONTAIN ANY OTHER FLAGS)
EINEREG1 EQU   B'00000000'         (EICTB5)==> REG1 CAN BE ODD
EIEVREG1 EQU   B'00010000'         (EICTB5)==> REG1 MUST BE EVEN
EINEREG2 EQU   B'00000000'         (EICTB5)==> REG2 CAN BE ODD
EIEVREG2 EQU   B'00000001'         (EICTB5)==> REG 2 MUST BE EVEN
*              EQUATES FOR INSTR MOD/FETCH LENGTH
*
*              NOTE *****  THE UPPER NIBBLE OF THIS BYTE SHOULD ONLY
*              BE USED WHEN ABSOLUTELY NECESSARY.  IF IT IS USED,
*              THEN THE FOLLOWING INSTR MUST BE PLACED BETWEEN THE
*              IC AND LTR INSTRS FOLLOWING LABEL => EINOCHK:
*                   N     R2,=XL4'0F'
*
EIMFLENG EQU   B'00001111'        (EICTB6)==> LOWER NIBBLE HAS LENGTH
*
***********************************************************************
*                                                                     *
*        THE FOLLOWING EQUATES ARE USED FOR EXTENDED OPCODE           *
*        TABLE ENTRY FETCHING:                                        *
*                                                                     *
***********************************************************************
*                                                                     *
******** IMPORTANT NOTES FOR EXTENDED OPCODE INSTRUCTIONS *************
*                                                                     *
*        THE MAIN TABLE (EICONTAB) ENTRY FOR AN EXTENDED OPCODE       *
*        WILL CONTAIN THE ACTUAL 4 BYTE ADDRESS OF THE SECONDARY      *
*        TABLE CONTAINING DECODING ENTRIES FOR THE EXTENDED OPCODE    *
*        INSTRUCTION.                                                 *
*                                                                     *
*        THE FIRST 8 BYTE ENTRY OF THE SECONDARY TABLE WILL           *
*        CONTAIN A BYTE HAVING THE # OF BITS TO SHIFT THE 2ND         *
*        BYTE OF THE INSTRUCTION TO OBTAIN AN INDEX INTO THE          *
*        BYTE TABLE FOLLOWING THE 1ST ENTRY.  ALSO IN THE 1ST ENTRY   *
*        WILL BE A FULLWORD COMPARATOR GIVING THE MAXIMUM INDEX       *
*        VALUE THAT IS LEGAL.                                         *
*                                                                     *
*        THE BYTE TABLE FOLLOWING THE 1ST ENTRY WILL CONTAIN AS       *
*        MANY SINGLE BYTE ENTRIES AS NECESSARY.  EACH ENTRY WILL BE   *
*        A DISPLACEMENT FROM THE BEGINNING OF THE TABLE TO THE        *
*        CORRECT TABLE ENTRY FOR THE PARTICULAR INSTRUCTION.  IF      *
*        THE BYTE IS ZERO THEN THE INSTRUCTION IS NOT IMPLEMENTED     *
*        AND AN OC-1 INTERRUPT WILL BE FLAGGED.                       *
*                                                                     *
***********************************************************************
*
*                   SECONDARY EXTENDED OPCODE TABLE                   *
*  THIS TABLE IS AN EXTENSION OF THE MAIN DECODING TABLE AND IS       *
*  STRICTLY RESERVED FOR THE EXTENDED OPCODE INSTRUCTIONS -- THOSE    *
*  WITH AN OPCODE OF 'EO'.  BY SHIFTING THE SECOND BYTE OF THE        *
*  INSTRUCTIONS 5 BITS TO THE RIGHT, AN INBEX TO BYTE TABLE -- SECOND *
*  8 BYTES OF THIS TABLE -- IS ESTABLISHED WHERE A DISPLACEMENT TO    *
*  THE PROPER INSTRUCTION DECODING ENTRY IS LOCATED. THE FIRST 8 BYTES*
*  OF THE SECONDARY DECODING TABLE IS EXPLAINED ABOVE.                *
         SPACE 2
EI2EXTAB DS    0F                  SECONDARY EXTENDED DECODING TABLE
*              EXTENDED OPCODE TABLE EQUATES
*              --> 1ST 8 BYTE ENTRY
EIMAXIND EQU   4                   POSITION OF MAX INDEX VALUE ALLOWED X
                                   (THIS IS A FULLWORD)
EI#SHIFT EQU   3                   POS OF SHIFT BYTE IN 1ST TAB ENTRY
         DC    XL3'0',X'5'         BYTE 3 = # BITS TO SHIFT MASK
         DC    F'8'                MAXIMUM INDEX LIMIT
         DC    X'1018202830384000' DISPLACEMENTS FROM EI2EXTAB
         EITAB READ,360,6,0,NO,NM,CK,S,*,RR4,IX,NON,O,O,EIXIOS
         EITAB PRNT,360,6,0,NO,NM,CK,F,*,RR4,IX,NON,O,O,EIXIOS
         EITAB PNCH,360,6,0,NO,NM,CK,F,*,RR4,IX,NON,O,O,EIXIOS
         EITAB DUMP,360,6,0,NO,NM,CK,F,*,RR4,IX,NON,O,O,EIXIOS
         EITAB LIMD,360,6,0,NO,NM,CK,*,*,RR4,IX,NON,O,O,EIXIOS
         EITAB  GET,360,6,0,NO,NM,CK,S,*,RR4,IX,NON,O,O,EIXIOS
         EITAB  PUT,360,6,0,NO,NM,CK,F,*,RR4,IX,NON,O,O,EIXIOS
.EINONE  ANOP
//*
//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
//* STEP 2 - APPLY CHANGES TO SOURCE IN TEMPORARY DATASETS.
//*          (MAKE ANY DESIRED CHANGES TO THE STATEMENTS BELOW.)
//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
//*
//UPDATEA.SYSIN DD *
./ CHANGE
&$GENDAT SETC  '&SYSDATE'          CURRENT GENERATION DATE            J
&$IDF    SETA  20000000            LARGE VAL - USE TIMER INSTEAD
&$IMX    SETA  20000000            LARGE VAL - USE TIMER INSTEAD
&$SYSTEM SETC  'OS-MVS'            SYSTEM IS OS OPTION MVS
&$S370   SETA  1                   S/370 INSTRUCTION SET
&$VERSLV SETC  '4.0/A2'            CURRENT ASSIST VERSION             J
&$IOUNIT(2)  SETC  'SYSIN2  '      SET OS SECONDARY INPUT
&$IOUNIT(3)  SETC  'SYSPRINT'      SET OS PRINTER
&$IOUNIT(4)  SETC  'SYSPUNCH'      SET OS PUNCH
&$IOUNIT(5)  SETC  'SYSUT1  '      SET OS DISK INTERMEDIATE
//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
//* THE CHANGES BELOW WERE REQUIRED TO CORRECT SOME PROBLEMS IN THE
//* ORIGINAL SOURCE.  YOU SHOULD NOT MAKE CHANGES HERE YOURSELF.
//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
//UPDATEB.SYSIN DD *
./ CHANGE
&XSAVE   DC    18F'0'  .           SAVE AREA
         LH    RA,CNDOCNT          GET LENGTH-1 CURRENTLY READY
.UTE1A1  ANOP
         TITLE '*** ECBRSTKD - DSECT FOR THE EXT''D INT BRANCH STACK'
         END
//*
//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
//* STEP 3 - ASSEMBLE AND LINK-EDIT ASSIST.
//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
//*
//ASM      EXEC ASMFCL,REGION.ASM=4096K,
//             PARM.ASM='LOAD,NODECK,LIST,NOXREF',
//             MAC1='SYS1.AMODGEN'
//ASM.SYSUT1 DD UNIT=SYSDA,SPACE=(1700,(1500,500))
//ASM.SYSUT2 DD UNIT=SYSDA,SPACE=(1700,(1500,500))
//ASM.SYSUT3 DD UNIT=SYSDA,SPACE=(1700,(1500,500))
//ASM.SYSPRINT DD SYSOUT=*
//ASM.SYSGO DD UNIT=SYSDA,SPACE=(80,(1500,100))
//ASM.SYSIN DD DSN=&&ASSRCM1,DISP=(OLD,DELETE)
//          DD DSN=&&ASSRCM2,DISP=(OLD,DELETE)
//LKED.SYSLMOD DD DSN=SYS2.LINKLIB,DISP=SHR      <== TARGET LIBRARY
//LKED.SYSUT1 DD SPACE=(1024,(250,20))
//LKED.SYSPRINT DD SYSOUT=*
//LKED.SYSIN DD *
  NAME ASSIST(R)
//*
//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
//* STEP 4 - ADD X??? MACROS TO SYS1.MACLIB.
//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
//*
//MACROS   EXEC PGM=IEBUPDTE,PARM=NEW
//SYSPRINT DD  SYSOUT=*
//SYSUT2   DD  DISP=SHR,DSN=SYS1.MACLIB          <== TARGET LIBRARY
//SYSIN    DD  *
./ ADD LEVEL=40,SOURCE=0,NAME=EQUREGS
         MACRO
&LABEL   EQUREGS &L=R,&DO=(0,15,1),&SYM=
.*--> MACRO: EQUREGS    GENERATE SYMBOLIC REGISTER EQUATES  . . . . . .
.*                                 JOHN R. MASHEY/JULY'69/PSU 360/67  *
.*       MACRO FOR SETTING UP SETS OF REGISTER EQUATES.               *
.*       *** ARGUMENTS ***                                            *
.*       L=        SYMBOL USED TO BEGIN EQUATES, SUCH AS R, REG,ETC.  *
.*       DO=       (INITIAL,LIMIT,INCREMENT) WILL SET UP REGISTERS    *
.*             EQUATED TO THE VALUE AS CONTROLLED BY THE DO PARAMATER.*
.*             BEHAVES LIKE FORTRAN DO, INCLUDING ABILITY TO LEAVE OUT*
.*             INCREMENT.                                             *
.*       SYM=      LIST OF SYMBOLS TO BE CONCATENATED TO L PARM.      *
.*             LIST WILL SET UP EQUATES INCLUDING SYM VALUES, FOR     *
.*             FIRST SET OF EQUATES IN LIST, AND WILL THEN SET UP     *
.*             NUMERIC EQUATES IF DO VALUES EXCEED NUMBER OF ELEMENTS *
.*             IN SYM OPERAND.  MAY BE OMITTED ENTIRELY.              *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         LCLA  &I,&J,&K            COUNTER,INCREMENT,SYM COUNTER
         AIF   (N'&DO LT 2).XERROR           NOT ENOUGH ARGUMENTS-ERR
&K       SETA  1                   INIT
&I       SETA  &DO(1)              SET TO INITIAL VALUE
&J       SETA  1                   SET TO DEFAULT VALUE
         AIF   (N'&DO LT 3).XLOOP            DEFAULT VALUE IS OK
&J       SETA  &DO(3)              USE VALUE PROVIDED
.XLOOP   AIF   ('&SYM(&K)' EQ '').XLOOP1     USE NUMBER IF NO SYM VAL
&L&SYM(&K) EQU &I
&K       SETA  &K+1      INCREMENT TO GET NEXT SYM OPERAND
         AGO   .XLOOP2             SKIP OVER NORMAL GENRATION
.XLOOP1  ANOP
&L&I     EQU   &I
.XLOOP2  ANOP
&I       SETA  &I+&J               ADD INCREMENT TO COUNTER
         AIF   (&I LE &DO(2)).XLOOP          CONTINUE UNTIL DONE
         MEXIT
.XERROR  MNOTE 0,'** ERROR - EQUREGS REQUIRES AT LEAST 2 VALUES IN DO'
         MEND
./ ADD LEVEL=40,SOURCE=0,NAME=XCHAR
         MACRO
         XCHAR &STRING,&NUM
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XCHAR      RETURN SAFE RIGHT-END SUBSTRING OF A STRING.  *
.*                                     JOHN R. MASHEY-JULY 1969-360/67*
.*       THIS MACRO RETURNS IN &XXCHAR THE &NUM CHARACTERS TAKEN FROM *
.*       THE RIGHT END OF THE CHARACTER STRING &STRING, WITHOUT       *
.*       BLOWING UP IF THERE ARE LESS THAN &NUM CHARS IN &STRING.     *
.*       THIS MACRO IS USED BY XSAVE,XRETURN, AND XSRNR               *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLC  &XXCHAR             RETURN RESULT IN THIS
         AIF   (&NUM GT K'&STRING).XGA       SKIP IF HE WANTS MORE
&XXCHAR  SETC  '&STRING'(K'&STRING+1-&NUM,&NUM)        SCOOP RIGHT AMT
         MEXIT
.XGA     ANOP
&XXCHAR  SETC  '&STRING'           STRING SMALLER-USE WHOLE THING
         MEND
./ ADD LEVEL=40,SOURCE=0,NAME=XDECI
         MACRO
&LABEL   XDECI &REG,&ADDRESS
.*--> MACRO: XDECI      EXTENDED DECIMAL INPUT CONVERSION * * * * * * *
.*             EXTENDED DECIMAL INPUT MACRO - ENABLES PROGRAMS        *
.*       WRITTEN FOR ASSIST TO BE RUN UNDER OS/360 DIRECTLY.          *
.*       USES MODULE XXXXDECI TO SCAN DECIMAL STRING BEGINNING AT     *
.*       &ADDRESS, CONVERT ITS VALUE INTO REGISTER &REG, AND SET      *
.*       REGISTER R1 AS A SCAN POINTER TO THE DELIMITER FOLLOWING THE *
.*       STRING OF DECIMAL DIGITS.  THE CONDITION CODE IS SET BY THE  *
.*       VALUE IN &REG, UNLESS AN ERROR OCCURRS, IN WHICH CASE CC=3.  *
.*       SEE ASSIST USER MANUAL FOR USAGE INSTRUCTIONS.               *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         LCLC  &XLABL              FOR CREATION OF LABEL
&XLABL   SETC  'XX&SYSNDX.E'       CREATE UNIQUE LABEL
         CNOP  2,4  .              LINE UP ON BOUNDARY
&LABEL   STM   14,1,&XLABL  .      SAVE LINKAGE REGS
         LA    0,&ADDRESS .        BEGINNING @ FOR SCANNING
         L     15,&XLABL-4  .      GET ADCON FOR CONVERSION
         BALR  14,15 .             CALL ROUTINE, PT WITH R14
         DC    V(XXXXDECI) .       ADCON FOR CONVERSION ROUTINE
&XLABL   DS    5F .                REGS 14,15,0,1, VALUE FOR &REG
         LM    14,1,4(14) .        RELOAD REGS
         BO    *+8 .               BRANCH IF &REG SHOULDN'T CHANGE
         L     &REG,&XLABL+16  .   GET VALUE FOR &REG
         AIF   (T'&REG EQ 'N' AND '&REG' NE '1').XXEXIT SKIP IF SAFE
         L     1,&XLABL+12  .      USER MAY HAVE REG=1, LOAD FOR SAFE
.XXEXIT  MEND
./ ADD LEVEL=40,SOURCE=0,NAME=XDECO
         MACRO
&LABEL   XDECO &REG,&ADDRESS
.*--> MACRO: XDECO      EXTENDED DECIMAL OUTPUT CONVERSION* * * * * * *
.*       USES MODULE XXXXDECO TO CONVERT VALUE IN REGISTER &REG TO    *
.*       AN EDITED 12-BYTE FIELD, WITH SIGN, AT LOCATION &ADDRESS.    *
.*             EXTENDED DECIMAL OUTPUT MACRO - ENABLES PROGRAMS       *
.*       WRITTEN FOR ASSIST TO BE RUN UNDER OS/360 DIRECTLY.          *
.*       SEE ASSIST USER MANUAL FOR USAGE INSTRUCTIONS.               *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         LCLC  &XLABL              FOR CREATION OF UNIQUE LABEL
&XLABL   SETC  'XX&SYSNDX.D'       CREATE UNIQUE LABEL
         CNOP  2,4 .               LINE UP ON RIGHT BOUNDARY
&LABEL   STM   14,0,&XLABL  .      STORE LINKAGE REGS
         ST    &REG,&XLABL+12  .   SAVE VALUE TO BE CONVERTED
         LA    0,&ADDRESS .        OBTAIN @ OPERAND FILED
         L     15,&XLABL-4  .      GET ADCON FOR CONVERSION PROG
         BALR  14,15 .             CALL XXXXDECO, PT R14
         DC    V(XXXXDECO) .       ADCON FOR CONVERSION PROG
&XLABL   DS    4F .                REGS 14,15,0, REG TO BE CONVERTED
         LM    14,0,4(14) .        RELOAD LINKAGE REGISTERS
         MEND
./ ADD LEVEL=40,SOURCE=0,NAME=XDUMP
         MACRO
&LABEL   XDUMP &AREA,&LENGTH
.*--> MACRO: XDUMP      ASSIST COMPATIBILITY DUMP MACRO . . . . . . . .
.*             MACRO FOR STORAGE AND REGISTER DUMPING. ENABLES        *
.*       PROGRAMS WRITTEN FOR ASSIST TO BE RUN DIRECTLY UNDER OS/360. *
.*       SEE ASSIST USER MANUAL FOR USAGE *
.*       *NOTE* USES XSNAP, SO REQUIRES XSNAPOUT DD SYOUT=A CARD.     *
.*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         AIF   (T'&AREA EQ 'O').XREGS   SKIP TO REGS IF NO OPS
         AIF   (T'&LENGTH EQ 'O').XSTDF DEFAULT LENGTH IF NONE
.*             DUMP STORAGE, USING SUPPLIED LENGTH &LENGTH.
&LABEL   XSNAP T=NO,LABEL='USER STORAGE',                              #
               STORAGE=(*&AREA,*&LENGTH+&AREA)
         MEXIT
.*             DUMP STORAGE, USING DEFAULT LENGTH OF 4.
.XSTDF   ANOP
&LABEL   XSNAP T=NO,LABEL='USER STORAGE',                              #
               STORAGE=(*&AREA,*4+&AREA)
         MEXIT
.*             &AREA,&LENGTH OMITTED --> DUMP REGISTERS.
.XREGS   ANOP
&LABEL   XSNAP LABEL='USER REGISTERS'
         MEND
./ ADD LEVEL=40,SOURCE=0,NAME=XGET
         MACRO
&XLABEL  XGET  &XAREA,&XNUM
.*--> MACRO: XGET    GET RECORD OFF OF &DDNAME FILE . . . . . . . . . *
.*                                 RICHARD FOWLER AUG, 1972 V.5.0     *
.*       MACRO FOR EASY READING OFF OF ANY DD FILE, READS &XNUM       *
.*       CHARACTERS. CONDITION CODE SET TO 0 NORMALLY, OR TO 1 ON     *
.*       END OF FILE. GENERATION CONTROLLED BY &XGETST.               *
.*       EXECUTION ASSUMES REG 1 POINTS TO DD NAME                    *
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **
         GBLB  &XGETST             GENERATION STATUS- 0=YES, 1=NO
         AIF   (&XGETST).XNOGEN    IF SHOULDN'T GENERATE-SKIP CALL
&XLABEL  XIONR XXXXGET,&XNUM,&XAREA,80
         MEXIT
.XNOGEN  AIF   (T'&XLABEL EQ 'O').XXEXIT     GEN LABEL ONLY IF NEEDED
&XLABEL  DS    0H .                LABEL FOR CANCELLED XGET
.XXEXIT  MEND
./ ADD LEVEL=40,SOURCE=0,NAME=XGPGEN
         MACRO
&LABEL   XGPGEN &DIREC=G,&FETCH=NOT,&DDNUM=20
.** --> MACRO: XGPGEN  GENERATE GENERAL I/O MODULES . . . . . . . . . .
.*                                    RICHARD FOWLER NOV, 1972 V.5.0  .
.*                                                                    .
.*       ARGUMENTS:                                                   .
.*             &DIREC = P --> OUTPUT                                  .
.*                   ^= P --> INPUT                                   .
.*             &FETCH  =NOT --> NO FETCH PROTECTION                   .
.*                    ^=NOT -->    FETCH PROTECTION                   .
.*             &DDNUM = MAXIMUM NUMBER OF DD NAMES ALLOWED AT ONCE    .
.*     (**EACH DD FILE REQUIRES 3F TABLE ENTRY PLUS DCB AND BUFFER**) .
.*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         TITLE ' &LABEL - MODULE CREATED BY XGPGEN'
         DCBD DSORG=QS
* * * * * XIOBLOCK - CONTROL BLOCK SET UP BY XREAD/XPRNT/XPNCH  * * * *
XIOBLOCK DSECT
         DS    V .                 @ I/O ROUTINE
         DS    3F                  AREA FOR REGS 15-0 TO BE SAVED
XIOLENG  DS    AL2 .               LENGTH OF RECORD, (CODES-FUTURE USEQ
XIORETRN LM    14,0,4(14)          RETURN CODE FOR RESTORING REGISTERS
&LABEL   CSECT
*--> CSECT: EXTENDED I/O MODULE FOR GENERAL I/O . . . . . . . . . . . .
*        THIS MODULE IS CALLED TO DO GENERAL I/O WORK ON A FILE       .
*              SIMILAR IN OPERATION TO THE XIO ROUTINES, BUT CAN HANDLE
*              MANY FILES AT ONCE.                                    .
*        ENTRY CONDITIONS:                                            .
*          R14 = @ OF CONTROL BLOCK                                   .
*          R15  = ENTRY POINT ADDRESS                                 .
*          R0  = ADDRESS OF AREA TO MOVE DATA INTO                    .
*          R1  = ADDRESS OF DD NAME TO BE USED                        .
*        CONTROL BLOCK:                                               .
*      OFFSET  LENGTH        WHAT                                     .
*        0       1F        ENTRY POINT ADDRESS                        .
*        4       3F          SAVE AREA                                .
*        16      2           LENGTH OF AREA                           .
* . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         USING *,15 .              NOTE TEMPORARY ADDRESSABILITY
         USING XIOBLOCK,R14
         STM   R13,R7,X&DIREC.SAV1 SAVE REGISTERS TO BE USED          A
         CNOP  0,4 .               GET ON FULLWORD
         BAL   R13,*+76            SET UP FAKE AREA PNTR - BASE
         USING *,R13 .             NOTE NEW USING/SAVE AREA POINTER
         DS    18F .               FAKE SAVE AREA
         DROP  R15 .               KILL OLD ADDRESSING
         SPACE 2
         USING IHADCB,R1 .         SET UP ADDRESSIBILITY TO DCB S
         MVC   X&DIREC.CURENT(8),0(R1) . GET CURRENT DD NAME
*   CHECK FOR CLOSE
         SR    R1,R1               GET ZERO LENGTH INDICATOR
         CH    R1,XIOLENG          ARE THEY EQUAL?
         BE    X&DIREC.EOF .       YES-GO CLOSE AND FORGET FILE
         XXGPSRCH &DIREC
*  THE FOLLOWING CODE, IF EXECUTED, GENERATES A DCB AND TRIES AN OPEN
*
X&DIREC.MAKE C R1,=A(X&DIREC.FULL) CHECK FOR TABLE OVERFLOW
         BNL   X&DIREC.CC3         NO SPACE, DON'T TRY OPEN-RETURN    J
         ST    R1,X&DIREC.ELEM .   SAVE NEW ADDRESS, R1 ALREADY POINTIN
         MVC   0(8,R1),X&DIREC.CURENT  SAVE DD NAME FOR FUTURE CALLS
         L     0,X&DIREC.LONG
         GETMAIN R,LV=(0) .        LOAD R1 WITH ADDR OF NEW DCB
         L     R2,X&DIREC.ELEM .   GET ADDRESS OF POINTER
         ST    R1,8(R2) .          SAVE @ OF DCB
*
         ST    R1,X&DIREC.FULL     KLUDGE TO GET AROUND ADDRESSIBILITY
         MVC   X&DIREC.OPEN+1(3),X&DIREC.FULL+1  COPY OVER DCB @ INTO J
*
         MVC   0(X&DIREC.ELEM-X&DIREC.DCB,R1),X&DIREC.DCB BUILD DCB
         MVC   DCBDDNAM,X&DIREC.CURENT MOVE DD NAME INTO DCB
         OPEN  MF=(E,X&DIREC.DCBPTR)  DO REMOTE OPEN
         L     R1,X&DIREC.FULL .   FIX R1, DESTROYED IN OPEN
         TM    DCBOFLGS,X'10' .    DID OPEN GO?
         BO    X&DIREC.CONT4       YES, DO I/O
*              OPEN DIDN'T GO - CLEAN UP SO DOESN'T BOMB LATER        J
         L     R0,X&DIREC.LONG     GET LENGTH OF DCB FOR FREEMAIN     J
         FREEMAIN R,LV=(0),A=(1)   GIVE THE SPACE BACK TO OS          J
         XC    0(12,R2),0(R2)      CLEAR OUT SO WON'T THINK IT'S OPEN J
X&DIREC.CC3 TM *+1,X'FF'       SET CC=3  ==> OPEN IMPOSSIBLE          J
         B     X&DIREC.RET         RETURN TO USER
         SPACE 2
X&DIREC.CONT L R1,8(R1) .          GET DCB ADDRESS
X&DIREC.CONT4 LH R5,XIOLENG        GET LENGTH OF AREA
         AIF   ('&FETCH' EQ 'PROTECT').SKPFTCH
         L     R2,X&DIREC.SAV1+12  GET @ I/O AREA
* THE FOLLOWING CODE IS USED FOR ADDRESS ILLEGAL     ******************
*****  THIS CODE WILL NOT WORK IF MACHINE HAS FETCH PROTECT ***********
         SPACE 2
         L     R4,16 .             GET CVT PNTR FROM LOC 16
         LA    R0,0(R2,R5) .       GET ENDING ADDRESS OF I/O AREA
         C     R0,164(R4) .        COMPARE TO CVTMZ00 - HIGHEST ADDRESS
         BNL   X&DIREC.ABD3 .      GO ABEND IF HIGHER
.SKPFTCH ANOP
         AIF   ('&DIREC' EQ 'P').XOUT  SKIP IF OUTPUT
         LH    R7,DCBLRECL         GET LRECL FROM DCB                 J
         GET   IHADCB .            GET # BUFFER
         CLR   R5,R7               COMPARE REQUEST LENGTH TO LRECL    J
         BNH   *+6                 SKIP AROUND IF OK                  J
         LR    R5,R7               TOO BIG, USE LRECL INSTEAD         J
         LR    R4,R5 .             SET UP FOR SHIFT
         SRDL  R4,8 .              PUT RIGHTMOST BYTE IN R5
         SRL   R5,24 .             RIGTH JUSTIFY FOR MOVE
         LTR   R4,R4 .             ANYTHING LEFT IN R4?
         BE    *+22 .              NO - DO NORMAL MOVE
         MVC   0(256,R2),0(R1) .   GIVE USER 256 BYTES OF DATA
         LA    R2,256(R2) .        GO TO NEXT BLOCK
         LA    R1,256(R1) .        GO TO NEXT BLOCK
         BCT   R4,*-14 .           IF ANYTHING LEFT IN R4, DO ANOTHER
*              NORMAL MOVE FOLLOWS
         LTR   R5,R5 .             IS ANYTHING IN R5?
         BE    *+10 .              NO - DONT MOVE LEFTOVER BYTES
         BCTR  R5,0 .              DECREMENT LENGTH BY 1
         EX    R5,X&DIREC.MOV .    MOVE INTO RIGHT PLACE
.XCLOSE  ANOP
         SR    R0,R0 .             SET COND CODE TO 0, USER OK
         B     X&DIREC.RET .       GO TO RETURNX&DIREC.EOF CLOSE IHADCB
X&DIREC.EOF EQU *
         XXGPSRCH &DIREC,2
X&DIREC.MAKE2 B X&DIREC.RET .      GO RETURN
X&DIREC.CONT2 LR R4,R1 .           SAVE THE ADDRESS
         MVC   X&DIREC.PTR+1(3),9(R1)
         LA    R1,X&DIREC.PTR
         CLOSE MF=(E,(1))          DO REMOTE CLOSE
         L     R1,8(R4) .          POINT TO DCB TO FREE
         FREEPOOL (1)              FREE THE BUFFERS
         L     R1,8(R4)            RESET R1 IN CASE DESTROYED
         L     R0,X&DIREC.LONG     GET AMOUNT TO FREE
         FREEMAIN R,LV=(0),A=(1)
*
*   DCB NO LONGER EXISTS,  REMOVE CORRESPONDING ELEMENT FROM LIST
*
         LA    R3,X&DIREC.FULL .    GET UPPER ADDRESS OF TABLE
         SR    R3,R4   .           FIND LENGTH OF REST OF TABLE
         EX    R3,X&DIREC.WIPOUT   WIPEOUT 12 BYTES OF MEMORY
*
*      IF NO POINTERS REMAIN, SET POINTER TO LAST TO ZERO
*
         LA    R3,12
       L       R2,X&DIREC.ELEM
         SR    R2,R3
         LA    R1,X&DIREC.PNTSRT
         CR    R1,R2
         BNH   *+8
         LA    R2,0 .              SET POINTER TO ZERO
         ST    R2,X&DIREC.ELEM     SAVE POINTER
         AIF   ('&DIREC' EQ 'P').XRET
         OI    *+1,1 .             SET COND CODE FOR END OF FILE
.*       SHOULD REMOVE DCB FROM LIST NOW
         AGO   .XRET .             HAVE RETURN CODE GENERATED
.*
.XOUT    ANOP
         LH    R7,82(R1) .         GET LRECL
         PUT   IHADCB .            PRINT THE STUFF
         CLR   R5,R7               COMPARE REQUEST LENGTH TO LRECL    J
         BNH   *+6                 SKIP AROUND IF OK LENGTH           J
         LR    R5,R7               TOO BIG- USE LRECL INSTEAD         J
         LR    R4,R5 .             SET UP FOR SHIFT
         LR    R6,R5               SAVE FOR LATER
         SRDL  R4,8 .              PUT RIGHTMOST BYTE IN R5
         SRL   R5,24 .             RIGTH JUSTIFY FOR MOVE
         LTR   R4,R4 .             ANYTHING LEFT IN R4?
         BE    *+22 .              NO - DO NORMAL MOVE
         MVC   0(256,R1),0(R2) .   PUT STUFF INTO BUFFER
         LA    R2,256(R2) .        GO TO NEXT BLOCK
         LA    R1,256(R1) .        GO TO NEXT BLOCK
         BCT   R4,*-14 .           IF ANYTHING LEFT IN R4, DO ANOTHER
*              NORMAL MOVE FOLLOWS
         LTR   R5,R5 .             IS ANYTHING IN R5?
         BE    *+12
         BCTR  R5,0 .              DECREMENT LENGTH BY 1
         EX    R5,X&DIREC.MOV .    MOVE INTO RIGHT PLACE
         AR    R1,R5               GET BEGINNING @ TO BLANK
         SR    R7,R6               GET DIFFERENCE BETWEEN USER AND DCB
         BZ    *+12                NO DIFFERENCE, DO NOTHING          A
         MVI   1(R1),C' '
         EX    R7,X&DIREC.MOV2     CLEAR REST
*  ****NOTE THAT THIS ONLY WORKS FOR DIFFERENCES < 256
         AGO   .XCLOSE
.*
.XRET    ANOP
         SPACE 2
X&DIREC.RET LM R13,R7,X&DIREC.SAV1 RESTORE REGS                       A
         B     XIORETRN            RETURN
         DROP  R14
X&DIREC.ABD3 CLI  *,0              SET CC=2, SHOW EXECUTE ERROR       J
         B     X&DIREC.RET         GO RETURN, SHOWING ERROR           J
.*
         SPACE 2
X&DIREC.PTR CLOSE (X&DIREC.CONT),MF=L    GENERAL PURPOSE CLOSE
X&DIREC.WIPOUT MVC 0(1,R4),12(R4)
X&DIREC.CURENT DS  CL8  .          AREA TO HOLD CURRENT DD NAME
X&DIREC.SAV1 DS 11F                SAVE AREA FOR REGS USED            A
X&DIREC.PNTSRT DS (&DDNUM*3)F .    AREA FOR DDNUM DD NAMES & POINTERS
X&DIREC.FULL DS F
X&DIREC.OPEN DS 0F                 EXTRA LABEL
         AIF   ('&DIREC' EQ 'P').XDEFSR  SKIP IF OUTPUT
X&DIREC.DCBPTR OPEN (X&DIREC.CONT,(INPUT)),MF=L  OPEN CONTROL WORD    J
X&DIREC.DCB DCB DSORG=PS,MACRF=GL,EODAD=X&DIREC.EOF
X&DIREC.ELEM DC  F'0' .            INITIAL # OF ELEMENTS
XX&DIREC.LONG EQU X&DIREC.ELEM-X&DIREC.DCB   GET DCB LENGTH
X&DIREC.LONG DC A(XX&DIREC.LONG)   SAVE LENGTH OF DCB
X&DIREC.MOV MVC 0(1,R2),0(R1) .    GIVES USER THE DATA
         LTORG
         DROP  R13
         MEXIT                     DONE
.XDEFSR  ANOP
X&DIREC.DCBPTR OPEN (X&DIREC.CONT,(OUTPUT)),MF=L OPEN CONTROL WORD    J
X&DIREC.DCB DCB DSORG=PS,MACRF=PL
X&DIREC.ELEM DC F'0' .             INITIAL # OF ELEMENTS
XX&DIREC.LONG EQU X&DIREC.ELEM-X&DIREC.DCB   GET DCB LENGTH
X&DIREC.LONG DC A(XX&DIREC.LONG)   SAVE LENGTH OF DCB
X&DIREC.MOV MVC 0(1,R1),0(R2) .    MOVE INTO LINE
X&DIREC.MOV2 MVC 2(1,R1),1(R1)     CLEAR OUT REST OF BUFFER
         LTORG
         DROP  R13
         MEND
./ ADD LEVEL=41,SOURCE=0,NAME=XHEXI
         MACRO
&NAME    XHEXI &REG,&ADDR
.*                                                                    *
.*-->MACRO: XHEXI  HEXADECIMAL INPUT CONVERSION MACRO.                *
.*                                WRITTEN BY ALAN ARTZ 4/17/72        *
.*       THIS MACRO TAKES THE VALUE STARTING AT THE ADDRESS GIVEN BY  *
.*  &ADDR AND CONVERTS IT AND PUTS THE HEXADECIMAL VALUE IN &REG.     *
.*  IF THERE ARE MORE THAN 8 DIGITS, R1 POINTS TO THE 9TH AND THE     *
.*  FIRST 8 ARE CONVERTED.  IF THERE IS A NON-BLANK, NON-HEX DIGIT    *
.*  FOUND, R1 POINTS TO THAT CHARACTER AND THE CC=3, OTHERWISE CC SET *
.*  BY VALUE IN REG.                                                  *
.*                                                                    *
.*       CALLS MODULE XXXXHEXI TO DO THE ACTUAL CONVERSIONS           *
.*                                                                    *
.**********************************************************************
         LCLC  &LABEL
&LABEL   SETC  'XX&SYSNDX.H'      UNIQUE LABEL
&NAME    STM   14,0,&LABEL  .      SAVE REGISTERS
         ST    &REG,&LABEL+12  .  REGISTER STORE INCASE OF OVERFLOW CND
         LA    0,&ADDR  .         GET STRING TO BE CONVERTED
         CNOP  2,4  .              GET PROPER ALIGNMENT
         L     15,&LABEL-4  .     ADDRESS OF XXXXHEXI
         BALR  14,15  .            GO TO APPROPRIATE PLACE
         DC    V(XXXXHEXI)  .      VCON OF ROUTINE
&LABEL   DS    4F  .              STORAGE FOR REGISTERS
         LM    14,0,4(14)  .       RESTORE REGISTERS
         L     &REG,&LABEL+12  .  GET CONVERTED NUMBER
         MEND
./ ADD LEVEL=41,SOURCE=0,NAME=XHEXO
         MACRO
&NAME    XHEXO &REG,&ADDR
         LCLC  &LABEL
.*                                                                    *
.*-->MARCO: XHEXO  HEXADECIMAL OUTPUT CONVERSION MACRO                *
.*                                WRITTEN BY ALAN ARTZ 4/17/72        *
.*       THIS MACRO TAKES THE VALUE IN & REG AND CONVERTS IT TO       *
.*  PRINTABLE FORM.                                                   *
.*       IT PUTS THE CONVERTED VALUE IN AN EIGHT BYTE AREA STARTING AT*
.* THE ADDRESS GIVEN IN &ADDR.                                        *
.*      THE CONDITION CODE IS NOT CHANGED AND NETHER ARE THE REGISTERS*
.*                                                                    *
.*       CALLS MODULE XXXXHEXO TO DO THE ACTUAL CONVERSIONS.          *
.*                                                                    *
.**********************************************************************
&LABEL   SETC  'XX&SYSNDX.H'      UNIQUE LABEL
&NAME    DS    0H
         STM   14,0,&LABEL  .      SAVE REGIST5RS
         ST    &REG,&LABEL+12  .    SAVE REGISTER
         LA    0,&ADDR   .        PASS REGISTER TO XXXXHEXO
         CNOP  2,4  .              GDT PROPER ALIGNMENT
         L     15,&LABEL-4  .     ADDRESS OF XXXXHEXO
         BALR  14,15  .            CALL HEXO
         DC    V(XXXXHEXO)
&LABEL   DS    4F  .              STORAGE FOR REGISTERS
         LM    14,0,&LABEL  .     RESTORE REGISTERS
         MEND
./ ADD LEVEL=40,SOURCE=0,NAME=XIDENT
         MACRO
         XIDENT &ID,&LABEL,&XCSECT,&PRIVATE
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XIDENT     IDENTIFY ENTRY POINT FOR XSAVE,$SAVE.         *
.*       MACRO USED BY XSAVE TO PRODUCE ID AT AN ENTRY POINT.  WILL   *
.*       USE THE FIRST NON-NULL OPERAND PASSED TO IT AS THE ID.       *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         LCLA  &I,&J                LOCAL COUNTERS
&I       SETA  1                    INITIALIZE
         AIF   ('&ID' NE '*').XIDINC         SKIP IF EXPLICIT ID FIELD
.XILOOP  ANOP
&I       SETA  &I+1                 INCREMENT TO NEXT ONE
         AIF   ('&SYSLIST(&I)' EQ '').XILOOP SKIP BACK IF THIS IS NULL
.XIDINC  ANOP
&J       SETA  6+((K'&SYSLIST(&I)+1)/2)*2   GET BRANCH LENGTH
         B     &J.(,15) .           BRANCH AROUND ID
&J       SETA  &J-5                 GET ACTUAL LENGTH OF ID
         DC    AL1(&J),CL&J'&SYSLIST(&I)'
         MEND
./ ADD LEVEL=40,SOURCE=0,NAME=XIOGN
         MACRO
&XLABEL  XIOGN  &LRECL=80,&BLKSIZE=80,&XOP=OUTPUT,&RECFM=,&DDNAME=,    #
               &BUFNO=1
.*--> MACRO: XIOGN      I/O SUPPORT MODULE GENERATION . . . . . . . . .
.*                                 JOHN R. MASHEY - FEB 1970 - V.5.0  *
.*       MACRO USED TO GENERATE THE I/O CSECTS USED BY THE XIOPAK     *
.*       MACROS XREAD,XPRNT,XPNCH.  THE CSECTS ARE CALLED EACH TIME   *
.*       ONE OF THE MACROS IS CALLED, AND DOES REQUIRED OPN'S, GET'S, *
.*       PUT'S, ETC .                                                 *
.*       **ARGUMENTS**                                                *
.*       BLKSIZE,BUFNO,LRECL,RECFM=    ARGUMENTS FOR CREATED DCB.     *
.*             DEFAULTS: BLKSIZE=80,BUFNO=1,LRECL=80.                 *
.*             IF MODULE DESIRED FOR USE WITH VARIABLE JCL VALUES,    *
.*             CODE BLKSIZE=0,BUFNO=0,LRECL=0.                        *
.*       XOP= EITHER INPUT OR OUTPUT, DENOTING DIRECTION OF I/O.      *
.*             DEFAULT: OUTPUT.                                       *
.*       DDNAME=   LIST OF DDNAMES WHICH MODULE CAN USE FOR I/O.      *
.*             WILL ATTEMPT OPEN OF EACH ONE, IN ORDER GIVEN, UNTIL   *
.*             ONE SUCCEEDS OR LIST IS EXHAUSTED.                     *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLB  &XIOGNST            =0 ==> HAVEN'T GEND XIOBLOCK
         LCLA  &XDD                COUNTER FOR # DDNAMES
         LCLB  &XIO                OUTPUT=1,INPUT=0
         LCLC  &X                  PREFIX OF ALL LABELS
&XDD     SETA  N'&DDNAME           GET # OF DDNAMES TO BE TRIED
&XIO     SETB  ('&XOP' EQ 'OUTPUT')          SET FOR INPUT OR OUTPUT
&X       SETC  '&XLABEL'(3,4)      GET LABEL START
        TITLE  ' *** &XLABEL *** I/O ROUTINE'
&XLABEL  CSECT
         ENTRY &X.DCB
         USING XIOBLOCK,R14 .      NOTE POINTER TO CONTROL BLOCK
         USING *,R15 .             NOTE TEMPORARY ADDRESSIBILITY
         STM   R13,R5,&X.SAV1   .  SAVE REGS WHICH WILL BE USED
         CNOP  0,4 .               MAKE SURE ALIGNED ON FULLWORD
         BAL   R13,*+76 .          SET UP FAKE SAVE AREA PTR,BASE
         USING *,R13 .             NOTE NEW USING/SAVE AREA POINTER
         DS    18F .               FAKE SAVE AREA,FOR GET/PUT ETC
         DROP  R15 .               KILL OLD ADDRESSING
         SPACE 2
.XASA1   AIF   (&XIO).XOUT         SKIP IF OUTPUT
&X.EOFT  NOP   &X.ABD2  .          *** WILL BECOME A B AFTER EOF EXIT
.XOUT    ANOP
&X.TES1  NOP   &X.GO   .           *** WILL BE A BRANCH AFTER OPEN GOES
         LR    R5,R14              SAVE R14 AROUND CALL TO XXXXOPEN
         LA    1,&X.OPBK .         GET ADDRESS OF CONTROL TABLE
         L     15,&X.OPAD .        GET BRANCH ADDRESS
         BALR  14,15 .             CALL XXXXOPEN ROUTINE
         LR    R14,R5              RESTORE R14
&X.OPOK  MVI   &X.TES1+1,X'F0'  .  CHANGE NOP TO B-DONT OPEN AGAIN
&X.GO    LH    R4,&X.DCB+82 .      GET DCB LRECL FOR COMPARISON
         LH    R5,XIOLENG .        GET LENGTH FROM CONTROL BLOCK
         BCTR  R5,0 .              DECREMENT TO LENGTH-1
         CLR   R4,R5 .             COMPARE WITH LIMIT
         BH    *+8 .               SKIP IF WITHIN RANGE
         LR    R5,R4 .             MOVE DEFAULT VALUE OVER
         BCTR  R5,0 .              DECREMENT DEFAULT TO LENGTH-1
.XASB    SPACE 2
         L     R2,&X.SAV1+12 .     GET ADDRESS OF I/O AREA (FROM R0)
.*
*        THE FOLLOWING CODE IS USED TO CHECK FOR ADDRESS ILLEGAL      *
*        THIS CODE WILL NOT WORK IF MACHINE HAS FETCH PROTECT**********
         L     R1,16 .             GET CVT POINTER FROM LOC 16
         LA    R0,1(R2,R5) .       GET ENDING ADDRESS OF I/O AREA
         C     R0,164(R1) .        COMPARE TO CVTMZ00-HGIHEST ADDRESS
         BNL   &X.ABD3   .         GO ABEND IF HIGHER
.*
         AIF   (&XIO).XOUT1        SKIP IF OUTPUT MODE
         GET   &X.DCB              OBTAIN @ BUFFER
         EX    R5,&X.MOV  .        MOVE REQUESTED NUMBER OF BYTES
         SR    R0,R0 .             SET CONDITION CODE=0, SHOW USER OK
         B     &X.RET  .           GO TO RETURN TO CALLER
&X.ABD2  WTO   ' &XLABEL ABEND 300 - ATTEMPT TO READ PAST END-OF-FILE',X
               ROUTCDE=11
         B     &X.ABD1  .          GO ABEND
&X.EOF   CLOSE &X.DCB
         LA    1,&X.DCB            POINT 1 TO DCB TO FREE BUFFER
         FREEPOOL (1)              FREE THE BUFFERS
         OI    *+1,1  .            SET CONDITON CODE TO 1
         MVI   &X.EOFT+1,X'F0'  .  CHANGE NOP TO B-NO MORE READS
         AGO   .XRET               HAVE RETURN CODE GENRATED
.*
.XOUT1   EX    R5,&X.MOV  .        MOVE NUMBER OF BYTES TO OUTPUT LINE
         PUT   &X.DCB,&X.BUF
         EX    R5,&X.MOV1  .       REBLANK OUTPUT LINE
.*
.XRET    ANOP
         SPACE 2
&X.RET   LM    R13,R5,&X.SAV1  .   RESTORE THE REGS WE CHANGED
         AIF   (NOT &XIO).XOUT2    SKIP SPM IF THIS WAS AN INPUT
         SPM   R14 .               RESTORE THE CONDITION CODE
.XOUT2   B     XIORETRN .          RETURN TO CALLING XIOBLOCK
&X.ABD3  WTO   ' &XLABEL ABEND 300-ILLEGAL ADDRESS-SEE REG 2',         X
               ROUTCDE=11
&X.ABD1  ABEND 300,DUMP
.*
         SPACE 2
&X.SAV1  DS    9F .                AREA TO PRESERVE REGS IN
&X.OPAD  DC    V(XXXXOPEN) .       ADDRESS OF SUPEROPEN ROUTINE
&X.OPBK  XOPENBLK &X.DCB,&XLABEL,&DDNAME,RECFM=&RECFM,LRECL=&LRECL,    #
               BLKSIZE=&BLKSIZE,BUFNO=&BUFNO,XOP=&XOP
.XNODD   AIF   (&XIO).XOUT3        SKIP IF OUTPUT
.*
&X.MOV   MVC   0(0,R2),0(R1) .     R1==> BUFFER, EXECUTE SUPPLIES LENGT
&X.DCB   DCB   DSORG=PS,MACRF=GL,EODAD=&X.EOF
         AGO   .XEXIT
.*
.XOUT3   ANOP
&X.BUF   DC    CL(&LRECL)' ' .     OUTPUT I/O BUFFER AREA
&X.BLNK  DC    CL(&LRECL)' ' .     FOR REBLANKING OUTPUT BUFFER
&X.MOV   MVC   &X.BUF(0),0(R2)  .  MOVE RIGHT NUMBER OF CHARS TO BUFFER
&X.MOV1  MVC   &X.BUF(0),&X.BLNK   EXECUTED MOVE TO REBLANK BUFFER
&X.DCB   DCB   DSORG=PS,MACRF=PM
.XEXIT   DROP  R13,R14 .           KILL LEFTOVER ADDRESSING
.*
         AIF   (&XIOGNST).XXEXIT   SKIP IF ALREADY GEND XIOBLOCK
&XIOGNST SETB  (1)                 SHOW WE'VE GENERATE XIOBLOCK
         EJECT
* * * * * XIOBLOCK - CONTROL BLOCK SET UP BY XREAD/XPRNT/XPNCH  * * * *
XIOBLOCK DSECT
         DS    V .                 @ I/O ROUTINE
         DS    3F                  AREA FOR REGS 15-0 TO BE SAVED
XIOLENG  DS    AL2 .               LENGTH OF RECORD, (CODES-FUTURE USEQ
XIORETRN LM    14,0,4(14)          RETURN CODE FOR RESTORING REGISTERS
.XXEXIT  MEND
./ ADD LEVEL=40,SOURCE=0,NAME=XIONR
         MACRO
&XLABEL  XIONR &XNAME,&XNUM,&XAREA,&XDEFT
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XIONR      INNER MACRO-$READ,$PNCH,$PRNT,$SORC           *
.*                                 JOHN R. MASHEY - FEB 1970 - V.5.0  *
.*       XIONR IS USED BY XIOPAK MACROS XREAD,XPRNT,XPNCH TO SET UP   *
.*       THE REQUIRED CODE FOR CALLING THEIR RESPECTIVE SUBROUTINES.  *
.*       *** ARGUMENTS ***                                            *
.*       XNAME     THE NAME OF THE I/O ROUTINE TO BE CALLED.          *
.*       XNUM      THE LENGTH OF XAREA TO BE PRINTED,PUNCHED,ETC.     *
.*       XAREA     THE AREA ON WHICH I/O OPERATION TO BE PERFORMED.   *
.*             MAY BE SPECIFIED BY (0) OR (R0).                       *
.*       XDEFT     DEFAULT VALUE OF XNUM TO BE USED, IF IT IS OMITTED *
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **
.*                                                                    *
.*       AS OF AUG 1972, XGET AND XPUT ALSO USE THIS MACRO.           *
.*                                     RICHARD FOWLER                 *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         AIF   (T'&XAREA EQ 'O').XERR1       PRODUCE MNOTE
&XLABEL  STM   14,0,XX&SYSNDX.R+4 .    SAVE REGS WHICH WILL BE CHANGED
         AIF   (T'&XNUM EQ 'O').XN1    SKIP NEXT CHECK IF OMITTED
         AIF   ('&XNUM'(1,1) NE '(' OR '&XNUM'(K'&XNUM,1) NE ')').XN1
         STH   &XNUM,XX&SYSNDX.R+16 .       STORE LENGTH
.XN1     AIF   ('&XAREA' EQ '(0)' OR '&XAREA' EQ '(R0)').XNOLA
.XN2     LA    0,&XAREA
.XNOLA   L     15,XX&SYSNDX.R  .   GET BRANCH ADDRESS
         CNOP  2,4  .              ADJUST FOR RIGHT ALIGNEMNT
         BALR  14,15 .             CALL ROUTINE, R14==> CONTROL BLOCK
XX&SYSNDX.R DC V(&XNAME)  .        ROUTINE ADDRESS
         DS    3F .                SAVE SPACE FOR REGS 14-0
         AIF   ('&XNUM' EQ '').XDFT         SKIP IF DEFAULT SHOULD BE
         DC    AL2(&XNUM) .        LENGTH OF AREA
         AGO   .XDS                SKIP
.XDFT    DC    AL2(&XDEFT) .       DEFAULT LENGTH USED
.XDS     LM    14,0,4(14) .        RESTORE REGS. CON CODE ALREADY DONE
         MEXIT
.XERR1   MNOTE 0,'**XIONR- AREA ADDRESS OMITTED-GENERATION CANCELLED'
         MEND
./ ADD LEVEL=40,SOURCE=0,NAME=XLIMD
         MACRO
&XLABEL  XLIMD &ADDR,&LENGTH
.*--> MACRO: XLIMD      LIMIT DUMP-ASSIST COMPATIBILITY MACRO . . . . .
.*.      MACRO PROVIDED ONLY FOR RUNNING ASSIST DECKS UNDER OS/360.   .
.*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
&XLABEL  DS    0H .                XLIMD EXPANSION- NOTHING
         MEND
./ ADD LEVEL=40,SOURCE=0,NAME=XLOOK
         MACRO
         XLOOK &ARG1,&ARGL
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XLOOK      FIND POSITION OF ELEMENT IN LIST.             *
.*                                 JOHN R. MASHEY - FEB 1970 - V.4.0  *
.*       MACRO TO FIND AND RETURN POSTION OF ARGUMENT IN A SUBLIST.   *
.*       &ARG1 ARGUMENT TO BE SEARCHED FOR                            *
.*       &ARGL LIST OF ARGUMENTS FOR &ARG1 TO BE CHECKED FOR IN       *
.*       &XXLOOK   THE FIRST POSITION IN &ARGL IN WHICH &ARG1 IS      *
.*       FOUND, IF ANY.  IF &ARG1 IS NOT IN &ARGL, &XXLOOK = 0.       *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLA  &XXLOOK             FOR RETURN OF INDEX VALUE
&XXLOOK  SETA  1                   INITIALIZE THE COUNTER
.XLA     AIF   (&XXLOOK GT N'&ARGL).XLB     IF GT,QUIT,NOT FOUND
         AIF   ('&ARG1' EQ '&ARGL(&XXLOOK)').XXEXIT   IF FOUND,RETURN
&XXLOOK  SETA  &XXLOOK+1           INCREMENT COUNTER
         AGO   .XLA                GO BACK FOR NEXT CHECK
.XLB     ANOP
&XXLOOK  SETA  0                   NOT FOUND, SET TO 0 TO SHOW THIS
.XXEXIT  MEND
./ ADD LEVEL=40,SOURCE=0,NAME=XMUSE
         MACRO
         XMUSE &BR,&AD
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XMUSE      BASE REGISTER SETUP MACRO FOR XSAVE           *
.*                                 JOHN R. MASHEY - FEB 1970 - V.4.0  *
.*       THIS MACRO IS CALLED BY XSAVE TO HANDLE BR AND AD OPERANDS,  *
.*       AND PRODUCE APPROPRIATE USINGS.  &BR AND &AD ARE FROM XSAVE. *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         LCLA  &I,&N               LOCAL COUNTERS
         LCLC  &B(4),&V            BASE REGS, USING NAME
&N       SETA  N'&BR               GET NUMBER WHERE HANDY
&V       SETC  '*'                 NORMAL USE
         AIF   (&N LE 4).XNOKA     MAKE SURE NOT TOO MANY BASES
&N       SETA  4                   IDIOT USER HAD >4 BASES, IGNORE EXTR
         MNOTE 4,'**XMUSE- MORE THAN 4 BASE REGS-EXTRAS IGNORED'
.XNOKA   AIF   ('&AD' EQ '').X1LOOP         SKIP IF NORMAL SITUATION
.*             USED IF AD PARAMATER WAS SPECIFIED IN XSAVE MACRO.     *
         CNOP 0,4
         B     *+8 .               SKIP AROUND ADDRESS CONSTANT
         DC    A(&AD)       .      ADDRESS CONSTANT FOR AD=PARAMETER
         L     &BR(1),*-4 .        LOAD ADCON INTO RIGHT REGISTER
&V       SETC  '&AD'               CHANGE NAME FOR USING 1ST OPERND
.*             NORMAL SECTION OF CODE FOR GENERATING USING.           *
.X1LOOP  ANOP
&I       SETA  &I+1      INCREMENT COUNTER TO BASE REG
&B(&I)   SETC  ',&BR(&I)'          GET I'TH BASE REGISTER
         AIF   (&I LT &N).X1LOOP   CONTINUE UNTIL ALL BASWE REGS DONE
         DROP  15 .                CLEAN UP USING SITUATION
         USING &V&B(1)&B(2)&B(3)&B(4)
         MEND
./ ADD LEVEL=40,SOURCE=0,NAME=XOPENBLK
         MACRO
&LABEL   XOPENBLK &DCB,&XNAME,&DDNAME,&RECFM=F,&LRECL=,&BLKSIZE=,      #
               &BUFNO=1,&XOP=OUTPUT,&ABEND=YES,&WARN=NO
.*--> MACRO: XOPENBLK   GENERATES 1 CONTROL BLOCK FOR XXXXOPEN  . . . .
.*             SEE THE XOPENBLK DSECT.                                .
.*       *** ARGUMENTS ***                                            .
.*       &DCB                      NAME OF DCB TO BE OPENED           .
.*       &XNAME                    NAME OF CALLING ROUTINE            .
.*       &DDNAME                   LIST OF 1 OR MORE DDNAMES, IN ORDER.
.*                                 DESIRED TO BE TRIED.               .
.*             NEXT 4 ARGS GIVE DEFAULT VALUES USED TO FILL DCB       .
.*             IF NEEDED DURING DCB EXIT PROCESSING.                  .
.*       &RECFM=, &LRECL=, &BLKSIZE=, &BUFNO=     SAME NAMES AS DCB   .
.*       &XOP=                     DIRECTION TO OPEN:  OUTPUT OR INPUT.
.*       &ABEND=                   ABEND IF CAN'T OPEN: YES OR NO     .
.*       &WARN=                    WARNING IF CAN'T OPEN FIRST CHOICE .
.*                                 YES  OR  NO                        .
.*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         LCLA  &I                  COUNTER VARIABEL
         LCLB  &B0,&B3,&B5         FOR RECFM BITS, XOPFLAG1 BITS
&LABEL   OPEN  (&DCB,&XOP),MF=L .  LIST TO GEN CONTROL ELEMENT
         DC    AL2(&LRECL,&BLKSIZE,&BUFNO)   LRECL,BLKSIZE,BUFNO
.*
&B0      SETB  ('&RECFM'(1,1) EQ 'F')  SHOULD BE SET
&B3      SETB  ('&RECFM.X'(2,1) EQ 'B')          BLOCKED OR NOT
&B5      SETB  ('&RECFM'(K'&RECFM,1) EQ 'A')     ASA CARRIAGE CONTROLS
         DC    B'&B0.00&B3.0&B5.00' .       RECFM BYTE
.*
&B0      SETB  ('&ABEND' EQ 'YES') DOES HE WANT TO ABEND IF NO OPEN
&B3      SETB  ('&WARN' EQ 'YES')  DOES HE WANT WARN IF NOT FIRST DDNA
         DC    B'&B3&B0',CL8'&XNAME ' .  XOP-FLAG1,XNAME
.*
&I       SETA  8*(N'&DDNAME-1)     3 DDNAMES, CONVERT TO BXLE LMT
         DC    H'&I' .             BXLE OFFSET FOR DD SEARCH
&I       SETA  1                   RE INIT FOR LOOP TO GEN
.XOPA    DC    CL8'&DDNAME(&I)'
&I       SETA  &I+1                INCREMENT TO NEXT ONE
         AIF   (&I LE N'&DDNAME).XOPA       LOOP UNTIL ALL DDNAMES GEND
         MEND
./ ADD LEVEL=40,SOURCE=0,NAME=XPNCH
         MACRO
&XLABEL  XPNCH &XAREA,&XNUM
.*--> MACRO: XPNCH      PUNCH CARD MACRO  . . . . . . . . . . . . . . .
.*                                 JOHN R. MASHEY - FEB 1970 - V.4.0  *
.*       MACRO FOR EASY PUNCHING OF UP TO 80 BYTES OF XAREA. MACRO    *
.*       GENERATION IS CONTROLLED BY &XPNCHST.                        *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLB  &XPNCHST            STATUS VARIABLE- 0=ON, 1=OFF
         AIF   (&XPNCHST).XNOGEN   SKIP GENRATION IF NOT WANTED
&XLABEL  XIONR XXXXPNCH,&XNUM,&XAREA,80
         MEXIT
.XNOGEN  AIF   (T'&XLABEL EQ 'O').XXEXIT     GEN LABEL ONLY IF NEEDED
&XLABEL  DS    0H .                LABEL FOR A CANCELLED  XPNCH
.XXEXIT  MEND
./ ADD LEVEL=40,SOURCE=0,NAME=XPRNT
         MACRO
&XLABEL  XPRNT &XAREA,&XNUM
.*--> MACRO: XPRNT      PRINT LINE MACRO  . . . . . . . . . . . . . . .
.*                                 JOHN R. MASHEY - FEB 1970 - V.4.0  *
.*       MACRO FOR EASY PRINTING OF UP TO 133 CHARACTERS OF XAREA,    *
.*       AS SPECIFIED BY XNUM.  FIRST CHARACTER IS USED AS CARRIAGE   *
.*       CONTROL CHARACTER.  GENERATION IS CONTROLLED BY &XPRNTST.    *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLB  &XPRNTST            GENERATION STATUS 0=YES, 1=NO
         AIF   (&XPRNTST).XNOGEN   SKIP GENERATION IF STATUS=OFF
&XLABEL  XIONR XXXXPRNT,&XNUM,&XAREA,133
         MEXIT
.XNOGEN  AIF   (T'&XLABEL EQ 'O').XXEXIT     GEN LABEL ONLY IF NEEDED
&XLABEL  DS    0H .                LABEL FOR CANCELLED XPRNT
.XXEXIT  MEND
./ ADD LEVEL=40,SOURCE=0,NAME=XPUT
         MACRO
&XLABEL  XPUT  &XAREA,&XNUM
.*--> MACRO: XPUT           PUT A RECORD ONTO FILE &DDNAME . . . . .  *
.*                                 RICHARD FOWLER AUG 1972 V.5.0      *
.*       MACRO FOR EASY PRINTING ONTO ANY DD FILE RECORD LENGTH=&XNUM *
.*       IF PRINT FILE, THE FIRST CHARACTER IS USED AS CARRIAGE CONTROL
.*       GENERATION CONTROLLED BY &XPUST                              *
.*       EXECUTION ASSUMES REG 1 POINTS TO DD NAME                    *
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **
         GBLB  &XPUTST             GENERATION STATUS- 0=YES, 1=NO
         AIF   (&XPUTST).XNOGEN    IF SHOULDN'T GENERATE, SKIP CALL
&XLABEL  XIONR XXXXPUT,&XNUM,&XAREA,133
         MEXIT
.XNOGEN  AIF   (T'&XLABEL EQ 'O').XXEXIT     GEN LABEL ONLY IF NEEDED
&XLABEL  DS    0H .                LABEL FOR CANCELLED XPUT
.XXEXIT  MEND
./ ADD LEVEL=40,SOURCE=0,NAME=XREAD
         MACRO
&XLABEL  XREAD &XAREA,&XNUM
.*--> MACRO: XREAD      READ CARD MACRO . . . . . . . . . . . . . . . .
.*                                 JOHN R. MASHEY - FEB 1970 - V.4.0  *
.*       MACRO FOR EASY CARD READING-READS UP TO 80 CHARACTERS INTO   *
.*       XAREA OPERAND. CONDITION CODE SET TO 0 NORMALLY, OR TO 1 ON  *
.*       END OF FILE.  GENERATION CONTROLLED BY &XREADST.             *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLB  &XREADST            GENERATION STATUS- 0=YES, 1=NO
         AIF   (&XREADST).XNOGEN   IF SHOULDN'T GENRATE-SKIP CALL
&XLABEL  XIONR XXXXREAD,&XNUM,&XAREA,80
         MEXIT
.XNOGEN  AIF   (T'&XLABEL EQ 'O').XXEXIT     GEN LABEL ONLY IF NEEDED
&XLABEL DS     0H .                LABEL FOR CANCELLED XREAD
.XXEXIT  MEND
./ ADD LEVEL=40,SOURCE=0,NAME=XRETURN
         MACRO
&LABEL   XRETURN &RGS=(14-12),&SA=,&RC=,&RP=,&T=,&TR=*,&REEN=
.** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XRETURN    GENERAL RETURN MACRO, OS LINKAGE              *
.*                                 JOHN R. MASHEY - FEB 1970 - V.4.0  *
.*       EXTENDED RETURN MACRO - SEE PSU CC WRITEUP - XSAVE/XRETURN   *
.*       FOR EXPLANATION AND USE OF OPERANDS.                         *
.*       USES MACROS: FREEMAIN,XCHAR,XSRNR                            *
.** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLB  &XRETUST            =0 TRACE GENERATION OK, =1 NO TRACE
         GBLC  &XSAVE,&XXCHAR      STD SAVE AREA NAME, XCHAR VARIABLE
         LCLA  &I                  LOCAL COUNTER
         LCLB  &RCA,&RCB           FOR CONTROL OF RETURN CODE GENER
.*                                                                    *
.*       GENERATE LABEL IF THERE IS ONE, GENERATE TRACE CODE IF IT    *
.*       IF DESIRED, AND SET UP LCLB VARIABLES TO DESCRIBE RETURN     *
.*       CODE CONDITIONS. GENERATE LR IF NEEDED FOR RC OPTION.        *
.*                                                                    *
         SPACE 1
         AIF   (T'&LABEL EQ 'O').XNOLB       SKIP IF NO LABEL USED
&LABEL   DS    0H .                DEFINE LABEL
.XNOLB   AIF   ('&TR' EQ 'NO' OR &XRETUST).XNORT       SKIP IF NO TRACE
         XSRTR &TR,&LABEL,EXITED   GET TRACE GENERATED
.XNORT   ANOP
&RCA     SETB  (T'&RC EQ 'O')      TRUE IF WHOLE THING OMITTED
&RCB     SETB  (1)                 SET THIS WAY FOR NEXT TEST
         AIF   (&RCA).XNRCB        SKIP IMMEDIATELY IF OMITTED
&RCB     SETB  ('&RC'(1,1) NE '(' OR '&RC'(K'&RC,1) NE ')')  NOT RG TYP
         AIF   (&RCB).XNRCB       SKIP IF NOT REGISTER TYPE
         XCHAR &RC,3               GET LAST 3 CHARS
         AIF   ('&XXCHAR' EQ '15)').XNRCB    SKIP IF ALREADY IN 15
         LR    15,&RC .            LOAD RETURN CODE FROM DESIRED REG
.XNRCB   AIF   (T'&REEN EQ 'O').XNORM        SKIP IF NOT REENTRANT
.*                                                                    *
.*       REENTRANT RETURN CODE GENERATION - OBTAIN ADDRESS AND LENGTH *
.*       OF AREA FROM WHERE XSAVE PUT THEM,DO FREEMAIN,FIXUP REGS.    *
.*                                                                    *
         AIF   ('&TR' EQ 'NO' OR &XRETUST).XGOK        MAKE SURE REENT
         MNOTE 0,'**XRETURN- TR OPTION IMPLIES NON-REENTRANT CODE'
.XGOK    L     13,4(13) .          GET OLD SA POINTER BACK
         STM   15,1,16(13) .       SAVE REGS FROM FREEMAIN CRUNCHING
         L     1,8(13) .           GET ADDRESS OF AREA BACK
*        FREEMAIN R,LV=8*((&REEN+79)/8),A=(1)          FREE STORAGE
         FREEMAIN R,LV=8*((&REEN+79)/8),A=(1)          FREE STORAGE
         LM    15,1,16(13) .       RESTORE THE REGS
         AGO   .XNORM1             GO TO PROCESS REGISTER RESTORATION
.XNORM   AIF   ('&SA' EQ 'NO').XNORM1        SKIP RESTORATION IF UNUSED
.*                                                                    *
.*       REGISTER RESTORATION CODE - RESTORE REGS FROM CALLER'S       *
.*       SAVE AREA,DEPENDING ON RETURN CODE AND FUNCTION OPTIONS.     *
.*                                                                    *
         L     13,4(13) .          RESTORE PREVIOUS SAVE AREA POINT
.XNORM1  AIF   ('&RGS' EQ 'NO').XNORM2A     SKIP IF NO REGS NEEDED
         AIF   ('&RGS' NE '(14-12)' OR NOT &RCB).XNORM2
         LM    14,12,12(13) .      STANDARD REGISTER RESTORATION
         AGO   .XNORM2A            CONTINUE
.XNORM2  ANOP
&I       SETA  &I+1                INCREMENT COUNTER
         XSRNR L,&RGS(&I),&RCB     HAVE RESTORE CODE GENRATED
         AIF   (&I LT N'&RGS).XNORM2        LOOP UNTIL DONE
.*                                                                    *
.*       RETURN CODE(15) AND RETURN PAST(14) CODE GENERATION.         *
.*                                                                    *
.XNORM2A AIF   (&RCA OR NOT &RCB).XNORM3    SKIP IF NOT LA TYPE RC=
         LA    15,&RC .            PUT RETURN CODE IN 15
.XNORM3  AIF   ('&T' NE '*').XNORM4          SEE IF MVI WANTED
         MVI   12(13),X'FF' .      SHOW WE HAVE RETURNED
.XNORM4  AIF   (T'&RP EQ 'O').XNORP          SKIP IF RP NOT USED
         B     &RP.(14) .          RETURN GIVEN NUMBER PAST 14
         AGO   .XNORM5
.XNORP   BR    14 .                RETURN NORMALLY TO CALLER
.*                                                                    *
.*       SAVE AREA GENERATION - IF A SAVE AREA SHOULD BE CREATED,     *
.*       USE EITHER ONE SPECIFIED BY MACRO,OR ELSE STANDARD ONE.      *
.*                                                                    *
.XNORM5  AIF   (T'&SA EQ 'O' OR '&SA' EQ 'NO').XEXIT   SKIP IF NO SAV5
         AIF   ('&SA' EQ '*').XSASTD         IF *,USE STANDARD SAVE
&SA      DC    18F'0' .            SAVE AREA,NAMED BY MACRO
         AGO   .XEXIT
.XSASTD  ANOP
&XSAVE   DC    18F'0' .            SAVE AREA,USING GENERATED NAME
.XEXIT   SPACE 1
         MEND
./ ADD LEVEL=40,SOURCE=0,NAME=XSAVE
         MACRO
&LABEL   XSAVE &RGS=(14-12),&BR=12,&SA=*,&ID=*,&TR=*,&REEN=,&OPT=,&AD=
.** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XSAVE      EXTENDED SAVE MACRO - OS LINKAGE.             *
.*                                 JOHN R. MASHEY - FEB 1970 - V.4.0  *
.*       EXTENDED SAVE MACRO - SEE PSU CC WRITEUP - XSAVE/XRETURN     *
.*       FOR DESCRIPTION OF ARGUMENTS FOR THIS MACRO                  *
.*       USES MACROS: GETMAIN,XCHAR,XIDENT,XLOOK,XMUSE,XSRNT,XSRTR    *
.** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLA  &XXLOOK             RETURN VARIABLE FROM XLOOK MACRO
         GBLB  &XSAVEST            =0 TRACE GEN OK, =1 NO TRACE DONE
         GBLC  &XSAVE,&XCSECT,&XXCHAR  STD NAME,CSECT NAME,XCHAR VAR
         LCLA  &I                  LOCAL COUNTER
         LCLB &XNSECT              FLAG FOR NEW CSECT
         LCLC  &B1,&BT             1ST BASE,LAST 2 CHARS OF 1ST BASE
&B1      SETC  '&BR(1)'            GET FIRST OR ONLY BASE IN EASIER NAM
         XCHAR &B1,2               GET LAST 2 CHARS OF BASE REG
&BT      SETC  '&XXCHAR'           GET LAST 2 CHARACTERS
&XNSECT  SETB  ('&SYSECT' NE '&XCSECT')      NOTE IF NEW CSECT NEEDED
&XCSECT  SETC  '&SYSECT'           SET TO SYSECT, FOR NORMAL USE
.*                                                                    *
.*       CHECK OPT FIELD - GENERATE TITLE AND/OR ENTRY OR CSECT       *
.*       STATEMENTS, DEPENDING ON CONTENTS OF OPT FIELD, IF USED.     *
.*                                                                    *
         AIF   (T'&OPT EQ 'O').XNOPS         SKIP IF OPT UNUSED
         XLOOK TITLE,&OPT           WAS TITLE OPTION USED
         AIF   (&XXLOOK EQ 0).XNTITL         SKIP IF TITLE NOT USED
         AIF   (N'&OPT EQ 1).XNOPS SKIP IF TITLE ONLY
        TITLE  '*** &LABEL ***'
.XNTITL  XLOOK ENTRY,&OPT           WAS ENTRY USED
         AIF   (&XXLOOK EQ 0).XTRCS         SKIP IF NOT USED
         AIF   ('&LABEL' EQ '').XENTE        SKIP TO ERR IF NO LABEL
         ENTRY &LABEL  .            NOTE XSAVE ENTRY OPTION
         AGO   .XNOPS
.XENTE   MNOTE 4,'**XSAVE- OPT=ENTRY USED WITHOUT LABEL-OPTION IGNORED'
         AGO   .XNOPS
.XTRCS   XLOOK CSECT,&OPT           CHECK FOR CSECT OPTION
         AIF   (&XXLOOK EQ 0).XTRCS1        SKIP IF OPTION NOT THERE
&LABEL   CSECT
&XCSECT  SETC  '&LABEL'            SET THIS TO SHOW NEW CSECT
&XNSECT  SETB  (1)                  NOTE THAT NEW CSECT IS NEEDED
         AGO   .XENT1               SKIP OVER &LABEL DEFN
.XTRCS1  MNOTE 0,'**XSAVE- UNKNOWN OPT=&OPT- IGNORED'
.*                                                                    *
.*       CREATE STATMENT LABEL IF ANY. IF IDENTIFIER REQUESTED,USE    *
.*       SPECIFIED IDENTIFIER,STATEMENT LABEL,OR CSECT NAME IN XIDENT *
.*       TO GENERATE CORRECT IDENTIFIER WITH BRANCH AROUND IT.        *
.*                                                                    *
.XNOPS   SPACE 2
&LABEL   DS    0H .                DEFINE LABEL,MAKE SUREE ALIGNED
.XENT1   USING *,15 .              FOR TEMPORARY ADDRESSIBILITY
         AIF   ('&SA' EQ '*' OR '&SA' EQ 'NO').XCHKS1 SKIP IF NO CHANGE
&XSAVE   SETC  '&SA'                EXPLICIT NEW SAVE AREA NAME
         AGO   .XSAOK
.XCHKS1  AIF   ('&XSAVE' NE '').XCHKS2       SKIP IF NOT NULL
&XSAVE   SETC  '$PR#&SYSNDX'        SET UP DEFAULT SAVE AREA NAME
         AGO   .XSAOK
.XCHKS2  AIF   (NOT &XNSECT).XSAOK SKIP IF NEW SAVE NOT NEEDED
&XSAVE   SETC  '&XCSECT'(1,3).'#&SYSNDX'     DEFAULT SAVE AREA NAME
.*                                                                    *
.XSAOK   AIF   ('&ID' EQ 'NO').XID3 SKIP IF NO ID WANTED
         XIDENT &ID,&LABEL,&XCSECT,$PRIVATE CALL TO SET UP IDENT
.*                                                                    *
.*       IF TR OPTION IN EFFECT, CALL XSRTR TO GENERATE RIGHT CODE,   *
.*       THEN HAVE XSRNR GENERATE CODE TO SAVE RANGES OF REGISTERS    *
.*                                                                    *
.XID3    AIF   (&XSAVEST OR '&TR' EQ 'NO').XNOTR       SKIP IF NO TRACE
         XSRTR &TR,&LABEL,ENTERED  GET TRACE GENERATED
.XNOTR   AIF   ('&RGS' NE '(14-12)').XSRCAL SKIP IF NOT STANDARD
         STM   14,12,12(13) .      SAVE STANDARD REGISTER SET
         AGO   .XCHK13
.XSRCAL  AIF   ('&RGS' EQ 'NO').XCHK13       SKIP IF NO REGS SAVED
&I       SETA  1                   INITIALIZE COUNTER
.XSETUP  XSRNR ST,&RGS(&I)         CALL XSRNR WITH EACH REG SET
&I       SETA  &I+1                INCREMENT TO NEXT REGS SET
         AIF   (&I LE N'&RGS).XSETUP         CONTINUE PROCESSING RGS
.XCHK13  AIF   ('&BT' NE '13').XNORM1       NOT REG 13,DO NORMALLY
.*                                                                    *
.*       REGISTER 13 DOUBLE USAGE - THIS SECTION GENERATES CODE TO    *
.*       USE REGISTER 13 BOTH AS A BASE AND AS THE SAVE AREA POINTER. *
.*                                                                    *
         AIF   (T'&AD EQ 'O').XU2  SKIP TO NORMAL IF &AD OMITTED
         LR    14,13 .             SAVE @ OLD SAVE AREA BEFORE SETTING
         XMUSE &BR,&AD             HAVE ADCON SET UP
         ST    13,8(14) .          SAVE NEW POINTER INTO OLD SAVEAREA
         ST    14,4(13) .          SAVE OLD POINTER INTO NEW AREA
         AGO   .XEND1              GO FINISH UP
.XU2     CNOP  0,4
         ST    13,&XSAVE+4 .       SAVE OLD SA POINTER INTO NEW AREA
         BAL   13,&XSAVE+72 .      SET UP 13, BRANCH AROUND SA
         XMUSE &BR                 SET UP WHATEVER USING REQUIRED
&XSAVE   DC    18F'0'  .           SAVE A¢EA
.XU3     L     15,&XSAVE+4 .       GET OLD SA POINTER BACK TO SET LINKS
         ST    13,8(15) .          STORE NEW POINTER IN OLD AREA
         AGO   .XEND1              CHECK NUMBER OF BR'S,GET LA'S SET UP
.*                                                                    *
.XNORM1  AIF   (T'&REEN EQ 'O').XNORM2       SKIP OVER REENTRANT
.*                                                                    *
.*       REENTRANT ENTRY CODE GENERATION - THIS GENERATES CODE TO     *
.*       ACQUIRE SPACE FOR SAVEAREA(72 BYTES) + AS MUCH MORE SPACE    *
.*       AS IS SPECIFIED IN REEN PARAMATER, IF USED.                  *
.*                                                                    *
         AIF   ('&TR' EQ 'NO' OR &XSAVEST).XGOK        MAKE SURE REENT
         MNOTE 0,'**XSAVE- USE OF TR OPTION IMPLIES NON-REENTRANT CODE'
.XGOK    ANOP
*        GETMAIN R,LV=8*((&REEN+79)/8)       GET SPACE ROUNDED TO D
         GETMAIN R,LV=8*((&REEN+79)/8) .GET CORE ROUNDED TO DBLWRD
         ST    13,4(1) .           STORE OLD POINTER IN NEW AREA
         ST    1,8(13) .           STORE (EW POINTER IN OLD AREA
         LR    &B1,1 .             SAVE VALUE OF NEW SAVE POINTER
         LM    0,1,20(13) .        RESTORE PREVIOUS VALUES OF REGS
         LR    13,&B1 .            POINT 13 TO NEW SAVE AREA
         AGO   .XNEWBS             GO GENERATE NEW BALR,USING
.*                                                                    *
.*       NORMAL,NON-REENTRANT ENTRY CODE SECTION.                     *
.*                                                                    *
.XNORM2  AIF   ('&SA' EQ 'NO').XNEWBS        SKIP IF NO SAVE AREA
         ST    13,&XSAVE+4 .       SAVE OLD POINTER IN NEW AREA
         AIF   ('&BT' NE '15').XSN15         SKIP IF NOT 15
         LA    13,&XSAVE .         GET ADDRESS OF NEW SAVE AREA
         L     &B1,&XSAVE+4 .      GET OLD SAVE POINTER BACK
         AGO   .XSOLD              GO SAVE NEW POINTER
.XSN15   LR    &B1,13 .            MOVE OLD POINTER OVER
         LA    13,&XSAVE    .      ADDRES> OF NEW SAVE AREA
.XSOLD   ST    13,8(&B1) .         SAVE NEW POINTER IN OLD AREA
.*             SET UP BALR, LA'S IF REQUIRED, AND USING STATEMENT.    *
.XNEWBS  AIF   ('&BT' NE '15' OR N'&BR GT 1).XSET2  SKIP IF 15
         AIF   ('&REEN' EQ '' AND '&SA' EQ 'NO' AND '&AD' EQ '').XEND2
.XSET2   AIF   (T'&AD NE 'O').XSET3          SKIP BALR IF ADCON USED
         BALR  &B1,0 .             SET UP NEW BASE REGISTER
.XSET3   XMUSE &BR,&AD             SET UP USINGS, ADCON IF NEEDED
.XEND1   AIF   (N'&BR EQ 1).XEND2  IF ONLY 1 BASE,DON'T CALL XMUSE
&I       SETA  2                    INITIALIZE
.XA2A    LA    &BR(&I),4095 .       LOAD IN ADDRESS
         LA    &BR(&I),1(&BR(&I),&BR(&I-1))  .   SET USING VALUES
&I       SETA  &I+1                 INCREMENT TO NEXT BASE
         AIF   (&I LE N'&BR AND &I LE 4).XA2A         LOOP FOR # BASES
.XEND2   SPACE 1
         MEND
./ ADD LEVEL=40,SOURCE=0,NAME=XSET
         MACRO
&XLABEL  XSET  &XSNAP=,&XSTOP=,&XREAD=,&XPRNT=,&XPNCH=,&XTIME=,        X
               &XSAVE=,&XRETURN=
.*--> MACRO: XSET       CONTROL XMACRO GENERATION . . . . . . . . . . .
.*                                 JOHN R. MASHEY - FEB 1970 - V.4.0  *
.*       XSET IS USED TO CONTROL GENERATION OF X-MACROS OF THE NAMES  *
.*       USED AS OPERANDS. NAME=OFF CANCELLS THE GIVEN MACRO UNTIL    *
.*       NAME=ON IS CODED.  ALL NAMES ARE ON UNLESS CANCELLED. ALL    *
.*       CODE MAY BE ELIMINATED FOR ANY MACROS EXCEPT XSAVE/XRETURN,  *
.*       WHOSE TRACE CODE ONLY IS ELIMINATED.                         *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLB  &XSNAPST,&XSTOPST,&XSAVEST,&XRETUST     STATUS VARS
         GBLB  &XREADST,&XPRNTST,&XPNCHST,&XTIMEST
         AIF   (T'&XLABEL EQ 'O').XNOLB  GEN LABEL ONLY IF NEEDED
&XLABEL  DS    0H  .               LABEL APPEARED ON AN XSET
.XNOLB   ANOP
&XSNAPST SETB (('&XSNAP' EQ 'OFF') OR ((T'&XSNAP EQ 'O') AND &XSNAPST))
&XSTOPST SETB (('&XSTOP' EQ 'OFF') OR ((T'&XSTOP EQ 'O') AND &XSTOPST))
&XREADST SETB (('&XREAD' EQ 'OFF') OR ((T'&XREAD EQ 'O') AND &XREADST))
&XPRNTST SETB (('&XPRNT' EQ 'OFF') OR ((T'&XPRNT EQ 'O') AND &XPRNTST))
&XPNCHST SETB (('&XPNCH' EQ 'OFF') OR ((T'&XPNCH EQ 'O') AND &XPNCHST))
&XTIMEST SETB (('&XTIME' EQ 'OFF') OR ((T'&XTIME EQ 'O') AND &XTIMEST))
&XSAVEST SETB (('&XSAVE' EQ 'OFF') OR ((T'&XSAVE EQ 'O') AND &XSAVEST))
&XRETUST SETB  (('&XRETURN' EQ 'OFF') OR ((T'&XRETURN EQ 'O') AND      X
               &XRETUST))
         MEND
./ ADD LEVEL=40,SOURCE=0,NAME=XSNAP
         MACRO
&XLABEL  XSNAP &T=PR,&LABEL=,&STORAGE=,&IF=
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XSNAP      EXTENDED SNAP MACRO-DEBUGGING-DUMPING.        *
.*                                 JOHN R. MASHEY - FEB 1970 - V.4.0  *
.*       XSNAP     IS USED FOR STORING,PRINTING OF REGISTERS AND ANY  *
.*       OTHER ADDRESSIBLE AREAS. XSNAP HARMS NO REGISTERS,CAN BE USED*
.*       IN ANY NUMBER OF CSECTS IN 1 ASSEMBLY,AND PRINTS REGISTERS   *
.*       EXACTLY AS THEY ARE WHEN THE XSNAP IS CALLED.  XSNAP         *
.*       ACTION MAY BE MADE CONDITIONAL EITHER AT ASSEMBLY TIME OR    *
.*       DURING EXECUTE TIME.  SEE WRITEUP FOR OPERAND DESCRIPTION.   *
.*       USES MACROS: XLOOK                                           *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLA  &XXLOOK             XLOOK RETURN VALUE
         GBLB  &XSNAPST            GENERATION STATUS,ON=0,OFF=1
         LCLA  &I,&K,&L,&N         LOCAL COUNTERS
         LCLB  &XP,&XF             PRINT REGS AND PRINT FLOATING REGS
         LCLC  &NAM,&INST,&A(5)
.*                                                                    *
.*       CHECK FOR XSNAPS BEING CANCELLED. CREATE LABEL IF NEEDED.    *
.*                                                                    *
         AIF   (NOT &XSNAPST).XGOGEN   GENERATE IF STATUS=ON
         AIF   (T'&XLABEL EQ 'O').XXEXIT    SKIP IF NOTHING TO GEN
&XLABEL  DS    0H  .               LABEL USED ON NULLIFIED XSNAP
         MEXIT
.XGOGEN  SPACE 1
&NAM     SETC  'XX&SYSNDX'         SET UP MOST OF NAME FOR LABELS
&N       SETA  (N'&STORAGE/2)*2    GET ROUNDED NUMBER OF OPERANDS
&XLABEL  STM   0,15,&NAM.B  .      SAVE ALL REGISTERS
.*                                                                    *
.*       IF OPTION - IF IF OPTION IS USED AND HAS CORRECT ARGUMENTS,  *
.*       GENERATE A CLI, C, OR CR INSTRUCTION TO PERFORM APPROPRIATE  *
.*       TEST,DEPENDING ON THE KIND OF IF ARGUMENTS . NEGATE THE      *
.*       CONDITION AND CREATE THE RIGHT EXTENDED MNEMONIC BRANCH      *
.*       SO THAT THE XSNAP WILL BE SKIPPED IF THE STATED CONDTION IS  *
.*       NOT MET.  GENERATE USER'S OWN OPCODE IF HE SUPPLIED ONE.     *
.*                                                                    *
         AIF   (T'&IF EQ 'O').XNOIF          SKIP IF IF NOT REQUESTED
         AIF   (N'&IF GE 3).XOKIF  SKIP IF ENOUGH ARGUMENTS
         MNOTE 0,'**XSNAP- IF=&IF:IGNORED, LACKS REQUIRED 3-4 OPERANDS'
         AGO   .XNOIF              CANCEL IF OPTION
.XOKIF   XLOOK &IF(2),(H,L,E,O,P,M,Z,NH,NL,NE,NO,NP,NM,NZ)
         AIF   (&XXLOOK GT 0).XOKIF1        SKIP IF OK RELATION
         MNOTE 0,'**XSNAP- IF=&IF(2) UNKNOWN-CANCELLED'
         AGO   .XNOIF              SKIP GENERATION OF THIS OPTION
.XOKIF1  ANOP
&INST    SETC  '&IF(4)'            GET INSTRUCTION
         AIF   (N'&IF EQ 4).X      IF OPCODE SUPPLIED,SKIP CHECKING
&INST    SETC  'CLI'               MAKE TENTATIVE INSTRUCTION SETUP
         AIF   ('&IF(1)'(1,1) NE '(' OR '&IF(1)'(K'&IF(1),1) NE ')').X
&INST    SETC  'C'                 PROBABLY WANTS RX TYPE
         AIF   ('&IF(3)'(1,1) NE '(' OR '&IF(3)'(K'&IF(3),1) NE ')').X
&INST    SETC  'CR'                2 REGS-USER WANTS RR TYPE
.X       ANOP
         &INST &IF(1),&IF(3) .     TEST
&INST    SETC  'BN&IF(2)'          NEGATE COND, HOPE FOR 1 OF 1ST SET
         AIF   (&XXLOOK LE 7).XOKIF2        SKIP IF NOW SET UP RIGHT
&INST    SETC  'B'.'&IF(2)'(2,2)   REMOVE N FROM COND
.XOKIF2  &INST &NAM.C
.*                                                                    *
.*             CREATE BRANCH AROUND THE SAVE AREA, FLAGS, ETC.        *
.*                                                                    *
.XNOIF   XLOOK &T(1),(PR,PRINT,FL,FLOAT,NO,NOREGS,ST,STORE)
&I       SETA  72+4*&N             LENGTH FOR T=PRINT,NOREGS
         AIF   (&XXLOOK LE 6).XBRNCH        SKIP IF ILLEGAL, OR PR,NO
&I       SETA  68                  LENGTH FOR T=STORE
.XBRNCH  B     &NAM.B+&I  .        BRANCH AROUND CONSTANTS
.*                                                                    *
.*       CREATE FRONT BRACKET CHARACTER STRING FOR REGISTER AREA      *
.*                                                                    *
         DS    0F  .               ALIGN LABEL ON FULLWORD
&L       SETA  8                   SET &L FOR NO LABEL= LENGTH
         AIF   (T'&LABEL EQ 'O').XNOLAB      IF NO LABEL,SKIP GENERATIO
&L       SETA  ((K'&LABEL+1)/4)*4  ROUND LENGTH UP TO FULLWORD
         AIF   (&L LE 92).XLAB1    SKIP IF LABEL SMALL ENOUGH
         MNOTE 0,'**XSNAP- LABEL= OPERAND TRUNCATED TO 92 CHARACTERS'
&L       SETA  92                  TRUNCATE
.XLAB1   DC    CL&L&LABEL
         AGO   .XCHK1              SKIP GENRATION OF 1ST DELIMETER
.XNOLAB  DC    CL8'&NAM.B'   .     FRONT BRACKET FOR REGISTER AREA
.*                                                                    *
.*             CREATE REGISTER AREA, BRACKETS, FLAG VALUES, AS NEEDED *
.XCHK1   AIF   (&XXLOOK LT 7).XPRINT        SKIP IF PRINTED OUTPUT
&NAM.B   DC    16F'-1',4C'X' .     REGISTER SAVE AREA, BRACKET X'S
         AGO   .XIFLB              SKIP TO CHECK FOR IF LABEL
.XPRINT  AIF   (&XXLOOK GT 0).XPRINT1       SKIP IF LEGAL T=
         MNOTE 0,'**XSNAP- UNKNOWN T=&T: T=PR ASSUMED'
.XPRINT1 ANOP
&XP      SETB  (&XXLOOK LT 5)      SET TO 1 IF GP REGS NEEDED
&XF      SETB  (&XXLOOK GT 2 AND &XP)       SET TO 1 IF T=FL OR T=FLOAT
&XF      SETB  (&XF OR '&T(2)' EQ 'FL' OR '&T(2)' EQ 'FLOAT')
&NAM.B   DC    16F'-1',B'&T(3)00&XF&XP',AL1(0,&L,&N/2),V(XXXXSNAP)
.*                                                                    *
.*       GENERATE ADDRESS LIST FOR STORAGE=, WITH EITHER WORDS FOR    *
.*       STORING ADDRESSES OR A-TYPE ADDRESS CONSTANTS.               *
.*                                                                    *
         AIF   (T'&STORAGE EQ 'O').OKN      SKIP IF STORAGE= NOT USED
&I       SETA  1                   INITIALIZE AS COUNTER
         AIF   (&N EQ N'&STORAGE).LOOP1               SKIP IF LEGAL
         MNOTE 0,'**XSNAP- ODD OPERAND IGNORED: STORAGE=&STORAGE(&N)'
         AIF   (&N EQ 0).OKN
.LOOP1   AIF   ('&STORAGE(&I)'(1,1) NE '*').LOOP1E
&K       SETA  1                   INITIALIZE COUNTER
.*             PROCESS ADDRESS REQUIRING LA - ST COMBINATION          *
.LOOP1A  AIF   (&I+&K GT &N).LOOP1C         SKIP IF WE'RE AT END
         AIF   ('&STORAGE(&I+&K)'(1,1) NE '*').LOOP1C SKIP IF NOT *
&K       SETA  &K+1                INCREM # CONSECUTIVE *FORMS
         AGO   .LOOP1A             GO CHECK NEXT
.LOOP1C  DS    &K.A .              WORDS WHERE ADDRESSES WILL BE STORED
&I       SETA  &I+&K               INCREMENT
         AGO   .LOOP1G             GO FOR NEXT CHECK
.*             PROCESS ADDRESS CONSTANT TYPE OF OPERAND               *
.LOOP1E  DC    A(&STORAGE(&I))
&I       SETA  &I+1                INCREMENT # OPERANDS DONE
.LOOP1G  AIF   (&I LE &N).LOOP1    CONTINUE IF ANY MORE
.*                                                                    *
.*       CREATE LOAD ADDRESS - STORE PAIRS FOR EXPRESSION ADDRESSES   *
.*                                                                    *
&I       SETA  1
.LOOP2   AIF   ('&STORAGE(&I)'(1,1) NE '*').LOOP2E    SKIP IF NOT *
&L       SETA  K'&STORAGE(&I)-1    GET # CHARAS IN EXPRESSION
&K       SETA  1                   INIT COUNTER
         AIF    (&L LE 40).LOOP2A  SKIP IF SMALL ENOUGH
         MNOTE 8,'**XSNAP- STORAGE(&I) LONGER THAN 40 CHARACTERS'
&L       SETA  40                  TRUNCATE AND HOPE IT GOES
.*       BREAK EXPRESSION INTO 8 CHARACTER SECTIONS.                  *
.LOOP2A  ANOP
&A(&K)   SETC  '&STORAGE(&I)'(8*&K-6,8)      GET UP TO 8 NEXT CHARS
&K       SETA  &K+1                INCRMENT COUNTER
         AIF   (8*&K-8 LT &L).LOOP2A        LOOP UNTIL HAVE WHOLE OPR
         LA    0,&A(1)&A(2)&A(3)&A(4)&A(5)
         ST    0,&NAM.B+4*&I+68    STORE ADDRESS IN LIST
.LOOP2C  ANOP
&K       SETA  &K-1                DECRMENT SECTION TO NULL
&A(&K)   SETC  ''                  NULL FOR NEXT USE
         AIF   (&K GT 2).LOOP2C    CONTINUE UNTIL ALL BUT &A(1) NULL
.LOOP2E  ANOP
&I       SETA  &I+1                INCREMENT POSITION IN LIST
         AIF   (&I LE &N).LOOP2    CONTINUE WITH LIST
.*                                                                    *
.*       CREATE CODE TO SET UP REGISTERS FOR XXXXSNAP,CALL IT,AND     *
.*       RESTORE REGS ON RETURN.  XXXXSNAP RESTORES THE CONDTION CODE.*
.*                                                                    *
.OKN     LA    10,&NAM.B  .        GET ADDRESS OF REGISTER BLOCK
         L     15,68(10) .         GET V(XXXXSNAP) FOR BRANCH
         BALR  14,15 .             CALL XXXXSNAP,POINT 14 AT NEXT INST
         LM    0,15,0(10) .        RELOAD THE REGISTERS
.*             CREATE LABEL FOR IF OPTION, IF IT WAS USED.            *
.XIFLB   AIF   ('&INST' EQ '').XEXIT         SKIP GEN OF IF LABEL
&NAM.C   EQU   * .                 DEFINE LABEL FOR IF= BRANCH
.XEXIT   SPACE 2
.XXEXIT  MEND
./ ADD LEVEL=40,SOURCE=0,NAME=XSRNR
         MACRO
         XSRNR &OP,&RG,&NO15
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XSRNR      SAVE/RESTORE REGISTERS FOR XSAVE/XRETURN      *
.*                                 JOHN R. MASHEY- FEB 1970 - V.4.0   *
.*             THIS MACRO IS USED BY XSAVE AND XRETURN TO SET UP      *
.*       REGISTER SAVING AND RESTORATION.                             *
.*       &OP IS THE OPCODE TO BE USED.  I.E.  EITHER L  OR ST.        *
.*       &RG  IS 1 OPERAND FROM THE &RGS OPERAND USED BY XSAVE AND    *
.*             XRETURN.  IT IS EITHER 1 REGISTER, OR A PAIR OF REGS   *
.*             SEPARATED BY A DASH.                                   *
.*       &NO15   =0  STATES THAT A RETURN CODE IS CURRENTLY IN REG 15 *
.*             AND SHOULD NOT BE DISTURBED, REGARDLESS OF HOW THE REGS*
.*             ARE SPECIFIED.                                         *
.*       USES MACROS: XCHAR                                           *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLC  &XXCHAR             FOR COMMUNICATION WITH XCHAR
         LCLA  &I
         LCLC  &R1,&R2             1ST REG, 2ND REG, TEMPORARY
         AIF   ('&RG' EQ 'NO').XXEXIT        DON'T GEN ANYTHING
.*             SCAN FOR DASH-MEANING 2 REGISTERS.                     *
.XSL1    ANOP
&I       SETA  &I+1                INCREMENT FOR NEXT CHARACTER
         AIF   ('&RG'(&I,1) EQ '-').XDASH    JUMP IF DASH FOUND
         AIF   (&I LT K'&RG).XSL1  CONTINUE TO END OF OPERAND
&R1      SETC  '&RG'               &RG IS 1 REGISTER BY ITSELF
         AGO   .XSAA               GO TO NEXT DECISION POINT
.*             FOUND DASH-NOW SEPARATE THE REGISTERS.                 *
.XDASH   ANOP
&R1      SETC  '&RG'(1,&I-1)       GET FIRST REGISTER
         AIF   (&I EQ K'&RG).XSAA  DUMB USER - 1 REG FOLLOWED BY -
&R2      SETC  '&RG'(&I+1,K'&RG-&I)         GET 2ND REGISTER
.XSAA    XCHAR &R1,2               GET UP TO LAST 2 CHARS OF 1ST REG
         AIF   ('&XXCHAR' NE '14' AND '&XXCHAR' NE '15').XNO1415
&I       SETA  4*&XXCHAR-44         OFFSET FOR 14 OR 15
         AIF   ('&R2' NE '').XS2RG SKIP IF 2 REGISTERS SPECIFIED
         AIF   ('&XXCHAR' EQ '15' AND '&NO15' EQ '0').XXEXIT
         &OP   &R1,&I.(13)  .       SAVE/RESTORE 1 REG
         MEXIT
.XS2RG   AIF   ('&NO15' EQ '0').XSN15        SKIP IF 15 SHOULDN'T BE
         &OP.M &R1,&R2,&I.(13)  .  SAVE/RESTORE RANGE OF REGS
         MEXIT
.XSN15   AIF   ('&XXCHAR' EQ '15').XSN15A    SKIP IF 15 SPECIFIED
         L     &R1,12(13)  .        RELOAD REG 14
         XCHAR &R2,2                GET 2ND REG
         AIF   ('&XXCHAR' EQ '15').XXEXIT    SKIP IF 15 SPECIFIED
.XSN15A  LM    0,&R2,20(13)  .     RELOAD REST OF REGS
         MEXIT
.*             RESTORE 1 REG OR RANGE (NOT STARTING WITH 14 OR 15).   *
.XNO1415 AIF   ('&R2' NE '').XLMSTM          JUMP IF MULTIPLE REGS
         &OP   &R1,&R1*4+20(13)
         MEXIT
.XLMSTM  &OP.M &R1,&R2,&R1*4+20(13)
.XXEXIT  MEND
./ ADD LEVEL=40,SOURCE=0,NAME=XSRTR
         MACRO
         XSRTR &TR,&LABEL,&MSG
.*--> MACRO: XSRTR      GENERATE TRACE CODE FOR XSAVE/XRETURN . . . . .
.*                                 JOHN R. MASHEY- FEB 1970 - V.4.0   *
.*       THIS MACRO IS USED BY XSAVE AND XRETURN TO GENERATE THE      *
.*       TRACE CODE CALLS TO XSNAP OR XPRNT, OR TIMING CALLS TO XTIME.*
.*       MACROS CALLED BY THIS MACRO - XLLOK, XPRNT,XSNAP,XTIME       *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLA  &XXLOOK             FOR COMMUNICATION 0WITH XLOOK
         GBLB &XSNAPST,&XPRNTST    GLOBALS FOR OUTPUT MACROS
         LCLA  &I                  FOR USE AS LENGTH SPECIIFICATION
         LCLB  &XSTSAV             FOR SAVING STAUS VARIABLES
         LCLC  &NAME               FOR EITHER LABEL OR CSECT
         XLOOK &TR(1),(*,SNAP,TIME)         CHECK TYPE
         AIF   (&XXLOOK LT 3).XPS  SKIP IF NOT TIME
*        XTIME ,&TR(2)
         XTIME ,&TR(2)
         MEXIT
.XPS     AIF   (&XXLOOK EQ 0 AND N'&TR GT 1 AND '&TR(2)' NE 'SNAP').XE
&NAME    SETC  '&LABEL'            ASSUME NAME IS LABEL
         AIF   (T'&LABEL NE 'O').XNOK1       SKIP IF LABEL EXISTS
&NAME    SETC  '&SYSECT'           USE CSECT NAME INSTEAD
         AIF   ('&SYSECT' NE '').XNOK1       SKIP IF CSECT NOT PC
&NAME    SETC  '$PRIVATE'          USE NAME FOR PRIVATE CODE (PC)
.XNOK1   AIF   (&XXLOOK EQ 2 OR '&TR(2)' EQ 'SNAP').XNSNAP
&XSTSAV  SETB  (&XPRNTST)          SAVE STATUS VARIABLE
&XPRNTST SETB  (0)                 MAKE SURE XPRNT WILL GENERATE
         AIF   (&XXLOOK EQ 1).XDFTA         SKIP- TR=* - DEFAULT
&I       SETA 2*((K'&TR)/2)        GET RIGHT TOTAL LENGTH FOR DC
         B     *+4+&I .            BRANCH AROUND MESSAGE
XX&SYSNDX.T DC C'0',CL(&I-1)&TR
         AGO   .XPRB               SKIP OVER ALTERNATE
.XDFTA   B     *+28 .              BRANCH AROUND MESSAGE
XX&SYSNDX.T DC CL24'0*** &NAME &MSG ***'
&I       SETA  24                  SET UP FOR XPRNT
.XPRB    ANOP
*        XPRNT XX&SYSNDX.T,&I      PRINT MESSAGE WITH GIVEN LENGTH
         XPRNT XX&SYSNDX.T,&I
&XPRNTST SETB  (&XSTSAV)           RESTORE PREVIOUS VALUE
         MEXIT
.XE      MNOTE 0,'**XSRTR- TR=&TR: UNKNOWN, IGNORED'
         MEXIT
.XNSNAP  ANOP
&XSTSAV  SETB  (&XSNAPST)          SAVE XSNAP STATUS, IN CASE OFF
&XSNAPST SETB  (0)                 MAKE SURE XSNAP WILL GENERATE
*        XSNAP LABEL='  MESSAGE '
         AIF   (&XXLOOK EQ 2).XDFTB         SKIP IF TR=SNAP
         XSNAP LABEL=&TR(1)
         AGO   .XSNB               SKIP OVER ALTERNATE
.XDFTB   XSNAP LABEL='*** &NAME &MSG ***'
.XSNB    ANOP
&XSNAPST SETB  (&XSTSAV)           RESTORE STATUS,IN CASE IT WAS OFF
         MEND
./ ADD LEVEL=40,SOURCE=0,NAME=XSTOP
         MACRO
&LABEL   XSTOP &N=2,&ABEND=200,&GOTO=
.*--> MACRO: XSTOP      CONTROL PROGRAM LOOPS . . . . . . . . . . . . .
.*                                 JOHN R. MASHEY - FEB 1970 - V.4.0  *
.*       XSTOP     IS USED TO STOP INFINITE LOOPS IN ASSEMBLER        *
.*         N=NUMBER   WILL CAUSE THE PROGRAM TO ABEND THE NUMBER'TH   *
.*             TIME THROUGH THE XSTOP.  DEFAULT IS N=2,               *
.*             WHICH MEANS THE XSTOP CAN ONLY BE ENCOUNTERED ONCE     *
.*             BEFORE IT ABENDS.                                      *
.*         ABEND=K      K WILL BE THE COMPLETION CODE ISSUED BY THE   *
.*             EMBEDDED ABEND MACRO.  DEFAULT IS 200.                 *
.*         GOTO=LABEL   BRANCH TO LABEL INSTEAD OF ABENDING           *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLB  &XSTOPST            XSTOP GENERATION STATUS,ON=0,OFF=1
         LCLC  &XNAM               NAME FOR CONSTANTS
         AIF   (&XSTOPST).XXNOG    SKIP IF NOGEN
&XNAM    SETC  'XX&SYSNDX.V'       GET UNIQUE LABEL
&LABEL   ST    0,&XNAM   .         SAVE WORK REGISTER
         L     0,&XNAM+4   .       LOAD CURRENT COUNTER VALUE
         BCT   0,&XNAM+8   .       BRANCH IF STILL OK,DECREMENT REG
         L     0,&XNAM .           RESTORE WORK REGISTER
         AIF   ('&GOTO' EQ '').XXAB         SKIP IF NO GOTO USED
         B     &GOTO  .            TAKE DESIRED BRANCH
         AGO   .XXDC               SKIP TO GENERATE DC'S
.XXAB    ABEND &ABEND,DUMP
.XXDC    ANOP
&XNAM    DC    A(0,&N)    .        REGISTER SAVE AREA, COUNTER
         ST    0,&XNAM+4   .       SAVE DECREMENTED COUNTER VALUE
         L     0,&XNAM   .         RESTORE WORK REGISTER
         SPACE 2
         MEXIT
.XXNOG   AIF   (T'&LABEL EQ 'O').XXEXIT     SKIP IF NO LABEL
&LABEL   DS    0H
.XXEXIT  MEND
./ ADD LEVEL=40,SOURCE=0,NAME=XXGPSRCH
         MACRO
        XXGPSRCH &DIREC,&TIME
.**-->MACRO: XXGPSRCH  INNER MACRO FOR XGPGEN . . . . . . . . . . . . .
.*     ARGUMENTS:
.*       &DIREC= G--> INPUT
.*               P--> OUTPUT
.*       &TIME=1 --> FIRST CALL, SETS UP EXTRA CODE AND ACTS AS &SYSNDX
.*             2--> SECOND CALL
.*. . . . . . . . . . . . .. .  . . . . . . . . . . . . . . . . . . . .
         L     R3,X&DIREC.ELEM .   GET # LAST POINTER TO OPEN FILES
         LA    R1,X&DIREC.PNTSRT . GET @ OF FIRST POINTER
         LTR   R3,R3 .             ARE THERE ANY ELEMENTS?
         BE    X&DIREC.MAKE&TIME   NO - GO CREATE ONE
         LA    R2,12 .             SET UP INCREMENT SIZE
X&DIREC.LOOP&TIME CLC 0(8,R1),X&DIREC.CURENT COMPARE DD NAMES
         BE    X&DIREC.CONT&TIME   IF EQUAL, GO TO I/O
         BXLE  R1,R2,X&DIREC.LOOP&TIME ^EQUAL, SEARCH TILL END OF TABLE
         SPACE 2
         MEND
//*
//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
//* STEP 5 - ADD ASSIST PROCEDURE TO SYS2.PROCLIB.
//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
//*
//PROC     EXEC PGM=IEBUPDTE,PARM=NEW
//SYSPRINT DD  SYSOUT=*
//SYSUT2   DD  DISP=SHR,DSN=SYS2.PROCLIB         <== TARGET LIBRARY
//SYSIN    DD  DATA
./ ADD NAME=ASSIST
//ASSIST   PROC
//DATA     EXEC PGM=ASSIST,REGION=4096K,PARM='BATCH,MACRO=H'
//SYSPRINT DD  SYSOUT=*
//SYSIN2   DD  DDNAME=SYSIN2  (ONLY NEEDED IF &$DATARD=1: 2 READERS)
//SYSPRINT DD  SYSOUT=*,DCB=(RECFM=FA,LRECL=133,BLKSIZE=133) PRINTER
//SYSPUNCH DD  SYSOUT=B,DCB=(RECFM=F,LRECL=80,BLKSIZE=80)    PUNCH
//SYSUT1   DD  UNIT=SYSDA,DISP=(,DELETE),SPACE=(3520,(100,10)),
//             DCB=(RECFM=F,BLKSIZE=3520)      DISK INTERMEDIATE
//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR
/*
//
