{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220013529000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 352716, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 8, "INMDSNAM": "CBT.V500.FILE942.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 352716, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 352716, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE942.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x07\\t'", "DS1TRBAL": "b'i\\xb8'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xc0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xc0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\t\\xa8\\x00\\x06\\t\\xa8\\x00\\r\\x00\\x08'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04c\\x00Y\\x01 \\x11\\x9f\\x01 \\x11\\x9f\\x163\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf9@@@'", "ispf": {"version": "04.99", "flags": 0, "createdate": "2020-04-28T00:00:00", "modifydate": "2020-04-28T16:33:59", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-499"}, "text": "REGULAR CBT TAPE - VERSION 499    FILE:  942\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT499.FILE942\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 12 MEMBERS COUNTED; CUMULATIVE SIZE IS 2,647 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   04/28/20    16:33:59    UTC-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$$VSAM": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x0e\\x00!\\x01\\x10\\x04\\x8f\\x01\\x17'\\x0f\\x08S\\x00\\r\\x00\\x08\\x00\\x00\\xe3\\xd9\\xc9\\xc4\\xd1\\xd2@@@@\"", "ispf": {"version": "01.14", "flags": 0, "createdate": "2010-02-17T00:00:00", "modifydate": "2017-09-27T08:53:21", "lines": 13, "newlines": 8, "modlines": 0, "user": "TRIDJK"}, "text": "To install the Steve Kleeves VSAM Information dialog (CBT File 137).\n\n1.  TSO RECEIVE the VSAMXMIT member.\n2.  Copy panels VI#1 and VI#1H to an ISPPLIB dataset.\n3.  Copy rexxes VI, VIX, and RXDATE to a SYSPROC or SYSEXEC dataset.\n\nTo run the VSAM Information dialog.\n\n1.  Enter the VS line command on the PDS LISTC function display.\n2.  Enter the VI/VIX line command on the ISPF 3.4 DSLIST display.\n\nNote: use the VIX rexx exec if you need to define LIBDEF's.\n      First, it must be customized with your own exec and panel DSN's.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE942": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04c\\x00Q\\x01 \\x11\\x9f\\x01 \\x11\\x9f\\x163\\x00-\\x00-\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf9@@@'", "ispf": {"version": "04.99", "flags": 0, "createdate": "2020-04-28T00:00:00", "modifydate": "2020-04-28T16:33:51", "lines": 45, "newlines": 45, "modlines": 0, "user": "CBT-499"}, "text": "//***FILE 942 comes by way of John Kalinich, but is the work of     *   FILE 942\n//*           several people.  The cornerstone of this file is      *   FILE 942\n//*           the two REXXes called VI (alias VSAM), and VCX,       *   FILE 942\n//*           together with their panels, VI#1 and VI#1H.           *   FILE 942\n//*                                                                 *   FILE 942\n//*           These allow you to find information about VSAM        *   FILE 942\n//*           datasets, directly from an ISPF 3.4 panel.            *   FILE 942\n//*                                                                 *   FILE 942\n//*           VI     -  lists \"LISTC-type\" information, but         *   FILE 942\n//*                     on a panel -- easy to read.                 *   FILE 942\n//*                                                                 *   FILE 942\n//*           VSAM   -  an alias for VI                             *   FILE 942\n//*                                                                 *   FILE 942\n//*           VCX    -  generates a DEFINE statement to             *   FILE 942\n//*                     recatalog the dataset.  (valuable..!!)      *   FILE 942\n//*                                                                 *   FILE 942\n//*       Try them.... You'll like them.....!!                      *   FILE 942\n//*                                                                 *   FILE 942\n//*       In order to get VCX to work properly, you will need       *   FILE 942\n//*       a TSO command to clear the screen.  It should be          *   FILE 942\n//*       renamed to the name CLEAR, or you can change the name     *   FILE 942\n//*       in the VCX exec.  Two of these have been supplied:        *   FILE 942\n//*                                                                 *   FILE 942\n//*       Members CLEAR and CLEAR$ (program and assembly JCL)       *   FILE 942\n//*                                                                 *   FILE 942\n//*       Member CLS (another program which does essentially        *   FILE 942\n//*           the same thing).                                      *   FILE 942\n//*                                                                 *   FILE 942\n//*       Two other programs have also been supplied here:          *   FILE 942\n//*                                                                 *   FILE 942\n//*           LISTCSUM  - A REXX to break LISTC output into         *   FILE 942\n//*                       parse-able chunks (also needs \"CLEAR\")    *   FILE 942\n//*                                                                 *   FILE 942\n//*           RXDATE    - A REXX subroutine to convert dates        *   FILE 942\n//*                       in many ways.                             *   FILE 942\n//*                                                                 *   FILE 942\n//*           email:  jkalinic@outlook.com                          *   FILE 942\n//*                                                                 *   FILE 942\n//*           email:  sbgolob@cbttape.org                           *   FILE 942\n//*                                                                 *   FILE 942\n//*       28 Apr 2020                                               *   FILE 942\n//*          - Jim Turner (jim_turner@triserv.com) added            *   FILE 942\n//*            additional informational fields for SMS/RLS and      *   FILE 942\n//*            made the VI#1 panel scrollable.                      *   FILE 942\n//*                                                                 *   FILE 942\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CLEAR": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'P\\x06\\x00\\x00\\x01\\x05\\x03O\\x01\\x14\\x05/\\x13X\\x00Y\\x00*\\x00;\\xc7\\xc5\\xd9\\xc8\\xc1\\xd9\\xc4@@@'", "ispf": {"version": "80.06", "flags": 0, "createdate": "2005-02-03T00:00:00", "modifydate": "2014-02-21T13:58:00", "lines": 89, "newlines": 42, "modlines": 59, "user": "GERHARD"}, "text": "CLR70    TITLE 'C L E A R  ***  CLEAR SCREEN ON TSO/VTAM CRT'\n         PUNCH ' ENTRY CLEAR   '                                GP05033\n         PUNCH '  ORDER CLEAR(P) '     NEAT DUMPS\n         PRINT GEN\n***********************************************************************\n*                                                                     *\n*        CLEAR - TSO CLEAR SCREEN COMMAND                             *\n*              RENT,REFR,REUS                                         *\n*                                                                     *\n*        RECOMMENDED ALIAS OF CLR3270 FOR COMPATIBILITY               *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n*        WRITTEN FROM A SUGGESTION IN TECHNICAL SUPPORT MAGAZINE,     *\n*        VOL. 4, NUMBER 15 (DEC. 1990), PAGE 10                       *\n*                                                                     *\n***********************************************************************\nCLEAR    CSECT\n         USING SAVE,R13\nA@0002   B     B@0002-*(,R15)\n         DC    AL1(L'N@0002)\nN@0002   DC    C'CLEAR - &SYSDATE - &SYSTIME'\n\nB@0002   STM   R14,R12,SAVE14\n         LR    R12,R15\n         LR    R11,R1\n         USING A@0002,R12\n         LA    R14,SAVEND-SAVE\n         LR    0,R14                   LOAD LENGTH\n         BAL   1,*+4                   INDICATE GETMAIN\n         SVC   10                      ISSUE GETMAIN SVC\n         ST    R14,SAVESPLN-SAVE(R1)\n         ST    R1,SAVEFWD\n         ST    R13,SAVE13-SAVE(R1)\n         LR    R13,R1\nSAVE     DSECT\nSAVESPLN DS    F\nSAVE13   DS    F\nSAVEFWD  DS    A\nSAVE14   DS    A\nSAVE15   DS    A\nSAVE0    DS    A\nSAVE1    DS    A\nSAVE2    DS    A\nSAVE3    DS    A\nSAVE4    DS    A\nSAVE5    DS    A\nSAVE6    DS    A\nSAVE7    DS    A\nSAVE8    DS    A\nSAVE9    DS    A\nSAVE10   DS    A\nSAVE11   DS    A\nSAVE12   DS    A\nSAVEFWK  EQU   *\nCLEAR    CSECT\n         YREGS\n*        GTSIZE ,            CHECK FOR A CRT\n         GTSIZE\n         CH    R0,=H'1'      MORE THAN ONE LINE ?\n         BNH   GETOUT        NO\n         STFSMODE ON,INITIAL=YES\n         BXH   R15,R15,NOTVTAM\n         STLINENO LINE=1,MODE=ON\n         STFSMODE OFF\n         B     GETOUT\nNOTVTAM  TPUT  SCRNCLR,SCRNCLRL,NOEDIT\nGETOUT   L     R0,SAVESPLN-SAVESPLN(,R13)\n         LR    R1,R13\n         L     R13,SAVE13-SAVESPLN(,R13)\n         SVC   10\n         LM    R14,R12,SAVE14-SAVESPLN(R13)\n         MVI   SAVE14-SAVESPLN(R13),X'FF'\n         XR    R15,R15\n         BR    R14\n         SPACE 1\nSCRNCLR  DC    C'C'\n         DC    X'11'                    SET BUFFER ADDRESS\n         DC    C'  '\n         DC    C' '\n         DC    X'3C'                    REPEAT TO ADDRESS\n         DC    C'  '\n         DC    C' '\n         DC    X'13'                    INSERT CURSOR\nSCRNCLRL EQU   *-SCRNCLR\n         SPACE 1\nSAVE     DSECT ,             SAVE/WORK AREA\nSAVEND   EQU   *\n         END   ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CLEAR$": {"ttr": 525, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x001\\x00\\x994/\\x01\\x16\\x11\\x7f\\x13W\\x00\\x1b\\x00\\x1d\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1999-12-08T00:00:00", "modifydate": "2016-04-26T13:57:31", "lines": 27, "newlines": 29, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(CLEAR)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET,RENT,REUS,REFR'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB     <-- YOUR LIBRARY\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB     <-- YOUR LIBRARY\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n SETCODE AC(0)\n SETSSI  CB488221\n NAME    CLEAR(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CLS": {"ttr": 527, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x03\\x00\\x00\\x00\\x00\\x90\\x07\\x9f\\x00\\x97\\x15\\x1f\\tH\\x00\\x15\\x00\\x03\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf1\\xf5@@@@'", "ispf": {"version": "03.00", "flags": 0, "createdate": "1990-03-20T00:00:00", "modifydate": "1997-05-31T09:48:00", "lines": 21, "newlines": 3, "modlines": 0, "user": "CBT415"}, "text": "//GILBERTK JOB (ACCT#),CLS,\n// CLASS=A,MSGCLASS=H,COND=(0,NE)\n//HLASM EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n*---------------------------------------------------------------------*\n*        TSO \"CLEAR SCREEN\" COMMAND                                   *\n*---------------------------------------------------------------------*\nCLEARSCR CSECT\nCLEARSCR RMODE ANY\n         STLINENO LINE=1,CLEAR=YES     TOP OF SCREEN\n         BR    14                      GOBACK\n         DC    C'GSF UTILITIES - CLS R300'\n         END\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,1)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),BLKSIZE=3200\n//*\n//LKED    EXEC PGM=HEWL,PARM=(MAP,RENT)\n//SYSLIN   DD DSN=*.HLASM.SYSLIN,DISP=(OLD,PASS)\n//SYSLMOD  DD DSN=CBTTAPE.FILE183.LOAD(CLS),DISP=SHR\n//SYSPRINT DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTCSUM": {"ttr": 529, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00T\\x01\\x064_\\x01 \\x12\\x8f\\x11\\x19\\x01\\xfa\\x01O\\x00\\x00\\xe2\\xd3\\xc2\\xc4@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2006-12-11T00:00:00", "modifydate": "2020-05-07T11:19:54", "lines": 506, "newlines": 335, "modlines": 0, "user": "SLBD"}, "text": "/* REXX    LISTCSUM   Parse and isolate LISTCAT output to discrete,\n                      identifiable packets.\n\n           Written by Frank Clarke 20020318\n\n     Impact Analysis\n.    SYSPROC   TRAPOUT\n\n     Modification History\n     20020423 fxc enable OUTPUT; if CLUSTERASSOCIATIONS is empty,\n                  get clustername from DATAASSOCIATIONS or\n                  INDEXASSOCIATIONS and restart the command;\n     20020507 fxc no hyphens in keys\n     20020722 fxc leave queue intact if STACK\n     20030331 fxc GDGBASE implies NONVSAM and SUMMARY\n\n*/ arg argline\naddress TSO                            /* REXXSKEL ver.20010802      */\narg parms \"((\" opts\n\nsignal on syntax\nsignal on novalue\n\ncall TOOLKIT_INIT                      /* conventional start-up     -*/\nrc     = trace(tv)\ninfo   = parms                         /* to enable parsing          */\n\ncall A_INIT                            /*                           -*/\n                                    if sw.0error_found then return\ncall B_LISTC                           /*                           -*/\ncall C_PARSE                           /*                           -*/\ncall D_REPORT                          /*                           -*/\n\nif sw.0STACK then return               /* leave the queue intact     */\nif \\sw.nested then call DUMP_QUEUE     /*                           -*/\nexit                                   /*@ LISTCSUM                  */\n/*\n.  ----------------------------------------------------------------- */\nA_INIT:                                /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   call AA_SETUP_LOG                   /*                           -*/\n   call AB_KEYWDS                      /*                           -*/\n\n   major_keys = \"ALIAS NONVSAM CLUSTER DATA INDEX SUMM\"\n   minor_keys. = \"\"\n   minor_keys.alias   = \"INCAT HISTORY ASSOCIATIONS\"\n   minor_keys.nonvsam = \"INCAT HISTORY SMSDATA VOLUMES\",\n                        \"ASSOCIATIONS ATTRIBUTES\"\n   minor_keys.gdgbase = \"INCAT HISTORY ASSOCIATIONS ATTRIBUTES\"\n   minor_keys.cluster = \"INCAT HISTORY SMSDATA RLSDATA ASSOCIATIONS\"\n   minor_keys.data    = \"INCAT HISTORY ASSOCIATIONS ATTRIBUTES\",\n                        \"STATISTICS ALLOCATION VOLUME\"\n   minor_keys.index   = \"INCAT HISTORY ASSOCIATIONS ATTRIBUTES\",\n                        \"STATISTICS ALLOCATION VOLUME\"\n   minor_keys.SUMM    = \"ARY\"\n   parse value \"\" with ,\n               valuestr.  .\n\nreturn                                 /*@ A_INIT                    */\n/*\n.  ----------------------------------------------------------------- */\nAA_SETUP_LOG:                          /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   parse value \"0\" with,\n               log#    log.\n   parse value Date(\"S\")  Time(\"S\")  Time(\"N\")  with,\n               yyyymmdd   sssss      hhmmss  .\n   parse var yyyymmdd  4 yrdigit 5 mm 7 dd          /* 9 12 14 maybe */\n   if Pos(yrdigit,\"13579\") > 0 then mm = mm + 12       /* mm=24      */\n   logtag = Substr(\"ABCDEFGHIJKLMNOPQRSTUVWX\",mm,1)    /* logtag=X   */\n   subid  = logtag\"\"dd\"\"Right(sssss,5,0)               /* X1423722 ? */\n   vb4k.0    = \"NEW CATALOG UNIT(SYSDA) SPACE(1 5) TRACKS\",\n               \"RECFM(V B) LRECL(4096) BLKSIZE(0)\"\n   vb4k.1    = \"SHR\"                   /* if it already exists...    */\n   logdsn = \"@@LOG.\"exec_name\".\"subid\".#CILIST\"\n\n   call ZL_LOGMSG(exec_name \"started by\" Userid()  yyyymmdd  hhmmss)\n   call ZL_LOGMSG(\"Arg:\" argline)\n\nreturn                                 /*@ AA_SETUP_LOG              */\n/*\n.  ----------------------------------------------------------------- */\nAB_KEYWDS:                             /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   sw.0stack = SWITCH(\"STACK\")         /* return results to stack    */\n\n   outdsn    = KEYWD(\"OUTPUT\")         /* save output on DASD        */\n   if outdsn <> \"\" then do\n      sw.0stack = 1                    /* force stack                */\n\n      alloc.0 = \"NEW CATALOG UNIT(SYSDA) SPACE(5 5) TRACKS\",\n                  \"RECFM(V B) LRECL(4096) BLKSIZE(0)\"\n      alloc.1 = \"SHR\"                  /* if it already exists...    */\n      tempstat = Pos(Sysdsn(outdsn),\"OK MEMBER NOT FOUND\") > 0\n      \"ALLOC FI($TMP) DA(\"outdsn\") REU\" alloc.tempstat\n      if rc > 0 then do\n         sw.0error_found = 1\n         return\n         end\n      end                              /* outdsn                     */\n\n   parse var info   vsds  info\n   if vsds = \"\" then do\n      say \"DSName required\"\n      exit\n      end\n\nreturn                                 /*@ AB_KEYWDS                 */\n/*\n.  ----------------------------------------------------------------- */\nB_LISTC:                               /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   \"ALLOC FI(SYSPRINT) UNIT(VIO)  NEW REU SPACE(1) TRACKS\",\n            \"RECFM(V B A) LRECL(121) BLKSIZE(0)\"\n   \"ALLOC FI(SYSIN)    UNIT(VIO)  NEW REU SPACE(1) TRACKS\",\n            \"RECFM(F B) LRECL(80) BLKSIZE(0)\"\n   \"NEWSTACK\"\n   queue \"  LISTCAT ENTRIES(\"vsds\") +\"\n   queue \"          ALL\"\n   \"EXECIO\" queued() \"DISKW SYSIN (FINIS\"\n   \"DELSTACK\"\n\n   address LINKMVS \"IDCAMS\"\n\nreturn                                 /*@ B_LISTC                   */\n/*\n.  ----------------------------------------------------------------- */\nC_PARSE:                               /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   \"NEWSTACK\"\n   \"EXECIO * DISKR SYSPRINT (FINIS\"    /* load the queue             */\n   do queued()\n      parse pull 2 w1 rest\n      if w1 = \"\" then iterate\n      if WordPos(w1,\"IDCAMS LISTCAT\") > 0 then iterate\n      if w1 = \"IN-CAT\" then w1 = \"INCAT\"\n      select\n         when WordPos(w1,\"THE\") > 0 then leave\n         when WordPos(w1,\"GDG\") > 0 then do\n            /* special case: major name is two words                 */\n            parse var rest w2 rest\n            if w2 = \"BASE\" then,\n               parse value \"GDGBASE NONVSAM SUMM\" with ,\n                            major_keys 1 w1 .\n            major = w1\n            rest  = Translate(rest,\" \",\"-\")\n            valuestr.major = Space(rest,1)        /* strip           */\n            end                        /* GDG BASE                   */\n         when WordPos(w1,major_keys) > 0 then do\n            major = w1\n            rest  = Translate(rest,\" \",\"-\")\n            valuestr.major = Space(rest,1)        /* strip           */\n            end                        /* major                      */\n         when WordPos(w1,minor_keys.major) > 0 then do\n            minor = w1\n            key   = Space(major minor,0)\n            data  = Translate(rest,\" \",\"-\")\n            valuestr.key = Space(data,1)     /* strip                */\n            end                        /* minor                      */\n         otherwise do\n            data  = Translate(w1 rest,\" \",\"-\")\n            valuestr.key = valuestr.key Space(data,1)     /* strip   */\n            end                        /* value line                 */\n      end                              /* select                     */\n   end                                 /* queued                     */\n\n   info = valuestr.DATAASSOCIATIONS valuestr.INDEXASSOCIATIONS\n   /* Comment Start - remove this section of code by comment (lbd 5/7/20)\n   if valuestr.CLUSTERASSOCIATIONS = \"\" then,\n      if info <> \"\" then do            /* re-do the command          */\n         \"DELSTACK\"                    /* stack before CALL          */\n         clustername = KEYWD(\"CLUSTER\")\n         (exec_name) clustername argline\n         exit                          /* bail out                   */\n         end\n      Comment End */\n\n   major = \"SUMM\"                      /* This is kinda hokey...     */\n   key   = \"SUMMARY\"\n   do queued()                         /* gross stats                */\n      parse pull 2 w1 rest\n      if w1 = \"\" then iterate\n      select\n         when WordPos(w1,\"THE\") > 0 then leave\n         otherwise do\n            data  = Translate(w1 rest,\" \",\"-\")\n            valuestr.key = valuestr.key Space(data,1)     /* strip   */\n            end                        /* value line                 */\n      end                              /* select                     */\n   end                                 /* queued                     */\n   \"DELSTACK\"\n\nreturn                                 /*@ C_PARSE                   */\n/*\n.  ----------------------------------------------------------------- */\nD_REPORT:                              /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   \"CLEAR\"\n   if outdsn <> \"\" then \"NEWSTACK\"     /* isolate the queue          */\n   do Words(major_keys)                /* each major key             */\n      parse var major_keys major major_keys\n      do Words(minor_keys.major)       /* each minor key             */\n         parse var minor_keys.major minor minor_keys.major\n         key = Space(major minor,0)\n         if valuestr.key = \"\" then iterate\n         if sw.0stack then,\n            queue key\":\" valuestr.key\n         else do\n            say key\n            say \"     \"valuestr.key\n            end\n      end                              /* minor                      */\n   end                                 /* major                      */\n\n   if outdsn <> \"\" then do\n      \"EXECIO\" queued() \"DISKW $TMP (FINIS\"\n      \"FREE  FI($TMP)\"\n      \"DELSTACK\"\n      end\n\nreturn                                 /*@ D_REPORT                  */\n/*\n.  ----------------------------------------------------------------- */\nLOCAL_PREINIT:                         /*@ customize opts            */\n   address TSO\n\n\nreturn                                 /*@ LOCAL_PREINIT             */\n/*   subroutines below LOCAL_PREINIT are not selected by SHOWFLOW    */\n/*\n.  ----------------------------------------------------------------- */\nZB_SAVELOG:                            /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   if Symbol(\"LOG#\") = \"LIT\" then return          /* not yet set     */\n\n   \"ALLOC FI($LOG) DA(\"logdsn\") REU\" vb4k.0\n   \"EXECIO\" log# \"DISKW $LOG (STEM LOG. FINIS\"\n   \"FREE  FI($LOG)\"\n\nreturn                                 /*@ ZB_SAVELOG                */\n/*\n.  ----------------------------------------------------------------- */\nZL_LOGMSG: Procedure expose,           /*@                           */\n   (tk_globalvars)  log. log#\n   rc = Trace(\"O\")\n   address TSO\n\n   parse arg msgtext\n   parse value  log#+1  msgtext     with,\n                zz      log.zz    1  log#   .\n\n   if monitor then say,\n      msgtext\n\nreturn                                 /*@ ZL_LOGMSG                 */\n/*\n.  ----------------------------------------------------------------- */\nHELP:                                  /*@                           */\naddress TSO;\"CLEAR\"\nif helpmsg <> \"\" then do ; say helpmsg; say \"\"; end\nex_nam = Left(exec_name,8)             /* predictable size           */\n\nsay \"  \"ex_nam\"      parses and summarizes the output of an IDCAMS LISTCAT  \"\nsay \"                operation.                                             \"\nsay \"                                                                       \"\nsay \"  Syntax:   \"ex_nam\"  <dsname>                                         \"\nsay \"                      <OUTPUT odsn>                                    \"\nsay \"                      <STACK>                                          \"\nsay \"                                                                       \"\nsay \"            dsname    identifies the component for which a LISTCAT is  \"\nsay \"                      to be done.                                      \"\nsay \"                                                                       \"\nsay \"            odsn      identifies the output dataset where the stack is \"\nsay \"                      to be written.                                   \"\nsay \"                                                                       \"\nsay \"            STACK     places the parsed, summarized output on the queue\"\nsay \"                      for use by a caller-routine.                     \"\nsay \"                                                                       \"\nsay \"                                                      more....         \"\n\"NEWSTACK\"; pull ; \"CLEAR\" ; \"DELSTACK\"\nsay \"  Material placed on the stack is prefixed by its key and a colon (:)     \"\nsay \"  followed by the value string.  The following keys are delivered to the  \"\nsay \"  stack if populated:                                                     \"\nsay \"                                                                          \"\nsay \"  NONVSAMINCAT            ALIASINCAT            GDGBASEINCAT              \"\nsay \"  NONVSAMHISTORY          ALIASHISTORY          GDGBASEHISTORY            \"\nsay \"  NONVSAMASSOCIATIONS     ALIASASSOCIATIONS     GDGBASEASSOCIATIONS       \"\nsay \"  NONVSAMATTRIBUTES                             GDGBASEATTRIBUTES         \"\nsay \"  NONVSAMSMSDATA                                                          \"\nsay \"  NONVSAMVOLUMES                                                          \"\nsay \"                                                                          \"\nsay \"  CLUSTERINCAT            DATAINCAT             INDEXINCAT                \"\nsay \"  CLUSTERHISTORY          DATAHISTORY           INDEXHISTORY              \"\nsay \"  CLUSTERASSOCIATIONS     DATAASSOCIATIONS      INDEXASSOCIATIONS         \"\nsay \"  CLUSTERSMSDATA                                                          \"\nsay \"  CLUSTERRLSDATA                                                          \"\nsay \"                          DATAATTRIBUTES        INDEXATTRIBUTES           \"\nsay \"                          DATASTATISTICS        INDEXSTATISTICS           \"\nsay \"                          DATAALLOCATION        INDEXALLOCATION           \"\nsay \"                          DATAVOLUME            INDEXVOLUME               \"\nsay \"  SUMMARY                                                                 \"\n\"NEWSTACK\"; pull ; \"CLEAR\" ; \"DELSTACK\"\nsay \"   Debugging tools provided include:                                   \"\nsay \"                                                                       \"\nsay \"        MONITOR:  displays key information throughout processing.      \"\nsay \"                                                                       \"\nsay \"        BRANCH:   show all paragraph entries.                          \"\nsay \"                                                                       \"\nsay \"        TRACE tv: will use value following TRACE to place the          \"\nsay \"                  execution in REXX TRACE Mode.                        \"\nsay \"                                                                       \"\nsay \"                                                                       \"\nsay \"   Debugging tools can be accessed in the following manner:            \"\nsay \"                                                                       \"\nsay \"        TSO \"ex_nam\"  parameters     ((  debug-options                 \"\nsay \"                                                                       \"\nsay \"   For example:                                                        \"\nsay \"                                                                       \"\nsay \"        TSO \"ex_nam\"  (( MONITOR TRACE ?R                              \"\n\naddress ISPEXEC \"CONTROL DISPLAY REFRESH\"\nexit                                   /*@ HELP                      */\n/*             REXXSKEL back-end removed for space                  */\n.  ----------------------------------------------------------------- */\nBRANCH: Procedure expose,              /*@                           */\n        sigl exec_name\n   rc = trace(\"O\")                     /* we do not want to see this */\n   arg brparm .\n\n   origin = sigl                       /* where was I called from ?  */\n   do currln = origin to 1 by -1       /* inch backward to label     */\n      if Right(Word(Sourceline(currln),1),1) = \":\" then do\n         parse value sourceline(currln) with pgfname \":\" .  /* Label */\n         leave ; end                   /*                name        */\n   end                                 /* currln                     */\n\n   select\n      when brparm = \"NAME\" then return(pgfname) /* Return full name  */\n      when brparm = \"ID\"      then do           /* wants the prefix  */\n         parse var pgfname pgfpref \"_\" .        /* get the prefix    */\n         return(pgfpref)\n         end                           /* brparm = \"ID\"              */\n      otherwise\n         say left(sigl,6) left(pgfname,40) exec_name \"Time:\" time(\"L\")\n   end                                 /* select                     */\n\nreturn                                 /*@ BRANCH                    */\n/*\n.  ----------------------------------------------------------------- */\nDUMP_QUEUE:                            /*@ Take whatever is in stack */\n   rc = trace(\"O\")                     /*  and write to the screen   */\n   address TSO\n\n   \"QSTACK\"                            /* how many stacks?           */\n   stk2dump    = rc - tk_init_stacks   /* remaining stacks           */\n   if stk2dump = 0 & queued() = 0 then return\n   say \"Total Stacks\" rc ,             /* rc = #of stacks            */\n    \"   Begin Stacks\" tk_init_stacks , /* Stacks present at start    */\n    \"   Excess Stacks to dump\" stk2dump\n\n   do dd = rc to tk_init_stacks by -1  /* empty each one.            */\n      say \"Processing Stack #\" dd \"   Total Lines:\" queued()\n      do queued();pull line;say line;end /* pump to the screen       */\n      \"DELSTACK\"                       /* remove stack               */\n   end                                 /* dd = 1 to rc               */\n\nreturn                                 /*@ DUMP_QUEUE                */\n/* Handle CLIST-form keywords             added 20020513\n.  ----------------------------------------------------------------- */\nCLKWD: Procedure expose info           /*@ hide all except info      */\n   arg kw\n   kw = kw\"(\"                          /* form is 'KEY(DATA)'        */\n   kw_pos = Pos(kw,info)               /* find where it is, maybe    */\n   if kw_pos = 0 then return \"\"        /* send back a null, not found*/\n   rtpt   = Pos(\") \",info\" \",kw_pos)   /* locate end-paren           */\n   slug   = Substr(info,kw_pos,rtpt-kw_pos+1)     /* isolate         */\n   info   = Delstr(info,kw_pos,rtpt-kw_pos+1)     /* excise          */\n   parse var slug (kw)     slug        /* drop kw                    */\n   slug   = Reverse(Substr(Reverse(Strip(slug)),2))\nreturn slug                            /*@CLKWD                      */\n/* Handle multi-word keys 20020513\n.  ----------------------------------------------------------------- */\nKEYWD: Procedure expose info           /*@ hide all vars, except info*/\n   arg kw\n   kw_pos = wordpos(kw,info)           /* find where it is, maybe    */\n   if kw_pos = 0 then return \"\"        /* send back a null, not found*/\n   kw_val = word(info,kw_pos+Words(kw))/* get the next word          */\n   info   = Delword(info,kw_pos,2)     /* remove both                */\nreturn kw_val                          /*@ KEYWD                     */\n/*\n.  ----------------------------------------------------------------- */\nKEYPHRS: Procedure expose,             /*@                           */\n         info helpmsg exec_name        /*  except these three        */\n   arg kp\n   wp    = wordpos(kp,info)            /* where is it?               */\n   if wp = 0 then return \"\"            /* not found                  */\n   front = subword(info,1,wp-1)        /* everything before kp       */\n   back  = subword(info,wp+1)          /* everything after kp        */\n   parse var back dlm back             /* 1st token must be 2 bytes  */\n   if length(dlm) <> 2 then            /* Must be two bytes          */\n      helpmsg = helpmsg \"Invalid length for delimiter(\"dlm\") with KEYPHRS(\"kp\")\"\n   if wordpos(dlm,back) = 0 then       /* search for ending delimiter*/\n      helpmsg = helpmsg \"No matching second delimiter(\"dlm\") with KEYPHRS(\"kp\")\"\n   if helpmsg <> \"\" then call HELP     /* Something is wrong         */\n   parse var back kpval (dlm) back     /* get everything b/w delim   */\n   info =  front back                  /* restore remainder          */\nreturn Strip(kpval)                    /*@ KEYPHRS                   */\n/*\n.  ----------------------------------------------------------------- */\nNOVALUE:                               /*@                           */\n   say exec_name \"raised NOVALUE at line\" sigl\n   say \" \"\n   say \"The referenced variable is\" condition(\"D\")\n   say \" \"\n   zsigl = sigl\n   signal SHOW_SOURCE                  /*@ NOVALUE                   */\n/*\n.  ----------------------------------------------------------------- */\nSHOW_SOURCE:                           /*@                           */\n   call DUMP_QUEUE                     /* Spill contents of stacks  -*/\n   if sourceline() <> \"0\" then         /* to screen                  */\n      say sourceline(zsigl)\n   rc =  trace(\"?R\")\n   nop\n   exit                                /*@ SHOW_SOURCE               */\n/*\n.  ----------------------------------------------------------------- */\nSS: Procedure                          /*@ Show Source               */\n   arg  ssbeg  ssend  .\n   if ssend = \"\" then ssend = 10\n   if \\datatype(ssbeg,\"W\") | \\datatype(ssend,\"W\") then return\n   ssend = ssbeg + ssend\n   do ssii = ssbeg to ssend ; say Strip(sourceline(ssii),'T') ; end\nreturn                                 /*@ SS                        */\n/*\n.  ----------------------------------------------------------------- */\nSWITCH: Procedure expose info          /*@                           */\n   arg kw\n   sw_val = Wordpos(kw,info) > 0       /* exists = 1; not found = 0  */\n   if sw_val then                      /* exists                     */\n      info = Delword(info,Wordpos(kw,info),1) /* remove it           */\nreturn sw_val                          /*@ SWITCH                    */\n/*\n.  ----------------------------------------------------------------- */\nSYNTAX:                                /*@                           */\n   errormsg = exec_name \"encountered REXX error\" rc \"in line\" sigl\":\",\n                        errortext(rc)\n   say errormsg\n   zsigl = sigl\n   signal SHOW_SOURCE                  /*@ SYNTAX                    */\n/*\n   Can call TRAPOUT.\n.  ----------------------------------------------------------------- */\nTOOLKIT_INIT:                          /*@                           */\n   address TSO\n   info = Strip(opts,\"T\",\")\")          /* clip trailing paren        */\n\n   parse source  sys_id  how_invokt  exec_name  DD_nm  DS_nm,\n                     as_invokt  cmd_env  addr_spc  usr_tokn\n\n   parse value \"\" with  tv  helpmsg  .\n   parse value 0   \"ISR00000  YES\"     \"Error-Press PF1\"    with,\n               sw.  zerrhm    zerralrm  zerrsm\n\n   if SWITCH(\"TRAPOUT\") then do\n      \"TRAPOUT\" exec_name parms \"(( TRACE R\" info\n      exit\n      end                              /* trapout                    */\n\n   if Word(parms,1) = \"?\" then call HELP /* I won't be back          */\n\n   \"QSTACK\" ; tk_init_stacks = rc      /* How many stacks?           */\n\n   parse value SWITCH(\"BRANCH\") SWITCH(\"MONITOR\") SWITCH(\"NOUPDT\") with,\n               branch           monitor           noupdt    .\n\n   parse value mvsvar(\"SYSNAME\") sysvar(\"SYSNODE\") with,\n               #tk_cpu           node          .\n\n   sw.nested    = sysvar(\"SYSNEST\") = \"YES\"\n   sw.batch     = sysvar(\"SYSENV\")  = \"BACK\"\n   sw.inispf    = sysvar(\"SYSISPF\") = \"ACTIVE\"\n\n   parse value KEYWD(\"TRACE\")  \"O\"    with   tv  .\n   tk_globalvars = \"exec_name  tv  helpmsg  sw.  zerrhm  zerralrm \",\n                   \"zerrsm  zerrlm  tk_init_stacks  branch  monitor \",\n                   \"noupdt\"\n\n   call LOCAL_PREINIT                  /* for more opts             -*/\n\nreturn                                 /*@ TOOLKIT_INIT              */\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTCSUO": {"ttr": 774, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x11\\x01\\x064_\\x01\\x16\\x11\\x7f\\x136\\x01\\xf8\\x01O\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2006-12-11T00:00:00", "modifydate": "2016-04-26T13:36:11", "lines": 504, "newlines": 335, "modlines": 0, "user": "REXX"}, "text": "/* REXX    LISTCSUM   Parse and isolate LISTCAT output to discrete,     */\n/*                    identifiable packets.\n\n           Written by Frank Clarke 20020318\n\n     Impact Analysis\n.    SYSPROC   TRAPOUT\n\n     Modification History\n     20020423 fxc enable OUTPUT; if CLUSTERASSOCIATIONS is empty,\n                  get clustername from DATAASSOCIATIONS or\n                  INDEXASSOCIATIONS and restart the command;\n     20020507 fxc no hyphens in keys\n     20020722 fxc leave queue intact if STACK\n     20030331 fxc GDGBASE implies NONVSAM and SUMMARY\n\n*/ arg argline\naddress TSO                            /* REXXSKEL ver.20010802      */\narg parms \"((\" opts\n\nsignal on syntax\nsignal on novalue\n\ncall TOOLKIT_INIT                      /* conventional start-up     -*/\nrc     = trace(tv)\ninfo   = parms                         /* to enable parsing          */\n\ncall A_INIT                            /*                           -*/\n                                    if sw.0error_found then return\ncall B_LISTC                           /*                           -*/\ncall C_PARSE                           /*                           -*/\ncall D_REPORT                          /*                           -*/\n\nif sw.0STACK then return               /* leave the queue intact     */\nif \\sw.nested then call DUMP_QUEUE     /*                           -*/\nexit                                   /*@ LISTCSUM                  */\n/*\n.  ----------------------------------------------------------------- */\nA_INIT:                                /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   call AA_SETUP_LOG                   /*                           -*/\n   call AB_KEYWDS                      /*                           -*/\n\n   major_keys = \"ALIAS NONVSAM CLUSTER DATA INDEX SUMM\"\n   minor_keys. = \"\"\n   minor_keys.alias   = \"INCAT HISTORY ASSOCIATIONS\"\n   minor_keys.nonvsam = \"INCAT HISTORY SMSDATA VOLUMES\",\n                        \"ASSOCIATIONS ATTRIBUTES\"\n   minor_keys.gdgbase = \"INCAT HISTORY ASSOCIATIONS ATTRIBUTES\"\n   minor_keys.cluster = \"INCAT HISTORY SMSDATA RLSDATA ASSOCIATIONS\"\n   minor_keys.data    = \"INCAT HISTORY ASSOCIATIONS ATTRIBUTES\",\n                        \"STATISTICS ALLOCATION VOLUME\"\n   minor_keys.index   = \"INCAT HISTORY ASSOCIATIONS ATTRIBUTES\",\n                        \"STATISTICS ALLOCATION VOLUME\"\n   minor_keys.SUMM    = \"ARY\"\n   parse value \"\" with ,\n               valuestr.  .\n\nreturn                                 /*@ A_INIT                    */\n/*\n.  ----------------------------------------------------------------- */\nAA_SETUP_LOG:                          /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   parse value \"0\" with,\n               log#    log.\n   parse value Date(\"S\")  Time(\"S\")  Time(\"N\")  with,\n               yyyymmdd   sssss      hhmmss  .\n   parse var yyyymmdd  4 yrdigit 5 mm 7 dd          /* 9 12 14 maybe */\n   if Pos(yrdigit,\"13579\") > 0 then mm = mm + 12       /* mm=24      */\n   logtag = Substr(\"ABCDEFGHIJKLMNOPQRSTUVWX\",mm,1)    /* logtag=X   */\n   subid  = logtag\"\"dd\"\"Right(sssss,5,0)               /* X1423722 ? */\n   vb4k.0    = \"NEW CATALOG UNIT(SYSDA) SPACE(1 5) TRACKS\",\n               \"RECFM(V B) LRECL(4096) BLKSIZE(0)\"\n   vb4k.1    = \"SHR\"                   /* if it already exists...    */\n   logdsn = \"@@LOG.\"exec_name\".\"subid\".#CILIST\"\n\n   call ZL_LOGMSG(exec_name \"started by\" Userid()  yyyymmdd  hhmmss)\n   call ZL_LOGMSG(\"Arg:\" argline)\n\nreturn                                 /*@ AA_SETUP_LOG              */\n/*\n.  ----------------------------------------------------------------- */\nAB_KEYWDS:                             /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   sw.0stack = SWITCH(\"STACK\")         /* return results to stack    */\n\n   outdsn    = KEYWD(\"OUTPUT\")         /* save output on DASD        */\n   if outdsn <> \"\" then do\n      sw.0stack = 1                    /* force stack                */\n\n      alloc.0 = \"NEW CATALOG UNIT(SYSDA) SPACE(5 5) TRACKS\",\n                  \"RECFM(V B) LRECL(4096) BLKSIZE(0)\"\n      alloc.1 = \"SHR\"                  /* if it already exists...    */\n      tempstat = Pos(Sysdsn(outdsn),\"OK MEMBER NOT FOUND\") > 0\n      \"ALLOC FI($TMP) DA(\"outdsn\") REU\" alloc.tempstat\n      if rc > 0 then do\n         sw.0error_found = 1\n         return\n         end\n      end                              /* outdsn                     */\n\n   parse var info   vsds  info\n   if vsds = \"\" then do\n      say \"DSName required\"\n      exit\n      end\n\nreturn                                 /*@ AB_KEYWDS                 */\n/*\n.  ----------------------------------------------------------------- */\nB_LISTC:                               /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   \"ALLOC FI(SYSPRINT) UNIT(VIO)  NEW REU SPACE(1) TRACKS\",\n            \"RECFM(V B A) LRECL(121) BLKSIZE(0)\"\n   \"ALLOC FI(SYSIN)    UNIT(VIO)  NEW REU SPACE(1) TRACKS\",\n            \"RECFM(F B) LRECL(80) BLKSIZE(0)\"\n   \"NEWSTACK\"\n   queue \"  LISTCAT ENTRIES(\"vsds\") +\"\n   queue \"          ALL\"\n   \"EXECIO\" queued() \"DISKW SYSIN (FINIS\"\n   \"DELSTACK\"\n\n   address LINKMVS \"IDCAMS\"\n\nreturn                                 /*@ B_LISTC                   */\n/*\n.  ----------------------------------------------------------------- */\nC_PARSE:                               /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   \"NEWSTACK\"\n   \"EXECIO * DISKR SYSPRINT (FINIS\"    /* load the queue             */\n   do queued()\n      parse pull 2 w1 rest\n      if w1 = \"\" then iterate\n      if WordPos(w1,\"IDCAMS LISTCAT\") > 0 then iterate\n      if w1 = \"IN-CAT\" then w1 = \"INCAT\"\n      select\n         when WordPos(w1,\"THE\") > 0 then leave\n         when WordPos(w1,\"GDG\") > 0 then do\n            /* special case: major name is two words                 */\n            parse var rest w2 rest\n            if w2 = \"BASE\" then,\n               parse value \"GDGBASE NONVSAM SUMM\" with ,\n                            major_keys 1 w1 .\n            major = w1\n            rest  = Translate(rest,\" \",\"-\")\n            valuestr.major = Space(rest,1)        /* strip           */\n            end                        /* GDG BASE                   */\n         when WordPos(w1,major_keys) > 0 then do\n            major = w1\n            rest  = Translate(rest,\" \",\"-\")\n            valuestr.major = Space(rest,1)        /* strip           */\n            end                        /* major                      */\n         when WordPos(w1,minor_keys.major) > 0 then do\n            minor = w1\n            key   = Space(major minor,0)\n            data  = Translate(rest,\" \",\"-\")\n            valuestr.key = Space(data,1)     /* strip                */\n            end                        /* minor                      */\n         otherwise do\n            data  = Translate(w1 rest,\" \",\"-\")\n            valuestr.key = valuestr.key Space(data,1)     /* strip   */\n            end                        /* value line                 */\n      end                              /* select                     */\n   end                                 /* queued                     */\n\n   info = valuestr.DATAASSOCIATIONS valuestr.INDEXASSOCIATIONS\n   if valuestr.CLUSTERASSOCIATIONS = \"\" then,\n      if info <> \"\" then do            /* re-do the command          */\n         \"DELSTACK\"                    /* stack before CALL          */\n         clustername = KEYWD(\"CLUSTER\")\n         (exec_name) clustername argline\n         exit                          /* bail out                   */\n         end\n\n   major = \"SUMM\"                      /* This is kinda hokey...     */\n   key   = \"SUMMARY\"\n   do queued()                         /* gross stats                */\n      parse pull 2 w1 rest\n      if w1 = \"\" then iterate\n      select\n         when WordPos(w1,\"THE\") > 0 then leave\n         otherwise do\n            data  = Translate(w1 rest,\" \",\"-\")\n            valuestr.key = valuestr.key Space(data,1)     /* strip   */\n            end                        /* value line                 */\n      end                              /* select                     */\n   end                                 /* queued                     */\n   \"DELSTACK\"\n\nreturn                                 /*@ C_PARSE                   */\n/*\n.  ----------------------------------------------------------------- */\nD_REPORT:                              /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   \"CLEAR\"\n   if outdsn <> \"\" then \"NEWSTACK\"     /* isolate the queue          */\n   do Words(major_keys)                /* each major key             */\n      parse var major_keys major major_keys\n      do Words(minor_keys.major)       /* each minor key             */\n         parse var minor_keys.major minor minor_keys.major\n         key = Space(major minor,0)\n         if valuestr.key = \"\" then iterate\n         if sw.0stack then,\n            queue key\":\" valuestr.key\n         else do\n            say key\n            say \"     \"valuestr.key\n            end\n      end                              /* minor                      */\n   end                                 /* major                      */\n\n   if outdsn <> \"\" then do\n      \"EXECIO\" queued() \"DISKW $TMP (FINIS\"\n      \"FREE  FI($TMP)\"\n      \"DELSTACK\"\n      end\n\nreturn                                 /*@ D_REPORT                  */\n/*\n.  ----------------------------------------------------------------- */\nLOCAL_PREINIT:                         /*@ customize opts            */\n   address TSO\n\n\nreturn                                 /*@ LOCAL_PREINIT             */\n/*   subroutines below LOCAL_PREINIT are not selected by SHOWFLOW    */\n/*\n.  ----------------------------------------------------------------- */\nZB_SAVELOG:                            /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   if Symbol(\"LOG#\") = \"LIT\" then return          /* not yet set     */\n\n   \"ALLOC FI($LOG) DA(\"logdsn\") REU\" vb4k.0\n   \"EXECIO\" log# \"DISKW $LOG (STEM LOG. FINIS\"\n   \"FREE  FI($LOG)\"\n\nreturn                                 /*@ ZB_SAVELOG                */\n/*\n.  ----------------------------------------------------------------- */\nZL_LOGMSG: Procedure expose,           /*@                           */\n   (tk_globalvars)  log. log#\n   rc = Trace(\"O\")\n   address TSO\n\n   parse arg msgtext\n   parse value  log#+1  msgtext     with,\n                zz      log.zz    1  log#   .\n\n   if monitor then say,\n      msgtext\n\nreturn                                 /*@ ZL_LOGMSG                 */\n/*\n.  ----------------------------------------------------------------- */\nHELP:                                  /*@                           */\naddress TSO;\"CLEAR\"\nif helpmsg <> \"\" then do ; say helpmsg; say \"\"; end\nex_nam = Left(exec_name,8)             /* predictable size           */\n\nsay \"  \"ex_nam\"      parses and summarizes the output of an IDCAMS LISTCAT  \"\nsay \"                operation.                                             \"\nsay \"                                                                       \"\nsay \"  Syntax:   \"ex_nam\"  <dsname>                                         \"\nsay \"                      <OUTPUT odsn>                                    \"\nsay \"                      <STACK>                                          \"\nsay \"                                                                       \"\nsay \"            dsname    identifies the component for which a LISTCAT is  \"\nsay \"                      to be done.                                      \"\nsay \"                                                                       \"\nsay \"            odsn      identifies the output dataset where the stack is \"\nsay \"                      to be written.                                   \"\nsay \"                                                                       \"\nsay \"            STACK     places the parsed, summarized output on the queue\"\nsay \"                      for use by a caller-routine.                     \"\nsay \"                                                                       \"\nsay \"                                                      more....         \"\n\"NEWSTACK\"; pull ; \"CLEAR\" ; \"DELSTACK\"\nsay \"  Material placed on the stack is prefixed by its key and a colon (:)     \"\nsay \"  followed by the value string.  The following keys are delivered to the  \"\nsay \"  stack if populated:                                                     \"\nsay \"                                                                          \"\nsay \"  NONVSAMINCAT            ALIASINCAT            GDGBASEINCAT              \"\nsay \"  NONVSAMHISTORY          ALIASHISTORY          GDGBASEHISTORY            \"\nsay \"  NONVSAMASSOCIATIONS     ALIASASSOCIATIONS     GDGBASEASSOCIATIONS       \"\nsay \"  NONVSAMATTRIBUTES                             GDGBASEATTRIBUTES         \"\nsay \"  NONVSAMSMSDATA                                                          \"\nsay \"  NONVSAMVOLUMES                                                          \"\nsay \"                                                                          \"\nsay \"  CLUSTERINCAT            DATAINCAT             INDEXINCAT                \"\nsay \"  CLUSTERHISTORY          DATAHISTORY           INDEXHISTORY              \"\nsay \"  CLUSTERASSOCIATIONS     DATAASSOCIATIONS      INDEXASSOCIATIONS         \"\nsay \"  CLUSTERSMSDATA                                                          \"\nsay \"  CLUSTERRLSDATA                                                          \"\nsay \"                          DATAATTRIBUTES        INDEXATTRIBUTES           \"\nsay \"                          DATASTATISTICS        INDEXSTATISTICS           \"\nsay \"                          DATAALLOCATION        INDEXALLOCATION           \"\nsay \"                          DATAVOLUME            INDEXVOLUME               \"\nsay \"  SUMMARY                                                                 \"\n\"NEWSTACK\"; pull ; \"CLEAR\" ; \"DELSTACK\"\nsay \"   Debugging tools provided include:                                   \"\nsay \"                                                                       \"\nsay \"        MONITOR:  displays key information throughout processing.      \"\nsay \"                                                                       \"\nsay \"        BRANCH:   show all paragraph entries.                          \"\nsay \"                                                                       \"\nsay \"        TRACE tv: will use value following TRACE to place the          \"\nsay \"                  execution in REXX TRACE Mode.                        \"\nsay \"                                                                       \"\nsay \"                                                                       \"\nsay \"   Debugging tools can be accessed in the following manner:            \"\nsay \"                                                                       \"\nsay \"        TSO \"ex_nam\"  parameters     ((  debug-options                 \"\nsay \"                                                                       \"\nsay \"   For example:                                                        \"\nsay \"                                                                       \"\nsay \"        TSO \"ex_nam\"  (( MONITOR TRACE ?R                              \"\n\naddress ISPEXEC \"CONTROL DISPLAY REFRESH\"\nexit                                   /*@ HELP                      */\n/*             REXXSKEL back-end removed for space                  */\n.  ----------------------------------------------------------------- */\nBRANCH: Procedure expose,              /*@                           */\n        sigl exec_name\n   rc = trace(\"O\")                     /* we do not want to see this */\n   arg brparm .\n\n   origin = sigl                       /* where was I called from ?  */\n   do currln = origin to 1 by -1       /* inch backward to label     */\n      if Right(Word(Sourceline(currln),1),1) = \":\" then do\n         parse value sourceline(currln) with pgfname \":\" .  /* Label */\n         leave ; end                   /*                name        */\n   end                                 /* currln                     */\n\n   select\n      when brparm = \"NAME\" then return(pgfname) /* Return full name  */\n      when brparm = \"ID\"      then do           /* wants the prefix  */\n         parse var pgfname pgfpref \"_\" .        /* get the prefix    */\n         return(pgfpref)\n         end                           /* brparm = \"ID\"              */\n      otherwise\n         say left(sigl,6) left(pgfname,40) exec_name \"Time:\" time(\"L\")\n   end                                 /* select                     */\n\nreturn                                 /*@ BRANCH                    */\n/*\n.  ----------------------------------------------------------------- */\nDUMP_QUEUE:                            /*@ Take whatever is in stack */\n   rc = trace(\"O\")                     /*  and write to the screen   */\n   address TSO\n\n   \"QSTACK\"                            /* how many stacks?           */\n   stk2dump    = rc - tk_init_stacks   /* remaining stacks           */\n   if stk2dump = 0 & queued() = 0 then return\n   say \"Total Stacks\" rc ,             /* rc = #of stacks            */\n    \"   Begin Stacks\" tk_init_stacks , /* Stacks present at start    */\n    \"   Excess Stacks to dump\" stk2dump\n\n   do dd = rc to tk_init_stacks by -1  /* empty each one.            */\n      say \"Processing Stack #\" dd \"   Total Lines:\" queued()\n      do queued();pull line;say line;end /* pump to the screen       */\n      \"DELSTACK\"                       /* remove stack               */\n   end                                 /* dd = 1 to rc               */\n\nreturn                                 /*@ DUMP_QUEUE                */\n/* Handle CLIST-form keywords             added 20020513\n.  ----------------------------------------------------------------- */\nCLKWD: Procedure expose info           /*@ hide all except info      */\n   arg kw\n   kw = kw\"(\"                          /* form is 'KEY(DATA)'        */\n   kw_pos = Pos(kw,info)               /* find where it is, maybe    */\n   if kw_pos = 0 then return \"\"        /* send back a null, not found*/\n   rtpt   = Pos(\") \",info\" \",kw_pos)   /* locate end-paren           */\n   slug   = Substr(info,kw_pos,rtpt-kw_pos+1)     /* isolate         */\n   info   = Delstr(info,kw_pos,rtpt-kw_pos+1)     /* excise          */\n   parse var slug (kw)     slug        /* drop kw                    */\n   slug   = Reverse(Substr(Reverse(Strip(slug)),2))\nreturn slug                            /*@CLKWD                      */\n/* Handle multi-word keys 20020513\n.  ----------------------------------------------------------------- */\nKEYWD: Procedure expose info           /*@ hide all vars, except info*/\n   arg kw\n   kw_pos = wordpos(kw,info)           /* find where it is, maybe    */\n   if kw_pos = 0 then return \"\"        /* send back a null, not found*/\n   kw_val = word(info,kw_pos+Words(kw))/* get the next word          */\n   info   = Delword(info,kw_pos,2)     /* remove both                */\nreturn kw_val                          /*@ KEYWD                     */\n/*\n.  ----------------------------------------------------------------- */\nKEYPHRS: Procedure expose,             /*@                           */\n         info helpmsg exec_name        /*  except these three        */\n   arg kp\n   wp    = wordpos(kp,info)            /* where is it?               */\n   if wp = 0 then return \"\"            /* not found                  */\n   front = subword(info,1,wp-1)        /* everything before kp       */\n   back  = subword(info,wp+1)          /* everything after kp        */\n   parse var back dlm back             /* 1st token must be 2 bytes  */\n   if length(dlm) <> 2 then            /* Must be two bytes          */\n      helpmsg = helpmsg \"Invalid length for delimiter(\"dlm\") with KEYPHRS(\"kp\")\"\n   if wordpos(dlm,back) = 0 then       /* search for ending delimiter*/\n      helpmsg = helpmsg \"No matching second delimiter(\"dlm\") with KEYPHRS(\"kp\")\"\n   if helpmsg <> \"\" then call HELP     /* Something is wrong         */\n   parse var back kpval (dlm) back     /* get everything b/w delim   */\n   info =  front back                  /* restore remainder          */\nreturn Strip(kpval)                    /*@ KEYPHRS                   */\n/*\n.  ----------------------------------------------------------------- */\nNOVALUE:                               /*@                           */\n   say exec_name \"raised NOVALUE at line\" sigl\n   say \" \"\n   say \"The referenced variable is\" condition(\"D\")\n   say \" \"\n   zsigl = sigl\n   signal SHOW_SOURCE                  /*@ NOVALUE                   */\n/*\n.  ----------------------------------------------------------------- */\nSHOW_SOURCE:                           /*@                           */\n   call DUMP_QUEUE                     /* Spill contents of stacks  -*/\n   if sourceline() <> \"0\" then         /* to screen                  */\n      say sourceline(zsigl)\n   rc =  trace(\"?R\")\n   nop\n   exit                                /*@ SHOW_SOURCE               */\n/*\n.  ----------------------------------------------------------------- */\nSS: Procedure                          /*@ Show Source               */\n   arg  ssbeg  ssend  .\n   if ssend = \"\" then ssend = 10\n   if \\datatype(ssbeg,\"W\") | \\datatype(ssend,\"W\") then return\n   ssend = ssbeg + ssend\n   do ssii = ssbeg to ssend ; say Strip(sourceline(ssii),'T') ; end\nreturn                                 /*@ SS                        */\n/*\n.  ----------------------------------------------------------------- */\nSWITCH: Procedure expose info          /*@                           */\n   arg kw\n   sw_val = Wordpos(kw,info) > 0       /* exists = 1; not found = 0  */\n   if sw_val then                      /* exists                     */\n      info = Delword(info,Wordpos(kw,info),1) /* remove it           */\nreturn sw_val                          /*@ SWITCH                    */\n/*\n.  ----------------------------------------------------------------- */\nSYNTAX:                                /*@                           */\n   errormsg = exec_name \"encountered REXX error\" rc \"in line\" sigl\":\",\n                        errortext(rc)\n   say errormsg\n   zsigl = sigl\n   signal SHOW_SOURCE                  /*@ SYNTAX                    */\n/*\n   Can call TRAPOUT.\n.  ----------------------------------------------------------------- */\nTOOLKIT_INIT:                          /*@                           */\n   address TSO\n   info = Strip(opts,\"T\",\")\")          /* clip trailing paren        */\n\n   parse source  sys_id  how_invokt  exec_name  DD_nm  DS_nm,\n                     as_invokt  cmd_env  addr_spc  usr_tokn\n\n   parse value \"\" with  tv  helpmsg  .\n   parse value 0   \"ISR00000  YES\"     \"Error-Press PF1\"    with,\n               sw.  zerrhm    zerralrm  zerrsm\n\n   if SWITCH(\"TRAPOUT\") then do\n      \"TRAPOUT\" exec_name parms \"(( TRACE R\" info\n      exit\n      end                              /* trapout                    */\n\n   if Word(parms,1) = \"?\" then call HELP /* I won't be back          */\n\n   \"QSTACK\" ; tk_init_stacks = rc      /* How many stacks?           */\n\n   parse value SWITCH(\"BRANCH\") SWITCH(\"MONITOR\") SWITCH(\"NOUPDT\") with,\n               branch           monitor           noupdt    .\n\n   parse value mvsvar(\"SYSNAME\") sysvar(\"SYSNODE\") with,\n               #tk_cpu           node          .\n\n   sw.nested    = sysvar(\"SYSNEST\") = \"YES\"\n   sw.batch     = sysvar(\"SYSENV\")  = \"BACK\"\n   sw.inispf    = sysvar(\"SYSISPF\") = \"ACTIVE\"\n\n   parse value KEYWD(\"TRACE\")  \"O\"    with   tv  .\n   tk_globalvars = \"exec_name  tv  helpmsg  sw.  zerrhm  zerralrm \",\n                   \"zerrsm  zerrlm  tk_init_stacks  branch  monitor \",\n                   \"noupdt\"\n\n   call LOCAL_PREINIT                  /* for more opts             -*/\n\nreturn                                 /*@ TOOLKIT_INIT              */\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXDATE": {"ttr": 1029, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x10\\x00I\\x00\\x97(\\x9f\\x01\\x16\\x11\\x7f\\x132\\x03\\xb9\\x03\\xb1\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.16", "flags": 0, "createdate": "1997-10-16T00:00:00", "modifydate": "2016-04-26T13:32:49", "lines": 953, "newlines": 945, "modlines": 0, "user": "REXX"}, "text": "/*% NOCOMMENT REXX     */\n/*\n  RXDATE -- provides enhancements to all options of the DATE() function\n  provided by REXX, and also provides 9 additional options.\n\n  Source:   Bruce Sacco (dc.sysf80@ts3.teale.ca.gov)\n            via the TSO REXX Discussion List\n\n  Author:   Steve Rushing of the Health and Welfare Data\n            Center, State of Calif.\n\n  Mods:     John Kalinich (jkalinic@csc.com) Year 2000 (Oct 1997)\n\nThe format of the RXDATE function is:\n\n  +--------------------------------------------------------------+\n    RXDATE((option,parm1,parm2))\n  +--------------------------------------------------------------+\n\nOptions:\n\n  NULL option i.e. RXDATE() or RXDATE(,parm1) converts the date\n     supplied in parm1 to the format 'dd Mmm yyyy', and returns it\n     as the value of the function.\n\n     parm1 = a Date in the format mm/dd/yy or mm/dd/yyyy\n     parm2 = not used\n\n     e.g.  RXDATE(,'10/06/85')   returns ===> 06 Oct 1985\n           RXDATE(,'10/06/2000') returns ===> 06 Oct 2000\n\n  C  (Century); returns as the function value, the number of day into\n     the century the date represents. The returned value is of the form\n     ddddd with no leading zeroes.\n\n     parm1 = null (current date) or mm/dd/yy or mm/dd/yyyy\n     parm2 = not used\n\n     e.g.  RXDATE(c,'01/10/85')   returns ===> 31056\n           RXDATE(c,'01/10/1800') returns ===> 10\n\n  D  (Days); returns as the function value, the number of days into the\n     year, the date represents.\n\n     parm1 = null (current date) or mm/dd/yy or mm/dd/yyyy\n     parm2 = not used\n\n     e.g.  RXDATE(d,'01/10/85')   returns ===> 10\n           RXDATE(d,'07/10/1800') returns ===> 191\n\n  E  (European); returns as the value of the function, dd/mm/yy if\n     the date supplied in parm1 is >= the 1900's, or dd/mm/yyyy if\n     the date supplied in parm1 is < the 1900's.\n\n     parm1 = null (current date) or mm/dd/yy or mm/dd/yyyy\n     parm2 = not used\n\n     e.g.  RXDATE(e,'01/23/85')   returns ===> 23/01/85\n           RXDATE(e,'01/23/1800') returns ===> 23/01/1800\n\n  J  (Julian-OS); returns as the value of the function, yyddd\n     representing the date supplied in parm1.\n\n     parm1 = null (current date) or mm/dd/yy or mm/dd/yyyy\n     parm2 = not used\n\n     e.g.  RXDATE(j,'07/23/85')   returns ===> 85204\n           RXDATE(j,'07/23/1885') returns ===> 85204\n\n  M  (Month); returns as the value of the function, the full name of\n     the month, for the date supplied in parm1.\n\n     parm1 = null (current date) or mm/dd/yy or mm/dd/yyyy\n     parm2 = not used\n\n     e.g.  RXDATE(m,'01/23/85')   returns ===> January\n           RXDATE(m,'07/23/1885') returns ===> July\n\n  O  (Ordered); returns as the value of the function,  yy/mm/dd if the\n     date supplied in parm1 is >= the 1900's, or yyyy/mm/dd if the date\n     supplied in parm1 is < the 1900's.\n\n     parm1 = null (current date) or mm/dd/yy or mm/dd/yyyy\n     parm2 = not used\n\n     e.g.  RXDATE(o,'07/23/85')   returns ===> 85/07/23\n           RXDATE(o,'07/23/1885') returns ===> 1885/07/23\n\n  S  (Sorted); returns as the value of the function, yyyymmdd\n     representing the date supplied in parm1\n\n     parm1 = null (current date) or mm/dd/yy or mm/dd/yyyy\n     parm2 = not used\n\n     e.g.  RXDATE(s,'07/23/85')   returns ===> 19850723\n           RXDATE(s,'07/23/1885') returns ===> 18850723\n\n  U  (USA); returns as the value of the function,  mm/dd/yy if the\n     date supplied in parm1 is >= the 1900's, or mm/dd/yyyy if the date\n     supplied in parm1 is < the 1900's. If you just want the\n     current date, the built-in DATE() function is more efficient.\n\n     parm1 = null (current date) or mm/dd/yy or mm/dd/yyyy\n     parm2 = not used\n\n     e.g.  RXDATE(u,'07/23/85')   returns ===> 07/23/85\n           RXDATE(u,'07/23/1985') returns ===> 07/23/85\n           RXDATE(u,'07/23/1885') returns ===> 07/23/1885\n\n  W  (WEEKDAY) returns as the value of the function, the full name of\n     the day-of-the-week, for the date specified in parm1.\n\n     parm1 = null (current date) or mm/dd/yy or mm/dd/yyyy\n     parm2 = not used\n\n     e.g.  RXDATE(w,'01/01/2000') returns ===> Saturday\n           RXDATE(w,'07/04/1776') returns ===> Thursday\n\n  1  Converts TRUE Julian number to corresponding GREGORIAN date,\n     and returns the GREGORIAN date as the value of the function.\n\n     parm1 = null (TRUE julian number for current date) or\n             number in range 1721426-5373484 inclusive.\n                 1721426 = 01/01/0001\n                 5373484 = 12/31/9999\n     parm2 = not used\n\n     e.g.  RXDATE(1,2446270)   returns ===> 07/23/85\n           RXDATE(1,2455198)   returns ===> 01/01/2010\n\n  2  Converts GREGORIAN date to corresponding TRUE Julian number, and\n     returns the TRUE julian number as the value of the function.\n\n     parm1 = null (current date) or mm/dd/yy or mm/dd/yyyy\n     parm2 = not used\n\n     e.g.  RXDATE(2,'07/23/85')   returns ===> 2446270\n           RXDATE(2,'01/01/2010') returns ===> 2455198\n\n  3  Converts Julian-OS (yyddd) to TRUE Julian number, and returns the\n     TRUE julian number as the value of the function.\n\n     parm1 = null (Julian-OS for current date) or yyddd\n             yy assumed if >= 1900's\n     parm2 = not used\n\n     e.g.  RXDATE(3,85100)   returns ===> 2446166\n\n  4  Converts TRUE Julian number to Julian-OS, and returns the\n     Julian-OS as the value of the function.\n\n     parm1 = null (TRUE julian number for current date) or\n             number in range 1721426-5373120 inclusive.\n                 1721426 = 01/01/0001\n                 5373120 = 12/31/9999\n     parm2 = not used\n\n     e.g.  RXDATE(4,2446270)   returns ===> 85204    07/23/85\n           RXDATE(4,2455198)   returns ===> 10001    01/01/2010\n\n     *** note -- Obviously this makes sense only for the 1900's.\n\n  5  Converts Julian-OS to GREGORIAN date, and returns the GREGORIAN\n     date as the value of the function.\n\n     parm1 = null (Julian-OS for current date) or yyddd\n             yy assumed if >= 1900's\n     parm2 = not used\n\n     e.g.  RXDATE(5,85205)   returns ===>  07/24/85\n\n  6  Returns the date xx days hence or before.  Base date supplied in\n     parm1, number of days hence (+ or -) supplied in parm2.\n\n     parm1 = null (current date) or mm/dd/yy or mm/dd/yyyy\n     parm2 = null (0) or positive/negative integer\n\n     e.g.  RXDATE(6,,1)            returns ===>  next day's date\n           RXDATE(6,'07/23/85',10) returns ===>  08/02/85\n           RXDATE(6,'07/23/85',-5) returns ===>  07/18/85\n\n  7  Returns as the value of the function, the number of days from one\n     date to another. The number of days from one day to the next is\n     considered one (1).\n\n     parm1 = null (current date) or mm/dd/yy or mm/dd/yyyy\n     parm2 = null (current date) or mm/dd/yy or mm/dd/yyyy\n\n     e.g.  RXDATE(7,,'01/01/2000')             returns ===>  5288\n                  (assuming current date is 7/10/85)\n           RXDATE(7,'01/01/1900','01/01/2000') returns ===> 36524\n           RXDATE(7,'01/01/2000','01/01/1900') returns ===> 36524\n\n  8  Returns as the value of the function, the number of the\n     day-of-the-week, 1-7 for Sunday-Saturday respectively, for\n     date specified in parm1.\n\n     parm1 = null (current date) or mm/dd/yy or mm/dd/yyyy\n     parm2 = not used\n\n     e.g.  RXDATE(8,'01/01/2000') returns ===> 7\n           RXDATE(8,'07/04/1776') returns ===> 5\n\n  9  Edits the supplied date.  Returns '1' if date supplied in parm1 is\n     valid; returns 'ERROR' if date is invalid.\n\n     parm1 = null (current date) or mm/dd/yy or mm/dd/yyyy\n     parm2 = not used\n\n     e.g.  RXDATE(9,'a1/01/2000') returns ===> ERROR\n           RXDATE(9,'01/33/1985') returns ===> ERROR    (33 not valid)\n           RXDATE(9,'07/04/1776') returns ===> 1\n           RXDATE(9,'02/29/85')   returns ===> ERROR    (not leap year)\n           RXDATE(9,'02/29/84')   returns ===> 1\n\n\nDefaults:\n\n  Discussed under each option.\n\n====================== NOTES NOTES NOTES =======================\n\nWhen specifying dates in the parms, the date can be supplied as\nmm/dd/yy, or mm/dd/yyyy. This allows for dates not in the 1900's.\nAny date of the form mm/dd/yy is assumed in the 1900's if yy is >=\nthe value of the date window variable (win19xx)..\n\nFor options requesting a date be returned in the form mm/dd/yy,\ndd/mm/yy, or yy/mm/dd, the yy portion will be 2 digits if the year is\n>= the 1900's or 4 digits if < the 1900's.\n\nThe RXDATE function emulates all of the options of the REXX built-\nin function DATE(), and also has nine (9) other options.  The REXX\nbuilt-in DATE() function however, returns data concerning the current\ndate only; for example DATE(M) will return the full name of the current\nmonth, whereas RXDATE(M) will do the same thing, but you can specify\na parm i.e. RXDATE(M,'02/13/86') which will return 'February'.\n\nThis is true for all of the RXDATE options which correspond to the\nsame option for the REXX DATE built-in function.\n\nOptions C, D, E, J, M, O, S, U, and W are the same as for the DATE\nbuilt-in function, except you can specify any date as a parm. As another\nexample of this, if today is Wednesday, and you execute code DATE(W),\nor RXDATE(W), 'Wednesday' will be returned from the function; if you\nwant to know what day January 1, 2000 is, you can code:\n\n          day = RXDATE(W,'01/01/2000')\n\nand the variable 'day' will contain 'Saturday'.\n\n===================== END OF NOTES ============================= */\n\n    trace\n\n    option = arg(1)\n    parm1  = arg(2)\n    parm2  = arg(3)\n\n    CALL INIT_LOGIC\n    CALL MAIN_LOGIC\n    CALL CLOSING_LOGIC\n    If errors_present = true\n      then\n        EXIT 'ERROR'\n      else\n        EXIT answer\n\nINIT_LOGIC:\n\n    ONCE = 1\n    TRUE = 1\n    FALSE = 0\n    NULL = ''\n    ERRORS_PRESENT = FALSE\n    STACK_DELIMITER = 'FAFBFCFDFEFFFEFDFCFBFA'X\n    HI = '1DC8'X\n    LO = '1D60'X\n    existing_date_options = 'CDEJMOSUW'\n    new_date_options = '123456789'\n    option_string = 'CDEJMOSUW123456789'\n    options_returning_data_with_slashes = 'EOU156'\n    first_parm_mmddyy_options = 'CDEJMOSUW26789'\n    first_parm_true_julian_options = '14'\n    first_parm_false_julian_options = '35'\n    second_parm_numeric_options = '6'\n    second_parm_mmddyy_options = '7'\n\n    RETURN\n\nMAIN_LOGIC:\n\n    call edit_options_and_parms\n\n    do once while errors_present = false\n      select\n        when option = ''  then\n             answer = date_function_for_null_option(parm1)\n        when index(existing_date_options,option) /= 0 then\n             call emulate_existing_function_with_extended_capability\n        when index(new_date_options,option) /= 0 then\n             call perform_functions_of_new_options\n      otherwise\n          nop\n      end\n    end\n\n    RETURN\n\nemulate_existing_function_with_extended_capability:\n\n    select\n      when option = 'C' then\n         answer = number_of_days_from_start_of_century(parm1)\n      when option = 'D' then\n         answer = number_of_days_from_start_of_year(parm1)\n      when option = 'E' then\n         answer = date_in_european_format(parm1)\n      when option = 'J' then\n         answer = julian_os_the_false_julian(parm1)\n      when option = 'M' then\n         answer = full_name_of_the_month(parm1)\n      when option = 'O' then\n         answer = date_in_form_YY_MM_DD(parm1)\n      when option = 'S' then\n         answer = date_in_form_YYYYMMDD(parm1)\n      when option = 'U' then\n         answer = date_in_form_MM_DD_YY(parm1)\n      when option = 'W' then\n         answer = full_name_of_the_day(parm1)\n    otherwise\n      nop\n    end\n\n   Return answer\n\nperform_functions_of_new_options:\n\n    select\n      when option =  1  then\n        answer = convert_true_julian_to_gregorian(parm1)\n      when option =  2  then\n        answer = convert_gregorian_to_true_julian(parm1)\n      when option =  3  then\n        answer = convert_false_julian_to_true_julian(parm1)\n      when option =  4  then\n        answer = convert_true_julian_to_false_julian(parm1)\n      when option =  5  then\n        answer = convert_false_julian_to_gregorian(parm1)\n      when option =  6  then\n        answer = number_of_days_hence_plus_or_minus(parm1,parm2)\n      when option =  7  then\n        answer = difference_in_days_between_two_dates(parm1,parm2)\n      when option =  8  then\n        answer = return_day_of_week_1_thru_7(parm1)\n      when option =  9  then\n        answer = just_edit_the_date(parm1)\n      otherwise\n        nop\n    end\n\n   Return\n\nCLOSING_LOGIC:\n\n    call reformat_year_in_answer_to_2_digits_if_1900s\n\n    RETURN\n\nreformat_year_in_answer_to_2_digits_if_1900s:\n\n    do once while errors_present = false &,\n                  index(options_returning_data_with_slashes,option) /= 0\n      parse value answer with v1 '/' v2 '/' v3 .\n      select\n        when length(v1) > 2 then\n          do\n            if substr(v1,1,2) >= '19' then v1 = 2digit(v1)\n          end\n        when length(v2) > 2 then\n          do\n            if substr(v2,1,2) >= '19' then v2 = 2digit(v2)\n          end\n        when length(v3) > 2 then\n          do\n            if substr(v3,1,2) >= '19' then v3 = 2digit(v3)\n          end\n        otherwise\n          nop\n      end\n      answer = v1 '/' v2 '/' v3\n      answer = space(answer,'0')\n    end\n\n   Return\n\ndate_function_for_null_option: procedure\n\n    arg parm1\n    parse value parm1 with mm '/' dd '/' yy .\n\n    answer = right(dd,2,'0') substr(name_of_month_text(mm),1,3),\n             4digit_year(yy)\n\n    answer = space(answer,'1')\n\n   Return answer\n\nnumber_of_days_from_start_of_century: procedure\n\n    arg parm1\n    parse value parm1 with mm '/' dd '/' yy .\n    yy = 4digit_year(yy)\n    century_yr = century(yy)\n    answer = jnum(mm,dd,yy) - jnum(1,1,century_yr) + 1\n\n   Return answer\n\nnumber_of_days_from_start_of_year: procedure\n\n    arg parm1\n    parse value parm1 with mm '/' dd '/' yy .\n    yy = 4digit_year(yy)\n    answer = jnum(mm,dd,yy) - jnum(01,01,yy) + 1\n\n   Return answer\n\ndate_in_european_format: procedure\n\n    arg parm1\n    parse value parm1 with mm '/' dd '/' yy .\n    answer = space(dd '/' mm '/' yy,'0')\n\n   Return answer\n\njulian_os_the_false_julian: procedure\n\n    arg parm1\n    parse value parm1 with mm '/' dd '/' yy .\n    v1 = 2digit(yy)\n    v2 = number_of_days_from_start_of_year(parm1)\n    answer = v1||right(v2,3,'0')\n\n   Return answer\n\nfull_name_of_the_month: procedure\n\n    arg parm1\n    parse value parm1 with mm '/' .\n    answer = name_of_month_text(mm)\n\n   Return answer\n\ndate_in_form_YY_MM_DD: procedure\n\n    arg parm1\n    parse value parm1 with mm '/' dd '/' yy .\n    answer = yy '/' mm '/' dd\n    answer = space(answer,'0')\n\n   Return answer\n\ndate_in_form_YYYYMMDD: procedure\n\n    arg parm1\n    parse value parm1 with mm '/' dd '/' yy .\n    answer = 4digit_year(yy) 2digit(mm) 2digit(dd)\n    answer = space(answer,'0')\n\n   Return answer\n\ndate_in_form_MM_DD_YY: procedure\n\n    arg parm1\n    answer = parm1\n\n   Return answer\n\nfull_name_of_the_day: procedure\n\n    arg parm1\n    parse value parm1 with mm '/' dd '/' yy .\n    answer = name_of_day_text(day_of_week(mm,dd,yy))\n\n   Return answer\n\nconvert_true_julian_to_gregorian: procedure\n\n    arg parm1\n    answer = gregday(parm1)\n\n   Return answer\n\nconvert_gregorian_to_true_julian: procedure\n\n    arg parm1\n    parse value parm1 with mm '/' dd '/' yy .\n    answer = jnum(mm,dd,yy)\n\n   Return answer\n\nconvert_false_julian_to_true_julian: procedure\n\n    arg parm1\n    answer =  fjul_tjul(parm1)\n\n   Return answer\n\nconvert_true_julian_to_false_julian: procedure\n\n    arg parm1\n    answer =  tjul_fjul(parm1)\n\n   Return answer\n\nconvert_false_julian_to_gregorian: procedure\n\n    arg parm1\n    answer =  gregday(fjul_tjul(parm1))\n\n   Return answer\n\nnumber_of_days_hence_plus_or_minus:\n\n    procedure expose errors_present true\n\n    parm1 = arg(1)\n    parm2 = arg(2)\n    parse value parm1 with mm '/' dd '/' yy .\n    select\n      when parm2 < 0 & abs(parm2) > (jnum(mm,dd,yy) - 1721426) then\n        do\n          errors_present = true\n        end\n      when parm2 >= 0 & parm2 >  (5373484 - jnum(mm,dd,yy)) then\n        do\n          errors_present = true\n        end\n      otherwise\n        do\n          answer = gregday(jnum(mm,dd,yy) + parm2)\n        end\n    end\n\n   Return answer\n\ndifference_in_days_between_two_dates: procedure\n\n    parm1 = arg(1)\n    parm2 = arg(2)\n    parse value parm1 with mm1 '/' dd1 '/' yy1 .\n    parse value parm2 with mm2 '/' dd2 '/' yy2 .\n    answer = abs(jnum(mm1,dd1,yy1) - jnum(mm2,dd2,yy2))\n\n   Return answer\n\nreturn_day_of_week_1_thru_7: procedure\n\n    arg parm1\n    parse value parm1 with mm '/' dd '/' yy .\n    yy = 4digit_year(yy)\n    answer = day_of_week(mm,dd,yy)\n\n   Return  answer\n\njust_edit_the_date: procedure\n\n/* date must be good or we would not get here */\n\n    answer = 1\n\n   Return answer\n\njnum: procedure\n\n    month = arg(1)\n    day   = arg(2)\n    year  = arg(3)\n\n    year  = 4digit_year(year)\n\n    numeric digits 15\n\n    If month > 2\n      then\n        month = month - 3\n      else\n        do\n        month = month + 9\n        year = year - 1\n        end\n\n    c =     year % 100\n    ya =     year - 100 * c\n    julian_number =    (146097 * c  % 4) +    ((1461 * ya) % 4) +,\n                       ((153 * month + 2) % 5) + day + 1721119\n\n    return julian_number\n\nGREGDAY: procedure\n\n    jn = arg(1)\n    numeric digits 15\n    jn = jn - 1721119\n    year =    ((4 * jn - 1) % 146097)\n    jn =    (4 * jn - 1 - 146097 * year)\n    day =     jn % 4\n    jn =    ((4 * day + 3) % 1461)\n    day =    (4 * day + 3 - 1461 * jn)\n    day =    ((day + 4) % 4)\n    month =    ((5 * day - 3) % 153)\n    day   =    (5 * day - 3 - 153 * month)\n    day =    ((day + 5) % 5)\n    year =    (100 * year + jn)\n\n    If month < 10\n      Then\n         month = month + 3\n      Else\n        Do\n          month = month - 9\n          year  = year + 1\n        End\n\n    return mm_dd_yyyy(month,day,year)\n\nmm_dd_yy: procedure\n\n    mm = arg(1)\n    dd = arg(2)\n    yy = arg(3)\n\n    answer = right(month,2,'0') '/' right(day,2,'0') '/',\n             right(year,2,'0')\n    answer = space(answer,0)\n\n    return answer\n\nday_of_week: procedure\n\n    mm = arg(1)\n    dd = arg(2)\n    yy = arg(3)\n\n    w_var  =     (jnum(mm,dd,yy) - jnum(1,1,1984)) // 7\n\n    if w_var >= 0 then\n        answer = w_var + 1\n      else\n        answer = w_var + 8\n\n   Return answer\n\nTJUL_FJUL: procedure /* true julian to false julian */\n\n    true_julian_number = arg(1)\n    greg_date = gregday(true_julian_number)\n    greg_year = substr(greg_date,7,4)\n    false_julian_day = true_julian_number - jnum(1,1,greg_year) + 1\n    answer = substr(greg_year,3,2)||right(false_julian_day,3,'0')\n\n    return answer\n\nFJUL_TJUL: procedure /* false julian to true julian */\n\n    false_julian_number = arg(1)\n    false_julian_year   = substr(false_julian_number,1,2)\n    false_julian_day    = substr(false_julian_number,3,3)\n    answer = jnum(1,1,false_julian_year) + false_julian_day - 1\n\n    return answer\n\nmm_dd_yyyy: procedure\n\n    mm   = arg(1)\n    dd   = arg(2)\n    yyyy = arg(3)\n\n    answer = right(mm,2,'0') '/' right(dd,2,'0') '/',\n             right(yyyy,4,'0')\n    answer = space(answer,'0')\n\n    return answer\n\nedit_options_and_parms:\n\n    call edit_options\n    do once while errors_present = false\n      call edit_parms\n    end\n\n   Return\n\nedit_options:\n\n    upper option\n\n    select\n      when option = null then nop\n      when index(option_string,option) /= 0 then nop\n    otherwise\n        do\n          errors_present = true\n        end\n    end\n\n   Return\n\nedit_parms:\n\n    call edit_the_first_parm\n    call edit_the_second_parm\n\n   Return\n\nedit_the_first_parm:\n\n    parm1 = space(parm1,'0')\n\n    select\n      when parm1 = null then\n        call generate_default_value_for_parm1\n      when index(first_parm_mmddyy_options,option) /= 0 &,\n           mmddyy_edit_ok(parm1) = true then\n        NOP\n      when index(first_parm_true_Julian_options,option) /= 0 &,\n           true_julian_edit_ok(parm1) = true then\n        NOP\n      when index(first_parm_false_julian_options,option) /= 0 &,\n           false_julian_edit_ok(parm1) = true then\n        NOP\n      when option = null & mmddyy_edit_ok(parm1) = true then\n        NOP\n      otherwise\n          errors_present = true\n    end\n\n   Return\n\ngenerate_default_value_for_parm1:\n\n    select\n      when index(first_parm_mmddyy_options,option) /= 0 then\n          parm1 = DATE(U)\n      when index(first_parm_true_julian_options,option) /= 0 then\n        do\n          parse value DATE(U) with mm '/' dd '/' yy .\n          parm1 = jnum(mm,dd,yy)\n        end\n      when index(first_parm_false_julian_options,option) /= 0 then\n          parm1 = DATE(J)\n      when option = null then parm1 = DATE(U)\n    otherwise\n      nop\n    end\n\n   Return\n\n\nedit_the_second_parm:\n\n    parm2 = space(parm2,'0')\n\n    select\n      when parm2 = null then\n        call generate_default_value_for_parm2\n      when index(second_parm_numeric_options,option) /= 0 &,\n           datatype(parm2,'N') = true then\n        NOP\n      when index(second_parm_mmddyy_options,option) /= 0 &,\n           mmddyy_edit_ok(parm2) = true then\n        NOP\n      otherwise\n          errors_present = true\n    end\n\n   Return\n\ngenerate_default_value_for_parm2:\n\n    select\n      when index(second_parm_mmddyy_options,option) /= 0 then\n        parm2 = DATE(U)\n      when index(second_parm_numeric_options,option) /= 0 then\n        parm2 = '0'\n    otherwise\n      nop\n    end\n\n   Return\n\nmmddyy_edit_ok: procedure\n\n    arg mmddyy\n\n    parse value mmddyy with mm '/' dd '/' yy .\n    answer = 0\n\n    If datatype(mm,'N') & datatype(dd,'N') & datatype(yy,'N')\n      then\n        do\n          yy = 4digit_year(yy)\n          If gregday(jnum(mm,dd,yy)) = mm_dd_yyyy(mm,dd,yy)\n            then\n              do\n                answer = 1\n              end\n        end\n\n    return answer\n\nfalse_julian_edit_ok: procedure\n\n    arg false_julian\n\n    select\n      when datatype(false_julian,'N') /= 1  then\n          do\n          answer = 0\n          end\n      when length(false_julian) /= 5        then\n          do\n          answer = 0\n          end\n      when tjul_fjul(fjul_tjul(false_julian)) /= false_julian then\n          do\n          answer = 0\n          end\n      otherwise\n        do\n          answer = 1\n        end\n    end\n\n    return answer\n\ntrue_julian_edit_ok: procedure\n\n    arg true_julian\n\n    select\n      when datatype(true_julian,'N') /= 1 then\n        do\n          answer = 0\n        end\n      when true_julian <  1721426   true_julian >  5373484 then\n        do\n          answer = 0\n        end\n      otherwise\n        do\n          answer = 1\n        end\n    end\n\n    return answer\n\nname_of_month_text: procedure\n\n    mm = arg(1)\n\n    answer = word('January February March April May June',\n            ' July August September October',\n            ' November December',mm)\n\n   Return answer\n\nname_of_day_text: procedure\n\n    arg dd\n\n    answer = word('Sunday Monday Tuesday Wednesday',\n            ' Thursday Friday Saturday Sunday',dd)\n\n   Return answer\n\ncentury: procedure\n\n    win19xx = 66          /* Start of 19xx date window */\n\n    yyyy = arg(1)\n\n    century_year = 100 * (yyyy % 100)\n\n    If century_year < 100\n      then\n        do\n          If century_year < win19xx\n            then\n              century_year = 2000\n            else\n              century_year = 1900\n        end\n\n    return century_year\n\n2digit: procedure\n\n    var = arg(1)\n\n    var = right(var,2,'0')\n\n    return var\n\n    return\n\n4digit: procedure\n\n    var = arg(1)\n\n    var = right(var,4,'0')\n\n    return var\n\n4digit_year: procedure\n\n    win19xx = 66          /* Start of 19xx date window */\n\n    yy = arg(1)\n\n    If length(yy) < 3\n      then\n        do\n          If yy < win19xx\n            then\n              yy = yy + 2000\n            else\n              yy = yy + 1900\n        end\n\n    return yy\n\nFormat_year_to_two_or_four_digit_year: procedure\n\n    ddate = arg(1)\n    parse value ddate with mm '/' dd '/' yy .\n\n    select\n      when length(yy) > 2 & substr(yy,1,2) >= '19' then\n        do\n          yy = 2digit(yy)\n        end\n      otherwise\n        nop\n    end\n\n    answer = mm '/' dd '/' yy\n    answer = space(answer,'0')\n\n    return answer\n\n/* J. Kalinich, 314-552-3232                                          */\n/* Rexx date conversion function                                      */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "VCX": {"ttr": 1290, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00V\\x01\\x064_\\x01\\x11\\x04_\\x083\\x02\\x9f\\x01\\xf3\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2006-12-11T00:00:00", "modifydate": "2011-02-14T08:33:56", "lines": 671, "newlines": 499, "modlines": 0, "user": "REXX"}, "text": "/* REXX    VCX        Re-write of Jim Connelley's VC to take advantage\n                      of LISTCSUM\n\n           Written by Frank Clarke 20020507\n\n     VC Source\n     http://connelley.org/Coding_Examples/vclone.html\n\n     Impact Analysis\n.    SYSPROC   LISTCSUM\n.    SYSPROC   TRAPOUT\n\n     Modification History\n     20020722 fxc NUMBERED on CLUSTER only; ignore NOWRITECHK, NOIMBED,\n                  NOREPLICAT, NOREUSE;\n     20020819 fxc rearranged parameters; drop obsolete tags\n     20030331 fxc no SUMMARY for a GDGBASE; a single generation of a\n                  GDG will show as NONVSAM with a 'GDG' tag in\n                  NONVSAMASSOCIATIONS;\n\n*/ arg argline\naddress TSO                            /* REXXSKEL ver.20020513      */\narg parms \"((\" opts\n\nsignal on syntax\nsignal on novalue\n\ncall TOOLKIT_INIT                      /* conventional start-up     -*/\nrc     = trace(tv)\ninfo   = parms                         /* to enable parsing          */\n\ncall A_INIT                            /*                           -*/\ncall B_PROCESS_CAT                     /*                           -*/\n\nif \\sw.nested then call DUMP_QUEUE     /*                           -*/\nif \\sw.nested then do\n   \"NEWSTACK\" ; pull ; \"DELSTACK\"\n   end\nexit                                   /*@ VCX                       */\n/*\n.  ----------------------------------------------------------------- */\nA_INIT:                                /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   parse value \"0 0 0 0 0 0 0 0 0 0\" with ,\n         ct.    .\n   parse value \"\" with ,\n         taglist   tagdata.      ,\n         .\n   call AK_KEYWDS                      /*                           -*/\n   parse var info dsname info\n\nreturn                                 /*@ A_INIT                    */\n/*\n.  ----------------------------------------------------------------- */\nAK_KEYWDS:                             /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   outdsn = KEYWD(\"OUTPUT\")\n\nreturn                                 /*@ AK_KEYWDS                 */\n/*\n   Obtain definition data via LISTC; parse it into its components;\n   recreate the DEFINE which produced this picture.\n.  ----------------------------------------------------------------- */\nB_PROCESS_CAT:                         /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   \"NEWSTACK\"\n   call BA_RUN_LISTCSUM                /*                           -*/\n   call BD_PULL_DATAPOINTS             /*                           -*/\n   \"DELSTACK\"\n\n   \"NEWSTACK\"\n                                    if \\sw.0error_found then,\n   call BG_WRITE_DEFINE                /*                           -*/\n   \"DELSTACK\"\n\nreturn                                 /*@ B_PROCESS_CAT             */\n/*\n.  ----------------------------------------------------------------- */\nBA_RUN_LISTCSUM:                       /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   \"LISTCSUM\" dsname  \"STACK\"          /* load keys to stack        -*/\n\nreturn                                 /*@ BA_RUN_LISTCSUM           */\n/*\n.  ----------------------------------------------------------------- */\nBD_PULL_DATAPOINTS:                    /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   do queued()                         /* each queued line           */\n      parse pull keytag \":\" tagdata\n      taglist = taglist keytag         /* add to list                */\n      tagdata.keytag = tagdata         /* load tagdata to keytag     */\n   end                                 /* queued                     */\n\n   info        = tagdata.SUMMARY\n   parse value   KEYWD(\"ALIAS\")   0 with ct.0alias .\n   parse value   KEYWD(\"CLUSTER\") 0 with ct.0cluster .\n   parse value   KEYWD(\"DATA\")    0 with ct.0data  .\n   parse value   KEYWD(\"GDG\")     0 with ct.0gdg   .\n   parse value   KEYWD(\"INDEX\")   0 with ct.0index .\n   parse value   KEYWD(\"NONVSAM\") 0 with ct.0nonvsam .\n   parse value   KEYWD(\"TOTAL\")   0 with ct.0total .\n   ct.0subtot  = ct.0alias + ct.0cluster + ct.0data + ct.0gdg + ,\n                 ct.0index + ct.0nonvsam\n   if ct.0total > ct.0subtot then do   /* stuff we can't handle      */\n      say exec_name \"is not yet capable of handling something in\",\n            \"this list:\"\n      say info                         /* what's left over?          */\n      sw.0error_found = 1\n      return                           /* we're done                 */\n      end\n\n   if ct.0alias   > 0 then call BDA_ALIAS /*                         -*/\n   if ct.0cluster > 0 then call BDC_CLU   /*                         -*/\n   if ct.0gdg     > 0 then call BDG_GDG   /*                         -*/\n   if ct.0nonvsam > 0 then call BDN_NV    /*                         -*/\n\nreturn                                 /*@ BD_PULL_DATAPOINTS        */\n/*\n   An ALIAS is also referenced in NONVSAMASSOCIATIONS\n.  ----------------------------------------------------------------- */\nBDA_ALIAS:                             /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   info  = tagdata.aliasassociations\n   base  = KEYWD(\"NONVSAM\")\n   alias = dsname\n\nreturn                                 /*@ BDA_ALIAS                 */\n/*\n   CLUSTER.\n.  ----------------------------------------------------------------- */\nBDC_CLU:                               /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   clusterdsn = dsname\n\n   info     = tagdata.clusterassociations\n   datadsn  = KEYWD(\"DATA\")\n   indexdsn = KEYWD(\"INDEX\")\n\n   info     = tagdata.clustersmsdata\n   stgcls   = KEYWD(\"STORAGECLASS\")\n   mgmtcls  = KEYWD(\"MANAGEMENTCLASS\")\n   datacls  = KEYWD(\"DATACLASS\")\n\n   if ct.0data > 0 then,\n      call BDCD_DATA                   /*                           -*/\n\n   if ct.0index > 0 then,\n      call BDCI_INDEX                  /*                           -*/\n\nreturn                                 /*@ BDC_CLU                   */\n/*\n   CLUSTER DATA\n.  ----------------------------------------------------------------- */\nBDCD_DATA:                             /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   info     = tagdata.dataattributes\n   keylen   = KEYWD(\"KEYLEN\")\n   avgrecl  = KEYWD(\"AVGLRECL\")\n   bufspc   = KEYWD(\"BUFSPACE\")\n   cisize   = KEYWD(\"CISIZE\")\n   rkp      = KEYWD(\"RKP\")\n   maxrecl  = KEYWD(\"MAXLRECL\")\n   excpext  = KEYWD(\"EXCPEXIT\")\n   recsper  = KEYWD(\"RECORDS/CI\")\n   maxrecs  = KEYWD(\"MAXRECS\")\n   cicapct  = KEYWD(\"CI/CA\")\n   shropts  = CLKWD(\"SHROPTNS\")        /* CLIST-form                 */\n   dataopts = info                     /* whatever is left           */\n\n   info     = tagdata.dataallocation\n   spctyp   = KEYWD(\"SPACE TYPE\")\n   spcpri   = KEYWD(\"SPACE PRI\")\n   spcsec   = KEYWD(\"SPACE SEC\")\n\n   info     = tagdata.datastatistics\n   dfspcci  = KEYWD(\"FREESPACE %CI\")\n   dfspcca  = KEYWD(\"FREESPACE %CA\")\n\n   info     = tagdata.dataassociations\n   clusterdsn = KEYWD(\"CLUSTER\")\n\nreturn                                 /*@ BDCD_DATA                 */\n/*\n   CLUSTER INDEX\n.  ----------------------------------------------------------------- */\nBDCI_INDEX:                            /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   info     = tagdata.indexattributes\n   idxklen  = KEYWD(\"KEYLEN\")\n   idxavgl  = KEYWD(\"AVGLRECL\")\n   idxbuf   = KEYWD(\"BUFSPACE\")\n   idxci    = KEYWD(\"CISIZE\")\n   idxrkp   = KEYWD(\"RKP\")\n   idxmaxl  = KEYWD(\"MAXLRECL\")\n   idxecpx  = KEYWD(\"EXCPEXIT\")\n   idxcica  = KEYWD(\"CI/CA\")\n   idxshro  = CLKWD(\"SHROPTNS\")        /* CLIST-form                 */\n   idxopts  = info                     /* whatever is left           */\n\n   info     = tagdata.indexallocation\n   idxspc   = KEYWD(\"SPACE TYPE\")\n   idxpri   = KEYWD(\"SPACE PRI\")\n   idxsec   = KEYWD(\"SPACE SEC\")\n\n   info     = tagdata.indexstatistics\n   xfspcci  = KEYWD(\"FREESPACE %CI\")\n   xfspcca  = KEYWD(\"FREESPACE %CA\")\n\n   info     = tagdata.indexassociations\n   clusterdsn = KEYWD(\"CLUSTER\")\n\nreturn                                 /*@ BDCI_INDEX                */\n/*\n.  Missing: OWNER, TO, FROM\n.  ----------------------------------------------------------------- */\nBDG_GDG:                               /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   info    = tagdata.gdgbaseattributes\n   gdglim  = KEYWD(\"LIMIT\")\n   gdgopts = info                      /* whatever is left           */\n   ct.0nonvsam = 0                     /* don't process NONVSAM      */\n\nreturn                                 /*@ BDG_GDG                   */\n/*\n.  ----------------------------------------------------------------- */\nBDN_NV:                                /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   info     = tagdata.nonvsamsmsdata\n   stgcls   = KEYWD(\"STORAGECLASS\")\n   mgmtcls  = KEYWD(\"MANAGEMENTCLASS\")\n   datacls  = KEYWD(\"DATACLASS\")\n\n   info     = tagdata.associations\n   nvalias  = KEYWD(\"ALIAS\")\n\nreturn                                 /*@ BDN_NV                    */\n/*\n.  ----------------------------------------------------------------- */\nBG_WRITE_DEFINE:                       /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   if ct.0alias  > 0 then,\n      call BGA_DEFALIAS                /*                           -*/\n   if ct.0cluster > 0 then,\n      call BGC_DEFCL                   /*                           -*/\n   if ct.0gdg    > 0 then,\n      call BGG_DEFGDG                  /*                           -*/\n   if ct.0nonvsam > 0 then,\n      call BGG_DEFNVSAM                /*                           -*/\n\n   alloc.0   = \"NEW CATALOG UNIT(SYSDA) SPACE(1) TRACKS\",\n               \"RECFM(V B) LRECL(1024) DSORG(PS) BLKSIZE(0)\"\n   vio.0     = \"NEW CATALOG UNIT(VIO) SPACE(1) TRACKS\",\n               \"RECFM(V B) LRECL(1024) DSORG(PS) BLKSIZE(0)\"\n   alloc.1   = \"SHR\"                /* if it already exists...    */\n\n   if outdsn <> \"\" then do             /* write to DASD              */\n      tempstat = Sysdsn(outdsn) = \"OK\",/* 1=exists, 0=missing        */\n               | Sysdsn(outdsn) = \"MEMBER NOT FOUND\"\n      \"ALLOC FI($TMP) DA(\"outdsn\") REU\" alloc.tempstat\n      \"EXECIO\" queued() \"DISKW $TMP (FINIS\"\n      sw.0BrowseTMP = 1                /*                            */\n      end                              /* outdsn                     */\n   else ,                              /* no OUTDSN                  */\n   if sw.inispf then do                /* ISPF available             */\n      \"ALLOC FI($TMP)  REU\" vio.0\n      \"EXECIO\" queued() \"DISKW $TMP (FINIS\"\n      sw.0BrowseTMP = 1                /*                            */\n      end                              /* inispf                     */\n   else do                             /* write to terminal          */\n      \"CLEAR\"                          /*                            */\n      do queued()\n         pull line; say line           /*                            */\n      end                              /* queued                     */\n      end                              /* terminal                   */\n\n   if sw.0BrowseTMP then do            /* display text               */\n      call BGZ_BROWSE_TMP              /*                           -*/\n      \"FREE  FI($TMP)\"\n      end                              /* BrowseTMP                  */\n\nreturn                                 /*@ BG_WRITE_DEFINE           */\n/*\n.  ----------------------------------------------------------------- */\nBGA_DEFALIAS:                          /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   queue \"   DEFINE  ALIAS -\"\n   queue \"       (   NAME(\"alias\") -\"\n   queue \"         RELATE(\"base\") )\"\n\nreturn                                 /*@ BGA_DEFALIAS              */\n/*\n.  ----------------------------------------------------------------- */\nBGC_DEFCL:                             /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   info = dataopts                     /* ready for parsing          */\n   sw.numbered = SWITCH(\"NUMBERED\")    /* RRDS ?                     */\n   sw.indexed  = SWITCH(\"INDEXED\")     /* KSDS ?                     */\n   sw.nonindx  = SWITCH(\"NONINDEXED\")  /* ESDS ?                     */\n   sw.linear   = SWITCH(\"LINEAR\")      /* Linear DS ?                */\n\n   sw.reuse    = SWITCH(\"REUSE\")\n   sw.noreuse  = SWITCH(\"NOREUSE\")\n   if sw.reuse = sw.noreuse then,\n      parse value \"0 1\"  with  sw.reuse  sw.noreuse .\n\n   sw.unique   = SWITCH(\"UNIQUE\")\n   if sw.reuse then sw.unique = 0\n\n   $z   = SWITCH(\"NOWRITECHK\")         /* unused                     */\n   $z   = SWITCH(\"NOIMBED\")            /* unused                     */\n   $z   = SWITCH(\"NOREPLICAT\")         /* unused                     */\n   dataopts = info                     /* restore corrected          */\n\n   queue \"   DEFINE  CLUSTER -\"\n   queue \"       (   NAME(\"clusterdsn\") -\"\n   if stgcls   <> \"(NULL)\" then,\n      queue \"         STORAGECLASS(\"stgcls\") -\"\n   if mgmtcls  <> \"(NULL)\" then,\n      queue \"         MANAGEMENTCLASS(\"mgmtcls\") -\"\n   if datacls  <> \"(NULL)\" then,\n      queue \"         DATACLASS(\"datacls\") -\"\n\n   attribs = \"\"\n   if sw.numbered  then,\n      attribs = attribs \"NUMBERED\"\n   if sw.indexed   then,\n      attribs = attribs \"INDEXED\"\n   if sw.nonindx   then,\n      attribs = attribs \"NONINDEXED\"\n   if sw.linear    then,\n      attribs = attribs \"LINEAR\"\n   if attribs <> \"\" then ,\n      queue \"         \"Space(attribs,1)\" -\"\n\n   if ct.0data > 0 then do\n   queue \"       ) -\"\n   queue \"           DATA    -\"\n   queue \"       (   NAME(\"datadsn\") -\"\n   queue \"         \"spctyp\"(\"spcpri \",\" spcsec\") -\"\n   queue \"         RECORDSIZE(\"avgrecl \",\" maxrecl\") -\"\n   queue \"         FREESPACE(\"dfspcci \",\" dfspcca\") -\"\n\n   if sw.reuse then dataopts = dataopts \"REUSE\"\n               else dataopts = dataopts \"NOREUSE\"\n   dataopts = Space(dataopts,1)\n   do while dataopts <> \"\"\n      pt = LastPos(\" \",dataopts\" \",40)\n      slug      = Substr(dataopts,1,pt)\n      dataopts  = Delstr(dataopts,1,pt)\n      queue \"         \"slug\" -\"\n   end                                 /* dataopts                   */\n\n   queue \"         BUFFERSPACE(\"bufspc\") -\"\n   queue \"         CONTROLINTERVALSIZE(\"cisize\") -\"\n   queue \"         SHAREOPTIONS(\"shropts\") -\"\n   if keylen > 0 then,\n   queue \"         KEYS(\"keylen \",\" rkp\") -\"\n      end                              /* DATA                       */\n\n   if ct.0index > 0 then do\n   queue \"       ) -\"\n   queue \"           INDEX   -\"\n   queue \"       (   NAME(\"indexdsn\") -\"\n   queue \"         \"idxspc\"(\"idxpri \",\" idxsec\") -\"\n\n   info    = idxopts                   /* ready for parsing          */\n   $z      = SWITCH(\"SPEED\")           /* purge from string          */\n   $z      = SWITCH(\"RECOVERY\")\n   $z      = SWITCH(\"ERASE\")\n   $z      = SWITCH(\"NOERASE\")\n   $z      = SWITCH(\"UNIQUE\")\n   $z      = SWITCH(\"WRITECHK\")\n   $z      = SWITCH(\"NOWRITECHK\")\n   $z      = SWITCH(\"NOREPLICAT\")\n   $z      = SWITCH(\"REPLICAT\")\n   $z      = SWITCH(\"REPLICATE\")\n   idxopts = Space(info,1)             /* ready to load              */\n\n   idxopts = Space(idxopts,1)\n   do while idxopts <> \"\"\n      pt = LastPos(\" \",idxopts\" \",40)\n      slug      = Substr(idxopts,1,pt)\n      idxopts   = Delstr(idxopts,1,pt)\n      queue \"         \"slug\" -\"\n   end                                 /* idxopts                    */\n\n   queue \"         CONTROLINTERVALSIZE(\"idxci\") -\"\n   queue \"         SHAREOPTIONS(\"idxshro\") -\"\n      end                              /* INDEX                      */\n\n   queue \"       )\"\n\nreturn                                 /*@ BGC_DEFCL                 */\n/*\n.  ----------------------------------------------------------------- */\nBGG_DEFGDG:                            /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   queue \"   DEFINE  GENERATIONDATAGROUP   -\"\n   queue \"       (   NAME(\"dsname\") -\"\n   queue \"          LIMIT(\"gdglim\") -\"\n   queue \"          \" gdgopts \")\"\n\nreturn                                 /*@ BGG_DEFGDG                */\n/*\n.  ----------------------------------------------------------------- */\nBGG_DEFNVSAM:                          /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   queue \"   DEFINE  NONVSAM   -\"\n   queue \"       (   NAME(\"dsname\") )\"\n\nreturn                                 /*@ BGG_DEFNVSAM              */\n/*\n.  ----------------------------------------------------------------- */\nBGZ_BROWSE_TMP:                        /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   \"LMINIT DATAID(DDNID) DDNAME($TMP)\"\n   \"VIEW DATAID(\"ddnid\")\"\n\nreturn                                 /*@ BGZ_BROWSE_TMP            */\n/*\n.  ----------------------------------------------------------------- */\nLOCAL_PREINIT:                         /*@ customize opts            */\n   address TSO\n\n   if SWITCH(\"NONEST\") then sw.nested = 0\n\nreturn                                 /*@ LOCAL_PREINIT             */\n/*   subroutines below LOCAL_PREINIT are not selected by SHOWFLOW    */\n/*\n.  ----------------------------------------------------------------- */\nHELP:                                  /*@                           */\naddress TSO;\"CLEAR\"\nif helpmsg <> \"\" then do ; say helpmsg; say \"\"; end\nex_nam = Left(exec_name,8)             /* predictable size           */\n\nsay \"  \"ex_nam\"      generates pro-forma IDCAMS DEFINE statements for the   \"\nsay \"                specified entity such as would have been used to       \"\nsay \"                create it originally.                                  \"\nsay \"                                                                       \"\nsay \"  Syntax:   \"ex_nam\"  <dsname>                                         \"\nsay \"                      <OUTPUT outdsn>                                  \"\nsay \"                                                                       \"\nsay \"            dsname    identifies the entity to be analyzed so that (a) \"\nsay \"                      DEFINE statement(s) can be constructed.          \"\nsay \"                                                                       \"\nsay \"            outdsn    names the target to receive the generated IDCAMS \"\nsay \"                      DEFINE statements.                               \"\nsay \"                                                                       \"\n\"NEWSTACK\"; pull ; \"CLEAR\" ; \"DELSTACK\"\nsay \"   Debugging tools provided include:                                   \"\nsay \"                                                                       \"\nsay \"        BRANCH:   show all paragraph entries.                          \"\nsay \"                                                                       \"\nsay \"        TRACE tv: will use value following TRACE to place the          \"\nsay \"                  execution in REXX TRACE Mode.                        \"\nsay \"                                                                       \"\nsay \"                                                                       \"\nsay \"   Debugging tools can be accessed in the following manner:            \"\nsay \"                                                                       \"\nsay \"        TSO \"ex_nam\"  parameters     ((  debug-options                 \"\nsay \"                                                                       \"\nsay \"   For example:                                                        \"\nsay \"                                                                       \"\nsay \"        TSO \"ex_nam\"  (( MONITOR TRACE ?R                              \"\n\naddress ISPEXEC \"CONTROL DISPLAY REFRESH\"\nexit                                   /*@ HELP                      */\n/*             REXXSKEL back-end removed for space                  */\n.  ----------------------------------------------------------------- */\nBRANCH: Procedure expose,              /*@                           */\n        sigl exec_name\n   rc = trace(\"O\")                     /* we do not want to see this */\n   arg brparm .\n\n   origin = sigl                       /* where was I called from ?  */\n   do currln = origin to 1 by -1       /* inch backward to label     */\n      if Right(Word(Sourceline(currln),1),1) = \":\" then do\n         parse value sourceline(currln) with pgfname \":\" .  /* Label */\n         leave ; end                   /*                name        */\n   end                                 /* currln                     */\n\n   select\n      when brparm = \"NAME\" then return(pgfname) /* Return full name  */\n      when brparm = \"ID\"      then do           /* wants the prefix  */\n         parse var pgfname pgfpref \"_\" .        /* get the prefix    */\n         return(pgfpref)\n         end                           /* brparm = \"ID\"              */\n      otherwise\n         say left(sigl,6) left(pgfname,40) exec_name \"Time:\" time(\"L\")\n   end                                 /* select                     */\n\nreturn                                 /*@ BRANCH                    */\n/*\n.  ----------------------------------------------------------------- */\nDUMP_QUEUE:                            /*@ Take whatever is in stack */\n   rc = trace(\"O\")                     /*  and write to the screen   */\n   address TSO\n\n   \"QSTACK\"                            /* how many stacks?           */\n   stk2dump    = rc - tk_init_stacks   /* remaining stacks           */\n   if stk2dump = 0 & queued() = 0 then return\n   say \"Total Stacks\" rc ,             /* rc = #of stacks            */\n    \"   Begin Stacks\" tk_init_stacks , /* Stacks present at start    */\n    \"   Excess Stacks to dump\" stk2dump\n\n   do dd = rc to tk_init_stacks by -1  /* empty each one.            */\n      say \"Processing Stack #\" dd \"   Total Lines:\" queued()\n      do queued();pull line;say line;end /* pump to the screen       */\n      \"DELSTACK\"                       /* remove stack               */\n   end                                 /* dd = 1 to rc               */\n\nreturn                                 /*@ DUMP_QUEUE                */\n/* Handle CLIST-form keywords             added 20020513\n.  ----------------------------------------------------------------- */\nCLKWD: Procedure expose info           /*@ hide all except info      */\n   arg kw\n   kw = kw\"(\"                          /* form is 'KEY(DATA)'        */\n   kw_pos = Pos(kw,info)               /* find where it is, maybe    */\n   if kw_pos = 0 then return \"\"        /* send back a null, not found*/\n   rtpt   = Pos(\") \",info\" \",kw_pos)   /* locate end-paren           */\n   slug   = Substr(info,kw_pos,rtpt-kw_pos+1)     /* isolate         */\n   info   = Delstr(info,kw_pos,rtpt-kw_pos+1)     /* excise          */\n   parse var slug (kw)     slug        /* drop kw                    */\n   slug   = Reverse(Substr(Reverse(Strip(slug)),2))\nreturn slug                            /*@CLKWD                      */\n/* Handle multi-word keys 20020513\n.  ----------------------------------------------------------------- */\nKEYWD: Procedure expose info           /*@ hide all vars, except info*/\n   arg kw\n   kw_pos = wordpos(kw,info)           /* find where it is, maybe    */\n   if kw_pos = 0 then return \"\"        /* send back a null, not found*/\n   kw_val = word(info,kw_pos+Words(kw))/* get the next word          */\n   info   = Delword(info,kw_pos,2)     /* remove both                */\nreturn kw_val                          /*@ KEYWD                     */\n/*\n.  ----------------------------------------------------------------- */\nKEYPHRS: Procedure expose,             /*@                           */\n         info helpmsg exec_name        /*  except these three        */\n   arg kp\n   wp    = wordpos(kp,info)            /* where is it?               */\n   if wp = 0 then return \"\"            /* not found                  */\n   front = subword(info,1,wp-1)        /* everything before kp       */\n   back  = subword(info,wp+1)          /* everything after kp        */\n   parse var back dlm back             /* 1st token must be 2 bytes  */\n   if length(dlm) <> 2 then            /* Must be two bytes          */\n      helpmsg = helpmsg \"Invalid length for delimiter(\"dlm\") with KEYPHRS(\"kp\")\"\n   if wordpos(dlm,back) = 0 then       /* search for ending delimiter*/\n      helpmsg = helpmsg \"No matching second delimiter(\"dlm\") with KEYPHRS(\"kp\")\"\n   if helpmsg <> \"\" then call HELP     /* Something is wrong         */\n   parse var back kpval (dlm) back     /* get everything b/w delim   */\n   info =  front back                  /* restore remainder          */\nreturn Strip(kpval)                    /*@ KEYPHRS                   */\n/*\n.  ----------------------------------------------------------------- */\nNOVALUE:                               /*@                           */\n   say exec_name \"raised NOVALUE at line\" sigl\n   say \" \"\n   say \"The referenced variable is\" condition(\"D\")\n   say \" \"\n   zsigl = sigl\n   signal SHOW_SOURCE                  /*@ NOVALUE                   */\n/*\n.  ----------------------------------------------------------------- */\nSHOW_SOURCE:                           /*@                           */\n   call DUMP_QUEUE                     /* Spill contents of stacks  -*/\n   if sourceline() <> \"0\" then         /* to screen                  */\n      say sourceline(zsigl)\n   rc =  trace(\"?R\")\n   nop\n   exit                                /*@ SHOW_SOURCE               */\n/*\n.  ----------------------------------------------------------------- */\nSS: Procedure                          /*@ Show Source               */\n   arg  ssbeg  ssend  .\n   if ssend = \"\" then ssend = 10\n   if \\datatype(ssbeg,\"W\") | \\datatype(ssend,\"W\") then return\n   ssend = ssbeg + ssend\n   do ssii = ssbeg to ssend ; say Strip(sourceline(ssii),'T') ; end\nreturn                                 /*@ SS                        */\n/*\n.  ----------------------------------------------------------------- */\nSWITCH: Procedure expose info          /*@                           */\n   arg kw\n   sw_val = Wordpos(kw,info) > 0       /* exists = 1; not found = 0  */\n   if sw_val then                      /* exists                     */\n      info = Delword(info,Wordpos(kw,info),1) /* remove it           */\nreturn sw_val                          /*@ SWITCH                    */\n/*\n.  ----------------------------------------------------------------- */\nSYNTAX:                                /*@                           */\n   errormsg = exec_name \"encountered REXX error\" rc \"in line\" sigl\":\",\n                        errortext(rc)\n   say errormsg\n   zsigl = sigl\n   signal SHOW_SOURCE                  /*@ SYNTAX                    */\n/*\n   Can call TRAPOUT.\n.  ----------------------------------------------------------------- */\nTOOLKIT_INIT:                          /*@                           */\n   address TSO\n   info = Strip(opts,\"T\",\")\")          /* clip trailing paren        */\n\n   parse source  sys_id  how_invokt  exec_name  DD_nm  DS_nm,\n                     as_invokt  cmd_env  addr_spc  usr_tokn\n\n   parse value \"\" with  tv  helpmsg  .\n   parse value 0   \"ISR00000  YES\"     \"Error-Press PF1\"    with,\n               sw.  zerrhm    zerralrm  zerrsm\n\n   if SWITCH(\"TRAPOUT\") then do\n      \"TRAPOUT\" exec_name parms \"(( TRACE R\" info\n      exit\n      end                              /* trapout                    */\n\n   if Word(parms,1) = \"?\" then call HELP /* I won't be back          */\n\n   \"QSTACK\" ; tk_init_stacks = rc      /* How many stacks?           */\n\n   parse value SWITCH(\"BRANCH\") SWITCH(\"MONITOR\") SWITCH(\"NOUPDT\") with,\n               branch           monitor           noupdt    .\n\n   parse value mvsvar(\"SYSNAME\") sysvar(\"SYSNODE\") with,\n               #tk_cpu           node          .\n\n   sw.nested    = sysvar(\"SYSNEST\") = \"YES\"\n   sw.batch     = sysvar(\"SYSENV\")  = \"BACK\"\n   sw.inispf    = sysvar(\"SYSISPF\") = \"ACTIVE\"\n\n   parse value KEYWD(\"TRACE\")  \"O\"    with   tv  .\n   tk_globalvars = \"exec_name  tv  helpmsg  sw.  zerrhm  zerralrm \",\n                   \"zerrsm  zerrlm  tk_init_stacks  branch  monitor \",\n                   \"noupdt\"\n\n   call LOCAL_PREINIT                  /* for more opts             -*/\n\nreturn                                 /*@ TOOLKIT_INIT              */\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VI": {"ttr": 1793, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x07\\x01 \\x11\\x9f\\x01 \\x11\\x9f\\x10Q\\x00\\xdb\\x00\\xdb\\x00\\x00\\xd1\\xe3\\xe4\\xd9\\xd5\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-04-28T00:00:00", "modifydate": "2020-04-28T10:51:07", "lines": 219, "newlines": 219, "modlines": 0, "user": "JTURNER"}, "text": "/* REXX */\n/**************************************************/\n/* VSAM LISTCAT FORMATTED IN ISPF                 */\n/**************************************************/\nIF SYSVAR(SYSISPF) = 'NOT ACTIVE' THEN DO\n   SAY 'ISPF must be active to use the VI dialog.'\n   EXIT\nEND\nARG DSNAME\nIF DSNAME = ' ' THEN DO\n   SAY 'Please enter a VSAM data set name:'\n   PULL DSNAME\nEND\nTDSN = STRIP(DSNAME,,'''')\nSTATUS=SYSDSN(''''TDSN'''')\nIF STATUS /= 'OK' THEN DO\n /* SAY TDSN \"NOT FOUND\" */\n    zedsmsg = 'NOT CATALOGED'\n    zedlmsg = 'The specified data set is not catalogued.'\n    \"ISPEXEC SETMSG MSG(ISRZ001)\"\n    EXIT\nEND\nX=OUTTRAP('CLS.')\n\"LISTC EN('\"TDSN\"') ALL\"\nX=OUTTRAP('OFF')\nIF POS('NONVSAM',CLS.1) /= 0 THEN DO\n /* SAY TDSN \"IS NOT A VSAM DATASET\" */\n    zedsmsg = 'ERROR: NONVSAM'\n    zedlmsg = 'The VI dialog neither supports nor processes non-VSAM data sets.'\n    \"ISPEXEC SETMSG MSG(ISRZ001)\"\n    EXIT\nEND\nIF POS('USERCATALOG',CLS.1) /= 0 THEN DO\n /* SAY TDSN \"CAN'T HANDLE CATALOGS\" */\n    zedsmsg  = 'ERROR: CATALOG'\n    zedlmsg = 'The VI dialog neither supports nor processes VSAM catalogs.'\n    \"ISPEXEC SETMSG MSG(ISRZ001)\"\n    EXIT\nEND\nIF POS('INDEX',CLS.1) /= 0 THEN INDEX = 'Y'\nCDATE = SUBSTR(CLS.4,53,8)\nEDATE = SUBSTR(CLS.5,53,8)\n\n/* CSC date mod  */\nyyddd = Substr(cdate,3,2)||Substr(cdate,6,3)\nmmyydd   = Rxdate(5,yyddd)\nyyyymmdd = Rxdate(S,mmyydd)\ncdate = Substr(yyyymmdd,1,4)||'/'||,\n        Substr(yyyymmdd,5,2)||'/'||,\n        Substr(yyyymmdd,7,2)\n\nyyddd = Substr(edate,3,2)||Substr(edate,6,3)\nIf yyddd = '00000' Then\n  edate = ''\nElse\n  Do\n    mmyydd   = Rxdate(5,yyddd)\n    yyyymmdd = Rxdate(S,mmyydd)\n    edate = Substr(yyyymmdd,1,4)||'/'||,\n            Substr(yyyymmdd,5,2)||'/'||,\n            Substr(yyyymmdd,7,2)\n  End\n/* CSC date mod */\n\nCATNME = ''\nSCLS = ''\nMCLS = ''\nDCLS = ''\nLG   = ''\nIUSE = ''\nIF POS('IN-CAT',CLS.2) = 6 THEN\n   CATNME = STRIP(WORD(CLS.2,3),B,' ')\nDO I=6 TO CLS.0\nIF POS('STORAGECLASS',CLS.I) = 8 THEN\nDO\n   WRKLNE = TRANSLATE(CLS.I,'   ','-()')\n   SCLS = WORD(WRKLNE,2)\n   MCLS = WORD(WRKLNE,4)\n   I = I + 1\n   WRKLNE = TRANSLATE(CLS.I,'   ','-()')\n   DCLS = WORD(WRKLNE,2)\nEND\nIF WORD(CLS.I,1) = 'RLSDATA' THEN\nDO\n   I = I + 1\n   WRKLNE = TRANSLATE(CLS.I,'   ','-()')\n   LG = WORD(WRKLNE,2)\n   I = I + 1\n   WRKLNE = TRANSLATE(CLS.I,'   ','-()')\n   IUSE = WORD(WRKLNE,7)\nEND\nIF POS('ATTRIBUTE',CLS.I) = 6 THEN DO\n   I = I + 1\n   IF POS('NOUPGRADE',CLS.I) = 8 | POS('UPGRADE',CLS.I) =8 THEN DO\n       PARSE VAR CLS.I OPTF\n       ITERATE\n   END\n   KLEN = STRIP(SUBSTR(CLS.I,25,8),,'-')\n   ALEN = STRIP(SUBSTR(CLS.I,54,7),,'-')\n   CISZ = STRIP(SUBSTR(CLS.I,114,5),,'-')\n   I = I + 1\n   RKP  = STRIP(SUBSTR(CLS.I,25,8),,'-')\n   MLEN = STRIP(SUBSTR(CLS.I,54,7),,'-')\n   CICA = STRIP(SUBSTR(CLS.I,114,5),,'-')\n   I = I + 1\n   IF POS('BUFND',CLS.I) /=0 THEN I = I + 1\n   IF POS('STRIPE-COUNT',CLS.I) /=0 THEN I = I + 1\n   IF POS('RECORDS/CI',CLS.I) /=0 THEN I = I + 1\n   IF POS('AXRKP',CLS.I) /=0 THEN I = I + 1\n   IF POS('VERSION-NUMBER',CLS.I) /=0 THEN I = I + 1\n   IF POS('ACT-DIC-TOKEN',CLS.I) /=0 THEN I = I + 1\n   TYPE = 'INDEXED'\n   IF POS('NONINDEX',CLS.I) /=0 THEN\n      TYPE = 'NONINDEXED'\n   IF POS('NUMBERED',CLS.I) /=0 THEN\n      TYPE = 'NUMBERED'\n   IF POS('LINEAR',CLS.I) /=0 THEN\n      TYPE = 'LINEAR'\n   IF POS(' IMBED',CLS.I) /=0 & INDEX = 'Y' THEN SEQ = 'Y'\n   PARSE VAR CLS.I OPT1 OPT2 OPT3 OPT4 OPT5 OPT6 OPT7 OPT8\n   I = I + 1\n   IF POS('NONINDEX',CLS.I) /=0 THEN\n      TYPE = 'NONINDEXED'\n   IF POS('NUMBERED',CLS.I) /=0 THEN\n      TYPE = 'NUMBERED'\n   IF POS('LINEAR',CLS.I) /=0 THEN\n      TYPE = 'LINEAR'\n   IF POS(' IMBED',CLS.I) /=0 & INDEX = 'Y' THEN SEQ = 'Y'\n   IF POS('STATISTIC',CLS.I) = 6 THEN\n      LEAVE\n   PARSE VAR CLS.I OPTA OPTB OPTC OPTD OPTE\n   IF OPTF /= 'OPTF' THEN OPTE = OPTF\n\n   LEAVE\nEND\nEND\nDO I=I TO CLS.0\nIF POS('STATISTIC',CLS.I) = 6 THEN DO\n   I = I + 1\n   RTOT = STRIP(SUBSTR(CLS.I,21,11),,'-')\n   CISP = STRIP(SUBSTR(CLS.I,54,7),,'-')\n   I = I + 1\n   RDEL = STRIP(SUBSTR(CLS.I,21,11),,'-')\n   CASP = STRIP(SUBSTR(CLS.I,54,7),,'-')\n   EXTS = STRIP(SUBSTR(CLS.I,87,3),,'-')\n   I = I + 1\n   RINT = STRIP(SUBSTR(CLS.I,21,11),,'-')\n   CIFR = STRIP(SUBSTR(CLS.I,58,3),,'-')\n   I = I + 1\n   RUPD = STRIP(SUBSTR(CLS.I,21,11),,'-')\n   CAFR = STRIP(SUBSTR(CLS.I,58,3),,'-')\n   I = I + 1\n   RRET = STRIP(SUBSTR(CLS.I,21,11),,'-')\n   LEAVE\nEND\nEND\nDO I=I TO CLS.0\nIF POS('ALLOCATION',CLS.I) = 6 THEN DO\n   I = I + 1\n   ATYP = 'cylinders:'\n   IF SUBSTR(CLS.I,29,3) = 'ACK' THEN\n   ATYP = 'tracks:'\n   IF SUBSTR(CLS.I,29,3) = 'ORD' THEN\n   ATYP = 'records:'\n   BTYP = ATYP\n   ARBA = STRIP(SUBSTR(CLS.I,50,11),,'-')\n   I = I + 1\n   SPRI = STRIP(SUBSTR(CLS.I,24,8),,'-')\n   URBA = STRIP(SUBSTR(CLS.I,50,11),,'-')\n   I = I + 1\n   SSEC = STRIP(SUBSTR(CLS.I,24,8),,'-')\n   LEAVE\nEND\nEND\nA = 1\nDO I=I TO CLS.0\nIF POS('INDEX',CLS.I) = 4 THEN LEAVE\nIF POS('VOLSER',CLS.I) = 8 THEN DO\n   VSER.A = STRIP(SUBSTR(CLS.I,26,6),,'-')\n   IF SEQ = 'Y' & A=1 THEN DO\n   ARBA = STRIP(SUBSTR(CLS.I,80,10),,'-')\n   EXTS = STRIP(SUBSTR(CLS.I,116,3),,'-')\n   END\n   A = A +1\nIF A = 2 THEN DO\n   I = I + 1\n   IF SEQ = 'Y' THEN DO\n   URBA = STRIP(SUBSTR(CLS.I,80,10),,'-')\n   I = I + 1\n   TRKS = STRIP(SUBSTR(CLS.I,59,2),,'-')\n   LEAVE\n   END\n   I = I + 1\n   TRKS = STRIP(SUBSTR(CLS.I,59,2),,'-')\nEND\nEND\nEND\nVOL1 = VSER.1\nIF VSER.2 /= 'VSER.2' THEN VOL2 = VSER.2\nIF VSER.3 /= 'VSER.3' THEN VOL3 = VSER.3\nATRK = ARBA/CISZ/CICA*TRKS\nUTRK = URBA/CISZ/CICA*TRKS\nUPER = UTRK/ATRK*100\nATRK = FORMAT(ATRK,,0)\nUTRK = FORMAT(UTRK,,0)\nUPER = FORMAT(UPER,,0)\nzedsmsg  = 'VSAM INFO     '\nzedlmsg  = 'VSAM INFO is distributed with the PDS TSO command package.'\n\"ISPEXEC SETMSG MSG(ISRZ001)\"\n\ndo while virc < 8\n  \"ISPEXEC DISPLAY PANEL(VI#1)\"\n  virc = rc\n  end\n\n/*  From Steve Kleeves, Makita USA Inc, CBT File 137  */\n/*  Mod  John Kalinich, CSC  */\n/*  With corrections and enhancements, William (Bill) Smith, US Steel */\n/*  Add SMS/RLS/Catalog, Jim Turner, Trident Services */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VI#1": {"ttr": 1798, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x015\\x00G\\x00\\x901\\x8f\\x01 \\x11\\x9f\\x10Q\\x00,\\x00\\x1a\\x00\\x00\\xd1\\xe3\\xe4\\xd9\\xd5\\xc5\\xd9@@@'", "ispf": {"version": "01.53", "flags": 0, "createdate": "1990-11-14T00:00:00", "modifydate": "2020-04-28T10:51:47", "lines": 44, "newlines": 26, "modlines": 0, "user": "JTURNER"}, "text": ")ATTR DEFAULT(%+_)\n  %   TYPE(TEXT)   INTENS(HIGH)  COLOR(WHITE) SKIP(ON)\n  +   TYPE(TEXT)   INTENS(LOW)   COLOR(TURQ) SKIP(ON)\n  !   TYPE(OUTPUT) INTENS(HIGH)  JUST(LEFT) CAPS(OFF)  COLOR(WHITE)\n  #   TYPE(OUTPUT) INTENS(HIGH)  JUST(LEFT) CAPS(OFF)  COLOR(YELLOW)\n  ?   TYPE(OUTPUT) INTENS(LOW)   JUST(LEFT) CAPS(OFF) COLOR(BLUE)\n  @   TYPE(OUTPUT) INTENS(LOW)   JUST(RIGHT) CAPS(OFF) COLOR(TURQ)\n  {   TYPE(OUTPUT) INTENS(LOW)   JUST(RIGHT) CAPS(OFF) COLOR(TURQ)\n  $   TYPE(TEXT)   INTENS(HIGH)  COLOR(BLUE)\n  ~   TYPE(OUTPUT) INTENS(LOW)   JUST(LEFT)  CAPS(OFF) COLOR(TURQ)\n  }   AREA(SCRL)   EXTEND(ON)\n)BODY EXPAND(\\\\)\n+-\\-\\-%VSAM Data Set Information+-\\-\\-\n%COMMAND ===>_ZCMD                                                             +\n}TXTAREA                                               \\ \\                     }\n)AREA TXTAREA\n$Data Set Name:!TDSN                                        +\n$Catalog Name: ~CATNME                                      +\n$General Data:                                 Current Allocation:\n+   Volume serials:         @VOL1  @VOL2  @VOL3  +Allocated trks:   @ATRK      +\n+   Type:               {TYPE      +              Allocated extents:@EXTS      +\n+   Ave record length:    @ALEN    +\n+   Max record length:    @MLEN    +          $Current Utilization:\n+   Key length:           @KLEN    +              Used trks:      @UTRK        +\n+   Relative key position:@RKP     +              Used percent:   @UPER        +\n+   CI size:              @CISZ    +\n+   CI freespace:         @CIFR    +          $Usage Data:                     +\n+   CA freespace:         @CAFR    +              Total records:  @RTOT        +\n+   1st extent?ATYP      +@SPRI    +              Records deleted:@RDEL        +\n+   Secondary?BTYP      + @SSEC    +              Records inserted:@RINT       +\n+   Creation date:      {CDATE     +              Records updated:@RUPD        +\n+   Expiration date:    {EDATE     +              Records retrieved:@RRET      +\n$RLS Data:                                      + CI splits:      @CISP        +\n+   In-Use:~IUSE       +LOG: ~LG                + CA splits:      @CASP        +\n$SMS Data:\n+   MGMTCLAS:~MCLS    + STORCLAS:~SCLS    + DATACLAS:~DCLS    +\n#OPTC           #OPTD           #OPTE           +\n#OPT1           #OPT2           #OPT3           #OPT4           #OPT5\n#OPT6           #OPT7           #OPT8           #OPTA           #OPTB\n)INIT\n  .HELP = VI#1H\n  &ZCMD = &Z\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "VI#1H": {"ttr": 1800, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x017\\x00\\x14\\x00\\x901\\x8f\\x01 \\x11\\x9f\\x10S\\x001\\x00\\x1a\\x00\\x00\\xd1\\xe3\\xe4\\xd9\\xd5\\xc5\\xd9@@@'", "ispf": {"version": "01.55", "flags": 0, "createdate": "1990-11-14T00:00:00", "modifydate": "2020-04-28T10:53:14", "lines": 49, "newlines": 26, "modlines": 0, "user": "JTURNER"}, "text": ")ATTR DEFAULT(%+_)\n  %   TYPE(TEXT)   INTENS(HIGH)  COLOR(WHITE) SKIP(ON)\n  +   TYPE(TEXT)   INTENS(LOW)   COLOR(TURQ) SKIP(ON)\n  !   TYPE(OUTPUT) INTENS(HIGH)  JUST(LEFT) CAPS(OFF)  COLOR(WHITE)\n  ?   TYPE(TEXT) INTENS(LOW)   JUST(LEFT) CAPS(OFF) COLOR(BLUE)\n  @   TYPE(OUTPUT) INTENS(LOW)   JUST(RIGHT) CAPS(OFF) COLOR(TURQ)\n  {   TYPE(OUTPUT) INTENS(LOW)   JUST(LEFT) CAPS(OFF) COLOR(TURQ)\n  $   TYPE(TEXT)   INTENS(HIGH)  COLOR(YELLOW)\n  # AREA(SCRL) EXTEND(ON)\n)BODY EXPAND(\\\\)\n+Tutorial \\-\\-%VSAM Dataset Information+-\\-\\ Tutorial\n%COMMAND ===>_ZCMD                                                             +\n#CODEAREA -----------------------------------------------------------------#\n)AREA CODEAREA\n+   Data Set Name:        ?Name of VSAM dataset\n+   Catalog Name:         ?Name of catalog dataset\n+   Volume serials:       ?Up to 3 volsers are displayed\n+   Type:                 ?INDEXED, NONINDEXED, NUMBERED, LINEAR\n+                         $KSDS     ESDS        RRDS      LDS\n+   Ave record length:    ?Average record length\n+   Max record length:    ?Maximum record length\n+   Key length:           ?Record key length\n+   Relative key position:?Relative key position\n+   CI size:              ?Control interval size\n+   CI freespace:         ?Control interval free space\n+   CA freespace:         ?Control area free space\n+   1st extent <type>:    ?First extent amount in TRKS/CYLS/RCDS\n+   Secondary <type>:     ?Secondary amount in TRKS/CYLS/RCDS\n+   Creation date:        ?Creation   date in the format:  yyyy/mm/dd\n+   Expiration date:      ?Expiration date in the format:  yyyy/mm/dd\n+   Allocated trks:       ?Number of tracks allocated\n+   Allocated extents:    ?Number of allocated DASD extents\n+   Used trks:            ?Number of used tracks\n+   Used percent:         ?Percent used\n+   Total records:        ?Total records in file\n+   Records deleted:      ?Number of records deleted from file\n+   Records inserted:     ?Number of records inserted into file\n+   Records updated:      ?Number of records updated in file\n+   Records retrieved:    ?Number of records retrieved from file\n+   CI splits:            ?Number of control interval splits\n+   CA splits:            ?Number of control area splits\n+   RLS data:             ?In-Use and LOG attributes for RLS\n+   SMS data:             ?SMS management, storage and data classes\n+   Attributes 1-13:      ?VSAM file attributes defined with IDCAMS\n)INIT\n  &ZCMD = &Z\n  &ZUP = VI#1H\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "VSAM": {"ttr": 1793, "alias": true, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x07\\x01 \\x11\\x9f\\x01 \\x11\\x9f\\x10Q\\x00\\xdb\\x00\\xdb\\x00\\x00\\xd1\\xe3\\xe4\\xd9\\xd5\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-04-28T00:00:00", "modifydate": "2020-04-28T10:51:07", "lines": 219, "newlines": 219, "modlines": 0, "user": "JTURNER"}}}}}, "SCRIPTOPTIONS": {"filename": "./CBT942/FILE942.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT942", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}