{"INMR01": {"INMLRECL": 80, "INMFNODE": "NODENAME", "INMFUID": "T311LBD", "INMTNODE": "X", "INMTUID": "Y", "INMFTIME": "20160602184042000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 117572, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 255, "INMBLKSZ": 32760, "INMRECFM": "VB", "INMDIR": 6, "INMDSNAM": "T311LBD.LIONEL.EXEC", "INMMEMBR": "T311LBD.LIONEL.EXEC", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 117572, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 117572, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"T311LBD.LIONEL.EXEC": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 32760, "DS1LRECL": 255, "DS1RECFM": "VB", "DS1KEYL": 0, "DS1OPTCD": 32, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 32760, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "160154", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x01,'", "DS1LSTAR": "b'\\x01\\x1c\\x05'", "DS1TRBAL": "b'\\x07N'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x17\\xa0\\x00\\x04\\x98\\x10\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x17\\xa0\\x00\\x04\\x98\\x10\\xd8'", "b\"X\\x9f\\x8f\\x88\\x00\\x00\\x0f\\x0e\\x00\\x08\\x0f'\\x00\\t\\x01y\"", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"TXT2RTF": {"ttr": 72705, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x00Y\\x01\\t2?\\x01\\x16\\x15O\\x100\\x04M\\x04?\\x00\\x00\\xe3\\xf3\\xf1\\xf1\\xd3\\xc2\\xc4@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "2009-11-19T00:00:00", "modifydate": "2016-06-02T10:30:59", "lines": 1101, "newlines": 1087, "modlines": 0, "user": "T311LBD"}, "text": "        /* --------------------  rexx procedure  -------------------- *\n         * Name:      txt2rtf                                         */\n         ver = \"1.13\"\n        /*                                                            *\n         * Function:  Convert a mainframe sequential file to an       *\n         *            RTF (rich text format) file that can then be    *\n         *            transferred to a workstation and opened in      *\n         *            any office word processing application.         *\n         *                                                            *\n         * Syntax:    %txt2rtf input output options                   *\n         *                                                            *\n         *             Where:                                         *\n         *                                                            *\n         *             input is the input data set name               *\n         *                   or dd:ddname                             *\n         *             output is the output data set name             *\n         *                    or dd:ddname                            *\n         *                                                            *\n         *             optional options                               *\n         *             CC                                             *\n         *                   this is a switch and if coded will cause *\n         *                   carriage control to be detected in this  *\n         *                   input file regardless of the DCB         *\n         *             NOCC                                           *\n         *                   this is a switch and if coded will cause *\n         *                   carriage control to NOT be detected.     *\n         *             NOCONFIRM                                      *\n         *                   this is a switch and if coded will cause *\n         *                   all confirmation message to be suppressed*\n         *             CONFIG dataset or DD:ddname                    *\n         *                  references a configuration file with      *\n         *                  txt2rtf keywords and parameters           *\n         *                                                            *\n         *                  syntax:                                   *\n         *                  one or more keywords with parameters on   *\n         *                  each line with no continuation supported  *\n         *                                                            *\n         *                  e.g.                                      *\n         *                  CC                                        *\n         *                  FONT 9                                    *\n         *                  MARGINS .8/.8.5.5                         *\n         *                                                            *\n         *                  Note: You can over-ride any value in the  *\n         *                        CONFIG using a keyword on the cmd.  *\n         *                                                            *\n         *             FONT size                                      *\n         *                  from 1 to nn where 72 is 1 inch           *\n         *             MARGINS left/right/top/bottom                  *\n         *             METRIC                                         *\n         *                   this is a switch and if coded will cause *\n         *                   measurements to be in centimeters        *\n         *             ORIENTATION Portrait or Landscape              *\n         *             PAPER size                                     *\n         *                   size is LETTER for 8.5 x 11              *\n         *                           LEGAL  for 11 x 14               *\n         *                           A4     for 8.27 x 11.7           *\n         *                           widthXheight (e.g. 4x6)          *\n         *             READONLY                                       *\n         *                   this is a switch and if coded will set   *\n         *                   the read-only flag in the rtf file       *\n         *             NORTFXLATE                                     *\n         *                   this is a switch and if coded prevent    *\n         *                   RTF Translation on for special characters*\n         *                   to that they will print in some charsets *\n         *                      backslash                             *\n         *                      curly bracket left                    *\n         *                      curly bracket right                   *\n         *                                                            *\n         * Customization:  Find *custom* for local customizations     *\n         *                                                            *\n         * Note: Carriage control processing is based on the CC or    *\n         *       NOCC keywords or based on the DCB of the input file. *\n         *                                                            *\n         * Author:    Lionel B. Dyck                                  *\n         *            Internet: Internet: lbdyck@gmail.com            *\n         *                                                            *\n         * History:                                                   *\n         *          2016-06-02 - Version 1.16                         *\n         *                     - Update from Larry Slaten for basl    *\n         *          2009-12-03 - Version 1.12                         *\n         *                     - Update from Mario Robitaille         *\n         *                       to report on non-zero returns        *\n         *          2008-12-01 - Version 1.11                         *\n         *                     - use quotes for x2c strings           *\n         *          2008-09-01 - 1.10 remove never executed \"exit\"s   *\n         *          2008-08-28 - 1.09 msgid correction                *  /*wls*/\n         *                     - compiled exec - fix msgid problem    *\n         *                     - uniform msgid                        *\n         *          2008-06-27 - 1.08 add options support ver         *  /*wls*/\n         *          2007-11-13 - 1.07 NLS support (see also XMITIPCU) *  /*wls*/\n         *                       use variables instead of special     *\n         *                       characters                           *\n         *                     - use hardcoded default values or      *\n         *                       use default values from xmitipcu     *\n         *                       (depending on the existence of the   *\n         *                       routine xmitipcu)                    *\n         *                     - support explicit execute of TXT2RTF  *\n         *                       by checking source and use of altlib *\n         *          2007-01-22 - 1.06 Correction for merge lines      *  /*wls*/\n         *          2006-03-09 - 1.05 from Billy Smith                *  /*wls*/\n         *                       allow CONFIG options to be overridden*  /*wls*/\n         *                       by command keyword usage             *\n         *          2006-02-24 - 1.04 from Billy Smith                *  /*wls*/\n         *                       added option to set line spacing     *  /*wls*/\n         *          2006-01-26 - 1.03                                 *\n         *                     - Correction for mach cc x'09'         *\n         *                       thx to Robert Charlesworth           *\n         *          2006-01-19 - 1.02                                 *\n         *                     - Correct + CC if overlay is shorter   *\n         *                       than the primary record              *\n         *          2004-02-05 - 1.01                                 *\n         *                     - Add font name local customization    *\n         *          2004-02-05 - 1.00                                 *\n         *                     - Change to version 1.00               *\n         *                     - Correct font name (thx to wordpad)   *\n         *          2004-01-24 - 0.16                                 *\n         *                     - Correct overlay processing (+) if    *\n         *                       line 2 is longer than line 1         *\n         *          2004-01-23 - 0.15                                 *\n         *                     - Correct processing for overlay +     *\n         *          2004-01-12 - 0.14                                 *\n         *                     - Correct NOXLATE to NORTFXLATE        *\n         *          2003-12-30 - 0.13                                 *\n         *                     - Correct test for readonly (rop) var  *\n         *          2003-10-09 - 0.12                                 *\n         *                     - Correct bug if margins but no left   *\n         *                       margin coded                         *\n         *          2003-09-30 - 0.11                                 *\n         *                     - Correct bug if 1st line is just 1    *\n         *                     - Detect recursive configs             *\n         *          2003-09-23 - 0.10                                 *\n         *                     - Add msgid to messages                *\n         *          2003-09-17 - 0.09                                 *\n         *                     - Add improved messages                *\n         *          2003-09-16 - 0.08                                 *\n         *                     - Add ISPF Panel                       *\n         *          2003-09-13 - 0.07                                 *\n         *                     - fix DD: for input and output         *\n         *          2003-09-11 - 0.06                                 *\n         *                     - fix DCB detection routine            *\n         *                     - if first line is a + (no space) then *\n         *                       ignore it                            *\n         *          2003-09-11 - 0.05                                 *\n         *                     - add NOCONFIRM option                 *\n         *                     - Get CC option from DCB and override  *\n         *                       with CC/NOCC                         *\n         *          2003-09-11 - 0.04                                 *\n         *                     - Overwrite output file if it exists   *\n         *          2003-09-11 - 0.03                                 *\n         *                     - Correct parameter parsing            *\n         *          2003-09-11 - 0.02                                 *\n         *                     - Correct output space alloc and       *\n         *                       support output pds member            *\n         *                     - Improve reporting                    *\n         *                     - Correct carriage control processing  *\n         *                     - Allow ORIENT as an abbreviation of   *\n         *                       ORIENTATION                          *\n         *          2003-09-09 - 0.01                                 *\n         *                     - Cleanup (add CONFIG)                 *\n         *          2003-09-08 - Creation                             *\n         *                                                            *\n         * ---------------------------------------------------------- */\n         _x_ = sub_init() ;\n         parse arg options\n\n         if abbrev(options,\"VER\") = 1,\n         then do ;\n                    /* ----------------------------- *\n                     * Get Current Version           *\n                     * ----------------------------- */\n                     return ver\n              end;\n\n        /* -------------------------------------------------------- *\n         * Local Customization *custom*                             *\n         *  Change FONTNAME from Courier New to Courier if you like *\n         * -------------------------------------------------------- */\n         fontname = \"Courier New\"\n\n         if length(options) > 0 then\n            parse arg input output options\n         else do\n              if sysvar('sysispf') = \"ACTIVE\" ,\n                 then do\n                        if rexxdsn /= \"?\" ,\n                        then \"altlib   act appl(exec) da('\"rexxdsn\"')\"\n                        call do_ispf\n                        if rexxdsn /= \"?\" ,\n                        then \"altlib deact appl(exec)\"\n                        exit 0\n                      end\n                 else signal do_syntax\n              end\n\n         Start:\n         if length(input) = 0 then do\n            say msgid \"Error: No input file specified.\"\n            say msgid \" try again....\"\n            signal do_syntax\n            end\n\n         if length(output) = 0 then do\n            say msgid \"Error: No output file specified.\"\n            say msgid \" try again....\"\n            signal do_syntax\n            end\n\n         input  = translate(input)\n         output = translate(output)\n\n         options = strip(options)\n         save_options = options\n\n        call set_defaults\n\n        /* ---------------------------- *\n         * Find DCB of the Input for CC *\n         * ---------------------------- */\n         if left(input,3) = \"DD:\" then do\n            parse value input with \"DD:\"indd\n            call listdsi indd \"FILE\"\n            end\n            else\n            call listdsi input\n         if right(sysrecfm,1) = \"A\" then do_cc = 1\n         if right(sysrecfm,1) = \"M\" then do_cc = 1\n\n        /* ----------------------------- *\n         * Now process the other options *\n         * ----------------------------- */\n         do while length(options) > 0\n            uoptions = translate(options)\n            Select\n              When word(uoptions,1) = \"CONFIG\" then do\n                   config  = word(uoptions,2)\n                   if wordpos(config,configs) = 0  then\n                      configs = configs config\n                   else do\n                      say msgid \"Error: Recursive CONFIG files\"\n                      say msgid \"       Config\" config \"already specified.\"\n                      say msgid \"Exiting....\"\n                      exit 8\n                      end\n                   call add_log \"CONFIG\" config\n                   options = delword(options,1,2)\n                   drop cfg.\n                   if left(config,3) = \"DD:\" then do\n                      parse value config with \"DD:\"cdd\n                      \"Execio * diskr\" cdd \"(finis stem cfg.\"\n                      end\n                   else do\n                        \"Alloc f(\"rtfdd\") shr reuse ds(\"config\")\"\n                        \"Execio * diskr\" rtfdd \"(finis stem cfg.\"\n                        \"Free  f(\"rtfdd\")\"\n                        end\n                   do ic = 1 to cfg.0\n                   /* reverse concatenation of options to allow\n                      individual parameters to follow and override\n                      DD:CONFIG parms\n                      options = strip(options cfg.ic) wlsb */\n                      options = strip(cfg.ic)\" \"options\n                      end\n                   uoptions = translate(options)\n                   end\n              When word(uoptions,1) = \"CC\" then do\n                   do_cc   = 1\n                   call add_log \"CC\"\n                   options = delword(options,1,1)\n                   end\n              When word(uoptions,1) = \"NOCC\" then do\n                   do_cc   = null\n                   call add_log \"NOCC\"\n                   options = delword(options,1,1)\n                   end\n              When word(uoptions,1) = \"FONT\" then do\n                   font = word(uoptions,2)\n                   call add_log \"FONT\" font\n                   options = delword(options,1,2)\n                   end\n              When word(uoptions,1) = \"MARGINS\" then do\n                   margins = word(uoptions,2)\n                   call add_log \"MARGINS\" margins\n                   options = delword(options,1,2)\n                   parse value margins with wleft\"/\"wright\"/\"wtop\"/\"wbottom\n                   if wleft   <> null then left   = wleft\n                   if wright  <> null then right  = wright\n                   if wtop    <> null then top    = wtop\n                   if wbottom <> null then bottom = wbottom\n                   end\n              When abbrev(\"ORIENTATION\",word(uoptions,1),6) = 1 then do\n                   orient  = word(uoptions,2)\n                   call add_log \"ORIENTATION\" orient\n                   options = delword(options,1,2)\n                   end\n              When word(uoptions,1) = \"PAPER\" then do\n                   paper   = word(uoptions,2)\n                   call add_log \"PAPER\" paper\n                   options = delword(options,1,2)\n                   end\n              When word(uoptions,1) = \"METRIC\" then do\n                   metric = \"C\"\n                   call add_log \"METRIC\"\n                   options = delword(options,1,1)\n                   end\n              When word(uoptions,1) = \"READONLY\" then do\n                   readonly = \"YES\"\n                   call add_log \"READONLY\"\n                   options = delword(options,1,1)\n                   end\n              When abbrev(\"NORTFXLATE\",word(uoptions,1),6) = 1 then do\n                   xlate = \"OFF\"\n                   call add_log \"NORTFXLATE\"\n                   options = delword(options,1,1)\n                   end\n              When abbrev(\"NOCONFIRM\",word(uoptions,1),3) = 1 then do\n                   confirm = \"OFF\"\n                   call add_log \"NOCONFIRM\"\n                   options = delword(options,1,1)\n                   end\n              When word(uoptions,1) = \"LINESPACE\" then do                /*wls*/\n                   linespace  = word(uoptions,2)                         /*wls*/\n                   call add_log \"LINESPACE\" linespace                    /*wls*/\n                   options = delword(options,1,2)                        /*wls*/\n                   end                                                   /*wls*/\n              Otherwise do\n                        say msgid \"Error: Invalid option found\" ,\n                             word(options,1)\n                        say msgid \"Exiting.....\"\n                        exit 8\n                        end\n              end\n            end\n\n        /* -------------------------- *\n         * Now read in the input data *\n         * -------------------------- */\n         if left(input,3) = \"DD:\" then do\n            parse value input with \"DD:\"inddn\n            \"Execio * diskr\" inddn \"(Finis stem in.\"\n            end\n         else do\n              \"Alloc f(\"rtfdd\") ds(\"input\") shr reuse\"\n              \"Execio * diskr\" rtfdd \"(Finis stem in.\"\n              \"Free  f(\"rtfdd\")\"\n              end\n         input_count = in.0\n\n        /* ------------------------ *\n         * Write out the RTF Header *\n         * ------------------------ */\n           call do_rtf_head\n           n = out.0\n\n        /* ----------------------------- *\n         * Now process each input record *\n         * ----------------------------- */\n           do i = 1 to in.0\n              in.i = strip(in.i,'t')\n              call do_rtf\n              end\n           n = out.0\n           do i = 1 to in.0\n              if left(in.i,2) = x2c(\"FF FF\") then iterate\n              n = n + 1\n              out.n = in.i\n              if max < length(in.i) then\n                 max = length(in.i)\n              end\n           out.0 = n\n\n        /* ------------------------- *\n         * Write out the RTF Trailer *\n         * ------------------------- */\n           call do_rtf_end\n           output_count = out.0\n\n        /* -------------------------------- *\n         * Report on our processing options *\n         * -------------------------------- */\n         if confirm = null then do\n            call add_msg \"Starting TXT2RTF version\" ver \"processing.\"\n            call add_msg \" \"\n            call add_msg \"User specified options:\"\n            do lc = 1 to opt.0\n               call add_msg opt.lc\n               end\n            call add_msg \" \"\n            call add_msg \"Processing report:\"\n            call add_msg \"Input:   \" input\n            call add_msg \" records:\" input_count\n            call add_msg \"Output:  \" output\n            call add_msg \" records:\" output_count\n            if cc_type <> null then\n               call add_msg \"Carriage:\" cc_type\n            call add_msg \"Font:    \" font/2\n            call add_msg \"Margins: \" margins_report\n            if left(orient,1) = \"L\" then\n               call add_msg \"Orient:   Landscape\"\n            else\n                call add_msg \"Orient:   Portrait\"\n            call add_msg \"Paper:   \" paper pmeasure\n            call add_msg \"Linespace:   \" linespace                       /*wls*/\n            if readonly = \"YES\" then\n               call add_msg \"ReadOnly: Yes\"\n            if xlate = null then\n               call add_msg \"XLATE:    Yes\"\n            else\n               call add_msg \"XLATE:    No\"\n            call add_msg \" \"\n            end\n\n        /* ----------------------------- *\n         * Now write out the output file *\n         * ----------------------------- */\n          if left(output,3) = \"DD:\" then do\n             parse value output with \"DD:\"ddn\n             \"Execio * diskw\" ddn \"(Finis stem out.\"\n             if rc > 0 then do\n                if rc = 20 then do\n                   say msgid \" \"\n                   say msgid \"severe error returned by EXECIO\"\n                   say msgid \"Exiting....\"\n                   exit 8\n                   end\n                else call add_msg \"Output data has been written\" ,\n                                  \"but some data truncation has\" ,\n                                  \"occurred due to a too small\" ,\n                                  \"lrecl.\"\n                end\n             end\n         else do\n         if pos(\"(\",output) > 0 then do\n                                     dir = \"dir(15)\"\n                                     if max < 256 then max = 256\n                                     end\n                                else dir = null\n         if dir = null then disp = \"new\"\n         if sysdsn(output) = \"DATASET NOT FOUND\"\n             then disp = \"new\"\n             else disp = \"shr\"\n              \"Alloc f(\"rtfdd\") ds(\"output\") reuse\",\n                    \"spa(90,90) tr recfm(v b) lrec(\"max+8\")\" ,\n                    \"blksize(23998)\" dir disp\n              \"Execio * diskw\" rtfdd \"(Finis stem out.\"\n              \"Free  f(\"rtfdd\")\"\n          end\n\n          if ispf = 1 then do\n             call add_msg \" \"\n             call add_msg \"Completed processing\" input \"to\" output\n             \"Alloc f(\"rtfdd\") new spa(1,1) tr recfm(v b) lrecl(80)\" ,\n                    \"ds(\"rtfdd\")\"\n             \"Execio * diskw\" rtfdd \"(finis stem log.\"\n             Address ISPExec \"Browse Dataset(\"rtfdd\")\"\n             call msg 'off'\n             \"Del\" rtfdd\n             call msg 'on'\n             return\n             end\n          else do\n               do i = 1 to log.0\n                  say msgid log.i\n                  end\n               end\n          exit 0\n\n        /* ----------------------------------------------------- *\n         * Do_RTF_Head Routine.                                  *\n         * put out rtf headers                                   *\n         * -------------------------                             *\n         * The paperw/etc numbers are in twips. 1440 per inch.   *\n         * ----------------------------------------------------- */\n         Do_RTF_Head:\n\n        /* --------------------------------------------------------- *\n         * Convert centimeters to inches if needed                   *\n         * --------------------------------------------------------- */\n         if metric = \"C\" then do\n            top    = top * 0.3937\n            bottom = bottom * 0.3937\n            left   = left * 0.3937\n            right  = right * 0.3937\n            marg   = \"Centimeters\"\n            end\n         else marg = \"Inches\"\n\n         margins_report = \"Left:\" left \"Right:\" right ,\n                          \"Top:\" top \"Bottom:\" bottom ,\n                          \"in\" marg\n         left   = trunc(left   * 1440)\n         right  = trunc(right  * 1440)\n         top    = trunc(top    * 1440)\n         bottom = trunc(bottom * 1440)\n         orient = strip(translate(orient))\n\n        /* ----------------------------------------------------- *\n         * setup the paper size values (width/height)            *\n         * ----------------------------------------------------- */\n         paper = strip(translate(paper))\n         if length(paper) = 0 then paper = translate(paper_size)\n         width    = 12240\n         pmeasure = \" \"\n         Select\n            when pos(\"X\",paper) > 0 then do\n                 parse value paper with w \"X\" h\n                 paper = \"Width\" w \"by Height\" h\n                 if metric = \"C\" then do\n                    h = h * 0.3937\n                    w = w * 0.3937\n                    pmeasure = \"in Centimeters\"\n                    end\n                 height = h * 1440\n                 width  = w * 1440\n                 if pos('.',height)> 0 then\n                    parse value height with height '.' .\n                 if pos('.',width) > 0 then\n                    parse value width with width '.' .\n                 end\n            when abbrev(\"LETTER\",paper,3) = 1 then height = 15840\n            when abbrev(\"LEGAL\",paper,3) = 1 then height = 20160\n            When paper = \"LTR\" then height = 15840\n            When paper = \"LGL\" then height = 20160\n            When paper = \"A4\"  then do\n                 width  = 11908\n                 height = 16833\n                 end\n            otherwise do\n                      if strip(paper) <> null then\n                      call add_msg \"Invalid paper size:\" paper ,\n                                \"default Letter used.\"\n                      height = 15840\n                      end\n            end\n\n         n = out.0 + 1\n         _out_ = \"\"brcl\n         _out_ = _out_\"\"basl\"rtf1\"basl\"ansi\"basl\"ansicpg1252\"\n         _out_ = _out_\"\"basl\"deff0\"basl\"deflang1033\"basl\"deftab720\"\n         out.n = _out_ ; _out_ = \"\"\n         n     = n + 1\n         _out_ = \"\"brcl\n         _out_ = _out_\"\"basl\"fonttbl\"basl\"f0\"basl\"fmodern\"\n         _out_ = _out_\"\"basl\"fprq1\"basl\"fcharset0\" fontname\";\"brcr\n         out.n = _out_ ; _out_ = \"\"\n         if left(orient,1) = \"L\" then do\n             n      = n + 1\n             out.n  = \"\"basl\"landscape\"\n             h      = width\n             width  = height\n             height = h\n             end\n         n     = n + 1\n         out.n = basl\"paperw\"width\"\"basl\"paperh\"height\"\"basl\"horzdoc\"\n         n     = n + 1\n         _out_ = basl\"margl\"left\"\"basl\"margr\"right\n         _out_ = _out_\"\"basl\"margt\"top\"\"basl\"margb\"bottom\n         out.n = _out_ ; _out_ = \"\"\n         n     = n + 1\n         /* font is in 1/2 points thus 18 = 9 points */\n         font = font*2\n         out.n = \"\"basl\"pard\"basl\"plain\"basl\"f0\"basl\"fs\"trunc(font)\n         Select                                                          /*wls*/\n            when linespace = 1 then nop                                  /*wls*/\n            when linespace = 0 then do                                   /*wls*/\n                    out.n = out.n\"\"basl\"sl\"                              /*wls*/\n                    out.n = out.n\"-\"trunc(font)*10                       /*wls*/\n                    out.n = out.n\"\"basl\"slmult0\"                         /*wls*/\n                 end                                                     /*wls*/\n            otherwise do                                                 /*wls*/\n                    out.n = out.n\"\"basl\"sl\"                              /*wls*/\n                    out.n = out.n\"\"trunc(linespace*240)                  /*wls*/\n                    out.n = out.n\"\"basl\"slmult1\"                         /*wls*/\n            end                                                          /*wls*/\n         end                                                             /*wls*/\n         if readonly = \"YES\" then do\n            n     = n + 1\n            out.n = \"\"basl\"annotprot\"\n            end\n         out.0 = n\n         return\n\n        /* ----------------------------------------------------- *\n         * Do_RTF Routine                                        *\n         * setup rtf record                                      *\n         *                                                       *\n         * If Do_CC  = 1 then:                                   *\n         *  1 in column 1 gets page eject                        *\n         *    except for the first record in the file            *\n         *  0 in column 1 gets space 1 line                      *\n         *  - in column 1 gets space 2 lines                     *\n         *  + in column 1 gets data merged into previous line    *\n         *  other in col 1 treated as a 0                        *\n         * ----------------------------------------------------- */\n         Do_RTF:\n         /* ----------------------------------------------------- *\n          * convert                                               *\n          *   backslash  curly-bracket-left  curly-bracket-right  *\n          *     so they will print                                *\n          * ----------------------------------------------------- */\n         if xlate = null then do\n            Call RTFXlate in.i\n            in.i = strout\n            end\n\n         /* - insert the RTF control */\n         if do_cc = 1 then do\n         if cc_type = null then do\n            if pos(left(in.i,1),\"01-+ \") > 0 then\n               cc_type = \"ASA\"\n            if pos(left(in.i,1),x2c(\"89 8B 11 13 19 1B\")) > 0 then\n               cc_type = \"Machine\"\n            end\n         Select\n            when left(in.i,1) = \"1\" then do\n                 if i > 1 then\n                    in.i = \"\"basl\"page\" substr(in.i,2)\n                 else\n                    in.i = substr(in.i,2)\n                 if length(in.i) = 0 then in.i = \" \"\n                 end\n            when left(in.i,1) = \"0\" then\n                 in.i = \"\"basl\"line\"basl\"par\" substr(in.i,2)\n            when left(in.i,1) = \"-\" then\n                 in.i = \"\"basl\"line\"basl\"line\"basl\"par\" substr(in.i,2)\n            when left(in.i,1) = \"+\" then do\n                 ip = i - 1\n                 if ip > 0 then do\n                    parse value in.ip with rtftag i1\n                    l1 = length(i1)\n                    i2 = substr(in.i,2)\n                    l1 = max(l1,length(i2))\n                    if i1 <> i2 then\n                       i1 = left(i1,l1,' ')\n                       do c = 1 to l1\n                          c1 =  substr(i2,c,1)\n                          if substr(i1,c,1) = \" \" then\n                             i1 = overlay(c1,i1,c)\n                          end\n                    in.ip = rtftag i1\n                    end\n                 in.i = x2c(\"FF FF\")\n                 end\n            when left(in.i,1) = \" \" then\n                 in.i = \"\"basl\"par\" substr(in.i,2)\n        /* --------------------------------------------------------- *\n         * Process Machine Carriage Control - revised & corrected    *\n         * --------------------------------------------------------- */\n            when left(in.i,1) = '89'x then do\n                 if i > 1 then\n                    in.i = substr(in.i,2) \"\"basl\"page\"\n                 else\n                    in.i = substr(in.i,2)\"\"basl\"line\"\n                 end\n            when left(in.i,1) = '8B'x then\n                 if i > 1 then\n                    in.i = \"\"basl\"page\" substr(in.i,2)\n                 else\n                    in.i = substr(in.i,2)\"\"basl\"line\"\n            when left(in.i,1) = '09'x then\n                 in.i = substr(in.i,2) \"\"basl\"par\"\n            when left(in.i,1) = '11'x then\n                 in.i = substr(in.i,2) \"\"basl\"line\"basl\"par\"\n            when left(in.i,1) = '13'x then\n                 in.i = \"\"basl\"line\"basl\"par\" substr(in.i,2)\n            when left(in.i,1) = '19'x then\n                 in.i = substr(in.i,2) \"\"basl\"line\"basl\"line\"basl\"par\"\n            when left(in.i,1) = '1B'x then\n                 in.i = \"\"basl\"line\"basl\"line\"basl\"par\" substr(in.i,2)\n            otherwise in.i = \"\"basl\"par\" substr(in.i,2)\n            end\n         end\n         else in.i = \"\"basl\"par\" in.i\n         return\n\n        /* ----------------------------------------------------- *\n         * Do_RTF_End Routine                                    *\n         * put out rtf trailer                                   *\n         * ----------------------------------------------------- */\n         Do_RTF_End:\n         n = out.0 + 1\n         out.n = \"\"basl\"par \"brcr\"\"brcr\"\"\n         out.0 = n\n         return\n\n         /*\n          * =========================================================\n          * Routine:       RTFXlate    : Escapes characters within\n          *                            : text\n          * Arguments:     strData     : Data to scan\n          * Return:        strData     : Updated data\n          * Exposed vars:  (all)       : All\n          * ========================================================\n         */\n         RTFXlate:\n         PARSE ARG strData\n\n           /* ======================================================\n            * The characters we need to escape\n           */\n           strFrom = \"\"brcl\"\"brcr\"\"basl\"\"\n\n           /* ======================================================\n            * Loop, prefixing all above characters with a\n            * a backslash\n           */\n           strOut = \"\"\n           DO UNTIL numPos = 0\n             numPos =  Verify( strData, strFrom, \"Match\" )\n             IF numPos <> 0 THEN DO\n               strChar = Substr( strData, numPos, 1 )\n               PARSE VAR strData strLeft (strChar) strData\n               strOut = strOut\"\"strLeft\"\"basl\"\"strChar\n              END\n            END\n            strOut = strOut\"\"strData\n\n            /* =====================================================\n             * Return escaped data\n            */\n          RETURN strOut\n\n        /* ----------------------- *\n         * Do the ISPF Dialog here *\n         * ----------------------- */\n         Do_ISPF:\n         Address ISPExec\n         \"Vget (zapplid)\"\n         if zapplid <> \"T2R\" then do\n            \"Select CMD(\"myname\" \"options \") Newappl(T2R)\" ,\n                \"passlib scrname(TXT2RTF)\"\n            return 0\n            end\n         call set_defaults\n         ispf = 1\n         \"Vget (pinput poutput pcc pfont pleft pright ptop pbottom \" ,\n              \"ppaper rop porient plinespc) profile\"\n         if pfont   = null then pfont = font\n         if pleft   = null then pleft = left\n         if pright  = null then pright = right\n         if ptop    = null then ptop   = top\n         if pbottom = null then pbottom = bottom\n         if ppaper  = null then ppaper  = paper\n         if porient = null then porient = orient\n         if plinespc = null then plinespc = linespace                    /*wls*/\n         do forever\n            \"Display Panel(txt2rtf)\"\n            if rc > 0 then do\n               zedsmsg = \"Complete\"\n               zedlmsg = \"TXT2RTF dialog processing completed.\"\n               \"Setmsg msg(isrz001)\"\n               return 0\n               end\n            \"Vput (pinput poutput pcc pfont pleft pright ptop pbottom \" ,\n                  \"ppaper rop porient) profile\"\n            input  = pinput\n            output = poutput\n            options = \"Font\" pfont\n            if translate(pcc) = \"YES\" then\n               options = options \"CC\"\n            if translate(pcc) = \"NO\" then\n               options = options \"NOCC\"\n            if pleft <> null then\n               options = options \"MARGINS\" pleft\"/\"pright\"/\"ptop\"/\"pbottom\n            if porient <> null then\n               options = options \"ORIENT\" porient\n            if ppaper <> null then\n               options = options \"PAPER\" ppaper\n            if plinespc <> null then                                     /*wls*/\n               options = options \"LINESPACE\" plinespc                    /*wls*/\n            if translate(rop) = \"YES\" then\n               options = options \"READONLY\"\n            Address TSO\n            call start\n            Address ISPEXEC\n            end\n\n        /* ----------------------- *\n         * Display Syntax and Exit *\n         * ----------------------- */\n         Do_Syntax:\n         say msgid \" \"\n         say msgid left(\"*\",50,\"*\")\n         say msgid \"Syntax error in TXT2RTF\"\n         say msgid \" \"\n         say msgid \"The correct syntax is:\"\n         say msgid \" \"\n         say msgid \"%txt2rtf input_dsn output_dsn options:\"\n         say msgid \" \"\n         say msgid \"Valid options are:\"\n         say msgid \" CC or NOCC\"\n         say msgid \" NOCONFIRM\"\n         say msgid \" CONFIG dataset\"\n         say msgid \" or \"\n         say msgid \" CONFIG DD:ddname\"\n         say msgid \" FONT nn\"\n         say msgid \" MARGINS left/right/top/bottom\"\n         say msgid \" ORIENTATION PORTRAIT or LANDSCAPE\"\n         say msgid \" METRIC \"\n         say msgid \" PAPER LETTER or LEGAL or A4 or widthXheight\"\n         say msgid \" LINESPACE (0 thru 3 in 0.5 increments\"              /*wls*/\n         say msgid \" READONLY\"\n         say msgid \" NORTFXLATE\"\n         exit 8\n\n        /* ------------------- *\n         * Define our defaults *\n         * ------------------- */\n         Set_Defaults:\n         parse value \"\" with null readonly xlate out. ,\n                        paper_size font_size metric def_orient ,\n                        mtop mbottom mleft mright ,\n                        cc_type confirm do_cc log. opt. configs\n\n         _x_ = sub_codepage_set()\n         codepage = codepage_num\n\n         out.0  = 0\n         log.0  = 0\n         opt.0  = 0\n\n         if   mleft   = \"\" ,\n         then  left   = .5\n         else  left   = mleft\n         if   mright  = \"\" ,\n         then  right  = .5\n         else  right  = mright\n         if   mtop    = \"\" ,\n         then  top    = .5\n         else  top    = mtop\n         if   mbottom = \"\" ,\n         then  bottom = .5\n         else  bottom = mbottom\n         if font_size = \"\" ,\n         then font = 9          /* font size */\n         else font = font_size  /* font size */\n         if def_orient = \"\" ,\n         then orient = \"P\"\n         else orient = def_orient\n         linespace = \"1\"                                                 /*wls*/\n         if paper_size = \"\" ,\n         then paper  = \"LETTER\"\n         else paper  = \"\"paper_size\n\n         rtfdd  = \"RTF\"random(9999)\n         max    = 80\n\n         return\n\n        /* -------------------------- *\n         * Add Options to Options Log *\n         * -------------------------- */\n         Add_Log: procedure expose opt. ispf\n         parse arg msg\n         c = opt.0 + 1\n         opt.c = \">\" msg\n         opt.0 = c\n         return\n\n        /* -------------------------- *\n         * Add Message to Message Log *\n         * -------------------------- */\n         Add_Msg: procedure expose log. ispf\n         parse arg msg\n         c = log.0 + 1\n         log.c = msg\n         log.0 = c\n         return\n\nsub_init:\n  /* to get the correct name for MSGID don't use other cmds before */\n  parse source ,\n    rexxenv rexxinv rexxname rexxdd rexxdsn . rexxtype addrspc .\n\n  myname = rexxname\n  if myname = \"?\" ,\n  then do ;\n           myname = sysvar(\"sysicmd\")\n           if length(myname) = 0 ,\n           then  myname = sysvar(\"syspcmd\")\n       end;\n  msgid = left(myname\": \",9)\n\n return 0\n\n /* -------------------------------------------------------------- *\n  * set the codepage                                               *\n  * -------------------------------------------------------------- */\n\n sub_codepage_set: procedure expose ,\n   codepage_num codepage_chars ,\n         paper_size font_size metric def_orient ,\n         mtop mbottom mleft mright ,\n   excl basl diar brsl brsr brcl brcr hash\n\n   cc_excl          = x2c(\"5A\")\n   cc_brcl          = x2c(\"C0\")\n   cc_brcr          = x2c(\"D0\")\n      excl          = x2c(\"5A\")\n      basl          = x2c(\"E0\")  /* Larry Slaten */\n      brcl          = x2c(\"C0\")\n      brcr          = x2c(\"D0\")\n   SpecialChars     = x2c(\"5A E0 72 AD BD C0 D0 7B\")\n   codepage_num     = \"00037\"\n   codepage_chars   = \"\"SpecialChars\n   codepage_default = \"\"codepage_num\" \"codepage_chars\n   codepage_default = \"\"\n   encoding_default = \"WINDOWS-1252\"\n        sep_default = \",\"\n /* return 0 */ /* remove the comment to deactivate xmitipcu */\n\n /* check xmitipcu existence and get data                */\n /*   use a sub routine to continue processing if error  */\n cu = sub_check_xmitipcu() ;\n\n if datatype(cu) = \"NUM\" ,\n then do ;\n           nop ;\n      end;\n else do ;\n        /* ----------------------------------------------------- *\n         * Invoke XMITIPCU for local customization values        *\n         * ----------------------------------------------------- */\n        cu = xmitipcu()\n        if datatype(cu) = \"NUM\" then exit cu\n\n        /* ----------------------------------------------------- *\n         * parse the customization defaults to use them here     *\n         * ----------------------------------------------------- *\n         * parse the string depending on the used separator      *\n         * ----------------------------------------------------- */\n        if left(cu,4) = \"SEP=\" ,\n        then do ;\n                 parse var cu \"SEP=\" _s_ cu\n                 _s_val_d_ = c2d(_s_)\n                 _s_val_x_ = c2x(_s_)\n             end;\n        else     _s_ = left(strip(cu),1)\n\n        parse value cu with ,\n             (_s_) _center_ (_s_) zone (_s_) smtp ,\n             (_s_) vio (_s_) smtp_secure (_s_) smtp_address ,\n             (_s_) smtp_domain (_s_) text_enter ,\n             (_s_) sysout_class (_s_) from_center (_s_) writer ,\n             (_s_) mtop (_s_) mbottom (_s_) mleft (_s_) mright ,\n             (_s_) tcp_hostid (_s_) tcp_name (_s_) tcp_domain ,\n             (_s_) tcp_stack  ,\n             (_s_) from_default ,\n             (_s_) append_domain (_s_) zip_type (_s_) zip_load ,\n             (_s_) zip_hlq (_s_) zip_unit ,\n             (_s_) interlink (_s_) size_limit ,\n             (_s_) batch_idval (_s_) create_dsn_lrecl ,\n             (_s_) receipt_type (_s_) paper_size ,\n             (_s_) file_suf (_s_) force_suf ,\n             (_s_) mail_relay (_s_) AtSign ,\n             (_s_) ispffrom (_s_) fromreq ,\n             (_s_) char (_s_) charuse (_s_) disclaim (_s_) empty_opt ,\n             (_s_) font_size (_s_) def_orient ,\n             (_s_) conf_msg (_s_) metric ,\n             (_s_) descopt (_s_) smtp_method (_s_) smtp_loadlib ,\n             (_s_) smtp_server (_s_) deflpi (_s_) nullsysout ,\n             (_s_) default_hlq (_s_) msg_summary (_s_) site_disclaim ,\n             (_s_) zipcont (_s_) feedback_addr (_s_) rfc_maxreclen ,\n             (_s_) restrict_domain (_s_) log ,\n             (_s_) faxcheck (_s_) tpageend (_s_) tpagelen,\n             (_s_) from2rep (_s_) dateformat (_s_) validfrom ,\n             (_s_) systcpd (_s_) restrict_hlq (_s_) default_lang ,\n             (_s_) disable_antispoof (_s_) special_chars ,\n             (_s_) send_from (_s_) Mime8bit ,\n             (_s_) jobid (_s_) jobidl (_s_) custsym ,\n             (_s_) codepage_default ,\n             (_s_) encoding_default (_s_) encoding_check ,\n             (_s_) check_send_from ,\n             (_s_) check_send_to ,\n             (_s_) smtp_array ,\n             (_s_) txt2pdf_parms ,\n             (_s_) xmitsock_parms ,\n             (_s_) xmitipcu_infos ,\n             (_s_) antispoof (_s_)(_s_) cu_add\n                   /*   antispoof is always last         */\n                   /*   finish CU with double separator  */\n                   /*   cu_add for specials ...          */\n\n        /* ------------------------------------------------------ *\n         * Now remove any leading/trailing blanks from the values *\n         * ------------------------------------------------------ */\n         special_chars = special_chars\n         codepage_num  = strip(word(special_chars,1))\n         sp_chars      = strip(word(special_chars,2))\n         excl          = substr(sp_chars,1,1)\n         basl          = substr(sp_chars,2,1)\n         diar          = substr(sp_chars,3,1)\n         brsl          = substr(sp_chars,4,1)\n         brsr          = substr(sp_chars,5,1)\n         brcl          = substr(sp_chars,6,1)\n         brcr          = substr(sp_chars,7,1)\n         hash          = substr(sp_chars,8,1)\n         paper_size    = strip(paper_size)\n         font_size     = strip(font_size)\n         metric        = strip(metric)\n         def_orient    = strip(def_orient)\n         mtop          = strip(mtop)\n         mbottom       = strip(mbottom)\n         mleft         = strip(mleft)\n         mright        = strip(mright)\n      end;\n   return 0\n\n sub_check_xmitipcu:\n   signal on  syntax name sub_check\n   cu = xmitipcu() ;\n   signal off syntax\n   return cu\n\n sub_check:\n\n  signal off novalue        /* Ignore no-value variables within trap */\n  trap_errortext = 'Not Present'/* Error text available only with RC */\n  trap_condition = Condition('C')              /* Which trap sprung? */\n  trap_description = Condition('D')               /* What caused it? */\n  trap_rc = rc                          /* What was the return code? */\n  if datatype(trap_rc) = 'NUM' then     /* Did we get a return code? */\n     trap_errortext = Errortext(trap_rc)    /* What was the message? */\n  trap_linenumber = sigl                     /* Where did it happen? */\n  trap_line = sourceline(trap_linenumber)  /* What is the code line? */\n  trap_line = strip(space(trap_line,1,\" \"))\n\n  _code_ = 999\n  rcode = sub_specials(_code_)\n  if rcode < _code_ ,\n  then do ;\n           return rcode\n       end;\n\n  if value(contact) = \"CONTACT\" ,\n  then contact = \"your contact\"\n  ER. = ''                           /* Initialize error output stem */\n  ER.1 = ' '\n  ER.2 = 'An error has occurred in Rexx module:' myname\n  ER.3 = '   Error Type        :' trap_condition\n  ER.4 = '   Error Line Number :' trap_linenumber\n  ER.5 = '   Instruction       :' trap_line\n  ER.6 = '   Return Code       :' trap_rc\n  ER.7 = '   Error Message text:' trap_errortext\n  ER.8 = '   Error Description :' trap_description\n  ER.9 = ' '\n  ER.10= 'Please look for corresponding messages '\n  ER.11= '  and report the problem to 'contact'.'\n  ER.12= ' '\n  ER.0 = 12\n\n  do i = 1 to ER.0                   /* Print error report to screen */\n     say ER.i\n  end /*do i = 1 to ER.0*/\n\n  Exit 8\n\n  /* ------------------------------------------------------------ *\n   * special checks:                                              *\n   *    get the failing command                                   *\n   *    check whether processing can / should continue ...        *\n   * here: check existence of xmitipcu                            *\n   *       continue processing without messages                   *\n   *       use hardcoded values or xmitipcu values                *\n   * ------------------------------------------------------------ */\n sub_specials:\n  parse arg ret_str\n  _cmd_ = trap_line\n  parse var _cmd_ 1 . \"=\" _cmd_ \"/*\" .\n  parse var _cmd_ 1       _cmd_ \";\"  .\n  _cmd_ = space(translate(_cmd_,\"\",'\"'),0)\n  _cmd_upper_ = translate(_cmd_)\n  txt.0 = 0\n  select\n    when ( _cmd_upper_ = translate(\"XMITIPCU()\") ) ,\n      then do ;\n               ret_str = 4\n               txt.1 = \" \"\n               txt.2 = \"\"msgid\"... \"_cmd_\n               txt.3 = \"\"msgid\"... \"trap_rc\" - \"trap_errortext\n               txt.4 = \"\"msgid\"... processing continues ...\"\n               txt.5 = \" \"\n               txt.0 = 5\n               txt.0 = 0  /* deactivate msg lines */\n           end;\n    when ( _cmd_upper_ = translate(\"SOCKET('terminate')\") ) ,\n      then do ;\n               ret_str = 4\n               txt.1 = \" \"\n               txt.2 = \"\"msgid\"... \"_cmd_\n               txt.3 = \"\"msgid\"... \"trap_rc\" - \"trap_errortext\n               txt.4 = \"\"msgid\"... processing continues ...\"\n               txt.5 = \" \"\n               txt.0 = 5\n           end;\n    otherwise nop ;\n  end;\n           do i = 1 to txt.0\n              say txt.i\n           end\n  return ret_str\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT313/CBT.V500.FILE313.PDS/TXT2RTF.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT313/CBT.V500.FILE313.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}