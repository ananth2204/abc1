{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012921000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 1528436, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 20, "INMDSNAM": "CBT.V500.FILE836.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 1528436, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 1528436, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE836.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x1a\\x0c'", "DS1TRBAL": "b'\\x84\\xae'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x05\\xcc\\x00\\x08\\x05\\xce\\x00\\x04\\x00\\x1b'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00\\x17\\x01 \\x16\\x9f\\x01 \\x16\\x9f\"4\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf5\\xf0\\xf0@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "2020-06-17T00:00:00", "modifydate": "2020-06-17T22:34:17", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-500"}, "text": "REGULAR CBT TAPE - VERSION 500    FILE:  836\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT500.FILE836\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 86 MEMBERS COUNTED; CUMULATIVE SIZE IS 13,987 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   06/17/20    22:34:17    UTC-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FILE836": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00\\x11\\x01 \\x16\\x9f\\x01 \\x16\\x9f\"4\\x00\\x9d\\x00\\x9d\\x00\\x00\\xc3\\xc2\\xe3`\\xf5\\xf0\\xf0@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "2020-06-17T00:00:00", "modifydate": "2020-06-17T22:34:11", "lines": 157, "newlines": 157, "modlines": 0, "user": "CBT-500"}, "text": "//***FILE 836 is from Sam Golob and contains programs from CBT      *   FILE 836\n//*           File 830 (Xephon MVS Update issues from July 1987     *   FILE 836\n//*           thru December 1996) that have been fixed to run on    *   FILE 836\n//*           z/OS (currently at 2.3).  Original versions of the    *   FILE 836\n//*           programs have been modified so they work at whatever  *   FILE 836\n//*           z/OS level is the highest available.                  *   FILE 836\n//*                                                                 *   FILE 836\n//*           Since the support rights for these Xephon materials   *   FILE 836\n//*           were given to www.cbttape.org by Bob Thomas in 2008,  *   FILE 836\n//*           we are now taking advantage, by trying to get some    *   FILE 836\n//*           of these programs to run in a current environment.    *   FILE 836\n//*                                                                 *   FILE 836\n//*           We try to give credit to the original author, if      *   FILE 836\n//*           that person's name is available in the original file. *   FILE 836\n//*                                                                 *   FILE 836\n//*           email:  sbgolob@cbttape.org                           *   FILE 836\n//*                                                                 *   FILE 836\n//*       Description of programs or articles.                      *   FILE 836\n//*       In parentheses is the original member name in File 830.   *   FILE 836\n//*                                                                 *   FILE 836\n//*       ZTDM      - Rexx exec to restore the \"Bottom of Data\"     *   FILE 836\n//*       (S.Golob)   line to your member lists.  This is changed   *   FILE 836\n//*                   by some of the ISPF applications here.  But   *   FILE 836\n//*                   you can use this little exec to put it back.  *   FILE 836\n//*                   Or you can append it to the end of any exec   *   FILE 836\n//*                   which alters the \"bottom line\" marker, and    *   FILE 836\n//*                   set it back right.                            *   FILE 836\n//*                                                                 *   FILE 836\n//*       ASVTSCAN  - Program written by David Welch to summarize   *   FILE 836\n//*       (AC7AF2B8)  the information about Address Space totals    *   FILE 836\n//*                   that is found in the ASVT.                    *   FILE 836\n//*       ASVTSCAT  - TSO command with the same output.             *   FILE 836\n//*                                                                 *   FILE 836\n//*       CHKASVT   - A companion program to ASVTSCAN, which        *   FILE 836\n//*                   enumerates which address space numbers are    *   FILE 836\n//*                   not reusable.  From CBT Tape File 473.        *   FILE 836\n//*                   (from Scott Finlayson, thru Ron Robinson)     *   FILE 836\n//*                                                                 *   FILE 836\n//*       CLS       - Clear the screen and preserve terminal        *   FILE 836\n//*       (A315B7EF)  type.                                         *   FILE 836\n//*                                                                 *   FILE 836\n//*       DFRMM     - An introduction to RMM, what it does, and     *   FILE 836\n//*       (BEAEA3B9)  how it is set up.  This is not code, but      *   FILE 836\n//*                   a how-to narrative from Rem Perretta.         *   FILE 836\n//*                                                                 *   FILE 836\n//*       EDTDSPLY  - Package to display devices under Esoteric     *   FILE 836\n//*       (Q9802A5F)  Unit Names in ISPF.  (from Rem Perretta)      *   FILE 836\n//*                   Members:  EDTINF (Assembler program)          *   FILE 836\n//*                             EDTDSPLY (Rexx exec)                *   FILE 836\n//*                             EDTPAN01, EDTPAN02  (ISPF Panels)   *   FILE 836\n//*                                                                 *   FILE 836\n//*       ESVCSCAN  - Package from Rem Perretta to display          *   FILE 836\n//*       (YE55C023)  extended SVC tables under ISPF.               *   FILE 836\n//*                                                                 *   FILE 836\n//*       FINDSYSI  - Article by Roger Bowler about how to find     *   FILE 836\n//*       (C8B469E7)  Job-related info in MVS control blocks.       *   FILE 836\n//*                   (From Roger Bowler)                           *   FILE 836\n//*                                                                 *   FILE 836\n//*       GETDSN    - Look in TIOT to see if a dsname is allocated  *   FILE 836\n//*       (A08A5369)  to a ddname.  Uses QSAM and is callable.      *   FILE 836\n//*                   (Enhanced and IVP supplied by Willy Jensen.)  *   FILE 836\n//*                   (Original article anonymous)                  *   FILE 836\n//*                   GETDSNM - macro library in IEBUPDTE format    *   FILE 836\n//*                                                                 *   FILE 836\n//*       GETDEVNM  - Get Device Number....                         *   FILE 836\n//*       (S254E5EF)  Rexx exec with backup assembler program       *   FILE 836\n//*                   and panels.  You give it a disk volser, and   *   FILE 836\n//*                   it returns the device unit address and other  *   FILE 836\n//*                   nice information about the pack.              *   FILE 836\n//*                   (From Rem Perretta)                           *   FILE 836\n//*                   Members:  GETDEVNM (Rexx exec)                *   FILE 836\n//*                             GETUADDR (Assembler program)        *   FILE 836\n//*                             GETDEVP1 thru GETDEVP4 (panels)     *   FILE 836\n//*                                                                 *   FILE 836\n//*       LLASTATS  - From Mike Pekic via Bill Smith & Lionel Dyck  *   FILE 836\n//*                   Xephon MVS Update 186 - March 2002            *   FILE 836\n//*                   Produces LLA statistics via a REXX which      *   FILE 836\n//*                   scrapes the output of the undocumented        *   FILE 836\n//*                   operator command:  D LLA,STATISTICS           *   FILE 836\n//*                   Produces beautiful ISPF formatted output.     *   FILE 836\n//*                                                                 *   FILE 836\n//*       MORESYSI  - Article with more information about how to    *   FILE 836\n//*       (FEDEBB0D)  find information in MVS control blocks.       *   FILE 836\n//*                   (From Lynn Grant)                             *   FILE 836\n//*                                                                 *   FILE 836\n//*       PRSMINFO  - Package to display LPAR, processor, and       *   FILE 836\n//*       (D2F6A419)  IODF information.  From R.F.Perretta.         *   FILE 836\n//*                   Packaged and fixed to run on z/OS 2.3.        *   FILE 836\n//*                   (member is in TSO XMIT format)                *   FILE 836\n//*                                                                 *   FILE 836\n//*       RACFAUTH  - A program to give SPECIAL and/or OPERATIONS   *   FILE 836\n//*                   authority to a userid.                        *   FILE 836\n//*                                                                 *   FILE 836\n//*       RACROUTE  - An assembler program to show how much RACF    *   FILE 836\n//*       (David      authority that this userid has, to a dataset. *   FILE 836\n//*         Spiegel)  Accompanied by a REXX exec to use the program *   FILE 836\n//*                   to do a display.                              *   FILE 836\n//*                                                                 *   FILE 836\n//*       RGENR     - REXX to decompile RACF profiles and convert   *   FILE 836\n//*       (A6B797AC)  them to \"source\" TSO RACF commands.           *   FILE 836\n//*                                                                 *   FILE 836\n//*       SEND@     - TSO command to send a non-deletable message   *   FILE 836\n//*       (BC5C26EB)  to the operator console. (from Walter         *   FILE 836\n//*                   Wiedemann)                                    *   FILE 836\n//*                                                                 *   FILE 836\n//*       SHOWALOC  - TSO CLIST to display TSO dataset allocations  *   FILE 836\n//*       (F64BA4D1)  for a DDname.  (from Andrew Cahillane)        *   FILE 836\n//*                                                                 *   FILE 836\n//*       SMPEMOVE  - Instructions to move SMP/E zone entries from  *   FILE 836\n//*       (A162FCC4)  one VSAM file (zone) to another, and to       *   FILE 836\n//*                   combine two zones into one.                   *   FILE 836\n//*                   (From John Bradley)                           *   FILE 836\n//*                                                                 *   FILE 836\n//*       STRPATRN  - An assembler macro to test a string against   *   FILE 836\n//*                   a pattern.  (from Willy Jensen)               *   FILE 836\n//*                                                                 *   FILE 836\n//*       SUBCOMS   - REXX function to list all the names of        *   FILE 836\n//*       (ABA7F5DD)  environments available to REXX.               *   FILE 836\n//*                   (from Willy Jensen - Xephon contributor       *   FILE 836\n//*                    was anonymous)                               *   FILE 836\n//*                                                                 *   FILE 836\n//*       SUBSYSxx  - REXX and PANELS to display subsystem          *   FILE 836\n//*       (WAB4EB8B)  information under ISPF. (from R.F.Perretta)   *   FILE 836\n//*                                                                 *   FILE 836\n//*       SVCR****  - SVC Update Recording Table display (from      *   FILE 836\n//*       (XABB8414)  R.F.Perretta). Displays all SVCs that have    *   FILE 836\n//*                   been updated.                                 *   FILE 836\n//*                                                                 *   FILE 836\n//*       SWRID     - A more advanced version of USEID.  Assembles  *   FILE 836\n//*                   differently for z/OS 2.2 and lower, and for   *   FILE 836\n//*                   z/OS 2.3 and higher, with the 8-character     *   FILE 836\n//*                   TSO userid support.  Also includes a lot of   *   FILE 836\n//*                   WTO's to tell everybody what you did.         *   FILE 836\n//*                                                                 *   FILE 836\n//*       USEID     - (Xephon issue 33 August 2003)                 *   FILE 836\n//*                   TSO command to change your userid in two      *   FILE 836\n//*                   places, the ASXB and the ACEE (importantly)   *   FILE 836\n//*                   so that you can run jobs with someone else's  *   FILE 836\n//*                   authority.  You have to know the other id's   *   FILE 836\n//*                   password, however, to effect the change.      *   FILE 836\n//*                   (Fixed for 8-character TSO userid support.)   *   FILE 836\n//*                                                                 *   FILE 836\n//*       USEID22   - Pre-z/OS 2.3 version of USEID.                *   FILE 836\n//*                   (No 8-character TSO userid support.)          *   FILE 836\n//*                                                                 *   FILE 836\n//*       WHEREIS   - Program to determine where a module was       *   FILE 836\n//*       (AC7C7897)  loaded from.  This program does the job       *   FILE 836\n//*                   particularly well. (Fixed by Willy Jensen.)   *   FILE 836\n//*                   (Original contributor - Paul Poolsaar)        *   FILE 836\n//*                                                                 *   FILE 836\n//*       WTOPROG   - A multi-function WTO program.  Can be ysed    *   FILE 836\n//*       (BB2BDE14)  to force a job to wait, if other jobs are     *   FILE 836\n//*                   (or are not) present.  Or it may be used to   *   FILE 836\n//*                   stop a job until the operator answers \"Y\"     *   FILE 836\n//*                   to a WTOR message of your choice.             *   FILE 836\n//*                   (from R.F.Perretta)  (Works fine on z/OS 2.3) *   FILE 836\n//*                                                                 *   FILE 836\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ADJUST": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x08\\x01\\x10 o\\x01\\x100\\x8f#\\x16\\x00x\\x00\\x84\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2010-07-25T00:00:00", "modifydate": "2010-11-04T23:16:08", "lines": 120, "newlines": 132, "modlines": 0, "user": "SBGOLOB"}, "text": "Centering or right-adjusting print lines\n(was member BA46BFC0 in File 830)\n\nFew applications programmers write in Assembler these days, but\nthere are still plenty of reports printed by Assembler programs.\nFrom the quick-and-dirty utility to the complex DASD space\nmanager - every program prints some kind of report to tell you\nwhat it did.\n\nCentered or right-adjusted headings can make these reports much\nmore readable, but they are seldom used, because system\nprogrammers don't like spending a lot of time making their\nreports clear.\n\nWith the ADJUST macro, making centered or right-adjusted print\nlines is easy.\n\nThe macro is called like this:\n\nlabel     ADJUST addr,len,TYPE=type\n\n*    label is an optional label for the first generated\n     instruction.\n\n*    addr is the address of the print line.  It can be any label\n     that would be valid as the operand of an LA instruction, or\n     it can be a register (0, or 2-15), enclosed in parentheses.\n\n*    len is the length of the print line.  It can be any value\n     that would be valid as the operand of an LA instruction, or\n     it can be a register (1-15), enclosed in parentheses.\n\n*    type is the type of adjustment desired:  RIGHT for right\n     adjustment, or CENTER for centering.\n\nThe data to be adjusted is assumed to start at addr, with no\nleading blanks, and to be padded with blanks to length  len.\n\nThe macro destroys registers 0, 1, 14, and 15.\n\nHere is an example of using the ADJUST macro to centre a heading:\n\n         MVI   PRTLINE,C' '              BLANK OUT THE LINE\n         MVC   PRTLINE+1(L'PRTLINE-1),PRTLINE   ...\n         MVC   PRTLINE(11),=CL11'DASD REPORT'  MOVE HEADING\n         ADJUST  PRTLINE,L'PRTLINE,TYPE=CENTER   CENTER IT\n         .\nPRTLINE  DS    CL80                       PRINT LINE\n\n\nSOURCE CODE FOR THE ADJUST MACRO\n\n         MACRO\n&LABEL   ADJUST  &ADDR,&LEN,&TYPE=CENTER\n         LCLC  &STR                WORK VARIABLE\n         LCLC  &NDX                SHORT FORM OF &SYSNDX\n&NDX     SETC  '&SYSNDX'           ...\n         AIF   ('&TYPE' EQ 'CENTER' OR '&TYPE' EQ 'RIGHT').OKTYPE\n         MNOTE 8,'ADJUST: TYPE MUST BE ''CENTER'' OR ''RIGHT'''\n         MEXIT\n.OKTYPE  ANOP\n         AIF   ('&ADDR'(1,1) EQ '(').RADDR\n&LABEL   LA    R0,&ADDR            GET STRING ADDRESS\n         AGO   .OKADDR\n.RADDR   ANOP\n&STR     SETC  '&ADDR'(2,K'&ADDR-2)\n&LABEL   LR    R0,&STR  GET STRING ADDRESS\n.OKADDR  ANOP\n         AIF   ('&LEN'(1,1) EQ '(').RLEN\n         LA    R1,&LEN             GET STRING LENGTH\n         AGO   .OKLEN\n.RLEN    ANOP\n&STR     SETC  '&LEN'(2,K'&LEN-2)\n         LR    R1,&STR  GET STRING LENGTH\n.OKLEN   ANOP\n*   FIND THE REAL END OF THE STRING\n         AR    R1,R0               POINT TO THE LAST CHAR OF STRING\n         BCTR  R1,0                ...\n         LR    R15,R1              GET WORKING COPY OF ADDR\nLP1&NDX  CR    R15,R0              BACK AT THE BEGINNING?\n         BL    DONE&NDX            YES...STRING IS ALL BLANK\n         CLI   0(R15),C' '         IS THIS CHARACTER BLANK?\n         BNE   LN1&NDX             NO...REAL END OF STRING\n         BCTR  R15,0               YES...BACK UP ONE\n         B     LP1&NDX             AND TRY AGAIN\nLN1&NDX  CR    R15,R1              SAME AS END OF STRING?\n         BNL   DONE&NDX            YES...NO TRAILING BLANKS\n         AIF   ('&TYPE' NE 'CENTER').NOCENT\n.*   ADJUST NEW END FOR CENTERING\n         LA    R14,1(R1)           FIGURE LENGTH OF TRAILING BLANKS\n         SR    R14,R15             ...\n         SRL   R14,1               DIVIDE BY TWO\n         SR    R1,R14              ADJUST NEW END\n.NOCENT  ANOP\n*   COPY THE STRING, RIGHT TO LEFT, TO ITS NEW POSITION\nLP2&NDX  CR    R15,R0              BACK AT THE BEGINNING?\n         BL    LN2&NDX             YES...STOP COPYING\n         MVC   0(1,R1),0(R15)      MOVE ONE CHARACTER\n         BCTR  R15,0               BACK UP ONE INPUT CHARACTER\n         BCTR  R1,0                BACK UP ONE OUTPUT CHARACTER\n         B     LP2&NDX             DO IT AGAIN\n*   INSERT LEADING BLANKS IN STRING\nLN2&NDX  SR    R1,R15              R1 = NUMBER OF LEADING BLANKS\n         BNP   DONE&NDX            IF NONE, WE'RE ALL DONE\n         LR    R15,R0              R15 = ADDR OF START OF STRING\n         MVI   0(R15),C' '         INSERT FIRST BLANK\n         BCTR  R1,0                DEDUCT FIRST BLANK FROM LENGTH\n         BCTR  R1,0                DECREMENT LENGTH FOR EX\n         LTR   R1,R1               ANY BLANKS LEFT?\n         BM    DONE&NDX            NO MORE...WE'RE ALL DONE\nMVC&NDX  MVC   1(*-*,R15),0(R15)   *** EXECUTED INSTRUCTION ***\n         EX    R1,MVC&NDX          RIPPLE IN OTHER BLANKS\nDONE&NDX DS    0H                  ALL DONE\n         MEND\n\n\nLynn Grant\nTechnical Consultant (USA)      August 1987\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ASVTSCA$": {"ttr": 525, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x000\\x01\\x10$\\x8f\\x01\\x10$\\x8f!\\x10\\x00\\x1c\\x00\\x1c\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2010-09-05T00:00:00", "modifydate": "2010-09-05T21:10:30", "lines": 28, "newlines": 28, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,FLAG(5))\n//SYSLIB   DD DISP=SHR,DSN=SBGOLOB.T21.MACLIB\n//         DD DISP=SHR,DSN=SBGOLOB.T21.MODGEN\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(ASVTSCAN)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,4),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n SETCODE AC(0)\n SETSSI  CB480836\n NAME    ASVTSCAN(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ASVTSCA@": {"ttr": 527, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00H\\x01\\x10$\\x8f\\x01\\x10$\\x8f!2\\x00\\x06\\x00\\x06\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2010-09-05T00:00:00", "modifydate": "2010-09-05T21:32:48", "lines": 6, "newlines": 6, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBA JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//ASVTSCAN EXEC PGM=ASVTSCAN\n//STEPLIB  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSPRINT DD  SYSOUT=*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ASVTSCAN": {"ttr": 529, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00C\\x01\\x10 o\\x01\\x10$\\x9f\"%\\x00\\x83\\x00\\x87\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "2010-07-25T00:00:00", "modifydate": "2010-09-06T22:25:43", "lines": 131, "newlines": 135, "modlines": 0, "user": "SBGOLOB"}, "text": "*  Author:   David Welch (New Zealand)\nASVTSCAN CSECT\n         BAKR  R14,0\n         LR    R12,R15\n         USING ASVTSCAN,R12\n         L     R2,CVTPTR                      r2 --> cvt\n         ICM   R1,15,CVTSMCA-CVT(R2)          r1 --> smca\n         MVC   L0A+12(4),SMCASID-SMCABASE(R1) smfid\n         L     R2,CVTASVT-CVT(,R2)            r2 --> asvt\n         USING ASVT,R2\n         CLC   ASVTASVT-ASVT(4,R2),=C'ASVT'   check eyecatcher\n         BNE   ABEND\n         XR    R8,R8\n         L     R4,ASVTMAXI-ASVT(,R2)          r4 no of asvt slots\n         LA    R3,ASVTENTY-ASVT(,R2)          r3 --> first asvt slot\n         LR    R5,R3                          r5 --> MASTERs asvt slot\n         L     R6,0(,R5)                      r6 --> MASTERs ascb\n         CLC   ASCBASCB-ASCB(4,R6),=C'ASCB'\n         BNE   ABEND\n         ICM   R6,B'1111',ASCBJBNS-ASCB(R6)   r6 --> jobname\n         BZ    ABEND\n         CLC   0(8,R6),=C'*MASTER*'\n         BNE   ABEND\n         O     R5,=X'80000000'                turn high-order bit on\nASVT_LOOP EQU *\n         ICM   R6,B'1111',0(R3)               asvt entry\n         BNM   ASVT_NEXT                      assigned ?\n         C     R6,=X'80000000'                end of queue ?\n         BE    ASVT_NEXT\n         CR    R5,R6                          MASTER asvt ?\n         BNE   ASVT_NEXT\n         LA    R8,1(,R8)                      yes - increment count\nASVT_NEXT EQU *\n         LA    R3,4(,R3)                      r3 --> next asvt slot\n         BCT   R4,ASVT_LOOP\n         OPEN  (SYSPRINT,(OUTPUT))\n         BAL   R3,PUT_LINE\n         MVC   0(L'L0A,R7),L0A                system id\n         BAL   R3,PUT_LINE\n         BAL   R3,PUT_LINE\n         MVC   BINARY(4),ASVTAAV-ASVT(R2)     no of free slots\n         BAL   R3,CONVERT_TO_DECIMAL\n         BAL   R3,PLACE_NUMBER\n         MVC   0(L'L1A,R7),L1A\n         LA    R7,L'L1A(,R7)\n         MVC   BINARY(4),ASVTMAXI-ASVT(R2)    maxuser value\n         BAL   R3,CONVERT_TO_DECIMAL\n         BAL   R3,PLACE_NUMBER\n         MVC   0(L'L1B,R7),L1B\n         BAL   R3,PUT_LINE\n         BAL   R3,PUT_LINE\n         MVC   BINARY(4),ASVTAST-ASVT(R2)     free reserved (start q)\n         BAL   R3,CONVERT_TO_DECIMAL\n         BAL   R3,PLACE_NUMBER\n         MVC   0(L'L2A,R7),L2A\n         LA    R7,L'L2A(,R7)\n         MVC   BINARY(4),ASVTSTRT-ASVT(R2)    rsvstrt value\n         BAL   R3,CONVERT_TO_DECIMAL\n         BAL   R3,PLACE_NUMBER\n         MVC   0(L'L2B,R7),L2B\n         BAL   R3,PUT_LINE\n         BAL   R3,PUT_LINE\n         MVC   BINARY(4),ASVTANR-ASVT(R2)     free non-reusable q\n         BAL   R3,CONVERT_TO_DECIMAL\n         BAL   R3,PLACE_NUMBER\n         MVC   0(L'L3A,R7),L3A\n         LA    R7,L'L3A(,R7)\n         MVC   BINARY(4),ASVTNONR-ASVT(R2)    rsvnonr value\n         BAL   R3,CONVERT_TO_DECIMAL\n         BAL   R3,PLACE_NUMBER\n         MVC   0(L'L3B,R7),L3B\n         BAL   R3,PUT_LINE\n         BAL   R3,PUT_LINE\n         ST    R8,BINARY                      number flagged as\n         BAL   R3,CONVERT_TO_DECIMAL          .. not reusable\n         BAL   R3,PLACE_NUMBER\n         MVC   0(L'L4A,R7),L4A\n         LA    R7,L'L4A(,R7)\n         MVC   BINARY(4),ASVTMAXI-ASVT(R2)    maxuser\n         BAL   R3,CONVERT_TO_DECIMAL\n         BAL   R3,PLACE_NUMBER\n         CLOSE (SYSPRINT)\nEXIT     XR    R15,R15\n         PR                                   return to MVS\nPUT_LINE EQU *                                subroutine\n         PUT   SYSPRINT\n         MVI   0(R1),C' '\n         MVC   1(120,R1),0(R1)\n         LA    R7,2(,R1)\n         BR    R3                             return to caller\nCONVERT_TO_DECIMAL EQU *                      subroutine\n         L     R5,BINARY\n         CVD   R5,PACKED\n         MVC   ZONED(8),PATTERN\n         ED    ZONED(8),PACKED+4              return to caller\n         BR    R3\nPLACE_NUMBER EQU *                            subroutine\n         LA    R5,ZONED+6\n         LA    R6,1\nPLACE_NUMBER_LOOP EQU *\n         CLI   0(R5),C' '\n         BE    PLACE_NUMBER_MVC\n         BCTR  R5,0\n         LA    R6,1(,R6)\n         B     PLACE_NUMBER_LOOP\nPLACE_NUMBER_MVC EQU *\n         EX    R6,MVC001\n         LA    R7,1(R6,R7)\n         BR    R3                             return to caller\nMVC001   MVC   0(0,R7),0(R5)\nABEND    ABEND 99\nSYSPRINT DCB DDNAME=SYSPRINT,MACRF=PL,DSORG=PS,LRECL=121\nPACKED   DC    D'0'\nBINARY   DC    F'0'\nZONED    DC    CL8' '\nPATTERN  DC    X'4020202020202120'\nL0A      DC    C'System id - xxxx'\nL1A      DC    C' free ASVT slots (out of'\nL1B      DC    C' - MAXUSER value)'\nL2A      DC    C' free slots on reserved START queue (original size'\nL2B      DC    C' - RSVSTRT value)'\nL3A      DC    C' free slots on the non-reusable replacement queue (oriX\n               ginal size'\nL3B      DC    C' - RSVNONR value)'\nL4A      DC    C' slots marked as not reusable - out of original'\n         YREGS\n         CVT DSECT=YES\n         IHAASVT DSECT=YES,LIST=YES\n         IHAASCB DSECT=YES,LIST=YES\n         IEESMCA\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ASVTSCAT": {"ttr": 532, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01(\\x001\\x01\\x10 o\\x01\\x19\\x10O#E\\x00\\x8e\\x00\\x87\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.40", "flags": 0, "createdate": "2010-07-25T00:00:00", "modifydate": "2019-04-14T23:45:31", "lines": 142, "newlines": 135, "modlines": 0, "user": "SBGOLOB"}, "text": "ASVTSCAN CSECT\nASVTSCAN AMODE 31\nASVTSCAN RMODE 24\n         BAKR  R14,0\n         LR    R12,R15\n         USING ASVTSCAN,R12\n         L     R2,CVTPTR                      r2 --> cvt\n         ICM   R1,15,CVTSMCA-CVT(R2)          r1 --> smca\n         MVC   L0A+12(4),SMCASID-SMCABASE(R1) smfid\n         L     R2,CVTASVT-CVT(,R2)            r2 --> asvt\n         USING ASVT,R2\n         CLC   ASVTASVT-ASVT(4,R2),=C'ASVT'   check eyecatcher\n         BNE   ABEND\n         XR    R8,R8\n         L     R4,ASVTMAXI-ASVT(,R2)          r4 no of asvt slots\n         LA    R3,ASVTENTY-ASVT(,R2)          r3 --> first asvt slot\n         LR    R5,R3                          r5 --> MASTERs asvt slot\n         L     R6,0(,R5)                      r6 --> MASTERs ascb\n         CLC   ASCBASCB-ASCB(4,R6),=C'ASCB'\n         BNE   ABEND\n         ICM   R6,B'1111',ASCBJBNS-ASCB(R6)   r6 --> jobname\n         BZ    ABEND\n         CLC   0(8,R6),=C'*MASTER*'\n         BNE   ABEND\n         O     R5,=X'80000000'                turn high-order bit on\nASVT_LOOP EQU *\n         ICM   R6,B'1111',0(R3)               asvt entry\n         BNM   ASVT_NEXT                      assigned ?\n         C     R6,=X'80000000'                end of queue ?\n         BE    ASVT_NEXT\n         CR    R5,R6                          MASTER asvt ?\n         BNE   ASVT_NEXT\n         LA    R8,1(,R8)                      yes - increment count\nASVT_NEXT EQU *\n         LA    R3,4(,R3)                      r3 --> next asvt slot\n         BCT   R4,ASVT_LOOP\n         LA    R1,SYSPRINT\n         MVI   0(R1),X'40'\n         MVC   1(120,R1),0(R1)\n         BAL   R3,PUT_LINE\n         MVC   0(L'L0A,R7),L0A                system id\n         BAL   R3,PUT_LINE\n         BAL   R3,PUT_LINE\n         LR    R1,R7\n         LA    R7,2(,R1)\n         MVC   BINARY(4),ASVTAAV-ASVT(R2)     no of free slots\n         BAL   R3,CONVERT_TO_DECIMAL\n         BAL   R3,PLACE_NUMBER\n         MVC   0(L'L1A,R7),L1A\n         LA    R7,L'L1A(,R7)\n         MVC   BINARY(4),ASVTMAXI-ASVT(R2)    maxuser value\n         BAL   R3,CONVERT_TO_DECIMAL\n         BAL   R3,PLACE_NUMBER\n         MVC   0(L'L1B,R7),L1B\n         BAL   R3,PUT_LINE\n         BAL   R3,PUT_LINE\n         MVC   BINARY(4),ASVTAST-ASVT(R2)     free reserved (start q)\n         BAL   R3,CONVERT_TO_DECIMAL\n         BAL   R3,PLACE_NUMBER\n         MVC   0(L'L2A,R7),L2A\n         LA    R7,L'L2A(,R7)\n         MVC   BINARY(4),ASVTSTRT-ASVT(R2)    rsvstrt value\n         BAL   R3,CONVERT_TO_DECIMAL\n         BAL   R3,PLACE_NUMBER\n         MVC   0(L'L2B,R7),L2B\n         BAL   R3,PUT_LINE\n         BAL   R3,PUT_LINE\n         MVC   BINARY(4),ASVTANR-ASVT(R2)     free non-reusable q\n         BAL   R3,CONVERT_TO_DECIMAL\n         BAL   R3,PLACE_NUMBER\n         MVC   0(L'L3A,R7),L3A\n         LA    R7,L'L3A(,R7)\n         MVC   BINARY(4),ASVTNONR-ASVT(R2)    rsvnonr value\n         BAL   R3,CONVERT_TO_DECIMAL\n         BAL   R3,PLACE_NUMBER\n         MVC   0(L'L3B,R7),L3B\n         BAL   R3,PUT_LINE\n         BAL   R3,PUT_LINE\n         LR    R1,R7\n         LA    R7,2(,R1)\n         ST    R8,BINARY                      number flagged as\n         BAL   R3,CONVERT_TO_DECIMAL          .. not reusable\n         BAL   R3,PLACE_NUMBER\n         MVC   0(L'L4A,R7),L4A\n         LA    R7,L'L4A(,R7)\n         MVC   BINARY(4),ASVTMAXI-ASVT(R2)    maxuser\n         BAL   R3,CONVERT_TO_DECIMAL\n         BAL   R3,PLACE_NUMBER\n         BAL   R3,PUT_LINE\nEXIT     XR    R15,R15\n         PR                                   return to MVS\nPUT_LINE EQU *                                subroutine\n         MVC   SYSPRINT(121),0(R1)\n         STM   R14,R1,SAVE14T1\n         TPUT  SYSPRINT,121\n         LM    R14,R1,SAVE14T1\n         MVI   0(R1),C' '\n         MVC   1(120,R1),0(R1)\n         LA    R7,2(,R1)\n         BR    R3                             return to caller\nCONVERT_TO_DECIMAL EQU *                      subroutine\n         L     R5,BINARY\n         CVD   R5,PACKED\n         MVC   ZONED(8),PATTERN\n         ED    ZONED(8),PACKED+4              return to caller\n         BR    R3\nPLACE_NUMBER EQU *                            subroutine\n         LA    R5,ZONED+6\n         LA    R6,1\nPLACE_NUMBER_LOOP EQU *\n         CLI   0(R5),C' '\n         BE    PLACE_NUMBER_MVC\n         BCTR  R5,0\n         LA    R6,1(,R6)\n         B     PLACE_NUMBER_LOOP\nPLACE_NUMBER_MVC EQU *\n         EX    R6,MVC001\n         LA    R7,1(R6,R7)\n         BR    R3                             return to caller\nMVC001   MVC   0(0,R7),0(R5)\nABEND    ABEND 99\nSYSPRINT DC    CL121' '\nPACKED   DC    D'0'\nBINARY   DC    F'0'\nSAVE14T1 DC    4F'0'\nZONED    DC    CL8' '\nPATTERN  DC    X'4020202020202120'\nL0A      DC    C'System id - xxxx'\nL1A      DC    C' free ASVT slots (out of'\nL1B      DC    C' - MAXUSER value)'\nL2A      DC    C' free slots on reserved START queue (original size'\nL2B      DC    C' - RSVSTRT value)'\nL3A      DC    C' free slots on the non-reusable replacement queue (oriX\n               ginal size'\nL3B      DC    C' - RSVNONR value)'\nL4A      DC    C' slots marked as not reusable - out of original'\n         YREGS\n         CVT DSECT=YES\n         IHAASVT DSECT=YES,LIST=YES\n         IHAASCB DSECT=YES,LIST=YES\n         IEESMCA\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CHKASVT": {"ttr": 772, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x97\\x08O\\x01\\x00!?\\x12!\\x00S\\x00S\\x00\\x11\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1997-03-25T00:00:00", "modifydate": "2000-07-31T12:21:00", "lines": 83, "newlines": 83, "modlines": 17, "user": "WSBG"}, "text": "*        DISPLAYS THE MAXIMUM AND AVAILABLE NUMBER OF ASID SLOTS.\n*        SYS1.CMDLIB(CHKASVT)\nCHKASVT  START\n*        REGS\n         YREGS\n         SAVE  (14,12)\n         LR    12,15\n         USING CHKASVT,12\n         ST    R13,RSAVE+4                SAVE REGISTERS\n         LA    R9,RSAVE\n         ST    R9,8(R13)\n         LR    R13,R9\n         L     R13,RSAVE+4\n         L     R1,16                      GET ASVT\n         USING CVT,R1\n         L     R1,CVTASVT\n         USING ASVT,R1\n         SLR   R2,R2                      GET ASVT HEADER STUFF\n         L     R2,ASVTMAXU                MAX ASIDS\n         LR    R4,R2                      SAVE MAX ASIDS IN REG4\n         CVD   R2,PACKED                  CONVERT TO DECIMAL, AND\n         UNPK  WTO+19(5),PACKED+5(3)      DISPLAY\n         OI    WTO+23,X'F0'               MAKE LAST DIGIT READABLE\n         SLR   R2,R2\n         L     R2,ASVTAAV                 GET # AVAILABLE ASIDS\n         CVD   R2,PACKED                  CONVERT TO DECIMAL, AND\n         UNPK  WTO+44(5),PACKED+5(3)      DISPLAY\n         OI    WTO+48,X'F0'               MAKE LAST DIGIT READABLE\n         SLR   R2,R2                    CLEAR REG 2(COUNTER)\n         LA    R3,ASVTENTY              GO TO 1ST ENTRY ADDR\n         LR    R5,R3                 SAVE ADDR FOR COMPARISON\n         ICM   R5,8,=X'80'           SET HIGHORDER\n         BCTR  R4,0                 REDUCE COUNTER BY ONE\n         LA    R6,WTO2+65           ADDRESS OF LAST ZZZZZ IN WTO2\n         LA    R9,WTO2+29           ADDRESS OF FRST ZZZZZ IN WTO2\n         LA    R7,1(,0)             SET REG7 TO ASID=1\n         MVC   WTO2+29(5),=C'     '\n         MVC   WTO2+35(5),=C'     '    CLEAR SLOTS IN MSG LINE\n         MVC   WTO2+41(5),=C'     '\n         MVC   WTO2+47(5),=C'     '\n         MVC   WTO2+53(5),=C'     '\n         MVC   WTO2+59(5),=C'     '\n         MVC   WTO2+65(5),=C'     '\nASVTLOOP C     R5,0(R3)             ENTRY = TO MASTER ASID ENTRY ADDR?\n         BNE   PASSCNT              NO, DON'T COUNT IT AS UNAVAILABLE\n         CVD   R7,PACKED            THEN PREPARE TO TELL 'EM\n         UNPK  0(5,R9),PACKED+5(3)  DISPLAY THE COUNT\n         OI    4(R9),X'F0'          MAKE LAST DIGIT READABLE\n         LA    R9,6(,R9)            BUMP TO NEXT ZZZZZ IN WTO2\n         CR    R9,R6\n         BNH   CONTINUE             HAVEN'T FILLED IN ALL ZZZZZ'S YET\n         BAL   R10,WTORTN           DISPLAY NON-REUSEABLE ASID NUMBERS\n         LA    R9,WTO2+29           REINITIALIZE REG9 TO 1ST ZZZZZ ADDR\n         MVC   WTO2+29(5),=C'     '\n         MVC   WTO2+35(5),=C'     '\n         MVC   WTO2+41(5),=C'     '\n         MVC   WTO2+47(5),=C'     '\n         MVC   WTO2+53(5),=C'     '\n         MVC   WTO2+59(5),=C'     '\n         MVC   WTO2+65(5),=C'     '\nCONTINUE EQU   *\n         LA    R2,1(,R2)                BUMP COUNTER\nPASSCNT  LA    R3,4(R3)                GET NEXT ASVT ENTRY\n         LA    R7,1(,R7)               BUMP COUNT TO NEXT ASID NUMBER\n         BCT   R4,ASVTLOOP             LOOP THRU ENTRIES\n         CLC   WTO2+29(5),=C'     '     ANY DATA FILLED IN?\n         BE    CONTINU2                 NOPE, BYPASS WTO2\n         BAL   R10,WTORTN           DISPLAY NON-REUSEABLE ASID NUMBERS\nCONTINU2 CVD   R2,PACKED                 THEN PREPARE TO TELL 'EM\n         UNPK  WTO+67(5),PACKED+5(3)     DISPLAY\n         OI    WTO+71,X'F0'\nWTO      WTO   'ASID MAX = 12345; ASIDS AVAILABLE = 12345; NON-REUSABLEX\n               S = 12345',ROUTCDE=11\n         RETURN (14,12),RC=0\nWTORTN   EQU   *\nWTO2     WTO   'NON-REUSEABLE ASIDS: ZZZZZ ZZZZZ ZZZZZ ZZZZZ ZZZZZ ZZZZX\n               Z ZZZZZ',ROUTCDE=11\n         BR    R10\nRSAVE    DC    18F'0'\nPACKED   DS    D\n         CVT   DSECT=YES\n         IHAASVT\n         END   CHKASVT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CLS": {"ttr": 775, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\t\\x01\\x10)O\\x01\\x10)O\\x01C\\x00\\x15\\x00\\x15\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2010-10-21T00:00:00", "modifydate": "2010-10-21T01:43:09", "lines": 21, "newlines": 21, "modlines": 0, "user": "SBGOLOB"}, "text": "CLS     CSECT\n* THIS PROGRAM IS DESIGNED TO CLEAR THE SCREEN ON ANY MODEL 327X TSO\n* TERMINAL.  THE PROGRAM SHOULD BE ASSEMBLED AND LINK-EDITED INTO A\n* TSO STEPLIB OR A LINK-LISTED LIBRARY, IT MAY THEN BE INVOKED AS A\n* TSO COMMAND.  THE COMMAND CAN BE ISSUED FROM A TSO 'READY' STATE\n* OR, PROBABLY OF MORE USE, WITHIN A CLIST.  NO OPERANDS ARE NEEDED,\n* IF ANY ARE PRESENT, THEY WILL BE IGNORED.\n* ASSEMBLY SYSLIB:  SYS1.MACLIB\n* LINK-EDIT SYSLIB: NONE\n*           PARM:   NCAL, LET, LIST, RENT, AC(0)\n         SAVE  (14,12)             SAVE REGISTERS\n         LR    12,15               COPY BASE ADDRESS TO REG-12\n         USING CLS,12              PROVIDE ADDRESSABILITY\n         GTSIZE ,                  GET TERMINAL SIZE VALUES\n         LTR   0,0                 TEST NUMBER OF LINES ON SCREEN\n         BZ    NOT3270             EXIT IF NONE, NOT A DISPLAY TERM\n         TPUT CLRSCRN,CLRSCRNL,FULLSCR  ELSE CLEAR THE SCREEN\nNOT3270  RETURN (14,12),RC=0       RESTORE REGISTERS EXIT WITH R/C 0\nCLRSCRN  DC    X'C31140403C404000' 327X DATA-STREAM\nCLRSCRNL EQU   (*-CLRSCRN)\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CLS$": {"ttr": 777, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x14\\x01\\x10)O\\x01\\x10)O\\x01D\\x00\\x1c\\x00\\x1c\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2010-10-21T00:00:00", "modifydate": "2010-10-21T01:44:14", "lines": 28, "newlines": 28, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,FLAG(5))\n//SYSLIB   DD DISP=SHR,DSN=SBGOLOB.T21.MACLIB      SYS1.MACLIB\n//         DD DISP=SHR,DSN=SBGOLOB.T21.MODGEN      SYS1.MODGEN\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(CLS)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,4),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n SETCODE AC(0)\n SETSSI  CB480830\n NAME    CLS(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CLS#": {"ttr": 779, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00W\\x01\\x10 o\\x01\\x10)O\\x01F\\x00!\\x00!\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2010-07-25T00:00:00", "modifydate": "2010-10-21T01:46:57", "lines": 33, "newlines": 33, "modlines": 0, "user": "SBGOLOB"}, "text": "A TSO command to clear the screen   (pds member A315B7EF)\n\nThe following TSO command was designed to clear the screen on\na 327x terminal.  It is particularly useful within CLISTs in that the\nCLIST writer can control the clearing of the screen at appropriate\npoints.\n\nCLS     CSECT\n* THIS PROGRAM IS DESIGNED TO CLEAR THE SCREEN ON ANY MODEL 327X TSO\n* TERMINAL.  THE PROGRAM SHOULD BE ASSEMBLED AND LINK-EDITED INTO A\n* TSO STEPLIB OR A LINK-LISTED LIBRARY, IT MAY THEN BE INVOKED AS A\n* TSO COMMAND.  THE COMMAND CAN BE ISSUED FROM A TSO 'READY' STATE\n* OR, PROBABLY OF MORE USE, WITHIN A CLIST.  NO OPERANDS ARE NEEDED,\n* IF ANY ARE PRESENT, THEY WILL BE IGNORED.\n* ASSEMBLY SYSLIB:  SYS1.MACLIB\n* LINK-EDIT SYSLIB: NONE\n*           PARM:   NCAL, LET, LIST, RENT, AC(0)\n         SAVE  (14,12)             SAVE REGISTERS\n         LR    12,15               COPY BASE ADDRESS TO REG-12\n         USING CLS,12              PROVIDE ADDRESSABILITY\n         GTSIZE ,                  GET TERMINAL SIZE VALUES\n         LTR   0,0                 TEST NUMBER OF LINES ON SCREEN\n         BZ    NOT3270             EXIT IF NONE, NOT A DISPLAY TERM\n         TPUT CLRSCRN,CLRSCRNL,FULLSCR  ELSE CLEAR THE SCREEN\nNOT3270  RETURN (14,12),RC=0       RESTORE REGISTERS EXIT WITH R/C 0\nCLRSCRN  DC    X'C31140403C404000' 327X DATA-STREAM\nCLRSCRNL EQU   (*-CLRSCRN)\n         END\n\n\nPaul J Horak\nSEI(USA)        1989\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DFRMM": {"ttr": 781, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x10 o\\x01\\x10 o\\x00\\x00\\x02)\\x02)\\x00\\x00\\xd4\\xe5\\xe2\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2010-07-25T00:00:00", "modifydate": "2010-07-25T00:00:00", "lines": 553, "newlines": 553, "modlines": 0, "user": "MVSUPDT"}, "text": "DFRMM\n\nINTRODUCTION\n\nDFRMM is IBM's first major move into the tape management\nsystem area. This product was designed and developed in the\nsoftware laboratories at IBM Warwick, UK. This article describes\nthe concepts and facilities that are part of the DFRMM product.\n\nCOMMON TERMS\n\nLet us begin by describing some common terms used in\nDFRMM.\n\nRMM\n\nRemovable Media Manager.\n\nPool\n\nA pool is a group of shelf locations in the removable media library\nwhose rack numbers share a common prefix.\n\nShelf location\n\nA shelf location is a single space on a shelf where you store a\nvolume. DFRMM defines a shelf location in the removable media\nlibrary by a rack number, and a shelf location in a storage location\nby a bin number.\n\nRack number\n\nA six-character identifier that corresponds to a specific volume\nshelf location in the installation removable media library.\n\nMaster volume\n\nA volume that contains valid data and cannot be written to unless\nthe dataset names match or the volume is changed to 'user' status.\n\nVRS\n\nVital Record Specifications (VRSs) are definitions that describe\nhow datasets and volumes are to be retained within DFRMM.\n\nScratch volume\n\nA volume that is available to satisfy non-specific volume mount\nrequests.\n\nStorage location\n\nA location that is physically separate from the main DFRMM\nremovable media library where volumes are stored and retained\nfor purposes such as disaster recovery. At the current time,\nDFRMM defines three storage locations: remote, local, and\ndistant.\n\nBin number\n\nA shelf location where a volume resides in a storage location.\n\nUser volume\n\nA volume that can be overwritten until the volume expires.\n\nINSTALLATION\n\nDFRMM is installed in the existing MVS zones using normal\nSMP/E receive, apply, and accept. All load modules are link-\nedited into SYS1.LINKLIB or SYS1.LPALIB. The DFRMM\nhooks are installed at installation time by including object code in\nthe OPEN/CLOSE/EOV modules. There is a dependency that the\nOPEN/CLOSE/EOV modules are at the latest level as shipped by\nIBM. The following is a list of the OPEN/CLOSE/EOV modules\nthat DFRMM link-edits into:\n\no      IFG0194A\n\no      IG00020\n\no      IGC0005E\n\no      IGC0001I\n\no      IGC0002C.\n\nThere is also a dependency by DFRMM on the transfer of control\ntables for some of the CSECTs that are part of the previous load\nmodules. These CSECTs are:\n\no      IFG0194F\n\no      IFG0195C\n\no      IFG0195K\n\no      IFG0195N\n\no      IFG0196P\n\no      IFG0196N\n\no      IFG0200Y\n\no      IFG0551H\n\no      IFG0553F\n\no      IFG0552B\n\no      IFG0552D\n\no      IFG0232S.\n\nThe activation of the interface is completed by the DFRMM\nsubsystem interface initialization module, EDGSSSI.\n\nSupport is also provided for existing EMODVOL1 or\nOMODVOL1 routines. These routines are called after DFRMM\nhas completed its functions.\n\nThe following libraries are created as part of the ISFP/PDF\ninterface:\n\nSYS1.SEDGEXE1  -  SYSEXEC/SYSPROC    - REXX EXECs\n\nSYS1.SEDGMSG1  -  ISPMLIB                       - message\nlibrary\n\nSYS1.SEDGPNL1  -  ISPPLIB                         - panel library.\n\nSYS1.SEDGSKL1  -  ISPSLIB                         - skeleton\nlibrary.\n\nSYS1.SEDGTBL1  -  ISPTLIB                        - table library.\n\nA REXX EXEC is available (EDGRMLIB), which LIBDEFs the\nDFRMM libraries and then calls the RMM ISPF interface.\n\nThe IEFSNNxx  and IKJTSOxx PARMLIB members will need\nto be updated.Three other members can optionally be updated:\nGRSRNLxx, SCHEDxx, andSMFPRMxx.\n\nAn entry must be included for DFRMM in the IEFSSNxx\nmember as DFRM, EDGSSSI or simply DFRM.\n\nIf the initialization module EDGSSSI is coded, DFRMM will be\nfully enabled. If this route is chosen, all tape mounts will be\nrejected unless the subsystem is also active. Any subsystem name\ncan be used, up to four characters in length. The started task name\nfor DFRMM does not have to match the subsystem name unless\nyou omit EDGSSSI from the IEFSSNxx entry. It is worth noting\nthat the DFRMM entry must be inserted before the NetView of\nthe CA-ACF2 entry if applicable.\n\nThe PARMLIB member IKJTSOxx must be updated to authorize\nDFRMM commands and programs that will be used with TSO\nand the TSO service facility.\n\nThere are two types of SMF record that can be generated by\nDFRMM: audit records and security records.\n\nFor this purpose two SMF record numbers in the range 128 to\n255 must be selected and SMFPRMxx updated accordingly. It\nshould be noted that this facility is optional and either record can\nbe generated.\n\nDFRMM requires the use of two datasets: the DFRMM\nCONTROL dataset and the DFRMM JOURNAL dataset. The\nDFRMM control dataset is a VSAM KSDS and contains the\nremote media inventory. The record size is variable with a range\nbetween 512 bytes and 9216 bytes. A normal IDCAMS define\ncluster is used to create this dataset and a special DFRMM utility,\nEDGUTIL, is used to initialize the control dataset.\n\nThe DFRMM journal dataset is a sequential structure and is used\nto contain a record of all changes that are made to the control\ndataset. An interesting point to note here is that this dataset is\noptional. However, without this dataset no easy method of\nrecovering the control dataset is possible.\n\nSYSTEM OPTIONS\n\nDFRMM has its own PARMLIB member(s), EDGRMMxx, and\nis divided into five commands.\n\nOption command\n\nThis part defines the system options. Here you define information\nsuch as:\n\no      Control dataset name\n\no      Journal dataset name\n\no      Maximum retention period\n\no      Operational running mode\n\no      Retention period\n\no      SMF record numbers for audit and security records\n\no      The RACF tape support required\n\no      The tape dataset UNCATALOG option.\n\nREJECT command\n\nThis command is used to reject a range of tape volume serial\nnumbers on particular systems. This could be used when an\ninstallation has separate development and production systems.\n\nVPOOL command\n\nThis command defines the installation pools to DFRMM. The\ninformation that can be defined per pool is:\n\no      Expiration date check support. (This option controls the\nautomatic processing of unexpired tapes at the pool level.)\n\no      Prefix of the shelf location within the pool.\n\no      Whether RACF tape profile processing is enabled within the\npool.\n\no      Type of pool: rack or scratch.\n\nMNTMSG command\n\nThis command allows an installation to tailor the normal MVS\nmount and fetch messages so that the volume serial number, pool\nnumber, and rack number are displayed. For example:\n\n      IEF233A M 160, 001000,,JOBTAPE,JOB00, - RACK - 001000\n\nThis can help the operators when mounting or locating tapes.\n\nSECCLS command\n\nThis command allows an installation to define security classes for\nvolumes and datasets. It should be noted that these are internal\nsecurity classes and do not affect RACF processing. These classes\nare stored in the control dataset.\n\nINITIALIZATION\n\nTo start the DFRMM subsystem address space, a procedure must\nbe created in a system PROCLIB and a start command for\nDFRMM must be issued. For example:\n\n      S DFRMM\n\nThis command should be placed in the COMMNDxx member of\nSYS1.PARMLIB.\n\nYou can include the MASTER (control dataset) and JOURNAL\nDD cards in the start member, but it is advisable to identify these\n\ntwo datasets to DFRMM through the PARMLIB member,\nEDGRMMxx.\n\nTo disable the DFRMM subsystem interface the following\ncommands must be issued:\n\n      S DFRMM,OPTF=RESET\n      P DFRMM\n\nTo re-enable, an S DFRMM command is all that is required.\n\nTo restart the DFRMM subsystem the following command must\nbe issued:\n\n      F DFRMM,M=xx\n\nwhere xx is the suffix of the EDGRMMxx member. When this\ncommand is issued the subsystem stops and then re-initializes\nitself.\n\nTHE MEDIA POOL\n\nIn the implementation phase of DFRMM an important issue is the\ndesign of the volume pools. A pool contains a group of rack\nnumbers that all share a common prefix. In DFRMM there are\ntwo types of pool: the rack pool and the scratch pool.\n\nA rack pool is typically used to hold volumes that are read only.\nThe documentation defines software product tapes as prime\ncandidates for this pool. A scratch pool is a set of shelf locations\nused to satisfy non-specific mount requests.\n\nThe DFRMM manuals go into a lot of detail on how to plan, size,\nand design storage pools. I cannot stress enough the importance\nof understanding and designing the storage pool strategy right at\nthe initial stages of implementation. A good recommendation is to\ndefine one scratch pool for the entire removable media library.\n\nDFRMM RUNNING MODES\n\nThere are four running modes available with DFRMM. These are\nspecified in the option command in the DFRMM PARMLIB\nmember EDGRMMxx.\n\nManual mode\n\nWhen DFRMM is executing in this mode, you can use DFRMM\nTSO commands, DFRMM ISPF panels, and inventory\nmanagement functions. When DFRMM is in manual mode,\nDFRMM does not validate volume or record volume usage.\n\nRecord mode\n\nWhen DFRMM is executing in record mode, it will record\ninformation about tape volumes used, dataset names, and\ninformation about volume owners. It does not validate or reflect\nvolumes in this mode.\n\nWarning mode\n\nWhen DFRMM is executing in warning mode, it will validate\ntape volumes as they are used. If it discovers any errors, it will\nissue warning messages without rejecting tapes.\n\nProtect mode\n\nWhen DFRMM is executing in protect mode, all tape requests are\nvalidated and information is recorded in the control dataset.\n\nIt is worth noting that once DFRMM is in full protect mode it will\ncontrol all scratch mounts across all tape device types. There is no\nway to restrict DFRMM to control scratch mounts on only one\ndevice type.\n\nRACF SUPPORT\n\nThe type of RACF support that is required is specified in the\noption command in the active DFRMM PARMLIB member,\nEDGRMMxx. This is the system-wide option. There is also a\nRACF option at the pool level. This will allow certain pools to run\nwithout security. There are a number of DFRMM resources that\ncan be protected with RACF profiles in the FACILITY class.\n\nAn example of this is RMM.RESET.SSI. This controls the use of\nthe RESET facility for removing DFRMM from the system, ie use\nof the S DFRMM,OPT=RESET command\n\nDFHSM INTERFACE\n\nDFRMM provides support for DFHSM to use tapes from either a\nDFHSM-managed tape pool or the system scratch pool. This is\nspecified through parameters in the DFHSM PARMLIB member.\n\nDFRMM uses and supplies the DFHSM tape volume exit\nARCTVEXT. DFHSM initiates this exit when it needs to notify a\ntape management system to expire one of its tapes. ARCTVEXT\ncalls the DFRMM program EDGDFHSM.\n\nTwo very important APARs are both supported by DRFMM:\n\no      OY50997 - ARCTVEXT is invoked for expiring CDS back-\nup tapes.\n\no      OY58292 - ARCTVEXT will now also be invoked when the\nCDS back-up function fails.\n\nThere is currently a compatibility problem between DFHSM and\nDFRMM when the DFHSM TAPEREPL command is issued.\nThis command would typically be issued at a disaster recovery\nsite where hundreds of alternative volumes could be involved.\nWhen the mount is issued for the alternative volume (ie the\nreplacement volume), DFHSM issues the open with the dataset\nname of the original volume (ie the replaced volume). DFRMM\nwill then reject this mount because of a dataset name mismatch.\n\nOEM tape management systems do not have these problems as\nthey treat products like DFHSM as external data managers and\nonly check that the high-level qualifier of the dataset name is\ncorrect.\n\nVITAL RECORDS\n\nA vital record specification is used to control the movement and\nretention of tape volumes. When creating the vital record\nspecifications either dataset names or volume serial numbers can\nbe used to determine how long to retain tapes. Vital record\nspecifications are also used to control the movement of tapes\nbetween the removable media library and storage locations.\nDFRMM currently defines three storage locations: local, distant,\nand remote.\n\nDFRMM also defines one other location (library), which is the\nremovable media library.\n\nThere are three ways that vital record specifications can be\ndefined:\n\n1      By dataset name and minimum generation. For generation\ndatasets this type of vital record specifies the minimum number of\ncopies or generations that should be kept. For non-GDG datasets,\nDFRMM considers each occurrence of a dataset to be a single\ngeneration.\n\n2      By dataset name and elapsed days.\n\n3      By volume serial number.\n\nIf no vital record specification is found for a volume or dataset, the\ndefault retention period in the active DFRMM PARMLIB\nmember EDGRMMxx is used. This value is added to the current\ndate to calculate the volume's new expiry date.\n\nCLOSED CYCLE GDG PROCESSING\n\nClosed cycle GDG processing is a method commonly used by\ninstallations that have no tape management system or do not\ndefine a scratch pool. In closed cycle GDG processing, the oldest\ngeneration's tapes are used to satisfy a new generation. DFRMM\nfully supports closed cycle GDG processing because it allows one\ngeneration of the same GDG to be overwritten with another\ngeneration of the same GDG. One of the problems with using\nclosed cycle GDG processing under DFRMM is that the size of a\nnew generation can vary, which can lead to some of the pre-\nassigned volumes not being used. To avoid this problem, correct\nvital record specifications must be used so that DFRMM will\nretain all volumes that contain any of the GDG generations.\n\nThose users that have no tape management systems will inevitably\nbe using closed cycle GDG processing. If they are considering\nmoving to a tape management system then DFRMM will fully\nsupport that environment. It is strongly recommended, however,\nthat a scratch pool system is used to obtain the full benefits of a\ntape management system.\n\nEDGHSKP UTILITY\n\nA utility program (EDGHSKP) is available, which will perform\nthe following functions:\n\nVital record processing\n\nThis process will determine which volumes and datasets are kept.\nIt will also determine which volumes are eligible to be moved to\nother storage locations.\n\nExpiry processing\n\nThis process identifies volumes that are ready to expire. DFRMM\nchecks the expiry dates of all volumes not managed by vital\nrecord specification and, if it finds that they have expired, will set\nthe volume into PENDING RELEASE status. It normally takes\ntwo runs of EDGHSKP before a volume is returned to scratch\nstatus. If this job is run daily it will take at least 24 hours before\nthese volumes are available for scratch mounts.\n\nStorage location processing\n\nThis process will identify datasets and volumes that are to be\nmoved from the library to a storage location or between storage\nlocations.\n\nBACK-UP AND RECOVERY\n\nTwo programs are available to back up the control dataset. When\nthe DFRMM subsystem is active, EDGHSKP can be used. When\nthe subsystem is not active, EDGBKUP must be used. Both\nprograms produce back-up copies using the AMS REPRO\ncommand. Once the back-up has been completed the journal\ndataset is reset. There is also an option to back up the journal\ndataset.\n\nFull recovery of the DFRMM control dataset is available and is\nvery straightforward to implement. You can forward recover the\ncontrol dataset using an old back-up level and then use the\njournals to bring DFRMM up to the precise moment that the\nfailure occurred. An important point to mention is that DFRMM\nwill attempt automatic recovery using the current journal. If\nautomatic recovery fails through an I/O error on the journal or the\ncontrol dataset, then DFRMM will notify the operator that\nautomatic recovery has failed and that manual recovery will be\nrequired.\n\nISPF/PDF INTERFACE\n\nDFRMM comes with a very user-friendly ISPF/PDF interface.\nThe ISPF dialog has been designed to cater for general users,\nsystems programmers, tape librarians, and storage administrators.\n\nThrough RACF profiles, users are assigned different levels of\nauthority depending on the user group that they are assigned to.\n\nThe panels offer functions such as:\n\no      Defining new volumes\n\no      Adding shelf locations\n\no      Confirming volume movement and action\n\no      Updating owner information\n\no      Releasing volumes\n\no      Listing volumes by volume serial number\n\no      Listing volumes by dataset name.\n\nTSO sub-commands are also available to request DFRMM\nfunctions.\n\nYou can create your own REXX EXECs or CLISTs and embed\nDFRMM command calls within them. Each command will return\nthe information as REXX variables. The variables can take the\nform of 'stems'. This can be extremely useful when processing a\nlist of volumes.\n\nMIGRATION\n\nWhile this article was being written some users of DFRMM were\neither at the pilot test level or the service offering. The\nDFSMSrmm level that is the GA code has now become available\nand some enhancements that appear in this level are:\n\no      Support for the SMS tape and the IBM 3495 tape library\ndataserver.\n\no      Support for some special keyword dates, such as 99000 and\n98000, which are available in other tape management systems.\nThis support is implemented through an RMM installation exit.\n\no      Vital records have been enhanced.\n\no      Update to EDGINERS (volume initialization program).\n\nIt seems that to move to the DFSMSrmm level from a previous\nlevel is very straightforward and requires minimal effort. No co-\nexistence PTFs are required, the DFRMM control dataset can be\nshared between different levels, and you can move forward or go\nback to the previous level if required.\n\nAn extremely useful red book is available that describes the\nplanning process for conversion to DFSMSrmm. The book\ndescribes the process that is required to convert from other\nvendors' tape management systems to DFSMSrmm. Also\nincluded are two sample extract programs and information on the\nIBM conversion program. This program uses as input the\nsequential output created by the extract programs. The form\nnumber and title of this manual is GG24-3988 Planning Guide\nfor Conversion to DFSMSrmm.\n\nR F Perretta\nSenior  Systems Programmer (UK)                                         c Xephon\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "EDTDSPLY": {"ttr": 1030, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00R\\x01\\x19\\t\\x0f\\x01\\x19\\t\\x0f\\x19\\x10\\x00g\\x00d\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2019-03-31T00:00:00", "modifydate": "2019-03-31T19:10:52", "lines": 103, "newlines": 100, "modlines": 0, "user": "SBGOLOB"}, "text": "/**rexx**/\n/*  PROGRAM-ID           EDTDSPLY.                                 */\n/*  Displays the esoteric entries in the current EDT.              */\n/*trace i*/\nsave_prompt = prompt(\"off\")\n/* --------------------------------------------------------------- */\n/* Change the next line to point to your panel dataset in ISPPLIB. */\n/* --------------------------------------------------------------- */\naddress \"ISPEXEC\" \"LIBDEF ISPPLIB DATASET ID('SYS1.U.PANELS')\"\nedtscan:\nADDRESS \"ISPEXEC\" \"CONTROL DISPLAY LOCK\" /* LOCK THE TERMINAL      */\nif (rc > 8) then do                      /* error?                 */\n   say 'Lock error    rc = 'rc''         /* yes- output message    */\n   ADDRESS \"ISPEXEC\" \"LIBDEF ISPPLIB\"    /* remove allocation      */\n   exit(0)                               /* and quit               */\nend\nADDRESS \"ISPEXEC\" \"ADDPOP ROW(6) COLUMN(5)\" /* pop up position    */\nADDRESS \"ISPEXEC\" \"DISPLAY PANEL(EDTPAN02)\"\n   if (rc > 8) then do                      /* error?              */\n      say 'Display error    rc = 'rc''      /* yes- output message */\n      ADDRESS \"ISPEXEC\" \"LIBDEF ISPPLIB\"    /* remove allocation   */\n      exit(0)                               /* and quit            */\n   end                                                             */\nEDTINF                                   /* Obtain EDT Info        */\nif (rc \u00ac= 0) then do                     /* error?                 */\n   edtrc= rc                             /* save the return code   */\n   say 'EDTINF Error    rc = 'rc''       /* yes- output message    */\n   ADDRESS \"ISPEXEC\" \"LIBDEF ISPPLIB\"    /* remove allocation      */\n   exit(edtrc)                           /* and quit               */\nend\ncall edt_esoteric_build                  /* build esoteric info    */\nADDRESS \"ISPEXEC\" \"REMPOP\"               /* remove popup           */\nADDRESS \"ISPEXEC\" \"ADDPOP ROW(2) COLUMN(1)\"  /* pop up position    */\nADDRESS \"ISPEXEC\" \"TBDISPL EDTTAB PANEL(EDTPAN01)\"\nif (rc > 8) then do                      /* error?                 */\n   say 'tbdispl error    rc = 'rc''      /* yes- output message    */\n   ADDRESS \"ISPEXEC\" \"LIBDEF ISPPLIB\"    /* remove allocation      */\n   exit(0)                               /* and quit               */\nend\nADDRESS \"ISPEXEC\" \"REMPOP\"               /* remove menu popup      */\nADDRESS \"ISPEXEC\" \"LIBDEF ISPPLIB\"       /* remove allocation      */\nexit(0)                                  /* quit                   */\nedt_esoteric_build:\nADDRESS \"ISPEXEC\" \"TBCREATE EDTTAB NOWRITE REPLACE\"\nif (rc >  4) then do                     /* call ok?               */\n   say 'tbcreate error    rc = 'rc''     /* no- inform the user    */\n   ADDRESS \"ISPEXEC\" \"LIBDEF ISPPLIB\"    /* remove allocation      */\n   exit(0)                               /* lets quit              */\nend\nztdmark=    '-------------------------------------------------------------------\n--------'\nADDRESS  \"ISPEXEC\" \"VPUT    (esoteric,vio,devnums,ZTDMARK) SHARED\"\ntabrows=  5000                           /* max table rows         */\nno_edt_table_entries= x2d(c2x(substr(edttab,1,4))) /*no of table ents*/\ndispl= 5                                 /* starting displacement  */\ndo i = 1 to no_edt_table_entries         /* loop through all tab ents*/\n   esoteric= substr(edttab,displ,8)      /* esoteric name          */\n   vio=      substr(edttab,displ+8,1)    /* vio eligible           */\n   no_of_device_nums= x2d(c2x(substr(edttab,displ+9,4)))\n   displ= (displ + 13)                   /* position onto dev nums */\n   devnums_displ= displ                  /* device number start    */\n   devnums= ''                           /* init                   */\n   devnums_per_line= 0                   /* init                   */\n   do x= 1 to no_of_device_nums          /* print the device nums  */\n      devnums= devnums||' '||substr(edttab,devnums_displ,4)\n      devnums_displ= (devnums_displ + 4) /* next entry             */\n      devnums_per_line= (devnums_per_line + 1)\n      if (devnums_per_line = 10) then do /* ten device nos per line*/\n         ADDRESS \"ISPEXEC\" \"TBADD EDTTAB  /* add the entries       */\n                 SAVE(esoteric,vio,devnums)\n                 MULT(\"TABROWS\")\"\n         if (rc \u00ac= 0) then do           /* call ok?                */\n            say 'tbadd error    rc = 'rc'' /* no- inform the user  */\n            ADDRESS \"ISPEXEC\" \"LIBDEF ISPPLIB\" /* remove allocation*/\n            exit(0)                      /* let's quit             */\n         end\n         else do\n            esoteric= ''                 /* init                   */\n            vio=      ''                 /* init                   */\n            devnums=  ''                 /* init                   */\n            devnums_per_line= 0          /* init                   */\n         end\n      end\n   end\n  if (devnums_per_line \u00ac= 0) then do     /* anything left to print?*/\n     ADDRESS \"ISPEXEC\" \"TBADD EDTTAB     /* yes- add the entries   */\n              SAVE(esoteric,vio,devnums)\n              MULT(\"TABROWS\")\"\n     if (rc \u00ac= 0) then do               /* call ok?                */\n        say 'tbadd error    rc = 'rc' ' /* no- inform the user  */\n        ADDRESS \"ISPEXEC\" \"LIBDEF ISPPLIB\" /* remove allocation*/\n        exit(0)                         /* let's quit              */\n     end\n  end\n  displ= devnums_displ                  /* next edt entry position */\nend\nADDRESS \"ISPEXEC\" \"TBTOP EDTTAB\"         /* position to top of tab */\nif (rc \u00ac= 0) then do                     /* call ok?               */\n   say 'tbtop error    rc = 'rc''        /* no- inform the user    */\n   ADDRESS \"ISPEXEC\" \"LIBDEF ISPPLIB\"    /* remove allocation      */\n   exit(0)                               /* let's quit             */\nend\nreturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EDTINF": {"ttr": 1033, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00B\\x01\\x153o\\x01\\x19\\t\\x0f\\x18X\\x019\\x01*\\x00\\x00\\xc1\\xe2\\xd4\\xd7\\xc7\\xd4@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2015-12-02T00:00:00", "modifydate": "2019-03-31T18:58:42", "lines": 313, "newlines": 298, "modlines": 0, "user": "ASMPGM"}, "text": "EDTINF TITLE 'RETURN THE EDT ESOTERIC INFORMATION'\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*   PROGRAM WRITTEN BY:   REM PERRETTA                                *\n*                                                                     *\n*          MODIFIED BY:   SAM GOLOB     (WORKS ON Z/OS 2.3)           *\n*                                                                     *\n*   COMPONENTS:  1 ASSEMBLER PROGRAM - THIS ONE.                      *\n*                1 REXX EXEC CALLED EDTDSPLY                          *\n*                2 ISPF PANELS CALLED:  EDTPAN01                      *\n*                                       EDTPAN02                      *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         YREGS\nEDTINF   CSECT\nSPACE    EQU   C' '                      SPACE\nEDTINF   AMODE 31\nEDTINF   RMODE 24\n         BAKR  R14,0                     SAVE CALLER'S ARS + GPRS\n*                                        IN THE LINKAGE STACK\n         LAE   R12,0(R15,0)              SET UP PROGRAM BASE REGISTER\nGETWORK  EQU   *\n         USING EDTINF,R12                INFORM THE ASSEMBLER\n         LR    R8,R1                     PARM @ OF @\n         STORAGE OBTAIN,LENGTH=WORKALEN,ADDR=(R10),SP=0,KEY=8,         X\n               LOC=BELOW,COND=NO,RELATED=(FREEWORK,'FREE WORK AREA')\n         LAE   R13,0(R10,0)              @ THE WORKAREA\n         USING WORKAREA,R13              INFORM THE ASSEMBLER\n         MVC   PREVSA,=C'F1SA'           PUT ACRONYM INTO SAVEAREA\n*                                        TO INDICATE STATUS SAVED ON\n*                                        THE LINKAGE STACK.\nEDTDAT   EQU   *\n         STORAGE OBTAIN,LENGTH=DVNLTLEN,ADDR=(R9),SP=0,KEY=8,          X\n               LOC=BELOW,COND=NO,RELATED=(FREEWORK,'FREE DEVICE LIST')\n         STCM  R9,B'1111',DEVLIST@     STORE DEVICE NAME LIST @\n         BAL   R2,GETESC               GET THE EDT ESOTERICS\nRETURN   EQU   *\n         ICM   R1,B'1111',DEVLIST@     ADDRESS TO FREE\n         STORAGE RELEASE,ADDR=(R1),LENGTH=DVNLTLEN,SP=0,KEY=8,         X\n               COND=NO,RELATED=(GETWORK,'OBTAIN WORK AREA')\n         LAE   R1,0(R13,0)             ADDRESS TO FREE\n         STORAGE RELEASE,ADDR=(R1),LENGTH=WORKALEN,SP=0,KEY=8,         X\n               COND=NO,RELATED=(GETWORK,'OBTAIN WORK AREA')\n         LR    R15,R10                 SET RC\n         PR                            RESTORE CALLER'S ARS\n*                                      GPRS 2-14 AND RETURN\n*                                      TO CALLER\n* THIS ROUTINE WILL BUILD A TABLE OF THE CURRENTLY DEFINED ESOTERICS.\n* THE FORMAT OF THE TABLE IS AS FOLLOWS.\n*  --------------------------------------\n*  |  NO OF ESOTERICS IN THE TABLE. AL4 |\n*  --------------------------------------\n*  THE FOLLOWING VARIABLE SECTION WILL BE REPEATED FOR EACH ESOTERIC.\n*     ---------------------------------------------------\n*     |  ESOTERIC NAME                 CL8              |\n*     |  VIO-ELIGIBLE                  CL1              |\n*     |  NO OF DEVICE UNDER ESOTERIC   AL4              |\n*     |  DEVICE NUMBERS                CL4*NO OF DEVICES|\n*     ---------------------------------------------------\nGETESC   EQU   *\n         STCM  R2,B'1111',RETURN@      SAVE THE RETURN @\n         LA    R3,DEVCLASS             @ THE DEVICE CLASS TABLE\n         USING DCLASS,R3               INFORM THE ASSEMBLER\n         LA    R4,DEVCLNET             NO OF TABLE ENTRIES\n         LA    R5,EDTTAB+L'EDTNTE      @ THE EDT TABLE. SKIP OVER HDR\nEDTBLD   EQU   *\n         EDTINFO RTNNAMD,                                              X\n               DEVCLASS=DEVCLS,                                        X\n               NAMELIST=NLISTPTR,                                      X\n               RSNCODE=REASONC,                                        X\n               MF=(E,EDTRNLST,COMPLETE)\n         LTR   R15,R15                 CALL OK?\n         BZ    RETATTR                 YES-\n         LR    R10,R15                 SAVE THE RETURN CODE\n         A     R10,=F'100'             UNIQUE RETURN CODE\n         ICM   R2,B'1111',RETURN@      RETURN @\n         BR    R2                      RETURN TO THE CALLER\nRETATTR  EQU   *\n         ICM   R7,B'1111',NLISTPTR     NAME LIST POINTER\n         USING UNLISTD,R7              INFORM THE ASSEMBLER\n         ICM   R8,B'1111',UNLNETS      NO OF TABLE ENTRIES\n         BZ    NXTDCLAS                NO- ENTRIES\n         LA    R7,UNLHDRL(,R7)         SKIP OVER THE HEADER\n         DROP  R7                      INFORM THE ASSEMBLER\n         USING UNLARRAY,R7             INFORM THE ASSEMBLER\nUNSCAN   EQU   *\n         MVI   ATTRALEN,X'0A'          ATTRIBUTE AREA LENGTH\n         EDTINFO RTNATTR,                                              X\n               UNITNAME=UNLARRAY,                                      X\n               ATTRAREA=ATTRARA,                                       X\n               RSNCODE=REASONC,                                        X\n               MF=(E,EDTRNATR,COMPLETE)\n         LTR   R15,R15                 CALL OK?\n         BZ    TESTATTR                YES-\n         CH    R15,=H'8'               RC = 8?\n         BNE   BADRC1                  RETURN CODE?\n         CLC   REASONC,=X'00000001'    UNIT NAME NOT IN EDT?\n         BE    NEXTUNME                YES-\nBADRC1   EQU   *\n         LR    R10,R15                 SAVE THE RETURN CODE\n         A     R10,=F'200'             UNIQUE RETURN CODE\n         ICM   R2,B'1111',RETURN@      RETURN @\n         BR    R2                      RETURN TO THE CALLER\nTESTATTR EQU   *\n         TM    ATTRFLG1,ATTRESC        ESOTERIC?\n         BNO   NEXTUNME                NO- CHECK THE NEXT UNIT NAME\n         ST    R5,EDTTAB@              STORE CURRENT TABLE ENTRY @\n         LA    R5,EDTEHLEN(,R5)        MOVE OVER THE HEADER PART\n         ICM   R9,B'1111',DEVLIST@     DEVICE NAME LIST @\n         STCM  R9,B'1111',DNLIST@      STORE FOR RTNDEVN MACRO USE\n         USING DVNLISTD,R9             INFORM THE ASSEMBLER\n         ICM   R10,B'1111',=AL4(L'DVNLIST) LENGTH OF DEVICE NAME LIST\n         STCM  R10,B'1111',DVNLLEN     STORE LENGTH INTO TABLE\n*   REPLACE THIS EDTINFO CALL WITH A MORE MODERN ONE.....\n*        EDTINFO RTNDEVN,                                             X\n*              UNITNAME=UNLARRAY,                                     X\n*              DEVNLIST=DNLIST@,                                      X\n*              RSNCODE=REASONC,                                       X\n*              MF=(E,EDTRNDEV,COMPLETE)\n         EDTINFO RTNDEVN,DEVNLIST=DNLIST@,UNITNAME=UNLARRAY,           +\n               DYNAMIC=YES,LOC=ANY,RANGE=ALL,RSNCODE=REASONC,          +\n               MF=(E,EDTRNDEV,COMPLETE)\n         LTR   R15,R15                 CALL OK?\n         BZ    MOVEDEVN                YES-\n         LR    R10,R15                 SAVE THE RETURN CODE\n         A     R10,=F'300'             UNIQUE RETURN CODE\n         ICM   R2,B'1111',RETURN@      RETURN @\n         BR    R2                      RETURN TO THE CALLER\nMOVEDEVN EQU   *\n         ICM   R15,B'1111',DVNLNENT    CALCULATE THE NO OF DEVICE\n         SLL   R15,(DVNENTL/2)(0)      NUMBERS TO MOVE\n         ST    R15,LENSTORE            STORE FOR A WHILE\n         LA    R14,DVNLIST             @ DSN LIST\n         LR    R0,R5                   DESTINATION @\n         LR    R1,R15                  LENGTH TO RECEIVE\n         MVCL  R0,R14                  MOVE THE DEVICE NUMBERS\n         L     R14,LENSTORE            LENGTH FOR UPDATE\n         LA    R5,0(R14,R5)            NEXT ESOTERIC TABLE ENTRY\n         ICM   R15,B'1111',VARVALLN    CURRENT LENGTH OF EDT TABLE\n         LA    R14,EDTEHLEN(R15,R14)   LENGTH OF THIS ESOTERIC ENTRY\n         STCM  R14,B'1111',VARVALLN    UPDATED LENGTH OF EDT TABLE\n         ST    R5,STORE@               LET'S STORE FOR A MOMENT\n         L     R5,EDTTAB@              RESET TABLE @\n         USING EDTTABD1,R5             INFORM THE ASSEMBLER\n         MVC   EDTESC,UNLARRAY         ESOTERIC NAME\n         MVC   EDTNENTS,DVNLNENT       NO OF DEVICE NUMBERS FOR\n*                                      ESOTERIC\n         MVI   EDTVIO,C'Y'             VIO ELIGIBLE\n         TM    ATTRFLG1,ATTRVIO        VIO ELIGIBLE?\n         BO    RESET@                  YES-\n         MVI   EDTVIO,C'N'             NOT VIO ELIGIBLE\nRESET@   EQU   *\n         L     R14,NOESOTER            UPDATE THE NUMBER\n         LA    R14,1(,R14)             OF CREATED\n         ST    R14,NOESOTER            ESOTERICS\n         L     R5,STORE@               RESET EDTTAB @\n         DROP  R5                      INFORM THE ASSEMBLER\nNEXTUNME EQU  *\n         LA    R7,L'UNLARRAY(,R7)      NEXT UNIT NAME ENTRY\n         BCT   R8,UNSCAN               DO WHILE R8 > 0?\nNXTDCLAS EQU  *\n         LA    R3,L'DEVCLASS(,R3)      NEXT DEVICE CLASS ENTRY\n         BCT   R4,EDTBLD               DO WHILE R4 > 0?\n         LA    R5,EDTTAB               @ THE GENERATED EDT TABLE\n         L     R14,NOESOTER            NO OF DEFINED ESOTERICS\n         ST    R14,0(,R5)              STORE INTO TABLE\n         LA    R14,VARNAME             @ OF VARIABLE NAME TO CREATE\n         STCM  R14,B'1111',VARNPTR     STORE FOR IKJCT441\n         LA    R14,L'VARNAME(0,0)      LENGTH OF VARIABLE NAME\n         STCM  R14,B'1111',VARVNLEN    STORE FOR IKJCT441\n         LA    R14,EDTTAB              @ OF VARIABLE\n         STCM  R14,B'1111',VARVAL@     STORE FOR IKJCT441\n         ICM   R14,B'1111',VARVALLN    CURRENT LENGTH OF EDT TABLE\n         LA    R14,L'EDTNTE(,R14)      ADD HEADER PART IN\n         STCM  R14,B'1111',VARVALLN    UPDATED LENGTH OF EDT TABLE\n         BAL   R2,REXXVAR              BUILD THE REXX VARIABLE\n         LTR   R15,R15                 DID WE BUILD THE VARIABLE?\n         BZ    ALLOK                   YES-\n         L     R10,RCODE441            SAVE THE RETURN CODE\n         A     R10,=F'400'             UNIQUE RETURN CODE\n         B     LETSQUIT                AND LET'S QUIT\nALLOK    EQU   *\n         SR    R10,R10                 SET THE RETURN CODE\nLETSQUIT EQU   *\n         ICM   R2,B'1111',RETURN@      RETURN @\n         BR    R2                      RETURN TO CALLER\nREXXVAR  EQU   *                       DEFINE REXX VARIABLE\n         XC    IKJTOKEN,IKJTOKEN       NO REQUIRED FOR THIS CALL\n         XC    RCODE441,RCODE441       RETURN CODE\n         L     R15,CVTPTR              CVT @\n         USING CVT,R15                 INFORM THE ASSEMBLER\n         L     R15,CVTTVT              TSCT @\n         USING TSVT,R15                INFORM THE ASSEMBLER\n         L     R15,TSVTVACC            IKJCT441 @\n         LTR   R15,R15                 ENTRY POINT FOUND?\n         BNZ   CALL441                 YES- DO A CALL\nLINK441  EQU   *\n         MVC   LINKAREA,LINKL          LINK SL=L\n         MVC   CALLAREA,CALLL          PROG PROGRAM LIST\n         LINK  EP=IKJCT441,                                            X\n               PARAM=(ECODE,           ENTRY CODE                      X\n               VARNPTR,                POINTER TO VARIABLE NAME        X\n               VARVNLEN,               LENGTH  OF VARIABLE NAME        X\n               VARVAL@,                POINTER TO VARIABLE VALUE       X\n               VARVALLN,               LENGTH  OF VARIABLE             X\n               IKJTOKEN,               TOKEN                           X\n               ECTPARM,                NOT REQUIRED                    X\n               RCODE441),              RETURN CODE                     X\n               VL=1,                   EOL                             X\n               MF=(E,CALLAREA),        CALL AREA                       X\n               SF=(E,LINKAREA)         LINK AREA\n         B     CHKRET                  CHECK THE RETURN CODE\nCALL441  EQU   *\n         MVC   CALLAREA,CALLL          PROG PROGRAM LIST\n         CALL  (15),                                                   X\n               (ECODE,                 ENTRY CODE                      X\n               VARNPTR,                POINTER TO VARIABLE NAME        X\n               VARVNLEN,               LENGTH  OF VARIABLE NAME        X\n               VARVAL@,                POINTER TO VARIABLE VALUE       X\n               VARVALLN,               LENGTH  OF VARIABLE             X\n               IKJTOKEN,               TOKEN                           X\n               ECTPARM,                NOT REQUIRED                    X\n               RCODE441),              RETURN CODE                     X\n               VL,                     EOL                             X\n               MF=(E,CALLAREA)\n         B     CHKRET                  CHECK THE RETURN CODE\nCHKRET   EQU   *\n         BR    R2                      RETURN TO CALLER\nMOVEDNUM MVC   0(*-*,R5),DVNLIST       MOVE IN ESOTERIC DEVICE NUMS\n         LTORG\nVARNAME  DC    CL6'EDTTAB'             VARIABLE NAME\nECTPARM  DC    X'FFFFFFFF'             ECT\nECODE    DC    AL4(TSVEUPDT)           CREATE CODE\nLINKL    LINK SF=L\nLINKLEN EQU  *-LINKL                   LENGTH\nCALLL    CALL ,(,,,,,,,),MF=L\nCALLLEN EQU  *-CALLL                   LENGTH\nDEVCLASS DS    0X                      DEVICE CLASS TABLE\n         DC    X'80'                   TAPE\n         DC    X'40'                   COMMS\n         DC    X'41'                   CTC\n         DC    X'20'                   DASD\n         DC    X'10'                   DISPLAY\n         DC    X'08'                   UNIT RECORD\n         DC    X'04'                   CHARACTER\nDEVCLLEN EQU   *-DEVCLASS              DEVICE CLASS TABLE LENGTH\nDEVCLNET EQU   DEVCLLEN/L'DEVCLASS     NO OF TABLE ENTRIES\nWORKAREA DSECT\nSAVEAREA DS    CL72                    SAVEAREA\nPREVSA   EQU   SAVEAREA+4,4            @ OF PREVIOUS SAVEAREA\nREASONC  DS    AL4                     REASON CODE\nLENSTORE DS    F                       STORE AREA FOR LENGTH\nNOESOTER DS    F                       NO OF OBTAINED ESOTERICS\nRETURN@  DS    F                       RETURN @\nSTORE@   DS    F                       @ STORE AREA\nEDTTAB@  DS    F                       CURRENT EDT TABLE @ ENTRY\nEDTTABNE DS    F                       EDT NO OF TABLE ENTRIES\nDEVLIST@ DS    F                       STORED DEVICE LIST @\nDNLIST@  DS    F                       DEVICE LIST @\n*                                      A(DVNLIST)\nATTRARA  DS    0CL10                   ATTRIBUTE AREA\nATTRALEN DS    X                       ATTRIBUTE AREA LENGTH\nATTRFLG1 DS    X                       ATTRIBUTE AREA FLAG 1\nATTRESC  EQU   X'80'                   UNITNAME IS AN ESOTERIC\nATTRVIO  EQU   X'40'                   UNITNAME IS VIO ELIGIBLE\nATTRFLG2 DS    X                       ATTRIBUTE AREA FLAG 2\nATTRDEVC DS    X                       NO OF DEVICE CLASSES IN\n*                                      UNIT NAME\nATTRDEVT DS    AL4                     NO OF DEVICE TYPES IN\nATTRFILL DS    XL2                     NOT PART OF PROG INTERFACE\n*                                      UNIT NAME\nNLISTPTR DS    F                       RETURNED UNITNAME TABLE\n         EDTINFO MF=(L,EDTRNLST)       EDT INFO\n         EDTINFO MF=(L,EDTRNATR)       EDT INFO\n         EDTINFO MF=(L,EDTRNDEV)       EDT INFO\n*  IJKCT441 PARAMETERS                 UNIT NAME\nIKJTOKEN DS    F                       TOKEN\nRCODE441 DS    F                       RETURN CODE\nVARNPTR  DS    F                       VARIABLE NAME PTR\nVARVNLEN DS    F                       VARIABLE NAME LENGTH\nVARVAL@  DS    F                       VARIABLE @\nVARVALLN DS    F                       LENGTH OF VARIABLE\n         DS    0F\nLINKAREA DS    CL(LINKLEN)             LINK AREA\nCALLAREA DS    CL(CALLLEN)             PARM LIST AREA\nEDTTAB   DS    CL32000                 GENERATED EDT TABLE\nWORKALEN EQU   *-WORKAREA              WORK AREA LENGTH\nDCLASS   DSECT\nDEVCLS   DS    X                       DEVICE CLASS\nUNLISTD  DSECT\nUNLSUBP  DS    X                       NAME LIST SUBPOOL\nUNLSIZE  DS    AL3                     SIZE OF UNIT NAME LIST\nUNLNETS  DS    AL4                     NO OF TABLE ENTRIES\nUNLHDRL  EQU   *-UNLSUBP               HEADER LENGTH\nUNLARRAY DS    CL8                     ARRAY OF UNIT NAMES\nEDTTABD1 DSECT\nEDTNTE   DS    AL4                     NO OF TABLE ENTRIES\n         ORG   EDTNTE\nEDTESC   DS    CL8                     ESOTERIC\nEDTVIO   DS    CL1                     VIO ELIGIBLE\nEDTNENTS DS    AL4                     NO OF ENTRIES FOR ESOTERIC\nEDTEHLEN EQU   *-EDTESC                LENGTH OF HEADER PART\n         ORG   EDTNENTS+L'EDTNENTS\nEDTDEVNM DS    CL4                     DEVICE NUMBER\n         ORG\nDVNLISTD DSECT\nDVNLLEN  DS    AL4                     TABLE LENGTH + HEADER\nDVNLNENT DS    AL4                     NO OF TABLE ENTRIES\nDVNLHLEN EQU   *-DVNLLEN               LENGTH OF HEADER PART\nDVNLIST  DS    CL32000                 DEVICE NUMBER LIST TABLE\nDVNENTL  EQU   4                       DEVICE NUMBER LENGTH\nDVNLTLEN EQU   *-DVNLISTD              DEVICE NUMBER LIST LENGTH\n         CVT   DSECT=YES,LIST=NO\n         IKJTSVT\n         END   EDTINF\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EDTINF$": {"ttr": 1284, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00\\x02\\x01\\x07\"_\\x01\\x19\\t\\x0f\\x14\\x12\\x00\\x1b\\x00\\x0e\\x00\\x00\\xc1\\xe2\\xd4\\xd3\\xd1\\xc3\\xd3@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "2007-08-13T00:00:00", "modifydate": "2019-03-31T14:12:02", "lines": 27, "newlines": 14, "modlines": 0, "user": "ASMLJCL"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,RLD)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(EDTINF)\n//SYSUT1   DD UNIT=SYSDA,SPACE=(CYL,20)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=SYSDA,SPACE=(TRK,30),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=(OLD,PASS),DSN=&&TEMP\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB\n ORDER   EDTINF\n SETSSI  CB497836\n ENTRY   EDTINF\n NAME    EDTINF(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EDTPAN01": {"ttr": 1286, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x002\\x01\\x153o\\x01\\x153o\\x01P\\x00\\x1a\\x00\\x1a\\x00\\x00\\xd7\\xc1\\xd5\\xc5\\xd3@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2015-12-02T00:00:00", "modifydate": "2015-12-02T01:50:32", "lines": 26, "newlines": 26, "modlines": 0, "user": "PANEL"}, "text": ")ATTR\n_ TYPE(INPUT)   INTENS(HIGH) COLOR(YELLOW)\n% TYPE(TEXT)    COLOR(RED)\n* TYPE(TEXT)    COLOR(YELLOW)\n+ TYPE(TEXT)    COLOR(WHITE)\n# TYPE(OUTPUT)  INTENS(HIGH) COLOR(BLUE)\n? TYPE(OUTPUT)  INTENS(HIGH) COLOR(RED)\n@ TYPE(OUTPUT)  COLOR(RED)\n)BODY WINDOW(70,18)\n%\n%COMMAND ===>_ZCMD      %                      SCROLL ===>_AMT      +\n%\n%\n*Esoteric   VIO     Device\n* Name              Numbers\n%\n)MODEL\n#Z       %  #z%   #z                                                 %\n)INIT\n.ZVARS= '(esoteric,vio,devnums)'\n&ZCMD= ' '\n&ZWINTTL=  'EDT ESOTERICS'\n)REINIT\n&ZCMD= ' '\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "EDTPAN02": {"ttr": 1288, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Q\\x01\\x153o\\x01\\x153o\\x01P\\x00\\x15\\x00\\x15\\x00\\x00\\xd7\\xc1\\xd5\\xc5\\xd3@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2015-12-02T00:00:00", "modifydate": "2015-12-02T01:50:51", "lines": 21, "newlines": 21, "modlines": 0, "user": "PANEL"}, "text": ")ATTR\n_ TYPE(INPUT)   INTENS(HIGH) COLOR(YELLOW)\n% TYPE(TEXT)    COLOR(RED)\n* TYPE(TEXT)    COLOR(YELLOW)\n+ TYPE(TEXT)    COLOR(WHITE)\n# TYPE(OUTPUT)  INTENS(HIGH) COLOR(BLUE)\n? TYPE(OUTPUT)  INTENS(HIGH) COLOR(RED)\n@ TYPE(OUTPUT)  COLOR(RED)\n)BODY WINDOW(60,5)\n%\n%    -----------------------------------------------------\n%    |  EDT ESOTERIC Search is in progress. Please Wait  |\n%    -----------------------------------------------------\n%\n)INIT\n&ZCMD= ' '\n&ZWINTTL=  'EDT ESOTERIC Search'\n)REINIT\n&ZCMD= ' '\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ESVCSCAN": {"ttr": 1290, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00H\\x01\\x19\\x08_\\x01\\x19\\x08_\\x11\\x05\\x02.\\x02.\\x00\\x00\\xc9\\xe2\\xd7\\xc6\\xc1\\xd7\\xd7@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-03-26T00:00:00", "modifydate": "2019-03-26T11:05:48", "lines": 558, "newlines": 558, "modlines": 0, "user": "ISPFAPP"}, "text": "./ ADD NAME=$$README 0100-19085-19085-0953-00012-00012-00000-SBGOLOB 57\nThis package allows you to view extended SVCs under ISPF.\n\nIngredients:  3 Panels, 1 Rexx exec, 1 Assembler Program\n\nEXEC:    ESVCSCAN    (customize hard-coded panel library name)\n\nPANELS:  ESVCPAN1, ESVCPAN2, ESVCPAN3\n\nASSEMBLER PROGRAM    :  NUCLOOK\nASSEMBLY-LINKEDIT JCL:  NUCLOOK$\n\n\n./ ADD NAME=ESVCPAN1 0100-19085-19085-0152-00030-00030-00000-PANEL   46\n)ATTR\n* TYPE(INPUT)   INTENS(HIGH) COLOR(YELLOW)\n_ TYPE(INPUT)   INTENS(HIGH) COLOR(YELLOW)\n% TYPE(TEXT)    COLOR(RED)\n+ TYPE(TEXT)    COLOR(WHITE)\n# TYPE(OUTPUT)  INTENS(HIGH) COLOR(BLUE)\n? TYPE(OUTPUT)  INTENS(HIGH) COLOR(RED)\n@ TYPE(OUTPUT)  COLOR(RED)\n)BODY WINDOW(52,12)\n%\n%COMMAND ===>_ZCMD      %      SCROLL ===>_AMT   +\n%\n%\n% SVC Table Address =#z        %\n%\n%                          Address In SVC Table\n)MODEL\n  *Z%   ESR= #ESRSVC%          #Z        %\n)INIT\n.ZVARS= '(SVCTABAD,CSEL,ESRADDR)'\n&ZCMD= ' '\n&CSEL= '_'\n.CURSOR= CSEL\n&ZWINTTL=  'Currently Installed ESR SVC''s'\n)REINIT\n&CSEL= '_'\n&ZCMD= ' '\n)PROC\n&CURPOS= .CURSOR\n)END\n./ ADD NAME=ESVCPAN2 0100-19085-19085-0153-00027-00027-00000-PANEL   04\n)ATTR\n_ TYPE(INPUT)   INTENS(HIGH) COLOR(YELLOW)\n% TYPE(TEXT)    COLOR(RED)\n* TYPE(TEXT)    COLOR(YELLOW)\n+ TYPE(TEXT)    COLOR(WHITE)\n# TYPE(OUTPUT)  INTENS(HIGH) COLOR(BLUE)\n? TYPE(OUTPUT)  INTENS(HIGH) COLOR(RED)\n@ TYPE(OUTPUT)  COLOR(RED)\n)BODY WINDOW(77,18)\n%\n%COMMAND ===>_ZCMD      %                           SCROLL ===>_AMT   +\n%\n% ESR=#z       %   No of ESR slots=#z   %   ESR Table Address=#z        %\n%\n* SVC      Module    Module   SVC    NON    AR   APF  Locks\n* ADDR      Name      Loc    Assist Preempt ASC\n%\n)MODEL\n#Z                                                                          %\n)INIT\n.ZVARS= '(SVCTYPE,ESRCNT,ESRRADDR,ESVCENTS)'\n&ZCMD= ' '\n&ZWINTTL=  'ESR SVC Table List'\n)REINIT\n&ZCMD= ' '\n)PROC\n)END\n./ ADD NAME=ESVCPAN3 0100-19085-19085-0153-00023-00023-00000-PANEL   32\n)ATTR\n_ TYPE(INPUT)   INTENS(HIGH) COLOR(YELLOW)\n% TYPE(TEXT)    COLOR(RED)\n* TYPE(TEXT)    COLOR(YELLOW)\n+ TYPE(TEXT)    COLOR(WHITE)\n# TYPE(OUTPUT)  INTENS(HIGH) COLOR(BLUE)\n? TYPE(OUTPUT)  INTENS(HIGH) COLOR(RED)\n@ TYPE(OUTPUT)  COLOR(RED)\n)BODY WINDOW(58,7)\n%\n%COMMAND ===>_ZCMD      %         SCROLL ===>_AMT   +\n%\n%    -------------------------------------------------\n%    |  ESR SVC Table Search In process. Please Wait |\n%    -------------------------------------------------\n%\n)INIT\n&ZCMD= ' '\n&ZWINTTL=  'ESR SVC Table Search'\n)REINIT\n&ZCMD= ' '\n)PROC\n)END\n./ ADD NAME=ESVCSCAN 0102-19085-19085-1058-00287-00285-00000-REXX    51\n/**rexx**/\n/*  Program-id           ESVCSCAN                                  */\n/*  Remarks              Expand the ESR SVC entries                */\n/*trace i*/\nmodaddr=  '00000000'x                    /* initialize variables   */\nmodinfo=  '               '\nmodrc=    '00000000'x\naddress \"ISPEXEC\" \"LIBDEF ISPPLIB DATASET ID('SYS1.U.PANELS')\"\nsvctable:\ncvt=      c2x(storage(10,4))            /* cvt address             */\ncvtabend= d2x((x2d(cvt))+200)           /* cvt + 200 = cvtabend    */\nscvt=     c2x(storage(cvtabend,4))      /* scvt @                  */\nscvtscvt= d2x(x2d(scvt)+132)            /* scvt + 132 = scvtscvt   */\nsvctable= c2x(storage(scvtscvt,4))      /* svctable @              */\nsvctabad= svctable                      /* store for panel output  */\nsvctable_addr_store= svctable           /* store svc table @       */\nesr_svcs.0= 0                           /* set to 0                */\nx= 0                                    /* set to 0                */\ndo i = 0 to 255                         /* process all svc entries */\n   svc_table_addr= d2x(x2d(svctable)+4) /* move onto svcattr1      */\n   svcattr1= storage(svc_table_addr,1)  /* pick up svcattr1        */\n   svcattr=  bitand(svcattr1,'04'x)     /* test for esr svc bit    */\n   if (svcattr = '04'x) then do         /* test for esr svc        */\n      esr_svcs.0= esr_svcs.0 + 1        /* incr no of esrs found   */\n      x= esr_svcs.0                     /* next esr variable       */\n      esr_svcs.x= i                     /* svc no                  */\n      esr_svc_table_addr.x= svctable    /* esr svc table address   */\n   end\n   svctable= d2x(x2d(svctable)+8)       /* next svctable entry     */\nend\ncall esrsvc_menu                        /* display esr svcs found  */\nADDRESS \"ISPEXEC\" \"ADDPOP ROW(3) COLUMN(6)\"  /* pop up position    */\ndo forever                              /* loop forever            */\n   ADDRESS \"ISPEXEC\" \"TBDISPL ESVCTAB PANEL(ESVCPAN1)\"\n   if (rc > 8) then do                  /* error?                  */\n      say 'tbdispl error    rc = 'rc''  /* yes- output message     */\n      ADDRESS \"ISPEXEC\" \"LIBDEF ISPPLIB\" /* remove allocation      */\n      exit(rc)                          /* and quit                */\n   end\n   if (rc = 8) then do                  /* end?                    */\n      ADDRESS \"ISPEXEC\" \"LIBDEF ISPPLIB\" /* remove allocation      */\n      exit(rc)                          /* yes- let's quit         */\n   end\n   do while (ztdsels > 0)               /* user selected a esr svc?*/\n      if (csel = '/') then do           /* user selected an esrsvc?*/\n         call display_esrsvc            /* yes- let's display it   */\n         ztdmark= ' '                   /* no end of table message */\n         leave                          /* back to main menu       */\n      end\n      else\n         leave                          /* back to main menu       */\n   end\nend\nADDRESS \"ISPEXEC\" \"REMPOP\"               /* remove menu popup      */\nADDRESS \"ISPEXEC\" \"LIBDEF ISPPLIB\"       /* remove allocation      */\nexit(0)                                  /* quit                   */\nesrsvc_menu:\nADDRESS \"ISPEXEC\" \"TBCREATE ESVCTAB NOWRITE REPLACE\"\nif (rc >  4) then do                     /* call OK?               */\n   say 'tbcreate error    rc = 'rc''     /* no- inform the user    */\n   ADDRESS \"ISPEXEC\" \"LIBDEF ISPPLIB\"    /* remove allocation      */\n   exit(rc)                              /* let's quit             */\nend\ncsel=       '_'                          /* init                   */\nctype=      ''                           /* init                   */\nesrsvc=     ''                           /* init                   */\nsvcaddr=    ''                           /* init                   */\nztdmark=    ' '                          /* no end of table message*/\nADDRESS \"ISPEXEC\" \"VPUT    (CSEL,ESRSVC,ESRADDR,ZTDMARK) SHARED\"\ntabrows=  100                            /* max table rows         */\ndo i= 1 to esr_svcs.0                    /* add the esr svcs to an */\n   esrsvc= esr_svcs.i                    /* ispf table             */\n   esraddr= esr_svc_table_addr.i         /* addr in svc table      */\n   ADDRESS \"ISPEXEC\" \"TBADD ESVCTAB      /* add the entries        */\n            SAVE(ESRSVC,ESRADDR)\n            MULT(\"TABROWS\")\"\n   if (rc \u00ac= 0) then do                  /* call OK?               */\n      say 'tbadd error    rc = 'rc''     /* no- inform the user    */\n      ADDRESS \"ISPEXEC\" \"LIBDEF ISPPLIB\" /* remove allocation      */\n      exit(rc)                           /* let's quit             */\n   end\nend\nADDRESS \"ISPEXEC\" \"TBTOP ESVCTAB\"        /* position to top of tab */\nif (rc \u00ac= 0) then do                     /* call OK?               */\n   say 'tbtop error    rc = 'rc''        /* no- inform the user    */\n   ADDRESS \"ISPEXEC\" \"LIBDEF ISPPLIB\"    /* remove allocation      */\n   exit(rc)                              /* let's quit             */\nend\nreturn\ndisplay_esrsvc:\nsvctable=  svctable_addr_store          /* store svc table @       */\nsvctable=  x2d(svctable)                /* convert to decimal      */\nesr_svcno= esrsvc                       /* selected esr svc        */\nif (esr_svcno > 0) then                 /* calculate the esr svc   */\n   esr_svcno= (esr_svcno * 8)           /* table entry position    */\nsvctable=  svctable + esr_svcno         /* position onto it        */\nsvctable=  d2x(svctable)                /* back to hex             */\nesr_table_addr= storage(svctable,4)     /* the real esr svc table  */\nesrraddr= c2x(esr_table_addr)           /* convert to hex for dsply*/\nesr_attr_addr=  c2d(esr_table_addr)     /* convert to decimal      */\nesr_cnt_addr=   c2d(esr_table_addr)     /* convert to decimal      */\nesr_cnt_addr=   esr_cnt_addr + 4        /* no of esr slots         */\nesr_cnt_addr=   d2x(esr_cnt_addr)       /* back to hex             */\nesrcnt=  storage(esr_cnt_addr,4)        /* move esr cnt            */\nesrcnt=  c2d(esrcnt)                    /* convert to decimal      */\nesrcnt=  esrcnt + 1                     /* get true value          */\nesr_attr_addr=  esr_attr_addr + 12      /* @ svcattr1              */\nesr_attr_addr=  d2x(esr_attr_addr)      /* back to hex             */\nsvcattr=  storage(esr_attr_addr,4)      /* move esr svcattr        */\ncall calc_svc_type                      /* calculate svc type      */\nesr_svcs_addr=  c2d(esr_table_addr)     /* position onto the       */\nesr_svcs_addr=  esr_svcs_addr + 8       /* first esr svc           */\nesr_svcs_addr=  d2x(esr_svcs_addr)      /* back to hex             */\nADDRESS \"ISPEXEC\" \"ADDPOP ROW(3) COLUMN(1)\"  /* pop up position    */\nADDRESS \"ISPEXEC\" \"CONTROL DISPLAY LOCK\" /* lock the terminal      */\nif (rc > 8) then do                      /* error?                 */\n   say 'Lock error    rc = 'rc''         /* yes- output message    */\n   ADDRESS \"ISPEXEC\" \"LIBDEF ISPPLIB\"    /* remove allocation      */\n   exit(rc)                              /* and quit               */\nend\nADDRESS \"ISPEXEC\" \"DISPLAY PANEL(ESVCPAN3)\"\nif (rc > 8) then do                      /* error?                 */\n   say 'Display error    rc = 'rc''      /* yes- output message    */\n   ADDRESS \"ISPEXEC\" \"LIBDEF ISPPLIB\"    /* remove allocation      */\n   exit(rc)                              /* and quit               */\nend\ncall create_esr_svc_entries              /* create table of esrs   */\nreturn\ncalc_svc_type:                           /* calculate the svc type */\ndo forever                               /* do forever             */\n   svcattr1= substr(svcattr,1,1)         /* svctp                  */\n   svcattr1= bitand(svcattr1,'F0'x)      /* test for type 1        */\n   if (svcattr1 = '00'x) then do         /* type 1 svc?            */\n      svctype= 'Type 1  '                /* yes                    */\n      leave                              /* all done               */\n   end\n   svcattr1= substr(svcattr,1,1)         /* svctp                  */\n   svcattr1= bitand(svcattr1,'C0'x)      /* test for type 3/4      */\n   if (svcattr1 = 'C0'x) then do         /* type 3/4 svc?          */\n      svctype= 'Type 3/4'                /* yes                    */\n      leave                              /* all done               */\n   end\n   svcattr1= substr(svcattr,1,1)         /* svctp                  */\n   svcattr1= bitand(svcattr1,'80'x)      /* test for type 2        */\n   if (svcattr1 = '80'x) then do         /* type 2 svc?            */\n      svctype= 'Type 2  '                /* yes                    */\n      leave                              /* all done               */\n   end\n   svcattr1= substr(svcattr,1,1)         /* svctp                  */\n   svcattr1= bitand(svcattr1,'20'x)      /* test for type 6        */\n   if (svcattr1 = '20'x) then do         /* type 6 svc?            */\n      svctype= 'Type 6  '                /* yes                    */\n      leave                              /* all done               */\n   end\nleave                                    /* all done               */\nend\nreturn                                   /* return to caller       */\ncreate_esr_svc_entries:                  /* create table of esrs   */\nADDRESS \"ISPEXEC\" \"TBCREATE ESVCESRS NOWRITE REPLACE\"\nif (rc >  4) then do                     /* call OK?               */\n   say 'tbcreate error    rc = 'rc''     /* no- inform the user    */\n   ADDRESS \"ISPEXEC\" \"LIBDEF ISPPLIB\"    /* remove allocation      */\n   exit(rc)                              /* let's quit             */\nend\nztdmark= '*******      End OF ESR SVC Table Entries       *******'\nADDRESS \"ISPEXEC\" \"VPUT    (ESVCENTS,ZTDMARK) SHARED\"\nztdmark= ' '         /* get rid of annoying \"persistent\" message   */\nADDRESS \"ISPEXEC\" \"VPUT    (ZTDMARK) SHARED\"\ntabrows=  100                            /* max table rows         */\ndo i = 1 to esrcnt                       /* process all esr entries*/\n   esvcents= ' '                         /* init table variable    */\n   modaddr=  storage(esr_svcs_addr,4)    /* esr svc @              */\n   ADDRESS \"LINKPGM\" \"NUCLOOK MODADDR MODINFO MODRC\"\n   mrc= c2d(modrc)                       /* convert rc to decimal  */\n   if (mrc /= 0) then do                 /* call OK?               */\n      say 'NUCLOOK Error  rc = 'mrc' --- Module Info= 'modinfo''\n      ADDRESS \"ISPEXEC\" \"LIBDEF ISPPLIB\" /* remove allocation      */\n      exit(mrc)                          /* return to caller       */\n   end\n   esvcents= c2x(modaddr)                /* module address         */\n   esvcents= esvcents||' '               /* space                  */\n   esvcents= esvcents||substr(modinfo,1,8)  /* module name         */\n   esvcents= esvcents||'  '              /* spaces                 */\n   esvcents= esvcents||substr(modinfo,9,7)  /* module location     */\n   if substr(modinfo,1,8) = 'IEAVESVC' then do /* spare entry?     */\n                                         /* yes-                   */\n      esvcents= esvcents||'   *** Entry is available ***'\n   end\n   else do\n      esr_svcs_addr2=  x2d(esr_svcs_addr) /* position onto the     */\n      esr_svcs_addr2=  esr_svcs_addr2 + 4 /* svcattr1 field        */\n      esr_svcs_addr2=  d2x(esr_svcs_addr2) /* back to hex          */\n      svcattr1= storage(esr_svcs_addr2,4) /* svcattr1 word         */\n      call examine_svcattr1               /* examine svc attributes*/\n      esvcents= esvcents||'    '||svcassit /* svc assist            */\n      esvcents= esvcents||'   '||nonpremp /* non-premptive svc   */\n      esvcents= esvcents||'    '||arasc   /* ar asc svc            */\n      esvcents= esvcents||'  '||apfmode   /* apf mode              */\n      esvcents= esvcents||'  '||locks     /* locks                 */\n   end\n   esr_svcs_addr=  x2d(esr_svcs_addr)     /* position onto the     */\n   esr_svcs_addr=  esr_svcs_addr + 8      /* next esr svc          */\n   esr_svcs_addr=  d2x(esr_svcs_addr)     /* entry                 */\n   ADDRESS \"ISPEXEC\" \"TBADD ESVCESRS      /* add the entries       */\n            SAVE(ESVCENTS)\n            MULT(\"TABROWS\")\"\n   if (rc \u00ac= 0) then do                 /* call OK?                */\n      say 'tbadd error    rc = 'rc''    /* no- inform the user     */\n      ADDRESS \"ISPEXEC\" \"LIBDEF ISPPLIB\" /* remove allocation      */\n      exit(rc)                          /* let's quit              */\n   end\nend\nADDRESS \"ISPEXEC\" \"TBTOP ESVCESRS\"      /* position to top of tab  */\nif (rc \u00ac= 0) then do                    /* call OK?                */\n   say 'tbtop error    rc = 'rc''       /* no- inform the user     */\n   ADDRESS \"ISPEXEC\" \"LIBDEF ISPPLIB\"   /* remove allocation       */\n   exit(rc)                             /* let's quit              */\nend\nADDRESS \"ISPEXEC\" \"REMPOP\"              /* remove lock popup       */\nADDRESS \"ISPEXEC\" \"ADDPOP ROW(3) COLUMN(1)\"  /* pop up position    */\nADDRESS \"ISPEXEC\" \"TBDISPL ESVCESRS PANEL(ESVCPAN2)\"\nif (rc > 8) then do                     /* error?                  */\n   say 'tbdispl error    rc = 'rc''     /* yes- output message     */\n   ADDRESS \"ISPEXEC\" \"LIBDEF ISPPLIB\"   /* remove allocation       */\n   exit(rc)                             /* and quit                */\nend\nADDRESS \"ISPEXEC\" \"REMPOP\"              /* remove popup            */\nreturn\nexamine_svcattr1:                       /* examine svc attributes  */\nnonpremp= 'No '                         /* default for non-prempt  */\nsvcattr= substr(svcattr1,1,1)           /* svcattr1                */\nsvcattr= bitand(svcattr,'02'x)          /* test for non-prempt     */\nif (svcattr = '02'x) then do            /* non-prempt svc?         */\n   nonpremp= 'Yes'                      /* yes                     */\nend\nsvcassit= 'No '                         /* default for svc assist  */\nsvcattr= substr(svcattr1,1,1)           /* svcattr1                */\nsvcattr= bitand(svcattr,'01'x)          /* test for svc assist     */\nif (svcattr = '01'x) then do            /* svc assist svc?         */\n   svcassit= 'Yes'                      /* yes                     */\nend\narasc= 'No '                            /* default for ar asc mode */\nsvcattr= substr(svcattr1,2,1)           /* svcattr3                */\nsvcattr= bitand(svcattr,'80'x)          /* test for asc mode?      */\nif (svcattr = '80'x) then do            /* svc ar asc?             */\n   arasc= 'Yes'                         /* yes                     */\nend\napfmode= 'No '                          /* default for ar apfmode  */\nsvcattr= substr(svcattr1,1,1)           /* svcattr3                */\nsvcattr= bitand(svcattr,'08'x)          /* test for apf?           */\nif (svcattr = '08'x) then do            /* apf?                    */\n   apfmode= 'Yes'                       /* yes                     */\nend\nlocks= ''                               /* default for locks       */\nsvcattr= substr(svcattr1,3,1)           /* svclocks                */\nsvcattr= bitand(svcattr,'80'x)          /* test for local lock     */\nif (svcattr = '80'x) then do            /* local lock?             */\n   locks= 'LL,'                         /* yes                     */\nend\nsvcattr= substr(svcattr1,3,1)           /* svclocks                */\nsvcattr= bitand(svcattr,'40'x)          /* test for cms lock       */\nif (svcattr = '40'x) then do            /* cms lock?               */\n   locks= locks||'CMS,'                 /* yes                     */\nend\nsvcattr= substr(svcattr1,3,1)           /* svclocks                */\nsvcattr= bitand(svcattr,'20'x)          /* test for SRM lock       */\nif (svcattr = '20'x) then do            /* srm lock?               */\n   locks= locks||'OPT,'                 /* yes                     */\nend\nsvcattr= substr(svcattr1,3,1)           /* svclocks                */\nsvcattr= bitand(svcattr,'10'x)          /* test for salloc lock?   */\nif (svcattr = '10'x) then do            /* salloc lock?            */\n   locks= locks||'SALLOC,'              /* yes                     */\nend\nsvcattr= substr(svcattr1,3,1)           /* svclocks                */\nsvcattr= bitand(svcattr,'08'x)          /* test for disp lock,     */\nif (svcattr = '08'x) then do            /* disp lock?              */\n   locks= locks||'DISP'                 /* yes                     */\nend\nlen= length(locks)                      /* obtain length of locks  */\nif (len > 0) then do                    /* length > 0?             */\n   comma= substr(locks,len,1)           /* obtain last character   */\n   if (comma = ',') then do             /* is it a comma?          */\n      locks= overlay(' ',locks,len,1)   /* remove the last comma   */\n   end\nend\nreturn\n./ ADD NAME=NUCLOOK  0101-19085-19085-0157-00143-00142-00000-ASSMBLR 22\n         TITLE 'RETRIEVE EP NAME IN NUCLEUS, FLPA MLPA OR PLPA'\nZERO     EQU   X'00'                   ZERO\nSPACE    EQU   C' '                    SPACE\nSIGNF    EQU   X'F0'                   POSITIVE SIGN\n         YREGS\nNUCLOOK  CSECT\nNUCLOOK  AMODE 31\nNUCLOOK  RMODE 24\n         BAKR  R14,0                   SAVE CALLER'S ARS + GPRS\n*                                      IN THE LINKAGE STACK\n         USING NUCLOOK,R12             SET UP PROGRAM BASE REGISTER\n         LAE   R12,0(R15,0)             SET UP PROGRAM BASE REGISTER\n         LM    R3,R5,0(R1)              PARAMETERS\n         USING MODADDR,R3               MODULE ADDRESS\n         USING MODINFO,R4               MODULE INFORMATION\n         USING RETURNCD,R5              RETURN CODE\nGETWORK  EQU   *\n         L     R9,=AL4(WORKALEN)        WORK AREA LENGTH\n         STORAGE OBTAIN,LENGTH=(R9),ADDR=(R10),SP=0,KEY=8,             X\n               LOC=BELOW,COND=NO,RELATED=(FREEWORK,'FREE WORK AREA')\n         LR    R13,R1                   @ THE WORKAREA\n         USING SAVEAREA,R13             INFORM THE ASSEMBLER\n         LA    R0,SAVEAREA              @ THE WORKAREA\n         LA    R1,WORKALEN(0,0)         LENGTH\n         LA    R14,=X'00'               ZERO FILL\n         SR    R15,R15                  PROPAGATE\n         MVCL  R0,R14                   CLEAR THE AREA\n         MVC   PREVSA,=C'F1SA'          PUT ACRONYM INTO SAVEAREA\n*                                       TO INDICATE STATUS SAVED ON\n*                                       THE LINKAGE STACK.\n         TITLE 'MAIN PROGRAM CONTROL'\nCONTROL  EQU   *\n         XC    RC,RC                    CLEAR THE RETURN CODE\n         MVC   MODNAME,=8C' '           CLEAR THE RETURN NAME\n         MVC   MODLOC,=7C' '            CLEAR THE RETURN LOCATION\n         BAS   R2,PARMCHK               CHECK THE MODULE ADDRESS\n         LTR   R15,R15                  GOOD RETURN CODE?\n         BNZ   RETURN                   NO- LET'S RETURN TO CALLER\n         BAS   R2,NUCMOD                CHECK FOR NUCLEUS MODULE\n         CH    R15,=H'4'                GOOD RETURN CODE?\n         BH    RETURN                   NO- LET'S RETURN TO CALLER\n         BL    RETURN                   MODULE FOUND IN THE NUC\n         BAS   R2,CMNMOD                CHECK FOR COMMON MODULE\nRETURN   EQU   *\n         LAE   R1,0(R13,0)              ADDRESS TO FREE\n         L     R9,=AL4(WORKALEN)        WORK AREA LENGTH\n         STORAGE RELEASE,ADDR=(R1),LENGTH=(R9),SP=0,KEY=8,             X\n               COND=NO,RELATED=(GETWORK,'OBTAIN WORK AREA')\n         SLR   R15,R15                  SET RC TO ZERO\n         PR                             RESTORE CALLER'S ARS\n*                                       GPRS 2-14 AND RETURN\n*                                       TO CALLER\nPARMCHK  EQU   *                        CHECK MODULE ADDRESS\n         LA    R15,0(0,0)               GOOD ADDRESS\n         ICM   R6,B'1111',MADDR         MODULE ADDRESS\n         N     R6,=X'7FFFFFFF'          TURN OFF 31-BIT MODE\n         LTR   R6,R6                    NON-ZERO @?\n         BNZR  R2                       YES-\n         LA    R15,40(0,0)              BAD ADDRESS\n         STCM  R15,B'1111',RC           INFORM THE USER\n         BR    R2                       RETURN TO CALLER\nNUCMOD   EQU   *                        SEE IF MODULE IS IN THE NUCLEUS\n         L     R6,MADDR                 MODULE ADDRESS\n         LA    R7,CSECTNAM              NAME OF CSECT RETURNED\n         NUCLKUP BYADDR,NAME=(R7),ADDR=(R6)\n         LTR   R15,R15                  NAME RETURNED?\n         BNZ   NSETRC                   NO-\n         MVC   MODNAME,CSECTNAM         RETURN MODULE NAME TO CALLER\n         MVC   MODLOC,=CL7'NUCLEUS'     MODULE FOUND IN NUCLEUS\n         STCM  R15,B'1111',RC           INFORM THE USER\n         BR    R2                       RETURN TO CALLER\nNSETRC   EQU   *\n         CH    R15,=H'8'                CALL ERROR?\n         BLR   R2                       NO-\n         STCM  R15,B'1111',RC           INFORM THE USER\n         MVC   MODNAME,=CL8'NUCLKUP '   MACRO WITH ERROR\n         BR    R2                       RETURN TO CALLER\nCMNMOD   EQU   *                    SEE IF MODULE IS IN THE COMMON AREA\n         MVC   CSVQRY,CSVQARA           MOVE CSVQUERY LIST\n         LA    R6,MADDR                 MODULE ADDRESS\n         LA    R7,CSVQRY                MACRO AREA\n         CSVQUERY INADDR=(R6),SEARCH=LPA,OUTEPNM=CSECTNAM,             X\n               OUTATTR3=ATTR3,OUTVALID=PARMOK,MF=(E,(R7),COMPLETE)\n         LTR   R15,R15                  NAME RETURNED?\n         BNZ   CSETRC                   NO-\n         STCM  R15,B'1111',RC           INFORM THE USER\nTESTATTR EQU   *\n         MVC   MODNAME,CSECTNAM         RETURN MODULE NAME TO CALLER\n         MVC   MODLOC,=CL7'PLPA   '     PLPA RESIDENT\n         TM    ATTR3,ATTR3B2            PLPA?\n         BOR   R2                       YES\n         MVC   MODLOC,=CL7'MLPA   '     MLPA RESIDENT\n         TM    ATTR3,ATTR3B3            MLPA?\n         BOR   R2                       YES\n         MVC   MODLOC,=CL7'FLPA   '     FLPA RESIDENT\n         TM    ATTR3,ATTR3B4            MLPA?\n         BOR   R2                       YES\n         MVC   MODLOC,=CL7'CSA    '     CSA  RESIDENT\n         TM    ATTR3,ATTR3B5            CSA?\n         BOR   R2                       YES\n         BR    R2                       RETURN TO CALLER\nCSETRC   EQU   *\n         CH    R15,=H'4'                MODULE FOUND INFO MISSING?\n         BNE   TSTR8                    YES-\n         MVC   MODNAME,CSECTNAM         RETURN MODULE NAME TO CALLER\n         MVC   RC,=F'44'                INFORM THE USER\n         B     TESTATTR                 RETURN MODULE NAME TO CALLER\nTSTR8    EQU   *\n         STCM  R15,B'1111',RC           INFORM THE USER\n         CH    R15,=H'8'                MODULE NOT FOUND?\n         BNE   CSVERR                   YES-\n         MVC   RC,=F'48'                INFORM THE USER\n         BR    R2                       RETURN TO CALLER\nCSVERR   EQU   *\n         MVC   MODNAME,=CL8'CSVQUERY'   MACRO WITH ERROR\n         BR    R2                       RETURN TO CALLER\n         LTORG\n         CSVQUERY MF=(L,CSVQARA)        CSVQUERY LIST AREA\nWORKAREA DSECT\nSAVEAREA DS    CL72                     SAVEAREA\nPREVSA   EQU   SAVEAREA+4,4             @ OF PREVIOUS SAVEAREA\nCSVQRY   DS    CL(CSVQARAL)             CSVQUERY AREA\nCSECTNAM DS    CL8                      RETURNED CSECT NAME\nATTR3    DS    X                        ATTRIBUTE 3\nATTR3B0  EQU   X'80'                    RESIDENT ABOVE 16 MEG LINE\nATTR3B1  EQU   X'40'                    JOB PACK AREA RESIDENT\nATTR3B2  EQU   X'20'                    PLPA RESIDENT\nATTR3B3  EQU   X'10'                    MLPA RESIDENT\nATTR3B4  EQU   X'08'                    FLPA RESIDENT\nATTR3B5  EQU   X'04'                    CSA  RESIDENT\nATTR3B6  EQU   X'02'                    NOT PART OF INTERFACE\nATTR3B7  EQU   X'01'                    NOT PART OF INTERFACE\nPARMOK   DS    F                        VALID DATA FIELD\nWORKALEN EQU   *-WORKAREA               WORK AREA LENGTH\nMODADDR  DSECT\nMADDR    DS    XL4                      MODULE ADDRESS\nMODINFO  DSECT\nMODNAME  DS    CL8                      MODULE NAME\nMODLOC   DS    CL7                      MODULE LOCATION\nRETURNCD DSECT\nRC       DS    XL4                      RETURN CODE\n         CVT   DSECT=YES,LIST=NO\n         END   NUCLOOK\n./ ADD NAME=NUCLOOK$ 0109-95148-19085-0156-00029-00022-00000-ASMLJCL 42\n//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,ESD,RLD,NOXREF)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(NUCLOOK)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET,RENT,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD *\n INCLUDE OBJECT\n SETCODE AC(1)\n SETSSI CB497836\n ENTRY NUCLOOK\n NAME  NUCLOOK(R)\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FINDSYSI": {"ttr": 1541, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x08\\x01\\x10 o\\x01\\x10#\\x7f\\x10 \\x00\\xf9\\x00\\xc6\\x00\\x00\\xc6\\xc9\\xe7\\xc5\\xc4\\xf0\\xc4@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2010-07-25T00:00:00", "modifydate": "2010-08-25T10:20:08", "lines": 249, "newlines": 198, "modlines": 0, "user": "FIXED0D"}, "text": "Some useful fields in MVS control blocks\n\nIt is sometimes useful for a program to be able to find out its own job\nname and job number, the name of the system it is running on, and so on.\nThis sort of information might be required, for example, for inclusion\nin console messages and reports, or by a suite of programs that keeps\nits own log of jobs as they are run.\n\nThis article presents some techniques for locating such information,\ntogether with some fragments of Assembler code that will show how to\nfind the relevant control blocks.\n\nFor the purposes of illustration, all the examples use absolute decimal\nvalues for control block offsets.  Although the use of explicit base and\ndisplacements is not usually considered good coding practice, it can\nsafely be used in most of the cases given here, since most the fields\nquoted in this article are in very well established MVS control blocks,\nand in most cases their offsets have not changed since the first release\nof MVS over 12 years ago.  For those who prefer to use the appropriate\nmapping macros, the field names have been included as comments against\nthe code.\n\nThe starting point for finding most of the control blocks associated\nwith a job is either the Address Space Control Block (ASCB) or the Task\nControl Block (TCB).  These are the fundamental control blocks\nassociated with a running job.  There is one ASCB for each address space\n(ie each job, started task, and TSO user) in the system.  ASCBs are in\ncommon storage (SQA), therefore any job in the system can look at the\nASCBs for all the other jobs currently running.\n\nThere is one TCB for each task running in the address space.  TCBs are\nheld within the address space (in LSQA) and are therefore accessible\nonly to programs running within the same address space.  In common with\nmost of the useful control blocks, neither the ASCB nor the TCB is\nfetch-protected.\n\nIn the PSA of each processor there is an area of storage called the\nTCBWORDS.  This area is four words long and defines the currently\ndispatched task: the second word contains the current TCB address and\nthe fourth word contains the ASCB address.  The first word of the CVT\npoints to the TCBWORDS.  Thus, a program can always find its own ASCB\nand TCB address by this sequence of code:\n\n         L     R2,16                POINT TO CVT (CVTPTR)\n         L     R2,0(,R2)            POINT TO TCBWORDS (CVTTCBP)\n         L     R3,4(,R2)            POINT TO CURRENT TCB\n         L     R4,12(,R2)           POINT TO CURRENT ASCB\n\nHOW TO FIND THE CURRENT JOB NAME OR TSO USER-ID\n\nA program running as a batch job can find its job name from the TIOT.\nThe TIOT is pointed to by the TCB.  The first three double words of the\nTIOT contain the job name, step name, and procedure step name.  A\nprogram running under TSO will find the TSO user-id in the first double\nword of the TIOT in place of the job name; the second double word\ncontains the name of the log-on procedure.\n\n         L     R2,16                POINT TO CVT (CVTPTR)\n         L     R2,0(,R2)            POINT TO TCBWORDS (CVTTCBP)\n         L     R2,4(,R2)            POINT TO TCB\n         L     R2,12(,R2)           POINT TO TIOT (TCBTIO)\n         MVC   JOBNAME(8),0(R2)     COPY JOBNAME FROM TIOT\n         MVC   STEPNAME(8),8(R2)    COPY STEPNAME FROM TIOT\n\nHOW TO FIND THE CURRENT JOB NUMBER\n\nIt is sometimes useful for a program to know the identifier by which its\njob is known to the job entry subsystem (in a JES2 system this is the\nJOB number, STC number, or TSU number).  The job identifier is held in\nthe life-of-job SSIB, which is the control block that identifies the job\nto JES when calls are made via the subsystem interface.  The life-of-job\nSSIB is accessed from the JSCB, as in the following sample code:\n\n         L     R2,16                POINT TO CVT\n         L     R2,0(,R2)            TO TCBWORDS\n         L     R2,4(,R2)            TO TCB\n         L     R2,180(,R2)          TO JSCB (TCBJSCB)\n         L     R2,348(,R2)          TO ACTIVE JSCB (JSCBACT)\n         ICM   R2,15,316(R2)        TO LIFE-OF-JOB SSIB (JSCBSSIB)\n         BZ    NOID                 (SKIP IF NO LOJ SSIB)\n         MVC   JOBID(8),12(R2)      COPY JOB NUMBER (SSIBJBID)\nNOID     EQU   *\n\nHOW TO FIND A TSO USER'S TERMINAL-ID\n\nThe VTAM LU name of a TSO user's terminal is held in a control block\ncalled the Terminal Status Block (TSB).  The TSB is pointed to by the\nTSO user's ASCB.  The TSB is in fetch-protected CSA storage, therefore\nit can be read only by an APF-authorised program, which has set itself\ninto the correct key using the MODESET macro instruction.  The following\ncode illustrates how a program running in a TSO user's address space can\nfind its own terminal name:\n\n         L     R2,16                POINT TO CVT (CVTPTR)\n         L     R2,0(,R2)            TO TCBWORDS (CVTTCBP)\n         L     R2,12(,R2)           TO CURRENT ASCB\n         ICM   R2,15,60(R2)         TO TSB (ASCBTSB)\n         BZ    NOTTSO               (SKIP IF NOT TSO USER)\n         MODESET KEY=ZERO           ENTER KEY ZERO\n         MVC   TERMID(8),104(R2)    COPY TERMINAL NAME (TSBTRMID)\n         MODESET KEY=NZERO          REVERT TO NORMAL KEY\nNOTTSO   EQU    *\n\nTo find the terminal name of another TSO user, it is first necessary to\nlocate that user's ASCB.  This can be done by scanning the CSCB chain,\nas shown later in this article.  From the ASCB, the user's TSB can be\nfound.\n\nHOW TO FIND THE SYSTEM-ID\n\nA four-character system identifier is assigned at IPL time by SMF\ninitialisation.  This system-id is specified in the SMFPRMxx member of\nSYS1.PARMLIB.  The primary purpose of the SMF system-id is to identify\nwhich system produced each SMF record.  More significantly, the SMF\nsystem-id is used by JES2 to identify the individual systems in a\nmulti-access spool (MAS) complex.  The SMF system-id appears in certain\nJES2 messages and commands, and in the lock record in the JES2\nCheckpoint Dataset.  The SMF system-id can be found in the System\nManagement Control Area (SMCA), which is the primary control block for\nSMF.  The SMCA can be found from the CVT as in the following code:\n\n         L     R2,16                POINT TO CVT\n         L     R2,196(,R2)          POINT TO SMCA (CVTSMCA)\n         MVC   SYSID(4),16(R2)      COPY SMF-ID (SMCASID)\n\nHOW TO FIND THE MVS RELEASE NUMBER\n\nThe CVT contains the FMID of the base control program (for example\nJBB2217 for MVS/XA 2.1.7).  This identifier is held in the CVT prefix at\nCVT-32.  The CVT also contains an indication of the operating system\ntype (ie VS1, MVS, MVS/XA, etc).  This is held in a one-byte field at\nCVT+116.  This byte contains X'13' for MVS, and X'93' for MVS/XA.\n\nThe following code illustrates access to these fields:\n\n         L     R2,16                POINT TO CVT (CVTPTR)\n         TM    116(R2),X'80'        IS IT XA? (TM CVTDCB,CVTMVSE)\n         BZ    NOTXA                NO - SKIP\n         ...  (put XA specific code here)\nNOTXA    SH   R2,=H'256             POINT TO CVT PREFIX (CVTFIX)\n         MVC  FMID(8),224(R2)       COPY FMID (CVTPRODI)\n\nHOW TO FIND THE SYSRES VOLUME SERIAL\n\nThe device address and volume serial number of the unit that the system\nwas IPLed from are contained in the Unit Control Block for the system\nresidence volume (the SYSRES UCB).  The CVT contains the address of the\nSYSRES UCB.  The following example shows how to find the SYSRES unit and\nvolume serial number:\n\n         L     R2,16                POINT TO CVT (CVTPTR)\n         L     R2,48(,R2)           POINT TO SYSRES UCB (CVTSYSAD)\n         MVC   UNIT(3),13(R2)       COPY UNIT ADDRESS (UCBNAME)\n         MVC   VOL(6),28(R2)        COPY VOLUME SERIAL (UCBVOLI)\n\nHOW TO FIND THE NAMES OF ALL EXECUTING JOBS\n\nEach job, started task, and TSO user currently in the system has a\ncontrol block called a Command Scheduling Control Block (CSCB).  This is\nthe control block that the master scheduler uses to locate the job when\nan operator CANCEL command is issued.  Each CSCB contains the job name,\nstarted task-id, or TSO user-id.  It also contains the job's address\nspace-id (ASID), which can be used as an index into the address space\nvector table to locate the job's ASCB.\n\nThe CSCBs are chained together in the SQA (common storage).  The head of\nthe chain is pointed to by a control block called the Master Scheduler\nResident Data Area (whose acronym, strangely, is BASEA).\n\nThe following code illustrates how to scan the CSCB chain to find the\nASCB for a job called FRED:\n\n         L     R2,16                POINT TO CVT (CVTPTR)\n         L     R3,148(,R2)          TO BASEA (CVTMSER)\n         L     R3,0(,R3)            TO 1ST CSCB (BACHN)\nNEXTCSCB EQU  *\n         CLC   8(8,R3),=CL8'FRED'   IS THIS OUR CSCB (CHKEY)\n         BE    GOTIT                YES - EXIT SCAN\n         L     R3,0(R3)             TO NEXT CSCB (CHPTR)\n         LTR   R3,R3                END OF CSCB CHAIN?\n         BNZ   NEXTCSCB             NO - CONTINUE SCAN\n         B     NOTFOUND             EXIT - JOB NOT FOUND\nGOTIT    DS    0H\n         LH    R5,30(,R3)           ASID FROM CSCB (CHASID)\n         SLL   R5,2                 X 4\n         L     R6,556(,R2)          POINT TO ASVT (CVTASVT)\n         L     R6,524(R5,R6)        GET ASCB ADDR FROM ASVT\n         ...\n*       (R5 now contains the ASID and R6 points to the ASCB)\n\nThis example would be better coded with the use of mapping macros to\nprovide symbolic field names, as shown below:\n\n         L     R2,CVTPTR            POINT TO CVT\n         USING CVTMAP,R2            CVT ADDRESSABILITY\n         L     R3,CVTMSER           POINT TO BASEA (MASTER SCHEDULER\n         USING BASE,R3              RESIDENT DATA AREA)\n         L     R3,BACHN             POINT TO 1ST CSCB\n         USING CHAIN,R3             CSCB ADDRESSABILITY\nNEXTCSCB EQU   *\n         CLC   CHKEY,=CL8'FRED'     IS THIS OUR CSCB\n         BE    GOTIT                YES - EXIT SCAN\n         L     R3,CHPTR             TO NEXT CSCB\n         LTR   R3,R3                END OF CSCB CHAIN?\n         BNZ   NEXTCSCB             NO - CONTINUE SCAN\n         B     NOTFOUND             EXIT - JOB NOT FOUND\nGOTIT    DS    0H\n         LH    R5,CHASID            ASID FROM CSCB\n         SLL   R5,2                 X 4\n         L     R6,CVTASVT           POINT TO ASVT\n         USING ASVT,R6              ASVT ADDRESSABILITY\n         L     R6,ASVTENTY-4(R5)    GET ASCB ADDR FROM ASVT\n         USING ASCB,R6              ADDRESSABILITY TO ASCB\n         ...\n*        (R5 now contains the ASID and R6 points to the ASCB)\n\nThe following mapping macros will be needed if symbolic fields names are\nused:\n\n         CVT   DSECT=YES            CVT\n         IEEBASEA ,                 MASTER SCHEDULER        *\n                                       RESIDENT DATA AREA\n         IEECHAIN ,                 CSCB\n         IHAASVT ,                  ASVT\n         IHAASCB ,                  ASCB\n\nThese macros are in SYS1.AMODGEN on the MVS distribution library\nvolumes.  It will be necessary therefore to ensure that SYS1.AMODGEN is\nincluded in the SYSLIB concatenation in the JCL used to assemble the\nprogram.\n\nWHERE TO FIND MORE INFORMATION\n\nFull details of all the control blocks mentioned in this article can be\nfound in the manuals listed below.\n\nFor MVS/SP Version 1 (MVS/370):\nOS/VS2 SPL: Debugging Handbook, Vol 2-3, GC28-1048-9.\nFor MVS/SP Version 2 (MVS/XA):\nMVS/XA Debugging Handbook, Vol 2-5, LC28-1165-8.\n\nRoger Bowler (UK)   \u20ac Roger Bowler 1988\n\n\n\n\n\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GETDEVNM": {"ttr": 1546, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x08\\x01\\x19\\t\\x1f\\x01\\x19\\t\\x1f\\x184\\x01\\x06\\x01\\x06\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-04-01T00:00:00", "modifydate": "2019-04-01T18:34:08", "lines": 262, "newlines": 262, "modlines": 0, "user": "REXX"}, "text": "/**rexx**/\n/*  PROGRAM-ID           GETDEVNM                                  */\n/*  Remarks              This REXX exec will return the unit       */\n/*                       number for a volume.                      */\n/*trace i*/\nsave_prompt = prompt(\"off\")\ndnum= '    '                                /* device number       */\nstatus= '       '                           /* device status       */\nretcode= '00000000'x                        /* ucbscan return code */\npathinfo= '                                                '\nreason_code= '00000000'x                    /* ucbscan reason code */\naddress \"ISPEXEC\" \"LIBDEF ISPPLIB DATASET ID('SYS1.U.PANELS')\"\nmain_processing_loop:\ndo forever\n   call display_the_volume_panel            /* display vol panel   */\n   ADDRESS \"ISPEXEC\" \"REMPOP\"               /* remove pop-up       */\nend\ndisplay_the_volume_panel:\nADDRESS \"ISPEXEC\" \"ADDPOP ROW(1) COLUMN(2)\" /* pop-up position  */\nADDRESS \"ISPEXEC\" \"DISPLAY PANEL(GETDEVP1)\"\nif (rc > 8) then do                         /* error?              */\n   say 'Display error    rc = 'rc''         /* yes- output message */\n   ADDRESS \"ISPEXEC\" \"LIBDEF ISPPLIB\"       /* remove allocation   */\n   exit(0)                               /* and quit               */\nend\nif (rc = 8) then do                      /* return?                */\n   ADDRESS \"ISPEXEC\" \"REMPOP\"            /* remove pop-up          */\n   ADDRESS \"ISPEXEC\" \"LIBDEF ISPPLIB\"    /* remove allocation      */\n   exit(0)                               /* and quit               */\nend\ncall Lets_Lock_The_Terminal              /* lock the terminal      */\nADDRESS \"LINKPGM\" \"GETUADDR  volser dnum status pathinfo retcode reason_code\"\nif (retcode > '00000000'x) then do\n   ADDRESS \"ISPEXEC\" \"REMPOP\"            /* remove pop-up          */\n   call display_error_panel              /* display the error panel*/\n   return                                /* return to caller       */\nend\nADDRESS \"ISPEXEC\" \"TBCREATE DEVNTAB NOWRITE REPLACE\"\nif (rc >  4) then do                     /* call okay?             */\n   say 'tbcreate error    rc = 'rc''     /* no- inform the user    */\n   ADDRESS \"ISPEXEC\" \"LIBDEF ISPPLIB\"    /* remove allocation      */\n   exit(0)                               /* let's quit             */\nend\nztdmark= ' '\nADDRESS  \"ISPEXEC\" \"VPUT    (ztdmark) SHARED\"\ntabrows=  9999                           /* max table rows         */\nx= 16                                    /* starting position      */\nno_of_chpids= x2d(c2x(substr(pathinfo,12,4)))\nif (no_of_chpids = 0) then do\n   ADDRESS \"ISPEXEC\" \"REMPOP\"             /* remove pop-up         */\n   pinfo= '***  No Paths Defined ***'     /* inform user           */\n   ADDRESS \"ISPEXEC\" \"ADDPOP ROW(1) COLUMN(5)\" /* pop-up position  */\n   ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(getdevp3)\"\n   if (rc > 8) then do                    /* error?                */\n      say 'Display error    rc = 'rc''    /* yes- output message   */\n      ADDRESS \"ISPEXEC\" \"LIBDEF ISPPLIB\"  /* remove allocation     */\n      exit(0)                             /* and quit              */\n   end\n   ADDRESS \"ISPEXEC\" \"REMPOP\"             /* remove pop-up         */\n   return                                 /* return to caller      */\nend\nsms= 'YES'                                /* set sms to yes        */\nif  substr(pathinfo,1,1) = 'N' then       /* sms device?           */\n    sms= 'NO '                            /* no-                   */\nvstatus= ' '                              /* init                  */\nselect                                    /* determine vol status  */\n    when status = 'ONLINE'  then\n          vstatus= 'Online  '\n    when status = 'OFFLINE'  then\n          vstatus= 'Offline  '\n    when status = 'PENDING'  then\n          vstatus= 'Pending Offline  '\n   otherwise\n          nop\nend\nselect                                   /* volume allocation      */\n    when substr(pathinfo,5,1) = 'Y' then\n          vstatus= vstatus||'Alloc  '\n    when substr(pathinfo,5,1) = 'N' then\n          vstatus= vstatus||'Not-Alloc  '\n   otherwise\n          nop\nend\nselect                                   /* sysres                 */\n    when substr(pathinfo,11,1) = 'Y' then\n          vstatus= vstatus||'SYSRES  '\n   otherwise\n          nop\nend\nselect                                   /* dasd reserve           */\n    when substr(pathinfo,10,1) = 'Y' then\n          vstatus= vstatus||'Reserved'\n   otherwise\n          nop\nend\nmntstat= ' '                             /* init                   */\nselect                                   /* determine vol res      */\n    when substr(pathinfo,2,1) = 1 then\n          mntstat= 'Resident  '\n    when substr(pathinfo,2,1) = 2 then\n          mntstat= 'Perm Res  '\n   otherwise\n          nop\nend\nselect                                   /* determine vol status   */\n    when substr(pathinfo,3,1) = 1 then\n          mntstat= mntstat||'Private  '\n    when substr(pathinfo,3,1) = 2 then\n          mntstat= mntstat||'Public  '\n    when substr(pathinfo,3,1) = 3 then\n          mntstat= mntstat||'Storage  '\n   otherwise\n          nop\nend\nselect                                   /* shared dasd            */\n    when substr(pathinfo,4,1) = 'Y' then\n          mntstat= mntstat||'Shared'\n   otherwise\n          nop\nend\ndevstat=  ' '                            /* init                   */\nselect                                   /* device type            */\n    when substr(pathinfo,9,1) = '0B'x then\n          devstat= '3350  '\n    when substr(pathinfo,9,1) = '0C'x then\n          devstat= '3375  '\n    when substr(pathinfo,9,1) = '0E'x then\n          devstat= '3380  '\n    when substr(pathinfo,9,1) = '0F'x then\n          devstat= '3390  '\n   otherwise\n          nop\nend\nif substr(pathinfo,8,1) = 'Y' then       /* suspended channel prog?*/\n   devstat= devstat||'Suspended Channel Program  '\nif substr(pathinfo,6,1) = 'Y' then       /* paging device?         */\n   devstat= devstat||'<Paging Device>'\nISC=  x2d(c2x(substr(pathinfo,7,1)))     /* Interrupt Subclass     */\ndo i= 1 to no_of_chpids                  /* do no of table entries */\n   path=  c2x(substr(pathinfo,x+1,1))    /* path                   */\n   select                                /* Determine Path Type    */\n         when (substr(pathinfo,x+3,1)) = '01'x then\n              pathtyp= 'Parallel Block Multiplexor'\n         when (substr(pathinfo,x+3,1)) = '02'x then\n              pathtyp= 'Parallel Byte Multiplexor'\n         when (substr(pathinfo,x+3,1)) = '03'x then\n              pathtyp= 'ESCON Point To Point'\n         when (substr(pathinfo,x+3,1)) = '04'x then\n              pathtyp= 'ESCON '\n         when (substr(pathinfo,x+3,1)) = '05'x then\n              pathtyp= 'ESCON Switch Point To Point'\n         when (substr(pathinfo,x+3,1)) = '06'x then\n              pathtyp= 'FIBER Extended'\n         when (substr(pathinfo,x+3,1)) = '07'x then\n              pathtyp= 'ESCON Native'\n   otherwise\n              pathtyp= 'UNKNOWN'\n   end\n   if substr(pathinfo,x+2,1) = '06'x then do /* path on-line?      */\n      pathstat= 'Path ONLINE'              /* yes                  */\n      call create_table_entry              /* create a table entry */\n   end\n   path_status= substr(pathinfo,x+2,1)     /* path status byte     */\n   path_status= bitand(path_status,'20'x)  /* isolate bit required */\n   if (path_status = '20'x) then do      /* path off-line due escm?*/\n      pathstat= 'Path OFFLINE Due To ESCM' /* yes                  */\n      call create_table_entry              /* create a table entry */\n   end\n   path_status= substr(pathinfo,x+2,1)     /* path status byte     */\n   path_status= bitand(path_status,'10'x)  /* isolate bit required */\n   if (path_status = '10'x) then do        /* path off-line due op?*/\n      pathstat= 'Path OFFLINE Due To Operator'\n      call create_table_entry              /* create a table entry */\n   end\n   path_status= substr(pathinfo,x+2,1)     /* path status byte     */\n   path_status= bitand(path_status,'08'x)  /* isolate bit required */\n   if (path_status = '08'x) then do    /* path off-line due cu rcv?*/\n      pathstat= 'Path OFFLINE Due CU Recovery'\n      call create_table_entry            /* create a table entry   */\n   end\n   path_status= substr(pathinfo,x+2,1)   /* path status byte       */\n   path_status= bitand(path_status,'01'x) /* isolate bit required  */\n   if (path_status = '01'x) then do      /* vary off-line in prog? */\n      pathstat= 'Path OFFLINE In Progress'\n      call create_table_entry            /* create a table entry   */\n   end\n   x= (x + 4)                            /* next table entry       */\nend\nADDRESS \"ISPEXEC\" \"REMPOP\"               /* remove pop-up          */\nADDRESS \"ISPEXEC\" \"ADDPOP ROW(1) COLUMN(2)\" /* pop-up position     */\nADDRESS \"ISPEXEC\" \"TBTOP DEVNTAB\"        /* position to top of tab */\nif (rc \u00ac= 0) then do                     /* call okay?             */\n   say 'tbtop error    rc = 'rc''        /* no- inform the user    */\n   ADDRESS \"ISPEXEC\" \"LIBDEF ISPPLIB\"    /* remove allocation      */\n   exit(0)                               /* let's quit             */\nend\nADDRESS \"ISPEXEC\" \"TBDISPL DEVNTAB PANEL(GETDEVP3)\"\nif (rc > 8) then do                      /* error?                 */\n   say 'tbdispl error    rc = 'rc''      /* yes- output message    */\n   ADDRESS \"ISPEXEC\" \"LIBDEF ISPPLIB\"    /* remove allocation      */\n   exit(0)                               /* and quit               */\nend\nADDRESS \"ISPEXEC\" \"TBCLOSE  DEVNTAB\"     /* close the table        */\nif (rc \u00ac= 0) then do                     /* call okay?             */\n   say 'tbtop error    rc = 'rc''        /* no- inform the user    */\n   ADDRESS \"ISPEXEC\" \"LIBDEF ISPPLIB\"    /* remove allocation      */\n   exit(0)                               /* lets quit              */\nend\nADDRESS \"ISPEXEC\" \"REMPOP\"               /* remove pop-up          */\nreturn\nLets_Lock_The_Terminal:\nADDRESS \"ISPEXEC\" \"CONTROL DISPLAY LOCK\" /* lock the terminal      */\nif (rc > 8) then do                      /* error?                 */\n   say 'Lock error    rc = 'rc''         /* yes- output message    */\n   ADDRESS \"ISPEXEC\" \"LIBDEF ISPPLIB\"    /* remove allocation      */\n   exit(0)                               /* and quit               */\nend\nADDRESS \"ISPEXEC\" \"ADDPOP ROW(3) COLUMN(7)\" /* pop-up position     */\nADDRESS \"ISPEXEC\" \"DISPLAY PANEL(GETDEVP2)\"\nif (rc > 8) then do                      /* error?                 */\n   say 'Display error    rc = 'rc''      /* yes- output message    */\n   ADDRESS \"ISPEXEC\" \"LIBDEF ISPPLIB\"    /* remove allocation      */\n   exit(0)                               /* and quit               */\nend\nreturn\ndisplay_error_panel:\nselect\n  when (substr(pathinfo,12,1)) = 'C' then do /* UCBCOPY error?     */\n       if (retcode = '00000004'x) & (reason_code = '00000001'x) then\n           merr= 'VOLSER Not ONLINE'\n       else\n           merr= 'Error Has Occurred during call to UCBCOPY'\n       end\n  when (substr(pathinfo,12,1)) = 'I' then do /* UCBINFO Error?     */\n       merr= 'Error Has Occurred during call to UCBINFO'\n       end\notherwise\n      nop                                /* nop                    */\nend\nurtc=  c2x(retcode)                      /* convert to character   */\nursc=  c2x(reason_code)                  /* convert to character   */\nADDRESS \"ISPEXEC\" \"ADDPOP ROW(2) COLUMN(7)\"  /* pop-up position    */\nADDRESS \"ISPEXEC\" \"DISPLAY PANEL(GETDEVP4)\"  /* display error panel*/\nif (rc > 8) then do                      /* error?                 */\n   say 'Display error    rc = 'rc''      /* yes- output message    */\n   ADDRESS \"ISPEXEC\" \"LIBDEF ISPPLIB\"    /* remove allocation      */\n   exit(0)                               /* and quit               */\nend\nADDRESS \"ISPEXEC\" \"REMPOP\"               /* remove pop-up          */\nreturn\ncreate_table_entry:\nADDRESS \"ISPEXEC\" \"TBADD DEVNTAB\n         SAVE(path,pathtyp,pathstat)\n         MULT(\"TABROWS\")\"\nif (rc \u00ac= 0) then do                     /* call okay?             */\n   say 'tbadd error    rc = 'rc''        /* no- inform the user    */\n   ADDRESS \"ISPEXEC\" \"LIBDEF ISPPLIB\"    /* remove allocation      */\n   exit(0)                               /* let's quit             */\nend\npath= ' '                                /* reset                  */\npathtyp= ' '                             /* reset                  */\nreturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GETDEVP1": {"ttr": 1796, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00(\\x01\\x19\\t\\x1f\\x01\\x19\\t\\x1f\\x182\\x00\\x1c\\x00\\x1c\\x00\\x00\\xd7\\xc1\\xd5\\xc5\\xd3@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-04-01T00:00:00", "modifydate": "2019-04-01T18:32:28", "lines": 28, "newlines": 28, "modlines": 0, "user": "PANEL"}, "text": ")ATTR\n_ TYPE(INPUT)   INTENS(HIGH) COLOR(YELLOW)\n% TYPE(TEXT)    COLOR(RED)\n+ TYPE(TEXT)    COLOR(WHITE)\n# TYPE(TEXT)    INTENS(HIGH) COLOR(BLUE)\n? TYPE(OUTPUT)  INTENS(HIGH) COLOR(RED)\n@ TYPE(OUTPUT)  COLOR(RED)\n)BODY WINDOW(33,7)\n%\n%COMMAND ===>_ZCMD      %\n%\n%\n+   Volume Serial No:  _z     %\n%\n)INIT\n.ZVARS= '(volser)'\n&ZCMD= ' '\n&volser= ' '\n.CURSOR= volser\n&ZWINTTL=  'Return Device Number'\n)REINIT\n&ZCMD= ' '\n&volser= ' '\n.CURSOR= volser\n&ZWINTTL=  'Return Device Number'\n)PROC\nver (&volser,nb)\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GETDEVP2": {"ttr": 1798, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x01\\x19\\t\\x1f\\x01\\x19\\t\\x1f\\x182\\x00\\x17\\x00\\x17\\x00\\x00\\xd7\\xc1\\xd5\\xc5\\xd3@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-04-01T00:00:00", "modifydate": "2019-04-01T18:32:44", "lines": 23, "newlines": 23, "modlines": 0, "user": "PANEL"}, "text": ")ATTR\n_ TYPE(INPUT)   INTENS(HIGH) COLOR(YELLOW)\n% TYPE(TEXT)    COLOR(RED)\n* TYPE(TEXT)    COLOR(YELLOW)\n+ TYPE(TEXT)    COLOR(WHITE)\n# TYPE(OUTPUT)  INTENS(HIGH) COLOR(BLUE)\n? TYPE(OUTPUT)  INTENS(HIGH) COLOR(RED)\n@ TYPE(OUTPUT)  COLOR(RED)\n)BODY WINDOW(54,7)\n%\n%COMMAND ===>_ZCMD      %         SCROLL ===>_AMT   +\n%\n%   ------------------------------------------------\n%   | Your Request Is Being Processed. Please Wait |\n%   ------------------------------------------------\n%\n)INIT\n&ZCMD= ' '\n&ZWINTTL=  'Progress Panel'\n)REINIT\n&ZCMD= ' '\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GETDEVP3": {"ttr": 1800, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x19\\t\\x1f\\x01\\x19\\t\\x1f\\x183\\x00 \\x00 \\x00\\x00\\xd7\\xc1\\xd5\\xc5\\xd3@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-04-01T00:00:00", "modifydate": "2019-04-01T18:33:03", "lines": 32, "newlines": 32, "modlines": 0, "user": "PANEL"}, "text": ")ATTR\n_ TYPE(INPUT)   INTENS(HIGH) COLOR(YELLOW)\n% TYPE(TEXT)    COLOR(RED)\n* TYPE(TEXT)    COLOR(YELLOW)\n+ TYPE(TEXT)    COLOR(WHITE)\n# TYPE(OUTPUT)  INTENS(HIGH) COLOR(YELLOW) CAPS(OFF)\n? TYPE(OUTPUT)  INTENS(HIGH) COLOR(RED)\n@ TYPE(OUTPUT)  COLOR(RED)\n)BODY WINDOW(71,17)\n%COMMAND ===>_ZCMD      %\n%\n+Volume Ser Number: #volser+ Device Number:#dnum+ SMS:#sms+\n+Status:            #vstatus                          +\n+Mount Status:      #mntstat                  +\n+Device Status:     #devstat                                         *\n+Interrupt Subclass:#z*\n%\n+?pinfo                    %\n+\n+ Path Path                           Status\n+      Type\n+\n)MODEL\n*#z * #z                          *  #z                              *\n)INIT\n.ZVARS= '(isc,path,pathtyp,pathstat)'\n&ZCMD= ' '\n&ZWINTTL=  'Volume Information'\n)REINIT\n&ZCMD= ' '\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GETDEVP4": {"ttr": 1802, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00!\\x01\\x19\\t\\x1f\\x01\\x19\\t\\x1f\\x183\\x00\\x18\\x00\\x18\\x00\\x00\\xd7\\xc1\\xd5\\xc5\\xd3@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-04-01T00:00:00", "modifydate": "2019-04-01T18:33:21", "lines": 24, "newlines": 24, "modlines": 0, "user": "PANEL"}, "text": ")ATTR\n_ TYPE(INPUT)   INTENS(HIGH) COLOR(YELLOW)\n% TYPE(TEXT)    COLOR(RED)\n* TYPE(TEXT)    COLOR(BLUE)\n+ TYPE(TEXT)    COLOR(WHITE)\n# TYPE(OUTPUT)  INTENS(HIGH) COLOR(BLUE)\n? TYPE(OUTPUT)  INTENS(HIGH) COLOR(RED)\n@ TYPE(OUTPUT)  COLOR(YELLOW)\n)BODY WINDOW(47,9)\n%\n%COMMAND ===>_ZCMD      %\n%\n%  ?merr                                     %\n%\n*   Return Code=@urtc    %\n*   Reason Code=@ursc    %\n%\n)INIT\n&ZCMD= ' '\n&ZWINTTL=  'Error Panel'\n)REINIT\n&ZCMD= ' '\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GETDSN": {"ttr": 1804, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00Y\\x01\\x19\\t\\x1f\\x01\\x19\\x10/\\x177\\x00f\\x00R\\x00\\x00\\xe6\\xd1\\xc5\\xd5\\xe2\\xc5\\xd5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2019-04-01T00:00:00", "modifydate": "2019-04-12T17:37:59", "lines": 102, "newlines": 82, "modlines": 0, "user": "WJENSEN"}, "text": "* Retrieving a dataset name from a program  (member A08A5369 1989)\n*\n* It is often very useful to know which dataset name has been\n* assigned to a particular DDNAME from a program.  This\n* information can be used to print the dataset name on a report so\n* that, should the JCL become detached, the input file that was used\n* is apparent.  It also enables programmers to use dynamic\n* allocation against members of a PDS for use with the QSAM access\n* method, thus avoiding the complexities of BPAM for processing a\n* PDS.\n*\n* Using QSAM for processing a PDS means that high-level languages\n* can be used for the I/O directly.  To achieve this, one would need\n* to get the dataset name with the routine shown below, optionally\n* read the PDS directory, and allocate particular members (old or\n* new) with a suitable dynamic allocation interface such as the one\n* supplied on the SHARE tape or one coded specifically for the\n* purpose.\n*\n* Following the allocation of the member (effectively a sequential\n* file) the I/O can be performed from any language, and the\n* member is simply unallocated.  However, to allocate the\n* 'dataset(member)' the dataset name must be known and this\n* routine allows this using the DDNAME.  It should be pointed out\n* that dynamic allocation is not restricted to TSO and can be used in\n* any job, often resulting in simpler JCL and better defaults.\n\n         TITLE 'GETDSN - MODULE TO EXTRACT THE DSN FOR A DDNAME'\nGETDSN   CSECT ,\n         AIF   (&REGS EQ 0).NOYREGS\n         YREGS\n.NOYREGS ANOP\n*********************************************************************\n** PROGRAM:    GETDSN\n** PARAMETERS: (2) PASSED AS STANDARD FORMAT CALL SEQUENCE\n**             DDNAME   CL8  (input)\n**             DSNAME   CL44 (output)\n** FUNCTION:   CHECK DDNAME EXISTS IN TASK INPUT/OUTPUT TABLE (TIOT).\n**             READS JFCB TO EXTRACT DSNAME, RETURN THE DATASET NAME.\n** RET CODE:   R15 = 0 IF OK, R15 = 4 IF DDNAME NOT IN TIOT.\n*\n* Sample call\n*\n*          la    r14,ddname\n*          la    r15,dsname\n*          stm   r14,r15,parmlist\n*          la    r1,parmlist\n*          l     r15,=v(GETDSN)\n*          balr  r14,r15\n*          ltr   r15,r15\n*          . . .\n* ddname   dc    c8'SYSEXEC'\n* dsname   dc    cl44' '\n* parmlist ds    2a\n*          . . .\n*          copy  getdsn           get code\n*\n*********************************************************************\n         STM   R14,R12,12(R13)          SAVE REGS\n         LR    R12,R15                  SET BASE REG\n         USING GETDSN,R12\n         ST    R13,SAVEAREA+4           BACKWARD CHAIN\n         LR    R11,R13\n         LA    R13,SAVEAREA             POINT TO OUR SAVE AREA ADDR\n         ST    R13,8(,R11)              FORWARD CHAIN\n         TITLE 'GETDSN - START OF PROCESSING CODE'\n         LM    R2,R3,0(R1)             LOAD PARAMETER LIST\n         EXTRACT TIOTADDR,FIELDS=(TIOT) GET TIOT ADDR\n         MVC   DDNAME,0(R2)             MOVE DDNAME\n         L     R1,TIOTADDR              SEARCH TIOT FOR DDNAME\n         LA    R1,24(,R1)               STEP TO DD ENTRIES\n         XR    R0,R0                    CLEAR LENGTH REGISTER\nLOOP1    IC    R0,0(R1)                 GET LENGTH OF THIS ENTRY\n         LTR   R0,R0                    IS LENGTH ZERO?\n         BZ    NOTFOUND                 YES THEN NOTFOUND\n         CLC   4(8,R1),DDNAME           IS DDNAME THE SAME?\n         BE    FOUND                    YES THEN FOUND\n         CLC   36(4,R1),=F'0'           END OF TIOT?\n         BE    NOTFOUND                 YES THEN NOTFOUND\n         AR    R1,R0                    POINT TO NEXT ENTRY\n         B     LOOP1                    AND PROCESS IT\nNOTFOUND LA    R15,4                    SET RET CODE FOR BAD DDNAME\n         B     OUT                      AND GOTO EXIT\nFOUND    LA    R15,0                    SET RET CODE FOR GOOD DDNAME\n         LA    R11,DUMDCB               FIND OUR DCB\n         MVC   40(8,R11),DDNAME         MOVE IN THE DDNAME\n         RDJFCB DUMDCB                  READ JFCB\n         MVC   0(44,R3),JFCBAREA        MOVE IT\n         XC    JFCBAREA,JFCBAREA        CLEAR JFCB\n         XC    DDNAME,DDNAME            CLEAR DDNAME\n         B     OUT                      AND GOTO EXIT\nOUT      L     R13,4(R13)               RELOAD SAVE AREA ADDR\n         RETURN (14,12),RC=(15)         RETURN TO CALLER\n         LTORG\nSAVEAREA DC    18F'0'\nTIOTADDR DC    F'0'\nDDNAME   DC    CL8' '\nDUMDCB   DCB   DDNAME=NOTSET,DSORG=PS,MACRF=PL,EXLST=EXLST\nEXLST    DS    0F\n         DC    X'87',AL3(JFCBAREA)      FUNCTION,AREA\nJFCBAREA DC    176X'00'                 JFCB AREA\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GETDSN$": {"ttr": 1807, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00\\x07\\x01\\x19\\t\\x1f\\x01\\x19\\x10/\\x179\\x00R\\x00a\\x00\\x00\\xe6\\xd1\\xc5\\xd5\\xe2\\xc5\\xd5@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "2019-04-01T00:00:00", "modifydate": "2019-04-12T17:39:07", "lines": 82, "newlines": 97, "modlines": 0, "user": "WJENSEN"}, "text": "//SBGOLOBM JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//    JCLLIB ORDER=WJENSEN.LIB.CNTL\n//*\n//A   EXEC ASMACL,PARM.C='TERM',PARM.L='LIST,MAP'\n//C.SYSLIB  DD DISP=SHR,DSN=SBGOLOB.GETDSN.MACLIB  (member GETDSNM)\n//          DD DISP=SHR,DSN=SBGOLOB.CBT497.FILE836\n//          DD DISP=SHR,DSN=SYS1.MACLIB\n//          DD DISP=SHR,DSN=SYS1.MODGEN\n//C.SYSTERM DD SYSOUT=*\n//C.SYSIN   DD *\n         print on\n*-\n* begin\n*-\n&REGS    SETA  0\ntest     #module rmode=24,base=r12\n*\n         log   open\n         log   'Begin.....'\n         print on\n*-\n* test\n*-\n         Macro\n         TestIt &p1\n         lclc  &dd\n&dd      setc  Upper('&p1')\n         $la   r14,=cl8'&dd'\n         $la   r15,dsname\n         stm   r14,r15,parmlist\n         la    r1,parmlist\n         l     r15,=v(GETDSN)\n         clear dsname\n         balr  r14,r15\n         strmake logr,'dd &dd -> ',dsname\n         log   ,\n         Mend\n\n*\n         TestIt cbtlib\n*\n         TestIt steplib\n*-\n* end\n*-\n         print off\n         cnop  0,4\n         log   'End.......'\n         log   close\n         #module exit\n         print on\n\nzero     dc    a(0)\nparmlist dc    4a(0)\ndsname   ds    cl44\nblank    dc    cl140' '\n\n         log   dcb\n         log   field\ndw       ds    d\nfw       ds    f\nrc       dc    a(0)\nsa       ds    (4*18)a\nsaend    ds    0x\n         ltorg\nwrk256   ds    xl256\n\n* Get module\n         Copy  GETDSN\n         End\n//*\n//L.SYSLIB   DD DISP=SHR,DSN=SYS1.CSSLIB\n//L.SYSLMOD  DD DISP=(,PASS),DSN=&&LOADLIB(GETDSN$),\n//         SPACE=(TRK,(8,8,8)),DCB=(SYS1.LINKLIB)\n//*\n//IVP1     EXEC PGM=GETDSN$\n//STEPLIB  DD DISP=OLD,DSN=&&LOADLIB\n//CBTLIB   DD DISP=SHR,DSN=WJENSEN.CBT.FILE830\n//SYSPRINT DD SYSOUT=*,OUTLIM=(5000)\n//SYSTSIN  DD DUMMY\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GETDSN$$": {"ttr": 1810, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00G\\x01\\x07\"_\\x01\\x19\\x10/\\x16D\\x00\\x1b\\x00\\x0e\\x00\\x00\\xc1\\xe2\\xd4\\xd1\\xc3\\xd3@@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "2007-08-13T00:00:00", "modifydate": "2019-04-12T16:44:47", "lines": 27, "newlines": 14, "modlines": 0, "user": "ASMJCL"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,RLD)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(GETDSN)\n//SYSUT1   DD UNIT=SYSDA,SPACE=(CYL,20)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=SYSDA,SPACE=(TRK,30),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=(OLD,PASS),DSN=&&TEMP\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB\n ORDER   GETDSN\n SETSSI  CB497836\n ENTRY   GETDSN\n NAME    GETDSN(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "GETDSNM": {"ttr": 1812, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x002\\x01\\x19\\x10/\\x01\\x19\\x10/\\x17\\x16\\x03k\\x03k\\x00\\x00\\xd4\\xc1\\xc3\\xd3\\xc9\\xc2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-04-12T00:00:00", "modifydate": "2019-04-12T17:16:32", "lines": 875, "newlines": 875, "modlines": 0, "user": "MACLIB"}, "text": "./ ADD NAME=$LA      0114-17085-19011-1901-00138-00116-00000-WJ      19\n         Macro\n.*-\n.* $LA - build LA instruction (inner macro)\n.*\n.* Returns length in a global variable, length either defined by the\n.* 2rd operand, or computed from the 2nd operand.\n.* Syntax:\n.*   $la  r1,label      -> la    r1,label\n.*   $la  r1,,label     -> la    r1,label\n.*   $la  r1,number     -> lgfi  r1,nnn\n.*   $la  r1,4(,r3)     -> la    r1,4(,r3)                -> length=0\n.*   $la  r1,(r2)       -> lr    r1,r2                    -> length=0\n.*   $la  r1,'kilroy'   -> la    r1,=c'kilroy'\n.*   $la  r1,0          -> slr   r1,r1                    -> length=0\n.*   $la  r1,x.label    -> lx    r1,label  (x: B, F or H) -> length=0\n.* The length is returned in global variable $lalen, the type in\n.* global variable $latype.\n.*\n.* updates\n.* 2017-14-03  numeric value now different from label\n.* 2018-06-16  2rd operand is now alternate src, not global length\n.* 2019-01-11  change global $LALENC\n.*-\n&mlbl    $la   &reg,&psrc,&pasrc,&pasrc2,&glen=,&src2=\n         lcla  &n,&l\n         lclc  &s,&c,&r,&srct,&srcl,&src\n         gbla  &$lalen\n         gblc  &$lalenc\n         gblc  &$latype\n&$lalen  seta  0\n&$lalenc setc ''\n.* select source\n         aif   (k'&psrc   gt 0).setsrc1\n         aif   (k'&pasrc  gt 0).setsrc2\n         aif   (k'&pasrc2 gt 0).setsrc3\n         aif   (k'&src2   gt 0).setsrc4\n         mnote  8,'** $LA mising source'\n.setsrc1 anop\n&src     setc  '&psrc'\n         ago   .setsrcn\n.setsrc2 anop\n&src     setc  '&pasrc'\n         ago   .setsrcn\n.setsrc3 anop\n&src     setc  '&pasrc2'\n         ago   .setsrcn\n.setsrc4 anop\n&src     setc  '&src2'\n.setsrcn anop\n.*\n&s       setc  Upper('&src')\n         aif   ('&s   '(1,3) eq 'L''''').litlen\n&srct    setc  t'&src\n&srcl    setc  Lower('&src')\n.* mnote *,'type &srct'\n.*-\n.* what kind of 1st operand do we have?\n.*-\n         aif   (k'&src gt 0).cp1\n         mnote 8,'src operand missing'\n         mexit\n.cp1     aif   ('&src '(2,1) eq '.').load\n         aif   ('&src' eq '0').clr          clear register\n         aif   ('&src'(1,1) eq '(').reg     register\n         aif   ('&src'(1,1) eq '''').txt    text\n         aif   ('&srct' eq 'N').num        number\n         ago   .lbl\n.*- src is 0, means clear reg\n.clr     anop  ,\n&$latype setc  'CLR'\n&mlbl    slr   &reg,&reg\n         mexit\n.*- src is a number\n.num     anop  ,\n&$latype setc  'NUM'\n&mlbl    lgfi  &reg,&src\n&$lalen  seta  &src\n         mexit\n.*- src is a label or address\n.lbl     anop  ,                           label\n&$latype setc  'LBL'\n&mlbl    la    &reg,&src\n&$lalenc setc  'l''&src'\n&c       setc  t'&src\n         aif   ('&c' ne 'A').setl0\n&n       seta  l'&src\n&$lalen  seta  &n\n         mexit\n.*- src is a register\n.reg     anop  ,                           register\n&$latype setc  'REG'\n&n       seta  (k'&src)-2\n&s       setc  '&src'(2,&n)\n&mlbl    lr    &reg,&s\n&$lalen  seta  1                            default\n         mexit\n.*- src is text\n.txt     anop  ,\n&$latype setc  'TXT'\n&s       setc  '=c&src'\n&mlbl    la    &reg,&s\n&n       seta  (k'&src)-2\n&$lalen  seta  &n\n&$lalenc setc  '&n'\n         mexit\n.*- load from storage\n.load    anop  ,\n.* mnote *,'load'\n&c       setc  Upper('&srcl'(1,1))\n&n       seta  (k'&src)-2\n&s       setc  '&src'(3,&n)\n&$latype setc  'LFS'\n&$lalen  seta  0\n         aif   ('&c' eq 'F' or '&c' eq 'A').loadf\n         aif   ('&c' eq 'H').loadh\n         aif   ('&c' eq 'B').loadb\n         mnote 8,*** invalid load parm &c'\n         mexit\n.loadf   anop  ,\n&mlbl    l     &reg,&s                     load from fullword\n         mexit\n.loadh   anop  ,\n&mlbl    lh    &reg,&s                     load from halfword\n         mexit\n.loadb   anop  ,\n&mlbl    sr    &reg,&reg\n         ic    &reg,&s                     load from byte\n         mexit\n*-\n.litlen  anop\n&n       seta  (k'&src)-4\n&$lalen  seta  &n\n         la    &reg,&n                     length of literal\n         mexit\n*-\n.setl0   anop\n&$lalen  seta  0\n.x       Mend\n./ ADD NAME=#MODULE  0163-98127-19046-1855-00194-00169-00000-WJ      21\n         Macro\n.*\n.* Setup module start - basereg, working storage etc.\n.*\n.* base=(reg1\u00dd,reg2\u00dd,reg3\u00a8\u00a8)      setup up to 3 baseregs\n.* work=(length,label,reg)        acquire dynamic storage\n.* work24=(length,label,reg)      acquire dynamic 24-bit storage\n.* sa=label | *\u00ddn\u00a8                save area label or inline\n.* prolog=address                 address of prolog subroutine\n.* epilog=address                 address of epilog subroutine\n.* end\u00dd,rc=value\u00a8                 return via epilog\n.* return\u00dd,rc=value\u00a8              return via epilog\n.*\n.* Changelog\n.* 2018-10-27  rc value for end can be syslist(2) i.e #module end,123\n.* 2018-11-26  4th parm of work/work24 can be set to 'C' => clear stg\n.* 2019-02-05  use &SYSCLOCK(1,16) instead of &SYSDATE+&SYSTIME\n.*             add &ver option\n.* 2019-02-14  add SYSSTATE OSREL=SYSSTATE,ARCHLVL=OSREL\n.*\n&mlbl    #MODULE &p1,&amode=31,&rmode=ANY,&text=,&ver=,&rc=,           c\n               &base=r12,&sa=,&work=,&work24=,&sp=*future*,            c\n               &prolog=,&epilog=,&xprolog=,&xepilog=\n.*-\n         gblb  &#modequ\n         gbla  &iezbits\n         gblc  &#modname,&#modrmod,&#modamod\n         lcla  &n,&m\n         lclc  &s,&l,&base1,&base2,&base3,&dt\n         lclc  &worksz,&workrg,&worklb,&workloc,&workclr\n&l        setc  '#M&sysndx'\n          aif   (k'&p1 eq 0).nop1\n&s        setc  Upper('&p1')\n          aif   ('&s' eq 'END' or '&s' eq 'RETURN'                     c\n               or '&s' eq 'EXIT').end\n          mnote 8,'*** Invalid p1'\n          mexit\n.nop1     anop\n          aif   (k'&mlbl gt 0).lblok\n          mnote 8,'*** Missing label'\n          mexit\n.lblok    anop\n&#modname setc  '&mlbl'\n&#modamod setc  '&amode'\n&#modrmod setc  '&rmode'\n&base1    setc  '&base(1)'\n&base2    setc  '&base(3)'\n&base3    setc  '&base(4)'\n&worksz   setc  '&work(1)&work24(1)'\n&worklb   setc  '&work(2)&work24(2)'\n&workrg   setc  '&work(3)&work24(3)'\n&workclr  setc  Upper('&work(4)&work24(4)')\n&workloc  setc  '&amode'\n          aif   (n'&work24 eq 0).worklocn\n&workloc  setc  '24'\n.worklocn anop\n.*-\n.* Equate regs and bits\n.*-\n         push  print\n         print off\n&n       seta  0\n         aif   (&#modequ).equregn  bits allready set\n&#modequ setb  1\n.equreg  anop\nr&n      equ   &n\n&n       seta  &n+1\n         aif   (&n le 16).equreg\n.equregn anop\n         aif   (&iezbits ne 0).equbitn  bits allready set\n         IEZBITS\n.equbitn anop\n         pop   print\n*-\n* Module start\n*-\n.*       SYSSTATE OSREL=SYSSTATE,ARCHLVL=OSREL\n*-\n&mlbl    amode &amode\n&mlbl    rmode &rmode\n&mlbl    Csect\n         bakr  14,0\n.*       sam&amode\n*setup base register(s)\n         lr    &base1,r15\n         using &mlbl,&base1\n         aif   (n'&base eq 1).basen\n         lr    &base(2),&base(1)\n         alfi  &base(2),4096\n         using &mlbl.+4096,&base(2)\n         aif   (n'&base eq 2).basen\n         lr    &base(3),&base(2)\n         alfi  &base(3),4096\n         using &mlbl.+8192,&base(3)\n.basen   anop\n         j     &l.idn\n&dt      setc  '&sysclock'(1,16)       YYYY-MM-DD HH:MM\n         aif   (k'&text eq 0).id\n&n       seta  k'&text\n&s       setc  '&text'(2,&n-2)\n&mlbl._id dc    c'&mlbl&ver &dt &s'\n         ago   .idl\n.id      anop\n&mlbl._id dc    c'&mlbl&ver &dt'\n.idl     anop\n&mlbl._idl equ   *-&mlbl._id\n&l.idn   ds    0a\n.*-\n.* get working storage\n.*-\n         aif   ('&worksz' eq '').workn\n         mnote *,'obtain storage, length=&worksz,loc=&workloc'\n         Storage OBTAIN,length=&worksz,loc=&workloc\n         aif   (k'&workrg eq 0).workn\n         lr    &workrg,r1\n.* clear storage\n         aif   ('&workclr' ne 'C').clrstrn\n         lr    r0,r1                   target\n         lgfi  r1,&worksz              target length\n         la    r14,=al1(0)             source\n         la    r15,1                   source length\n         mvcl  r0,r14                  clear storage\n.clrstrn anop\n.*\n         aif   (k'&worklb eq 0).workn\n         using &worklb,&workrg\n.workn   anop\n.*-\n.* setup save area\n.*-\n         aif   (k'&sa eq 0).saven\n*setup save area\n         aif   ('&sa '(1,1) eq '*').saveint\n         la    r13,&sa\n         ago  .saven\n.saveint cnop  0,4\n&s       setc  '1'\n&n       seta  k'&sa\n         aif   (&n eq 1).savein2\n&s       setc  '&sa'(2,&n-1)\n.savein2 bas   r13,*+(&s*72)+4         address internal save area\n         ds    (&s*18)a                internal save area\n.saven   anop\n.*-\n.* setup prolog\n.*-\n         aif   (k'&prolog ne 0).prologl\n         aif   (k'&xprolog ne 0).prologv\n         ago   .prologn\n.prologl larl  r15,&prolog             prolog address\n         ago   .prologc\n.prologv l     r15,=v(&xprolog)        prolog address\n.prologc basr  r14,r15                 call prolog\n.prologn anop\n         j     &l.X\n.*-\n.* setup termination\n.*-\n* module termination\n&mlbl._X cnop  0,4\n.*-\n.* setup epilog\n.*-\n         aif   (k'&epilog eq 0 and k'&xepilog eq 0).epilogn\n         lr    r2,r15                  copy rc\n         aif   (k'&epilog ne 0).epilogl\n         aif   (k'&epilog ne 0).epilogl\n         aif   (k'&xepilog ne 0).epilogv\n         ago   .epilogn\n.epilogl larl  r15,&epilog             epilog address\n         ago   .epilogc\n.epilogv l     r15,=v(&xepilog)        epilog address\n.epilogc basr  r14,r15                 call epilog\n.epilogn anop\n         aif   ('&worksz' eq '').xworkn\n         mnote *,'release storage, length=&worksz,addr=&workrg'\n         lr    r2,r15\n         Storage RELEASE,length=&worksz,addr=(&workrg)\n         lr    r15,r2\n.xworkn  pr    ,\n* end of termination\n&l.X     ereg  0,1                     reload regs 0 and 1\n*-\n* End of module start\n*-\n         Mexit\n.*-\n.* return\n.*-\n.end     anop\n&s       setc  '&syslist(2)'\n&mlbl    $la   r15,&rc,&s,0\n         j     &#modname._X\n         Mend\n./ ADD NAME=CLEAR    0100-17131-17131-1809-00014-00014-00000-WJ      45\n         MACRO\n&LBL     CLEAR &A=,&C=C' ',&L=\n         LCLC  &LEN,&ADDR\n&ADDR    SETC  '&A'\n         AIF   (K'&A GT 0).SETL\n&ADDR    SETC  '&SYSLIST(1)'\n.SETL    ANOP\n&LEN     SETC  'L''&ADDR.-1'\n         AIF   (K'&L EQ 0).L0900\n&LEN     SETC  '&L-1'\n.L0900   ANOP\n&LBL     MVI   &ADDR,&C\n         MVC   &ADDR+1(&LEN),&ADDR\n         MEND\n./ ADD NAME=LOG      0114-03245-19026-0801-00052-00016-00000-WJ      44\n         Macro\n&lbl     Log   &p1,&p2,&ddname=SYSPRINT,&MF=,&lrecl=140,&print=\n         gblc  &$log_opt_print\n         lcla  &p1l\n         lclc  &s,&mfp1,&mfp2,&mprint\n&s       setc  Upper('&p1')\n         aif   ('&s' eq 'OPT').opt\n&mfp1    setc  Upper('&mf(1)')\n&mfp2    setc  '&mf(2)'\n&mprint  setc  '&print'\n         aif   (k'&print gt 0).pr12\n&mprint  setc  '&$log_opt_print'\n.pr12    anop\n         aif   (k'&mprint eq 0).pr1n\n         push  print\n         print &mprint\n.pr1n    anop\n         aif   ('&s' eq 'OPEN').open\n         aif   ('&s' eq 'CLOSE').close\n         aif   ('&s' eq 'DCB').dcb\n         aif   ('&s' eq 'FIELD').field\n&lbl     mvlit logr,&p1\n         put   logdcb,logr\n         clear logr\n         ago   .q\n.open    anop\n&lbl     open  (logdcb,(OUTPUT))\n         ago   .q\n.close   anop\n&lbl     close (logdcb)\n         ago   .q\n.dcb     anop\n&s       setc  Upper('&ddname')\nLogdcb   STDDCB MODEL=SYSPRINT,DDNAME=&s,lrecl=&lrecl\nLogdcbl  equ   *-logdcb\n&s       setc  Upper('&p2')\n         aif   ('&s' eq 'FIELD').field\n         ago   .q\n.field   anop\nlogr     dc    cl&lrecl.' '\n.q       anop\n         aif   (k'&mprint eq 0).pr2n\n         pop   print\n.pr2n    anop\n         mexit\n.* set global options\n.opt     anop\n         aif   (k'&print eq 0).optprn\n&$log_opt_print setc  '&print'\n         mnote *,'print defailt is now &print'\n.optprn  anop\n.x       Mend\n./ ADD NAME=MVLIT    0104-03018-18311-1550-00019-00006-00000-WJ      07\n         MACRO\n&lbl     MVLIT &A,&T,&LR=,&lenreg=,&LA=\n.* move literal to area\n.*  lr : load text length to register\n.*  la : load register with address of end of text\n         aif   (k'&t eq 0).nullp\n         lcla  &tl\n&tl      seta  (k'&t)-2\n&lbl     mvc   &a.(&tl),=c&t\n         aif   (k'&lr eq 0 and k'&lenreg eq 0).lrn\n         la    &lr&lenreg,&tl\n.lrn     anop\n         aif   (k'&la eq 0).lan\n         la    &la,&a+&tl\n.lan     mexit\n.nullp   anop\n         aif   (k'&lbl eq 0).x\n&lbl     ds    0h\n.x       MEND\n./ ADD NAME=STDDCB   0102-05113-18216-1601-00159-00141-00000-WJ      13\n         MACRO\n&ZNAME   STDDCB &L=,&EOD=,&B=,&DSORG=PS,&CTL=,&EXLST=0,                *\n               &MODEL=,&DCBD=YES,&DDNAME=,                             *\n               &LRECL=,&BLKSZ=,                                        *\n               &PRINT=NOGEN,                                           *\n               &DIV\n.*--------------------------------------------------------------------*\n.*  DO 1ST TIME PROCESS                                               *\n.*  ONESW IS ALSO SET BY DCBD MACRO                                   *\n.*--------------------------------------------------------------------*\n         GBLB  &STDDCB,&ONESW\n.*\n.*--------------------------------------------------------------------*\n.*  GENERATE STANDARD DCB TYPES                                       *\n.*--------------------------------------------------------------------*\n         LCLA  &N,&RS,&BS,&LR\n         LCLC  &C,&DTYP,&DCBNM,&CSECT,&ZEOD,&NAME,&DDN,&S,&U\n&NAME    SETC  (UPPER '&ZNAME')\n.*\n.*--------------------------------------------------------------------*\n.*  SET VARIOUS OPTIONS                                               *\n.*--------------------------------------------------------------------*\n         AIF   (K'&DIV EQ 0).DIVN\n&C       SETC  '&C'.',&DIV'             CONCATENATE OPTIONS\n.DIVN    ANOP\n&ZEOD    SETC  '*-*'\n         AIF   (K'&EOD EQ 0).EODN\n&ZEOD    SETC  '&EOD'\n.EODN    ANOP\n.*\n.*-- DEFAULT RECORD LENGTH AND BLOCKSIZE\n         AIF   (K'&LRECL EQ 0).ZRSN\n&RS      SETA  &LRECL\n         AIF   (K'&BLKSZ GT 0).ZBSN\n&BS      SETA  4096/&RS*&RS\n.ZBSN    ANOP\n.ZRSN    ANOP\n.*--\n         PUSH  PRINT\n         PRINT &PRINT\n.*\n.*--------------------------------------------------------------------*\n.*  STANDARD DUMMY SECTION IS CREATED 1ST TIME AROUND                 *\n.*--------------------------------------------------------------------*\n         AIF   (&ONESW).DCBD200        BYPASS IF PREVIOUS DCBD\n         AIF   ('&DCBD' EQ 'NO').DCBD200\n&CSECT   SETC  '&SYSECT'\n         DCBD  DSORG=&DSORG\n&ONESW   SETB  1\n         MNOTE *,'* DUMMY DCB IS CREATED'\n&CSECT   CSECT\n.DCBD200 ANOP\n         AIF   (&STDDCB).DCBD400       BYPASS IF SET\nSTDDCBLN EQU   DCBEOB+4-IHADCB\n         MNOTE *,'* LENGTH OF DCB TYPE 1 IS EQUATED TO STDDCBLN'\n&STDDCB  SETB  1\n.DCBD400 ANOP\n.*\n         AIF   (K'&NAME GT 0).NME999\n         MNOTE 8,'*** ERROR : NAME ENTRY MISSING'\n         AGO   .MEXIT\n.NME999  ANOP\n.*\n.*-- DEFINE LABEL FOR DCB MACRO\n         AIF   (K'&NAME EQ 0).DCBNM20\n&DCBNM   SETC  '&NAME'\n         AGO   .DCBNM99\n.DCBNM20 ANOP\n&DCBNM   SETC  'DCB&SYSNDX'\n.DCBNM99 ANOP\n.*--\n&DDN     SETC  (UPPER '&NAME')\n         AIF   (K'&DDNAME EQ 0).DDNAME2\n&DDN     SETC  (UPPER '&DDNAME')\n.DDNAME2 ANOP\n.*--\n&DTYP    SETC  '&NAME'                 DEFAULT: USE DDNAME AS MODEL\n         AIF   (K'&MODEL EQ 0).TYP999\n&DTYP    SETC  UPPER('&MODEL')\n.TYP999  ANOP\n.*\n&N       SETA  1\n.TN      ANOP\n.*\n.*--------------------------------------------------------------------*\n.*   JUMP TO APPROPRIATE DCB                                          *\n.*--------------------------------------------------------------------*\n         AIF   ('&DTYP' EQ 'SYSPRINT'                                  +\n               OR '&DTYP' EQ 'PRINT').SYSP\n         AIF   ('&DTYP' EQ 'SYSIN').SYSI\n         AIF   ('&DTYP' EQ 'SYSUT1').SYSUT1\n         AIF   ('&DTYP' EQ 'SYSUT2').SYSUT2\n         AIF   ('&MODEL' EQ 'OUTPUT').STDOUT\n         AIF   ('&DTYP' EQ 'SNAPDUMP'                                  +\n               OR '&DTYP' EQ 'SNAP').SNAP\n         AIF   ('&DTYP' EQ 'DCBD').MEXIT\n         AIF   ('&DTYP' EQ 'DSECT').MEXIT\n         AIF   ('&DIV' EQ 'DSECT').MEXIT\n         MNOTE  8,'*** ERROR - VALID DCB MODEL NOT DEFINED'\n         MEXIT\n.*\n.*--------------------------------------------------------------------*\n.*  SYSPRINT STANDARD DCB                                             *\n.*--------------------------------------------------------------------*\n.SYSP    ANOP\n MNOTE *,'* STANDARD DCB TYPE SYSPRINT - DCB=(RECFM=F,BLKSIZE=121)'\n         AIF   (K'&LRECL EQ 0).SYSPLR2\n&LR      SETA  &LRECL\n         AGO   .SYSPLRN\n.SYSPLR2 ANOP\n&LR      SETA  132\n.SYSPLRN ANOP\n         AIF   (K'&BLKSZ EQ 0).SYSPBS2\n&BS      SETA  &BLKSZ\n         AGO   .SYSPBSN\n.SYSPBS2 ANOP\n&BS      SETA  4096/&LR*&LR            COMPUTE BLOCKSIZE\n.SYSPBSN ANOP\n&DCBNM   DCB   DDNAME=&DDN,MACRF=PM,DSORG=PS,                          *\n               RECFM=FB&CTL,LRECL=&LR,BLKSIZE=&BS,EXLST=&EXLST\n         AGO   .MEXIT\n.*--------------------------------------------------------------------*\n.*  SYSIN STANDARD DCB                                                *\n.*--------------------------------------------------------------------*\n.SYSI    ANOP\n MNOTE *,'* STANDARD DCB TYPE SYSIN'\n.SYSUT1  ANOP\n         AIF   (K'&EOD NE 0).SYSIDCB\n MNOTE 4,'*** WARNING - EOD MISSING'\n.SYSIDCB ANOP\n&DCBNM   DCB   DDNAME=&DDN,MACRF=GM,DSORG=PS,EODAD=&ZEOD,              C\n               EXLST=&EXLST\n         AIF   ('&ZEOD' NE '*-*').MEXIT\n         AGO   .MEXIT\n         MNOTE *,'* WARNING - EOD OPERAND NOT DEFINED - SET TO *-*'\n         AGO   .MEXIT\n.*\n.*--------------------------------------------------------------------*\n.*  STANDARD OUTPUT DCB                                               *\n.*--------------------------------------------------------------------*\n.STDOUT  ANOP\n.SYSUT2  ANOP\n&NAME    DCB   DDNAME=&DDN,MACRF=PM,DSORG=PS,                          *\n               RECFM=FB&CTL,LRECL=&RS,BLKSIZE=&BS,EXLST=&EXLST\n         AGO   .MEXIT\n.*--------------------------------------------------------------------*\n.*  SNAPDUMP STANDARD DCB                                             *\n.*--------------------------------------------------------------------*\n.SNAP    ANOP\n MNOTE *,'* STANDARD DCB TYPE SNAP, DDNAME(&DDN)'\n&DCBNM   DCB   DDNAME=&DDN,MACRF=(W),RECFM=VBA,DSORG=PS,               *\n               LRECL=125,BLKSIZE=882,EXLST=&EXLST\n         AGO   .MEXIT\n.*--------------------------------------------------------------------*\n.*  END OF MACRO                                                      *\n.*--------------------------------------------------------------------*\n.MEXIT   ANOP\n         POP   PRINT\n         MEND\n./ ADD NAME=STRMAKE  0149-18207-19029-1748-00292-00202-00000-WJ      15\n         Macro\n.* ------------------------------------------------------------------ *\n.*                                                                    *\n.* StrMake                                                            *\n.*                                                                    *\n.* Build a string from literals and fields. Specific position and     *\n.* skips are also possible.                                           *\n.*                                                                    *\n.* Syntax                                                             *\n.*                                                                    *\n.*  STRMAKE fld,.,pos,.,fld,REG=R14|posreg,LR=lenreg,PRINT=print      *\n.*                                                                    *\n.*    fld   (field,length,conversion,out-length)                      *\n.*          length, conversion and out-length are optional.           *\n.*                                                                    *\n.*          field         label, (reg), literal, f.address            *\n.*          length        value, (reg), f|h|b.address                 *\n.*          conversion                                                *\n.*            C2B         storage -> binary c'0' and c'1'             *\n.*            CVD  | C2D  storage -> dec                              *\n.*                        in-length and out-length are reqd           *\n.*            CVDR        register -> dec                             *\n.*                        out-length is required                      *\n.*            CVXD | C2X  hex-> dec, i.e. x'1A' -> c'F1C1'            *\n.*            UNPK | P2D  packed dec i.e. x'0123C' -> c'123'          *\n.*            ST          store register asis (using STCM)            *\n.*            STH         store half of register asis (using STCM)    *\n.*                        out-length is required                      *\n.*          out-length    value, (reg), f|h|b.address                 *\n.*          pos           position in string                          *\n.*                        +n  skip n positions forward                *\n.*                        -n  skip n positions backward               *\n.*                        =n  position at n                           *\n.*                        =B  position at next blank                  *\n.*                                                                    *\n.*    posreg        register pointing to the end of the               *\n.*                  generated string. Default is R14.                 *\n.*    lenreg        register set to length of string                  *\n.*    print         print macro option OFF or NOGEN.                  *\n.*                                                                    *\n.* Registers 14, 15, 0 and 1 may be used internally as work regs, so  *\n.* the 'reg' value should not be any of those.                        *\n.*                                                                    *\n.* Conversion sub-functions typically uses the save are for storing   *\n.* intermediate values, so a save area must be available.             *\n.*                                                                    *\n.* ------------------------------------------------------------------ *\n&mlbl    StrMake &reg=R14,&print=,&lenck=N,&lenreg=,&lr=\n         aif   (k'&print eq 0).pr1n\n         push  print\n         print &print\n.pr1n    anop\n         lcla  &pix,&litl,&incr,&n,&mvcn\n         lclc  &str,&fld,&srcl,&cnv,&src,&srcu,&tgt,&tgtl,&s,&lbl,&outl\n         lclc  &mask,&lb1,&r,&lm(4),&unpkadr,&strl\n         gblc  strmakea,strmakel,&strp2dl\n&lm(1)   setc  '1'\n&lm(2)   setc  '3'\n&lm(3)   setc  '7'\n&lm(4)   setc  '15'\n.*\n.* output string address\n.*\n&str     setc  '&syslist(1,1)'\n         aif   ('&str' eq '*').setstrn\n         aif   (k'&str eq 0).setstrn\n         $la   &reg,&str               ->str\n&strl    setc  '&syslist(1,2)'\n         aif   (k'&strl ne 0).strl2\n&strl    setc  'l''&str'\n.strl2   anop\n&strmakea setc '&str'                  remember address\n&strmakel setc '&strl'                 remember length\n.setstrn anop\n.*-\n.* do over parmlist\n.*-\n&pix     seta  1\n.scan    anop\n&lbl     setc  'SM&sysndx.#&pix'\n&pix     seta  &pix+1\n         aif   (&pix gt n'&syslist).quit\n&src     setc  '&syslist(&pix,1)'\n&srcu    setc  (UPPER '&src')\n&srcl    setc  '&syslist(&pix,2)'\n         aif   (k'&srcl ne 0).srcl2\n&srcl    setc  'l''&src'\n.srcl2   anop\n&cnv     setc  (UPPER '&syslist(&pix,3)')\n&outl    setc  '&syslist(&pix,4)'\n.* junction 1\n         aif   ('&src '(1,1) ne '=').tpositn\n         aif   ('&src '(2,1) eq '(').posit     position in register\n&n       seta  k'&src\n&s       setc  '&src'(2,&n-1)\n         aif   (t'&s eq 'N').posit\n.tpositn anop\n         aif   ('&srcu'(1,2) eq '=B').posbl\n         aif   (T'&src eq 'N').posit\n         aif   ('&src'(1,1) eq '+').skip\n         aif   ('&src'(1,1) eq '-').skipb\n.* the width check is not very good, but better than nothing\n&s       setc  Upper('&lenck ')\n         aif   ('&s'(1,1) ne 'Y' and n'&syslist(1) lt 2).lenckn\n         $la   r15,&strmakea\n         $la   r0,&strmakel\n         ar    r15,r0\n         $la   r0,&outl,&srcl\n         ar    r0,&reg                    -> after insert\n         cr    r0,r15\n         jl    &lbl.s\n         mvi   0(r14),c'+'\n&s       setc  'SM&sysndx.Q'\n         j     &s\n&lbl.s   equ   *\n.lenckn  anop\n.* width check end\n.* junction 2\n         aif   ('&src '(1,1) eq '''').lit\n         aif   (k'&cnv eq 0).mvc\n         aif   ('&cnv' eq 'CVD').c2d      binary to decimal\n         aif   ('&cnv' eq 'C2D').c2d              -\n         aif   ('&cnv' eq 'CVDR').cvdr    binary in reg to decimal\n         aif   ('&cnv' eq 'P2D').p2d      packed dec -> zoned\n         aif   ('&cnv' eq 'UNPK').p2d             -\n         aif   ('&cnv' eq 'C2B').c2b      byte to readable bits\n         aif   ('&cnv' eq 'C2X').c2x      hex to readable hex\n         aif   ('&cnv' eq 'CVX').c2x              -\n         aif   ('&cnv' eq 'CVXD').c2x             -\n         aif   ('&cnv' eq 'ST').st        store register\n         aif   ('&cnv' eq 'STH').sth      store register halfword\n         mnote 8,'invalid format: &cnv'\n         ago   .quit\n.*-\n.* src is a field\n.* 'outl' is max length\n.*-\n.mvc     anop\n         $la   r15,&srcl\n         ltr   r15,r15\n         jz    &lbl.N                        no data\n         aif   (k'&outl eq 0).mvc2\n         $la   r0,&outl\n         ltr   r0,r0                         zsro => no check\n         jz    &lbl.cf1\n         cr    r15,r0\n         jnh   &lbl.cf1\n         lr    r15,r0\n.mvc2    anop\n&lbl.cf1 cfi   r15,256\n         jh    &lbl.l                        long string\n         bctr  r15,0\n         $la   r1,&src\n         mvc   0(*-*,&reg),0(r1)\n         ex    r15,*-6\n         la    &reg,1(r15,&reg)\n         j     &lbl.n\n&lbl.l   equ   *\n         stm   r14,r15,12(r13)\n         lr    r0,&reg                       -> target\n         $la   r14,&src                      -> source\n         lr    r1,r15                        copy length\n         mvcl  r0,r14\n         lm    r14,r15,12(r13)\n         ar    &reg,r15\n&lbl.n   equ   *\n         ago   .scan\n.*-\n.* Convert hex value in register to decimal\n.*-\n.cvdr    anop                               source is register\n         cvd   &src,16(r13)\n         unpk  0(&outl,&reg),16(8,r13)\n         oi    &outl-1(&reg),x'f0'\n         la    &reg,&outl.(,&reg)\n         ago   .scan\n.*-\n.* Convert hex in string to decimal\n.*-\n.c2d     anop\n         st    &reg,68(,r13)               save pos\n         lr    r0,&reg                     preserve r14\n         StrC2d call,from=(&src,&srcl),to=((r0),&outl)\n         l     &reg,68(,r13)               load pos\n         ar    &reg,r0\n         ago   .scan\n.*-\n.* packed dec field\n.*-\n.p2d     anop                              packed dec\n         st    &reg,68(,r13)               save pos\n         lr    r0,&reg\n         StrP2D call,from=(&src,&srcl),to=((r0),&outl)\n         l     &reg,68(,r13)               load pos\n         ar    &reg,r0\n         ago   .scan\n.*-\n.* hex-to-char\n.*-\n.c2x     anop\n         st    &reg,68(,r13)               save pos\n.* preserve r14\n         lr    r1,&reg                     to addr\n.*  r14=from,r15=to,r0=len\n         StrC2X call,from=(&src,&srcl),to=(r1),setlen=Y\n         l     &reg,68(,r13)               load pos\n         ar    &reg,r0                     update pos\n         ago   .scan\n.*-\n.* byte to bits\n.*-\n.c2b     anop\n         st    &reg,68(,r13)               save pos\n         StrC2B call,from=&src,to=(&reg)\n         l     &reg,68(,r13)               load pos\n         la    &reg,8(,&reg)\n         ago   .scan\n.*-\n.* literal\n.*-\n.lit     anop\n         aif   (k'&src eq 3).lit100        one char\n&litl    seta  k'&src-2\n         mvc   0(&litl,&reg),=c&src\n         la    &reg,&litl.(,&reg)\n         ago   .scan\n.lit100  anop\n         mvi   0(&reg),c&src\n         la    &reg,1(,&reg)\n         ago   .scan\n.*-\n.* store register\n.*-\n.st      anop\n         stcm  &src,15,0(&reg)\n         la    &reg,4(,&reg)\n         ago   .scan\n.*-\n.* store lower half of register\n.*-\n.sth     anop\n         stcm  &src,3,0(&reg)\n         la    &reg,2(,&reg)\n         ago   .scan\n.*-\n.* skip\n.*-\n.skip    anop\n&s       setc  '&src'(2,k'&src-1)\n         ahi   &reg,&s\n         ago   .scan\n.skipb   anop\n&s       setc  '&src'(2,k'&src-1)\n         ahi   &reg,-&s\n         ago   .scan\n.*-\n.* position pointer in string\n.*-\n.posit   anop\n&c       setc  '&src'(2,k'&src-1)\n.*       la    &reg,&strmakea+&c-1\n         $la   &reg,&strmakea\n         $la   r15,&c\n         bctr  r15,0\n         ar    &reg,r15\n         ago   .scan\n.*-\n.* position at next blank\n.*-\n.posbl   anop\n         cli   0(&reg.),c' '\n         bne   *+8\n         bct   &reg.,*-8\n         la    &reg.,1(,&reg.)\n         ago   .scan\n.*-\n.* end of macro\n.*-\n.quit    anop\n&r       setc  '&lenreg&lr'\n         aif   (k'&r eq 0).lenregn\n         $la   r0,&strmakea\n         sr    r14,r0\n         lr    r0,r14                    copy gend length\n         lr    &r,r14\n.lenregn anop\n         aif   (k'&print eq 0).pr2n\n         pop  print\n.pr2n    anop\n&s       setc  'SM&sysndx.Q'\n&s       ds    0h\n         Mend\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GETUADD$": {"ttr": 2309, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x02\\x01\\x19\\x14o\\x01\\x19\\x14o!\\x05\\x00\\x1c\\x00\\x1c\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-05-26T00:00:00", "modifydate": "2019-05-26T21:05:02", "lines": 28, "newlines": 28, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(GETUADDR)\n//SYSUT1   DD UNIT=SYSDA,SPACE=(CYL,20)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=SYSDA,SPACE=(TRK,30),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,RENT,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLIN   DD  DSN=&&TEMP,DISP=(OLD,PASS)\n//         DD  DDNAME=SYSIN\n//SYSIN    DD  *\n ENTRY   GETUADDR\n SETSSI  CB497836\n SETCODE AC(0)\n NAME    GETUADDR(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "GETUADDR": {"ttr": 2311, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x02\\x01\\x19\\x14o\\x01\\x19\\x14o!\\x05\\x00\\xf7\\x00\\xf7\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-05-26T00:00:00", "modifydate": "2019-05-26T21:05:02", "lines": 247, "newlines": 247, "modlines": 0, "user": "SBGOLOB"}, "text": "         TITLE 'DISPLAY VOLUME COMMAND'\nZERO     EQU   X'00'                   ZERO\nSPACE    EQU   C' '                    SPACE\nSIGNF    EQU   X'F0'                   POSITIVE SIGN\nGETUADDR CSECT\nGETUADDR AMODE 24\nGETUADDR RMODE 24\n         YREGS\n         BAKR  R14,0                   SAVE CALLER'S ARS + GPRS\n*                                      IN THE LINKAGE STACK\n         USING GETUADDR,R12            SET UP PROGRAM BASE REGISTER\n         LAE   R12,0(R15,0)            SET UP PROGRAM BASE REGISTER\n         LM    R3,R8,0(R1)             LOAD PARM @\n         USING RVOLUME,R3              INFORM THE ASSEMBLER\n         USING DEVNUM,R4               INFORM THE ASSEMBLER\n         USING DSTATUS,R5              INFORM THE ASSEMBLER\n         USING PATHAREA,R6             INFORM THE ASSEMBLER\n         USING RETCODE,R7              INFORM THE ASSEMBLER\n         USING REASONC,R8              INFORM THE ASSEMBLER\nGETWORK  EQU   *\n         L     R9,=AL4(WORKALEN)       WORK AREA LENGTH\n         STORAGE OBTAIN,LENGTH=(R9),ADDR=(R10),SP=0,KEY=8,             X\n               LOC=BELOW,COND=NO,RELATED=(FREEWORK,'FREE WORK AREA')\n         LR    R13,R1                  @ THE WORKAREA\n         USING SAVEAREA,R13            INFORM THE ASSEMBLER\n         MVC   PREVSA,=C'F1SA'         PUT ACRONYM INTO SAVEAREA\n*                                      TO INDICATE STATUS SAVED ON\n*                                      THE LINKAGE STACK\nMAINLINE EQU   *\n         MVC   RC,=X'00000000'         SET THE RETURN CODE\n         MVC   RSCODE,=X'00000000'     SET THE REASON CODE\n         BAL   R2,UCBSCAN              GET DEVICE NUM FOR VOLSER\nRETURN   EQU   *\n         LAE   R1,0(R13,0)             ADDRESS TO FREE\n         L     R9,=AL4(WORKALEN)       WORK AREA LENGTH\n         STORAGE RELEASE,ADDR=(R1),LENGTH=(R9),SP=0,KEY=8,             X\n               COND=NO,RELATED=(GETWORK,'OBTAIN WORK AREA')\n         SLR   R15,R15                 SET RC TO ZERO\n         PR                            RESTORE CALLER'S ARS\n*                                      GPRS 2-14 AND RETURN\n*                                      TO CALLER\n         TITLE 'SCAN THE UCBS TO OBTAIN THE UCB ADDRESSES'\nUCBSCAN  EQU   *\n         XC    IOTOKEN,IOTOKEN         ZEROIZE\n         XC    UCBSWA,UCBSWA           ZEROIZE\n         MVC   VOLUME,VOL              VOLUME TO CHECK\nUCBCHECK EQU   *\n         MVC   UCBLPARM,UCBPARM        MOVE UCBSCAN PARM AREA\n         UCBSCAN COPY,                                                 X\n               WORKAREA=UCBSWA,                                        X\n               UCBAREA=UCBCS,                                          X\n               CMXTAREA=UCBES,                                         X\n               UCBPAREA=UCBPES,                                        X\n               DCEAREA=DCEES,                                          X\n               DCELEN=DCEESLEN,                                        X\n               VOLSER=VOLUME,                                          X\n               DYNAMIC=YES,                                            X\n               RANGE=ALL,                                              X\n               IOCTOKEN=IOTOKEN,                                       X\n               DEVCLASS=DASD,                                          X\n               DEVNCHAR=DNUM,                                          X\n               LINKAGE=SYSTEM,                                         X\n               RETCODE=UCBRTCDE,                                       X\n               RSNCODE=UCBRSCDE,                                       X\n               MF=(E,UCBLPARM,COMPLETE)\n         LTR   R15,R15                 UCB RETURNED?\n         BNZ   UCBCERR                 UCB SCAN ERROR\n         LA    R9,UCBCS                @ UCB\n         USING UCB,R9                  INFORM THE ASSEMBLER\nDVCODE   EQU   *\n         MVC   DEVCODE,UCBTBYT4        DEVICE CODE\nONOROFF  EQU   *\n         MVC   STATUS,=CL7'ONLINE '    DEVICE ON-LINE\n         TM    UCBSTAT,UCBONLI         DEVICE ON-LINE?\n         BO    PENDING                 YES-\n         MVC   STATUS,=CL7'OFFLINE'    DEVICE ON-LINE\nPENDING  EQU   *\n         TM    UCBSTAT,UCBCHGS         CHANGING STAT?\n         BNO   ALLOC                   NO\n         MVC   STATUS,=CL7'PENDING'    DEVICE ON-LINE\nALLOC    EQU   *\n         MVI   VALLOC,C'Y'             DEVICE IS ALLOCATED\n         TM    UCBSTAT,UCBALOC         DEVICE ALLOCATED?\n         BO    SMSINDC                 YES-\n         MVI   VALLOC,C'N'             DEVICE NOT ALLOCATED\nSMSINDC  EQU   *\n         MVI   SMSIND,C'Y'             DEFAULT\n         TM    UCBFL5,UCBSMS           SMS DEVICE?\n         BO    CHKUSE                  YES-\n         MVI   SMSIND,C'N'             NO-\nCHKUSE   EQU   *\n         MVI   VOLUSE,C'1'             PRIVATE\n         TM    UCBSTAB,UCBBPRV         PRIVATE?\n         BO    CHKMOUNT                YES-\n         MVI   VOLUSE,C'2'             PUBLIC\n         TM    UCBSTAB,UCBBPUB         PUBLIC?\n         BO    CHKMOUNT                YES-\n         MVI   VOLUSE,C'3'             STORAGE\n         TM    UCBSTAB,UCBBSTR         STORAGE?\n         BO    CHKMOUNT                YES-\n         MVI   VOLUSE,C'0'             ?\nCHKMOUNT EQU   *\n         MVI   VOLMOUNT,C'1'           DEFAULT\n         TM    UCBSTAT,UCBRESV         RESERVED?\n         BO    SHARED                  YES-\n         MVI   VOLMOUNT,C'2'           DEFAULT\n         TM    UCBSTAT,UCBPRES         PERMANENTLY RESERVED?\n         BO    SHARED                  NO-\n         MVI   VOLMOUNT,C'0'           ?  -\nSHARED   EQU   *\n         MVI   VOLSHARE,C'Y'           DEFAULT\n         TM    UCBTBYT2,UCBRR          SHARED VOLUME?\n         BO    SYSRSVOL                YES-\n         MVI   VOLSHARE,C'N'           DEFAULT\nSYSRSVOL EQU   *\n         MVI   SYSRES,C'N'             DEFAULT\n         TM    UCBSTAT,UCBSYSR         SYSRES VOLUME?\n         BNO   CHKUCBX                 NO-\n         MVI   SYSRES,C'Y'             YES-\nCHKUCBX  EQU   *\n         LA    R11,UCBPES              @ UCB PREFIX AREA\n         USING UCBPDATA,R11            INFORM THE ASSEMBLER\n         MVI   PAGEDEV,C'N'            SET DEFAULT\n         TM    UCBMIHTI,UCBPGDEV       PAGING DEVICE?\n         BNO   DASDRSV                 NO-\n         MVI   PAGEDEV,C'Y'            SET DEFAULT\nDASDRSV  EQU   *\n         MVI   RESERVED,C'N'           DEFAULT\n         TM    UCBIOSF1,UCBRESVH       DEVICE RESERVED?\n         BNO   MOVEISC                 NO-\n         MVI   RESERVED,C'Y'           YES-\nMOVEISC  EQU   *\n         XR    R10,R10                 CLEAR\n         ICM   R10,B'0011',UCBPMCW1    PICK UP INTERRUPTION SUBCLASS\n         SRL   R10,11(0)               LASTBYTE= 00000ISC\n         N     R10,=X'00000007'        TURN OFF ALL BITS EXCEPT LAST\n*                                      THREE BITS\n         STC   R10,ISC                 STORE FOR CALLER\nSCPROG   EQU   *\n         LA    R11,UCBES               @ UCB COMMON EXTENSION\n         USING UCBCMEXT,R11            INFORM THE ASSEMBLER\n         MVI   SUSPCP,C'N'             DEFAULT\n         TM    UCBFL7,UCBSSPND         SUSPENDED CHANNEL PROGRAM?\n         BNO   INFOUCB                 NO-\n         MVI   SUSPCP,C'Y'             DEFAULT\nINFOUCB  EQU   *\n         MVC   UCBINFP,UCBINF          MOVE UCBINF PARM AREA\n         UCBINFO PATHINFO,                                             X\n               PATHAREA=PATHINFO,                                      X\n               DEVN=UCBCHAN,                                           X\n               LINKAGE=SYSTEM,                                         X\n               RETCODE=UCBIRTCD,                                       X\n               RSNCODE=UCBIRSCD,                                       X\n               MF=(E,UCBINFP,COMPLETE)\n         LTR   R15,R15                  UCBINFO OKAY?\n         BNZ   UCBIERR                  NO-\n         DROP  R9                       INFORM THE ASSEMBLER\n         LA    R9,PATHINFO              @ THE PATH INFO\n         USING PATH,R9                  INFORM THE ASSEMBLER\n         MVC   PATHCNT,PATH#CHPIDS      NO OF INSTALLED PATHS\n         LA    R6,L'PATHCNT(,R6)        RE-POSITION\n         ICM   R10,B'1111',PATH#CHPIDS  NO OF INSTALLED PATHS\n         BZR   R2                       RETURN TO CALLER\nPATHMOVE EQU   *\n         MVC   CHPID,PATHCHPID          CHPID\n         MVC   PBITS,PATHBITS           PATH BITS\n         MVC   PTYPE,PATHINTTYPE        PATH TYPE\n         LA    R6,PCHPLEN(,R6)          NEXT TABLE ENTRY\n         LA    R9,L'PATHCHPIDARRAY(,R9) NEXT TABLE ENTRY\n         BCT   R10,PATHMOVE             DO WHILE R10 > 0?\nEXIT     EQU   *\n         BR    R2                       RETURN TO CALLER\n         TITLE 'ERROR SECTION'\nUCBIERR  EQU   *\n         STCM  R15,B'1111',RC           RETURN CODE\n         MVC   RSCODE,UCBIRSCD          REASON CODE\n         MVI   PATHCNT,C'I'             UCBINFO ERROR\n         BR    R2                       RETURN TO CALLER\nUCBCERR  EQU   *\n         STCM  R15,B'1111',RC           RETURN CODE\n         MVC   RSCODE,UCBRSCDE          REASON CODE\n         MVI   PATHCNT,C'C'             UCBCOPY ERROR\n         BR    R2                       RETURN TO CALLER\n         LTORG\nUCBPARMA DS    CL1                      UCBSCAN AREA\n         UCBSCAN MF=(L,UCBPARM)\n         UCBINFO MF=(L,UCBINF)\nUCBLSIZE EQU   1                        NO OF UCB ADDRESSES\nDEVSIZE  EQU   36                       RETURNED INFO LENGTH\nDCEESLEN DC    AL2(128)                 DCE EXTENSION SEGMENT LENGTH\nWORKAREA DSECT\nSAVEAREA DS    CL72                     SAVEAREA\nPREVSA   EQU   SAVEAREA+4,4             @ OF PREVIOUS SAVEAREA\nUCB@     DS    AL4                      UCB ADDRESS\nUCBPFX@  DS    AL4                      UCB PREFIX ADDRESS\nUCBSWA   DS    CL100                    UCBSCAN WORK AREA\nUCBCS    DS    CL48                     UCB COMMON SEGMENT\nUCBES    DS    CL32                     UCB EXTENSION SEGMENT\nUCBPES   DS    CL32                     UCB PREFIX EXTENSION SEGMENT\nDCEES    DS    CL128                    DCE EXTENSION SEGMENT\nVOLUME   DS    CL6                      VOLUME\nDEVNO    DS    CL4                      CURRENT DEVICE NO\nIOTOKEN  DS    CL48                     DYNAMIC I/O TOKEN\nUCBRTCDE DS    F                        RETURN CODE\nUCBRSCDE DS    F                        REASON CODE\nUCBLPARM DS    CL(UCBPARML)             UCBSCAN PARAMETER AREA\n         DS    0D\nUCBINFP  DS    CL(UCBINFL)              UCBINF PARAMETER AREA\nPATHINFO DS    XL256                    UCBINFO PATH INFORMATION\n         DS    0F\nUCBIRTCD DS    XL4                      UCBINFO RETURN CODE\nUCBIRSCD DS    XL4                      UCBINFO REASON CODE\nWORKALEN EQU   *-WORKAREA               WORK AREA LENGTH\nRVOLUME  DSECT\nVOL      DS    CL6                      VOLUME SERIAL NO\nDEVNUM   DSECT\nDNUM     DS    CL4                      DEVICE NUMBER\nDSTATUS  DSECT\nSTATUS   DS    CL7                      STATUS\nPATHAREA DSECT\nSMSIND   DS    C                        SMS INDICATOR\nVOLMOUNT DS    C                        MOUNT ATTRIBUTE\nVOLUSE   DS    C                        USE ATTRIBUTE\nVOLSHARE DS    C                        SHARED DASD\nVALLOC   DS    C                        DEVICE ALLOCATED\nPAGEDEV  DS    C                        PAGING DEVICE\nISC      DS    X                        INTERRUPT SUBCLASS MASK\nSUSPCP   DS    C                        SUSPENDED CHANNEL PROGRAM\nDEVCODE  DS    X                        DEVICE CODE FROM UCBTBYT4\nRESERVED DS    C                        DASD RESERVED BYTE\nSYSRES   DS    C                        SYSRES DEVICE\nPATHCNT  DS    XL4                      NO OF CHANNEL PATHS\n         ORG   PATHCNT\nCHPID    DS    XL2                      CHANNEL PATHS\nPBITS    DS    X                        PATH BITS\nPTYPE    DS    X                        PATH TYPE\nPCHPLEN  EQU   *-CHPID                  ENTRY LENGTH\nRETCODE  DSECT\nRC       DS    AL4                      RETURN CODE\nREASONC  DSECT\nRSCODE   DS    AL4                      REASON CODE\nUCB      DSECT\n         IEFUCBOB                       UCB MACRO ID\n         IOSDUPI\n         IOSDPATH\n         CVT   DSECT=YES,LIST=NO\n         END   GETUADDR\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LLASTATS": {"ttr": 2316, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x08\\x01 \\x10O\\x01 \\x11O\\x116\\x00\\xb7\\x00\\xbe\\x00\\x00\\xe2\\xd3\\xc2\\xc4@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2020-04-13T00:00:00", "modifydate": "2020-04-23T11:36:08", "lines": 183, "newlines": 190, "modlines": 0, "user": "SLBD"}, "text": "/* REXX - LLASTATS */\n\n/*-------------------------------------------------------------------*/\n/*                                                                   */\n/*  L L A  Statistics                                                */\n/*  -----------------                                                */\n/*                                                                   */\n/*  Source:  XEPHON 186 (CBT) - dated March 2002                     */\n/*  Article title:  \"Monitoring LLA activity\", page 3                */\n/*  Author:  Mile Pekic, Systems Programmer, Postal Savings Bank,    */\n/*  Yugoslavia                                                       */\n/*                                                                   */\n/*  Updated 23Apr2020, Lionel B. Dyck, 21st Century Software.        */\n/*  . Remove perm dsnames and intermediate console msg datasets      */\n/*                                                                   */\n/*  Updated 15Mar2020, William J. Smith, Trident Services, Inc.,     */\n/*  Capitola, CA                                                     */\n/*  . Reformatted totals line 'left' functions to adjust the column  */\n/*    alignment of each value                                        */\n/*  . Changed BROWSE to VIEW function to allow for quick sorting of  */\n/*    displayed output                                               */\n/*                                                                   */\n/*  Updated 14Mar2020, William J. Smith, Trident Services, Inc.,     */\n/*  Capitola, CA                                                     */\n/*  . Corrected, reformatted, and tested on z/OS 2.3 RSU 1906        */\n/*  . Uses an undocumented z/OS system command to display LLA        */\n/*    statistics \"D LLA,STATISTICS\"                                  */\n/*  . LLASTAT parses the output from the D LLA,STATISTICS command    */\n/*    and formats a report which is displayed using ISPF BROWSE      */\n/*  . Courtesy Mile Pekic, Systems Programmer, Postal Savings Bank   */\n/*    (Yugoslavia)                                                   */\n/*  . Most of Mr. Pekic's code has been left intact/unchanged        */\n/*                                                                   */\n/*  Consider changing the comds and comfm data set names to remove   */\n/*  duplicate specification of the userid in the constructed data    */\n/*  set names.  DCB was changed to half-track for each data set.     */\n/*                                                                   */\n/*  Note:  Contact Peter Relson, IBM Poughkeepsie, to obtain the     */\n/*  IBM Module Fetch Monitor, as described in the Xephon article.    */\n/*  Email:  relson@us.ibm.com                                        */\n/*                                                                   */\n/*-------------------------------------------------------------------*/\n\n/*-------------------------------------------------------------------*/\n/* Part I: Issue MVS command and write the output to a file          */\n/*-------------------------------------------------------------------*/\n\n/*Trace ?i*/\n/*Trace ?r*/\n\nAddress TSO\n  userid = sysvar('sysuid')\n  cmdds = userid||'.comds.out'            /* Change data set names */\n  cpu_seconds = sysvar(syscpu)\n  begin = time(R)\n  cart = sysvar('sysuid')\n\n/*-------------------------------------------------------------------*/\n/* Console environment                                               */\n/*-------------------------------------------------------------------*/\n\n x = MSG('OFF')\n SD = SYSVAR(\"SOLDISP\")\n USD = SYSVAR(\"UNSDISP\")\n If SD = 'YES' then\n   \"CONSPROF SOLDISP(NO)\"           /* Console Profile  solicited    */\n If USD = 'YES' then                /* unsolicited must be NO to be  */\n   \"CONSPROF UNSOLDISP(NO)\"         /* able to catch command response*/\n \"CONSPROF SOLNUM(400) UNSOLNUM(400)\"\n\n x = MSG('ON')\n \"CONSOLE ACTIVATE CART(\"cart\")\"         /* Activate CONSOLE service */\n\n \"CONSOLE SYSCMD(D LLA,STATISTICS) CART(\"cart\")\"\n getcode = GETMSG('cons_msg.','SOL',cart,,5)\n\n \"CONSOLE DEACTIVATE\"                       /* Close console session */\n\n/*-------------------------------------------------------------------*/\n/* Copy the command response to output data set                      */\n/*-------------------------------------------------------------------*/\n\n If SD = 'YES' then\n   \"CONSPROF SOLDISP(\"SD\")\"\n If USD = 'YES' then\n   \"CONSPROF UNSOLDISP(\"USD\")\"\n x = MSG('OFF')\n\n \"ALLOC FILE(CMDOUT)\" ,\n    \" UNIT(SYSALLDA) NEW TRACKS SPACE(2,1)\" ,\n    \" REUSE LRECL(133) RECFM(F B) BLKSIZE(27930)\"\n  \"ALLOC FILE(fout)\" ,\n    \" UNIT(SYSALLDA) NEW TRACKS SPACE(2,1)\",\n    \" REUSE LRECL(80) RECFM(F B) BLKSIZE(27920)\"\n\n /*------------------------------------------------------------------*/\n /* Part II: Formatting captured output & printing it to a new file  */\n /*------------------------------------------------------------------*/\n\n /*------------------------------------------------------------------*/\n /* Print header and labels                                          */\n /*------------------------------------------------------------------*/\n\n   Out.1 = left(' ',20,' '),\n           ||center('Display LLA Statistics ',22,),\n           ||left(' ',15,' ')\n   Out.2 = left(' ',10,' '),\n           ||center('Report produced on',18,),\n           ||left(' ',1,' ')||left(date(),11),\n           ||left(' ',1,' ')||left('at ',3,' '),\n           ||left(time(),10)\n   Out.3 = ' '\n   Out.4 = left('LLA entry',28) left('members',8),\n       left('members',8) left('members',8),\n       left('dasd',8) left('vlf',4)\n   Out.5 = left(' ',37) left('fetched',8) left('in vlf',7),\n       left('fetched',8) left('retrieves',9)\n   Out.6 = left('-',73,'-')\n   t = 6\n\n/*-------------------------------------------------------------------*/\n/* Read command output                                               */\n/*-------------------------------------------------------------------*/\n\n   tmem  = 0\n   tmemf = 0\n   tmemv = 0\n   tdasd = 0\n   tvlfr = 0\n   i=4\n  do while(i <= cons_msg.0)\n    dsname = SUBSTR(cons_msg.i,11,25)\n    i = i+1\n    mem = SUBSTR(cons_msg.i,26,5)\n    tmem = tmem + mem\n    i = i+1\n    memf = SUBSTR(cons_msg.i,26,5)\n    memv = SUBSTR(cons_msg.i,54,5)\n    tmemf = tmemf + memf\n    tmemv = tmemv + memv\n    i = i+1\n    dasdf = SUBSTR(cons_msg.i,26,5)\n    vlfr = SUBSTR(cons_msg.i,54,5)\n    tdasd = tdasd + dasdf\n    tvlfr = tvlfr + vlfr\n    i = i+1\n    t = t+1\n\n/*-------------------------------------------------------------------*/\n/* Formatting and printing list of LLA enties                        */\n/*-------------------------------------------------------------------*/\n\n Out.t = left(dsname,27) left(mem,7) left(memf,8) left(memv,8),\n      left(dasdf,7) left(vlfr,7)\n End\n t = t + 1\n\n/*-------------------------------------------------------------------*/\n/* Print footer                                                      */\n/*-------------------------------------------------------------------*/\n\n Out.t = left('-',67,'-')\n  t = t + 1\n  Out.t = left('Totals',27) left(tmem,8) left(tmemf,9) left(tmemv,6),\n  left(tdasd,8) left(tvlfr,7)\n  t = t + 1\n  Out.t = left(' ',63,' ')\n  t = t + 1\n elapsed_seconds = time(E)\n cpu_seconds = Sysvar(SYSCPU)-cpu_seconds\n Out.t = 'This REXX EXEC used' cpu_seconds 'CPU-seconds' ,\n     'and' elapsed_seconds 'in elapsed time (seconds).'\n  Out.0 = t\n   \"EXECIO * DISKW fout (Finis STEM Out.)\"\n      Address ISPExec\n      'lminit dataid(ddb) ddname('fout')'\n      'view dataid('ddb')'\n      'lmfree dataid('ddb')'\n  Address TSO\n  \"Free file(fout)\"\n\n Exit\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LOADPAR@": {"ttr": 2563, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00$\\x01\\x10 o\\x01\\x100\\x8f#\\x14\\x00\\x7f\\x00\\x7f\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2010-07-25T00:00:00", "modifydate": "2010-11-04T23:14:24", "lines": 127, "newlines": 127, "modlines": 0, "user": "SBGOLOB"}, "text": "Obtaining the ESA LOADPARM with REXX  (was member BAE42C57 in File 830)\n\nTHE NEED\n\nOne day, I was required to change the IEASYSnn member in\nSYS1.PARMLIB. When the edit selection member list displayed,\nI found several IEASYSnn members. No problem, I thought, I'll\njust look at LOADnn to see which IEASYSnn is the 'active'\nmember. Imagine my shock when I found several LOADnn\nmembers pointing to several IEASYSnn members. My first\nreaction was that I'd have to get out of my chair, go downstairs to\nthe computer room, and check the OPRCTL frame to see which\nLOADnn member was specified. Well this was a repugnant\nthought to me. My wife would say this was because I'm averse to\nphysical activity but, in truth, I have a compulsion to do\neverything as efficiently as possible. With today's staffing realities,\nI usually find myself in a minimally staffed shop, so any tool I can\nlay my hands on to get the job done more quickly or easily is\nwelcome. Naturally those little gears in my head began to turn. I\ndecided that MVS/ESA had to be aware of the LOADPARM in\norder to IPL and, if ESA knew about it, it must be in a control\nblock somewhere. So my quest began.\n\nTHE SCCB\n\nThe Prefixed Save Area (PSA) is located at hexadecimal address\nzero. It is mapped by the IHAPSA macro. See Figure 1 for a\ngraphic example of the control block chains.\n\nAt a displacement of X'10' into the PSA is the FLCCVT, which\ncontains an address that points to the Communication Vector\nTable (CVT). The CVT is mapped by the CVT macro. At\ndisplacement X'340' in the CVT is the CVTSCPIN field, which\ncontains an address that points to the Service Call Control Block\n(SCCB). The SCCB is mapped by the IHASCCB macro. At\ndisplacement X'18' of the SCCB is the information we seek, in a\nfield called the SCCBPARM. The SCCBPARM is an eight-\ncharacter field that contains the same eight characters that appear\neither on the OPRCTL or SYSCTL system console frames. Voila,\nno trip downstairs to the computer room!\n\nThe format of the SCCBPARM (or LOADPARM if you wish) is\nddddlsin, where dddd is the device address of the volume\ncontaining the PARMLIB dataset, ls is the load suffix (the nn in\nLOADnn), i is the Initial Message Suppression Indicator (IMSI),\nand n is the nucleus-id (ie the IEANUC0 suffix).\n\nTHE LOADPARM EXEC\n\n1   /*REXX --------------------------------------------------------------*/\n2   /*                                                                   */\n3   /*  GRACE.EXEC(LP):                                                  */\n4   /*        Just a little EXEC to display the current IPL LOADPARM.    */\n5   /*                                                   GRACE  12.16.93 */\n6   /*-------------------------------------------------------------------*/\n7   Trace Errors\n8\n9   /*-------------------------------------------------------------------*/\n10  /*   Obtain the Service Call Control Block Parm:                     */\n11  /*     PSA (real loc x'00')                                          */\n12  /*       FLCCVT (PSA + x'10') ---> CVT                               */\n13  /*         CVTSCPIN (CVT + x'340') ---> SCCB                         */\n14  /*           SCCBPARM (SCCB + x'18')                                 */\n15  /*-------------------------------------------------------------------*/\n16  cvt_ptr = GET_ADDR(0,10)\n17  cvtscpin_ptr = GET_ADDR(cvt_ptr,'340')\n18\n19  loadparm = Storage(D2x(X2d(cvtscpin_ptr) + X2d('18')),'8')\n20\n21  Say 'The LOADPARM used for the current IPL is:' loadparm\n22\n23  Exit\n24\n25  GET_ADDR: Procedure\n26  /*-------------------------------------------------------------------*/\n27  /*   Return 4 byte hex pointer given hex addr (Arg(1)) and           */\n28  /*   hex offset (Arg(2)).                                            */\n29  /*-------------------------------------------------------------------*/\n30  Return C2x(Storage(D2x(X2d(Arg(1)) + X2d(Arg(2))),4))\n\nTo obtain the LOADPARM information the REXX function\nSTORAGE is used. The STORAGE function returns a specified\nnumber of bytes of storage from a given location. In statement 16,\nthe variable cvt_ptr is set to the value returned by the\nGET_ADDR internal procedure. Passed to the GET_ADDR\nprocedure is the address of the PSA (X'00') and the displacement\ninto the PSA of the FLCCVT (X'10').\n\nIn statement 30, the first argument (X'00' obtained by REXX\nfunction ARG) and the second argument (X'10' obtained with\nthe ARG function specifying 2 for the second argument) are\nconverted to decimal by the X2d function. This is done so that\nthey can be added together to generate the address we wish to\npass the STORAGE function. Once they are added together, the\nnew address is converted back to hexadecimal with the D2x\nfunction for input to the STORAGE function. A length of four is\nhard coded in this case because all address fields are 4 bytes.\n\nFinally, the resulting decimal address is converted back to\nhexadecimal with the C2x function because this new address will\nbe the foundation for another STORAGE request.\n\nI coded GET_ADDR as an internal procedure simply because I\nhave a personal habit of coding anything I use more than once as\na procedure. I could just as easily have coded a similar statement\nto statement 30 on both statements 16 and 17. In statement 17, the\nvariable cvtscpin_ptr is set to the address returned from the\nGET_ADDR procedure. This time the cvt_ptr address is used as a\nbase and the displacement into the CVT of the CVTSCPIN\n(X'340') is the second argument. Then in statement 19,\nsomething similar is done one last time. The cvtscpin_ptr is the\nbase and the displacement into the SCCB of the SCCBPARM is\nthe second argument. The difference this time is that the length is\neight instead of four and we don't want the result converted to\nhexadecimal because we are going to display it in statement 21.\n\nTHE END\n\nSo there we have it. Using the REXX STORAGE function, we\ncan chain through ESA control blocks to display information of\ninterest. It's much less time-consuming to type 'TSO %LC' when\nyou're unsure which is the 'active' LOADnn member than to\nmake that trip to the computer room.\n\nJoseph R Grace\nSenior Systems Programmer (USA)                                            1994\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LOADPARM": {"ttr": 2566, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00F\\x01\\x10 o\\x01\\x100\\x8f#\\x06\\x00\\x1e\\x00\\x7f\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2010-07-25T00:00:00", "modifydate": "2010-11-04T23:06:46", "lines": 30, "newlines": 127, "modlines": 0, "user": "SBGOLOB"}, "text": "/*REXX --------------------------------------------------------------*/\n/*                                                                   */\n/*  GRACE.EXEC(LP):                                                  */\n/*        Just a little EXEC to display the current IPL LOADPARM.    */\n/*                                                   GRACE  12.16.93 */\n/*-------------------------------------------------------------------*/\nTrace Errors\n\n/*-------------------------------------------------------------------*/\n/*   Obtain the Service Call Control Block Parm:                     */\n/*     PSA (real loc x'00')                                          */\n/*       FLCCVT (PSA + x'10') ---> CVT                               */\n/*         CVTSCPIN (CVT + x'340') ---> SCCB                         */\n/*           SCCBPARM (SCCB + x'18')                                 */\n/*-------------------------------------------------------------------*/\ncvt_ptr = GET_ADDR(0,10)\ncvtscpin_ptr = GET_ADDR(cvt_ptr,'340')\n\nloadparm = Storage(D2x(X2d(cvtscpin_ptr) + X2d('18')),'8')\n\nSay 'The LOADPARM used for the current IPL is:' loadparm\n\nExit\n\nGET_ADDR: Procedure\n/*-------------------------------------------------------------------*/\n/*   Return 4 byte hex pointer given hex addr (Arg(1)) and           */\n/*   hex offset (Arg(2)).                                            */\n/*-------------------------------------------------------------------*/\nReturn C2x(Storage(D2x(X2d(Arg(1)) + X2d(Arg(2))),4))\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MORESYSI": {"ttr": 2568, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x17\\x01\\x10 o\\x01\\x10#\\x7f!3\\x00f\\x00\\x84\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2010-07-25T00:00:00", "modifydate": "2010-08-25T21:33:17", "lines": 102, "newlines": 132, "modlines": 0, "user": "SBGOLOB"}, "text": "More about MVS control blocks\n\nRoger Bowler's article, Some useful fields in MVS control blocks (MVS\nUpdate, July 1988), is a good compendium of information that old systems\nprogrammers have managed to pick up over the years, but which has never\nbefore been presented all together for the rookie systems programmer.  I\nwould like to add the following comments to Roger's notes.\n\nIn an ACF2 shop it is possible to find a TSO user's terminal-id without\ngetting into key zero or being APF-authorised.  While you are there, you\ncan also get the JES job-id and the ACF2 logon-id (which, for a TSO job,\nis the same as the TSO user-id).  Here is a bit of code to do the job:\n\n         ACFASVT DSECT=YES             (SYS1.ACFMAC)\n         ACCVT   DSECT=YES             (SYS1.ACFMAC)\n         IHAASCB DSECT=YES             (SYS1.AMODGEN)\n         IHAPSA  DSECT=YES             (SYS1.AMODGEN)\n         .\n         .\n         ACFGACVT R11,NONE=NOACF2 GET ACCVT ADDRESS\n         USING ACCVT,R11          SET UP BASE FOR ACCVT\n         ICM   R11,B'1111',ACCASVT GET POINTER TO ACFASVT\n         BZ    NOACF2             ERROR IF NONE\n         USING ACFASVT,R11        SET UP BASE FOR ACFASVT\n         USING PSA,R0             SET UP BASE FOR PSA\n         L     R10,PSAAOLD        GET ASCB ADDR FOR THIS JOB\n         USING IHAASCB,R10        SET UP BASE FOR ASCB\n         LH    R4,ASCBASID        GET ASID FOR THIS JOB\n         SLL   R4,ASVINDEX        CONVERT TO ACFASVT OFFSET\n         LA    R11,ACFASVT(R4)    POINT TO OUR ACFASVT ENTRY\n         MVC   termid(8),ASVSRC   MOVE LOGICAL SOURCE ID\n         MVC   logonid(8),ASVLID  MOVE USER LOGONID\n         MVC   jobid(8),ASVJID    MOVE JES JOBID\n\nThe NOACF2 label is an error branch for the odd case where ACF2 is not\nup when your program is running.  The ACFGACVT macro calls the $ACFGCVT\nroutine, which you must link in with your program from SYS1.ACFMOD.\n\nRoger says that the SMF system-id is used by JES2 to identify the\nsystems in a multi-access spool complex.  This is frequently the case,\nbut need not be; the SMF-id is used only if a different JES-id is not\nspecified in the JES2 initialisation deck.\n\nThere are valid reasons for having different JES2 and SMF system-ids for\nthe same machine.  For example, at one shop where I worked, the JES2\nsystem-ids were published and never changed: SYSA for production, SYSB\nfor test, SYSC for engineering jobs, etc.  We kept them  the  same so\nthat our users  would  not have to  change  the /*JOBPARM cards they\nused to route their jobs to particular systems and because it took a\nJES2 cold start to change them.\n\nHowever, we would change the SMF system-ids when we were testing new\nversions of the operating system so we could identify the SMF records\ncut during testing more easily.  The users never saw the SMF system-ids\nso they were not bothered by the changes.\n\nHere is some code to find the JES2 system-id:\n\n         $HASPEQU ,                 (SYS1.HASPSRC--NEEDED BY $SVT)\n         $SCAT ,                    (SYS1.HASPSRC--NEEDED BY $SVT)\n         $XECB ,                    (SYS1.HASPSRC--NEEDED BY $SVT)\n         $SVT ,                     (SYS1.HASPSRC)\n         IEFJESCT ,                 (SYS1.MACLIB)\n         IEFJSCVT ,                 (SYS1.MACLIB)\n         CVT   DSECT=YES            (SYS1.AMODGEN)\n         .\n         .\n         L     R8,CVTPTR            SET UP BASE FOR CVT\n         USING CVTMAP,R8            ...\n         L     R7,CVTJESCT          SET UP JES CONTROL TABLE BASE\n         USING JESCT,R7             ...\n         L     R6,JESSSCT           FIRST SSCT IS FOR JES2\n         USING SSCT,R6              SET UP A BASE FOR IT\n         L     R5,SSCTSSVT          SET UP BASE FOR JES2 SSVT\n         USING SSVT,R5\n         MVC   jesid(4),SVTSID      GET THE JES2 SYSTEM ID\n\nThe SVTSID field used to be called $SVSID - somewhere around JES2 1.3.6\nit was renamed.  I should mention that you should never, ever, use\nhard-coded offsets for JES2 control blocks.  The developers of JES2\nthink nothing of adding fields in the middle of control blocks, making\nall the following offsets change.  If you refer to the fields by name\nyou will pick up the change by just re- assembling your program.  Of\ncourse, when they rename the fields out from under you, you are still in\ntrouble.\n\nFinding jobs by running the CSCB chain is the accepted way of doing\nthings, but it won't find you everything.  Some system address spaces\nthat are started at IPL do not have CSCBs.  They are things like\nCONSOLE, the DIDOCS address space, and usually you won't want to look at\nthem anyway.\n\nThere are also a few jobs with extra CSCBs, most notably external\nwriters.  When you start an external writer, say to a printer at unit\naddress 00E, the external writer creates a CSCB with a CHKEY of 00E, so\nthat if you want to cancel the job that is printing, you can enter C 00E\non the console.\n\nLynn Grant\nTechnical Consultant (USA)    \u20ac        1988\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PRSMINFO": {"ttr": 2571, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x18\\x01\\x19\\x08?\\x01\\x19\\x08?\\x152\\x060\\x060\\x00\\x00\\xe7\\xd4\\xc9\\xe3@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-03-24T00:00:00", "modifydate": "2019-03-24T15:32:18", "lines": 1584, "newlines": 1584, "modlines": 0, "user": "XMIT"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "RACFAUT$": {"ttr": 3331, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x19\\x14o\\x01\\x19\\x14o\\x16R\\x00\\x1c\\x00\\x1c\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-05-26T00:00:00", "modifydate": "2019-05-26T16:52:00", "lines": 28, "newlines": 28, "modlines": 0, "user": "IBMUSER"}, "text": "//IBMUSERU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,RLD)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSIN    DD DISP=SHR,DSN=IBMUSER.B.ASM(RACFAUTH)\n//SYSUT1   DD UNIT=SYSDA,SPACE=(CYL,20)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=SYSDA,SPACE=(TRK,30),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=(OLD,PASS),DSN=&&TEMP\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB\n ORDER   RACFAUTH\n SETCODE AC(1)\n SETSSI  CB498836\n ENTRY   RACFAUTH\n NAME    RACFAUTH(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RACFAUT@": {"ttr": 3333, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x007\\x01\\x10 o\\x01\\x19\\x08?\\x158\\x00\\xe6\\x00\\xe5\\x00\\x00\\xc1\\xd9\\xe3\\xc9\\xc3\\xd3\\xc5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2010-07-25T00:00:00", "modifydate": "2019-03-24T15:38:37", "lines": 230, "newlines": 229, "modlines": 0, "user": "ARTICLE"}, "text": "Dynamically altering RACF attributes  (was member BAC678B5 in File 830)\n\nIn our shop we have the policy that, even though the systems\nprogrammers install and maintain RACF, they do not have\neither the 'operations' or 'special' RACF attributes. These\nattributes are reserved for storage managers and RACF\nadministrators. We, the systems programmers, are considered\nto be ordinary users, with access to all relevant data through\nstandard RACF PERMITs and CONNECTs.\n\nIn reality however, every once in a while, systems\nprogrammers need the 'operations' or 'special' attributes. This\nusually occurs on a dark night when a RACF administrator is\nneeded to solve a problem and you can't find him or her\nanywhere. What did you do the night you discovered that JES2\nVersion 4 needed a RACF user to access its own spool and\ncheckpoint datasets? Or what if you are the only one available\nwho can circumvent a DFP problem with a production\ndatabase, but you do not have access to the dataset. Another\ninteresting situation is if all your 'special' users get revoked.\nThat has happened in a number of installations and causes\nconsiderable trouble.\n\nWe have a program called TEMPAUTH to gain the RACF\nattributes 'special' and 'operations'. It can be supplied with the\nparameters OPERATIONS, NOOPERATIONS, SPECIAL,\nand NOSPECIAL (only one at a time), and imitates the effects\nof the ALTUSER RACF command. But, while the ALTUSER\ncommand alters data in the RACF database, this program does\nit in the in-storage ACEE that you are currently running under.\nSo you don't have to log off/log on, and the attributes are not\nsaved at log-off.\n\nThe RACFAUTH program itself does not log anything, but\nwhatever you do is logged in SMF (if you use the RACF\ngeneral options SAUDIT and OPERAUDIT), and is shown in\nRACF report writer reports. So there is really no reason why\nyou shouldn't have a tool like this.\n\nPlease remember the limitations of the OPERATIONS\nattribute. You can't access a resource that you already have\naccess to through the access list with a higher access level than\nalready PERMITed, and security classification checking or\nsecurity label checking can deny access. In these situations you\ncan always use the SPECIAL function and temporarily change\nthe access list etc.\n\nThe use of RACFAUTH is restricted to the users who have\nread access to a RACF profile in the FACILITY general\nresource class called RACFAUTH.OPERATIONS (with\nparameters OPERATIONS and NOOPERATIONS), and\nRACFAUTH.SPECIAL (with parameters SPECIAL and\nNOSPECIAL). To leave you with an extra way out of trouble\nin case all your special users and the users with access to this\nprogram get revoked, the program can easily be altered to a\nrevolver version that doesn't need parameters supplied the TSO\nway, and doesn't check RACF for access to execute, but just\nreverses the special bit in the ACEE of the user executing it.\nThis program should of course not be generally available, but\ncould be kept in source code only, so a user with access to an\nauthorized library could install it. Or you could prepare some\ndefinitions in PARMLIB to IPL with this program active and\nauthorized.\n\nIf you submit a batch job, the attributes gained by this program\nare not propagated, since the batch job builds its RACF ACEE\nfrom the RACF base. But you can still use this utility in a\nbatch job by including a TSO step that calls this program. The\nattributes will last for the total lifetime of the job. It is done\nlike this:\n\n// jobcard\n//STEP1   EXEC PGM=IKJEFT01,PARM='RACFAUTH OPERATIONS'\n//SYSTSPRT DD  SYSOUT=*\n//SYSTSIN  DD  DUMMY\n//*\n\nThe program needs to be linked with AC=1 into an authorized\nlibrary and to be specified in SYS1.PARMLIB(IKJTSO00) as\nboth AUTHCMD and AUTHTSF. The program has been used\non RACF 1.9 and MVS 4.1, but I can't see why it should not\nwork on previous releases.\n\n\nJCL to assemble and link RACFAUTH\n\n// jobcard\n//ASSEM  EXEC PGM=ASMA90,\n//            PARM=(OBJECT,NODECK)\n//SYSLIB   DD DSN=SYS1.MODGEN,DISP=SHR\n//         DD DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD DSN=&SYSUT1,SPACE=(1024,(120,120),,,ROUND),UNIT=VIO,\n//            DCB=BUFNO=1\n//SYSLIN   DD DSN=&&LOADSET,DISP=(,PASS),SPACE=(CYL,(5,1)),UNIT=SYSDA,\n//            DCB=BLKSIZE=80\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD DSN=source library           <== YOUR SOURCE LIBRARY\n//*\n//LINK   EXEC PGM=IEWL,\n//       PARM='AC=1'\n//SYSLMOD  DD DSN=loadlib library          <== YOUR LOADLIB LIBRARY\n//SYSUT1   DD UNIT=SYSDA,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=&&LOADSET,DISP=(OLD,DELETE)\n//         DD *\n    NAME   RACFAUTH(R)\n/*\n\n\nRACFAUTH program\n\n* DYNAMIC SPECIAL/OPERATIONS PROGRAM\n* INVOCATION :                    NEEDS ACCESS TO FACILITY PROFILE :\n*   TSO RACFAUTH SPECIAL          RACFAUTH.SPECIAL\n*   TSO RACFAUTH NOSPECIAL        RACFAUTH.SPECIAL\n*   TSO RACFAUTH OPERATIONS       RACFAUTH.OPERATIONS\n*   TSO RACFAUTH NOOPERATIONS     RACFAUTH.OPERATIONS\n&ID      SETC  'RACFAUTH'              SET CSECT NAME\n&IDLEN   SETA  K'&ID\n&ID      CSECT\n&ID      AMODE 31\n&ID      RMODE 24\n         SAVE  (14,12),,RACFAUTH-&SYSDATE-&SYSTIME-SMIT\n         BALR  12,0                    STANDARD LINKAGE\n         USING *,12\n         LA    11,SAVE\n         ST    13,4(11)\n         ST    11,8(13)\n         LR    13,11\n         L     R2,0(R1)                GET PARM ADDR\n         LH    R3,0(R2)                GET PARM LENGTH\n         CH    R3,=AL2(5+&IDLEN)       TEST FOR ZERO PARM\n         BNH   WRGPARM                 IF ZERO, IGNORE\n         AH    R2,=AL2(5+&IDLEN)       POINT TO BEGINNING OF SUPP. PARM\n         SH    R3,=AL2(5+&IDLEN)       SUBTRACT HEADER TO GET PARM LEN\n         LA    R8,0                    R8 = INDEX INTO PARAMETER\nPARMLOOP EQU   *                       SCAN FOR FIRST NON-BLANK CHAR.\n         LA    R9,0(R2,R8)             LOAD ADDR. OF CHAR. IN PARM\n         CLI   0(R9),C' '              IS IT BLANK?\n         BNE   FIRSTNB                 IF NOT BRANCH TO FIRSTNB\n         LA    R8,1(R8)                GET NEXT CHARACTER\n         CR    R8,R3                   END OF PARM ?\n         BH    WRGPARM                 YES, WRITE ERROR\n         B     PARMLOOP                NO, GET NEXT CHARACTER\nFIRSTNB  EQU   *                       FIRST NONBLANK CHAR. FOUND\n         SR    R3,R8                   SUBTRACT NO OF BLANKS IN PARM\n         BCTR  R3,0                    SUBTRACT 1 FROM LENGTH\n         EX    R3,MOVECHR              MOVE IN PARAMETER\n         OC    PARM,=CL12' '           TRANSLATE PARM TO UPPERCASE\n         L     R1,PSAAOLD-PSA(0)       R1 POINTS AT ASCB\n         USING ASCB,R1\n         L     R1,ASCBASXB             R1 POINTS AT ASXB\n         USING ASXB,R1\n         L     R2,ASXBSENV             R2 POINTS AT ACEE\n         USING ACEE,R2                 ESTABLISH ADDRESSABILITY TO ACEE\n         LA    R5,PARMTABL             LOAD START OF PARMTABLE\n         LA    R3,PARMEND              LOAD END OF PARMTABLE\nLOOP     EQU   *\n         CLC   0(12,R5),PARM           COMPARE ENTRY IN PARMTABLE WITH\n         BE    PARMOK                  SUPPLIED PARM, BRANCH EQ PARMOK\n         A     R5,=F'56'               SKIP TO NEXT PARMTABLE ENTRY\n         CR    R5,R3                   HAVE WE REACHED THE END\n         BNE   LOOP                    IF NOT LOOP AGAIN\n         B     WRGPARM                 ELSE WRITE ERROR\nPARMOK   EQU   *                       PARAMETER WAS OK\n         L     R4,52(R5)               LOAD ADDRESS OF BRANCH LABEL\n         LA    R5,12(R5)               LOAD ADDRESS OF PROFILE TO CHECK\n         RACROUTE REQUEST=AUTH,WORKA=RACFWORK,LOG=ASIS,                X\n               ENTITY=((R5)),CLASS='FACILITY',ATTR=READ\n         LTR   R11,R15                 CHECK RACF RETURN CODE\n         BNZ   NOTAUTH                 IF NOT AUTH. BRANCH TO ERROR\n         MODESET KEY=ZERO              GET READY TO CHANGE BIT IN ACEE\n         BR    R4                      BRANCH TO LABEL SPEC. IN TABLE\nSPEC     EQU   *\n         OI    ACEEFLG1,ACEESPEC       SET SPECIAL ON\n         B     NZERO\nNOSPEC   EQU   *\n         NI    ACEEFLG1,255-ACEESPEC   SET SPECIAL OFF\n         B     NZERO\nOPER     EQU   *\n         OI    ACEEFLG1,ACEEOPER       SET OPERATIONS  ON\n         B     NZERO\nNOOPER   EQU   *\n         NI    ACEEFLG1,255-ACEEOPER   SET OPERATIONS  OFF\n         B     NZERO\nNZERO    EQU   *\n         MODESET KEY=NZERO             RETURN TO USER KEY\nEXIT     EQU   *\n         L     R13,SAVE+4              RETURN\n         LR    R15,R11                 SET RETURN CODE FROM RACHECK\n         RETURN (14,12),RC=(15)\nNOTAUTH  EQU   *\n         TPUT  =CL39'YOU ARE NOT AUTHORIZED TO THIS FUNCTION',39\n         B     EXIT\nWRGPARM  EQU   *\n         TPUT  =CL68'WRONG PARAMETER, SHOULD BE SPECIAL/NOSPECIAL/OPERAX\n               TIONS/NOOPERATIONS',68\n         LA    R11,16                  SET RETURN CODE\n         B     EXIT\nSAVE     DC    18F'0'                  SAVE AREA\nPARM     DC    CL12' '                 PARAMETER SUPPLIED TO PROGRAM\nPARMTABL DS    0F                      PARAMETER TABLE\n         DC    CL12'SPECIAL'           EACH ENTRY CONSISTS OF 56 BYTES:\n         DC    CL40'RACFAUTH.SPECIAL'  A 12 BYTE FIELD THAT HAS TO\n         DC    A(SPEC)                   MATCH THE PARAMETER SPECIFIED\n         DC    CL12'NOSPECIAL'         A 40 BYTE FIELD CONTAINING THE\n         DC    CL40'RACFAUTH.SPECIAL'    RACF PROFILE TO CHECK\n         DC    A(NOSPEC)               A 4 BYTE ADDRESS OF THE LABEL\n         DC    CL12'OPERATIONS'          TO BRANCH TO IN ORDER TO\n         DC    CL40'RACFAUTH.OPERATIONS' CARRY OUT THE FUNCTION\n         DC    A(OPER)                   REQUESTED\n         DC    CL12'NOOPERATIONS'\n         DC    CL40'RACFAUTH.OPERATIONS'\n         DC    A(NOOPER)\nPARMEND  EQU   *                       END OF PARAMETER TABLE\nMOVECHR  MVC   PARM(0),0(R9)           EX INSTRUCTION TO MOVE PARMS\nRACFWORK DS    128F                    WORKAREA FOR RACROUTE\n         LTORG\n         YREGS\n         IHAASCB\n         IHAASXB\n         IHAPSA\n         IHAACEE\n         END\n\n\nFlemming Smit\nSystems Programmer\nNykredit (Denmark)                                           (July 1992)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RACFAUTH": {"ttr": 3338, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00A\\x01\\x19\\x14o\\x01\\x19\\x14o 1\\x00\\x88\\x00q\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "2019-05-26T00:00:00", "modifydate": "2019-05-26T20:31:41", "lines": 136, "newlines": 113, "modlines": 0, "user": "IBMUSER"}, "text": "* DYNAMIC SPECIAL/OPERATIONS PROGRAM\n* -------------------------------------------------------------------\n* MODIFIED TO OPTIONALLY ELIMINATE RACF CHECKS.\n* IF RACF CHECKS ARE NOT DESIRED, THEN\n*   UN-COMMENT THE *NORACF LABEL STATEMENT.\n* ADDED TESTAUTH CHECK TO MAKE SURE YOU'RE APF-AUTHORIZED.\n* -------------------------------------------------------------------\n* INVOCATION :               NEEDS READ ACCESS TO FACILITY PROFILE :\n*   TSO RACFAUTH SPECIAL          RACFAUTH.SPECIAL\n*   TSO RACFAUTH NOSPECIAL        RACFAUTH.SPECIAL\n*   TSO RACFAUTH OPERATIONS       RACFAUTH.OPERATIONS\n*   TSO RACFAUTH NOOPERATIONS     RACFAUTH.OPERATIONS\n&ID      SETC  'RACFAUTH'              SET CSECT NAME\n&IDLEN   SETA  K'&ID\n&ID      CSECT\n&ID      AMODE 31\n&ID      RMODE 24\n         SAVE  (14,12),,RACFAUTH-&SYSDATE-&SYSTIME-SMIT\n         BALR  R12,0                    STANDARD LINKAGE\n         USING *,R12\n         LA    R11,SAVE\n         ST    R13,4(,R11)\n         ST    R11,8(,R13)\n         LR    R13,R11\n         L     R2,0(,R1)               GET PARM ADDR\n         LH    R3,0(,R2)               GET PARM LENGTH\n         CH    R3,=AL2(5+&IDLEN)       TEST FOR ZERO PARM\n         BNH   WRGPARM                 IF ZERO, IGNORE\n         AH    R2,=AL2(5+&IDLEN)       POINT TO BEGINNING OF SUPP. PARM\n         SH    R3,=AL2(5+&IDLEN)       SUBTRACT HEADER TO GET PARM LEN\n         LA    R8,0                    R8 = INDEX INTO PARAMETER\nPARMLOOP DS    0H                      SCAN FOR FIRST NON-BLANK CHAR.\n         LA    R9,0(R2,R8)             LOAD ADDR. OF CHAR. IN PARM\n         CLI   0(R9),C' '              IS IT BLANK?\n         BNE   FIRSTNB                 IF NOT BRANCH TO FIRSTNB\n         LA    R8,1(,R8)               GET NEXT CHARACTER\n         CR    R8,R3                   END OF PARM ?\n         BH    WRGPARM                 YES, WRITE ERROR\n         B     PARMLOOP                NO, GET NEXT CHARACTER\nFIRSTNB  DS    0H                      FIRST NONBLANK CHAR. FOUND\n         SR    R3,R8                   SUBTRACT NO OF BLANKS IN PARM\n         BCTR  R3,0                    SUBTRACT 1 FROM LENGTH\n         EX    R3,MOVECHR              MOVE IN PARAMETER\n         OC    PARM,=CL12' '           TRANSLATE PARM TO UPPERCASE\n         L     R1,PSAAOLD-PSA(0)       R1 POINTS AT ASCB\n         USING ASCB,R1\n         L     R1,ASCBASXB             R1 POINTS AT ASXB\n         USING ASXB,R1\n         L     R2,ASXBSENV             R2 POINTS AT ACEE\n         USING ACEE,R2                 ESTABLISH ADDRESSABILITY TO ACEE\n         LA    R5,PARMTABL             LOAD START OF PARMTABLE\n         LA    R3,PARMEND              LOAD END OF PARMTABLE\nLOOP     DS    0H\n         CLC   0(12,R5),PARM           COMPARE ENTRY IN PARMTABLE WITH\n         BE    PARMOK                  SUPPLIED PARM, BRANCH EQ PARMOK\n         A     R5,=F'56'               SKIP TO NEXT PARMTABLE ENTRY\n         CR    R5,R3                   HAVE WE REACHED THE END\n         BNE   LOOP                    IF NOT LOOP AGAIN\n         B     WRGPARM                 ELSE WRITE ERROR\nPARMOK   DS    0H                      PARAMETER WAS OK\n         L     R4,52(,R5)              LOAD ADDRESS OF BRANCH LABEL\n* ---- >          COMMENT OUT TO DO RACF CHECKS       < ---- * BELOW\n*NORACF  B     YESAUTH                 BYPASS RACF CHECKS\n* ---- >          COMMENT OUT TO DO RACF CHECKS       < ---- * ABOVE\n         LA    R5,12(,R5)              LOAD ADDRESS OF PROFILE TO CHECK\n         RACROUTE REQUEST=AUTH,WORKA=RACFWORK,LOG=ASIS,                X\n               ENTITY=((R5)),CLASS='FACILITY',ATTR=READ\n         LTR   R11,R15                 CHECK RACF RETURN CODE\n         BNZ   NOTAUTH                 IF NOT AUTH. BRANCH TO ERROR\nYESAUTH  DS    0H                      RACF CHECKS BYPASSED\n         LA    R11,0                   RETURN CODE ZERO\n* -- >  Test if this command is being run APF Authorized - below\n         STM   R15,R1,SAVE14T1     Now save registers and test if APF\n         XR    R15,R15                  authorized.\n         TESTAUTH FCTN=1           Are we authorized?\n         LTR   R15,R15             Test the return code.\n         BNZ   NOTAPF              Not zero, tell not authorized.\n         LM    R15,R1,SAVE14T1     Restore registers used by TESTAUTH.\n* -- >  Test if this command is being run APF Authorized - above\n         MODESET KEY=ZERO              GET READY TO CHANGE BIT IN ACEE\n         BR    R4                      BRANCH TO LABEL SPEC. IN TABLE\nSPEC     DS    0H\n         OI    ACEEFLG1,ACEESPEC       SET SPECIAL ON\n         B     NZERO\nNOSPEC   DS    0H\n         NI    ACEEFLG1,255-ACEESPEC   SET SPECIAL OFF\n         B     NZERO\nOPER     DS    0H\n         OI    ACEEFLG1,ACEEOPER       SET OPERATIONS  ON\n         B     NZERO\nNOOPER   DS    0H\n         NI    ACEEFLG1,255-ACEEOPER   SET OPERATIONS  OFF\n         B     NZERO\nNZERO    DS    0H\n         MODESET KEY=NZERO             RETURN TO USER KEY\nEXIT     DS    0H\n         L     R13,SAVE+4              RETURN\n         LR    R15,R11                 SET RETURN CODE FROM RACHECK\n         RETURN (14,12),RC=(15)\nNOTAUTH  DS    0H\n         TPUT  =CL39'YOU ARE NOT AUTHORIZED TO THIS FUNCTION',39\n         B     EXIT\nNOTAPF   DS    0H\n         TPUT  =CL39'YOU NEED TO RUN THIS PROGRAM AUTHORIZED',39\n         B     EXIT\nWRGPARM  DS    0H\n         TPUT  =CL68'WRONG PARAMETER, SHOULD BE SPECIAL/NOSPECIAL/OPERAX\n               TIONS/NOOPERATIONS',68\n         LA    R11,16                  SET RETURN CODE\n         B     EXIT\nSAVE     DC    18F'0'                  SAVE AREA\nSAVE14T1 DC    4F'0'\nPARM     DC    CL12' '                 PARAMETER SUPPLIED TO PROGRAM\nPARMTABL DS    0F                      PARAMETER TABLE\n         DC    CL12'SPECIAL'           EACH ENTRY CONSISTS OF 56 BYTES:\n         DC    CL40'RACFAUTH.SPECIAL'  A 12 BYTE FIELD THAT HAS TO\n         DC    A(SPEC)                   MATCH THE PARAMETER SPECIFIED\n         DC    CL12'NOSPECIAL'         A 40 BYTE FIELD CONTAINING THE\n         DC    CL40'RACFAUTH.SPECIAL'    RACF PROFILE TO CHECK\n         DC    A(NOSPEC)               A 4 BYTE ADDRESS OF THE LABEL\n         DC    CL12'OPERATIONS'          TO BRANCH TO IN ORDER TO\n         DC    CL40'RACFAUTH.OPERATIONS' CARRY OUT THE FUNCTION\n         DC    A(OPER)                   REQUESTED\n         DC    CL12'NOOPERATIONS'\n         DC    CL40'RACFAUTH.OPERATIONS'\n         DC    A(NOOPER)\nPARMEND  DS    0H                      END OF PARAMETER TABLE\nMOVECHR  MVC   PARM(0),0(R9)           EX INSTRUCTION TO MOVE PARMS\nRACFWORK DS    128F                    WORKAREA FOR RACROUTE\n         LTORG\n         YREGS\n         IHAASCB\n         IHAASXB\n         IHAPSA\n         IHAACEE\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RACRAUTH": {"ttr": 3341, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x19\\x01 \\x16\\x7f\\x01 \\x16\\x7f\\t!\\x00\\x17\\x00\\x0f\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2020-06-15T00:00:00", "modifydate": "2020-06-15T09:21:19", "lines": 23, "newlines": 15, "modlines": 0, "user": "REXX"}, "text": "/* Rexx */\n/* Trace I */\n/*\n    Rename this exec to DSAUTH or something descriptive.\n    Enter the fully qualified dsname with no quotes.\n\n    00  The user has no access.\n    04  The user has READ authority.\n    08  The user has UPDATE authority.\n    0C  The user has CONTROL authority.\n    10  The user has ALTER authority\n\nhttps://www.ibm.com/support/knowledgecenter/SSLTBW_2.1.0/com.ibm.zos.\nv2r1.ichc600/ich2c6_Return_codes_and_reason_codes1.htm\n  */\nArg dsn\nAddress TSO \"Call *(Racrout) '\"dsn\"'\"\nSay Reason Code (in decimal) is rc\nsay  00  The user has no access.\nsay  04  The user has READ authority.\nsay  08  The user has UPDATE authority.\nsay  12  The user has CONTROL authority.\nsay  16  The user has ALTER authority\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RACROUT$": {"ttr": 3343, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00#\\x01 \\x16\\x7f\\x01 \\x16\\x7f\\x01\\x03\\x00\\x1b\\x00\\x1b\\x00\\x00\\xc1\\xe2\\xd4\\xd1\\xc3\\xd3@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2020-06-15T00:00:00", "modifydate": "2020-06-15T01:03:23", "lines": 27, "newlines": 27, "modlines": 0, "user": "ASMJCL"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,RLD)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.CBT500.FILE836(RACROUTE)\n//SYSUT1   DD UNIT=SYSDA,SPACE=(CYL,20)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=SYSDA,SPACE=(TRK,30),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=(OLD,PASS),DSN=&&TEMP\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB\n ORDER   RACROUTE\n SETSSI  CB500836\n ENTRY   RACROUTE\n NAME    RACROUT(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RACROUTE": {"ttr": 3345, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x10\\x00\\x12\\x01 \\x16\\x7f\\x01 \\x16\\x9f\\x12!\\x00\\x92\\x00T\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.16", "flags": 0, "createdate": "2020-06-15T00:00:00", "modifydate": "2020-06-17T12:21:12", "lines": 146, "newlines": 84, "modlines": 0, "user": "SBGOLOB"}, "text": "RACROUTE TITLE 'RACROUTE STATUS=ACCESS'\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*\n*        Author:   David Spiegel\n*\n*        Update:   Sam Golob  - June 17, 2002\n*                  Return words instead of only the reason code.\n*\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*\n*  This program is meant to be used with the following REXX:\n*\n*  /*   rexx   */\n*  Arg dsn\n*  Address TSO \"Call *(Racrout) '\"dsn\"'\"\n*\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nRACROUTE CSECT ,\nRACROUTE AMODE 31\nRACROUTE RMODE ANY\n         SAVE  (14,12),,RACROUTE.&SYSDATE..&SYSTIME Save caller's regs.\n         LR    R12,R15            Load address of entry point\n         USING RACROUTE,R12       Give assembler program's base reg.\n*\n         LR    R11,R1             Save Pointer to Parameter Address Blk\n         USING ARGS,R11\n*\n         GETMAIN R,LV=SAVESIZE,LOC=BELOW\n         XC    0(CLEARSIZ,R1),0(R1)  Clear the save/work area\n         ST    R1,8(,R13)         Save new save area addr.in old area\n         ST    R13,4(,R1)         Save old save area addr.in new area\n         LR    R13,R1             Replace old save area with new one\n         USING SAVEAREA,R13       Tell assembler about save area\n*\n*\n*\n         L     R11,0(,R11)\n         LH    R5,0(,R11)\n         C     R5,=F'0'            PARM?\n         BE    RETURN              No, RETURN\n*\n         BCTR  R5,0\n         EX    R5,MVC\n         B     CONTINUE\n*\nMVC      MVC   THEENT(*-*),2(R11)\n*\n*\n*\nCONTINUE DS    0F\n         RACROUTE REQUEST=AUTH,                                        x\n               RELEASE=1.9,                                            x\n               STATUS=ACCESS,                                          x\n               CLASS='DATASET',                                        x\n               ATTR=UPDATE,                                            x\n               ENTITY=THEENT,VOLSER=THEVOL,                            x\n               WORKA=SAFWORKA\n         LM    R3,R4,CONTINUE+4    Save Return Code, Reason Code\n         ST    R4,SAVER4A\n*\n*\n*\nRETURN   DS    0H\n*        WTO   'RACROUTE About to Exit'\n         L     R4,SAVER4A\n         B     *+4(R4)\n         B     NONE\n         B     READ\n         B     UPDATE\n         B     CONTROL\n         B     ALTER\n         B     OUTFREE\n         B     OUTFREE\nOUTFREE  DS    0H\n         LR    R1,R13             Save old save area addr. for FREEMAIN\n         L     R13,4(,R13)        Restore old save area address\n         FREEMAIN R,LV=SAVESIZE,A=(1)\nEXIT     DS    0H\n*        SLR   R15,R15            Set a return code of zero\n         LR    R15,R4             Return with Reason Code\n         RETURN (14,12),RC=(15)   Return to caller, return code zero\n*\nNONE     DS    0H\n         MVI   OUTLINE-1,X'40'\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE,=CL17'Access is NONE   '\n         TPUT  OUTLINE,17\n         B     OUTFREE\nREAD     DS    0H\n         MVI   OUTLINE-1,X'40'\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE,=CL8'READ'\n         MVC   OUTLINE,=CL17'Access is READ   '\n         TPUT  OUTLINE,17\n         B     OUTFREE\nUPDATE   DS    0H\n         MVI   OUTLINE-1,X'40'\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE,=CL17'Access is UPDATE '\n         TPUT  OUTLINE,17\n         B     OUTFREE\nCONTROL  DS    0H\n         MVI   OUTLINE-1,X'40'\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE,=CL17'Access is CONTROL'\n         TPUT  OUTLINE,17\n         B     OUTFREE\nALTER    DS    0H\n         MVI   OUTLINE-1,X'40'\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE,=CL17'Access is ALTER  '\n         TPUT  OUTLINE,17\n         B     OUTFREE\n*\n*\n*\n         DS    0D\nSAFWORKA DS    CL512\nTHEENT   DC    CL44' '\nTHEVOL   DC    CL6'THEVOL'\n*\n*\n*\nSAVEAREA DSECT ,                  Register save area and work area\n         DS    18F                Register save area\nCLEARSIZ EQU   *-SAVEAREA         Save and work area size\n         DS    X\nOUTLINE  DS    CL19\nSAVER4A  DS    F\nRECORD   DS    0CL16\nUSERID   DS    CL8\nPASSWORD DS    CL8\nRECSIZE  EQU   *-RECORD\nWTO0     WTO   '                                                     ',X\n               MF=L\nWTO0L    EQU   *-WTO0\nSAVESIZE EQU   *-SAVEAREA         Save and work area size\n*\n*\n*\nARGS DSECT\n          DS   0D\nLENGTH    DS   H\nDSNAME    DS   CL44               Dataset Name to Check\n          YREGS\n          END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RACROU00": {"ttr": 3588, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\"\\x01 \\x16\\x7f\\x01 \\x16\\x7f\\x11\\x07\\x00W\\x00T\\x00\\x00\\xc4\\xe2\\xd7\\xc9\\xc5\\xc7\\xd3@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2020-06-15T00:00:00", "modifydate": "2020-06-15T11:07:22", "lines": 87, "newlines": 84, "modlines": 0, "user": "DSPIEGL"}, "text": "RACROUTE TITLE 'RACROUTE STATUS=ACCESS'\n*\n*        Author:   David Spiegel\n*\nRACROUTE CSECT ,\nRACROUTE AMODE 31\nRACROUTE RMODE ANY\n         SAVE  (14,12),,RACROUTE.&SYSDATE..&SYSTIME Save caller's regs.\n         LR    R12,R15            Load address of entry point\n         USING RACROUTE,R12       Give assembler program's base reg.\n*\n         LR    R11,R1             Save Pointer to Parameter Address Blk\n         USING ARGS,R11\n*\n         GETMAIN R,LV=SAVESIZE,LOC=BELOW\n         XC    0(CLEARSIZ,R1),0(R1)  Clear the save/work area\n         ST    R1,8(,R13)         Save new save area addr.in old area\n         ST    R13,4(,R1)         Save old save area addr.in new area\n         LR    R13,R1             Replace old save area with new one\n         USING SAVEAREA,R13       Tell assembler about save area\n*\n*\n*\n         L     R11,0(,R11)\n         LH    R5,0(,R11)\n         C     R5,=F'0'            PARM?\n         BE    RETURN              No, RETURN\n*\n         BCTR  R5,0\n         EX    R5,MVC\n         B     CONTINUE\n*\nMVC      MVC   THEENT(*-*),2(R11)\n*\n*\n*\nCONTINUE DS    0F\n         RACROUTE REQUEST=AUTH,                                        x\n               RELEASE=1.9,                                            x\n               STATUS=ACCESS,                                          x\n               CLASS='DATASET',                                        x\n               ATTR=UPDATE,                                            x\n               ENTITY=THEENT,VOLSER=THEVOL,                            x\n               WORKA=SAFWORKA\n         LM    R3,R4,CONTINUE+4    Save Return Code, Reason Code\n*\n*\n*\nRETURN   DS    0H\n*        WTO   'RACROUTE About to Exit'\n         LR    R1,R13             Save old save area addr. for FREEMAIN\n         L     R13,4(,R13)        Restore old save area address\n         FREEMAIN R,LV=SAVESIZE,A=(1)\nEXIT     DS 0H\n         LR    R15,R4             Return with Reason Code\n*        SLR   R15,R15            Set a return code of zero\n         RETURN (14,12),RC=(15)   Return to caller, return code zero\n*\n*\n*\n         DS    0D\nSAFWORKA DS    CL512\nTHEENT   DC    CL44' '\nTHEVOL   DC    CL6'THEVOL'\n*\n*\n*\nSAVEAREA DSECT ,                  Register save area and work area\n         DS    18F                Register save area\nCLEARSIZ EQU   *-SAVEAREA         Save and work area size\nRECORD   DS    0CL16\nUSERID   DS    CL8\nPASSWORD DS    CL8\nRECSIZE  EQU   *-RECORD\nWTO0     WTO   '                                                     ',X\n               MF=L\nWTO0L    EQU   *-WTO0\nSAVESIZE EQU   *-SAVEAREA         Save and work area size\n*\n*\n*\nARGS DSECT\n          DS   0D\nLENGTH    DS   H\nDSNAME    DS   CL44               Dataset Name to Check\n          YREGS\n          END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RGENR": {"ttr": 3591, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00W\\x01\\x10)O\\x01\\x10)O\\tY\\x00\\x8f\\x00\\xad\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2010-10-21T00:00:00", "modifydate": "2010-10-21T09:59:57", "lines": 143, "newlines": 173, "modlines": 0, "user": "SBGOLOB"}, "text": "/* REXX - RACF RULE SOURCE GENERATOR.           */\n/* WILL RECREATE THE RACF COMMANDS TO BUILD A   */\n/* GIVEN SET OF RACF PROFILES, USEFUL BEFORE    */\n/* RENAMING PROFILES OR MERGING QUALIFIERS ETC. */\n/* PARM 1 - FILTER (EG SYS1.**)                 */\n/* PARM 2 - CLASS  (DEFAULT DATASET)            */\n/* FILE DDOUT WILL BE WRITTEN TO AND CONTAIN    */\n/* THE RACF ADDSD/RDEFINE AND PERMIT COMMANDS   */\n/* NECESSARY TO BUILD THE EXISTING PROFILES.    */\n/* THESE CAN BE EDITED AND RE-EXECUTED LATER.   */\nARG FILTER CLASS\nIF CLASS = ' ' THEN\n   CLASS = 'DATASET'\n/* PRODUCE LIST OF PROFILES FOR FILTER */\nREC.0 = 0\nX = OUTTRAP('SER.')\nADDRESS TSO \"SEARCH FILTER(\"FILTER\") CLASS(\"CLASS\")\"\nX = OUTTRAP('OFF')\nDO I = 1 TO SER.0\n   PROF = STRIP(SER.I)\n   LPROF = LENGTH(PROF)\n   IF LPROF > 3 THEN\n      IF SUBSTR(PROF,LPROF-3,4) = ' (G)' THEN\n         DO\n            PROF = SUBSTR(PROF,1,LPROF-4)\n            GEN = 'GEN'\n         END\n      ELSE\n         GEN = ' '\n   X = OUTTRAP('PRF.')\n   IF CLASS = 'DATASET' THEN\n      ADDRESS TSO \"LISTDSD DA('\"PROF\"') AUTH\"\n   ELSE\n      ADDRESS TSO \"RLIST \"CLASS\" \"PROF\" AUTH\"\n   X = OUTTRAP('OFF')\n   IF CLASS = 'DATASET' THEN\n      SRT = 2\n   ELSE\n      SRT = 1\n   CALL DEFINE\n   CALL INCREM\n   REC.K = ' '\n   CALL ACCESS\n   CALL INCREM\n   REC.K = ' '\nEND\nK = REC.0 + 1\nREC.K = ''\n\"EXECIO * DISKW DDOUT (STEM REC. FINIS\"\nEXIT 0\n/* PRODUCE DEFINITIONS FOR THIS PROFILE */\nDEFINE:\nAUD = ' '; INS = ' '; LEV = ' '; OWN = ' '; UAC = ' '; WAR = ' '\nIF CLASS = 'DATASET' THEN\n   WSB = 4\nELSE\n   WSB = 5\nDO J = 1 TO PRF.0\n   IF SUBSTR(PRF.J,SRT,12) = 'LEVEL  OWNER' THEN\n      DO\n         K = J + 2\n         LEV = SUBWORD(PRF.K,1,1)\n         OWN = SUBWORD(PRF.K,2,1)\n         UAC = SUBWORD(PRF.K,3,1)\n         WAR = SUBWORD(PRF.K,WSB,1)\n      END\n   IF SUBSTR(PRF.J,SRT,8) = 'AUDITING' THEN\n      DO\n         K = J + 2\n         AUD = SUBWORD(PRF.K,1,1)\n      END\n   IF SUBSTR(PRF.J,SRT,6) = 'NOTIFY' THEN\n      DO\n         K = J + 2\n         NOT = SUBWORD(PRF.K,1,1)\n         IF NOT = 'NO' THEN\n            NOT = ''\n         ELSE\n            NOT = \"NOTIFY(\"NOT\")\"\n      END\n   IF SUBSTR(PRF.J,SRT,17) = 'INSTALLATION DATA' THEN\n      DO\n         K = J + 2\n         INS = STRIP(SUBSTR(PRF.K,SRT))\n         K = J + 3\n         INS = INS STRIP(SUBSTR(PRF.K,SRT))\n         INS = STRIP(INS)\n      END\nEND\nCALL INCREM\nIF CLASS = 'DATASET' THEN\n   REC.K = \"ADDSD '\"PROF\"' \"GEN\" -\"\nELSE\n   REC.K = \"RDEFINE \"CLASS\" \"PROF\" -\"\nCALL INCREM\nREC.K = \" LEVEL(\"LEV\") OWNER(\"OWN\") \"NOT\" -\"\nCALL INCREM\nREC.K = \" UACC(\"UAC\") AUDIT(\"AUD\") -\"\nIF WAR = 'YES' THEN\n   DO\n      CALL INCREM\n      REC.K = \" WARNING -\"\n   END\nCALL INCREM\nREC.K = \" DATA('\"INS\"')\"\nRETURN 0\n/* PRODUCE PERMIT LIST FOR THIS PROFILE */\nACCESS:\nSTART = 0\nDO J = 1 TO PRF.0\n   IF START = 1 THEN\n      IF SUBSTR(PRF.J,1,17) = '            ' THEN\n         START = 0\n   IF START = 1 THEN\n      DO\n         RID = SUBWORD(PRF.J,1,1)\n         IF SUBSTR(RID,1,1) \\= '-' & RID \\= 'NO' THEN\n            DO\n               ACC = SUBWORD(PRF.J,2,1)\n               CALL INCREM\n               S = SUBSTR('        ',1,8-LENGTH(RID))\n               IF CLASS = 'DATASET' THEN\n                  REC.K = \"PE '\"PROF\"' ID(\"RID\")\"S\" ACC(\"ACC\")\" GEN\n               ELSE\n                  DO\n                     CLS = 'CL('CLASS')'\n                     REC.K = \"PE \"PROF\" ID(\"RID\")\"S\" ACC(\"ACC\")\" GEN CLS\n                  END\n            END\n      END\n   IF CLASS = 'DATASET' THEN\n      IF SUBSTR(PRF.J,1,17) = '    ID     ACCESS' THEN\n         START = 1\n   IF CLASS \\= 'DATASET' THEN\n      IF SUBSTR(PRF.J,1,16) = 'USER      ACCESS' THEN\n         START = 1\nEND\nRETURN 0\n/* INCREMENT COUNTER IN OUTPUT ARRAY */\nINCREM:\nREC.0 = REC.0 + 1\nK = REC.0\nRETURN 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RGENR#": {"ttr": 3595, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x001\\x01\\x10)O\\x01\\x10)O\\tY\\x00\\xad\\x00\\xad\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2010-10-21T00:00:00", "modifydate": "2010-10-21T09:59:31", "lines": 173, "newlines": 173, "modlines": 0, "user": "SBGOLOB"}, "text": "De-compilation of RACF profiles\n\nRACF profiles tend to be built up over time as a result of the\nTSO commands issued by RACF administrators and others.\nHowever, if you want to rename your high-level qualifiers or\nmove profiles to a different RACF database, there is no IBM\ntool to reconstruct the original commands.\n\nThe REXX shown below provides this facility.  It accepts two\nparameters: the first is the search filter and the second the class\nname.  The search filter works in the same way as the RACF\nsearch command.  The class defaults to DATASET but can\nalso be a general resource class name.\n\nThe result is a file written to the DDNAME DDOUT consisting\nof the ADDSD/RDEFINE and PERMIT commands that, if re-\nexecuted, would create the same profiles that currently exist.\nThis file can then be edited to change the high-level qualifier or\nsent to another system before re-execution.  It can also be used\nfor report generation purposes. Before executing this REXX,\nallocate the DDNAME DDOUT to a sequential file with a\nLRECL of 80.  For large lists of profiles it can be run in batch.\n\n\nRGENR REXX source\n\n/* REXX - RACF RULE SOURCE GENERATOR.           */\n/* WILL RECREATE THE RACF COMMANDS TO BUILD A   */\n/* GIVEN SET OF RACF PROFILES, USEFUL BEFORE    */\n/* RENAMING PROFILES OR MERGING QUALIFIERS ETC. */\n/* PARM 1 - FILTER (EG SYS1.**)                 */\n/* PARM 2 - CLASS  (DEFAULT DATASET)            */\n/* FILE DDOUT WILL BE WRITTEN TO AND CONTAIN    */\n/* THE RACF ADDSD/RDEFINE AND PERMIT COMMANDS   */\n/* NECESSARY TO BUILD THE EXISTING PROFILES.    */\n/* THESE CAN BE EDITED AND RE-EXECUTED LATER.   */\nARG FILTER CLASS\nIF CLASS = ' ' THEN\n   CLASS = 'DATASET'\n/* PRODUCE LIST OF PROFILES FOR FILTER */\nREC.0 = 0\nX = OUTTRAP('SER.')\nADDRESS TSO \"SEARCH FILTER(\"FILTER\") CLASS(\"CLASS\")\"\nX = OUTTRAP('OFF')\nDO I = 1 TO SER.0\n   PROF = STRIP(SER.I)\n   LPROF = LENGTH(PROF)\n   IF LPROF > 3 THEN\n      IF SUBSTR(PROF,LPROF-3,4) = ' (G)' THEN\n         DO\n            PROF = SUBSTR(PROF,1,LPROF-4)\n            GEN = 'GEN'\n         END\n      ELSE\n         GEN = ' '\n   X = OUTTRAP('PRF.')\n   IF CLASS = 'DATASET' THEN\n      ADDRESS TSO \"LISTDSD DA('\"PROF\"') AUTH\"\n   ELSE\n      ADDRESS TSO \"RLIST \"CLASS\" \"PROF\" AUTH\"\n   X = OUTTRAP('OFF')\n   IF CLASS = 'DATASET' THEN\n      SRT = 2\n   ELSE\n      SRT = 1\n   CALL DEFINE\n   CALL INCREM\n   REC.K = ' '\n   CALL ACCESS\n   CALL INCREM\n   REC.K = ' '\nEND\nK = REC.0 + 1\nREC.K = ''\n\"EXECIO * DISKW DDOUT (STEM REC. FINIS\"\nEXIT 0\n/* PRODUCE DEFINITIONS FOR THIS PROFILE */\nDEFINE:\nAUD = ' '; INS = ' '; LEV = ' '; OWN = ' '; UAC = ' '; WAR = ' '\nIF CLASS = 'DATASET' THEN\n   WSB = 4\nELSE\n   WSB = 5\nDO J = 1 TO PRF.0\n   IF SUBSTR(PRF.J,SRT,12) = 'LEVEL  OWNER' THEN\n      DO\n         K = J + 2\n         LEV = SUBWORD(PRF.K,1,1)\n         OWN = SUBWORD(PRF.K,2,1)\n         UAC = SUBWORD(PRF.K,3,1)\n         WAR = SUBWORD(PRF.K,WSB,1)\n      END\n   IF SUBSTR(PRF.J,SRT,8) = 'AUDITING' THEN\n      DO\n         K = J + 2\n         AUD = SUBWORD(PRF.K,1,1)\n      END\n   IF SUBSTR(PRF.J,SRT,6) = 'NOTIFY' THEN\n      DO\n         K = J + 2\n         NOT = SUBWORD(PRF.K,1,1)\n         IF NOT = 'NO' THEN\n            NOT = ''\n         ELSE\n            NOT = \"NOTIFY(\"NOT\")\"\n      END\n   IF SUBSTR(PRF.J,SRT,17) = 'INSTALLATION DATA' THEN\n      DO\n         K = J + 2\n         INS = STRIP(SUBSTR(PRF.K,SRT))\n         K = J + 3\n         INS = INS STRIP(SUBSTR(PRF.K,SRT))\n         INS = STRIP(INS)\n      END\nEND\nCALL INCREM\nIF CLASS = 'DATASET' THEN\n   REC.K = \"ADDSD '\"PROF\"' \"GEN\" -\"\nELSE\n   REC.K = \"RDEFINE \"CLASS\" \"PROF\" -\"\nCALL INCREM\nREC.K = \" LEVEL(\"LEV\") OWNER(\"OWN\") \"NOT\" -\"\nCALL INCREM\nREC.K = \" UACC(\"UAC\") AUDIT(\"AUD\") -\"\nIF WAR = 'YES' THEN\n   DO\n      CALL INCREM\n      REC.K = \" WARNING -\"\n   END\nCALL INCREM\nREC.K = \" DATA('\"INS\"')\"\nRETURN 0\n/* PRODUCE PERMIT LIST FOR THIS PROFILE */\nACCESS:\nSTART = 0\nDO J = 1 TO PRF.0\n   IF START = 1 THEN\n      IF SUBSTR(PRF.J,1,17) = '            ' THEN\n         START = 0\n   IF START = 1 THEN\n      DO\n         RID = SUBWORD(PRF.J,1,1)\n         IF SUBSTR(RID,1,1) \\= '-' & RID \\= 'NO' THEN\n            DO\n               ACC = SUBWORD(PRF.J,2,1)\n               CALL INCREM\n               S = SUBSTR('        ',1,8-LENGTH(RID))\n               IF CLASS = 'DATASET' THEN\n                  REC.K = \"PE '\"PROF\"' ID(\"RID\")\"S\" ACC(\"ACC\")\" GEN\n               ELSE\n                  DO\n                     CLS = 'CL('CLASS')'\n                     REC.K = \"PE \"PROF\" ID(\"RID\")\"S\" ACC(\"ACC\")\" GEN CLS\n                  END\n            END\n      END\n   IF CLASS = 'DATASET' THEN\n      IF SUBSTR(PRF.J,1,17) = '    ID     ACCESS' THEN\n         START = 1\n   IF CLASS \\= 'DATASET' THEN\n      IF SUBSTR(PRF.J,1,16) = 'USER      ACCESS' THEN\n         START = 1\nEND\nRETURN 0\n/* INCREMENT COUNTER IN OUTPUT ARRAY */\nINCREM:\nREC.0 = REC.0 + 1\nK = REC.0\nRETURN 0\n\n\n                                                                        c Xephon\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXINSTRM": {"ttr": 3599, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x000\\x01\\x16$\\x7f\\x01\\x16$\\x7f\\x10\\x08\\x00\\x15\\x00\\x15\\x00\\x00\\xe6\\xd1\\xc5\\xd5\\xe2\\xc5\\xd5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-03T00:00:00", "modifydate": "2016-09-03T10:08:30", "lines": 21, "newlines": 21, "modlines": 0, "user": "WJENSEN"}, "text": "/* Instream REXX                                              */\n cc=bpxwdyn('alloc new delete rtddn($libdd) rtdsn($libds)',\n            'lrecl(255) recfm(v,b) blksize(0)',\n            'tracks space(1,1) dir(1) unit(vio)')\n if cc<>0 then call close 40 'Alloc lib rc' cc\n cc=bpxwdyn('alloc shr rtddn($mbrdd) da('$libds'($@$@$@$@)')\n if cc<>0 then call close 40 'Alloc mbr rc' cc\n address tso\n queue '/* rexx */' /* just in case */\n \"execio  *         diskr REXX     (finis)\"\n queue 'Exit 0'     /* just in case */\n \"execio\" queued() \"diskw\" $mbrdd \"(finis)\"\n \"altlib act appl(exec) dd(\"$libdd\")\"\n Call $@$@$@$@ arg(1)\n if datatype(rc)='NUM' then call close rc\n Call Close 0\n\nClose:\n parse arg _rc _msg\n if _msg<>'' then say _msg\n Exit word(_rc 0,1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SCANSUB$": {"ttr": 3601, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00V\\x01\\x10)\\x9f\\x01\\x10)\\x9f!\\t\\x00\\x1c\\x00\\x1c\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2010-10-26T00:00:00", "modifydate": "2010-10-26T21:09:56", "lines": 28, "newlines": 28, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,FLAG(5))\n//SYSLIB   DD DISP=SHR,DSN=SBGOLOB.T21.MACLIB\n//         DD DISP=SHR,DSN=SBGOLOB.T21.MODGEN\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(SCANSUBS)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,4),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n SETCODE AC(0)\n SETSSI  CB480830\n NAME    SCANSUBS(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SCANSUB@": {"ttr": 3603, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x19\\x01\\x10)\\x9f\\x01\\x10)\\x9f!\\x13\\x00\\t\\x00\\t\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2010-10-26T00:00:00", "modifydate": "2010-10-26T21:13:19", "lines": 9, "newlines": 9, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBS JOB (ACCT#),'SCANSUBS UTILITY',\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X\n//*\n//*       SCANSUBS UTILITY PROGRAM\n//*\n//SCANSUBS EXEC PGM=SCANSUBS\n//STEPLIB  DD DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSPRINT DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SCANSUBS": {"ttr": 3841, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x10\\x01\\x10)\\x9f\\x01\\x10)\\x9f!\\x12\\x00C\\x00C\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2010-10-26T00:00:00", "modifydate": "2010-10-26T21:12:10", "lines": 67, "newlines": 67, "modlines": 0, "user": "SBGOLOB"}, "text": "SCANSUBS CSECT\n         USING *,R15\n         B     START\n         DC    CL8'SCANSUBS'\n         DC    CL8'&SYSDATE'\n         DROP  R15\n         DC    C'F1SA'\nSTART    BAKR  R14,0\n         LR    R12,R15\n         USING SCANSUBS,R12                   base register\n         LA    R13,SAVE_AREA\n         L     R2,CVTPTR                      r2 --> cvt\n         ICM   R1,15,CVTSMCA-CVT(R2)          r1 --> smca\n         MVC   L0A+14(4),SMCASID-SMCABASE(R1) smfid\n         L     R2,CVTJESCT-CVT(,R2)           r2 --> jesct\n         L     R10,JESSSCT-JESCT(,R2)         r10 --> ssct\n         OPEN  (SYSPRINT,(OUTPUT))\n         LTR   R15,R15\n         BNZ   EXIT\n         BAL   R2,PUT_LINE\n         MVC   0(L'L0A,R3),L0A                heading\n         BAL   R2,PUT_LINE\n         MVC   0(L'L1A,R3),L1A                heading\nSSCT_LOOP EQU *\n         BAL   R2,PUT_LINE\n         MVC   2(4,R3),SSCTSNAM-SSCT(R10)     subsystem name\n         MVC   BINARY(4),SSCTSNAM-SSCT(R10)\n         BAL   R2,CONVERT_TO_HEXADECIMAL\n         MVI   8(R3),C'('\n         MVC   9(8,R3),ZONED\n         MVI   17(R3),C')'\n         MVC   BINARY(4),SSCTSSVT-SSCT(R10)\n         BAL   R2,CONVERT_TO_HEXADECIMAL\n         MVC   24(8,R3),ZONED\n         ICM   R4,15,SSCTSSVT-SSCT(R10)       ssvt assigned ?\n         BNZ   SSCT_NEXT\n         MVC   34(25,R1),=C'<--- subsystem not active'\nSSCT_NEXT EQU *\n         ICM   R10,15,SSCTSCTA-SSCT(R10)      r10 --> next ssct\n         BNZ   SSCT_LOOP\n         CLOSE (SYSPRINT)\n         XR    R15,R15\nEXIT     PR\nPUT_LINE EQU *                                subroutine\n         PUT   SYSPRINT\n         MVI   0(R1),C' '\n         MVC   1(120,R1),0(R1)\n         LR    R3,R1\n         BR    R2                             return to caller\nCONVERT_TO_HEXADECIMAL EQU *                  subroutine\n         UNPK  ZONED(9),BINARY(5)\n         NC    ZONED(8),=X'0F0F0F0F0F0F0F0F'\n         TR    ZONED(8),=C'0123456789ABCDEF'\n         BR    R2                             return to caller\nSAVE_AREA DC   18F'0'\nL0A       DC    C'  System id - xxxx'\nL1A       DC    C'  Subsystem             SSVT Addr'\nBINARY    DC    F'0'\n          DC    X'00'\nZONED     DC    CL9' '\nSYSPRINT  DCB DDNAME=SYSPRINT,MACRF=PL,DSORG=PS,LRECL=121\n         CVT DSECT=YES\n         IEFJSCVT\n         IEFJESCT\n         IEESMCA\n         YREGS\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SEND@": {"ttr": 3843, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x02\\x01\\x10#o\\x01\\x10#o\\x11X\\x008\\x001\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2010-08-24T00:00:00", "modifydate": "2010-08-24T11:58:02", "lines": 56, "newlines": 49, "modlines": 0, "user": "SBGOLOB"}, "text": "***********************************************************************\n* SEND MESSAGES OF HIGH IMPORTANCE FROM TSO SCREEN TO OPERATOR CONSOLE.\n* MESSAGES REMAIN ON CONSOLE AND MUST BE DELETED BY OPERATOR.\n***********************************************************************\n         YREGS\nSEND@    CSECT\n         SAVE  (14,6),,SEND@_&SYSDATE  SAVE REGISTERS, IDENTIFY MODULE\n         LR    R2,R15                  LOAD BASE REGISTER\n         USING SEND@,R2                TELL IT ASSEMBLER\n         ST    R13,SAVEAREA+4          CHAIN\n         LR    R3,R13                     SAVEAREAS\n         LA    R13,SAVEAREA\n         ST    R13,8(R3)\n         SLR   R6,R6                    INDICATE: USERID NOT EXTRACTED\n         TPUT  PROMPT,L'PROMPT          PROMPT USER FOR MESSAGE\nTGET     TGET  MSG,L'MSG                GET MESSAGE FROM USER\n         LTR   R4,R1                    LENGTH OF MESSAGE\n         BZ    PROGEND                  0 = BLANK INPUT = FINISH\n         MVC   MSGCOPY,MSG\n         OC    MSGCOPY(4),MSGCOPYB\n         CLC   MSGCOPY(3),=C'BYE'\n         BE    PROGEND\n         LTR   R6,R6                    USERID ALREADY EXTRACTED ?\n         BNZ   MOVE                      YES\n         EXTRACT TIOTADR,'S',FIELDS=(TIOT) GET ADDRESS OF TIOT\n         L     R6,TIOTADR              USERID AT OFFSET ZERO IN TIOT\n         MVC   MCS,WMCS                MOVE 1ST PART OF WTO LIST\nMOVE     LA    R5,MSG(R4)              ADDR. OF CHAR BEHIND MSG TEXT\n         MVC   0(5,R5),=C' --- '       MOVE BEHIND MESSAGE TEXT\n         MVC   5(7,R5),0(R6)           MOVE USERID BEHIND OF IT\n         MVC   5+7(4,R5),WCODE         MOVE LAST PART OF WTO LIST\n         LA    R4,4+1+5+7(R4)          COMPUTE LENGTH OF WTO LIST\n         STH   R4,LEN                  LENGTH INTO WTO LIST\n         LA    R1,LIST                 ADDR. OF WTO LIST\n         WTO   MF=(E,(R1))             ISSUE WTO\n         B     TGET                    NEXT INPUT LINE\nPROGEND  L     R13,4(R13)\n         RETURN (14,6),RC=0            LOAD REGISTERS AND RETURN\nSAVEAREA DS    18F\nTIOTADR  DS    A\nLIST     DS    0F                      WTO LIST\nLEN      DS    AL2                     LENGTH\nMCS      DS    BL2                     WMCS\n         DC    C' '                    BLANK IN FRONT OF MESSAGE\nMSG      DS    CL111                   MESSAGE TEXT (MAX. LENGTH)\n         DS    CL5                     ' --- '\n         DS    CL7                     USERID BEHIND MESSAGE TEXT\n         DS    CL4                     WCODE\nPROMPT   DC    C'ENTER MESSAGE FOR OPERATOR -'\nWTO      WTO   ' ',ROUTCDE=(2),DESC=(2),MF=L\nWMCS     EQU   WTO+2\nWCODE    EQU   WTO+5\n         LTORG\nMSGCOPY  DS    CL111                   MESSAGE TEXT (MAX. LENGTH)\nMSGCOPYB DC    CL4' '                  BLANKS\n         END   SEND@\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SEND@$": {"ttr": 3845, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x10\\x01\\x10#o\\x01\\x10#o\\x11H\\x00\\x1d\\x00\\x1d\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2010-08-24T00:00:00", "modifydate": "2010-08-24T11:48:10", "lines": 29, "newlines": 29, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,FLAG(5))\n//SYSLIB   DD DISP=SHR,DSN=SBGOLOB.T21.MACLIB\n//         DD DISP=SHR,DSN=SBGOLOB.T21.MODGEN\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(SEND@)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,4),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n ENTRY   SEND@\n SETCODE AC(1)\n SETSSI  CB480000\n NAME    SEND@(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SEND@#": {"ttr": 3847, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x04\\x01\\x10#o\\x01\\x10#o\\x12\\x12\\x00 \\x00\\x1b\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2010-08-24T00:00:00", "modifydate": "2010-08-24T12:12:04", "lines": 32, "newlines": 27, "modlines": 0, "user": "SBGOLOB"}, "text": "Sending high priority messages under TSO\n\nTSO users are able to send messages to the operator console via the TSO\nSEND command.  The message appears at the console as a low priority\nmessage.  It is not highlighted and is removed when space is required\nfor other messages.\n\nThe program SEND@ provides the ability, particularly for system\nprogrammers, to send high priority messages to the console. They are\nhighlighted and do not disappear until deleted by the operator.\n\nTo run the SEND@ program:\n\n     TSO SEND@\n     ENTER MESSAGE FOR OPERATOR -\n\n       then enter as many highlighted messages as you want.....\n\n     BYE     (in column 1 - will exit the program)   or if not\n                                                     in Session Manager\n                                                     mode....\n             then a null line will exit the program.\n\n             Session Manager mode does not allow you to enter a\n             completely null line.\n\nCredit to the original author:  Walter Wiedemann   1987\n                                Consultant (West Germany)\n\nProgram fixed to run on z/OS :  Sam Golob  2010-08-24\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SHOWALOC": {"ttr": 3849, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00U\\x01\\x10 o\\x01\\x10#\\x8f#U\\x00j\\x00\\x84\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2010-07-25T00:00:00", "modifydate": "2010-08-26T23:55:55", "lines": 106, "newlines": 132, "modlines": 0, "user": "SBGOLOB"}, "text": "Searching TSO library allocations\n\nIn a large TSO site, possibly with many different TSO log-on procedures,\nit is often very difficult to search through all the various datasets\n(panels, CLISTs, command libraries etc) allocated to particular TSO\nsessions.  TSO users can of course complicate the problem by performing\ntheir own library allocations.  One common problem when attempting to\nresolve problems with 'non-working' TSO functions, panels, or CLISTs, is\nactually finding out where the function being executed resides.  Is the\npanel or CLIST a user has accessed his own version or a system version?\n\nThe following CLIST scans the datasets concatenated to a given DDNAME\nsearching for a given member name.  All datasets that the member name\nresides in will be identified (the output being written to the\nterminal).  For example, when I run this CLIST by entering\n\n'TSO %WFROM WFROM SYSPROC' I get:\n\nSYSPROC  userid.CLIST              <<<  HERE\n         Project.PRIV.CLIST\n         Project.PROD.CLIST        <<<  HERE\n         SYS1.CLIST\n         TSO.CLIST\n         etc..\n         etc..\n\ndisplayed on my screen, because the CLIST WFROM exists in both my\nuser-id CLIST library and the Project Production CLIST library.\n\nThe two parameters to this CLIST are member, which is the member name to\nbe searched for (in the above example it was WFROM);  and ddname, which\nis the DDNAME to be used for the scan of the above member (in the above\nexample it was SYSPROC).  The DDNAME needs to be the name of a DDNAME\nallocated in the current TSO session.\n\n/* TSO CLIST \"WFROM\"\nPROC 2 MEMBER DDNAME Q(&)\nSET SYSOUTTRAP = 1000\nLISTALC STATUS\nSET SYSLINES   = &SYSOUTLINE\nSET SYSOUTTRAP = 0\nSET I = 2\nSET J = 0\nSET NEED = Y\nDO WHILE &I <= &SYSLINES\n   SET DATA = &STR(&Q.SYSOUTLINE&I)\n   IF &SUBSTR(1:3,&STR(&DATA   )) \u00ac= &STR() && +\n      &SUBSTR(1:8,&STR(&DATA        )) \u00ac= NULLFILE && +\n      &SUBSTR(1:8,&STR(&DATA        )) \u00ac= TERMFILE +\n      THEN DO\n           IF &SUBSTR(1:1,&STR(&DATA )) \u00ac= &STR() +\n              THEN DO\n                   SET DSN = &STR(&DATA)\n                   IF &NEED = Y +\n                      THEN DO\n                           SET J = &J + 1\n                           SET LIB&J = &STR(         &DSN)\n                           SET DSN&J = &DSN\n                           END\n                   END\n              ELSE DO\n                   SET DD = &SUBSTR(3:10,&DATA)\n                   SET DD = &DD\n                   IF &DD = &DDNAME +\n                      THEN DO\n                           SET NEED = Y\n                           SET LIB&J = +\n                               &STR(&SUBSTR(1:9,&DD           )&DSN)\n                           SET DSN&J = &DSN\n                           END\n                      ELSE SET NEED = N\n                   END\n           END\n   SET I = &I + 1\nEND /* do while */\nIF &NEED = N +\n   THEN DO\n        SET LIB&J = &STR()\n        SET J = &J - 1\n        END\nSET I = 1\n/*\n/* You should really clear the screen somehow here !\n/*\nDO WHILE &I <= &J\n   SET LIB = &STR(&Q.LIB&I)\n   SET LIB = &SUBSTR(10:&LENGTH(&STR(&LIB)),&STR(&LIB))\n   ISPEXEC LMINIT DATAID(DID) DATASET('&LIB') ENQ(SHR)\n   ISPEXEC LMOPEN DATAID(&DID) OPTION(INPUT)\n   ISPEXEC LMMFIND DATAID(&DID) MEMBER(&MEMBER)\n   IF &LASTCC = 0 +\n      THEN SET HERE = &STR((((  HERE)\n      ELSE SET HERE = &STR()\n   ISPEXEC LMCLOSE DATAID(&DID)\n   ISPEXEC LMFREE DATAID(&DID)\n   WRITE &SUBSTR(1:35,&STR(&Q.LIB&I                                 ))-\n&STR(&HERE)\n   SET I = &I + 1\nEND /* do while */\n\n\nAndrew Cahillane\nSoftware Programming Consultant\nDelphic Computing Ltd (UK)    \u20ac        1988\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SMPEMOVE": {"ttr": 3852, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00 \\x01\\x10 o\\x01\\x10)\\x8f\\x10!\\x00\\xe8\\x00\\xe8\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2010-07-25T00:00:00", "modifydate": "2010-10-25T10:21:20", "lines": 232, "newlines": 232, "modlines": 0, "user": "SBGOLOB"}, "text": "Moving SMP/E entries        (In File 830, member A162FCC4)\n\nAfter installing a new CBIPO at our installation, several of the\nproducts contained in the previous system's CSIs were not re-\ninstalled.  Rather than maintaining two sets of CSIs, we\ndecided to include the entries from the old CSIs in the new\nCSIs.  This article presents the JCL and associated SMP/E\ncontrol statements that we used to achieve this operation.\n\nThe SMP/E command to use is the UNLOAD command.  This\ncommand unloads entries from the SMP/E target and\ndistribution zones to the SMPPUNCH dataset.  The output is in\nUCL format and can be used as input to an SMP/E procedure.\nThis means that the FMIDs selected, or all FMIDs, can be\ntransferred from one zone to another.\n\nPrior to beginning the operation, I would suggest that you take\nback-up copies of the CSI datasets that you will be\nmanipulating.\n\nThe following job stream will unload all entries from our MVS\ntarget and distribution zones that relate to FMID HNV1303.\nNote that the SET BOUNDARY control statement points to the\nzone that is being unloaded.  Also note that I have specified\nseparate SMPPUNCH datasets for each step.\n\n//SYSPJXBA    JOB   (SDTS),'JOHN BRADLEY',CLASS=A,MSGCLASS=Q,\n//            MSGLEVEL=(1,1),NOTIFY=SYSPJXB\n//*      **************************************************************\n//*      * THIS JOB IS USED TO UNLOAD ALL ELEMENTS FOR A PARTICULAR   *\n//*      * FMID TO SMPPUNCH DATASET. THIS CAN THEN BE USED AS INPUT   *\n//*      * TO ADD THE FMID TO ANOTHER SET OF CSIS.                    *\n//*      **************************************************************\n//INSTALL     EXEC  PGM=GIMSMP,PARM='DATE=U',REGION=4096K,\n//            TIME=1440\n//SMPOUT      DD    SYSOUT=Q\n//SMPPUNCH    DD    DSN=SYSPJXB.WORK.UNL,DISP=(,CATLG,DELETE),\n//            UNIT=WORK,SPACE=(CYL,100,RLSE),\n//            DCB=(RECFM=FB,DSORG=PS,LRECL=80,BLKSIZE=8000)\n//SYSPRINT    DD    SYSOUT=Q\n//SMPLOG      DD    DUMMY\n//SYSUT1      DD    DISP=(,DELETE),UNIT=WORK,SPACE=(CYL,(15,5))\n//SYSUT2      DD    DISP=(,DELETE),UNIT=WORK,SPACE=(CYL,(15,5))\n//SYSUT3      DD    DISP=(,DELETE),UNIT=WORK,SPACE=(CYL,(15,5))\n//SYSUT4      DD    DISP=(,DELETE),UNIT=WORK,SPACE=(CYL,(15,5))\n//SMPWRK1     DD    DISP=(,DELETE),UNIT=WORK,SPACE=(CYL,(2,1,5)),\n//            DCB=BLKSIZE=3120\n//SMPWRK2     DD    DISP=(,DELETE),UNIT=WORK,SPACE=(CYL,(2,1,5)),\n//            DCB=BLKSIZE=3120\n//SMPWRK3     DD    DISP=(,DELETE),UNIT=WORK,SPACE=(CYL,(2,1,20)),\n//            DCB=BLKSIZE=3120\n//SMPWRK4     DD    DISP=(,DELETE),UNIT=WORK,SPACE=(CYL,(2,1,5)),\n//            DCB=BLKSIZE=3120\n//SMPWRK5     DD    DISP=(,DELETE),UNIT=WORK,SPACE=(CYL,(9,1,500)),\n//            DCB=BLKSIZE=13030\n//SMPCSI      DD    DSN=MVS.GLOBAL.CSI,DISP=SHR\n//SMPHOLD     DD    DUMMY\n//SMPCNTL     DD  *\n SET BDY(MVSDLBD).\n UNLOAD FORFMID(HNV1303).\n/*\n//INSTALL     EXEC  PGM=GIMSMP,PARM='DATE=U',REGION=4096K,\n//            TIME=1440\n//SMPOUT      DD    SYSOUT=Q\n//SMPPUNCH    DD    DSN=SYSPJXB.WORK.UNLT,DISP=(,CATLG,DELETE),\n//            UNIT=WORK,SPACE=(CYL,100,RLSE),\n//            DCB=(RECFM=FB,DSORG=PS,LRECL=80,BLKSIZE=8000)\n//SYSPRINT    DD    SYSOUT=Q\n//SMPLOG      DD    DUMMY\n//SYSUT1      DD    DISP=(,DELETE),UNIT=WORK,SPACE=(CYL,(15,5))\n//SYSUT2      DD    DISP=(,DELETE),UNIT=WORK,SPACE=(CYL,(15,5))\n//SYSUT3      DD    DISP=(,DELETE),UNIT=WORK,SPACE=(CYL,(15,5))\n//SYSUT4      DD    DISP=(,DELETE),UNIT=WORK,SPACE=(CYL,(15,5))\n//SMPWRK1     DD    DISP=(,DELETE),UNIT=WORK,SPACE=(CYL,(2,1,5)),\n//            DCB=BLKSIZE=3120\n//SMPWRK2     DD    DISP=(,DELETE),UNIT=WORK,SPACE=(CYL,(2,1,5)),\n//            DCB=BLKSIZE=3120\n//SMPWRK3     DD    DISP=(,DELETE),UNIT=WORK,SPACE=(CYL,(2,1,20)),\n//            DCB=BLKSIZE=3120\n//SMPWRK4     DD    DISP=(,DELETE),UNIT=WORK,SPACE=(CYL,(2,1,5)),\n//            DCB=BLKSIZE=3120\n//SMPWRK5     DD    DISP=(,DELETE),UNIT=WORK,SPACE=(CYL,(9,1,500)),\n//            DCB=BLKSIZE=13030\n//SMPCSI      DD    DSN=MVS.GLOBAL.CSI,DISP=SHR\n//SMPHOLD     DD    DUMMY\n//SMPCNTL     DD  *\n SET BDY(TSTTRGT).\n UNLOAD FORFMID(HNV1303).\n/*\n\nOn completion you should receive messages similar to these:\n\nGIM42401I THE FOLLOWING PARAMETERS WERE SPECIFIED ON THE EXEC\n          STATEMENT FOR GIMSMP: 'DATE=U'\nSET BDY(MVSDLBD).\nGIM20501I SET PROCESSING IS COMPLETE. THE HIGHEST RETURN CODE WAS 00.\nUNLOAD FORFMID(HNV1303).\n------------------------------------------------------------------------\nUNLOAD    SUMMARY REPORT FOR MVSDLBD\nENTRY-TYPE    ENTRY-NAME    STATUS\nMACRO                       FOUND\nMODULE                      FOUND\nSYSMOD                      FOUND\n------------------------------------------------------------------------\nGIM20501I UNLOAD PROCESSING IS COMPLETE. THE HIGHEST RETURN CODE WAS 00.\nGIM20502I GIMSMP PROCESSING IS COMPLETE. THE HIGHEST RETURN CODE WAS 00.\n------------------------------------------------------------------------\n------------------------------------------------------------------------\n------------------------------------------------------------------------\nGIM42401I THE FOLLOWING PARAMETERS WERE SPECIFIED ON THE EXEC\n          STATEMENT FOR GIMSMP: 'DATE=U'\nSET BDY(TSTTRGT).\nGIM20501I SET PROCESSING IS COMPLETE. THE HIGHEST RETURN CODE WAS 00.\nUNLOAD FORFMID(HNV1303).\n------------------------------------------------------------------------\nUNLOAD    SUMMARY REPORT FOR TSTTRGT\nENTRY-TYPE    ENTRY-NAME    STATUS\nMACRO                       FOUND\nMODULE                      FOUND\nSYSMOD                      FOUND\n------------------------------------------------------------------------\nGIM20501I UNLOAD PROCESSING IS COMPLETE. THE HIGHEST RETURN CODE WAS 00.\nGIM20502I GIMSMP PROCESSING IS COMPLETE. THE HIGHEST RETURN CODE WAS 00.\n------------------------------------------------------------------------\n\nBecause we did not intend to use the old CSIs once the\noperation was complete I have not performed any clean-up\noperations on these zones.  If you wish to remove the FMID\nentries from the GLOBAL zone, and DDDEF entries, then you\nwould have to use separate SMP/E job streams that are not\npresented here.\n\nReview the SMPPUNCH datasets.  The UCLIN will contain\nREP statements for the FMID that has been unloaded.  These\nstatements will completely rebuild the FMID in the new zones.\nHowever any DDDEFs relating to libraries required by this\nFMID must be amended manually.  A sample job that will\nachieve this process would look like this.\n\n//SYSPJXBA    JOB   (SDTS),'JOHN BRADLEY',CLASS=A,MSGCLASS=Q,\n//            MSGLEVEL=(1,1),NOTIFY=SYSPJXB\n//*      *************************************************************\n//*      * THIS JOB IS USED TO ADD DDDEF ENTRIES TO SMPE CSIS.       *\n//*      *************************************************************\n//STEP1       EXEC  MVSSMPE\n//SMPCNTL     DD    *\n SET BDY(MVSDLBD).\n UCLIN.\n ADD     DDDEF(NCCFLIB)\n         SHR DA(MVS.NCCF.LIB1).\n ADD     DDDEF(NCCFMAC)\n         SHR DA(MVS.NCCF.MAC1).\n ADD     DDDEF(NCCFLIB2)\n         SHR DA(MVS.NCCF.LIB2).\n ADD     DDDEF(NCCFMAC2)\n         SHR DA(MVS.NCCF.MAC2).\n ENDUCL.\n SET BDY(TSTTRGT).\n UCLIN.\n ADD     DDDEF(NCCFLIB)\n         SHR DA(MVS.NCCF.LIB1).\n ADD     DDDEF(NCCFMAC)\n         SHR DA(MVS.NCCF.MAC1).\n ADD     DDDEF(NCCFLIB2)\n         SHR DA(MVS.NCCF.LIB2).\n ADD     DDDEF(NCCFMAC2)\n         SHR DA(MVS.NCCF.MAC2).\n ENDUCL.\n\nPrior to reloading the FMID into the new CSIs you should add\nan entry to the GLOBAL zone for the FMID.  The job stream\nshown below can be used to achieve this operation.\n\n//SYSPJXBA    JOB   (SDTS),'JOHN BRADLEY',CLASS=A,MSGCLASS=Q,\n//            MSGLEVEL=(1,1),NOTIFY=SYSPJXB\n//*      **************************************************************\n//*      * THIS JOB IS USED TO ADD AN ENTRY TO THE GLOBALZONE FOR     *\n//*      * AN FMID THAT IS TO BE DEFINED SEPARATELY.                  *\n//*      **************************************************************\n//SMPE        EXEC  PGM=GIMSMP,REGION=4096K\n//SMPCSI      DD    DSN=MVS.GLOBAL.CSI,DISP=OLD\n//SMPLIST     DD    SYSOUT=Q\n//SMPOUT      DD    SYSOUT=Q\n//SMPRPT      DD    SYSOUT=Q\n//SYSPRINT    DD    SYSOUT=Q\n//SMPWRK1     DD    UNIT=DISK,SPACE=(CYL,(5,1,15)),DCB=BLKSIZE=3360\n//SMPWRK2     DD    UNIT=DISK,SPACE=(CYL,(5,1,15)),DCB=BLKSIZE=3360\n//SMPWRK3     DD    UNIT=DISK,SPACE=(CYL,(3,1,15)),DCB=BLKSIZE=3200\n//SMPWRK4     DD    UNIT=DISK,SPACE=(CYL,(4,1,15)),DCB=BLKSIZE=3200\n//SMPWRK6     DD    UNIT=DISK,SPACE=(CYL,(3,1,15)),DCB=BLKSIZE=7294\n//SYSUT1      DD    UNIT=DISK,SPACE=(CYL,(2,2))\n//SYSUT2      DD    UNIT=DISK,SPACE=(CYL,(2,2))\n//SYSUT3      DD    UNIT=DISK,SPACE=(CYL,(2,2))\n//SYSUT4      DD    UNIT=DISK,SPACE=(TRK,(1))\n//SMPCNTL     DD    *\n SET BDY(GLOBAL).\n UCLIN.\n ADD GLOBALZONE FMID(HNV1303).\n ENDUCL.\n/*\n\nUpon successful completion of this operation you can run this\nfinal job stream.  This job will use the output from the job that\nwas run at the start of the operation.\n\n//SYSPJXBA    JOB   (SDTS),'JOHN BRADLEY',CLASS=A,MSGCLASS=Q,\n//            MSGLEVEL=(1,1),NOTIFY=SYSPJXB\n//SMPE        EXEC  PGM=GIMSMP,REGION=4096K\n//SMPCSI      DD    DSN=MVS.GLOBAL.CSI,DISP=OLD\n//SMPLIST     DD    SYSOUT=Q\n//SMPOUT      DD    SYSOUT=Q\n//SMPRPT      DD    SYSOUT=Q\n//SYSPRINT    DD    SYSOUT=Q\n//SMPWRK1     DD    UNIT=DISK,SPACE=(CYL,(5,1,15)),DCB=BLKSIZE=3360\n//SMPWRK2     DD    UNIT=DISK,SPACE=(CYL,(5,1,15)),DCB=BLKSIZE=3360\n//SMPWRK3     DD    UNIT=DISK,SPACE=(CYL,(3,1,15)),DCB=BLKSIZE=3200\n//SMPWRK4     DD    UNIT=DISK,SPACE=(CYL,(4,1,15)),DCB=BLKSIZE=3200\n//SMPWRK6     DD    UNIT=DISK,SPACE=(CYL,(3,1,15)),DCB=BLKSIZE=7294\n//SYSUT1      DD    UNIT=DISK,SPACE=(CYL,(2,2))\n//SYSUT2      DD    UNIT=DISK,SPACE=(CYL,(2,2))\n//SYSUT3      DD    UNIT=DISK,SPACE=(CYL,(2,2))\n//SYSUT4      DD    UNIT=DISK,SPACE=(TRK,(1))\n//SMPCNTL     DD    DSN=SYSPJXB.WORK.UNL,DISP=SHR\n//            DD    DSN=SYSPJXB.WORK.UNLT,DISP=SHR\n\nThe SMP/E UNLOAD command enables FMIDs to be ported\nacross to new zones as required in a quick and easy manner.\n\n\nJohn Bradley\nTechnical Support Engineer (UK)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "STRPATRN": {"ttr": 4097, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x016\\x00I\\x01\\x193o\\x01\\x193o\\x11\\x16\\x01\\xac\\x01\\xac\\x00\\x00\\xe6\\xd1\\xc5\\xd5\\xe2\\xc5\\xd5@@@'", "ispf": {"version": "01.54", "flags": 0, "createdate": "2019-12-02T00:00:00", "modifydate": "2019-12-02T11:16:49", "lines": 428, "newlines": 428, "modlines": 0, "user": "WJENSEN"}, "text": "         Macro\n.*-\n.* Test string against a pattern/mask.\n.*\n.* Syntax\n.*  STRPATRN DATA=data-addr,MASK=mask-addr,WC=ao|*%\n.*\n.*   'addr' is either a label, or (label,len) or 'literal'. 'label'\n.*   and 'len' may be a register like (rn) or f/h/b/c.label to load\n.*   from a fullword, halfword, byte or char field. See .XLA below.\n.*   The mask may contain wildcards % for a single char and * for\n.*   multiple or no chars.\n.*   'ao' mask chars for all or none, or any one char. default is *%.\n.*   STR= can be used instead of DATA=. This will probably be removed\n.*   in a later version, so please use DATA=.\n.*\n.* Returns result in r15:\n.*   0  Data matches mask\n.*  >1  Data does not match mask, code indicates where in STRPATRN\n.*      the check failed. Additional info is returned as follows:\n.*        r0 -> data addr when check failed\n.*        r1 -> mask addr when check failed\n.*\n.* Operation\n.*   First time the macro is invoked an internal CSECT is generated,\n.*   further macro invocations call the same CSECT.\n.*   The save area pointed to by r13 is used as work area both for\n.*   the call parameters and for saving registers. Registers 4-12 are\n.*   restore when the program returns, registers 2 and 3 are not used\n.*   so need not be preserved. Registers 0, 1, 14 and 15 are changed\n.*   by the macro.\n.*\n.* Samples\n.*    STRPATRN data=text1,mask=mask1\n.*    STRPATRN data='ABCDE',mask='A%C*'\n.*    STRPATRN data=((r2),(r3)),mask=(f.maskaddr,b.masklen)\n.*    STRPATRN data=text1,mask='Doc*Brit*'\n.*    . .\n.*  text1    dc    c'Doctor Who is a British sci-fi TV series'\n.*  mask1    dc    c'*Who*Brit*'\n.*  maskaddr ds    a       contains address of mask\n.*  masklen  ds    al1     max len 128 as field is signed\n.*\n.* Note that IBM supplies a similar function in macro ASAXWC in\n.* SYS1.MODGEN. STRPATRN, however, is simpler to use and test has\n.* shown it to be up to 4 times as fast as ASAXWC.\n.*\n.* History\n.*  2019-12-01  Total rewrite, so is now new base\n.*\n.* Author\n.*     Willy Jensen\n.*     mail: willy@harders-jensen.com\n.*     web : http://harders-jensen.com/wjtech\n.*-\n&ml      STRPATRN &str=,&data=,&mask=,&wc='*%'\n         lclc  &l,&s,&c\n         lcla  &qn\n&l       setc  'sp&sysndx'\n         gblb  &$STRPATRN\n.* xla sub\n         gblc  &xlalen\n&s       setc  Upper('&syslist(1)')\n         aif   ('&s' eq 'XLA').xla\n.* call\n&ml      la    r1,8(,r13)\n         STRPATRN XLA,r14,&data(1),&str(1)\n         STRPATRN XLA,r15,&data(2),&str(2),&xlalen,1\n         stm   r14,r15,0(r1)\n         STRPATRN XLA,r14,&mask(1)\n         STRPATRN XLA,r15,&mask(2),&xlalen,1\n         stm   r14,r15,8(r1)\n         STRPATRN XLA,r14,&wc\n         mvc   16(2,r1),0(r14)\n         mvc   18(2,r1),=x'0000'\n         l     r15,=v(ZTRPATRN)\n         basr  r14,r15\n         aif   (&$STRPATRN).x\n&$STRPATRN setb 1\n         j     &l.ltn\n         ltorg\n&l.ltn   ds    0a\n* STRPATRN module\n* r14  return address\n* r12  basereg\n* r11  -> string\n* r10  -> mask\n* r9   -> string end\n* r8   -> mask end\n* r7   wildcards : byte0 is 'all', byte1 = one\n* r6   -> save mask ptr\n* r5   -> last '*'\n* r2-r4 are not used, they are not saved and restored as that space in\n* the save area is used for the parm block.\n&s       setc  '&sysect'\nZTRPATRN Amode 31\nZTRPATRN Rmode any\nZTRPATRN Csect\n         save  (4,12)\n         push  using\n         lr    r12,r15\n         using ZTRPATRN,r12\n* set up registers\n         using zptrnblk,r1\n         l     r11,zptrnsa            -> string\n         l     r9,zptrnsl             string length\n         ar    r9,r11                 -> past string\n         ahi   r9,-1                  -> end of string\n         l     r10,zptrnma            -> mask\n         l     r8,zptrnml             mask length\n         ar    r8,r10                 -> past mask\n         ahi   r8,-1                  -> end of mask\n         l     r7,zptrnwc             wild cards and opts\n         drop  r1\n*-\n* Frontend - till '*' or end of mask or end of string\n*-\n&l.fep   equ   *\n&l.f100  equ   *\n         clm   r7,8,0(r10)            '*' ?\n         je    &l.f400                then go handle block\n\n* test char\n&l.f200  equ   *\n         clm   r7,4,0(r10)            '%' ?\n         je    &l.f300                yes\n         clc   0(1,r10),0(r11)        same char in string and mask?\n         jne   &l.fe01                no, abort\n\n* char ok, check/bump pointers\n&l.f300  equ   *\n         sr    r1,r1                  mask must also not be at end\n         cr    r10,r8                 end of mask?\n         jnh   *+8                    nope\n         ahi   r1,1                   mask\n         cr    r11,r9                 end of data?\n         jnh   *+8                    nope\n         ahi   r1,1                   mark\n         ltr   r1,r1                  both before end?\n         jz    &l.f310                good\n         clfi  r1,2                   both are at the end\n         je    &l.q0                  good\n         cr    r10,r8                 end of mask?\n         je    &l.fe03                mask end before string end\n\n* string end before mask end, check if mask+1='*' and end of mask\n         ahi   r10,1                  -> past '*'\n         cr    r10,r8                 now end of mask?\n         jne   &l.fe04                sadly not\n         clm   r7,8,0(r10)            '*' ?\n         je    &l.q0                  ok\n         j     &l.fe05                bad\n\n* both mask and string within bounds, bump and try next\n&l.f310  equ   *\n         ahi   r10,1                  bump mask ptr\n         ahi   r11,1                  bump string ptr\n         j     &l.f100                continue frontend processing\n\n* mask (r10->) chr is '*'\n&l.f400  equ   *\n         cr    r10,r8                 end of mask?\n         je    &l.q0                  yup, all is well\n\n* handle multiple consequitive '*'\n&l.f410  equ   *\n         ahi   r10,1                  -> past '*'\n         cr    r10,r8                 end of mask?\n         je    &l.f430\n         clm   r7,8,0(r10)            mask is * ?\n         je    &l.f410                yes\n\n* not end of mask, not '*'\n&l.f420  equ   *\n         ahi   r10,-1                 -> * ?\n         j     &l.f500                go prep for mid- and backend\n\n* end of mask\n&l.f430  equ   *\n         clm   r7,8,0(r10)            mask is * ?\n         je    &l.q0                  yes\n* small backend of one char\n         clm   r7,4,0(r10)            mask is % ?\n         je    &l.q0                  yes\n         clc   0(1,r10),0(r11)        char match ?\n         je    &l.q0                  yes\n         j     &l.fe06\n\n* mask chr (r10->) is '*', locate last '*' in mask\n* if this '*' is also last '*' in mask then just do backend\n&l.f500  equ   *\n         lr    r5,r8                  -> mask end\n&l.f510  equ   *\n         cr    r5,r10                 test against located '*'\n         je    &l.f520                reached that\n         clm   r7,8,0(r5)             is mask '*' ?\n         je    &l.f530                yes\n         bct   r5,&l.f510             else go test next\n\n* last '*' = first '*' then no mid section, go do backend\n&l.f520  equ   *\n         j     &l.bep\n\n* last '*' <> first '*' then there is a mid section\n&l.f530  equ   *\n         j     &l.msp\n\n* Set return codes\n&l.fe01  la    r15,101\n         j     &l.qx\n&l.fe02  la    r15,102\n         j     &l.qx\n&l.fe03  la    r15,103\n         j     &l.qx\n&l.fe04  la    r15,104\n         j     &l.qx\n&l.fe05  la    r15,105\n         j     &l.qx\n&l.fe06  la    r15,106\n         j     &l.qx\n\n*-\n* mid section processing, find matching block in string.\n* at entry: r10 -> position in mask, r11 -> position in text\n* r6  -> save mask ptr\n* r5  -> last '*'\n*-\n&l.msp   equ   *\n\n* handle multiple '*'\n&l.m010  equ   *\n         ahi   r10,1                  -> past '*'\n         clm   r7,8,0(r10)            mask is * ?\n         jne   &l.m100                init properly\n         cr    r10,r5                 = last '*' ?\n         je    &l.m020                yes\n         cr    r10,r8                 end of mask?\n         je    &l.q0\n         j     &l.bep                 else go do backend\n\n* r10 -> last '*', also mask end?\n&l.m020  equ   *\n         cr    r10,r8                 mask end too?\n         je    &l.q0                  then all is good\n         j     &l.bep                 else do backend\n\n* (re)start at submask\n&l.m100  equ   *\n         lr    r6,r10                 work mask ptr -> past '*'\n\n&l.m200  equ   *\n         cr    r6,r5                  mask work ptr gt subend?\n         jh    &l.m100                then iterate\n&l.m210  equ   *\n         cr    r11,r9                 string gt end?\n         jh    &l.me01                then error\n\n* test match\n&l.m300  equ   *\n         clm   r7,4,0(r6)             mask is % ?\n         je    &l.m310\n         clc   0(1,r6),0(r11)         mask matches string?\n         jne   &l.m400                nope, try next\n* char match\n&l.m310  equ   *\n         ahi   r6,1                   bump maskworkptr\n         cr    r6,r5                  last submsk done?\n         je    &l.m600                yes, do backend\n         clm   r7,8,0(r6)             mask is * ?  (submask end)\n         je    &l.m500                nope\n         ahi   r11,1                  bump strptr\n         j     &l.m210                cont with test\n\n* char don't match\n&l.m400  equ   *\n         cr    r6,r10                 past 1st char?\n         jh    &l.m410                yes\n         ahi   r11,1                  bump strptr\n         j     &l.m100                restart submask\n&l.m410  equ   *\n         j     &l.m100                restart submask\n\n* submask end\n&l.m500  equ   *\n         la    r10,1(,r6)             -> past '*'\n         ahi   r11,1                  bump strptr\n         j     &l.m100                restart submask\n\n* work ptr -> last '*'\n&l.m600  equ   *\n         cr    r6,r8                  also end of mask?\n         je    &l.q0\n         lr    r10,r6\n         j     &l.bep\n\n* Set return code\n&l.me01  la    r15,201\n         j     &l.qx\n&l.me02  la    r15,202\n         j     &l.qx\n&l.me03  la    r15,203\n         j     &l.qx\n&l.me04  la    r15,204\n         j     &l.qx\n&l.me05  la    r15,205\n         j     &l.qx\n&l.me06  la    r15,206\n         j     &l.qx\n\n*-\n* backend procesing, scan backwards till '*'\n* r11 -> string pos\n* r10 -> last '*'\n* r9  -> last byte of pos\n* r8  -> last byte of mask\n*-\n&l.bep   equ   *\n         ahi   r10,1\n         lr    r4,r8\n         sr    r4,r10                 length of backend\n         lr    r5,r9\n         sr    r5,r11                 length of str remainder\n         cr    r5,r4\n         jl    &l.be01\n\n&l.b100  equ   *\n         clm   r7,4,0(r8)             mask is % ?\n         je    &l.b200                bad if not\n         clc   0(1,r8),0(r9)          mask = text?\n         jne   &l.be03                bad if not\n&l.b200  equ   *\n         cr    r8,r10                 locate last mask?\n         jle   &l.q0                  then all ok\n\n&l.b300  equ   *\n         ahi   r9,-1                  decr string ptr\n         bct   r8,&l.b100             decr mask ptr\n\n&l.be01  equ   *\n         la    r15,301\n         j     &l.be99\n&l.be02  equ   *\n         la    r15,302\n         j     &l.be99\n&l.be03  equ   *\n         la    r15,303\n         j     &l.be99\n&l.be99  equ   *\n         lr    r0,r9                  copy string addr for reporting\n         lr    r1,r8                  copy mask addr for reporting\n         j     &l.qx\n\n*-\n* return\n*-\n&l.q0    equ   *                      set good rc\n         sr    r15,r15                set good rc\n&l.qx    lr    r0,r11                 updated str addr for reporting\n         lr    r1,r10                 updated mask addr for reporting\n         return (4,12)\n         ltorg\n         pop   using\n\nzptrnblk dsect\nzptrnsa  ds    a                      string address\nzptrnsl  ds    a                      string length\nzptrnma  ds    a                      mask address\nzptrnml  ds    a                      mask length\nzptrnwc  ds    a                      wild cards etc\nzptrnblkl equ  *-zptrnblk\n.* resume main\n&s       Csect                        resume main\n         Mexit\n.*-\n.* $$LA - subroutine, generate Lx instruction (shortened $LA)\n.* Syntax: $$LA  reg,what1,what2,,whatn\n.*         what: label or (reg) or 'literal' or f/h/b/c.label\n.*               c.label -> reg is cleared and the entire byte loaded\n.*               1st non-null what is used\n.*-\n.xla     anop\n         lclc  &xlar,&xlap,&xla\n         lcla  &xlapn,&xlan\n&xlalen  setc   ''\n&xlar    setc  '&syslist(2)'\n&xlapn   seta  2\n.xlanext anop\n&xlapn   seta  &xlapn+1\n         aif   (&xlapn gt n'&syslist).xlax\n&xlap    setc  '&syslist(&xlapn)'\n         aif   (k'&xlap eq 0).xlanext\n         aif   ('&xlap '(1,1) eq '(').xlareg\n         aif   ('&xlap '(1,1) eq '''').xlalit\n         aif   ('&xlap '(2,1) eq '.').xlafld\n&xla     setc  t'&xlap\n         aif   ('&xla' eq 'N').xlanum\n&ml      la    &xlar,&xlap\n         aif   ('&xlap  '(1,2) eq 'l''').xlax\n&xlalen  setc   'l''&xlap'\n         mexit\n.xlanum  anop\n&ml      lgfi  &xlar,&xlap\n         mexit\n.xlafld  anop\n&xlan    seta  k'&xlap-2\n&xla     setc  '&xlap'(1,1)\n&xlap    setc  '&xlap'(3,&xlan)\n&xla     setc  lower('&xla')\n         aif   ('&xla' ne 'c').xlafld1\n&ml      sr    &xlar,&xlar\n         ic    &xlar,&xlap\n         mexit\n.xlafld1 aif   ('&xla' ne 'f').xlafld2\n&xla     setc  ''\n.xlafld2 anop\n&ml      l&xla &xlar,&xlap\n         mexit\n.xlareg  anop\n&xlan    seta  k'&xlap-2\n&xlap    setc  '&xlap'(2,&xlan)\n&ml      lr    &xlar,&xlap\n         mexit\n.xlalit  anop\n&ml      la    &xlar,=c&xlap\n&xlan    seta  k'&xlap-2\n&xlalen  setc  '&xlan'\n.xlax    mexit\n.x       Mend\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SUBCOMS": {"ttr": 4105, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x02\\x00'\\x01\\x19\\t\\x8f\\x01\\x19\\x10_\\x00@\\x00\\x8e\\x00\\x90\\x00\\x00\\xe6\\xd1\\xc5\\xd5\\xe2\\xc5\\xd5@@@\"", "ispf": {"version": "01.02", "flags": 0, "createdate": "2019-04-08T00:00:00", "modifydate": "2019-04-15T00:40:27", "lines": 142, "newlines": 144, "modlines": 0, "user": "WJENSEN"}, "text": "*\n* REXX environment inquiry external function\n*\n* REXX provides the capability to write external functions which\n* may supply a REXX EXEC with information not readily\n* available.  These functions may be written in programming\n* languages or REXX itself.  One of the REXX built-in\n* functions, called SUBCOM, returns a value showing if an\n* environment is available given the environment name as an\n* argument.  For example, the expression:\n*\n*       IF SUBCOM(ISPEXEC) = 0\n*\n* would test if the ISPF environment is valid (0) or not (1).\n* However, REXX does not provide a method for easily\n* determining which environments are in existence; rather, one\n* must know the environment names beforehand in order to\n* check for their existence.  I thought it would be a nice idea to\n* find out what environments were in effect rather than guessing\n* what they were, so I wrote SUBCOMS, a small Assembler\n* REXX external function that returns the names of all currently\n* available environments.\n*\n* The program is written for 31-bit mode since the control blocks\n* accessed reside above the 16-megabyte line in MVS/ESA.  The\n* program chains through the REXX subcommand table\n* retrieving the names of all valid environments.\n*\n* As it turns out, any particular environment name may appear\n* more than once in the chain, although I do not know why.  To\n* handle this, the program checks to see if it has already found\n* the environment name previously.  If so, it is skipped;\n* otherwise its name is added to the string returned by the\n* SUBCOMS function.  The names are returned as a single\n* string, with each name delimited by a blank.  Names are not\n* padded with blanks for 8 bytes, as is the typical MVS standard.\n* This way, the string returned can be searched for blank\n* delimiters.  The program could also easily be modified to\n* supply the environment names as 8-byte blank padded values if\n* desired.  To verify the operation of the SUBCOMS external\n* function, a REXX EXEC can be coded as follows:\n*\n* x=SUBCOMS()\n* say \"The valid environments are\" x\n*\n*\n*                                                              1992\n*\n* SUBCOMS SOURCE CODE\n*\nSUBCOMS  CSECT\nSUBCOMS  AMODE 31\nSUBCOMS  RMODE ANY\n         YREGS  , Register equates generation macro\n         SAVE  (14,12),,SUBCOMS-&SYSDATE\n         LR    R12,R15                 LOAD BASE REGISTER\n         USING SUBCOMS,R12             ESTABLISH ADDRESSABILITY\n         LR    R10,R0                  LOAD A(ENVIRONMENT BLOCK)\n         USING ENVBLOCK,R10            ESTABLISH ADDRESSABILITY\n         CLC   ENVBLOCK_ID,ENVBID      IS IT AN ENVIRONMENT BLOCK\n         BNE   RETURN2                 NO, THEN RETURN\n         LR    R11,R1                  LOAD A(EXT. FUNCTION PLIST)\n         USING EFPL,R11                ESTABLISH ADDRESSABILITY\n         GETMAIN RU,LV=WORKLEN         GETMAIN WORKAREA\n         ST    R13,4(,R1)              ST A(CALLERS S/A) IN MY S/A\n         ST    R1,8(,R13)              ST A(MY S/A) IN CALLERS S/A\n         LR    R13,R1                  LOAD A(MY S/A)\n         USING WORKAREA,R13            ESTABLISH ADDRESSABILITY\n         L     R10,ENVBLOCK_PARMBLOCK  LOAD A(PARM BLOCK)\n         DROP  R10                     DROP ADDRESSABILITY\n         USING PARMBLOCK,R10           ESTABLISH ADDRESSABILITY\n         CLC   PARMBLOCK_ID,PARMBID    IS IT A VALID PARMBLOCK\n         BNE   RETURN3                 NO, THEN RETURN\n         L     R10,PARMBLOCK_SUBCOMTB  LOAD A(SUBCOM TABLE)\n         DROP  R10                     DROP ADDRESSABILITY\n         USING SUBCOMTB_HEADER,R10     ESTABLISH ADDRESSABILITY\n         CLC   SUBCOMTB_FFFF,SUBCMTID  IS IT A VALID SUBCOM TABLE\n         BNE   RETURN3                 NO, THEN RETURN\n         L     R9,SUBCOMTB_FIRST       LOAD A(1ST SUBCOMTB ENTRY)\n         USING SUBCOMTB_ENTRY,R9       ESTABLISH ADDRESSABILITY\n         L     R8,SUBCOMTB_USED        LOAD OUTER LOOP COUNTER\n         L     R7,SUBCOMTB_LENGTH      LOAD LENGTH(SUBCOMTB ENTRY)\n         L     R6,EFPLEVAL             LOAD A(A(EVAL BLOCK))\n         L     R6,0(,R6)               LOAD A(EVAL BLOCK)\n         USING EVALBLOCK,R6            ESTABLISH ADDRESSABILITY\n         LA    R5,EVALBLOCK_EVDATA     LOAD A(EVALBLOCK_DATA)\n         LR    R0,R5                   SAVE A(DATA)\n         LTR   R8,R8                   WERE THERE ANY SUBCOM ENTRIES\n         BNP   RETURN                  NO, THEN RETURN\n         L     R3,EVALBLOCK_EVSIZE     ELSE, LOAD SIZE(EVALBLK IN DBLW)\n         S     R3,=A(((EVALBLOCK_EVDATA-EVALBLOCK)+7)/8)\n* SUBTRACT NUMBER OF DOUBLEWORDS OF EVALBLOCK HEADER PORTION\n         SLL   R3,3                    MULTIPLY BY 8 = NUMBER OF BYTES\n         LA    R3,0(R5,R3)             LOAD A(END OF DATA)\nLOOPOUTR L     R1,SUBCOMTB_FIRST       LOAD A(1ST SUBCOMTB ENTRY)\nCHECKPTR CR    R1,R9                   ARE WE POINTING AT SAME PLACE\n         BE    PREPINNR                YES, SKIP COMPARE\n         CLC   SUBCOMTB_NAME,SUBCOMTB_NAME-SUBCOMTB_ENTRY(R1)\n* ARE THE NAMES THE SAME\n         BE    BUMPPTR                 YES, GO BUMP TO NEXT ENTRY\n         ALR   R1,R7                   ELSE, ADD LENGTH TO BASE\n         B     CHECKPTR                GO CHECK THEM AGAIN\nPREPINNR LA    R2,8                    LOAD INNER LOOP COUNTER\n         LA    R4,SUBCOMTB_FIRST-SUBCOMTB_HEADER(,R9) L A(SUBCOM_FIRST)\nLOOPINNR MVC   0(1,R5),0(R4)           MOVE 1 BYTE OF ENTRY\n         LA    R5,1(,R5)               BUMP TO NEXT BYTE\n         CR    R5,R3                   ARE WE PAST END\n         BNL   RETURN                  YES, DONE\n         CLI   0(R4),C' '              ELSE, IS BYTE BLANK\n         BE    BUMPPTR                 YES, DONE WITH THIS ENTRY\n         LA    R4,1(,R4)               BUMP TO NEXT BYTE\n         BCT   R2,LOOPINNR             LOOP ON NUMBER OF BYTES\n         LA    R4,BLANKS               DONE, POINT TO AREA AGAIN\n         B     LOOPINNR                LOOP TO DO NEXT ENTRY\nBUMPPTR  ALR   R9,R7                   ADD LENGTH TO CURRENT ENTRY\n         BCT   R8,LOOPOUTR             LOOP ON # OF SUBCOM ENTRIES\n         BCTR  R5,R0                   DECREMENT LENGTH\nRETURN   SLR   R5,R0                   SUBTRACT ORIGINAL ADDRESS\n         ST    R5,EVALBLOCK_EVLEN      SAVE NEW LENGTH IN EVALBLOCK\nRETURN3  LR    R1,R13                  LOAD R1 W/A(AREA TO FREEMAIN)\n         L     R13,4(,R13)             LOAD A(CALLERS S/A)\n         FREEMAIN RU,LV=WORKLEN,A=(1)  FREEMAIN WORKAREA\nRETURN2  RETURN (14,12),RC=0           RETURN TO CALLER\nENVBID   DC    C'ENVBLOCK'\nPARMBID  DC    C'IRXPARMS'\nSUBCMTID DC    X'FFFFFFFFFFFFFFFF'\nBLANKS   DC    C'        '\n         LTORG\nWORKAREA DSECT\nSAVEAREA DS    18F                     OS SAVE AREA\nWORKLEN  EQU   *-WORKAREA\n         IHAPSA\n         IHAASCB\n         IHAASXB\n         IKJEFLWA\n         IKJECT\n         IRXENVB\n         IRXPARMB\n         IRXSUBCT\n         IRXEFPL\n         IRXEVALB\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SUBCOMS$": {"ttr": 4109, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00W\\x01\\x19\\t\\x8f\\x01\\x19\\x10_\\x01\\x02\\x00\"\\x00\\x18\\x00\\x00\\xc1\\xe2\\xd4\\xd3\\xc9\\xe5\\xd7@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2019-04-08T00:00:00", "modifydate": "2019-04-15T01:02:57", "lines": 34, "newlines": 24, "modlines": 0, "user": "ASMLIVP"}, "text": "//SBGOLOBM JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//* ORG: ABA7F5DD\n//*\n//*   JCLLIB ORDER=WJENSEN.LIB.CNTL\n//    SET    LOADLIB=SYS1.W$$.LINKLIB\n//    SET    LOADLIB=&&LOADLIB\n//*\n//RXINSTRM PROC P=''\n//R        EXEC PGM=IKJEFT1B,PARM='RXINSTRM &P',DYNAMNBR=200\n//STEPLIB  DD DISP=SHR,DSN=SBGOLOB.W$$.LINKLIB\n//SYSEXEC  DD DISP=SHR,DSN=WJENSEN.LIB.EXEC\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD DUMMY\n//REXX     DD DDNAME=SYSIN\n//         PEND\n//*\n//A   EXEC ASMACL,PARM.C='TERM',\n//             PARM.L='LIST,MAP' ,AMODE(31),RMODE(ANY)'\n//C.SYSLIB  DD DISP=SHR,DSN=SYS1.MACLIB\n//          DD DISP=SHR,DSN=SYS1.MODGEN\n//C.SYSTERM DD SYSOUT=*\n//C.SYSIN   DD DISP=SHR,DSN=SBGOLOB.CBT497.FILE836(SUBCOMS)\n//L.SYSLMOD  DD DISP=SHR,DSN=SYS1.W$$.LINKLIB(SUBCOMS)\n//*L.SYSLMOD  DD DISP=(,PASS),DSN=&&LOADLIB(SUBCOMS),\n//*         SPACE=(TRK,(8,8,8)),DCB=(SYS1.LINKLIB)\n//*\n//IVP1     EXEC RXINSTRM\n//STEPLIB  DD DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//REXX     DD *\n SAY 'TEST..'\n P=SUBCOMS()\n SAY 'SUBCOMS:' P\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SUBSYS": {"ttr": 4354, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x02\\x01\\x19\\t\\x0f\\x01\\x19\\t\\x0f \\x03\\x00\\xf0\\x00\\xea\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2019-03-31T00:00:00", "modifydate": "2019-03-31T20:03:02", "lines": 240, "newlines": 234, "modlines": 0, "user": "REXX"}, "text": "/*rexx                                                              */\n/*  Program-id           SUBSYS                                     */\n/*  Remarks              This routine will display the information  */\n/*                       for each defined subsystem.                */\n/*trace i*/                              /*    Turn tracing on      */\n/*                                                                  */\n/* initialize variables                                             */\n/*                                                                  */\nreturn_code= '00000000'x                 /* Init the return code    */\nint_return_code= 0                       /* Init the internal rc    */\ncall house_keeping                       /* let's initialize        */\ndo forever                               /* main loop               */\n   call display_info_panel               /* display the info panel  */\n   call get_the_ssn_info                 /* obtain the subsys info  */\n   call display_the_subsys_table         /* display the ssn table   */\n   exit                                  /* obtain the subsys info  */\nend\nget_the_ssn_info:\ncvt=      c2x(storage(10,4))            /* cvt address             */\ncvtjesct= d2x((x2d(cvt))+296)           /* cvt + x'128' = cvtjesct */\njesct@=   c2x(storage(cvtjesct,4))      /* jesct address           */\njesssct=  d2x((x2d(jesct@))+24)         /* jesct + x'18'x = sscvt  */\nsscvt@=   c2x(storage(jesssct,4))       /* sscvt @                 */\nssct@=    sscvt@                        /* let's switch            */\nno_of_subsystems= 0                     /* no of subsystems        */\nx=        1                             /* stem no                 */\ndo forever\n   if (ssct@ = 00000000) then do        /* end of chain?           */\n       return                           /* yes                     */\n   end                                  /* yes                     */\n   ssctname@=  d2x((x2d(ssct@))+8)      /* sub-system name @       */\n   ssctsnam.x= storage(ssctname@,4)     /* sub-system name         */\n   ssctflg1@=  d2x((x2d(ssct@))+12)     /* ssctflg1  @             */\n   ssctflg1.x= storage(ssctflg1@,1)     /* ssctflg1                */\n   ssctssid@=  d2x((x2d(ssct@))+13)     /* ssctssid @              */\n   ssctssid.x= storage(ssctssid@,1)     /* ssctssid                */\n   ssctssvt@=  d2x((x2d(ssct@))+16)     /* ssctssvt @              */\n   ssctssvt.x= storage(ssctssvt@,4)     /* ssctssvt                */\n   ssctsuse@=  d2x((x2d(ssct@))+20)     /* ssctsuse @              */\n   ssctsuse.x= storage(ssctsuse@,4)     /* ssctsuse                */\n   ssctsus2@=  d2x((x2d(ssct@))+28)     /* ssctsus2 @              */\n   ssctsus2.x= storage(ssctsus2@,4)     /* ssctsus2                */\n   ssctscta@=  d2x((x2d(ssct@))+4)      /* ssctscta @              */\n   ssctscta.x= storage(ssctscta@,4)     /* ssctscta                */\n   ssct@=      c2x(storage(ssctscta@,4)) /* next ssct on the chain */\n   x= (x + 1)                           /* next stem               */\n   no_of_subsystems= (no_of_subsystems + 1)/* no of subsystems     */\nend\nreturn\ndisplay_the_subsys_table:\nADDRESS \"ISPEXEC\" \"TBCREATE SSNTAB NOWRITE REPLACE\"\nif (rc >  4) then do                     /* call okay?             */\n   say 'TBCREATE error    rc = 'rc''     /* no- inform the user    */\n   call dealloc                          /* Dealloc                */\n   exit(0)                               /* let's quit             */\nend\nztdmark='**************************** Bottom of data *************************'\nADDRESS  \"ISPEXEC\" \"VPUT (ZTDMARK) SHARED\"\ntabrows=  200                            /* max table rows         */\nssel= '_'                                /* init the selection ind */\ndo i = 1 to no_of_subsystems             /* create ssn table ents  */\n   sname=  ssctsnam.i                    /* subsystem name         */\n   sflg1=  c2x(ssctflg1.i)               /* ssctflg1               */\n   sssid=  c2x(ssctssid.i)               /* ssctssid               */\n   sssvt=  c2x(ssctssvt.i)               /* ssctssvt               */\n   ssuse=  c2x(ssctsuse.i)               /* ssctsuse               */\n   ssus2=  c2x(ssctsus2.i)               /* ssctsus2               */\n   ssscvt= c2x(ssctscta.i)               /* ssctscta               */\n   ADDRESS \"ISPEXEC\" \"TBADD SSNTAB       /* add the entries        */\n            SAVE(sname,sflg1,sssid,sssvt,ssuse,ssus2,ssscvt)\n            MULT(\"TABROWS\")\"\n   if (rc \u00ac= 0) then do                  /* call okay?             */\n      say 'TBADD error    rc = 'rc''     /* no- inform the user    */\n      call dealloc                       /* Dealloc                */\n      exit(0)                            /* let's quit             */\n   end\nend\nADDRESS \"ISPEXEC\" \"TBTOP SSNTAB\"         /* position to top of tab */\nif (rc \u00ac= 0) then do                     /* call okay?             */\n   say 'TBTOP error    rc = 'rc''        /* no- inform the user    */\n   call dealloc                          /* Dealloc                */\n   exit(0)                               /* let's quit             */\nend\nADDRESS \"ISPEXEC\" \"ADDPOP POPLOC(ZCMD)\"  /* pop up position         */\nADDRESS \"ISPEXEC\" \"TBDISPL SSNTAB PANEL(SUBSYSP1)\"\nif (rc = 8) then do                      /* pf3 or return?          */\n   ADDRESS \"ISPEXEC\" \"REMPOP\"            /* remove pop-up           */\n   return                                /* and quit                */\nend\nif (rc > 8) then do                      /* error?                  */\n   say 'SUBSYSP1 TBDISPL error  rc = 'rc''\n   call dealloc                          /* Dealloc                 */\n   exit(0)                               /* and quit                */\nend\ndo while (ztdsels > 0)                   /* Do while user selection?*/\n   address \"ISPEXEC\" \"CONTROL DISPLAY SAVE\" /* Save The Environment */\n   if (rc \u00ac= 0) then do                  /* save okay?              */\n      say 'CONTROL SAVE error  rc = 'rc''\n      call dealloc                       /* Dealloc                 */\n      exit(0)                            /* and quit                */\n   end\n   if (ssel = '/') then do               /* Display subsystem matrix*/\n      call display_the_subsys_matrix     /* yes-                    */\n   end\n   address \"ISPEXEC\" \"CONTROL DISPLAY RESTORE\" /* Restore the envirn*/\n   if (rc \u00ac= 0) then do                  /* save okay?              */\n      say 'CONTROL RESTORE error  rc = 'rc''\n      call dealloc                       /* Dealloc                 */\n      exit(0)                            /* and quit                */\n   end\n   ssel= '_'                             /* init selection          */\nztdmark='<<-------------------- End Of Subsystem Entries ------------------->>'\n   ADDRESS \"ISPEXEC\" \"TBDISPL SSNTAB\"\n   if (rc = 8) then do                   /* pf3 or return?          */\n      ADDRESS \"ISPEXEC\" \"REMPOP\"         /* remove pop-up           */\n      return                             /* and quit                */\n   end\n   if (rc > 8) then do\n      say 'SUBSYSP1 TBDISPL error  rc = 'rc''\n      call dealloc                       /* Dealloc                 */\n      exit(0)                            /* and quit                */\n   end\nend\nADDRESS \"ISPEXEC\" \"REMPOP\"               /* remove pop-up           */\nreturn\ndisplay_information_panel:\nADDRESS \"ISPEXEC\" \"ADDPOP ROW(1) COLUMN(1)\" /* pop up position      */\nADDRESS \"ISPEXEC\" \"DISPLAY PANEL(SUBSYSP2)\" /* position the cursor  */\nif (rc = 8) then do                      /* error?                  */\n   ADDRESS \"ISPEXEC\" \"REMPOP\"            /* remove pop-up           */\n   return                                /* return to caller        */\nend\nif (rc \u00ac= 0) then do                     /* error?                  */\n   ADDRESS \"ISPEXEC\" \"REMPOP\"            /* remove pop-up           */\n   say 'SUBSYSP2 Display error    rc = 'rc''\n   call dealloc                          /* Dealloc                 */\n   exit(0)                               /* and quit                */\nend\nADDRESS \"ISPEXEC\" \"REMPOP\"               /* remove pop-up           */\nreturn\ndisplay_info_panel:\nADDRESS \"ISPEXEC\" \"CONTROL DISPLAY LOCK\" /* lock the terminal      */\nif (rc \u00ac= 0) then do                     /* error?                 */\n   say 'SUBSYS Lock error    rc = 'rc''  /* yes- output message    */\n   call dealloc                          /* dealloc                */\n   exit(0)                               /* and quit               */\nend\nsubsinfo= 'Your Request Is Being Processed. Please Wait'\nADDRESS \"ISPEXEC\" \"ADDPOP ROW(1) COLUMN(1)\" /* pop-up position      */\nADDRESS \"ISPEXEC\" \"DISPLAY PANEL(SUBSYSP2)\" /* position the cursor  */\nif (rc \u00ac= 0) then do                     /* error?                  */\n   ADDRESS \"ISPEXEC\" \"REMPOP\"            /* remove pop-up           */\n   say 'SUBSYSP2 Display error    rc = 'rc''\n   call dealloc                          /* Dealloc                 */\n   exit(0)                               /* and quit                */\nend\nADDRESS \"ISPEXEC\" \"REMPOP\"               /* remove pop-up           */\nreturn\nhouse_keeping:\n/*                                                                 */\n/* Set the error mode                                              */\n/*                                                                 */\naddress \"ISPEXEC\" \"CONTROL ERRORS CANCEL\"\n/*                                                                 */\n/* dynamically allocate the panel libraries                        */\n/*                                                                 */\n/* --------------------------------------------------------------- */\n/* Change the next line to point to your load library in ISPLLIB.  */\n/* --------------------------------------------------------------- */\naddress \"ISPEXEC\" \"LIBDEF ISPLLIB DATASET ID('SYS1.W$$.LINKLIB')\"\n/* --------------------------------------------------------------- */\n/* Change the next line to point to your panel dataset in ISPPLIB. */\n/* --------------------------------------------------------------- */\naddress \"ISPEXEC\" \"LIBDEF ISPPLIB DATASET ID('SYS1.U.PANELS')\"\nreturn\ndealloc:\naddress \"ISPEXEC\" \"LIBDEF ISPLLIB\"\naddress \"ISPEXEC\" \"LIBDEF ISPPLIB\"\nreturn\ndisplay_the_subsys_matrix:\nADDRESS \"ISPEXEC\" \"TBCREATE SSVTTAB NOWRITE REPLACE\"\nif (rc >  4) then do                     /* call okay?             */\n   say 'TBCREATE error    rc = 'rc''     /* no- inform the user    */\n   call dealloc                          /* Dealloc                */\n   exit(0)                               /* let's quit             */\nend\nztdmark='<<------- End Of Function Table ------>>'\nADDRESS  \"ISPEXEC\" \"VPUT (ZTDMARK) SHARED\"\ntabrows=  256                            /* max table rows         */\nssel= '_'                                /* init the selection ind */\nif (sssvt = 00000000) then do           /* no functions supported? */\n   subsinfo= 'No Functions are Supported by Subsystem 'sname''\n   call display_information_panel       /* inform the user         */\n   return                               /* return to caller        */\nend\nsssvt_addr= d2x(x2d(sssvt)+2)           /* sssvt address           */\nssvtfnum=   c2x(storage(sssvt_addr,2))  /* no of functs supported  */\nsnofunc=    x2d(ssvtfnum)               /* no of functs supported  */\nif (ssvtfnum = 0000) then do            /* no functions supported? */\n   subsinfo= 'No Functions are Supported by Subsystem 'sname''\n   call display_information_panel       /* inform the user         */\n   return                               /* return to caller        */\nend\nssvtfcod_addr= d2x(x2d(sssvt)+4)        /* start of function matrix*/\ndo i= 1 to 256\n   ssvtfcod= c2d(storage(ssvtfcod_addr,1)) /* sscvt @              */\n   ssvtfcod_addr= d2x(x2d(ssvtfcod_addr)+1) /* next function byte  */\n   if (ssvtfcod = 0) then do            /* no function?            */\n      iterate                           /* yes-                    */\n   end\n   smfuncc= i                           /* position in matrix table*/\n   smatrix=  ssvtfcod                   /* function code           */\n   ssvtfcod= ((ssvtfcod - 1) * 4)       /* function subscript      */\n   ssvtfrtn_addr= d2x(x2d(sssvt)+260)   /* function routine pointers*/\n   ssvtfrtn_addr= d2x(x2d(ssvtfrtn_addr) + ssvtfcod) /* function @ */\n   sfaddr= c2x(storage(ssvtfrtn_addr,4)) /* sscvt @                */\n   ADDRESS \"ISPEXEC\" \"TBADD SSVTTAB      /* add the entries        */\n            SAVE(smfuncc,smatrix,sfaddr)\n            MULT(\"TABROWS\")\"\n   if (rc \u00ac= 0) then do                  /* call okay?             */\n      say 'TBADD error    rc = 'rc''     /* no- inform the user    */\n      call dealloc                       /* Dealloc                */\n      exit(0)                            /* let's quit             */\n   end\nend\nADDRESS \"ISPEXEC\" \"TBTOP SSVTTAB\"        /* position to top of tab */\nif (rc \u00ac= 0) then do                     /* call okay?             */\n   say 'TBTOP error    rc = 'rc''        /* no- inform the user    */\n   call dealloc                          /* Dealloc                */\n   exit(0)                               /* let's quit             */\nend\nADDRESS \"ISPEXEC\" \"ADDPOP POPLOC(ZCMD)\"  /* pop up position        */\nADDRESS \"ISPEXEC\" \"TBDISPL SSVTTAB PANEL(SUBSYSP3)\"\nif (rc > 8) then do                      /* error?                 */\n   say 'SUBSYSP3 TBDISPL error  rc = 'rc''\n   call dealloc                          /* Dealloc                */\n   exit(0)                               /* and quit               */\nend\nADDRESS \"ISPEXEC\" \"REMPOP\"               /* remove pop-up          */\nreturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SUBSYSAR": {"ttr": 4359, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x01\\x01\\x10 o\\x01\\x19\\t\\x0f\\x197\\x01c\\x01c\\x00\\x00\\xc1\\xd9\\xe3\\xc9\\xc3\\xd3\\xc5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2010-07-25T00:00:00", "modifydate": "2019-03-31T19:37:01", "lines": 355, "newlines": 355, "modlines": 0, "user": "ARTICLE"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "SUBSYSP1": {"ttr": 4609, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00H\\x01\\x19\\t\\x0f\\x01\\x19\\t\\x0f\\x195\\x00%\\x00%\\x00\\x00\\xd7\\xc1\\xd5\\xc5\\xd3@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-03-31T00:00:00", "modifydate": "2019-03-31T19:35:48", "lines": 37, "newlines": 37, "modlines": 0, "user": "PANEL"}, "text": ")ATTR\n* TYPE(INPUT)   INTENS(HIGH) COLOR(RED)\n_ TYPE(INPUT)   INTENS(HIGH) COLOR(YELLOW)\n% TYPE(TEXT)    COLOR(RED)\n+ TYPE(TEXT)    COLOR(WHITE)\n# TYPE(TEXT)    INTENS(HIGH) COLOR(BLUE)\n? TYPE(OUTPUT)  INTENS(HIGH) COLOR(RED)\n@ TYPE(OUTPUT)  COLOR(RED)\n$ TYPE(OUTPUT)  COLOR(YELLOW)\n)BODY WINDOW(70,19)\n%\n% COMMAND ===>_ZCMD          %    SCROLL ===>_AMT   +\n%\n% SSCTFLG1  x'80' = Serial FIB Operations Required\n%           x'40' = Use Primary Subsystems Service's for this\n%                   Subsystem\n% SSCTSSID  x'00' = Unknown Subsystem id\n%           x'02' = JES2 Subsystem id\n%           x'03' = JES3 Subsystem id\n%\n#Display  Subsystem SSCT  SSCT Vector    SSCT      SSCT      Pointer\n#Vector   Name      Flag1 SSID Table     SUSE      SUS2      to next\n#Table                         Pointer                       SSCVT\n%\n)MODEL\n*z%      $z   %    $z %  $z % $z       %$z       %$z       %$z       %\n)INIT\n.ZVARS= '(ssel,sname,sflg1,sssid,sssvt,ssuse,ssus2,ssscvt)'\n&ZCMD= ' '\n.CURSOR=   ZCMD\n&ZWINTTL= 'MVS Subsystem Table'\n)REINIT\n&ZCMD=    ' '\n.CURSOR=   ZCMD\n&ZWINTTL= 'MVS Subsystem Table'\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SUBSYSP2": {"ttr": 4611, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x19\\x01\\x19\\t\\x0f\\x01\\x19\\t\\x0f\\x196\\x00\\x1d\\x00\\x1d\\x00\\x00\\xd7\\xc1\\xd5\\xc5\\xd3@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-03-31T00:00:00", "modifydate": "2019-03-31T19:36:19", "lines": 29, "newlines": 29, "modlines": 0, "user": "PANEL"}, "text": ")ATTR\n* TYPE(INPUT)   INTENS(HIGH) COLOR(YELLOW)\n_ TYPE(INPUT)   INTENS(HIGH) COLOR(YELLOW)\n% TYPE(TEXT)    COLOR(RED)\n+ TYPE(TEXT)    COLOR(WHITE)\n# TYPE(TEXT)    INTENS(HIGH) COLOR(BLUE)\n$ TYPE(OUTPUT)  INTENS(HIGH) COLOR(YELLOW)\n? TYPE(OUTPUT)  INTENS(HIGH) COLOR(RED)\n@ TYPE(OUTPUT)  COLOR(RED)\n)BODY WINDOW(56,9)\n%\n%COMMAND ===>_ZCMD          %     SCROLL ===>_AMT   +\n%\n%    ------------------------------------------------\n%    \u0093                                              \u0093\n%    \u0093$z                                           %\u0093\n%    \u0093                                              \u0093\n%    ------------------------------------------------\n%\n)INIT\n.ZVARS=  '(subsinfo)'\n&ZCMD=   ' '\n.CURSOR= ZCMD\n&ZWINTTL=  'Subsystem Information Panel'\n)REINIT\n.CURSOR= ZCMD\n&ZWINTTL=  'Subsystem Information Panel'\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SUBSYSP3": {"ttr": 4613, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x008\\x01\\x19\\t\\x0f\\x01\\x19\\t\\x0f\\x196\\x00!\\x00!\\x00\\x00\\xd7\\xc1\\xd5\\xc5\\xd3@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-03-31T00:00:00", "modifydate": "2019-03-31T19:36:38", "lines": 33, "newlines": 33, "modlines": 0, "user": "PANEL"}, "text": ")ATTR\n* TYPE(INPUT)   INTENS(HIGH) COLOR(RED)\n_ TYPE(INPUT)   INTENS(HIGH) COLOR(YELLOW)\n% TYPE(TEXT)    COLOR(RED)\n+ TYPE(TEXT)    COLOR(WHITE)\n# TYPE(TEXT)    INTENS(HIGH) COLOR(BLUE)\n? TYPE(OUTPUT)  INTENS(HIGH) COLOR(RED)\n@ TYPE(OUTPUT)  COLOR(RED)\n$ TYPE(OUTPUT)  COLOR(YELLOW)\n)BODY WINDOW(56,19)\n%\n% COMMAND ===>_ZCMD          %    SCROLL ===>_AMT   +\n%\n% Sub-System Name:                                $z   %\n% No Of Functions Supported By This Sub-System:   $z  %\n%\n# Function  Matrix     Function Routine\n# Code      Function   Address\n#           Byte\n%\n)MODEL\n $z  %     $z  %      $z       %\n)INIT\n.ZVARS= '(sname,snofunc,smfuncc,smatrix,sfaddr)'\n&ZCMD= ' '\n.CURSOR=   ZCMD\n&ZWINTTL= 'Subsystem Vector Table'\n)REINIT\n&ZCMD=    ' '\n.CURSOR=   ZCMD\n&ZWINTTL= 'Subsystem Vector Table'\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SVCR": {"ttr": 4615, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x07\\x01\\x19\\x08?\\x01\\x19\\x08?\\x15V\\x00\\xcb\\x00\\xc8\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2019-03-24T00:00:00", "modifydate": "2019-03-24T15:56:07", "lines": 203, "newlines": 200, "modlines": 0, "user": "REXX"}, "text": "/**rexx**/\n/*  Program-id           SVCR                                      */\n/*  Remarks              This REXX EXEC will display the entries   */\n/*                       in the SVC update recording table.        */\n/*                       The following information is displayed    */\n/*                       for each updated SVC:                     */\n/*                       1. SVC Number.                            */\n/*                       2. The old SVC Table Entry.               */\n/*                       3. The new SVC EP address.                */\n/*                       4. Date the SVC table was updated.        */\n/*                       5. The number of updates for the SVC.     */\n/*                       6. Suffix of the IEASVCxx parmlib member, */\n/*                          if the SVC table entry was replaced    */\n/*                          using this method.                     */\n/*                       When the table is displayed, the entries  */\n/*                       can be selected to display the first 128  */\n/*                       bytes of the SVC module storage.          */\n/*trace i*/                             /* trace option            */\ncall house_keeping                      /* let's initialize        */\ndo forever\n   call get_the_svcr_address            /* svc upd recording table */\n   call display_info_panel              /* display info panel      */\n   call build_the_svcr_entries          /* build the svcr entries  */\n   call display_the_svcr_entries        /* display the svcr entries*/\n   exit(0)                              /* let's get out           */\nend\nget_the_svcr_address:\ncvt=         c2x(storage(10,4))         /* cvt address             */\ncvtabend=    d2x((x2d(cvt))+200)        /* cvt + 200 = cvtabend    */\nscvt=        c2x(storage(cvtabend,4))   /* scvt @                  */\nscvtsvcr=    d2x(x2d(scvt)+136)         /* scvt + 136 = scvtsvcr   */\nsvcrtaddr=   c2x(storage(scvtsvcr,4))   /* svct table @            */\nsvcr@=       svcrtaddr                  /* store for panel output  */\nreturn                                  /* return to the caller    */\nbuild_the_svcr_entries:\ndo i = 0 to 255                         /* process all svcr entries*/\n   svcr.i= storage(svcrtaddr,24)        /* pick up the svcr entry  */\n   svcrtaddr= d2x(x2d(svcrtaddr)+24)    /* next svcr table entry   */\nend\nADDRESS \"ISPEXEC\" \"TBCREATE SVCRTAB NOWRITE REPLACE\"\nif (rc >  4) then do                    /* call okay?              */\n   say 'TBCREATE error    rc = 'rc''    /* no- inform the user     */\n   call dealloc                         /* remove allocation       */\n   exit(0)                              /* let's quit              */\nend\nssel=       '_'                         /* init                    */\nsvcrtadr=  svcr@                        /* svcr table address      */\nztdmark= '**************** End Of SVC Update Recording Table *****************'\nADDRESS \"ISPEXEC\" \"VPUT (ztdmark) SHARED\"\ntabrows=  256                           /* max table rows          */\nsvcnos=   0                             /* count the no of svcs    */\ndo i= 0 to 255                          /* add the esr svcs to an  */\n   if substr(svcr.i,1,16)= '00000000000000000000000000000000'x then\n      iterate\n   svcnos= (svcnos + 1)                 /* no of updated svcs      */\n   svcnum= i                            /* svc number              */\n   svcurold= c2x(substr(svcr.i,1,8))    /* old svc table entry     */\n   svcurret= c2x(substr(svcr.i,9,4))    /* ret @ in caller        */\n   svcurnew= c2x(substr(svcr.i,13,4))   /* new svc ep @           */\n   svcurdat= c2x(substr(svcr.i,17,4))   /* cvtdate for update     */\n   svcurcnt= c2x(substr(svcr.i,21,2))   /* count of updates for svc*/\n   svcursx=  substr(svcr.i,23,2)        /* suffix of ieasvcxx     */\n   ADDRESS \"ISPEXEC\" \"TBADD SVCRTAB     /* add the entries        */\n            SAVE(svcnum,svcurold,svcurret,svcurnew,svcurdat,svcurcnt,\n            svcursx)\n            MULT(\"TABROWS\")\"\n   if (rc \\= 0) then do                 /* call okay?             */\n      say 'TBADD error    rc = 'rc''    /* no- inform the user    */\n      call dealloc                      /* remove allocation      */\n      exit(0)                           /* let's quit             */\n   end\nend\nADDRESS \"ISPEXEC\" \"TBTOP SVCRTAB\"       /* position to top of tab */\nif (rc \\= 0) then do                    /* call okay?             */\n   say 'TBTOP error    rc = 'rc''       /* no- inform the user    */\n   call dealloc                         /* remove allocation      */\n   exit(0)                              /* let's quit             */\nend\nreturn\ndisplay_the_svcr_entries:\nADDRESS \"ISPEXEC\" \"ADDPOP POPLOC(ZCMD)\" /* pop-up position        */\nADDRESS \"ISPEXEC\" \"TBDISPL SVCRTAB PANEL(SVCRPAN1)\"\nif (rc > 8) then do                     /* error?                 */\n   say 'TBDISPL error    rc = 'rc''     /* yes- output message    */\n   call dealloc                         /* remove allocation      */\n   exit(0)                              /* and quit               */\nend\nif (rc = 8) then do                     /* end?                   */\n   ADDRESS \"ISPEXEC\" \"REMPOP\"           /* remove pop-up          */\n   call dealloc                         /* remove allocation      */\n   return                               /* and quit               */\nend\ndo while (ztdsels > 0)                  /* svc selection loop     */\n   address \"ISPEXEC\" \"CONTROL DISPLAY SAVE\" /* Save The Environment */\n   if (rc \\= 0) then do                 /* save okay?             */\n      say 'CONTROL SAVE error  rc = 'rc''\n      call dealloc                      /* Dealloc                */\n      exit(0)                           /* and quit               */\n   end\n   if (ssel = '/') then do              /* user selected a svc?   */\n      call display_svc_storage          /* display the svc storage*/\n   end\n   address \"ISPEXEC\" \"CONTROL DISPLAY RESTORE\" /* Restore the envirn*/\n   if (rc \\= 0) then do                 /* save okay?             */\n      say 'CONTROL RESTORE error  rc = 'rc''\n      call dealloc                      /* Dealloc                */\n      exit(0)                           /* and quit               */\n   end\n   ssel= '_'                             /* reset the sel ind      */\nztdmark= '**************** End Of SVC Update Recording Table *****************'\n   ADDRESS \"ISPEXEC\" \"TBDISPL SVCRTAB\"\n   if (rc = 8) then do                   /* pf3 or return?         */\n      ADDRESS \"ISPEXEC\" \"REMPOP\"         /* remove pop-up          */\n      return                             /* and quit               */\n   end\n   if (rc > 8) then do\n      say 'TBDISPL error  rc = 'rc''\n      call dealloc                       /* Dealloc                */\n      exit(0)                            /* and quit               */\n   end\nend\nADDRESS \"ISPEXEC\" \"REMPOP\"               /* remove menu pop-up     */\nreturn\ndisplay_svc_storage:\nADDRESS \"ISPEXEC\" \"TBCREATE SVCSTOR NOWRITE REPLACE\"\nif (rc >  4) then do                     /* call okay?             */\n   say 'TBCREATE error    rc = 'rc''     /* no- inform the user    */\n   call dealloc                          /* remove allocation      */\n   exit(0)                               /* let's quit             */\nend\nztdmark= ''                              /* set to null            */\nADDRESS \"ISPEXEC\" \"VPUT (ztdmark) SHARED\"\ntabrows=  20                             /* max table rows         */\nsvc_storage= storage(svcurnew,128)       /* 128 bytes of storage   */\nx= 1                                     /* starting position      */\ndo i= 1 to 8                             /* the number of lines    */\n   modhex=  c2x(substr(svc_storage,x,4)) /* first four bytes       */\n   modhex=  modhex' '                    /* blank                  */\n   modhex=  modhex''c2x(substr(svc_storage,x+4,4))\n   modhex=  modhex' '                    /* blank                  */\n   modhex=  modhex''c2x(substr(svc_storage,x+8,4))\n   modhex=  modhex' '                    /* blank                  */\n   modhex=  modhex''c2x(substr(svc_storage,x+12,4))\n   modchar= substr(svc_storage,x,16)     /* 16 bytes char          */\n   ADDRESS \"ISPEXEC\" \"TBADD SVCSTOR      /* add the entries        */\n            SAVE(modhex,modchar)\n            MULT(\"TABROWS\")\"\n   if (rc \\= 0) then do                  /* call okay?             */\n      say 'TBADD error    rc = 'rc''     /* no- inform the user    */\n      call dealloc                       /* remove allocation      */\n      exit(0)                            /* let's quit             */\n   end\n   x= (x + 16)                           /* next entry             */\nend\nADDRESS \"ISPEXEC\" \"TBTOP SVCSTOR\"        /* position to top of tab */\nif (rc \\= 0) then do                     /* call okay?             */\n   say 'TBTOP error    rc = 'rc''        /* no- inform the user    */\n   call dealloc                          /* remove allocation      */\n   exit(0)                               /* let's quit             */\nend\nADDRESS \"ISPEXEC\" \"ADDPOP POPLOC(ZCMD)\" /* pop-up position         */\nADDRESS \"ISPEXEC\" \"TBDISPL SVCSTOR PANEL(SVCRPAN2)\"\nif (rc > 8) then do                     /* error?                  */\n   say 'TBDISPL error    rc = 'rc''     /* yes- output message     */\n   call dealloc                         /* remove allocation       */\n   exit(0)                              /* and quit                */\nend\nADDRESS \"ISPEXEC\" \"REMPOP\"              /* remove pop-up           */\nreturn\ndisplay_info_panel:\nADDRESS \"ISPEXEC\" \"CONTROL DISPLAY LOCK\" /* lock the terminal      */\nif (rc \\= 0) then do                     /* error?                 */\n   say 'SUBSYS Lock error    rc = 'rc''  /* yes- output message    */\n   call dealloc                          /* dealloc                */\n   exit(0)                               /* and quit               */\nend\nsvcinfo= 'Your Request Is Being Processed Please Wait'\nADDRESS \"ISPEXEC\" \"ADDPOP ROW(1) COLUMN(1)\" /* pop-up position     */\nADDRESS \"ISPEXEC\" \"DISPLAY PANEL(svcrpan3)\" /* position the cursor */\nif (rc \\= 0) then do                    /* error?                  */\n   ADDRESS \"ISPEXEC\" \"REMPOP\"           /* remove pop-up           */\n   say 'Display error    rc = 'rc''\n   call dealloc                         /* Dealloc                 */\n   exit(0)                              /* and quit                */\nend\nADDRESS \"ISPEXEC\" \"REMPOP\"              /* remove pop-up           */\nreturn\nhouse_keeping:\n/*                                                                 */\n/* Set the error mode                                              */\n/*                                                                 */\naddress \"ISPEXEC\" \"CONTROL ERRORS CANCEL\"\n/*                                                                 */\n/* dynamically allocate the panel libraries                        */\n/*                                                                 */\n/* --------------------------------------------------------------- */\n/* Change the next line to point to your panel dataset in ISPPLIB. */\n/* --------------------------------------------------------------- */\naddress \"ISPEXEC\" \"LIBDEF ISPPLIB DATASET ID('SYS1.U.PANELS')\"\nreturn\ndealloc:\naddress \"ISPEXEC\" \"LIBDEF ISPPLIB\"\nreturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SVCRPAN1": {"ttr": 4619, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x08\\x01\\x19\\x08?\\x01\\x19\\x08?\\x15G\\x00\"\\x00\"\\x00\\x00\\xd7\\xc1\\xd5\\xc5\\xd3@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-03-24T00:00:00", "modifydate": "2019-03-24T15:47:08", "lines": 34, "newlines": 34, "modlines": 0, "user": "PANEL"}, "text": ")ATTR\n* TYPE(INPUT)   INTENS(HIGH) COLOR(RED)\n_ TYPE(INPUT)   INTENS(HIGH) COLOR(YELLOW)\n% TYPE(TEXT)    COLOR(RED)\n+ TYPE(TEXT)    COLOR(WHITE)\n# TYPE(TEXT)    INTENS(HIGH) COLOR(BLUE)\n? TYPE(OUTPUT)  INTENS(HIGH) COLOR(RED)\n@ TYPE(OUTPUT)  COLOR(RED)\n$ TYPE(OUTPUT)  COLOR(YELLOW)\n)BODY WINDOW(69,18)\n%\n% COMMAND ===>_ZCMD          %            SCROLL ===>_AMT   +\n%\n% SVC Update Recording Table Address:    $z       %\n% Number Of SVC Updates:                 $z   %\n%\n# Sel  SVC     OLD SVC           New SVC   Date      No Of   IEASVCxx\n# SVC  Number  Table             EP        Of        Updates Parmlib\n#              Entry             Address   Update    For SVC Suffix\n%\n)MODEL\n *z%  $z  %   $z               %$z       %$z       %$z   %  $z %\n)INIT\n.ZVARS= '(svcr@,svcnos,ssel,svcnum,svcurold,svcurnew,svcurdat, +\nsvcurcnt,svcursx)'\n&ZCMD= ' '\n.CURSOR=   ZCMD\n&ZWINTTL= 'SVC Update Recording Table'\n)REINIT\n&ZCMD=    ' '\n.CURSOR=   ZCMD\n&ZWINTTL= 'SVC Update Recording Table'\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SVCRPAN2": {"ttr": 4621, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00#\\x01\\x19\\x08?\\x01\\x19\\x08?\\x15G\\x00\\x1f\\x00\\x1f\\x00\\x00\\xd7\\xc1\\xd5\\xc5\\xd3@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-03-24T00:00:00", "modifydate": "2019-03-24T15:47:23", "lines": 31, "newlines": 31, "modlines": 0, "user": "PANEL"}, "text": ")ATTR\n* TYPE(INPUT)   INTENS(HIGH) COLOR(RED)\n_ TYPE(INPUT)   INTENS(HIGH) COLOR(YELLOW)\n% TYPE(TEXT)    COLOR(RED)\n+ TYPE(TEXT)    COLOR(WHITE)\n# TYPE(TEXT)    INTENS(HIGH) COLOR(BLUE)\n? TYPE(OUTPUT)  INTENS(HIGH) COLOR(RED)\n@ TYPE(OUTPUT)  COLOR(RED)\n$ TYPE(OUTPUT)  COLOR(YELLOW)\n)BODY WINDOW(62,16)\n%\n% COMMAND ===>_ZCMD          %    SCROLL ===>_AMT   +\n%\n% SVC Number:       $z  %\n% SVC Address:      $z       %\n%\n# First 128 bytes of the SVC Program\n%\n)MODEL\n $z                                  %     $z               %\n)INIT\n.ZVARS= '(svcnum,svcurnew,modhex,modchar)'\n&ZCMD= ' '\n.CURSOR=   ZCMD\n&ZWINTTL= 'SVC Program Storage'\n)REINIT\n&ZCMD=    ' '\n.CURSOR=   ZCMD\n&ZWINTTL= 'SVC Program Storage'\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SVCRPAN3": {"ttr": 4623, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x009\\x01\\x19\\x08?\\x01\\x19\\x08?\\x15G\\x00\\x1d\\x00\\x1d\\x00\\x00\\xd7\\xc1\\xd5\\xc5\\xd3@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-03-24T00:00:00", "modifydate": "2019-03-24T15:47:39", "lines": 29, "newlines": 29, "modlines": 0, "user": "PANEL"}, "text": ")ATTR\n* TYPE(INPUT)   INTENS(HIGH) COLOR(YELLOW)\n_ TYPE(INPUT)   INTENS(HIGH) COLOR(YELLOW)\n% TYPE(TEXT)    COLOR(RED)\n+ TYPE(TEXT)    COLOR(WHITE)\n# TYPE(TEXT)    INTENS(HIGH) COLOR(BLUE)\n$ TYPE(OUTPUT)  INTENS(HIGH) COLOR(YELLOW)\n? TYPE(OUTPUT)  INTENS(HIGH) COLOR(RED)\n@ TYPE(OUTPUT)  COLOR(RED)\n)BODY WINDOW(56,9)\n%\n%COMMAND ===>_ZCMD          %     SCROLL ===>_AMT   +\n%\n%    ------------------------------------------------\n%    |                                              |\n%    |$z                                           %|\n%    |                                              |\n%    ------------------------------------------------\n%\n)INIT\n.ZVARS=  '(svcinfo)'\n&ZCMD=   ' '\n.CURSOR= ZCMD\n&ZWINTTL=  'SVC Information Panel'\n)REINIT\n.CURSOR= ZCMD\n&ZWINTTL=  'SVC Information Panel'\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SVCUPDRC": {"ttr": 4625, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00Y\\x01\\x10 o\\x01\\x19\\x08?\\x15W\\x01;\\x01;\\x00\\x00\\xc1\\xd9\\xe3\\xc9\\xc3\\xd3\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2010-07-25T00:00:00", "modifydate": "2019-03-24T15:57:59", "lines": 315, "newlines": 315, "modlines": 0, "user": "ARTICLE"}, "text": "The SVC update recording table\n\n\nSVCR REXX EXEC\n\n/**rexx**/\n/*  Program-id           SVCR                                      */\n/*  Remarks              This REXX EXEC will display the entries   */\n/*                       in the SVC update recording table.        */\n/*                       The following information is displayed    */\n/*                       for each updated SVC:                     */\n/*                       1. SVC Number.                            */\n/*                       2. The old SVC Table Entry.               */\n/*                       3. The new SVC EP address.                */\n/*                       4. Date the SVC table was updated.        */\n/*                       5. The number of updates for the SVC.     */\n/*                       6. Suffix of the IEASVCxx parmlib member, */\n/*                          if the SVC table entry was replaced    */\n/*                          using this method.                     */\n/*                       When the table is displayed, the entries  */\n/*                       can be selected to display the first 128  */\n/*                       bytes of the SVC module storage.          */\n/*trace i*/                             /* trace option            */\ncall house_keeping                      /* let's initialize        */\ndo forever\n   call get_the_svcr_address            /* svc upd recording table */\n   call display_info_panel              /* display info panel      */\n   call build_the_svcr_entries          /* build the svcr entries  */\n   call display_the_svcr_entries        /* display the svcr entries*/\n   exit(0)                              /* let's get out           */\nend\nget_the_svcr_address:\ncvt=         c2x(storage(10,4))         /* cvt address             */\ncvtabend=    d2x((x2d(cvt))+200)        /* cvt + 200 = cvtabend    */\nscvt=        c2x(storage(cvtabend,4))   /* scvt @                  */\nscvtsvcr=    d2x(x2d(scvt)+136)         /* scvt + 136 = scvtsvcr   */\nsvcrtaddr=   c2x(storage(scvtsvcr,4))   /* svct table @            */\nsvcr@=       svcrtaddr                  /* store for panel output  */\nreturn                                  /* return to the caller    */\nbuild_the_svcr_entries:\ndo i = 0 to 255                         /* process all svcr entries*/\n   svcr.i= storage(svcrtaddr,24)        /* pick up the svcr entry  */\n   svcrtaddr= d2x(x2d(svcrtaddr)+24)    /* next svcr table entry   */\nend\nADDRESS \"ISPEXEC\" \"TBCREATE SVCRTAB NOWRITE REPLACE\"\nif (rc >  4) then do                    /* call okay?              */\n   say 'TBCREATE error    rc = 'rc''    /* no- inform the user     */\n   call dealloc                         /* remove allocation       */\n   exit(0)                              /* let's quit              */\nend\nssel=       '_'                         /* init                    */\nsvcrtadr=  svcr@                        /* svcr table address      */\nztdmark= '**************** End Of SVC Update Recording Table *****************'\nADDRESS \"ISPEXEC\" \"VPUT (ztdmark) SHARED\"\ntabrows=  256                           /* max table rows          */\nsvcnos=   0                             /* count the no of svcs    */\ndo i= 0 to 255                          /* add the esr svcs to an  */\n   if substr(svcr.i,1,16)= '00000000000000000000000000000000'x then\n      iterate\n   svcnos= (svcnos + 1)                 /* no of updated svcs      */\n   svcnum= i                            /* svc number              */\n   svcurold= c2x(substr(svcr.i,1,8))    /* old svc table entry     */\n   svcurret= c2x(substr(svcr.i,9,4))    /* ret @ in caller        */\n   svcurnew= c2x(substr(svcr.i,13,4))   /* new svc ep @           */\n   svcurdat= c2x(substr(svcr.i,17,4))   /* cvtdate for update     */\n   svcurcnt= c2x(substr(svcr.i,21,2))   /* count of updates for svc*/\n   svcursx=  substr(svcr.i,23,2)        /* suffix of ieasvcxx     */\n   ADDRESS \"ISPEXEC\" \"TBADD SVCRTAB     /* add the entries        */\n            SAVE(svcnum,svcurold,svcurret,svcurnew,svcurdat,svcurcnt,\n            svcursx)\n            MULT(\"TABROWS\")\"\n   if (rc \\= 0) then do                 /* call okay?             */\n      say 'TBADD error    rc = 'rc''    /* no- inform the user    */\n      call dealloc                      /* remove allocation      */\n      exit(0)                           /* let's quit             */\n   end\nend\nADDRESS \"ISPEXEC\" \"TBTOP SVCRTAB\"       /* position to top of tab */\nif (rc \\= 0) then do                    /* call okay?             */\n   say 'TBTOP error    rc = 'rc''       /* no- inform the user    */\n   call dealloc                         /* remove allocation      */\n   exit(0)                              /* let's quit             */\nend\nreturn\ndisplay_the_svcr_entries:\nADDRESS \"ISPEXEC\" \"ADDPOP POPLOC(ZCMD)\" /* pop-up position        */\nADDRESS \"ISPEXEC\" \"TBDISPL SVCRTAB PANEL(SVCRPAN1)\"\nif (rc > 8) then do                     /* error?                 */\n   say 'TBDISPL error    rc = 'rc''     /* yes- output message    */\n   call dealloc                         /* remove allocation      */\n   exit(0)                              /* and quit               */\nend\nif (rc = 8) then do                     /* end?                   */\n   ADDRESS \"ISPEXEC\" \"REMPOP\"           /* remove pop-up          */\n   call dealloc                         /* remove allocation      */\n   return                               /* and quit               */\nend\ndo while (ztdsels > 0)                  /* svc selection loop     */\n   address \"ISPEXEC\" \"CONTROL DISPLAY SAVE\" /* Save The Environment */\n   if (rc \\= 0) then do                 /* save okay?             */\n      say 'CONTROL SAVE error  rc = 'rc''\n      call dealloc                      /* Dealloc                */\n      exit(0)                           /* and quit               */\n   end\n   if (ssel = '/') then do              /* user selected a svc?   */\n      call display_svc_storage          /* display the svc storage*/\n   end\n   address \"ISPEXEC\" \"CONTROL DISPLAY RESTORE\" /* Restore the envirn*/\n   if (rc \\= 0) then do                 /* save okay?             */\n      say 'CONTROL RESTORE error  rc = 'rc''\n      call dealloc                      /* Dealloc                */\n      exit(0)                           /* and quit               */\n   end\n   ssel= '_'                             /* reset the sel ind      */\nztdmark= '**************** End Of SVC Update Recording Table *****************'\n   ADDRESS \"ISPEXEC\" \"TBDISPL SVCRTAB\"\n   if (rc = 8) then do                   /* pf3 or return?         */\n      ADDRESS \"ISPEXEC\" \"REMPOP\"         /* remove pop-up          */\n      return                             /* and quit               */\n   end\n   if (rc > 8) then do\n      say 'TBDISPL error  rc = 'rc''\n      call dealloc                       /* Dealloc                */\n      exit(0)                            /* and quit               */\n   end\nend\nADDRESS \"ISPEXEC\" \"REMPOP\"               /* remove menu pop-up     */\nreturn\ndisplay_svc_storage:\nADDRESS \"ISPEXEC\" \"TBCREATE SVCSTOR NOWRITE REPLACE\"\nif (rc >  4) then do                     /* call okay?             */\n   say 'TBCREATE error    rc = 'rc''     /* no- inform the user    */\n   call dealloc                          /* remove allocation      */\n   exit(0)                               /* let's quit             */\nend\nztdmark= ''                              /* set to null            */\nADDRESS \"ISPEXEC\" \"VPUT (ztdmark) SHARED\"\ntabrows=  20                             /* max table rows         */\nsvc_storage= storage(svcurnew,128)       /* 128 bytes of storage   */\nx= 1                                     /* starting position      */\ndo i= 1 to 8                             /* the number of lines    */\n   modhex=  c2x(substr(svc_storage,x,4)) /* first four bytes       */\n   modhex=  modhex' '                    /* blank                  */\n   modhex=  modhex''c2x(substr(svc_storage,x+4,4))\n   modhex=  modhex' '                    /* blank                  */\n   modhex=  modhex''c2x(substr(svc_storage,x+8,4))\n   modhex=  modhex' '                    /* blank                  */\n   modhex=  modhex''c2x(substr(svc_storage,x+12,4))\n   modchar= substr(svc_storage,x,16)     /* 16 bytes char          */\n   ADDRESS \"ISPEXEC\" \"TBADD SVCSTOR      /* add the entries        */\n            SAVE(modhex,modchar)\n            MULT(\"TABROWS\")\"\n   if (rc \\= 0) then do                  /* call okay?             */\n      say 'TBADD error    rc = 'rc''     /* no- inform the user    */\n      call dealloc                       /* remove allocation      */\n      exit(0)                            /* let's quit             */\n   end\n   x= (x + 16)                           /* next entry             */\nend\nADDRESS \"ISPEXEC\" \"TBTOP SVCSTOR\"        /* position to top of tab */\nif (rc \\= 0) then do                     /* call okay?             */\n   say 'TBTOP error    rc = 'rc''        /* no- inform the user    */\n   call dealloc                          /* remove allocation      */\n   exit(0)                               /* let's quit             */\nend\nADDRESS \"ISPEXEC\" \"ADDPOP POPLOC(ZCMD)\" /* pop-up position         */\nADDRESS \"ISPEXEC\" \"TBDISPL SVCSTOR PANEL(SVCRPAN2)\"\nif (rc > 8) then do                     /* error?                  */\n   say 'TBDISPL error    rc = 'rc''     /* yes- output message     */\n   call dealloc                         /* remove allocation       */\n   exit(0)                              /* and quit                */\nend\nADDRESS \"ISPEXEC\" \"REMPOP\"              /* remove pop-up           */\nreturn\ndisplay_info_panel:\nADDRESS \"ISPEXEC\" \"CONTROL DISPLAY LOCK\" /* lock the terminal      */\nif (rc \\= 0) then do                     /* error?                 */\n   say 'SUBSYS Lock error    rc = 'rc''  /* yes- output message    */\n   call dealloc                          /* dealloc                */\n   exit(0)                               /* and quit               */\nend\nsvcinfo= 'Your Request Is Being Processed Please Wait'\nADDRESS \"ISPEXEC\" \"ADDPOP ROW(1) COLUMN(1)\" /* pop-up position     */\nADDRESS \"ISPEXEC\" \"DISPLAY PANEL(svcrpan3)\" /* position the cursor */\nif (rc \\= 0) then do                    /* error?                  */\n   ADDRESS \"ISPEXEC\" \"REMPOP\"           /* remove pop-up           */\n   say 'Display error    rc = 'rc''\n   call dealloc                         /* Dealloc                 */\n   exit(0)                              /* and quit                */\nend\nADDRESS \"ISPEXEC\" \"REMPOP\"              /* remove pop-up           */\nreturn\nhouse_keeping:\n/*                                                                 */\n/* Set the error mode                                              */\n/*                                                                 */\naddress \"ISPEXEC\" \"CONTROL ERRORS CANCEL\"\n/*                                                                 */\n/* dynamically allocate the panel libraries                        */\n/*                                                                 */\naddress \"ISPEXEC\" \"LIBDEF ISPPLIB DATASET ID('XXXXXXX.PANELS')\"\nreturn\ndealloc:\naddress \"ISPEXEC\" \"LIBDEF ISPPLIB\"\nreturn\n\n\nSVCRPAN1 PANEL\n\n)ATTR\n* TYPE(INPUT)   INTENS(HIGH) COLOR(RED)\n_ TYPE(INPUT)   INTENS(HIGH) COLOR(YELLOW)\n% TYPE(TEXT)    COLOR(RED)\n+ TYPE(TEXT)    COLOR(WHITE)\n# TYPE(TEXT)    INTENS(HIGH) COLOR(BLUE)\n? TYPE(OUTPUT)  INTENS(HIGH) COLOR(RED)\n@ TYPE(OUTPUT)  COLOR(RED)\n$ TYPE(OUTPUT)  COLOR(YELLOW)\n)BODY WINDOW(69,18)\n%\n% COMMAND ===>_ZCMD          %            SCROLL ===>_AMT   +\n%\n% SVC Update Recording Table Address:    $z       %\n% Number Of SVC Updates:                 $z   %\n%\n# Sel  SVC     OLD SVC           New SVC   Date      No Of   IEASVCxx\n# SVC  Number  Table             EP        Of        Updates Parmlib\n#              Entry             Address   Update    For SVC Suffix\n%\n)MODEL\n *z%  $z  %   $z               %$z       %$z       %$z   %  $z %\n)INIT\n.ZVARS= '(svcr@,svcnos,ssel,svcnum,svcurold,svcurnew,svcurdat, +\nsvcurcnt,svcursx)'\n&ZCMD= ' '\n.CURSOR=   ZCMD\n&ZWINTTL= 'SVC Update Recording Table'\n)REINIT\n&ZCMD=    ' '\n.CURSOR=   ZCMD\n&ZWINTTL= 'SVC Update Recording Table'\n)PROC\n)END\n\n\nSVCRPAN2 PANEL\n\n)ATTR\n* TYPE(INPUT)   INTENS(HIGH) COLOR(RED)\n_ TYPE(INPUT)   INTENS(HIGH) COLOR(YELLOW)\n% TYPE(TEXT)    COLOR(RED)\n+ TYPE(TEXT)    COLOR(WHITE)\n# TYPE(TEXT)    INTENS(HIGH) COLOR(BLUE)\n? TYPE(OUTPUT)  INTENS(HIGH) COLOR(RED)\n@ TYPE(OUTPUT)  COLOR(RED)\n$ TYPE(OUTPUT)  COLOR(YELLOW)\n)BODY WINDOW(62,16)\n%\n% COMMAND ===>_ZCMD          %    SCROLL ===>_AMT   +\n%\n% SVC Number:       $z  %\n% SVC Address:      $z       %\n%\n# First 128 bytes of the SVC Program\n%\n)MODEL\n $z                                  %     $z               %\n)INIT\n.ZVARS= '(svcnum,svcurnew,modhex,modchar)'\n&ZCMD= ' '\n.CURSOR=   ZCMD\n&ZWINTTL= 'SVC Program Storage'\n)REINIT\n&ZCMD=    ' '\n.CURSOR=   ZCMD\n&ZWINTTL= 'SVC Program Storage'\n)PROC\n)END\n\n\nSVCRPAN3 PANEL\n\n)ATTR\n* TYPE(INPUT)   INTENS(HIGH) COLOR(YELLOW)\n_ TYPE(INPUT)   INTENS(HIGH) COLOR(YELLOW)\n% TYPE(TEXT)    COLOR(RED)\n+ TYPE(TEXT)    COLOR(WHITE)\n# TYPE(TEXT)    INTENS(HIGH) COLOR(BLUE)\n$ TYPE(OUTPUT)  INTENS(HIGH) COLOR(YELLOW)\n? TYPE(OUTPUT)  INTENS(HIGH) COLOR(RED)\n@ TYPE(OUTPUT)  COLOR(RED)\n)BODY WINDOW(56,9)\n%\n%COMMAND ===>_ZCMD          %     SCROLL ===>_AMT   +\n%\n%    ------------------------------------------------\n%    |                                              |\n%    |$z                                           %|\n%    |                                              |\n%    ------------------------------------------------\n%\n)INIT\n.ZVARS=  '(svcinfo)'\n&ZCMD=   ' '\n.CURSOR= ZCMD\n&ZWINTTL=  'SVC Information Panel'\n)REINIT\n.CURSOR= ZCMD\n&ZWINTTL=  'SVC Information Panel'\n)PROC\n)END\n\n\nR F Perretta\nSenior Systems Programmer (UK)                         1996\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SWRID": {"ttr": 4869, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01!\\x00\\x04\\x01 \\x14?\\x01 \\x14o\\x10A\\x03N\\x031\\x00\\x00\\xe2\\xe6\\xd9\\xc9\\xc4@@@@@'", "ispf": {"version": "01.33", "flags": 0, "createdate": "2020-05-22T00:00:00", "modifydate": "2020-05-25T10:41:04", "lines": 846, "newlines": 817, "modlines": 0, "user": "SWRID"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "SWRID$": {"ttr": 5129, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00\\t\\x01\\x07\"_\\x01 \\x14?\\x17&\\x00\\x1c\\x00\\x0e\\x00\\x00\\xf8`\\xc3\\xc8\\xc1@@@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "2007-08-13T00:00:00", "modifydate": "2020-05-22T17:26:09", "lines": 28, "newlines": 14, "modlines": 0, "user": "8-CHA"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,RLD)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(SWRID)\n//SYSUT1   DD UNIT=SYSDA,SPACE=(CYL,20)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=SYSDA,SPACE=(TRK,30),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=(OLD,PASS),DSN=&&TEMP\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB\n SETCODE AC(1)\n ORDER   SWRID\n SETSSI  CB500836\n ENTRY   SWRID\n NAME    SWRID(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SWRID$22": {"ttr": 5131, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0f\\x00G\\x01\\x07\"_\\x01 \\x16/ B\\x00\\x1c\\x00\\x0e\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.15", "flags": 0, "createdate": "2007-08-13T00:00:00", "modifydate": "2020-06-10T20:42:47", "lines": 28, "newlines": 14, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM - FOR Z/OS 2.2\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,RLD)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB,UNIT=SYSALLDA,VOL=SER=Z25RES\n//         DD DISP=SHR,DSN=SYS1.MODGEN,UNIT=SYSALLDA,VOL=SER=Z25RES\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(SWRID)\n//SYSUT1   DD UNIT=SYSDA,SPACE=(CYL,20)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=SYSDA,SPACE=(TRK,30),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=(OLD,PASS),DSN=&&TEMP\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB\n SETCODE AC(1)\n ORDER   SWRID\n SETSSI  CB500836\n ENTRY   SWRID\n NAME    SWRID22(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SWRID#": {"ttr": 5133, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x11\\x01 \\x14O\\x01 \\x14_\\t\\x17\\x00\\x19\\x00\\x18\\x00\\x00\\xc8\\xc5\\xd3\\xd7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2020-05-23T00:00:00", "modifydate": "2020-05-24T09:17:11", "lines": 25, "newlines": 24, "modlines": 0, "user": "HELP"}, "text": ")F Function -\n   The SWRID command will switch the current users RACF userid to\n   a different userid, and return. This is to allow a user to use\n   their unprivileged userid and then, when needed, to switch to a\n   privileged userid to perform privileged actions.\n\n   When switching the password for the privileged userid will be\n   asked via a prompt using a non-display entry field.\n\n   Enter SWRID without any parameters to return to the original\n   userid.\n\n   This is similar to the OMVS, Unix, Linux su command.\n\n)X Syntax -\n   SWRID   | userid\n           | userid/password\n\n   If userid is not provided then it will be prompted for.\n\n   If password is not provided then it will be prompted for which\n   is the recommended mode of operation.\n\n   DEFAULTS - NONE\n   ALIAS    - NONE\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "USEID": {"ttr": 5135, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1c\\x004\\x01 \\x14\\x1f\\x01 \\x14/\\x15@\\x03\\x07\\x02\\xe6\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.28", "flags": 0, "createdate": "2020-05-20T00:00:00", "modifydate": "2020-05-21T15:40:34", "lines": 775, "newlines": 742, "modlines": 0, "user": "SBGOLOB"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "USEID$": {"ttr": 5636, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00(\\x01\\x07\"_\\x01 \\x14/\\x15F\\x00\\x1c\\x00\\x0e\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "2007-08-13T00:00:00", "modifydate": "2020-05-21T15:46:28", "lines": 28, "newlines": 14, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,RLD)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.CBT500.FILE836(USEID)\n//SYSUT1   DD UNIT=SYSDA,SPACE=(CYL,20)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=SYSDA,SPACE=(TRK,30),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,RENT,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=(OLD,PASS),DSN=&&TEMP\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB\n SETCODE AC(1)\n ORDER   USEID\n SETSSI  CB500836\n ENTRY   USEID\n NAME    USEID(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "USEID@": {"ttr": 5638, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00'\\x01 \\x14/\\x01 \\x14/\\x12\\x05\\x00j\\x00j\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2020-05-21T00:00:00", "modifydate": "2020-05-21T12:05:27", "lines": 106, "newlines": 106, "modlines": 0, "user": "SBGOLOB"}, "text": "The article author is\nJon E Pearkins (Canada)\n\nCopyright  Xephon 2003\n(www.cbttape.org supports Xephon software now)\n\nAnd the code author is Trevor Howard who wrote this code\napproximately 20 years prior - so the early 1980's.\n\nMaking it easy to switch IDs in TSO\n\nHave you ever hit PF3 in the ISPF Editor and had RACF refuse to\nsave your changes?  And then had to CANCEL, get all the way out of\nISPF, log on to a different TSO ID, find the dataset, and make\nall the changes again before you can hit PF3?  The chances are\nthat you didn't even remember all the changes you made the first\ntime.\n\nThe TSO command USEID solves this, and many other problems, by\nallowing you to switch IDs in the middle of virtually anything in\nISPF, TSO, or any application that runs on ISPF.  Simply type TSO\nUSEID in ISPF, or just USEID at a TSO READY prompt or in ISPF\nOption 6, followed by the user ID you want to switch to, and\nyou'll be prompted for the ID's password and taken back to where\nyou left off.\n\nSpecifying USEID without an ID returns you to your log-on ID.\nAbout the only things to remind you that you logged on with your\noriginal ID are the JOBNAME and OWNER fields that you'll see if\nyou look at your TSO session with SDSF's DA (Display Active)\ncommand.\n\nIf you submit a batch job, the SDSF-displayed OWNER field and the\nvalue of &SYSUID in the job's JCL will be your assumed ID.  It's\njust as if you had originally logged on to TSO with the assumed\nID and submitted the batch job. The only thing you lose is\nNOTIFY=&SYSUID on the JOB card of the batch job; if you code it,\nyou won't receive a message when the job completes because,\ntechnically, you're still logged on in TSO with your original\nrather than your assumed ID.\n\nIMPLEMENTATION EXAMPLE\n\nUSEID is used in one organization to try to dissuade technical\nstaff from always logging on with their 'super power' RACF\nuserIDs.  In fact, the RACF TSO segment of all such IDs has been\ndeleted; users must log on with their normal, slightly less\npowerful ID, and then use USEID to switch to super powers only\nwhen they need them.\n\nIt's a nice theory and, so far, it has satisfied the auditors.\nBut it's easy to switch to the super power ID and forget to\nswitch back, which can be a problem, given that most systems\nprogrammers stay logged on all day.  However, that still doesn't\ntake away from the fact that USEID is an extremely handy command.\n\nHISTORY\n\nThis code was written over 20 years ago by Trevor Howard when he\nfirst joined the Alberta Government in Canada, and he recently\ndescribed it as the most useful 100 lines of code I ever wrote\".\n\nBecause it was written so long ago, it uses the original RACF\nmacros, which are no longer supported, but still work.  One of IBM\nCanada's top technical people recently reviewed the code and\ncommented that no RACF short-cuts were taken, which doubtless\nexplains why it has never caused any RACF problems or errors over\nthe many years of its use at several local z/OS sites.\n\nNOTES\n\nTwo important areas of USEID are commented out because I haven't\nhad a chance to fully test them.  They are as follows:\n\nThe group checking section, including the call to AUTHCHEK, was\nremoved years ago at the site's request.  The group checking code\nis commented out just before the GROUPOK label.  Obviously, if you\nleave group checking commented out, you won't need to assemble or\ninclude AUTHCHEK in the load module.\n\nCode to address a new bug that surfaced recently and was tracked\ndown to a missing maximum length check on the user-supplied ID.\nThe ID length checking code is commented out after the NOSAVE\nlabel.\n\nASSEMBLY\n\nYou could just separately assemble USEID and AUTHCHEK, and\nlinkedit them together into a load module and store it\nin SYS1.CMDLIB(USEID).  The only other step you would need to\ncomplete would be to add USEID to SYS1.PARMLIB(IKJTSO00),as is\nrequired for all APF-authorized TSO commands:\n\nAUTHCMD NAMES(\n/*   AUTHORIZED COMMANDS\n*/ +\n   LISTB    LISTBC\n/*\n*/ +\n     {rest of APF-authorized\n      TSO commands}\n\n   USEID\n/* CHANGE RACF USERID\n*/ +\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "USEID22": {"ttr": 5641, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x009\\x01 \\x14\\x1f\\x01 \\x14/\\x11W\\x02\\xf1\\x02\\xe6\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2020-05-20T00:00:00", "modifydate": "2020-05-21T11:57:39", "lines": 753, "newlines": 742, "modlines": 0, "user": "SBGOLOB"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "USEID22$": {"ttr": 5896, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00\\x06\\x01\\x07\"_\\x01 \\x14\\x1f\"\\'\\x00\\x1c\\x00\\x0e\\x00\\x00\\xc1\\xe2\\xd4\\xd1\\xc3\\xd3@@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "2007-08-13T00:00:00", "modifydate": "2020-05-20T22:27:06", "lines": 28, "newlines": 14, "modlines": 0, "user": "ASMJCL"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,RLD)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(USEID22)\n//SYSUT1   DD UNIT=SYSDA,SPACE=(CYL,20)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=SYSDA,SPACE=(TRK,30),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,RENT,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=(OLD,PASS),DSN=&&TEMP\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB\n SETCODE AC(1)\n ORDER   USEID\n SETSSI  CB500836\n ENTRY   USEID\n NAME    USEID22(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "WHEREIS": {"ttr": 5898, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00V\\x01\\x19\\x10\\x1f\\x01\\x19\\x11?\\x157\\x02\\x0e\\x02\\x0e\\x00\\x00\\xe6\\xd1\\xc5\\xd5\\xe2\\xc5\\xd5@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "2019-04-11T00:00:00", "modifydate": "2019-04-23T15:37:56", "lines": 526, "newlines": 526, "modlines": 0, "user": "WJENSEN"}, "text": "*\n* Determining where a module was loaded from\n*\n*\n* PROGRAM SOURCE CODE\n*\n* Original version:\n* Paul Poolsaar\n* Systems Programmer (Canada)                             1996\n*\n* Rather heavily modified by Willy Jensen, 2019.\n*   TSOPUTLN line replaces TPUTs. Macro supplied by Willy Jensen\n*   new macros MVLIT and CLEAR.   Macros supplied by Willy Jensen\n*\n         Macro\n.*-\n.*   TSOPUTLN - assembler macro - TSO putline not needing setup.\n.*\n.* The macro is self-contained in that  it does not need an external\n.* subroutine, the  subroutine is generated internally  at the first\n.* macro expansion.\n.*\n.* The macro  works even if  used in a  mdule started with  the BAKR\n.* instruction, because  the generated  subroutine uses  EXTRACT and\n.* LOCASCB to  get the necessary runtime  info, it does not  rely on\n.* tracing back through save areas.\n.*\n.* It may cause a slight  performance degradation as the module must\n.* format the message string, so GETMAINs and FREEMAINs a work area.\n.* On the other hand, this  makes the subroutine fully reentrant and\n.* reusable.\n.*\n.* Syntax\n.*\n.*  TSOPUTLN address,length (,DSECT=YES/NO)\n.*           address     Address of text. Required.\n.*                       May be label, (reg) or F|H|B.label for\n.*                       L label, LH label or LB label.\n.*           length      Length of text. Number or (reg). Default\n.*                       is length of 'address'.\n.*           DSECT=YES   Generate various neccessary IBM dsects.\n.*           DSECT=NO    Do not generate IBM dsects. This is used\n.*                       when those dsects are generated elsewhere.\n.*\n.* Samples\n.*\n.*            la    r5,120\n.*            TsoPutln msg,(r5)\n.*\n.*            la    r4,msg\n.*            TsoPutln (r4),(r5)\n.*\n.*            TsoPutln text\n.*\n.*            TsoPutln text,25\n.*\n.*            TsoPutln 'Just another fine day'\n.*\n.*            TsoPutln f.textaddr,h.textlen\n.*\n.*   msg      ds    cl256\n.*   textaddr dc    a(test)\n.*   textlen  dc    y(l'test)\n.*   text     dc    c'Kilroy was here'\n.*   text2    dc    c' and it is such a nice day today'\n.*\n.* Note\n.*\n.* TSOPUTLN does not work when used in a REXX function, i.e. n=PGM()\n.*\n.* by: Willy Jensen\n.*     mail: wj-53@outlook.com\n.*     web : http://harders-jensen.com/wjtech/index.html\n.*-\n&mlbl    TSoPutLn &print=nogen,&dsects=YES\n         lcla  &n,&pn\n         lclc  &q,&l,&sect,&src,&len,&p,&r\n         gblb  @@tsoputln\n         gblc  $xlalen\n&q       setc  Upper('&syslist(1)')\n         aif   ('&q' eq 'XLA').xla\n&l       setc  'tp&sysndx'\n&sect    setc  '&sysect'\n&src     setc  '&syslist(1)'\n&len     setc  '&syslist(2)'\n         aif   (k'&mlbl eq 0).mlbln\n&mlbl    ds    0h\n.mlbln   anop\n.* text address - label, (reg) or 'literal'\n         TSOPUTLN xla,r1,&src\n.* text length - label, (reg) or null. if null then set l'text\n         TSOPUTLN xla,r0,&len,&$xlalen\n         l     r15,=v(TSOPUTLN)\n         basr  r14,r15\n         aif   (&@@tsoputln).x\n.*-\n.* module\n.*-\n&@@tsoputln setb 1\n         push  using\n         push  print\n         print &print\n*-\n* TSOPUTLN module\n*-\nTSOPUTLN Csect\n         save  (14,12)\n         lr    r12,r15\n         Using TSOPUTLN,r12\n         Using @tputblk,r10\n         lr    r2,r1                   copy text/buffer address\n         lr    r3,r0                   copy text length\n*- get storage\n         la    r9,@tputblkl+4(r3)      blk+text length\n         Getmain R,lv=(r9),loc=31\n         lr    r10,r1\n         lr    r0,r10\n         la    r1,@tputblkl\n.*       la    r14,=al1(0)\n         la    r14,tsoputln_al10\n         la    r15,1\n         mvcl  r0,r14\n         st    r10,8(,r13)             chain\n         st    r13,4(,r10)               save\n         lr    r13,r10                     areas\n*- copy data\n         la    r1,4(,r3)               set length\n         sll   r1,16                   to upper halfword\n         st    r1,@tputlen             store as prefix\n         la    r14,@tputtext           target address\n         lr    r15,r3                  copy length\n         mvcl  r14,r2                  copy text\n*- obtain address of the upt through the extract facility\n         la    r0,@tputiopl\n         EXTRACT (0),'S',FIELDS=(PSB,ASID),MF=(E,@tputextr)\n         l     r1,@tputiopl\n         mvc   @tputupta,pscbupt-pscb(r1)\n*- obtain address of the ect from the lwa control block\n         l     r1,@tputiopl+4          asid\n         LOCASCB ASID=(1)\n         l     r1,ascbasxb-ascb(,r1)   -> asxb\n         l     r1,asxblwa-asxb(,r1)    -> lwa\n         mvc   @tputecta,lwapect-lwa(r1) get ect address\n*- do putline\n         xc    @tputecb,@tputecb\n         xc    @tputiopl(16),@tputiopl\n         l     r14,@tputupta\n         l     r15,@tputecta\n         PUTLINE PARM=@tputmfl,UPT=(r14),ECT=(r15),ECB=@tputecb,       c\n               OUTPUT=(@tputlen,TERM,SINGLE,DATA),MF=(E,@tputiopl)\n         lr    r5,r15\n*- release storage\n         l     r13,4(,r13)             <- callers save area\n         Freemain R,lv=(r9),a=(r10)\n*- back\n         lr    r15,r5                  set return code\n         lm    r2,r12,28(r13)          reload gregs\n         l     r14,12(,r13)            return address\n         br    r14                     and return\ntsoputln_al10  dc al1(0)\n         drop  r10,r12\n*-\n* TSOPUTLN local dsects\n*-\n@tputblk  dsect\n@tputsa1  ds    18a\n@tputextr EXTRACT MF=L\n*         org   @tputextr\n@tputecb  ds    a\n@tputecta ds    a\n@tputupta ds    a\n*         org\n@tputiopl ds    4a\n@tputmfl  PUTLINE MF=L\n@tputmsgl ds    a\n@tputmsg  ds    cl255\n@tputlen  ds    a\n@tputtext ds    0c\n@tputblkl equ   *-@tputblk\n         aif   ('&dsects' ne 'YES').dsctn\n*-\n* TSOPUTLN IBM dsect expansions (if requested)\n*-\n         IKJPSCB\n         IHAASCB\n         IHAASXB\n         IKJEFLWA\n.dsctn   anop\n         pop   print\n.* rejoin csect\n&sect    Csect                         resume main\n         pop  using\n.x       Mexit\n.*-\n.* XLA - subroutine, generate Lx instruction\n.* Syntax: macname XLA,reg,ahat\n.*                 what: label, (reg), 'literal', f/h/b.label\n.*-\n.XLA     anop\n         lclc  &xlar,&xlap,&xla\n         lcla  &xlapn,&xlan\n&$xlalen setc  ''\n&xlar    setc  '&syslist(2)'\n&xlapn   seta  2\n.xlanext anop\n&xlapn   seta  &xlapn+1\n         aif   (&xlapn gt n'&syslist).xlan\n&xlap    setc  '&syslist(&xlapn)'\n         aif   (k'&xlap eq 0).xlanext\n         aif   ('&xlap '(1,1) eq '(').xlareg\n         aif   ('&xlap '(1,1) eq '''').xlalit\n         aif   ('&xlap  '(2,1) eq '.').xlafld\n&xla     setc  t'&xlap\n         aif   ('&xla' eq 'N').xlanum\n         la    &xlar,&xlap\n&$xlalen setc 'l''&xlap'\n         mexit\n.xlanum  anop\n         lgfi  &xlar,&xlap\n         mexit\n.xlafld  anop\n&xlan    seta  k'&xlap-2\n&xla     setc  '&xlap'(1,1)\n&xla     setc  Upper('&xla')\n         aif   ('&xla' ne 'F').xlafld2\n&xla     setc  ''\n.xlafld2 anop\n&xlap    setc  '&xlap'(3,&xlan)\n         l&xla &xlar,&xlap\n         mexit\n.xlareg  anop\n&xlan    seta  k'&xlap-2\n&xlap    setc  '&xlap'(2,&xlan)\n         lr    &xlar,&xlap\n         mexit\n.xlalit  anop\n         la    &xlar,=c&xlap\n&xlan    seta k'&xlap-2\n&$xlalen setc '&xlan'\n.xlan    mexit\n         MEND\n\n         MACRO\n&mlbl    MVLIT &a,&t\n         lcla  &l\n&l       seta   k'&t-2\n&mlbl    mvc   &a.(&l),=c&t\n         MEND\n\n         MACRO\n&mlbl    CLEAR &a\n&mlbl    mvi   &a,c' '\n         mvc   &a+1(l'&a-1),&a\n         MEND\n\n* (mostly) original code follows\n         YREGS\nWHEREIS  CSECT\nWHEREIS  AMODE 31\nWHEREIS  RMODE ANY\n         BAKR  14,0               Save regs, ARs, etc on linkage stack\n         LAE   12,0(15,0)         Base register\n         USING WHEREIS,12\n         B     INIT               Branch around constants\n         DC    CL9'WHEREIS '\n         DC    CL9'&SYSDATE'\n         DC    CL8'&SYSTIME'\n         SPACE\nINIT     EQU   *\n         LR    R10,R1\n         USING CPPL,R10\n         STORAGE OBTAIN,LENGTH=WORKL  Get Work Area Storage\n         LR    R11,R1             Address of storage\n         USING WORK,R11           Addressability\n         SPACE\n         LAE   13,SAVEAREA        Set up save area addr in AR/R13\n         MVC   4(4,13),=C'F1SA'   LS save indicator\n         SPACE\n         L     R3,CPPLCBUF        Get command buffer address\n         LH    R1,2(,R3)          Offset of operands\n         LA    R2,4(R1,R3)        Address of parm\n         LH    R4,0(,R3)          Length of parm\n         SH    R4,=H'4'\n         SH    R4,2(,R3)\n         MVC   XNAME(8),=CL8' '    Blank out field name\n         LA    R7,XNAME            Address of name field\n\n*---------------------------------------------------------------*\n*  Scan command buffer for member name parm and move it into the*\n*  BLDL parm list.                                              *\n*---------------------------------------------------------------*\nUSERLOOP EQU   *\n         CLI   0(R2),X'00'         end of parm?\n         BE    GOTUSER\n         CLI   0(R2),C' '          end of parm?\n         BE    GOTUSER\n         MVC   0(1,R7),0(R2)       Move in character\n         LA    R2,1(,R2)           Increment pointer\n         LA    R7,1(,R7)           Increment pointer\n         BCT   4,USERLOOP          Get next char of member name\nGOTUSER  EQU   *\n         OC    XNAME(8),=CL8' '    Convert to upper case\n         mvc   xmsg1(8),xname      move member name into msg\n\n*---------------------------------------------------------------*\n*  Issue BLDL to find out in which library the member is in     *\n*---------------------------------------------------------------*\n         LA    R5,XPARMS           Address of BLDL parms\n         BLDL  0,(5),NOCONNECT     Issue BLDL\n         LTR   R15,R15             BLDL worked?\n*        BNZ   ERROR               no ... issue error msg\n         bnz   testlpa             perhaps in lpa?\n\n*---------------------------------------------------------------*\n*  Interpret what is returned from BLDL                         *\n*---------------------------------------------------------------*\nPRIVATE  EQU   *\n         CLI   XLIBTYPE,X'00'      Private lib?\n         BNE   LINKLIB             No ... continue checking\n         mvlit XMSG1+22,'private library'  Move in msg\n         B     LibNum              Issue msg\nLINKLIB  EQU   *\n         CLI   XLIBTYPE,X'01'      Linklist dataset?\n         BNE   STEPLIB             No ... Continue checking\n         mvlit XMSG1+9,'in LINKLIB +'  Move in msg\n         B     LibNum              Issue msg\nSTEPLIB  EQU   *\n         CLI   XLIBTYPE,X'02'       STEPLIB ?\n         BNE   PARENT              No ... Check of STEPLIB of Parent\n         mvlit XMSG1+9,'in STEPLIB +'  Move in msg\n         B     LibNum              Issue msg\nPARENT   EQU   *\n         mvlit XMSG1+9,'in STEPLIB of parent n '  Move in msg\n         B     MESSAGE1            Issue msg\n\n*---------------------------------------------------------------*\n*  Figure out library module is in.                             *\n*---------------------------------------------------------------*\nLibNum   EQU   *\n         XR    R3,R3                Clear R3\n         IC    R3,XCONCAT           R3 = concat #\n*\n*        Make number printable\n* number conversion changed by Willy Jensen\n*        LA    1,0(,R3)\n*        SLL   1,4\n*        O     1,X'0000000F'\n*        ST    1,XWORK\n*        UNPK  XERROR(4),XWORK(4)\n*        LA    1,=XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n*        SH    1,=H'240'\n*        TR    XERROR(4),0(1)\n*        MVC   XMSG1+32(2),XERROR+2 Move in concat number\n         cvd   r3,dw\n         unpk  XMSG1+22(4),dw\n         oi    XMSG1+25,x'f0'\n         CLI   XLIBTYPE,X'02'       STEPLIB ?\n         BE    MESSAGE1             If in STEPLIB don't check LL concat\n         XR    R2,R2                Clear R2\n         M     R2,=F'45'            Length of each dataset in linklist\n         L     R4,16                Address of CVT (X'10')\n         USING CVT,R4               Get addressability\n         L     R5,X'4DC'(R4)\n         AR    R3,R5\n         mvc   xmsg1+28(44),9(r3)   get dsn name where member is\n         b     Message1             go tell\n\n*---------------------------------------------------------------------*\n*    Module might be in LPA                                           *\n*---------------------------------------------------------------------*\nTestLPA  cnop  0,4\n*\n* LOCATING MODULES IN THE LPA\n*\n* The first routine invokes an MVS function to locate a module\n* on the active LPA queue by searching the Contents Directory\n* Entry (CDE) chain.  This can be used to determine if a module\n* has been loaded into the MLPA or FLPA, or dynamically\n* loaded by a utility such as OMEGAMON, as well as retrieving\n* module information like load and entry points.  Register usage\n* is listed in the comments.  Note that the CDE search routine\n* returns to the address in register 14 if the module was found\n* and returns 4 bytes past the register 14 address if the module\n* was not found.  If the module was found, register 10 will\n* contain the address of the CDE.\n*\n***********************************************************************\n*        IEAQCDSR SCANS THE CONTENTS DIRECTORY FOR AN ENTRY           *\n*        REPRESENTING THE MODULE NAME REQUESTED BY THE CALLER         *\n*        REGS      ON ENTRY                  ON RETURN                *\n*        R0        IRRELEVANT                LEFT HALF MODULE NAME    *\n*        R1            \"                     RIGHT HALF MODULE NAME   *\n*        R2-R7         \"                     UNCHANGED                *\n*        R8        A(ACTIVE LPA QUEUE HDR)       \"                    *\n*        R9        A(SEARCH ARGUMENT)            \"                    *\n*        R10       IRRELEVANT                A(CDE-IF FOUND)          *\n*        R11-R13       \"                     UNCHANGED                *\n*        R14       A(RETURN POINT)              \"                     *\n*        R15       A(IEAQCDSR)               CHANGED (USED FOR BASE)  *\n*        ON EXIT, IF MODULE NOT FOUND, RETURNS TO THE CALLER 4 BYTES  *\n*        BEYOND THE RETURN ADDRESS INDICATED BY R14.                  *\n***********************************************************************\n         stm   r2,r12,28(r13)\n         L     R15,CVTPTR              LOAD A(CVT)\n         L     R8,CVTQLPAQ-CVT(,R15)   LOAD A(ACTIVE LPA QUEUE HEADER)\n         LA    R9,XNAME                -> NAME OF MODULE\n         L     R15,CVTQCDSR-CVT(,R15)  LOAD A(CDE SEARCH ROUTINE)\n         BALR  R14,R15                 INVOKE CDE SEARCH ROUTINE\n         B     LPA1OK                  +0 MODULE FOUND, END SEARCH\n         B     LPA1NOK                 +4 MODULE NOT FOUND\nLPA1OK   EQU   *\n         lm    r2,r12,28(r13)\n         mvlit xmsg1+9,'in LPA'\n         b     message1\nLPA1NOK  EQU   *\n         lm    r2,r12,28(r13)\n*\n* SEARCHING THE LPA DIRECTORY\n*\n* The following routine searches the LPA directory for the\n* existence of a module.  This Link Pack Directory Entry\n* (LPDE) search routine and the CDE search routine above can\n* be combined to locate the existence of a module in the MLPA,\n* FLPA, or PLPA.  It employs the same register 14 return\n* technique as the CDE search routine.  If the module is found,\n* register 0 will contain the address of the LPDE.\n*\n***********************************************************************\n*        IEAVVMSR SCANS THE LINK PACK DIRECTORY FOR AN ENTRY          *\n*        REPRESENTING THE MODULE NAME REQUESTED BY THE CALLER         *\n*        REGS         ON ENTRY                 ON RETURN              *\n*        R0           LEFT HALF MODULE NAME    A(LPDE-IF FOUND)       *\n*        R1           RIGHT HALF MODULE NAME   UNCHANGED              *\n*        R2           IRRELEVANT                   \"                  *\n*        R3           A(CVT)                       \"                  *\n*        R4-R5        IRRELEVANT                   \"                  *\n*        R6               \"                    CHANGED (USED AS BASE) *\n*        R7               \"                    UNCHANGED              *\n*        R8-R9            \"                    UNPREDICTABLE          *\n*        R10-R13          \"                    UNCHANGED              *\n*        R14          A(RETURN POINT)              \"                  *\n*        R15          A(IEAVVMSR)                  \"                  *\n*        ON EXIT, IF MODULE NOT FOUND, RETURNS TO THE CALLER 4 BYTES  *\n*        BEYOND THE RETURN ADDRESS INDICATED BY R14.                  *\n***********************************************************************\n         stm   r2,r12,28(r13)\n         L     R0,xname                LOAD 1ST HALF OF MODULE NAME\n         L     R1,xname+4              LOAD 2ND HALF OF MODULE NAME\n         L     R3,CVTPTR               LOAD A(CVT)\n         L     R15,CVTLPDSR-CVT(,R3)   LOAD A(LPDE SCAN ROUTINE)\n         BALR  R14,R15                 GO SEARCH FOR THE MODULE\n         B     LPA2OK                  +0 MODULE FOUND, END SEARCH\n         B     LPA2NOK                 +4 MODULE NOT FOUND\nLPA2OK   lm    r2,r12,28(r13)\n*        LR    R2,R0                   ESTABLISH ADDRESSABILITY\n*        USING LPDE,R2                   TO LPDE\n         mvlit xmsg1+9,'in LPADIR'\n         b     message1\nLPA2NOK  lm    r2,r12,28(r13)\n         mvlit xmsg1+9,'not found'\n         b     message1\n\n*---------------------------------------------------------------*\n*    Issue WTO tell where the module resides                    *\n*---------------------------------------------------------------*\nMESSAGE1 equ   *\n         tsoputln XMSG1\n         B     RETURN\n\n*---------------------------------------------------------------*\n*    Error Message processing                                   *\n*---------------------------------------------------------------*\nERROR    EQU   *\n         mvlit XMSG1+9,'Error During BLDL - Return Code '\n         LR    R3,R15\n*\n*        Make number printable\n* number conversion changed by Willy Jensen\n*\n*        LA    1,0(,R3)\n*        SLL   1,4\n*        O     1,X'0000000F'\n*        ST    1,XWORK\n*        UNPK  XERROR(4),XWORK(4)\n*        LA    1,=XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n*        SH    1,=H'240'\n*        TR    XERROR(4),0(1)\n         cvd   r3,dw\n         unpk  XMSG1+40(8),dw\n         oi    XMSG1+43,x'f0'\n         tsoputln XMSG1\n         B     RETURN\n\n*---------------------------------------------------------------*\n*    Return to Caller                                           *\n*---------------------------------------------------------------*\nRETURN   EQU   *\n         LR    R1,R11\n         STORAGE RELEASE,ADDR=(1),LENGTH=WORKL\n         SLR   R15,R15            rc = 0\n         PR                       Return\n\n*---------------------------------------------------------------*\n*    Data areas                                                 *\n*---------------------------------------------------------------*\nXCONNECT DS    CL8                Reserved 8 bytes for noconnect opt.\nXPARMS   DC    XL2'1'             Number of entries in list\nXLENGTH  DC    XL2'76'            Length of each entry\nXNAME    DS    CL8                Member to be located\nXTTR     DS    XL3                Relative track number and record\nXCONCAT  DS    XL1                Concat number of dataset\nXLIBTYPE DS    XL1                Where system found library\nXX       DC    76X'00'            User data filled in by BLDL\n         ltorg\nWORK     DSECT\nXMSG1    DS    CL80\nXWORK    DS    D                  Work field\nXERROR   DS    D                  Error field\ndw       DS    D                  work field\nfw       DS    f                  work field\nSAVEAREA DS    18F                Savearea\nWORKL    EQU   *-WORK\n         IKJCPPL\n         CVT   DSECT=YES\n         IHACDE ,                 User by testlpa\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WHEREIS$": {"ttr": 6152, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00A\\x01\\x07\"_\\x01\\x19\\x10/\\x11\\x14\\x00\\x1b\\x00\\x0e\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "2007-08-13T00:00:00", "modifydate": "2019-04-12T11:14:41", "lines": 27, "newlines": 14, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,RLD)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.CBT497.FILE836(WHEREIS)\n//SYSUT1   DD UNIT=SYSDA,SPACE=(CYL,20)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=SYSDA,SPACE=(TRK,30),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=(OLD,PASS),DSN=&&TEMP\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB\n ORDER   WHEREIS\n SETSSI  CB497836\n ENTRY   WHEREIS\n NAME    WHEREIS(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "WHEREIS#": {"ttr": 6154, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00F\\x01\\x19\\t\\x8f\\x01\\x19\\x10\\x1f\\x17!\\x00\\x1d\\x00\\x17\\x00\\x00\\xe6\\xd1\\xc5\\xd5\\xe2\\xc5\\xd5@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "2019-04-08T00:00:00", "modifydate": "2019-04-11T17:21:46", "lines": 29, "newlines": 23, "modlines": 0, "user": "WJENSEN"}, "text": "//WJWHRIS$ JOB (1),'WJENSEN',CLASS=A,MSGLEVEL=(1,1),MSGCLASS=T,\n//       TIME=NOLIMIT,REGION=64M,COND=(0,LT)\n//*\n//* ORG: AC7C7897 + Z5FFA270\n//*\n//    JCLLIB ORDER=WJENSEN.LIB.CNTL\n//    SET    LOADLIB=WJENSEN.LIB.LOADLIB\n//    SET    LOADLIB=&&LOADLIB\n//*\n//A   EXEC ASMACL,PARM.C='TERM',PARM.L='LIST,MAP'\n//C.SYSLIB  DD DISP=SHR,DSN=WJENSEN.CBT.FILE830\n//          DD DISP=SHR,DSN=SYS1.MACLIB\n//          DD DISP=SHR,DSN=SYS1.MODGEN\n//C.SYSTERM DD SYSOUT=*\n//C.SYSIN   DD DISP=SHR,DSN=WJENSEN.CBT.FILE830(WHEREIS)\n//*.SYSLMOD DD DISP=SHR,DSN=&LOADLIB(WHEREIS)\n//L.SYSLMOD DD DISP=(,PASS),DSN=&&LOADLIB(WHEREIS),\n//         SPACE=(TRK,(8,8,8)),DCB=(SYS1.LINKLIB)\n//*\n//IVP1     EXEC PGM=IKJEFT1B\n//STEPLIB  DD DISP=SHR,DSN=&LOADLIB\n//         DD DISP=SHR,DSN=WJENSEN.LIB.LOADLIB\n//SYSTSPRT DD SYSOUT=*,OUTLIM=(5000)\n//SYSTSIN  DD *\n WHEREIS WHEREIS\n WHEREIS IEFBR14\n WHEREIS REXXGBLV\n WHEREIS AHLTVTAM\n WHEREIS XYZMOD\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "WTOPROG": {"ttr": 6156, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00X\\x01\\x19\\x08\\x1f\\x01\\x19\\x08\\x8f\\x00!\\x01I\\x01H\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2019-03-22T00:00:00", "modifydate": "2019-03-29T00:21:58", "lines": 329, "newlines": 328, "modlines": 0, "user": "SBGOLOB"}, "text": "         TITLE 'WTO PROGRAM'\n         MACRO\n         MODE24\n         LA    R1,LAB&SYSNDX\n         BSM   R0,R1\nLAB&SYSNDX EQU  *\n         MEND\n         MACRO\n         MODE31\n         LCLA  &LABNUM\n&LABNUM  SETA  &SYSNDX+1\n         L     R1,LAB&SYSNDX\n         BSM   R0,R1\nLAB&SYSNDX DC  A(LBL&LABNUM+X'80000000')\nLBL&LABNUM EQU *\n         MEND\nYES      EQU   C'Y'                         YES TO CONTINUE\nREPLYLEN EQU   1                            REPLY LENGTH\nWTORLOOP EQU   3                            WTOR LOOP MAX\nPARMER   EQU   12                           PARM ERROR\nMESSNO   EQU   16                           NO MESSAGE\nWTOPROB  EQU   20                           WTOR PROBLEM\nJOBFND   EQU   X'01'                        JOB ALREADY LOCATED\nZERO     EQU   X'00'                        SET TO ZERO\nASID     EQU   X'01'                        SET TO ASID SCAN\nWTOR     EQU   X'02'                        ISSUE WTOR\nNOTINSYS EQU   X'04'                        CHECK ASIDS NOT IN SYSTEM\nMESSREAD EQU   X'08'                        MESSAGE HAS BEEN READ\nWTOPROG  CSECT\nWTOPROG  AMODE 31\nWTOPROG  RMODE 24\n         BAKR  R14,0                        SAVE CALLER'S ARS + GPRS\n*                                           IN THE LINKAGE STACK\n         LAE   R12,0(R15,0)                SET UP PROGRAM BASE REGISTER\nGETWORK  EQU   *\n         USING WTOPROG,R12                  INFORM THE ASSEMBLER\n         LR    R8,R1                        PARM @ OF @\n         STORAGE OBTAIN,LENGTH=WORKALEN,ADDR=(R10),SP=0,KEY=8,         X\n               LOC=BELOW,COND=NO,RELATED=(FREEWORK,'FREE WORK AREA')\n         LAE   R13,0(R10,0)                 @ THE WORKAREA\n         USING WORKAREA,R13                 INFORM THE ASSEMBLER\n         MVC   PREVSA,=C'F1SA'              PUT ACRONYM INTO SAVEAREA\n*                                           TO INDICATE STATUS SAVED ON\n*                                           THE LINKAGE STACK.\n         MVI   OPTION,ASID                  SET TO ASID SCAN\n         L     R8,0(,R8)                    PARM @\n         LH    R9,0(,R8)                    PARM LENGTH FIELD\n         LTR   R9,R9                        ANY PARM?\n         BZ    NOPARM                       NO- CHECK ASID'S\n         CH    R9,=H'1'                     1-BYTE PARM?\n         BNE   PARMERR                      NO- PARMERR\n         CLI   2(R8),C'M'                   CHECK ASIDS'S NOT IN SYS?\n         BE    MISSING                      NO- PARMERR\n         CLI   2(R8),C'W'                   WTOR TO ISSUE?\n         BNE   PARMERR                      NO- PARMERR\n         MVI   OPTION,WTOR                  SET TO WTOR SCAN\n         MVC   DDCB,DISKDCB                 SET UP MESSAGES DCB AREA\n         MVC   OPENARA3,OPENLST3            SET UP OPEN MACRO AREA\n         MVC   CLOSEARA,CLOSELST            SET UP CLOSE MACRO AREA\n         MVC   WTORARA(WTORLEN),WTORLIST    WTOR MACRO AREA\n         LA    R7,DDCB                      @ MESSAGE DCB\n         USING IHADCB,R7                    INFORM THE ASSEMBLER\n         LA    R1,OPENARA3                  @ THE OPEN AREA CB\n         OPEN  ((R7),INPUT),MODE=31,MF=(E,(R1))\n         TM    DCBOFLGS,DCBOFOPN            OPEN SUCCESSFUL?\n         BZ    OPENERR1                     NO- LET'S ABEND\n         B     WTOMESS                      GIVE OUT THE MESSAGE\nMISSING  EQU   *\n         MVI   OPTION,NOTINSYS              ASID MISSING CHECK\nNOPARM   EQU   *\n         MVC   DDCB,DISKDCB                 SET UP MESSAGES DCB AREA\n         MVC   JDCB,JOBNAME                 SET UP PARMLIB DCB AREA\n         MVC   OPENARA,OPENLST              SET UP OPEN MACRO AREA\n         MVC   OPENARA2,OPENLST2            SET UP OPEN MACRO AREA\n         MVC   CLOSEARA,CLOSELST            SET UP CLOSE MACRO AREA\n         MVC   WTORARA(WTORLEN),WTORLIST    WTOR MACRO AREA\n         TITLE 'OPEN MESSAGE DATASET'\nOPENMESS EQU   *\n         LA    R7,DDCB                      @ MESSAGE DCB\n         USING IHADCB,R7                    INFORM THE ASSEMBLER\n         LA    R9,JDCB                      @ PARMLIB DCB\n         LA    R1,OPENARA                   @ THE OPEN AREA CB\n         OPEN  ((R7),INPUT,(R9),INPUT),MODE=31,MF=(E,(R1))\n         TM    DCBOFLGS,DCBOFOPN            OPEN SUCCESSFUL?\n         BZ    OPENERR1                     NO- LET'S ABEND\n         DROP  R7                           INFORM THE ASSEMBLER\n         USING IHADCB,R9                    INFORM THE ASSEMBLER\n         TM    DCBOFLGS,DCBOFOPN            OPEN SUCCESSFUL?\n         BZ    OPENERR2                     NO- LET'S ABEND\n         TITLE 'OBTAIN THE PARMLIB INFO'\nJINIT    EQU   *\n         SR    R5,R5                        ZEROIZE\n         MODE24                             GET INTO AMODE 24\nJLOOP    EQU   *\n         GET   JDCB,JOBNME                  READ A JOBNAME\n         LA    R5,1(,R5)                    INCREMENT NO OF RECORDS\n         B     JLOOP                        DO WHILE NOT EOF?\n         TITLE 'CLOSE PARMLIB DATASET'\nJEOD     EQU   *\n         MODE31                             GET INTO AMODE 24\n         STCM  R5,B'1111',SYSINRCS          NO OF RECORDS READ\n         LTR   R5,R5                        ANY INPUT RECORDS?\n         BZ    WTOMESS                      NO- JUST ISSUE WTO\n         M     R4,=AL4(L'JNAME+L'JOBIND)    BUFFER LENGTH\n         STCM  R5,B'1111',IBUFLEN           STORE FOR SAFE KEEPING\n         LA    R1,CLOSEARA                  @ THE CLOSE AREA CB\n         CLOSE ((R9)),MODE=31,MF=(E,(R1))   CLOSE PARMLIB DATASET\n         LA    R1,OPENARA2                  @ THE OPEN AREA CB\n         OPEN  ((R9),INPUT),MODE=31,MF=(E,(R1))\n         STORAGE OBTAIN,LENGTH=(R5),ADDR=(R3),SP=0,KEY=8,              X\n               LOC=BELOW,COND=NO,RELATED=(FREEWORK,'FREE WORK AREA')\n         STCM  R3,B'1111',INPBUFF@          STORE FOR FUTURE REFERENCE\n         ICM   R5,B'1111',SYSINRCS          NO OF RECORDS TO READ\n         USING JOBDSECT,R3                  INFORM THE ASSEMBLER\nREADLOOP EQU  *\n         MODE24                             GET INTO AMODE 24\n         GET   JDCB,JOBNME                  READ A JOBNAME\n         MODE31                             GET INTO AMODE 31\n         MVC   JBNME,JNAME                  MOVE JOBNAME\n         MVI   JOBIND,ZERO                  SET TO ZERO\n         LA    R3,L'JBNME+L'JOBIND(,R3)     NEXT BUFFER ENTRY\n         BCT   R5,READLOOP                  DO WHILE R5 > 0?\n         LA    R1,CLOSEARA                  @ THE CLOSE AREA CB\n         CLOSE ((R9)),MODE=31,MF=(E,(R1))   CLOSE PARMLIB DATASET\nASIDSCAN EQU  *\n         L     R5,16(0,0)                   CVT @\n         USING CVT,R5                       INFORM THE ASSEMBLER\n         ICM   R5,B'1111',CVTASVT           ASVT @\n         USING ASVT,R5                      INFORM THE ASSEMBLER\n         ICM   R5,B'1111',ASVTMAXU          MAX NO OF ASID SLOTS\n         LA    R10,1(0,0)                   START WITH *MASTER*\nASIDLOOP EQU   *\n         LOCASCB ASID=(R10)                 OBTAIN ASCB @\n         LTR   R15,R15                      ASID IN USE?\n         BNZ   NEXTASID                     NO-\n         USING ASCB,R1                      INFORM THE ASSEMBLER\n         CLC   ASCBJBNI,=F'0'               STC?\n         BE    STC                          YES-\n         ICM   R11,B'1111',ASCBJBNI         BATCH JOB UNDER INIT\n         B     COMPJBN                      COMPARE FOR JOBNAMES\nSTC      EQU   *\n         ICM   R11,B'1111',ASCBJBNS         STC NO INIT\n         B     COMPJBN                      COMPARE FOR JOBNAMES\nCOMPJBN  EQU   *\n         ICM   R3,B'1111',INPBUFF@          INPUT BUFFER @\n         ICM   R4,B'1111',SYSINRCS          NO OF RECORDS TO SCAN\nJOBCLOOP EQU   *\n         TM    JOBIND,JOBFND                JOB ALREADY LOCATED\n         BO    NEXTJOB                      NEXT ASID\n         CLC   JBNME,0(R11)                 = JOBNAMES?\n         BNE   NEXTJOB                      NO-\n         OI    JOBIND,JOBFND                INDICATE JOB FOUND\n         B     NEXTASID                     NEXT ASID\nNEXTJOB  EQU   *\n         LA    R3,L'JBNME+L'JOBIND(,R3)     NEXT BUFFER ENTRY\n         BCT   R4,JOBCLOOP                  DO WHILE R4 > 0?\nNEXTASID EQU   *\n         LA    R10,1(,R10)                  NEXT ASID\n         BCT   R5,ASIDLOOP                  DO WHILE R5 > 0?\nCHKINDS  EQU   *\n         ICM   R3,B'1111',INPBUFF@          INPUT BUFFER @\n         ICM   R4,B'1111',SYSINRCS          NO OF RECORDS TO SCAN\nINDCHECK EQU   *\n         TM    OPTION,ASID                  JOB ACTIVE CHECK?\n         BO    CHKACTVE                     NO-\n         CLI   JOBIND,ZERO                  JOB ACTIVE?\n         BE    NXTJOB                       NO-\n         B     WTOMESS                      YES- ISSUE WTO\nCHKACTVE EQU   *\n         TM    JOBIND,JOBFND                JOB ACTIVE?\n         BNO   WTOMESS                      NO-\nNXTJOB   EQU   *\n         LA    R3,L'JBNME+L'JOBIND(,R3)     NEXT BUFFER ENTRY\n         BCT   R4,INDCHECK                  DO WHILE R4 > 0?\n         BAL   R2,CLOSE                     CLOSE FILES\n         B     RETURN                       RETURN TO CALLER\n         TITLE 'OBTAIN THE MESSAGE'\nWTOMESS  EQU   *\n         TM    OPTION,MESSREAD              IS THE MESSAGE IN THE\n*                                           I/O AREA?\n         BO    WTORMAX                      YES-\n         MODE24                             GET INTO AMODE 24\n         GET   DDCB,MESSAGE                 READ A MESSAGE\n         MODE31                             GET INTO AMODE 31\n         LA    R6,MESSARA+L'MESSARA-1       @ LAST BYTE OF MESSAGE\n         LA    R7,L'MESSAGE                 LENGTH OF MESSAGE\n         OI    OPTION,MESSREAD              INDICATE MESSAGE ISSUED\nMESSSCAN EQU   *\n         CLI   0(R6),C' '                   END OF MESSAGE?\n         BNE   WTORMAX                      YES-\n         BCTR  R6,0                         -1\n         BCT   R7,MESSSCAN                  DO WHILE R7 > 0?\nWTORMAX  EQU   *\n         LA    R8,WTORLOOP                  MAX TIMES TO ISSUE WTOR\n         MVC   WTORARA(WTORLEN),WTORLIST    WTOR AREA\nENDMESS  EQU   *\n         XC    REPLYECB,REPLYECB            CLEAR THE ECB\n         XC    REPLY,REPLY                  CLEAR THE REPLY\n         STCM  R7,B'0011',MESSLEN           MESSAGE LENGTH\n         MVC   TOKENDOM,=CL4'ACE3'          DOM TOKEN\n         MVC   KEYID,=CL8'ACE3'             KEY\nWTORMESS EQU   *\n         WTOR  TEXT=(MESSARA,REPLY,REPLYLEN,REPLYECB),                 X\n               RPLYISUR=RISUR,KEY=KEYID,TOKEN=TOKENDOM,                X\n               MF=(E,WTORARA,EXTENDED)\n         LTR   R15,R15                      SUCCESSFUL WTOR?\n         BZ    WAITRPLY                    YES- LET'S WAIT FOR A REPLY?\n         BCT   R8,ENDMESS                   DO WHILE R8 > 0?\n         B     WTORERR                      LET'S GIVE UP\nWAITRPLY EQU   *\n         WAIT  ECB=REPLYECB                 LET'S WAIT A BIT?\n         CLI   REPLY,YES                    CAN WE PROCEED?\n         BNE   WTORMAX                      NO- IT'S ONLY 1 CHARACTER\n         TM    OPTION,WTOR                  WTOR OPTION?\n         BNO   REINIT                       NO-\n         BAL   R2,CLOSE                     LET'S CLOSE THE FILE\n         B     RETURN                       AND LET THE NEXT STEPS RUN\nREINIT   EQU   *\n         ICM   R3,B'1111',INPBUFF@          INPUT BUFFER @\n         ICM   R4,B'1111',SYSINRCS          NO OF RECORDS TO SCAN\nRESET    EQU   *\n         MVI   JOBIND,ZERO                  RESET INDICATOR\n         LA    R3,L'JBNME+L'JOBIND(,R3)     NEXT BUFFER ENTRY\n         BCT   R4,RESET                     DO WHILE R4 > 0?\n         B     ASIDSCAN                     KEEP CHECKING\n         TITLE 'CLOSE MESSAGE DATASET'\nCLOSE    EQU   *\n         LA    R1,CLOSEARA                  @ THE OPEN AREA CB\n         LA    R7,DISKDCB                   ADDR OF DCB BEFORE CLOSE\n         CLOSE ((R7)),MODE=31,MF=(E,(R1))   CLOSE DISK DATASET\n         BR    R2                           RETURN TO CALLER\n         TITLE 'LETS RETURN TO THE INITIATOR'\nRETURN   EQU   *\n         LAE   R1,0(R13,0)                  ADDRESS TO FREE\n         STORAGE RELEASE,ADDR=(R1),LENGTH=WORKALEN,SP=0,KEY=8,         X\n               COND=NO,RELATED=(GETWORK,'OBTAIN WORK AREA')\n         SLR   R15,R15                      SET RC TO ZERO\n         PR                                 RESTORE CALLER'S AR'S\n*                                           GPR'S 2-14 AND RETURN\n*                                           TO CALLER\n         TITLE 'ERROR SECTION'\nOPENERR1 EQU   *\n         ABEND 001,DUMP                     OPEN ERROR MESSAGES\nOPENERR2 EQU   *\n         ABEND 002,DUMP                     OPEN ERROR PARMLIB\nNOMESS   EQU   *\n         BAS   R2,CLOSE                     CLOSE DATASET\n         LAE   R1,0(R13,0)                  ADDRESS TO FREE\n         STORAGE RELEASE,ADDR=(R1),LENGTH=WORKALEN,SP=0,KEY=8,         X\n               COND=NO,RELATED=(GETWORK,'OBTAIN WORK AREA')\n         LA    R15,MESSNO                   SET RC TO NO MESSAGE\n         PR                                 RESTORE CALLER'S AR'S\n*                                           GPR'S 2-14 AND RETURN\n*                                           TO CALLER\nWTORERR  EQU   *\n         BAS   R2,CLOSE                     CLOSE DATASET\n         LAE   R1,0(R13,0)                  ADDRESS TO FREE\n         STORAGE RELEASE,ADDR=(R1),LENGTH=WORKALEN,SP=0,KEY=8,         X\n               COND=NO,RELATED=(GETWORK,'OBTAIN WORK AREA')\n         LA    R15,WTOPROB                  SET RC TO WTO PROBLEM\n         PR                                 RESTORE CALLER'S AR'S\n*                                           GPR'S 2-14 AND RETURN\n*                                           TO CALLER\nPARMERR  EQU   *\n         LAE   R1,0(R13,0)                  ADDRESS TO FREE\n         STORAGE RELEASE,ADDR=(R1),LENGTH=WORKALEN,SP=0,KEY=8,         X\n               COND=NO,RELATED=(GETWORK,'OBTAIN WORK AREA')\n         LA    R15,PARMER                   SET RC TO PARM ERROR\n         PR                                 RESTORE CALLER'S AR'S\n*                                           GPR'S 2-14 AND RETURN\n*                                           TO CALLER\n         LTORG\nDISKDCB  DCB   DDNAME=MESSAGES,DSORG=PS,MACRF=GM,EODAD=NOMESS\nDDCBLEN  EQU *-DISKDCB                      DCB  MACRO LENGTH\nJOBNAME  DCB   DDNAME=PARMLIB,DSORG=PS,MACRF=GM,EODAD=JEOD\nJDCBLEN  EQU *-JOBNAME                      DCB  MACRO LENGTH\nOPENLST  OPEN  (,,,),MF=L,MODE=31\nOPENLEN  EQU *-OPENLST                      OPEN MACRO LENGTH\nOPENLST2 OPEN  (,),MF=L,MODE=31\nOPENLEN2 EQU *-OPENLST2                     OPEN MACRO LENGTH\nOPENLST3 OPEN  (,),MF=L,MODE=31\nOPENLEN3 EQU *-OPENLST3                     OPEN MACRO LENGTH\nCLOSELST CLOSE (,),MF=L,MODE=31\nCLOSELEN EQU *-CLOSELST                     OPEN MACRO LENGTH\nWTORLIST WTOR  TEXT=(,,,),ROUTCDE=(2),RPLYISUR=,KEY=,TOKEN=,MF=L\nWTORLEN  EQU *-WTORLIST                     WTOR LIST LENGTH\nWORKAREA DSECT\nSAVEAREA DS    CL72                         SAVEAREA\nPREVSA   EQU   SAVEAREA+4,4                 @ OF PREVIOUS SAVEAREA\nOPTION   DS    X                            OPTION BYTE\n         DS    0F                           ALIGNMENT\nRISUR    DS    CL12                         CONSOLE NAME AND ID\nKEYID    DS    CL8                           USEFUL WITH D R COMMAND\nTOKENDOM DS    CL4                           TOKEN FOR DOM MACRO\nREPLYECB DS    F                             REPLY ECB\nREPLY    DS    C                             REPLY AREA\n         DS    0F                            ALIGNMENT\nSYSINRCS DS    AL4                           NO OF SYSIN RECORDS READ\nINPBUFF@ DS    AL4                           SYSIN BUFFER @\nIBUFLEN  DS    AL4                           BUFFER LENGTH\n         DS    0F                            ALIGNMENT\nDDCB     DS    CL(DDCBLEN)                   DISK DCB AREA\n         DS    0F                            ALIGNMENT\nJDCB     DS    CL(JDCBLEN)                   DISK DCB AREA\n         DS    0F                            ALIGNMENT\nOPENARA  DS    CL(OPENLEN)                   OPEN AREA\n         DS    0F                            ALIGNMENT\nOPENARA2 DS    CL(OPENLEN2)                  OPEN AREA\n         DS    0F                            ALIGNMENT\nOPENARA3 DS    CL(OPENLEN3)                  OPEN AREA\n         DS    0F                            ALIGNMENT\nCLOSEARA DS    CL(CLOSELEN)                  CLOSE AREA\n         DS    0F                            ALIGNMENT\nWTORARA  DS    CL(WTORLEN)                   WTOR AREA\nMESSARA  DS    0CL102                        MAXIMUM MESSAGE AREA\nMESSLEN  DS    XL2                           MESSAGE LENGTH\nMESSAGE  DS    CL100                         MAXIMUM MESSAGE\nJOBNME   DS    CL80                          JOBNAME AREA\nJNAME    EQU   JOBNME,8                      JOBNAME\nWORKALEN EQU   *-WORKAREA                    WORK AREA LENGTH\nJOBDSECT DSECT\nJBNME    DS    CL8                           JOBNAME\nJOBIND   DS    XL1                           JOB FOUND INDICATOR\n         DCBD  DSORG=PS,DEVD=DA\n         CVT   DSECT=YES\n         IHAASCB DSECT=YES\n         IHAASVT DSECT=YES\n         YREGS\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "WTOPROG$": {"ttr": 6405, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x10\\x01\\x19\\x07\\x8f\\x01\\x19\\x08\\x8f\\x02#\\x00\\x1a\\x00\\x1a\\x00\\x00\\xc1\\xe2\\xd4\\xd3\\xd1\\xc3\\xd3@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2019-03-19T00:00:00", "modifydate": "2019-03-29T02:23:10", "lines": 26, "newlines": 26, "modlines": 0, "user": "ASMLJCL"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,RLD)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.CBT497.FILE836(WTOPROG)\n//SYSUT1   DD UNIT=SYSDA,SPACE=(CYL,20)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=SYSDA,SPACE=(TRK,30),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=(OLD,PASS),DSN=&&TEMP\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB\n SETSSI  CB497836\n ENTRY   WTOPROG\n NAME    WTOPROG(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "WTOPROG#": {"ttr": 6407, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00$\\x01\\x19\\x08\\x9f\\x01\\x19\\x08\\x9f\"\\x06\\x00c\\x00c\\x00\\x00\\xc8\\xc5\\xd3\\xd7@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-03-30T00:00:00", "modifydate": "2019-03-30T22:06:24", "lines": 99, "newlines": 99, "modlines": 0, "user": "HELP"}, "text": "A multi-function WTO program\n\nINTRODUCTION\n\nIt is sometimes a requirement that certain steps of a job should not\nexecute without specific address spaces (ie subsystems) being\neither active or not active in the system. WTOPROG is a utility\nprogram that addresses these problems. In addition, it provides a\ngeneralized facility for issuing WTOR messages to the system\nconsole. WTOPROG has three options.\n\nOPTION ONE\n\nThis option checks that the user-specified address spaces are\nactive in the system. If any address spaces are not active, a WTOR\nmessage is issued to the system console awaiting an affirmative\nreply from the operator - it is assumed that the operator will start\nthe required address space(s). If all address spaces are active, a\nzero return code is set and the next step executes. The following\nJCL needs to be inserted before the required step:\n\n//ACTIVE   EXEC PGM=WTOPROG\n//STEPLIB  DD   DSN=wtoprog.loadlib,DISP=SHR\n//SYSPRINT DD   SYSOUT=*\n//SYSUDUMP DD   SYSOUT=*\n//MESSAGES DD   DSN=wtoprog.message,DISP=SHR\n//PARMLIB  DD   DSN=wtoprog.parmlib,DISP=SHR\n\nRefer to the dataset attributes definition below for the definitions\nof the MESSAGES and PARMLIB datasets.\n\nOPTION TWO\n\nThis option checks that the user-specified address spaces are not\nactive in the system. If any address spaces are found to be active, a\nWTOR message is issued to the system console awaiting an\naffirmative reply from the operator - it is assumed that the\noperator will stop the required address space(s). If all address\nspaces are inactive, a zero return code is set and the next step\nexecutes. The following JCL needs to be inserted before the\nrequired step:\n\n//INACTIVE EXEC PGM=WTOPROG,PARM='M'\n//STEPLIB  DD   DSN=wtoprog.loadlib,DISP=SHR\n//SYSPRINT DD   SYSOUT=*\n//SYSUDUMP DD   SYSOUT=*\n//MESSAGES DD   DSN=wtoprog.message,DISP=SHR\n//PARMLIB  DD   DSN=wtoprog.parmlib,DISP=SHR\n\nOPTION THREE\n\nThis option is a generalized facility for issuing WTOR messages\nto the system console and then waiting for an affirmative reply\nfrom the operator - it is assumed that the operator has been\nrequested to perform a particular task. The following JCL is\nrequired.\n\n//INACTIVE EXEC PGM=WTOPROG,PARM='W'\n//STEPLIB  DD   DSN=wtoprog.loadlib,DISP=SHR\n//SYSPRINT DD   SYSOUT=*\n//SYSUDUMP DD   SYSOUT=*\n//MESSAGES DD   DSN=wtoprog.message,DISP=SHR\n\nREQUIRED DATASETS AND THEIR ATTRIBUTES\n\nMESSAGES DD card\n\nThis dataset contains the WTOR message. It must be a single\nrecord, up to 100 characters in length, contained in a sequential\ndataset or a member of a PDS.\n\nPARMLIB DD card\n\nThis dataset contains the names of the address spaces that need to\nbe active or inactive in the system. Any number of records can be\nspecified in a sequential dataset or member in a PDS. Address\nspace names are specified in columns 1 to 8 of an 80-byte record\nwith trailing blanks.\n\nRETURN CODES\n\nWTOR will issue the following return codes:\n\n0      Successful\n\n12      PARM field error\n\n16      No record in the MESSAGE dataset\n\n20      Error issuing the WTOR message.\n\nABEND CODES\n\nWTOR will issue the following abend codes:\n\n001      Open error (MESSAGES dataset)\n\n002      Open error (PARMLIB dataset).\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "WTOPROGA": {"ttr": 6410, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00B\\x01\\x10 o\\x01\\x19\\x08\\x9f!R\\x01\\xb3\\x01\\xb1\\x00\\x00\\xc1\\xd9\\xe3\\xc9\\xc3\\xd3\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2010-07-25T00:00:00", "modifydate": "2019-03-30T21:52:42", "lines": 435, "newlines": 433, "modlines": 0, "user": "ARTICLE"}, "text": "A multi-function WTO program\n\nINTRODUCTION\n\nIt is sometimes a requirement that certain steps of a job should not\nexecute without specific address spaces (ie subsystems) being\neither active or not active in the system. WTOPROG is a utility\nprogram that addresses these problems. In addition, it provides a\ngeneralized facility for issuing WTOR messages to the system\nconsole. WTOPROG has three options.\n\nOPTION ONE\n\nThis option checks that the user-specified address spaces are\nactive in the system. If any address spaces are not active, a WTOR\nmessage is issued to the system console awaiting an affirmative\nreply from the operator - it is assumed that the operator will start\nthe required address space(s). If all address spaces are active, a\nzero return code is set and the next step executes. The following\nJCL needs to be inserted before the required step:\n\n//ACTIVE   EXEC PGM=WTOPROG\n//STEPLIB  DD   DSN=wtoprog.loadlib,DISP=SHR\n//SYSPRINT DD   SYSOUT=*\n//SYSUDUMP DD   SYSOUT=*\n//MESSAGES DD   DSN=wtoprog.message,DISP=SHR\n//PARMLIB  DD   DSN=wtoprog.parmlib,DISP=SHR\n\nRefer to the dataset attributes definition below for the definitions\nof the MESSAGES and PARMLIB datasets.\n\nOPTION TWO\n\nThis option checks that the user-specified address spaces are not\nactive in the system. If any address spaces are found to be active, a\nWTOR message is issued to the system console awaiting an\naffirmative reply from the operator - it is assumed that the\noperator will stop the required address space(s). If all address\nspaces are inactive, a zero return code is set and the next step\nexecutes. The following JCL needs to be inserted before the\nrequired step:\n\n//INACTIVE EXEC PGM=WTOPROG,PARM='M'\n//STEPLIB  DD   DSN=wtoprog.loadlib,DISP=SHR\n//SYSPRINT DD   SYSOUT=*\n//SYSUDUMP DD   SYSOUT=*\n//MESSAGES DD   DSN=wtoprog.message,DISP=SHR\n//PARMLIB  DD   DSN=wtoprog.parmlib,DISP=SHR\n\nOPTION THREE\n\nThis option is a generalized facility for issuing WTOR messages\nto the system console and then waiting for an affirmative reply\nfrom the operator - it is assumed that the operator has been\nrequested to perform a particular task. The following JCL is\nrequired.\n\n//INACTIVE EXEC PGM=WTOPROG,PARM='W'\n//STEPLIB  DD   DSN=wtoprog.loadlib,DISP=SHR\n//SYSPRINT DD   SYSOUT=*\n//SYSUDUMP DD   SYSOUT=*\n//MESSAGES DD   DSN=wtoprog.message,DISP=SHR\n\nREQUIRED DATASETS AND THEIR ATTRIBUTES\n\nMESSAGES DD card\n\nThis dataset contains the WTOR message. It must be a single\nrecord, up to 100 characters in length, contained in a sequential\ndataset or a member of a PDS.\n\nPARMLIB DD card\n\nThis dataset contains the names of the address spaces that need to\nbe active or inactive in the system. Any number of records can be\nspecified in a sequential dataset or member in a PDS. Address\nspace names are specified in columns 1 to 8 of an 80-byte record\nwith trailing blanks.\n\nRETURN CODES\n\nWTOR will issue the following return codes:\n\n0      Successful\n\n12      PARM field error\n\n16      No record in the MESSAGE dataset\n\n20      Error issuing the WTOR message.\n\nABEND CODES\n\nWTOR will issue the following abend codes:\n\n001      Open error (MESSAGES dataset)\n\n002      Open error (PARMLIB dataset).\n\nWTOPROG SOURCE CODE\n\n         TITLE 'WTO PROGRAM'\n         MACRO\n         MODE24\n         LA    R1,LAB&SYSNDX\n         BSM   R0,R1\nLAB&SYSNDX EQU  *\n         MEND\n         MACRO\n         MODE31\n         LCLA  &LABNUM\n&LABNUM  SETA  &SYSNDX+1\n         L     R1,LAB&SYSNDX\n         BSM   R0,R1\nLAB&SYSNDX DC  A(LBL&LABNUM+X'80000000')\nLBL&LABNUM EQU *\n         MEND\nYES      EQU   C'Y'                         YES TO CONTINUE\nREPLYLEN EQU   1                            REPLY LENGTH\nWTORLOOP EQU   3                            WTOR LOOP MAX\nPARMER   EQU   12                           PARM ERROR\nMESSNO   EQU   16                           NO MESSAGE\nWTOPROB  EQU   20                           WTOR PROBLEM\nJOBFND   EQU   X'01'                        JOB ALREADY LOCATED\nZERO     EQU   X'00'                        SET TO ZERO\nASID     EQU   X'01'                        SET TO ASID SCAN\nWTOR     EQU   X'02'                        ISSUE WTOR\nNOTINSYS EQU   X'04'                        CHECK ASIDS NOT IN SYSTEM\nMESSREAD EQU   X'08'                        MESSAGE HAS BEEN READ\nWTOPROG  CSECT\nWTOPROG  AMODE 31\nWTOPROG  RMODE 24\n         BAKR  R14,0                        SAVE CALLER'S ARS + GPRS\n*                                           IN THE LINKAGE STACK\n         LAE   R12,0(R15,0)                SET UP PROGRAM BASE REGISTER\nGETWORK  EQU   *\n         USING WTOPROG,R12                  INFORM THE ASSEMBLER\n         LR    R8,R1                        PARM @ OF @\n         STORAGE OBTAIN,LENGTH=WORKALEN,ADDR=(R10),SP=0,KEY=8,         X\n               LOC=BELOW,COND=NO,RELATED=(FREEWORK,'FREE WORK AREA')\n         LAE   R13,0(R10,0)                 @ THE WORKAREA\n         USING WORKAREA,R13                 INFORM THE ASSEMBLER\n         MVC   PREVSA,=C'F1SA'              PUT ACRONYM INTO SAVEAREA\n*                                           TO INDICATE STATUS SAVED ON\n*                                           THE LINKAGE STACK.\n         MVI   OPTION,ASID                  SET TO ASID SCAN\n         L     R8,0(,R8)                    PARM @\n         LH    R9,0(,R8)                    PARM LENGTH FIELD\n         LTR   R9,R9                        ANY PARM?\n         BZ    NOPARM                       NO- CHECK ASID'S\n         CH    R9,=H'1'                     1-BYTE PARM?\n         BNE   PARMERR                      NO- PARMERR\n         CLI   2(R8),C'M'                   CHECK ASIDS'S NOT IN SYS?\n         BE    MISSING                      NO- PARMERR\n         CLI   2(R8),C'W'                   WTOR TO ISSUE?\n         BNE   PARMERR                      NO- PARMERR\n         MVI   OPTION,WTOR                  SET TO WTOR SCAN\n         MVC   DDCB,DISKDCB                 SET UP MESSAGES DCB AREA\n         MVC   OPENARA3,OPENLST3            SET UP OPEN MACRO AREA\n         MVC   CLOSEARA,CLOSELST            SET UP CLOSE MACRO AREA\n         MVC   WTORARA(WTORLEN),WTORLIST    WTOR MACRO AREA\n         LA    R7,DDCB                      @ MESSAGE DCB\n         USING IHADCB,R7                    INFORM THE ASSEMBLER\n         LA    R1,OPENARA3                  @ THE OPEN AREA CB\n         OPEN  ((R7),INPUT),MODE=31,MF=(E,(R1))\n         TM    DCBOFLGS,DCBOFOPN            OPEN SUCCESSFUL?\n         BZ    OPENERR1                     NO- LET'S ABEND\n         B     WTOMESS                      GIVE OUT THE MESSAGE\nMISSING  EQU   *\n         MVI   OPTION,NOTINSYS              ASID MISSING CHECK\nNOPARM   EQU   *\n         MVC   DDCB,DISKDCB                 SET UP MESSAGES DCB AREA\n         MVC   JDCB,JOBNAME                 SET UP PARMLIB DCB AREA\n         MVC   OPENARA,OPENLST              SET UP OPEN MACRO AREA\n         MVC   OPENARA2,OPENLST2            SET UP OPEN MACRO AREA\n         MVC   CLOSEARA,CLOSELST            SET UP CLOSE MACRO AREA\n         MVC   WTORARA(WTORLEN),WTORLIST    WTOR MACRO AREA\n         TITLE 'OPEN MESSAGE DATASET'\nOPENMESS EQU   *\n         LA    R7,DDCB                      @ MESSAGE DCB\n         USING IHADCB,R7                    INFORM THE ASSEMBLER\n         LA    R9,JDCB                      @ PARMLIB DCB\n         LA    R1,OPENARA                   @ THE OPEN AREA CB\n         OPEN  ((R7),INPUT,(R9),INPUT),MODE=31,MF=(E,(R1))\n         TM    DCBOFLGS,DCBOFOPN            OPEN SUCCESSFUL?\n         BZ    OPENERR1                     NO- LET'S ABEND\n         DROP  R7                           INFORM THE ASSEMBLER\n         USING IHADCB,R9                    INFORM THE ASSEMBLER\n         TM    DCBOFLGS,DCBOFOPN            OPEN SUCCESSFUL?\n         BZ    OPENERR2                     NO- LET'S ABEND\n         TITLE 'OBTAIN THE PARMLIB INFO'\nJINIT    EQU   *\n         SR    R5,R5                        ZEROIZE\n         MODE24                             GET INTO AMODE 24\nJLOOP    EQU   *\n         GET   JDCB,JOBNME                  READ A JOBNAME\n         LA    R5,1(,R5)                    INCREMENT NO OF RECORDS\n         B     JLOOP                        DO WHILE NOT EOF?\n         TITLE 'CLOSE PARMLIB DATASET'\nJEOD     EQU   *\n         MODE31                             GET INTO AMODE 24\n         STCM  R5,B'1111',SYSINRCS          NO OF RECORDS READ\n         LTR   R5,R5                        ANY INPUT RECORDS?\n         BZ    WTOMESS                      NO- JUST ISSUE WTO\n         M     R4,=AL4(L'JNAME+L'JOBIND)    BUFFER LENGTH\n         STCM  R5,B'1111',IBUFLEN           STORE FOR SAFE KEEPING\n         LA    R1,CLOSEARA                  @ THE CLOSE AREA CB\n         CLOSE ((R9)),MODE=31,MF=(E,(R1))   CLOSE PARMLIB DATASET\n         LA    R1,OPENARA2                  @ THE OPEN AREA CB\n         OPEN  ((R9),INPUT),MODE=31,MF=(E,(R1))\n         STORAGE OBTAIN,LENGTH=(R5),ADDR=(R3),SP=0,KEY=8,              X\n               LOC=BELOW,COND=NO,RELATED=(FREEWORK,'FREE WORK AREA')\n         STCM  R3,B'1111',INPBUFF@          STORE FOR FUTURE REFERENCE\n         ICM   R5,B'1111',SYSINRCS          NO OF RECORDS TO READ\n         USING JOBDSECT,R3                  INFORM THE ASSEMBLER\nREADLOOP EQU  *\n         MODE24                             GET INTO AMODE 24\n         GET   JDCB,JOBNME                  READ A JOBNAME\n         MODE31                             GET INTO AMODE 31\n         MVC   JBNME,JNAME                  MOVE JOBNAME\n         MVI   JOBIND,ZERO                  SET TO ZERO\n         LA    R3,L'JBNME+L'JOBIND(,R3)     NEXT BUFFER ENTRY\n         BCT   R5,READLOOP                  DO WHILE R5 > 0?\n         LA    R1,CLOSEARA                  @ THE CLOSE AREA CB\n         CLOSE ((R9)),MODE=31,MF=(E,(R1))   CLOSE PARMLIB DATASET\nASIDSCAN EQU  *\n         L     R5,16(0,0)                   CVT @\n         USING CVT,R5                       INFORM THE ASSEMBLER\n         ICM   R5,B'1111',CVTASVT           ASVT @\n         USING ASVT,R5                      INFORM THE ASSEMBLER\n         ICM   R5,B'1111',ASVTMAXU          MAX NO OF ASID SLOTS\n         LA    R10,1(0,0)                   START WITH *MASTER*\nASIDLOOP EQU   *\n         LOCASCB ASID=(R10)                 OBTAIN ASCB @\n         LTR   R15,R15                      ASID IN USE?\n         BNZ   NEXTASID                     NO-\n         USING ASCB,R1                      INFORM THE ASSEMBLER\n         CLC   ASCBJBNI,=F'0'               STC?\n         BE    STC                          YES-\n         ICM   R11,B'1111',ASCBJBNI         BATCH JOB UNDER INIT\n         B     COMPJBN                      COMPARE FOR JOBNAMES\nSTC      EQU   *\n         ICM   R11,B'1111',ASCBJBNS         STC NO INIT\n         B     COMPJBN                      COMPARE FOR JOBNAMES\nCOMPJBN  EQU   *\n         ICM   R3,B'1111',INPBUFF@          INPUT BUFFER @\n         ICM   R4,B'1111',SYSINRCS          NO OF RECORDS TO SCAN\nJOBCLOOP EQU   *\n         TM    JOBIND,JOBFND                JOB ALREADY LOCATED\n         BO    NEXTJOB                      NEXT ASID\n         CLC   JBNME,0(R11)                 = JOBNAMES?\n         BNE   NEXTJOB                      NO-\n         OI    JOBIND,JOBFND                INDICATE JOB FOUND\n         B     NEXTASID                     NEXT ASID\nNEXTJOB  EQU   *\n         LA    R3,L'JBNME+L'JOBIND(,R3)     NEXT BUFFER ENTRY\n         BCT   R4,JOBCLOOP                  DO WHILE R4 > 0?\nNEXTASID EQU   *\n         LA    R10,1(,R10)                  NEXT ASID\n         BCT   R5,ASIDLOOP                  DO WHILE R5 > 0?\nCHKINDS  EQU   *\n         ICM   R3,B'1111',INPBUFF@          INPUT BUFFER @\n         ICM   R4,B'1111',SYSINRCS          NO OF RECORDS TO SCAN\nINDCHECK EQU   *\n         TM    OPTION,ASID                  JOB ACTIVE CHECK?\n         BO    CHKACTVE                     NO-\n         CLI   JOBIND,ZERO                  JOB ACTIVE?\n         BE    NXTJOB                       NO-\n         B     WTOMESS                      YES- ISSUE WTO\nCHKACTVE EQU   *\n         TM    JOBIND,JOBFND                JOB ACTIVE?\n         BNO   WTOMESS                      NO-\nNXTJOB   EQU   *\n         LA    R3,L'JBNME+L'JOBIND(,R3)     NEXT BUFFER ENTRY\n         BCT   R4,INDCHECK                  DO WHILE R4 > 0?\n         BAL   R2,CLOSE                     CLOSE FILES\n         B     RETURN                       RETURN TO CALLER\n         TITLE 'OBTAIN THE MESSAGE'\nWTOMESS  EQU   *\n         TM    OPTION,MESSREAD              IS THE MESSAGE IN THE\n*                                           I/O AREA?\n         BO    WTORMAX                      YES-\n         MODE24                             GET INTO AMODE 24\n         GET   DDCB,MESSAGE                 READ A MESSAGE\n         MODE31                             GET INTO AMODE 31\n         LA    R6,MESSARA+L'MESSARA-1       @ LAST BYTE OF MESSAGE\n         LA    R7,L'MESSAGE                 LENGTH OF MESSAGE\n         OI    OPTION,MESSREAD              INDICATE MESSAGE ISSUED\nMESSSCAN EQU   *\n         CLI   0(R6),C' '                   END OF MESSAGE?\n         BNE   WTORMAX                      YES-\n         BCTR  R6,0                         -1\n         BCT   R7,MESSSCAN                  DO WHILE R7 > 0?\nWTORMAX  EQU   *\n         LA    R8,WTORLOOP                  MAX TIMES TO ISSUE WTOR\n         MVC   WTORARA(WTORLEN),WTORLIST    WTOR AREA\nENDMESS  EQU   *\n         XC    REPLYECB,REPLYECB            CLEAR THE ECB\n         XC    REPLY,REPLY                  CLEAR THE REPLY\n         STCM  R7,B'0011',MESSLEN           MESSAGE LENGTH\n         MVC   TOKENDOM,=CL4'ACE3'          DOM TOKEN\n         MVC   KEYID,=CL8'ACE3'             KEY\nWTORMESS EQU   *\n         WTOR  TEXT=(MESSARA,REPLY,REPLYLEN,REPLYECB),                 X\n               RPLYISUR=RISUR,KEY=KEYID,TOKEN=TOKENDOM,                X\n               MF=(E,WTORARA,EXTENDED)\n         LTR   R15,R15                      SUCCESSFUL WTOR?\n         BZ    WAITRPLY                    YES- LET'S WAIT FOR A REPLY?\n         BCT   R8,ENDMESS                   DO WHILE R8 > 0?\n         B     WTORERR                      LET'S GIVE UP\nWAITRPLY EQU   *\n         WAIT  ECB=REPLYECB                 LET'S WAIT A BIT?\n         CLI   REPLY,YES                    CAN WE PROCEED?\n         BNE   WTORMAX                      NO- IT'S ONLY 1 CHARACTER\n         TM    OPTION,WTOR                  WTOR OPTION?\n         BNO   REINIT                       NO-\n         BAL   R2,CLOSE                     LET'S CLOSE THE FILE\n         B     RETURN                       AND LET THE NEXT STEPS RUN\nREINIT   EQU   *\n         ICM   R3,B'1111',INPBUFF@          INPUT BUFFER @\n         ICM   R4,B'1111',SYSINRCS          NO OF RECORDS TO SCAN\nRESET    EQU   *\n         MVI   JOBIND,ZERO                  RESET INDICATOR\n         LA    R3,L'JBNME+L'JOBIND(,R3)     NEXT BUFFER ENTRY\n         BCT   R4,RESET                     DO WHILE R4 > 0?\n         B     ASIDSCAN                     KEEP CHECKING\n         TITLE 'CLOSE MESSAGE DATASET'\nCLOSE    EQU   *\n         LA    R1,CLOSEARA                  @ THE OPEN AREA CB\n         LA    R7,DISKDCB                   ADDR OF DCB BEFORE CLOSE\n         CLOSE ((R7)),MODE=31,MF=(E,(R1))   CLOSE DISK DATASET\n         BR    R2                           RETURN TO CALLER\n         TITLE 'LETS RETURN TO THE INITIATOR'\nRETURN   EQU   *\n         LAE   R1,0(R13,0)                  ADDRESS TO FREE\n         STORAGE RELEASE,ADDR=(R1),LENGTH=WORKALEN,SP=0,KEY=8,         X\n               COND=NO,RELATED=(GETWORK,'OBTAIN WORK AREA')\n         SLR   R15,R15                      SET RC TO ZERO\n         PR                                 RESTORE CALLER'S AR'S\n*                                           GPR'S 2-14 AND RETURN\n*                                           TO CALLER\n         TITLE 'ERROR SECTION'\nOPENERR1 EQU   *\n         ABEND 001,DUMP                     OPEN ERROR MESSAGES\nOPENERR2 EQU   *\n         ABEND 002,DUMP                     OPEN ERROR PARMLIB\nNOMESS   EQU   *\n         BAS   R2,CLOSE                     CLOSE DATASET\n         LAE   R1,0(R13,0)                  ADDRESS TO FREE\n         STORAGE RELEASE,ADDR=(R1),LENGTH=WORKALEN,SP=0,KEY=8,         X\n               COND=NO,RELATED=(GETWORK,'OBTAIN WORK AREA')\n         LA    R15,MESSNO                   SET RC TO NO MESSAGE\n         PR                                 RESTORE CALLER'S AR'S\n*                                           GPR'S 2-14 AND RETURN\n*                                           TO CALLER\nWTORERR  EQU   *\n         BAS   R2,CLOSE                     CLOSE DATASET\n         LAE   R1,0(R13,0)                  ADDRESS TO FREE\n         STORAGE RELEASE,ADDR=(R1),LENGTH=WORKALEN,SP=0,KEY=8,         X\n               COND=NO,RELATED=(GETWORK,'OBTAIN WORK AREA')\n         LA    R15,WTOPROB                  SET RC TO WTO PROBLEM\n         PR                                 RESTORE CALLER'S AR'S\n*                                           GPR'S 2-14 AND RETURN\n*                                           TO CALLER\nPARMERR  EQU   *\n         LAE   R1,0(R13,0)                  ADDRESS TO FREE\n         STORAGE RELEASE,ADDR=(R1),LENGTH=WORKALEN,SP=0,KEY=8,         X\n               COND=NO,RELATED=(GETWORK,'OBTAIN WORK AREA')\n         LA    R15,PARMER                   SET RC TO PARM ERROR\n         PR                                 RESTORE CALLER'S AR'S\n*                                           GPR'S 2-14 AND RETURN\n*                                           TO CALLER\n         LTORG\nDISKDCB  DCB   DDNAME=MESSAGES,DSORG=PS,MACRF=GM,EODAD=NOMESS\nDDCBLEN  EQU *-DISKDCB                      DCB  MACRO LENGTH\nJOBNAME  DCB   DDNAME=PARMLIB,DSORG=PS,MACRF=GM,EODAD=JEOD\nJDCBLEN  EQU *-JOBNAME                      DCB  MACRO LENGTH\nOPENLST  OPEN  (,,,),MF=L,MODE=31\nOPENLEN  EQU *-OPENLST                      OPEN MACRO LENGTH\nOPENLST2 OPEN  (,),MF=L,MODE=31\nOPENLEN2 EQU *-OPENLST2                     OPEN MACRO LENGTH\nOPENLST3 OPEN  (,),MF=L,MODE=31\nOPENLEN3 EQU *-OPENLST3                     OPEN MACRO LENGTH\nCLOSELST CLOSE (,),MF=L,MODE=31\nCLOSELEN EQU *-CLOSELST                     OPEN MACRO LENGTH\nWTORLIST WTOR  TEXT=(,,,),ROUTCDE=(2),RPLYISUR=,KEY=,TOKEN=,MF=L\nWTORLEN  EQU *-WTORLIST                     WTOR LIST LENGTH\nWORKAREA DSECT\nSAVEAREA DS    CL72                         SAVEAREA\nPREVSA   EQU   SAVEAREA+4,4                 @ OF PREVIOUS SAVEAREA\nOPTION   DS    X                            OPTION BYTE\n         DS    0F                           ALIGNMENT\nRISUR    DS    CL12                         CONSOLE NAME AND ID\nKEYID    DS    CL8                           USEFUL WITH D R COMMAND\nTOKENDOM DS    CL4                           TOKEN FOR DOM MACRO\nREPLYECB DS    F                             REPLY ECB\nREPLY    DS    C                             REPLY AREA\n         DS    0F                            ALIGNMENT\nSYSINRCS DS    AL4                           NO OF SYSIN RECORDS READ\nINPBUFF@ DS    AL4                           SYSIN BUFFER @\nIBUFLEN  DS    AL4                           BUFFER LENGTH\n         DS    0F                            ALIGNMENT\nDDCB     DS    CL(DDCBLEN)                   DISK DCB AREA\n         DS    0F                            ALIGNMENT\nJDCB     DS    CL(JDCBLEN)                   DISK DCB AREA\n         DS    0F                            ALIGNMENT\nOPENARA  DS    CL(OPENLEN)                   OPEN AREA\n         DS    0F                            ALIGNMENT\nOPENARA2 DS    CL(OPENLEN2)                  OPEN AREA\n         DS    0F                            ALIGNMENT\nOPENARA3 DS    CL(OPENLEN3)                  OPEN AREA\n         DS    0F                            ALIGNMENT\nCLOSEARA DS    CL(CLOSELEN)                  CLOSE AREA\n         DS    0F                            ALIGNMENT\nWTORARA  DS    CL(WTORLEN)                   WTOR AREA\nMESSARA  DS    0CL102                        MAXIMUM MESSAGE AREA\nMESSLEN  DS    XL2                           MESSAGE LENGTH\nMESSAGE  DS    CL100                         MAXIMUM MESSAGE\nJOBNME   DS    CL80                          JOBNAME AREA\nJNAME    EQU   JOBNME,8                      JOBNAME\nWORKALEN EQU   *-WORKAREA                    WORK AREA LENGTH\nJOBDSECT DSECT\nJBNME    DS    CL8                           JOBNAME\nJOBIND   DS    XL1                           JOB FOUND INDICATOR\n         DCBD  DSORG=PS,DEVD=DA\n         CVT   DSECT=YES\n         IHAASCB DSECT=YES\n         IHAASVT DSECT=YES\n         YREGS\n         END\n\n\nR F Perretta\nSenior Systems Programmer (UK)                                               c X\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "WTOPROGN": {"ttr": 6661, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x19\\x01\\x19\\x08\\x1f\\x01\\x19\\x08\\x9f\"\\x05\\x00\\x10\\x00\\x08\\x00\\x00\\xc5\\xe7\\xc1\\xd4\\xd7\\xd3\\xc5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2019-03-22T00:00:00", "modifydate": "2019-03-30T22:05:19", "lines": 16, "newlines": 8, "modlines": 0, "user": "EXAMPLE"}, "text": "//SBGOLOBM JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//* --------------------------------------------------------- *//\n//*   Send a message to the console. The operator must reply  *//\n//*   Y to the message, in order for the job to continue.     *//\n//* --------------------------------------------------------- *//\n//INACTIVE EXEC PGM=WTOPROG,PARM='M'\n//STEPLIB  DD   DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSPRINT DD   SYSOUT=*\n//SYSUDUMP DD   SYSOUT=*\n//MESSAGES DD   DATA,DLM=XW       (contains a message)\nIs TSSO not present in this system now?\nXW\n//PARMLIB  DD   DATA,DLM=KG       (contains a list of jobnames)\nTSSO\nKG\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "WTOPROGW": {"ttr": 6663, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x10\\x01\\x19\\x08\\x1f\\x01\\x19\\x08\\x9f\"\\x03\\x00\\r\\x00\\x08\\x00\\x00\\xc5\\xe7\\xc1\\xd4\\xd7\\xd3\\xc5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2019-03-22T00:00:00", "modifydate": "2019-03-30T22:03:10", "lines": 13, "newlines": 8, "modlines": 0, "user": "EXAMPLE"}, "text": "//SBGOLOBW JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//* --------------------------------------------------------- *//\n//*   Send a message to the console. The operator must reply  *//\n//*   Y to the message, in order for the job to continue.     *//\n//* --------------------------------------------------------- *//\n//WRITEMSG EXEC PGM=WTOPROG,PARM='W'\n//STEPLIB  DD   DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSPRINT DD   SYSOUT=*\n//SYSUDUMP DD   SYSOUT=*\n//MESSAGES DD   DATA,DLM=XW\nWill you answer this test message?\nXW\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "WTOPROGY": {"ttr": 6665, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00C\\x01\\x19\\x08\\x1f\\x01\\x19\\x08\\x9f\"\\x02\\x00\\x10\\x00\\x08\\x00\\x00\\xc5\\xe7\\xc1\\xd4\\xd7\\xd3\\xc5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2019-03-22T00:00:00", "modifydate": "2019-03-30T22:02:43", "lines": 16, "newlines": 8, "modlines": 0, "user": "EXAMPLE"}, "text": "//SBGOLOBM JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//* --------------------------------------------------------- *//\n//*   Send a message to the console. The operator must reply  *//\n//*   Y to the message, in order for the job to continue.     *//\n//* --------------------------------------------------------- *//\n//ACTIVE   EXEC PGM=WTOPROG\n//STEPLIB  DD   DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSPRINT DD   SYSOUT=*\n//SYSUDUMP DD   SYSOUT=*\n//MESSAGES DD   DATA,DLM=XW\nIs TSSO present in this system now?\nXW\n//PARMLIB  DD   DATA,DLM=KG\nTSSO\nKG\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZTDM": {"ttr": 6667, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x07\\x01\\x19\\t\\x1f\\x01\\x19\\t\\x1f\\x19\\x18\\x00\\x04\\x00\\x02\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2019-04-01T00:00:00", "modifydate": "2019-04-01T19:18:07", "lines": 4, "newlines": 2, "modlines": 0, "user": "REXX"}, "text": "/*  rexx  */\nztdmark= '******************************* Bottom of Data ***********************\n*********'\nADDRESS \"ISPEXEC\" \"VPUT (ztdmark) SHARED\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT836/FILE836.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT836", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}